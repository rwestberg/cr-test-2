<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderLayerBacking.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="RenderLayer.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="RenderLayerBacking.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderLayerBacking.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 32,10 ***</span>
<span class="line-new-header">--- 32,11 ---</span>
  #include &quot;CanvasRenderingContext.h&quot;
  #include &quot;CSSPropertyNames.h&quot;
  #include &quot;CachedImage.h&quot;
  #include &quot;Chrome.h&quot;
  #include &quot;DocumentTimeline.h&quot;
<span class="line-added">+ #include &quot;EventRegion.h&quot;</span>
  #include &quot;Frame.h&quot;
  #include &quot;FrameView.h&quot;
  #include &quot;GraphicsContext.h&quot;
  #include &quot;GraphicsLayer.h&quot;
  #include &quot;HTMLBodyElement.h&quot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 44,10 ***</span>
<span class="line-new-header">--- 45,11 ---</span>
  #include &quot;HTMLMediaElement.h&quot;
  #include &quot;HTMLNames.h&quot;
  #include &quot;HTMLPlugInElement.h&quot;
  #include &quot;InspectorInstrumentation.h&quot;
  #include &quot;KeyframeList.h&quot;
<span class="line-added">+ #include &quot;LayerAncestorClippingStack.h&quot;</span>
  #include &quot;Logging.h&quot;
  #include &quot;Page.h&quot;
  #include &quot;PerformanceLoggingClient.h&quot;
  #include &quot;PluginViewBase.h&quot;
  #include &quot;ProgressTracker.h&quot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 235,11 ***</span>
  }
  
  RenderLayerBacking::~RenderLayerBacking()
  {
      // Note that m_owningLayer-&gt;backing() is null here.
<span class="line-modified">!     updateAncestorClippingLayer(false);</span>
      updateChildClippingStrategy(false);
      updateDescendantClippingLayer(false);
      updateOverflowControlsLayers(false, false, false);
      updateForegroundLayer(false);
      updateBackgroundLayer(false);
<span class="line-new-header">--- 237,11 ---</span>
  }
  
  RenderLayerBacking::~RenderLayerBacking()
  {
      // Note that m_owningLayer-&gt;backing() is null here.
<span class="line-modified">!     updateAncestorClipping(false, nullptr);</span>
      updateChildClippingStrategy(false);
      updateDescendantClippingLayer(false);
      updateOverflowControlsLayers(false, false, false);
      updateForegroundLayer(false);
      updateBackgroundLayer(false);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 247,26 ***</span>
<span class="line-new-header">--- 249,83 ---</span>
      updateScrollingLayers(false);
  
      ASSERT(!m_viewportConstrainedNodeID);
      ASSERT(!m_scrollingNodeID);
      ASSERT(!m_frameHostingNodeID);
<span class="line-added">+     ASSERT(!m_positioningNodeID);</span>
  
      destroyGraphicsLayers();
  }
  
  void RenderLayerBacking::willBeDestroyed()
  {
      ASSERT(m_owningLayer.backing() == this);
      compositor().removeFromScrollCoordinatedLayers(m_owningLayer);
<span class="line-added">+ </span>
<span class="line-added">+     clearBackingSharingLayers();</span>
  }
  
  void RenderLayerBacking::willDestroyLayer(const GraphicsLayer* layer)
  {
      if (layer &amp;&amp; layer-&gt;type() == GraphicsLayer::Type::Normal &amp;&amp; layer-&gt;tiledBacking())
          compositor().layerTiledBackingUsageChanged(layer, false);
  }
  
<span class="line-added">+ static void clearBackingSharingLayerProviders(Vector&lt;WeakPtr&lt;RenderLayer&gt;&gt;&amp; sharingLayers)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     for (auto&amp; layerWeakPtr : sharingLayers) {</span>
<span class="line-added">+         if (!layerWeakPtr)</span>
<span class="line-added">+             continue;</span>
<span class="line-added">+         layerWeakPtr-&gt;setBackingProviderLayer(nullptr);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void RenderLayerBacking::setBackingSharingLayers(Vector&lt;WeakPtr&lt;RenderLayer&gt;&gt;&amp;&amp; sharingLayers)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     bool sharingLayersChanged = m_backingSharingLayers != sharingLayers;</span>
<span class="line-added">+     if (sharingLayersChanged) {</span>
<span class="line-added">+         // For layers that used to share and no longer do, and are not composited, recompute repaint rects.</span>
<span class="line-added">+         for (auto&amp; oldSharingLayer : m_backingSharingLayers) {</span>
<span class="line-added">+             // Layers that go from shared to composited have their repaint rects recomputed in RenderLayerCompositor::updateBacking().</span>
<span class="line-added">+             // FIXME: Two O(n^2) traversals in this funtion. Probably OK because sharing lists are usually small, but still.</span>
<span class="line-added">+             if (!sharingLayers.contains(oldSharingLayer) &amp;&amp; !oldSharingLayer-&gt;isComposited())</span>
<span class="line-added">+                 oldSharingLayer-&gt;computeRepaintRectsIncludingDescendants();</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     clearBackingSharingLayerProviders(m_backingSharingLayers);</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (sharingLayers != m_backingSharingLayers)</span>
<span class="line-added">+         setContentsNeedDisplay(); // This could be optimized to only repaint rects for changed layers.</span>
<span class="line-added">+ </span>
<span class="line-added">+     auto oldSharingLayers = WTFMove(m_backingSharingLayers);</span>
<span class="line-added">+     m_backingSharingLayers = WTFMove(sharingLayers);</span>
<span class="line-added">+ </span>
<span class="line-added">+     for (auto&amp; layerWeakPtr : m_backingSharingLayers)</span>
<span class="line-added">+         layerWeakPtr-&gt;setBackingProviderLayer(&amp;m_owningLayer);</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (sharingLayersChanged) {</span>
<span class="line-added">+         // For layers that are newly sharing, recompute repaint rects.</span>
<span class="line-added">+         for (auto&amp; currentSharingLayer : m_backingSharingLayers) {</span>
<span class="line-added">+             if (!oldSharingLayers.contains(currentSharingLayer))</span>
<span class="line-added">+                 currentSharingLayer-&gt;computeRepaintRectsIncludingDescendants();</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void RenderLayerBacking::removeBackingSharingLayer(RenderLayer&amp; layer)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     layer.setBackingProviderLayer(nullptr);</span>
<span class="line-added">+     m_backingSharingLayers.removeAll(&amp;layer);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void RenderLayerBacking::clearBackingSharingLayers()</span>
<span class="line-added">+ {</span>
<span class="line-added">+     clearBackingSharingLayerProviders(m_backingSharingLayers);</span>
<span class="line-added">+     m_backingSharingLayers.clear();</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  Ref&lt;GraphicsLayer&gt; RenderLayerBacking::createGraphicsLayer(const String&amp; name, GraphicsLayer::Type layerType)
  {
      auto* graphicsLayerFactory = renderer().page().chrome().client().graphicsLayerFactory();
  
      auto graphicsLayer = GraphicsLayer::create(graphicsLayerFactory, *this, layerType);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 315,19 ***</span>
  TiledBacking* RenderLayerBacking::tiledBacking() const
  {
      return m_graphicsLayer-&gt;tiledBacking();
  }
  
<span class="line-modified">! static TiledBacking::TileCoverage computePageTiledBackingCoverage(RenderLayerBacking* backing)</span>
  {
<span class="line-removed">-     // FIXME: When we use TiledBacking for overflow, this should look at RenderView scrollability.</span>
<span class="line-removed">-     auto&amp; frameView = backing-&gt;owningLayer().renderer().view().frameView();</span>
<span class="line-removed">- </span>
      // If the page is non-visible, don&#39;t incur the cost of keeping extra tiles for scrolling.
<span class="line-modified">!     if (!backing-&gt;owningLayer().page().isVisible())</span>
          return TiledBacking::CoverageForVisibleArea;
  
      TiledBacking::TileCoverage tileCoverage = TiledBacking::CoverageForVisibleArea;
      bool useMinimalTilesDuringLiveResize = frameView.inLiveResize();
      if (frameView.speculativeTilingEnabled() &amp;&amp; !useMinimalTilesDuringLiveResize) {
          bool clipsToExposedRect = static_cast&lt;bool&gt;(frameView.viewExposedRect());
          if (frameView.horizontalScrollbarMode() != ScrollbarAlwaysOff || clipsToExposedRect)
<span class="line-new-header">--- 374,18 ---</span>
  TiledBacking* RenderLayerBacking::tiledBacking() const
  {
      return m_graphicsLayer-&gt;tiledBacking();
  }
  
<span class="line-modified">! static TiledBacking::TileCoverage computePageTiledBackingCoverage(const RenderLayer&amp; layer)</span>
  {
      // If the page is non-visible, don&#39;t incur the cost of keeping extra tiles for scrolling.
<span class="line-modified">!     if (!layer.page().isVisible())</span>
          return TiledBacking::CoverageForVisibleArea;
  
<span class="line-added">+     auto&amp; frameView = layer.renderer().view().frameView();</span>
<span class="line-added">+ </span>
      TiledBacking::TileCoverage tileCoverage = TiledBacking::CoverageForVisibleArea;
      bool useMinimalTilesDuringLiveResize = frameView.inLiveResize();
      if (frameView.speculativeTilingEnabled() &amp;&amp; !useMinimalTilesDuringLiveResize) {
          bool clipsToExposedRect = static_cast&lt;bool&gt;(frameView.viewExposedRect());
          if (frameView.horizontalScrollbarMode() != ScrollbarAlwaysOff || clipsToExposedRect)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 337,17 ***</span>
              tileCoverage |= TiledBacking::CoverageForVerticalScrolling;
      }
      return tileCoverage;
  }
  
  void RenderLayerBacking::adjustTiledBackingCoverage()
  {
<span class="line-modified">!     if (!m_isFrameLayerWithTiledBacking)</span>
<span class="line-modified">!         return;</span>
  
<span class="line-modified">!     TiledBacking::TileCoverage tileCoverage = computePageTiledBackingCoverage(this);</span>
<span class="line-modified">!     tiledBacking()-&gt;setTileCoverage(tileCoverage);</span>
  }
  
  void RenderLayerBacking::setTiledBackingHasMargins(bool hasExtendedBackgroundOnLeftAndRight, bool hasExtendedBackgroundOnTopAndBottom)
  {
      if (!m_isFrameLayerWithTiledBacking)
<span class="line-new-header">--- 395,44 ---</span>
              tileCoverage |= TiledBacking::CoverageForVerticalScrolling;
      }
      return tileCoverage;
  }
  
<span class="line-added">+ static TiledBacking::TileCoverage computeOverflowTiledBackingCoverage(const RenderLayer&amp; layer)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     // If the page is non-visible, don&#39;t incur the cost of keeping extra tiles for scrolling.</span>
<span class="line-added">+     if (!layer.page().isVisible())</span>
<span class="line-added">+         return TiledBacking::CoverageForVisibleArea;</span>
<span class="line-added">+ </span>
<span class="line-added">+     auto&amp; frameView = layer.renderer().view().frameView();</span>
<span class="line-added">+ </span>
<span class="line-added">+     TiledBacking::TileCoverage tileCoverage = TiledBacking::CoverageForVisibleArea;</span>
<span class="line-added">+     bool useMinimalTilesDuringLiveResize = frameView.inLiveResize();</span>
<span class="line-added">+     if (!useMinimalTilesDuringLiveResize) {</span>
<span class="line-added">+         if (layer.hasScrollableHorizontalOverflow())</span>
<span class="line-added">+             tileCoverage |= TiledBacking::CoverageForHorizontalScrolling;</span>
<span class="line-added">+ </span>
<span class="line-added">+         if (layer.hasScrollableVerticalOverflow())</span>
<span class="line-added">+             tileCoverage |= TiledBacking::CoverageForVerticalScrolling;</span>
<span class="line-added">+     }</span>
<span class="line-added">+     return tileCoverage;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  void RenderLayerBacking::adjustTiledBackingCoverage()
  {
<span class="line-modified">!     if (m_isFrameLayerWithTiledBacking) {</span>
<span class="line-modified">!         auto tileCoverage = computePageTiledBackingCoverage(m_owningLayer);</span>
<span class="line-added">+         if (auto* tiledBacking = this-&gt;tiledBacking())</span>
<span class="line-added">+             tiledBacking-&gt;setTileCoverage(tileCoverage);</span>
<span class="line-added">+     }</span>
  
<span class="line-modified">!     if (m_owningLayer.hasCompositedScrollableOverflow() &amp;&amp; m_scrolledContentsLayer) {</span>
<span class="line-modified">!         if (auto* tiledBacking = m_scrolledContentsLayer-&gt;tiledBacking()) {</span>
<span class="line-added">+             auto tileCoverage = computeOverflowTiledBackingCoverage(m_owningLayer);</span>
<span class="line-added">+             tiledBacking-&gt;setTileCoverage(tileCoverage);</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
  }
  
  void RenderLayerBacking::setTiledBackingHasMargins(bool hasExtendedBackgroundOnLeftAndRight, bool hasExtendedBackgroundOnTopAndBottom)
  {
      if (!m_isFrameLayerWithTiledBacking)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 359,12 ***</span>
  void RenderLayerBacking::updateDebugIndicators(bool showBorder, bool showRepaintCounter)
  {
      m_graphicsLayer-&gt;setShowDebugBorder(showBorder);
      m_graphicsLayer-&gt;setShowRepaintCounter(showRepaintCounter);
  
<span class="line-modified">!     if (m_ancestorClippingLayer)</span>
<span class="line-modified">!         m_ancestorClippingLayer-&gt;setShowDebugBorder(showBorder);</span>
  
      if (m_foregroundLayer) {
          m_foregroundLayer-&gt;setShowDebugBorder(showBorder);
          m_foregroundLayer-&gt;setShowRepaintCounter(showRepaintCounter);
      }
<span class="line-new-header">--- 444,14 ---</span>
  void RenderLayerBacking::updateDebugIndicators(bool showBorder, bool showRepaintCounter)
  {
      m_graphicsLayer-&gt;setShowDebugBorder(showBorder);
      m_graphicsLayer-&gt;setShowRepaintCounter(showRepaintCounter);
  
<span class="line-modified">!     if (m_ancestorClippingStack) {</span>
<span class="line-modified">!         for (auto&amp; entry : m_ancestorClippingStack-&gt;stack())</span>
<span class="line-added">+             entry.clippingLayer-&gt;setShowDebugBorder(showBorder);</span>
<span class="line-added">+     }</span>
  
      if (m_foregroundLayer) {
          m_foregroundLayer-&gt;setShowDebugBorder(showBorder);
          m_foregroundLayer-&gt;setShowRepaintCounter(showRepaintCounter);
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 474,11 ***</span>
          willDestroyLayer(m_graphicsLayer.get());
      }
  
      GraphicsLayer::clear(m_maskLayer);
  
<span class="line-modified">!     GraphicsLayer::unparentAndClear(m_ancestorClippingLayer);</span>
      GraphicsLayer::unparentAndClear(m_contentsContainmentLayer);
      GraphicsLayer::unparentAndClear(m_foregroundLayer);
      GraphicsLayer::unparentAndClear(m_backgroundLayer);
      GraphicsLayer::unparentAndClear(m_childContainmentLayer);
      GraphicsLayer::unparentAndClear(m_childClippingMaskLayer);
<span class="line-new-header">--- 561,15 ---</span>
          willDestroyLayer(m_graphicsLayer.get());
      }
  
      GraphicsLayer::clear(m_maskLayer);
  
<span class="line-modified">!     if (m_ancestorClippingStack) {</span>
<span class="line-added">+         for (auto&amp; entry : m_ancestorClippingStack-&gt;stack())</span>
<span class="line-added">+             GraphicsLayer::unparentAndClear(entry.clippingLayer);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      GraphicsLayer::unparentAndClear(m_contentsContainmentLayer);
      GraphicsLayer::unparentAndClear(m_foregroundLayer);
      GraphicsLayer::unparentAndClear(m_backgroundLayer);
      GraphicsLayer::unparentAndClear(m_childContainmentLayer);
      GraphicsLayer::unparentAndClear(m_childClippingMaskLayer);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 503,11 ***</span>
          makeMatrixRenderable(t, compositor().canRender3DTransforms());
      }
  
      if (m_contentsContainmentLayer) {
          m_contentsContainmentLayer-&gt;setTransform(t);
<span class="line-modified">!         m_graphicsLayer-&gt;setTransform(TransformationMatrix());</span>
      } else
          m_graphicsLayer-&gt;setTransform(t);
  }
  
  void RenderLayerBacking::updateFilters(const RenderStyle&amp; style)
<span class="line-new-header">--- 594,11 ---</span>
          makeMatrixRenderable(t, compositor().canRender3DTransforms());
      }
  
      if (m_contentsContainmentLayer) {
          m_contentsContainmentLayer-&gt;setTransform(t);
<span class="line-modified">!         m_graphicsLayer-&gt;setTransform({ });</span>
      } else
          m_graphicsLayer-&gt;setTransform(t);
  }
  
  void RenderLayerBacking::updateFilters(const RenderStyle&amp; style)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 531,11 ***</span>
  
      auto&amp; renderer = downcast&lt;RenderBox&gt;(this-&gt;renderer());
      LayoutRect boxRect = renderer.borderBoxRect();
      if (renderer.hasClip())
          boxRect.intersect(renderer.clipRect(LayoutPoint(), nullptr));
<span class="line-modified">!     boxRect.move(contentOffsetInCompostingLayer());</span>
  
      FloatRoundedRect backdropFiltersRect;
      if (renderer.style().hasBorderRadius() &amp;&amp; !renderer.hasClip())
          backdropFiltersRect = renderer.style().getRoundedInnerBorderFor(boxRect).pixelSnappedRoundedRectForPainting(deviceScaleFactor());
      else
<span class="line-new-header">--- 622,11 ---</span>
  
      auto&amp; renderer = downcast&lt;RenderBox&gt;(this-&gt;renderer());
      LayoutRect boxRect = renderer.borderBoxRect();
      if (renderer.hasClip())
          boxRect.intersect(renderer.clipRect(LayoutPoint(), nullptr));
<span class="line-modified">!     boxRect.move(contentOffsetInCompositingLayer());</span>
  
      FloatRoundedRect backdropFiltersRect;
      if (renderer.style().hasBorderRadius() &amp;&amp; !renderer.hasClip())
          backdropFiltersRect = renderer.style().getRoundedInnerBorderFor(boxRect).pixelSnappedRoundedRectForPainting(deviceScaleFactor());
      else
</pre>
<hr />
<pre>
<span class="line-old-header">*** 546,13 ***</span>
  #endif
  
  #if ENABLE(CSS_COMPOSITING)
  void RenderLayerBacking::updateBlendMode(const RenderStyle&amp; style)
  {
<span class="line-modified">!     // FIXME: where is the blend mode updated when m_ancestorClippingLayers come and go?</span>
<span class="line-modified">!     if (m_ancestorClippingLayer) {</span>
<span class="line-modified">!         m_ancestorClippingLayer-&gt;setBlendMode(style.blendMode());</span>
          m_graphicsLayer-&gt;setBlendMode(BlendMode::Normal);
      } else
          m_graphicsLayer-&gt;setBlendMode(style.blendMode());
  }
  #endif
<span class="line-new-header">--- 637,13 ---</span>
  #endif
  
  #if ENABLE(CSS_COMPOSITING)
  void RenderLayerBacking::updateBlendMode(const RenderStyle&amp; style)
  {
<span class="line-modified">!     // FIXME: where is the blend mode updated when m_ancestorClippingStacks come and go?</span>
<span class="line-modified">!     if (m_ancestorClippingStack) {</span>
<span class="line-modified">!         m_ancestorClippingStack-&gt;stack().first().clippingLayer-&gt;setBlendMode(style.blendMode());</span>
          m_graphicsLayer-&gt;setBlendMode(BlendMode::Normal);
      } else
          m_graphicsLayer-&gt;setBlendMode(style.blendMode());
  }
  #endif
</pre>
<hr />
<pre>
<span class="line-old-header">*** 602,11 ***</span>
          || (style.transformOriginY().type() == Fixed &amp;&amp; style.transformOriginY().value());
  }
  
  bool RenderLayerBacking::updateCompositedBounds()
  {
<span class="line-modified">!     LayoutRect layerBounds = m_owningLayer.calculateLayerBounds(&amp;m_owningLayer, LayoutSize(), RenderLayer::defaultCalculateLayerBoundsFlags() | RenderLayer::ExcludeHiddenDescendants | RenderLayer::DontConstrainForMask);</span>
      // Clip to the size of the document or enclosing overflow-scroll layer.
      // If this or an ancestor is transformed, we can&#39;t currently compute the correct rect to intersect with.
      // We&#39;d need RenderObject::convertContainerToLocalQuad(), which doesn&#39;t yet exist.
      if (shouldClipCompositedBounds()) {
          auto&amp; view = renderer().view();
<span class="line-new-header">--- 693,11 ---</span>
          || (style.transformOriginY().type() == Fixed &amp;&amp; style.transformOriginY().value());
  }
  
  bool RenderLayerBacking::updateCompositedBounds()
  {
<span class="line-modified">!     LayoutRect layerBounds = m_owningLayer.calculateLayerBounds(&amp;m_owningLayer, { }, RenderLayer::defaultCalculateLayerBoundsFlags() | RenderLayer::ExcludeHiddenDescendants | RenderLayer::DontConstrainForMask);</span>
      // Clip to the size of the document or enclosing overflow-scroll layer.
      // If this or an ancestor is transformed, we can&#39;t currently compute the correct rect to intersect with.
      // We&#39;d need RenderObject::convertContainerToLocalQuad(), which doesn&#39;t yet exist.
      if (shouldClipCompositedBounds()) {
          auto&amp; view = renderer().view();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 625,10 ***</span>
<span class="line-new-header">--- 716,21 ---</span>
          clippingBounds.move(-delta.x(), -delta.y());
  
          layerBounds.intersect(clippingBounds);
      }
  
<span class="line-added">+     // If the backing provider has overflow:clip, we know all sharing layers are affected by the clip because they are containing-block descendants.</span>
<span class="line-added">+     if (!renderer().hasOverflowClip()) {</span>
<span class="line-added">+         for (auto&amp; layerWeakPtr : m_backingSharingLayers) {</span>
<span class="line-added">+             auto* boundsRootLayer = &amp;m_owningLayer;</span>
<span class="line-added">+             ASSERT(layerWeakPtr-&gt;isDescendantOf(m_owningLayer));</span>
<span class="line-added">+             auto offset = layerWeakPtr-&gt;offsetFromAncestor(&amp;m_owningLayer);</span>
<span class="line-added">+             auto bounds = layerWeakPtr-&gt;calculateLayerBounds(boundsRootLayer, offset, RenderLayer::defaultCalculateLayerBoundsFlags() | RenderLayer::ExcludeHiddenDescendants | RenderLayer::DontConstrainForMask);</span>
<span class="line-added">+             layerBounds.unite(bounds);</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      // If the element has a transform-origin that has fixed lengths, and the renderer has zero size,
      // then we need to ensure that the compositing layer has non-zero size so that we can apply
      // the transform-origin via the GraphicsLayer anchorPoint (which is expressed as a fractional value).
      if (layerBounds.isEmpty() &amp;&amp; (hasNonZeroTransformOrigin(renderer()) || renderer().style().hasPerspective())) {
          layerBounds.setWidth(1);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 638,10 ***</span>
<span class="line-new-header">--- 740,41 ---</span>
          m_artificiallyInflatedBounds = false;
  
      return setCompositedBounds(layerBounds);
  }
  
<span class="line-added">+ void RenderLayerBacking::updateAllowsBackingStoreDetaching(const LayoutRect&amp; absoluteBounds)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     auto setAllowsBackingStoreDetaching = [&amp;](bool allowDetaching) {</span>
<span class="line-added">+         m_graphicsLayer-&gt;setAllowsBackingStoreDetaching(allowDetaching);</span>
<span class="line-added">+         if (m_foregroundLayer)</span>
<span class="line-added">+             m_foregroundLayer-&gt;setAllowsBackingStoreDetaching(allowDetaching);</span>
<span class="line-added">+         if (m_backgroundLayer)</span>
<span class="line-added">+             m_backgroundLayer-&gt;setAllowsBackingStoreDetaching(allowDetaching);</span>
<span class="line-added">+         if (m_scrolledContentsLayer)</span>
<span class="line-added">+             m_scrolledContentsLayer-&gt;setAllowsBackingStoreDetaching(allowDetaching);</span>
<span class="line-added">+     };</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (!m_owningLayer.behavesAsFixed()) {</span>
<span class="line-added">+         setAllowsBackingStoreDetaching(true);</span>
<span class="line-added">+         return;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     // We&#39;ll allow detaching if the layer is outside the layout viewport. Fixed layers inside</span>
<span class="line-added">+     // the layout viewport can be revealed by async scrolling, so we want to pin their backing store.</span>
<span class="line-added">+     FrameView&amp; frameView = renderer().view().frameView();</span>
<span class="line-added">+     LayoutRect fixedLayoutRect;</span>
<span class="line-added">+     if (frameView.useFixedLayout())</span>
<span class="line-added">+         fixedLayoutRect = renderer().view().unscaledDocumentRect();</span>
<span class="line-added">+     else</span>
<span class="line-added">+         fixedLayoutRect = frameView.rectForFixedPositionLayout();</span>
<span class="line-added">+ </span>
<span class="line-added">+     bool allowDetaching = !fixedLayoutRect.intersects(absoluteBounds);</span>
<span class="line-added">+     LOG_WITH_STREAM(Compositing, stream &lt;&lt; &quot;RenderLayerBacking (layer &quot; &lt;&lt; &amp;m_owningLayer &lt;&lt; &quot;) updateAllowsBackingStoreDetaching - absoluteBounds &quot; &lt;&lt; absoluteBounds &lt;&lt; &quot; layoutViewportRect &quot; &lt;&lt; fixedLayoutRect &lt;&lt; &quot;, allowDetaching &quot; &lt;&lt; allowDetaching);</span>
<span class="line-added">+     setAllowsBackingStoreDetaching(allowDetaching);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  void RenderLayerBacking::updateAfterWidgetResize()
  {
      if (!is&lt;RenderWidget&gt;(renderer()))
          return;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 649,21 ***</span>
          innerCompositor-&gt;frameViewDidChangeSize();
          innerCompositor-&gt;frameViewDidChangeLocation(flooredIntPoint(contentsBox().location()));
      }
  }
  
<span class="line-modified">! void RenderLayerBacking::updateAfterLayout(bool needsFullRepaint)</span>
  {
      LOG(Compositing, &quot;RenderLayerBacking %p updateAfterLayout (layer %p)&quot;, this, &amp;m_owningLayer);
  
      // This is the main trigger for layout changing layer geometry, but we have to do the work again in updateBackingAndHierarchy()
      // when we know the final compositing hierarchy. We can&#39;t just set dirty bits from RenderLayer::setSize() because that doesn&#39;t
      // take overflow into account.
      if (updateCompositedBounds()) {
          m_owningLayer.setNeedsCompositingGeometryUpdate();
          // This layer&#39;s geometry affects those of its children.
          m_owningLayer.setChildrenNeedCompositingGeometryUpdate();
      }
  
      if (needsFullRepaint &amp;&amp; canIssueSetNeedsDisplay())
          setContentsNeedDisplay();
  }
<span class="line-new-header">--- 782,24 ---</span>
          innerCompositor-&gt;frameViewDidChangeSize();
          innerCompositor-&gt;frameViewDidChangeLocation(flooredIntPoint(contentsBox().location()));
      }
  }
  
<span class="line-modified">! void RenderLayerBacking::updateAfterLayout(bool needsClippingUpdate, bool needsFullRepaint)</span>
  {
      LOG(Compositing, &quot;RenderLayerBacking %p updateAfterLayout (layer %p)&quot;, this, &amp;m_owningLayer);
  
      // This is the main trigger for layout changing layer geometry, but we have to do the work again in updateBackingAndHierarchy()
      // when we know the final compositing hierarchy. We can&#39;t just set dirty bits from RenderLayer::setSize() because that doesn&#39;t
      // take overflow into account.
      if (updateCompositedBounds()) {
          m_owningLayer.setNeedsCompositingGeometryUpdate();
          // This layer&#39;s geometry affects those of its children.
          m_owningLayer.setChildrenNeedCompositingGeometryUpdate();
<span class="line-added">+     } else if (needsClippingUpdate) {</span>
<span class="line-added">+         m_owningLayer.setNeedsCompositingConfigurationUpdate();</span>
<span class="line-added">+         m_owningLayer.setNeedsCompositingGeometryUpdate();</span>
      }
  
      if (needsFullRepaint &amp;&amp; canIssueSetNeedsDisplay())
          setContentsNeedDisplay();
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 719,20 ***</span>
          // If it&#39;s scrollable, it has to be a box.
          auto&amp; renderBox = downcast&lt;RenderBox&gt;(renderer());
          FloatRoundedRect contentsClippingRect = renderer().style().getRoundedInnerBorderFor(renderBox.borderBoxRect()).pixelSnappedRoundedRectForPainting(deviceScaleFactor());
          needsDescendantsClippingLayer = contentsClippingRect.isRounded();
      } else
<span class="line-modified">!         needsDescendantsClippingLayer = compositor.clipsCompositingDescendants(m_owningLayer);</span>
  
      if (updateScrollingLayers(usesCompositedScrolling))
          layerConfigChanged = true;
  
      if (updateDescendantClippingLayer(needsDescendantsClippingLayer))
          layerConfigChanged = true;
  
<span class="line-modified">!     // clippedByAncestor() does a tree walk.</span>
<span class="line-modified">!     if (updateAncestorClippingLayer(compositor.clippedByAncestor(m_owningLayer)))</span>
          layerConfigChanged = true;
  
      if (updateOverflowControlsLayers(requiresHorizontalScrollbarLayer(), requiresVerticalScrollbarLayer(), requiresScrollCornerLayer()))
          layerConfigChanged = true;
  
<span class="line-new-header">--- 855,20 ---</span>
          // If it&#39;s scrollable, it has to be a box.
          auto&amp; renderBox = downcast&lt;RenderBox&gt;(renderer());
          FloatRoundedRect contentsClippingRect = renderer().style().getRoundedInnerBorderFor(renderBox.borderBoxRect()).pixelSnappedRoundedRectForPainting(deviceScaleFactor());
          needsDescendantsClippingLayer = contentsClippingRect.isRounded();
      } else
<span class="line-modified">!         needsDescendantsClippingLayer = RenderLayerCompositor::clipsCompositingDescendants(m_owningLayer);</span>
  
      if (updateScrollingLayers(usesCompositedScrolling))
          layerConfigChanged = true;
  
      if (updateDescendantClippingLayer(needsDescendantsClippingLayer))
          layerConfigChanged = true;
  
<span class="line-modified">!     auto* compositingAncestor = m_owningLayer.ancestorCompositingLayer();</span>
<span class="line-modified">!     if (updateAncestorClipping(compositor.clippedByAncestor(m_owningLayer, compositingAncestor), compositingAncestor))</span>
          layerConfigChanged = true;
  
      if (updateOverflowControlsLayers(requiresHorizontalScrollbarLayer(), requiresVerticalScrollbarLayer(), requiresScrollCornerLayer()))
          layerConfigChanged = true;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 742,11 ***</span>
      if (auto* flatteningLayer = tileCacheFlatteningLayer()) {
          if (layerConfigChanged || flatteningLayer-&gt;parent() != m_graphicsLayer.get())
              m_graphicsLayer-&gt;addChild(*flatteningLayer);
      }
  
<span class="line-modified">!     updateMaskingLayer(renderer().hasMask(), renderer().hasClipPath());</span>
  
      updateChildClippingStrategy(needsDescendantsClippingLayer);
  
      if (m_owningLayer.hasReflection()) {
          if (m_owningLayer.reflectionLayer()-&gt;backing()) {
<span class="line-new-header">--- 878,12 ---</span>
      if (auto* flatteningLayer = tileCacheFlatteningLayer()) {
          if (layerConfigChanged || flatteningLayer-&gt;parent() != m_graphicsLayer.get())
              m_graphicsLayer-&gt;addChild(*flatteningLayer);
      }
  
<span class="line-modified">!     if (updateMaskingLayer(renderer().hasMask(), renderer().hasClipPath()))</span>
<span class="line-added">+         layerConfigChanged = true;</span>
  
      updateChildClippingStrategy(needsDescendantsClippingLayer);
  
      if (m_owningLayer.hasReflection()) {
          if (m_owningLayer.reflectionLayer()-&gt;backing()) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 787,11 ***</span>
          m_graphicsLayer-&gt;setContentsToPlatformLayer(mediaElement-&gt;platformLayer(), GraphicsLayer::ContentsLayerPurpose::Media);
          // Requires layout.
          resetContentsRect();
      }
  #endif
<span class="line-modified">! #if ENABLE(WEBGL) || ENABLE(ACCELERATED_2D_CANVAS)</span>
      else if (renderer().isCanvas() &amp;&amp; canvasCompositingStrategy(renderer()) == CanvasAsLayerContents) {
          const HTMLCanvasElement* canvas = downcast&lt;HTMLCanvasElement&gt;(renderer().element());
          if (auto* context = canvas-&gt;renderingContext())
              m_graphicsLayer-&gt;setContentsToPlatformLayer(context-&gt;platformLayer(), GraphicsLayer::ContentsLayerPurpose::Canvas);
  
<span class="line-new-header">--- 924,11 ---</span>
          m_graphicsLayer-&gt;setContentsToPlatformLayer(mediaElement-&gt;platformLayer(), GraphicsLayer::ContentsLayerPurpose::Media);
          // Requires layout.
          resetContentsRect();
      }
  #endif
<span class="line-modified">! #if ENABLE(WEBGL) || ENABLE(ACCELERATED_2D_CANVAS) || ENABLE(WEBGPU)</span>
      else if (renderer().isCanvas() &amp;&amp; canvasCompositingStrategy(renderer()) == CanvasAsLayerContents) {
          const HTMLCanvasElement* canvas = downcast&lt;HTMLCanvasElement&gt;(renderer().element());
          if (auto* context = canvas-&gt;renderingContext())
              m_graphicsLayer-&gt;setContentsToPlatformLayer(context-&gt;platformLayer(), GraphicsLayer::ContentsLayerPurpose::Canvas);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 809,10 ***</span>
<span class="line-new-header">--- 946,13 ---</span>
              m_graphicsLayer-&gt;setContentsToEmbeddedView(GraphicsLayer::ContentsLayerEmbeddedViewType::EditableImage, downcast&lt;HTMLImageElement&gt;(element)-&gt;editableImageViewID());
              layerConfigChanged = true;
          }
      }
  
<span class="line-added">+     if (layerConfigChanged)</span>
<span class="line-added">+         updatePaintingPhases();</span>
<span class="line-added">+ </span>
      return layerConfigChanged;
  }
  
  static LayoutRect clipBox(RenderBox&amp; renderer)
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 868,11 ***</span>
      snappedGraphicsLayer.m_snappedRect = LayoutRect(snapRectToDevicePixels(graphicsLayerRect, deviceScaleFactor));
      snappedGraphicsLayer.m_snapDelta = snappedGraphicsLayer.m_snappedRect.location() - toLayoutPoint(offset);
      return snappedGraphicsLayer;
  }
  
<span class="line-modified">! static LayoutSize computeOffsetFromAncestorGraphicsLayer(RenderLayer* compositedAncestor, const LayoutPoint&amp; location, float deviceScaleFactor)</span>
  {
      if (!compositedAncestor)
          return toLayoutSize(location);
  
      // FIXME: This is a workaround until after webkit.org/162634 gets fixed. ancestorSubpixelOffsetFromRenderer
<span class="line-new-header">--- 1008,11 ---</span>
      snappedGraphicsLayer.m_snappedRect = LayoutRect(snapRectToDevicePixels(graphicsLayerRect, deviceScaleFactor));
      snappedGraphicsLayer.m_snapDelta = snappedGraphicsLayer.m_snappedRect.location() - toLayoutPoint(offset);
      return snappedGraphicsLayer;
  }
  
<span class="line-modified">! static LayoutSize computeOffsetFromAncestorGraphicsLayer(const RenderLayer* compositedAncestor, const LayoutPoint&amp; location, float deviceScaleFactor)</span>
  {
      if (!compositedAncestor)
          return toLayoutSize(location);
  
      // FIXME: This is a workaround until after webkit.org/162634 gets fixed. ancestorSubpixelOffsetFromRenderer
</pre>
<hr />
<pre>
<span class="line-old-header">*** 932,17 ***</span>
      float m_deviceScaleFactor;
  };
  
  LayoutRect RenderLayerBacking::computePrimaryGraphicsLayerRect(const LayoutRect&amp; parentGraphicsLayerRect) const
  {
<span class="line-modified">!     ComputedOffsets compositedBoundsOffset(m_owningLayer, compositedBounds(), parentGraphicsLayerRect, LayoutRect());</span>
      return LayoutRect(encloseRectToDevicePixels(LayoutRect(toLayoutPoint(compositedBoundsOffset.fromParentGraphicsLayer()), compositedBounds().size()),
          deviceScaleFactor()));
  }
  
  // FIXME: See if we need this now that updateGeometry() is always called in post-order traversal.
<span class="line-modified">! LayoutRect RenderLayerBacking::computeParentGraphicsLayerRect(RenderLayer* compositedAncestor, LayoutSize&amp; ancestorClippingLayerOffset) const</span>
  {
      if (!compositedAncestor || !compositedAncestor-&gt;backing())
          return renderer().view().documentRect();
  
      auto* ancestorBackingLayer = compositedAncestor-&gt;backing();
<span class="line-new-header">--- 1072,17 ---</span>
      float m_deviceScaleFactor;
  };
  
  LayoutRect RenderLayerBacking::computePrimaryGraphicsLayerRect(const LayoutRect&amp; parentGraphicsLayerRect) const
  {
<span class="line-modified">!     ComputedOffsets compositedBoundsOffset(m_owningLayer, compositedBounds(), parentGraphicsLayerRect, { });</span>
      return LayoutRect(encloseRectToDevicePixels(LayoutRect(toLayoutPoint(compositedBoundsOffset.fromParentGraphicsLayer()), compositedBounds().size()),
          deviceScaleFactor()));
  }
  
  // FIXME: See if we need this now that updateGeometry() is always called in post-order traversal.
<span class="line-modified">! LayoutRect RenderLayerBacking::computeParentGraphicsLayerRect(const RenderLayer* compositedAncestor) const</span>
  {
      if (!compositedAncestor || !compositedAncestor-&gt;backing())
          return renderer().view().documentRect();
  
      auto* ancestorBackingLayer = compositedAncestor-&gt;backing();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 967,24 ***</span>
          LayoutRect paddingBoxIncludingScrollbar = renderBox.paddingBoxRectIncludingScrollbar();
          ScrollOffset scrollOffset = compositedAncestor-&gt;scrollOffset();
          parentGraphicsLayerRect = LayoutRect((paddingBoxIncludingScrollbar.location() - toLayoutSize(ancestorCompositedBounds.location()) - toLayoutSize(scrollOffset)), paddingBoxIncludingScrollbar.size());
      }
  
<span class="line-removed">-     if (m_ancestorClippingLayer) {</span>
<span class="line-removed">-         // Call calculateRects to get the backgroundRect which is what is used to clip the contents of this</span>
<span class="line-removed">-         // layer. Note that we call it with temporaryClipRects = true because normally when computing clip rects</span>
<span class="line-removed">-         // for a compositing layer, rootLayer is the layer itself.</span>
<span class="line-removed">-         ShouldRespectOverflowClip shouldRespectOverflowClip = compositedAncestor-&gt;isolatesCompositedBlending() ? RespectOverflowClip : IgnoreOverflowClip;</span>
<span class="line-removed">-         RenderLayer::ClipRectsContext clipRectsContext(compositedAncestor, TemporaryClipRects, IgnoreOverlayScrollbarSize, shouldRespectOverflowClip);</span>
<span class="line-removed">-         LayoutRect parentClipRect = m_owningLayer.backgroundClipRect(clipRectsContext).rect(); // FIXME: Incorrect for CSS regions.</span>
<span class="line-removed">-         ASSERT(!parentClipRect.isInfinite());</span>
<span class="line-removed">-         LayoutSize clippingOffset = computeOffsetFromAncestorGraphicsLayer(compositedAncestor, parentClipRect.location(), deviceScaleFactor());</span>
<span class="line-removed">-         LayoutRect snappedClippingLayerRect = snappedGraphicsLayer(clippingOffset, parentClipRect.size(), deviceScaleFactor()).m_snappedRect;</span>
<span class="line-removed">-         // The primary layer is then parented in, and positioned relative to this clipping layer.</span>
<span class="line-removed">-         ancestorClippingLayerOffset = snappedClippingLayerRect.location() - parentGraphicsLayerRect.location();</span>
<span class="line-removed">-         parentGraphicsLayerRect = snappedClippingLayerRect;</span>
<span class="line-removed">-     }</span>
      return parentGraphicsLayerRect;
  }
  
  void RenderLayerBacking::updateGeometry()
  {
<span class="line-new-header">--- 1107,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 994,97 ***</span>
      ASSERT(!renderer().view().needsLayout());
  
      const RenderStyle&amp; style = renderer().style();
  
      bool isRunningAcceleratedTransformAnimation = false;
<span class="line-removed">-     bool isRunningAcceleratedOpacityAnimation = false;</span>
      if (RuntimeEnabledFeatures::sharedFeatures().webAnimationsCSSIntegrationEnabled()) {
<span class="line-modified">!         if (auto* timeline = renderer().documentTimeline()) {</span>
              isRunningAcceleratedTransformAnimation = timeline-&gt;isRunningAcceleratedAnimationOnRenderer(renderer(), CSSPropertyTransform);
<span class="line-modified">!             isRunningAcceleratedOpacityAnimation = timeline-&gt;isRunningAcceleratedAnimationOnRenderer(renderer(), CSSPropertyOpacity);</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-     } else {</span>
          isRunningAcceleratedTransformAnimation = renderer().animation().isRunningAcceleratedAnimationOnRenderer(renderer(), CSSPropertyTransform);
<span class="line-removed">-         isRunningAcceleratedOpacityAnimation = renderer().animation().isRunningAcceleratedAnimationOnRenderer(renderer(), CSSPropertyOpacity);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     // Set transform property, if it is not animating. We have to do this here because the transform</span>
<span class="line-removed">-     // is affected by the layer dimensions.</span>
<span class="line-removed">-     if (!isRunningAcceleratedTransformAnimation)</span>
<span class="line-removed">-         updateTransform(style);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     // Set opacity, if it is not animating.</span>
<span class="line-removed">-     if (!isRunningAcceleratedOpacityAnimation)</span>
<span class="line-removed">-         updateOpacity(style);</span>
  
      updateFilters(style);
  #if ENABLE(FILTERS_LEVEL_2)
      updateBackdropFilters(style);
  #endif
  #if ENABLE(CSS_COMPOSITING)
      updateBlendMode(style);
  #endif
  
<span class="line-removed">-     // FIXME: reflections should force transform-style to be flat in the style: https://bugs.webkit.org/show_bug.cgi?id=106959</span>
<span class="line-removed">-     bool preserves3D = style.transformStyle3D() == TransformStyle3D::Preserve3D &amp;&amp; !renderer().hasReflection();</span>
<span class="line-removed">-     m_graphicsLayer-&gt;setPreserves3D(preserves3D);</span>
<span class="line-removed">-     m_graphicsLayer-&gt;setBackfaceVisibility(style.backfaceVisibility() == BackfaceVisibility::Visible);</span>
<span class="line-removed">- </span>
      auto* compositedAncestor = m_owningLayer.ancestorCompositingLayer();
<span class="line-modified">!     LayoutSize ancestorClippingLayerOffset;</span>
<span class="line-modified">!     LayoutRect parentGraphicsLayerRect = computeParentGraphicsLayerRect(compositedAncestor, ancestorClippingLayerOffset);</span>
      LayoutRect primaryGraphicsLayerRect = computePrimaryGraphicsLayerRect(parentGraphicsLayerRect);
  
      ComputedOffsets compositedBoundsOffset(m_owningLayer, compositedBounds(), parentGraphicsLayerRect, primaryGraphicsLayerRect);
      m_compositedBoundsOffsetFromGraphicsLayer = compositedBoundsOffset.fromPrimaryGraphicsLayer();
<span class="line-modified">!     m_graphicsLayer-&gt;setPosition(primaryGraphicsLayerRect.location());</span>
<span class="line-modified">!     m_graphicsLayer-&gt;setSize(primaryGraphicsLayerRect.size());</span>
  
      auto computeAnimationExtent = [&amp;] () -&gt; Optional&lt;FloatRect&gt; {
          LayoutRect animatedBounds;
          if (isRunningAcceleratedTransformAnimation &amp;&amp; m_owningLayer.getOverlapBoundsIncludingChildrenAccountingForTransformAnimations(animatedBounds, RenderLayer::IncludeCompositedDescendants))
              return FloatRect(animatedBounds);
          return { };
      };
      m_graphicsLayer-&gt;setAnimationExtent(computeAnimationExtent());
  
<span class="line-modified">!     ComputedOffsets rendererOffset(m_owningLayer, LayoutRect(), parentGraphicsLayerRect, primaryGraphicsLayerRect);</span>
<span class="line-modified">!     if (m_ancestorClippingLayer) {</span>
<span class="line-removed">-         // Clipping layer is parented in the ancestor layer.</span>
<span class="line-removed">-         m_ancestorClippingLayer-&gt;setPosition(toLayoutPoint(ancestorClippingLayerOffset));</span>
<span class="line-removed">-         m_ancestorClippingLayer-&gt;setSize(parentGraphicsLayerRect.size());</span>
<span class="line-removed">-         m_ancestorClippingLayer-&gt;setOffsetFromRenderer(-rendererOffset.fromParentGraphicsLayer());</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     if (m_contentsContainmentLayer) {</span>
<span class="line-removed">-         m_contentsContainmentLayer-&gt;setPreserves3D(preserves3D);</span>
<span class="line-removed">-         m_contentsContainmentLayer-&gt;setPosition(primaryGraphicsLayerRect.location());</span>
<span class="line-removed">-         m_graphicsLayer-&gt;setPosition(FloatPoint());</span>
<span class="line-removed">-         // Use the same size as m_graphicsLayer so transforms behave correctly.</span>
<span class="line-removed">-         m_contentsContainmentLayer-&gt;setSize(primaryGraphicsLayerRect.size());</span>
<span class="line-removed">-     }</span>
  
      // Compute renderer offset from primary graphics layer. Note that primaryGraphicsLayerRect is in parentGraphicsLayer&#39;s coordinate system which is not necessarily
      // the same as the ancestor graphics layer.
      OffsetFromRenderer primaryGraphicsLayerOffsetFromRenderer;
      LayoutSize oldSubpixelOffsetFromRenderer = m_subpixelOffsetFromRenderer;
      primaryGraphicsLayerOffsetFromRenderer = computeOffsetFromRenderer(-rendererOffset.fromPrimaryGraphicsLayer(), deviceScaleFactor());
      m_subpixelOffsetFromRenderer = primaryGraphicsLayerOffsetFromRenderer.m_subpixelOffset;
  
      if (primaryGraphicsLayerOffsetFromRenderer.m_devicePixelOffset != m_graphicsLayer-&gt;offsetFromRenderer()) {
          m_graphicsLayer-&gt;setOffsetFromRenderer(primaryGraphicsLayerOffsetFromRenderer.m_devicePixelOffset);
          positionOverflowControlsLayers();
      }
  
<span class="line-removed">-     if (!m_isMainFrameRenderViewLayer &amp;&amp; !m_isFrameLayerWithTiledBacking &amp;&amp; !m_requiresBackgroundLayer) {</span>
<span class="line-removed">-         // For non-root layers, background is always painted by the primary graphics layer.</span>
<span class="line-removed">-         ASSERT(!m_backgroundLayer);</span>
<span class="line-removed">-         // Subpixel offset from graphics layer or size changed.</span>
<span class="line-removed">-         bool hadSubpixelRounding = !m_subpixelOffsetFromRenderer.isZero() || compositedBounds().size() != primaryGraphicsLayerRect.size();</span>
<span class="line-removed">-         m_graphicsLayer-&gt;setContentsOpaque(!hadSubpixelRounding &amp;&amp; m_owningLayer.backgroundIsKnownToBeOpaqueInRect(compositedBounds()));</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
      // If we have a layer that clips children, position it.
      LayoutRect clippingBox;
      if (auto* clipLayer = clippingLayer()) {
          // clipLayer is the m_childContainmentLayer.
          clippingBox = clipBox(downcast&lt;RenderBox&gt;(renderer()));
<span class="line-new-header">--- 1120,101 ---</span>
      ASSERT(!renderer().view().needsLayout());
  
      const RenderStyle&amp; style = renderer().style();
  
      bool isRunningAcceleratedTransformAnimation = false;
      if (RuntimeEnabledFeatures::sharedFeatures().webAnimationsCSSIntegrationEnabled()) {
<span class="line-modified">!         if (auto* timeline = renderer().documentTimeline())</span>
              isRunningAcceleratedTransformAnimation = timeline-&gt;isRunningAcceleratedAnimationOnRenderer(renderer(), CSSPropertyTransform);
<span class="line-modified">!     } else</span>
          isRunningAcceleratedTransformAnimation = renderer().animation().isRunningAcceleratedAnimationOnRenderer(renderer(), CSSPropertyTransform);
  
<span class="line-added">+     updateTransform(style);</span>
<span class="line-added">+     updateOpacity(style);</span>
      updateFilters(style);
  #if ENABLE(FILTERS_LEVEL_2)
      updateBackdropFilters(style);
  #endif
  #if ENABLE(CSS_COMPOSITING)
      updateBlendMode(style);
  #endif
  
      auto* compositedAncestor = m_owningLayer.ancestorCompositingLayer();
<span class="line-modified">!     LayoutRect parentGraphicsLayerRect = computeParentGraphicsLayerRect(compositedAncestor);</span>
<span class="line-modified">! </span>
<span class="line-added">+     if (m_ancestorClippingStack) {</span>
<span class="line-added">+         // All clipRects in the stack are computed relative to m_owningLayer, so convert them back to compositedAncestor.</span>
<span class="line-added">+         auto offsetFromCompositedAncestor = toLayoutSize(m_owningLayer.convertToLayerCoords(compositedAncestor, { }, RenderLayer::AdjustForColumns));</span>
<span class="line-added">+         LayoutRect lastClipLayerRect = parentGraphicsLayerRect;</span>
<span class="line-added">+ </span>
<span class="line-added">+         for (auto&amp; entry : m_ancestorClippingStack-&gt;stack()) {</span>
<span class="line-added">+             auto clipRect = entry.clipData.clipRect;</span>
<span class="line-added">+             LayoutSize clippingOffset = computeOffsetFromAncestorGraphicsLayer(compositedAncestor, clipRect.location() + offsetFromCompositedAncestor, deviceScaleFactor());</span>
<span class="line-added">+             LayoutRect snappedClippingLayerRect = snappedGraphicsLayer(clippingOffset, clipRect.size(), deviceScaleFactor()).m_snappedRect;</span>
<span class="line-added">+ </span>
<span class="line-added">+             entry.clippingLayer-&gt;setPosition(toLayoutPoint(snappedClippingLayerRect.location() - lastClipLayerRect.location()));</span>
<span class="line-added">+             lastClipLayerRect = snappedClippingLayerRect;</span>
<span class="line-added">+ </span>
<span class="line-added">+             entry.clippingLayer-&gt;setSize(snappedClippingLayerRect.size());</span>
<span class="line-added">+ </span>
<span class="line-added">+             if (entry.clipData.isOverflowScroll) {</span>
<span class="line-added">+                 ScrollOffset scrollOffset = entry.clipData.clippingLayer-&gt;scrollOffset();</span>
<span class="line-added">+ </span>
<span class="line-added">+                 entry.clippingLayer-&gt;setBoundsOrigin(scrollOffset);</span>
<span class="line-added">+                 lastClipLayerRect.moveBy(-scrollOffset);</span>
<span class="line-added">+             } else</span>
<span class="line-added">+                 entry.clippingLayer-&gt;setBoundsOrigin({ });</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         parentGraphicsLayerRect = lastClipLayerRect;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      LayoutRect primaryGraphicsLayerRect = computePrimaryGraphicsLayerRect(parentGraphicsLayerRect);
  
      ComputedOffsets compositedBoundsOffset(m_owningLayer, compositedBounds(), parentGraphicsLayerRect, primaryGraphicsLayerRect);
<span class="line-added">+     ComputedOffsets rendererOffset(m_owningLayer, { }, parentGraphicsLayerRect, primaryGraphicsLayerRect);</span>
<span class="line-added">+ </span>
      m_compositedBoundsOffsetFromGraphicsLayer = compositedBoundsOffset.fromPrimaryGraphicsLayer();
<span class="line-modified">! </span>
<span class="line-modified">!     auto primaryLayerPosition = primaryGraphicsLayerRect.location();</span>
<span class="line-added">+ </span>
<span class="line-added">+     // FIXME: reflections should force transform-style to be flat in the style: https://bugs.webkit.org/show_bug.cgi?id=106959</span>
<span class="line-added">+     bool preserves3D = style.transformStyle3D() == TransformStyle3D::Preserve3D &amp;&amp; !renderer().hasReflection();</span>
<span class="line-added">+     if (m_contentsContainmentLayer) {</span>
<span class="line-added">+         m_contentsContainmentLayer-&gt;setPreserves3D(preserves3D);</span>
<span class="line-added">+         m_contentsContainmentLayer-&gt;setPosition(primaryLayerPosition);</span>
<span class="line-added">+         primaryLayerPosition = { };</span>
<span class="line-added">+         // Use the same size as m_graphicsLayer so transforms behave correctly.</span>
<span class="line-added">+         m_contentsContainmentLayer-&gt;setSize(primaryGraphicsLayerRect.size());</span>
<span class="line-added">+     }</span>
  
      auto computeAnimationExtent = [&amp;] () -&gt; Optional&lt;FloatRect&gt; {
          LayoutRect animatedBounds;
          if (isRunningAcceleratedTransformAnimation &amp;&amp; m_owningLayer.getOverlapBoundsIncludingChildrenAccountingForTransformAnimations(animatedBounds, RenderLayer::IncludeCompositedDescendants))
              return FloatRect(animatedBounds);
          return { };
      };
      m_graphicsLayer-&gt;setAnimationExtent(computeAnimationExtent());
<span class="line-added">+     m_graphicsLayer-&gt;setPreserves3D(preserves3D);</span>
<span class="line-added">+     m_graphicsLayer-&gt;setBackfaceVisibility(style.backfaceVisibility() == BackfaceVisibility::Visible);</span>
  
<span class="line-modified">!     m_graphicsLayer-&gt;setPosition(primaryLayerPosition);</span>
<span class="line-modified">!     m_graphicsLayer-&gt;setSize(primaryGraphicsLayerRect.size());</span>
  
      // Compute renderer offset from primary graphics layer. Note that primaryGraphicsLayerRect is in parentGraphicsLayer&#39;s coordinate system which is not necessarily
      // the same as the ancestor graphics layer.
      OffsetFromRenderer primaryGraphicsLayerOffsetFromRenderer;
      LayoutSize oldSubpixelOffsetFromRenderer = m_subpixelOffsetFromRenderer;
      primaryGraphicsLayerOffsetFromRenderer = computeOffsetFromRenderer(-rendererOffset.fromPrimaryGraphicsLayer(), deviceScaleFactor());
      m_subpixelOffsetFromRenderer = primaryGraphicsLayerOffsetFromRenderer.m_subpixelOffset;
<span class="line-added">+     m_hasSubpixelRounding = !m_subpixelOffsetFromRenderer.isZero() || compositedBounds().size() != primaryGraphicsLayerRect.size();</span>
  
      if (primaryGraphicsLayerOffsetFromRenderer.m_devicePixelOffset != m_graphicsLayer-&gt;offsetFromRenderer()) {
          m_graphicsLayer-&gt;setOffsetFromRenderer(primaryGraphicsLayerOffsetFromRenderer.m_devicePixelOffset);
          positionOverflowControlsLayers();
      }
  
      // If we have a layer that clips children, position it.
      LayoutRect clippingBox;
      if (auto* clipLayer = clippingLayer()) {
          // clipLayer is the m_childContainmentLayer.
          clippingBox = clipBox(downcast&lt;RenderBox&gt;(renderer()));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1093,10 ***</span>
<span class="line-new-header">--- 1223,17 ---</span>
          SnappedRectInfo snappedClippingGraphicsLayer = snappedGraphicsLayer(clipBoxOffsetFromGraphicsLayer, clippingBox.size(), deviceScaleFactor());
          clipLayer-&gt;setPosition(snappedClippingGraphicsLayer.m_snappedRect.location());
          clipLayer-&gt;setSize(snappedClippingGraphicsLayer.m_snappedRect.size());
          clipLayer-&gt;setOffsetFromRenderer(toLayoutSize(clippingBox.location() - snappedClippingGraphicsLayer.m_snapDelta));
  
<span class="line-added">+         if ((renderer().style().clipPath() || renderer().style().hasBorderRadius()) &amp;&amp; !m_childClippingMaskLayer) {</span>
<span class="line-added">+             LayoutRect boxRect(LayoutPoint(), downcast&lt;RenderBox&gt;(renderer()).size());</span>
<span class="line-added">+             FloatRoundedRect contentsClippingRect = renderer().style().getRoundedInnerBorderFor(boxRect).pixelSnappedRoundedRectForPainting(deviceScaleFactor());</span>
<span class="line-added">+             contentsClippingRect.move(LayoutSize(-clipLayer-&gt;offsetFromRenderer()));</span>
<span class="line-added">+             clipLayer-&gt;setMasksToBoundsRect(contentsClippingRect);</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
          if (m_childClippingMaskLayer &amp;&amp; !m_scrollContainerLayer) {
              m_childClippingMaskLayer-&gt;setSize(clipLayer-&gt;size());
              m_childClippingMaskLayer-&gt;setPosition(FloatPoint());
              m_childClippingMaskLayer-&gt;setOffsetFromRenderer(clipLayer-&gt;offsetFromRenderer());
          }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1140,43 ***</span>
          m_graphicsLayer-&gt;setAnchorPoint(FloatPoint3D(0.5, 0.5, 0));
          if (m_contentsContainmentLayer)
              m_contentsContainmentLayer-&gt;setAnchorPoint(FloatPoint3D(0.5, 0.5, 0));
      }
  
<span class="line-removed">-     if (m_foregroundLayer) {</span>
<span class="line-removed">-         FloatPoint foregroundPosition;</span>
<span class="line-removed">-         FloatSize foregroundSize = primaryGraphicsLayerRect.size();</span>
<span class="line-removed">-         FloatSize foregroundOffset = m_graphicsLayer-&gt;offsetFromRenderer();</span>
<span class="line-removed">-         if (hasClippingLayer()) {</span>
<span class="line-removed">-             // If we have a clipping layer (which clips descendants), then the foreground layer is a child of it,</span>
<span class="line-removed">-             // so that it gets correctly sorted with children. In that case, position relative to the clipping layer.</span>
<span class="line-removed">-             foregroundSize = FloatSize(clippingBox.size());</span>
<span class="line-removed">-             foregroundOffset = toFloatSize(clippingBox.location());</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
<span class="line-removed">-         m_foregroundLayer-&gt;setPosition(foregroundPosition);</span>
<span class="line-removed">-         m_foregroundLayer-&gt;setSize(foregroundSize);</span>
<span class="line-removed">-         m_foregroundLayer-&gt;setOffsetFromRenderer(foregroundOffset);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     if (m_backgroundLayer) {</span>
<span class="line-removed">-         FloatPoint backgroundPosition;</span>
<span class="line-removed">-         FloatSize backgroundSize = primaryGraphicsLayerRect.size();</span>
<span class="line-removed">-         if (backgroundLayerPaintsFixedRootBackground()) {</span>
<span class="line-removed">-             const FrameView&amp; frameView = renderer().view().frameView();</span>
<span class="line-removed">-             backgroundPosition = frameView.scrollPositionForFixedPosition();</span>
<span class="line-removed">-             backgroundSize = frameView.layoutSize();</span>
<span class="line-removed">-         } else {</span>
<span class="line-removed">-             auto boundingBox = renderer().objectBoundingBox();</span>
<span class="line-removed">-             backgroundPosition = boundingBox.location();</span>
<span class="line-removed">-             backgroundSize = boundingBox.size();</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         m_backgroundLayer-&gt;setPosition(backgroundPosition);</span>
<span class="line-removed">-         m_backgroundLayer-&gt;setSize(backgroundSize);</span>
<span class="line-removed">-         m_backgroundLayer-&gt;setOffsetFromRenderer(m_graphicsLayer-&gt;offsetFromRenderer());</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
      if (m_owningLayer.reflectionLayer() &amp;&amp; m_owningLayer.reflectionLayer()-&gt;isComposited()) {
          auto* reflectionBacking = m_owningLayer.reflectionLayer()-&gt;backing();
          reflectionBacking-&gt;updateGeometry();
  
          // The reflection layer has the bounds of m_owningLayer.reflectionLayer(),
<span class="line-new-header">--- 1277,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1187,46 ***</span>
      }
  
      if (m_scrollContainerLayer) {
          ASSERT(m_scrolledContentsLayer);
          auto&amp; renderBox = downcast&lt;RenderBox&gt;(renderer());
<span class="line-modified">!         LayoutRect paddingBoxIncludingScrollbar = renderBox.paddingBoxRectIncludingScrollbar();</span>
          LayoutRect parentLayerBounds = clippingLayer() ? clippingBox : compositedBounds();
  
          // FIXME: need to do some pixel snapping here.
<span class="line-modified">!         m_scrollContainerLayer-&gt;setPosition(FloatPoint(paddingBoxIncludingScrollbar.location() - parentLayerBounds.location()));</span>
          m_scrollContainerLayer-&gt;setSize(roundedIntSize(LayoutSize(renderBox.paddingBoxWidth(), renderBox.paddingBoxHeight())));
  
          ScrollOffset scrollOffset = m_owningLayer.scrollOffset();
          updateScrollOffset(scrollOffset);
<span class="line-removed">- #if PLATFORM(IOS_FAMILY)</span>
<span class="line-removed">-         m_scrolledContentsLayer-&gt;setPosition({ }); // FIXME: necessary?</span>
<span class="line-removed">- #endif</span>
  
          FloatSize oldScrollingLayerOffset = m_scrollContainerLayer-&gt;offsetFromRenderer();
<span class="line-modified">!         m_scrollContainerLayer-&gt;setOffsetFromRenderer(toFloatSize(paddingBoxIncludingScrollbar.location()));</span>
  
          if (m_childClippingMaskLayer) {
              m_childClippingMaskLayer-&gt;setPosition(m_scrollContainerLayer-&gt;position());
              m_childClippingMaskLayer-&gt;setSize(m_scrollContainerLayer-&gt;size());
<span class="line-modified">!             m_childClippingMaskLayer-&gt;setOffsetFromRenderer(toFloatSize(paddingBoxIncludingScrollbar.location()));</span>
          }
  
          bool paddingBoxOffsetChanged = oldScrollingLayerOffset != m_scrollContainerLayer-&gt;offsetFromRenderer();
  
          IntSize scrollSize(m_owningLayer.scrollWidth(), m_owningLayer.scrollHeight());
          if (scrollSize != m_scrolledContentsLayer-&gt;size() || paddingBoxOffsetChanged)
              m_scrolledContentsLayer-&gt;setNeedsDisplay();
  
          m_scrolledContentsLayer-&gt;setSize(scrollSize);
          m_scrolledContentsLayer-&gt;setScrollOffset(scrollOffset, GraphicsLayer::DontSetNeedsDisplay);
<span class="line-modified">!         m_scrolledContentsLayer-&gt;setOffsetFromRenderer(toLayoutSize(paddingBoxIncludingScrollbar.location()), GraphicsLayer::DontSetNeedsDisplay);</span>
  
<span class="line-modified">!         if (m_foregroundLayer) {</span>
<span class="line-modified">!             m_foregroundLayer-&gt;setSize(m_scrolledContentsLayer-&gt;size());</span>
<span class="line-modified">!             m_foregroundLayer-&gt;setOffsetFromRenderer(m_scrolledContentsLayer-&gt;offsetFromRenderer() - toLayoutSize(m_scrolledContentsLayer-&gt;scrollOffset()));</span>
          }
      }
  
      // If this layer was created just for clipping or to apply perspective, it doesn&#39;t need its own backing store.
      LayoutRect ancestorCompositedBounds = compositedAncestor ? compositedAncestor-&gt;backing()-&gt;compositedBounds() : LayoutRect();
      setRequiresOwnBackingStore(compositor().requiresOwnBackingStore(m_owningLayer, compositedAncestor,
<span class="line-new-header">--- 1291,80 ---</span>
      }
  
      if (m_scrollContainerLayer) {
          ASSERT(m_scrolledContentsLayer);
          auto&amp; renderBox = downcast&lt;RenderBox&gt;(renderer());
<span class="line-modified">!         LayoutRect paddingBox = renderBox.paddingBoxRect();</span>
          LayoutRect parentLayerBounds = clippingLayer() ? clippingBox : compositedBounds();
  
          // FIXME: need to do some pixel snapping here.
<span class="line-modified">!         m_scrollContainerLayer-&gt;setPosition(FloatPoint(paddingBox.location() - parentLayerBounds.location()));</span>
          m_scrollContainerLayer-&gt;setSize(roundedIntSize(LayoutSize(renderBox.paddingBoxWidth(), renderBox.paddingBoxHeight())));
  
          ScrollOffset scrollOffset = m_owningLayer.scrollOffset();
          updateScrollOffset(scrollOffset);
  
          FloatSize oldScrollingLayerOffset = m_scrollContainerLayer-&gt;offsetFromRenderer();
<span class="line-modified">!         m_scrollContainerLayer-&gt;setOffsetFromRenderer(toFloatSize(paddingBox.location()));</span>
  
          if (m_childClippingMaskLayer) {
              m_childClippingMaskLayer-&gt;setPosition(m_scrollContainerLayer-&gt;position());
              m_childClippingMaskLayer-&gt;setSize(m_scrollContainerLayer-&gt;size());
<span class="line-modified">!             m_childClippingMaskLayer-&gt;setOffsetFromRenderer(toFloatSize(paddingBox.location()));</span>
          }
  
          bool paddingBoxOffsetChanged = oldScrollingLayerOffset != m_scrollContainerLayer-&gt;offsetFromRenderer();
  
          IntSize scrollSize(m_owningLayer.scrollWidth(), m_owningLayer.scrollHeight());
          if (scrollSize != m_scrolledContentsLayer-&gt;size() || paddingBoxOffsetChanged)
              m_scrolledContentsLayer-&gt;setNeedsDisplay();
  
          m_scrolledContentsLayer-&gt;setSize(scrollSize);
          m_scrolledContentsLayer-&gt;setScrollOffset(scrollOffset, GraphicsLayer::DontSetNeedsDisplay);
<span class="line-modified">!         m_scrolledContentsLayer-&gt;setOffsetFromRenderer(toLayoutSize(paddingBox.location()), GraphicsLayer::DontSetNeedsDisplay);</span>
<span class="line-added">+ </span>
<span class="line-added">+         adjustTiledBackingCoverage();</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (m_foregroundLayer) {</span>
<span class="line-added">+         FloatSize foregroundSize;</span>
<span class="line-added">+         FloatSize foregroundOffset;</span>
<span class="line-added">+         GraphicsLayer::ShouldSetNeedsDisplay needsDisplayOnOffsetChange = GraphicsLayer::SetNeedsDisplay;</span>
<span class="line-added">+         if (m_scrolledContentsLayer) {</span>
<span class="line-added">+             foregroundSize = m_scrolledContentsLayer-&gt;size();</span>
<span class="line-added">+             foregroundOffset = m_scrolledContentsLayer-&gt;offsetFromRenderer() - toLayoutSize(m_scrolledContentsLayer-&gt;scrollOffset());</span>
<span class="line-added">+             needsDisplayOnOffsetChange = GraphicsLayer::DontSetNeedsDisplay;</span>
<span class="line-added">+         } else if (hasClippingLayer()) {</span>
<span class="line-added">+             // If we have a clipping layer (which clips descendants), then the foreground layer is a child of it,</span>
<span class="line-added">+             // so that it gets correctly sorted with children. In that case, position relative to the clipping layer.</span>
<span class="line-added">+             foregroundSize = FloatSize(clippingBox.size());</span>
<span class="line-added">+             foregroundOffset = toFloatSize(clippingBox.location());</span>
<span class="line-added">+         } else {</span>
<span class="line-added">+             foregroundSize = primaryGraphicsLayerRect.size();</span>
<span class="line-added">+             foregroundOffset = m_graphicsLayer-&gt;offsetFromRenderer();</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         m_foregroundLayer-&gt;setPosition({ });</span>
<span class="line-added">+         m_foregroundLayer-&gt;setSize(foregroundSize);</span>
<span class="line-added">+         m_foregroundLayer-&gt;setOffsetFromRenderer(foregroundOffset, needsDisplayOnOffsetChange);</span>
<span class="line-added">+     }</span>
  
<span class="line-modified">!     if (m_backgroundLayer) {</span>
<span class="line-modified">!         FloatPoint backgroundPosition;</span>
<span class="line-modified">!         FloatSize backgroundSize = primaryGraphicsLayerRect.size();</span>
<span class="line-added">+         if (backgroundLayerPaintsFixedRootBackground()) {</span>
<span class="line-added">+             const FrameView&amp; frameView = renderer().view().frameView();</span>
<span class="line-added">+             backgroundPosition = frameView.scrollPositionForFixedPosition();</span>
<span class="line-added">+             backgroundSize = frameView.layoutSize();</span>
<span class="line-added">+         } else {</span>
<span class="line-added">+             auto boundingBox = renderer().objectBoundingBox();</span>
<span class="line-added">+             backgroundPosition = boundingBox.location();</span>
<span class="line-added">+             backgroundSize = boundingBox.size();</span>
          }
<span class="line-added">+         m_backgroundLayer-&gt;setPosition(backgroundPosition);</span>
<span class="line-added">+         m_backgroundLayer-&gt;setSize(backgroundSize);</span>
<span class="line-added">+         m_backgroundLayer-&gt;setOffsetFromRenderer(m_graphicsLayer-&gt;offsetFromRenderer());</span>
      }
  
      // If this layer was created just for clipping or to apply perspective, it doesn&#39;t need its own backing store.
      LayoutRect ancestorCompositedBounds = compositedAncestor ? compositedAncestor-&gt;backing()-&gt;compositedBounds() : LayoutRect();
      setRequiresOwnBackingStore(compositor().requiresOwnBackingStore(m_owningLayer, compositedAncestor,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1240,34 ***</span>
          setContentsNeedDisplay();
  }
  
  void RenderLayerBacking::setLocationOfScrolledContents(ScrollOffset scrollOffset, ScrollingLayerPositionAction setOrSync)
  {
<span class="line-removed">- #if PLATFORM(IOS_FAMILY)</span>
      if (setOrSync == ScrollingLayerPositionAction::Sync)
          m_scrollContainerLayer-&gt;syncBoundsOrigin(scrollOffset);
      else
          m_scrollContainerLayer-&gt;setBoundsOrigin(scrollOffset);
<span class="line-removed">- #else</span>
<span class="line-removed">-     if (setOrSync == ScrollingLayerPositionAction::Sync)</span>
<span class="line-removed">-         m_scrolledContentsLayer-&gt;syncPosition(-scrollOffset);</span>
<span class="line-removed">-     else</span>
<span class="line-removed">-         m_scrolledContentsLayer-&gt;setPosition(-scrollOffset);</span>
<span class="line-removed">- #endif</span>
  }
  
  void RenderLayerBacking::updateScrollOffset(ScrollOffset scrollOffset)
  {
<span class="line-modified">!     if (m_owningLayer.isInUserScroll()) {</span>
          // If scrolling is happening externally, we don&#39;t want to touch the layer bounds origin here because that will cause jitter.
          setLocationOfScrolledContents(scrollOffset, ScrollingLayerPositionAction::Sync);
          m_owningLayer.setRequiresScrollPositionReconciliation(true);
      } else {
          // Note that we implement the contents offset via the bounds origin on this layer, rather than a position on the sublayer.
          setLocationOfScrolledContents(scrollOffset, ScrollingLayerPositionAction::Set);
          m_owningLayer.setRequiresScrollPositionReconciliation(false);
      }
  }
  
  void RenderLayerBacking::updateAfterDescendants()
  {
      // FIXME: this potentially duplicates work we did in updateConfiguration().
<span class="line-new-header">--- 1378,29 ---</span>
          setContentsNeedDisplay();
  }
  
  void RenderLayerBacking::setLocationOfScrolledContents(ScrollOffset scrollOffset, ScrollingLayerPositionAction setOrSync)
  {
      if (setOrSync == ScrollingLayerPositionAction::Sync)
          m_scrollContainerLayer-&gt;syncBoundsOrigin(scrollOffset);
      else
          m_scrollContainerLayer-&gt;setBoundsOrigin(scrollOffset);
  }
  
  void RenderLayerBacking::updateScrollOffset(ScrollOffset scrollOffset)
  {
<span class="line-modified">!     if (m_owningLayer.currentScrollType() == ScrollType::User) {</span>
          // If scrolling is happening externally, we don&#39;t want to touch the layer bounds origin here because that will cause jitter.
          setLocationOfScrolledContents(scrollOffset, ScrollingLayerPositionAction::Sync);
          m_owningLayer.setRequiresScrollPositionReconciliation(true);
      } else {
          // Note that we implement the contents offset via the bounds origin on this layer, rather than a position on the sublayer.
          setLocationOfScrolledContents(scrollOffset, ScrollingLayerPositionAction::Set);
          m_owningLayer.setRequiresScrollPositionReconciliation(false);
      }
<span class="line-added">+ </span>
<span class="line-added">+     ASSERT(m_scrolledContentsLayer-&gt;position().isZero());</span>
  }
  
  void RenderLayerBacking::updateAfterDescendants()
  {
      // FIXME: this potentially duplicates work we did in updateConfiguration().
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1281,10 ***</span>
<span class="line-new-header">--- 1414,16 ---</span>
              resetContentsRect();
      }
  
      updateDrawsContent(contentsInfo);
  
<span class="line-added">+     if (!m_isMainFrameRenderViewLayer &amp;&amp; !m_isFrameLayerWithTiledBacking &amp;&amp; !m_requiresBackgroundLayer) {</span>
<span class="line-added">+         // For non-root layers, background is always painted by the primary graphics layer.</span>
<span class="line-added">+         ASSERT(!m_backgroundLayer);</span>
<span class="line-added">+         m_graphicsLayer-&gt;setContentsOpaque(!m_hasSubpixelRounding &amp;&amp; m_owningLayer.backgroundIsKnownToBeOpaqueInRect(compositedBounds()));</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      m_graphicsLayer-&gt;setContentsVisible(m_owningLayer.hasVisibleContent() || hasVisibleNonCompositedDescendants());
      if (m_scrollContainerLayer) {
          m_scrollContainerLayer-&gt;setContentsVisible(renderer().style().visibility() == Visibility::Visible);
          m_scrollContainerLayer-&gt;setUserInteractionEnabled(renderer().style().pointerEvents() != PointerEvents::None);
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1331,26 ***</span>
  
  void RenderLayerBacking::updateInternalHierarchy()
  {
      // m_foregroundLayer has to be inserted in the correct order with child layers,
      // so it&#39;s not inserted here.
<span class="line-modified">!     if (m_ancestorClippingLayer)</span>
<span class="line-modified">!         m_ancestorClippingLayer-&gt;removeAllChildren();</span>
  
      if (m_contentsContainmentLayer) {
          m_contentsContainmentLayer-&gt;removeAllChildren();
<span class="line-modified">!         if (m_ancestorClippingLayer)</span>
<span class="line-modified">!             m_ancestorClippingLayer-&gt;addChild(*m_contentsContainmentLayer);</span>
      }
  
      if (m_backgroundLayer)
          m_contentsContainmentLayer-&gt;addChild(*m_backgroundLayer);
  
      if (m_contentsContainmentLayer)
          m_contentsContainmentLayer-&gt;addChild(*m_graphicsLayer);
<span class="line-modified">!     else if (m_ancestorClippingLayer)</span>
<span class="line-modified">!         m_ancestorClippingLayer-&gt;addChild(*m_graphicsLayer);</span>
  
      if (m_childContainmentLayer)
          m_graphicsLayer-&gt;addChild(*m_childContainmentLayer);
  
      if (m_scrollContainerLayer) {
<span class="line-new-header">--- 1470,37 ---</span>
  
  void RenderLayerBacking::updateInternalHierarchy()
  {
      // m_foregroundLayer has to be inserted in the correct order with child layers,
      // so it&#39;s not inserted here.
<span class="line-modified">!     GraphicsLayer* lastClippingLayer = nullptr;</span>
<span class="line-modified">!     if (m_ancestorClippingStack) {</span>
<span class="line-added">+         auto&amp; clippingStack = m_ancestorClippingStack-&gt;stack();</span>
<span class="line-added">+         for (unsigned i = 0; i &lt; clippingStack.size() - 1; ++i) {</span>
<span class="line-added">+             auto&amp; entry = clippingStack.at(i);</span>
<span class="line-added">+             Vector&lt;Ref&lt;GraphicsLayer&gt;&gt; children;</span>
<span class="line-added">+             children.append(*clippingStack.at(i + 1).clippingLayer);</span>
<span class="line-added">+             entry.clippingLayer-&gt;setChildren(WTFMove(children));</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         lastClippingLayer = clippingStack.last().clippingLayer.get();</span>
<span class="line-added">+         lastClippingLayer-&gt;removeAllChildren();</span>
<span class="line-added">+     }</span>
  
      if (m_contentsContainmentLayer) {
          m_contentsContainmentLayer-&gt;removeAllChildren();
<span class="line-modified">!         if (lastClippingLayer)</span>
<span class="line-modified">!             lastClippingLayer-&gt;addChild(*m_contentsContainmentLayer);</span>
      }
  
      if (m_backgroundLayer)
          m_contentsContainmentLayer-&gt;addChild(*m_backgroundLayer);
  
      if (m_contentsContainmentLayer)
          m_contentsContainmentLayer-&gt;addChild(*m_graphicsLayer);
<span class="line-modified">!     else if (lastClippingLayer)</span>
<span class="line-modified">!         lastClippingLayer-&gt;addChild(*m_graphicsLayer);</span>
  
      if (m_childContainmentLayer)
          m_graphicsLayer-&gt;addChild(*m_childContainmentLayer);
  
      if (m_scrollContainerLayer) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1375,11 ***</span>
  {
      m_graphicsLayer-&gt;setContentsRect(snapRectToDevicePixels(contentsBox(), deviceScaleFactor()));
  
      if (is&lt;RenderBox&gt;(renderer())) {
          LayoutRect boxRect(LayoutPoint(), downcast&lt;RenderBox&gt;(renderer()).size());
<span class="line-modified">!         boxRect.move(contentOffsetInCompostingLayer());</span>
          FloatRoundedRect contentsClippingRect = renderer().style().getRoundedInnerBorderFor(boxRect).pixelSnappedRoundedRectForPainting(deviceScaleFactor());
          m_graphicsLayer-&gt;setContentsClippingRect(contentsClippingRect);
      }
  
      m_graphicsLayer-&gt;setContentsTileSize(IntSize());
<span class="line-new-header">--- 1525,11 ---</span>
  {
      m_graphicsLayer-&gt;setContentsRect(snapRectToDevicePixels(contentsBox(), deviceScaleFactor()));
  
      if (is&lt;RenderBox&gt;(renderer())) {
          LayoutRect boxRect(LayoutPoint(), downcast&lt;RenderBox&gt;(renderer()).size());
<span class="line-modified">!         boxRect.move(contentOffsetInCompositingLayer());</span>
          FloatRoundedRect contentsClippingRect = renderer().style().getRoundedInnerBorderFor(boxRect).pixelSnappedRoundedRectForPainting(deviceScaleFactor());
          m_graphicsLayer-&gt;setContentsClippingRect(contentsClippingRect);
      }
  
      m_graphicsLayer-&gt;setContentsTileSize(IntSize());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1402,11 ***</span>
          // m_scrollContainerLayer never has backing store.
          // m_scrolledContentsLayer only needs backing store if the scrolled contents need to paint.
          bool hasNonScrollingPaintedContent = m_owningLayer.hasVisibleContent() &amp;&amp; m_owningLayer.hasVisibleBoxDecorationsOrBackground();
          m_graphicsLayer-&gt;setDrawsContent(hasNonScrollingPaintedContent);
  
<span class="line-modified">!         bool hasScrollingPaintedContent = m_owningLayer.hasVisibleContent() &amp;&amp; (renderer().hasBackground() || contentsInfo.paintsContent());</span>
          m_scrolledContentsLayer-&gt;setDrawsContent(hasScrollingPaintedContent);
          return;
      }
  
      bool hasPaintedContent = containsPaintedContent(contentsInfo);
<span class="line-new-header">--- 1552,11 ---</span>
          // m_scrollContainerLayer never has backing store.
          // m_scrolledContentsLayer only needs backing store if the scrolled contents need to paint.
          bool hasNonScrollingPaintedContent = m_owningLayer.hasVisibleContent() &amp;&amp; m_owningLayer.hasVisibleBoxDecorationsOrBackground();
          m_graphicsLayer-&gt;setDrawsContent(hasNonScrollingPaintedContent);
  
<span class="line-modified">!         bool hasScrollingPaintedContent = hasBackingSharingLayers() || (m_owningLayer.hasVisibleContent() &amp;&amp; (renderer().hasBackground() || contentsInfo.paintsContent()));</span>
          m_scrolledContentsLayer-&gt;setDrawsContent(hasScrollingPaintedContent);
          return;
      }
  
      bool hasPaintedContent = containsPaintedContent(contentsInfo);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1426,24 ***</span>
  
      if (m_backgroundLayer)
          m_backgroundLayer-&gt;setDrawsContent(m_backgroundLayerPaintsFixedRootBackground ? hasPaintedContent : contentsInfo.paintsBoxDecorations());
  }
  
  // Return true if the layer changed.
<span class="line-modified">! bool RenderLayerBacking::updateAncestorClippingLayer(bool needsAncestorClip)</span>
  {
      bool layersChanged = false;
  
      if (needsAncestorClip) {
<span class="line-modified">!         if (!m_ancestorClippingLayer) {</span>
<span class="line-modified">!             m_ancestorClippingLayer = createGraphicsLayer(&quot;ancestor clipping&quot;);</span>
<span class="line-modified">!             m_ancestorClippingLayer-&gt;setMasksToBounds(true);</span>
              layersChanged = true;
          }
<span class="line-modified">!     } else if (hasAncestorClippingLayer()) {</span>
<span class="line-modified">!         willDestroyLayer(m_ancestorClippingLayer.get());</span>
<span class="line-modified">!         GraphicsLayer::unparentAndClear(m_ancestorClippingLayer);</span>
          layersChanged = true;
      }
  
      return layersChanged;
  }
<span class="line-new-header">--- 1576,99 ---</span>
  
      if (m_backgroundLayer)
          m_backgroundLayer-&gt;setDrawsContent(m_backgroundLayerPaintsFixedRootBackground ? hasPaintedContent : contentsInfo.paintsBoxDecorations());
  }
  
<span class="line-added">+ void RenderLayerBacking::updateEventRegion()</span>
<span class="line-added">+ {</span>
<span class="line-added">+ #if PLATFORM(IOS_FAMILY)</span>
<span class="line-added">+     if (paintsIntoCompositedAncestor())</span>
<span class="line-added">+         return;</span>
<span class="line-added">+ </span>
<span class="line-added">+     bool hasTouchActionElements = false;</span>
<span class="line-added">+ #if ENABLE(POINTER_EVENTS)</span>
<span class="line-added">+     hasTouchActionElements = renderer().document().mayHaveElementsWithNonAutoTouchAction();</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+     if (m_owningLayer.isRenderViewLayer() &amp;&amp; !hasTouchActionElements)</span>
<span class="line-added">+         return;</span>
<span class="line-added">+ </span>
<span class="line-added">+     GraphicsContext nullContext(nullptr);</span>
<span class="line-added">+     RenderLayer::LayerPaintingInfo paintingInfo(&amp;m_owningLayer, compositedBounds(), { }, LayoutSize());</span>
<span class="line-added">+ </span>
<span class="line-added">+     EventRegion eventRegion;</span>
<span class="line-added">+     auto eventRegionContext = eventRegion.makeContext();</span>
<span class="line-added">+     paintingInfo.eventRegionContext = &amp;eventRegionContext;</span>
<span class="line-added">+ </span>
<span class="line-added">+     auto paintFlags = RenderLayer::paintLayerPaintingCompositingAllPhasesFlags() | RenderLayer::PaintLayerCollectingEventRegion;</span>
<span class="line-added">+     m_owningLayer.paintLayerContents(nullContext, paintingInfo, paintFlags);</span>
<span class="line-added">+ </span>
<span class="line-added">+     for (auto&amp; layer : m_backingSharingLayers)</span>
<span class="line-added">+         layer-&gt;paintLayerWithEffects(nullContext, paintingInfo, paintFlags);</span>
<span class="line-added">+ </span>
<span class="line-added">+     GraphicsLayer&amp; layerForEventRegion = m_scrolledContentsLayer ? *m_scrolledContentsLayer : *m_graphicsLayer;</span>
<span class="line-added">+ </span>
<span class="line-added">+     auto layerOffset = toIntSize(layerForEventRegion.scrollOffset()) - roundedIntSize(layerForEventRegion.offsetFromRenderer());</span>
<span class="line-added">+     eventRegion.translate(layerOffset);</span>
<span class="line-added">+ </span>
<span class="line-added">+     layerForEventRegion.setEventRegion(WTFMove(eventRegion));</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ bool RenderLayerBacking::updateAncestorClippingStack(Vector&lt;CompositedClipData&gt;&amp;&amp; clippingData)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     if (!m_ancestorClippingStack &amp;&amp; clippingData.isEmpty())</span>
<span class="line-added">+         return false;</span>
<span class="line-added">+ </span>
<span class="line-added">+     auto* scrollingCoordinator = m_owningLayer.page().scrollingCoordinator();</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (m_ancestorClippingStack &amp;&amp; clippingData.isEmpty()) {</span>
<span class="line-added">+         m_ancestorClippingStack-&gt;clear(scrollingCoordinator);</span>
<span class="line-added">+         m_ancestorClippingStack = nullptr;</span>
<span class="line-added">+         return true;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (!m_ancestorClippingStack) {</span>
<span class="line-added">+         m_ancestorClippingStack = makeUnique&lt;LayerAncestorClippingStack&gt;(WTFMove(clippingData));</span>
<span class="line-added">+         LOG_WITH_STREAM(Compositing, stream &lt;&lt; &quot;layer &quot; &lt;&lt; &amp;m_owningLayer &lt;&lt; &quot; ancestorClippingStack &quot; &lt;&lt; *m_ancestorClippingStack);</span>
<span class="line-added">+         return true;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (m_ancestorClippingStack-&gt;equalToClipData(clippingData)) {</span>
<span class="line-added">+         LOG_WITH_STREAM(Compositing, stream &lt;&lt; &quot;layer &quot; &lt;&lt; &amp;m_owningLayer &lt;&lt; &quot; ancestorClippingStack &quot; &lt;&lt; *m_ancestorClippingStack);</span>
<span class="line-added">+         return false;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     m_ancestorClippingStack-&gt;updateWithClipData(scrollingCoordinator, WTFMove(clippingData));</span>
<span class="line-added">+     LOG_WITH_STREAM(Compositing, stream &lt;&lt; &quot;layer &quot; &lt;&lt; &amp;m_owningLayer &lt;&lt; &quot; ancestorClippingStack &quot; &lt;&lt; *m_ancestorClippingStack);</span>
<span class="line-added">+     return true;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  // Return true if the layer changed.
<span class="line-modified">! bool RenderLayerBacking::updateAncestorClipping(bool needsAncestorClip, const RenderLayer* compositingAncestor)</span>
  {
      bool layersChanged = false;
  
      if (needsAncestorClip) {
<span class="line-modified">!         if (compositor().updateAncestorClippingStack(m_owningLayer, compositingAncestor)) {</span>
<span class="line-modified">!             // Make any layers we don&#39;t have.</span>
<span class="line-modified">!             if (m_ancestorClippingStack) {</span>
<span class="line-added">+                 for (auto&amp; entry : m_ancestorClippingStack-&gt;stack()) {</span>
<span class="line-added">+                     if (!entry.clippingLayer) {</span>
<span class="line-added">+                         entry.clippingLayer = createGraphicsLayer(entry.clipData.isOverflowScroll ? &quot;clip for scroller&quot; : &quot;ancestor clipping&quot;);</span>
<span class="line-added">+                         entry.clippingLayer-&gt;setMasksToBounds(true);</span>
<span class="line-added">+                         entry.clippingLayer-&gt;setPaintingPhase({ });</span>
<span class="line-added">+                     }</span>
<span class="line-added">+                 }</span>
<span class="line-added">+             }</span>
<span class="line-added">+ </span>
              layersChanged = true;
          }
<span class="line-modified">!     } else if (m_ancestorClippingStack) {</span>
<span class="line-modified">!         for (auto&amp; entry : m_ancestorClippingStack-&gt;stack())</span>
<span class="line-modified">!             GraphicsLayer::unparentAndClear(entry.clippingLayer);</span>
<span class="line-added">+ </span>
<span class="line-added">+         m_ancestorClippingStack = nullptr;</span>
          layersChanged = true;
      }
  
      return layersChanged;
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1515,11 ***</span>
  {
      bool horizontalScrollbarLayerChanged = false;
      if (needsHorizontalScrollbarLayer) {
          if (!m_layerForHorizontalScrollbar) {
              m_layerForHorizontalScrollbar = createGraphicsLayer(&quot;horizontal scrollbar&quot;);
<span class="line-modified">!             m_layerForHorizontalScrollbar-&gt;setCanDetachBackingStore(false);</span>
              horizontalScrollbarLayerChanged = true;
          }
      } else if (m_layerForHorizontalScrollbar) {
          willDestroyLayer(m_layerForHorizontalScrollbar.get());
          GraphicsLayer::unparentAndClear(m_layerForHorizontalScrollbar);
<span class="line-new-header">--- 1740,11 ---</span>
  {
      bool horizontalScrollbarLayerChanged = false;
      if (needsHorizontalScrollbarLayer) {
          if (!m_layerForHorizontalScrollbar) {
              m_layerForHorizontalScrollbar = createGraphicsLayer(&quot;horizontal scrollbar&quot;);
<span class="line-modified">!             m_layerForHorizontalScrollbar-&gt;setAllowsBackingStoreDetaching(false);</span>
              horizontalScrollbarLayerChanged = true;
          }
      } else if (m_layerForHorizontalScrollbar) {
          willDestroyLayer(m_layerForHorizontalScrollbar.get());
          GraphicsLayer::unparentAndClear(m_layerForHorizontalScrollbar);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1528,11 ***</span>
  
      bool verticalScrollbarLayerChanged = false;
      if (needsVerticalScrollbarLayer) {
          if (!m_layerForVerticalScrollbar) {
              m_layerForVerticalScrollbar = createGraphicsLayer(&quot;vertical scrollbar&quot;);
<span class="line-modified">!             m_layerForVerticalScrollbar-&gt;setCanDetachBackingStore(false);</span>
              verticalScrollbarLayerChanged = true;
          }
      } else if (m_layerForVerticalScrollbar) {
          willDestroyLayer(m_layerForVerticalScrollbar.get());
          GraphicsLayer::unparentAndClear(m_layerForVerticalScrollbar);
<span class="line-new-header">--- 1753,11 ---</span>
  
      bool verticalScrollbarLayerChanged = false;
      if (needsVerticalScrollbarLayer) {
          if (!m_layerForVerticalScrollbar) {
              m_layerForVerticalScrollbar = createGraphicsLayer(&quot;vertical scrollbar&quot;);
<span class="line-modified">!             m_layerForVerticalScrollbar-&gt;setAllowsBackingStoreDetaching(false);</span>
              verticalScrollbarLayerChanged = true;
          }
      } else if (m_layerForVerticalScrollbar) {
          willDestroyLayer(m_layerForVerticalScrollbar.get());
          GraphicsLayer::unparentAndClear(m_layerForVerticalScrollbar);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1541,11 ***</span>
  
      bool scrollCornerLayerChanged = false;
      if (needsScrollCornerLayer) {
          if (!m_layerForScrollCorner) {
              m_layerForScrollCorner = createGraphicsLayer(&quot;scroll corner&quot;);
<span class="line-modified">!             m_layerForScrollCorner-&gt;setCanDetachBackingStore(false);</span>
              scrollCornerLayerChanged = true;
          }
      } else if (m_layerForScrollCorner) {
          willDestroyLayer(m_layerForScrollCorner.get());
          GraphicsLayer::unparentAndClear(m_layerForScrollCorner);
<span class="line-new-header">--- 1766,11 ---</span>
  
      bool scrollCornerLayerChanged = false;
      if (needsScrollCornerLayer) {
          if (!m_layerForScrollCorner) {
              m_layerForScrollCorner = createGraphicsLayer(&quot;scroll corner&quot;);
<span class="line-modified">!             m_layerForScrollCorner-&gt;setAllowsBackingStoreDetaching(false);</span>
              scrollCornerLayerChanged = true;
          }
      } else if (m_layerForScrollCorner) {
          willDestroyLayer(m_layerForScrollCorner.get());
          GraphicsLayer::unparentAndClear(m_layerForScrollCorner);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1608,24 ***</span>
      if (needsForegroundLayer) {
          if (!m_foregroundLayer) {
              String layerName = m_owningLayer.name() + &quot; (foreground)&quot;;
              m_foregroundLayer = createGraphicsLayer(layerName);
              m_foregroundLayer-&gt;setDrawsContent(true);
<span class="line-removed">-             m_foregroundLayer-&gt;setPaintingPhase(GraphicsLayerPaintForeground);</span>
              layerChanged = true;
          }
      } else if (m_foregroundLayer) {
          willDestroyLayer(m_foregroundLayer.get());
          GraphicsLayer::unparentAndClear(m_foregroundLayer);
          layerChanged = true;
      }
  
<span class="line-removed">-     if (layerChanged) {</span>
<span class="line-removed">-         m_graphicsLayer-&gt;setNeedsDisplay();</span>
<span class="line-removed">-         m_graphicsLayer-&gt;setPaintingPhase(paintingPhaseForPrimaryLayer());</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
      return layerChanged;
  }
  
  bool RenderLayerBacking::updateBackgroundLayer(bool needsBackgroundLayer)
  {
<span class="line-new-header">--- 1833,18 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1634,11 ***</span>
          if (!m_backgroundLayer) {
              String layerName = m_owningLayer.name() + &quot; (background)&quot;;
              m_backgroundLayer = createGraphicsLayer(layerName);
              m_backgroundLayer-&gt;setDrawsContent(true);
              m_backgroundLayer-&gt;setAnchorPoint(FloatPoint3D());
<span class="line-removed">-             m_backgroundLayer-&gt;setPaintingPhase(GraphicsLayerPaintBackground);</span>
              layerChanged = true;
          }
  
          if (!m_contentsContainmentLayer) {
              String layerName = m_owningLayer.name() + &quot; (contents containment)&quot;;
<span class="line-new-header">--- 1853,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1659,32 ***</span>
              layerChanged = true;
              m_graphicsLayer-&gt;setAppliesPageScale(true);
          }
      }
  
<span class="line-removed">-     if (layerChanged)</span>
<span class="line-removed">-         m_graphicsLayer-&gt;setNeedsDisplay();</span>
<span class="line-removed">- </span>
      return layerChanged;
  }
  
  // Masking layer is used for masks or clip-path.
<span class="line-modified">! void RenderLayerBacking::updateMaskingLayer(bool hasMask, bool hasClipPath)</span>
  {
      bool layerChanged = false;
      if (hasMask || hasClipPath) {
<span class="line-modified">!         GraphicsLayerPaintingPhase maskPhases = 0;</span>
          if (hasMask)
<span class="line-modified">!             maskPhases = GraphicsLayerPaintMask;</span>
  
          if (hasClipPath) {
              // If we have a mask, we need to paint the combined clip-path and mask into the mask layer.
              if (hasMask || renderer().style().clipPath()-&gt;type() == ClipPathOperation::Reference || !GraphicsLayer::supportsLayerType(GraphicsLayer::Type::Shape))
<span class="line-modified">!                 maskPhases |= GraphicsLayerPaintClipPath;</span>
          }
  
<span class="line-modified">!         bool paintsContent = maskPhases;</span>
          GraphicsLayer::Type requiredLayerType = paintsContent ? GraphicsLayer::Type::Normal : GraphicsLayer::Type::Shape;
          if (m_maskLayer &amp;&amp; m_maskLayer-&gt;type() != requiredLayerType) {
              m_graphicsLayer-&gt;setMaskLayer(nullptr);
              willDestroyLayer(m_maskLayer.get());
              GraphicsLayer::clear(m_maskLayer);
<span class="line-new-header">--- 1877,29 ---</span>
              layerChanged = true;
              m_graphicsLayer-&gt;setAppliesPageScale(true);
          }
      }
  
      return layerChanged;
  }
  
  // Masking layer is used for masks or clip-path.
<span class="line-modified">! bool RenderLayerBacking::updateMaskingLayer(bool hasMask, bool hasClipPath)</span>
  {
      bool layerChanged = false;
      if (hasMask || hasClipPath) {
<span class="line-modified">!         OptionSet&lt;GraphicsLayerPaintingPhase&gt; maskPhases;</span>
          if (hasMask)
<span class="line-modified">!             maskPhases = GraphicsLayerPaintingPhase::Mask;</span>
  
          if (hasClipPath) {
              // If we have a mask, we need to paint the combined clip-path and mask into the mask layer.
              if (hasMask || renderer().style().clipPath()-&gt;type() == ClipPathOperation::Reference || !GraphicsLayer::supportsLayerType(GraphicsLayer::Type::Shape))
<span class="line-modified">!                 maskPhases.add(GraphicsLayerPaintingPhase::ClipPath);</span>
          }
  
<span class="line-modified">!         bool paintsContent = !maskPhases.isEmpty();</span>
          GraphicsLayer::Type requiredLayerType = paintsContent ? GraphicsLayer::Type::Normal : GraphicsLayer::Type::Shape;
          if (m_maskLayer &amp;&amp; m_maskLayer-&gt;type() != requiredLayerType) {
              m_graphicsLayer-&gt;setMaskLayer(nullptr);
              willDestroyLayer(m_maskLayer.get());
              GraphicsLayer::clear(m_maskLayer);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1704,65 ***</span>
          willDestroyLayer(m_maskLayer.get());
          GraphicsLayer::clear(m_maskLayer);
          layerChanged = true;
      }
  
<span class="line-modified">!     if (layerChanged)</span>
<span class="line-removed">-         m_graphicsLayer-&gt;setPaintingPhase(paintingPhaseForPrimaryLayer());</span>
  }
  
  void RenderLayerBacking::updateChildClippingStrategy(bool needsDescendantsClippingLayer)
  {
      if (hasClippingLayer() &amp;&amp; needsDescendantsClippingLayer) {
          if (is&lt;RenderBox&gt;(renderer()) &amp;&amp; (renderer().style().clipPath() || renderer().style().hasBorderRadius())) {
              LayoutRect boxRect(LayoutPoint(), downcast&lt;RenderBox&gt;(renderer()).size());
<span class="line-removed">-             boxRect.move(contentOffsetInCompostingLayer());</span>
              FloatRoundedRect contentsClippingRect = renderer().style().getRoundedInnerBorderFor(boxRect).pixelSnappedRoundedRectForPainting(deviceScaleFactor());
<span class="line-modified">!             if (clippingLayer()-&gt;setMasksToBoundsRect(contentsClippingRect)) {</span>
<span class="line-modified">!                 clippingLayer()-&gt;setMaskLayer(nullptr);</span>
                  GraphicsLayer::clear(m_childClippingMaskLayer);
                  return;
              }
  
              if (!m_childClippingMaskLayer) {
                  m_childClippingMaskLayer = createGraphicsLayer(&quot;child clipping mask&quot;);
                  m_childClippingMaskLayer-&gt;setDrawsContent(true);
<span class="line-modified">!                 m_childClippingMaskLayer-&gt;setPaintingPhase(GraphicsLayerPaintChildClippingMask);</span>
                  clippingLayer()-&gt;setMaskLayer(m_childClippingMaskLayer.copyRef());
              }
          }
      } else {
          if (m_childClippingMaskLayer) {
              if (hasClippingLayer())
                  clippingLayer()-&gt;setMaskLayer(nullptr);
              GraphicsLayer::clear(m_childClippingMaskLayer);
          } else
              if (hasClippingLayer())
<span class="line-modified">!                 clippingLayer()-&gt;setMasksToBoundsRect(FloatRoundedRect(FloatRect(FloatPoint(), clippingLayer()-&gt;size())));</span>
      }
  }
  
  bool RenderLayerBacking::updateScrollingLayers(bool needsScrollingLayers)
  {
      if (needsScrollingLayers == !!m_scrollContainerLayer)
          return false;
  
      if (!m_scrollContainerLayer) {
<span class="line-modified">!         // Outer layer which corresponds with the scroll view.</span>
          m_scrollContainerLayer = createGraphicsLayer(&quot;scroll container&quot;, GraphicsLayer::Type::ScrollContainer);
          m_scrollContainerLayer-&gt;setDrawsContent(false);
          m_scrollContainerLayer-&gt;setMasksToBounds(true);
  
          // Inner layer which renders the content that scrolls.
<span class="line-modified">!         m_scrolledContentsLayer = createGraphicsLayer(&quot;scrolled contents&quot;);</span>
          m_scrolledContentsLayer-&gt;setDrawsContent(true);
          m_scrolledContentsLayer-&gt;setAnchorPoint({ });
<span class="line-removed">- </span>
<span class="line-removed">-         GraphicsLayerPaintingPhase paintPhase = GraphicsLayerPaintOverflowContents | GraphicsLayerPaintCompositedScroll;</span>
<span class="line-removed">-         if (!m_foregroundLayer)</span>
<span class="line-removed">-             paintPhase |= GraphicsLayerPaintForeground;</span>
<span class="line-removed">-         m_scrolledContentsLayer-&gt;setPaintingPhase(paintPhase);</span>
          m_scrollContainerLayer-&gt;addChild(*m_scrolledContentsLayer);
      } else {
          compositor().willRemoveScrollingLayerWithBacking(m_owningLayer, *this);
  
          willDestroyLayer(m_scrollContainerLayer.get());
<span class="line-new-header">--- 1919,62 ---</span>
          willDestroyLayer(m_maskLayer.get());
          GraphicsLayer::clear(m_maskLayer);
          layerChanged = true;
      }
  
<span class="line-modified">!     return layerChanged;</span>
  }
  
  void RenderLayerBacking::updateChildClippingStrategy(bool needsDescendantsClippingLayer)
  {
      if (hasClippingLayer() &amp;&amp; needsDescendantsClippingLayer) {
          if (is&lt;RenderBox&gt;(renderer()) &amp;&amp; (renderer().style().clipPath() || renderer().style().hasBorderRadius())) {
<span class="line-added">+             auto* clipLayer = clippingLayer();</span>
              LayoutRect boxRect(LayoutPoint(), downcast&lt;RenderBox&gt;(renderer()).size());
              FloatRoundedRect contentsClippingRect = renderer().style().getRoundedInnerBorderFor(boxRect).pixelSnappedRoundedRectForPainting(deviceScaleFactor());
<span class="line-modified">!             contentsClippingRect.move(LayoutSize(clipLayer-&gt;offsetFromRenderer()));</span>
<span class="line-modified">!             // Note that we have to set this rounded rect again during the geometry update (clipLayer-&gt;offsetFromRenderer() may be stale here).</span>
<span class="line-added">+             if (clipLayer-&gt;setMasksToBoundsRect(contentsClippingRect)) {</span>
<span class="line-added">+                 clipLayer-&gt;setMaskLayer(nullptr);</span>
                  GraphicsLayer::clear(m_childClippingMaskLayer);
                  return;
              }
  
              if (!m_childClippingMaskLayer) {
                  m_childClippingMaskLayer = createGraphicsLayer(&quot;child clipping mask&quot;);
                  m_childClippingMaskLayer-&gt;setDrawsContent(true);
<span class="line-modified">!                 m_childClippingMaskLayer-&gt;setPaintingPhase({ GraphicsLayerPaintingPhase::ChildClippingMask });</span>
                  clippingLayer()-&gt;setMaskLayer(m_childClippingMaskLayer.copyRef());
              }
          }
      } else {
          if (m_childClippingMaskLayer) {
              if (hasClippingLayer())
                  clippingLayer()-&gt;setMaskLayer(nullptr);
              GraphicsLayer::clear(m_childClippingMaskLayer);
          } else
              if (hasClippingLayer())
<span class="line-modified">!                 clippingLayer()-&gt;setMasksToBoundsRect(FloatRoundedRect(FloatRect({ }, clippingLayer()-&gt;size())));</span>
      }
  }
  
  bool RenderLayerBacking::updateScrollingLayers(bool needsScrollingLayers)
  {
      if (needsScrollingLayers == !!m_scrollContainerLayer)
          return false;
  
      if (!m_scrollContainerLayer) {
<span class="line-modified">!         // Outer layer which corresponds with the scroll view. This never paints content.</span>
          m_scrollContainerLayer = createGraphicsLayer(&quot;scroll container&quot;, GraphicsLayer::Type::ScrollContainer);
<span class="line-added">+         m_scrollContainerLayer-&gt;setPaintingPhase({ });</span>
          m_scrollContainerLayer-&gt;setDrawsContent(false);
          m_scrollContainerLayer-&gt;setMasksToBounds(true);
  
          // Inner layer which renders the content that scrolls.
<span class="line-modified">!         m_scrolledContentsLayer = createGraphicsLayer(&quot;scrolled contents&quot;, GraphicsLayer::Type::ScrolledContents);</span>
          m_scrolledContentsLayer-&gt;setDrawsContent(true);
          m_scrolledContentsLayer-&gt;setAnchorPoint({ });
          m_scrollContainerLayer-&gt;addChild(*m_scrolledContentsLayer);
      } else {
          compositor().willRemoveScrollingLayerWithBacking(m_owningLayer, *this);
  
          willDestroyLayer(m_scrollContainerLayer.get());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1770,93 ***</span>
  
          GraphicsLayer::unparentAndClear(m_scrollContainerLayer);
          GraphicsLayer::unparentAndClear(m_scrolledContentsLayer);
      }
  
<span class="line-removed">-     m_graphicsLayer-&gt;setPaintingPhase(paintingPhaseForPrimaryLayer());</span>
<span class="line-removed">-     m_graphicsLayer-&gt;setNeedsDisplay(); // Because painting phases changed.</span>
<span class="line-removed">- </span>
      if (m_scrollContainerLayer)
          compositor().didAddScrollingLayer(m_owningLayer);
  
      return true;
  }
  
<span class="line-removed">- OptionSet&lt;ScrollCoordinationRole&gt; RenderLayerBacking::coordinatedScrollingRoles() const</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     auto&amp; compositor = this-&gt;compositor();</span>
<span class="line-removed">- </span>
<span class="line-removed">-     OptionSet&lt;ScrollCoordinationRole&gt; coordinationRoles;</span>
<span class="line-removed">-     if (compositor.isViewportConstrainedFixedOrStickyLayer(m_owningLayer))</span>
<span class="line-removed">-         coordinationRoles.add(ScrollCoordinationRole::ViewportConstrained);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     if (compositor.useCoordinatedScrollingForLayer(m_owningLayer))</span>
<span class="line-removed">-         coordinationRoles.add(ScrollCoordinationRole::Scrolling);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     if (compositor.isLayerForIFrameWithScrollCoordinatedContents(m_owningLayer))</span>
<span class="line-removed">-         coordinationRoles.add(ScrollCoordinationRole::FrameHosting);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     return coordinationRoles;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  void RenderLayerBacking::detachFromScrollingCoordinator(OptionSet&lt;ScrollCoordinationRole&gt; roles)
  {
<span class="line-modified">!     if (!m_scrollingNodeID &amp;&amp; !m_frameHostingNodeID &amp;&amp; !m_viewportConstrainedNodeID)</span>
          return;
  
      auto* scrollingCoordinator = m_owningLayer.page().scrollingCoordinator();
      if (!scrollingCoordinator)
          return;
  
      if (roles.contains(ScrollCoordinationRole::Scrolling) &amp;&amp; m_scrollingNodeID) {
<span class="line-modified">!         LOG(Compositing, &quot;Detaching Scrolling node %&quot; PRIu64, m_scrollingNodeID);</span>
          scrollingCoordinator-&gt;unparentChildrenAndDestroyNode(m_scrollingNodeID);
          m_scrollingNodeID = 0;
      }
  
<span class="line-modified">!     if (roles.contains(ScrollCoordinationRole::Scrolling) &amp;&amp; m_frameHostingNodeID) {</span>
<span class="line-modified">!         LOG(Compositing, &quot;Detaching FrameHosting node %&quot; PRIu64, m_frameHostingNodeID);</span>
          scrollingCoordinator-&gt;unparentChildrenAndDestroyNode(m_frameHostingNodeID);
          m_frameHostingNodeID = 0;
      }
  
      if (roles.contains(ScrollCoordinationRole::ViewportConstrained) &amp;&amp; m_viewportConstrainedNodeID) {
<span class="line-modified">!         LOG(Compositing, &quot;Detaching ViewportConstrained node %&quot; PRIu64, m_viewportConstrainedNodeID);</span>
          scrollingCoordinator-&gt;unparentChildrenAndDestroyNode(m_viewportConstrainedNodeID);
          m_viewportConstrainedNodeID = 0;
      }
<span class="line-removed">- }</span>
  
<span class="line-modified">! void RenderLayerBacking::setIsScrollCoordinatedWithViewportConstrainedRole(bool viewportCoordinated)</span>
<span class="line-modified">! {</span>
<span class="line-modified">!     m_graphicsLayer-&gt;setIsViewportConstrained(viewportCoordinated);</span>
  }
  
<span class="line-modified">! GraphicsLayerPaintingPhase RenderLayerBacking::paintingPhaseForPrimaryLayer() const</span>
  {
<span class="line-modified">!     unsigned phase = 0;</span>
<span class="line-modified">!     if (!m_backgroundLayer)</span>
<span class="line-removed">-         phase |= GraphicsLayerPaintBackground;</span>
<span class="line-removed">-     if (!m_foregroundLayer)</span>
<span class="line-removed">-         phase |= GraphicsLayerPaintForeground;</span>
  
<span class="line-modified">!     if (m_scrolledContentsLayer) {</span>
<span class="line-modified">!         phase &amp;= ~GraphicsLayerPaintForeground;</span>
<span class="line-modified">!         phase |= GraphicsLayerPaintCompositedScroll;</span>
      }
  
<span class="line-modified">!     return static_cast&lt;GraphicsLayerPaintingPhase&gt;(phase);</span>
  }
  
  float RenderLayerBacking::compositingOpacity(float rendererOpacity) const
  {
      float finalOpacity = rendererOpacity;
  
      for (auto* curr = m_owningLayer.parent(); curr; curr = curr-&gt;parent()) {
          // We only care about parents that are stacking contexts.
          // Recall that opacity creates stacking context.
<span class="line-modified">!         if (!curr-&gt;isStackingContext())</span>
              continue;
  
          // If we found a compositing layer, we want to compute opacity
          // relative to it. So we can break here.
          if (curr-&gt;isComposited())
<span class="line-new-header">--- 1982,82 ---</span>
  
          GraphicsLayer::unparentAndClear(m_scrollContainerLayer);
          GraphicsLayer::unparentAndClear(m_scrolledContentsLayer);
      }
  
      if (m_scrollContainerLayer)
          compositor().didAddScrollingLayer(m_owningLayer);
  
      return true;
  }
  
  void RenderLayerBacking::detachFromScrollingCoordinator(OptionSet&lt;ScrollCoordinationRole&gt; roles)
  {
<span class="line-modified">!     if (!m_scrollingNodeID &amp;&amp; !m_ancestorClippingStack &amp;&amp; !m_frameHostingNodeID &amp;&amp; !m_viewportConstrainedNodeID &amp;&amp; !m_positioningNodeID)</span>
          return;
  
      auto* scrollingCoordinator = m_owningLayer.page().scrollingCoordinator();
      if (!scrollingCoordinator)
          return;
  
      if (roles.contains(ScrollCoordinationRole::Scrolling) &amp;&amp; m_scrollingNodeID) {
<span class="line-modified">!         LOG_WITH_STREAM(Compositing, stream &lt;&lt; &quot;Detaching Scrolling node &quot; &lt;&lt; m_scrollingNodeID);</span>
          scrollingCoordinator-&gt;unparentChildrenAndDestroyNode(m_scrollingNodeID);
          m_scrollingNodeID = 0;
      }
  
<span class="line-modified">!     if (roles.contains(ScrollCoordinationRole::ScrollingProxy) &amp;&amp; m_ancestorClippingStack) {</span>
<span class="line-modified">!         m_ancestorClippingStack-&gt;detachFromScrollingCoordinator(*scrollingCoordinator);</span>
<span class="line-added">+         LOG_WITH_STREAM(Compositing, stream &lt;&lt; &quot;Detaching nodes in ancestor clipping stack&quot;);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (roles.contains(ScrollCoordinationRole::FrameHosting) &amp;&amp; m_frameHostingNodeID) {</span>
<span class="line-added">+         LOG_WITH_STREAM(Compositing, stream &lt;&lt; &quot;Detaching FrameHosting node &quot; &lt;&lt; m_frameHostingNodeID);</span>
          scrollingCoordinator-&gt;unparentChildrenAndDestroyNode(m_frameHostingNodeID);
          m_frameHostingNodeID = 0;
      }
  
      if (roles.contains(ScrollCoordinationRole::ViewportConstrained) &amp;&amp; m_viewportConstrainedNodeID) {
<span class="line-modified">!         LOG_WITH_STREAM(Compositing, stream &lt;&lt; &quot;Detaching ViewportConstrained node &quot; &lt;&lt; m_viewportConstrainedNodeID);</span>
          scrollingCoordinator-&gt;unparentChildrenAndDestroyNode(m_viewportConstrainedNodeID);
          m_viewportConstrainedNodeID = 0;
      }
  
<span class="line-modified">!     if (roles.contains(ScrollCoordinationRole::Positioning) &amp;&amp; m_positioningNodeID) {</span>
<span class="line-modified">!         LOG_WITH_STREAM(Compositing, stream &lt;&lt; &quot;Detaching Positioned node &quot; &lt;&lt; m_positioningNodeID);</span>
<span class="line-modified">!         scrollingCoordinator-&gt;unparentChildrenAndDestroyNode(m_positioningNodeID);</span>
<span class="line-added">+         m_positioningNodeID = 0;</span>
<span class="line-added">+     }</span>
  }
  
<span class="line-modified">! ScrollingNodeID RenderLayerBacking::scrollingNodeIDForChildren() const</span>
  {
<span class="line-modified">!     if (m_frameHostingNodeID)</span>
<span class="line-modified">!         return m_frameHostingNodeID;</span>
  
<span class="line-modified">!     if (m_scrollingNodeID)</span>
<span class="line-modified">!         return m_scrollingNodeID;</span>
<span class="line-modified">! </span>
<span class="line-added">+     if (m_viewportConstrainedNodeID)</span>
<span class="line-added">+         return m_viewportConstrainedNodeID;</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (m_ancestorClippingStack) {</span>
<span class="line-added">+         if (auto lastOverflowScrollProxyNode = m_ancestorClippingStack-&gt;lastOverflowScrollProxyNodeID())</span>
<span class="line-added">+             return lastOverflowScrollProxyNode;</span>
      }
  
<span class="line-modified">!     return m_positioningNodeID;</span>
  }
  
  float RenderLayerBacking::compositingOpacity(float rendererOpacity) const
  {
      float finalOpacity = rendererOpacity;
  
      for (auto* curr = m_owningLayer.parent(); curr; curr = curr-&gt;parent()) {
          // We only care about parents that are stacking contexts.
          // Recall that opacity creates stacking context.
<span class="line-modified">!         if (!curr-&gt;isCSSStackingContext())</span>
              continue;
  
          // If we found a compositing layer, we want to compute opacity
          // relative to it. So we can break here.
          if (curr-&gt;isComposited())
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2013,10 ***</span>
<span class="line-new-header">--- 2214,43 ---</span>
          m_graphicsLayer-&gt;setBackgroundColor(backgroundColor);
          m_graphicsLayer-&gt;setContentsOpaque(!viewIsTransparent);
      }
  }
  
<span class="line-added">+ void RenderLayerBacking::updatePaintingPhases()</span>
<span class="line-added">+ {</span>
<span class="line-added">+     // Phases for m_childClippingMaskLayer and m_maskLayer are set elsewhere.</span>
<span class="line-added">+     OptionSet&lt;GraphicsLayerPaintingPhase&gt; primaryLayerPhases = { GraphicsLayerPaintingPhase::Background, GraphicsLayerPaintingPhase::Foreground };</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (m_foregroundLayer) {</span>
<span class="line-added">+         OptionSet&lt;GraphicsLayerPaintingPhase&gt; foregroundLayerPhases { GraphicsLayerPaintingPhase::Foreground };</span>
<span class="line-added">+ </span>
<span class="line-added">+         if (m_scrolledContentsLayer)</span>
<span class="line-added">+             foregroundLayerPhases.add(GraphicsLayerPaintingPhase::OverflowContents);</span>
<span class="line-added">+ </span>
<span class="line-added">+         m_foregroundLayer-&gt;setPaintingPhase(foregroundLayerPhases);</span>
<span class="line-added">+         primaryLayerPhases.remove(GraphicsLayerPaintingPhase::Foreground);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (m_backgroundLayer) {</span>
<span class="line-added">+         m_backgroundLayer-&gt;setPaintingPhase(GraphicsLayerPaintingPhase::Background);</span>
<span class="line-added">+         primaryLayerPhases.remove(GraphicsLayerPaintingPhase::Background);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (m_scrolledContentsLayer) {</span>
<span class="line-added">+         OptionSet&lt;GraphicsLayerPaintingPhase&gt; scrolledContentLayerPhases = { GraphicsLayerPaintingPhase::OverflowContents, GraphicsLayerPaintingPhase::CompositedScroll };</span>
<span class="line-added">+         if (!m_foregroundLayer)</span>
<span class="line-added">+             scrolledContentLayerPhases.add(GraphicsLayerPaintingPhase::Foreground);</span>
<span class="line-added">+         m_scrolledContentsLayer-&gt;setPaintingPhase(scrolledContentLayerPhases);</span>
<span class="line-added">+ </span>
<span class="line-added">+         primaryLayerPhases.remove(GraphicsLayerPaintingPhase::Foreground);</span>
<span class="line-added">+         primaryLayerPhases.add(GraphicsLayerPaintingPhase::CompositedScroll);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     m_graphicsLayer-&gt;setPaintingPhase(primaryLayerPhases);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  static bool supportsDirectlyCompositedBoxDecorations(const RenderLayerModelObject&amp; renderer)
  {
      if (!GraphicsLayer::supportsBackgroundColorContent())
          return false;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2100,10 ***</span>
<span class="line-new-header">--- 2334,13 ---</span>
  bool RenderLayerBacking::isSimpleContainerCompositingLayer(PaintedContentsInfo&amp; contentsInfo) const
  {
      if (m_owningLayer.isRenderViewLayer())
          return false;
  
<span class="line-added">+     if (hasBackingSharingLayers())</span>
<span class="line-added">+         return false;</span>
<span class="line-added">+ </span>
      if (renderer().isRenderReplaced() &amp;&amp; (!isCompositedPlugin(renderer()) || isRestartedPlugin(renderer())))
          return false;
  
      if (renderer().isTextControl())
          return false;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2237,11 ***</span>
  
          auto* image = cachedImage-&gt;imageForRenderer(&amp;imageRenderer);
          if (!is&lt;BitmapImage&gt;(image))
              return false;
  
<span class="line-modified">!         if (downcast&lt;BitmapImage&gt;(*image).orientationForCurrentFrame() != DefaultImageOrientation)</span>
              return false;
  
  #if (PLATFORM(GTK) || PLATFORM(WPE))
          // GTK and WPE ports don&#39;t support rounded rect clipping at TextureMapper level, so they cannot
          // directly composite images that have border-radius propery. Draw them as non directly composited
<span class="line-new-header">--- 2474,11 ---</span>
  
          auto* image = cachedImage-&gt;imageForRenderer(&amp;imageRenderer);
          if (!is&lt;BitmapImage&gt;(image))
              return false;
  
<span class="line-modified">!         if (downcast&lt;BitmapImage&gt;(*image).orientationForCurrentFrame() != ImageOrientation::None)</span>
              return false;
  
  #if (PLATFORM(GTK) || PLATFORM(WPE))
          // GTK and WPE ports don&#39;t support rounded rect clipping at TextureMapper level, so they cannot
          // directly composite images that have border-radius propery. Draw them as non directly composited
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2262,18 ***</span>
      if ((changeType == ImageChanged) &amp;&amp; contentsInfo.isDirectlyCompositedImage()) {
          updateImageContents(contentsInfo);
          return;
      }
  
      if ((changeType == BackgroundImageChanged) &amp;&amp; canDirectlyCompositeBackgroundBackgroundImage(renderer().style()))
          m_owningLayer.setNeedsCompositingConfigurationUpdate();
  
      if ((changeType == MaskImageChanged) &amp;&amp; m_maskLayer)
          m_owningLayer.setNeedsCompositingConfigurationUpdate();
  
<span class="line-modified">! #if ENABLE(WEBGL) || ENABLE(ACCELERATED_2D_CANVAS)</span>
      if ((changeType == CanvasChanged || changeType == CanvasPixelsChanged) &amp;&amp; renderer().isCanvas() &amp;&amp; canvasCompositingStrategy(renderer()) == CanvasAsLayerContents) {
          m_graphicsLayer-&gt;setContentsNeedsDisplay();
          return;
      }
  #endif
  }
<span class="line-new-header">--- 2499,26 ---</span>
      if ((changeType == ImageChanged) &amp;&amp; contentsInfo.isDirectlyCompositedImage()) {
          updateImageContents(contentsInfo);
          return;
      }
  
<span class="line-added">+     if (changeType == VideoChanged) {</span>
<span class="line-added">+         compositor().scheduleCompositingLayerUpdate();</span>
<span class="line-added">+         return;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      if ((changeType == BackgroundImageChanged) &amp;&amp; canDirectlyCompositeBackgroundBackgroundImage(renderer().style()))
          m_owningLayer.setNeedsCompositingConfigurationUpdate();
  
      if ((changeType == MaskImageChanged) &amp;&amp; m_maskLayer)
          m_owningLayer.setNeedsCompositingConfigurationUpdate();
  
<span class="line-modified">! #if ENABLE(WEBGL) || ENABLE(ACCELERATED_2D_CANVAS) || ENABLE(WEBGPU)</span>
      if ((changeType == CanvasChanged || changeType == CanvasPixelsChanged) &amp;&amp; renderer().isCanvas() &amp;&amp; canvasCompositingStrategy(renderer()) == CanvasAsLayerContents) {
<span class="line-added">+         if (changeType == CanvasChanged)</span>
<span class="line-added">+             compositor().scheduleCompositingLayerUpdate();</span>
<span class="line-added">+ </span>
          m_graphicsLayer-&gt;setContentsNeedsDisplay();
          return;
      }
  #endif
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2296,11 ***</span>
  
      // This is a no-op if the layer doesn&#39;t have an inner layer for the image.
      m_graphicsLayer-&gt;setContentsRect(snapRectToDevicePixels(contentsBox(), deviceScaleFactor()));
  
      LayoutRect boxRect(LayoutPoint(), imageRenderer.size());
<span class="line-modified">!     boxRect.move(contentOffsetInCompostingLayer());</span>
      FloatRoundedRect contentsClippingRect = renderer().style().getRoundedInnerBorderFor(boxRect).pixelSnappedRoundedRectForPainting(deviceScaleFactor());
      m_graphicsLayer-&gt;setContentsClippingRect(contentsClippingRect);
  
      m_graphicsLayer-&gt;setContentsToImage(image);
  
<span class="line-new-header">--- 2541,11 ---</span>
  
      // This is a no-op if the layer doesn&#39;t have an inner layer for the image.
      m_graphicsLayer-&gt;setContentsRect(snapRectToDevicePixels(contentsBox(), deviceScaleFactor()));
  
      LayoutRect boxRect(LayoutPoint(), imageRenderer.size());
<span class="line-modified">!     boxRect.move(contentOffsetInCompositingLayer());</span>
      FloatRoundedRect contentsClippingRect = renderer().style().getRoundedInnerBorderFor(boxRect).pixelSnappedRoundedRectForPainting(deviceScaleFactor());
      m_graphicsLayer-&gt;setContentsClippingRect(contentsClippingRect);
  
      m_graphicsLayer-&gt;setContentsToImage(image);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2324,11 ***</span>
  
      return origin;
  }
  
  // Return the offset from the top-left of this compositing layer at which the renderer&#39;s contents are painted.
<span class="line-modified">! LayoutSize RenderLayerBacking::contentOffsetInCompostingLayer() const</span>
  {
      return LayoutSize(-m_compositedBounds.x() + m_compositedBoundsOffsetFromGraphicsLayer.width(), -m_compositedBounds.y() + m_compositedBoundsOffsetFromGraphicsLayer.height());
  }
  
  LayoutRect RenderLayerBacking::contentsBox() const
<span class="line-new-header">--- 2569,11 ---</span>
  
      return origin;
  }
  
  // Return the offset from the top-left of this compositing layer at which the renderer&#39;s contents are painted.
<span class="line-modified">! LayoutSize RenderLayerBacking::contentOffsetInCompositingLayer() const</span>
  {
      return LayoutSize(-m_compositedBounds.x() + m_compositedBoundsOffsetFromGraphicsLayer.width(), -m_compositedBounds.y() + m_compositedBoundsOffsetFromGraphicsLayer.height());
  }
  
  LayoutRect RenderLayerBacking::contentsBox() const
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2347,11 ***</span>
          RenderReplaced&amp; renderReplaced = downcast&lt;RenderReplaced&gt;(renderBox);
          contentsRect = renderReplaced.replacedContentRect();
      } else
          contentsRect = renderBox.contentBoxRect();
  
<span class="line-modified">!     contentsRect.move(contentOffsetInCompostingLayer());</span>
      return contentsRect;
  }
  
  static LayoutRect backgroundRectForBox(const RenderBox&amp; box)
  {
<span class="line-new-header">--- 2592,11 ---</span>
          RenderReplaced&amp; renderReplaced = downcast&lt;RenderReplaced&gt;(renderBox);
          contentsRect = renderReplaced.replacedContentRect();
      } else
          contentsRect = renderBox.contentBoxRect();
  
<span class="line-modified">!     contentsRect.move(contentOffsetInCompositingLayer());</span>
      return contentsRect;
  }
  
  static LayoutRect backgroundRectForBox(const RenderBox&amp; box)
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2374,11 ***</span>
  {
      if (!is&lt;RenderBox&gt;(renderer()))
          return FloatRect();
  
      LayoutRect backgroundBox = backgroundRectForBox(downcast&lt;RenderBox&gt;(renderer()));
<span class="line-modified">!     backgroundBox.move(contentOffsetInCompostingLayer());</span>
      return snapRectToDevicePixels(backgroundBox, deviceScaleFactor());
  }
  
  GraphicsLayer* RenderLayerBacking::parentForSublayers() const
  {
<span class="line-new-header">--- 2619,11 ---</span>
  {
      if (!is&lt;RenderBox&gt;(renderer()))
          return FloatRect();
  
      LayoutRect backgroundBox = backgroundRectForBox(downcast&lt;RenderBox&gt;(renderer()));
<span class="line-modified">!     backgroundBox.move(contentOffsetInCompositingLayer());</span>
      return snapRectToDevicePixels(backgroundBox, deviceScaleFactor());
  }
  
  GraphicsLayer* RenderLayerBacking::parentForSublayers() const
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2388,12 ***</span>
      return m_childContainmentLayer ? m_childContainmentLayer.get() : m_graphicsLayer.get();
  }
  
  GraphicsLayer* RenderLayerBacking::childForSuperlayers() const
  {
<span class="line-modified">!     if (m_ancestorClippingLayer)</span>
<span class="line-modified">!         return m_ancestorClippingLayer.get();</span>
  
      if (m_contentsContainmentLayer)
          return m_contentsContainmentLayer.get();
  
      return m_graphicsLayer.get();
<span class="line-new-header">--- 2633,12 ---</span>
      return m_childContainmentLayer ? m_childContainmentLayer.get() : m_graphicsLayer.get();
  }
  
  GraphicsLayer* RenderLayerBacking::childForSuperlayers() const
  {
<span class="line-modified">!     if (m_ancestorClippingStack)</span>
<span class="line-modified">!         return m_ancestorClippingStack-&gt;firstClippingLayer();</span>
  
      if (m_contentsContainmentLayer)
          return m_contentsContainmentLayer.get();
  
      return m_graphicsLayer.get();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2441,10 ***</span>
<span class="line-new-header">--- 2686,12 ---</span>
  
      // Use the repaint as a trigger to re-evaluate direct compositing (which is never used on the root layer).
      if (!m_owningLayer.isRenderViewLayer())
          m_owningLayer.setNeedsCompositingConfigurationUpdate();
  
<span class="line-added">+     m_owningLayer.invalidateEventRegion();</span>
<span class="line-added">+ </span>
      auto&amp; frameView = renderer().view().frameView();
      if (m_isMainFrameRenderViewLayer &amp;&amp; frameView.isTrackingRepaints())
          frameView.addTrackedRepaintRect(owningLayer().absoluteBoundingBoxForPainting());
  
      if (m_graphicsLayer &amp;&amp; m_graphicsLayer-&gt;drawsContent()) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2479,10 ***</span>
<span class="line-new-header">--- 2726,12 ---</span>
  
      // Use the repaint as a trigger to re-evaluate direct compositing (which is never used on the root layer).
      if (!m_owningLayer.isRenderViewLayer())
          m_owningLayer.setNeedsCompositingConfigurationUpdate();
  
<span class="line-added">+     m_owningLayer.invalidateEventRegion();</span>
<span class="line-added">+ </span>
      FloatRect pixelSnappedRectForPainting = snapRectToDevicePixels(r, deviceScaleFactor());
      auto&amp; frameView = renderer().view().frameView();
      if (m_isMainFrameRenderViewLayer &amp;&amp; frameView.isTrackingRepaints())
          frameView.addTrackedRepaintRect(pixelSnappedRectForPainting);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2518,47 ***</span>
      }
  
      if (m_scrolledContentsLayer &amp;&amp; m_scrolledContentsLayer-&gt;drawsContent()) {
          FloatRect layerDirtyRect = pixelSnappedRectForPainting;
          layerDirtyRect.move(-m_scrolledContentsLayer-&gt;offsetFromRenderer() + toLayoutSize(m_scrolledContentsLayer-&gt;scrollOffset()) - m_subpixelOffsetFromRenderer);
<span class="line-removed">- #if PLATFORM(IOS_FAMILY)</span>
<span class="line-removed">-         // Account for the fact that RenderLayerBacking::updateGeometry() bakes scrollOffset into offsetFromRenderer on iOS,</span>
<span class="line-removed">-         // but the repaint rect is computed without taking the scroll position into account (see shouldApplyClipAndScrollPositionForRepaint()).</span>
<span class="line-removed">-         layerDirtyRect.moveBy(-m_owningLayer.scrollPosition());</span>
<span class="line-removed">- #endif</span>
          m_scrolledContentsLayer-&gt;setNeedsDisplayInRect(layerDirtyRect, shouldClip);
      }
  }
  
  void RenderLayerBacking::paintIntoLayer(const GraphicsLayer* graphicsLayer, GraphicsContext&amp; context,
      const IntRect&amp; paintDirtyRect, // In the coords of rootLayer.
<span class="line-modified">!     OptionSet&lt;PaintBehavior&gt; paintBehavior, GraphicsLayerPaintingPhase paintingPhase)</span>
  {
<span class="line-modified">!     if ((paintsIntoWindow() || paintsIntoCompositedAncestor()) &amp;&amp; paintingPhase != GraphicsLayerPaintChildClippingMask) {</span>
  #if !PLATFORM(IOS_FAMILY) &amp;&amp; !OS(WINDOWS)
          // FIXME: Looks like the CALayer tree is out of sync with the GraphicsLayer heirarchy
          // when pages are restored from the PageCache.
          // &lt;rdar://problem/8712587&gt; ASSERT: When Going Back to Page with Plugins in PageCache
          ASSERT_NOT_REACHED();
  #endif
          return;
      }
  
      OptionSet&lt;RenderLayer::PaintLayerFlag&gt; paintFlags;
<span class="line-modified">!     if (paintingPhase &amp; GraphicsLayerPaintBackground)</span>
          paintFlags.add(RenderLayer::PaintLayerPaintingCompositingBackgroundPhase);
<span class="line-modified">!     if (paintingPhase &amp; GraphicsLayerPaintForeground)</span>
          paintFlags.add(RenderLayer::PaintLayerPaintingCompositingForegroundPhase);
<span class="line-modified">!     if (paintingPhase &amp; GraphicsLayerPaintMask)</span>
          paintFlags.add(RenderLayer::PaintLayerPaintingCompositingMaskPhase);
<span class="line-modified">!     if (paintingPhase &amp; GraphicsLayerPaintClipPath)</span>
          paintFlags.add(RenderLayer::PaintLayerPaintingCompositingClipPathPhase);
<span class="line-modified">!     if (paintingPhase &amp; GraphicsLayerPaintChildClippingMask)</span>
          paintFlags.add(RenderLayer::PaintLayerPaintingChildClippingMaskPhase);
<span class="line-modified">!     if (paintingPhase &amp; GraphicsLayerPaintOverflowContents)</span>
          paintFlags.add(RenderLayer::PaintLayerPaintingOverflowContents);
<span class="line-modified">!     if (paintingPhase &amp; GraphicsLayerPaintCompositedScroll)</span>
          paintFlags.add(RenderLayer::PaintLayerPaintingCompositingScrollingPhase);
  
      if (graphicsLayer == m_backgroundLayer.get() &amp;&amp; m_backgroundLayerPaintsFixedRootBackground)
          paintFlags.add({ RenderLayer::PaintLayerPaintingRootBackgroundOnly, RenderLayer::PaintLayerPaintingCompositingForegroundPhase }); // Need PaintLayerPaintingCompositingForegroundPhase to walk child layers.
      else if (compositor().fixedRootBackgroundLayer())
<span class="line-new-header">--- 2767,42 ---</span>
      }
  
      if (m_scrolledContentsLayer &amp;&amp; m_scrolledContentsLayer-&gt;drawsContent()) {
          FloatRect layerDirtyRect = pixelSnappedRectForPainting;
          layerDirtyRect.move(-m_scrolledContentsLayer-&gt;offsetFromRenderer() + toLayoutSize(m_scrolledContentsLayer-&gt;scrollOffset()) - m_subpixelOffsetFromRenderer);
          m_scrolledContentsLayer-&gt;setNeedsDisplayInRect(layerDirtyRect, shouldClip);
      }
  }
  
  void RenderLayerBacking::paintIntoLayer(const GraphicsLayer* graphicsLayer, GraphicsContext&amp; context,
      const IntRect&amp; paintDirtyRect, // In the coords of rootLayer.
<span class="line-modified">!     OptionSet&lt;PaintBehavior&gt; paintBehavior, OptionSet&lt;GraphicsLayerPaintingPhase&gt; paintingPhase)</span>
  {
<span class="line-modified">!     if ((paintsIntoWindow() || paintsIntoCompositedAncestor()) &amp;&amp; paintingPhase != OptionSet&lt;GraphicsLayerPaintingPhase&gt;(GraphicsLayerPaintingPhase::ChildClippingMask)) {</span>
  #if !PLATFORM(IOS_FAMILY) &amp;&amp; !OS(WINDOWS)
          // FIXME: Looks like the CALayer tree is out of sync with the GraphicsLayer heirarchy
          // when pages are restored from the PageCache.
          // &lt;rdar://problem/8712587&gt; ASSERT: When Going Back to Page with Plugins in PageCache
          ASSERT_NOT_REACHED();
  #endif
          return;
      }
  
      OptionSet&lt;RenderLayer::PaintLayerFlag&gt; paintFlags;
<span class="line-modified">!     if (paintingPhase.contains(GraphicsLayerPaintingPhase::Background))</span>
          paintFlags.add(RenderLayer::PaintLayerPaintingCompositingBackgroundPhase);
<span class="line-modified">!     if (paintingPhase.contains(GraphicsLayerPaintingPhase::Foreground))</span>
          paintFlags.add(RenderLayer::PaintLayerPaintingCompositingForegroundPhase);
<span class="line-modified">!     if (paintingPhase.contains(GraphicsLayerPaintingPhase::Mask))</span>
          paintFlags.add(RenderLayer::PaintLayerPaintingCompositingMaskPhase);
<span class="line-modified">!     if (paintingPhase.contains(GraphicsLayerPaintingPhase::ClipPath))</span>
          paintFlags.add(RenderLayer::PaintLayerPaintingCompositingClipPathPhase);
<span class="line-modified">!     if (paintingPhase.contains(GraphicsLayerPaintingPhase::ChildClippingMask))</span>
          paintFlags.add(RenderLayer::PaintLayerPaintingChildClippingMaskPhase);
<span class="line-modified">!     if (paintingPhase.contains(GraphicsLayerPaintingPhase::OverflowContents))</span>
          paintFlags.add(RenderLayer::PaintLayerPaintingOverflowContents);
<span class="line-modified">!     if (paintingPhase.contains(GraphicsLayerPaintingPhase::CompositedScroll))</span>
          paintFlags.add(RenderLayer::PaintLayerPaintingCompositingScrollingPhase);
  
      if (graphicsLayer == m_backgroundLayer.get() &amp;&amp; m_backgroundLayerPaintsFixedRootBackground)
          paintFlags.add({ RenderLayer::PaintLayerPaintingRootBackgroundOnly, RenderLayer::PaintLayerPaintingCompositingForegroundPhase }); // Need PaintLayerPaintingCompositingForegroundPhase to walk child layers.
      else if (compositor().fixedRootBackgroundLayer())
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2566,31 ***</span>
  
  #ifndef NDEBUG
      RenderElement::SetLayoutNeededForbiddenScope forbidSetNeedsLayout(&amp;renderer());
  #endif
  
<span class="line-modified">!     FrameView::PaintingState paintingState;</span>
<span class="line-modified">!     if (m_owningLayer.isRenderViewLayer())</span>
<span class="line-removed">-         renderer().view().frameView().willPaintContents(context, paintDirtyRect, paintingState);</span>
  
<span class="line-modified">!     // FIXME: GraphicsLayers need a way to split for RenderFragmentContainers.</span>
<span class="line-modified">!     RenderLayer::LayerPaintingInfo paintingInfo(&amp;m_owningLayer, paintDirtyRect, paintBehavior, -m_subpixelOffsetFromRenderer);</span>
<span class="line-modified">!     m_owningLayer.paintLayerContents(context, paintingInfo, paintFlags);</span>
  
<span class="line-modified">!     if (m_owningLayer.containsDirtyOverlayScrollbars())</span>
<span class="line-removed">-         m_owningLayer.paintLayerContents(context, paintingInfo, paintFlags | RenderLayer::PaintLayerPaintingOverlayScrollbars);</span>
  
<span class="line-modified">!     if (m_owningLayer.isRenderViewLayer())</span>
<span class="line-modified">!         renderer().view().frameView().didPaintContents(context, paintDirtyRect, paintingState);</span>
  
      compositor().didPaintBacking(this);
  
<span class="line-modified">!     ASSERT(!m_owningLayer.m_usedTransparency);</span>
  }
  
  // Up-call from compositing layer drawing callback.
<span class="line-modified">! void RenderLayerBacking::paintContents(const GraphicsLayer* graphicsLayer, GraphicsContext&amp; context, GraphicsLayerPaintingPhase paintingPhase, const FloatRect&amp; clip, GraphicsLayerPaintBehavior layerPaintBehavior)</span>
  {
  #ifndef NDEBUG
      renderer().page().setIsPainting(true);
  #endif
  
<span class="line-new-header">--- 2810,176 ---</span>
  
  #ifndef NDEBUG
      RenderElement::SetLayoutNeededForbiddenScope forbidSetNeedsLayout(&amp;renderer());
  #endif
  
<span class="line-modified">!     auto paintOneLayer = [&amp;](RenderLayer&amp; layer, OptionSet&lt;RenderLayer::PaintLayerFlag&gt; paintFlags) {</span>
<span class="line-modified">!         InspectorInstrumentation::willPaint(layer.renderer());</span>
  
<span class="line-modified">!         FrameView::PaintingState paintingState;</span>
<span class="line-modified">!         if (layer.isRenderViewLayer())</span>
<span class="line-modified">!             renderer().view().frameView().willPaintContents(context, paintDirtyRect, paintingState);</span>
  
<span class="line-modified">!         RenderLayer::LayerPaintingInfo paintingInfo(&amp;m_owningLayer, paintDirtyRect, paintBehavior, -m_subpixelOffsetFromRenderer);</span>
  
<span class="line-modified">!         if (&amp;layer == &amp;m_owningLayer) {</span>
<span class="line-modified">!             layer.paintLayerContents(context, paintingInfo, paintFlags);</span>
<span class="line-added">+ </span>
<span class="line-added">+             if (layer.containsDirtyOverlayScrollbars())</span>
<span class="line-added">+                 layer.paintLayerContents(context, paintingInfo, paintFlags | RenderLayer::PaintLayerPaintingOverlayScrollbars);</span>
<span class="line-added">+         } else</span>
<span class="line-added">+             layer.paintLayerWithEffects(context, paintingInfo, paintFlags);</span>
<span class="line-added">+ </span>
<span class="line-added">+         if (layer.isRenderViewLayer())</span>
<span class="line-added">+             renderer().view().frameView().didPaintContents(context, paintDirtyRect, paintingState);</span>
<span class="line-added">+ </span>
<span class="line-added">+         ASSERT(!m_owningLayer.m_usedTransparency);</span>
<span class="line-added">+ </span>
<span class="line-added">+         InspectorInstrumentation::didPaint(layer.renderer(), paintDirtyRect);</span>
<span class="line-added">+     };</span>
<span class="line-added">+ </span>
<span class="line-added">+     paintOneLayer(m_owningLayer, paintFlags);</span>
<span class="line-added">+ </span>
<span class="line-added">+     // FIXME: Need to check m_foregroundLayer, masking etc. webkit.org/b/197565.</span>
<span class="line-added">+     GraphicsLayer* destinationForSharingLayers = m_scrolledContentsLayer ? m_scrolledContentsLayer.get() : m_graphicsLayer.get();</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (graphicsLayer == destinationForSharingLayers) {</span>
<span class="line-added">+         OptionSet&lt;RenderLayer::PaintLayerFlag&gt; sharingLayerPaintFlags = {</span>
<span class="line-added">+             RenderLayer::PaintLayerPaintingCompositingBackgroundPhase,</span>
<span class="line-added">+             RenderLayer::PaintLayerPaintingCompositingForegroundPhase };</span>
<span class="line-added">+ </span>
<span class="line-added">+         if (paintingPhase.contains(GraphicsLayerPaintingPhase::OverflowContents))</span>
<span class="line-added">+             sharingLayerPaintFlags.add(RenderLayer::PaintLayerPaintingOverflowContents);</span>
<span class="line-added">+ </span>
<span class="line-added">+         for (auto&amp; layerWeakPtr : m_backingSharingLayers)</span>
<span class="line-added">+             paintOneLayer(*layerWeakPtr, sharingLayerPaintFlags);</span>
<span class="line-added">+     }</span>
  
      compositor().didPaintBacking(this);
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ #if ENABLE(POINTER_EVENTS)</span>
<span class="line-added">+ static RefPtr&lt;Pattern&gt; patternForTouchAction(TouchAction touchAction, FloatSize contentOffset, GraphicsContext&amp; destContext)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     auto toIndex = [](TouchAction touchAction) -&gt; unsigned {</span>
<span class="line-added">+         switch (touchAction) {</span>
<span class="line-added">+         case TouchAction::None:</span>
<span class="line-added">+             return 1;</span>
<span class="line-added">+         case TouchAction::Manipulation:</span>
<span class="line-added">+             return 2;</span>
<span class="line-added">+         case TouchAction::PanX:</span>
<span class="line-added">+             return 3;</span>
<span class="line-added">+         case TouchAction::PanY:</span>
<span class="line-added">+             return 4;</span>
<span class="line-added">+         case TouchAction::PinchZoom:</span>
<span class="line-added">+             return 5;</span>
<span class="line-added">+         case TouchAction::Auto:</span>
<span class="line-added">+             break;</span>
<span class="line-added">+         }</span>
<span class="line-added">+         return 0;</span>
<span class="line-added">+     };</span>
<span class="line-added">+ </span>
<span class="line-added">+     struct TouchActionAndRGB {</span>
<span class="line-added">+         TouchAction action;</span>
<span class="line-added">+         ASCIILiteral name;</span>
<span class="line-added">+         FloatSize phase;</span>
<span class="line-added">+     };</span>
<span class="line-added">+     static const TouchActionAndRGB actionsAndColors[] = {</span>
<span class="line-added">+         { TouchAction::Auto, &quot;auto&quot;_s, { } },</span>
<span class="line-added">+         { TouchAction::None, &quot;none&quot;_s, { } },</span>
<span class="line-added">+         { TouchAction::Manipulation, &quot;manip&quot;_s, { } },</span>
<span class="line-added">+         { TouchAction::PanX, &quot;pan-x&quot;_s, { } },</span>
<span class="line-added">+         { TouchAction::PanY, &quot;pan-y&quot;_s, { 0, 9 } },</span>
<span class="line-added">+         { TouchAction::PinchZoom, &quot;p-z&quot;_s, { 16, 4.5 } },</span>
<span class="line-added">+     };</span>
<span class="line-added">+ </span>
<span class="line-added">+     auto actionIndex = toIndex(touchAction);</span>
<span class="line-added">+     if (!actionIndex || actionIndex &gt;= ARRAY_SIZE(actionsAndColors))</span>
<span class="line-added">+         return nullptr;</span>
<span class="line-added">+ </span>
<span class="line-added">+     const FloatSize tileSize { 32, 18 };</span>
<span class="line-added">+ </span>
<span class="line-added">+     auto imageBuffer = ImageBuffer::createCompatibleBuffer(tileSize, ColorSpaceSRGB, destContext);</span>
<span class="line-added">+     if (!imageBuffer)</span>
<span class="line-added">+         return nullptr;</span>
<span class="line-added">+ </span>
<span class="line-added">+     const auto&amp; touchActionData = actionsAndColors[actionIndex];</span>
<span class="line-added">+     {</span>
<span class="line-added">+         GraphicsContext&amp; imageContext = imageBuffer-&gt;context();</span>
  
<span class="line-modified">!         FontCascadeDescription fontDescription;</span>
<span class="line-added">+         fontDescription.setOneFamily(&quot;Helvetica&quot;);</span>
<span class="line-added">+         fontDescription.setSpecifiedSize(10);</span>
<span class="line-added">+         fontDescription.setComputedSize(10);</span>
<span class="line-added">+         fontDescription.setWeight(FontSelectionValue(500));</span>
<span class="line-added">+         FontCascade font(WTFMove(fontDescription), 0, 0);</span>
<span class="line-added">+         font.update(nullptr);</span>
<span class="line-added">+ </span>
<span class="line-added">+         TextRun textRun = TextRun(touchActionData.name);</span>
<span class="line-added">+         imageContext.setFillColor(Color(0, 0, 0, 128));</span>
<span class="line-added">+ </span>
<span class="line-added">+         constexpr float textGap = 4;</span>
<span class="line-added">+         constexpr float yOffset = 12;</span>
<span class="line-added">+         imageContext.drawText(font, textRun, { textGap, yOffset }, 0);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     auto tileImage = ImageBuffer::sinkIntoImage(WTFMove(imageBuffer));</span>
<span class="line-added">+     auto fillPattern = Pattern::create(tileImage.releaseNonNull(), true, true);</span>
<span class="line-added">+     AffineTransform patternOffsetTransform;</span>
<span class="line-added">+     patternOffsetTransform.translate(contentOffset + touchActionData.phase);</span>
<span class="line-added">+     patternOffsetTransform.scale(1 / destContext.scaleFactor());</span>
<span class="line-added">+     fillPattern-&gt;setPatternSpaceTransform(patternOffsetTransform);</span>
<span class="line-added">+ </span>
<span class="line-added">+     return fillPattern;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ #endif // ENABLE(POINTER_EVENTS)</span>
<span class="line-added">+ </span>
<span class="line-added">+ void RenderLayerBacking::paintDebugOverlays(const GraphicsLayer* graphicsLayer, GraphicsContext&amp; context)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     if (graphicsLayer-&gt;eventRegion().isEmpty())</span>
<span class="line-added">+         return;</span>
<span class="line-added">+ </span>
<span class="line-added">+     GraphicsContextStateSaver stateSaver(context);</span>
<span class="line-added">+ </span>
<span class="line-added">+     // The region is offset by contentOffsetInCompositingLayer() so undo that.</span>
<span class="line-added">+     auto contentOffset = roundedIntSize(contentOffsetInCompositingLayer());</span>
<span class="line-added">+     context.translate(-contentOffset);</span>
<span class="line-added">+ </span>
<span class="line-added">+     // The interactive part.</span>
<span class="line-added">+     auto&amp; eventRegion = graphicsLayer-&gt;eventRegion();</span>
<span class="line-added">+     Color regionColor(0, 0, 0, 5);</span>
<span class="line-added">+     context.setFillColor(regionColor);</span>
<span class="line-added">+     for (auto rect : eventRegion.region().rects())</span>
<span class="line-added">+         context.fillRect(rect);</span>
<span class="line-added">+ </span>
<span class="line-added">+ #if ENABLE(POINTER_EVENTS)</span>
<span class="line-added">+     const TouchAction touchActionList[] = {</span>
<span class="line-added">+         TouchAction::None,</span>
<span class="line-added">+         TouchAction::Manipulation,</span>
<span class="line-added">+         TouchAction::PanX,</span>
<span class="line-added">+         TouchAction::PanY,</span>
<span class="line-added">+         TouchAction::PinchZoom,</span>
<span class="line-added">+     };</span>
<span class="line-added">+ </span>
<span class="line-added">+     for (auto action : touchActionList) {</span>
<span class="line-added">+         auto* actionRegion = graphicsLayer-&gt;eventRegion().regionForTouchAction(action);</span>
<span class="line-added">+         if (!actionRegion)</span>
<span class="line-added">+             continue;</span>
<span class="line-added">+ </span>
<span class="line-added">+         auto fillPattern = patternForTouchAction(action, contentOffsetInCompositingLayer(), context);</span>
<span class="line-added">+         if (!fillPattern)</span>
<span class="line-added">+             continue;</span>
<span class="line-added">+ </span>
<span class="line-added">+         context.setFillPattern(fillPattern.releaseNonNull());</span>
<span class="line-added">+         for (auto rect : actionRegion-&gt;rects())</span>
<span class="line-added">+             context.fillRect(rect);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ #endif // ENABLE(POINTER_EVENTS)</span>
  }
  
  // Up-call from compositing layer drawing callback.
<span class="line-modified">! void RenderLayerBacking::paintContents(const GraphicsLayer* graphicsLayer, GraphicsContext&amp; context, OptionSet&lt;GraphicsLayerPaintingPhase&gt; paintingPhase, const FloatRect&amp; clip, GraphicsLayerPaintBehavior layerPaintBehavior)</span>
  {
  #ifndef NDEBUG
      renderer().page().setIsPainting(true);
  #endif
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2610,13 ***</span>
          || graphicsLayer == m_foregroundLayer.get()
          || graphicsLayer == m_backgroundLayer.get()
          || graphicsLayer == m_maskLayer.get()
          || graphicsLayer == m_childClippingMaskLayer.get()
          || graphicsLayer == m_scrolledContentsLayer.get()) {
<span class="line-removed">-         InspectorInstrumentation::willPaint(renderer());</span>
  
<span class="line-modified">!         if (!(paintingPhase &amp; GraphicsLayerPaintOverflowContents))</span>
              dirtyRect.intersect(enclosingIntRect(compositedBoundsIncludingMargin()));
  
          // We have to use the same root as for hit testing, because both methods can compute and cache clipRects.
          OptionSet&lt;PaintBehavior&gt; behavior = PaintBehavior::Normal;
          if (layerPaintBehavior == GraphicsLayerPaintSnapshotting)
<span class="line-new-header">--- 2999,12 ---</span>
          || graphicsLayer == m_foregroundLayer.get()
          || graphicsLayer == m_backgroundLayer.get()
          || graphicsLayer == m_maskLayer.get()
          || graphicsLayer == m_childClippingMaskLayer.get()
          || graphicsLayer == m_scrolledContentsLayer.get()) {
  
<span class="line-modified">!         if (!paintingPhase.contains(GraphicsLayerPaintingPhase::OverflowContents))</span>
              dirtyRect.intersect(enclosingIntRect(compositedBoundsIncludingMargin()));
  
          // We have to use the same root as for hit testing, because both methods can compute and cache clipRects.
          OptionSet&lt;PaintBehavior&gt; behavior = PaintBehavior::Normal;
          if (layerPaintBehavior == GraphicsLayerPaintSnapshotting)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2625,24 ***</span>
          if (layerPaintBehavior == GraphicsLayerPaintFirstTilePaint)
              behavior.add(PaintBehavior::TileFirstPaint);
  
          paintIntoLayer(graphicsLayer, context, dirtyRect, behavior, paintingPhase);
  
<span class="line-modified">!         InspectorInstrumentation::didPaint(renderer(), dirtyRect);</span>
      } else if (graphicsLayer == layerForHorizontalScrollbar()) {
          paintScrollbar(m_owningLayer.horizontalScrollbar(), context, dirtyRect);
      } else if (graphicsLayer == layerForVerticalScrollbar()) {
          paintScrollbar(m_owningLayer.verticalScrollbar(), context, dirtyRect);
      } else if (graphicsLayer == layerForScrollCorner()) {
          const LayoutRect&amp; scrollCornerAndResizer = m_owningLayer.scrollCornerAndResizerRect();
<span class="line-modified">!         context.save();</span>
          context.translate(-scrollCornerAndResizer.location());
          LayoutRect transformedClip = LayoutRect(clip);
          transformedClip.moveBy(scrollCornerAndResizer.location());
          m_owningLayer.paintScrollCorner(context, IntPoint(), snappedIntRect(transformedClip));
          m_owningLayer.paintResizer(context, IntPoint(), transformedClip);
<span class="line-removed">-         context.restore();</span>
      }
  #ifndef NDEBUG
      renderer().page().setIsPainting(false);
  #endif
  }
<span class="line-new-header">--- 3013,25 ---</span>
          if (layerPaintBehavior == GraphicsLayerPaintFirstTilePaint)
              behavior.add(PaintBehavior::TileFirstPaint);
  
          paintIntoLayer(graphicsLayer, context, dirtyRect, behavior, paintingPhase);
  
<span class="line-modified">!         if (renderer().settings().visibleDebugOverlayRegions() &amp; NonFastScrollableRegion) // Piggy-back off the setting that shows touch handler regions.</span>
<span class="line-added">+             paintDebugOverlays(graphicsLayer, context);</span>
<span class="line-added">+ </span>
      } else if (graphicsLayer == layerForHorizontalScrollbar()) {
          paintScrollbar(m_owningLayer.horizontalScrollbar(), context, dirtyRect);
      } else if (graphicsLayer == layerForVerticalScrollbar()) {
          paintScrollbar(m_owningLayer.verticalScrollbar(), context, dirtyRect);
      } else if (graphicsLayer == layerForScrollCorner()) {
          const LayoutRect&amp; scrollCornerAndResizer = m_owningLayer.scrollCornerAndResizerRect();
<span class="line-modified">!         GraphicsContextStateSaver stateSaver(context);</span>
          context.translate(-scrollCornerAndResizer.location());
          LayoutRect transformedClip = LayoutRect(clip);
          transformedClip.moveBy(scrollCornerAndResizer.location());
          m_owningLayer.paintScrollCorner(context, IntPoint(), snappedIntRect(transformedClip));
          m_owningLayer.paintResizer(context, IntPoint(), transformedClip);
      }
  #ifndef NDEBUG
      renderer().page().setIsPainting(false);
  #endif
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2756,11 ***</span>
  {
      ASSERT(!renderer().page().isPainting());
  }
  #endif
  
<span class="line-modified">! bool RenderLayerBacking::startAnimation(double timeOffset, const Animation* anim, const KeyframeList&amp; keyframes)</span>
  {
      bool hasOpacity = keyframes.containsProperty(CSSPropertyOpacity);
      bool hasTransform = renderer().isBox() &amp;&amp; keyframes.containsProperty(CSSPropertyTransform);
      bool hasFilter = keyframes.containsProperty(CSSPropertyFilter);
  
<span class="line-new-header">--- 3145,11 ---</span>
  {
      ASSERT(!renderer().page().isPainting());
  }
  #endif
  
<span class="line-modified">! bool RenderLayerBacking::startAnimation(double timeOffset, const Animation&amp; animation, const KeyframeList&amp; keyframes)</span>
  {
      bool hasOpacity = keyframes.containsProperty(CSSPropertyOpacity);
      bool hasTransform = renderer().isBox() &amp;&amp; keyframes.containsProperty(CSSPropertyTransform);
      bool hasFilter = keyframes.containsProperty(CSSPropertyFilter);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2790,40 ***</span>
  
          auto* tf = currentKeyframe.timingFunction();
  
          bool isFirstOrLastKeyframe = key == 0 || key == 1;
          if ((hasTransform &amp;&amp; isFirstOrLastKeyframe) || currentKeyframe.containsProperty(CSSPropertyTransform))
<span class="line-modified">!             transformVector.insert(std::make_unique&lt;TransformAnimationValue&gt;(key, keyframeStyle-&gt;transform(), tf));</span>
  
          if ((hasOpacity &amp;&amp; isFirstOrLastKeyframe) || currentKeyframe.containsProperty(CSSPropertyOpacity))
<span class="line-modified">!             opacityVector.insert(std::make_unique&lt;FloatAnimationValue&gt;(key, keyframeStyle-&gt;opacity(), tf));</span>
  
          if ((hasFilter &amp;&amp; isFirstOrLastKeyframe) || currentKeyframe.containsProperty(CSSPropertyFilter))
<span class="line-modified">!             filterVector.insert(std::make_unique&lt;FilterAnimationValue&gt;(key, keyframeStyle-&gt;filter(), tf));</span>
  
  #if ENABLE(FILTERS_LEVEL_2)
          if ((hasBackdropFilter &amp;&amp; isFirstOrLastKeyframe) || currentKeyframe.containsProperty(CSSPropertyWebkitBackdropFilter))
<span class="line-modified">!             backdropFilterVector.insert(std::make_unique&lt;FilterAnimationValue&gt;(key, keyframeStyle-&gt;backdropFilter(), tf));</span>
  #endif
      }
  
      if (!renderer().settings().acceleratedCompositedAnimationsEnabled())
          return false;
  
      bool didAnimate = false;
  
<span class="line-modified">!     if (hasTransform &amp;&amp; m_graphicsLayer-&gt;addAnimation(transformVector, snappedIntRect(renderBox()-&gt;borderBoxRect()).size(), anim, keyframes.animationName(), timeOffset))</span>
          didAnimate = true;
  
<span class="line-modified">!     if (hasOpacity &amp;&amp; m_graphicsLayer-&gt;addAnimation(opacityVector, IntSize(), anim, keyframes.animationName(), timeOffset))</span>
          didAnimate = true;
  
<span class="line-modified">!     if (hasFilter &amp;&amp; m_graphicsLayer-&gt;addAnimation(filterVector, IntSize(), anim, keyframes.animationName(), timeOffset))</span>
          didAnimate = true;
  
  #if ENABLE(FILTERS_LEVEL_2)
<span class="line-modified">!     if (hasBackdropFilter &amp;&amp; m_graphicsLayer-&gt;addAnimation(backdropFilterVector, IntSize(), anim, keyframes.animationName(), timeOffset))</span>
          didAnimate = true;
  #endif
  
      if (didAnimate)
          m_owningLayer.setNeedsPostLayoutCompositingUpdate();
<span class="line-new-header">--- 3179,40 ---</span>
  
          auto* tf = currentKeyframe.timingFunction();
  
          bool isFirstOrLastKeyframe = key == 0 || key == 1;
          if ((hasTransform &amp;&amp; isFirstOrLastKeyframe) || currentKeyframe.containsProperty(CSSPropertyTransform))
<span class="line-modified">!             transformVector.insert(makeUnique&lt;TransformAnimationValue&gt;(key, keyframeStyle-&gt;transform(), tf));</span>
  
          if ((hasOpacity &amp;&amp; isFirstOrLastKeyframe) || currentKeyframe.containsProperty(CSSPropertyOpacity))
<span class="line-modified">!             opacityVector.insert(makeUnique&lt;FloatAnimationValue&gt;(key, keyframeStyle-&gt;opacity(), tf));</span>
  
          if ((hasFilter &amp;&amp; isFirstOrLastKeyframe) || currentKeyframe.containsProperty(CSSPropertyFilter))
<span class="line-modified">!             filterVector.insert(makeUnique&lt;FilterAnimationValue&gt;(key, keyframeStyle-&gt;filter(), tf));</span>
  
  #if ENABLE(FILTERS_LEVEL_2)
          if ((hasBackdropFilter &amp;&amp; isFirstOrLastKeyframe) || currentKeyframe.containsProperty(CSSPropertyWebkitBackdropFilter))
<span class="line-modified">!             backdropFilterVector.insert(makeUnique&lt;FilterAnimationValue&gt;(key, keyframeStyle-&gt;backdropFilter(), tf));</span>
  #endif
      }
  
      if (!renderer().settings().acceleratedCompositedAnimationsEnabled())
          return false;
  
      bool didAnimate = false;
  
<span class="line-modified">!     if (hasTransform &amp;&amp; m_graphicsLayer-&gt;addAnimation(transformVector, snappedIntRect(renderBox()-&gt;borderBoxRect()).size(), &amp;animation, keyframes.animationName(), timeOffset))</span>
          didAnimate = true;
  
<span class="line-modified">!     if (hasOpacity &amp;&amp; m_graphicsLayer-&gt;addAnimation(opacityVector, IntSize { }, &amp;animation, keyframes.animationName(), timeOffset))</span>
          didAnimate = true;
  
<span class="line-modified">!     if (hasFilter &amp;&amp; m_graphicsLayer-&gt;addAnimation(filterVector, IntSize { }, &amp;animation, keyframes.animationName(), timeOffset))</span>
          didAnimate = true;
  
  #if ENABLE(FILTERS_LEVEL_2)
<span class="line-modified">!     if (hasBackdropFilter &amp;&amp; m_graphicsLayer-&gt;addAnimation(backdropFilterVector, IntSize { }, &amp;animation, keyframes.animationName(), timeOffset))</span>
          didAnimate = true;
  #endif
  
      if (didAnimate)
          m_owningLayer.setNeedsPostLayoutCompositingUpdate();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2855,12 ***</span>
  
      if (property == CSSPropertyOpacity) {
          const Animation* opacityAnim = toStyle-&gt;transitionForProperty(CSSPropertyOpacity);
          if (opacityAnim &amp;&amp; !opacityAnim-&gt;isEmptyOrZeroDuration()) {
              KeyframeValueList opacityVector(AnimatedPropertyOpacity);
<span class="line-modified">!             opacityVector.insert(std::make_unique&lt;FloatAnimationValue&gt;(0, compositingOpacity(fromStyle-&gt;opacity())));</span>
<span class="line-modified">!             opacityVector.insert(std::make_unique&lt;FloatAnimationValue&gt;(1, compositingOpacity(toStyle-&gt;opacity())));</span>
              // The boxSize param is only used for transform animations (which can only run on RenderBoxes), so we pass an empty size here.
              if (m_graphicsLayer-&gt;addAnimation(opacityVector, FloatSize(), opacityAnim, GraphicsLayer::animationNameForTransition(AnimatedPropertyOpacity), timeOffset)) {
                  // To ensure that the correct opacity is visible when the animation ends, also set the final opacity.
                  updateOpacity(*toStyle);
                  didAnimate = true;
<span class="line-new-header">--- 3244,12 ---</span>
  
      if (property == CSSPropertyOpacity) {
          const Animation* opacityAnim = toStyle-&gt;transitionForProperty(CSSPropertyOpacity);
          if (opacityAnim &amp;&amp; !opacityAnim-&gt;isEmptyOrZeroDuration()) {
              KeyframeValueList opacityVector(AnimatedPropertyOpacity);
<span class="line-modified">!             opacityVector.insert(makeUnique&lt;FloatAnimationValue&gt;(0, compositingOpacity(fromStyle-&gt;opacity())));</span>
<span class="line-modified">!             opacityVector.insert(makeUnique&lt;FloatAnimationValue&gt;(1, compositingOpacity(toStyle-&gt;opacity())));</span>
              // The boxSize param is only used for transform animations (which can only run on RenderBoxes), so we pass an empty size here.
              if (m_graphicsLayer-&gt;addAnimation(opacityVector, FloatSize(), opacityAnim, GraphicsLayer::animationNameForTransition(AnimatedPropertyOpacity), timeOffset)) {
                  // To ensure that the correct opacity is visible when the animation ends, also set the final opacity.
                  updateOpacity(*toStyle);
                  didAnimate = true;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2870,12 ***</span>
  
      if (property == CSSPropertyTransform &amp;&amp; m_owningLayer.hasTransform()) {
          const Animation* transformAnim = toStyle-&gt;transitionForProperty(CSSPropertyTransform);
          if (transformAnim &amp;&amp; !transformAnim-&gt;isEmptyOrZeroDuration()) {
              KeyframeValueList transformVector(AnimatedPropertyTransform);
<span class="line-modified">!             transformVector.insert(std::make_unique&lt;TransformAnimationValue&gt;(0, fromStyle-&gt;transform()));</span>
<span class="line-modified">!             transformVector.insert(std::make_unique&lt;TransformAnimationValue&gt;(1, toStyle-&gt;transform()));</span>
              if (m_graphicsLayer-&gt;addAnimation(transformVector, snappedIntRect(renderBox()-&gt;borderBoxRect()).size(), transformAnim, GraphicsLayer::animationNameForTransition(AnimatedPropertyTransform), timeOffset)) {
                  // To ensure that the correct transform is visible when the animation ends, also set the final transform.
                  updateTransform(*toStyle);
                  didAnimate = true;
              }
<span class="line-new-header">--- 3259,12 ---</span>
  
      if (property == CSSPropertyTransform &amp;&amp; m_owningLayer.hasTransform()) {
          const Animation* transformAnim = toStyle-&gt;transitionForProperty(CSSPropertyTransform);
          if (transformAnim &amp;&amp; !transformAnim-&gt;isEmptyOrZeroDuration()) {
              KeyframeValueList transformVector(AnimatedPropertyTransform);
<span class="line-modified">!             transformVector.insert(makeUnique&lt;TransformAnimationValue&gt;(0, fromStyle-&gt;transform()));</span>
<span class="line-modified">!             transformVector.insert(makeUnique&lt;TransformAnimationValue&gt;(1, toStyle-&gt;transform()));</span>
              if (m_graphicsLayer-&gt;addAnimation(transformVector, snappedIntRect(renderBox()-&gt;borderBoxRect()).size(), transformAnim, GraphicsLayer::animationNameForTransition(AnimatedPropertyTransform), timeOffset)) {
                  // To ensure that the correct transform is visible when the animation ends, also set the final transform.
                  updateTransform(*toStyle);
                  didAnimate = true;
              }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2884,12 ***</span>
  
      if (property == CSSPropertyFilter &amp;&amp; m_owningLayer.hasFilter()) {
          const Animation* filterAnim = toStyle-&gt;transitionForProperty(CSSPropertyFilter);
          if (filterAnim &amp;&amp; !filterAnim-&gt;isEmptyOrZeroDuration()) {
              KeyframeValueList filterVector(AnimatedPropertyFilter);
<span class="line-modified">!             filterVector.insert(std::make_unique&lt;FilterAnimationValue&gt;(0, fromStyle-&gt;filter()));</span>
<span class="line-modified">!             filterVector.insert(std::make_unique&lt;FilterAnimationValue&gt;(1, toStyle-&gt;filter()));</span>
              if (m_graphicsLayer-&gt;addAnimation(filterVector, FloatSize(), filterAnim, GraphicsLayer::animationNameForTransition(AnimatedPropertyFilter), timeOffset)) {
                  // To ensure that the correct filter is visible when the animation ends, also set the final filter.
                  updateFilters(*toStyle);
                  didAnimate = true;
              }
<span class="line-new-header">--- 3273,12 ---</span>
  
      if (property == CSSPropertyFilter &amp;&amp; m_owningLayer.hasFilter()) {
          const Animation* filterAnim = toStyle-&gt;transitionForProperty(CSSPropertyFilter);
          if (filterAnim &amp;&amp; !filterAnim-&gt;isEmptyOrZeroDuration()) {
              KeyframeValueList filterVector(AnimatedPropertyFilter);
<span class="line-modified">!             filterVector.insert(makeUnique&lt;FilterAnimationValue&gt;(0, fromStyle-&gt;filter()));</span>
<span class="line-modified">!             filterVector.insert(makeUnique&lt;FilterAnimationValue&gt;(1, toStyle-&gt;filter()));</span>
              if (m_graphicsLayer-&gt;addAnimation(filterVector, FloatSize(), filterAnim, GraphicsLayer::animationNameForTransition(AnimatedPropertyFilter), timeOffset)) {
                  // To ensure that the correct filter is visible when the animation ends, also set the final filter.
                  updateFilters(*toStyle);
                  didAnimate = true;
              }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2899,12 ***</span>
  #if ENABLE(FILTERS_LEVEL_2)
      if (property == CSSPropertyWebkitBackdropFilter &amp;&amp; m_owningLayer.hasBackdropFilter()) {
          const Animation* backdropFilterAnim = toStyle-&gt;transitionForProperty(CSSPropertyWebkitBackdropFilter);
          if (backdropFilterAnim &amp;&amp; !backdropFilterAnim-&gt;isEmptyOrZeroDuration()) {
              KeyframeValueList backdropFilterVector(AnimatedPropertyWebkitBackdropFilter);
<span class="line-modified">!             backdropFilterVector.insert(std::make_unique&lt;FilterAnimationValue&gt;(0, fromStyle-&gt;backdropFilter()));</span>
<span class="line-modified">!             backdropFilterVector.insert(std::make_unique&lt;FilterAnimationValue&gt;(1, toStyle-&gt;backdropFilter()));</span>
              if (m_graphicsLayer-&gt;addAnimation(backdropFilterVector, FloatSize(), backdropFilterAnim, GraphicsLayer::animationNameForTransition(AnimatedPropertyWebkitBackdropFilter), timeOffset)) {
                  // To ensure that the correct backdrop filter is visible when the animation ends, also set the final backdrop filter.
                  updateBackdropFilters(*toStyle);
                  didAnimate = true;
              }
<span class="line-new-header">--- 3288,12 ---</span>
  #if ENABLE(FILTERS_LEVEL_2)
      if (property == CSSPropertyWebkitBackdropFilter &amp;&amp; m_owningLayer.hasBackdropFilter()) {
          const Animation* backdropFilterAnim = toStyle-&gt;transitionForProperty(CSSPropertyWebkitBackdropFilter);
          if (backdropFilterAnim &amp;&amp; !backdropFilterAnim-&gt;isEmptyOrZeroDuration()) {
              KeyframeValueList backdropFilterVector(AnimatedPropertyWebkitBackdropFilter);
<span class="line-modified">!             backdropFilterVector.insert(makeUnique&lt;FilterAnimationValue&gt;(0, fromStyle-&gt;backdropFilter()));</span>
<span class="line-modified">!             backdropFilterVector.insert(makeUnique&lt;FilterAnimationValue&gt;(1, toStyle-&gt;backdropFilter()));</span>
              if (m_graphicsLayer-&gt;addAnimation(backdropFilterVector, FloatSize(), backdropFilterAnim, GraphicsLayer::animationNameForTransition(AnimatedPropertyWebkitBackdropFilter), timeOffset)) {
                  // To ensure that the correct backdrop filter is visible when the animation ends, also set the final backdrop filter.
                  updateBackdropFilters(*toStyle);
                  didAnimate = true;
              }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3054,11 ***</span>
  
  double RenderLayerBacking::backingStoreMemoryEstimate() const
  {
      double backingMemory;
  
<span class="line-modified">!     // m_ancestorClippingLayer, m_contentsContainmentLayer and m_childContainmentLayer are just used for masking or containment, so have no backing.</span>
      backingMemory = m_graphicsLayer-&gt;backingStoreMemoryEstimate();
      if (m_foregroundLayer)
          backingMemory += m_foregroundLayer-&gt;backingStoreMemoryEstimate();
      if (m_backgroundLayer)
          backingMemory += m_backgroundLayer-&gt;backingStoreMemoryEstimate();
<span class="line-new-header">--- 3443,11 ---</span>
  
  double RenderLayerBacking::backingStoreMemoryEstimate() const
  {
      double backingMemory;
  
<span class="line-modified">!     // Layers in m_ancestorClippingStack, m_contentsContainmentLayer and m_childContainmentLayer are just used for masking or containment, so have no backing.</span>
      backingMemory = m_graphicsLayer-&gt;backingStoreMemoryEstimate();
      if (m_foregroundLayer)
          backingMemory += m_foregroundLayer-&gt;backingStoreMemoryEstimate();
      if (m_backgroundLayer)
          backingMemory += m_backgroundLayer-&gt;backingStoreMemoryEstimate();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3096,11 ***</span>
<span class="line-new-header">--- 3485,17 ---</span>
      ts &lt;&lt; &quot; primary layer ID &quot; &lt;&lt; backing.graphicsLayer()-&gt;primaryLayerID();
      if (auto nodeID = backing.scrollingNodeIDForRole(ScrollCoordinationRole::ViewportConstrained))
          ts &lt;&lt; &quot; viewport constrained scrolling node &quot; &lt;&lt; nodeID;
      if (auto nodeID = backing.scrollingNodeIDForRole(ScrollCoordinationRole::Scrolling))
          ts &lt;&lt; &quot; scrolling node &quot; &lt;&lt; nodeID;
<span class="line-added">+ </span>
<span class="line-added">+     if (backing.ancestorClippingStack())</span>
<span class="line-added">+         ts &lt;&lt; &quot; ancestor clip stack &quot; &lt;&lt; *backing.ancestorClippingStack();</span>
<span class="line-added">+ </span>
      if (auto nodeID = backing.scrollingNodeIDForRole(ScrollCoordinationRole::FrameHosting))
          ts &lt;&lt; &quot; frame hosting node &quot; &lt;&lt; nodeID;
<span class="line-added">+     if (auto nodeID = backing.scrollingNodeIDForRole(ScrollCoordinationRole::Positioning))</span>
<span class="line-added">+         ts &lt;&lt; &quot; positioning node &quot; &lt;&lt; nodeID;</span>
      return ts;
  }
  
  } // namespace WebCore
</pre>
<center><a href="RenderLayer.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="RenderLayerBacking.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>