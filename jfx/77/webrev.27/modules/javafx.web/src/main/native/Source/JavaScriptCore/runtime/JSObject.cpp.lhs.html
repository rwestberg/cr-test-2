<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSObject.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  *  Copyright (C) 1999-2001 Harri Porten (porten@kde.org)
   3  *  Copyright (C) 2001 Peter Kelly (pmk@post.com)
<a name="1" id="anc1"></a><span class="line-modified">   4  *  Copyright (C) 2003-2017 Apple Inc. All rights reserved.</span>
   5  *  Copyright (C) 2007 Eric Seidel (eric@webkit.org)
   6  *
   7  *  This library is free software; you can redistribute it and/or
   8  *  modify it under the terms of the GNU Library General Public
   9  *  License as published by the Free Software Foundation; either
  10  *  version 2 of the License, or (at your option) any later version.
  11  *
  12  *  This library is distributed in the hope that it will be useful,
  13  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  14  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  15  *  Library General Public License for more details.
  16  *
  17  *  You should have received a copy of the GNU Library General Public License
  18  *  along with this library; see the file COPYING.LIB.  If not, write to
  19  *  the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  20  *  Boston, MA 02110-1301, USA.
  21  *
  22  */
  23 
  24 #include &quot;config.h&quot;
  25 #include &quot;JSObject.h&quot;
  26 
  27 #include &quot;ButterflyInlines.h&quot;
  28 #include &quot;CatchScope.h&quot;
  29 #include &quot;CustomGetterSetter.h&quot;
  30 #include &quot;DatePrototype.h&quot;
  31 #include &quot;ErrorConstructor.h&quot;
  32 #include &quot;Exception.h&quot;
<a name="2" id="anc2"></a>
  33 #include &quot;GetterSetter.h&quot;
<a name="3" id="anc3"></a><span class="line-modified">  34 #include &quot;HeapSnapshotBuilder.h&quot;</span>
  35 #include &quot;IndexingHeaderInlines.h&quot;
  36 #include &quot;JSCInlines.h&quot;
  37 #include &quot;JSCustomGetterSetterFunction.h&quot;
  38 #include &quot;JSFunction.h&quot;
  39 #include &quot;JSGlobalObject.h&quot;
  40 #include &quot;JSImmutableButterfly.h&quot;
  41 #include &quot;Lookup.h&quot;
  42 #include &quot;NativeErrorConstructor.h&quot;
  43 #include &quot;ObjectPrototype.h&quot;
  44 #include &quot;PropertyDescriptor.h&quot;
  45 #include &quot;PropertyNameArray.h&quot;
  46 #include &quot;ProxyObject.h&quot;
  47 #include &quot;SlotVisitorInlines.h&quot;
  48 #include &quot;TypeError.h&quot;
  49 #include &quot;VMInlines.h&quot;
  50 #include &lt;math.h&gt;
  51 #include &lt;wtf/Assertions.h&gt;
  52 
  53 namespace JSC {
  54 
  55 // We keep track of the size of the last array after it was grown. We use this
  56 // as a simple heuristic for as the value to grow the next array from size 0.
  57 // This value is capped by the constant FIRST_VECTOR_GROW defined in
  58 // ArrayConventions.h.
  59 static unsigned lastArraySize = 0;
  60 
  61 STATIC_ASSERT_IS_TRIVIALLY_DESTRUCTIBLE(JSObject);
  62 STATIC_ASSERT_IS_TRIVIALLY_DESTRUCTIBLE(JSFinalObject);
  63 
  64 const ASCIILiteral NonExtensibleObjectPropertyDefineError { &quot;Attempting to define property on object that is not extensible.&quot;_s };
  65 const ASCIILiteral ReadonlyPropertyWriteError { &quot;Attempted to assign to readonly property.&quot;_s };
  66 const ASCIILiteral ReadonlyPropertyChangeError { &quot;Attempting to change value of a readonly property.&quot;_s };
  67 const ASCIILiteral UnableToDeletePropertyError { &quot;Unable to delete property.&quot;_s };
  68 const ASCIILiteral UnconfigurablePropertyChangeAccessMechanismError { &quot;Attempting to change access mechanism for an unconfigurable property.&quot;_s };
  69 const ASCIILiteral UnconfigurablePropertyChangeConfigurabilityError { &quot;Attempting to change configurable attribute of unconfigurable property.&quot;_s };
  70 const ASCIILiteral UnconfigurablePropertyChangeEnumerabilityError { &quot;Attempting to change enumerable attribute of unconfigurable property.&quot;_s };
  71 const ASCIILiteral UnconfigurablePropertyChangeWritabilityError { &quot;Attempting to change writable attribute of unconfigurable property.&quot;_s };
  72 
  73 const ClassInfo JSObject::s_info = { &quot;Object&quot;, nullptr, nullptr, nullptr, CREATE_METHOD_TABLE(JSObject) };
  74 
  75 const ClassInfo JSFinalObject::s_info = { &quot;Object&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSFinalObject) };
  76 
  77 static inline void getClassPropertyNames(ExecState* exec, const ClassInfo* classInfo, PropertyNameArray&amp; propertyNames, EnumerationMode mode)
  78 {
  79     VM&amp; vm = exec-&gt;vm();
  80 
  81     // Add properties from the static hashtables of properties
  82     for (; classInfo; classInfo = classInfo-&gt;parentClass) {
  83         const HashTable* table = classInfo-&gt;staticPropHashTable;
  84         if (!table)
  85             continue;
  86 
  87         for (auto iter = table-&gt;begin(); iter != table-&gt;end(); ++iter) {
  88             if (!(iter-&gt;attributes() &amp; PropertyAttribute::DontEnum) || mode.includeDontEnumProperties())
<a name="4" id="anc4"></a><span class="line-modified">  89                 propertyNames.add(Identifier::fromString(&amp;vm, iter.key()));</span>
  90         }
  91     }
  92 }
  93 
  94 ALWAYS_INLINE void JSObject::markAuxiliaryAndVisitOutOfLineProperties(SlotVisitor&amp; visitor, Butterfly* butterfly, Structure* structure, PropertyOffset lastOffset)
  95 {
  96     // We call this when we found everything without races.
  97     ASSERT(structure);
  98 
  99     if (!butterfly)
 100         return;
 101 
 102     if (isCopyOnWrite(structure-&gt;indexingMode())) {
 103         visitor.append(bitwise_cast&lt;WriteBarrier&lt;JSCell&gt;&gt;(JSImmutableButterfly::fromButterfly(butterfly)));
 104         return;
 105     }
 106 
 107     bool hasIndexingHeader = structure-&gt;hasIndexingHeader(this);
 108     size_t preCapacity;
 109     if (hasIndexingHeader)
 110         preCapacity = butterfly-&gt;indexingHeader()-&gt;preCapacity(structure);
 111     else
 112         preCapacity = 0;
 113 
 114     HeapCell* base = bitwise_cast&lt;HeapCell*&gt;(
 115         butterfly-&gt;base(preCapacity, Structure::outOfLineCapacity(lastOffset)));
 116 
 117     ASSERT(Heap::heap(base) == visitor.heap());
 118 
 119     visitor.markAuxiliary(base);
 120 
 121     unsigned outOfLineSize = Structure::outOfLineSize(lastOffset);
 122     visitor.appendValuesHidden(butterfly-&gt;propertyStorage() - outOfLineSize, outOfLineSize);
 123 }
 124 
 125 ALWAYS_INLINE Structure* JSObject::visitButterfly(SlotVisitor&amp; visitor)
 126 {
 127     static const char* const raceReason = &quot;JSObject::visitButterfly&quot;;
 128     Structure* result = visitButterflyImpl(visitor);
 129     if (!result)
 130         visitor.didRace(this, raceReason);
 131     return result;
 132 }
 133 
 134 ALWAYS_INLINE Structure* JSObject::visitButterflyImpl(SlotVisitor&amp; visitor)
 135 {
 136     VM&amp; vm = visitor.vm();
 137 
 138     Butterfly* butterfly;
 139     Structure* structure;
 140     PropertyOffset lastOffset;
 141 
 142     auto visitElements = [&amp;] (IndexingType indexingMode) {
 143         switch (indexingMode) {
 144         // We don&#39;t need to visit the elements for CopyOnWrite butterflies since they we marked the JSImmutableButterfly acting as out butterfly.
 145         case ALL_WRITABLE_CONTIGUOUS_INDEXING_TYPES:
 146             visitor.appendValuesHidden(butterfly-&gt;contiguous().data(), butterfly-&gt;publicLength());
 147             break;
 148         case ALL_ARRAY_STORAGE_INDEXING_TYPES:
 149             visitor.appendValuesHidden(butterfly-&gt;arrayStorage()-&gt;m_vector, butterfly-&gt;arrayStorage()-&gt;vectorLength());
 150             if (butterfly-&gt;arrayStorage()-&gt;m_sparseMap)
 151                 visitor.append(butterfly-&gt;arrayStorage()-&gt;m_sparseMap);
 152             break;
 153         default:
 154             break;
 155         }
 156     };
 157 
 158     if (visitor.mutatorIsStopped()) {
 159         butterfly = this-&gt;butterfly();
 160         structure = this-&gt;structure(vm);
 161         lastOffset = structure-&gt;lastOffset();
 162 
 163         markAuxiliaryAndVisitOutOfLineProperties(visitor, butterfly, structure, lastOffset);
 164         visitElements(structure-&gt;indexingMode());
 165 
 166         return structure;
 167     }
 168 
 169     // We want to ensure that we only scan the butterfly if we have an exactly matched structure and an
 170     // exactly matched size. The mutator is required to perform the following shenanigans when
 171     // reallocating the butterfly with a concurrent collector, with all fencing necessary to ensure
 172     // that this executes as if under sequential consistency:
 173     //
 174     //     object-&gt;structure = nuke(object-&gt;structure)
 175     //     object-&gt;butterfly = newButterfly
 176     //     structure-&gt;m_offset = newLastOffset
 177     //     object-&gt;structure = newStructure
 178     //
 179     // It&#39;s OK to skip this when reallocating the butterfly in a way that does not affect the m_offset.
 180     // We have other protocols in place for that.
 181     //
 182     // Note that the m_offset can change without the structure changing, but in that case the mutator
 183     // will still store null to the structure.
 184     //
 185     // The collector will ensure that it always sees a matched butterfly/structure by reading the
 186     // structure before and after reading the butterfly. For simplicity, let&#39;s first consider the case
 187     // where the only way to change the outOfLineCapacity is to change the structure. This works
 188     // because the mutator performs the following steps sequentially:
 189     //
 190     //     NukeStructure ChangeButterfly PutNewStructure
 191     //
 192     // Meanwhile the collector performs the following steps sequentially:
 193     //
 194     //     ReadStructureEarly ReadButterfly ReadStructureLate
 195     //
 196     // The collector is allowed to do any of these three things:
 197     //
 198     // BEFORE: Scan the object with the structure and butterfly *before* the mutator&#39;s transition.
 199     // AFTER: Scan the object with the structure and butterfly *after* the mutator&#39;s transition.
 200     // IGNORE: Ignore the butterfly and call didRace to schedule us to be revisted again in the future.
 201     //
 202     // In other words, the collector will never see any torn structure/butterfly mix. It will
 203     // always see the structure/butterfly before the transition or after but not in between.
 204     //
 205     // We can prove that this is correct by exhaustively considering all interleavings:
 206     //
 207     // NukeStructure ChangeButterfly PutNewStructure ReadStructureEarly ReadButterfly ReadStructureLate: AFTER, trivially.
 208     // NukeStructure ChangeButterfly ReadStructureEarly PutNewStructure ReadButterfly ReadStructureLate: IGNORE, because nuked structure read early
 209     // NukeStructure ChangeButterfly ReadStructureEarly ReadButterfly PutNewStructure ReadStructureLate: IGNORE, because nuked structure read early
 210     // NukeStructure ChangeButterfly ReadStructureEarly ReadButterfly ReadStructureLate PutNewStructure: IGNORE, because nuked structure read early
 211     // NukeStructure ReadStructureEarly ChangeButterfly PutNewStructure ReadButterfly ReadStructureLate: IGNORE, because nuked structure read early
 212     // NukeStructure ReadStructureEarly ChangeButterfly ReadButterfly PutNewStructure ReadStructureLate: IGNORE, because nuked structure read early
 213     // NukeStructure ReadStructureEarly ChangeButterfly ReadButterfly ReadStructureLate PutNewStructure: IGNORE, because nuked structure read early
 214     // NukeStructure ReadStructureEarly ReadButterfly ChangeButterfly PutNewStructure ReadStructureLate: IGNORE, because nuked structure read early
 215     // NukeStructure ReadStructureEarly ReadButterfly ChangeButterfly ReadStructureLate PutNewStructure: IGNORE, because nuked structure read early
 216     // NukeStructure ReadStructureEarly ReadButterfly ReadStructureLate ChangeButterfly PutNewStructure: IGNORE, because nuked structure read early
 217     // ReadStructureEarly NukeStructure ChangeButterfly PutNewStructure ReadButterfly ReadStructureLate: IGNORE, because early and late structures don&#39;t match
 218     // ReadStructureEarly NukeStructure ChangeButterfly ReadButterfly PutNewStructure ReadStructureLate: IGNORE, because early and late structures don&#39;t match
 219     // ReadStructureEarly NukeStructure ChangeButterfly ReadButterfly ReadStructureLate PutNewStructure: IGNORE, because nuked structure read late
 220     // ReadStructureEarly NukeStructure ReadButterfly ChangeButterfly PutNewStructure ReadStructureLate: IGNORE, because early and late structures don&#39;t match
 221     // ReadStructureEarly NukeStructure ReadButterfly ChangeButterfly ReadStructureLate PutNewStructure: IGNORE, because nuked structure read late
 222     // ReadStructureEarly NukeStructure ReadButterfly ReadStructureLate ChangeButterfly PutNewStructure: IGNORE, because nuked structure read late
 223     // ReadStructureEarly ReadButterfly NukeStructure ChangeButterfly PutNewStructure ReadStructureLate: IGNORE, because early and late structures don&#39;t match
 224     // ReadStructureEarly ReadButterfly NukeStructure ChangeButterfly ReadStructureLate PutNewStructure: IGNORE, because nuked structure read late
 225     // ReadStructureEarly ReadButterfly NukeStructure ReadStructureLate ChangeButterfly PutNewStructure: IGNORE, because nuked structure read late
 226     // ReadStructureEarly ReadButterfly ReadStructureLate NukeStructure ChangeButterfly PutNewStructure: BEFORE, trivially.
 227     //
 228     // But we additionally have to worry about the size changing. We make this work by requiring that
 229     // the collector reads the size early and late as well. Lets consider the interleaving of the
 230     // mutator changing the size without changing the structure:
 231     //
 232     //     NukeStructure ChangeButterfly ChangeLastOffset RestoreStructure
 233     //
 234     // Meanwhile the collector does:
 235     //
 236     //     ReadStructureEarly ReadLastOffsetEarly ReadButterfly ReadStructureLate ReadLastOffsetLate
 237     //
 238     // The collector can detect races by not only comparing the early structure to the late structure
 239     // (which will be the same before and after the algorithm runs) but also by comparing the early and
 240     // late lastOffsets.  Note: the IGNORE proofs do not cite all of the reasons why the collector will
 241     // ignore the case, since we only need to identify one to say that we&#39;re in the ignore case.
 242     //
 243     // NukeStructure ChangeButterfly ChangeLastOffset RestoreStructure ReadStructureEarly ReadLastOffsetEarly ReadButterfly ReadStructureLate ReadLastOffsetLate: AFTER, trivially
 244     // NukeStructure ChangeButterfly ChangeLastOffset ReadStructureEarly RestoreStructure ReadLastOffsetEarly ReadButterfly ReadStructureLate ReadLastOffsetLate: IGNORE, read nuked structure early
 245     // NukeStructure ChangeButterfly ChangeLastOffset ReadStructureEarly ReadLastOffsetEarly RestoreStructure ReadButterfly ReadStructureLate ReadLastOffsetLate: IGNORE, read nuked structure early
 246     // NukeStructure ChangeButterfly ChangeLastOffset ReadStructureEarly ReadLastOffsetEarly ReadButterfly RestoreStructure ReadStructureLate ReadLastOffsetLate: IGNORE, read nuked structure early
 247     // NukeStructure ChangeButterfly ChangeLastOffset ReadStructureEarly ReadLastOffsetEarly ReadButterfly ReadStructureLate RestoreStructure ReadLastOffsetLate: IGNORE, read nuked structure early
 248     // NukeStructure ChangeButterfly ChangeLastOffset ReadStructureEarly ReadLastOffsetEarly ReadButterfly ReadStructureLate ReadLastOffsetLate RestoreStructure: IGNORE, read nuked structure early
 249     // NukeStructure ChangeButterfly ReadStructureEarly ChangeLastOffset RestoreStructure ReadLastOffsetEarly ReadButterfly ReadStructureLate ReadLastOffsetLate: IGNORE, read nuked structure early
 250     // NukeStructure ChangeButterfly ReadStructureEarly ChangeLastOffset ReadLastOffsetEarly RestoreStructure ReadButterfly ReadStructureLate ReadLastOffsetLate: IGNORE, read nuked structure early
 251     // NukeStructure ChangeButterfly ReadStructureEarly ChangeLastOffset ReadLastOffsetEarly ReadButterfly RestoreStructure ReadStructureLate ReadLastOffsetLate: IGNORE, read nuked structure early
 252     // NukeStructure ChangeButterfly ReadStructureEarly ChangeLastOffset ReadLastOffsetEarly ReadButterfly ReadStructureLate RestoreStructure ReadLastOffsetLate: IGNORE, read nuked structure early
 253     // NukeStructure ChangeButterfly ReadStructureEarly ChangeLastOffset ReadLastOffsetEarly ReadButterfly ReadStructureLate ReadLastOffsetLate RestoreStructure: IGNORE, read nuked structure early
 254     // NukeStructure ChangeButterfly ReadStructureEarly ReadLastOffsetEarly ChangeLastOffset RestoreStructure ReadButterfly ReadStructureLate ReadLastOffsetLate: IGNORE, read nuked structure early
 255     // NukeStructure ChangeButterfly ReadStructureEarly ReadLastOffsetEarly ChangeLastOffset ReadButterfly RestoreStructure ReadStructureLate ReadLastOffsetLate: IGNORE, read nuked structure early
 256     // NukeStructure ChangeButterfly ReadStructureEarly ReadLastOffsetEarly ChangeLastOffset ReadButterfly ReadStructureLate RestoreStructure ReadLastOffsetLate: IGNORE, read nuked structure early
 257     // NukeStructure ChangeButterfly ReadStructureEarly ReadLastOffsetEarly ChangeLastOffset ReadButterfly ReadStructureLate ReadLastOffsetLate RestoreStructure: IGNORE, read nuked structure early
 258     // NukeStructure ChangeButterfly ReadStructureEarly ReadLastOffsetEarly ReadButterfly ChangeLastOffset RestoreStructure ReadStructureLate ReadLastOffsetLate: IGNORE, read nuked structure early
 259     // NukeStructure ChangeButterfly ReadStructureEarly ReadLastOffsetEarly ReadButterfly ChangeLastOffset ReadStructureLate RestoreStructure ReadLastOffsetLate: IGNORE, read nuked structure early
 260     // NukeStructure ChangeButterfly ReadStructureEarly ReadLastOffsetEarly ReadButterfly ChangeLastOffset ReadStructureLate ReadLastOffsetLate RestoreStructure: IGNORE, read nuked structure early
 261     // NukeStructure ChangeButterfly ReadStructureEarly ReadLastOffsetEarly ReadButterfly ReadStructureLate ChangeLastOffset RestoreStructure ReadLastOffsetLate: IGNORE, read nuked structure early
 262     // NukeStructure ChangeButterfly ReadStructureEarly ReadLastOffsetEarly ReadButterfly ReadStructureLate ChangeLastOffset ReadLastOffsetLate RestoreStructure: IGNORE, read nuked structure early
 263     // NukeStructure ChangeButterfly ReadStructureEarly ReadLastOffsetEarly ReadButterfly ReadStructureLate ReadLastOffsetLate ChangeLastOffset RestoreStructure: IGNORE, read nuked structure early
 264     // NukeStructure ReadStructureEarly ChangeButterfly ChangeLastOffset RestoreStructure ReadLastOffsetEarly ReadButterfly ReadStructureLate ReadLastOffsetLate: IGNORE, read nuked structure early
 265     // NukeStructure ReadStructureEarly ChangeButterfly ChangeLastOffset ReadLastOffsetEarly RestoreStructure ReadButterfly ReadStructureLate ReadLastOffsetLate: IGNORE, read nuked structure early
 266     // NukeStructure ReadStructureEarly ChangeButterfly ChangeLastOffset ReadLastOffsetEarly ReadButterfly RestoreStructure ReadStructureLate ReadLastOffsetLate: IGNORE, read nuked structure early
 267     // NukeStructure ReadStructureEarly ChangeButterfly ChangeLastOffset ReadLastOffsetEarly ReadButterfly ReadStructureLate RestoreStructure ReadLastOffsetLate: IGNORE, read nuked structure early
 268     // NukeStructure ReadStructureEarly ChangeButterfly ChangeLastOffset ReadLastOffsetEarly ReadButterfly ReadStructureLate ReadLastOffsetLate RestoreStructure: IGNORE, read nuked structure early
 269     // NukeStructure ReadStructureEarly ChangeButterfly ReadLastOffsetEarly ChangeLastOffset RestoreStructure ReadButterfly ReadStructureLate ReadLastOffsetLate: IGNORE, read nuked structure early
 270     // NukeStructure ReadStructureEarly ChangeButterfly ReadLastOffsetEarly ChangeLastOffset ReadButterfly RestoreStructure ReadStructureLate ReadLastOffsetLate: IGNORE, read nuked structure early
 271     // NukeStructure ReadStructureEarly ChangeButterfly ReadLastOffsetEarly ChangeLastOffset ReadButterfly ReadStructureLate RestoreStructure ReadLastOffsetLate: IGNORE, read nuked structure early
 272     // NukeStructure ReadStructureEarly ChangeButterfly ReadLastOffsetEarly ChangeLastOffset ReadButterfly ReadStructureLate ReadLastOffsetLate RestoreStructure: IGNORE, read nuked structure early
 273     // NukeStructure ReadStructureEarly ChangeButterfly ReadLastOffsetEarly ReadButterfly ChangeLastOffset RestoreStructure ReadStructureLate ReadLastOffsetLate: IGNORE, read nuked structure early
 274     // NukeStructure ReadStructureEarly ChangeButterfly ReadLastOffsetEarly ReadButterfly ChangeLastOffset ReadStructureLate RestoreStructure ReadLastOffsetLate: IGNORE, read nuked structure early
 275     // NukeStructure ReadStructureEarly ChangeButterfly ReadLastOffsetEarly ReadButterfly ChangeLastOffset ReadStructureLate ReadLastOffsetLate RestoreStructure: IGNORE, read nuked structure early
 276     // NukeStructure ReadStructureEarly ChangeButterfly ReadLastOffsetEarly ReadButterfly ReadStructureLate ChangeLastOffset RestoreStructure ReadLastOffsetLate: IGNORE, read nuked structure early
 277     // NukeStructure ReadStructureEarly ChangeButterfly ReadLastOffsetEarly ReadButterfly ReadStructureLate ChangeLastOffset ReadLastOffsetLate RestoreStructure: IGNORE, read nuked structure early
 278     // NukeStructure ReadStructureEarly ChangeButterfly ReadLastOffsetEarly ReadButterfly ReadStructureLate ReadLastOffsetLate ChangeLastOffset RestoreStructure: IGNORE, read nuked structure early
 279     // NukeStructure ReadStructureEarly ReadLastOffsetEarly ChangeButterfly ChangeLastOffset RestoreStructure ReadButterfly ReadStructureLate ReadLastOffsetLate: IGNORE, read nuked structure early
 280     // NukeStructure ReadStructureEarly ReadLastOffsetEarly ChangeButterfly ChangeLastOffset ReadButterfly RestoreStructure ReadStructureLate ReadLastOffsetLate: IGNORE, read nuked structure early
 281     // NukeStructure ReadStructureEarly ReadLastOffsetEarly ChangeButterfly ChangeLastOffset ReadButterfly ReadStructureLate RestoreStructure ReadLastOffsetLate: IGNORE, read nuked structure early
 282     // NukeStructure ReadStructureEarly ReadLastOffsetEarly ChangeButterfly ChangeLastOffset ReadButterfly ReadStructureLate ReadLastOffsetLate RestoreStructure: IGNORE, read nuked structure early
 283     // NukeStructure ReadStructureEarly ReadLastOffsetEarly ChangeButterfly ReadButterfly ChangeLastOffset RestoreStructure ReadStructureLate ReadLastOffsetLate: IGNORE, read nuked structure early
 284     // NukeStructure ReadStructureEarly ReadLastOffsetEarly ChangeButterfly ReadButterfly ChangeLastOffset ReadStructureLate RestoreStructure ReadLastOffsetLate: IGNORE, read nuked structure early
 285     // NukeStructure ReadStructureEarly ReadLastOffsetEarly ChangeButterfly ReadButterfly ChangeLastOffset ReadStructureLate ReadLastOffsetLate RestoreStructure: IGNORE, read nuked structure early
 286     // NukeStructure ReadStructureEarly ReadLastOffsetEarly ChangeButterfly ReadButterfly ReadStructureLate ChangeLastOffset RestoreStructure ReadLastOffsetLate: IGNORE, read nuked structure early
 287     // NukeStructure ReadStructureEarly ReadLastOffsetEarly ChangeButterfly ReadButterfly ReadStructureLate ChangeLastOffset ReadLastOffsetLate RestoreStructure: IGNORE, read nuked structure early
 288     // NukeStructure ReadStructureEarly ReadLastOffsetEarly ChangeButterfly ReadButterfly ReadStructureLate ReadLastOffsetLate ChangeLastOffset RestoreStructure: IGNORE, read nuked structure early
 289     // NukeStructure ReadStructureEarly ReadLastOffsetEarly ReadButterfly ChangeButterfly ChangeLastOffset RestoreStructure ReadStructureLate ReadLastOffsetLate: IGNORE, read nuked structure early
 290     // NukeStructure ReadStructureEarly ReadLastOffsetEarly ReadButterfly ChangeButterfly ChangeLastOffset ReadStructureLate RestoreStructure ReadLastOffsetLate: IGNORE, read nuked structure early
 291     // NukeStructure ReadStructureEarly ReadLastOffsetEarly ReadButterfly ChangeButterfly ChangeLastOffset ReadStructureLate ReadLastOffsetLate RestoreStructure: IGNORE, read nuked structure early
 292     // NukeStructure ReadStructureEarly ReadLastOffsetEarly ReadButterfly ChangeButterfly ReadStructureLate ChangeLastOffset RestoreStructure ReadLastOffsetLate: IGNORE, read nuked structure early
 293     // NukeStructure ReadStructureEarly ReadLastOffsetEarly ReadButterfly ChangeButterfly ReadStructureLate ChangeLastOffset ReadLastOffsetLate RestoreStructure: IGNORE, read nuked structure early
 294     // NukeStructure ReadStructureEarly ReadLastOffsetEarly ReadButterfly ChangeButterfly ReadStructureLate ReadLastOffsetLate ChangeLastOffset RestoreStructure: IGNORE, read nuked structure early
 295     // NukeStructure ReadStructureEarly ReadLastOffsetEarly ReadButterfly ReadStructureLate ChangeButterfly ChangeLastOffset RestoreStructure ReadLastOffsetLate: IGNORE, read nuked structure early
 296     // NukeStructure ReadStructureEarly ReadLastOffsetEarly ReadButterfly ReadStructureLate ChangeButterfly ChangeLastOffset ReadLastOffsetLate RestoreStructure: IGNORE, read nuked structure early
 297     // NukeStructure ReadStructureEarly ReadLastOffsetEarly ReadButterfly ReadStructureLate ChangeButterfly ReadLastOffsetLate ChangeLastOffset RestoreStructure: IGNORE, read nuked structure early
 298     // NukeStructure ReadStructureEarly ReadLastOffsetEarly ReadButterfly ReadStructureLate ReadLastOffsetLate ChangeButterfly ChangeLastOffset RestoreStructure: IGNORE, read nuked structure early
 299     // ReadStructureEarly NukeStructure ChangeButterfly ChangeLastOffset RestoreStructure ReadLastOffsetEarly ReadButterfly ReadStructureLate ReadLastOffsetLate: AFTER, the ReadStructureEarly sees the same structure as after and everything else runs after.
 300     // ReadStructureEarly NukeStructure ChangeButterfly ChangeLastOffset ReadLastOffsetEarly RestoreStructure ReadButterfly ReadStructureLate ReadLastOffsetLate: AFTER, as above and the ReadLastOffsetEarly sees the lastOffset after.
 301     // ReadStructureEarly NukeStructure ChangeButterfly ChangeLastOffset ReadLastOffsetEarly ReadButterfly RestoreStructure ReadStructureLate ReadLastOffsetLate: AFTER, as above and the ReadButterfly sees the right butterfly after.
 302     // ReadStructureEarly NukeStructure ChangeButterfly ChangeLastOffset ReadLastOffsetEarly ReadButterfly ReadStructureLate RestoreStructure ReadLastOffsetLate: IGNORE, read nuked structure late
 303     // ReadStructureEarly NukeStructure ChangeButterfly ChangeLastOffset ReadLastOffsetEarly ReadButterfly ReadStructureLate ReadLastOffsetLate RestoreStructure: IGNORE, read nuked structure late
 304     // ReadStructureEarly NukeStructure ChangeButterfly ReadLastOffsetEarly ChangeLastOffset RestoreStructure ReadButterfly ReadStructureLate ReadLastOffsetLate: IGNORE, read different offsets
 305     // ReadStructureEarly NukeStructure ChangeButterfly ReadLastOffsetEarly ChangeLastOffset ReadButterfly RestoreStructure ReadStructureLate ReadLastOffsetLate: IGNORE, read different offsets
 306     // ReadStructureEarly NukeStructure ChangeButterfly ReadLastOffsetEarly ChangeLastOffset ReadButterfly ReadStructureLate RestoreStructure ReadLastOffsetLate: IGNORE, read different offsets
 307     // ReadStructureEarly NukeStructure ChangeButterfly ReadLastOffsetEarly ChangeLastOffset ReadButterfly ReadStructureLate ReadLastOffsetLate RestoreStructure: IGNORE, read different offsets
 308     // ReadStructureEarly NukeStructure ChangeButterfly ReadLastOffsetEarly ReadButterfly ChangeLastOffset RestoreStructure ReadStructureLate ReadLastOffsetLate: IGNORE, read different offsets
 309     // ReadStructureEarly NukeStructure ChangeButterfly ReadLastOffsetEarly ReadButterfly ChangeLastOffset ReadStructureLate RestoreStructure ReadLastOffsetLate: IGNORE, read different offsets
 310     // ReadStructureEarly NukeStructure ChangeButterfly ReadLastOffsetEarly ReadButterfly ChangeLastOffset ReadStructureLate ReadLastOffsetLate RestoreStructure: IGNORE, read different offsets
 311     // ReadStructureEarly NukeStructure ChangeButterfly ReadLastOffsetEarly ReadButterfly ReadStructureLate ChangeLastOffset RestoreStructure ReadLastOffsetLate: IGNORE, read different offsets
 312     // ReadStructureEarly NukeStructure ChangeButterfly ReadLastOffsetEarly ReadButterfly ReadStructureLate ChangeLastOffset ReadLastOffsetLate RestoreStructure: IGNORE, read different offsets
 313     // ReadStructureEarly NukeStructure ChangeButterfly ReadLastOffsetEarly ReadButterfly ReadStructureLate ReadLastOffsetLate ChangeLastOffset RestoreStructure: IGNORE, read nuked structure late
 314     // ReadStructureEarly NukeStructure ReadLastOffsetEarly ChangeButterfly ChangeLastOffset RestoreStructure ReadButterfly ReadStructureLate ReadLastOffsetLate: IGNORE, read different offsets
 315     // ReadStructureEarly NukeStructure ReadLastOffsetEarly ChangeButterfly ChangeLastOffset ReadButterfly RestoreStructure ReadStructureLate ReadLastOffsetLate: IGNORE, read different offsets
 316     // ReadStructureEarly NukeStructure ReadLastOffsetEarly ChangeButterfly ChangeLastOffset ReadButterfly ReadStructureLate RestoreStructure ReadLastOffsetLate: IGNORE, read different offsets
 317     // ReadStructureEarly NukeStructure ReadLastOffsetEarly ChangeButterfly ChangeLastOffset ReadButterfly ReadStructureLate ReadLastOffsetLate RestoreStructure: IGNORE, read different offsets
 318     // ReadStructureEarly NukeStructure ReadLastOffsetEarly ChangeButterfly ReadButterfly ChangeLastOffset RestoreStructure ReadStructureLate ReadLastOffsetLate: IGNORE, read different offsets
 319     // ReadStructureEarly NukeStructure ReadLastOffsetEarly ChangeButterfly ReadButterfly ChangeLastOffset ReadStructureLate RestoreStructure ReadLastOffsetLate: IGNORE, read different offsets
 320     // ReadStructureEarly NukeStructure ReadLastOffsetEarly ChangeButterfly ReadButterfly ChangeLastOffset ReadStructureLate ReadLastOffsetLate RestoreStructure: IGNORE, read different offsets
 321     // ReadStructureEarly NukeStructure ReadLastOffsetEarly ChangeButterfly ReadButterfly ReadStructureLate ChangeLastOffset RestoreStructure ReadLastOffsetLate: IGNORE, read different offsets
 322     // ReadStructureEarly NukeStructure ReadLastOffsetEarly ChangeButterfly ReadButterfly ReadStructureLate ChangeLastOffset ReadLastOffsetLate RestoreStructure: IGNORE, read different offsets
 323     // ReadStructureEarly NukeStructure ReadLastOffsetEarly ChangeButterfly ReadButterfly ReadStructureLate ReadLastOffsetLate ChangeLastOffset RestoreStructure: IGNORE, read nuked structure late
 324     // ReadStructureEarly NukeStructure ReadLastOffsetEarly ReadButterfly ChangeButterfly ChangeLastOffset RestoreStructure ReadStructureLate ReadLastOffsetLate: IGNORE, read different offsets
 325     // ReadStructureEarly NukeStructure ReadLastOffsetEarly ReadButterfly ChangeButterfly ChangeLastOffset ReadStructureLate RestoreStructure ReadLastOffsetLate: IGNORE, read different offsets
 326     // ReadStructureEarly NukeStructure ReadLastOffsetEarly ReadButterfly ChangeButterfly ChangeLastOffset ReadStructureLate ReadLastOffsetLate RestoreStructure: IGNORE, read different offsets
 327     // ReadStructureEarly NukeStructure ReadLastOffsetEarly ReadButterfly ChangeButterfly ReadStructureLate ChangeLastOffset RestoreStructure ReadLastOffsetLate: IGNORE, read different offsets
 328     // ReadStructureEarly NukeStructure ReadLastOffsetEarly ReadButterfly ChangeButterfly ReadStructureLate ChangeLastOffset ReadLastOffsetLate RestoreStructure: IGNORE, read different offsets
 329     // ReadStructureEarly NukeStructure ReadLastOffsetEarly ReadButterfly ChangeButterfly ReadStructureLate ReadLastOffsetLate ChangeLastOffset RestoreStructure: IGNORE, read nuked structure late
 330     // ReadStructureEarly NukeStructure ReadLastOffsetEarly ReadButterfly ReadStructureLate ChangeButterfly ChangeLastOffset RestoreStructure ReadLastOffsetLate: IGNORE, read different offsets
 331     // ReadStructureEarly NukeStructure ReadLastOffsetEarly ReadButterfly ReadStructureLate ChangeButterfly ChangeLastOffset ReadLastOffsetLate RestoreStructure: IGNORE, read different offsets
 332     // ReadStructureEarly NukeStructure ReadLastOffsetEarly ReadButterfly ReadStructureLate ChangeButterfly ReadLastOffsetLate ChangeLastOffset RestoreStructure: IGNORE, read nuked structure late
 333     // ReadStructureEarly NukeStructure ReadLastOffsetEarly ReadButterfly ReadStructureLate ReadLastOffsetLate ChangeButterfly ChangeLastOffset RestoreStructure: IGNORE, read nuked structure late
 334     // ReadStructureEarly ReadLastOffsetEarly NukeStructure ChangeButterfly ChangeLastOffset RestoreStructure ReadButterfly ReadStructureLate ReadLastOffsetLate: IGNORE, read different offsets
 335     // ReadStructureEarly ReadLastOffsetEarly NukeStructure ChangeButterfly ChangeLastOffset ReadButterfly RestoreStructure ReadStructureLate ReadLastOffsetLate: IGNORE, read different offsets
 336     // ReadStructureEarly ReadLastOffsetEarly NukeStructure ChangeButterfly ChangeLastOffset ReadButterfly ReadStructureLate RestoreStructure ReadLastOffsetLate: IGNORE, read nuked structure late
 337     // ReadStructureEarly ReadLastOffsetEarly NukeStructure ChangeButterfly ChangeLastOffset ReadButterfly ReadStructureLate ReadLastOffsetLate RestoreStructure: IGNORE, read nuked structure late
 338     // ReadStructureEarly ReadLastOffsetEarly NukeStructure ChangeButterfly ReadButterfly ChangeLastOffset RestoreStructure ReadStructureLate ReadLastOffsetLate: IGNORE, read different offsets
 339     // ReadStructureEarly ReadLastOffsetEarly NukeStructure ChangeButterfly ReadButterfly ChangeLastOffset ReadStructureLate RestoreStructure ReadLastOffsetLate: IGNORE, read different offsets
 340     // ReadStructureEarly ReadLastOffsetEarly NukeStructure ChangeButterfly ReadButterfly ChangeLastOffset ReadStructureLate ReadLastOffsetLate RestoreStructure: IGNORE, read different offsets
 341     // ReadStructureEarly ReadLastOffsetEarly NukeStructure ChangeButterfly ReadButterfly ReadStructureLate ChangeLastOffset RestoreStructure ReadLastOffsetLate: IGNORE, read different offsets
 342     // ReadStructureEarly ReadLastOffsetEarly NukeStructure ChangeButterfly ReadButterfly ReadStructureLate ChangeLastOffset ReadLastOffsetLate RestoreStructure: IGNORE, read different offsets
 343     // ReadStructureEarly ReadLastOffsetEarly NukeStructure ChangeButterfly ReadButterfly ReadStructureLate ReadLastOffsetLate ChangeLastOffset RestoreStructure: IGNORE, read nuked structure late
 344     // ReadStructureEarly ReadLastOffsetEarly NukeStructure ReadButterfly ChangeButterfly ChangeLastOffset RestoreStructure ReadStructureLate ReadLastOffsetLate: IGNORE, read different offsets
 345     // ReadStructureEarly ReadLastOffsetEarly NukeStructure ReadButterfly ChangeButterfly ChangeLastOffset ReadStructureLate RestoreStructure ReadLastOffsetLate: IGNORE, read different offsets
 346     // ReadStructureEarly ReadLastOffsetEarly NukeStructure ReadButterfly ChangeButterfly ChangeLastOffset ReadStructureLate ReadLastOffsetLate RestoreStructure: IGNORE, read different offsets
 347     // ReadStructureEarly ReadLastOffsetEarly NukeStructure ReadButterfly ChangeButterfly ReadStructureLate ChangeLastOffset RestoreStructure ReadLastOffsetLate: IGNORE, read different offsets
 348     // ReadStructureEarly ReadLastOffsetEarly NukeStructure ReadButterfly ChangeButterfly ReadStructureLate ChangeLastOffset ReadLastOffsetLate RestoreStructure: IGNORE, read different offsets
 349     // ReadStructureEarly ReadLastOffsetEarly NukeStructure ReadButterfly ChangeButterfly ReadStructureLate ReadLastOffsetLate ChangeLastOffset RestoreStructure: IGNORE, read nuked structure late
 350     // ReadStructureEarly ReadLastOffsetEarly NukeStructure ReadButterfly ReadStructureLate ChangeButterfly ChangeLastOffset RestoreStructure ReadLastOffsetLate: IGNORE, read different offsets
 351     // ReadStructureEarly ReadLastOffsetEarly NukeStructure ReadButterfly ReadStructureLate ChangeButterfly ChangeLastOffset ReadLastOffsetLate RestoreStructure: IGNORE, read nuked structure late
 352     // ReadStructureEarly ReadLastOffsetEarly NukeStructure ReadButterfly ReadStructureLate ChangeButterfly ReadLastOffsetLate ChangeLastOffset RestoreStructure: IGNORE, read nuked structure late
 353     // ReadStructureEarly ReadLastOffsetEarly NukeStructure ReadButterfly ReadStructureLate ReadLastOffsetLate ChangeButterfly ChangeLastOffset RestoreStructure: IGNORE, read nuked structure late
 354     // ReadStructureEarly ReadLastOffsetEarly ReadButterfly NukeStructure ChangeButterfly ChangeLastOffset RestoreStructure ReadStructureLate ReadLastOffsetLate: IGNORE, read different offsets
 355     // ReadStructureEarly ReadLastOffsetEarly ReadButterfly NukeStructure ChangeButterfly ChangeLastOffset ReadStructureLate RestoreStructure ReadLastOffsetLate: IGNORE, read different offsets
 356     // ReadStructureEarly ReadLastOffsetEarly ReadButterfly NukeStructure ChangeButterfly ChangeLastOffset ReadStructureLate ReadLastOffsetLate RestoreStructure: IGNORE, read different offsets
 357     // ReadStructureEarly ReadLastOffsetEarly ReadButterfly NukeStructure ChangeButterfly ReadStructureLate ChangeLastOffset RestoreStructure ReadLastOffsetLate: IGNORE, read different offsets
 358     // ReadStructureEarly ReadLastOffsetEarly ReadButterfly NukeStructure ChangeButterfly ReadStructureLate ChangeLastOffset ReadLastOffsetLate RestoreStructure: IGNORE, read different offsets
 359     // ReadStructureEarly ReadLastOffsetEarly ReadButterfly NukeStructure ChangeButterfly ReadStructureLate ReadLastOffsetLate ChangeLastOffset RestoreStructure: IGNORE, read nuked structure late
 360     // ReadStructureEarly ReadLastOffsetEarly ReadButterfly NukeStructure ReadStructureLate ChangeButterfly ChangeLastOffset RestoreStructure ReadLastOffsetLate: IGNORE, read nuked structure late
 361     // ReadStructureEarly ReadLastOffsetEarly ReadButterfly NukeStructure ReadStructureLate ChangeButterfly ChangeLastOffset ReadLastOffsetLate RestoreStructure: IGNORE, read nuked structure late
 362     // ReadStructureEarly ReadLastOffsetEarly ReadButterfly NukeStructure ReadStructureLate ChangeButterfly ReadLastOffsetLate ChangeLastOffset RestoreStructure: IGNORE, read nuked structure late
 363     // ReadStructureEarly ReadLastOffsetEarly ReadButterfly NukeStructure ReadStructureLate ReadLastOffsetLate ChangeButterfly ChangeLastOffset RestoreStructure: IGNORE, read nuked structure late
 364     // ReadStructureEarly ReadLastOffsetEarly ReadButterfly ReadStructureLate NukeStructure ChangeButterfly ChangeLastOffset RestoreStructure ReadLastOffsetLate: IGNORE, read different offsets
 365     // ReadStructureEarly ReadLastOffsetEarly ReadButterfly ReadStructureLate NukeStructure ChangeButterfly ChangeLastOffset ReadLastOffsetLate RestoreStructure: IGNORE, read different offsets
 366     // ReadStructureEarly ReadLastOffsetEarly ReadButterfly ReadStructureLate NukeStructure ChangeButterfly ReadLastOffsetLate ChangeLastOffset RestoreStructure: BEFORE, reads the offset before, everything else happens before
 367     // ReadStructureEarly ReadLastOffsetEarly ReadButterfly ReadStructureLate NukeStructure ReadLastOffsetLate ChangeButterfly ChangeLastOffset RestoreStructure: BEFORE, reads the offset before, everything else happens before
 368     // ReadStructureEarly ReadLastOffsetEarly ReadButterfly ReadStructureLate ReadLastOffsetLate NukeStructure ChangeButterfly ChangeLastOffset RestoreStructure: BEFORE, trivially
 369     //
 370     // Whew.
 371     //
 372     // What the collector is doing is just the &quot;double collect&quot; snapshot from &quot;The Unbounded Single-
 373     // Writer Algorithm&quot; from Yehuda Afek et al&#39;s &quot;Atomic Snapshots of Shared Memory&quot; in JACM 1993,
 374     // also available here:
 375     //
 376     // http://people.csail.mit.edu/shanir/publications/AADGMS.pdf
 377     //
 378     // Unlike Afek et al&#39;s algorithm, ours does not require extra hacks to force wait-freedom (see
 379     // &quot;Observation 2&quot; in the paper). This simplifies the whole algorithm. Instead we are happy with
 380     // obstruction-freedom, and like any good obstruction-free algorithm, we ensure progress using
 381     // scheduling. We also only collect the butterfly once instead of twice; this optimization seems
 382     // to hold up in my proofs above and I&#39;m not sure it&#39;s part of Afek et al&#39;s algos.
 383     //
 384     // For more background on this kind of madness, I like this paper; it&#39;s where I learned about
 385     // both the snapshot algorithm and obstruction-freedom:
 386     //
 387     // Lunchangco, Moir, Shavit. &quot;Nonblocking k-compare-single-swap.&quot; SPAA &#39;03
 388     // https://pdfs.semanticscholar.org/343f/7182cde7669ca2a7de3dc01127927f384ef7.pdf
 389 
 390     StructureID structureID = this-&gt;structureID();
 391     if (isNuked(structureID))
 392         return nullptr;
 393     structure = vm.getStructure(structureID);
 394     lastOffset = structure-&gt;lastOffset();
 395     IndexingType indexingMode = structure-&gt;indexingMode();
 396     Dependency indexingModeDependency = Dependency::fence(indexingMode);
 397     Locker&lt;JSCellLock&gt; locker(NoLockingNecessary);
 398     switch (indexingMode) {
 399     case ALL_ARRAY_STORAGE_INDEXING_TYPES:
 400         // We need to hold this lock to protect against changes to the innards of the butterfly
 401         // that can happen when the butterfly is used for array storage.
 402         // We do not need to hold this lock for contiguous butterflies. We do not reuse the existing
 403         // butterfly with contiguous shape for new array storage butterfly. When converting the butterfly
 404         // with contiguous shape to array storage, we always allocate a new one. Holding this lock for contiguous
 405         // butterflies is unnecessary since contiguous shaped butterfly never becomes broken state.
 406         locker = holdLock(cellLock());
 407         break;
 408     default:
 409         break;
 410     }
 411     butterfly = indexingModeDependency.consume(this)-&gt;butterfly();
 412     Dependency butterflyDependency = Dependency::fence(butterfly);
 413     if (!butterfly)
 414         return structure;
 415     if (butterflyDependency.consume(this)-&gt;structureID() != structureID)
 416         return nullptr;
 417     if (butterflyDependency.consume(structure)-&gt;lastOffset() != lastOffset)
 418         return nullptr;
 419 
 420     markAuxiliaryAndVisitOutOfLineProperties(visitor, butterfly, structure, lastOffset);
 421     ASSERT(indexingMode == structure-&gt;indexingMode());
 422     visitElements(indexingMode);
 423 
 424     return structure;
 425 }
 426 
 427 size_t JSObject::estimatedSize(JSCell* cell, VM&amp; vm)
 428 {
 429     JSObject* thisObject = jsCast&lt;JSObject*&gt;(cell);
 430     size_t butterflyOutOfLineSize = thisObject-&gt;m_butterfly ? thisObject-&gt;structure(vm)-&gt;outOfLineSize() : 0;
 431     return Base::estimatedSize(cell, vm) + butterflyOutOfLineSize;
 432 }
 433 
 434 void JSObject::visitChildren(JSCell* cell, SlotVisitor&amp; visitor)
 435 {
 436     JSObject* thisObject = jsCast&lt;JSObject*&gt;(cell);
 437     ASSERT_GC_OBJECT_INHERITS(thisObject, info());
 438 #if !ASSERT_DISABLED
 439     bool wasCheckingForDefaultMarkViolation = visitor.m_isCheckingForDefaultMarkViolation;
 440     visitor.m_isCheckingForDefaultMarkViolation = false;
 441 #endif
 442 
 443     JSCell::visitChildren(thisObject, visitor);
 444 
 445     thisObject-&gt;visitButterfly(visitor);
 446 
 447 #if !ASSERT_DISABLED
 448     visitor.m_isCheckingForDefaultMarkViolation = wasCheckingForDefaultMarkViolation;
 449 #endif
 450 }
 451 
<a name="5" id="anc5"></a><span class="line-modified"> 452 void JSObject::heapSnapshot(JSCell* cell, HeapSnapshotBuilder&amp; builder)</span>
 453 {
 454     JSObject* thisObject = jsCast&lt;JSObject*&gt;(cell);
<a name="6" id="anc6"></a><span class="line-modified"> 455     Base::heapSnapshot(cell, builder);</span>
 456 
 457     Structure* structure = thisObject-&gt;structure();
 458     for (auto&amp; entry : structure-&gt;getPropertiesConcurrently()) {
 459         JSValue toValue = thisObject-&gt;getDirect(entry.offset);
 460         if (toValue &amp;&amp; toValue.isCell())
<a name="7" id="anc7"></a><span class="line-modified"> 461             builder.appendPropertyNameEdge(thisObject, toValue.asCell(), entry.key);</span>
 462     }
 463 
 464     Butterfly* butterfly = thisObject-&gt;butterfly();
 465     if (butterfly) {
 466         WriteBarrier&lt;Unknown&gt;* data = nullptr;
 467         uint32_t count = 0;
 468 
 469         switch (thisObject-&gt;indexingType()) {
 470         case ALL_CONTIGUOUS_INDEXING_TYPES:
 471             data = butterfly-&gt;contiguous().data();
 472             count = butterfly-&gt;publicLength();
 473             break;
 474         case ALL_ARRAY_STORAGE_INDEXING_TYPES:
 475             data = butterfly-&gt;arrayStorage()-&gt;m_vector;
 476             count = butterfly-&gt;arrayStorage()-&gt;vectorLength();
 477             break;
 478         default:
 479             break;
 480         }
 481 
 482         for (uint32_t i = 0; i &lt; count; ++i) {
 483             JSValue toValue = data[i].get();
 484             if (toValue &amp;&amp; toValue.isCell())
<a name="8" id="anc8"></a><span class="line-modified"> 485                 builder.appendIndexEdge(thisObject, toValue.asCell(), i);</span>
 486         }
 487     }
 488 }
 489 
 490 void JSFinalObject::visitChildren(JSCell* cell, SlotVisitor&amp; visitor)
 491 {
 492     JSFinalObject* thisObject = jsCast&lt;JSFinalObject*&gt;(cell);
 493     ASSERT_GC_OBJECT_INHERITS(thisObject, info());
 494 #if !ASSERT_DISABLED
 495     bool wasCheckingForDefaultMarkViolation = visitor.m_isCheckingForDefaultMarkViolation;
 496     visitor.m_isCheckingForDefaultMarkViolation = false;
 497 #endif
 498 
 499     JSCell::visitChildren(thisObject, visitor);
 500 
 501     if (Structure* structure = thisObject-&gt;visitButterfly(visitor)) {
 502         if (unsigned storageSize = structure-&gt;inlineSize())
 503             visitor.appendValuesHidden(thisObject-&gt;inlineStorage(), storageSize);
 504     }
 505 
 506 #if !ASSERT_DISABLED
 507     visitor.m_isCheckingForDefaultMarkViolation = wasCheckingForDefaultMarkViolation;
 508 #endif
 509 }
 510 
 511 String JSObject::className(const JSObject* object, VM&amp; vm)
 512 {
 513     const ClassInfo* info = object-&gt;classInfo(vm);
 514     ASSERT(info);
 515     return info-&gt;className;
 516 }
 517 
 518 String JSObject::toStringName(const JSObject* object, ExecState* exec)
 519 {
 520     VM&amp; vm = exec-&gt;vm();
 521     const ClassInfo* info = object-&gt;classInfo(vm);
 522     ASSERT(info);
 523     return info-&gt;className;
 524 }
 525 
 526 String JSObject::calculatedClassName(JSObject* object)
 527 {
<a name="9" id="anc9"></a><span class="line-modified"> 528     String prototypeFunctionName;</span>
<span class="line-modified"> 529     auto globalObject = object-&gt;globalObject();</span>

 530     VM&amp; vm = globalObject-&gt;vm();
 531     auto scope = DECLARE_CATCH_SCOPE(vm);
<a name="10" id="anc10"></a>
 532 
<a name="11" id="anc11"></a><span class="line-modified"> 533     ExecState* exec = globalObject-&gt;globalExec();</span>
<span class="line-modified"> 534     PropertySlot slot(object-&gt;getPrototypeDirect(vm), PropertySlot::InternalMethodType::VMInquiry);</span>
<span class="line-modified"> 535     PropertyName constructor(vm.propertyNames-&gt;constructor);</span>
<span class="line-modified"> 536     if (object-&gt;getPropertySlot(exec, constructor, slot)) {</span>
 537         EXCEPTION_ASSERT(!scope.exception());
 538         if (slot.isValue()) {
<a name="12" id="anc12"></a><span class="line-modified"> 539             JSValue constructorValue = slot.getValue(exec, constructor);</span>
<span class="line-modified"> 540             if (constructorValue.isCell()) {</span>
<span class="line-modified"> 541                 if (JSCell* constructorCell = constructorValue.asCell()) {</span>
<span class="line-modified"> 542                     if (JSObject* ctorObject = constructorCell-&gt;getObject()) {</span>
<span class="line-modified"> 543                         if (JSFunction* constructorFunction = jsDynamicCast&lt;JSFunction*&gt;(vm, ctorObject))</span>
<span class="line-modified"> 544                             prototypeFunctionName = constructorFunction-&gt;calculatedDisplayName(vm);</span>
<span class="line-modified"> 545                         else if (InternalFunction* constructorFunction = jsDynamicCast&lt;InternalFunction*&gt;(vm, ctorObject))</span>
<span class="line-modified"> 546                             prototypeFunctionName = constructorFunction-&gt;calculatedDisplayName(vm);</span>























 547                     }
 548                 }
 549             }
 550         }
 551     }
<a name="13" id="anc13"></a><span class="line-modified"> 552     EXCEPTION_ASSERT(!scope.exception() || prototypeFunctionName.isNull());</span>

 553     if (UNLIKELY(scope.exception()))
 554         scope.clearException();
 555 
<a name="14" id="anc14"></a><span class="line-modified"> 556     if (prototypeFunctionName.isNull() || prototypeFunctionName == &quot;Object&quot;) {</span>
 557         String tableClassName = object-&gt;methodTable(vm)-&gt;className(object, vm);
 558         if (!tableClassName.isNull() &amp;&amp; tableClassName != &quot;Object&quot;)
 559             return tableClassName;
 560 
 561         String classInfoName = object-&gt;classInfo(vm)-&gt;className;
 562         if (!classInfoName.isNull())
 563             return classInfoName;
 564 
<a name="15" id="anc15"></a><span class="line-modified"> 565         if (prototypeFunctionName.isNull())</span>
 566             return &quot;Object&quot;_s;
 567     }
 568 
<a name="16" id="anc16"></a><span class="line-modified"> 569     return prototypeFunctionName;</span>
 570 }
 571 
 572 bool JSObject::getOwnPropertySlotByIndex(JSObject* thisObject, ExecState* exec, unsigned i, PropertySlot&amp; slot)
 573 {
<a name="17" id="anc17"></a>

 574     // NB. The fact that we&#39;re directly consulting our indexed storage implies that it is not
 575     // legal for anyone to override getOwnPropertySlot() without also overriding
 576     // getOwnPropertySlotByIndex().
 577 
 578     if (i &gt; MAX_ARRAY_INDEX)
<a name="18" id="anc18"></a><span class="line-modified"> 579         return thisObject-&gt;methodTable(exec-&gt;vm())-&gt;getOwnPropertySlot(thisObject, exec, Identifier::from(exec, i), slot);</span>
 580 
 581     switch (thisObject-&gt;indexingType()) {
 582     case ALL_BLANK_INDEXING_TYPES:
 583     case ALL_UNDECIDED_INDEXING_TYPES:
 584         break;
 585 
 586     case ALL_INT32_INDEXING_TYPES:
 587     case ALL_CONTIGUOUS_INDEXING_TYPES: {
 588         Butterfly* butterfly = thisObject-&gt;butterfly();
 589         if (i &gt;= butterfly-&gt;vectorLength())
 590             return false;
 591 
 592         JSValue value = butterfly-&gt;contiguous().at(thisObject, i).get();
 593         if (value) {
 594             slot.setValue(thisObject, static_cast&lt;unsigned&gt;(PropertyAttribute::None), value);
 595             return true;
 596         }
 597 
 598         return false;
 599     }
 600 
 601     case ALL_DOUBLE_INDEXING_TYPES: {
 602         Butterfly* butterfly = thisObject-&gt;butterfly();
 603         if (i &gt;= butterfly-&gt;vectorLength())
 604             return false;
 605 
 606         double value = butterfly-&gt;contiguousDouble().at(thisObject, i);
 607         if (value == value) {
 608             slot.setValue(thisObject, static_cast&lt;unsigned&gt;(PropertyAttribute::None), JSValue(JSValue::EncodeAsDouble, value));
 609             return true;
 610         }
 611 
 612         return false;
 613     }
 614 
 615     case ALL_ARRAY_STORAGE_INDEXING_TYPES: {
 616         ArrayStorage* storage = thisObject-&gt;m_butterfly-&gt;arrayStorage();
 617         if (i &gt;= storage-&gt;length())
 618             return false;
 619 
 620         if (i &lt; storage-&gt;vectorLength()) {
 621             JSValue value = storage-&gt;m_vector[i].get();
 622             if (value) {
 623                 slot.setValue(thisObject, static_cast&lt;unsigned&gt;(PropertyAttribute::None), value);
 624                 return true;
 625             }
 626         } else if (SparseArrayValueMap* map = storage-&gt;m_sparseMap.get()) {
 627             SparseArrayValueMap::iterator it = map-&gt;find(i);
 628             if (it != map-&gt;notFound()) {
 629                 it-&gt;value.get(thisObject, slot);
 630                 return true;
 631             }
 632         }
 633         break;
 634     }
 635 
 636     default:
 637         RELEASE_ASSERT_NOT_REACHED();
 638         break;
 639     }
 640 
 641     return false;
 642 }
 643 
 644 // https://tc39.github.io/ecma262/#sec-ordinaryset
 645 bool ordinarySetSlow(ExecState* exec, JSObject* object, PropertyName propertyName, JSValue value, JSValue receiver, bool shouldThrow)
 646 {
 647     // If we find the receiver is not the same to the object, we fall to this slow path.
 648     // Currently, there are 3 candidates.
 649     // 1. Reflect.set can alter the receiver with an arbitrary value.
 650     // 2. Window Proxy.
 651     // 3. ES6 Proxy.
 652 
 653     VM&amp; vm = exec-&gt;vm();
 654     auto scope = DECLARE_THROW_SCOPE(vm);
 655     JSObject* current = object;
 656     PropertyDescriptor ownDescriptor;
 657     while (true) {
<a name="19" id="anc19"></a><span class="line-modified"> 658         if (current-&gt;type() == ProxyObjectType &amp;&amp; propertyName != vm.propertyNames-&gt;underscoreProto) {</span>
 659             ProxyObject* proxy = jsCast&lt;ProxyObject*&gt;(current);
 660             PutPropertySlot slot(receiver, shouldThrow);
 661             RELEASE_AND_RETURN(scope, proxy-&gt;ProxyObject::put(proxy, exec, propertyName, value, slot));
 662         }
 663 
 664         // 9.1.9.1-2 Let ownDesc be ? O.[[GetOwnProperty]](P).
 665         bool ownDescriptorFound = current-&gt;getOwnPropertyDescriptor(exec, propertyName, ownDescriptor);
 666         RETURN_IF_EXCEPTION(scope, false);
 667 
 668         if (!ownDescriptorFound) {
 669             // 9.1.9.1-3-a Let parent be ? O.[[GetPrototypeOf]]().
 670             JSValue prototype = current-&gt;getPrototype(vm, exec);
 671             RETURN_IF_EXCEPTION(scope, false);
 672 
 673             // 9.1.9.1-3-b If parent is not null, then
 674             if (!prototype.isNull()) {
 675                 // 9.1.9.1-3-b-i Return ? parent.[[Set]](P, V, Receiver).
 676                 current = asObject(prototype);
 677                 continue;
 678             }
 679             // 9.1.9.1-3-c-i Let ownDesc be the PropertyDescriptor{[[Value]]: undefined, [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true}.
 680             ownDescriptor = PropertyDescriptor(jsUndefined(), static_cast&lt;unsigned&gt;(PropertyAttribute::None));
 681         }
 682         break;
 683     }
 684 
 685     // 9.1.9.1-4 If IsDataDescriptor(ownDesc) is true, then
 686     if (ownDescriptor.isDataDescriptor()) {
 687         // 9.1.9.1-4-a If ownDesc.[[Writable]] is false, return false.
 688         if (!ownDescriptor.writable())
 689             return typeError(exec, scope, shouldThrow, ReadonlyPropertyWriteError);
 690 
 691         // 9.1.9.1-4-b If Type(Receiver) is not Object, return false.
 692         if (!receiver.isObject())
 693             return typeError(exec, scope, shouldThrow, ReadonlyPropertyWriteError);
 694 
 695         // In OrdinarySet, the receiver may not be the same to the object.
 696         // So, we perform [[GetOwnProperty]] onto the receiver while we already perform [[GetOwnProperty]] onto the object.
 697 
 698         // 9.1.9.1-4-c Let existingDescriptor be ? Receiver.[[GetOwnProperty]](P).
 699         JSObject* receiverObject = asObject(receiver);
 700         PropertyDescriptor existingDescriptor;
 701         bool existingDescriptorFound = receiverObject-&gt;getOwnPropertyDescriptor(exec, propertyName, existingDescriptor);
 702         RETURN_IF_EXCEPTION(scope, false);
 703 
 704         // 9.1.9.1-4-d If existingDescriptor is not undefined, then
 705         if (existingDescriptorFound) {
 706             // 9.1.9.1-4-d-i If IsAccessorDescriptor(existingDescriptor) is true, return false.
 707             if (existingDescriptor.isAccessorDescriptor())
 708                 return typeError(exec, scope, shouldThrow, ReadonlyPropertyWriteError);
 709 
 710             // 9.1.9.1-4-d-ii If existingDescriptor.[[Writable]] is false, return false.
 711             if (!existingDescriptor.writable())
 712                 return typeError(exec, scope, shouldThrow, ReadonlyPropertyWriteError);
 713 
 714             // 9.1.9.1-4-d-iii Let valueDesc be the PropertyDescriptor{[[Value]]: V}.
 715             PropertyDescriptor valueDescriptor;
 716             valueDescriptor.setValue(value);
 717 
 718             // 9.1.9.1-4-d-iv Return ? Receiver.[[DefineOwnProperty]](P, valueDesc).
 719             RELEASE_AND_RETURN(scope, receiverObject-&gt;methodTable(vm)-&gt;defineOwnProperty(receiverObject, exec, propertyName, valueDescriptor, shouldThrow));
 720         }
 721 
 722         // 9.1.9.1-4-e Else Receiver does not currently have a property P,
 723         // 9.1.9.1-4-e-i Return ? CreateDataProperty(Receiver, P, V).
 724         RELEASE_AND_RETURN(scope, receiverObject-&gt;methodTable(vm)-&gt;defineOwnProperty(receiverObject, exec, propertyName, PropertyDescriptor(value, static_cast&lt;unsigned&gt;(PropertyAttribute::None)), shouldThrow));
 725     }
 726 
 727     // 9.1.9.1-5 Assert: IsAccessorDescriptor(ownDesc) is true.
 728     ASSERT(ownDescriptor.isAccessorDescriptor());
 729 
 730     // 9.1.9.1-6 Let setter be ownDesc.[[Set]].
 731     // 9.1.9.1-7 If setter is undefined, return false.
 732     JSValue setter = ownDescriptor.setter();
 733     if (!setter.isObject())
 734         return typeError(exec, scope, shouldThrow, ReadonlyPropertyWriteError);
 735 
 736     // 9.1.9.1-8 Perform ? Call(setter, Receiver, &lt;&lt; V &gt;&gt;).
 737     JSObject* setterObject = asObject(setter);
 738     MarkedArgumentBuffer args;
 739     args.append(value);
 740     ASSERT(!args.hasOverflowed());
 741 
 742     CallData callData;
 743     CallType callType = setterObject-&gt;methodTable(vm)-&gt;getCallData(setterObject, callData);
 744     scope.release();
 745     call(exec, setterObject, callType, callData, receiver, args);
 746 
 747     // 9.1.9.1-9 Return true.
 748     return true;
 749 }
 750 
 751 // ECMA 8.6.2.2
 752 bool JSObject::put(JSCell* cell, ExecState* exec, PropertyName propertyName, JSValue value, PutPropertySlot&amp; slot)
 753 {
 754     return putInlineForJSObject(cell, exec, propertyName, value, slot);
 755 }
 756 
 757 bool JSObject::putInlineSlow(ExecState* exec, PropertyName propertyName, JSValue value, PutPropertySlot&amp; slot)
 758 {
 759     ASSERT(!isThisValueAltered(slot, this));
 760 
 761     VM&amp; vm = exec-&gt;vm();
 762     auto scope = DECLARE_THROW_SCOPE(vm);
 763 
 764     JSObject* obj = this;
 765     for (;;) {
<a name="20" id="anc20"></a>




 766         unsigned attributes;
<a name="21" id="anc21"></a><span class="line-modified"> 767         PropertyOffset offset = obj-&gt;structure(vm)-&gt;get(vm, propertyName, attributes);</span>
 768         if (isValidOffset(offset)) {
 769             if (attributes &amp; PropertyAttribute::ReadOnly) {
 770                 ASSERT(this-&gt;prototypeChainMayInterceptStoreTo(vm, propertyName) || obj == this);
 771                 return typeError(exec, scope, slot.isStrictMode(), ReadonlyPropertyWriteError);
 772             }
 773 
 774             JSValue gs = obj-&gt;getDirect(offset);
 775             if (gs.isGetterSetter()) {
 776                 // We need to make sure that we decide to cache this property before we potentially execute aribitrary JS.
<a name="22" id="anc22"></a><span class="line-modified"> 777                 if (!structure(vm)-&gt;isDictionary())</span>
 778                     slot.setCacheableSetter(obj, offset);
 779 
 780                 bool result = callSetter(exec, slot.thisValue(), gs, value, slot.isStrictMode() ? StrictMode : NotStrictMode);
 781                 RETURN_IF_EXCEPTION(scope, false);
 782                 return result;
 783             }
 784             if (gs.isCustomGetterSetter()) {
 785                 // We need to make sure that we decide to cache this property before we potentially execute aribitrary JS.
 786                 if (attributes &amp; PropertyAttribute::CustomAccessor)
 787                     slot.setCustomAccessor(obj, jsCast&lt;CustomGetterSetter*&gt;(gs.asCell())-&gt;setter());
 788                 else
 789                     slot.setCustomValue(obj, jsCast&lt;CustomGetterSetter*&gt;(gs.asCell())-&gt;setter());
 790 
 791                 bool result = callCustomSetter(exec, gs, attributes &amp; PropertyAttribute::CustomAccessor, obj, slot.thisValue(), value);
 792                 RETURN_IF_EXCEPTION(scope, false);
 793                 return result;
 794             }
 795             ASSERT(!(attributes &amp; PropertyAttribute::Accessor));
 796 
<a name="23" id="anc23"></a><span class="line-modified"> 797             // If there&#39;s an existing property on the object or one of its</span>
<span class="line-modified"> 798             // prototypes it should be replaced, so break here.</span>
 799             break;
 800         }
 801         if (!obj-&gt;staticPropertiesReified(vm)) {
 802             if (obj-&gt;classInfo(vm)-&gt;hasStaticSetterOrReadonlyProperties()) {
 803                 if (auto entry = obj-&gt;findPropertyHashEntry(vm, propertyName))
 804                     RELEASE_AND_RETURN(scope, putEntry(exec, entry-&gt;table-&gt;classForThis, entry-&gt;value, obj, this, propertyName, value, slot));
 805             }
 806         }
<a name="24" id="anc24"></a><span class="line-modified"> 807         if (obj-&gt;type() == ProxyObjectType &amp;&amp; propertyName != vm.propertyNames-&gt;underscoreProto) {</span>
 808             // FIXME: We shouldn&#39;t unconditionally perform [[Set]] here.
 809             // We need to do more because this is observable behavior.
 810             // https://bugs.webkit.org/show_bug.cgi?id=155012
 811             ProxyObject* proxy = jsCast&lt;ProxyObject*&gt;(obj);
 812             RELEASE_AND_RETURN(scope, proxy-&gt;ProxyObject::put(proxy, exec, propertyName, value, slot));
 813         }
 814         JSValue prototype = obj-&gt;getPrototype(vm, exec);
 815         RETURN_IF_EXCEPTION(scope, false);
 816         if (prototype.isNull())
 817             break;
 818         obj = asObject(prototype);
 819     }
 820 
 821     if (!putDirectInternal&lt;PutModePut&gt;(vm, propertyName, value, 0, slot))
 822         return typeError(exec, scope, slot.isStrictMode(), ReadonlyPropertyWriteError);
 823     return true;
 824 }
 825 
 826 bool JSObject::putByIndex(JSCell* cell, ExecState* exec, unsigned propertyName, JSValue value, bool shouldThrow)
 827 {
 828     VM&amp; vm = exec-&gt;vm();
 829     JSObject* thisObject = jsCast&lt;JSObject*&gt;(cell);
 830 
 831     if (propertyName &gt; MAX_ARRAY_INDEX) {
 832         PutPropertySlot slot(cell, shouldThrow);
<a name="25" id="anc25"></a><span class="line-modified"> 833         return thisObject-&gt;methodTable(vm)-&gt;put(thisObject, exec, Identifier::from(exec, propertyName), value, slot);</span>
 834     }
 835 
 836     thisObject-&gt;ensureWritable(vm);
 837 
 838     switch (thisObject-&gt;indexingType()) {
 839     case ALL_BLANK_INDEXING_TYPES:
 840         break;
 841 
 842     case ALL_UNDECIDED_INDEXING_TYPES: {
 843         thisObject-&gt;convertUndecidedForValue(vm, value);
 844         // Reloop.
 845         return putByIndex(cell, exec, propertyName, value, shouldThrow);
 846     }
 847 
 848     case ALL_INT32_INDEXING_TYPES: {
 849         if (!value.isInt32()) {
 850             thisObject-&gt;convertInt32ForValue(vm, value);
 851             return putByIndex(cell, exec, propertyName, value, shouldThrow);
 852         }
 853         FALLTHROUGH;
 854     }
 855 
 856     case ALL_CONTIGUOUS_INDEXING_TYPES: {
 857         Butterfly* butterfly = thisObject-&gt;butterfly();
 858         if (propertyName &gt;= butterfly-&gt;vectorLength())
 859             break;
 860         butterfly-&gt;contiguous().at(thisObject, propertyName).set(vm, thisObject, value);
 861         if (propertyName &gt;= butterfly-&gt;publicLength())
 862             butterfly-&gt;setPublicLength(propertyName + 1);
 863         return true;
 864     }
 865 
 866     case ALL_DOUBLE_INDEXING_TYPES: {
 867         if (!value.isNumber()) {
 868             thisObject-&gt;convertDoubleToContiguous(vm);
 869             // Reloop.
 870             return putByIndex(cell, exec, propertyName, value, shouldThrow);
 871         }
 872 
 873         double valueAsDouble = value.asNumber();
 874         if (valueAsDouble != valueAsDouble) {
 875             thisObject-&gt;convertDoubleToContiguous(vm);
 876             // Reloop.
 877             return putByIndex(cell, exec, propertyName, value, shouldThrow);
 878         }
 879         Butterfly* butterfly = thisObject-&gt;butterfly();
 880         if (propertyName &gt;= butterfly-&gt;vectorLength())
 881             break;
 882         butterfly-&gt;contiguousDouble().at(thisObject, propertyName) = valueAsDouble;
 883         if (propertyName &gt;= butterfly-&gt;publicLength())
 884             butterfly-&gt;setPublicLength(propertyName + 1);
 885         return true;
 886     }
 887 
 888     case NonArrayWithArrayStorage:
 889     case ArrayWithArrayStorage: {
 890         ArrayStorage* storage = thisObject-&gt;m_butterfly-&gt;arrayStorage();
 891 
 892         if (propertyName &gt;= storage-&gt;vectorLength())
 893             break;
 894 
 895         WriteBarrier&lt;Unknown&gt;&amp; valueSlot = storage-&gt;m_vector[propertyName];
 896         unsigned length = storage-&gt;length();
 897 
 898         // Update length &amp; m_numValuesInVector as necessary.
 899         if (propertyName &gt;= length) {
 900             length = propertyName + 1;
 901             storage-&gt;setLength(length);
 902             ++storage-&gt;m_numValuesInVector;
 903         } else if (!valueSlot)
 904             ++storage-&gt;m_numValuesInVector;
 905 
 906         valueSlot.set(vm, thisObject, value);
 907         return true;
 908     }
 909 
 910     case NonArrayWithSlowPutArrayStorage:
 911     case ArrayWithSlowPutArrayStorage: {
 912         ArrayStorage* storage = thisObject-&gt;m_butterfly-&gt;arrayStorage();
 913 
 914         if (propertyName &gt;= storage-&gt;vectorLength())
 915             break;
 916 
 917         WriteBarrier&lt;Unknown&gt;&amp; valueSlot = storage-&gt;m_vector[propertyName];
 918         unsigned length = storage-&gt;length();
 919 
<a name="26" id="anc26"></a>

 920         // Update length &amp; m_numValuesInVector as necessary.
 921         if (propertyName &gt;= length) {
 922             bool putResult = false;
<a name="27" id="anc27"></a><span class="line-modified"> 923             if (thisObject-&gt;attemptToInterceptPutByIndexOnHole(exec, propertyName, value, shouldThrow, putResult))</span>


 924                 return putResult;
 925             length = propertyName + 1;
 926             storage-&gt;setLength(length);
 927             ++storage-&gt;m_numValuesInVector;
 928         } else if (!valueSlot) {
 929             bool putResult = false;
<a name="28" id="anc28"></a><span class="line-modified"> 930             if (thisObject-&gt;attemptToInterceptPutByIndexOnHole(exec, propertyName, value, shouldThrow, putResult))</span>


 931                 return putResult;
 932             ++storage-&gt;m_numValuesInVector;
 933         }
 934 
 935         valueSlot.set(vm, thisObject, value);
 936         return true;
 937     }
 938 
 939     default:
 940         RELEASE_ASSERT_NOT_REACHED();
 941     }
 942 
 943     return thisObject-&gt;putByIndexBeyondVectorLength(exec, propertyName, value, shouldThrow);
 944 }
 945 
 946 ArrayStorage* JSObject::enterDictionaryIndexingModeWhenArrayStorageAlreadyExists(VM&amp; vm, ArrayStorage* storage)
 947 {
 948     SparseArrayValueMap* map = storage-&gt;m_sparseMap.get();
 949 
 950     if (!map)
 951         map = allocateSparseIndexMap(vm);
 952 
 953     if (map-&gt;sparseMode())
 954         return storage;
 955 
 956     map-&gt;setSparseMode();
 957 
 958     unsigned usedVectorLength = std::min(storage-&gt;length(), storage-&gt;vectorLength());
 959     for (unsigned i = 0; i &lt; usedVectorLength; ++i) {
 960         JSValue value = storage-&gt;m_vector[i].get();
 961         // This will always be a new entry in the map, so no need to check we can write,
 962         // and attributes are default so no need to set them.
 963         if (value)
 964             map-&gt;add(this, i).iterator-&gt;value.forceSet(vm, map, value, 0);
 965     }
 966 
 967     DeferGC deferGC(vm.heap);
 968     Butterfly* newButterfly = storage-&gt;butterfly()-&gt;resizeArray(vm, this, structure(vm), 0, ArrayStorage::sizeFor(0));
 969     RELEASE_ASSERT(newButterfly);
 970     newButterfly-&gt;arrayStorage()-&gt;m_indexBias = 0;
 971     newButterfly-&gt;arrayStorage()-&gt;setVectorLength(0);
 972     newButterfly-&gt;arrayStorage()-&gt;m_sparseMap.set(vm, this, map);
 973     setButterfly(vm, newButterfly);
 974 
 975     return newButterfly-&gt;arrayStorage();
 976 }
 977 
 978 void JSObject::enterDictionaryIndexingMode(VM&amp; vm)
 979 {
 980     switch (indexingType()) {
 981     case ALL_BLANK_INDEXING_TYPES:
 982     case ALL_UNDECIDED_INDEXING_TYPES:
 983     case ALL_INT32_INDEXING_TYPES:
 984     case ALL_DOUBLE_INDEXING_TYPES:
 985     case ALL_CONTIGUOUS_INDEXING_TYPES:
 986         // NOTE: this is horribly inefficient, as it will perform two conversions. We could optimize
 987         // this case if we ever cared. Note that ensureArrayStorage() can return null if the object
 988         // doesn&#39;t support traditional indexed properties. At the time of writing, this just affects
 989         // typed arrays.
 990         if (ArrayStorage* storage = ensureArrayStorageSlow(vm))
 991             enterDictionaryIndexingModeWhenArrayStorageAlreadyExists(vm, storage);
 992         break;
 993     case ALL_ARRAY_STORAGE_INDEXING_TYPES:
 994         enterDictionaryIndexingModeWhenArrayStorageAlreadyExists(vm, m_butterfly-&gt;arrayStorage());
 995         break;
 996 
 997     default:
 998         break;
 999     }
1000 }
1001 
1002 void JSObject::notifyPresenceOfIndexedAccessors(VM&amp; vm)
1003 {
1004     if (mayInterceptIndexedAccesses(vm))
1005         return;
1006 
1007     setStructure(vm, Structure::nonPropertyTransition(vm, structure(vm), NonPropertyTransition::AddIndexedAccessors));
1008 
1009     if (!mayBePrototype())
1010         return;
1011 
1012     globalObject(vm)-&gt;haveABadTime(vm);
1013 }
1014 
1015 Butterfly* JSObject::createInitialIndexedStorage(VM&amp; vm, unsigned length)
1016 {
1017     ASSERT(length &lt;= MAX_STORAGE_VECTOR_LENGTH);
1018     IndexingType oldType = indexingType();
1019     ASSERT_UNUSED(oldType, !hasIndexedProperties(oldType));
1020     ASSERT(!needsSlowPutIndexing(vm));
1021     ASSERT(!indexingShouldBeSparse(vm));
1022     Structure* structure = this-&gt;structure(vm);
1023     unsigned propertyCapacity = structure-&gt;outOfLineCapacity();
1024     unsigned vectorLength = Butterfly::optimalContiguousVectorLength(propertyCapacity, length);
1025     Butterfly* newButterfly = Butterfly::createOrGrowArrayRight(
1026         butterfly(), vm, this, structure, propertyCapacity, false, 0,
1027         sizeof(EncodedJSValue) * vectorLength);
1028     newButterfly-&gt;setPublicLength(length);
1029     newButterfly-&gt;setVectorLength(vectorLength);
1030     return newButterfly;
1031 }
1032 
1033 Butterfly* JSObject::createInitialUndecided(VM&amp; vm, unsigned length)
1034 {
1035     DeferGC deferGC(vm.heap);
1036     Butterfly* newButterfly = createInitialIndexedStorage(vm, length);
1037     StructureID oldStructureID = this-&gt;structureID();
1038     Structure* oldStructure = vm.getStructure(oldStructureID);
1039     Structure* newStructure = Structure::nonPropertyTransition(vm, oldStructure, NonPropertyTransition::AllocateUndecided);
1040     nukeStructureAndSetButterfly(vm, oldStructureID, newButterfly);
1041     setStructure(vm, newStructure);
1042     return newButterfly;
1043 }
1044 
1045 ContiguousJSValues JSObject::createInitialInt32(VM&amp; vm, unsigned length)
1046 {
1047     DeferGC deferGC(vm.heap);
1048     Butterfly* newButterfly = createInitialIndexedStorage(vm, length);
1049     for (unsigned i = newButterfly-&gt;vectorLength(); i--;)
1050         newButterfly-&gt;contiguous().at(this, i).setWithoutWriteBarrier(JSValue());
1051     StructureID oldStructureID = this-&gt;structureID();
1052     Structure* oldStructure = vm.getStructure(oldStructureID);
1053     Structure* newStructure = Structure::nonPropertyTransition(vm, oldStructure, NonPropertyTransition::AllocateInt32);
1054     nukeStructureAndSetButterfly(vm, oldStructureID, newButterfly);
1055     setStructure(vm, newStructure);
1056     return newButterfly-&gt;contiguousInt32();
1057 }
1058 
1059 ContiguousDoubles JSObject::createInitialDouble(VM&amp; vm, unsigned length)
1060 {
1061     DeferGC deferGC(vm.heap);
1062     Butterfly* newButterfly = createInitialIndexedStorage(vm, length);
1063     for (unsigned i = newButterfly-&gt;vectorLength(); i--;)
1064         newButterfly-&gt;contiguousDouble().at(this, i) = PNaN;
1065     StructureID oldStructureID = this-&gt;structureID();
1066     Structure* oldStructure = vm.getStructure(oldStructureID);
1067     Structure* newStructure = Structure::nonPropertyTransition(vm, oldStructure, NonPropertyTransition::AllocateDouble);
1068     nukeStructureAndSetButterfly(vm, oldStructureID, newButterfly);
1069     setStructure(vm, newStructure);
1070     return newButterfly-&gt;contiguousDouble();
1071 }
1072 
1073 ContiguousJSValues JSObject::createInitialContiguous(VM&amp; vm, unsigned length)
1074 {
1075     DeferGC deferGC(vm.heap);
1076     Butterfly* newButterfly = createInitialIndexedStorage(vm, length);
1077     for (unsigned i = newButterfly-&gt;vectorLength(); i--;)
1078         newButterfly-&gt;contiguous().at(this, i).setWithoutWriteBarrier(JSValue());
1079     StructureID oldStructureID = this-&gt;structureID();
1080     Structure* oldStructure = vm.getStructure(oldStructureID);
1081     Structure* newStructure = Structure::nonPropertyTransition(vm, oldStructure, NonPropertyTransition::AllocateContiguous);
1082     nukeStructureAndSetButterfly(vm, oldStructureID, newButterfly);
1083     setStructure(vm, newStructure);
1084     return newButterfly-&gt;contiguous();
1085 }
1086 
1087 Butterfly* JSObject::createArrayStorageButterfly(VM&amp; vm, JSObject* intendedOwner, Structure* structure, unsigned length, unsigned vectorLength, Butterfly* oldButterfly)
1088 {
1089     Butterfly* newButterfly = Butterfly::createOrGrowArrayRight(
1090         oldButterfly, vm, intendedOwner, structure, structure-&gt;outOfLineCapacity(), false, 0,
1091         ArrayStorage::sizeFor(vectorLength));
1092     RELEASE_ASSERT(newButterfly);
1093 
1094     ArrayStorage* result = newButterfly-&gt;arrayStorage();
1095     result-&gt;setLength(length);
1096     result-&gt;setVectorLength(vectorLength);
1097     result-&gt;m_sparseMap.clear();
1098     result-&gt;m_numValuesInVector = 0;
1099     result-&gt;m_indexBias = 0;
1100     for (size_t i = vectorLength; i--;)
1101         result-&gt;m_vector[i].setWithoutWriteBarrier(JSValue());
1102 
1103     return newButterfly;
1104 }
1105 
1106 ArrayStorage* JSObject::createArrayStorage(VM&amp; vm, unsigned length, unsigned vectorLength)
1107 {
1108     DeferGC deferGC(vm.heap);
1109     StructureID oldStructureID = this-&gt;structureID();
1110     Structure* oldStructure = vm.getStructure(oldStructureID);
1111     IndexingType oldType = indexingType();
1112     ASSERT_UNUSED(oldType, !hasIndexedProperties(oldType));
1113 
1114     Butterfly* newButterfly = createArrayStorageButterfly(vm, this, oldStructure, length, vectorLength, butterfly());
1115     ArrayStorage* result = newButterfly-&gt;arrayStorage();
1116     Structure* newStructure = Structure::nonPropertyTransition(vm, oldStructure, suggestedArrayStorageTransition(vm));
1117     nukeStructureAndSetButterfly(vm, oldStructureID, newButterfly);
1118     setStructure(vm, newStructure);
1119     return result;
1120 }
1121 
1122 ArrayStorage* JSObject::createInitialArrayStorage(VM&amp; vm)
1123 {
1124     return createArrayStorage(
1125         vm, 0, ArrayStorage::optimalVectorLength(0, structure(vm)-&gt;outOfLineCapacity(), 0));
1126 }
1127 
1128 ContiguousJSValues JSObject::convertUndecidedToInt32(VM&amp; vm)
1129 {
1130     ASSERT(hasUndecided(indexingType()));
1131 
1132     Butterfly* butterfly = this-&gt;butterfly();
1133     for (unsigned i = butterfly-&gt;vectorLength(); i--;)
1134         butterfly-&gt;contiguous().at(this, i).setWithoutWriteBarrier(JSValue());
1135 
1136     setStructure(vm, Structure::nonPropertyTransition(vm, structure(vm), NonPropertyTransition::AllocateInt32));
1137     return m_butterfly-&gt;contiguousInt32();
1138 }
1139 
1140 ContiguousDoubles JSObject::convertUndecidedToDouble(VM&amp; vm)
1141 {
1142     ASSERT(hasUndecided(indexingType()));
1143 
1144     Butterfly* butterfly = m_butterfly.get();
1145     for (unsigned i = butterfly-&gt;vectorLength(); i--;)
1146         butterfly-&gt;contiguousDouble().at(this, i) = PNaN;
1147 
1148     setStructure(vm, Structure::nonPropertyTransition(vm, structure(vm), NonPropertyTransition::AllocateDouble));
1149     return m_butterfly-&gt;contiguousDouble();
1150 }
1151 
1152 ContiguousJSValues JSObject::convertUndecidedToContiguous(VM&amp; vm)
1153 {
1154     ASSERT(hasUndecided(indexingType()));
1155 
1156     Butterfly* butterfly = m_butterfly.get();
1157     for (unsigned i = butterfly-&gt;vectorLength(); i--;)
1158         butterfly-&gt;contiguous().at(this, i).setWithoutWriteBarrier(JSValue());
1159 
1160     WTF::storeStoreFence();
1161     setStructure(vm, Structure::nonPropertyTransition(vm, structure(vm), NonPropertyTransition::AllocateContiguous));
1162     return m_butterfly-&gt;contiguous();
1163 }
1164 
1165 ArrayStorage* JSObject::constructConvertedArrayStorageWithoutCopyingElements(VM&amp; vm, unsigned neededLength)
1166 {
1167     Structure* structure = this-&gt;structure(vm);
1168     unsigned publicLength = m_butterfly-&gt;publicLength();
1169     unsigned propertyCapacity = structure-&gt;outOfLineCapacity();
1170 
1171     Butterfly* newButterfly = Butterfly::createUninitialized(vm, this, 0, propertyCapacity, true, ArrayStorage::sizeFor(neededLength));
1172 
1173     memcpy(
1174         newButterfly-&gt;base(0, propertyCapacity),
1175         m_butterfly-&gt;base(0, propertyCapacity),
1176         propertyCapacity * sizeof(EncodedJSValue));
1177 
1178     ArrayStorage* newStorage = newButterfly-&gt;arrayStorage();
1179     newStorage-&gt;setVectorLength(neededLength);
1180     newStorage-&gt;setLength(publicLength);
1181     newStorage-&gt;m_sparseMap.clear();
1182     newStorage-&gt;m_indexBias = 0;
1183     newStorage-&gt;m_numValuesInVector = 0;
1184 
1185     return newStorage;
1186 }
1187 
1188 ArrayStorage* JSObject::convertUndecidedToArrayStorage(VM&amp; vm, NonPropertyTransition transition)
1189 {
1190     DeferGC deferGC(vm.heap);
1191     ASSERT(hasUndecided(indexingType()));
1192 
1193     unsigned vectorLength = m_butterfly-&gt;vectorLength();
1194     ArrayStorage* storage = constructConvertedArrayStorageWithoutCopyingElements(vm, vectorLength);
1195 
1196     for (unsigned i = vectorLength; i--;)
1197         storage-&gt;m_vector[i].setWithoutWriteBarrier(JSValue());
1198 
1199     StructureID oldStructureID = this-&gt;structureID();
1200     Structure* oldStructure = vm.getStructure(oldStructureID);
1201     Structure* newStructure = Structure::nonPropertyTransition(vm, oldStructure, transition);
1202     nukeStructureAndSetButterfly(vm, oldStructureID, storage-&gt;butterfly());
1203     setStructure(vm, newStructure);
1204     return storage;
1205 }
1206 
1207 ArrayStorage* JSObject::convertUndecidedToArrayStorage(VM&amp; vm)
1208 {
1209     return convertUndecidedToArrayStorage(vm, suggestedArrayStorageTransition(vm));
1210 }
1211 
1212 ContiguousDoubles JSObject::convertInt32ToDouble(VM&amp; vm)
1213 {
1214     ASSERT(hasInt32(indexingType()));
1215     ASSERT(!isCopyOnWrite(indexingMode()));
1216 
1217     Butterfly* butterfly = m_butterfly.get();
1218     for (unsigned i = butterfly-&gt;vectorLength(); i--;) {
1219         WriteBarrier&lt;Unknown&gt;* current = &amp;butterfly-&gt;contiguous().atUnsafe(i);
1220         double* currentAsDouble = bitwise_cast&lt;double*&gt;(current);
1221         JSValue v = current-&gt;get();
1222         // NOTE: Since this may be used during initialization, v could be garbage. If it&#39;s garbage,
1223         // that means it will be overwritten later.
1224         if (!v.isInt32()) {
1225             *currentAsDouble = PNaN;
1226             continue;
1227         }
1228         *currentAsDouble = v.asInt32();
1229     }
1230 
1231     setStructure(vm, Structure::nonPropertyTransition(vm, structure(vm), NonPropertyTransition::AllocateDouble));
1232     return m_butterfly-&gt;contiguousDouble();
1233 }
1234 
1235 ContiguousJSValues JSObject::convertInt32ToContiguous(VM&amp; vm)
1236 {
1237     ASSERT(hasInt32(indexingType()));
1238 
1239     setStructure(vm, Structure::nonPropertyTransition(vm, structure(vm), NonPropertyTransition::AllocateContiguous));
1240     return m_butterfly-&gt;contiguous();
1241 }
1242 
1243 ArrayStorage* JSObject::convertInt32ToArrayStorage(VM&amp; vm, NonPropertyTransition transition)
1244 {
1245     DeferGC deferGC(vm.heap);
1246     ASSERT(hasInt32(indexingType()));
1247 
1248     unsigned vectorLength = m_butterfly-&gt;vectorLength();
1249     ArrayStorage* newStorage = constructConvertedArrayStorageWithoutCopyingElements(vm, vectorLength);
1250     Butterfly* butterfly = m_butterfly.get();
1251     for (unsigned i = 0; i &lt; vectorLength; i++) {
1252         JSValue v = butterfly-&gt;contiguous().at(this, i).get();
1253         newStorage-&gt;m_vector[i].setWithoutWriteBarrier(v);
1254         if (v)
1255             newStorage-&gt;m_numValuesInVector++;
1256     }
1257 
1258     StructureID oldStructureID = this-&gt;structureID();
1259     Structure* oldStructure = vm.getStructure(oldStructureID);
1260     Structure* newStructure = Structure::nonPropertyTransition(vm, oldStructure, transition);
1261     nukeStructureAndSetButterfly(vm, oldStructureID, newStorage-&gt;butterfly());
1262     setStructure(vm, newStructure);
1263     return newStorage;
1264 }
1265 
1266 ArrayStorage* JSObject::convertInt32ToArrayStorage(VM&amp; vm)
1267 {
1268     return convertInt32ToArrayStorage(vm, suggestedArrayStorageTransition(vm));
1269 }
1270 
1271 ContiguousJSValues JSObject::convertDoubleToContiguous(VM&amp; vm)
1272 {
1273     ASSERT(hasDouble(indexingType()));
1274     ASSERT(!isCopyOnWrite(indexingMode()));
1275 
1276     Butterfly* butterfly = m_butterfly.get();
1277     for (unsigned i = butterfly-&gt;vectorLength(); i--;) {
1278         double* current = &amp;butterfly-&gt;contiguousDouble().atUnsafe(i);
1279         WriteBarrier&lt;Unknown&gt;* currentAsValue = bitwise_cast&lt;WriteBarrier&lt;Unknown&gt;*&gt;(current);
1280         double value = *current;
1281         if (value != value) {
1282             currentAsValue-&gt;clear();
1283             continue;
1284         }
1285         JSValue v = JSValue(JSValue::EncodeAsDouble, value);
1286         currentAsValue-&gt;setWithoutWriteBarrier(v);
1287     }
1288 
1289     WTF::storeStoreFence();
1290     setStructure(vm, Structure::nonPropertyTransition(vm, structure(vm), NonPropertyTransition::AllocateContiguous));
1291     return m_butterfly-&gt;contiguous();
1292 }
1293 
1294 ArrayStorage* JSObject::convertDoubleToArrayStorage(VM&amp; vm, NonPropertyTransition transition)
1295 {
1296     DeferGC deferGC(vm.heap);
1297     ASSERT(hasDouble(indexingType()));
1298 
1299     unsigned vectorLength = m_butterfly-&gt;vectorLength();
1300     ArrayStorage* newStorage = constructConvertedArrayStorageWithoutCopyingElements(vm, vectorLength);
1301     Butterfly* butterfly = m_butterfly.get();
1302     for (unsigned i = 0; i &lt; vectorLength; i++) {
1303         double value = butterfly-&gt;contiguousDouble().at(this, i);
1304         if (value != value) {
1305             newStorage-&gt;m_vector[i].clear();
1306             continue;
1307         }
1308         newStorage-&gt;m_vector[i].setWithoutWriteBarrier(JSValue(JSValue::EncodeAsDouble, value));
1309         newStorage-&gt;m_numValuesInVector++;
1310     }
1311 
1312     StructureID oldStructureID = this-&gt;structureID();
1313     Structure* oldStructure = vm.getStructure(oldStructureID);
1314     Structure* newStructure = Structure::nonPropertyTransition(vm, oldStructure, transition);
1315     nukeStructureAndSetButterfly(vm, oldStructureID, newStorage-&gt;butterfly());
1316     setStructure(vm, newStructure);
1317     return newStorage;
1318 }
1319 
1320 ArrayStorage* JSObject::convertDoubleToArrayStorage(VM&amp; vm)
1321 {
1322     return convertDoubleToArrayStorage(vm, suggestedArrayStorageTransition(vm));
1323 }
1324 
1325 ArrayStorage* JSObject::convertContiguousToArrayStorage(VM&amp; vm, NonPropertyTransition transition)
1326 {
1327     DeferGC deferGC(vm.heap);
1328     ASSERT(hasContiguous(indexingType()));
1329 
1330     unsigned vectorLength = m_butterfly-&gt;vectorLength();
1331     ArrayStorage* newStorage = constructConvertedArrayStorageWithoutCopyingElements(vm, vectorLength);
1332     Butterfly* butterfly = m_butterfly.get();
1333     for (unsigned i = 0; i &lt; vectorLength; i++) {
1334         JSValue v = butterfly-&gt;contiguous().at(this, i).get();
1335         newStorage-&gt;m_vector[i].setWithoutWriteBarrier(v);
1336         if (v)
1337             newStorage-&gt;m_numValuesInVector++;
1338     }
1339 
1340     // While we modify the butterfly of Contiguous Array, we do not take any cellLock here. This is because
1341     // (1) the old butterfly is not changed and (2) new butterfly is not changed after it is exposed to
1342     // the collector.
1343     // The mutator performs the following operations are sequentially executed by using storeStoreFence.
1344     //
1345     //     CreateNewButterfly NukeStructure ChangeButterfly PutNewStructure
1346     //
1347     // Meanwhile the collector performs the following steps sequentially:
1348     //
1349     //     ReadStructureEarly ReadButterfly ReadStructureLate
1350     //
1351     // We list up all the patterns by writing a tiny script, and ensure all the cases are categorized into BEFORE, AFTER, and IGNORE.
1352     //
1353     // CreateNewButterfly NukeStructure ChangeButterfly PutNewStructure ReadStructureEarly ReadButterfly ReadStructureLate: AFTER, trivially
1354     // CreateNewButterfly NukeStructure ChangeButterfly ReadStructureEarly PutNewStructure ReadButterfly ReadStructureLate: IGNORE, because nuked structure read early
1355     // CreateNewButterfly NukeStructure ChangeButterfly ReadStructureEarly ReadButterfly PutNewStructure ReadStructureLate: IGNORE, because nuked structure read early
1356     // CreateNewButterfly NukeStructure ChangeButterfly ReadStructureEarly ReadButterfly ReadStructureLate PutNewStructure: IGNORE, because nuked structure read early
1357     // CreateNewButterfly NukeStructure ReadStructureEarly ChangeButterfly PutNewStructure ReadButterfly ReadStructureLate: IGNORE, because nuked structure read early
1358     // CreateNewButterfly NukeStructure ReadStructureEarly ChangeButterfly ReadButterfly PutNewStructure ReadStructureLate: IGNORE, because nuked structure read early
1359     // CreateNewButterfly NukeStructure ReadStructureEarly ChangeButterfly ReadButterfly ReadStructureLate PutNewStructure: IGNORE, because nuked structure read early
1360     // CreateNewButterfly NukeStructure ReadStructureEarly ReadButterfly ChangeButterfly PutNewStructure ReadStructureLate: IGNORE, because nuked structure read early
1361     // CreateNewButterfly NukeStructure ReadStructureEarly ReadButterfly ChangeButterfly ReadStructureLate PutNewStructure: IGNORE, because nuked structure read early
1362     // CreateNewButterfly NukeStructure ReadStructureEarly ReadButterfly ReadStructureLate ChangeButterfly PutNewStructure: IGNORE, because nuked structure read early
1363     // CreateNewButterfly ReadStructureEarly NukeStructure ChangeButterfly PutNewStructure ReadButterfly ReadStructureLate: IGNORE, because early and late structures don&#39;t match
1364     // CreateNewButterfly ReadStructureEarly NukeStructure ChangeButterfly ReadButterfly PutNewStructure ReadStructureLate: IGNORE, because early and late structures don&#39;t match
1365     // CreateNewButterfly ReadStructureEarly NukeStructure ChangeButterfly ReadButterfly ReadStructureLate PutNewStructure: IGNORE, because nuked structure read late
1366     // CreateNewButterfly ReadStructureEarly NukeStructure ReadButterfly ChangeButterfly PutNewStructure ReadStructureLate: IGNORE, because early and late structures don&#39;t match
1367     // CreateNewButterfly ReadStructureEarly NukeStructure ReadButterfly ChangeButterfly ReadStructureLate PutNewStructure: IGNORE, because nuked structure read late
1368     // CreateNewButterfly ReadStructureEarly NukeStructure ReadButterfly ReadStructureLate ChangeButterfly PutNewStructure: IGNORE, because nuked structure read late
1369     // CreateNewButterfly ReadStructureEarly ReadButterfly NukeStructure ChangeButterfly PutNewStructure ReadStructureLate: IGNORE, because early and late structures don&#39;t match
1370     // CreateNewButterfly ReadStructureEarly ReadButterfly NukeStructure ChangeButterfly ReadStructureLate PutNewStructure: IGNORE, because nuked structure read late
1371     // CreateNewButterfly ReadStructureEarly ReadButterfly NukeStructure ReadStructureLate ChangeButterfly PutNewStructure: IGNORE, because nuked structure read late
1372     // CreateNewButterfly ReadStructureEarly ReadButterfly ReadStructureLate NukeStructure ChangeButterfly PutNewStructure: BEFORE, trivially.
1373     // ReadStructureEarly CreateNewButterfly NukeStructure ChangeButterfly PutNewStructure ReadButterfly ReadStructureLate: IGNORE, because early and late structures don&#39;t match
1374     // ReadStructureEarly CreateNewButterfly NukeStructure ChangeButterfly ReadButterfly PutNewStructure ReadStructureLate: IGNORE, because early and late structures don&#39;t match
1375     // ReadStructureEarly CreateNewButterfly NukeStructure ChangeButterfly ReadButterfly ReadStructureLate PutNewStructure: IGNORE, because nuked structure read late
1376     // ReadStructureEarly CreateNewButterfly NukeStructure ReadButterfly ChangeButterfly PutNewStructure ReadStructureLate: IGNORE, because early and late structures don&#39;t match
1377     // ReadStructureEarly CreateNewButterfly NukeStructure ReadButterfly ChangeButterfly ReadStructureLate PutNewStructure: IGNORE, because nuked structure read late
1378     // ReadStructureEarly CreateNewButterfly NukeStructure ReadButterfly ReadStructureLate ChangeButterfly PutNewStructure: IGNORE, because nuked structure read late
1379     // ReadStructureEarly CreateNewButterfly ReadButterfly NukeStructure ChangeButterfly PutNewStructure ReadStructureLate: IGNORE, because early and late structures don&#39;t match
1380     // ReadStructureEarly CreateNewButterfly ReadButterfly NukeStructure ChangeButterfly ReadStructureLate PutNewStructure: IGNORE, because nuked structure read late
1381     // ReadStructureEarly CreateNewButterfly ReadButterfly NukeStructure ReadStructureLate ChangeButterfly PutNewStructure: IGNORE, because nuked structure read late
1382     // ReadStructureEarly CreateNewButterfly ReadButterfly ReadStructureLate NukeStructure ChangeButterfly PutNewStructure: BEFORE, CreateNewButterfly is not visible to collector.
1383     // ReadStructureEarly ReadButterfly CreateNewButterfly NukeStructure ChangeButterfly PutNewStructure ReadStructureLate: IGNORE, because early and late structures don&#39;t match
1384     // ReadStructureEarly ReadButterfly CreateNewButterfly NukeStructure ChangeButterfly ReadStructureLate PutNewStructure: IGNORE, because nuked structure read late
1385     // ReadStructureEarly ReadButterfly CreateNewButterfly NukeStructure ReadStructureLate ChangeButterfly PutNewStructure: IGNORE, because nuked structure read late
1386     // ReadStructureEarly ReadButterfly CreateNewButterfly ReadStructureLate NukeStructure ChangeButterfly PutNewStructure: BEFORE, CreateNewButterfly is not visible to collector.
1387     // ReadStructureEarly ReadButterfly ReadStructureLate CreateNewButterfly NukeStructure ChangeButterfly PutNewStructure: BEFORE, trivially.
1388 
1389     ASSERT(newStorage-&gt;butterfly() != butterfly);
1390     StructureID oldStructureID = this-&gt;structureID();
1391     Structure* oldStructure = vm.getStructure(oldStructureID);
1392     Structure* newStructure = Structure::nonPropertyTransition(vm, oldStructure, transition);
1393 
1394     // Ensure new Butterfly initialization is correctly done before exposing it to the concurrent threads.
1395     if (isX86() || vm.heap.mutatorShouldBeFenced())
1396         WTF::storeStoreFence();
1397     nukeStructureAndSetButterfly(vm, oldStructureID, newStorage-&gt;butterfly());
1398     setStructure(vm, newStructure);
1399 
1400     return newStorage;
1401 }
1402 
1403 ArrayStorage* JSObject::convertContiguousToArrayStorage(VM&amp; vm)
1404 {
1405     return convertContiguousToArrayStorage(vm, suggestedArrayStorageTransition(vm));
1406 }
1407 
1408 void JSObject::convertUndecidedForValue(VM&amp; vm, JSValue value)
1409 {
1410     IndexingType type = indexingTypeForValue(value);
1411     if (type == Int32Shape) {
1412         convertUndecidedToInt32(vm);
1413         return;
1414     }
1415 
1416     if (type == DoubleShape) {
1417         convertUndecidedToDouble(vm);
1418         return;
1419     }
1420 
1421     ASSERT(type == ContiguousShape);
1422     convertUndecidedToContiguous(vm);
1423 }
1424 
1425 void JSObject::createInitialForValueAndSet(VM&amp; vm, unsigned index, JSValue value)
1426 {
1427     if (value.isInt32()) {
1428         createInitialInt32(vm, index + 1).at(this, index).set(vm, this, value);
1429         return;
1430     }
1431 
1432     if (value.isDouble()) {
1433         double doubleValue = value.asNumber();
1434         if (doubleValue == doubleValue) {
1435             createInitialDouble(vm, index + 1).at(this, index) = doubleValue;
1436             return;
1437         }
1438     }
1439 
1440     createInitialContiguous(vm, index + 1).at(this, index).set(vm, this, value);
1441 }
1442 
1443 void JSObject::convertInt32ForValue(VM&amp; vm, JSValue value)
1444 {
1445     ASSERT(!value.isInt32());
1446 
1447     if (value.isDouble() &amp;&amp; !std::isnan(value.asDouble())) {
1448         convertInt32ToDouble(vm);
1449         return;
1450     }
1451 
1452     convertInt32ToContiguous(vm);
1453 }
1454 
1455 void JSObject::convertFromCopyOnWrite(VM&amp; vm)
1456 {
1457     ASSERT(isCopyOnWrite(indexingMode()));
1458     ASSERT(structure(vm)-&gt;indexingMode() == indexingMode());
1459 
1460     const bool hasIndexingHeader = true;
1461     Butterfly* oldButterfly = butterfly();
1462     size_t propertyCapacity = 0;
1463     unsigned newVectorLength = Butterfly::optimalContiguousVectorLength(propertyCapacity, std::min(oldButterfly-&gt;vectorLength() * 2, MAX_STORAGE_VECTOR_LENGTH));
1464     Butterfly* newButterfly = Butterfly::createUninitialized(vm, this, 0, propertyCapacity, hasIndexingHeader, newVectorLength * sizeof(JSValue));
1465 
1466     memcpy(newButterfly-&gt;propertyStorage(), oldButterfly-&gt;propertyStorage(), oldButterfly-&gt;vectorLength() * sizeof(JSValue) + sizeof(IndexingHeader));
1467 
1468     WTF::storeStoreFence();
1469     NonPropertyTransition transition = ([&amp;] () {
1470         switch (indexingType()) {
1471         case ArrayWithInt32:
1472             return NonPropertyTransition::AllocateInt32;
1473         case ArrayWithDouble:
1474             return NonPropertyTransition::AllocateDouble;
1475         case ArrayWithContiguous:
1476             return NonPropertyTransition::AllocateContiguous;
1477         default:
1478             RELEASE_ASSERT_NOT_REACHED();
1479             return NonPropertyTransition::AllocateContiguous;
1480         }
1481     })();
1482     StructureID oldStructureID = structureID();
1483     Structure* newStructure = Structure::nonPropertyTransition(vm, structure(vm), transition);
1484     nukeStructureAndSetButterfly(vm, oldStructureID, newButterfly);
1485     setStructure(vm, newStructure);
1486 }
1487 
1488 void JSObject::setIndexQuicklyToUndecided(VM&amp; vm, unsigned index, JSValue value)
1489 {
1490     ASSERT(index &lt; m_butterfly-&gt;publicLength());
1491     ASSERT(index &lt; m_butterfly-&gt;vectorLength());
1492     convertUndecidedForValue(vm, value);
1493     setIndexQuickly(vm, index, value);
1494 }
1495 
1496 void JSObject::convertInt32ToDoubleOrContiguousWhilePerformingSetIndex(VM&amp; vm, unsigned index, JSValue value)
1497 {
1498     ASSERT(!value.isInt32());
1499     convertInt32ForValue(vm, value);
1500     setIndexQuickly(vm, index, value);
1501 }
1502 
1503 void JSObject::convertDoubleToContiguousWhilePerformingSetIndex(VM&amp; vm, unsigned index, JSValue value)
1504 {
1505     ASSERT(!value.isNumber() || value.asNumber() != value.asNumber());
1506     convertDoubleToContiguous(vm);
1507     setIndexQuickly(vm, index, value);
1508 }
1509 
1510 ContiguousJSValues JSObject::tryMakeWritableInt32Slow(VM&amp; vm)
1511 {
1512     ASSERT(inherits(vm, info()));
1513 
1514     if (isCopyOnWrite(indexingMode())) {
1515         if (leastUpperBoundOfIndexingTypes(indexingType() &amp; IndexingShapeMask, Int32Shape) == Int32Shape) {
1516             ASSERT(hasInt32(indexingMode()));
1517             convertFromCopyOnWrite(vm);
1518             return butterfly()-&gt;contiguousInt32();
1519         }
1520         return ContiguousJSValues();
1521     }
1522 
1523     if (structure(vm)-&gt;hijacksIndexingHeader())
1524         return ContiguousJSValues();
1525 
1526     switch (indexingType()) {
1527     case ALL_BLANK_INDEXING_TYPES:
1528         if (UNLIKELY(indexingShouldBeSparse(vm) || needsSlowPutIndexing(vm)))
1529             return ContiguousJSValues();
1530         return createInitialInt32(vm, 0);
1531 
1532     case ALL_UNDECIDED_INDEXING_TYPES:
1533         return convertUndecidedToInt32(vm);
1534 
1535     case ALL_DOUBLE_INDEXING_TYPES:
1536     case ALL_CONTIGUOUS_INDEXING_TYPES:
1537     case ALL_ARRAY_STORAGE_INDEXING_TYPES:
1538         return ContiguousJSValues();
1539 
1540     default:
1541         CRASH();
1542         return ContiguousJSValues();
1543     }
1544 }
1545 
1546 ContiguousDoubles JSObject::tryMakeWritableDoubleSlow(VM&amp; vm)
1547 {
1548     ASSERT(inherits(vm, info()));
1549 
1550     if (isCopyOnWrite(indexingMode())) {
1551         if (leastUpperBoundOfIndexingTypes(indexingType() &amp; IndexingShapeMask, DoubleShape) == DoubleShape) {
1552             convertFromCopyOnWrite(vm);
1553             if (hasDouble(indexingMode()))
1554                 return butterfly()-&gt;contiguousDouble();
1555             ASSERT(hasInt32(indexingMode()));
1556         } else
1557             return ContiguousDoubles();
1558     }
1559 
1560     if (structure(vm)-&gt;hijacksIndexingHeader())
1561         return ContiguousDoubles();
1562 
1563     switch (indexingType()) {
1564     case ALL_BLANK_INDEXING_TYPES:
1565         if (UNLIKELY(indexingShouldBeSparse(vm) || needsSlowPutIndexing(vm)))
1566             return ContiguousDoubles();
1567         return createInitialDouble(vm, 0);
1568 
1569     case ALL_UNDECIDED_INDEXING_TYPES:
1570         return convertUndecidedToDouble(vm);
1571 
1572     case ALL_INT32_INDEXING_TYPES:
1573         return convertInt32ToDouble(vm);
1574 
1575     case ALL_CONTIGUOUS_INDEXING_TYPES:
1576     case ALL_ARRAY_STORAGE_INDEXING_TYPES:
1577         return ContiguousDoubles();
1578 
1579     default:
1580         CRASH();
1581         return ContiguousDoubles();
1582     }
1583 }
1584 
1585 ContiguousJSValues JSObject::tryMakeWritableContiguousSlow(VM&amp; vm)
1586 {
1587     ASSERT(inherits(vm, info()));
1588 
1589     if (isCopyOnWrite(indexingMode())) {
1590         if (leastUpperBoundOfIndexingTypes(indexingType() &amp; IndexingShapeMask, ContiguousShape) == ContiguousShape) {
1591             convertFromCopyOnWrite(vm);
1592             if (hasContiguous(indexingMode()))
1593                 return butterfly()-&gt;contiguous();
1594             ASSERT(hasInt32(indexingMode()) || hasDouble(indexingMode()));
1595         } else
1596             return ContiguousJSValues();
1597     }
1598 
1599     if (structure(vm)-&gt;hijacksIndexingHeader())
1600         return ContiguousJSValues();
1601 
1602     switch (indexingType()) {
1603     case ALL_BLANK_INDEXING_TYPES:
1604         if (UNLIKELY(indexingShouldBeSparse(vm) || needsSlowPutIndexing(vm)))
1605             return ContiguousJSValues();
1606         return createInitialContiguous(vm, 0);
1607 
1608     case ALL_UNDECIDED_INDEXING_TYPES:
1609         return convertUndecidedToContiguous(vm);
1610 
1611     case ALL_INT32_INDEXING_TYPES:
1612         return convertInt32ToContiguous(vm);
1613 
1614     case ALL_DOUBLE_INDEXING_TYPES:
1615         return convertDoubleToContiguous(vm);
1616 
1617     case ALL_ARRAY_STORAGE_INDEXING_TYPES:
1618         return ContiguousJSValues();
1619 
1620     default:
1621         CRASH();
1622         return ContiguousJSValues();
1623     }
1624 }
1625 
1626 ArrayStorage* JSObject::ensureArrayStorageSlow(VM&amp; vm)
1627 {
1628     ASSERT(inherits(vm, info()));
1629 
1630     if (structure(vm)-&gt;hijacksIndexingHeader())
1631         return nullptr;
1632 
1633     ensureWritable(vm);
1634 
1635     switch (indexingType()) {
1636     case ALL_BLANK_INDEXING_TYPES:
1637         if (UNLIKELY(indexingShouldBeSparse(vm)))
1638             return ensureArrayStorageExistsAndEnterDictionaryIndexingMode(vm);
1639         return createInitialArrayStorage(vm);
1640 
1641     case ALL_UNDECIDED_INDEXING_TYPES:
1642         ASSERT(!indexingShouldBeSparse(vm));
1643         ASSERT(!needsSlowPutIndexing(vm));
1644         return convertUndecidedToArrayStorage(vm);
1645 
1646     case ALL_INT32_INDEXING_TYPES:
1647         ASSERT(!indexingShouldBeSparse(vm));
1648         ASSERT(!needsSlowPutIndexing(vm));
1649         return convertInt32ToArrayStorage(vm);
1650 
1651     case ALL_DOUBLE_INDEXING_TYPES:
1652         ASSERT(!indexingShouldBeSparse(vm));
1653         ASSERT(!needsSlowPutIndexing(vm));
1654         return convertDoubleToArrayStorage(vm);
1655 
1656     case ALL_CONTIGUOUS_INDEXING_TYPES:
1657         ASSERT(!indexingShouldBeSparse(vm));
1658         ASSERT(!needsSlowPutIndexing(vm));
1659         return convertContiguousToArrayStorage(vm);
1660 
1661     default:
1662         RELEASE_ASSERT_NOT_REACHED();
1663         return 0;
1664     }
1665 }
1666 
1667 ArrayStorage* JSObject::ensureArrayStorageExistsAndEnterDictionaryIndexingMode(VM&amp; vm)
1668 {
1669     ensureWritable(vm);
1670 
1671     switch (indexingType()) {
1672     case ALL_BLANK_INDEXING_TYPES: {
1673         createArrayStorage(vm, 0, 0);
1674         SparseArrayValueMap* map = allocateSparseIndexMap(vm);
1675         map-&gt;setSparseMode();
1676         return arrayStorage();
1677     }
1678 
1679     case ALL_UNDECIDED_INDEXING_TYPES:
1680         return enterDictionaryIndexingModeWhenArrayStorageAlreadyExists(vm, convertUndecidedToArrayStorage(vm));
1681 
1682     case ALL_INT32_INDEXING_TYPES:
1683         return enterDictionaryIndexingModeWhenArrayStorageAlreadyExists(vm, convertInt32ToArrayStorage(vm));
1684 
1685     case ALL_DOUBLE_INDEXING_TYPES:
1686         return enterDictionaryIndexingModeWhenArrayStorageAlreadyExists(vm, convertDoubleToArrayStorage(vm));
1687 
1688     case ALL_CONTIGUOUS_INDEXING_TYPES:
1689         return enterDictionaryIndexingModeWhenArrayStorageAlreadyExists(vm, convertContiguousToArrayStorage(vm));
1690 
1691     case ALL_ARRAY_STORAGE_INDEXING_TYPES:
1692         return enterDictionaryIndexingModeWhenArrayStorageAlreadyExists(vm, m_butterfly-&gt;arrayStorage());
1693 
1694     default:
1695         CRASH();
1696         return 0;
1697     }
1698 }
1699 
1700 void JSObject::switchToSlowPutArrayStorage(VM&amp; vm)
1701 {
1702     ensureWritable(vm);
1703 
1704     switch (indexingType()) {
1705     case ArrayClass:
1706         ensureArrayStorage(vm);
1707         RELEASE_ASSERT(hasAnyArrayStorage(indexingType()));
1708         if (hasSlowPutArrayStorage(indexingType()))
1709             return;
1710         switchToSlowPutArrayStorage(vm);
1711         break;
1712 
1713     case ALL_UNDECIDED_INDEXING_TYPES:
1714         convertUndecidedToArrayStorage(vm, NonPropertyTransition::AllocateSlowPutArrayStorage);
1715         break;
1716 
1717     case ALL_INT32_INDEXING_TYPES:
1718         convertInt32ToArrayStorage(vm, NonPropertyTransition::AllocateSlowPutArrayStorage);
1719         break;
1720 
1721     case ALL_DOUBLE_INDEXING_TYPES:
1722         convertDoubleToArrayStorage(vm, NonPropertyTransition::AllocateSlowPutArrayStorage);
1723         break;
1724 
1725     case ALL_CONTIGUOUS_INDEXING_TYPES:
1726         convertContiguousToArrayStorage(vm, NonPropertyTransition::AllocateSlowPutArrayStorage);
1727         break;
1728 
1729     case NonArrayWithArrayStorage:
1730     case ArrayWithArrayStorage: {
1731         Structure* newStructure = Structure::nonPropertyTransition(vm, structure(vm), NonPropertyTransition::SwitchToSlowPutArrayStorage);
1732         setStructure(vm, newStructure);
1733         break;
1734     }
1735 
1736     default:
1737         CRASH();
1738         break;
1739     }
1740 }
1741 
1742 void JSObject::setPrototypeDirect(VM&amp; vm, JSValue prototype)
1743 {
1744     ASSERT(prototype);
1745     if (prototype.isObject())
1746         asObject(prototype)-&gt;didBecomePrototype();
1747 
1748     if (structure(vm)-&gt;hasMonoProto()) {
1749         DeferredStructureTransitionWatchpointFire deferred(vm, structure(vm));
1750         Structure* newStructure = Structure::changePrototypeTransition(vm, structure(vm), prototype, deferred);
1751         setStructure(vm, newStructure);
1752     } else
1753         putDirect(vm, knownPolyProtoOffset, prototype);
1754 
1755     if (!anyObjectInChainMayInterceptIndexedAccesses(vm))
1756         return;
1757 
1758     if (mayBePrototype()) {
1759         structure(vm)-&gt;globalObject()-&gt;haveABadTime(vm);
1760         return;
1761     }
1762 
1763     if (!hasIndexedProperties(indexingType()))
1764         return;
1765 
1766     if (shouldUseSlowPut(indexingType()))
1767         return;
1768 
1769     switchToSlowPutArrayStorage(vm);
1770 }
1771 
1772 bool JSObject::setPrototypeWithCycleCheck(VM&amp; vm, ExecState* exec, JSValue prototype, bool shouldThrowIfCantSet)
1773 {
1774     auto scope = DECLARE_THROW_SCOPE(vm);
1775 
1776     if (this-&gt;structure(vm)-&gt;isImmutablePrototypeExoticObject()) {
1777         // This implements https://tc39.github.io/ecma262/#sec-set-immutable-prototype.
1778         if (this-&gt;getPrototype(vm, exec) == prototype)
1779             return true;
1780 
1781         return typeError(exec, scope, shouldThrowIfCantSet, &quot;Cannot set prototype of immutable prototype object&quot;_s);
1782     }
1783 
1784     ASSERT(methodTable(vm)-&gt;toThis(this, exec, NotStrictMode) == this);
1785 
1786     if (this-&gt;getPrototypeDirect(vm) == prototype)
1787         return true;
1788 
1789     bool isExtensible = this-&gt;isExtensible(exec);
1790     RETURN_IF_EXCEPTION(scope, false);
1791 
1792     if (!isExtensible)
1793         return typeError(exec, scope, shouldThrowIfCantSet, ReadonlyPropertyWriteError);
1794 
1795     JSValue nextPrototype = prototype;
1796     while (nextPrototype &amp;&amp; nextPrototype.isObject()) {
1797         if (nextPrototype == this)
1798             return typeError(exec, scope, shouldThrowIfCantSet, &quot;cyclic __proto__ value&quot;_s);
1799         // FIXME: The specification currently says we should check if the [[GetPrototypeOf]] internal method of nextPrototype
1800         // is not the ordinary object internal method. However, we currently restrict this to Proxy objects as it would allow
1801         // for cycles with certain HTML objects (WindowProxy, Location) otherwise.
1802         // https://bugs.webkit.org/show_bug.cgi?id=161534
1803         if (UNLIKELY(asObject(nextPrototype)-&gt;type() == ProxyObjectType))
1804             break; // We&#39;re done. Set the prototype.
1805         nextPrototype = asObject(nextPrototype)-&gt;getPrototypeDirect(vm);
1806     }
1807     setPrototypeDirect(vm, prototype);
1808     return true;
1809 }
1810 
1811 bool JSObject::setPrototype(JSObject* object, ExecState* exec, JSValue prototype, bool shouldThrowIfCantSet)
1812 {
1813     return object-&gt;setPrototypeWithCycleCheck(exec-&gt;vm(), exec, prototype, shouldThrowIfCantSet);
1814 }
1815 
1816 JSValue JSObject::getPrototype(JSObject* object, ExecState* exec)
1817 {
1818     return object-&gt;getPrototypeDirect(exec-&gt;vm());
1819 }
1820 
1821 bool JSObject::setPrototype(VM&amp; vm, ExecState* exec, JSValue prototype, bool shouldThrowIfCantSet)
1822 {
1823     return methodTable(vm)-&gt;setPrototype(this, exec, prototype, shouldThrowIfCantSet);
1824 }
1825 
1826 bool JSObject::putGetter(ExecState* exec, PropertyName propertyName, JSValue getter, unsigned attributes)
1827 {
1828     PropertyDescriptor descriptor;
1829     descriptor.setGetter(getter);
1830 
1831     ASSERT(attributes &amp; PropertyAttribute::Accessor);
1832     if (!(attributes &amp; PropertyAttribute::ReadOnly))
1833         descriptor.setConfigurable(true);
1834     if (!(attributes &amp; PropertyAttribute::DontEnum))
1835         descriptor.setEnumerable(true);
1836 
1837     return defineOwnProperty(this, exec, propertyName, descriptor, true);
1838 }
1839 
1840 bool JSObject::putSetter(ExecState* exec, PropertyName propertyName, JSValue setter, unsigned attributes)
1841 {
1842     PropertyDescriptor descriptor;
1843     descriptor.setSetter(setter);
1844 
1845     ASSERT(attributes &amp; PropertyAttribute::Accessor);
1846     if (!(attributes &amp; PropertyAttribute::ReadOnly))
1847         descriptor.setConfigurable(true);
1848     if (!(attributes &amp; PropertyAttribute::DontEnum))
1849         descriptor.setEnumerable(true);
1850 
1851     return defineOwnProperty(this, exec, propertyName, descriptor, true);
1852 }
1853 
1854 bool JSObject::putDirectAccessor(ExecState* exec, PropertyName propertyName, GetterSetter* accessor, unsigned attributes)
1855 {
1856     ASSERT(attributes &amp; PropertyAttribute::Accessor);
1857 
1858     if (Optional&lt;uint32_t&gt; index = parseIndex(propertyName))
1859         return putDirectIndex(exec, index.value(), accessor, attributes, PutDirectIndexLikePutDirect);
1860 
1861     return putDirectNonIndexAccessor(exec-&gt;vm(), propertyName, accessor, attributes);
1862 }
1863 
1864 // FIXME: Introduce a JSObject::putDirectCustomValue() method instead of using
1865 // JSObject::putDirectCustomAccessor() to put CustomValues.
1866 // https://bugs.webkit.org/show_bug.cgi?id=192576
1867 bool JSObject::putDirectCustomAccessor(VM&amp; vm, PropertyName propertyName, JSValue value, unsigned attributes)
1868 {
1869     ASSERT(!parseIndex(propertyName));
1870     ASSERT(value.isCustomGetterSetter());
1871     if (!(attributes &amp; PropertyAttribute::CustomAccessor))
1872         attributes |= PropertyAttribute::CustomValue;
1873 
1874     PutPropertySlot slot(this);
1875     bool result = putDirectInternal&lt;PutModeDefineOwnProperty&gt;(vm, propertyName, value, attributes, slot);
1876 
1877     ASSERT(slot.type() == PutPropertySlot::NewProperty);
1878 
1879     Structure* structure = this-&gt;structure(vm);
1880     if (attributes &amp; PropertyAttribute::ReadOnly)
1881         structure-&gt;setContainsReadOnlyProperties();
1882     structure-&gt;setHasCustomGetterSetterPropertiesWithProtoCheck(propertyName == vm.propertyNames-&gt;underscoreProto);
1883     return result;
1884 }
1885 
1886 bool JSObject::putDirectNonIndexAccessor(VM&amp; vm, PropertyName propertyName, GetterSetter* accessor, unsigned attributes)
1887 {
1888     ASSERT(attributes &amp; PropertyAttribute::Accessor);
1889     PutPropertySlot slot(this);
1890     bool result = putDirectInternal&lt;PutModeDefineOwnProperty&gt;(vm, propertyName, accessor, attributes, slot);
1891 
1892     Structure* structure = this-&gt;structure(vm);
1893     if (attributes &amp; PropertyAttribute::ReadOnly)
1894         structure-&gt;setContainsReadOnlyProperties();
1895 
1896     structure-&gt;setHasGetterSetterPropertiesWithProtoCheck(propertyName == vm.propertyNames-&gt;underscoreProto);
1897     return result;
1898 }
1899 
<a name="29" id="anc29"></a>












1900 // HasProperty(O, P) from Section 7.3.10 of the spec.
1901 // http://www.ecma-international.org/ecma-262/6.0/index.html#sec-hasproperty
1902 bool JSObject::hasProperty(ExecState* exec, PropertyName propertyName) const
1903 {
1904     return hasPropertyGeneric(exec, propertyName, PropertySlot::InternalMethodType::HasProperty);
1905 }
1906 
1907 bool JSObject::hasProperty(ExecState* exec, unsigned propertyName) const
1908 {
1909     return hasPropertyGeneric(exec, propertyName, PropertySlot::InternalMethodType::HasProperty);
1910 }
1911 
1912 bool JSObject::hasPropertyGeneric(ExecState* exec, PropertyName propertyName, PropertySlot::InternalMethodType internalMethodType) const
1913 {
1914     PropertySlot slot(this, internalMethodType);
1915     return const_cast&lt;JSObject*&gt;(this)-&gt;getPropertySlot(exec, propertyName, slot);
1916 }
1917 
1918 bool JSObject::hasPropertyGeneric(ExecState* exec, unsigned propertyName, PropertySlot::InternalMethodType internalMethodType) const
1919 {
1920     PropertySlot slot(this, internalMethodType);
1921     return const_cast&lt;JSObject*&gt;(this)-&gt;getPropertySlot(exec, propertyName, slot);
1922 }
1923 
1924 // ECMA 8.6.2.5
1925 bool JSObject::deleteProperty(JSCell* cell, ExecState* exec, PropertyName propertyName)
1926 {
1927     JSObject* thisObject = jsCast&lt;JSObject*&gt;(cell);
1928     VM&amp; vm = exec-&gt;vm();
1929 
1930     if (Optional&lt;uint32_t&gt; index = parseIndex(propertyName))
1931         return thisObject-&gt;methodTable(vm)-&gt;deletePropertyByIndex(thisObject, exec, index.value());
1932 
1933     unsigned attributes;
1934 
1935     if (!thisObject-&gt;staticPropertiesReified(vm)) {
1936         if (auto entry = thisObject-&gt;findPropertyHashEntry(vm, propertyName)) {
1937             // If the static table contains a non-configurable (DontDelete) property then we can return early;
1938             // if there is a property in the storage array it too must be non-configurable (the language does
1939             // not allow repacement of a non-configurable property with a configurable one).
1940             if (entry-&gt;value-&gt;attributes() &amp; PropertyAttribute::DontDelete &amp;&amp; vm.deletePropertyMode() != VM::DeletePropertyMode::IgnoreConfigurable) {
1941                 ASSERT(!isValidOffset(thisObject-&gt;structure(vm)-&gt;get(vm, propertyName, attributes)) || attributes &amp; PropertyAttribute::DontDelete);
1942                 return false;
1943             }
1944             thisObject-&gt;reifyAllStaticProperties(exec);
1945         }
1946     }
1947 
1948     Structure* structure = thisObject-&gt;structure(vm);
1949 
1950     bool propertyIsPresent = isValidOffset(structure-&gt;get(vm, propertyName, attributes));
1951     if (propertyIsPresent) {
1952         if (attributes &amp; PropertyAttribute::DontDelete &amp;&amp; vm.deletePropertyMode() != VM::DeletePropertyMode::IgnoreConfigurable)
1953             return false;
1954 
1955         PropertyOffset offset;
1956         if (structure-&gt;isUncacheableDictionary())
1957             offset = structure-&gt;removePropertyWithoutTransition(vm, propertyName, [] (const ConcurrentJSLocker&amp;, PropertyOffset) { });
1958         else
1959             thisObject-&gt;setStructure(vm, Structure::removePropertyTransition(vm, structure, propertyName, offset));
1960 
1961         if (offset != invalidOffset)
1962             thisObject-&gt;locationForOffset(offset)-&gt;clear();
1963     }
1964 
1965     return true;
1966 }
1967 
1968 bool JSObject::deletePropertyByIndex(JSCell* cell, ExecState* exec, unsigned i)
1969 {
1970     VM&amp; vm = exec-&gt;vm();
1971     JSObject* thisObject = jsCast&lt;JSObject*&gt;(cell);
1972 
1973     if (i &gt; MAX_ARRAY_INDEX)
<a name="30" id="anc30"></a><span class="line-modified">1974         return thisObject-&gt;methodTable(vm)-&gt;deleteProperty(thisObject, exec, Identifier::from(exec, i));</span>
1975 
1976     switch (thisObject-&gt;indexingMode()) {
1977     case ALL_BLANK_INDEXING_TYPES:
1978     case ALL_UNDECIDED_INDEXING_TYPES:
1979         return true;
1980 
1981     case CopyOnWriteArrayWithInt32:
1982     case CopyOnWriteArrayWithContiguous: {
1983         Butterfly* butterfly = thisObject-&gt;butterfly();
1984         if (i &gt;= butterfly-&gt;vectorLength())
1985             return true;
1986         thisObject-&gt;convertFromCopyOnWrite(vm);
1987         FALLTHROUGH;
1988     }
1989 
1990     case ALL_WRITABLE_INT32_INDEXING_TYPES:
1991     case ALL_WRITABLE_CONTIGUOUS_INDEXING_TYPES: {
1992         Butterfly* butterfly = thisObject-&gt;butterfly();
1993         if (i &gt;= butterfly-&gt;vectorLength())
1994             return true;
1995         butterfly-&gt;contiguous().at(thisObject, i).clear();
1996         return true;
1997     }
1998 
1999     case CopyOnWriteArrayWithDouble: {
2000         Butterfly* butterfly = thisObject-&gt;butterfly();
2001         if (i &gt;= butterfly-&gt;vectorLength())
2002             return true;
2003         thisObject-&gt;convertFromCopyOnWrite(vm);
2004         FALLTHROUGH;
2005     }
2006 
2007     case ALL_WRITABLE_DOUBLE_INDEXING_TYPES: {
2008         Butterfly* butterfly = thisObject-&gt;butterfly();
2009         if (i &gt;= butterfly-&gt;vectorLength())
2010             return true;
2011         butterfly-&gt;contiguousDouble().at(thisObject, i) = PNaN;
2012         return true;
2013     }
2014 
2015     case ALL_ARRAY_STORAGE_INDEXING_TYPES: {
2016         ArrayStorage* storage = thisObject-&gt;m_butterfly-&gt;arrayStorage();
2017 
2018         if (i &lt; storage-&gt;vectorLength()) {
2019             WriteBarrier&lt;Unknown&gt;&amp; valueSlot = storage-&gt;m_vector[i];
2020             if (valueSlot) {
2021                 valueSlot.clear();
2022                 --storage-&gt;m_numValuesInVector;
2023             }
2024         } else if (SparseArrayValueMap* map = storage-&gt;m_sparseMap.get()) {
2025             SparseArrayValueMap::iterator it = map-&gt;find(i);
2026             if (it != map-&gt;notFound()) {
2027                 if (it-&gt;value.attributes() &amp; PropertyAttribute::DontDelete)
2028                     return false;
2029                 map-&gt;remove(it);
2030             }
2031         }
2032 
2033         return true;
2034     }
2035 
2036     default:
2037         RELEASE_ASSERT_NOT_REACHED();
2038         return false;
2039     }
2040 }
2041 
2042 enum class TypeHintMode { TakesHint, DoesNotTakeHint };
2043 
2044 template&lt;TypeHintMode mode = TypeHintMode::DoesNotTakeHint&gt;
2045 static ALWAYS_INLINE JSValue callToPrimitiveFunction(ExecState* exec, const JSObject* object, PropertyName propertyName, PreferredPrimitiveType hint)
2046 {
2047     VM&amp; vm = exec-&gt;vm();
2048     auto scope = DECLARE_THROW_SCOPE(vm);
2049 
2050     PropertySlot slot(object, PropertySlot::InternalMethodType::Get);
2051     // FIXME: Remove this when we have fixed: rdar://problem/33451840
2052     // https://bugs.webkit.org/show_bug.cgi?id=187109.
2053     constexpr bool debugNullStructure = mode == TypeHintMode::TakesHint;
2054     bool hasProperty = const_cast&lt;JSObject*&gt;(object)-&gt;getPropertySlot&lt;debugNullStructure&gt;(exec, propertyName, slot);
2055     RETURN_IF_EXCEPTION(scope, scope.exception());
2056     JSValue function = hasProperty ? slot.getValue(exec, propertyName) : jsUndefined();
2057     RETURN_IF_EXCEPTION(scope, scope.exception());
2058     if (function.isUndefinedOrNull() &amp;&amp; mode == TypeHintMode::TakesHint)
2059         return JSValue();
2060     CallData callData;
2061     CallType callType = getCallData(vm, function, callData);
2062     if (callType == CallType::None) {
2063         if (mode == TypeHintMode::TakesHint)
2064             throwTypeError(exec, scope, &quot;Symbol.toPrimitive is not a function, undefined, or null&quot;_s);
2065         return scope.exception();
2066     }
2067 
2068     MarkedArgumentBuffer callArgs;
2069     if (mode == TypeHintMode::TakesHint) {
2070         JSString* hintString = nullptr;
2071         switch (hint) {
2072         case NoPreference:
2073             hintString = vm.smallStrings.defaultString();
2074             break;
2075         case PreferNumber:
2076             hintString = vm.smallStrings.numberString();
2077             break;
2078         case PreferString:
2079             hintString = vm.smallStrings.stringString();
2080             break;
2081         }
2082         callArgs.append(hintString);
2083     }
2084     ASSERT(!callArgs.hasOverflowed());
2085 
2086     JSValue result = call(exec, function, callType, callData, const_cast&lt;JSObject*&gt;(object), callArgs);
2087     RETURN_IF_EXCEPTION(scope, scope.exception());
2088     ASSERT(!result.isGetterSetter());
2089     if (result.isObject())
2090         return mode == TypeHintMode::DoesNotTakeHint ? JSValue() : throwTypeError(exec, scope, &quot;Symbol.toPrimitive returned an object&quot;_s);
2091     return result;
2092 }
2093 
2094 // ECMA 7.1.1
2095 JSValue JSObject::ordinaryToPrimitive(ExecState* exec, PreferredPrimitiveType hint) const
2096 {
2097     VM&amp; vm = exec-&gt;vm();
2098     auto scope = DECLARE_THROW_SCOPE(vm);
2099 
2100     // Make sure that whatever default value methods there are on object&#39;s prototype chain are
2101     // being watched.
2102     for (const JSObject* object = this; object; object = object-&gt;structure(vm)-&gt;storedPrototypeObject(object))
2103         object-&gt;structure(vm)-&gt;startWatchingInternalPropertiesIfNecessary(vm);
2104 
2105     JSValue value;
2106     if (hint == PreferString) {
2107         value = callToPrimitiveFunction(exec, this, vm.propertyNames-&gt;toString, hint);
2108         EXCEPTION_ASSERT(!scope.exception() || scope.exception() == value.asCell());
2109         if (value)
2110             return value;
2111         value = callToPrimitiveFunction(exec, this, vm.propertyNames-&gt;valueOf, hint);
2112         EXCEPTION_ASSERT(!scope.exception() || scope.exception() == value.asCell());
2113         if (value)
2114             return value;
2115     } else {
2116         value = callToPrimitiveFunction(exec, this, vm.propertyNames-&gt;valueOf, hint);
2117         EXCEPTION_ASSERT(!scope.exception() || scope.exception() == value.asCell());
2118         if (value)
2119             return value;
2120         value = callToPrimitiveFunction(exec, this, vm.propertyNames-&gt;toString, hint);
2121         EXCEPTION_ASSERT(!scope.exception() || scope.exception() == value.asCell());
2122         if (value)
2123             return value;
2124     }
2125 
2126     scope.assertNoException();
2127 
2128     return throwTypeError(exec, scope, &quot;No default value&quot;_s);
2129 }
2130 
2131 JSValue JSObject::defaultValue(const JSObject* object, ExecState* exec, PreferredPrimitiveType hint)
2132 {
2133     return object-&gt;ordinaryToPrimitive(exec, hint);
2134 }
2135 
2136 JSValue JSObject::toPrimitive(ExecState* exec, PreferredPrimitiveType preferredType) const
2137 {
2138     VM&amp; vm = exec-&gt;vm();
2139     auto scope = DECLARE_THROW_SCOPE(vm);
2140 
2141     JSValue value = callToPrimitiveFunction&lt;TypeHintMode::TakesHint&gt;(exec, this, vm.propertyNames-&gt;toPrimitiveSymbol, preferredType);
2142     RETURN_IF_EXCEPTION(scope, { });
2143     if (value)
2144         return value;
2145 
2146     RELEASE_AND_RETURN(scope, this-&gt;methodTable(vm)-&gt;defaultValue(this, exec, preferredType));
2147 }
2148 
2149 bool JSObject::getPrimitiveNumber(ExecState* exec, double&amp; number, JSValue&amp; result) const
2150 {
2151     VM&amp; vm = exec-&gt;vm();
2152     auto scope = DECLARE_THROW_SCOPE(vm);
2153 
2154     result = toPrimitive(exec, PreferNumber);
2155     RETURN_IF_EXCEPTION(scope, false);
2156     scope.release();
2157     number = result.toNumber(exec);
2158     return !result.isString();
2159 }
2160 
2161 bool JSObject::getOwnStaticPropertySlot(VM&amp; vm, PropertyName propertyName, PropertySlot&amp; slot)
2162 {
2163     for (auto* info = classInfo(vm); info; info = info-&gt;parentClass) {
2164         if (auto* table = info-&gt;staticPropHashTable) {
2165             if (getStaticPropertySlotFromTable(vm, table-&gt;classForThis, *table, this, propertyName, slot))
2166                 return true;
2167         }
2168     }
2169     return false;
2170 }
2171 
2172 auto JSObject::findPropertyHashEntry(VM&amp; vm, PropertyName propertyName) const -&gt; Optional&lt;PropertyHashEntry&gt;
2173 {
2174     for (const ClassInfo* info = classInfo(vm); info; info = info-&gt;parentClass) {
2175         if (const HashTable* propHashTable = info-&gt;staticPropHashTable) {
2176             if (const HashTableValue* entry = propHashTable-&gt;entry(propertyName))
2177                 return PropertyHashEntry { propHashTable, entry };
2178         }
2179     }
2180     return WTF::nullopt;
2181 }
2182 
2183 bool JSObject::hasInstance(ExecState* exec, JSValue value, JSValue hasInstanceValue)
2184 {
2185     VM&amp; vm = exec-&gt;vm();
2186     auto scope = DECLARE_THROW_SCOPE(vm);
2187 
2188     if (!hasInstanceValue.isUndefinedOrNull() &amp;&amp; hasInstanceValue != exec-&gt;lexicalGlobalObject()-&gt;functionProtoHasInstanceSymbolFunction()) {
2189         CallData callData;
2190         CallType callType = JSC::getCallData(vm, hasInstanceValue, callData);
2191         if (callType == CallType::None) {
2192             throwException(exec, scope, createInvalidInstanceofParameterErrorHasInstanceValueNotFunction(exec, this));
2193             return false;
2194         }
2195 
2196         MarkedArgumentBuffer args;
2197         args.append(value);
2198         ASSERT(!args.hasOverflowed());
2199         JSValue result = call(exec, hasInstanceValue, callType, callData, this, args);
2200         RETURN_IF_EXCEPTION(scope, false);
2201         return result.toBoolean(exec);
2202     }
2203 
2204     TypeInfo info = structure(vm)-&gt;typeInfo();
2205     if (info.implementsDefaultHasInstance()) {
2206         JSValue prototype = get(exec, vm.propertyNames-&gt;prototype);
2207         RETURN_IF_EXCEPTION(scope, false);
2208         RELEASE_AND_RETURN(scope, defaultHasInstance(exec, value, prototype));
2209     }
2210     if (info.implementsHasInstance()) {
2211         if (UNLIKELY(!vm.isSafeToRecurseSoft())) {
2212             throwStackOverflowError(exec, scope);
2213             return false;
2214         }
2215         RELEASE_AND_RETURN(scope, methodTable(vm)-&gt;customHasInstance(this, exec, value));
2216     }
2217 
2218     throwException(exec, scope, createInvalidInstanceofParameterErrorNotFunction(exec, this));
2219     return false;
2220 }
2221 
2222 bool JSObject::hasInstance(ExecState* exec, JSValue value)
2223 {
2224     VM&amp; vm = exec-&gt;vm();
2225     auto scope = DECLARE_THROW_SCOPE(vm);
2226     JSValue hasInstanceValue = get(exec, vm.propertyNames-&gt;hasInstanceSymbol);
2227     RETURN_IF_EXCEPTION(scope, false);
2228 
2229     RELEASE_AND_RETURN(scope, hasInstance(exec, value, hasInstanceValue));
2230 }
2231 
2232 bool JSObject::defaultHasInstance(ExecState* exec, JSValue value, JSValue proto)
2233 {
2234     VM&amp; vm = exec-&gt;vm();
2235     auto scope = DECLARE_THROW_SCOPE(vm);
2236 
2237     if (!value.isObject())
2238         return false;
2239 
2240     if (!proto.isObject()) {
2241         throwTypeError(exec, scope, &quot;instanceof called on an object with an invalid prototype property.&quot;_s);
2242         return false;
2243     }
2244 
2245     JSObject* object = asObject(value);
2246     while (true) {
2247         JSValue objectValue = object-&gt;getPrototype(vm, exec);
2248         RETURN_IF_EXCEPTION(scope, false);
2249         if (!objectValue.isObject())
2250             return false;
2251         object = asObject(objectValue);
2252         if (proto == object)
2253             return true;
2254     }
2255     ASSERT_NOT_REACHED();
2256 }
2257 
2258 EncodedJSValue JSC_HOST_CALL objectPrivateFuncInstanceOf(ExecState* exec)
2259 {
2260     JSValue value = exec-&gt;uncheckedArgument(0);
2261     JSValue proto = exec-&gt;uncheckedArgument(1);
2262 
2263     return JSValue::encode(jsBoolean(JSObject::defaultHasInstance(exec, value, proto)));
2264 }
2265 
2266 void JSObject::getPropertyNames(JSObject* object, ExecState* exec, PropertyNameArray&amp; propertyNames, EnumerationMode mode)
2267 {
2268     VM&amp; vm = exec-&gt;vm();
2269     auto scope = DECLARE_THROW_SCOPE(vm);
2270     object-&gt;methodTable(vm)-&gt;getOwnPropertyNames(object, exec, propertyNames, mode);
2271     RETURN_IF_EXCEPTION(scope, void());
2272 
2273     JSValue nextProto = object-&gt;getPrototype(vm, exec);
2274     RETURN_IF_EXCEPTION(scope, void());
2275     if (nextProto.isNull())
2276         return;
2277 
2278     JSObject* prototype = asObject(nextProto);
2279     while(1) {
2280         if (prototype-&gt;structure(vm)-&gt;typeInfo().overridesGetPropertyNames()) {
2281             scope.release();
2282             prototype-&gt;methodTable(vm)-&gt;getPropertyNames(prototype, exec, propertyNames, mode);
2283             return;
2284         }
2285         prototype-&gt;methodTable(vm)-&gt;getOwnPropertyNames(prototype, exec, propertyNames, mode);
2286         RETURN_IF_EXCEPTION(scope, void());
2287         nextProto = prototype-&gt;getPrototype(vm, exec);
2288         RETURN_IF_EXCEPTION(scope, void());
2289         if (nextProto.isNull())
2290             break;
2291         prototype = asObject(nextProto);
2292     }
2293 }
2294 
2295 void JSObject::getOwnPropertyNames(JSObject* object, ExecState* exec, PropertyNameArray&amp; propertyNames, EnumerationMode mode)
2296 {
2297     VM&amp; vm = exec-&gt;vm();
2298     if (!mode.includeJSObjectProperties()) {
2299         // We still have to get non-indexed properties from any subclasses of JSObject that have them.
2300         object-&gt;methodTable(vm)-&gt;getOwnNonIndexPropertyNames(object, exec, propertyNames, mode);
2301         return;
2302     }
2303 
2304     if (propertyNames.includeStringProperties()) {
2305         // Add numeric properties first. That appears to be the accepted convention.
2306         // FIXME: Filling PropertyNameArray with an identifier for every integer
2307         // is incredibly inefficient for large arrays. We need a different approach,
2308         // which almost certainly means a different structure for PropertyNameArray.
2309         switch (object-&gt;indexingType()) {
2310         case ALL_BLANK_INDEXING_TYPES:
2311         case ALL_UNDECIDED_INDEXING_TYPES:
2312             break;
2313 
2314         case ALL_INT32_INDEXING_TYPES:
2315         case ALL_CONTIGUOUS_INDEXING_TYPES: {
2316             Butterfly* butterfly = object-&gt;butterfly();
2317             unsigned usedLength = butterfly-&gt;publicLength();
2318             for (unsigned i = 0; i &lt; usedLength; ++i) {
2319                 if (!butterfly-&gt;contiguous().at(object, i))
2320                     continue;
2321                 propertyNames.add(i);
2322             }
2323             break;
2324         }
2325 
2326         case ALL_DOUBLE_INDEXING_TYPES: {
2327             Butterfly* butterfly = object-&gt;butterfly();
2328             unsigned usedLength = butterfly-&gt;publicLength();
2329             for (unsigned i = 0; i &lt; usedLength; ++i) {
2330                 double value = butterfly-&gt;contiguousDouble().at(object, i);
2331                 if (value != value)
2332                     continue;
2333                 propertyNames.add(i);
2334             }
2335             break;
2336         }
2337 
2338         case ALL_ARRAY_STORAGE_INDEXING_TYPES: {
2339             ArrayStorage* storage = object-&gt;m_butterfly-&gt;arrayStorage();
2340 
2341             unsigned usedVectorLength = std::min(storage-&gt;length(), storage-&gt;vectorLength());
2342             for (unsigned i = 0; i &lt; usedVectorLength; ++i) {
2343                 if (storage-&gt;m_vector[i])
2344                     propertyNames.add(i);
2345             }
2346 
2347             if (SparseArrayValueMap* map = storage-&gt;m_sparseMap.get()) {
2348                 Vector&lt;unsigned, 0, UnsafeVectorOverflow&gt; keys;
2349                 keys.reserveInitialCapacity(map-&gt;size());
2350 
2351                 SparseArrayValueMap::const_iterator end = map-&gt;end();
2352                 for (SparseArrayValueMap::const_iterator it = map-&gt;begin(); it != end; ++it) {
2353                     if (mode.includeDontEnumProperties() || !(it-&gt;value.attributes() &amp; PropertyAttribute::DontEnum))
2354                         keys.uncheckedAppend(static_cast&lt;unsigned&gt;(it-&gt;key));
2355                 }
2356 
2357                 std::sort(keys.begin(), keys.end());
2358                 for (unsigned i = 0; i &lt; keys.size(); ++i)
2359                     propertyNames.add(keys[i]);
2360             }
2361             break;
2362         }
2363 
2364         default:
2365             RELEASE_ASSERT_NOT_REACHED();
2366         }
2367     }
2368 
2369     object-&gt;methodTable(vm)-&gt;getOwnNonIndexPropertyNames(object, exec, propertyNames, mode);
2370 }
2371 
2372 void JSObject::getOwnNonIndexPropertyNames(JSObject* object, ExecState* exec, PropertyNameArray&amp; propertyNames, EnumerationMode mode)
2373 {
2374     VM&amp; vm = exec-&gt;vm();
2375     if (!object-&gt;staticPropertiesReified(vm))
2376         getClassPropertyNames(exec, object-&gt;classInfo(vm), propertyNames, mode);
2377 
2378     if (!mode.includeJSObjectProperties())
2379         return;
2380 
2381     object-&gt;structure(vm)-&gt;getPropertyNamesFromStructure(vm, propertyNames, mode);
2382 }
2383 
2384 double JSObject::toNumber(ExecState* exec) const
2385 {
2386     VM&amp; vm = exec-&gt;vm();
2387     auto scope = DECLARE_THROW_SCOPE(vm);
2388     JSValue primitive = toPrimitive(exec, PreferNumber);
2389     RETURN_IF_EXCEPTION(scope, 0.0); // should be picked up soon in Nodes.cpp
2390     RELEASE_AND_RETURN(scope, primitive.toNumber(exec));
2391 }
2392 
2393 JSString* JSObject::toString(ExecState* exec) const
2394 {
2395     VM&amp; vm = exec-&gt;vm();
2396     auto scope = DECLARE_THROW_SCOPE(vm);
2397     JSValue primitive = toPrimitive(exec, PreferString);
<a name="31" id="anc31"></a><span class="line-modified">2398     RETURN_IF_EXCEPTION(scope, jsEmptyString(exec));</span>
<span class="line-modified">2399     return primitive.toString(exec);</span>
2400 }
2401 
2402 JSValue JSObject::toThis(JSCell* cell, ExecState*, ECMAMode)
2403 {
2404     return jsCast&lt;JSObject*&gt;(cell);
2405 }
2406 
2407 void JSObject::seal(VM&amp; vm)
2408 {
2409     if (isSealed(vm))
2410         return;
2411     enterDictionaryIndexingMode(vm);
2412     setStructure(vm, Structure::sealTransition(vm, structure(vm)));
2413 }
2414 
2415 void JSObject::freeze(VM&amp; vm)
2416 {
2417     if (isFrozen(vm))
2418         return;
2419     enterDictionaryIndexingMode(vm);
2420     setStructure(vm, Structure::freezeTransition(vm, structure(vm)));
2421 }
2422 
2423 bool JSObject::preventExtensions(JSObject* object, ExecState* exec)
2424 {
2425     VM&amp; vm = exec-&gt;vm();
2426     if (!object-&gt;isStructureExtensible(vm)) {
2427         // We&#39;ve already set the internal [[PreventExtensions]] field to false.
2428         // We don&#39;t call the methodTable isExtensible here because it&#39;s not defined
2429         // that way in the specification. We are just doing an optimization here.
2430         return true;
2431     }
2432 
2433     object-&gt;enterDictionaryIndexingMode(vm);
2434     object-&gt;setStructure(vm, Structure::preventExtensionsTransition(vm, object-&gt;structure(vm)));
2435     return true;
2436 }
2437 
2438 bool JSObject::isExtensible(JSObject* obj, ExecState* exec)
2439 {
2440     return obj-&gt;isStructureExtensible(exec-&gt;vm());
2441 }
2442 
2443 bool JSObject::isExtensible(ExecState* exec)
2444 {
2445     VM&amp; vm = exec-&gt;vm();
2446     return methodTable(vm)-&gt;isExtensible(this, exec);
2447 }
2448 
2449 void JSObject::reifyAllStaticProperties(ExecState* exec)
2450 {
2451     VM&amp; vm = exec-&gt;vm();
2452     ASSERT(!staticPropertiesReified(vm));
2453 
2454     // If this object&#39;s ClassInfo has no static properties, then nothing to reify!
2455     // We can safely set the flag to avoid the expensive check again in the future.
2456     if (!TypeInfo::hasStaticPropertyTable(inlineTypeFlags())) {
2457         structure(vm)-&gt;setStaticPropertiesReified(true);
2458         return;
2459     }
2460 
2461     if (!structure(vm)-&gt;isDictionary())
2462         setStructure(vm, Structure::toCacheableDictionaryTransition(vm, structure(vm)));
2463 
2464     for (const ClassInfo* info = classInfo(vm); info; info = info-&gt;parentClass) {
2465         const HashTable* hashTable = info-&gt;staticPropHashTable;
2466         if (!hashTable)
2467             continue;
2468 
2469         for (auto&amp; value : *hashTable) {
2470             unsigned attributes;
<a name="32" id="anc32"></a><span class="line-modified">2471             auto key = Identifier::fromString(&amp;vm, value.m_key);</span>
2472             PropertyOffset offset = getDirectOffset(vm, key, attributes);
2473             if (!isValidOffset(offset))
2474                 reifyStaticProperty(vm, hashTable-&gt;classForThis, key, value, *this);
2475         }
2476     }
2477 
2478     structure(vm)-&gt;setStaticPropertiesReified(true);
2479 }
2480 
2481 NEVER_INLINE void JSObject::fillGetterPropertySlot(VM&amp; vm, PropertySlot&amp; slot, JSCell* getterSetter, unsigned attributes, PropertyOffset offset)
2482 {
2483     if (structure(vm)-&gt;isUncacheableDictionary()) {
2484         slot.setGetterSlot(this, attributes, jsCast&lt;GetterSetter*&gt;(getterSetter));
2485         return;
2486     }
2487 
2488     // This access is cacheable because Structure requires an attributeChangedTransition
2489     // if this property stops being an accessor.
2490     slot.setCacheableGetterSlot(this, attributes, jsCast&lt;GetterSetter*&gt;(getterSetter), offset);
2491 }
2492 
2493 static bool putIndexedDescriptor(ExecState* exec, SparseArrayValueMap* map, SparseArrayEntry* entryInMap, const PropertyDescriptor&amp; descriptor, PropertyDescriptor&amp; oldDescriptor)
2494 {
2495     VM&amp; vm = exec-&gt;vm();
2496 
2497     if (descriptor.isDataDescriptor()) {
2498         unsigned attributes = descriptor.attributesOverridingCurrent(oldDescriptor) &amp; ~PropertyAttribute::Accessor;
2499         if (descriptor.value())
2500             entryInMap-&gt;forceSet(vm, map, descriptor.value(), attributes);
2501         else if (oldDescriptor.isAccessorDescriptor())
2502             entryInMap-&gt;forceSet(vm, map, jsUndefined(), attributes);
2503         else
2504             entryInMap-&gt;forceSet(attributes);
2505         return true;
2506     }
2507 
2508     if (descriptor.isAccessorDescriptor()) {
2509         JSObject* getter = nullptr;
2510         if (descriptor.getterPresent())
2511             getter = descriptor.getterObject();
2512         else if (oldDescriptor.isAccessorDescriptor())
2513             getter = oldDescriptor.getterObject();
2514         JSObject* setter = nullptr;
2515         if (descriptor.setterPresent())
2516             setter = descriptor.setterObject();
2517         else if (oldDescriptor.isAccessorDescriptor())
2518             setter = oldDescriptor.setterObject();
2519 
2520         GetterSetter* accessor = GetterSetter::create(vm, exec-&gt;lexicalGlobalObject(), getter, setter);
2521         entryInMap-&gt;forceSet(vm, map, accessor, descriptor.attributesOverridingCurrent(oldDescriptor) &amp; ~PropertyAttribute::ReadOnly);
2522         return true;
2523     }
2524 
2525     ASSERT(descriptor.isGenericDescriptor());
2526     entryInMap-&gt;forceSet(descriptor.attributesOverridingCurrent(oldDescriptor));
2527     return true;
2528 }
2529 
2530 ALWAYS_INLINE static bool canDoFastPutDirectIndex(VM&amp; vm, JSObject* object)
2531 {
2532     return (isJSArray(object) &amp;&amp; !isCopyOnWrite(object-&gt;indexingMode()))
2533         || jsDynamicCast&lt;JSFinalObject*&gt;(vm, object)
2534         || TypeInfo::isArgumentsType(object-&gt;type());
2535 }
2536 
2537 // Defined in ES5.1 8.12.9
2538 bool JSObject::defineOwnIndexedProperty(ExecState* exec, unsigned index, const PropertyDescriptor&amp; descriptor, bool throwException)
2539 {
2540     VM&amp; vm = exec-&gt;vm();
2541     auto scope = DECLARE_THROW_SCOPE(vm);
2542 
2543     ASSERT(index &lt;= MAX_ARRAY_INDEX);
2544 
2545     ensureWritable(vm);
2546 
2547     if (!inSparseIndexingMode()) {
2548         // Fast case: we&#39;re putting a regular property to a regular array
2549         // FIXME: this will pessimistically assume that if attributes are missing then they&#39;ll default to false
2550         // however if the property currently exists missing attributes will override from their current &#39;true&#39;
2551         // state (i.e. defineOwnProperty could be used to set a value without needing to entering &#39;SparseMode&#39;).
2552         if (!descriptor.attributes() &amp;&amp; descriptor.value() &amp;&amp; canDoFastPutDirectIndex(vm, this)) {
2553             ASSERT(!descriptor.isAccessorDescriptor());
2554             RELEASE_AND_RETURN(scope, putDirectIndex(exec, index, descriptor.value(), 0, throwException ? PutDirectIndexShouldThrow : PutDirectIndexShouldNotThrow));
2555         }
2556 
2557         ensureArrayStorageExistsAndEnterDictionaryIndexingMode(vm);
2558     }
2559 
2560     if (descriptor.attributes() &amp; (PropertyAttribute::ReadOnly | PropertyAttribute::Accessor))
2561         notifyPresenceOfIndexedAccessors(vm);
2562 
2563     SparseArrayValueMap* map = m_butterfly-&gt;arrayStorage()-&gt;m_sparseMap.get();
2564     RELEASE_ASSERT(map);
2565 
2566     // 1. Let current be the result of calling the [[GetOwnProperty]] internal method of O with property name P.
2567     SparseArrayValueMap::AddResult result = map-&gt;add(this, index);
2568     SparseArrayEntry* entryInMap = &amp;result.iterator-&gt;value;
2569 
2570     // 2. Let extensible be the value of the [[Extensible]] internal property of O.
2571     // 3. If current is undefined and extensible is false, then Reject.
2572     // 4. If current is undefined and extensible is true, then
2573     if (result.isNewEntry) {
2574         if (!isStructureExtensible(vm)) {
2575             map-&gt;remove(result.iterator);
2576             return typeError(exec, scope, throwException, NonExtensibleObjectPropertyDefineError);
2577         }
2578 
2579         // 4.a. If IsGenericDescriptor(Desc) or IsDataDescriptor(Desc) is true, then create an own data property
2580         // named P of object O whose [[Value]], [[Writable]], [[Enumerable]] and [[Configurable]] attribute values
2581         // are described by Desc. If the value of an attribute field of Desc is absent, the attribute of the newly
2582         // created property is set to its default value.
2583         // 4.b. Else, Desc must be an accessor Property Descriptor so, create an own accessor property named P of
2584         // object O whose [[Get]], [[Set]], [[Enumerable]] and [[Configurable]] attribute values are described by
2585         // Desc. If the value of an attribute field of Desc is absent, the attribute of the newly created property
2586         // is set to its default value.
2587         // 4.c. Return true.
2588 
2589         PropertyDescriptor defaults(jsUndefined(), PropertyAttribute::DontDelete | PropertyAttribute::DontEnum | PropertyAttribute::ReadOnly);
2590         putIndexedDescriptor(exec, map, entryInMap, descriptor, defaults);
2591         Butterfly* butterfly = m_butterfly.get();
2592         if (index &gt;= butterfly-&gt;arrayStorage()-&gt;length())
2593             butterfly-&gt;arrayStorage()-&gt;setLength(index + 1);
2594         return true;
2595     }
2596 
2597     // 5. Return true, if every field in Desc is absent.
2598     // 6. Return true, if every field in Desc also occurs in current and the value of every field in Desc is the same value as the corresponding field in current when compared using the SameValue algorithm (9.12).
2599     PropertyDescriptor current;
2600     entryInMap-&gt;get(current);
2601     bool isEmptyOrEqual = descriptor.isEmpty() || descriptor.equalTo(exec, current);
2602     RETURN_IF_EXCEPTION(scope, false);
2603     if (isEmptyOrEqual)
2604         return true;
2605 
2606     // 7. If the [[Configurable]] field of current is false then
2607     if (!current.configurable()) {
2608         // 7.a. Reject, if the [[Configurable]] field of Desc is true.
2609         if (descriptor.configurablePresent() &amp;&amp; descriptor.configurable())
2610             return typeError(exec, scope, throwException, UnconfigurablePropertyChangeConfigurabilityError);
2611         // 7.b. Reject, if the [[Enumerable]] field of Desc is present and the [[Enumerable]] fields of current and Desc are the Boolean negation of each other.
2612         if (descriptor.enumerablePresent() &amp;&amp; current.enumerable() != descriptor.enumerable())
2613             return typeError(exec, scope, throwException, UnconfigurablePropertyChangeEnumerabilityError);
2614     }
2615 
2616     // 8. If IsGenericDescriptor(Desc) is true, then no further validation is required.
2617     if (!descriptor.isGenericDescriptor()) {
2618         // 9. Else, if IsDataDescriptor(current) and IsDataDescriptor(Desc) have different results, then
2619         if (current.isDataDescriptor() != descriptor.isDataDescriptor()) {
2620             // 9.a. Reject, if the [[Configurable]] field of current is false.
2621             if (!current.configurable())
2622                 return typeError(exec, scope, throwException, UnconfigurablePropertyChangeAccessMechanismError);
2623             // 9.b. If IsDataDescriptor(current) is true, then convert the property named P of object O from a
2624             // data property to an accessor property. Preserve the existing values of the converted property&#39;s
2625             // [[Configurable]] and [[Enumerable]] attributes and set the rest of the property&#39;s attributes to
2626             // their default values.
2627             // 9.c. Else, convert the property named P of object O from an accessor property to a data property.
2628             // Preserve the existing values of the converted property&#39;s [[Configurable]] and [[Enumerable]]
2629             // attributes and set the rest of the property&#39;s attributes to their default values.
2630         } else if (current.isDataDescriptor() &amp;&amp; descriptor.isDataDescriptor()) {
2631             // 10. Else, if IsDataDescriptor(current) and IsDataDescriptor(Desc) are both true, then
2632             // 10.a. If the [[Configurable]] field of current is false, then
2633             if (!current.configurable() &amp;&amp; !current.writable()) {
2634                 // 10.a.i. Reject, if the [[Writable]] field of current is false and the [[Writable]] field of Desc is true.
2635                 if (descriptor.writable())
2636                     return typeError(exec, scope, throwException, UnconfigurablePropertyChangeWritabilityError);
2637                 // 10.a.ii. If the [[Writable]] field of current is false, then
2638                 // 10.a.ii.1. Reject, if the [[Value]] field of Desc is present and SameValue(Desc.[[Value]], current.[[Value]]) is false.
2639                 if (descriptor.value() &amp;&amp; !sameValue(exec, descriptor.value(), current.value()))
2640                     return typeError(exec, scope, throwException, ReadonlyPropertyChangeError);
2641             }
2642             // 10.b. else, the [[Configurable]] field of current is true, so any change is acceptable.
2643         } else {
2644             ASSERT(current.isAccessorDescriptor() &amp;&amp; current.getterPresent() &amp;&amp; current.setterPresent());
2645             // 11. Else, IsAccessorDescriptor(current) and IsAccessorDescriptor(Desc) are both true so, if the [[Configurable]] field of current is false, then
2646             if (!current.configurable()) {
2647                 // 11.i. Reject, if the [[Set]] field of Desc is present and SameValue(Desc.[[Set]], current.[[Set]]) is false.
2648                 if (descriptor.setterPresent() &amp;&amp; descriptor.setter() != current.setter())
2649                     return typeError(exec, scope, throwException, &quot;Attempting to change the setter of an unconfigurable property.&quot;_s);
2650                 // 11.ii. Reject, if the [[Get]] field of Desc is present and SameValue(Desc.[[Get]], current.[[Get]]) is false.
2651                 if (descriptor.getterPresent() &amp;&amp; descriptor.getter() != current.getter())
2652                     return typeError(exec, scope, throwException, &quot;Attempting to change the getter of an unconfigurable property.&quot;_s);
2653             }
2654         }
2655     }
2656 
2657     // 12. For each attribute field of Desc that is present, set the correspondingly named attribute of the property named P of object O to the value of the field.
2658     putIndexedDescriptor(exec, map, entryInMap, descriptor, current);
2659     // 13. Return true.
2660     return true;
2661 }
2662 
2663 SparseArrayValueMap* JSObject::allocateSparseIndexMap(VM&amp; vm)
2664 {
2665     SparseArrayValueMap* result = SparseArrayValueMap::create(vm);
2666     arrayStorage()-&gt;m_sparseMap.set(vm, this, result);
2667     return result;
2668 }
2669 
2670 void JSObject::deallocateSparseIndexMap()
2671 {
2672     if (ArrayStorage* arrayStorage = arrayStorageOrNull())
2673         arrayStorage-&gt;m_sparseMap.clear();
2674 }
2675 
2676 bool JSObject::attemptToInterceptPutByIndexOnHoleForPrototype(ExecState* exec, JSValue thisValue, unsigned i, JSValue value, bool shouldThrow, bool&amp; putResult)
2677 {
2678     VM&amp; vm = exec-&gt;vm();
<a name="33" id="anc33"></a>

2679     for (JSObject* current = this; ;) {
2680         // This has the same behavior with respect to prototypes as JSObject::put(). It only
2681         // allows a prototype to intercept a put if (a) the prototype declares the property
2682         // we&#39;re after rather than intercepting it via an override of JSObject::put(), and
2683         // (b) that property is declared as ReadOnly or Accessor.
2684 
2685         ArrayStorage* storage = current-&gt;arrayStorageOrNull();
2686         if (storage &amp;&amp; storage-&gt;m_sparseMap) {
2687             SparseArrayValueMap::iterator iter = storage-&gt;m_sparseMap-&gt;find(i);
2688             if (iter != storage-&gt;m_sparseMap-&gt;notFound() &amp;&amp; (iter-&gt;value.attributes() &amp; (PropertyAttribute::Accessor | PropertyAttribute::ReadOnly))) {
<a name="34" id="anc34"></a>
2689                 putResult = iter-&gt;value.put(exec, thisValue, storage-&gt;m_sparseMap.get(), value, shouldThrow);
2690                 return true;
2691             }
2692         }
2693 
2694         if (current-&gt;type() == ProxyObjectType) {
<a name="35" id="anc35"></a>
2695             ProxyObject* proxy = jsCast&lt;ProxyObject*&gt;(current);
2696             putResult = proxy-&gt;putByIndexCommon(exec, thisValue, i, value, shouldThrow);
2697             return true;
2698         }
2699 
<a name="36" id="anc36"></a><span class="line-modified">2700         JSValue prototypeValue = current-&gt;getPrototypeDirect(vm);</span>

2701         if (prototypeValue.isNull())
2702             return false;
2703 
2704         current = asObject(prototypeValue);
2705     }
2706 }
2707 
2708 bool JSObject::attemptToInterceptPutByIndexOnHole(ExecState* exec, unsigned i, JSValue value, bool shouldThrow, bool&amp; putResult)
2709 {
<a name="37" id="anc37"></a><span class="line-modified">2710     JSValue prototypeValue = getPrototypeDirect(exec-&gt;vm());</span>




2711     if (prototypeValue.isNull())
2712         return false;
2713 
<a name="38" id="anc38"></a><span class="line-modified">2714     return asObject(prototypeValue)-&gt;attemptToInterceptPutByIndexOnHoleForPrototype(exec, this, i, value, shouldThrow, putResult);</span>
2715 }
2716 
2717 template&lt;IndexingType indexingShape&gt;
2718 bool JSObject::putByIndexBeyondVectorLengthWithoutAttributes(ExecState* exec, unsigned i, JSValue value)
2719 {
2720     VM&amp; vm = exec-&gt;vm();
2721     auto scope = DECLARE_THROW_SCOPE(vm);
2722 
2723     RELEASE_ASSERT_WITH_SECURITY_IMPLICATION(!isCopyOnWrite(indexingMode()));
2724     ASSERT((indexingType() &amp; IndexingShapeMask) == indexingShape);
2725     ASSERT(!indexingShouldBeSparse(vm));
2726 
2727     Butterfly* butterfly = m_butterfly.get();
2728 
2729     // For us to get here, the index is either greater than the public length, or greater than
2730     // or equal to the vector length.
2731     ASSERT(i &gt;= butterfly-&gt;vectorLength());
2732 
2733     if (i &gt; MAX_STORAGE_VECTOR_INDEX
2734         || (i &gt;= MIN_SPARSE_ARRAY_INDEX &amp;&amp; !isDenseEnoughForVector(i, countElements&lt;indexingShape&gt;(butterfly)))
2735         || indexIsSufficientlyBeyondLengthForSparseMap(i, butterfly-&gt;vectorLength())) {
2736         ASSERT(i &lt;= MAX_ARRAY_INDEX);
2737         ensureArrayStorageSlow(vm);
2738         SparseArrayValueMap* map = allocateSparseIndexMap(vm);
2739         bool result = map-&gt;putEntry(exec, this, i, value, false);
2740         RETURN_IF_EXCEPTION(scope, false);
2741         ASSERT(i &gt;= arrayStorage()-&gt;length());
2742         arrayStorage()-&gt;setLength(i + 1);
2743         return result;
2744     }
2745 
2746     if (!ensureLength(vm, i + 1)) {
2747         throwOutOfMemoryError(exec, scope);
2748         return false;
2749     }
2750     butterfly = m_butterfly.get();
2751 
2752     RELEASE_ASSERT(i &lt; butterfly-&gt;vectorLength());
2753     switch (indexingShape) {
2754     case Int32Shape:
2755         ASSERT(value.isInt32());
2756         butterfly-&gt;contiguous().at(this, i).setWithoutWriteBarrier(value);
2757         return true;
2758 
2759     case DoubleShape: {
2760         ASSERT(value.isNumber());
2761         double valueAsDouble = value.asNumber();
2762         ASSERT(valueAsDouble == valueAsDouble);
2763         butterfly-&gt;contiguousDouble().at(this, i) = valueAsDouble;
2764         return true;
2765     }
2766 
2767     case ContiguousShape:
2768         butterfly-&gt;contiguous().at(this, i).set(vm, this, value);
2769         return true;
2770 
2771     default:
2772         CRASH();
2773         return false;
2774     }
2775 }
2776 
2777 // Explicit instantiations needed by JSArray.cpp.
2778 template bool JSObject::putByIndexBeyondVectorLengthWithoutAttributes&lt;Int32Shape&gt;(ExecState*, unsigned, JSValue);
2779 template bool JSObject::putByIndexBeyondVectorLengthWithoutAttributes&lt;DoubleShape&gt;(ExecState*, unsigned, JSValue);
2780 template bool JSObject::putByIndexBeyondVectorLengthWithoutAttributes&lt;ContiguousShape&gt;(ExecState*, unsigned, JSValue);
2781 
2782 bool JSObject::putByIndexBeyondVectorLengthWithArrayStorage(ExecState* exec, unsigned i, JSValue value, bool shouldThrow, ArrayStorage* storage)
2783 {
2784     VM&amp; vm = exec-&gt;vm();
2785     auto scope = DECLARE_THROW_SCOPE(vm);
2786 
2787     ASSERT(!isCopyOnWrite(indexingMode()));
2788     // i should be a valid array index that is outside of the current vector.
2789     ASSERT(i &lt;= MAX_ARRAY_INDEX);
2790     ASSERT(i &gt;= storage-&gt;vectorLength());
2791 
2792     SparseArrayValueMap* map = storage-&gt;m_sparseMap.get();
2793 
2794     // First, handle cases where we don&#39;t currently have a sparse map.
2795     if (LIKELY(!map)) {
2796         // If the array is not extensible, we should have entered dictionary mode, and created the sparse map.
2797         ASSERT(isStructureExtensible(vm));
2798 
2799         // Update m_length if necessary.
2800         if (i &gt;= storage-&gt;length())
2801             storage-&gt;setLength(i + 1);
2802 
2803         // Check that it is sensible to still be using a vector, and then try to grow the vector.
2804         if (LIKELY(!indexIsSufficientlyBeyondLengthForSparseMap(i, storage-&gt;vectorLength())
2805             &amp;&amp; isDenseEnoughForVector(i, storage-&gt;m_numValuesInVector)
2806             &amp;&amp; increaseVectorLength(vm, i + 1))) {
2807             // success! - reread m_storage since it has likely been reallocated, and store to the vector.
2808             storage = arrayStorage();
2809             storage-&gt;m_vector[i].set(vm, this, value);
2810             ++storage-&gt;m_numValuesInVector;
2811             return true;
2812         }
2813         // We don&#39;t want to, or can&#39;t use a vector to hold this property - allocate a sparse map &amp; add the value.
2814         map = allocateSparseIndexMap(vm);
2815         RELEASE_AND_RETURN(scope, map-&gt;putEntry(exec, this, i, value, shouldThrow));
2816     }
2817 
2818     // Update m_length if necessary.
2819     unsigned length = storage-&gt;length();
2820     if (i &gt;= length) {
2821         // Prohibit growing the array if length is not writable.
2822         if (map-&gt;lengthIsReadOnly() || !isStructureExtensible(vm))
2823             return typeError(exec, scope, shouldThrow, ReadonlyPropertyWriteError);
2824         length = i + 1;
2825         storage-&gt;setLength(length);
2826     }
2827 
2828     // We are currently using a map - check whether we still want to be doing so.
2829     // We will continue  to use a sparse map if SparseMode is set, a vector would be too sparse, or if allocation fails.
2830     unsigned numValuesInArray = storage-&gt;m_numValuesInVector + map-&gt;size();
2831     if (map-&gt;sparseMode() || !isDenseEnoughForVector(length, numValuesInArray) || !increaseVectorLength(vm, length))
2832         RELEASE_AND_RETURN(scope, map-&gt;putEntry(exec, this, i, value, shouldThrow));
2833 
2834     // Reread m_storage after increaseVectorLength, update m_numValuesInVector.
2835     storage = arrayStorage();
2836     storage-&gt;m_numValuesInVector = numValuesInArray;
2837 
2838     // Copy all values from the map into the vector, and delete the map.
2839     WriteBarrier&lt;Unknown&gt;* vector = storage-&gt;m_vector;
2840     SparseArrayValueMap::const_iterator end = map-&gt;end();
2841     for (SparseArrayValueMap::const_iterator it = map-&gt;begin(); it != end; ++it)
2842         vector[it-&gt;key].set(vm, this, it-&gt;value.getNonSparseMode());
2843     deallocateSparseIndexMap();
2844 
2845     // Store the new property into the vector.
2846     WriteBarrier&lt;Unknown&gt;&amp; valueSlot = vector[i];
2847     if (!valueSlot)
2848         ++storage-&gt;m_numValuesInVector;
2849     valueSlot.set(vm, this, value);
2850     return true;
2851 }
2852 
2853 bool JSObject::putByIndexBeyondVectorLength(ExecState* exec, unsigned i, JSValue value, bool shouldThrow)
2854 {
2855     VM&amp; vm = exec-&gt;vm();
<a name="39" id="anc39"></a>
2856 
2857     RELEASE_ASSERT_WITH_SECURITY_IMPLICATION(!isCopyOnWrite(indexingMode()));
2858 
2859     // i should be a valid array index that is outside of the current vector.
2860     ASSERT(i &lt;= MAX_ARRAY_INDEX);
2861 
2862     switch (indexingType()) {
2863     case ALL_BLANK_INDEXING_TYPES: {
2864         if (indexingShouldBeSparse(vm)) {
<a name="40" id="anc40"></a><span class="line-modified">2865             return putByIndexBeyondVectorLengthWithArrayStorage(</span>
2866                 exec, i, value, shouldThrow,
<a name="41" id="anc41"></a><span class="line-modified">2867                 ensureArrayStorageExistsAndEnterDictionaryIndexingMode(vm));</span>
2868         }
2869         if (indexIsSufficientlyBeyondLengthForSparseMap(i, 0) || i &gt;= MIN_SPARSE_ARRAY_INDEX) {
<a name="42" id="anc42"></a><span class="line-modified">2870             return putByIndexBeyondVectorLengthWithArrayStorage(</span>
<span class="line-removed">2871                 exec, i, value, shouldThrow, createArrayStorage(vm, 0, 0));</span>
2872         }
2873         if (needsSlowPutIndexing(vm)) {
2874             // Convert the indexing type to the SlowPutArrayStorage and retry.
2875             createArrayStorage(vm, i + 1, getNewVectorLength(vm, 0, 0, 0, i + 1));
<a name="43" id="anc43"></a><span class="line-modified">2876             return putByIndex(this, exec, i, value, shouldThrow);</span>
2877         }
2878 
2879         createInitialForValueAndSet(vm, i, value);
2880         return true;
2881     }
2882 
2883     case ALL_UNDECIDED_INDEXING_TYPES: {
2884         CRASH();
2885         break;
2886     }
2887 
2888     case ALL_INT32_INDEXING_TYPES:
<a name="44" id="anc44"></a><span class="line-modified">2889         return putByIndexBeyondVectorLengthWithoutAttributes&lt;Int32Shape&gt;(exec, i, value);</span>
2890 
2891     case ALL_DOUBLE_INDEXING_TYPES:
<a name="45" id="anc45"></a><span class="line-modified">2892         return putByIndexBeyondVectorLengthWithoutAttributes&lt;DoubleShape&gt;(exec, i, value);</span>
2893 
2894     case ALL_CONTIGUOUS_INDEXING_TYPES:
<a name="46" id="anc46"></a><span class="line-modified">2895         return putByIndexBeyondVectorLengthWithoutAttributes&lt;ContiguousShape&gt;(exec, i, value);</span>
2896 
2897     case NonArrayWithSlowPutArrayStorage:
2898     case ArrayWithSlowPutArrayStorage: {
2899         // No own property present in the vector, but there might be in the sparse map!
2900         SparseArrayValueMap* map = arrayStorage()-&gt;m_sparseMap.get();
2901         bool putResult = false;
<a name="47" id="anc47"></a><span class="line-modified">2902         if (!(map &amp;&amp; map-&gt;contains(i)) &amp;&amp; attemptToInterceptPutByIndexOnHole(exec, i, value, shouldThrow, putResult))</span>
<span class="line-modified">2903             return putResult;</span>




2904         FALLTHROUGH;
2905     }
2906 
2907     case NonArrayWithArrayStorage:
2908     case ArrayWithArrayStorage:
<a name="48" id="anc48"></a><span class="line-modified">2909         return putByIndexBeyondVectorLengthWithArrayStorage(exec, i, value, shouldThrow, arrayStorage());</span>
2910 
2911     default:
2912         RELEASE_ASSERT_NOT_REACHED();
2913     }
2914     return false;
2915 }
2916 
2917 bool JSObject::putDirectIndexBeyondVectorLengthWithArrayStorage(ExecState* exec, unsigned i, JSValue value, unsigned attributes, PutDirectIndexMode mode, ArrayStorage* storage)
2918 {
2919     VM&amp; vm = exec-&gt;vm();
2920     auto scope = DECLARE_THROW_SCOPE(vm);
2921 
2922     // i should be a valid array index that is outside of the current vector.
2923     ASSERT(hasAnyArrayStorage(indexingType()));
2924     ASSERT(arrayStorage() == storage);
2925     ASSERT(i &gt;= storage-&gt;vectorLength() || attributes);
2926     ASSERT(i &lt;= MAX_ARRAY_INDEX);
2927 
2928     SparseArrayValueMap* map = storage-&gt;m_sparseMap.get();
2929 
2930     // First, handle cases where we don&#39;t currently have a sparse map.
2931     if (LIKELY(!map)) {
2932         // If the array is not extensible, we should have entered dictionary mode, and created the spare map.
2933         ASSERT(isStructureExtensible(vm));
2934 
2935         // Update m_length if necessary.
2936         if (i &gt;= storage-&gt;length())
2937             storage-&gt;setLength(i + 1);
2938 
2939         // Check that it is sensible to still be using a vector, and then try to grow the vector.
2940         if (LIKELY(
2941                 !attributes
2942                 &amp;&amp; (isDenseEnoughForVector(i, storage-&gt;m_numValuesInVector))
2943                 &amp;&amp; !indexIsSufficientlyBeyondLengthForSparseMap(i, storage-&gt;vectorLength()))
2944                 &amp;&amp; increaseVectorLength(vm, i + 1)) {
2945             // success! - reread m_storage since it has likely been reallocated, and store to the vector.
2946             storage = arrayStorage();
2947             storage-&gt;m_vector[i].set(vm, this, value);
2948             ++storage-&gt;m_numValuesInVector;
2949             return true;
2950         }
2951         // We don&#39;t want to, or can&#39;t use a vector to hold this property - allocate a sparse map &amp; add the value.
2952         map = allocateSparseIndexMap(vm);
2953         RELEASE_AND_RETURN(scope, map-&gt;putDirect(exec, this, i, value, attributes, mode));
2954     }
2955 
2956     // Update m_length if necessary.
2957     unsigned length = storage-&gt;length();
2958     if (i &gt;= length) {
2959         if (mode != PutDirectIndexLikePutDirect) {
2960             // Prohibit growing the array if length is not writable.
2961             if (map-&gt;lengthIsReadOnly())
2962                 return typeError(exec, scope, mode == PutDirectIndexShouldThrow, ReadonlyPropertyWriteError);
2963             if (!isStructureExtensible(vm))
2964                 return typeError(exec, scope, mode == PutDirectIndexShouldThrow, NonExtensibleObjectPropertyDefineError);
2965         }
2966         length = i + 1;
2967         storage-&gt;setLength(length);
2968     }
2969 
2970     // We are currently using a map - check whether we still want to be doing so.
2971     // We will continue  to use a sparse map if SparseMode is set, a vector would be too sparse, or if allocation fails.
2972     unsigned numValuesInArray = storage-&gt;m_numValuesInVector + map-&gt;size();
2973     if (map-&gt;sparseMode() || attributes || !isDenseEnoughForVector(length, numValuesInArray) || !increaseVectorLength(vm, length))
2974         RELEASE_AND_RETURN(scope, map-&gt;putDirect(exec, this, i, value, attributes, mode));
2975 
2976     // Reread m_storage after increaseVectorLength, update m_numValuesInVector.
2977     storage = arrayStorage();
2978     storage-&gt;m_numValuesInVector = numValuesInArray;
2979 
2980     // Copy all values from the map into the vector, and delete the map.
2981     WriteBarrier&lt;Unknown&gt;* vector = storage-&gt;m_vector;
2982     SparseArrayValueMap::const_iterator end = map-&gt;end();
2983     for (SparseArrayValueMap::const_iterator it = map-&gt;begin(); it != end; ++it)
2984         vector[it-&gt;key].set(vm, this, it-&gt;value.getNonSparseMode());
2985     deallocateSparseIndexMap();
2986 
2987     // Store the new property into the vector.
2988     WriteBarrier&lt;Unknown&gt;&amp; valueSlot = vector[i];
2989     if (!valueSlot)
2990         ++storage-&gt;m_numValuesInVector;
2991     valueSlot.set(vm, this, value);
2992     return true;
2993 }
2994 
2995 bool JSObject::putDirectIndexSlowOrBeyondVectorLength(ExecState* exec, unsigned i, JSValue value, unsigned attributes, PutDirectIndexMode mode)
2996 {
2997     VM&amp; vm = exec-&gt;vm();
2998     ASSERT(!value.isCustomGetterSetter());
2999 
3000     if (!canDoFastPutDirectIndex(vm, this)) {
3001         PropertyDescriptor descriptor;
3002         descriptor.setDescriptor(value, attributes);
<a name="49" id="anc49"></a><span class="line-modified">3003         return methodTable(vm)-&gt;defineOwnProperty(this, exec, Identifier::from(exec, i), descriptor, mode == PutDirectIndexShouldThrow);</span>
3004     }
3005 
3006     // i should be a valid array index that is outside of the current vector.
3007     ASSERT(i &lt;= MAX_ARRAY_INDEX);
3008 
3009     if (attributes &amp; (PropertyAttribute::ReadOnly | PropertyAttribute::Accessor))
3010         notifyPresenceOfIndexedAccessors(vm);
3011 
3012     switch (indexingType()) {
3013     case ALL_BLANK_INDEXING_TYPES: {
3014         if (indexingShouldBeSparse(vm) || attributes) {
3015             return putDirectIndexBeyondVectorLengthWithArrayStorage(
3016                 exec, i, value, attributes, mode,
3017                 ensureArrayStorageExistsAndEnterDictionaryIndexingMode(vm));
3018         }
<a name="50" id="anc50"></a><span class="line-modified">3019         if (i &gt;= MIN_SPARSE_ARRAY_INDEX) {</span>
3020             return putDirectIndexBeyondVectorLengthWithArrayStorage(
3021                 exec, i, value, attributes, mode, createArrayStorage(vm, 0, 0));
3022         }
3023         if (needsSlowPutIndexing(vm)) {
3024             ArrayStorage* storage = createArrayStorage(vm, i + 1, getNewVectorLength(vm, 0, 0, 0, i + 1));
3025             storage-&gt;m_vector[i].set(vm, this, value);
3026             storage-&gt;m_numValuesInVector++;
3027             return true;
3028         }
3029 
3030         createInitialForValueAndSet(vm, i, value);
3031         return true;
3032     }
3033 
3034     case ALL_UNDECIDED_INDEXING_TYPES: {
3035         convertUndecidedForValue(vm, value);
3036         // Reloop.
3037         return putDirectIndex(exec, i, value, attributes, mode);
3038     }
3039 
3040     case ALL_INT32_INDEXING_TYPES: {
3041         ASSERT(!indexingShouldBeSparse(vm));
3042         if (attributes)
3043             return putDirectIndexBeyondVectorLengthWithArrayStorage(exec, i, value, attributes, mode, ensureArrayStorageExistsAndEnterDictionaryIndexingMode(vm));
3044         if (!value.isInt32()) {
3045             convertInt32ForValue(vm, value);
3046             return putDirectIndexSlowOrBeyondVectorLength(exec, i, value, attributes, mode);
3047         }
3048         putByIndexBeyondVectorLengthWithoutAttributes&lt;Int32Shape&gt;(exec, i, value);
3049         return true;
3050     }
3051 
3052     case ALL_DOUBLE_INDEXING_TYPES: {
3053         ASSERT(!indexingShouldBeSparse(vm));
3054         if (attributes)
3055             return putDirectIndexBeyondVectorLengthWithArrayStorage(exec, i, value, attributes, mode, ensureArrayStorageExistsAndEnterDictionaryIndexingMode(vm));
3056         if (!value.isNumber()) {
3057             convertDoubleToContiguous(vm);
3058             return putDirectIndexSlowOrBeyondVectorLength(exec, i, value, attributes, mode);
3059         }
3060         double valueAsDouble = value.asNumber();
3061         if (valueAsDouble != valueAsDouble) {
3062             convertDoubleToContiguous(vm);
3063             return putDirectIndexSlowOrBeyondVectorLength(exec, i, value, attributes, mode);
3064         }
3065         putByIndexBeyondVectorLengthWithoutAttributes&lt;DoubleShape&gt;(exec, i, value);
3066         return true;
3067     }
3068 
3069     case ALL_CONTIGUOUS_INDEXING_TYPES: {
3070         ASSERT(!indexingShouldBeSparse(vm));
3071         if (attributes)
3072             return putDirectIndexBeyondVectorLengthWithArrayStorage(exec, i, value, attributes, mode, ensureArrayStorageExistsAndEnterDictionaryIndexingMode(vm));
3073         putByIndexBeyondVectorLengthWithoutAttributes&lt;ContiguousShape&gt;(exec, i, value);
3074         return true;
3075     }
3076 
3077     case ALL_ARRAY_STORAGE_INDEXING_TYPES:
3078         if (attributes)
3079             return putDirectIndexBeyondVectorLengthWithArrayStorage(exec, i, value, attributes, mode, ensureArrayStorageExistsAndEnterDictionaryIndexingMode(vm));
3080         return putDirectIndexBeyondVectorLengthWithArrayStorage(exec, i, value, attributes, mode, arrayStorage());
3081 
3082     default:
3083         RELEASE_ASSERT_NOT_REACHED();
3084         return false;
3085     }
3086 }
3087 
3088 bool JSObject::putDirectNativeIntrinsicGetter(VM&amp; vm, JSGlobalObject* globalObject, Identifier name, NativeFunction nativeFunction, Intrinsic intrinsic, unsigned attributes)
3089 {
3090     JSFunction* function = JSFunction::create(vm, globalObject, 0, makeString(&quot;get &quot;, name.string()), nativeFunction, intrinsic);
3091     GetterSetter* accessor = GetterSetter::create(vm, globalObject, function, nullptr);
3092     return putDirectNonIndexAccessor(vm, name, accessor, attributes);
3093 }
3094 
<a name="51" id="anc51"></a>






3095 bool JSObject::putDirectNativeFunction(VM&amp; vm, JSGlobalObject* globalObject, const PropertyName&amp; propertyName, unsigned functionLength, NativeFunction nativeFunction, Intrinsic intrinsic, unsigned attributes)
3096 {
3097     StringImpl* name = propertyName.publicName();
3098     if (!name)
3099         name = vm.propertyNames-&gt;anonymous.impl();
3100     ASSERT(name);
3101 
3102     JSFunction* function = JSFunction::create(vm, globalObject, functionLength, name, nativeFunction, intrinsic);
3103     return putDirect(vm, propertyName, function, attributes);
3104 }
3105 
3106 bool JSObject::putDirectNativeFunction(VM&amp; vm, JSGlobalObject* globalObject, const PropertyName&amp; propertyName, unsigned functionLength, NativeFunction nativeFunction, Intrinsic intrinsic, const DOMJIT::Signature* signature, unsigned attributes)
3107 {
3108     StringImpl* name = propertyName.publicName();
3109     if (!name)
3110         name = vm.propertyNames-&gt;anonymous.impl();
3111     ASSERT(name);
3112 
3113     JSFunction* function = JSFunction::create(vm, globalObject, functionLength, name, nativeFunction, intrinsic, callHostFunctionAsConstructor, signature);
3114     return putDirect(vm, propertyName, function, attributes);
3115 }
3116 
3117 void JSObject::putDirectNativeFunctionWithoutTransition(VM&amp; vm, JSGlobalObject* globalObject, const PropertyName&amp; propertyName, unsigned functionLength, NativeFunction nativeFunction, Intrinsic intrinsic, unsigned attributes)
3118 {
3119     StringImpl* name = propertyName.publicName();
3120     if (!name)
3121         name = vm.propertyNames-&gt;anonymous.impl();
3122     ASSERT(name);
3123     JSFunction* function = JSFunction::create(vm, globalObject, functionLength, name, nativeFunction, intrinsic);
3124     putDirectWithoutTransition(vm, propertyName, function, attributes);
3125 }
3126 
3127 JSFunction* JSObject::putDirectBuiltinFunction(VM&amp; vm, JSGlobalObject* globalObject, const PropertyName&amp; propertyName, FunctionExecutable* functionExecutable, unsigned attributes)
3128 {
3129     StringImpl* name = propertyName.publicName();
3130     if (!name)
3131         name = vm.propertyNames-&gt;anonymous.impl();
3132     ASSERT(name);
3133     JSFunction* function = JSFunction::create(vm, static_cast&lt;FunctionExecutable*&gt;(functionExecutable), globalObject);
3134     putDirect(vm, propertyName, function, attributes);
3135     return function;
3136 }
3137 
3138 JSFunction* JSObject::putDirectBuiltinFunctionWithoutTransition(VM&amp; vm, JSGlobalObject* globalObject, const PropertyName&amp; propertyName, FunctionExecutable* functionExecutable, unsigned attributes)
3139 {
3140     JSFunction* function = JSFunction::create(vm, static_cast&lt;FunctionExecutable*&gt;(functionExecutable), globalObject);
3141     putDirectWithoutTransition(vm, propertyName, function, attributes);
3142     return function;
3143 }
3144 
3145 // NOTE: This method is for ArrayStorage vectors.
3146 ALWAYS_INLINE unsigned JSObject::getNewVectorLength(VM&amp; vm, unsigned indexBias, unsigned currentVectorLength, unsigned currentLength, unsigned desiredLength)
3147 {
3148     ASSERT(desiredLength &lt;= MAX_STORAGE_VECTOR_LENGTH);
3149 
3150     unsigned increasedLength;
3151     unsigned maxInitLength = std::min(currentLength, 100000U);
3152 
3153     if (desiredLength &lt; maxInitLength)
3154         increasedLength = maxInitLength;
3155     else if (!currentVectorLength)
3156         increasedLength = std::max(desiredLength, lastArraySize);
3157     else {
3158         increasedLength = timesThreePlusOneDividedByTwo(desiredLength);
3159     }
3160 
3161     ASSERT(increasedLength &gt;= desiredLength);
3162 
3163     lastArraySize = std::min(increasedLength, FIRST_ARRAY_STORAGE_VECTOR_GROW);
3164 
3165     return ArrayStorage::optimalVectorLength(
3166         indexBias, structure(vm)-&gt;outOfLineCapacity(),
3167         std::min(increasedLength, MAX_STORAGE_VECTOR_LENGTH));
3168 }
3169 
3170 ALWAYS_INLINE unsigned JSObject::getNewVectorLength(VM&amp; vm, unsigned desiredLength)
3171 {
3172     unsigned indexBias = 0;
3173     unsigned vectorLength = 0;
3174     unsigned length = 0;
3175 
3176     if (hasIndexedProperties(indexingType())) {
3177         if (ArrayStorage* storage = arrayStorageOrNull())
3178             indexBias = storage-&gt;m_indexBias;
3179         vectorLength = m_butterfly-&gt;vectorLength();
3180         length = m_butterfly-&gt;publicLength();
3181     }
3182 
3183     return getNewVectorLength(vm, indexBias, vectorLength, length, desiredLength);
3184 }
3185 
3186 template&lt;IndexingType indexingShape&gt;
3187 unsigned JSObject::countElements(Butterfly* butterfly)
3188 {
3189     unsigned numValues = 0;
3190     for (unsigned i = butterfly-&gt;publicLength(); i--;) {
3191         switch (indexingShape) {
3192         case Int32Shape:
3193         case ContiguousShape:
3194             if (butterfly-&gt;contiguous().at(this, i))
3195                 numValues++;
3196             break;
3197 
3198         case DoubleShape: {
3199             double value = butterfly-&gt;contiguousDouble().at(this, i);
3200             if (value == value)
3201                 numValues++;
3202             break;
3203         }
3204 
3205         default:
3206             CRASH();
3207         }
3208     }
3209     return numValues;
3210 }
3211 
3212 unsigned JSObject::countElements()
3213 {
3214     switch (indexingType()) {
3215     case ALL_BLANK_INDEXING_TYPES:
3216     case ALL_UNDECIDED_INDEXING_TYPES:
3217         return 0;
3218 
3219     case ALL_INT32_INDEXING_TYPES:
3220         return countElements&lt;Int32Shape&gt;(butterfly());
3221 
3222     case ALL_DOUBLE_INDEXING_TYPES:
3223         return countElements&lt;DoubleShape&gt;(butterfly());
3224 
3225     case ALL_CONTIGUOUS_INDEXING_TYPES:
3226         return countElements&lt;ContiguousShape&gt;(butterfly());
3227 
3228     default:
3229         CRASH();
3230         return 0;
3231     }
3232 }
3233 
3234 bool JSObject::increaseVectorLength(VM&amp; vm, unsigned newLength)
3235 {
3236     ArrayStorage* storage = arrayStorage();
3237 
3238     unsigned vectorLength = storage-&gt;vectorLength();
3239     unsigned availableVectorLength = storage-&gt;availableVectorLength(structure(vm), vectorLength);
3240     if (availableVectorLength &gt;= newLength) {
3241         // The cell was already big enough for the desired length!
3242         for (unsigned i = vectorLength; i &lt; availableVectorLength; ++i)
3243             storage-&gt;m_vector[i].clear();
3244         storage-&gt;setVectorLength(availableVectorLength);
3245         return true;
3246     }
3247 
3248     // This function leaves the array in an internally inconsistent state, because it does not move any values from sparse value map
3249     // to the vector. Callers have to account for that, because they can do it more efficiently.
3250     if (newLength &gt; MAX_STORAGE_VECTOR_LENGTH)
3251         return false;
3252 
3253     if (newLength &gt;= MIN_SPARSE_ARRAY_INDEX
3254         &amp;&amp; !isDenseEnoughForVector(newLength, storage-&gt;m_numValuesInVector))
3255         return false;
3256 
3257     unsigned indexBias = storage-&gt;m_indexBias;
3258     ASSERT(newLength &gt; vectorLength);
3259     unsigned newVectorLength = getNewVectorLength(vm, newLength);
3260 
3261     // Fast case - there is no precapacity. In these cases a realloc makes sense.
3262     Structure* structure = this-&gt;structure(vm);
3263     if (LIKELY(!indexBias)) {
3264         DeferGC deferGC(vm.heap);
3265         Butterfly* newButterfly = storage-&gt;butterfly()-&gt;growArrayRight(
3266             vm, this, structure, structure-&gt;outOfLineCapacity(), true,
3267             ArrayStorage::sizeFor(vectorLength), ArrayStorage::sizeFor(newVectorLength));
3268         if (!newButterfly)
3269             return false;
3270         for (unsigned i = vectorLength; i &lt; newVectorLength; ++i)
3271             newButterfly-&gt;arrayStorage()-&gt;m_vector[i].clear();
3272         newButterfly-&gt;arrayStorage()-&gt;setVectorLength(newVectorLength);
3273         setButterfly(vm, newButterfly);
3274         return true;
3275     }
3276 
3277     // Remove some, but not all of the precapacity. Atomic decay, &amp; capped to not overflow array length.
3278     DeferGC deferGC(vm.heap);
3279     unsigned newIndexBias = std::min(indexBias &gt;&gt; 1, MAX_STORAGE_VECTOR_LENGTH - newVectorLength);
3280     Butterfly* newButterfly = storage-&gt;butterfly()-&gt;resizeArray(
3281         vm, this,
3282         structure-&gt;outOfLineCapacity(), true, ArrayStorage::sizeFor(vectorLength),
3283         newIndexBias, true, ArrayStorage::sizeFor(newVectorLength));
3284     if (!newButterfly)
3285         return false;
3286     for (unsigned i = vectorLength; i &lt; newVectorLength; ++i)
3287         newButterfly-&gt;arrayStorage()-&gt;m_vector[i].clear();
3288     newButterfly-&gt;arrayStorage()-&gt;setVectorLength(newVectorLength);
3289     newButterfly-&gt;arrayStorage()-&gt;m_indexBias = newIndexBias;
3290     setButterfly(vm, newButterfly);
3291     return true;
3292 }
3293 
3294 bool JSObject::ensureLengthSlow(VM&amp; vm, unsigned length)
3295 {
3296     if (isCopyOnWrite(indexingMode())) {
3297         convertFromCopyOnWrite(vm);
3298         if (m_butterfly-&gt;vectorLength() &gt;= length)
3299             return true;
3300     }
3301 
3302     Butterfly* butterfly = this-&gt;butterfly();
3303 
3304     ASSERT(length &lt;= MAX_STORAGE_VECTOR_LENGTH);
3305     ASSERT(hasContiguous(indexingType()) || hasInt32(indexingType()) || hasDouble(indexingType()) || hasUndecided(indexingType()));
3306     ASSERT(length &gt; butterfly-&gt;vectorLength());
3307 
3308     unsigned oldVectorLength = butterfly-&gt;vectorLength();
3309     unsigned newVectorLength;
3310 
3311     Structure* structure = this-&gt;structure(vm);
3312     unsigned propertyCapacity = structure-&gt;outOfLineCapacity();
3313 
<a name="52" id="anc52"></a>

3314     unsigned availableOldLength =
3315         Butterfly::availableContiguousVectorLength(propertyCapacity, oldVectorLength);
3316     Butterfly* newButterfly = nullptr;
3317     if (availableOldLength &gt;= length) {
3318         // This is the case where someone else selected a vector length that caused internal
3319         // fragmentation. If we did our jobs right, this would never happen. But I bet we will mess
3320         // this up, so this defense should stay.
3321         newVectorLength = availableOldLength;
3322     } else {
3323         newVectorLength = Butterfly::optimalContiguousVectorLength(
3324             propertyCapacity, std::min(length * 2, MAX_STORAGE_VECTOR_LENGTH));
<a name="53" id="anc53"></a><span class="line-modified">3325         butterfly = butterfly-&gt;growArrayRight(</span>
<span class="line-modified">3326             vm, this, structure, propertyCapacity, true,</span>
3327             oldVectorLength * sizeof(EncodedJSValue),
3328             newVectorLength * sizeof(EncodedJSValue));
3329         if (!butterfly)
3330             return false;
3331         newButterfly = butterfly;
3332     }
3333 
3334     if (hasDouble(indexingType())) {
3335         for (unsigned i = oldVectorLength; i &lt; newVectorLength; ++i)
3336             butterfly-&gt;indexingPayload&lt;double&gt;()[i] = PNaN;
3337     } else {
3338         for (unsigned i = oldVectorLength; i &lt; newVectorLength; ++i)
3339             butterfly-&gt;indexingPayload&lt;WriteBarrier&lt;Unknown&gt;&gt;()[i].clear();
3340     }
3341 
3342     if (newButterfly) {
3343         butterfly-&gt;setVectorLength(newVectorLength);
3344         WTF::storeStoreFence();
3345         m_butterfly.set(vm, this, newButterfly);
3346     } else {
3347         WTF::storeStoreFence();
3348         butterfly-&gt;setVectorLength(newVectorLength);
3349     }
3350 
3351     return true;
3352 }
3353 
3354 void JSObject::reallocateAndShrinkButterfly(VM&amp; vm, unsigned length)
3355 {
3356     ASSERT(length &lt;= MAX_STORAGE_VECTOR_LENGTH);
3357     ASSERT(hasContiguous(indexingType()) || hasInt32(indexingType()) || hasDouble(indexingType()) || hasUndecided(indexingType()));
3358     ASSERT(m_butterfly-&gt;vectorLength() &gt; length);
3359     ASSERT(!m_butterfly-&gt;indexingHeader()-&gt;preCapacity(structure(vm)));
3360 
3361     DeferGC deferGC(vm.heap);
3362     Butterfly* newButterfly = butterfly()-&gt;resizeArray(vm, this, structure(vm), 0, ArrayStorage::sizeFor(length));
3363     newButterfly-&gt;setVectorLength(length);
3364     newButterfly-&gt;setPublicLength(length);
3365     WTF::storeStoreFence();
3366     m_butterfly.set(vm, this, newButterfly);
3367 
3368 }
3369 
3370 Butterfly* JSObject::allocateMoreOutOfLineStorage(VM&amp; vm, size_t oldSize, size_t newSize)
3371 {
3372     ASSERT(newSize &gt; oldSize);
3373 
3374     // It&#39;s important that this function not rely on structure(), for the property
3375     // capacity, since we might have already mutated the structure in-place.
3376 
3377     return Butterfly::createOrGrowPropertyStorage(butterfly(), vm, this, structure(vm), oldSize, newSize);
3378 }
3379 
3380 static JSCustomGetterSetterFunction* getCustomGetterSetterFunctionForGetterSetter(ExecState* exec, PropertyName propertyName, CustomGetterSetter* getterSetter, JSCustomGetterSetterFunction::Type type)
3381 {
3382     VM&amp; vm = exec-&gt;vm();
3383     auto key = std::make_pair(getterSetter, (int)type);
3384     JSCustomGetterSetterFunction* customGetterSetterFunction = vm.customGetterSetterFunctionMap.get(key);
3385     if (!customGetterSetterFunction) {
3386         customGetterSetterFunction = JSCustomGetterSetterFunction::create(vm, exec-&gt;lexicalGlobalObject(), getterSetter, type, propertyName.publicName());
3387         vm.customGetterSetterFunctionMap.set(key, customGetterSetterFunction);
3388     }
3389     return customGetterSetterFunction;
3390 }
3391 
3392 bool JSObject::getOwnPropertyDescriptor(ExecState* exec, PropertyName propertyName, PropertyDescriptor&amp; descriptor)
3393 {
3394     VM&amp; vm = exec-&gt;vm();
<a name="54" id="anc54"></a>
3395     JSC::PropertySlot slot(this, PropertySlot::InternalMethodType::GetOwnProperty);
<a name="55" id="anc55"></a><span class="line-modified">3396     if (!methodTable(vm)-&gt;getOwnPropertySlot(this, exec, propertyName, slot))</span>



3397         return false;
3398 
<a name="56" id="anc56"></a>




3399     // DebuggerScope::getOwnPropertySlot() (and possibly others) may return attributes from the prototype chain
3400     // but getOwnPropertyDescriptor() should only work for &#39;own&#39; properties so we exit early if we detect that
3401     // the property is not an own property.
3402     if (slot.slotBase() != this &amp;&amp; slot.slotBase()) {
3403         JSProxy* jsProxy = jsDynamicCast&lt;JSProxy*&gt;(vm, this);
3404         if (!jsProxy || jsProxy-&gt;target() != slot.slotBase()) {
3405             // Try ProxyObject.
3406             ProxyObject* proxyObject = jsDynamicCast&lt;ProxyObject*&gt;(vm, this);
3407             if (!proxyObject || proxyObject-&gt;target() != slot.slotBase())
3408                 return false;
3409         }
3410     }
3411 
3412     if (slot.isAccessor())
3413         descriptor.setAccessorDescriptor(slot.getterSetter(), slot.attributes());
3414     else if (slot.attributes() &amp; PropertyAttribute::CustomAccessor) {
3415         descriptor.setCustomDescriptor(slot.attributes());
3416 
3417         JSObject* thisObject = this;
3418         if (auto* proxy = jsDynamicCast&lt;JSProxy*&gt;(vm, this))
3419             thisObject = proxy-&gt;target();
3420 
3421         CustomGetterSetter* getterSetter;
3422         if (slot.isCustomAccessor())
3423             getterSetter = slot.customGetterSetter();
3424         else {
3425             JSValue maybeGetterSetter = thisObject-&gt;getDirect(vm, propertyName);
3426             if (!maybeGetterSetter) {
3427                 thisObject-&gt;reifyAllStaticProperties(exec);
3428                 maybeGetterSetter = thisObject-&gt;getDirect(vm, propertyName);
3429             }
3430 
3431             ASSERT(maybeGetterSetter);
3432             getterSetter = jsDynamicCast&lt;CustomGetterSetter*&gt;(vm, maybeGetterSetter);
3433         }
3434         ASSERT(getterSetter);
3435         if (!getterSetter)
3436             return false;
3437 
3438         if (getterSetter-&gt;getter())
3439             descriptor.setGetter(getCustomGetterSetterFunctionForGetterSetter(exec, propertyName, getterSetter, JSCustomGetterSetterFunction::Type::Getter));
3440         if (getterSetter-&gt;setter())
3441             descriptor.setSetter(getCustomGetterSetterFunctionForGetterSetter(exec, propertyName, getterSetter, JSCustomGetterSetterFunction::Type::Setter));
<a name="57" id="anc57"></a><span class="line-modified">3442     } else</span>
<span class="line-modified">3443         descriptor.setDescriptor(slot.getValue(exec, propertyName), slot.attributes());</span>




3444     return true;
3445 }
3446 
3447 static bool putDescriptor(ExecState* exec, JSObject* target, PropertyName propertyName, const PropertyDescriptor&amp; descriptor, unsigned attributes, const PropertyDescriptor&amp; oldDescriptor)
3448 {
3449     VM&amp; vm = exec-&gt;vm();
3450     if (descriptor.isGenericDescriptor() || descriptor.isDataDescriptor()) {
3451         if (descriptor.isGenericDescriptor() &amp;&amp; oldDescriptor.isAccessorDescriptor()) {
3452             JSObject* getter = oldDescriptor.getterPresent() ? oldDescriptor.getterObject() : nullptr;
3453             JSObject* setter = oldDescriptor.setterPresent() ? oldDescriptor.setterObject() : nullptr;
3454             GetterSetter* accessor = GetterSetter::create(vm, exec-&gt;lexicalGlobalObject(), getter, setter);
3455             target-&gt;putDirectAccessor(exec, propertyName, accessor, attributes | PropertyAttribute::Accessor);
3456             return true;
3457         }
3458         JSValue newValue = jsUndefined();
3459         if (descriptor.value())
3460             newValue = descriptor.value();
3461         else if (oldDescriptor.value())
3462             newValue = oldDescriptor.value();
3463         target-&gt;putDirect(vm, propertyName, newValue, attributes &amp; ~PropertyAttribute::Accessor);
3464         if (attributes &amp; PropertyAttribute::ReadOnly)
3465             target-&gt;structure(vm)-&gt;setContainsReadOnlyProperties();
3466         return true;
3467     }
3468     attributes &amp;= ~PropertyAttribute::ReadOnly;
3469 
3470     JSObject* getter = descriptor.getterPresent()
3471         ? descriptor.getterObject() : oldDescriptor.getterPresent()
3472         ? oldDescriptor.getterObject() : nullptr;
3473     JSObject* setter = descriptor.setterPresent()
3474         ? descriptor.setterObject() : oldDescriptor.setterPresent()
3475         ? oldDescriptor.setterObject() : nullptr;
3476     GetterSetter* accessor = GetterSetter::create(vm, exec-&gt;lexicalGlobalObject(), getter, setter);
3477 
3478     target-&gt;putDirectAccessor(exec, propertyName, accessor, attributes | PropertyAttribute::Accessor);
3479     return true;
3480 }
3481 
3482 bool JSObject::putDirectMayBeIndex(ExecState* exec, PropertyName propertyName, JSValue value)
3483 {
3484     if (Optional&lt;uint32_t&gt; index = parseIndex(propertyName))
3485         return putDirectIndex(exec, index.value(), value);
3486     return putDirect(exec-&gt;vm(), propertyName, value);
3487 }
3488 
3489 // 9.1.6.3 of the spec
3490 // http://www.ecma-international.org/ecma-262/6.0/index.html#sec-validateandapplypropertydescriptor
3491 bool validateAndApplyPropertyDescriptor(ExecState* exec, JSObject* object, PropertyName propertyName, bool isExtensible,
3492     const PropertyDescriptor&amp; descriptor, bool isCurrentDefined, const PropertyDescriptor&amp; current, bool throwException)
3493 {
3494     VM&amp; vm = exec-&gt;vm();
3495     auto scope = DECLARE_THROW_SCOPE(vm);
3496 
3497     // If we have a new property we can just put it on normally
3498     // Step 2.
3499     if (!isCurrentDefined) {
3500         // unless extensions are prevented!
3501         // Step 2.a
3502         if (!isExtensible)
3503             return typeError(exec, scope, throwException, NonExtensibleObjectPropertyDefineError);
3504         if (!object)
3505             return true;
3506         // Step 2.c/d
3507         PropertyDescriptor oldDescriptor;
3508         oldDescriptor.setValue(jsUndefined());
3509         // FIXME: spec says to always return true here.
3510         return putDescriptor(exec, object, propertyName, descriptor, descriptor.attributes(), oldDescriptor);
3511     }
3512     // Step 3.
3513     if (descriptor.isEmpty())
3514         return true;
3515     // Step 4.
3516     bool isEqual = current.equalTo(exec, descriptor);
3517     RETURN_IF_EXCEPTION(scope, false);
3518     if (isEqual)
3519         return true;
3520 
3521     // Step 5.
3522     // Filter out invalid changes
3523     if (!current.configurable()) {
3524         if (descriptor.configurable())
3525             return typeError(exec, scope, throwException, UnconfigurablePropertyChangeConfigurabilityError);
3526         if (descriptor.enumerablePresent() &amp;&amp; descriptor.enumerable() != current.enumerable())
3527             return typeError(exec, scope, throwException, UnconfigurablePropertyChangeEnumerabilityError);
3528     }
3529 
3530     // Step 6.
3531     // A generic descriptor is simply changing the attributes of an existing property
3532     if (descriptor.isGenericDescriptor()) {
3533         if (!current.attributesEqual(descriptor) &amp;&amp; object) {
3534             object-&gt;methodTable(vm)-&gt;deleteProperty(object, exec, propertyName);
3535             RETURN_IF_EXCEPTION(scope, false);
3536             return putDescriptor(exec, object, propertyName, descriptor, descriptor.attributesOverridingCurrent(current), current);
3537         }
3538         return true;
3539     }
3540 
3541     // Step 7.
3542     // Changing between a normal property or an accessor property
3543     if (descriptor.isDataDescriptor() != current.isDataDescriptor()) {
3544         if (!current.configurable())
3545             return typeError(exec, scope, throwException, UnconfigurablePropertyChangeAccessMechanismError);
3546 
3547         if (!object)
3548             return true;
3549 
3550         object-&gt;methodTable(vm)-&gt;deleteProperty(object, exec, propertyName);
3551         RETURN_IF_EXCEPTION(scope, false);
3552         return putDescriptor(exec, object, propertyName, descriptor, descriptor.attributesOverridingCurrent(current), current);
3553     }
3554 
3555     // Step 8.
3556     // Changing the value and attributes of an existing property
3557     if (descriptor.isDataDescriptor()) {
3558         if (!current.configurable()) {
3559             if (!current.writable() &amp;&amp; descriptor.writable())
3560                 return typeError(exec, scope, throwException, UnconfigurablePropertyChangeWritabilityError);
3561             if (!current.writable()) {
3562                 if (descriptor.value() &amp;&amp; !sameValue(exec, current.value(), descriptor.value()))
3563                     return typeError(exec, scope, throwException, ReadonlyPropertyChangeError);
3564             }
3565         }
3566         if (current.attributesEqual(descriptor) &amp;&amp; !descriptor.value())
3567             return true;
3568         if (!object)
3569             return true;
3570         object-&gt;methodTable(vm)-&gt;deleteProperty(object, exec, propertyName);
3571         RETURN_IF_EXCEPTION(scope, false);
3572         return putDescriptor(exec, object, propertyName, descriptor, descriptor.attributesOverridingCurrent(current), current);
3573     }
3574 
3575     // Step 9.
3576     // Changing the accessor functions of an existing accessor property
3577     ASSERT(descriptor.isAccessorDescriptor());
3578     if (!current.configurable()) {
3579         if (descriptor.setterPresent() &amp;&amp; !(current.setterPresent() &amp;&amp; JSValue::strictEqual(exec, current.setter(), descriptor.setter())))
3580             return typeError(exec, scope, throwException, &quot;Attempting to change the setter of an unconfigurable property.&quot;_s);
3581         if (descriptor.getterPresent() &amp;&amp; !(current.getterPresent() &amp;&amp; JSValue::strictEqual(exec, current.getter(), descriptor.getter())))
3582             return typeError(exec, scope, throwException, &quot;Attempting to change the getter of an unconfigurable property.&quot;_s);
3583         if (current.attributes() &amp; PropertyAttribute::CustomAccessor)
3584             return typeError(exec, scope, throwException, UnconfigurablePropertyChangeAccessMechanismError);
3585     }
3586 
3587     // Step 10/11.
3588     if (!object)
3589         return true;
3590     JSValue accessor = object-&gt;getDirect(vm, propertyName);
3591     if (!accessor)
3592         return false;
3593     JSObject* getter = nullptr;
3594     JSObject* setter = nullptr;
3595     bool getterSetterChanged = false;
3596 
3597     if (accessor.isCustomGetterSetter()) {
3598         auto* customGetterSetter = jsCast&lt;CustomGetterSetter*&gt;(accessor);
3599         if (customGetterSetter-&gt;setter())
3600             setter = getCustomGetterSetterFunctionForGetterSetter(exec, propertyName, customGetterSetter, JSCustomGetterSetterFunction::Type::Setter);
3601         if (customGetterSetter-&gt;getter())
3602             getter = getCustomGetterSetterFunctionForGetterSetter(exec, propertyName, customGetterSetter, JSCustomGetterSetterFunction::Type::Getter);
3603     } else {
3604         ASSERT(accessor.isGetterSetter());
3605         auto* getterSetter = jsCast&lt;GetterSetter*&gt;(accessor);
3606         getter = getterSetter-&gt;getter();
3607         setter = getterSetter-&gt;setter();
3608     }
3609     if (descriptor.setterPresent()) {
3610         setter = descriptor.setterObject();
3611         getterSetterChanged = true;
3612     }
3613     if (descriptor.getterPresent()) {
3614         getter = descriptor.getterObject();
3615         getterSetterChanged = true;
3616     }
3617 
3618     if (current.attributesEqual(descriptor) &amp;&amp; !getterSetterChanged)
3619         return true;
3620 
3621     GetterSetter* getterSetter = GetterSetter::create(vm, exec-&gt;lexicalGlobalObject(), getter, setter);
3622 
3623     object-&gt;methodTable(vm)-&gt;deleteProperty(object, exec, propertyName);
3624     RETURN_IF_EXCEPTION(scope, false);
3625     unsigned attrs = descriptor.attributesOverridingCurrent(current);
3626     object-&gt;putDirectAccessor(exec, propertyName, getterSetter, attrs | PropertyAttribute::Accessor);
3627     return true;
3628 }
3629 
3630 bool JSObject::defineOwnNonIndexProperty(ExecState* exec, PropertyName propertyName, const PropertyDescriptor&amp; descriptor, bool throwException)
3631 {
3632     VM&amp; vm  = exec-&gt;vm();
3633     auto throwScope = DECLARE_THROW_SCOPE(vm);
3634 
3635     // Track on the globaldata that we&#39;re in define property.
3636     // Currently DefineOwnProperty uses delete to remove properties when they are being replaced
3637     // (particularly when changing attributes), however delete won&#39;t allow non-configurable (i.e.
3638     // DontDelete) properties to be deleted. For now, we can use this flag to make this work.
3639     VM::DeletePropertyModeScope scope(vm, VM::DeletePropertyMode::IgnoreConfigurable);
3640     PropertyDescriptor current;
3641     bool isCurrentDefined = getOwnPropertyDescriptor(exec, propertyName, current);
3642     bool isExtensible = this-&gt;isExtensible(exec);
3643     RETURN_IF_EXCEPTION(throwScope, false);
3644     RELEASE_AND_RETURN(throwScope, validateAndApplyPropertyDescriptor(exec, this, propertyName, isExtensible, descriptor, isCurrentDefined, current, throwException));
3645 }
3646 
3647 bool JSObject::defineOwnProperty(JSObject* object, ExecState* exec, PropertyName propertyName, const PropertyDescriptor&amp; descriptor, bool throwException)
3648 {
3649     // If it&#39;s an array index, then use the indexed property storage.
3650     if (Optional&lt;uint32_t&gt; index = parseIndex(propertyName)) {
3651         // c. Let succeeded be the result of calling the default [[DefineOwnProperty]] internal method (8.12.9) on A passing P, Desc, and false as arguments.
3652         // d. Reject if succeeded is false.
3653         // e. If index &gt;= oldLen
3654         // e.i. Set oldLenDesc.[[Value]] to index + 1.
3655         // e.ii. Call the default [[DefineOwnProperty]] internal method (8.12.9) on A passing &quot;length&quot;, oldLenDesc, and false as arguments. This call will always return true.
3656         // f. Return true.
3657         return object-&gt;defineOwnIndexedProperty(exec, index.value(), descriptor, throwException);
3658     }
3659 
3660     return object-&gt;defineOwnNonIndexProperty(exec, propertyName, descriptor, throwException);
3661 }
3662 
3663 void JSObject::convertToDictionary(VM&amp; vm)
3664 {
3665     DeferredStructureTransitionWatchpointFire deferredWatchpointFire(vm, structure(vm));
3666     setStructure(
3667         vm, Structure::toCacheableDictionaryTransition(vm, structure(vm), &amp;deferredWatchpointFire));
3668 }
3669 
3670 void JSObject::shiftButterflyAfterFlattening(const GCSafeConcurrentJSLocker&amp;, VM&amp; vm, Structure* structure, size_t outOfLineCapacityAfter)
3671 {
3672     // This could interleave visitChildren because some old structure could have been a non
3673     // dictionary structure. We have to be crazy careful. But, we are guaranteed to be holding
3674     // the structure&#39;s lock right now, and that helps a bit.
3675 
3676     Butterfly* oldButterfly = this-&gt;butterfly();
3677     size_t preCapacity;
3678     size_t indexingPayloadSizeInBytes;
3679     bool hasIndexingHeader = this-&gt;hasIndexingHeader(vm);
3680     if (UNLIKELY(hasIndexingHeader)) {
3681         preCapacity = oldButterfly-&gt;indexingHeader()-&gt;preCapacity(structure);
3682         indexingPayloadSizeInBytes = oldButterfly-&gt;indexingHeader()-&gt;indexingPayloadSizeInBytes(structure);
3683     } else {
3684         preCapacity = 0;
3685         indexingPayloadSizeInBytes = 0;
3686     }
3687 
3688     Butterfly* newButterfly = Butterfly::createUninitialized(vm, this, preCapacity, outOfLineCapacityAfter, hasIndexingHeader, indexingPayloadSizeInBytes);
3689 
3690     // No need to copy the precapacity.
3691     void* currentBase = oldButterfly-&gt;base(0, outOfLineCapacityAfter);
3692     void* newBase = newButterfly-&gt;base(0, outOfLineCapacityAfter);
3693 
3694     memcpy(newBase, currentBase, Butterfly::totalSize(0, outOfLineCapacityAfter, hasIndexingHeader, indexingPayloadSizeInBytes));
3695 
3696     setButterfly(vm, newButterfly);
3697 }
3698 
3699 uint32_t JSObject::getEnumerableLength(ExecState* exec, JSObject* object)
3700 {
3701     VM&amp; vm = exec-&gt;vm();
3702     Structure* structure = object-&gt;structure(vm);
3703     if (structure-&gt;holesMustForwardToPrototype(vm, object))
3704         return 0;
3705     switch (object-&gt;indexingType()) {
3706     case ALL_BLANK_INDEXING_TYPES:
3707     case ALL_UNDECIDED_INDEXING_TYPES:
3708         return 0;
3709 
3710     case ALL_INT32_INDEXING_TYPES:
3711     case ALL_CONTIGUOUS_INDEXING_TYPES: {
3712         Butterfly* butterfly = object-&gt;butterfly();
3713         unsigned usedLength = butterfly-&gt;publicLength();
3714         for (unsigned i = 0; i &lt; usedLength; ++i) {
3715             if (!butterfly-&gt;contiguous().at(object, i))
3716                 return 0;
3717         }
3718         return usedLength;
3719     }
3720 
3721     case ALL_DOUBLE_INDEXING_TYPES: {
3722         Butterfly* butterfly = object-&gt;butterfly();
3723         unsigned usedLength = butterfly-&gt;publicLength();
3724         for (unsigned i = 0; i &lt; usedLength; ++i) {
3725             double value = butterfly-&gt;contiguousDouble().at(object, i);
3726             if (value != value)
3727                 return 0;
3728         }
3729         return usedLength;
3730     }
3731 
3732     case ALL_ARRAY_STORAGE_INDEXING_TYPES: {
3733         ArrayStorage* storage = object-&gt;m_butterfly-&gt;arrayStorage();
3734         if (storage-&gt;m_sparseMap.get())
3735             return 0;
3736 
3737         unsigned usedVectorLength = std::min(storage-&gt;length(), storage-&gt;vectorLength());
3738         for (unsigned i = 0; i &lt; usedVectorLength; ++i) {
3739             if (!storage-&gt;m_vector[i])
3740                 return 0;
3741         }
3742         return usedVectorLength;
3743     }
3744 
3745     default:
3746         RELEASE_ASSERT_NOT_REACHED();
3747         return 0;
3748     }
3749 }
3750 
3751 void JSObject::getStructurePropertyNames(JSObject* object, ExecState* exec, PropertyNameArray&amp; propertyNames, EnumerationMode mode)
3752 {
3753     VM&amp; vm = exec-&gt;vm();
3754     object-&gt;structure(vm)-&gt;getPropertyNamesFromStructure(vm, propertyNames, mode);
3755 }
3756 
3757 void JSObject::getGenericPropertyNames(JSObject* object, ExecState* exec, PropertyNameArray&amp; propertyNames, EnumerationMode mode)
3758 {
3759     VM&amp; vm = exec-&gt;vm();
3760     auto scope = DECLARE_THROW_SCOPE(vm);
3761     object-&gt;methodTable(vm)-&gt;getOwnPropertyNames(object, exec, propertyNames, EnumerationMode(mode, JSObjectPropertiesMode::Exclude));
3762     RETURN_IF_EXCEPTION(scope, void());
3763 
3764     JSValue nextProto = object-&gt;getPrototype(vm, exec);
3765     RETURN_IF_EXCEPTION(scope, void());
3766     if (nextProto.isNull())
3767         return;
3768 
3769     JSObject* prototype = asObject(nextProto);
3770     while (true) {
3771         if (prototype-&gt;structure(vm)-&gt;typeInfo().overridesGetPropertyNames()) {
3772             scope.release();
3773             prototype-&gt;methodTable(vm)-&gt;getPropertyNames(prototype, exec, propertyNames, mode);
3774             return;
3775         }
3776         prototype-&gt;methodTable(vm)-&gt;getOwnPropertyNames(prototype, exec, propertyNames, mode);
3777         RETURN_IF_EXCEPTION(scope, void());
3778         nextProto = prototype-&gt;getPrototype(vm, exec);
3779         RETURN_IF_EXCEPTION(scope, void());
3780         if (nextProto.isNull())
3781             break;
3782         prototype = asObject(nextProto);
3783     }
3784 }
3785 
3786 // Implements GetMethod(O, P) in section 7.3.9 of the spec.
3787 // http://www.ecma-international.org/ecma-262/6.0/index.html#sec-getmethod
3788 JSValue JSObject::getMethod(ExecState* exec, CallData&amp; callData, CallType&amp; callType, const Identifier&amp; ident, const String&amp; errorMessage)
3789 {
3790     VM&amp; vm = exec-&gt;vm();
3791     auto scope = DECLARE_THROW_SCOPE(vm);
3792 
3793     JSValue method = get(exec, ident);
3794     RETURN_IF_EXCEPTION(scope, JSValue());
3795 
3796     if (!method.isCell()) {
3797         if (method.isUndefinedOrNull())
3798             return jsUndefined();
3799 
3800         throwVMTypeError(exec, scope, errorMessage);
3801         return jsUndefined();
3802     }
3803 
3804     callType = method.asCell()-&gt;methodTable(vm)-&gt;getCallData(method.asCell(), callData);
3805     if (callType == CallType::None) {
3806         throwVMTypeError(exec, scope, errorMessage);
3807         return jsUndefined();
3808     }
3809 
3810     return method;
3811 }
3812 
3813 bool JSObject::anyObjectInChainMayInterceptIndexedAccesses(VM&amp; vm) const
3814 {
3815     for (const JSObject* current = this; ;) {
3816         if (current-&gt;structure(vm)-&gt;mayInterceptIndexedAccesses())
3817             return true;
3818 
3819         JSValue prototype = current-&gt;getPrototypeDirect(vm);
3820         if (prototype.isNull())
3821             return false;
3822 
3823         current = asObject(prototype);
3824     }
3825 }
3826 
3827 bool JSObject::prototypeChainMayInterceptStoreTo(VM&amp; vm, PropertyName propertyName)
3828 {
3829     if (parseIndex(propertyName))
3830         return anyObjectInChainMayInterceptIndexedAccesses(vm);
3831 
3832     for (JSObject* current = this; ;) {
3833         JSValue prototype = current-&gt;getPrototypeDirect(vm);
3834         if (prototype.isNull())
3835             return false;
3836 
3837         current = asObject(prototype);
3838 
3839         unsigned attributes;
3840         PropertyOffset offset = current-&gt;structure(vm)-&gt;get(vm, propertyName, attributes);
3841         if (!JSC::isValidOffset(offset))
3842             continue;
3843 
3844         if (attributes &amp; (PropertyAttribute::ReadOnly | PropertyAttribute::Accessor))
3845             return true;
3846 
3847         return false;
3848     }
3849 }
3850 
3851 bool JSObject::needsSlowPutIndexing(VM&amp; vm) const
3852 {
3853     return anyObjectInChainMayInterceptIndexedAccesses(vm) || globalObject(vm)-&gt;isHavingABadTime();
3854 }
3855 
3856 NonPropertyTransition JSObject::suggestedArrayStorageTransition(VM&amp; vm) const
3857 {
3858     if (needsSlowPutIndexing(vm))
3859         return NonPropertyTransition::AllocateSlowPutArrayStorage;
3860 
3861     return NonPropertyTransition::AllocateArrayStorage;
3862 }
3863 
3864 } // namespace JSC
<a name="58" id="anc58"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="58" type="hidden" />
</body>
</html>