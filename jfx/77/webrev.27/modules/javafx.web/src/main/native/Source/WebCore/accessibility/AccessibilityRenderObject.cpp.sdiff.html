<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/accessibility/AccessibilityRenderObject.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="AccessibilityProgressIndicator.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="AccessibilityRenderObject.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/accessibility/AccessibilityRenderObject.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  21 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  22 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  23 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  24 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  25 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  26 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  27 */
  28 
  29 #include &quot;config.h&quot;
  30 #include &quot;AccessibilityRenderObject.h&quot;
  31 
  32 #include &quot;AXObjectCache.h&quot;
  33 #include &quot;AccessibilityImageMapLink.h&quot;
  34 #include &quot;AccessibilityLabel.h&quot;
  35 #include &quot;AccessibilityListBox.h&quot;
  36 #include &quot;AccessibilitySVGRoot.h&quot;
  37 #include &quot;AccessibilitySpinButton.h&quot;
  38 #include &quot;AccessibilityTable.h&quot;
  39 #include &quot;CachedImage.h&quot;
  40 #include &quot;Editing.h&quot;

  41 #include &quot;ElementIterator.h&quot;
  42 #include &quot;FloatRect.h&quot;
  43 #include &quot;Frame.h&quot;
  44 #include &quot;FrameLoader.h&quot;
  45 #include &quot;FrameSelection.h&quot;
  46 #include &quot;HTMLAreaElement.h&quot;
  47 #include &quot;HTMLAudioElement.h&quot;
  48 #include &quot;HTMLDetailsElement.h&quot;
  49 #include &quot;HTMLFormElement.h&quot;
  50 #include &quot;HTMLFrameElementBase.h&quot;
  51 #include &quot;HTMLImageElement.h&quot;
  52 #include &quot;HTMLInputElement.h&quot;
  53 #include &quot;HTMLLabelElement.h&quot;
  54 #include &quot;HTMLMapElement.h&quot;
  55 #include &quot;HTMLMeterElement.h&quot;
  56 #include &quot;HTMLNames.h&quot;
  57 #include &quot;HTMLOptionElement.h&quot;
  58 #include &quot;HTMLOptionsCollection.h&quot;

  59 #include &quot;HTMLSelectElement.h&quot;
  60 #include &quot;HTMLSummaryElement.h&quot;
  61 #include &quot;HTMLTableElement.h&quot;
  62 #include &quot;HTMLTextAreaElement.h&quot;
  63 #include &quot;HTMLVideoElement.h&quot;
  64 #include &quot;HitTestRequest.h&quot;
  65 #include &quot;HitTestResult.h&quot;
  66 #include &quot;Image.h&quot;
  67 #include &quot;LocalizedStrings.h&quot;
  68 #include &quot;NodeList.h&quot;
  69 #include &quot;Page.h&quot;
  70 #include &quot;ProgressTracker.h&quot;
  71 #include &quot;RenderButton.h&quot;
  72 #include &quot;RenderFileUploadControl.h&quot;
  73 #include &quot;RenderHTMLCanvas.h&quot;
  74 #include &quot;RenderImage.h&quot;
  75 #include &quot;RenderInline.h&quot;
  76 #include &quot;RenderIterator.h&quot;
  77 #include &quot;RenderLayer.h&quot;
  78 #include &quot;RenderLineBreak.h&quot;
</pre>
<hr />
<pre>
 560 
 561     // bail if none found
 562     if (!currentRenderer)
 563         return nullptr;
 564 
 565     // search up the DOM tree for an anchor element
 566     // NOTE: this assumes that any non-image with an anchor is an HTMLAnchorElement
 567     for (Node* node = currentRenderer-&gt;node(); node; node = node-&gt;parentNode()) {
 568         if (is&lt;HTMLAnchorElement&gt;(*node) || (node-&gt;renderer() &amp;&amp; cache-&gt;getOrCreate(node-&gt;renderer())-&gt;isLink()))
 569             return downcast&lt;Element&gt;(node);
 570     }
 571 
 572     return nullptr;
 573 }
 574 
 575 String AccessibilityRenderObject::helpText() const
 576 {
 577     if (!m_renderer)
 578         return String();
 579 
<span class="line-modified"> 580     const AtomicString&amp; ariaHelp = getAttribute(aria_helpAttr);</span>
 581     if (!ariaHelp.isEmpty())
 582         return ariaHelp;
 583 
 584     String describedBy = ariaDescribedByAttribute();
 585     if (!describedBy.isEmpty())
 586         return describedBy;
 587 
 588     String description = accessibilityDescription();
 589     for (RenderObject* ancestor = renderer(); ancestor; ancestor = ancestor-&gt;parent()) {
 590         if (is&lt;HTMLElement&gt;(ancestor-&gt;node())) {
 591             HTMLElement&amp; element = downcast&lt;HTMLElement&gt;(*ancestor-&gt;node());
<span class="line-modified"> 592             const AtomicString&amp; summary = element.getAttribute(summaryAttr);</span>
 593             if (!summary.isEmpty())
 594                 return summary;
 595 
 596             // The title attribute should be used as help text unless it is already being used as descriptive text.
<span class="line-modified"> 597             const AtomicString&amp; title = element.getAttribute(titleAttr);</span>
 598             if (!title.isEmpty() &amp;&amp; description != title)
 599                 return title;
 600         }
 601 
 602         // Only take help text from an ancestor element if its a group or an unknown role. If help was
 603         // added to those kinds of elements, it is likely it was meant for a child element.
 604         if (AccessibilityObject* axObj = axObjectCache()-&gt;getOrCreate(ancestor)) {
 605             if (!axObj-&gt;isGroup() &amp;&amp; axObj-&gt;roleValue() != AccessibilityRole::Unknown)
 606                 break;
 607         }
 608     }
 609 
 610     return String();
 611 }
 612 
 613 String AccessibilityRenderObject::textUnderElement(AccessibilityTextUnderElementMode mode) const
 614 {
 615     if (!m_renderer)
 616         return String();
 617 
</pre>
<hr />
<pre>
 730 
 731     RenderBoxModelObject* cssBox = renderBoxModelObject();
 732 
 733     if (isARIAStaticText()) {
 734         String staticText = text();
 735         if (!staticText.length())
 736             staticText = textUnderElement();
 737         return staticText;
 738     }
 739 
 740     if (is&lt;RenderText&gt;(*m_renderer))
 741         return textUnderElement();
 742 
 743     if (is&lt;RenderMenuList&gt;(cssBox)) {
 744         // RenderMenuList will go straight to the text() of its selected item.
 745         // This has to be overridden in the case where the selected item has an ARIA label.
 746         HTMLSelectElement&amp; selectElement = downcast&lt;HTMLSelectElement&gt;(*m_renderer-&gt;node());
 747         int selectedIndex = selectElement.selectedIndex();
 748         const Vector&lt;HTMLElement*&gt;&amp; listItems = selectElement.listItems();
 749         if (selectedIndex &gt;= 0 &amp;&amp; static_cast&lt;size_t&gt;(selectedIndex) &lt; listItems.size()) {
<span class="line-modified"> 750             const AtomicString&amp; overriddenDescription = listItems[selectedIndex]-&gt;attributeWithoutSynchronization(aria_labelAttr);</span>
 751             if (!overriddenDescription.isNull())
 752                 return overriddenDescription;
 753         }
 754         return downcast&lt;RenderMenuList&gt;(*m_renderer).text();
 755     }
 756 
 757     if (is&lt;RenderListMarker&gt;(*m_renderer))
 758         return downcast&lt;RenderListMarker&gt;(*m_renderer).text();
 759 
 760     if (isWebArea())
 761         return String();
 762 
 763     if (isTextControl())
 764         return text();
 765 
 766 #if PLATFORM(IOS_FAMILY)
 767     if (isInputTypePopupButton())
 768         return textUnderElement();
 769 #endif
 770 
</pre>
<hr />
<pre>
 880     return is&lt;RenderSVGShape&gt;(renderer());
 881 }
 882 
 883 Path AccessibilityRenderObject::elementPath() const
 884 {
 885     if (is&lt;RenderSVGShape&gt;(renderer()) &amp;&amp; downcast&lt;RenderSVGShape&gt;(*m_renderer).hasPath()) {
 886         Path path = downcast&lt;RenderSVGShape&gt;(*m_renderer).path();
 887 
 888         // The SVG path is in terms of the parent&#39;s bounding box. The path needs to be offset to frame coordinates.
 889         if (auto svgRoot = ancestorsOfType&lt;RenderSVGRoot&gt;(*m_renderer).first()) {
 890             LayoutPoint parentOffset = axObjectCache()-&gt;getOrCreate(&amp;*svgRoot)-&gt;elementRect().location();
 891             path.transform(AffineTransform().translate(parentOffset.x(), parentOffset.y()));
 892         }
 893 
 894         return path;
 895     }
 896 
 897     return Path();
 898 }
 899 























 900 IntPoint AccessibilityRenderObject::clickPoint()
 901 {
 902     // Headings are usually much wider than their textual content. If the mid point is used, often it can be wrong.
<span class="line-modified"> 903     if (isHeading() &amp;&amp; children().size() == 1)</span>
<span class="line-modified"> 904         return children()[0]-&gt;clickPoint();</span>




 905 
 906     // use the default position unless this is an editable web area, in which case we use the selection bounds.
 907     if (!isWebArea() || !canSetValueAttribute())
 908         return AccessibilityObject::clickPoint();
 909 
 910     VisibleSelection visSelection = selection();
 911     VisiblePositionRange range = VisiblePositionRange(visSelection.visibleStart(), visSelection.visibleEnd());
 912     IntRect bounds = boundsForVisiblePositionRange(range);
<span class="line-modified"> 913 #if PLATFORM(COCOA)</span>
<span class="line-removed"> 914     bounds.setLocation(m_renderer-&gt;view().frameView().screenToContents(bounds.location()));</span>
<span class="line-removed"> 915 #endif</span>
<span class="line-removed"> 916     return IntPoint(bounds.x() + (bounds.width() / 2), bounds.y() - (bounds.height() / 2));</span>
 917 }
 918 
 919 AccessibilityObject* AccessibilityRenderObject::internalLinkElement() const
 920 {
 921     Element* element = anchorElement();
 922     // Right now, we do not support ARIA links as internal link elements
 923     if (!is&lt;HTMLAnchorElement&gt;(element))
 924         return nullptr;
 925     HTMLAnchorElement&amp; anchor = downcast&lt;HTMLAnchorElement&gt;(*element);
 926 
 927     URL linkURL = anchor.href();
 928     String fragmentIdentifier = linkURL.fragmentIdentifier();
 929     if (fragmentIdentifier.isEmpty())
 930         return nullptr;
 931 
 932     // check if URL is the same as current URL
 933     URL documentURL = m_renderer-&gt;document().url();
 934     if (!equalIgnoringFragmentIdentifier(documentURL, linkURL))
 935         return nullptr;
 936 
</pre>
<hr />
<pre>
 989 
 990     if (isLink()) {
 991         AccessibilityObject* linkedAXElement = internalLinkElement();
 992         if (linkedAXElement)
 993             linkedUIElements.append(linkedAXElement);
 994     }
 995 
 996     if (roleValue() == AccessibilityRole::RadioButton)
 997         addRadioButtonGroupMembers(linkedUIElements);
 998 }
 999 
1000 bool AccessibilityRenderObject::hasTextAlternative() const
1001 {
1002     // ARIA: section 2A, bullet #3 says if aria-labeledby or aria-label appears, it should
1003     // override the &quot;label&quot; element association.
1004     return ariaAccessibilityDescription().length();
1005 }
1006 
1007 bool AccessibilityRenderObject::hasPopup() const
1008 {
<span class="line-modified">1009     return !equalLettersIgnoringASCIICase(hasPopupValue(), &quot;false&quot;);</span>




1010 }
1011 
1012 bool AccessibilityRenderObject::supportsARIADropping() const
1013 {
<span class="line-modified">1014     const AtomicString&amp; dropEffect = getAttribute(aria_dropeffectAttr);</span>
1015     return !dropEffect.isEmpty();
1016 }
1017 
1018 bool AccessibilityRenderObject::supportsARIADragging() const
1019 {
<span class="line-modified">1020     const AtomicString&amp; grabbed = getAttribute(aria_grabbedAttr);</span>
1021     return equalLettersIgnoringASCIICase(grabbed, &quot;true&quot;) || equalLettersIgnoringASCIICase(grabbed, &quot;false&quot;);
1022 }
1023 
1024 bool AccessibilityRenderObject::isARIAGrabbed()
1025 {
1026     return elementAttributeValue(aria_grabbedAttr);
1027 }
1028 
1029 Vector&lt;String&gt; AccessibilityRenderObject::determineARIADropEffects()
1030 {
<span class="line-modified">1031     const AtomicString&amp; dropEffects = getAttribute(aria_dropeffectAttr);</span>
1032     if (dropEffects.isEmpty()) {
1033         return { };
1034     }
1035 
1036     String dropEffectsString = dropEffects.string();
1037     dropEffectsString.replace(&#39;\n&#39;, &#39; &#39;);
1038     return dropEffectsString.split(&#39; &#39;);
1039 }
1040 
1041 bool AccessibilityRenderObject::exposesTitleUIElement() const
1042 {
1043     if (!isControl() &amp;&amp; !isFigureElement())
1044         return false;
1045 
1046     // If this control is ignored (because it&#39;s invisible),
1047     // then the label needs to be exposed so it can be visible to accessibility.
1048     if (accessibilityIsIgnored())
1049         return true;
1050 
1051     // When controls have their own descriptions, the title element should be ignored.
</pre>
<hr />
<pre>
1056     // titleUIElement, otherwise its inner text will be announced by a screenreader.
1057     if (isLabelable()) {
1058         if (HTMLLabelElement* label = labelForElement(downcast&lt;Element&gt;(node()))) {
1059             if (!label-&gt;attributeWithoutSynchronization(aria_labelAttr).isEmpty())
1060                 return false;
1061             if (AccessibilityObject* labelObject = axObjectCache()-&gt;getOrCreate(label)) {
1062                 if (!labelObject-&gt;ariaLabeledByAttribute().isEmpty())
1063                     return false;
1064                 // To simplify instances where the labeling element includes widget descendants
1065                 // which it does not label.
1066                 if (is&lt;AccessibilityLabel&gt;(*labelObject)
1067                     &amp;&amp; downcast&lt;AccessibilityLabel&gt;(*labelObject).containsUnrelatedControls())
1068                     return false;
1069             }
1070         }
1071     }
1072 
1073     return true;
1074 }
1075 




































1076 AccessibilityObject* AccessibilityRenderObject::titleUIElement() const
1077 {
1078     if (!m_renderer)
1079         return nullptr;
1080 
1081     // if isFieldset is true, the renderer is guaranteed to be a RenderFieldset
1082     if (isFieldset())
1083         return axObjectCache()-&gt;getOrCreate(downcast&lt;RenderBlock&gt;(*m_renderer).findFieldsetLegend(RenderBlock::FieldsetIncludeFloatingOrOutOfFlow));
1084 
1085     if (isFigureElement())
1086         return captionForFigure();
1087 
1088     Node* node = m_renderer-&gt;node();
1089     if (!is&lt;Element&gt;(node))
1090         return nullptr;
1091     HTMLLabelElement* label = labelForElement(downcast&lt;Element&gt;(node));
1092     if (label &amp;&amp; label-&gt;renderer())
1093         return axObjectCache()-&gt;getOrCreate(label);
1094 
1095     return nullptr;
</pre>
<hr />
<pre>
1136 AccessibilityObjectInclusion AccessibilityRenderObject::defaultObjectInclusion() const
1137 {
1138     // The following cases can apply to any element that&#39;s a subclass of AccessibilityRenderObject.
1139 
1140     if (!m_renderer)
1141         return AccessibilityObjectInclusion::IgnoreObject;
1142 
1143     if (m_renderer-&gt;style().visibility() != Visibility::Visible) {
1144         // aria-hidden is meant to override visibility as the determinant in AX hierarchy inclusion.
1145         if (equalLettersIgnoringASCIICase(getAttribute(aria_hiddenAttr), &quot;false&quot;))
1146             return AccessibilityObjectInclusion::DefaultBehavior;
1147 
1148         return AccessibilityObjectInclusion::IgnoreObject;
1149     }
1150 
1151     return AccessibilityObject::defaultObjectInclusion();
1152 }
1153 
1154 static bool webAreaIsPresentational(RenderObject* renderer)
1155 {
<span class="line-modified">1156     if (!is&lt;RenderView&gt;(*renderer))</span>
1157         return false;
1158 
1159     if (auto ownerElement = renderer-&gt;document().ownerElement())
1160         return nodeHasPresentationRole(ownerElement);
1161 
1162     return false;
1163 }
1164 
1165 bool AccessibilityRenderObject::computeAccessibilityIsIgnored() const
1166 {
1167 #ifndef NDEBUG
1168     ASSERT(m_initialized);
1169 #endif
1170 
1171     if (!m_renderer)
1172         return true;
1173 
1174     // Check first if any of the common reasons cause this element to be ignored.
1175     // Then process other use cases that need to be applied to all the various roles
1176     // that AccessibilityRenderObjects take on.
</pre>
<hr />
<pre>
1253 
1254     if (isLink())
1255         return false;
1256 
1257     if (isLandmark())
1258         return false;
1259 
1260     // all controls are accessible
1261     if (isControl())
1262         return false;
1263 
1264     if (isFigureElement())
1265         return false;
1266 
1267     switch (roleValue()) {
1268     case AccessibilityRole::Audio:
1269     case AccessibilityRole::DescriptionListTerm:
1270     case AccessibilityRole::DescriptionListDetail:
1271     case AccessibilityRole::Details:
1272     case AccessibilityRole::DocumentArticle:

1273     case AccessibilityRole::LandmarkRegion:
1274     case AccessibilityRole::ListItem:
1275     case AccessibilityRole::Time:
1276     case AccessibilityRole::Video:
1277         return false;
1278     default:
1279         break;
1280     }
1281 
1282     if (ariaRoleAttribute() != AccessibilityRole::Unknown)
1283         return false;
1284 
1285     if (roleValue() == AccessibilityRole::HorizontalRule)
1286         return false;
1287 
1288     // don&#39;t ignore labels, because they serve as TitleUIElements
1289     Node* node = m_renderer-&gt;node();
1290     if (is&lt;HTMLLabelElement&gt;(node))
1291         return false;
1292 
</pre>
<hr />
<pre>
1424 }
1425 
1426 bool AccessibilityRenderObject::isLoaded() const
1427 {
1428     return !m_renderer-&gt;document().parser();
1429 }
1430 
1431 double AccessibilityRenderObject::estimatedLoadingProgress() const
1432 {
1433     if (!m_renderer)
1434         return 0;
1435 
1436     if (isLoaded())
1437         return 1.0;
1438 
1439     return m_renderer-&gt;page().progress().estimatedProgress();
1440 }
1441 
1442 int AccessibilityRenderObject::layoutCount() const
1443 {
<span class="line-modified">1444     if (!is&lt;RenderView&gt;(*m_renderer))</span>
1445         return 0;
1446     return downcast&lt;RenderView&gt;(*m_renderer).frameView().layoutContext().layoutCount();
1447 }
1448 
1449 String AccessibilityRenderObject::text() const
1450 {
1451     if (isPasswordField())
1452         return passwordFieldValue();
1453 
1454     return AccessibilityNodeObject::text();
1455 }
1456 
1457 int AccessibilityRenderObject::textLength() const
1458 {
1459     ASSERT(isTextControl());
1460 
1461     if (isPasswordField())
1462         return passwordFieldValue().length();
1463 
1464     return text().length();
</pre>
<hr />
<pre>
1486     int end = indexForVisiblePosition(visibleSelection.end());
1487 
1488     return PlainTextRange(start, end - start);
1489 }
1490 
1491 String AccessibilityRenderObject::selectedText() const
1492 {
1493     ASSERT(isTextControl());
1494 
1495     if (isPasswordField())
1496         return String(); // need to return something distinct from empty string
1497 
1498     if (isNativeTextControl()) {
1499         HTMLTextFormControlElement&amp; textControl = downcast&lt;RenderTextControl&gt;(*m_renderer).textFormControlElement();
1500         return textControl.selectedText();
1501     }
1502 
1503     return doAXStringForRange(documentBasedSelectedTextRange());
1504 }
1505 
<span class="line-modified">1506 const AtomicString&amp; AccessibilityRenderObject::accessKey() const</span>
1507 {
1508     Node* node = m_renderer-&gt;node();
1509     if (!is&lt;Element&gt;(node))
1510         return nullAtom();
1511     return downcast&lt;Element&gt;(*node).attributeWithoutSynchronization(accesskeyAttr);
1512 }
1513 
1514 VisibleSelection AccessibilityRenderObject::selection() const
1515 {
1516     return m_renderer-&gt;frame().selection().selection();
1517 }
1518 
1519 PlainTextRange AccessibilityRenderObject::selectedTextRange() const
1520 {
1521     ASSERT(isTextControl());
1522 
1523     if (isPasswordField())
1524         return PlainTextRange();
1525 
1526     AccessibilityRole ariaRole = ariaRoleAttribute();
</pre>
<hr />
<pre>
1641 
1642     // Menu items are considered selectable by assistive technologies
1643     if (isMenuItem())
1644         return isFocused() || parentObjectUnignored()-&gt;activeDescendant() == this;
1645 
1646     return false;
1647 }
1648 
1649 bool AccessibilityRenderObject::isTabItemSelected() const
1650 {
1651     if (!isTabItem() || !m_renderer)
1652         return false;
1653 
1654     Node* node = m_renderer-&gt;node();
1655     if (!node || !node-&gt;isElementNode())
1656         return false;
1657 
1658     // The ARIA spec says a tab item can also be selected if it is aria-labeled by a tabpanel
1659     // that has keyboard focus inside of it, or if a tabpanel in its aria-controls list has KB
1660     // focus inside of it.
<span class="line-modified">1661     AccessibilityObject* focusedElement = focusedUIElement();</span>
1662     if (!focusedElement)
1663         return false;
1664 
1665     Vector&lt;Element*&gt; elements;
1666     elementsFromAttribute(elements, aria_controlsAttr);
1667 
1668     AXObjectCache* cache = axObjectCache();
1669     if (!cache)
1670         return false;
1671 
1672     for (const auto&amp; element : elements) {
1673         AccessibilityObject* tabPanel = cache-&gt;getOrCreate(element);
1674 
1675         // A tab item should only control tab panels.
1676         if (!tabPanel || tabPanel-&gt;roleValue() != AccessibilityRole::TabPanel)
1677             continue;
1678 
1679         AccessibilityObject* checkFocusElement = focusedElement;
1680         // Check if the focused element is a descendant of the element controlled by the tab item.
1681         while (checkFocusElement) {
</pre>
<hr />
<pre>
1693     if (!m_renderer)
1694         return false;
1695 
1696     Document&amp; document = m_renderer-&gt;document();
1697 
1698     Element* focusedElement = document.focusedElement();
1699     if (!focusedElement)
1700         return false;
1701 
1702     // A web area is represented by the Document node in the DOM tree, which isn&#39;t focusable.
1703     // Check instead if the frame&#39;s selection controller is focused
1704     if (focusedElement == m_renderer-&gt;node()
1705         || (roleValue() == AccessibilityRole::WebArea &amp;&amp; document.frame()-&gt;selection().isFocusedAndActive()))
1706         return true;
1707 
1708     return false;
1709 }
1710 
1711 void AccessibilityRenderObject::setFocused(bool on)
1712 {
<span class="line-removed">1713     if (on &amp;&amp; dispatchAccessibilityEventWithType(AccessibilityEventType::Focus))</span>
<span class="line-removed">1714         return;</span>
<span class="line-removed">1715 </span>
1716     if (!canSetFocusAttribute())
1717         return;
1718 
1719     Document* document = this-&gt;document();
1720     Node* node = this-&gt;node();
1721 
1722     if (!on || !is&lt;Element&gt;(node)) {
1723         document-&gt;setFocusedElement(nullptr);
1724         return;
1725     }
1726 
1727     // When a node is told to set focus, that can cause it to be deallocated, which means that doing
1728     // anything else inside this object will crash. To fix this, we added a RefPtr to protect this object
1729     // long enough for duration.
1730     RefPtr&lt;AccessibilityObject&gt; protectedThis(this);
1731 
1732     // If this node is already the currently focused node, then calling focus() won&#39;t do anything.
1733     // That is a problem when focus is removed from the webpage to chrome, and then returns.
1734     // In these cases, we need to do what keyboard and mouse focus do, which is reset focus first.
1735     if (document-&gt;focusedElement() == node)
</pre>
<hr />
<pre>
1746 void AccessibilityRenderObject::setSelectedRows(AccessibilityChildrenVector&amp; selectedRows)
1747 {
1748     // Setting selected only makes sense in trees and tables (and tree-tables).
1749     AccessibilityRole role = roleValue();
1750     if (role != AccessibilityRole::Tree &amp;&amp; role != AccessibilityRole::TreeGrid &amp;&amp; role != AccessibilityRole::Table &amp;&amp; role != AccessibilityRole::Grid)
1751         return;
1752 
1753     bool isMulti = isMultiSelectable();
1754     unsigned count = selectedRows.size();
1755     if (count &gt; 1 &amp;&amp; !isMulti)
1756         count = 1;
1757 
1758     for (const auto&amp; selectedRow : selectedRows)
1759         selectedRow-&gt;setSelected(true);
1760 }
1761 
1762 void AccessibilityRenderObject::setValue(const String&amp; string)
1763 {
1764     if (!m_renderer || !is&lt;Element&gt;(m_renderer-&gt;node()))
1765         return;
<span class="line-removed">1766     if (dispatchAccessibleSetValueEvent(string))</span>
<span class="line-removed">1767         return;</span>
1768 
1769     Element&amp; element = downcast&lt;Element&gt;(*m_renderer-&gt;node());
1770     RenderObject&amp; renderer = *m_renderer;
1771 
1772     // We should use the editor&#39;s insertText to mimic typing into the field.
1773     // Also only do this when the field is in editing mode.
1774     if (Frame* frame = renderer.document().frame()) {
1775         Editor&amp; editor = frame-&gt;editor();
1776         if (element.shouldUseInputMethod()) {
1777             editor.clearText();
1778             editor.insertText(string, nullptr);
1779             return;
1780         }
1781     }
1782     // FIXME: Do we want to do anything here for ARIA textboxes?
1783     if (renderer.isTextField() &amp;&amp; is&lt;HTMLInputElement&gt;(element))
1784         downcast&lt;HTMLInputElement&gt;(element).setValue(string);
1785     else if (renderer.isTextArea() &amp;&amp; is&lt;HTMLTextAreaElement&gt;(element))
1786         downcast&lt;HTMLTextAreaElement&gt;(element).setValue(string);
1787 }
1788 
1789 bool AccessibilityRenderObject::supportsARIAOwns() const
1790 {
1791     if (!m_renderer)
1792         return false;
<span class="line-modified">1793     const AtomicString&amp; ariaOwns = getAttribute(aria_ownsAttr);</span>
1794 
1795     return !ariaOwns.isEmpty();
1796 }
1797 
1798 RenderView* AccessibilityRenderObject::topRenderer() const
1799 {
1800     Document* topDoc = topDocument();
1801     if (!topDoc)
1802         return nullptr;
1803 
1804     return topDoc-&gt;renderView();
1805 }
1806 
1807 Document* AccessibilityRenderObject::document() const
1808 {
1809     if (!m_renderer)
1810         return nullptr;
1811     return &amp;m_renderer-&gt;document();
1812 }
1813 
1814 Widget* AccessibilityRenderObject::widget() const
1815 {
<span class="line-modified">1816     if (!is&lt;RenderWidget&gt;(*m_renderer))</span>
1817         return nullptr;
1818     return downcast&lt;RenderWidget&gt;(*m_renderer).widget();
1819 }
1820 
1821 AccessibilityObject* AccessibilityRenderObject::accessibilityParentForImageMap(HTMLMapElement* map) const
1822 {
1823     // find an image that is using this map
1824     if (!map)
1825         return nullptr;
1826 
1827     HTMLImageElement* imageElement = map-&gt;imageElement();
1828     if (!imageElement)
1829         return nullptr;
1830 
1831     if (AXObjectCache* cache = axObjectCache())
1832         return cache-&gt;getOrCreate(imageElement);
1833 
1834     return nullptr;
1835 }
1836 
</pre>
<hr />
<pre>
1899         if (endPos.isNull())
1900             endPos = startPos;
1901     }
1902 
1903     return VisiblePositionRange(startPos, endPos);
1904 }
1905 
1906 VisiblePositionRange AccessibilityRenderObject::visiblePositionRangeForLine(unsigned lineCount) const
1907 {
1908     if (!lineCount || !m_renderer)
1909         return VisiblePositionRange();
1910 
1911     // iterate over the lines
1912     // FIXME: this is wrong when lineNumber is lineCount+1,  because nextLinePosition takes you to the
1913     // last offset of the last line
1914     VisiblePosition visiblePos = m_renderer-&gt;view().positionForPoint(IntPoint(), nullptr);
1915     VisiblePosition savedVisiblePos;
1916     while (--lineCount) {
1917         savedVisiblePos = visiblePos;
1918         visiblePos = nextLinePosition(visiblePos, 0);
<span class="line-modified">1919         if (visiblePos.isNull() || visiblePos == savedVisiblePos)</span>


1920             return VisiblePositionRange();
1921     }
1922 
1923     // make a caret selection for the marker position, then extend it to the line
1924     // NOTE: ignores results of sel.modify because it returns false when
1925     // starting at an empty line.  The resulting selection in that case
1926     // will be a caret at visiblePos.
1927     FrameSelection selection;
1928     selection.setSelection(VisibleSelection(visiblePos));
1929     selection.modify(FrameSelection::AlterationExtend, DirectionRight, LineBoundary);
1930 
1931     return VisiblePositionRange(selection.selection().visibleStart(), selection.selection().visibleEnd());
1932 }
1933 
1934 VisiblePosition AccessibilityRenderObject::visiblePositionForIndex(int index) const
1935 {
1936     if (!m_renderer)
1937         return VisiblePosition();
1938 
1939     if (isNativeTextControl())
</pre>
<hr />
<pre>
1948 
1949     return visiblePositionForIndexUsingCharacterIterator(*node, index);
1950 }
1951 
1952 int AccessibilityRenderObject::indexForVisiblePosition(const VisiblePosition&amp; position) const
1953 {
1954     if (isNativeTextControl())
1955         return downcast&lt;RenderTextControl&gt;(*m_renderer).textFormControlElement().indexForVisiblePosition(position);
1956 
1957     if (!isTextControl())
1958         return 0;
1959 
1960     Node* node = m_renderer-&gt;node();
1961     if (!node)
1962         return 0;
1963 
1964     Position indexPosition = position.deepEquivalent();
1965     if (indexPosition.isNull() || highestEditableRoot(indexPosition, HasEditableAXRole) != node)
1966         return 0;
1967 
<span class="line-modified">1968 #if PLATFORM(GTK)</span>
1969     // We need to consider replaced elements for GTK, as they will be
1970     // presented with the &#39;object replacement character&#39; (0xFFFC).
1971     bool forSelectionPreservation = true;
1972 #else
1973     bool forSelectionPreservation = false;
1974 #endif
1975 
1976     return WebCore::indexForVisiblePosition(*node, position, forSelectionPreservation);
1977 }
1978 
1979 Element* AccessibilityRenderObject::rootEditableElementForPosition(const Position&amp; position) const
1980 {
1981     // Find the root editable or pseudo-editable (i.e. having an editable ARIA role) element.
1982     Element* result = nullptr;
1983 
1984     Element* rootEditableElement = position.rootEditableElement();
1985 
1986     for (Element* e = position.element(); e &amp;&amp; e != rootEditableElement; e = e-&gt;parentElement()) {
1987         if (nodeIsTextControl(e))
1988             result = e;
</pre>
<hr />
<pre>
1992 
1993     if (result)
1994         return result;
1995 
1996     return rootEditableElement;
1997 }
1998 
1999 bool AccessibilityRenderObject::nodeIsTextControl(const Node* node) const
2000 {
2001     if (!node)
2002         return false;
2003 
2004     if (AXObjectCache* cache = axObjectCache()) {
2005         if (AccessibilityObject* axObjectForNode = cache-&gt;getOrCreate(const_cast&lt;Node*&gt;(node)))
2006             return axObjectForNode-&gt;isTextControl();
2007     }
2008 
2009     return false;
2010 }
2011 
<span class="line-modified">2012 IntRect AccessibilityRenderObject::boundsForRects(LayoutRect&amp; rect1, LayoutRect&amp; rect2, RefPtr&lt;Range&gt; dataRange) const</span>
2013 {
2014     LayoutRect ourRect = rect1;
2015     ourRect.unite(rect2);
2016 
2017     // if the rectangle spans lines and contains multiple text chars, use the range&#39;s bounding box intead
2018     if (rect1.maxY() != rect2.maxY()) {
2019         LayoutRect boundingBox = dataRange-&gt;absoluteBoundingBox();
2020         String rangeString = plainText(dataRange.get());
2021         if (rangeString.length() &gt; 1 &amp;&amp; !boundingBox.isEmpty())
2022             ourRect = boundingBox;
2023     }
2024 
<span class="line-removed">2025 #if PLATFORM(MAC)</span>
<span class="line-removed">2026     return m_renderer-&gt;view().frameView().contentsToScreen(snappedIntRect(ourRect));</span>
<span class="line-removed">2027 #else</span>
2028     return snappedIntRect(ourRect);
<span class="line-removed">2029 #endif</span>
2030 }
2031 
2032 IntRect AccessibilityRenderObject::boundsForVisiblePositionRange(const VisiblePositionRange&amp; visiblePositionRange) const
2033 {
2034     if (visiblePositionRange.isNull())
2035         return IntRect();
2036 
2037     // Create a mutable VisiblePositionRange.
2038     VisiblePositionRange range(visiblePositionRange);
2039     LayoutRect rect1 = range.start.absoluteCaretBounds();
2040     LayoutRect rect2 = range.end.absoluteCaretBounds();
2041 
2042     // readjust for position at the edge of a line.  This is to exclude line rect that doesn&#39;t need to be accounted in the range bounds
2043     if (rect2.y() != rect1.y()) {
2044         VisiblePosition endOfFirstLine = endOfLine(range.start);
2045         if (range.start == endOfFirstLine) {
2046             range.start.setAffinity(DOWNSTREAM);
2047             rect1 = range.start.absoluteCaretBounds();
2048         }
2049         if (range.end == endOfFirstLine) {
</pre>
<hr />
<pre>
2316         return nullptr;
2317 
2318     AccessibilityObject* parent = nullptr;
2319     for (Element* mapParent = area-&gt;parentElement(); mapParent; mapParent = mapParent-&gt;parentElement()) {
2320         if (is&lt;HTMLMapElement&gt;(*mapParent)) {
2321             parent = accessibilityParentForImageMap(downcast&lt;HTMLMapElement&gt;(mapParent));
2322             break;
2323         }
2324     }
2325     if (!parent)
2326         return nullptr;
2327 
2328     for (const auto&amp; child : parent-&gt;children()) {
2329         if (child-&gt;elementRect().contains(point))
2330             return child.get();
2331     }
2332 
2333     return nullptr;
2334 }
2335 
<span class="line-modified">2336 AccessibilityObject* AccessibilityRenderObject::remoteSVGElementHitTest(const IntPoint&amp; point) const</span>
2337 {
2338     AccessibilityObject* remote = remoteSVGRootElement(Create);
2339     if (!remote)
2340         return nullptr;
2341 
2342     IntSize offset = point - roundedIntPoint(boundingBoxRect().location());
2343     return remote-&gt;accessibilityHitTest(IntPoint(offset));
2344 }
2345 
<span class="line-modified">2346 AccessibilityObject* AccessibilityRenderObject::elementAccessibilityHitTest(const IntPoint&amp; point) const</span>
2347 {
2348     if (isSVGImage())
2349         return remoteSVGElementHitTest(point);
2350 
2351     return AccessibilityObject::elementAccessibilityHitTest(point);
2352 }
2353 
2354 static bool shouldUseShadowHostForHitTesting(Node* shadowHost)
2355 {
2356     // We need to allow automation of mouse events on video tags.
2357     return shadowHost &amp;&amp; !shadowHost-&gt;hasTagName(videoTag);
2358 }
2359 
<span class="line-modified">2360 AccessibilityObject* AccessibilityRenderObject::accessibilityHitTest(const IntPoint&amp; point) const</span>
2361 {
2362     if (!m_renderer || !m_renderer-&gt;hasLayer())
2363         return nullptr;
2364 
2365     m_renderer-&gt;document().updateLayout();
2366 
2367     if (!m_renderer || !m_renderer-&gt;hasLayer())
2368         return nullptr;
2369 
2370     RenderLayer* layer = downcast&lt;RenderBox&gt;(*m_renderer).layer();
2371 
2372     HitTestRequest request(HitTestRequest::ReadOnly | HitTestRequest::Active | HitTestRequest::AccessibilityHitTest);
2373     HitTestResult hitTestResult = HitTestResult(point);
2374     layer-&gt;hitTest(request, hitTestResult);
2375     Node* node = hitTestResult.innerNode();
2376     if (!node)
2377         return nullptr;
2378     Node* shadowAncestorNode = node-&gt;shadowHost();
2379     if (shouldUseShadowHostForHitTesting(shadowAncestorNode))
2380         node = shadowAncestorNode;
2381     ASSERT(node);
2382 
2383     if (is&lt;HTMLAreaElement&gt;(*node))
2384         return accessibilityImageMapHitTest(downcast&lt;HTMLAreaElement&gt;(node), point);
2385 
2386     if (is&lt;HTMLOptionElement&gt;(*node))
2387         node = downcast&lt;HTMLOptionElement&gt;(*node).ownerSelectElement();
2388 
2389     RenderObject* obj = node-&gt;renderer();
2390     if (!obj)
2391         return nullptr;
2392 
2393     AccessibilityObject* result = obj-&gt;document().axObjectCache()-&gt;getOrCreate(obj);
2394     result-&gt;updateChildrenIfNecessary();
2395 
2396     // Allow the element to perform any hit-testing it might need to do to reach non-render children.
<span class="line-modified">2397     result = result-&gt;elementAccessibilityHitTest(point);</span>
2398 
2399     if (result &amp;&amp; result-&gt;accessibilityIsIgnored()) {
2400         // If this element is the label of a control, a hit test should return the control.
2401         AccessibilityObject* controlObject = result-&gt;correspondingControlForLabelElement();
2402         if (controlObject &amp;&amp; !controlObject-&gt;exposesTitleUIElement())
2403             return controlObject;
2404 
2405         result = result-&gt;parentObjectUnignored();
2406     }
2407 
2408     return result;
2409 }
2410 
2411 bool AccessibilityRenderObject::shouldNotifyActiveDescendant() const
2412 {
<span class="line-modified">2413 #if PLATFORM(GTK)</span>
2414     // According to the Core AAM spec, ATK expects object:state-changed:focused notifications
2415     // whenever the active descendant changes.
2416     return true;
2417 #endif
2418     // We want to notify that the combo box has changed its active descendant,
2419     // but we do not want to change the focus, because focus should remain with the combo box.
2420     if (isComboBox())
2421         return true;
2422 
2423     return shouldFocusActiveDescendant();
2424 }
2425 
2426 bool AccessibilityRenderObject::shouldFocusActiveDescendant() const
2427 {
2428     switch (ariaRoleAttribute()) {
2429     case AccessibilityRole::ApplicationGroup:
2430     case AccessibilityRole::ListBox:
2431     case AccessibilityRole::Menu:
2432     case AccessibilityRole::MenuBar:
2433     case AccessibilityRole::RadioGroup:
2434     case AccessibilityRole::Row:
2435     case AccessibilityRole::PopUpButton:

2436     case AccessibilityRole::ProgressIndicator:
2437     case AccessibilityRole::Toolbar:
2438     case AccessibilityRole::Outline:
2439     case AccessibilityRole::Tree:
2440     case AccessibilityRole::Grid:
2441     /* FIXME: replace these with actual roles when they are added to AccessibilityRole
2442     composite
2443     alert
2444     alertdialog
2445     status
2446     timer
2447     */
2448         return true;
2449     default:
2450         return false;
2451     }
2452 }
2453 
2454 AccessibilityObject* AccessibilityRenderObject::activeDescendant() const
2455 {
2456     if (!m_renderer)
2457         return nullptr;
2458 
<span class="line-modified">2459     const AtomicString&amp; activeDescendantAttrStr = getAttribute(aria_activedescendantAttr);</span>
2460     if (activeDescendantAttrStr.isNull() || activeDescendantAttrStr.isEmpty())
2461         return nullptr;
2462     Element* element = this-&gt;element();
2463     if (!element)
2464         return nullptr;
2465 
2466     Element* target = element-&gt;treeScope().getElementById(activeDescendantAttrStr);
2467     if (!target)
2468         return nullptr;
2469 
2470     if (AXObjectCache* cache = axObjectCache()) {
2471         AccessibilityObject* obj = cache-&gt;getOrCreate(target);
2472         if (obj &amp;&amp; obj-&gt;isAccessibilityRenderObject())
2473             // an activedescendant is only useful if it has a renderer, because that&#39;s what&#39;s needed to post the notification
2474             return obj;
2475     }
2476 
2477     return nullptr;
2478 }
2479 
</pre>
<hr />
<pre>
2611     // Textboxes should send out notifications.
2612     if (nodeHasRole(node, &quot;textbox&quot;) || (is&lt;Element&gt;(*node) &amp;&amp; contentEditableAttributeIsEnabled(downcast&lt;Element&gt;(node))))
2613         return true;
2614 
2615     return false;
2616 }
2617 
2618 AccessibilityObject* AccessibilityRenderObject::observableObject() const
2619 {
2620     // Find the object going up the parent chain that is used in accessibility to monitor certain notifications.
2621     for (RenderObject* renderer = this-&gt;renderer(); renderer &amp;&amp; renderer-&gt;node(); renderer = renderer-&gt;parent()) {
2622         if (renderObjectIsObservable(*renderer)) {
2623             if (AXObjectCache* cache = axObjectCache())
2624                 return cache-&gt;getOrCreate(renderer);
2625         }
2626     }
2627 
2628     return nullptr;
2629 }
2630 









2631 bool AccessibilityRenderObject::isDescendantOfElementType(const QualifiedName&amp; tagName) const
2632 {
2633     for (auto&amp; ancestor : ancestorsOfType&lt;RenderElement&gt;(*m_renderer)) {
2634         if (ancestor.element() &amp;&amp; ancestor.element()-&gt;hasTagName(tagName))
2635             return true;
2636     }
2637     return false;
2638 }
2639 
2640 String AccessibilityRenderObject::expandedTextValue() const
2641 {
2642     if (AccessibilityObject* parent = parentObject()) {
2643         if (parent-&gt;hasTagName(abbrTag) || parent-&gt;hasTagName(acronymTag))
2644             return parent-&gt;getAttribute(titleAttr);
2645     }
2646 
2647     return String();
2648 }
2649 
2650 bool AccessibilityRenderObject::supportsExpandedTextValue() const
2651 {
2652     if (roleValue() == AccessibilityRole::StaticText) {
2653         if (AccessibilityObject* parent = parentObject())
2654             return parent-&gt;hasTagName(abbrTag) || parent-&gt;hasTagName(acronymTag);
2655     }
2656 
2657     return false;
2658 }
2659 
2660 AccessibilityRole AccessibilityRenderObject::determineAccessibilityRole()
2661 {
2662     if (!m_renderer)
2663         return AccessibilityRole::Unknown;
2664 





2665     // Sometimes we need to ignore the attribute role. Like if a tree is malformed,
2666     // we want to ignore the treeitem&#39;s attribute role.
2667     if ((m_ariaRole = determineAriaRoleAttribute()) != AccessibilityRole::Unknown &amp;&amp; !shouldIgnoreAttributeRole())
2668         return m_ariaRole;
2669 
2670     Node* node = m_renderer-&gt;node();
2671     RenderBoxModelObject* cssBox = renderBoxModelObject();
2672 
2673     if (node &amp;&amp; node-&gt;isLink())
2674         return AccessibilityRole::WebCoreLink;
2675     if (node &amp;&amp; is&lt;HTMLImageElement&gt;(*node) &amp;&amp; downcast&lt;HTMLImageElement&gt;(*node).hasAttributeWithoutSynchronization(usemapAttr))
2676         return AccessibilityRole::ImageMap;
2677     if ((cssBox &amp;&amp; cssBox-&gt;isListItem()) || (node &amp;&amp; node-&gt;hasTagName(liTag)))
2678         return AccessibilityRole::ListItem;
2679     if (m_renderer-&gt;isListMarker())
2680         return AccessibilityRole::ListMarker;
2681     if (node &amp;&amp; node-&gt;hasTagName(buttonTag))
2682         return buttonRoleType();
2683     if (node &amp;&amp; node-&gt;hasTagName(legendTag))
2684         return AccessibilityRole::Legend;
</pre>
<hr />
<pre>
2723         if (input.isColorControl())
2724             return AccessibilityRole::ColorWell;
2725 #endif
2726     }
2727 
2728     if (hasContentEditableAttributeSet())
2729         return AccessibilityRole::TextArea;
2730 
2731     if (isFileUploadButton())
2732         return AccessibilityRole::Button;
2733 
2734     if (cssBox &amp;&amp; cssBox-&gt;isMenuList())
2735         return AccessibilityRole::PopUpButton;
2736 
2737     if (headingLevel())
2738         return AccessibilityRole::Heading;
2739 
2740     if (m_renderer-&gt;isSVGRoot())
2741         return AccessibilityRole::SVGRoot;
2742 
<span class="line-modified">2743     if (isStyleFormatGroup())</span>








2744         return is&lt;RenderInline&gt;(*m_renderer) ? AccessibilityRole::Inline : AccessibilityRole::TextGroup;

2745 
2746     if (node &amp;&amp; node-&gt;hasTagName(ddTag))
2747         return AccessibilityRole::DescriptionListDetail;
2748 
2749     if (node &amp;&amp; node-&gt;hasTagName(dtTag))
2750         return AccessibilityRole::DescriptionListTerm;
2751 
2752     if (node &amp;&amp; node-&gt;hasTagName(dlTag))
2753         return AccessibilityRole::DescriptionList;
2754 
2755     if (node &amp;&amp; node-&gt;hasTagName(fieldsetTag))
2756         return AccessibilityRole::Group;
2757 
2758     if (node &amp;&amp; node-&gt;hasTagName(figureTag))
2759         return AccessibilityRole::Figure;
2760 
2761     // Check for Ruby elements
2762     if (m_renderer-&gt;isRubyText())
2763         return AccessibilityRole::RubyText;
2764     if (m_renderer-&gt;isRubyBase())
</pre>
<hr />
<pre>
2836         return AccessibilityRole::Summary;
2837 
2838     // http://rawgit.com/w3c/aria/master/html-aam/html-aam.html
2839     // Output elements should be mapped to status role.
2840     if (isOutput())
2841         return AccessibilityRole::ApplicationStatus;
2842 
2843 #if ENABLE(VIDEO)
2844     if (is&lt;HTMLVideoElement&gt;(node))
2845         return AccessibilityRole::Video;
2846     if (is&lt;HTMLAudioElement&gt;(node))
2847         return AccessibilityRole::Audio;
2848 #endif
2849 
2850     // The HTML element should not be exposed as an element. That&#39;s what the RenderView element does.
2851     if (node &amp;&amp; node-&gt;hasTagName(htmlTag))
2852         return AccessibilityRole::Ignored;
2853 
2854     // There should only be one banner/contentInfo per page. If header/footer are being used within an article or section
2855     // then it should not be exposed as whole page&#39;s banner/contentInfo
<span class="line-modified">2856     if (node &amp;&amp; node-&gt;hasTagName(headerTag) &amp;&amp; !isDescendantOfElementType(articleTag) &amp;&amp; !isDescendantOfElementType(sectionTag))</span>
2857         return AccessibilityRole::LandmarkBanner;
<span class="line-modified">2858     if (node &amp;&amp; node-&gt;hasTagName(footerTag) &amp;&amp; !isDescendantOfElementType(articleTag) &amp;&amp; !isDescendantOfElementType(sectionTag))</span>





2859         return AccessibilityRole::Footer;

2860 
2861     // menu tags with toolbar type should have Toolbar role.
2862     if (node &amp;&amp; node-&gt;hasTagName(menuTag) &amp;&amp; equalLettersIgnoringASCIICase(getAttribute(typeAttr), &quot;toolbar&quot;))
2863         return AccessibilityRole::Toolbar;
2864 
2865     if (node &amp;&amp; node-&gt;hasTagName(timeTag))
2866         return AccessibilityRole::Time;
2867 
2868     // If the element does not have role, but it has ARIA attributes, or accepts tab focus, accessibility should fallback to exposing it as a group.
2869     if (supportsARIAAttributes() || canSetFocusAttribute())
2870         return AccessibilityRole::Group;
2871 
2872     if (m_renderer-&gt;isRenderBlockFlow())
2873         return m_renderer-&gt;isAnonymousBlock() ? AccessibilityRole::TextGroup : AccessibilityRole::Group;
2874 
2875     // InlineRole is the final fallback before assigning AccessibilityRole::Unknown to an object. It makes it
2876     // possible to distinguish truly unknown objects from non-focusable inline text elements
2877     // which have an event handler or attribute suggesting possible inclusion by the platform.
2878     if (is&lt;RenderInline&gt;(*m_renderer)
2879         &amp;&amp; (hasAttributesRequiredForInclusion()
2880             || (node &amp;&amp; node-&gt;hasEventListeners())
2881             || (supportsDatetimeAttribute() &amp;&amp; !getAttribute(datetimeAttr).isEmpty())))
2882         return AccessibilityRole::Inline;
2883 
2884     return AccessibilityRole::Unknown;
2885 }
2886 
2887 AccessibilityOrientation AccessibilityRenderObject::orientation() const
2888 {
<span class="line-modified">2889     const AtomicString&amp; ariaOrientation = getAttribute(aria_orientationAttr);</span>
2890     if (equalLettersIgnoringASCIICase(ariaOrientation, &quot;horizontal&quot;))
2891         return AccessibilityOrientation::Horizontal;
2892     if (equalLettersIgnoringASCIICase(ariaOrientation, &quot;vertical&quot;))
2893         return AccessibilityOrientation::Vertical;
2894     if (equalLettersIgnoringASCIICase(ariaOrientation, &quot;undefined&quot;))
2895         return AccessibilityOrientation::Undefined;
2896 
2897     // In ARIA 1.1, the implicit value of aria-orientation changed from horizontal
2898     // to undefined on all roles that don&#39;t have their own role-specific values. In
2899     // addition, the implicit value of combobox became undefined.
2900     if (isComboBox() || isRadioGroup() || isTreeGrid())
2901         return AccessibilityOrientation::Undefined;
2902 
2903     if (isScrollbar() || isListBox() || isMenu() || isTree())
2904         return AccessibilityOrientation::Vertical;
2905 
2906     if (isMenuBar() || isSplitter() || isTabList() || isToolbar() || isSlider())
2907         return AccessibilityOrientation::Horizontal;
2908 
2909     return AccessibilityObject::orientation();
</pre>
<hr />
<pre>
2970 {
2971     switch (m_ariaRole) {
2972     case AccessibilityRole::Button:
2973     case AccessibilityRole::Slider:
2974     case AccessibilityRole::Image:
2975     case AccessibilityRole::ProgressIndicator:
2976     case AccessibilityRole::SpinButton:
2977     // case SeparatorRole:
2978         return true;
2979     default:
2980         return false;
2981     }
2982 }
2983 
2984 bool AccessibilityRenderObject::canSetExpandedAttribute() const
2985 {
2986     if (roleValue() == AccessibilityRole::Details)
2987         return true;
2988 
2989     // An object can be expanded if it aria-expanded is true or false.
<span class="line-modified">2990     const AtomicString&amp; expanded = getAttribute(aria_expandedAttr);</span>
2991     if (equalLettersIgnoringASCIICase(expanded, &quot;true&quot;) || equalLettersIgnoringASCIICase(expanded, &quot;false&quot;))
2992         return true;
2993     return false;
2994 }
2995 
2996 bool AccessibilityRenderObject::canSetTextRangeAttributes() const
2997 {
2998     return isTextControl();
2999 }
3000 
3001 void AccessibilityRenderObject::textChanged()
3002 {
3003     // If this element supports ARIA live regions, or is part of a region with an ARIA editable role,
3004     // then notify the AT of changes.
3005     AXObjectCache* cache = axObjectCache();
3006     if (!cache)
3007         return;
3008 
3009     for (RenderObject* renderParent = renderer(); renderParent; renderParent = renderParent-&gt;parent()) {
3010         AccessibilityObject* parent = cache-&gt;get(renderParent);
</pre>
<hr />
<pre>
3230             if (childObject)
3231                 insertionIndex = m_children.find(childObject) + 1;
3232             continue;
3233         }
3234 
3235         if (!isNodeAriaVisible(child))
3236             continue;
3237 
3238         unsigned previousSize = m_children.size();
3239         if (insertionIndex &gt; previousSize)
3240             insertionIndex = previousSize;
3241 
3242         insertChild(axObjectCache()-&gt;getOrCreate(child), insertionIndex);
3243         insertionIndex += (m_children.size() - previousSize);
3244     }
3245 }
3246 
3247 void AccessibilityRenderObject::updateRoleAfterChildrenCreation()
3248 {
3249     // If a menu does not have valid menuitem children, it should not be exposed as a menu.
<span class="line-modified">3250     if (roleValue() == AccessibilityRole::Menu) {</span>

3251         // Elements marked as menus must have at least one menu item child.
3252         size_t menuItemCount = 0;
3253         for (const auto&amp; child : children()) {
3254             if (child-&gt;isMenuItem()) {
3255                 menuItemCount++;
3256                 break;
3257             }
3258         }
3259 
3260         if (!menuItemCount)
3261             m_role = AccessibilityRole::Group;
3262     }


3263 }
3264 
3265 void AccessibilityRenderObject::addChildren()
3266 {
3267     // If the need to add more children in addition to existing children arises,
3268     // childrenChanged should have been called, leaving the object with no children.
3269     ASSERT(!m_haveChildren);
3270 
3271     m_haveChildren = true;
3272 
3273     if (!canHaveChildren())
3274         return;
3275 
3276     for (RefPtr&lt;AccessibilityObject&gt; obj = firstChild(); obj; obj = obj-&gt;nextSibling())
3277         addChild(obj.get());
3278 
3279     m_subtreeDirty = false;
3280 
3281     addHiddenChildren();
3282     addAttachmentChildren();
</pre>
<hr />
<pre>
3285     addCanvasChildren();
3286     addRemoteSVGChildren();
3287 
3288 #if PLATFORM(COCOA)
3289     updateAttachmentViewParents();
3290 #endif
3291 
3292     updateRoleAfterChildrenCreation();
3293 }
3294 
3295 bool AccessibilityRenderObject::canHaveChildren() const
3296 {
3297     if (!m_renderer)
3298         return false;
3299 
3300     return AccessibilityNodeObject::canHaveChildren();
3301 }
3302 
3303 const String AccessibilityRenderObject::liveRegionStatus() const
3304 {
<span class="line-modified">3305     const AtomicString&amp; liveRegionStatus = getAttribute(aria_liveAttr);</span>
3306     // These roles have implicit live region status.
3307     if (liveRegionStatus.isEmpty())
3308         return defaultLiveRegionStatusForRole(roleValue());
3309 
3310     return liveRegionStatus;
3311 }
3312 
3313 const String AccessibilityRenderObject::liveRegionRelevant() const
3314 {
<span class="line-modified">3315     static NeverDestroyed&lt;const AtomicString&gt; defaultLiveRegionRelevant(&quot;additions text&quot;, AtomicString::ConstructFromLiteral);</span>
<span class="line-modified">3316     const AtomicString&amp; relevant = getAttribute(aria_relevantAttr);</span>
3317 
3318     // Default aria-relevant = &quot;additions text&quot;.
3319     if (relevant.isEmpty())
3320         return &quot;additions text&quot;;
3321 
3322     return relevant;
3323 }
3324 
3325 bool AccessibilityRenderObject::liveRegionAtomic() const
3326 {
<span class="line-modified">3327     const AtomicString&amp; atomic = getAttribute(aria_atomicAttr);</span>
3328     if (equalLettersIgnoringASCIICase(atomic, &quot;true&quot;))
3329         return true;
3330     if (equalLettersIgnoringASCIICase(atomic, &quot;false&quot;))
3331         return false;
3332 
3333     // WAI-ARIA &quot;alert&quot; and &quot;status&quot; roles have an implicit aria-atomic value of true.
3334     switch (roleValue()) {
3335     case AccessibilityRole::ApplicationAlert:
3336     case AccessibilityRole::ApplicationStatus:
3337         return true;
3338     default:
3339         return false;
3340     }
3341 }
3342 
3343 bool AccessibilityRenderObject::isBusy() const
3344 {
3345     return elementAttributeValue(aria_busyAttr);
3346 }
3347 
</pre>
<hr />
<pre>
3428         return;
3429     case AccessibilityRole::Grid:
3430     case AccessibilityRole::Tree:
3431     case AccessibilityRole::TreeGrid:
3432         ariaSelectedRows(result);
3433         return;
3434     case AccessibilityRole::TabList:
3435         if (AccessibilityObject* selectedTab = selectedTabItem())
3436             result.append(selectedTab);
3437         return;
3438     case AccessibilityRole::List:
3439         if (auto* selectedListItemChild = selectedListItem())
3440             result.append(selectedListItemChild);
3441         return;
3442     case AccessibilityRole::Menu:
3443     case AccessibilityRole::MenuBar:
3444         if (AccessibilityObject* descendant = activeDescendant()) {
3445             result.append(descendant);
3446             return;
3447         }
<span class="line-modified">3448         if (AccessibilityObject* focusedElement = focusedUIElement()) {</span>
3449             result.append(focusedElement);
3450             return;
3451         }
3452         return;
3453     default:
3454         ASSERT_NOT_REACHED();
3455     }
3456 }
3457 
3458 void AccessibilityRenderObject::ariaListboxVisibleChildren(AccessibilityChildrenVector&amp; result)
3459 {
3460     if (!hasChildren())
3461         addChildren();
3462 
3463     for (const auto&amp; child : children()) {
3464         if (child-&gt;isOffScreen())
3465             result.append(child);
3466     }
3467 }
3468 
</pre>
<hr />
<pre>
3505     case AccessibilityRole::ToggleButton:
3506         return buttonAction;
3507     case AccessibilityRole::TextField:
3508     case AccessibilityRole::TextArea:
3509         return textFieldAction;
3510     case AccessibilityRole::RadioButton:
3511         return radioButtonAction;
3512     case AccessibilityRole::CheckBox:
3513         return isChecked() ? checkedCheckBoxAction : uncheckedCheckBoxAction;
3514     case AccessibilityRole::Link:
3515     case AccessibilityRole::WebCoreLink:
3516         return linkAction;
3517     default:
3518         return nullAtom();
3519     }
3520 #else
3521     return nullAtom();
3522 #endif
3523 }
3524 
<span class="line-modified">3525 void AccessibilityRenderObject::setAccessibleName(const AtomicString&amp; name)</span>
3526 {
3527     // Setting the accessible name can store the value in the DOM
3528     if (!m_renderer)
3529         return;
3530 
3531     Node* node = nullptr;
3532     // For web areas, set the aria-label on the HTML element.
3533     if (isWebArea())
3534         node = m_renderer-&gt;document().documentElement();
3535     else
3536         node = m_renderer-&gt;node();
3537 
3538     if (is&lt;Element&gt;(node))
3539         downcast&lt;Element&gt;(*node).setAttribute(aria_labelAttr, name);
3540 }
3541 
3542 static bool isLinkable(const AccessibilityRenderObject&amp; object)
3543 {
3544     if (!object.renderer())
3545         return false;
</pre>
<hr />
<pre>
3593     if (!m_renderer)
3594         return false;
3595 
3596     if (!canHavePlainText())
3597         return false;
3598 
3599     const RenderStyle&amp; style = m_renderer-&gt;style();
3600     return style.fontDescription().weight() == normalWeightValue()
3601         &amp;&amp; !isItalic(style.fontDescription().italic())
3602         &amp;&amp; style.textDecorationsInEffect().isEmpty();
3603 }
3604 
3605 bool AccessibilityRenderObject::hasSameFont(RenderObject* renderer) const
3606 {
3607     if (!m_renderer || !renderer)
3608         return false;
3609 
3610     return m_renderer-&gt;style().fontDescription().families() == renderer-&gt;style().fontDescription().families();
3611 }
3612 
















3613 bool AccessibilityRenderObject::hasSameFontColor(RenderObject* renderer) const
3614 {
3615     if (!m_renderer || !renderer)
3616         return false;
3617 
3618     return m_renderer-&gt;style().visitedDependentColor(CSSPropertyColor) == renderer-&gt;style().visitedDependentColor(CSSPropertyColor);
3619 }
3620 
3621 bool AccessibilityRenderObject::hasSameStyle(RenderObject* renderer) const
3622 {
3623     if (!m_renderer || !renderer)
3624         return false;
3625 
3626     return m_renderer-&gt;style() == renderer-&gt;style();
3627 }
3628 
3629 bool AccessibilityRenderObject::hasUnderline() const
3630 {
3631     if (!m_renderer)
3632         return false;
</pre>
</td>
<td>
<hr />
<pre>
  21 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  22 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  23 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  24 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  25 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  26 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  27 */
  28 
  29 #include &quot;config.h&quot;
  30 #include &quot;AccessibilityRenderObject.h&quot;
  31 
  32 #include &quot;AXObjectCache.h&quot;
  33 #include &quot;AccessibilityImageMapLink.h&quot;
  34 #include &quot;AccessibilityLabel.h&quot;
  35 #include &quot;AccessibilityListBox.h&quot;
  36 #include &quot;AccessibilitySVGRoot.h&quot;
  37 #include &quot;AccessibilitySpinButton.h&quot;
  38 #include &quot;AccessibilityTable.h&quot;
  39 #include &quot;CachedImage.h&quot;
  40 #include &quot;Editing.h&quot;
<span class="line-added">  41 #include &quot;Editor.h&quot;</span>
  42 #include &quot;ElementIterator.h&quot;
  43 #include &quot;FloatRect.h&quot;
  44 #include &quot;Frame.h&quot;
  45 #include &quot;FrameLoader.h&quot;
  46 #include &quot;FrameSelection.h&quot;
  47 #include &quot;HTMLAreaElement.h&quot;
  48 #include &quot;HTMLAudioElement.h&quot;
  49 #include &quot;HTMLDetailsElement.h&quot;
  50 #include &quot;HTMLFormElement.h&quot;
  51 #include &quot;HTMLFrameElementBase.h&quot;
  52 #include &quot;HTMLImageElement.h&quot;
  53 #include &quot;HTMLInputElement.h&quot;
  54 #include &quot;HTMLLabelElement.h&quot;
  55 #include &quot;HTMLMapElement.h&quot;
  56 #include &quot;HTMLMeterElement.h&quot;
  57 #include &quot;HTMLNames.h&quot;
  58 #include &quot;HTMLOptionElement.h&quot;
  59 #include &quot;HTMLOptionsCollection.h&quot;
<span class="line-added">  60 #include &quot;HTMLParserIdioms.h&quot;</span>
  61 #include &quot;HTMLSelectElement.h&quot;
  62 #include &quot;HTMLSummaryElement.h&quot;
  63 #include &quot;HTMLTableElement.h&quot;
  64 #include &quot;HTMLTextAreaElement.h&quot;
  65 #include &quot;HTMLVideoElement.h&quot;
  66 #include &quot;HitTestRequest.h&quot;
  67 #include &quot;HitTestResult.h&quot;
  68 #include &quot;Image.h&quot;
  69 #include &quot;LocalizedStrings.h&quot;
  70 #include &quot;NodeList.h&quot;
  71 #include &quot;Page.h&quot;
  72 #include &quot;ProgressTracker.h&quot;
  73 #include &quot;RenderButton.h&quot;
  74 #include &quot;RenderFileUploadControl.h&quot;
  75 #include &quot;RenderHTMLCanvas.h&quot;
  76 #include &quot;RenderImage.h&quot;
  77 #include &quot;RenderInline.h&quot;
  78 #include &quot;RenderIterator.h&quot;
  79 #include &quot;RenderLayer.h&quot;
  80 #include &quot;RenderLineBreak.h&quot;
</pre>
<hr />
<pre>
 562 
 563     // bail if none found
 564     if (!currentRenderer)
 565         return nullptr;
 566 
 567     // search up the DOM tree for an anchor element
 568     // NOTE: this assumes that any non-image with an anchor is an HTMLAnchorElement
 569     for (Node* node = currentRenderer-&gt;node(); node; node = node-&gt;parentNode()) {
 570         if (is&lt;HTMLAnchorElement&gt;(*node) || (node-&gt;renderer() &amp;&amp; cache-&gt;getOrCreate(node-&gt;renderer())-&gt;isLink()))
 571             return downcast&lt;Element&gt;(node);
 572     }
 573 
 574     return nullptr;
 575 }
 576 
 577 String AccessibilityRenderObject::helpText() const
 578 {
 579     if (!m_renderer)
 580         return String();
 581 
<span class="line-modified"> 582     const AtomString&amp; ariaHelp = getAttribute(aria_helpAttr);</span>
 583     if (!ariaHelp.isEmpty())
 584         return ariaHelp;
 585 
 586     String describedBy = ariaDescribedByAttribute();
 587     if (!describedBy.isEmpty())
 588         return describedBy;
 589 
 590     String description = accessibilityDescription();
 591     for (RenderObject* ancestor = renderer(); ancestor; ancestor = ancestor-&gt;parent()) {
 592         if (is&lt;HTMLElement&gt;(ancestor-&gt;node())) {
 593             HTMLElement&amp; element = downcast&lt;HTMLElement&gt;(*ancestor-&gt;node());
<span class="line-modified"> 594             const AtomString&amp; summary = element.getAttribute(summaryAttr);</span>
 595             if (!summary.isEmpty())
 596                 return summary;
 597 
 598             // The title attribute should be used as help text unless it is already being used as descriptive text.
<span class="line-modified"> 599             const AtomString&amp; title = element.getAttribute(titleAttr);</span>
 600             if (!title.isEmpty() &amp;&amp; description != title)
 601                 return title;
 602         }
 603 
 604         // Only take help text from an ancestor element if its a group or an unknown role. If help was
 605         // added to those kinds of elements, it is likely it was meant for a child element.
 606         if (AccessibilityObject* axObj = axObjectCache()-&gt;getOrCreate(ancestor)) {
 607             if (!axObj-&gt;isGroup() &amp;&amp; axObj-&gt;roleValue() != AccessibilityRole::Unknown)
 608                 break;
 609         }
 610     }
 611 
 612     return String();
 613 }
 614 
 615 String AccessibilityRenderObject::textUnderElement(AccessibilityTextUnderElementMode mode) const
 616 {
 617     if (!m_renderer)
 618         return String();
 619 
</pre>
<hr />
<pre>
 732 
 733     RenderBoxModelObject* cssBox = renderBoxModelObject();
 734 
 735     if (isARIAStaticText()) {
 736         String staticText = text();
 737         if (!staticText.length())
 738             staticText = textUnderElement();
 739         return staticText;
 740     }
 741 
 742     if (is&lt;RenderText&gt;(*m_renderer))
 743         return textUnderElement();
 744 
 745     if (is&lt;RenderMenuList&gt;(cssBox)) {
 746         // RenderMenuList will go straight to the text() of its selected item.
 747         // This has to be overridden in the case where the selected item has an ARIA label.
 748         HTMLSelectElement&amp; selectElement = downcast&lt;HTMLSelectElement&gt;(*m_renderer-&gt;node());
 749         int selectedIndex = selectElement.selectedIndex();
 750         const Vector&lt;HTMLElement*&gt;&amp; listItems = selectElement.listItems();
 751         if (selectedIndex &gt;= 0 &amp;&amp; static_cast&lt;size_t&gt;(selectedIndex) &lt; listItems.size()) {
<span class="line-modified"> 752             const AtomString&amp; overriddenDescription = listItems[selectedIndex]-&gt;attributeWithoutSynchronization(aria_labelAttr);</span>
 753             if (!overriddenDescription.isNull())
 754                 return overriddenDescription;
 755         }
 756         return downcast&lt;RenderMenuList&gt;(*m_renderer).text();
 757     }
 758 
 759     if (is&lt;RenderListMarker&gt;(*m_renderer))
 760         return downcast&lt;RenderListMarker&gt;(*m_renderer).text();
 761 
 762     if (isWebArea())
 763         return String();
 764 
 765     if (isTextControl())
 766         return text();
 767 
 768 #if PLATFORM(IOS_FAMILY)
 769     if (isInputTypePopupButton())
 770         return textUnderElement();
 771 #endif
 772 
</pre>
<hr />
<pre>
 882     return is&lt;RenderSVGShape&gt;(renderer());
 883 }
 884 
 885 Path AccessibilityRenderObject::elementPath() const
 886 {
 887     if (is&lt;RenderSVGShape&gt;(renderer()) &amp;&amp; downcast&lt;RenderSVGShape&gt;(*m_renderer).hasPath()) {
 888         Path path = downcast&lt;RenderSVGShape&gt;(*m_renderer).path();
 889 
 890         // The SVG path is in terms of the parent&#39;s bounding box. The path needs to be offset to frame coordinates.
 891         if (auto svgRoot = ancestorsOfType&lt;RenderSVGRoot&gt;(*m_renderer).first()) {
 892             LayoutPoint parentOffset = axObjectCache()-&gt;getOrCreate(&amp;*svgRoot)-&gt;elementRect().location();
 893             path.transform(AffineTransform().translate(parentOffset.x(), parentOffset.y()));
 894         }
 895 
 896         return path;
 897     }
 898 
 899     return Path();
 900 }
 901 
<span class="line-added"> 902 IntPoint AccessibilityRenderObject::linkClickPoint()</span>
<span class="line-added"> 903 {</span>
<span class="line-added"> 904     ASSERT(isLink());</span>
<span class="line-added"> 905     /* A link bounding rect can contain points that are not part of the link.</span>
<span class="line-added"> 906      For instance, a link that starts at the end of a line and finishes at the</span>
<span class="line-added"> 907      beginning of the next line will have a bounding rect that includes the</span>
<span class="line-added"> 908      entire two lines. In such a case, the middle point of the bounding rect</span>
<span class="line-added"> 909      may not belong to the link element and thus may not activate the link.</span>
<span class="line-added"> 910      Hence, return the middle point of the first character in the link if exists.</span>
<span class="line-added"> 911      */</span>
<span class="line-added"> 912     if (RefPtr&lt;Range&gt; range = elementRange()) {</span>
<span class="line-added"> 913         VisiblePosition start = range-&gt;startPosition();</span>
<span class="line-added"> 914         VisiblePosition end = nextVisiblePosition(start);</span>
<span class="line-added"> 915         if (start.isNull() || !range-&gt;contains(end))</span>
<span class="line-added"> 916             return AccessibilityObject::clickPoint();</span>
<span class="line-added"> 917 </span>
<span class="line-added"> 918         RefPtr&lt;Range&gt; charRange = makeRange(start, end);</span>
<span class="line-added"> 919         IntRect rect = boundsForRange(charRange);</span>
<span class="line-added"> 920         return { rect.x() + rect.width() / 2, rect.y() + rect.height() / 2 };</span>
<span class="line-added"> 921     }</span>
<span class="line-added"> 922     return AccessibilityObject::clickPoint();</span>
<span class="line-added"> 923 }</span>
<span class="line-added"> 924 </span>
 925 IntPoint AccessibilityRenderObject::clickPoint()
 926 {
 927     // Headings are usually much wider than their textual content. If the mid point is used, often it can be wrong.
<span class="line-modified"> 928     AccessibilityChildrenVector children = this-&gt;children();</span>
<span class="line-modified"> 929     if (isHeading() &amp;&amp; children.size() == 1)</span>
<span class="line-added"> 930         return children[0]-&gt;clickPoint();</span>
<span class="line-added"> 931 </span>
<span class="line-added"> 932     if (isLink())</span>
<span class="line-added"> 933         return linkClickPoint();</span>
 934 
 935     // use the default position unless this is an editable web area, in which case we use the selection bounds.
 936     if (!isWebArea() || !canSetValueAttribute())
 937         return AccessibilityObject::clickPoint();
 938 
 939     VisibleSelection visSelection = selection();
 940     VisiblePositionRange range = VisiblePositionRange(visSelection.visibleStart(), visSelection.visibleEnd());
 941     IntRect bounds = boundsForVisiblePositionRange(range);
<span class="line-modified"> 942     return { bounds.x() + (bounds.width() / 2), bounds.y() + (bounds.height() / 2) };</span>



 943 }
 944 
 945 AccessibilityObject* AccessibilityRenderObject::internalLinkElement() const
 946 {
 947     Element* element = anchorElement();
 948     // Right now, we do not support ARIA links as internal link elements
 949     if (!is&lt;HTMLAnchorElement&gt;(element))
 950         return nullptr;
 951     HTMLAnchorElement&amp; anchor = downcast&lt;HTMLAnchorElement&gt;(*element);
 952 
 953     URL linkURL = anchor.href();
 954     String fragmentIdentifier = linkURL.fragmentIdentifier();
 955     if (fragmentIdentifier.isEmpty())
 956         return nullptr;
 957 
 958     // check if URL is the same as current URL
 959     URL documentURL = m_renderer-&gt;document().url();
 960     if (!equalIgnoringFragmentIdentifier(documentURL, linkURL))
 961         return nullptr;
 962 
</pre>
<hr />
<pre>
1015 
1016     if (isLink()) {
1017         AccessibilityObject* linkedAXElement = internalLinkElement();
1018         if (linkedAXElement)
1019             linkedUIElements.append(linkedAXElement);
1020     }
1021 
1022     if (roleValue() == AccessibilityRole::RadioButton)
1023         addRadioButtonGroupMembers(linkedUIElements);
1024 }
1025 
1026 bool AccessibilityRenderObject::hasTextAlternative() const
1027 {
1028     // ARIA: section 2A, bullet #3 says if aria-labeledby or aria-label appears, it should
1029     // override the &quot;label&quot; element association.
1030     return ariaAccessibilityDescription().length();
1031 }
1032 
1033 bool AccessibilityRenderObject::hasPopup() const
1034 {
<span class="line-modified">1035     // Return true if this has the aria-haspopup attribute, or if it has an ancestor of type link with the aria-haspopup attribute.</span>
<span class="line-added">1036     return AccessibilityObject::matchedParent(*this, true, [this] (const AccessibilityObject&amp; object) {</span>
<span class="line-added">1037         return (this == &amp;object) ? !equalLettersIgnoringASCIICase(object.popupValue(), &quot;false&quot;)</span>
<span class="line-added">1038             : object.isLink() &amp;&amp; !equalLettersIgnoringASCIICase(object.popupValue(), &quot;false&quot;);</span>
<span class="line-added">1039     });</span>
1040 }
1041 
1042 bool AccessibilityRenderObject::supportsARIADropping() const
1043 {
<span class="line-modified">1044     const AtomString&amp; dropEffect = getAttribute(aria_dropeffectAttr);</span>
1045     return !dropEffect.isEmpty();
1046 }
1047 
1048 bool AccessibilityRenderObject::supportsARIADragging() const
1049 {
<span class="line-modified">1050     const AtomString&amp; grabbed = getAttribute(aria_grabbedAttr);</span>
1051     return equalLettersIgnoringASCIICase(grabbed, &quot;true&quot;) || equalLettersIgnoringASCIICase(grabbed, &quot;false&quot;);
1052 }
1053 
1054 bool AccessibilityRenderObject::isARIAGrabbed()
1055 {
1056     return elementAttributeValue(aria_grabbedAttr);
1057 }
1058 
1059 Vector&lt;String&gt; AccessibilityRenderObject::determineARIADropEffects()
1060 {
<span class="line-modified">1061     const AtomString&amp; dropEffects = getAttribute(aria_dropeffectAttr);</span>
1062     if (dropEffects.isEmpty()) {
1063         return { };
1064     }
1065 
1066     String dropEffectsString = dropEffects.string();
1067     dropEffectsString.replace(&#39;\n&#39;, &#39; &#39;);
1068     return dropEffectsString.split(&#39; &#39;);
1069 }
1070 
1071 bool AccessibilityRenderObject::exposesTitleUIElement() const
1072 {
1073     if (!isControl() &amp;&amp; !isFigureElement())
1074         return false;
1075 
1076     // If this control is ignored (because it&#39;s invisible),
1077     // then the label needs to be exposed so it can be visible to accessibility.
1078     if (accessibilityIsIgnored())
1079         return true;
1080 
1081     // When controls have their own descriptions, the title element should be ignored.
</pre>
<hr />
<pre>
1086     // titleUIElement, otherwise its inner text will be announced by a screenreader.
1087     if (isLabelable()) {
1088         if (HTMLLabelElement* label = labelForElement(downcast&lt;Element&gt;(node()))) {
1089             if (!label-&gt;attributeWithoutSynchronization(aria_labelAttr).isEmpty())
1090                 return false;
1091             if (AccessibilityObject* labelObject = axObjectCache()-&gt;getOrCreate(label)) {
1092                 if (!labelObject-&gt;ariaLabeledByAttribute().isEmpty())
1093                     return false;
1094                 // To simplify instances where the labeling element includes widget descendants
1095                 // which it does not label.
1096                 if (is&lt;AccessibilityLabel&gt;(*labelObject)
1097                     &amp;&amp; downcast&lt;AccessibilityLabel&gt;(*labelObject).containsUnrelatedControls())
1098                     return false;
1099             }
1100         }
1101     }
1102 
1103     return true;
1104 }
1105 
<span class="line-added">1106 #if ENABLE(APPLE_PAY)</span>
<span class="line-added">1107 String AccessibilityRenderObject::applePayButtonDescription() const</span>
<span class="line-added">1108 {</span>
<span class="line-added">1109     switch (applePayButtonType()) {</span>
<span class="line-added">1110     case ApplePayButtonType::Plain:</span>
<span class="line-added">1111         return AXApplePayPlainLabel();</span>
<span class="line-added">1112     case ApplePayButtonType::Buy:</span>
<span class="line-added">1113         return AXApplePayBuyLabel();</span>
<span class="line-added">1114     case ApplePayButtonType::SetUp:</span>
<span class="line-added">1115         return AXApplePaySetupLabel();</span>
<span class="line-added">1116     case ApplePayButtonType::Donate:</span>
<span class="line-added">1117         return AXApplePayDonateLabel();</span>
<span class="line-added">1118 #if ENABLE(APPLE_PAY_SESSION_V4)</span>
<span class="line-added">1119     case ApplePayButtonType::CheckOut:</span>
<span class="line-added">1120         return AXApplePayCheckOutLabel();</span>
<span class="line-added">1121     case ApplePayButtonType::Book:</span>
<span class="line-added">1122         return AXApplePayBookLabel();</span>
<span class="line-added">1123     case ApplePayButtonType::Subscribe:</span>
<span class="line-added">1124         return AXApplePaySubscribeLabel();</span>
<span class="line-added">1125 #endif</span>
<span class="line-added">1126     }</span>
<span class="line-added">1127 }</span>
<span class="line-added">1128 #endif</span>
<span class="line-added">1129 </span>
<span class="line-added">1130 void AccessibilityRenderObject::titleElementText(Vector&lt;AccessibilityText&gt;&amp; textOrder) const</span>
<span class="line-added">1131 {</span>
<span class="line-added">1132 #if ENABLE(APPLE_PAY)</span>
<span class="line-added">1133     if (isApplePayButton()) {</span>
<span class="line-added">1134         textOrder.append(AccessibilityText(applePayButtonDescription(), AccessibilityTextSource::Alternative));</span>
<span class="line-added">1135         return;</span>
<span class="line-added">1136     }</span>
<span class="line-added">1137 #endif</span>
<span class="line-added">1138 </span>
<span class="line-added">1139     AccessibilityNodeObject::titleElementText(textOrder);</span>
<span class="line-added">1140 }</span>
<span class="line-added">1141 </span>
1142 AccessibilityObject* AccessibilityRenderObject::titleUIElement() const
1143 {
1144     if (!m_renderer)
1145         return nullptr;
1146 
1147     // if isFieldset is true, the renderer is guaranteed to be a RenderFieldset
1148     if (isFieldset())
1149         return axObjectCache()-&gt;getOrCreate(downcast&lt;RenderBlock&gt;(*m_renderer).findFieldsetLegend(RenderBlock::FieldsetIncludeFloatingOrOutOfFlow));
1150 
1151     if (isFigureElement())
1152         return captionForFigure();
1153 
1154     Node* node = m_renderer-&gt;node();
1155     if (!is&lt;Element&gt;(node))
1156         return nullptr;
1157     HTMLLabelElement* label = labelForElement(downcast&lt;Element&gt;(node));
1158     if (label &amp;&amp; label-&gt;renderer())
1159         return axObjectCache()-&gt;getOrCreate(label);
1160 
1161     return nullptr;
</pre>
<hr />
<pre>
1202 AccessibilityObjectInclusion AccessibilityRenderObject::defaultObjectInclusion() const
1203 {
1204     // The following cases can apply to any element that&#39;s a subclass of AccessibilityRenderObject.
1205 
1206     if (!m_renderer)
1207         return AccessibilityObjectInclusion::IgnoreObject;
1208 
1209     if (m_renderer-&gt;style().visibility() != Visibility::Visible) {
1210         // aria-hidden is meant to override visibility as the determinant in AX hierarchy inclusion.
1211         if (equalLettersIgnoringASCIICase(getAttribute(aria_hiddenAttr), &quot;false&quot;))
1212             return AccessibilityObjectInclusion::DefaultBehavior;
1213 
1214         return AccessibilityObjectInclusion::IgnoreObject;
1215     }
1216 
1217     return AccessibilityObject::defaultObjectInclusion();
1218 }
1219 
1220 static bool webAreaIsPresentational(RenderObject* renderer)
1221 {
<span class="line-modified">1222     if (!renderer || !is&lt;RenderView&gt;(*renderer))</span>
1223         return false;
1224 
1225     if (auto ownerElement = renderer-&gt;document().ownerElement())
1226         return nodeHasPresentationRole(ownerElement);
1227 
1228     return false;
1229 }
1230 
1231 bool AccessibilityRenderObject::computeAccessibilityIsIgnored() const
1232 {
1233 #ifndef NDEBUG
1234     ASSERT(m_initialized);
1235 #endif
1236 
1237     if (!m_renderer)
1238         return true;
1239 
1240     // Check first if any of the common reasons cause this element to be ignored.
1241     // Then process other use cases that need to be applied to all the various roles
1242     // that AccessibilityRenderObjects take on.
</pre>
<hr />
<pre>
1319 
1320     if (isLink())
1321         return false;
1322 
1323     if (isLandmark())
1324         return false;
1325 
1326     // all controls are accessible
1327     if (isControl())
1328         return false;
1329 
1330     if (isFigureElement())
1331         return false;
1332 
1333     switch (roleValue()) {
1334     case AccessibilityRole::Audio:
1335     case AccessibilityRole::DescriptionListTerm:
1336     case AccessibilityRole::DescriptionListDetail:
1337     case AccessibilityRole::Details:
1338     case AccessibilityRole::DocumentArticle:
<span class="line-added">1339     case AccessibilityRole::Footer:</span>
1340     case AccessibilityRole::LandmarkRegion:
1341     case AccessibilityRole::ListItem:
1342     case AccessibilityRole::Time:
1343     case AccessibilityRole::Video:
1344         return false;
1345     default:
1346         break;
1347     }
1348 
1349     if (ariaRoleAttribute() != AccessibilityRole::Unknown)
1350         return false;
1351 
1352     if (roleValue() == AccessibilityRole::HorizontalRule)
1353         return false;
1354 
1355     // don&#39;t ignore labels, because they serve as TitleUIElements
1356     Node* node = m_renderer-&gt;node();
1357     if (is&lt;HTMLLabelElement&gt;(node))
1358         return false;
1359 
</pre>
<hr />
<pre>
1491 }
1492 
1493 bool AccessibilityRenderObject::isLoaded() const
1494 {
1495     return !m_renderer-&gt;document().parser();
1496 }
1497 
1498 double AccessibilityRenderObject::estimatedLoadingProgress() const
1499 {
1500     if (!m_renderer)
1501         return 0;
1502 
1503     if (isLoaded())
1504         return 1.0;
1505 
1506     return m_renderer-&gt;page().progress().estimatedProgress();
1507 }
1508 
1509 int AccessibilityRenderObject::layoutCount() const
1510 {
<span class="line-modified">1511     if (!m_renderer || !is&lt;RenderView&gt;(*m_renderer))</span>
1512         return 0;
1513     return downcast&lt;RenderView&gt;(*m_renderer).frameView().layoutContext().layoutCount();
1514 }
1515 
1516 String AccessibilityRenderObject::text() const
1517 {
1518     if (isPasswordField())
1519         return passwordFieldValue();
1520 
1521     return AccessibilityNodeObject::text();
1522 }
1523 
1524 int AccessibilityRenderObject::textLength() const
1525 {
1526     ASSERT(isTextControl());
1527 
1528     if (isPasswordField())
1529         return passwordFieldValue().length();
1530 
1531     return text().length();
</pre>
<hr />
<pre>
1553     int end = indexForVisiblePosition(visibleSelection.end());
1554 
1555     return PlainTextRange(start, end - start);
1556 }
1557 
1558 String AccessibilityRenderObject::selectedText() const
1559 {
1560     ASSERT(isTextControl());
1561 
1562     if (isPasswordField())
1563         return String(); // need to return something distinct from empty string
1564 
1565     if (isNativeTextControl()) {
1566         HTMLTextFormControlElement&amp; textControl = downcast&lt;RenderTextControl&gt;(*m_renderer).textFormControlElement();
1567         return textControl.selectedText();
1568     }
1569 
1570     return doAXStringForRange(documentBasedSelectedTextRange());
1571 }
1572 
<span class="line-modified">1573 const AtomString&amp; AccessibilityRenderObject::accessKey() const</span>
1574 {
1575     Node* node = m_renderer-&gt;node();
1576     if (!is&lt;Element&gt;(node))
1577         return nullAtom();
1578     return downcast&lt;Element&gt;(*node).attributeWithoutSynchronization(accesskeyAttr);
1579 }
1580 
1581 VisibleSelection AccessibilityRenderObject::selection() const
1582 {
1583     return m_renderer-&gt;frame().selection().selection();
1584 }
1585 
1586 PlainTextRange AccessibilityRenderObject::selectedTextRange() const
1587 {
1588     ASSERT(isTextControl());
1589 
1590     if (isPasswordField())
1591         return PlainTextRange();
1592 
1593     AccessibilityRole ariaRole = ariaRoleAttribute();
</pre>
<hr />
<pre>
1708 
1709     // Menu items are considered selectable by assistive technologies
1710     if (isMenuItem())
1711         return isFocused() || parentObjectUnignored()-&gt;activeDescendant() == this;
1712 
1713     return false;
1714 }
1715 
1716 bool AccessibilityRenderObject::isTabItemSelected() const
1717 {
1718     if (!isTabItem() || !m_renderer)
1719         return false;
1720 
1721     Node* node = m_renderer-&gt;node();
1722     if (!node || !node-&gt;isElementNode())
1723         return false;
1724 
1725     // The ARIA spec says a tab item can also be selected if it is aria-labeled by a tabpanel
1726     // that has keyboard focus inside of it, or if a tabpanel in its aria-controls list has KB
1727     // focus inside of it.
<span class="line-modified">1728     AccessibilityObject* focusedElement = static_cast&lt;AccessibilityObject*&gt;(focusedUIElement());</span>
1729     if (!focusedElement)
1730         return false;
1731 
1732     Vector&lt;Element*&gt; elements;
1733     elementsFromAttribute(elements, aria_controlsAttr);
1734 
1735     AXObjectCache* cache = axObjectCache();
1736     if (!cache)
1737         return false;
1738 
1739     for (const auto&amp; element : elements) {
1740         AccessibilityObject* tabPanel = cache-&gt;getOrCreate(element);
1741 
1742         // A tab item should only control tab panels.
1743         if (!tabPanel || tabPanel-&gt;roleValue() != AccessibilityRole::TabPanel)
1744             continue;
1745 
1746         AccessibilityObject* checkFocusElement = focusedElement;
1747         // Check if the focused element is a descendant of the element controlled by the tab item.
1748         while (checkFocusElement) {
</pre>
<hr />
<pre>
1760     if (!m_renderer)
1761         return false;
1762 
1763     Document&amp; document = m_renderer-&gt;document();
1764 
1765     Element* focusedElement = document.focusedElement();
1766     if (!focusedElement)
1767         return false;
1768 
1769     // A web area is represented by the Document node in the DOM tree, which isn&#39;t focusable.
1770     // Check instead if the frame&#39;s selection controller is focused
1771     if (focusedElement == m_renderer-&gt;node()
1772         || (roleValue() == AccessibilityRole::WebArea &amp;&amp; document.frame()-&gt;selection().isFocusedAndActive()))
1773         return true;
1774 
1775     return false;
1776 }
1777 
1778 void AccessibilityRenderObject::setFocused(bool on)
1779 {



1780     if (!canSetFocusAttribute())
1781         return;
1782 
1783     Document* document = this-&gt;document();
1784     Node* node = this-&gt;node();
1785 
1786     if (!on || !is&lt;Element&gt;(node)) {
1787         document-&gt;setFocusedElement(nullptr);
1788         return;
1789     }
1790 
1791     // When a node is told to set focus, that can cause it to be deallocated, which means that doing
1792     // anything else inside this object will crash. To fix this, we added a RefPtr to protect this object
1793     // long enough for duration.
1794     RefPtr&lt;AccessibilityObject&gt; protectedThis(this);
1795 
1796     // If this node is already the currently focused node, then calling focus() won&#39;t do anything.
1797     // That is a problem when focus is removed from the webpage to chrome, and then returns.
1798     // In these cases, we need to do what keyboard and mouse focus do, which is reset focus first.
1799     if (document-&gt;focusedElement() == node)
</pre>
<hr />
<pre>
1810 void AccessibilityRenderObject::setSelectedRows(AccessibilityChildrenVector&amp; selectedRows)
1811 {
1812     // Setting selected only makes sense in trees and tables (and tree-tables).
1813     AccessibilityRole role = roleValue();
1814     if (role != AccessibilityRole::Tree &amp;&amp; role != AccessibilityRole::TreeGrid &amp;&amp; role != AccessibilityRole::Table &amp;&amp; role != AccessibilityRole::Grid)
1815         return;
1816 
1817     bool isMulti = isMultiSelectable();
1818     unsigned count = selectedRows.size();
1819     if (count &gt; 1 &amp;&amp; !isMulti)
1820         count = 1;
1821 
1822     for (const auto&amp; selectedRow : selectedRows)
1823         selectedRow-&gt;setSelected(true);
1824 }
1825 
1826 void AccessibilityRenderObject::setValue(const String&amp; string)
1827 {
1828     if (!m_renderer || !is&lt;Element&gt;(m_renderer-&gt;node()))
1829         return;


1830 
1831     Element&amp; element = downcast&lt;Element&gt;(*m_renderer-&gt;node());
1832     RenderObject&amp; renderer = *m_renderer;
1833 
1834     // We should use the editor&#39;s insertText to mimic typing into the field.
1835     // Also only do this when the field is in editing mode.
1836     if (Frame* frame = renderer.document().frame()) {
1837         Editor&amp; editor = frame-&gt;editor();
1838         if (element.shouldUseInputMethod()) {
1839             editor.clearText();
1840             editor.insertText(string, nullptr);
1841             return;
1842         }
1843     }
1844     // FIXME: Do we want to do anything here for ARIA textboxes?
1845     if (renderer.isTextField() &amp;&amp; is&lt;HTMLInputElement&gt;(element))
1846         downcast&lt;HTMLInputElement&gt;(element).setValue(string);
1847     else if (renderer.isTextArea() &amp;&amp; is&lt;HTMLTextAreaElement&gt;(element))
1848         downcast&lt;HTMLTextAreaElement&gt;(element).setValue(string);
1849 }
1850 
1851 bool AccessibilityRenderObject::supportsARIAOwns() const
1852 {
1853     if (!m_renderer)
1854         return false;
<span class="line-modified">1855     const AtomString&amp; ariaOwns = getAttribute(aria_ownsAttr);</span>
1856 
1857     return !ariaOwns.isEmpty();
1858 }
1859 
1860 RenderView* AccessibilityRenderObject::topRenderer() const
1861 {
1862     Document* topDoc = topDocument();
1863     if (!topDoc)
1864         return nullptr;
1865 
1866     return topDoc-&gt;renderView();
1867 }
1868 
1869 Document* AccessibilityRenderObject::document() const
1870 {
1871     if (!m_renderer)
1872         return nullptr;
1873     return &amp;m_renderer-&gt;document();
1874 }
1875 
1876 Widget* AccessibilityRenderObject::widget() const
1877 {
<span class="line-modified">1878     if (!m_renderer || !is&lt;RenderWidget&gt;(*m_renderer))</span>
1879         return nullptr;
1880     return downcast&lt;RenderWidget&gt;(*m_renderer).widget();
1881 }
1882 
1883 AccessibilityObject* AccessibilityRenderObject::accessibilityParentForImageMap(HTMLMapElement* map) const
1884 {
1885     // find an image that is using this map
1886     if (!map)
1887         return nullptr;
1888 
1889     HTMLImageElement* imageElement = map-&gt;imageElement();
1890     if (!imageElement)
1891         return nullptr;
1892 
1893     if (AXObjectCache* cache = axObjectCache())
1894         return cache-&gt;getOrCreate(imageElement);
1895 
1896     return nullptr;
1897 }
1898 
</pre>
<hr />
<pre>
1961         if (endPos.isNull())
1962             endPos = startPos;
1963     }
1964 
1965     return VisiblePositionRange(startPos, endPos);
1966 }
1967 
1968 VisiblePositionRange AccessibilityRenderObject::visiblePositionRangeForLine(unsigned lineCount) const
1969 {
1970     if (!lineCount || !m_renderer)
1971         return VisiblePositionRange();
1972 
1973     // iterate over the lines
1974     // FIXME: this is wrong when lineNumber is lineCount+1,  because nextLinePosition takes you to the
1975     // last offset of the last line
1976     VisiblePosition visiblePos = m_renderer-&gt;view().positionForPoint(IntPoint(), nullptr);
1977     VisiblePosition savedVisiblePos;
1978     while (--lineCount) {
1979         savedVisiblePos = visiblePos;
1980         visiblePos = nextLinePosition(visiblePos, 0);
<span class="line-modified">1981         if (visiblePos.isNull()</span>
<span class="line-added">1982             || visiblePos == savedVisiblePos</span>
<span class="line-added">1983             || visiblePos.equals(savedVisiblePos))</span>
1984             return VisiblePositionRange();
1985     }
1986 
1987     // make a caret selection for the marker position, then extend it to the line
1988     // NOTE: ignores results of sel.modify because it returns false when
1989     // starting at an empty line.  The resulting selection in that case
1990     // will be a caret at visiblePos.
1991     FrameSelection selection;
1992     selection.setSelection(VisibleSelection(visiblePos));
1993     selection.modify(FrameSelection::AlterationExtend, DirectionRight, LineBoundary);
1994 
1995     return VisiblePositionRange(selection.selection().visibleStart(), selection.selection().visibleEnd());
1996 }
1997 
1998 VisiblePosition AccessibilityRenderObject::visiblePositionForIndex(int index) const
1999 {
2000     if (!m_renderer)
2001         return VisiblePosition();
2002 
2003     if (isNativeTextControl())
</pre>
<hr />
<pre>
2012 
2013     return visiblePositionForIndexUsingCharacterIterator(*node, index);
2014 }
2015 
2016 int AccessibilityRenderObject::indexForVisiblePosition(const VisiblePosition&amp; position) const
2017 {
2018     if (isNativeTextControl())
2019         return downcast&lt;RenderTextControl&gt;(*m_renderer).textFormControlElement().indexForVisiblePosition(position);
2020 
2021     if (!isTextControl())
2022         return 0;
2023 
2024     Node* node = m_renderer-&gt;node();
2025     if (!node)
2026         return 0;
2027 
2028     Position indexPosition = position.deepEquivalent();
2029     if (indexPosition.isNull() || highestEditableRoot(indexPosition, HasEditableAXRole) != node)
2030         return 0;
2031 
<span class="line-modified">2032 #if USE(ATK)</span>
2033     // We need to consider replaced elements for GTK, as they will be
2034     // presented with the &#39;object replacement character&#39; (0xFFFC).
2035     bool forSelectionPreservation = true;
2036 #else
2037     bool forSelectionPreservation = false;
2038 #endif
2039 
2040     return WebCore::indexForVisiblePosition(*node, position, forSelectionPreservation);
2041 }
2042 
2043 Element* AccessibilityRenderObject::rootEditableElementForPosition(const Position&amp; position) const
2044 {
2045     // Find the root editable or pseudo-editable (i.e. having an editable ARIA role) element.
2046     Element* result = nullptr;
2047 
2048     Element* rootEditableElement = position.rootEditableElement();
2049 
2050     for (Element* e = position.element(); e &amp;&amp; e != rootEditableElement; e = e-&gt;parentElement()) {
2051         if (nodeIsTextControl(e))
2052             result = e;
</pre>
<hr />
<pre>
2056 
2057     if (result)
2058         return result;
2059 
2060     return rootEditableElement;
2061 }
2062 
2063 bool AccessibilityRenderObject::nodeIsTextControl(const Node* node) const
2064 {
2065     if (!node)
2066         return false;
2067 
2068     if (AXObjectCache* cache = axObjectCache()) {
2069         if (AccessibilityObject* axObjectForNode = cache-&gt;getOrCreate(const_cast&lt;Node*&gt;(node)))
2070             return axObjectForNode-&gt;isTextControl();
2071     }
2072 
2073     return false;
2074 }
2075 
<span class="line-modified">2076 IntRect AccessibilityRenderObject::boundsForRects(LayoutRect const&amp; rect1, LayoutRect const&amp; rect2, RefPtr&lt;Range&gt; const&amp; dataRange)</span>
2077 {
2078     LayoutRect ourRect = rect1;
2079     ourRect.unite(rect2);
2080 
2081     // if the rectangle spans lines and contains multiple text chars, use the range&#39;s bounding box intead
2082     if (rect1.maxY() != rect2.maxY()) {
2083         LayoutRect boundingBox = dataRange-&gt;absoluteBoundingBox();
2084         String rangeString = plainText(dataRange.get());
2085         if (rangeString.length() &gt; 1 &amp;&amp; !boundingBox.isEmpty())
2086             ourRect = boundingBox;
2087     }
2088 



2089     return snappedIntRect(ourRect);

2090 }
2091 
2092 IntRect AccessibilityRenderObject::boundsForVisiblePositionRange(const VisiblePositionRange&amp; visiblePositionRange) const
2093 {
2094     if (visiblePositionRange.isNull())
2095         return IntRect();
2096 
2097     // Create a mutable VisiblePositionRange.
2098     VisiblePositionRange range(visiblePositionRange);
2099     LayoutRect rect1 = range.start.absoluteCaretBounds();
2100     LayoutRect rect2 = range.end.absoluteCaretBounds();
2101 
2102     // readjust for position at the edge of a line.  This is to exclude line rect that doesn&#39;t need to be accounted in the range bounds
2103     if (rect2.y() != rect1.y()) {
2104         VisiblePosition endOfFirstLine = endOfLine(range.start);
2105         if (range.start == endOfFirstLine) {
2106             range.start.setAffinity(DOWNSTREAM);
2107             rect1 = range.start.absoluteCaretBounds();
2108         }
2109         if (range.end == endOfFirstLine) {
</pre>
<hr />
<pre>
2376         return nullptr;
2377 
2378     AccessibilityObject* parent = nullptr;
2379     for (Element* mapParent = area-&gt;parentElement(); mapParent; mapParent = mapParent-&gt;parentElement()) {
2380         if (is&lt;HTMLMapElement&gt;(*mapParent)) {
2381             parent = accessibilityParentForImageMap(downcast&lt;HTMLMapElement&gt;(mapParent));
2382             break;
2383         }
2384     }
2385     if (!parent)
2386         return nullptr;
2387 
2388     for (const auto&amp; child : parent-&gt;children()) {
2389         if (child-&gt;elementRect().contains(point))
2390             return child.get();
2391     }
2392 
2393     return nullptr;
2394 }
2395 
<span class="line-modified">2396 AccessibilityObjectInterface* AccessibilityRenderObject::remoteSVGElementHitTest(const IntPoint&amp; point) const</span>
2397 {
2398     AccessibilityObject* remote = remoteSVGRootElement(Create);
2399     if (!remote)
2400         return nullptr;
2401 
2402     IntSize offset = point - roundedIntPoint(boundingBoxRect().location());
2403     return remote-&gt;accessibilityHitTest(IntPoint(offset));
2404 }
2405 
<span class="line-modified">2406 AccessibilityObjectInterface* AccessibilityRenderObject::elementAccessibilityHitTest(const IntPoint&amp; point) const</span>
2407 {
2408     if (isSVGImage())
2409         return remoteSVGElementHitTest(point);
2410 
2411     return AccessibilityObject::elementAccessibilityHitTest(point);
2412 }
2413 
2414 static bool shouldUseShadowHostForHitTesting(Node* shadowHost)
2415 {
2416     // We need to allow automation of mouse events on video tags.
2417     return shadowHost &amp;&amp; !shadowHost-&gt;hasTagName(videoTag);
2418 }
2419 
<span class="line-modified">2420 AccessibilityObjectInterface* AccessibilityRenderObject::accessibilityHitTest(const IntPoint&amp; point) const</span>
2421 {
2422     if (!m_renderer || !m_renderer-&gt;hasLayer())
2423         return nullptr;
2424 
2425     m_renderer-&gt;document().updateLayout();
2426 
2427     if (!m_renderer || !m_renderer-&gt;hasLayer())
2428         return nullptr;
2429 
2430     RenderLayer* layer = downcast&lt;RenderBox&gt;(*m_renderer).layer();
2431 
2432     HitTestRequest request(HitTestRequest::ReadOnly | HitTestRequest::Active | HitTestRequest::AccessibilityHitTest);
2433     HitTestResult hitTestResult = HitTestResult(point);
2434     layer-&gt;hitTest(request, hitTestResult);
2435     Node* node = hitTestResult.innerNode();
2436     if (!node)
2437         return nullptr;
2438     Node* shadowAncestorNode = node-&gt;shadowHost();
2439     if (shouldUseShadowHostForHitTesting(shadowAncestorNode))
2440         node = shadowAncestorNode;
2441     ASSERT(node);
2442 
2443     if (is&lt;HTMLAreaElement&gt;(*node))
2444         return accessibilityImageMapHitTest(downcast&lt;HTMLAreaElement&gt;(node), point);
2445 
2446     if (is&lt;HTMLOptionElement&gt;(*node))
2447         node = downcast&lt;HTMLOptionElement&gt;(*node).ownerSelectElement();
2448 
2449     RenderObject* obj = node-&gt;renderer();
2450     if (!obj)
2451         return nullptr;
2452 
2453     AccessibilityObject* result = obj-&gt;document().axObjectCache()-&gt;getOrCreate(obj);
2454     result-&gt;updateChildrenIfNecessary();
2455 
2456     // Allow the element to perform any hit-testing it might need to do to reach non-render children.
<span class="line-modified">2457     result = static_cast&lt;AccessibilityObject*&gt;(result-&gt;elementAccessibilityHitTest(point));</span>
2458 
2459     if (result &amp;&amp; result-&gt;accessibilityIsIgnored()) {
2460         // If this element is the label of a control, a hit test should return the control.
2461         AccessibilityObject* controlObject = result-&gt;correspondingControlForLabelElement();
2462         if (controlObject &amp;&amp; !controlObject-&gt;exposesTitleUIElement())
2463             return controlObject;
2464 
2465         result = result-&gt;parentObjectUnignored();
2466     }
2467 
2468     return result;
2469 }
2470 
2471 bool AccessibilityRenderObject::shouldNotifyActiveDescendant() const
2472 {
<span class="line-modified">2473 #if USE(ATK)</span>
2474     // According to the Core AAM spec, ATK expects object:state-changed:focused notifications
2475     // whenever the active descendant changes.
2476     return true;
2477 #endif
2478     // We want to notify that the combo box has changed its active descendant,
2479     // but we do not want to change the focus, because focus should remain with the combo box.
2480     if (isComboBox())
2481         return true;
2482 
2483     return shouldFocusActiveDescendant();
2484 }
2485 
2486 bool AccessibilityRenderObject::shouldFocusActiveDescendant() const
2487 {
2488     switch (ariaRoleAttribute()) {
2489     case AccessibilityRole::ApplicationGroup:
2490     case AccessibilityRole::ListBox:
2491     case AccessibilityRole::Menu:
2492     case AccessibilityRole::MenuBar:
2493     case AccessibilityRole::RadioGroup:
2494     case AccessibilityRole::Row:
2495     case AccessibilityRole::PopUpButton:
<span class="line-added">2496     case AccessibilityRole::Meter:</span>
2497     case AccessibilityRole::ProgressIndicator:
2498     case AccessibilityRole::Toolbar:
2499     case AccessibilityRole::Outline:
2500     case AccessibilityRole::Tree:
2501     case AccessibilityRole::Grid:
2502     /* FIXME: replace these with actual roles when they are added to AccessibilityRole
2503     composite
2504     alert
2505     alertdialog
2506     status
2507     timer
2508     */
2509         return true;
2510     default:
2511         return false;
2512     }
2513 }
2514 
2515 AccessibilityObject* AccessibilityRenderObject::activeDescendant() const
2516 {
2517     if (!m_renderer)
2518         return nullptr;
2519 
<span class="line-modified">2520     const AtomString&amp; activeDescendantAttrStr = getAttribute(aria_activedescendantAttr);</span>
2521     if (activeDescendantAttrStr.isNull() || activeDescendantAttrStr.isEmpty())
2522         return nullptr;
2523     Element* element = this-&gt;element();
2524     if (!element)
2525         return nullptr;
2526 
2527     Element* target = element-&gt;treeScope().getElementById(activeDescendantAttrStr);
2528     if (!target)
2529         return nullptr;
2530 
2531     if (AXObjectCache* cache = axObjectCache()) {
2532         AccessibilityObject* obj = cache-&gt;getOrCreate(target);
2533         if (obj &amp;&amp; obj-&gt;isAccessibilityRenderObject())
2534             // an activedescendant is only useful if it has a renderer, because that&#39;s what&#39;s needed to post the notification
2535             return obj;
2536     }
2537 
2538     return nullptr;
2539 }
2540 
</pre>
<hr />
<pre>
2672     // Textboxes should send out notifications.
2673     if (nodeHasRole(node, &quot;textbox&quot;) || (is&lt;Element&gt;(*node) &amp;&amp; contentEditableAttributeIsEnabled(downcast&lt;Element&gt;(node))))
2674         return true;
2675 
2676     return false;
2677 }
2678 
2679 AccessibilityObject* AccessibilityRenderObject::observableObject() const
2680 {
2681     // Find the object going up the parent chain that is used in accessibility to monitor certain notifications.
2682     for (RenderObject* renderer = this-&gt;renderer(); renderer &amp;&amp; renderer-&gt;node(); renderer = renderer-&gt;parent()) {
2683         if (renderObjectIsObservable(*renderer)) {
2684             if (AXObjectCache* cache = axObjectCache())
2685                 return cache-&gt;getOrCreate(renderer);
2686         }
2687     }
2688 
2689     return nullptr;
2690 }
2691 
<span class="line-added">2692 bool AccessibilityRenderObject::isDescendantOfElementType(const HashSet&lt;QualifiedName&gt;&amp; tagNames) const</span>
<span class="line-added">2693 {</span>
<span class="line-added">2694     for (auto&amp; ancestor : ancestorsOfType&lt;RenderElement&gt;(*m_renderer)) {</span>
<span class="line-added">2695         if (ancestor.element() &amp;&amp; tagNames.contains(ancestor.element()-&gt;tagQName()))</span>
<span class="line-added">2696             return true;</span>
<span class="line-added">2697     }</span>
<span class="line-added">2698     return false;</span>
<span class="line-added">2699 }</span>
<span class="line-added">2700 </span>
2701 bool AccessibilityRenderObject::isDescendantOfElementType(const QualifiedName&amp; tagName) const
2702 {
2703     for (auto&amp; ancestor : ancestorsOfType&lt;RenderElement&gt;(*m_renderer)) {
2704         if (ancestor.element() &amp;&amp; ancestor.element()-&gt;hasTagName(tagName))
2705             return true;
2706     }
2707     return false;
2708 }
2709 
2710 String AccessibilityRenderObject::expandedTextValue() const
2711 {
2712     if (AccessibilityObject* parent = parentObject()) {
2713         if (parent-&gt;hasTagName(abbrTag) || parent-&gt;hasTagName(acronymTag))
2714             return parent-&gt;getAttribute(titleAttr);
2715     }
2716 
2717     return String();
2718 }
2719 
2720 bool AccessibilityRenderObject::supportsExpandedTextValue() const
2721 {
2722     if (roleValue() == AccessibilityRole::StaticText) {
2723         if (AccessibilityObject* parent = parentObject())
2724             return parent-&gt;hasTagName(abbrTag) || parent-&gt;hasTagName(acronymTag);
2725     }
2726 
2727     return false;
2728 }
2729 
2730 AccessibilityRole AccessibilityRenderObject::determineAccessibilityRole()
2731 {
2732     if (!m_renderer)
2733         return AccessibilityRole::Unknown;
2734 
<span class="line-added">2735 #if ENABLE(APPLE_PAY)</span>
<span class="line-added">2736     if (isApplePayButton())</span>
<span class="line-added">2737         return AccessibilityRole::Button;</span>
<span class="line-added">2738 #endif</span>
<span class="line-added">2739 </span>
2740     // Sometimes we need to ignore the attribute role. Like if a tree is malformed,
2741     // we want to ignore the treeitem&#39;s attribute role.
2742     if ((m_ariaRole = determineAriaRoleAttribute()) != AccessibilityRole::Unknown &amp;&amp; !shouldIgnoreAttributeRole())
2743         return m_ariaRole;
2744 
2745     Node* node = m_renderer-&gt;node();
2746     RenderBoxModelObject* cssBox = renderBoxModelObject();
2747 
2748     if (node &amp;&amp; node-&gt;isLink())
2749         return AccessibilityRole::WebCoreLink;
2750     if (node &amp;&amp; is&lt;HTMLImageElement&gt;(*node) &amp;&amp; downcast&lt;HTMLImageElement&gt;(*node).hasAttributeWithoutSynchronization(usemapAttr))
2751         return AccessibilityRole::ImageMap;
2752     if ((cssBox &amp;&amp; cssBox-&gt;isListItem()) || (node &amp;&amp; node-&gt;hasTagName(liTag)))
2753         return AccessibilityRole::ListItem;
2754     if (m_renderer-&gt;isListMarker())
2755         return AccessibilityRole::ListMarker;
2756     if (node &amp;&amp; node-&gt;hasTagName(buttonTag))
2757         return buttonRoleType();
2758     if (node &amp;&amp; node-&gt;hasTagName(legendTag))
2759         return AccessibilityRole::Legend;
</pre>
<hr />
<pre>
2798         if (input.isColorControl())
2799             return AccessibilityRole::ColorWell;
2800 #endif
2801     }
2802 
2803     if (hasContentEditableAttributeSet())
2804         return AccessibilityRole::TextArea;
2805 
2806     if (isFileUploadButton())
2807         return AccessibilityRole::Button;
2808 
2809     if (cssBox &amp;&amp; cssBox-&gt;isMenuList())
2810         return AccessibilityRole::PopUpButton;
2811 
2812     if (headingLevel())
2813         return AccessibilityRole::Heading;
2814 
2815     if (m_renderer-&gt;isSVGRoot())
2816         return AccessibilityRole::SVGRoot;
2817 
<span class="line-modified">2818     if (isStyleFormatGroup()) {</span>
<span class="line-added">2819         if (node-&gt;hasTagName(delTag))</span>
<span class="line-added">2820             return AccessibilityRole::Deletion;</span>
<span class="line-added">2821         if (node-&gt;hasTagName(insTag))</span>
<span class="line-added">2822             return AccessibilityRole::Insertion;</span>
<span class="line-added">2823         if (node-&gt;hasTagName(subTag))</span>
<span class="line-added">2824             return AccessibilityRole::Subscript;</span>
<span class="line-added">2825         if (node-&gt;hasTagName(supTag))</span>
<span class="line-added">2826             return AccessibilityRole::Superscript;</span>
2827         return is&lt;RenderInline&gt;(*m_renderer) ? AccessibilityRole::Inline : AccessibilityRole::TextGroup;
<span class="line-added">2828     }</span>
2829 
2830     if (node &amp;&amp; node-&gt;hasTagName(ddTag))
2831         return AccessibilityRole::DescriptionListDetail;
2832 
2833     if (node &amp;&amp; node-&gt;hasTagName(dtTag))
2834         return AccessibilityRole::DescriptionListTerm;
2835 
2836     if (node &amp;&amp; node-&gt;hasTagName(dlTag))
2837         return AccessibilityRole::DescriptionList;
2838 
2839     if (node &amp;&amp; node-&gt;hasTagName(fieldsetTag))
2840         return AccessibilityRole::Group;
2841 
2842     if (node &amp;&amp; node-&gt;hasTagName(figureTag))
2843         return AccessibilityRole::Figure;
2844 
2845     // Check for Ruby elements
2846     if (m_renderer-&gt;isRubyText())
2847         return AccessibilityRole::RubyText;
2848     if (m_renderer-&gt;isRubyBase())
</pre>
<hr />
<pre>
2920         return AccessibilityRole::Summary;
2921 
2922     // http://rawgit.com/w3c/aria/master/html-aam/html-aam.html
2923     // Output elements should be mapped to status role.
2924     if (isOutput())
2925         return AccessibilityRole::ApplicationStatus;
2926 
2927 #if ENABLE(VIDEO)
2928     if (is&lt;HTMLVideoElement&gt;(node))
2929         return AccessibilityRole::Video;
2930     if (is&lt;HTMLAudioElement&gt;(node))
2931         return AccessibilityRole::Audio;
2932 #endif
2933 
2934     // The HTML element should not be exposed as an element. That&#39;s what the RenderView element does.
2935     if (node &amp;&amp; node-&gt;hasTagName(htmlTag))
2936         return AccessibilityRole::Ignored;
2937 
2938     // There should only be one banner/contentInfo per page. If header/footer are being used within an article or section
2939     // then it should not be exposed as whole page&#39;s banner/contentInfo
<span class="line-modified">2940     if (node &amp;&amp; node-&gt;hasTagName(headerTag) &amp;&amp; !isDescendantOfElementType({ articleTag, sectionTag }))</span>
2941         return AccessibilityRole::LandmarkBanner;
<span class="line-modified">2942 </span>
<span class="line-added">2943     // http://webkit.org/b/190138 Footers should become contentInfo&#39;s if scoped to body (and consequently become a landmark).</span>
<span class="line-added">2944     // It should remain a footer if scoped to main, sectioning elements (article, section) or root sectioning element (blockquote, details, dialog, fieldset, figure, td).</span>
<span class="line-added">2945     if (node &amp;&amp; node-&gt;hasTagName(footerTag)) {</span>
<span class="line-added">2946         if (!isDescendantOfElementType({ articleTag, sectionTag, mainTag, blockquoteTag, detailsTag, fieldsetTag, figureTag, tdTag }))</span>
<span class="line-added">2947             return AccessibilityRole::LandmarkContentInfo;</span>
2948         return AccessibilityRole::Footer;
<span class="line-added">2949     }</span>
2950 
2951     // menu tags with toolbar type should have Toolbar role.
2952     if (node &amp;&amp; node-&gt;hasTagName(menuTag) &amp;&amp; equalLettersIgnoringASCIICase(getAttribute(typeAttr), &quot;toolbar&quot;))
2953         return AccessibilityRole::Toolbar;
2954 
2955     if (node &amp;&amp; node-&gt;hasTagName(timeTag))
2956         return AccessibilityRole::Time;
2957 
2958     // If the element does not have role, but it has ARIA attributes, or accepts tab focus, accessibility should fallback to exposing it as a group.
2959     if (supportsARIAAttributes() || canSetFocusAttribute())
2960         return AccessibilityRole::Group;
2961 
2962     if (m_renderer-&gt;isRenderBlockFlow())
2963         return m_renderer-&gt;isAnonymousBlock() ? AccessibilityRole::TextGroup : AccessibilityRole::Group;
2964 
2965     // InlineRole is the final fallback before assigning AccessibilityRole::Unknown to an object. It makes it
2966     // possible to distinguish truly unknown objects from non-focusable inline text elements
2967     // which have an event handler or attribute suggesting possible inclusion by the platform.
2968     if (is&lt;RenderInline&gt;(*m_renderer)
2969         &amp;&amp; (hasAttributesRequiredForInclusion()
2970             || (node &amp;&amp; node-&gt;hasEventListeners())
2971             || (supportsDatetimeAttribute() &amp;&amp; !getAttribute(datetimeAttr).isEmpty())))
2972         return AccessibilityRole::Inline;
2973 
2974     return AccessibilityRole::Unknown;
2975 }
2976 
2977 AccessibilityOrientation AccessibilityRenderObject::orientation() const
2978 {
<span class="line-modified">2979     const AtomString&amp; ariaOrientation = getAttribute(aria_orientationAttr);</span>
2980     if (equalLettersIgnoringASCIICase(ariaOrientation, &quot;horizontal&quot;))
2981         return AccessibilityOrientation::Horizontal;
2982     if (equalLettersIgnoringASCIICase(ariaOrientation, &quot;vertical&quot;))
2983         return AccessibilityOrientation::Vertical;
2984     if (equalLettersIgnoringASCIICase(ariaOrientation, &quot;undefined&quot;))
2985         return AccessibilityOrientation::Undefined;
2986 
2987     // In ARIA 1.1, the implicit value of aria-orientation changed from horizontal
2988     // to undefined on all roles that don&#39;t have their own role-specific values. In
2989     // addition, the implicit value of combobox became undefined.
2990     if (isComboBox() || isRadioGroup() || isTreeGrid())
2991         return AccessibilityOrientation::Undefined;
2992 
2993     if (isScrollbar() || isListBox() || isMenu() || isTree())
2994         return AccessibilityOrientation::Vertical;
2995 
2996     if (isMenuBar() || isSplitter() || isTabList() || isToolbar() || isSlider())
2997         return AccessibilityOrientation::Horizontal;
2998 
2999     return AccessibilityObject::orientation();
</pre>
<hr />
<pre>
3060 {
3061     switch (m_ariaRole) {
3062     case AccessibilityRole::Button:
3063     case AccessibilityRole::Slider:
3064     case AccessibilityRole::Image:
3065     case AccessibilityRole::ProgressIndicator:
3066     case AccessibilityRole::SpinButton:
3067     // case SeparatorRole:
3068         return true;
3069     default:
3070         return false;
3071     }
3072 }
3073 
3074 bool AccessibilityRenderObject::canSetExpandedAttribute() const
3075 {
3076     if (roleValue() == AccessibilityRole::Details)
3077         return true;
3078 
3079     // An object can be expanded if it aria-expanded is true or false.
<span class="line-modified">3080     const AtomString&amp; expanded = getAttribute(aria_expandedAttr);</span>
3081     if (equalLettersIgnoringASCIICase(expanded, &quot;true&quot;) || equalLettersIgnoringASCIICase(expanded, &quot;false&quot;))
3082         return true;
3083     return false;
3084 }
3085 
3086 bool AccessibilityRenderObject::canSetTextRangeAttributes() const
3087 {
3088     return isTextControl();
3089 }
3090 
3091 void AccessibilityRenderObject::textChanged()
3092 {
3093     // If this element supports ARIA live regions, or is part of a region with an ARIA editable role,
3094     // then notify the AT of changes.
3095     AXObjectCache* cache = axObjectCache();
3096     if (!cache)
3097         return;
3098 
3099     for (RenderObject* renderParent = renderer(); renderParent; renderParent = renderParent-&gt;parent()) {
3100         AccessibilityObject* parent = cache-&gt;get(renderParent);
</pre>
<hr />
<pre>
3320             if (childObject)
3321                 insertionIndex = m_children.find(childObject) + 1;
3322             continue;
3323         }
3324 
3325         if (!isNodeAriaVisible(child))
3326             continue;
3327 
3328         unsigned previousSize = m_children.size();
3329         if (insertionIndex &gt; previousSize)
3330             insertionIndex = previousSize;
3331 
3332         insertChild(axObjectCache()-&gt;getOrCreate(child), insertionIndex);
3333         insertionIndex += (m_children.size() - previousSize);
3334     }
3335 }
3336 
3337 void AccessibilityRenderObject::updateRoleAfterChildrenCreation()
3338 {
3339     // If a menu does not have valid menuitem children, it should not be exposed as a menu.
<span class="line-modified">3340     auto role = roleValue();</span>
<span class="line-added">3341     if (role == AccessibilityRole::Menu) {</span>
3342         // Elements marked as menus must have at least one menu item child.
3343         size_t menuItemCount = 0;
3344         for (const auto&amp; child : children()) {
3345             if (child-&gt;isMenuItem()) {
3346                 menuItemCount++;
3347                 break;
3348             }
3349         }
3350 
3351         if (!menuItemCount)
3352             m_role = AccessibilityRole::Group;
3353     }
<span class="line-added">3354     if (role == AccessibilityRole::SVGRoot &amp;&amp; !hasChildren())</span>
<span class="line-added">3355         m_role = AccessibilityRole::Image;</span>
3356 }
3357 
3358 void AccessibilityRenderObject::addChildren()
3359 {
3360     // If the need to add more children in addition to existing children arises,
3361     // childrenChanged should have been called, leaving the object with no children.
3362     ASSERT(!m_haveChildren);
3363 
3364     m_haveChildren = true;
3365 
3366     if (!canHaveChildren())
3367         return;
3368 
3369     for (RefPtr&lt;AccessibilityObject&gt; obj = firstChild(); obj; obj = obj-&gt;nextSibling())
3370         addChild(obj.get());
3371 
3372     m_subtreeDirty = false;
3373 
3374     addHiddenChildren();
3375     addAttachmentChildren();
</pre>
<hr />
<pre>
3378     addCanvasChildren();
3379     addRemoteSVGChildren();
3380 
3381 #if PLATFORM(COCOA)
3382     updateAttachmentViewParents();
3383 #endif
3384 
3385     updateRoleAfterChildrenCreation();
3386 }
3387 
3388 bool AccessibilityRenderObject::canHaveChildren() const
3389 {
3390     if (!m_renderer)
3391         return false;
3392 
3393     return AccessibilityNodeObject::canHaveChildren();
3394 }
3395 
3396 const String AccessibilityRenderObject::liveRegionStatus() const
3397 {
<span class="line-modified">3398     const AtomString&amp; liveRegionStatus = getAttribute(aria_liveAttr);</span>
3399     // These roles have implicit live region status.
3400     if (liveRegionStatus.isEmpty())
3401         return defaultLiveRegionStatusForRole(roleValue());
3402 
3403     return liveRegionStatus;
3404 }
3405 
3406 const String AccessibilityRenderObject::liveRegionRelevant() const
3407 {
<span class="line-modified">3408     static NeverDestroyed&lt;const AtomString&gt; defaultLiveRegionRelevant(&quot;additions text&quot;, AtomString::ConstructFromLiteral);</span>
<span class="line-modified">3409     const AtomString&amp; relevant = getAttribute(aria_relevantAttr);</span>
3410 
3411     // Default aria-relevant = &quot;additions text&quot;.
3412     if (relevant.isEmpty())
3413         return &quot;additions text&quot;;
3414 
3415     return relevant;
3416 }
3417 
3418 bool AccessibilityRenderObject::liveRegionAtomic() const
3419 {
<span class="line-modified">3420     const AtomString&amp; atomic = getAttribute(aria_atomicAttr);</span>
3421     if (equalLettersIgnoringASCIICase(atomic, &quot;true&quot;))
3422         return true;
3423     if (equalLettersIgnoringASCIICase(atomic, &quot;false&quot;))
3424         return false;
3425 
3426     // WAI-ARIA &quot;alert&quot; and &quot;status&quot; roles have an implicit aria-atomic value of true.
3427     switch (roleValue()) {
3428     case AccessibilityRole::ApplicationAlert:
3429     case AccessibilityRole::ApplicationStatus:
3430         return true;
3431     default:
3432         return false;
3433     }
3434 }
3435 
3436 bool AccessibilityRenderObject::isBusy() const
3437 {
3438     return elementAttributeValue(aria_busyAttr);
3439 }
3440 
</pre>
<hr />
<pre>
3521         return;
3522     case AccessibilityRole::Grid:
3523     case AccessibilityRole::Tree:
3524     case AccessibilityRole::TreeGrid:
3525         ariaSelectedRows(result);
3526         return;
3527     case AccessibilityRole::TabList:
3528         if (AccessibilityObject* selectedTab = selectedTabItem())
3529             result.append(selectedTab);
3530         return;
3531     case AccessibilityRole::List:
3532         if (auto* selectedListItemChild = selectedListItem())
3533             result.append(selectedListItemChild);
3534         return;
3535     case AccessibilityRole::Menu:
3536     case AccessibilityRole::MenuBar:
3537         if (AccessibilityObject* descendant = activeDescendant()) {
3538             result.append(descendant);
3539             return;
3540         }
<span class="line-modified">3541         if (AccessibilityObject* focusedElement = static_cast&lt;AccessibilityObject*&gt;(focusedUIElement())) {</span>
3542             result.append(focusedElement);
3543             return;
3544         }
3545         return;
3546     default:
3547         ASSERT_NOT_REACHED();
3548     }
3549 }
3550 
3551 void AccessibilityRenderObject::ariaListboxVisibleChildren(AccessibilityChildrenVector&amp; result)
3552 {
3553     if (!hasChildren())
3554         addChildren();
3555 
3556     for (const auto&amp; child : children()) {
3557         if (child-&gt;isOffScreen())
3558             result.append(child);
3559     }
3560 }
3561 
</pre>
<hr />
<pre>
3598     case AccessibilityRole::ToggleButton:
3599         return buttonAction;
3600     case AccessibilityRole::TextField:
3601     case AccessibilityRole::TextArea:
3602         return textFieldAction;
3603     case AccessibilityRole::RadioButton:
3604         return radioButtonAction;
3605     case AccessibilityRole::CheckBox:
3606         return isChecked() ? checkedCheckBoxAction : uncheckedCheckBoxAction;
3607     case AccessibilityRole::Link:
3608     case AccessibilityRole::WebCoreLink:
3609         return linkAction;
3610     default:
3611         return nullAtom();
3612     }
3613 #else
3614     return nullAtom();
3615 #endif
3616 }
3617 
<span class="line-modified">3618 void AccessibilityRenderObject::setAccessibleName(const AtomString&amp; name)</span>
3619 {
3620     // Setting the accessible name can store the value in the DOM
3621     if (!m_renderer)
3622         return;
3623 
3624     Node* node = nullptr;
3625     // For web areas, set the aria-label on the HTML element.
3626     if (isWebArea())
3627         node = m_renderer-&gt;document().documentElement();
3628     else
3629         node = m_renderer-&gt;node();
3630 
3631     if (is&lt;Element&gt;(node))
3632         downcast&lt;Element&gt;(*node).setAttribute(aria_labelAttr, name);
3633 }
3634 
3635 static bool isLinkable(const AccessibilityRenderObject&amp; object)
3636 {
3637     if (!object.renderer())
3638         return false;
</pre>
<hr />
<pre>
3686     if (!m_renderer)
3687         return false;
3688 
3689     if (!canHavePlainText())
3690         return false;
3691 
3692     const RenderStyle&amp; style = m_renderer-&gt;style();
3693     return style.fontDescription().weight() == normalWeightValue()
3694         &amp;&amp; !isItalic(style.fontDescription().italic())
3695         &amp;&amp; style.textDecorationsInEffect().isEmpty();
3696 }
3697 
3698 bool AccessibilityRenderObject::hasSameFont(RenderObject* renderer) const
3699 {
3700     if (!m_renderer || !renderer)
3701         return false;
3702 
3703     return m_renderer-&gt;style().fontDescription().families() == renderer-&gt;style().fontDescription().families();
3704 }
3705 
<span class="line-added">3706 #if ENABLE(APPLE_PAY)</span>
<span class="line-added">3707 bool AccessibilityRenderObject::isApplePayButton() const</span>
<span class="line-added">3708 {</span>
<span class="line-added">3709     if (!m_renderer)</span>
<span class="line-added">3710         return false;</span>
<span class="line-added">3711     return m_renderer-&gt;style().appearance() == ApplePayButtonPart;</span>
<span class="line-added">3712 }</span>
<span class="line-added">3713 </span>
<span class="line-added">3714 ApplePayButtonType AccessibilityRenderObject::applePayButtonType() const</span>
<span class="line-added">3715 {</span>
<span class="line-added">3716     if (!m_renderer)</span>
<span class="line-added">3717         return ApplePayButtonType::Plain;</span>
<span class="line-added">3718     return m_renderer-&gt;style().applePayButtonType();</span>
<span class="line-added">3719 }</span>
<span class="line-added">3720 #endif</span>
<span class="line-added">3721 </span>
3722 bool AccessibilityRenderObject::hasSameFontColor(RenderObject* renderer) const
3723 {
3724     if (!m_renderer || !renderer)
3725         return false;
3726 
3727     return m_renderer-&gt;style().visitedDependentColor(CSSPropertyColor) == renderer-&gt;style().visitedDependentColor(CSSPropertyColor);
3728 }
3729 
3730 bool AccessibilityRenderObject::hasSameStyle(RenderObject* renderer) const
3731 {
3732     if (!m_renderer || !renderer)
3733         return false;
3734 
3735     return m_renderer-&gt;style() == renderer-&gt;style();
3736 }
3737 
3738 bool AccessibilityRenderObject::hasUnderline() const
3739 {
3740     if (!m_renderer)
3741         return false;
</pre>
</td>
</tr>
</table>
<center><a href="AccessibilityProgressIndicator.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="AccessibilityRenderObject.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>