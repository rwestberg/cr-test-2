<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderBox.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (C) 1999 Lars Knoll (knoll@kde.org)
   3  *           (C) 1999 Antti Koivisto (koivisto@kde.org)
   4  *           (C) 2005 Allan Sandfeld Jensen (kde@carewolf.com)
   5  *           (C) 2005, 2006 Samuel Weinig (sam.weinig@gmail.com)
   6  * Copyright (C) 2005-2010, 2015 Apple Inc. All rights reserved.
   7  *
   8  * This library is free software; you can redistribute it and/or
   9  * modify it under the terms of the GNU Library General Public
  10  * License as published by the Free Software Foundation; either
  11  * version 2 of the License, or (at your option) any later version.
  12  *
  13  * This library is distributed in the hope that it will be useful,
  14  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  15  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  16  * Library General Public License for more details.
  17  *
  18  * You should have received a copy of the GNU Library General Public License
  19  * along with this library; see the file COPYING.LIB.  If not, write to
  20  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  21  * Boston, MA 02110-1301, USA.
  22  *
  23  */
  24 
  25 #include &quot;config.h&quot;
  26 #include &quot;RenderBox.h&quot;
  27 
  28 #include &quot;CSSFontSelector.h&quot;
  29 #include &quot;ControlStates.h&quot;
  30 #include &quot;Document.h&quot;
  31 #include &quot;Editing.h&quot;
  32 #include &quot;EventHandler.h&quot;
  33 #include &quot;FloatQuad.h&quot;
  34 #include &quot;FloatRoundedRect.h&quot;
  35 #include &quot;Frame.h&quot;
  36 #include &quot;FrameView.h&quot;
  37 #include &quot;GraphicsContext.h&quot;
  38 #include &quot;HTMLBodyElement.h&quot;
  39 #include &quot;HTMLButtonElement.h&quot;
  40 #include &quot;HTMLFrameOwnerElement.h&quot;
  41 #include &quot;HTMLHtmlElement.h&quot;
  42 #include &quot;HTMLImageElement.h&quot;
  43 #include &quot;HTMLInputElement.h&quot;
  44 #include &quot;HTMLLegendElement.h&quot;
  45 #include &quot;HTMLNames.h&quot;
  46 #include &quot;HTMLSelectElement.h&quot;
  47 #include &quot;HTMLTextAreaElement.h&quot;
  48 #include &quot;HitTestResult.h&quot;
  49 #include &quot;InlineElementBox.h&quot;
  50 #include &quot;Page.h&quot;
  51 #include &quot;PaintInfo.h&quot;
  52 #include &quot;RenderBoxFragmentInfo.h&quot;
  53 #include &quot;RenderChildIterator.h&quot;
  54 #include &quot;RenderDeprecatedFlexibleBox.h&quot;
  55 #include &quot;RenderFlexibleBox.h&quot;
  56 #include &quot;RenderFragmentContainer.h&quot;
  57 #include &quot;RenderGeometryMap.h&quot;
  58 #include &quot;RenderGrid.h&quot;
  59 #include &quot;RenderInline.h&quot;
  60 #include &quot;RenderIterator.h&quot;
  61 #include &quot;RenderLayer.h&quot;
  62 #include &quot;RenderLayerCompositor.h&quot;
  63 #include &quot;RenderLayoutState.h&quot;
  64 #include &quot;RenderMultiColumnFlow.h&quot;
  65 #include &quot;RenderTableCell.h&quot;
  66 #include &quot;RenderTheme.h&quot;
  67 #include &quot;RenderView.h&quot;
  68 #include &quot;RuntimeApplicationChecks.h&quot;
  69 #include &quot;ScrollAnimator.h&quot;
  70 #include &quot;ScrollbarTheme.h&quot;
  71 #include &quot;Settings.h&quot;
  72 #include &quot;StyleScrollSnapPoints.h&quot;
  73 #include &quot;TransformState.h&quot;
  74 #include &lt;algorithm&gt;
  75 #include &lt;math.h&gt;
  76 #include &lt;wtf/IsoMallocInlines.h&gt;
  77 #include &lt;wtf/StackStats.h&gt;
  78 
  79 namespace WebCore {
  80 
  81 WTF_MAKE_ISO_ALLOCATED_IMPL(RenderBox);
  82 
  83 struct SameSizeAsRenderBox : public RenderBoxModelObject {
  84     virtual ~SameSizeAsRenderBox() = default;
  85     LayoutRect frameRect;
  86     LayoutBoxExtent marginBox;
  87     LayoutUnit preferredLogicalWidths[2];
  88     void* pointers[2];
  89 };
  90 
  91 COMPILE_ASSERT(sizeof(RenderBox) == sizeof(SameSizeAsRenderBox), RenderBox_should_stay_small);
  92 
  93 using namespace HTMLNames;
  94 
  95 // Used by flexible boxes when flexing this element and by table cells.
  96 typedef WTF::HashMap&lt;const RenderBox*, LayoutUnit&gt; OverrideSizeMap;
  97 static OverrideSizeMap* gOverrideContentLogicalHeightMap = nullptr;
  98 static OverrideSizeMap* gOverrideContentLogicalWidthMap = nullptr;
  99 
 100 // Used by grid elements to properly size their grid items.
 101 // FIXME: We should store these based on physical direction.
 102 typedef WTF::HashMap&lt;const RenderBox*, Optional&lt;LayoutUnit&gt;&gt; OverrideOptionalSizeMap;
 103 static OverrideOptionalSizeMap* gOverrideContainingBlockContentLogicalHeightMap = nullptr;
 104 static OverrideOptionalSizeMap* gOverrideContainingBlockContentLogicalWidthMap = nullptr;
 105 
 106 // Size of border belt for autoscroll. When mouse pointer in border belt,
 107 // autoscroll is started.
 108 static const int autoscrollBeltSize = 20;
 109 static const unsigned backgroundObscurationTestMaxDepth = 4;
 110 
 111 using ControlStatesRendererMap = HashMap&lt;const RenderObject*, std::unique_ptr&lt;ControlStates&gt;&gt;;
 112 static ControlStatesRendererMap&amp; controlStatesRendererMap()
 113 {
 114     static NeverDestroyed&lt;ControlStatesRendererMap&gt; map;
 115     return map;
 116 }
 117 
 118 static ControlStates* controlStatesForRenderer(const RenderBox&amp; renderer)
 119 {
 120     return controlStatesRendererMap().ensure(&amp;renderer, [] {
 121         return makeUnique&lt;ControlStates&gt;();
 122     }).iterator-&gt;value.get();
 123 }
 124 
 125 static void removeControlStatesForRenderer(const RenderBox&amp; renderer)
 126 {
 127     controlStatesRendererMap().remove(&amp;renderer);
 128 }
 129 
 130 bool RenderBox::s_hadOverflowClip = false;
 131 
 132 RenderBox::RenderBox(Element&amp; element, RenderStyle&amp;&amp; style, BaseTypeFlags baseTypeFlags)
 133     : RenderBoxModelObject(element, WTFMove(style), baseTypeFlags)
 134 {
 135     setIsBox();
 136 }
 137 
 138 RenderBox::RenderBox(Document&amp; document, RenderStyle&amp;&amp; style, BaseTypeFlags baseTypeFlags)
 139     : RenderBoxModelObject(document, WTFMove(style), baseTypeFlags)
 140 {
 141     setIsBox();
 142 }
 143 
 144 RenderBox::~RenderBox()
 145 {
 146     // Do not add any code here. Add it to willBeDestroyed() instead.
 147 }
 148 
 149 void RenderBox::willBeDestroyed()
 150 {
 151     if (frame().eventHandler().autoscrollRenderer() == this)
 152         frame().eventHandler().stopAutoscrollTimer(true);
 153 
 154     clearOverrideContentSize();
 155     clearOverrideContainingBlockContentSize();
 156 
 157     RenderBlock::removePercentHeightDescendantIfNeeded(*this);
 158 
 159     ShapeOutsideInfo::removeInfo(*this);
 160 
 161     view().unscheduleLazyRepaint(*this);
 162     removeControlStatesForRenderer(*this);
 163 
 164 #if ENABLE(CSS_SCROLL_SNAP)
 165     if (hasInitializedStyle() &amp;&amp; style().scrollSnapArea().hasSnapPosition())
 166         view().unregisterBoxWithScrollSnapPositions(*this);
 167 #endif
 168 
 169     RenderBoxModelObject::willBeDestroyed();
 170 }
 171 
 172 RenderFragmentContainer* RenderBox::clampToStartAndEndFragments(RenderFragmentContainer* fragment) const
 173 {
 174     RenderFragmentedFlow* fragmentedFlow = enclosingFragmentedFlow();
 175 
 176     ASSERT(isRenderView() || (fragment &amp;&amp; fragmentedFlow));
 177     if (isRenderView())
 178         return fragment;
 179 
 180     // We need to clamp to the block, since we want any lines or blocks that overflow out of the
 181     // logical top or logical bottom of the block to size as though the border box in the first and
 182     // last fragments extended infinitely. Otherwise the lines are going to size according to the fragments
 183     // they overflow into, which makes no sense when this block doesn&#39;t exist in |fragment| at all.
 184     RenderFragmentContainer* startFragment = nullptr;
 185     RenderFragmentContainer* endFragment = nullptr;
 186     if (!fragmentedFlow-&gt;getFragmentRangeForBox(this, startFragment, endFragment))
 187         return fragment;
 188 
 189     if (fragment-&gt;logicalTopForFragmentedFlowContent() &lt; startFragment-&gt;logicalTopForFragmentedFlowContent())
 190         return startFragment;
 191     if (fragment-&gt;logicalTopForFragmentedFlowContent() &gt; endFragment-&gt;logicalTopForFragmentedFlowContent())
 192         return endFragment;
 193 
 194     return fragment;
 195 }
 196 
 197 bool RenderBox::hasFragmentRangeInFragmentedFlow() const
 198 {
 199     RenderFragmentedFlow* fragmentedFlow = enclosingFragmentedFlow();
 200     if (!fragmentedFlow || !fragmentedFlow-&gt;hasValidFragmentInfo())
 201         return false;
 202 
 203     return fragmentedFlow-&gt;hasCachedFragmentRangeForBox(*this);
 204 }
 205 
 206 LayoutRect RenderBox::clientBoxRectInFragment(RenderFragmentContainer* fragment) const
 207 {
 208     if (!fragment)
 209         return clientBoxRect();
 210 
 211     LayoutRect clientBox = borderBoxRectInFragment(fragment);
 212     clientBox.setLocation(clientBox.location() + LayoutSize(borderLeft(), borderTop()));
 213     clientBox.setSize(clientBox.size() - LayoutSize(borderLeft() + borderRight() + verticalScrollbarWidth(), borderTop() + borderBottom() + horizontalScrollbarHeight()));
 214 
 215     return clientBox;
 216 }
 217 
 218 LayoutRect RenderBox::borderBoxRectInFragment(RenderFragmentContainer*, RenderBoxFragmentInfoFlags) const
 219 {
 220     return borderBoxRect();
 221 }
 222 
 223 static RenderBlockFlow* outermostBlockContainingFloatingObject(RenderBox&amp; box)
 224 {
 225     ASSERT(box.isFloating());
 226     RenderBlockFlow* parentBlock = nullptr;
 227     for (auto&amp; ancestor : ancestorsOfType&lt;RenderBlockFlow&gt;(box)) {
 228         if (ancestor.isRenderView())
 229             break;
 230         if (!parentBlock || ancestor.containsFloat(box))
 231             parentBlock = &amp;ancestor;
 232     }
 233     return parentBlock;
 234 }
 235 
 236 void RenderBox::removeFloatingOrPositionedChildFromBlockLists()
 237 {
 238     ASSERT(isFloatingOrOutOfFlowPositioned());
 239 
 240     if (renderTreeBeingDestroyed())
 241         return;
 242 
 243     if (isFloating()) {
 244         if (RenderBlockFlow* parentBlock = outermostBlockContainingFloatingObject(*this)) {
 245             parentBlock-&gt;markSiblingsWithFloatsForLayout(this);
 246             parentBlock-&gt;markAllDescendantsWithFloatsForLayout(this, false);
 247         }
 248     }
 249 
 250     if (isOutOfFlowPositioned())
 251         RenderBlock::removePositionedObject(*this);
 252 }
 253 
 254 void RenderBox::styleWillChange(StyleDifference diff, const RenderStyle&amp; newStyle)
 255 {
 256     s_hadOverflowClip = hasOverflowClip();
 257 
 258     const RenderStyle* oldStyle = hasInitializedStyle() ? &amp;style() : nullptr;
 259     if (oldStyle) {
 260         // The background of the root element or the body element could propagate up to
 261         // the canvas. Issue full repaint, when our style changes substantially.
 262         if (diff &gt;= StyleDifference::Repaint &amp;&amp; (isDocumentElementRenderer() || isBody())) {
 263             view().repaintRootContents();
 264             if (oldStyle-&gt;hasEntirelyFixedBackground() != newStyle.hasEntirelyFixedBackground())
 265                 view().compositor().rootLayerConfigurationChanged();
 266         }
 267 
 268         // When a layout hint happens and an object&#39;s position style changes, we have to do a layout
 269         // to dirty the render tree using the old position value now.
 270         if (diff == StyleDifference::Layout &amp;&amp; parent() &amp;&amp; oldStyle-&gt;position() != newStyle.position()) {
 271             markContainingBlocksForLayout();
 272             if (oldStyle-&gt;position() == PositionType::Static)
 273                 repaint();
 274             else if (newStyle.hasOutOfFlowPosition())
 275                 parent()-&gt;setChildNeedsLayout();
 276             if (isFloating() &amp;&amp; !isOutOfFlowPositioned() &amp;&amp; newStyle.hasOutOfFlowPosition())
 277                 removeFloatingOrPositionedChildFromBlockLists();
 278         }
 279     } else if (isBody())
 280         view().repaintRootContents();
 281 
 282 #if ENABLE(CSS_SCROLL_SNAP)
 283     bool boxContributesSnapPositions = newStyle.scrollSnapArea().hasSnapPosition();
 284     if (boxContributesSnapPositions || (oldStyle &amp;&amp; oldStyle-&gt;scrollSnapArea().hasSnapPosition())) {
 285         if (boxContributesSnapPositions)
 286             view().registerBoxWithScrollSnapPositions(*this);
 287         else
 288             view().unregisterBoxWithScrollSnapPositions(*this);
 289     }
 290 #endif
 291 
 292     RenderBoxModelObject::styleWillChange(diff, newStyle);
 293 }
 294 
 295 void RenderBox::styleDidChange(StyleDifference diff, const RenderStyle* oldStyle)
 296 {
 297     // Horizontal writing mode definition is updated in RenderBoxModelObject::updateFromStyle,
 298     // (as part of the RenderBoxModelObject::styleDidChange call below). So, we can safely cache the horizontal
 299     // writing mode value before style change here.
 300     bool oldHorizontalWritingMode = isHorizontalWritingMode();
 301 
 302     RenderBoxModelObject::styleDidChange(diff, oldStyle);
 303 
 304     const RenderStyle&amp; newStyle = style();
 305     if (needsLayout() &amp;&amp; oldStyle) {
 306         RenderBlock::removePercentHeightDescendantIfNeeded(*this);
 307 
 308         // Normally we can do optimized positioning layout for absolute/fixed positioned objects. There is one special case, however, which is
 309         // when the positioned object&#39;s margin-before is changed. In this case the parent has to get a layout in order to run margin collapsing
 310         // to determine the new static position.
 311         if (isOutOfFlowPositioned() &amp;&amp; newStyle.hasStaticBlockPosition(isHorizontalWritingMode()) &amp;&amp; oldStyle-&gt;marginBefore() != newStyle.marginBefore()
 312             &amp;&amp; parent() &amp;&amp; !parent()-&gt;normalChildNeedsLayout())
 313             parent()-&gt;setChildNeedsLayout();
 314     }
 315 
 316     if (RenderBlock::hasPercentHeightContainerMap() &amp;&amp; firstChild()
 317         &amp;&amp; oldHorizontalWritingMode != isHorizontalWritingMode())
 318         RenderBlock::clearPercentHeightDescendantsFrom(*this);
 319 
 320     // If our zoom factor changes and we have a defined scrollLeft/Top, we need to adjust that value into the
 321     // new zoomed coordinate space.
 322     if (hasOverflowClip() &amp;&amp; layer() &amp;&amp; oldStyle &amp;&amp; oldStyle-&gt;effectiveZoom() != newStyle.effectiveZoom()) {
 323         ScrollPosition scrollPosition = layer()-&gt;scrollPosition();
 324         float zoomScaleFactor = newStyle.effectiveZoom() / oldStyle-&gt;effectiveZoom();
 325         scrollPosition.scale(zoomScaleFactor);
 326         layer()-&gt;setPostLayoutScrollPosition(scrollPosition);
 327     }
 328 
 329     // Our opaqueness might have changed without triggering layout.
 330     if (diff &gt;= StyleDifference::Repaint &amp;&amp; diff &lt;= StyleDifference::RepaintLayer) {
 331         auto parentToInvalidate = parent();
 332         for (unsigned i = 0; i &lt; backgroundObscurationTestMaxDepth &amp;&amp; parentToInvalidate; ++i) {
 333             parentToInvalidate-&gt;invalidateBackgroundObscurationStatus();
 334             parentToInvalidate = parentToInvalidate-&gt;parent();
 335         }
 336     }
 337 
 338     bool isBodyRenderer = isBody();
 339     bool isDocElementRenderer = isDocumentElementRenderer();
 340 
 341     if (isDocElementRenderer || isBodyRenderer) {
 342         // Propagate the new writing mode and direction up to the RenderView.
 343         auto* documentElementRenderer = document().documentElement()-&gt;renderer();
 344         auto&amp; viewStyle = view().mutableStyle();
 345         bool rootStyleChanged = false;
 346         bool viewDirectionOrWritingModeChanged = false;
 347         auto* rootRenderer = isBodyRenderer ? documentElementRenderer : nullptr;
 348         if (viewStyle.direction() != newStyle.direction() &amp;&amp; (isDocElementRenderer || !documentElementRenderer-&gt;style().hasExplicitlySetDirection())) {
 349             viewStyle.setDirection(newStyle.direction());
 350             viewDirectionOrWritingModeChanged = true;
 351             if (isBodyRenderer) {
 352                 rootRenderer-&gt;mutableStyle().setDirection(newStyle.direction());
 353                 rootStyleChanged = true;
 354             }
 355             setNeedsLayoutAndPrefWidthsRecalc();
 356 
 357             view().frameView().topContentDirectionDidChange();
 358         }
 359 
 360         if (viewStyle.writingMode() != newStyle.writingMode() &amp;&amp; (isDocElementRenderer || !documentElementRenderer-&gt;style().hasExplicitlySetWritingMode())) {
 361             viewStyle.setWritingMode(newStyle.writingMode());
 362             viewDirectionOrWritingModeChanged = true;
 363             view().setHorizontalWritingMode(newStyle.isHorizontalWritingMode());
 364             view().markAllDescendantsWithFloatsForLayout();
 365             if (isBodyRenderer) {
 366                 rootStyleChanged = true;
 367                 rootRenderer-&gt;mutableStyle().setWritingMode(newStyle.writingMode());
 368                 rootRenderer-&gt;setHorizontalWritingMode(newStyle.isHorizontalWritingMode());
 369             }
 370             setNeedsLayoutAndPrefWidthsRecalc();
 371         }
 372 
 373 #if ENABLE(DARK_MODE_CSS)
 374         view().frameView().recalculateBaseBackgroundColor();
 375 #endif
 376 
 377         view().frameView().recalculateScrollbarOverlayStyle();
 378 
 379         const Pagination&amp; pagination = view().frameView().pagination();
 380         if (viewDirectionOrWritingModeChanged &amp;&amp; pagination.mode != Pagination::Unpaginated) {
 381             viewStyle.setColumnStylesFromPaginationMode(pagination.mode);
 382             if (view().multiColumnFlow())
 383                 view().updateColumnProgressionFromStyle(viewStyle);
 384         }
 385 
 386         if (viewDirectionOrWritingModeChanged &amp;&amp; view().multiColumnFlow())
 387             view().updateStylesForColumnChildren();
 388 
 389         if (rootStyleChanged &amp;&amp; is&lt;RenderBlockFlow&gt;(rootRenderer) &amp;&amp; downcast&lt;RenderBlockFlow&gt;(*rootRenderer).multiColumnFlow())
 390             downcast&lt;RenderBlockFlow&gt;(*rootRenderer).updateStylesForColumnChildren();
 391 
 392         if (isBodyRenderer &amp;&amp; pagination.mode != Pagination::Unpaginated &amp;&amp; page().paginationLineGridEnabled()) {
 393             // Propagate the body font back up to the RenderView and use it as
 394             // the basis of the grid.
 395             if (newStyle.fontDescription() != view().style().fontDescription()) {
 396                 view().mutableStyle().setFontDescription(FontCascadeDescription { newStyle.fontDescription() });
 397                 view().mutableStyle().fontCascade().update(&amp;document().fontSelector());
 398             }
 399         }
 400 
 401         if (diff != StyleDifference::Equal)
 402             view().compositor().rootOrBodyStyleChanged(*this, oldStyle);
 403     }
 404 
 405     if ((oldStyle &amp;&amp; oldStyle-&gt;shapeOutside()) || style().shapeOutside())
 406         updateShapeOutsideInfoAfterStyleChange(style(), oldStyle);
 407     updateGridPositionAfterStyleChange(style(), oldStyle);
 408 }
 409 
 410 void RenderBox::updateGridPositionAfterStyleChange(const RenderStyle&amp; style, const RenderStyle* oldStyle)
 411 {
 412     if (!oldStyle || !is&lt;RenderGrid&gt;(parent()))
 413         return;
 414 
 415     if (oldStyle-&gt;gridItemColumnStart() == style.gridItemColumnStart()
 416         &amp;&amp; oldStyle-&gt;gridItemColumnEnd() == style.gridItemColumnEnd()
 417         &amp;&amp; oldStyle-&gt;gridItemRowStart() == style.gridItemRowStart()
 418         &amp;&amp; oldStyle-&gt;gridItemRowEnd() == style.gridItemRowEnd()
 419         &amp;&amp; oldStyle-&gt;order() == style.order()
 420         &amp;&amp; oldStyle-&gt;hasOutOfFlowPosition() == style.hasOutOfFlowPosition())
 421         return;
 422 
 423     // Positioned items don&#39;t participate on the layout of the grid,
 424     // so we don&#39;t need to mark the grid as dirty if they change positions.
 425     if (oldStyle-&gt;hasOutOfFlowPosition() &amp;&amp; style.hasOutOfFlowPosition())
 426         return;
 427 
 428     // It should be possible to not dirty the grid in some cases (like moving an
 429     // explicitly placed grid item).
 430     // For now, it&#39;s more simple to just always recompute the grid.
 431     downcast&lt;RenderGrid&gt;(*parent()).dirtyGrid();
 432 }
 433 
 434 void RenderBox::updateShapeOutsideInfoAfterStyleChange(const RenderStyle&amp; style, const RenderStyle* oldStyle)
 435 {
 436     const ShapeValue* shapeOutside = style.shapeOutside();
 437     const ShapeValue* oldShapeOutside = oldStyle ? oldStyle-&gt;shapeOutside() : nullptr;
 438 
 439     Length shapeMargin = style.shapeMargin();
 440     Length oldShapeMargin = oldStyle ? oldStyle-&gt;shapeMargin() : RenderStyle::initialShapeMargin();
 441 
 442     float shapeImageThreshold = style.shapeImageThreshold();
 443     float oldShapeImageThreshold = oldStyle ? oldStyle-&gt;shapeImageThreshold() : RenderStyle::initialShapeImageThreshold();
 444 
 445     // FIXME: A future optimization would do a deep comparison for equality. (bug 100811)
 446     if (shapeOutside == oldShapeOutside &amp;&amp; shapeMargin == oldShapeMargin &amp;&amp; shapeImageThreshold == oldShapeImageThreshold)
 447         return;
 448 
 449     if (!shapeOutside)
 450         ShapeOutsideInfo::removeInfo(*this);
 451     else
 452         ShapeOutsideInfo::ensureInfo(*this).markShapeAsDirty();
 453 
 454     if (shapeOutside || shapeOutside != oldShapeOutside)
 455         markShapeOutsideDependentsForLayout();
 456 }
 457 
 458 void RenderBox::updateFromStyle()
 459 {
 460     RenderBoxModelObject::updateFromStyle();
 461 
 462     const RenderStyle&amp; styleToUse = style();
 463     bool isDocElementRenderer = isDocumentElementRenderer();
 464     bool isViewObject = isRenderView();
 465 
 466     // The root and the RenderView always paint their backgrounds/borders.
 467     if (isDocElementRenderer || isViewObject)
 468         setHasVisibleBoxDecorations(true);
 469 
 470     setFloating(!isOutOfFlowPositioned() &amp;&amp; styleToUse.isFloating());
 471 
 472     // We also handle &lt;body&gt; and &lt;html&gt;, whose overflow applies to the viewport.
 473     if (styleToUse.overflowX() != Overflow::Visible &amp;&amp; !isDocElementRenderer &amp;&amp; isRenderBlock()) {
 474         bool boxHasOverflowClip = true;
 475         if (isBody()) {
 476             // Overflow on the body can propagate to the viewport under the following conditions.
 477             // (1) The root element is &lt;html&gt;.
 478             // (2) We are the primary &lt;body&gt; (can be checked by looking at document.body).
 479             // (3) The root element has visible overflow.
 480             if (is&lt;HTMLHtmlElement&gt;(*document().documentElement())
 481                 &amp;&amp; document().body() == element()
 482                 &amp;&amp; document().documentElement()-&gt;renderer()-&gt;style().overflowX() == Overflow::Visible) {
 483                 boxHasOverflowClip = false;
 484             }
 485         }
 486         // Check for overflow clip.
 487         // It&#39;s sufficient to just check one direction, since it&#39;s illegal to have visible on only one overflow value.
 488         if (boxHasOverflowClip) {
 489             if (!s_hadOverflowClip &amp;&amp; hasRenderOverflow()) {
 490                 // Erase the overflow.
 491                 // Overflow changes have to result in immediate repaints of the entire layout overflow area because
 492                 // repaints issued by removal of descendants get clipped using the updated style when they shouldn&#39;t.
 493                 repaintRectangle(visualOverflowRect());
 494                 repaintRectangle(layoutOverflowRect());
 495             }
 496             setHasOverflowClip();
 497         }
 498     }
 499     setHasTransformRelatedProperty(styleToUse.hasTransformRelatedProperty());
 500     setHasReflection(styleToUse.boxReflect());
 501 }
 502 
 503 void RenderBox::layout()
 504 {
 505     StackStats::LayoutCheckPoint layoutCheckPoint;
 506     ASSERT(needsLayout());
 507 
 508     RenderObject* child = firstChild();
 509     if (!child) {
 510         clearNeedsLayout();
 511         return;
 512     }
 513 
 514     LayoutStateMaintainer statePusher(*this, locationOffset(), style().isFlippedBlocksWritingMode());
 515     while (child) {
 516         if (child-&gt;needsLayout())
 517             downcast&lt;RenderElement&gt;(*child).layout();
 518         ASSERT(!child-&gt;needsLayout());
 519         child = child-&gt;nextSibling();
 520     }
 521     invalidateBackgroundObscurationStatus();
 522     clearNeedsLayout();
 523 }
 524 
 525 // More IE extensions.  clientWidth and clientHeight represent the interior of an object
 526 // excluding border and scrollbar.
 527 LayoutUnit RenderBox::clientWidth() const
 528 {
 529     return paddingBoxWidth();
 530 }
 531 
 532 LayoutUnit RenderBox::clientHeight() const
 533 {
 534     return paddingBoxHeight();
 535 }
 536 
 537 int RenderBox::scrollWidth() const
 538 {
 539     if (hasOverflowClip() &amp;&amp; layer())
 540         return layer()-&gt;scrollWidth();
 541     // For objects with visible overflow, this matches IE.
 542     // FIXME: Need to work right with writing modes.
 543     if (style().isLeftToRightDirection()) {
 544         // FIXME: This should use snappedIntSize() instead with absolute coordinates.
 545         return roundToInt(std::max(clientWidth(), layoutOverflowRect().maxX() - borderLeft()));
 546     }
 547     return roundToInt(clientWidth() - std::min&lt;LayoutUnit&gt;(0, layoutOverflowRect().x() - borderLeft()));
 548 }
 549 
 550 int RenderBox::scrollHeight() const
 551 {
 552     if (hasOverflowClip() &amp;&amp; layer())
 553         return layer()-&gt;scrollHeight();
 554     // For objects with visible overflow, this matches IE.
 555     // FIXME: Need to work right with writing modes.
 556     // FIXME: This should use snappedIntSize() instead with absolute coordinates.
 557     return roundToInt(std::max(clientHeight(), layoutOverflowRect().maxY() - borderTop()));
 558 }
 559 
 560 int RenderBox::scrollLeft() const
 561 {
 562     return hasOverflowClip() &amp;&amp; layer() ? layer()-&gt;scrollPosition().x() : 0;
 563 }
 564 
 565 int RenderBox::scrollTop() const
 566 {
 567     return hasOverflowClip() &amp;&amp; layer() ? layer()-&gt;scrollPosition().y() : 0;
 568 }
 569 
 570 static void setupWheelEventTestTrigger(RenderLayer&amp; layer)
 571 {
 572     Page&amp; page = layer.renderer().page();
 573     if (!page.expectsWheelEventTriggers())
 574         return;
 575     layer.scrollAnimator().setWheelEventTestTrigger(page.testTrigger());
 576 }
 577 
 578 void RenderBox::setScrollLeft(int newLeft, ScrollType scrollType, ScrollClamping clamping)
 579 {
 580     if (!hasOverflowClip() || !layer())
 581         return;
 582     setupWheelEventTestTrigger(*layer());
 583     layer()-&gt;scrollToXPosition(newLeft, scrollType, clamping);
 584 }
 585 
 586 void RenderBox::setScrollTop(int newTop, ScrollType scrollType, ScrollClamping clamping)
 587 {
 588     if (!hasOverflowClip() || !layer())
 589         return;
 590     setupWheelEventTestTrigger(*layer());
 591     layer()-&gt;scrollToYPosition(newTop, scrollType, clamping);
 592 }
 593 
 594 void RenderBox::absoluteRects(Vector&lt;IntRect&gt;&amp; rects, const LayoutPoint&amp; accumulatedOffset) const
 595 {
 596     rects.append(snappedIntRect(accumulatedOffset, size()));
 597 }
 598 
 599 void RenderBox::absoluteQuads(Vector&lt;FloatQuad&gt;&amp; quads, bool* wasFixed) const
 600 {
 601     FloatRect localRect(0, 0, width(), height());
 602 
 603     RenderFragmentedFlow* fragmentedFlow = enclosingFragmentedFlow();
 604     if (fragmentedFlow &amp;&amp; fragmentedFlow-&gt;absoluteQuadsForBox(quads, wasFixed, this, localRect.y(), localRect.maxY()))
 605         return;
 606 
 607     quads.append(localToAbsoluteQuad(localRect, UseTransforms, wasFixed));
 608 }
 609 
 610 void RenderBox::updateLayerTransform()
 611 {
 612     // Transform-origin depends on box size, so we need to update the layer transform after layout.
 613     if (hasLayer())
 614         layer()-&gt;updateTransform();
 615 }
 616 
 617 LayoutUnit RenderBox::constrainLogicalWidthInFragmentByMinMax(LayoutUnit logicalWidth, LayoutUnit availableWidth, RenderBlock&amp; cb, RenderFragmentContainer* fragment) const
 618 {
 619     const RenderStyle&amp; styleToUse = style();
 620     if (!styleToUse.logicalMaxWidth().isUndefined())
 621         logicalWidth = std::min(logicalWidth, computeLogicalWidthInFragmentUsing(MaxSize, styleToUse.logicalMaxWidth(), availableWidth, cb, fragment));
 622     return std::max(logicalWidth, computeLogicalWidthInFragmentUsing(MinSize, styleToUse.logicalMinWidth(), availableWidth, cb, fragment));
 623 }
 624 
 625 LayoutUnit RenderBox::constrainLogicalHeightByMinMax(LayoutUnit logicalHeight, Optional&lt;LayoutUnit&gt; intrinsicContentHeight) const
 626 {
 627     const RenderStyle&amp; styleToUse = style();
 628     if (!styleToUse.logicalMaxHeight().isUndefined()) {
 629         if (Optional&lt;LayoutUnit&gt; maxH = computeLogicalHeightUsing(MaxSize, styleToUse.logicalMaxHeight(), intrinsicContentHeight))
 630             logicalHeight = std::min(logicalHeight, maxH.value());
 631     }
 632     if (Optional&lt;LayoutUnit&gt; computedLogicalHeight = computeLogicalHeightUsing(MinSize, styleToUse.logicalMinHeight(), intrinsicContentHeight))
 633         return std::max(logicalHeight, computedLogicalHeight.value());
 634     return logicalHeight;
 635 }
 636 
 637 LayoutUnit RenderBox::constrainContentBoxLogicalHeightByMinMax(LayoutUnit logicalHeight, Optional&lt;LayoutUnit&gt; intrinsicContentHeight) const
 638 {
 639     const RenderStyle&amp; styleToUse = style();
 640     if (!styleToUse.logicalMaxHeight().isUndefined()) {
 641         if (Optional&lt;LayoutUnit&gt; maxH = computeContentLogicalHeight(MaxSize, styleToUse.logicalMaxHeight(), intrinsicContentHeight))
 642             logicalHeight = std::min(logicalHeight, maxH.value());
 643     }
 644     if (Optional&lt;LayoutUnit&gt; computedContentLogicalHeight = computeContentLogicalHeight(MinSize, styleToUse.logicalMinHeight(), intrinsicContentHeight))
 645         return std::max(logicalHeight, computedContentLogicalHeight.value());
 646     return logicalHeight;
 647 }
 648 
 649 RoundedRect::Radii RenderBox::borderRadii() const
 650 {
 651     auto&amp; style = this-&gt;style();
 652     LayoutRect bounds = frameRect();
 653 
 654     unsigned borderLeft = style.borderLeftWidth();
 655     unsigned borderTop = style.borderTopWidth();
 656     bounds.moveBy(LayoutPoint(borderLeft, borderTop));
 657     bounds.contract(borderLeft + style.borderRightWidth(), borderTop + style.borderBottomWidth());
 658     return style.getRoundedBorderFor(bounds).radii();
 659 }
 660 
 661 LayoutRect RenderBox::paddingBoxRect() const
 662 {
 663     auto verticalScrollbarWidth = this-&gt;verticalScrollbarWidth();
 664     LayoutUnit offsetForScrollbar = shouldPlaceBlockDirectionScrollbarOnLeft() ? verticalScrollbarWidth : 0;
 665 
 666     return LayoutRect(borderLeft() + offsetForScrollbar, borderTop(),
 667         width() - borderLeft() - borderRight() - verticalScrollbarWidth,
 668         height() - borderTop() - borderBottom() - horizontalScrollbarHeight());
 669 }
 670 
 671 LayoutRect RenderBox::contentBoxRect() const
 672 {
 673     return { contentBoxLocation(), contentSize() };
 674 }
 675 
 676 LayoutPoint RenderBox::contentBoxLocation() const
 677 {
 678     LayoutUnit scrollbarSpace = shouldPlaceBlockDirectionScrollbarOnLeft() ? verticalScrollbarWidth() : 0;
 679     return { borderLeft() + paddingLeft() + scrollbarSpace, borderTop() + paddingTop() };
 680 }
 681 
 682 IntRect RenderBox::absoluteContentBox() const
 683 {
 684     // This is wrong with transforms and flipped writing modes.
 685     IntRect rect = snappedIntRect(contentBoxRect());
 686     FloatPoint absPos = localToAbsolute();
 687     rect.move(absPos.x(), absPos.y());
 688     return rect;
 689 }
 690 
 691 FloatQuad RenderBox::absoluteContentQuad() const
 692 {
 693     LayoutRect rect = contentBoxRect();
 694     return localToAbsoluteQuad(FloatRect(rect));
 695 }
 696 
 697 LayoutRect RenderBox::outlineBoundsForRepaint(const RenderLayerModelObject* repaintContainer, const RenderGeometryMap* geometryMap) const
 698 {
 699     LayoutRect box = borderBoundingBox();
 700     adjustRectForOutlineAndShadow(box);
 701 
 702     if (repaintContainer != this) {
 703         FloatQuad containerRelativeQuad;
 704         if (geometryMap)
 705             containerRelativeQuad = geometryMap-&gt;mapToContainer(box, repaintContainer);
 706         else
 707             containerRelativeQuad = localToContainerQuad(FloatRect(box), repaintContainer);
 708 
 709         box = LayoutRect(containerRelativeQuad.boundingBox());
 710     }
 711 
 712     // FIXME: layoutDelta needs to be applied in parts before/after transforms and
 713     // repaint containers. https://bugs.webkit.org/show_bug.cgi?id=23308
 714     box.move(view().frameView().layoutContext().layoutDelta());
 715 
 716     return LayoutRect(snapRectToDevicePixels(box, document().deviceScaleFactor()));
 717 }
 718 
 719 void RenderBox::addFocusRingRects(Vector&lt;LayoutRect&gt;&amp; rects, const LayoutPoint&amp; additionalOffset, const RenderLayerModelObject*)
 720 {
 721     if (!size().isEmpty())
 722         rects.append(LayoutRect(additionalOffset, size()));
 723 }
 724 
 725 int RenderBox::reflectionOffset() const
 726 {
 727     if (!style().boxReflect())
 728         return 0;
 729     if (style().boxReflect()-&gt;direction() == ReflectionLeft || style().boxReflect()-&gt;direction() == ReflectionRight)
 730         return valueForLength(style().boxReflect()-&gt;offset(), borderBoxRect().width());
 731     return valueForLength(style().boxReflect()-&gt;offset(), borderBoxRect().height());
 732 }
 733 
 734 LayoutRect RenderBox::reflectedRect(const LayoutRect&amp; r) const
 735 {
 736     if (!style().boxReflect())
 737         return LayoutRect();
 738 
 739     LayoutRect box = borderBoxRect();
 740     LayoutRect result = r;
 741     switch (style().boxReflect()-&gt;direction()) {
 742         case ReflectionBelow:
 743             result.setY(box.maxY() + reflectionOffset() + (box.maxY() - r.maxY()));
 744             break;
 745         case ReflectionAbove:
 746             result.setY(box.y() - reflectionOffset() - box.height() + (box.maxY() - r.maxY()));
 747             break;
 748         case ReflectionLeft:
 749             result.setX(box.x() - reflectionOffset() - box.width() + (box.maxX() - r.maxX()));
 750             break;
 751         case ReflectionRight:
 752             result.setX(box.maxX() + reflectionOffset() + (box.maxX() - r.maxX()));
 753             break;
 754     }
 755     return result;
 756 }
 757 
 758 bool RenderBox::fixedElementLaysOutRelativeToFrame(const FrameView&amp; frameView) const
 759 {
 760     return isFixedPositioned() &amp;&amp; container()-&gt;isRenderView() &amp;&amp; frameView.fixedElementsLayoutRelativeToFrame();
 761 }
 762 
 763 bool RenderBox::includeVerticalScrollbarSize() const
 764 {
 765     return hasOverflowClip() &amp;&amp; layer() &amp;&amp; !layer()-&gt;hasOverlayScrollbars()
 766         &amp;&amp; (style().overflowY() == Overflow::Scroll || style().overflowY() == Overflow::Auto);
 767 }
 768 
 769 bool RenderBox::includeHorizontalScrollbarSize() const
 770 {
 771     return hasOverflowClip() &amp;&amp; layer() &amp;&amp; !layer()-&gt;hasOverlayScrollbars()
 772         &amp;&amp; (style().overflowX() == Overflow::Scroll || style().overflowX() == Overflow::Auto);
 773 }
 774 
 775 int RenderBox::verticalScrollbarWidth() const
 776 {
 777     return includeVerticalScrollbarSize() ? layer()-&gt;verticalScrollbarWidth() : 0;
 778 }
 779 
 780 int RenderBox::horizontalScrollbarHeight() const
 781 {
 782     return includeHorizontalScrollbarSize() ? layer()-&gt;horizontalScrollbarHeight() : 0;
 783 }
 784 
 785 int RenderBox::intrinsicScrollbarLogicalWidth() const
 786 {
 787     if (!hasOverflowClip())
 788         return 0;
 789 
 790     if (isHorizontalWritingMode() &amp;&amp; (style().overflowY() == Overflow::Scroll &amp;&amp; !canUseOverlayScrollbars())) {
 791         ASSERT(layer() &amp;&amp; layer()-&gt;hasVerticalScrollbar());
 792         return verticalScrollbarWidth();
 793     }
 794 
 795     if (!isHorizontalWritingMode() &amp;&amp; (style().overflowX() == Overflow::Scroll &amp;&amp; !canUseOverlayScrollbars())) {
 796         ASSERT(layer() &amp;&amp; layer()-&gt;hasHorizontalScrollbar());
 797         return horizontalScrollbarHeight();
 798     }
 799 
 800     return 0;
 801 }
 802 
 803 bool RenderBox::scrollLayer(ScrollDirection direction, ScrollGranularity granularity, float multiplier, Element** stopElement)
 804 {
 805     RenderLayer* boxLayer = layer();
 806     if (boxLayer &amp;&amp; boxLayer-&gt;scroll(direction, granularity, multiplier)) {
 807         if (stopElement)
 808             *stopElement = element();
 809 
 810         return true;
 811     }
 812 
 813     return false;
 814 }
 815 
 816 bool RenderBox::scroll(ScrollDirection direction, ScrollGranularity granularity, float multiplier, Element** stopElement, RenderBox* startBox, const IntPoint&amp; wheelEventAbsolutePoint)
 817 {
 818     if (scrollLayer(direction, granularity, multiplier, stopElement))
 819         return true;
 820 
 821     if (stopElement &amp;&amp; *stopElement &amp;&amp; *stopElement == element())
 822         return true;
 823 
 824     RenderBlock* nextScrollBlock = containingBlock();
 825 
 826     if (nextScrollBlock &amp;&amp; !nextScrollBlock-&gt;isRenderView())
 827         return nextScrollBlock-&gt;scroll(direction, granularity, multiplier, stopElement, startBox, wheelEventAbsolutePoint);
 828 
 829     return false;
 830 }
 831 
 832 bool RenderBox::logicalScroll(ScrollLogicalDirection direction, ScrollGranularity granularity, float multiplier, Element** stopElement)
 833 {
 834     bool scrolled = false;
 835 
 836     RenderLayer* l = layer();
 837     if (l) {
 838 #if PLATFORM(COCOA)
 839         // On Mac only we reset the inline direction position when doing a document scroll (e.g., hitting Home/End).
 840         if (granularity == ScrollByDocument)
 841             scrolled = l-&gt;scroll(logicalToPhysical(ScrollInlineDirectionBackward, isHorizontalWritingMode(), style().isFlippedBlocksWritingMode()), ScrollByDocument, multiplier);
 842 #endif
 843         if (l-&gt;scroll(logicalToPhysical(direction, isHorizontalWritingMode(), style().isFlippedBlocksWritingMode()), granularity, multiplier))
 844             scrolled = true;
 845 
 846         if (scrolled) {
 847             if (stopElement)
 848                 *stopElement = element();
 849             return true;
 850         }
 851     }
 852 
 853     if (stopElement &amp;&amp; *stopElement &amp;&amp; *stopElement == element())
 854         return true;
 855 
 856     RenderBlock* b = containingBlock();
 857     if (b &amp;&amp; !b-&gt;isRenderView())
 858         return b-&gt;logicalScroll(direction, granularity, multiplier, stopElement);
 859     return false;
 860 }
 861 
 862 bool RenderBox::canBeScrolledAndHasScrollableArea() const
 863 {
 864     return canBeProgramaticallyScrolled() &amp;&amp; (hasHorizontalOverflow() || hasVerticalOverflow());
 865 }
 866 
 867 bool RenderBox::isScrollableOrRubberbandableBox() const
 868 {
 869     return canBeScrolledAndHasScrollableArea();
 870 }
 871 
 872 // FIXME: This is badly named. overflow:hidden can be programmatically scrolled, yet this returns false in that case.
 873 bool RenderBox::canBeProgramaticallyScrolled() const
 874 {
 875     if (isRenderView())
 876         return true;
 877 
 878     if (!hasOverflowClip())
 879         return false;
 880 
 881     if (hasScrollableOverflowX() || hasScrollableOverflowY())
 882         return true;
 883 
 884     return element() &amp;&amp; element()-&gt;hasEditableStyle();
 885 }
 886 
 887 bool RenderBox::usesCompositedScrolling() const
 888 {
 889     return hasOverflowClip() &amp;&amp; hasLayer() &amp;&amp; layer()-&gt;usesCompositedScrolling();
 890 }
 891 
 892 void RenderBox::autoscroll(const IntPoint&amp; position)
 893 {
 894     if (layer())
 895         layer()-&gt;autoscroll(position);
 896 }
 897 
 898 // There are two kinds of renderer that can autoscroll.
 899 bool RenderBox::canAutoscroll() const
 900 {
 901     if (isRenderView())
 902         return view().frameView().isScrollable();
 903 
 904     // Check for a box that can be scrolled in its own right.
 905     if (canBeScrolledAndHasScrollableArea())
 906         return true;
 907 
 908     return false;
 909 }
 910 
 911 // If specified point is in border belt, returned offset denotes direction of
 912 // scrolling.
 913 IntSize RenderBox::calculateAutoscrollDirection(const IntPoint&amp; windowPoint) const
 914 {
 915     IntRect box(absoluteBoundingBoxRect());
 916     box.moveBy(view().frameView().scrollPosition());
 917     IntRect windowBox = view().frameView().contentsToWindow(box);
 918 
 919     IntPoint windowAutoscrollPoint = windowPoint;
 920 
 921     if (windowAutoscrollPoint.x() &lt; windowBox.x() + autoscrollBeltSize)
 922         windowAutoscrollPoint.move(-autoscrollBeltSize, 0);
 923     else if (windowAutoscrollPoint.x() &gt; windowBox.maxX() - autoscrollBeltSize)
 924         windowAutoscrollPoint.move(autoscrollBeltSize, 0);
 925 
 926     if (windowAutoscrollPoint.y() &lt; windowBox.y() + autoscrollBeltSize)
 927         windowAutoscrollPoint.move(0, -autoscrollBeltSize);
 928     else if (windowAutoscrollPoint.y() &gt; windowBox.maxY() - autoscrollBeltSize)
 929         windowAutoscrollPoint.move(0, autoscrollBeltSize);
 930 
 931     return windowAutoscrollPoint - windowPoint;
 932 }
 933 
 934 RenderBox* RenderBox::findAutoscrollable(RenderObject* renderer)
 935 {
 936     while (renderer &amp;&amp; !(is&lt;RenderBox&gt;(*renderer) &amp;&amp; downcast&lt;RenderBox&gt;(*renderer).canAutoscroll())) {
 937         if (is&lt;RenderView&gt;(*renderer) &amp;&amp; renderer-&gt;document().ownerElement())
 938             renderer = renderer-&gt;document().ownerElement()-&gt;renderer();
 939         else
 940             renderer = renderer-&gt;parent();
 941     }
 942 
 943     return is&lt;RenderBox&gt;(renderer) ? downcast&lt;RenderBox&gt;(renderer) : nullptr;
 944 }
 945 
 946 void RenderBox::panScroll(const IntPoint&amp; source)
 947 {
 948     if (layer())
 949         layer()-&gt;panScrollFromPoint(source);
 950 }
 951 
 952 bool RenderBox::canUseOverlayScrollbars() const
 953 {
 954     return !style().hasPseudoStyle(PseudoId::Scrollbar) &amp;&amp; ScrollbarTheme::theme().usesOverlayScrollbars();
 955 }
 956 
 957 bool RenderBox::hasVerticalScrollbarWithAutoBehavior() const
 958 {
 959     return hasOverflowClip() &amp;&amp; (style().overflowY() == Overflow::Auto || (style().overflowY() == Overflow::Scroll &amp;&amp; canUseOverlayScrollbars()));
 960 }
 961 
 962 bool RenderBox::hasHorizontalScrollbarWithAutoBehavior() const
 963 {
 964     return hasOverflowClip() &amp;&amp; (style().overflowX() == Overflow::Auto || (style().overflowX() == Overflow::Scroll &amp;&amp; canUseOverlayScrollbars()));
 965 }
 966 
 967 bool RenderBox::needsPreferredWidthsRecalculation() const
 968 {
 969     return style().paddingStart().isPercentOrCalculated() || style().paddingEnd().isPercentOrCalculated();
 970 }
 971 
 972 ScrollPosition RenderBox::scrollPosition() const
 973 {
 974     if (!hasOverflowClip())
 975         return { 0, 0 };
 976 
 977     ASSERT(hasLayer());
 978     return layer()-&gt;scrollPosition();
 979 }
 980 
 981 LayoutSize RenderBox::cachedSizeForOverflowClip() const
 982 {
 983     ASSERT(hasOverflowClip());
 984     ASSERT(hasLayer());
 985     return layer()-&gt;size();
 986 }
 987 
 988 bool RenderBox::applyCachedClipAndScrollPosition(LayoutRect&amp; rect, const RenderLayerModelObject* container, VisibleRectContext context) const
 989 {
 990     flipForWritingMode(rect);
 991 
 992     if (context.m_options.contains(VisibleRectContextOption::ApplyCompositedContainerScrolls) || this != container || !usesCompositedScrolling())
 993         rect.moveBy(-scrollPosition()); // For overflow:auto/scroll/hidden.
 994 
 995     // Do not clip scroll layer contents to reduce the number of repaints while scrolling.
 996     if ((!context.m_options.contains(VisibleRectContextOption::ApplyCompositedClips) &amp;&amp; usesCompositedScrolling())
 997         || (!context.m_options.contains(VisibleRectContextOption::ApplyContainerClip) &amp;&amp; this == container)) {
 998         flipForWritingMode(rect);
 999         return true;
1000     }
1001 
1002     // height() is inaccurate if we&#39;re in the middle of a layout of this RenderBox, so use the
1003     // layer&#39;s size instead. Even if the layer&#39;s size is wrong, the layer itself will repaint
1004     // anyway if its size does change.
1005     LayoutRect clipRect(LayoutPoint(), cachedSizeForOverflowClip());
1006     bool intersects;
1007     if (context.m_options.contains(VisibleRectContextOption::UseEdgeInclusiveIntersection))
1008         intersects = rect.edgeInclusiveIntersect(clipRect);
1009     else {
1010         rect.intersect(clipRect);
1011         intersects = !rect.isEmpty();
1012     }
1013     flipForWritingMode(rect);
1014     return intersects;
1015 }
1016 
1017 void RenderBox::computeIntrinsicLogicalWidths(LayoutUnit&amp; minLogicalWidth, LayoutUnit&amp; maxLogicalWidth) const
1018 {
1019     minLogicalWidth = minPreferredLogicalWidth() - borderAndPaddingLogicalWidth();
1020     maxLogicalWidth = maxPreferredLogicalWidth() - borderAndPaddingLogicalWidth();
1021 }
1022 
1023 LayoutUnit RenderBox::minPreferredLogicalWidth() const
1024 {
1025     if (preferredLogicalWidthsDirty()) {
1026 #ifndef NDEBUG
1027         SetLayoutNeededForbiddenScope layoutForbiddenScope(const_cast&lt;RenderBox*&gt;(this));
1028 #endif
1029         const_cast&lt;RenderBox*&gt;(this)-&gt;computePreferredLogicalWidths();
1030     }
1031 
1032     return m_minPreferredLogicalWidth;
1033 }
1034 
1035 LayoutUnit RenderBox::maxPreferredLogicalWidth() const
1036 {
1037     if (preferredLogicalWidthsDirty()) {
1038 #ifndef NDEBUG
1039         SetLayoutNeededForbiddenScope layoutForbiddenScope(const_cast&lt;RenderBox*&gt;(this));
1040 #endif
1041         const_cast&lt;RenderBox*&gt;(this)-&gt;computePreferredLogicalWidths();
1042     }
1043 
1044     return m_maxPreferredLogicalWidth;
1045 }
1046 
1047 bool RenderBox::hasOverrideContentLogicalHeight() const
1048 {
1049     return gOverrideContentLogicalHeightMap &amp;&amp; gOverrideContentLogicalHeightMap-&gt;contains(this);
1050 }
1051 
1052 bool RenderBox::hasOverrideContentLogicalWidth() const
1053 {
1054     return gOverrideContentLogicalWidthMap &amp;&amp; gOverrideContentLogicalWidthMap-&gt;contains(this);
1055 }
1056 
1057 void RenderBox::setOverrideContentLogicalHeight(LayoutUnit height)
1058 {
1059     if (!gOverrideContentLogicalHeightMap)
1060         gOverrideContentLogicalHeightMap = new OverrideSizeMap();
1061     gOverrideContentLogicalHeightMap-&gt;set(this, height);
1062 }
1063 
1064 void RenderBox::setOverrideContentLogicalWidth(LayoutUnit width)
1065 {
1066     if (!gOverrideContentLogicalWidthMap)
1067         gOverrideContentLogicalWidthMap = new OverrideSizeMap();
1068     gOverrideContentLogicalWidthMap-&gt;set(this, width);
1069 }
1070 
1071 void RenderBox::clearOverrideContentLogicalHeight()
1072 {
1073     if (gOverrideContentLogicalHeightMap)
1074         gOverrideContentLogicalHeightMap-&gt;remove(this);
1075 }
1076 
1077 void RenderBox::clearOverrideContentLogicalWidth()
1078 {
1079     if (gOverrideContentLogicalWidthMap)
1080         gOverrideContentLogicalWidthMap-&gt;remove(this);
1081 }
1082 
1083 void RenderBox::clearOverrideContentSize()
1084 {
1085     clearOverrideContentLogicalHeight();
1086     clearOverrideContentLogicalWidth();
1087 }
1088 
1089 LayoutUnit RenderBox::overrideContentLogicalWidth() const
1090 {
1091     ASSERT(hasOverrideContentLogicalWidth());
1092     return gOverrideContentLogicalWidthMap-&gt;get(this);
1093 }
1094 
1095 LayoutUnit RenderBox::overrideContentLogicalHeight() const
1096 {
1097     ASSERT(hasOverrideContentLogicalHeight());
1098     return gOverrideContentLogicalHeightMap-&gt;get(this);
1099 }
1100 
1101 Optional&lt;LayoutUnit&gt; RenderBox::overrideContainingBlockContentWidth() const
1102 {
1103     ASSERT(hasOverrideContainingBlockContentWidth());
1104     return containingBlock()-&gt;style().isHorizontalWritingMode()
1105         ? gOverrideContainingBlockContentLogicalWidthMap-&gt;get(this)
1106         : gOverrideContainingBlockContentLogicalHeightMap-&gt;get(this);
1107 }
1108 
1109 Optional&lt;LayoutUnit&gt; RenderBox::overrideContainingBlockContentHeight() const
1110 {
1111     ASSERT(hasOverrideContainingBlockContentHeight());
1112     return containingBlock()-&gt;style().isHorizontalWritingMode()
1113         ? gOverrideContainingBlockContentLogicalHeightMap-&gt;get(this)
1114         : gOverrideContainingBlockContentLogicalWidthMap-&gt;get(this);
1115 }
1116 
1117 bool RenderBox::hasOverrideContainingBlockContentWidth() const
1118 {
1119     RenderBlock* cb = containingBlock();
1120     if (!cb)
1121         return false;
1122 
1123     return cb-&gt;style().isHorizontalWritingMode()
1124         ? gOverrideContainingBlockContentLogicalWidthMap &amp;&amp; gOverrideContainingBlockContentLogicalWidthMap-&gt;contains(this)
1125         : gOverrideContainingBlockContentLogicalHeightMap &amp;&amp; gOverrideContainingBlockContentLogicalHeightMap-&gt;contains(this);
1126 }
1127 
1128 bool RenderBox::hasOverrideContainingBlockContentHeight() const
1129 {
1130     RenderBlock* cb = containingBlock();
1131     if (!cb)
1132         return false;
1133 
1134     return cb-&gt;style().isHorizontalWritingMode()
1135         ? gOverrideContainingBlockContentLogicalHeightMap &amp;&amp; gOverrideContainingBlockContentLogicalHeightMap-&gt;contains(this)
1136         : gOverrideContainingBlockContentLogicalHeightMap &amp;&amp; gOverrideContainingBlockContentLogicalHeightMap-&gt;contains(this);
1137 }
1138 
1139 Optional&lt;LayoutUnit&gt; RenderBox::overrideContainingBlockContentLogicalWidth() const
1140 {
1141     ASSERT(hasOverrideContainingBlockContentLogicalWidth());
1142     return gOverrideContainingBlockContentLogicalWidthMap-&gt;get(this);
1143 }
1144 
1145 Optional&lt;LayoutUnit&gt; RenderBox::overrideContainingBlockContentLogicalHeight() const
1146 {
1147     ASSERT(hasOverrideContainingBlockContentLogicalHeight());
1148     return gOverrideContainingBlockContentLogicalHeightMap-&gt;get(this);
1149 }
1150 
1151 bool RenderBox::hasOverrideContainingBlockContentLogicalWidth() const
1152 {
1153     return gOverrideContainingBlockContentLogicalWidthMap &amp;&amp; gOverrideContainingBlockContentLogicalWidthMap-&gt;contains(this);
1154 }
1155 
1156 bool RenderBox::hasOverrideContainingBlockContentLogicalHeight() const
1157 {
1158     return gOverrideContainingBlockContentLogicalHeightMap &amp;&amp; gOverrideContainingBlockContentLogicalHeightMap-&gt;contains(this);
1159 }
1160 
1161 void RenderBox::setOverrideContainingBlockContentLogicalWidth(Optional&lt;LayoutUnit&gt; logicalWidth)
1162 {
1163     if (!gOverrideContainingBlockContentLogicalWidthMap)
1164         gOverrideContainingBlockContentLogicalWidthMap = new OverrideOptionalSizeMap;
1165     gOverrideContainingBlockContentLogicalWidthMap-&gt;set(this, logicalWidth);
1166 }
1167 
1168 void RenderBox::setOverrideContainingBlockContentLogicalHeight(Optional&lt;LayoutUnit&gt; logicalHeight)
1169 {
1170     if (!gOverrideContainingBlockContentLogicalHeightMap)
1171         gOverrideContainingBlockContentLogicalHeightMap = new OverrideOptionalSizeMap;
1172     gOverrideContainingBlockContentLogicalHeightMap-&gt;set(this, logicalHeight);
1173 }
1174 
1175 void RenderBox::clearOverrideContainingBlockContentSize()
1176 {
1177     if (gOverrideContainingBlockContentLogicalWidthMap)
1178         gOverrideContainingBlockContentLogicalWidthMap-&gt;remove(this);
1179     clearOverrideContainingBlockContentLogicalHeight();
1180 }
1181 
1182 void RenderBox::clearOverrideContainingBlockContentLogicalHeight()
1183 {
1184     if (gOverrideContainingBlockContentLogicalHeightMap)
1185         gOverrideContainingBlockContentLogicalHeightMap-&gt;remove(this);
1186 }
1187 
1188 LayoutUnit RenderBox::adjustBorderBoxLogicalWidthForBoxSizing(LayoutUnit width) const
1189 {
1190     LayoutUnit bordersPlusPadding = borderAndPaddingLogicalWidth();
1191     if (style().boxSizing() == BoxSizing::ContentBox)
1192         return width + bordersPlusPadding;
1193     return std::max(width, bordersPlusPadding);
1194 }
1195 
1196 LayoutUnit RenderBox::adjustBorderBoxLogicalHeightForBoxSizing(LayoutUnit height) const
1197 {
1198     LayoutUnit bordersPlusPadding = borderAndPaddingLogicalHeight();
1199     if (style().boxSizing() == BoxSizing::ContentBox)
1200         return height + bordersPlusPadding;
1201     return std::max(height, bordersPlusPadding);
1202 }
1203 
1204 LayoutUnit RenderBox::adjustContentBoxLogicalWidthForBoxSizing(LayoutUnit width) const
1205 {
1206     if (style().boxSizing() == BoxSizing::BorderBox)
1207         width -= borderAndPaddingLogicalWidth();
1208     return std::max&lt;LayoutUnit&gt;(0, width);
1209 }
1210 
1211 LayoutUnit RenderBox::adjustContentBoxLogicalHeightForBoxSizing(Optional&lt;LayoutUnit&gt; height) const
1212 {
1213     if (!height)
1214         return 0;
1215     LayoutUnit result = height.value();
1216     if (style().boxSizing() == BoxSizing::BorderBox)
1217         result -= borderAndPaddingLogicalHeight();
1218     return std::max(0_lu, result);
1219 }
1220 
1221 // Hit Testing
1222 bool RenderBox::nodeAtPoint(const HitTestRequest&amp; request, HitTestResult&amp; result, const HitTestLocation&amp; locationInContainer, const LayoutPoint&amp; accumulatedOffset, HitTestAction action)
1223 {
1224     LayoutPoint adjustedLocation = accumulatedOffset + location();
1225 
1226     // Check kids first.
1227     for (RenderObject* child = lastChild(); child; child = child-&gt;previousSibling()) {
1228         if (!child-&gt;hasLayer() &amp;&amp; child-&gt;nodeAtPoint(request, result, locationInContainer, adjustedLocation, action)) {
1229             updateHitTestResult(result, locationInContainer.point() - toLayoutSize(adjustedLocation));
1230             return true;
1231         }
1232     }
1233 
1234     // Check our bounds next. For this purpose always assume that we can only be hit in the
1235     // foreground phase (which is true for replaced elements like images).
1236     LayoutRect boundsRect = borderBoxRectInFragment(nullptr);
1237     boundsRect.moveBy(adjustedLocation);
1238     if (visibleToHitTesting() &amp;&amp; action == HitTestForeground &amp;&amp; locationInContainer.intersects(boundsRect)) {
1239         updateHitTestResult(result, locationInContainer.point() - toLayoutSize(adjustedLocation));
1240         if (result.addNodeToListBasedTestResult(element(), request, locationInContainer, boundsRect) == HitTestProgress::Stop)
1241             return true;
1242     }
1243 
1244     return false;
1245 }
1246 
1247 // --------------------- painting stuff -------------------------------
1248 
1249 void RenderBox::paintRootBoxFillLayers(const PaintInfo&amp; paintInfo)
1250 {
1251     ASSERT(isDocumentElementRenderer());
1252     if (paintInfo.skipRootBackground())
1253         return;
1254 
1255     auto* rootBackgroundRenderer = view().rendererForRootBackground();
1256     if (!rootBackgroundRenderer)
1257         return;
1258 
1259     auto&amp; style = rootBackgroundRenderer-&gt;style();
1260     auto color = style.visitedDependentColor(CSSPropertyBackgroundColor);
1261     auto compositeOp = document().compositeOperatorForBackgroundColor(color, *this);
1262 
1263     paintFillLayers(paintInfo, style.colorByApplyingColorFilter(color), style.backgroundLayers(), view().backgroundRect(), BackgroundBleedNone, compositeOp, rootBackgroundRenderer);
1264 }
1265 
1266 BackgroundBleedAvoidance RenderBox::determineBackgroundBleedAvoidance(GraphicsContext&amp; context) const
1267 {
1268     if (context.paintingDisabled())
1269         return BackgroundBleedNone;
1270 
1271     const RenderStyle&amp; style = this-&gt;style();
1272 
1273     if (!style.hasBackground() || !style.hasBorder() || !style.hasBorderRadius() || borderImageIsLoadedAndCanBeRendered())
1274         return BackgroundBleedNone;
1275 
1276     AffineTransform ctm = context.getCTM();
1277     FloatSize contextScaling(static_cast&lt;float&gt;(ctm.xScale()), static_cast&lt;float&gt;(ctm.yScale()));
1278 
1279     // Because RoundedRect uses IntRect internally the inset applied by the
1280     // BackgroundBleedShrinkBackground strategy cannot be less than one integer
1281     // layout coordinate, even with subpixel layout enabled. To take that into
1282     // account, we clamp the contextScaling to 1.0 for the following test so
1283     // that borderObscuresBackgroundEdge can only return true if the border
1284     // widths are greater than 2 in both layout coordinates and screen
1285     // coordinates.
1286     // This precaution will become obsolete if RoundedRect is ever promoted to
1287     // a sub-pixel representation.
1288     if (contextScaling.width() &gt; 1)
1289         contextScaling.setWidth(1);
1290     if (contextScaling.height() &gt; 1)
1291         contextScaling.setHeight(1);
1292 
1293     if (borderObscuresBackgroundEdge(contextScaling))
1294         return BackgroundBleedShrinkBackground;
1295     if (!style.hasAppearance() &amp;&amp; borderObscuresBackground() &amp;&amp; backgroundHasOpaqueTopLayer())
1296         return BackgroundBleedBackgroundOverBorder;
1297 
1298     return BackgroundBleedUseTransparencyLayer;
1299 }
1300 
1301 void RenderBox::paintBoxDecorations(PaintInfo&amp; paintInfo, const LayoutPoint&amp; paintOffset)
1302 {
1303     if (!paintInfo.shouldPaintWithinRoot(*this))
1304         return;
1305 
1306     LayoutRect paintRect = borderBoxRectInFragment(nullptr);
1307     paintRect.moveBy(paintOffset);
1308     adjustBorderBoxRectForPainting(paintRect);
1309 
1310 #if PLATFORM(IOS_FAMILY)
1311     // Workaround for &lt;rdar://problem/6209763&gt;. Force the painting bounds of checkboxes and radio controls to be square.
1312     // FIXME: Consolidate this code with the same code in RenderElement::paintOutline(). See &lt;https://bugs.webkit.org/show_bug.cgi?id=194781&gt;.
1313     if (style().appearance() == CheckboxPart || style().appearance() == RadioPart) {
1314         int width = std::min(paintRect.width(), paintRect.height());
1315         int height = width;
1316         paintRect = IntRect { paintRect.x(), paintRect.y() + (this-&gt;height() - height) / 2, width, height }; // Vertically center the checkbox, like on desktop
1317     }
1318 #endif
1319     BackgroundBleedAvoidance bleedAvoidance = determineBackgroundBleedAvoidance(paintInfo.context());
1320 
1321     // FIXME: Should eventually give the theme control over whether the box shadow should paint, since controls could have
1322     // custom shadows of their own.
1323     if (!boxShadowShouldBeAppliedToBackground(paintRect.location(), bleedAvoidance))
1324         paintBoxShadow(paintInfo, paintRect, style(), Normal);
1325 
1326     GraphicsContextStateSaver stateSaver(paintInfo.context(), false);
1327     if (bleedAvoidance == BackgroundBleedUseTransparencyLayer) {
1328         // To avoid the background color bleeding out behind the border, we&#39;ll render background and border
1329         // into a transparency layer, and then clip that in one go (which requires setting up the clip before
1330         // beginning the layer).
1331         stateSaver.save();
1332         paintInfo.context().clipRoundedRect(style().getRoundedBorderFor(paintRect).pixelSnappedRoundedRectForPainting(document().deviceScaleFactor()));
1333         paintInfo.context().beginTransparencyLayer(1);
1334     }
1335 
1336     // If we have a native theme appearance, paint that before painting our background.
1337     // The theme will tell us whether or not we should also paint the CSS background.
1338     bool borderOrBackgroundPaintingIsNeeded = true;
1339     if (style().hasAppearance()) {
1340         ControlStates* controlStates = controlStatesForRenderer(*this);
1341         borderOrBackgroundPaintingIsNeeded = theme().paint(*this, *controlStates, paintInfo, paintRect);
1342         if (controlStates-&gt;needsRepaint())
1343             view().scheduleLazyRepaint(*this);
1344     }
1345 
1346     if (borderOrBackgroundPaintingIsNeeded) {
1347         if (bleedAvoidance == BackgroundBleedBackgroundOverBorder)
1348             paintBorder(paintInfo, paintRect, style(), bleedAvoidance);
1349 
1350         paintBackground(paintInfo, paintRect, bleedAvoidance);
1351 
1352         if (style().hasAppearance())
1353             theme().paintDecorations(*this, paintInfo, paintRect);
1354     }
1355     paintBoxShadow(paintInfo, paintRect, style(), Inset);
1356 
1357     // The theme will tell us whether or not we should also paint the CSS border.
1358     if (bleedAvoidance != BackgroundBleedBackgroundOverBorder &amp;&amp; (!style().hasAppearance() || (borderOrBackgroundPaintingIsNeeded &amp;&amp; theme().paintBorderOnly(*this, paintInfo, paintRect))) &amp;&amp; style().hasVisibleBorderDecoration())
1359         paintBorder(paintInfo, paintRect, style(), bleedAvoidance);
1360 
1361     if (bleedAvoidance == BackgroundBleedUseTransparencyLayer)
1362         paintInfo.context().endTransparencyLayer();
1363 }
1364 
1365 bool RenderBox::paintsOwnBackground() const
1366 {
1367     if (isBody()) {
1368         // The &lt;body&gt; only paints its background if the root element has defined a background independent of the body,
1369         // or if the &lt;body&gt;&#39;s parent is not the document element&#39;s renderer (e.g. inside SVG foreignObject).
1370         auto documentElementRenderer = document().documentElement()-&gt;renderer();
1371         return !documentElementRenderer
1372             || documentElementRenderer-&gt;hasBackground()
1373             || (documentElementRenderer != parent());
1374     }
1375 
1376     return true;
1377 }
1378 
1379 void RenderBox::paintBackground(const PaintInfo&amp; paintInfo, const LayoutRect&amp; paintRect, BackgroundBleedAvoidance bleedAvoidance)
1380 {
1381     if (isDocumentElementRenderer()) {
1382         paintRootBoxFillLayers(paintInfo);
1383         return;
1384     }
1385 
1386     if (!paintsOwnBackground())
1387         return;
1388 
1389     if (backgroundIsKnownToBeObscured(paintRect.location()) &amp;&amp; !boxShadowShouldBeAppliedToBackground(paintRect.location(), bleedAvoidance))
1390         return;
1391 
1392     auto backgroundColor = style().visitedDependentColor(CSSPropertyBackgroundColor);
1393     auto compositeOp = document().compositeOperatorForBackgroundColor(backgroundColor, *this);
1394 
1395     paintFillLayers(paintInfo, style().colorByApplyingColorFilter(backgroundColor), style().backgroundLayers(), paintRect, bleedAvoidance, compositeOp);
1396 }
1397 
1398 bool RenderBox::getBackgroundPaintedExtent(const LayoutPoint&amp; paintOffset, LayoutRect&amp; paintedExtent) const
1399 {
1400     ASSERT(hasBackground());
1401     LayoutRect backgroundRect = snappedIntRect(borderBoxRect());
1402 
1403     Color backgroundColor = style().visitedDependentColorWithColorFilter(CSSPropertyBackgroundColor);
1404     if (backgroundColor.isVisible()) {
1405         paintedExtent = backgroundRect;
1406         return true;
1407     }
1408 
1409     auto&amp; layers = style().backgroundLayers();
1410     if (!layers.image() || layers.next()) {
1411         paintedExtent =  backgroundRect;
1412         return true;
1413     }
1414 
1415     auto geometry = calculateBackgroundImageGeometry(nullptr, layers, paintOffset, backgroundRect);
1416     paintedExtent = geometry.destRect();
1417     return !geometry.hasNonLocalGeometry();
1418 }
1419 
1420 bool RenderBox::backgroundIsKnownToBeOpaqueInRect(const LayoutRect&amp; localRect) const
1421 {
1422     if (!paintsOwnBackground())
1423         return false;
1424 
1425     Color backgroundColor = style().visitedDependentColorWithColorFilter(CSSPropertyBackgroundColor);
1426     if (!backgroundColor.isOpaque())
1427         return false;
1428 
1429     // If the element has appearance, it might be painted by theme.
1430     // We cannot be sure if theme paints the background opaque.
1431     // In this case it is safe to not assume opaqueness.
1432     // FIXME: May be ask theme if it paints opaque.
1433     if (style().hasAppearance())
1434         return false;
1435     // FIXME: Check the opaqueness of background images.
1436 
1437     if (hasClip() || hasClipPath())
1438         return false;
1439 
1440     // FIXME: Use rounded rect if border radius is present.
1441     if (style().hasBorderRadius())
1442         return false;
1443 
1444     // FIXME: The background color clip is defined by the last layer.
1445     if (style().backgroundLayers().next())
1446         return false;
1447     LayoutRect backgroundRect;
1448     switch (style().backgroundClip()) {
1449     case FillBox::Border:
1450         backgroundRect = borderBoxRect();
1451         break;
1452     case FillBox::Padding:
1453         backgroundRect = paddingBoxRect();
1454         break;
1455     case FillBox::Content:
1456         backgroundRect = contentBoxRect();
1457         break;
1458     default:
1459         break;
1460     }
1461     return backgroundRect.contains(localRect);
1462 }
1463 
1464 static bool isCandidateForOpaquenessTest(const RenderBox&amp; childBox)
1465 {
1466     const RenderStyle&amp; childStyle = childBox.style();
1467     if (childStyle.position() != PositionType::Static &amp;&amp; childBox.containingBlock() != childBox.parent())
1468         return false;
1469     if (childStyle.visibility() != Visibility::Visible)
1470         return false;
1471     if (childStyle.shapeOutside())
1472         return false;
1473     if (!childBox.width() || !childBox.height())
1474         return false;
1475     if (RenderLayer* childLayer = childBox.layer()) {
1476         if (childLayer-&gt;isComposited())
1477             return false;
1478         // FIXME: Deal with z-index.
1479         if (!childStyle.hasAutoZIndex())
1480             return false;
1481         if (childLayer-&gt;hasTransform() || childLayer-&gt;isTransparent() || childLayer-&gt;hasFilter())
1482             return false;
1483         if (!childBox.scrollPosition().isZero())
1484             return false;
1485     }
1486     return true;
1487 }
1488 
1489 bool RenderBox::foregroundIsKnownToBeOpaqueInRect(const LayoutRect&amp; localRect, unsigned maxDepthToTest) const
1490 {
1491     if (!maxDepthToTest)
1492         return false;
1493 
1494     for (auto&amp; childBox : childrenOfType&lt;RenderBox&gt;(*this)) {
1495         if (!isCandidateForOpaquenessTest(childBox))
1496             continue;
1497         LayoutPoint childLocation = childBox.location();
1498         if (childBox.isRelativelyPositioned())
1499             childLocation.move(childBox.relativePositionOffset());
1500         LayoutRect childLocalRect = localRect;
1501         childLocalRect.moveBy(-childLocation);
1502         if (childLocalRect.y() &lt; 0 || childLocalRect.x() &lt; 0) {
1503             // If there is unobscured area above/left of a static positioned box then the rect is probably not covered.
1504             if (childBox.style().position() == PositionType::Static)
1505                 return false;
1506             continue;
1507         }
1508         if (childLocalRect.maxY() &gt; childBox.height() || childLocalRect.maxX() &gt; childBox.width())
1509             continue;
1510         if (childBox.backgroundIsKnownToBeOpaqueInRect(childLocalRect))
1511             return true;
1512         if (childBox.foregroundIsKnownToBeOpaqueInRect(childLocalRect, maxDepthToTest - 1))
1513             return true;
1514     }
1515     return false;
1516 }
1517 
1518 bool RenderBox::computeBackgroundIsKnownToBeObscured(const LayoutPoint&amp; paintOffset)
1519 {
1520     // Test to see if the children trivially obscure the background.
1521     // FIXME: This test can be much more comprehensive.
1522     if (!hasBackground())
1523         return false;
1524     // Table and root background painting is special.
1525     if (isTable() || isDocumentElementRenderer())
1526         return false;
1527 
1528     LayoutRect backgroundRect;
1529     if (!getBackgroundPaintedExtent(paintOffset, backgroundRect))
1530         return false;
1531 
1532     if (hasLayer() &amp;&amp; layer()-&gt;scrollingMayRevealBackground())
1533         return false;
1534 
1535     return foregroundIsKnownToBeOpaqueInRect(backgroundRect, backgroundObscurationTestMaxDepth);
1536 }
1537 
1538 bool RenderBox::backgroundHasOpaqueTopLayer() const
1539 {
1540     auto&amp; fillLayer = style().backgroundLayers();
1541     if (fillLayer.clip() != FillBox::Border)
1542         return false;
1543 
1544     // Clipped with local scrolling
1545     if (hasOverflowClip() &amp;&amp; fillLayer.attachment() == FillAttachment::LocalBackground)
1546         return false;
1547 
1548     if (fillLayer.hasOpaqueImage(*this) &amp;&amp; fillLayer.hasRepeatXY() &amp;&amp; fillLayer.image()-&gt;canRender(this, style().effectiveZoom()))
1549         return true;
1550 
1551     // If there is only one layer and no image, check whether the background color is opaque.
1552     if (!fillLayer.next() &amp;&amp; !fillLayer.hasImage()) {
1553         Color bgColor = style().visitedDependentColorWithColorFilter(CSSPropertyBackgroundColor);
1554         if (bgColor.isOpaque())
1555             return true;
1556     }
1557 
1558     return false;
1559 }
1560 
1561 void RenderBox::paintMask(PaintInfo&amp; paintInfo, const LayoutPoint&amp; paintOffset)
1562 {
1563     if (!paintInfo.shouldPaintWithinRoot(*this) || style().visibility() != Visibility::Visible || paintInfo.phase != PaintPhase::Mask || paintInfo.context().paintingDisabled())
1564         return;
1565 
1566     LayoutRect paintRect = LayoutRect(paintOffset, size());
1567     adjustBorderBoxRectForPainting(paintRect);
1568     paintMaskImages(paintInfo, paintRect);
1569 }
1570 
1571 void RenderBox::paintClippingMask(PaintInfo&amp; paintInfo, const LayoutPoint&amp; paintOffset)
1572 {
1573     if (!paintInfo.shouldPaintWithinRoot(*this) || style().visibility() != Visibility::Visible || paintInfo.phase != PaintPhase::ClippingMask || paintInfo.context().paintingDisabled())
1574         return;
1575 
1576     LayoutRect paintRect = LayoutRect(paintOffset, size());
1577     paintInfo.context().fillRect(snappedIntRect(paintRect), Color::black);
1578 }
1579 
1580 void RenderBox::paintMaskImages(const PaintInfo&amp; paintInfo, const LayoutRect&amp; paintRect)
1581 {
1582     // Figure out if we need to push a transparency layer to render our mask.
1583     bool pushTransparencyLayer = false;
1584     bool compositedMask = hasLayer() &amp;&amp; layer()-&gt;hasCompositedMask();
1585     bool flattenCompositingLayers = paintInfo.paintBehavior.contains(PaintBehavior::FlattenCompositingLayers);
1586     CompositeOperator compositeOp = CompositeSourceOver;
1587 
1588     bool allMaskImagesLoaded = true;
1589 
1590     if (!compositedMask || flattenCompositingLayers) {
1591         pushTransparencyLayer = true;
1592 
1593         // Don&#39;t render a masked element until all the mask images have loaded, to prevent a flash of unmasked content.
1594         if (auto* maskBoxImage = style().maskBoxImage().image())
1595             allMaskImagesLoaded &amp;= maskBoxImage-&gt;isLoaded();
1596 
1597         allMaskImagesLoaded &amp;= style().maskLayers().imagesAreLoaded();
1598 
1599         paintInfo.context().setCompositeOperation(CompositeDestinationIn);
1600         paintInfo.context().beginTransparencyLayer(1);
1601         compositeOp = CompositeSourceOver;
1602     }
1603 
1604     if (allMaskImagesLoaded) {
1605         paintFillLayers(paintInfo, Color(), style().maskLayers(), paintRect, BackgroundBleedNone, compositeOp);
1606         paintNinePieceImage(paintInfo.context(), paintRect, style(), style().maskBoxImage(), compositeOp);
1607     }
1608 
1609     if (pushTransparencyLayer)
1610         paintInfo.context().endTransparencyLayer();
1611 }
1612 
1613 LayoutRect RenderBox::maskClipRect(const LayoutPoint&amp; paintOffset)
1614 {
1615     const NinePieceImage&amp; maskBoxImage = style().maskBoxImage();
1616     if (maskBoxImage.image()) {
1617         LayoutRect borderImageRect = borderBoxRect();
1618 
1619         // Apply outsets to the border box.
1620         borderImageRect.expand(style().maskBoxImageOutsets());
1621         return borderImageRect;
1622     }
1623 
1624     LayoutRect result;
1625     LayoutRect borderBox = borderBoxRect();
1626     for (auto* maskLayer = &amp;style().maskLayers(); maskLayer; maskLayer = maskLayer-&gt;next()) {
1627         if (maskLayer-&gt;image()) {
1628             // Masks should never have fixed attachment, so it&#39;s OK for paintContainer to be null.
1629             result.unite(calculateBackgroundImageGeometry(nullptr, *maskLayer, paintOffset, borderBox).destRect());
1630         }
1631     }
1632     return result;
1633 }
1634 
1635 void RenderBox::paintFillLayers(const PaintInfo&amp; paintInfo, const Color&amp; color, const FillLayer&amp; fillLayer, const LayoutRect&amp; rect,
1636     BackgroundBleedAvoidance bleedAvoidance, CompositeOperator op, RenderElement* backgroundObject)
1637 {
1638     Vector&lt;const FillLayer*, 8&gt; layers;
1639     bool shouldDrawBackgroundInSeparateBuffer = false;
1640 
1641     for (auto* layer = &amp;fillLayer; layer; layer = layer-&gt;next()) {
1642         layers.append(layer);
1643 
1644         if (layer-&gt;blendMode() != BlendMode::Normal)
1645             shouldDrawBackgroundInSeparateBuffer = true;
1646 
1647         // Stop traversal when an opaque layer is encountered.
1648         // FIXME: It would be possible for the following occlusion culling test to be more aggressive
1649         // on layers with no repeat by testing whether the image covers the layout rect.
1650         // Testing that here would imply duplicating a lot of calculations that are currently done in
1651         // RenderBoxModelObject::paintFillLayerExtended. A more efficient solution might be to move
1652         // the layer recursion into paintFillLayerExtended, or to compute the layer geometry here
1653         // and pass it down.
1654 
1655         // The clipOccludesNextLayers condition must be evaluated first to avoid short-circuiting.
1656         if (layer-&gt;clipOccludesNextLayers(layer == &amp;fillLayer) &amp;&amp; layer-&gt;hasOpaqueImage(*this) &amp;&amp; layer-&gt;image()-&gt;canRender(this, style().effectiveZoom()) &amp;&amp; layer-&gt;hasRepeatXY() &amp;&amp; layer-&gt;blendMode() == BlendMode::Normal)
1657             break;
1658     }
1659 
1660     auto&amp; context = paintInfo.context();
1661     auto baseBgColorUsage = BaseBackgroundColorUse;
1662 
1663     if (shouldDrawBackgroundInSeparateBuffer) {
1664         paintFillLayer(paintInfo, color, *layers.last(), rect, bleedAvoidance, op, backgroundObject, BaseBackgroundColorOnly);
1665         baseBgColorUsage = BaseBackgroundColorSkip;
1666         context.beginTransparencyLayer(1);
1667     }
1668 
1669     auto topLayer = layers.rend();
1670     for (auto it = layers.rbegin(); it != topLayer; ++it)
1671         paintFillLayer(paintInfo, color, **it, rect, bleedAvoidance, op, backgroundObject, baseBgColorUsage);
1672 
1673     if (shouldDrawBackgroundInSeparateBuffer)
1674         context.endTransparencyLayer();
1675 }
1676 
1677 void RenderBox::paintFillLayer(const PaintInfo&amp; paintInfo, const Color&amp; c, const FillLayer&amp; fillLayer, const LayoutRect&amp; rect,
1678     BackgroundBleedAvoidance bleedAvoidance, CompositeOperator op, RenderElement* backgroundObject, BaseBackgroundColorUsage baseBgColorUsage)
1679 {
1680     paintFillLayerExtended(paintInfo, c, fillLayer, rect, bleedAvoidance, nullptr, LayoutSize(), op, backgroundObject, baseBgColorUsage);
1681 }
1682 
1683 static bool layersUseImage(WrappedImagePtr image, const FillLayer&amp; layers)
1684 {
1685     for (auto* layer = &amp;layers; layer; layer = layer-&gt;next()) {
1686         if (layer-&gt;image() &amp;&amp; image == layer-&gt;image()-&gt;data())
1687             return true;
1688     }
1689     return false;
1690 }
1691 
1692 void RenderBox::imageChanged(WrappedImagePtr image, const IntRect*)
1693 {
1694     if (!parent())
1695         return;
1696 
1697     if ((style().borderImage().image() &amp;&amp; style().borderImage().image()-&gt;data() == image) ||
1698         (style().maskBoxImage().image() &amp;&amp; style().maskBoxImage().image()-&gt;data() == image)) {
1699         repaint();
1700         return;
1701     }
1702 
1703     ShapeValue* shapeOutsideValue = style().shapeOutside();
1704     if (!view().frameView().layoutContext().isInRenderTreeLayout() &amp;&amp; isFloating() &amp;&amp; shapeOutsideValue &amp;&amp; shapeOutsideValue-&gt;image() &amp;&amp; shapeOutsideValue-&gt;image()-&gt;data() == image) {
1705         ShapeOutsideInfo::ensureInfo(*this).markShapeAsDirty();
1706         markShapeOutsideDependentsForLayout();
1707     }
1708 
1709     bool didFullRepaint = repaintLayerRectsForImage(image, style().backgroundLayers(), true);
1710     if (!didFullRepaint)
1711         repaintLayerRectsForImage(image, style().maskLayers(), false);
1712 
1713     if (!isComposited())
1714         return;
1715 
1716     if (layer()-&gt;hasCompositedMask() &amp;&amp; layersUseImage(image, style().maskLayers()))
1717         layer()-&gt;contentChanged(MaskImageChanged);
1718     if (layersUseImage(image, style().backgroundLayers()))
1719         layer()-&gt;contentChanged(BackgroundImageChanged);
1720 }
1721 
1722 bool RenderBox::repaintLayerRectsForImage(WrappedImagePtr image, const FillLayer&amp; layers, bool drawingBackground)
1723 {
1724     LayoutRect rendererRect;
1725     RenderBox* layerRenderer = nullptr;
1726 
1727     for (auto* layer = &amp;layers; layer; layer = layer-&gt;next()) {
1728         if (layer-&gt;image() &amp;&amp; image == layer-&gt;image()-&gt;data() &amp;&amp; layer-&gt;image()-&gt;canRender(this, style().effectiveZoom())) {
1729             // Now that we know this image is being used, compute the renderer and the rect if we haven&#39;t already.
1730             bool drawingRootBackground = drawingBackground &amp;&amp; (isDocumentElementRenderer() || (isBody() &amp;&amp; !document().documentElement()-&gt;renderer()-&gt;hasBackground()));
1731             if (!layerRenderer) {
1732                 if (drawingRootBackground) {
1733                     layerRenderer = &amp;view();
1734 
1735                     LayoutUnit rw = downcast&lt;RenderView&gt;(*layerRenderer).frameView().contentsWidth();
1736                     LayoutUnit rh = downcast&lt;RenderView&gt;(*layerRenderer).frameView().contentsHeight();
1737 
1738                     rendererRect = LayoutRect(-layerRenderer-&gt;marginLeft(),
1739                         -layerRenderer-&gt;marginTop(),
1740                         std::max(layerRenderer-&gt;width() + layerRenderer-&gt;horizontalMarginExtent() + layerRenderer-&gt;borderLeft() + layerRenderer-&gt;borderRight(), rw),
1741                         std::max(layerRenderer-&gt;height() + layerRenderer-&gt;verticalMarginExtent() + layerRenderer-&gt;borderTop() + layerRenderer-&gt;borderBottom(), rh));
1742                 } else {
1743                     layerRenderer = this;
1744                     rendererRect = borderBoxRect();
1745                 }
1746             }
1747             // FIXME: Figure out how to pass absolute position to calculateBackgroundImageGeometry (for pixel snapping)
1748             BackgroundImageGeometry geometry = layerRenderer-&gt;calculateBackgroundImageGeometry(nullptr, *layer, LayoutPoint(), rendererRect);
1749             if (geometry.hasNonLocalGeometry()) {
1750                 // Rather than incur the costs of computing the paintContainer for renderers with fixed backgrounds
1751                 // in order to get the right destRect, just repaint the entire renderer.
1752                 layerRenderer-&gt;repaint();
1753                 return true;
1754             }
1755 
1756             LayoutRect rectToRepaint = geometry.destRect();
1757             bool shouldClipToLayer = true;
1758 
1759             // If this is the root background layer, we may need to extend the repaintRect if the FrameView has an
1760             // extendedBackground. We should only extend the rect if it is already extending the full width or height
1761             // of the rendererRect.
1762             if (drawingRootBackground &amp;&amp; view().frameView().hasExtendedBackgroundRectForPainting()) {
1763                 shouldClipToLayer = false;
1764                 IntRect extendedBackgroundRect = view().frameView().extendedBackgroundRectForPainting();
1765                 if (rectToRepaint.width() == rendererRect.width()) {
1766                     rectToRepaint.move(extendedBackgroundRect.x(), 0);
1767                     rectToRepaint.setWidth(extendedBackgroundRect.width());
1768                 }
1769                 if (rectToRepaint.height() == rendererRect.height()) {
1770                     rectToRepaint.move(0, extendedBackgroundRect.y());
1771                     rectToRepaint.setHeight(extendedBackgroundRect.height());
1772                 }
1773             }
1774 
1775             layerRenderer-&gt;repaintRectangle(rectToRepaint, shouldClipToLayer);
1776             if (geometry.destRect() == rendererRect)
1777                 return true;
1778         }
1779     }
1780     return false;
1781 }
1782 
1783 bool RenderBox::pushContentsClip(PaintInfo&amp; paintInfo, const LayoutPoint&amp; accumulatedOffset)
1784 {
1785     if (paintInfo.phase == PaintPhase::BlockBackground || paintInfo.phase == PaintPhase::SelfOutline || paintInfo.phase == PaintPhase::Mask)
1786         return false;
1787 
1788     bool isControlClip = hasControlClip();
1789     bool isOverflowClip = hasOverflowClip() &amp;&amp; !layer()-&gt;isSelfPaintingLayer();
1790 
1791     if (!isControlClip &amp;&amp; !isOverflowClip)
1792         return false;
1793 
1794     if (paintInfo.phase == PaintPhase::Outline)
1795         paintInfo.phase = PaintPhase::ChildOutlines;
1796     else if (paintInfo.phase == PaintPhase::ChildBlockBackground) {
1797         paintInfo.phase = PaintPhase::BlockBackground;
1798         paintObject(paintInfo, accumulatedOffset);
1799         paintInfo.phase = PaintPhase::ChildBlockBackgrounds;
1800     }
1801     float deviceScaleFactor = document().deviceScaleFactor();
1802     FloatRect clipRect = snapRectToDevicePixels((isControlClip ? controlClipRect(accumulatedOffset) : overflowClipRect(accumulatedOffset, nullptr, IgnoreOverlayScrollbarSize, paintInfo.phase)), deviceScaleFactor);
1803     paintInfo.context().save();
1804     if (style().hasBorderRadius())
1805         paintInfo.context().clipRoundedRect(style().getRoundedInnerBorderFor(LayoutRect(accumulatedOffset, size())).pixelSnappedRoundedRectForPainting(deviceScaleFactor));
1806     paintInfo.context().clip(clipRect);
1807 
1808     if (paintInfo.phase == PaintPhase::EventRegion)
1809         paintInfo.eventRegionContext-&gt;pushClip(enclosingIntRect(clipRect));
1810 
1811     return true;
1812 }
1813 
1814 void RenderBox::popContentsClip(PaintInfo&amp; paintInfo, PaintPhase originalPhase, const LayoutPoint&amp; accumulatedOffset)
1815 {
1816     ASSERT(hasControlClip() || (hasOverflowClip() &amp;&amp; !layer()-&gt;isSelfPaintingLayer()));
1817 
1818     if (paintInfo.phase == PaintPhase::EventRegion)
1819         paintInfo.eventRegionContext-&gt;popClip();
1820 
1821     paintInfo.context().restore();
1822     if (originalPhase == PaintPhase::Outline) {
1823         paintInfo.phase = PaintPhase::SelfOutline;
1824         paintObject(paintInfo, accumulatedOffset);
1825         paintInfo.phase = originalPhase;
1826     } else if (originalPhase == PaintPhase::ChildBlockBackground)
1827         paintInfo.phase = originalPhase;
1828 }
1829 
1830 LayoutRect RenderBox::overflowClipRect(const LayoutPoint&amp; location, RenderFragmentContainer* fragment, OverlayScrollbarSizeRelevancy relevancy, PaintPhase)
1831 {
1832     // FIXME: When overflow-clip (CSS3) is implemented, we&#39;ll obtain the property
1833     // here.
1834     LayoutRect clipRect = borderBoxRectInFragment(fragment);
1835     clipRect.setLocation(location + clipRect.location() + LayoutSize(borderLeft(), borderTop()));
1836     clipRect.setSize(clipRect.size() - LayoutSize(borderLeft() + borderRight(), borderTop() + borderBottom()));
1837 
1838     // Subtract out scrollbars if we have them.
1839     if (layer()) {
1840         if (shouldPlaceBlockDirectionScrollbarOnLeft())
1841             clipRect.move(layer()-&gt;verticalScrollbarWidth(relevancy), 0);
1842         clipRect.contract(layer()-&gt;verticalScrollbarWidth(relevancy), layer()-&gt;horizontalScrollbarHeight(relevancy));
1843     }
1844 
1845     return clipRect;
1846 }
1847 
1848 LayoutRect RenderBox::clipRect(const LayoutPoint&amp; location, RenderFragmentContainer* fragment)
1849 {
1850     LayoutRect borderBoxRect = borderBoxRectInFragment(fragment);
1851     LayoutRect clipRect = LayoutRect(borderBoxRect.location() + location, borderBoxRect.size());
1852 
1853     if (!style().clipLeft().isAuto()) {
1854         LayoutUnit c = valueForLength(style().clipLeft(), borderBoxRect.width());
1855         clipRect.move(c, 0_lu);
1856         clipRect.contract(c, 0_lu);
1857     }
1858 
1859     // We don&#39;t use the fragment-specific border box&#39;s width and height since clip offsets are (stupidly) specified
1860     // from the left and top edges. Therefore it&#39;s better to avoid constraining to smaller widths and heights.
1861 
1862     if (!style().clipRight().isAuto())
1863         clipRect.contract(width() - valueForLength(style().clipRight(), width()), 0_lu);
1864 
1865     if (!style().clipTop().isAuto()) {
1866         LayoutUnit c = valueForLength(style().clipTop(), borderBoxRect.height());
1867         clipRect.move(0_lu, c);
1868         clipRect.contract(0_lu, c);
1869     }
1870 
1871     if (!style().clipBottom().isAuto())
1872         clipRect.contract(0_lu, height() - valueForLength(style().clipBottom(), height()));
1873 
1874     return clipRect;
1875 }
1876 
1877 LayoutUnit RenderBox::shrinkLogicalWidthToAvoidFloats(LayoutUnit childMarginStart, LayoutUnit childMarginEnd, const RenderBlock&amp; cb, RenderFragmentContainer* fragment) const
1878 {
1879     RenderFragmentContainer* containingBlockFragment = nullptr;
1880     LayoutUnit logicalTopPosition = logicalTop();
1881     if (fragment) {
1882         LayoutUnit offsetFromLogicalTopOfFragment = fragment ? fragment-&gt;logicalTopForFragmentedFlowContent() - offsetFromLogicalTopOfFirstPage() : 0_lu;
1883         logicalTopPosition = std::max(logicalTopPosition, logicalTopPosition + offsetFromLogicalTopOfFragment);
1884         containingBlockFragment = cb.clampToStartAndEndFragments(fragment);
1885     }
1886 
1887     LayoutUnit logicalHeight = cb.logicalHeightForChild(*this);
1888     LayoutUnit result = cb.availableLogicalWidthForLineInFragment(logicalTopPosition, DoNotIndentText, containingBlockFragment, logicalHeight) - childMarginStart - childMarginEnd;
1889 
1890     // We need to see if margins on either the start side or the end side can contain the floats in question. If they can,
1891     // then just using the line width is inaccurate. In the case where a float completely fits, we don&#39;t need to use the line
1892     // offset at all, but can instead push all the way to the content edge of the containing block. In the case where the float
1893     // doesn&#39;t fit, we can use the line offset, but we need to grow it by the margin to reflect the fact that the margin was
1894     // &quot;consumed&quot; by the float. Negative margins aren&#39;t consumed by the float, and so we ignore them.
1895     if (childMarginStart &gt; 0) {
1896         LayoutUnit startContentSide = cb.startOffsetForContent(containingBlockFragment);
1897         LayoutUnit startContentSideWithMargin = startContentSide + childMarginStart;
1898         LayoutUnit startOffset = cb.startOffsetForLineInFragment(logicalTopPosition, DoNotIndentText, containingBlockFragment, logicalHeight);
1899         if (startOffset &gt; startContentSideWithMargin)
1900             result += childMarginStart;
1901         else
1902             result += startOffset - startContentSide;
1903     }
1904 
1905     if (childMarginEnd &gt; 0) {
1906         LayoutUnit endContentSide = cb.endOffsetForContent(containingBlockFragment);
1907         LayoutUnit endContentSideWithMargin = endContentSide + childMarginEnd;
1908         LayoutUnit endOffset = cb.endOffsetForLineInFragment(logicalTopPosition, DoNotIndentText, containingBlockFragment, logicalHeight);
1909         if (endOffset &gt; endContentSideWithMargin)
1910             result += childMarginEnd;
1911         else
1912             result += endOffset - endContentSide;
1913     }
1914 
1915     return result;
1916 }
1917 
1918 LayoutUnit RenderBox::containingBlockLogicalWidthForContent() const
1919 {
1920     if (hasOverrideContainingBlockContentLogicalWidth()) {
1921         if (auto overrideLogicalWidth = overrideContainingBlockContentLogicalWidth())
1922             return overrideLogicalWidth.value();
1923     }
1924 
1925     if (RenderBlock* cb = containingBlock())
1926         return cb-&gt;availableLogicalWidth();
1927     return 0_lu;
1928 }
1929 
1930 LayoutUnit RenderBox::containingBlockLogicalHeightForContent(AvailableLogicalHeightType heightType) const
1931 {
1932     if (hasOverrideContainingBlockContentLogicalHeight()) {
1933         if (auto overrideLogicalHeight = overrideContainingBlockContentLogicalHeight())
1934             return overrideLogicalHeight.value();
1935     }
1936 
1937     if (RenderBlock* cb = containingBlock())
1938         return cb-&gt;availableLogicalHeight(heightType);
1939     return 0_lu;
1940 }
1941 
1942 LayoutUnit RenderBox::containingBlockLogicalWidthForContentInFragment(RenderFragmentContainer* fragment) const
1943 {
1944     if (!fragment)
1945         return containingBlockLogicalWidthForContent();
1946 
1947     RenderBlock* cb = containingBlock();
1948     RenderFragmentContainer* containingBlockFragment = cb-&gt;clampToStartAndEndFragments(fragment);
1949     // FIXME: It&#39;s unclear if a fragment&#39;s content should use the containing block&#39;s override logical width.
1950     // If it should, the following line should call containingBlockLogicalWidthForContent.
1951     LayoutUnit result = cb-&gt;availableLogicalWidth();
1952     RenderBoxFragmentInfo* boxInfo = cb-&gt;renderBoxFragmentInfo(containingBlockFragment);
1953     if (!boxInfo)
1954         return result;
1955     return std::max&lt;LayoutUnit&gt;(0, result - (cb-&gt;logicalWidth() - boxInfo-&gt;logicalWidth()));
1956 }
1957 
1958 LayoutUnit RenderBox::containingBlockAvailableLineWidthInFragment(RenderFragmentContainer* fragment) const
1959 {
1960     RenderBlock* cb = containingBlock();
1961     RenderFragmentContainer* containingBlockFragment = nullptr;
1962     LayoutUnit logicalTopPosition = logicalTop();
1963     if (fragment) {
1964         LayoutUnit offsetFromLogicalTopOfFragment = fragment ? fragment-&gt;logicalTopForFragmentedFlowContent() - offsetFromLogicalTopOfFirstPage() : 0_lu;
1965         logicalTopPosition = std::max(logicalTopPosition, logicalTopPosition + offsetFromLogicalTopOfFragment);
1966         containingBlockFragment = cb-&gt;clampToStartAndEndFragments(fragment);
1967     }
1968     return cb-&gt;availableLogicalWidthForLineInFragment(logicalTopPosition, DoNotIndentText, containingBlockFragment, availableLogicalHeight(IncludeMarginBorderPadding));
1969 }
1970 
1971 LayoutUnit RenderBox::perpendicularContainingBlockLogicalHeight() const
1972 {
1973     if (hasOverrideContainingBlockContentLogicalHeight()) {
1974         if (auto overrideLogicalHeight = overrideContainingBlockContentLogicalHeight())
1975             return overrideLogicalHeight.value();
1976     }
1977 
1978     RenderBlock* cb = containingBlock();
1979     if (cb-&gt;hasOverrideContentLogicalHeight())
1980         return cb-&gt;overrideContentLogicalHeight();
1981 
1982     const RenderStyle&amp; containingBlockStyle = cb-&gt;style();
1983     Length logicalHeightLength = containingBlockStyle.logicalHeight();
1984 
1985     // FIXME: For now just support fixed heights.  Eventually should support percentage heights as well.
1986     if (!logicalHeightLength.isFixed()) {
1987         LayoutUnit fillFallbackExtent = containingBlockStyle.isHorizontalWritingMode() ? view().frameView().visibleHeight() : view().frameView().visibleWidth();
1988         LayoutUnit fillAvailableExtent = containingBlock()-&gt;availableLogicalHeight(ExcludeMarginBorderPadding);
1989         view().addPercentHeightDescendant(const_cast&lt;RenderBox&amp;&gt;(*this));
1990         // FIXME: https://bugs.webkit.org/show_bug.cgi?id=158286 We also need to perform the same percentHeightDescendant treatment to the element which dictates the return value for containingBlock()-&gt;availableLogicalHeight() above.
1991         return std::min(fillAvailableExtent, fillFallbackExtent);
1992     }
1993 
1994     // Use the content box logical height as specified by the style.
1995     return cb-&gt;adjustContentBoxLogicalHeightForBoxSizing(LayoutUnit(logicalHeightLength.value()));
1996 }
1997 
1998 void RenderBox::mapLocalToContainer(const RenderLayerModelObject* repaintContainer, TransformState&amp; transformState, MapCoordinatesFlags mode, bool* wasFixed) const
1999 {
2000     if (repaintContainer == this)
2001         return;
2002 
2003     if (!repaintContainer &amp;&amp; view().frameView().layoutContext().isPaintOffsetCacheEnabled()) {
2004         auto* layoutState = view().frameView().layoutContext().layoutState();
2005         LayoutSize offset = layoutState-&gt;paintOffset() + locationOffset();
2006         if (style().hasInFlowPosition() &amp;&amp; layer())
2007             offset += layer()-&gt;offsetForInFlowPosition();
2008         transformState.move(offset);
2009         return;
2010     }
2011 
2012     bool containerSkipped;
2013     RenderElement* container = this-&gt;container(repaintContainer, containerSkipped);
2014     if (!container)
2015         return;
2016 
2017     bool isFixedPos = isFixedPositioned();
2018     // If this box has a transform, it acts as a fixed position container for fixed descendants,
2019     // and may itself also be fixed position. So propagate &#39;fixed&#39; up only if this box is fixed position.
2020     if (hasTransform() &amp;&amp; !isFixedPos)
2021         mode &amp;= ~IsFixed;
2022     else if (isFixedPos)
2023         mode |= IsFixed;
2024 
2025     if (wasFixed)
2026         *wasFixed = mode &amp; IsFixed;
2027 
2028     LayoutSize containerOffset = offsetFromContainer(*container, LayoutPoint(transformState.mappedPoint()));
2029 
2030     bool preserve3D = mode &amp; UseTransforms &amp;&amp; (container-&gt;style().preserves3D() || style().preserves3D());
2031     if (mode &amp; UseTransforms &amp;&amp; shouldUseTransformFromContainer(container)) {
2032         TransformationMatrix t;
2033         getTransformFromContainer(container, containerOffset, t);
2034         transformState.applyTransform(t, preserve3D ? TransformState::AccumulateTransform : TransformState::FlattenTransform);
2035     } else
2036         transformState.move(containerOffset.width(), containerOffset.height(), preserve3D ? TransformState::AccumulateTransform : TransformState::FlattenTransform);
2037 
2038     if (containerSkipped) {
2039         // There can&#39;t be a transform between repaintContainer and o, because transforms create containers, so it should be safe
2040         // to just subtract the delta between the repaintContainer and o.
2041         LayoutSize containerOffset = repaintContainer-&gt;offsetFromAncestorContainer(*container);
2042         transformState.move(-containerOffset.width(), -containerOffset.height(), preserve3D ? TransformState::AccumulateTransform : TransformState::FlattenTransform);
2043         return;
2044     }
2045 
2046     mode &amp;= ~ApplyContainerFlip;
2047 
2048     container-&gt;mapLocalToContainer(repaintContainer, transformState, mode, wasFixed);
2049 }
2050 
2051 const RenderObject* RenderBox::pushMappingToContainer(const RenderLayerModelObject* ancestorToStopAt, RenderGeometryMap&amp; geometryMap) const
2052 {
2053     ASSERT(ancestorToStopAt != this);
2054 
2055     bool ancestorSkipped;
2056     RenderElement* container = this-&gt;container(ancestorToStopAt, ancestorSkipped);
2057     if (!container)
2058         return nullptr;
2059 
2060     bool isFixedPos = isFixedPositioned();
2061     LayoutSize adjustmentForSkippedAncestor;
2062     if (ancestorSkipped) {
2063         // There can&#39;t be a transform between repaintContainer and container, because transforms create containers, so it should be safe
2064         // to just subtract the delta between the ancestor and container.
2065         adjustmentForSkippedAncestor = -ancestorToStopAt-&gt;offsetFromAncestorContainer(*container);
2066     }
2067 
2068     bool offsetDependsOnPoint = false;
2069     LayoutSize containerOffset = offsetFromContainer(*container, LayoutPoint(), &amp;offsetDependsOnPoint);
2070 
2071     bool preserve3D = container-&gt;style().preserves3D() || style().preserves3D();
2072     if (shouldUseTransformFromContainer(container) &amp;&amp; (geometryMap.mapCoordinatesFlags() &amp; UseTransforms)) {
2073         TransformationMatrix t;
2074         getTransformFromContainer(container, containerOffset, t);
2075         t.translateRight(adjustmentForSkippedAncestor.width(), adjustmentForSkippedAncestor.height());
2076 
2077         geometryMap.push(this, t, preserve3D, offsetDependsOnPoint, isFixedPos, hasTransform());
2078     } else {
2079         containerOffset += adjustmentForSkippedAncestor;
2080         geometryMap.push(this, containerOffset, preserve3D, offsetDependsOnPoint, isFixedPos, hasTransform());
2081     }
2082 
2083     return ancestorSkipped ? ancestorToStopAt : container;
2084 }
2085 
2086 void RenderBox::mapAbsoluteToLocalPoint(MapCoordinatesFlags mode, TransformState&amp; transformState) const
2087 {
2088     bool isFixedPos = isFixedPositioned();
2089     if (hasTransform() &amp;&amp; !isFixedPos) {
2090         // If this box has a transform, it acts as a fixed position container for fixed descendants,
2091         // and may itself also be fixed position. So propagate &#39;fixed&#39; up only if this box is fixed position.
2092         mode &amp;= ~IsFixed;
2093     } else if (isFixedPos)
2094         mode |= IsFixed;
2095 
2096     RenderBoxModelObject::mapAbsoluteToLocalPoint(mode, transformState);
2097 }
2098 
2099 LayoutSize RenderBox::offsetFromContainer(RenderElement&amp; container, const LayoutPoint&amp;, bool* offsetDependsOnPoint) const
2100 {
2101     // A fragment &quot;has&quot; boxes inside it without being their container.
2102     ASSERT(&amp;container == this-&gt;container() || is&lt;RenderFragmentContainer&gt;(container));
2103 
2104     LayoutSize offset;
2105     if (isInFlowPositioned())
2106         offset += offsetForInFlowPosition();
2107 
2108     if (!isInline() || isReplaced())
2109         offset += topLeftLocationOffset();
2110 
2111     if (is&lt;RenderBox&gt;(container))
2112         offset -= toLayoutSize(downcast&lt;RenderBox&gt;(container).scrollPosition());
2113 
2114     if (isAbsolutelyPositioned() &amp;&amp; container.isInFlowPositioned() &amp;&amp; is&lt;RenderInline&gt;(container))
2115         offset += downcast&lt;RenderInline&gt;(container).offsetForInFlowPositionedInline(this);
2116 
2117     if (offsetDependsOnPoint)
2118         *offsetDependsOnPoint |= is&lt;RenderFragmentedFlow&gt;(container);
2119 
2120     return offset;
2121 }
2122 
2123 std::unique_ptr&lt;InlineElementBox&gt; RenderBox::createInlineBox()
2124 {
2125     return makeUnique&lt;InlineElementBox&gt;(*this);
2126 }
2127 
2128 void RenderBox::dirtyLineBoxes(bool fullLayout)
2129 {
2130     if (!m_inlineBoxWrapper)
2131         return;
2132 
2133     if (fullLayout) {
2134         delete m_inlineBoxWrapper;
2135         m_inlineBoxWrapper = nullptr;
2136     } else
2137         m_inlineBoxWrapper-&gt;dirtyLineBoxes();
2138 }
2139 
2140 void RenderBox::positionLineBox(InlineElementBox&amp; box)
2141 {
2142     if (isOutOfFlowPositioned()) {
2143         // Cache the x position only if we were an DisplayType::Inline type originally.
2144         bool wasInline = style().isOriginalDisplayInlineType();
2145         if (wasInline) {
2146             // The value is cached in the xPos of the box.  We only need this value if
2147             // our object was inline originally, since otherwise it would have ended up underneath
2148             // the inlines.
2149             RootInlineBox&amp; rootBox = box.root();
2150             rootBox.blockFlow().setStaticInlinePositionForChild(*this, rootBox.lineTopWithLeading(), LayoutUnit::fromFloatRound(box.logicalLeft()));
2151             if (style().hasStaticInlinePosition(box.isHorizontal()))
2152                 setChildNeedsLayout(MarkOnlyThis); // Just mark the positioned object as needing layout, so it will update its position properly.
2153         } else {
2154             // Our object was a block originally, so we make our normal flow position be
2155             // just below the line box (as though all the inlines that came before us got
2156             // wrapped in an anonymous block, which is what would have happened had we been
2157             // in flow).  This value was cached in the y() of the box.
2158             layer()-&gt;setStaticBlockPosition(LayoutUnit(box.logicalTop()));
2159             if (style().hasStaticBlockPosition(box.isHorizontal()))
2160                 setChildNeedsLayout(MarkOnlyThis); // Just mark the positioned object as needing layout, so it will update its position properly.
2161         }
2162         return;
2163     }
2164 
2165     if (isReplaced()) {
2166         setLocation(LayoutPoint(box.topLeft()));
2167         setInlineBoxWrapper(&amp;box);
2168     }
2169 }
2170 
2171 void RenderBox::deleteLineBoxWrapper()
2172 {
2173     if (!m_inlineBoxWrapper)
2174         return;
2175 
2176     if (!renderTreeBeingDestroyed())
2177         m_inlineBoxWrapper-&gt;removeFromParent();
2178     delete m_inlineBoxWrapper;
2179     m_inlineBoxWrapper = nullptr;
2180 }
2181 
2182 LayoutRect RenderBox::clippedOverflowRectForRepaint(const RenderLayerModelObject* repaintContainer) const
2183 {
2184     if (style().visibility() != Visibility::Visible &amp;&amp; !enclosingLayer()-&gt;hasVisibleContent())
2185         return LayoutRect();
2186     LayoutRect r = visualOverflowRect();
2187     // FIXME: layoutDelta needs to be applied in parts before/after transforms and
2188     // repaint containers. https://bugs.webkit.org/show_bug.cgi?id=23308
2189     r.move(view().frameView().layoutContext().layoutDelta());
2190     return computeRectForRepaint(r, repaintContainer);
2191 }
2192 
2193 LayoutRect RenderBox::computeVisibleRectUsingPaintOffset(const LayoutRect&amp; rect) const
2194 {
2195     LayoutRect adjustedRect = rect;
2196     auto* layoutState = view().frameView().layoutContext().layoutState();
2197 
2198     if (layer() &amp;&amp; layer()-&gt;transform())
2199         adjustedRect = LayoutRect(encloseRectToDevicePixels(layer()-&gt;transform()-&gt;mapRect(adjustedRect), document().deviceScaleFactor()));
2200 
2201     // We can&#39;t trust the bits on RenderObject, because this might be called while re-resolving style.
2202     if (style().hasInFlowPosition() &amp;&amp; layer())
2203         adjustedRect.move(layer()-&gt;offsetForInFlowPosition());
2204 
2205     adjustedRect.moveBy(location());
2206     adjustedRect.move(layoutState-&gt;paintOffset());
2207     if (layoutState-&gt;isClipped())
2208         adjustedRect.intersect(layoutState-&gt;clipRect());
2209     return adjustedRect;
2210 }
2211 
2212 Optional&lt;LayoutRect&gt; RenderBox::computeVisibleRectInContainer(const LayoutRect&amp; rect, const RenderLayerModelObject* container, VisibleRectContext context) const
2213 {
2214     // The rect we compute at each step is shifted by our x/y offset in the parent container&#39;s coordinate space.
2215     // Only when we cross a writing mode boundary will we have to possibly flipForWritingMode (to convert into a more appropriate
2216     // offset corner for the enclosing container).  This allows for a fully RL or BT document to repaint
2217     // properly even during layout, since the rect remains flipped all the way until the end.
2218     //
2219     // RenderView::computeVisibleRectInContainer then converts the rect to physical coordinates. We also convert to
2220     // physical when we hit a repaint container boundary. Therefore the final rect returned is always in the
2221     // physical coordinate space of the container.
2222     const RenderStyle&amp; styleToUse = style();
2223     // Paint offset cache is only valid for root-relative, non-fixed position repainting
2224     if (view().frameView().layoutContext().isPaintOffsetCacheEnabled() &amp;&amp; !container &amp;&amp; styleToUse.position() != PositionType::Fixed &amp;&amp; !context.m_options.contains(VisibleRectContextOption::UseEdgeInclusiveIntersection))
2225         return computeVisibleRectUsingPaintOffset(rect);
2226 
2227     LayoutRect adjustedRect = rect;
2228     if (hasReflection())
2229         adjustedRect.unite(reflectedRect(adjustedRect));
2230 
2231     if (container == this) {
2232         if (container-&gt;style().isFlippedBlocksWritingMode())
2233             flipForWritingMode(adjustedRect);
2234         return adjustedRect;
2235     }
2236 
2237     bool containerIsSkipped;
2238     auto* localContainer = this-&gt;container(container, containerIsSkipped);
2239     if (!localContainer)
2240         return adjustedRect;
2241 
2242     // This code isn&#39;t necessary for in-flow RenderFragmentedFlows.
2243     // Don&#39;t add the location of the fragment in the flow thread for absolute positioned
2244     // elements because their absolute position already pushes them down through
2245     // the fragments so adding this here and then adding the topLeft again would cause
2246     // us to add the height twice.
2247     // The same logic applies for elements flowed directly into the flow thread. Their topLeft member
2248     // will already contain the portion rect of the fragment.
2249     auto position = styleToUse.position();
2250     if (localContainer-&gt;isOutOfFlowRenderFragmentedFlow() &amp;&amp; position != PositionType::Absolute &amp;&amp; containingBlock() != enclosingFragmentedFlow()) {
2251         RenderFragmentContainer* firstFragment = nullptr;
2252         RenderFragmentContainer* lastFragment = nullptr;
2253         if (downcast&lt;RenderFragmentedFlow&gt;(*localContainer).getFragmentRangeForBox(this, firstFragment, lastFragment))
2254             adjustedRect.moveBy(firstFragment-&gt;fragmentedFlowPortionRect().location());
2255     }
2256 
2257     if (isWritingModeRoot()) {
2258         if (!isOutOfFlowPositioned() || !context.m_dirtyRectIsFlipped) {
2259             flipForWritingMode(adjustedRect);
2260             context.m_dirtyRectIsFlipped = true;
2261         }
2262     }
2263 
2264     LayoutSize locationOffset = this-&gt;locationOffset();
2265     // FIXME: This is needed as long as RenderWidget snaps to integral size/position.
2266     if (isRenderReplaced() &amp;&amp; isWidget()) {
2267         LayoutSize flooredLocationOffset = toIntSize(flooredIntPoint(locationOffset));
2268         adjustedRect.expand(locationOffset - flooredLocationOffset);
2269         locationOffset = flooredLocationOffset;
2270     }
2271 
2272     if (is&lt;RenderMultiColumnFlow&gt;(this)) {
2273         // We won&#39;t normally run this code. Only when the container is null (i.e., we&#39;re trying
2274         // to get the rect in view coordinates) will we come in here, since normally container
2275         // will be set and we&#39;ll stop at the flow thread. This case is mainly hit by the check for whether
2276         // or not images should animate.
2277         // FIXME: Just as with offsetFromContainer, we aren&#39;t really handling objects that span
2278         // multiple columns properly.
2279         LayoutPoint physicalPoint(flipForWritingMode(adjustedRect.location()));
2280         if (auto* fragment = downcast&lt;RenderMultiColumnFlow&gt;(*this).physicalTranslationFromFlowToFragment((physicalPoint))) {
2281             adjustedRect.setLocation(fragment-&gt;flipForWritingMode(physicalPoint));
2282             return fragment-&gt;computeVisibleRectInContainer(adjustedRect, container, context);
2283         }
2284     }
2285 
2286     LayoutPoint topLeft = adjustedRect.location();
2287     topLeft.move(locationOffset);
2288 
2289     // We are now in our parent container&#39;s coordinate space. Apply our transform to obtain a bounding box
2290     // in the parent&#39;s coordinate space that encloses us.
2291     if (hasLayer() &amp;&amp; layer()-&gt;transform()) {
2292         context.m_hasPositionFixedDescendant = position == PositionType::Fixed;
2293         adjustedRect = LayoutRect(encloseRectToDevicePixels(layer()-&gt;transform()-&gt;mapRect(adjustedRect), document().deviceScaleFactor()));
2294         topLeft = adjustedRect.location();
2295         topLeft.move(locationOffset);
2296     } else if (position == PositionType::Fixed)
2297         context.m_hasPositionFixedDescendant = true;
2298 
2299     if (position == PositionType::Absolute &amp;&amp; localContainer-&gt;isInFlowPositioned() &amp;&amp; is&lt;RenderInline&gt;(*localContainer))
2300         topLeft += downcast&lt;RenderInline&gt;(*localContainer).offsetForInFlowPositionedInline(this);
2301     else if (styleToUse.hasInFlowPosition() &amp;&amp; layer()) {
2302         // Apply the relative position offset when invalidating a rectangle.  The layer
2303         // is translated, but the render box isn&#39;t, so we need to do this to get the
2304         // right dirty rect.  Since this is called from RenderObject::setStyle, the relative position
2305         // flag on the RenderObject has been cleared, so use the one on the style().
2306         topLeft += layer()-&gt;offsetForInFlowPosition();
2307     }
2308 
2309     // FIXME: We ignore the lightweight clipping rect that controls use, since if |o| is in mid-layout,
2310     // its controlClipRect will be wrong. For overflow clip we use the values cached by the layer.
2311     adjustedRect.setLocation(topLeft);
2312     if (localContainer-&gt;hasOverflowClip()) {
2313         RenderBox&amp; containerBox = downcast&lt;RenderBox&gt;(*localContainer);
2314         bool isEmpty = !containerBox.applyCachedClipAndScrollPosition(adjustedRect, container, context);
2315         if (isEmpty) {
2316             if (context.m_options.contains(VisibleRectContextOption::UseEdgeInclusiveIntersection))
2317                 return WTF::nullopt;
2318             return adjustedRect;
2319         }
2320     }
2321 
2322     if (containerIsSkipped) {
2323         // If the container is below localContainer, then we need to map the rect into container&#39;s coordinates.
2324         LayoutSize containerOffset = container-&gt;offsetFromAncestorContainer(*localContainer);
2325         adjustedRect.move(-containerOffset);
2326         return adjustedRect;
2327     }
2328     return localContainer-&gt;computeVisibleRectInContainer(adjustedRect, container, context);
2329 }
2330 
2331 void RenderBox::repaintDuringLayoutIfMoved(const LayoutRect&amp; oldRect)
2332 {
2333     if (oldRect.location() != m_frameRect.location()) {
2334         LayoutRect newRect = m_frameRect;
2335         // The child moved.  Invalidate the object&#39;s old and new positions.  We have to do this
2336         // since the object may not have gotten a layout.
2337         m_frameRect = oldRect;
2338         repaint();
2339         repaintOverhangingFloats(true);
2340         m_frameRect = newRect;
2341         repaint();
2342         repaintOverhangingFloats(true);
2343     }
2344 }
2345 
2346 void RenderBox::repaintOverhangingFloats(bool)
2347 {
2348 }
2349 
2350 void RenderBox::updateLogicalWidth()
2351 {
2352     LogicalExtentComputedValues computedValues;
2353     computeLogicalWidthInFragment(computedValues);
2354 
2355     setLogicalWidth(computedValues.m_extent);
2356     setLogicalLeft(computedValues.m_position);
2357     setMarginStart(computedValues.m_margins.m_start);
2358     setMarginEnd(computedValues.m_margins.m_end);
2359 }
2360 
2361 void RenderBox::computeLogicalWidthInFragment(LogicalExtentComputedValues&amp; computedValues, RenderFragmentContainer* fragment) const
2362 {
2363     computedValues.m_extent = logicalWidth();
2364     computedValues.m_position = logicalLeft();
2365     computedValues.m_margins.m_start = marginStart();
2366     computedValues.m_margins.m_end = marginEnd();
2367 
2368     if (isOutOfFlowPositioned()) {
2369         // FIXME: This calculation is not patched for block-flow yet.
2370         // https://bugs.webkit.org/show_bug.cgi?id=46500
2371         computePositionedLogicalWidth(computedValues, fragment);
2372         return;
2373     }
2374 
2375     // If layout is limited to a subtree, the subtree root&#39;s logical width does not change.
2376     if (element() &amp;&amp; !view().frameView().layoutContext().isLayoutPending() &amp;&amp; view().frameView().layoutContext().subtreeLayoutRoot() == this)
2377         return;
2378 
2379     // The parent box is flexing us, so it has increased or decreased our
2380     // width.  Use the width from the style context.
2381     // FIXME: Account for block-flow in flexible boxes.
2382     // https://bugs.webkit.org/show_bug.cgi?id=46418
2383     if (hasOverrideContentLogicalWidth() &amp;&amp; (isRubyRun() || style().borderFit() == BorderFit::Lines || (parent()-&gt;isFlexibleBoxIncludingDeprecated()))) {
2384         computedValues.m_extent = overrideContentLogicalWidth() + borderAndPaddingLogicalWidth();
2385         return;
2386     }
2387 
2388     // FIXME: Account for block-flow in flexible boxes.
2389     // https://bugs.webkit.org/show_bug.cgi?id=46418
2390     bool inVerticalBox = parent()-&gt;isDeprecatedFlexibleBox() &amp;&amp; (parent()-&gt;style().boxOrient() == BoxOrient::Vertical);
2391     bool stretching = (parent()-&gt;style().boxAlign() == BoxAlignment::Stretch);
2392     // FIXME: Stretching is the only reason why we don&#39;t want the box to be treated as a replaced element, so we could perhaps
2393     // refactor all this logic, not only for flex and grid since alignment is intended to be applied to any block.
2394     bool treatAsReplaced = shouldComputeSizeAsReplaced() &amp;&amp; (!inVerticalBox || !stretching);
2395     treatAsReplaced = treatAsReplaced &amp;&amp; (!isGridItem() || !hasStretchedLogicalWidth());
2396 
2397     const RenderStyle&amp; styleToUse = style();
2398     Length logicalWidthLength = treatAsReplaced ? Length(computeReplacedLogicalWidth(), Fixed) : styleToUse.logicalWidth();
2399 
2400     RenderBlock&amp; cb = *containingBlock();
2401     LayoutUnit containerLogicalWidth = std::max&lt;LayoutUnit&gt;(0, containingBlockLogicalWidthForContentInFragment(fragment));
2402     bool hasPerpendicularContainingBlock = cb.isHorizontalWritingMode() != isHorizontalWritingMode();
2403 
2404     if (isInline() &amp;&amp; !isInlineBlockOrInlineTable()) {
2405         // just calculate margins
2406         computedValues.m_margins.m_start = minimumValueForLength(styleToUse.marginStart(), containerLogicalWidth);
2407         computedValues.m_margins.m_end = minimumValueForLength(styleToUse.marginEnd(), containerLogicalWidth);
2408         if (treatAsReplaced)
2409             computedValues.m_extent = std::max(LayoutUnit(floatValueForLength(logicalWidthLength, 0) + borderAndPaddingLogicalWidth()), minPreferredLogicalWidth());
2410         return;
2411     }
2412 
2413     LayoutUnit containerWidthInInlineDirection = containerLogicalWidth;
2414     if (hasPerpendicularContainingBlock)
2415         containerWidthInInlineDirection = perpendicularContainingBlockLogicalHeight();
2416 
2417     // Width calculations
2418     if (treatAsReplaced) {
2419         computedValues.m_extent = logicalWidthLength.value() + borderAndPaddingLogicalWidth();
2420     } else {
2421         LayoutUnit preferredWidth = computeLogicalWidthInFragmentUsing(MainOrPreferredSize, styleToUse.logicalWidth(), containerWidthInInlineDirection, cb, fragment);
2422         computedValues.m_extent = constrainLogicalWidthInFragmentByMinMax(preferredWidth, containerWidthInInlineDirection, cb, fragment);
2423     }
2424 
2425     // Margin calculations.
2426     if (hasPerpendicularContainingBlock || isFloating() || isInline()) {
2427         computedValues.m_margins.m_start = minimumValueForLength(styleToUse.marginStart(), containerLogicalWidth);
2428         computedValues.m_margins.m_end = minimumValueForLength(styleToUse.marginEnd(), containerLogicalWidth);
2429     } else {
2430         LayoutUnit containerLogicalWidthForAutoMargins = containerLogicalWidth;
2431         if (avoidsFloats() &amp;&amp; cb.containsFloats())
2432             containerLogicalWidthForAutoMargins = containingBlockAvailableLineWidthInFragment(fragment);
2433         bool hasInvertedDirection = cb.style().isLeftToRightDirection() != style().isLeftToRightDirection();
2434         computeInlineDirectionMargins(cb, containerLogicalWidthForAutoMargins, computedValues.m_extent,
2435             hasInvertedDirection ? computedValues.m_margins.m_end : computedValues.m_margins.m_start,
2436             hasInvertedDirection ? computedValues.m_margins.m_start : computedValues.m_margins.m_end);
2437     }
2438 
2439     if (!hasPerpendicularContainingBlock &amp;&amp; containerLogicalWidth &amp;&amp; containerLogicalWidth != (computedValues.m_extent + computedValues.m_margins.m_start + computedValues.m_margins.m_end)
2440         &amp;&amp; !isFloating() &amp;&amp; !isInline() &amp;&amp; !cb.isFlexibleBoxIncludingDeprecated()
2441 #if ENABLE(MATHML)
2442         // RenderMathMLBlocks take the size of their content so we must not adjust the margin to fill the container size.
2443         &amp;&amp; !cb.isRenderMathMLBlock()
2444 #endif
2445         &amp;&amp; !cb.isRenderGrid()
2446         ) {
2447         LayoutUnit newMarginTotal = containerLogicalWidth - computedValues.m_extent;
2448         bool hasInvertedDirection = cb.style().isLeftToRightDirection() != style().isLeftToRightDirection();
2449         if (hasInvertedDirection)
2450             computedValues.m_margins.m_start = newMarginTotal - computedValues.m_margins.m_end;
2451         else
2452             computedValues.m_margins.m_end = newMarginTotal - computedValues.m_margins.m_start;
2453     }
2454 }
2455 
2456 LayoutUnit RenderBox::fillAvailableMeasure(LayoutUnit availableLogicalWidth) const
2457 {
2458     LayoutUnit marginStart;
2459     LayoutUnit marginEnd;
2460     return fillAvailableMeasure(availableLogicalWidth, marginStart, marginEnd);
2461 }
2462 
2463 LayoutUnit RenderBox::fillAvailableMeasure(LayoutUnit availableLogicalWidth, LayoutUnit&amp; marginStart, LayoutUnit&amp; marginEnd) const
2464 {
2465     marginStart = minimumValueForLength(style().marginStart(), availableLogicalWidth);
2466     marginEnd = minimumValueForLength(style().marginEnd(), availableLogicalWidth);
2467     return availableLogicalWidth - marginStart - marginEnd;
2468 }
2469 
2470 LayoutUnit RenderBox::computeIntrinsicLogicalWidthUsing(Length logicalWidthLength, LayoutUnit availableLogicalWidth, LayoutUnit borderAndPadding) const
2471 {
2472     if (logicalWidthLength.type() == FillAvailable)
2473         return std::max(borderAndPadding, fillAvailableMeasure(availableLogicalWidth));
2474 
2475     LayoutUnit minLogicalWidth;
2476     LayoutUnit maxLogicalWidth;
2477     computeIntrinsicLogicalWidths(minLogicalWidth, maxLogicalWidth);
2478 
2479     if (logicalWidthLength.type() == MinContent)
2480         return minLogicalWidth + borderAndPadding;
2481 
2482     if (logicalWidthLength.type() == MaxContent)
2483         return maxLogicalWidth + borderAndPadding;
2484 
2485     if (logicalWidthLength.type() == FitContent) {
2486         minLogicalWidth += borderAndPadding;
2487         maxLogicalWidth += borderAndPadding;
2488         return std::max(minLogicalWidth, std::min(maxLogicalWidth, fillAvailableMeasure(availableLogicalWidth)));
2489     }
2490 
2491     ASSERT_NOT_REACHED();
2492     return 0;
2493 }
2494 
2495 LayoutUnit RenderBox::computeLogicalWidthInFragmentUsing(SizeType widthType, Length logicalWidth, LayoutUnit availableLogicalWidth,
2496     const RenderBlock&amp; cb, RenderFragmentContainer* fragment) const
2497 {
2498     ASSERT(widthType == MinSize || widthType == MainOrPreferredSize || !logicalWidth.isAuto());
2499     if (widthType == MinSize &amp;&amp; logicalWidth.isAuto())
2500         return adjustBorderBoxLogicalWidthForBoxSizing(0);
2501 
2502     if (!logicalWidth.isIntrinsicOrAuto()) {
2503         // FIXME: If the containing block flow is perpendicular to our direction we need to use the available logical height instead.
2504         return adjustBorderBoxLogicalWidthForBoxSizing(valueForLength(logicalWidth, availableLogicalWidth));
2505     }
2506 
2507     if (logicalWidth.isIntrinsic())
2508         return computeIntrinsicLogicalWidthUsing(logicalWidth, availableLogicalWidth, borderAndPaddingLogicalWidth());
2509 
2510     LayoutUnit marginStart;
2511     LayoutUnit marginEnd;
2512     LayoutUnit logicalWidthResult = fillAvailableMeasure(availableLogicalWidth, marginStart, marginEnd);
2513 
2514     if (shrinkToAvoidFloats() &amp;&amp; cb.containsFloats())
2515         logicalWidthResult = std::min(logicalWidthResult, shrinkLogicalWidthToAvoidFloats(marginStart, marginEnd, cb, fragment));
2516 
2517     if (widthType == MainOrPreferredSize &amp;&amp; sizesLogicalWidthToFitContent(widthType))
2518         return std::max(minPreferredLogicalWidth(), std::min(maxPreferredLogicalWidth(), logicalWidthResult));
2519     return logicalWidthResult;
2520 }
2521 
2522 bool RenderBox::columnFlexItemHasStretchAlignment() const
2523 {
2524     // auto margins mean we don&#39;t stretch. Note that this function will only be
2525     // used for widths, so we don&#39;t have to check marginBefore/marginAfter.
2526     const auto&amp; parentStyle = parent()-&gt;style();
2527     ASSERT(parentStyle.isColumnFlexDirection());
2528     if (style().marginStart().isAuto() || style().marginEnd().isAuto())
2529         return false;
2530     return style().resolvedAlignSelf(&amp;parentStyle, containingBlock()-&gt;selfAlignmentNormalBehavior()).position() == ItemPosition::Stretch;
2531 }
2532 
2533 bool RenderBox::isStretchingColumnFlexItem() const
2534 {
2535     if (parent()-&gt;isDeprecatedFlexibleBox() &amp;&amp; parent()-&gt;style().boxOrient() == BoxOrient::Vertical &amp;&amp; parent()-&gt;style().boxAlign() == BoxAlignment::Stretch)
2536         return true;
2537 
2538     // We don&#39;t stretch multiline flexboxes because they need to apply line spacing (align-content) first.
2539     if (parent()-&gt;isFlexibleBox() &amp;&amp; parent()-&gt;style().flexWrap() == FlexWrap::NoWrap &amp;&amp; parent()-&gt;style().isColumnFlexDirection() &amp;&amp; columnFlexItemHasStretchAlignment())
2540         return true;
2541     return false;
2542 }
2543 
2544 // FIXME: Can/Should we move this inside specific layout classes (flex. grid)? Can we refactor columnFlexItemHasStretchAlignment logic?
2545 bool RenderBox::hasStretchedLogicalWidth() const
2546 {
2547     auto&amp; style = this-&gt;style();
2548     if (!style.logicalWidth().isAuto() || style.marginStart().isAuto() || style.marginEnd().isAuto())
2549         return false;
2550     RenderBlock* containingBlock = this-&gt;containingBlock();
2551     if (!containingBlock) {
2552         // We are evaluating align-self/justify-self, which default to &#39;normal&#39; for the root element.
2553         // The &#39;normal&#39; value behaves like &#39;start&#39; except for Flexbox Items, which obviously should have a container.
2554         return false;
2555     }
2556     if (containingBlock-&gt;isHorizontalWritingMode() != isHorizontalWritingMode())
2557         return style.resolvedAlignSelf(&amp;containingBlock-&gt;style(), containingBlock-&gt;selfAlignmentNormalBehavior(this)).position() == ItemPosition::Stretch;
2558     return style.resolvedJustifySelf(&amp;containingBlock-&gt;style(), containingBlock-&gt;selfAlignmentNormalBehavior(this)).position() == ItemPosition::Stretch;
2559 }
2560 
2561 bool RenderBox::sizesLogicalWidthToFitContent(SizeType widthType) const
2562 {
2563     // Marquees in WinIE are like a mixture of blocks and inline-blocks.  They size as though they&#39;re blocks,
2564     // but they allow text to sit on the same line as the marquee.
2565     if (isFloating() || (isInlineBlockOrInlineTable() &amp;&amp; !isHTMLMarquee()))
2566         return true;
2567 
2568     if (isGridItem())
2569         return !hasStretchedLogicalWidth();
2570 
2571     // This code may look a bit strange.  Basically width:intrinsic should clamp the size when testing both
2572     // min-width and width.  max-width is only clamped if it is also intrinsic.
2573     Length logicalWidth = (widthType == MaxSize) ? style().logicalMaxWidth() : style().logicalWidth();
2574     if (logicalWidth.type() == Intrinsic)
2575         return true;
2576 
2577     // Children of a horizontal marquee do not fill the container by default.
2578     // FIXME: Need to deal with MarqueeDirection::Auto value properly. It could be vertical.
2579     // FIXME: Think about block-flow here.  Need to find out how marquee direction relates to
2580     // block-flow (as well as how marquee overflow should relate to block flow).
2581     // https://bugs.webkit.org/show_bug.cgi?id=46472
2582     if (parent()-&gt;isHTMLMarquee()) {
2583         MarqueeDirection dir = parent()-&gt;style().marqueeDirection();
2584         if (dir == MarqueeDirection::Auto || dir == MarqueeDirection::Forward || dir == MarqueeDirection::Backward || dir == MarqueeDirection::Left || dir == MarqueeDirection::Right)
2585             return true;
2586     }
2587 
2588 #if ENABLE(MATHML)
2589     // RenderMathMLBlocks take the size of their content, not of their container.
2590     if (parent()-&gt;isRenderMathMLBlock())
2591         return true;
2592 #endif
2593 
2594     // Flexible box items should shrink wrap, so we lay them out at their intrinsic widths.
2595     // In the case of columns that have a stretch alignment, we layout at the stretched size
2596     // to avoid an extra layout when applying alignment.
2597     if (parent()-&gt;isFlexibleBox()) {
2598         // For multiline columns, we need to apply align-content first, so we can&#39;t stretch now.
2599         if (!parent()-&gt;style().isColumnFlexDirection() || parent()-&gt;style().flexWrap() != FlexWrap::NoWrap)
2600             return true;
2601         if (!columnFlexItemHasStretchAlignment())
2602             return true;
2603     }
2604 
2605     // Flexible horizontal boxes lay out children at their intrinsic widths.  Also vertical boxes
2606     // that don&#39;t stretch their kids lay out their children at their intrinsic widths.
2607     // FIXME: Think about block-flow here.
2608     // https://bugs.webkit.org/show_bug.cgi?id=46473
2609     if (parent()-&gt;isDeprecatedFlexibleBox() &amp;&amp; (parent()-&gt;style().boxOrient() == BoxOrient::Horizontal || parent()-&gt;style().boxAlign() != BoxAlignment::Stretch))
2610         return true;
2611 
2612     // Button, input, select, textarea, and legend treat width value of &#39;auto&#39; as &#39;intrinsic&#39; unless it&#39;s in a
2613     // stretching column flexbox.
2614     // FIXME: Think about block-flow here.
2615     // https://bugs.webkit.org/show_bug.cgi?id=46473
2616     if (logicalWidth.type() == Auto &amp;&amp; !isStretchingColumnFlexItem() &amp;&amp; element() &amp;&amp; (is&lt;HTMLInputElement&gt;(*element()) || is&lt;HTMLSelectElement&gt;(*element()) || is&lt;HTMLButtonElement&gt;(*element()) || is&lt;HTMLTextAreaElement&gt;(*element()) || is&lt;HTMLLegendElement&gt;(*element())))
2617         return true;
2618 
2619     if (isHorizontalWritingMode() != containingBlock()-&gt;isHorizontalWritingMode())
2620         return true;
2621 
2622     return false;
2623 }
2624 
2625 void RenderBox::computeInlineDirectionMargins(const RenderBlock&amp; containingBlock, LayoutUnit containerWidth, LayoutUnit childWidth, LayoutUnit&amp; marginStart, LayoutUnit&amp; marginEnd) const
2626 {
2627 
2628     const RenderStyle&amp; containingBlockStyle = containingBlock.style();
2629     Length marginStartLength = style().marginStartUsing(&amp;containingBlockStyle);
2630     Length marginEndLength = style().marginEndUsing(&amp;containingBlockStyle);
2631 
2632     if (isFloating() || isInline()) {
2633         // Inline blocks/tables and floats don&#39;t have their margins increased.
2634         marginStart = minimumValueForLength(marginStartLength, containerWidth);
2635         marginEnd = minimumValueForLength(marginEndLength, containerWidth);
2636         return;
2637     }
2638 
2639     if (containingBlock.isFlexibleBox()) {
2640         // We need to let flexbox handle the margin adjustment - otherwise, flexbox
2641         // will think we&#39;re wider than we actually are and calculate line sizes
2642         // wrong. See also http://dev.w3.org/csswg/css-flexbox/#auto-margins
2643         if (marginStartLength.isAuto())
2644             marginStartLength = Length(0, Fixed);
2645         if (marginEndLength.isAuto())
2646             marginEndLength = Length(0, Fixed);
2647     }
2648 
2649     // Case One: The object is being centered in the containing block&#39;s available logical width.
2650     if ((marginStartLength.isAuto() &amp;&amp; marginEndLength.isAuto() &amp;&amp; childWidth &lt; containerWidth)
2651         || (!marginStartLength.isAuto() &amp;&amp; !marginEndLength.isAuto() &amp;&amp; containingBlock.style().textAlign() == TextAlignMode::WebKitCenter)) {
2652         // Other browsers center the margin box for align=center elements so we match them here.
2653         LayoutUnit marginStartWidth = minimumValueForLength(marginStartLength, containerWidth);
2654         LayoutUnit marginEndWidth = minimumValueForLength(marginEndLength, containerWidth);
2655         LayoutUnit centeredMarginBoxStart = std::max&lt;LayoutUnit&gt;(0, (containerWidth - childWidth - marginStartWidth - marginEndWidth) / 2);
2656         marginStart = centeredMarginBoxStart + marginStartWidth;
2657         marginEnd = containerWidth - childWidth - marginStart + marginEndWidth;
2658         return;
2659     }
2660 
2661     // Case Two: The object is being pushed to the start of the containing block&#39;s available logical width.
2662     if (marginEndLength.isAuto() &amp;&amp; childWidth &lt; containerWidth) {
2663         marginStart = valueForLength(marginStartLength, containerWidth);
2664         marginEnd = containerWidth - childWidth - marginStart;
2665         return;
2666     }
2667 
2668     // Case Three: The object is being pushed to the end of the containing block&#39;s available logical width.
2669     bool pushToEndFromTextAlign = !marginEndLength.isAuto() &amp;&amp; ((!containingBlockStyle.isLeftToRightDirection() &amp;&amp; containingBlockStyle.textAlign() == TextAlignMode::WebKitLeft)
2670         || (containingBlockStyle.isLeftToRightDirection() &amp;&amp; containingBlockStyle.textAlign() == TextAlignMode::WebKitRight));
2671     if ((marginStartLength.isAuto() || pushToEndFromTextAlign) &amp;&amp; childWidth &lt; containerWidth) {
2672         marginEnd = valueForLength(marginEndLength, containerWidth);
2673         marginStart = containerWidth - childWidth - marginEnd;
2674         return;
2675     }
2676 
2677     // Case Four: Either no auto margins, or our width is &gt;= the container width (css2.1, 10.3.3).  In that case
2678     // auto margins will just turn into 0.
2679     marginStart = minimumValueForLength(marginStartLength, containerWidth);
2680     marginEnd = minimumValueForLength(marginEndLength, containerWidth);
2681 }
2682 
2683 RenderBoxFragmentInfo* RenderBox::renderBoxFragmentInfo(RenderFragmentContainer* fragment, RenderBoxFragmentInfoFlags cacheFlag) const
2684 {
2685     // Make sure nobody is trying to call this with a null fragment.
2686     if (!fragment)
2687         return nullptr;
2688 
2689     // If we have computed our width in this fragment already, it will be cached, and we can
2690     // just return it.
2691     RenderBoxFragmentInfo* boxInfo = fragment-&gt;renderBoxFragmentInfo(this);
2692     if (boxInfo &amp;&amp; cacheFlag == CacheRenderBoxFragmentInfo)
2693         return boxInfo;
2694 
2695     return nullptr;
2696 }
2697 
2698 static bool shouldFlipBeforeAfterMargins(const RenderStyle&amp; containingBlockStyle, const RenderStyle* childStyle)
2699 {
2700     ASSERT(containingBlockStyle.isHorizontalWritingMode() != childStyle-&gt;isHorizontalWritingMode());
2701     WritingMode childWritingMode = childStyle-&gt;writingMode();
2702     bool shouldFlip = false;
2703     switch (containingBlockStyle.writingMode()) {
2704     case TopToBottomWritingMode:
2705         shouldFlip = (childWritingMode == RightToLeftWritingMode);
2706         break;
2707     case BottomToTopWritingMode:
2708         shouldFlip = (childWritingMode == RightToLeftWritingMode);
2709         break;
2710     case RightToLeftWritingMode:
2711         shouldFlip = (childWritingMode == BottomToTopWritingMode);
2712         break;
2713     case LeftToRightWritingMode:
2714         shouldFlip = (childWritingMode == BottomToTopWritingMode);
2715         break;
2716     }
2717 
2718     if (!containingBlockStyle.isLeftToRightDirection())
2719         shouldFlip = !shouldFlip;
2720 
2721     return shouldFlip;
2722 }
2723 
2724 void RenderBox::cacheIntrinsicContentLogicalHeightForFlexItem(LayoutUnit height) const
2725 {
2726     if (isFloatingOrOutOfFlowPositioned() || !parent() || !parent()-&gt;isFlexibleBox())
2727         return;
2728     downcast&lt;RenderFlexibleBox&gt;(parent())-&gt;setCachedChildIntrinsicContentLogicalHeight(*this, height);
2729 }
2730 
2731 void RenderBox::updateLogicalHeight()
2732 {
2733     cacheIntrinsicContentLogicalHeightForFlexItem(contentLogicalHeight());
2734     auto computedValues = computeLogicalHeight(logicalHeight(), logicalTop());
2735     setLogicalHeight(computedValues.m_extent);
2736     setLogicalTop(computedValues.m_position);
2737     setMarginBefore(computedValues.m_margins.m_before);
2738     setMarginAfter(computedValues.m_margins.m_after);
2739 }
2740 
2741 RenderBox::LogicalExtentComputedValues RenderBox::computeLogicalHeight(LayoutUnit logicalHeight, LayoutUnit logicalTop) const
2742 {
2743     LogicalExtentComputedValues computedValues;
2744     computedValues.m_extent = logicalHeight;
2745     computedValues.m_position = logicalTop;
2746 
2747     // Cell height is managed by the table and inline non-replaced elements do not support a height property.
2748     if (isTableCell() || (isInline() &amp;&amp; !isReplaced()))
2749         return computedValues;
2750 
2751     Length h;
2752     if (isOutOfFlowPositioned())
2753         computePositionedLogicalHeight(computedValues);
2754     else {
2755         RenderBlock&amp; cb = *containingBlock();
2756         bool hasPerpendicularContainingBlock = cb.isHorizontalWritingMode() != isHorizontalWritingMode();
2757 
2758         if (!hasPerpendicularContainingBlock) {
2759             bool shouldFlipBeforeAfter = cb.style().writingMode() != style().writingMode();
2760             computeBlockDirectionMargins(cb,
2761                 shouldFlipBeforeAfter ? computedValues.m_margins.m_after : computedValues.m_margins.m_before,
2762                 shouldFlipBeforeAfter ? computedValues.m_margins.m_before : computedValues.m_margins.m_after);
2763         }
2764 
2765         // For tables, calculate margins only.
2766         if (isTable()) {
2767             if (hasPerpendicularContainingBlock) {
2768                 bool shouldFlipBeforeAfter = shouldFlipBeforeAfterMargins(cb.style(), &amp;style());
2769                 computeInlineDirectionMargins(cb, containingBlockLogicalWidthForContent(), computedValues.m_extent,
2770                     shouldFlipBeforeAfter ? computedValues.m_margins.m_after : computedValues.m_margins.m_before,
2771                     shouldFlipBeforeAfter ? computedValues.m_margins.m_before : computedValues.m_margins.m_after);
2772             }
2773             return computedValues;
2774         }
2775 
2776         // FIXME: Account for block-flow in flexible boxes.
2777         // https://bugs.webkit.org/show_bug.cgi?id=46418
2778         bool inHorizontalBox = parent()-&gt;isDeprecatedFlexibleBox() &amp;&amp; parent()-&gt;style().boxOrient() == BoxOrient::Horizontal;
2779         bool stretching = parent()-&gt;style().boxAlign() == BoxAlignment::Stretch;
2780         bool treatAsReplaced = shouldComputeSizeAsReplaced() &amp;&amp; (!inHorizontalBox || !stretching);
2781         bool checkMinMaxHeight = false;
2782 
2783         // The parent box is flexing us, so it has increased or decreased our height.  We have to
2784         // grab our cached flexible height.
2785         // FIXME: Account for block-flow in flexible boxes.
2786         // https://bugs.webkit.org/show_bug.cgi?id=46418
2787         if (hasOverrideContentLogicalHeight() &amp;&amp; (parent()-&gt;isFlexibleBoxIncludingDeprecated() || parent()-&gt;isRenderGrid())) {
2788             h = Length(overrideContentLogicalHeight(), Fixed);
2789         } else if (treatAsReplaced)
2790             h = Length(computeReplacedLogicalHeight(), Fixed);
2791         else {
2792             h = style().logicalHeight();
2793             checkMinMaxHeight = true;
2794         }
2795 
2796         // Block children of horizontal flexible boxes fill the height of the box.
2797         // FIXME: Account for block-flow in flexible boxes.
2798         // https://bugs.webkit.org/show_bug.cgi?id=46418
2799         if (h.isAuto() &amp;&amp; is&lt;RenderDeprecatedFlexibleBox&gt;(*parent()) &amp;&amp; parent()-&gt;style().boxOrient() == BoxOrient::Horizontal
2800                 &amp;&amp; downcast&lt;RenderDeprecatedFlexibleBox&gt;(*parent()).isStretchingChildren()) {
2801             h = Length(parentBox()-&gt;contentLogicalHeight() - marginBefore() - marginAfter() - borderAndPaddingLogicalHeight(), Fixed);
2802             checkMinMaxHeight = false;
2803         }
2804 
2805         LayoutUnit heightResult;
2806         if (checkMinMaxHeight) {
2807             LayoutUnit intrinsicHeight = computedValues.m_extent - borderAndPaddingLogicalHeight();
2808             heightResult = computeLogicalHeightUsing(MainOrPreferredSize, style().logicalHeight(), intrinsicHeight).valueOr(computedValues.m_extent);
2809             heightResult = constrainLogicalHeightByMinMax(heightResult, intrinsicHeight);
2810         } else {
2811             // The only times we don&#39;t check min/max height are when a fixed length has
2812             // been given as an override.  Just use that.  The value has already been adjusted
2813             // for box-sizing.
2814             ASSERT(h.isFixed());
2815             heightResult = h.value() + borderAndPaddingLogicalHeight();
2816         }
2817 
2818         computedValues.m_extent = heightResult;
2819 
2820         if (hasPerpendicularContainingBlock) {
2821             bool shouldFlipBeforeAfter = shouldFlipBeforeAfterMargins(cb.style(), &amp;style());
2822             computeInlineDirectionMargins(cb, containingBlockLogicalWidthForContent(), heightResult,
2823                     shouldFlipBeforeAfter ? computedValues.m_margins.m_after : computedValues.m_margins.m_before,
2824                     shouldFlipBeforeAfter ? computedValues.m_margins.m_before : computedValues.m_margins.m_after);
2825         }
2826     }
2827 
2828     // WinIE quirk: The &lt;html&gt; block always fills the entire canvas in quirks mode.  The &lt;body&gt; always fills the
2829     // &lt;html&gt; block in quirks mode.  Only apply this quirk if the block is normal flow and no height
2830     // is specified. When we&#39;re printing, we also need this quirk if the body or root has a percentage
2831     // height since we don&#39;t set a height in RenderView when we&#39;re printing. So without this quirk, the
2832     // height has nothing to be a percentage of, and it ends up being 0. That is bad.
2833     bool paginatedContentNeedsBaseHeight = document().printing() &amp;&amp; h.isPercentOrCalculated()
2834         &amp;&amp; (isDocumentElementRenderer() || (isBody() &amp;&amp; document().documentElement()-&gt;renderer()-&gt;style().logicalHeight().isPercentOrCalculated())) &amp;&amp; !isInline();
2835     if (stretchesToViewport() || paginatedContentNeedsBaseHeight) {
2836         LayoutUnit margins = collapsedMarginBefore() + collapsedMarginAfter();
2837         LayoutUnit visibleHeight = view().pageOrViewLogicalHeight();
2838         if (isDocumentElementRenderer())
2839             computedValues.m_extent = std::max(computedValues.m_extent, visibleHeight - margins);
2840         else {
2841             LayoutUnit marginsBordersPadding = margins + parentBox()-&gt;marginBefore() + parentBox()-&gt;marginAfter() + parentBox()-&gt;borderAndPaddingLogicalHeight();
2842             computedValues.m_extent = std::max(computedValues.m_extent, visibleHeight - marginsBordersPadding);
2843         }
2844     }
2845     return computedValues;
2846 }
2847 
2848 LayoutUnit RenderBox::computeLogicalHeightWithoutLayout() const
2849 {
2850     // FIXME:: We should probably return something other than just
2851     // border + padding, but for now we have no good way to do anything else
2852     // without layout, so we just use that.
2853     LogicalExtentComputedValues computedValues = computeLogicalHeight(borderAndPaddingLogicalHeight(), 0_lu);
2854     return computedValues.m_extent;
2855 }
2856 
2857 Optional&lt;LayoutUnit&gt; RenderBox::computeLogicalHeightUsing(SizeType heightType, const Length&amp; height, Optional&lt;LayoutUnit&gt; intrinsicContentHeight) const
2858 {
2859     if (Optional&lt;LayoutUnit&gt; logicalHeight = computeContentAndScrollbarLogicalHeightUsing(heightType, height, intrinsicContentHeight))
2860         return adjustBorderBoxLogicalHeightForBoxSizing(logicalHeight.value());
2861     return WTF::nullopt;
2862 }
2863 
2864 Optional&lt;LayoutUnit&gt; RenderBox::computeContentLogicalHeight(SizeType heightType, const Length&amp; height, Optional&lt;LayoutUnit&gt; intrinsicContentHeight) const
2865 {
2866     if (Optional&lt;LayoutUnit&gt; heightIncludingScrollbar = computeContentAndScrollbarLogicalHeightUsing(heightType, height, intrinsicContentHeight))
2867         return std::max&lt;LayoutUnit&gt;(0, adjustContentBoxLogicalHeightForBoxSizing(heightIncludingScrollbar) - scrollbarLogicalHeight());
2868     return WTF::nullopt;
2869 }
2870 
2871 Optional&lt;LayoutUnit&gt; RenderBox::computeIntrinsicLogicalContentHeightUsing(Length logicalHeightLength, Optional&lt;LayoutUnit&gt; intrinsicContentHeight, LayoutUnit borderAndPadding) const
2872 {
2873     // FIXME: The CSS sizing spec is considering changing what min-content/max-content should resolve to.
2874     // If that happens, this code will have to change.
2875     if (logicalHeightLength.isMinContent() || logicalHeightLength.isMaxContent() || logicalHeightLength.isFitContent()) {
2876         if (!intrinsicContentHeight)
2877             return intrinsicContentHeight;
2878         if (style().boxSizing() == BoxSizing::BorderBox)
2879             return intrinsicContentHeight.value() + borderAndPaddingLogicalHeight();
2880         return intrinsicContentHeight;
2881     }
2882     if (logicalHeightLength.isFillAvailable())
2883         return containingBlock()-&gt;availableLogicalHeight(ExcludeMarginBorderPadding) - borderAndPadding;
2884     ASSERT_NOT_REACHED();
2885     return 0_lu;
2886 }
2887 
2888 Optional&lt;LayoutUnit&gt; RenderBox::computeContentAndScrollbarLogicalHeightUsing(SizeType heightType, const Length&amp; height, Optional&lt;LayoutUnit&gt; intrinsicContentHeight) const
2889 {
2890     if (height.isAuto())
2891         return heightType == MinSize ? Optional&lt;LayoutUnit&gt;(0) : WTF::nullopt;
2892     // FIXME: The CSS sizing spec is considering changing what min-content/max-content should resolve to.
2893     // If that happens, this code will have to change.
2894     if (height.isIntrinsic())
2895         return computeIntrinsicLogicalContentHeightUsing(height, intrinsicContentHeight, borderAndPaddingLogicalHeight());
2896     if (height.isFixed())
2897         return LayoutUnit(height.value());
2898     if (height.isPercentOrCalculated())
2899         return computePercentageLogicalHeight(height);
2900     return WTF::nullopt;
2901 }
2902 
2903 bool RenderBox::skipContainingBlockForPercentHeightCalculation(const RenderBox&amp; containingBlock, bool isPerpendicularWritingMode) const
2904 {
2905     // Flow threads for multicol or paged overflow should be skipped. They are invisible to the DOM,
2906     // and percent heights of children should be resolved against the multicol or paged container.
2907     if (containingBlock.isInFlowRenderFragmentedFlow() &amp;&amp; !isPerpendicularWritingMode)
2908         return true;
2909 
2910     // Render view is not considered auto height.
2911     if (is&lt;RenderView&gt;(containingBlock))
2912         return false;
2913 
2914     // If the writing mode of the containing block is orthogonal to ours, it means
2915     // that we shouldn&#39;t skip anything, since we&#39;re going to resolve the
2916     // percentage height against a containing block *width*.
2917     if (isPerpendicularWritingMode)
2918         return false;
2919 
2920     // Anonymous blocks should not impede percentage resolution on a child.
2921     // Examples of such anonymous blocks are blocks wrapped around inlines that
2922     // have block siblings (from the CSS spec) and multicol flow threads (an
2923     // implementation detail). Another implementation detail, ruby runs, create
2924     // anonymous inline-blocks, so skip those too. All other types of anonymous
2925     // objects, such as table-cells and flexboxes, will be treated as if they were
2926     // non-anonymous.
2927     if (containingBlock.isAnonymous())
2928         return containingBlock.style().display() == DisplayType::Block || containingBlock.style().display() == DisplayType::InlineBlock;
2929 
2930     // For quirks mode, we skip most auto-height containing blocks when computing
2931     // percentages.
2932     return document().inQuirksMode() &amp;&amp; !containingBlock.isTableCell() &amp;&amp; !containingBlock.isOutOfFlowPositioned() &amp;&amp; !containingBlock.isRenderGrid() &amp;&amp; containingBlock.style().logicalHeight().isAuto();
2933 }
2934 
2935 bool RenderBox::shouldTreatChildAsReplacedInTableCells() const
2936 {
2937     if (isReplaced())
2938         return true;
2939     return element() &amp;&amp; (element()-&gt;isFormControlElement() || is&lt;HTMLImageElement&gt;(element()));
2940 }
2941 
2942 static bool tableCellShouldHaveZeroInitialSize(const RenderBlock&amp; block, const RenderBox&amp; child, bool scrollsOverflowY)
2943 {
2944     // Normally we would let the cell size intrinsically, but scrolling overflow has to be
2945     // treated differently, since WinIE lets scrolled overflow fragments shrink as needed.
2946     // While we can&#39;t get all cases right, we can at least detect when the cell has a specified
2947     // height or when the table has a specified height. In these cases we want to initially have
2948     // no size and allow the flexing of the table or the cell to its specified height to cause us
2949     // to grow to fill the space. This could end up being wrong in some cases, but it is
2950     // preferable to the alternative (sizing intrinsically and making the row end up too big).
2951     const RenderTableCell&amp; cell = downcast&lt;RenderTableCell&gt;(block);
2952     return scrollsOverflowY &amp;&amp; !child.shouldTreatChildAsReplacedInTableCells() &amp;&amp; (!cell.style().logicalHeight().isAuto() || !cell.table()-&gt;style().logicalHeight().isAuto());
2953 }
2954 
2955 Optional&lt;LayoutUnit&gt; RenderBox::computePercentageLogicalHeight(const Length&amp; height) const
2956 {
2957     Optional&lt;LayoutUnit&gt; availableHeight;
2958 
2959     bool skippedAutoHeightContainingBlock = false;
2960     RenderBlock* cb = containingBlock();
2961     const RenderBox* containingBlockChild = this;
2962     LayoutUnit rootMarginBorderPaddingHeight;
2963     bool isHorizontal = isHorizontalWritingMode();
2964     while (cb &amp;&amp; !is&lt;RenderView&gt;(*cb) &amp;&amp; skipContainingBlockForPercentHeightCalculation(*cb, isHorizontal != cb-&gt;isHorizontalWritingMode())) {
2965         if (cb-&gt;isBody() || cb-&gt;isDocumentElementRenderer())
2966             rootMarginBorderPaddingHeight += cb-&gt;marginBefore() + cb-&gt;marginAfter() + cb-&gt;borderAndPaddingLogicalHeight();
2967         skippedAutoHeightContainingBlock = true;
2968         containingBlockChild = cb;
2969         cb = cb-&gt;containingBlock();
2970     }
2971     cb-&gt;addPercentHeightDescendant(const_cast&lt;RenderBox&amp;&gt;(*this));
2972 
2973     if (isHorizontal != cb-&gt;isHorizontalWritingMode())
2974         availableHeight = containingBlockChild-&gt;containingBlockLogicalWidthForContent();
2975     else if (hasOverrideContainingBlockContentLogicalHeight())
2976         availableHeight = overrideContainingBlockContentLogicalHeight();
2977     else if (is&lt;RenderTableCell&gt;(*cb)) {
2978         if (!skippedAutoHeightContainingBlock) {
2979             // Table cells violate what the CSS spec says to do with heights. Basically we
2980             // don&#39;t care if the cell specified a height or not. We just always make ourselves
2981             // be a percentage of the cell&#39;s current content height.
2982             if (!cb-&gt;hasOverrideContentLogicalHeight())
2983                 return tableCellShouldHaveZeroInitialSize(*cb, *this, scrollsOverflowY()) ? Optional&lt;LayoutUnit&gt;(0) : WTF::nullopt;
2984 
2985             availableHeight = cb-&gt;overrideContentLogicalHeight();
2986         }
2987     } else
2988         availableHeight = cb-&gt;availableLogicalHeightForPercentageComputation();
2989 
2990     if (!availableHeight)
2991         return availableHeight;
2992 
2993     LayoutUnit result = valueForLength(height, availableHeight.value() - rootMarginBorderPaddingHeight + (isTable() &amp;&amp; isOutOfFlowPositioned() ? cb-&gt;paddingBefore() + cb-&gt;paddingAfter() : 0_lu));
2994 
2995     // |overrideContentLogicalHeight| is the maximum height made available by the
2996     // cell to its percent height children when we decide they can determine the
2997     // height of the cell. If the percent height child is box-sizing:content-box
2998     // then we must subtract the border and padding from the cell&#39;s
2999     // |availableHeight| (given by |overrideContentLogicalHeight|) to arrive
3000     // at the child&#39;s computed height.
3001     bool subtractBorderAndPadding = isTable() || (is&lt;RenderTableCell&gt;(*cb) &amp;&amp; !skippedAutoHeightContainingBlock &amp;&amp; cb-&gt;hasOverrideContentLogicalHeight());
3002     if (subtractBorderAndPadding) {
3003         result -= borderAndPaddingLogicalHeight();
3004         return std::max(0_lu, result);
3005     }
3006     return result;
3007 }
3008 
3009 LayoutUnit RenderBox::computeReplacedLogicalWidth(ShouldComputePreferred shouldComputePreferred) const
3010 {
3011     return computeReplacedLogicalWidthRespectingMinMaxWidth(computeReplacedLogicalWidthUsing(MainOrPreferredSize, style().logicalWidth()), shouldComputePreferred);
3012 }
3013 
3014 LayoutUnit RenderBox::computeReplacedLogicalWidthRespectingMinMaxWidth(LayoutUnit logicalWidth, ShouldComputePreferred shouldComputePreferred) const
3015 {
3016     auto&amp; logicalMinWidth = style().logicalMinWidth();
3017     auto&amp; logicalMaxWidth = style().logicalMaxWidth();
3018     bool useLogicalWidthForMinWidth = (shouldComputePreferred == ComputePreferred &amp;&amp; logicalMinWidth.isPercentOrCalculated()) || logicalMinWidth.isUndefined();
3019     bool useLogicalWidthForMaxWidth = (shouldComputePreferred == ComputePreferred &amp;&amp; logicalMaxWidth.isPercentOrCalculated()) || logicalMaxWidth.isUndefined();
3020     auto minLogicalWidth =  useLogicalWidthForMinWidth ? logicalWidth : computeReplacedLogicalWidthUsing(MinSize, logicalMinWidth);
3021     auto maxLogicalWidth =  useLogicalWidthForMaxWidth ? logicalWidth : computeReplacedLogicalWidthUsing(MaxSize, logicalMaxWidth);
3022     return std::max(minLogicalWidth, std::min(logicalWidth, maxLogicalWidth));
3023 }
3024 
3025 LayoutUnit RenderBox::computeReplacedLogicalWidthUsing(SizeType widthType, Length logicalWidth) const
3026 {
3027     ASSERT(widthType == MinSize || widthType == MainOrPreferredSize || !logicalWidth.isAuto());
3028     if (widthType == MinSize &amp;&amp; logicalWidth.isAuto())
3029         return adjustContentBoxLogicalWidthForBoxSizing(0);
3030 
3031     switch (logicalWidth.type()) {
3032         case Fixed:
3033             return adjustContentBoxLogicalWidthForBoxSizing(logicalWidth.value());
3034         case MinContent:
3035         case MaxContent: {
3036             // MinContent/MaxContent don&#39;t need the availableLogicalWidth argument.
3037             LayoutUnit availableLogicalWidth;
3038             return computeIntrinsicLogicalWidthUsing(logicalWidth, availableLogicalWidth, borderAndPaddingLogicalWidth()) - borderAndPaddingLogicalWidth();
3039         }
3040         case FitContent:
3041         case FillAvailable:
3042         case Percent:
3043         case Calculated: {
3044             // FIXME: containingBlockLogicalWidthForContent() is wrong if the replaced element&#39;s block-flow is perpendicular to the
3045             // containing block&#39;s block-flow.
3046             // https://bugs.webkit.org/show_bug.cgi?id=46496
3047             const LayoutUnit cw = isOutOfFlowPositioned() ? containingBlockLogicalWidthForPositioned(downcast&lt;RenderBoxModelObject&gt;(*container())) : containingBlockLogicalWidthForContent();
3048             Length containerLogicalWidth = containingBlock()-&gt;style().logicalWidth();
3049             // FIXME: Handle cases when containing block width is calculated or viewport percent.
3050             // https://bugs.webkit.org/show_bug.cgi?id=91071
3051             if (logicalWidth.isIntrinsic())
3052                 return computeIntrinsicLogicalWidthUsing(logicalWidth, cw, borderAndPaddingLogicalWidth()) - borderAndPaddingLogicalWidth();
3053             if (cw &gt; 0 || (!cw &amp;&amp; (containerLogicalWidth.isFixed() || containerLogicalWidth.isPercentOrCalculated())))
3054                 return adjustContentBoxLogicalWidthForBoxSizing(minimumValueForLength(logicalWidth, cw));
3055             return 0_lu;
3056         }
3057         case Intrinsic:
3058         case MinIntrinsic:
3059         case Auto:
3060         case Relative:
3061         case Undefined:
3062             return intrinsicLogicalWidth();
3063     }
3064 
3065     ASSERT_NOT_REACHED();
3066     return 0;
3067 }
3068 
3069 LayoutUnit RenderBox::computeReplacedLogicalHeight(Optional&lt;LayoutUnit&gt;) const
3070 {
3071     return computeReplacedLogicalHeightRespectingMinMaxHeight(computeReplacedLogicalHeightUsing(MainOrPreferredSize, style().logicalHeight()));
3072 }
3073 
3074 static bool allowMinMaxPercentagesInAutoHeightBlocksQuirk()
3075 {
3076 #if PLATFORM(MAC)
3077     return MacApplication::isIBooks();
3078 #elif PLATFORM(IOS_FAMILY)
3079     return IOSApplication::isIBooks();
3080 #endif
3081     return false;
3082 }
3083 
3084 bool RenderBox::replacedMinMaxLogicalHeightComputesAsNone(SizeType sizeType) const
3085 {
3086     ASSERT(sizeType == MinSize || sizeType == MaxSize);
3087 
3088     auto logicalHeight = sizeType == MinSize ? style().logicalMinHeight() : style().logicalMaxHeight();
3089     auto initialLogicalHeight = sizeType == MinSize ? RenderStyle::initialMinSize() : RenderStyle::initialMaxSize();
3090 
3091     if (logicalHeight == initialLogicalHeight)
3092         return true;
3093 
3094     // Make sure % min-height and % max-height resolve to none if the containing block has auto height.
3095     // Note that the &quot;height&quot; case for replaced elements was handled by hasReplacedLogicalHeight, which is why
3096     // min and max-height are the only ones handled here.
3097     // FIXME: For now we put in a quirk for iBooks until we can move them to viewport units.
3098     if (auto* cb = containingBlockForAutoHeightDetection(logicalHeight))
3099         return allowMinMaxPercentagesInAutoHeightBlocksQuirk() ? false : cb-&gt;hasAutoHeightOrContainingBlockWithAutoHeight();
3100 
3101     return false;
3102 }
3103 
3104 LayoutUnit RenderBox::computeReplacedLogicalHeightRespectingMinMaxHeight(LayoutUnit logicalHeight) const
3105 {
3106     LayoutUnit minLogicalHeight;
3107     if (!replacedMinMaxLogicalHeightComputesAsNone(MinSize))
3108         minLogicalHeight = computeReplacedLogicalHeightUsing(MinSize, style().logicalMinHeight());
3109     LayoutUnit maxLogicalHeight = logicalHeight;
3110     if (!replacedMinMaxLogicalHeightComputesAsNone(MaxSize))
3111         maxLogicalHeight = computeReplacedLogicalHeightUsing(MaxSize, style().logicalMaxHeight());
3112     return std::max(minLogicalHeight, std::min(logicalHeight, maxLogicalHeight));
3113 }
3114 
3115 LayoutUnit RenderBox::computeReplacedLogicalHeightUsing(SizeType heightType, Length logicalHeight) const
3116 {
3117     ASSERT(heightType == MinSize || heightType == MainOrPreferredSize || !logicalHeight.isAuto());
3118     if (heightType == MinSize &amp;&amp; logicalHeight.isAuto())
3119         return adjustContentBoxLogicalHeightForBoxSizing(Optional&lt;LayoutUnit&gt;(0));
3120 
3121     switch (logicalHeight.type()) {
3122         case Fixed:
3123             return adjustContentBoxLogicalHeightForBoxSizing(LayoutUnit(logicalHeight.value()));
3124         case Percent:
3125         case Calculated:
3126         {
3127             auto* container = isOutOfFlowPositioned() ? this-&gt;container() : containingBlock();
3128             while (container &amp;&amp; container-&gt;isAnonymous()) {
3129                 // Stop at rendering context root.
3130                 if (is&lt;RenderView&gt;(*container))
3131                     break;
3132                 container = container-&gt;containingBlock();
3133             }
3134             Optional&lt;LayoutUnit&gt; stretchedHeight;
3135             if (is&lt;RenderBlock&gt;(container)) {
3136                 auto* block = downcast&lt;RenderBlock&gt;(container);
3137                 block-&gt;addPercentHeightDescendant(*const_cast&lt;RenderBox*&gt;(this));
3138                 if (block-&gt;isFlexItem())
3139                     stretchedHeight = downcast&lt;RenderFlexibleBox&gt;(block-&gt;parent())-&gt;childLogicalHeightForPercentageResolution(*block);
3140                 else if (block-&gt;isGridItem() &amp;&amp; block-&gt;hasOverrideContentLogicalHeight())
3141                     stretchedHeight = block-&gt;overrideContentLogicalHeight();
3142             }
3143 
3144             // FIXME: This calculation is not patched for block-flow yet.
3145             // https://bugs.webkit.org/show_bug.cgi?id=46500
3146             if (container-&gt;isOutOfFlowPositioned()
3147                 &amp;&amp; container-&gt;style().height().isAuto()
3148                 &amp;&amp; !(container-&gt;style().top().isAuto() || container-&gt;style().bottom().isAuto())) {
3149                 ASSERT_WITH_SECURITY_IMPLICATION(container-&gt;isRenderBlock());
3150                 auto&amp; block = downcast&lt;RenderBlock&gt;(*container);
3151                 auto computedValues = block.computeLogicalHeight(block.logicalHeight(), 0);
3152                 LayoutUnit newContentHeight = computedValues.m_extent - block.borderAndPaddingLogicalHeight() - block.scrollbarLogicalHeight();
3153                 return adjustContentBoxLogicalHeightForBoxSizing(valueForLength(logicalHeight, newContentHeight));
3154             }
3155 
3156             // FIXME: availableLogicalHeight() is wrong if the replaced element&#39;s block-flow is perpendicular to the
3157             // containing block&#39;s block-flow.
3158             // https://bugs.webkit.org/show_bug.cgi?id=46496
3159             LayoutUnit availableHeight;
3160             if (isOutOfFlowPositioned())
3161                 availableHeight = containingBlockLogicalHeightForPositioned(downcast&lt;RenderBoxModelObject&gt;(*container));
3162             else if (stretchedHeight)
3163                 availableHeight = stretchedHeight.value();
3164             else {
3165                 availableHeight = containingBlockLogicalHeightForContent(IncludeMarginBorderPadding);
3166                 // It is necessary to use the border-box to match WinIE&#39;s broken
3167                 // box model.  This is essential for sizing inside
3168                 // table cells using percentage heights.
3169                 // FIXME: This needs to be made block-flow-aware.  If the cell and image are perpendicular block-flows, this isn&#39;t right.
3170                 // https://bugs.webkit.org/show_bug.cgi?id=46997
3171                 while (container &amp;&amp; !is&lt;RenderView&gt;(*container)
3172                     &amp;&amp; (container-&gt;style().logicalHeight().isAuto() || container-&gt;style().logicalHeight().isPercentOrCalculated())) {
3173                     if (container-&gt;isTableCell()) {
3174                         // Don&#39;t let table cells squeeze percent-height replaced elements
3175                         // &lt;http://bugs.webkit.org/show_bug.cgi?id=15359&gt;
3176                         availableHeight = std::max(availableHeight, intrinsicLogicalHeight());
3177                         return valueForLength(logicalHeight, availableHeight - borderAndPaddingLogicalHeight());
3178                     }
3179                     downcast&lt;RenderBlock&gt;(*container).addPercentHeightDescendant(const_cast&lt;RenderBox&amp;&gt;(*this));
3180                     container = container-&gt;containingBlock();
3181                 }
3182             }
3183             return adjustContentBoxLogicalHeightForBoxSizing(valueForLength(logicalHeight, availableHeight));
3184         }
3185         case MinContent:
3186         case MaxContent:
3187         case FitContent:
3188         case FillAvailable:
3189             return adjustContentBoxLogicalHeightForBoxSizing(computeIntrinsicLogicalContentHeightUsing(logicalHeight, intrinsicLogicalHeight(), borderAndPaddingLogicalHeight()));
3190         default:
3191             return intrinsicLogicalHeight();
3192     }
3193 }
3194 
3195 LayoutUnit RenderBox::availableLogicalHeight(AvailableLogicalHeightType heightType) const
3196 {
3197     return constrainLogicalHeightByMinMax(availableLogicalHeightUsing(style().logicalHeight(), heightType), WTF::nullopt);
3198 }
3199 
3200 LayoutUnit RenderBox::availableLogicalHeightUsing(const Length&amp; h, AvailableLogicalHeightType heightType) const
3201 {
3202     // We need to stop here, since we don&#39;t want to increase the height of the table
3203     // artificially.  We&#39;re going to rely on this cell getting expanded to some new
3204     // height, and then when we lay out again we&#39;ll use the calculation below.
3205     if (isTableCell() &amp;&amp; (h.isAuto() || h.isPercentOrCalculated())) {
3206         if (hasOverrideContentLogicalHeight())
3207             return overrideContentLogicalHeight();
3208         return logicalHeight() - borderAndPaddingLogicalHeight();
3209     }
3210 
3211     if (isFlexItem()) {
3212         auto&amp; flexBox = downcast&lt;RenderFlexibleBox&gt;(*parent());
3213         auto stretchedHeight = flexBox.childLogicalHeightForPercentageResolution(*this);
3214         if (stretchedHeight)
3215             return stretchedHeight.value();
3216     }
3217 
3218     if (h.isPercentOrCalculated() &amp;&amp; isOutOfFlowPositioned() &amp;&amp; !isRenderFragmentedFlow()) {
3219         // FIXME: This is wrong if the containingBlock has a perpendicular writing mode.
3220         LayoutUnit availableHeight = containingBlockLogicalHeightForPositioned(*containingBlock());
3221         return adjustContentBoxLogicalHeightForBoxSizing(valueForLength(h, availableHeight));
3222     }
3223 
3224     if (Optional&lt;LayoutUnit&gt; heightIncludingScrollbar = computeContentAndScrollbarLogicalHeightUsing(MainOrPreferredSize, h, WTF::nullopt))
3225         return std::max&lt;LayoutUnit&gt;(0, adjustContentBoxLogicalHeightForBoxSizing(heightIncludingScrollbar) - scrollbarLogicalHeight());
3226 
3227     // FIXME: Check logicalTop/logicalBottom here to correctly handle vertical writing-mode.
3228     // https://bugs.webkit.org/show_bug.cgi?id=46500
3229     if (is&lt;RenderBlock&gt;(*this) &amp;&amp; isOutOfFlowPositioned() &amp;&amp; style().height().isAuto() &amp;&amp; !(style().top().isAuto() || style().bottom().isAuto())) {
3230         RenderBlock&amp; block = const_cast&lt;RenderBlock&amp;&gt;(downcast&lt;RenderBlock&gt;(*this));
3231         auto computedValues = block.computeLogicalHeight(block.logicalHeight(), 0);
3232         return computedValues.m_extent - block.borderAndPaddingLogicalHeight() - block.scrollbarLogicalHeight();
3233     }
3234 
3235     // FIXME: This is wrong if the containingBlock has a perpendicular writing mode.
3236     LayoutUnit availableHeight = containingBlockLogicalHeightForContent(heightType);
3237     if (heightType == ExcludeMarginBorderPadding) {
3238         // FIXME: Margin collapsing hasn&#39;t happened yet, so this incorrectly removes collapsed margins.
3239         availableHeight -= marginBefore() + marginAfter() + borderAndPaddingLogicalHeight();
3240     }
3241     return availableHeight;
3242 }
3243 
3244 void RenderBox::computeBlockDirectionMargins(const RenderBlock&amp; containingBlock, LayoutUnit&amp; marginBefore, LayoutUnit&amp; marginAfter) const
3245 {
3246     if (isTableCell()) {
3247         // FIXME: Not right if we allow cells to have different directionality than the table.  If we do allow this, though,
3248         // we may just do it with an extra anonymous block inside the cell.
3249         marginBefore = 0;
3250         marginAfter = 0;
3251         return;
3252     }
3253 
3254     // Margins are calculated with respect to the logical width of
3255     // the containing block (8.3)
3256     LayoutUnit cw = containingBlockLogicalWidthForContent();
3257     const RenderStyle&amp; containingBlockStyle = containingBlock.style();
3258     marginBefore = minimumValueForLength(style().marginBeforeUsing(&amp;containingBlockStyle), cw);
3259     marginAfter = minimumValueForLength(style().marginAfterUsing(&amp;containingBlockStyle), cw);
3260 }
3261 
3262 void RenderBox::computeAndSetBlockDirectionMargins(const RenderBlock&amp; containingBlock)
3263 {
3264     LayoutUnit marginBefore;
3265     LayoutUnit marginAfter;
3266     computeBlockDirectionMargins(containingBlock, marginBefore, marginAfter);
3267     containingBlock.setMarginBeforeForChild(*this, marginBefore);
3268     containingBlock.setMarginAfterForChild(*this, marginAfter);
3269 }
3270 
3271 LayoutUnit RenderBox::containingBlockLogicalWidthForPositioned(const RenderBoxModelObject&amp; containingBlock, RenderFragmentContainer* fragment, bool checkForPerpendicularWritingMode) const
3272 {
3273     if (checkForPerpendicularWritingMode &amp;&amp; containingBlock.isHorizontalWritingMode() != isHorizontalWritingMode())
3274         return containingBlockLogicalHeightForPositioned(containingBlock, false);
3275 
3276     if (hasOverrideContainingBlockContentLogicalWidth()) {
3277         if (auto overrideLogicalWidth = overrideContainingBlockContentLogicalWidth())
3278             return overrideLogicalWidth.value();
3279     }
3280 
3281     if (is&lt;RenderBox&gt;(containingBlock)) {
3282         bool isFixedPosition = isFixedPositioned();
3283 
3284         RenderFragmentedFlow* fragmentedFlow = enclosingFragmentedFlow();
3285         if (!fragmentedFlow) {
3286             if (isFixedPosition &amp;&amp; is&lt;RenderView&gt;(containingBlock))
3287                 return downcast&lt;RenderView&gt;(containingBlock).clientLogicalWidthForFixedPosition();
3288 
3289             return downcast&lt;RenderBox&gt;(containingBlock).clientLogicalWidth();
3290         }
3291 
3292         if (!is&lt;RenderBlock&gt;(containingBlock))
3293             return downcast&lt;RenderBox&gt;(containingBlock).clientLogicalWidth();
3294 
3295         const RenderBlock&amp; cb = downcast&lt;RenderBlock&gt;(containingBlock);
3296         RenderBoxFragmentInfo* boxInfo = nullptr;
3297         if (!fragment) {
3298             if (is&lt;RenderFragmentedFlow&gt;(containingBlock) &amp;&amp; !checkForPerpendicularWritingMode)
3299                 return downcast&lt;RenderFragmentedFlow&gt;(containingBlock).contentLogicalWidthOfFirstFragment();
3300             if (isWritingModeRoot()) {
3301                 LayoutUnit cbPageOffset = cb.offsetFromLogicalTopOfFirstPage();
3302                 RenderFragmentContainer* cbFragment = cb.fragmentAtBlockOffset(cbPageOffset);
3303                 if (cbFragment)
3304                     boxInfo = cb.renderBoxFragmentInfo(cbFragment);
3305             }
3306         } else if (fragmentedFlow-&gt;isHorizontalWritingMode() == containingBlock.isHorizontalWritingMode()) {
3307             RenderFragmentContainer* containingBlockFragment = cb.clampToStartAndEndFragments(fragment);
3308             boxInfo = cb.renderBoxFragmentInfo(containingBlockFragment);
3309         }
3310         return (boxInfo) ? std::max&lt;LayoutUnit&gt;(0, cb.clientLogicalWidth() - (cb.logicalWidth() - boxInfo-&gt;logicalWidth())) : cb.clientLogicalWidth();
3311     }
3312 
3313     ASSERT(containingBlock.isInFlowPositioned());
3314 
3315     const auto&amp; flow = downcast&lt;RenderInline&gt;(containingBlock);
3316     InlineFlowBox* first = flow.firstLineBox();
3317     InlineFlowBox* last = flow.lastLineBox();
3318 
3319     // If the containing block is empty, return a width of 0.
3320     if (!first || !last)
3321         return 0;
3322 
3323     LayoutUnit fromLeft;
3324     LayoutUnit fromRight;
3325     if (containingBlock.style().isLeftToRightDirection()) {
3326         fromLeft = first-&gt;logicalLeft() + first-&gt;borderLogicalLeft();
3327         fromRight = last-&gt;logicalLeft() + last-&gt;logicalWidth() - last-&gt;borderLogicalRight();
3328     } else {
3329         fromRight = first-&gt;logicalLeft() + first-&gt;logicalWidth() - first-&gt;borderLogicalRight();
3330         fromLeft = last-&gt;logicalLeft() + last-&gt;borderLogicalLeft();
3331     }
3332 
3333     return std::max&lt;LayoutUnit&gt;(0, fromRight - fromLeft);
3334 }
3335 
3336 LayoutUnit RenderBox::containingBlockLogicalHeightForPositioned(const RenderBoxModelObject&amp; containingBlock, bool checkForPerpendicularWritingMode) const
3337 {
3338     if (checkForPerpendicularWritingMode &amp;&amp; containingBlock.isHorizontalWritingMode() != isHorizontalWritingMode())
3339         return containingBlockLogicalWidthForPositioned(containingBlock, nullptr, false);
3340 
3341     if (hasOverrideContainingBlockContentLogicalHeight()) {
3342         if (auto overrideLogicalHeight = overrideContainingBlockContentLogicalHeight())
3343             return overrideLogicalHeight.value();
3344     }
3345 
3346     if (containingBlock.isBox()) {
3347         bool isFixedPosition = isFixedPositioned();
3348 
3349         if (isFixedPosition &amp;&amp; is&lt;RenderView&gt;(containingBlock))
3350             return downcast&lt;RenderView&gt;(containingBlock).clientLogicalHeightForFixedPosition();
3351 
3352         const RenderBlock&amp; cb = is&lt;RenderBlock&gt;(containingBlock) ? downcast&lt;RenderBlock&gt;(containingBlock) : *containingBlock.containingBlock();
3353         LayoutUnit result = cb.clientLogicalHeight();
3354         RenderFragmentedFlow* fragmentedFlow = enclosingFragmentedFlow();
3355         if (fragmentedFlow &amp;&amp; is&lt;RenderFragmentedFlow&gt;(containingBlock) &amp;&amp; fragmentedFlow-&gt;isHorizontalWritingMode() == containingBlock.isHorizontalWritingMode())
3356             return downcast&lt;RenderFragmentedFlow&gt;(containingBlock).contentLogicalHeightOfFirstFragment();
3357         return result;
3358     }
3359 
3360     ASSERT(containingBlock.isInFlowPositioned());
3361 
3362     const auto&amp; flow = downcast&lt;RenderInline&gt;(containingBlock);
3363     InlineFlowBox* first = flow.firstLineBox();
3364     InlineFlowBox* last = flow.lastLineBox();
3365 
3366     // If the containing block is empty, return a height of 0.
3367     if (!first || !last)
3368         return 0;
3369 
3370     LayoutUnit heightResult;
3371     LayoutRect boundingBox = flow.linesBoundingBox();
3372     if (containingBlock.isHorizontalWritingMode())
3373         heightResult = boundingBox.height();
3374     else
3375         heightResult = boundingBox.width();
3376     heightResult -= (containingBlock.borderBefore() + containingBlock.borderAfter());
3377     return heightResult;
3378 }
3379 
3380 static void computeInlineStaticDistance(Length&amp; logicalLeft, Length&amp; logicalRight, const RenderBox* child, const RenderBoxModelObject&amp; containerBlock, LayoutUnit containerLogicalWidth, RenderFragmentContainer* fragment)
3381 {
3382     if (!logicalLeft.isAuto() || !logicalRight.isAuto())
3383         return;
3384 
3385     RenderObject* parent = child-&gt;parent();
3386     TextDirection parentDirection = parent-&gt;style().direction();
3387 
3388     // This method is using enclosingBox() which is wrong for absolutely
3389     // positioned grid items, as they rely on the grid area. So for grid items if
3390     // both &quot;left&quot; and &quot;right&quot; properties are &quot;auto&quot;, we can consider that one of
3391     // them (depending on the direction) is simply &quot;0&quot;.
3392     if (parent-&gt;isRenderGrid() &amp;&amp; parent == child-&gt;containingBlock()) {
3393         if (parentDirection == TextDirection::LTR)
3394             logicalLeft.setValue(Fixed, 0);
3395         else
3396             logicalRight.setValue(Fixed, 0);
3397         return;
3398     }
3399 
3400     // FIXME: The static distance computation has not been patched for mixed writing modes yet.
3401     if (parentDirection == TextDirection::LTR) {
3402         LayoutUnit staticPosition = child-&gt;layer()-&gt;staticInlinePosition() - containerBlock.borderLogicalLeft();
3403         for (auto* current = parent; current &amp;&amp; current != &amp;containerBlock; current = current-&gt;container()) {
3404             if (!is&lt;RenderBox&gt;(*current))
3405                 continue;
3406             const auto&amp; renderBox = downcast&lt;RenderBox&gt;(*current);
3407             staticPosition += renderBox.logicalLeft();
3408             if (renderBox.isInFlowPositioned())
3409                 staticPosition += renderBox.isHorizontalWritingMode() ? renderBox.offsetForInFlowPosition().width() : renderBox.offsetForInFlowPosition().height();
3410             if (fragment &amp;&amp; is&lt;RenderBlock&gt;(*current)) {
3411                 const RenderBlock&amp; currentBlock = downcast&lt;RenderBlock&gt;(*current);
3412                 fragment = currentBlock.clampToStartAndEndFragments(fragment);
3413                 RenderBoxFragmentInfo* boxInfo = currentBlock.renderBoxFragmentInfo(fragment);
3414                 if (boxInfo)
3415                     staticPosition += boxInfo-&gt;logicalLeft();
3416             }
3417         }
3418         logicalLeft.setValue(Fixed, staticPosition);
3419     } else {
3420         LayoutUnit staticPosition = child-&gt;layer()-&gt;staticInlinePosition() + containerLogicalWidth + containerBlock.borderLogicalLeft();
3421         auto&amp; enclosingBox = parent-&gt;enclosingBox();
3422         if (&amp;enclosingBox != &amp;containerBlock &amp;&amp; containerBlock.isDescendantOf(&amp;enclosingBox)) {
3423             logicalRight.setValue(Fixed, staticPosition);
3424             return;
3425         }
3426 
3427         staticPosition -= enclosingBox.logicalWidth();
3428         for (const RenderElement* current = &amp;enclosingBox; current; current = current-&gt;container()) {
3429             if (!is&lt;RenderBox&gt;(*current))
3430                 continue;
3431 
3432             if (current != &amp;containerBlock) {
3433                 auto&amp; renderBox = downcast&lt;RenderBox&gt;(*current);
3434                 staticPosition -= renderBox.logicalLeft();
3435                 if (renderBox.isInFlowPositioned())
3436                     staticPosition -= renderBox.isHorizontalWritingMode() ? renderBox.offsetForInFlowPosition().width() : renderBox.offsetForInFlowPosition().height();
3437             }
3438             if (fragment &amp;&amp; is&lt;RenderBlock&gt;(*current)) {
3439                 auto&amp; currentBlock = downcast&lt;RenderBlock&gt;(*current);
3440                 fragment = currentBlock.clampToStartAndEndFragments(fragment);
3441                 RenderBoxFragmentInfo* boxInfo = currentBlock.renderBoxFragmentInfo(fragment);
3442                 if (boxInfo) {
3443                     if (current != &amp;containerBlock)
3444                         staticPosition -= currentBlock.logicalWidth() - (boxInfo-&gt;logicalLeft() + boxInfo-&gt;logicalWidth());
3445                     if (current == &amp;enclosingBox)
3446                         staticPosition += enclosingBox.logicalWidth() - boxInfo-&gt;logicalWidth();
3447                 }
3448             }
3449             if (current == &amp;containerBlock)
3450                 break;
3451         }
3452         logicalRight.setValue(Fixed, staticPosition);
3453     }
3454 }
3455 
3456 void RenderBox::computePositionedLogicalWidth(LogicalExtentComputedValues&amp; computedValues, RenderFragmentContainer* fragment) const
3457 {
3458     if (isReplaced()) {
3459         // FIXME: Positioned replaced elements inside a flow thread are not working properly
3460         // with variable width fragments (see https://bugs.webkit.org/show_bug.cgi?id=69896 ).
3461         computePositionedLogicalWidthReplaced(computedValues);
3462         return;
3463     }
3464 
3465     // QUESTIONS
3466     // FIXME 1: Should we still deal with these the cases of &#39;left&#39; or &#39;right&#39; having
3467     // the type &#39;static&#39; in determining whether to calculate the static distance?
3468     // NOTE: &#39;static&#39; is not a legal value for &#39;left&#39; or &#39;right&#39; as of CSS 2.1.
3469 
3470     // FIXME 2: Can perhaps optimize out cases when max-width/min-width are greater
3471     // than or less than the computed width().  Be careful of box-sizing and
3472     // percentage issues.
3473 
3474     // The following is based off of the W3C Working Draft from April 11, 2006 of
3475     // CSS 2.1: Section 10.3.7 &quot;Absolutely positioned, non-replaced elements&quot;
3476     // &lt;http://www.w3.org/TR/CSS21/visudet.html#abs-non-replaced-width&gt;
3477     // (block-style-comments in this function and in computePositionedLogicalWidthUsing()
3478     // correspond to text from the spec)
3479 
3480 
3481     // We don&#39;t use containingBlock(), since we may be positioned by an enclosing
3482     // relative positioned inline.
3483     const RenderBoxModelObject&amp; containerBlock = downcast&lt;RenderBoxModelObject&gt;(*container());
3484 
3485     const LayoutUnit containerLogicalWidth = containingBlockLogicalWidthForPositioned(containerBlock, fragment);
3486 
3487     // Use the container block&#39;s direction except when calculating the static distance
3488     // This conforms with the reference results for abspos-replaced-width-margin-000.htm
3489     // of the CSS 2.1 test suite
3490     TextDirection containerDirection = containerBlock.style().direction();
3491 
3492     bool isHorizontal = isHorizontalWritingMode();
3493     const LayoutUnit bordersPlusPadding = borderAndPaddingLogicalWidth();
3494     const Length marginLogicalLeft = isHorizontal ? style().marginLeft() : style().marginTop();
3495     const Length marginLogicalRight = isHorizontal ? style().marginRight() : style().marginBottom();
3496 
3497     Length logicalLeftLength = style().logicalLeft();
3498     Length logicalRightLength = style().logicalRight();
3499 
3500     /*---------------------------------------------------------------------------*\
3501      * For the purposes of this section and the next, the term &quot;static position&quot;
3502      * (of an element) refers, roughly, to the position an element would have had
3503      * in the normal flow. More precisely:
3504      *
3505      * * The static position for &#39;left&#39; is the distance from the left edge of the
3506      *   containing block to the left margin edge of a hypothetical box that would
3507      *   have been the first box of the element if its &#39;position&#39; property had
3508      *   been &#39;static&#39; and &#39;float&#39; had been &#39;none&#39;. The value is negative if the
3509      *   hypothetical box is to the left of the containing block.
3510      * * The static position for &#39;right&#39; is the distance from the right edge of the
3511      *   containing block to the right margin edge of the same hypothetical box as
3512      *   above. The value is positive if the hypothetical box is to the left of the
3513      *   containing block&#39;s edge.
3514      *
3515      * But rather than actually calculating the dimensions of that hypothetical box,
3516      * user agents are free to make a guess at its probable position.
3517      *
3518      * For the purposes of calculating the static position, the containing block of
3519      * fixed positioned elements is the initial containing block instead of the
3520      * viewport, and all scrollable boxes should be assumed to be scrolled to their
3521      * origin.
3522     \*---------------------------------------------------------------------------*/
3523 
3524     // see FIXME 1
3525     // Calculate the static distance if needed.
3526     computeInlineStaticDistance(logicalLeftLength, logicalRightLength, this, containerBlock, containerLogicalWidth, fragment);
3527 
3528     // Calculate constraint equation values for &#39;width&#39; case.
3529     computePositionedLogicalWidthUsing(MainOrPreferredSize, style().logicalWidth(), containerBlock, containerDirection,
3530                                        containerLogicalWidth, bordersPlusPadding,
3531                                        logicalLeftLength, logicalRightLength, marginLogicalLeft, marginLogicalRight,
3532                                        computedValues);
3533 
3534     // Calculate constraint equation values for &#39;max-width&#39; case.
3535     if (!style().logicalMaxWidth().isUndefined()) {
3536         LogicalExtentComputedValues maxValues;
3537 
3538         computePositionedLogicalWidthUsing(MaxSize, style().logicalMaxWidth(), containerBlock, containerDirection,
3539                                            containerLogicalWidth, bordersPlusPadding,
3540                                            logicalLeftLength, logicalRightLength, marginLogicalLeft, marginLogicalRight,
3541                                            maxValues);
3542 
3543         if (computedValues.m_extent &gt; maxValues.m_extent) {
3544             computedValues.m_extent = maxValues.m_extent;
3545             computedValues.m_position = maxValues.m_position;
3546             computedValues.m_margins.m_start = maxValues.m_margins.m_start;
3547             computedValues.m_margins.m_end = maxValues.m_margins.m_end;
3548         }
3549     }
3550 
3551     // Calculate constraint equation values for &#39;min-width&#39; case.
3552     if (!style().logicalMinWidth().isZero() || style().logicalMinWidth().isIntrinsic()) {
3553         LogicalExtentComputedValues minValues;
3554 
3555         computePositionedLogicalWidthUsing(MinSize, style().logicalMinWidth(), containerBlock, containerDirection,
3556                                            containerLogicalWidth, bordersPlusPadding,
3557                                            logicalLeftLength, logicalRightLength, marginLogicalLeft, marginLogicalRight,
3558                                            minValues);
3559 
3560         if (computedValues.m_extent &lt; minValues.m_extent) {
3561             computedValues.m_extent = minValues.m_extent;
3562             computedValues.m_position = minValues.m_position;
3563             computedValues.m_margins.m_start = minValues.m_margins.m_start;
3564             computedValues.m_margins.m_end = minValues.m_margins.m_end;
3565         }
3566     }
3567 
3568     computedValues.m_extent += bordersPlusPadding;
3569     if (is&lt;RenderBox&gt;(containerBlock)) {
3570         auto&amp; containingBox = downcast&lt;RenderBox&gt;(containerBlock);
3571         if (containingBox.shouldPlaceBlockDirectionScrollbarOnLeft())
3572             computedValues.m_position += containingBox.verticalScrollbarWidth();
3573     }
3574 
3575     // Adjust logicalLeft if we need to for the flipped version of our writing mode in fragments.
3576     // FIXME: Add support for other types of objects as containerBlock, not only RenderBlock.
3577     RenderFragmentedFlow* fragmentedFlow = enclosingFragmentedFlow();
3578     if (fragmentedFlow &amp;&amp; !fragment &amp;&amp; isWritingModeRoot() &amp;&amp; isHorizontalWritingMode() == containerBlock.isHorizontalWritingMode() &amp;&amp; is&lt;RenderBlock&gt;(containerBlock)) {
3579         ASSERT(containerBlock.canHaveBoxInfoInFragment());
3580         LayoutUnit logicalLeftPos = computedValues.m_position;
3581         const RenderBlock&amp; renderBlock = downcast&lt;RenderBlock&gt;(containerBlock);
3582         LayoutUnit cbPageOffset = renderBlock.offsetFromLogicalTopOfFirstPage();
3583         RenderFragmentContainer* cbFragment = renderBlock.fragmentAtBlockOffset(cbPageOffset);
3584         if (cbFragment) {
3585             RenderBoxFragmentInfo* boxInfo = renderBlock.renderBoxFragmentInfo(cbFragment);
3586             if (boxInfo) {
3587                 logicalLeftPos += boxInfo-&gt;logicalLeft();
3588                 computedValues.m_position = logicalLeftPos;
3589             }
3590         }
3591     }
3592 }
3593 
3594 static void computeLogicalLeftPositionedOffset(LayoutUnit&amp; logicalLeftPos, const RenderBox* child, LayoutUnit logicalWidthValue, const RenderBoxModelObject&amp; containerBlock, LayoutUnit containerLogicalWidth)
3595 {
3596     // Deal with differing writing modes here.  Our offset needs to be in the containing block&#39;s coordinate space. If the containing block is flipped
3597     // along this axis, then we need to flip the coordinate.  This can only happen if the containing block is both a flipped mode and perpendicular to us.
3598     if (containerBlock.isHorizontalWritingMode() != child-&gt;isHorizontalWritingMode() &amp;&amp; containerBlock.style().isFlippedBlocksWritingMode()) {
3599         logicalLeftPos = containerLogicalWidth - logicalWidthValue - logicalLeftPos;
3600         logicalLeftPos += (child-&gt;isHorizontalWritingMode() ? containerBlock.borderRight() : containerBlock.borderBottom());
3601     } else
3602         logicalLeftPos += (child-&gt;isHorizontalWritingMode() ? containerBlock.borderLeft() : containerBlock.borderTop());
3603 }
3604 
3605 void RenderBox::computePositionedLogicalWidthUsing(SizeType widthType, Length logicalWidth, const RenderBoxModelObject&amp; containerBlock, TextDirection containerDirection,
3606                                                    LayoutUnit containerLogicalWidth, LayoutUnit bordersPlusPadding,
3607                                                    Length logicalLeft, Length logicalRight, Length marginLogicalLeft, Length marginLogicalRight,
3608                                                    LogicalExtentComputedValues&amp; computedValues) const
3609 {
3610     ASSERT(widthType == MinSize || widthType == MainOrPreferredSize || !logicalWidth.isAuto());
3611     if (widthType == MinSize &amp;&amp; logicalWidth.isAuto())
3612         logicalWidth = Length(0, Fixed);
3613     else if (logicalWidth.isIntrinsic())
3614         logicalWidth = Length(computeIntrinsicLogicalWidthUsing(logicalWidth, containerLogicalWidth, bordersPlusPadding) - bordersPlusPadding, Fixed);
3615 
3616     // &#39;left&#39; and &#39;right&#39; cannot both be &#39;auto&#39; because one would of been
3617     // converted to the static position already
3618     ASSERT(!(logicalLeft.isAuto() &amp;&amp; logicalRight.isAuto()));
3619 
3620     LayoutUnit logicalLeftValue;
3621 
3622     const LayoutUnit containerRelativeLogicalWidth = containingBlockLogicalWidthForPositioned(containerBlock, nullptr, false);
3623 
3624     bool logicalWidthIsAuto = logicalWidth.isIntrinsicOrAuto();
3625     bool logicalLeftIsAuto = logicalLeft.isAuto();
3626     bool logicalRightIsAuto = logicalRight.isAuto();
3627     LayoutUnit&amp; marginLogicalLeftValue = style().isLeftToRightDirection() ? computedValues.m_margins.m_start : computedValues.m_margins.m_end;
3628     LayoutUnit&amp; marginLogicalRightValue = style().isLeftToRightDirection() ? computedValues.m_margins.m_end : computedValues.m_margins.m_start;
3629 
3630     if (!logicalLeftIsAuto &amp;&amp; !logicalWidthIsAuto &amp;&amp; !logicalRightIsAuto) {
3631         /*-----------------------------------------------------------------------*\
3632          * If none of the three is &#39;auto&#39;: If both &#39;margin-left&#39; and &#39;margin-
3633          * right&#39; are &#39;auto&#39;, solve the equation under the extra constraint that
3634          * the two margins get equal values, unless this would make them negative,
3635          * in which case when direction of the containing block is &#39;ltr&#39; (&#39;rtl&#39;),
3636          * set &#39;margin-left&#39; (&#39;margin-right&#39;) to zero and solve for &#39;margin-right&#39;
3637          * (&#39;margin-left&#39;). If one of &#39;margin-left&#39; or &#39;margin-right&#39; is &#39;auto&#39;,
3638          * solve the equation for that value. If the values are over-constrained,
3639          * ignore the value for &#39;left&#39; (in case the &#39;direction&#39; property of the
3640          * containing block is &#39;rtl&#39;) or &#39;right&#39; (in case &#39;direction&#39; is &#39;ltr&#39;)
3641          * and solve for that value.
3642         \*-----------------------------------------------------------------------*/
3643         // NOTE:  It is not necessary to solve for &#39;right&#39; in the over constrained
3644         // case because the value is not used for any further calculations.
3645 
3646         logicalLeftValue = valueForLength(logicalLeft, containerLogicalWidth);
3647         computedValues.m_extent = adjustContentBoxLogicalWidthForBoxSizing(valueForLength(logicalWidth, containerLogicalWidth));
3648 
3649         const LayoutUnit availableSpace = containerLogicalWidth - (logicalLeftValue + computedValues.m_extent + valueForLength(logicalRight, containerLogicalWidth) + bordersPlusPadding);
3650 
3651         // Margins are now the only unknown
3652         if (marginLogicalLeft.isAuto() &amp;&amp; marginLogicalRight.isAuto()) {
3653             // Both margins auto, solve for equality
3654             if (availableSpace &gt;= 0) {
3655                 marginLogicalLeftValue = availableSpace / 2; // split the difference
3656                 marginLogicalRightValue = availableSpace - marginLogicalLeftValue; // account for odd valued differences
3657             } else {
3658                 // Use the containing block&#39;s direction rather than the parent block&#39;s
3659                 // per CSS 2.1 reference test abspos-non-replaced-width-margin-000.
3660                 if (containerDirection == TextDirection::LTR) {
3661                     marginLogicalLeftValue = 0;
3662                     marginLogicalRightValue = availableSpace; // will be negative
3663                 } else {
3664                     marginLogicalLeftValue = availableSpace; // will be negative
3665                     marginLogicalRightValue = 0;
3666                 }
3667             }
3668         } else if (marginLogicalLeft.isAuto()) {
3669             // Solve for left margin
3670             marginLogicalRightValue = valueForLength(marginLogicalRight, containerRelativeLogicalWidth);
3671             marginLogicalLeftValue = availableSpace - marginLogicalRightValue;
3672         } else if (marginLogicalRight.isAuto()) {
3673             // Solve for right margin
3674             marginLogicalLeftValue = valueForLength(marginLogicalLeft, containerRelativeLogicalWidth);
3675             marginLogicalRightValue = availableSpace - marginLogicalLeftValue;
3676         } else {
3677             // Over-constrained, solve for left if direction is RTL
3678             marginLogicalLeftValue = valueForLength(marginLogicalLeft, containerRelativeLogicalWidth);
3679             marginLogicalRightValue = valueForLength(marginLogicalRight, containerRelativeLogicalWidth);
3680 
3681             // Use the containing block&#39;s direction rather than the parent block&#39;s
3682             // per CSS 2.1 reference test abspos-non-replaced-width-margin-000.
3683             if (containerDirection == TextDirection::RTL)
3684                 logicalLeftValue = (availableSpace + logicalLeftValue) - marginLogicalLeftValue - marginLogicalRightValue;
3685         }
3686     } else {
3687         /*--------------------------------------------------------------------*\
3688          * Otherwise, set &#39;auto&#39; values for &#39;margin-left&#39; and &#39;margin-right&#39;
3689          * to 0, and pick the one of the following six rules that applies.
3690          *
3691          * 1. &#39;left&#39; and &#39;width&#39; are &#39;auto&#39; and &#39;right&#39; is not &#39;auto&#39;, then the
3692          *    width is shrink-to-fit. Then solve for &#39;left&#39;
3693          *
3694          *              OMIT RULE 2 AS IT SHOULD NEVER BE HIT
3695          * ------------------------------------------------------------------
3696          * 2. &#39;left&#39; and &#39;right&#39; are &#39;auto&#39; and &#39;width&#39; is not &#39;auto&#39;, then if
3697          *    the &#39;direction&#39; property of the containing block is &#39;ltr&#39; set
3698          *    &#39;left&#39; to the static position, otherwise set &#39;right&#39; to the
3699          *    static position. Then solve for &#39;left&#39; (if &#39;direction is &#39;rtl&#39;)
3700          *    or &#39;right&#39; (if &#39;direction&#39; is &#39;ltr&#39;).
3701          * ------------------------------------------------------------------
3702          *
3703          * 3. &#39;width&#39; and &#39;right&#39; are &#39;auto&#39; and &#39;left&#39; is not &#39;auto&#39;, then the
3704          *    width is shrink-to-fit . Then solve for &#39;right&#39;
3705          * 4. &#39;left&#39; is &#39;auto&#39;, &#39;width&#39; and &#39;right&#39; are not &#39;auto&#39;, then solve
3706          *    for &#39;left&#39;
3707          * 5. &#39;width&#39; is &#39;auto&#39;, &#39;left&#39; and &#39;right&#39; are not &#39;auto&#39;, then solve
3708          *    for &#39;width&#39;
3709          * 6. &#39;right&#39; is &#39;auto&#39;, &#39;left&#39; and &#39;width&#39; are not &#39;auto&#39;, then solve
3710          *    for &#39;right&#39;
3711          *
3712          * Calculation of the shrink-to-fit width is similar to calculating the
3713          * width of a table cell using the automatic table layout algorithm.
3714          * Roughly: calculate the preferred width by formatting the content
3715          * without breaking lines other than where explicit line breaks occur,
3716          * and also calculate the preferred minimum width, e.g., by trying all
3717          * possible line breaks. CSS 2.1 does not define the exact algorithm.
3718          * Thirdly, calculate the available width: this is found by solving
3719          * for &#39;width&#39; after setting &#39;left&#39; (in case 1) or &#39;right&#39; (in case 3)
3720          * to 0.
3721          *
3722          * Then the shrink-to-fit width is:
3723          * min(max(preferred minimum width, available width), preferred width).
3724         \*--------------------------------------------------------------------*/
3725         // NOTE: For rules 3 and 6 it is not necessary to solve for &#39;right&#39;
3726         // because the value is not used for any further calculations.
3727 
3728         // Calculate margins, &#39;auto&#39; margins are ignored.
3729         marginLogicalLeftValue = minimumValueForLength(marginLogicalLeft, containerRelativeLogicalWidth);
3730         marginLogicalRightValue = minimumValueForLength(marginLogicalRight, containerRelativeLogicalWidth);
3731 
3732         const LayoutUnit availableSpace = containerLogicalWidth - (marginLogicalLeftValue + marginLogicalRightValue + bordersPlusPadding);
3733 
3734         // FIXME: Is there a faster way to find the correct case?
3735         // Use rule/case that applies.
3736         if (logicalLeftIsAuto &amp;&amp; logicalWidthIsAuto &amp;&amp; !logicalRightIsAuto) {
3737             // RULE 1: (use shrink-to-fit for width, and solve of left)
3738             LayoutUnit logicalRightValue = valueForLength(logicalRight, containerLogicalWidth);
3739 
3740             // FIXME: would it be better to have shrink-to-fit in one step?
3741             LayoutUnit preferredWidth = maxPreferredLogicalWidth() - bordersPlusPadding;
3742             LayoutUnit preferredMinWidth = minPreferredLogicalWidth() - bordersPlusPadding;
3743             LayoutUnit availableWidth = availableSpace - logicalRightValue;
3744             computedValues.m_extent = std::min(std::max(preferredMinWidth, availableWidth), preferredWidth);
3745             logicalLeftValue = availableSpace - (computedValues.m_extent + logicalRightValue);
3746         } else if (!logicalLeftIsAuto &amp;&amp; logicalWidthIsAuto &amp;&amp; logicalRightIsAuto) {
3747             // RULE 3: (use shrink-to-fit for width, and no need solve of right)
3748             logicalLeftValue = valueForLength(logicalLeft, containerLogicalWidth);
3749 
3750             // FIXME: would it be better to have shrink-to-fit in one step?
3751             LayoutUnit preferredWidth = maxPreferredLogicalWidth() - bordersPlusPadding;
3752             LayoutUnit preferredMinWidth = minPreferredLogicalWidth() - bordersPlusPadding;
3753             LayoutUnit availableWidth = availableSpace - logicalLeftValue;
3754             computedValues.m_extent = std::min(std::max(preferredMinWidth, availableWidth), preferredWidth);
3755         } else if (logicalLeftIsAuto &amp;&amp; !logicalWidthIsAuto &amp;&amp; !logicalRightIsAuto) {
3756             // RULE 4: (solve for left)
3757             computedValues.m_extent = adjustContentBoxLogicalWidthForBoxSizing(valueForLength(logicalWidth, containerLogicalWidth));
3758             logicalLeftValue = availableSpace - (computedValues.m_extent + valueForLength(logicalRight, containerLogicalWidth));
3759         } else if (!logicalLeftIsAuto &amp;&amp; logicalWidthIsAuto &amp;&amp; !logicalRightIsAuto) {
3760             // RULE 5: (solve for width)
3761             logicalLeftValue = valueForLength(logicalLeft, containerLogicalWidth);
3762             computedValues.m_extent = availableSpace - (logicalLeftValue + valueForLength(logicalRight, containerLogicalWidth));
3763         } else if (!logicalLeftIsAuto &amp;&amp; !logicalWidthIsAuto &amp;&amp; logicalRightIsAuto) {
3764             // RULE 6: (no need solve for right)
3765             logicalLeftValue = valueForLength(logicalLeft, containerLogicalWidth);
3766             computedValues.m_extent = adjustContentBoxLogicalWidthForBoxSizing(valueForLength(logicalWidth, containerLogicalWidth));
3767         }
3768     }
3769 
3770     // Use computed values to calculate the horizontal position.
3771 
3772     // FIXME: This hack is needed to calculate the  logical left position for a &#39;rtl&#39; relatively
3773     // positioned, inline because right now, it is using the logical left position
3774     // of the first line box when really it should use the last line box.  When
3775     // this is fixed elsewhere, this block should be removed.
3776     if (is&lt;RenderInline&gt;(containerBlock) &amp;&amp; !containerBlock.style().isLeftToRightDirection()) {
3777         const auto&amp; flow = downcast&lt;RenderInline&gt;(containerBlock);
3778         InlineFlowBox* firstLine = flow.firstLineBox();
3779         InlineFlowBox* lastLine = flow.lastLineBox();
3780         if (firstLine &amp;&amp; lastLine &amp;&amp; firstLine != lastLine) {
3781             computedValues.m_position = logicalLeftValue + marginLogicalLeftValue + lastLine-&gt;borderLogicalLeft() + (lastLine-&gt;logicalLeft() - firstLine-&gt;logicalLeft());
3782             return;
3783         }
3784     }
3785 
3786     computedValues.m_position = logicalLeftValue + marginLogicalLeftValue;
3787     computeLogicalLeftPositionedOffset(computedValues.m_position, this, computedValues.m_extent, containerBlock, containerLogicalWidth);
3788 }
3789 
3790 static void computeBlockStaticDistance(Length&amp; logicalTop, Length&amp; logicalBottom, const RenderBox* child, const RenderBoxModelObject&amp; containerBlock)
3791 {
3792     if (!logicalTop.isAuto() || !logicalBottom.isAuto())
3793         return;
3794 
3795     // FIXME: The static distance computation has not been patched for mixed writing modes.
3796     LayoutUnit staticLogicalTop = child-&gt;layer()-&gt;staticBlockPosition() - containerBlock.borderBefore();
3797     for (RenderElement* container = child-&gt;parent(); container &amp;&amp; container != &amp;containerBlock; container = container-&gt;container()) {
3798         if (!is&lt;RenderBox&gt;(*container))
3799             continue;
3800         const auto&amp; renderBox = downcast&lt;RenderBox&gt;(*container);
3801         if (!is&lt;RenderTableRow&gt;(renderBox))
3802             staticLogicalTop += renderBox.logicalTop();
3803         if (renderBox.isInFlowPositioned())
3804             staticLogicalTop += renderBox.isHorizontalWritingMode() ? renderBox.offsetForInFlowPosition().height() : renderBox.offsetForInFlowPosition().width();
3805     }
3806     logicalTop.setValue(Fixed, staticLogicalTop);
3807 }
3808 
3809 void RenderBox::computePositionedLogicalHeight(LogicalExtentComputedValues&amp; computedValues) const
3810 {
3811     if (isReplaced()) {
3812         computePositionedLogicalHeightReplaced(computedValues);
3813         return;
3814     }
3815 
3816     // The following is based off of the W3C Working Draft from April 11, 2006 of
3817     // CSS 2.1: Section 10.6.4 &quot;Absolutely positioned, non-replaced elements&quot;
3818     // &lt;http://www.w3.org/TR/2005/WD-CSS21-20050613/visudet.html#abs-non-replaced-height&gt;
3819     // (block-style-comments in this function and in computePositionedLogicalHeightUsing()
3820     // correspond to text from the spec)
3821 
3822 
3823     // We don&#39;t use containingBlock(), since we may be positioned by an enclosing relpositioned inline.
3824     const RenderBoxModelObject&amp; containerBlock = downcast&lt;RenderBoxModelObject&gt;(*container());
3825 
3826     const LayoutUnit containerLogicalHeight = containingBlockLogicalHeightForPositioned(containerBlock);
3827 
3828     const RenderStyle&amp; styleToUse = style();
3829     const LayoutUnit bordersPlusPadding = borderAndPaddingLogicalHeight();
3830     const Length marginBefore = styleToUse.marginBefore();
3831     const Length marginAfter = styleToUse.marginAfter();
3832     Length logicalTopLength = styleToUse.logicalTop();
3833     Length logicalBottomLength = styleToUse.logicalBottom();
3834 
3835     /*---------------------------------------------------------------------------*\
3836      * For the purposes of this section and the next, the term &quot;static position&quot;
3837      * (of an element) refers, roughly, to the position an element would have had
3838      * in the normal flow. More precisely, the static position for &#39;top&#39; is the
3839      * distance from the top edge of the containing block to the top margin edge
3840      * of a hypothetical box that would have been the first box of the element if
3841      * its &#39;position&#39; property had been &#39;static&#39; and &#39;float&#39; had been &#39;none&#39;. The
3842      * value is negative if the hypothetical box is above the containing block.
3843      *
3844      * But rather than actually calculating the dimensions of that hypothetical
3845      * box, user agents are free to make a guess at its probable position.
3846      *
3847      * For the purposes of calculating the static position, the containing block
3848      * of fixed positioned elements is the initial containing block instead of
3849      * the viewport.
3850     \*---------------------------------------------------------------------------*/
3851 
3852     // see FIXME 1
3853     // Calculate the static distance if needed.
3854     computeBlockStaticDistance(logicalTopLength, logicalBottomLength, this, containerBlock);
3855 
3856     // Calculate constraint equation values for &#39;height&#39; case.
3857     LayoutUnit logicalHeight = computedValues.m_extent;
3858     computePositionedLogicalHeightUsing(MainOrPreferredSize, styleToUse.logicalHeight(), containerBlock, containerLogicalHeight, bordersPlusPadding, logicalHeight,
3859                                         logicalTopLength, logicalBottomLength, marginBefore, marginAfter,
3860                                         computedValues);
3861 
3862     // Avoid doing any work in the common case (where the values of min-height and max-height are their defaults).
3863     // see FIXME 2
3864 
3865     // Calculate constraint equation values for &#39;max-height&#39; case.
3866     if (!styleToUse.logicalMaxHeight().isUndefined()) {
3867         LogicalExtentComputedValues maxValues;
3868 
3869         computePositionedLogicalHeightUsing(MaxSize, styleToUse.logicalMaxHeight(), containerBlock, containerLogicalHeight, bordersPlusPadding, logicalHeight,
3870                                             logicalTopLength, logicalBottomLength, marginBefore, marginAfter,
3871                                             maxValues);
3872 
3873         if (computedValues.m_extent &gt; maxValues.m_extent) {
3874             computedValues.m_extent = maxValues.m_extent;
3875             computedValues.m_position = maxValues.m_position;
3876             computedValues.m_margins.m_before = maxValues.m_margins.m_before;
3877             computedValues.m_margins.m_after = maxValues.m_margins.m_after;
3878         }
3879     }
3880 
3881     // Calculate constraint equation values for &#39;min-height&#39; case.
3882     if (!styleToUse.logicalMinHeight().isZero() || styleToUse.logicalMinHeight().isIntrinsic()) {
3883         LogicalExtentComputedValues minValues;
3884 
3885         computePositionedLogicalHeightUsing(MinSize, styleToUse.logicalMinHeight(), containerBlock, containerLogicalHeight, bordersPlusPadding, logicalHeight,
3886                                             logicalTopLength, logicalBottomLength, marginBefore, marginAfter,
3887                                             minValues);
3888 
3889         if (computedValues.m_extent &lt; minValues.m_extent) {
3890             computedValues.m_extent = minValues.m_extent;
3891             computedValues.m_position = minValues.m_position;
3892             computedValues.m_margins.m_before = minValues.m_margins.m_before;
3893             computedValues.m_margins.m_after = minValues.m_margins.m_after;
3894         }
3895     }
3896 
3897     // Set final height value.
3898     computedValues.m_extent += bordersPlusPadding;
3899 
3900     // Adjust logicalTop if we need to for perpendicular writing modes in fragments.
3901     // FIXME: Add support for other types of objects as containerBlock, not only RenderBlock.
3902     RenderFragmentedFlow* fragmentedFlow = enclosingFragmentedFlow();
3903     if (fragmentedFlow &amp;&amp; isHorizontalWritingMode() != containerBlock.isHorizontalWritingMode() &amp;&amp; is&lt;RenderBlock&gt;(containerBlock)) {
3904         ASSERT(containerBlock.canHaveBoxInfoInFragment());
3905         LayoutUnit logicalTopPos = computedValues.m_position;
3906         const RenderBlock&amp; renderBox = downcast&lt;RenderBlock&gt;(containerBlock);
3907         LayoutUnit cbPageOffset = renderBox.offsetFromLogicalTopOfFirstPage() - logicalLeft();
3908         RenderFragmentContainer* cbFragment = renderBox.fragmentAtBlockOffset(cbPageOffset);
3909         if (cbFragment) {
3910             RenderBoxFragmentInfo* boxInfo = renderBox.renderBoxFragmentInfo(cbFragment);
3911             if (boxInfo) {
3912                 logicalTopPos += boxInfo-&gt;logicalLeft();
3913                 computedValues.m_position = logicalTopPos;
3914             }
3915         }
3916     }
3917 }
3918 
3919 static void computeLogicalTopPositionedOffset(LayoutUnit&amp; logicalTopPos, const RenderBox* child, LayoutUnit logicalHeightValue, const RenderBoxModelObject&amp; containerBlock, LayoutUnit containerLogicalHeight)
3920 {
3921     // Deal with differing writing modes here.  Our offset needs to be in the containing block&#39;s coordinate space. If the containing block is flipped
3922     // along this axis, then we need to flip the coordinate.  This can only happen if the containing block is both a flipped mode and perpendicular to us.
3923     if ((child-&gt;style().isFlippedBlocksWritingMode() &amp;&amp; child-&gt;isHorizontalWritingMode() != containerBlock.isHorizontalWritingMode())
3924         || (child-&gt;style().isFlippedBlocksWritingMode() != containerBlock.style().isFlippedBlocksWritingMode() &amp;&amp; child-&gt;isHorizontalWritingMode() == containerBlock.isHorizontalWritingMode()))
3925         logicalTopPos = containerLogicalHeight - logicalHeightValue - logicalTopPos;
3926 
3927     // Our offset is from the logical bottom edge in a flipped environment, e.g., right for vertical-rl and bottom for horizontal-bt.
3928     if (containerBlock.style().isFlippedBlocksWritingMode() &amp;&amp; child-&gt;isHorizontalWritingMode() == containerBlock.isHorizontalWritingMode()) {
3929         if (child-&gt;isHorizontalWritingMode())
3930             logicalTopPos += containerBlock.borderBottom();
3931         else
3932             logicalTopPos += containerBlock.borderRight();
3933     } else {
3934         if (child-&gt;isHorizontalWritingMode())
3935             logicalTopPos += containerBlock.borderTop();
3936         else
3937             logicalTopPos += containerBlock.borderLeft();
3938     }
3939 }
3940 
3941 void RenderBox::computePositionedLogicalHeightUsing(SizeType heightType, Length logicalHeightLength, const RenderBoxModelObject&amp; containerBlock,
3942                                                     LayoutUnit containerLogicalHeight, LayoutUnit bordersPlusPadding, LayoutUnit logicalHeight,
3943                                                     Length logicalTop, Length logicalBottom, Length marginBefore, Length marginAfter,
3944                                                     LogicalExtentComputedValues&amp; computedValues) const
3945 {
3946     ASSERT(heightType == MinSize || heightType == MainOrPreferredSize || !logicalHeightLength.isAuto());
3947     if (heightType == MinSize &amp;&amp; logicalHeightLength.isAuto())
3948         logicalHeightLength = Length(0, Fixed);
3949 
3950     // &#39;top&#39; and &#39;bottom&#39; cannot both be &#39;auto&#39; because &#39;top would of been
3951     // converted to the static position in computePositionedLogicalHeight()
3952     ASSERT(!(logicalTop.isAuto() &amp;&amp; logicalBottom.isAuto()));
3953 
3954     LayoutUnit logicalHeightValue;
3955     LayoutUnit contentLogicalHeight = logicalHeight - bordersPlusPadding;
3956 
3957     const LayoutUnit containerRelativeLogicalWidth = containingBlockLogicalWidthForPositioned(containerBlock, nullptr, false);
3958 
3959     LayoutUnit logicalTopValue;
3960 
3961     bool logicalHeightIsAuto = logicalHeightLength.isAuto();
3962     bool logicalTopIsAuto = logicalTop.isAuto();
3963     bool logicalBottomIsAuto = logicalBottom.isAuto();
3964 
3965     // Height is never unsolved for tables.
3966     LayoutUnit resolvedLogicalHeight;
3967     if (isTable()) {
3968         resolvedLogicalHeight = contentLogicalHeight;
3969         logicalHeightIsAuto = false;
3970     } else {
3971         if (logicalHeightLength.isIntrinsic())
3972             resolvedLogicalHeight = computeIntrinsicLogicalContentHeightUsing(logicalHeightLength, contentLogicalHeight, bordersPlusPadding).value();
3973         else
3974             resolvedLogicalHeight = adjustContentBoxLogicalHeightForBoxSizing(valueForLength(logicalHeightLength, containerLogicalHeight));
3975     }
3976 
3977     if (!logicalTopIsAuto &amp;&amp; !logicalHeightIsAuto &amp;&amp; !logicalBottomIsAuto) {
3978         /*-----------------------------------------------------------------------*\
3979          * If none of the three are &#39;auto&#39;: If both &#39;margin-top&#39; and &#39;margin-
3980          * bottom&#39; are &#39;auto&#39;, solve the equation under the extra constraint that
3981          * the two margins get equal values. If one of &#39;margin-top&#39; or &#39;margin-
3982          * bottom&#39; is &#39;auto&#39;, solve the equation for that value. If the values
3983          * are over-constrained, ignore the value for &#39;bottom&#39; and solve for that
3984          * value.
3985         \*-----------------------------------------------------------------------*/
3986         // NOTE:  It is not necessary to solve for &#39;bottom&#39; in the over constrained
3987         // case because the value is not used for any further calculations.
3988 
3989         logicalHeightValue = resolvedLogicalHeight;
3990         logicalTopValue = valueForLength(logicalTop, containerLogicalHeight);
3991 
3992         const LayoutUnit availableSpace = containerLogicalHeight - (logicalTopValue + logicalHeightValue + valueForLength(logicalBottom, containerLogicalHeight) + bordersPlusPadding);
3993 
3994         // Margins are now the only unknown
3995         if (marginBefore.isAuto() &amp;&amp; marginAfter.isAuto()) {
3996             // Both margins auto, solve for equality
3997             // NOTE: This may result in negative values.
3998             computedValues.m_margins.m_before = availableSpace / 2; // split the difference
3999             computedValues.m_margins.m_after = availableSpace - computedValues.m_margins.m_before; // account for odd valued differences
4000         } else if (marginBefore.isAuto()) {
4001             // Solve for top margin
4002             computedValues.m_margins.m_after = valueForLength(marginAfter, containerRelativeLogicalWidth);
4003             computedValues.m_margins.m_before = availableSpace - computedValues.m_margins.m_after;
4004         } else if (marginAfter.isAuto()) {
4005             // Solve for bottom margin
4006             computedValues.m_margins.m_before = valueForLength(marginBefore, containerRelativeLogicalWidth);
4007             computedValues.m_margins.m_after = availableSpace - computedValues.m_margins.m_before;
4008         } else {
4009             // Over-constrained, (no need solve for bottom)
4010             computedValues.m_margins.m_before = valueForLength(marginBefore, containerRelativeLogicalWidth);
4011             computedValues.m_margins.m_after = valueForLength(marginAfter, containerRelativeLogicalWidth);
4012         }
4013     } else {
4014         /*--------------------------------------------------------------------*\
4015          * Otherwise, set &#39;auto&#39; values for &#39;margin-top&#39; and &#39;margin-bottom&#39;
4016          * to 0, and pick the one of the following six rules that applies.
4017          *
4018          * 1. &#39;top&#39; and &#39;height&#39; are &#39;auto&#39; and &#39;bottom&#39; is not &#39;auto&#39;, then
4019          *    the height is based on the content, and solve for &#39;top&#39;.
4020          *
4021          *              OMIT RULE 2 AS IT SHOULD NEVER BE HIT
4022          * ------------------------------------------------------------------
4023          * 2. &#39;top&#39; and &#39;bottom&#39; are &#39;auto&#39; and &#39;height&#39; is not &#39;auto&#39;, then
4024          *    set &#39;top&#39; to the static position, and solve for &#39;bottom&#39;.
4025          * ------------------------------------------------------------------
4026          *
4027          * 3. &#39;height&#39; and &#39;bottom&#39; are &#39;auto&#39; and &#39;top&#39; is not &#39;auto&#39;, then
4028          *    the height is based on the content, and solve for &#39;bottom&#39;.
4029          * 4. &#39;top&#39; is &#39;auto&#39;, &#39;height&#39; and &#39;bottom&#39; are not &#39;auto&#39;, and
4030          *    solve for &#39;top&#39;.
4031          * 5. &#39;height&#39; is &#39;auto&#39;, &#39;top&#39; and &#39;bottom&#39; are not &#39;auto&#39;, and
4032          *    solve for &#39;height&#39;.
4033          * 6. &#39;bottom&#39; is &#39;auto&#39;, &#39;top&#39; and &#39;height&#39; are not &#39;auto&#39;, and
4034          *    solve for &#39;bottom&#39;.
4035         \*--------------------------------------------------------------------*/
4036         // NOTE: For rules 3 and 6 it is not necessary to solve for &#39;bottom&#39;
4037         // because the value is not used for any further calculations.
4038 
4039         // Calculate margins, &#39;auto&#39; margins are ignored.
4040         computedValues.m_margins.m_before = minimumValueForLength(marginBefore, containerRelativeLogicalWidth);
4041         computedValues.m_margins.m_after = minimumValueForLength(marginAfter, containerRelativeLogicalWidth);
4042 
4043         const LayoutUnit availableSpace = containerLogicalHeight - (computedValues.m_margins.m_before + computedValues.m_margins.m_after + bordersPlusPadding);
4044 
4045         // Use rule/case that applies.
4046         if (logicalTopIsAuto &amp;&amp; logicalHeightIsAuto &amp;&amp; !logicalBottomIsAuto) {
4047             // RULE 1: (height is content based, solve of top)
4048             logicalHeightValue = contentLogicalHeight;
4049             logicalTopValue = availableSpace - (logicalHeightValue + valueForLength(logicalBottom, containerLogicalHeight));
4050         } else if (!logicalTopIsAuto &amp;&amp; logicalHeightIsAuto &amp;&amp; logicalBottomIsAuto) {
4051             // RULE 3: (height is content based, no need solve of bottom)
4052             logicalTopValue = valueForLength(logicalTop, containerLogicalHeight);
4053             logicalHeightValue = contentLogicalHeight;
4054         } else if (logicalTopIsAuto &amp;&amp; !logicalHeightIsAuto &amp;&amp; !logicalBottomIsAuto) {
4055             // RULE 4: (solve of top)
4056             logicalHeightValue = resolvedLogicalHeight;
4057             logicalTopValue = availableSpace - (logicalHeightValue + valueForLength(logicalBottom, containerLogicalHeight));
4058         } else if (!logicalTopIsAuto &amp;&amp; logicalHeightIsAuto &amp;&amp; !logicalBottomIsAuto) {
4059             // RULE 5: (solve of height)
4060             logicalTopValue = valueForLength(logicalTop, containerLogicalHeight);
4061             logicalHeightValue = std::max&lt;LayoutUnit&gt;(0, availableSpace - (logicalTopValue + valueForLength(logicalBottom, containerLogicalHeight)));
4062         } else if (!logicalTopIsAuto &amp;&amp; !logicalHeightIsAuto &amp;&amp; logicalBottomIsAuto) {
4063             // RULE 6: (no need solve of bottom)
4064             logicalHeightValue = resolvedLogicalHeight;
4065             logicalTopValue = valueForLength(logicalTop, containerLogicalHeight);
4066         }
4067     }
4068     computedValues.m_extent = logicalHeightValue;
4069 
4070     // Use computed values to calculate the vertical position.
4071     computedValues.m_position = logicalTopValue + computedValues.m_margins.m_before;
4072     computeLogicalTopPositionedOffset(computedValues.m_position, this, logicalHeightValue, containerBlock, containerLogicalHeight);
4073 }
4074 
4075 void RenderBox::computePositionedLogicalWidthReplaced(LogicalExtentComputedValues&amp; computedValues) const
4076 {
4077     // The following is based off of the W3C Working Draft from April 11, 2006 of
4078     // CSS 2.1: Section 10.3.8 &quot;Absolutely positioned, replaced elements&quot;
4079     // &lt;http://www.w3.org/TR/2005/WD-CSS21-20050613/visudet.html#abs-replaced-width&gt;
4080     // (block-style-comments in this function correspond to text from the spec and
4081     // the numbers correspond to numbers in spec)
4082 
4083     // We don&#39;t use containingBlock(), since we may be positioned by an enclosing
4084     // relative positioned inline.
4085     const RenderBoxModelObject&amp; containerBlock = downcast&lt;RenderBoxModelObject&gt;(*container());
4086 
4087     const LayoutUnit containerLogicalWidth = containingBlockLogicalWidthForPositioned(containerBlock);
4088     const LayoutUnit containerRelativeLogicalWidth = containingBlockLogicalWidthForPositioned(containerBlock, nullptr, false);
4089 
4090     // To match WinIE, in quirks mode use the parent&#39;s &#39;direction&#39; property
4091     // instead of the container block&#39;s.
4092     TextDirection containerDirection = containerBlock.style().direction();
4093 
4094     // Variables to solve.
4095     bool isHorizontal = isHorizontalWritingMode();
4096     Length logicalLeft = style().logicalLeft();
4097     Length logicalRight = style().logicalRight();
4098     Length marginLogicalLeft = isHorizontal ? style().marginLeft() : style().marginTop();
4099     Length marginLogicalRight = isHorizontal ? style().marginRight() : style().marginBottom();
4100     LayoutUnit&amp; marginLogicalLeftAlias = style().isLeftToRightDirection() ? computedValues.m_margins.m_start : computedValues.m_margins.m_end;
4101     LayoutUnit&amp; marginLogicalRightAlias = style().isLeftToRightDirection() ? computedValues.m_margins.m_end : computedValues.m_margins.m_start;
4102 
4103     /*-----------------------------------------------------------------------*\
4104      * 1. The used value of &#39;width&#39; is determined as for inline replaced
4105      *    elements.
4106     \*-----------------------------------------------------------------------*/
4107     // NOTE: This value of width is final in that the min/max width calculations
4108     // are dealt with in computeReplacedWidth().  This means that the steps to produce
4109     // correct max/min in the non-replaced version, are not necessary.
4110     computedValues.m_extent = computeReplacedLogicalWidth() + borderAndPaddingLogicalWidth();
4111 
4112     const LayoutUnit availableSpace = containerLogicalWidth - computedValues.m_extent;
4113 
4114     /*-----------------------------------------------------------------------*\
4115      * 2. If both &#39;left&#39; and &#39;right&#39; have the value &#39;auto&#39;, then if &#39;direction&#39;
4116      *    of the containing block is &#39;ltr&#39;, set &#39;left&#39; to the static position;
4117      *    else if &#39;direction&#39; is &#39;rtl&#39;, set &#39;right&#39; to the static position.
4118     \*-----------------------------------------------------------------------*/
4119     // see FIXME 1
4120     computeInlineStaticDistance(logicalLeft, logicalRight, this, containerBlock, containerLogicalWidth, nullptr); // FIXME: Pass the fragment.
4121 
4122     /*-----------------------------------------------------------------------*\
4123      * 3. If &#39;left&#39; or &#39;right&#39; are &#39;auto&#39;, replace any &#39;auto&#39; on &#39;margin-left&#39;
4124      *    or &#39;margin-right&#39; with &#39;0&#39;.
4125     \*-----------------------------------------------------------------------*/
4126     if (logicalLeft.isAuto() || logicalRight.isAuto()) {
4127         if (marginLogicalLeft.isAuto())
4128             marginLogicalLeft.setValue(Fixed, 0);
4129         if (marginLogicalRight.isAuto())
4130             marginLogicalRight.setValue(Fixed, 0);
4131     }
4132 
4133     /*-----------------------------------------------------------------------*\
4134      * 4. If at this point both &#39;margin-left&#39; and &#39;margin-right&#39; are still
4135      *    &#39;auto&#39;, solve the equation under the extra constraint that the two
4136      *    margins must get equal values, unless this would make them negative,
4137      *    in which case when the direction of the containing block is &#39;ltr&#39;
4138      *    (&#39;rtl&#39;), set &#39;margin-left&#39; (&#39;margin-right&#39;) to zero and solve for
4139      *    &#39;margin-right&#39; (&#39;margin-left&#39;).
4140     \*-----------------------------------------------------------------------*/
4141     LayoutUnit logicalLeftValue;
4142     LayoutUnit logicalRightValue;
4143 
4144     if (marginLogicalLeft.isAuto() &amp;&amp; marginLogicalRight.isAuto()) {
4145         // &#39;left&#39; and &#39;right&#39; cannot be &#39;auto&#39; due to step 3
4146         ASSERT(!(logicalLeft.isAuto() &amp;&amp; logicalRight.isAuto()));
4147 
4148         logicalLeftValue = valueForLength(logicalLeft, containerLogicalWidth);
4149         logicalRightValue = valueForLength(logicalRight, containerLogicalWidth);
4150 
4151         LayoutUnit difference = availableSpace - (logicalLeftValue + logicalRightValue);
4152         if (difference &gt; 0) {
4153             marginLogicalLeftAlias = difference / 2; // split the difference
4154             marginLogicalRightAlias = difference - marginLogicalLeftAlias; // account for odd valued differences
4155         } else {
4156             // Use the containing block&#39;s direction rather than the parent block&#39;s
4157             // per CSS 2.1 reference test abspos-replaced-width-margin-000.
4158             if (containerDirection == TextDirection::LTR) {
4159                 marginLogicalLeftAlias = 0;
4160                 marginLogicalRightAlias = difference; // will be negative
4161             } else {
4162                 marginLogicalLeftAlias = difference; // will be negative
4163                 marginLogicalRightAlias = 0;
4164             }
4165         }
4166 
4167     /*-----------------------------------------------------------------------*\
4168      * 5. If at this point there is an &#39;auto&#39; left, solve the equation for
4169      *    that value.
4170     \*-----------------------------------------------------------------------*/
4171     } else if (logicalLeft.isAuto()) {
4172         marginLogicalLeftAlias = valueForLength(marginLogicalLeft, containerRelativeLogicalWidth);
4173         marginLogicalRightAlias = valueForLength(marginLogicalRight, containerRelativeLogicalWidth);
4174         logicalRightValue = valueForLength(logicalRight, containerLogicalWidth);
4175 
4176         // Solve for &#39;left&#39;
4177         logicalLeftValue = availableSpace - (logicalRightValue + marginLogicalLeftAlias + marginLogicalRightAlias);
4178     } else if (logicalRight.isAuto()) {
4179         marginLogicalLeftAlias = valueForLength(marginLogicalLeft, containerRelativeLogicalWidth);
4180         marginLogicalRightAlias = valueForLength(marginLogicalRight, containerRelativeLogicalWidth);
4181         logicalLeftValue = valueForLength(logicalLeft, containerLogicalWidth);
4182 
4183         // Solve for &#39;right&#39;
4184         logicalRightValue = availableSpace - (logicalLeftValue + marginLogicalLeftAlias + marginLogicalRightAlias);
4185     } else if (marginLogicalLeft.isAuto()) {
4186         marginLogicalRightAlias = valueForLength(marginLogicalRight, containerRelativeLogicalWidth);
4187         logicalLeftValue = valueForLength(logicalLeft, containerLogicalWidth);
4188         logicalRightValue = valueForLength(logicalRight, containerLogicalWidth);
4189 
4190         // Solve for &#39;margin-left&#39;
4191         marginLogicalLeftAlias = availableSpace - (logicalLeftValue + logicalRightValue + marginLogicalRightAlias);
4192     } else if (marginLogicalRight.isAuto()) {
4193         marginLogicalLeftAlias = valueForLength(marginLogicalLeft, containerRelativeLogicalWidth);
4194         logicalLeftValue = valueForLength(logicalLeft, containerLogicalWidth);
4195         logicalRightValue = valueForLength(logicalRight, containerLogicalWidth);
4196 
4197         // Solve for &#39;margin-right&#39;
4198         marginLogicalRightAlias = availableSpace - (logicalLeftValue + logicalRightValue + marginLogicalLeftAlias);
4199     } else {
4200         // Nothing is &#39;auto&#39;, just calculate the values.
4201         marginLogicalLeftAlias = valueForLength(marginLogicalLeft, containerRelativeLogicalWidth);
4202         marginLogicalRightAlias = valueForLength(marginLogicalRight, containerRelativeLogicalWidth);
4203         logicalRightValue = valueForLength(logicalRight, containerLogicalWidth);
4204         logicalLeftValue = valueForLength(logicalLeft, containerLogicalWidth);
4205         // If the containing block is right-to-left, then push the left position as far to the right as possible
4206         if (containerDirection == TextDirection::RTL) {
4207             int totalLogicalWidth = computedValues.m_extent + logicalLeftValue + logicalRightValue +  marginLogicalLeftAlias + marginLogicalRightAlias;
4208             logicalLeftValue = containerLogicalWidth - (totalLogicalWidth - logicalLeftValue);
4209         }
4210     }
4211 
4212     /*-----------------------------------------------------------------------*\
4213      * 6. If at this point the values are over-constrained, ignore the value
4214      *    for either &#39;left&#39; (in case the &#39;direction&#39; property of the
4215      *    containing block is &#39;rtl&#39;) or &#39;right&#39; (in case &#39;direction&#39; is
4216      *    &#39;ltr&#39;) and solve for that value.
4217     \*-----------------------------------------------------------------------*/
4218     // NOTE: Constraints imposed by the width of the containing block and its content have already been accounted for above.
4219 
4220     // FIXME: Deal with differing writing modes here.  Our offset needs to be in the containing block&#39;s coordinate space, so that
4221     // can make the result here rather complicated to compute.
4222 
4223     // Use computed values to calculate the horizontal position.
4224 
4225     // FIXME: This hack is needed to calculate the logical left position for a &#39;rtl&#39; relatively
4226     // positioned, inline containing block because right now, it is using the logical left position
4227     // of the first line box when really it should use the last line box.  When
4228     // this is fixed elsewhere, this block should be removed.
4229     if (is&lt;RenderInline&gt;(containerBlock) &amp;&amp; !containerBlock.style().isLeftToRightDirection()) {
4230         const auto&amp; flow = downcast&lt;RenderInline&gt;(containerBlock);
4231         InlineFlowBox* firstLine = flow.firstLineBox();
4232         InlineFlowBox* lastLine = flow.lastLineBox();
4233         if (firstLine &amp;&amp; lastLine &amp;&amp; firstLine != lastLine) {
4234             computedValues.m_position = logicalLeftValue + marginLogicalLeftAlias + lastLine-&gt;borderLogicalLeft() + (lastLine-&gt;logicalLeft() - firstLine-&gt;logicalLeft());
4235             return;
4236         }
4237     }
4238 
4239     LayoutUnit logicalLeftPos = logicalLeftValue + marginLogicalLeftAlias;
4240     computeLogicalLeftPositionedOffset(logicalLeftPos, this, computedValues.m_extent, containerBlock, containerLogicalWidth);
4241     computedValues.m_position = logicalLeftPos;
4242 }
4243 
4244 void RenderBox::computePositionedLogicalHeightReplaced(LogicalExtentComputedValues&amp; computedValues) const
4245 {
4246     // The following is based off of the W3C Working Draft from April 11, 2006 of
4247     // CSS 2.1: Section 10.6.5 &quot;Absolutely positioned, replaced elements&quot;
4248     // &lt;http://www.w3.org/TR/2005/WD-CSS21-20050613/visudet.html#abs-replaced-height&gt;
4249     // (block-style-comments in this function correspond to text from the spec and
4250     // the numbers correspond to numbers in spec)
4251 
4252     // We don&#39;t use containingBlock(), since we may be positioned by an enclosing relpositioned inline.
4253     const RenderBoxModelObject&amp; containerBlock = downcast&lt;RenderBoxModelObject&gt;(*container());
4254 
4255     const LayoutUnit containerLogicalHeight = containingBlockLogicalHeightForPositioned(containerBlock);
4256     const LayoutUnit containerRelativeLogicalWidth = containingBlockLogicalWidthForPositioned(containerBlock, nullptr, false);
4257 
4258     // Variables to solve.
4259     Length marginBefore = style().marginBefore();
4260     Length marginAfter = style().marginAfter();
4261     LayoutUnit&amp; marginBeforeAlias = computedValues.m_margins.m_before;
4262     LayoutUnit&amp; marginAfterAlias = computedValues.m_margins.m_after;
4263 
4264     Length logicalTop = style().logicalTop();
4265     Length logicalBottom = style().logicalBottom();
4266 
4267     /*-----------------------------------------------------------------------*\
4268      * 1. The used value of &#39;height&#39; is determined as for inline replaced
4269      *    elements.
4270     \*-----------------------------------------------------------------------*/
4271     // NOTE: This value of height is final in that the min/max height calculations
4272     // are dealt with in computeReplacedHeight().  This means that the steps to produce
4273     // correct max/min in the non-replaced version, are not necessary.
4274     computedValues.m_extent = computeReplacedLogicalHeight() + borderAndPaddingLogicalHeight();
4275     const LayoutUnit availableSpace = containerLogicalHeight - computedValues.m_extent;
4276 
4277     /*-----------------------------------------------------------------------*\
4278      * 2. If both &#39;top&#39; and &#39;bottom&#39; have the value &#39;auto&#39;, replace &#39;top&#39;
4279      *    with the element&#39;s static position.
4280     \*-----------------------------------------------------------------------*/
4281     // see FIXME 1
4282     computeBlockStaticDistance(logicalTop, logicalBottom, this, containerBlock);
4283 
4284     /*-----------------------------------------------------------------------*\
4285      * 3. If &#39;bottom&#39; is &#39;auto&#39;, replace any &#39;auto&#39; on &#39;margin-top&#39; or
4286      *    &#39;margin-bottom&#39; with &#39;0&#39;.
4287     \*-----------------------------------------------------------------------*/
4288     // FIXME: The spec. says that this step should only be taken when bottom is
4289     // auto, but if only top is auto, this makes step 4 impossible.
4290     if (logicalTop.isAuto() || logicalBottom.isAuto()) {
4291         if (marginBefore.isAuto())
4292             marginBefore.setValue(Fixed, 0);
4293         if (marginAfter.isAuto())
4294             marginAfter.setValue(Fixed, 0);
4295     }
4296 
4297     /*-----------------------------------------------------------------------*\
4298      * 4. If at this point both &#39;margin-top&#39; and &#39;margin-bottom&#39; are still
4299      *    &#39;auto&#39;, solve the equation under the extra constraint that the two
4300      *    margins must get equal values.
4301     \*-----------------------------------------------------------------------*/
4302     LayoutUnit logicalTopValue;
4303     LayoutUnit logicalBottomValue;
4304 
4305     if (marginBefore.isAuto() &amp;&amp; marginAfter.isAuto()) {
4306         // &#39;top&#39; and &#39;bottom&#39; cannot be &#39;auto&#39; due to step 2 and 3 combined.
4307         ASSERT(!(logicalTop.isAuto() || logicalBottom.isAuto()));
4308 
4309         logicalTopValue = valueForLength(logicalTop, containerLogicalHeight);
4310         logicalBottomValue = valueForLength(logicalBottom, containerLogicalHeight);
4311 
4312         LayoutUnit difference = availableSpace - (logicalTopValue + logicalBottomValue);
4313         // NOTE: This may result in negative values.
4314         marginBeforeAlias =  difference / 2; // split the difference
4315         marginAfterAlias = difference - marginBeforeAlias; // account for odd valued differences
4316 
4317     /*-----------------------------------------------------------------------*\
4318      * 5. If at this point there is only one &#39;auto&#39; left, solve the equation
4319      *    for that value.
4320     \*-----------------------------------------------------------------------*/
4321     } else if (logicalTop.isAuto()) {
4322         marginBeforeAlias = valueForLength(marginBefore, containerRelativeLogicalWidth);
4323         marginAfterAlias = valueForLength(marginAfter, containerRelativeLogicalWidth);
4324         logicalBottomValue = valueForLength(logicalBottom, containerLogicalHeight);
4325 
4326         // Solve for &#39;top&#39;
4327         logicalTopValue = availableSpace - (logicalBottomValue + marginBeforeAlias + marginAfterAlias);
4328     } else if (logicalBottom.isAuto()) {
4329         marginBeforeAlias = valueForLength(marginBefore, containerRelativeLogicalWidth);
4330         marginAfterAlias = valueForLength(marginAfter, containerRelativeLogicalWidth);
4331         logicalTopValue = valueForLength(logicalTop, containerLogicalHeight);
4332 
4333         // Solve for &#39;bottom&#39;
4334         // NOTE: It is not necessary to solve for &#39;bottom&#39; because we don&#39;t ever
4335         // use the value.
4336     } else if (marginBefore.isAuto()) {
4337         marginAfterAlias = valueForLength(marginAfter, containerRelativeLogicalWidth);
4338         logicalTopValue = valueForLength(logicalTop, containerLogicalHeight);
4339         logicalBottomValue = valueForLength(logicalBottom, containerLogicalHeight);
4340 
4341         // Solve for &#39;margin-top&#39;
4342         marginBeforeAlias = availableSpace - (logicalTopValue + logicalBottomValue + marginAfterAlias);
4343     } else if (marginAfter.isAuto()) {
4344         marginBeforeAlias = valueForLength(marginBefore, containerRelativeLogicalWidth);
4345         logicalTopValue = valueForLength(logicalTop, containerLogicalHeight);
4346         logicalBottomValue = valueForLength(logicalBottom, containerLogicalHeight);
4347 
4348         // Solve for &#39;margin-bottom&#39;
4349         marginAfterAlias = availableSpace - (logicalTopValue + logicalBottomValue + marginBeforeAlias);
4350     } else {
4351         // Nothing is &#39;auto&#39;, just calculate the values.
4352         marginBeforeAlias = valueForLength(marginBefore, containerRelativeLogicalWidth);
4353         marginAfterAlias = valueForLength(marginAfter, containerRelativeLogicalWidth);
4354         logicalTopValue = valueForLength(logicalTop, containerLogicalHeight);
4355         // NOTE: It is not necessary to solve for &#39;bottom&#39; because we don&#39;t ever
4356         // use the value.
4357      }
4358 
4359     /*-----------------------------------------------------------------------*\
4360      * 6. If at this point the values are over-constrained, ignore the value
4361      *    for &#39;bottom&#39; and solve for that value.
4362     \*-----------------------------------------------------------------------*/
4363     // NOTE: It is not necessary to do this step because we don&#39;t end up using
4364     // the value of &#39;bottom&#39; regardless of whether the values are over-constrained
4365     // or not.
4366 
4367     // Use computed values to calculate the vertical position.
4368     LayoutUnit logicalTopPos = logicalTopValue + marginBeforeAlias;
4369     computeLogicalTopPositionedOffset(logicalTopPos, this, computedValues.m_extent, containerBlock, containerLogicalHeight);
4370     computedValues.m_position = logicalTopPos;
4371 }
4372 
4373 LayoutRect RenderBox::localCaretRect(InlineBox* box, unsigned caretOffset, LayoutUnit* extraWidthToEndOfLine)
4374 {
4375     // VisiblePositions at offsets inside containers either a) refer to the positions before/after
4376     // those containers (tables and select elements) or b) refer to the position inside an empty block.
4377     // They never refer to children.
4378     // FIXME: Paint the carets inside empty blocks differently than the carets before/after elements.
4379 
4380     LayoutRect rect(location(), LayoutSize(caretWidth, height()));
4381     bool ltr = box ? box-&gt;isLeftToRightDirection() : style().isLeftToRightDirection();
4382 
4383     if ((!caretOffset) ^ ltr)
4384         rect.move(LayoutSize(width() - caretWidth, 0_lu));
4385 
4386     if (box) {
4387         const RootInlineBox&amp; rootBox = box-&gt;root();
4388         LayoutUnit top = rootBox.lineTop();
4389         rect.setY(top);
4390         rect.setHeight(rootBox.lineBottom() - top);
4391     }
4392 
4393     // If height of box is smaller than font height, use the latter one,
4394     // otherwise the caret might become invisible.
4395     //
4396     // Also, if the box is not a replaced element, always use the font height.
4397     // This prevents the &quot;big caret&quot; bug described in:
4398     // &lt;rdar://problem/3777804&gt; Deleting all content in a document can result in giant tall-as-window insertion point
4399     //
4400     // FIXME: ignoring :first-line, missing good reason to take care of
4401     LayoutUnit fontHeight = style().fontMetrics().height();
4402     if (fontHeight &gt; rect.height() || (!isReplaced() &amp;&amp; !isTable()))
4403         rect.setHeight(fontHeight);
4404 
4405     if (extraWidthToEndOfLine)
4406         *extraWidthToEndOfLine = x() + width() - rect.maxX();
4407 
4408     // Move to local coords
4409     rect.moveBy(-location());
4410 
4411     // FIXME: Border/padding should be added for all elements but this workaround
4412     // is needed because we use offsets inside an &quot;atomic&quot; element to represent
4413     // positions before and after the element in deprecated editing offsets.
4414     if (element() &amp;&amp; !(editingIgnoresContent(*element()) || isRenderedTable(element()))) {
4415         rect.setX(rect.x() + borderLeft() + paddingLeft());
4416         rect.setY(rect.y() + paddingTop() + borderTop());
4417     }
4418 
4419     if (!isHorizontalWritingMode())
4420         return rect.transposedRect();
4421 
4422     return rect;
4423 }
4424 
4425 VisiblePosition RenderBox::positionForPoint(const LayoutPoint&amp; point, const RenderFragmentContainer* fragment)
4426 {
4427     // no children...return this render object&#39;s element, if there is one, and offset 0
4428     if (!firstChild())
4429         return createVisiblePosition(nonPseudoElement() ? firstPositionInOrBeforeNode(nonPseudoElement()) : Position());
4430 
4431     if (isTable() &amp;&amp; nonPseudoElement()) {
4432         LayoutUnit right = contentWidth() + horizontalBorderAndPaddingExtent();
4433         LayoutUnit bottom = contentHeight() + verticalBorderAndPaddingExtent();
4434 
4435         if (point.x() &lt; 0 || point.x() &gt; right || point.y() &lt; 0 || point.y() &gt; bottom) {
4436             if (point.x() &lt;= right / 2)
4437                 return createVisiblePosition(firstPositionInOrBeforeNode(nonPseudoElement()));
4438             return createVisiblePosition(lastPositionInOrAfterNode(nonPseudoElement()));
4439         }
4440     }
4441 
4442     // Pass off to the closest child.
4443     LayoutUnit minDist = LayoutUnit::max();
4444     RenderBox* closestRenderer = nullptr;
4445     LayoutPoint adjustedPoint = point;
4446     if (isTableRow())
4447         adjustedPoint.moveBy(location());
4448 
4449     for (auto&amp; renderer : childrenOfType&lt;RenderBox&gt;(*this)) {
4450         if (is&lt;RenderFragmentedFlow&gt;(*this)) {
4451             ASSERT(fragment);
4452             if (!downcast&lt;RenderFragmentedFlow&gt;(*this).objectShouldFragmentInFlowFragment(&amp;renderer, fragment))
4453                 continue;
4454         }
4455 
4456         if ((!renderer.firstChild() &amp;&amp; !renderer.isInline() &amp;&amp; !is&lt;RenderBlockFlow&gt;(renderer))
4457             || renderer.style().visibility() != Visibility::Visible)
4458             continue;
4459 
4460         LayoutUnit top = renderer.borderTop() + renderer.paddingTop() + (is&lt;RenderTableRow&gt;(*this) ? 0_lu : renderer.y());
4461         LayoutUnit bottom = top + renderer.contentHeight();
4462         LayoutUnit left = renderer.borderLeft() + renderer.paddingLeft() + (is&lt;RenderTableRow&gt;(*this) ? 0_lu : renderer.x());
4463         LayoutUnit right = left + renderer.contentWidth();
4464 
4465         if (point.x() &lt;= right &amp;&amp; point.x() &gt;= left &amp;&amp; point.y() &lt;= top &amp;&amp; point.y() &gt;= bottom) {
4466             if (is&lt;RenderTableRow&gt;(renderer))
4467                 return renderer.positionForPoint(point + adjustedPoint - renderer.locationOffset(), fragment);
4468             return renderer.positionForPoint(point - renderer.locationOffset(), fragment);
4469         }
4470 
4471         // Find the distance from (x, y) to the box.  Split the space around the box into 8 pieces
4472         // and use a different compare depending on which piece (x, y) is in.
4473         LayoutPoint cmp;
4474         if (point.x() &gt; right) {
4475             if (point.y() &lt; top)
4476                 cmp = LayoutPoint(right, top);
4477             else if (point.y() &gt; bottom)
4478                 cmp = LayoutPoint(right, bottom);
4479             else
4480                 cmp = LayoutPoint(right, point.y());
4481         } else if (point.x() &lt; left) {
4482             if (point.y() &lt; top)
4483                 cmp = LayoutPoint(left, top);
4484             else if (point.y() &gt; bottom)
4485                 cmp = LayoutPoint(left, bottom);
4486             else
4487                 cmp = LayoutPoint(left, point.y());
4488         } else {
4489             if (point.y() &lt; top)
4490                 cmp = LayoutPoint(point.x(), top);
4491             else
4492                 cmp = LayoutPoint(point.x(), bottom);
4493         }
4494 
4495         LayoutSize difference = cmp - point;
4496 
4497         LayoutUnit dist = difference.width() * difference.width() + difference.height() * difference.height();
4498         if (dist &lt; minDist) {
4499             closestRenderer = &amp;renderer;
4500             minDist = dist;
4501         }
4502     }
4503 
4504     if (closestRenderer)
4505         return closestRenderer-&gt;positionForPoint(adjustedPoint - closestRenderer-&gt;locationOffset(), fragment);
4506 
4507     return createVisiblePosition(firstPositionInOrBeforeNode(nonPseudoElement()));
4508 }
4509 
4510 bool RenderBox::shrinkToAvoidFloats() const
4511 {
4512     // Floating objects don&#39;t shrink.  Objects that don&#39;t avoid floats don&#39;t shrink.  Marquees don&#39;t shrink.
4513     if ((isInline() &amp;&amp; !isHTMLMarquee()) || !avoidsFloats() || isFloating())
4514         return false;
4515 
4516     // Only auto width objects can possibly shrink to avoid floats.
4517     return style().width().isAuto();
4518 }
4519 
4520 bool RenderBox::createsNewFormattingContext() const
4521 {
4522     return isInlineBlockOrInlineTable() || isFloatingOrOutOfFlowPositioned() || hasOverflowClip() || isFlexItemIncludingDeprecated()
4523         || isTableCell() || isTableCaption() || isFieldset() || isWritingModeRoot() || isDocumentElementRenderer() || isRenderFragmentedFlow() || isRenderFragmentContainer()
4524         || isGridItem() || style().specifiesColumns() || style().columnSpan() == ColumnSpan::All || style().display() == DisplayType::FlowRoot;
4525 }
4526 
4527 bool RenderBox::avoidsFloats() const
4528 {
4529     return isReplaced() || isHR() || isLegend() || isFieldset() || createsNewFormattingContext();
4530 }
4531 
4532 void RenderBox::addVisualEffectOverflow()
4533 {
4534     if (!style().boxShadow() &amp;&amp; !style().hasBorderImageOutsets() &amp;&amp; !outlineStyleForRepaint().hasOutlineInVisualOverflow())
4535         return;
4536 
4537     addVisualOverflow(applyVisualEffectOverflow(borderBoxRect()));
4538 
4539     RenderFragmentedFlow* fragmentedFlow = enclosingFragmentedFlow();
4540     if (fragmentedFlow)
4541         fragmentedFlow-&gt;addFragmentsVisualEffectOverflow(this);
4542 }
4543 
4544 LayoutRect RenderBox::applyVisualEffectOverflow(const LayoutRect&amp; borderBox) const
4545 {
4546     bool isFlipped = style().isFlippedBlocksWritingMode();
4547     bool isHorizontal = isHorizontalWritingMode();
4548 
4549     LayoutUnit overflowMinX = borderBox.x();
4550     LayoutUnit overflowMaxX = borderBox.maxX();
4551     LayoutUnit overflowMinY = borderBox.y();
4552     LayoutUnit overflowMaxY = borderBox.maxY();
4553 
4554     // Compute box-shadow overflow first.
4555     if (style().boxShadow()) {
4556         LayoutUnit shadowLeft;
4557         LayoutUnit shadowRight;
4558         LayoutUnit shadowTop;
4559         LayoutUnit shadowBottom;
4560         style().getBoxShadowExtent(shadowTop, shadowRight, shadowBottom, shadowLeft);
4561 
4562         // In flipped blocks writing modes such as vertical-rl, the physical right shadow value is actually at the lower x-coordinate.
4563         overflowMinX = borderBox.x() + ((!isFlipped || isHorizontal) ? shadowLeft : -shadowRight);
4564         overflowMaxX = borderBox.maxX() + ((!isFlipped || isHorizontal) ? shadowRight : -shadowLeft);
4565         overflowMinY = borderBox.y() + ((!isFlipped || !isHorizontal) ? shadowTop : -shadowBottom);
4566         overflowMaxY = borderBox.maxY() + ((!isFlipped || !isHorizontal) ? shadowBottom : -shadowTop);
4567     }
4568 
4569     // Now compute border-image-outset overflow.
4570     if (style().hasBorderImageOutsets()) {
4571         LayoutBoxExtent borderOutsets = style().borderImageOutsets();
4572 
4573         // In flipped blocks writing modes, the physical sides are inverted. For example in vertical-rl, the right
4574         // border is at the lower x coordinate value.
4575         overflowMinX = std::min(overflowMinX, borderBox.x() - ((!isFlipped || isHorizontal) ? borderOutsets.left() : borderOutsets.right()));
4576         overflowMaxX = std::max(overflowMaxX, borderBox.maxX() + ((!isFlipped || isHorizontal) ? borderOutsets.right() : borderOutsets.left()));
4577         overflowMinY = std::min(overflowMinY, borderBox.y() - ((!isFlipped || !isHorizontal) ? borderOutsets.top() : borderOutsets.bottom()));
4578         overflowMaxY = std::max(overflowMaxY, borderBox.maxY() + ((!isFlipped || !isHorizontal) ? borderOutsets.bottom() : borderOutsets.top()));
4579     }
4580 
4581     if (outlineStyleForRepaint().hasOutlineInVisualOverflow()) {
4582         LayoutUnit outlineSize { outlineStyleForRepaint().outlineSize() };
4583         overflowMinX = std::min(overflowMinX, borderBox.x() - outlineSize);
4584         overflowMaxX = std::max(overflowMaxX, borderBox.maxX() + outlineSize);
4585         overflowMinY = std::min(overflowMinY, borderBox.y() - outlineSize);
4586         overflowMaxY = std::max(overflowMaxY, borderBox.maxY() + outlineSize);
4587     }
4588     // Add in the final overflow with shadows and outsets combined.
4589     return LayoutRect(overflowMinX, overflowMinY, overflowMaxX - overflowMinX, overflowMaxY - overflowMinY);
4590 }
4591 
4592 void RenderBox::addOverflowFromChild(const RenderBox* child, const LayoutSize&amp; delta)
4593 {
4594     // Never allow flow threads to propagate overflow up to a parent.
4595     if (child-&gt;isRenderFragmentedFlow())
4596         return;
4597 
4598     RenderFragmentedFlow* fragmentedFlow = enclosingFragmentedFlow();
4599     if (fragmentedFlow)
4600         fragmentedFlow-&gt;addFragmentsOverflowFromChild(this, child, delta);
4601 
4602     // Only propagate layout overflow from the child if the child isn&#39;t clipping its overflow.  If it is, then
4603     // its overflow is internal to it, and we don&#39;t care about it.  layoutOverflowRectForPropagation takes care of this
4604     // and just propagates the border box rect instead.
4605     LayoutRect childLayoutOverflowRect = child-&gt;layoutOverflowRectForPropagation(&amp;style());
4606     childLayoutOverflowRect.move(delta);
4607     addLayoutOverflow(childLayoutOverflowRect);
4608 
4609     // Add in visual overflow from the child.  Even if the child clips its overflow, it may still
4610     // have visual overflow of its own set from box shadows or reflections.  It is unnecessary to propagate this
4611     // overflow if we are clipping our own overflow.
4612     if (child-&gt;hasSelfPaintingLayer() || hasOverflowClip())
4613         return;
4614     LayoutRect childVisualOverflowRect = child-&gt;visualOverflowRectForPropagation(&amp;style());
4615     childVisualOverflowRect.move(delta);
4616     addVisualOverflow(childVisualOverflowRect);
4617 }
4618 
4619 void RenderBox::addLayoutOverflow(const LayoutRect&amp; rect)
4620 {
4621     LayoutRect clientBox = flippedClientBoxRect();
4622     if (clientBox.contains(rect) || rect.isEmpty())
4623         return;
4624 
4625     // For overflow clip objects, we don&#39;t want to propagate overflow into unreachable areas.
4626     LayoutRect overflowRect(rect);
4627     if (hasOverflowClip() || isRenderView()) {
4628         // Overflow is in the block&#39;s coordinate space and thus is flipped for horizontal-bt and vertical-rl
4629         // writing modes.  At this stage that is actually a simplification, since we can treat horizontal-tb/bt as the same
4630         // and vertical-lr/rl as the same.
4631         bool hasTopOverflow = isTopLayoutOverflowAllowed();
4632         bool hasLeftOverflow = isLeftLayoutOverflowAllowed();
4633 
4634         if (!hasTopOverflow)
4635             overflowRect.shiftYEdgeTo(std::max(overflowRect.y(), clientBox.y()));
4636         else
4637             overflowRect.shiftMaxYEdgeTo(std::min(overflowRect.maxY(), clientBox.maxY()));
4638         if (!hasLeftOverflow)
4639             overflowRect.shiftXEdgeTo(std::max(overflowRect.x(), clientBox.x()));
4640         else
4641             overflowRect.shiftMaxXEdgeTo(std::min(overflowRect.maxX(), clientBox.maxX()));
4642 
4643         // Now re-test with the adjusted rectangle and see if it has become unreachable or fully
4644         // contained.
4645         if (clientBox.contains(overflowRect) || overflowRect.isEmpty())
4646             return;
4647     }
4648 
4649     if (!m_overflow)
4650         m_overflow = adoptRef(new RenderOverflow(clientBox, borderBoxRect()));
4651 
4652     m_overflow-&gt;addLayoutOverflow(overflowRect);
4653 }
4654 
4655 void RenderBox::addVisualOverflow(const LayoutRect&amp; rect)
4656 {
4657     LayoutRect borderBox = borderBoxRect();
4658     if (borderBox.contains(rect) || rect.isEmpty())
4659         return;
4660 
4661     if (!m_overflow)
4662         m_overflow = adoptRef(new RenderOverflow(flippedClientBoxRect(), borderBox));
4663 
4664     m_overflow-&gt;addVisualOverflow(rect);
4665 }
4666 
4667 void RenderBox::clearOverflow()
4668 {
4669     m_overflow = nullptr;
4670     RenderFragmentedFlow* fragmentedFlow = enclosingFragmentedFlow();
4671     if (fragmentedFlow)
4672         fragmentedFlow-&gt;clearFragmentsOverflow(this);
4673 }
4674 
4675 bool RenderBox::percentageLogicalHeightIsResolvable() const
4676 {
4677     // Do this to avoid duplicating all the logic that already exists when computing
4678     // an actual percentage height.
4679     Length fakeLength(100, Percent);
4680     return computePercentageLogicalHeight(fakeLength) != WTF::nullopt;
4681 }
4682 
4683 bool RenderBox::hasUnsplittableScrollingOverflow() const
4684 {
4685     // We will paginate as long as we don&#39;t scroll overflow in the pagination direction.
4686     bool isHorizontal = isHorizontalWritingMode();
4687     if ((isHorizontal &amp;&amp; !scrollsOverflowY()) || (!isHorizontal &amp;&amp; !scrollsOverflowX()))
4688         return false;
4689 
4690     // We do have overflow. We&#39;ll still be willing to paginate as long as the block
4691     // has auto logical height, auto or undefined max-logical-height and a zero or auto min-logical-height.
4692     // Note this is just a heuristic, and it&#39;s still possible to have overflow under these
4693     // conditions, but it should work out to be good enough for common cases. Paginating overflow
4694     // with scrollbars present is not the end of the world and is what we used to do in the old model anyway.
4695     return !style().logicalHeight().isIntrinsicOrAuto()
4696         || (!style().logicalMaxHeight().isIntrinsicOrAuto() &amp;&amp; !style().logicalMaxHeight().isUndefined() &amp;&amp; (!style().logicalMaxHeight().isPercentOrCalculated() || percentageLogicalHeightIsResolvable()))
4697         || (!style().logicalMinHeight().isIntrinsicOrAuto() &amp;&amp; style().logicalMinHeight().isPositive() &amp;&amp; (!style().logicalMinHeight().isPercentOrCalculated() || percentageLogicalHeightIsResolvable()));
4698 }
4699 
4700 bool RenderBox::isUnsplittableForPagination() const
4701 {
4702     return isReplaced()
4703         || hasUnsplittableScrollingOverflow()
4704         || (parent() &amp;&amp; isWritingModeRoot())
4705         || (isFloating() &amp;&amp; style().styleType() == PseudoId::FirstLetter &amp;&amp; style().initialLetterDrop() &gt; 0);
4706 }
4707 
4708 LayoutUnit RenderBox::lineHeight(bool /*firstLine*/, LineDirectionMode direction, LinePositionMode /*linePositionMode*/) const
4709 {
4710     if (isReplaced())
4711         return direction == HorizontalLine ? m_marginBox.top() + height() + m_marginBox.bottom() : m_marginBox.right() + width() + m_marginBox.left();
4712     return 0;
4713 }
4714 
4715 int RenderBox::baselinePosition(FontBaseline baselineType, bool /*firstLine*/, LineDirectionMode direction, LinePositionMode /*linePositionMode*/) const
4716 {
4717     if (isReplaced()) {
4718         int result = direction == HorizontalLine ? m_marginBox.top() + height() + m_marginBox.bottom() : m_marginBox.right() + width() + m_marginBox.left();
4719         if (baselineType == AlphabeticBaseline)
4720             return result;
4721         return result - result / 2;
4722     }
4723     return 0;
4724 }
4725 
4726 
4727 RenderLayer* RenderBox::enclosingFloatPaintingLayer() const
4728 {
4729     for (auto&amp; box : lineageOfType&lt;RenderBox&gt;(*this)) {
4730         if (box.layer() &amp;&amp; box.layer()-&gt;isSelfPaintingLayer())
4731             return box.layer();
4732     }
4733     return nullptr;
4734 }
4735 
4736 LayoutRect RenderBox::logicalVisualOverflowRectForPropagation(const RenderStyle* parentStyle) const
4737 {
4738     LayoutRect rect = visualOverflowRectForPropagation(parentStyle);
4739     if (!parentStyle-&gt;isHorizontalWritingMode())
4740         return rect.transposedRect();
4741     return rect;
4742 }
4743 
4744 LayoutRect RenderBox::visualOverflowRectForPropagation(const RenderStyle* parentStyle) const
4745 {
4746     // If the writing modes of the child and parent match, then we don&#39;t have to
4747     // do anything fancy. Just return the result.
4748     LayoutRect rect = visualOverflowRect();
4749     if (parentStyle-&gt;writingMode() == style().writingMode())
4750         return rect;
4751 
4752     // We are putting ourselves into our parent&#39;s coordinate space.  If there is a flipped block mismatch
4753     // in a particular axis, then we have to flip the rect along that axis.
4754     if (style().writingMode() == RightToLeftWritingMode || parentStyle-&gt;writingMode() == RightToLeftWritingMode)
4755         rect.setX(width() - rect.maxX());
4756     else if (style().writingMode() == BottomToTopWritingMode || parentStyle-&gt;writingMode() == BottomToTopWritingMode)
4757         rect.setY(height() - rect.maxY());
4758 
4759     return rect;
4760 }
4761 
4762 LayoutRect RenderBox::logicalLayoutOverflowRectForPropagation(const RenderStyle* parentStyle) const
4763 {
4764     LayoutRect rect = layoutOverflowRectForPropagation(parentStyle);
4765     if (!parentStyle-&gt;isHorizontalWritingMode())
4766         return rect.transposedRect();
4767     return rect;
4768 }
4769 
4770 LayoutRect RenderBox::layoutOverflowRectForPropagation(const RenderStyle* parentStyle) const
4771 {
4772     // Only propagate interior layout overflow if we don&#39;t clip it.
4773     LayoutRect rect = borderBoxRect();
4774     if (!hasOverflowClip())
4775         rect.unite(layoutOverflowRect());
4776 
4777     bool hasTransform = this-&gt;hasTransform();
4778     if (isInFlowPositioned() || hasTransform) {
4779         // If we are relatively positioned or if we have a transform, then we have to convert
4780         // this rectangle into physical coordinates, apply relative positioning and transforms
4781         // to it, and then convert it back.
4782         flipForWritingMode(rect);
4783 
4784         if (hasTransform)
4785             rect = layer()-&gt;currentTransform().mapRect(rect);
4786 
4787         if (isInFlowPositioned())
4788             rect.move(offsetForInFlowPosition());
4789 
4790         // Now we need to flip back.
4791         flipForWritingMode(rect);
4792     }
4793 
4794     // If the writing modes of the child and parent match, then we don&#39;t have to
4795     // do anything fancy. Just return the result.
4796     if (parentStyle-&gt;writingMode() == style().writingMode())
4797         return rect;
4798 
4799     // We are putting ourselves into our parent&#39;s coordinate space.  If there is a flipped block mismatch
4800     // in a particular axis, then we have to flip the rect along that axis.
4801     if (style().writingMode() == RightToLeftWritingMode || parentStyle-&gt;writingMode() == RightToLeftWritingMode)
4802         rect.setX(width() - rect.maxX());
4803     else if (style().writingMode() == BottomToTopWritingMode || parentStyle-&gt;writingMode() == BottomToTopWritingMode)
4804         rect.setY(height() - rect.maxY());
4805 
4806     return rect;
4807 }
4808 
4809 LayoutRect RenderBox::flippedClientBoxRect() const
4810 {
4811     // Because of the special coordinate system used for overflow rectangles (not quite logical, not
4812     // quite physical), we need to flip the block progression coordinate in vertical-rl and
4813     // horizontal-bt writing modes. Apart from that, this method does the same as clientBoxRect().
4814 
4815     LayoutUnit left = borderLeft();
4816     LayoutUnit top = borderTop();
4817     LayoutUnit right = borderRight();
4818     LayoutUnit bottom = borderBottom();
4819     // Calculate physical padding box.
4820     LayoutRect rect(left, top, width() - left - right, height() - top - bottom);
4821     // Flip block progression axis if writing mode is vertical-rl or horizontal-bt.
4822     flipForWritingMode(rect);
4823     // Subtract space occupied by scrollbars. They are at their physical edge in this coordinate
4824     // system, so order is important here: first flip, then subtract scrollbars.
4825     if (shouldPlaceBlockDirectionScrollbarOnLeft())
4826         rect.move(verticalScrollbarWidth(), 0);
4827     rect.contract(verticalScrollbarWidth(), horizontalScrollbarHeight());
4828     return rect;
4829 }
4830 
4831 LayoutRect RenderBox::overflowRectForPaintRejection() const
4832 {
4833     LayoutRect overflowRect = visualOverflowRect();
4834 
4835     if (!m_overflow || !usesCompositedScrolling())
4836         return overflowRect;
4837 
4838     overflowRect.unite(layoutOverflowRect());
4839     overflowRect.moveBy(-scrollPosition());
4840     return overflowRect;
4841 }
4842 
4843 LayoutUnit RenderBox::offsetLeft() const
4844 {
4845     return adjustedPositionRelativeToOffsetParent(topLeftLocation()).x();
4846 }
4847 
4848 LayoutUnit RenderBox::offsetTop() const
4849 {
4850     return adjustedPositionRelativeToOffsetParent(topLeftLocation()).y();
4851 }
4852 
4853 LayoutPoint RenderBox::flipForWritingModeForChild(const RenderBox* child, const LayoutPoint&amp; point) const
4854 {
4855     if (!style().isFlippedBlocksWritingMode())
4856         return point;
4857 
4858     // The child is going to add in its x() and y(), so we have to make sure it ends up in
4859     // the right place.
4860     if (isHorizontalWritingMode())
4861         return LayoutPoint(point.x(), point.y() + height() - child-&gt;height() - (2 * child-&gt;y()));
4862     return LayoutPoint(point.x() + width() - child-&gt;width() - (2 * child-&gt;x()), point.y());
4863 }
4864 
4865 void RenderBox::flipForWritingMode(LayoutRect&amp; rect) const
4866 {
4867     if (!style().isFlippedBlocksWritingMode())
4868         return;
4869 
4870     if (isHorizontalWritingMode())
4871         rect.setY(height() - rect.maxY());
4872     else
4873         rect.setX(width() - rect.maxX());
4874 }
4875 
4876 LayoutUnit RenderBox::flipForWritingMode(LayoutUnit position) const
4877 {
4878     if (!style().isFlippedBlocksWritingMode())
4879         return position;
4880     return logicalHeight() - position;
4881 }
4882 
4883 LayoutPoint RenderBox::flipForWritingMode(const LayoutPoint&amp; position) const
4884 {
4885     if (!style().isFlippedBlocksWritingMode())
4886         return position;
4887     return isHorizontalWritingMode() ? LayoutPoint(position.x(), height() - position.y()) : LayoutPoint(width() - position.x(), position.y());
4888 }
4889 
4890 LayoutSize RenderBox::flipForWritingMode(const LayoutSize&amp; offset) const
4891 {
4892     if (!style().isFlippedBlocksWritingMode())
4893         return offset;
4894     return isHorizontalWritingMode() ? LayoutSize(offset.width(), height() - offset.height()) : LayoutSize(width() - offset.width(), offset.height());
4895 }
4896 
4897 FloatPoint RenderBox::flipForWritingMode(const FloatPoint&amp; position) const
4898 {
4899     if (!style().isFlippedBlocksWritingMode())
4900         return position;
4901     return isHorizontalWritingMode() ? FloatPoint(position.x(), height() - position.y()) : FloatPoint(width() - position.x(), position.y());
4902 }
4903 
4904 void RenderBox::flipForWritingMode(FloatRect&amp; rect) const
4905 {
4906     if (!style().isFlippedBlocksWritingMode())
4907         return;
4908 
4909     if (isHorizontalWritingMode())
4910         rect.setY(height() - rect.maxY());
4911     else
4912         rect.setX(width() - rect.maxX());
4913 }
4914 
4915 LayoutPoint RenderBox::topLeftLocation() const
4916 {
4917     if (!view().frameView().hasFlippedBlockRenderers())
4918         return location();
4919 
4920     RenderBlock* containerBlock = containingBlock();
4921     if (!containerBlock || containerBlock == this)
4922         return location();
4923     return containerBlock-&gt;flipForWritingModeForChild(this, location());
4924 }
4925 
4926 LayoutSize RenderBox::topLeftLocationOffset() const
4927 {
4928     if (!view().frameView().hasFlippedBlockRenderers())
4929         return locationOffset();
4930 
4931     RenderBlock* containerBlock = containingBlock();
4932     if (!containerBlock || containerBlock == this)
4933         return locationOffset();
4934 
4935     LayoutRect rect(frameRect());
4936     containerBlock-&gt;flipForWritingMode(rect); // FIXME: This is wrong if we are an absolutely positioned object enclosed by a relative-positioned inline.
4937     return LayoutSize(rect.x(), rect.y());
4938 }
4939 
4940 void RenderBox::applyTopLeftLocationOffsetWithFlipping(LayoutPoint&amp; point) const
4941 {
4942     RenderBlock* containerBlock = containingBlock();
4943     if (!containerBlock || containerBlock == this) {
4944         point.move(m_frameRect.x(), m_frameRect.y());
4945         return;
4946     }
4947 
4948     LayoutRect rect(frameRect());
4949     containerBlock-&gt;flipForWritingMode(rect); // FIXME: This is wrong if we are an absolutely positioned object  enclosed by a relative-positioned inline.
4950     point.move(rect.x(), rect.y());
4951 }
4952 
4953 bool RenderBox::hasRelativeDimensions() const
4954 {
4955     return style().height().isPercentOrCalculated() || style().width().isPercentOrCalculated()
4956         || style().maxHeight().isPercentOrCalculated() || style().maxWidth().isPercentOrCalculated()
4957         || style().minHeight().isPercentOrCalculated() || style().minWidth().isPercentOrCalculated();
4958 }
4959 
4960 bool RenderBox::hasRelativeLogicalHeight() const
4961 {
4962     return style().logicalHeight().isPercentOrCalculated()
4963         || style().logicalMinHeight().isPercentOrCalculated()
4964         || style().logicalMaxHeight().isPercentOrCalculated();
4965 }
4966 
4967 bool RenderBox::hasRelativeLogicalWidth() const
4968 {
4969     return style().logicalWidth().isPercentOrCalculated()
4970         || style().logicalMinWidth().isPercentOrCalculated()
4971         || style().logicalMaxWidth().isPercentOrCalculated();
4972 }
4973 
4974 LayoutUnit RenderBox::offsetFromLogicalTopOfFirstPage() const
4975 {
4976     auto* layoutState = view().frameView().layoutContext().layoutState();
4977     if ((layoutState &amp;&amp; !layoutState-&gt;isPaginated()) || (!layoutState &amp;&amp; !enclosingFragmentedFlow()))
4978         return 0;
4979 
4980     RenderBlock* containerBlock = containingBlock();
4981     return containerBlock-&gt;offsetFromLogicalTopOfFirstPage() + logicalTop();
4982 }
4983 
4984 const RenderBox* RenderBox::findEnclosingScrollableContainer() const
4985 {
4986     for (auto&amp; candidate : lineageOfType&lt;RenderBox&gt;(*this)) {
4987         if (candidate.hasOverflowClip())
4988             return &amp;candidate;
4989     }
4990     // If all parent elements are not overflow scrollable, check the body.
4991     if (document().body() &amp;&amp; frame().mainFrame().view() &amp;&amp; frame().mainFrame().view()-&gt;isScrollable())
4992         return document().body()-&gt;renderBox();
4993 
4994     return nullptr;
4995 }
4996 
4997 } // namespace WebCore
    </pre>
  </body>
</html>