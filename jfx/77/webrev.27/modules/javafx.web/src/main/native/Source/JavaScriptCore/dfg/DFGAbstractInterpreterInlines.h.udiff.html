<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGAbstractInterpreterInlines.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="DFGAbstractInterpreter.h.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DFGAbstractValue.cpp.udiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGAbstractInterpreterInlines.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -1,7 +1,7 @@</span>
  /*
<span class="udiff-line-modified-removed">-  * Copyright (C) 2013-2018 Apple Inc. All rights reserved.</span>
<span class="udiff-line-modified-added">+  * Copyright (C) 2013-2019 Apple Inc. All rights reserved.</span>
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions
   * are met:
   * 1. Redistributions of source code must retain the above copyright
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -41,10 +41,11 @@</span>
  #include &quot;MathCommon.h&quot;
  #include &quot;NumberConstructor.h&quot;
  #include &quot;Operations.h&quot;
  #include &quot;PutByIdStatus.h&quot;
  #include &quot;StringObject.h&quot;
<span class="udiff-line-added">+ #include &quot;StructureCache.h&quot;</span>
  #include &quot;StructureRareDataInlines.h&quot;
  #include &lt;wtf/BooleanLattice.h&gt;
  #include &lt;wtf/CheckedArithmetic.h&gt;
  
  namespace JSC { namespace DFG {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -55,11 +56,11 @@</span>
      , m_graph(graph)
      , m_vm(m_graph.m_vm)
      , m_state(state)
  {
      if (m_graph.m_form == SSA)
<span class="udiff-line-modified-removed">-         m_phiChildren = std::make_unique&lt;PhiChildren&gt;(m_graph);</span>
<span class="udiff-line-modified-added">+         m_phiChildren = makeUnique&lt;PhiChildren&gt;(m_graph);</span>
  }
  
  template&lt;typename AbstractStateType&gt;
  AbstractInterpreter&lt;AbstractStateType&gt;::~AbstractInterpreter()
  {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -230,10 +231,106 @@</span>
      }
  
      return ToThisResult::Dynamic;
  }
  
<span class="udiff-line-added">+ template&lt;typename AbstractStateType&gt;</span>
<span class="udiff-line-added">+ bool AbstractInterpreter&lt;AbstractStateType&gt;::handleConstantBinaryBitwiseOp(Node* node)</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     JSValue left = forNode(node-&gt;child1()).value();</span>
<span class="udiff-line-added">+     JSValue right = forNode(node-&gt;child2()).value();</span>
<span class="udiff-line-added">+     if (left &amp;&amp; right &amp;&amp; left.isInt32() &amp;&amp; right.isInt32()) {</span>
<span class="udiff-line-added">+         int32_t a = left.asInt32();</span>
<span class="udiff-line-added">+         int32_t b = right.asInt32();</span>
<span class="udiff-line-added">+         if (node-&gt;isBinaryUseKind(UntypedUse))</span>
<span class="udiff-line-added">+             didFoldClobberWorld();</span>
<span class="udiff-line-added">+         NodeType op = node-&gt;op();</span>
<span class="udiff-line-added">+         switch (op) {</span>
<span class="udiff-line-added">+         case ValueBitAnd:</span>
<span class="udiff-line-added">+         case ArithBitAnd:</span>
<span class="udiff-line-added">+             setConstant(node, JSValue(a &amp; b));</span>
<span class="udiff-line-added">+             break;</span>
<span class="udiff-line-added">+         case ValueBitOr:</span>
<span class="udiff-line-added">+         case ArithBitOr:</span>
<span class="udiff-line-added">+             setConstant(node, JSValue(a | b));</span>
<span class="udiff-line-added">+             break;</span>
<span class="udiff-line-added">+         case ValueBitXor:</span>
<span class="udiff-line-added">+         case ArithBitXor:</span>
<span class="udiff-line-added">+             setConstant(node, JSValue(a ^ b));</span>
<span class="udiff-line-added">+             break;</span>
<span class="udiff-line-added">+         case BitRShift:</span>
<span class="udiff-line-added">+             setConstant(node, JSValue(a &gt;&gt; (static_cast&lt;uint32_t&gt;(b) &amp; 0x1f)));</span>
<span class="udiff-line-added">+             break;</span>
<span class="udiff-line-added">+         case ValueBitLShift:</span>
<span class="udiff-line-added">+         case ArithBitLShift:</span>
<span class="udiff-line-added">+             setConstant(node, JSValue(a &lt;&lt; (static_cast&lt;uint32_t&gt;(b) &amp; 0x1f)));</span>
<span class="udiff-line-added">+             break;</span>
<span class="udiff-line-added">+         case BitURShift:</span>
<span class="udiff-line-added">+             setConstant(node, JSValue(static_cast&lt;int32_t&gt;(static_cast&lt;uint32_t&gt;(a) &gt;&gt; (static_cast&lt;uint32_t&gt;(b) &amp; 0x1f))));</span>
<span class="udiff-line-added">+             break;</span>
<span class="udiff-line-added">+         default:</span>
<span class="udiff-line-added">+             RELEASE_ASSERT_NOT_REACHED();</span>
<span class="udiff-line-added">+             break;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         return true;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     return false;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ template&lt;typename AbstractStateType&gt;</span>
<span class="udiff-line-added">+ bool AbstractInterpreter&lt;AbstractStateType&gt;::handleConstantDivOp(Node* node)</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     JSValue left = forNode(node-&gt;child1()).value();</span>
<span class="udiff-line-added">+     JSValue right = forNode(node-&gt;child2()).value();</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     if (left &amp;&amp; right) {</span>
<span class="udiff-line-added">+         NodeType op = node-&gt;op();</span>
<span class="udiff-line-added">+         bool isDivOperation = op == ValueDiv || op == ArithDiv;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         // Only possible case of ValueOp below is UntypedUse,</span>
<span class="udiff-line-added">+         // so we need to reflect clobberize rules.</span>
<span class="udiff-line-added">+         bool isClobbering = op == ValueDiv || op == ValueMod;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         if (left.isInt32() &amp;&amp; right.isInt32()) {</span>
<span class="udiff-line-added">+             double doubleResult;</span>
<span class="udiff-line-added">+             if (isDivOperation)</span>
<span class="udiff-line-added">+                 doubleResult = left.asNumber() / right.asNumber();</span>
<span class="udiff-line-added">+             else</span>
<span class="udiff-line-added">+                 doubleResult = fmod(left.asNumber(), right.asNumber());</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             if (node-&gt;hasArithMode()) {</span>
<span class="udiff-line-added">+                 if (!shouldCheckOverflow(node-&gt;arithMode()))</span>
<span class="udiff-line-added">+                     doubleResult = toInt32(doubleResult);</span>
<span class="udiff-line-added">+                 else if (!shouldCheckNegativeZero(node-&gt;arithMode()))</span>
<span class="udiff-line-added">+                     doubleResult += 0; // Sanitizes zero.</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             JSValue valueResult = jsNumber(doubleResult);</span>
<span class="udiff-line-added">+             if (valueResult.isInt32()) {</span>
<span class="udiff-line-added">+                 if (isClobbering)</span>
<span class="udiff-line-added">+                     didFoldClobberWorld();</span>
<span class="udiff-line-added">+                 setConstant(node, valueResult);</span>
<span class="udiff-line-added">+                 return true;</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+         } else if (left.isNumber() &amp;&amp; right.isNumber()) {</span>
<span class="udiff-line-added">+             if (isClobbering)</span>
<span class="udiff-line-added">+                 didFoldClobberWorld();</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             if (isDivOperation)</span>
<span class="udiff-line-added">+                 setConstant(node, jsDoubleNumber(left.asNumber() / right.asNumber()));</span>
<span class="udiff-line-added">+             else</span>
<span class="udiff-line-added">+                 setConstant(node, jsDoubleNumber(fmod(left.asNumber(), right.asNumber())));</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             return true;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     return false;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
  template&lt;typename AbstractStateType&gt;
  bool AbstractInterpreter&lt;AbstractStateType&gt;::executeEffects(unsigned clobberLimit, Node* node)
  {
      verifyEdges(node);
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -319,13 +416,14 @@</span>
          // This is just a hint telling us that the OSR state of the local is no longer inside the
          // flushed data.
          break;
      }
  
<span class="udiff-line-modified-removed">-     case SetArgument:</span>
<span class="udiff-line-modified-removed">-         // Assert that the state of arguments has been set. SetArgument means that someone set</span>
<span class="udiff-line-modified-removed">-         // the argument values out-of-band, and currently this always means setting to a</span>
<span class="udiff-line-modified-added">+     case SetArgumentDefinitely:</span>
<span class="udiff-line-modified-added">+     case SetArgumentMaybe:</span>
<span class="udiff-line-modified-added">+         // Assert that the state of arguments has been set. SetArgumentDefinitely/SetArgumentMaybe means</span>
<span class="udiff-line-added">+         // that someone set the argument values out-of-band, and currently this always means setting to a</span>
          // non-clear value.
          ASSERT(!m_state.operand(node-&gt;local()).isClear());
          break;
  
      case InitializeEntrypointArguments: {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -374,17 +472,30 @@</span>
          for (unsigned i = data-&gt;limit - 1; i--;)
              m_state.operand(data-&gt;start.offset() + i).makeHeapTop();
          break;
      }
  
<span class="udiff-line-modified-removed">-     case ArithBitNot: {</span>
<span class="udiff-line-modified-removed">-         if (node-&gt;child1().useKind() == UntypedUse) {</span>
<span class="udiff-line-modified-removed">-             clobberWorld();</span>
<span class="udiff-line-modified-removed">-             setNonCellTypeForNode(node, SpecInt32Only);</span>
<span class="udiff-line-modified-added">+     case ValueBitNot: {</span>
<span class="udiff-line-modified-added">+         JSValue operand = forNode(node-&gt;child1()).value();</span>
<span class="udiff-line-modified-added">+         if (operand &amp;&amp; operand.isInt32()) {</span>
<span class="udiff-line-modified-added">+             didFoldClobberWorld();</span>
<span class="udiff-line-added">+             int32_t a = operand.asInt32();</span>
<span class="udiff-line-added">+             setConstant(node, JSValue(~a));</span>
              break;
          }
  
<span class="udiff-line-added">+         if (node-&gt;child1().useKind() == BigIntUse)</span>
<span class="udiff-line-added">+             setTypeForNode(node, SpecBigInt);</span>
<span class="udiff-line-added">+         else {</span>
<span class="udiff-line-added">+             clobberWorld();</span>
<span class="udiff-line-added">+             setTypeForNode(node, SpecInt32Only | SpecBigInt);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         break;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     case ArithBitNot: {</span>
          JSValue operand = forNode(node-&gt;child1()).value();
          if (operand &amp;&amp; operand.isInt32()) {
              int32_t a = operand.asInt32();
              setConstant(node, JSValue(~a));
              break;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -395,60 +506,37 @@</span>
      }
  
      case ValueBitXor:
      case ValueBitAnd:
      case ValueBitOr:
<span class="udiff-line-added">+     case ValueBitLShift: {</span>
<span class="udiff-line-added">+         if (handleConstantBinaryBitwiseOp(node))</span>
<span class="udiff-line-added">+             break;</span>
<span class="udiff-line-added">+ </span>
          if (node-&gt;binaryUseKind() == BigIntUse)
              setTypeForNode(node, SpecBigInt);
          else {
              clobberWorld();
<span class="udiff-line-modified-removed">-             setTypeForNode(node, SpecBoolInt32 | SpecBigInt);</span>
<span class="udiff-line-modified-added">+             setTypeForNode(node, SpecInt32Only | SpecBigInt);</span>
          }
          break;
<span class="udiff-line-added">+     }</span>
  
      case ArithBitAnd:
      case ArithBitOr:
      case ArithBitXor:
      case BitRShift:
<span class="udiff-line-modified-removed">-     case BitLShift:</span>
<span class="udiff-line-modified-added">+     case ArithBitLShift:</span>
      case BitURShift: {
          if (node-&gt;child1().useKind() == UntypedUse || node-&gt;child2().useKind() == UntypedUse) {
              clobberWorld();
              setNonCellTypeForNode(node, SpecInt32Only);
              break;
          }
  
<span class="udiff-line-modified-removed">-         JSValue left = forNode(node-&gt;child1()).value();</span>
<span class="udiff-line-removed">-         JSValue right = forNode(node-&gt;child2()).value();</span>
<span class="udiff-line-removed">-         if (left &amp;&amp; right &amp;&amp; left.isInt32() &amp;&amp; right.isInt32()) {</span>
<span class="udiff-line-removed">-             int32_t a = left.asInt32();</span>
<span class="udiff-line-removed">-             int32_t b = right.asInt32();</span>
<span class="udiff-line-removed">-             switch (node-&gt;op()) {</span>
<span class="udiff-line-removed">-             case ArithBitAnd:</span>
<span class="udiff-line-removed">-                 setConstant(node, JSValue(a &amp; b));</span>
<span class="udiff-line-removed">-                 break;</span>
<span class="udiff-line-removed">-             case ArithBitOr:</span>
<span class="udiff-line-removed">-                 setConstant(node, JSValue(a | b));</span>
<span class="udiff-line-removed">-                 break;</span>
<span class="udiff-line-removed">-             case ArithBitXor:</span>
<span class="udiff-line-removed">-                 setConstant(node, JSValue(a ^ b));</span>
<span class="udiff-line-removed">-                 break;</span>
<span class="udiff-line-removed">-             case BitRShift:</span>
<span class="udiff-line-removed">-                 setConstant(node, JSValue(a &gt;&gt; (static_cast&lt;uint32_t&gt;(b) &amp; 0x1f)));</span>
<span class="udiff-line-removed">-                 break;</span>
<span class="udiff-line-removed">-             case BitLShift:</span>
<span class="udiff-line-removed">-                 setConstant(node, JSValue(a &lt;&lt; (static_cast&lt;uint32_t&gt;(b) &amp; 0x1f)));</span>
<span class="udiff-line-removed">-                 break;</span>
<span class="udiff-line-removed">-             case BitURShift:</span>
<span class="udiff-line-removed">-                 setConstant(node, JSValue(static_cast&lt;int32_t&gt;(static_cast&lt;uint32_t&gt;(a) &gt;&gt; (static_cast&lt;uint32_t&gt;(b) &amp; 0x1f))));</span>
<span class="udiff-line-removed">-                 break;</span>
<span class="udiff-line-removed">-             default:</span>
<span class="udiff-line-removed">-                 RELEASE_ASSERT_NOT_REACHED();</span>
<span class="udiff-line-removed">-                 break;</span>
<span class="udiff-line-removed">-             }</span>
<span class="udiff-line-modified-added">+         if (handleConstantBinaryBitwiseOp(node))</span>
              break;
<span class="udiff-line-removed">-         }</span>
  
          if (node-&gt;op() == ArithBitAnd
              &amp;&amp; (isBoolInt32Speculation(forNode(node-&gt;child1()).m_type) ||
                  isBoolInt32Speculation(forNode(node-&gt;child2()).m_type))) {
              setNonCellTypeForNode(node, SpecBoolInt32);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -466,11 +554,11 @@</span>
                  if (child &amp;&amp; child.isAnyInt()) {
                      int64_t machineInt = child.asAnyInt();
                      setConstant(node, jsNumber(static_cast&lt;uint32_t&gt;(machineInt)));
                      break;
                  }
<span class="udiff-line-modified-removed">-                 setNonCellTypeForNode(node, SpecAnyInt);</span>
<span class="udiff-line-modified-added">+                 setNonCellTypeForNode(node, SpecInt52Any);</span>
                  break;
              }
              if (child &amp;&amp; child.isInt32()) {
                  uint32_t value = child.asInt32();
                  setConstant(node, jsNumber(value));
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -593,11 +681,12 @@</span>
          if (child &amp;&amp; child.isAnyInt()) {
              setConstant(node, child);
              break;
          }
  
<span class="udiff-line-modified-removed">-         setNonCellTypeForNode(node, SpecAnyInt);</span>
<span class="udiff-line-modified-added">+         setTypeForNode(node, forNode(node-&gt;child1()).m_type);</span>
<span class="udiff-line-added">+         forNode(node).fixTypeForRepresentation(m_graph, node);</span>
          break;
      }
  
      case ValueRep: {
          JSValue value = forNode(node-&gt;child1()).value();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -652,11 +741,11 @@</span>
                  if (result.isAnyInt()) {
                      setConstant(node, result);
                      break;
                  }
              }
<span class="udiff-line-modified-removed">-             setNonCellTypeForNode(node, SpecAnyInt);</span>
<span class="udiff-line-modified-added">+             setNonCellTypeForNode(node, SpecInt52Any);</span>
              break;
          case DoubleRepUse:
              if (left &amp;&amp; right &amp;&amp; left.isNumber() &amp;&amp; right.isNumber()) {
                  setConstant(node, jsDoubleNumber(left.asNumber() + right.asNumber()));
                  break;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -689,11 +778,11 @@</span>
              default:
                  didFoldClobberWorld();
                  break;
              }
              uint32_t value = toUInt32(*number);
<span class="udiff-line-modified-removed">-             setConstant(node, jsNumber(clz32(value)));</span>
<span class="udiff-line-modified-added">+             setConstant(node, jsNumber(clz(value)));</span>
              break;
          }
          switch (node-&gt;child1().useKind()) {
          case Int32Use:
          case KnownInt32Use:
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -705,49 +794,27 @@</span>
          setNonCellTypeForNode(node, SpecInt32Only);
          break;
      }
  
      case MakeRope: {
<span class="udiff-line-removed">-         unsigned numberOfChildren = 0;</span>
          unsigned numberOfRemovedChildren = 0;
<span class="udiff-line-removed">-         Optional&lt;unsigned&gt; nonEmptyIndex;</span>
          for (unsigned i = 0; i &lt; AdjacencyList::Size; ++i) {
              Edge&amp; edge = node-&gt;children.child(i);
              if (!edge)
                  break;
<span class="udiff-line-removed">-             ++numberOfChildren;</span>
<span class="udiff-line-removed">- </span>
              JSValue childConstant = m_state.forNode(edge).value();
<span class="udiff-line-modified-removed">-             if (!childConstant) {</span>
<span class="udiff-line-removed">-                 nonEmptyIndex = i;</span>
<span class="udiff-line-modified-added">+             if (!childConstant)</span>
                  continue;
<span class="udiff-line-modified-removed">-             }</span>
<span class="udiff-line-removed">-             if (!childConstant.isString()) {</span>
<span class="udiff-line-removed">-                 nonEmptyIndex = i;</span>
<span class="udiff-line-modified-added">+             if (!childConstant.isString())</span>
                  continue;
<span class="udiff-line-modified-removed">-             }</span>
<span class="udiff-line-removed">-             if (asString(childConstant)-&gt;length()) {</span>
<span class="udiff-line-removed">-                 nonEmptyIndex = i;</span>
<span class="udiff-line-modified-added">+             if (asString(childConstant)-&gt;length())</span>
                  continue;
<span class="udiff-line-removed">-             }</span>
<span class="udiff-line-removed">- </span>
              ++numberOfRemovedChildren;
          }
  
<span class="udiff-line-modified-removed">-         if (numberOfRemovedChildren) {</span>
<span class="udiff-line-modified-added">+         if (numberOfRemovedChildren)</span>
              m_state.setFoundConstants(true);
<span class="udiff-line-removed">-             if (numberOfRemovedChildren == numberOfChildren) {</span>
<span class="udiff-line-removed">-                 // Propagate the last child. This is the way taken in the constant folding phase.</span>
<span class="udiff-line-removed">-                 setForNode(node, forNode(node-&gt;children.child(numberOfChildren - 1)));</span>
<span class="udiff-line-removed">-                 break;</span>
<span class="udiff-line-removed">-             }</span>
<span class="udiff-line-removed">-             if ((numberOfRemovedChildren + 1) == numberOfChildren) {</span>
<span class="udiff-line-removed">-                 ASSERT(nonEmptyIndex);</span>
<span class="udiff-line-removed">-                 setForNode(node, forNode(node-&gt;children.child(nonEmptyIndex.value())));</span>
<span class="udiff-line-removed">-                 break;</span>
<span class="udiff-line-removed">-             }</span>
<span class="udiff-line-removed">-         }</span>
          setForNode(node, m_vm.stringStructure.get());
          break;
      }
  
      case ArithSub: {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -769,16 +836,16 @@</span>
              setNonCellTypeForNode(node, SpecInt32Only);
              break;
          case Int52RepUse:
              if (left &amp;&amp; right &amp;&amp; left.isAnyInt() &amp;&amp; right.isAnyInt()) {
                  JSValue result = jsNumber(left.asAnyInt() - right.asAnyInt());
<span class="udiff-line-modified-removed">-                 if (result.isAnyInt() || !shouldCheckOverflow(node-&gt;arithMode())) {</span>
<span class="udiff-line-modified-added">+                 if (result.isAnyInt()) {</span>
                      setConstant(node, result);
                      break;
                  }
              }
<span class="udiff-line-modified-removed">-             setNonCellTypeForNode(node, SpecAnyInt);</span>
<span class="udiff-line-modified-added">+             setNonCellTypeForNode(node, SpecInt52Any);</span>
              break;
          case DoubleRepUse:
              if (left &amp;&amp; right &amp;&amp; left.isNumber() &amp;&amp; right.isNumber()) {
                  setConstant(node, jsDoubleNumber(left.asNumber() - right.asNumber()));
                  break;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -837,11 +904,11 @@</span>
                  if (valueResult.isAnyInt()) {
                      setConstant(node, valueResult);
                      break;
                  }
              }
<span class="udiff-line-modified-removed">-             setNonCellTypeForNode(node, SpecAnyInt);</span>
<span class="udiff-line-modified-added">+             setNonCellTypeForNode(node, SpecInt52Any);</span>
              break;
          case DoubleRepUse:
              if (child &amp;&amp; child.isNumber()) {
                  setConstant(node, jsDoubleNumber(-child.asNumber()));
                  break;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -855,10 +922,31 @@</span>
              break;
          }
          break;
      }
  
<span class="udiff-line-added">+     case ValuePow: {</span>
<span class="udiff-line-added">+         JSValue childX = forNode(node-&gt;child1()).value();</span>
<span class="udiff-line-added">+         JSValue childY = forNode(node-&gt;child2()).value();</span>
<span class="udiff-line-added">+         if (childX &amp;&amp; childY &amp;&amp; childX.isNumber() &amp;&amp; childY.isNumber()) {</span>
<span class="udiff-line-added">+             // We need to call `didFoldClobberWorld` here because this path is only possible</span>
<span class="udiff-line-added">+             // when node-&gt;useKind is UntypedUse. In the case of BigIntUse, children will be</span>
<span class="udiff-line-added">+             // cleared by `AbstractInterpreter::executeEffects`.</span>
<span class="udiff-line-added">+             didFoldClobberWorld();</span>
<span class="udiff-line-added">+             setConstant(node, jsDoubleNumber(operationMathPow(childX.asNumber(), childY.asNumber())));</span>
<span class="udiff-line-added">+             break;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         if (node-&gt;binaryUseKind() == BigIntUse)</span>
<span class="udiff-line-added">+             setTypeForNode(node, SpecBigInt);</span>
<span class="udiff-line-added">+         else {</span>
<span class="udiff-line-added">+             clobberWorld();</span>
<span class="udiff-line-added">+             setTypeForNode(node, SpecBytecodeNumber | SpecBigInt);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         break;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
      case ValueMul: {
          if (node-&gt;binaryUseKind() == BigIntUse)
              setTypeForNode(node, SpecBigInt);
          else {
              clobberWorld();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -897,11 +985,11 @@</span>
                  if (valueResult.isAnyInt()) {
                      setConstant(node, valueResult);
                      break;
                  }
              }
<span class="udiff-line-modified-removed">-             setNonCellTypeForNode(node, SpecAnyInt);</span>
<span class="udiff-line-modified-added">+             setNonCellTypeForNode(node, SpecInt52Any);</span>
              break;
          case DoubleRepUse:
              if (left &amp;&amp; right &amp;&amp; left.isNumber() &amp;&amp; right.isNumber()) {
                  setConstant(node, jsDoubleNumber(left.asNumber() * right.asNumber()));
                  break;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -915,82 +1003,44 @@</span>
              break;
          }
          break;
      }
  
<span class="udiff-line-added">+     case ValueMod:</span>
      case ValueDiv: {
<span class="udiff-line-added">+         if (handleConstantDivOp(node))</span>
<span class="udiff-line-added">+             break;</span>
<span class="udiff-line-added">+ </span>
          if (node-&gt;binaryUseKind() == BigIntUse)
              setTypeForNode(node, SpecBigInt);
          else {
              clobberWorld();
              setTypeForNode(node, SpecBytecodeNumber | SpecBigInt);
          }
          break;
      }
  
<span class="udiff-line-added">+     case ArithMod:</span>
      case ArithDiv: {
<span class="udiff-line-modified-removed">-         JSValue left = forNode(node-&gt;child1()).value();</span>
<span class="udiff-line-removed">-         JSValue right = forNode(node-&gt;child2()).value();</span>
<span class="udiff-line-removed">-         switch (node-&gt;binaryUseKind()) {</span>
<span class="udiff-line-removed">-         case Int32Use:</span>
<span class="udiff-line-removed">-             if (left &amp;&amp; right &amp;&amp; left.isInt32() &amp;&amp; right.isInt32()) {</span>
<span class="udiff-line-removed">-                 double doubleResult = left.asNumber() / right.asNumber();</span>
<span class="udiff-line-removed">-                 if (!shouldCheckOverflow(node-&gt;arithMode()))</span>
<span class="udiff-line-removed">-                     doubleResult = toInt32(doubleResult);</span>
<span class="udiff-line-removed">-                 else if (!shouldCheckNegativeZero(node-&gt;arithMode()))</span>
<span class="udiff-line-removed">-                     doubleResult += 0; // Sanitizes zero.</span>
<span class="udiff-line-removed">-                 JSValue valueResult = jsNumber(doubleResult);</span>
<span class="udiff-line-removed">-                 if (valueResult.isInt32()) {</span>
<span class="udiff-line-removed">-                     setConstant(node, valueResult);</span>
<span class="udiff-line-removed">-                     break;</span>
<span class="udiff-line-removed">-                 }</span>
<span class="udiff-line-removed">-             }</span>
<span class="udiff-line-removed">-             setNonCellTypeForNode(node, SpecInt32Only);</span>
<span class="udiff-line-removed">-             break;</span>
<span class="udiff-line-removed">-         case DoubleRepUse:</span>
<span class="udiff-line-removed">-             if (left &amp;&amp; right &amp;&amp; left.isNumber() &amp;&amp; right.isNumber()) {</span>
<span class="udiff-line-removed">-                 setConstant(node, jsDoubleNumber(left.asNumber() / right.asNumber()));</span>
<span class="udiff-line-removed">-                 break;</span>
<span class="udiff-line-removed">-             }</span>
<span class="udiff-line-removed">-             setNonCellTypeForNode(node,</span>
<span class="udiff-line-removed">-                 typeOfDoubleQuotient(</span>
<span class="udiff-line-removed">-                     forNode(node-&gt;child1()).m_type, forNode(node-&gt;child2()).m_type));</span>
<span class="udiff-line-removed">-             break;</span>
<span class="udiff-line-removed">-         default:</span>
<span class="udiff-line-removed">-             RELEASE_ASSERT_NOT_REACHED();</span>
<span class="udiff-line-modified-added">+         if (handleConstantDivOp(node))</span>
              break;
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-         break;</span>
<span class="udiff-line-removed">-     }</span>
  
<span class="udiff-line-removed">-     case ArithMod: {</span>
<span class="udiff-line-removed">-         JSValue left = forNode(node-&gt;child1()).value();</span>
<span class="udiff-line-removed">-         JSValue right = forNode(node-&gt;child2()).value();</span>
          switch (node-&gt;binaryUseKind()) {
          case Int32Use:
<span class="udiff-line-removed">-             if (left &amp;&amp; right &amp;&amp; left.isInt32() &amp;&amp; right.isInt32()) {</span>
<span class="udiff-line-removed">-                 double doubleResult = fmod(left.asNumber(), right.asNumber());</span>
<span class="udiff-line-removed">-                 if (!shouldCheckOverflow(node-&gt;arithMode()))</span>
<span class="udiff-line-removed">-                     doubleResult = toInt32(doubleResult);</span>
<span class="udiff-line-removed">-                 else if (!shouldCheckNegativeZero(node-&gt;arithMode()))</span>
<span class="udiff-line-removed">-                     doubleResult += 0; // Sanitizes zero.</span>
<span class="udiff-line-removed">-                 JSValue valueResult = jsNumber(doubleResult);</span>
<span class="udiff-line-removed">-                 if (valueResult.isInt32()) {</span>
<span class="udiff-line-removed">-                     setConstant(node, valueResult);</span>
<span class="udiff-line-removed">-                     break;</span>
<span class="udiff-line-removed">-                 }</span>
<span class="udiff-line-removed">-             }</span>
              setNonCellTypeForNode(node, SpecInt32Only);
              break;
          case DoubleRepUse:
<span class="udiff-line-modified-removed">-             if (left &amp;&amp; right &amp;&amp; left.isNumber() &amp;&amp; right.isNumber()) {</span>
<span class="udiff-line-modified-removed">-                 setConstant(node, jsDoubleNumber(fmod(left.asNumber(), right.asNumber())));</span>
<span class="udiff-line-modified-removed">-                 break;</span>
<span class="udiff-line-modified-added">+             if (node-&gt;op() == ArithDiv) {</span>
<span class="udiff-line-modified-added">+                 setNonCellTypeForNode(node,</span>
<span class="udiff-line-modified-added">+                     typeOfDoubleQuotient(</span>
<span class="udiff-line-added">+                         forNode(node-&gt;child1()).m_type, forNode(node-&gt;child2()).m_type));</span>
<span class="udiff-line-added">+             } else {</span>
<span class="udiff-line-added">+                 setNonCellTypeForNode(node,</span>
<span class="udiff-line-added">+                     typeOfDoubleBinaryOp(</span>
<span class="udiff-line-added">+                         forNode(node-&gt;child1()).m_type, forNode(node-&gt;child2()).m_type));</span>
              }
<span class="udiff-line-modified-removed">-             setNonCellTypeForNode(node,</span>
<span class="udiff-line-removed">-                 typeOfDoubleBinaryOp(</span>
<span class="udiff-line-removed">-                     forNode(node-&gt;child1()).m_type, forNode(node-&gt;child2()).m_type));</span>
<span class="udiff-line-modified-added">+ </span>
              break;
          default:
              RELEASE_ASSERT_NOT_REACHED();
              break;
          }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2137,12 +2187,12 @@</span>
              setNonCellTypeForNode(node, SpecInt32Only);
              break;
          case Array::Uint32Array:
              if (node-&gt;shouldSpeculateInt32())
                  setNonCellTypeForNode(node, SpecInt32Only);
<span class="udiff-line-modified-removed">-             else if (enableInt52() &amp;&amp; node-&gt;shouldSpeculateAnyInt())</span>
<span class="udiff-line-modified-removed">-                 setNonCellTypeForNode(node, SpecAnyInt);</span>
<span class="udiff-line-modified-added">+             else if (node-&gt;shouldSpeculateInt52())</span>
<span class="udiff-line-modified-added">+                 setNonCellTypeForNode(node, SpecInt52Any);</span>
              else
                  setNonCellTypeForNode(node, SpecAnyIntAsDouble);
              break;
          case Array::Float32Array:
              setNonCellTypeForNode(node, SpecFullDouble);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2220,11 +2270,11 @@</span>
          break;
  
      case GetMyArgumentByVal:
      case GetMyArgumentByValOutOfBounds: {
          JSValue index = forNode(node-&gt;child2()).m_value;
<span class="udiff-line-modified-removed">-         InlineCallFrame* inlineCallFrame = node-&gt;child1()-&gt;origin.semantic.inlineCallFrame;</span>
<span class="udiff-line-modified-added">+         InlineCallFrame* inlineCallFrame = node-&gt;child1()-&gt;origin.semantic.inlineCallFrame();</span>
  
          if (index &amp;&amp; index.isUInt32()) {
              // This pretends to return TOP for accesses that are actually proven out-of-bounds because
              // that&#39;s the conservative thing to do. Otherwise we&#39;d need to write more code to mark such
              // paths as unreachable, or to return undefined. We could implement that eventually.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2538,11 +2588,11 @@</span>
          break;
  
      case ToThis: {
          AbstractValue&amp; source = forNode(node-&gt;child1());
          AbstractValue&amp; destination = forNode(node);
<span class="udiff-line-modified-removed">-         bool strictMode = m_graph.executableFor(node-&gt;origin.semantic)-&gt;isStrictMode();</span>
<span class="udiff-line-modified-added">+         bool strictMode = m_graph.isStrictModeFor(node-&gt;origin.semantic);</span>
  
          ToThisResult result = isToThisAnIdentity(m_vm, strictMode, source);
          switch (result) {
          case ToThisResult::Identity:
              m_state.setFoundConstants(true);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2592,21 +2642,24 @@</span>
          setForNode(node, node-&gt;structure());
          break;
  
      case ObjectCreate: {
          if (JSValue base = forNode(node-&gt;child1()).m_value) {
<span class="udiff-line-modified-removed">-             if (base.isNull()) {</span>
<span class="udiff-line-modified-removed">-                 JSGlobalObject* globalObject = m_graph.globalObjectFor(node-&gt;origin.semantic);</span>
<span class="udiff-line-modified-added">+             JSGlobalObject* globalObject = m_graph.globalObjectFor(node-&gt;origin.semantic);</span>
<span class="udiff-line-modified-added">+             Structure* structure = nullptr;</span>
<span class="udiff-line-added">+             if (base.isNull())</span>
<span class="udiff-line-added">+                 structure = globalObject-&gt;nullPrototypeObjectStructure();</span>
<span class="udiff-line-added">+             else if (base.isObject())</span>
<span class="udiff-line-added">+                 structure = globalObject-&gt;vm().structureCache.emptyObjectStructureConcurrently(globalObject, base.getObject(), JSFinalObject::defaultInlineCapacity());</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             if (structure) {</span>
                  m_state.setFoundConstants(true);
                  if (node-&gt;child1().useKind() == UntypedUse)
                      didFoldClobberWorld();
<span class="udiff-line-modified-removed">-                 setForNode(node, globalObject-&gt;nullPrototypeObjectStructure());</span>
<span class="udiff-line-modified-added">+                 setForNode(node, structure);</span>
                  break;
              }
<span class="udiff-line-removed">-             // FIXME: We should get a structure for a constant prototype. We need to allow concurrent</span>
<span class="udiff-line-removed">-             // access to StructureCache from compiler threads.</span>
<span class="udiff-line-removed">-             // https://bugs.webkit.org/show_bug.cgi?id=186199</span>
          }
          if (node-&gt;child1().useKind() == UntypedUse)
              clobberWorld();
          setTypeForNode(node, SpecFinalObject);
          break;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2729,19 +2782,17 @@</span>
          break;
      }
  
      case GetCallee:
          if (FunctionExecutable* executable = jsDynamicCast&lt;FunctionExecutable*&gt;(m_vm, m_codeBlock-&gt;ownerExecutable())) {
<span class="udiff-line-modified-removed">-             InferredValue* singleton = executable-&gt;singletonFunction();</span>
<span class="udiff-line-modified-removed">-             if (JSValue value = singleton-&gt;inferredValue()) {</span>
<span class="udiff-line-removed">-                 m_graph.watchpoints().addLazily(singleton);</span>
<span class="udiff-line-removed">-                 JSFunction* function = jsCast&lt;JSFunction*&gt;(value);</span>
<span class="udiff-line-modified-added">+             if (JSFunction* function = executable-&gt;singleton().inferredValue()) {</span>
<span class="udiff-line-modified-added">+                 m_graph.watchpoints().addLazily(executable);</span>
                  setConstant(node, *m_graph.freeze(function));
                  break;
              }
          }
<span class="udiff-line-modified-removed">-         setTypeForNode(node, SpecFunction);</span>
<span class="udiff-line-modified-added">+         setTypeForNode(node, SpecFunction | SpecObjectOther);</span>
          break;
  
      case GetArgumentCountIncludingThis:
          setTypeForNode(node, SpecInt32Only);
          break;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2753,28 +2804,26 @@</span>
      case GetRestLength:
          setNonCellTypeForNode(node, SpecInt32Only);
          break;
  
      case GetGetter: {
<span class="udiff-line-modified-removed">-         JSValue base = forNode(node-&gt;child1()).m_value;</span>
<span class="udiff-line-modified-removed">-         if (base) {</span>
<span class="udiff-line-modified-removed">-             GetterSetter* getterSetter = jsCast&lt;GetterSetter*&gt;(base);</span>
<span class="udiff-line-removed">-             if (!getterSetter-&gt;isGetterNull()) {</span>
<span class="udiff-line-modified-added">+         if (JSValue base = forNode(node-&gt;child1()).m_value) {</span>
<span class="udiff-line-modified-added">+             GetterSetter* getterSetter = jsDynamicCast&lt;GetterSetter*&gt;(m_vm, base);</span>
<span class="udiff-line-modified-added">+             if (getterSetter &amp;&amp; !getterSetter-&gt;isGetterNull()) {</span>
                  setConstant(node, *m_graph.freeze(getterSetter-&gt;getterConcurrently()));
                  break;
              }
          }
  
          setTypeForNode(node, SpecObject);
          break;
      }
  
      case GetSetter: {
<span class="udiff-line-modified-removed">-         JSValue base = forNode(node-&gt;child1()).m_value;</span>
<span class="udiff-line-modified-removed">-         if (base) {</span>
<span class="udiff-line-modified-removed">-             GetterSetter* getterSetter = jsCast&lt;GetterSetter*&gt;(base);</span>
<span class="udiff-line-removed">-             if (!getterSetter-&gt;isSetterNull()) {</span>
<span class="udiff-line-modified-added">+         if (JSValue base = forNode(node-&gt;child1()).m_value) {</span>
<span class="udiff-line-modified-added">+             GetterSetter* getterSetter = jsDynamicCast&lt;GetterSetter*&gt;(m_vm, base);</span>
<span class="udiff-line-modified-added">+             if (getterSetter &amp;&amp; !getterSetter-&gt;isSetterNull()) {</span>
                  setConstant(node, *m_graph.freeze(getterSetter-&gt;setterConcurrently()));
                  break;
              }
          }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2791,14 +2840,17 @@</span>
          }
          setTypeForNode(node, SpecObjectOther);
          break;
  
      case SkipScope: {
<span class="udiff-line-modified-removed">-         JSValue child = forNode(node-&gt;child1()).value();</span>
<span class="udiff-line-modified-removed">-         if (child) {</span>
<span class="udiff-line-modified-removed">-             setConstant(node, *m_graph.freeze(JSValue(jsCast&lt;JSScope*&gt;(child.asCell())-&gt;next())));</span>
<span class="udiff-line-modified-removed">-             break;</span>
<span class="udiff-line-modified-added">+         if (JSValue child = forNode(node-&gt;child1()).value()) {</span>
<span class="udiff-line-modified-added">+             if (JSScope* scope = jsDynamicCast&lt;JSScope*&gt;(m_vm, child)) {</span>
<span class="udiff-line-modified-added">+                 if (JSScope* nextScope = scope-&gt;next()) {</span>
<span class="udiff-line-modified-added">+                     setConstant(node, *m_graph.freeze(JSValue(nextScope)));</span>
<span class="udiff-line-added">+                     break;</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+             }</span>
          }
          setTypeForNode(node, SpecObjectOther);
          break;
      }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3285,17 +3337,23 @@</span>
          break;
      }
  
      case GetGetterSetterByOffset: {
          StorageAccessData&amp; data = node-&gt;storageAccessData();
<span class="udiff-line-modified-removed">-         JSValue result = m_graph.tryGetConstantProperty(forNode(node-&gt;child2()), data.offset);</span>
<span class="udiff-line-modified-added">+         AbstractValue base = forNode(node-&gt;child2());</span>
<span class="udiff-line-added">+         JSValue result = m_graph.tryGetConstantProperty(base, data.offset);</span>
          if (result &amp;&amp; jsDynamicCast&lt;GetterSetter*&gt;(m_vm, result)) {
              setConstant(node, *m_graph.freeze(result));
              break;
          }
  
<span class="udiff-line-modified-removed">-         setForNode(node, m_graph.globalObjectFor(node-&gt;origin.semantic)-&gt;getterSetterStructure());</span>
<span class="udiff-line-modified-added">+         if (base.value() &amp;&amp; base.value().isObject()) {</span>
<span class="udiff-line-added">+             setForNode(node, asObject(base.value())-&gt;globalObject()-&gt;getterSetterStructure());</span>
<span class="udiff-line-added">+             break;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         setTypeForNode(node, SpecObjectOther);</span>
          break;
      }
  
      case MultiGetByOffset: {
          // This code will filter the base value in a manner that is possibly different (either more
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3547,11 +3605,11 @@</span>
          AbstractValue&amp; property = forNode(node-&gt;child2());
          if (JSValue constant = property.value()) {
              if (constant.isString()) {
                  JSString* string = asString(constant);
                  const StringImpl* impl = string-&gt;tryGetValueImpl();
<span class="udiff-line-modified-removed">-                 if (impl &amp;&amp; impl-&gt;isAtomic())</span>
<span class="udiff-line-modified-added">+                 if (impl &amp;&amp; impl-&gt;isAtom())</span>
                      m_state.setFoundConstants(true);
              }
          }
  
          // FIXME: We can determine when the property definitely exists based on abstract
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3882,11 +3940,11 @@</span>
          else {
              ASSERT(data.byteSize == 4);
              if (data.isSigned)
                  setNonCellTypeForNode(node, SpecInt32Only);
              else
<span class="udiff-line-modified-removed">-                 setNonCellTypeForNode(node, SpecAnyInt);</span>
<span class="udiff-line-modified-added">+                 setNonCellTypeForNode(node, SpecInt52Any);</span>
          }
          break;
      }
  
      case DataViewGetFloat: {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4034,10 +4092,18 @@</span>
  
  template&lt;typename AbstractStateType&gt;
  void AbstractInterpreter&lt;AbstractStateType&gt;::observeTransition(
      unsigned clobberLimit, RegisteredStructure from, RegisteredStructure to)
  {
<span class="udiff-line-added">+     // Stop performing precise structure transition tracking.</span>
<span class="udiff-line-added">+     // Precise structure transition tracking shows quadratic complexity for # of nodes in a basic block.</span>
<span class="udiff-line-added">+     // If it is too large, we conservatively clobber all the structures.</span>
<span class="udiff-line-added">+     if (m_state.block()-&gt;size() &gt; Options::maxDFGNodesInBasicBlockForPreciseAnalysis()) {</span>
<span class="udiff-line-added">+         clobberStructures();</span>
<span class="udiff-line-added">+         return;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
      AbstractValue::TransitionObserver transitionObserver(from, to);
      forAllValues(clobberLimit, transitionObserver);
  
      ASSERT(!from-&gt;dfgShouldWatch()); // We don&#39;t need to claim to be in a clobbered state because &#39;from&#39; was never watchable (during the time we were compiling), hence no constants ever introduced into the DFG IR that ever had a watchable structure would ever have the same structure as from.
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4049,10 +4115,18 @@</span>
      unsigned clobberLimit, const TransitionVector&amp; vector)
  {
      if (vector.isEmpty())
          return;
  
<span class="udiff-line-added">+     // Stop performing precise structure transition tracking.</span>
<span class="udiff-line-added">+     // Precise structure transition tracking shows quadratic complexity for # of nodes in a basic block.</span>
<span class="udiff-line-added">+     // If it is too large, we conservatively clobber all the structures.</span>
<span class="udiff-line-added">+     if (m_state.block()-&gt;size() &gt; Options::maxDFGNodesInBasicBlockForPreciseAnalysis()) {</span>
<span class="udiff-line-added">+         clobberStructures();</span>
<span class="udiff-line-added">+         return;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
      AbstractValue::TransitionsObserver transitionsObserver(vector);
      forAllValues(clobberLimit, transitionsObserver);
  
      if (!ASSERT_DISABLED) {
          // We don&#39;t need to claim to be in a clobbered state because none of the Transition::previous structures are watchable.
</pre>
<center><a href="DFGAbstractInterpreter.h.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DFGAbstractValue.cpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>