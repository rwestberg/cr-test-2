<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.web/src/main/native/Source/WebCore/accessibility/AccessibilityRenderObject.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2 * Copyright (C) 2008-2019 Apple Inc. All rights reserved.
   3 *
   4 * Redistribution and use in source and binary forms, with or without
   5 * modification, are permitted provided that the following conditions
   6 * are met:
   7 *
   8 * 1.  Redistributions of source code must retain the above copyright
   9 *     notice, this list of conditions and the following disclaimer.
  10 * 2.  Redistributions in binary form must reproduce the above copyright
  11 *     notice, this list of conditions and the following disclaimer in the
  12 *     documentation and/or other materials provided with the distribution.
  13 * 3.  Neither the name of Apple Inc. (&quot;Apple&quot;) nor the names of
  14 *     its contributors may be used to endorse or promote products derived
  15 *     from this software without specific prior written permission.
  16 *
  17 * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS &quot;AS IS&quot; AND ANY
  18 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  19 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  20 * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
  21 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  22 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  23 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  24 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  25 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  26 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  27 */
  28 
  29 #include &quot;config.h&quot;
  30 #include &quot;AccessibilityRenderObject.h&quot;
  31 
  32 #include &quot;AXObjectCache.h&quot;
  33 #include &quot;AccessibilityImageMapLink.h&quot;
  34 #include &quot;AccessibilityLabel.h&quot;
  35 #include &quot;AccessibilityListBox.h&quot;
  36 #include &quot;AccessibilitySVGRoot.h&quot;
  37 #include &quot;AccessibilitySpinButton.h&quot;
  38 #include &quot;AccessibilityTable.h&quot;
  39 #include &quot;CachedImage.h&quot;
  40 #include &quot;Editing.h&quot;
  41 #include &quot;ElementIterator.h&quot;
  42 #include &quot;FloatRect.h&quot;
  43 #include &quot;Frame.h&quot;
  44 #include &quot;FrameLoader.h&quot;
  45 #include &quot;FrameSelection.h&quot;
  46 #include &quot;HTMLAreaElement.h&quot;
  47 #include &quot;HTMLAudioElement.h&quot;
  48 #include &quot;HTMLDetailsElement.h&quot;
  49 #include &quot;HTMLFormElement.h&quot;
  50 #include &quot;HTMLFrameElementBase.h&quot;
  51 #include &quot;HTMLImageElement.h&quot;
  52 #include &quot;HTMLInputElement.h&quot;
  53 #include &quot;HTMLLabelElement.h&quot;
  54 #include &quot;HTMLMapElement.h&quot;
  55 #include &quot;HTMLMeterElement.h&quot;
  56 #include &quot;HTMLNames.h&quot;
  57 #include &quot;HTMLOptionElement.h&quot;
  58 #include &quot;HTMLOptionsCollection.h&quot;
  59 #include &quot;HTMLSelectElement.h&quot;
  60 #include &quot;HTMLSummaryElement.h&quot;
  61 #include &quot;HTMLTableElement.h&quot;
  62 #include &quot;HTMLTextAreaElement.h&quot;
  63 #include &quot;HTMLVideoElement.h&quot;
  64 #include &quot;HitTestRequest.h&quot;
  65 #include &quot;HitTestResult.h&quot;
  66 #include &quot;Image.h&quot;
  67 #include &quot;LocalizedStrings.h&quot;
  68 #include &quot;NodeList.h&quot;
  69 #include &quot;Page.h&quot;
  70 #include &quot;ProgressTracker.h&quot;
  71 #include &quot;RenderButton.h&quot;
  72 #include &quot;RenderFileUploadControl.h&quot;
  73 #include &quot;RenderHTMLCanvas.h&quot;
  74 #include &quot;RenderImage.h&quot;
  75 #include &quot;RenderInline.h&quot;
  76 #include &quot;RenderIterator.h&quot;
  77 #include &quot;RenderLayer.h&quot;
  78 #include &quot;RenderLineBreak.h&quot;
  79 #include &quot;RenderListBox.h&quot;
  80 #include &quot;RenderListItem.h&quot;
  81 #include &quot;RenderListMarker.h&quot;
  82 #include &quot;RenderMathMLBlock.h&quot;
  83 #include &quot;RenderMenuList.h&quot;
  84 #include &quot;RenderSVGRoot.h&quot;
  85 #include &quot;RenderSVGShape.h&quot;
  86 #include &quot;RenderTableCell.h&quot;
  87 #include &quot;RenderText.h&quot;
  88 #include &quot;RenderTextControl.h&quot;
  89 #include &quot;RenderTextControlSingleLine.h&quot;
  90 #include &quot;RenderTextFragment.h&quot;
  91 #include &quot;RenderTheme.h&quot;
  92 #include &quot;RenderView.h&quot;
  93 #include &quot;RenderWidget.h&quot;
  94 #include &quot;RenderedPosition.h&quot;
  95 #include &quot;SVGDocument.h&quot;
  96 #include &quot;SVGImage.h&quot;
  97 #include &quot;SVGSVGElement.h&quot;
  98 #include &quot;Text.h&quot;
  99 #include &quot;TextControlInnerElements.h&quot;
 100 #include &quot;TextIterator.h&quot;
 101 #include &quot;VisibleUnits.h&quot;
 102 #include &lt;wtf/NeverDestroyed.h&gt;
 103 #include &lt;wtf/StdLibExtras.h&gt;
 104 #include &lt;wtf/unicode/CharacterNames.h&gt;
 105 
 106 namespace WebCore {
 107 
 108 using namespace HTMLNames;
 109 
 110 AccessibilityRenderObject::AccessibilityRenderObject(RenderObject* renderer)
 111     : AccessibilityNodeObject(renderer-&gt;node())
 112     , m_renderer(makeWeakPtr(renderer))
 113 {
 114 #ifndef NDEBUG
 115     m_renderer-&gt;setHasAXObject(true);
 116 #endif
 117 }
 118 
 119 AccessibilityRenderObject::~AccessibilityRenderObject()
 120 {
 121     ASSERT(isDetached());
 122 }
 123 
 124 void AccessibilityRenderObject::init()
 125 {
 126     AccessibilityNodeObject::init();
 127 }
 128 
 129 Ref&lt;AccessibilityRenderObject&gt; AccessibilityRenderObject::create(RenderObject* renderer)
 130 {
 131     return adoptRef(*new AccessibilityRenderObject(renderer));
 132 }
 133 
 134 void AccessibilityRenderObject::detach(AccessibilityDetachmentType detachmentType, AXObjectCache* cache)
 135 {
 136     AccessibilityNodeObject::detach(detachmentType, cache);
 137 
 138     detachRemoteSVGRoot();
 139 
 140 #ifndef NDEBUG
 141     if (m_renderer)
 142         m_renderer-&gt;setHasAXObject(false);
 143 #endif
 144     m_renderer = nullptr;
 145 }
 146 
 147 RenderBoxModelObject* AccessibilityRenderObject::renderBoxModelObject() const
 148 {
 149     if (!is&lt;RenderBoxModelObject&gt;(renderer()))
 150         return nullptr;
 151     return downcast&lt;RenderBoxModelObject&gt;(renderer());
 152 }
 153 
 154 void AccessibilityRenderObject::setRenderer(RenderObject* renderer)
 155 {
 156     m_renderer = makeWeakPtr(renderer);
 157     setNode(renderer-&gt;node());
 158 }
 159 
 160 static inline bool isInlineWithContinuation(RenderObject&amp; object)
 161 {
 162     return is&lt;RenderInline&gt;(object) &amp;&amp; downcast&lt;RenderInline&gt;(object).continuation();
 163 }
 164 
 165 static inline RenderObject* firstChildInContinuation(RenderInline&amp; renderer)
 166 {
 167     auto* continuation = renderer.continuation();
 168 
 169     while (continuation) {
 170         if (is&lt;RenderBlock&gt;(*continuation))
 171             return continuation;
 172         if (RenderObject* child = continuation-&gt;firstChild())
 173             return child;
 174         continuation = downcast&lt;RenderInline&gt;(*continuation).continuation();
 175     }
 176 
 177     return nullptr;
 178 }
 179 
 180 static inline RenderObject* firstChildConsideringContinuation(RenderObject&amp; renderer)
 181 {
 182     RenderObject* firstChild = renderer.firstChildSlow();
 183 
 184     // We don&#39;t want to include the end of a continuation as the firstChild of the
 185     // anonymous parent, because everything has already been linked up via continuation.
 186     // CSS first-letter selector is an example of this case.
 187     if (renderer.isAnonymous() &amp;&amp; is&lt;RenderInline&gt;(firstChild) &amp;&amp; downcast&lt;RenderInline&gt;(*firstChild).isContinuation())
 188         firstChild = nullptr;
 189 
 190     if (!firstChild &amp;&amp; isInlineWithContinuation(renderer))
 191         firstChild = firstChildInContinuation(downcast&lt;RenderInline&gt;(renderer));
 192 
 193     return firstChild;
 194 }
 195 
 196 
 197 static inline RenderObject* lastChildConsideringContinuation(RenderObject&amp; renderer)
 198 {
 199     if (!is&lt;RenderInline&gt;(renderer) &amp;&amp; !is&lt;RenderBlock&gt;(renderer))
 200         return &amp;renderer;
 201 
 202     RenderObject* lastChild = downcast&lt;RenderBoxModelObject&gt;(renderer).lastChild();
 203     for (auto* current = &amp;downcast&lt;RenderBoxModelObject&gt;(renderer); current; ) {
 204         if (RenderObject* newLastChild = current-&gt;lastChild())
 205             lastChild = newLastChild;
 206 
 207         current = current-&gt;inlineContinuation();
 208     }
 209 
 210     return lastChild;
 211 }
 212 
 213 AccessibilityObject* AccessibilityRenderObject::firstChild() const
 214 {
 215     if (!m_renderer)
 216         return nullptr;
 217 
 218     RenderObject* firstChild = firstChildConsideringContinuation(*m_renderer);
 219 
 220     // If an object can&#39;t have children, then it is using this method to help
 221     // calculate some internal property (like its description).
 222     // In this case, it should check the Node level for children in case they&#39;re
 223     // not rendered (like a &lt;meter&gt; element).
 224     if (!firstChild &amp;&amp; !canHaveChildren())
 225         return AccessibilityNodeObject::firstChild();
 226 
 227     return axObjectCache()-&gt;getOrCreate(firstChild);
 228 }
 229 
 230 AccessibilityObject* AccessibilityRenderObject::lastChild() const
 231 {
 232     if (!m_renderer)
 233         return nullptr;
 234 
 235     RenderObject* lastChild = lastChildConsideringContinuation(*m_renderer);
 236 
 237     if (!lastChild &amp;&amp; !canHaveChildren())
 238         return AccessibilityNodeObject::lastChild();
 239 
 240     return axObjectCache()-&gt;getOrCreate(lastChild);
 241 }
 242 
 243 static inline RenderInline* startOfContinuations(RenderObject&amp; renderer)
 244 {
 245     if (!is&lt;RenderElement&gt;(renderer))
 246         return nullptr;
 247     auto&amp; renderElement = downcast&lt;RenderElement&gt;(renderer);
 248     if (is&lt;RenderInline&gt;(renderElement) &amp;&amp; renderElement.isContinuation() &amp;&amp; is&lt;RenderInline&gt;(renderElement.element()-&gt;renderer()))
 249         return downcast&lt;RenderInline&gt;(renderer.node()-&gt;renderer());
 250 
 251     // Blocks with a previous continuation always have a next continuation
 252     if (is&lt;RenderBlock&gt;(renderElement) &amp;&amp; downcast&lt;RenderBlock&gt;(renderElement).inlineContinuation())
 253         return downcast&lt;RenderInline&gt;(downcast&lt;RenderBlock&gt;(renderElement).inlineContinuation()-&gt;element()-&gt;renderer());
 254 
 255     return nullptr;
 256 }
 257 
 258 static inline RenderObject* endOfContinuations(RenderObject&amp; renderer)
 259 {
 260     if (!is&lt;RenderInline&gt;(renderer) &amp;&amp; !is&lt;RenderBlock&gt;(renderer))
 261         return &amp;renderer;
 262 
 263     auto* previous = &amp;downcast&lt;RenderBoxModelObject&gt;(renderer);
 264     for (auto* current = previous; current; ) {
 265         previous = current;
 266         current = current-&gt;inlineContinuation();
 267     }
 268 
 269     return previous;
 270 }
 271 
 272 
 273 static inline RenderObject* childBeforeConsideringContinuations(RenderInline* renderer, RenderObject* child)
 274 {
 275     RenderObject* previous = nullptr;
 276     for (RenderBoxModelObject* currentContainer = renderer; currentContainer; ) {
 277         if (is&lt;RenderInline&gt;(*currentContainer)) {
 278             auto* current = currentContainer-&gt;firstChild();
 279             while (current) {
 280                 if (current == child)
 281                     return previous;
 282                 previous = current;
 283                 current = current-&gt;nextSibling();
 284             }
 285 
 286             currentContainer = currentContainer-&gt;continuation();
 287         } else if (is&lt;RenderBlock&gt;(*currentContainer)) {
 288             if (currentContainer == child)
 289                 return previous;
 290 
 291             previous = currentContainer;
 292             currentContainer = currentContainer-&gt;inlineContinuation();
 293         }
 294     }
 295 
 296     ASSERT_NOT_REACHED();
 297     return nullptr;
 298 }
 299 
 300 static inline bool firstChildIsInlineContinuation(RenderElement&amp; renderer)
 301 {
 302     RenderObject* child = renderer.firstChild();
 303     return is&lt;RenderInline&gt;(child) &amp;&amp; downcast&lt;RenderInline&gt;(*child).isContinuation();
 304 }
 305 
 306 AccessibilityObject* AccessibilityRenderObject::previousSibling() const
 307 {
 308     if (!m_renderer)
 309         return nullptr;
 310 
 311     RenderObject* previousSibling = nullptr;
 312 
 313     // Case 1: The node is a block and is an inline&#39;s continuation. In that case, the inline&#39;s
 314     // last child is our previous sibling (or further back in the continuation chain)
 315     RenderInline* startOfConts;
 316     if (is&lt;RenderBox&gt;(*m_renderer) &amp;&amp; (startOfConts = startOfContinuations(*m_renderer)))
 317         previousSibling = childBeforeConsideringContinuations(startOfConts, renderer());
 318 
 319     // Case 2: Anonymous block parent of the end of a continuation - skip all the way to before
 320     // the parent of the start, since everything in between will be linked up via the continuation.
 321     else if (m_renderer-&gt;isAnonymousBlock() &amp;&amp; firstChildIsInlineContinuation(downcast&lt;RenderBlock&gt;(*m_renderer))) {
 322         RenderBlock&amp; renderBlock = downcast&lt;RenderBlock&gt;(*m_renderer);
 323         auto* firstParent = startOfContinuations(*renderBlock.firstChild())-&gt;parent();
 324         ASSERT(firstParent);
 325         while (firstChildIsInlineContinuation(*firstParent))
 326             firstParent = startOfContinuations(*firstParent-&gt;firstChild())-&gt;parent();
 327         previousSibling = firstParent-&gt;previousSibling();
 328     }
 329 
 330     // Case 3: The node has an actual previous sibling
 331     else if (RenderObject* ps = m_renderer-&gt;previousSibling())
 332         previousSibling = ps;
 333 
 334     // Case 4: This node has no previous siblings, but its parent is an inline,
 335     // and is another node&#39;s inline continutation. Follow the continuation chain.
 336     else if (is&lt;RenderInline&gt;(*m_renderer-&gt;parent()) &amp;&amp; (startOfConts = startOfContinuations(*m_renderer-&gt;parent())))
 337         previousSibling = childBeforeConsideringContinuations(startOfConts, m_renderer-&gt;parent()-&gt;firstChild());
 338 
 339     if (!previousSibling)
 340         return nullptr;
 341 
 342     return axObjectCache()-&gt;getOrCreate(previousSibling);
 343 }
 344 
 345 static inline bool lastChildHasContinuation(RenderElement&amp; renderer)
 346 {
 347     RenderObject* child = renderer.lastChild();
 348     return child &amp;&amp; isInlineWithContinuation(*child);
 349 }
 350 
 351 AccessibilityObject* AccessibilityRenderObject::nextSibling() const
 352 {
 353     if (!m_renderer)
 354         return nullptr;
 355 
 356     RenderObject* nextSibling = nullptr;
 357 
 358     // Case 1: node is a block and has an inline continuation. Next sibling is the inline continuation&#39;s
 359     // first child.
 360     RenderInline* inlineContinuation;
 361     if (is&lt;RenderBlock&gt;(*m_renderer) &amp;&amp; (inlineContinuation = downcast&lt;RenderBlock&gt;(*m_renderer).inlineContinuation()))
 362         nextSibling = firstChildConsideringContinuation(*inlineContinuation);
 363 
 364     // Case 2: Anonymous block parent of the start of a continuation - skip all the way to
 365     // after the parent of the end, since everything in between will be linked up via the continuation.
 366     else if (m_renderer-&gt;isAnonymousBlock() &amp;&amp; lastChildHasContinuation(downcast&lt;RenderBlock&gt;(*m_renderer))) {
 367         RenderElement* lastParent = endOfContinuations(*downcast&lt;RenderBlock&gt;(*m_renderer).lastChild())-&gt;parent();
 368         ASSERT(lastParent);
 369         while (lastChildHasContinuation(*lastParent))
 370             lastParent = endOfContinuations(*lastParent-&gt;lastChild())-&gt;parent();
 371         nextSibling = lastParent-&gt;nextSibling();
 372     }
 373 
 374     // Case 3: node has an actual next sibling
 375     else if (RenderObject* ns = m_renderer-&gt;nextSibling())
 376         nextSibling = ns;
 377 
 378     // Case 4: node is an inline with a continuation. Next sibling is the next sibling of the end
 379     // of the continuation chain.
 380     else if (isInlineWithContinuation(*m_renderer))
 381         nextSibling = endOfContinuations(*m_renderer)-&gt;nextSibling();
 382 
 383     // Case 5: node has no next sibling, and its parent is an inline with a continuation.
 384     // Case 5.1: After case 4, (the element was inline w/ continuation but had no sibling), then check it&#39;s parent.
 385     if (!nextSibling &amp;&amp; isInlineWithContinuation(*m_renderer-&gt;parent())) {
 386         auto&amp; continuation = *downcast&lt;RenderInline&gt;(*m_renderer-&gt;parent()).continuation();
 387 
 388         // Case 5a: continuation is a block - in this case the block itself is the next sibling.
 389         if (is&lt;RenderBlock&gt;(continuation))
 390             nextSibling = &amp;continuation;
 391         // Case 5b: continuation is an inline - in this case the inline&#39;s first child is the next sibling
 392         else
 393             nextSibling = firstChildConsideringContinuation(continuation);
 394 
 395         // After case 4, there are chances that nextSibling has the same node as the current renderer,
 396         // which might lead to adding the same child repeatedly.
 397         if (nextSibling &amp;&amp; nextSibling-&gt;node() == m_renderer-&gt;node()) {
 398             if (AccessibilityObject* nextObj = axObjectCache()-&gt;getOrCreate(nextSibling))
 399                 return nextObj-&gt;nextSibling();
 400         }
 401     }
 402 
 403     if (!nextSibling)
 404         return nullptr;
 405 
 406     // Make sure next sibling has the same parent.
 407     AccessibilityObject* nextObj = axObjectCache()-&gt;getOrCreate(nextSibling);
 408     if (nextObj &amp;&amp; nextObj-&gt;parentObject() != this-&gt;parentObject())
 409         return nullptr;
 410 
 411     return nextObj;
 412 }
 413 
 414 static RenderBoxModelObject* nextContinuation(RenderObject&amp; renderer)
 415 {
 416     if (is&lt;RenderInline&gt;(renderer) &amp;&amp; !renderer.isReplaced())
 417         return downcast&lt;RenderInline&gt;(renderer).continuation();
 418     if (is&lt;RenderBlock&gt;(renderer))
 419         return downcast&lt;RenderBlock&gt;(renderer).inlineContinuation();
 420     return nullptr;
 421 }
 422 
 423 RenderObject* AccessibilityRenderObject::renderParentObject() const
 424 {
 425     if (!m_renderer)
 426         return nullptr;
 427 
 428     RenderElement* parent = m_renderer-&gt;parent();
 429 
 430     // Case 1: node is a block and is an inline&#39;s continuation. Parent
 431     // is the start of the continuation chain.
 432     RenderInline* startOfConts = nullptr;
 433     RenderObject* firstChild = nullptr;
 434     if (is&lt;RenderBlock&gt;(*m_renderer) &amp;&amp; (startOfConts = startOfContinuations(*m_renderer)))
 435         parent = startOfConts;
 436 
 437     // Case 2: node&#39;s parent is an inline which is some node&#39;s continuation; parent is
 438     // the earliest node in the continuation chain.
 439     else if (is&lt;RenderInline&gt;(parent) &amp;&amp; (startOfConts = startOfContinuations(*parent)))
 440         parent = startOfConts;
 441 
 442     // Case 3: The first sibling is the beginning of a continuation chain. Find the origin of that continuation.
 443     else if (parent &amp;&amp; (firstChild = parent-&gt;firstChild()) &amp;&amp; firstChild-&gt;node()) {
 444         // Get the node&#39;s renderer and follow that continuation chain until the first child is found
 445         RenderObject* nodeRenderFirstChild = firstChild-&gt;node()-&gt;renderer();
 446         while (nodeRenderFirstChild != firstChild) {
 447             for (RenderObject* contsTest = nodeRenderFirstChild; contsTest; contsTest = nextContinuation(*contsTest)) {
 448                 if (contsTest == firstChild) {
 449                     parent = nodeRenderFirstChild-&gt;parent();
 450                     break;
 451                 }
 452             }
 453             RenderObject* parentFirstChild = parent-&gt;firstChild();
 454             if (firstChild == parentFirstChild)
 455                 break;
 456             firstChild = parentFirstChild;
 457             if (!firstChild-&gt;node())
 458                 break;
 459             nodeRenderFirstChild = firstChild-&gt;node()-&gt;renderer();
 460         }
 461     }
 462 
 463     return parent;
 464 }
 465 
 466 AccessibilityObject* AccessibilityRenderObject::parentObjectIfExists() const
 467 {
 468     AXObjectCache* cache = axObjectCache();
 469     if (!cache)
 470         return nullptr;
 471 
 472     // WebArea&#39;s parent should be the scroll view containing it.
 473     if (isWebArea())
 474         return cache-&gt;get(&amp;m_renderer-&gt;view().frameView());
 475 
 476     return cache-&gt;get(renderParentObject());
 477 }
 478 
 479 AccessibilityObject* AccessibilityRenderObject::parentObject() const
 480 {
 481     if (!m_renderer)
 482         return nullptr;
 483 
 484     if (ariaRoleAttribute() == AccessibilityRole::MenuBar)
 485         return axObjectCache()-&gt;getOrCreate(m_renderer-&gt;parent());
 486 
 487     // menuButton and its corresponding menu are DOM siblings, but Accessibility needs them to be parent/child
 488     if (ariaRoleAttribute() == AccessibilityRole::Menu) {
 489         AccessibilityObject* parent = menuButtonForMenu();
 490         if (parent)
 491             return parent;
 492     }
 493 
 494     AXObjectCache* cache = axObjectCache();
 495     if (!cache)
 496         return nullptr;
 497 
 498     RenderObject* parentObj = renderParentObject();
 499     if (parentObj)
 500         return cache-&gt;getOrCreate(parentObj);
 501 
 502     // WebArea&#39;s parent should be the scroll view containing it.
 503     if (isWebArea())
 504         return cache-&gt;getOrCreate(&amp;m_renderer-&gt;view().frameView());
 505 
 506     return nullptr;
 507 }
 508 
 509 bool AccessibilityRenderObject::isAttachment() const
 510 {
 511     RenderBoxModelObject* renderer = renderBoxModelObject();
 512     if (!renderer)
 513         return false;
 514     // Widgets are the replaced elements that we represent to AX as attachments
 515     bool isWidget = renderer-&gt;isWidget();
 516 
 517     return isWidget &amp;&amp; ariaRoleAttribute() == AccessibilityRole::Unknown;
 518 }
 519 
 520 bool AccessibilityRenderObject::isFileUploadButton() const
 521 {
 522     if (m_renderer &amp;&amp; is&lt;HTMLInputElement&gt;(m_renderer-&gt;node())) {
 523         HTMLInputElement&amp; input = downcast&lt;HTMLInputElement&gt;(*m_renderer-&gt;node());
 524         return input.isFileUpload();
 525     }
 526 
 527     return false;
 528 }
 529 
 530 bool AccessibilityRenderObject::isOffScreen() const
 531 {
 532     if (!m_renderer)
 533         return true;
 534 
 535     IntRect contentRect = snappedIntRect(m_renderer-&gt;absoluteClippedOverflowRect());
 536     // FIXME: unclear if we need LegacyIOSDocumentVisibleRect.
 537     IntRect viewRect = m_renderer-&gt;view().frameView().visibleContentRect(ScrollableArea::LegacyIOSDocumentVisibleRect);
 538     viewRect.intersect(contentRect);
 539     return viewRect.isEmpty();
 540 }
 541 
 542 Element* AccessibilityRenderObject::anchorElement() const
 543 {
 544     if (!m_renderer)
 545         return nullptr;
 546 
 547     AXObjectCache* cache = axObjectCache();
 548     if (!cache)
 549         return nullptr;
 550 
 551     RenderObject* currentRenderer;
 552 
 553     // Search up the render tree for a RenderObject with a DOM node.  Defer to an earlier continuation, though.
 554     for (currentRenderer = renderer(); currentRenderer &amp;&amp; !currentRenderer-&gt;node(); currentRenderer = currentRenderer-&gt;parent()) {
 555         if (currentRenderer-&gt;isAnonymousBlock()) {
 556             if (RenderObject* continuation = downcast&lt;RenderBlock&gt;(*currentRenderer).continuation())
 557                 return cache-&gt;getOrCreate(continuation)-&gt;anchorElement();
 558         }
 559     }
 560 
 561     // bail if none found
 562     if (!currentRenderer)
 563         return nullptr;
 564 
 565     // search up the DOM tree for an anchor element
 566     // NOTE: this assumes that any non-image with an anchor is an HTMLAnchorElement
 567     for (Node* node = currentRenderer-&gt;node(); node; node = node-&gt;parentNode()) {
 568         if (is&lt;HTMLAnchorElement&gt;(*node) || (node-&gt;renderer() &amp;&amp; cache-&gt;getOrCreate(node-&gt;renderer())-&gt;isLink()))
 569             return downcast&lt;Element&gt;(node);
 570     }
 571 
 572     return nullptr;
 573 }
 574 
 575 String AccessibilityRenderObject::helpText() const
 576 {
 577     if (!m_renderer)
 578         return String();
 579 
 580     const AtomicString&amp; ariaHelp = getAttribute(aria_helpAttr);
 581     if (!ariaHelp.isEmpty())
 582         return ariaHelp;
 583 
 584     String describedBy = ariaDescribedByAttribute();
 585     if (!describedBy.isEmpty())
 586         return describedBy;
 587 
 588     String description = accessibilityDescription();
 589     for (RenderObject* ancestor = renderer(); ancestor; ancestor = ancestor-&gt;parent()) {
 590         if (is&lt;HTMLElement&gt;(ancestor-&gt;node())) {
 591             HTMLElement&amp; element = downcast&lt;HTMLElement&gt;(*ancestor-&gt;node());
 592             const AtomicString&amp; summary = element.getAttribute(summaryAttr);
 593             if (!summary.isEmpty())
 594                 return summary;
 595 
 596             // The title attribute should be used as help text unless it is already being used as descriptive text.
 597             const AtomicString&amp; title = element.getAttribute(titleAttr);
 598             if (!title.isEmpty() &amp;&amp; description != title)
 599                 return title;
 600         }
 601 
 602         // Only take help text from an ancestor element if its a group or an unknown role. If help was
 603         // added to those kinds of elements, it is likely it was meant for a child element.
 604         if (AccessibilityObject* axObj = axObjectCache()-&gt;getOrCreate(ancestor)) {
 605             if (!axObj-&gt;isGroup() &amp;&amp; axObj-&gt;roleValue() != AccessibilityRole::Unknown)
 606                 break;
 607         }
 608     }
 609 
 610     return String();
 611 }
 612 
 613 String AccessibilityRenderObject::textUnderElement(AccessibilityTextUnderElementMode mode) const
 614 {
 615     if (!m_renderer)
 616         return String();
 617 
 618     if (is&lt;RenderFileUploadControl&gt;(*m_renderer))
 619         return downcast&lt;RenderFileUploadControl&gt;(*m_renderer).buttonValue();
 620 
 621     // Reflect when a content author has explicitly marked a line break.
 622     if (m_renderer-&gt;isBR())
 623         return &quot;\n&quot;_s;
 624 
 625     if (shouldGetTextFromNode(mode))
 626         return AccessibilityNodeObject::textUnderElement(mode);
 627 
 628     // We use a text iterator for text objects AND for those cases where we are
 629     // explicitly asking for the full text under a given element.
 630     if (is&lt;RenderText&gt;(*m_renderer) || mode.childrenInclusion == AccessibilityTextUnderElementMode::TextUnderElementModeIncludeAllChildren) {
 631         // If possible, use a text iterator to get the text, so that whitespace
 632         // is handled consistently.
 633         Document* nodeDocument = nullptr;
 634         RefPtr&lt;Range&gt; textRange;
 635         if (Node* node = m_renderer-&gt;node()) {
 636             nodeDocument = &amp;node-&gt;document();
 637             textRange = rangeOfContents(*node);
 638         } else {
 639             // For anonymous blocks, we work around not having a direct node to create a range from
 640             // defining one based in the two external positions defining the boundaries of the subtree.
 641             RenderObject* firstChildRenderer = m_renderer-&gt;firstChildSlow();
 642             RenderObject* lastChildRenderer = m_renderer-&gt;lastChildSlow();
 643             if (firstChildRenderer &amp;&amp; firstChildRenderer-&gt;node() &amp;&amp; lastChildRenderer &amp;&amp; lastChildRenderer-&gt;node()) {
 644                 // We define the start and end positions for the range as the ones right before and after
 645                 // the first and the last nodes in the DOM tree that is wrapped inside the anonymous block.
 646                 Node* firstNodeInBlock = firstChildRenderer-&gt;node();
 647                 Position startPosition = positionInParentBeforeNode(firstNodeInBlock);
 648                 Position endPosition = positionInParentAfterNode(lastChildRenderer-&gt;node());
 649 
 650                 nodeDocument = &amp;firstNodeInBlock-&gt;document();
 651                 textRange = Range::create(*nodeDocument, startPosition, endPosition);
 652             }
 653         }
 654 
 655         if (nodeDocument &amp;&amp; textRange) {
 656             if (Frame* frame = nodeDocument-&gt;frame()) {
 657                 // catch stale WebCoreAXObject (see &lt;rdar://problem/3960196&gt;)
 658                 if (frame-&gt;document() != nodeDocument)
 659                     return String();
 660 
 661                 // Renders referenced by accessibility objects could get destroyed, if TextIterator ends up triggering
 662                 // style update/layout here. See also AXObjectCache::deferTextChangedIfNeeded().
 663                 ASSERT_WITH_SECURITY_IMPLICATION(!nodeDocument-&gt;childNeedsStyleRecalc());
 664                 ASSERT_WITH_SECURITY_IMPLICATION(!nodeDocument-&gt;view()-&gt;layoutContext().isInRenderTreeLayout());
 665                 return plainText(textRange.get(), textIteratorBehaviorForTextRange());
 666             }
 667         }
 668 
 669         // Sometimes text fragments don&#39;t have Nodes associated with them (like when
 670         // CSS content is used to insert text or when a RenderCounter is used.)
 671         if (is&lt;RenderText&gt;(*m_renderer)) {
 672             RenderText&amp; renderTextObject = downcast&lt;RenderText&gt;(*m_renderer);
 673             if (is&lt;RenderTextFragment&gt;(renderTextObject)) {
 674                 RenderTextFragment&amp; renderTextFragment = downcast&lt;RenderTextFragment&gt;(renderTextObject);
 675                 // The alt attribute may be set on a text fragment through CSS, which should be honored.
 676                 const String&amp; altText = renderTextFragment.altText();
 677                 if (!altText.isEmpty())
 678                     return altText;
 679                 return renderTextFragment.contentString();
 680             }
 681 
 682             return renderTextObject.text();
 683         }
 684     }
 685 
 686     return AccessibilityNodeObject::textUnderElement(mode);
 687 }
 688 
 689 bool AccessibilityRenderObject::shouldGetTextFromNode(AccessibilityTextUnderElementMode mode) const
 690 {
 691     if (!m_renderer)
 692         return false;
 693 
 694     // AccessibilityRenderObject::textUnderElement() gets the text of anonymous blocks by using
 695     // the child nodes to define positions. CSS tables and their anonymous descendants lack
 696     // children with nodes.
 697     if (m_renderer-&gt;isAnonymous() &amp;&amp; m_renderer-&gt;isTablePart())
 698         return mode.childrenInclusion == AccessibilityTextUnderElementMode::TextUnderElementModeIncludeAllChildren;
 699 
 700     // AccessibilityRenderObject::textUnderElement() calls rangeOfContents() to create the text
 701     // range. rangeOfContents() does not include CSS-generated content.
 702     if (m_renderer-&gt;isBeforeOrAfterContent())
 703         return true;
 704     if (Node* node = m_renderer-&gt;node()) {
 705         Node* firstChild = node-&gt;pseudoAwareFirstChild();
 706         Node* lastChild = node-&gt;pseudoAwareLastChild();
 707         if ((firstChild &amp;&amp; firstChild-&gt;isPseudoElement()) || (lastChild &amp;&amp; lastChild-&gt;isPseudoElement()))
 708             return true;
 709     }
 710 
 711     return false;
 712 }
 713 
 714 Node* AccessibilityRenderObject::node() const
 715 {
 716     if (!m_renderer)
 717         return nullptr;
 718     if (m_renderer-&gt;isRenderView())
 719         return &amp;m_renderer-&gt;document();
 720     return m_renderer-&gt;node();
 721 }
 722 
 723 String AccessibilityRenderObject::stringValue() const
 724 {
 725     if (!m_renderer)
 726         return String();
 727 
 728     if (isPasswordField())
 729         return passwordFieldValue();
 730 
 731     RenderBoxModelObject* cssBox = renderBoxModelObject();
 732 
 733     if (isARIAStaticText()) {
 734         String staticText = text();
 735         if (!staticText.length())
 736             staticText = textUnderElement();
 737         return staticText;
 738     }
 739 
 740     if (is&lt;RenderText&gt;(*m_renderer))
 741         return textUnderElement();
 742 
 743     if (is&lt;RenderMenuList&gt;(cssBox)) {
 744         // RenderMenuList will go straight to the text() of its selected item.
 745         // This has to be overridden in the case where the selected item has an ARIA label.
 746         HTMLSelectElement&amp; selectElement = downcast&lt;HTMLSelectElement&gt;(*m_renderer-&gt;node());
 747         int selectedIndex = selectElement.selectedIndex();
 748         const Vector&lt;HTMLElement*&gt;&amp; listItems = selectElement.listItems();
 749         if (selectedIndex &gt;= 0 &amp;&amp; static_cast&lt;size_t&gt;(selectedIndex) &lt; listItems.size()) {
 750             const AtomicString&amp; overriddenDescription = listItems[selectedIndex]-&gt;attributeWithoutSynchronization(aria_labelAttr);
 751             if (!overriddenDescription.isNull())
 752                 return overriddenDescription;
 753         }
 754         return downcast&lt;RenderMenuList&gt;(*m_renderer).text();
 755     }
 756 
 757     if (is&lt;RenderListMarker&gt;(*m_renderer))
 758         return downcast&lt;RenderListMarker&gt;(*m_renderer).text();
 759 
 760     if (isWebArea())
 761         return String();
 762 
 763     if (isTextControl())
 764         return text();
 765 
 766 #if PLATFORM(IOS_FAMILY)
 767     if (isInputTypePopupButton())
 768         return textUnderElement();
 769 #endif
 770 
 771     if (is&lt;RenderFileUploadControl&gt;(*m_renderer))
 772         return downcast&lt;RenderFileUploadControl&gt;(*m_renderer).fileTextValue();
 773 
 774     // FIXME: We might need to implement a value here for more types
 775     // FIXME: It would be better not to advertise a value at all for the types for which we don&#39;t implement one;
 776     // this would require subclassing or making accessibilityAttributeNames do something other than return a
 777     // single static array.
 778     return String();
 779 }
 780 
 781 bool AccessibilityRenderObject::canHavePlainText() const
 782 {
 783     return isARIAStaticText() || is&lt;RenderText&gt;(*m_renderer) || isTextControl();
 784 }
 785 
 786 HTMLLabelElement* AccessibilityRenderObject::labelElementContainer() const
 787 {
 788     if (!m_renderer)
 789         return nullptr;
 790 
 791     // the control element should not be considered part of the label
 792     if (isControl())
 793         return nullptr;
 794 
 795     // find if this has a parent that is a label
 796     for (Node* parentNode = m_renderer-&gt;node(); parentNode; parentNode = parentNode-&gt;parentNode()) {
 797         if (is&lt;HTMLLabelElement&gt;(*parentNode))
 798             return downcast&lt;HTMLLabelElement&gt;(parentNode);
 799     }
 800 
 801     return nullptr;
 802 }
 803 
 804 // The boundingBox for elements within the remote SVG element needs to be offset by its position
 805 // within the parent page, otherwise they are in relative coordinates only.
 806 void AccessibilityRenderObject::offsetBoundingBoxForRemoteSVGElement(LayoutRect&amp; rect) const
 807 {
 808     for (AccessibilityObject* parent = parentObject(); parent; parent = parent-&gt;parentObject()) {
 809         if (parent-&gt;isAccessibilitySVGRoot()) {
 810             rect.moveBy(parent-&gt;parentObject()-&gt;boundingBoxRect().location());
 811             break;
 812         }
 813     }
 814 }
 815 
 816 LayoutRect AccessibilityRenderObject::boundingBoxRect() const
 817 {
 818     RenderObject* obj = renderer();
 819 
 820     if (!obj)
 821         return LayoutRect();
 822 
 823     if (obj-&gt;node()) // If we are a continuation, we want to make sure to use the primary renderer.
 824         obj = obj-&gt;node()-&gt;renderer();
 825 
 826     // absoluteFocusRingQuads will query the hierarchy below this element, which for large webpages can be very slow.
 827     // For a web area, which will have the most elements of any element, absoluteQuads should be used.
 828     // We should also use absoluteQuads for SVG elements, otherwise transforms won&#39;t be applied.
 829     Vector&lt;FloatQuad&gt; quads;
 830     bool isSVGRoot = false;
 831 
 832     if (obj-&gt;isSVGRoot())
 833         isSVGRoot = true;
 834 
 835     if (is&lt;RenderText&gt;(*obj))
 836         quads = downcast&lt;RenderText&gt;(*obj).absoluteQuadsClippedToEllipsis();
 837     else if (isWebArea() || isSVGRoot)
 838         obj-&gt;absoluteQuads(quads);
 839     else
 840         obj-&gt;absoluteFocusRingQuads(quads);
 841 
 842     LayoutRect result = boundingBoxForQuads(obj, quads);
 843 
 844     Document* document = this-&gt;document();
 845     if (document &amp;&amp; document-&gt;isSVGDocument())
 846         offsetBoundingBoxForRemoteSVGElement(result);
 847 
 848     // The size of the web area should be the content size, not the clipped size.
 849     if (isWebArea())
 850         result.setSize(obj-&gt;view().frameView().contentsSize());
 851 
 852     return result;
 853 }
 854 
 855 LayoutRect AccessibilityRenderObject::checkboxOrRadioRect() const
 856 {
 857     if (!m_renderer)
 858         return LayoutRect();
 859 
 860     HTMLLabelElement* label = labelForElement(downcast&lt;Element&gt;(m_renderer-&gt;node()));
 861     if (!label || !label-&gt;renderer())
 862         return boundingBoxRect();
 863 
 864     LayoutRect labelRect = axObjectCache()-&gt;getOrCreate(label)-&gt;elementRect();
 865     labelRect.unite(boundingBoxRect());
 866     return labelRect;
 867 }
 868 
 869 LayoutRect AccessibilityRenderObject::elementRect() const
 870 {
 871     // a checkbox or radio button should encompass its label
 872     if (isCheckboxOrRadio())
 873         return checkboxOrRadioRect();
 874 
 875     return boundingBoxRect();
 876 }
 877 
 878 bool AccessibilityRenderObject::supportsPath() const
 879 {
 880     return is&lt;RenderSVGShape&gt;(renderer());
 881 }
 882 
 883 Path AccessibilityRenderObject::elementPath() const
 884 {
 885     if (is&lt;RenderSVGShape&gt;(renderer()) &amp;&amp; downcast&lt;RenderSVGShape&gt;(*m_renderer).hasPath()) {
 886         Path path = downcast&lt;RenderSVGShape&gt;(*m_renderer).path();
 887 
 888         // The SVG path is in terms of the parent&#39;s bounding box. The path needs to be offset to frame coordinates.
 889         if (auto svgRoot = ancestorsOfType&lt;RenderSVGRoot&gt;(*m_renderer).first()) {
 890             LayoutPoint parentOffset = axObjectCache()-&gt;getOrCreate(&amp;*svgRoot)-&gt;elementRect().location();
 891             path.transform(AffineTransform().translate(parentOffset.x(), parentOffset.y()));
 892         }
 893 
 894         return path;
 895     }
 896 
 897     return Path();
 898 }
 899 
 900 IntPoint AccessibilityRenderObject::clickPoint()
 901 {
 902     // Headings are usually much wider than their textual content. If the mid point is used, often it can be wrong.
 903     if (isHeading() &amp;&amp; children().size() == 1)
 904         return children()[0]-&gt;clickPoint();
 905 
 906     // use the default position unless this is an editable web area, in which case we use the selection bounds.
 907     if (!isWebArea() || !canSetValueAttribute())
 908         return AccessibilityObject::clickPoint();
 909 
 910     VisibleSelection visSelection = selection();
 911     VisiblePositionRange range = VisiblePositionRange(visSelection.visibleStart(), visSelection.visibleEnd());
 912     IntRect bounds = boundsForVisiblePositionRange(range);
 913 #if PLATFORM(COCOA)
 914     bounds.setLocation(m_renderer-&gt;view().frameView().screenToContents(bounds.location()));
 915 #endif
 916     return IntPoint(bounds.x() + (bounds.width() / 2), bounds.y() - (bounds.height() / 2));
 917 }
 918 
 919 AccessibilityObject* AccessibilityRenderObject::internalLinkElement() const
 920 {
 921     Element* element = anchorElement();
 922     // Right now, we do not support ARIA links as internal link elements
 923     if (!is&lt;HTMLAnchorElement&gt;(element))
 924         return nullptr;
 925     HTMLAnchorElement&amp; anchor = downcast&lt;HTMLAnchorElement&gt;(*element);
 926 
 927     URL linkURL = anchor.href();
 928     String fragmentIdentifier = linkURL.fragmentIdentifier();
 929     if (fragmentIdentifier.isEmpty())
 930         return nullptr;
 931 
 932     // check if URL is the same as current URL
 933     URL documentURL = m_renderer-&gt;document().url();
 934     if (!equalIgnoringFragmentIdentifier(documentURL, linkURL))
 935         return nullptr;
 936 
 937     Node* linkedNode = m_renderer-&gt;document().findAnchor(fragmentIdentifier);
 938     if (!linkedNode)
 939         return nullptr;
 940 
 941     // The element we find may not be accessible, so find the first accessible object.
 942     return firstAccessibleObjectFromNode(linkedNode);
 943 }
 944 
 945 OptionSet&lt;SpeakAs&gt; AccessibilityRenderObject::speakAsProperty() const
 946 {
 947     if (!m_renderer)
 948         return AccessibilityObject::speakAsProperty();
 949 
 950     return m_renderer-&gt;style().speakAs();
 951 }
 952 
 953 void AccessibilityRenderObject::addRadioButtonGroupChildren(AccessibilityObject* parent, AccessibilityChildrenVector&amp; linkedUIElements) const
 954 {
 955     for (const auto&amp; child : parent-&gt;children()) {
 956         if (child-&gt;roleValue() == AccessibilityRole::RadioButton)
 957             linkedUIElements.append(child);
 958         else
 959             addRadioButtonGroupChildren(child.get(), linkedUIElements);
 960     }
 961 }
 962 
 963 void AccessibilityRenderObject::addRadioButtonGroupMembers(AccessibilityChildrenVector&amp; linkedUIElements) const
 964 {
 965     if (roleValue() != AccessibilityRole::RadioButton)
 966         return;
 967 
 968     Node* node = this-&gt;node();
 969     if (is&lt;HTMLInputElement&gt;(node)) {
 970         HTMLInputElement&amp; input = downcast&lt;HTMLInputElement&gt;(*node);
 971         for (auto&amp; radioSibling : input.radioButtonGroup()) {
 972             if (AccessibilityObject* object = axObjectCache()-&gt;getOrCreate(radioSibling))
 973                 linkedUIElements.append(object);
 974         }
 975     } else {
 976         // If we didn&#39;t find any radio button siblings with the traditional naming, lets search for a radio group role and find its children.
 977         for (AccessibilityObject* parent = parentObject(); parent; parent = parent-&gt;parentObject()) {
 978             if (parent-&gt;roleValue() == AccessibilityRole::RadioGroup)
 979                 addRadioButtonGroupChildren(parent, linkedUIElements);
 980         }
 981     }
 982 }
 983 
 984 // linked ui elements could be all the related radio buttons in a group
 985 // or an internal anchor connection
 986 void AccessibilityRenderObject::linkedUIElements(AccessibilityChildrenVector&amp; linkedUIElements) const
 987 {
 988     ariaFlowToElements(linkedUIElements);
 989 
 990     if (isLink()) {
 991         AccessibilityObject* linkedAXElement = internalLinkElement();
 992         if (linkedAXElement)
 993             linkedUIElements.append(linkedAXElement);
 994     }
 995 
 996     if (roleValue() == AccessibilityRole::RadioButton)
 997         addRadioButtonGroupMembers(linkedUIElements);
 998 }
 999 
1000 bool AccessibilityRenderObject::hasTextAlternative() const
1001 {
1002     // ARIA: section 2A, bullet #3 says if aria-labeledby or aria-label appears, it should
1003     // override the &quot;label&quot; element association.
1004     return ariaAccessibilityDescription().length();
1005 }
1006 
1007 bool AccessibilityRenderObject::hasPopup() const
1008 {
1009     return !equalLettersIgnoringASCIICase(hasPopupValue(), &quot;false&quot;);
1010 }
1011 
1012 bool AccessibilityRenderObject::supportsARIADropping() const
1013 {
1014     const AtomicString&amp; dropEffect = getAttribute(aria_dropeffectAttr);
1015     return !dropEffect.isEmpty();
1016 }
1017 
1018 bool AccessibilityRenderObject::supportsARIADragging() const
1019 {
1020     const AtomicString&amp; grabbed = getAttribute(aria_grabbedAttr);
1021     return equalLettersIgnoringASCIICase(grabbed, &quot;true&quot;) || equalLettersIgnoringASCIICase(grabbed, &quot;false&quot;);
1022 }
1023 
1024 bool AccessibilityRenderObject::isARIAGrabbed()
1025 {
1026     return elementAttributeValue(aria_grabbedAttr);
1027 }
1028 
1029 Vector&lt;String&gt; AccessibilityRenderObject::determineARIADropEffects()
1030 {
1031     const AtomicString&amp; dropEffects = getAttribute(aria_dropeffectAttr);
1032     if (dropEffects.isEmpty()) {
1033         return { };
1034     }
1035 
1036     String dropEffectsString = dropEffects.string();
1037     dropEffectsString.replace(&#39;\n&#39;, &#39; &#39;);
1038     return dropEffectsString.split(&#39; &#39;);
1039 }
1040 
1041 bool AccessibilityRenderObject::exposesTitleUIElement() const
1042 {
1043     if (!isControl() &amp;&amp; !isFigureElement())
1044         return false;
1045 
1046     // If this control is ignored (because it&#39;s invisible),
1047     // then the label needs to be exposed so it can be visible to accessibility.
1048     if (accessibilityIsIgnored())
1049         return true;
1050 
1051     // When controls have their own descriptions, the title element should be ignored.
1052     if (hasTextAlternative())
1053         return false;
1054 
1055     // When &lt;label&gt; element has aria-label or aria-labelledby on it, we shouldn&#39;t expose it as the
1056     // titleUIElement, otherwise its inner text will be announced by a screenreader.
1057     if (isLabelable()) {
1058         if (HTMLLabelElement* label = labelForElement(downcast&lt;Element&gt;(node()))) {
1059             if (!label-&gt;attributeWithoutSynchronization(aria_labelAttr).isEmpty())
1060                 return false;
1061             if (AccessibilityObject* labelObject = axObjectCache()-&gt;getOrCreate(label)) {
1062                 if (!labelObject-&gt;ariaLabeledByAttribute().isEmpty())
1063                     return false;
1064                 // To simplify instances where the labeling element includes widget descendants
1065                 // which it does not label.
1066                 if (is&lt;AccessibilityLabel&gt;(*labelObject)
1067                     &amp;&amp; downcast&lt;AccessibilityLabel&gt;(*labelObject).containsUnrelatedControls())
1068                     return false;
1069             }
1070         }
1071     }
1072 
1073     return true;
1074 }
1075 
1076 AccessibilityObject* AccessibilityRenderObject::titleUIElement() const
1077 {
1078     if (!m_renderer)
1079         return nullptr;
1080 
1081     // if isFieldset is true, the renderer is guaranteed to be a RenderFieldset
1082     if (isFieldset())
1083         return axObjectCache()-&gt;getOrCreate(downcast&lt;RenderBlock&gt;(*m_renderer).findFieldsetLegend(RenderBlock::FieldsetIncludeFloatingOrOutOfFlow));
1084 
1085     if (isFigureElement())
1086         return captionForFigure();
1087 
1088     Node* node = m_renderer-&gt;node();
1089     if (!is&lt;Element&gt;(node))
1090         return nullptr;
1091     HTMLLabelElement* label = labelForElement(downcast&lt;Element&gt;(node));
1092     if (label &amp;&amp; label-&gt;renderer())
1093         return axObjectCache()-&gt;getOrCreate(label);
1094 
1095     return nullptr;
1096 }
1097 
1098 bool AccessibilityRenderObject::isAllowedChildOfTree() const
1099 {
1100     // Determine if this is in a tree. If so, we apply special behavior to make it work like an AXOutline.
1101     AccessibilityObject* axObj = parentObject();
1102     bool isInTree = false;
1103     bool isTreeItemDescendant = false;
1104     while (axObj) {
1105         if (axObj-&gt;roleValue() == AccessibilityRole::TreeItem)
1106             isTreeItemDescendant = true;
1107         if (axObj-&gt;isTree()) {
1108             isInTree = true;
1109             break;
1110         }
1111         axObj = axObj-&gt;parentObject();
1112     }
1113 
1114     // If the object is in a tree, only tree items should be exposed (and the children of tree items).
1115     if (isInTree) {
1116         AccessibilityRole role = roleValue();
1117         if (role != AccessibilityRole::TreeItem &amp;&amp; role != AccessibilityRole::StaticText &amp;&amp; !isTreeItemDescendant)
1118             return false;
1119     }
1120     return true;
1121 }
1122 
1123 static AccessibilityObjectInclusion objectInclusionFromAltText(const String&amp; altText)
1124 {
1125     // Don&#39;t ignore an image that has an alt tag.
1126     if (!altText.isAllSpecialCharacters&lt;isHTMLSpace&gt;())
1127         return AccessibilityObjectInclusion::IncludeObject;
1128 
1129     // The informal standard is to ignore images with zero-length alt strings.
1130     if (!altText.isNull())
1131         return AccessibilityObjectInclusion::IgnoreObject;
1132 
1133     return AccessibilityObjectInclusion::DefaultBehavior;
1134 }
1135 
1136 AccessibilityObjectInclusion AccessibilityRenderObject::defaultObjectInclusion() const
1137 {
1138     // The following cases can apply to any element that&#39;s a subclass of AccessibilityRenderObject.
1139 
1140     if (!m_renderer)
1141         return AccessibilityObjectInclusion::IgnoreObject;
1142 
1143     if (m_renderer-&gt;style().visibility() != Visibility::Visible) {
1144         // aria-hidden is meant to override visibility as the determinant in AX hierarchy inclusion.
1145         if (equalLettersIgnoringASCIICase(getAttribute(aria_hiddenAttr), &quot;false&quot;))
1146             return AccessibilityObjectInclusion::DefaultBehavior;
1147 
1148         return AccessibilityObjectInclusion::IgnoreObject;
1149     }
1150 
1151     return AccessibilityObject::defaultObjectInclusion();
1152 }
1153 
1154 static bool webAreaIsPresentational(RenderObject* renderer)
1155 {
1156     if (!is&lt;RenderView&gt;(*renderer))
1157         return false;
1158 
1159     if (auto ownerElement = renderer-&gt;document().ownerElement())
1160         return nodeHasPresentationRole(ownerElement);
1161 
1162     return false;
1163 }
1164 
1165 bool AccessibilityRenderObject::computeAccessibilityIsIgnored() const
1166 {
1167 #ifndef NDEBUG
1168     ASSERT(m_initialized);
1169 #endif
1170 
1171     if (!m_renderer)
1172         return true;
1173 
1174     // Check first if any of the common reasons cause this element to be ignored.
1175     // Then process other use cases that need to be applied to all the various roles
1176     // that AccessibilityRenderObjects take on.
1177     AccessibilityObjectInclusion decision = defaultObjectInclusion();
1178     if (decision == AccessibilityObjectInclusion::IncludeObject)
1179         return false;
1180     if (decision == AccessibilityObjectInclusion::IgnoreObject)
1181         return true;
1182 
1183     // If this element is within a parent that cannot have children, it should not be exposed.
1184     if (isDescendantOfBarrenParent())
1185         return true;
1186 
1187     if (roleValue() == AccessibilityRole::Ignored)
1188         return true;
1189 
1190     if (roleValue() == AccessibilityRole::Presentational || inheritsPresentationalRole())
1191         return true;
1192 
1193     // WebAreas should be ignored if their iframe container is marked as presentational.
1194     if (webAreaIsPresentational(renderer()))
1195         return true;
1196 
1197     // An ARIA tree can only have tree items and static text as children.
1198     if (!isAllowedChildOfTree())
1199         return true;
1200 
1201     // Allow the platform to decide if the attachment is ignored or not.
1202     if (isAttachment())
1203         return accessibilityIgnoreAttachment();
1204 
1205     // ignore popup menu items because AppKit does
1206     if (m_renderer &amp;&amp; ancestorsOfType&lt;RenderMenuList&gt;(*m_renderer).first())
1207         return true;
1208 
1209     // https://webkit.org/b/161276 Getting the controlObject might cause the m_renderer to be nullptr.
1210     if (!m_renderer)
1211         return true;
1212 
1213     if (m_renderer-&gt;isBR())
1214         return true;
1215 
1216     if (is&lt;RenderText&gt;(*m_renderer)) {
1217         // static text beneath MenuItems and MenuButtons are just reported along with the menu item, so it&#39;s ignored on an individual level
1218         AccessibilityObject* parent = parentObjectUnignored();
1219         if (parent &amp;&amp; (parent-&gt;isMenuItem() || parent-&gt;ariaRoleAttribute() == AccessibilityRole::MenuButton))
1220             return true;
1221         auto&amp; renderText = downcast&lt;RenderText&gt;(*m_renderer);
1222         if (!renderText.hasRenderedText())
1223             return true;
1224 
1225         if (renderText.parent()-&gt;isFirstLetter())
1226             return true;
1227 
1228         // static text beneath TextControls is reported along with the text control text so it&#39;s ignored.
1229         for (AccessibilityObject* parent = parentObject(); parent; parent = parent-&gt;parentObject()) {
1230             if (parent-&gt;roleValue() == AccessibilityRole::TextField)
1231                 return true;
1232         }
1233 
1234         // Walking up the parent chain might reset the m_renderer.
1235         if (!m_renderer)
1236             return true;
1237 
1238         // The alt attribute may be set on a text fragment through CSS, which should be honored.
1239         if (is&lt;RenderTextFragment&gt;(renderText)) {
1240             AccessibilityObjectInclusion altTextInclusion = objectInclusionFromAltText(downcast&lt;RenderTextFragment&gt;(renderText).altText());
1241             if (altTextInclusion == AccessibilityObjectInclusion::IgnoreObject)
1242                 return true;
1243             if (altTextInclusion == AccessibilityObjectInclusion::IncludeObject)
1244                 return false;
1245         }
1246 
1247         // text elements that are just empty whitespace should not be returned
1248         return renderText.text().isAllSpecialCharacters&lt;isHTMLSpace&gt;();
1249     }
1250 
1251     if (isHeading())
1252         return false;
1253 
1254     if (isLink())
1255         return false;
1256 
1257     if (isLandmark())
1258         return false;
1259 
1260     // all controls are accessible
1261     if (isControl())
1262         return false;
1263 
1264     if (isFigureElement())
1265         return false;
1266 
1267     switch (roleValue()) {
1268     case AccessibilityRole::Audio:
1269     case AccessibilityRole::DescriptionListTerm:
1270     case AccessibilityRole::DescriptionListDetail:
1271     case AccessibilityRole::Details:
1272     case AccessibilityRole::DocumentArticle:
1273     case AccessibilityRole::LandmarkRegion:
1274     case AccessibilityRole::ListItem:
1275     case AccessibilityRole::Time:
1276     case AccessibilityRole::Video:
1277         return false;
1278     default:
1279         break;
1280     }
1281 
1282     if (ariaRoleAttribute() != AccessibilityRole::Unknown)
1283         return false;
1284 
1285     if (roleValue() == AccessibilityRole::HorizontalRule)
1286         return false;
1287 
1288     // don&#39;t ignore labels, because they serve as TitleUIElements
1289     Node* node = m_renderer-&gt;node();
1290     if (is&lt;HTMLLabelElement&gt;(node))
1291         return false;
1292 
1293     // Anything that is content editable should not be ignored.
1294     // However, one cannot just call node-&gt;hasEditableStyle() since that will ask if its parents
1295     // are also editable. Only the top level content editable region should be exposed.
1296     if (hasContentEditableAttributeSet())
1297         return false;
1298 
1299 
1300     // if this element has aria attributes on it, it should not be ignored.
1301     if (supportsARIAAttributes())
1302         return false;
1303 
1304 #if ENABLE(MATHML)
1305     // First check if this is a special case within the math tree that needs to be ignored.
1306     if (isIgnoredElementWithinMathTree())
1307         return true;
1308     // Otherwise all other math elements are in the tree.
1309     if (isMathElement())
1310         return false;
1311 #endif
1312 
1313     if (is&lt;RenderBlockFlow&gt;(*m_renderer) &amp;&amp; m_renderer-&gt;childrenInline() &amp;&amp; !canSetFocusAttribute())
1314         return !downcast&lt;RenderBlockFlow&gt;(*m_renderer).hasLines() &amp;&amp; !mouseButtonListener();
1315 
1316     // ignore images seemingly used as spacers
1317     if (isImage()) {
1318 
1319         // If the image can take focus, it should not be ignored, lest the user not be able to interact with something important.
1320         if (canSetFocusAttribute())
1321             return false;
1322 
1323         // First check the RenderImage&#39;s altText (which can be set through a style sheet, or come from the Element).
1324         // However, if this is not a native image, fallback to the attribute on the Element.
1325         AccessibilityObjectInclusion altTextInclusion = AccessibilityObjectInclusion::DefaultBehavior;
1326         bool isRenderImage = is&lt;RenderImage&gt;(renderer());
1327         if (isRenderImage)
1328             altTextInclusion = objectInclusionFromAltText(downcast&lt;RenderImage&gt;(*m_renderer).altText());
1329         else
1330             altTextInclusion = objectInclusionFromAltText(getAttribute(altAttr).string());
1331 
1332         if (altTextInclusion == AccessibilityObjectInclusion::IgnoreObject)
1333             return true;
1334         if (altTextInclusion == AccessibilityObjectInclusion::IncludeObject)
1335             return false;
1336 
1337         // If an image has a title attribute on it, accessibility should be lenient and allow it to appear in the hierarchy (according to WAI-ARIA).
1338         if (!getAttribute(titleAttr).isEmpty())
1339             return false;
1340 
1341         if (isRenderImage) {
1342             // check for one-dimensional image
1343             RenderImage&amp; image = downcast&lt;RenderImage&gt;(*m_renderer);
1344             if (image.height() &lt;= 1 || image.width() &lt;= 1)
1345                 return true;
1346 
1347             // check whether rendered image was stretched from one-dimensional file image
1348             if (image.cachedImage()) {
1349                 LayoutSize imageSize = image.cachedImage()-&gt;imageSizeForRenderer(&amp;image, image.view().zoomFactor());
1350                 return imageSize.height() &lt;= 1 || imageSize.width() &lt;= 1;
1351             }
1352         }
1353         return false;
1354     }
1355 
1356     if (isCanvas()) {
1357         if (canvasHasFallbackContent())
1358             return false;
1359 
1360         if (is&lt;RenderBox&gt;(*m_renderer)) {
1361             auto&amp; canvasBox = downcast&lt;RenderBox&gt;(*m_renderer);
1362             if (canvasBox.height() &lt;= 1 || canvasBox.width() &lt;= 1)
1363                 return true;
1364         }
1365         // Otherwise fall through; use presence of help text, title, or description to decide.
1366     }
1367 
1368     if (m_renderer-&gt;isListMarker()) {
1369         AccessibilityObject* parent = parentObjectUnignored();
1370         return parent &amp;&amp; !parent-&gt;isListItem();
1371     }
1372 
1373     if (isWebArea())
1374         return false;
1375 
1376 #if ENABLE(METER_ELEMENT)
1377     // The render tree of meter includes a RenderBlock (meter) and a RenderMeter (div).
1378     // We expose the latter and thus should ignore the former. However, if the author
1379     // includes a title attribute on the element, hasAttributesRequiredForInclusion()
1380     // will return true, potentially resulting in a redundant accessible object.
1381     if (is&lt;HTMLMeterElement&gt;(node))
1382         return true;
1383 #endif
1384 
1385     // Using the presence of an accessible name to decide an element&#39;s visibility is not
1386     // as definitive as previous checks, so this should remain as one of the last.
1387     if (hasAttributesRequiredForInclusion())
1388         return false;
1389 
1390     // Don&#39;t ignore generic focusable elements like &lt;div tabindex=0&gt;
1391     // unless they&#39;re completely empty, with no children.
1392     if (isGenericFocusableElement() &amp;&amp; node-&gt;firstChild())
1393         return false;
1394 
1395     // &lt;span&gt; tags are inline tags and not meant to convey information if they have no other aria
1396     // information on them. If we don&#39;t ignore them, they may emit signals expected to come from
1397     // their parent. In addition, because included spans are AccessibilityRole::Group objects, and AccessibilityRole::Group
1398     // objects are often containers with meaningful information, the inclusion of a span can have
1399     // the side effect of causing the immediate parent accessible to be ignored. This is especially
1400     // problematic for platforms which have distinct roles for textual block elements.
1401     if (node &amp;&amp; node-&gt;hasTagName(spanTag))
1402         return true;
1403 
1404     // Other non-ignored host language elements
1405     if (node &amp;&amp; node-&gt;hasTagName(dfnTag))
1406         return false;
1407 
1408     if (isStyleFormatGroup())
1409         return false;
1410 
1411     // Make sure that ruby containers are not ignored.
1412     if (m_renderer-&gt;isRubyRun() || m_renderer-&gt;isRubyBlock() || m_renderer-&gt;isRubyInline())
1413         return false;
1414 
1415     // Find out if this element is inside of a label element.
1416     // If so, it may be ignored because it&#39;s the label for a checkbox or radio button.
1417     AccessibilityObject* controlObject = correspondingControlForLabelElement();
1418     if (controlObject &amp;&amp; !controlObject-&gt;exposesTitleUIElement() &amp;&amp; controlObject-&gt;isCheckboxOrRadio())
1419         return true;
1420 
1421     // By default, objects should be ignored so that the AX hierarchy is not
1422     // filled with unnecessary items.
1423     return true;
1424 }
1425 
1426 bool AccessibilityRenderObject::isLoaded() const
1427 {
1428     return !m_renderer-&gt;document().parser();
1429 }
1430 
1431 double AccessibilityRenderObject::estimatedLoadingProgress() const
1432 {
1433     if (!m_renderer)
1434         return 0;
1435 
1436     if (isLoaded())
1437         return 1.0;
1438 
1439     return m_renderer-&gt;page().progress().estimatedProgress();
1440 }
1441 
1442 int AccessibilityRenderObject::layoutCount() const
1443 {
1444     if (!is&lt;RenderView&gt;(*m_renderer))
1445         return 0;
1446     return downcast&lt;RenderView&gt;(*m_renderer).frameView().layoutContext().layoutCount();
1447 }
1448 
1449 String AccessibilityRenderObject::text() const
1450 {
1451     if (isPasswordField())
1452         return passwordFieldValue();
1453 
1454     return AccessibilityNodeObject::text();
1455 }
1456 
1457 int AccessibilityRenderObject::textLength() const
1458 {
1459     ASSERT(isTextControl());
1460 
1461     if (isPasswordField())
1462         return passwordFieldValue().length();
1463 
1464     return text().length();
1465 }
1466 
1467 PlainTextRange AccessibilityRenderObject::documentBasedSelectedTextRange() const
1468 {
1469     Node* node = m_renderer-&gt;node();
1470     if (!node)
1471         return PlainTextRange();
1472 
1473     VisibleSelection visibleSelection = selection();
1474     RefPtr&lt;Range&gt; currentSelectionRange = visibleSelection.toNormalizedRange();
1475     if (!currentSelectionRange)
1476         return PlainTextRange();
1477     // FIXME: The reason this does the correct thing when the selection is in the
1478     // shadow tree of an input element is that we get an exception below, and we
1479     // choose to interpret all exceptions as &quot;does not intersect&quot;. Seems likely
1480     // that does not handle all cases correctly.
1481     auto intersectsResult = currentSelectionRange-&gt;intersectsNode(*node);
1482     if (!intersectsResult.hasException() &amp;&amp; !intersectsResult.releaseReturnValue())
1483         return PlainTextRange();
1484 
1485     int start = indexForVisiblePosition(visibleSelection.start());
1486     int end = indexForVisiblePosition(visibleSelection.end());
1487 
1488     return PlainTextRange(start, end - start);
1489 }
1490 
1491 String AccessibilityRenderObject::selectedText() const
1492 {
1493     ASSERT(isTextControl());
1494 
1495     if (isPasswordField())
1496         return String(); // need to return something distinct from empty string
1497 
1498     if (isNativeTextControl()) {
1499         HTMLTextFormControlElement&amp; textControl = downcast&lt;RenderTextControl&gt;(*m_renderer).textFormControlElement();
1500         return textControl.selectedText();
1501     }
1502 
1503     return doAXStringForRange(documentBasedSelectedTextRange());
1504 }
1505 
1506 const AtomicString&amp; AccessibilityRenderObject::accessKey() const
1507 {
1508     Node* node = m_renderer-&gt;node();
1509     if (!is&lt;Element&gt;(node))
1510         return nullAtom();
1511     return downcast&lt;Element&gt;(*node).attributeWithoutSynchronization(accesskeyAttr);
1512 }
1513 
1514 VisibleSelection AccessibilityRenderObject::selection() const
1515 {
1516     return m_renderer-&gt;frame().selection().selection();
1517 }
1518 
1519 PlainTextRange AccessibilityRenderObject::selectedTextRange() const
1520 {
1521     ASSERT(isTextControl());
1522 
1523     if (isPasswordField())
1524         return PlainTextRange();
1525 
1526     AccessibilityRole ariaRole = ariaRoleAttribute();
1527     // Use the text control native range if it&#39;s a native object and it has no ARIA role (or has a text based ARIA role).
1528     if (isNativeTextControl() &amp;&amp; (ariaRole == AccessibilityRole::Unknown || isARIATextControl())) {
1529         HTMLTextFormControlElement&amp; textControl = downcast&lt;RenderTextControl&gt;(*m_renderer).textFormControlElement();
1530         return PlainTextRange(textControl.selectionStart(), textControl.selectionEnd() - textControl.selectionStart());
1531     }
1532 
1533     return documentBasedSelectedTextRange();
1534 }
1535 
1536 static void setTextSelectionIntent(AXObjectCache* cache, AXTextStateChangeType type)
1537 {
1538     if (!cache)
1539         return;
1540     AXTextStateChangeIntent intent(type, AXTextSelection { AXTextSelectionDirectionDiscontiguous, AXTextSelectionGranularityUnknown, false });
1541     cache-&gt;setTextSelectionIntent(intent);
1542     cache-&gt;setIsSynchronizingSelection(true);
1543 }
1544 
1545 static void clearTextSelectionIntent(AXObjectCache* cache)
1546 {
1547     if (!cache)
1548         return;
1549     cache-&gt;setTextSelectionIntent(AXTextStateChangeIntent());
1550     cache-&gt;setIsSynchronizingSelection(false);
1551 }
1552 
1553 void AccessibilityRenderObject::setSelectedTextRange(const PlainTextRange&amp; range)
1554 {
1555     setTextSelectionIntent(axObjectCache(), range.length ? AXTextStateChangeTypeSelectionExtend : AXTextStateChangeTypeSelectionMove);
1556 
1557     if (isNativeTextControl()) {
1558         HTMLTextFormControlElement&amp; textControl = downcast&lt;RenderTextControl&gt;(*m_renderer).textFormControlElement();
1559         textControl.setSelectionRange(range.start, range.start + range.length);
1560     } else {
1561         auto node = this-&gt;node();
1562         ASSERT(node);
1563         VisiblePosition start = visiblePositionForIndexUsingCharacterIterator(*node, range.start);
1564         VisiblePosition end = visiblePositionForIndexUsingCharacterIterator(*node, range.start + range.length);
1565         m_renderer-&gt;frame().selection().setSelection(VisibleSelection(start, end), FrameSelection::defaultSetSelectionOptions(UserTriggered));
1566     }
1567 
1568     clearTextSelectionIntent(axObjectCache());
1569 }
1570 
1571 URL AccessibilityRenderObject::url() const
1572 {
1573     if (isLink() &amp;&amp; is&lt;HTMLAnchorElement&gt;(*m_renderer-&gt;node())) {
1574         if (HTMLAnchorElement* anchor = downcast&lt;HTMLAnchorElement&gt;(anchorElement()))
1575             return anchor-&gt;href();
1576     }
1577 
1578     if (isWebArea())
1579         return m_renderer-&gt;document().url();
1580 
1581     if (isImage() &amp;&amp; is&lt;HTMLImageElement&gt;(m_renderer-&gt;node()))
1582         return downcast&lt;HTMLImageElement&gt;(*m_renderer-&gt;node()).src();
1583 
1584     if (isInputImage())
1585         return downcast&lt;HTMLInputElement&gt;(*m_renderer-&gt;node()).src();
1586 
1587     return URL();
1588 }
1589 
1590 bool AccessibilityRenderObject::isUnvisited() const
1591 {
1592     if (!m_renderer)
1593         return true;
1594 
1595     // FIXME: Is it a privacy violation to expose unvisited information to accessibility APIs?
1596     return m_renderer-&gt;style().isLink() &amp;&amp; m_renderer-&gt;style().insideLink() == InsideLink::InsideUnvisited;
1597 }
1598 
1599 bool AccessibilityRenderObject::isVisited() const
1600 {
1601     if (!m_renderer)
1602         return false;
1603 
1604     // FIXME: Is it a privacy violation to expose visited information to accessibility APIs?
1605     return m_renderer-&gt;style().isLink() &amp;&amp; m_renderer-&gt;style().insideLink() == InsideLink::InsideVisited;
1606 }
1607 
1608 void AccessibilityRenderObject::setElementAttributeValue(const QualifiedName&amp; attributeName, bool value)
1609 {
1610     if (!m_renderer)
1611         return;
1612 
1613     Node* node = m_renderer-&gt;node();
1614     if (!is&lt;Element&gt;(node))
1615         return;
1616 
1617     downcast&lt;Element&gt;(*node).setAttribute(attributeName, (value) ? &quot;true&quot; : &quot;false&quot;);
1618 }
1619 
1620 bool AccessibilityRenderObject::elementAttributeValue(const QualifiedName&amp; attributeName) const
1621 {
1622     if (!m_renderer)
1623         return false;
1624 
1625     return equalLettersIgnoringASCIICase(getAttribute(attributeName), &quot;true&quot;);
1626 }
1627 
1628 bool AccessibilityRenderObject::isSelected() const
1629 {
1630     if (!m_renderer)
1631         return false;
1632 
1633     if (!m_renderer-&gt;node())
1634         return false;
1635 
1636     if (equalLettersIgnoringASCIICase(getAttribute(aria_selectedAttr), &quot;true&quot;))
1637         return true;
1638 
1639     if (isTabItem() &amp;&amp; isTabItemSelected())
1640         return true;
1641 
1642     // Menu items are considered selectable by assistive technologies
1643     if (isMenuItem())
1644         return isFocused() || parentObjectUnignored()-&gt;activeDescendant() == this;
1645 
1646     return false;
1647 }
1648 
1649 bool AccessibilityRenderObject::isTabItemSelected() const
1650 {
1651     if (!isTabItem() || !m_renderer)
1652         return false;
1653 
1654     Node* node = m_renderer-&gt;node();
1655     if (!node || !node-&gt;isElementNode())
1656         return false;
1657 
1658     // The ARIA spec says a tab item can also be selected if it is aria-labeled by a tabpanel
1659     // that has keyboard focus inside of it, or if a tabpanel in its aria-controls list has KB
1660     // focus inside of it.
1661     AccessibilityObject* focusedElement = focusedUIElement();
1662     if (!focusedElement)
1663         return false;
1664 
1665     Vector&lt;Element*&gt; elements;
1666     elementsFromAttribute(elements, aria_controlsAttr);
1667 
1668     AXObjectCache* cache = axObjectCache();
1669     if (!cache)
1670         return false;
1671 
1672     for (const auto&amp; element : elements) {
1673         AccessibilityObject* tabPanel = cache-&gt;getOrCreate(element);
1674 
1675         // A tab item should only control tab panels.
1676         if (!tabPanel || tabPanel-&gt;roleValue() != AccessibilityRole::TabPanel)
1677             continue;
1678 
1679         AccessibilityObject* checkFocusElement = focusedElement;
1680         // Check if the focused element is a descendant of the element controlled by the tab item.
1681         while (checkFocusElement) {
1682             if (tabPanel == checkFocusElement)
1683                 return true;
1684             checkFocusElement = checkFocusElement-&gt;parentObject();
1685         }
1686     }
1687 
1688     return false;
1689 }
1690 
1691 bool AccessibilityRenderObject::isFocused() const
1692 {
1693     if (!m_renderer)
1694         return false;
1695 
1696     Document&amp; document = m_renderer-&gt;document();
1697 
1698     Element* focusedElement = document.focusedElement();
1699     if (!focusedElement)
1700         return false;
1701 
1702     // A web area is represented by the Document node in the DOM tree, which isn&#39;t focusable.
1703     // Check instead if the frame&#39;s selection controller is focused
1704     if (focusedElement == m_renderer-&gt;node()
1705         || (roleValue() == AccessibilityRole::WebArea &amp;&amp; document.frame()-&gt;selection().isFocusedAndActive()))
1706         return true;
1707 
1708     return false;
1709 }
1710 
1711 void AccessibilityRenderObject::setFocused(bool on)
1712 {
1713     if (on &amp;&amp; dispatchAccessibilityEventWithType(AccessibilityEventType::Focus))
1714         return;
1715 
1716     if (!canSetFocusAttribute())
1717         return;
1718 
1719     Document* document = this-&gt;document();
1720     Node* node = this-&gt;node();
1721 
1722     if (!on || !is&lt;Element&gt;(node)) {
1723         document-&gt;setFocusedElement(nullptr);
1724         return;
1725     }
1726 
1727     // When a node is told to set focus, that can cause it to be deallocated, which means that doing
1728     // anything else inside this object will crash. To fix this, we added a RefPtr to protect this object
1729     // long enough for duration.
1730     RefPtr&lt;AccessibilityObject&gt; protectedThis(this);
1731 
1732     // If this node is already the currently focused node, then calling focus() won&#39;t do anything.
1733     // That is a problem when focus is removed from the webpage to chrome, and then returns.
1734     // In these cases, we need to do what keyboard and mouse focus do, which is reset focus first.
1735     if (document-&gt;focusedElement() == node)
1736         document-&gt;setFocusedElement(nullptr);
1737 
1738     // If we return from setFocusedElement and our element has been removed from a tree, axObjectCache() may be null.
1739     if (AXObjectCache* cache = axObjectCache()) {
1740         cache-&gt;setIsSynchronizingSelection(true);
1741         downcast&lt;Element&gt;(*node).focus();
1742         cache-&gt;setIsSynchronizingSelection(false);
1743     }
1744 }
1745 
1746 void AccessibilityRenderObject::setSelectedRows(AccessibilityChildrenVector&amp; selectedRows)
1747 {
1748     // Setting selected only makes sense in trees and tables (and tree-tables).
1749     AccessibilityRole role = roleValue();
1750     if (role != AccessibilityRole::Tree &amp;&amp; role != AccessibilityRole::TreeGrid &amp;&amp; role != AccessibilityRole::Table &amp;&amp; role != AccessibilityRole::Grid)
1751         return;
1752 
1753     bool isMulti = isMultiSelectable();
1754     unsigned count = selectedRows.size();
1755     if (count &gt; 1 &amp;&amp; !isMulti)
1756         count = 1;
1757 
1758     for (const auto&amp; selectedRow : selectedRows)
1759         selectedRow-&gt;setSelected(true);
1760 }
1761 
1762 void AccessibilityRenderObject::setValue(const String&amp; string)
1763 {
1764     if (!m_renderer || !is&lt;Element&gt;(m_renderer-&gt;node()))
1765         return;
1766     if (dispatchAccessibleSetValueEvent(string))
1767         return;
1768 
1769     Element&amp; element = downcast&lt;Element&gt;(*m_renderer-&gt;node());
1770     RenderObject&amp; renderer = *m_renderer;
1771 
1772     // We should use the editor&#39;s insertText to mimic typing into the field.
1773     // Also only do this when the field is in editing mode.
1774     if (Frame* frame = renderer.document().frame()) {
1775         Editor&amp; editor = frame-&gt;editor();
1776         if (element.shouldUseInputMethod()) {
1777             editor.clearText();
1778             editor.insertText(string, nullptr);
1779             return;
1780         }
1781     }
1782     // FIXME: Do we want to do anything here for ARIA textboxes?
1783     if (renderer.isTextField() &amp;&amp; is&lt;HTMLInputElement&gt;(element))
1784         downcast&lt;HTMLInputElement&gt;(element).setValue(string);
1785     else if (renderer.isTextArea() &amp;&amp; is&lt;HTMLTextAreaElement&gt;(element))
1786         downcast&lt;HTMLTextAreaElement&gt;(element).setValue(string);
1787 }
1788 
1789 bool AccessibilityRenderObject::supportsARIAOwns() const
1790 {
1791     if (!m_renderer)
1792         return false;
1793     const AtomicString&amp; ariaOwns = getAttribute(aria_ownsAttr);
1794 
1795     return !ariaOwns.isEmpty();
1796 }
1797 
1798 RenderView* AccessibilityRenderObject::topRenderer() const
1799 {
1800     Document* topDoc = topDocument();
1801     if (!topDoc)
1802         return nullptr;
1803 
1804     return topDoc-&gt;renderView();
1805 }
1806 
1807 Document* AccessibilityRenderObject::document() const
1808 {
1809     if (!m_renderer)
1810         return nullptr;
1811     return &amp;m_renderer-&gt;document();
1812 }
1813 
1814 Widget* AccessibilityRenderObject::widget() const
1815 {
1816     if (!is&lt;RenderWidget&gt;(*m_renderer))
1817         return nullptr;
1818     return downcast&lt;RenderWidget&gt;(*m_renderer).widget();
1819 }
1820 
1821 AccessibilityObject* AccessibilityRenderObject::accessibilityParentForImageMap(HTMLMapElement* map) const
1822 {
1823     // find an image that is using this map
1824     if (!map)
1825         return nullptr;
1826 
1827     HTMLImageElement* imageElement = map-&gt;imageElement();
1828     if (!imageElement)
1829         return nullptr;
1830 
1831     if (AXObjectCache* cache = axObjectCache())
1832         return cache-&gt;getOrCreate(imageElement);
1833 
1834     return nullptr;
1835 }
1836 
1837 void AccessibilityRenderObject::getDocumentLinks(AccessibilityChildrenVector&amp; result)
1838 {
1839     Document&amp; document = m_renderer-&gt;document();
1840     Ref&lt;HTMLCollection&gt; links = document.links();
1841     for (unsigned i = 0; auto* current = links-&gt;item(i); ++i) {
1842         if (auto* renderer = current-&gt;renderer()) {
1843             RefPtr&lt;AccessibilityObject&gt; axObject = document.axObjectCache()-&gt;getOrCreate(renderer);
1844             ASSERT(axObject);
1845             if (!axObject-&gt;accessibilityIsIgnored() &amp;&amp; axObject-&gt;isLink())
1846                 result.append(axObject);
1847         } else {
1848             auto* parent = current-&gt;parentNode();
1849             if (is&lt;HTMLAreaElement&gt;(*current) &amp;&amp; is&lt;HTMLMapElement&gt;(parent)) {
1850                 auto&amp; areaObject = downcast&lt;AccessibilityImageMapLink&gt;(*axObjectCache()-&gt;getOrCreate(AccessibilityRole::ImageMapLink));
1851                 HTMLMapElement&amp; map = downcast&lt;HTMLMapElement&gt;(*parent);
1852                 areaObject.setHTMLAreaElement(downcast&lt;HTMLAreaElement&gt;(current));
1853                 areaObject.setHTMLMapElement(&amp;map);
1854                 areaObject.setParent(accessibilityParentForImageMap(&amp;map));
1855 
1856                 result.append(&amp;areaObject);
1857             }
1858         }
1859     }
1860 }
1861 
1862 FrameView* AccessibilityRenderObject::documentFrameView() const
1863 {
1864     if (!m_renderer)
1865         return nullptr;
1866 
1867     // this is the RenderObject&#39;s Document&#39;s Frame&#39;s FrameView
1868     return &amp;m_renderer-&gt;view().frameView();
1869 }
1870 
1871 Widget* AccessibilityRenderObject::widgetForAttachmentView() const
1872 {
1873     if (!isAttachment())
1874         return nullptr;
1875     return downcast&lt;RenderWidget&gt;(*m_renderer).widget();
1876 }
1877 
1878 // This function is like a cross-platform version of - (WebCoreTextMarkerRange*)textMarkerRange. It returns
1879 // a Range that we can convert to a WebCoreTextMarkerRange in the Obj-C file
1880 VisiblePositionRange AccessibilityRenderObject::visiblePositionRange() const
1881 {
1882     if (!m_renderer)
1883         return VisiblePositionRange();
1884 
1885     // construct VisiblePositions for start and end
1886     Node* node = m_renderer-&gt;node();
1887     if (!node)
1888         return VisiblePositionRange();
1889 
1890     VisiblePosition startPos = firstPositionInOrBeforeNode(node);
1891     VisiblePosition endPos = lastPositionInOrAfterNode(node);
1892 
1893     // the VisiblePositions are equal for nodes like buttons, so adjust for that
1894     // FIXME: Really?  [button, 0] and [button, 1] are distinct (before and after the button)
1895     // I expect this code is only hit for things like empty divs?  In which case I don&#39;t think
1896     // the behavior is correct here -- eseidel
1897     if (startPos == endPos) {
1898         endPos = endPos.next();
1899         if (endPos.isNull())
1900             endPos = startPos;
1901     }
1902 
1903     return VisiblePositionRange(startPos, endPos);
1904 }
1905 
1906 VisiblePositionRange AccessibilityRenderObject::visiblePositionRangeForLine(unsigned lineCount) const
1907 {
1908     if (!lineCount || !m_renderer)
1909         return VisiblePositionRange();
1910 
1911     // iterate over the lines
1912     // FIXME: this is wrong when lineNumber is lineCount+1,  because nextLinePosition takes you to the
1913     // last offset of the last line
1914     VisiblePosition visiblePos = m_renderer-&gt;view().positionForPoint(IntPoint(), nullptr);
1915     VisiblePosition savedVisiblePos;
1916     while (--lineCount) {
1917         savedVisiblePos = visiblePos;
1918         visiblePos = nextLinePosition(visiblePos, 0);
1919         if (visiblePos.isNull() || visiblePos == savedVisiblePos)
1920             return VisiblePositionRange();
1921     }
1922 
1923     // make a caret selection for the marker position, then extend it to the line
1924     // NOTE: ignores results of sel.modify because it returns false when
1925     // starting at an empty line.  The resulting selection in that case
1926     // will be a caret at visiblePos.
1927     FrameSelection selection;
1928     selection.setSelection(VisibleSelection(visiblePos));
1929     selection.modify(FrameSelection::AlterationExtend, DirectionRight, LineBoundary);
1930 
1931     return VisiblePositionRange(selection.selection().visibleStart(), selection.selection().visibleEnd());
1932 }
1933 
1934 VisiblePosition AccessibilityRenderObject::visiblePositionForIndex(int index) const
1935 {
1936     if (!m_renderer)
1937         return VisiblePosition();
1938 
1939     if (isNativeTextControl())
1940         return downcast&lt;RenderTextControl&gt;(*m_renderer).textFormControlElement().visiblePositionForIndex(index);
1941 
1942     if (!allowsTextRanges() &amp;&amp; !is&lt;RenderText&gt;(*m_renderer))
1943         return VisiblePosition();
1944 
1945     Node* node = m_renderer-&gt;node();
1946     if (!node)
1947         return VisiblePosition();
1948 
1949     return visiblePositionForIndexUsingCharacterIterator(*node, index);
1950 }
1951 
1952 int AccessibilityRenderObject::indexForVisiblePosition(const VisiblePosition&amp; position) const
1953 {
1954     if (isNativeTextControl())
1955         return downcast&lt;RenderTextControl&gt;(*m_renderer).textFormControlElement().indexForVisiblePosition(position);
1956 
1957     if (!isTextControl())
1958         return 0;
1959 
1960     Node* node = m_renderer-&gt;node();
1961     if (!node)
1962         return 0;
1963 
1964     Position indexPosition = position.deepEquivalent();
1965     if (indexPosition.isNull() || highestEditableRoot(indexPosition, HasEditableAXRole) != node)
1966         return 0;
1967 
1968 #if PLATFORM(GTK)
1969     // We need to consider replaced elements for GTK, as they will be
1970     // presented with the &#39;object replacement character&#39; (0xFFFC).
1971     bool forSelectionPreservation = true;
1972 #else
1973     bool forSelectionPreservation = false;
1974 #endif
1975 
1976     return WebCore::indexForVisiblePosition(*node, position, forSelectionPreservation);
1977 }
1978 
1979 Element* AccessibilityRenderObject::rootEditableElementForPosition(const Position&amp; position) const
1980 {
1981     // Find the root editable or pseudo-editable (i.e. having an editable ARIA role) element.
1982     Element* result = nullptr;
1983 
1984     Element* rootEditableElement = position.rootEditableElement();
1985 
1986     for (Element* e = position.element(); e &amp;&amp; e != rootEditableElement; e = e-&gt;parentElement()) {
1987         if (nodeIsTextControl(e))
1988             result = e;
1989         if (e-&gt;hasTagName(bodyTag))
1990             break;
1991     }
1992 
1993     if (result)
1994         return result;
1995 
1996     return rootEditableElement;
1997 }
1998 
1999 bool AccessibilityRenderObject::nodeIsTextControl(const Node* node) const
2000 {
2001     if (!node)
2002         return false;
2003 
2004     if (AXObjectCache* cache = axObjectCache()) {
2005         if (AccessibilityObject* axObjectForNode = cache-&gt;getOrCreate(const_cast&lt;Node*&gt;(node)))
2006             return axObjectForNode-&gt;isTextControl();
2007     }
2008 
2009     return false;
2010 }
2011 
2012 IntRect AccessibilityRenderObject::boundsForRects(LayoutRect&amp; rect1, LayoutRect&amp; rect2, RefPtr&lt;Range&gt; dataRange) const
2013 {
2014     LayoutRect ourRect = rect1;
2015     ourRect.unite(rect2);
2016 
2017     // if the rectangle spans lines and contains multiple text chars, use the range&#39;s bounding box intead
2018     if (rect1.maxY() != rect2.maxY()) {
2019         LayoutRect boundingBox = dataRange-&gt;absoluteBoundingBox();
2020         String rangeString = plainText(dataRange.get());
2021         if (rangeString.length() &gt; 1 &amp;&amp; !boundingBox.isEmpty())
2022             ourRect = boundingBox;
2023     }
2024 
2025 #if PLATFORM(MAC)
2026     return m_renderer-&gt;view().frameView().contentsToScreen(snappedIntRect(ourRect));
2027 #else
2028     return snappedIntRect(ourRect);
2029 #endif
2030 }
2031 
2032 IntRect AccessibilityRenderObject::boundsForVisiblePositionRange(const VisiblePositionRange&amp; visiblePositionRange) const
2033 {
2034     if (visiblePositionRange.isNull())
2035         return IntRect();
2036 
2037     // Create a mutable VisiblePositionRange.
2038     VisiblePositionRange range(visiblePositionRange);
2039     LayoutRect rect1 = range.start.absoluteCaretBounds();
2040     LayoutRect rect2 = range.end.absoluteCaretBounds();
2041 
2042     // readjust for position at the edge of a line.  This is to exclude line rect that doesn&#39;t need to be accounted in the range bounds
2043     if (rect2.y() != rect1.y()) {
2044         VisiblePosition endOfFirstLine = endOfLine(range.start);
2045         if (range.start == endOfFirstLine) {
2046             range.start.setAffinity(DOWNSTREAM);
2047             rect1 = range.start.absoluteCaretBounds();
2048         }
2049         if (range.end == endOfFirstLine) {
2050             range.end.setAffinity(UPSTREAM);
2051             rect2 = range.end.absoluteCaretBounds();
2052         }
2053     }
2054 
2055     RefPtr&lt;Range&gt; dataRange = makeRange(range.start, range.end);
2056     return boundsForRects(rect1, rect2, dataRange);
2057 }
2058 
2059 IntRect AccessibilityRenderObject::boundsForRange(const RefPtr&lt;Range&gt; range) const
2060 {
2061     if (!range)
2062         return IntRect();
2063 
2064     AXObjectCache* cache = this-&gt;axObjectCache();
2065     if (!cache)
2066         return IntRect();
2067 
2068     CharacterOffset start = cache-&gt;startOrEndCharacterOffsetForRange(range, true);
2069     CharacterOffset end = cache-&gt;startOrEndCharacterOffsetForRange(range, false);
2070 
2071     LayoutRect rect1 = cache-&gt;absoluteCaretBoundsForCharacterOffset(start);
2072     LayoutRect rect2 = cache-&gt;absoluteCaretBoundsForCharacterOffset(end);
2073 
2074     // readjust for position at the edge of a line. This is to exclude line rect that doesn&#39;t need to be accounted in the range bounds.
2075     if (rect2.y() != rect1.y()) {
2076         CharacterOffset endOfFirstLine = cache-&gt;endCharacterOffsetOfLine(start);
2077         if (start.isEqual(endOfFirstLine)) {
2078             start = cache-&gt;nextCharacterOffset(start, false);
2079             rect1 = cache-&gt;absoluteCaretBoundsForCharacterOffset(start);
2080         }
2081         if (end.isEqual(endOfFirstLine)) {
2082             end = cache-&gt;previousCharacterOffset(end, false);
2083             rect2 = cache-&gt;absoluteCaretBoundsForCharacterOffset(end);
2084         }
2085     }
2086 
2087     return boundsForRects(rect1, rect2, range);
2088 }
2089 
2090 bool AccessibilityRenderObject::isVisiblePositionRangeInDifferentDocument(const VisiblePositionRange&amp; range) const
2091 {
2092     if (range.start.isNull() || range.end.isNull())
2093         return false;
2094 
2095     VisibleSelection newSelection = VisibleSelection(range.start, range.end);
2096     if (Document* newSelectionDocument = newSelection.base().document()) {
2097         if (RefPtr&lt;Frame&gt; newSelectionFrame = newSelectionDocument-&gt;frame()) {
2098             Frame* frame = this-&gt;frame();
2099             if (!frame || (newSelectionFrame != frame &amp;&amp; newSelectionDocument != frame-&gt;document()))
2100                 return true;
2101         }
2102     }
2103 
2104     return false;
2105 }
2106 
2107 void AccessibilityRenderObject::setSelectedVisiblePositionRange(const VisiblePositionRange&amp; range) const
2108 {
2109     if (range.start.isNull() || range.end.isNull())
2110         return;
2111 
2112     // In WebKit1, when the top web area sets the selection to be an input element in an iframe, the caret will disappear.
2113     // FrameSelection::setSelectionWithoutUpdatingAppearance is setting the selection on the new frame in this case, and causing this behavior.
2114     if (isWebArea() &amp;&amp; parentObject() &amp;&amp; parentObject()-&gt;isAttachment()) {
2115         if (isVisiblePositionRangeInDifferentDocument(range))
2116             return;
2117     }
2118 
2119     // make selection and tell the document to use it. if it&#39;s zero length, then move to that position
2120     if (range.start == range.end) {
2121         setTextSelectionIntent(axObjectCache(), AXTextStateChangeTypeSelectionMove);
2122         m_renderer-&gt;frame().selection().moveTo(range.start, UserTriggered);
2123         clearTextSelectionIntent(axObjectCache());
2124     }
2125     else {
2126         setTextSelectionIntent(axObjectCache(), AXTextStateChangeTypeSelectionExtend);
2127         VisibleSelection newSelection = VisibleSelection(range.start, range.end);
2128         m_renderer-&gt;frame().selection().setSelection(newSelection, FrameSelection::defaultSetSelectionOptions());
2129         clearTextSelectionIntent(axObjectCache());
2130     }
2131 }
2132 
2133 VisiblePosition AccessibilityRenderObject::visiblePositionForPoint(const IntPoint&amp; point) const
2134 {
2135     if (!m_renderer)
2136         return VisiblePosition();
2137 
2138     // convert absolute point to view coordinates
2139     RenderView* renderView = topRenderer();
2140     if (!renderView)
2141         return VisiblePosition();
2142 
2143 #if PLATFORM(COCOA)
2144     FrameView* frameView = &amp;renderView-&gt;frameView();
2145 #endif
2146 
2147     Node* innerNode = nullptr;
2148 
2149     // locate the node containing the point
2150     LayoutPoint pointResult;
2151     while (1) {
2152         LayoutPoint ourpoint;
2153 #if PLATFORM(MAC)
2154         ourpoint = frameView-&gt;screenToContents(point);
2155 #else
2156         ourpoint = point;
2157 #endif
2158         HitTestRequest request(HitTestRequest::ReadOnly |
2159                                HitTestRequest::Active);
2160         HitTestResult result(ourpoint);
2161         renderView-&gt;document().hitTest(request, result);
2162         innerNode = result.innerNode();
2163         if (!innerNode)
2164             return VisiblePosition();
2165 
2166         RenderObject* renderer = innerNode-&gt;renderer();
2167         if (!renderer)
2168             return VisiblePosition();
2169 
2170         pointResult = result.localPoint();
2171 
2172         // done if hit something other than a widget
2173         if (!is&lt;RenderWidget&gt;(*renderer))
2174             break;
2175 
2176         // descend into widget (FRAME, IFRAME, OBJECT...)
2177         Widget* widget = downcast&lt;RenderWidget&gt;(*renderer).widget();
2178         if (!is&lt;FrameView&gt;(widget))
2179             break;
2180         Frame&amp; frame = downcast&lt;FrameView&gt;(*widget).frame();
2181         renderView = frame.document()-&gt;renderView();
2182 #if PLATFORM(COCOA)
2183         frameView = downcast&lt;FrameView&gt;(widget);
2184 #endif
2185     }
2186 
2187     return innerNode-&gt;renderer()-&gt;positionForPoint(pointResult, nullptr);
2188 }
2189 
2190 // NOTE: Consider providing this utility method as AX API
2191 VisiblePosition AccessibilityRenderObject::visiblePositionForIndex(unsigned indexValue, bool lastIndexOK) const
2192 {
2193     if (!isTextControl())
2194         return VisiblePosition();
2195 
2196     // lastIndexOK specifies whether the position after the last character is acceptable
2197     if (indexValue &gt;= text().length()) {
2198         if (!lastIndexOK || indexValue &gt; text().length())
2199             return VisiblePosition();
2200     }
2201     VisiblePosition position = visiblePositionForIndex(indexValue);
2202     position.setAffinity(DOWNSTREAM);
2203     return position;
2204 }
2205 
2206 // NOTE: Consider providing this utility method as AX API
2207 int AccessibilityRenderObject::index(const VisiblePosition&amp; position) const
2208 {
2209     if (position.isNull() || !isTextControl())
2210         return -1;
2211 
2212     if (renderObjectContainsPosition(renderer(), position.deepEquivalent()))
2213         return indexForVisiblePosition(position);
2214 
2215     return -1;
2216 }
2217 
2218 void AccessibilityRenderObject::lineBreaks(Vector&lt;int&gt;&amp; lineBreaks) const
2219 {
2220     if (!isTextControl())
2221         return;
2222 
2223     VisiblePosition visiblePos = visiblePositionForIndex(0);
2224     VisiblePosition savedVisiblePos = visiblePos;
2225     visiblePos = nextLinePosition(visiblePos, 0);
2226     while (!visiblePos.isNull() &amp;&amp; visiblePos != savedVisiblePos) {
2227         lineBreaks.append(indexForVisiblePosition(visiblePos));
2228         savedVisiblePos = visiblePos;
2229         visiblePos = nextLinePosition(visiblePos, 0);
2230     }
2231 }
2232 
2233 // Given a line number, the range of characters of the text associated with this accessibility
2234 // object that contains the line number.
2235 PlainTextRange AccessibilityRenderObject::doAXRangeForLine(unsigned lineNumber) const
2236 {
2237     if (!isTextControl())
2238         return PlainTextRange();
2239 
2240     // iterate to the specified line
2241     VisiblePosition visiblePos = visiblePositionForIndex(0);
2242     VisiblePosition savedVisiblePos;
2243     for (unsigned lineCount = lineNumber; lineCount; lineCount -= 1) {
2244         savedVisiblePos = visiblePos;
2245         visiblePos = nextLinePosition(visiblePos, 0);
2246         if (visiblePos.isNull() || visiblePos == savedVisiblePos)
2247             return PlainTextRange();
2248     }
2249 
2250     // Get the end of the line based on the starting position.
2251     VisiblePosition endPosition = endOfLine(visiblePos);
2252 
2253     int index1 = indexForVisiblePosition(visiblePos);
2254     int index2 = indexForVisiblePosition(endPosition);
2255 
2256     // add one to the end index for a line break not caused by soft line wrap (to match AppKit)
2257     if (endPosition.affinity() == DOWNSTREAM &amp;&amp; endPosition.next().isNotNull())
2258         index2 += 1;
2259 
2260     // return nil rather than an zero-length range (to match AppKit)
2261     if (index1 == index2)
2262         return PlainTextRange();
2263 
2264     return PlainTextRange(index1, index2 - index1);
2265 }
2266 
2267 // The composed character range in the text associated with this accessibility object that
2268 // is specified by the given index value. This parameterized attribute returns the complete
2269 // range of characters (including surrogate pairs of multi-byte glyphs) at the given index.
2270 PlainTextRange AccessibilityRenderObject::doAXRangeForIndex(unsigned index) const
2271 {
2272     if (!isTextControl())
2273         return PlainTextRange();
2274 
2275     String elementText = text();
2276     if (!elementText.length() || index &gt; elementText.length() - 1)
2277         return PlainTextRange();
2278 
2279     return PlainTextRange(index, 1);
2280 }
2281 
2282 // A substring of the text associated with this accessibility object that is
2283 // specified by the given character range.
2284 String AccessibilityRenderObject::doAXStringForRange(const PlainTextRange&amp; range) const
2285 {
2286     if (!range.length)
2287         return String();
2288 
2289     if (!isTextControl())
2290         return String();
2291 
2292     String elementText = isPasswordField() ? passwordFieldValue() : text();
2293     return elementText.substring(range.start, range.length);
2294 }
2295 
2296 // The bounding rectangle of the text associated with this accessibility object that is
2297 // specified by the given range. This is the bounding rectangle a sighted user would see
2298 // on the display screen, in pixels.
2299 IntRect AccessibilityRenderObject::doAXBoundsForRange(const PlainTextRange&amp; range) const
2300 {
2301     if (allowsTextRanges())
2302         return boundsForVisiblePositionRange(visiblePositionRangeForRange(range));
2303     return IntRect();
2304 }
2305 
2306 IntRect AccessibilityRenderObject::doAXBoundsForRangeUsingCharacterOffset(const PlainTextRange&amp; range) const
2307 {
2308     if (allowsTextRanges())
2309         return boundsForRange(rangeForPlainTextRange(range));
2310     return IntRect();
2311 }
2312 
2313 AccessibilityObject* AccessibilityRenderObject::accessibilityImageMapHitTest(HTMLAreaElement* area, const IntPoint&amp; point) const
2314 {
2315     if (!area)
2316         return nullptr;
2317 
2318     AccessibilityObject* parent = nullptr;
2319     for (Element* mapParent = area-&gt;parentElement(); mapParent; mapParent = mapParent-&gt;parentElement()) {
2320         if (is&lt;HTMLMapElement&gt;(*mapParent)) {
2321             parent = accessibilityParentForImageMap(downcast&lt;HTMLMapElement&gt;(mapParent));
2322             break;
2323         }
2324     }
2325     if (!parent)
2326         return nullptr;
2327 
2328     for (const auto&amp; child : parent-&gt;children()) {
2329         if (child-&gt;elementRect().contains(point))
2330             return child.get();
2331     }
2332 
2333     return nullptr;
2334 }
2335 
2336 AccessibilityObject* AccessibilityRenderObject::remoteSVGElementHitTest(const IntPoint&amp; point) const
2337 {
2338     AccessibilityObject* remote = remoteSVGRootElement(Create);
2339     if (!remote)
2340         return nullptr;
2341 
2342     IntSize offset = point - roundedIntPoint(boundingBoxRect().location());
2343     return remote-&gt;accessibilityHitTest(IntPoint(offset));
2344 }
2345 
2346 AccessibilityObject* AccessibilityRenderObject::elementAccessibilityHitTest(const IntPoint&amp; point) const
2347 {
2348     if (isSVGImage())
2349         return remoteSVGElementHitTest(point);
2350 
2351     return AccessibilityObject::elementAccessibilityHitTest(point);
2352 }
2353 
2354 static bool shouldUseShadowHostForHitTesting(Node* shadowHost)
2355 {
2356     // We need to allow automation of mouse events on video tags.
2357     return shadowHost &amp;&amp; !shadowHost-&gt;hasTagName(videoTag);
2358 }
2359 
2360 AccessibilityObject* AccessibilityRenderObject::accessibilityHitTest(const IntPoint&amp; point) const
2361 {
2362     if (!m_renderer || !m_renderer-&gt;hasLayer())
2363         return nullptr;
2364 
2365     m_renderer-&gt;document().updateLayout();
2366 
2367     if (!m_renderer || !m_renderer-&gt;hasLayer())
2368         return nullptr;
2369 
2370     RenderLayer* layer = downcast&lt;RenderBox&gt;(*m_renderer).layer();
2371 
2372     HitTestRequest request(HitTestRequest::ReadOnly | HitTestRequest::Active | HitTestRequest::AccessibilityHitTest);
2373     HitTestResult hitTestResult = HitTestResult(point);
2374     layer-&gt;hitTest(request, hitTestResult);
2375     Node* node = hitTestResult.innerNode();
2376     if (!node)
2377         return nullptr;
2378     Node* shadowAncestorNode = node-&gt;shadowHost();
2379     if (shouldUseShadowHostForHitTesting(shadowAncestorNode))
2380         node = shadowAncestorNode;
2381     ASSERT(node);
2382 
2383     if (is&lt;HTMLAreaElement&gt;(*node))
2384         return accessibilityImageMapHitTest(downcast&lt;HTMLAreaElement&gt;(node), point);
2385 
2386     if (is&lt;HTMLOptionElement&gt;(*node))
2387         node = downcast&lt;HTMLOptionElement&gt;(*node).ownerSelectElement();
2388 
2389     RenderObject* obj = node-&gt;renderer();
2390     if (!obj)
2391         return nullptr;
2392 
2393     AccessibilityObject* result = obj-&gt;document().axObjectCache()-&gt;getOrCreate(obj);
2394     result-&gt;updateChildrenIfNecessary();
2395 
2396     // Allow the element to perform any hit-testing it might need to do to reach non-render children.
2397     result = result-&gt;elementAccessibilityHitTest(point);
2398 
2399     if (result &amp;&amp; result-&gt;accessibilityIsIgnored()) {
2400         // If this element is the label of a control, a hit test should return the control.
2401         AccessibilityObject* controlObject = result-&gt;correspondingControlForLabelElement();
2402         if (controlObject &amp;&amp; !controlObject-&gt;exposesTitleUIElement())
2403             return controlObject;
2404 
2405         result = result-&gt;parentObjectUnignored();
2406     }
2407 
2408     return result;
2409 }
2410 
2411 bool AccessibilityRenderObject::shouldNotifyActiveDescendant() const
2412 {
2413 #if PLATFORM(GTK)
2414     // According to the Core AAM spec, ATK expects object:state-changed:focused notifications
2415     // whenever the active descendant changes.
2416     return true;
2417 #endif
2418     // We want to notify that the combo box has changed its active descendant,
2419     // but we do not want to change the focus, because focus should remain with the combo box.
2420     if (isComboBox())
2421         return true;
2422 
2423     return shouldFocusActiveDescendant();
2424 }
2425 
2426 bool AccessibilityRenderObject::shouldFocusActiveDescendant() const
2427 {
2428     switch (ariaRoleAttribute()) {
2429     case AccessibilityRole::ApplicationGroup:
2430     case AccessibilityRole::ListBox:
2431     case AccessibilityRole::Menu:
2432     case AccessibilityRole::MenuBar:
2433     case AccessibilityRole::RadioGroup:
2434     case AccessibilityRole::Row:
2435     case AccessibilityRole::PopUpButton:
2436     case AccessibilityRole::ProgressIndicator:
2437     case AccessibilityRole::Toolbar:
2438     case AccessibilityRole::Outline:
2439     case AccessibilityRole::Tree:
2440     case AccessibilityRole::Grid:
2441     /* FIXME: replace these with actual roles when they are added to AccessibilityRole
2442     composite
2443     alert
2444     alertdialog
2445     status
2446     timer
2447     */
2448         return true;
2449     default:
2450         return false;
2451     }
2452 }
2453 
2454 AccessibilityObject* AccessibilityRenderObject::activeDescendant() const
2455 {
2456     if (!m_renderer)
2457         return nullptr;
2458 
2459     const AtomicString&amp; activeDescendantAttrStr = getAttribute(aria_activedescendantAttr);
2460     if (activeDescendantAttrStr.isNull() || activeDescendantAttrStr.isEmpty())
2461         return nullptr;
2462     Element* element = this-&gt;element();
2463     if (!element)
2464         return nullptr;
2465 
2466     Element* target = element-&gt;treeScope().getElementById(activeDescendantAttrStr);
2467     if (!target)
2468         return nullptr;
2469 
2470     if (AXObjectCache* cache = axObjectCache()) {
2471         AccessibilityObject* obj = cache-&gt;getOrCreate(target);
2472         if (obj &amp;&amp; obj-&gt;isAccessibilityRenderObject())
2473             // an activedescendant is only useful if it has a renderer, because that&#39;s what&#39;s needed to post the notification
2474             return obj;
2475     }
2476 
2477     return nullptr;
2478 }
2479 
2480 void AccessibilityRenderObject::handleAriaExpandedChanged()
2481 {
2482     // This object might be deleted under the call to the parentObject() method.
2483     auto protectedThis = makeRef(*this);
2484 
2485     // Find if a parent of this object should handle aria-expanded changes.
2486     AccessibilityObject* containerParent = this-&gt;parentObject();
2487     while (containerParent) {
2488         bool foundParent = false;
2489 
2490         switch (containerParent-&gt;roleValue()) {
2491         case AccessibilityRole::Tree:
2492         case AccessibilityRole::TreeGrid:
2493         case AccessibilityRole::Grid:
2494         case AccessibilityRole::Table:
2495         case AccessibilityRole::Browser:
2496             foundParent = true;
2497             break;
2498         default:
2499             break;
2500         }
2501 
2502         if (foundParent)
2503             break;
2504 
2505         containerParent = containerParent-&gt;parentObject();
2506     }
2507 
2508     // Post that the row count changed.
2509     AXObjectCache* cache = axObjectCache();
2510     if (!cache)
2511         return;
2512 
2513     if (containerParent)
2514         cache-&gt;postNotification(containerParent, document(), AXObjectCache::AXRowCountChanged);
2515 
2516     // Post that the specific row either collapsed or expanded.
2517     if (roleValue() == AccessibilityRole::Row || roleValue() == AccessibilityRole::TreeItem)
2518         cache-&gt;postNotification(this, document(), isExpanded() ? AXObjectCache::AXRowExpanded : AXObjectCache::AXRowCollapsed);
2519     else
2520         cache-&gt;postNotification(this, document(), AXObjectCache::AXExpandedChanged);
2521 }
2522 
2523 RenderObject* AccessibilityRenderObject::targetElementForActiveDescendant(const QualifiedName&amp; attributeName, AccessibilityObject* activeDescendant) const
2524 {
2525     AccessibilityObject::AccessibilityChildrenVector elements;
2526     ariaElementsFromAttribute(elements, attributeName);
2527     for (const auto&amp; element : elements) {
2528         if (activeDescendant-&gt;isDescendantOfObject(element.get()))
2529             return element-&gt;renderer();
2530     }
2531 
2532     return nullptr;
2533 }
2534 
2535 void AccessibilityRenderObject::handleActiveDescendantChanged()
2536 {
2537     Element* element = downcast&lt;Element&gt;(renderer()-&gt;node());
2538     if (!element)
2539         return;
2540     if (!renderer()-&gt;frame().selection().isFocusedAndActive() || renderer()-&gt;document().focusedElement() != element)
2541         return;
2542 
2543     auto* activeDescendant = this-&gt;activeDescendant();
2544     if (activeDescendant &amp;&amp; shouldNotifyActiveDescendant()) {
2545         auto* targetRenderer = renderer();
2546 
2547 #if PLATFORM(COCOA)
2548         // If the combobox&#39;s activeDescendant is inside another object, the target element should be that parent.
2549         if (isComboBox()) {
2550             if (auto* ariaOwner = targetElementForActiveDescendant(aria_ownsAttr, activeDescendant))
2551                 targetRenderer = ariaOwner;
2552             else if (auto* ariaController = targetElementForActiveDescendant(aria_controlsAttr, activeDescendant))
2553                 targetRenderer = ariaController;
2554         }
2555 #endif
2556 
2557         renderer()-&gt;document().axObjectCache()-&gt;postNotification(targetRenderer, AXObjectCache::AXActiveDescendantChanged);
2558     }
2559 }
2560 
2561 AccessibilityObject* AccessibilityRenderObject::correspondingControlForLabelElement() const
2562 {
2563     HTMLLabelElement* labelElement = labelElementContainer();
2564     if (!labelElement)
2565         return nullptr;
2566 
2567     auto correspondingControl = labelElement-&gt;control();
2568     if (!correspondingControl)
2569         return nullptr;
2570 
2571     // Make sure the corresponding control isn&#39;t a descendant of this label that&#39;s in the middle of being destroyed.
2572     if (correspondingControl-&gt;renderer() &amp;&amp; !correspondingControl-&gt;renderer()-&gt;parent())
2573         return nullptr;
2574 
2575     return axObjectCache()-&gt;getOrCreate(correspondingControl.get());
2576 }
2577 
2578 AccessibilityObject* AccessibilityRenderObject::correspondingLabelForControlElement() const
2579 {
2580     if (!m_renderer)
2581         return nullptr;
2582 
2583     // ARIA: section 2A, bullet #3 says if aria-labeledby or aria-label appears, it should
2584     // override the &quot;label&quot; element association.
2585     if (hasTextAlternative())
2586         return nullptr;
2587 
2588     Node* node = m_renderer-&gt;node();
2589     if (is&lt;HTMLElement&gt;(node)) {
2590         if (HTMLLabelElement* label = labelForElement(downcast&lt;HTMLElement&gt;(node)))
2591             return axObjectCache()-&gt;getOrCreate(label);
2592     }
2593 
2594     return nullptr;
2595 }
2596 
2597 bool AccessibilityRenderObject::renderObjectIsObservable(RenderObject&amp; renderer) const
2598 {
2599     // AX clients will listen for AXValueChange on a text control.
2600     if (is&lt;RenderTextControl&gt;(renderer))
2601         return true;
2602 
2603     // AX clients will listen for AXSelectedChildrenChanged on listboxes.
2604     Node* node = renderer.node();
2605     if (!node)
2606         return false;
2607 
2608     if (nodeHasRole(node, &quot;listbox&quot;) || (is&lt;RenderBoxModelObject&gt;(renderer) &amp;&amp; downcast&lt;RenderBoxModelObject&gt;(renderer).isListBox()))
2609         return true;
2610 
2611     // Textboxes should send out notifications.
2612     if (nodeHasRole(node, &quot;textbox&quot;) || (is&lt;Element&gt;(*node) &amp;&amp; contentEditableAttributeIsEnabled(downcast&lt;Element&gt;(node))))
2613         return true;
2614 
2615     return false;
2616 }
2617 
2618 AccessibilityObject* AccessibilityRenderObject::observableObject() const
2619 {
2620     // Find the object going up the parent chain that is used in accessibility to monitor certain notifications.
2621     for (RenderObject* renderer = this-&gt;renderer(); renderer &amp;&amp; renderer-&gt;node(); renderer = renderer-&gt;parent()) {
2622         if (renderObjectIsObservable(*renderer)) {
2623             if (AXObjectCache* cache = axObjectCache())
2624                 return cache-&gt;getOrCreate(renderer);
2625         }
2626     }
2627 
2628     return nullptr;
2629 }
2630 
2631 bool AccessibilityRenderObject::isDescendantOfElementType(const QualifiedName&amp; tagName) const
2632 {
2633     for (auto&amp; ancestor : ancestorsOfType&lt;RenderElement&gt;(*m_renderer)) {
2634         if (ancestor.element() &amp;&amp; ancestor.element()-&gt;hasTagName(tagName))
2635             return true;
2636     }
2637     return false;
2638 }
2639 
2640 String AccessibilityRenderObject::expandedTextValue() const
2641 {
2642     if (AccessibilityObject* parent = parentObject()) {
2643         if (parent-&gt;hasTagName(abbrTag) || parent-&gt;hasTagName(acronymTag))
2644             return parent-&gt;getAttribute(titleAttr);
2645     }
2646 
2647     return String();
2648 }
2649 
2650 bool AccessibilityRenderObject::supportsExpandedTextValue() const
2651 {
2652     if (roleValue() == AccessibilityRole::StaticText) {
2653         if (AccessibilityObject* parent = parentObject())
2654             return parent-&gt;hasTagName(abbrTag) || parent-&gt;hasTagName(acronymTag);
2655     }
2656 
2657     return false;
2658 }
2659 
2660 AccessibilityRole AccessibilityRenderObject::determineAccessibilityRole()
2661 {
2662     if (!m_renderer)
2663         return AccessibilityRole::Unknown;
2664 
2665     // Sometimes we need to ignore the attribute role. Like if a tree is malformed,
2666     // we want to ignore the treeitem&#39;s attribute role.
2667     if ((m_ariaRole = determineAriaRoleAttribute()) != AccessibilityRole::Unknown &amp;&amp; !shouldIgnoreAttributeRole())
2668         return m_ariaRole;
2669 
2670     Node* node = m_renderer-&gt;node();
2671     RenderBoxModelObject* cssBox = renderBoxModelObject();
2672 
2673     if (node &amp;&amp; node-&gt;isLink())
2674         return AccessibilityRole::WebCoreLink;
2675     if (node &amp;&amp; is&lt;HTMLImageElement&gt;(*node) &amp;&amp; downcast&lt;HTMLImageElement&gt;(*node).hasAttributeWithoutSynchronization(usemapAttr))
2676         return AccessibilityRole::ImageMap;
2677     if ((cssBox &amp;&amp; cssBox-&gt;isListItem()) || (node &amp;&amp; node-&gt;hasTagName(liTag)))
2678         return AccessibilityRole::ListItem;
2679     if (m_renderer-&gt;isListMarker())
2680         return AccessibilityRole::ListMarker;
2681     if (node &amp;&amp; node-&gt;hasTagName(buttonTag))
2682         return buttonRoleType();
2683     if (node &amp;&amp; node-&gt;hasTagName(legendTag))
2684         return AccessibilityRole::Legend;
2685     if (m_renderer-&gt;isText())
2686         return AccessibilityRole::StaticText;
2687     if (cssBox &amp;&amp; cssBox-&gt;isImage()) {
2688         if (is&lt;HTMLInputElement&gt;(node))
2689             return hasPopup() ? AccessibilityRole::PopUpButton : AccessibilityRole::Button;
2690         if (isSVGImage())
2691             return AccessibilityRole::SVGRoot;
2692         return AccessibilityRole::Image;
2693     }
2694 
2695     if (node &amp;&amp; node-&gt;hasTagName(canvasTag))
2696         return AccessibilityRole::Canvas;
2697 
2698     if (cssBox &amp;&amp; cssBox-&gt;isRenderView())
2699         return AccessibilityRole::WebArea;
2700 
2701     if (cssBox &amp;&amp; cssBox-&gt;isTextField()) {
2702         if (is&lt;HTMLInputElement&gt;(node))
2703             return downcast&lt;HTMLInputElement&gt;(*node).isSearchField() ? AccessibilityRole::SearchField : AccessibilityRole::TextField;
2704     }
2705 
2706     if (cssBox &amp;&amp; cssBox-&gt;isTextArea())
2707         return AccessibilityRole::TextArea;
2708 
2709     if (is&lt;HTMLInputElement&gt;(node)) {
2710         HTMLInputElement&amp; input = downcast&lt;HTMLInputElement&gt;(*node);
2711         if (input.isCheckbox())
2712             return AccessibilityRole::CheckBox;
2713         if (input.isRadioButton())
2714             return AccessibilityRole::RadioButton;
2715         if (input.isTextButton())
2716             return buttonRoleType();
2717         // On iOS, the date field and time field are popup buttons. On other platforms they are text fields.
2718 #if PLATFORM(IOS_FAMILY)
2719         if (input.isDateField() || input.isTimeField())
2720             return AccessibilityRole::PopUpButton;
2721 #endif
2722 #if ENABLE(INPUT_TYPE_COLOR)
2723         if (input.isColorControl())
2724             return AccessibilityRole::ColorWell;
2725 #endif
2726     }
2727 
2728     if (hasContentEditableAttributeSet())
2729         return AccessibilityRole::TextArea;
2730 
2731     if (isFileUploadButton())
2732         return AccessibilityRole::Button;
2733 
2734     if (cssBox &amp;&amp; cssBox-&gt;isMenuList())
2735         return AccessibilityRole::PopUpButton;
2736 
2737     if (headingLevel())
2738         return AccessibilityRole::Heading;
2739 
2740     if (m_renderer-&gt;isSVGRoot())
2741         return AccessibilityRole::SVGRoot;
2742 
2743     if (isStyleFormatGroup())
2744         return is&lt;RenderInline&gt;(*m_renderer) ? AccessibilityRole::Inline : AccessibilityRole::TextGroup;
2745 
2746     if (node &amp;&amp; node-&gt;hasTagName(ddTag))
2747         return AccessibilityRole::DescriptionListDetail;
2748 
2749     if (node &amp;&amp; node-&gt;hasTagName(dtTag))
2750         return AccessibilityRole::DescriptionListTerm;
2751 
2752     if (node &amp;&amp; node-&gt;hasTagName(dlTag))
2753         return AccessibilityRole::DescriptionList;
2754 
2755     if (node &amp;&amp; node-&gt;hasTagName(fieldsetTag))
2756         return AccessibilityRole::Group;
2757 
2758     if (node &amp;&amp; node-&gt;hasTagName(figureTag))
2759         return AccessibilityRole::Figure;
2760 
2761     // Check for Ruby elements
2762     if (m_renderer-&gt;isRubyText())
2763         return AccessibilityRole::RubyText;
2764     if (m_renderer-&gt;isRubyBase())
2765         return AccessibilityRole::RubyBase;
2766     if (m_renderer-&gt;isRubyRun())
2767         return AccessibilityRole::RubyRun;
2768     if (m_renderer-&gt;isRubyBlock())
2769         return AccessibilityRole::RubyBlock;
2770     if (m_renderer-&gt;isRubyInline())
2771         return AccessibilityRole::RubyInline;
2772 
2773     // This return value is what will be used if AccessibilityTableCell determines
2774     // the cell should not be treated as a cell (e.g. because it is a layout table.
2775     if (is&lt;RenderTableCell&gt;(renderer()))
2776         return AccessibilityRole::TextGroup;
2777 
2778     // Table sections should be ignored.
2779     if (m_renderer-&gt;isTableSection())
2780         return AccessibilityRole::Ignored;
2781 
2782     if (m_renderer-&gt;isHR())
2783         return AccessibilityRole::HorizontalRule;
2784 
2785     if (node &amp;&amp; node-&gt;hasTagName(pTag))
2786         return AccessibilityRole::Paragraph;
2787 
2788     if (is&lt;HTMLLabelElement&gt;(node))
2789         return AccessibilityRole::Label;
2790 
2791     if (node &amp;&amp; node-&gt;hasTagName(dfnTag))
2792         return AccessibilityRole::Definition;
2793 
2794     if (node &amp;&amp; node-&gt;hasTagName(divTag))
2795         return AccessibilityRole::Div;
2796 
2797     if (is&lt;HTMLFormElement&gt;(node))
2798         return AccessibilityRole::Form;
2799 
2800     if (node &amp;&amp; node-&gt;hasTagName(articleTag))
2801         return AccessibilityRole::DocumentArticle;
2802 
2803     if (node &amp;&amp; node-&gt;hasTagName(mainTag))
2804         return AccessibilityRole::LandmarkMain;
2805 
2806     if (node &amp;&amp; node-&gt;hasTagName(navTag))
2807         return AccessibilityRole::LandmarkNavigation;
2808 
2809     if (node &amp;&amp; node-&gt;hasTagName(asideTag))
2810         return AccessibilityRole::LandmarkComplementary;
2811 
2812     // The default role attribute value for the section element, region, became a landmark in ARIA 1.1.
2813     // The HTML AAM spec says it is &quot;strongly recommended&quot; that ATs only convey and provide navigation
2814     // for section elements which have names.
2815     if (node &amp;&amp; node-&gt;hasTagName(sectionTag))
2816         return hasAttribute(aria_labelAttr) || hasAttribute(aria_labelledbyAttr) ? AccessibilityRole::LandmarkRegion : AccessibilityRole::TextGroup;
2817 
2818     if (node &amp;&amp; node-&gt;hasTagName(addressTag))
2819         return AccessibilityRole::LandmarkContentInfo;
2820 
2821     if (node &amp;&amp; node-&gt;hasTagName(blockquoteTag))
2822         return AccessibilityRole::Blockquote;
2823 
2824     if (node &amp;&amp; node-&gt;hasTagName(captionTag))
2825         return AccessibilityRole::Caption;
2826 
2827     if (node &amp;&amp; node-&gt;hasTagName(markTag))
2828         return AccessibilityRole::Mark;
2829 
2830     if (node &amp;&amp; node-&gt;hasTagName(preTag))
2831         return AccessibilityRole::Pre;
2832 
2833     if (is&lt;HTMLDetailsElement&gt;(node))
2834         return AccessibilityRole::Details;
2835     if (is&lt;HTMLSummaryElement&gt;(node))
2836         return AccessibilityRole::Summary;
2837 
2838     // http://rawgit.com/w3c/aria/master/html-aam/html-aam.html
2839     // Output elements should be mapped to status role.
2840     if (isOutput())
2841         return AccessibilityRole::ApplicationStatus;
2842 
2843 #if ENABLE(VIDEO)
2844     if (is&lt;HTMLVideoElement&gt;(node))
2845         return AccessibilityRole::Video;
2846     if (is&lt;HTMLAudioElement&gt;(node))
2847         return AccessibilityRole::Audio;
2848 #endif
2849 
2850     // The HTML element should not be exposed as an element. That&#39;s what the RenderView element does.
2851     if (node &amp;&amp; node-&gt;hasTagName(htmlTag))
2852         return AccessibilityRole::Ignored;
2853 
2854     // There should only be one banner/contentInfo per page. If header/footer are being used within an article or section
2855     // then it should not be exposed as whole page&#39;s banner/contentInfo
2856     if (node &amp;&amp; node-&gt;hasTagName(headerTag) &amp;&amp; !isDescendantOfElementType(articleTag) &amp;&amp; !isDescendantOfElementType(sectionTag))
2857         return AccessibilityRole::LandmarkBanner;
2858     if (node &amp;&amp; node-&gt;hasTagName(footerTag) &amp;&amp; !isDescendantOfElementType(articleTag) &amp;&amp; !isDescendantOfElementType(sectionTag))
2859         return AccessibilityRole::Footer;
2860 
2861     // menu tags with toolbar type should have Toolbar role.
2862     if (node &amp;&amp; node-&gt;hasTagName(menuTag) &amp;&amp; equalLettersIgnoringASCIICase(getAttribute(typeAttr), &quot;toolbar&quot;))
2863         return AccessibilityRole::Toolbar;
2864 
2865     if (node &amp;&amp; node-&gt;hasTagName(timeTag))
2866         return AccessibilityRole::Time;
2867 
2868     // If the element does not have role, but it has ARIA attributes, or accepts tab focus, accessibility should fallback to exposing it as a group.
2869     if (supportsARIAAttributes() || canSetFocusAttribute())
2870         return AccessibilityRole::Group;
2871 
2872     if (m_renderer-&gt;isRenderBlockFlow())
2873         return m_renderer-&gt;isAnonymousBlock() ? AccessibilityRole::TextGroup : AccessibilityRole::Group;
2874 
2875     // InlineRole is the final fallback before assigning AccessibilityRole::Unknown to an object. It makes it
2876     // possible to distinguish truly unknown objects from non-focusable inline text elements
2877     // which have an event handler or attribute suggesting possible inclusion by the platform.
2878     if (is&lt;RenderInline&gt;(*m_renderer)
2879         &amp;&amp; (hasAttributesRequiredForInclusion()
2880             || (node &amp;&amp; node-&gt;hasEventListeners())
2881             || (supportsDatetimeAttribute() &amp;&amp; !getAttribute(datetimeAttr).isEmpty())))
2882         return AccessibilityRole::Inline;
2883 
2884     return AccessibilityRole::Unknown;
2885 }
2886 
2887 AccessibilityOrientation AccessibilityRenderObject::orientation() const
2888 {
2889     const AtomicString&amp; ariaOrientation = getAttribute(aria_orientationAttr);
2890     if (equalLettersIgnoringASCIICase(ariaOrientation, &quot;horizontal&quot;))
2891         return AccessibilityOrientation::Horizontal;
2892     if (equalLettersIgnoringASCIICase(ariaOrientation, &quot;vertical&quot;))
2893         return AccessibilityOrientation::Vertical;
2894     if (equalLettersIgnoringASCIICase(ariaOrientation, &quot;undefined&quot;))
2895         return AccessibilityOrientation::Undefined;
2896 
2897     // In ARIA 1.1, the implicit value of aria-orientation changed from horizontal
2898     // to undefined on all roles that don&#39;t have their own role-specific values. In
2899     // addition, the implicit value of combobox became undefined.
2900     if (isComboBox() || isRadioGroup() || isTreeGrid())
2901         return AccessibilityOrientation::Undefined;
2902 
2903     if (isScrollbar() || isListBox() || isMenu() || isTree())
2904         return AccessibilityOrientation::Vertical;
2905 
2906     if (isMenuBar() || isSplitter() || isTabList() || isToolbar() || isSlider())
2907         return AccessibilityOrientation::Horizontal;
2908 
2909     return AccessibilityObject::orientation();
2910 }
2911 
2912 bool AccessibilityRenderObject::inheritsPresentationalRole() const
2913 {
2914     // ARIA states if an item can get focus, it should not be presentational.
2915     if (canSetFocusAttribute())
2916         return false;
2917 
2918     // ARIA spec says that when a parent object is presentational, and it has required child elements,
2919     // those child elements are also presentational. For example, &lt;li&gt; becomes presentational from &lt;ul&gt;.
2920     // http://www.w3.org/WAI/PF/aria/complete#presentation
2921 
2922     const Vector&lt;const HTMLQualifiedName*&gt;* parentTags;
2923     switch (roleValue()) {
2924     case AccessibilityRole::ListItem:
2925     case AccessibilityRole::ListMarker: {
2926         static const auto listItemParents = makeNeverDestroyed(Vector&lt;const HTMLQualifiedName*&gt; { &amp;dlTag.get(), &amp;olTag.get(), &amp;ulTag.get() });
2927         parentTags = &amp;listItemParents.get();
2928         break;
2929     }
2930     case AccessibilityRole::GridCell:
2931     case AccessibilityRole::Cell: {
2932         static const auto tableCellParents = makeNeverDestroyed(Vector&lt;const HTMLQualifiedName*&gt; { &amp;tableTag.get() });
2933         parentTags = &amp;tableCellParents.get();
2934         break;
2935     }
2936     default:
2937         // Not all elements need to do the following check, only ones that are required children.
2938         return false;
2939     }
2940 
2941     for (auto* parent = parentObject(); parent; parent = parent-&gt;parentObject()) {
2942         if (!is&lt;AccessibilityRenderObject&gt;(*parent))
2943             continue;
2944 
2945         Node* node = downcast&lt;AccessibilityRenderObject&gt;(*parent).node();
2946         if (!is&lt;Element&gt;(node))
2947             continue;
2948 
2949         // If native tag of the parent element matches an acceptable name, then return
2950         // based on its presentational status.
2951         auto&amp; name = downcast&lt;Element&gt;(*node).tagQName();
2952         if (std::any_of(parentTags-&gt;begin(), parentTags-&gt;end(), [&amp;name] (auto* possibleName) { return *possibleName == name; }))
2953             return parent-&gt;roleValue() == AccessibilityRole::Presentational;
2954     }
2955 
2956     return false;
2957 }
2958 
2959 bool AccessibilityRenderObject::isPresentationalChildOfAriaRole() const
2960 {
2961     // Walk the parent chain looking for a parent that has presentational children
2962     AccessibilityObject* parent;
2963     for (parent = parentObject(); parent &amp;&amp; !parent-&gt;ariaRoleHasPresentationalChildren(); parent = parent-&gt;parentObject())
2964     { }
2965 
2966     return parent;
2967 }
2968 
2969 bool AccessibilityRenderObject::ariaRoleHasPresentationalChildren() const
2970 {
2971     switch (m_ariaRole) {
2972     case AccessibilityRole::Button:
2973     case AccessibilityRole::Slider:
2974     case AccessibilityRole::Image:
2975     case AccessibilityRole::ProgressIndicator:
2976     case AccessibilityRole::SpinButton:
2977     // case SeparatorRole:
2978         return true;
2979     default:
2980         return false;
2981     }
2982 }
2983 
2984 bool AccessibilityRenderObject::canSetExpandedAttribute() const
2985 {
2986     if (roleValue() == AccessibilityRole::Details)
2987         return true;
2988 
2989     // An object can be expanded if it aria-expanded is true or false.
2990     const AtomicString&amp; expanded = getAttribute(aria_expandedAttr);
2991     if (equalLettersIgnoringASCIICase(expanded, &quot;true&quot;) || equalLettersIgnoringASCIICase(expanded, &quot;false&quot;))
2992         return true;
2993     return false;
2994 }
2995 
2996 bool AccessibilityRenderObject::canSetTextRangeAttributes() const
2997 {
2998     return isTextControl();
2999 }
3000 
3001 void AccessibilityRenderObject::textChanged()
3002 {
3003     // If this element supports ARIA live regions, or is part of a region with an ARIA editable role,
3004     // then notify the AT of changes.
3005     AXObjectCache* cache = axObjectCache();
3006     if (!cache)
3007         return;
3008 
3009     for (RenderObject* renderParent = renderer(); renderParent; renderParent = renderParent-&gt;parent()) {
3010         AccessibilityObject* parent = cache-&gt;get(renderParent);
3011         if (!parent)
3012             continue;
3013 
3014         if (parent-&gt;supportsLiveRegion())
3015             cache-&gt;postLiveRegionChangeNotification(parent);
3016 
3017         if (parent-&gt;isNonNativeTextControl())
3018             cache-&gt;postNotification(renderParent, AXObjectCache::AXValueChanged);
3019     }
3020 }
3021 
3022 void AccessibilityRenderObject::clearChildren()
3023 {
3024     AccessibilityObject::clearChildren();
3025     m_childrenDirty = false;
3026 }
3027 
3028 void AccessibilityRenderObject::addImageMapChildren()
3029 {
3030     RenderBoxModelObject* cssBox = renderBoxModelObject();
3031     if (!is&lt;RenderImage&gt;(cssBox))
3032         return;
3033 
3034     HTMLMapElement* map = downcast&lt;RenderImage&gt;(*cssBox).imageMap();
3035     if (!map)
3036         return;
3037 
3038     for (auto&amp; area : descendantsOfType&lt;HTMLAreaElement&gt;(*map)) {
3039         // add an &lt;area&gt; element for this child if it has a link
3040         if (!area.isLink())
3041             continue;
3042         auto&amp; areaObject = downcast&lt;AccessibilityImageMapLink&gt;(*axObjectCache()-&gt;getOrCreate(AccessibilityRole::ImageMapLink));
3043         areaObject.setHTMLAreaElement(&amp;area);
3044         areaObject.setHTMLMapElement(map);
3045         areaObject.setParent(this);
3046         if (!areaObject.accessibilityIsIgnored())
3047             m_children.append(&amp;areaObject);
3048         else
3049             axObjectCache()-&gt;remove(areaObject.axObjectID());
3050     }
3051 }
3052 
3053 void AccessibilityRenderObject::updateChildrenIfNecessary()
3054 {
3055     if (needsToUpdateChildren())
3056         clearChildren();
3057 
3058     AccessibilityObject::updateChildrenIfNecessary();
3059 }
3060 
3061 void AccessibilityRenderObject::addTextFieldChildren()
3062 {
3063     Node* node = this-&gt;node();
3064     if (!is&lt;HTMLInputElement&gt;(node))
3065         return;
3066 
3067     HTMLInputElement&amp; input = downcast&lt;HTMLInputElement&gt;(*node);
3068     if (HTMLElement* autoFillElement = input.autoFillButtonElement()) {
3069         if (AccessibilityObject* axAutoFill = axObjectCache()-&gt;getOrCreate(autoFillElement))
3070             m_children.append(axAutoFill);
3071     }
3072 
3073     HTMLElement* spinButtonElement = input.innerSpinButtonElement();
3074     if (!is&lt;SpinButtonElement&gt;(spinButtonElement))
3075         return;
3076 
3077     auto&amp; axSpinButton = downcast&lt;AccessibilitySpinButton&gt;(*axObjectCache()-&gt;getOrCreate(AccessibilityRole::SpinButton));
3078     axSpinButton.setSpinButtonElement(downcast&lt;SpinButtonElement&gt;(spinButtonElement));
3079     axSpinButton.setParent(this);
3080     m_children.append(&amp;axSpinButton);
3081 }
3082 
3083 bool AccessibilityRenderObject::isSVGImage() const
3084 {
3085     return remoteSVGRootElement(Create);
3086 }
3087 
3088 void AccessibilityRenderObject::detachRemoteSVGRoot()
3089 {
3090     if (AccessibilitySVGRoot* root = remoteSVGRootElement(Retrieve))
3091         root-&gt;setParent(nullptr);
3092 }
3093 
3094 AccessibilitySVGRoot* AccessibilityRenderObject::remoteSVGRootElement(CreationChoice createIfNecessary) const
3095 {
3096     if (!is&lt;RenderImage&gt;(renderer()))
3097         return nullptr;
3098 
3099     CachedImage* cachedImage = downcast&lt;RenderImage&gt;(*m_renderer).cachedImage();
3100     if (!cachedImage)
3101         return nullptr;
3102 
3103     Image* image = cachedImage-&gt;image();
3104     if (!is&lt;SVGImage&gt;(image))
3105         return nullptr;
3106 
3107     FrameView* frameView = downcast&lt;SVGImage&gt;(*image).frameView();
3108     if (!frameView)
3109         return nullptr;
3110     Frame&amp; frame = frameView-&gt;frame();
3111 
3112     Document* document = frame.document();
3113     if (!is&lt;SVGDocument&gt;(document))
3114         return nullptr;
3115 
3116     auto rootElement = SVGDocument::rootElement(*document);
3117     if (!rootElement)
3118         return nullptr;
3119     RenderObject* rendererRoot = rootElement-&gt;renderer();
3120     if (!rendererRoot)
3121         return nullptr;
3122 
3123     AXObjectCache* cache = frame.document()-&gt;axObjectCache();
3124     if (!cache)
3125         return nullptr;
3126     AccessibilityObject* rootSVGObject = createIfNecessary == Create ? cache-&gt;getOrCreate(rendererRoot) : cache-&gt;get(rendererRoot);
3127 
3128     // In order to connect the AX hierarchy from the SVG root element from the loaded resource
3129     // the parent must be set, because there&#39;s no other way to get back to who created the image.
3130     ASSERT(!createIfNecessary || rootSVGObject);
3131     if (!is&lt;AccessibilitySVGRoot&gt;(rootSVGObject))
3132         return nullptr;
3133 
3134     return downcast&lt;AccessibilitySVGRoot&gt;(rootSVGObject);
3135 }
3136 
3137 void AccessibilityRenderObject::addRemoteSVGChildren()
3138 {
3139     AccessibilitySVGRoot* root = remoteSVGRootElement(Create);
3140     if (!root)
3141         return;
3142 
3143     root-&gt;setParent(this);
3144 
3145     if (root-&gt;accessibilityIsIgnored()) {
3146         for (const auto&amp; child : root-&gt;children())
3147             m_children.append(child);
3148     } else
3149         m_children.append(root);
3150 }
3151 
3152 void AccessibilityRenderObject::addCanvasChildren()
3153 {
3154     // Add the unrendered canvas children as AX nodes, unless we&#39;re not using a canvas renderer
3155     // because JS is disabled for example.
3156     if (!node() || !node()-&gt;hasTagName(canvasTag) || (renderer() &amp;&amp; !renderer()-&gt;isCanvas()))
3157         return;
3158 
3159     // If it&#39;s a canvas, it won&#39;t have rendered children, but it might have accessible fallback content.
3160     // Clear m_haveChildren because AccessibilityNodeObject::addChildren will expect it to be false.
3161     ASSERT(!m_children.size());
3162     m_haveChildren = false;
3163     AccessibilityNodeObject::addChildren();
3164 }
3165 
3166 void AccessibilityRenderObject::addAttachmentChildren()
3167 {
3168     if (!isAttachment())
3169         return;
3170 
3171     // FrameView&#39;s need to be inserted into the AX hierarchy when encountered.
3172     Widget* widget = widgetForAttachmentView();
3173     if (!widget || !widget-&gt;isFrameView())
3174         return;
3175 
3176     addChild(axObjectCache()-&gt;getOrCreate(widget));
3177 }
3178 
3179 #if PLATFORM(COCOA)
3180 void AccessibilityRenderObject::updateAttachmentViewParents()
3181 {
3182     // Only the unignored parent should set the attachment parent, because that&#39;s what is reflected in the AX
3183     // hierarchy to the client.
3184     if (accessibilityIsIgnored())
3185         return;
3186 
3187     for (const auto&amp; child : m_children) {
3188         if (child-&gt;isAttachment())
3189             child-&gt;overrideAttachmentParent(this);
3190     }
3191 }
3192 #endif
3193 
3194 // Hidden children are those that are not rendered or visible, but are specifically marked as aria-hidden=false,
3195 // meaning that they should be exposed to the AX hierarchy.
3196 void AccessibilityRenderObject::addHiddenChildren()
3197 {
3198     Node* node = this-&gt;node();
3199     if (!node)
3200         return;
3201 
3202     // First do a quick run through to determine if we have any hidden nodes (most often we will not).
3203     // If we do have hidden nodes, we need to determine where to insert them so they match DOM order as close as possible.
3204     bool shouldInsertHiddenNodes = false;
3205     for (Node* child = node-&gt;firstChild(); child; child = child-&gt;nextSibling()) {
3206         if (!child-&gt;renderer() &amp;&amp; isNodeAriaVisible(child)) {
3207             shouldInsertHiddenNodes = true;
3208             break;
3209         }
3210     }
3211 
3212     if (!shouldInsertHiddenNodes)
3213         return;
3214 
3215     // Iterate through all of the children, including those that may have already been added, and
3216     // try to insert hidden nodes in the correct place in the DOM order.
3217     unsigned insertionIndex = 0;
3218     for (Node* child = node-&gt;firstChild(); child; child = child-&gt;nextSibling()) {
3219         if (child-&gt;renderer()) {
3220             // Find out where the last render sibling is located within m_children.
3221             AccessibilityObject* childObject = axObjectCache()-&gt;get(child-&gt;renderer());
3222             if (childObject &amp;&amp; childObject-&gt;accessibilityIsIgnored()) {
3223                 auto&amp; children = childObject-&gt;children();
3224                 if (children.size())
3225                     childObject = children.last().get();
3226                 else
3227                     childObject = nullptr;
3228             }
3229 
3230             if (childObject)
3231                 insertionIndex = m_children.find(childObject) + 1;
3232             continue;
3233         }
3234 
3235         if (!isNodeAriaVisible(child))
3236             continue;
3237 
3238         unsigned previousSize = m_children.size();
3239         if (insertionIndex &gt; previousSize)
3240             insertionIndex = previousSize;
3241 
3242         insertChild(axObjectCache()-&gt;getOrCreate(child), insertionIndex);
3243         insertionIndex += (m_children.size() - previousSize);
3244     }
3245 }
3246 
3247 void AccessibilityRenderObject::updateRoleAfterChildrenCreation()
3248 {
3249     // If a menu does not have valid menuitem children, it should not be exposed as a menu.
3250     if (roleValue() == AccessibilityRole::Menu) {
3251         // Elements marked as menus must have at least one menu item child.
3252         size_t menuItemCount = 0;
3253         for (const auto&amp; child : children()) {
3254             if (child-&gt;isMenuItem()) {
3255                 menuItemCount++;
3256                 break;
3257             }
3258         }
3259 
3260         if (!menuItemCount)
3261             m_role = AccessibilityRole::Group;
3262     }
3263 }
3264 
3265 void AccessibilityRenderObject::addChildren()
3266 {
3267     // If the need to add more children in addition to existing children arises,
3268     // childrenChanged should have been called, leaving the object with no children.
3269     ASSERT(!m_haveChildren);
3270 
3271     m_haveChildren = true;
3272 
3273     if (!canHaveChildren())
3274         return;
3275 
3276     for (RefPtr&lt;AccessibilityObject&gt; obj = firstChild(); obj; obj = obj-&gt;nextSibling())
3277         addChild(obj.get());
3278 
3279     m_subtreeDirty = false;
3280 
3281     addHiddenChildren();
3282     addAttachmentChildren();
3283     addImageMapChildren();
3284     addTextFieldChildren();
3285     addCanvasChildren();
3286     addRemoteSVGChildren();
3287 
3288 #if PLATFORM(COCOA)
3289     updateAttachmentViewParents();
3290 #endif
3291 
3292     updateRoleAfterChildrenCreation();
3293 }
3294 
3295 bool AccessibilityRenderObject::canHaveChildren() const
3296 {
3297     if (!m_renderer)
3298         return false;
3299 
3300     return AccessibilityNodeObject::canHaveChildren();
3301 }
3302 
3303 const String AccessibilityRenderObject::liveRegionStatus() const
3304 {
3305     const AtomicString&amp; liveRegionStatus = getAttribute(aria_liveAttr);
3306     // These roles have implicit live region status.
3307     if (liveRegionStatus.isEmpty())
3308         return defaultLiveRegionStatusForRole(roleValue());
3309 
3310     return liveRegionStatus;
3311 }
3312 
3313 const String AccessibilityRenderObject::liveRegionRelevant() const
3314 {
3315     static NeverDestroyed&lt;const AtomicString&gt; defaultLiveRegionRelevant(&quot;additions text&quot;, AtomicString::ConstructFromLiteral);
3316     const AtomicString&amp; relevant = getAttribute(aria_relevantAttr);
3317 
3318     // Default aria-relevant = &quot;additions text&quot;.
3319     if (relevant.isEmpty())
3320         return &quot;additions text&quot;;
3321 
3322     return relevant;
3323 }
3324 
3325 bool AccessibilityRenderObject::liveRegionAtomic() const
3326 {
3327     const AtomicString&amp; atomic = getAttribute(aria_atomicAttr);
3328     if (equalLettersIgnoringASCIICase(atomic, &quot;true&quot;))
3329         return true;
3330     if (equalLettersIgnoringASCIICase(atomic, &quot;false&quot;))
3331         return false;
3332 
3333     // WAI-ARIA &quot;alert&quot; and &quot;status&quot; roles have an implicit aria-atomic value of true.
3334     switch (roleValue()) {
3335     case AccessibilityRole::ApplicationAlert:
3336     case AccessibilityRole::ApplicationStatus:
3337         return true;
3338     default:
3339         return false;
3340     }
3341 }
3342 
3343 bool AccessibilityRenderObject::isBusy() const
3344 {
3345     return elementAttributeValue(aria_busyAttr);
3346 }
3347 
3348 bool AccessibilityRenderObject::canHaveSelectedChildren() const
3349 {
3350     switch (roleValue()) {
3351     // These roles are containers whose children support aria-selected:
3352     case AccessibilityRole::Grid:
3353     case AccessibilityRole::ListBox:
3354     case AccessibilityRole::TabList:
3355     case AccessibilityRole::Tree:
3356     case AccessibilityRole::TreeGrid:
3357     case AccessibilityRole::List:
3358     // These roles are containers whose children are treated as selected by assistive
3359     // technologies. We can get the &quot;selected&quot; item via aria-activedescendant or the
3360     // focused element.
3361     case AccessibilityRole::Menu:
3362     case AccessibilityRole::MenuBar:
3363         return true;
3364     default:
3365         return false;
3366     }
3367 }
3368 
3369 void AccessibilityRenderObject::ariaSelectedRows(AccessibilityChildrenVector&amp; result)
3370 {
3371     // Determine which rows are selected.
3372     bool isMulti = isMultiSelectable();
3373 
3374     // Prefer active descendant over aria-selected.
3375     AccessibilityObject* activeDesc = activeDescendant();
3376     if (activeDesc &amp;&amp; (activeDesc-&gt;isTreeItem() || activeDesc-&gt;isTableRow())) {
3377         result.append(activeDesc);
3378         if (!isMulti)
3379             return;
3380     }
3381 
3382     // Get all the rows.
3383     auto rowsIteration = [&amp;](auto&amp; rows) {
3384         for (auto&amp; row : rows) {
3385             if (row-&gt;isSelected() || row-&gt;isActiveDescendantOfFocusedContainer()) {
3386                 result.append(row);
3387                 if (!isMulti)
3388                     break;
3389             }
3390         }
3391     };
3392     if (isTree()) {
3393         AccessibilityChildrenVector allRows;
3394         ariaTreeRows(allRows);
3395         rowsIteration(allRows);
3396     } else if (is&lt;AccessibilityTable&gt;(*this)) {
3397         auto&amp; thisTable = downcast&lt;AccessibilityTable&gt;(*this);
3398         if (thisTable.isExposableThroughAccessibility() &amp;&amp; thisTable.supportsSelectedRows())
3399             rowsIteration(thisTable.rows());
3400     }
3401 }
3402 
3403 void AccessibilityRenderObject::ariaListboxSelectedChildren(AccessibilityChildrenVector&amp; result)
3404 {
3405     bool isMulti = isMultiSelectable();
3406 
3407     for (const auto&amp; child : children()) {
3408         // Every child should have aria-role option, and if so, check for selected attribute/state.
3409         if (child-&gt;ariaRoleAttribute() == AccessibilityRole::ListBoxOption &amp;&amp; (child-&gt;isSelected() || child-&gt;isActiveDescendantOfFocusedContainer())) {
3410             result.append(child);
3411             if (!isMulti)
3412                 return;
3413         }
3414     }
3415 }
3416 
3417 void AccessibilityRenderObject::selectedChildren(AccessibilityChildrenVector&amp; result)
3418 {
3419     ASSERT(result.isEmpty());
3420 
3421     if (!canHaveSelectedChildren())
3422         return;
3423 
3424     switch (roleValue()) {
3425     case AccessibilityRole::ListBox:
3426         // native list boxes would be AccessibilityListBoxes, so only check for aria list boxes
3427         ariaListboxSelectedChildren(result);
3428         return;
3429     case AccessibilityRole::Grid:
3430     case AccessibilityRole::Tree:
3431     case AccessibilityRole::TreeGrid:
3432         ariaSelectedRows(result);
3433         return;
3434     case AccessibilityRole::TabList:
3435         if (AccessibilityObject* selectedTab = selectedTabItem())
3436             result.append(selectedTab);
3437         return;
3438     case AccessibilityRole::List:
3439         if (auto* selectedListItemChild = selectedListItem())
3440             result.append(selectedListItemChild);
3441         return;
3442     case AccessibilityRole::Menu:
3443     case AccessibilityRole::MenuBar:
3444         if (AccessibilityObject* descendant = activeDescendant()) {
3445             result.append(descendant);
3446             return;
3447         }
3448         if (AccessibilityObject* focusedElement = focusedUIElement()) {
3449             result.append(focusedElement);
3450             return;
3451         }
3452         return;
3453     default:
3454         ASSERT_NOT_REACHED();
3455     }
3456 }
3457 
3458 void AccessibilityRenderObject::ariaListboxVisibleChildren(AccessibilityChildrenVector&amp; result)
3459 {
3460     if (!hasChildren())
3461         addChildren();
3462 
3463     for (const auto&amp; child : children()) {
3464         if (child-&gt;isOffScreen())
3465             result.append(child);
3466     }
3467 }
3468 
3469 void AccessibilityRenderObject::visibleChildren(AccessibilityChildrenVector&amp; result)
3470 {
3471     ASSERT(result.isEmpty());
3472 
3473     // only listboxes are asked for their visible children.
3474     if (ariaRoleAttribute() != AccessibilityRole::ListBox) {
3475         // native list boxes would be AccessibilityListBoxes, so only check for aria list boxes
3476         ASSERT_NOT_REACHED();
3477         return;
3478     }
3479     return ariaListboxVisibleChildren(result);
3480 }
3481 
3482 void AccessibilityRenderObject::tabChildren(AccessibilityChildrenVector&amp; result)
3483 {
3484     ASSERT(roleValue() == AccessibilityRole::TabList);
3485 
3486     for (const auto&amp; child : children()) {
3487         if (child-&gt;isTabItem())
3488             result.append(child);
3489     }
3490 }
3491 
3492 const String&amp; AccessibilityRenderObject::actionVerb() const
3493 {
3494 #if !PLATFORM(IOS_FAMILY)
3495     // FIXME: Need to add verbs for select elements.
3496     static NeverDestroyed&lt;const String&gt; buttonAction(AXButtonActionVerb());
3497     static NeverDestroyed&lt;const String&gt; textFieldAction(AXTextFieldActionVerb());
3498     static NeverDestroyed&lt;const String&gt; radioButtonAction(AXRadioButtonActionVerb());
3499     static NeverDestroyed&lt;const String&gt; checkedCheckBoxAction(AXUncheckedCheckBoxActionVerb());
3500     static NeverDestroyed&lt;const String&gt; uncheckedCheckBoxAction(AXUncheckedCheckBoxActionVerb());
3501     static NeverDestroyed&lt;const String&gt; linkAction(AXLinkActionVerb());
3502 
3503     switch (roleValue()) {
3504     case AccessibilityRole::Button:
3505     case AccessibilityRole::ToggleButton:
3506         return buttonAction;
3507     case AccessibilityRole::TextField:
3508     case AccessibilityRole::TextArea:
3509         return textFieldAction;
3510     case AccessibilityRole::RadioButton:
3511         return radioButtonAction;
3512     case AccessibilityRole::CheckBox:
3513         return isChecked() ? checkedCheckBoxAction : uncheckedCheckBoxAction;
3514     case AccessibilityRole::Link:
3515     case AccessibilityRole::WebCoreLink:
3516         return linkAction;
3517     default:
3518         return nullAtom();
3519     }
3520 #else
3521     return nullAtom();
3522 #endif
3523 }
3524 
3525 void AccessibilityRenderObject::setAccessibleName(const AtomicString&amp; name)
3526 {
3527     // Setting the accessible name can store the value in the DOM
3528     if (!m_renderer)
3529         return;
3530 
3531     Node* node = nullptr;
3532     // For web areas, set the aria-label on the HTML element.
3533     if (isWebArea())
3534         node = m_renderer-&gt;document().documentElement();
3535     else
3536         node = m_renderer-&gt;node();
3537 
3538     if (is&lt;Element&gt;(node))
3539         downcast&lt;Element&gt;(*node).setAttribute(aria_labelAttr, name);
3540 }
3541 
3542 static bool isLinkable(const AccessibilityRenderObject&amp; object)
3543 {
3544     if (!object.renderer())
3545         return false;
3546 
3547     // See https://wiki.mozilla.org/Accessibility/AT-Windows-API for the elements
3548     // Mozilla considers linkable.
3549     return object.isLink() || object.isImage() || object.renderer()-&gt;isText();
3550 }
3551 
3552 String AccessibilityRenderObject::stringValueForMSAA() const
3553 {
3554     if (isLinkable(*this)) {
3555         Element* anchor = anchorElement();
3556         if (is&lt;HTMLAnchorElement&gt;(anchor))
3557             return downcast&lt;HTMLAnchorElement&gt;(*anchor).href();
3558     }
3559 
3560     return stringValue();
3561 }
3562 
3563 bool AccessibilityRenderObject::isLinked() const
3564 {
3565     if (!isLinkable(*this))
3566         return false;
3567 
3568     Element* anchor = anchorElement();
3569     if (!is&lt;HTMLAnchorElement&gt;(anchor))
3570         return false;
3571 
3572     return !downcast&lt;HTMLAnchorElement&gt;(*anchor).href().isEmpty();
3573 }
3574 
3575 bool AccessibilityRenderObject::hasBoldFont() const
3576 {
3577     if (!m_renderer)
3578         return false;
3579 
3580     return isFontWeightBold(m_renderer-&gt;style().fontDescription().weight());
3581 }
3582 
3583 bool AccessibilityRenderObject::hasItalicFont() const
3584 {
3585     if (!m_renderer)
3586         return false;
3587 
3588     return isItalic(m_renderer-&gt;style().fontDescription().italic());
3589 }
3590 
3591 bool AccessibilityRenderObject::hasPlainText() const
3592 {
3593     if (!m_renderer)
3594         return false;
3595 
3596     if (!canHavePlainText())
3597         return false;
3598 
3599     const RenderStyle&amp; style = m_renderer-&gt;style();
3600     return style.fontDescription().weight() == normalWeightValue()
3601         &amp;&amp; !isItalic(style.fontDescription().italic())
3602         &amp;&amp; style.textDecorationsInEffect().isEmpty();
3603 }
3604 
3605 bool AccessibilityRenderObject::hasSameFont(RenderObject* renderer) const
3606 {
3607     if (!m_renderer || !renderer)
3608         return false;
3609 
3610     return m_renderer-&gt;style().fontDescription().families() == renderer-&gt;style().fontDescription().families();
3611 }
3612 
3613 bool AccessibilityRenderObject::hasSameFontColor(RenderObject* renderer) const
3614 {
3615     if (!m_renderer || !renderer)
3616         return false;
3617 
3618     return m_renderer-&gt;style().visitedDependentColor(CSSPropertyColor) == renderer-&gt;style().visitedDependentColor(CSSPropertyColor);
3619 }
3620 
3621 bool AccessibilityRenderObject::hasSameStyle(RenderObject* renderer) const
3622 {
3623     if (!m_renderer || !renderer)
3624         return false;
3625 
3626     return m_renderer-&gt;style() == renderer-&gt;style();
3627 }
3628 
3629 bool AccessibilityRenderObject::hasUnderline() const
3630 {
3631     if (!m_renderer)
3632         return false;
3633 
3634     return m_renderer-&gt;style().textDecorationsInEffect().contains(TextDecoration::Underline);
3635 }
3636 
3637 String AccessibilityRenderObject::nameForMSAA() const
3638 {
3639     if (m_renderer &amp;&amp; m_renderer-&gt;isText())
3640         return textUnderElement();
3641 
3642     return title();
3643 }
3644 
3645 static bool shouldReturnTagNameAsRoleForMSAA(const Element&amp; element)
3646 {
3647     return element.hasTagName(abbrTag) || element.hasTagName(acronymTag)
3648         || element.hasTagName(blockquoteTag) || element.hasTagName(ddTag)
3649         || element.hasTagName(dlTag) || element.hasTagName(dtTag)
3650         || element.hasTagName(formTag) || element.hasTagName(frameTag)
3651         || element.hasTagName(h1Tag) || element.hasTagName(h2Tag)
3652         || element.hasTagName(h3Tag) || element.hasTagName(h4Tag)
3653         || element.hasTagName(h5Tag) || element.hasTagName(h6Tag)
3654         || element.hasTagName(iframeTag) || element.hasTagName(qTag)
3655         || element.hasTagName(tbodyTag) || element.hasTagName(tfootTag)
3656         || element.hasTagName(theadTag);
3657 }
3658 
3659 String AccessibilityRenderObject::stringRoleForMSAA() const
3660 {
3661     if (!m_renderer)
3662         return String();
3663 
3664     Node* node = m_renderer-&gt;node();
3665     if (!is&lt;Element&gt;(node))
3666         return String();
3667 
3668     Element&amp; element = downcast&lt;Element&gt;(*node);
3669     if (!shouldReturnTagNameAsRoleForMSAA(element))
3670         return String();
3671 
3672     return element.tagName();
3673 }
3674 
3675 String AccessibilityRenderObject::positionalDescriptionForMSAA() const
3676 {
3677     // See &quot;positional descriptions&quot;,
3678     // https://wiki.mozilla.org/Accessibility/AT-Windows-API
3679     if (isHeading())
3680         return makeString(&#39;L&#39;, headingLevel());
3681 
3682     // FIXME: Add positional descriptions for other elements.
3683     return String();
3684 }
3685 
3686 String AccessibilityRenderObject::descriptionForMSAA() const
3687 {
3688     String description = positionalDescriptionForMSAA();
3689     if (!description.isEmpty())
3690         return description;
3691 
3692     description = accessibilityDescription();
3693     if (!description.isEmpty()) {
3694         // From the Mozilla MSAA implementation:
3695         // &quot;Signal to screen readers that this description is speakable and is not
3696         // a formatted positional information description. Don&#39;t localize the
3697         // &#39;Description: &#39; part of this string, it will be parsed out by assistive
3698         // technologies.&quot;
3699         return &quot;Description: &quot; + description;
3700     }
3701 
3702     return String();
3703 }
3704 
3705 static AccessibilityRole msaaRoleForRenderer(const RenderObject* renderer)
3706 {
3707     if (!renderer)
3708         return AccessibilityRole::Unknown;
3709 
3710     if (is&lt;RenderText&gt;(*renderer))
3711         return AccessibilityRole::EditableText;
3712 
3713     if (is&lt;RenderListItem&gt;(*renderer))
3714         return AccessibilityRole::ListItem;
3715 
3716     return AccessibilityRole::Unknown;
3717 }
3718 
3719 AccessibilityRole AccessibilityRenderObject::roleValueForMSAA() const
3720 {
3721     if (m_roleForMSAA != AccessibilityRole::Unknown)
3722         return m_roleForMSAA;
3723 
3724     m_roleForMSAA = msaaRoleForRenderer(renderer());
3725 
3726     if (m_roleForMSAA == AccessibilityRole::Unknown)
3727         m_roleForMSAA = roleValue();
3728 
3729     return m_roleForMSAA;
3730 }
3731 
3732 String AccessibilityRenderObject::passwordFieldValue() const
3733 {
3734     ASSERT(isPasswordField());
3735 
3736     // Look for the RenderText object in the RenderObject tree for this input field.
3737     RenderObject* renderer = node()-&gt;renderer();
3738     while (renderer &amp;&amp; !is&lt;RenderText&gt;(renderer))
3739         renderer = downcast&lt;RenderElement&gt;(*renderer).firstChild();
3740 
3741     if (!is&lt;RenderText&gt;(renderer))
3742         return String();
3743 
3744     // Return the text that is actually being rendered in the input field.
3745     return downcast&lt;RenderText&gt;(*renderer).textWithoutConvertingBackslashToYenSymbol();
3746 }
3747 
3748 ScrollableArea* AccessibilityRenderObject::getScrollableAreaIfScrollable() const
3749 {
3750     // If the parent is a scroll view, then this object isn&#39;t really scrollable, the parent ScrollView should handle the scrolling.
3751     if (parentObject() &amp;&amp; parentObject()-&gt;isAccessibilityScrollView())
3752         return nullptr;
3753 
3754     if (!is&lt;RenderBox&gt;(renderer()))
3755         return nullptr;
3756 
3757     auto&amp; box = downcast&lt;RenderBox&gt;(*m_renderer);
3758     if (!box.canBeScrolledAndHasScrollableArea())
3759         return nullptr;
3760 
3761     return box.layer();
3762 }
3763 
3764 void AccessibilityRenderObject::scrollTo(const IntPoint&amp; point) const
3765 {
3766     if (!is&lt;RenderBox&gt;(renderer()))
3767         return;
3768 
3769     auto&amp; box = downcast&lt;RenderBox&gt;(*m_renderer);
3770     if (!box.canBeScrolledAndHasScrollableArea())
3771         return;
3772 
3773     // FIXME: is point a ScrollOffset or ScrollPosition? Test in RTL overflow.
3774     box.layer()-&gt;scrollToOffset(point);
3775 }
3776 
3777 #if ENABLE(MATHML)
3778 bool AccessibilityRenderObject::isIgnoredElementWithinMathTree() const
3779 {
3780     // We ignore anonymous boxes inserted into RenderMathMLBlocks to honor CSS rules.
3781     // See https://www.w3.org/TR/css3-box/#block-level0
3782     return m_renderer &amp;&amp; m_renderer-&gt;isAnonymous() &amp;&amp; m_renderer-&gt;parent() &amp;&amp; is&lt;RenderMathMLBlock&gt;(m_renderer-&gt;parent());
3783 }
3784 #endif
3785 
3786 } // namespace WebCore
    </pre>
  </body>
</html>