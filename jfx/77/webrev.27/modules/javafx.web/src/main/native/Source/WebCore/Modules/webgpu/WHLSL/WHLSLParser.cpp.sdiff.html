<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/Modules/webgpu/WHLSL/WHLSLParser.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="WHLSLNameResolver.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="WHLSLParser.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/Modules/webgpu/WHLSL/WHLSLParser.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
  14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
  15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
  17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
  23  * THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #include &quot;config.h&quot;
  27 #include &quot;WHLSLParser.h&quot;
  28 
  29 #if ENABLE(WEBGPU)
  30 
  31 #include &quot;WHLSLAddressSpace.h&quot;
  32 #include &quot;WHLSLEntryPointType.h&quot;

  33 #include &lt;wtf/dtoa.h&gt;
  34 #include &lt;wtf/text/StringBuilder.h&gt;
  35 #include &lt;wtf/text/StringConcatenate.h&gt;
  36 
  37 namespace WebCore {
  38 
  39 namespace WHLSL {
  40 
<span class="line-modified">  41 // FIXME: Return a better error code from this, and report it to JavaScript.</span>
<span class="line-modified">  42 auto Parser::parse(Program&amp; program, StringView stringView, Mode mode) -&gt; Optional&lt;Error&gt;</span>



















  43 {
<span class="line-modified">  44     m_lexer = Lexer(stringView);</span>
  45     m_mode = mode;
  46 
  47     while (!m_lexer.isFullyConsumed()) {
<span class="line-modified">  48         if (tryType(Lexer::Token::Type::Semicolon)) {</span>




  49             m_lexer.consumeToken();
  50             continue;








  51         }
<span class="line-modified">  52 </span>
<span class="line-modified">  53         {</span>
<span class="line-modified">  54             auto typeDefinition = backtrackingScope&lt;Expected&lt;AST::TypeDefinition, Error&gt;&gt;([&amp;]() {</span>
<span class="line-modified">  55                 return parseTypeDefinition();</span>
<span class="line-modified">  56             });</span>
<span class="line-modified">  57             if (typeDefinition) {</span>
<span class="line-modified">  58                 auto success = program.append(WTFMove(*typeDefinition));</span>
<span class="line-modified">  59                 if (!success)</span>
<span class="line-removed">  60                     return WTF::nullopt;</span>
<span class="line-removed">  61                 continue;</span>
<span class="line-removed">  62             }</span>
  63         }
<span class="line-modified">  64 </span>
<span class="line-modified">  65         {</span>
<span class="line-modified">  66             auto structureDefinition = backtrackingScope&lt;Expected&lt;AST::StructureDefinition, Error&gt;&gt;([&amp;]() {</span>
<span class="line-modified">  67                 return parseStructureDefinition();</span>
<span class="line-modified">  68             });</span>
<span class="line-modified">  69             if (structureDefinition) {</span>
<span class="line-modified">  70                 auto success = program.append(WTFMove(*structureDefinition));</span>
<span class="line-modified">  71                 if (!success)</span>
<span class="line-removed">  72                     return WTF::nullopt;</span>
<span class="line-removed">  73                 continue;</span>
<span class="line-removed">  74             }</span>
  75         }
<span class="line-modified">  76 </span>
<span class="line-modified">  77         {</span>
<span class="line-modified">  78             auto enumerationDefinition = backtrackingScope&lt;Expected&lt;AST::EnumerationDefinition, Error&gt;&gt;([&amp;]() {</span>
<span class="line-modified">  79                 return parseEnumerationDefinition();</span>
<span class="line-modified">  80             });</span>
<span class="line-modified">  81             if (enumerationDefinition) {</span>
<span class="line-modified">  82                 auto success = program.append(WTFMove(*enumerationDefinition));</span>
<span class="line-modified">  83                 if (!success)</span>
<span class="line-modified">  84                     return WTF::nullopt;</span>




  85                 continue;
  86             }







  87         }
<span class="line-modified">  88 </span>
<span class="line-modified">  89         Optional&lt;Error&gt; error;</span>
<span class="line-modified">  90         {</span>
<span class="line-modified">  91             auto functionDefinition = backtrackingScope&lt;Expected&lt;AST::FunctionDefinition, Error&gt;&gt;([&amp;]() {</span>
<span class="line-modified">  92                 return parseFunctionDefinition();</span>
<span class="line-modified">  93             });</span>
<span class="line-modified">  94             if (functionDefinition) {</span>
<span class="line-modified">  95                 auto success = program.append(WTFMove(*functionDefinition));</span>
<span class="line-removed">  96                 if (!success)</span>
<span class="line-removed">  97                     return WTF::nullopt;</span>
<span class="line-removed">  98                 continue;</span>
<span class="line-removed">  99             }</span>
<span class="line-removed"> 100             error = functionDefinition.error();</span>
 101         }
<span class="line-removed"> 102 </span>
<span class="line-removed"> 103         if (m_mode == Mode::StandardLibrary) {</span>
<span class="line-removed"> 104             auto nativeFunctionDeclaration = backtrackingScope&lt;Expected&lt;AST::NativeFunctionDeclaration, Error&gt;&gt;([&amp;]() {</span>
<span class="line-removed"> 105                 return parseNativeFunctionDeclaration();</span>
<span class="line-removed"> 106             });</span>
<span class="line-removed"> 107             if (nativeFunctionDeclaration) {</span>
<span class="line-removed"> 108                 auto success = program.append(WTFMove(*nativeFunctionDeclaration));</span>
<span class="line-removed"> 109                 if (!success)</span>
<span class="line-removed"> 110                     return WTF::nullopt;</span>
<span class="line-removed"> 111                 continue;</span>
<span class="line-removed"> 112             }</span>
 113         }

 114 
<span class="line-modified"> 115         if (m_mode == Mode::StandardLibrary) {</span>
<span class="line-modified"> 116             auto nativeTypeDeclaration = backtrackingScope&lt;Expected&lt;AST::NativeTypeDeclaration, Error&gt;&gt;([&amp;]() {</span>
<span class="line-removed"> 117                 return parseNativeTypeDeclaration();</span>
<span class="line-removed"> 118             });</span>
<span class="line-removed"> 119             if (nativeTypeDeclaration) {</span>
<span class="line-removed"> 120                 auto success = program.append(WTFMove(*nativeTypeDeclaration));</span>
<span class="line-removed"> 121                 if (!success)</span>
<span class="line-removed"> 122                     return WTF::nullopt;</span>
<span class="line-removed"> 123                 continue;</span>
<span class="line-removed"> 124             }</span>
<span class="line-removed"> 125         }</span>
 126 
<span class="line-modified"> 127         return WTFMove(*error);</span>




 128     }
<span class="line-modified"> 129     return WTF::nullopt;</span>
 130 }
 131 
<span class="line-modified"> 132 auto Parser::fail(const String&amp; message) -&gt; Unexpected&lt;Error&gt;</span>
 133 {
<span class="line-modified"> 134     if (auto nextToken = peek())</span>
<span class="line-modified"> 135         return Unexpected&lt;Error&gt;(Error(m_lexer.errorString(*nextToken, message)));</span>
<span class="line-modified"> 136     return Unexpected&lt;Error&gt;(Error(makeString(&quot;Cannot lex: &quot;, message)));</span>

 137 }
 138 
<span class="line-modified"> 139 auto Parser::peek() -&gt; Expected&lt;Lexer::Token, Error&gt;</span>
 140 {
<span class="line-modified"> 141     if (auto token = m_lexer.consumeToken()) {</span>
<span class="line-modified"> 142         m_lexer.unconsumeToken(Lexer::Token(*token));</span>
<span class="line-modified"> 143         return *token;</span>


























 144     }
<span class="line-modified"> 145     return fail(&quot;Cannot consume token&quot;_str);</span>






 146 }
 147 
<span class="line-modified"> 148 Optional&lt;Lexer::Token&gt; Parser::tryType(Lexer::Token::Type type)</span>

 149 {
<span class="line-modified"> 150     if (auto token = m_lexer.consumeToken()) {</span>
<span class="line-modified"> 151         if (token-&gt;type == type)</span>
<span class="line-modified"> 152             return token;</span>
<span class="line-modified"> 153         m_lexer.unconsumeToken(Lexer::Token(*token));</span>
<span class="line-modified"> 154     }</span>




 155     return WTF::nullopt;
 156 }
 157 
<span class="line-modified"> 158 Optional&lt;Lexer::Token&gt; Parser::tryTypes(Vector&lt;Lexer::Token::Type&gt; types)</span>

 159 {
<span class="line-modified"> 160     if (auto token = m_lexer.consumeToken()) {</span>
<span class="line-modified"> 161         if (std::find(types.begin(), types.end(), token-&gt;type) != types.end())</span>
<span class="line-modified"> 162             return token;</span>
<span class="line-removed"> 163         m_lexer.unconsumeToken(Lexer::Token(*token));</span>
<span class="line-removed"> 164     }</span>
 165     return WTF::nullopt;
 166 }
 167 
<span class="line-modified"> 168 auto Parser::consumeType(Lexer::Token::Type type) -&gt; Expected&lt;Lexer::Token, Error&gt;</span>
 169 {
<span class="line-modified"> 170     if (auto token = m_lexer.consumeToken()) {</span>
<span class="line-modified"> 171         if (token-&gt;type == type)</span>
<span class="line-modified"> 172             return *token;</span>
<span class="line-modified"> 173         return fail(makeString(&quot;Unexpected token (expected &quot;, Lexer::Token::typeName(type), &quot; got &quot;, Lexer::Token::typeName(token-&gt;type), &quot;)&quot;));</span>
<span class="line-removed"> 174     }</span>
<span class="line-removed"> 175     return fail(makeString(&quot;Cannot consume token (expected &quot;, Lexer::Token::typeName(type), &quot;)&quot;));</span>
 176 }
 177 
<span class="line-modified"> 178 auto Parser::consumeTypes(Vector&lt;Lexer::Token::Type&gt; types) -&gt; Expected&lt;Lexer::Token, Error&gt;</span>

 179 {
 180     auto buildExpectedString = [&amp;]() -&gt; String {
 181         StringBuilder builder;
 182         builder.append(&quot;[&quot;);
<span class="line-modified"> 183         for (unsigned i = 0; i &lt; types.size(); ++i) {</span>
<span class="line-removed"> 184             if (i &gt; 0)</span>
<span class="line-removed"> 185                 builder.append(&quot;, &quot;);</span>
<span class="line-removed"> 186             builder.append(Lexer::Token::typeName(types[i]));</span>
<span class="line-removed"> 187         }</span>
 188         builder.append(&quot;]&quot;);
 189         return builder.toString();
 190     };
 191 
<span class="line-modified"> 192     if (auto token = m_lexer.consumeToken()) {</span>
<span class="line-modified"> 193         if (std::find(types.begin(), types.end(), token-&gt;type) != types.end())</span>
<span class="line-modified"> 194             return *token;</span>
<span class="line-modified"> 195         return fail(makeString(&quot;Unexpected token (expected one of &quot;, buildExpectedString(), &quot; got &quot;, Lexer::Token::typeName(token-&gt;type), &quot;)&quot;));</span>
<span class="line-removed"> 196     }</span>
<span class="line-removed"> 197     return fail(makeString(&quot;Cannot consume token (expected &quot;, buildExpectedString(), &quot;)&quot;));</span>
 198 }
 199 
 200 static int digitValue(UChar character)
 201 {
 202     if (character &gt;= &#39;0&#39; &amp;&amp; character &lt;= &#39;9&#39;)
 203         return character - &#39;0&#39;;
 204     if (character &gt;= &#39;a&#39; &amp;&amp; character &lt;= &#39;f&#39;)
 205         return character - &#39;a&#39; + 10;
 206     return character - &#39;A&#39; + 10;
 207 }
 208 
<span class="line-modified"> 209 static Expected&lt;int, Parser::Error&gt; intLiteralToInt(StringView text)</span>
 210 {
 211     bool negate = false;
 212     if (text.startsWith(&quot;-&quot;_str)) {
 213         negate = true;
 214         text = text.substring(1);
 215     }
 216     int base = 10;
 217     if (text.startsWith(&quot;0x&quot;_str)) {
 218         text = text.substring(2);
 219         base = 16;
 220     }
 221 
 222     unsigned result = 0;
 223     for (auto codePoint : text.codePoints()) {
 224         unsigned digit = digitValue(codePoint);
 225         auto previous = result;
 226         result = result * base + digit;
 227         if (result &lt; previous)
<span class="line-modified"> 228             return Unexpected&lt;Parser::Error&gt;(Parser::Error(makeString(&quot;int literal &quot;, text, &quot; is out of bounds&quot;)));</span>
 229     }
 230     if (negate) {
<span class="line-modified"> 231         static_assert(std::numeric_limits&lt;long long int&gt;::min() &lt; std::numeric_limits&lt;int&gt;::min(), &quot;long long needs to be bigger than an int&quot;);</span>
<span class="line-modified"> 232         if (static_cast&lt;long long&gt;(result) &gt; std::abs(static_cast&lt;long long&gt;(std::numeric_limits&lt;int&gt;::min())))</span>
<span class="line-modified"> 233             return Unexpected&lt;Parser::Error&gt;(Parser::Error(makeString(&quot;int literal &quot;, text, &quot; is out of bounds&quot;)));</span>
<span class="line-modified"> 234         return { static_cast&lt;int&gt;(static_cast&lt;long long&gt;(result) * 1) };</span>

 235     }
 236     if (result &gt; static_cast&lt;unsigned&gt;(std::numeric_limits&lt;int&gt;::max()))
<span class="line-modified"> 237         return Unexpected&lt;Parser::Error&gt;(Parser::Error(makeString(&quot;int literal &quot;, text, &quot; is out of bounds&quot;)));</span>
 238     return { static_cast&lt;int&gt;(result) };
 239 }
 240 
<span class="line-modified"> 241 static Expected&lt;unsigned, Parser::Error&gt; uintLiteralToUint(StringView text)</span>
 242 {
 243     unsigned base = 10;
 244     if (text.startsWith(&quot;0x&quot;_str)) {
 245         text = text.substring(2);
 246         base = 16;
 247     }
 248     ASSERT(text.endsWith(&quot;u&quot;));
 249     text = text.substring(0, text.length() - 1);
 250     unsigned result = 0;
 251     for (auto codePoint : text.codePoints()) {
 252         unsigned digit = digitValue(codePoint);
 253         auto previous = result;
 254         result = result * base + digit;
 255         if (result &lt; previous)
<span class="line-modified"> 256             return Unexpected&lt;Parser::Error&gt;(Parser::Error(makeString(&quot;uint literal &quot;, text, &quot; is out of bounds&quot;)));</span>
 257     }
 258     return { result };
 259 }
 260 
<span class="line-modified"> 261 static Expected&lt;float, Parser::Error&gt; floatLiteralToFloat(StringView text)</span>
 262 {
 263     size_t parsedLength;
 264     auto result = parseDouble(text, parsedLength);
 265     if (parsedLength != text.length())
<span class="line-modified"> 266         return Unexpected&lt;Parser::Error&gt;(Parser::Error(makeString(&quot;Cannot parse float &quot;, text)));</span>
 267     return static_cast&lt;float&gt;(result);
 268 }
 269 
 270 auto Parser::consumeIntegralLiteral() -&gt; Expected&lt;Variant&lt;int, unsigned&gt;, Error&gt;
 271 {
<span class="line-modified"> 272     auto integralLiteralToken = consumeTypes({ Lexer::Token::Type::IntLiteral, Lexer::Token::Type::UintLiteral });</span>
 273     if (!integralLiteralToken)
<span class="line-modified"> 274         return Unexpected&lt;Error&gt;(integralLiteralToken.error());</span>
 275 
 276     switch (integralLiteralToken-&gt;type) {
<span class="line-modified"> 277     case Lexer::Token::Type::IntLiteral: {</span>
<span class="line-modified"> 278         auto result = intLiteralToInt(integralLiteralToken-&gt;stringView);</span>
 279         if (result)
 280             return {{ *result }};
<span class="line-modified"> 281         return Unexpected&lt;Error&gt;(result.error());</span>
 282     }
 283     default: {
<span class="line-modified"> 284         ASSERT(integralLiteralToken-&gt;type == Lexer::Token::Type::UintLiteral);</span>
<span class="line-modified"> 285         auto result = uintLiteralToUint(integralLiteralToken-&gt;stringView);</span>
 286         if (result)
 287             return {{ *result }};
<span class="line-modified"> 288         return Unexpected&lt;Error&gt;(result.error());</span>
 289     }
 290     }
 291 }
 292 
 293 auto Parser::consumeNonNegativeIntegralLiteral() -&gt; Expected&lt;unsigned, Error&gt;
 294 {
 295     auto integralLiteral = consumeIntegralLiteral();
 296     if (!integralLiteral)
<span class="line-modified"> 297         return Unexpected&lt;Error&gt;(integralLiteral.error());</span>
 298     auto result = WTF::visit(WTF::makeVisitor([](int x) -&gt; Optional&lt;unsigned&gt; {
 299         if (x &lt; 0)
 300             return WTF::nullopt;
 301         return x;
 302     }, [](unsigned x) -&gt; Optional&lt;unsigned&gt; {
 303         return x;
 304     }), *integralLiteral);
 305     if (result)
 306         return *result;
 307     return fail(&quot;int literal is negative&quot;_str);
 308 }
 309 
<span class="line-modified"> 310 static Expected&lt;unsigned, Parser::Error&gt; recognizeSimpleUnsignedInteger(StringView stringView)</span>
 311 {
 312     unsigned result = 0;
 313     if (stringView.length() &lt; 1)
<span class="line-modified"> 314         return Unexpected&lt;Parser::Error&gt;(Parser::Error(makeString(&quot;Simple unsigned literal &quot;, stringView, &quot; is too short&quot;)));</span>
 315     for (auto codePoint : stringView.codePoints()) {
 316         if (codePoint &lt; &#39;0&#39; || codePoint &gt; &#39;9&#39;)
<span class="line-modified"> 317             return Unexpected&lt;Parser::Error&gt;(Parser::Error(makeString(&quot;Simple unsigned literal &quot;, stringView, &quot; isn&#39;t of the form [0-9]+&quot;)));</span>
 318         auto previous = result;
 319         result = result * 10 + (codePoint - &#39;0&#39;);
 320         if (result &lt; previous)
<span class="line-modified"> 321             return Unexpected&lt;Parser::Error&gt;(Parser::Error(makeString(&quot;Simple unsigned literal &quot;, stringView, &quot; is out of bounds&quot;)));</span>
 322     }
 323     return result;
 324 }
 325 
 326 auto Parser::parseConstantExpression() -&gt; Expected&lt;AST::ConstantExpression, Error&gt;
 327 {
<span class="line-modified"> 328     auto type = consumeTypes({</span>
<span class="line-modified"> 329         Lexer::Token::Type::IntLiteral,</span>
<span class="line-modified"> 330         Lexer::Token::Type::UintLiteral,</span>
<span class="line-modified"> 331         Lexer::Token::Type::FloatLiteral,</span>
<span class="line-modified"> 332         Lexer::Token::Type::Null,</span>
<span class="line-modified"> 333         Lexer::Token::Type::True,</span>
<span class="line-modified"> 334         Lexer::Token::Type::False,</span>
<span class="line-modified"> 335         Lexer::Token::Type::Identifier,</span>
<span class="line-removed"> 336     });</span>
 337     if (!type)
<span class="line-modified"> 338         return Unexpected&lt;Error&gt;(type.error());</span>
 339 
 340     switch (type-&gt;type) {
<span class="line-modified"> 341     case Lexer::Token::Type::IntLiteral: {</span>
<span class="line-modified"> 342         auto value = intLiteralToInt(type-&gt;stringView);</span>
 343         if (!value)
<span class="line-modified"> 344             return Unexpected&lt;Error&gt;(value.error());</span>
<span class="line-modified"> 345         return {{ AST::IntegerLiteral(WTFMove(*type), *value) }};</span>
 346     }
<span class="line-modified"> 347     case Lexer::Token::Type::UintLiteral: {</span>
<span class="line-modified"> 348         auto value = uintLiteralToUint(type-&gt;stringView);</span>
 349         if (!value)
<span class="line-modified"> 350             return Unexpected&lt;Error&gt;(value.error());</span>
<span class="line-modified"> 351         return {{ AST::UnsignedIntegerLiteral(WTFMove(*type), *value) }};</span>
 352     }
<span class="line-modified"> 353     case Lexer::Token::Type::FloatLiteral: {</span>
<span class="line-modified"> 354         auto value = floatLiteralToFloat(type-&gt;stringView);</span>
 355         if (!value)
<span class="line-modified"> 356             return Unexpected&lt;Error&gt;(value.error());</span>
<span class="line-modified"> 357         return {{ AST::FloatLiteral(WTFMove(*type), *value) }};</span>
 358     }
<span class="line-modified"> 359     case Lexer::Token::Type::Null:</span>
 360         return { AST::NullLiteral(WTFMove(*type)) };
<span class="line-modified"> 361     case Lexer::Token::Type::True:</span>
 362         return { AST::BooleanLiteral(WTFMove(*type), true) };
<span class="line-modified"> 363     case Lexer::Token::Type::False:</span>
 364         return { AST::BooleanLiteral(WTFMove(*type), false) };
 365     default: {
<span class="line-modified"> 366         ASSERT(type-&gt;type == Lexer::Token::Type::Identifier);</span>
<span class="line-modified"> 367         auto origin = consumeType(Lexer::Token::Type::FullStop);</span>
<span class="line-modified"> 368         if (!origin)</span>
<span class="line-modified"> 369             return Unexpected&lt;Error&gt;(origin.error());</span>
<span class="line-removed"> 370         auto next = consumeType(Lexer::Token::Type::Identifier);</span>
<span class="line-removed"> 371         if (!next)</span>
<span class="line-removed"> 372             return Unexpected&lt;Error&gt;(next.error());</span>
<span class="line-removed"> 373         return { AST::EnumerationMemberLiteral(WTFMove(*origin), type-&gt;stringView.toString(), next-&gt;stringView.toString()) };</span>
 374     }
 375     }
 376 }
 377 
 378 auto Parser::parseTypeArgument() -&gt; Expected&lt;AST::TypeArgument, Error&gt;
 379 {
<span class="line-modified"> 380     auto constantExpression = backtrackingScope&lt;Expected&lt;AST::ConstantExpression, Error&gt;&gt;([&amp;]() {</span>
<span class="line-modified"> 381         return parseConstantExpression();</span>
<span class="line-modified"> 382     });</span>
<span class="line-modified"> 383     if (constantExpression)</span>
 384         return AST::TypeArgument(WTFMove(*constantExpression));
<span class="line-modified"> 385     auto result = consumeType(Lexer::Token::Type::Identifier);</span>
<span class="line-modified"> 386     if (!result)</span>
<span class="line-modified"> 387         return Unexpected&lt;Error&gt;(result.error());</span>
<span class="line-modified"> 388     return AST::TypeArgument(makeUniqueRef&lt;AST::TypeReference&gt;(Lexer::Token(*result), result-&gt;stringView.toString(), AST::TypeArguments()));</span>
 389 }
 390 
 391 auto Parser::parseTypeArguments() -&gt; Expected&lt;AST::TypeArguments, Error&gt;
 392 {
<span class="line-modified"> 393     auto typeArguments = backtrackingScope&lt;Optional&lt;AST::TypeArguments&gt;&gt;([&amp;]() -&gt; Optional&lt;AST::TypeArguments&gt; {</span>
<span class="line-modified"> 394         auto lessThanSign = consumeType(Lexer::Token::Type::LessThanSign);</span>
<span class="line-modified"> 395         if (!lessThanSign)</span>
<span class="line-removed"> 396             return WTF::nullopt;</span>
<span class="line-removed"> 397         AST::TypeArguments typeArguments;</span>
<span class="line-removed"> 398         auto typeArgument = parseTypeArgument();</span>
<span class="line-removed"> 399         if (!typeArgument)</span>
<span class="line-removed"> 400             return WTF::nullopt;</span>
<span class="line-removed"> 401         typeArguments.append(WTFMove(*typeArgument));</span>
<span class="line-removed"> 402         while (tryType(Lexer::Token::Type::Comma)) {</span>
<span class="line-removed"> 403             auto typeArgument = parseTypeArgument();</span>
<span class="line-removed"> 404             if (!typeArgument)</span>
<span class="line-removed"> 405                 return WTF::nullopt;</span>
<span class="line-removed"> 406             typeArguments.append(WTFMove(*typeArgument));</span>
<span class="line-removed"> 407         }</span>
<span class="line-removed"> 408         auto greaterThanSign = consumeType(Lexer::Token::Type::GreaterThanSign);</span>
<span class="line-removed"> 409         if (!greaterThanSign)</span>
<span class="line-removed"> 410             return WTF::nullopt;</span>
 411         return typeArguments;
<span class="line-removed"> 412     });</span>
<span class="line-removed"> 413     if (typeArguments)</span>
<span class="line-removed"> 414         return WTFMove(*typeArguments);</span>
 415 
<span class="line-modified"> 416     typeArguments = backtrackingScope&lt;Optional&lt;AST::TypeArguments&gt;&gt;([&amp;]() -&gt; Optional&lt;AST::TypeArguments&gt; {</span>
<span class="line-modified"> 417         auto lessThanSign = consumeType(Lexer::Token::Type::LessThanSign);</span>
<span class="line-modified"> 418         if (!lessThanSign)</span>
<span class="line-modified"> 419             return WTF::nullopt;</span>
<span class="line-modified"> 420         auto greaterThanSign = consumeType(Lexer::Token::Type::GreaterThanSign);</span>
<span class="line-modified"> 421         if (!greaterThanSign)</span>
<span class="line-modified"> 422             return WTF::nullopt;</span>
<span class="line-modified"> 423         return {{ }};</span>
<span class="line-modified"> 424     });</span>
<span class="line-modified"> 425     if (typeArguments)</span>
<span class="line-modified"> 426         return WTFMove(*typeArguments);</span>





 427 
<span class="line-modified"> 428     return AST::TypeArguments();</span>
 429 }
 430 
 431 auto Parser::parseTypeSuffixAbbreviated() -&gt; Expected&lt;TypeSuffixAbbreviated, Error&gt;
 432 {
<span class="line-modified"> 433     auto token = consumeTypes({ Lexer::Token::Type::Star, Lexer::Token::Type::SquareBracketPair, Lexer::Token::Type::LeftSquareBracket });</span>



 434     if (!token)
<span class="line-modified"> 435         return Unexpected&lt;Error&gt;(token.error());</span>
<span class="line-modified"> 436     if (token-&gt;type == Lexer::Token::Type::LeftSquareBracket) {</span>
 437         auto numElements = consumeNonNegativeIntegralLiteral();
 438         if (!numElements)
<span class="line-modified"> 439             return Unexpected&lt;Error&gt;(numElements.error());</span>
<span class="line-modified"> 440         auto rightSquareBracket = consumeType(Lexer::Token::Type::RightSquareBracket);</span>
<span class="line-modified"> 441         if (!rightSquareBracket)</span>
<span class="line-removed"> 442             return Unexpected&lt;Error&gt;(rightSquareBracket.error());</span>
<span class="line-removed"> 443         return {{ *token, *numElements }};</span>
 444     }
<span class="line-modified"> 445     return {{ *token, WTF::nullopt }};</span>
 446 }
 447 
 448 auto Parser::parseTypeSuffixNonAbbreviated() -&gt; Expected&lt;TypeSuffixNonAbbreviated, Error&gt;
 449 {
<span class="line-modified"> 450     auto token = consumeTypes({ Lexer::Token::Type::Star, Lexer::Token::Type::SquareBracketPair, Lexer::Token::Type::LeftSquareBracket });</span>



 451     if (!token)
<span class="line-modified"> 452         return Unexpected&lt;Error&gt;(token.error());</span>
<span class="line-modified"> 453     if (token-&gt;type == Lexer::Token::Type::LeftSquareBracket) {</span>
 454         auto numElements = consumeNonNegativeIntegralLiteral();
 455         if (!numElements)
<span class="line-modified"> 456             return Unexpected&lt;Error&gt;(numElements.error());</span>
<span class="line-modified"> 457         auto rightSquareBracket = consumeType(Lexer::Token::Type::RightSquareBracket);</span>
<span class="line-modified"> 458         if (!rightSquareBracket)</span>
<span class="line-modified"> 459             return Unexpected&lt;Error&gt;(rightSquareBracket.error());</span>
<span class="line-modified"> 460         return {{ *token, WTF::nullopt, *numElements }};</span>
<span class="line-modified"> 461     }</span>
<span class="line-modified"> 462     auto addressSpaceToken = consumeTypes({ Lexer::Token::Type::Constant, Lexer::Token::Type::Device, Lexer::Token::Type::Threadgroup, Lexer::Token::Type::Thread});</span>


 463     if (!addressSpaceToken)
<span class="line-modified"> 464         return Unexpected&lt;Error&gt;(addressSpaceToken.error());</span>
 465     AST::AddressSpace addressSpace;
 466     switch (addressSpaceToken-&gt;type) {
<span class="line-modified"> 467     case Lexer::Token::Type::Constant:</span>
 468         addressSpace = AST::AddressSpace::Constant;
 469         break;
<span class="line-modified"> 470     case Lexer::Token::Type::Device:</span>
 471         addressSpace = AST::AddressSpace::Device;
 472         break;
<span class="line-modified"> 473     case Lexer::Token::Type::Threadgroup:</span>
 474         addressSpace = AST::AddressSpace::Threadgroup;
 475         break;
 476     default:
<span class="line-modified"> 477         ASSERT(addressSpaceToken-&gt;type == Lexer::Token::Type::Thread);</span>
 478         addressSpace = AST::AddressSpace::Thread;
 479         break;
 480     }
<span class="line-modified"> 481     return {{ *token, { addressSpace }, WTF::nullopt }};</span>
 482 }
 483 
<span class="line-modified"> 484 auto Parser::parseAddressSpaceType() -&gt; Expected&lt;UniqueRef&lt;AST::UnnamedType&gt;, Error&gt;</span>
 485 {
<span class="line-modified"> 486     auto addressSpaceToken = consumeTypes({ Lexer::Token::Type::Constant, Lexer::Token::Type::Device, Lexer::Token::Type::Threadgroup, Lexer::Token::Type::Thread});</span>
<span class="line-modified"> 487     if (!addressSpaceToken)</span>
<span class="line-modified"> 488         return Unexpected&lt;Error&gt;(addressSpaceToken.error());</span>
<span class="line-modified"> 489     AST::AddressSpace addressSpace;</span>
<span class="line-modified"> 490     switch (addressSpaceToken-&gt;type) {</span>
<span class="line-removed"> 491     case Lexer::Token::Type::Constant:</span>
<span class="line-removed"> 492         addressSpace = AST::AddressSpace::Constant;</span>
<span class="line-removed"> 493         break;</span>
<span class="line-removed"> 494     case Lexer::Token::Type::Device:</span>
<span class="line-removed"> 495         addressSpace = AST::AddressSpace::Device;</span>
<span class="line-removed"> 496         break;</span>
<span class="line-removed"> 497     case Lexer::Token::Type::Threadgroup:</span>
<span class="line-removed"> 498         addressSpace = AST::AddressSpace::Threadgroup;</span>
<span class="line-removed"> 499         break;</span>
<span class="line-removed"> 500     default:</span>
<span class="line-removed"> 501         ASSERT(addressSpaceToken-&gt;type == Lexer::Token::Type::Thread);</span>
<span class="line-removed"> 502         addressSpace = AST::AddressSpace::Thread;</span>
<span class="line-removed"> 503         break;</span>
<span class="line-removed"> 504     }</span>
<span class="line-removed"> 505     auto name = consumeType(Lexer::Token::Type::Identifier);</span>
<span class="line-removed"> 506     if (!name)</span>
<span class="line-removed"> 507         return Unexpected&lt;Error&gt;(name.error());</span>
<span class="line-removed"> 508     auto typeArguments = parseTypeArguments();</span>
<span class="line-removed"> 509     if (!typeArguments)</span>
<span class="line-removed"> 510         return Unexpected&lt;Error&gt;(typeArguments.error());</span>
<span class="line-removed"> 511 </span>
<span class="line-removed"> 512     auto constructTypeFromSuffixAbbreviated = [&amp;](const TypeSuffixAbbreviated&amp; typeSuffixAbbreviated, UniqueRef&lt;AST::UnnamedType&gt;&amp;&amp; previous) -&gt; UniqueRef&lt;AST::UnnamedType&gt; {</span>
<span class="line-removed"> 513         switch (typeSuffixAbbreviated.token.type) {</span>
<span class="line-removed"> 514         case Lexer::Token::Type::Star:</span>
<span class="line-removed"> 515             return { makeUniqueRef&lt;AST::PointerType&gt;(Lexer::Token(typeSuffixAbbreviated.token), addressSpace, WTFMove(previous)) };</span>
<span class="line-removed"> 516         case Lexer::Token::Type::SquareBracketPair:</span>
<span class="line-removed"> 517             return { makeUniqueRef&lt;AST::ArrayReferenceType&gt;(Lexer::Token(typeSuffixAbbreviated.token), addressSpace, WTFMove(previous)) };</span>
<span class="line-removed"> 518         default:</span>
<span class="line-removed"> 519             ASSERT(typeSuffixAbbreviated.token.type == Lexer::Token::Type::LeftSquareBracket);</span>
<span class="line-removed"> 520             return { makeUniqueRef&lt;AST::ArrayType&gt;(Lexer::Token(typeSuffixAbbreviated.token), WTFMove(previous), *typeSuffixAbbreviated.numElements) };</span>
<span class="line-removed"> 521         }</span>
<span class="line-removed"> 522     };</span>
 523 
<span class="line-modified"> 524     auto firstTypeSuffixAbbreviated = parseTypeSuffixAbbreviated();</span>
<span class="line-modified"> 525     if (!firstTypeSuffixAbbreviated)</span>
<span class="line-modified"> 526         return Unexpected&lt;Error&gt;(firstTypeSuffixAbbreviated.error());</span>
<span class="line-modified"> 527     UniqueRef&lt;AST::UnnamedType&gt; result = makeUniqueRef&lt;AST::TypeReference&gt;(WTFMove(*addressSpaceToken), name-&gt;stringView.toString(), WTFMove(*typeArguments));</span>
<span class="line-modified"> 528     auto next = constructTypeFromSuffixAbbreviated(*firstTypeSuffixAbbreviated, WTFMove(result));</span>
<span class="line-modified"> 529     result = WTFMove(next);</span>
<span class="line-modified"> 530     while (true) {</span>
<span class="line-modified"> 531         auto typeSuffixAbbreviated = backtrackingScope&lt;Expected&lt;TypeSuffixAbbreviated, Error&gt;&gt;([&amp;]() {</span>
<span class="line-removed"> 532             return parseTypeSuffixAbbreviated();</span>
<span class="line-removed"> 533         });</span>
<span class="line-removed"> 534         if (!typeSuffixAbbreviated)</span>
 535             break;
<span class="line-modified"> 536         // FIXME: The nesting here might be in the wrong order.</span>
<span class="line-modified"> 537         next = constructTypeFromSuffixAbbreviated(*typeSuffixAbbreviated, WTFMove(result));</span>
























 538         result = WTFMove(next);













 539     }
 540 
<span class="line-modified"> 541     return WTFMove(result);</span>
<span class="line-modified"> 542 }</span>
<span class="line-removed"> 543 </span>
<span class="line-removed"> 544 auto Parser::parseNonAddressSpaceType() -&gt; Expected&lt;UniqueRef&lt;AST::UnnamedType&gt;, Error&gt;</span>
<span class="line-removed"> 545 {</span>
<span class="line-removed"> 546     auto origin = peek();</span>
<span class="line-removed"> 547     if (!origin)</span>
<span class="line-removed"> 548         return Unexpected&lt;Error&gt;(origin.error());</span>
<span class="line-removed"> 549     auto name = consumeType(Lexer::Token::Type::Identifier);</span>
<span class="line-removed"> 550     if (!name)</span>
<span class="line-removed"> 551         return Unexpected&lt;Error&gt;(name.error());</span>
<span class="line-removed"> 552     auto typeArguments = parseTypeArguments();</span>
<span class="line-removed"> 553     if (!typeArguments)</span>
<span class="line-removed"> 554         return Unexpected&lt;Error&gt;(typeArguments.error());</span>
<span class="line-removed"> 555 </span>
<span class="line-removed"> 556     auto constructTypeFromSuffixNonAbbreviated = [&amp;](const TypeSuffixNonAbbreviated&amp; typeSuffixNonAbbreviated, UniqueRef&lt;AST::UnnamedType&gt;&amp;&amp; previous) -&gt; UniqueRef&lt;AST::UnnamedType&gt; {</span>
 557         switch (typeSuffixNonAbbreviated.token.type) {
<span class="line-modified"> 558         case Lexer::Token::Type::Star:</span>
<span class="line-modified"> 559             return { makeUniqueRef&lt;AST::PointerType&gt;(Lexer::Token(typeSuffixNonAbbreviated.token), *typeSuffixNonAbbreviated.addressSpace, WTFMove(previous)) };</span>
<span class="line-modified"> 560         case Lexer::Token::Type::SquareBracketPair:</span>
<span class="line-modified"> 561             return { makeUniqueRef&lt;AST::ArrayReferenceType&gt;(Lexer::Token(typeSuffixNonAbbreviated.token), *typeSuffixNonAbbreviated.addressSpace, WTFMove(previous)) };</span>
 562         default:
<span class="line-modified"> 563             ASSERT(typeSuffixNonAbbreviated.token.type == Lexer::Token::Type::LeftSquareBracket);</span>
<span class="line-modified"> 564             return { makeUniqueRef&lt;AST::ArrayType&gt;(Lexer::Token(typeSuffixNonAbbreviated.token), WTFMove(previous), *typeSuffixNonAbbreviated.numElements) };</span>
 565         }
 566     };
<span class="line-modified"> 567 </span>
<span class="line-removed"> 568     UniqueRef&lt;AST::UnnamedType&gt; result = makeUniqueRef&lt;AST::TypeReference&gt;(WTFMove(*origin), name-&gt;stringView.toString(), WTFMove(*typeArguments));</span>
 569     while (true) {
<span class="line-modified"> 570         auto typeSuffixNonAbbreviated = backtrackingScope&lt;Expected&lt;TypeSuffixNonAbbreviated, Error&gt;&gt;([&amp;]() {</span>
<span class="line-modified"> 571             return parseTypeSuffixNonAbbreviated();</span>
<span class="line-modified"> 572         });</span>
<span class="line-modified"> 573         if (!typeSuffixNonAbbreviated)</span>
 574             break;


 575         // FIXME: The nesting here might be in the wrong order.
 576         auto next = constructTypeFromSuffixNonAbbreviated(*typeSuffixNonAbbreviated, WTFMove(result));
 577         result = WTFMove(next);
 578     }
<span class="line-removed"> 579 </span>
 580     return WTFMove(result);
 581 }
 582 
<span class="line-removed"> 583 auto Parser::parseType() -&gt; Expected&lt;UniqueRef&lt;AST::UnnamedType&gt;, Error&gt;</span>
<span class="line-removed"> 584 {</span>
<span class="line-removed"> 585     auto type = backtrackingScope&lt;Expected&lt;UniqueRef&lt;AST::UnnamedType&gt;, Error&gt;&gt;([&amp;]() {</span>
<span class="line-removed"> 586         return parseAddressSpaceType();</span>
<span class="line-removed"> 587     });</span>
<span class="line-removed"> 588     if (type)</span>
<span class="line-removed"> 589         return type;</span>
<span class="line-removed"> 590 </span>
<span class="line-removed"> 591     type = backtrackingScope&lt;Expected&lt;UniqueRef&lt;AST::UnnamedType&gt;, Error&gt;&gt;([&amp;]() {</span>
<span class="line-removed"> 592         return parseNonAddressSpaceType();</span>
<span class="line-removed"> 593     });</span>
<span class="line-removed"> 594     if (type)</span>
<span class="line-removed"> 595         return type;</span>
<span class="line-removed"> 596 </span>
<span class="line-removed"> 597     return Unexpected&lt;Error&gt;(type.error());</span>
<span class="line-removed"> 598 }</span>
<span class="line-removed"> 599 </span>
 600 auto Parser::parseTypeDefinition() -&gt; Expected&lt;AST::TypeDefinition, Error&gt;
 601 {
<span class="line-modified"> 602     auto origin = consumeType(Lexer::Token::Type::Typedef);</span>
<span class="line-modified"> 603     if (!origin)</span>
<span class="line-modified"> 604         return Unexpected&lt;Error&gt;(origin.error());</span>
<span class="line-modified"> 605     auto name = consumeType(Lexer::Token::Type::Identifier);</span>
<span class="line-modified"> 606     if (!name)</span>
<span class="line-modified"> 607         return Unexpected&lt;Error&gt;(name.error());</span>
<span class="line-removed"> 608     auto equals = consumeType(Lexer::Token::Type::EqualsSign);</span>
<span class="line-removed"> 609     if (!equals)</span>
<span class="line-removed"> 610         return Unexpected&lt;Error&gt;(equals.error());</span>
<span class="line-removed"> 611     auto type = parseType();</span>
<span class="line-removed"> 612     if (!type)</span>
<span class="line-removed"> 613         return Unexpected&lt;Error&gt;(type.error());</span>
<span class="line-removed"> 614     auto semicolon = consumeType(Lexer::Token::Type::Semicolon);</span>
<span class="line-removed"> 615     if (!semicolon)</span>
<span class="line-removed"> 616         return Unexpected&lt;Error&gt;(semicolon.error());</span>
<span class="line-removed"> 617     return AST::TypeDefinition(WTFMove(*origin), name-&gt;stringView.toString(), WTFMove(*type));</span>
 618 }
 619 
 620 auto Parser::parseBuiltInSemantic() -&gt; Expected&lt;AST::BuiltInSemantic, Error&gt;
 621 {
<span class="line-modified"> 622     auto origin = consumeTypes({</span>
<span class="line-modified"> 623         Lexer::Token::Type::SVInstanceID,</span>
<span class="line-modified"> 624         Lexer::Token::Type::SVVertexID,</span>
<span class="line-modified"> 625         Lexer::Token::Type::PSize,</span>
<span class="line-modified"> 626         Lexer::Token::Type::SVPosition,</span>
<span class="line-modified"> 627         Lexer::Token::Type::SVIsFrontFace,</span>
<span class="line-modified"> 628         Lexer::Token::Type::SVSampleIndex,</span>
<span class="line-modified"> 629         Lexer::Token::Type::SVInnerCoverage,</span>
<span class="line-modified"> 630         Lexer::Token::Type::SVTarget,</span>
<span class="line-modified"> 631         Lexer::Token::Type::SVDepth,</span>
<span class="line-modified"> 632         Lexer::Token::Type::SVCoverage,</span>
<span class="line-modified"> 633         Lexer::Token::Type::SVDispatchThreadID,</span>
<span class="line-modified"> 634         Lexer::Token::Type::SVGroupID,</span>
<span class="line-modified"> 635         Lexer::Token::Type::SVGroupIndex,</span>
<span class="line-modified"> 636         Lexer::Token::Type::SVGroupThreadID});</span>
 637     if (!origin)
<span class="line-modified"> 638         return Unexpected&lt;Error&gt;(origin.error());</span>
 639 
 640     switch (origin-&gt;type) {
<span class="line-modified"> 641     case Lexer::Token::Type::SVInstanceID:</span>
<span class="line-modified"> 642         return AST::BuiltInSemantic(WTFMove(*origin), AST::BuiltInSemantic::Variable::SVInstanceID);</span>
<span class="line-modified"> 643     case Lexer::Token::Type::SVVertexID:</span>
<span class="line-modified"> 644         return AST::BuiltInSemantic(WTFMove(*origin), AST::BuiltInSemantic::Variable::SVVertexID);</span>
<span class="line-modified"> 645     case Lexer::Token::Type::PSize:</span>
<span class="line-modified"> 646         return AST::BuiltInSemantic(WTFMove(*origin), AST::BuiltInSemantic::Variable::PSize);</span>
<span class="line-modified"> 647     case Lexer::Token::Type::SVPosition:</span>
<span class="line-modified"> 648         return AST::BuiltInSemantic(WTFMove(*origin), AST::BuiltInSemantic::Variable::SVPosition);</span>
<span class="line-modified"> 649     case Lexer::Token::Type::SVIsFrontFace:</span>
<span class="line-modified"> 650         return AST::BuiltInSemantic(WTFMove(*origin), AST::BuiltInSemantic::Variable::SVIsFrontFace);</span>
<span class="line-modified"> 651     case Lexer::Token::Type::SVSampleIndex:</span>
<span class="line-modified"> 652         return AST::BuiltInSemantic(WTFMove(*origin), AST::BuiltInSemantic::Variable::SVSampleIndex);</span>
<span class="line-modified"> 653     case Lexer::Token::Type::SVInnerCoverage:</span>
<span class="line-modified"> 654         return AST::BuiltInSemantic(WTFMove(*origin), AST::BuiltInSemantic::Variable::SVInnerCoverage);</span>
<span class="line-modified"> 655     case Lexer::Token::Type::SVTarget: {</span>
<span class="line-modified"> 656         auto target = consumeNonNegativeIntegralLiteral();</span>
 657         if (!target)
<span class="line-modified"> 658             return Unexpected&lt;Error&gt;(target.error());</span>
<span class="line-modified"> 659         return AST::BuiltInSemantic(WTFMove(*origin), AST::BuiltInSemantic::Variable::SVTarget, *target);</span>
<span class="line-modified"> 660     }</span>
<span class="line-modified"> 661     case Lexer::Token::Type::SVDepth:</span>
<span class="line-modified"> 662         return AST::BuiltInSemantic(WTFMove(*origin), AST::BuiltInSemantic::Variable::SVDepth);</span>
<span class="line-modified"> 663     case Lexer::Token::Type::SVCoverage:</span>
<span class="line-modified"> 664         return AST::BuiltInSemantic(WTFMove(*origin), AST::BuiltInSemantic::Variable::SVCoverage);</span>
<span class="line-modified"> 665     case Lexer::Token::Type::SVDispatchThreadID:</span>
<span class="line-modified"> 666         return AST::BuiltInSemantic(WTFMove(*origin), AST::BuiltInSemantic::Variable::SVDispatchThreadID);</span>
<span class="line-modified"> 667     case Lexer::Token::Type::SVGroupID:</span>
<span class="line-modified"> 668         return AST::BuiltInSemantic(WTFMove(*origin), AST::BuiltInSemantic::Variable::SVGroupID);</span>
<span class="line-modified"> 669     case Lexer::Token::Type::SVGroupIndex:</span>
<span class="line-modified"> 670         return AST::BuiltInSemantic(WTFMove(*origin), AST::BuiltInSemantic::Variable::SVGroupIndex);</span>
 671     default:
<span class="line-modified"> 672         ASSERT(origin-&gt;type == Lexer::Token::Type::SVGroupThreadID);</span>
<span class="line-modified"> 673         return AST::BuiltInSemantic(WTFMove(*origin), AST::BuiltInSemantic::Variable::SVGroupThreadID);</span>
 674     }
 675 }
 676 
 677 auto Parser::parseResourceSemantic() -&gt; Expected&lt;AST::ResourceSemantic, Error&gt;
 678 {
<span class="line-modified"> 679     auto origin = consumeType(Lexer::Token::Type::Register);</span>
<span class="line-modified"> 680     if (!origin)</span>
<span class="line-removed"> 681         return Unexpected&lt;Error&gt;(origin.error());</span>
 682 
<span class="line-modified"> 683     auto leftParenthesis = consumeType(Lexer::Token::Type::LeftParenthesis);</span>
<span class="line-modified"> 684     if (!leftParenthesis)</span>
<span class="line-modified"> 685         return Unexpected&lt;Error&gt;(leftParenthesis.error());</span>
<span class="line-modified"> 686 </span>
<span class="line-modified"> 687     auto info = consumeType(Lexer::Token::Type::Identifier);</span>
<span class="line-modified"> 688     if (!info)</span>
<span class="line-modified"> 689         return Unexpected&lt;Error&gt;(info.error());</span>
<span class="line-removed"> 690     if (info-&gt;stringView.length() &lt; 2 || (info-&gt;stringView[0] != &#39;u&#39;</span>
<span class="line-removed"> 691         &amp;&amp; info-&gt;stringView[0] != &#39;t&#39;</span>
<span class="line-removed"> 692         &amp;&amp; info-&gt;stringView[0] != &#39;b&#39;</span>
<span class="line-removed"> 693         &amp;&amp; info-&gt;stringView[0] != &#39;s&#39;))</span>
<span class="line-removed"> 694         return Unexpected&lt;Error&gt;(Error(makeString(info-&gt;stringView.substring(0, 1), &quot; is not a known resource type (&#39;u&#39;, &#39;t&#39;, &#39;b&#39;, or &#39;s&#39;)&quot;)));</span>
 695 
 696     AST::ResourceSemantic::Mode mode;
<span class="line-modified"> 697     switch (info-&gt;stringView[0]) {</span>
 698     case &#39;u&#39;:
 699         mode = AST::ResourceSemantic::Mode::UnorderedAccessView;
 700         break;
 701     case &#39;t&#39;:
 702         mode = AST::ResourceSemantic::Mode::Texture;
 703         break;
 704     case &#39;b&#39;:
 705         mode = AST::ResourceSemantic::Mode::Buffer;
 706         break;
 707     case &#39;s&#39;:
 708         mode = AST::ResourceSemantic::Mode::Sampler;
 709         break;
 710     }
 711 
<span class="line-modified"> 712     auto index = recognizeSimpleUnsignedInteger(info-&gt;stringView.substring(1));</span>
 713     if (!index)
<span class="line-modified"> 714         return Unexpected&lt;Error&gt;(index.error());</span>
 715 
 716     unsigned space = 0;
<span class="line-modified"> 717     if (tryType(Lexer::Token::Type::Comma)) {</span>
<span class="line-modified"> 718         auto spaceToken = consumeType(Lexer::Token::Type::Identifier);</span>
<span class="line-modified"> 719         if (!spaceToken)</span>
<span class="line-modified"> 720             return Unexpected&lt;Error&gt;(spaceToken.error());</span>
<span class="line-modified"> 721         auto prefix = &quot;space&quot;_str;</span>
<span class="line-modified"> 722         if (!spaceToken-&gt;stringView.startsWith(StringView(prefix)))</span>
<span class="line-modified"> 723             return Unexpected&lt;Error&gt;(Error(makeString(&quot;Second argument to resource semantic &quot;, spaceToken-&gt;stringView, &quot; needs be of the form &#39;space0&#39;&quot;)));</span>
<span class="line-modified"> 724         if (spaceToken-&gt;stringView.length() &lt;= prefix.length())</span>
<span class="line-modified"> 725             return Unexpected&lt;Error&gt;(Error(makeString(&quot;Second argument to resource semantic &quot;, spaceToken-&gt;stringView, &quot; needs be of the form &#39;space0&#39;&quot;)));</span>
<span class="line-removed"> 726         auto spaceValue = recognizeSimpleUnsignedInteger(spaceToken-&gt;stringView.substring(prefix.length()));</span>
 727         if (!spaceValue)
<span class="line-modified"> 728             return Unexpected&lt;Error&gt;(spaceValue.error());</span>
 729         space = *spaceValue;
 730     }
 731 
<span class="line-modified"> 732     auto rightParenthesis = consumeType(Lexer::Token::Type::RightParenthesis);</span>
<span class="line-removed"> 733     if (!rightParenthesis)</span>
<span class="line-removed"> 734         return Unexpected&lt;Error&gt;(rightParenthesis.error());</span>
 735 
<span class="line-modified"> 736     return AST::ResourceSemantic(WTFMove(*origin), mode, *index, space);</span>
 737 }
 738 
 739 auto Parser::parseSpecializationConstantSemantic() -&gt; Expected&lt;AST::SpecializationConstantSemantic, Error&gt;
 740 {
<span class="line-modified"> 741     auto origin = consumeType(Lexer::Token::Type::Specialized);</span>
<span class="line-modified"> 742     if (!origin)</span>
<span class="line-removed"> 743         return Unexpected&lt;Error&gt;(origin.error());</span>
<span class="line-removed"> 744     return AST::SpecializationConstantSemantic(WTFMove(*origin));</span>
 745 }
 746 
 747 auto Parser::parseStageInOutSemantic() -&gt; Expected&lt;AST::StageInOutSemantic, Error&gt;
 748 {
<span class="line-modified"> 749     auto origin = consumeType(Lexer::Token::Type::Attribute);</span>
<span class="line-modified"> 750     if (!origin)</span>
<span class="line-removed"> 751         return Unexpected&lt;Error&gt;(origin.error());</span>
<span class="line-removed"> 752 </span>
<span class="line-removed"> 753     auto leftParenthesis = consumeType(Lexer::Token::Type::LeftParenthesis);</span>
<span class="line-removed"> 754     if (!leftParenthesis)</span>
<span class="line-removed"> 755         return Unexpected&lt;Error&gt;(leftParenthesis.error());</span>
 756 
 757     auto index = consumeNonNegativeIntegralLiteral();
 758     if (!index)
<span class="line-modified"> 759         return Unexpected&lt;Error&gt;(index.error());</span>
 760 
<span class="line-modified"> 761     auto rightParenthesis = consumeType(Lexer::Token::Type::RightParenthesis);</span>
<span class="line-removed"> 762     if (!rightParenthesis)</span>
<span class="line-removed"> 763         return Unexpected&lt;Error&gt;(rightParenthesis.error());</span>
 764 
<span class="line-modified"> 765     return AST::StageInOutSemantic(WTFMove(*origin), *index);</span>
 766 }
 767 
<span class="line-modified"> 768 auto Parser::parseSemantic() -&gt; Expected&lt;AST::Semantic, Error&gt;</span>
 769 {
<span class="line-modified"> 770     auto builtInSemantic = backtrackingScope&lt;Expected&lt;AST::BuiltInSemantic, Error&gt;&gt;([&amp;]() {</span>
<span class="line-modified"> 771         return parseBuiltInSemantic();</span>
<span class="line-removed"> 772     });</span>
<span class="line-removed"> 773     if (builtInSemantic)</span>
<span class="line-removed"> 774         return AST::Semantic(WTFMove(*builtInSemantic));</span>
<span class="line-removed"> 775 </span>
<span class="line-removed"> 776     auto resourceSemantic = backtrackingScope&lt;Expected&lt;AST::ResourceSemantic, Error&gt;&gt;([&amp;]() {</span>
<span class="line-removed"> 777         return parseResourceSemantic();</span>
<span class="line-removed"> 778     });</span>
<span class="line-removed"> 779     if (resourceSemantic)</span>
<span class="line-removed"> 780         return AST::Semantic(WTFMove(*resourceSemantic));</span>
<span class="line-removed"> 781 </span>
<span class="line-removed"> 782     auto specializationConstantSemantic = backtrackingScope&lt;Expected&lt;AST::SpecializationConstantSemantic, Error&gt;&gt;([&amp;]() {</span>
<span class="line-removed"> 783         return parseSpecializationConstantSemantic();</span>
<span class="line-removed"> 784     });</span>
<span class="line-removed"> 785     if (specializationConstantSemantic)</span>
<span class="line-removed"> 786         return AST::Semantic(WTFMove(*specializationConstantSemantic));</span>
<span class="line-removed"> 787 </span>
<span class="line-removed"> 788     auto stageInOutSemantic = backtrackingScope&lt;Expected&lt;AST::StageInOutSemantic, Error&gt;&gt;([&amp;]() {</span>
<span class="line-removed"> 789         return parseStageInOutSemantic();</span>
<span class="line-removed"> 790     });</span>
<span class="line-removed"> 791     if (stageInOutSemantic)</span>
<span class="line-removed"> 792         return AST::Semantic(WTFMove(*stageInOutSemantic));</span>
 793 
<span class="line-modified"> 794     return Unexpected&lt;Error&gt;(stageInOutSemantic.error());</span>


















 795 }
 796 AST::Qualifiers Parser::parseQualifiers()
 797 {
 798     AST::Qualifiers qualifiers;
<span class="line-modified"> 799     while (true) {</span>
<span class="line-modified"> 800         if (auto next = tryType(Lexer::Token::Type::Qualifier)) {</span>
<span class="line-modified"> 801             if (&quot;nointerpolation&quot; == next-&gt;stringView)</span>
<span class="line-modified"> 802                 qualifiers.append(AST::Qualifier::Nointerpolation);</span>
<span class="line-modified"> 803             else if (&quot;noperspective&quot; == next-&gt;stringView)</span>
<span class="line-modified"> 804                 qualifiers.append(AST::Qualifier::Noperspective);</span>
<span class="line-modified"> 805             else if (&quot;uniform&quot; == next-&gt;stringView)</span>
<span class="line-modified"> 806                 qualifiers.append(AST::Qualifier::Uniform);</span>
<span class="line-modified"> 807             else if (&quot;centroid&quot; == next-&gt;stringView)</span>
<span class="line-modified"> 808                 qualifiers.append(AST::Qualifier::Centroid);</span>
<span class="line-modified"> 809             else {</span>
<span class="line-modified"> 810                 ASSERT(&quot;sample&quot; == next-&gt;stringView);</span>
<span class="line-modified"> 811                 qualifiers.append(AST::Qualifier::Sample);</span>
<span class="line-modified"> 812             }</span>
<span class="line-removed"> 813         } else</span>
<span class="line-removed"> 814             break;</span>
 815     }
 816     return qualifiers;
 817 }
 818 
 819 auto Parser::parseStructureElement() -&gt; Expected&lt;AST::StructureElement, Error&gt;
 820 {
<span class="line-modified"> 821     auto origin = peek();</span>
<span class="line-removed"> 822     if (!origin)</span>
<span class="line-removed"> 823         return Unexpected&lt;Error&gt;(origin.error());</span>
 824 
 825     AST::Qualifiers qualifiers = parseQualifiers();
 826 
<span class="line-modified"> 827     auto type = parseType();</span>
<span class="line-modified"> 828     if (!type)</span>
<span class="line-modified"> 829         return Unexpected&lt;Error&gt;(type.error());</span>
<span class="line-modified"> 830 </span>
<span class="line-removed"> 831     auto name = consumeType(Lexer::Token::Type::Identifier);</span>
<span class="line-removed"> 832     if (!name)</span>
<span class="line-removed"> 833         return Unexpected&lt;Error&gt;(name.error());</span>
<span class="line-removed"> 834 </span>
<span class="line-removed"> 835     if (tryType(Lexer::Token::Type::Colon)) {</span>
<span class="line-removed"> 836         auto semantic = parseSemantic();</span>
<span class="line-removed"> 837         if (!semantic)</span>
<span class="line-removed"> 838             return Unexpected&lt;Error&gt;(semantic.error());</span>
<span class="line-removed"> 839 </span>
<span class="line-removed"> 840         auto semicolon = consumeType(Lexer::Token::Type::Semicolon);</span>
<span class="line-removed"> 841         if (!semicolon)</span>
<span class="line-removed"> 842             return Unexpected&lt;Error&gt;(semicolon.error());</span>
 843 
<span class="line-modified"> 844         return AST::StructureElement(WTFMove(*origin), WTFMove(qualifiers), WTFMove(*type), name-&gt;stringView.toString(), WTFMove(*semantic));</span>
<span class="line-removed"> 845     }</span>
<span class="line-removed"> 846 </span>
<span class="line-removed"> 847     auto semicolon = consumeType(Lexer::Token::Type::Semicolon);</span>
<span class="line-removed"> 848     if (!semicolon)</span>
<span class="line-removed"> 849         return Unexpected&lt;Error&gt;(semicolon.error());</span>
<span class="line-removed"> 850 </span>
<span class="line-removed"> 851     return AST::StructureElement(WTFMove(*origin), WTFMove(qualifiers), WTFMove(*type), name-&gt;stringView.toString(), WTF::nullopt);</span>
 852 }
 853 
 854 auto Parser::parseStructureDefinition() -&gt; Expected&lt;AST::StructureDefinition, Error&gt;
 855 {
<span class="line-modified"> 856     auto origin = consumeType(Lexer::Token::Type::Struct);</span>
<span class="line-modified"> 857     if (!origin)</span>
<span class="line-modified"> 858         return Unexpected&lt;Error&gt;(origin.error());</span>
<span class="line-removed"> 859 </span>
<span class="line-removed"> 860     auto name = consumeType(Lexer::Token::Type::Identifier);</span>
<span class="line-removed"> 861     if (!name)</span>
<span class="line-removed"> 862         return Unexpected&lt;Error&gt;(name.error());</span>
<span class="line-removed"> 863 </span>
<span class="line-removed"> 864     auto leftCurlyBracket = consumeType(Lexer::Token::Type::LeftCurlyBracket);</span>
<span class="line-removed"> 865     if (!leftCurlyBracket)</span>
<span class="line-removed"> 866         return Unexpected&lt;Error&gt;(leftCurlyBracket.error());</span>
 867 
 868     AST::StructureElements structureElements;
<span class="line-modified"> 869     while (true) {</span>
<span class="line-modified"> 870         auto structureElement = backtrackingScope&lt;Expected&lt;AST::StructureElement, Error&gt;&gt;([&amp;]() {</span>
<span class="line-modified"> 871             return parseStructureElement();</span>
<span class="line-removed"> 872         });</span>
<span class="line-removed"> 873         if (structureElement)</span>
<span class="line-removed"> 874             structureElements.append(WTFMove(*structureElement));</span>
<span class="line-removed"> 875         else</span>
<span class="line-removed"> 876             break;</span>
 877     }
 878 
<span class="line-modified"> 879     auto rightCurlyBracket = consumeType(Lexer::Token::Type::RightCurlyBracket);</span>
<span class="line-removed"> 880     if (!rightCurlyBracket)</span>
<span class="line-removed"> 881         return Unexpected&lt;Error&gt;(rightCurlyBracket.error());</span>
 882 
<span class="line-modified"> 883     return AST::StructureDefinition(WTFMove(*origin), name-&gt;stringView.toString(), WTFMove(structureElements));</span>
 884 }
 885 
 886 auto Parser::parseEnumerationDefinition() -&gt; Expected&lt;AST::EnumerationDefinition, Error&gt;
 887 {
<span class="line-modified"> 888     auto origin = consumeType(Lexer::Token::Type::Enum);</span>
<span class="line-modified"> 889     if (!origin)</span>
<span class="line-removed"> 890         return Unexpected&lt;Error&gt;(origin.error());</span>
<span class="line-removed"> 891 </span>
<span class="line-removed"> 892     auto name = consumeType(Lexer::Token::Type::Identifier);</span>
<span class="line-removed"> 893     if (!name)</span>
<span class="line-removed"> 894         return Unexpected&lt;Error&gt;(name.error());</span>
 895 
<span class="line-modified"> 896     auto type = ([&amp;]() -&gt; Expected&lt;UniqueRef&lt;AST::UnnamedType&gt;, Error&gt; {</span>
<span class="line-modified"> 897         if (tryType(Lexer::Token::Type::Colon)) {</span>
<span class="line-modified"> 898             auto parsedType = parseType();</span>
<span class="line-removed"> 899             if (!parsedType)</span>
<span class="line-removed"> 900                 return Unexpected&lt;Error&gt;(parsedType.error());</span>
 901             return WTFMove(*parsedType);
 902         }
<span class="line-modified"> 903         return { makeUniqueRef&lt;AST::TypeReference&gt;(Lexer::Token(*origin), &quot;int&quot;_str, AST::TypeArguments()) };</span>
 904     })();
 905     if (!type)
<span class="line-modified"> 906         return Unexpected&lt;Error&gt;(type.error());</span>
 907 
<span class="line-modified"> 908     auto leftCurlyBracket = consumeType(Lexer::Token::Type::LeftCurlyBracket);</span>
<span class="line-removed"> 909     if (!leftCurlyBracket)</span>
<span class="line-removed"> 910         return Unexpected&lt;Error&gt;(leftCurlyBracket.error());</span>
 911 
<span class="line-modified"> 912     auto firstEnumerationMember = parseEnumerationMember();</span>
<span class="line-modified"> 913     if (!firstEnumerationMember)</span>
<span class="line-modified"> 914         return Unexpected&lt;Error&gt;(firstEnumerationMember.error());</span>
 915 
<span class="line-modified"> 916     AST::EnumerationDefinition result(WTFMove(*origin), name-&gt;stringView.toString(), WTFMove(*type));</span>
 917     auto success = result.add(WTFMove(*firstEnumerationMember));
 918     if (!success)
 919         return fail(&quot;Cannot add enumeration member&quot;_str);
 920 
<span class="line-modified"> 921     while (tryType(Lexer::Token::Type::Comma)) {</span>
<span class="line-modified"> 922         auto member = parseEnumerationMember();</span>
<span class="line-modified"> 923         if (!member)</span>
<span class="line-removed"> 924             return Unexpected&lt;Error&gt;(member.error());</span>
 925         success = result.add(WTFMove(*member));
 926         if (!success)
 927             return fail(&quot;Cannot add enumeration member&quot;_str);
 928     }
 929 
<span class="line-modified"> 930     auto rightCurlyBracket = consumeType(Lexer::Token::Type::RightCurlyBracket);</span>
<span class="line-modified"> 931     if (!rightCurlyBracket)</span>
<span class="line-removed"> 932         return Unexpected&lt;Error&gt;(rightCurlyBracket.error());</span>
 933 
 934     return WTFMove(result);
 935 }
 936 
<span class="line-modified"> 937 auto Parser::parseEnumerationMember() -&gt; Expected&lt;AST::EnumerationMember, Error&gt;</span>
 938 {
<span class="line-modified"> 939     auto identifier = consumeType(Lexer::Token::Type::Identifier);</span>
<span class="line-modified"> 940     if (!identifier)</span>
<span class="line-modified"> 941         return Unexpected&lt;Error&gt;(identifier.error());</span>
<span class="line-modified"> 942     auto name = identifier-&gt;stringView.toString();</span>

 943 
<span class="line-modified"> 944     if (tryType(Lexer::Token::Type::EqualsSign)) {</span>
<span class="line-modified"> 945         auto constantExpression = parseConstantExpression();</span>
<span class="line-modified"> 946         if (!constantExpression)</span>
<span class="line-modified"> 947             return Unexpected&lt;Error&gt;(constantExpression.error());</span>
<span class="line-modified"> 948         return AST::EnumerationMember(Lexer::Token(*identifier), WTFMove(name), WTFMove(*constantExpression));</span>









 949     }
<span class="line-modified"> 950     return AST::EnumerationMember(Lexer::Token(*identifier), WTFMove(name));</span>
 951 }
 952 
 953 auto Parser::parseNativeTypeDeclaration() -&gt; Expected&lt;AST::NativeTypeDeclaration, Error&gt;
 954 {
<span class="line-modified"> 955     auto origin = consumeType(Lexer::Token::Type::Native);</span>
<span class="line-modified"> 956     if (!origin)</span>
<span class="line-modified"> 957         return Unexpected&lt;Error&gt;(origin.error());</span>
<span class="line-modified"> 958 </span>
<span class="line-modified"> 959     auto parsedTypedef = consumeType(Lexer::Token::Type::Typedef);</span>
<span class="line-removed"> 960     if (!parsedTypedef)</span>
<span class="line-removed"> 961         return Unexpected&lt;Error&gt;(parsedTypedef.error());</span>
<span class="line-removed"> 962 </span>
<span class="line-removed"> 963     auto name = consumeType(Lexer::Token::Type::Identifier);</span>
<span class="line-removed"> 964     if (!name)</span>
<span class="line-removed"> 965         return Unexpected&lt;Error&gt;(name.error());</span>
 966 
<span class="line-modified"> 967     auto typeArguments = parseTypeArguments();</span>
<span class="line-removed"> 968     if (!typeArguments)</span>
<span class="line-removed"> 969         return Unexpected&lt;Error&gt;(typeArguments.error());</span>
<span class="line-removed"> 970 </span>
<span class="line-removed"> 971     auto semicolon = consumeType(Lexer::Token::Type::Semicolon);</span>
<span class="line-removed"> 972     if (!semicolon)</span>
<span class="line-removed"> 973         return Unexpected&lt;Error&gt;(semicolon.error());</span>
<span class="line-removed"> 974 </span>
<span class="line-removed"> 975     return AST::NativeTypeDeclaration(WTFMove(*origin), name-&gt;stringView.toString(), WTFMove(*typeArguments));</span>
 976 }
 977 
 978 auto Parser::parseNumThreadsFunctionAttribute() -&gt; Expected&lt;AST::NumThreadsFunctionAttribute, Error&gt;
 979 {
<span class="line-modified"> 980     auto origin = consumeType(Lexer::Token::Type::NumThreads);</span>
<span class="line-modified"> 981     if (!origin)</span>
<span class="line-removed"> 982         return Unexpected&lt;Error&gt;(origin.error());</span>
<span class="line-removed"> 983 </span>
<span class="line-removed"> 984     auto leftParenthesis = consumeType(Lexer::Token::Type::LeftParenthesis);</span>
<span class="line-removed"> 985     if (!leftParenthesis)</span>
<span class="line-removed"> 986         return Unexpected&lt;Error&gt;(leftParenthesis.error());</span>
 987 
 988     auto width = consumeNonNegativeIntegralLiteral();
 989     if (!width)
<span class="line-modified"> 990         return Unexpected&lt;Error&gt;(width.error());</span>
 991 
<span class="line-modified"> 992     auto comma = consumeType(Lexer::Token::Type::Comma);</span>
<span class="line-removed"> 993     if (!comma)</span>
<span class="line-removed"> 994         return Unexpected&lt;Error&gt;(comma.error());</span>
 995 
 996     auto height = consumeNonNegativeIntegralLiteral();
 997     if (!height)
<span class="line-modified"> 998         return Unexpected&lt;Error&gt;(height.error());</span>
 999 
<span class="line-modified">1000     comma = consumeType(Lexer::Token::Type::Comma);</span>
<span class="line-removed">1001     if (!comma)</span>
<span class="line-removed">1002         return Unexpected&lt;Error&gt;(comma.error());</span>
1003 
1004     auto depth = consumeNonNegativeIntegralLiteral();
1005     if (!depth)
<span class="line-modified">1006         return Unexpected&lt;Error&gt;(depth.error());</span>
1007 
<span class="line-modified">1008     auto rightParenthesis = consumeType(Lexer::Token::Type::RightParenthesis);</span>
<span class="line-removed">1009     if (!rightParenthesis)</span>
<span class="line-removed">1010         return Unexpected&lt;Error&gt;(rightParenthesis.error());</span>
1011 
<span class="line-modified">1012     return AST::NumThreadsFunctionAttribute(WTFMove(*origin), *width, *height, *depth);</span>
1013 }
1014 
1015 auto Parser::parseAttributeBlock() -&gt; Expected&lt;AST::AttributeBlock, Error&gt;
1016 {
<span class="line-modified">1017     auto leftSquareBracket = consumeType(Lexer::Token::Type::LeftSquareBracket);</span>
<span class="line-removed">1018     if (!leftSquareBracket)</span>
<span class="line-removed">1019         return Unexpected&lt;Error&gt;(leftSquareBracket.error());</span>
1020 
1021     AST::AttributeBlock result;
1022 
<span class="line-modified">1023     while (true) {</span>
<span class="line-modified">1024         auto numThreadsFunctionAttribute = backtrackingScope&lt;Expected&lt;AST::NumThreadsFunctionAttribute, Error&gt;&gt;([&amp;]() {</span>
<span class="line-modified">1025             return parseNumThreadsFunctionAttribute();</span>
<span class="line-removed">1026         });</span>
<span class="line-removed">1027         if (numThreadsFunctionAttribute) {</span>
<span class="line-removed">1028             result.append(WTFMove(*numThreadsFunctionAttribute));</span>
<span class="line-removed">1029             continue;</span>
<span class="line-removed">1030         }</span>
<span class="line-removed">1031 </span>
<span class="line-removed">1032         break;</span>
1033     }
1034 
<span class="line-removed">1035     auto rightSquareBracket = consumeType(Lexer::Token::Type::RightSquareBracket);</span>
<span class="line-removed">1036     if (!rightSquareBracket)</span>
<span class="line-removed">1037         return Unexpected&lt;Error&gt;(rightSquareBracket.error());</span>
<span class="line-removed">1038 </span>
1039     return WTFMove(result);
1040 }
1041 
1042 auto Parser::parseParameter() -&gt; Expected&lt;AST::VariableDeclaration, Error&gt;
1043 {
<span class="line-modified">1044     auto origin = peek();</span>
<span class="line-removed">1045     if (!origin)</span>
<span class="line-removed">1046         return Unexpected&lt;Error&gt;(origin.error());</span>
1047 
1048     AST::Qualifiers qualifiers = parseQualifiers();
<span class="line-modified">1049 </span>
<span class="line-removed">1050     auto type = parseType();</span>
<span class="line-removed">1051     if (!type)</span>
<span class="line-removed">1052         return Unexpected&lt;Error&gt;(type.error());</span>
1053 
1054     String name;
<span class="line-modified">1055     if (auto token = tryType(Lexer::Token::Type::Identifier))</span>
<span class="line-modified">1056         name = token-&gt;stringView.toString();</span>
1057 
<span class="line-modified">1058     if (tryType(Lexer::Token::Type::Colon)) {</span>
<span class="line-modified">1059         auto semantic = parseSemantic();</span>
<span class="line-modified">1060         if (!semantic)</span>
<span class="line-removed">1061             return Unexpected&lt;Error&gt;(semantic.error());</span>
<span class="line-removed">1062         return AST::VariableDeclaration(WTFMove(*origin), WTFMove(qualifiers), Optional&lt;UniqueRef&lt;AST::UnnamedType&gt;&gt;(WTFMove(*type)), WTFMove(name), WTFMove(*semantic), WTF::nullopt);</span>
<span class="line-removed">1063     }</span>
1064 
<span class="line-modified">1065     return AST::VariableDeclaration(WTFMove(*origin), WTFMove(qualifiers), { WTFMove(*type) }, WTFMove(name), WTF::nullopt, WTF::nullopt);</span>
1066 }
1067 
1068 auto Parser::parseParameters() -&gt; Expected&lt;AST::VariableDeclarations, Error&gt;
1069 {
<span class="line-removed">1070     auto leftParenthesis = consumeType(Lexer::Token::Type::LeftParenthesis);</span>
<span class="line-removed">1071     if (!leftParenthesis)</span>
<span class="line-removed">1072         return Unexpected&lt;Error&gt;(leftParenthesis.error());</span>
<span class="line-removed">1073 </span>
1074     AST::VariableDeclarations parameters;
<span class="line-modified">1075     if (tryType(Lexer::Token::Type::RightParenthesis))</span>



1076         return WTFMove(parameters);
1077 
<span class="line-modified">1078     auto firstParameter = parseParameter();</span>
<span class="line-modified">1079     if (!firstParameter)</span>
<span class="line-removed">1080         return Unexpected&lt;Error&gt;(firstParameter.error());</span>
<span class="line-removed">1081     parameters.append(WTFMove(*firstParameter));</span>
1082 
<span class="line-modified">1083     while (tryType(Lexer::Token::Type::Comma)) {</span>
<span class="line-modified">1084         auto parameter = parseParameter();</span>
<span class="line-modified">1085         if (!parameter)</span>
<span class="line-removed">1086             return Unexpected&lt;Error&gt;(parameter.error());</span>
<span class="line-removed">1087         parameters.append(WTFMove(*parameter));</span>
1088     }
1089 
<span class="line-modified">1090     auto rightParenthesis = consumeType(Lexer::Token::Type::RightParenthesis);</span>
<span class="line-removed">1091     if (!rightParenthesis)</span>
<span class="line-removed">1092         return Unexpected&lt;Error&gt;(rightParenthesis.error());</span>
1093 
1094     return WTFMove(parameters);
1095 }
1096 
1097 auto Parser::parseFunctionDefinition() -&gt; Expected&lt;AST::FunctionDefinition, Error&gt;
1098 {
<span class="line-modified">1099     auto functionDeclaration = parseFunctionDeclaration();</span>
<span class="line-modified">1100     if (!functionDeclaration)</span>
<span class="line-removed">1101         return Unexpected&lt;Error&gt;(functionDeclaration.error());</span>
<span class="line-removed">1102 </span>
<span class="line-removed">1103     auto block = parseBlock();</span>
<span class="line-removed">1104     if (!block)</span>
<span class="line-removed">1105         return Unexpected&lt;Error&gt;(block.error());</span>
<span class="line-removed">1106 </span>
1107     return AST::FunctionDefinition(WTFMove(*functionDeclaration), WTFMove(*block));
1108 }
1109 
<span class="line-modified">1110 auto Parser::parseEntryPointFunctionDeclaration() -&gt; Expected&lt;AST::FunctionDeclaration, Error&gt;</span>
1111 {
<span class="line-modified">1112     auto origin = peek();</span>
<span class="line-removed">1113     if (!origin)</span>
<span class="line-removed">1114         return Unexpected&lt;Error&gt;(origin.error());</span>
1115 
<span class="line-modified">1116     AST::AttributeBlock attributeBlock;</span>
<span class="line-modified">1117     AST::EntryPointType entryPointType;</span>
<span class="line-modified">1118 </span>
<span class="line-modified">1119     auto parsedAttributeBlock = backtrackingScope&lt;Expected&lt;AST::AttributeBlock, Error&gt;&gt;([&amp;]() {</span>
<span class="line-modified">1120         return parseAttributeBlock();</span>
<span class="line-modified">1121     });</span>
<span class="line-removed">1122     if (parsedAttributeBlock) {</span>
<span class="line-removed">1123         auto compute = consumeType(Lexer::Token::Type::Compute);</span>
<span class="line-removed">1124         if (!compute)</span>
<span class="line-removed">1125             return Unexpected&lt;Error&gt;(compute.error());</span>
<span class="line-removed">1126         attributeBlock = WTFMove(*parsedAttributeBlock);</span>
<span class="line-removed">1127         entryPointType = AST::EntryPointType::Compute;</span>
<span class="line-removed">1128     } else {</span>
<span class="line-removed">1129         auto type = consumeTypes({ Lexer::Token::Type::Vertex, Lexer::Token::Type::Fragment });</span>
<span class="line-removed">1130         if (!type)</span>
<span class="line-removed">1131             return Unexpected&lt;Error&gt;(type.error());</span>
<span class="line-removed">1132 </span>
<span class="line-removed">1133         switch (origin-&gt;type) {</span>
<span class="line-removed">1134         case Lexer::Token::Type::Vertex:</span>
<span class="line-removed">1135             entryPointType = AST::EntryPointType::Vertex;</span>
<span class="line-removed">1136             break;</span>
<span class="line-removed">1137         default:</span>
<span class="line-removed">1138             ASSERT(origin-&gt;type == Lexer::Token::Type::Fragment);</span>
<span class="line-removed">1139             entryPointType = AST::EntryPointType::Fragment;</span>
<span class="line-removed">1140             break;</span>
<span class="line-removed">1141         }</span>
<span class="line-removed">1142     }</span>
1143 
<span class="line-modified">1144     auto type = parseType();</span>
<span class="line-removed">1145     if (!type)</span>
<span class="line-removed">1146         return Unexpected&lt;Error&gt;(type.error());</span>
1147 
<span class="line-modified">1148     auto name = consumeType(Lexer::Token::Type::Identifier);</span>
<span class="line-modified">1149     if (!name)</span>
<span class="line-modified">1150         return Unexpected&lt;Error&gt;(name.error());</span>
1151 
<span class="line-modified">1152     auto parameters = parseParameters();</span>
<span class="line-modified">1153     if (!parameters)</span>
<span class="line-modified">1154         return Unexpected&lt;Error&gt;(parameters.error());</span>



1155 
<span class="line-modified">1156     bool isOperator = false;</span>



1157 
<span class="line-modified">1158     if (tryType(Lexer::Token::Type::Colon)) {</span>
<span class="line-removed">1159         auto semantic = parseSemantic();</span>
<span class="line-removed">1160         if (!semantic)</span>
<span class="line-removed">1161             return Unexpected&lt;Error&gt;(semantic.error());</span>
<span class="line-removed">1162         return AST::FunctionDeclaration(WTFMove(*origin), WTFMove(attributeBlock), entryPointType, WTFMove(*type), name-&gt;stringView.toString(), WTFMove(*parameters), WTFMove(*semantic), isOperator);</span>
<span class="line-removed">1163     }</span>
1164 
<span class="line-modified">1165     return AST::FunctionDeclaration(WTFMove(*origin), WTFMove(attributeBlock), entryPointType, WTFMove(*type), name-&gt;stringView.toString(), WTFMove(*parameters), WTF::nullopt, isOperator);</span>

1166 }
1167 
1168 auto Parser::parseRegularFunctionDeclaration() -&gt; Expected&lt;AST::FunctionDeclaration, Error&gt;
1169 {
<span class="line-modified">1170     auto origin = peek();</span>
<span class="line-removed">1171     if (!origin)</span>
<span class="line-removed">1172         return Unexpected&lt;Error&gt;(origin.error());</span>
1173 
<span class="line-modified">1174     auto type = parseType();</span>
<span class="line-removed">1175     if (!type)</span>
<span class="line-removed">1176         return Unexpected&lt;Error&gt;(type.error());</span>
1177 
<span class="line-modified">1178     auto name = consumeTypes({ Lexer::Token::Type::Identifier, Lexer::Token::Type::OperatorName });</span>
1179     if (!name)
<span class="line-modified">1180         return Unexpected&lt;Error&gt;(name.error());</span>
<span class="line-modified">1181     auto isOperator = name-&gt;type == Lexer::Token::Type::OperatorName;</span>
1182 
<span class="line-modified">1183     auto parameters = parseParameters();</span>
<span class="line-modified">1184     if (!parameters)</span>
<span class="line-removed">1185         return Unexpected&lt;Error&gt;(parameters.error());</span>
1186 
<span class="line-modified">1187     if (tryType(Lexer::Token::Type::Colon)) {</span>
<span class="line-removed">1188         auto semantic = parseSemantic();</span>
<span class="line-removed">1189         if (!semantic)</span>
<span class="line-removed">1190             return Unexpected&lt;Error&gt;(semantic.error());</span>
<span class="line-removed">1191         return AST::FunctionDeclaration(WTFMove(*origin), { }, WTF::nullopt, WTFMove(*type), name-&gt;stringView.toString(), WTFMove(*parameters), WTFMove(*semantic), isOperator);</span>
<span class="line-removed">1192     }</span>
1193 
<span class="line-modified">1194     return AST::FunctionDeclaration(WTFMove(*origin), { }, WTF::nullopt, WTFMove(*type), name-&gt;stringView.toString(), WTFMove(*parameters), WTF::nullopt, isOperator);</span>
1195 }
1196 
1197 auto Parser::parseOperatorFunctionDeclaration() -&gt; Expected&lt;AST::FunctionDeclaration, Error&gt;
1198 {
<span class="line-modified">1199     auto origin = consumeType(Lexer::Token::Type::Operator);</span>
<span class="line-modified">1200     if (!origin)</span>
<span class="line-modified">1201         return Unexpected&lt;Error&gt;(origin.error());</span>
<span class="line-modified">1202 </span>
<span class="line-removed">1203     auto type = parseType();</span>
<span class="line-removed">1204     if (!type)</span>
<span class="line-removed">1205         return Unexpected&lt;Error&gt;(type.error());</span>
1206 
<span class="line-modified">1207     auto parameters = parseParameters();</span>
<span class="line-removed">1208     if (!parameters)</span>
<span class="line-removed">1209         return Unexpected&lt;Error&gt;(parameters.error());</span>
1210 
1211     bool isOperator = true;
<span class="line-modified">1212 </span>
<span class="line-removed">1213     if (tryType(Lexer::Token::Type::Colon)) {</span>
<span class="line-removed">1214         auto semantic = parseSemantic();</span>
<span class="line-removed">1215         if (!semantic)</span>
<span class="line-removed">1216             return Unexpected&lt;Error&gt;(semantic.error());</span>
<span class="line-removed">1217         return AST::FunctionDeclaration(WTFMove(*origin), { }, WTF::nullopt, WTFMove(*type), &quot;operator cast&quot;_str, WTFMove(*parameters), WTFMove(*semantic), isOperator);</span>
<span class="line-removed">1218     }</span>
<span class="line-removed">1219 </span>
<span class="line-removed">1220     return AST::FunctionDeclaration(WTFMove(*origin), { }, WTF::nullopt, WTFMove(*type), &quot;operator cast&quot;_str, WTFMove(*parameters), WTF::nullopt, isOperator);</span>
1221 }
1222 
1223 auto Parser::parseFunctionDeclaration() -&gt; Expected&lt;AST::FunctionDeclaration, Error&gt;
1224 {
<span class="line-modified">1225     auto entryPointFunctionDeclaration = backtrackingScope&lt;Expected&lt;AST::FunctionDeclaration, Error&gt;&gt;([&amp;]() {</span>
<span class="line-modified">1226         return parseEntryPointFunctionDeclaration();</span>
<span class="line-modified">1227     });</span>
<span class="line-removed">1228     if (entryPointFunctionDeclaration)</span>
<span class="line-removed">1229         return WTFMove(*entryPointFunctionDeclaration);</span>
<span class="line-removed">1230 </span>
<span class="line-removed">1231     auto regularFunctionDeclaration = backtrackingScope&lt;Expected&lt;AST::FunctionDeclaration, Error&gt;&gt;([&amp;]() {</span>
<span class="line-removed">1232         return parseRegularFunctionDeclaration();</span>
<span class="line-removed">1233     });</span>
<span class="line-removed">1234     if (regularFunctionDeclaration)</span>
<span class="line-removed">1235         return WTFMove(*regularFunctionDeclaration);</span>
<span class="line-removed">1236 </span>
<span class="line-removed">1237     auto operatorFunctionDeclaration = backtrackingScope&lt;Expected&lt;AST::FunctionDeclaration, Error&gt;&gt;([&amp;]() {</span>
1238         return parseOperatorFunctionDeclaration();
<span class="line-modified">1239     });</span>
<span class="line-modified">1240     if (operatorFunctionDeclaration)</span>
<span class="line-modified">1241         return WTFMove(*operatorFunctionDeclaration);</span>
<span class="line-modified">1242 </span>
<span class="line-modified">1243     return Unexpected&lt;Error&gt;(operatorFunctionDeclaration.error());</span>



1244 }
1245 
1246 auto Parser::parseNativeFunctionDeclaration() -&gt; Expected&lt;AST::NativeFunctionDeclaration, Error&gt;
1247 {
<span class="line-modified">1248     Optional&lt;Lexer::Token&gt; origin;</span>
<span class="line-modified">1249 </span>
<span class="line-modified">1250     auto native = consumeType(Lexer::Token::Type::Native);</span>
<span class="line-removed">1251     if (!native)</span>
<span class="line-removed">1252         return Unexpected&lt;Error&gt;(native.error());</span>
<span class="line-removed">1253     if (!origin)</span>
<span class="line-removed">1254         origin = *native;</span>
<span class="line-removed">1255 </span>
<span class="line-removed">1256     auto functionDeclaration = parseFunctionDeclaration();</span>
<span class="line-removed">1257     if (!functionDeclaration)</span>
<span class="line-removed">1258         return Unexpected&lt;Error&gt;(functionDeclaration.error());</span>
<span class="line-removed">1259 </span>
<span class="line-removed">1260     auto semicolon = consumeType(Lexer::Token::Type::Semicolon);</span>
<span class="line-removed">1261     if (!semicolon)</span>
<span class="line-removed">1262         return Unexpected&lt;Error&gt;(semicolon.error());</span>
1263 
1264     return AST::NativeFunctionDeclaration(WTFMove(*functionDeclaration));
1265 }
1266 
1267 auto Parser::parseBlock() -&gt; Expected&lt;AST::Block, Error&gt;
1268 {
<span class="line-modified">1269     auto origin = consumeType(Lexer::Token::Type::LeftCurlyBracket);</span>
<span class="line-modified">1270     if (!origin)</span>
<span class="line-modified">1271         return Unexpected&lt;Error&gt;(origin.error());</span>
<span class="line-modified">1272 </span>
<span class="line-modified">1273     auto result = parseBlockBody(WTFMove(*origin));</span>
<span class="line-removed">1274 </span>
<span class="line-removed">1275     auto rightCurlyBracket = consumeType(Lexer::Token::Type::RightCurlyBracket);</span>
<span class="line-removed">1276     if (!rightCurlyBracket)</span>
<span class="line-removed">1277         return Unexpected&lt;Error&gt;(rightCurlyBracket.error());</span>
<span class="line-removed">1278 </span>
<span class="line-removed">1279     return WTFMove(result);</span>
1280 }
1281 
<span class="line-modified">1282 AST::Block Parser::parseBlockBody(Lexer::Token&amp;&amp; origin)</span>
1283 {


1284     AST::Statements statements;
<span class="line-modified">1285     while (true) {</span>
<span class="line-modified">1286         auto statement = backtrackingScope&lt;Expected&lt;UniqueRef&lt;AST::Statement&gt;, Error&gt;&gt;([&amp;]() {</span>
<span class="line-modified">1287             return parseStatement();</span>
<span class="line-removed">1288         });</span>
<span class="line-removed">1289         if (statement)</span>
<span class="line-removed">1290             statements.append(WTFMove(*statement));</span>
<span class="line-removed">1291         else</span>
<span class="line-removed">1292             break;</span>
1293     }
<span class="line-modified">1294     return AST::Block(WTFMove(origin), WTFMove(statements));</span>



1295 }
1296 
1297 auto Parser::parseIfStatement() -&gt; Expected&lt;AST::IfStatement, Error&gt;
1298 {
<span class="line-modified">1299     auto origin = consumeType(Lexer::Token::Type::If);</span>
<span class="line-modified">1300     if (!origin)</span>
<span class="line-modified">1301         return Unexpected&lt;Error&gt;(origin.error());</span>
<span class="line-modified">1302 </span>
<span class="line-modified">1303     auto leftParenthesis = consumeType(Lexer::Token::Type::LeftParenthesis);</span>
<span class="line-removed">1304     if (!leftParenthesis)</span>
<span class="line-removed">1305         return Unexpected&lt;Error&gt;(leftParenthesis.error());</span>
<span class="line-removed">1306 </span>
<span class="line-removed">1307     auto conditional = parseExpression();</span>
<span class="line-removed">1308     if (!conditional)</span>
<span class="line-removed">1309         return Unexpected&lt;Error&gt;(conditional.error());</span>
<span class="line-removed">1310 </span>
<span class="line-removed">1311     auto rightParenthesis = consumeType(Lexer::Token::Type::RightParenthesis);</span>
<span class="line-removed">1312     if (!rightParenthesis)</span>
<span class="line-removed">1313         return Unexpected&lt;Error&gt;(rightParenthesis.error());</span>
<span class="line-removed">1314 </span>
<span class="line-removed">1315     auto body = parseStatement();</span>
<span class="line-removed">1316     if (!body)</span>
<span class="line-removed">1317         return Unexpected&lt;Error&gt;(body.error());</span>
1318 
<span class="line-modified">1319     Optional&lt;UniqueRef&lt;AST::Statement&gt;&gt; elseBody;</span>
<span class="line-modified">1320     if (tryType(Lexer::Token::Type::Else)) {</span>
<span class="line-modified">1321         auto parsedElseBody = parseStatement();</span>
<span class="line-modified">1322         if (!parsedElseBody)</span>
<span class="line-removed">1323             return Unexpected&lt;Error&gt;(parsedElseBody.error());</span>
<span class="line-removed">1324         elseBody = WTFMove(*parsedElseBody);</span>
1325     }
1326 


1327     Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; castArguments;
1328     castArguments.append(WTFMove(*conditional));
<span class="line-modified">1329     auto boolCast = makeUniqueRef&lt;AST::CallExpression&gt;(Lexer::Token(*origin), &quot;bool&quot;_str, WTFMove(castArguments));</span>
<span class="line-modified">1330     return AST::IfStatement(WTFMove(*origin), WTFMove(boolCast), WTFMove(*body), WTFMove(elseBody));</span>
1331 }
1332 
1333 auto Parser::parseSwitchStatement() -&gt; Expected&lt;AST::SwitchStatement, Error&gt;
1334 {
<span class="line-modified">1335     auto origin = consumeType(Lexer::Token::Type::Switch);</span>
<span class="line-modified">1336     if (!origin)</span>
<span class="line-modified">1337         return Unexpected&lt;Error&gt;(origin.error());</span>


1338 
<span class="line-modified">1339     auto leftParenthesis = consumeType(Lexer::Token::Type::LeftParenthesis);</span>
<span class="line-modified">1340     if (!leftParenthesis)</span>
<span class="line-modified">1341         return Unexpected&lt;Error&gt;(leftParenthesis.error());</span>





1342 
<span class="line-modified">1343     auto value = parseExpression();</span>
<span class="line-removed">1344     if (!value)</span>
<span class="line-removed">1345         return Unexpected&lt;Error&gt;(value.error());</span>
1346 
<span class="line-modified">1347     auto rightParenthesis = consumeType(Lexer::Token::Type::RightParenthesis);</span>
<span class="line-modified">1348     if (!rightParenthesis)</span>
<span class="line-removed">1349         return Unexpected&lt;Error&gt;(rightParenthesis.error());</span>
1350 
<span class="line-modified">1351     auto leftCurlyBracket = consumeType(Lexer::Token::Type::LeftCurlyBracket);</span>
<span class="line-modified">1352     if (!leftCurlyBracket)</span>
<span class="line-modified">1353         return Unexpected&lt;Error&gt;(leftCurlyBracket.error());</span>
<span class="line-modified">1354 </span>
<span class="line-modified">1355     Vector&lt;AST::SwitchCase&gt; switchCases;</span>
<span class="line-removed">1356     while (true) {</span>
<span class="line-removed">1357         auto switchCase = backtrackingScope&lt;Expected&lt;AST::SwitchCase, Error&gt;&gt;([&amp;]() {</span>
<span class="line-removed">1358             return parseSwitchCase();</span>
<span class="line-removed">1359         });</span>
<span class="line-removed">1360         if (switchCase)</span>
<span class="line-removed">1361             switchCases.append(WTFMove(*switchCase));</span>
<span class="line-removed">1362         else</span>
<span class="line-removed">1363             break;</span>
<span class="line-removed">1364     }</span>
<span class="line-removed">1365 </span>
<span class="line-removed">1366     auto rightCurlyBracket = consumeType(Lexer::Token::Type::RightCurlyBracket);</span>
<span class="line-removed">1367     if (!rightCurlyBracket)</span>
<span class="line-removed">1368         return Unexpected&lt;Error&gt;(rightCurlyBracket.error());</span>
<span class="line-removed">1369 </span>
<span class="line-removed">1370     return AST::SwitchStatement(WTFMove(*origin), WTFMove(*value), WTFMove(switchCases));</span>
<span class="line-removed">1371 }</span>
<span class="line-removed">1372 </span>
<span class="line-removed">1373 auto Parser::parseSwitchCase() -&gt; Expected&lt;AST::SwitchCase, Error&gt;</span>
<span class="line-removed">1374 {</span>
<span class="line-removed">1375     auto origin = consumeTypes({ Lexer::Token::Type::Case, Lexer::Token::Type::Default });</span>
<span class="line-removed">1376     if (!origin)</span>
<span class="line-removed">1377         return Unexpected&lt;Error&gt;(origin.error());</span>
1378 
1379     switch (origin-&gt;type) {
<span class="line-modified">1380     case Lexer::Token::Type::Case: {</span>
<span class="line-modified">1381         auto value = parseConstantExpression();</span>
<span class="line-modified">1382         if (!value)</span>
<span class="line-removed">1383             return Unexpected&lt;Error&gt;(value.error());</span>
1384 
<span class="line-modified">1385         auto origin = consumeType(Lexer::Token::Type::Colon);</span>
<span class="line-removed">1386         if (!origin)</span>
<span class="line-removed">1387             return Unexpected&lt;Error&gt;(origin.error());</span>
1388 
<span class="line-modified">1389         auto block = parseBlockBody(Lexer::Token(*origin));</span>
<span class="line-removed">1390 </span>
<span class="line-removed">1391         return AST::SwitchCase(WTFMove(*origin), WTFMove(*value), WTFMove(block));</span>
1392     }
1393     default: {
<span class="line-modified">1394         ASSERT(origin-&gt;type == Lexer::Token::Type::Default);</span>
<span class="line-modified">1395         auto origin = consumeType(Lexer::Token::Type::Colon);</span>
<span class="line-removed">1396         if (!origin)</span>
<span class="line-removed">1397             return Unexpected&lt;Error&gt;(origin.error());</span>
1398 
<span class="line-modified">1399         auto block = parseBlockBody(Lexer::Token(*origin));</span>
1400 
<span class="line-modified">1401         return AST::SwitchCase(WTFMove(*origin), WTF::nullopt, WTFMove(block));</span>
1402     }
1403     }
1404 }
1405 
1406 auto Parser::parseForLoop() -&gt; Expected&lt;AST::ForLoop, Error&gt;
1407 {
<span class="line-modified">1408     auto origin = consumeType(Lexer::Token::Type::For);</span>
<span class="line-modified">1409     if (!origin)</span>
<span class="line-removed">1410         return Unexpected&lt;Error&gt;(origin.error());</span>
1411 
<span class="line-modified">1412     auto parseRemainder = [&amp;](Variant&lt;AST::VariableDeclarationsStatement, UniqueRef&lt;AST::Expression&gt;&gt;&amp;&amp; initialization) -&gt; Expected&lt;AST::ForLoop, Error&gt; {</span>
<span class="line-modified">1413         auto semicolon = consumeType(Lexer::Token::Type::Semicolon);</span>
<span class="line-removed">1414         if (!semicolon)</span>
<span class="line-removed">1415             return Unexpected&lt;Error&gt;(semicolon.error());</span>
1416 
<span class="line-modified">1417         auto condition = backtrackingScope&lt;Optional&lt;UniqueRef&lt;AST::Expression&gt;&gt;&gt;([&amp;]() -&gt; Optional&lt;UniqueRef&lt;AST::Expression&gt;&gt; {</span>

1418             if (auto expression = parseExpression())
<span class="line-modified">1419                 return { WTFMove(*expression) };</span>
<span class="line-modified">1420             return WTF::nullopt;</span>
<span class="line-modified">1421         });</span>
<span class="line-modified">1422 </span>
<span class="line-modified">1423         semicolon = consumeType(Lexer::Token::Type::Semicolon);</span>
<span class="line-removed">1424         if (!semicolon)</span>
<span class="line-removed">1425             return Unexpected&lt;Error&gt;(semicolon.error());</span>
1426 
<span class="line-modified">1427         auto increment = backtrackingScope&lt;Optional&lt;UniqueRef&lt;AST::Expression&gt;&gt;&gt;([&amp;]() -&gt; Optional&lt;UniqueRef&lt;AST::Expression&gt;&gt; {</span>

1428             if (auto expression = parseExpression())
<span class="line-modified">1429                 return { WTFMove(*expression) };</span>
<span class="line-modified">1430             return WTF::nullopt;</span>
<span class="line-modified">1431         });</span>
<span class="line-modified">1432 </span>
<span class="line-modified">1433         auto rightParenthesis = consumeType(Lexer::Token::Type::RightParenthesis);</span>
<span class="line-removed">1434         if (!rightParenthesis)</span>
<span class="line-removed">1435             return Unexpected&lt;Error&gt;(rightParenthesis.error());</span>
<span class="line-removed">1436 </span>
<span class="line-removed">1437         auto body = parseStatement();</span>
<span class="line-removed">1438         if (!body)</span>
<span class="line-removed">1439             return Unexpected&lt;Error&gt;(body.error());</span>
1440 
<span class="line-modified">1441         return AST::ForLoop(WTFMove(*origin), WTFMove(initialization), WTFMove(condition), WTFMove(increment), WTFMove(*body));</span>


1442     };
1443 
<span class="line-removed">1444     auto leftParenthesis = consumeType(Lexer::Token::Type::LeftParenthesis);</span>
<span class="line-removed">1445     if (!leftParenthesis)</span>
<span class="line-removed">1446         return Unexpected&lt;Error&gt;(leftParenthesis.error());</span>
<span class="line-removed">1447 </span>
1448     auto variableDeclarations = backtrackingScope&lt;Expected&lt;AST::VariableDeclarationsStatement, Error&gt;&gt;([&amp;]() {
1449         return parseVariableDeclarations();
1450     });
<span class="line-modified">1451     if (variableDeclarations)</span>
<span class="line-modified">1452         return parseRemainder(WTFMove(*variableDeclarations));</span>


1453 
<span class="line-modified">1454     auto effectfulExpression = parseEffectfulExpression();</span>
<span class="line-removed">1455     if (!effectfulExpression)</span>
<span class="line-removed">1456         return Unexpected&lt;Error&gt;(effectfulExpression.error());</span>
1457 
1458     return parseRemainder(WTFMove(*effectfulExpression));
1459 }
1460 
1461 auto Parser::parseWhileLoop() -&gt; Expected&lt;AST::WhileLoop, Error&gt;
1462 {
<span class="line-modified">1463     auto origin = consumeType(Lexer::Token::Type::While);</span>
<span class="line-modified">1464     if (!origin)</span>
<span class="line-modified">1465         return Unexpected&lt;Error&gt;(origin.error());</span>
<span class="line-modified">1466 </span>
<span class="line-modified">1467     auto leftParenthesis = consumeType(Lexer::Token::Type::LeftParenthesis);</span>
<span class="line-removed">1468     if (!leftParenthesis)</span>
<span class="line-removed">1469         return Unexpected&lt;Error&gt;(leftParenthesis.error());</span>
<span class="line-removed">1470 </span>
<span class="line-removed">1471     auto conditional = parseExpression();</span>
<span class="line-removed">1472     if (!conditional)</span>
<span class="line-removed">1473         return Unexpected&lt;Error&gt;(conditional.error());</span>
<span class="line-removed">1474 </span>
<span class="line-removed">1475     auto rightParenthesis = consumeType(Lexer::Token::Type::RightParenthesis);</span>
<span class="line-removed">1476     if (!rightParenthesis)</span>
<span class="line-removed">1477         return Unexpected&lt;Error&gt;(rightParenthesis.error());</span>
1478 
<span class="line-modified">1479     auto body = parseStatement();</span>
<span class="line-modified">1480     if (!body)</span>
<span class="line-removed">1481         return Unexpected&lt;Error&gt;(body.error());</span>
<span class="line-removed">1482 </span>
<span class="line-removed">1483     return AST::WhileLoop(WTFMove(*origin), WTFMove(*conditional), WTFMove(*body));</span>
1484 }
1485 
1486 auto Parser::parseDoWhileLoop() -&gt; Expected&lt;AST::DoWhileLoop, Error&gt;
1487 {
<span class="line-modified">1488     auto origin = consumeType(Lexer::Token::Type::Do);</span>
<span class="line-modified">1489     if (!origin)</span>
<span class="line-modified">1490         return Unexpected&lt;Error&gt;(origin.error());</span>
<span class="line-modified">1491 </span>
<span class="line-modified">1492     auto body = parseStatement();</span>
<span class="line-modified">1493     if (!body)</span>
<span class="line-modified">1494         return Unexpected&lt;Error&gt;(body.error());</span>
<span class="line-removed">1495 </span>
<span class="line-removed">1496     auto whileKeyword = consumeType(Lexer::Token::Type::While);</span>
<span class="line-removed">1497     if (!whileKeyword)</span>
<span class="line-removed">1498         return Unexpected&lt;Error&gt;(whileKeyword.error());</span>
1499 
<span class="line-modified">1500     auto leftParenthesis = consumeType(Lexer::Token::Type::LeftParenthesis);</span>
<span class="line-removed">1501     if (!leftParenthesis)</span>
<span class="line-removed">1502         return Unexpected&lt;Error&gt;(leftParenthesis.error());</span>
<span class="line-removed">1503 </span>
<span class="line-removed">1504     auto conditional = parseExpression();</span>
<span class="line-removed">1505     if (!conditional)</span>
<span class="line-removed">1506         return Unexpected&lt;Error&gt;(conditional.error());</span>
<span class="line-removed">1507 </span>
<span class="line-removed">1508     auto rightParenthesis = consumeType(Lexer::Token::Type::RightParenthesis);</span>
<span class="line-removed">1509     if (!rightParenthesis)</span>
<span class="line-removed">1510         return Unexpected&lt;Error&gt;(rightParenthesis.error());</span>
<span class="line-removed">1511 </span>
<span class="line-removed">1512     return AST::DoWhileLoop(WTFMove(*origin), WTFMove(*body), WTFMove(*conditional));</span>
1513 }
1514 
<span class="line-modified">1515 auto Parser::parseVariableDeclaration(UniqueRef&lt;AST::UnnamedType&gt;&amp;&amp; type) -&gt; Expected&lt;AST::VariableDeclaration, Error&gt;</span>
1516 {
<span class="line-modified">1517     auto origin = peek();</span>
<span class="line-removed">1518     if (!origin)</span>
<span class="line-removed">1519         return Unexpected&lt;Error&gt;(origin.error());</span>
1520 
1521     auto qualifiers = parseQualifiers();
1522 
<span class="line-modified">1523     auto name = consumeType(Lexer::Token::Type::Identifier);</span>
<span class="line-modified">1524     if (!name)</span>
<span class="line-removed">1525         return Unexpected&lt;Error&gt;(name.error());</span>
<span class="line-removed">1526 </span>
<span class="line-removed">1527     if (tryType(Lexer::Token::Type::Colon)) {</span>
<span class="line-removed">1528         auto semantic = parseSemantic();</span>
<span class="line-removed">1529         if (!semantic)</span>
<span class="line-removed">1530             return Unexpected&lt;Error&gt;(semantic.error());</span>
<span class="line-removed">1531 </span>
<span class="line-removed">1532         if (tryType(Lexer::Token::Type::EqualsSign)) {</span>
<span class="line-removed">1533             auto initializer = parseExpression();</span>
<span class="line-removed">1534             if (!initializer)</span>
<span class="line-removed">1535                 return Unexpected&lt;Error&gt;(initializer.error());</span>
<span class="line-removed">1536             return AST::VariableDeclaration(WTFMove(*origin), WTFMove(qualifiers), { WTFMove(type) }, name-&gt;stringView.toString(), WTFMove(*semantic), WTFMove(*initializer));</span>
<span class="line-removed">1537         }</span>
<span class="line-removed">1538 </span>
<span class="line-removed">1539         return AST::VariableDeclaration(WTFMove(*origin), WTFMove(qualifiers), { WTFMove(type) }, name-&gt;stringView.toString(), WTFMove(*semantic), WTF::nullopt);</span>
<span class="line-removed">1540     }</span>
1541 
<span class="line-modified">1542     if (tryType(Lexer::Token::Type::EqualsSign)) {</span>
<span class="line-modified">1543         auto initializer = parseExpression();</span>
<span class="line-modified">1544         if (!initializer)</span>
<span class="line-modified">1545             return Unexpected&lt;Error&gt;(initializer.error());</span>
<span class="line-removed">1546         return AST::VariableDeclaration(WTFMove(*origin), WTFMove(qualifiers), { WTFMove(type) }, name-&gt;stringView.toString(), WTF::nullopt, WTFMove(*initializer));</span>
1547     }
1548 
<span class="line-modified">1549     return AST::VariableDeclaration(WTFMove(*origin), WTFMove(qualifiers), { WTFMove(type) }, name-&gt;stringView.toString(), WTF::nullopt, WTF::nullopt);</span>

1550 }
1551 
1552 auto Parser::parseVariableDeclarations() -&gt; Expected&lt;AST::VariableDeclarationsStatement, Error&gt;
1553 {
<span class="line-modified">1554     auto origin = peek();</span>
<span class="line-removed">1555     if (!origin)</span>
<span class="line-removed">1556         return Unexpected&lt;Error&gt;(origin.error());</span>
1557 
<span class="line-modified">1558     auto type = parseType();</span>
<span class="line-removed">1559     if (!type)</span>
<span class="line-removed">1560         return Unexpected&lt;Error&gt;(type.error());</span>
1561 
<span class="line-modified">1562     auto firstVariableDeclaration = parseVariableDeclaration((*type)-&gt;clone());</span>
1563     if (!firstVariableDeclaration)
<span class="line-modified">1564         return Unexpected&lt;Error&gt;(firstVariableDeclaration.error());</span>
1565 
<span class="line-modified">1566     Vector&lt;AST::VariableDeclaration&gt; result;</span>
<span class="line-modified">1567     result.append(WTFMove(*firstVariableDeclaration));</span>
1568 
<span class="line-modified">1569     while (tryType(Lexer::Token::Type::Comma)) {</span>
<span class="line-modified">1570         auto variableDeclaration = parseVariableDeclaration((*type)-&gt;clone());</span>
1571         if (!variableDeclaration)
<span class="line-modified">1572             return Unexpected&lt;Error&gt;(variableDeclaration.error());</span>
<span class="line-modified">1573         result.append(WTFMove(*variableDeclaration));</span>
1574     }
1575 
<span class="line-modified">1576     return AST::VariableDeclarationsStatement(WTFMove(*origin), WTFMove(result));</span>

1577 }
1578 
1579 auto Parser::parseStatement() -&gt; Expected&lt;UniqueRef&lt;AST::Statement&gt;, Error&gt;
1580 {
<span class="line-modified">1581     {</span>
<span class="line-modified">1582         auto block = backtrackingScope&lt;Expected&lt;AST::Block, Error&gt;&gt;([&amp;]() {</span>
<span class="line-modified">1583             return parseBlock();</span>
<span class="line-modified">1584         });</span>
<span class="line-modified">1585         if (block)</span>
<span class="line-modified">1586             return { makeUniqueRef&lt;AST::Block&gt;(WTFMove(*block)) };</span>
<span class="line-modified">1587     }</span>
<span class="line-modified">1588 </span>
<span class="line-modified">1589     {</span>
<span class="line-modified">1590         auto ifStatement = backtrackingScope&lt;Expected&lt;AST::IfStatement, Error&gt;&gt;([&amp;]() {</span>
<span class="line-modified">1591             return parseIfStatement();</span>
<span class="line-modified">1592         });</span>
<span class="line-modified">1593         if (ifStatement)</span>
<span class="line-modified">1594             return { makeUniqueRef&lt;AST::IfStatement&gt;(WTFMove(*ifStatement)) };</span>
<span class="line-modified">1595     }</span>
<span class="line-modified">1596 </span>
<span class="line-modified">1597     {</span>
<span class="line-modified">1598         auto switchStatement = backtrackingScope&lt;Expected&lt;AST::SwitchStatement, Error&gt;&gt;([&amp;]() {</span>
<span class="line-modified">1599             return parseSwitchStatement();</span>
<span class="line-modified">1600         });</span>
<span class="line-modified">1601         if (switchStatement)</span>
<span class="line-modified">1602             return { makeUniqueRef&lt;AST::SwitchStatement&gt;(WTFMove(*switchStatement)) };</span>
<span class="line-modified">1603     }</span>
<span class="line-modified">1604 </span>
<span class="line-modified">1605     {</span>
<span class="line-modified">1606         auto forLoop = backtrackingScope&lt;Expected&lt;AST::ForLoop, Error&gt;&gt;([&amp;]() {</span>
<span class="line-modified">1607             return parseForLoop();</span>
<span class="line-modified">1608         });</span>
<span class="line-modified">1609         if (forLoop)</span>
<span class="line-modified">1610             return { makeUniqueRef&lt;AST::ForLoop&gt;(WTFMove(*forLoop)) };</span>
<span class="line-modified">1611     }</span>
<span class="line-modified">1612 </span>
<span class="line-modified">1613     {</span>
<span class="line-modified">1614         auto whileLoop = backtrackingScope&lt;Expected&lt;AST::WhileLoop, Error&gt;&gt;([&amp;]() {</span>
<span class="line-modified">1615             return parseWhileLoop();</span>
<span class="line-modified">1616         });</span>
<span class="line-modified">1617         if (whileLoop)</span>
<span class="line-modified">1618             return { makeUniqueRef&lt;AST::WhileLoop&gt;(WTFMove(*whileLoop)) };</span>
<span class="line-modified">1619     }</span>
<span class="line-modified">1620 </span>
<span class="line-modified">1621     {</span>
<span class="line-modified">1622         auto doWhileLoop = backtrackingScope&lt;Expected&lt;AST::DoWhileLoop, Error&gt;&gt;([&amp;]() -&gt; Expected&lt;AST::DoWhileLoop, Error&gt; {</span>
<span class="line-modified">1623             auto result = parseDoWhileLoop();</span>
<span class="line-modified">1624             if (!result)</span>
<span class="line-modified">1625                 return Unexpected&lt;Error&gt;(result.error());</span>
<span class="line-modified">1626 </span>
<span class="line-modified">1627             auto semicolon = consumeType(Lexer::Token::Type::Semicolon);</span>
<span class="line-modified">1628             if (!semicolon)</span>
<span class="line-modified">1629                 return Unexpected&lt;Error&gt;(semicolon.error());</span>
<span class="line-modified">1630 </span>
<span class="line-modified">1631             return result;</span>
<span class="line-modified">1632         });</span>
<span class="line-modified">1633         if (doWhileLoop)</span>
<span class="line-modified">1634             return { makeUniqueRef&lt;AST::DoWhileLoop&gt;(WTFMove(*doWhileLoop)) };</span>
<span class="line-modified">1635     }</span>
<span class="line-modified">1636 </span>
<span class="line-modified">1637     {</span>
<span class="line-modified">1638         auto breakObject = backtrackingScope&lt;Expected&lt;AST::Break, Error&gt;&gt;([&amp;]() -&gt; Expected&lt;AST::Break, Error&gt; {</span>
<span class="line-modified">1639             auto origin = consumeType(Lexer::Token::Type::Break);</span>
<span class="line-modified">1640             if (!origin)</span>
<span class="line-modified">1641                 return Unexpected&lt;Error&gt;(origin.error());</span>
<span class="line-modified">1642 </span>
<span class="line-modified">1643             auto semicolon = consumeType(Lexer::Token::Type::Semicolon);</span>
<span class="line-modified">1644             if (!semicolon)</span>
<span class="line-modified">1645                 return Unexpected&lt;Error&gt;(semicolon.error());</span>
<span class="line-modified">1646 </span>
<span class="line-modified">1647             return AST::Break(WTFMove(*origin));</span>
<span class="line-modified">1648         });</span>
<span class="line-modified">1649         if (breakObject)</span>
<span class="line-modified">1650             return { makeUniqueRef&lt;AST::Break&gt;(WTFMove(*breakObject)) };</span>
<span class="line-modified">1651     }</span>
<span class="line-modified">1652 </span>
<span class="line-modified">1653     {</span>
<span class="line-modified">1654         auto continueObject = backtrackingScope&lt;Expected&lt;AST::Continue, Error&gt;&gt;([&amp;]() -&gt; Expected&lt;AST::Continue, Error&gt; {</span>
<span class="line-modified">1655             auto origin = consumeType(Lexer::Token::Type::Continue);</span>
<span class="line-modified">1656             if (!origin)</span>
<span class="line-modified">1657                 return Unexpected&lt;Error&gt;(origin.error());</span>
<span class="line-modified">1658 </span>
<span class="line-removed">1659             auto semicolon = consumeType(Lexer::Token::Type::Semicolon);</span>
<span class="line-removed">1660             if (!semicolon)</span>
<span class="line-removed">1661                 return Unexpected&lt;Error&gt;(semicolon.error());</span>
<span class="line-removed">1662 </span>
<span class="line-removed">1663             return AST::Continue(WTFMove(*origin));</span>
<span class="line-removed">1664         });</span>
<span class="line-removed">1665         if (continueObject)</span>
<span class="line-removed">1666             return { makeUniqueRef&lt;AST::Continue&gt;(WTFMove(*continueObject)) };</span>
<span class="line-removed">1667     }</span>
<span class="line-removed">1668 </span>
<span class="line-removed">1669     {</span>
<span class="line-removed">1670         auto fallthroughObject = backtrackingScope&lt;Expected&lt;AST::Fallthrough, Error&gt;&gt;([&amp;]() -&gt; Expected&lt;AST::Fallthrough, Error&gt; {</span>
<span class="line-removed">1671             auto origin = consumeType(Lexer::Token::Type::Fallthrough);</span>
<span class="line-removed">1672             if (!origin)</span>
<span class="line-removed">1673                 return Unexpected&lt;Error&gt;(origin.error());</span>
<span class="line-removed">1674 </span>
<span class="line-removed">1675             auto semicolon = consumeType(Lexer::Token::Type::Semicolon);</span>
<span class="line-removed">1676             if (!semicolon)</span>
<span class="line-removed">1677                 return Unexpected&lt;Error&gt;(semicolon.error());</span>
<span class="line-removed">1678 </span>
<span class="line-removed">1679             return AST::Fallthrough(WTFMove(*origin));</span>
<span class="line-removed">1680         });</span>
<span class="line-removed">1681         if (fallthroughObject)</span>
<span class="line-removed">1682             return { makeUniqueRef&lt;AST::Fallthrough&gt;(WTFMove(*fallthroughObject)) };</span>
<span class="line-removed">1683     }</span>
<span class="line-removed">1684 </span>
<span class="line-removed">1685     {</span>
<span class="line-removed">1686         auto trapObject = backtrackingScope&lt;Expected&lt;AST::Trap, Error&gt;&gt;([&amp;]() -&gt; Expected&lt;AST::Trap, Error&gt; {</span>
<span class="line-removed">1687             auto origin = consumeType(Lexer::Token::Type::Trap);</span>
<span class="line-removed">1688             if (!origin)</span>
<span class="line-removed">1689                 return Unexpected&lt;Error&gt;(origin.error());</span>
<span class="line-removed">1690 </span>
<span class="line-removed">1691             auto semicolon = consumeType(Lexer::Token::Type::Semicolon);</span>
<span class="line-removed">1692             if (!semicolon)</span>
<span class="line-removed">1693                 return Unexpected&lt;Error&gt;(semicolon.error());</span>
<span class="line-removed">1694 </span>
<span class="line-removed">1695             return AST::Trap(WTFMove(*origin));</span>
<span class="line-removed">1696         });</span>
<span class="line-removed">1697         if (trapObject)</span>
<span class="line-removed">1698             return { makeUniqueRef&lt;AST::Trap&gt;(WTFMove(*trapObject)) };</span>
1699     }
<span class="line-modified">1700 </span>
<span class="line-modified">1701     {</span>
<span class="line-removed">1702         auto returnObject = backtrackingScope&lt;Expected&lt;AST::Return, Error&gt;&gt;([&amp;]() -&gt; Expected&lt;AST::Return, Error&gt; {</span>
<span class="line-removed">1703             auto origin = consumeType(Lexer::Token::Type::Return);</span>
<span class="line-removed">1704             if (!origin)</span>
<span class="line-removed">1705                 return Unexpected&lt;Error&gt;(origin.error());</span>
<span class="line-removed">1706 </span>
<span class="line-removed">1707             if (auto semicolon = tryType(Lexer::Token::Type::Semicolon))</span>
<span class="line-removed">1708                 return AST::Return(WTFMove(*origin), WTF::nullopt);</span>
<span class="line-removed">1709 </span>
<span class="line-removed">1710             auto expression = parseExpression();</span>
<span class="line-removed">1711             if (!expression)</span>
<span class="line-removed">1712                 return Unexpected&lt;Error&gt;(expression.error());</span>
<span class="line-removed">1713 </span>
<span class="line-removed">1714             auto semicolon = consumeType(Lexer::Token::Type::Semicolon);</span>
<span class="line-removed">1715             if (!semicolon)</span>
<span class="line-removed">1716                 return Unexpected&lt;Error&gt;(semicolon.error());</span>
<span class="line-removed">1717 </span>
<span class="line-removed">1718             return AST::Return(WTFMove(*origin), { WTFMove(*expression) });</span>
<span class="line-removed">1719         });</span>
<span class="line-removed">1720         if (returnObject)</span>
<span class="line-removed">1721             return { makeUniqueRef&lt;AST::Return&gt;(WTFMove(*returnObject)) };</span>
1722     }
1723 
1724     {
<span class="line-modified">1725         auto variableDeclarations = backtrackingScope&lt;Expected&lt;AST::VariableDeclarationsStatement, Error&gt;&gt;([&amp;]() -&gt; Expected&lt;AST::VariableDeclarationsStatement, Error&gt; {</span>
<span class="line-modified">1726             auto result = parseVariableDeclarations();</span>
<span class="line-modified">1727             if (!result)</span>
<span class="line-removed">1728                 return Unexpected&lt;Error&gt;(result.error());</span>
<span class="line-removed">1729 </span>
<span class="line-removed">1730             auto semicolon = consumeType(Lexer::Token::Type::Semicolon);</span>
<span class="line-removed">1731             if (!semicolon)</span>
<span class="line-removed">1732                 return Unexpected&lt;Error&gt;(semicolon.error());</span>
<span class="line-removed">1733 </span>
1734             return result;
1735         });
<span class="line-modified">1736         if (variableDeclarations)</span>
<span class="line-modified">1737             return { makeUniqueRef&lt;AST::VariableDeclarationsStatement&gt;(WTFMove(*variableDeclarations)) };</span>
1738     }
1739 
<span class="line-modified">1740     auto effectfulExpression = backtrackingScope&lt;Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;&gt;([&amp;]() -&gt; Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt; {</span>
<span class="line-modified">1741         auto result = parseEffectfulExpression();</span>
<span class="line-modified">1742         if (!result)</span>
<span class="line-removed">1743             return Unexpected&lt;Error&gt;(result.error());</span>
<span class="line-removed">1744 </span>
<span class="line-removed">1745         auto semicolon = consumeType(Lexer::Token::Type::Semicolon);</span>
<span class="line-removed">1746         if (!semicolon)</span>
<span class="line-removed">1747             return Unexpected&lt;Error&gt;(semicolon.error());</span>
<span class="line-removed">1748 </span>
<span class="line-removed">1749         return result;</span>
<span class="line-removed">1750     });</span>
<span class="line-removed">1751     if (effectfulExpression)</span>
<span class="line-removed">1752         return { makeUniqueRef&lt;AST::EffectfulExpressionStatement&gt;(WTFMove(*effectfulExpression)) };</span>
<span class="line-removed">1753 </span>
<span class="line-removed">1754     return Unexpected&lt;Error&gt;(effectfulExpression.error());</span>
1755 }
1756 
<span class="line-modified">1757 auto Parser::parseEffectfulExpression() -&gt; Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;</span>
1758 {
<span class="line-modified">1759     auto origin = peek();</span>
<span class="line-modified">1760     if (!origin)</span>
<span class="line-modified">1761         return Unexpected&lt;Error&gt;(origin.error());</span>
1762 
1763     Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; expressions;


1764 
<span class="line-modified">1765     auto first = backtrackingScope&lt;Optional&lt;UniqueRef&lt;AST::Expression&gt;&gt;&gt;([&amp;]() -&gt; Optional&lt;UniqueRef&lt;AST::Expression&gt;&gt; {</span>
<span class="line-modified">1766         auto effectfulExpression = parseEffectfulAssignment();</span>
<span class="line-removed">1767         if (!effectfulExpression)</span>
<span class="line-removed">1768             return WTF::nullopt;</span>
<span class="line-removed">1769         return { WTFMove(*effectfulExpression) };</span>
<span class="line-removed">1770     });</span>
<span class="line-removed">1771     if (!first)</span>
<span class="line-removed">1772         return { makeUniqueRef&lt;AST::CommaExpression&gt;(WTFMove(*origin), WTFMove(expressions)) };</span>
<span class="line-removed">1773 </span>
<span class="line-removed">1774     expressions.append(WTFMove(*first));</span>
<span class="line-removed">1775 </span>
<span class="line-removed">1776     while (tryType(Lexer::Token::Type::Comma)) {</span>
<span class="line-removed">1777         auto expression = parseEffectfulAssignment();</span>
<span class="line-removed">1778         if (!expression)</span>
<span class="line-removed">1779             return Unexpected&lt;Error&gt;(expression.error());</span>
1780         expressions.append(WTFMove(*expression));
1781     }
1782 
1783     if (expressions.size() == 1)
<span class="line-modified">1784         return WTFMove(expressions[0]);</span>
<span class="line-modified">1785     return { makeUniqueRef&lt;AST::CommaExpression&gt;(WTFMove(*origin), WTFMove(expressions)) };</span>



1786 }
1787 
1788 auto Parser::parseEffectfulAssignment() -&gt; Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;
1789 {
<span class="line-modified">1790     auto assignment = backtrackingScope&lt;Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;&gt;([&amp;]() {</span>
<span class="line-removed">1791         return parseAssignment();</span>
<span class="line-removed">1792     });</span>
<span class="line-removed">1793     if (assignment)</span>
<span class="line-removed">1794         return assignment;</span>
1795 
<span class="line-modified">1796     assignment = backtrackingScope&lt;Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;&gt;([&amp;]() {</span>
<span class="line-modified">1797         return parseEffectfulPrefix();</span>
<span class="line-removed">1798     });</span>
<span class="line-removed">1799     if (assignment)</span>
<span class="line-removed">1800         return assignment;</span>
<span class="line-removed">1801 </span>
<span class="line-removed">1802     assignment = backtrackingScope&lt;Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;&gt;([&amp;]() {</span>
<span class="line-removed">1803         return parseCallExpression();</span>
<span class="line-removed">1804     });</span>
<span class="line-removed">1805     if (assignment)</span>
<span class="line-removed">1806         return assignment;</span>
1807 
<span class="line-modified">1808     return Unexpected&lt;Error&gt;(assignment.error());</span>
<span class="line-modified">1809 }</span>
<span class="line-modified">1810 </span>
<span class="line-modified">1811 auto Parser::parseEffectfulPrefix() -&gt; Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;</span>
<span class="line-modified">1812 {</span>
<span class="line-modified">1813     auto prefix = consumeTypes({ Lexer::Token::Type::PlusPlus, Lexer::Token::Type::MinusMinus });</span>
<span class="line-modified">1814     if (!prefix)</span>
<span class="line-modified">1815         return Unexpected&lt;Error&gt;(prefix.error());</span>
<span class="line-modified">1816 </span>
<span class="line-modified">1817     auto previous = parsePossiblePrefix();</span>
<span class="line-modified">1818     if (!previous)</span>
<span class="line-modified">1819         return Unexpected&lt;Error&gt;(previous.error());</span>
<span class="line-modified">1820 </span>
<span class="line-modified">1821     switch (prefix-&gt;type) {</span>
<span class="line-removed">1822     case Lexer::Token::Type::PlusPlus: {</span>
<span class="line-removed">1823         auto result = AST::ReadModifyWriteExpression::create(Lexer::Token(*prefix), WTFMove(*previous));</span>
<span class="line-removed">1824         Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; callArguments;</span>
<span class="line-removed">1825         callArguments.append(result-&gt;oldVariableReference());</span>
<span class="line-removed">1826         result-&gt;setNewValueExpression(makeUniqueRef&lt;AST::CallExpression&gt;(WTFMove(*prefix), &quot;operator++&quot;_str, WTFMove(callArguments)));</span>
<span class="line-removed">1827         result-&gt;setResultExpression(result-&gt;newVariableReference());</span>
<span class="line-removed">1828         return { WTFMove(result) };</span>
1829     }
<span class="line-removed">1830     default: {</span>
<span class="line-removed">1831         ASSERT(prefix-&gt;type == Lexer::Token::Type::MinusMinus);</span>
<span class="line-removed">1832         auto result = AST::ReadModifyWriteExpression::create(Lexer::Token(*prefix), WTFMove(*previous));</span>
<span class="line-removed">1833         Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; callArguments;</span>
<span class="line-removed">1834         callArguments.append(result-&gt;oldVariableReference());</span>
<span class="line-removed">1835         result-&gt;setNewValueExpression(makeUniqueRef&lt;AST::CallExpression&gt;(WTFMove(*prefix), &quot;operator--&quot;_str, WTFMove(callArguments)));</span>
<span class="line-removed">1836         result-&gt;setResultExpression(result-&gt;newVariableReference());</span>
<span class="line-removed">1837         return { WTFMove(result) };</span>
<span class="line-removed">1838     }</span>
<span class="line-removed">1839     }</span>
<span class="line-removed">1840 }</span>
1841 
<span class="line-modified">1842 auto Parser::parseEffectfulSuffix() -&gt; Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;</span>
<span class="line-removed">1843 {</span>
<span class="line-removed">1844     auto effectfulSuffix = backtrackingScope&lt;Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;&gt;([&amp;]() -&gt; Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt; {</span>
<span class="line-removed">1845         auto previous = parsePossibleSuffix();</span>
<span class="line-removed">1846         if (!previous)</span>
<span class="line-removed">1847             return Unexpected&lt;Error&gt;(previous.error());</span>
<span class="line-removed">1848 </span>
<span class="line-removed">1849         auto suffix = consumeTypes({ Lexer::Token::Type::PlusPlus, Lexer::Token::Type::MinusMinus });</span>
<span class="line-removed">1850         if (!suffix)</span>
<span class="line-removed">1851             return Unexpected&lt;Error&gt;(suffix.error());</span>
<span class="line-removed">1852 </span>
<span class="line-removed">1853         switch (suffix-&gt;type) {</span>
<span class="line-removed">1854         case Lexer::Token::Type::PlusPlus: {</span>
<span class="line-removed">1855             auto result = AST::ReadModifyWriteExpression::create(Lexer::Token(*suffix), WTFMove(*previous));</span>
<span class="line-removed">1856             Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; callArguments;</span>
<span class="line-removed">1857             callArguments.append(result-&gt;oldVariableReference());</span>
<span class="line-removed">1858             result-&gt;setNewValueExpression(makeUniqueRef&lt;AST::CallExpression&gt;(WTFMove(*suffix), &quot;operator++&quot;_str, WTFMove(callArguments)));</span>
<span class="line-removed">1859             result-&gt;setResultExpression(result-&gt;oldVariableReference());</span>
<span class="line-removed">1860             return { WTFMove(result) };</span>
<span class="line-removed">1861         }</span>
<span class="line-removed">1862         default: {</span>
<span class="line-removed">1863             ASSERT(suffix-&gt;type == Lexer::Token::Type::MinusMinus);</span>
<span class="line-removed">1864             auto result = AST::ReadModifyWriteExpression::create(Lexer::Token(*suffix), WTFMove(*previous));</span>
<span class="line-removed">1865             Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; callArguments;</span>
<span class="line-removed">1866             callArguments.append(result-&gt;oldVariableReference());</span>
<span class="line-removed">1867             result-&gt;setNewValueExpression(makeUniqueRef&lt;AST::CallExpression&gt;(WTFMove(*suffix), &quot;operator--&quot;_str, WTFMove(callArguments)));</span>
<span class="line-removed">1868             result-&gt;setResultExpression(result-&gt;oldVariableReference());</span>
<span class="line-removed">1869             return { WTFMove(result) };</span>
<span class="line-removed">1870         }</span>
<span class="line-removed">1871         }</span>
<span class="line-removed">1872     });</span>
<span class="line-removed">1873     if (effectfulSuffix)</span>
<span class="line-removed">1874         return effectfulSuffix;</span>
<span class="line-removed">1875 </span>
<span class="line-removed">1876     effectfulSuffix = backtrackingScope&lt;Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;&gt;([&amp;]() {</span>
<span class="line-removed">1877         return parseCallExpression();</span>
<span class="line-removed">1878     });</span>
<span class="line-removed">1879     if (effectfulSuffix)</span>
<span class="line-removed">1880         return effectfulSuffix;</span>
<span class="line-removed">1881 </span>
<span class="line-removed">1882     effectfulSuffix = backtrackingScope&lt;Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;&gt;([&amp;]() -&gt; Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt; {</span>
<span class="line-removed">1883         auto leftParenthesis = consumeType(Lexer::Token::Type::LeftParenthesis);</span>
<span class="line-removed">1884         if (!leftParenthesis)</span>
<span class="line-removed">1885             return Unexpected&lt;Error&gt;(leftParenthesis.error());</span>
<span class="line-removed">1886 </span>
<span class="line-removed">1887         auto expression = parseExpression();</span>
<span class="line-removed">1888         if (!expression)</span>
<span class="line-removed">1889             return Unexpected&lt;Error&gt;(expression.error());</span>
<span class="line-removed">1890 </span>
<span class="line-removed">1891         auto rightParenthesis = consumeType(Lexer::Token::Type::RightParenthesis);</span>
<span class="line-removed">1892         if (!rightParenthesis)</span>
<span class="line-removed">1893             return Unexpected&lt;Error&gt;(rightParenthesis.error());</span>
<span class="line-removed">1894 </span>
<span class="line-removed">1895         return { WTFMove(*expression) };</span>
<span class="line-removed">1896     });</span>
<span class="line-removed">1897     if (effectfulSuffix)</span>
<span class="line-removed">1898         return effectfulSuffix;</span>
<span class="line-removed">1899 </span>
<span class="line-removed">1900     return Unexpected&lt;Error&gt;(effectfulSuffix.error());</span>
1901 }
1902 
1903 auto Parser::parseLimitedSuffixOperator(UniqueRef&lt;AST::Expression&gt;&amp;&amp; previous) -&gt; SuffixExpression
1904 {
<span class="line-modified">1905     auto type = consumeTypes({ Lexer::Token::Type::FullStop, Lexer::Token::Type::Arrow, Lexer::Token::Type::LeftSquareBracket });</span>



1906     if (!type)
1907         return SuffixExpression(WTFMove(previous), false);
1908 
1909     switch (type-&gt;type) {
<span class="line-modified">1910     case Lexer::Token::Type::FullStop: {</span>
<span class="line-modified">1911         auto identifier = consumeType(Lexer::Token::Type::Identifier);</span>
1912         if (!identifier)
1913             return SuffixExpression(WTFMove(previous), false);
<span class="line-modified">1914         return SuffixExpression(makeUniqueRef&lt;AST::DotExpression&gt;(WTFMove(*type), WTFMove(previous), identifier-&gt;stringView.toString()), true);</span>

1915     }
<span class="line-modified">1916     case Lexer::Token::Type::Arrow: {</span>
<span class="line-modified">1917         auto identifier = consumeType(Lexer::Token::Type::Identifier);</span>
1918         if (!identifier)
1919             return SuffixExpression(WTFMove(previous), false);
<span class="line-modified">1920         return SuffixExpression(makeUniqueRef&lt;AST::DotExpression&gt;(Lexer::Token(*type), makeUniqueRef&lt;AST::DereferenceExpression&gt;(WTFMove(*type), WTFMove(previous)), identifier-&gt;stringView.toString()), true);</span>

1921     }
1922     default: {
<span class="line-modified">1923         ASSERT(type-&gt;type == Lexer::Token::Type::LeftSquareBracket);</span>
1924         auto expression = parseExpression();
1925         if (!expression)
1926             return SuffixExpression(WTFMove(previous), false);
<span class="line-modified">1927         if (!consumeType(Lexer::Token::Type::RightSquareBracket))</span>
<span class="line-modified">1928             return SuffixExpression(WTFMove(previous), false);</span>
<span class="line-modified">1929         return SuffixExpression(makeUniqueRef&lt;AST::IndexExpression&gt;(WTFMove(*type), WTFMove(previous), WTFMove(*expression)), true);</span>


1930     }
1931     }
1932 }
1933 
1934 auto Parser::parseSuffixOperator(UniqueRef&lt;AST::Expression&gt;&amp;&amp; previous) -&gt; SuffixExpression
1935 {
<span class="line-modified">1936     auto suffix = consumeTypes({ Lexer::Token::Type::FullStop, Lexer::Token::Type::Arrow, Lexer::Token::Type::LeftSquareBracket, Lexer::Token::Type::PlusPlus, Lexer::Token::Type::MinusMinus });</span>





1937     if (!suffix)
1938         return SuffixExpression(WTFMove(previous), false);
1939 
1940     switch (suffix-&gt;type) {
<span class="line-modified">1941     case Lexer::Token::Type::FullStop: {</span>
<span class="line-modified">1942         auto identifier = consumeType(Lexer::Token::Type::Identifier);</span>
1943         if (!identifier)
1944             return SuffixExpression(WTFMove(previous), false);
<span class="line-modified">1945         return SuffixExpression(makeUniqueRef&lt;AST::DotExpression&gt;(WTFMove(*suffix), WTFMove(previous), identifier-&gt;stringView.toString()), true);</span>

1946     }
<span class="line-modified">1947     case Lexer::Token::Type::Arrow: {</span>
<span class="line-modified">1948         auto identifier = consumeType(Lexer::Token::Type::Identifier);</span>
1949         if (!identifier)
1950             return SuffixExpression(WTFMove(previous), false);
<span class="line-modified">1951         return SuffixExpression(makeUniqueRef&lt;AST::DotExpression&gt;(Lexer::Token(*suffix), makeUniqueRef&lt;AST::DereferenceExpression&gt;(WTFMove(*suffix), WTFMove(previous)), identifier-&gt;stringView.toString()), true);</span>

1952     }
<span class="line-modified">1953     case Lexer::Token::Type::LeftSquareBracket: {</span>
1954         auto expression = parseExpression();
1955         if (!expression)
1956             return SuffixExpression(WTFMove(previous), false);
<span class="line-modified">1957         if (!consumeType(Lexer::Token::Type::RightSquareBracket))</span>
<span class="line-modified">1958             return SuffixExpression(WTFMove(previous), false);</span>
<span class="line-modified">1959         return SuffixExpression(makeUniqueRef&lt;AST::IndexExpression&gt;(WTFMove(*suffix), WTFMove(previous), WTFMove(*expression)), true);</span>


1960     }
<span class="line-modified">1961     case Lexer::Token::Type::PlusPlus: {</span>
<span class="line-modified">1962         auto result = AST::ReadModifyWriteExpression::create(Lexer::Token(*suffix), WTFMove(previous));</span>

1963         Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; callArguments;
1964         callArguments.append(result-&gt;oldVariableReference());
<span class="line-modified">1965         result-&gt;setNewValueExpression(makeUniqueRef&lt;AST::CallExpression&gt;(WTFMove(*suffix), &quot;operator++&quot;_str, WTFMove(callArguments)));</span>
1966         result-&gt;setResultExpression(result-&gt;oldVariableReference());
1967         return SuffixExpression(WTFMove(result), true);
1968     }
1969     default: {
<span class="line-modified">1970         ASSERT(suffix-&gt;type == Lexer::Token::Type::MinusMinus);</span>
<span class="line-modified">1971         auto result = AST::ReadModifyWriteExpression::create(Lexer::Token(*suffix), WTFMove(previous));</span>

1972         Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; callArguments;
1973         callArguments.append(result-&gt;oldVariableReference());
<span class="line-modified">1974         result-&gt;setNewValueExpression(makeUniqueRef&lt;AST::CallExpression&gt;(WTFMove(*suffix), &quot;operator--&quot;_str, WTFMove(callArguments)));</span>
1975         result-&gt;setResultExpression(result-&gt;oldVariableReference());
1976         return SuffixExpression(WTFMove(result), true);
1977     }
1978     }
1979 }
1980 
1981 auto Parser::parseExpression() -&gt; Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;
1982 {
<span class="line-modified">1983     auto origin = peek();</span>
<span class="line-removed">1984     if (!origin)</span>
<span class="line-removed">1985         return Unexpected&lt;Error&gt;(origin.error());</span>
<span class="line-removed">1986 </span>
<span class="line-removed">1987     auto first = parsePossibleTernaryConditional();</span>
<span class="line-removed">1988     if (!first)</span>
<span class="line-removed">1989         return Unexpected&lt;Error&gt;(first.error());</span>
<span class="line-removed">1990 </span>
1991     Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; expressions;

1992     expressions.append(WTFMove(*first));
1993 
<span class="line-modified">1994     while (tryType(Lexer::Token::Type::Comma)) {</span>
<span class="line-modified">1995         auto expression = parsePossibleTernaryConditional();</span>
<span class="line-removed">1996         if (!expression)</span>
<span class="line-removed">1997             return Unexpected&lt;Error&gt;(expression.error());</span>
1998         expressions.append(WTFMove(*expression));
1999     }
2000 
2001     if (expressions.size() == 1)
2002         return WTFMove(expressions[0]);
<span class="line-modified">2003     return { makeUniqueRef&lt;AST::CommaExpression&gt;(WTFMove(*origin), WTFMove(expressions)) };</span>


2004 }
2005 
<span class="line-modified">2006 auto Parser::parseTernaryConditional() -&gt; Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;</span>
2007 {
<span class="line-modified">2008     auto origin = peek();</span>
<span class="line-modified">2009     if (!origin)</span>
<span class="line-modified">2010         return Unexpected&lt;Error&gt;(origin.error());</span>
<span class="line-modified">2011 </span>
<span class="line-removed">2012     auto predicate = parsePossibleLogicalBinaryOperation();</span>
<span class="line-removed">2013     if (!predicate)</span>
<span class="line-removed">2014         return Unexpected&lt;Error&gt;(predicate.error());</span>
<span class="line-removed">2015 </span>
<span class="line-removed">2016     auto questionMark = consumeType(Lexer::Token::Type::QuestionMark);</span>
<span class="line-removed">2017     if (!questionMark)</span>
<span class="line-removed">2018         return Unexpected&lt;Error&gt;(questionMark.error());</span>
<span class="line-removed">2019 </span>
<span class="line-removed">2020     auto bodyExpression = parseExpression();</span>
<span class="line-removed">2021     if (!bodyExpression)</span>
<span class="line-removed">2022         return Unexpected&lt;Error&gt;(bodyExpression.error());</span>
<span class="line-removed">2023 </span>
<span class="line-removed">2024     auto colon = consumeType(Lexer::Token::Type::Colon);</span>
<span class="line-removed">2025     if (!colon)</span>
<span class="line-removed">2026         return Unexpected&lt;Error&gt;(colon.error());</span>
<span class="line-removed">2027 </span>
<span class="line-removed">2028     auto elseExpression = parsePossibleTernaryConditional();</span>
<span class="line-removed">2029     if (!elseExpression)</span>
<span class="line-removed">2030         return Unexpected&lt;Error&gt;(elseExpression.error());</span>
2031 

2032     Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; castArguments;
<span class="line-modified">2033     castArguments.append(WTFMove(*predicate));</span>
<span class="line-modified">2034     auto boolCast = makeUniqueRef&lt;AST::CallExpression&gt;(Lexer::Token(*origin), &quot;bool&quot;_str, WTFMove(castArguments));</span>
<span class="line-modified">2035     return { makeUniqueRef&lt;AST::TernaryExpression&gt;(WTFMove(*origin), WTFMove(boolCast), WTFMove(*bodyExpression), WTFMove(*elseExpression)) };</span>
<span class="line-modified">2036 }</span>
<span class="line-modified">2037 </span>
<span class="line-modified">2038 auto Parser::parseAssignment() -&gt; Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;</span>
<span class="line-modified">2039 {</span>
<span class="line-modified">2040     auto origin = peek();</span>
<span class="line-modified">2041     if (!origin)</span>
<span class="line-modified">2042         return Unexpected&lt;Error&gt;(origin.error());</span>
<span class="line-modified">2043 </span>
<span class="line-modified">2044     auto left = parsePossiblePrefix();</span>
<span class="line-modified">2045     if (!left)</span>
<span class="line-modified">2046         return Unexpected&lt;Error&gt;(left.error());</span>
<span class="line-modified">2047 </span>
<span class="line-modified">2048     auto assignmentOperator = consumeTypes({</span>
<span class="line-modified">2049         Lexer::Token::Type::EqualsSign,</span>
<span class="line-modified">2050         Lexer::Token::Type::PlusEquals,</span>
<span class="line-modified">2051         Lexer::Token::Type::MinusEquals,</span>
<span class="line-modified">2052         Lexer::Token::Type::TimesEquals,</span>
<span class="line-removed">2053         Lexer::Token::Type::DivideEquals,</span>
<span class="line-removed">2054         Lexer::Token::Type::ModEquals,</span>
<span class="line-removed">2055         Lexer::Token::Type::XorEquals,</span>
<span class="line-removed">2056         Lexer::Token::Type::AndEquals,</span>
<span class="line-removed">2057         Lexer::Token::Type::OrEquals,</span>
<span class="line-removed">2058         Lexer::Token::Type::RightShiftEquals,</span>
<span class="line-removed">2059         Lexer::Token::Type::LeftShiftEquals</span>
<span class="line-removed">2060     });</span>
2061     if (!assignmentOperator)
<span class="line-modified">2062         return Unexpected&lt;Error&gt;(assignmentOperator.error());</span>
2063 
<span class="line-modified">2064     auto right = parsePossibleTernaryConditional();</span>
<span class="line-modified">2065     if (!right)</span>
<span class="line-removed">2066         return Unexpected&lt;Error&gt;(right.error());</span>
2067 
<span class="line-modified">2068     if (assignmentOperator-&gt;type == Lexer::Token::Type::EqualsSign)</span>
<span class="line-modified">2069         return { makeUniqueRef&lt;AST::AssignmentExpression&gt;(WTFMove(*origin), WTFMove(*left), WTFMove(*right))};</span>
2070 
2071     String name;
2072     switch (assignmentOperator-&gt;type) {
<span class="line-modified">2073     case Lexer::Token::Type::PlusEquals:</span>
2074         name = &quot;operator+&quot;_str;
2075         break;
<span class="line-modified">2076     case Lexer::Token::Type::MinusEquals:</span>
2077         name = &quot;operator-&quot;_str;
2078         break;
<span class="line-modified">2079     case Lexer::Token::Type::TimesEquals:</span>
2080         name = &quot;operator*&quot;_str;
2081         break;
<span class="line-modified">2082     case Lexer::Token::Type::DivideEquals:</span>
2083         name = &quot;operator/&quot;_str;
2084         break;
<span class="line-modified">2085     case Lexer::Token::Type::ModEquals:</span>
2086         name = &quot;operator%&quot;_str;
2087         break;
<span class="line-modified">2088     case Lexer::Token::Type::XorEquals:</span>
2089         name = &quot;operator^&quot;_str;
2090         break;
<span class="line-modified">2091     case Lexer::Token::Type::AndEquals:</span>
2092         name = &quot;operator&amp;&quot;_str;
2093         break;
<span class="line-modified">2094     case Lexer::Token::Type::OrEquals:</span>
2095         name = &quot;operator|&quot;_str;
2096         break;
<span class="line-modified">2097     case Lexer::Token::Type::RightShiftEquals:</span>
2098         name = &quot;operator&gt;&gt;&quot;_str;
2099         break;
2100     default:
<span class="line-modified">2101         ASSERT(assignmentOperator-&gt;type == Lexer::Token::Type::LeftShiftEquals);</span>
2102         name = &quot;operator&lt;&lt;&quot;_str;
2103         break;
2104     }
2105 
<span class="line-modified">2106     auto result = AST::ReadModifyWriteExpression::create(Lexer::Token(*origin), WTFMove(*left));</span>
2107     Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; callArguments;
2108     callArguments.append(result-&gt;oldVariableReference());
2109     callArguments.append(WTFMove(*right));
<span class="line-modified">2110     result-&gt;setNewValueExpression(makeUniqueRef&lt;AST::CallExpression&gt;(WTFMove(*origin), WTFMove(name), WTFMove(callArguments)));</span>
2111     result-&gt;setResultExpression(result-&gt;newVariableReference());
2112     return { WTFMove(result) };
2113 }
2114 
2115 auto Parser::parsePossibleTernaryConditional() -&gt; Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;
2116 {
<span class="line-modified">2117     auto ternaryExpression = backtrackingScope&lt;Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;&gt;([&amp;]() {</span>
<span class="line-removed">2118         return parseTernaryConditional();</span>
<span class="line-removed">2119     });</span>
<span class="line-removed">2120     if (ternaryExpression)</span>
<span class="line-removed">2121         return ternaryExpression;</span>
2122 
<span class="line-modified">2123     auto assignmentExpression = backtrackingScope&lt;Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;&gt;([&amp;]() {</span>
<span class="line-modified">2124         return parseAssignment();</span>
<span class="line-modified">2125     });</span>
<span class="line-modified">2126     if (assignmentExpression)</span>
<span class="line-modified">2127         return assignmentExpression;</span>








2128 
<span class="line-modified">2129     auto binaryOperation = backtrackingScope&lt;Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;&gt;([&amp;]() {</span>
<span class="line-modified">2130         return parsePossibleLogicalBinaryOperation();</span>
<span class="line-modified">2131     });</span>
<span class="line-modified">2132     if (binaryOperation)</span>
<span class="line-modified">2133         return binaryOperation;</span>










2134 
<span class="line-modified">2135     return Unexpected&lt;Error&gt;(binaryOperation.error());</span>







2136 }
2137 
2138 auto Parser::parsePossibleLogicalBinaryOperation() -&gt; Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;
2139 {
<span class="line-modified">2140     auto parsedPrevious = parsePossibleRelationalBinaryOperation();</span>
<span class="line-modified">2141     if (!parsedPrevious)</span>
<span class="line-modified">2142         return Unexpected&lt;Error&gt;(parsedPrevious.error());</span>
<span class="line-modified">2143     UniqueRef&lt;AST::Expression&gt; previous = WTFMove(*parsedPrevious);</span>
<span class="line-modified">2144 </span>
<span class="line-modified">2145     while (auto logicalBinaryOperation = tryTypes({</span>
<span class="line-modified">2146         Lexer::Token::Type::OrOr,</span>
<span class="line-modified">2147         Lexer::Token::Type::AndAnd,</span>
<span class="line-modified">2148         Lexer::Token::Type::Or,</span>
<span class="line-modified">2149         Lexer::Token::Type::Xor,</span>
<span class="line-modified">2150         Lexer::Token::Type::And</span>
<span class="line-modified">2151         })) {</span>
<span class="line-modified">2152         auto next = parsePossibleRelationalBinaryOperation();</span>
<span class="line-modified">2153         if (!next)</span>
<span class="line-modified">2154             return Unexpected&lt;Error&gt;(next.error());</span>
2155 
2156         switch (logicalBinaryOperation-&gt;type) {
<span class="line-modified">2157         case Lexer::Token::Type::OrOr:</span>
<span class="line-modified">2158             previous = makeUniqueRef&lt;AST::LogicalExpression&gt;(WTFMove(*logicalBinaryOperation), AST::LogicalExpression::Type::Or, WTFMove(previous), WTFMove(*next));</span>
2159             break;
<span class="line-modified">2160         case Lexer::Token::Type::AndAnd:</span>
<span class="line-modified">2161             previous = makeUniqueRef&lt;AST::LogicalExpression&gt;(WTFMove(*logicalBinaryOperation), AST::LogicalExpression::Type::And, WTFMove(previous), WTFMove(*next));</span>
2162             break;
<span class="line-modified">2163         case Lexer::Token::Type::Or: {</span>
2164             Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; callArguments;
2165             callArguments.append(WTFMove(previous));
2166             callArguments.append(WTFMove(*next));
<span class="line-modified">2167             previous = makeUniqueRef&lt;AST::CallExpression&gt;(WTFMove(*logicalBinaryOperation), &quot;operator|&quot;_str, WTFMove(callArguments));</span>
2168             break;
2169         }
<span class="line-modified">2170         case Lexer::Token::Type::Xor: {</span>
2171             Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; callArguments;
2172             callArguments.append(WTFMove(previous));
2173             callArguments.append(WTFMove(*next));
<span class="line-modified">2174             previous = makeUniqueRef&lt;AST::CallExpression&gt;(WTFMove(*logicalBinaryOperation), &quot;operator^&quot;_str, WTFMove(callArguments));</span>
2175             break;
2176         }
2177         default: {
<span class="line-modified">2178             ASSERT(logicalBinaryOperation-&gt;type == Lexer::Token::Type::And);</span>
2179             Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; callArguments;
2180             callArguments.append(WTFMove(previous));
2181             callArguments.append(WTFMove(*next));
<span class="line-modified">2182             previous = makeUniqueRef&lt;AST::CallExpression&gt;(WTFMove(*logicalBinaryOperation), &quot;operator&amp;&quot;_str, WTFMove(callArguments));</span>
2183             break;
2184         }
2185         }
2186     }
2187 
2188     return { WTFMove(previous) };
2189 }
2190 
2191 auto Parser::parsePossibleRelationalBinaryOperation() -&gt; Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;
2192 {
<span class="line-modified">2193     auto parsedPrevious = parsePossibleShift();</span>
<span class="line-modified">2194     if (!parsedPrevious)</span>
<span class="line-modified">2195         return Unexpected&lt;Error&gt;(parsedPrevious.error());</span>
<span class="line-modified">2196     UniqueRef&lt;AST::Expression&gt; previous = WTFMove(*parsedPrevious);</span>
<span class="line-modified">2197 </span>
<span class="line-modified">2198     while (auto relationalBinaryOperation = tryTypes({</span>
<span class="line-modified">2199         Lexer::Token::Type::LessThanSign,</span>
<span class="line-modified">2200         Lexer::Token::Type::GreaterThanSign,</span>
<span class="line-modified">2201         Lexer::Token::Type::LessThanOrEqualTo,</span>
<span class="line-modified">2202         Lexer::Token::Type::GreaterThanOrEqualTo,</span>
<span class="line-modified">2203         Lexer::Token::Type::EqualComparison,</span>
<span class="line-modified">2204         Lexer::Token::Type::NotEqual</span>
<span class="line-modified">2205         })) {</span>
<span class="line-modified">2206         auto next = parsePossibleShift();</span>
<span class="line-modified">2207         if (!next)</span>
<span class="line-modified">2208             return Unexpected&lt;Error&gt;(next.error());</span>




2209 
2210         switch (relationalBinaryOperation-&gt;type) {
<span class="line-modified">2211         case Lexer::Token::Type::LessThanSign: {</span>
<span class="line-modified">2212             Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; callArguments;</span>
<span class="line-removed">2213             callArguments.append(WTFMove(previous));</span>
<span class="line-removed">2214             callArguments.append(WTFMove(*next));</span>
<span class="line-removed">2215             previous = makeUniqueRef&lt;AST::CallExpression&gt;(WTFMove(*relationalBinaryOperation), &quot;operator&lt;&quot;_str, WTFMove(callArguments));</span>
2216             break;
2217         }
<span class="line-modified">2218         case Lexer::Token::Type::GreaterThanSign: {</span>
<span class="line-modified">2219             Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; callArguments;</span>
<span class="line-removed">2220             callArguments.append(WTFMove(previous));</span>
<span class="line-removed">2221             callArguments.append(WTFMove(*next));</span>
<span class="line-removed">2222             previous = makeUniqueRef&lt;AST::CallExpression&gt;(WTFMove(*relationalBinaryOperation), &quot;operator&gt;&quot;_str, WTFMove(callArguments));</span>
2223             break;
2224         }
<span class="line-modified">2225         case Lexer::Token::Type::LessThanOrEqualTo: {</span>
<span class="line-modified">2226             Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; callArguments;</span>
<span class="line-removed">2227             callArguments.append(WTFMove(previous));</span>
<span class="line-removed">2228             callArguments.append(WTFMove(*next));</span>
<span class="line-removed">2229             previous = makeUniqueRef&lt;AST::CallExpression&gt;(WTFMove(*relationalBinaryOperation), &quot;operator&lt;=&quot;_str, WTFMove(callArguments));</span>
2230             break;
2231         }
<span class="line-modified">2232         case Lexer::Token::Type::GreaterThanOrEqualTo: {</span>
<span class="line-modified">2233             Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; callArguments;</span>
<span class="line-removed">2234             callArguments.append(WTFMove(previous));</span>
<span class="line-removed">2235             callArguments.append(WTFMove(*next));</span>
<span class="line-removed">2236             previous = makeUniqueRef&lt;AST::CallExpression&gt;(WTFMove(*relationalBinaryOperation), &quot;operator&gt;=&quot;_str, WTFMove(callArguments));</span>
2237             break;
2238         }
<span class="line-modified">2239         case Lexer::Token::Type::EqualComparison: {</span>
<span class="line-modified">2240             Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; callArguments;</span>
<span class="line-removed">2241             callArguments.append(WTFMove(previous));</span>
<span class="line-removed">2242             callArguments.append(WTFMove(*next));</span>
<span class="line-removed">2243             previous = makeUniqueRef&lt;AST::CallExpression&gt;(WTFMove(*relationalBinaryOperation), &quot;operator==&quot;_str, WTFMove(callArguments));</span>
2244             break;
2245         }
2246         default: {
<span class="line-modified">2247             ASSERT(relationalBinaryOperation-&gt;type == Lexer::Token::Type::NotEqual);</span>
<span class="line-modified">2248             Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; callArguments;</span>
<span class="line-modified">2249             callArguments.append(WTFMove(previous));</span>
<span class="line-removed">2250             callArguments.append(WTFMove(*next));</span>
<span class="line-removed">2251             previous = makeUniqueRef&lt;AST::CallExpression&gt;(Lexer::Token(*relationalBinaryOperation), &quot;operator==&quot;_str, WTFMove(callArguments));</span>
<span class="line-removed">2252             previous = makeUniqueRef&lt;AST::LogicalNotExpression&gt;(WTFMove(*relationalBinaryOperation), WTFMove(previous));</span>
2253             break;
2254         }
2255         }
2256     }
2257 
2258     return WTFMove(previous);
2259 }
2260 
2261 auto Parser::parsePossibleShift() -&gt; Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;
2262 {
<span class="line-modified">2263     auto parsedPrevious = parsePossibleAdd();</span>
<span class="line-modified">2264     if (!parsedPrevious)</span>
<span class="line-modified">2265         return Unexpected&lt;Error&gt;(parsedPrevious.error());</span>
<span class="line-modified">2266     UniqueRef&lt;AST::Expression&gt; previous = WTFMove(*parsedPrevious);</span>








2267 
<span class="line-modified">2268     while (auto shift = tryTypes({</span>
<span class="line-modified">2269         Lexer::Token::Type::LeftShift,</span>
<span class="line-modified">2270         Lexer::Token::Type::RightShift</span>
<span class="line-removed">2271         })) {</span>
<span class="line-removed">2272         auto next = parsePossibleAdd();</span>
<span class="line-removed">2273         if (!next)</span>
<span class="line-removed">2274             return Unexpected&lt;Error&gt;(next.error());</span>
2275 
2276         switch (shift-&gt;type) {
<span class="line-modified">2277         case Lexer::Token::Type::LeftShift: {</span>
<span class="line-modified">2278             Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; callArguments;</span>
<span class="line-removed">2279             callArguments.append(WTFMove(previous));</span>
<span class="line-removed">2280             callArguments.append(WTFMove(*next));</span>
<span class="line-removed">2281             previous = makeUniqueRef&lt;AST::CallExpression&gt;(WTFMove(*shift), &quot;operator&lt;&lt;&quot;_str, WTFMove(callArguments));</span>
2282             break;
2283         }
2284         default: {
<span class="line-modified">2285             ASSERT(shift-&gt;type == Lexer::Token::Type::RightShift);</span>
<span class="line-modified">2286             Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; callArguments;</span>
<span class="line-removed">2287             callArguments.append(WTFMove(previous));</span>
<span class="line-removed">2288             callArguments.append(WTFMove(*next));</span>
<span class="line-removed">2289             previous = makeUniqueRef&lt;AST::CallExpression&gt;(WTFMove(*shift), &quot;operator&gt;&gt;&quot;_str, WTFMove(callArguments));</span>
2290             break;
2291         }
2292         }
2293     }
2294 
2295     return WTFMove(previous);
2296 }
2297 
2298 auto Parser::parsePossibleAdd() -&gt; Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;
2299 {
<span class="line-modified">2300     auto parsedPrevious = parsePossibleMultiply();</span>
<span class="line-modified">2301     if (!parsedPrevious)</span>
<span class="line-modified">2302         return Unexpected&lt;Error&gt;(parsedPrevious.error());</span>
<span class="line-removed">2303     UniqueRef&lt;AST::Expression&gt; previous = WTFMove(*parsedPrevious);</span>
2304 
<span class="line-modified">2305     while (auto add = tryTypes({</span>
<span class="line-modified">2306         Lexer::Token::Type::Plus,</span>
<span class="line-modified">2307         Lexer::Token::Type::Minus</span>
<span class="line-modified">2308         })) {</span>
<span class="line-modified">2309         auto next = parsePossibleMultiply();</span>
<span class="line-modified">2310         if (!next)</span>
<span class="line-modified">2311             return Unexpected&lt;Error&gt;(next.error());</span>





2312 
2313         switch (add-&gt;type) {
<span class="line-modified">2314         case Lexer::Token::Type::Plus: {</span>
<span class="line-modified">2315             Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; callArguments;</span>
<span class="line-removed">2316             callArguments.append(WTFMove(previous));</span>
<span class="line-removed">2317             callArguments.append(WTFMove(*next));</span>
<span class="line-removed">2318             previous = makeUniqueRef&lt;AST::CallExpression&gt;(WTFMove(*add), &quot;operator+&quot;_str, WTFMove(callArguments));</span>
2319             break;
2320         }
2321         default: {
<span class="line-modified">2322             ASSERT(add-&gt;type == Lexer::Token::Type::Minus);</span>
<span class="line-modified">2323             Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; callArguments;</span>
<span class="line-removed">2324             callArguments.append(WTFMove(previous));</span>
<span class="line-removed">2325             callArguments.append(WTFMove(*next));</span>
<span class="line-removed">2326             previous = makeUniqueRef&lt;AST::CallExpression&gt;(WTFMove(*add), &quot;operator-&quot;_str, WTFMove(callArguments));</span>
2327             break;
2328         }
2329         }
2330     }
2331 
2332     return WTFMove(previous);
2333 }
2334 
2335 auto Parser::parsePossibleMultiply() -&gt; Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;
2336 {
<span class="line-modified">2337     auto parsedPrevious = parsePossiblePrefix();</span>
<span class="line-modified">2338     if (!parsedPrevious)</span>
<span class="line-modified">2339         return Unexpected&lt;Error&gt;(parsedPrevious.error());</span>
<span class="line-removed">2340     UniqueRef&lt;AST::Expression&gt; previous = WTFMove(*parsedPrevious);</span>
2341 
<span class="line-modified">2342     while (auto multiply = tryTypes({</span>
<span class="line-modified">2343         Lexer::Token::Type::Star,</span>
<span class="line-modified">2344         Lexer::Token::Type::Divide,</span>
<span class="line-modified">2345         Lexer::Token::Type::Mod</span>
<span class="line-modified">2346         })) {</span>
<span class="line-modified">2347         auto next = parsePossiblePrefix();</span>
<span class="line-modified">2348         if (!next)</span>
<span class="line-modified">2349             return Unexpected&lt;Error&gt;(next.error());</span>





2350 
2351         switch (multiply-&gt;type) {
<span class="line-modified">2352         case Lexer::Token::Type::Star: {</span>
<span class="line-modified">2353             Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; callArguments;</span>
<span class="line-removed">2354             callArguments.append(WTFMove(previous));</span>
<span class="line-removed">2355             callArguments.append(WTFMove(*next));</span>
<span class="line-removed">2356             previous = makeUniqueRef&lt;AST::CallExpression&gt;(WTFMove(*multiply), &quot;operator*&quot;_str, WTFMove(callArguments));</span>
2357             break;
2358         }
<span class="line-modified">2359         case Lexer::Token::Type::Divide: {</span>
<span class="line-modified">2360             Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; callArguments;</span>
<span class="line-removed">2361             callArguments.append(WTFMove(previous));</span>
<span class="line-removed">2362             callArguments.append(WTFMove(*next));</span>
<span class="line-removed">2363             previous = makeUniqueRef&lt;AST::CallExpression&gt;(WTFMove(*multiply), &quot;operator/&quot;_str, WTFMove(callArguments));</span>
2364             break;
2365         }
2366         default: {
<span class="line-modified">2367             ASSERT(multiply-&gt;type == Lexer::Token::Type::Mod);</span>
<span class="line-modified">2368             Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; callArguments;</span>
<span class="line-removed">2369             callArguments.append(WTFMove(previous));</span>
<span class="line-removed">2370             callArguments.append(WTFMove(*next));</span>
<span class="line-removed">2371             previous = makeUniqueRef&lt;AST::CallExpression&gt;(WTFMove(*multiply), &quot;operator%&quot;_str, WTFMove(callArguments));</span>
2372             break;
2373         }
2374         }
2375     }
2376 
2377     return WTFMove(previous);
2378 }
2379 
<span class="line-modified">2380 auto Parser::parsePossiblePrefix() -&gt; Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;</span>
2381 {
<span class="line-modified">2382     if (auto prefix = tryTypes({</span>
<span class="line-modified">2383         Lexer::Token::Type::PlusPlus,</span>
<span class="line-modified">2384         Lexer::Token::Type::MinusMinus,</span>
<span class="line-modified">2385         Lexer::Token::Type::Plus,</span>
<span class="line-modified">2386         Lexer::Token::Type::Minus,</span>
<span class="line-modified">2387         Lexer::Token::Type::Tilde,</span>
<span class="line-modified">2388         Lexer::Token::Type::ExclamationPoint,</span>
<span class="line-modified">2389         Lexer::Token::Type::And,</span>
<span class="line-modified">2390         Lexer::Token::Type::At,</span>
<span class="line-modified">2391         Lexer::Token::Type::Star</span>
<span class="line-modified">2392     })) {</span>
<span class="line-modified">2393         auto next = parsePossiblePrefix();</span>
<span class="line-modified">2394         if (!next)</span>
<span class="line-removed">2395             return Unexpected&lt;Error&gt;(next.error());</span>
2396 
2397         switch (prefix-&gt;type) {
<span class="line-modified">2398         case Lexer::Token::Type::PlusPlus: {</span>
<span class="line-modified">2399             auto result = AST::ReadModifyWriteExpression::create(Lexer::Token(*prefix), WTFMove(*next));</span>


2400             Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; callArguments;
2401             callArguments.append(result-&gt;oldVariableReference());
<span class="line-modified">2402             result-&gt;setNewValueExpression(makeUniqueRef&lt;AST::CallExpression&gt;(Lexer::Token(*prefix), &quot;operator++&quot;_str, WTFMove(callArguments)));</span>
2403             result-&gt;setResultExpression(result-&gt;newVariableReference());
2404             return { WTFMove(result) };
2405         }
<span class="line-modified">2406         case Lexer::Token::Type::MinusMinus: {</span>
<span class="line-modified">2407             auto result = AST::ReadModifyWriteExpression::create(Lexer::Token(*prefix), WTFMove(*next));</span>


2408             Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; callArguments;
2409             callArguments.append(result-&gt;oldVariableReference());
<span class="line-modified">2410             result-&gt;setNewValueExpression(makeUniqueRef&lt;AST::CallExpression&gt;(Lexer::Token(*prefix), &quot;operator--&quot;_str, WTFMove(callArguments)));</span>
2411             result-&gt;setResultExpression(result-&gt;newVariableReference());
2412             return { WTFMove(result) };
2413         }
<span class="line-modified">2414         case Lexer::Token::Type::Plus: {</span>
2415             Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; callArguments;
2416             callArguments.append(WTFMove(*next));
<span class="line-modified">2417             return { makeUniqueRef&lt;AST::CallExpression&gt;(Lexer::Token(*prefix), &quot;operator+&quot;_str, WTFMove(callArguments)) };</span>
2418         }
<span class="line-modified">2419         case Lexer::Token::Type::Minus: {</span>
2420             Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; callArguments;
2421             callArguments.append(WTFMove(*next));
<span class="line-modified">2422             return { makeUniqueRef&lt;AST::CallExpression&gt;(Lexer::Token(*prefix), &quot;operator-&quot;_str, WTFMove(callArguments)) };</span>
2423         }
<span class="line-modified">2424         case Lexer::Token::Type::Tilde: {</span>
2425             Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; callArguments;
2426             callArguments.append(WTFMove(*next));
<span class="line-modified">2427             return { makeUniqueRef&lt;AST::CallExpression&gt;(Lexer::Token(*prefix), &quot;operator~&quot;_str, WTFMove(callArguments)) };</span>
2428         }
<span class="line-modified">2429         case Lexer::Token::Type::ExclamationPoint: {</span>
2430             Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; castArguments;
2431             castArguments.append(WTFMove(*next));
<span class="line-modified">2432             auto boolCast = makeUniqueRef&lt;AST::CallExpression&gt;(Lexer::Token(*prefix), &quot;bool&quot;_str, WTFMove(castArguments));</span>
<span class="line-modified">2433             return { makeUniqueRef&lt;AST::LogicalNotExpression&gt;(Lexer::Token(*prefix), WTFMove(boolCast)) };</span>
2434         }
<span class="line-modified">2435         case Lexer::Token::Type::And:</span>
<span class="line-modified">2436             return { makeUniqueRef&lt;AST::MakePointerExpression&gt;(Lexer::Token(*prefix), WTFMove(*next)) };</span>
<span class="line-modified">2437         case Lexer::Token::Type::At:</span>
<span class="line-modified">2438             return { makeUniqueRef&lt;AST::MakeArrayReferenceExpression&gt;(Lexer::Token(*prefix), WTFMove(*next)) };</span>
2439         default:
<span class="line-modified">2440             ASSERT(prefix-&gt;type == Lexer::Token::Type::Star);</span>
<span class="line-modified">2441             return { makeUniqueRef&lt;AST::DereferenceExpression&gt;(Lexer::Token(*prefix), WTFMove(*next)) };</span>
2442         }
2443     }
2444 
<span class="line-modified">2445     return parsePossibleSuffix();</span>
2446 }
2447 
<span class="line-modified">2448 auto Parser::parsePossibleSuffix() -&gt; Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;</span>
2449 {
<span class="line-modified">2450     auto suffix = backtrackingScope&lt;Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;&gt;([&amp;]() -&gt; Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt; {</span>
<span class="line-modified">2451         auto expression = parseCallExpression();</span>
<span class="line-removed">2452         if (!expression)</span>
<span class="line-removed">2453             return Unexpected&lt;Error&gt;(expression.error());</span>
2454 




2455         while (true) {
<span class="line-modified">2456             auto result = backtrackingScope&lt;SuffixExpression&gt;([&amp;]() -&gt; SuffixExpression {</span>
<span class="line-modified">2457                 return parseLimitedSuffixOperator(WTFMove(*expression));</span>
<span class="line-removed">2458             });</span>
<span class="line-removed">2459             expression = WTFMove(result.result);</span>
<span class="line-removed">2460             if (!result)</span>
2461                 break;


2462         }
2463         return expression;
<span class="line-modified">2464     });</span>
<span class="line-removed">2465     if (suffix)</span>
<span class="line-removed">2466         return suffix;</span>
2467 
<span class="line-modified">2468     suffix = backtrackingScope&lt;Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;&gt;([&amp;]() -&gt; Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt; {</span>
<span class="line-modified">2469         auto expression = parseTerm();</span>
<span class="line-removed">2470         if (!expression)</span>
<span class="line-removed">2471             return Unexpected&lt;Error&gt;(expression.error());</span>
2472 
<span class="line-modified">2473         while (true) {</span>
<span class="line-modified">2474             auto result = backtrackingScope&lt;SuffixExpression&gt;([&amp;]() -&gt; SuffixExpression {</span>
<span class="line-modified">2475                 return parseSuffixOperator(WTFMove(*expression));</span>
<span class="line-modified">2476             });</span>
<span class="line-modified">2477             expression = WTFMove(result.result);</span>
<span class="line-modified">2478             if (!result)</span>
<span class="line-modified">2479                 break;</span>



2480         }
<span class="line-modified">2481         return expression;</span>
<span class="line-modified">2482     });</span>
<span class="line-modified">2483     if (suffix)</span>
<span class="line-modified">2484         return suffix;</span>
<span class="line-modified">2485 </span>
<span class="line-modified">2486     return Unexpected&lt;Error&gt;(suffix.error());</span>

2487 }
2488 
2489 auto Parser::parseCallExpression() -&gt; Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;
2490 {
<span class="line-modified">2491     auto name = consumeType(Lexer::Token::Type::Identifier);</span>
<span class="line-modified">2492     if (!name)</span>
<span class="line-removed">2493         return Unexpected&lt;Error&gt;(name.error());</span>
<span class="line-removed">2494     auto callName = name-&gt;stringView.toString();</span>
2495 
<span class="line-modified">2496     auto leftParenthesis = consumeType(Lexer::Token::Type::LeftParenthesis);</span>
<span class="line-removed">2497     if (!leftParenthesis)</span>
<span class="line-removed">2498         return Unexpected&lt;Error&gt;(leftParenthesis.error());</span>
2499 
2500     Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; arguments;
<span class="line-modified">2501     if (tryType(Lexer::Token::Type::RightParenthesis))</span>
2502         return { makeUniqueRef&lt;AST::CallExpression&gt;(WTFMove(*name), WTFMove(callName), WTFMove(arguments)) };
2503 
<span class="line-modified">2504     auto firstArgument = parsePossibleTernaryConditional();</span>
<span class="line-removed">2505     if (!firstArgument)</span>
<span class="line-removed">2506         return Unexpected&lt;Error&gt;(firstArgument.error());</span>
2507     arguments.append(WTFMove(*firstArgument));
<span class="line-modified">2508     while (tryType(Lexer::Token::Type::Comma)) {</span>
<span class="line-modified">2509         auto argument = parsePossibleTernaryConditional();</span>
<span class="line-removed">2510         if (!argument)</span>
<span class="line-removed">2511             return Unexpected&lt;Error&gt;(argument.error());</span>
2512         arguments.append(WTFMove(*argument));
2513     }
2514 
<span class="line-modified">2515     auto rightParenthesis = consumeType(Lexer::Token::Type::RightParenthesis);</span>
<span class="line-modified">2516     if (!rightParenthesis)</span>
<span class="line-removed">2517         return Unexpected&lt;Error&gt;(rightParenthesis.error());</span>
2518 
<span class="line-modified">2519     return { makeUniqueRef&lt;AST::CallExpression&gt;(WTFMove(*name), WTFMove(callName), WTFMove(arguments)) };</span>
2520 }
2521 
2522 auto Parser::parseTerm() -&gt; Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;
2523 {
<span class="line-modified">2524     auto type = consumeTypes({</span>
<span class="line-modified">2525         Lexer::Token::Type::IntLiteral,</span>
<span class="line-modified">2526         Lexer::Token::Type::UintLiteral,</span>
<span class="line-modified">2527         Lexer::Token::Type::FloatLiteral,</span>
<span class="line-modified">2528         Lexer::Token::Type::Null,</span>
<span class="line-modified">2529         Lexer::Token::Type::True,</span>
<span class="line-modified">2530         Lexer::Token::Type::False,</span>
<span class="line-modified">2531         Lexer::Token::Type::Identifier,</span>
<span class="line-modified">2532         Lexer::Token::Type::LeftParenthesis</span>
<span class="line-removed">2533     });</span>
2534     if (!type)
<span class="line-modified">2535         return Unexpected&lt;Error&gt;(type.error());</span>
2536 
2537     switch (type-&gt;type) {
<span class="line-modified">2538     case Lexer::Token::Type::IntLiteral: {</span>
<span class="line-modified">2539         auto value = intLiteralToInt(type-&gt;stringView);</span>
2540         if (!value)
<span class="line-modified">2541             return Unexpected&lt;Error&gt;(value.error());</span>
<span class="line-modified">2542         return { makeUniqueRef&lt;AST::IntegerLiteral&gt;(WTFMove(*type), *value) };</span>
2543     }
<span class="line-modified">2544     case Lexer::Token::Type::UintLiteral: {</span>
<span class="line-modified">2545         auto value = uintLiteralToUint(type-&gt;stringView);</span>
2546         if (!value)
<span class="line-modified">2547             return Unexpected&lt;Error&gt;(value.error());</span>
<span class="line-modified">2548         return { makeUniqueRef&lt;AST::UnsignedIntegerLiteral&gt;(WTFMove(*type), *value) };</span>
2549     }
<span class="line-modified">2550     case Lexer::Token::Type::FloatLiteral: {</span>
<span class="line-modified">2551         auto value = floatLiteralToFloat(type-&gt;stringView);</span>
2552         if (!value)
<span class="line-modified">2553             return Unexpected&lt;Error&gt;(value.error());</span>
<span class="line-modified">2554         return { makeUniqueRef&lt;AST::FloatLiteral&gt;(WTFMove(*type), *value) };</span>
<span class="line-modified">2555     }</span>
<span class="line-modified">2556     case Lexer::Token::Type::Null:</span>
<span class="line-modified">2557         return { makeUniqueRef&lt;AST::NullLiteral&gt;(WTFMove(*type)) };</span>
<span class="line-modified">2558     case Lexer::Token::Type::True:</span>
<span class="line-modified">2559         return { makeUniqueRef&lt;AST::BooleanLiteral&gt;(WTFMove(*type), true) };</span>
<span class="line-modified">2560     case Lexer::Token::Type::False:</span>
<span class="line-modified">2561         return { makeUniqueRef&lt;AST::BooleanLiteral&gt;(WTFMove(*type), false) };</span>
<span class="line-modified">2562     case Lexer::Token::Type::Identifier: {</span>
<span class="line-modified">2563         auto name = type-&gt;stringView.toString();</span>
<span class="line-modified">2564         return { makeUniqueRef&lt;AST::VariableReference&gt;(WTFMove(*type), WTFMove(name)) };</span>
2565     }
2566     default: {
<span class="line-modified">2567         ASSERT(type-&gt;type == Lexer::Token::Type::LeftParenthesis);</span>
<span class="line-modified">2568         auto expression = parseExpression();</span>
<span class="line-modified">2569         if (!expression)</span>
<span class="line-removed">2570             return Unexpected&lt;Error&gt;(expression.error());</span>
<span class="line-removed">2571 </span>
<span class="line-removed">2572         auto rightParenthesis = consumeType(Lexer::Token::Type::RightParenthesis);</span>
<span class="line-removed">2573         if (!rightParenthesis)</span>
<span class="line-removed">2574             return Unexpected&lt;Error&gt;(rightParenthesis.error());</span>
2575 
2576         return { WTFMove(*expression) };
2577     }
2578     }
2579 }
2580 
2581 } // namespace WHLSL
2582 
2583 } // namespace WebCore
2584 
2585 #endif // ENABLE(WEBGPU)
</pre>
</td>
<td>
<hr />
<pre>
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
  14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
  15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
  17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
  23  * THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #include &quot;config.h&quot;
  27 #include &quot;WHLSLParser.h&quot;
  28 
  29 #if ENABLE(WEBGPU)
  30 
  31 #include &quot;WHLSLAddressSpace.h&quot;
  32 #include &quot;WHLSLEntryPointType.h&quot;
<span class="line-added">  33 #include &quot;WHLSLProgram.h&quot;</span>
  34 #include &lt;wtf/dtoa.h&gt;
  35 #include &lt;wtf/text/StringBuilder.h&gt;
  36 #include &lt;wtf/text/StringConcatenate.h&gt;
  37 
  38 namespace WebCore {
  39 
  40 namespace WHLSL {
  41 
<span class="line-modified">  42 #define PARSE(name, element, ...) \</span>
<span class="line-modified">  43     auto name = parse##element(__VA_ARGS__); \</span>
<span class="line-added">  44     if (!name) \</span>
<span class="line-added">  45         return makeUnexpected(name.error()); \</span>
<span class="line-added">  46 </span>
<span class="line-added">  47 #define CONSUME_TYPE(name, type) \</span>
<span class="line-added">  48     auto name = consumeType(Token::Type::type); \</span>
<span class="line-added">  49     if (!name) \</span>
<span class="line-added">  50         return makeUnexpected(name.error());</span>
<span class="line-added">  51 </span>
<span class="line-added">  52 #define PEEK(name) \</span>
<span class="line-added">  53     auto name = peek(); \</span>
<span class="line-added">  54     if (!name) \</span>
<span class="line-added">  55         return makeUnexpected(name.error());</span>
<span class="line-added">  56 </span>
<span class="line-added">  57 #define PEEK_FURTHER(name) \</span>
<span class="line-added">  58     auto name = peekFurther(); \</span>
<span class="line-added">  59     if (!name) \</span>
<span class="line-added">  60         return makeUnexpected(name.error());</span>
<span class="line-added">  61 </span>
<span class="line-added">  62 auto Parser::parse(Program&amp; program, StringView stringView, ParsingMode mode, AST::NameSpace nameSpace) -&gt; Expected&lt;void, Error&gt;</span>
  63 {
<span class="line-modified">  64     m_lexer = Lexer(stringView, nameSpace);</span>
  65     m_mode = mode;
  66 
  67     while (!m_lexer.isFullyConsumed()) {
<span class="line-modified">  68         auto token = m_lexer.peek();</span>
<span class="line-added">  69         switch (token.type) {</span>
<span class="line-added">  70         case Token::Type::Invalid:</span>
<span class="line-added">  71             return { };</span>
<span class="line-added">  72         case Token::Type::Semicolon:</span>
  73             m_lexer.consumeToken();
  74             continue;
<span class="line-added">  75         case Token::Type::Typedef: {</span>
<span class="line-added">  76             auto typeDefinition = parseTypeDefinition();</span>
<span class="line-added">  77             if (!typeDefinition)</span>
<span class="line-added">  78                 return makeUnexpected(typeDefinition.error());</span>
<span class="line-added">  79             auto appendResult = program.append(WTFMove(*typeDefinition));</span>
<span class="line-added">  80             if (!appendResult)</span>
<span class="line-added">  81                 return makeUnexpected(appendResult.error());</span>
<span class="line-added">  82             continue;</span>
  83         }
<span class="line-modified">  84         case Token::Type::Struct: {</span>
<span class="line-modified">  85             auto structureDefinition = parseStructureDefinition();</span>
<span class="line-modified">  86             if (!structureDefinition)</span>
<span class="line-modified">  87                 return makeUnexpected(structureDefinition.error());</span>
<span class="line-modified">  88             auto appendResult = program.append(WTFMove(*structureDefinition));</span>
<span class="line-modified">  89             if (!appendResult)</span>
<span class="line-modified">  90                 return makeUnexpected(appendResult.error());</span>
<span class="line-modified">  91             continue;</span>



  92         }
<span class="line-modified">  93         case Token::Type::Enum: {</span>
<span class="line-modified">  94             auto enumerationDefinition = parseEnumerationDefinition();</span>
<span class="line-modified">  95             if (!enumerationDefinition)</span>
<span class="line-modified">  96                 return makeUnexpected(enumerationDefinition.error());</span>
<span class="line-modified">  97             auto appendResult = program.append(WTFMove(*enumerationDefinition));</span>
<span class="line-modified">  98             if (!appendResult)</span>
<span class="line-modified">  99                 return makeUnexpected(appendResult.error());</span>
<span class="line-modified"> 100             continue;</span>



 101         }
<span class="line-modified"> 102         case Token::Type::Native: {</span>
<span class="line-modified"> 103             if (m_mode != ParsingMode::StandardLibrary)</span>
<span class="line-modified"> 104                 return fail(makeString(&quot;&#39;native&#39; can&#39;t exist outside of the standard library.&quot;));</span>
<span class="line-modified"> 105             auto furtherToken = peekFurther();</span>
<span class="line-modified"> 106             if (!furtherToken)</span>
<span class="line-modified"> 107                 return { };</span>
<span class="line-modified"> 108             if (furtherToken-&gt;type == Token::Type::Typedef) {</span>
<span class="line-modified"> 109                 auto nativeTypeDeclaration = parseNativeTypeDeclaration();</span>
<span class="line-modified"> 110                 if (!nativeTypeDeclaration)</span>
<span class="line-added"> 111                     return makeUnexpected(nativeTypeDeclaration.error());</span>
<span class="line-added"> 112                 auto appendResult = program.append(WTFMove(*nativeTypeDeclaration));</span>
<span class="line-added"> 113                 if (!appendResult)</span>
<span class="line-added"> 114                     return makeUnexpected(appendResult.error());</span>
 115                 continue;
 116             }
<span class="line-added"> 117             auto nativeFunctionDeclaration = parseNativeFunctionDeclaration();</span>
<span class="line-added"> 118             if (!nativeFunctionDeclaration)</span>
<span class="line-added"> 119                 return makeUnexpected(nativeFunctionDeclaration.error());</span>
<span class="line-added"> 120             auto appendResult = program.append(WTFMove(*nativeFunctionDeclaration));</span>
<span class="line-added"> 121             if (!appendResult)</span>
<span class="line-added"> 122                 return makeUnexpected(appendResult.error());</span>
<span class="line-added"> 123             continue;</span>
 124         }
<span class="line-modified"> 125         default: {</span>
<span class="line-modified"> 126             auto functionDefinition = parseFunctionDefinition();</span>
<span class="line-modified"> 127             if (!functionDefinition)</span>
<span class="line-modified"> 128                 return makeUnexpected(functionDefinition.error());</span>
<span class="line-modified"> 129             auto appendResult = program.append(WTFMove(*functionDefinition));</span>
<span class="line-modified"> 130             if (!appendResult)</span>
<span class="line-modified"> 131                 return makeUnexpected(appendResult.error());</span>
<span class="line-modified"> 132             continue;</span>





 133         }











 134         }
<span class="line-added"> 135     }</span>
 136 
<span class="line-modified"> 137     return { };</span>
<span class="line-modified"> 138 }</span>









 139 
<span class="line-modified"> 140 auto Parser::fail(const String&amp; message, TryToPeek tryToPeek) -&gt; Unexpected&lt;Error&gt;</span>
<span class="line-added"> 141 {</span>
<span class="line-added"> 142     if (tryToPeek == TryToPeek::Yes) {</span>
<span class="line-added"> 143         if (auto nextToken = peek())</span>
<span class="line-added"> 144             return makeUnexpected(Error(m_lexer.errorString(*nextToken, message)));</span>
 145     }
<span class="line-modified"> 146     return makeUnexpected(Error(makeString(&quot;Cannot lex: &quot;, message)));</span>
 147 }
 148 
<span class="line-modified"> 149 auto Parser::peek() -&gt; Expected&lt;Token, Error&gt;</span>
 150 {
<span class="line-modified"> 151     auto token = m_lexer.peek();</span>
<span class="line-modified"> 152     if (token.type != Token::Type::Invalid &amp;&amp; token.type != Token::Type::EndOfFile)</span>
<span class="line-modified"> 153         return { token };</span>
<span class="line-added"> 154     return fail(&quot;Cannot consume token&quot;_str, TryToPeek::No);</span>
 155 }
 156 
<span class="line-modified"> 157 auto Parser::peekFurther() -&gt; Expected&lt;Token, Error&gt;</span>
 158 {
<span class="line-modified"> 159     auto token = m_lexer.peekFurther();</span>
<span class="line-modified"> 160     if (token.type != Token::Type::Invalid &amp;&amp; token.type != Token::Type::EndOfFile)</span>
<span class="line-modified"> 161         return { token };</span>
<span class="line-added"> 162     return fail(&quot;Cannot consume two tokens&quot;_str, TryToPeek::No);</span>
<span class="line-added"> 163 }</span>
<span class="line-added"> 164 </span>
<span class="line-added"> 165 template &lt;Token::Type t, Token::Type... ts&gt;</span>
<span class="line-added"> 166 struct Types {</span>
<span class="line-added"> 167     static bool includes(Token::Type type)</span>
<span class="line-added"> 168     {</span>
<span class="line-added"> 169         return t == type || Types&lt;ts...&gt;::includes(type);</span>
<span class="line-added"> 170     }</span>
<span class="line-added"> 171 </span>
<span class="line-added"> 172     static void appendNameTo(StringBuilder&amp; builder)</span>
<span class="line-added"> 173     {</span>
<span class="line-added"> 174         builder.append(Token::typeName(t), &quot;, &quot;);</span>
<span class="line-added"> 175         Types&lt;ts...&gt;::appendNameTo(builder);</span>
<span class="line-added"> 176     }</span>
<span class="line-added"> 177 };</span>
<span class="line-added"> 178 template &lt;Token::Type t&gt;</span>
<span class="line-added"> 179 struct Types&lt;t&gt; {</span>
<span class="line-added"> 180     static bool includes(Token::Type type)</span>
<span class="line-added"> 181     {</span>
<span class="line-added"> 182         return t == type;</span>
<span class="line-added"> 183     }</span>
<span class="line-added"> 184 </span>
<span class="line-added"> 185     static void appendNameTo(StringBuilder&amp; builder)</span>
<span class="line-added"> 186     {</span>
<span class="line-added"> 187         builder.append(Token::typeName(t));</span>
 188     }
<span class="line-modified"> 189 };</span>
<span class="line-added"> 190 </span>
<span class="line-added"> 191 </span>
<span class="line-added"> 192 bool Parser::peekType(Token::Type type)</span>
<span class="line-added"> 193 {</span>
<span class="line-added"> 194     auto token = m_lexer.peek();</span>
<span class="line-added"> 195     return token.type == type;</span>
 196 }
 197 
<span class="line-modified"> 198 template &lt;Token::Type... types&gt;</span>
<span class="line-added"> 199 bool Parser::peekTypes()</span>
 200 {
<span class="line-modified"> 201     auto token = m_lexer.peek();</span>
<span class="line-modified"> 202     return Types&lt;types...&gt;::includes(token.type);</span>
<span class="line-modified"> 203 }</span>
<span class="line-modified"> 204 </span>
<span class="line-modified"> 205 Optional&lt;Token&gt; Parser::tryType(Token::Type type)</span>
<span class="line-added"> 206 {</span>
<span class="line-added"> 207     auto token = m_lexer.peek();</span>
<span class="line-added"> 208     if (token.type == type)</span>
<span class="line-added"> 209         return { m_lexer.consumeToken() };</span>
 210     return WTF::nullopt;
 211 }
 212 
<span class="line-modified"> 213 template &lt;Token::Type... types&gt;</span>
<span class="line-added"> 214 Optional&lt;Token&gt; Parser::tryTypes()</span>
 215 {
<span class="line-modified"> 216     auto token = m_lexer.peek();</span>
<span class="line-modified"> 217     if (Types&lt;types...&gt;::includes(token.type))</span>
<span class="line-modified"> 218         return { m_lexer.consumeToken() };</span>


 219     return WTF::nullopt;
 220 }
 221 
<span class="line-modified"> 222 auto Parser::consumeType(Token::Type type) -&gt; Expected&lt;Token, Error&gt;</span>
 223 {
<span class="line-modified"> 224     auto token = m_lexer.consumeToken();</span>
<span class="line-modified"> 225     if (token.type == type)</span>
<span class="line-modified"> 226         return { token };</span>
<span class="line-modified"> 227     return fail(makeString(&quot;Unexpected token (expected &quot;, Token::typeName(type), &quot; got &quot;, Token::typeName(token.type), &quot;)&quot;));</span>


 228 }
 229 
<span class="line-modified"> 230 template &lt;Token::Type... types&gt;</span>
<span class="line-added"> 231 auto Parser::consumeTypes() -&gt; Expected&lt;Token, Error&gt;</span>
 232 {
 233     auto buildExpectedString = [&amp;]() -&gt; String {
 234         StringBuilder builder;
 235         builder.append(&quot;[&quot;);
<span class="line-modified"> 236         Types&lt;types...&gt;::appendNameTo(builder);</span>




 237         builder.append(&quot;]&quot;);
 238         return builder.toString();
 239     };
 240 
<span class="line-modified"> 241     auto token = m_lexer.consumeToken();</span>
<span class="line-modified"> 242     if (Types&lt;types...&gt;::includes(token.type))</span>
<span class="line-modified"> 243         return { token };</span>
<span class="line-modified"> 244     return fail(makeString(&quot;Unexpected token (expected one of &quot;, buildExpectedString(), &quot; got &quot;, Token::typeName(token.type), &quot;)&quot;));</span>


 245 }
 246 
 247 static int digitValue(UChar character)
 248 {
 249     if (character &gt;= &#39;0&#39; &amp;&amp; character &lt;= &#39;9&#39;)
 250         return character - &#39;0&#39;;
 251     if (character &gt;= &#39;a&#39; &amp;&amp; character &lt;= &#39;f&#39;)
 252         return character - &#39;a&#39; + 10;
 253     return character - &#39;A&#39; + 10;
 254 }
 255 
<span class="line-modified"> 256 static Expected&lt;int, Error&gt; intLiteralToInt(StringView text)</span>
 257 {
 258     bool negate = false;
 259     if (text.startsWith(&quot;-&quot;_str)) {
 260         negate = true;
 261         text = text.substring(1);
 262     }
 263     int base = 10;
 264     if (text.startsWith(&quot;0x&quot;_str)) {
 265         text = text.substring(2);
 266         base = 16;
 267     }
 268 
 269     unsigned result = 0;
 270     for (auto codePoint : text.codePoints()) {
 271         unsigned digit = digitValue(codePoint);
 272         auto previous = result;
 273         result = result * base + digit;
 274         if (result &lt; previous)
<span class="line-modified"> 275             return makeUnexpected(Error(makeString(&quot;int literal &quot;, text, &quot; is out of bounds&quot;)));</span>
 276     }
 277     if (negate) {
<span class="line-modified"> 278         static_assert(sizeof(int64_t) &gt; sizeof(unsigned) &amp;&amp; sizeof(int64_t) &gt; sizeof(int), &quot;This code would be wrong otherwise&quot;);</span>
<span class="line-modified"> 279         int64_t intResult = -static_cast&lt;int64_t&gt;(result);</span>
<span class="line-modified"> 280         if (intResult &lt; static_cast&lt;int64_t&gt;(std::numeric_limits&lt;int&gt;::min()))</span>
<span class="line-modified"> 281             return makeUnexpected(Error(makeString(&quot;int literal &quot;, text, &quot; is out of bounds&quot;)));</span>
<span class="line-added"> 282         return { static_cast&lt;int&gt;(intResult) };</span>
 283     }
 284     if (result &gt; static_cast&lt;unsigned&gt;(std::numeric_limits&lt;int&gt;::max()))
<span class="line-modified"> 285         return makeUnexpected(Error(makeString(&quot;int literal &quot;, text, &quot; is out of bounds&quot;)));</span>
 286     return { static_cast&lt;int&gt;(result) };
 287 }
 288 
<span class="line-modified"> 289 static Expected&lt;unsigned, Error&gt; uintLiteralToUint(StringView text)</span>
 290 {
 291     unsigned base = 10;
 292     if (text.startsWith(&quot;0x&quot;_str)) {
 293         text = text.substring(2);
 294         base = 16;
 295     }
 296     ASSERT(text.endsWith(&quot;u&quot;));
 297     text = text.substring(0, text.length() - 1);
 298     unsigned result = 0;
 299     for (auto codePoint : text.codePoints()) {
 300         unsigned digit = digitValue(codePoint);
 301         auto previous = result;
 302         result = result * base + digit;
 303         if (result &lt; previous)
<span class="line-modified"> 304             return makeUnexpected(Error(makeString(&quot;uint literal &quot;, text, &quot; is out of bounds&quot;)));</span>
 305     }
 306     return { result };
 307 }
 308 
<span class="line-modified"> 309 static Expected&lt;float, Error&gt; floatLiteralToFloat(StringView text)</span>
 310 {
 311     size_t parsedLength;
 312     auto result = parseDouble(text, parsedLength);
 313     if (parsedLength != text.length())
<span class="line-modified"> 314         return makeUnexpected(Error(makeString(&quot;Cannot parse float &quot;, text)));</span>
 315     return static_cast&lt;float&gt;(result);
 316 }
 317 
 318 auto Parser::consumeIntegralLiteral() -&gt; Expected&lt;Variant&lt;int, unsigned&gt;, Error&gt;
 319 {
<span class="line-modified"> 320     auto integralLiteralToken = consumeTypes&lt;Token::Type::IntLiteral, Token::Type::UintLiteral&gt;();</span>
 321     if (!integralLiteralToken)
<span class="line-modified"> 322         return makeUnexpected(integralLiteralToken.error());</span>
 323 
 324     switch (integralLiteralToken-&gt;type) {
<span class="line-modified"> 325     case Token::Type::IntLiteral: {</span>
<span class="line-modified"> 326         auto result = intLiteralToInt(integralLiteralToken-&gt;stringView(m_lexer));</span>
 327         if (result)
 328             return {{ *result }};
<span class="line-modified"> 329         return makeUnexpected(result.error());</span>
 330     }
 331     default: {
<span class="line-modified"> 332         ASSERT(integralLiteralToken-&gt;type == Token::Type::UintLiteral);</span>
<span class="line-modified"> 333         auto result = uintLiteralToUint(integralLiteralToken-&gt;stringView(m_lexer));</span>
 334         if (result)
 335             return {{ *result }};
<span class="line-modified"> 336         return makeUnexpected(result.error());</span>
 337     }
 338     }
 339 }
 340 
 341 auto Parser::consumeNonNegativeIntegralLiteral() -&gt; Expected&lt;unsigned, Error&gt;
 342 {
 343     auto integralLiteral = consumeIntegralLiteral();
 344     if (!integralLiteral)
<span class="line-modified"> 345         return makeUnexpected(integralLiteral.error());</span>
 346     auto result = WTF::visit(WTF::makeVisitor([](int x) -&gt; Optional&lt;unsigned&gt; {
 347         if (x &lt; 0)
 348             return WTF::nullopt;
 349         return x;
 350     }, [](unsigned x) -&gt; Optional&lt;unsigned&gt; {
 351         return x;
 352     }), *integralLiteral);
 353     if (result)
 354         return *result;
 355     return fail(&quot;int literal is negative&quot;_str);
 356 }
 357 
<span class="line-modified"> 358 static Expected&lt;unsigned, Error&gt; recognizeSimpleUnsignedInteger(StringView stringView)</span>
 359 {
 360     unsigned result = 0;
 361     if (stringView.length() &lt; 1)
<span class="line-modified"> 362         return makeUnexpected(Error(makeString(&quot;Simple unsigned literal &quot;, stringView, &quot; is too short&quot;)));</span>
 363     for (auto codePoint : stringView.codePoints()) {
 364         if (codePoint &lt; &#39;0&#39; || codePoint &gt; &#39;9&#39;)
<span class="line-modified"> 365             return makeUnexpected(Error(makeString(&quot;Simple unsigned literal &quot;, stringView, &quot; isn&#39;t of the form [0-9]+&quot;)));</span>
 366         auto previous = result;
 367         result = result * 10 + (codePoint - &#39;0&#39;);
 368         if (result &lt; previous)
<span class="line-modified"> 369             return makeUnexpected(Error(makeString(&quot;Simple unsigned literal &quot;, stringView, &quot; is out of bounds&quot;)));</span>
 370     }
 371     return result;
 372 }
 373 
 374 auto Parser::parseConstantExpression() -&gt; Expected&lt;AST::ConstantExpression, Error&gt;
 375 {
<span class="line-modified"> 376     auto type = consumeTypes&lt;</span>
<span class="line-modified"> 377         Token::Type::IntLiteral,</span>
<span class="line-modified"> 378         Token::Type::UintLiteral,</span>
<span class="line-modified"> 379         Token::Type::FloatLiteral,</span>
<span class="line-modified"> 380         Token::Type::Null,</span>
<span class="line-modified"> 381         Token::Type::True,</span>
<span class="line-modified"> 382         Token::Type::False,</span>
<span class="line-modified"> 383         Token::Type::Identifier&gt;();</span>

 384     if (!type)
<span class="line-modified"> 385         return makeUnexpected(type.error());</span>
 386 
 387     switch (type-&gt;type) {
<span class="line-modified"> 388     case Token::Type::IntLiteral: {</span>
<span class="line-modified"> 389         auto value = intLiteralToInt(type-&gt;stringView(m_lexer));</span>
 390         if (!value)
<span class="line-modified"> 391             return makeUnexpected(value.error());</span>
<span class="line-modified"> 392         return {{ AST::IntegerLiteral({ *type }, *value) }};</span>
 393     }
<span class="line-modified"> 394     case Token::Type::UintLiteral: {</span>
<span class="line-modified"> 395         auto value = uintLiteralToUint(type-&gt;stringView(m_lexer));</span>
 396         if (!value)
<span class="line-modified"> 397             return makeUnexpected(value.error());</span>
<span class="line-modified"> 398         return {{ AST::UnsignedIntegerLiteral({ *type }, *value) }};</span>
 399     }
<span class="line-modified"> 400     case Token::Type::FloatLiteral: {</span>
<span class="line-modified"> 401         auto value = floatLiteralToFloat(type-&gt;stringView(m_lexer));</span>
 402         if (!value)
<span class="line-modified"> 403             return makeUnexpected(value.error());</span>
<span class="line-modified"> 404         return {{ AST::FloatLiteral({ *type }, *value) }};</span>
 405     }
<span class="line-modified"> 406     case Token::Type::Null:</span>
 407         return { AST::NullLiteral(WTFMove(*type)) };
<span class="line-modified"> 408     case Token::Type::True:</span>
 409         return { AST::BooleanLiteral(WTFMove(*type), true) };
<span class="line-modified"> 410     case Token::Type::False:</span>
 411         return { AST::BooleanLiteral(WTFMove(*type), false) };
 412     default: {
<span class="line-modified"> 413         ASSERT(type-&gt;type == Token::Type::Identifier);</span>
<span class="line-modified"> 414         CONSUME_TYPE(fullStop, FullStop);</span>
<span class="line-modified"> 415         CONSUME_TYPE(next, Identifier);</span>
<span class="line-modified"> 416         return { AST::EnumerationMemberLiteral({ *type, *next }, type-&gt;stringView(m_lexer).toString(), next-&gt;stringView(m_lexer).toString()) };</span>




 417     }
 418     }
 419 }
 420 
 421 auto Parser::parseTypeArgument() -&gt; Expected&lt;AST::TypeArgument, Error&gt;
 422 {
<span class="line-modified"> 423     PEEK(nextToken);</span>
<span class="line-modified"> 424     PEEK_FURTHER(furtherToken);</span>
<span class="line-modified"> 425     if (nextToken-&gt;type != Token::Type::Identifier || furtherToken-&gt;type == Token::Type::FullStop) {</span>
<span class="line-modified"> 426         PARSE(constantExpression, ConstantExpression);</span>
 427         return AST::TypeArgument(WTFMove(*constantExpression));
<span class="line-modified"> 428     }</span>
<span class="line-modified"> 429     CONSUME_TYPE(result, Identifier);</span>
<span class="line-modified"> 430     CodeLocation location(*result);</span>
<span class="line-modified"> 431     return AST::TypeArgument(AST::TypeReference::create(location, result-&gt;stringView(m_lexer).toString(), AST::TypeArguments()));</span>
 432 }
 433 
 434 auto Parser::parseTypeArguments() -&gt; Expected&lt;AST::TypeArguments, Error&gt;
 435 {
<span class="line-modified"> 436     AST::TypeArguments typeArguments;</span>
<span class="line-modified"> 437     auto lessThanSign = tryType(Token::Type::LessThanSign);</span>
<span class="line-modified"> 438     if (!lessThanSign)</span>















 439         return typeArguments;



 440 
<span class="line-modified"> 441     auto greaterThanSign = tryType(Token::Type::GreaterThanSign);</span>
<span class="line-modified"> 442     if (greaterThanSign)</span>
<span class="line-modified"> 443         return typeArguments;</span>
<span class="line-modified"> 444 </span>
<span class="line-modified"> 445     PARSE(typeArgument, TypeArgument);</span>
<span class="line-modified"> 446     typeArguments.append(WTFMove(*typeArgument));</span>
<span class="line-modified"> 447 </span>
<span class="line-modified"> 448     while (true) {</span>
<span class="line-modified"> 449         auto greaterThanSign = tryType(Token::Type::GreaterThanSign);</span>
<span class="line-modified"> 450         if (greaterThanSign)</span>
<span class="line-modified"> 451             break;</span>
<span class="line-added"> 452 </span>
<span class="line-added"> 453         CONSUME_TYPE(comma, Comma);</span>
<span class="line-added"> 454         PARSE(typeArgument, TypeArgument);</span>
<span class="line-added"> 455         typeArguments.append(WTFMove(*typeArgument));</span>
<span class="line-added"> 456     }</span>
 457 
<span class="line-modified"> 458     return typeArguments;</span>
 459 }
 460 
 461 auto Parser::parseTypeSuffixAbbreviated() -&gt; Expected&lt;TypeSuffixAbbreviated, Error&gt;
 462 {
<span class="line-modified"> 463     auto token = consumeTypes&lt;</span>
<span class="line-added"> 464         Token::Type::Star,</span>
<span class="line-added"> 465         Token::Type::SquareBracketPair,</span>
<span class="line-added"> 466         Token::Type::LeftSquareBracket&gt;();</span>
 467     if (!token)
<span class="line-modified"> 468         return makeUnexpected(token.error());</span>
<span class="line-modified"> 469     if (token-&gt;type == Token::Type::LeftSquareBracket) {</span>
 470         auto numElements = consumeNonNegativeIntegralLiteral();
 471         if (!numElements)
<span class="line-modified"> 472             return makeUnexpected(numElements.error());</span>
<span class="line-modified"> 473         CONSUME_TYPE(rightSquareBracket, RightSquareBracket);</span>
<span class="line-modified"> 474         return {{ { *token, *rightSquareBracket }, *token, *numElements }};</span>


 475     }
<span class="line-modified"> 476     return {{ { *token }, *token, WTF::nullopt }};</span>
 477 }
 478 
 479 auto Parser::parseTypeSuffixNonAbbreviated() -&gt; Expected&lt;TypeSuffixNonAbbreviated, Error&gt;
 480 {
<span class="line-modified"> 481     auto token = consumeTypes&lt;</span>
<span class="line-added"> 482         Token::Type::Star,</span>
<span class="line-added"> 483         Token::Type::SquareBracketPair,</span>
<span class="line-added"> 484         Token::Type::LeftSquareBracket&gt;();</span>
 485     if (!token)
<span class="line-modified"> 486         return makeUnexpected(token.error());</span>
<span class="line-modified"> 487     if (token-&gt;type == Token::Type::LeftSquareBracket) {</span>
 488         auto numElements = consumeNonNegativeIntegralLiteral();
 489         if (!numElements)
<span class="line-modified"> 490             return makeUnexpected(numElements.error());</span>
<span class="line-modified"> 491         CONSUME_TYPE(rightSquareBracket, RightSquareBracket);</span>
<span class="line-modified"> 492         return {{ { *token, *rightSquareBracket }, *token, WTF::nullopt, *numElements }};</span>
<span class="line-modified"> 493     }</span>
<span class="line-modified"> 494     auto addressSpaceToken = consumeTypes&lt;</span>
<span class="line-modified"> 495         Token::Type::Constant,</span>
<span class="line-modified"> 496         Token::Type::Device,</span>
<span class="line-added"> 497         Token::Type::Threadgroup,</span>
<span class="line-added"> 498         Token::Type::Thread&gt;();</span>
 499     if (!addressSpaceToken)
<span class="line-modified"> 500         return makeUnexpected(addressSpaceToken.error());</span>
 501     AST::AddressSpace addressSpace;
 502     switch (addressSpaceToken-&gt;type) {
<span class="line-modified"> 503     case Token::Type::Constant:</span>
 504         addressSpace = AST::AddressSpace::Constant;
 505         break;
<span class="line-modified"> 506     case Token::Type::Device:</span>
 507         addressSpace = AST::AddressSpace::Device;
 508         break;
<span class="line-modified"> 509     case Token::Type::Threadgroup:</span>
 510         addressSpace = AST::AddressSpace::Threadgroup;
 511         break;
 512     default:
<span class="line-modified"> 513         ASSERT(addressSpaceToken-&gt;type == Token::Type::Thread);</span>
 514         addressSpace = AST::AddressSpace::Thread;
 515         break;
 516     }
<span class="line-modified"> 517     return {{ { *token }, *token, { addressSpace }, WTF::nullopt }};</span>
 518 }
 519 
<span class="line-modified"> 520 auto Parser::parseType() -&gt; Expected&lt;Ref&lt;AST::UnnamedType&gt;, Error&gt;</span>
 521 {
<span class="line-modified"> 522     auto addressSpaceToken = tryTypes&lt;</span>
<span class="line-modified"> 523         Token::Type::Constant,</span>
<span class="line-modified"> 524         Token::Type::Device,</span>
<span class="line-modified"> 525         Token::Type::Threadgroup,</span>
<span class="line-modified"> 526         Token::Type::Thread&gt;();</span>
































 527 
<span class="line-modified"> 528     CONSUME_TYPE(name, Identifier);</span>
<span class="line-modified"> 529     PARSE(typeArguments, TypeArguments);</span>
<span class="line-modified"> 530 </span>
<span class="line-modified"> 531     if (addressSpaceToken) {</span>
<span class="line-modified"> 532         AST::AddressSpace addressSpace;</span>
<span class="line-modified"> 533         switch (addressSpaceToken-&gt;type) {</span>
<span class="line-modified"> 534         case Token::Type::Constant:</span>
<span class="line-modified"> 535             addressSpace = AST::AddressSpace::Constant;</span>



 536             break;
<span class="line-modified"> 537         case Token::Type::Device:</span>
<span class="line-modified"> 538             addressSpace = AST::AddressSpace::Device;</span>
<span class="line-added"> 539             break;</span>
<span class="line-added"> 540         case Token::Type::Threadgroup:</span>
<span class="line-added"> 541             addressSpace = AST::AddressSpace::Threadgroup;</span>
<span class="line-added"> 542             break;</span>
<span class="line-added"> 543         default:</span>
<span class="line-added"> 544             ASSERT(addressSpaceToken-&gt;type == Token::Type::Thread);</span>
<span class="line-added"> 545             addressSpace = AST::AddressSpace::Thread;</span>
<span class="line-added"> 546             break;</span>
<span class="line-added"> 547         }</span>
<span class="line-added"> 548         auto constructTypeFromSuffixAbbreviated = [&amp;](const TypeSuffixAbbreviated&amp; typeSuffixAbbreviated, Ref&lt;AST::UnnamedType&gt;&amp;&amp; previous) -&gt; Ref&lt;AST::UnnamedType&gt; {</span>
<span class="line-added"> 549             CodeLocation location(*addressSpaceToken, typeSuffixAbbreviated.location);</span>
<span class="line-added"> 550             switch (typeSuffixAbbreviated.token.type) {</span>
<span class="line-added"> 551             case Token::Type::Star:</span>
<span class="line-added"> 552                 return { AST::PointerType::create(location, addressSpace, WTFMove(previous)) };</span>
<span class="line-added"> 553             case Token::Type::SquareBracketPair:</span>
<span class="line-added"> 554                 return { AST::ArrayReferenceType::create(location, addressSpace, WTFMove(previous)) };</span>
<span class="line-added"> 555             default:</span>
<span class="line-added"> 556                 ASSERT(typeSuffixAbbreviated.token.type == Token::Type::LeftSquareBracket);</span>
<span class="line-added"> 557                 return { AST::ArrayType::create(location, WTFMove(previous), *typeSuffixAbbreviated.numElements) };</span>
<span class="line-added"> 558             }</span>
<span class="line-added"> 559         };</span>
<span class="line-added"> 560         PARSE(firstTypeSuffixAbbreviated, TypeSuffixAbbreviated);</span>
<span class="line-added"> 561         Ref&lt;AST::UnnamedType&gt; result = AST::TypeReference::create(WTFMove(*addressSpaceToken), name-&gt;stringView(m_lexer).toString(), WTFMove(*typeArguments));</span>
<span class="line-added"> 562         auto next = constructTypeFromSuffixAbbreviated(*firstTypeSuffixAbbreviated, WTFMove(result));</span>
 563         result = WTFMove(next);
<span class="line-added"> 564         while (true) {</span>
<span class="line-added"> 565             PEEK(nextToken);</span>
<span class="line-added"> 566             if (nextToken-&gt;type != Token::Type::Star</span>
<span class="line-added"> 567                 &amp;&amp; nextToken-&gt;type != Token::Type::SquareBracketPair</span>
<span class="line-added"> 568                 &amp;&amp; nextToken-&gt;type != Token::Type::LeftSquareBracket) {</span>
<span class="line-added"> 569                 break;</span>
<span class="line-added"> 570             }</span>
<span class="line-added"> 571             PARSE(typeSuffixAbbreviated, TypeSuffixAbbreviated);</span>
<span class="line-added"> 572             // FIXME: The nesting here might be in the wrong order.</span>
<span class="line-added"> 573             next = constructTypeFromSuffixAbbreviated(*typeSuffixAbbreviated, WTFMove(result));</span>
<span class="line-added"> 574             result = WTFMove(next);</span>
<span class="line-added"> 575         }</span>
<span class="line-added"> 576         return WTFMove(result);</span>
 577     }
 578 
<span class="line-modified"> 579     auto constructTypeFromSuffixNonAbbreviated = [&amp;](const TypeSuffixNonAbbreviated&amp; typeSuffixNonAbbreviated, Ref&lt;AST::UnnamedType&gt;&amp;&amp; previous) -&gt; Ref&lt;AST::UnnamedType&gt; {</span>
<span class="line-modified"> 580         CodeLocation location(*name, typeSuffixNonAbbreviated.location);</span>














 581         switch (typeSuffixNonAbbreviated.token.type) {
<span class="line-modified"> 582         case Token::Type::Star:</span>
<span class="line-modified"> 583             return { AST::PointerType::create(location, *typeSuffixNonAbbreviated.addressSpace, WTFMove(previous)) };</span>
<span class="line-modified"> 584         case Token::Type::SquareBracketPair:</span>
<span class="line-modified"> 585             return { AST::ArrayReferenceType::create(location, *typeSuffixNonAbbreviated.addressSpace, WTFMove(previous)) };</span>
 586         default:
<span class="line-modified"> 587             ASSERT(typeSuffixNonAbbreviated.token.type == Token::Type::LeftSquareBracket);</span>
<span class="line-modified"> 588             return { AST::ArrayType::create(location, WTFMove(previous), *typeSuffixNonAbbreviated.numElements) };</span>
 589         }
 590     };
<span class="line-modified"> 591     Ref&lt;AST::UnnamedType&gt; result = AST::TypeReference::create(*name, name-&gt;stringView(m_lexer).toString(), WTFMove(*typeArguments));</span>

 592     while (true) {
<span class="line-modified"> 593         PEEK(nextToken);</span>
<span class="line-modified"> 594         if (nextToken-&gt;type != Token::Type::Star</span>
<span class="line-modified"> 595             &amp;&amp; nextToken-&gt;type != Token::Type::SquareBracketPair</span>
<span class="line-modified"> 596             &amp;&amp; nextToken-&gt;type != Token::Type::LeftSquareBracket) {</span>
 597             break;
<span class="line-added"> 598         }</span>
<span class="line-added"> 599         PARSE(typeSuffixNonAbbreviated, TypeSuffixNonAbbreviated);</span>
 600         // FIXME: The nesting here might be in the wrong order.
 601         auto next = constructTypeFromSuffixNonAbbreviated(*typeSuffixNonAbbreviated, WTFMove(result));
 602         result = WTFMove(next);
 603     }

 604     return WTFMove(result);
 605 }
 606 

















 607 auto Parser::parseTypeDefinition() -&gt; Expected&lt;AST::TypeDefinition, Error&gt;
 608 {
<span class="line-modified"> 609     CONSUME_TYPE(origin, Typedef);</span>
<span class="line-modified"> 610     CONSUME_TYPE(name, Identifier);</span>
<span class="line-modified"> 611     CONSUME_TYPE(equals, EqualsSign);</span>
<span class="line-modified"> 612     PARSE(type, Type);</span>
<span class="line-modified"> 613     CONSUME_TYPE(semicolon, Semicolon);</span>
<span class="line-modified"> 614     return AST::TypeDefinition({ *origin, *semicolon }, name-&gt;stringView(m_lexer).toString(), WTFMove(*type));</span>










 615 }
 616 
 617 auto Parser::parseBuiltInSemantic() -&gt; Expected&lt;AST::BuiltInSemantic, Error&gt;
 618 {
<span class="line-modified"> 619     auto origin = consumeTypes&lt;</span>
<span class="line-modified"> 620         Token::Type::SVInstanceID,</span>
<span class="line-modified"> 621         Token::Type::SVVertexID,</span>
<span class="line-modified"> 622         Token::Type::PSize,</span>
<span class="line-modified"> 623         Token::Type::SVPosition,</span>
<span class="line-modified"> 624         Token::Type::SVIsFrontFace,</span>
<span class="line-modified"> 625         Token::Type::SVSampleIndex,</span>
<span class="line-modified"> 626         Token::Type::SVInnerCoverage,</span>
<span class="line-modified"> 627         Token::Type::SVTarget,</span>
<span class="line-modified"> 628         Token::Type::SVDepth,</span>
<span class="line-modified"> 629         Token::Type::SVCoverage,</span>
<span class="line-modified"> 630         Token::Type::SVDispatchThreadID,</span>
<span class="line-modified"> 631         Token::Type::SVGroupID,</span>
<span class="line-modified"> 632         Token::Type::SVGroupIndex,</span>
<span class="line-modified"> 633         Token::Type::SVGroupThreadID&gt;();</span>
 634     if (!origin)
<span class="line-modified"> 635         return makeUnexpected(origin.error());</span>
 636 
 637     switch (origin-&gt;type) {
<span class="line-modified"> 638     case Token::Type::SVInstanceID:</span>
<span class="line-modified"> 639         return AST::BuiltInSemantic({ *origin }, AST::BuiltInSemantic::Variable::SVInstanceID);</span>
<span class="line-modified"> 640     case Token::Type::SVVertexID:</span>
<span class="line-modified"> 641         return AST::BuiltInSemantic({ *origin }, AST::BuiltInSemantic::Variable::SVVertexID);</span>
<span class="line-modified"> 642     case Token::Type::PSize:</span>
<span class="line-modified"> 643         return AST::BuiltInSemantic({ *origin }, AST::BuiltInSemantic::Variable::PSize);</span>
<span class="line-modified"> 644     case Token::Type::SVPosition:</span>
<span class="line-modified"> 645         return AST::BuiltInSemantic({ *origin }, AST::BuiltInSemantic::Variable::SVPosition);</span>
<span class="line-modified"> 646     case Token::Type::SVIsFrontFace:</span>
<span class="line-modified"> 647         return AST::BuiltInSemantic({ *origin }, AST::BuiltInSemantic::Variable::SVIsFrontFace);</span>
<span class="line-modified"> 648     case Token::Type::SVSampleIndex:</span>
<span class="line-modified"> 649         return AST::BuiltInSemantic({ *origin }, AST::BuiltInSemantic::Variable::SVSampleIndex);</span>
<span class="line-modified"> 650     case Token::Type::SVInnerCoverage:</span>
<span class="line-modified"> 651         return AST::BuiltInSemantic({ *origin }, AST::BuiltInSemantic::Variable::SVInnerCoverage);</span>
<span class="line-modified"> 652     case Token::Type::SVTarget: {</span>
<span class="line-modified"> 653         auto target = consumeNonNegativeIntegralLiteral(); // FIXME: https://bugs.webkit.org/show_bug.cgi?id=195807 Make this work with strings like &quot;SV_Target0&quot;.</span>
 654         if (!target)
<span class="line-modified"> 655             return makeUnexpected(target.error());</span>
<span class="line-modified"> 656         return AST::BuiltInSemantic({ *origin }, AST::BuiltInSemantic::Variable::SVTarget, *target);</span>
<span class="line-modified"> 657     }</span>
<span class="line-modified"> 658     case Token::Type::SVDepth:</span>
<span class="line-modified"> 659         return AST::BuiltInSemantic({ *origin }, AST::BuiltInSemantic::Variable::SVDepth);</span>
<span class="line-modified"> 660     case Token::Type::SVCoverage:</span>
<span class="line-modified"> 661         return AST::BuiltInSemantic({ *origin }, AST::BuiltInSemantic::Variable::SVCoverage);</span>
<span class="line-modified"> 662     case Token::Type::SVDispatchThreadID:</span>
<span class="line-modified"> 663         return AST::BuiltInSemantic({ *origin }, AST::BuiltInSemantic::Variable::SVDispatchThreadID);</span>
<span class="line-modified"> 664     case Token::Type::SVGroupID:</span>
<span class="line-modified"> 665         return AST::BuiltInSemantic({ *origin }, AST::BuiltInSemantic::Variable::SVGroupID);</span>
<span class="line-modified"> 666     case Token::Type::SVGroupIndex:</span>
<span class="line-modified"> 667         return AST::BuiltInSemantic({ *origin }, AST::BuiltInSemantic::Variable::SVGroupIndex);</span>
 668     default:
<span class="line-modified"> 669         ASSERT(origin-&gt;type == Token::Type::SVGroupThreadID);</span>
<span class="line-modified"> 670         return AST::BuiltInSemantic({ *origin }, AST::BuiltInSemantic::Variable::SVGroupThreadID);</span>
 671     }
 672 }
 673 
 674 auto Parser::parseResourceSemantic() -&gt; Expected&lt;AST::ResourceSemantic, Error&gt;
 675 {
<span class="line-modified"> 676     CONSUME_TYPE(origin, Register);</span>
<span class="line-modified"> 677     CONSUME_TYPE(leftParenthesis, LeftParenthesis);</span>

 678 
<span class="line-modified"> 679     CONSUME_TYPE(info, Identifier);</span>
<span class="line-modified"> 680     auto infoStringView = info-&gt;stringView(m_lexer);</span>
<span class="line-modified"> 681     if (infoStringView.length() &lt; 2 || (infoStringView[0] != &#39;u&#39;</span>
<span class="line-modified"> 682         &amp;&amp; infoStringView[0] != &#39;t&#39;</span>
<span class="line-modified"> 683         &amp;&amp; infoStringView[0] != &#39;b&#39;</span>
<span class="line-modified"> 684         &amp;&amp; infoStringView[0] != &#39;s&#39;))</span>
<span class="line-modified"> 685         return makeUnexpected(Error(makeString(infoStringView.substring(0, 1), &quot; is not a known resource type (&#39;u&#39;, &#39;t&#39;, &#39;b&#39;, or &#39;s&#39;)&quot;)));</span>





 686 
 687     AST::ResourceSemantic::Mode mode;
<span class="line-modified"> 688     switch (infoStringView[0]) {</span>
 689     case &#39;u&#39;:
 690         mode = AST::ResourceSemantic::Mode::UnorderedAccessView;
 691         break;
 692     case &#39;t&#39;:
 693         mode = AST::ResourceSemantic::Mode::Texture;
 694         break;
 695     case &#39;b&#39;:
 696         mode = AST::ResourceSemantic::Mode::Buffer;
 697         break;
 698     case &#39;s&#39;:
 699         mode = AST::ResourceSemantic::Mode::Sampler;
 700         break;
 701     }
 702 
<span class="line-modified"> 703     auto index = recognizeSimpleUnsignedInteger(infoStringView.substring(1));</span>
 704     if (!index)
<span class="line-modified"> 705         return makeUnexpected(index.error());</span>
 706 
 707     unsigned space = 0;
<span class="line-modified"> 708     if (tryType(Token::Type::Comma)) {</span>
<span class="line-modified"> 709         CONSUME_TYPE(spaceToken, Identifier);</span>
<span class="line-modified"> 710         auto spaceTokenStringView = spaceToken-&gt;stringView(m_lexer);</span>
<span class="line-modified"> 711         StringView prefix { &quot;space&quot; };</span>
<span class="line-modified"> 712         if (!spaceTokenStringView.startsWith(prefix))</span>
<span class="line-modified"> 713             return makeUnexpected(Error(makeString(&quot;Second argument to resource semantic &quot;, spaceTokenStringView, &quot; needs be of the form &#39;space0&#39;&quot;)));</span>
<span class="line-modified"> 714         if (spaceTokenStringView.length() &lt;= prefix.length())</span>
<span class="line-modified"> 715             return makeUnexpected(Error(makeString(&quot;Second argument to resource semantic &quot;, spaceTokenStringView, &quot; needs be of the form &#39;space0&#39;&quot;)));</span>
<span class="line-modified"> 716         auto spaceValue = recognizeSimpleUnsignedInteger(spaceTokenStringView.substring(prefix.length()));</span>

 717         if (!spaceValue)
<span class="line-modified"> 718             return makeUnexpected(spaceValue.error());</span>
 719         space = *spaceValue;
 720     }
 721 
<span class="line-modified"> 722     CONSUME_TYPE(rightParenthesis, RightParenthesis);</span>


 723 
<span class="line-modified"> 724     return AST::ResourceSemantic({ *origin, *rightParenthesis }, mode, *index, space);</span>
 725 }
 726 
 727 auto Parser::parseSpecializationConstantSemantic() -&gt; Expected&lt;AST::SpecializationConstantSemantic, Error&gt;
 728 {
<span class="line-modified"> 729     CONSUME_TYPE(origin, Specialized);</span>
<span class="line-modified"> 730     return AST::SpecializationConstantSemantic(*origin);</span>


 731 }
 732 
 733 auto Parser::parseStageInOutSemantic() -&gt; Expected&lt;AST::StageInOutSemantic, Error&gt;
 734 {
<span class="line-modified"> 735     CONSUME_TYPE(origin, Attribute);</span>
<span class="line-modified"> 736     CONSUME_TYPE(leftParenthesis, LeftParenthesis);</span>





 737 
 738     auto index = consumeNonNegativeIntegralLiteral();
 739     if (!index)
<span class="line-modified"> 740         return makeUnexpected(index.error());</span>
 741 
<span class="line-modified"> 742     CONSUME_TYPE(rightParenthesis, RightParenthesis);</span>


 743 
<span class="line-modified"> 744     return AST::StageInOutSemantic({ *origin, *rightParenthesis }, *index);</span>
 745 }
 746 
<span class="line-modified"> 747 auto Parser::parseSemantic() -&gt; Expected&lt;std::unique_ptr&lt;AST::Semantic&gt;, Error&gt;</span>
 748 {
<span class="line-modified"> 749     if (!tryType(Token::Type::Colon))</span>
<span class="line-modified"> 750         return { nullptr };</span>





















 751 
<span class="line-modified"> 752     PEEK(token);</span>
<span class="line-added"> 753     switch (token-&gt;type) {</span>
<span class="line-added"> 754     case Token::Type::Attribute: {</span>
<span class="line-added"> 755         PARSE(result, StageInOutSemantic);</span>
<span class="line-added"> 756         return { makeUnique&lt;AST::Semantic&gt;(WTFMove(*result)) };</span>
<span class="line-added"> 757     }</span>
<span class="line-added"> 758     case Token::Type::Specialized:  {</span>
<span class="line-added"> 759         PARSE(result, SpecializationConstantSemantic);</span>
<span class="line-added"> 760         return { makeUnique&lt;AST::Semantic&gt;(WTFMove(*result)) };</span>
<span class="line-added"> 761     }</span>
<span class="line-added"> 762     case Token::Type::Register:  {</span>
<span class="line-added"> 763         PARSE(result, ResourceSemantic);</span>
<span class="line-added"> 764         return { makeUnique&lt;AST::Semantic&gt;(WTFMove(*result)) };</span>
<span class="line-added"> 765     }</span>
<span class="line-added"> 766     default:  {</span>
<span class="line-added"> 767         PARSE(result, BuiltInSemantic);</span>
<span class="line-added"> 768         return { makeUnique&lt;AST::Semantic&gt;(WTFMove(*result)) };</span>
<span class="line-added"> 769     }</span>
<span class="line-added"> 770     }</span>
 771 }
 772 AST::Qualifiers Parser::parseQualifiers()
 773 {
 774     AST::Qualifiers qualifiers;
<span class="line-modified"> 775     while (auto next = tryType(Token::Type::Qualifier)) {</span>
<span class="line-modified"> 776         auto nextStringView = next-&gt;stringView(m_lexer);</span>
<span class="line-modified"> 777         if (&quot;nointerpolation&quot; == nextStringView)</span>
<span class="line-modified"> 778             qualifiers.append(AST::Qualifier::Nointerpolation);</span>
<span class="line-modified"> 779         else if (&quot;noperspective&quot; == nextStringView)</span>
<span class="line-modified"> 780             qualifiers.append(AST::Qualifier::Noperspective);</span>
<span class="line-modified"> 781         else if (&quot;uniform&quot; == nextStringView)</span>
<span class="line-modified"> 782             qualifiers.append(AST::Qualifier::Uniform);</span>
<span class="line-modified"> 783         else if (&quot;centroid&quot; == nextStringView)</span>
<span class="line-modified"> 784             qualifiers.append(AST::Qualifier::Centroid);</span>
<span class="line-modified"> 785         else {</span>
<span class="line-modified"> 786             ASSERT(&quot;sample&quot; == nextStringView);</span>
<span class="line-modified"> 787             qualifiers.append(AST::Qualifier::Sample);</span>
<span class="line-modified"> 788         }</span>


 789     }
 790     return qualifiers;
 791 }
 792 
 793 auto Parser::parseStructureElement() -&gt; Expected&lt;AST::StructureElement, Error&gt;
 794 {
<span class="line-modified"> 795     PEEK(origin);</span>


 796 
 797     AST::Qualifiers qualifiers = parseQualifiers();
 798 
<span class="line-modified"> 799     PARSE(type, Type);</span>
<span class="line-modified"> 800     CONSUME_TYPE(name, Identifier);</span>
<span class="line-modified"> 801     PARSE(semantic, Semantic);</span>
<span class="line-modified"> 802     CONSUME_TYPE(semicolon, Semicolon);</span>












 803 
<span class="line-modified"> 804     return AST::StructureElement({ *origin, *semicolon }, WTFMove(qualifiers), WTFMove(*type), name-&gt;stringView(m_lexer).toString(), WTFMove(*semantic));</span>







 805 }
 806 
 807 auto Parser::parseStructureDefinition() -&gt; Expected&lt;AST::StructureDefinition, Error&gt;
 808 {
<span class="line-modified"> 809     CONSUME_TYPE(origin, Struct);</span>
<span class="line-modified"> 810     CONSUME_TYPE(name, Identifier);</span>
<span class="line-modified"> 811     CONSUME_TYPE(leftCurlyBracket, LeftCurlyBracket);</span>








 812 
 813     AST::StructureElements structureElements;
<span class="line-modified"> 814     while (!peekType(Token::Type::RightCurlyBracket)) {</span>
<span class="line-modified"> 815         PARSE(structureElement, StructureElement);</span>
<span class="line-modified"> 816         structureElements.append(WTFMove(*structureElement));</span>





 817     }
 818 
<span class="line-modified"> 819     auto rightCurlyBracket = m_lexer.consumeToken();</span>


 820 
<span class="line-modified"> 821     return AST::StructureDefinition({ *origin, rightCurlyBracket }, name-&gt;stringView(m_lexer).toString(), WTFMove(structureElements));</span>
 822 }
 823 
 824 auto Parser::parseEnumerationDefinition() -&gt; Expected&lt;AST::EnumerationDefinition, Error&gt;
 825 {
<span class="line-modified"> 826     CONSUME_TYPE(origin, Enum);</span>
<span class="line-modified"> 827     CONSUME_TYPE(name, Identifier);</span>





 828 
<span class="line-modified"> 829     auto type = ([&amp;]() -&gt; Expected&lt;Ref&lt;AST::UnnamedType&gt;, Error&gt; {</span>
<span class="line-modified"> 830         if (tryType(Token::Type::Colon)) {</span>
<span class="line-modified"> 831             PARSE(parsedType, Type);</span>


 832             return WTFMove(*parsedType);
 833         }
<span class="line-modified"> 834         return { AST::TypeReference::create(*origin, &quot;int&quot;_str, AST::TypeArguments()) };</span>
 835     })();
 836     if (!type)
<span class="line-modified"> 837         return makeUnexpected(type.error());</span>
 838 
<span class="line-modified"> 839     CONSUME_TYPE(leftCurlyBracket, LeftCurlyBracket);</span>


 840 
<span class="line-modified"> 841     int64_t nextValue = 0;</span>
<span class="line-modified"> 842     PARSE(firstEnumerationMember, EnumerationMember, nextValue);</span>
<span class="line-modified"> 843     nextValue = firstEnumerationMember-&gt;value() + 1;</span>
 844 
<span class="line-modified"> 845     AST::EnumerationDefinition result({ }, name-&gt;stringView(m_lexer).toString(), WTFMove(*type));</span>
 846     auto success = result.add(WTFMove(*firstEnumerationMember));
 847     if (!success)
 848         return fail(&quot;Cannot add enumeration member&quot;_str);
 849 
<span class="line-modified"> 850     while (tryType(Token::Type::Comma)) {</span>
<span class="line-modified"> 851         PARSE(member, EnumerationMember, nextValue);</span>
<span class="line-modified"> 852         nextValue = member-&gt;value() + 1;</span>

 853         success = result.add(WTFMove(*member));
 854         if (!success)
 855             return fail(&quot;Cannot add enumeration member&quot;_str);
 856     }
 857 
<span class="line-modified"> 858     CONSUME_TYPE(rightCurlyBracket, RightCurlyBracket);</span>
<span class="line-modified"> 859     result.updateCodeLocation({ *origin, *rightCurlyBracket});</span>

 860 
 861     return WTFMove(result);
 862 }
 863 
<span class="line-modified"> 864 auto Parser::parseEnumerationMember(int64_t defaultValue) -&gt; Expected&lt;AST::EnumerationMember, Error&gt;</span>
 865 {
<span class="line-modified"> 866     CONSUME_TYPE(identifier, Identifier);</span>
<span class="line-modified"> 867     auto name = identifier-&gt;stringView(m_lexer).toString();</span>
<span class="line-modified"> 868 </span>
<span class="line-modified"> 869     if (tryType(Token::Type::EqualsSign)) {</span>
<span class="line-added"> 870         PARSE(constantExpression, ConstantExpression);</span>
 871 
<span class="line-modified"> 872         Optional&lt;int64_t&gt; value;</span>
<span class="line-modified"> 873         constantExpression-&gt;visit(WTF::makeVisitor([&amp;](AST::IntegerLiteral&amp; integerLiteral) {</span>
<span class="line-modified"> 874             value = integerLiteral.value();</span>
<span class="line-modified"> 875         }, [&amp;](AST::UnsignedIntegerLiteral&amp; unsignedIntegerLiteral) {</span>
<span class="line-modified"> 876             value = unsignedIntegerLiteral.value();</span>
<span class="line-added"> 877         }, [&amp;](AST::FloatLiteral&amp;) {</span>
<span class="line-added"> 878         }, [&amp;](AST::NullLiteral&amp;) {</span>
<span class="line-added"> 879         }, [&amp;](AST::BooleanLiteral&amp;) {</span>
<span class="line-added"> 880         }, [&amp;](AST::EnumerationMemberLiteral&amp;) {</span>
<span class="line-added"> 881         }));</span>
<span class="line-added"> 882 </span>
<span class="line-added"> 883         if (!value)</span>
<span class="line-added"> 884             return makeUnexpected(Error(&quot;enum initialization values can only be an int or uint constant.&quot;));</span>
<span class="line-added"> 885         return AST::EnumerationMember(*identifier, WTFMove(name), *value);</span>
 886     }
<span class="line-modified"> 887     return AST::EnumerationMember(*identifier, WTFMove(name), defaultValue);</span>
 888 }
 889 
 890 auto Parser::parseNativeTypeDeclaration() -&gt; Expected&lt;AST::NativeTypeDeclaration, Error&gt;
 891 {
<span class="line-modified"> 892     CONSUME_TYPE(origin, Native);</span>
<span class="line-modified"> 893     CONSUME_TYPE(parsedTypedef, Typedef);</span>
<span class="line-modified"> 894     CONSUME_TYPE(name, Identifier);</span>
<span class="line-modified"> 895     PARSE(typeArguments, TypeArguments);</span>
<span class="line-modified"> 896     CONSUME_TYPE(semicolon, Semicolon);</span>






 897 
<span class="line-modified"> 898     return AST::NativeTypeDeclaration({ *origin, *semicolon }, name-&gt;stringView(m_lexer).toString(), WTFMove(*typeArguments));</span>








 899 }
 900 
 901 auto Parser::parseNumThreadsFunctionAttribute() -&gt; Expected&lt;AST::NumThreadsFunctionAttribute, Error&gt;
 902 {
<span class="line-modified"> 903     CONSUME_TYPE(origin, NumThreads);</span>
<span class="line-modified"> 904     CONSUME_TYPE(leftParenthesis, LeftParenthesis);</span>





 905 
 906     auto width = consumeNonNegativeIntegralLiteral();
 907     if (!width)
<span class="line-modified"> 908         return makeUnexpected(width.error());</span>
 909 
<span class="line-modified"> 910     CONSUME_TYPE(comma, Comma);</span>


 911 
 912     auto height = consumeNonNegativeIntegralLiteral();
 913     if (!height)
<span class="line-modified"> 914         return makeUnexpected(height.error());</span>
 915 
<span class="line-modified"> 916     CONSUME_TYPE(secondComma, Comma);</span>


 917 
 918     auto depth = consumeNonNegativeIntegralLiteral();
 919     if (!depth)
<span class="line-modified"> 920         return makeUnexpected(depth.error());</span>
 921 
<span class="line-modified"> 922     CONSUME_TYPE(rightParenthesis, RightParenthesis);</span>


 923 
<span class="line-modified"> 924     return AST::NumThreadsFunctionAttribute({ *origin, *rightParenthesis }, *width, *height, *depth);</span>
 925 }
 926 
 927 auto Parser::parseAttributeBlock() -&gt; Expected&lt;AST::AttributeBlock, Error&gt;
 928 {
<span class="line-modified"> 929     CONSUME_TYPE(leftSquareBracket, LeftSquareBracket);</span>


 930 
 931     AST::AttributeBlock result;
 932 
<span class="line-modified"> 933     while (!tryType(Token::Type::RightSquareBracket)) {</span>
<span class="line-modified"> 934         PARSE(numThreadsFunctionAttribute, NumThreadsFunctionAttribute);</span>
<span class="line-modified"> 935         result.append(WTFMove(*numThreadsFunctionAttribute));</span>







 936     }
 937 




 938     return WTFMove(result);
 939 }
 940 
 941 auto Parser::parseParameter() -&gt; Expected&lt;AST::VariableDeclaration, Error&gt;
 942 {
<span class="line-modified"> 943     auto startOffset = m_lexer.peek().startOffset();</span>


 944 
 945     AST::Qualifiers qualifiers = parseQualifiers();
<span class="line-modified"> 946     PARSE(type, Type);</span>



 947 
 948     String name;
<span class="line-modified"> 949     if (auto token = tryType(Token::Type::Identifier))</span>
<span class="line-modified"> 950         name = token-&gt;stringView(m_lexer).toString();</span>
 951 
<span class="line-modified"> 952     PARSE(semantic, Semantic);</span>
<span class="line-modified"> 953 </span>
<span class="line-modified"> 954     auto endOffset = m_lexer.peek().startOffset();</span>



 955 
<span class="line-modified"> 956     return AST::VariableDeclaration({ startOffset, endOffset, m_lexer.nameSpace() }, WTFMove(qualifiers), { WTFMove(*type) }, WTFMove(name), WTFMove(*semantic), nullptr);</span>
 957 }
 958 
 959 auto Parser::parseParameters() -&gt; Expected&lt;AST::VariableDeclarations, Error&gt;
 960 {




 961     AST::VariableDeclarations parameters;
<span class="line-modified"> 962 </span>
<span class="line-added"> 963     CONSUME_TYPE(leftParenthesis, LeftParenthesis);</span>
<span class="line-added"> 964 </span>
<span class="line-added"> 965     if (tryType(Token::Type::RightParenthesis))</span>
 966         return WTFMove(parameters);
 967 
<span class="line-modified"> 968     PARSE(firstParameter, Parameter);</span>
<span class="line-modified"> 969     parameters.append(makeUniqueRef&lt;AST::VariableDeclaration&gt;(WTFMove(*firstParameter)));</span>


 970 
<span class="line-modified"> 971     while (tryType(Token::Type::Comma)) {</span>
<span class="line-modified"> 972         PARSE(parameter, Parameter);</span>
<span class="line-modified"> 973         parameters.append(makeUniqueRef&lt;AST::VariableDeclaration&gt;(WTFMove(*parameter)));</span>


 974     }
 975 
<span class="line-modified"> 976     CONSUME_TYPE(rightParenthesis, RightParenthesis);</span>


 977 
 978     return WTFMove(parameters);
 979 }
 980 
 981 auto Parser::parseFunctionDefinition() -&gt; Expected&lt;AST::FunctionDefinition, Error&gt;
 982 {
<span class="line-modified"> 983     PARSE(functionDeclaration, FunctionDeclaration);</span>
<span class="line-modified"> 984     PARSE(block, Block);</span>






 985     return AST::FunctionDefinition(WTFMove(*functionDeclaration), WTFMove(*block));
 986 }
 987 
<span class="line-modified"> 988 auto Parser::parseComputeFunctionDeclaration() -&gt; Expected&lt;AST::FunctionDeclaration, Error&gt;</span>
 989 {
<span class="line-modified"> 990     PEEK(origin);</span>


 991 
<span class="line-modified"> 992     PARSE(attributeBlock, AttributeBlock);</span>
<span class="line-modified"> 993     CONSUME_TYPE(compute, Compute);</span>
<span class="line-modified"> 994     PARSE(type, Type);</span>
<span class="line-modified"> 995     CONSUME_TYPE(name, Identifier);</span>
<span class="line-modified"> 996     PARSE(parameters, Parameters);</span>
<span class="line-modified"> 997     PARSE(semantic, Semantic);</span>





















 998 
<span class="line-modified"> 999     auto endOffset = m_lexer.peek().startOffset();</span>


1000 
<span class="line-modified">1001     bool isOperator = false;</span>
<span class="line-modified">1002     return AST::FunctionDeclaration({ origin-&gt;startOffset(), endOffset, m_lexer.nameSpace() }, WTFMove(*attributeBlock), AST::EntryPointType::Compute, WTFMove(*type), name-&gt;stringView(m_lexer).toString(), WTFMove(*parameters), WTFMove(*semantic), isOperator, m_mode);</span>
<span class="line-modified">1003 }</span>
1004 
<span class="line-modified">1005 auto Parser::parseVertexOrFragmentFunctionDeclaration() -&gt; Expected&lt;AST::FunctionDeclaration, Error&gt;</span>
<span class="line-modified">1006 {</span>
<span class="line-modified">1007     auto entryPoint = consumeTypes&lt;Token::Type::Vertex, Token::Type::Fragment&gt;();</span>
<span class="line-added">1008     if (!entryPoint)</span>
<span class="line-added">1009         return makeUnexpected(entryPoint.error());</span>
<span class="line-added">1010     auto entryPointType = (entryPoint-&gt;type == Token::Type::Vertex) ? AST::EntryPointType::Vertex : AST::EntryPointType::Fragment;</span>
1011 
<span class="line-modified">1012     PARSE(type, Type);</span>
<span class="line-added">1013     CONSUME_TYPE(name, Identifier);</span>
<span class="line-added">1014     PARSE(parameters, Parameters);</span>
<span class="line-added">1015     PARSE(semantic, Semantic);</span>
1016 
<span class="line-modified">1017     auto endOffset = m_lexer.peek().startOffset();</span>





1018 
<span class="line-modified">1019     bool isOperator = false;</span>
<span class="line-added">1020     return AST::FunctionDeclaration({ entryPoint-&gt;startOffset(), endOffset, m_lexer.nameSpace() }, { }, entryPointType, WTFMove(*type), name-&gt;stringView(m_lexer).toString(), WTFMove(*parameters), WTFMove(*semantic), isOperator, m_mode);</span>
1021 }
1022 
1023 auto Parser::parseRegularFunctionDeclaration() -&gt; Expected&lt;AST::FunctionDeclaration, Error&gt;
1024 {
<span class="line-modified">1025     PEEK(origin);</span>


1026 
<span class="line-modified">1027     PARSE(type, Type);</span>


1028 
<span class="line-modified">1029     auto name = consumeTypes&lt;Token::Type::Identifier, Token::Type::OperatorName&gt;();</span>
1030     if (!name)
<span class="line-modified">1031         return makeUnexpected(name.error());</span>
<span class="line-modified">1032     auto isOperator = name-&gt;type == Token::Type::OperatorName;</span>
1033 
<span class="line-modified">1034     PARSE(parameters, Parameters);</span>
<span class="line-modified">1035     PARSE(semantic, Semantic);</span>

1036 
<span class="line-modified">1037     auto endOffset = m_lexer.peek().startOffset();</span>





1038 
<span class="line-modified">1039     return AST::FunctionDeclaration({ origin-&gt;startOffset(), endOffset, m_lexer.nameSpace() }, { }, WTF::nullopt, WTFMove(*type), name-&gt;stringView(m_lexer).toString(), WTFMove(*parameters), WTFMove(*semantic), isOperator, m_mode);</span>
1040 }
1041 
1042 auto Parser::parseOperatorFunctionDeclaration() -&gt; Expected&lt;AST::FunctionDeclaration, Error&gt;
1043 {
<span class="line-modified">1044     CONSUME_TYPE(origin, Operator);</span>
<span class="line-modified">1045     PARSE(type, Type);</span>
<span class="line-modified">1046     PARSE(parameters, Parameters);</span>
<span class="line-modified">1047     PARSE(semantic, Semantic);</span>



1048 
<span class="line-modified">1049     auto endOffset = m_lexer.peek().startOffset();</span>


1050 
1051     bool isOperator = true;
<span class="line-modified">1052     return AST::FunctionDeclaration({ origin-&gt;startOffset(), endOffset, m_lexer.nameSpace() }, { }, WTF::nullopt, WTFMove(*type), &quot;operator cast&quot;_str, WTFMove(*parameters), WTFMove(*semantic), isOperator, m_mode);</span>








1053 }
1054 
1055 auto Parser::parseFunctionDeclaration() -&gt; Expected&lt;AST::FunctionDeclaration, Error&gt;
1056 {
<span class="line-modified">1057     PEEK(token);</span>
<span class="line-modified">1058     switch (token-&gt;type) {</span>
<span class="line-modified">1059     case Token::Type::Operator:</span>










1060         return parseOperatorFunctionDeclaration();
<span class="line-modified">1061     case Token::Type::Vertex:</span>
<span class="line-modified">1062     case Token::Type::Fragment:</span>
<span class="line-modified">1063         return parseVertexOrFragmentFunctionDeclaration();</span>
<span class="line-modified">1064     case Token::Type::LeftSquareBracket:</span>
<span class="line-modified">1065         return parseComputeFunctionDeclaration();</span>
<span class="line-added">1066     default:</span>
<span class="line-added">1067         return parseRegularFunctionDeclaration();</span>
<span class="line-added">1068     }</span>
1069 }
1070 
1071 auto Parser::parseNativeFunctionDeclaration() -&gt; Expected&lt;AST::NativeFunctionDeclaration, Error&gt;
1072 {
<span class="line-modified">1073     CONSUME_TYPE(native, Native);</span>
<span class="line-modified">1074     PARSE(functionDeclaration, FunctionDeclaration);</span>
<span class="line-modified">1075     CONSUME_TYPE(semicolon, Semicolon);</span>












1076 
1077     return AST::NativeFunctionDeclaration(WTFMove(*functionDeclaration));
1078 }
1079 
1080 auto Parser::parseBlock() -&gt; Expected&lt;AST::Block, Error&gt;
1081 {
<span class="line-modified">1082     CONSUME_TYPE(origin, LeftCurlyBracket);</span>
<span class="line-modified">1083     PARSE(result, BlockBody);</span>
<span class="line-modified">1084     CONSUME_TYPE(rightCurlyBracket, RightCurlyBracket);</span>
<span class="line-modified">1085     result-&gt;updateCodeLocation({ *origin, *rightCurlyBracket });</span>
<span class="line-modified">1086     return WTFMove(*result);</span>






1087 }
1088 
<span class="line-modified">1089 auto Parser::parseBlockBody() -&gt; Expected&lt;AST::Block, Error&gt;</span>
1090 {
<span class="line-added">1091     auto startOffset = m_lexer.peek().startOffset();</span>
<span class="line-added">1092 </span>
1093     AST::Statements statements;
<span class="line-modified">1094     while (!peekTypes&lt;Token::Type::RightCurlyBracket, Token::Type::Case, Token::Type::Default&gt;()) {</span>
<span class="line-modified">1095         PARSE(statement, Statement);</span>
<span class="line-modified">1096         statements.append(WTFMove(*statement));</span>





1097     }
<span class="line-modified">1098 </span>
<span class="line-added">1099     auto endOffset = m_lexer.peek().startOffset();</span>
<span class="line-added">1100 </span>
<span class="line-added">1101     return AST::Block({ startOffset, endOffset, m_lexer.nameSpace() }, WTFMove(statements));</span>
1102 }
1103 
1104 auto Parser::parseIfStatement() -&gt; Expected&lt;AST::IfStatement, Error&gt;
1105 {
<span class="line-modified">1106     CONSUME_TYPE(origin, If);</span>
<span class="line-modified">1107     CONSUME_TYPE(leftParenthesis, LeftParenthesis);</span>
<span class="line-modified">1108     PARSE(conditional, Expression);</span>
<span class="line-modified">1109     CONSUME_TYPE(rightParenthesis, RightParenthesis);</span>
<span class="line-modified">1110     PARSE(body, Statement);</span>














1111 
<span class="line-modified">1112     std::unique_ptr&lt;AST::Statement&gt; elseBody(nullptr);</span>
<span class="line-modified">1113     if (tryType(Token::Type::Else)) {</span>
<span class="line-modified">1114         PARSE(parsedElseBody, Statement);</span>
<span class="line-modified">1115         elseBody = (*parsedElseBody).moveToUniquePtr();</span>


1116     }
1117 
<span class="line-added">1118     auto endOffset = m_lexer.peek().startOffset();</span>
<span class="line-added">1119 </span>
1120     Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; castArguments;
1121     castArguments.append(WTFMove(*conditional));
<span class="line-modified">1122     auto boolCast = makeUniqueRef&lt;AST::CallExpression&gt;(Token(*origin), &quot;bool&quot;_str, WTFMove(castArguments));</span>
<span class="line-modified">1123     return AST::IfStatement({ origin-&gt;startOffset(), endOffset, m_lexer.nameSpace() }, WTFMove(boolCast), WTFMove(*body), WTFMove(elseBody));</span>
1124 }
1125 
1126 auto Parser::parseSwitchStatement() -&gt; Expected&lt;AST::SwitchStatement, Error&gt;
1127 {
<span class="line-modified">1128     CONSUME_TYPE(origin, Switch);</span>
<span class="line-modified">1129     CONSUME_TYPE(leftParenthesis, LeftParenthesis);</span>
<span class="line-modified">1130     PARSE(value, Expression);</span>
<span class="line-added">1131     CONSUME_TYPE(rightParenthesis, RightParenthesis);</span>
<span class="line-added">1132     CONSUME_TYPE(leftCurlyBracket, LeftCurlyBracket);</span>
1133 
<span class="line-modified">1134     Vector&lt;AST::SwitchCase&gt; switchCases;</span>
<span class="line-modified">1135     PEEK(nextToken);</span>
<span class="line-modified">1136     while (nextToken-&gt;type != Token::Type::RightCurlyBracket) {</span>
<span class="line-added">1137         PARSE(switchCase, SwitchCase);</span>
<span class="line-added">1138         switchCases.append(WTFMove(*switchCase));</span>
<span class="line-added">1139         PEEK(nextTokenInLoop);</span>
<span class="line-added">1140         nextToken = nextTokenInLoop;</span>
<span class="line-added">1141     }</span>
1142 
<span class="line-modified">1143     auto endToken = m_lexer.consumeToken();</span>


1144 
<span class="line-modified">1145     return AST::SwitchStatement({ *origin, endToken }, WTFMove(*value), WTFMove(switchCases));</span>
<span class="line-modified">1146 }</span>

1147 
<span class="line-modified">1148 auto Parser::parseSwitchCase() -&gt; Expected&lt;AST::SwitchCase, Error&gt;</span>
<span class="line-modified">1149 {</span>
<span class="line-modified">1150     auto origin = consumeTypes&lt;Token::Type::Case, Token::Type::Default&gt;();</span>
<span class="line-modified">1151     if (!origin)</span>
<span class="line-modified">1152         return makeUnexpected(origin.error());</span>






















1153 
1154     switch (origin-&gt;type) {
<span class="line-modified">1155     case Token::Type::Case: {</span>
<span class="line-modified">1156         PARSE(value, ConstantExpression);</span>
<span class="line-modified">1157         CONSUME_TYPE(colon, Colon);</span>

1158 
<span class="line-modified">1159         PARSE(block, BlockBody);</span>


1160 
<span class="line-modified">1161         return AST::SwitchCase({ origin-&gt;codeLocation,  block-&gt;codeLocation()}, WTFMove(*value), WTFMove(*block));</span>


1162     }
1163     default: {
<span class="line-modified">1164         ASSERT(origin-&gt;type == Token::Type::Default);</span>
<span class="line-modified">1165         CONSUME_TYPE(colon, Colon);</span>


1166 
<span class="line-modified">1167         PARSE(block, BlockBody);</span>
1168 
<span class="line-modified">1169         return AST::SwitchCase({ origin-&gt;codeLocation,  block-&gt;codeLocation()}, WTF::nullopt, WTFMove(*block));</span>
1170     }
1171     }
1172 }
1173 
1174 auto Parser::parseForLoop() -&gt; Expected&lt;AST::ForLoop, Error&gt;
1175 {
<span class="line-modified">1176     CONSUME_TYPE(origin, For);</span>
<span class="line-modified">1177     CONSUME_TYPE(leftParenthesis, LeftParenthesis);</span>

1178 
<span class="line-modified">1179     auto parseRemainder = [&amp;](UniqueRef&lt;AST::Statement&gt;&amp;&amp; initialization) -&gt; Expected&lt;AST::ForLoop, Error&gt; {</span>
<span class="line-modified">1180         CONSUME_TYPE(semicolon, Semicolon);</span>


1181 
<span class="line-modified">1182         std::unique_ptr&lt;AST::Expression&gt; condition(nullptr);</span>
<span class="line-added">1183         if (!tryType(Token::Type::Semicolon)) {</span>
1184             if (auto expression = parseExpression())
<span class="line-modified">1185                 condition = (*expression).moveToUniquePtr();</span>
<span class="line-modified">1186             else</span>
<span class="line-modified">1187                 return makeUnexpected(expression.error());</span>
<span class="line-modified">1188             CONSUME_TYPE(secondSemicolon, Semicolon);</span>
<span class="line-modified">1189         }</span>


1190 
<span class="line-modified">1191         std::unique_ptr&lt;AST::Expression&gt; increment(nullptr);</span>
<span class="line-added">1192         if (!tryType(Token::Type::RightParenthesis)) {</span>
1193             if (auto expression = parseExpression())
<span class="line-modified">1194                 increment = (*expression).moveToUniquePtr();</span>
<span class="line-modified">1195             else</span>
<span class="line-modified">1196                 return makeUnexpected(expression.error());</span>
<span class="line-modified">1197             CONSUME_TYPE(rightParenthesis, RightParenthesis);</span>
<span class="line-modified">1198         }</span>






1199 
<span class="line-modified">1200         PARSE(body, Statement);</span>
<span class="line-added">1201         CodeLocation location(origin-&gt;codeLocation, (*body)-&gt;codeLocation());</span>
<span class="line-added">1202         return AST::ForLoop(location, WTFMove(initialization), WTFMove(condition), WTFMove(increment), WTFMove(*body));</span>
1203     };
1204 




1205     auto variableDeclarations = backtrackingScope&lt;Expected&lt;AST::VariableDeclarationsStatement, Error&gt;&gt;([&amp;]() {
1206         return parseVariableDeclarations();
1207     });
<span class="line-modified">1208     if (variableDeclarations) {</span>
<span class="line-modified">1209         UniqueRef&lt;AST::Statement&gt; declarationStatement = makeUniqueRef&lt;AST::VariableDeclarationsStatement&gt;(WTFMove(*variableDeclarations));</span>
<span class="line-added">1210         return parseRemainder(WTFMove(declarationStatement));</span>
<span class="line-added">1211     }</span>
1212 
<span class="line-modified">1213     PARSE(effectfulExpression, EffectfulExpression);</span>


1214 
1215     return parseRemainder(WTFMove(*effectfulExpression));
1216 }
1217 
1218 auto Parser::parseWhileLoop() -&gt; Expected&lt;AST::WhileLoop, Error&gt;
1219 {
<span class="line-modified">1220     CONSUME_TYPE(origin, While);</span>
<span class="line-modified">1221     CONSUME_TYPE(leftParenthesis, LeftParenthesis);</span>
<span class="line-modified">1222     PARSE(conditional, Expression);</span>
<span class="line-modified">1223     CONSUME_TYPE(rightParenthesis, RightParenthesis);</span>
<span class="line-modified">1224     PARSE(body, Statement);</span>










1225 
<span class="line-modified">1226     CodeLocation location(origin-&gt;codeLocation,  (*body)-&gt;codeLocation());</span>
<span class="line-modified">1227     return AST::WhileLoop(location, WTFMove(*conditional), WTFMove(*body));</span>



1228 }
1229 
1230 auto Parser::parseDoWhileLoop() -&gt; Expected&lt;AST::DoWhileLoop, Error&gt;
1231 {
<span class="line-modified">1232     CONSUME_TYPE(origin, Do);</span>
<span class="line-modified">1233     PARSE(body, Statement);</span>
<span class="line-modified">1234     CONSUME_TYPE(whileKeyword, While);</span>
<span class="line-modified">1235     CONSUME_TYPE(leftParenthesis, LeftParenthesis);</span>
<span class="line-modified">1236     PARSE(conditional, Expression);</span>
<span class="line-modified">1237     CONSUME_TYPE(rightParenthesis, RightParenthesis);</span>
<span class="line-modified">1238     CONSUME_TYPE(semicolon, Semicolon);</span>




1239 
<span class="line-modified">1240     return AST::DoWhileLoop({ *origin, *semicolon}, WTFMove(*body), WTFMove(*conditional));</span>












1241 }
1242 
<span class="line-modified">1243 auto Parser::parseVariableDeclaration(Ref&lt;AST::UnnamedType&gt;&amp;&amp; type) -&gt; Expected&lt;AST::VariableDeclaration, Error&gt;</span>
1244 {
<span class="line-modified">1245     PEEK(origin);</span>


1246 
1247     auto qualifiers = parseQualifiers();
1248 
<span class="line-modified">1249     CONSUME_TYPE(name, Identifier);</span>
<span class="line-modified">1250     PARSE(semantic, Semantic);</span>
















1251 
<span class="line-modified">1252     std::unique_ptr&lt;AST::Expression&gt; initializer = nullptr;</span>
<span class="line-modified">1253     if (tryType(Token::Type::EqualsSign)) {</span>
<span class="line-modified">1254         PARSE(initializingExpression, PossibleTernaryConditional);</span>
<span class="line-modified">1255         initializer = initializingExpression.value().moveToUniquePtr();</span>

1256     }
1257 
<span class="line-modified">1258     auto endOffset = m_lexer.peek().startOffset();</span>
<span class="line-added">1259     return AST::VariableDeclaration({ origin-&gt;startOffset(), endOffset, m_lexer.nameSpace() }, WTFMove(qualifiers), { WTFMove(type) }, name-&gt;stringView(m_lexer).toString(), WTFMove(*semantic), WTFMove(initializer));</span>
1260 }
1261 
1262 auto Parser::parseVariableDeclarations() -&gt; Expected&lt;AST::VariableDeclarationsStatement, Error&gt;
1263 {
<span class="line-modified">1264     PEEK(origin);</span>


1265 
<span class="line-modified">1266     PARSE(type, Type);</span>


1267 
<span class="line-modified">1268     auto firstVariableDeclaration = parseVariableDeclaration(type-&gt;copyRef());</span>
1269     if (!firstVariableDeclaration)
<span class="line-modified">1270         return makeUnexpected(firstVariableDeclaration.error());</span>
1271 
<span class="line-modified">1272     Vector&lt;UniqueRef&lt;AST::VariableDeclaration&gt;&gt; result;</span>
<span class="line-modified">1273     result.append(makeUniqueRef&lt;AST::VariableDeclaration&gt;(WTFMove(*firstVariableDeclaration)));</span>
1274 
<span class="line-modified">1275     while (tryType(Token::Type::Comma)) {</span>
<span class="line-modified">1276         auto variableDeclaration = parseVariableDeclaration(type-&gt;copyRef());</span>
1277         if (!variableDeclaration)
<span class="line-modified">1278             return makeUnexpected(variableDeclaration.error());</span>
<span class="line-modified">1279         result.append(makeUniqueRef&lt;AST::VariableDeclaration&gt;(WTFMove(*variableDeclaration)));</span>
1280     }
1281 
<span class="line-modified">1282     auto endOffset = m_lexer.peek().startOffset();</span>
<span class="line-added">1283     return AST::VariableDeclarationsStatement({ origin-&gt;startOffset(), endOffset, m_lexer.nameSpace() }, WTFMove(result));</span>
1284 }
1285 
1286 auto Parser::parseStatement() -&gt; Expected&lt;UniqueRef&lt;AST::Statement&gt;, Error&gt;
1287 {
<span class="line-modified">1288     PEEK(token);</span>
<span class="line-modified">1289     switch (token-&gt;type) {</span>
<span class="line-modified">1290     case Token::Type::LeftCurlyBracket: {</span>
<span class="line-modified">1291         PARSE(block, Block);</span>
<span class="line-modified">1292         return { makeUniqueRef&lt;AST::Block&gt;(WTFMove(*block)) };</span>
<span class="line-modified">1293     }</span>
<span class="line-modified">1294     case Token::Type::If: {</span>
<span class="line-modified">1295         PARSE(ifStatement, IfStatement);</span>
<span class="line-modified">1296         return { makeUniqueRef&lt;AST::IfStatement&gt;(WTFMove(*ifStatement)) };</span>
<span class="line-modified">1297     }</span>
<span class="line-modified">1298     case Token::Type::Switch: {</span>
<span class="line-modified">1299         PARSE(switchStatement, SwitchStatement);</span>
<span class="line-modified">1300         return { makeUniqueRef&lt;AST::SwitchStatement&gt;(WTFMove(*switchStatement)) };</span>
<span class="line-modified">1301     }</span>
<span class="line-modified">1302     case Token::Type::For: {</span>
<span class="line-modified">1303         PARSE(forLoop, ForLoop);</span>
<span class="line-modified">1304         return { makeUniqueRef&lt;AST::ForLoop&gt;(WTFMove(*forLoop)) };</span>
<span class="line-modified">1305     }</span>
<span class="line-modified">1306     case Token::Type::While: {</span>
<span class="line-modified">1307         PARSE(whileLoop, WhileLoop);</span>
<span class="line-modified">1308         return { makeUniqueRef&lt;AST::WhileLoop&gt;(WTFMove(*whileLoop)) };</span>
<span class="line-modified">1309     }</span>
<span class="line-modified">1310     case Token::Type::Do: {</span>
<span class="line-modified">1311         PARSE(doWhileLoop, DoWhileLoop);</span>
<span class="line-modified">1312         return { makeUniqueRef&lt;AST::DoWhileLoop&gt;(WTFMove(*doWhileLoop)) };</span>
<span class="line-modified">1313     }</span>
<span class="line-modified">1314     case Token::Type::Break: {</span>
<span class="line-modified">1315         auto breakToken = m_lexer.consumeToken();</span>
<span class="line-modified">1316         CONSUME_TYPE(semicolon, Semicolon);</span>
<span class="line-modified">1317         auto breakObject = AST::Break(WTFMove(breakToken));</span>
<span class="line-modified">1318         return { makeUniqueRef&lt;AST::Break&gt;(WTFMove(breakObject)) };</span>
<span class="line-modified">1319     }</span>
<span class="line-modified">1320     case Token::Type::Continue: {</span>
<span class="line-modified">1321         auto continueToken = m_lexer.consumeToken();</span>
<span class="line-modified">1322         CONSUME_TYPE(semicolon, Semicolon);</span>
<span class="line-modified">1323         auto continueObject = AST::Continue(WTFMove(continueToken));</span>
<span class="line-modified">1324         return { makeUniqueRef&lt;AST::Continue&gt;(WTFMove(continueObject)) };</span>
<span class="line-modified">1325     }</span>
<span class="line-modified">1326     case Token::Type::Fallthrough: {</span>
<span class="line-modified">1327         auto fallthroughToken = m_lexer.consumeToken();</span>
<span class="line-modified">1328         CONSUME_TYPE(semicolon, Semicolon);</span>
<span class="line-modified">1329         auto fallthroughObject = AST::Fallthrough(WTFMove(fallthroughToken));</span>
<span class="line-modified">1330         return { makeUniqueRef&lt;AST::Fallthrough&gt;(WTFMove(fallthroughObject)) };</span>
<span class="line-modified">1331     }</span>
<span class="line-modified">1332     case Token::Type::Return: {</span>
<span class="line-modified">1333         auto returnToken = m_lexer.consumeToken();</span>
<span class="line-modified">1334         if (auto semicolon = tryType(Token::Type::Semicolon)) {</span>
<span class="line-modified">1335             auto returnObject = AST::Return(WTFMove(returnToken), nullptr);</span>
<span class="line-modified">1336             return { makeUniqueRef&lt;AST::Return&gt;(WTFMove(returnObject)) };</span>
<span class="line-modified">1337         }</span>
<span class="line-modified">1338         PARSE(expression, Expression);</span>
<span class="line-modified">1339         CONSUME_TYPE(finalSemicolon, Semicolon);</span>
<span class="line-modified">1340         auto returnObject = AST::Return(WTFMove(returnToken), (*expression).moveToUniquePtr());</span>
<span class="line-modified">1341         return { makeUniqueRef&lt;AST::Return&gt;(WTFMove(returnObject)) };</span>
<span class="line-modified">1342     }</span>
<span class="line-modified">1343     case Token::Type::Constant:</span>
<span class="line-modified">1344     case Token::Type::Device:</span>
<span class="line-modified">1345     case Token::Type::Threadgroup:</span>
<span class="line-modified">1346     case Token::Type::Thread: {</span>
<span class="line-modified">1347         PARSE(variableDeclarations, VariableDeclarations);</span>
<span class="line-modified">1348         CONSUME_TYPE(semicolon, Semicolon);</span>
<span class="line-modified">1349         return { makeUniqueRef&lt;AST::VariableDeclarationsStatement&gt;(WTFMove(*variableDeclarations)) };</span>
<span class="line-modified">1350     }</span>
<span class="line-modified">1351     case Token::Type::Identifier: {</span>
<span class="line-modified">1352         PEEK_FURTHER(nextToken);</span>
<span class="line-modified">1353         switch (nextToken-&gt;type) {</span>
<span class="line-modified">1354         case Token::Type::Identifier:</span>
<span class="line-modified">1355         case Token::Type::LessThanSign:</span>
<span class="line-modified">1356         case Token::Type::Star:</span>
<span class="line-modified">1357         case Token::Type::Qualifier: {</span>
<span class="line-modified">1358             PARSE(variableDeclarations, VariableDeclarations);</span>
<span class="line-modified">1359             CONSUME_TYPE(semicolon, Semicolon);</span>
<span class="line-modified">1360             return { makeUniqueRef&lt;AST::VariableDeclarationsStatement&gt;(WTFMove(*variableDeclarations)) };</span>
<span class="line-modified">1361         }</span>
<span class="line-modified">1362         default:</span>
<span class="line-modified">1363             break;</span>
<span class="line-modified">1364         }</span>
<span class="line-modified">1365         break;</span>








































1366     }
<span class="line-modified">1367     default:</span>
<span class="line-modified">1368         break;</span>




















1369     }
1370 
1371     {
<span class="line-modified">1372         auto effectfulExpression = backtrackingScope&lt;Expected&lt;UniqueRef&lt;AST::Statement&gt;, Error&gt;&gt;([&amp;]() -&gt; Expected&lt;UniqueRef&lt;AST::Statement&gt;, Error&gt; {</span>
<span class="line-modified">1373             PARSE(result, EffectfulExpression);</span>
<span class="line-modified">1374             CONSUME_TYPE(semicolon, Semicolon);</span>






1375             return result;
1376         });
<span class="line-modified">1377         if (effectfulExpression)</span>
<span class="line-modified">1378             return WTFMove(*effectfulExpression);</span>
1379     }
1380 
<span class="line-modified">1381     PARSE(variableDeclarations, VariableDeclarations);</span>
<span class="line-modified">1382     CONSUME_TYPE(semicolon, Semicolon);</span>
<span class="line-modified">1383     return { makeUniqueRef&lt;AST::VariableDeclarationsStatement&gt;(WTFMove(*variableDeclarations)) };</span>












1384 }
1385 
<span class="line-modified">1386 auto Parser::parseEffectfulExpression() -&gt; Expected&lt;UniqueRef&lt;AST::Statement&gt;, Error&gt;</span>
1387 {
<span class="line-modified">1388     PEEK(origin);</span>
<span class="line-modified">1389     if (origin-&gt;type == Token::Type::Semicolon)</span>
<span class="line-modified">1390         return { makeUniqueRef&lt;AST::Block&gt;(*origin, Vector&lt;UniqueRef&lt;AST::Statement&gt;&gt;()) };</span>
1391 
1392     Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; expressions;
<span class="line-added">1393     PARSE(effectfulExpression, EffectfulAssignment);</span>
<span class="line-added">1394     expressions.append(WTFMove(*effectfulExpression));</span>
1395 
<span class="line-modified">1396     while (tryType(Token::Type::Comma)) {</span>
<span class="line-modified">1397         PARSE(expression, EffectfulAssignment);</span>













1398         expressions.append(WTFMove(*expression));
1399     }
1400 
1401     if (expressions.size() == 1)
<span class="line-modified">1402         return { makeUniqueRef&lt;AST::EffectfulExpressionStatement&gt;(WTFMove(expressions[0])) };</span>
<span class="line-modified">1403     unsigned endOffset = m_lexer.peek().startOffset();</span>
<span class="line-added">1404     CodeLocation location(origin-&gt;startOffset(), endOffset, m_lexer.nameSpace());</span>
<span class="line-added">1405     auto commaExpression = makeUniqueRef&lt;AST::CommaExpression&gt;(location, WTFMove(expressions));</span>
<span class="line-added">1406     return { makeUniqueRef&lt;AST::EffectfulExpressionStatement&gt;(WTFMove(commaExpression)) };</span>
1407 }
1408 
1409 auto Parser::parseEffectfulAssignment() -&gt; Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;
1410 {
<span class="line-modified">1411     PEEK(origin);</span>




1412 
<span class="line-modified">1413     bool isEffectful = false;</span>
<span class="line-modified">1414     PARSE(expression, PossiblePrefix, &amp;isEffectful);</span>









1415 
<span class="line-modified">1416     if (!isEffectful || peekTypes&lt;</span>
<span class="line-modified">1417         Token::Type::EqualsSign,</span>
<span class="line-modified">1418         Token::Type::PlusEquals,</span>
<span class="line-modified">1419         Token::Type::MinusEquals,</span>
<span class="line-modified">1420         Token::Type::TimesEquals,</span>
<span class="line-modified">1421         Token::Type::DivideEquals,</span>
<span class="line-modified">1422         Token::Type::ModEquals,</span>
<span class="line-modified">1423         Token::Type::XorEquals,</span>
<span class="line-modified">1424         Token::Type::AndEquals,</span>
<span class="line-modified">1425         Token::Type::OrEquals,</span>
<span class="line-modified">1426         Token::Type::RightShiftEquals,</span>
<span class="line-modified">1427         Token::Type::LeftShiftEquals</span>
<span class="line-modified">1428     &gt;()) {</span>
<span class="line-modified">1429         return completeAssignment(WTFMove(*expression));</span>







1430     }











1431 
<span class="line-modified">1432     return expression;</span>


























































1433 }
1434 
1435 auto Parser::parseLimitedSuffixOperator(UniqueRef&lt;AST::Expression&gt;&amp;&amp; previous) -&gt; SuffixExpression
1436 {
<span class="line-modified">1437     auto type = consumeTypes&lt;</span>
<span class="line-added">1438         Token::Type::FullStop,</span>
<span class="line-added">1439         Token::Type::Arrow,</span>
<span class="line-added">1440         Token::Type::LeftSquareBracket&gt;();</span>
1441     if (!type)
1442         return SuffixExpression(WTFMove(previous), false);
1443 
1444     switch (type-&gt;type) {
<span class="line-modified">1445     case Token::Type::FullStop: {</span>
<span class="line-modified">1446         auto identifier = consumeType(Token::Type::Identifier);</span>
1447         if (!identifier)
1448             return SuffixExpression(WTFMove(previous), false);
<span class="line-modified">1449         CodeLocation location(previous-&gt;codeLocation(), *identifier);</span>
<span class="line-added">1450         return SuffixExpression(makeUniqueRef&lt;AST::DotExpression&gt;(location, WTFMove(previous), identifier-&gt;stringView(m_lexer).toString()), true);</span>
1451     }
<span class="line-modified">1452     case Token::Type::Arrow: {</span>
<span class="line-modified">1453         auto identifier = consumeType(Token::Type::Identifier);</span>
1454         if (!identifier)
1455             return SuffixExpression(WTFMove(previous), false);
<span class="line-modified">1456         CodeLocation location(previous-&gt;codeLocation(), *identifier);</span>
<span class="line-added">1457         return SuffixExpression(makeUniqueRef&lt;AST::DotExpression&gt;(location, makeUniqueRef&lt;AST::DereferenceExpression&gt;(location, WTFMove(previous)), identifier-&gt;stringView(m_lexer).toString()), true);</span>
1458     }
1459     default: {
<span class="line-modified">1460         ASSERT(type-&gt;type == Token::Type::LeftSquareBracket);</span>
1461         auto expression = parseExpression();
1462         if (!expression)
1463             return SuffixExpression(WTFMove(previous), false);
<span class="line-modified">1464         if (auto rightSquareBracket = consumeType(Token::Type::RightSquareBracket)) {</span>
<span class="line-modified">1465             CodeLocation location(previous-&gt;codeLocation(), *rightSquareBracket);</span>
<span class="line-modified">1466             return SuffixExpression(makeUniqueRef&lt;AST::IndexExpression&gt;(location, WTFMove(previous), WTFMove(*expression)), true);</span>
<span class="line-added">1467         }</span>
<span class="line-added">1468         return SuffixExpression(WTFMove(previous), false);</span>
1469     }
1470     }
1471 }
1472 
1473 auto Parser::parseSuffixOperator(UniqueRef&lt;AST::Expression&gt;&amp;&amp; previous) -&gt; SuffixExpression
1474 {
<span class="line-modified">1475     auto suffix = consumeTypes&lt;</span>
<span class="line-added">1476         Token::Type::FullStop,</span>
<span class="line-added">1477         Token::Type::Arrow,</span>
<span class="line-added">1478         Token::Type::LeftSquareBracket,</span>
<span class="line-added">1479         Token::Type::PlusPlus,</span>
<span class="line-added">1480         Token::Type::MinusMinus&gt;();</span>
1481     if (!suffix)
1482         return SuffixExpression(WTFMove(previous), false);
1483 
1484     switch (suffix-&gt;type) {
<span class="line-modified">1485     case Token::Type::FullStop: {</span>
<span class="line-modified">1486         auto identifier = consumeType(Token::Type::Identifier);</span>
1487         if (!identifier)
1488             return SuffixExpression(WTFMove(previous), false);
<span class="line-modified">1489         CodeLocation location(previous-&gt;codeLocation(), *identifier);</span>
<span class="line-added">1490         return SuffixExpression(makeUniqueRef&lt;AST::DotExpression&gt;(location, WTFMove(previous), identifier-&gt;stringView(m_lexer).toString()), true);</span>
1491     }
<span class="line-modified">1492     case Token::Type::Arrow: {</span>
<span class="line-modified">1493         auto identifier = consumeType(Token::Type::Identifier);</span>
1494         if (!identifier)
1495             return SuffixExpression(WTFMove(previous), false);
<span class="line-modified">1496         CodeLocation location(previous-&gt;codeLocation(), *identifier);</span>
<span class="line-added">1497         return SuffixExpression(makeUniqueRef&lt;AST::DotExpression&gt;(location, makeUniqueRef&lt;AST::DereferenceExpression&gt;(WTFMove(*suffix), WTFMove(previous)), identifier-&gt;stringView(m_lexer).toString()), true);</span>
1498     }
<span class="line-modified">1499     case Token::Type::LeftSquareBracket: {</span>
1500         auto expression = parseExpression();
1501         if (!expression)
1502             return SuffixExpression(WTFMove(previous), false);
<span class="line-modified">1503         if (auto rightSquareBracket = consumeType(Token::Type::RightSquareBracket)) {</span>
<span class="line-modified">1504             CodeLocation location(previous-&gt;codeLocation(), *rightSquareBracket);</span>
<span class="line-modified">1505             return SuffixExpression(makeUniqueRef&lt;AST::IndexExpression&gt;(location, WTFMove(previous), WTFMove(*expression)), true);</span>
<span class="line-added">1506         }</span>
<span class="line-added">1507         return SuffixExpression(WTFMove(previous), false);</span>
1508     }
<span class="line-modified">1509     case Token::Type::PlusPlus: {</span>
<span class="line-modified">1510         CodeLocation location(previous-&gt;codeLocation(), *suffix);</span>
<span class="line-added">1511         auto result = makeUniqueRef&lt;AST::ReadModifyWriteExpression&gt;(location, WTFMove(previous));</span>
1512         Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; callArguments;
1513         callArguments.append(result-&gt;oldVariableReference());
<span class="line-modified">1514         result-&gt;setNewValueExpression(makeUniqueRef&lt;AST::CallExpression&gt;(location, &quot;operator++&quot;_str, WTFMove(callArguments)));</span>
1515         result-&gt;setResultExpression(result-&gt;oldVariableReference());
1516         return SuffixExpression(WTFMove(result), true);
1517     }
1518     default: {
<span class="line-modified">1519         ASSERT(suffix-&gt;type == Token::Type::MinusMinus);</span>
<span class="line-modified">1520         CodeLocation location(previous-&gt;codeLocation(), *suffix);</span>
<span class="line-added">1521         auto result = makeUniqueRef&lt;AST::ReadModifyWriteExpression&gt;(location, WTFMove(previous));</span>
1522         Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; callArguments;
1523         callArguments.append(result-&gt;oldVariableReference());
<span class="line-modified">1524         result-&gt;setNewValueExpression(makeUniqueRef&lt;AST::CallExpression&gt;(location, &quot;operator--&quot;_str, WTFMove(callArguments)));</span>
1525         result-&gt;setResultExpression(result-&gt;oldVariableReference());
1526         return SuffixExpression(WTFMove(result), true);
1527     }
1528     }
1529 }
1530 
1531 auto Parser::parseExpression() -&gt; Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;
1532 {
<span class="line-modified">1533     PARSE(first, PossibleTernaryConditional);</span>







1534     Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; expressions;
<span class="line-added">1535     unsigned startOffset = (*first)-&gt;codeLocation().startOffset();</span>
1536     expressions.append(WTFMove(*first));
1537 
<span class="line-modified">1538     while (tryType(Token::Type::Comma)) {</span>
<span class="line-modified">1539         PARSE(expression, PossibleTernaryConditional);</span>


1540         expressions.append(WTFMove(*expression));
1541     }
1542 
1543     if (expressions.size() == 1)
1544         return WTFMove(expressions[0]);
<span class="line-modified">1545     auto endOffset = m_lexer.peek().startOffset();</span>
<span class="line-added">1546     CodeLocation location(startOffset, endOffset, m_lexer.nameSpace());</span>
<span class="line-added">1547     return { makeUniqueRef&lt;AST::CommaExpression&gt;(location, WTFMove(expressions)) };</span>
1548 }
1549 
<span class="line-modified">1550 auto Parser::completeTernaryConditional(UniqueRef&lt;AST::Expression&gt;&amp;&amp; predicate) -&gt; Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;</span>
1551 {
<span class="line-modified">1552     CONSUME_TYPE(questionMark, QuestionMark);</span>
<span class="line-modified">1553     PARSE(bodyExpression, Expression);</span>
<span class="line-modified">1554     CONSUME_TYPE(colon, Colon);</span>
<span class="line-modified">1555     PARSE(elseExpression, PossibleTernaryConditional);</span>



















1556 
<span class="line-added">1557     CodeLocation predicateLocation = predicate-&gt;codeLocation();</span>
1558     Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; castArguments;
<span class="line-modified">1559     castArguments.append(WTFMove(predicate));</span>
<span class="line-modified">1560     auto boolCast = makeUniqueRef&lt;AST::CallExpression&gt;(predicateLocation, &quot;bool&quot;_str, WTFMove(castArguments));</span>
<span class="line-modified">1561     CodeLocation location(predicateLocation, (*elseExpression)-&gt;codeLocation());</span>
<span class="line-modified">1562     return { makeUniqueRef&lt;AST::TernaryExpression&gt;(location, WTFMove(boolCast), WTFMove(*bodyExpression), WTFMove(*elseExpression)) };</span>
<span class="line-modified">1563 }</span>
<span class="line-modified">1564 </span>
<span class="line-modified">1565 auto Parser::completeAssignment(UniqueRef&lt;AST::Expression&gt;&amp;&amp; left) -&gt; Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;</span>
<span class="line-modified">1566 {</span>
<span class="line-modified">1567     auto assignmentOperator = consumeTypes&lt;</span>
<span class="line-modified">1568         Token::Type::EqualsSign,</span>
<span class="line-modified">1569         Token::Type::PlusEquals,</span>
<span class="line-modified">1570         Token::Type::MinusEquals,</span>
<span class="line-modified">1571         Token::Type::TimesEquals,</span>
<span class="line-modified">1572         Token::Type::DivideEquals,</span>
<span class="line-modified">1573         Token::Type::ModEquals,</span>
<span class="line-modified">1574         Token::Type::XorEquals,</span>
<span class="line-modified">1575         Token::Type::AndEquals,</span>
<span class="line-modified">1576         Token::Type::OrEquals,</span>
<span class="line-modified">1577         Token::Type::RightShiftEquals,</span>
<span class="line-modified">1578         Token::Type::LeftShiftEquals&gt;();</span>








1579     if (!assignmentOperator)
<span class="line-modified">1580         return makeUnexpected(assignmentOperator.error());</span>
1581 
<span class="line-modified">1582     PARSE(right, PossibleTernaryConditional);</span>
<span class="line-modified">1583     CodeLocation location = { left-&gt;codeLocation(), (*right)-&gt;codeLocation() };</span>

1584 
<span class="line-modified">1585     if (assignmentOperator-&gt;type == Token::Type::EqualsSign)</span>
<span class="line-modified">1586         return { makeUniqueRef&lt;AST::AssignmentExpression&gt;(location, WTFMove(left), WTFMove(*right))};</span>
1587 
1588     String name;
1589     switch (assignmentOperator-&gt;type) {
<span class="line-modified">1590     case Token::Type::PlusEquals:</span>
1591         name = &quot;operator+&quot;_str;
1592         break;
<span class="line-modified">1593     case Token::Type::MinusEquals:</span>
1594         name = &quot;operator-&quot;_str;
1595         break;
<span class="line-modified">1596     case Token::Type::TimesEquals:</span>
1597         name = &quot;operator*&quot;_str;
1598         break;
<span class="line-modified">1599     case Token::Type::DivideEquals:</span>
1600         name = &quot;operator/&quot;_str;
1601         break;
<span class="line-modified">1602     case Token::Type::ModEquals:</span>
1603         name = &quot;operator%&quot;_str;
1604         break;
<span class="line-modified">1605     case Token::Type::XorEquals:</span>
1606         name = &quot;operator^&quot;_str;
1607         break;
<span class="line-modified">1608     case Token::Type::AndEquals:</span>
1609         name = &quot;operator&amp;&quot;_str;
1610         break;
<span class="line-modified">1611     case Token::Type::OrEquals:</span>
1612         name = &quot;operator|&quot;_str;
1613         break;
<span class="line-modified">1614     case Token::Type::RightShiftEquals:</span>
1615         name = &quot;operator&gt;&gt;&quot;_str;
1616         break;
1617     default:
<span class="line-modified">1618         ASSERT(assignmentOperator-&gt;type == Token::Type::LeftShiftEquals);</span>
1619         name = &quot;operator&lt;&lt;&quot;_str;
1620         break;
1621     }
1622 
<span class="line-modified">1623     auto result = makeUniqueRef&lt;AST::ReadModifyWriteExpression&gt;(location, WTFMove(left));</span>
1624     Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; callArguments;
1625     callArguments.append(result-&gt;oldVariableReference());
1626     callArguments.append(WTFMove(*right));
<span class="line-modified">1627     result-&gt;setNewValueExpression(makeUniqueRef&lt;AST::CallExpression&gt;(location, WTFMove(name), WTFMove(callArguments)));</span>
1628     result-&gt;setResultExpression(result-&gt;newVariableReference());
1629     return { WTFMove(result) };
1630 }
1631 
1632 auto Parser::parsePossibleTernaryConditional() -&gt; Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;
1633 {
<span class="line-modified">1634     PARSE(expression, PossiblePrefix);</span>




1635 
<span class="line-modified">1636     if (peekTypes&lt;Token::Type::EqualsSign,</span>
<span class="line-modified">1637         Token::Type::PlusEquals,</span>
<span class="line-modified">1638         Token::Type::MinusEquals,</span>
<span class="line-modified">1639         Token::Type::TimesEquals,</span>
<span class="line-modified">1640         Token::Type::DivideEquals,</span>
<span class="line-added">1641         Token::Type::ModEquals,</span>
<span class="line-added">1642         Token::Type::XorEquals,</span>
<span class="line-added">1643         Token::Type::AndEquals,</span>
<span class="line-added">1644         Token::Type::OrEquals,</span>
<span class="line-added">1645         Token::Type::RightShiftEquals,</span>
<span class="line-added">1646         Token::Type::LeftShiftEquals&gt;()) {</span>
<span class="line-added">1647         return completeAssignment(WTFMove(*expression));</span>
<span class="line-added">1648     }</span>
1649 
<span class="line-modified">1650     expression = completePossibleShift(WTFMove(*expression));</span>
<span class="line-modified">1651     if (!expression)</span>
<span class="line-modified">1652         return makeUnexpected(expression.error());</span>
<span class="line-modified">1653 </span>
<span class="line-modified">1654     expression = completePossibleMultiply(WTFMove(*expression));</span>
<span class="line-added">1655     if (!expression)</span>
<span class="line-added">1656         return makeUnexpected(expression.error());</span>
<span class="line-added">1657 </span>
<span class="line-added">1658     expression = completePossibleAdd(WTFMove(*expression));</span>
<span class="line-added">1659     if (!expression)</span>
<span class="line-added">1660         return makeUnexpected(expression.error());</span>
<span class="line-added">1661 </span>
<span class="line-added">1662     expression = completePossibleRelationalBinaryOperation(WTFMove(*expression));</span>
<span class="line-added">1663     if (!expression)</span>
<span class="line-added">1664         return makeUnexpected(expression.error());</span>
1665 
<span class="line-modified">1666     expression = completePossibleLogicalBinaryOperation(WTFMove(*expression));</span>
<span class="line-added">1667     if (!expression)</span>
<span class="line-added">1668         return makeUnexpected(expression.error());</span>
<span class="line-added">1669 </span>
<span class="line-added">1670     PEEK(nextToken);</span>
<span class="line-added">1671     if (nextToken-&gt;type == Token::Type::QuestionMark)</span>
<span class="line-added">1672         return completeTernaryConditional(WTFMove(*expression));</span>
<span class="line-added">1673     return expression;</span>
1674 }
1675 
1676 auto Parser::parsePossibleLogicalBinaryOperation() -&gt; Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;
1677 {
<span class="line-modified">1678     PARSE(parsedPrevious, PossibleRelationalBinaryOperation);</span>
<span class="line-modified">1679     return completePossibleLogicalBinaryOperation(WTFMove(*parsedPrevious));</span>
<span class="line-modified">1680 }</span>
<span class="line-modified">1681 </span>
<span class="line-modified">1682 auto Parser::completePossibleLogicalBinaryOperation(UniqueRef&lt;AST::Expression&gt;&amp;&amp; previous) -&gt; Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;</span>
<span class="line-modified">1683 {</span>
<span class="line-modified">1684     while (auto logicalBinaryOperation = tryTypes&lt;</span>
<span class="line-modified">1685         Token::Type::OrOr,</span>
<span class="line-modified">1686         Token::Type::AndAnd,</span>
<span class="line-modified">1687         Token::Type::Or,</span>
<span class="line-modified">1688         Token::Type::Xor,</span>
<span class="line-modified">1689         Token::Type::And</span>
<span class="line-modified">1690         &gt;()) {</span>
<span class="line-modified">1691         PARSE(next, PossibleRelationalBinaryOperation);</span>
<span class="line-modified">1692         CodeLocation location(previous-&gt;codeLocation(), (*next)-&gt;codeLocation());</span>
1693 
1694         switch (logicalBinaryOperation-&gt;type) {
<span class="line-modified">1695         case Token::Type::OrOr:</span>
<span class="line-modified">1696             previous = makeUniqueRef&lt;AST::LogicalExpression&gt;(location, AST::LogicalExpression::Type::Or, WTFMove(previous), WTFMove(*next));</span>
1697             break;
<span class="line-modified">1698         case Token::Type::AndAnd:</span>
<span class="line-modified">1699             previous = makeUniqueRef&lt;AST::LogicalExpression&gt;(location, AST::LogicalExpression::Type::And, WTFMove(previous), WTFMove(*next));</span>
1700             break;
<span class="line-modified">1701         case Token::Type::Or: {</span>
1702             Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; callArguments;
1703             callArguments.append(WTFMove(previous));
1704             callArguments.append(WTFMove(*next));
<span class="line-modified">1705             previous = makeUniqueRef&lt;AST::CallExpression&gt;(location, &quot;operator|&quot;_str, WTFMove(callArguments));</span>
1706             break;
1707         }
<span class="line-modified">1708         case Token::Type::Xor: {</span>
1709             Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; callArguments;
1710             callArguments.append(WTFMove(previous));
1711             callArguments.append(WTFMove(*next));
<span class="line-modified">1712             previous = makeUniqueRef&lt;AST::CallExpression&gt;(location, &quot;operator^&quot;_str, WTFMove(callArguments));</span>
1713             break;
1714         }
1715         default: {
<span class="line-modified">1716             ASSERT(logicalBinaryOperation-&gt;type == Token::Type::And);</span>
1717             Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; callArguments;
1718             callArguments.append(WTFMove(previous));
1719             callArguments.append(WTFMove(*next));
<span class="line-modified">1720             previous = makeUniqueRef&lt;AST::CallExpression&gt;(location, &quot;operator&amp;&quot;_str, WTFMove(callArguments));</span>
1721             break;
1722         }
1723         }
1724     }
1725 
1726     return { WTFMove(previous) };
1727 }
1728 
1729 auto Parser::parsePossibleRelationalBinaryOperation() -&gt; Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;
1730 {
<span class="line-modified">1731     PARSE(parsedPrevious, PossibleShift);</span>
<span class="line-modified">1732     return completePossibleRelationalBinaryOperation(WTFMove(*parsedPrevious));</span>
<span class="line-modified">1733 }</span>
<span class="line-modified">1734 </span>
<span class="line-modified">1735 auto Parser::completePossibleRelationalBinaryOperation(UniqueRef&lt;AST::Expression&gt;&amp;&amp; previous) -&gt; Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;</span>
<span class="line-modified">1736 {</span>
<span class="line-modified">1737     while (auto relationalBinaryOperation = tryTypes&lt;</span>
<span class="line-modified">1738         Token::Type::LessThanSign,</span>
<span class="line-modified">1739         Token::Type::GreaterThanSign,</span>
<span class="line-modified">1740         Token::Type::LessThanOrEqualTo,</span>
<span class="line-modified">1741         Token::Type::GreaterThanOrEqualTo,</span>
<span class="line-modified">1742         Token::Type::EqualComparison,</span>
<span class="line-modified">1743         Token::Type::NotEqual</span>
<span class="line-modified">1744         &gt;()) {</span>
<span class="line-modified">1745         PARSE(next, PossibleShift);</span>
<span class="line-modified">1746         CodeLocation location(previous-&gt;codeLocation(), (*next)-&gt;codeLocation());</span>
<span class="line-added">1747 </span>
<span class="line-added">1748         Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; callArguments;</span>
<span class="line-added">1749         callArguments.append(WTFMove(previous));</span>
<span class="line-added">1750         callArguments.append(WTFMove(*next));</span>
1751 
1752         switch (relationalBinaryOperation-&gt;type) {
<span class="line-modified">1753         case Token::Type::LessThanSign: {</span>
<span class="line-modified">1754             previous = makeUniqueRef&lt;AST::CallExpression&gt;(location, &quot;operator&lt;&quot;_str, WTFMove(callArguments));</span>



1755             break;
1756         }
<span class="line-modified">1757         case Token::Type::GreaterThanSign: {</span>
<span class="line-modified">1758             previous = makeUniqueRef&lt;AST::CallExpression&gt;(location, &quot;operator&gt;&quot;_str, WTFMove(callArguments));</span>



1759             break;
1760         }
<span class="line-modified">1761         case Token::Type::LessThanOrEqualTo: {</span>
<span class="line-modified">1762             previous = makeUniqueRef&lt;AST::CallExpression&gt;(location, &quot;operator&lt;=&quot;_str, WTFMove(callArguments));</span>



1763             break;
1764         }
<span class="line-modified">1765         case Token::Type::GreaterThanOrEqualTo: {</span>
<span class="line-modified">1766             previous = makeUniqueRef&lt;AST::CallExpression&gt;(location, &quot;operator&gt;=&quot;_str, WTFMove(callArguments));</span>



1767             break;
1768         }
<span class="line-modified">1769         case Token::Type::EqualComparison: {</span>
<span class="line-modified">1770             previous = makeUniqueRef&lt;AST::CallExpression&gt;(location, &quot;operator==&quot;_str, WTFMove(callArguments));</span>



1771             break;
1772         }
1773         default: {
<span class="line-modified">1774             ASSERT(relationalBinaryOperation-&gt;type == Token::Type::NotEqual);</span>
<span class="line-modified">1775             previous = makeUniqueRef&lt;AST::CallExpression&gt;(location, &quot;operator==&quot;_str, WTFMove(callArguments));</span>
<span class="line-modified">1776             previous = makeUniqueRef&lt;AST::LogicalNotExpression&gt;(location, WTFMove(previous));</span>



1777             break;
1778         }
1779         }
1780     }
1781 
1782     return WTFMove(previous);
1783 }
1784 
1785 auto Parser::parsePossibleShift() -&gt; Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;
1786 {
<span class="line-modified">1787     PARSE(parsedPrevious, PossibleAdd);</span>
<span class="line-modified">1788     return completePossibleShift(WTFMove(*parsedPrevious));</span>
<span class="line-modified">1789 }</span>
<span class="line-modified">1790 </span>
<span class="line-added">1791 auto Parser::completePossibleShift(UniqueRef&lt;AST::Expression&gt;&amp;&amp; previous) -&gt; Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;</span>
<span class="line-added">1792 {</span>
<span class="line-added">1793     while (auto shift = tryTypes&lt;</span>
<span class="line-added">1794         Token::Type::LeftShift,</span>
<span class="line-added">1795         Token::Type::RightShift</span>
<span class="line-added">1796         &gt;()) {</span>
<span class="line-added">1797         PARSE(next, PossibleAdd);</span>
<span class="line-added">1798         CodeLocation location(previous-&gt;codeLocation(), (*next)-&gt;codeLocation());</span>
1799 
<span class="line-modified">1800         Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; callArguments;</span>
<span class="line-modified">1801         callArguments.append(WTFMove(previous));</span>
<span class="line-modified">1802         callArguments.append(WTFMove(*next));</span>




1803 
1804         switch (shift-&gt;type) {
<span class="line-modified">1805         case Token::Type::LeftShift: {</span>
<span class="line-modified">1806             previous = makeUniqueRef&lt;AST::CallExpression&gt;(location, &quot;operator&lt;&lt;&quot;_str, WTFMove(callArguments));</span>



1807             break;
1808         }
1809         default: {
<span class="line-modified">1810             ASSERT(shift-&gt;type == Token::Type::RightShift);</span>
<span class="line-modified">1811             previous = makeUniqueRef&lt;AST::CallExpression&gt;(location, &quot;operator&gt;&gt;&quot;_str, WTFMove(callArguments));</span>



1812             break;
1813         }
1814         }
1815     }
1816 
1817     return WTFMove(previous);
1818 }
1819 
1820 auto Parser::parsePossibleAdd() -&gt; Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;
1821 {
<span class="line-modified">1822     PARSE(parsedPrevious, PossibleMultiply);</span>
<span class="line-modified">1823     return completePossibleAdd(WTFMove(*parsedPrevious));</span>
<span class="line-modified">1824 }</span>

1825 
<span class="line-modified">1826 auto Parser::completePossibleAdd(UniqueRef&lt;AST::Expression&gt;&amp;&amp; previous) -&gt; Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;</span>
<span class="line-modified">1827 {</span>
<span class="line-modified">1828     while (auto add = tryTypes&lt;</span>
<span class="line-modified">1829         Token::Type::Plus,</span>
<span class="line-modified">1830         Token::Type::Minus</span>
<span class="line-modified">1831         &gt;()) {</span>
<span class="line-modified">1832         PARSE(next, PossibleMultiply);</span>
<span class="line-added">1833         CodeLocation location(previous-&gt;codeLocation(), (*next)-&gt;codeLocation());</span>
<span class="line-added">1834 </span>
<span class="line-added">1835         Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; callArguments;</span>
<span class="line-added">1836         callArguments.append(WTFMove(previous));</span>
<span class="line-added">1837         callArguments.append(WTFMove(*next));</span>
1838 
1839         switch (add-&gt;type) {
<span class="line-modified">1840         case Token::Type::Plus: {</span>
<span class="line-modified">1841             previous = makeUniqueRef&lt;AST::CallExpression&gt;(location, &quot;operator+&quot;_str, WTFMove(callArguments));</span>



1842             break;
1843         }
1844         default: {
<span class="line-modified">1845             ASSERT(add-&gt;type == Token::Type::Minus);</span>
<span class="line-modified">1846             previous = makeUniqueRef&lt;AST::CallExpression&gt;(location, &quot;operator-&quot;_str, WTFMove(callArguments));</span>



1847             break;
1848         }
1849         }
1850     }
1851 
1852     return WTFMove(previous);
1853 }
1854 
1855 auto Parser::parsePossibleMultiply() -&gt; Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;
1856 {
<span class="line-modified">1857     PARSE(parsedPrevious, PossiblePrefix);</span>
<span class="line-modified">1858     return completePossibleMultiply(WTFMove(*parsedPrevious));</span>
<span class="line-modified">1859 }</span>

1860 
<span class="line-modified">1861 auto Parser::completePossibleMultiply(UniqueRef&lt;AST::Expression&gt;&amp;&amp; previous) -&gt; Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;</span>
<span class="line-modified">1862 {</span>
<span class="line-modified">1863     while (auto multiply = tryTypes&lt;</span>
<span class="line-modified">1864         Token::Type::Star,</span>
<span class="line-modified">1865         Token::Type::Divide,</span>
<span class="line-modified">1866         Token::Type::Mod</span>
<span class="line-modified">1867         &gt;()) {</span>
<span class="line-modified">1868         PARSE(next, PossiblePrefix);</span>
<span class="line-added">1869         CodeLocation location(previous-&gt;codeLocation(), (*next)-&gt;codeLocation());</span>
<span class="line-added">1870 </span>
<span class="line-added">1871         Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; callArguments;</span>
<span class="line-added">1872         callArguments.append(WTFMove(previous));</span>
<span class="line-added">1873         callArguments.append(WTFMove(*next));</span>
1874 
1875         switch (multiply-&gt;type) {
<span class="line-modified">1876         case Token::Type::Star: {</span>
<span class="line-modified">1877             previous = makeUniqueRef&lt;AST::CallExpression&gt;(location, &quot;operator*&quot;_str, WTFMove(callArguments));</span>



1878             break;
1879         }
<span class="line-modified">1880         case Token::Type::Divide: {</span>
<span class="line-modified">1881             previous = makeUniqueRef&lt;AST::CallExpression&gt;(location, &quot;operator/&quot;_str, WTFMove(callArguments));</span>



1882             break;
1883         }
1884         default: {
<span class="line-modified">1885             ASSERT(multiply-&gt;type == Token::Type::Mod);</span>
<span class="line-modified">1886             previous = makeUniqueRef&lt;AST::CallExpression&gt;(location, &quot;operator%&quot;_str, WTFMove(callArguments));</span>



1887             break;
1888         }
1889         }
1890     }
1891 
1892     return WTFMove(previous);
1893 }
1894 
<span class="line-modified">1895 auto Parser::parsePossiblePrefix(bool *isEffectful) -&gt; Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;</span>
1896 {
<span class="line-modified">1897     if (auto prefix = tryTypes&lt;</span>
<span class="line-modified">1898         Token::Type::PlusPlus,</span>
<span class="line-modified">1899         Token::Type::MinusMinus,</span>
<span class="line-modified">1900         Token::Type::Plus,</span>
<span class="line-modified">1901         Token::Type::Minus,</span>
<span class="line-modified">1902         Token::Type::Tilde,</span>
<span class="line-modified">1903         Token::Type::ExclamationPoint,</span>
<span class="line-modified">1904         Token::Type::And,</span>
<span class="line-modified">1905         Token::Type::At,</span>
<span class="line-modified">1906         Token::Type::Star</span>
<span class="line-modified">1907     &gt;()) {</span>
<span class="line-modified">1908         PARSE(next, PossiblePrefix);</span>
<span class="line-modified">1909         CodeLocation location(*prefix, (*next)-&gt;codeLocation());</span>

1910 
1911         switch (prefix-&gt;type) {
<span class="line-modified">1912         case Token::Type::PlusPlus: {</span>
<span class="line-modified">1913             if (isEffectful)</span>
<span class="line-added">1914                 *isEffectful = true;</span>
<span class="line-added">1915             auto result = makeUniqueRef&lt;AST::ReadModifyWriteExpression&gt;(location, WTFMove(*next));</span>
1916             Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; callArguments;
1917             callArguments.append(result-&gt;oldVariableReference());
<span class="line-modified">1918             result-&gt;setNewValueExpression(makeUniqueRef&lt;AST::CallExpression&gt;(location, &quot;operator++&quot;_str, WTFMove(callArguments)));</span>
1919             result-&gt;setResultExpression(result-&gt;newVariableReference());
1920             return { WTFMove(result) };
1921         }
<span class="line-modified">1922         case Token::Type::MinusMinus: {</span>
<span class="line-modified">1923             if (isEffectful)</span>
<span class="line-added">1924                 *isEffectful = true;</span>
<span class="line-added">1925             auto result = makeUniqueRef&lt;AST::ReadModifyWriteExpression&gt;(location, WTFMove(*next));</span>
1926             Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; callArguments;
1927             callArguments.append(result-&gt;oldVariableReference());
<span class="line-modified">1928             result-&gt;setNewValueExpression(makeUniqueRef&lt;AST::CallExpression&gt;(location, &quot;operator--&quot;_str, WTFMove(callArguments)));</span>
1929             result-&gt;setResultExpression(result-&gt;newVariableReference());
1930             return { WTFMove(result) };
1931         }
<span class="line-modified">1932         case Token::Type::Plus: {</span>
1933             Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; callArguments;
1934             callArguments.append(WTFMove(*next));
<span class="line-modified">1935             return { makeUniqueRef&lt;AST::CallExpression&gt;(location, &quot;operator+&quot;_str, WTFMove(callArguments)) };</span>
1936         }
<span class="line-modified">1937         case Token::Type::Minus: {</span>
1938             Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; callArguments;
1939             callArguments.append(WTFMove(*next));
<span class="line-modified">1940             return { makeUniqueRef&lt;AST::CallExpression&gt;(location, &quot;operator-&quot;_str, WTFMove(callArguments)) };</span>
1941         }
<span class="line-modified">1942         case Token::Type::Tilde: {</span>
1943             Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; callArguments;
1944             callArguments.append(WTFMove(*next));
<span class="line-modified">1945             return { makeUniqueRef&lt;AST::CallExpression&gt;(location, &quot;operator~&quot;_str, WTFMove(callArguments)) };</span>
1946         }
<span class="line-modified">1947         case Token::Type::ExclamationPoint: {</span>
1948             Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; castArguments;
1949             castArguments.append(WTFMove(*next));
<span class="line-modified">1950             auto boolCast = makeUniqueRef&lt;AST::CallExpression&gt;(location, &quot;bool&quot;_str, WTFMove(castArguments));</span>
<span class="line-modified">1951             return { makeUniqueRef&lt;AST::LogicalNotExpression&gt;(location, WTFMove(boolCast)) };</span>
1952         }
<span class="line-modified">1953         case Token::Type::And:</span>
<span class="line-modified">1954             return { makeUniqueRef&lt;AST::MakePointerExpression&gt;(location, WTFMove(*next), AST::AddressEscapeMode::Escapes) };</span>
<span class="line-modified">1955         case Token::Type::At:</span>
<span class="line-modified">1956             return { makeUniqueRef&lt;AST::MakeArrayReferenceExpression&gt;(location, WTFMove(*next), AST::AddressEscapeMode::Escapes) };</span>
1957         default:
<span class="line-modified">1958             ASSERT(prefix-&gt;type == Token::Type::Star);</span>
<span class="line-modified">1959             return { makeUniqueRef&lt;AST::DereferenceExpression&gt;(location, WTFMove(*next)) };</span>
1960         }
1961     }
1962 
<span class="line-modified">1963     return parsePossibleSuffix(isEffectful);</span>
1964 }
1965 
<span class="line-modified">1966 auto Parser::parsePossibleSuffix(bool *isEffectful) -&gt; Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;</span>
1967 {
<span class="line-modified">1968     PEEK(token);</span>
<span class="line-modified">1969     PEEK_FURTHER(nextToken);</span>


1970 
<span class="line-added">1971     if (token-&gt;type == Token::Type::Identifier &amp;&amp; nextToken-&gt;type == Token::Type::LeftParenthesis) {</span>
<span class="line-added">1972         PARSE(expression, CallExpression);</span>
<span class="line-added">1973         if (isEffectful)</span>
<span class="line-added">1974             *isEffectful = true;</span>
1975         while (true) {
<span class="line-modified">1976             PEEK(suffixToken);</span>
<span class="line-modified">1977             if (suffixToken-&gt;type != Token::Type::FullStop &amp;&amp; suffixToken-&gt;type != Token::Type::Arrow &amp;&amp; suffixToken-&gt;type != Token::Type::LeftSquareBracket)</span>



1978                 break;
<span class="line-added">1979             auto result = parseLimitedSuffixOperator(WTFMove(*expression));</span>
<span class="line-added">1980             expression = WTFMove(result.result);</span>
1981         }
1982         return expression;
<span class="line-modified">1983     }</span>


1984 
<span class="line-modified">1985     if (token-&gt;type == Token::Type::LeftParenthesis &amp;&amp; isEffectful)</span>
<span class="line-modified">1986         *isEffectful = true;</span>


1987 
<span class="line-modified">1988     PARSE(expression, Term);</span>
<span class="line-modified">1989     bool isLastSuffixTokenEffectful = false;</span>
<span class="line-modified">1990     while (true) {</span>
<span class="line-modified">1991         PEEK(suffixToken);</span>
<span class="line-modified">1992         if (suffixToken-&gt;type != Token::Type::FullStop</span>
<span class="line-modified">1993             &amp;&amp; suffixToken-&gt;type != Token::Type::Arrow</span>
<span class="line-modified">1994             &amp;&amp; suffixToken-&gt;type != Token::Type::LeftSquareBracket</span>
<span class="line-added">1995             &amp;&amp; suffixToken-&gt;type != Token::Type::PlusPlus</span>
<span class="line-added">1996             &amp;&amp; suffixToken-&gt;type != Token::Type::MinusMinus) {</span>
<span class="line-added">1997             break;</span>
1998         }
<span class="line-modified">1999         isLastSuffixTokenEffectful = suffixToken-&gt;type == Token::Type::PlusPlus || suffixToken-&gt;type == Token::Type::MinusMinus;</span>
<span class="line-modified">2000         auto result = parseSuffixOperator(WTFMove(*expression));</span>
<span class="line-modified">2001         expression = WTFMove(result.result);</span>
<span class="line-modified">2002     }</span>
<span class="line-modified">2003     if (isLastSuffixTokenEffectful &amp;&amp; isEffectful)</span>
<span class="line-modified">2004         *isEffectful = true;</span>
<span class="line-added">2005     return expression;</span>
2006 }
2007 
2008 auto Parser::parseCallExpression() -&gt; Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;
2009 {
<span class="line-modified">2010     CONSUME_TYPE(name, Identifier);</span>
<span class="line-modified">2011     auto callName = name-&gt;stringView(m_lexer).toString();</span>


2012 
<span class="line-modified">2013     CONSUME_TYPE(leftParenthesis, LeftParenthesis);</span>


2014 
2015     Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; arguments;
<span class="line-modified">2016     if (tryType(Token::Type::RightParenthesis))</span>
2017         return { makeUniqueRef&lt;AST::CallExpression&gt;(WTFMove(*name), WTFMove(callName), WTFMove(arguments)) };
2018 
<span class="line-modified">2019     PARSE(firstArgument, PossibleTernaryConditional);</span>


2020     arguments.append(WTFMove(*firstArgument));
<span class="line-modified">2021     while (tryType(Token::Type::Comma)) {</span>
<span class="line-modified">2022         PARSE(argument, PossibleTernaryConditional);</span>


2023         arguments.append(WTFMove(*argument));
2024     }
2025 
<span class="line-modified">2026     CONSUME_TYPE(rightParenthesis, RightParenthesis);</span>
<span class="line-modified">2027     CodeLocation location(*name, *rightParenthesis);</span>

2028 
<span class="line-modified">2029     return { makeUniqueRef&lt;AST::CallExpression&gt;(location, WTFMove(callName), WTFMove(arguments)) };</span>
2030 }
2031 
2032 auto Parser::parseTerm() -&gt; Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;
2033 {
<span class="line-modified">2034     auto type = consumeTypes&lt;</span>
<span class="line-modified">2035         Token::Type::IntLiteral,</span>
<span class="line-modified">2036         Token::Type::UintLiteral,</span>
<span class="line-modified">2037         Token::Type::FloatLiteral,</span>
<span class="line-modified">2038         Token::Type::Null,</span>
<span class="line-modified">2039         Token::Type::True,</span>
<span class="line-modified">2040         Token::Type::False,</span>
<span class="line-modified">2041         Token::Type::Identifier,</span>
<span class="line-modified">2042         Token::Type::LeftParenthesis&gt;();</span>

2043     if (!type)
<span class="line-modified">2044         return makeUnexpected(type.error());</span>
2045 
2046     switch (type-&gt;type) {
<span class="line-modified">2047     case Token::Type::IntLiteral: {</span>
<span class="line-modified">2048         auto value = intLiteralToInt(type-&gt;stringView(m_lexer));</span>
2049         if (!value)
<span class="line-modified">2050             return makeUnexpected(value.error());</span>
<span class="line-modified">2051         return { makeUniqueRef&lt;AST::IntegerLiteral&gt;(*type, *value) };</span>
2052     }
<span class="line-modified">2053     case Token::Type::UintLiteral: {</span>
<span class="line-modified">2054         auto value = uintLiteralToUint(type-&gt;stringView(m_lexer));</span>
2055         if (!value)
<span class="line-modified">2056             return makeUnexpected(value.error());</span>
<span class="line-modified">2057         return { makeUniqueRef&lt;AST::UnsignedIntegerLiteral&gt;(*type, *value) };</span>
2058     }
<span class="line-modified">2059     case Token::Type::FloatLiteral: {</span>
<span class="line-modified">2060         auto value = floatLiteralToFloat(type-&gt;stringView(m_lexer));</span>
2061         if (!value)
<span class="line-modified">2062             return makeUnexpected(value.error());</span>
<span class="line-modified">2063         return { makeUniqueRef&lt;AST::FloatLiteral&gt;(*type, *value) };</span>
<span class="line-modified">2064     }</span>
<span class="line-modified">2065     case Token::Type::Null:</span>
<span class="line-modified">2066         return { makeUniqueRef&lt;AST::NullLiteral&gt;(*type) };</span>
<span class="line-modified">2067     case Token::Type::True:</span>
<span class="line-modified">2068         return { makeUniqueRef&lt;AST::BooleanLiteral&gt;(*type, true) };</span>
<span class="line-modified">2069     case Token::Type::False:</span>
<span class="line-modified">2070         return { makeUniqueRef&lt;AST::BooleanLiteral&gt;(*type, false) };</span>
<span class="line-modified">2071     case Token::Type::Identifier: {</span>
<span class="line-modified">2072         auto name = type-&gt;stringView(m_lexer).toString();</span>
<span class="line-modified">2073         return { makeUniqueRef&lt;AST::VariableReference&gt;(*type, WTFMove(name)) };</span>
2074     }
2075     default: {
<span class="line-modified">2076         ASSERT(type-&gt;type == Token::Type::LeftParenthesis);</span>
<span class="line-modified">2077         PARSE(expression, Expression);</span>
<span class="line-modified">2078         CONSUME_TYPE(rightParenthesis, RightParenthesis);</span>





2079 
2080         return { WTFMove(*expression) };
2081     }
2082     }
2083 }
2084 
2085 } // namespace WHLSL
2086 
2087 } // namespace WebCore
2088 
2089 #endif // ENABLE(WEBGPU)
</pre>
</td>
</tr>
</table>
<center><a href="WHLSLNameResolver.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="WHLSLParser.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>