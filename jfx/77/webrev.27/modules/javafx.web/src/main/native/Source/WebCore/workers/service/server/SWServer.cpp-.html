<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.web/src/main/native/Source/WebCore/workers/service/server/SWServer.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2017 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;SWServer.h&quot;
 28 
 29 #if ENABLE(SERVICE_WORKER)
 30 
 31 #include &quot;ExceptionCode.h&quot;
 32 #include &quot;ExceptionData.h&quot;
 33 #include &quot;Logging.h&quot;
 34 #include &quot;RegistrationStore.h&quot;
 35 #include &quot;SWOriginStore.h&quot;
 36 #include &quot;SWServerJobQueue.h&quot;
 37 #include &quot;SWServerRegistration.h&quot;
 38 #include &quot;SWServerToContextConnection.h&quot;
 39 #include &quot;SWServerWorker.h&quot;
 40 #include &quot;SecurityOrigin.h&quot;
 41 #include &quot;ServiceWorkerClientType.h&quot;
 42 #include &quot;ServiceWorkerContextData.h&quot;
 43 #include &quot;ServiceWorkerFetchResult.h&quot;
 44 #include &quot;ServiceWorkerJobData.h&quot;
 45 #include &lt;wtf/CompletionHandler.h&gt;
 46 #include &lt;wtf/NeverDestroyed.h&gt;
 47 #include &lt;wtf/text/WTFString.h&gt;
 48 
 49 namespace WebCore {
 50 
 51 static Seconds terminationDelay { 10_s };
 52 
 53 SWServer::Connection::Connection(SWServer&amp; server)
 54     : m_server(server)
 55     , m_identifier(SWServerConnectionIdentifier::generate())
 56 {
 57 }
 58 
 59 HashSet&lt;SWServer*&gt;&amp; SWServer::allServers()
 60 {
 61     static NeverDestroyed&lt;HashSet&lt;SWServer*&gt;&gt; servers;
 62     return servers;
 63 }
 64 
 65 SWServer::~SWServer()
 66 {
 67     // Destroy the remaining connections before the SWServer gets destroyed since they have a raw pointer
 68     // to the server and since they try to unregister clients from the server in their destructor.
 69     auto connections = WTFMove(m_connections);
 70     connections.clear();
 71 
 72     allServers().remove(this);
 73 }
 74 
 75 SWServerWorker* SWServer::workerByID(ServiceWorkerIdentifier identifier) const
 76 {
 77     auto* worker = SWServerWorker::existingWorkerForIdentifier(identifier);
 78     ASSERT(!worker || &amp;worker-&gt;server() == this);
 79     return worker;
 80 }
 81 
 82 Optional&lt;ServiceWorkerClientData&gt; SWServer::serviceWorkerClientWithOriginByID(const ClientOrigin&amp; clientOrigin, const ServiceWorkerClientIdentifier&amp; clientIdentifier) const
 83 {
 84     auto iterator = m_clientIdentifiersPerOrigin.find(clientOrigin);
 85     if (iterator == m_clientIdentifiersPerOrigin.end())
 86         return WTF::nullopt;
 87 
 88     if (!iterator-&gt;value.identifiers.contains(clientIdentifier))
 89         return WTF::nullopt;
 90 
 91     auto clientIterator = m_clientsById.find(clientIdentifier);
 92     ASSERT(clientIterator != m_clientsById.end());
 93     return clientIterator-&gt;value;
 94 }
 95 
 96 String SWServer::serviceWorkerClientUserAgent(const ClientOrigin&amp; clientOrigin) const
 97 {
 98     auto iterator = m_clientIdentifiersPerOrigin.find(clientOrigin);
 99     if (iterator == m_clientIdentifiersPerOrigin.end())
100         return String();
101     return iterator-&gt;value.userAgent;
102 }
103 
104 SWServerWorker* SWServer::activeWorkerFromRegistrationID(ServiceWorkerRegistrationIdentifier identifier)
105 {
106     auto* registration = m_registrationsByID.get(identifier);
107     return registration ? registration-&gt;activeWorker() : nullptr;
108 }
109 
110 SWServerRegistration* SWServer::getRegistration(const ServiceWorkerRegistrationKey&amp; registrationKey)
111 {
112     return m_registrations.get(registrationKey);
113 }
114 
115 void SWServer::registrationStoreImportComplete()
116 {
117     ASSERT(!m_importCompleted);
118     m_importCompleted = true;
119     m_originStore-&gt;importComplete();
120 
121     auto clearCallbacks = WTFMove(m_clearCompletionCallbacks);
122     for (auto&amp; callback : clearCallbacks)
123         callback();
124 
125     performGetOriginsWithRegistrationsCallbacks();
126 }
127 
128 void SWServer::registrationStoreDatabaseFailedToOpen()
129 {
130     if (!m_importCompleted)
131         registrationStoreImportComplete();
132 }
133 
134 void SWServer::addRegistrationFromStore(ServiceWorkerContextData&amp;&amp; data)
135 {
136     // Pages should not have been able to make a new registration to this key while the import was still taking place.
137     ASSERT(!m_registrations.contains(data.registration.key));
138 
139     auto registration = std::make_unique&lt;SWServerRegistration&gt;(*this, data.registration.key, data.registration.updateViaCache, data.registration.scopeURL, data.scriptURL);
140     registration-&gt;setLastUpdateTime(data.registration.lastUpdateTime);
141     auto registrationPtr = registration.get();
142     addRegistration(WTFMove(registration));
143 
144     auto worker = SWServerWorker::create(*this, *registrationPtr, data.scriptURL, data.script, data.contentSecurityPolicy, WTFMove(data.referrerPolicy), data.workerType, data.serviceWorkerIdentifier, HashMap&lt;URL, ServiceWorkerContextData::ImportedScript&gt; { data.scriptResourceMap });
145     registrationPtr-&gt;updateRegistrationState(ServiceWorkerRegistrationState::Active, worker.ptr());
146     worker-&gt;setState(ServiceWorkerState::Activated);
147 }
148 
149 void SWServer::addRegistration(std::unique_ptr&lt;SWServerRegistration&gt;&amp;&amp; registration)
150 {
151     auto key = registration-&gt;key();
152     auto* registrationPtr = registration.get();
153     auto addResult1 = m_registrations.add(key, WTFMove(registration));
154     ASSERT_UNUSED(addResult1, addResult1.isNewEntry);
155 
156     auto addResult2 = m_registrationsByID.add(registrationPtr-&gt;identifier(), registrationPtr);
157     ASSERT_UNUSED(addResult2, addResult2.isNewEntry);
158 
159     m_originStore-&gt;add(key.topOrigin());
160 }
161 
162 void SWServer::removeRegistration(const ServiceWorkerRegistrationKey&amp; key)
163 {
164     auto topOrigin = key.topOrigin();
165     auto registration = m_registrations.take(key);
166     ASSERT(registration);
167     bool wasRemoved = m_registrationsByID.remove(registration-&gt;identifier());
168     ASSERT_UNUSED(wasRemoved, wasRemoved);
169 
170     m_originStore-&gt;remove(topOrigin);
171     if (m_registrationStore)
172         m_registrationStore-&gt;removeRegistration(*registration);
173 }
174 
175 Vector&lt;ServiceWorkerRegistrationData&gt; SWServer::getRegistrations(const SecurityOriginData&amp; topOrigin, const URL&amp; clientURL)
176 {
177     Vector&lt;SWServerRegistration*&gt; matchingRegistrations;
178     for (auto&amp; item : m_registrations) {
179         if (!item.value-&gt;isUninstalling() &amp;&amp; item.key.originIsMatching(topOrigin, clientURL))
180             matchingRegistrations.append(item.value.get());
181     }
182     // The specification mandates that registrations are returned in the insertion order.
183     std::sort(matchingRegistrations.begin(), matchingRegistrations.end(), [](auto&amp; a, auto&amp; b) {
184         return a-&gt;creationTime() &lt; b-&gt;creationTime();
185     });
186     Vector&lt;ServiceWorkerRegistrationData&gt; matchingRegistrationDatas;
187     matchingRegistrationDatas.reserveInitialCapacity(matchingRegistrations.size());
188     for (auto* registration : matchingRegistrations)
189         matchingRegistrationDatas.uncheckedAppend(registration-&gt;data());
190     return matchingRegistrationDatas;
191 }
192 
193 void SWServer::clearAll(CompletionHandler&lt;void()&gt;&amp;&amp; completionHandler)
194 {
195     if (!m_importCompleted) {
196         m_clearCompletionCallbacks.append([this, completionHandler = WTFMove(completionHandler)] () mutable {
197             ASSERT(m_importCompleted);
198             clearAll(WTFMove(completionHandler));
199         });
200         return;
201     }
202 
203     m_jobQueues.clear();
204     while (!m_registrations.isEmpty())
205         m_registrations.begin()-&gt;value-&gt;clear();
206     ASSERT(m_registrationsByID.isEmpty());
207     m_pendingContextDatas.clear();
208     m_originStore-&gt;clearAll();
209     if (m_registrationStore)
210         m_registrationStore-&gt;clearAll(WTFMove(completionHandler));
211 }
212 
213 void SWServer::clear(const SecurityOriginData&amp; securityOrigin, CompletionHandler&lt;void()&gt;&amp;&amp; completionHandler)
214 {
215     if (!m_importCompleted) {
216         m_clearCompletionCallbacks.append([this, securityOrigin, completionHandler = WTFMove(completionHandler)] () mutable {
217             ASSERT(m_importCompleted);
218             clear(securityOrigin, WTFMove(completionHandler));
219         });
220         return;
221     }
222 
223     m_jobQueues.removeIf([&amp;](auto&amp; keyAndValue) {
224         return keyAndValue.key.relatesToOrigin(securityOrigin);
225     });
226 
227     Vector&lt;SWServerRegistration*&gt; registrationsToRemove;
228     for (auto&amp; keyAndValue : m_registrations) {
229         if (keyAndValue.key.relatesToOrigin(securityOrigin))
230             registrationsToRemove.append(keyAndValue.value.get());
231     }
232 
233     for (auto&amp; contextDatas : m_pendingContextDatas.values()) {
234         contextDatas.removeAllMatching([&amp;](auto&amp; contextData) {
235             return contextData.registration.key.relatesToOrigin(securityOrigin);
236         });
237     }
238 
239     if (registrationsToRemove.isEmpty()) {
240         completionHandler();
241         return;
242     }
243 
244     // Calling SWServerRegistration::clear() takes care of updating m_registrations, m_originStore and m_registrationStore.
245     for (auto* registration : registrationsToRemove)
246         registration-&gt;clear();
247 
248     if (m_registrationStore)
249         m_registrationStore-&gt;flushChanges(WTFMove(completionHandler));
250 }
251 
252 void SWServer::Connection::finishFetchingScriptInServer(const ServiceWorkerFetchResult&amp; result)
253 {
254     m_server.scriptFetchFinished(*this, result);
255 }
256 
257 void SWServer::Connection::didResolveRegistrationPromise(const ServiceWorkerRegistrationKey&amp; key)
258 {
259     m_server.didResolveRegistrationPromise(*this, key);
260 }
261 
262 void SWServer::Connection::addServiceWorkerRegistrationInServer(ServiceWorkerRegistrationIdentifier identifier)
263 {
264     m_server.addClientServiceWorkerRegistration(*this, identifier);
265 }
266 
267 void SWServer::Connection::removeServiceWorkerRegistrationInServer(ServiceWorkerRegistrationIdentifier identifier)
268 {
269     m_server.removeClientServiceWorkerRegistration(*this, identifier);
270 }
271 
272 void SWServer::Connection::syncTerminateWorker(ServiceWorkerIdentifier identifier)
273 {
274     if (auto* worker = m_server.workerByID(identifier))
275         m_server.syncTerminateWorker(*worker);
276 }
277 
278 SWServer::SWServer(UniqueRef&lt;SWOriginStore&gt;&amp;&amp; originStore, String&amp;&amp; registrationDatabaseDirectory, PAL::SessionID sessionID)
279     : m_originStore(WTFMove(originStore))
280     , m_sessionID(sessionID)
281 {
282     ASSERT(!registrationDatabaseDirectory.isEmpty() || m_sessionID.isEphemeral());
283     if (!m_sessionID.isEphemeral())
284         m_registrationStore = std::make_unique&lt;RegistrationStore&gt;(*this, WTFMove(registrationDatabaseDirectory));
285     else
286         registrationStoreImportComplete();
287 
288     UNUSED_PARAM(registrationDatabaseDirectory);
289     allServers().add(this);
290 }
291 
292 // https://w3c.github.io/ServiceWorker/#schedule-job-algorithm
293 void SWServer::scheduleJob(ServiceWorkerJobData&amp;&amp; jobData)
294 {
295     ASSERT(m_connections.contains(jobData.connectionIdentifier()));
296 
297     // FIXME: Per the spec, check if this job is equivalent to the last job on the queue.
298     // If it is, stack it along with that job.
299 
300     auto&amp; jobQueue = *m_jobQueues.ensure(jobData.registrationKey(), [this, &amp;jobData] {
301         return std::make_unique&lt;SWServerJobQueue&gt;(*this, jobData.registrationKey());
302     }).iterator-&gt;value;
303 
304     jobQueue.enqueueJob(jobData);
305     if (jobQueue.size() == 1)
306         jobQueue.runNextJob();
307 }
308 
309 void SWServer::rejectJob(const ServiceWorkerJobData&amp; jobData, const ExceptionData&amp; exceptionData)
310 {
311     LOG(ServiceWorker, &quot;Rejected ServiceWorker job %s in server&quot;, jobData.identifier().loggingString().utf8().data());
312     auto* connection = m_connections.get(jobData.connectionIdentifier());
313     if (!connection)
314         return;
315 
316     connection-&gt;rejectJobInClient(jobData.identifier().jobIdentifier, exceptionData);
317 }
318 
319 void SWServer::resolveRegistrationJob(const ServiceWorkerJobData&amp; jobData, const ServiceWorkerRegistrationData&amp; registrationData, ShouldNotifyWhenResolved shouldNotifyWhenResolved)
320 {
321     LOG(ServiceWorker, &quot;Resolved ServiceWorker job %s in server with registration %s&quot;, jobData.identifier().loggingString().utf8().data(), registrationData.identifier.loggingString().utf8().data());
322     auto* connection = m_connections.get(jobData.connectionIdentifier());
323     if (!connection)
324         return;
325 
326     connection-&gt;resolveRegistrationJobInClient(jobData.identifier().jobIdentifier, registrationData, shouldNotifyWhenResolved);
327 }
328 
329 void SWServer::resolveUnregistrationJob(const ServiceWorkerJobData&amp; jobData, const ServiceWorkerRegistrationKey&amp; registrationKey, bool unregistrationResult)
330 {
331     auto* connection = m_connections.get(jobData.connectionIdentifier());
332     if (!connection)
333         return;
334 
335     connection-&gt;resolveUnregistrationJobInClient(jobData.identifier().jobIdentifier, registrationKey, unregistrationResult);
336 }
337 
338 void SWServer::startScriptFetch(const ServiceWorkerJobData&amp; jobData, FetchOptions::Cache cachePolicy)
339 {
340     LOG(ServiceWorker, &quot;Server issuing startScriptFetch for current job %s in client&quot;, jobData.identifier().loggingString().utf8().data());
341     auto* connection = m_connections.get(jobData.connectionIdentifier());
342     ASSERT_WITH_MESSAGE(connection, &quot;If the connection was lost, this job should have been cancelled&quot;);
343     if (connection)
344         connection-&gt;startScriptFetchInClient(jobData.identifier().jobIdentifier, jobData.registrationKey(), cachePolicy);
345 }
346 
347 void SWServer::scriptFetchFinished(Connection&amp; connection, const ServiceWorkerFetchResult&amp; result)
348 {
349     LOG(ServiceWorker, &quot;Server handling scriptFetchFinished for current job %s in client&quot;, result.jobDataIdentifier.loggingString().utf8().data());
350 
351     ASSERT(m_connections.contains(result.jobDataIdentifier.connectionIdentifier));
352 
353     auto jobQueue = m_jobQueues.get(result.registrationKey);
354     if (!jobQueue)
355         return;
356 
357     jobQueue-&gt;scriptFetchFinished(connection, result);
358 }
359 
360 void SWServer::scriptContextFailedToStart(const Optional&lt;ServiceWorkerJobDataIdentifier&gt;&amp; jobDataIdentifier, SWServerWorker&amp; worker, const String&amp; message)
361 {
362     if (!jobDataIdentifier)
363         return;
364 
365     RELEASE_LOG_ERROR(ServiceWorker, &quot;%p - SWServer::scriptContextFailedToStart: Failed to start SW for job %s, error: %s&quot;, this, jobDataIdentifier-&gt;loggingString().utf8().data(), message.utf8().data());
366 
367     auto* jobQueue = m_jobQueues.get(worker.registrationKey());
368     if (!jobQueue || !jobQueue-&gt;isCurrentlyProcessingJob(*jobDataIdentifier)) {
369         // The job which started this worker has been canceled, terminate this worker.
370         terminatePreinstallationWorker(worker);
371         return;
372     }
373     jobQueue-&gt;scriptContextFailedToStart(*jobDataIdentifier, worker.identifier(), message);
374 }
375 
376 void SWServer::scriptContextStarted(const Optional&lt;ServiceWorkerJobDataIdentifier&gt;&amp; jobDataIdentifier, SWServerWorker&amp; worker)
377 {
378     if (!jobDataIdentifier)
379         return;
380 
381     auto* jobQueue = m_jobQueues.get(worker.registrationKey());
382     if (!jobQueue || !jobQueue-&gt;isCurrentlyProcessingJob(*jobDataIdentifier)) {
383         // The job which started this worker has been canceled, terminate this worker.
384         terminatePreinstallationWorker(worker);
385         return;
386     }
387     jobQueue-&gt;scriptContextStarted(*jobDataIdentifier, worker.identifier());
388 }
389 
390 void SWServer::terminatePreinstallationWorker(SWServerWorker&amp; worker)
391 {
392     worker.terminate();
393     auto* registration = getRegistration(worker.registrationKey());
394     if (registration &amp;&amp; registration-&gt;preInstallationWorker() == &amp;worker)
395         registration-&gt;setPreInstallationWorker(nullptr);
396 }
397 
398 void SWServer::didFinishInstall(const Optional&lt;ServiceWorkerJobDataIdentifier&gt;&amp; jobDataIdentifier, SWServerWorker&amp; worker, bool wasSuccessful)
399 {
400     if (!jobDataIdentifier)
401         return;
402 
403     if (wasSuccessful)
404         RELEASE_LOG(ServiceWorker, &quot;%p - SWServer::didFinishInstall: Successfuly finished SW install for job %s&quot;, this, jobDataIdentifier-&gt;loggingString().utf8().data());
405     else
406         RELEASE_LOG_ERROR(ServiceWorker, &quot;%p - SWServer::didFinishInstall: Failed SW install for job %s&quot;, this, jobDataIdentifier-&gt;loggingString().utf8().data());
407 
408     if (auto* jobQueue = m_jobQueues.get(worker.registrationKey()))
409         jobQueue-&gt;didFinishInstall(*jobDataIdentifier, worker.identifier(), wasSuccessful);
410 }
411 
412 void SWServer::didFinishActivation(SWServerWorker&amp; worker)
413 {
414     RELEASE_LOG(ServiceWorker, &quot;%p - SWServer::didFinishActivation: Finished activation for service worker %llu&quot;, this, worker.identifier().toUInt64());
415 
416     auto* registration = getRegistration(worker.registrationKey());
417     if (!registration)
418         return;
419 
420     if (m_registrationStore)
421         m_registrationStore-&gt;updateRegistration(worker.contextData());
422     registration-&gt;didFinishActivation(worker.identifier());
423 }
424 
425 // https://w3c.github.io/ServiceWorker/#clients-getall
426 void SWServer::matchAll(SWServerWorker&amp; worker, const ServiceWorkerClientQueryOptions&amp; options, ServiceWorkerClientsMatchAllCallback&amp;&amp; callback)
427 {
428     // FIXME: Support reserved client filtering.
429     // FIXME: Support WindowClient additional properties.
430 
431     Vector&lt;ServiceWorkerClientData&gt; matchingClients;
432     forEachClientForOrigin(worker.origin(), [&amp;](auto&amp; clientData) {
433         if (!options.includeUncontrolled) {
434             auto registrationIdentifier = m_clientToControllingRegistration.get(clientData.identifier);
435             if (worker.data().registrationIdentifier != registrationIdentifier)
436                 return;
437             if (&amp;worker != this-&gt;activeWorkerFromRegistrationID(registrationIdentifier))
438                 return;
439         }
440         if (options.type != ServiceWorkerClientType::All &amp;&amp; options.type != clientData.type)
441             return;
442         matchingClients.append(clientData);
443     });
444     callback(WTFMove(matchingClients));
445 }
446 
447 void SWServer::forEachClientForOrigin(const ClientOrigin&amp; origin, const WTF::Function&lt;void(ServiceWorkerClientData&amp;)&gt;&amp; apply)
448 {
449     auto iterator = m_clientIdentifiersPerOrigin.find(origin);
450     if (iterator == m_clientIdentifiersPerOrigin.end())
451         return;
452 
453     for (auto&amp; clientIdentifier : iterator-&gt;value.identifiers) {
454         auto clientIterator = m_clientsById.find(clientIdentifier);
455         ASSERT(clientIterator != m_clientsById.end());
456         apply(clientIterator-&gt;value);
457     }
458 }
459 
460 void SWServer::claim(SWServerWorker&amp; worker)
461 {
462     auto&amp; origin = worker.origin();
463     forEachClientForOrigin(origin, [&amp;](auto&amp; clientData) {
464         auto* registration = this-&gt;doRegistrationMatching(origin.topOrigin, clientData.url);
465         if (!(registration &amp;&amp; registration-&gt;key() == worker.registrationKey()))
466             return;
467 
468         auto result = m_clientToControllingRegistration.add(clientData.identifier, registration-&gt;identifier());
469         if (!result.isNewEntry) {
470             auto previousIdentifier = result.iterator-&gt;value;
471             if (previousIdentifier == registration-&gt;identifier())
472                 return;
473             result.iterator-&gt;value = registration-&gt;identifier();
474             if (auto* controllingRegistration = m_registrationsByID.get(previousIdentifier))
475                 controllingRegistration-&gt;removeClientUsingRegistration(clientData.identifier);
476         }
477         registration-&gt;controlClient(clientData.identifier);
478     });
479 }
480 
481 void SWServer::didResolveRegistrationPromise(Connection&amp; connection, const ServiceWorkerRegistrationKey&amp; registrationKey)
482 {
483     ASSERT_UNUSED(connection, m_connections.contains(connection.identifier()));
484 
485     if (auto* jobQueue = m_jobQueues.get(registrationKey))
486         jobQueue-&gt;didResolveRegistrationPromise();
487 }
488 
489 void SWServer::addClientServiceWorkerRegistration(Connection&amp; connection, ServiceWorkerRegistrationIdentifier identifier)
490 {
491     auto* registration = m_registrationsByID.get(identifier);
492     if (!registration) {
493         LOG_ERROR(&quot;Request to add client-side ServiceWorkerRegistration to non-existent server-side registration&quot;);
494         return;
495     }
496 
497     registration-&gt;addClientServiceWorkerRegistration(connection.identifier());
498 }
499 
500 void SWServer::removeClientServiceWorkerRegistration(Connection&amp; connection, ServiceWorkerRegistrationIdentifier identifier)
501 {
502     if (auto* registration = m_registrationsByID.get(identifier))
503         registration-&gt;removeClientServiceWorkerRegistration(connection.identifier());
504 }
505 
506 void SWServer::updateWorker(Connection&amp;, const ServiceWorkerJobDataIdentifier&amp; jobDataIdentifier, SWServerRegistration&amp; registration, const URL&amp; url, const String&amp; script, const ContentSecurityPolicyResponseHeaders&amp; contentSecurityPolicy, const String&amp; referrerPolicy, WorkerType type, HashMap&lt;URL, ServiceWorkerContextData::ImportedScript&gt;&amp;&amp; scriptResourceMap)
507 {
508     tryInstallContextData({ jobDataIdentifier, registration.data(), ServiceWorkerIdentifier::generate(), script, contentSecurityPolicy, referrerPolicy, url, type, sessionID(), false, WTFMove(scriptResourceMap) });
509 }
510 
511 void SWServer::tryInstallContextData(ServiceWorkerContextData&amp;&amp; data)
512 {
513     auto securityOrigin = SecurityOriginData::fromURL(data.scriptURL);
514     auto* connection = SWServerToContextConnection::connectionForOrigin(securityOrigin);
515     if (!connection) {
516         m_pendingContextDatas.ensure(WTFMove(securityOrigin), [] {
517             return Vector&lt;ServiceWorkerContextData&gt; { };
518         }).iterator-&gt;value.append(WTFMove(data));
519         return;
520     }
521 
522     installContextData(data);
523 }
524 
525 void SWServer::serverToContextConnectionCreated(SWServerToContextConnection&amp; contextConnection)
526 {
527     auto pendingContextDatas = m_pendingContextDatas.take(contextConnection.securityOrigin());
528     for (auto&amp; data : pendingContextDatas)
529         installContextData(data);
530 
531     auto serviceWorkerRunRequests = m_serviceWorkerRunRequests.take(contextConnection.securityOrigin());
532     for (auto&amp; item : serviceWorkerRunRequests) {
533         bool success = runServiceWorker(item.key);
534         for (auto&amp; callback : item.value)
535             callback(success ? &amp;contextConnection : nullptr);
536     }
537 }
538 
539 void SWServer::installContextData(const ServiceWorkerContextData&amp; data)
540 {
541     ASSERT_WITH_MESSAGE(!data.loadedFromDisk, &quot;Workers we just read from disk should only be launched as needed&quot;);
542 
543     if (data.jobDataIdentifier) {
544         // Abort if the job that scheduled this has been cancelled.
545         auto* jobQueue = m_jobQueues.get(data.registration.key);
546         if (!jobQueue || !jobQueue-&gt;isCurrentlyProcessingJob(*data.jobDataIdentifier))
547             return;
548     }
549 
550     auto* registration = m_registrations.get(data.registration.key);
551     RELEASE_ASSERT(registration);
552 
553     auto worker = SWServerWorker::create(*this, *registration, data.scriptURL, data.script, data.contentSecurityPolicy, String { data.referrerPolicy }, data.workerType, data.serviceWorkerIdentifier, HashMap&lt;URL, ServiceWorkerContextData::ImportedScript&gt; { data.scriptResourceMap });
554 
555     auto* connection = worker-&gt;contextConnection();
556     ASSERT(connection);
557 
558     registration-&gt;setPreInstallationWorker(worker.ptr());
559     worker-&gt;setState(SWServerWorker::State::Running);
560     auto userAgent = worker-&gt;userAgent();
561     auto result = m_runningOrTerminatingWorkers.add(data.serviceWorkerIdentifier, WTFMove(worker));
562     ASSERT_UNUSED(result, result.isNewEntry);
563 
564     connection-&gt;installServiceWorkerContext(data, m_sessionID, userAgent);
565 }
566 
567 void SWServer::runServiceWorkerIfNecessary(ServiceWorkerIdentifier identifier, RunServiceWorkerCallback&amp;&amp; callback)
568 {
569     auto* worker = workerByID(identifier);
570     if (!worker) {
571         callback(nullptr);
572         return;
573     }
574 
575     auto* contextConnection = worker-&gt;contextConnection();
576     if (worker-&gt;isRunning()) {
577         ASSERT(contextConnection);
578         callback(contextConnection);
579         return;
580     }
581 
582     if (!contextConnection) {
583         auto&amp; serviceWorkerRunRequestsForOrigin = m_serviceWorkerRunRequests.ensure(worker-&gt;securityOrigin(), [] {
584             return HashMap&lt;ServiceWorkerIdentifier, Vector&lt;RunServiceWorkerCallback&gt;&gt; { };
585         }).iterator-&gt;value;
586         serviceWorkerRunRequestsForOrigin.ensure(identifier, [&amp;] {
587             return Vector&lt;RunServiceWorkerCallback&gt; { };
588         }).iterator-&gt;value.append(WTFMove(callback));
589         return;
590     }
591 
592     bool success = runServiceWorker(identifier);
593     callback(success ? contextConnection : nullptr);
594 }
595 
596 bool SWServer::runServiceWorker(ServiceWorkerIdentifier identifier)
597 {
598     auto* worker = workerByID(identifier);
599     if (!worker)
600         return false;
601 
602     // If the registration for a working has been removed then the request to run
603     // the worker is moot.
604     if (!getRegistration(worker-&gt;registrationKey()))
605         return false;
606 
607     auto addResult = m_runningOrTerminatingWorkers.add(identifier, *worker);
608     ASSERT_UNUSED(addResult, addResult.isNewEntry || worker-&gt;isTerminating());
609 
610     worker-&gt;setState(SWServerWorker::State::Running);
611 
612     auto* contextConnection = worker-&gt;contextConnection();
613     ASSERT(contextConnection);
614 
615     contextConnection-&gt;installServiceWorkerContext(worker-&gt;contextData(), m_sessionID, worker-&gt;userAgent());
616 
617     return true;
618 }
619 
620 void SWServer::terminateWorker(SWServerWorker&amp; worker)
621 {
622     terminateWorkerInternal(worker, Asynchronous);
623 }
624 
625 void SWServer::syncTerminateWorker(SWServerWorker&amp; worker)
626 {
627     terminateWorkerInternal(worker, Synchronous);
628 }
629 
630 void SWServer::terminateWorkerInternal(SWServerWorker&amp; worker, TerminationMode mode)
631 {
632     ASSERT(m_runningOrTerminatingWorkers.get(worker.identifier()) == &amp;worker);
633     ASSERT(worker.isRunning());
634 
635     RELEASE_LOG(ServiceWorker, &quot;%p - SWServer::terminateWorkerInternal: Terminating service worker %llu&quot;, this, worker.identifier().toUInt64());
636 
637     worker.setState(SWServerWorker::State::Terminating);
638 
639     auto* contextConnection = worker.contextConnection();
640     ASSERT(contextConnection);
641     if (!contextConnection) {
642         LOG_ERROR(&quot;Request to terminate a worker whose context connection does not exist&quot;);
643         workerContextTerminated(worker);
644         return;
645     }
646 
647     switch (mode) {
648     case Asynchronous:
649         contextConnection-&gt;terminateWorker(worker.identifier());
650         break;
651     case Synchronous:
652         contextConnection-&gt;syncTerminateWorker(worker.identifier());
653         break;
654     };
655 }
656 
657 void SWServer::markAllWorkersForOriginAsTerminated(const SecurityOriginData&amp; securityOrigin)
658 {
659     Vector&lt;SWServerWorker*&gt; terminatedWorkers;
660     for (auto&amp; worker : m_runningOrTerminatingWorkers.values()) {
661         if (worker-&gt;securityOrigin() == securityOrigin)
662             terminatedWorkers.append(worker.ptr());
663     }
664     for (auto&amp; terminatedWorker : terminatedWorkers)
665         workerContextTerminated(*terminatedWorker);
666 }
667 
668 void SWServer::workerContextTerminated(SWServerWorker&amp; worker)
669 {
670     worker.setState(SWServerWorker::State::NotRunning);
671 
672     if (auto* jobQueue = m_jobQueues.get(worker.registrationKey()))
673         jobQueue-&gt;cancelJobsFromServiceWorker(worker.identifier());
674 
675     // At this point if no registrations are referencing the worker then it will be destroyed,
676     // removing itself from the m_workersByID map.
677     auto result = m_runningOrTerminatingWorkers.take(worker.identifier());
678     ASSERT_UNUSED(result, result &amp;&amp; result-&gt;ptr() == &amp;worker);
679 }
680 
681 void SWServer::fireInstallEvent(SWServerWorker&amp; worker)
682 {
683     auto* contextConnection = worker.contextConnection();
684     if (!contextConnection) {
685         LOG_ERROR(&quot;Request to fire install event on a worker whose context connection does not exist&quot;);
686         return;
687     }
688 
689     contextConnection-&gt;fireInstallEvent(worker.identifier());
690 }
691 
692 void SWServer::fireActivateEvent(SWServerWorker&amp; worker)
693 {
694     auto* contextConnection = worker.contextConnection();
695     if (!contextConnection) {
696         LOG_ERROR(&quot;Request to fire install event on a worker whose context connection does not exist&quot;);
697         return;
698     }
699 
700     contextConnection-&gt;fireActivateEvent(worker.identifier());
701 }
702 
703 void SWServer::addConnection(std::unique_ptr&lt;Connection&gt;&amp;&amp; connection)
704 {
705     auto identifier = connection-&gt;identifier();
706     ASSERT(!m_connections.contains(identifier));
707     m_connections.add(identifier, WTFMove(connection));
708 }
709 
710 void SWServer::removeConnection(SWServerConnectionIdentifier connectionIdentifier)
711 {
712     ASSERT(m_connections.contains(connectionIdentifier));
713     m_connections.remove(connectionIdentifier);
714 
715     for (auto&amp; registration : m_registrations.values())
716         registration-&gt;unregisterServerConnection(connectionIdentifier);
717 
718     for (auto&amp; jobQueue : m_jobQueues.values())
719         jobQueue-&gt;cancelJobsFromConnection(connectionIdentifier);
720 }
721 
722 SWServerRegistration* SWServer::doRegistrationMatching(const SecurityOriginData&amp; topOrigin, const URL&amp; clientURL)
723 {
724     SWServerRegistration* selectedRegistration = nullptr;
725     for (auto&amp; registration : m_registrations.values()) {
726         if (!registration-&gt;key().isMatching(topOrigin, clientURL))
727             continue;
728         if (!selectedRegistration || selectedRegistration-&gt;key().scopeLength() &lt; registration-&gt;key().scopeLength())
729             selectedRegistration = registration.get();
730     }
731 
732     return (selectedRegistration &amp;&amp; !selectedRegistration-&gt;isUninstalling()) ? selectedRegistration : nullptr;
733 }
734 
735 SWServerRegistration* SWServer::registrationFromServiceWorkerIdentifier(ServiceWorkerIdentifier identifier)
736 {
737     auto iterator = m_runningOrTerminatingWorkers.find(identifier);
738     if (iterator == m_runningOrTerminatingWorkers.end())
739         return nullptr;
740 
741     return m_registrations.get(iterator-&gt;value-&gt;registrationKey());
742 }
743 
744 void SWServer::registerServiceWorkerClient(ClientOrigin&amp;&amp; clientOrigin, ServiceWorkerClientData&amp;&amp; data, const Optional&lt;ServiceWorkerRegistrationIdentifier&gt;&amp; controllingServiceWorkerRegistrationIdentifier, String&amp;&amp; userAgent)
745 {
746     auto clientIdentifier = data.identifier;
747 
748     ASSERT(!m_clientsById.contains(clientIdentifier));
749     m_clientsById.add(clientIdentifier, WTFMove(data));
750 
751     auto&amp; clientIdentifiersForOrigin = m_clientIdentifiersPerOrigin.ensure(clientOrigin, [] {
752         return Clients { };
753     }).iterator-&gt;value;
754 
755     ASSERT(!clientIdentifiersForOrigin.identifiers.contains(clientIdentifier));
756     clientIdentifiersForOrigin.identifiers.append(clientIdentifier);
757 
758     if (!clientIdentifiersForOrigin.userAgent.isNull() &amp;&amp; clientIdentifiersForOrigin.userAgent != userAgent)
759         RELEASE_LOG_ERROR(ServiceWorker, &quot;%p - SWServer::registerServiceWorkerClient: Service worker has clients using different user agents&quot;, this);
760     clientIdentifiersForOrigin.userAgent = WTFMove(userAgent);
761 
762     clientIdentifiersForOrigin.terminateServiceWorkersTimer = nullptr;
763 
764     m_clientsBySecurityOrigin.ensure(clientOrigin.clientOrigin, [] {
765         return HashSet&lt;ServiceWorkerClientIdentifier&gt; { };
766     }).iterator-&gt;value.add(clientIdentifier);
767 
768     if (!controllingServiceWorkerRegistrationIdentifier)
769         return;
770 
771     auto* controllingRegistration = m_registrationsByID.get(*controllingServiceWorkerRegistrationIdentifier);
772     if (!controllingRegistration || !controllingRegistration-&gt;activeWorker())
773         return;
774 
775     controllingRegistration-&gt;addClientUsingRegistration(clientIdentifier);
776     ASSERT(!m_clientToControllingRegistration.contains(clientIdentifier));
777     m_clientToControllingRegistration.add(clientIdentifier, *controllingServiceWorkerRegistrationIdentifier);
778 }
779 
780 void SWServer::unregisterServiceWorkerClient(const ClientOrigin&amp; clientOrigin, ServiceWorkerClientIdentifier clientIdentifier)
781 {
782     bool wasRemoved = m_clientsById.remove(clientIdentifier);
783     ASSERT_UNUSED(wasRemoved, wasRemoved);
784 
785     auto iterator = m_clientIdentifiersPerOrigin.find(clientOrigin);
786     ASSERT(iterator != m_clientIdentifiersPerOrigin.end());
787 
788     auto&amp; clientIdentifiers = iterator-&gt;value.identifiers;
789     clientIdentifiers.removeFirstMatching([&amp;] (const auto&amp; identifier) {
790         return clientIdentifier == identifier;
791     });
792     if (clientIdentifiers.isEmpty()) {
793         ASSERT(!iterator-&gt;value.terminateServiceWorkersTimer);
794         iterator-&gt;value.terminateServiceWorkersTimer = std::make_unique&lt;Timer&gt;([clientOrigin, this] {
795             Vector&lt;SWServerWorker*&gt; workersToTerminate;
796             for (auto&amp; worker : m_runningOrTerminatingWorkers.values()) {
797                 if (worker-&gt;isRunning() &amp;&amp; worker-&gt;origin() == clientOrigin)
798                     workersToTerminate.append(worker.ptr());
799             }
800             for (auto* worker : workersToTerminate)
801                 terminateWorker(*worker);
802 
803             if (!m_clientsBySecurityOrigin.contains(clientOrigin.clientOrigin)) {
804                 if (auto* connection = SWServerToContextConnection::connectionForOrigin(clientOrigin.clientOrigin))
805                     connection-&gt;connectionMayNoLongerBeNeeded();
806             }
807 
808             m_clientIdentifiersPerOrigin.remove(clientOrigin);
809         });
810         iterator-&gt;value.terminateServiceWorkersTimer-&gt;startOneShot(m_shouldDisableServiceWorkerProcessTerminationDelay ? 0_s : terminationDelay);
811     }
812 
813     auto clientsBySecurityOriginIterator = m_clientsBySecurityOrigin.find(clientOrigin.clientOrigin);
814     ASSERT(clientsBySecurityOriginIterator != m_clientsBySecurityOrigin.end());
815     auto&amp; clientsForSecurityOrigin = clientsBySecurityOriginIterator-&gt;value;
816     clientsForSecurityOrigin.remove(clientIdentifier);
817     if (clientsForSecurityOrigin.isEmpty())
818         m_clientsBySecurityOrigin.remove(clientsBySecurityOriginIterator);
819 
820     auto registrationIterator = m_clientToControllingRegistration.find(clientIdentifier);
821     if (registrationIterator == m_clientToControllingRegistration.end())
822         return;
823 
824     if (auto* registration = m_registrationsByID.get(registrationIterator-&gt;value))
825         registration-&gt;removeClientUsingRegistration(clientIdentifier);
826 
827     m_clientToControllingRegistration.remove(registrationIterator);
828 }
829 
830 bool SWServer::needsServerToContextConnectionForOrigin(const SecurityOriginData&amp; securityOrigin) const
831 {
832     return m_clientsBySecurityOrigin.contains(securityOrigin);
833 }
834 
835 void SWServer::resolveRegistrationReadyRequests(SWServerRegistration&amp; registration)
836 {
837     for (auto&amp; connection : m_connections.values())
838         connection-&gt;resolveRegistrationReadyRequests(registration);
839 }
840 
841 void SWServer::Connection::whenRegistrationReady(uint64_t registrationReadyRequestIdentifier, const SecurityOriginData&amp; topOrigin, const URL&amp; clientURL)
842 {
843     if (auto* registration = doRegistrationMatching(topOrigin, clientURL)) {
844         if (registration-&gt;activeWorker()) {
845             registrationReady(registrationReadyRequestIdentifier, registration-&gt;data());
846             return;
847         }
848     }
849     m_registrationReadyRequests.append({ topOrigin, clientURL, registrationReadyRequestIdentifier });
850 }
851 
852 void SWServer::Connection::resolveRegistrationReadyRequests(SWServerRegistration&amp; registration)
853 {
854     m_registrationReadyRequests.removeAllMatching([&amp;](auto&amp; request) {
855         if (!registration.key().isMatching(request.topOrigin, request.clientURL))
856             return false;
857 
858         this-&gt;registrationReady(request.identifier, registration.data());
859         return true;
860     });
861 }
862 
863 void SWServer::getOriginsWithRegistrations(Function&lt;void(const HashSet&lt;SecurityOriginData&gt;&amp;)&gt;&amp;&amp; callback)
864 {
865     m_getOriginsWithRegistrationsCallbacks.append(WTFMove(callback));
866 
867     if (m_importCompleted)
868         performGetOriginsWithRegistrationsCallbacks();
869 }
870 
871 void SWServer::performGetOriginsWithRegistrationsCallbacks()
872 {
873     ASSERT(isMainThread());
874     ASSERT(m_importCompleted);
875 
876     if (m_getOriginsWithRegistrationsCallbacks.isEmpty())
877         return;
878 
879     HashSet&lt;SecurityOriginData&gt; originsWithRegistrations;
880     for (auto&amp; key : m_registrations.keys()) {
881         originsWithRegistrations.add(key.topOrigin());
882         originsWithRegistrations.add(SecurityOriginData { key.scope().protocol().toString(), key.scope().host().toString(), key.scope().port() });
883     }
884 
885     auto callbacks = WTFMove(m_getOriginsWithRegistrationsCallbacks);
886     for (auto&amp; callback : callbacks)
887         callback(originsWithRegistrations);
888 }
889 
890 } // namespace WebCore
891 
892 #endif // ENABLE(SERVICE_WORKER)
    </pre>
  </body>
</html>