<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/parser/Parser.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="Nodes.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Parser.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/parser/Parser.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  71     if (strictMode() &amp;&amp; token.m_type == RESERVED_IF_STRICT) \
  72         semanticFail(&quot;Cannot use the reserved word &#39;&quot;, getToken(token), &quot;&#39; as a &quot;, __VA_ARGS__, &quot; in strict mode&quot;); \
  73     if (token.m_type == RESERVED || token.m_type == RESERVED_IF_STRICT) \
  74         semanticFail(&quot;Cannot use the reserved word &#39;&quot;, getToken(token), &quot;&#39; as a &quot;, __VA_ARGS__); \
  75     if (token.m_type &amp; KeywordTokenFlag) { \
  76         if (!isAnyContextualKeyword(token)) \
  77             semanticFail(&quot;Cannot use the keyword &#39;&quot;, getToken(token), &quot;&#39; as a &quot;, __VA_ARGS__); \
  78         if (isDisallowedIdentifierLet(token)) \
  79             semanticFail(&quot;Cannot use &#39;let&#39; as a &quot;, __VA_ARGS__, &quot; &quot;, disallowedIdentifierLetReason()); \
  80         if (isDisallowedIdentifierAwait(token)) \
  81             semanticFail(&quot;Cannot use &#39;await&#39; as a &quot;, __VA_ARGS__, &quot; &quot;, disallowedIdentifierAwaitReason()); \
  82         if (isDisallowedIdentifierYield(token)) \
  83             semanticFail(&quot;Cannot use &#39;yield&#39; as a &quot;, __VA_ARGS__, &quot; &quot;, disallowedIdentifierYieldReason()); \
  84     } \
  85 } while (0)
  86 
  87 #define semanticFailureDueToKeyword(...) semanticFailureDueToKeywordCheckingToken(m_token, __VA_ARGS__);
  88 
  89 namespace JSC {
  90 


  91 ALWAYS_INLINE static SourceParseMode getAsynFunctionBodyParseMode(SourceParseMode parseMode)
  92 {
  93     if (isAsyncGeneratorWrapperParseMode(parseMode))
  94         return SourceParseMode::AsyncGeneratorBodyMode;
  95 
  96     if (parseMode == SourceParseMode::AsyncArrowFunctionMode)
  97         return SourceParseMode::AsyncArrowFunctionBodyMode;
  98 
  99     return SourceParseMode::AsyncFunctionBodyMode;
 100 }
 101 
 102 template &lt;typename LexerType&gt;
 103 void Parser&lt;LexerType&gt;::logError(bool)
 104 {
 105     if (hasError())
 106         return;
 107     StringPrintStream stream;
 108     printUnexpectedTokenText(stream);
 109     setErrorMessage(stream.toStringWithLatin1Fallback());
 110 }
 111 
 112 template &lt;typename LexerType&gt; template &lt;typename... Args&gt;
 113 void Parser&lt;LexerType&gt;::logError(bool shouldPrintToken, Args&amp;&amp;... args)
 114 {
 115     if (hasError())
 116         return;
 117     StringPrintStream stream;
 118     if (shouldPrintToken) {
 119         printUnexpectedTokenText(stream);
 120         stream.print(&quot;. &quot;);
 121     }
 122     stream.print(std::forward&lt;Args&gt;(args)..., &quot;.&quot;);
 123     setErrorMessage(stream.toStringWithLatin1Fallback());
 124 }
 125 
 126 template &lt;typename LexerType&gt;
<span class="line-modified"> 127 Parser&lt;LexerType&gt;::Parser(VM* vm, const SourceCode&amp; source, JSParserBuiltinMode builtinMode, JSParserStrictMode strictMode, JSParserScriptMode scriptMode, SourceParseMode parseMode, SuperBinding superBinding, ConstructorKind defaultConstructorKind, DerivedContextType derivedContextType, bool isEvalContext, EvalContextType evalContextType, DebuggerParseData* debuggerParseData)</span>
 128     : m_vm(vm)
 129     , m_source(&amp;source)
 130     , m_hasStackOverflow(false)
 131     , m_allowsIn(true)
 132     , m_statementDepth(0)
 133     , m_sourceElements(0)
 134     , m_parsingBuiltin(builtinMode == JSParserBuiltinMode::Builtin)
 135     , m_scriptMode(scriptMode)
 136     , m_superBinding(superBinding)
 137     , m_defaultConstructorKind(defaultConstructorKind)
 138     , m_immediateParentAllowsFunctionDeclarationInStatement(false)
 139     , m_debuggerParseData(debuggerParseData)
 140 {
<span class="line-modified"> 141     m_lexer = std::make_unique&lt;LexerType&gt;(vm, builtinMode, scriptMode);</span>
 142     m_lexer-&gt;setCode(source, &amp;m_parserArena);
 143     m_token.m_location.line = source.firstLine().oneBasedInt();
 144     m_token.m_location.startOffset = source.startOffset();
 145     m_token.m_location.endOffset = source.startOffset();
 146     m_token.m_location.lineStartOffset = source.startOffset();
<span class="line-modified"> 147     m_functionCache = vm-&gt;addSourceProviderCache(source.provider());</span>
 148     m_expressionErrorClassifier = nullptr;
 149 
 150     ScopeRef scope = pushScope();
 151     scope-&gt;setSourceParseMode(parseMode);
 152     scope-&gt;setIsEvalContext(isEvalContext);
 153     if (isEvalContext)
 154         scope-&gt;setEvalContextType(evalContextType);
 155 
 156     if (derivedContextType == DerivedContextType::DerivedConstructorContext) {
 157         scope-&gt;setConstructorKind(ConstructorKind::Extends);
 158         scope-&gt;setExpectedSuperBinding(SuperBinding::Needed);
 159     }
 160 
 161     if (derivedContextType == DerivedContextType::DerivedMethodContext)
 162         scope-&gt;setExpectedSuperBinding(SuperBinding::Needed);
 163 
 164     if (strictMode == JSParserStrictMode::Strict)
 165         scope-&gt;setStrictMode();
 166 
 167     if (isModuleParseMode(parseMode))
 168         m_moduleScopeData = ModuleScopeData::create();
 169 
 170     if (isProgramOrModuleParseMode(parseMode))
 171         scope-&gt;setIsGlobalCodeScope();
 172 
 173     next();
 174 }
 175 
<span class="line-modified"> 176 class Scope::MaybeParseAsGeneratorForScope : public SetForScope&lt;bool&gt; {</span>
 177 public:
 178     MaybeParseAsGeneratorForScope(ScopeRef&amp; scope, bool shouldParseAsGenerator)
<span class="line-modified"> 179         : SetForScope&lt;bool&gt;(scope-&gt;m_isGenerator, shouldParseAsGenerator) { }</span>













 180 };
 181 
 182 struct DepthManager : private SetForScope&lt;int&gt; {
 183 public:
 184     DepthManager(int* depth)
 185         : SetForScope&lt;int&gt;(*depth, *depth)
 186     {
 187     }
 188 };
 189 
 190 template &lt;typename LexerType&gt;
 191 Parser&lt;LexerType&gt;::~Parser()
 192 {
 193 }
 194 
 195 template &lt;typename LexerType&gt;
 196 String Parser&lt;LexerType&gt;::parseInner(const Identifier&amp; calleeName, SourceParseMode parseMode, ParsingContext parsingContext, Optional&lt;int&gt; functionConstructorParametersEndPosition)
 197 {
 198     String parseError = String();
 199 
<span class="line-modified"> 200     ASTBuilder context(const_cast&lt;VM*&gt;(m_vm), m_parserArena, const_cast&lt;SourceCode*&gt;(m_source));</span>
 201     ScopeRef scope = currentScope();
 202     scope-&gt;setIsLexicalScope();
 203     SetForScope&lt;FunctionParsePhase&gt; functionParsePhasePoisoner(m_parserState.functionParsePhase, FunctionParsePhase::Body);
 204 
 205     bool isArrowFunctionBodyExpression = parseMode == SourceParseMode::AsyncArrowFunctionBodyMode &amp;&amp; !match(OPENBRACE);
 206     if (m_lexer-&gt;isReparsingFunction()) {
 207         ParserFunctionInfo&lt;ASTBuilder&gt; functionInfo;
 208         if (isGeneratorOrAsyncFunctionBodyParseMode(parseMode))
 209             m_parameters = createGeneratorParameters(context, functionInfo.parameterCount);
 210         else
 211             m_parameters = parseFunctionParameters(context, parseMode, functionInfo);
 212 
 213         if (SourceParseModeSet(SourceParseMode::ArrowFunctionMode, SourceParseMode::AsyncArrowFunctionMode).contains(parseMode) &amp;&amp; !hasError()) {
 214             // The only way we could have an error wile reparsing is if we run out of stack space.
 215             RELEASE_ASSERT(match(ARROWFUNCTION));
 216             next();
 217             isArrowFunctionBodyExpression = !match(OPENBRACE);
 218         }
 219     }
 220 
</pre>
<hr />
<pre>
 244     }
 245 
 246     bool validEnding = consume(EOFTOK);
 247     if (!sourceElements || !validEnding) {
 248         if (hasError())
 249             parseError = m_errorMessage;
 250         else
 251             parseError = &quot;Parser error&quot;_s;
 252     }
 253 
 254     IdentifierSet capturedVariables;
 255     UniquedStringImplPtrSet sloppyModeHoistedFunctions;
 256     scope-&gt;getSloppyModeHoistedFunctions(sloppyModeHoistedFunctions);
 257     scope-&gt;getCapturedVars(capturedVariables);
 258 
 259     VariableEnvironment&amp; varDeclarations = scope-&gt;declaredVariables();
 260     for (auto&amp; entry : capturedVariables)
 261         varDeclarations.markVariableAsCaptured(entry);
 262 
 263     if (isGeneratorWrapperParseMode(parseMode) || isAsyncFunctionOrAsyncGeneratorWrapperParseMode(parseMode)) {
<span class="line-modified"> 264         if (scope-&gt;usedVariablesContains(m_vm-&gt;propertyNames-&gt;arguments.impl()))</span>
 265             context.propagateArgumentsUse();
 266     }
 267 
 268     CodeFeatures features = context.features();
 269     if (scope-&gt;strictMode())
 270         features |= StrictModeFeature;
 271     if (scope-&gt;shadowsArguments())
 272         features |= ShadowsArgumentsFeature;
 273     if (m_seenTaggedTemplate)
 274         features |= NoEvalCacheFeature;
 275 
 276 #ifndef NDEBUG
 277     if (m_parsingBuiltin &amp;&amp; isProgramParseMode(parseMode)) {
 278         VariableEnvironment&amp; lexicalVariables = scope-&gt;lexicalVariables();
 279         const HashSet&lt;UniquedStringImpl*&gt;&amp; closedVariableCandidates = scope-&gt;closedVariableCandidates();
 280         for (UniquedStringImpl* candidate : closedVariableCandidates) {
 281             // FIXME: We allow async to leak because it appearing as a closed variable is a side effect of trying to parse async arrow functions.
<span class="line-modified"> 282             if (!lexicalVariables.contains(candidate) &amp;&amp; !varDeclarations.contains(candidate) &amp;&amp; !candidate-&gt;isSymbol() &amp;&amp; candidate != m_vm-&gt;propertyNames-&gt;async.impl()) {</span>
 283                 dataLog(&quot;Bad global capture in builtin: &#39;&quot;, candidate, &quot;&#39;\n&quot;);
 284                 dataLog(m_source-&gt;view());
 285                 CRASH();
 286             }
 287         }
 288     }
 289 #endif // NDEBUG
 290     didFinishParsing(sourceElements, scope-&gt;takeFunctionDeclarations(), varDeclarations, WTFMove(sloppyModeHoistedFunctions), features, context.numConstants());
 291 
 292     return parseError;
 293 }
 294 
 295 template &lt;typename LexerType&gt;
 296 void Parser&lt;LexerType&gt;::didFinishParsing(SourceElements* sourceElements, DeclarationStacks::FunctionStack&amp;&amp; funcStack,
 297     VariableEnvironment&amp; varDeclarations, UniquedStringImplPtrSet&amp;&amp; sloppyModeHoistedFunctions, CodeFeatures features, int numConstants)
 298 {
 299     m_sourceElements = sourceElements;
 300     m_funcDeclarations = WTFMove(funcStack);
 301     m_varDeclarations.swap(varDeclarations);
 302     m_features = features;
 303     m_sloppyModeHoistedFunctions = WTFMove(sloppyModeHoistedFunctions);
 304     m_numConstants = numConstants;
 305 }
 306 
 307 template &lt;typename LexerType&gt;
 308 bool Parser&lt;LexerType&gt;::isArrowFunctionParameters()
 309 {
 310     if (match(OPENPAREN)) {
 311         SavePoint saveArrowFunctionPoint = createSavePoint();
 312         next();
 313         bool isArrowFunction = false;
 314         if (match(CLOSEPAREN)) {
 315             next();
 316             isArrowFunction = match(ARROWFUNCTION);
 317         } else {
<span class="line-modified"> 318             SyntaxChecker syntaxChecker(const_cast&lt;VM*&gt;(m_vm), m_lexer.get());</span>
 319             // We make fake scope, otherwise parseFormalParameters will add variable to current scope that lead to errors
 320             AutoPopScopeRef fakeScope(this, pushScope());
 321             fakeScope-&gt;setSourceParseMode(SourceParseMode::ArrowFunctionMode);
 322 
 323             unsigned parametersCount = 0;
 324             bool isArrowFunctionParameterList = true;
 325             bool isMethod = false;
 326             isArrowFunction = parseFormalParameters(syntaxChecker, syntaxChecker.createFormalParameterList(), isArrowFunctionParameterList, isMethod, parametersCount) &amp;&amp; consume(CLOSEPAREN) &amp;&amp; match(ARROWFUNCTION);
 327             propagateError();
 328             popScope(fakeScope, syntaxChecker.NeedsFreeVariableInfo);
 329         }
 330         restoreSavePoint(saveArrowFunctionPoint);
 331         return isArrowFunction;
 332     }
 333 
 334     if (matchSpecIdentifier()) {
 335         SavePoint saveArrowFunctionPoint = createSavePoint();
 336         next();
 337         bool isArrowFunction = match(ARROWFUNCTION);
 338         restoreSavePoint(saveArrowFunctionPoint);
</pre>
<hr />
<pre>
 345 template &lt;typename LexerType&gt;
 346 bool Parser&lt;LexerType&gt;::allowAutomaticSemicolon()
 347 {
 348     return match(CLOSEBRACE) || match(EOFTOK) || m_lexer-&gt;hasLineTerminatorBeforeToken();
 349 }
 350 
 351 template &lt;typename LexerType&gt;
 352 template &lt;class TreeBuilder&gt; TreeSourceElements Parser&lt;LexerType&gt;::parseSourceElements(TreeBuilder&amp; context, SourceElementsMode mode)
 353 {
 354     const unsigned lengthOfUseStrictLiteral = 12; // &quot;use strict&quot;.length
 355     TreeSourceElements sourceElements = context.createSourceElements();
 356     const Identifier* directive = 0;
 357     unsigned directiveLiteralLength = 0;
 358     auto savePoint = createSavePoint();
 359     bool shouldCheckForUseStrict = mode == CheckForStrictMode;
 360 
 361     while (TreeStatement statement = parseStatementListItem(context, directive, &amp;directiveLiteralLength)) {
 362         if (shouldCheckForUseStrict) {
 363             if (directive) {
 364                 // &quot;use strict&quot; must be the exact literal without escape sequences or line continuation.
<span class="line-modified"> 365                 if (directiveLiteralLength == lengthOfUseStrictLiteral &amp;&amp; m_vm-&gt;propertyNames-&gt;useStrictIdentifier == *directive) {</span>
 366                     setStrictMode();
 367                     shouldCheckForUseStrict = false; // We saw &quot;use strict&quot;, there is no need to keep checking for it.
 368                     if (!isValidStrictMode()) {
 369                         if (m_parserState.lastFunctionName) {
<span class="line-modified"> 370                             if (m_vm-&gt;propertyNames-&gt;arguments == *m_parserState.lastFunctionName)</span>
 371                                 semanticFail(&quot;Cannot name a function &#39;arguments&#39; in strict mode&quot;);
<span class="line-modified"> 372                             if (m_vm-&gt;propertyNames-&gt;eval == *m_parserState.lastFunctionName)</span>
 373                                 semanticFail(&quot;Cannot name a function &#39;eval&#39; in strict mode&quot;);
 374                         }
<span class="line-modified"> 375                         if (hasDeclaredVariable(m_vm-&gt;propertyNames-&gt;arguments))</span>
 376                             semanticFail(&quot;Cannot declare a variable named &#39;arguments&#39; in strict mode&quot;);
<span class="line-modified"> 377                         if (hasDeclaredVariable(m_vm-&gt;propertyNames-&gt;eval))</span>
 378                             semanticFail(&quot;Cannot declare a variable named &#39;eval&#39; in strict mode&quot;);
 379                         semanticFailIfTrue(currentScope()-&gt;hasNonSimpleParameterList(), &quot;&#39;use strict&#39; directive not allowed inside a function with a non-simple parameter list&quot;);
 380                         semanticFailIfFalse(isValidStrictMode(), &quot;Invalid parameters or function name in strict mode&quot;);
 381                     }
 382                     // Since strict mode is changed, restoring lexer state by calling next() may cause errors.
 383                     restoreSavePoint(savePoint);
 384                     propagateError();
 385                     continue;
 386                 }
 387 
 388                 // We saw a directive, but it wasn&#39;t &quot;use strict&quot;. We reset our state to
 389                 // see if the next statement we parse is also a directive.
 390                 directive = nullptr;
 391             } else {
 392                 // We saw a statement that wasn&#39;t in the form of a directive. The spec says that &quot;use strict&quot;
 393                 // is only allowed as the first statement, or after a sequence of directives before it, but
 394                 // not after non-directive statements.
 395                 shouldCheckForUseStrict = false;
 396             }
 397         }
 398         context.appendStatement(sourceElements, statement);
 399     }
 400 
 401     propagateError();
 402     return sourceElements;
 403 }
 404 
 405 template &lt;typename LexerType&gt;
 406 template &lt;class TreeBuilder&gt; TreeSourceElements Parser&lt;LexerType&gt;::parseModuleSourceElements(TreeBuilder&amp; context, SourceParseMode parseMode)
 407 {
 408     TreeSourceElements sourceElements = context.createSourceElements();
<span class="line-modified"> 409     SyntaxChecker syntaxChecker(const_cast&lt;VM*&gt;(m_vm), m_lexer.get());</span>
 410 
 411     while (true) {
 412         TreeStatement statement = 0;
 413         switch (m_token.m_type) {
 414         case EXPORT:
 415             statement = parseExportDeclaration(context);
 416             if (statement)
 417                 recordPauseLocation(context.breakpointLocation(statement));
 418             break;
 419 
 420         case IMPORT: {
 421             SavePoint savePoint = createSavePoint();
 422             next();
 423             bool isImportDeclaration = !match(OPENPAREN) &amp;&amp; !match(DOT);
 424             restoreSavePoint(savePoint);
 425             if (isImportDeclaration) {
 426                 statement = parseImportDeclaration(context);
 427                 if (statement)
 428                     recordPauseLocation(context.breakpointLocation(statement));
 429                 break;
</pre>
<hr />
<pre>
 468 
 469         semanticFail(&quot;Exported binding &#39;&quot;, uid.get(), &quot;&#39; needs to refer to a top-level declared variable&quot;);
 470     }
 471 
 472     return sourceElements;
 473 }
 474 
 475 template &lt;typename LexerType&gt;
 476 template &lt;class TreeBuilder&gt; TreeSourceElements Parser&lt;LexerType&gt;::parseGeneratorFunctionSourceElements(TreeBuilder&amp; context, const Identifier&amp; name, SourceElementsMode mode)
 477 {
 478     auto sourceElements = context.createSourceElements();
 479 
 480     unsigned functionKeywordStart = tokenStart();
 481     JSTokenLocation startLocation(tokenLocation());
 482     JSTextPosition start = tokenStartPosition();
 483     unsigned startColumn = tokenColumn();
 484     int functionNameStart = m_token.m_location.startOffset;
 485     int parametersStart = m_token.m_location.startOffset;
 486 
 487     ParserFunctionInfo&lt;TreeBuilder&gt; info;
<span class="line-modified"> 488     info.name = &amp;m_vm-&gt;propertyNames-&gt;nullIdentifier;</span>
 489     createGeneratorParameters(context, info.parameterCount);
 490     info.startOffset = parametersStart;
 491     info.startLine = tokenLine();
 492 
 493     {
 494         AutoPopScopeRef generatorBodyScope(this, pushScope());
 495         generatorBodyScope-&gt;setSourceParseMode(SourceParseMode::GeneratorBodyMode);
 496         generatorBodyScope-&gt;setConstructorKind(ConstructorKind::None);
 497         generatorBodyScope-&gt;setExpectedSuperBinding(m_superBinding);
 498 
<span class="line-modified"> 499         SyntaxChecker generatorFunctionContext(const_cast&lt;VM*&gt;(m_vm), m_lexer.get());</span>
 500         failIfFalse(parseSourceElements(generatorFunctionContext, mode), &quot;Cannot parse the body of a generator&quot;);
 501         popScope(generatorBodyScope, TreeBuilder::NeedsFreeVariableInfo);
 502     }
 503     info.body = context.createFunctionMetadata(startLocation, tokenLocation(), startColumn, tokenColumn(), functionKeywordStart, functionNameStart, parametersStart, strictMode(), ConstructorKind::None, m_superBinding, info.parameterCount, SourceParseMode::GeneratorBodyMode, false);
 504 
 505     info.endLine = tokenLine();
 506     info.endOffset = m_token.m_data.offset;
 507     info.parametersStartColumn = startColumn;
 508 
 509     auto functionExpr = context.createGeneratorFunctionBody(startLocation, info, name);
 510     auto statement = context.createExprStatement(startLocation, functionExpr, start, m_lastTokenEndPosition.line);
 511     context.appendStatement(sourceElements, statement);
 512 
 513     return sourceElements;
 514 }
 515 
 516 template &lt;typename LexerType&gt;
 517 template &lt;class TreeBuilder&gt; TreeSourceElements Parser&lt;LexerType&gt;::parseAsyncFunctionSourceElements(TreeBuilder&amp; context, SourceParseMode parseMode, bool isArrowFunctionBodyExpression, SourceElementsMode mode)
 518 {
 519     ASSERT(isAsyncFunctionOrAsyncGeneratorWrapperParseMode(parseMode));
 520     auto sourceElements = context.createSourceElements();
 521 
 522     unsigned functionKeywordStart = tokenStart();
 523     JSTokenLocation startLocation(tokenLocation());
 524     JSTextPosition start = tokenStartPosition();
 525     unsigned startColumn = tokenColumn();
 526     int functionNameStart = m_token.m_location.startOffset;
 527     int parametersStart = m_token.m_location.startOffset;
 528 
 529     ParserFunctionInfo&lt;TreeBuilder&gt; info;
<span class="line-modified"> 530     info.name = &amp;m_vm-&gt;propertyNames-&gt;nullIdentifier;</span>
 531     createGeneratorParameters(context, info.parameterCount);
 532     info.startOffset = parametersStart;
 533     info.startLine = tokenLine();
 534 
 535     SourceParseMode innerParseMode = getAsynFunctionBodyParseMode(parseMode);
 536 
 537     {
 538         AutoPopScopeRef asyncFunctionBodyScope(this, pushScope());
 539         asyncFunctionBodyScope-&gt;setSourceParseMode(innerParseMode);
<span class="line-modified"> 540         SyntaxChecker syntaxChecker(const_cast&lt;VM*&gt;(m_vm), m_lexer.get());</span>
 541         if (isArrowFunctionBodyExpression) {
 542             if (m_debuggerParseData)
 543                 failIfFalse(parseArrowFunctionSingleExpressionBodySourceElements(context), &quot;Cannot parse the body of async arrow function&quot;);
 544             else
 545                 failIfFalse(parseArrowFunctionSingleExpressionBodySourceElements(syntaxChecker), &quot;Cannot parse the body of async arrow function&quot;);
 546         } else {
 547             if (m_debuggerParseData)
 548                 failIfFalse(parseSourceElements(context, mode), &quot;Cannot parse the body of async function&quot;);
 549             else
 550                 failIfFalse(parseSourceElements(syntaxChecker, mode), &quot;Cannot parse the body of async function&quot;);
 551         }
 552         popScope(asyncFunctionBodyScope, TreeBuilder::NeedsFreeVariableInfo);
 553     }
 554     info.body = context.createFunctionMetadata(startLocation, tokenLocation(), startColumn, tokenColumn(), functionKeywordStart, functionNameStart, parametersStart, strictMode(), ConstructorKind::None, m_superBinding, info.parameterCount, innerParseMode, isArrowFunctionBodyExpression);
 555 
 556     info.endLine = tokenLine();
 557     info.endOffset = isArrowFunctionBodyExpression ? tokenLocation().endOffset : m_token.m_data.offset;
 558     info.parametersStartColumn = startColumn;
 559 
 560     auto functionExpr = context.createAsyncFunctionBody(startLocation, info, innerParseMode);
 561     auto statement = context.createExprStatement(startLocation, functionExpr, start, m_lastTokenEndPosition.line);
 562     context.appendStatement(sourceElements, statement);
 563 
 564     return sourceElements;
 565 }
 566 
 567 template &lt;typename LexerType&gt;
 568 template &lt;class TreeBuilder&gt; TreeSourceElements Parser&lt;LexerType&gt;::parseAsyncGeneratorFunctionSourceElements(TreeBuilder&amp; context, SourceParseMode parseMode, bool isArrowFunctionBodyExpression, SourceElementsMode mode)
 569 {
 570     ASSERT_UNUSED(parseMode, isAsyncGeneratorWrapperParseMode(parseMode));
 571     auto sourceElements = context.createSourceElements();
 572 
 573     unsigned functionKeywordStart = tokenStart();
 574     JSTokenLocation startLocation(tokenLocation());
 575     JSTextPosition start = tokenStartPosition();
 576     unsigned startColumn = tokenColumn();
 577     int functionNameStart = m_token.m_location.startOffset;
 578     int parametersStart = m_token.m_location.startOffset;
 579 
 580     ParserFunctionInfo&lt;TreeBuilder&gt; info;
<span class="line-modified"> 581     info.name = &amp;m_vm-&gt;propertyNames-&gt;nullIdentifier;</span>
 582     createGeneratorParameters(context, info.parameterCount);
 583     info.startOffset = parametersStart;
 584     info.startLine = tokenLine();
 585     SourceParseMode innerParseMode = SourceParseMode::AsyncGeneratorBodyMode;
 586     {
 587         AutoPopScopeRef asyncFunctionBodyScope(this, pushScope());
 588         asyncFunctionBodyScope-&gt;setSourceParseMode(innerParseMode);
<span class="line-modified"> 589         SyntaxChecker syntaxChecker(const_cast&lt;VM*&gt;(m_vm), m_lexer.get());</span>
 590         if (isArrowFunctionBodyExpression) {
 591             if (m_debuggerParseData)
 592                 failIfFalse(parseArrowFunctionSingleExpressionBodySourceElements(context), &quot;Cannot parse the body of async arrow function&quot;);
 593             else
 594                 failIfFalse(parseArrowFunctionSingleExpressionBodySourceElements(syntaxChecker), &quot;Cannot parse the body of async arrow function&quot;);
 595         } else {
 596             if (m_debuggerParseData)
 597                 failIfFalse(parseSourceElements(context, mode), &quot;Cannot parse the body of async function&quot;);
 598             else
 599                 failIfFalse(parseSourceElements(syntaxChecker, mode), &quot;Cannot parse the body of async function&quot;);
 600         }
 601         popScope(asyncFunctionBodyScope, TreeBuilder::NeedsFreeVariableInfo);
 602     }
 603     info.body = context.createFunctionMetadata(startLocation, tokenLocation(), startColumn, tokenColumn(), functionKeywordStart, functionNameStart, parametersStart, strictMode(), ConstructorKind::None, m_superBinding, info.parameterCount, innerParseMode, isArrowFunctionBodyExpression);
 604 
 605     info.endLine = tokenLine();
 606     info.endOffset = isArrowFunctionBodyExpression ? tokenLocation().endOffset : m_token.m_data.offset;
 607     info.parametersStartColumn = startColumn;
 608 
 609     auto functionExpr = context.createAsyncFunctionBody(startLocation, info, innerParseMode);
 610     auto statement = context.createExprStatement(startLocation, functionExpr, start, m_lastTokenEndPosition.line);
 611     context.appendStatement(sourceElements, statement);
 612 
 613     return sourceElements;
 614 }
 615 
 616 template &lt;typename LexerType&gt;
 617 template &lt;class TreeBuilder&gt; TreeSourceElements Parser&lt;LexerType&gt;::parseSingleFunction(TreeBuilder&amp; context, Optional&lt;int&gt; functionConstructorParametersEndPosition)
 618 {
 619     TreeSourceElements sourceElements = context.createSourceElements();
 620     TreeStatement statement = 0;
 621     switch (m_token.m_type) {
 622     case FUNCTION:
 623         statement = parseFunctionDeclaration(context, ExportType::NotExported, DeclarationDefaultContext::Standard, functionConstructorParametersEndPosition);
 624         break;
 625     case IDENT:
<span class="line-modified"> 626         if (*m_token.m_data.ident == m_vm-&gt;propertyNames-&gt;async &amp;&amp; !m_token.m_data.escaped) {</span>
 627             next();
 628             failIfFalse(match(FUNCTION) &amp;&amp; !m_lexer-&gt;hasLineTerminatorBeforeToken(), &quot;Cannot parse the async function&quot;);
 629             statement = parseAsyncFunctionDeclaration(context, ExportType::NotExported, DeclarationDefaultContext::Standard, functionConstructorParametersEndPosition);
 630             break;
 631         }
 632         FALLTHROUGH;
 633     default:
 634         failDueToUnexpectedToken();
 635         break;
 636     }
 637 
 638     if (statement) {
 639         context.setEndOffset(statement, m_lastTokenEndPosition.offset);
 640         context.appendStatement(sourceElements, statement);
 641     }
 642 
 643     propagateError();
 644     return sourceElements;
 645 }
 646 
 647 
 648 template &lt;typename LexerType&gt;
 649 template &lt;class TreeBuilder&gt; TreeStatement Parser&lt;LexerType&gt;::parseStatementListItem(TreeBuilder&amp; context, const Identifier*&amp; directive, unsigned* directiveLiteralLength)
 650 {
 651     // The grammar is documented here:
 652     // http://www.ecma-international.org/ecma-262/6.0/index.html#sec-statements
 653     DepthManager statementDepth(&amp;m_statementDepth);
 654     m_statementDepth++;

 655     TreeStatement result = 0;
 656     bool shouldSetEndOffset = true;
 657     bool shouldSetPauseLocation = false;
 658 
 659     switch (m_token.m_type) {
 660     case CONSTTOKEN:
 661         result = parseVariableDeclaration(context, DeclarationType::ConstDeclaration);
 662         shouldSetPauseLocation = true;
 663         break;
 664     case LET: {
 665         bool shouldParseVariableDeclaration = true;
 666         if (!strictMode()) {
 667             SavePoint savePoint = createSavePoint();
 668             next();
 669             // Intentionally use `isIdentifierOrAnyContextualKeyword(m_token)` and don&#39;t use `matchSpecIdentifier()`.
 670             // We would like to fall into parseVariableDeclaration path even if &quot;yield&quot; is not treated as an Identifier.
 671             // For example, under a generator context, matchSpecIdentifier() for &quot;yield&quot; returns `false`.
 672             // But we would like to enter parseVariableDeclaration and raise an error under the context of parseVariableDeclaration
 673             // to raise consistent errors between &quot;var&quot;, &quot;const&quot; and &quot;let&quot;.
 674             if (!isIdentifierOrAnyContextualKeyword(m_token) &amp;&amp; !match(OPENBRACE) &amp;&amp; !match(OPENBRACKET))
 675                 shouldParseVariableDeclaration = false;
 676             restoreSavePoint(savePoint);
 677         }
 678         if (shouldParseVariableDeclaration)
 679             result = parseVariableDeclaration(context, DeclarationType::LetDeclaration);
 680         else {
 681             bool allowFunctionDeclarationAsStatement = true;
 682             result = parseExpressionOrLabelStatement(context, allowFunctionDeclarationAsStatement);
 683         }
 684         shouldSetPauseLocation = !context.shouldSkipPauseLocation(result);
 685         break;
 686     }
 687     case CLASSTOKEN:
 688         result = parseClassDeclaration(context);
 689         break;
 690     case FUNCTION:
 691         result = parseFunctionDeclaration(context);
 692         break;
 693     case IDENT:
<span class="line-modified"> 694         if (UNLIKELY(*m_token.m_data.ident == m_vm-&gt;propertyNames-&gt;async &amp;&amp; !m_token.m_data.escaped)) {</span>
 695             // Eagerly parse as AsyncFunctionDeclaration. This is the uncommon case,
 696             // but could be mistakenly parsed as an AsyncFunctionExpression.
 697             SavePoint savePoint = createSavePoint();
 698             next();
 699             if (UNLIKELY(match(FUNCTION) &amp;&amp; !m_lexer-&gt;hasLineTerminatorBeforeToken())) {
 700                 result = parseAsyncFunctionDeclaration(context);
 701                 break;
 702             }
 703             restoreSavePoint(savePoint);
 704         }
 705         FALLTHROUGH;
 706     case AWAIT:
 707     case YIELD: {
 708         // This is a convenient place to notice labeled statements
 709         // (even though we also parse them as normal statements)
 710         // because we allow the following type of code in sloppy mode:
 711         // ``` function foo() { label: function bar() { } } ```
 712         bool allowFunctionDeclarationAsStatement = true;
 713         result = parseExpressionOrLabelStatement(context, allowFunctionDeclarationAsStatement);
 714         shouldSetPauseLocation = !context.shouldSkipPauseLocation(result);
</pre>
<hr />
<pre>
 910         if (!m_lexer-&gt;isReparsingFunction() &amp;&amp; hasDeclaredParameter(name))
 911             semanticFail(&quot;Cannot declare a parameter named &#39;&quot;, name.impl(), &quot;&#39; in strict mode as it has already been declared&quot;);
 912         semanticFail(&quot;Cannot declare a parameter named &#39;&quot;, name.impl(), &quot;&#39; in strict mode&quot;);
 913     }
 914     if (declarationResult &amp; DeclarationResult::InvalidDuplicateDeclaration) {
 915         // It&#39;s not always an error to define a duplicate parameter.
 916         // It&#39;s only an error when there are default parameter values or destructuring parameters.
 917         // We note this value now so we can check it later.
 918         if (duplicateIdentifier)
 919             *duplicateIdentifier = &amp;name;
 920     }
 921 
 922     return true;
 923 }
 924 
 925 template &lt;typename LexerType&gt;
 926 template &lt;class TreeBuilder&gt; TreeDestructuringPattern Parser&lt;LexerType&gt;::createBindingPattern(TreeBuilder&amp; context, DestructuringKind kind, ExportType exportType, const Identifier&amp; name, JSToken token, AssignmentContext bindingContext, const Identifier** duplicateIdentifier)
 927 {
 928     ASSERT(!name.isNull());
 929 
<span class="line-modified"> 930     ASSERT(name.impl()-&gt;isAtomic() || name.impl()-&gt;isSymbol());</span>
 931 
 932     switch (kind) {
 933     case DestructuringKind::DestructureToVariables: {
 934         DeclarationResultMask declarationResult = declareVariable(&amp;name);
 935         failIfTrueIfStrict(declarationResult &amp; DeclarationResult::InvalidStrictMode, &quot;Cannot declare a variable named &#39;&quot;, name.impl(), &quot;&#39; in strict mode&quot;);
 936         if (declarationResult &amp; DeclarationResult::InvalidDuplicateDeclaration)
 937             internalFailWithMessage(false, &quot;Cannot declare a var variable that shadows a let/const/class variable: &#39;&quot;, name.impl(), &quot;&#39;&quot;);
 938         break;
 939     }
 940 
 941     case DestructuringKind::DestructureToLet:
 942     case DestructuringKind::DestructureToConst:
 943     case DestructuringKind::DestructureToCatchParameters: {
 944         DeclarationResultMask declarationResult = declareVariable(&amp;name, kind == DestructuringKind::DestructureToConst ? DeclarationType::ConstDeclaration : DeclarationType::LetDeclaration);
 945         if (declarationResult != DeclarationResult::Valid) {
 946             failIfTrueIfStrict(declarationResult &amp; DeclarationResult::InvalidStrictMode, &quot;Cannot destructure to a variable named &#39;&quot;, name.impl(), &quot;&#39; in strict mode&quot;);
 947             failIfTrue(declarationResult &amp; DeclarationResult::InvalidDuplicateDeclaration, &quot;Cannot declare a lexical variable twice: &#39;&quot;, name.impl(), &quot;&#39;&quot;);
 948         }
 949         break;
 950     }
</pre>
<hr />
<pre>
1007 template &lt;typename LexerType&gt;
1008 template &lt;class TreeBuilder&gt; TreeDestructuringPattern Parser&lt;LexerType&gt;::parseBindingOrAssignmentElement(TreeBuilder&amp; context, DestructuringKind kind, ExportType exportType, const Identifier** duplicateIdentifier, bool* hasDestructuringPattern, AssignmentContext bindingContext, int depth)
1009 {
1010     if (kind == DestructuringKind::DestructureToExpressions)
1011         return parseAssignmentElement(context, kind, exportType, duplicateIdentifier, hasDestructuringPattern, bindingContext, depth);
1012     return parseDestructuringPattern(context, kind, exportType, duplicateIdentifier, hasDestructuringPattern, bindingContext, depth);
1013 }
1014 
1015 template &lt;typename LexerType&gt;
1016 template &lt;class TreeBuilder&gt; TreeDestructuringPattern Parser&lt;LexerType&gt;::parseObjectRestAssignmentElement(TreeBuilder&amp; context)
1017 {
1018     JSTextPosition startPosition = tokenStartPosition();
1019     auto element = parseMemberExpression(context);
1020 
1021     if (!element || !context.isAssignmentLocation(element)) {
1022         reclassifyExpressionError(ErrorIndicatesPattern, ErrorIndicatesNothing);
1023         semanticFail(&quot;Invalid destructuring assignment target&quot;);
1024     }
1025 
1026     if (strictMode() &amp;&amp; m_parserState.lastIdentifier &amp;&amp; context.isResolve(element)) {
<span class="line-modified">1027         bool isEvalOrArguments = m_vm-&gt;propertyNames-&gt;eval == *m_parserState.lastIdentifier || m_vm-&gt;propertyNames-&gt;arguments == *m_parserState.lastIdentifier;</span>
1028         if (isEvalOrArguments &amp;&amp; strictMode())
1029             reclassifyExpressionError(ErrorIndicatesPattern, ErrorIndicatesNothing);
1030         failIfTrueIfStrict(isEvalOrArguments, &quot;Cannot modify &#39;&quot;, m_parserState.lastIdentifier-&gt;impl(), &quot;&#39; in strict mode&quot;);
1031     }
1032 
1033     return createAssignmentElement(context, element, startPosition, lastTokenEndPosition());
1034 }
1035 
1036 template &lt;typename LexerType&gt;
1037 template &lt;class TreeBuilder&gt; TreeDestructuringPattern Parser&lt;LexerType&gt;::parseAssignmentElement(TreeBuilder&amp; context, DestructuringKind kind, ExportType exportType, const Identifier** duplicateIdentifier, bool* hasDestructuringPattern, AssignmentContext bindingContext, int depth)
1038 {
1039     TreeDestructuringPattern assignmentTarget = 0;
1040 
1041     if (match(OPENBRACE) || match(OPENBRACKET)) {
1042         SavePoint savePoint = createSavePoint();
1043         assignmentTarget = parseDestructuringPattern(context, kind, exportType, duplicateIdentifier, hasDestructuringPattern, bindingContext, depth);
1044         if (assignmentTarget &amp;&amp; !match(DOT) &amp;&amp; !match(OPENBRACKET) &amp;&amp; !match(OPENPAREN) &amp;&amp; !match(BACKQUOTE))
1045             return assignmentTarget;
1046         restoreSavePoint(savePoint);
1047     }
1048 
1049     JSTextPosition startPosition = tokenStartPosition();
1050     auto element = parseMemberExpression(context);
1051 
1052     semanticFailIfFalse(element &amp;&amp; context.isAssignmentLocation(element), &quot;Invalid destructuring assignment target&quot;);
1053 
1054     if (strictMode() &amp;&amp; m_parserState.lastIdentifier &amp;&amp; context.isResolve(element)) {
<span class="line-modified">1055         bool isEvalOrArguments = m_vm-&gt;propertyNames-&gt;eval == *m_parserState.lastIdentifier || m_vm-&gt;propertyNames-&gt;arguments == *m_parserState.lastIdentifier;</span>
1056         failIfTrueIfStrict(isEvalOrArguments, &quot;Cannot modify &#39;&quot;, m_parserState.lastIdentifier-&gt;impl(), &quot;&#39; in strict mode&quot;);
1057     }
1058 
1059     return createAssignmentElement(context, element, startPosition, lastTokenEndPosition());
1060 }
1061 
1062 static const char* destructuringKindToVariableKindName(DestructuringKind kind)
1063 {
1064     switch (kind) {
1065     case DestructuringKind::DestructureToLet:
1066     case DestructuringKind::DestructureToConst:
1067         return &quot;lexical variable name&quot;;
1068     case DestructuringKind::DestructureToVariables:
1069         return &quot;variable name&quot;;
1070     case DestructuringKind::DestructureToParameters:
1071         return &quot;parameter name&quot;;
1072     case DestructuringKind::DestructureToCatchParameters:
1073         return &quot;catch parameter name&quot;;
1074     case DestructuringKind::DestructureToExpressions:
1075         return &quot;expression name&quot;;
</pre>
<hr />
<pre>
1163         next();
1164 
1165         if (hasDestructuringPattern)
1166             *hasDestructuringPattern = true;
1167 
1168         bool restElementWasFound = false;
1169 
1170         do {
1171             bool wasString = false;
1172 
1173             if (match(CLOSEBRACE))
1174                 break;
1175 
1176             if (match(DOTDOTDOT)) {
1177                 JSTokenLocation location = m_token.m_location;
1178                 next();
1179                 auto innerPattern = parseObjectRestBindingOrAssignmentElement(context, kind, exportType, duplicateIdentifier, bindingContext);
1180                 propagateError();
1181                 if (!innerPattern)
1182                     return 0;
<span class="line-modified">1183                 context.appendObjectPatternRestEntry(*m_vm, objectPattern, location, innerPattern);</span>
1184                 restElementWasFound = true;
1185                 context.setContainsObjectRestElement(objectPattern, restElementWasFound);
1186                 break;
1187             }
1188 
1189             const Identifier* propertyName = nullptr;
1190             TreeExpression propertyExpression = 0;
1191             TreeDestructuringPattern innerPattern = 0;
1192             JSTokenLocation location = m_token.m_location;
1193             if (matchSpecIdentifier()) {
1194                 failIfTrue(match(LET) &amp;&amp; (kind == DestructuringKind::DestructureToLet || kind == DestructuringKind::DestructureToConst), &quot;Cannot use &#39;let&#39; as an identifier name for a LexicalDeclaration&quot;);
1195                 propertyName = m_token.m_data.ident;
1196                 JSToken identifierToken = m_token;
1197                 next();
1198                 if (consume(COLON))
1199                     innerPattern = parseBindingOrAssignmentElement(context, kind, exportType, duplicateIdentifier, hasDestructuringPattern, bindingContext, depth + 1);
1200                 else {
1201                     if (kind == DestructuringKind::DestructureToExpressions) {
<span class="line-modified">1202                         bool isEvalOrArguments = m_vm-&gt;propertyNames-&gt;eval == *propertyName || m_vm-&gt;propertyNames-&gt;arguments == *propertyName;</span>
1203                         if (isEvalOrArguments &amp;&amp; strictMode())
1204                             reclassifyExpressionError(ErrorIndicatesPattern, ErrorIndicatesNothing);
1205                         failIfTrueIfStrict(isEvalOrArguments, &quot;Cannot modify &#39;&quot;, propertyName-&gt;impl(), &quot;&#39; in strict mode&quot;);
1206                     }
1207                     semanticFailIfTrue(isDisallowedIdentifierAwait(identifierToken), &quot;Cannot use &#39;await&#39; as a &quot;, destructuringKindToVariableKindName(kind), &quot; &quot;, disallowedIdentifierAwaitReason());
1208                     innerPattern = createBindingPattern(context, kind, exportType, *propertyName, identifierToken, bindingContext, duplicateIdentifier);
1209                 }
1210             } else {
1211                 JSTokenType tokenType = m_token.m_type;
1212                 switch (m_token.m_type) {
1213                 case DOUBLE:
1214                 case INTEGER:
<span class="line-modified">1215                     propertyName = &amp;m_parserArena.identifierArena().makeNumericIdentifier(const_cast&lt;VM*&gt;(m_vm), m_token.m_data.doubleValue);</span>
1216                     break;
1217                 case STRING:
1218                     propertyName = m_token.m_data.ident;
1219                     wasString = true;
1220                     break;
1221                 case OPENBRACKET:
1222                     next();
1223                     propertyExpression = parseAssignmentExpression(context);
1224                     failIfFalse(propertyExpression, &quot;Cannot parse computed property name&quot;);
1225                     matchOrFail(CLOSEBRACKET, &quot;Expected &#39;]&#39; to end end a computed property name&quot;);
1226                     break;
1227                 default:
1228                     if (m_token.m_type != RESERVED &amp;&amp; m_token.m_type != RESERVED_IF_STRICT &amp;&amp; !(m_token.m_type &amp; KeywordTokenFlag)) {
1229                         if (kind == DestructuringKind::DestructureToExpressions)
1230                             return 0;
1231                         failWithMessage(&quot;Expected a property name&quot;);
1232                     }
1233                     propertyName = m_token.m_data.ident;
1234                     break;
1235                 }
1236                 next();
1237                 if (!consume(COLON)) {
1238                     if (kind == DestructuringKind::DestructureToExpressions)
1239                         return 0;
1240                     semanticFailIfTrue(tokenType == RESERVED, &quot;Cannot use abbreviated destructuring syntax for reserved name &#39;&quot;, propertyName-&gt;impl(), &quot;&#39;&quot;);
1241                     semanticFailIfTrue(tokenType == RESERVED_IF_STRICT, &quot;Cannot use abbreviated destructuring syntax for reserved name &#39;&quot;, propertyName-&gt;impl(), &quot;&#39; in strict mode&quot;);
1242                     semanticFailIfTrue(tokenType &amp; KeywordTokenFlag, &quot;Cannot use abbreviated destructuring syntax for keyword &#39;&quot;, propertyName-&gt;impl(), &quot;&#39;&quot;);
1243 
1244                     failWithMessage(&quot;Expected a &#39;:&#39; prior to a named destructuring property&quot;);
1245                 }
1246                 innerPattern = parseBindingOrAssignmentElement(context, kind, exportType, duplicateIdentifier, hasDestructuringPattern, bindingContext, depth + 1);
1247             }
1248             if (kind == DestructuringKind::DestructureToExpressions &amp;&amp; !innerPattern)
1249                 return 0;
1250             failIfFalse(innerPattern, &quot;Cannot parse this destructuring pattern&quot;);
1251             TreeExpression defaultValue = parseDefaultValueForDestructuringPattern(context);
1252             propagateError();
1253             if (propertyExpression) {
<span class="line-modified">1254                 context.appendObjectPatternEntry(*m_vm, objectPattern, location, propertyExpression, innerPattern, defaultValue);</span>
1255                 context.setContainsComputedProperty(objectPattern, true);
1256             } else {
1257                 ASSERT(propertyName);
1258                 context.appendObjectPatternEntry(objectPattern, location, wasString, *propertyName, innerPattern, defaultValue);
1259             }
1260         } while (consume(COMMA));
1261 
1262         if (kind == DestructuringKind::DestructureToExpressions &amp;&amp; !match(CLOSEBRACE))
1263             return 0;
1264         consumeOrFail(CLOSEBRACE, restElementWasFound ? &quot;Expected a closing &#39;}&#39; following a rest element destructuring pattern&quot; : &quot;Expected either a closing &#39;}&#39; or an &#39;,&#39; after a property destructuring pattern&quot;);
1265         pattern = objectPattern;
1266         break;
1267     }
1268 
1269     default: {
1270         if (!matchSpecIdentifier()) {
1271             if (kind == DestructuringKind::DestructureToExpressions)
1272                 return 0;
1273             semanticFailureDueToKeyword(destructuringKindToVariableKindName(kind));
1274             failWithMessage(&quot;Expected a parameter pattern or a &#39;)&#39; in parameter list&quot;);
</pre>
<hr />
<pre>
1290     if (!match(EQUAL))
1291         return 0;
1292 
1293     next(TreeBuilder::DontBuildStrings); // consume &#39;=&#39;
1294     return parseAssignmentExpression(context);
1295 }
1296 
1297 template &lt;typename LexerType&gt;
1298 template &lt;class TreeBuilder&gt; TreeStatement Parser&lt;LexerType&gt;::parseForStatement(TreeBuilder&amp; context)
1299 {
1300     ASSERT(match(FOR));
1301     JSTokenLocation location(tokenLocation());
1302     int startLine = tokenLine();
1303     bool isAwaitFor = false;
1304     next();
1305 
1306     DepthManager statementDepth(&amp;m_statementDepth);
1307     m_statementDepth++;
1308 
1309     if (match(AWAIT)) {
<span class="line-modified">1310         semanticFailIfFalse(currentScope()-&gt;isAsyncFunction(), &quot;for-await-of can&#39;t be used only in async function or async generator.&quot;);</span>
1311         isAwaitFor = true;
1312         next();
1313     }
1314 
1315     handleProductionOrFail(OPENPAREN, &quot;(&quot;, &quot;start&quot;, &quot;for-loop header&quot;);
1316     int nonLHSCount = m_parserState.nonLHSCount;
1317     int declarations = 0;
1318     JSTokenLocation declLocation(tokenLocation());
1319     JSTextPosition declsStart;
1320     JSTextPosition declsEnd;
1321     TreeExpression decls = 0;
1322     TreeDestructuringPattern pattern = 0;
1323     bool isVarDeclaraton = match(VAR);
1324     bool isLetDeclaration = match(LET);
1325     bool isConstDeclaration = match(CONSTTOKEN);
1326     bool forLoopConstDoesNotHaveInitializer = false;
1327 
1328     VariableEnvironment dummySet;
1329     VariableEnvironment* lexicalVariables = nullptr;
1330     AutoCleanupLexicalScope lexicalScope;
</pre>
<hr />
<pre>
1365         else if (isLetDeclaration)
1366             declarationType = DeclarationType::LetDeclaration;
1367         else if (isConstDeclaration)
1368             declarationType = DeclarationType::ConstDeclaration;
1369         else
1370             RELEASE_ASSERT_NOT_REACHED();
1371         decls = parseVariableDeclarationList(context, declarations, forInTarget, forInInitializer, declsStart, initStart, initEnd, ForLoopContext, declarationType, ExportType::NotExported, forLoopConstDoesNotHaveInitializer);
1372         m_allowsIn = true;
1373         propagateError();
1374 
1375         // Remainder of a standard for loop is handled identically
1376         if (match(SEMICOLON))
1377             goto standardForLoop;
1378 
1379         failIfFalse(declarations == 1, &quot;can only declare a single variable in an enumeration&quot;);
1380 
1381         // Handle for-in with var declaration
1382         JSTextPosition inLocation = tokenStartPosition();
1383         bool isOfEnumeration = false;
1384         if (!match(INTOKEN)) {
<span class="line-modified">1385             failIfFalse(matchContextualKeyword(m_vm-&gt;propertyNames-&gt;of), &quot;Expected either &#39;in&#39; or &#39;of&#39; in enumeration syntax&quot;);</span>
1386             isOfEnumeration = true;
1387             next();
1388         } else {
1389             failIfFalse(!isAwaitFor, &quot;Expected &#39;of&#39; in for-await syntax&quot;);
1390             next();
1391         }
1392 
1393         bool hasAnyAssignments = !!forInInitializer;
1394         if (hasAnyAssignments) {
1395             if (isOfEnumeration)
1396                 internalFailWithMessage(false, &quot;Cannot assign to the loop variable inside a for-of loop header&quot;);
1397             if (strictMode() || (isLetDeclaration || isConstDeclaration) || !context.isBindingNode(forInTarget))
1398                 internalFailWithMessage(false, &quot;Cannot assign to the loop variable inside a for-in loop header&quot;);
1399         }
1400         TreeExpression expr = parseExpression(context);
1401         failIfFalse(expr, &quot;Expected expression to enumerate&quot;);
1402         recordPauseLocation(context.breakpointLocation(expr));
1403         JSTextPosition exprEnd = lastTokenEndPosition();
1404 
1405         int endLine = tokenLine();
</pre>
<hr />
<pre>
1415         TreeStatement result;
1416         if (isOfEnumeration)
1417             result = context.createForOfLoop(isAwaitFor, location, forInTarget, expr, statement, declLocation, declsStart, inLocation, exprEnd, startLine, endLine, *lexicalVariables);
1418         else {
1419             ASSERT(!isAwaitFor);
1420             if (isVarDeclaraton &amp;&amp; forInInitializer)
1421                 result = context.createForInLoop(location, decls, expr, statement, declLocation, declsStart, inLocation, exprEnd, startLine, endLine, *lexicalVariables);
1422             else
1423                 result = context.createForInLoop(location, forInTarget, expr, statement, declLocation, declsStart, inLocation, exprEnd, startLine, endLine, *lexicalVariables);
1424         }
1425         popLexicalScopeIfNecessary();
1426         return result;
1427     }
1428 
1429     if (!match(SEMICOLON)) {
1430         if (match(OPENBRACE) || match(OPENBRACKET)) {
1431             SavePoint savePoint = createSavePoint();
1432             declsStart = tokenStartPosition();
1433             pattern = tryParseDestructuringPatternExpression(context, AssignmentContext::DeclarationStatement);
1434             declsEnd = lastTokenEndPosition();
<span class="line-modified">1435             if (pattern &amp;&amp; (match(INTOKEN) || matchContextualKeyword(m_vm-&gt;propertyNames-&gt;of)))</span>
1436                 goto enumerationLoop;
1437             pattern = TreeDestructuringPattern(0);
1438             restoreSavePoint(savePoint);
1439         }
1440         m_allowsIn = false;
1441         declsStart = tokenStartPosition();
1442         decls = parseExpression(context);
1443         declsEnd = lastTokenEndPosition();
1444         m_allowsIn = true;
1445         failIfFalse(decls, &quot;Cannot parse for loop declarations&quot;);
1446         recordPauseLocation(context.breakpointLocation(decls));
1447     }
1448 
1449     if (match(SEMICOLON)) {
1450     standardForLoop:
1451         failIfFalse(!isAwaitFor, &quot;Unexpected a &#39;;&#39; in for-await-of header&quot;);
1452         // Standard for loop
1453         if (decls)
1454             recordPauseLocation(context.breakpointLocation(decls));
1455         next();
</pre>
<hr />
<pre>
1470             recordPauseLocation(context.breakpointLocation(increment));
1471         }
1472         int endLine = tokenLine();
1473         handleProductionOrFail(CLOSEPAREN, &quot;)&quot;, &quot;end&quot;, &quot;for-loop header&quot;);
1474         const Identifier* unused = 0;
1475         startLoop();
1476         TreeStatement statement = parseStatement(context, unused);
1477         endLoop();
1478         failIfFalse(statement, &quot;Expected a statement as the body of a for loop&quot;);
1479         gatherLexicalVariablesIfNecessary();
1480         TreeStatement result = context.createForLoop(location, decls, condition, increment, statement, startLine, endLine, *lexicalVariables);
1481         popLexicalScopeIfNecessary();
1482         return result;
1483     }
1484 
1485     // For-in and For-of loop
1486 enumerationLoop:
1487     failIfFalse(nonLHSCount == m_parserState.nonLHSCount, &quot;Expected a reference on the left hand side of an enumeration statement&quot;);
1488     bool isOfEnumeration = false;
1489     if (!match(INTOKEN)) {
<span class="line-modified">1490         failIfFalse(matchContextualKeyword(m_vm-&gt;propertyNames-&gt;of), &quot;Expected either &#39;in&#39; or &#39;of&#39; in enumeration syntax&quot;);</span>
1491         isOfEnumeration = true;
1492         next();
1493     } else {
1494         failIfFalse(!isAwaitFor, &quot;Expected &#39;of&#39; in for-await syntax&quot;);
1495         next();
1496     }
1497 
1498     TreeExpression expr = parseExpression(context);
1499     failIfFalse(expr, &quot;Cannot parse subject for-&quot;, isOfEnumeration ? &quot;of&quot; : &quot;in&quot;, &quot; statement&quot;);
1500     recordPauseLocation(context.breakpointLocation(expr));
1501     JSTextPosition exprEnd = lastTokenEndPosition();
1502     int endLine = tokenLine();
1503 
1504     handleProductionOrFail(CLOSEPAREN, &quot;)&quot;, &quot;end&quot;, (isOfEnumeration ? &quot;for-of header&quot; : &quot;for-in header&quot;));
1505     const Identifier* unused = 0;
1506     startLoop();
1507     TreeStatement statement = parseStatement(context, unused);
1508     endLoop();
1509     failIfFalse(statement, &quot;Expected a statement as the body of a for-&quot;, isOfEnumeration ? &quot;of&quot; : &quot;in&quot;, &quot;loop&quot;);
1510     gatherLexicalVariablesIfNecessary();
</pre>
<hr />
<pre>
1525         result = context.createForOfLoop(isAwaitFor, location, decls, expr, statement, declLocation, declsStart, declsEnd, exprEnd, startLine, endLine, *lexicalVariables);
1526     else {
1527         ASSERT(!isAwaitFor);
1528         result = context.createForInLoop(location, decls, expr, statement, declLocation, declsStart, declsEnd, exprEnd, startLine, endLine, *lexicalVariables);
1529     }
1530     popLexicalScopeIfNecessary();
1531     return result;
1532 }
1533 
1534 template &lt;typename LexerType&gt;
1535 template &lt;class TreeBuilder&gt; TreeStatement Parser&lt;LexerType&gt;::parseBreakStatement(TreeBuilder&amp; context)
1536 {
1537     ASSERT(match(BREAK));
1538     JSTokenLocation location(tokenLocation());
1539     JSTextPosition start = tokenStartPosition();
1540     JSTextPosition end = tokenEndPosition();
1541     next();
1542 
1543     if (autoSemiColon()) {
1544         semanticFailIfFalse(breakIsValid(), &quot;&#39;break&#39; is only valid inside a switch or loop statement&quot;);
<span class="line-modified">1545         return context.createBreakStatement(location, &amp;m_vm-&gt;propertyNames-&gt;nullIdentifier, start, end);</span>
1546     }
1547     failIfFalse(matchSpecIdentifier(), &quot;Expected an identifier as the target for a break statement&quot;);
1548     const Identifier* ident = m_token.m_data.ident;
1549     semanticFailIfFalse(getLabel(ident), &quot;Cannot use the undeclared label &#39;&quot;, ident-&gt;impl(), &quot;&#39;&quot;);
1550     end = tokenEndPosition();
1551     next();
1552     failIfFalse(autoSemiColon(), &quot;Expected a &#39;;&#39; following a targeted break statement&quot;);
1553     return context.createBreakStatement(location, ident, start, end);
1554 }
1555 
1556 template &lt;typename LexerType&gt;
1557 template &lt;class TreeBuilder&gt; TreeStatement Parser&lt;LexerType&gt;::parseContinueStatement(TreeBuilder&amp; context)
1558 {
1559     ASSERT(match(CONTINUE));
1560     JSTokenLocation location(tokenLocation());
1561     JSTextPosition start = tokenStartPosition();
1562     JSTextPosition end = tokenEndPosition();
1563     next();
1564 
1565     if (autoSemiColon()) {
1566         semanticFailIfFalse(continueIsValid(), &quot;&#39;continue&#39; is only valid inside a loop statement&quot;);
<span class="line-modified">1567         return context.createContinueStatement(location, &amp;m_vm-&gt;propertyNames-&gt;nullIdentifier, start, end);</span>
1568     }
1569     failIfFalse(matchSpecIdentifier(), &quot;Expected an identifier as the target for a continue statement&quot;);
1570     const Identifier* ident = m_token.m_data.ident;
1571     ScopeLabelInfo* label = getLabel(ident);
1572     semanticFailIfFalse(label, &quot;Cannot use the undeclared label &#39;&quot;, ident-&gt;impl(), &quot;&#39;&quot;);
1573     semanticFailIfFalse(label-&gt;isLoop, &quot;Cannot continue to the label &#39;&quot;, ident-&gt;impl(), &quot;&#39; as it is not targeting a loop&quot;);
1574     end = tokenEndPosition();
1575     next();
1576     failIfFalse(autoSemiColon(), &quot;Expected a &#39;;&#39; following a targeted continue statement&quot;);
1577     return context.createContinueStatement(location, ident, start, end);
1578 }
1579 
1580 template &lt;typename LexerType&gt;
1581 template &lt;class TreeBuilder&gt; TreeStatement Parser&lt;LexerType&gt;::parseReturnStatement(TreeBuilder&amp; context)
1582 {
1583     ASSERT(match(RETURN));
1584     JSTokenLocation location(tokenLocation());
1585     semanticFailIfFalse(currentScope()-&gt;isFunction(), &quot;Return statements are only valid inside functions&quot;);
1586     JSTextPosition start = tokenStartPosition();
1587     JSTextPosition end = tokenEndPosition();
</pre>
<hr />
<pre>
1917         break;
1918     case TRY:
1919         result = parseTryStatement(context);
1920         break;
1921     case DEBUGGER:
1922         result = parseDebuggerStatement(context);
1923         shouldSetPauseLocation = true;
1924         break;
1925     case EOFTOK:
1926     case CASE:
1927     case CLOSEBRACE:
1928     case DEFAULT:
1929         // These tokens imply the end of a set of source elements
1930         return 0;
1931     case LET: {
1932         if (!strictMode())
1933             goto identcase;
1934         goto defaultCase;
1935     }
1936     case IDENT:
<span class="line-modified">1937         if (UNLIKELY(*m_token.m_data.ident == m_vm-&gt;propertyNames-&gt;async &amp;&amp; !m_token.m_data.escaped)) {</span>
1938             if (maybeParseAsyncFunctionDeclarationStatement(context, result, parentAllowsFunctionDeclarationAsStatement))
1939                 break;
1940         }
1941         FALLTHROUGH;
1942     case AWAIT:
1943     case YIELD: {
1944         identcase:
1945         bool allowFunctionDeclarationAsStatement = false;
1946         result = parseExpressionOrLabelStatement(context, allowFunctionDeclarationAsStatement);
1947         shouldSetPauseLocation = !context.shouldSkipPauseLocation(result);
1948         break;
1949     }
1950     case STRING:
1951         directive = m_token.m_data.ident;
1952         if (directiveLiteralLength)
1953             *directiveLiteralLength = m_token.m_location.endOffset - m_token.m_location.startOffset;
1954         nonTrivialExpressionCount = m_parserState.nonTrivialExpressionCount;
1955         FALLTHROUGH;
1956     default:
1957         defaultCase:
</pre>
<hr />
<pre>
2006     JSTokenLocation location(tokenLocation());
2007     int start = tokenLine();
2008 
2009     TreeStatement function = 0;
2010     if (!isAsync)
2011         function = parseFunctionDeclaration(context);
2012     else
2013         function = parseAsyncFunctionDeclaration(context);
2014     propagateError();
2015     failIfFalse(function, &quot;Expected valid function statement after &#39;function&#39; keyword&quot;);
2016     TreeSourceElements sourceElements = context.createSourceElements();
2017     context.appendStatement(sourceElements, function);
2018     TreeStatement result = context.createBlockStatement(location, sourceElements, start, m_lastTokenEndPosition.line, currentScope()-&gt;finalizeLexicalEnvironment(), currentScope()-&gt;takeFunctionDeclarations());
2019     popScope(blockScope, TreeBuilder::NeedsFreeVariableInfo);
2020     return result;
2021 }
2022 
2023 template &lt;typename LexerType&gt;
2024 template &lt;class TreeBuilder&gt; bool Parser&lt;LexerType&gt;::maybeParseAsyncFunctionDeclarationStatement(TreeBuilder&amp; context, TreeStatement&amp; result, bool parentAllowsFunctionDeclarationAsStatement)
2025 {
<span class="line-modified">2026     ASSERT(matchContextualKeyword(m_vm-&gt;propertyNames-&gt;async));</span>
2027     SavePoint savePoint = createSavePoint();
2028     next();
2029     if (match(FUNCTION) &amp;&amp; !m_lexer-&gt;hasLineTerminatorBeforeToken()) {
2030         const bool isAsync = true;
2031         result = parseFunctionDeclarationStatement(context, isAsync, parentAllowsFunctionDeclarationAsStatement);
2032         return true;
2033     }
2034     restoreSavePoint(savePoint);
2035     return false;
2036 }
2037 
2038 template &lt;typename LexerType&gt;
2039 template &lt;class TreeBuilder&gt; bool Parser&lt;LexerType&gt;::parseFormalParameters(TreeBuilder&amp; context, TreeFormalParameterList list, bool isArrowFunction, bool isMethod, unsigned&amp; parameterCount)
2040 {
2041 #define failIfDuplicateIfViolation() \
2042     if (duplicateParameter) {\
2043         semanticFailIfTrue(hasDefaultParameterValues, &quot;Duplicate parameter &#39;&quot;, duplicateParameter-&gt;impl(), &quot;&#39; not allowed in function with default parameter values&quot;);\
2044         semanticFailIfTrue(hasDestructuringPattern, &quot;Duplicate parameter &#39;&quot;, duplicateParameter-&gt;impl(), &quot;&#39; not allowed in function with destructuring parameters&quot;);\
2045         semanticFailIfTrue(isRestParameter, &quot;Duplicate parameter &#39;&quot;, duplicateParameter-&gt;impl(), &quot;&#39; not allowed in function with a rest parameter&quot;);\
2046         semanticFailIfTrue(isArrowFunction, &quot;Duplicate parameter &#39;&quot;, duplicateParameter-&gt;impl(), &quot;&#39; not allowed in an arrow function&quot;);\
</pre>
<hr />
<pre>
2267 
2268     return parameterList;
2269 }
2270 
2271 template &lt;typename LexerType&gt;
2272 template &lt;class TreeBuilder&gt; typename TreeBuilder::FormalParameterList Parser&lt;LexerType&gt;::createGeneratorParameters(TreeBuilder&amp; context, unsigned&amp; parameterCount)
2273 {
2274     auto parameters = context.createFormalParameterList();
2275 
2276     JSTokenLocation location(tokenLocation());
2277     JSTextPosition position = tokenStartPosition();
2278 
2279     auto addParameter = [&amp;](const Identifier&amp; name) {
2280         declareParameter(&amp;name);
2281         auto binding = context.createBindingLocation(location, name, position, position, AssignmentContext::DeclarationStatement);
2282         context.appendParameter(parameters, binding, 0);
2283         ++parameterCount;
2284     };
2285 
2286     // @generator
<span class="line-modified">2287     addParameter(m_vm-&gt;propertyNames-&gt;generatorPrivateName);</span>
2288     // @generatorState
<span class="line-modified">2289     addParameter(m_vm-&gt;propertyNames-&gt;generatorStatePrivateName);</span>
2290     // @generatorValue
<span class="line-modified">2291     addParameter(m_vm-&gt;propertyNames-&gt;generatorValuePrivateName);</span>
2292     // @generatorResumeMode
<span class="line-modified">2293     addParameter(m_vm-&gt;propertyNames-&gt;generatorResumeModePrivateName);</span>
2294     // @generatorFrame
<span class="line-modified">2295     addParameter(m_vm-&gt;propertyNames-&gt;generatorFramePrivateName);</span>
2296 
2297     return parameters;
2298 }
2299 
2300 template &lt;typename LexerType&gt;
2301 template &lt;class TreeBuilder&gt; bool Parser&lt;LexerType&gt;::parseFunctionInfo(TreeBuilder&amp; context, FunctionNameRequirements requirements, SourceParseMode mode, bool nameIsInContainingScope, ConstructorKind constructorKind, SuperBinding expectedSuperBinding, int functionKeywordStart, ParserFunctionInfo&lt;TreeBuilder&gt;&amp; functionInfo, FunctionDefinitionType functionDefinitionType, Optional&lt;int&gt; functionConstructorParametersEndPosition)
2302 {
2303     RELEASE_ASSERT(isFunctionParseMode(mode));
2304 
2305     ScopeRef parentScope = currentScope();
2306 
2307     bool isDisallowedAwaitFunctionName = isDisallowedIdentifierAwait(m_token);
2308     const char* isDisallowedAwaitFunctionNameReason = isDisallowedAwaitFunctionName ? disallowedIdentifierAwaitReason() : nullptr;
2309 
2310     AutoPopScopeRef functionScope(this, pushScope());
2311     functionScope-&gt;setSourceParseMode(mode);
2312     functionScope-&gt;setExpectedSuperBinding(expectedSuperBinding);
2313     functionScope-&gt;setConstructorKind(constructorKind);
2314     SetForScope&lt;FunctionParsePhase&gt; functionParsePhasePoisoner(m_parserState.functionParsePhase, FunctionParsePhase::Body);
2315     int functionNameStart = m_token.m_location.startOffset;
</pre>
<hr />
<pre>
2379             m_lexer-&gt;setLineNumber(m_token.m_location.line);
2380 
2381             switch (functionBodyType) {
2382             case ArrowFunctionBodyExpression:
2383                 next();
2384                 context.setEndOffset(functionInfo.body, m_lexer-&gt;currentOffset());
2385                 break;
2386             case ArrowFunctionBodyBlock:
2387             case StandardFunctionBodyBlock:
2388                 context.setEndOffset(functionInfo.body, m_lexer-&gt;currentOffset());
2389                 next();
2390                 break;
2391             }
2392             functionInfo.endLine = m_lastTokenEndPosition.line;
2393             return true;
2394         }
2395 
2396         return false;
2397     };
2398 
<span class="line-modified">2399     SyntaxChecker syntaxChecker(const_cast&lt;VM*&gt;(m_vm), m_lexer.get());</span>
2400 
2401     if (UNLIKELY((SourceParseModeSet(SourceParseMode::ArrowFunctionMode, SourceParseMode::AsyncArrowFunctionMode).contains(mode)))) {
2402         startLocation = tokenLocation();
2403         functionInfo.startLine = tokenLine();
2404         startColumn = tokenColumn();
2405 
2406         parametersStart = m_token.m_location.startOffset;
2407         functionInfo.startOffset = parametersStart;
2408         functionInfo.parametersStartColumn = startColumn;
2409 
2410         if (loadCachedFunction())
2411             return true;
2412 
2413         {
2414             // Parse formal parameters with [+Yield] parameterization, in order to ban YieldExpressions
2415             // in ArrowFormalParameters, per ES6 #sec-arrow-function-definitions-static-semantics-early-errors.
2416             Scope::MaybeParseAsGeneratorForScope parseAsGenerator(functionScope, parentScope-&gt;isGenerator());
2417             SetForScope&lt;bool&gt; overrideAllowAwait(m_parserState.allowAwait, !isAsyncFunctionParseMode(mode));
2418             parseFunctionParameters(syntaxChecker, mode, functionInfo);
2419             propagateError();
</pre>
<hr />
<pre>
2556         // needed.
2557         if (functionScope-&gt;hasNonSimpleParameterList())
2558             generatorBodyScope-&gt;setHasNonSimpleParameterList();
2559 
2560         functionInfo.body = performParsingFunctionBody();
2561 
2562         // When a generator has a &quot;use strict&quot; directive, a generator function wrapping it should be strict mode.
2563         if  (generatorBodyScope-&gt;strictMode())
2564             functionScope-&gt;setStrictMode();
2565 
2566         popScope(generatorBodyScope, TreeBuilder::NeedsFreeVariableInfo);
2567     } else
2568         functionInfo.body = performParsingFunctionBody();
2569 
2570     restoreParserState(oldState);
2571     failIfFalse(functionInfo.body, &quot;Cannot parse the body of this &quot;, stringForFunctionMode(mode));
2572     context.setEndOffset(functionInfo.body, m_lexer-&gt;currentOffset());
2573     if (functionScope-&gt;strictMode() &amp;&amp; requirements != FunctionNameRequirements::Unnamed) {
2574         ASSERT(functionInfo.name);
2575         RELEASE_ASSERT(SourceParseModeSet(SourceParseMode::NormalFunctionMode, SourceParseMode::MethodMode, SourceParseMode::ArrowFunctionMode, SourceParseMode::GeneratorBodyMode, SourceParseMode::GeneratorWrapperFunctionMode).contains(mode) || isAsyncFunctionOrAsyncGeneratorWrapperParseMode(mode));
<span class="line-modified">2576         semanticFailIfTrue(m_vm-&gt;propertyNames-&gt;arguments == *functionInfo.name, &quot;&#39;&quot;, functionInfo.name-&gt;impl(), &quot;&#39; is not a valid function name in strict mode&quot;);</span>
<span class="line-modified">2577         semanticFailIfTrue(m_vm-&gt;propertyNames-&gt;eval == *functionInfo.name, &quot;&#39;&quot;, functionInfo.name-&gt;impl(), &quot;&#39; is not a valid function name in strict mode&quot;);</span>
2578     }
2579 
2580     JSTokenLocation location = JSTokenLocation(m_token.m_location);
2581     functionInfo.endOffset = m_token.m_data.offset;
2582 
2583     if (functionBodyType == ArrowFunctionBodyExpression) {
2584         location = locationBeforeLastToken();
2585         functionInfo.endOffset = location.endOffset;
2586     } else {
2587         recordFunctionEntryLocation(JSTextPosition(startLocation.line, startLocation.startOffset, startLocation.lineStartOffset));
2588         recordFunctionLeaveLocation(JSTextPosition(location.line, location.startOffset, location.lineStartOffset));
2589     }
2590 
2591     // Cache the tokenizer state and the function scope the first time the function is parsed.
2592     // Any future reparsing can then skip the function.
2593     // For arrow function is 8 = x=&gt;x + 4 symbols;
2594     // For ordinary function is 16  = function(){} + 4 symbols
2595     const int minimumSourceLengthToCache = functionBodyType == StandardFunctionBodyBlock ? 16 : 8;
2596     std::unique_ptr&lt;SourceProviderCacheItem&gt; newInfo;
2597     int sourceLength = functionInfo.endOffset - functionInfo.startOffset;
</pre>
<hr />
<pre>
2659         //
2660         //     ExportDeclaration:
2661         //         ...
2662         //         export default HoistableDeclaration[~Yield, +Default]
2663         //         ...
2664         //
2665         //     HoistableDeclaration[Yield, Default]:
2666         //         FunctionDeclaration[?Yield, ?Default]
2667         //         GeneratorDeclaration[?Yield, ?Default]
2668         //
2669         //     FunctionDeclaration[Yield, Default]:
2670         //         ...
2671         //         [+Default] function ( FormalParameters[~Yield] ) { FunctionBody[~Yield] }
2672         //
2673         //     GeneratorDeclaration[Yield, Default]:
2674         //         ...
2675         //         [+Default] function * ( FormalParameters[+Yield] ) { GeneratorBody }
2676         //
2677         // In this case, we use &quot;*default*&quot; as this function declaration&#39;s name.
2678         requirements = FunctionNameRequirements::None;
<span class="line-modified">2679         functionInfo.name = &amp;m_vm-&gt;propertyNames-&gt;starDefaultPrivateName;</span>
2680     }
2681 
2682     failIfFalse((parseFunctionInfo(context, requirements, parseMode, true, ConstructorKind::None, SuperBinding::NotNeeded, functionKeywordStart, functionInfo, FunctionDefinitionType::Declaration, functionConstructorParametersEndPosition)), &quot;Cannot parse this function&quot;);
2683     ASSERT(functionInfo.name);
2684 
2685     std::pair&lt;DeclarationResultMask, ScopeRef&gt; functionDeclaration = declareFunction(functionInfo.name);
2686     DeclarationResultMask declarationResult = functionDeclaration.first;
2687     failIfTrueIfStrict(declarationResult &amp; DeclarationResult::InvalidStrictMode, &quot;Cannot declare a function named &#39;&quot;, functionInfo.name-&gt;impl(), &quot;&#39; in strict mode&quot;);
2688     if (declarationResult &amp; DeclarationResult::InvalidDuplicateDeclaration)
2689         internalFailWithMessage(false, &quot;Cannot declare a function that shadows a let/const/class/function variable &#39;&quot;, functionInfo.name-&gt;impl(), &quot;&#39; in strict mode&quot;);
2690     if (exportType == ExportType::Exported) {
2691         ASSERT_WITH_MESSAGE(declarationDefaultContext != DeclarationDefaultContext::ExportDefault, &quot;Export default case will export the name and binding in the caller.&quot;);
2692         semanticFailIfFalse(exportName(*functionInfo.name), &quot;Cannot export a duplicate function name: &#39;&quot;, functionInfo.name-&gt;impl(), &quot;&#39;&quot;);
2693         m_moduleScopeData-&gt;exportBinding(*functionInfo.name);
2694     }
2695 
2696     TreeStatement result = context.createFuncDeclStatement(location, functionInfo);
2697     if (TreeBuilder::CreatesAST)
2698         functionDeclaration.second-&gt;appendFunction(getMetadata(functionInfo));
2699     return result;
</pre>
<hr />
<pre>
2717         //
2718         //     ExportDeclaration:
2719         //         ...
2720         //         export default HoistableDeclaration[~Yield, +Default]
2721         //         ...
2722         //
2723         //     HoistableDeclaration[Yield, Default]:
2724         //         FunctionDeclaration[?Yield, ?Default]
2725         //         GeneratorDeclaration[?Yield, ?Default]
2726         //
2727         //     FunctionDeclaration[Yield, Default]:
2728         //         ...
2729         //         [+Default] function ( FormalParameters[~Yield] ) { FunctionBody[~Yield] }
2730         //
2731         //     GeneratorDeclaration[Yield, Default]:
2732         //         ...
2733         //         [+Default] function * ( FormalParameters[+Yield] ) { GeneratorBody }
2734         //
2735         // In this case, we use &quot;*default*&quot; as this function declaration&#39;s name.
2736         requirements = FunctionNameRequirements::None;
<span class="line-modified">2737         functionInfo.name = &amp;m_vm-&gt;propertyNames-&gt;starDefaultPrivateName;</span>
2738     }
2739 
2740     failIfFalse((parseFunctionInfo(context, requirements, parseMode, true, ConstructorKind::None, SuperBinding::NotNeeded, functionKeywordStart, functionInfo, FunctionDefinitionType::Declaration, functionConstructorParametersEndPosition)), &quot;Cannot parse this async function&quot;);
2741     failIfFalse(functionInfo.name, &quot;Async function statements must have a name&quot;);
2742 
2743     std::pair&lt;DeclarationResultMask, ScopeRef&gt; functionDeclaration = declareFunction(functionInfo.name);
2744     DeclarationResultMask declarationResult = functionDeclaration.first;
2745     failIfTrueIfStrict(declarationResult &amp; DeclarationResult::InvalidStrictMode, &quot;Cannot declare an async function named &#39;&quot;, functionInfo.name-&gt;impl(), &quot;&#39; in strict mode&quot;);
2746     if (declarationResult &amp; DeclarationResult::InvalidDuplicateDeclaration)
2747         internalFailWithMessage(false, &quot;Cannot declare an async function that shadows a let/const/class/function variable &#39;&quot;, functionInfo.name-&gt;impl(), &quot;&#39; in strict mode&quot;);
2748     if (exportType == ExportType::Exported) {
2749         semanticFailIfFalse(exportName(*functionInfo.name), &quot;Cannot export a duplicate function name: &#39;&quot;, functionInfo.name-&gt;impl(), &quot;&#39;&quot;);
2750         m_moduleScopeData-&gt;exportBinding(*functionInfo.name);
2751     }
2752 
2753     TreeStatement result = context.createFuncDeclStatement(location, functionInfo);
2754     if (TreeBuilder::CreatesAST)
2755         functionDeclaration.second-&gt;appendFunction(getMetadata(functionInfo));
2756     return result;
2757 }
</pre>
<hr />
<pre>
2763     JSTokenLocation location(tokenLocation());
2764     JSTextPosition classStart = tokenStartPosition();
2765     unsigned classStartLine = tokenLine();
2766 
2767     ParserClassInfo&lt;TreeBuilder&gt; info;
2768     FunctionNameRequirements requirements = FunctionNameRequirements::Named;
2769     if (declarationDefaultContext == DeclarationDefaultContext::ExportDefault) {
2770         // Under the &quot;export default&quot; context, class declaration does not require the class name.
2771         //
2772         //     ExportDeclaration:
2773         //         ...
2774         //         export default ClassDeclaration[~Yield, +Default]
2775         //         ...
2776         //
2777         //     ClassDeclaration[Yield, Default]:
2778         //         ...
2779         //         [+Default] class ClassTail[?Yield]
2780         //
2781         // In this case, we use &quot;*default*&quot; as this class declaration&#39;s name.
2782         requirements = FunctionNameRequirements::None;
<span class="line-modified">2783         info.className = &amp;m_vm-&gt;propertyNames-&gt;starDefaultPrivateName;</span>
2784     }
2785 
2786     TreeClassExpression classExpr = parseClass(context, requirements, info);
2787     failIfFalse(classExpr, &quot;Failed to parse class&quot;);
2788     ASSERT(info.className);
2789 
2790     DeclarationResultMask declarationResult = declareVariable(info.className, DeclarationType::LetDeclaration);
2791     if (declarationResult &amp; DeclarationResult::InvalidDuplicateDeclaration)
2792         internalFailWithMessage(false, &quot;Cannot declare a class twice: &#39;&quot;, info.className-&gt;impl(), &quot;&#39;&quot;);
2793     if (exportType == ExportType::Exported) {
2794         ASSERT_WITH_MESSAGE(declarationDefaultContext != DeclarationDefaultContext::ExportDefault, &quot;Export default case will export the name and binding in the caller.&quot;);
2795         semanticFailIfFalse(exportName(*info.className), &quot;Cannot export a duplicate class name: &#39;&quot;, info.className-&gt;impl(), &quot;&#39;&quot;);
2796         m_moduleScopeData-&gt;exportBinding(*info.className);
2797     }
2798 
2799     JSTextPosition classEnd = lastTokenEndPosition();
2800     unsigned classEndLine = tokenLine();
2801 
2802     return context.createClassDeclStatement(location, classExpr, classStart, classEnd, classStartLine, classEndLine);
2803 }
</pre>
<hr />
<pre>
2837         failIfFalse(parentClass, &quot;Cannot parse the parent class name&quot;);
2838     }
2839     const ConstructorKind constructorKind = parentClass ? ConstructorKind::Extends : ConstructorKind::Base;
2840 
2841     consumeOrFail(OPENBRACE, &quot;Expected opening &#39;{&#39; at the start of a class body&quot;);
2842 
2843     TreeExpression constructor = 0;
2844     TreePropertyList classElements = 0;
2845     TreePropertyList classElementsTail = 0;
2846     while (!match(CLOSEBRACE)) {
2847         if (match(SEMICOLON)) {
2848             next();
2849             continue;
2850         }
2851 
2852         JSTokenLocation methodLocation(tokenLocation());
2853         unsigned methodStart = tokenStart();
2854 
2855         // For backwards compatibility, &quot;static&quot; is a non-reserved keyword in non-strict mode.
2856         ClassElementTag tag = ClassElementTag::Instance;
<span class="line-modified">2857         if (match(RESERVED_IF_STRICT) &amp;&amp; *m_token.m_data.ident == m_vm-&gt;propertyNames-&gt;staticKeyword) {</span>
2858             SavePoint savePoint = createSavePoint();
2859             next();
2860             if (match(OPENPAREN)) {
2861                 // Reparse &quot;static()&quot; as a method named &quot;static&quot;.
2862                 restoreSavePoint(savePoint);
2863             } else
2864                 tag = ClassElementTag::Static;
2865         }
2866 
2867         // FIXME: Figure out a way to share more code with parseProperty.
<span class="line-modified">2868         const CommonIdentifiers&amp; propertyNames = *m_vm-&gt;propertyNames;</span>
2869         const Identifier* ident = &amp;propertyNames.nullIdentifier;
2870         TreeExpression computedPropertyName = 0;
2871         bool isGetter = false;
2872         bool isSetter = false;
2873         SourceParseMode parseMode = SourceParseMode::MethodMode;
2874         if (consume(TIMES))
2875             parseMode = SourceParseMode::GeneratorWrapperMethodMode;
2876 
2877 parseMethod:
2878         switch (m_token.m_type) {
2879         namedKeyword:
2880         case STRING:
2881             ident = m_token.m_data.ident;
2882             ASSERT(ident);
2883             next();
2884             break;
2885         case IDENT:
<span class="line-modified">2886             if (UNLIKELY(*m_token.m_data.ident == m_vm-&gt;propertyNames-&gt;async &amp;&amp; !m_token.m_data.escaped)) {</span>
2887                 if (!isGeneratorMethodParseMode(parseMode) &amp;&amp; !isAsyncMethodParseMode(parseMode)) {
2888                     ident = m_token.m_data.ident;
2889                     next();
2890                     if (match(OPENPAREN) || match(COLON) || match(EQUAL) || m_lexer-&gt;hasLineTerminatorBeforeToken())
2891                         break;
2892                     if (UNLIKELY(consume(TIMES)))
2893                         parseMode = SourceParseMode::AsyncGeneratorWrapperMethodMode;
2894                     else
2895                         parseMode = SourceParseMode::AsyncMethodMode;
2896                     goto parseMethod;
2897                 }
2898             }
2899             FALLTHROUGH;
2900         case AWAIT:
2901             ident = m_token.m_data.ident;
2902             ASSERT(ident);
2903             next();
2904             if (parseMode == SourceParseMode::MethodMode &amp;&amp; (matchIdentifierOrKeyword() || match(STRING) || match(DOUBLE) || match(INTEGER) || match(OPENBRACKET))) {
2905                 isGetter = *ident == propertyNames.get;
2906                 isSetter = *ident == propertyNames.set;
2907             }
2908             break;
2909         case DOUBLE:
2910         case INTEGER:
<span class="line-modified">2911             ident = &amp;m_parserArena.identifierArena().makeNumericIdentifier(const_cast&lt;VM*&gt;(m_vm), m_token.m_data.doubleValue);</span>
2912             ASSERT(ident);
2913             next();
2914             break;
2915         case OPENBRACKET:
2916             next();
2917             computedPropertyName = parseAssignmentExpression(context);
2918             failIfFalse(computedPropertyName, &quot;Cannot parse computed property name&quot;);
2919             handleProductionOrFail(CLOSEBRACKET, &quot;]&quot;, &quot;end&quot;, &quot;computed property name&quot;);
2920             break;
2921         default:
2922             if (m_token.m_type &amp; KeywordTokenFlag)
2923                 goto namedKeyword;
2924             failDueToUnexpectedToken();
2925         }
2926 
2927         TreeProperty property;
2928         const bool alwaysStrictInsideClass = true;
2929         if (isGetter || isSetter) {
2930             property = parseGetterSetter(context, alwaysStrictInsideClass, isGetter ? PropertyNode::Getter : PropertyNode::Setter,
2931                 methodStart, ConstructorKind::None, tag);
2932             failIfFalse(property, &quot;Cannot parse this method&quot;);
2933         } else {
2934             ParserFunctionInfo&lt;TreeBuilder&gt; methodInfo;
2935             bool isConstructor = tag == ClassElementTag::Instance &amp;&amp; *ident == propertyNames.constructor;
2936             if (isAsyncMethodParseMode(parseMode) || isAsyncGeneratorMethodParseMode(parseMode) || isGeneratorMethodParseMode(parseMode)) {
2937                 isConstructor = false;
<span class="line-modified">2938                 semanticFailIfTrue(*ident == m_vm-&gt;propertyNames-&gt;prototype, &quot;Cannot declare &quot;, stringArticleForFunctionMode(parseMode), stringForFunctionMode(parseMode), &quot; named &#39;prototype&#39;&quot;);</span>
<span class="line-modified">2939                 semanticFailIfTrue(*ident == m_vm-&gt;propertyNames-&gt;constructor, &quot;Cannot declare &quot;, stringArticleForFunctionMode(parseMode), stringForFunctionMode(parseMode), &quot; named &#39;constructor&#39;&quot;);</span>
2940             }
2941 
2942             methodInfo.name = isConstructor ? info.className : ident;
2943             failIfFalse((parseFunctionInfo(context, FunctionNameRequirements::Unnamed, parseMode, false, isConstructor ? constructorKind : ConstructorKind::None, SuperBinding::Needed, methodStart, methodInfo, FunctionDefinitionType::Method)), &quot;Cannot parse this method&quot;);
2944 
2945             TreeExpression method = context.createMethodDefinition(methodLocation, methodInfo);
2946             if (isConstructor) {
2947                 semanticFailIfTrue(constructor, &quot;Cannot declare multiple constructors in a single class&quot;);
2948                 constructor = method;
2949                 continue;
2950             }
2951 
2952             // FIXME: Syntax error when super() is called
2953             semanticFailIfTrue(tag == ClassElementTag::Static &amp;&amp; methodInfo.name &amp;&amp; *methodInfo.name == propertyNames.prototype,
2954                 &quot;Cannot declare a static method named &#39;prototype&#39;&quot;);
2955 
2956             if (computedPropertyName) {
2957                 property = context.createProperty(computedPropertyName, method, static_cast&lt;PropertyNode::Type&gt;(PropertyNode::Constant | PropertyNode::Computed),
2958                     PropertyNode::Unknown, alwaysStrictInsideClass, SuperBinding::Needed, tag);
2959             } else {
</pre>
<hr />
<pre>
3071         break;
3072     }
3073     JSTextPosition start = tokenStartPosition();
3074     JSTokenLocation location(tokenLocation());
3075     TreeExpression expression = parseExpression(context);
3076     failIfFalse(expression, &quot;Cannot parse expression statement&quot;);
3077     failIfFalse(autoSemiColon(), &quot;Parse error&quot;);
3078     return context.createExprStatement(location, expression, start, m_lastTokenEndPosition.line);
3079 }
3080 
3081 template &lt;typename LexerType&gt;
3082 template &lt;class TreeBuilder&gt; TreeStatement Parser&lt;LexerType&gt;::parseIfStatement(TreeBuilder&amp; context)
3083 {
3084     ASSERT(match(IF));
3085     JSTokenLocation ifLocation(tokenLocation());
3086     int start = tokenLine();
3087     next();
3088     handleProductionOrFail2(OPENPAREN, &quot;(&quot;, &quot;start&quot;, &quot;&#39;if&#39; condition&quot;);
3089 
3090     TreeExpression condition = parseExpression(context);
<span class="line-modified">3091     failIfFalse(condition, &quot;Expected a expression as the condition for an if statement&quot;);</span>
3092     recordPauseLocation(context.breakpointLocation(condition));
3093     int end = tokenLine();
3094     handleProductionOrFail2(CLOSEPAREN, &quot;)&quot;, &quot;end&quot;, &quot;&#39;if&#39; condition&quot;);
3095 
3096     const Identifier* unused = 0;
3097     m_immediateParentAllowsFunctionDeclarationInStatement = true;
3098     TreeStatement trueBlock = parseStatement(context, unused);
3099     failIfFalse(trueBlock, &quot;Expected a statement as the body of an if block&quot;);
3100 
3101     if (!match(ELSE))
3102         return context.createIfStatement(ifLocation, condition, trueBlock, 0, start, end);
3103 
3104     Vector&lt;TreeExpression&gt; exprStack;
3105     Vector&lt;std::pair&lt;int, int&gt;&gt; posStack;
3106     Vector&lt;JSTokenLocation&gt; tokenLocationStack;
3107     Vector&lt;TreeStatement&gt; statementStack;
3108     bool trailingElse = false;
3109     do {
3110         JSTokenLocation tempLocation = tokenLocation();
3111         next();
3112         if (!match(IF)) {
3113             const Identifier* unused = 0;
3114             m_immediateParentAllowsFunctionDeclarationInStatement = true;
3115             TreeStatement block = parseStatement(context, unused);
3116             failIfFalse(block, &quot;Expected a statement as the body of an else block&quot;);
3117             statementStack.append(block);
3118             trailingElse = true;
3119             break;
3120         }
3121         int innerStart = tokenLine();
3122         next();
3123 
3124         handleProductionOrFail2(OPENPAREN, &quot;(&quot;, &quot;start&quot;, &quot;&#39;if&#39; condition&quot;);
3125 
3126         TreeExpression innerCondition = parseExpression(context);
<span class="line-modified">3127         failIfFalse(innerCondition, &quot;Expected a expression as the condition for an if statement&quot;);</span>
3128         recordPauseLocation(context.breakpointLocation(innerCondition));
3129         int innerEnd = tokenLine();
3130         handleProductionOrFail2(CLOSEPAREN, &quot;)&quot;, &quot;end&quot;, &quot;&#39;if&#39; condition&quot;);
3131         const Identifier* unused = 0;
3132         m_immediateParentAllowsFunctionDeclarationInStatement = true;
3133         TreeStatement innerTrueBlock = parseStatement(context, unused);
3134         failIfFalse(innerTrueBlock, &quot;Expected a statement as the body of an if block&quot;);
3135         tokenLocationStack.append(tempLocation);
3136         exprStack.append(innerCondition);
3137         posStack.append(std::make_pair(innerStart, innerEnd));
3138         statementStack.append(innerTrueBlock);
3139     } while (match(ELSE));
3140 
3141     if (!trailingElse) {
3142         TreeExpression condition = exprStack.last();
3143         exprStack.removeLast();
3144         TreeStatement trueBlock = statementStack.last();
3145         statementStack.removeLast();
3146         std::pair&lt;int, int&gt; pos = posStack.last();
3147         posStack.removeLast();
</pre>
<hr />
<pre>
3185 }
3186 
3187 template &lt;typename LexerType&gt;
3188 template &lt;class TreeBuilder&gt; typename TreeBuilder::ImportSpecifier Parser&lt;LexerType&gt;::parseImportClauseItem(TreeBuilder&amp; context, ImportSpecifierType specifierType)
3189 {
3190     // Produced node is the item of the ImportClause.
3191     // That is the ImportSpecifier, ImportedDefaultBinding or NameSpaceImport.
3192     // http://www.ecma-international.org/ecma-262/6.0/#sec-imports
3193     JSTokenLocation specifierLocation(tokenLocation());
3194     JSToken localNameToken;
3195     const Identifier* importedName = nullptr;
3196     const Identifier* localName = nullptr;
3197 
3198     switch (specifierType) {
3199     case ImportSpecifierType::NamespaceImport: {
3200         // NameSpaceImport :
3201         // * as ImportedBinding
3202         // e.g.
3203         //     * as namespace
3204         ASSERT(match(TIMES));
<span class="line-modified">3205         importedName = &amp;m_vm-&gt;propertyNames-&gt;timesIdentifier;</span>
3206         next();
3207 
<span class="line-modified">3208         failIfFalse(matchContextualKeyword(m_vm-&gt;propertyNames-&gt;as), &quot;Expected &#39;as&#39; before imported binding name&quot;);</span>
3209         next();
3210 
3211         failIfFalse(matchSpecIdentifier(), &quot;Expected a variable name for the import declaration&quot;);
3212         localNameToken = m_token;
3213         localName = m_token.m_data.ident;
3214         next();
3215         break;
3216     }
3217 
3218     case ImportSpecifierType::NamedImport: {
3219         // ImportSpecifier :
3220         // ImportedBinding
3221         // IdentifierName as ImportedBinding
3222         // e.g.
3223         //     A
3224         //     A as B
3225         ASSERT(matchIdentifierOrKeyword());
3226         localNameToken = m_token;
3227         localName = m_token.m_data.ident;
3228         importedName = localName;
3229         next();
3230 
<span class="line-modified">3231         if (matchContextualKeyword(m_vm-&gt;propertyNames-&gt;as)) {</span>
3232             next();
3233             failIfFalse(matchSpecIdentifier(), &quot;Expected a variable name for the import declaration&quot;);
3234             localNameToken = m_token;
3235             localName = m_token.m_data.ident;
3236             next();
3237         }
3238         break;
3239     }
3240 
3241     case ImportSpecifierType::DefaultImport: {
3242         // ImportedDefaultBinding :
3243         // ImportedBinding
3244         ASSERT(matchSpecIdentifier());
3245         localNameToken = m_token;
3246         localName = m_token.m_data.ident;
<span class="line-modified">3247         importedName = &amp;m_vm-&gt;propertyNames-&gt;defaultKeyword;</span>
3248         next();
3249         break;
3250     }
3251     }
3252 
3253     semanticFailIfTrue(localNameToken.m_type == AWAIT, &quot;Cannot use &#39;await&#39; as an imported binding name&quot;);
3254     semanticFailIfTrue(localNameToken.m_type &amp; KeywordTokenFlag, &quot;Cannot use keyword as imported binding name&quot;);
3255     DeclarationResultMask declarationResult = declareVariable(localName, DeclarationType::ConstDeclaration, (specifierType == ImportSpecifierType::NamespaceImport) ? DeclarationImportType::ImportedNamespace : DeclarationImportType::Imported);
3256     if (declarationResult != DeclarationResult::Valid) {
3257         failIfTrueIfStrict(declarationResult &amp; DeclarationResult::InvalidStrictMode, &quot;Cannot declare an imported binding named &quot;, localName-&gt;impl(), &quot; in strict mode&quot;);
3258         if (declarationResult &amp; DeclarationResult::InvalidDuplicateDeclaration)
3259             internalFailWithMessage(false, &quot;Cannot declare an imported binding name twice: &#39;&quot;, localName-&gt;impl(), &quot;&#39;&quot;);
3260     }
3261 
3262     return context.createImportSpecifier(specifierLocation, *importedName, *localName);
3263 }
3264 
3265 template &lt;typename LexerType&gt;
3266 template &lt;class TreeBuilder&gt; TreeStatement Parser&lt;LexerType&gt;::parseImportDeclaration(TreeBuilder&amp; context)
3267 {
</pre>
<hr />
<pre>
3305             // { ImportsList }
3306             // { ImportsList , }
3307             next();
3308 
3309             while (!match(CLOSEBRACE)) {
3310                 failIfFalse(matchIdentifierOrKeyword(), &quot;Expected an imported name for the import declaration&quot;);
3311                 auto specifier = parseImportClauseItem(context, ImportSpecifierType::NamedImport);
3312                 failIfFalse(specifier, &quot;Cannot parse the named import&quot;);
3313                 context.appendImportSpecifier(specifierList, specifier);
3314                 if (!consume(COMMA))
3315                     break;
3316             }
3317             handleProductionOrFail2(CLOSEBRACE, &quot;}&quot;, &quot;end&quot;, &quot;import list&quot;);
3318         } else
3319             failWithMessage(&quot;Expected namespace import or import list&quot;);
3320     }
3321 
3322     // FromClause :
3323     // from ModuleSpecifier
3324 
<span class="line-modified">3325     failIfFalse(matchContextualKeyword(m_vm-&gt;propertyNames-&gt;from), &quot;Expected &#39;from&#39; before imported module name&quot;);</span>
3326     next();
3327 
3328     auto moduleName = parseModuleName(context);
3329     failIfFalse(moduleName, &quot;Cannot parse the module name&quot;);
3330     failIfFalse(autoSemiColon(), &quot;Expected a &#39;;&#39; following a targeted import declaration&quot;);
3331 
3332     return context.createImportDeclaration(importLocation, specifierList, moduleName);
3333 }
3334 
3335 template &lt;typename LexerType&gt;
3336 template &lt;class TreeBuilder&gt; typename TreeBuilder::ExportSpecifier Parser&lt;LexerType&gt;::parseExportSpecifier(TreeBuilder&amp; context, Vector&lt;std::pair&lt;const Identifier*, const Identifier*&gt;&gt;&amp; maybeExportedLocalNames, bool&amp; hasKeywordForLocalBindings)
3337 {
3338     // ExportSpecifier :
3339     // IdentifierName
3340     // IdentifierName as IdentifierName
3341     // http://www.ecma-international.org/ecma-262/6.0/#sec-exports
3342     ASSERT(matchIdentifierOrKeyword());
3343     JSTokenLocation specifierLocation(tokenLocation());
3344     if (m_token.m_type &amp; KeywordTokenFlag)
3345         hasKeywordForLocalBindings = true;
3346     const Identifier* localName = m_token.m_data.ident;
3347     const Identifier* exportedName = localName;
3348     next();
3349 
<span class="line-modified">3350     if (matchContextualKeyword(m_vm-&gt;propertyNames-&gt;as)) {</span>
3351         next();
3352         failIfFalse(matchIdentifierOrKeyword(), &quot;Expected an exported name for the export declaration&quot;);
3353         exportedName = m_token.m_data.ident;
3354         next();
3355     }
3356 
3357     semanticFailIfFalse(exportName(*exportedName), &quot;Cannot export a duplicate name &#39;&quot;, exportedName-&gt;impl(), &quot;&#39;&quot;);
3358     maybeExportedLocalNames.append(std::make_pair(localName, exportedName));
3359     return context.createExportSpecifier(specifierLocation, *localName, *exportedName);
3360 }
3361 
3362 template &lt;typename LexerType&gt;
3363 template &lt;class TreeBuilder&gt; TreeStatement Parser&lt;LexerType&gt;::parseExportDeclaration(TreeBuilder&amp; context)
3364 {
3365     // http://www.ecma-international.org/ecma-262/6.0/#sec-exports
3366     ASSERT(match(EXPORT));
3367     JSTokenLocation exportLocation(tokenLocation());
3368     next();
3369 
3370     switch (m_token.m_type) {
3371     case TIMES: {
3372         // export * FromClause ;
3373         next();
3374 
<span class="line-modified">3375         failIfFalse(matchContextualKeyword(m_vm-&gt;propertyNames-&gt;from), &quot;Expected &#39;from&#39; before exported module name&quot;);</span>
3376         next();
3377         auto moduleName = parseModuleName(context);
3378         failIfFalse(moduleName, &quot;Cannot parse the &#39;from&#39; clause&quot;);
3379         failIfFalse(autoSemiColon(), &quot;Expected a &#39;;&#39; following a targeted export declaration&quot;);
3380 
3381         return context.createExportAllDeclaration(exportLocation, moduleName);
3382     }
3383 
3384     case DEFAULT: {
3385         // export default HoistableDeclaration[Default]
3386         // export default ClassDeclaration[Default]
3387         // export default [lookahead not-in {function, class}] AssignmentExpression[In] ;
3388 
3389         next();
3390 
3391         TreeStatement result = 0;
3392         bool isFunctionOrClassDeclaration = false;
3393         const Identifier* localName = nullptr;
3394 
3395         bool startsWithFunction = match(FUNCTION);
3396         if (startsWithFunction || match(CLASSTOKEN)) {
3397             SavePoint savePoint = createSavePoint();
3398             isFunctionOrClassDeclaration = true;
3399             next();
3400 
3401             // ES6 Generators
3402             if (startsWithFunction &amp;&amp; match(TIMES))
3403                 next();
3404             if (match(IDENT))
3405                 localName = m_token.m_data.ident;
3406             restoreSavePoint(savePoint);
<span class="line-modified">3407         } else if (matchContextualKeyword(m_vm-&gt;propertyNames-&gt;async)) {</span>
3408             SavePoint savePoint = createSavePoint();
3409             next();
3410             if (match(FUNCTION) &amp;&amp; !m_lexer-&gt;hasLineTerminatorBeforeToken()) {
3411                 next();
3412                 if (match(IDENT))
3413                     localName = m_token.m_data.ident;
3414                 isFunctionOrClassDeclaration = true;
3415             }
3416             restoreSavePoint(savePoint);
3417         }
3418 
3419         if (!localName)
<span class="line-modified">3420             localName = &amp;m_vm-&gt;propertyNames-&gt;starDefaultPrivateName;</span>
3421 
3422         if (isFunctionOrClassDeclaration) {
3423             if (startsWithFunction) {
3424                 ASSERT(match(FUNCTION));
3425                 DepthManager statementDepth(&amp;m_statementDepth);
3426                 m_statementDepth = 1;
3427                 result = parseFunctionDeclaration(context, ExportType::NotExported, DeclarationDefaultContext::ExportDefault);
3428             } else if (match(CLASSTOKEN)) {
3429                 result = parseClassDeclaration(context, ExportType::NotExported, DeclarationDefaultContext::ExportDefault);
3430             } else {
<span class="line-modified">3431                 ASSERT(matchContextualKeyword(m_vm-&gt;propertyNames-&gt;async));</span>
3432                 next();
3433                 DepthManager statementDepth(&amp;m_statementDepth);
3434                 m_statementDepth = 1;
3435                 result = parseAsyncFunctionDeclaration(context, ExportType::NotExported, DeclarationDefaultContext::ExportDefault);
3436             }
3437         } else {
3438             // export default expr;
3439             //
3440             // It should be treated as the same to the following.
3441             //
3442             // const *default* = expr;
3443             // export { *default* as default }
3444             //
3445             // In the above example, *default* is the invisible variable to the users.
3446             // We use the private symbol to represent the name of this variable.
3447             JSTokenLocation location(tokenLocation());
3448             JSTextPosition start = tokenStartPosition();
3449             TreeExpression expression = parseAssignmentExpression(context);
3450             failIfFalse(expression, &quot;Cannot parse expression&quot;);
3451 
<span class="line-modified">3452             DeclarationResultMask declarationResult = declareVariable(&amp;m_vm-&gt;propertyNames-&gt;starDefaultPrivateName, DeclarationType::ConstDeclaration);</span>
3453             if (declarationResult &amp; DeclarationResult::InvalidDuplicateDeclaration)
3454                 internalFailWithMessage(false, &quot;Only one &#39;default&#39; export is allowed&quot;);
3455 
<span class="line-modified">3456             TreeExpression assignment = context.createAssignResolve(location, m_vm-&gt;propertyNames-&gt;starDefaultPrivateName, expression, start, start, tokenEndPosition(), AssignmentContext::ConstDeclarationStatement);</span>
3457             result = context.createExprStatement(location, assignment, start, tokenEndPosition());
3458             failIfFalse(autoSemiColon(), &quot;Expected a &#39;;&#39; following a targeted export declaration&quot;);
3459         }
3460         failIfFalse(result, &quot;Cannot parse the declaration&quot;);
3461 
<span class="line-modified">3462         semanticFailIfFalse(exportName(m_vm-&gt;propertyNames-&gt;defaultKeyword), &quot;Only one &#39;default&#39; export is allowed&quot;);</span>
<span class="line-modified">3463         m_moduleScopeData-&gt;exportBinding(*localName, m_vm-&gt;propertyNames-&gt;defaultKeyword);</span>
3464         return context.createExportDefaultDeclaration(exportLocation, result, *localName);
3465     }
3466 
3467     case OPENBRACE: {
3468         // export ExportClause FromClause ;
3469         // export ExportClause ;
3470         //
3471         // ExportClause :
3472         // { }
3473         // { ExportsList }
3474         // { ExportsList , }
3475         //
3476         // ExportsList :
3477         // ExportSpecifier
3478         // ExportsList , ExportSpecifier
3479 
3480         next();
3481 
3482         auto specifierList = context.createExportSpecifierList();
3483         Vector&lt;std::pair&lt;const Identifier*, const Identifier*&gt;&gt; maybeExportedLocalNames;
3484 
3485         bool hasKeywordForLocalBindings = false;
3486         while (!match(CLOSEBRACE)) {
3487             failIfFalse(matchIdentifierOrKeyword(), &quot;Expected a variable name for the export declaration&quot;);
3488             auto specifier = parseExportSpecifier(context, maybeExportedLocalNames, hasKeywordForLocalBindings);
3489             failIfFalse(specifier, &quot;Cannot parse the named export&quot;);
3490             context.appendExportSpecifier(specifierList, specifier);
3491             if (!consume(COMMA))
3492                 break;
3493         }
3494         handleProductionOrFail2(CLOSEBRACE, &quot;}&quot;, &quot;end&quot;, &quot;export list&quot;);
3495 
3496         typename TreeBuilder::ModuleName moduleName = 0;
<span class="line-modified">3497         if (matchContextualKeyword(m_vm-&gt;propertyNames-&gt;from)) {</span>
3498             next();
3499             moduleName = parseModuleName(context);
3500             failIfFalse(moduleName, &quot;Cannot parse the &#39;from&#39; clause&quot;);
3501         }
3502         failIfFalse(autoSemiColon(), &quot;Expected a &#39;;&#39; following a targeted export declaration&quot;);
3503 
3504         if (!moduleName) {
3505             semanticFailIfTrue(hasKeywordForLocalBindings, &quot;Cannot use keyword as exported variable name&quot;);
3506             // Since this export declaration does not have module specifier part, it exports the local bindings.
3507             // While the export declaration with module specifier does not have any effect on the current module&#39;s scope,
3508             // the export named declaration without module specifier references the local binding names.
3509             // For example,
3510             //   export { A, B, C as D } from &quot;mod&quot;
3511             // does not have effect on the current module&#39;s scope. But,
3512             //   export { A, B, C as D }
3513             // will reference the current module&#39;s bindings.
3514             for (const auto&amp; pair : maybeExportedLocalNames) {
3515                 const Identifier* localName = pair.first;
3516                 const Identifier* exportedName = pair.second;
3517                 m_moduleScopeData-&gt;exportBinding(*localName, *exportedName);
</pre>
<hr />
<pre>
3533         case CONSTTOKEN:
3534             result = parseVariableDeclaration(context, DeclarationType::ConstDeclaration, ExportType::Exported);
3535             break;
3536 
3537         case LET:
3538             result = parseVariableDeclaration(context, DeclarationType::LetDeclaration, ExportType::Exported);
3539             break;
3540 
3541         case FUNCTION: {
3542             DepthManager statementDepth(&amp;m_statementDepth);
3543             m_statementDepth = 1;
3544             result = parseFunctionDeclaration(context, ExportType::Exported);
3545             break;
3546         }
3547 
3548         case CLASSTOKEN:
3549             result = parseClassDeclaration(context, ExportType::Exported);
3550             break;
3551 
3552         case IDENT:
<span class="line-modified">3553             if (*m_token.m_data.ident == m_vm-&gt;propertyNames-&gt;async &amp;&amp; !m_token.m_data.escaped) {</span>
3554                 next();
3555                 semanticFailIfFalse(match(FUNCTION) &amp;&amp; !m_lexer-&gt;hasLineTerminatorBeforeToken(), &quot;Expected &#39;function&#39; keyword following &#39;async&#39; keyword with no preceding line terminator&quot;);
3556                 DepthManager statementDepth(&amp;m_statementDepth);
3557                 m_statementDepth = 1;
3558                 result = parseAsyncFunctionDeclaration(context, ExportType::Exported);
3559                 break;
3560             }
3561             FALLTHROUGH;
3562         default:
3563             failWithMessage(&quot;Expected either a declaration or a variable statement&quot;);
3564             break;
3565         }
3566 
3567         failIfFalse(result, &quot;Cannot parse the declaration&quot;);
3568         return context.createExportLocalDeclaration(exportLocation, result);
3569     }
3570     }
3571 
3572     RELEASE_ASSERT_NOT_REACHED();
3573     return 0;
</pre>
<hr />
<pre>
3614 
3615 template &lt;typename LexerType&gt;
3616 template &lt;typename TreeBuilder&gt; TreeExpression Parser&lt;LexerType&gt;::parseAssignmentExpression(TreeBuilder&amp; context)
3617 {
3618     ExpressionErrorClassifier classifier(this);
3619     return parseAssignmentExpression(context, classifier);
3620 }
3621 
3622 
3623 template &lt;typename LexerType&gt;
3624 template &lt;typename TreeBuilder&gt; NEVER_INLINE const char* Parser&lt;LexerType&gt;::metaPropertyName(TreeBuilder&amp; context, TreeExpression expr)
3625 {
3626     if (context.isNewTarget(expr))
3627         return &quot;new.target&quot;;
3628     if (context.isImportMeta(expr))
3629         return &quot;import.meta&quot;;
3630     RELEASE_ASSERT_NOT_REACHED();
3631     return &quot;error&quot;;
3632 }
3633 








3634 template &lt;typename LexerType&gt;
3635 template &lt;typename TreeBuilder&gt; TreeExpression Parser&lt;LexerType&gt;::parseAssignmentExpression(TreeBuilder&amp; context, ExpressionErrorClassifier&amp; classifier)
3636 {
3637     ASSERT(!hasError());
3638 
3639     failIfStackOverflow();
3640 
3641     if (match(YIELD) &amp;&amp; !isYIELDMaskedAsIDENT(currentScope()-&gt;isGenerator()))
3642         return parseYieldExpression(context);
3643 
3644     JSTextPosition start = tokenStartPosition();
3645     JSTokenLocation location(tokenLocation());
3646     int initialAssignmentCount = m_parserState.assignmentCount;
3647     int initialNonLHSCount = m_parserState.nonLHSCount;
3648     bool maybeAssignmentPattern = match(OPENBRACE) || match(OPENBRACKET);
3649     bool wasOpenParen = match(OPENPAREN);
3650     // Do not use matchSpecIdentifier() here since it is slower than isIdentifierOrKeyword.
3651     // Whether spec identifier is will be validated by isArrowFunctionParameters().
3652     bool wasIdentifierOrKeyword = isIdentifierOrKeyword(m_token);
3653     bool maybeValidArrowFunctionStart = wasOpenParen || wasIdentifierOrKeyword;
3654     SavePoint savePoint = createSavePoint();
3655     size_t usedVariablesSize = 0;
3656 
3657     if (wasOpenParen) {
3658         usedVariablesSize = currentScope()-&gt;currentUsedVariablesSize();
3659         currentScope()-&gt;pushUsedVariableSet();
3660     }
3661 
3662     TreeExpression lhs = parseConditionalExpression(context);
3663 
3664     if (maybeValidArrowFunctionStart &amp;&amp; !match(EOFTOK)) {
3665         bool isArrowFunctionToken = match(ARROWFUNCTION);
3666         if (!lhs || isArrowFunctionToken) {
3667             SavePointWithError errorRestorationSavePoint = createSavePointForError();
3668             restoreSavePoint(savePoint);
3669             bool isAsyncArrow = false;
3670             if (UNLIKELY(classifier.indicatesPossibleAsyncArrowFunction())) {
<span class="line-modified">3671                 if (matchContextualKeyword(m_vm-&gt;propertyNames-&gt;async)) {</span>
3672                     next();
3673                     isAsyncArrow = !m_lexer-&gt;hasLineTerminatorBeforeToken();
3674                 }
3675             }
3676             if (isArrowFunctionParameters()) {
3677                 if (wasOpenParen)
3678                     currentScope()-&gt;revertToPreviousUsedVariables(usedVariablesSize);
3679                 return parseArrowFunctionExpression(context, isAsyncArrow);
3680             }
3681             if (isArrowFunctionToken)
3682                 propagateError();
3683             restoreSavePointWithError(errorRestorationSavePoint);
3684             if (isArrowFunctionToken)
3685                 failDueToUnexpectedToken();
3686         }
3687     }
3688 
3689     if (!lhs &amp;&amp; (!maybeAssignmentPattern || !classifier.indicatesPossiblePattern()))
3690         propagateError();
3691 
</pre>
<hr />
<pre>
3719     while (true) {
3720         switch (m_token.m_type) {
3721         case EQUAL: op = OpEqual; break;
3722         case PLUSEQUAL: op = OpPlusEq; break;
3723         case MINUSEQUAL: op = OpMinusEq; break;
3724         case MULTEQUAL: op = OpMultEq; break;
3725         case DIVEQUAL: op = OpDivEq; break;
3726         case LSHIFTEQUAL: op = OpLShift; break;
3727         case RSHIFTEQUAL: op = OpRShift; break;
3728         case URSHIFTEQUAL: op = OpURShift; break;
3729         case ANDEQUAL: op = OpAndEq; break;
3730         case XOREQUAL: op = OpXOrEq; break;
3731         case OREQUAL: op = OpOrEq; break;
3732         case MODEQUAL: op = OpModEq; break;
3733         case POWEQUAL: op = OpPowEq; break;
3734         default:
3735             goto end;
3736         }
3737         m_parserState.nonTrivialExpressionCount++;
3738         hadAssignment = true;
<span class="line-modified">3739         if (UNLIKELY(context.isMetaProperty(lhs)))</span>
<span class="line-modified">3740             internalFailWithMessage(false, metaPropertyName(context, lhs), &quot; can&#39;t be the left hand side of an assignment expression&quot;);</span>
3741         context.assignmentStackAppend(assignmentStack, lhs, start, tokenStartPosition(), m_parserState.assignmentCount, op);
3742         start = tokenStartPosition();
3743         m_parserState.assignmentCount++;
3744         next(TreeBuilder::DontBuildStrings);
3745         if (strictMode() &amp;&amp; m_parserState.lastIdentifier &amp;&amp; context.isResolve(lhs)) {
<span class="line-modified">3746             failIfTrueIfStrict(m_vm-&gt;propertyNames-&gt;eval == *m_parserState.lastIdentifier, &quot;Cannot modify &#39;eval&#39; in strict mode&quot;);</span>
<span class="line-modified">3747             failIfTrueIfStrict(m_vm-&gt;propertyNames-&gt;arguments == *m_parserState.lastIdentifier, &quot;Cannot modify &#39;arguments&#39; in strict mode&quot;);</span>
3748             m_parserState.lastIdentifier = 0;
3749         }
3750         lhs = parseAssignmentExpression(context);
3751         failIfFalse(lhs, &quot;Cannot parse the right hand side of an assignment expression&quot;);
3752         if (initialNonLHSCount != m_parserState.nonLHSCount) {
3753             if (m_token.m_type &gt;= EQUAL &amp;&amp; m_token.m_type &lt;= OREQUAL)
3754                 semanticFail(&quot;Left hand side of operator &#39;&quot;, getToken(), &quot;&#39; must be a reference&quot;);
3755             break;
3756         }
3757     }
3758 end:
3759     if (hadAssignment)
3760         m_parserState.nonLHSCount++;
3761 
3762     if (!TreeBuilder::CreatesAST)
3763         return lhs;
3764 
3765     while (assignmentStack)
3766         lhs = context.createAssignment(location, assignmentStack, lhs, initialAssignmentCount, m_parserState.assignmentCount, lastTokenEndPosition());
3767 
</pre>
<hr />
<pre>
3844     if (isUpdateOp(token))
3845         return false;
3846     return isUnaryOp(token);
3847 }
3848 
3849 template &lt;typename LexerType&gt;
3850 int Parser&lt;LexerType&gt;::isBinaryOperator(JSTokenType token)
3851 {
3852     if (m_allowsIn)
3853         return token &amp; (BinaryOpTokenPrecedenceMask &lt;&lt; BinaryOpTokenAllowsInPrecedenceAdditionalShift);
3854     return token &amp; BinaryOpTokenPrecedenceMask;
3855 }
3856 
3857 template &lt;typename LexerType&gt;
3858 template &lt;class TreeBuilder&gt; TreeExpression Parser&lt;LexerType&gt;::parseBinaryExpression(TreeBuilder&amp; context)
3859 {
3860     int operandStackDepth = 0;
3861     int operatorStackDepth = 0;
3862     typename TreeBuilder::BinaryExprContext binaryExprContext(context);
3863     JSTokenLocation location(tokenLocation());



3864     while (true) {
3865         JSTextPosition exprStart = tokenStartPosition();
3866         int initialAssignments = m_parserState.assignmentCount;
3867         JSTokenType leadingTokenTypeForUnaryExpression = m_token.m_type;
3868         TreeExpression current = parseUnaryExpression(context);
3869         failIfFalse(current, &quot;Cannot parse expression&quot;);
3870 
3871         context.appendBinaryExpressionInfo(operandStackDepth, current, exprStart, lastTokenEndPosition(), lastTokenEndPosition(), initialAssignments != m_parserState.assignmentCount);



3872 
3873         // 12.6 https://tc39.github.io/ecma262/#sec-exp-operator
3874         // ExponentiationExpresion is described as follows.
3875         //
3876         //     ExponentiationExpression[Yield]:
3877         //         UnaryExpression[?Yield]
3878         //         UpdateExpression[?Yield] ** ExponentiationExpression[?Yield]
3879         //
3880         // As we can see, the left hand side of the ExponentiationExpression is UpdateExpression, not UnaryExpression.
3881         // So placing UnaryExpression not included in UpdateExpression here is a syntax error.
3882         // This is intentional. For example, if UnaryExpression is allowed, we can have the code like `-x**y`.
3883         // But this is confusing: `-(x**y)` OR `(-x)**y`, which interpretation is correct?
3884         // To avoid this problem, ECMA262 makes unparenthesized exponentiation expression as operand of unary operators an early error.
3885         // More rationale: https://mail.mozilla.org/pipermail/es-discuss/2015-September/044232.html
3886         //
3887         // Here, we guarantee that the left hand side of this expression is not unary expression by checking the leading operator of the parseUnaryExpression.
3888         // This check just works. Let&#39;s consider the example,
3889         //     y &lt;&gt; -x ** z
3890         //          ^
3891         //          Check this.
3892         // If the binary operator &lt;&gt; has higher precedence than one of &quot;**&quot;, this check does not work.
3893         // But it&#39;s OK for ** because the operator &quot;**&quot; has the highest operator precedence in the binary operators.
3894         failIfTrue(match(POW) &amp;&amp; isUnaryOpExcludingUpdateOp(leadingTokenTypeForUnaryExpression), &quot;Ambiguous unary expression in the left hand side of the exponentiation expression; parentheses must be used to disambiguate the expression&quot;);
3895 
<span class="line-modified">3896         int precedence = isBinaryOperator(m_token.m_type);</span>
<span class="line-modified">3897         if (!precedence)</span>
<span class="line-modified">3898             break;</span>





3899         m_parserState.nonTrivialExpressionCount++;
3900         m_parserState.nonLHSCount++;
3901         int operatorToken = m_token.m_type;
3902         next(TreeBuilder::DontBuildStrings);
3903 
3904         while (operatorStackDepth &amp;&amp; context.operatorStackShouldReduce(precedence)) {
3905             ASSERT(operandStackDepth &gt; 1);
3906 
3907             typename TreeBuilder::BinaryOperand rhs = context.getFromOperandStack(-1);
3908             typename TreeBuilder::BinaryOperand lhs = context.getFromOperandStack(-2);
3909             context.shrinkOperandStackBy(operandStackDepth, 2);
3910             context.appendBinaryOperation(location, operandStackDepth, operatorStackDepth, lhs, rhs);
3911             context.operatorStackPop(operatorStackDepth);
3912         }
3913         context.operatorStackAppend(operatorStackDepth, operatorToken, precedence);
3914     }
3915     while (operatorStackDepth) {
3916         ASSERT(operandStackDepth &gt; 1);
3917 
3918         typename TreeBuilder::BinaryOperand rhs = context.getFromOperandStack(-1);
3919         typename TreeBuilder::BinaryOperand lhs = context.getFromOperandStack(-2);
3920         context.shrinkOperandStackBy(operandStackDepth, 2);
3921         context.appendBinaryOperation(location, operandStackDepth, operatorStackDepth, lhs, rhs);
3922         context.operatorStackPop(operatorStackDepth);
3923     }
3924     return context.popOperandStack(operandStackDepth);
3925 }
3926 
3927 template &lt;typename LexerType&gt;
3928 template &lt;class TreeBuilder&gt; TreeProperty Parser&lt;LexerType&gt;::parseProperty(TreeBuilder&amp; context, bool complete)
3929 {
3930     SourceParseMode parseMode = SourceParseMode::MethodMode;
3931     bool wasIdent = false;
3932 
3933     if (consume(TIMES))
3934         parseMode = SourceParseMode::GeneratorWrapperMethodMode;
3935 
3936 parseProperty:
3937     switch (m_token.m_type) {
3938     case IDENT:
<span class="line-modified">3939         if (UNLIKELY(*m_token.m_data.ident == m_vm-&gt;propertyNames-&gt;async &amp;&amp; !m_token.m_data.escaped)) {</span>
3940             if (parseMode == SourceParseMode::MethodMode) {
3941                 SavePoint savePoint = createSavePoint();
3942                 next();
3943 
3944                 if (match(COLON) || match(OPENPAREN) || match(COMMA) || match(CLOSEBRACE)) {
3945                     restoreSavePoint(savePoint);
3946                     wasIdent = true;
3947                     goto namedProperty;
3948                 }
3949 
3950                 failIfTrue(m_lexer-&gt;hasLineTerminatorBeforeToken(), &quot;Expected a property name following keyword &#39;async&#39;&quot;);
3951                 if (UNLIKELY(consume(TIMES)))
3952                     parseMode = SourceParseMode::AsyncGeneratorWrapperMethodMode;
3953                 else
3954                     parseMode = SourceParseMode::AsyncMethodMode;
3955                 goto parseProperty;
3956             }
3957         }
3958         FALLTHROUGH;
3959     case YIELD:
3960     case AWAIT:
3961         wasIdent = true;
3962         FALLTHROUGH;
3963     case STRING: {
3964 namedProperty:
3965         const Identifier* ident = m_token.m_data.ident;
3966         unsigned getterOrSetterStartOffset = tokenStart();
3967         JSToken identToken = m_token;
3968 
<span class="line-modified">3969         if (complete || (wasIdent &amp;&amp; !isGeneratorMethodParseMode(parseMode)  &amp;&amp; (*ident == m_vm-&gt;propertyNames-&gt;get || *ident == m_vm-&gt;propertyNames-&gt;set)))</span>
3970             nextExpectIdentifier(LexerFlagsIgnoreReservedWords);
3971         else
3972             nextExpectIdentifier(LexerFlagsIgnoreReservedWords | TreeBuilder::DontBuildKeywords);
3973 
3974         if (!isGeneratorMethodParseMode(parseMode) &amp;&amp; !isAsyncMethodParseMode(parseMode) &amp;&amp; match(COLON)) {
3975             next();
3976             TreeExpression node = parseAssignmentExpressionOrPropagateErrorClass(context);
3977             failIfFalse(node, &quot;Cannot parse expression for property declaration&quot;);
3978             context.setEndOffset(node, m_lexer-&gt;currentOffset());
<span class="line-modified">3979             InferName inferName = ident &amp;&amp; *ident == m_vm-&gt;propertyNames-&gt;underscoreProto ? InferName::Disallowed : InferName::Allowed;</span>
3980             return context.createProperty(ident, node, PropertyNode::Constant, PropertyNode::Unknown, complete, SuperBinding::NotNeeded, inferName, ClassElementTag::No);
3981         }
3982 
3983         if (match(OPENPAREN)) {
3984             auto method = parsePropertyMethod(context, ident, parseMode);
3985             propagateError();
3986             return context.createProperty(ident, method, PropertyNode::Constant, PropertyNode::KnownDirect, complete, SuperBinding::Needed, InferName::Allowed, ClassElementTag::No);
3987         }
3988         failIfTrue(parseMode != SourceParseMode::MethodMode, &quot;Expected a parenthesis for argument list&quot;);
3989 
3990         failIfFalse(wasIdent, &quot;Expected an identifier as property name&quot;);
3991 
3992         if (match(COMMA) || match(CLOSEBRACE)) {
3993             semanticFailureDueToKeywordCheckingToken(identToken, &quot;shorthand property name&quot;);
3994             JSTextPosition start = tokenStartPosition();
3995             JSTokenLocation location(tokenLocation());
<span class="line-modified">3996             currentScope()-&gt;useVariable(ident, m_vm-&gt;propertyNames-&gt;eval == *ident);</span>
3997             if (currentScope()-&gt;isArrowFunction())
3998                 currentScope()-&gt;setInnerArrowFunctionUsesEval();
3999             TreeExpression node = context.createResolve(location, *ident, start, lastTokenEndPosition());
4000             return context.createProperty(ident, node, static_cast&lt;PropertyNode::Type&gt;(PropertyNode::Constant | PropertyNode::Shorthand), PropertyNode::KnownDirect, complete, SuperBinding::NotNeeded, InferName::Allowed, ClassElementTag::No);
4001         }
4002 
4003         if (match(EQUAL)) // CoverInitializedName is exclusive to BindingPattern and AssignmentPattern
4004             classifyExpressionError(ErrorIndicatesPattern);
4005 
4006         PropertyNode::Type type;
<span class="line-modified">4007         if (*ident == m_vm-&gt;propertyNames-&gt;get)</span>
4008             type = PropertyNode::Getter;
<span class="line-modified">4009         else if (*ident == m_vm-&gt;propertyNames-&gt;set)</span>
4010             type = PropertyNode::Setter;
4011         else
4012             failWithMessage(&quot;Expected a &#39;:&#39; following the property name &#39;&quot;, ident-&gt;impl(), &quot;&#39;&quot;);
4013         return parseGetterSetter(context, complete, type, getterOrSetterStartOffset, ConstructorKind::None, ClassElementTag::No);
4014     }
4015     case DOUBLE:
4016     case INTEGER: {
4017         double propertyName = m_token.m_data.doubleValue;
4018         next();
4019 
4020         if (match(OPENPAREN)) {
<span class="line-modified">4021             const Identifier&amp; ident = m_parserArena.identifierArena().makeNumericIdentifier(const_cast&lt;VM*&gt;(m_vm), propertyName);</span>
4022             auto method = parsePropertyMethod(context, &amp;ident, parseMode);
4023             propagateError();
4024             return context.createProperty(&amp;ident, method, PropertyNode::Constant, PropertyNode::Unknown, complete, SuperBinding::Needed, InferName::Allowed, ClassElementTag::No);
4025         }
4026         failIfTrue(parseMode != SourceParseMode::MethodMode, &quot;Expected a parenthesis for argument list&quot;);
4027 
4028         consumeOrFail(COLON, &quot;Expected &#39;:&#39; after property name&quot;);
4029         TreeExpression node = parseAssignmentExpression(context);
4030         failIfFalse(node, &quot;Cannot parse expression for property declaration&quot;);
4031         context.setEndOffset(node, m_lexer-&gt;currentOffset());
<span class="line-modified">4032         return context.createProperty(const_cast&lt;VM*&gt;(m_vm), m_parserArena, propertyName, node, PropertyNode::Constant, PropertyNode::Unknown, complete, SuperBinding::NotNeeded, ClassElementTag::No);</span>
4033     }
4034     case OPENBRACKET: {
4035         next();
4036         auto propertyName = parseAssignmentExpression(context);
4037         failIfFalse(propertyName, &quot;Cannot parse computed property name&quot;);
4038         handleProductionOrFail(CLOSEBRACKET, &quot;]&quot;, &quot;end&quot;, &quot;computed property name&quot;);
4039 
4040         if (match(OPENPAREN)) {
<span class="line-modified">4041             auto method = parsePropertyMethod(context, &amp;m_vm-&gt;propertyNames-&gt;nullIdentifier, parseMode);</span>
4042             propagateError();
4043             return context.createProperty(propertyName, method, static_cast&lt;PropertyNode::Type&gt;(PropertyNode::Constant | PropertyNode::Computed), PropertyNode::KnownDirect, complete, SuperBinding::Needed, ClassElementTag::No);
4044         }
4045         failIfTrue(parseMode != SourceParseMode::MethodMode, &quot;Expected a parenthesis for argument list&quot;);
4046 
4047         consumeOrFail(COLON, &quot;Expected &#39;:&#39; after property name&quot;);
4048         TreeExpression node = parseAssignmentExpression(context);
4049         failIfFalse(node, &quot;Cannot parse expression for property declaration&quot;);
4050         context.setEndOffset(node, m_lexer-&gt;currentOffset());
4051         return context.createProperty(propertyName, node, static_cast&lt;PropertyNode::Type&gt;(PropertyNode::Constant | PropertyNode::Computed), PropertyNode::Unknown, complete, SuperBinding::NotNeeded, ClassElementTag::No);
4052     }
4053     case DOTDOTDOT: {
4054         auto spreadLocation = m_token.m_location;
4055         auto start = m_token.m_startPosition;
4056         auto divot = m_token.m_endPosition;
4057         next();
4058         TreeExpression elem = parseAssignmentExpressionOrPropagateErrorClass(context);
4059         failIfFalse(elem, &quot;Cannot parse subject of a spread operation&quot;);
4060         auto node = context.createObjectSpreadExpression(spreadLocation, elem, start, divot, m_lastTokenEndPosition);
4061         return context.createProperty(node, PropertyNode::Spread, PropertyNode::Unknown, complete, SuperBinding::NotNeeded, ClassElementTag::No);
</pre>
<hr />
<pre>
4074     JSTokenLocation methodLocation(tokenLocation());
4075     unsigned methodStart = tokenStart();
4076     ParserFunctionInfo&lt;TreeBuilder&gt; methodInfo;
4077     methodInfo.name = methodName;
4078     failIfFalse((parseFunctionInfo(context, FunctionNameRequirements::Unnamed, parseMode, false, ConstructorKind::None, SuperBinding::Needed, methodStart, methodInfo, FunctionDefinitionType::Method)), &quot;Cannot parse this method&quot;);
4079     return context.createMethodDefinition(methodLocation, methodInfo);
4080 }
4081 
4082 template &lt;typename LexerType&gt;
4083 template &lt;class TreeBuilder&gt; TreeProperty Parser&lt;LexerType&gt;::parseGetterSetter(TreeBuilder&amp; context, bool strict, PropertyNode::Type type, unsigned getterOrSetterStartOffset,
4084     ConstructorKind constructorKind, ClassElementTag tag)
4085 {
4086     const Identifier* stringPropertyName = 0;
4087     double numericPropertyName = 0;
4088     TreeExpression computedPropertyName = 0;
4089 
4090     JSTokenLocation location(tokenLocation());
4091 
4092     if (matchSpecIdentifier() || match(STRING) || m_token.m_type &amp; KeywordTokenFlag) {
4093         stringPropertyName = m_token.m_data.ident;
<span class="line-modified">4094         semanticFailIfTrue(tag == ClassElementTag::Static &amp;&amp; *stringPropertyName == m_vm-&gt;propertyNames-&gt;prototype,</span>
4095             &quot;Cannot declare a static method named &#39;prototype&#39;&quot;);
<span class="line-modified">4096         semanticFailIfTrue(tag == ClassElementTag::Instance &amp;&amp; *stringPropertyName == m_vm-&gt;propertyNames-&gt;constructor,</span>
4097             &quot;Cannot declare a getter or setter named &#39;constructor&#39;&quot;);
4098         next();
4099     } else if (match(DOUBLE) || match(INTEGER)) {
4100         numericPropertyName = m_token.m_data.doubleValue;
4101         next();
4102     } else if (match(OPENBRACKET)) {
4103         next();
4104         computedPropertyName = parseAssignmentExpression(context);
4105         failIfFalse(computedPropertyName, &quot;Cannot parse computed property name&quot;);
4106         handleProductionOrFail(CLOSEBRACKET, &quot;]&quot;, &quot;end&quot;, &quot;computed property name&quot;);
4107     } else
4108         failDueToUnexpectedToken();
4109 
4110     ParserFunctionInfo&lt;TreeBuilder&gt; info;
4111     if (type &amp; PropertyNode::Getter) {
4112         failIfFalse(match(OPENPAREN), &quot;Expected a parameter list for getter definition&quot;);
4113         failIfFalse((parseFunctionInfo(context, FunctionNameRequirements::Unnamed, SourceParseMode::GetterMode, false, constructorKind, SuperBinding::Needed, getterOrSetterStartOffset, info, FunctionDefinitionType::Method)), &quot;Cannot parse getter definition&quot;);
4114     } else {
4115         failIfFalse(match(OPENPAREN), &quot;Expected a parameter list for setter definition&quot;);
4116         failIfFalse((parseFunctionInfo(context, FunctionNameRequirements::Unnamed, SourceParseMode::SetterMode, false, constructorKind, SuperBinding::Needed, getterOrSetterStartOffset, info, FunctionDefinitionType::Method)), &quot;Cannot parse setter definition&quot;);
4117     }
4118 
4119     if (stringPropertyName)
4120         return context.createGetterOrSetterProperty(location, type, strict, stringPropertyName, info, tag);
4121 
4122     if (computedPropertyName)
4123         return context.createGetterOrSetterProperty(location, static_cast&lt;PropertyNode::Type&gt;(type | PropertyNode::Computed), strict, computedPropertyName, info, tag);
4124 
<span class="line-modified">4125     return context.createGetterOrSetterProperty(const_cast&lt;VM*&gt;(m_vm), m_parserArena, location, type, strict, numericPropertyName, info, tag);</span>
4126 }
4127 
4128 template &lt;typename LexerType&gt;
4129 template &lt;class TreeBuilder&gt; bool Parser&lt;LexerType&gt;::shouldCheckPropertyForUnderscoreProtoDuplicate(TreeBuilder&amp; context, const TreeProperty&amp; property)
4130 {
4131     if (!context.getName(property))
4132         return false;
4133 
4134     // A Constant property that is not a Computed or Shorthand Constant property.
4135     return context.getType(property) == PropertyNode::Constant;
4136 }
4137 
4138 template &lt;typename LexerType&gt;
4139 void Parser&lt;LexerType&gt;::recordPauseLocation(const JSTextPosition&amp; position)
4140 {
4141     if (LIKELY(!m_debuggerParseData))
4142         return;
4143 
4144     if (position.line &lt; 0)
4145         return;
</pre>
<hr />
<pre>
4172     consumeOrFailWithFlags(OPENBRACE, TreeBuilder::DontBuildStrings, &quot;Expected opening &#39;{&#39; at the start of an object literal&quot;);
4173 
4174     int oldNonLHSCount = m_parserState.nonLHSCount;
4175 
4176     JSTokenLocation location(tokenLocation());
4177     if (match(CLOSEBRACE)) {
4178         next();
4179         return context.createObjectLiteral(location);
4180     }
4181 
4182     TreeProperty property = parseProperty(context, false);
4183     failIfFalse(property, &quot;Cannot parse object literal property&quot;);
4184 
4185     if (context.getType(property) &amp; (PropertyNode::Getter | PropertyNode::Setter)) {
4186         restoreSavePoint(savePoint);
4187         return parseStrictObjectLiteral(context);
4188     }
4189 
4190     bool seenUnderscoreProto = false;
4191     if (shouldCheckPropertyForUnderscoreProtoDuplicate(context, property))
<span class="line-modified">4192         seenUnderscoreProto = *context.getName(property) == m_vm-&gt;propertyNames-&gt;underscoreProto;</span>
4193 
4194     TreePropertyList propertyList = context.createPropertyList(location, property);
4195     TreePropertyList tail = propertyList;
4196     while (match(COMMA)) {
4197         next(TreeBuilder::DontBuildStrings);
4198         if (match(CLOSEBRACE))
4199             break;
4200         JSTokenLocation propertyLocation(tokenLocation());
4201         property = parseProperty(context, false);
4202         failIfFalse(property, &quot;Cannot parse object literal property&quot;);
4203         if (context.getType(property) &amp; (PropertyNode::Getter | PropertyNode::Setter)) {
4204             restoreSavePoint(savePoint);
4205             return parseStrictObjectLiteral(context);
4206         }
4207         if (shouldCheckPropertyForUnderscoreProtoDuplicate(context, property)) {
<span class="line-modified">4208             if (*context.getName(property) == m_vm-&gt;propertyNames-&gt;underscoreProto) {</span>
4209                 semanticFailIfTrue(seenUnderscoreProto, &quot;Attempted to redefine __proto__ property&quot;);
4210                 seenUnderscoreProto = true;
4211             }
4212         }
4213         tail = context.createPropertyList(propertyLocation, property, tail);
4214     }
4215 
4216     location = tokenLocation();
4217     handleProductionOrFail2(CLOSEBRACE, &quot;}&quot;, &quot;end&quot;, &quot;object literal&quot;);
4218 
4219     m_parserState.nonLHSCount = oldNonLHSCount;
4220 
4221     return context.createObjectLiteral(location, propertyList);
4222 }
4223 
4224 template &lt;typename LexerType&gt;
4225 template &lt;class TreeBuilder&gt; TreeExpression Parser&lt;LexerType&gt;::parseStrictObjectLiteral(TreeBuilder&amp; context)
4226 {
4227     consumeOrFail(OPENBRACE, &quot;Expected opening &#39;{&#39; at the start of an object literal&quot;);
4228 
4229     int oldNonLHSCount = m_parserState.nonLHSCount;
4230 
4231     JSTokenLocation location(tokenLocation());
4232     if (match(CLOSEBRACE)) {
4233         next();
4234         return context.createObjectLiteral(location);
4235     }
4236 
4237     TreeProperty property = parseProperty(context, true);
4238     failIfFalse(property, &quot;Cannot parse object literal property&quot;);
4239 
4240     bool seenUnderscoreProto = false;
4241     if (shouldCheckPropertyForUnderscoreProtoDuplicate(context, property))
<span class="line-modified">4242         seenUnderscoreProto = *context.getName(property) == m_vm-&gt;propertyNames-&gt;underscoreProto;</span>
4243 
4244     TreePropertyList propertyList = context.createPropertyList(location, property);
4245     TreePropertyList tail = propertyList;
4246     while (match(COMMA)) {
4247         next();
4248         if (match(CLOSEBRACE))
4249             break;
4250         JSTokenLocation propertyLocation(tokenLocation());
4251         property = parseProperty(context, true);
4252         failIfFalse(property, &quot;Cannot parse object literal property&quot;);
4253         if (shouldCheckPropertyForUnderscoreProtoDuplicate(context, property)) {
<span class="line-modified">4254             if (*context.getName(property) == m_vm-&gt;propertyNames-&gt;underscoreProto) {</span>
4255                 semanticFailIfTrue(seenUnderscoreProto, &quot;Attempted to redefine __proto__ property&quot;);
4256                 seenUnderscoreProto = true;
4257             }
4258         }
4259         tail = context.createPropertyList(propertyLocation, property, tail);
4260     }
4261 
4262     location = tokenLocation();
4263     handleProductionOrFail2(CLOSEBRACE, &quot;}&quot;, &quot;end&quot;, &quot;object literal&quot;);
4264 
4265     m_parserState.nonLHSCount = oldNonLHSCount;
4266 
4267     return context.createObjectLiteral(location, propertyList);
4268 }
4269 
4270 template &lt;typename LexerType&gt;
4271 template &lt;class TreeBuilder&gt; TreeExpression Parser&lt;LexerType&gt;::parseArrayLiteral(TreeBuilder&amp; context)
4272 {
4273     consumeOrFailWithFlags(OPENBRACKET, TreeBuilder::DontBuildStrings, &quot;Expected an opening &#39;[&#39; at the beginning of an array literal&quot;);
4274 
</pre>
<hr />
<pre>
4329         failIfFalse(elem, &quot;Cannot parse array literal element&quot;);
4330         tail = context.createElementList(tail, elisions, elem);
4331     }
4332 
4333     JSTokenLocation location(tokenLocation());
4334     if (!consume(CLOSEBRACKET)) {
4335         failIfFalse(match(DOTDOTDOT), &quot;Expected either a closing &#39;]&#39; or a &#39;,&#39; following an array element&quot;);
4336         semanticFail(&quot;The &#39;...&#39; operator should come before a target expression&quot;);
4337     }
4338 
4339     m_parserState.nonLHSCount = oldNonLHSCount;
4340 
4341     return context.createArray(location, elementList);
4342 }
4343 
4344 template &lt;typename LexerType&gt;
4345 template &lt;class TreeBuilder&gt; TreeClassExpression Parser&lt;LexerType&gt;::parseClassExpression(TreeBuilder&amp; context)
4346 {
4347     ASSERT(match(CLASSTOKEN));
4348     ParserClassInfo&lt;TreeBuilder&gt; info;
<span class="line-modified">4349     info.className = &amp;m_vm-&gt;propertyNames-&gt;nullIdentifier;</span>
4350     return parseClass(context, FunctionNameRequirements::None, info);
4351 }
4352 
4353 template &lt;typename LexerType&gt;
4354 template &lt;class TreeBuilder&gt; TreeExpression Parser&lt;LexerType&gt;::parseFunctionExpression(TreeBuilder&amp; context)
4355 {
4356     ASSERT(match(FUNCTION));
4357     JSTokenLocation location(tokenLocation());
4358     unsigned functionKeywordStart = tokenStart();
4359     next();
4360     ParserFunctionInfo&lt;TreeBuilder&gt; functionInfo;
<span class="line-modified">4361     functionInfo.name = &amp;m_vm-&gt;propertyNames-&gt;nullIdentifier;</span>
4362     SourceParseMode parseMode = SourceParseMode::NormalFunctionMode;
4363     if (consume(TIMES))
4364         parseMode = SourceParseMode::GeneratorWrapperFunctionMode;
4365     failIfFalse((parseFunctionInfo(context, FunctionNameRequirements::None, parseMode, false, ConstructorKind::None, SuperBinding::NotNeeded, functionKeywordStart, functionInfo, FunctionDefinitionType::Expression)), &quot;Cannot parse function expression&quot;);
4366     return context.createFunctionExpr(location, functionInfo);
4367 }
4368 
4369 template &lt;typename LexerType&gt;
4370 template &lt;class TreeBuilder&gt; TreeExpression Parser&lt;LexerType&gt;::parseAsyncFunctionExpression(TreeBuilder&amp; context)
4371 {
4372     ASSERT(match(FUNCTION));
4373     JSTokenLocation location(tokenLocation());
4374     unsigned functionKeywordStart = tokenStart();
4375     next();
4376     SourceParseMode parseMode = SourceParseMode::AsyncFunctionMode;
4377 
4378     if (consume(TIMES))
4379         parseMode = SourceParseMode::AsyncGeneratorWrapperFunctionMode;
4380 
4381     ParserFunctionInfo&lt;TreeBuilder&gt; functionInfo;
<span class="line-modified">4382     functionInfo.name = &amp;m_vm-&gt;propertyNames-&gt;nullIdentifier;</span>
4383     failIfFalse(parseFunctionInfo(context, FunctionNameRequirements::None, parseMode, false, ConstructorKind::None, SuperBinding::NotNeeded, functionKeywordStart, functionInfo, FunctionDefinitionType::Expression), parseMode == SourceParseMode::AsyncFunctionMode ? &quot;Cannot parse async function expression&quot; : &quot;Cannot parse async generator function expression&quot;);
4384     return context.createFunctionExpr(location, functionInfo);
4385 }
4386 
4387 template &lt;typename LexerType&gt;
4388 template &lt;class TreeBuilder&gt; typename TreeBuilder::TemplateString Parser&lt;LexerType&gt;::parseTemplateString(TreeBuilder&amp; context, bool isTemplateHead, typename LexerType::RawStringsBuildMode rawStringsBuildMode, bool&amp; elementIsTail)
4389 {
4390     if (isTemplateHead)
4391         ASSERT(match(BACKQUOTE));
4392     else
4393         matchOrFail(CLOSEBRACE, &quot;Expected a closing &#39;}&#39; following an expression in template literal&quot;);
4394 
4395     // Re-scan the token to recognize it as Template Element.
4396     m_token.m_type = m_lexer-&gt;scanTemplateString(&amp;m_token, rawStringsBuildMode);
4397     matchOrFail(TEMPLATE, &quot;Expected an template element&quot;);
4398     const Identifier* cooked = m_token.m_data.cooked;
4399     const Identifier* raw = m_token.m_data.raw;
4400     elementIsTail = m_token.m_data.isTail;
4401     JSTokenLocation location(tokenLocation());
4402     next();
</pre>
<hr />
<pre>
4474         TreeExpression result = parseExpression(context);
4475         m_parserState.nonLHSCount = oldNonLHSCount;
4476         handleProductionOrFail(CLOSEPAREN, &quot;)&quot;, &quot;end&quot;, &quot;compound expression&quot;);
4477         return result;
4478     }
4479     case THISTOKEN: {
4480         JSTokenLocation location(tokenLocation());
4481         next();
4482         if (currentScope()-&gt;isArrowFunction())
4483             currentScope()-&gt;setInnerArrowFunctionUsesThis();
4484         return context.createThisExpr(location);
4485     }
4486     case AWAIT:
4487         if (m_parserState.functionParsePhase == FunctionParsePhase::Parameters)
4488             failIfFalse(m_parserState.allowAwait, &quot;Cannot use await expression within parameters&quot;);
4489         else if (currentFunctionScope()-&gt;isAsyncFunctionBoundary())
4490             return parseAwaitExpression(context);
4491 
4492         goto identifierExpression;
4493     case IDENT: {
<span class="line-modified">4494         if (UNLIKELY(*m_token.m_data.ident == m_vm-&gt;propertyNames-&gt;async &amp;&amp; !m_token.m_data.escaped)) {</span>
4495             JSTextPosition start = tokenStartPosition();
4496             const Identifier* ident = m_token.m_data.ident;
4497             JSTokenLocation location(tokenLocation());
4498             next();
4499             if (match(FUNCTION) &amp;&amp; !m_lexer-&gt;hasLineTerminatorBeforeToken())
4500                 return parseAsyncFunctionExpression(context);
4501 
4502             // Avoid using variable if it is an arrow function parameter
4503             if (UNLIKELY(match(ARROWFUNCTION)))
4504                 return 0;
4505 
4506             const bool isEval = false;
4507             return createResolveAndUseVariable(context, ident, isEval, start, location);
4508         }
4509     identifierExpression:
4510         JSTextPosition start = tokenStartPosition();
4511         const Identifier* ident = m_token.m_data.ident;
4512         JSTokenLocation location(tokenLocation());
4513         next();
4514 
4515         // Avoid using variable if it is an arrow function parameter
4516         if (UNLIKELY(match(ARROWFUNCTION)))
4517             return 0;
4518 
<span class="line-modified">4519         return createResolveAndUseVariable(context, ident, *ident == m_vm-&gt;propertyNames-&gt;eval, start, location);</span>
4520     }
4521     case BIGINT: {
4522         const Identifier* ident = m_token.m_data.bigIntString;
4523         uint8_t radix = m_token.m_data.radix;
4524         JSTokenLocation location(tokenLocation());
4525         next();
4526         return context.createBigInt(location, ident, radix);
4527     }
4528     case STRING: {
4529         const Identifier* ident = m_token.m_data.ident;
4530         JSTokenLocation location(tokenLocation());
4531         next();
4532         return context.createString(location, ident);
4533     }
4534     case DOUBLE: {
4535         double d = m_token.m_data.doubleValue;
4536         JSTokenLocation location(tokenLocation());
4537         next();
4538         return context.createDoubleExpr(location, d);
4539     }
</pre>
<hr />
<pre>
4684     TreeExpression base = 0;
4685     JSTextPosition expressionStart = tokenStartPosition();
4686     int newCount = 0;
4687     JSTokenLocation startLocation = tokenLocation();
4688     JSTokenLocation lastNewTokenLocation;
4689     while (match(NEW)) {
4690         lastNewTokenLocation = tokenLocation();
4691         next();
4692         newCount++;
4693     }
4694     JSTokenLocation location = tokenLocation();
4695 
4696     bool baseIsSuper = match(SUPER);
4697     bool previousBaseWasSuper = false;
4698     bool baseIsImport = match(IMPORT);
4699     semanticFailIfTrue((baseIsSuper || baseIsImport) &amp;&amp; newCount, &quot;Cannot use new with &quot;, getToken());
4700 
4701     bool baseIsNewTarget = false;
4702     if (newCount &amp;&amp; match(DOT)) {
4703         next();
<span class="line-modified">4704         if (matchContextualKeyword(m_vm-&gt;propertyNames-&gt;target)) {</span>
4705             ScopeRef closestOrdinaryFunctionScope = closestParentOrdinaryFunctionNonLexicalScope();
4706             semanticFailIfFalse(currentScope()-&gt;isFunction() || closestOrdinaryFunctionScope-&gt;evalContextType() == EvalContextType::FunctionEvalContext, &quot;new.target is only valid inside functions&quot;);
4707             baseIsNewTarget = true;
4708             if (currentScope()-&gt;isArrowFunction()) {
4709                 semanticFailIfFalse(!closestOrdinaryFunctionScope-&gt;isGlobalCodeScope() || closestOrdinaryFunctionScope-&gt;evalContextType() == EvalContextType::FunctionEvalContext, &quot;new.target is not valid inside arrow functions in global code&quot;);
4710                 currentScope()-&gt;setInnerArrowFunctionUsesNewTarget();
4711             }
4712             ASSERT(lastNewTokenLocation.line);
4713             base = context.createNewTargetExpr(lastNewTokenLocation);
4714             newCount--;
4715             next();
4716         } else {
4717             failIfTrue(match(IDENT), &quot;\&quot;new.\&quot; can only followed with target&quot;);
4718             failDueToUnexpectedToken();
4719         }
4720     }
4721 
4722     bool baseIsAsyncKeyword = false;
4723 
4724     if (baseIsSuper) {
4725         ScopeRef closestOrdinaryFunctionScope = closestParentOrdinaryFunctionNonLexicalScope();
4726         semanticFailIfFalse(currentScope()-&gt;isFunction() || (closestOrdinaryFunctionScope-&gt;isEvalContext() &amp;&amp; closestOrdinaryFunctionScope-&gt;expectedSuperBinding() == SuperBinding::Needed), &quot;super is not valid in this context&quot;);
4727         base = context.createSuperExpr(location);
4728         next();
4729         ScopeRef functionScope = currentFunctionScope();
4730         if (!functionScope-&gt;setNeedsSuperBinding()) {
4731             // It unnecessary to check of using super during reparsing one more time. Also it can lead to syntax error
4732             // in case of arrow function because during reparsing we don&#39;t know whether we currently parse the arrow function
4733             // inside of the constructor or method.
4734             if (!m_lexer-&gt;isReparsingFunction()) {
4735                 SuperBinding functionSuperBinding = !functionScope-&gt;isArrowFunction() &amp;&amp; !closestOrdinaryFunctionScope-&gt;isEvalContext()
4736                     ? functionScope-&gt;expectedSuperBinding()
4737                     : closestOrdinaryFunctionScope-&gt;expectedSuperBinding();
4738                 semanticFailIfTrue(functionSuperBinding == SuperBinding::NotNeeded, &quot;super is not valid in this context&quot;);
4739             }
4740         }
4741     } else if (baseIsImport) {
4742         next();
4743         JSTextPosition expressionEnd = lastTokenEndPosition();
4744         if (consume(DOT)) {
<span class="line-modified">4745             if (matchContextualKeyword(m_vm-&gt;propertyNames-&gt;builtinNames().metaPublicName())) {</span>
4746                 semanticFailIfFalse(m_scriptMode == JSParserScriptMode::Module, &quot;import.meta is only valid inside modules&quot;);
<span class="line-modified">4747                 base = context.createImportMetaExpr(location, createResolveAndUseVariable(context, &amp;m_vm-&gt;propertyNames-&gt;metaPrivateName, false, expressionStart, location));</span>
4748                 next();
4749             } else {
4750                 failIfTrue(match(IDENT), &quot;\&quot;import.\&quot; can only followed with meta&quot;);
4751                 failDueToUnexpectedToken();
4752             }
4753         } else {
4754             consumeOrFail(OPENPAREN, &quot;import call expects exactly one argument&quot;);
4755             TreeExpression expr = parseAssignmentExpression(context);
4756             failIfFalse(expr, &quot;Cannot parse expression&quot;);
4757             consumeOrFail(CLOSEPAREN, &quot;import call expects exactly one argument&quot;);
4758             base = context.createImportExpr(location, expr, expressionStart, expressionEnd, lastTokenEndPosition());
4759         }
4760     } else if (!baseIsNewTarget) {
<span class="line-modified">4761         const bool isAsync = matchContextualKeyword(m_vm-&gt;propertyNames-&gt;async);</span>
4762 
4763         base = parsePrimaryExpression(context);
4764         failIfFalse(base, &quot;Cannot parse base expression&quot;);
4765         if (UNLIKELY(isAsync &amp;&amp; context.isResolve(base) &amp;&amp; !m_lexer-&gt;hasLineTerminatorBeforeToken())) {
4766             if (matchSpecIdentifier()) {
4767                 // AsyncArrowFunction
4768                 forceClassifyExpressionError(ErrorIndicatesAsyncArrowFunction);
4769                 failDueToUnexpectedToken();
4770             }
4771             baseIsAsyncKeyword = true;
4772         }
4773     }
4774 
4775     failIfFalse(base, &quot;Cannot parse base expression&quot;);
<span class="line-removed">4776     while (true) {</span>
<span class="line-removed">4777         location = tokenLocation();</span>
<span class="line-removed">4778         switch (m_token.m_type) {</span>
<span class="line-removed">4779         case OPENBRACKET: {</span>
<span class="line-removed">4780             m_parserState.nonTrivialExpressionCount++;</span>
<span class="line-removed">4781             JSTextPosition expressionEnd = lastTokenEndPosition();</span>
<span class="line-removed">4782             next();</span>
<span class="line-removed">4783             int nonLHSCount = m_parserState.nonLHSCount;</span>
<span class="line-removed">4784             int initialAssignments = m_parserState.assignmentCount;</span>
<span class="line-removed">4785             TreeExpression property = parseExpression(context);</span>
<span class="line-removed">4786             failIfFalse(property, &quot;Cannot parse subscript expression&quot;);</span>
<span class="line-removed">4787             base = context.createBracketAccess(startLocation, base, property, initialAssignments != m_parserState.assignmentCount, expressionStart, expressionEnd, tokenEndPosition());</span>
4788 
<span class="line-modified">4789             if (UNLIKELY(baseIsSuper &amp;&amp; currentScope()-&gt;isArrowFunction()))</span>
<span class="line-modified">4790                 currentFunctionScope()-&gt;setInnerArrowFunctionUsesSuperProperty();</span>








4791 
<span class="line-modified">4792             handleProductionOrFail(CLOSEBRACKET, &quot;]&quot;, &quot;end&quot;, &quot;subscript expression&quot;);</span>
<span class="line-modified">4793             m_parserState.nonLHSCount = nonLHSCount;</span>
<span class="line-modified">4794             break;</span>





4795         }
<span class="line-modified">4796         case OPENPAREN: {</span>
<span class="line-modified">4797             m_parserState.nonTrivialExpressionCount++;</span>
<span class="line-modified">4798             int nonLHSCount = m_parserState.nonLHSCount;</span>
<span class="line-modified">4799             if (newCount) {</span>
<span class="line-modified">4800                 newCount--;</span>
<span class="line-modified">4801                 JSTextPosition expressionEnd = lastTokenEndPosition();</span>
<span class="line-removed">4802                 TreeArguments arguments = parseArguments(context);</span>
<span class="line-removed">4803                 failIfFalse(arguments, &quot;Cannot parse call arguments&quot;);</span>
<span class="line-removed">4804                 base = context.createNewExpr(location, base, arguments, expressionStart, expressionEnd, lastTokenEndPosition());</span>
<span class="line-removed">4805             } else {</span>
<span class="line-removed">4806                 size_t usedVariablesSize = currentScope()-&gt;currentUsedVariablesSize();</span>
4807                 JSTextPosition expressionEnd = lastTokenEndPosition();
<span class="line-modified">4808                 Optional&lt;CallOrApplyDepthScope&gt; callOrApplyDepthScope;</span>
<span class="line-modified">4809                 recordCallOrApplyDepth&lt;TreeBuilder&gt;(this, *m_vm, callOrApplyDepthScope, base);</span>




4810 
<span class="line-modified">4811                 TreeArguments arguments = parseArguments(context);</span>

4812 
<span class="line-modified">4813                 if (baseIsAsyncKeyword &amp;&amp; (!arguments || match(ARROWFUNCTION))) {</span>
<span class="line-modified">4814                     currentScope()-&gt;revertToPreviousUsedVariables(usedVariablesSize);</span>
<span class="line-modified">4815                     forceClassifyExpressionError(ErrorIndicatesAsyncArrowFunction);</span>
<span class="line-modified">4816                     failDueToUnexpectedToken();</span>
<span class="line-modified">4817                 }</span>















4818 
<span class="line-modified">4819                 failIfFalse(arguments, &quot;Cannot parse call arguments&quot;);</span>
<span class="line-modified">4820                 if (baseIsSuper) {</span>
<span class="line-modified">4821                     ScopeRef functionScope = currentFunctionScope();</span>
<span class="line-modified">4822                     if (!functionScope-&gt;setHasDirectSuper()) {</span>
<span class="line-modified">4823                         // It unnecessary to check of using super during reparsing one more time. Also it can lead to syntax error</span>
<span class="line-modified">4824                         // in case of arrow function because during reparsing we don&#39;t know whether we currently parse the arrow function</span>
<span class="line-modified">4825                         // inside of the constructor or method.</span>
<span class="line-modified">4826                         if (!m_lexer-&gt;isReparsingFunction()) {</span>
<span class="line-modified">4827                             ScopeRef closestOrdinaryFunctionScope = closestParentOrdinaryFunctionNonLexicalScope();</span>
<span class="line-modified">4828                             ConstructorKind functionConstructorKind = !functionScope-&gt;isArrowFunction() &amp;&amp; !closestOrdinaryFunctionScope-&gt;isEvalContext()</span>
<span class="line-modified">4829                                 ? functionScope-&gt;constructorKind()</span>
<span class="line-modified">4830                                 : closestOrdinaryFunctionScope-&gt;constructorKind();</span>
<span class="line-modified">4831                             semanticFailIfTrue(functionConstructorKind == ConstructorKind::None, &quot;super is not valid in this context&quot;);</span>
<span class="line-modified">4832                             semanticFailIfTrue(functionConstructorKind != ConstructorKind::Extends, &quot;super is not valid in this context&quot;);</span>







4833                         }


4834                     }
<span class="line-modified">4835                     if (currentScope()-&gt;isArrowFunction())</span>
<span class="line-modified">4836                         functionScope-&gt;setInnerArrowFunctionUsesSuperCall();</span>





4837                 }
<span class="line-modified">4838                 base = context.makeFunctionCallNode(startLocation, base, previousBaseWasSuper, arguments, expressionStart,</span>
<span class="line-modified">4839                     expressionEnd, lastTokenEndPosition(), callOrApplyDepthScope ? callOrApplyDepthScope-&gt;distanceToInnermostChild() : 0);</span>
4840             }
<span class="line-modified">4841             m_parserState.nonLHSCount = nonLHSCount;</span>
<span class="line-modified">4842             break;</span>
<span class="line-modified">4843         }</span>
<span class="line-modified">4844         case DOT: {</span>
<span class="line-modified">4845             m_parserState.nonTrivialExpressionCount++;</span>
<span class="line-modified">4846             JSTextPosition expressionEnd = lastTokenEndPosition();</span>
<span class="line-modified">4847             nextExpectIdentifier(LexerFlagsIgnoreReservedWords | TreeBuilder::DontBuildKeywords);</span>
<span class="line-modified">4848             matchOrFail(IDENT, &quot;Expected a property name after &#39;.&#39;&quot;);</span>
<span class="line-modified">4849             base = context.createDotAccess(startLocation, base, m_token.m_data.ident, expressionStart, expressionEnd, tokenEndPosition());</span>
<span class="line-modified">4850             if (UNLIKELY(baseIsSuper &amp;&amp; currentScope()-&gt;isArrowFunction()))</span>
<span class="line-modified">4851                 currentFunctionScope()-&gt;setInnerArrowFunctionUsesSuperProperty();</span>
<span class="line-modified">4852             next();</span>
<span class="line-modified">4853             break;</span>
<span class="line-modified">4854         }</span>
<span class="line-modified">4855         case BACKQUOTE: {</span>
<span class="line-modified">4856             semanticFailIfTrue(baseIsSuper, &quot;Cannot use super as tag for tagged templates&quot;);</span>
<span class="line-modified">4857             JSTextPosition expressionEnd = lastTokenEndPosition();</span>
<span class="line-modified">4858             int nonLHSCount = m_parserState.nonLHSCount;</span>
<span class="line-modified">4859             typename TreeBuilder::TemplateLiteral templateLiteral = parseTemplateLiteral(context, LexerType::RawStringsBuildMode::BuildRawStrings);</span>
<span class="line-modified">4860             failIfFalse(templateLiteral, &quot;Cannot parse template literal&quot;);</span>
<span class="line-modified">4861             base = context.createTaggedTemplate(startLocation, base, templateLiteral, expressionStart, expressionEnd, lastTokenEndPosition());</span>
<span class="line-modified">4862             m_parserState.nonLHSCount = nonLHSCount;</span>
<span class="line-modified">4863             m_seenTaggedTemplate = true;</span>
<span class="line-modified">4864             break;</span>
<span class="line-modified">4865         }</span>
<span class="line-modified">4866         default:</span>
<span class="line-modified">4867             goto endMemberExpression;</span>


4868         }
<span class="line-modified">4869         previousBaseWasSuper = baseIsSuper;</span>
<span class="line-modified">4870         baseIsSuper = false;</span>
<span class="line-modified">4871     }</span>
<span class="line-modified">4872 endMemberExpression:</span>

4873     semanticFailIfTrue(baseIsSuper, &quot;super is not valid in this context&quot;);
4874     while (newCount--)
4875         base = context.createNewExpr(location, base, expressionStart, lastTokenEndPosition());
4876     return base;
4877 }
4878 
4879 template &lt;typename LexerType&gt;
4880 template &lt;class TreeBuilder&gt; TreeExpression Parser&lt;LexerType&gt;::parseArrowFunctionExpression(TreeBuilder&amp; context, bool isAsync)
4881 {
4882     JSTokenLocation location;
4883 
4884     unsigned functionKeywordStart = tokenStart();
4885     location = tokenLocation();
4886     ParserFunctionInfo&lt;TreeBuilder&gt; info;
<span class="line-modified">4887     info.name = &amp;m_vm-&gt;propertyNames-&gt;nullIdentifier;</span>
4888 
4889     SourceParseMode parseMode = isAsync ? SourceParseMode::AsyncArrowFunctionMode : SourceParseMode::ArrowFunctionMode;
4890     failIfFalse((parseFunctionInfo(context, FunctionNameRequirements::Unnamed, parseMode, true, ConstructorKind::None, SuperBinding::NotNeeded, functionKeywordStart, info, FunctionDefinitionType::Expression)), &quot;Cannot parse arrow function expression&quot;);
4891 
4892     return context.createArrowFunctionExpr(location, info);
4893 }
4894 
4895 static const char* operatorString(bool prefix, unsigned tok)
4896 {
4897     switch (tok) {
4898     case MINUSMINUS:
4899     case AUTOMINUSMINUS:
4900         return prefix ? &quot;prefix-decrement&quot; : &quot;decrement&quot;;
4901 
4902     case PLUSPLUS:
4903     case AUTOPLUSPLUS:
4904         return prefix ? &quot;prefix-increment&quot; : &quot;increment&quot;;
4905 
4906     case EXCLAMATION:
4907         return &quot;logical-not&quot;;
</pre>
<hr />
<pre>
4911 
4912     case TYPEOF:
4913         return &quot;typeof&quot;;
4914 
4915     case VOIDTOKEN:
4916         return &quot;void&quot;;
4917 
4918     case DELETETOKEN:
4919         return &quot;delete&quot;;
4920     }
4921     RELEASE_ASSERT_NOT_REACHED();
4922     return &quot;error&quot;;
4923 }
4924 
4925 template &lt;typename LexerType&gt;
4926 template &lt;class TreeBuilder&gt; TreeExpression Parser&lt;LexerType&gt;::parseUnaryExpression(TreeBuilder&amp; context)
4927 {
4928     typename TreeBuilder::UnaryExprContext unaryExprContext(context);
4929     AllowInOverride allowInOverride(this);
4930     int tokenStackDepth = 0;
<span class="line-modified">4931     bool modifiesExpr = false;</span>
<span class="line-removed">4932     bool requiresLExpr = false;</span>
4933     unsigned lastOperator = 0;
4934 
4935     if (UNLIKELY(match(AWAIT) &amp;&amp; currentFunctionScope()-&gt;isAsyncFunctionBoundary()))
4936         return parseAwaitExpression(context);
4937 
4938     JSTokenLocation location(tokenLocation());
4939 
4940     while (isUnaryOp(m_token.m_type)) {
<span class="line-modified">4941         if (strictMode()) {</span>
<span class="line-modified">4942             switch (m_token.m_type) {</span>
<span class="line-modified">4943             case PLUSPLUS:</span>
<span class="line-modified">4944             case MINUSMINUS:</span>
<span class="line-modified">4945             case AUTOPLUSPLUS:</span>
<span class="line-modified">4946             case AUTOMINUSMINUS:</span>
<span class="line-modified">4947                 semanticFailIfTrue(requiresLExpr, &quot;The &quot;, operatorString(true, lastOperator), &quot; operator requires a reference expression&quot;);</span>
<span class="line-modified">4948                 modifiesExpr = true;</span>
<span class="line-modified">4949                 requiresLExpr = true;</span>
<span class="line-modified">4950                 break;</span>
<span class="line-modified">4951             default:</span>
<span class="line-removed">4952                 semanticFailIfTrue(requiresLExpr, &quot;The &quot;, operatorString(true, lastOperator), &quot; operator requires a reference expression&quot;);</span>
<span class="line-removed">4953                 break;</span>
<span class="line-removed">4954             }</span>
4955         }
4956         lastOperator = m_token.m_type;
4957         m_parserState.nonLHSCount++;
4958         context.appendUnaryToken(tokenStackDepth, m_token.m_type, tokenStartPosition());
4959         next();
4960         m_parserState.nonTrivialExpressionCount++;
4961     }
4962     JSTextPosition subExprStart = tokenStartPosition();
4963     ASSERT(subExprStart.offset &gt;= subExprStart.lineStartOffset);
4964     TreeExpression expr = parseMemberExpression(context);
4965     if (!expr) {
4966         if (lastOperator)
4967             failWithMessage(&quot;Cannot parse subexpression of &quot;, operatorString(true, lastOperator), &quot;operator&quot;);
4968         failWithMessage(&quot;Cannot parse member expression&quot;);
4969     }
<span class="line-modified">4970     if (UNLIKELY(isUpdateOp(static_cast&lt;JSTokenType&gt;(lastOperator)) &amp;&amp; context.isMetaProperty(expr)))</span>
<span class="line-modified">4971         internalFailWithMessage(false, metaPropertyName(context, expr), &quot; can&#39;t come after a prefix operator&quot;);</span>


4972     bool isEvalOrArguments = false;
4973     if (strictMode()) {
4974         if (context.isResolve(expr))
<span class="line-modified">4975             isEvalOrArguments = *m_parserState.lastIdentifier == m_vm-&gt;propertyNames-&gt;eval || *m_parserState.lastIdentifier == m_vm-&gt;propertyNames-&gt;arguments;</span>
4976     }
<span class="line-modified">4977     failIfTrueIfStrict(isEvalOrArguments &amp;&amp; modifiesExpr, &quot;Cannot modify &#39;&quot;, m_parserState.lastIdentifier-&gt;impl(), &quot;&#39; in strict mode&quot;);</span>
4978     switch (m_token.m_type) {
4979     case PLUSPLUS:
<span class="line-modified">4980         if (UNLIKELY(context.isMetaProperty(expr)))</span>
<span class="line-modified">4981             internalFailWithMessage(false, metaPropertyName(context, expr), &quot; can&#39;t come before a postfix operator&quot;);</span>
4982         m_parserState.nonTrivialExpressionCount++;
4983         m_parserState.nonLHSCount++;
4984         expr = context.makePostfixNode(location, expr, OpPlusPlus, subExprStart, lastTokenEndPosition(), tokenEndPosition());
4985         m_parserState.assignmentCount++;
4986         failIfTrueIfStrict(isEvalOrArguments, &quot;Cannot modify &#39;&quot;, m_parserState.lastIdentifier-&gt;impl(), &quot;&#39; in strict mode&quot;);
<span class="line-modified">4987         semanticFailIfTrue(requiresLExpr, &quot;The &quot;, operatorString(false, lastOperator), &quot; operator requires a reference expression&quot;);</span>
<span class="line-removed">4988         lastOperator = PLUSPLUS;</span>
4989         next();
4990         break;
4991     case MINUSMINUS:
<span class="line-modified">4992         if (UNLIKELY(context.isMetaProperty(expr)))</span>
<span class="line-modified">4993             internalFailWithMessage(false, metaPropertyName(context, expr), &quot; can&#39;t come before a postfix operator&quot;);</span>
4994         m_parserState.nonTrivialExpressionCount++;
4995         m_parserState.nonLHSCount++;
4996         expr = context.makePostfixNode(location, expr, OpMinusMinus, subExprStart, lastTokenEndPosition(), tokenEndPosition());
4997         m_parserState.assignmentCount++;
4998         failIfTrueIfStrict(isEvalOrArguments, &quot;&#39;&quot;, m_parserState.lastIdentifier-&gt;impl(), &quot;&#39; cannot be modified in strict mode&quot;);
<span class="line-modified">4999         semanticFailIfTrue(requiresLExpr, &quot;The &quot;, operatorString(false, lastOperator), &quot; operator requires a reference expression&quot;);</span>
<span class="line-removed">5000         lastOperator = PLUSPLUS;</span>
5001         next();
5002         break;
5003     default:
5004         break;
5005     }
5006 
5007     JSTextPosition end = lastTokenEndPosition();
<span class="line-removed">5008 </span>
<span class="line-removed">5009     if (!TreeBuilder::CreatesAST &amp;&amp; (!strictMode()))</span>
<span class="line-removed">5010         return expr;</span>
<span class="line-removed">5011 </span>
5012     while (tokenStackDepth) {
5013         switch (context.unaryTokenStackLastType(tokenStackDepth)) {
5014         case EXCLAMATION:
5015             expr = context.createLogicalNot(location, expr);
5016             break;
5017         case TILDE:
5018             expr = context.makeBitwiseNotNode(location, expr);
5019             break;
5020         case MINUS:
5021             expr = context.makeNegateNode(location, expr);
5022             break;
5023         case PLUS:
5024             expr = context.createUnaryPlus(location, expr);
5025             break;
5026         case PLUSPLUS:
5027         case AUTOPLUSPLUS:
5028             expr = context.makePrefixNode(location, expr, OpPlusPlus, context.unaryTokenStackLastStart(tokenStackDepth), subExprStart + 1, end);
5029             m_parserState.assignmentCount++;
5030             break;
5031         case MINUSMINUS:
</pre>
</td>
<td>
<hr />
<pre>
  71     if (strictMode() &amp;&amp; token.m_type == RESERVED_IF_STRICT) \
  72         semanticFail(&quot;Cannot use the reserved word &#39;&quot;, getToken(token), &quot;&#39; as a &quot;, __VA_ARGS__, &quot; in strict mode&quot;); \
  73     if (token.m_type == RESERVED || token.m_type == RESERVED_IF_STRICT) \
  74         semanticFail(&quot;Cannot use the reserved word &#39;&quot;, getToken(token), &quot;&#39; as a &quot;, __VA_ARGS__); \
  75     if (token.m_type &amp; KeywordTokenFlag) { \
  76         if (!isAnyContextualKeyword(token)) \
  77             semanticFail(&quot;Cannot use the keyword &#39;&quot;, getToken(token), &quot;&#39; as a &quot;, __VA_ARGS__); \
  78         if (isDisallowedIdentifierLet(token)) \
  79             semanticFail(&quot;Cannot use &#39;let&#39; as a &quot;, __VA_ARGS__, &quot; &quot;, disallowedIdentifierLetReason()); \
  80         if (isDisallowedIdentifierAwait(token)) \
  81             semanticFail(&quot;Cannot use &#39;await&#39; as a &quot;, __VA_ARGS__, &quot; &quot;, disallowedIdentifierAwaitReason()); \
  82         if (isDisallowedIdentifierYield(token)) \
  83             semanticFail(&quot;Cannot use &#39;yield&#39; as a &quot;, __VA_ARGS__, &quot; &quot;, disallowedIdentifierYieldReason()); \
  84     } \
  85 } while (0)
  86 
  87 #define semanticFailureDueToKeyword(...) semanticFailureDueToKeywordCheckingToken(m_token, __VA_ARGS__);
  88 
  89 namespace JSC {
  90 
<span class="line-added">  91 std::atomic&lt;unsigned&gt; globalParseCount { 0 };</span>
<span class="line-added">  92 </span>
  93 ALWAYS_INLINE static SourceParseMode getAsynFunctionBodyParseMode(SourceParseMode parseMode)
  94 {
  95     if (isAsyncGeneratorWrapperParseMode(parseMode))
  96         return SourceParseMode::AsyncGeneratorBodyMode;
  97 
  98     if (parseMode == SourceParseMode::AsyncArrowFunctionMode)
  99         return SourceParseMode::AsyncArrowFunctionBodyMode;
 100 
 101     return SourceParseMode::AsyncFunctionBodyMode;
 102 }
 103 
 104 template &lt;typename LexerType&gt;
 105 void Parser&lt;LexerType&gt;::logError(bool)
 106 {
 107     if (hasError())
 108         return;
 109     StringPrintStream stream;
 110     printUnexpectedTokenText(stream);
 111     setErrorMessage(stream.toStringWithLatin1Fallback());
 112 }
 113 
 114 template &lt;typename LexerType&gt; template &lt;typename... Args&gt;
 115 void Parser&lt;LexerType&gt;::logError(bool shouldPrintToken, Args&amp;&amp;... args)
 116 {
 117     if (hasError())
 118         return;
 119     StringPrintStream stream;
 120     if (shouldPrintToken) {
 121         printUnexpectedTokenText(stream);
 122         stream.print(&quot;. &quot;);
 123     }
 124     stream.print(std::forward&lt;Args&gt;(args)..., &quot;.&quot;);
 125     setErrorMessage(stream.toStringWithLatin1Fallback());
 126 }
 127 
 128 template &lt;typename LexerType&gt;
<span class="line-modified"> 129 Parser&lt;LexerType&gt;::Parser(VM&amp; vm, const SourceCode&amp; source, JSParserBuiltinMode builtinMode, JSParserStrictMode strictMode, JSParserScriptMode scriptMode, SourceParseMode parseMode, SuperBinding superBinding, ConstructorKind defaultConstructorKind, DerivedContextType derivedContextType, bool isEvalContext, EvalContextType evalContextType, DebuggerParseData* debuggerParseData)</span>
 130     : m_vm(vm)
 131     , m_source(&amp;source)
 132     , m_hasStackOverflow(false)
 133     , m_allowsIn(true)
 134     , m_statementDepth(0)
 135     , m_sourceElements(0)
 136     , m_parsingBuiltin(builtinMode == JSParserBuiltinMode::Builtin)
 137     , m_scriptMode(scriptMode)
 138     , m_superBinding(superBinding)
 139     , m_defaultConstructorKind(defaultConstructorKind)
 140     , m_immediateParentAllowsFunctionDeclarationInStatement(false)
 141     , m_debuggerParseData(debuggerParseData)
 142 {
<span class="line-modified"> 143     m_lexer = makeUnique&lt;LexerType&gt;(vm, builtinMode, scriptMode);</span>
 144     m_lexer-&gt;setCode(source, &amp;m_parserArena);
 145     m_token.m_location.line = source.firstLine().oneBasedInt();
 146     m_token.m_location.startOffset = source.startOffset();
 147     m_token.m_location.endOffset = source.startOffset();
 148     m_token.m_location.lineStartOffset = source.startOffset();
<span class="line-modified"> 149     m_functionCache = vm.addSourceProviderCache(source.provider());</span>
 150     m_expressionErrorClassifier = nullptr;
 151 
 152     ScopeRef scope = pushScope();
 153     scope-&gt;setSourceParseMode(parseMode);
 154     scope-&gt;setIsEvalContext(isEvalContext);
 155     if (isEvalContext)
 156         scope-&gt;setEvalContextType(evalContextType);
 157 
 158     if (derivedContextType == DerivedContextType::DerivedConstructorContext) {
 159         scope-&gt;setConstructorKind(ConstructorKind::Extends);
 160         scope-&gt;setExpectedSuperBinding(SuperBinding::Needed);
 161     }
 162 
 163     if (derivedContextType == DerivedContextType::DerivedMethodContext)
 164         scope-&gt;setExpectedSuperBinding(SuperBinding::Needed);
 165 
 166     if (strictMode == JSParserStrictMode::Strict)
 167         scope-&gt;setStrictMode();
 168 
 169     if (isModuleParseMode(parseMode))
 170         m_moduleScopeData = ModuleScopeData::create();
 171 
 172     if (isProgramOrModuleParseMode(parseMode))
 173         scope-&gt;setIsGlobalCodeScope();
 174 
 175     next();
 176 }
 177 
<span class="line-modified"> 178 class Scope::MaybeParseAsGeneratorForScope {</span>
 179 public:
 180     MaybeParseAsGeneratorForScope(ScopeRef&amp; scope, bool shouldParseAsGenerator)
<span class="line-modified"> 181         : m_scope(scope)</span>
<span class="line-added"> 182         , m_oldValue(scope-&gt;m_isGenerator)</span>
<span class="line-added"> 183     {</span>
<span class="line-added"> 184         m_scope-&gt;m_isGenerator = shouldParseAsGenerator;</span>
<span class="line-added"> 185     }</span>
<span class="line-added"> 186 </span>
<span class="line-added"> 187     ~MaybeParseAsGeneratorForScope()</span>
<span class="line-added"> 188     {</span>
<span class="line-added"> 189         m_scope-&gt;m_isGenerator = m_oldValue;</span>
<span class="line-added"> 190     }</span>
<span class="line-added"> 191 </span>
<span class="line-added"> 192 private:</span>
<span class="line-added"> 193     ScopeRef m_scope;</span>
<span class="line-added"> 194     bool m_oldValue;</span>
 195 };
 196 
 197 struct DepthManager : private SetForScope&lt;int&gt; {
 198 public:
 199     DepthManager(int* depth)
 200         : SetForScope&lt;int&gt;(*depth, *depth)
 201     {
 202     }
 203 };
 204 
 205 template &lt;typename LexerType&gt;
 206 Parser&lt;LexerType&gt;::~Parser()
 207 {
 208 }
 209 
 210 template &lt;typename LexerType&gt;
 211 String Parser&lt;LexerType&gt;::parseInner(const Identifier&amp; calleeName, SourceParseMode parseMode, ParsingContext parsingContext, Optional&lt;int&gt; functionConstructorParametersEndPosition)
 212 {
 213     String parseError = String();
 214 
<span class="line-modified"> 215     ASTBuilder context(const_cast&lt;VM&amp;&gt;(m_vm), m_parserArena, const_cast&lt;SourceCode*&gt;(m_source));</span>
 216     ScopeRef scope = currentScope();
 217     scope-&gt;setIsLexicalScope();
 218     SetForScope&lt;FunctionParsePhase&gt; functionParsePhasePoisoner(m_parserState.functionParsePhase, FunctionParsePhase::Body);
 219 
 220     bool isArrowFunctionBodyExpression = parseMode == SourceParseMode::AsyncArrowFunctionBodyMode &amp;&amp; !match(OPENBRACE);
 221     if (m_lexer-&gt;isReparsingFunction()) {
 222         ParserFunctionInfo&lt;ASTBuilder&gt; functionInfo;
 223         if (isGeneratorOrAsyncFunctionBodyParseMode(parseMode))
 224             m_parameters = createGeneratorParameters(context, functionInfo.parameterCount);
 225         else
 226             m_parameters = parseFunctionParameters(context, parseMode, functionInfo);
 227 
 228         if (SourceParseModeSet(SourceParseMode::ArrowFunctionMode, SourceParseMode::AsyncArrowFunctionMode).contains(parseMode) &amp;&amp; !hasError()) {
 229             // The only way we could have an error wile reparsing is if we run out of stack space.
 230             RELEASE_ASSERT(match(ARROWFUNCTION));
 231             next();
 232             isArrowFunctionBodyExpression = !match(OPENBRACE);
 233         }
 234     }
 235 
</pre>
<hr />
<pre>
 259     }
 260 
 261     bool validEnding = consume(EOFTOK);
 262     if (!sourceElements || !validEnding) {
 263         if (hasError())
 264             parseError = m_errorMessage;
 265         else
 266             parseError = &quot;Parser error&quot;_s;
 267     }
 268 
 269     IdentifierSet capturedVariables;
 270     UniquedStringImplPtrSet sloppyModeHoistedFunctions;
 271     scope-&gt;getSloppyModeHoistedFunctions(sloppyModeHoistedFunctions);
 272     scope-&gt;getCapturedVars(capturedVariables);
 273 
 274     VariableEnvironment&amp; varDeclarations = scope-&gt;declaredVariables();
 275     for (auto&amp; entry : capturedVariables)
 276         varDeclarations.markVariableAsCaptured(entry);
 277 
 278     if (isGeneratorWrapperParseMode(parseMode) || isAsyncFunctionOrAsyncGeneratorWrapperParseMode(parseMode)) {
<span class="line-modified"> 279         if (scope-&gt;usedVariablesContains(m_vm.propertyNames-&gt;arguments.impl()))</span>
 280             context.propagateArgumentsUse();
 281     }
 282 
 283     CodeFeatures features = context.features();
 284     if (scope-&gt;strictMode())
 285         features |= StrictModeFeature;
 286     if (scope-&gt;shadowsArguments())
 287         features |= ShadowsArgumentsFeature;
 288     if (m_seenTaggedTemplate)
 289         features |= NoEvalCacheFeature;
 290 
 291 #ifndef NDEBUG
 292     if (m_parsingBuiltin &amp;&amp; isProgramParseMode(parseMode)) {
 293         VariableEnvironment&amp; lexicalVariables = scope-&gt;lexicalVariables();
 294         const HashSet&lt;UniquedStringImpl*&gt;&amp; closedVariableCandidates = scope-&gt;closedVariableCandidates();
 295         for (UniquedStringImpl* candidate : closedVariableCandidates) {
 296             // FIXME: We allow async to leak because it appearing as a closed variable is a side effect of trying to parse async arrow functions.
<span class="line-modified"> 297             if (!lexicalVariables.contains(candidate) &amp;&amp; !varDeclarations.contains(candidate) &amp;&amp; !candidate-&gt;isSymbol() &amp;&amp; candidate != m_vm.propertyNames-&gt;async.impl()) {</span>
 298                 dataLog(&quot;Bad global capture in builtin: &#39;&quot;, candidate, &quot;&#39;\n&quot;);
 299                 dataLog(m_source-&gt;view());
 300                 CRASH();
 301             }
 302         }
 303     }
 304 #endif // NDEBUG
 305     didFinishParsing(sourceElements, scope-&gt;takeFunctionDeclarations(), varDeclarations, WTFMove(sloppyModeHoistedFunctions), features, context.numConstants());
 306 
 307     return parseError;
 308 }
 309 
 310 template &lt;typename LexerType&gt;
 311 void Parser&lt;LexerType&gt;::didFinishParsing(SourceElements* sourceElements, DeclarationStacks::FunctionStack&amp;&amp; funcStack,
 312     VariableEnvironment&amp; varDeclarations, UniquedStringImplPtrSet&amp;&amp; sloppyModeHoistedFunctions, CodeFeatures features, int numConstants)
 313 {
 314     m_sourceElements = sourceElements;
 315     m_funcDeclarations = WTFMove(funcStack);
 316     m_varDeclarations.swap(varDeclarations);
 317     m_features = features;
 318     m_sloppyModeHoistedFunctions = WTFMove(sloppyModeHoistedFunctions);
 319     m_numConstants = numConstants;
 320 }
 321 
 322 template &lt;typename LexerType&gt;
 323 bool Parser&lt;LexerType&gt;::isArrowFunctionParameters()
 324 {
 325     if (match(OPENPAREN)) {
 326         SavePoint saveArrowFunctionPoint = createSavePoint();
 327         next();
 328         bool isArrowFunction = false;
 329         if (match(CLOSEPAREN)) {
 330             next();
 331             isArrowFunction = match(ARROWFUNCTION);
 332         } else {
<span class="line-modified"> 333             SyntaxChecker syntaxChecker(const_cast&lt;VM&amp;&gt;(m_vm), m_lexer.get());</span>
 334             // We make fake scope, otherwise parseFormalParameters will add variable to current scope that lead to errors
 335             AutoPopScopeRef fakeScope(this, pushScope());
 336             fakeScope-&gt;setSourceParseMode(SourceParseMode::ArrowFunctionMode);
 337 
 338             unsigned parametersCount = 0;
 339             bool isArrowFunctionParameterList = true;
 340             bool isMethod = false;
 341             isArrowFunction = parseFormalParameters(syntaxChecker, syntaxChecker.createFormalParameterList(), isArrowFunctionParameterList, isMethod, parametersCount) &amp;&amp; consume(CLOSEPAREN) &amp;&amp; match(ARROWFUNCTION);
 342             propagateError();
 343             popScope(fakeScope, syntaxChecker.NeedsFreeVariableInfo);
 344         }
 345         restoreSavePoint(saveArrowFunctionPoint);
 346         return isArrowFunction;
 347     }
 348 
 349     if (matchSpecIdentifier()) {
 350         SavePoint saveArrowFunctionPoint = createSavePoint();
 351         next();
 352         bool isArrowFunction = match(ARROWFUNCTION);
 353         restoreSavePoint(saveArrowFunctionPoint);
</pre>
<hr />
<pre>
 360 template &lt;typename LexerType&gt;
 361 bool Parser&lt;LexerType&gt;::allowAutomaticSemicolon()
 362 {
 363     return match(CLOSEBRACE) || match(EOFTOK) || m_lexer-&gt;hasLineTerminatorBeforeToken();
 364 }
 365 
 366 template &lt;typename LexerType&gt;
 367 template &lt;class TreeBuilder&gt; TreeSourceElements Parser&lt;LexerType&gt;::parseSourceElements(TreeBuilder&amp; context, SourceElementsMode mode)
 368 {
 369     const unsigned lengthOfUseStrictLiteral = 12; // &quot;use strict&quot;.length
 370     TreeSourceElements sourceElements = context.createSourceElements();
 371     const Identifier* directive = 0;
 372     unsigned directiveLiteralLength = 0;
 373     auto savePoint = createSavePoint();
 374     bool shouldCheckForUseStrict = mode == CheckForStrictMode;
 375 
 376     while (TreeStatement statement = parseStatementListItem(context, directive, &amp;directiveLiteralLength)) {
 377         if (shouldCheckForUseStrict) {
 378             if (directive) {
 379                 // &quot;use strict&quot; must be the exact literal without escape sequences or line continuation.
<span class="line-modified"> 380                 if (directiveLiteralLength == lengthOfUseStrictLiteral &amp;&amp; m_vm.propertyNames-&gt;useStrictIdentifier == *directive) {</span>
 381                     setStrictMode();
 382                     shouldCheckForUseStrict = false; // We saw &quot;use strict&quot;, there is no need to keep checking for it.
 383                     if (!isValidStrictMode()) {
 384                         if (m_parserState.lastFunctionName) {
<span class="line-modified"> 385                             if (m_vm.propertyNames-&gt;arguments == *m_parserState.lastFunctionName)</span>
 386                                 semanticFail(&quot;Cannot name a function &#39;arguments&#39; in strict mode&quot;);
<span class="line-modified"> 387                             if (m_vm.propertyNames-&gt;eval == *m_parserState.lastFunctionName)</span>
 388                                 semanticFail(&quot;Cannot name a function &#39;eval&#39; in strict mode&quot;);
 389                         }
<span class="line-modified"> 390                         if (hasDeclaredVariable(m_vm.propertyNames-&gt;arguments))</span>
 391                             semanticFail(&quot;Cannot declare a variable named &#39;arguments&#39; in strict mode&quot;);
<span class="line-modified"> 392                         if (hasDeclaredVariable(m_vm.propertyNames-&gt;eval))</span>
 393                             semanticFail(&quot;Cannot declare a variable named &#39;eval&#39; in strict mode&quot;);
 394                         semanticFailIfTrue(currentScope()-&gt;hasNonSimpleParameterList(), &quot;&#39;use strict&#39; directive not allowed inside a function with a non-simple parameter list&quot;);
 395                         semanticFailIfFalse(isValidStrictMode(), &quot;Invalid parameters or function name in strict mode&quot;);
 396                     }
 397                     // Since strict mode is changed, restoring lexer state by calling next() may cause errors.
 398                     restoreSavePoint(savePoint);
 399                     propagateError();
 400                     continue;
 401                 }
 402 
 403                 // We saw a directive, but it wasn&#39;t &quot;use strict&quot;. We reset our state to
 404                 // see if the next statement we parse is also a directive.
 405                 directive = nullptr;
 406             } else {
 407                 // We saw a statement that wasn&#39;t in the form of a directive. The spec says that &quot;use strict&quot;
 408                 // is only allowed as the first statement, or after a sequence of directives before it, but
 409                 // not after non-directive statements.
 410                 shouldCheckForUseStrict = false;
 411             }
 412         }
 413         context.appendStatement(sourceElements, statement);
 414     }
 415 
 416     propagateError();
 417     return sourceElements;
 418 }
 419 
 420 template &lt;typename LexerType&gt;
 421 template &lt;class TreeBuilder&gt; TreeSourceElements Parser&lt;LexerType&gt;::parseModuleSourceElements(TreeBuilder&amp; context, SourceParseMode parseMode)
 422 {
 423     TreeSourceElements sourceElements = context.createSourceElements();
<span class="line-modified"> 424     SyntaxChecker syntaxChecker(const_cast&lt;VM&amp;&gt;(m_vm), m_lexer.get());</span>
 425 
 426     while (true) {
 427         TreeStatement statement = 0;
 428         switch (m_token.m_type) {
 429         case EXPORT:
 430             statement = parseExportDeclaration(context);
 431             if (statement)
 432                 recordPauseLocation(context.breakpointLocation(statement));
 433             break;
 434 
 435         case IMPORT: {
 436             SavePoint savePoint = createSavePoint();
 437             next();
 438             bool isImportDeclaration = !match(OPENPAREN) &amp;&amp; !match(DOT);
 439             restoreSavePoint(savePoint);
 440             if (isImportDeclaration) {
 441                 statement = parseImportDeclaration(context);
 442                 if (statement)
 443                     recordPauseLocation(context.breakpointLocation(statement));
 444                 break;
</pre>
<hr />
<pre>
 483 
 484         semanticFail(&quot;Exported binding &#39;&quot;, uid.get(), &quot;&#39; needs to refer to a top-level declared variable&quot;);
 485     }
 486 
 487     return sourceElements;
 488 }
 489 
 490 template &lt;typename LexerType&gt;
 491 template &lt;class TreeBuilder&gt; TreeSourceElements Parser&lt;LexerType&gt;::parseGeneratorFunctionSourceElements(TreeBuilder&amp; context, const Identifier&amp; name, SourceElementsMode mode)
 492 {
 493     auto sourceElements = context.createSourceElements();
 494 
 495     unsigned functionKeywordStart = tokenStart();
 496     JSTokenLocation startLocation(tokenLocation());
 497     JSTextPosition start = tokenStartPosition();
 498     unsigned startColumn = tokenColumn();
 499     int functionNameStart = m_token.m_location.startOffset;
 500     int parametersStart = m_token.m_location.startOffset;
 501 
 502     ParserFunctionInfo&lt;TreeBuilder&gt; info;
<span class="line-modified"> 503     info.name = &amp;m_vm.propertyNames-&gt;nullIdentifier;</span>
 504     createGeneratorParameters(context, info.parameterCount);
 505     info.startOffset = parametersStart;
 506     info.startLine = tokenLine();
 507 
 508     {
 509         AutoPopScopeRef generatorBodyScope(this, pushScope());
 510         generatorBodyScope-&gt;setSourceParseMode(SourceParseMode::GeneratorBodyMode);
 511         generatorBodyScope-&gt;setConstructorKind(ConstructorKind::None);
 512         generatorBodyScope-&gt;setExpectedSuperBinding(m_superBinding);
 513 
<span class="line-modified"> 514         SyntaxChecker generatorFunctionContext(const_cast&lt;VM&amp;&gt;(m_vm), m_lexer.get());</span>
 515         failIfFalse(parseSourceElements(generatorFunctionContext, mode), &quot;Cannot parse the body of a generator&quot;);
 516         popScope(generatorBodyScope, TreeBuilder::NeedsFreeVariableInfo);
 517     }
 518     info.body = context.createFunctionMetadata(startLocation, tokenLocation(), startColumn, tokenColumn(), functionKeywordStart, functionNameStart, parametersStart, strictMode(), ConstructorKind::None, m_superBinding, info.parameterCount, SourceParseMode::GeneratorBodyMode, false);
 519 
 520     info.endLine = tokenLine();
 521     info.endOffset = m_token.m_data.offset;
 522     info.parametersStartColumn = startColumn;
 523 
 524     auto functionExpr = context.createGeneratorFunctionBody(startLocation, info, name);
 525     auto statement = context.createExprStatement(startLocation, functionExpr, start, m_lastTokenEndPosition.line);
 526     context.appendStatement(sourceElements, statement);
 527 
 528     return sourceElements;
 529 }
 530 
 531 template &lt;typename LexerType&gt;
 532 template &lt;class TreeBuilder&gt; TreeSourceElements Parser&lt;LexerType&gt;::parseAsyncFunctionSourceElements(TreeBuilder&amp; context, SourceParseMode parseMode, bool isArrowFunctionBodyExpression, SourceElementsMode mode)
 533 {
 534     ASSERT(isAsyncFunctionOrAsyncGeneratorWrapperParseMode(parseMode));
 535     auto sourceElements = context.createSourceElements();
 536 
 537     unsigned functionKeywordStart = tokenStart();
 538     JSTokenLocation startLocation(tokenLocation());
 539     JSTextPosition start = tokenStartPosition();
 540     unsigned startColumn = tokenColumn();
 541     int functionNameStart = m_token.m_location.startOffset;
 542     int parametersStart = m_token.m_location.startOffset;
 543 
 544     ParserFunctionInfo&lt;TreeBuilder&gt; info;
<span class="line-modified"> 545     info.name = &amp;m_vm.propertyNames-&gt;nullIdentifier;</span>
 546     createGeneratorParameters(context, info.parameterCount);
 547     info.startOffset = parametersStart;
 548     info.startLine = tokenLine();
 549 
 550     SourceParseMode innerParseMode = getAsynFunctionBodyParseMode(parseMode);
 551 
 552     {
 553         AutoPopScopeRef asyncFunctionBodyScope(this, pushScope());
 554         asyncFunctionBodyScope-&gt;setSourceParseMode(innerParseMode);
<span class="line-modified"> 555         SyntaxChecker syntaxChecker(const_cast&lt;VM&amp;&gt;(m_vm), m_lexer.get());</span>
 556         if (isArrowFunctionBodyExpression) {
 557             if (m_debuggerParseData)
 558                 failIfFalse(parseArrowFunctionSingleExpressionBodySourceElements(context), &quot;Cannot parse the body of async arrow function&quot;);
 559             else
 560                 failIfFalse(parseArrowFunctionSingleExpressionBodySourceElements(syntaxChecker), &quot;Cannot parse the body of async arrow function&quot;);
 561         } else {
 562             if (m_debuggerParseData)
 563                 failIfFalse(parseSourceElements(context, mode), &quot;Cannot parse the body of async function&quot;);
 564             else
 565                 failIfFalse(parseSourceElements(syntaxChecker, mode), &quot;Cannot parse the body of async function&quot;);
 566         }
 567         popScope(asyncFunctionBodyScope, TreeBuilder::NeedsFreeVariableInfo);
 568     }
 569     info.body = context.createFunctionMetadata(startLocation, tokenLocation(), startColumn, tokenColumn(), functionKeywordStart, functionNameStart, parametersStart, strictMode(), ConstructorKind::None, m_superBinding, info.parameterCount, innerParseMode, isArrowFunctionBodyExpression);
 570 
 571     info.endLine = tokenLine();
 572     info.endOffset = isArrowFunctionBodyExpression ? tokenLocation().endOffset : m_token.m_data.offset;
 573     info.parametersStartColumn = startColumn;
 574 
 575     auto functionExpr = context.createAsyncFunctionBody(startLocation, info, innerParseMode);
 576     auto statement = context.createExprStatement(startLocation, functionExpr, start, m_lastTokenEndPosition.line);
 577     context.appendStatement(sourceElements, statement);
 578 
 579     return sourceElements;
 580 }
 581 
 582 template &lt;typename LexerType&gt;
 583 template &lt;class TreeBuilder&gt; TreeSourceElements Parser&lt;LexerType&gt;::parseAsyncGeneratorFunctionSourceElements(TreeBuilder&amp; context, SourceParseMode parseMode, bool isArrowFunctionBodyExpression, SourceElementsMode mode)
 584 {
 585     ASSERT_UNUSED(parseMode, isAsyncGeneratorWrapperParseMode(parseMode));
 586     auto sourceElements = context.createSourceElements();
 587 
 588     unsigned functionKeywordStart = tokenStart();
 589     JSTokenLocation startLocation(tokenLocation());
 590     JSTextPosition start = tokenStartPosition();
 591     unsigned startColumn = tokenColumn();
 592     int functionNameStart = m_token.m_location.startOffset;
 593     int parametersStart = m_token.m_location.startOffset;
 594 
 595     ParserFunctionInfo&lt;TreeBuilder&gt; info;
<span class="line-modified"> 596     info.name = &amp;m_vm.propertyNames-&gt;nullIdentifier;</span>
 597     createGeneratorParameters(context, info.parameterCount);
 598     info.startOffset = parametersStart;
 599     info.startLine = tokenLine();
 600     SourceParseMode innerParseMode = SourceParseMode::AsyncGeneratorBodyMode;
 601     {
 602         AutoPopScopeRef asyncFunctionBodyScope(this, pushScope());
 603         asyncFunctionBodyScope-&gt;setSourceParseMode(innerParseMode);
<span class="line-modified"> 604         SyntaxChecker syntaxChecker(const_cast&lt;VM&amp;&gt;(m_vm), m_lexer.get());</span>
 605         if (isArrowFunctionBodyExpression) {
 606             if (m_debuggerParseData)
 607                 failIfFalse(parseArrowFunctionSingleExpressionBodySourceElements(context), &quot;Cannot parse the body of async arrow function&quot;);
 608             else
 609                 failIfFalse(parseArrowFunctionSingleExpressionBodySourceElements(syntaxChecker), &quot;Cannot parse the body of async arrow function&quot;);
 610         } else {
 611             if (m_debuggerParseData)
 612                 failIfFalse(parseSourceElements(context, mode), &quot;Cannot parse the body of async function&quot;);
 613             else
 614                 failIfFalse(parseSourceElements(syntaxChecker, mode), &quot;Cannot parse the body of async function&quot;);
 615         }
 616         popScope(asyncFunctionBodyScope, TreeBuilder::NeedsFreeVariableInfo);
 617     }
 618     info.body = context.createFunctionMetadata(startLocation, tokenLocation(), startColumn, tokenColumn(), functionKeywordStart, functionNameStart, parametersStart, strictMode(), ConstructorKind::None, m_superBinding, info.parameterCount, innerParseMode, isArrowFunctionBodyExpression);
 619 
 620     info.endLine = tokenLine();
 621     info.endOffset = isArrowFunctionBodyExpression ? tokenLocation().endOffset : m_token.m_data.offset;
 622     info.parametersStartColumn = startColumn;
 623 
 624     auto functionExpr = context.createAsyncFunctionBody(startLocation, info, innerParseMode);
 625     auto statement = context.createExprStatement(startLocation, functionExpr, start, m_lastTokenEndPosition.line);
 626     context.appendStatement(sourceElements, statement);
 627 
 628     return sourceElements;
 629 }
 630 
 631 template &lt;typename LexerType&gt;
 632 template &lt;class TreeBuilder&gt; TreeSourceElements Parser&lt;LexerType&gt;::parseSingleFunction(TreeBuilder&amp; context, Optional&lt;int&gt; functionConstructorParametersEndPosition)
 633 {
 634     TreeSourceElements sourceElements = context.createSourceElements();
 635     TreeStatement statement = 0;
 636     switch (m_token.m_type) {
 637     case FUNCTION:
 638         statement = parseFunctionDeclaration(context, ExportType::NotExported, DeclarationDefaultContext::Standard, functionConstructorParametersEndPosition);
 639         break;
 640     case IDENT:
<span class="line-modified"> 641         if (*m_token.m_data.ident == m_vm.propertyNames-&gt;async &amp;&amp; !m_token.m_data.escaped) {</span>
 642             next();
 643             failIfFalse(match(FUNCTION) &amp;&amp; !m_lexer-&gt;hasLineTerminatorBeforeToken(), &quot;Cannot parse the async function&quot;);
 644             statement = parseAsyncFunctionDeclaration(context, ExportType::NotExported, DeclarationDefaultContext::Standard, functionConstructorParametersEndPosition);
 645             break;
 646         }
 647         FALLTHROUGH;
 648     default:
 649         failDueToUnexpectedToken();
 650         break;
 651     }
 652 
 653     if (statement) {
 654         context.setEndOffset(statement, m_lastTokenEndPosition.offset);
 655         context.appendStatement(sourceElements, statement);
 656     }
 657 
 658     propagateError();
 659     return sourceElements;
 660 }
 661 
 662 
 663 template &lt;typename LexerType&gt;
 664 template &lt;class TreeBuilder&gt; TreeStatement Parser&lt;LexerType&gt;::parseStatementListItem(TreeBuilder&amp; context, const Identifier*&amp; directive, unsigned* directiveLiteralLength)
 665 {
 666     // The grammar is documented here:
 667     // http://www.ecma-international.org/ecma-262/6.0/index.html#sec-statements
 668     DepthManager statementDepth(&amp;m_statementDepth);
 669     m_statementDepth++;
<span class="line-added"> 670     failIfStackOverflow();</span>
 671     TreeStatement result = 0;
 672     bool shouldSetEndOffset = true;
 673     bool shouldSetPauseLocation = false;
 674 
 675     switch (m_token.m_type) {
 676     case CONSTTOKEN:
 677         result = parseVariableDeclaration(context, DeclarationType::ConstDeclaration);
 678         shouldSetPauseLocation = true;
 679         break;
 680     case LET: {
 681         bool shouldParseVariableDeclaration = true;
 682         if (!strictMode()) {
 683             SavePoint savePoint = createSavePoint();
 684             next();
 685             // Intentionally use `isIdentifierOrAnyContextualKeyword(m_token)` and don&#39;t use `matchSpecIdentifier()`.
 686             // We would like to fall into parseVariableDeclaration path even if &quot;yield&quot; is not treated as an Identifier.
 687             // For example, under a generator context, matchSpecIdentifier() for &quot;yield&quot; returns `false`.
 688             // But we would like to enter parseVariableDeclaration and raise an error under the context of parseVariableDeclaration
 689             // to raise consistent errors between &quot;var&quot;, &quot;const&quot; and &quot;let&quot;.
 690             if (!isIdentifierOrAnyContextualKeyword(m_token) &amp;&amp; !match(OPENBRACE) &amp;&amp; !match(OPENBRACKET))
 691                 shouldParseVariableDeclaration = false;
 692             restoreSavePoint(savePoint);
 693         }
 694         if (shouldParseVariableDeclaration)
 695             result = parseVariableDeclaration(context, DeclarationType::LetDeclaration);
 696         else {
 697             bool allowFunctionDeclarationAsStatement = true;
 698             result = parseExpressionOrLabelStatement(context, allowFunctionDeclarationAsStatement);
 699         }
 700         shouldSetPauseLocation = !context.shouldSkipPauseLocation(result);
 701         break;
 702     }
 703     case CLASSTOKEN:
 704         result = parseClassDeclaration(context);
 705         break;
 706     case FUNCTION:
 707         result = parseFunctionDeclaration(context);
 708         break;
 709     case IDENT:
<span class="line-modified"> 710         if (UNLIKELY(*m_token.m_data.ident == m_vm.propertyNames-&gt;async &amp;&amp; !m_token.m_data.escaped)) {</span>
 711             // Eagerly parse as AsyncFunctionDeclaration. This is the uncommon case,
 712             // but could be mistakenly parsed as an AsyncFunctionExpression.
 713             SavePoint savePoint = createSavePoint();
 714             next();
 715             if (UNLIKELY(match(FUNCTION) &amp;&amp; !m_lexer-&gt;hasLineTerminatorBeforeToken())) {
 716                 result = parseAsyncFunctionDeclaration(context);
 717                 break;
 718             }
 719             restoreSavePoint(savePoint);
 720         }
 721         FALLTHROUGH;
 722     case AWAIT:
 723     case YIELD: {
 724         // This is a convenient place to notice labeled statements
 725         // (even though we also parse them as normal statements)
 726         // because we allow the following type of code in sloppy mode:
 727         // ``` function foo() { label: function bar() { } } ```
 728         bool allowFunctionDeclarationAsStatement = true;
 729         result = parseExpressionOrLabelStatement(context, allowFunctionDeclarationAsStatement);
 730         shouldSetPauseLocation = !context.shouldSkipPauseLocation(result);
</pre>
<hr />
<pre>
 926         if (!m_lexer-&gt;isReparsingFunction() &amp;&amp; hasDeclaredParameter(name))
 927             semanticFail(&quot;Cannot declare a parameter named &#39;&quot;, name.impl(), &quot;&#39; in strict mode as it has already been declared&quot;);
 928         semanticFail(&quot;Cannot declare a parameter named &#39;&quot;, name.impl(), &quot;&#39; in strict mode&quot;);
 929     }
 930     if (declarationResult &amp; DeclarationResult::InvalidDuplicateDeclaration) {
 931         // It&#39;s not always an error to define a duplicate parameter.
 932         // It&#39;s only an error when there are default parameter values or destructuring parameters.
 933         // We note this value now so we can check it later.
 934         if (duplicateIdentifier)
 935             *duplicateIdentifier = &amp;name;
 936     }
 937 
 938     return true;
 939 }
 940 
 941 template &lt;typename LexerType&gt;
 942 template &lt;class TreeBuilder&gt; TreeDestructuringPattern Parser&lt;LexerType&gt;::createBindingPattern(TreeBuilder&amp; context, DestructuringKind kind, ExportType exportType, const Identifier&amp; name, JSToken token, AssignmentContext bindingContext, const Identifier** duplicateIdentifier)
 943 {
 944     ASSERT(!name.isNull());
 945 
<span class="line-modified"> 946     ASSERT(name.impl()-&gt;isAtom() || name.impl()-&gt;isSymbol());</span>
 947 
 948     switch (kind) {
 949     case DestructuringKind::DestructureToVariables: {
 950         DeclarationResultMask declarationResult = declareVariable(&amp;name);
 951         failIfTrueIfStrict(declarationResult &amp; DeclarationResult::InvalidStrictMode, &quot;Cannot declare a variable named &#39;&quot;, name.impl(), &quot;&#39; in strict mode&quot;);
 952         if (declarationResult &amp; DeclarationResult::InvalidDuplicateDeclaration)
 953             internalFailWithMessage(false, &quot;Cannot declare a var variable that shadows a let/const/class variable: &#39;&quot;, name.impl(), &quot;&#39;&quot;);
 954         break;
 955     }
 956 
 957     case DestructuringKind::DestructureToLet:
 958     case DestructuringKind::DestructureToConst:
 959     case DestructuringKind::DestructureToCatchParameters: {
 960         DeclarationResultMask declarationResult = declareVariable(&amp;name, kind == DestructuringKind::DestructureToConst ? DeclarationType::ConstDeclaration : DeclarationType::LetDeclaration);
 961         if (declarationResult != DeclarationResult::Valid) {
 962             failIfTrueIfStrict(declarationResult &amp; DeclarationResult::InvalidStrictMode, &quot;Cannot destructure to a variable named &#39;&quot;, name.impl(), &quot;&#39; in strict mode&quot;);
 963             failIfTrue(declarationResult &amp; DeclarationResult::InvalidDuplicateDeclaration, &quot;Cannot declare a lexical variable twice: &#39;&quot;, name.impl(), &quot;&#39;&quot;);
 964         }
 965         break;
 966     }
</pre>
<hr />
<pre>
1023 template &lt;typename LexerType&gt;
1024 template &lt;class TreeBuilder&gt; TreeDestructuringPattern Parser&lt;LexerType&gt;::parseBindingOrAssignmentElement(TreeBuilder&amp; context, DestructuringKind kind, ExportType exportType, const Identifier** duplicateIdentifier, bool* hasDestructuringPattern, AssignmentContext bindingContext, int depth)
1025 {
1026     if (kind == DestructuringKind::DestructureToExpressions)
1027         return parseAssignmentElement(context, kind, exportType, duplicateIdentifier, hasDestructuringPattern, bindingContext, depth);
1028     return parseDestructuringPattern(context, kind, exportType, duplicateIdentifier, hasDestructuringPattern, bindingContext, depth);
1029 }
1030 
1031 template &lt;typename LexerType&gt;
1032 template &lt;class TreeBuilder&gt; TreeDestructuringPattern Parser&lt;LexerType&gt;::parseObjectRestAssignmentElement(TreeBuilder&amp; context)
1033 {
1034     JSTextPosition startPosition = tokenStartPosition();
1035     auto element = parseMemberExpression(context);
1036 
1037     if (!element || !context.isAssignmentLocation(element)) {
1038         reclassifyExpressionError(ErrorIndicatesPattern, ErrorIndicatesNothing);
1039         semanticFail(&quot;Invalid destructuring assignment target&quot;);
1040     }
1041 
1042     if (strictMode() &amp;&amp; m_parserState.lastIdentifier &amp;&amp; context.isResolve(element)) {
<span class="line-modified">1043         bool isEvalOrArguments = m_vm.propertyNames-&gt;eval == *m_parserState.lastIdentifier || m_vm.propertyNames-&gt;arguments == *m_parserState.lastIdentifier;</span>
1044         if (isEvalOrArguments &amp;&amp; strictMode())
1045             reclassifyExpressionError(ErrorIndicatesPattern, ErrorIndicatesNothing);
1046         failIfTrueIfStrict(isEvalOrArguments, &quot;Cannot modify &#39;&quot;, m_parserState.lastIdentifier-&gt;impl(), &quot;&#39; in strict mode&quot;);
1047     }
1048 
1049     return createAssignmentElement(context, element, startPosition, lastTokenEndPosition());
1050 }
1051 
1052 template &lt;typename LexerType&gt;
1053 template &lt;class TreeBuilder&gt; TreeDestructuringPattern Parser&lt;LexerType&gt;::parseAssignmentElement(TreeBuilder&amp; context, DestructuringKind kind, ExportType exportType, const Identifier** duplicateIdentifier, bool* hasDestructuringPattern, AssignmentContext bindingContext, int depth)
1054 {
1055     TreeDestructuringPattern assignmentTarget = 0;
1056 
1057     if (match(OPENBRACE) || match(OPENBRACKET)) {
1058         SavePoint savePoint = createSavePoint();
1059         assignmentTarget = parseDestructuringPattern(context, kind, exportType, duplicateIdentifier, hasDestructuringPattern, bindingContext, depth);
1060         if (assignmentTarget &amp;&amp; !match(DOT) &amp;&amp; !match(OPENBRACKET) &amp;&amp; !match(OPENPAREN) &amp;&amp; !match(BACKQUOTE))
1061             return assignmentTarget;
1062         restoreSavePoint(savePoint);
1063     }
1064 
1065     JSTextPosition startPosition = tokenStartPosition();
1066     auto element = parseMemberExpression(context);
1067 
1068     semanticFailIfFalse(element &amp;&amp; context.isAssignmentLocation(element), &quot;Invalid destructuring assignment target&quot;);
1069 
1070     if (strictMode() &amp;&amp; m_parserState.lastIdentifier &amp;&amp; context.isResolve(element)) {
<span class="line-modified">1071         bool isEvalOrArguments = m_vm.propertyNames-&gt;eval == *m_parserState.lastIdentifier || m_vm.propertyNames-&gt;arguments == *m_parserState.lastIdentifier;</span>
1072         failIfTrueIfStrict(isEvalOrArguments, &quot;Cannot modify &#39;&quot;, m_parserState.lastIdentifier-&gt;impl(), &quot;&#39; in strict mode&quot;);
1073     }
1074 
1075     return createAssignmentElement(context, element, startPosition, lastTokenEndPosition());
1076 }
1077 
1078 static const char* destructuringKindToVariableKindName(DestructuringKind kind)
1079 {
1080     switch (kind) {
1081     case DestructuringKind::DestructureToLet:
1082     case DestructuringKind::DestructureToConst:
1083         return &quot;lexical variable name&quot;;
1084     case DestructuringKind::DestructureToVariables:
1085         return &quot;variable name&quot;;
1086     case DestructuringKind::DestructureToParameters:
1087         return &quot;parameter name&quot;;
1088     case DestructuringKind::DestructureToCatchParameters:
1089         return &quot;catch parameter name&quot;;
1090     case DestructuringKind::DestructureToExpressions:
1091         return &quot;expression name&quot;;
</pre>
<hr />
<pre>
1179         next();
1180 
1181         if (hasDestructuringPattern)
1182             *hasDestructuringPattern = true;
1183 
1184         bool restElementWasFound = false;
1185 
1186         do {
1187             bool wasString = false;
1188 
1189             if (match(CLOSEBRACE))
1190                 break;
1191 
1192             if (match(DOTDOTDOT)) {
1193                 JSTokenLocation location = m_token.m_location;
1194                 next();
1195                 auto innerPattern = parseObjectRestBindingOrAssignmentElement(context, kind, exportType, duplicateIdentifier, bindingContext);
1196                 propagateError();
1197                 if (!innerPattern)
1198                     return 0;
<span class="line-modified">1199                 context.appendObjectPatternRestEntry(m_vm, objectPattern, location, innerPattern);</span>
1200                 restElementWasFound = true;
1201                 context.setContainsObjectRestElement(objectPattern, restElementWasFound);
1202                 break;
1203             }
1204 
1205             const Identifier* propertyName = nullptr;
1206             TreeExpression propertyExpression = 0;
1207             TreeDestructuringPattern innerPattern = 0;
1208             JSTokenLocation location = m_token.m_location;
1209             if (matchSpecIdentifier()) {
1210                 failIfTrue(match(LET) &amp;&amp; (kind == DestructuringKind::DestructureToLet || kind == DestructuringKind::DestructureToConst), &quot;Cannot use &#39;let&#39; as an identifier name for a LexicalDeclaration&quot;);
1211                 propertyName = m_token.m_data.ident;
1212                 JSToken identifierToken = m_token;
1213                 next();
1214                 if (consume(COLON))
1215                     innerPattern = parseBindingOrAssignmentElement(context, kind, exportType, duplicateIdentifier, hasDestructuringPattern, bindingContext, depth + 1);
1216                 else {
1217                     if (kind == DestructuringKind::DestructureToExpressions) {
<span class="line-modified">1218                         bool isEvalOrArguments = m_vm.propertyNames-&gt;eval == *propertyName || m_vm.propertyNames-&gt;arguments == *propertyName;</span>
1219                         if (isEvalOrArguments &amp;&amp; strictMode())
1220                             reclassifyExpressionError(ErrorIndicatesPattern, ErrorIndicatesNothing);
1221                         failIfTrueIfStrict(isEvalOrArguments, &quot;Cannot modify &#39;&quot;, propertyName-&gt;impl(), &quot;&#39; in strict mode&quot;);
1222                     }
1223                     semanticFailIfTrue(isDisallowedIdentifierAwait(identifierToken), &quot;Cannot use &#39;await&#39; as a &quot;, destructuringKindToVariableKindName(kind), &quot; &quot;, disallowedIdentifierAwaitReason());
1224                     innerPattern = createBindingPattern(context, kind, exportType, *propertyName, identifierToken, bindingContext, duplicateIdentifier);
1225                 }
1226             } else {
1227                 JSTokenType tokenType = m_token.m_type;
1228                 switch (m_token.m_type) {
1229                 case DOUBLE:
1230                 case INTEGER:
<span class="line-modified">1231                     propertyName = &amp;m_parserArena.identifierArena().makeNumericIdentifier(const_cast&lt;VM&amp;&gt;(m_vm), m_token.m_data.doubleValue);</span>
1232                     break;
1233                 case STRING:
1234                     propertyName = m_token.m_data.ident;
1235                     wasString = true;
1236                     break;
1237                 case OPENBRACKET:
1238                     next();
1239                     propertyExpression = parseAssignmentExpression(context);
1240                     failIfFalse(propertyExpression, &quot;Cannot parse computed property name&quot;);
1241                     matchOrFail(CLOSEBRACKET, &quot;Expected &#39;]&#39; to end end a computed property name&quot;);
1242                     break;
1243                 default:
1244                     if (m_token.m_type != RESERVED &amp;&amp; m_token.m_type != RESERVED_IF_STRICT &amp;&amp; !(m_token.m_type &amp; KeywordTokenFlag)) {
1245                         if (kind == DestructuringKind::DestructureToExpressions)
1246                             return 0;
1247                         failWithMessage(&quot;Expected a property name&quot;);
1248                     }
1249                     propertyName = m_token.m_data.ident;
1250                     break;
1251                 }
1252                 next();
1253                 if (!consume(COLON)) {
1254                     if (kind == DestructuringKind::DestructureToExpressions)
1255                         return 0;
1256                     semanticFailIfTrue(tokenType == RESERVED, &quot;Cannot use abbreviated destructuring syntax for reserved name &#39;&quot;, propertyName-&gt;impl(), &quot;&#39;&quot;);
1257                     semanticFailIfTrue(tokenType == RESERVED_IF_STRICT, &quot;Cannot use abbreviated destructuring syntax for reserved name &#39;&quot;, propertyName-&gt;impl(), &quot;&#39; in strict mode&quot;);
1258                     semanticFailIfTrue(tokenType &amp; KeywordTokenFlag, &quot;Cannot use abbreviated destructuring syntax for keyword &#39;&quot;, propertyName-&gt;impl(), &quot;&#39;&quot;);
1259 
1260                     failWithMessage(&quot;Expected a &#39;:&#39; prior to a named destructuring property&quot;);
1261                 }
1262                 innerPattern = parseBindingOrAssignmentElement(context, kind, exportType, duplicateIdentifier, hasDestructuringPattern, bindingContext, depth + 1);
1263             }
1264             if (kind == DestructuringKind::DestructureToExpressions &amp;&amp; !innerPattern)
1265                 return 0;
1266             failIfFalse(innerPattern, &quot;Cannot parse this destructuring pattern&quot;);
1267             TreeExpression defaultValue = parseDefaultValueForDestructuringPattern(context);
1268             propagateError();
1269             if (propertyExpression) {
<span class="line-modified">1270                 context.appendObjectPatternEntry(m_vm, objectPattern, location, propertyExpression, innerPattern, defaultValue);</span>
1271                 context.setContainsComputedProperty(objectPattern, true);
1272             } else {
1273                 ASSERT(propertyName);
1274                 context.appendObjectPatternEntry(objectPattern, location, wasString, *propertyName, innerPattern, defaultValue);
1275             }
1276         } while (consume(COMMA));
1277 
1278         if (kind == DestructuringKind::DestructureToExpressions &amp;&amp; !match(CLOSEBRACE))
1279             return 0;
1280         consumeOrFail(CLOSEBRACE, restElementWasFound ? &quot;Expected a closing &#39;}&#39; following a rest element destructuring pattern&quot; : &quot;Expected either a closing &#39;}&#39; or an &#39;,&#39; after a property destructuring pattern&quot;);
1281         pattern = objectPattern;
1282         break;
1283     }
1284 
1285     default: {
1286         if (!matchSpecIdentifier()) {
1287             if (kind == DestructuringKind::DestructureToExpressions)
1288                 return 0;
1289             semanticFailureDueToKeyword(destructuringKindToVariableKindName(kind));
1290             failWithMessage(&quot;Expected a parameter pattern or a &#39;)&#39; in parameter list&quot;);
</pre>
<hr />
<pre>
1306     if (!match(EQUAL))
1307         return 0;
1308 
1309     next(TreeBuilder::DontBuildStrings); // consume &#39;=&#39;
1310     return parseAssignmentExpression(context);
1311 }
1312 
1313 template &lt;typename LexerType&gt;
1314 template &lt;class TreeBuilder&gt; TreeStatement Parser&lt;LexerType&gt;::parseForStatement(TreeBuilder&amp; context)
1315 {
1316     ASSERT(match(FOR));
1317     JSTokenLocation location(tokenLocation());
1318     int startLine = tokenLine();
1319     bool isAwaitFor = false;
1320     next();
1321 
1322     DepthManager statementDepth(&amp;m_statementDepth);
1323     m_statementDepth++;
1324 
1325     if (match(AWAIT)) {
<span class="line-modified">1326         semanticFailIfFalse(currentScope()-&gt;isAsyncFunction(), &quot;for-await-of can only be used in an async function or async generator&quot;);</span>
1327         isAwaitFor = true;
1328         next();
1329     }
1330 
1331     handleProductionOrFail(OPENPAREN, &quot;(&quot;, &quot;start&quot;, &quot;for-loop header&quot;);
1332     int nonLHSCount = m_parserState.nonLHSCount;
1333     int declarations = 0;
1334     JSTokenLocation declLocation(tokenLocation());
1335     JSTextPosition declsStart;
1336     JSTextPosition declsEnd;
1337     TreeExpression decls = 0;
1338     TreeDestructuringPattern pattern = 0;
1339     bool isVarDeclaraton = match(VAR);
1340     bool isLetDeclaration = match(LET);
1341     bool isConstDeclaration = match(CONSTTOKEN);
1342     bool forLoopConstDoesNotHaveInitializer = false;
1343 
1344     VariableEnvironment dummySet;
1345     VariableEnvironment* lexicalVariables = nullptr;
1346     AutoCleanupLexicalScope lexicalScope;
</pre>
<hr />
<pre>
1381         else if (isLetDeclaration)
1382             declarationType = DeclarationType::LetDeclaration;
1383         else if (isConstDeclaration)
1384             declarationType = DeclarationType::ConstDeclaration;
1385         else
1386             RELEASE_ASSERT_NOT_REACHED();
1387         decls = parseVariableDeclarationList(context, declarations, forInTarget, forInInitializer, declsStart, initStart, initEnd, ForLoopContext, declarationType, ExportType::NotExported, forLoopConstDoesNotHaveInitializer);
1388         m_allowsIn = true;
1389         propagateError();
1390 
1391         // Remainder of a standard for loop is handled identically
1392         if (match(SEMICOLON))
1393             goto standardForLoop;
1394 
1395         failIfFalse(declarations == 1, &quot;can only declare a single variable in an enumeration&quot;);
1396 
1397         // Handle for-in with var declaration
1398         JSTextPosition inLocation = tokenStartPosition();
1399         bool isOfEnumeration = false;
1400         if (!match(INTOKEN)) {
<span class="line-modified">1401             failIfFalse(matchContextualKeyword(m_vm.propertyNames-&gt;of), &quot;Expected either &#39;in&#39; or &#39;of&#39; in enumeration syntax&quot;);</span>
1402             isOfEnumeration = true;
1403             next();
1404         } else {
1405             failIfFalse(!isAwaitFor, &quot;Expected &#39;of&#39; in for-await syntax&quot;);
1406             next();
1407         }
1408 
1409         bool hasAnyAssignments = !!forInInitializer;
1410         if (hasAnyAssignments) {
1411             if (isOfEnumeration)
1412                 internalFailWithMessage(false, &quot;Cannot assign to the loop variable inside a for-of loop header&quot;);
1413             if (strictMode() || (isLetDeclaration || isConstDeclaration) || !context.isBindingNode(forInTarget))
1414                 internalFailWithMessage(false, &quot;Cannot assign to the loop variable inside a for-in loop header&quot;);
1415         }
1416         TreeExpression expr = parseExpression(context);
1417         failIfFalse(expr, &quot;Expected expression to enumerate&quot;);
1418         recordPauseLocation(context.breakpointLocation(expr));
1419         JSTextPosition exprEnd = lastTokenEndPosition();
1420 
1421         int endLine = tokenLine();
</pre>
<hr />
<pre>
1431         TreeStatement result;
1432         if (isOfEnumeration)
1433             result = context.createForOfLoop(isAwaitFor, location, forInTarget, expr, statement, declLocation, declsStart, inLocation, exprEnd, startLine, endLine, *lexicalVariables);
1434         else {
1435             ASSERT(!isAwaitFor);
1436             if (isVarDeclaraton &amp;&amp; forInInitializer)
1437                 result = context.createForInLoop(location, decls, expr, statement, declLocation, declsStart, inLocation, exprEnd, startLine, endLine, *lexicalVariables);
1438             else
1439                 result = context.createForInLoop(location, forInTarget, expr, statement, declLocation, declsStart, inLocation, exprEnd, startLine, endLine, *lexicalVariables);
1440         }
1441         popLexicalScopeIfNecessary();
1442         return result;
1443     }
1444 
1445     if (!match(SEMICOLON)) {
1446         if (match(OPENBRACE) || match(OPENBRACKET)) {
1447             SavePoint savePoint = createSavePoint();
1448             declsStart = tokenStartPosition();
1449             pattern = tryParseDestructuringPatternExpression(context, AssignmentContext::DeclarationStatement);
1450             declsEnd = lastTokenEndPosition();
<span class="line-modified">1451             if (pattern &amp;&amp; (match(INTOKEN) || matchContextualKeyword(m_vm.propertyNames-&gt;of)))</span>
1452                 goto enumerationLoop;
1453             pattern = TreeDestructuringPattern(0);
1454             restoreSavePoint(savePoint);
1455         }
1456         m_allowsIn = false;
1457         declsStart = tokenStartPosition();
1458         decls = parseExpression(context);
1459         declsEnd = lastTokenEndPosition();
1460         m_allowsIn = true;
1461         failIfFalse(decls, &quot;Cannot parse for loop declarations&quot;);
1462         recordPauseLocation(context.breakpointLocation(decls));
1463     }
1464 
1465     if (match(SEMICOLON)) {
1466     standardForLoop:
1467         failIfFalse(!isAwaitFor, &quot;Unexpected a &#39;;&#39; in for-await-of header&quot;);
1468         // Standard for loop
1469         if (decls)
1470             recordPauseLocation(context.breakpointLocation(decls));
1471         next();
</pre>
<hr />
<pre>
1486             recordPauseLocation(context.breakpointLocation(increment));
1487         }
1488         int endLine = tokenLine();
1489         handleProductionOrFail(CLOSEPAREN, &quot;)&quot;, &quot;end&quot;, &quot;for-loop header&quot;);
1490         const Identifier* unused = 0;
1491         startLoop();
1492         TreeStatement statement = parseStatement(context, unused);
1493         endLoop();
1494         failIfFalse(statement, &quot;Expected a statement as the body of a for loop&quot;);
1495         gatherLexicalVariablesIfNecessary();
1496         TreeStatement result = context.createForLoop(location, decls, condition, increment, statement, startLine, endLine, *lexicalVariables);
1497         popLexicalScopeIfNecessary();
1498         return result;
1499     }
1500 
1501     // For-in and For-of loop
1502 enumerationLoop:
1503     failIfFalse(nonLHSCount == m_parserState.nonLHSCount, &quot;Expected a reference on the left hand side of an enumeration statement&quot;);
1504     bool isOfEnumeration = false;
1505     if (!match(INTOKEN)) {
<span class="line-modified">1506         failIfFalse(matchContextualKeyword(m_vm.propertyNames-&gt;of), &quot;Expected either &#39;in&#39; or &#39;of&#39; in enumeration syntax&quot;);</span>
1507         isOfEnumeration = true;
1508         next();
1509     } else {
1510         failIfFalse(!isAwaitFor, &quot;Expected &#39;of&#39; in for-await syntax&quot;);
1511         next();
1512     }
1513 
1514     TreeExpression expr = parseExpression(context);
1515     failIfFalse(expr, &quot;Cannot parse subject for-&quot;, isOfEnumeration ? &quot;of&quot; : &quot;in&quot;, &quot; statement&quot;);
1516     recordPauseLocation(context.breakpointLocation(expr));
1517     JSTextPosition exprEnd = lastTokenEndPosition();
1518     int endLine = tokenLine();
1519 
1520     handleProductionOrFail(CLOSEPAREN, &quot;)&quot;, &quot;end&quot;, (isOfEnumeration ? &quot;for-of header&quot; : &quot;for-in header&quot;));
1521     const Identifier* unused = 0;
1522     startLoop();
1523     TreeStatement statement = parseStatement(context, unused);
1524     endLoop();
1525     failIfFalse(statement, &quot;Expected a statement as the body of a for-&quot;, isOfEnumeration ? &quot;of&quot; : &quot;in&quot;, &quot;loop&quot;);
1526     gatherLexicalVariablesIfNecessary();
</pre>
<hr />
<pre>
1541         result = context.createForOfLoop(isAwaitFor, location, decls, expr, statement, declLocation, declsStart, declsEnd, exprEnd, startLine, endLine, *lexicalVariables);
1542     else {
1543         ASSERT(!isAwaitFor);
1544         result = context.createForInLoop(location, decls, expr, statement, declLocation, declsStart, declsEnd, exprEnd, startLine, endLine, *lexicalVariables);
1545     }
1546     popLexicalScopeIfNecessary();
1547     return result;
1548 }
1549 
1550 template &lt;typename LexerType&gt;
1551 template &lt;class TreeBuilder&gt; TreeStatement Parser&lt;LexerType&gt;::parseBreakStatement(TreeBuilder&amp; context)
1552 {
1553     ASSERT(match(BREAK));
1554     JSTokenLocation location(tokenLocation());
1555     JSTextPosition start = tokenStartPosition();
1556     JSTextPosition end = tokenEndPosition();
1557     next();
1558 
1559     if (autoSemiColon()) {
1560         semanticFailIfFalse(breakIsValid(), &quot;&#39;break&#39; is only valid inside a switch or loop statement&quot;);
<span class="line-modified">1561         return context.createBreakStatement(location, &amp;m_vm.propertyNames-&gt;nullIdentifier, start, end);</span>
1562     }
1563     failIfFalse(matchSpecIdentifier(), &quot;Expected an identifier as the target for a break statement&quot;);
1564     const Identifier* ident = m_token.m_data.ident;
1565     semanticFailIfFalse(getLabel(ident), &quot;Cannot use the undeclared label &#39;&quot;, ident-&gt;impl(), &quot;&#39;&quot;);
1566     end = tokenEndPosition();
1567     next();
1568     failIfFalse(autoSemiColon(), &quot;Expected a &#39;;&#39; following a targeted break statement&quot;);
1569     return context.createBreakStatement(location, ident, start, end);
1570 }
1571 
1572 template &lt;typename LexerType&gt;
1573 template &lt;class TreeBuilder&gt; TreeStatement Parser&lt;LexerType&gt;::parseContinueStatement(TreeBuilder&amp; context)
1574 {
1575     ASSERT(match(CONTINUE));
1576     JSTokenLocation location(tokenLocation());
1577     JSTextPosition start = tokenStartPosition();
1578     JSTextPosition end = tokenEndPosition();
1579     next();
1580 
1581     if (autoSemiColon()) {
1582         semanticFailIfFalse(continueIsValid(), &quot;&#39;continue&#39; is only valid inside a loop statement&quot;);
<span class="line-modified">1583         return context.createContinueStatement(location, &amp;m_vm.propertyNames-&gt;nullIdentifier, start, end);</span>
1584     }
1585     failIfFalse(matchSpecIdentifier(), &quot;Expected an identifier as the target for a continue statement&quot;);
1586     const Identifier* ident = m_token.m_data.ident;
1587     ScopeLabelInfo* label = getLabel(ident);
1588     semanticFailIfFalse(label, &quot;Cannot use the undeclared label &#39;&quot;, ident-&gt;impl(), &quot;&#39;&quot;);
1589     semanticFailIfFalse(label-&gt;isLoop, &quot;Cannot continue to the label &#39;&quot;, ident-&gt;impl(), &quot;&#39; as it is not targeting a loop&quot;);
1590     end = tokenEndPosition();
1591     next();
1592     failIfFalse(autoSemiColon(), &quot;Expected a &#39;;&#39; following a targeted continue statement&quot;);
1593     return context.createContinueStatement(location, ident, start, end);
1594 }
1595 
1596 template &lt;typename LexerType&gt;
1597 template &lt;class TreeBuilder&gt; TreeStatement Parser&lt;LexerType&gt;::parseReturnStatement(TreeBuilder&amp; context)
1598 {
1599     ASSERT(match(RETURN));
1600     JSTokenLocation location(tokenLocation());
1601     semanticFailIfFalse(currentScope()-&gt;isFunction(), &quot;Return statements are only valid inside functions&quot;);
1602     JSTextPosition start = tokenStartPosition();
1603     JSTextPosition end = tokenEndPosition();
</pre>
<hr />
<pre>
1933         break;
1934     case TRY:
1935         result = parseTryStatement(context);
1936         break;
1937     case DEBUGGER:
1938         result = parseDebuggerStatement(context);
1939         shouldSetPauseLocation = true;
1940         break;
1941     case EOFTOK:
1942     case CASE:
1943     case CLOSEBRACE:
1944     case DEFAULT:
1945         // These tokens imply the end of a set of source elements
1946         return 0;
1947     case LET: {
1948         if (!strictMode())
1949             goto identcase;
1950         goto defaultCase;
1951     }
1952     case IDENT:
<span class="line-modified">1953         if (UNLIKELY(*m_token.m_data.ident == m_vm.propertyNames-&gt;async &amp;&amp; !m_token.m_data.escaped)) {</span>
1954             if (maybeParseAsyncFunctionDeclarationStatement(context, result, parentAllowsFunctionDeclarationAsStatement))
1955                 break;
1956         }
1957         FALLTHROUGH;
1958     case AWAIT:
1959     case YIELD: {
1960         identcase:
1961         bool allowFunctionDeclarationAsStatement = false;
1962         result = parseExpressionOrLabelStatement(context, allowFunctionDeclarationAsStatement);
1963         shouldSetPauseLocation = !context.shouldSkipPauseLocation(result);
1964         break;
1965     }
1966     case STRING:
1967         directive = m_token.m_data.ident;
1968         if (directiveLiteralLength)
1969             *directiveLiteralLength = m_token.m_location.endOffset - m_token.m_location.startOffset;
1970         nonTrivialExpressionCount = m_parserState.nonTrivialExpressionCount;
1971         FALLTHROUGH;
1972     default:
1973         defaultCase:
</pre>
<hr />
<pre>
2022     JSTokenLocation location(tokenLocation());
2023     int start = tokenLine();
2024 
2025     TreeStatement function = 0;
2026     if (!isAsync)
2027         function = parseFunctionDeclaration(context);
2028     else
2029         function = parseAsyncFunctionDeclaration(context);
2030     propagateError();
2031     failIfFalse(function, &quot;Expected valid function statement after &#39;function&#39; keyword&quot;);
2032     TreeSourceElements sourceElements = context.createSourceElements();
2033     context.appendStatement(sourceElements, function);
2034     TreeStatement result = context.createBlockStatement(location, sourceElements, start, m_lastTokenEndPosition.line, currentScope()-&gt;finalizeLexicalEnvironment(), currentScope()-&gt;takeFunctionDeclarations());
2035     popScope(blockScope, TreeBuilder::NeedsFreeVariableInfo);
2036     return result;
2037 }
2038 
2039 template &lt;typename LexerType&gt;
2040 template &lt;class TreeBuilder&gt; bool Parser&lt;LexerType&gt;::maybeParseAsyncFunctionDeclarationStatement(TreeBuilder&amp; context, TreeStatement&amp; result, bool parentAllowsFunctionDeclarationAsStatement)
2041 {
<span class="line-modified">2042     ASSERT(matchContextualKeyword(m_vm.propertyNames-&gt;async));</span>
2043     SavePoint savePoint = createSavePoint();
2044     next();
2045     if (match(FUNCTION) &amp;&amp; !m_lexer-&gt;hasLineTerminatorBeforeToken()) {
2046         const bool isAsync = true;
2047         result = parseFunctionDeclarationStatement(context, isAsync, parentAllowsFunctionDeclarationAsStatement);
2048         return true;
2049     }
2050     restoreSavePoint(savePoint);
2051     return false;
2052 }
2053 
2054 template &lt;typename LexerType&gt;
2055 template &lt;class TreeBuilder&gt; bool Parser&lt;LexerType&gt;::parseFormalParameters(TreeBuilder&amp; context, TreeFormalParameterList list, bool isArrowFunction, bool isMethod, unsigned&amp; parameterCount)
2056 {
2057 #define failIfDuplicateIfViolation() \
2058     if (duplicateParameter) {\
2059         semanticFailIfTrue(hasDefaultParameterValues, &quot;Duplicate parameter &#39;&quot;, duplicateParameter-&gt;impl(), &quot;&#39; not allowed in function with default parameter values&quot;);\
2060         semanticFailIfTrue(hasDestructuringPattern, &quot;Duplicate parameter &#39;&quot;, duplicateParameter-&gt;impl(), &quot;&#39; not allowed in function with destructuring parameters&quot;);\
2061         semanticFailIfTrue(isRestParameter, &quot;Duplicate parameter &#39;&quot;, duplicateParameter-&gt;impl(), &quot;&#39; not allowed in function with a rest parameter&quot;);\
2062         semanticFailIfTrue(isArrowFunction, &quot;Duplicate parameter &#39;&quot;, duplicateParameter-&gt;impl(), &quot;&#39; not allowed in an arrow function&quot;);\
</pre>
<hr />
<pre>
2283 
2284     return parameterList;
2285 }
2286 
2287 template &lt;typename LexerType&gt;
2288 template &lt;class TreeBuilder&gt; typename TreeBuilder::FormalParameterList Parser&lt;LexerType&gt;::createGeneratorParameters(TreeBuilder&amp; context, unsigned&amp; parameterCount)
2289 {
2290     auto parameters = context.createFormalParameterList();
2291 
2292     JSTokenLocation location(tokenLocation());
2293     JSTextPosition position = tokenStartPosition();
2294 
2295     auto addParameter = [&amp;](const Identifier&amp; name) {
2296         declareParameter(&amp;name);
2297         auto binding = context.createBindingLocation(location, name, position, position, AssignmentContext::DeclarationStatement);
2298         context.appendParameter(parameters, binding, 0);
2299         ++parameterCount;
2300     };
2301 
2302     // @generator
<span class="line-modified">2303     addParameter(m_vm.propertyNames-&gt;generatorPrivateName);</span>
2304     // @generatorState
<span class="line-modified">2305     addParameter(m_vm.propertyNames-&gt;generatorStatePrivateName);</span>
2306     // @generatorValue
<span class="line-modified">2307     addParameter(m_vm.propertyNames-&gt;generatorValuePrivateName);</span>
2308     // @generatorResumeMode
<span class="line-modified">2309     addParameter(m_vm.propertyNames-&gt;generatorResumeModePrivateName);</span>
2310     // @generatorFrame
<span class="line-modified">2311     addParameter(m_vm.propertyNames-&gt;generatorFramePrivateName);</span>
2312 
2313     return parameters;
2314 }
2315 
2316 template &lt;typename LexerType&gt;
2317 template &lt;class TreeBuilder&gt; bool Parser&lt;LexerType&gt;::parseFunctionInfo(TreeBuilder&amp; context, FunctionNameRequirements requirements, SourceParseMode mode, bool nameIsInContainingScope, ConstructorKind constructorKind, SuperBinding expectedSuperBinding, int functionKeywordStart, ParserFunctionInfo&lt;TreeBuilder&gt;&amp; functionInfo, FunctionDefinitionType functionDefinitionType, Optional&lt;int&gt; functionConstructorParametersEndPosition)
2318 {
2319     RELEASE_ASSERT(isFunctionParseMode(mode));
2320 
2321     ScopeRef parentScope = currentScope();
2322 
2323     bool isDisallowedAwaitFunctionName = isDisallowedIdentifierAwait(m_token);
2324     const char* isDisallowedAwaitFunctionNameReason = isDisallowedAwaitFunctionName ? disallowedIdentifierAwaitReason() : nullptr;
2325 
2326     AutoPopScopeRef functionScope(this, pushScope());
2327     functionScope-&gt;setSourceParseMode(mode);
2328     functionScope-&gt;setExpectedSuperBinding(expectedSuperBinding);
2329     functionScope-&gt;setConstructorKind(constructorKind);
2330     SetForScope&lt;FunctionParsePhase&gt; functionParsePhasePoisoner(m_parserState.functionParsePhase, FunctionParsePhase::Body);
2331     int functionNameStart = m_token.m_location.startOffset;
</pre>
<hr />
<pre>
2395             m_lexer-&gt;setLineNumber(m_token.m_location.line);
2396 
2397             switch (functionBodyType) {
2398             case ArrowFunctionBodyExpression:
2399                 next();
2400                 context.setEndOffset(functionInfo.body, m_lexer-&gt;currentOffset());
2401                 break;
2402             case ArrowFunctionBodyBlock:
2403             case StandardFunctionBodyBlock:
2404                 context.setEndOffset(functionInfo.body, m_lexer-&gt;currentOffset());
2405                 next();
2406                 break;
2407             }
2408             functionInfo.endLine = m_lastTokenEndPosition.line;
2409             return true;
2410         }
2411 
2412         return false;
2413     };
2414 
<span class="line-modified">2415     SyntaxChecker syntaxChecker(const_cast&lt;VM&amp;&gt;(m_vm), m_lexer.get());</span>
2416 
2417     if (UNLIKELY((SourceParseModeSet(SourceParseMode::ArrowFunctionMode, SourceParseMode::AsyncArrowFunctionMode).contains(mode)))) {
2418         startLocation = tokenLocation();
2419         functionInfo.startLine = tokenLine();
2420         startColumn = tokenColumn();
2421 
2422         parametersStart = m_token.m_location.startOffset;
2423         functionInfo.startOffset = parametersStart;
2424         functionInfo.parametersStartColumn = startColumn;
2425 
2426         if (loadCachedFunction())
2427             return true;
2428 
2429         {
2430             // Parse formal parameters with [+Yield] parameterization, in order to ban YieldExpressions
2431             // in ArrowFormalParameters, per ES6 #sec-arrow-function-definitions-static-semantics-early-errors.
2432             Scope::MaybeParseAsGeneratorForScope parseAsGenerator(functionScope, parentScope-&gt;isGenerator());
2433             SetForScope&lt;bool&gt; overrideAllowAwait(m_parserState.allowAwait, !isAsyncFunctionParseMode(mode));
2434             parseFunctionParameters(syntaxChecker, mode, functionInfo);
2435             propagateError();
</pre>
<hr />
<pre>
2572         // needed.
2573         if (functionScope-&gt;hasNonSimpleParameterList())
2574             generatorBodyScope-&gt;setHasNonSimpleParameterList();
2575 
2576         functionInfo.body = performParsingFunctionBody();
2577 
2578         // When a generator has a &quot;use strict&quot; directive, a generator function wrapping it should be strict mode.
2579         if  (generatorBodyScope-&gt;strictMode())
2580             functionScope-&gt;setStrictMode();
2581 
2582         popScope(generatorBodyScope, TreeBuilder::NeedsFreeVariableInfo);
2583     } else
2584         functionInfo.body = performParsingFunctionBody();
2585 
2586     restoreParserState(oldState);
2587     failIfFalse(functionInfo.body, &quot;Cannot parse the body of this &quot;, stringForFunctionMode(mode));
2588     context.setEndOffset(functionInfo.body, m_lexer-&gt;currentOffset());
2589     if (functionScope-&gt;strictMode() &amp;&amp; requirements != FunctionNameRequirements::Unnamed) {
2590         ASSERT(functionInfo.name);
2591         RELEASE_ASSERT(SourceParseModeSet(SourceParseMode::NormalFunctionMode, SourceParseMode::MethodMode, SourceParseMode::ArrowFunctionMode, SourceParseMode::GeneratorBodyMode, SourceParseMode::GeneratorWrapperFunctionMode).contains(mode) || isAsyncFunctionOrAsyncGeneratorWrapperParseMode(mode));
<span class="line-modified">2592         semanticFailIfTrue(m_vm.propertyNames-&gt;arguments == *functionInfo.name, &quot;&#39;&quot;, functionInfo.name-&gt;impl(), &quot;&#39; is not a valid function name in strict mode&quot;);</span>
<span class="line-modified">2593         semanticFailIfTrue(m_vm.propertyNames-&gt;eval == *functionInfo.name, &quot;&#39;&quot;, functionInfo.name-&gt;impl(), &quot;&#39; is not a valid function name in strict mode&quot;);</span>
2594     }
2595 
2596     JSTokenLocation location = JSTokenLocation(m_token.m_location);
2597     functionInfo.endOffset = m_token.m_data.offset;
2598 
2599     if (functionBodyType == ArrowFunctionBodyExpression) {
2600         location = locationBeforeLastToken();
2601         functionInfo.endOffset = location.endOffset;
2602     } else {
2603         recordFunctionEntryLocation(JSTextPosition(startLocation.line, startLocation.startOffset, startLocation.lineStartOffset));
2604         recordFunctionLeaveLocation(JSTextPosition(location.line, location.startOffset, location.lineStartOffset));
2605     }
2606 
2607     // Cache the tokenizer state and the function scope the first time the function is parsed.
2608     // Any future reparsing can then skip the function.
2609     // For arrow function is 8 = x=&gt;x + 4 symbols;
2610     // For ordinary function is 16  = function(){} + 4 symbols
2611     const int minimumSourceLengthToCache = functionBodyType == StandardFunctionBodyBlock ? 16 : 8;
2612     std::unique_ptr&lt;SourceProviderCacheItem&gt; newInfo;
2613     int sourceLength = functionInfo.endOffset - functionInfo.startOffset;
</pre>
<hr />
<pre>
2675         //
2676         //     ExportDeclaration:
2677         //         ...
2678         //         export default HoistableDeclaration[~Yield, +Default]
2679         //         ...
2680         //
2681         //     HoistableDeclaration[Yield, Default]:
2682         //         FunctionDeclaration[?Yield, ?Default]
2683         //         GeneratorDeclaration[?Yield, ?Default]
2684         //
2685         //     FunctionDeclaration[Yield, Default]:
2686         //         ...
2687         //         [+Default] function ( FormalParameters[~Yield] ) { FunctionBody[~Yield] }
2688         //
2689         //     GeneratorDeclaration[Yield, Default]:
2690         //         ...
2691         //         [+Default] function * ( FormalParameters[+Yield] ) { GeneratorBody }
2692         //
2693         // In this case, we use &quot;*default*&quot; as this function declaration&#39;s name.
2694         requirements = FunctionNameRequirements::None;
<span class="line-modified">2695         functionInfo.name = &amp;m_vm.propertyNames-&gt;starDefaultPrivateName;</span>
2696     }
2697 
2698     failIfFalse((parseFunctionInfo(context, requirements, parseMode, true, ConstructorKind::None, SuperBinding::NotNeeded, functionKeywordStart, functionInfo, FunctionDefinitionType::Declaration, functionConstructorParametersEndPosition)), &quot;Cannot parse this function&quot;);
2699     ASSERT(functionInfo.name);
2700 
2701     std::pair&lt;DeclarationResultMask, ScopeRef&gt; functionDeclaration = declareFunction(functionInfo.name);
2702     DeclarationResultMask declarationResult = functionDeclaration.first;
2703     failIfTrueIfStrict(declarationResult &amp; DeclarationResult::InvalidStrictMode, &quot;Cannot declare a function named &#39;&quot;, functionInfo.name-&gt;impl(), &quot;&#39; in strict mode&quot;);
2704     if (declarationResult &amp; DeclarationResult::InvalidDuplicateDeclaration)
2705         internalFailWithMessage(false, &quot;Cannot declare a function that shadows a let/const/class/function variable &#39;&quot;, functionInfo.name-&gt;impl(), &quot;&#39; in strict mode&quot;);
2706     if (exportType == ExportType::Exported) {
2707         ASSERT_WITH_MESSAGE(declarationDefaultContext != DeclarationDefaultContext::ExportDefault, &quot;Export default case will export the name and binding in the caller.&quot;);
2708         semanticFailIfFalse(exportName(*functionInfo.name), &quot;Cannot export a duplicate function name: &#39;&quot;, functionInfo.name-&gt;impl(), &quot;&#39;&quot;);
2709         m_moduleScopeData-&gt;exportBinding(*functionInfo.name);
2710     }
2711 
2712     TreeStatement result = context.createFuncDeclStatement(location, functionInfo);
2713     if (TreeBuilder::CreatesAST)
2714         functionDeclaration.second-&gt;appendFunction(getMetadata(functionInfo));
2715     return result;
</pre>
<hr />
<pre>
2733         //
2734         //     ExportDeclaration:
2735         //         ...
2736         //         export default HoistableDeclaration[~Yield, +Default]
2737         //         ...
2738         //
2739         //     HoistableDeclaration[Yield, Default]:
2740         //         FunctionDeclaration[?Yield, ?Default]
2741         //         GeneratorDeclaration[?Yield, ?Default]
2742         //
2743         //     FunctionDeclaration[Yield, Default]:
2744         //         ...
2745         //         [+Default] function ( FormalParameters[~Yield] ) { FunctionBody[~Yield] }
2746         //
2747         //     GeneratorDeclaration[Yield, Default]:
2748         //         ...
2749         //         [+Default] function * ( FormalParameters[+Yield] ) { GeneratorBody }
2750         //
2751         // In this case, we use &quot;*default*&quot; as this function declaration&#39;s name.
2752         requirements = FunctionNameRequirements::None;
<span class="line-modified">2753         functionInfo.name = &amp;m_vm.propertyNames-&gt;starDefaultPrivateName;</span>
2754     }
2755 
2756     failIfFalse((parseFunctionInfo(context, requirements, parseMode, true, ConstructorKind::None, SuperBinding::NotNeeded, functionKeywordStart, functionInfo, FunctionDefinitionType::Declaration, functionConstructorParametersEndPosition)), &quot;Cannot parse this async function&quot;);
2757     failIfFalse(functionInfo.name, &quot;Async function statements must have a name&quot;);
2758 
2759     std::pair&lt;DeclarationResultMask, ScopeRef&gt; functionDeclaration = declareFunction(functionInfo.name);
2760     DeclarationResultMask declarationResult = functionDeclaration.first;
2761     failIfTrueIfStrict(declarationResult &amp; DeclarationResult::InvalidStrictMode, &quot;Cannot declare an async function named &#39;&quot;, functionInfo.name-&gt;impl(), &quot;&#39; in strict mode&quot;);
2762     if (declarationResult &amp; DeclarationResult::InvalidDuplicateDeclaration)
2763         internalFailWithMessage(false, &quot;Cannot declare an async function that shadows a let/const/class/function variable &#39;&quot;, functionInfo.name-&gt;impl(), &quot;&#39; in strict mode&quot;);
2764     if (exportType == ExportType::Exported) {
2765         semanticFailIfFalse(exportName(*functionInfo.name), &quot;Cannot export a duplicate function name: &#39;&quot;, functionInfo.name-&gt;impl(), &quot;&#39;&quot;);
2766         m_moduleScopeData-&gt;exportBinding(*functionInfo.name);
2767     }
2768 
2769     TreeStatement result = context.createFuncDeclStatement(location, functionInfo);
2770     if (TreeBuilder::CreatesAST)
2771         functionDeclaration.second-&gt;appendFunction(getMetadata(functionInfo));
2772     return result;
2773 }
</pre>
<hr />
<pre>
2779     JSTokenLocation location(tokenLocation());
2780     JSTextPosition classStart = tokenStartPosition();
2781     unsigned classStartLine = tokenLine();
2782 
2783     ParserClassInfo&lt;TreeBuilder&gt; info;
2784     FunctionNameRequirements requirements = FunctionNameRequirements::Named;
2785     if (declarationDefaultContext == DeclarationDefaultContext::ExportDefault) {
2786         // Under the &quot;export default&quot; context, class declaration does not require the class name.
2787         //
2788         //     ExportDeclaration:
2789         //         ...
2790         //         export default ClassDeclaration[~Yield, +Default]
2791         //         ...
2792         //
2793         //     ClassDeclaration[Yield, Default]:
2794         //         ...
2795         //         [+Default] class ClassTail[?Yield]
2796         //
2797         // In this case, we use &quot;*default*&quot; as this class declaration&#39;s name.
2798         requirements = FunctionNameRequirements::None;
<span class="line-modified">2799         info.className = &amp;m_vm.propertyNames-&gt;starDefaultPrivateName;</span>
2800     }
2801 
2802     TreeClassExpression classExpr = parseClass(context, requirements, info);
2803     failIfFalse(classExpr, &quot;Failed to parse class&quot;);
2804     ASSERT(info.className);
2805 
2806     DeclarationResultMask declarationResult = declareVariable(info.className, DeclarationType::LetDeclaration);
2807     if (declarationResult &amp; DeclarationResult::InvalidDuplicateDeclaration)
2808         internalFailWithMessage(false, &quot;Cannot declare a class twice: &#39;&quot;, info.className-&gt;impl(), &quot;&#39;&quot;);
2809     if (exportType == ExportType::Exported) {
2810         ASSERT_WITH_MESSAGE(declarationDefaultContext != DeclarationDefaultContext::ExportDefault, &quot;Export default case will export the name and binding in the caller.&quot;);
2811         semanticFailIfFalse(exportName(*info.className), &quot;Cannot export a duplicate class name: &#39;&quot;, info.className-&gt;impl(), &quot;&#39;&quot;);
2812         m_moduleScopeData-&gt;exportBinding(*info.className);
2813     }
2814 
2815     JSTextPosition classEnd = lastTokenEndPosition();
2816     unsigned classEndLine = tokenLine();
2817 
2818     return context.createClassDeclStatement(location, classExpr, classStart, classEnd, classStartLine, classEndLine);
2819 }
</pre>
<hr />
<pre>
2853         failIfFalse(parentClass, &quot;Cannot parse the parent class name&quot;);
2854     }
2855     const ConstructorKind constructorKind = parentClass ? ConstructorKind::Extends : ConstructorKind::Base;
2856 
2857     consumeOrFail(OPENBRACE, &quot;Expected opening &#39;{&#39; at the start of a class body&quot;);
2858 
2859     TreeExpression constructor = 0;
2860     TreePropertyList classElements = 0;
2861     TreePropertyList classElementsTail = 0;
2862     while (!match(CLOSEBRACE)) {
2863         if (match(SEMICOLON)) {
2864             next();
2865             continue;
2866         }
2867 
2868         JSTokenLocation methodLocation(tokenLocation());
2869         unsigned methodStart = tokenStart();
2870 
2871         // For backwards compatibility, &quot;static&quot; is a non-reserved keyword in non-strict mode.
2872         ClassElementTag tag = ClassElementTag::Instance;
<span class="line-modified">2873         if (match(RESERVED_IF_STRICT) &amp;&amp; *m_token.m_data.ident == m_vm.propertyNames-&gt;staticKeyword) {</span>
2874             SavePoint savePoint = createSavePoint();
2875             next();
2876             if (match(OPENPAREN)) {
2877                 // Reparse &quot;static()&quot; as a method named &quot;static&quot;.
2878                 restoreSavePoint(savePoint);
2879             } else
2880                 tag = ClassElementTag::Static;
2881         }
2882 
2883         // FIXME: Figure out a way to share more code with parseProperty.
<span class="line-modified">2884         const CommonIdentifiers&amp; propertyNames = *m_vm.propertyNames;</span>
2885         const Identifier* ident = &amp;propertyNames.nullIdentifier;
2886         TreeExpression computedPropertyName = 0;
2887         bool isGetter = false;
2888         bool isSetter = false;
2889         SourceParseMode parseMode = SourceParseMode::MethodMode;
2890         if (consume(TIMES))
2891             parseMode = SourceParseMode::GeneratorWrapperMethodMode;
2892 
2893 parseMethod:
2894         switch (m_token.m_type) {
2895         namedKeyword:
2896         case STRING:
2897             ident = m_token.m_data.ident;
2898             ASSERT(ident);
2899             next();
2900             break;
2901         case IDENT:
<span class="line-modified">2902             if (UNLIKELY(*m_token.m_data.ident == m_vm.propertyNames-&gt;async &amp;&amp; !m_token.m_data.escaped)) {</span>
2903                 if (!isGeneratorMethodParseMode(parseMode) &amp;&amp; !isAsyncMethodParseMode(parseMode)) {
2904                     ident = m_token.m_data.ident;
2905                     next();
2906                     if (match(OPENPAREN) || match(COLON) || match(EQUAL) || m_lexer-&gt;hasLineTerminatorBeforeToken())
2907                         break;
2908                     if (UNLIKELY(consume(TIMES)))
2909                         parseMode = SourceParseMode::AsyncGeneratorWrapperMethodMode;
2910                     else
2911                         parseMode = SourceParseMode::AsyncMethodMode;
2912                     goto parseMethod;
2913                 }
2914             }
2915             FALLTHROUGH;
2916         case AWAIT:
2917             ident = m_token.m_data.ident;
2918             ASSERT(ident);
2919             next();
2920             if (parseMode == SourceParseMode::MethodMode &amp;&amp; (matchIdentifierOrKeyword() || match(STRING) || match(DOUBLE) || match(INTEGER) || match(OPENBRACKET))) {
2921                 isGetter = *ident == propertyNames.get;
2922                 isSetter = *ident == propertyNames.set;
2923             }
2924             break;
2925         case DOUBLE:
2926         case INTEGER:
<span class="line-modified">2927             ident = &amp;m_parserArena.identifierArena().makeNumericIdentifier(const_cast&lt;VM&amp;&gt;(m_vm), m_token.m_data.doubleValue);</span>
2928             ASSERT(ident);
2929             next();
2930             break;
2931         case OPENBRACKET:
2932             next();
2933             computedPropertyName = parseAssignmentExpression(context);
2934             failIfFalse(computedPropertyName, &quot;Cannot parse computed property name&quot;);
2935             handleProductionOrFail(CLOSEBRACKET, &quot;]&quot;, &quot;end&quot;, &quot;computed property name&quot;);
2936             break;
2937         default:
2938             if (m_token.m_type &amp; KeywordTokenFlag)
2939                 goto namedKeyword;
2940             failDueToUnexpectedToken();
2941         }
2942 
2943         TreeProperty property;
2944         const bool alwaysStrictInsideClass = true;
2945         if (isGetter || isSetter) {
2946             property = parseGetterSetter(context, alwaysStrictInsideClass, isGetter ? PropertyNode::Getter : PropertyNode::Setter,
2947                 methodStart, ConstructorKind::None, tag);
2948             failIfFalse(property, &quot;Cannot parse this method&quot;);
2949         } else {
2950             ParserFunctionInfo&lt;TreeBuilder&gt; methodInfo;
2951             bool isConstructor = tag == ClassElementTag::Instance &amp;&amp; *ident == propertyNames.constructor;
2952             if (isAsyncMethodParseMode(parseMode) || isAsyncGeneratorMethodParseMode(parseMode) || isGeneratorMethodParseMode(parseMode)) {
2953                 isConstructor = false;
<span class="line-modified">2954                 semanticFailIfTrue(*ident == m_vm.propertyNames-&gt;prototype, &quot;Cannot declare &quot;, stringArticleForFunctionMode(parseMode), stringForFunctionMode(parseMode), &quot; named &#39;prototype&#39;&quot;);</span>
<span class="line-modified">2955                 semanticFailIfTrue(*ident == m_vm.propertyNames-&gt;constructor, &quot;Cannot declare &quot;, stringArticleForFunctionMode(parseMode), stringForFunctionMode(parseMode), &quot; named &#39;constructor&#39;&quot;);</span>
2956             }
2957 
2958             methodInfo.name = isConstructor ? info.className : ident;
2959             failIfFalse((parseFunctionInfo(context, FunctionNameRequirements::Unnamed, parseMode, false, isConstructor ? constructorKind : ConstructorKind::None, SuperBinding::Needed, methodStart, methodInfo, FunctionDefinitionType::Method)), &quot;Cannot parse this method&quot;);
2960 
2961             TreeExpression method = context.createMethodDefinition(methodLocation, methodInfo);
2962             if (isConstructor) {
2963                 semanticFailIfTrue(constructor, &quot;Cannot declare multiple constructors in a single class&quot;);
2964                 constructor = method;
2965                 continue;
2966             }
2967 
2968             // FIXME: Syntax error when super() is called
2969             semanticFailIfTrue(tag == ClassElementTag::Static &amp;&amp; methodInfo.name &amp;&amp; *methodInfo.name == propertyNames.prototype,
2970                 &quot;Cannot declare a static method named &#39;prototype&#39;&quot;);
2971 
2972             if (computedPropertyName) {
2973                 property = context.createProperty(computedPropertyName, method, static_cast&lt;PropertyNode::Type&gt;(PropertyNode::Constant | PropertyNode::Computed),
2974                     PropertyNode::Unknown, alwaysStrictInsideClass, SuperBinding::Needed, tag);
2975             } else {
</pre>
<hr />
<pre>
3087         break;
3088     }
3089     JSTextPosition start = tokenStartPosition();
3090     JSTokenLocation location(tokenLocation());
3091     TreeExpression expression = parseExpression(context);
3092     failIfFalse(expression, &quot;Cannot parse expression statement&quot;);
3093     failIfFalse(autoSemiColon(), &quot;Parse error&quot;);
3094     return context.createExprStatement(location, expression, start, m_lastTokenEndPosition.line);
3095 }
3096 
3097 template &lt;typename LexerType&gt;
3098 template &lt;class TreeBuilder&gt; TreeStatement Parser&lt;LexerType&gt;::parseIfStatement(TreeBuilder&amp; context)
3099 {
3100     ASSERT(match(IF));
3101     JSTokenLocation ifLocation(tokenLocation());
3102     int start = tokenLine();
3103     next();
3104     handleProductionOrFail2(OPENPAREN, &quot;(&quot;, &quot;start&quot;, &quot;&#39;if&#39; condition&quot;);
3105 
3106     TreeExpression condition = parseExpression(context);
<span class="line-modified">3107     failIfFalse(condition, &quot;Expected an expression as the condition for an if statement&quot;);</span>
3108     recordPauseLocation(context.breakpointLocation(condition));
3109     int end = tokenLine();
3110     handleProductionOrFail2(CLOSEPAREN, &quot;)&quot;, &quot;end&quot;, &quot;&#39;if&#39; condition&quot;);
3111 
3112     const Identifier* unused = 0;
3113     m_immediateParentAllowsFunctionDeclarationInStatement = true;
3114     TreeStatement trueBlock = parseStatement(context, unused);
3115     failIfFalse(trueBlock, &quot;Expected a statement as the body of an if block&quot;);
3116 
3117     if (!match(ELSE))
3118         return context.createIfStatement(ifLocation, condition, trueBlock, 0, start, end);
3119 
3120     Vector&lt;TreeExpression&gt; exprStack;
3121     Vector&lt;std::pair&lt;int, int&gt;&gt; posStack;
3122     Vector&lt;JSTokenLocation&gt; tokenLocationStack;
3123     Vector&lt;TreeStatement&gt; statementStack;
3124     bool trailingElse = false;
3125     do {
3126         JSTokenLocation tempLocation = tokenLocation();
3127         next();
3128         if (!match(IF)) {
3129             const Identifier* unused = 0;
3130             m_immediateParentAllowsFunctionDeclarationInStatement = true;
3131             TreeStatement block = parseStatement(context, unused);
3132             failIfFalse(block, &quot;Expected a statement as the body of an else block&quot;);
3133             statementStack.append(block);
3134             trailingElse = true;
3135             break;
3136         }
3137         int innerStart = tokenLine();
3138         next();
3139 
3140         handleProductionOrFail2(OPENPAREN, &quot;(&quot;, &quot;start&quot;, &quot;&#39;if&#39; condition&quot;);
3141 
3142         TreeExpression innerCondition = parseExpression(context);
<span class="line-modified">3143         failIfFalse(innerCondition, &quot;Expected an expression as the condition for an if statement&quot;);</span>
3144         recordPauseLocation(context.breakpointLocation(innerCondition));
3145         int innerEnd = tokenLine();
3146         handleProductionOrFail2(CLOSEPAREN, &quot;)&quot;, &quot;end&quot;, &quot;&#39;if&#39; condition&quot;);
3147         const Identifier* unused = 0;
3148         m_immediateParentAllowsFunctionDeclarationInStatement = true;
3149         TreeStatement innerTrueBlock = parseStatement(context, unused);
3150         failIfFalse(innerTrueBlock, &quot;Expected a statement as the body of an if block&quot;);
3151         tokenLocationStack.append(tempLocation);
3152         exprStack.append(innerCondition);
3153         posStack.append(std::make_pair(innerStart, innerEnd));
3154         statementStack.append(innerTrueBlock);
3155     } while (match(ELSE));
3156 
3157     if (!trailingElse) {
3158         TreeExpression condition = exprStack.last();
3159         exprStack.removeLast();
3160         TreeStatement trueBlock = statementStack.last();
3161         statementStack.removeLast();
3162         std::pair&lt;int, int&gt; pos = posStack.last();
3163         posStack.removeLast();
</pre>
<hr />
<pre>
3201 }
3202 
3203 template &lt;typename LexerType&gt;
3204 template &lt;class TreeBuilder&gt; typename TreeBuilder::ImportSpecifier Parser&lt;LexerType&gt;::parseImportClauseItem(TreeBuilder&amp; context, ImportSpecifierType specifierType)
3205 {
3206     // Produced node is the item of the ImportClause.
3207     // That is the ImportSpecifier, ImportedDefaultBinding or NameSpaceImport.
3208     // http://www.ecma-international.org/ecma-262/6.0/#sec-imports
3209     JSTokenLocation specifierLocation(tokenLocation());
3210     JSToken localNameToken;
3211     const Identifier* importedName = nullptr;
3212     const Identifier* localName = nullptr;
3213 
3214     switch (specifierType) {
3215     case ImportSpecifierType::NamespaceImport: {
3216         // NameSpaceImport :
3217         // * as ImportedBinding
3218         // e.g.
3219         //     * as namespace
3220         ASSERT(match(TIMES));
<span class="line-modified">3221         importedName = &amp;m_vm.propertyNames-&gt;timesIdentifier;</span>
3222         next();
3223 
<span class="line-modified">3224         failIfFalse(matchContextualKeyword(m_vm.propertyNames-&gt;as), &quot;Expected &#39;as&#39; before imported binding name&quot;);</span>
3225         next();
3226 
3227         failIfFalse(matchSpecIdentifier(), &quot;Expected a variable name for the import declaration&quot;);
3228         localNameToken = m_token;
3229         localName = m_token.m_data.ident;
3230         next();
3231         break;
3232     }
3233 
3234     case ImportSpecifierType::NamedImport: {
3235         // ImportSpecifier :
3236         // ImportedBinding
3237         // IdentifierName as ImportedBinding
3238         // e.g.
3239         //     A
3240         //     A as B
3241         ASSERT(matchIdentifierOrKeyword());
3242         localNameToken = m_token;
3243         localName = m_token.m_data.ident;
3244         importedName = localName;
3245         next();
3246 
<span class="line-modified">3247         if (matchContextualKeyword(m_vm.propertyNames-&gt;as)) {</span>
3248             next();
3249             failIfFalse(matchSpecIdentifier(), &quot;Expected a variable name for the import declaration&quot;);
3250             localNameToken = m_token;
3251             localName = m_token.m_data.ident;
3252             next();
3253         }
3254         break;
3255     }
3256 
3257     case ImportSpecifierType::DefaultImport: {
3258         // ImportedDefaultBinding :
3259         // ImportedBinding
3260         ASSERT(matchSpecIdentifier());
3261         localNameToken = m_token;
3262         localName = m_token.m_data.ident;
<span class="line-modified">3263         importedName = &amp;m_vm.propertyNames-&gt;defaultKeyword;</span>
3264         next();
3265         break;
3266     }
3267     }
3268 
3269     semanticFailIfTrue(localNameToken.m_type == AWAIT, &quot;Cannot use &#39;await&#39; as an imported binding name&quot;);
3270     semanticFailIfTrue(localNameToken.m_type &amp; KeywordTokenFlag, &quot;Cannot use keyword as imported binding name&quot;);
3271     DeclarationResultMask declarationResult = declareVariable(localName, DeclarationType::ConstDeclaration, (specifierType == ImportSpecifierType::NamespaceImport) ? DeclarationImportType::ImportedNamespace : DeclarationImportType::Imported);
3272     if (declarationResult != DeclarationResult::Valid) {
3273         failIfTrueIfStrict(declarationResult &amp; DeclarationResult::InvalidStrictMode, &quot;Cannot declare an imported binding named &quot;, localName-&gt;impl(), &quot; in strict mode&quot;);
3274         if (declarationResult &amp; DeclarationResult::InvalidDuplicateDeclaration)
3275             internalFailWithMessage(false, &quot;Cannot declare an imported binding name twice: &#39;&quot;, localName-&gt;impl(), &quot;&#39;&quot;);
3276     }
3277 
3278     return context.createImportSpecifier(specifierLocation, *importedName, *localName);
3279 }
3280 
3281 template &lt;typename LexerType&gt;
3282 template &lt;class TreeBuilder&gt; TreeStatement Parser&lt;LexerType&gt;::parseImportDeclaration(TreeBuilder&amp; context)
3283 {
</pre>
<hr />
<pre>
3321             // { ImportsList }
3322             // { ImportsList , }
3323             next();
3324 
3325             while (!match(CLOSEBRACE)) {
3326                 failIfFalse(matchIdentifierOrKeyword(), &quot;Expected an imported name for the import declaration&quot;);
3327                 auto specifier = parseImportClauseItem(context, ImportSpecifierType::NamedImport);
3328                 failIfFalse(specifier, &quot;Cannot parse the named import&quot;);
3329                 context.appendImportSpecifier(specifierList, specifier);
3330                 if (!consume(COMMA))
3331                     break;
3332             }
3333             handleProductionOrFail2(CLOSEBRACE, &quot;}&quot;, &quot;end&quot;, &quot;import list&quot;);
3334         } else
3335             failWithMessage(&quot;Expected namespace import or import list&quot;);
3336     }
3337 
3338     // FromClause :
3339     // from ModuleSpecifier
3340 
<span class="line-modified">3341     failIfFalse(matchContextualKeyword(m_vm.propertyNames-&gt;from), &quot;Expected &#39;from&#39; before imported module name&quot;);</span>
3342     next();
3343 
3344     auto moduleName = parseModuleName(context);
3345     failIfFalse(moduleName, &quot;Cannot parse the module name&quot;);
3346     failIfFalse(autoSemiColon(), &quot;Expected a &#39;;&#39; following a targeted import declaration&quot;);
3347 
3348     return context.createImportDeclaration(importLocation, specifierList, moduleName);
3349 }
3350 
3351 template &lt;typename LexerType&gt;
3352 template &lt;class TreeBuilder&gt; typename TreeBuilder::ExportSpecifier Parser&lt;LexerType&gt;::parseExportSpecifier(TreeBuilder&amp; context, Vector&lt;std::pair&lt;const Identifier*, const Identifier*&gt;&gt;&amp; maybeExportedLocalNames, bool&amp; hasKeywordForLocalBindings)
3353 {
3354     // ExportSpecifier :
3355     // IdentifierName
3356     // IdentifierName as IdentifierName
3357     // http://www.ecma-international.org/ecma-262/6.0/#sec-exports
3358     ASSERT(matchIdentifierOrKeyword());
3359     JSTokenLocation specifierLocation(tokenLocation());
3360     if (m_token.m_type &amp; KeywordTokenFlag)
3361         hasKeywordForLocalBindings = true;
3362     const Identifier* localName = m_token.m_data.ident;
3363     const Identifier* exportedName = localName;
3364     next();
3365 
<span class="line-modified">3366     if (matchContextualKeyword(m_vm.propertyNames-&gt;as)) {</span>
3367         next();
3368         failIfFalse(matchIdentifierOrKeyword(), &quot;Expected an exported name for the export declaration&quot;);
3369         exportedName = m_token.m_data.ident;
3370         next();
3371     }
3372 
3373     semanticFailIfFalse(exportName(*exportedName), &quot;Cannot export a duplicate name &#39;&quot;, exportedName-&gt;impl(), &quot;&#39;&quot;);
3374     maybeExportedLocalNames.append(std::make_pair(localName, exportedName));
3375     return context.createExportSpecifier(specifierLocation, *localName, *exportedName);
3376 }
3377 
3378 template &lt;typename LexerType&gt;
3379 template &lt;class TreeBuilder&gt; TreeStatement Parser&lt;LexerType&gt;::parseExportDeclaration(TreeBuilder&amp; context)
3380 {
3381     // http://www.ecma-international.org/ecma-262/6.0/#sec-exports
3382     ASSERT(match(EXPORT));
3383     JSTokenLocation exportLocation(tokenLocation());
3384     next();
3385 
3386     switch (m_token.m_type) {
3387     case TIMES: {
3388         // export * FromClause ;
3389         next();
3390 
<span class="line-modified">3391         failIfFalse(matchContextualKeyword(m_vm.propertyNames-&gt;from), &quot;Expected &#39;from&#39; before exported module name&quot;);</span>
3392         next();
3393         auto moduleName = parseModuleName(context);
3394         failIfFalse(moduleName, &quot;Cannot parse the &#39;from&#39; clause&quot;);
3395         failIfFalse(autoSemiColon(), &quot;Expected a &#39;;&#39; following a targeted export declaration&quot;);
3396 
3397         return context.createExportAllDeclaration(exportLocation, moduleName);
3398     }
3399 
3400     case DEFAULT: {
3401         // export default HoistableDeclaration[Default]
3402         // export default ClassDeclaration[Default]
3403         // export default [lookahead not-in {function, class}] AssignmentExpression[In] ;
3404 
3405         next();
3406 
3407         TreeStatement result = 0;
3408         bool isFunctionOrClassDeclaration = false;
3409         const Identifier* localName = nullptr;
3410 
3411         bool startsWithFunction = match(FUNCTION);
3412         if (startsWithFunction || match(CLASSTOKEN)) {
3413             SavePoint savePoint = createSavePoint();
3414             isFunctionOrClassDeclaration = true;
3415             next();
3416 
3417             // ES6 Generators
3418             if (startsWithFunction &amp;&amp; match(TIMES))
3419                 next();
3420             if (match(IDENT))
3421                 localName = m_token.m_data.ident;
3422             restoreSavePoint(savePoint);
<span class="line-modified">3423         } else if (matchContextualKeyword(m_vm.propertyNames-&gt;async)) {</span>
3424             SavePoint savePoint = createSavePoint();
3425             next();
3426             if (match(FUNCTION) &amp;&amp; !m_lexer-&gt;hasLineTerminatorBeforeToken()) {
3427                 next();
3428                 if (match(IDENT))
3429                     localName = m_token.m_data.ident;
3430                 isFunctionOrClassDeclaration = true;
3431             }
3432             restoreSavePoint(savePoint);
3433         }
3434 
3435         if (!localName)
<span class="line-modified">3436             localName = &amp;m_vm.propertyNames-&gt;starDefaultPrivateName;</span>
3437 
3438         if (isFunctionOrClassDeclaration) {
3439             if (startsWithFunction) {
3440                 ASSERT(match(FUNCTION));
3441                 DepthManager statementDepth(&amp;m_statementDepth);
3442                 m_statementDepth = 1;
3443                 result = parseFunctionDeclaration(context, ExportType::NotExported, DeclarationDefaultContext::ExportDefault);
3444             } else if (match(CLASSTOKEN)) {
3445                 result = parseClassDeclaration(context, ExportType::NotExported, DeclarationDefaultContext::ExportDefault);
3446             } else {
<span class="line-modified">3447                 ASSERT(matchContextualKeyword(m_vm.propertyNames-&gt;async));</span>
3448                 next();
3449                 DepthManager statementDepth(&amp;m_statementDepth);
3450                 m_statementDepth = 1;
3451                 result = parseAsyncFunctionDeclaration(context, ExportType::NotExported, DeclarationDefaultContext::ExportDefault);
3452             }
3453         } else {
3454             // export default expr;
3455             //
3456             // It should be treated as the same to the following.
3457             //
3458             // const *default* = expr;
3459             // export { *default* as default }
3460             //
3461             // In the above example, *default* is the invisible variable to the users.
3462             // We use the private symbol to represent the name of this variable.
3463             JSTokenLocation location(tokenLocation());
3464             JSTextPosition start = tokenStartPosition();
3465             TreeExpression expression = parseAssignmentExpression(context);
3466             failIfFalse(expression, &quot;Cannot parse expression&quot;);
3467 
<span class="line-modified">3468             DeclarationResultMask declarationResult = declareVariable(&amp;m_vm.propertyNames-&gt;starDefaultPrivateName, DeclarationType::ConstDeclaration);</span>
3469             if (declarationResult &amp; DeclarationResult::InvalidDuplicateDeclaration)
3470                 internalFailWithMessage(false, &quot;Only one &#39;default&#39; export is allowed&quot;);
3471 
<span class="line-modified">3472             TreeExpression assignment = context.createAssignResolve(location, m_vm.propertyNames-&gt;starDefaultPrivateName, expression, start, start, tokenEndPosition(), AssignmentContext::ConstDeclarationStatement);</span>
3473             result = context.createExprStatement(location, assignment, start, tokenEndPosition());
3474             failIfFalse(autoSemiColon(), &quot;Expected a &#39;;&#39; following a targeted export declaration&quot;);
3475         }
3476         failIfFalse(result, &quot;Cannot parse the declaration&quot;);
3477 
<span class="line-modified">3478         semanticFailIfFalse(exportName(m_vm.propertyNames-&gt;defaultKeyword), &quot;Only one &#39;default&#39; export is allowed&quot;);</span>
<span class="line-modified">3479         m_moduleScopeData-&gt;exportBinding(*localName, m_vm.propertyNames-&gt;defaultKeyword);</span>
3480         return context.createExportDefaultDeclaration(exportLocation, result, *localName);
3481     }
3482 
3483     case OPENBRACE: {
3484         // export ExportClause FromClause ;
3485         // export ExportClause ;
3486         //
3487         // ExportClause :
3488         // { }
3489         // { ExportsList }
3490         // { ExportsList , }
3491         //
3492         // ExportsList :
3493         // ExportSpecifier
3494         // ExportsList , ExportSpecifier
3495 
3496         next();
3497 
3498         auto specifierList = context.createExportSpecifierList();
3499         Vector&lt;std::pair&lt;const Identifier*, const Identifier*&gt;&gt; maybeExportedLocalNames;
3500 
3501         bool hasKeywordForLocalBindings = false;
3502         while (!match(CLOSEBRACE)) {
3503             failIfFalse(matchIdentifierOrKeyword(), &quot;Expected a variable name for the export declaration&quot;);
3504             auto specifier = parseExportSpecifier(context, maybeExportedLocalNames, hasKeywordForLocalBindings);
3505             failIfFalse(specifier, &quot;Cannot parse the named export&quot;);
3506             context.appendExportSpecifier(specifierList, specifier);
3507             if (!consume(COMMA))
3508                 break;
3509         }
3510         handleProductionOrFail2(CLOSEBRACE, &quot;}&quot;, &quot;end&quot;, &quot;export list&quot;);
3511 
3512         typename TreeBuilder::ModuleName moduleName = 0;
<span class="line-modified">3513         if (matchContextualKeyword(m_vm.propertyNames-&gt;from)) {</span>
3514             next();
3515             moduleName = parseModuleName(context);
3516             failIfFalse(moduleName, &quot;Cannot parse the &#39;from&#39; clause&quot;);
3517         }
3518         failIfFalse(autoSemiColon(), &quot;Expected a &#39;;&#39; following a targeted export declaration&quot;);
3519 
3520         if (!moduleName) {
3521             semanticFailIfTrue(hasKeywordForLocalBindings, &quot;Cannot use keyword as exported variable name&quot;);
3522             // Since this export declaration does not have module specifier part, it exports the local bindings.
3523             // While the export declaration with module specifier does not have any effect on the current module&#39;s scope,
3524             // the export named declaration without module specifier references the local binding names.
3525             // For example,
3526             //   export { A, B, C as D } from &quot;mod&quot;
3527             // does not have effect on the current module&#39;s scope. But,
3528             //   export { A, B, C as D }
3529             // will reference the current module&#39;s bindings.
3530             for (const auto&amp; pair : maybeExportedLocalNames) {
3531                 const Identifier* localName = pair.first;
3532                 const Identifier* exportedName = pair.second;
3533                 m_moduleScopeData-&gt;exportBinding(*localName, *exportedName);
</pre>
<hr />
<pre>
3549         case CONSTTOKEN:
3550             result = parseVariableDeclaration(context, DeclarationType::ConstDeclaration, ExportType::Exported);
3551             break;
3552 
3553         case LET:
3554             result = parseVariableDeclaration(context, DeclarationType::LetDeclaration, ExportType::Exported);
3555             break;
3556 
3557         case FUNCTION: {
3558             DepthManager statementDepth(&amp;m_statementDepth);
3559             m_statementDepth = 1;
3560             result = parseFunctionDeclaration(context, ExportType::Exported);
3561             break;
3562         }
3563 
3564         case CLASSTOKEN:
3565             result = parseClassDeclaration(context, ExportType::Exported);
3566             break;
3567 
3568         case IDENT:
<span class="line-modified">3569             if (*m_token.m_data.ident == m_vm.propertyNames-&gt;async &amp;&amp; !m_token.m_data.escaped) {</span>
3570                 next();
3571                 semanticFailIfFalse(match(FUNCTION) &amp;&amp; !m_lexer-&gt;hasLineTerminatorBeforeToken(), &quot;Expected &#39;function&#39; keyword following &#39;async&#39; keyword with no preceding line terminator&quot;);
3572                 DepthManager statementDepth(&amp;m_statementDepth);
3573                 m_statementDepth = 1;
3574                 result = parseAsyncFunctionDeclaration(context, ExportType::Exported);
3575                 break;
3576             }
3577             FALLTHROUGH;
3578         default:
3579             failWithMessage(&quot;Expected either a declaration or a variable statement&quot;);
3580             break;
3581         }
3582 
3583         failIfFalse(result, &quot;Cannot parse the declaration&quot;);
3584         return context.createExportLocalDeclaration(exportLocation, result);
3585     }
3586     }
3587 
3588     RELEASE_ASSERT_NOT_REACHED();
3589     return 0;
</pre>
<hr />
<pre>
3630 
3631 template &lt;typename LexerType&gt;
3632 template &lt;typename TreeBuilder&gt; TreeExpression Parser&lt;LexerType&gt;::parseAssignmentExpression(TreeBuilder&amp; context)
3633 {
3634     ExpressionErrorClassifier classifier(this);
3635     return parseAssignmentExpression(context, classifier);
3636 }
3637 
3638 
3639 template &lt;typename LexerType&gt;
3640 template &lt;typename TreeBuilder&gt; NEVER_INLINE const char* Parser&lt;LexerType&gt;::metaPropertyName(TreeBuilder&amp; context, TreeExpression expr)
3641 {
3642     if (context.isNewTarget(expr))
3643         return &quot;new.target&quot;;
3644     if (context.isImportMeta(expr))
3645         return &quot;import.meta&quot;;
3646     RELEASE_ASSERT_NOT_REACHED();
3647     return &quot;error&quot;;
3648 }
3649 
<span class="line-added">3650 template &lt;typename LexerType&gt;</span>
<span class="line-added">3651 template &lt;typename TreeBuilder&gt; bool Parser&lt;LexerType&gt;::isSimpleAssignmentTarget(TreeBuilder&amp; context, TreeExpression expr)</span>
<span class="line-added">3652 {</span>
<span class="line-added">3653     // Web compatibility concerns prevent us from handling a function call LHS as an early error in sloppy mode.</span>
<span class="line-added">3654     // This behavior is currently unspecified, but see: https://github.com/tc39/ecma262/issues/257#issuecomment-195106880</span>
<span class="line-added">3655     return context.isLocation(expr) || (!strictMode() &amp;&amp; context.isFunctionCall(expr));</span>
<span class="line-added">3656 }</span>
<span class="line-added">3657 </span>
3658 template &lt;typename LexerType&gt;
3659 template &lt;typename TreeBuilder&gt; TreeExpression Parser&lt;LexerType&gt;::parseAssignmentExpression(TreeBuilder&amp; context, ExpressionErrorClassifier&amp; classifier)
3660 {
3661     ASSERT(!hasError());
3662 
3663     failIfStackOverflow();
3664 
3665     if (match(YIELD) &amp;&amp; !isYIELDMaskedAsIDENT(currentScope()-&gt;isGenerator()))
3666         return parseYieldExpression(context);
3667 
3668     JSTextPosition start = tokenStartPosition();
3669     JSTokenLocation location(tokenLocation());
3670     int initialAssignmentCount = m_parserState.assignmentCount;
3671     int initialNonLHSCount = m_parserState.nonLHSCount;
3672     bool maybeAssignmentPattern = match(OPENBRACE) || match(OPENBRACKET);
3673     bool wasOpenParen = match(OPENPAREN);
3674     // Do not use matchSpecIdentifier() here since it is slower than isIdentifierOrKeyword.
3675     // Whether spec identifier is will be validated by isArrowFunctionParameters().
3676     bool wasIdentifierOrKeyword = isIdentifierOrKeyword(m_token);
3677     bool maybeValidArrowFunctionStart = wasOpenParen || wasIdentifierOrKeyword;
3678     SavePoint savePoint = createSavePoint();
3679     size_t usedVariablesSize = 0;
3680 
3681     if (wasOpenParen) {
3682         usedVariablesSize = currentScope()-&gt;currentUsedVariablesSize();
3683         currentScope()-&gt;pushUsedVariableSet();
3684     }
3685 
3686     TreeExpression lhs = parseConditionalExpression(context);
3687 
3688     if (maybeValidArrowFunctionStart &amp;&amp; !match(EOFTOK)) {
3689         bool isArrowFunctionToken = match(ARROWFUNCTION);
3690         if (!lhs || isArrowFunctionToken) {
3691             SavePointWithError errorRestorationSavePoint = createSavePointForError();
3692             restoreSavePoint(savePoint);
3693             bool isAsyncArrow = false;
3694             if (UNLIKELY(classifier.indicatesPossibleAsyncArrowFunction())) {
<span class="line-modified">3695                 if (matchContextualKeyword(m_vm.propertyNames-&gt;async)) {</span>
3696                     next();
3697                     isAsyncArrow = !m_lexer-&gt;hasLineTerminatorBeforeToken();
3698                 }
3699             }
3700             if (isArrowFunctionParameters()) {
3701                 if (wasOpenParen)
3702                     currentScope()-&gt;revertToPreviousUsedVariables(usedVariablesSize);
3703                 return parseArrowFunctionExpression(context, isAsyncArrow);
3704             }
3705             if (isArrowFunctionToken)
3706                 propagateError();
3707             restoreSavePointWithError(errorRestorationSavePoint);
3708             if (isArrowFunctionToken)
3709                 failDueToUnexpectedToken();
3710         }
3711     }
3712 
3713     if (!lhs &amp;&amp; (!maybeAssignmentPattern || !classifier.indicatesPossiblePattern()))
3714         propagateError();
3715 
</pre>
<hr />
<pre>
3743     while (true) {
3744         switch (m_token.m_type) {
3745         case EQUAL: op = OpEqual; break;
3746         case PLUSEQUAL: op = OpPlusEq; break;
3747         case MINUSEQUAL: op = OpMinusEq; break;
3748         case MULTEQUAL: op = OpMultEq; break;
3749         case DIVEQUAL: op = OpDivEq; break;
3750         case LSHIFTEQUAL: op = OpLShift; break;
3751         case RSHIFTEQUAL: op = OpRShift; break;
3752         case URSHIFTEQUAL: op = OpURShift; break;
3753         case ANDEQUAL: op = OpAndEq; break;
3754         case XOREQUAL: op = OpXOrEq; break;
3755         case OREQUAL: op = OpOrEq; break;
3756         case MODEQUAL: op = OpModEq; break;
3757         case POWEQUAL: op = OpPowEq; break;
3758         default:
3759             goto end;
3760         }
3761         m_parserState.nonTrivialExpressionCount++;
3762         hadAssignment = true;
<span class="line-modified">3763         semanticFailIfTrue(context.isMetaProperty(lhs), metaPropertyName(context, lhs), &quot; can&#39;t be the left hand side of an assignment expression&quot;);</span>
<span class="line-modified">3764         semanticFailIfFalse(isSimpleAssignmentTarget(context, lhs), &quot;Left side of assignment is not a reference&quot;);</span>
3765         context.assignmentStackAppend(assignmentStack, lhs, start, tokenStartPosition(), m_parserState.assignmentCount, op);
3766         start = tokenStartPosition();
3767         m_parserState.assignmentCount++;
3768         next(TreeBuilder::DontBuildStrings);
3769         if (strictMode() &amp;&amp; m_parserState.lastIdentifier &amp;&amp; context.isResolve(lhs)) {
<span class="line-modified">3770             failIfTrueIfStrict(m_vm.propertyNames-&gt;eval == *m_parserState.lastIdentifier, &quot;Cannot modify &#39;eval&#39; in strict mode&quot;);</span>
<span class="line-modified">3771             failIfTrueIfStrict(m_vm.propertyNames-&gt;arguments == *m_parserState.lastIdentifier, &quot;Cannot modify &#39;arguments&#39; in strict mode&quot;);</span>
3772             m_parserState.lastIdentifier = 0;
3773         }
3774         lhs = parseAssignmentExpression(context);
3775         failIfFalse(lhs, &quot;Cannot parse the right hand side of an assignment expression&quot;);
3776         if (initialNonLHSCount != m_parserState.nonLHSCount) {
3777             if (m_token.m_type &gt;= EQUAL &amp;&amp; m_token.m_type &lt;= OREQUAL)
3778                 semanticFail(&quot;Left hand side of operator &#39;&quot;, getToken(), &quot;&#39; must be a reference&quot;);
3779             break;
3780         }
3781     }
3782 end:
3783     if (hadAssignment)
3784         m_parserState.nonLHSCount++;
3785 
3786     if (!TreeBuilder::CreatesAST)
3787         return lhs;
3788 
3789     while (assignmentStack)
3790         lhs = context.createAssignment(location, assignmentStack, lhs, initialAssignmentCount, m_parserState.assignmentCount, lastTokenEndPosition());
3791 
</pre>
<hr />
<pre>
3868     if (isUpdateOp(token))
3869         return false;
3870     return isUnaryOp(token);
3871 }
3872 
3873 template &lt;typename LexerType&gt;
3874 int Parser&lt;LexerType&gt;::isBinaryOperator(JSTokenType token)
3875 {
3876     if (m_allowsIn)
3877         return token &amp; (BinaryOpTokenPrecedenceMask &lt;&lt; BinaryOpTokenAllowsInPrecedenceAdditionalShift);
3878     return token &amp; BinaryOpTokenPrecedenceMask;
3879 }
3880 
3881 template &lt;typename LexerType&gt;
3882 template &lt;class TreeBuilder&gt; TreeExpression Parser&lt;LexerType&gt;::parseBinaryExpression(TreeBuilder&amp; context)
3883 {
3884     int operandStackDepth = 0;
3885     int operatorStackDepth = 0;
3886     typename TreeBuilder::BinaryExprContext binaryExprContext(context);
3887     JSTokenLocation location(tokenLocation());
<span class="line-added">3888     bool hasLogicalOperator = false;</span>
<span class="line-added">3889     bool hasCoalesceOperator = false;</span>
<span class="line-added">3890 </span>
3891     while (true) {
3892         JSTextPosition exprStart = tokenStartPosition();
3893         int initialAssignments = m_parserState.assignmentCount;
3894         JSTokenType leadingTokenTypeForUnaryExpression = m_token.m_type;
3895         TreeExpression current = parseUnaryExpression(context);
3896         failIfFalse(current, &quot;Cannot parse expression&quot;);
3897 
3898         context.appendBinaryExpressionInfo(operandStackDepth, current, exprStart, lastTokenEndPosition(), lastTokenEndPosition(), initialAssignments != m_parserState.assignmentCount);
<span class="line-added">3899         int precedence = isBinaryOperator(m_token.m_type);</span>
<span class="line-added">3900         if (!precedence)</span>
<span class="line-added">3901             break;</span>
3902 
3903         // 12.6 https://tc39.github.io/ecma262/#sec-exp-operator
3904         // ExponentiationExpresion is described as follows.
3905         //
3906         //     ExponentiationExpression[Yield]:
3907         //         UnaryExpression[?Yield]
3908         //         UpdateExpression[?Yield] ** ExponentiationExpression[?Yield]
3909         //
3910         // As we can see, the left hand side of the ExponentiationExpression is UpdateExpression, not UnaryExpression.
3911         // So placing UnaryExpression not included in UpdateExpression here is a syntax error.
3912         // This is intentional. For example, if UnaryExpression is allowed, we can have the code like `-x**y`.
3913         // But this is confusing: `-(x**y)` OR `(-x)**y`, which interpretation is correct?
3914         // To avoid this problem, ECMA262 makes unparenthesized exponentiation expression as operand of unary operators an early error.
3915         // More rationale: https://mail.mozilla.org/pipermail/es-discuss/2015-September/044232.html
3916         //
3917         // Here, we guarantee that the left hand side of this expression is not unary expression by checking the leading operator of the parseUnaryExpression.
3918         // This check just works. Let&#39;s consider the example,
3919         //     y &lt;&gt; -x ** z
3920         //          ^
3921         //          Check this.
3922         // If the binary operator &lt;&gt; has higher precedence than one of &quot;**&quot;, this check does not work.
3923         // But it&#39;s OK for ** because the operator &quot;**&quot; has the highest operator precedence in the binary operators.
3924         failIfTrue(match(POW) &amp;&amp; isUnaryOpExcludingUpdateOp(leadingTokenTypeForUnaryExpression), &quot;Ambiguous unary expression in the left hand side of the exponentiation expression; parentheses must be used to disambiguate the expression&quot;);
3925 
<span class="line-modified">3926         // Mixing ?? with || or &amp;&amp; is currently specified as an early error.</span>
<span class="line-modified">3927         // Since ?? is the lowest-precedence binary operator, it suffices to check whether these ever coexist in the operator stack.</span>
<span class="line-modified">3928         if (match(AND) || match(OR))</span>
<span class="line-added">3929             hasLogicalOperator = true;</span>
<span class="line-added">3930         else if (match(COALESCE))</span>
<span class="line-added">3931             hasCoalesceOperator = true;</span>
<span class="line-added">3932         failIfTrue(hasLogicalOperator &amp;&amp; hasCoalesceOperator, &quot;Coalescing and logical operators used together in the same expression; parentheses must be used to disambiguate&quot;);</span>
<span class="line-added">3933 </span>
3934         m_parserState.nonTrivialExpressionCount++;
3935         m_parserState.nonLHSCount++;
3936         int operatorToken = m_token.m_type;
3937         next(TreeBuilder::DontBuildStrings);
3938 
3939         while (operatorStackDepth &amp;&amp; context.operatorStackShouldReduce(precedence)) {
3940             ASSERT(operandStackDepth &gt; 1);
3941 
3942             typename TreeBuilder::BinaryOperand rhs = context.getFromOperandStack(-1);
3943             typename TreeBuilder::BinaryOperand lhs = context.getFromOperandStack(-2);
3944             context.shrinkOperandStackBy(operandStackDepth, 2);
3945             context.appendBinaryOperation(location, operandStackDepth, operatorStackDepth, lhs, rhs);
3946             context.operatorStackPop(operatorStackDepth);
3947         }
3948         context.operatorStackAppend(operatorStackDepth, operatorToken, precedence);
3949     }
3950     while (operatorStackDepth) {
3951         ASSERT(operandStackDepth &gt; 1);
3952 
3953         typename TreeBuilder::BinaryOperand rhs = context.getFromOperandStack(-1);
3954         typename TreeBuilder::BinaryOperand lhs = context.getFromOperandStack(-2);
3955         context.shrinkOperandStackBy(operandStackDepth, 2);
3956         context.appendBinaryOperation(location, operandStackDepth, operatorStackDepth, lhs, rhs);
3957         context.operatorStackPop(operatorStackDepth);
3958     }
3959     return context.popOperandStack(operandStackDepth);
3960 }
3961 
3962 template &lt;typename LexerType&gt;
3963 template &lt;class TreeBuilder&gt; TreeProperty Parser&lt;LexerType&gt;::parseProperty(TreeBuilder&amp; context, bool complete)
3964 {
3965     SourceParseMode parseMode = SourceParseMode::MethodMode;
3966     bool wasIdent = false;
3967 
3968     if (consume(TIMES))
3969         parseMode = SourceParseMode::GeneratorWrapperMethodMode;
3970 
3971 parseProperty:
3972     switch (m_token.m_type) {
3973     case IDENT:
<span class="line-modified">3974         if (UNLIKELY(*m_token.m_data.ident == m_vm.propertyNames-&gt;async &amp;&amp; !m_token.m_data.escaped)) {</span>
3975             if (parseMode == SourceParseMode::MethodMode) {
3976                 SavePoint savePoint = createSavePoint();
3977                 next();
3978 
3979                 if (match(COLON) || match(OPENPAREN) || match(COMMA) || match(CLOSEBRACE)) {
3980                     restoreSavePoint(savePoint);
3981                     wasIdent = true;
3982                     goto namedProperty;
3983                 }
3984 
3985                 failIfTrue(m_lexer-&gt;hasLineTerminatorBeforeToken(), &quot;Expected a property name following keyword &#39;async&#39;&quot;);
3986                 if (UNLIKELY(consume(TIMES)))
3987                     parseMode = SourceParseMode::AsyncGeneratorWrapperMethodMode;
3988                 else
3989                     parseMode = SourceParseMode::AsyncMethodMode;
3990                 goto parseProperty;
3991             }
3992         }
3993         FALLTHROUGH;
3994     case YIELD:
3995     case AWAIT:
3996         wasIdent = true;
3997         FALLTHROUGH;
3998     case STRING: {
3999 namedProperty:
4000         const Identifier* ident = m_token.m_data.ident;
4001         unsigned getterOrSetterStartOffset = tokenStart();
4002         JSToken identToken = m_token;
4003 
<span class="line-modified">4004         if (complete || (wasIdent &amp;&amp; !isGeneratorMethodParseMode(parseMode)  &amp;&amp; (*ident == m_vm.propertyNames-&gt;get || *ident == m_vm.propertyNames-&gt;set)))</span>
4005             nextExpectIdentifier(LexerFlagsIgnoreReservedWords);
4006         else
4007             nextExpectIdentifier(LexerFlagsIgnoreReservedWords | TreeBuilder::DontBuildKeywords);
4008 
4009         if (!isGeneratorMethodParseMode(parseMode) &amp;&amp; !isAsyncMethodParseMode(parseMode) &amp;&amp; match(COLON)) {
4010             next();
4011             TreeExpression node = parseAssignmentExpressionOrPropagateErrorClass(context);
4012             failIfFalse(node, &quot;Cannot parse expression for property declaration&quot;);
4013             context.setEndOffset(node, m_lexer-&gt;currentOffset());
<span class="line-modified">4014             InferName inferName = ident &amp;&amp; *ident == m_vm.propertyNames-&gt;underscoreProto ? InferName::Disallowed : InferName::Allowed;</span>
4015             return context.createProperty(ident, node, PropertyNode::Constant, PropertyNode::Unknown, complete, SuperBinding::NotNeeded, inferName, ClassElementTag::No);
4016         }
4017 
4018         if (match(OPENPAREN)) {
4019             auto method = parsePropertyMethod(context, ident, parseMode);
4020             propagateError();
4021             return context.createProperty(ident, method, PropertyNode::Constant, PropertyNode::KnownDirect, complete, SuperBinding::Needed, InferName::Allowed, ClassElementTag::No);
4022         }
4023         failIfTrue(parseMode != SourceParseMode::MethodMode, &quot;Expected a parenthesis for argument list&quot;);
4024 
4025         failIfFalse(wasIdent, &quot;Expected an identifier as property name&quot;);
4026 
4027         if (match(COMMA) || match(CLOSEBRACE)) {
4028             semanticFailureDueToKeywordCheckingToken(identToken, &quot;shorthand property name&quot;);
4029             JSTextPosition start = tokenStartPosition();
4030             JSTokenLocation location(tokenLocation());
<span class="line-modified">4031             currentScope()-&gt;useVariable(ident, m_vm.propertyNames-&gt;eval == *ident);</span>
4032             if (currentScope()-&gt;isArrowFunction())
4033                 currentScope()-&gt;setInnerArrowFunctionUsesEval();
4034             TreeExpression node = context.createResolve(location, *ident, start, lastTokenEndPosition());
4035             return context.createProperty(ident, node, static_cast&lt;PropertyNode::Type&gt;(PropertyNode::Constant | PropertyNode::Shorthand), PropertyNode::KnownDirect, complete, SuperBinding::NotNeeded, InferName::Allowed, ClassElementTag::No);
4036         }
4037 
4038         if (match(EQUAL)) // CoverInitializedName is exclusive to BindingPattern and AssignmentPattern
4039             classifyExpressionError(ErrorIndicatesPattern);
4040 
4041         PropertyNode::Type type;
<span class="line-modified">4042         if (*ident == m_vm.propertyNames-&gt;get)</span>
4043             type = PropertyNode::Getter;
<span class="line-modified">4044         else if (*ident == m_vm.propertyNames-&gt;set)</span>
4045             type = PropertyNode::Setter;
4046         else
4047             failWithMessage(&quot;Expected a &#39;:&#39; following the property name &#39;&quot;, ident-&gt;impl(), &quot;&#39;&quot;);
4048         return parseGetterSetter(context, complete, type, getterOrSetterStartOffset, ConstructorKind::None, ClassElementTag::No);
4049     }
4050     case DOUBLE:
4051     case INTEGER: {
4052         double propertyName = m_token.m_data.doubleValue;
4053         next();
4054 
4055         if (match(OPENPAREN)) {
<span class="line-modified">4056             const Identifier&amp; ident = m_parserArena.identifierArena().makeNumericIdentifier(const_cast&lt;VM&amp;&gt;(m_vm), propertyName);</span>
4057             auto method = parsePropertyMethod(context, &amp;ident, parseMode);
4058             propagateError();
4059             return context.createProperty(&amp;ident, method, PropertyNode::Constant, PropertyNode::Unknown, complete, SuperBinding::Needed, InferName::Allowed, ClassElementTag::No);
4060         }
4061         failIfTrue(parseMode != SourceParseMode::MethodMode, &quot;Expected a parenthesis for argument list&quot;);
4062 
4063         consumeOrFail(COLON, &quot;Expected &#39;:&#39; after property name&quot;);
4064         TreeExpression node = parseAssignmentExpression(context);
4065         failIfFalse(node, &quot;Cannot parse expression for property declaration&quot;);
4066         context.setEndOffset(node, m_lexer-&gt;currentOffset());
<span class="line-modified">4067         return context.createProperty(const_cast&lt;VM&amp;&gt;(m_vm), m_parserArena, propertyName, node, PropertyNode::Constant, PropertyNode::Unknown, complete, SuperBinding::NotNeeded, ClassElementTag::No);</span>
4068     }
4069     case OPENBRACKET: {
4070         next();
4071         auto propertyName = parseAssignmentExpression(context);
4072         failIfFalse(propertyName, &quot;Cannot parse computed property name&quot;);
4073         handleProductionOrFail(CLOSEBRACKET, &quot;]&quot;, &quot;end&quot;, &quot;computed property name&quot;);
4074 
4075         if (match(OPENPAREN)) {
<span class="line-modified">4076             auto method = parsePropertyMethod(context, &amp;m_vm.propertyNames-&gt;nullIdentifier, parseMode);</span>
4077             propagateError();
4078             return context.createProperty(propertyName, method, static_cast&lt;PropertyNode::Type&gt;(PropertyNode::Constant | PropertyNode::Computed), PropertyNode::KnownDirect, complete, SuperBinding::Needed, ClassElementTag::No);
4079         }
4080         failIfTrue(parseMode != SourceParseMode::MethodMode, &quot;Expected a parenthesis for argument list&quot;);
4081 
4082         consumeOrFail(COLON, &quot;Expected &#39;:&#39; after property name&quot;);
4083         TreeExpression node = parseAssignmentExpression(context);
4084         failIfFalse(node, &quot;Cannot parse expression for property declaration&quot;);
4085         context.setEndOffset(node, m_lexer-&gt;currentOffset());
4086         return context.createProperty(propertyName, node, static_cast&lt;PropertyNode::Type&gt;(PropertyNode::Constant | PropertyNode::Computed), PropertyNode::Unknown, complete, SuperBinding::NotNeeded, ClassElementTag::No);
4087     }
4088     case DOTDOTDOT: {
4089         auto spreadLocation = m_token.m_location;
4090         auto start = m_token.m_startPosition;
4091         auto divot = m_token.m_endPosition;
4092         next();
4093         TreeExpression elem = parseAssignmentExpressionOrPropagateErrorClass(context);
4094         failIfFalse(elem, &quot;Cannot parse subject of a spread operation&quot;);
4095         auto node = context.createObjectSpreadExpression(spreadLocation, elem, start, divot, m_lastTokenEndPosition);
4096         return context.createProperty(node, PropertyNode::Spread, PropertyNode::Unknown, complete, SuperBinding::NotNeeded, ClassElementTag::No);
</pre>
<hr />
<pre>
4109     JSTokenLocation methodLocation(tokenLocation());
4110     unsigned methodStart = tokenStart();
4111     ParserFunctionInfo&lt;TreeBuilder&gt; methodInfo;
4112     methodInfo.name = methodName;
4113     failIfFalse((parseFunctionInfo(context, FunctionNameRequirements::Unnamed, parseMode, false, ConstructorKind::None, SuperBinding::Needed, methodStart, methodInfo, FunctionDefinitionType::Method)), &quot;Cannot parse this method&quot;);
4114     return context.createMethodDefinition(methodLocation, methodInfo);
4115 }
4116 
4117 template &lt;typename LexerType&gt;
4118 template &lt;class TreeBuilder&gt; TreeProperty Parser&lt;LexerType&gt;::parseGetterSetter(TreeBuilder&amp; context, bool strict, PropertyNode::Type type, unsigned getterOrSetterStartOffset,
4119     ConstructorKind constructorKind, ClassElementTag tag)
4120 {
4121     const Identifier* stringPropertyName = 0;
4122     double numericPropertyName = 0;
4123     TreeExpression computedPropertyName = 0;
4124 
4125     JSTokenLocation location(tokenLocation());
4126 
4127     if (matchSpecIdentifier() || match(STRING) || m_token.m_type &amp; KeywordTokenFlag) {
4128         stringPropertyName = m_token.m_data.ident;
<span class="line-modified">4129         semanticFailIfTrue(tag == ClassElementTag::Static &amp;&amp; *stringPropertyName == m_vm.propertyNames-&gt;prototype,</span>
4130             &quot;Cannot declare a static method named &#39;prototype&#39;&quot;);
<span class="line-modified">4131         semanticFailIfTrue(tag == ClassElementTag::Instance &amp;&amp; *stringPropertyName == m_vm.propertyNames-&gt;constructor,</span>
4132             &quot;Cannot declare a getter or setter named &#39;constructor&#39;&quot;);
4133         next();
4134     } else if (match(DOUBLE) || match(INTEGER)) {
4135         numericPropertyName = m_token.m_data.doubleValue;
4136         next();
4137     } else if (match(OPENBRACKET)) {
4138         next();
4139         computedPropertyName = parseAssignmentExpression(context);
4140         failIfFalse(computedPropertyName, &quot;Cannot parse computed property name&quot;);
4141         handleProductionOrFail(CLOSEBRACKET, &quot;]&quot;, &quot;end&quot;, &quot;computed property name&quot;);
4142     } else
4143         failDueToUnexpectedToken();
4144 
4145     ParserFunctionInfo&lt;TreeBuilder&gt; info;
4146     if (type &amp; PropertyNode::Getter) {
4147         failIfFalse(match(OPENPAREN), &quot;Expected a parameter list for getter definition&quot;);
4148         failIfFalse((parseFunctionInfo(context, FunctionNameRequirements::Unnamed, SourceParseMode::GetterMode, false, constructorKind, SuperBinding::Needed, getterOrSetterStartOffset, info, FunctionDefinitionType::Method)), &quot;Cannot parse getter definition&quot;);
4149     } else {
4150         failIfFalse(match(OPENPAREN), &quot;Expected a parameter list for setter definition&quot;);
4151         failIfFalse((parseFunctionInfo(context, FunctionNameRequirements::Unnamed, SourceParseMode::SetterMode, false, constructorKind, SuperBinding::Needed, getterOrSetterStartOffset, info, FunctionDefinitionType::Method)), &quot;Cannot parse setter definition&quot;);
4152     }
4153 
4154     if (stringPropertyName)
4155         return context.createGetterOrSetterProperty(location, type, strict, stringPropertyName, info, tag);
4156 
4157     if (computedPropertyName)
4158         return context.createGetterOrSetterProperty(location, static_cast&lt;PropertyNode::Type&gt;(type | PropertyNode::Computed), strict, computedPropertyName, info, tag);
4159 
<span class="line-modified">4160     return context.createGetterOrSetterProperty(const_cast&lt;VM&amp;&gt;(m_vm), m_parserArena, location, type, strict, numericPropertyName, info, tag);</span>
4161 }
4162 
4163 template &lt;typename LexerType&gt;
4164 template &lt;class TreeBuilder&gt; bool Parser&lt;LexerType&gt;::shouldCheckPropertyForUnderscoreProtoDuplicate(TreeBuilder&amp; context, const TreeProperty&amp; property)
4165 {
4166     if (!context.getName(property))
4167         return false;
4168 
4169     // A Constant property that is not a Computed or Shorthand Constant property.
4170     return context.getType(property) == PropertyNode::Constant;
4171 }
4172 
4173 template &lt;typename LexerType&gt;
4174 void Parser&lt;LexerType&gt;::recordPauseLocation(const JSTextPosition&amp; position)
4175 {
4176     if (LIKELY(!m_debuggerParseData))
4177         return;
4178 
4179     if (position.line &lt; 0)
4180         return;
</pre>
<hr />
<pre>
4207     consumeOrFailWithFlags(OPENBRACE, TreeBuilder::DontBuildStrings, &quot;Expected opening &#39;{&#39; at the start of an object literal&quot;);
4208 
4209     int oldNonLHSCount = m_parserState.nonLHSCount;
4210 
4211     JSTokenLocation location(tokenLocation());
4212     if (match(CLOSEBRACE)) {
4213         next();
4214         return context.createObjectLiteral(location);
4215     }
4216 
4217     TreeProperty property = parseProperty(context, false);
4218     failIfFalse(property, &quot;Cannot parse object literal property&quot;);
4219 
4220     if (context.getType(property) &amp; (PropertyNode::Getter | PropertyNode::Setter)) {
4221         restoreSavePoint(savePoint);
4222         return parseStrictObjectLiteral(context);
4223     }
4224 
4225     bool seenUnderscoreProto = false;
4226     if (shouldCheckPropertyForUnderscoreProtoDuplicate(context, property))
<span class="line-modified">4227         seenUnderscoreProto = *context.getName(property) == m_vm.propertyNames-&gt;underscoreProto;</span>
4228 
4229     TreePropertyList propertyList = context.createPropertyList(location, property);
4230     TreePropertyList tail = propertyList;
4231     while (match(COMMA)) {
4232         next(TreeBuilder::DontBuildStrings);
4233         if (match(CLOSEBRACE))
4234             break;
4235         JSTokenLocation propertyLocation(tokenLocation());
4236         property = parseProperty(context, false);
4237         failIfFalse(property, &quot;Cannot parse object literal property&quot;);
4238         if (context.getType(property) &amp; (PropertyNode::Getter | PropertyNode::Setter)) {
4239             restoreSavePoint(savePoint);
4240             return parseStrictObjectLiteral(context);
4241         }
4242         if (shouldCheckPropertyForUnderscoreProtoDuplicate(context, property)) {
<span class="line-modified">4243             if (*context.getName(property) == m_vm.propertyNames-&gt;underscoreProto) {</span>
4244                 semanticFailIfTrue(seenUnderscoreProto, &quot;Attempted to redefine __proto__ property&quot;);
4245                 seenUnderscoreProto = true;
4246             }
4247         }
4248         tail = context.createPropertyList(propertyLocation, property, tail);
4249     }
4250 
4251     location = tokenLocation();
4252     handleProductionOrFail2(CLOSEBRACE, &quot;}&quot;, &quot;end&quot;, &quot;object literal&quot;);
4253 
4254     m_parserState.nonLHSCount = oldNonLHSCount;
4255 
4256     return context.createObjectLiteral(location, propertyList);
4257 }
4258 
4259 template &lt;typename LexerType&gt;
4260 template &lt;class TreeBuilder&gt; TreeExpression Parser&lt;LexerType&gt;::parseStrictObjectLiteral(TreeBuilder&amp; context)
4261 {
4262     consumeOrFail(OPENBRACE, &quot;Expected opening &#39;{&#39; at the start of an object literal&quot;);
4263 
4264     int oldNonLHSCount = m_parserState.nonLHSCount;
4265 
4266     JSTokenLocation location(tokenLocation());
4267     if (match(CLOSEBRACE)) {
4268         next();
4269         return context.createObjectLiteral(location);
4270     }
4271 
4272     TreeProperty property = parseProperty(context, true);
4273     failIfFalse(property, &quot;Cannot parse object literal property&quot;);
4274 
4275     bool seenUnderscoreProto = false;
4276     if (shouldCheckPropertyForUnderscoreProtoDuplicate(context, property))
<span class="line-modified">4277         seenUnderscoreProto = *context.getName(property) == m_vm.propertyNames-&gt;underscoreProto;</span>
4278 
4279     TreePropertyList propertyList = context.createPropertyList(location, property);
4280     TreePropertyList tail = propertyList;
4281     while (match(COMMA)) {
4282         next();
4283         if (match(CLOSEBRACE))
4284             break;
4285         JSTokenLocation propertyLocation(tokenLocation());
4286         property = parseProperty(context, true);
4287         failIfFalse(property, &quot;Cannot parse object literal property&quot;);
4288         if (shouldCheckPropertyForUnderscoreProtoDuplicate(context, property)) {
<span class="line-modified">4289             if (*context.getName(property) == m_vm.propertyNames-&gt;underscoreProto) {</span>
4290                 semanticFailIfTrue(seenUnderscoreProto, &quot;Attempted to redefine __proto__ property&quot;);
4291                 seenUnderscoreProto = true;
4292             }
4293         }
4294         tail = context.createPropertyList(propertyLocation, property, tail);
4295     }
4296 
4297     location = tokenLocation();
4298     handleProductionOrFail2(CLOSEBRACE, &quot;}&quot;, &quot;end&quot;, &quot;object literal&quot;);
4299 
4300     m_parserState.nonLHSCount = oldNonLHSCount;
4301 
4302     return context.createObjectLiteral(location, propertyList);
4303 }
4304 
4305 template &lt;typename LexerType&gt;
4306 template &lt;class TreeBuilder&gt; TreeExpression Parser&lt;LexerType&gt;::parseArrayLiteral(TreeBuilder&amp; context)
4307 {
4308     consumeOrFailWithFlags(OPENBRACKET, TreeBuilder::DontBuildStrings, &quot;Expected an opening &#39;[&#39; at the beginning of an array literal&quot;);
4309 
</pre>
<hr />
<pre>
4364         failIfFalse(elem, &quot;Cannot parse array literal element&quot;);
4365         tail = context.createElementList(tail, elisions, elem);
4366     }
4367 
4368     JSTokenLocation location(tokenLocation());
4369     if (!consume(CLOSEBRACKET)) {
4370         failIfFalse(match(DOTDOTDOT), &quot;Expected either a closing &#39;]&#39; or a &#39;,&#39; following an array element&quot;);
4371         semanticFail(&quot;The &#39;...&#39; operator should come before a target expression&quot;);
4372     }
4373 
4374     m_parserState.nonLHSCount = oldNonLHSCount;
4375 
4376     return context.createArray(location, elementList);
4377 }
4378 
4379 template &lt;typename LexerType&gt;
4380 template &lt;class TreeBuilder&gt; TreeClassExpression Parser&lt;LexerType&gt;::parseClassExpression(TreeBuilder&amp; context)
4381 {
4382     ASSERT(match(CLASSTOKEN));
4383     ParserClassInfo&lt;TreeBuilder&gt; info;
<span class="line-modified">4384     info.className = &amp;m_vm.propertyNames-&gt;nullIdentifier;</span>
4385     return parseClass(context, FunctionNameRequirements::None, info);
4386 }
4387 
4388 template &lt;typename LexerType&gt;
4389 template &lt;class TreeBuilder&gt; TreeExpression Parser&lt;LexerType&gt;::parseFunctionExpression(TreeBuilder&amp; context)
4390 {
4391     ASSERT(match(FUNCTION));
4392     JSTokenLocation location(tokenLocation());
4393     unsigned functionKeywordStart = tokenStart();
4394     next();
4395     ParserFunctionInfo&lt;TreeBuilder&gt; functionInfo;
<span class="line-modified">4396     functionInfo.name = &amp;m_vm.propertyNames-&gt;nullIdentifier;</span>
4397     SourceParseMode parseMode = SourceParseMode::NormalFunctionMode;
4398     if (consume(TIMES))
4399         parseMode = SourceParseMode::GeneratorWrapperFunctionMode;
4400     failIfFalse((parseFunctionInfo(context, FunctionNameRequirements::None, parseMode, false, ConstructorKind::None, SuperBinding::NotNeeded, functionKeywordStart, functionInfo, FunctionDefinitionType::Expression)), &quot;Cannot parse function expression&quot;);
4401     return context.createFunctionExpr(location, functionInfo);
4402 }
4403 
4404 template &lt;typename LexerType&gt;
4405 template &lt;class TreeBuilder&gt; TreeExpression Parser&lt;LexerType&gt;::parseAsyncFunctionExpression(TreeBuilder&amp; context)
4406 {
4407     ASSERT(match(FUNCTION));
4408     JSTokenLocation location(tokenLocation());
4409     unsigned functionKeywordStart = tokenStart();
4410     next();
4411     SourceParseMode parseMode = SourceParseMode::AsyncFunctionMode;
4412 
4413     if (consume(TIMES))
4414         parseMode = SourceParseMode::AsyncGeneratorWrapperFunctionMode;
4415 
4416     ParserFunctionInfo&lt;TreeBuilder&gt; functionInfo;
<span class="line-modified">4417     functionInfo.name = &amp;m_vm.propertyNames-&gt;nullIdentifier;</span>
4418     failIfFalse(parseFunctionInfo(context, FunctionNameRequirements::None, parseMode, false, ConstructorKind::None, SuperBinding::NotNeeded, functionKeywordStart, functionInfo, FunctionDefinitionType::Expression), parseMode == SourceParseMode::AsyncFunctionMode ? &quot;Cannot parse async function expression&quot; : &quot;Cannot parse async generator function expression&quot;);
4419     return context.createFunctionExpr(location, functionInfo);
4420 }
4421 
4422 template &lt;typename LexerType&gt;
4423 template &lt;class TreeBuilder&gt; typename TreeBuilder::TemplateString Parser&lt;LexerType&gt;::parseTemplateString(TreeBuilder&amp; context, bool isTemplateHead, typename LexerType::RawStringsBuildMode rawStringsBuildMode, bool&amp; elementIsTail)
4424 {
4425     if (isTemplateHead)
4426         ASSERT(match(BACKQUOTE));
4427     else
4428         matchOrFail(CLOSEBRACE, &quot;Expected a closing &#39;}&#39; following an expression in template literal&quot;);
4429 
4430     // Re-scan the token to recognize it as Template Element.
4431     m_token.m_type = m_lexer-&gt;scanTemplateString(&amp;m_token, rawStringsBuildMode);
4432     matchOrFail(TEMPLATE, &quot;Expected an template element&quot;);
4433     const Identifier* cooked = m_token.m_data.cooked;
4434     const Identifier* raw = m_token.m_data.raw;
4435     elementIsTail = m_token.m_data.isTail;
4436     JSTokenLocation location(tokenLocation());
4437     next();
</pre>
<hr />
<pre>
4509         TreeExpression result = parseExpression(context);
4510         m_parserState.nonLHSCount = oldNonLHSCount;
4511         handleProductionOrFail(CLOSEPAREN, &quot;)&quot;, &quot;end&quot;, &quot;compound expression&quot;);
4512         return result;
4513     }
4514     case THISTOKEN: {
4515         JSTokenLocation location(tokenLocation());
4516         next();
4517         if (currentScope()-&gt;isArrowFunction())
4518             currentScope()-&gt;setInnerArrowFunctionUsesThis();
4519         return context.createThisExpr(location);
4520     }
4521     case AWAIT:
4522         if (m_parserState.functionParsePhase == FunctionParsePhase::Parameters)
4523             failIfFalse(m_parserState.allowAwait, &quot;Cannot use await expression within parameters&quot;);
4524         else if (currentFunctionScope()-&gt;isAsyncFunctionBoundary())
4525             return parseAwaitExpression(context);
4526 
4527         goto identifierExpression;
4528     case IDENT: {
<span class="line-modified">4529         if (UNLIKELY(*m_token.m_data.ident == m_vm.propertyNames-&gt;async &amp;&amp; !m_token.m_data.escaped)) {</span>
4530             JSTextPosition start = tokenStartPosition();
4531             const Identifier* ident = m_token.m_data.ident;
4532             JSTokenLocation location(tokenLocation());
4533             next();
4534             if (match(FUNCTION) &amp;&amp; !m_lexer-&gt;hasLineTerminatorBeforeToken())
4535                 return parseAsyncFunctionExpression(context);
4536 
4537             // Avoid using variable if it is an arrow function parameter
4538             if (UNLIKELY(match(ARROWFUNCTION)))
4539                 return 0;
4540 
4541             const bool isEval = false;
4542             return createResolveAndUseVariable(context, ident, isEval, start, location);
4543         }
4544     identifierExpression:
4545         JSTextPosition start = tokenStartPosition();
4546         const Identifier* ident = m_token.m_data.ident;
4547         JSTokenLocation location(tokenLocation());
4548         next();
4549 
4550         // Avoid using variable if it is an arrow function parameter
4551         if (UNLIKELY(match(ARROWFUNCTION)))
4552             return 0;
4553 
<span class="line-modified">4554         return createResolveAndUseVariable(context, ident, *ident == m_vm.propertyNames-&gt;eval, start, location);</span>
4555     }
4556     case BIGINT: {
4557         const Identifier* ident = m_token.m_data.bigIntString;
4558         uint8_t radix = m_token.m_data.radix;
4559         JSTokenLocation location(tokenLocation());
4560         next();
4561         return context.createBigInt(location, ident, radix);
4562     }
4563     case STRING: {
4564         const Identifier* ident = m_token.m_data.ident;
4565         JSTokenLocation location(tokenLocation());
4566         next();
4567         return context.createString(location, ident);
4568     }
4569     case DOUBLE: {
4570         double d = m_token.m_data.doubleValue;
4571         JSTokenLocation location(tokenLocation());
4572         next();
4573         return context.createDoubleExpr(location, d);
4574     }
</pre>
<hr />
<pre>
4719     TreeExpression base = 0;
4720     JSTextPosition expressionStart = tokenStartPosition();
4721     int newCount = 0;
4722     JSTokenLocation startLocation = tokenLocation();
4723     JSTokenLocation lastNewTokenLocation;
4724     while (match(NEW)) {
4725         lastNewTokenLocation = tokenLocation();
4726         next();
4727         newCount++;
4728     }
4729     JSTokenLocation location = tokenLocation();
4730 
4731     bool baseIsSuper = match(SUPER);
4732     bool previousBaseWasSuper = false;
4733     bool baseIsImport = match(IMPORT);
4734     semanticFailIfTrue((baseIsSuper || baseIsImport) &amp;&amp; newCount, &quot;Cannot use new with &quot;, getToken());
4735 
4736     bool baseIsNewTarget = false;
4737     if (newCount &amp;&amp; match(DOT)) {
4738         next();
<span class="line-modified">4739         if (matchContextualKeyword(m_vm.propertyNames-&gt;target)) {</span>
4740             ScopeRef closestOrdinaryFunctionScope = closestParentOrdinaryFunctionNonLexicalScope();
4741             semanticFailIfFalse(currentScope()-&gt;isFunction() || closestOrdinaryFunctionScope-&gt;evalContextType() == EvalContextType::FunctionEvalContext, &quot;new.target is only valid inside functions&quot;);
4742             baseIsNewTarget = true;
4743             if (currentScope()-&gt;isArrowFunction()) {
4744                 semanticFailIfFalse(!closestOrdinaryFunctionScope-&gt;isGlobalCodeScope() || closestOrdinaryFunctionScope-&gt;evalContextType() == EvalContextType::FunctionEvalContext, &quot;new.target is not valid inside arrow functions in global code&quot;);
4745                 currentScope()-&gt;setInnerArrowFunctionUsesNewTarget();
4746             }
4747             ASSERT(lastNewTokenLocation.line);
4748             base = context.createNewTargetExpr(lastNewTokenLocation);
4749             newCount--;
4750             next();
4751         } else {
4752             failIfTrue(match(IDENT), &quot;\&quot;new.\&quot; can only followed with target&quot;);
4753             failDueToUnexpectedToken();
4754         }
4755     }
4756 
4757     bool baseIsAsyncKeyword = false;
4758 
4759     if (baseIsSuper) {
4760         ScopeRef closestOrdinaryFunctionScope = closestParentOrdinaryFunctionNonLexicalScope();
4761         semanticFailIfFalse(currentScope()-&gt;isFunction() || (closestOrdinaryFunctionScope-&gt;isEvalContext() &amp;&amp; closestOrdinaryFunctionScope-&gt;expectedSuperBinding() == SuperBinding::Needed), &quot;super is not valid in this context&quot;);
4762         base = context.createSuperExpr(location);
4763         next();
4764         ScopeRef functionScope = currentFunctionScope();
4765         if (!functionScope-&gt;setNeedsSuperBinding()) {
4766             // It unnecessary to check of using super during reparsing one more time. Also it can lead to syntax error
4767             // in case of arrow function because during reparsing we don&#39;t know whether we currently parse the arrow function
4768             // inside of the constructor or method.
4769             if (!m_lexer-&gt;isReparsingFunction()) {
4770                 SuperBinding functionSuperBinding = !functionScope-&gt;isArrowFunction() &amp;&amp; !closestOrdinaryFunctionScope-&gt;isEvalContext()
4771                     ? functionScope-&gt;expectedSuperBinding()
4772                     : closestOrdinaryFunctionScope-&gt;expectedSuperBinding();
4773                 semanticFailIfTrue(functionSuperBinding == SuperBinding::NotNeeded, &quot;super is not valid in this context&quot;);
4774             }
4775         }
4776     } else if (baseIsImport) {
4777         next();
4778         JSTextPosition expressionEnd = lastTokenEndPosition();
4779         if (consume(DOT)) {
<span class="line-modified">4780             if (matchContextualKeyword(m_vm.propertyNames-&gt;builtinNames().metaPublicName())) {</span>
4781                 semanticFailIfFalse(m_scriptMode == JSParserScriptMode::Module, &quot;import.meta is only valid inside modules&quot;);
<span class="line-modified">4782                 base = context.createImportMetaExpr(location, createResolveAndUseVariable(context, &amp;m_vm.propertyNames-&gt;metaPrivateName, false, expressionStart, location));</span>
4783                 next();
4784             } else {
4785                 failIfTrue(match(IDENT), &quot;\&quot;import.\&quot; can only followed with meta&quot;);
4786                 failDueToUnexpectedToken();
4787             }
4788         } else {
4789             consumeOrFail(OPENPAREN, &quot;import call expects exactly one argument&quot;);
4790             TreeExpression expr = parseAssignmentExpression(context);
4791             failIfFalse(expr, &quot;Cannot parse expression&quot;);
4792             consumeOrFail(CLOSEPAREN, &quot;import call expects exactly one argument&quot;);
4793             base = context.createImportExpr(location, expr, expressionStart, expressionEnd, lastTokenEndPosition());
4794         }
4795     } else if (!baseIsNewTarget) {
<span class="line-modified">4796         const bool isAsync = matchContextualKeyword(m_vm.propertyNames-&gt;async);</span>
4797 
4798         base = parsePrimaryExpression(context);
4799         failIfFalse(base, &quot;Cannot parse base expression&quot;);
4800         if (UNLIKELY(isAsync &amp;&amp; context.isResolve(base) &amp;&amp; !m_lexer-&gt;hasLineTerminatorBeforeToken())) {
4801             if (matchSpecIdentifier()) {
4802                 // AsyncArrowFunction
4803                 forceClassifyExpressionError(ErrorIndicatesAsyncArrowFunction);
4804                 failDueToUnexpectedToken();
4805             }
4806             baseIsAsyncKeyword = true;
4807         }
4808     }
4809 
4810     failIfFalse(base, &quot;Cannot parse base expression&quot;);












4811 
<span class="line-modified">4812     do {</span>
<span class="line-modified">4813         TreeExpression optionalChainBase = 0;</span>
<span class="line-added">4814         JSTokenLocation optionalChainLocation;</span>
<span class="line-added">4815         JSTokenType type = m_token.m_type;</span>
<span class="line-added">4816 </span>
<span class="line-added">4817         if (match(QUESTIONDOT)) {</span>
<span class="line-added">4818             semanticFailIfTrue(newCount, &quot;Cannot call constructor in an optional chain&quot;);</span>
<span class="line-added">4819             semanticFailIfTrue(baseIsSuper, &quot;Cannot use super as the base of an optional chain&quot;);</span>
<span class="line-added">4820             optionalChainBase = base;</span>
<span class="line-added">4821             optionalChainLocation = tokenLocation();</span>
4822 
<span class="line-modified">4823             SavePoint savePoint = createSavePoint();</span>
<span class="line-modified">4824             next();</span>
<span class="line-modified">4825             if (match(OPENBRACKET) || match(OPENPAREN) || match(BACKQUOTE))</span>
<span class="line-added">4826                 type = m_token.m_type;</span>
<span class="line-added">4827             else {</span>
<span class="line-added">4828                 type = DOT;</span>
<span class="line-added">4829                 restoreSavePoint(savePoint);</span>
<span class="line-added">4830             }</span>
4831         }
<span class="line-modified">4832 </span>
<span class="line-modified">4833         while (true) {</span>
<span class="line-modified">4834             location = tokenLocation();</span>
<span class="line-modified">4835             switch (type) {</span>
<span class="line-modified">4836             case OPENBRACKET: {</span>
<span class="line-modified">4837                 m_parserState.nonTrivialExpressionCount++;</span>





4838                 JSTextPosition expressionEnd = lastTokenEndPosition();
<span class="line-modified">4839                 next();</span>
<span class="line-modified">4840                 int nonLHSCount = m_parserState.nonLHSCount;</span>
<span class="line-added">4841                 int initialAssignments = m_parserState.assignmentCount;</span>
<span class="line-added">4842                 TreeExpression property = parseExpression(context);</span>
<span class="line-added">4843                 failIfFalse(property, &quot;Cannot parse subscript expression&quot;);</span>
<span class="line-added">4844                 base = context.createBracketAccess(startLocation, base, property, initialAssignments != m_parserState.assignmentCount, expressionStart, expressionEnd, tokenEndPosition());</span>
4845 
<span class="line-modified">4846                 if (UNLIKELY(baseIsSuper &amp;&amp; currentScope()-&gt;isArrowFunction()))</span>
<span class="line-added">4847                     currentFunctionScope()-&gt;setInnerArrowFunctionUsesSuperProperty();</span>
4848 
<span class="line-modified">4849                 handleProductionOrFail(CLOSEBRACKET, &quot;]&quot;, &quot;end&quot;, &quot;subscript expression&quot;);</span>
<span class="line-modified">4850                 m_parserState.nonLHSCount = nonLHSCount;</span>
<span class="line-modified">4851                 break;</span>
<span class="line-modified">4852             }</span>
<span class="line-modified">4853             case OPENPAREN: {</span>
<span class="line-added">4854                 m_parserState.nonTrivialExpressionCount++;</span>
<span class="line-added">4855                 int nonLHSCount = m_parserState.nonLHSCount;</span>
<span class="line-added">4856                 if (newCount) {</span>
<span class="line-added">4857                     newCount--;</span>
<span class="line-added">4858                     JSTextPosition expressionEnd = lastTokenEndPosition();</span>
<span class="line-added">4859                     TreeArguments arguments = parseArguments(context);</span>
<span class="line-added">4860                     failIfFalse(arguments, &quot;Cannot parse call arguments&quot;);</span>
<span class="line-added">4861                     base = context.createNewExpr(location, base, arguments, expressionStart, expressionEnd, lastTokenEndPosition());</span>
<span class="line-added">4862                 } else {</span>
<span class="line-added">4863                     size_t usedVariablesSize = currentScope()-&gt;currentUsedVariablesSize();</span>
<span class="line-added">4864                     JSTextPosition expressionEnd = lastTokenEndPosition();</span>
<span class="line-added">4865                     Optional&lt;CallOrApplyDepthScope&gt; callOrApplyDepthScope;</span>
<span class="line-added">4866                     recordCallOrApplyDepth&lt;TreeBuilder&gt;(this, m_vm, callOrApplyDepthScope, base);</span>
<span class="line-added">4867 </span>
<span class="line-added">4868                     TreeArguments arguments = parseArguments(context);</span>
4869 
<span class="line-modified">4870                     if (baseIsAsyncKeyword &amp;&amp; (!arguments || match(ARROWFUNCTION))) {</span>
<span class="line-modified">4871                         currentScope()-&gt;revertToPreviousUsedVariables(usedVariablesSize);</span>
<span class="line-modified">4872                         forceClassifyExpressionError(ErrorIndicatesAsyncArrowFunction);</span>
<span class="line-modified">4873                         failDueToUnexpectedToken();</span>
<span class="line-modified">4874                     }</span>
<span class="line-modified">4875 </span>
<span class="line-modified">4876                     failIfFalse(arguments, &quot;Cannot parse call arguments&quot;);</span>
<span class="line-modified">4877                     if (baseIsSuper) {</span>
<span class="line-modified">4878                         ScopeRef functionScope = currentFunctionScope();</span>
<span class="line-modified">4879                         if (!functionScope-&gt;setHasDirectSuper()) {</span>
<span class="line-modified">4880                             // It unnecessary to check of using super during reparsing one more time. Also it can lead to syntax error</span>
<span class="line-modified">4881                             // in case of arrow function because during reparsing we don&#39;t know whether we currently parse the arrow function</span>
<span class="line-modified">4882                             // inside of the constructor or method.</span>
<span class="line-modified">4883                             if (!m_lexer-&gt;isReparsingFunction()) {</span>
<span class="line-added">4884                                 ScopeRef closestOrdinaryFunctionScope = closestParentOrdinaryFunctionNonLexicalScope();</span>
<span class="line-added">4885                                 ConstructorKind functionConstructorKind = !functionScope-&gt;isArrowFunction() &amp;&amp; !closestOrdinaryFunctionScope-&gt;isEvalContext()</span>
<span class="line-added">4886                                     ? functionScope-&gt;constructorKind()</span>
<span class="line-added">4887                                     : closestOrdinaryFunctionScope-&gt;constructorKind();</span>
<span class="line-added">4888                                 semanticFailIfTrue(functionConstructorKind == ConstructorKind::None, &quot;super is not valid in this context&quot;);</span>
<span class="line-added">4889                                 semanticFailIfTrue(functionConstructorKind != ConstructorKind::Extends, &quot;super is not valid in this context&quot;);</span>
<span class="line-added">4890                             }</span>
4891                         }
<span class="line-added">4892                         if (currentScope()-&gt;isArrowFunction())</span>
<span class="line-added">4893                             functionScope-&gt;setInnerArrowFunctionUsesSuperCall();</span>
4894                     }
<span class="line-modified">4895 </span>
<span class="line-modified">4896                     bool isOptionalCall = optionalChainLocation.endOffset == static_cast&lt;unsigned&gt;(expressionEnd.offset);</span>
<span class="line-added">4897                     base = context.makeFunctionCallNode(startLocation, base, previousBaseWasSuper, arguments, expressionStart,</span>
<span class="line-added">4898                         expressionEnd, lastTokenEndPosition(), callOrApplyDepthScope ? callOrApplyDepthScope-&gt;distanceToInnermostChild() : 0, isOptionalCall);</span>
<span class="line-added">4899 </span>
<span class="line-added">4900                     if (isOptionalCall)</span>
<span class="line-added">4901                         optionalChainBase = base;</span>
4902                 }
<span class="line-modified">4903                 m_parserState.nonLHSCount = nonLHSCount;</span>
<span class="line-modified">4904                 break;</span>
4905             }
<span class="line-modified">4906             case DOT: {</span>
<span class="line-modified">4907                 m_parserState.nonTrivialExpressionCount++;</span>
<span class="line-modified">4908                 JSTextPosition expressionEnd = lastTokenEndPosition();</span>
<span class="line-modified">4909                 nextExpectIdentifier(LexerFlagsIgnoreReservedWords | TreeBuilder::DontBuildKeywords);</span>
<span class="line-modified">4910                 matchOrFail(IDENT, &quot;Expected a property name after &quot;, optionalChainBase ? &quot;&#39;?.&#39;&quot; : &quot;&#39;.&#39;&quot;);</span>
<span class="line-modified">4911                 base = context.createDotAccess(startLocation, base, m_token.m_data.ident, expressionStart, expressionEnd, tokenEndPosition());</span>
<span class="line-modified">4912                 if (UNLIKELY(baseIsSuper &amp;&amp; currentScope()-&gt;isArrowFunction()))</span>
<span class="line-modified">4913                     currentFunctionScope()-&gt;setInnerArrowFunctionUsesSuperProperty();</span>
<span class="line-modified">4914                 next();</span>
<span class="line-modified">4915                 break;</span>
<span class="line-modified">4916             }</span>
<span class="line-modified">4917             case BACKQUOTE: {</span>
<span class="line-modified">4918                 semanticFailIfTrue(optionalChainBase, &quot;Cannot use tagged templates in an optional chain&quot;);</span>
<span class="line-modified">4919                 semanticFailIfTrue(baseIsSuper, &quot;Cannot use super as tag for tagged templates&quot;);</span>
<span class="line-modified">4920                 JSTextPosition expressionEnd = lastTokenEndPosition();</span>
<span class="line-modified">4921                 int nonLHSCount = m_parserState.nonLHSCount;</span>
<span class="line-modified">4922                 typename TreeBuilder::TemplateLiteral templateLiteral = parseTemplateLiteral(context, LexerType::RawStringsBuildMode::BuildRawStrings);</span>
<span class="line-modified">4923                 failIfFalse(templateLiteral, &quot;Cannot parse template literal&quot;);</span>
<span class="line-modified">4924                 base = context.createTaggedTemplate(startLocation, base, templateLiteral, expressionStart, expressionEnd, lastTokenEndPosition());</span>
<span class="line-modified">4925                 m_parserState.nonLHSCount = nonLHSCount;</span>
<span class="line-modified">4926                 m_seenTaggedTemplate = true;</span>
<span class="line-modified">4927                 break;</span>
<span class="line-modified">4928             }</span>
<span class="line-modified">4929             default:</span>
<span class="line-modified">4930                 goto endOfChain;</span>
<span class="line-modified">4931             }</span>
<span class="line-modified">4932             previousBaseWasSuper = baseIsSuper;</span>
<span class="line-added">4933             baseIsSuper = false;</span>
<span class="line-added">4934             type = m_token.m_type;</span>
4935         }
<span class="line-modified">4936 endOfChain:</span>
<span class="line-modified">4937         if (optionalChainBase)</span>
<span class="line-modified">4938             base = context.createOptionalChain(optionalChainLocation, optionalChainBase, base, !match(QUESTIONDOT));</span>
<span class="line-modified">4939     } while (match(QUESTIONDOT));</span>
<span class="line-added">4940 </span>
4941     semanticFailIfTrue(baseIsSuper, &quot;super is not valid in this context&quot;);
4942     while (newCount--)
4943         base = context.createNewExpr(location, base, expressionStart, lastTokenEndPosition());
4944     return base;
4945 }
4946 
4947 template &lt;typename LexerType&gt;
4948 template &lt;class TreeBuilder&gt; TreeExpression Parser&lt;LexerType&gt;::parseArrowFunctionExpression(TreeBuilder&amp; context, bool isAsync)
4949 {
4950     JSTokenLocation location;
4951 
4952     unsigned functionKeywordStart = tokenStart();
4953     location = tokenLocation();
4954     ParserFunctionInfo&lt;TreeBuilder&gt; info;
<span class="line-modified">4955     info.name = &amp;m_vm.propertyNames-&gt;nullIdentifier;</span>
4956 
4957     SourceParseMode parseMode = isAsync ? SourceParseMode::AsyncArrowFunctionMode : SourceParseMode::ArrowFunctionMode;
4958     failIfFalse((parseFunctionInfo(context, FunctionNameRequirements::Unnamed, parseMode, true, ConstructorKind::None, SuperBinding::NotNeeded, functionKeywordStart, info, FunctionDefinitionType::Expression)), &quot;Cannot parse arrow function expression&quot;);
4959 
4960     return context.createArrowFunctionExpr(location, info);
4961 }
4962 
4963 static const char* operatorString(bool prefix, unsigned tok)
4964 {
4965     switch (tok) {
4966     case MINUSMINUS:
4967     case AUTOMINUSMINUS:
4968         return prefix ? &quot;prefix-decrement&quot; : &quot;decrement&quot;;
4969 
4970     case PLUSPLUS:
4971     case AUTOPLUSPLUS:
4972         return prefix ? &quot;prefix-increment&quot; : &quot;increment&quot;;
4973 
4974     case EXCLAMATION:
4975         return &quot;logical-not&quot;;
</pre>
<hr />
<pre>
4979 
4980     case TYPEOF:
4981         return &quot;typeof&quot;;
4982 
4983     case VOIDTOKEN:
4984         return &quot;void&quot;;
4985 
4986     case DELETETOKEN:
4987         return &quot;delete&quot;;
4988     }
4989     RELEASE_ASSERT_NOT_REACHED();
4990     return &quot;error&quot;;
4991 }
4992 
4993 template &lt;typename LexerType&gt;
4994 template &lt;class TreeBuilder&gt; TreeExpression Parser&lt;LexerType&gt;::parseUnaryExpression(TreeBuilder&amp; context)
4995 {
4996     typename TreeBuilder::UnaryExprContext unaryExprContext(context);
4997     AllowInOverride allowInOverride(this);
4998     int tokenStackDepth = 0;
<span class="line-modified">4999     bool hasPrefixUpdateOp = false;</span>

5000     unsigned lastOperator = 0;
5001 
5002     if (UNLIKELY(match(AWAIT) &amp;&amp; currentFunctionScope()-&gt;isAsyncFunctionBoundary()))
5003         return parseAwaitExpression(context);
5004 
5005     JSTokenLocation location(tokenLocation());
5006 
5007     while (isUnaryOp(m_token.m_type)) {
<span class="line-modified">5008         switch (m_token.m_type) {</span>
<span class="line-modified">5009         case PLUSPLUS:</span>
<span class="line-modified">5010         case MINUSMINUS:</span>
<span class="line-modified">5011         case AUTOPLUSPLUS:</span>
<span class="line-modified">5012         case AUTOMINUSMINUS:</span>
<span class="line-modified">5013             semanticFailIfTrue(hasPrefixUpdateOp, &quot;The &quot;, operatorString(true, lastOperator), &quot; operator requires a reference expression&quot;);</span>
<span class="line-modified">5014             hasPrefixUpdateOp = true;</span>
<span class="line-modified">5015             break;</span>
<span class="line-modified">5016         default:</span>
<span class="line-modified">5017             semanticFailIfTrue(hasPrefixUpdateOp, &quot;The &quot;, operatorString(true, lastOperator), &quot; operator requires a reference expression&quot;);</span>
<span class="line-modified">5018             break;</span>



5019         }
5020         lastOperator = m_token.m_type;
5021         m_parserState.nonLHSCount++;
5022         context.appendUnaryToken(tokenStackDepth, m_token.m_type, tokenStartPosition());
5023         next();
5024         m_parserState.nonTrivialExpressionCount++;
5025     }
5026     JSTextPosition subExprStart = tokenStartPosition();
5027     ASSERT(subExprStart.offset &gt;= subExprStart.lineStartOffset);
5028     TreeExpression expr = parseMemberExpression(context);
5029     if (!expr) {
5030         if (lastOperator)
5031             failWithMessage(&quot;Cannot parse subexpression of &quot;, operatorString(true, lastOperator), &quot;operator&quot;);
5032         failWithMessage(&quot;Cannot parse member expression&quot;);
5033     }
<span class="line-modified">5034     if (isUpdateOp(static_cast&lt;JSTokenType&gt;(lastOperator))) {</span>
<span class="line-modified">5035         semanticFailIfTrue(context.isMetaProperty(expr), metaPropertyName(context, expr), &quot; can&#39;t come after a prefix operator&quot;);</span>
<span class="line-added">5036         semanticFailIfFalse(isSimpleAssignmentTarget(context, expr), &quot;Prefix &quot;, lastOperator == PLUSPLUS ? &quot;++&quot; : &quot;--&quot;, &quot; operator applied to value that is not a reference&quot;);</span>
<span class="line-added">5037     }</span>
5038     bool isEvalOrArguments = false;
5039     if (strictMode()) {
5040         if (context.isResolve(expr))
<span class="line-modified">5041             isEvalOrArguments = *m_parserState.lastIdentifier == m_vm.propertyNames-&gt;eval || *m_parserState.lastIdentifier == m_vm.propertyNames-&gt;arguments;</span>
5042     }
<span class="line-modified">5043     failIfTrueIfStrict(isEvalOrArguments &amp;&amp; hasPrefixUpdateOp, &quot;Cannot modify &#39;&quot;, m_parserState.lastIdentifier-&gt;impl(), &quot;&#39; in strict mode&quot;);</span>
5044     switch (m_token.m_type) {
5045     case PLUSPLUS:
<span class="line-modified">5046         semanticFailIfTrue(context.isMetaProperty(expr), metaPropertyName(context, expr), &quot; can&#39;t come before a postfix operator&quot;);</span>
<span class="line-modified">5047         semanticFailIfFalse(isSimpleAssignmentTarget(context, expr), &quot;Postfix ++ operator applied to value that is not a reference&quot;);</span>
5048         m_parserState.nonTrivialExpressionCount++;
5049         m_parserState.nonLHSCount++;
5050         expr = context.makePostfixNode(location, expr, OpPlusPlus, subExprStart, lastTokenEndPosition(), tokenEndPosition());
5051         m_parserState.assignmentCount++;
5052         failIfTrueIfStrict(isEvalOrArguments, &quot;Cannot modify &#39;&quot;, m_parserState.lastIdentifier-&gt;impl(), &quot;&#39; in strict mode&quot;);
<span class="line-modified">5053         semanticFailIfTrue(hasPrefixUpdateOp, &quot;The &quot;, operatorString(false, lastOperator), &quot; operator requires a reference expression&quot;);</span>

5054         next();
5055         break;
5056     case MINUSMINUS:
<span class="line-modified">5057         semanticFailIfTrue(context.isMetaProperty(expr), metaPropertyName(context, expr), &quot; can&#39;t come before a postfix operator&quot;);</span>
<span class="line-modified">5058         semanticFailIfFalse(isSimpleAssignmentTarget(context, expr), &quot;Postfix -- operator applied to value that is not a reference&quot;);</span>
5059         m_parserState.nonTrivialExpressionCount++;
5060         m_parserState.nonLHSCount++;
5061         expr = context.makePostfixNode(location, expr, OpMinusMinus, subExprStart, lastTokenEndPosition(), tokenEndPosition());
5062         m_parserState.assignmentCount++;
5063         failIfTrueIfStrict(isEvalOrArguments, &quot;&#39;&quot;, m_parserState.lastIdentifier-&gt;impl(), &quot;&#39; cannot be modified in strict mode&quot;);
<span class="line-modified">5064         semanticFailIfTrue(hasPrefixUpdateOp, &quot;The &quot;, operatorString(false, lastOperator), &quot; operator requires a reference expression&quot;);</span>

5065         next();
5066         break;
5067     default:
5068         break;
5069     }
5070 
5071     JSTextPosition end = lastTokenEndPosition();




5072     while (tokenStackDepth) {
5073         switch (context.unaryTokenStackLastType(tokenStackDepth)) {
5074         case EXCLAMATION:
5075             expr = context.createLogicalNot(location, expr);
5076             break;
5077         case TILDE:
5078             expr = context.makeBitwiseNotNode(location, expr);
5079             break;
5080         case MINUS:
5081             expr = context.makeNegateNode(location, expr);
5082             break;
5083         case PLUS:
5084             expr = context.createUnaryPlus(location, expr);
5085             break;
5086         case PLUSPLUS:
5087         case AUTOPLUSPLUS:
5088             expr = context.makePrefixNode(location, expr, OpPlusPlus, context.unaryTokenStackLastStart(tokenStackDepth), subExprStart + 1, end);
5089             m_parserState.assignmentCount++;
5090             break;
5091         case MINUSMINUS:
</pre>
</td>
</tr>
</table>
<center><a href="Nodes.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Parser.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>