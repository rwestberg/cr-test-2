<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/DatePrototype.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="DateConversion.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DirectArguments.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/DatePrototype.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
   2  *  Copyright (C) 1999-2000 Harri Porten (porten@kde.org)
<span class="line-modified">   3  *  Copyright (C) 2004-2008, 2016 Apple Inc. All rights reserved.</span>
   4  *  Copyright (C) 2008, 2009 Torch Mobile, Inc. All rights reserved.
   5  *  Copyright (C) 2010 Torch Mobile (Beijing) Co. Ltd. All rights reserved.
   6  *
   7  *  This library is free software; you can redistribute it and/or
   8  *  modify it under the terms of the GNU Lesser General Public
   9  *  License as published by the Free Software Foundation; either
  10  *  version 2 of the License, or (at your option) any later version.
  11  *
  12  *  This library is distributed in the hope that it will be useful,
  13  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  14  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  15  *  Lesser General Public License for more details.
  16  *
  17  *  You should have received a copy of the GNU Lesser General Public
  18  *  License along with this library; if not, write to the Free Software
  19  *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301
  20  *  USA
  21  *
  22  */
  23 
</pre>
<hr />
<pre>
 127 #if OS(DARWIN) &amp;&amp; USE(CF)
 128 
 129 // FIXME: Since this is superior to the strftime-based version, why limit this to OS(DARWIN)?
 130 // Instead we should consider using this whenever USE(CF) is true.
 131 
 132 static CFDateFormatterStyle styleFromArgString(const String&amp; string, CFDateFormatterStyle defaultStyle)
 133 {
 134     if (string == &quot;short&quot;)
 135         return kCFDateFormatterShortStyle;
 136     if (string == &quot;medium&quot;)
 137         return kCFDateFormatterMediumStyle;
 138     if (string == &quot;long&quot;)
 139         return kCFDateFormatterLongStyle;
 140     if (string == &quot;full&quot;)
 141         return kCFDateFormatterFullStyle;
 142     return defaultStyle;
 143 }
 144 
 145 static JSCell* formatLocaleDate(ExecState* exec, DateInstance*, double timeInMilliseconds, LocaleDateTimeFormat format)
 146 {

 147     CFDateFormatterStyle dateStyle = (format != LocaleTime ? kCFDateFormatterLongStyle : kCFDateFormatterNoStyle);
 148     CFDateFormatterStyle timeStyle = (format != LocaleDate ? kCFDateFormatterLongStyle : kCFDateFormatterNoStyle);
 149 
 150     bool useCustomFormat = false;
 151     String customFormatString;
 152 
 153     String arg0String = exec-&gt;argument(0).toWTFString(exec);
 154     if (arg0String == &quot;custom&quot; &amp;&amp; !exec-&gt;argument(1).isUndefined()) {
 155         useCustomFormat = true;
 156         customFormatString = exec-&gt;argument(1).toWTFString(exec);
 157     } else if (format == LocaleDateAndTime &amp;&amp; !exec-&gt;argument(1).isUndefined()) {
 158         dateStyle = styleFromArgString(arg0String, dateStyle);
 159         timeStyle = styleFromArgString(exec-&gt;argument(1).toWTFString(exec), timeStyle);
 160     } else if (format != LocaleTime &amp;&amp; !exec-&gt;argument(0).isUndefined())
 161         dateStyle = styleFromArgString(arg0String, dateStyle);
 162     else if (format != LocaleDate &amp;&amp; !exec-&gt;argument(0).isUndefined())
 163         timeStyle = styleFromArgString(arg0String, timeStyle);
 164 
 165     CFAbsoluteTime absoluteTime = floor(timeInMilliseconds / msPerSecond) - kCFAbsoluteTimeIntervalSince1970;
 166 
 167     auto formatter = adoptCF(CFDateFormatterCreate(kCFAllocatorDefault, adoptCF(CFLocaleCopyCurrent()).get(), dateStyle, timeStyle));
 168     if (useCustomFormat)
 169         CFDateFormatterSetFormat(formatter.get(), customFormatString.createCFString().get());
<span class="line-modified"> 170     return jsNontrivialString(exec, adoptCF(CFDateFormatterCreateStringWithAbsoluteTime(kCFAllocatorDefault, formatter.get(), absoluteTime)).get());</span>
 171 }
 172 
 173 #elif !UCONFIG_NO_FORMATTING
 174 
 175 static JSCell* formatLocaleDate(ExecState* exec, DateInstance*, double timeInMilliseconds, LocaleDateTimeFormat format)
 176 {

 177     UDateFormatStyle timeStyle = (format != LocaleDate ? UDAT_LONG : UDAT_NONE);
 178     UDateFormatStyle dateStyle = (format != LocaleTime ? UDAT_LONG : UDAT_NONE);
 179 
 180     UErrorCode status = U_ZERO_ERROR;
 181     UDateFormat* df = udat_open(timeStyle, dateStyle, 0, 0, -1, 0, 0, &amp;status);
 182     if (!df)
<span class="line-modified"> 183         return jsEmptyString(exec);</span>
 184 
 185     UChar buffer[128];
 186     int32_t length;
 187     length = udat_format(df, timeInMilliseconds, buffer, 128, 0, &amp;status);
 188     udat_close(df);
 189     if (status != U_ZERO_ERROR)
<span class="line-modified"> 190         return jsEmptyString(exec);</span>
 191 
<span class="line-modified"> 192     return jsNontrivialString(exec, String(buffer, length));</span>
 193 }
 194 
 195 #else
 196 
 197 static JSCell* formatLocaleDate(ExecState* exec, const GregorianDateTime&amp; gdt, LocaleDateTimeFormat format)
 198 {

 199 #if OS(WINDOWS)
 200     SYSTEMTIME systemTime;
 201     memset(&amp;systemTime, 0, sizeof(systemTime));
 202     systemTime.wYear = gdt.year();
 203     systemTime.wMonth = gdt.month() + 1;
 204     systemTime.wDay = gdt.monthDay();
 205     systemTime.wDayOfWeek = gdt.weekDay();
 206     systemTime.wHour = gdt.hour();
 207     systemTime.wMinute = gdt.minute();
 208     systemTime.wSecond = gdt.second();
 209 
 210     Vector&lt;UChar, 128&gt; buffer;
 211     size_t length = 0;
 212 
 213     if (format == LocaleDate) {
 214         buffer.resize(GetDateFormatW(LOCALE_USER_DEFAULT, DATE_LONGDATE, &amp;systemTime, 0, 0, 0));
 215         length = GetDateFormatW(LOCALE_USER_DEFAULT, DATE_LONGDATE, &amp;systemTime, 0, buffer.data(), buffer.size());
 216     } else if (format == LocaleTime) {
 217         buffer.resize(GetTimeFormatW(LOCALE_USER_DEFAULT, 0, &amp;systemTime, 0, 0, 0));
 218         length = GetTimeFormatW(LOCALE_USER_DEFAULT, 0, &amp;systemTime, 0, buffer.data(), buffer.size());
 219     } else if (format == LocaleDateAndTime) {
 220         buffer.resize(GetDateFormatW(LOCALE_USER_DEFAULT, DATE_LONGDATE, &amp;systemTime, 0, 0, 0) + GetTimeFormatW(LOCALE_USER_DEFAULT, 0, &amp;systemTime, 0, 0, 0));
 221         length = GetDateFormatW(LOCALE_USER_DEFAULT, DATE_LONGDATE, &amp;systemTime, 0, buffer.data(), buffer.size());
 222         if (length) {
 223             buffer[length - 1] = &#39; &#39;;
 224             length += GetTimeFormatW(LOCALE_USER_DEFAULT, 0, &amp;systemTime, 0, buffer.data() + length, buffer.size() - length);
 225         }
 226     } else
 227         RELEASE_ASSERT_NOT_REACHED();
 228 
 229     //  Remove terminating null character.
 230     if (length)
 231         length--;
 232 
<span class="line-modified"> 233     return jsNontrivialString(exec, String(buffer.data(), length));</span>
 234 
 235 #else // OS(WINDOWS)
 236 
 237 #if HAVE(LANGINFO_H)
 238     static const nl_item formats[] = { D_T_FMT, D_FMT, T_FMT };
 239 #else
 240     static const char* const formatStrings[] = { &quot;%#c&quot;, &quot;%#x&quot;, &quot;%X&quot; };
 241 #endif
 242 
 243     // Offset year if needed
 244     struct tm localTM = gdt;
 245     int year = gdt.year();
 246     bool yearNeedsOffset = year &lt; 1900 || year &gt; 2038;
 247     if (yearNeedsOffset)
 248         localTM.tm_year = equivalentYearForDST(year) - 1900;
 249 
 250 #if HAVE(LANGINFO_H)
 251     // We do not allow strftime to generate dates with 2-digits years,
 252     // both to avoid ambiguity, and a crash in strncpy, for years that
 253     // need offset.
 254     char* formatString = strdup(nl_langinfo(formats[format]));
 255     char* yPos = strchr(formatString, &#39;y&#39;);
 256     if (yPos)
 257         *yPos = &#39;Y&#39;;
 258 #endif
 259 
 260     // Do the formatting
 261     const int bufsize = 128;
 262     char timebuffer[bufsize];
 263 
 264 #if HAVE(LANGINFO_H)
 265     size_t ret = strftime(timebuffer, bufsize, formatString, &amp;localTM);
 266     free(formatString);
 267 #else
 268     size_t ret = strftime(timebuffer, bufsize, formatStrings[format], &amp;localTM);
 269 #endif
 270 
 271     if (ret == 0)
<span class="line-modified"> 272         return jsEmptyString(exec);</span>
 273 
 274     // Copy original into the buffer
 275     if (yearNeedsOffset &amp;&amp; format != LocaleTime) {
 276         static const int yearLen = 5;   // FIXME will be a problem in the year 10,000
 277         char yearString[yearLen];
 278 
 279         snprintf(yearString, yearLen, &quot;%d&quot;, localTM.tm_year + 1900);
 280         char* yearLocation = strstr(timebuffer, yearString);
 281         snprintf(yearString, yearLen, &quot;%d&quot;, year);
 282 
 283         strncpy(yearLocation, yearString, yearLen - 1);
 284     }
 285 
 286     // Convert multi-byte result to UNICODE.
 287     // If __STDC_ISO_10646__ is defined, wide character represents
 288     // UTF-16 (or UTF-32) code point. In most modern Unix like system
 289     // (e.g. Linux with glibc 2.2 and above) the macro is defined,
 290     // and wide character represents UTF-32 code point.
 291     // Here we static_cast potential UTF-32 to UTF-16, it should be
 292     // safe because date and (or) time related characters in different languages
 293     // should be in UNICODE BMP. If mbstowcs fails, we just fall
 294     // back on using multi-byte result as-is.
 295 #ifdef __STDC_ISO_10646__
 296     UChar buffer[bufsize];
 297     wchar_t tempbuffer[bufsize];
 298     size_t length = mbstowcs(tempbuffer, timebuffer, bufsize - 1);
 299     if (length != static_cast&lt;size_t&gt;(-1)) {
 300         for (size_t i = 0; i &lt; length; ++i)
 301             buffer[i] = static_cast&lt;UChar&gt;(tempbuffer[i]);
<span class="line-modified"> 302         return jsNontrivialString(exec, String(buffer, length));</span>
 303     }
 304 #endif
 305 
<span class="line-modified"> 306     return jsNontrivialString(exec, timebuffer);</span>
 307 #endif // OS(WINDOWS)
 308 }
 309 
 310 static JSCell* formatLocaleDate(ExecState* exec, DateInstance* dateObject, double, LocaleDateTimeFormat format)
 311 {

 312     const GregorianDateTime* gregorianDateTime = dateObject-&gt;gregorianDateTime(exec);
 313     if (!gregorianDateTime)
<span class="line-modified"> 314         return jsNontrivialString(exec, &quot;Invalid Date&quot;_s);</span>
 315     return formatLocaleDate(exec, *gregorianDateTime, format);
 316 }
 317 
 318 #endif // OS(DARWIN) &amp;&amp; USE(CF)
 319 
 320 static EncodedJSValue formateDateInstance(ExecState* exec, DateTimeFormat format, bool asUTCVariant)
 321 {
 322     VM&amp; vm = exec-&gt;vm();
 323     auto scope = DECLARE_THROW_SCOPE(vm);
 324     JSValue thisValue = exec-&gt;thisValue();
 325     auto* thisDateObj = jsDynamicCast&lt;DateInstance*&gt;(vm, thisValue);
 326     if (UNLIKELY(!thisDateObj))
 327         return throwVMTypeError(exec, scope);
 328 
 329     const GregorianDateTime* gregorianDateTime = asUTCVariant
 330         ? thisDateObj-&gt;gregorianDateTimeUTC(exec)
 331         : thisDateObj-&gt;gregorianDateTime(exec);
 332     if (!gregorianDateTime)
<span class="line-modified"> 333         return JSValue::encode(jsNontrivialString(exec, String(&quot;Invalid Date&quot;_s)));</span>
 334 
<span class="line-modified"> 335     return JSValue::encode(jsNontrivialString(exec, formatDateTime(*gregorianDateTime, format, asUTCVariant)));</span>
 336 }
 337 
 338 // Converts a list of arguments sent to a Date member function into milliseconds, updating
 339 // ms (representing milliseconds) and t (representing the rest of the date structure) appropriately.
 340 //
 341 // Format of member function: f([hour,] [min,] [sec,] [ms])
 342 static bool fillStructuresUsingTimeArgs(ExecState* exec, int maxArgs, double* ms, GregorianDateTime* t)
 343 {
 344     VM&amp; vm = exec-&gt;vm();
 345     auto scope = DECLARE_THROW_SCOPE(vm);
 346 
 347     double milliseconds = 0;
 348     bool ok = true;
 349     int idx = 0;
 350     int numArgs = exec-&gt;argumentCount();
 351 
 352     // JS allows extra trailing arguments -- ignore them
 353     if (numArgs &gt; maxArgs)
 354         numArgs = maxArgs;
 355 
</pre>
<hr />
<pre>
 485   setFullYear           dateProtoFuncSetFullYear             DontEnum|Function       3
 486   setUTCFullYear        dateProtoFuncSetUTCFullYear          DontEnum|Function       3
 487   setYear               dateProtoFuncSetYear                 DontEnum|Function       1
 488   getYear               dateProtoFuncGetYear                 DontEnum|Function       0
 489   toJSON                dateProtoFuncToJSON                  DontEnum|Function       1
 490 @end
 491 */
 492 
 493 // ECMA 15.9.4
 494 
 495 DatePrototype::DatePrototype(VM&amp; vm, Structure* structure)
 496     : Base(vm, structure)
 497 {
 498 }
 499 
 500 void DatePrototype::finishCreation(VM&amp; vm, JSGlobalObject* globalObject)
 501 {
 502     Base::finishCreation(vm);
 503     ASSERT(inherits(vm, info()));
 504 
<span class="line-modified"> 505     Identifier toUTCStringName = Identifier::fromString(&amp;vm, &quot;toUTCString&quot;_s);</span>
 506     JSFunction* toUTCStringFunction = JSFunction::create(vm, globalObject, 0, toUTCStringName.string(), dateProtoFuncToUTCString);
 507     putDirectWithoutTransition(vm, toUTCStringName, toUTCStringFunction, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
<span class="line-modified"> 508     putDirectWithoutTransition(vm, Identifier::fromString(&amp;vm, &quot;toGMTString&quot;_s), toUTCStringFunction, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));</span>
 509 
 510 #if ENABLE(INTL)
 511     JSC_BUILTIN_FUNCTION_WITHOUT_TRANSITION(&quot;toLocaleString&quot;, datePrototypeToLocaleStringCodeGenerator, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
 512     JSC_BUILTIN_FUNCTION_WITHOUT_TRANSITION(&quot;toLocaleDateString&quot;, datePrototypeToLocaleDateStringCodeGenerator, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
 513     JSC_BUILTIN_FUNCTION_WITHOUT_TRANSITION(&quot;toLocaleTimeString&quot;, datePrototypeToLocaleTimeStringCodeGenerator, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
 514 #endif
 515 
 516     JSFunction* toPrimitiveFunction = JSFunction::create(vm, globalObject, 1, &quot;[Symbol.toPrimitive]&quot;_s, dateProtoFuncToPrimitiveSymbol, NoIntrinsic);
 517     putDirectWithoutTransition(vm, vm.propertyNames-&gt;toPrimitiveSymbol, toPrimitiveFunction, PropertyAttribute::DontEnum | PropertyAttribute::ReadOnly);
 518 
 519     // The constructor will be added later, after DateConstructor has been built.
 520 }
 521 
 522 // Functions
 523 
 524 EncodedJSValue JSC_HOST_CALL dateProtoFuncToString(ExecState* exec)
 525 {
 526     const bool asUTCVariant = false;
 527     return formateDateInstance(exec, DateTimeFormatDateAndTime, asUTCVariant);
 528 }
</pre>
<hr />
<pre>
 530 EncodedJSValue JSC_HOST_CALL dateProtoFuncToUTCString(ExecState* exec)
 531 {
 532     const bool asUTCVariant = true;
 533     return formateDateInstance(exec, DateTimeFormatDateAndTime, asUTCVariant);
 534 }
 535 
 536 EncodedJSValue JSC_HOST_CALL dateProtoFuncToISOString(ExecState* exec)
 537 {
 538     VM&amp; vm = exec-&gt;vm();
 539     auto scope = DECLARE_THROW_SCOPE(vm);
 540     JSValue thisValue = exec-&gt;thisValue();
 541     auto* thisDateObj = jsDynamicCast&lt;DateInstance*&gt;(vm, thisValue);
 542     if (UNLIKELY(!thisDateObj))
 543         return throwVMTypeError(exec, scope);
 544 
 545     if (!std::isfinite(thisDateObj-&gt;internalNumber()))
 546         return throwVMError(exec, scope, createRangeError(exec, &quot;Invalid Date&quot;_s));
 547 
 548     const GregorianDateTime* gregorianDateTime = thisDateObj-&gt;gregorianDateTimeUTC(exec);
 549     if (!gregorianDateTime)
<span class="line-modified"> 550         return JSValue::encode(jsNontrivialString(exec, String(&quot;Invalid Date&quot;_s)));</span>
 551     // Maximum amount of space we need in buffer: 7 (max. digits in year) + 2 * 5 (2 characters each for month, day, hour, minute, second) + 4 (. + 3 digits for milliseconds)
 552     // 6 for formatting and one for null termination = 28. We add one extra character to allow us to force null termination.
 553     char buffer[28];
 554     // If the year is outside the bounds of 0 and 9999 inclusive we want to use the extended year format (ES 15.9.1.15.1).
 555     int ms = static_cast&lt;int&gt;(fmod(thisDateObj-&gt;internalNumber(), msPerSecond));
 556     if (ms &lt; 0)
 557         ms += msPerSecond;
 558 
 559     int charactersWritten;
 560     if (gregorianDateTime-&gt;year() &gt; 9999 || gregorianDateTime-&gt;year() &lt; 0)
 561         charactersWritten = snprintf(buffer, sizeof(buffer), &quot;%+07d-%02d-%02dT%02d:%02d:%02d.%03dZ&quot;, gregorianDateTime-&gt;year(), gregorianDateTime-&gt;month() + 1, gregorianDateTime-&gt;monthDay(), gregorianDateTime-&gt;hour(), gregorianDateTime-&gt;minute(), gregorianDateTime-&gt;second(), ms);
 562     else
 563         charactersWritten = snprintf(buffer, sizeof(buffer), &quot;%04d-%02d-%02dT%02d:%02d:%02d.%03dZ&quot;, gregorianDateTime-&gt;year(), gregorianDateTime-&gt;month() + 1, gregorianDateTime-&gt;monthDay(), gregorianDateTime-&gt;hour(), gregorianDateTime-&gt;minute(), gregorianDateTime-&gt;second(), ms);
 564 
 565     ASSERT(charactersWritten &gt; 0 &amp;&amp; static_cast&lt;unsigned&gt;(charactersWritten) &lt; sizeof(buffer));
 566     if (static_cast&lt;unsigned&gt;(charactersWritten) &gt;= sizeof(buffer))
<span class="line-modified"> 567         return JSValue::encode(jsEmptyString(exec));</span>
 568 
<span class="line-modified"> 569     return JSValue::encode(jsNontrivialString(exec, String(buffer, charactersWritten)));</span>
 570 }
 571 
 572 EncodedJSValue JSC_HOST_CALL dateProtoFuncToDateString(ExecState* exec)
 573 {
 574     const bool asUTCVariant = false;
 575     return formateDateInstance(exec, DateTimeFormatDate, asUTCVariant);
 576 }
 577 
 578 EncodedJSValue JSC_HOST_CALL dateProtoFuncToTimeString(ExecState* exec)
 579 {
 580     const bool asUTCVariant = false;
 581     return formateDateInstance(exec, DateTimeFormatTime, asUTCVariant);
 582 }
 583 
 584 EncodedJSValue JSC_HOST_CALL dateProtoFuncToLocaleString(ExecState* exec)
 585 {
 586     VM&amp; vm = exec-&gt;vm();
 587     auto scope = DECLARE_THROW_SCOPE(vm);
 588     JSValue thisValue = exec-&gt;thisValue();
 589     auto* thisDateObj = jsDynamicCast&lt;DateInstance*&gt;(vm, thisValue);
</pre>
<hr />
<pre>
1146     auto scope = DECLARE_THROW_SCOPE(vm);
1147     JSValue thisValue = exec-&gt;thisValue();
1148     JSObject* object = jsCast&lt;JSObject*&gt;(thisValue.toThis(exec, NotStrictMode));
1149     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1150 
1151     JSValue timeValue = object-&gt;toPrimitive(exec, PreferNumber);
1152     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1153     if (timeValue.isNumber() &amp;&amp; !(timeValue.isInt32() || std::isfinite(timeValue.asDouble())))
1154         return JSValue::encode(jsNull());
1155 
1156     JSValue toISOValue = object-&gt;get(exec, vm.propertyNames-&gt;toISOString);
1157     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1158 
1159     CallData callData;
1160     CallType callType = getCallData(vm, toISOValue, callData);
1161     if (callType == CallType::None)
1162         return throwVMTypeError(exec, scope, &quot;toISOString is not a function&quot;_s);
1163 
1164     JSValue result = call(exec, asObject(toISOValue), callType, callData, object, *vm.emptyList);
1165     RETURN_IF_EXCEPTION(scope, encodedJSValue());
<span class="line-removed">1166     if (result.isObject())</span>
<span class="line-removed">1167         return throwVMTypeError(exec, scope, &quot;toISOString did not return a primitive value&quot;_s);</span>
1168     return JSValue::encode(result);
1169 }
1170 
1171 } // namespace JSC
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
   2  *  Copyright (C) 1999-2000 Harri Porten (porten@kde.org)
<span class="line-modified">   3  *  Copyright (C) 2004-2019 Apple Inc. All rights reserved.</span>
   4  *  Copyright (C) 2008, 2009 Torch Mobile, Inc. All rights reserved.
   5  *  Copyright (C) 2010 Torch Mobile (Beijing) Co. Ltd. All rights reserved.
   6  *
   7  *  This library is free software; you can redistribute it and/or
   8  *  modify it under the terms of the GNU Lesser General Public
   9  *  License as published by the Free Software Foundation; either
  10  *  version 2 of the License, or (at your option) any later version.
  11  *
  12  *  This library is distributed in the hope that it will be useful,
  13  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  14  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  15  *  Lesser General Public License for more details.
  16  *
  17  *  You should have received a copy of the GNU Lesser General Public
  18  *  License along with this library; if not, write to the Free Software
  19  *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301
  20  *  USA
  21  *
  22  */
  23 
</pre>
<hr />
<pre>
 127 #if OS(DARWIN) &amp;&amp; USE(CF)
 128 
 129 // FIXME: Since this is superior to the strftime-based version, why limit this to OS(DARWIN)?
 130 // Instead we should consider using this whenever USE(CF) is true.
 131 
 132 static CFDateFormatterStyle styleFromArgString(const String&amp; string, CFDateFormatterStyle defaultStyle)
 133 {
 134     if (string == &quot;short&quot;)
 135         return kCFDateFormatterShortStyle;
 136     if (string == &quot;medium&quot;)
 137         return kCFDateFormatterMediumStyle;
 138     if (string == &quot;long&quot;)
 139         return kCFDateFormatterLongStyle;
 140     if (string == &quot;full&quot;)
 141         return kCFDateFormatterFullStyle;
 142     return defaultStyle;
 143 }
 144 
 145 static JSCell* formatLocaleDate(ExecState* exec, DateInstance*, double timeInMilliseconds, LocaleDateTimeFormat format)
 146 {
<span class="line-added"> 147     VM&amp; vm = exec-&gt;vm();</span>
 148     CFDateFormatterStyle dateStyle = (format != LocaleTime ? kCFDateFormatterLongStyle : kCFDateFormatterNoStyle);
 149     CFDateFormatterStyle timeStyle = (format != LocaleDate ? kCFDateFormatterLongStyle : kCFDateFormatterNoStyle);
 150 
 151     bool useCustomFormat = false;
 152     String customFormatString;
 153 
 154     String arg0String = exec-&gt;argument(0).toWTFString(exec);
 155     if (arg0String == &quot;custom&quot; &amp;&amp; !exec-&gt;argument(1).isUndefined()) {
 156         useCustomFormat = true;
 157         customFormatString = exec-&gt;argument(1).toWTFString(exec);
 158     } else if (format == LocaleDateAndTime &amp;&amp; !exec-&gt;argument(1).isUndefined()) {
 159         dateStyle = styleFromArgString(arg0String, dateStyle);
 160         timeStyle = styleFromArgString(exec-&gt;argument(1).toWTFString(exec), timeStyle);
 161     } else if (format != LocaleTime &amp;&amp; !exec-&gt;argument(0).isUndefined())
 162         dateStyle = styleFromArgString(arg0String, dateStyle);
 163     else if (format != LocaleDate &amp;&amp; !exec-&gt;argument(0).isUndefined())
 164         timeStyle = styleFromArgString(arg0String, timeStyle);
 165 
 166     CFAbsoluteTime absoluteTime = floor(timeInMilliseconds / msPerSecond) - kCFAbsoluteTimeIntervalSince1970;
 167 
 168     auto formatter = adoptCF(CFDateFormatterCreate(kCFAllocatorDefault, adoptCF(CFLocaleCopyCurrent()).get(), dateStyle, timeStyle));
 169     if (useCustomFormat)
 170         CFDateFormatterSetFormat(formatter.get(), customFormatString.createCFString().get());
<span class="line-modified"> 171     return jsNontrivialString(vm, adoptCF(CFDateFormatterCreateStringWithAbsoluteTime(kCFAllocatorDefault, formatter.get(), absoluteTime)).get());</span>
 172 }
 173 
 174 #elif !UCONFIG_NO_FORMATTING
 175 
 176 static JSCell* formatLocaleDate(ExecState* exec, DateInstance*, double timeInMilliseconds, LocaleDateTimeFormat format)
 177 {
<span class="line-added"> 178     VM&amp; vm = exec-&gt;vm();</span>
 179     UDateFormatStyle timeStyle = (format != LocaleDate ? UDAT_LONG : UDAT_NONE);
 180     UDateFormatStyle dateStyle = (format != LocaleTime ? UDAT_LONG : UDAT_NONE);
 181 
 182     UErrorCode status = U_ZERO_ERROR;
 183     UDateFormat* df = udat_open(timeStyle, dateStyle, 0, 0, -1, 0, 0, &amp;status);
 184     if (!df)
<span class="line-modified"> 185         return jsEmptyString(vm);</span>
 186 
 187     UChar buffer[128];
 188     int32_t length;
 189     length = udat_format(df, timeInMilliseconds, buffer, 128, 0, &amp;status);
 190     udat_close(df);
 191     if (status != U_ZERO_ERROR)
<span class="line-modified"> 192         return jsEmptyString(vm);</span>
 193 
<span class="line-modified"> 194     return jsNontrivialString(vm, String(buffer, length));</span>
 195 }
 196 
 197 #else
 198 
 199 static JSCell* formatLocaleDate(ExecState* exec, const GregorianDateTime&amp; gdt, LocaleDateTimeFormat format)
 200 {
<span class="line-added"> 201     VM&amp; vm = exec-&gt;vm();</span>
 202 #if OS(WINDOWS)
 203     SYSTEMTIME systemTime;
 204     memset(&amp;systemTime, 0, sizeof(systemTime));
 205     systemTime.wYear = gdt.year();
 206     systemTime.wMonth = gdt.month() + 1;
 207     systemTime.wDay = gdt.monthDay();
 208     systemTime.wDayOfWeek = gdt.weekDay();
 209     systemTime.wHour = gdt.hour();
 210     systemTime.wMinute = gdt.minute();
 211     systemTime.wSecond = gdt.second();
 212 
 213     Vector&lt;UChar, 128&gt; buffer;
 214     size_t length = 0;
 215 
 216     if (format == LocaleDate) {
 217         buffer.resize(GetDateFormatW(LOCALE_USER_DEFAULT, DATE_LONGDATE, &amp;systemTime, 0, 0, 0));
 218         length = GetDateFormatW(LOCALE_USER_DEFAULT, DATE_LONGDATE, &amp;systemTime, 0, buffer.data(), buffer.size());
 219     } else if (format == LocaleTime) {
 220         buffer.resize(GetTimeFormatW(LOCALE_USER_DEFAULT, 0, &amp;systemTime, 0, 0, 0));
 221         length = GetTimeFormatW(LOCALE_USER_DEFAULT, 0, &amp;systemTime, 0, buffer.data(), buffer.size());
 222     } else if (format == LocaleDateAndTime) {
 223         buffer.resize(GetDateFormatW(LOCALE_USER_DEFAULT, DATE_LONGDATE, &amp;systemTime, 0, 0, 0) + GetTimeFormatW(LOCALE_USER_DEFAULT, 0, &amp;systemTime, 0, 0, 0));
 224         length = GetDateFormatW(LOCALE_USER_DEFAULT, DATE_LONGDATE, &amp;systemTime, 0, buffer.data(), buffer.size());
 225         if (length) {
 226             buffer[length - 1] = &#39; &#39;;
 227             length += GetTimeFormatW(LOCALE_USER_DEFAULT, 0, &amp;systemTime, 0, buffer.data() + length, buffer.size() - length);
 228         }
 229     } else
 230         RELEASE_ASSERT_NOT_REACHED();
 231 
 232     //  Remove terminating null character.
 233     if (length)
 234         length--;
 235 
<span class="line-modified"> 236     return jsNontrivialString(vm, String(buffer.data(), length));</span>
 237 
 238 #else // OS(WINDOWS)
 239 
 240 #if HAVE(LANGINFO_H)
 241     static const nl_item formats[] = { D_T_FMT, D_FMT, T_FMT };
 242 #else
 243     static const char* const formatStrings[] = { &quot;%#c&quot;, &quot;%#x&quot;, &quot;%X&quot; };
 244 #endif
 245 
 246     // Offset year if needed
 247     struct tm localTM = gdt;
 248     int year = gdt.year();
 249     bool yearNeedsOffset = year &lt; 1900 || year &gt; 2038;
 250     if (yearNeedsOffset)
 251         localTM.tm_year = equivalentYearForDST(year) - 1900;
 252 
 253 #if HAVE(LANGINFO_H)
 254     // We do not allow strftime to generate dates with 2-digits years,
 255     // both to avoid ambiguity, and a crash in strncpy, for years that
 256     // need offset.
 257     char* formatString = strdup(nl_langinfo(formats[format]));
 258     char* yPos = strchr(formatString, &#39;y&#39;);
 259     if (yPos)
 260         *yPos = &#39;Y&#39;;
 261 #endif
 262 
 263     // Do the formatting
 264     const int bufsize = 128;
 265     char timebuffer[bufsize];
 266 
 267 #if HAVE(LANGINFO_H)
 268     size_t ret = strftime(timebuffer, bufsize, formatString, &amp;localTM);
 269     free(formatString);
 270 #else
 271     size_t ret = strftime(timebuffer, bufsize, formatStrings[format], &amp;localTM);
 272 #endif
 273 
 274     if (ret == 0)
<span class="line-modified"> 275         return jsEmptyString(vm);</span>
 276 
 277     // Copy original into the buffer
 278     if (yearNeedsOffset &amp;&amp; format != LocaleTime) {
 279         static const int yearLen = 5;   // FIXME will be a problem in the year 10,000
 280         char yearString[yearLen];
 281 
 282         snprintf(yearString, yearLen, &quot;%d&quot;, localTM.tm_year + 1900);
 283         char* yearLocation = strstr(timebuffer, yearString);
 284         snprintf(yearString, yearLen, &quot;%d&quot;, year);
 285 
 286         strncpy(yearLocation, yearString, yearLen - 1);
 287     }
 288 
 289     // Convert multi-byte result to UNICODE.
 290     // If __STDC_ISO_10646__ is defined, wide character represents
 291     // UTF-16 (or UTF-32) code point. In most modern Unix like system
 292     // (e.g. Linux with glibc 2.2 and above) the macro is defined,
 293     // and wide character represents UTF-32 code point.
 294     // Here we static_cast potential UTF-32 to UTF-16, it should be
 295     // safe because date and (or) time related characters in different languages
 296     // should be in UNICODE BMP. If mbstowcs fails, we just fall
 297     // back on using multi-byte result as-is.
 298 #ifdef __STDC_ISO_10646__
 299     UChar buffer[bufsize];
 300     wchar_t tempbuffer[bufsize];
 301     size_t length = mbstowcs(tempbuffer, timebuffer, bufsize - 1);
 302     if (length != static_cast&lt;size_t&gt;(-1)) {
 303         for (size_t i = 0; i &lt; length; ++i)
 304             buffer[i] = static_cast&lt;UChar&gt;(tempbuffer[i]);
<span class="line-modified"> 305         return jsNontrivialString(vm, String(buffer, length));</span>
 306     }
 307 #endif
 308 
<span class="line-modified"> 309     return jsNontrivialString(vm, timebuffer);</span>
 310 #endif // OS(WINDOWS)
 311 }
 312 
 313 static JSCell* formatLocaleDate(ExecState* exec, DateInstance* dateObject, double, LocaleDateTimeFormat format)
 314 {
<span class="line-added"> 315     VM&amp; vm = exec-&gt;vm();</span>
 316     const GregorianDateTime* gregorianDateTime = dateObject-&gt;gregorianDateTime(exec);
 317     if (!gregorianDateTime)
<span class="line-modified"> 318         return jsNontrivialString(vm, &quot;Invalid Date&quot;_s);</span>
 319     return formatLocaleDate(exec, *gregorianDateTime, format);
 320 }
 321 
 322 #endif // OS(DARWIN) &amp;&amp; USE(CF)
 323 
 324 static EncodedJSValue formateDateInstance(ExecState* exec, DateTimeFormat format, bool asUTCVariant)
 325 {
 326     VM&amp; vm = exec-&gt;vm();
 327     auto scope = DECLARE_THROW_SCOPE(vm);
 328     JSValue thisValue = exec-&gt;thisValue();
 329     auto* thisDateObj = jsDynamicCast&lt;DateInstance*&gt;(vm, thisValue);
 330     if (UNLIKELY(!thisDateObj))
 331         return throwVMTypeError(exec, scope);
 332 
 333     const GregorianDateTime* gregorianDateTime = asUTCVariant
 334         ? thisDateObj-&gt;gregorianDateTimeUTC(exec)
 335         : thisDateObj-&gt;gregorianDateTime(exec);
 336     if (!gregorianDateTime)
<span class="line-modified"> 337         return JSValue::encode(jsNontrivialString(vm, String(&quot;Invalid Date&quot;_s)));</span>
 338 
<span class="line-modified"> 339     return JSValue::encode(jsNontrivialString(vm, formatDateTime(*gregorianDateTime, format, asUTCVariant)));</span>
 340 }
 341 
 342 // Converts a list of arguments sent to a Date member function into milliseconds, updating
 343 // ms (representing milliseconds) and t (representing the rest of the date structure) appropriately.
 344 //
 345 // Format of member function: f([hour,] [min,] [sec,] [ms])
 346 static bool fillStructuresUsingTimeArgs(ExecState* exec, int maxArgs, double* ms, GregorianDateTime* t)
 347 {
 348     VM&amp; vm = exec-&gt;vm();
 349     auto scope = DECLARE_THROW_SCOPE(vm);
 350 
 351     double milliseconds = 0;
 352     bool ok = true;
 353     int idx = 0;
 354     int numArgs = exec-&gt;argumentCount();
 355 
 356     // JS allows extra trailing arguments -- ignore them
 357     if (numArgs &gt; maxArgs)
 358         numArgs = maxArgs;
 359 
</pre>
<hr />
<pre>
 489   setFullYear           dateProtoFuncSetFullYear             DontEnum|Function       3
 490   setUTCFullYear        dateProtoFuncSetUTCFullYear          DontEnum|Function       3
 491   setYear               dateProtoFuncSetYear                 DontEnum|Function       1
 492   getYear               dateProtoFuncGetYear                 DontEnum|Function       0
 493   toJSON                dateProtoFuncToJSON                  DontEnum|Function       1
 494 @end
 495 */
 496 
 497 // ECMA 15.9.4
 498 
 499 DatePrototype::DatePrototype(VM&amp; vm, Structure* structure)
 500     : Base(vm, structure)
 501 {
 502 }
 503 
 504 void DatePrototype::finishCreation(VM&amp; vm, JSGlobalObject* globalObject)
 505 {
 506     Base::finishCreation(vm);
 507     ASSERT(inherits(vm, info()));
 508 
<span class="line-modified"> 509     Identifier toUTCStringName = Identifier::fromString(vm, &quot;toUTCString&quot;_s);</span>
 510     JSFunction* toUTCStringFunction = JSFunction::create(vm, globalObject, 0, toUTCStringName.string(), dateProtoFuncToUTCString);
 511     putDirectWithoutTransition(vm, toUTCStringName, toUTCStringFunction, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
<span class="line-modified"> 512     putDirectWithoutTransition(vm, Identifier::fromString(vm, &quot;toGMTString&quot;_s), toUTCStringFunction, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));</span>
 513 
 514 #if ENABLE(INTL)
 515     JSC_BUILTIN_FUNCTION_WITHOUT_TRANSITION(&quot;toLocaleString&quot;, datePrototypeToLocaleStringCodeGenerator, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
 516     JSC_BUILTIN_FUNCTION_WITHOUT_TRANSITION(&quot;toLocaleDateString&quot;, datePrototypeToLocaleDateStringCodeGenerator, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
 517     JSC_BUILTIN_FUNCTION_WITHOUT_TRANSITION(&quot;toLocaleTimeString&quot;, datePrototypeToLocaleTimeStringCodeGenerator, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
 518 #endif
 519 
 520     JSFunction* toPrimitiveFunction = JSFunction::create(vm, globalObject, 1, &quot;[Symbol.toPrimitive]&quot;_s, dateProtoFuncToPrimitiveSymbol, NoIntrinsic);
 521     putDirectWithoutTransition(vm, vm.propertyNames-&gt;toPrimitiveSymbol, toPrimitiveFunction, PropertyAttribute::DontEnum | PropertyAttribute::ReadOnly);
 522 
 523     // The constructor will be added later, after DateConstructor has been built.
 524 }
 525 
 526 // Functions
 527 
 528 EncodedJSValue JSC_HOST_CALL dateProtoFuncToString(ExecState* exec)
 529 {
 530     const bool asUTCVariant = false;
 531     return formateDateInstance(exec, DateTimeFormatDateAndTime, asUTCVariant);
 532 }
</pre>
<hr />
<pre>
 534 EncodedJSValue JSC_HOST_CALL dateProtoFuncToUTCString(ExecState* exec)
 535 {
 536     const bool asUTCVariant = true;
 537     return formateDateInstance(exec, DateTimeFormatDateAndTime, asUTCVariant);
 538 }
 539 
 540 EncodedJSValue JSC_HOST_CALL dateProtoFuncToISOString(ExecState* exec)
 541 {
 542     VM&amp; vm = exec-&gt;vm();
 543     auto scope = DECLARE_THROW_SCOPE(vm);
 544     JSValue thisValue = exec-&gt;thisValue();
 545     auto* thisDateObj = jsDynamicCast&lt;DateInstance*&gt;(vm, thisValue);
 546     if (UNLIKELY(!thisDateObj))
 547         return throwVMTypeError(exec, scope);
 548 
 549     if (!std::isfinite(thisDateObj-&gt;internalNumber()))
 550         return throwVMError(exec, scope, createRangeError(exec, &quot;Invalid Date&quot;_s));
 551 
 552     const GregorianDateTime* gregorianDateTime = thisDateObj-&gt;gregorianDateTimeUTC(exec);
 553     if (!gregorianDateTime)
<span class="line-modified"> 554         return JSValue::encode(jsNontrivialString(vm, String(&quot;Invalid Date&quot;_s)));</span>
 555     // Maximum amount of space we need in buffer: 7 (max. digits in year) + 2 * 5 (2 characters each for month, day, hour, minute, second) + 4 (. + 3 digits for milliseconds)
 556     // 6 for formatting and one for null termination = 28. We add one extra character to allow us to force null termination.
 557     char buffer[28];
 558     // If the year is outside the bounds of 0 and 9999 inclusive we want to use the extended year format (ES 15.9.1.15.1).
 559     int ms = static_cast&lt;int&gt;(fmod(thisDateObj-&gt;internalNumber(), msPerSecond));
 560     if (ms &lt; 0)
 561         ms += msPerSecond;
 562 
 563     int charactersWritten;
 564     if (gregorianDateTime-&gt;year() &gt; 9999 || gregorianDateTime-&gt;year() &lt; 0)
 565         charactersWritten = snprintf(buffer, sizeof(buffer), &quot;%+07d-%02d-%02dT%02d:%02d:%02d.%03dZ&quot;, gregorianDateTime-&gt;year(), gregorianDateTime-&gt;month() + 1, gregorianDateTime-&gt;monthDay(), gregorianDateTime-&gt;hour(), gregorianDateTime-&gt;minute(), gregorianDateTime-&gt;second(), ms);
 566     else
 567         charactersWritten = snprintf(buffer, sizeof(buffer), &quot;%04d-%02d-%02dT%02d:%02d:%02d.%03dZ&quot;, gregorianDateTime-&gt;year(), gregorianDateTime-&gt;month() + 1, gregorianDateTime-&gt;monthDay(), gregorianDateTime-&gt;hour(), gregorianDateTime-&gt;minute(), gregorianDateTime-&gt;second(), ms);
 568 
 569     ASSERT(charactersWritten &gt; 0 &amp;&amp; static_cast&lt;unsigned&gt;(charactersWritten) &lt; sizeof(buffer));
 570     if (static_cast&lt;unsigned&gt;(charactersWritten) &gt;= sizeof(buffer))
<span class="line-modified"> 571         return JSValue::encode(jsEmptyString(vm));</span>
 572 
<span class="line-modified"> 573     return JSValue::encode(jsNontrivialString(vm, String(buffer, charactersWritten)));</span>
 574 }
 575 
 576 EncodedJSValue JSC_HOST_CALL dateProtoFuncToDateString(ExecState* exec)
 577 {
 578     const bool asUTCVariant = false;
 579     return formateDateInstance(exec, DateTimeFormatDate, asUTCVariant);
 580 }
 581 
 582 EncodedJSValue JSC_HOST_CALL dateProtoFuncToTimeString(ExecState* exec)
 583 {
 584     const bool asUTCVariant = false;
 585     return formateDateInstance(exec, DateTimeFormatTime, asUTCVariant);
 586 }
 587 
 588 EncodedJSValue JSC_HOST_CALL dateProtoFuncToLocaleString(ExecState* exec)
 589 {
 590     VM&amp; vm = exec-&gt;vm();
 591     auto scope = DECLARE_THROW_SCOPE(vm);
 592     JSValue thisValue = exec-&gt;thisValue();
 593     auto* thisDateObj = jsDynamicCast&lt;DateInstance*&gt;(vm, thisValue);
</pre>
<hr />
<pre>
1150     auto scope = DECLARE_THROW_SCOPE(vm);
1151     JSValue thisValue = exec-&gt;thisValue();
1152     JSObject* object = jsCast&lt;JSObject*&gt;(thisValue.toThis(exec, NotStrictMode));
1153     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1154 
1155     JSValue timeValue = object-&gt;toPrimitive(exec, PreferNumber);
1156     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1157     if (timeValue.isNumber() &amp;&amp; !(timeValue.isInt32() || std::isfinite(timeValue.asDouble())))
1158         return JSValue::encode(jsNull());
1159 
1160     JSValue toISOValue = object-&gt;get(exec, vm.propertyNames-&gt;toISOString);
1161     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1162 
1163     CallData callData;
1164     CallType callType = getCallData(vm, toISOValue, callData);
1165     if (callType == CallType::None)
1166         return throwVMTypeError(exec, scope, &quot;toISOString is not a function&quot;_s);
1167 
1168     JSValue result = call(exec, asObject(toISOValue), callType, callData, object, *vm.emptyList);
1169     RETURN_IF_EXCEPTION(scope, encodedJSValue());


1170     return JSValue::encode(result);
1171 }
1172 
1173 } // namespace JSC
</pre>
</td>
</tr>
</table>
<center><a href="DateConversion.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DirectArguments.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>