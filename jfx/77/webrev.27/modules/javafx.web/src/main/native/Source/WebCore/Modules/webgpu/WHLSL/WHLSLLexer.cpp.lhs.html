<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/Modules/webgpu/WHLSL/WHLSLLexer.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2018 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;WHLSLLexer.h&quot;
 28 
 29 #if ENABLE(WEBGPU)
 30 
 31 namespace WebCore {
 32 
 33 namespace WHLSL {
 34 
<a name="1" id="anc1"></a><span class="line-modified"> 35 const char* Lexer::Token::typeName(Type type)</span>
 36 {
 37     switch (type) {
 38     case Type::IntLiteral:
 39         return &quot;int literal&quot;;
 40     case Type::UintLiteral:
 41         return &quot;uint literal&quot;;
 42     case Type::FloatLiteral:
 43         return &quot;float literal&quot;;
 44     case Type::Struct:
 45         return &quot;struct&quot;;
 46     case Type::Typedef:
 47         return &quot;typedef&quot;;
 48     case Type::Enum:
 49         return &quot;enum&quot;;
 50     case Type::Operator:
 51         return &quot;operator&quot;;
 52     case Type::If:
 53         return &quot;if&quot;;
 54     case Type::Else:
 55         return &quot;else&quot;;
 56     case Type::Continue:
 57         return &quot;continue&quot;;
 58     case Type::Break:
 59         return &quot;break&quot;;
 60     case Type::Switch:
 61         return &quot;switch&quot;;
 62     case Type::Case:
 63         return &quot;case&quot;;
 64     case Type::Default:
 65         return &quot;default&quot;;
 66     case Type::Fallthrough:
 67         return &quot;fallthrough&quot;;
 68     case Type::For:
 69         return &quot;for&quot;;
 70     case Type::While:
 71         return &quot;while&quot;;
 72     case Type::Do:
 73         return &quot;do&quot;;
 74     case Type::Return:
 75         return &quot;return&quot;;
<a name="2" id="anc2"></a><span class="line-removed"> 76     case Type::Trap:</span>
<span class="line-removed"> 77         return &quot;trap&quot;;</span>
 78     case Type::Null:
 79         return &quot;null&quot;;
 80     case Type::True:
 81         return &quot;true&quot;;
 82     case Type::False:
 83         return &quot;false&quot;;
 84     case Type::Constant:
 85         return &quot;constant&quot;;
 86     case Type::Device:
 87         return &quot;device&quot;;
 88     case Type::Threadgroup:
 89         return &quot;threadgroup&quot;;
 90     case Type::Thread:
 91         return &quot;thread&quot;;
 92     case Type::Space:
 93         return &quot;space&quot;;
 94     case Type::Vertex:
 95         return &quot;vertex&quot;;
 96     case Type::Fragment:
 97         return &quot;fragment&quot;;
 98     case Type::Compute:
 99         return &quot;compute&quot;;
100     case Type::NumThreads:
101         return &quot;numthreads&quot;;
102     case Type::SVInstanceID:
103         return &quot;SV_InstanceID&quot;;
104     case Type::SVVertexID:
105         return &quot;SV_VertexID&quot;;
106     case Type::PSize:
107         return &quot;PSIZE&quot;;
108     case Type::SVPosition:
109         return &quot;SV_Position&quot;;
110     case Type::SVIsFrontFace:
111         return &quot;SV_IsFrontFace&quot;;
112     case Type::SVSampleIndex:
113         return &quot;SV_SampleIndex&quot;;
114     case Type::SVInnerCoverage:
115         return &quot;SV_InnerCoverage&quot;;
116     case Type::SVTarget:
117         return &quot;SV_Target&quot;;
118     case Type::SVDepth:
119         return &quot;SV_Depth&quot;;
120     case Type::SVCoverage:
121         return &quot;SV_Coverage&quot;;
122     case Type::SVDispatchThreadID:
123         return &quot;SV_DispatchThreadID&quot;;
124     case Type::SVGroupID:
125         return &quot;SV_GroupID&quot;;
126     case Type::SVGroupIndex:
127         return &quot;SV_GroupIndex&quot;;
128     case Type::SVGroupThreadID:
129         return &quot;SV_GroupThreadID&quot;;
130     case Type::Attribute:
131         return &quot;SV_Attribute&quot;;
132     case Type::Register:
133         return &quot;register&quot;;
134     case Type::Specialized:
135         return &quot;specialized&quot;;
136     case Type::Native:
137         return &quot;native&quot;;
138     case Type::Restricted:
139         return &quot;restricted&quot;;
140     case Type::Underscore:
141         return &quot;_&quot;;
142     case Type::Auto:
143         return &quot;auto&quot;;
144     case Type::Protocol:
145         return &quot;protocol&quot;;
146     case Type::Const:
147         return &quot;const&quot;;
148     case Type::Static:
149         return &quot;static&quot;;
150     case Type::Qualifier:
151         return &quot;qualifier&quot;;
152     case Type::Identifier:
153         return &quot;identifier&quot;;
154     case Type::OperatorName:
155         return &quot;operator name&quot;;
156     case Type::EqualsSign:
157         return &quot;=&quot;;
158     case Type::Semicolon:
159         return &quot;;&quot;;
160     case Type::LeftCurlyBracket:
161         return &quot;{&quot;;
162     case Type::RightCurlyBracket:
163         return &quot;}&quot;;
164     case Type::Colon:
165         return &quot;:&quot;;
166     case Type::Comma:
167         return &quot;,&quot;;
168     case Type::LeftParenthesis:
169         return &quot;(&quot;;
170     case Type::RightParenthesis:
171         return &quot;)&quot;;
172     case Type::SquareBracketPair:
173         return &quot;[]&quot;;
174     case Type::LeftSquareBracket:
175         return &quot;[&quot;;
176     case Type::RightSquareBracket:
177         return &quot;]&quot;;
178     case Type::Star:
179         return &quot;*&quot;;
180     case Type::LessThanSign:
181         return &quot;&lt;&quot;;
182     case Type::GreaterThanSign:
183         return &quot;&gt;&quot;;
184     case Type::FullStop:
185         return &quot;.&quot;;
186     case Type::PlusEquals:
187         return &quot;+=&quot;;
188     case Type::MinusEquals:
189         return &quot;-=&quot;;
190     case Type::TimesEquals:
191         return &quot;*=&quot;;
192     case Type::DivideEquals:
193         return &quot;/=&quot;;
194     case Type::ModEquals:
195         return &quot;%=&quot;;
196     case Type::XorEquals:
197         return &quot;^=&quot;;
198     case Type::AndEquals:
199         return &quot;&amp;=&quot;;
200     case Type::OrEquals:
201         return &quot;|=&quot;;
202     case Type::RightShiftEquals:
203         return &quot;&gt;&gt;=&quot;;
204     case Type::LeftShiftEquals:
205         return &quot;&lt;&lt;=&quot;;
206     case Type::PlusPlus:
207         return &quot;++&quot;;
208     case Type::MinusMinus:
209         return &quot;--&quot;;
210     case Type::Arrow:
211         return &quot;-&gt;&quot;;
212     case Type::QuestionMark:
213         return &quot;?&quot;;
214     case Type::OrOr:
215         return &quot;||&quot;;
216     case Type::AndAnd:
217         return &quot;&amp;&amp;&quot;;
218     case Type::Or:
219         return &quot;|&quot;;
220     case Type::Xor:
221         return &quot;^&quot;;
222     case Type::And:
223         return &quot;&amp;&quot;;
224     case Type::LessThanOrEqualTo:
225         return &quot;&lt;=&quot;;
226     case Type::GreaterThanOrEqualTo:
227         return &quot;&gt;=&quot;;
228     case Type::EqualComparison:
229         return &quot;==&quot;;
230     case Type::NotEqual:
231         return &quot;!=&quot;;
232     case Type::RightShift:
233         return &quot;&gt;&gt;&quot;;
234     case Type::LeftShift:
235         return &quot;&lt;&lt;&quot;;
236     case Type::Plus:
237         return &quot;+&quot;;
238     case Type::Minus:
239         return &quot;-&quot;;
240     case Type::Divide:
241         return &quot;/&quot;;
242     case Type::Mod:
243         return &quot;%&quot;;
244     case Type::Tilde:
245         return &quot;~&quot;;
246     case Type::ExclamationPoint:
247         return &quot;!&quot;;
248     case Type::At:
249         return &quot;@&quot;;
<a name="3" id="anc3"></a>



250     }
251 }
252 
<a name="4" id="anc4"></a><span class="line-modified">253 auto Lexer::recognizeKeyword(unsigned end) -&gt; Optional&lt;Token::Type&gt;</span>
254 {
<a name="5" id="anc5"></a><span class="line-modified">255     auto substring = m_stringView.substring(m_offset, end - m_offset);</span>
<span class="line-modified">256     if (substring == &quot;struct&quot;)</span>
<span class="line-modified">257         return Token::Type::Struct;</span>
<span class="line-removed">258     if (substring == &quot;typedef&quot;)</span>
<span class="line-removed">259         return Token::Type::Typedef;</span>
<span class="line-removed">260     if (substring == &quot;enum&quot;)</span>
<span class="line-removed">261         return Token::Type::Enum;</span>
<span class="line-removed">262     if (substring == &quot;operator&quot;)</span>
<span class="line-removed">263         return Token::Type::Operator;</span>
<span class="line-removed">264     if (substring == &quot;if&quot;)</span>
<span class="line-removed">265         return Token::Type::If;</span>
<span class="line-removed">266     if (substring == &quot;else&quot;)</span>
<span class="line-removed">267         return Token::Type::Else;</span>
<span class="line-removed">268     if (substring == &quot;continue&quot;)</span>
<span class="line-removed">269         return Token::Type::Continue;</span>
<span class="line-removed">270     if (substring == &quot;break&quot;)</span>
<span class="line-removed">271         return Token::Type::Break;</span>
<span class="line-removed">272     if (substring == &quot;switch&quot;)</span>
<span class="line-removed">273         return Token::Type::Switch;</span>
<span class="line-removed">274     if (substring == &quot;case&quot;)</span>
<span class="line-removed">275         return Token::Type::Case;</span>
<span class="line-removed">276     if (substring == &quot;default&quot;)</span>
<span class="line-removed">277         return Token::Type::Default;</span>
<span class="line-removed">278     if (substring == &quot;fallthrough&quot;)</span>
<span class="line-removed">279         return Token::Type::Fallthrough;</span>
<span class="line-removed">280     if (substring == &quot;for&quot;)</span>
<span class="line-removed">281         return Token::Type::For;</span>
<span class="line-removed">282     if (substring == &quot;while&quot;)</span>
<span class="line-removed">283         return Token::Type::While;</span>
<span class="line-removed">284     if (substring == &quot;do&quot;)</span>
<span class="line-removed">285         return Token::Type::Do;</span>
<span class="line-removed">286     if (substring == &quot;return&quot;)</span>
<span class="line-removed">287         return Token::Type::Return;</span>
<span class="line-removed">288     if (substring == &quot;trap&quot;)</span>
<span class="line-removed">289         return Token::Type::Trap;</span>
<span class="line-removed">290     if (substring == &quot;null&quot;)</span>
<span class="line-removed">291         return Token::Type::Null;</span>
<span class="line-removed">292     if (substring == &quot;true&quot;)</span>
<span class="line-removed">293         return Token::Type::True;</span>
<span class="line-removed">294     if (substring == &quot;false&quot;)</span>
<span class="line-removed">295         return Token::Type::False;</span>
<span class="line-removed">296     if (substring == &quot;constant&quot;)</span>
<span class="line-removed">297         return Token::Type::Constant;</span>
<span class="line-removed">298     if (substring == &quot;device&quot;)</span>
<span class="line-removed">299         return Token::Type::Device;</span>
<span class="line-removed">300     if (substring == &quot;threadgroup&quot;)</span>
<span class="line-removed">301         return Token::Type::Threadgroup;</span>
<span class="line-removed">302     if (substring == &quot;thread&quot;)</span>
<span class="line-removed">303         return Token::Type::Thread;</span>
<span class="line-removed">304     if (substring == &quot;space&quot;)</span>
<span class="line-removed">305         return Token::Type::Space;</span>
<span class="line-removed">306     if (substring == &quot;vertex&quot;)</span>
<span class="line-removed">307         return Token::Type::Vertex;</span>
<span class="line-removed">308     if (substring == &quot;fragment&quot;)</span>
<span class="line-removed">309         return Token::Type::Fragment;</span>
<span class="line-removed">310     if (substring == &quot;compute&quot;)</span>
<span class="line-removed">311         return Token::Type::Compute;</span>
<span class="line-removed">312     if (substring == &quot;numthreads&quot;)</span>
<span class="line-removed">313         return Token::Type::NumThreads;</span>
<span class="line-removed">314     if (substring == &quot;SV_InstanceID&quot;)</span>
<span class="line-removed">315         return Token::Type::SVInstanceID;</span>
<span class="line-removed">316     if (substring == &quot;SV_VertexID&quot;)</span>
<span class="line-removed">317         return Token::Type::SVVertexID;</span>
<span class="line-removed">318     if (substring == &quot;PSIZE&quot;)</span>
<span class="line-removed">319         return Token::Type::PSize;</span>
<span class="line-removed">320     if (substring == &quot;SV_Position&quot;)</span>
<span class="line-removed">321         return Token::Type::SVPosition;</span>
<span class="line-removed">322     if (substring == &quot;SV_IsFrontFace&quot;)</span>
<span class="line-removed">323         return Token::Type::SVIsFrontFace;</span>
<span class="line-removed">324     if (substring == &quot;SV_SampleIndex&quot;)</span>
<span class="line-removed">325         return Token::Type::SVSampleIndex;</span>
<span class="line-removed">326     if (substring == &quot;SV_InnerCoverage&quot;)</span>
<span class="line-removed">327         return Token::Type::SVInnerCoverage;</span>
<span class="line-removed">328     if (substring == &quot;SV_Target&quot;)</span>
<span class="line-removed">329         return Token::Type::SVTarget;</span>
<span class="line-removed">330     if (substring == &quot;SV_Depth&quot;)</span>
<span class="line-removed">331         return Token::Type::SVDepth;</span>
<span class="line-removed">332     if (substring == &quot;SV_Coverage&quot;)</span>
<span class="line-removed">333         return Token::Type::SVCoverage;</span>
<span class="line-removed">334     if (substring == &quot;SV_DispatchThreadID&quot;)</span>
<span class="line-removed">335         return Token::Type::SVDispatchThreadID;</span>
<span class="line-removed">336     if (substring == &quot;SV_GroupID&quot;)</span>
<span class="line-removed">337         return Token::Type::SVGroupID;</span>
<span class="line-removed">338     if (substring == &quot;SV_GroupIndex&quot;)</span>
<span class="line-removed">339         return Token::Type::SVGroupIndex;</span>
<span class="line-removed">340     if (substring == &quot;SV_GroupThreadID&quot;)</span>
<span class="line-removed">341         return Token::Type::SVGroupThreadID;</span>
<span class="line-removed">342     if (substring == &quot;attribute&quot;)</span>
<span class="line-removed">343         return Token::Type::Attribute;</span>
<span class="line-removed">344     if (substring == &quot;register&quot;)</span>
<span class="line-removed">345         return Token::Type::Register;</span>
<span class="line-removed">346     if (substring == &quot;specialized&quot;)</span>
<span class="line-removed">347         return Token::Type::Specialized;</span>
<span class="line-removed">348     if (substring == &quot;native&quot;)</span>
<span class="line-removed">349         return Token::Type::Native;</span>
<span class="line-removed">350     if (substring == &quot;restricted&quot;)</span>
<span class="line-removed">351         return Token::Type::Restricted;</span>
<span class="line-removed">352     if (substring == &quot;_&quot;)</span>
<span class="line-removed">353         return Token::Type::Underscore;</span>
<span class="line-removed">354     if (substring == &quot;auto&quot;)</span>
<span class="line-removed">355         return Token::Type::Auto;</span>
<span class="line-removed">356     if (substring == &quot;protocol&quot;)</span>
<span class="line-removed">357         return Token::Type::Protocol;</span>
<span class="line-removed">358     if (substring == &quot;const&quot;)</span>
<span class="line-removed">359         return Token::Type::Const;</span>
<span class="line-removed">360     if (substring == &quot;static&quot;)</span>
<span class="line-removed">361         return Token::Type::Static;</span>
<span class="line-removed">362     if (substring == &quot;nointerpolation&quot;)</span>
<span class="line-removed">363         return Token::Type::Qualifier;</span>
<span class="line-removed">364     if (substring == &quot;noperspective&quot;)</span>
<span class="line-removed">365         return Token::Type::Qualifier;</span>
<span class="line-removed">366     if (substring == &quot;uniform&quot;)</span>
<span class="line-removed">367         return Token::Type::Qualifier;</span>
<span class="line-removed">368     if (substring == &quot;centroid&quot;)</span>
<span class="line-removed">369         return Token::Type::Qualifier;</span>
<span class="line-removed">370     if (substring == &quot;sample&quot;)</span>
<span class="line-removed">371         return Token::Type::Qualifier;</span>
<span class="line-removed">372     return WTF::nullopt;</span>
373 }
374 
<a name="6" id="anc6"></a><span class="line-modified">375 auto Lexer::consumeTokenFromStream() -&gt; Optional&lt;Token&gt;</span>
376 {
<a name="7" id="anc7"></a><span class="line-modified">377     auto prepare = [&amp;](unsigned newOffset, Token::Type type) -&gt; Optional&lt;Token&gt; {</span>
<span class="line-modified">378         auto oldOffset = m_offset;</span>
<span class="line-modified">379         m_offset = newOffset;</span>
<span class="line-modified">380         skipWhitespaceAndComments();</span>
<span class="line-removed">381         return {{ m_stringView.substring(oldOffset, newOffset - oldOffset), m_lineNumber, type }};</span>
<span class="line-removed">382     };</span>
<span class="line-removed">383 </span>
<span class="line-removed">384     if (auto newOffset = floatLiteral(m_offset))</span>
<span class="line-removed">385         return prepare(*newOffset, Token::Type::FloatLiteral);</span>
<span class="line-removed">386     if (auto newOffset = uintLiteral(m_offset))</span>
<span class="line-removed">387         return prepare(*newOffset, Token::Type::UintLiteral);</span>
<span class="line-removed">388     if (auto newOffset = intLiteral(m_offset))</span>
<span class="line-removed">389         return prepare(*newOffset, Token::Type::IntLiteral);</span>
<span class="line-removed">390     if (auto newOffset = operatorName(m_offset))</span>
<span class="line-removed">391         return prepare(*newOffset, Token::Type::OperatorName);</span>
<span class="line-removed">392     if (auto newOffset = identifier(m_offset)) {</span>
<span class="line-removed">393         if (auto result = recognizeKeyword(*newOffset))</span>
<span class="line-removed">394             return prepare(*newOffset, *result);</span>
<span class="line-removed">395         return prepare(*newOffset, Token::Type::Identifier);</span>
<span class="line-removed">396     }</span>
<span class="line-removed">397     // Sorted by length, so longer matches are preferable to shorter matches.</span>
<span class="line-removed">398     if (auto newOffset = string(&quot;&gt;&gt;=&quot;, m_offset))</span>
<span class="line-removed">399         return prepare(*newOffset, Token::Type::RightShiftEquals);</span>
<span class="line-removed">400     if (auto newOffset = string(&quot;&lt;&lt;=&quot;, m_offset))</span>
<span class="line-removed">401         return prepare(*newOffset, Token::Type::LeftShiftEquals);</span>
<span class="line-removed">402     if (auto newOffset = string(&quot;+=&quot;, m_offset))</span>
<span class="line-removed">403         return prepare(*newOffset, Token::Type::PlusEquals);</span>
<span class="line-removed">404     if (auto newOffset = string(&quot;-=&quot;, m_offset))</span>
<span class="line-removed">405         return prepare(*newOffset, Token::Type::MinusEquals);</span>
<span class="line-removed">406     if (auto newOffset = string(&quot;*=&quot;, m_offset))</span>
<span class="line-removed">407         return prepare(*newOffset, Token::Type::TimesEquals);</span>
<span class="line-removed">408     if (auto newOffset = string(&quot;/=&quot;, m_offset))</span>
<span class="line-removed">409         return prepare(*newOffset, Token::Type::DivideEquals);</span>
<span class="line-removed">410     if (auto newOffset = string(&quot;%=&quot;, m_offset))</span>
<span class="line-removed">411         return prepare(*newOffset, Token::Type::ModEquals);</span>
<span class="line-removed">412     if (auto newOffset = string(&quot;^=&quot;, m_offset))</span>
<span class="line-removed">413         return prepare(*newOffset, Token::Type::XorEquals);</span>
<span class="line-removed">414     if (auto newOffset = string(&quot;&amp;=&quot;, m_offset))</span>
<span class="line-removed">415         return prepare(*newOffset, Token::Type::AndEquals);</span>
<span class="line-removed">416     if (auto newOffset = string(&quot;|=&quot;, m_offset))</span>
<span class="line-removed">417         return prepare(*newOffset, Token::Type::OrEquals);</span>
<span class="line-removed">418     if (auto newOffset = string(&quot;++&quot;, m_offset))</span>
<span class="line-removed">419         return prepare(*newOffset, Token::Type::PlusPlus);</span>
<span class="line-removed">420     if (auto newOffset = string(&quot;--&quot;, m_offset))</span>
<span class="line-removed">421         return prepare(*newOffset, Token::Type::MinusMinus);</span>
<span class="line-removed">422     if (auto newOffset = string(&quot;-&gt;&quot;, m_offset))</span>
<span class="line-removed">423         return prepare(*newOffset, Token::Type::Arrow);</span>
<span class="line-removed">424     if (auto newOffset = string(&quot;[]&quot;, m_offset))</span>
<span class="line-removed">425         return prepare(*newOffset, Token::Type::SquareBracketPair);</span>
<span class="line-removed">426     if (auto newOffset = string(&quot;||&quot;, m_offset))</span>
<span class="line-removed">427         return prepare(*newOffset, Token::Type::OrOr);</span>
<span class="line-removed">428     if (auto newOffset = string(&quot;&amp;&amp;&quot;, m_offset))</span>
<span class="line-removed">429         return prepare(*newOffset, Token::Type::AndAnd);</span>
<span class="line-removed">430     if (auto newOffset = string(&quot;&lt;=&quot;, m_offset))</span>
<span class="line-removed">431         return prepare(*newOffset, Token::Type::LessThanOrEqualTo);</span>
<span class="line-removed">432     if (auto newOffset = string(&quot;&gt;=&quot;, m_offset))</span>
<span class="line-removed">433         return prepare(*newOffset, Token::Type::GreaterThanOrEqualTo);</span>
<span class="line-removed">434     if (auto newOffset = string(&quot;==&quot;, m_offset))</span>
<span class="line-removed">435         return prepare(*newOffset, Token::Type::EqualComparison);</span>
<span class="line-removed">436     if (auto newOffset = string(&quot;!=&quot;, m_offset))</span>
<span class="line-removed">437         return prepare(*newOffset, Token::Type::NotEqual);</span>
<span class="line-removed">438     if (auto newOffset = string(&quot;&gt;&gt;&quot;, m_offset))</span>
<span class="line-removed">439         return prepare(*newOffset, Token::Type::RightShift);</span>
<span class="line-removed">440     if (auto newOffset = string(&quot;&lt;&lt;&quot;, m_offset))</span>
<span class="line-removed">441         return prepare(*newOffset, Token::Type::LeftShift);</span>
<span class="line-removed">442     if (auto newOffset = character(&#39;=&#39;, m_offset))</span>
<span class="line-removed">443         return prepare(*newOffset, Token::Type::EqualsSign);</span>
<span class="line-removed">444     if (auto newOffset = character(&#39;;&#39;, m_offset))</span>
<span class="line-removed">445         return prepare(*newOffset, Token::Type::Semicolon);</span>
<span class="line-removed">446     if (auto newOffset = character(&#39;{&#39;, m_offset))</span>
<span class="line-removed">447         return prepare(*newOffset, Token::Type::LeftCurlyBracket);</span>
<span class="line-removed">448     if (auto newOffset = character(&#39;}&#39;, m_offset))</span>
<span class="line-removed">449         return prepare(*newOffset, Token::Type::RightCurlyBracket);</span>
<span class="line-removed">450     if (auto newOffset = character(&#39;:&#39;, m_offset))</span>
<span class="line-removed">451         return prepare(*newOffset, Token::Type::Colon);</span>
<span class="line-removed">452     if (auto newOffset = character(&#39;,&#39;, m_offset))</span>
<span class="line-removed">453         return prepare(*newOffset, Token::Type::Comma);</span>
<span class="line-removed">454     if (auto newOffset = character(&#39;(&#39;, m_offset))</span>
<span class="line-removed">455         return prepare(*newOffset, Token::Type::LeftParenthesis);</span>
<span class="line-removed">456     if (auto newOffset = character(&#39;)&#39;, m_offset))</span>
<span class="line-removed">457         return prepare(*newOffset, Token::Type::RightParenthesis);</span>
<span class="line-removed">458     if (auto newOffset = character(&#39;[&#39;, m_offset))</span>
<span class="line-removed">459         return prepare(*newOffset, Token::Type::LeftSquareBracket);</span>
<span class="line-removed">460     if (auto newOffset = character(&#39;]&#39;, m_offset))</span>
<span class="line-removed">461         return prepare(*newOffset, Token::Type::RightSquareBracket);</span>
<span class="line-removed">462     if (auto newOffset = character(&#39;*&#39;, m_offset))</span>
<span class="line-removed">463         return prepare(*newOffset, Token::Type::Star);</span>
<span class="line-removed">464     if (auto newOffset = character(&#39;&lt;&#39;, m_offset))</span>
<span class="line-removed">465         return prepare(*newOffset, Token::Type::LessThanSign);</span>
<span class="line-removed">466     if (auto newOffset = character(&#39;&gt;&#39;, m_offset))</span>
<span class="line-removed">467         return prepare(*newOffset, Token::Type::GreaterThanSign);</span>
<span class="line-removed">468     if (auto newOffset = character(&#39;.&#39;, m_offset))</span>
<span class="line-removed">469         return prepare(*newOffset, Token::Type::FullStop);</span>
<span class="line-removed">470     if (auto newOffset = character(&#39;?&#39;, m_offset))</span>
<span class="line-removed">471         return prepare(*newOffset, Token::Type::QuestionMark);</span>
<span class="line-removed">472     if (auto newOffset = character(&#39;|&#39;, m_offset))</span>
<span class="line-removed">473         return prepare(*newOffset, Token::Type::Or);</span>
<span class="line-removed">474     if (auto newOffset = character(&#39;^&#39;, m_offset))</span>
<span class="line-removed">475         return prepare(*newOffset, Token::Type::Xor);</span>
<span class="line-removed">476     if (auto newOffset = character(&#39;&amp;&#39;, m_offset))</span>
<span class="line-removed">477         return prepare(*newOffset, Token::Type::And);</span>
<span class="line-removed">478     if (auto newOffset = character(&#39;+&#39;, m_offset))</span>
<span class="line-removed">479         return prepare(*newOffset, Token::Type::Plus);</span>
<span class="line-removed">480     if (auto newOffset = character(&#39;-&#39;, m_offset))</span>
<span class="line-removed">481         return prepare(*newOffset, Token::Type::Minus);</span>
<span class="line-removed">482     if (auto newOffset = character(&#39;/&#39;, m_offset))</span>
<span class="line-removed">483         return prepare(*newOffset, Token::Type::Divide);</span>
<span class="line-removed">484     if (auto newOffset = character(&#39;%&#39;, m_offset))</span>
<span class="line-removed">485         return prepare(*newOffset, Token::Type::Mod);</span>
<span class="line-removed">486     if (auto newOffset = character(&#39;~&#39;, m_offset))</span>
<span class="line-removed">487         return prepare(*newOffset, Token::Type::Tilde);</span>
<span class="line-removed">488     if (auto newOffset = character(&#39;!&#39;, m_offset))</span>
<span class="line-removed">489         return prepare(*newOffset, Token::Type::ExclamationPoint);</span>
<span class="line-removed">490     if (auto newOffset = character(&#39;@&#39;, m_offset))</span>
<span class="line-removed">491         return prepare(*newOffset, Token::Type::At);</span>
<span class="line-removed">492 </span>
<span class="line-removed">493     return WTF::nullopt;</span>
494 }
495 
<a name="8" id="anc8"></a><span class="line-modified">496 void Lexer::skipWhitespaceAndComments()</span>
497 {
<a name="9" id="anc9"></a><span class="line-modified">498     unsigned savedOffset;</span>
<span class="line-modified">499     do {</span>
<span class="line-modified">500         savedOffset = m_offset;</span>
<span class="line-removed">501         skipWhitespace();</span>
<span class="line-removed">502         skipLineComment();</span>
<span class="line-removed">503         skipLongComment();</span>
<span class="line-removed">504     } while (savedOffset != m_offset);</span>
505 }
506 
<a name="10" id="anc10"></a><span class="line-modified">507 static inline bool isWhitespace(UChar codeUnit)</span>
508 {
<a name="11" id="anc11"></a><span class="line-modified">509     switch (codeUnit) {</span>
<span class="line-removed">510     case &#39; &#39;:</span>
<span class="line-removed">511     case &#39;\t&#39;:</span>
<span class="line-removed">512     case &#39;\r&#39;:</span>
<span class="line-removed">513     case &#39;\n&#39;:</span>
<span class="line-removed">514         return true;</span>
<span class="line-removed">515     default:</span>
<span class="line-removed">516         return false;</span>
<span class="line-removed">517     }</span>
518 }
519 
<a name="12" id="anc12"></a><span class="line-modified">520 static inline bool isNewline(UChar codeUnit)</span>
521 {
<a name="13" id="anc13"></a><span class="line-modified">522     switch (codeUnit) {</span>
<span class="line-modified">523     case &#39;\r&#39;:</span>
<span class="line-modified">524     case &#39;\n&#39;:</span>
<span class="line-modified">525         return true;</span>
<span class="line-modified">526     default:</span>



















527         return false;
<a name="14" id="anc14"></a><span class="line-modified">528     }</span>
<span class="line-removed">529 }</span>
530 
<a name="15" id="anc15"></a><span class="line-modified">531 // We can take advantage of two properties of Unicode:</span>
<span class="line-modified">532 // 1. The consitutent UTF-16 code units for all non-BMP code points are surrogates,</span>
<span class="line-modified">533 //        which means we&#39;ll never see a false match. If we see a BMP code unit, we</span>
<span class="line-removed">534 //        really have a BMP code point.</span>
<span class="line-removed">535 // 2. Everything we&#39;re looking for is in BMP</span>
536 
<a name="16" id="anc16"></a><span class="line-modified">537 void Lexer::skipWhitespace()</span>
<span class="line-modified">538 {</span>
<span class="line-modified">539     for ( ; m_offset &lt; m_stringView.length() &amp;&amp; isWhitespace(m_stringView[m_offset]); ++m_offset) {</span>
<span class="line-modified">540         if (m_stringView[m_offset] == &#39;\r&#39; &amp;&amp; m_offset + 1 &lt; m_stringView.length() &amp;&amp; m_stringView[m_offset + 1] == &#39;\n&#39;) {</span>
<span class="line-modified">541             ++m_offset;</span>
<span class="line-modified">542             ++m_lineNumber;</span>
<span class="line-removed">543         } else if (isNewline(m_stringView[m_offset]))</span>
<span class="line-removed">544             ++m_lineNumber;</span>
<span class="line-removed">545     }</span>
<span class="line-removed">546 }</span>
547 
<a name="17" id="anc17"></a><span class="line-modified">548 void Lexer::skipLineComment()</span>
<span class="line-modified">549 {</span>
<span class="line-modified">550     if (m_offset + 1 &gt;= m_stringView.length() || m_stringView[m_offset] != &#39;/&#39; || m_stringView[m_offset + 1] != &#39;/&#39;)</span>
<span class="line-modified">551         return;</span>



































552 
<a name="18" id="anc18"></a><span class="line-modified">553     m_offset += 2;</span>
<span class="line-modified">554     for ( ; m_offset &lt; m_stringView.length() &amp;&amp; !isNewline(m_stringView[m_offset]); ++m_offset) { }</span>
<span class="line-modified">555 }</span>












556 
<a name="19" id="anc19"></a><span class="line-modified">557 void Lexer::skipLongComment()</span>
<span class="line-modified">558 {</span>
<span class="line-modified">559     if (m_offset + 1 &gt;= m_stringView.length() || m_stringView[m_offset] != &#39;/&#39; || m_stringView[m_offset + 1] != &#39;*&#39;)</span>
<span class="line-modified">560         return;</span>
<span class="line-modified">561 </span>
<span class="line-modified">562     m_offset += 2;</span>
<span class="line-modified">563     do {</span>
<span class="line-modified">564         for ( ; m_offset &lt; m_stringView.length() &amp;&amp; m_stringView[m_offset] != &#39;*&#39;; ++m_offset) {</span>
<span class="line-modified">565             if (m_stringView[m_offset] == &#39;\r&#39; &amp;&amp; m_offset + 1 &lt; m_stringView.length() &amp;&amp; m_stringView[m_offset + 1] == &#39;\n&#39;) {</span>
<span class="line-modified">566                 ++m_offset;</span>
<span class="line-modified">567                 ++m_lineNumber;</span>
<span class="line-modified">568             } else if (isNewline(m_stringView[m_offset]))</span>
<span class="line-modified">569                 ++m_lineNumber;</span>





































































570         }
<a name="20" id="anc20"></a><span class="line-modified">571         if (m_offset &lt; m_stringView.length())</span>
<span class="line-modified">572             ++m_offset;</span>
<span class="line-modified">573         if (m_offset &lt; m_stringView.length() &amp;&amp; m_stringView[m_offset] == &#39;/&#39;) {</span>
<span class="line-modified">574             ++m_offset;</span>















































































































































































































































































































































































































































































































575             break;
576         }
<a name="21" id="anc21"></a><span class="line-removed">577     } while (m_offset &lt; m_stringView.length());</span>
<span class="line-removed">578 }</span>
579 
<a name="22" id="anc22"></a><span class="line-modified">580 // Regular expression are unnecessary; we shouldn&#39;t need to compile them.</span>
581 
<a name="23" id="anc23"></a><span class="line-modified">582 Optional&lt;unsigned&gt; Lexer::coreDecimalIntLiteral(unsigned offset) const</span>
<span class="line-modified">583 {</span>
<span class="line-modified">584     if (offset &gt;= m_stringView.length())</span>
<span class="line-modified">585         return WTF::nullopt;</span>
<span class="line-modified">586     if (m_stringView[offset] == &#39;0&#39;)</span>
<span class="line-modified">587         return offset + 1;</span>
<span class="line-modified">588     if (m_stringView[offset] &gt;= &#39;1&#39; &amp;&amp; m_stringView[offset] &lt;= &#39;9&#39;) {</span>
<span class="line-modified">589         ++offset;</span>
<span class="line-modified">590         for ( ; offset &lt; m_stringView.length() &amp;&amp; m_stringView[offset] &gt;= &#39;0&#39; &amp;&amp; m_stringView[offset] &lt;= &#39;9&#39;; ++offset) {</span>























































































591         }
<a name="24" id="anc24"></a><span class="line-removed">592         return offset;</span>
<span class="line-removed">593     }</span>
<span class="line-removed">594     return WTF::nullopt;</span>
<span class="line-removed">595 }</span>
596 
<a name="25" id="anc25"></a><span class="line-modified">597 Optional&lt;unsigned&gt; Lexer::decimalIntLiteral(unsigned offset) const</span>
<span class="line-modified">598 {</span>
<span class="line-modified">599     if (offset &lt; m_stringView.length() &amp;&amp; m_stringView[offset] == &#39;-&#39;)</span>
<span class="line-modified">600         ++offset;</span>
<span class="line-modified">601     return coreDecimalIntLiteral(offset);</span>
<span class="line-modified">602 }</span>






603 
<a name="26" id="anc26"></a><span class="line-modified">604 Optional&lt;unsigned&gt; Lexer::decimalUintLiteral(unsigned offset) const</span>
<span class="line-modified">605 {</span>
<span class="line-modified">606     auto result = coreDecimalIntLiteral(offset);</span>
<span class="line-modified">607     if (!result)</span>
<span class="line-modified">608         return WTF::nullopt;</span>
<span class="line-modified">609     if (*result &lt; m_stringView.length() &amp;&amp; m_stringView[*result] == &#39;u&#39;)</span>
<span class="line-modified">610         return *result + 1;</span>
<span class="line-modified">611     return WTF::nullopt;</span>
<span class="line-modified">612 }</span>




























613 
<a name="27" id="anc27"></a><span class="line-modified">614 static inline bool isHexadecimalCharacter(UChar character)</span>
<span class="line-modified">615 {</span>
<span class="line-modified">616     return (character &gt;= &#39;0&#39; &amp;&amp; character &lt;= &#39;9&#39;)</span>
<span class="line-removed">617         || (character &gt;= &#39;a&#39; &amp;&amp; character &lt;= &#39;f&#39;)</span>
<span class="line-removed">618         || (character &gt;= &#39;A&#39; &amp;&amp; character &lt;= &#39;F&#39;);</span>
<span class="line-removed">619 }</span>
620 
<a name="28" id="anc28"></a><span class="line-removed">621 Optional&lt;unsigned&gt; Lexer::coreHexadecimalIntLiteral(unsigned offset) const</span>
<span class="line-removed">622 {</span>
<span class="line-removed">623     if (offset + 1 &gt;= m_stringView.length() || m_stringView[offset] != &#39;0&#39; || m_stringView[offset + 1] != &#39;x&#39;)</span>
<span class="line-removed">624         return WTF::nullopt;</span>
625 
<a name="29" id="anc29"></a><span class="line-modified">626     offset += 2;</span>
<span class="line-modified">627     if (offset &gt;= m_stringView.length() || !isHexadecimalCharacter(m_stringView[offset]))</span>
<span class="line-modified">628         return WTF::nullopt;</span>
<span class="line-modified">629     ++offset;</span>
<span class="line-modified">630     for ( ; offset &lt; m_stringView.length() &amp;&amp; isHexadecimalCharacter(m_stringView[offset]); ++offset) {</span>
<span class="line-modified">631     }</span>
<span class="line-modified">632     return offset;</span>
<span class="line-modified">633 }</span>






















634 
<a name="30" id="anc30"></a><span class="line-modified">635 Optional&lt;unsigned&gt; Lexer::hexadecimalIntLiteral(unsigned offset) const</span>
<span class="line-modified">636 {</span>
<span class="line-modified">637     if (offset &lt; m_stringView.length() &amp;&amp; m_stringView[offset] == &#39;-&#39;)</span>
<span class="line-modified">638         ++offset;</span>
<span class="line-modified">639     return coreHexadecimalIntLiteral(offset);</span>
<span class="line-modified">640 }</span>














641 
<a name="31" id="anc31"></a><span class="line-modified">642 Optional&lt;unsigned&gt; Lexer::hexadecimalUintLiteral(unsigned offset) const</span>
<span class="line-modified">643 {</span>
<span class="line-modified">644     auto result = coreHexadecimalIntLiteral(offset);</span>
<span class="line-modified">645     if (!result)</span>
<span class="line-modified">646         return WTF::nullopt;</span>
<span class="line-modified">647     if (*result &lt; m_stringView.length() &amp;&amp; m_stringView[*result] == &#39;u&#39;)</span>
<span class="line-modified">648         return *result + 1;</span>
<span class="line-modified">649     return WTF::nullopt;</span>
<span class="line-modified">650 }</span>































651 
<a name="32" id="anc32"></a><span class="line-modified">652 Optional&lt;unsigned&gt; Lexer::intLiteral(unsigned offset) const</span>
<span class="line-modified">653 {</span>
<span class="line-modified">654     if (auto result = decimalIntLiteral(offset))</span>
<span class="line-removed">655         return result;</span>
<span class="line-removed">656     if (auto result = hexadecimalIntLiteral(offset))</span>
<span class="line-removed">657         return result;</span>
<span class="line-removed">658     return WTF::nullopt;</span>
<span class="line-removed">659 }</span>
660 
<a name="33" id="anc33"></a><span class="line-modified">661 Optional&lt;unsigned&gt; Lexer::uintLiteral(unsigned offset) const</span>
<span class="line-modified">662 {</span>
<span class="line-modified">663     if (auto result = decimalUintLiteral(offset))</span>
<span class="line-modified">664         return result;</span>
<span class="line-modified">665     if (auto result = hexadecimalUintLiteral(offset))</span>
<span class="line-modified">666         return result;</span>
<span class="line-modified">667     return WTF::nullopt;</span>
<span class="line-modified">668 }</span>




669 
<a name="34" id="anc34"></a><span class="line-modified">670 Optional&lt;unsigned&gt; Lexer::digit(unsigned offset) const</span>
<span class="line-modified">671 {</span>
<span class="line-modified">672     if (offset &lt; m_stringView.length() &amp;&amp; m_stringView[offset] &gt;= &#39;0&#39; &amp;&amp; m_stringView[offset] &lt;= &#39;9&#39;)</span>
<span class="line-modified">673         return offset + 1;</span>
<span class="line-modified">674     return WTF::nullopt;</span>
<span class="line-modified">675 }</span>














































676 
<a name="35" id="anc35"></a><span class="line-modified">677 unsigned Lexer::digitStar(unsigned offset) const</span>
<span class="line-modified">678 {</span>
<span class="line-modified">679     while (true) {</span>
<span class="line-modified">680         auto result = digit(offset);</span>
<span class="line-modified">681         if (!result)</span>
<span class="line-modified">682             return offset;</span>
<span class="line-modified">683         offset = *result;</span>






















































































































































































































































































































































































684     }
<a name="36" id="anc36"></a><span class="line-removed">685 }</span>
686 
<a name="37" id="anc37"></a><span class="line-modified">687 Optional&lt;unsigned&gt; Lexer::character(char character, unsigned offset) const</span>
<span class="line-modified">688 {</span>
<span class="line-modified">689     if (offset &lt; m_stringView.length() &amp;&amp; m_stringView[offset] == character)</span>
<span class="line-modified">690         return offset + 1;</span>
<span class="line-modified">691     return WTF::nullopt;</span>


692 }
693 
<a name="38" id="anc38"></a><span class="line-modified">694 Optional&lt;unsigned&gt; Lexer::coreFloatLiteralType1(unsigned offset) const</span>







695 {
<a name="39" id="anc39"></a><span class="line-modified">696     auto result = digit(offset);</span>
<span class="line-modified">697     if (!result)</span>
<span class="line-modified">698         return WTF::nullopt;</span>
<span class="line-modified">699     auto result2 = digitStar(*result);</span>
<span class="line-modified">700     auto result3 = character(&#39;.&#39;, result2);</span>
<span class="line-modified">701     if (!result3)</span>
<span class="line-modified">702         return WTF::nullopt;</span>
<span class="line-modified">703     return digitStar(*result3);</span>

704 }
705 
<a name="40" id="anc40"></a><span class="line-modified">706 Optional&lt;unsigned&gt; Lexer::coreFloatLiteral(unsigned offset) const</span>
707 {
<a name="41" id="anc41"></a><span class="line-modified">708     if (auto type1 = coreFloatLiteralType1(offset))</span>
<span class="line-modified">709         return type1;</span>
<span class="line-modified">710     auto result = digitStar(offset);</span>
<span class="line-modified">711     auto result2 = character(&#39;.&#39;, result);</span>
<span class="line-modified">712     if (!result2)</span>
<span class="line-modified">713         return WTF::nullopt;</span>
<span class="line-modified">714     auto result3 = digit(*result2);</span>
<span class="line-removed">715     if (!result3)</span>
<span class="line-removed">716         return WTF::nullopt;</span>
<span class="line-removed">717     return digitStar(*result3);</span>
718 }
719 
<a name="42" id="anc42"></a><span class="line-modified">720 Optional&lt;unsigned&gt; Lexer::floatLiteral(unsigned offset) const</span>
721 {
<a name="43" id="anc43"></a><span class="line-modified">722     if (offset &lt; m_stringView.length() &amp;&amp; m_stringView[offset] == &#39;-&#39;)</span>
<span class="line-modified">723         ++offset;</span>
<span class="line-modified">724     auto result = coreFloatLiteral(offset);</span>
<span class="line-modified">725     if (!result)</span>
<span class="line-modified">726         return WTF::nullopt;</span>
<span class="line-modified">727     offset = *result;</span>
<span class="line-modified">728     if (offset &lt; m_stringView.length() &amp;&amp; m_stringView[offset] == &#39;f&#39;)</span>
<span class="line-modified">729         ++offset;</span>
<span class="line-modified">730     return offset;</span>


731 }
732 
<a name="44" id="anc44"></a><span class="line-modified">733 Optional&lt;unsigned&gt; Lexer::validIdentifier(unsigned offset) const</span>
734 {
<a name="45" id="anc45"></a><span class="line-modified">735     if (offset &gt;= m_stringView.length()</span>
<span class="line-modified">736         || !((m_stringView[offset] &gt;= &#39;a&#39; &amp;&amp; m_stringView[offset] &lt;= &#39;z&#39;)</span>
<span class="line-removed">737             || (m_stringView[offset] &gt;= &#39;A&#39; &amp;&amp; m_stringView[offset] &lt;= &#39;Z&#39;)</span>
<span class="line-removed">738             || (m_stringView[offset] == &#39;_&#39;)))</span>
739         return WTF::nullopt;
<a name="46" id="anc46"></a><span class="line-modified">740     ++offset;</span>
<span class="line-modified">741     while (true) {</span>
<span class="line-modified">742         if (offset &gt;= m_stringView.length()</span>
<span class="line-modified">743             || !((m_stringView[offset] &gt;= &#39;a&#39; &amp;&amp; m_stringView[offset] &lt;= &#39;z&#39;)</span>
<span class="line-modified">744                 || (m_stringView[offset] &gt;= &#39;A&#39; &amp;&amp; m_stringView[offset] &lt;= &#39;Z&#39;)</span>
<span class="line-removed">745                 || (m_stringView[offset] &gt;= &#39;0&#39; &amp;&amp; m_stringView[offset] &lt;= &#39;9&#39;)</span>
<span class="line-removed">746                 || (m_stringView[offset] == &#39;_&#39;)))</span>
<span class="line-removed">747             return offset;</span>
<span class="line-removed">748         ++offset;</span>
749     }
750 }
751 
<a name="47" id="anc47"></a><span class="line-modified">752 Optional&lt;unsigned&gt; Lexer::identifier(unsigned offset) const</span>
753 {
<a name="48" id="anc48"></a><span class="line-modified">754     return validIdentifier(offset);</span>






755 }
756 
<a name="49" id="anc49"></a><span class="line-modified">757 Optional&lt;unsigned&gt; Lexer::operatorName(unsigned offset) const</span>
758 {
<a name="50" id="anc50"></a><span class="line-modified">759     if (auto result = string(&quot;operator&amp;.&quot;, offset))</span>
<span class="line-modified">760         return validIdentifier(*result);</span>
<span class="line-modified">761     if (auto result = string(&quot;operator.&quot;, offset)) {</span>
<span class="line-modified">762         if ((result = validIdentifier(*result))) {</span>
<span class="line-modified">763             if (auto result2 = character(&#39;=&#39;, *result))</span>
<span class="line-modified">764                 return result2;</span>
<span class="line-modified">765             return *result;</span>
<span class="line-modified">766         }</span>
<span class="line-modified">767     }</span>
<span class="line-modified">768     if (auto result = string(&quot;operator&quot;, offset)) {</span>
<span class="line-modified">769         // Sorted by length, so longer matches are preferable to shorter matches.</span>
<span class="line-modified">770         if (auto result2 = string(&quot;&amp;[]&quot;, *result))</span>
<span class="line-modified">771             return result2;</span>
<span class="line-modified">772         if (auto result2 = string(&quot;[]=&quot;, *result))</span>
<span class="line-modified">773             return result2;</span>
<span class="line-modified">774         if (auto result2 = string(&quot;&gt;&gt;&quot;, *result))</span>
<span class="line-modified">775             return result2;</span>
<span class="line-modified">776         if (auto result2 = string(&quot;&lt;&lt;&quot;, *result))</span>
<span class="line-modified">777             return result2;</span>
<span class="line-modified">778         if (auto result2 = string(&quot;++&quot;, *result))</span>
<span class="line-modified">779             return result2;</span>
<span class="line-removed">780         if (auto result2 = string(&quot;--&quot;, *result))</span>
<span class="line-removed">781             return result2;</span>
<span class="line-removed">782         if (auto result2 = string(&quot;&amp;&amp;&quot;, *result))</span>
<span class="line-removed">783             return result2;</span>
<span class="line-removed">784         if (auto result2 = string(&quot;||&quot;, *result))</span>
<span class="line-removed">785             return result2;</span>
<span class="line-removed">786         if (auto result2 = string(&quot;&gt;=&quot;, *result))</span>
<span class="line-removed">787             return result2;</span>
<span class="line-removed">788         if (auto result2 = string(&quot;&lt;=&quot;, *result))</span>
<span class="line-removed">789             return result2;</span>
<span class="line-removed">790         if (auto result2 = string(&quot;==&quot;, *result))</span>
<span class="line-removed">791             return result2;</span>
<span class="line-removed">792         if (auto result2 = string(&quot;[]&quot;, *result))</span>
<span class="line-removed">793             return result2;</span>
<span class="line-removed">794         if (auto result2 = character(&#39;+&#39;, *result))</span>
<span class="line-removed">795             return result2;</span>
<span class="line-removed">796         if (auto result2 = character(&#39;-&#39;, *result))</span>
<span class="line-removed">797             return result2;</span>
<span class="line-removed">798         if (auto result2 = character(&#39;*&#39;, *result))</span>
<span class="line-removed">799             return result2;</span>
<span class="line-removed">800         if (auto result2 = character(&#39;/&#39;, *result))</span>
<span class="line-removed">801             return result2;</span>
<span class="line-removed">802         if (auto result2 = character(&#39;%&#39;, *result))</span>
<span class="line-removed">803             return result2;</span>
<span class="line-removed">804         if (auto result2 = character(&#39;&lt;&#39;, *result))</span>
<span class="line-removed">805             return result2;</span>
<span class="line-removed">806         if (auto result2 = character(&#39;&gt;&#39;, *result))</span>
<span class="line-removed">807             return result2;</span>
<span class="line-removed">808         if (auto result2 = character(&#39;!&#39;, *result))</span>
<span class="line-removed">809             return result2;</span>
<span class="line-removed">810         if (auto result2 = character(&#39;~&#39;, *result))</span>
<span class="line-removed">811             return result2;</span>
<span class="line-removed">812         if (auto result2 = character(&#39;&amp;&#39;, *result))</span>
<span class="line-removed">813             return result2;</span>
<span class="line-removed">814         if (auto result2 = character(&#39;^&#39;, *result))</span>
<span class="line-removed">815             return result2;</span>
<span class="line-removed">816         if (auto result2 = character(&#39;|&#39;, *result))</span>
<span class="line-removed">817             return result2;</span>
818     }
<a name="51" id="anc51"></a><span class="line-removed">819     return WTF::nullopt;</span>
820 }
821 
822 } // namespace WHLSL
823 
824 } // namespace WebCore
825 
826 #endif // ENABLE(WEBGPU)
<a name="52" id="anc52"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="52" type="hidden" />
</body>
</html>