<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/editing/Editor.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (C) 2006-2016 Apple Inc. All rights reserved.
   3  * Copyright (C) 2008 Nokia Corporation and/or its subsidiary(-ies)
   4  *
   5  * Redistribution and use in source and binary forms, with or without
   6  * modification, are permitted provided that the following conditions
   7  * are met:
   8  * 1. Redistributions of source code must retain the above copyright
   9  *    notice, this list of conditions and the following disclaimer.
  10  * 2. Redistributions in binary form must reproduce the above copyright
  11  *    notice, this list of conditions and the following disclaimer in the
  12  *    documentation and/or other materials provided with the distribution.
  13  *
  14  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  15  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  16  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  17  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  18  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  19  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  20  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  21  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  22  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  23  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  24  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  25  */
  26 
  27 #include &quot;config.h&quot;
  28 #include &quot;Editor.h&quot;
  29 
  30 #include &quot;AXObjectCache.h&quot;
  31 #include &quot;AlternativeTextController.h&quot;
  32 #include &quot;ApplyStyleCommand.h&quot;
  33 #include &quot;CSSComputedStyleDeclaration.h&quot;
  34 #include &quot;CSSPropertyNames.h&quot;
  35 #include &quot;CSSValueList.h&quot;
  36 #include &quot;CSSValuePool.h&quot;
  37 #include &quot;CachedResourceLoader.h&quot;
  38 #include &quot;ChangeListTypeCommand.h&quot;
  39 #include &quot;ClipboardEvent.h&quot;
  40 #include &quot;CompositionEvent.h&quot;
  41 #include &quot;CreateLinkCommand.h&quot;
  42 #include &quot;CustomUndoStep.h&quot;
  43 #include &quot;DataTransfer.h&quot;
  44 #include &quot;DeleteSelectionCommand.h&quot;
  45 #include &quot;DictationAlternative.h&quot;
  46 #include &quot;DictationCommand.h&quot;
  47 #include &quot;DocumentFragment.h&quot;
  48 #include &quot;DocumentMarkerController.h&quot;
  49 #include &quot;Editing.h&quot;
  50 #include &quot;EditorClient.h&quot;
  51 #include &quot;EventHandler.h&quot;
  52 #include &quot;EventNames.h&quot;
  53 #include &quot;File.h&quot;
  54 #include &quot;FocusController.h&quot;
  55 #include &quot;FontAttributes.h&quot;
  56 #include &quot;Frame.h&quot;
  57 #include &quot;FrameLoader.h&quot;
  58 #include &quot;FrameTree.h&quot;
  59 #include &quot;FrameView.h&quot;
  60 #include &quot;GraphicsContext.h&quot;
  61 #include &quot;HTMLAttachmentElement.h&quot;
  62 #include &quot;HTMLBRElement.h&quot;
  63 #include &quot;HTMLCollection.h&quot;
  64 #include &quot;HTMLFormControlElement.h&quot;
  65 #include &quot;HTMLFrameOwnerElement.h&quot;
  66 #include &quot;HTMLImageElement.h&quot;
  67 #include &quot;HTMLInputElement.h&quot;
  68 #include &quot;HTMLNames.h&quot;
  69 #include &quot;HTMLOListElement.h&quot;
  70 #include &quot;HTMLQuoteElement.h&quot;
  71 #include &quot;HTMLSpanElement.h&quot;
  72 #include &quot;HTMLUListElement.h&quot;
  73 #include &quot;HitTestResult.h&quot;
  74 #include &quot;IndentOutdentCommand.h&quot;
  75 #include &quot;InputEvent.h&quot;
  76 #include &quot;InsertEditableImageCommand.h&quot;
  77 #include &quot;InsertListCommand.h&quot;
  78 #include &quot;InsertTextCommand.h&quot;
  79 #include &quot;KeyboardEvent.h&quot;
  80 #include &quot;Logging.h&quot;
  81 #include &quot;ModifySelectionListLevel.h&quot;
  82 #include &quot;NodeList.h&quot;
  83 #include &quot;NodeTraversal.h&quot;
  84 #include &quot;Page.h&quot;
  85 #include &quot;Pasteboard.h&quot;
  86 #include &quot;Range.h&quot;
  87 #include &quot;RemoveFormatCommand.h&quot;
  88 #include &quot;RenderBlock.h&quot;
  89 #include &quot;RenderTextControl.h&quot;
  90 #include &quot;RenderedDocumentMarker.h&quot;
  91 #include &quot;RenderedPosition.h&quot;
  92 #include &quot;ReplaceRangeWithTextCommand.h&quot;
  93 #include &quot;ReplaceSelectionCommand.h&quot;
  94 #include &quot;RuntimeEnabledFeatures.h&quot;
  95 #include &quot;SerializedAttachmentData.h&quot;
  96 #include &quot;Settings.h&quot;
  97 #include &quot;ShadowRoot.h&quot;
  98 #include &quot;SharedBuffer.h&quot;
  99 #include &quot;SimplifyMarkupCommand.h&quot;
 100 #include &quot;SpellChecker.h&quot;
 101 #include &quot;SpellingCorrectionCommand.h&quot;
 102 #include &quot;StaticPasteboard.h&quot;
 103 #include &quot;StyleProperties.h&quot;
 104 #include &quot;TelephoneNumberDetector.h&quot;
 105 #include &quot;Text.h&quot;
 106 #include &quot;TextCheckerClient.h&quot;
 107 #include &quot;TextCheckingHelper.h&quot;
 108 #include &quot;TextEvent.h&quot;
 109 #include &quot;TextIterator.h&quot;
 110 #include &quot;TypingCommand.h&quot;
 111 #include &quot;UserTypingGestureIndicator.h&quot;
 112 #include &quot;VisibleUnits.h&quot;
 113 #include &quot;markup.h&quot;
 114 #include &lt;pal/FileSizeFormatter.h&gt;
 115 #include &lt;pal/system/Sound.h&gt;
 116 #include &lt;pal/text/KillRing.h&gt;
 117 #include &lt;wtf/unicode/CharacterNames.h&gt;
 118 
 119 #if PLATFORM(MAC)
 120 #include &quot;ServicesOverlayController.h&quot;
 121 #endif
 122 
 123 namespace WebCore {
 124 
<a name="1" id="anc1"></a><span class="line-modified"> 125 static bool dispatchBeforeInputEvent(Element&amp; element, const AtomString&amp; inputType, const String&amp; data = { }, RefPtr&lt;DataTransfer&gt;&amp;&amp; dataTransfer = nullptr, const Vector&lt;RefPtr&lt;StaticRange&gt;&gt;&amp; targetRanges = { }, Event::IsCancelable cancelable = Event::IsCancelable::Yes)</span>
 126 {
 127     if (!element.document().settings().inputEventsEnabled())
 128         return true;
 129 
 130     auto event = InputEvent::create(eventNames().beforeinputEvent, inputType, cancelable, element.document().windowProxy(), data, WTFMove(dataTransfer), targetRanges, 0);
 131     element.dispatchEvent(event);
 132     return !event-&gt;defaultPrevented();
 133 }
 134 
<a name="2" id="anc2"></a><span class="line-modified"> 135 static void dispatchInputEvent(Element&amp; element, const AtomString&amp; inputType, const String&amp; data = { }, RefPtr&lt;DataTransfer&gt;&amp;&amp; dataTransfer = nullptr, const Vector&lt;RefPtr&lt;StaticRange&gt;&gt;&amp; targetRanges = { })</span>
 136 {
 137     if (element.document().settings().inputEventsEnabled()) {
 138         // FIXME: We should not be dispatching to the scoped queue here. Normally, input events are dispatched in CompositeEditCommand::apply after the end of the scope,
 139         // but TypingCommands are special in that existing TypingCommands that are applied again fire input events *from within* the scope by calling typingAddedToOpenCommand.
 140         // Instead, TypingCommands should always dispatch events synchronously after the end of the scoped queue in CompositeEditCommand::apply. To work around this for the
 141         // time being, just revert back to calling dispatchScopedEvent.
 142         element.dispatchScopedEvent(InputEvent::create(eventNames().inputEvent, inputType, Event::IsCancelable::No,
 143             element.document().windowProxy(), data, WTFMove(dataTransfer), targetRanges, 0));
 144     } else
 145         element.dispatchInputEvent();
 146 }
 147 
 148 static String inputEventDataForEditingStyleAndAction(const StyleProperties* style, EditAction action)
 149 {
 150     if (!style)
 151         return { };
 152 
 153     switch (action) {
 154     case EditAction::SetColor:
 155         return style-&gt;getPropertyValue(CSSPropertyColor);
<a name="3" id="anc3"></a><span class="line-modified"> 156     case EditAction::SetInlineWritingDirection:</span>
<span class="line-added"> 157     case EditAction::SetBlockWritingDirection:</span>
 158         return style-&gt;getPropertyValue(CSSPropertyDirection);
 159     default:
 160         return { };
 161     }
 162 }
 163 
 164 static String inputEventDataForEditingStyleAndAction(EditingStyle&amp; style, EditAction action)
 165 {
 166     return inputEventDataForEditingStyleAndAction(style.style(), action);
 167 }
 168 
 169 class ClearTextCommand : public DeleteSelectionCommand {
 170 public:
 171     ClearTextCommand(Document&amp; document);
 172     static void CreateAndApply(const RefPtr&lt;Frame&gt; frame);
 173 
 174 private:
 175     EditAction editingAction() const override;
 176 };
 177 
 178 ClearTextCommand::ClearTextCommand(Document&amp; document)
 179     : DeleteSelectionCommand(document, false, true, false, false, true)
 180 {
 181 }
 182 
 183 EditAction ClearTextCommand::editingAction() const
 184 {
 185     return EditAction::Delete;
 186 }
 187 
 188 void ClearTextCommand::CreateAndApply(const RefPtr&lt;Frame&gt; frame)
 189 {
 190     if (frame-&gt;selection().isNone())
 191         return;
 192 
 193     // Don&#39;t leave around stale composition state.
 194     frame-&gt;editor().clear();
 195 
 196     const VisibleSelection oldSelection = frame-&gt;selection().selection();
 197     frame-&gt;selection().selectAll();
 198     auto clearCommand = adoptRef(*new ClearTextCommand(*frame-&gt;document()));
 199     clearCommand-&gt;setStartingSelection(oldSelection);
 200     clearCommand-&gt;apply();
 201 }
 202 
 203 using namespace HTMLNames;
 204 using namespace WTF::Unicode;
 205 
 206 TemporarySelectionChange::TemporarySelectionChange(Frame&amp; frame, Optional&lt;VisibleSelection&gt; temporarySelection, OptionSet&lt;TemporarySelectionOption&gt; options)
 207     : m_frame(frame)
 208     , m_options(options)
 209     , m_wasIgnoringSelectionChanges(frame.editor().ignoreSelectionChanges())
 210 #if PLATFORM(IOS_FAMILY)
 211     , m_appearanceUpdatesWereEnabled(frame.selection().isUpdateAppearanceEnabled())
 212 #endif
 213 {
 214 #if PLATFORM(IOS_FAMILY)
 215     if (options &amp; TemporarySelectionOption::EnableAppearanceUpdates)
 216         frame.selection().setUpdateAppearanceEnabled(true);
 217 #endif
 218 
 219     if (options &amp; TemporarySelectionOption::IgnoreSelectionChanges)
 220         frame.editor().setIgnoreSelectionChanges(true);
 221 
 222     if (temporarySelection) {
 223         m_selectionToRestore = frame.selection().selection();
 224         setSelection(temporarySelection.value());
 225     }
 226 }
 227 
 228 TemporarySelectionChange::~TemporarySelectionChange()
 229 {
 230     if (m_selectionToRestore)
 231         setSelection(m_selectionToRestore.value());
 232 
 233     if (m_options &amp; TemporarySelectionOption::IgnoreSelectionChanges) {
 234         auto revealSelection = m_options &amp; TemporarySelectionOption::RevealSelection ? Editor::RevealSelection::Yes : Editor::RevealSelection::No;
 235         m_frame-&gt;editor().setIgnoreSelectionChanges(m_wasIgnoringSelectionChanges, revealSelection);
 236     }
 237 
 238 #if PLATFORM(IOS_FAMILY)
 239     if (m_options &amp; TemporarySelectionOption::EnableAppearanceUpdates)
 240         m_frame-&gt;selection().setUpdateAppearanceEnabled(m_appearanceUpdatesWereEnabled);
 241 #endif
 242 }
 243 
 244 void TemporarySelectionChange::setSelection(const VisibleSelection&amp; selection)
 245 {
 246     auto options = FrameSelection::defaultSetSelectionOptions();
 247     if (m_options &amp; TemporarySelectionOption::DoNotSetFocus)
 248         options.add(FrameSelection::DoNotSetFocus);
 249     m_frame-&gt;selection().setSelection(selection, options);
 250 }
 251 
 252 // When an event handler has moved the selection outside of a text control
 253 // we should use the target control&#39;s selection for this editing operation.
 254 VisibleSelection Editor::selectionForCommand(Event* event)
 255 {
 256     auto selection = m_frame.selection().selection();
 257     if (!event)
 258         return selection;
 259     // If the target is a text control, and the current selection is outside of its shadow tree,
 260     // then use the saved selection for that text control.
 261     if (is&lt;Element&gt;(event-&gt;target()) &amp;&amp; downcast&lt;Element&gt;(*event-&gt;target()).isTextField()) {
 262         auto&amp; target = downcast&lt;HTMLTextFormControlElement&gt;(*event-&gt;target());
 263         auto start = selection.start();
 264         if (start.isNull() || &amp;target != enclosingTextFormControl(start)) {
 265             if (auto range = target.selection())
 266                 return { *range, DOWNSTREAM, selection.isDirectional() };
 267         }
 268     }
 269     return selection;
 270 }
 271 
 272 // Function considers Mac editing behavior a fallback when Page or Settings is not available.
 273 EditingBehavior Editor::behavior() const
 274 {
 275     return EditingBehavior(m_frame.settings().editingBehaviorType());
 276 }
 277 
 278 EditorClient* Editor::client() const
 279 {
 280     if (Page* page = m_frame.page())
 281         return &amp;page-&gt;editorClient();
 282     return nullptr;
 283 }
 284 
 285 TextCheckerClient* Editor::textChecker() const
 286 {
 287     if (EditorClient* owner = client())
 288         return owner-&gt;textChecker();
 289     return 0;
 290 }
 291 
 292 void Editor::handleKeyboardEvent(KeyboardEvent&amp; event)
 293 {
<a name="4" id="anc4"></a><span class="line-modified"> 294     if (auto* client = this-&gt;client())</span>
<span class="line-modified"> 295         client-&gt;handleKeyboardEvent(event);</span>
 296 }
 297 
 298 void Editor::handleInputMethodKeydown(KeyboardEvent&amp; event)
 299 {
<a name="5" id="anc5"></a><span class="line-modified"> 300     if (auto* client = this-&gt;client())</span>
<span class="line-modified"> 301         client-&gt;handleInputMethodKeydown(event);</span>
 302 }
 303 
 304 bool Editor::handleTextEvent(TextEvent&amp; event)
 305 {
 306     LOG(Editing, &quot;Editor %p handleTextEvent (data %s)&quot;, this, event.data().utf8().data());
 307 
 308     // Default event handling for Drag and Drop will be handled by DragController
 309     // so we leave the event for it.
 310     if (event.isDrop())
 311         return false;
 312 
 313     if (event.isPaste()) {
 314         if (event.pastingFragment()) {
 315 #if PLATFORM(IOS_FAMILY)
 316             if (client()-&gt;performsTwoStepPaste(event.pastingFragment()))
 317                 return true;
 318 #endif
 319             replaceSelectionWithFragment(*event.pastingFragment(), SelectReplacement::No, event.shouldSmartReplace() ? SmartReplace::Yes : SmartReplace::No, event.shouldMatchStyle() ? MatchStyle::Yes : MatchStyle::No, EditAction::Paste, event.mailBlockquoteHandling());
 320         } else
 321             replaceSelectionWithText(event.data(), SelectReplacement::No, event.shouldSmartReplace() ? SmartReplace::Yes : SmartReplace::No, EditAction::Paste);
 322         return true;
 323     }
 324 
 325     String data = event.data();
 326     if (data == &quot;\n&quot;) {
 327         if (event.isLineBreak())
 328             return insertLineBreak();
 329         return insertParagraphSeparator();
 330     }
 331 
 332     return insertTextWithoutSendingTextEvent(data, false, &amp;event);
 333 }
 334 
 335 bool Editor::canEdit() const
 336 {
 337     return m_frame.selection().selection().rootEditableElement();
 338 }
 339 
 340 bool Editor::canEditRichly() const
 341 {
 342     return m_frame.selection().selection().isContentRichlyEditable();
 343 }
 344 
 345 enum class ClipboardEventKind {
 346     Copy,
 347     Cut,
 348     Paste,
 349     PasteAsPlainText,
 350     PasteAsQuotation,
 351     BeforeCopy,
 352     BeforeCut,
 353     BeforePaste,
 354 };
 355 
<a name="6" id="anc6"></a><span class="line-modified"> 356 static AtomString eventNameForClipboardEvent(ClipboardEventKind kind)</span>
 357 {
 358     switch (kind) {
 359     case ClipboardEventKind::Copy:
 360         return eventNames().copyEvent;
 361     case ClipboardEventKind::Cut:
 362         return eventNames().cutEvent;
 363     case ClipboardEventKind::Paste:
 364     case ClipboardEventKind::PasteAsPlainText:
 365     case ClipboardEventKind::PasteAsQuotation:
 366         return eventNames().pasteEvent;
 367     case ClipboardEventKind::BeforeCopy:
 368         return eventNames().beforecopyEvent;
 369     case ClipboardEventKind::BeforeCut:
 370         return eventNames().beforecutEvent;
 371     case ClipboardEventKind::BeforePaste:
 372         return eventNames().beforepasteEvent;
 373     }
 374     ASSERT_NOT_REACHED();
 375     return { };
 376 }
 377 
 378 static Ref&lt;DataTransfer&gt; createDataTransferForClipboardEvent(Document&amp; document, ClipboardEventKind kind)
 379 {
 380     switch (kind) {
 381     case ClipboardEventKind::Copy:
 382     case ClipboardEventKind::Cut:
<a name="7" id="anc7"></a><span class="line-modified"> 383         return DataTransfer::createForCopyAndPaste(document, DataTransfer::StoreMode::ReadWrite, makeUnique&lt;StaticPasteboard&gt;());</span>
 384     case ClipboardEventKind::PasteAsPlainText:
 385         if (RuntimeEnabledFeatures::sharedFeatures().customPasteboardDataEnabled()) {
 386             auto plainTextType = &quot;text/plain&quot;_s;
 387             auto plainText = Pasteboard::createForCopyAndPaste()-&gt;readString(plainTextType);
<a name="8" id="anc8"></a><span class="line-modified"> 388             auto pasteboard = makeUnique&lt;StaticPasteboard&gt;();</span>
 389             pasteboard-&gt;writeString(plainTextType, plainText);
 390             return DataTransfer::createForCopyAndPaste(document, DataTransfer::StoreMode::Readonly, WTFMove(pasteboard));
 391         }
 392         FALLTHROUGH;
 393     case ClipboardEventKind::Paste:
 394     case ClipboardEventKind::PasteAsQuotation:
 395         return DataTransfer::createForCopyAndPaste(document, DataTransfer::StoreMode::Readonly, Pasteboard::createForCopyAndPaste());
 396     case ClipboardEventKind::BeforeCopy:
 397     case ClipboardEventKind::BeforeCut:
 398     case ClipboardEventKind::BeforePaste:
<a name="9" id="anc9"></a><span class="line-modified"> 399         return DataTransfer::createForCopyAndPaste(document, DataTransfer::StoreMode::Invalid, makeUnique&lt;StaticPasteboard&gt;());</span>
 400     }
 401     ASSERT_NOT_REACHED();
<a name="10" id="anc10"></a><span class="line-modified"> 402     return DataTransfer::createForCopyAndPaste(document, DataTransfer::StoreMode::Invalid, makeUnique&lt;StaticPasteboard&gt;());</span>
 403 }
 404 
 405 // Returns whether caller should continue with &quot;the default processing&quot;, which is the same as
 406 // the event handler NOT setting the return value to false
 407 // https://w3c.github.io/clipboard-apis/#fire-a-clipboard-event
 408 static bool dispatchClipboardEvent(RefPtr&lt;Element&gt;&amp;&amp; target, ClipboardEventKind kind)
 409 {
 410     // FIXME: Move the target selection code here.
 411     if (!target)
 412         return true;
 413 
 414     auto dataTransfer = createDataTransferForClipboardEvent(target-&gt;document(), kind);
 415 
 416     auto event = ClipboardEvent::create(eventNameForClipboardEvent(kind), dataTransfer.copyRef());
 417 
 418     target-&gt;dispatchEvent(event);
 419     bool noDefaultProcessing = event-&gt;defaultPrevented();
 420     if (noDefaultProcessing &amp;&amp; (kind == ClipboardEventKind::Copy || kind == ClipboardEventKind::Cut)) {
 421         auto pasteboard = Pasteboard::createForCopyAndPaste();
 422         pasteboard-&gt;clear();
 423         dataTransfer-&gt;commitToPasteboard(*pasteboard);
 424     }
 425 
 426     dataTransfer-&gt;makeInvalidForSecurity();
 427 
 428     return !noDefaultProcessing;
 429 }
 430 
 431 // WinIE uses onbeforecut and onbeforepaste to enables the cut and paste menu items.  They
 432 // also send onbeforecopy, apparently for symmetry, but it doesn&#39;t affect the menu items.
 433 // We need to use onbeforecopy as a real menu enabler because we allow elements that are not
 434 // normally selectable to implement copy/paste (like divs, or a document body).
 435 
 436 bool Editor::canDHTMLCut()
 437 {
 438     if (m_frame.selection().selection().isInPasswordField())
 439         return false;
 440 
 441     return !dispatchClipboardEvent(findEventTargetFromSelection(), ClipboardEventKind::BeforeCut);
 442 }
 443 
 444 bool Editor::canDHTMLCopy()
 445 {
 446     if (m_frame.selection().selection().isInPasswordField())
 447         return false;
 448     return !dispatchClipboardEvent(findEventTargetFromSelection(), ClipboardEventKind::BeforeCopy);
 449 }
 450 
 451 bool Editor::canDHTMLPaste()
 452 {
 453     return !dispatchClipboardEvent(findEventTargetFromSelection(), ClipboardEventKind::BeforePaste);
 454 }
 455 
 456 bool Editor::canCut() const
 457 {
 458     return canCopy() &amp;&amp; canDelete();
 459 }
 460 
 461 static HTMLImageElement* imageElementFromImageDocument(Document&amp; document)
 462 {
 463     if (!document.isImageDocument())
 464         return nullptr;
 465 
 466     HTMLElement* body = document.bodyOrFrameset();
 467     if (!body)
 468         return nullptr;
 469 
 470     Node* node = body-&gt;firstChild();
 471     if (!is&lt;HTMLImageElement&gt;(node))
 472         return nullptr;
 473     return downcast&lt;HTMLImageElement&gt;(node);
 474 }
 475 
 476 bool Editor::canCopy() const
 477 {
 478     if (imageElementFromImageDocument(document()))
 479         return true;
 480     const VisibleSelection&amp; selection = m_frame.selection().selection();
 481     return selection.isRange() &amp;&amp; !selection.isInPasswordField();
 482 }
 483 
 484 bool Editor::canPaste() const
 485 {
 486     if (m_frame.mainFrame().loader().shouldSuppressTextInputFromEditing())
 487         return false;
 488 
 489     return canEdit();
 490 }
 491 
 492 bool Editor::canDelete() const
 493 {
 494     const VisibleSelection&amp; selection = m_frame.selection().selection();
 495     return selection.isRange() &amp;&amp; selection.rootEditableElement();
 496 }
 497 
 498 bool Editor::canDeleteRange(Range* range) const
 499 {
 500     Node&amp; startContainer = range-&gt;startContainer();
 501     Node&amp; endContainer = range-&gt;endContainer();
 502 
 503     if (!startContainer.hasEditableStyle() || !endContainer.hasEditableStyle())
 504         return false;
 505 
 506     if (range-&gt;collapsed()) {
 507         VisiblePosition start(range-&gt;startPosition(), DOWNSTREAM);
 508         VisiblePosition previous = start.previous();
 509         // FIXME: We sometimes allow deletions at the start of editable roots, like when the caret is in an empty list item.
 510         if (previous.isNull() || previous.deepEquivalent().deprecatedNode()-&gt;rootEditableElement() != startContainer.rootEditableElement())
 511             return false;
 512     }
 513     return true;
 514 }
 515 
<a name="11" id="anc11"></a><span class="line-added"> 516 bool Editor::shouldSmartDelete()</span>
<span class="line-added"> 517 {</span>
<span class="line-added"> 518     if (behavior().shouldAlwaysSmartDelete())</span>
<span class="line-added"> 519         return true;</span>
<span class="line-added"> 520     return m_frame.selection().granularity() == WordGranularity;</span>
<span class="line-added"> 521 }</span>
<span class="line-added"> 522 </span>
 523 bool Editor::smartInsertDeleteEnabled()
 524 {
 525     return client() &amp;&amp; client()-&gt;smartInsertDeleteEnabled();
 526 }
 527 
 528 bool Editor::canSmartCopyOrDelete()
 529 {
<a name="12" id="anc12"></a><span class="line-modified"> 530     return client() &amp;&amp; client()-&gt;smartInsertDeleteEnabled() &amp;&amp; shouldSmartDelete();</span>
 531 }
 532 
 533 bool Editor::isSelectTrailingWhitespaceEnabled() const
 534 {
 535     return client() &amp;&amp; client()-&gt;isSelectTrailingWhitespaceEnabled();
 536 }
 537 
 538 bool Editor::deleteWithDirection(SelectionDirection direction, TextGranularity granularity, bool shouldAddToKillRing, bool isTypingAction)
 539 {
 540     if (!canEdit())
 541         return false;
 542 
 543     if (m_frame.selection().isRange()) {
 544         if (isTypingAction) {
 545             TypingCommand::deleteKeyPressed(document(), canSmartCopyOrDelete() ? TypingCommand::SmartDelete : 0, granularity);
 546             revealSelectionAfterEditingOperation();
 547         } else {
 548             if (shouldAddToKillRing)
 549                 addRangeToKillRing(*selectedRange().get(), KillRingInsertionMode::AppendText);
 550             deleteSelectionWithSmartDelete(canSmartCopyOrDelete());
 551             // Implicitly calls revealSelectionAfterEditingOperation().
 552         }
 553     } else {
 554         TypingCommand::Options options = 0;
 555         if (canSmartCopyOrDelete())
 556             options |= TypingCommand::SmartDelete;
 557         if (shouldAddToKillRing)
 558             options |= TypingCommand::AddsToKillRing;
 559         switch (direction) {
 560         case DirectionForward:
 561         case DirectionRight:
 562             TypingCommand::forwardDeleteKeyPressed(document(), options, granularity);
 563             break;
 564         case DirectionBackward:
 565         case DirectionLeft:
 566             TypingCommand::deleteKeyPressed(document(), options, granularity);
 567             break;
 568         }
 569         revealSelectionAfterEditingOperation();
 570     }
 571 
 572     // FIXME: We should to move this down into deleteKeyPressed.
 573     // clear the &quot;start new kill ring sequence&quot; setting, because it was set to true
 574     // when the selection was updated by deleting the range
 575     if (shouldAddToKillRing)
 576         setStartNewKillRingSequence(false);
 577 
 578     return true;
 579 }
 580 
 581 void Editor::deleteSelectionWithSmartDelete(bool smartDelete, EditAction editingAction)
 582 {
 583     if (m_frame.selection().isNone())
 584         return;
 585 
 586     DeleteSelectionCommand::create(document(), smartDelete, true, false, false, true, editingAction)-&gt;apply();
 587 }
 588 
 589 void Editor::clearText()
 590 {
 591     ClearTextCommand::CreateAndApply(&amp;m_frame);
 592 }
 593 
 594 void Editor::pasteAsPlainText(const String&amp; pastingText, bool smartReplace)
 595 {
 596     Element* target = findEventTargetFromSelection();
 597     if (!target)
 598         return;
 599     target-&gt;dispatchEvent(TextEvent::createForPlainTextPaste(document().windowProxy(), pastingText, smartReplace));
 600 }
 601 
 602 void Editor::pasteAsFragment(Ref&lt;DocumentFragment&gt;&amp;&amp; pastingFragment, bool smartReplace, bool matchStyle, MailBlockquoteHandling respectsMailBlockquote)
 603 {
 604     Element* target = findEventTargetFromSelection();
 605     if (!target)
 606         return;
 607     target-&gt;dispatchEvent(TextEvent::createForFragmentPaste(document().windowProxy(), WTFMove(pastingFragment), smartReplace, matchStyle, respectsMailBlockquote));
 608 }
 609 
 610 void Editor::pasteAsPlainTextBypassingDHTML()
 611 {
 612     pasteAsPlainTextWithPasteboard(*Pasteboard::createForCopyAndPaste());
 613 }
 614 
 615 void Editor::pasteAsPlainTextWithPasteboard(Pasteboard&amp; pasteboard)
 616 {
 617     String text = readPlainTextFromPasteboard(pasteboard);
 618     if (client() &amp;&amp; client()-&gt;shouldInsertText(text, selectedRange().get(), EditorInsertAction::Pasted))
 619         pasteAsPlainText(text, canSmartReplaceWithPasteboard(pasteboard));
 620 }
 621 
 622 String Editor::readPlainTextFromPasteboard(Pasteboard&amp; pasteboard)
 623 {
 624     PasteboardPlainText text;
 625     pasteboard.read(text);
 626     return plainTextFromPasteboard(text);
 627 }
 628 
 629 #if !PLATFORM(MAC)
 630 
 631 String Editor::plainTextFromPasteboard(const PasteboardPlainText&amp; text)
 632 {
 633     return text.text;
 634 }
 635 
 636 #endif
 637 
 638 bool Editor::canSmartReplaceWithPasteboard(Pasteboard&amp; pasteboard)
 639 {
 640     return client() &amp;&amp; client()-&gt;smartInsertDeleteEnabled() &amp;&amp; pasteboard.canSmartReplace();
 641 }
 642 
 643 bool Editor::shouldInsertFragment(DocumentFragment&amp; fragment, Range* replacingDOMRange, EditorInsertAction givenAction)
 644 {
 645     if (!client())
 646         return false;
 647 
 648     auto* child = fragment.firstChild();
 649     if (is&lt;CharacterData&gt;(child) &amp;&amp; fragment.lastChild() == child)
 650         return client()-&gt;shouldInsertText(downcast&lt;CharacterData&gt;(*child).data(), replacingDOMRange, givenAction);
 651 
 652     return client()-&gt;shouldInsertNode(&amp;fragment, replacingDOMRange, givenAction);
 653 }
 654 
 655 void Editor::replaceSelectionWithFragment(DocumentFragment&amp; fragment, SelectReplacement selectReplacement, SmartReplace smartReplace, MatchStyle matchStyle, EditAction editingAction, MailBlockquoteHandling mailBlockquoteHandling)
 656 {
 657     VisibleSelection selection = m_frame.selection().selection();
 658     if (selection.isNone() || !selection.isContentEditable())
 659         return;
 660 
 661     AccessibilityReplacedText replacedText;
 662     if (AXObjectCache::accessibilityEnabled() &amp;&amp; editingAction == EditAction::Paste)
 663         replacedText = AccessibilityReplacedText(selection);
 664 
 665     OptionSet&lt;ReplaceSelectionCommand::CommandOption&gt; options { ReplaceSelectionCommand::PreventNesting, ReplaceSelectionCommand::SanitizeFragment };
 666     if (selectReplacement == SelectReplacement::Yes)
 667         options.add(ReplaceSelectionCommand::SelectReplacement);
 668     if (smartReplace == SmartReplace::Yes)
 669         options.add(ReplaceSelectionCommand::SmartReplace);
 670     if (matchStyle == MatchStyle::Yes)
 671         options.add(ReplaceSelectionCommand::MatchStyle);
 672     if (mailBlockquoteHandling == MailBlockquoteHandling::IgnoreBlockquote)
 673         options.add(ReplaceSelectionCommand::IgnoreMailBlockquote);
 674 
 675     auto command = ReplaceSelectionCommand::create(document(), &amp;fragment, options, editingAction);
 676     command-&gt;apply();
 677     revealSelectionAfterEditingOperation();
 678 
 679     selection = m_frame.selection().selection();
 680     if (selection.isInPasswordField())
 681         return;
 682 
 683     if (AXObjectCache::accessibilityEnabled() &amp;&amp; editingAction == EditAction::Paste) {
 684         String text = AccessibilityObject::stringForVisiblePositionRange(command-&gt;visibleSelectionForInsertedText());
 685         replacedText.postTextStateChangeNotification(document().existingAXObjectCache(), AXTextEditTypePaste, text, m_frame.selection().selection());
 686         command-&gt;composition()-&gt;setRangeDeletedByUnapply(replacedText.replacedRange());
 687     }
 688 
 689     if (!isContinuousSpellCheckingEnabled())
 690         return;
 691 
 692     Node* nodeToCheck = selection.rootEditableElement();
 693     if (!nodeToCheck)
 694         return;
 695 
 696     auto rangeToCheck = Range::create(document(), firstPositionInNode(nodeToCheck), lastPositionInNode(nodeToCheck));
 697     if (auto request = SpellCheckRequest::create(resolveTextCheckingTypeMask(*nodeToCheck, { TextCheckingType::Spelling, TextCheckingType::Grammar }), TextCheckingProcessBatch, rangeToCheck.copyRef(), rangeToCheck.copyRef(), rangeToCheck.copyRef()))
 698         m_spellChecker-&gt;requestCheckingFor(request.releaseNonNull());
 699 }
 700 
 701 void Editor::replaceSelectionWithText(const String&amp; text, SelectReplacement selectReplacement, SmartReplace smartReplace, EditAction editingAction)
 702 {
 703     RefPtr&lt;Range&gt; range = selectedRange();
 704     if (!range)
 705         return;
 706 
 707     replaceSelectionWithFragment(createFragmentFromText(*range, text), selectReplacement, smartReplace, MatchStyle::Yes, editingAction);
 708 }
 709 
 710 RefPtr&lt;Range&gt; Editor::selectedRange()
 711 {
 712     return m_frame.selection().toNormalizedRange();
 713 }
 714 
 715 bool Editor::shouldDeleteRange(Range* range) const
 716 {
 717     if (!range || range-&gt;collapsed())
 718         return false;
 719 
 720     if (!canDeleteRange(range))
 721         return false;
 722 
 723     return client() &amp;&amp; client()-&gt;shouldDeleteRange(range);
 724 }
 725 
 726 bool Editor::tryDHTMLCopy()
 727 {
 728     if (m_frame.selection().selection().isInPasswordField())
 729         return false;
 730 
 731     return !dispatchClipboardEvent(findEventTargetFromSelection(), ClipboardEventKind::Copy);
 732 }
 733 
 734 bool Editor::tryDHTMLCut()
 735 {
 736     if (m_frame.selection().selection().isInPasswordField())
 737         return false;
 738 
 739     return !dispatchClipboardEvent(findEventTargetFromSelection(), ClipboardEventKind::Cut);
 740 }
 741 
 742 bool Editor::shouldInsertText(const String&amp; text, Range* range, EditorInsertAction action) const
 743 {
 744     if (m_frame.mainFrame().loader().shouldSuppressTextInputFromEditing() &amp;&amp; action == EditorInsertAction::Typed)
 745         return false;
 746 
 747     return client() &amp;&amp; client()-&gt;shouldInsertText(text, range, action);
 748 }
 749 
 750 void Editor::respondToChangedContents(const VisibleSelection&amp; endingSelection)
 751 {
 752     if (AXObjectCache::accessibilityEnabled()) {
 753         Node* node = endingSelection.start().deprecatedNode();
 754         if (AXObjectCache* cache = document().existingAXObjectCache())
 755             cache-&gt;postNotification(node, AXObjectCache::AXValueChanged, TargetObservableParent);
 756     }
 757 
 758     updateMarkersForWordsAffectedByEditing(true);
 759 
 760     if (client())
 761         client()-&gt;respondToChangedContents();
 762 }
 763 
 764 bool Editor::hasBidiSelection() const
 765 {
 766     if (m_frame.selection().isNone())
 767         return false;
 768 
 769     Node* startNode;
 770     if (m_frame.selection().isRange()) {
 771         startNode = m_frame.selection().selection().start().downstream().deprecatedNode();
 772         Node* endNode = m_frame.selection().selection().end().upstream().deprecatedNode();
 773         if (enclosingBlock(startNode) != enclosingBlock(endNode))
 774             return false;
 775     } else
 776         startNode = m_frame.selection().selection().visibleStart().deepEquivalent().deprecatedNode();
 777 
 778     if (!startNode)
 779         return false;
 780 
 781     auto renderer = startNode-&gt;renderer();
 782     while (renderer &amp;&amp; !is&lt;RenderBlockFlow&gt;(*renderer))
 783         renderer = renderer-&gt;parent();
 784 
 785     if (!renderer)
 786         return false;
 787 
 788     if (!renderer-&gt;style().isLeftToRightDirection())
 789         return true;
 790 
 791     return downcast&lt;RenderBlockFlow&gt;(*renderer).containsNonZeroBidiLevel();
 792 }
 793 
 794 TriState Editor::selectionUnorderedListState() const
 795 {
 796     if (m_frame.selection().isCaret()) {
 797         if (enclosingElementWithTag(m_frame.selection().selection().start(), ulTag))
 798             return TrueTriState;
 799     } else if (m_frame.selection().isRange()) {
 800         auto* startNode = enclosingElementWithTag(m_frame.selection().selection().start(), ulTag);
 801         auto* endNode = enclosingElementWithTag(m_frame.selection().selection().end(), ulTag);
 802         if (startNode &amp;&amp; endNode &amp;&amp; startNode == endNode)
 803             return TrueTriState;
 804     }
 805 
 806     return FalseTriState;
 807 }
 808 
 809 TriState Editor::selectionOrderedListState() const
 810 {
 811     if (m_frame.selection().isCaret()) {
 812         if (enclosingElementWithTag(m_frame.selection().selection().start(), olTag))
 813             return TrueTriState;
 814     } else if (m_frame.selection().isRange()) {
 815         auto* startNode = enclosingElementWithTag(m_frame.selection().selection().start(), olTag);
 816         auto* endNode = enclosingElementWithTag(m_frame.selection().selection().end(), olTag);
 817         if (startNode &amp;&amp; endNode &amp;&amp; startNode == endNode)
 818             return TrueTriState;
 819     }
 820 
 821     return FalseTriState;
 822 }
 823 
 824 RefPtr&lt;Node&gt; Editor::insertOrderedList()
 825 {
 826     if (!canEditRichly())
 827         return nullptr;
 828 
 829     auto newList = InsertListCommand::insertList(document(), InsertListCommand::Type::OrderedList);
 830     revealSelectionAfterEditingOperation();
 831     return newList;
 832 }
 833 
 834 RefPtr&lt;Node&gt; Editor::insertUnorderedList()
 835 {
 836     if (!canEditRichly())
 837         return nullptr;
 838 
 839     auto newList = InsertListCommand::insertList(document(), InsertListCommand::Type::UnorderedList);
 840     revealSelectionAfterEditingOperation();
 841     return newList;
 842 }
 843 
 844 bool Editor::canIncreaseSelectionListLevel()
 845 {
 846     return canEditRichly() &amp;&amp; IncreaseSelectionListLevelCommand::canIncreaseSelectionListLevel(&amp;document());
 847 }
 848 
 849 bool Editor::canDecreaseSelectionListLevel()
 850 {
 851     return canEditRichly() &amp;&amp; DecreaseSelectionListLevelCommand::canDecreaseSelectionListLevel(&amp;document());
 852 }
 853 
 854 RefPtr&lt;Node&gt; Editor::increaseSelectionListLevel()
 855 {
 856     if (!canEditRichly() || m_frame.selection().isNone())
 857         return nullptr;
 858 
 859     RefPtr&lt;Node&gt; newList = IncreaseSelectionListLevelCommand::increaseSelectionListLevel(&amp;document());
 860     revealSelectionAfterEditingOperation();
 861     return newList;
 862 }
 863 
 864 RefPtr&lt;Node&gt; Editor::increaseSelectionListLevelOrdered()
 865 {
 866     if (!canEditRichly() || m_frame.selection().isNone())
 867         return nullptr;
 868 
 869     RefPtr&lt;Node&gt; newList = IncreaseSelectionListLevelCommand::increaseSelectionListLevelOrdered(&amp;document());
 870     revealSelectionAfterEditingOperation();
 871     return newList;
 872 }
 873 
 874 RefPtr&lt;Node&gt; Editor::increaseSelectionListLevelUnordered()
 875 {
 876     if (!canEditRichly() || m_frame.selection().isNone())
 877         return nullptr;
 878 
 879     RefPtr&lt;Node&gt; newList = IncreaseSelectionListLevelCommand::increaseSelectionListLevelUnordered(&amp;document());
 880     revealSelectionAfterEditingOperation();
 881     return newList;
 882 }
 883 
 884 void Editor::decreaseSelectionListLevel()
 885 {
 886     if (!canEditRichly() || m_frame.selection().isNone())
 887         return;
 888 
 889     DecreaseSelectionListLevelCommand::decreaseSelectionListLevel(&amp;document());
 890     revealSelectionAfterEditingOperation();
 891 }
 892 
 893 void Editor::removeFormattingAndStyle()
 894 {
 895     RemoveFormatCommand::create(document())-&gt;apply();
 896 }
 897 
 898 void Editor::clearLastEditCommand()
 899 {
 900     m_lastEditCommand = nullptr;
 901 }
 902 
 903 Element* Editor::findEventTargetFrom(const VisibleSelection&amp; selection) const
 904 {
 905     Element* target = selection.start().element();
 906     if (!target)
 907         target = document().bodyOrFrameset();
 908     if (!target)
 909         return nullptr;
 910 
 911     return target;
 912 }
 913 
 914 Element* Editor::findEventTargetFromSelection() const
 915 {
 916     return findEventTargetFrom(m_frame.selection().selection());
 917 }
 918 
 919 void Editor::applyStyle(StyleProperties* style, EditAction editingAction)
 920 {
 921     if (style)
 922         applyStyle(EditingStyle::create(style), editingAction, ColorFilterMode::UseOriginalColor);
 923 }
 924 
 925 void Editor::applyStyle(RefPtr&lt;EditingStyle&gt;&amp;&amp; style, EditAction editingAction, ColorFilterMode colorFilterMode)
 926 {
 927     if (!style)
 928         return;
 929 
 930     auto selectionType = m_frame.selection().selection().selectionType();
 931     if (selectionType == VisibleSelection::NoSelection)
 932         return;
 933 
 934     String inputTypeName = inputTypeNameForEditingAction(editingAction);
 935     String inputEventData = inputEventDataForEditingStyleAndAction(*style, editingAction);
 936     RefPtr&lt;Element&gt; element = m_frame.selection().selection().rootEditableElement();
 937     if (element &amp;&amp; !dispatchBeforeInputEvent(*element, inputTypeName, inputEventData))
 938         return;
 939 
 940     Ref&lt;EditingStyle&gt; styleToApply = colorFilterMode == ColorFilterMode::InvertColor ? style-&gt;inverseTransformColorIfNeeded(*element) : style.releaseNonNull();
 941 
 942     switch (selectionType) {
 943     case VisibleSelection::CaretSelection:
 944         computeAndSetTypingStyle(styleToApply.get(), editingAction);
 945         break;
 946     case VisibleSelection::RangeSelection:
 947         ApplyStyleCommand::create(document(), styleToApply.ptr(), editingAction)-&gt;apply();
 948         break;
 949     default:
 950         break;
 951     }
 952 
 953     client()-&gt;didApplyStyle();
 954     if (element)
 955         dispatchInputEvent(*element, inputTypeName, inputEventData);
 956 }
 957 
 958 bool Editor::shouldApplyStyle(StyleProperties* style, Range* range)
 959 {
 960     return client()-&gt;shouldApplyStyle(style, range);
 961 }
 962 
 963 void Editor::applyParagraphStyle(StyleProperties* style, EditAction editingAction)
 964 {
 965     if (!style)
 966         return;
 967 
 968     auto selectionType = m_frame.selection().selection().selectionType();
 969     if (selectionType == VisibleSelection::NoSelection)
 970         return;
 971 
 972     String inputTypeName = inputTypeNameForEditingAction(editingAction);
 973     String inputEventData = inputEventDataForEditingStyleAndAction(style, editingAction);
 974     RefPtr&lt;Element&gt; element = m_frame.selection().selection().rootEditableElement();
 975     if (element &amp;&amp; !dispatchBeforeInputEvent(*element, inputTypeName, inputEventData))
 976         return;
 977 
 978     ApplyStyleCommand::create(document(), EditingStyle::create(style).ptr(), editingAction, ApplyStyleCommand::ForceBlockProperties)-&gt;apply();
 979     client()-&gt;didApplyStyle();
 980     if (element)
 981         dispatchInputEvent(*element, inputTypeName, inputEventData);
 982 }
 983 
 984 void Editor::applyStyleToSelection(StyleProperties* style, EditAction editingAction)
 985 {
 986     if (!style || style-&gt;isEmpty() || !canEditRichly())
 987         return;
 988 
 989     if (!client() || !client()-&gt;shouldApplyStyle(style, m_frame.selection().toNormalizedRange().get()))
 990         return;
 991     applyStyle(style, editingAction);
 992 }
 993 
 994 void Editor::applyStyleToSelection(Ref&lt;EditingStyle&gt;&amp;&amp; style, EditAction editingAction, ColorFilterMode colorFilterMode)
 995 {
 996     if (style-&gt;isEmpty() || !canEditRichly())
 997         return;
 998 
 999     // FIXME: This is wrong for text decorations since m_mutableStyle is empty.
1000     if (!client() || !client()-&gt;shouldApplyStyle(style-&gt;styleWithResolvedTextDecorations().ptr(), m_frame.selection().toNormalizedRange().get()))
1001         return;
1002 
1003     applyStyle(WTFMove(style), editingAction, colorFilterMode);
1004 }
1005 
1006 void Editor::applyParagraphStyleToSelection(StyleProperties* style, EditAction editingAction)
1007 {
1008     if (!style || style-&gt;isEmpty() || !canEditRichly())
1009         return;
1010 
1011     if (client() &amp;&amp; client()-&gt;shouldApplyStyle(style, m_frame.selection().toNormalizedRange().get()))
1012         applyParagraphStyle(style, editingAction);
1013 }
1014 
1015 bool Editor::selectionStartHasStyle(CSSPropertyID propertyID, const String&amp; value) const
1016 {
1017     if (auto editingStyle = EditingStyle::styleAtSelectionStart(m_frame.selection().selection(), propertyID == CSSPropertyBackgroundColor))
1018         return editingStyle-&gt;hasStyle(propertyID, value);
1019     return false;
1020 }
1021 
1022 TriState Editor::selectionHasStyle(CSSPropertyID propertyID, const String&amp; value) const
1023 {
1024     return EditingStyle::create(propertyID, value)-&gt;triStateOfStyle(m_frame.selection().selection());
1025 }
1026 
1027 String Editor::selectionStartCSSPropertyValue(CSSPropertyID propertyID)
1028 {
1029     RefPtr&lt;EditingStyle&gt; selectionStyle = EditingStyle::styleAtSelectionStart(m_frame.selection().selection(),
1030         propertyID == CSSPropertyBackgroundColor);
1031     if (!selectionStyle || !selectionStyle-&gt;style())
1032         return String();
1033 
1034     if (propertyID == CSSPropertyFontSize)
1035         return String::number(selectionStyle-&gt;legacyFontSize(document()));
1036     return selectionStyle-&gt;style()-&gt;getPropertyValue(propertyID);
1037 }
1038 
1039 void Editor::indent()
1040 {
1041     IndentOutdentCommand::create(document(), IndentOutdentCommand::Indent)-&gt;apply();
1042 }
1043 
1044 void Editor::outdent()
1045 {
1046     IndentOutdentCommand::create(document(), IndentOutdentCommand::Outdent)-&gt;apply();
1047 }
1048 
1049 static void notifyTextFromControls(Element* startRoot, Element* endRoot)
1050 {
1051     HTMLTextFormControlElement* startingTextControl = enclosingTextFormControl(firstPositionInOrBeforeNode(startRoot));
1052     HTMLTextFormControlElement* endingTextControl = enclosingTextFormControl(firstPositionInOrBeforeNode(endRoot));
1053     if (startingTextControl)
1054         startingTextControl-&gt;didEditInnerTextValue();
1055     if (endingTextControl &amp;&amp; startingTextControl != endingTextControl)
1056         endingTextControl-&gt;didEditInnerTextValue();
1057 }
1058 
<a name="13" id="anc13"></a><span class="line-modified">1059 static bool dispatchBeforeInputEvents(RefPtr&lt;Element&gt; startRoot, RefPtr&lt;Element&gt; endRoot, const AtomString&amp; inputTypeName, const String&amp; data = { }, RefPtr&lt;DataTransfer&gt;&amp;&amp; dataTransfer = nullptr, const Vector&lt;RefPtr&lt;StaticRange&gt;&gt;&amp; targetRanges = { }, Event::IsCancelable cancelable = Event::IsCancelable::Yes)</span>
1060 {
1061     bool continueWithDefaultBehavior = true;
1062     if (startRoot)
1063         continueWithDefaultBehavior &amp;= dispatchBeforeInputEvent(*startRoot, inputTypeName, data, WTFMove(dataTransfer), targetRanges, cancelable);
1064     if (endRoot &amp;&amp; endRoot != startRoot)
1065         continueWithDefaultBehavior &amp;= dispatchBeforeInputEvent(*endRoot, inputTypeName, data, WTFMove(dataTransfer), targetRanges, cancelable);
1066     return continueWithDefaultBehavior;
1067 }
1068 
<a name="14" id="anc14"></a><span class="line-modified">1069 static void dispatchInputEvents(RefPtr&lt;Element&gt; startRoot, RefPtr&lt;Element&gt; endRoot, const AtomString&amp; inputTypeName, const String&amp; data = { }, RefPtr&lt;DataTransfer&gt;&amp;&amp; dataTransfer = nullptr, const Vector&lt;RefPtr&lt;StaticRange&gt;&gt;&amp; targetRanges = { })</span>
1070 {
1071     if (startRoot)
1072         dispatchInputEvent(*startRoot, inputTypeName, data, WTFMove(dataTransfer), targetRanges);
1073     if (endRoot &amp;&amp; endRoot != startRoot)
1074         dispatchInputEvent(*endRoot, inputTypeName, data, WTFMove(dataTransfer), targetRanges);
1075 }
1076 
1077 bool Editor::willApplyEditing(CompositeEditCommand&amp; command, Vector&lt;RefPtr&lt;StaticRange&gt;&gt;&amp;&amp; targetRanges) const
1078 {
1079     if (!command.shouldDispatchInputEvents())
1080         return true;
1081 
1082     auto* composition = command.composition();
1083     if (!composition)
1084         return true;
1085 
1086     return dispatchBeforeInputEvents(composition-&gt;startingRootEditableElement(), composition-&gt;endingRootEditableElement(), command.inputEventTypeName(),
1087         command.inputEventData(), command.inputEventDataTransfer(), targetRanges, command.isBeforeInputEventCancelable() ? Event::IsCancelable::Yes : Event::IsCancelable::No);
1088 }
1089 
1090 void Editor::appliedEditing(CompositeEditCommand&amp; command)
1091 {
1092     LOG(Editing, &quot;Editor %p appliedEditing&quot;, this);
1093 
1094     document().updateLayout();
1095 
1096     ASSERT(command.composition());
1097     auto&amp; composition = *command.composition();
1098     VisibleSelection newSelection(command.endingSelection());
1099 
1100     notifyTextFromControls(composition.startingRootEditableElement(), composition.endingRootEditableElement());
1101 
1102     if (command.isTopLevelCommand()) {
1103         // Don&#39;t clear the typing style with this selection change. We do those things elsewhere if necessary.
1104         OptionSet&lt;FrameSelection::SetSelectionOption&gt; options;
1105         if (command.isDictationCommand())
1106             options.add(FrameSelection::DictationTriggered);
1107 
1108         changeSelectionAfterCommand(newSelection, options);
1109     }
1110 
1111     if (command.shouldDispatchInputEvents())
1112         dispatchInputEvents(composition.startingRootEditableElement(), composition.endingRootEditableElement(), command.inputEventTypeName(), command.inputEventData(), command.inputEventDataTransfer());
1113 
1114     if (command.isTopLevelCommand()) {
1115         updateEditorUINowIfScheduled();
1116 
1117         m_alternativeTextController-&gt;respondToAppliedEditing(&amp;command);
1118 
1119         if (!command.preservesTypingStyle())
1120             m_frame.selection().clearTypingStyle();
1121 
1122         // Command will be equal to last edit command only in the case of typing
1123         if (m_lastEditCommand.get() == &amp;command)
1124             ASSERT(command.isTypingCommand());
1125         else {
1126             // Only register a new undo command if the command passed in is
1127             // different from the last command
1128             m_lastEditCommand = &amp;command;
1129             if (client())
1130                 client()-&gt;registerUndoStep(m_lastEditCommand-&gt;ensureComposition());
1131         }
1132         respondToChangedContents(newSelection);
1133     }
1134 }
1135 
1136 bool Editor::willUnapplyEditing(const EditCommandComposition&amp; composition) const
1137 {
1138     return dispatchBeforeInputEvents(composition.startingRootEditableElement(), composition.endingRootEditableElement(), &quot;historyUndo&quot;);
1139 }
1140 
1141 void Editor::unappliedEditing(EditCommandComposition&amp; composition)
1142 {
1143     document().updateLayout();
1144 
1145     notifyTextFromControls(composition.startingRootEditableElement(), composition.endingRootEditableElement());
1146 
1147     VisibleSelection newSelection(composition.startingSelection());
1148     changeSelectionAfterCommand(newSelection, FrameSelection::defaultSetSelectionOptions());
1149     dispatchInputEvents(composition.startingRootEditableElement(), composition.endingRootEditableElement(), &quot;historyUndo&quot;);
1150 
1151     updateEditorUINowIfScheduled();
1152 
1153     m_alternativeTextController-&gt;respondToUnappliedEditing(&amp;composition);
1154 
1155     m_lastEditCommand = nullptr;
1156     if (auto* client = this-&gt;client())
1157         client-&gt;registerRedoStep(composition);
1158     respondToChangedContents(newSelection);
1159 }
1160 
1161 bool Editor::willReapplyEditing(const EditCommandComposition&amp; composition) const
1162 {
1163     return dispatchBeforeInputEvents(composition.startingRootEditableElement(), composition.endingRootEditableElement(), &quot;historyRedo&quot;);
1164 }
1165 
1166 void Editor::reappliedEditing(EditCommandComposition&amp; composition)
1167 {
1168     document().updateLayout();
1169 
1170     notifyTextFromControls(composition.startingRootEditableElement(), composition.endingRootEditableElement());
1171 
1172     VisibleSelection newSelection(composition.endingSelection());
1173     changeSelectionAfterCommand(newSelection, FrameSelection::defaultSetSelectionOptions());
1174     dispatchInputEvents(composition.startingRootEditableElement(), composition.endingRootEditableElement(), &quot;historyRedo&quot;);
1175 
1176     updateEditorUINowIfScheduled();
1177 
1178     m_lastEditCommand = nullptr;
1179     if (auto* client = this-&gt;client())
1180         client-&gt;registerUndoStep(composition);
1181     respondToChangedContents(newSelection);
1182 }
1183 
1184 Editor::Editor(Frame&amp; frame)
1185     : m_frame(frame)
<a name="15" id="anc15"></a><span class="line-modified">1186     , m_killRing(makeUnique&lt;PAL::KillRing&gt;())</span>
<span class="line-modified">1187     , m_spellChecker(makeUnique&lt;SpellChecker&gt;(frame))</span>
<span class="line-modified">1188     , m_alternativeTextController(makeUnique&lt;AlternativeTextController&gt;(frame))</span>
1189     , m_editorUIUpdateTimer(*this, &amp;Editor::editorUIUpdateTimerFired)
1190 #if ENABLE(TELEPHONE_NUMBER_DETECTION) &amp;&amp; !PLATFORM(IOS_FAMILY)
1191     , m_telephoneNumberDetectionUpdateTimer(*this, &amp;Editor::scanSelectionForTelephoneNumbers)
1192 #endif
1193 {
1194 }
1195 
1196 Editor::~Editor() = default;
1197 
1198 void Editor::clear()
1199 {
1200     m_lastEditCommand = nullptr;
1201     if (m_compositionNode) {
1202         m_compositionNode = nullptr;
1203         if (EditorClient* client = this-&gt;client())
1204             client-&gt;discardedComposition(&amp;m_frame);
1205     }
1206     m_customCompositionUnderlines.clear();
1207     m_shouldStyleWithCSS = false;
1208     m_defaultParagraphSeparator = EditorParagraphSeparatorIsDiv;
1209     m_mark = { };
1210     m_oldSelectionForEditorUIUpdate = { };
1211     m_editorUIUpdateTimer.stop();
1212 
1213 #if ENABLE(TELEPHONE_NUMBER_DETECTION) &amp;&amp; !PLATFORM(IOS_FAMILY)
1214     m_telephoneNumberDetectionUpdateTimer.stop();
1215     m_detectedTelephoneNumberRanges.clear();
1216 #endif
1217 }
1218 
1219 bool Editor::insertText(const String&amp; text, Event* triggeringEvent, TextEventInputType inputType)
1220 {
1221     return m_frame.eventHandler().handleTextInputEvent(text, triggeringEvent, inputType);
1222 }
1223 
1224 bool Editor::insertTextForConfirmedComposition(const String&amp; text)
1225 {
1226     return m_frame.eventHandler().handleTextInputEvent(text, 0, TextEventInputComposition);
1227 }
1228 
1229 bool Editor::insertDictatedText(const String&amp; text, const Vector&lt;DictationAlternative&gt;&amp; dictationAlternatives, Event* triggeringEvent)
1230 {
1231     return m_alternativeTextController-&gt;insertDictatedText(text, dictationAlternatives, triggeringEvent);
1232 }
1233 
1234 bool Editor::insertTextWithoutSendingTextEvent(const String&amp; text, bool selectInsertedText, TextEvent* triggeringEvent)
1235 {
1236     if (text.isEmpty())
1237         return false;
1238 
1239     VisibleSelection selection = selectionForCommand(triggeringEvent);
1240     if (!selection.isContentEditable())
1241         return false;
1242     RefPtr&lt;Range&gt; range = selection.toNormalizedRange();
1243 
1244     if (!shouldInsertText(text, range.get(), EditorInsertAction::Typed))
1245         return true;
1246 
1247     updateMarkersForWordsAffectedByEditing(isSpaceOrNewline(text[0]));
1248 
1249     bool shouldConsiderApplyingAutocorrection = false;
1250     if (text == &quot; &quot; || text == &quot;\t&quot;)
1251         shouldConsiderApplyingAutocorrection = true;
1252 
1253     if (text.length() == 1 &amp;&amp; u_ispunct(text[0]) &amp;&amp; !isAmbiguousBoundaryCharacter(text[0]))
1254         shouldConsiderApplyingAutocorrection = true;
1255 
1256     bool autocorrectionWasApplied = shouldConsiderApplyingAutocorrection &amp;&amp; m_alternativeTextController-&gt;applyAutocorrectionBeforeTypingIfAppropriate();
1257 
1258     // Get the selection to use for the event that triggered this insertText.
1259     // If the event handler changed the selection, we may want to use a different selection
1260     // that is contained in the event target.
1261     selection = selectionForCommand(triggeringEvent);
1262     if (selection.isContentEditable()) {
1263         if (Node* selectionStart = selection.start().deprecatedNode()) {
1264             Ref&lt;Document&gt; document(selectionStart-&gt;document());
1265 
1266             // Insert the text
1267             if (triggeringEvent &amp;&amp; triggeringEvent-&gt;isDictation())
1268                 DictationCommand::insertText(document, text, triggeringEvent-&gt;dictationAlternatives(), selection);
1269             else {
1270                 TypingCommand::Options options = 0;
1271                 if (selectInsertedText)
1272                     options |= TypingCommand::SelectInsertedText;
1273                 if (autocorrectionWasApplied)
1274                     options |= TypingCommand::RetainAutocorrectionIndicator;
1275                 if (triggeringEvent &amp;&amp; triggeringEvent-&gt;isAutocompletion())
1276                     options |= TypingCommand::IsAutocompletion;
1277                 TypingCommand::insertText(document, text, selection, options, triggeringEvent &amp;&amp; triggeringEvent-&gt;isComposition() ? TypingCommand::TextCompositionFinal : TypingCommand::TextCompositionNone);
1278             }
1279 
1280             // Reveal the current selection
1281             if (Frame* editedFrame = document-&gt;frame())
1282                 if (Page* page = editedFrame-&gt;page()) {
<a name="16" id="anc16"></a>


1283                     SelectionRevealMode revealMode = SelectionRevealMode::Reveal;
<a name="17" id="anc17"></a>
1284                     page-&gt;focusController().focusedOrMainFrame().selection().revealSelection(revealMode, ScrollAlignment::alignCenterIfNeeded);
1285                 }
1286         }
1287     }
1288 
1289     return true;
1290 }
1291 
1292 bool Editor::insertLineBreak()
1293 {
1294     if (!canEdit())
1295         return false;
1296 
1297     if (!shouldInsertText(&quot;\n&quot;, m_frame.selection().toNormalizedRange().get(), EditorInsertAction::Typed))
1298         return true;
1299 
1300     VisiblePosition caret = m_frame.selection().selection().visibleStart();
1301     bool alignToEdge = isEndOfEditableOrNonEditableContent(caret);
1302     bool autocorrectionIsApplied = m_alternativeTextController-&gt;applyAutocorrectionBeforeTypingIfAppropriate();
1303     TypingCommand::insertLineBreak(document(), autocorrectionIsApplied ? TypingCommand::RetainAutocorrectionIndicator : 0);
1304     revealSelectionAfterEditingOperation(alignToEdge ? ScrollAlignment::alignToEdgeIfNeeded : ScrollAlignment::alignCenterIfNeeded);
1305 
1306     return true;
1307 }
1308 
1309 bool Editor::insertParagraphSeparator()
1310 {
1311     if (!canEdit())
1312         return false;
1313 
1314     if (!canEditRichly())
1315         return insertLineBreak();
1316 
1317     if (!shouldInsertText(&quot;\n&quot;, m_frame.selection().toNormalizedRange().get(), EditorInsertAction::Typed))
1318         return true;
1319 
1320     VisiblePosition caret = m_frame.selection().selection().visibleStart();
1321     bool alignToEdge = isEndOfEditableOrNonEditableContent(caret);
1322     bool autocorrectionIsApplied = m_alternativeTextController-&gt;applyAutocorrectionBeforeTypingIfAppropriate();
1323     TypingCommand::insertParagraphSeparator(document(), autocorrectionIsApplied ? TypingCommand::RetainAutocorrectionIndicator : 0);
1324     revealSelectionAfterEditingOperation(alignToEdge ? ScrollAlignment::alignToEdgeIfNeeded : ScrollAlignment::alignCenterIfNeeded);
1325 
1326     return true;
1327 }
1328 
1329 bool Editor::insertParagraphSeparatorInQuotedContent()
1330 {
1331     // FIXME: Why is this missing calls to canEdit, canEditRichly, etc.?
1332     TypingCommand::insertParagraphSeparatorInQuotedContent(document());
1333     revealSelectionAfterEditingOperation();
1334     return true;
1335 }
1336 
1337 void Editor::cut()
1338 {
1339     if (tryDHTMLCut())
1340         return; // DHTML did the whole operation
1341     if (!canCut()) {
1342         PAL::systemBeep();
1343         return;
1344     }
1345 
1346     performCutOrCopy(CutAction);
1347 }
1348 
1349 void Editor::copy()
1350 {
1351     if (tryDHTMLCopy())
1352         return; // DHTML did the whole operation
1353     if (!canCopy()) {
1354         PAL::systemBeep();
1355         return;
1356     }
1357 
1358     performCutOrCopy(CopyAction);
1359 }
1360 
1361 void Editor::postTextStateChangeNotificationForCut(const String&amp; text, const VisibleSelection&amp; selection)
1362 {
1363     if (!AXObjectCache::accessibilityEnabled())
1364         return;
1365     if (!text.length())
1366         return;
1367     AXObjectCache* cache = document().existingAXObjectCache();
1368     if (!cache)
1369         return;
1370     cache-&gt;postTextStateChangeNotification(selection.start().anchorNode(), AXTextEditTypeCut, text, selection.start());
1371 }
1372 
1373 void Editor::performCutOrCopy(EditorActionSpecifier action)
1374 {
1375     RefPtr&lt;Range&gt; selection = selectedRange();
1376     willWriteSelectionToPasteboard(selection.get());
1377     if (action == CutAction) {
1378         if (!shouldDeleteRange(selection.get()))
1379             return;
1380 
1381         updateMarkersForWordsAffectedByEditing(true);
1382     }
1383 
1384     if (enclosingTextFormControl(m_frame.selection().selection().start()))
1385         Pasteboard::createForCopyAndPaste()-&gt;writePlainText(selectedTextForDataTransfer(), canSmartCopyOrDelete() ? Pasteboard::CanSmartReplace : Pasteboard::CannotSmartReplace);
1386     else {
1387         HTMLImageElement* imageElement = nullptr;
1388         if (action == CopyAction)
1389             imageElement = imageElementFromImageDocument(document());
1390 
1391         if (imageElement) {
1392 #if !PLATFORM(WIN)
1393             writeImageToPasteboard(*Pasteboard::createForCopyAndPaste(), *imageElement, document().url(), document().title());
1394 #else
1395             // FIXME: Delete after &lt;http://webkit.org/b/177618&gt; lands.
1396             Pasteboard::createForCopyAndPaste()-&gt;writeImage(*imageElement, document().url(), document().title());
1397 #endif
1398         } else {
1399 #if !PLATFORM(WIN)
1400             writeSelectionToPasteboard(*Pasteboard::createForCopyAndPaste());
1401 #else
1402             // FIXME: Delete after &lt;http://webkit.org/b/177618&gt; lands.
1403             Pasteboard::createForCopyAndPaste()-&gt;writeSelection(*selection, canSmartCopyOrDelete(), m_frame, IncludeImageAltTextForDataTransfer);
1404 #endif
1405         }
1406     }
1407 
1408     didWriteSelectionToPasteboard();
1409     if (action == CutAction) {
1410         String text;
1411         if (AXObjectCache::accessibilityEnabled())
1412             text = AccessibilityObject::stringForVisiblePositionRange(m_frame.selection().selection());
1413         deleteSelectionWithSmartDelete(canSmartCopyOrDelete(), EditAction::Cut);
1414         if (AXObjectCache::accessibilityEnabled())
1415             postTextStateChangeNotificationForCut(text, m_frame.selection().selection());
1416     }
1417 }
1418 
1419 void Editor::paste()
1420 {
1421     paste(*Pasteboard::createForCopyAndPaste());
1422 }
1423 
1424 void Editor::paste(Pasteboard&amp; pasteboard)
1425 {
1426     if (!dispatchClipboardEvent(findEventTargetFromSelection(), ClipboardEventKind::Paste))
1427         return; // DHTML did the whole operation
1428     if (!canPaste())
1429         return;
1430     updateMarkersForWordsAffectedByEditing(false);
1431     ResourceCacheValidationSuppressor validationSuppressor(document().cachedResourceLoader());
1432     if (m_frame.selection().selection().isContentRichlyEditable())
1433         pasteWithPasteboard(&amp;pasteboard, { PasteOption::AllowPlainText });
1434     else
1435         pasteAsPlainTextWithPasteboard(pasteboard);
1436 }
1437 
1438 void Editor::pasteAsPlainText()
1439 {
1440     if (!dispatchClipboardEvent(findEventTargetFromSelection(), ClipboardEventKind::PasteAsPlainText))
1441         return;
1442     if (!canPaste())
1443         return;
1444     updateMarkersForWordsAffectedByEditing(false);
1445     pasteAsPlainTextWithPasteboard(*Pasteboard::createForCopyAndPaste());
1446 }
1447 
1448 void Editor::pasteAsQuotation()
1449 {
1450     if (!dispatchClipboardEvent(findEventTargetFromSelection(), ClipboardEventKind::PasteAsQuotation))
1451         return;
1452     if (!canPaste())
1453         return;
1454     updateMarkersForWordsAffectedByEditing(false);
1455     ResourceCacheValidationSuppressor validationSuppressor(document().cachedResourceLoader());
1456     auto pasteboard = Pasteboard::createForCopyAndPaste();
1457     if (m_frame.selection().selection().isContentRichlyEditable())
1458         pasteWithPasteboard(pasteboard.get(), { PasteOption::AllowPlainText, PasteOption::AsQuotation });
1459     else
1460         pasteAsPlainTextWithPasteboard(*pasteboard);
1461 }
1462 
1463 void Editor::quoteFragmentForPasting(DocumentFragment&amp; fragment)
1464 {
1465     auto blockQuote = HTMLQuoteElement::create(blockquoteTag, document());
<a name="18" id="anc18"></a><span class="line-modified">1466     blockQuote-&gt;setAttributeWithoutSynchronization(typeAttr, AtomString(&quot;cite&quot;));</span>
<span class="line-modified">1467     blockQuote-&gt;setAttributeWithoutSynchronization(classAttr, AtomString(ApplePasteAsQuotation));</span>
1468 
1469     auto childNode = fragment.firstChild();
1470 
1471     if (childNode) {
1472         while (childNode) {
1473             blockQuote-&gt;appendChild(*childNode);
1474             childNode = fragment.firstChild();
1475         }
1476     } else
1477         blockQuote-&gt;appendChild(HTMLBRElement::create(document()));
1478 
1479     fragment.appendChild(blockQuote);
1480 }
1481 
1482 void Editor::performDelete()
1483 {
1484     if (!canDelete()) {
1485         PAL::systemBeep();
1486         return;
1487     }
1488 
1489     addRangeToKillRing(*selectedRange().get(), KillRingInsertionMode::AppendText);
1490     deleteSelectionWithSmartDelete(canSmartCopyOrDelete());
1491 
1492     // clear the &quot;start new kill ring sequence&quot; setting, because it was set to true
1493     // when the selection was updated by deleting the range
1494     setStartNewKillRingSequence(false);
1495 }
1496 
1497 void Editor::changeSelectionListType()
1498 {
1499     if (auto type = ChangeListTypeCommand::listConversionType(document()))
1500         ChangeListTypeCommand::create(document(), *type)-&gt;apply();
1501 }
1502 
1503 void Editor::simplifyMarkup(Node* startNode, Node* endNode)
1504 {
1505     if (!startNode)
1506         return;
1507     if (endNode) {
1508         if (&amp;startNode-&gt;document() != &amp;endNode-&gt;document())
1509             return;
1510         // check if start node is before endNode
1511         Node* node = startNode;
1512         while (node &amp;&amp; node != endNode)
1513             node = NodeTraversal::next(*node);
1514         if (!node)
1515             return;
1516     }
1517 
1518     SimplifyMarkupCommand::create(document(), startNode, endNode ? NodeTraversal::next(*endNode) : nullptr)-&gt;apply();
1519 }
1520 
1521 void Editor::copyURL(const URL&amp; url, const String&amp; title)
1522 {
1523     copyURL(url, title, *Pasteboard::createForCopyAndPaste());
1524 }
1525 
1526 void Editor::copyURL(const URL&amp; url, const String&amp; title, Pasteboard&amp; pasteboard)
1527 {
1528     PasteboardURL pasteboardURL;
1529     pasteboardURL.url = url;
1530     pasteboardURL.title = title;
1531 
1532 #if PLATFORM(MAC)
1533     pasteboardURL.userVisibleForm = userVisibleString(url);
1534 #endif
1535 
1536     pasteboard.write(pasteboardURL);
1537 }
1538 
1539 PasteboardWriterData::URLData Editor::pasteboardWriterURL(const URL&amp; url, const String&amp; title)
1540 {
1541     PasteboardWriterData::URLData result;
1542 
1543     result.url = url;
1544     result.title = title;
1545 #if PLATFORM(MAC)
1546     result.userVisibleForm = userVisibleString(url);
1547 #endif
1548 
1549     return result;
1550 }
1551 
1552 #if !PLATFORM(IOS_FAMILY)
1553 
1554 void Editor::copyImage(const HitTestResult&amp; result)
1555 {
1556     Element* element = result.innerNonSharedElement();
1557     if (!element)
1558         return;
1559 
1560     URL url = result.absoluteLinkURL();
1561     if (url.isEmpty())
1562         url = result.absoluteImageURL();
1563 
1564 #if !PLATFORM(WIN)
1565     writeImageToPasteboard(*Pasteboard::createForCopyAndPaste(), *element, url, result.altDisplayString());
1566 #else
1567     // FIXME: Delete after &lt;http://webkit.org/b/177618&gt; lands.
1568     Pasteboard::createForCopyAndPaste()-&gt;writeImage(*element, url, result.altDisplayString());
1569 #endif
1570 }
1571 
1572 #endif
1573 
1574 bool Editor::isContinuousSpellCheckingEnabled() const
1575 {
1576     return client() &amp;&amp; client()-&gt;isContinuousSpellCheckingEnabled();
1577 }
1578 
1579 void Editor::toggleContinuousSpellChecking()
1580 {
1581     if (client())
1582         client()-&gt;toggleContinuousSpellChecking();
1583 }
1584 
1585 bool Editor::isGrammarCheckingEnabled()
1586 {
1587     return client() &amp;&amp; client()-&gt;isGrammarCheckingEnabled();
1588 }
1589 
1590 void Editor::toggleGrammarChecking()
1591 {
1592     if (client())
1593         client()-&gt;toggleGrammarChecking();
1594 }
1595 
1596 int Editor::spellCheckerDocumentTag()
1597 {
1598     return client() ? client()-&gt;spellCheckerDocumentTag() : 0;
1599 }
1600 
1601 #if USE(APPKIT)
1602 
1603 void Editor::uppercaseWord()
1604 {
1605     if (client())
1606         client()-&gt;uppercaseWord();
1607 }
1608 
1609 void Editor::lowercaseWord()
1610 {
1611     if (client())
1612         client()-&gt;lowercaseWord();
1613 }
1614 
1615 void Editor::capitalizeWord()
1616 {
1617     if (client())
1618         client()-&gt;capitalizeWord();
1619 }
1620 
1621 #endif
1622 
1623 #if USE(AUTOMATIC_TEXT_REPLACEMENT)
1624 
1625 void Editor::showSubstitutionsPanel()
1626 {
1627     if (!client()) {
1628         LOG_ERROR(&quot;No NSSpellChecker&quot;);
1629         return;
1630     }
1631 
1632     if (client()-&gt;substitutionsPanelIsShowing()) {
1633         client()-&gt;showSubstitutionsPanel(false);
1634         return;
1635     }
1636     client()-&gt;showSubstitutionsPanel(true);
1637 }
1638 
1639 bool Editor::substitutionsPanelIsShowing()
1640 {
1641     if (!client())
1642         return false;
1643     return client()-&gt;substitutionsPanelIsShowing();
1644 }
1645 
1646 void Editor::toggleSmartInsertDelete()
1647 {
1648     if (client())
1649         client()-&gt;toggleSmartInsertDelete();
1650 }
1651 
1652 bool Editor::isAutomaticQuoteSubstitutionEnabled()
1653 {
1654     return client() &amp;&amp; client()-&gt;isAutomaticQuoteSubstitutionEnabled();
1655 }
1656 
1657 void Editor::toggleAutomaticQuoteSubstitution()
1658 {
1659     if (client())
1660         client()-&gt;toggleAutomaticQuoteSubstitution();
1661 }
1662 
1663 bool Editor::isAutomaticLinkDetectionEnabled()
1664 {
1665     return client() &amp;&amp; client()-&gt;isAutomaticLinkDetectionEnabled();
1666 }
1667 
1668 void Editor::toggleAutomaticLinkDetection()
1669 {
1670     if (client())
1671         client()-&gt;toggleAutomaticLinkDetection();
1672 }
1673 
1674 bool Editor::isAutomaticDashSubstitutionEnabled()
1675 {
1676     return client() &amp;&amp; client()-&gt;isAutomaticDashSubstitutionEnabled();
1677 }
1678 
1679 void Editor::toggleAutomaticDashSubstitution()
1680 {
1681     if (client())
1682         client()-&gt;toggleAutomaticDashSubstitution();
1683 }
1684 
1685 bool Editor::isAutomaticTextReplacementEnabled()
1686 {
1687     return client() &amp;&amp; client()-&gt;isAutomaticTextReplacementEnabled();
1688 }
1689 
1690 void Editor::toggleAutomaticTextReplacement()
1691 {
1692     if (client())
1693         client()-&gt;toggleAutomaticTextReplacement();
1694 }
1695 
1696 bool Editor::isAutomaticSpellingCorrectionEnabled()
1697 {
1698     return m_alternativeTextController-&gt;isAutomaticSpellingCorrectionEnabled();
1699 }
1700 
1701 void Editor::toggleAutomaticSpellingCorrection()
1702 {
1703     if (client())
1704         client()-&gt;toggleAutomaticSpellingCorrection();
1705 }
1706 
1707 #endif
1708 
1709 bool Editor::shouldEndEditing(Range* range)
1710 {
1711     return client() &amp;&amp; client()-&gt;shouldEndEditing(range);
1712 }
1713 
1714 bool Editor::shouldBeginEditing(Range* range)
1715 {
1716     return client() &amp;&amp; client()-&gt;shouldBeginEditing(range);
1717 }
1718 
1719 void Editor::clearUndoRedoOperations()
1720 {
1721     if (client())
1722         client()-&gt;clearUndoRedoOperations();
1723 }
1724 
1725 bool Editor::canUndo() const
1726 {
1727     return client() &amp;&amp; client()-&gt;canUndo();
1728 }
1729 
1730 void Editor::undo()
1731 {
1732     if (client())
1733         client()-&gt;undo();
1734 }
1735 
1736 bool Editor::canRedo() const
1737 {
1738     return client() &amp;&amp; client()-&gt;canRedo();
1739 }
1740 
1741 void Editor::redo()
1742 {
1743     if (client())
1744         client()-&gt;redo();
1745 }
1746 
1747 void Editor::registerCustomUndoStep(Ref&lt;CustomUndoStep&gt;&amp;&amp; undoStep)
1748 {
1749     ASSERT(RuntimeEnabledFeatures::sharedFeatures().undoManagerAPIEnabled());
1750     if (auto* client = this-&gt;client())
1751         client-&gt;registerUndoStep(WTFMove(undoStep));
1752 }
1753 
1754 void Editor::didBeginEditing()
1755 {
1756     if (client())
1757         client()-&gt;didBeginEditing();
1758 }
1759 
1760 void Editor::didEndEditing()
1761 {
1762     if (client())
1763         client()-&gt;didEndEditing();
1764 }
1765 
1766 void Editor::willWriteSelectionToPasteboard(Range* range)
1767 {
1768     if (client())
1769         client()-&gt;willWriteSelectionToPasteboard(range);
1770 }
1771 
1772 void Editor::didWriteSelectionToPasteboard()
1773 {
1774     if (client())
1775         client()-&gt;didWriteSelectionToPasteboard();
1776 }
1777 
1778 void Editor::toggleBold()
1779 {
1780     command(&quot;ToggleBold&quot;).execute();
1781 }
1782 
1783 void Editor::toggleUnderline()
1784 {
1785     command(&quot;ToggleUnderline&quot;).execute();
1786 }
1787 
1788 void Editor::setBaseWritingDirection(WritingDirection direction)
1789 {
1790 #if PLATFORM(IOS_FAMILY)
1791     if (inSameParagraph(m_frame.selection().selection().visibleStart(), m_frame.selection().selection().visibleEnd()) &amp;&amp;
1792         baseWritingDirectionForSelectionStart() == direction)
1793         return;
1794 #endif
1795 
1796     Element* focusedElement = document().focusedElement();
1797     if (focusedElement &amp;&amp; focusedElement-&gt;isTextField()) {
1798         if (direction == WritingDirection::Natural)
1799             return;
1800 
1801         auto&amp; focusedFormElement = downcast&lt;HTMLTextFormControlElement&gt;(*focusedElement);
1802         auto directionValue = direction == WritingDirection::LeftToRight ? &quot;ltr&quot; : &quot;rtl&quot;;
<a name="19" id="anc19"></a><span class="line-modified">1803         auto writingDirectionInputTypeName = inputTypeNameForEditingAction(EditAction::SetBlockWritingDirection);</span>
1804         if (!dispatchBeforeInputEvent(focusedFormElement, writingDirectionInputTypeName, directionValue))
1805             return;
1806 
1807         focusedFormElement.setAttributeWithoutSynchronization(dirAttr, directionValue);
1808         dispatchInputEvent(focusedFormElement, writingDirectionInputTypeName, directionValue);
1809         document().updateStyleIfNeeded();
1810         return;
1811     }
1812 
1813     auto style = MutableStyleProperties::create();
1814     style-&gt;setProperty(CSSPropertyDirection, direction == WritingDirection::LeftToRight ? &quot;ltr&quot; : direction == WritingDirection::RightToLeft ? &quot;rtl&quot; : &quot;inherit&quot;, false);
<a name="20" id="anc20"></a><span class="line-modified">1815     applyParagraphStyleToSelection(style.ptr(), EditAction::SetBlockWritingDirection);</span>
1816 }
1817 
1818 WritingDirection Editor::baseWritingDirectionForSelectionStart() const
1819 {
1820     auto result = WritingDirection::LeftToRight;
1821 
1822     Position pos = m_frame.selection().selection().visibleStart().deepEquivalent();
1823     Node* node = pos.deprecatedNode();
1824     if (!node)
1825         return result;
1826 
1827     auto renderer = node-&gt;renderer();
1828     if (!renderer)
1829         return result;
1830 
1831     if (!renderer-&gt;isRenderBlockFlow()) {
1832         renderer = renderer-&gt;containingBlock();
1833         if (!renderer)
1834             return result;
1835     }
1836 
1837     switch (renderer-&gt;style().direction()) {
1838     case TextDirection::LTR:
1839         return WritingDirection::LeftToRight;
1840     case TextDirection::RTL:
1841         return WritingDirection::RightToLeft;
1842     }
1843 
1844     return result;
1845 }
1846 
1847 void Editor::selectComposition()
1848 {
1849     RefPtr&lt;Range&gt; range = compositionRange();
1850     if (!range)
1851         return;
1852 
1853     // The composition can start inside a composed character sequence, so we have to override checks.
1854     // See &lt;http://bugs.webkit.org/show_bug.cgi?id=15781&gt;
1855     VisibleSelection selection;
1856     selection.setWithoutValidation(range-&gt;startPosition(), range-&gt;endPosition());
1857     m_frame.selection().setSelection(selection, { });
1858 }
1859 
1860 void Editor::confirmComposition()
1861 {
1862     if (!m_compositionNode)
1863         return;
1864     setComposition(m_compositionNode-&gt;data().substring(m_compositionStart, m_compositionEnd - m_compositionStart), ConfirmComposition);
1865 }
1866 
1867 void Editor::cancelComposition()
1868 {
1869     if (!m_compositionNode)
1870         return;
1871     setComposition(emptyString(), CancelComposition);
1872 }
1873 
1874 bool Editor::cancelCompositionIfSelectionIsInvalid()
1875 {
1876     unsigned start;
1877     unsigned end;
1878     if (!hasComposition() || ignoreSelectionChanges() || getCompositionSelection(start, end))
1879         return false;
1880 
1881     cancelComposition();
1882     return true;
1883 }
1884 
1885 void Editor::confirmComposition(const String&amp; text)
1886 {
1887     setComposition(text, ConfirmComposition);
1888 }
1889 
1890 class SetCompositionScope {
1891 public:
1892     SetCompositionScope(Frame&amp; frame)
1893         : m_frame(frame)
1894         , m_typingGestureIndicator(frame)
1895     {
1896         m_frame-&gt;editor().setIgnoreSelectionChanges(true);
1897     }
1898 
1899     ~SetCompositionScope()
1900     {
1901         m_frame-&gt;editor().setIgnoreSelectionChanges(false);
1902         if (auto* editorClient = m_frame-&gt;editor().client())
1903             editorClient-&gt;didUpdateComposition();
1904     }
1905 
1906     Ref&lt;Frame&gt; m_frame;
1907     UserTypingGestureIndicator m_typingGestureIndicator;
1908 };
1909 
1910 void Editor::setComposition(const String&amp; text, SetCompositionMode mode)
1911 {
1912     ASSERT(mode == ConfirmComposition || mode == CancelComposition);
1913     SetCompositionScope setCompositionScope(m_frame);
1914 
1915     if (mode == CancelComposition)
1916         ASSERT(text == emptyString());
1917     else
1918         selectComposition();
1919 
1920     m_compositionNode = nullptr;
1921     m_customCompositionUnderlines.clear();
1922 
1923     if (m_frame.selection().isNone())
1924         return;
1925 
1926     // Always delete the current composition before inserting the finalized composition text if we&#39;re confirming our composition.
1927     // Our default behavior (if the beforeinput event is not prevented) is to insert the finalized composition text back in.
1928     // We pass TypingCommand::TextCompositionPending here to indicate that we are deleting the pending composition.
1929     if (mode != CancelComposition)
1930         TypingCommand::deleteSelection(document(), 0, TypingCommand::TextCompositionPending);
1931 
1932     insertTextForConfirmedComposition(text);
1933 
1934     if (auto* target = document().focusedElement())
1935         target-&gt;dispatchEvent(CompositionEvent::create(eventNames().compositionendEvent, document().windowProxy(), text));
1936 
1937     if (mode == CancelComposition) {
1938         // An open typing command that disagrees about current selection would cause issues with typing later on.
1939         TypingCommand::closeTyping(&amp;m_frame);
1940     }
1941 }
1942 
1943 void Editor::setComposition(const String&amp; text, const Vector&lt;CompositionUnderline&gt;&amp; underlines, unsigned selectionStart, unsigned selectionEnd)
1944 {
1945     SetCompositionScope setCompositionScope(m_frame);
1946 
1947     // Updates styles before setting selection for composition to prevent
1948     // inserting the previous composition text into text nodes oddly.
1949     // See https://bugs.webkit.org/show_bug.cgi?id=46868
1950     document().updateStyleIfNeeded();
1951 
1952     selectComposition();
1953 
1954     if (m_frame.selection().isNone())
1955         return;
1956 
1957     String originalText = selectedText();
1958     bool isStartingToRecomposeExistingRange = !text.isEmpty() &amp;&amp; selectionStart &lt; selectionEnd &amp;&amp; !hasComposition();
1959     if (isStartingToRecomposeExistingRange) {
1960         // We pass TypingCommand::TextCompositionFinal here to indicate that we are removing composition text that has been finalized.
1961         TypingCommand::deleteSelection(document(), 0, TypingCommand::TextCompositionFinal);
1962         const VisibleSelection&amp; currentSelection = m_frame.selection().selection();
1963         if (currentSelection.isRange()) {
1964             // If deletion was prevented, then we need to collapse the selection to the end so that the original text will not be recomposed.
1965             m_frame.selection().setSelection({ currentSelection.end(), currentSelection.end() });
1966         }
1967     }
1968 
1969 #if PLATFORM(IOS_FAMILY)
1970     client()-&gt;startDelayingAndCoalescingContentChangeNotifications();
1971 #endif
1972 
1973     Element* target = document().focusedElement();
1974     if (target) {
1975         // Dispatch an appropriate composition event to the focused node.
1976         // We check the composition status and choose an appropriate composition event since this
1977         // function is used for three purposes:
1978         // 1. Starting a new composition.
1979         //    Send a compositionstart and a compositionupdate event when this function creates
1980         //    a new composition node, i.e.
1981         //    m_compositionNode == 0 &amp;&amp; !text.isEmpty().
1982         //    Sending a compositionupdate event at this time ensures that at least one
1983         //    compositionupdate event is dispatched.
1984         // 2. Updating the existing composition node.
1985         //    Send a compositionupdate event when this function updates the existing composition
1986         //    node, i.e. m_compositionNode != 0 &amp;&amp; !text.isEmpty().
1987         // 3. Canceling the ongoing composition.
1988         //    Send a compositionend event when function deletes the existing composition node, i.e.
1989         //    m_compositionNode != 0 &amp;&amp; test.isEmpty().
1990         RefPtr&lt;CompositionEvent&gt; event;
1991         if (!m_compositionNode) {
1992             // We should send a compositionstart event only when the given text is not empty because this
1993             // function doesn&#39;t create a composition node when the text is empty.
1994             if (!text.isEmpty()) {
1995                 target-&gt;dispatchEvent(CompositionEvent::create(eventNames().compositionstartEvent, document().windowProxy(), originalText));
1996                 event = CompositionEvent::create(eventNames().compositionupdateEvent, document().windowProxy(), text);
1997             }
1998         } else if (!text.isEmpty())
1999             event = CompositionEvent::create(eventNames().compositionupdateEvent, document().windowProxy(), text);
2000 
2001         if (event)
2002             target-&gt;dispatchEvent(*event);
2003     }
2004 
2005     // If text is empty, then delete the old composition here.  If text is non-empty, InsertTextCommand::input
2006     // will delete the old composition with an optimized replace operation.
2007     if (text.isEmpty()) {
2008         TypingCommand::deleteSelection(document(), TypingCommand::PreventSpellChecking, TypingCommand::TextCompositionPending);
2009         if (target)
2010             target-&gt;dispatchEvent(CompositionEvent::create(eventNames().compositionendEvent, document().windowProxy(), text));
2011     }
2012 
2013     m_compositionNode = nullptr;
2014     m_customCompositionUnderlines.clear();
2015 
2016     if (!text.isEmpty()) {
2017         TypingCommand::insertText(document(), text, TypingCommand::SelectInsertedText | TypingCommand::PreventSpellChecking, TypingCommand::TextCompositionPending);
2018 
2019         // Find out what node has the composition now.
2020         Position base = m_frame.selection().selection().base().downstream();
2021         Position extent = m_frame.selection().selection().extent();
2022         Node* baseNode = base.deprecatedNode();
2023         unsigned baseOffset = base.deprecatedEditingOffset();
2024         Node* extentNode = extent.deprecatedNode();
2025         unsigned extentOffset = extent.deprecatedEditingOffset();
2026 
2027         if (is&lt;Text&gt;(baseNode) &amp;&amp; baseNode == extentNode &amp;&amp; baseOffset + text.length() == extentOffset) {
2028             m_compositionNode = downcast&lt;Text&gt;(baseNode);
2029             m_compositionStart = baseOffset;
2030             m_compositionEnd = extentOffset;
2031             m_customCompositionUnderlines = underlines;
2032             for (auto&amp; underline : m_customCompositionUnderlines) {
2033                 underline.startOffset += baseOffset;
2034                 underline.endOffset += baseOffset;
2035             }
2036             if (baseNode-&gt;renderer())
2037                 baseNode-&gt;renderer()-&gt;repaint();
2038 
2039             unsigned start = std::min(baseOffset + selectionStart, extentOffset);
2040             unsigned end = std::min(std::max(start, baseOffset + selectionEnd), extentOffset);
2041             auto selectedRange = Range::create(baseNode-&gt;document(), baseNode, start, baseNode, end);
2042             m_frame.selection().setSelectedRange(selectedRange.ptr(), DOWNSTREAM, FrameSelection::ShouldCloseTyping::No);
2043         }
2044     }
2045 
2046 #if PLATFORM(IOS_FAMILY)
2047     client()-&gt;stopDelayingAndCoalescingContentChangeNotifications();
2048 #endif
2049 }
2050 
2051 void Editor::ignoreSpelling()
2052 {
2053     if (!client())
2054         return;
2055 
2056     RefPtr&lt;Range&gt; selectedRange = m_frame.selection().toNormalizedRange();
2057     if (selectedRange)
2058         document().markers().removeMarkers(*selectedRange, DocumentMarker::Spelling);
2059 
2060     String text = selectedText();
2061     ASSERT(text.length());
2062     textChecker()-&gt;ignoreWordInSpellDocument(text);
2063 }
2064 
2065 void Editor::learnSpelling()
2066 {
2067     if (!client())
2068         return;
2069 
2070     // FIXME: On Mac OS X, when use &quot;learn&quot; button on &quot;Spelling and Grammar&quot; panel, we don&#39;t call this function. It should remove misspelling markers around the learned word, see &lt;rdar://problem/5396072&gt;.
2071 
2072     RefPtr&lt;Range&gt; selectedRange = m_frame.selection().toNormalizedRange();
2073     if (selectedRange)
2074         document().markers().removeMarkers(*selectedRange, DocumentMarker::Spelling);
2075 
2076     String text = selectedText();
2077     ASSERT(text.length());
2078     textChecker()-&gt;learnWord(text);
2079 }
2080 
2081 #if !PLATFORM(IOS_FAMILY)
2082 
2083 void Editor::advanceToNextMisspelling(bool startBeforeSelection)
2084 {
2085     Ref&lt;Frame&gt; protection(m_frame);
2086 
2087     // The basic approach is to search in two phases - from the selection end to the end of the doc, and
2088     // then we wrap and search from the doc start to (approximately) where we started.
2089 
2090     // Start at the end of the selection, search to edge of document.  Starting at the selection end makes
2091     // repeated &quot;check spelling&quot; commands work.
2092     VisibleSelection selection(m_frame.selection().selection());
2093     Ref&lt;Range&gt; spellingSearchRange = rangeOfContents(document());
2094 
2095     bool startedWithSelection = false;
2096     if (selection.start().deprecatedNode()) {
2097         startedWithSelection = true;
2098         if (startBeforeSelection) {
2099             VisiblePosition start(selection.visibleStart());
2100             // We match AppKit&#39;s rule: Start 1 character before the selection.
2101             VisiblePosition oneBeforeStart = start.previous();
2102             setStart(spellingSearchRange.ptr(), oneBeforeStart.isNotNull() ? oneBeforeStart : start);
2103         } else
2104             setStart(spellingSearchRange.ptr(), selection.visibleEnd());
2105     }
2106 
2107     Position position = spellingSearchRange-&gt;startPosition();
2108     if (!isEditablePosition(position)) {
2109         // This shouldn&#39;t happen in very often because the Spelling menu items aren&#39;t enabled unless the
2110         // selection is editable.
2111         // This can happen in Mail for a mix of non-editable and editable content (like Stationary),
2112         // when spell checking the whole document before sending the message.
2113         // In that case the document might not be editable, but there are editable pockets that need to be spell checked.
2114 
2115         position = VisiblePosition(firstEditablePositionAfterPositionInRoot(position, document().documentElement())).deepEquivalent();
2116         if (position.isNull())
2117             return;
2118 
2119         Position rangeCompliantPosition = position.parentAnchoredEquivalent();
2120         if (rangeCompliantPosition.deprecatedNode())
2121             spellingSearchRange-&gt;setStart(*rangeCompliantPosition.deprecatedNode(), rangeCompliantPosition.deprecatedEditingOffset());
2122         startedWithSelection = false; // won&#39;t need to wrap
2123     }
2124 
2125     // topNode defines the whole range we want to operate on
2126     auto* topNode = highestEditableRoot(position);
2127     // FIXME: lastOffsetForEditing() is wrong here if editingIgnoresContent(highestEditableRoot()) returns true (e.g. a &lt;table&gt;)
2128     if (topNode)
2129         spellingSearchRange-&gt;setEnd(*topNode, lastOffsetForEditing(*topNode));
2130 
2131     // If spellingSearchRange starts in the middle of a word, advance to the next word so we start checking
2132     // at a word boundary. Going back by one char and then forward by a word does the trick.
2133     if (startedWithSelection) {
2134         VisiblePosition oneBeforeStart = startVisiblePosition(spellingSearchRange.ptr(), DOWNSTREAM).previous();
2135         if (oneBeforeStart.isNotNull())
2136             setStart(spellingSearchRange.ptr(), endOfWord(oneBeforeStart));
2137         // else we were already at the start of the editable node
2138     }
2139 
2140     if (spellingSearchRange-&gt;collapsed())
2141         return; // nothing to search in
2142 
2143     // Get the spell checker if it is available
2144     if (!client())
2145         return;
2146 
2147     // We go to the end of our first range instead of the start of it, just to be sure
2148     // we don&#39;t get foiled by any word boundary problems at the start.  It means we might
2149     // do a tiny bit more searching.
2150     Node&amp; searchEndNodeAfterWrap = spellingSearchRange-&gt;endContainer();
2151     int searchEndOffsetAfterWrap = spellingSearchRange-&gt;endOffset();
2152 
2153     int misspellingOffset = 0;
2154     GrammarDetail grammarDetail;
2155     int grammarPhraseOffset = 0;
2156     RefPtr&lt;Range&gt; grammarSearchRange;
2157     String badGrammarPhrase;
2158     String misspelledWord;
2159 
2160     bool isSpelling = true;
2161     int foundOffset = 0;
2162     String foundItem;
2163     RefPtr&lt;Range&gt; firstMisspellingRange;
2164     if (unifiedTextCheckerEnabled()) {
2165         grammarSearchRange = spellingSearchRange-&gt;cloneRange();
2166         foundItem = TextCheckingHelper(*client(), spellingSearchRange).findFirstMisspellingOrBadGrammar(isGrammarCheckingEnabled(), isSpelling, foundOffset, grammarDetail);
2167         if (isSpelling) {
2168             misspelledWord = foundItem;
2169             misspellingOffset = foundOffset;
2170         } else {
2171             badGrammarPhrase = foundItem;
2172             grammarPhraseOffset = foundOffset;
2173         }
2174     } else {
2175         misspelledWord = TextCheckingHelper(*client(), spellingSearchRange).findFirstMisspelling(misspellingOffset, false, firstMisspellingRange);
2176 
2177 #if USE(GRAMMAR_CHECKING)
2178         grammarSearchRange = spellingSearchRange-&gt;cloneRange();
2179         if (!misspelledWord.isEmpty()) {
2180             // Stop looking at start of next misspelled word
2181             CharacterIterator chars(*grammarSearchRange);
2182             chars.advance(misspellingOffset);
2183             grammarSearchRange-&gt;setEnd(chars.range()-&gt;startContainer(), chars.range()-&gt;startOffset());
2184         }
2185 
2186         if (isGrammarCheckingEnabled())
2187             badGrammarPhrase = TextCheckingHelper(*client(), *grammarSearchRange).findFirstBadGrammar(grammarDetail, grammarPhraseOffset, false);
2188 #endif
2189     }
2190 
2191     // If we found neither bad grammar nor a misspelled word, wrap and try again (but don&#39;t bother if we started at the beginning of the
2192     // block rather than at a selection).
2193     if (startedWithSelection &amp;&amp; !misspelledWord &amp;&amp; !badGrammarPhrase) {
2194         if (topNode)
2195             spellingSearchRange-&gt;setStart(*topNode, 0);
2196         // going until the end of the very first chunk we tested is far enough
2197         spellingSearchRange-&gt;setEnd(searchEndNodeAfterWrap, searchEndOffsetAfterWrap);
2198 
2199         if (unifiedTextCheckerEnabled()) {
2200             grammarSearchRange = spellingSearchRange-&gt;cloneRange();
2201             foundItem = TextCheckingHelper(*client(), spellingSearchRange).findFirstMisspellingOrBadGrammar(isGrammarCheckingEnabled(), isSpelling, foundOffset, grammarDetail);
2202             if (isSpelling) {
2203                 misspelledWord = foundItem;
2204                 misspellingOffset = foundOffset;
2205             } else {
2206                 badGrammarPhrase = foundItem;
2207                 grammarPhraseOffset = foundOffset;
2208             }
2209         } else {
2210             misspelledWord = TextCheckingHelper(*client(), spellingSearchRange).findFirstMisspelling(misspellingOffset, false, firstMisspellingRange);
2211 
2212 #if USE(GRAMMAR_CHECKING)
2213             grammarSearchRange = spellingSearchRange-&gt;cloneRange();
2214             if (!misspelledWord.isEmpty()) {
2215                 // Stop looking at start of next misspelled word
2216                 CharacterIterator chars(*grammarSearchRange);
2217                 chars.advance(misspellingOffset);
2218                 grammarSearchRange-&gt;setEnd(chars.range()-&gt;startContainer(), chars.range()-&gt;startOffset());
2219             }
2220 
2221             if (isGrammarCheckingEnabled())
2222                 badGrammarPhrase = TextCheckingHelper(*client(), *grammarSearchRange).findFirstBadGrammar(grammarDetail, grammarPhraseOffset, false);
2223 #endif
2224         }
2225     }
2226 
2227 #if !USE(GRAMMAR_CHECKING)
2228     ASSERT(badGrammarPhrase.isEmpty());
2229     UNUSED_PARAM(grammarPhraseOffset);
2230 #else
2231     if (!badGrammarPhrase.isEmpty()) {
2232         // We found bad grammar. Since we only searched for bad grammar up to the first misspelled word, the bad grammar
2233         // takes precedence and we ignore any potential misspelled word. Select the grammar detail, update the spelling
2234         // panel, and store a marker so we draw the green squiggle later.
2235 
2236         ASSERT(badGrammarPhrase.length() &gt; 0);
2237         ASSERT(grammarDetail.location != -1 &amp;&amp; grammarDetail.length &gt; 0);
2238 
2239         // FIXME 4859190: This gets confused with doubled punctuation at the end of a paragraph
2240         auto badGrammarRange = TextIterator::subrange(*grammarSearchRange, grammarPhraseOffset + grammarDetail.location, grammarDetail.length);
2241         m_frame.selection().setSelection(VisibleSelection(badGrammarRange, SEL_DEFAULT_AFFINITY));
2242         m_frame.selection().revealSelection();
2243 
2244         client()-&gt;updateSpellingUIWithGrammarString(badGrammarPhrase, grammarDetail);
2245         document().markers().addMarker(badGrammarRange, DocumentMarker::Grammar, grammarDetail.userDescription);
2246     } else
2247 #endif
2248     if (!misspelledWord.isEmpty()) {
2249         // We found a misspelling, but not any earlier bad grammar. Select the misspelling, update the spelling panel, and store
2250         // a marker so we draw the red squiggle later.
2251 
2252         auto misspellingRange = TextIterator::subrange(spellingSearchRange, misspellingOffset, misspelledWord.length());
2253         m_frame.selection().setSelection(VisibleSelection(misspellingRange, DOWNSTREAM));
2254         m_frame.selection().revealSelection();
2255 
2256         client()-&gt;updateSpellingUIWithMisspelledWord(misspelledWord);
2257         document().markers().addMarker(misspellingRange, DocumentMarker::Spelling);
2258     }
2259 }
2260 
2261 #endif // !PLATFORM(IOS_FAMILY)
2262 
2263 String Editor::misspelledWordAtCaretOrRange(Node* clickedNode) const
2264 {
2265     if (!isContinuousSpellCheckingEnabled() || !clickedNode || !isSpellCheckingEnabledFor(clickedNode))
2266         return String();
2267 
2268     VisibleSelection selection = m_frame.selection().selection();
2269     if (!selection.isContentEditable() || selection.isNone())
2270         return String();
2271 
2272     VisibleSelection wordSelection(selection.base());
2273     wordSelection.expandUsingGranularity(WordGranularity);
2274     RefPtr&lt;Range&gt; wordRange = wordSelection.toNormalizedRange();
2275     if (!wordRange)
2276         return String();
2277 
2278     // In compliance with GTK+ applications, additionally allow to provide suggestions when the current
2279     // selection exactly match the word selection.
2280     if (selection.isRange() &amp;&amp; !areRangesEqual(wordRange.get(), selection.toNormalizedRange().get()))
2281         return String();
2282 
2283     String word = wordRange-&gt;text();
2284     if (word.isEmpty() || !client())
2285         return String();
2286 
2287     int wordLength = word.length();
2288     int misspellingLocation = -1;
2289     int misspellingLength = 0;
2290     textChecker()-&gt;checkSpellingOfString(word, &amp;misspellingLocation, &amp;misspellingLength);
2291 
2292     return misspellingLength == wordLength ? word : String();
2293 }
2294 
2295 String Editor::misspelledSelectionString() const
2296 {
2297     String selectedString = selectedText();
2298     int length = selectedString.length();
2299     if (!length || !client())
2300         return String();
2301 
2302     int misspellingLocation = -1;
2303     int misspellingLength = 0;
2304     textChecker()-&gt;checkSpellingOfString(selectedString, &amp;misspellingLocation, &amp;misspellingLength);
2305 
2306     // The selection only counts as misspelled if the selected text is exactly one misspelled word
2307     if (misspellingLength != length)
2308         return String();
2309 
2310     // Update the spelling panel to be displaying this error (whether or not the spelling panel is on screen).
2311     // This is necessary to make a subsequent call to [NSSpellChecker ignoreWord:inSpellDocumentWithTag:] work
2312     // correctly; that call behaves differently based on whether the spelling panel is displaying a misspelling
2313     // or a grammar error.
2314     client()-&gt;updateSpellingUIWithMisspelledWord(selectedString);
2315 
2316     return selectedString;
2317 }
2318 
2319 bool Editor::isSelectionUngrammatical()
2320 {
2321 #if USE(GRAMMAR_CHECKING)
2322     RefPtr&lt;Range&gt; range = m_frame.selection().toNormalizedRange();
2323     if (!range || !client())
2324         return false;
2325     return TextCheckingHelper(*client(), *range).isUngrammatical();
2326 #else
2327     return false;
2328 #endif
2329 }
2330 
2331 Vector&lt;String&gt; Editor::guessesForMisspelledWord(const String&amp; word) const
2332 {
2333     ASSERT(word.length());
2334 
2335     Vector&lt;String&gt; guesses;
2336     if (client())
2337         textChecker()-&gt;getGuessesForWord(word, String(), m_frame.selection().selection(), guesses);
2338     return guesses;
2339 }
2340 
2341 Vector&lt;String&gt; Editor::guessesForMisspelledOrUngrammatical(bool&amp; misspelled, bool&amp; ungrammatical)
2342 {
2343     if (unifiedTextCheckerEnabled()) {
2344         RefPtr&lt;Range&gt; range;
2345         VisibleSelection selection = m_frame.selection().selection();
2346         if (selection.isCaret() &amp;&amp; behavior().shouldAllowSpellingSuggestionsWithoutSelection()) {
2347             VisibleSelection wordSelection = VisibleSelection(selection.base());
2348             wordSelection.expandUsingGranularity(WordGranularity);
2349             range = wordSelection.toNormalizedRange();
2350         } else
2351             range = selection.toNormalizedRange();
2352         if (!range || !client())
2353             return Vector&lt;String&gt;();
2354         return TextCheckingHelper(*client(), *range).guessesForMisspelledOrUngrammaticalRange(isGrammarCheckingEnabled(), misspelled, ungrammatical);
2355     }
2356 
2357     String misspelledWord = behavior().shouldAllowSpellingSuggestionsWithoutSelection() ? misspelledWordAtCaretOrRange(document().focusedElement()) : misspelledSelectionString();
2358     misspelled = !misspelledWord.isEmpty();
2359     // Only unified text checker supports guesses for ungrammatical phrases.
2360     ungrammatical = false;
2361 
2362     if (misspelled)
2363         return guessesForMisspelledWord(misspelledWord);
2364     return Vector&lt;String&gt;();
2365 }
2366 
2367 void Editor::showSpellingGuessPanel()
2368 {
2369     if (!client()) {
2370         LOG_ERROR(&quot;No NSSpellChecker&quot;);
2371         return;
2372     }
2373 
2374     if (client()-&gt;spellingUIIsShowing()) {
2375         client()-&gt;showSpellingUI(false);
2376         return;
2377     }
2378 
2379 #if !PLATFORM(IOS_FAMILY)
2380     advanceToNextMisspelling(true);
2381 #endif
2382     client()-&gt;showSpellingUI(true);
2383 }
2384 
2385 bool Editor::spellingPanelIsShowing()
2386 {
2387     if (!client())
2388         return false;
2389     return client()-&gt;spellingUIIsShowing();
2390 }
2391 
2392 void Editor::clearMisspellingsAndBadGrammar(const VisibleSelection&amp; movingSelection)
2393 {
2394     if (auto selectedRange = movingSelection.toNormalizedRange())
2395         document().markers().removeMarkers(*selectedRange, { DocumentMarker::Spelling, DocumentMarker::Grammar });
2396 }
2397 
2398 void Editor::markMisspellingsAndBadGrammar(const VisibleSelection &amp;movingSelection)
2399 {
2400     markMisspellingsAndBadGrammar(movingSelection, isContinuousSpellCheckingEnabled() &amp;&amp; isGrammarCheckingEnabled(), movingSelection);
2401 }
2402 
2403 void Editor::markMisspellingsAfterTypingToWord(const VisiblePosition &amp;wordStart, const VisibleSelection&amp; selectionAfterTyping, bool doReplacement)
2404 {
2405     Ref&lt;Frame&gt; protection(m_frame);
2406 
<a name="21" id="anc21"></a><span class="line-added">2407     if (platformDrivenTextCheckerEnabled())</span>
<span class="line-added">2408         return;</span>
<span class="line-added">2409 </span>
2410 #if PLATFORM(IOS_FAMILY)
2411     UNUSED_PARAM(selectionAfterTyping);
2412     UNUSED_PARAM(doReplacement);
2413     OptionSet&lt;TextCheckingType&gt; textCheckingOptions;
2414     if (isContinuousSpellCheckingEnabled())
2415         textCheckingOptions.add(TextCheckingType::Spelling);
2416     if (!textCheckingOptions.contains(TextCheckingType::Spelling))
2417         return;
2418 
2419     VisibleSelection adjacentWords = VisibleSelection(startOfWord(wordStart, LeftWordIfOnBoundary), endOfWord(wordStart, RightWordIfOnBoundary));
2420     auto adjacentWordRange = adjacentWords.toNormalizedRange();
2421     markAllMisspellingsAndBadGrammarInRanges(textCheckingOptions, adjacentWordRange.copyRef(), adjacentWordRange.copyRef(), adjacentWordRange.copyRef());
2422 #else
2423 #if !USE(AUTOMATIC_TEXT_REPLACEMENT)
2424     UNUSED_PARAM(doReplacement);
2425 #endif
2426 
2427     if (unifiedTextCheckerEnabled()) {
2428         m_alternativeTextController-&gt;applyPendingCorrection(selectionAfterTyping);
2429 
2430         OptionSet&lt;TextCheckingType&gt; textCheckingOptions;
2431 
2432         if (isContinuousSpellCheckingEnabled())
2433             textCheckingOptions.add(TextCheckingType::Spelling);
2434 
2435 #if USE(AUTOMATIC_TEXT_REPLACEMENT)
2436         if (doReplacement
2437             &amp;&amp; (isAutomaticQuoteSubstitutionEnabled()
2438                 || isAutomaticLinkDetectionEnabled()
2439                 || isAutomaticDashSubstitutionEnabled()
2440                 || isAutomaticTextReplacementEnabled()
2441                 || (textCheckingOptions.contains(TextCheckingType::Spelling) &amp;&amp; isAutomaticSpellingCorrectionEnabled())))
2442             textCheckingOptions.add(TextCheckingType::Replacement);
2443 #endif
2444         if (!textCheckingOptions.contains(TextCheckingType::Spelling) &amp;&amp; !textCheckingOptions.contains(TextCheckingType::Replacement))
2445             return;
2446 
2447         if (isGrammarCheckingEnabled())
2448             textCheckingOptions.add(TextCheckingType::Grammar);
2449 
2450         auto sentenceStart = startOfSentence(wordStart);
2451         auto sentenceEnd = endOfSentence(wordStart);
2452         VisibleSelection fullSentence(sentenceStart, sentenceEnd);
2453         auto fullSentenceRange = fullSentence.toNormalizedRange();
2454         if (!fullSentenceRange)
2455             return;
2456 
2457         auto spellCheckingStart = wordStart;
2458         auto spellCheckingEnd = wordStart;
2459 
2460         // FIXME: The following logic doesn&#39;t handle adding spelling markers due to retro sentence corrections when an
2461         // incorrectly spelled range is separated from the start of the current word by a text node inside an element
2462         // with spellcheck disabled. To fix this, we need to refactor markAllMisspellingsAndBadGrammarInRanges so that
2463         // it can handle a list of spelling ranges, alongside the grammar range.
2464         while (sentenceStart &lt; spellCheckingStart) {
2465             auto previousPosition = spellCheckingStart.previous(CannotCrossEditingBoundary);
2466             if (previousPosition.isNull() || previousPosition == spellCheckingStart)
2467                 break;
2468 
2469             auto* container = previousPosition.deepEquivalent().downstream().containerNode();
2470             if (auto* containerElement = is&lt;Element&gt;(container) ? downcast&lt;Element&gt;(container) : container-&gt;parentElement()) {
2471                 if (!containerElement-&gt;isSpellCheckingEnabled())
2472                     break;
2473             }
2474 
2475             spellCheckingStart = previousPosition;
2476         }
2477 
2478         while (spellCheckingEnd &lt; sentenceEnd) {
2479             auto nextPosition = spellCheckingEnd.next(CannotCrossEditingBoundary);
2480             if (nextPosition.isNull() || nextPosition == spellCheckingEnd)
2481                 break;
2482 
2483             auto* container = nextPosition.deepEquivalent().upstream().containerNode();
2484             if (auto* containerElement = is&lt;Element&gt;(container) ? downcast&lt;Element&gt;(container) : container-&gt;parentElement()) {
2485                 if (!containerElement-&gt;isSpellCheckingEnabled())
2486                     break;
2487             }
2488 
2489             spellCheckingEnd = nextPosition;
2490         }
2491 
2492         auto spellCheckingRange = VisibleSelection(spellCheckingStart, spellCheckingEnd).toNormalizedRange();
2493         if (!spellCheckingRange)
2494             return;
2495 
2496         auto adjacentWordRange = VisibleSelection(startOfWord(wordStart, LeftWordIfOnBoundary), endOfWord(wordStart, RightWordIfOnBoundary)).toNormalizedRange();
2497         if (!adjacentWordRange)
2498             return;
2499 
2500         // The spelling and grammar markers in these ranges are recomputed. This is because typing a word may
2501         // cause any other part of the current sentence to lose or gain spelling correction markers, due to
2502         // sentence retro correction. As such, we expand the spell checking range to encompass as much of the
2503         // full sentence as we can, respecting boundaries where spellchecking is disabled.
2504         fullSentenceRange-&gt;ownerDocument().markers().removeMarkers(*fullSentenceRange, DocumentMarker::Grammar);
2505         spellCheckingRange-&gt;ownerDocument().markers().removeMarkers(*spellCheckingRange, DocumentMarker::Spelling);
2506         markAllMisspellingsAndBadGrammarInRanges(textCheckingOptions, WTFMove(spellCheckingRange), WTFMove(adjacentWordRange), WTFMove(fullSentenceRange));
2507         return;
2508     }
2509 
2510     if (!isContinuousSpellCheckingEnabled())
2511         return;
2512 
2513     // Check spelling of one word
2514     RefPtr&lt;Range&gt; misspellingRange;
2515     markMisspellings(VisibleSelection(startOfWord(wordStart, LeftWordIfOnBoundary), endOfWord(wordStart, RightWordIfOnBoundary)), misspellingRange);
2516 
2517     // Autocorrect the misspelled word.
2518     if (!misspellingRange)
2519         return;
2520 
2521     // Get the misspelled word.
2522     const String misspelledWord = plainText(misspellingRange.get());
2523     String autocorrectedString = textChecker()-&gt;getAutoCorrectSuggestionForMisspelledWord(misspelledWord);
2524 
2525     // If autocorrected word is non empty, replace the misspelled word by this word.
2526     if (!autocorrectedString.isEmpty()) {
2527         VisibleSelection newSelection(*misspellingRange, DOWNSTREAM);
2528         if (newSelection != m_frame.selection().selection()) {
2529             if (!m_frame.selection().shouldChangeSelection(newSelection))
2530                 return;
2531             m_frame.selection().setSelection(newSelection);
2532         }
2533 
2534         if (!m_frame.editor().shouldInsertText(autocorrectedString, misspellingRange.get(), EditorInsertAction::Typed))
2535             return;
2536         m_frame.editor().replaceSelectionWithText(autocorrectedString, SelectReplacement::No, SmartReplace::No, EditAction::Insert);
2537 
2538         // Reset the charet one character further.
2539         m_frame.selection().moveTo(m_frame.selection().selection().end());
2540         m_frame.selection().modify(FrameSelection::AlterationMove, DirectionForward, CharacterGranularity);
2541     }
2542 
2543     if (!isGrammarCheckingEnabled())
2544         return;
2545 
2546     // Check grammar of entire sentence
2547     markBadGrammar(VisibleSelection(startOfSentence(wordStart), endOfSentence(wordStart)));
2548 #endif
2549 }
2550 
2551 void Editor::markMisspellingsOrBadGrammar(const VisibleSelection&amp; selection, bool checkSpelling, RefPtr&lt;Range&gt;&amp; firstMisspellingRange)
2552 {
2553 #if !PLATFORM(IOS_FAMILY)
2554     // This function is called with a selection already expanded to word boundaries.
2555     // Might be nice to assert that here.
2556 
2557     // This function is used only for as-you-type checking, so if that&#39;s off we do nothing. Note that
2558     // grammar checking can only be on if spell checking is also on.
2559     if (!isContinuousSpellCheckingEnabled())
2560         return;
2561 
2562     RefPtr&lt;Range&gt; searchRange(selection.toNormalizedRange());
2563     if (!searchRange)
2564         return;
2565 
2566     // If we&#39;re not in an editable node, bail.
2567     Node&amp; editableNode = searchRange-&gt;startContainer();
2568     if (!editableNode.hasEditableStyle())
2569         return;
2570 
2571     if (!isSpellCheckingEnabledFor(&amp;editableNode))
2572         return;
2573 
2574     // Get the spell checker if it is available
2575     if (!client())
2576         return;
2577 
2578     TextCheckingHelper checker(*client(), *searchRange);
2579     if (checkSpelling)
2580         checker.markAllMisspellings(firstMisspellingRange);
2581     else {
2582 #if USE(GRAMMAR_CHECKING)
2583         if (isGrammarCheckingEnabled())
2584             checker.markAllBadGrammar();
2585 #else
2586         ASSERT_NOT_REACHED();
2587 #endif
2588     }
2589 #else
2590         UNUSED_PARAM(selection);
2591         UNUSED_PARAM(checkSpelling);
2592         UNUSED_PARAM(firstMisspellingRange);
2593 #endif // !PLATFORM(IOS_FAMILY)
2594 }
2595 
2596 bool Editor::isSpellCheckingEnabledFor(Node* node) const
2597 {
2598     if (!node)
2599         return false;
2600     Element* element = is&lt;Element&gt;(*node) ? downcast&lt;Element&gt;(node) : node-&gt;parentElement();
2601     if (!element)
2602         return false;
2603     if (element-&gt;isInUserAgentShadowTree()) {
2604         if (HTMLTextFormControlElement* textControl = enclosingTextFormControl(firstPositionInOrBeforeNode(element)))
2605             return textControl-&gt;isSpellCheckingEnabled();
2606     }
2607     return element-&gt;isSpellCheckingEnabled();
2608 }
2609 
2610 bool Editor::isSpellCheckingEnabledInFocusedNode() const
2611 {
2612     return isSpellCheckingEnabledFor(m_frame.selection().selection().start().deprecatedNode());
2613 }
2614 
2615 void Editor::markMisspellings(const VisibleSelection&amp; selection, RefPtr&lt;Range&gt;&amp; firstMisspellingRange)
2616 {
2617     markMisspellingsOrBadGrammar(selection, true, firstMisspellingRange);
2618 }
2619 
2620 void Editor::markBadGrammar(const VisibleSelection&amp; selection)
2621 {
2622 #if USE(GRAMMAR_CHECKING)
2623     RefPtr&lt;Range&gt; firstMisspellingRange;
2624     markMisspellingsOrBadGrammar(selection, false, firstMisspellingRange);
2625 #else
2626     ASSERT_NOT_REACHED();
2627 #endif
2628 }
2629 
2630 void Editor::markAllMisspellingsAndBadGrammarInRanges(OptionSet&lt;TextCheckingType&gt; textCheckingOptions, RefPtr&lt;Range&gt;&amp;&amp; spellingRange, RefPtr&lt;Range&gt;&amp;&amp; automaticReplacementRange, RefPtr&lt;Range&gt;&amp;&amp; grammarRange)
2631 {
<a name="22" id="anc22"></a><span class="line-added">2632     if (platformDrivenTextCheckerEnabled())</span>
<span class="line-added">2633         return;</span>
<span class="line-added">2634 </span>
2635     ASSERT(unifiedTextCheckerEnabled());
2636 
2637     // There shouldn&#39;t be pending autocorrection at this moment.
2638     ASSERT(!m_alternativeTextController-&gt;hasPendingCorrection());
2639 
2640     bool shouldMarkGrammar = textCheckingOptions.contains(TextCheckingType::Grammar);
2641     bool shouldShowCorrectionPanel = textCheckingOptions.contains(TextCheckingType::ShowCorrectionPanel);
2642 
2643     // This function is called with selections already expanded to word boundaries.
2644     if (!client() || !spellingRange || (shouldMarkGrammar &amp;&amp; !grammarRange))
2645         return;
2646 
2647     // If we&#39;re not in an editable node, bail.
2648     Node&amp; editableNode = spellingRange-&gt;startContainer();
2649     if (!editableNode.hasEditableStyle())
2650         return;
2651 
2652     if (!isSpellCheckingEnabledFor(&amp;editableNode))
2653         return;
2654 
2655     auto rangeToCheck = shouldMarkGrammar ? grammarRange.releaseNonNull() : spellingRange.releaseNonNull();
2656     TextCheckingParagraph paragraphToCheck(rangeToCheck.get());
2657     if (paragraphToCheck.isEmpty())
2658         return;
2659 
2660     bool asynchronous = m_frame.settings().asynchronousSpellCheckingEnabled() &amp;&amp; !shouldShowCorrectionPanel;
2661 
2662     // In asynchronous mode, we intentionally check paragraph-wide sentence.
2663     const auto resolvedOptions = resolveTextCheckingTypeMask(editableNode, textCheckingOptions);
2664     auto textReplacementRange = automaticReplacementRange ? makeRef(*automaticReplacementRange) : rangeToCheck.copyRef();
2665     auto request = SpellCheckRequest::create(resolvedOptions, TextCheckingProcessIncremental, asynchronous ? makeRef(paragraphToCheck.paragraphRange()) : WTFMove(rangeToCheck), WTFMove(textReplacementRange), paragraphToCheck.paragraphRange());
2666     if (!request)
2667         return;
2668 
2669     if (asynchronous) {
2670         m_spellChecker-&gt;requestCheckingFor(request.releaseNonNull());
2671         return;
2672     }
2673 
2674     Vector&lt;TextCheckingResult&gt; results;
2675     checkTextOfParagraph(*textChecker(), paragraphToCheck.text(), resolvedOptions, results, m_frame.selection().selection());
2676     markAndReplaceFor(request.releaseNonNull(), results);
2677 }
2678 
2679 static bool isAutomaticTextReplacementType(TextCheckingType type)
2680 {
2681     switch (type) {
2682     case TextCheckingType::None:
2683     case TextCheckingType::Spelling:
2684     case TextCheckingType::Grammar:
2685         return false;
2686     case TextCheckingType::Link:
2687     case TextCheckingType::Quote:
2688     case TextCheckingType::Dash:
2689     case TextCheckingType::Replacement:
2690     case TextCheckingType::Correction:
2691     case TextCheckingType::ShowCorrectionPanel:
2692         return true;
2693     }
2694     ASSERT_NOT_REACHED();
2695     return false;
2696 }
2697 
<a name="23" id="anc23"></a><span class="line-added">2698 void Editor::replaceRangeForSpellChecking(Range&amp; rangeToReplace, const String&amp; replacement)</span>
<span class="line-added">2699 {</span>
<span class="line-added">2700     SpellingCorrectionCommand::create(rangeToReplace, replacement)-&gt;apply();</span>
<span class="line-added">2701 }</span>
<span class="line-added">2702 </span>
2703 static void correctSpellcheckingPreservingTextCheckingParagraph(TextCheckingParagraph&amp; paragraph, Range&amp; rangeToReplace, const String&amp; replacement, int resultLocation, int resultLength)
2704 {
2705     auto&amp; scope = downcast&lt;ContainerNode&gt;(paragraph.paragraphRange().startContainer().rootNode());
2706 
2707     size_t paragraphLocation;
2708     size_t paragraphLength;
2709     TextIterator::getLocationAndLengthFromRange(&amp;scope, &amp;paragraph.paragraphRange(), paragraphLocation, paragraphLength);
2710 
2711     SpellingCorrectionCommand::create(rangeToReplace, replacement)-&gt;apply();
2712 
2713     // TextCheckingParagraph may be orphaned after SpellingCorrectionCommand mutated DOM.
2714     // See &lt;rdar://10305315&gt;, http://webkit.org/b/89526.
2715 
2716     RefPtr&lt;Range&gt; newParagraphRange = TextIterator::rangeFromLocationAndLength(&amp;scope, paragraphLocation, paragraphLength + replacement.length() - resultLength);
2717 
2718     auto spellCheckingRange = TextIterator::subrange(*newParagraphRange, resultLocation, replacement.length());
2719     paragraph = TextCheckingParagraph(spellCheckingRange.copyRef(), spellCheckingRange.copyRef(), newParagraphRange.get());
2720 }
2721 
2722 void Editor::markAndReplaceFor(const SpellCheckRequest&amp; request, const Vector&lt;TextCheckingResult&gt;&amp; results)
2723 {
2724     Ref&lt;Frame&gt; protection(m_frame);
2725 
2726     auto textCheckingOptions = request.data().checkingTypes();
2727     TextCheckingParagraph paragraph(request.checkingRange(), request.automaticReplacementRange(), &amp;request.paragraphRange());
2728 
2729     // FIXME: Mark this const once MSVC bug is fixed: &lt;https://developercommunity.visualstudio.com/content/problem/316713/msvc-cant-compile-webkits-optionsetcontainsany.html&gt;.
2730     bool shouldPerformReplacement = textCheckingOptions.containsAny({ TextCheckingType::Quote, TextCheckingType::Dash, TextCheckingType::Replacement });
2731     const bool shouldMarkSpelling = textCheckingOptions.contains(TextCheckingType::Spelling);
2732     const bool shouldMarkGrammar = textCheckingOptions.contains(TextCheckingType::Grammar);
2733     const bool shouldMarkLink = textCheckingOptions.contains(TextCheckingType::Link);
2734     const bool shouldShowCorrectionPanel = textCheckingOptions.contains(TextCheckingType::ShowCorrectionPanel);
2735     const bool shouldCheckForCorrection = shouldShowCorrectionPanel || textCheckingOptions.contains(TextCheckingType::Correction);
2736 #if !USE(AUTOCORRECTION_PANEL)
2737     ASSERT(!shouldShowCorrectionPanel);
2738 #endif
2739 
2740     // Expand the range to encompass entire paragraphs, since text checking needs that much context.
2741     int selectionOffset = 0;
2742     bool useAmbiguousBoundaryOffset = false;
2743     bool selectionChanged = false;
2744     bool restoreSelectionAfterChange = false;
2745     bool adjustSelectionForParagraphBoundaries = false;
2746 
2747     if (shouldPerformReplacement || shouldMarkSpelling || shouldCheckForCorrection) {
2748         if (m_frame.selection().selection().selectionType() == VisibleSelection::CaretSelection) {
2749             // Attempt to save the caret position so we can restore it later if needed
2750             Position caretPosition = m_frame.selection().selection().end();
2751             selectionOffset = paragraph.offsetTo(caretPosition).releaseReturnValue();
2752             restoreSelectionAfterChange = true;
2753             if (selectionOffset &gt; 0 &amp;&amp; (selectionOffset &gt; paragraph.textLength() || paragraph.textCharAt(selectionOffset - 1) == newlineCharacter))
2754                 adjustSelectionForParagraphBoundaries = true;
2755             if (selectionOffset &gt; 0 &amp;&amp; selectionOffset &lt;= paragraph.textLength() &amp;&amp; isAmbiguousBoundaryCharacter(paragraph.textCharAt(selectionOffset - 1)))
2756                 useAmbiguousBoundaryOffset = true;
2757         }
2758     }
2759 
2760     int offsetDueToReplacement = 0;
2761 
2762     for (unsigned i = 0; i &lt; results.size(); i++) {
2763         const int spellingRangeEndOffset = paragraph.checkingEnd() + offsetDueToReplacement;
2764         const TextCheckingType resultType = results[i].type;
2765         const int resultLocation = results[i].location + offsetDueToReplacement;
2766         const int resultLength = results[i].length;
2767         const int resultEndLocation = resultLocation + resultLength;
2768         const int automaticReplacementEndLocation = paragraph.automaticReplacementStart() + paragraph.automaticReplacementLength() + offsetDueToReplacement;
2769         const String&amp; replacement = results[i].replacement;
2770         const bool resultEndsAtAmbiguousBoundary = useAmbiguousBoundaryOffset &amp;&amp; selectionOffset - 1 &lt;= resultEndLocation;
2771 
2772         // Only mark misspelling if:
2773         // 1. Current text checking isn&#39;t done for autocorrection, in which case shouldMarkSpelling is false.
2774         // 2. Result falls within spellingRange.
2775         // 3. The word in question doesn&#39;t end at an ambiguous boundary. For instance, we would not mark
2776         //    &quot;wouldn&#39;&quot; as misspelled right after apostrophe is typed.
2777         if (shouldMarkSpelling &amp;&amp; !shouldShowCorrectionPanel &amp;&amp; resultType == TextCheckingType::Spelling
2778             &amp;&amp; resultLocation &gt;= paragraph.checkingStart() &amp;&amp; resultEndLocation &lt;= spellingRangeEndOffset &amp;&amp; !resultEndsAtAmbiguousBoundary) {
2779             ASSERT(resultLength &gt; 0 &amp;&amp; resultLocation &gt;= 0);
2780             auto misspellingRange = paragraph.subrange(resultLocation, resultLength);
2781             if (!m_alternativeTextController-&gt;isSpellingMarkerAllowed(misspellingRange))
2782                 continue;
2783             misspellingRange-&gt;startContainer().document().markers().addMarker(misspellingRange, DocumentMarker::Spelling, replacement);
2784         } else if (shouldMarkGrammar &amp;&amp; resultType == TextCheckingType::Grammar &amp;&amp; paragraph.checkingRangeCovers(resultLocation, resultLength)) {
2785             ASSERT(resultLength &gt; 0 &amp;&amp; resultLocation &gt;= 0);
2786             for (auto&amp; detail : results[i].details) {
2787                 ASSERT(detail.length &gt; 0 &amp;&amp; detail.location &gt;= 0);
2788                 if (paragraph.checkingRangeCovers(resultLocation + detail.location, detail.length)) {
2789                     auto badGrammarRange = paragraph.subrange(resultLocation + detail.location, detail.length);
2790                     badGrammarRange-&gt;startContainer().document().markers().addMarker(badGrammarRange, DocumentMarker::Grammar, detail.userDescription);
2791                 }
2792             }
2793         } else if (resultEndLocation &lt;= automaticReplacementEndLocation &amp;&amp; resultEndLocation &gt;= paragraph.automaticReplacementStart()
2794             &amp;&amp; isAutomaticTextReplacementType(resultType)) {
2795             // In this case the result range just has to touch the automatic replacement range, so we can handle replacing non-word text such as punctuation.
2796             ASSERT(resultLength &gt; 0 &amp;&amp; resultLocation &gt;= 0);
2797 
2798             if (shouldShowCorrectionPanel &amp;&amp; (resultEndLocation &lt; automaticReplacementEndLocation
2799                 || (resultType != TextCheckingType::Replacement &amp;&amp; resultType != TextCheckingType::Correction)))
2800                 continue;
2801 
2802             // Apply replacement if:
2803             // 1. The replacement length is non-zero.
2804             // 2. The result doesn&#39;t end at an ambiguous boundary.
2805             //    (FIXME: this is required until 6853027 is fixed and text checking can do this for us
2806             bool doReplacement = replacement.length() &gt; 0 &amp;&amp; !resultEndsAtAmbiguousBoundary;
2807             auto rangeToReplace = paragraph.subrange(resultLocation, resultLength);
2808 
2809             // Adding links should be done only immediately after they are typed.
2810             if (resultType == TextCheckingType::Link &amp;&amp; selectionOffset != resultEndLocation + 1)
2811                 continue;
2812 
2813             if (!(shouldPerformReplacement || shouldCheckForCorrection || shouldMarkLink) || !doReplacement)
2814                 continue;
2815 
2816             String replacedString = plainText(rangeToReplace.ptr());
2817             const bool existingMarkersPermitReplacement = m_alternativeTextController-&gt;processMarkersOnTextToBeReplacedByResult(results[i], rangeToReplace, replacedString);
2818             if (!existingMarkersPermitReplacement)
2819                 continue;
2820 
2821             if (shouldShowCorrectionPanel) {
2822                 if (resultEndLocation == automaticReplacementEndLocation) {
2823                     // We only show the correction panel on the last word.
2824                     m_alternativeTextController-&gt;show(rangeToReplace, replacement);
2825                     break;
2826                 }
2827                 // If this function is called for showing correction panel, we ignore other correction or replacement.
2828                 continue;
2829             }
2830 
2831             VisibleSelection selectionToReplace(rangeToReplace, DOWNSTREAM);
2832             if (selectionToReplace != m_frame.selection().selection()) {
2833                 if (!m_frame.selection().shouldChangeSelection(selectionToReplace))
2834                     continue;
2835             }
2836 
2837             if (resultType == TextCheckingType::Link) {
2838                 m_frame.selection().setSelection(selectionToReplace);
2839                 selectionChanged = true;
2840                 restoreSelectionAfterChange = false;
2841                 if (canEditRichly())
2842                     CreateLinkCommand::create(document(), replacement)-&gt;apply();
2843             } else if (canEdit() &amp;&amp; shouldInsertText(replacement, rangeToReplace.ptr(), EditorInsertAction::Typed)) {
2844                 correctSpellcheckingPreservingTextCheckingParagraph(paragraph, rangeToReplace, replacement, resultLocation, resultLength);
2845 
2846                 if (AXObjectCache* cache = document().existingAXObjectCache()) {
2847                     if (Element* root = m_frame.selection().selection().rootEditableElement())
2848                         cache-&gt;postNotification(root, AXObjectCache::AXAutocorrectionOccured);
2849                 }
2850 
2851                 // Skip all other results for the replaced text.
2852                 while (i + 1 &lt; results.size() &amp;&amp; results[i + 1].location + offsetDueToReplacement &lt;= resultLocation)
2853                     i++;
2854 
2855                 selectionChanged = true;
2856                 offsetDueToReplacement += replacement.length() - resultLength;
2857                 if (resultLocation &lt; selectionOffset)
2858                     selectionOffset += replacement.length() - resultLength;
2859 
2860                 if (resultType == TextCheckingType::Correction) {
2861                     auto replacementRange = paragraph.subrange(resultLocation, replacement.length());
2862                     m_alternativeTextController-&gt;recordAutocorrectionResponse(AutocorrectionResponse::Accepted, replacedString, replacementRange.ptr());
2863 
2864                     // Add a marker so that corrections can easily be undone and won&#39;t be re-corrected.
2865                     m_alternativeTextController-&gt;markCorrection(replacementRange, replacedString);
2866                 }
2867             }
2868         }
2869     }
2870 
2871     if (selectionChanged) {
2872         TextCheckingParagraph extendedParagraph(WTFMove(paragraph));
2873         // Restore the caret position if we have made any replacements
2874         extendedParagraph.expandRangeToNextEnd();
2875         if (restoreSelectionAfterChange &amp;&amp; selectionOffset &gt;= 0 &amp;&amp; selectionOffset &lt;= extendedParagraph.rangeLength()) {
2876             auto selectionRange = extendedParagraph.subrange(0, selectionOffset);
2877             m_frame.selection().moveTo(selectionRange-&gt;endPosition(), DOWNSTREAM);
2878             if (adjustSelectionForParagraphBoundaries)
2879                 m_frame.selection().modify(FrameSelection::AlterationMove, DirectionForward, CharacterGranularity);
2880         } else {
2881             // If this fails for any reason, the fallback is to go one position beyond the last replacement
2882             m_frame.selection().moveTo(m_frame.selection().selection().end());
2883             m_frame.selection().modify(FrameSelection::AlterationMove, DirectionForward, CharacterGranularity);
2884         }
2885     }
2886 }
2887 
2888 void Editor::changeBackToReplacedString(const String&amp; replacedString)
2889 {
2890 #if !PLATFORM(IOS_FAMILY)
2891     ASSERT(unifiedTextCheckerEnabled());
2892 
2893     if (replacedString.isEmpty())
2894         return;
2895 
2896     RefPtr&lt;Range&gt; selection = selectedRange();
2897     if (!shouldInsertText(replacedString, selection.get(), EditorInsertAction::Pasted))
2898         return;
2899 
2900     m_alternativeTextController-&gt;recordAutocorrectionResponse(AutocorrectionResponse::Reverted, replacedString, selection.get());
2901     TextCheckingParagraph paragraph(*selection);
2902     replaceSelectionWithText(replacedString, SelectReplacement::No, SmartReplace::No, EditAction::Insert);
2903     auto changedRange = paragraph.subrange(paragraph.checkingStart(), replacedString.length());
2904     changedRange-&gt;startContainer().document().markers().addMarker(changedRange, DocumentMarker::Replacement, String());
2905     m_alternativeTextController-&gt;markReversed(changedRange);
2906 #else
2907     ASSERT_NOT_REACHED();
2908     UNUSED_PARAM(replacedString);
2909 #endif // !PLATFORM(IOS_FAMILY)
2910 }
2911 
2912 
2913 void Editor::markMisspellingsAndBadGrammar(const VisibleSelection&amp; spellingSelection, bool markGrammar, const VisibleSelection&amp; grammarSelection)
2914 {
<a name="24" id="anc24"></a><span class="line-added">2915     if (platformDrivenTextCheckerEnabled())</span>
<span class="line-added">2916         return;</span>
<span class="line-added">2917 </span>
2918     if (unifiedTextCheckerEnabled()) {
2919         if (!isContinuousSpellCheckingEnabled())
2920             return;
2921 
2922         // markMisspellingsAndBadGrammar() is triggered by selection change, in which case we check spelling and grammar, but don&#39;t autocorrect misspellings.
2923         OptionSet&lt;TextCheckingType&gt; textCheckingOptions { TextCheckingType::Spelling };
2924         if (markGrammar &amp;&amp; isGrammarCheckingEnabled())
2925             textCheckingOptions.add(TextCheckingType::Grammar);
2926         auto spellCheckingRange = spellingSelection.toNormalizedRange();
2927         markAllMisspellingsAndBadGrammarInRanges(textCheckingOptions, spellCheckingRange.copyRef(), spellCheckingRange.copyRef(), grammarSelection.toNormalizedRange());
2928         return;
2929     }
2930 
2931     RefPtr&lt;Range&gt; firstMisspellingRange;
2932     markMisspellings(spellingSelection, firstMisspellingRange);
2933     if (markGrammar)
2934         markBadGrammar(grammarSelection);
2935 }
2936 
2937 void Editor::unappliedSpellCorrection(const VisibleSelection&amp; selectionOfCorrected, const String&amp; corrected, const String&amp; correction)
2938 {
2939     m_alternativeTextController-&gt;respondToUnappliedSpellCorrection(selectionOfCorrected, corrected, correction);
2940 }
2941 
2942 void Editor::updateMarkersForWordsAffectedByEditing(bool doNotRemoveIfSelectionAtWordBoundary)
2943 {
2944     if (!document().markers().hasMarkers())
2945         return;
2946 
2947     if (!m_alternativeTextController-&gt;shouldRemoveMarkersUponEditing() &amp;&amp; (!textChecker() || textChecker()-&gt;shouldEraseMarkersAfterChangeSelection(TextCheckingType::Spelling)))
2948         return;
2949 
2950     // We want to remove the markers from a word if an editing command will change the word. This can happen in one of
2951     // several scenarios:
2952     // 1. Insert in the middle of a word.
2953     // 2. Appending non whitespace at the beginning of word.
2954     // 3. Appending non whitespace at the end of word.
2955     // Note that, appending only whitespaces at the beginning or end of word won&#39;t change the word, so we don&#39;t need to
2956     // remove the markers on that word.
2957     // Of course, if current selection is a range, we potentially will edit two words that fall on the boundaries of
2958     // selection, and remove words between the selection boundaries.
2959     //
2960     VisiblePosition startOfSelection = m_frame.selection().selection().start();
2961     VisiblePosition endOfSelection = m_frame.selection().selection().end();
2962     if (startOfSelection.isNull())
2963         return;
2964     // First word is the word that ends after or on the start of selection.
2965     VisiblePosition startOfFirstWord = startOfWord(startOfSelection, LeftWordIfOnBoundary);
2966     VisiblePosition endOfFirstWord = endOfWord(startOfSelection, LeftWordIfOnBoundary);
2967     // Last word is the word that begins before or on the end of selection
2968     VisiblePosition startOfLastWord = startOfWord(endOfSelection, RightWordIfOnBoundary);
2969     VisiblePosition endOfLastWord = endOfWord(endOfSelection, RightWordIfOnBoundary);
2970 
2971     if (startOfFirstWord.isNull()) {
2972         startOfFirstWord = startOfWord(startOfSelection, RightWordIfOnBoundary);
2973         endOfFirstWord = endOfWord(startOfSelection, RightWordIfOnBoundary);
2974     }
2975 
2976     if (endOfLastWord.isNull()) {
2977         startOfLastWord = startOfWord(endOfSelection, LeftWordIfOnBoundary);
2978         endOfLastWord = endOfWord(endOfSelection, LeftWordIfOnBoundary);
2979     }
2980 
2981     // If doNotRemoveIfSelectionAtWordBoundary is true, and first word ends at the start of selection,
2982     // we choose next word as the first word.
2983     if (doNotRemoveIfSelectionAtWordBoundary &amp;&amp; endOfFirstWord == startOfSelection) {
2984         startOfFirstWord = nextWordPosition(startOfFirstWord);
2985         endOfFirstWord = endOfWord(startOfFirstWord, RightWordIfOnBoundary);
2986         if (startOfFirstWord == endOfSelection)
2987             return;
2988     }
2989 
2990     // If doNotRemoveIfSelectionAtWordBoundary is true, and last word begins at the end of selection,
2991     // we choose previous word as the last word.
2992     if (doNotRemoveIfSelectionAtWordBoundary &amp;&amp; startOfLastWord == endOfSelection) {
2993         startOfLastWord = previousWordPosition(startOfLastWord);
2994         endOfLastWord = endOfWord(startOfLastWord, RightWordIfOnBoundary);
2995         if (endOfLastWord == startOfSelection)
2996             return;
2997     }
2998 
2999     if (startOfFirstWord.isNull() || endOfFirstWord.isNull() || startOfLastWord.isNull() || endOfLastWord.isNull())
3000         return;
3001 
3002     // Now we remove markers on everything between startOfFirstWord and endOfLastWord.
3003     // However, if an autocorrection change a single word to multiple words, we want to remove correction mark from all the
3004     // resulted words even we only edit one of them. For example, assuming autocorrection changes &quot;avantgarde&quot; to &quot;avant
3005     // garde&quot;, we will have CorrectionIndicator marker on both words and on the whitespace between them. If we then edit garde,
3006     // we would like to remove the marker from word &quot;avant&quot; and whitespace as well. So we need to get the continous range of
3007     // of marker that contains the word in question, and remove marker on that whole range.
3008     auto wordRange = Range::create(document(), startOfFirstWord.deepEquivalent(), endOfLastWord.deepEquivalent());
3009 
3010     Vector&lt;RenderedDocumentMarker*&gt; markers = document().markers().markersInRange(wordRange, DocumentMarker::DictationAlternatives);
3011     for (auto* marker : markers)
3012         m_alternativeTextController-&gt;removeDictationAlternativesForMarker(*marker);
3013 
3014     OptionSet&lt;DocumentMarker::MarkerType&gt; markerTypesToRemove {
3015         DocumentMarker::CorrectionIndicator,
3016         DocumentMarker::DictationAlternatives,
3017         DocumentMarker::SpellCheckingExemption,
3018         DocumentMarker::Spelling,
3019 #if !PLATFORM(IOS_FAMILY)
3020         DocumentMarker::Grammar,
3021 #endif
3022     };
3023     document().markers().removeMarkers(wordRange, markerTypesToRemove, DocumentMarkerController::RemovePartiallyOverlappingMarker);
3024     document().markers().clearDescriptionOnMarkersIntersectingRange(wordRange, DocumentMarker::Replacement);
3025 }
3026 
3027 void Editor::deletedAutocorrectionAtPosition(const Position&amp; position, const String&amp; originalString)
3028 {
3029     m_alternativeTextController-&gt;deletedAutocorrectionAtPosition(position, originalString);
3030 }
3031 
3032 RefPtr&lt;Range&gt; Editor::rangeForPoint(const IntPoint&amp; windowPoint)
3033 {
3034     Document* document = m_frame.documentAtPoint(windowPoint);
3035     if (!document)
3036         return nullptr;
3037 
3038     Frame* frame = document-&gt;frame();
3039     ASSERT(frame);
3040     FrameView* frameView = frame-&gt;view();
3041     if (!frameView)
3042         return nullptr;
3043     IntPoint framePoint = frameView-&gt;windowToContents(windowPoint);
3044     VisibleSelection selection(frame-&gt;visiblePositionForPoint(framePoint));
3045 
3046     return selection.toNormalizedRange();
3047 }
3048 
3049 void Editor::revealSelectionAfterEditingOperation(const ScrollAlignment&amp; alignment, RevealExtentOption revealExtentOption)
3050 {
3051     if (m_ignoreSelectionChanges)
3052         return;
3053 
<a name="25" id="anc25"></a>


3054     SelectionRevealMode revealMode = SelectionRevealMode::Reveal;
<a name="26" id="anc26"></a>

3055     m_frame.selection().revealSelection(revealMode, alignment, revealExtentOption);
3056 }
3057 
3058 void Editor::setIgnoreSelectionChanges(bool ignore, RevealSelection shouldRevealExistingSelection)
3059 {
3060     if (m_ignoreSelectionChanges == ignore)
3061         return;
3062 
3063     m_ignoreSelectionChanges = ignore;
3064 #if PLATFORM(IOS_FAMILY)
3065     // FIXME: Should suppress selection change notifications during a composition change &lt;https://webkit.org/b/38830&gt;
3066     if (!ignore)
3067         respondToChangedSelection(m_frame.selection().selection(), { });
3068 #endif
3069     if (!ignore &amp;&amp; shouldRevealExistingSelection == RevealSelection::Yes)
3070         revealSelectionAfterEditingOperation(ScrollAlignment::alignToEdgeIfNeeded, RevealExtent);
3071 }
3072 
3073 RefPtr&lt;Range&gt; Editor::compositionRange() const
3074 {
3075     if (!m_compositionNode)
3076         return nullptr;
3077     unsigned length = m_compositionNode-&gt;length();
3078     unsigned start = std::min(m_compositionStart, length);
3079     unsigned end = std::min(std::max(start, m_compositionEnd), length);
<a name="27" id="anc27"></a><span class="line-added">3080     // FIXME: Why is this early return neeed?</span>
3081     if (start &gt;= end)
3082         return nullptr;
3083     return Range::create(m_compositionNode-&gt;document(), m_compositionNode.get(), start, m_compositionNode.get(), end);
3084 }
3085 
3086 bool Editor::getCompositionSelection(unsigned&amp; selectionStart, unsigned&amp; selectionEnd) const
3087 {
3088     if (!m_compositionNode)
3089         return false;
3090     const VisibleSelection&amp; selection = m_frame.selection().selection();
3091     Position start = selection.start();
3092     if (start.deprecatedNode() != m_compositionNode)
3093         return false;
3094     Position end = selection.end();
3095     if (end.deprecatedNode() != m_compositionNode)
3096         return false;
3097 
3098     if (static_cast&lt;unsigned&gt;(start.deprecatedEditingOffset()) &lt; m_compositionStart)
3099         return false;
3100     if (static_cast&lt;unsigned&gt;(end.deprecatedEditingOffset()) &gt; m_compositionEnd)
3101         return false;
3102 
3103     selectionStart = start.deprecatedEditingOffset() - m_compositionStart;
3104     selectionEnd = start.deprecatedEditingOffset() - m_compositionEnd;
3105     return true;
3106 }
3107 
3108 void Editor::transpose()
3109 {
3110     if (!canEdit())
3111         return;
3112 
3113     VisibleSelection selection = m_frame.selection().selection();
3114     if (!selection.isCaret())
3115         return;
3116 
3117     // Make a selection that goes back one character and forward two characters.
3118     VisiblePosition caret = selection.visibleStart();
3119     VisiblePosition next = isEndOfParagraph(caret) ? caret : caret.next();
3120     VisiblePosition previous = next.previous();
3121     if (next == previous)
3122         return;
3123     previous = previous.previous();
3124     if (!inSameParagraph(next, previous))
3125         return;
3126     RefPtr&lt;Range&gt; range = makeRange(previous, next);
3127     if (!range)
3128         return;
3129     VisibleSelection newSelection(*range, DOWNSTREAM);
3130 
3131     // Transpose the two characters.
3132     String text = plainText(range.get());
3133     if (text.length() != 2)
3134         return;
3135     String transposed = text.right(1) + text.left(1);
3136 
3137     // Select the two characters.
3138     if (newSelection != m_frame.selection().selection()) {
3139         if (!m_frame.selection().shouldChangeSelection(newSelection))
3140             return;
3141         m_frame.selection().setSelection(newSelection);
3142     }
3143 
3144     // Insert the transposed characters.
3145     if (!shouldInsertText(transposed, range.get(), EditorInsertAction::Typed))
3146         return;
3147     replaceSelectionWithText(transposed, SelectReplacement::No, SmartReplace::No, EditAction::Insert);
3148 }
3149 
3150 void Editor::addRangeToKillRing(const Range&amp; range, KillRingInsertionMode mode)
3151 {
3152     addTextToKillRing(plainText(&amp;range), mode);
3153 }
3154 
3155 void Editor::addTextToKillRing(const String&amp; text, KillRingInsertionMode mode)
3156 {
3157     if (m_shouldStartNewKillRingSequence)
3158         killRing().startNewSequence();
3159 
3160     m_shouldStartNewKillRingSequence = false;
3161 
3162     // If the kill was from a backwards motion, prepend to the kill ring.
3163     // This will ensure that alternating forward and backward kills will
3164     // build up the original string in the kill ring without permuting it.
3165     switch (mode) {
3166     case KillRingInsertionMode::PrependText:
3167         killRing().prepend(text);
3168         break;
3169     case KillRingInsertionMode::AppendText:
3170         killRing().append(text);
3171         break;
3172     }
3173 }
3174 
3175 void Editor::startAlternativeTextUITimer()
3176 {
3177     m_alternativeTextController-&gt;startAlternativeTextUITimer(AlternativeTextTypeCorrection);
3178 }
3179 
3180 void Editor::handleAlternativeTextUIResult(const String&amp; correction)
3181 {
3182     m_alternativeTextController-&gt;handleAlternativeTextUIResult(correction);
3183 }
3184 
3185 
3186 void Editor::dismissCorrectionPanelAsIgnored()
3187 {
3188     m_alternativeTextController-&gt;dismiss(ReasonForDismissingAlternativeTextIgnored);
3189 }
3190 
3191 void Editor::changeSelectionAfterCommand(const VisibleSelection&amp; newSelection, OptionSet&lt;FrameSelection::SetSelectionOption&gt; options)
3192 {
3193     Ref&lt;Frame&gt; protection(m_frame);
3194 
3195     // If the new selection is orphaned, then don&#39;t update the selection.
3196     if (newSelection.start().isOrphan() || newSelection.end().isOrphan())
3197         return;
3198 
3199     // If there is no selection change, don&#39;t bother sending shouldChangeSelection, but still call setSelection,
3200     // because there is work that it must do in this situation.
3201     // The old selection can be invalid here and calling shouldChangeSelection can produce some strange calls.
3202     // See &lt;rdar://problem/5729315&gt; Some shouldChangeSelectedDOMRange contain Ranges for selections that are no longer valid
3203     bool selectionDidNotChangeDOMPosition = newSelection == m_frame.selection().selection();
3204     if (selectionDidNotChangeDOMPosition || m_frame.selection().shouldChangeSelection(newSelection))
3205         m_frame.selection().setSelection(newSelection, options);
3206 
3207     // Some editing operations change the selection visually without affecting its position within the DOM.
3208     // For example when you press return in the following (the caret is marked by ^):
3209     // &lt;div contentEditable=&quot;true&quot;&gt;&lt;div&gt;^Hello&lt;/div&gt;&lt;/div&gt;
3210     // WebCore inserts &lt;div&gt;&lt;br&gt;&lt;/div&gt; *before* the current block, which correctly moves the paragraph down but which doesn&#39;t
3211     // change the caret&#39;s DOM position ([&quot;hello&quot;, 0]). In these situations the above FrameSelection::setSelection call
3212     // does not call EditorClient::respondToChangedSelection(), which, on the Mac, sends selection change notifications and
3213     // starts a new kill ring sequence, but we want to do these things (matches AppKit).
3214 #if PLATFORM(IOS_FAMILY)
3215     // FIXME: Should suppress selection change notifications during a composition change &lt;https://webkit.org/b/38830&gt;
3216     if (m_ignoreSelectionChanges)
3217         return;
3218 #endif
3219     if (selectionDidNotChangeDOMPosition &amp;&amp; client())
3220         client()-&gt;respondToChangedSelection(&amp;m_frame);
3221 }
3222 
3223 String Editor::selectedText() const
3224 {
3225     TextIteratorBehavior behavior = TextIteratorDefaultBehavior;
3226     if (m_frame.settings().selectionAcrossShadowBoundariesEnabled())
3227         behavior |= TextIteratorTraversesFlatTree;
3228     return selectedText(behavior);
3229 }
3230 
3231 String Editor::selectedTextForDataTransfer() const
3232 {
3233     TextIteratorBehavior behavior = TextIteratorEmitsImageAltText;
3234     if (m_frame.settings().selectionAcrossShadowBoundariesEnabled())
3235         behavior |= TextIteratorTraversesFlatTree;
3236     return selectedText(behavior);
3237 }
3238 
3239 String Editor::selectedText(TextIteratorBehavior behavior) const
3240 {
3241     // We remove &#39;\0&#39; characters because they are not visibly rendered to the user.
3242     auto&amp; selection = m_frame.selection().selection();
3243     return plainText(selection.start(), selection.end(), behavior).replaceWithLiteral(&#39;\0&#39;, &quot;&quot;);
3244 }
3245 
3246 static inline void collapseCaretWidth(IntRect&amp; rect)
3247 {
3248     // FIXME: Width adjustment doesn&#39;t work for rotated text.
3249     if (rect.width() == caretWidth)
3250         rect.setWidth(0);
3251     else if (rect.height() == caretWidth)
3252         rect.setHeight(0);
3253 }
3254 
3255 IntRect Editor::firstRectForRange(Range* range) const
3256 {
3257     VisiblePosition startVisiblePosition(range-&gt;startPosition(), DOWNSTREAM);
3258 
3259     if (range-&gt;collapsed()) {
3260         // FIXME: Getting caret rect and removing caret width is a very roundabout way to get collapsed range location.
3261         // In particular, width adjustment doesn&#39;t work for rotated text.
3262         IntRect startCaretRect = RenderedPosition(startVisiblePosition).absoluteRect();
3263         collapseCaretWidth(startCaretRect);
3264         return startCaretRect;
3265     }
3266 
3267     VisiblePosition endVisiblePosition(range-&gt;endPosition(), UPSTREAM);
3268 
3269     if (inSameLine(startVisiblePosition, endVisiblePosition))
3270         return enclosingIntRect(RenderObject::absoluteBoundingBoxRectForRange(range));
3271 
3272     LayoutUnit extraWidthToEndOfLine;
3273     IntRect startCaretRect = RenderedPosition(startVisiblePosition).absoluteRect(&amp;extraWidthToEndOfLine);
3274     if (startCaretRect == IntRect())
3275         return IntRect();
3276 
3277     // When start and end aren&#39;t on the same line, we want to go from start to the end of its line.
3278     bool textIsHorizontal = startCaretRect.width() == caretWidth;
3279     return textIsHorizontal ?
3280         IntRect(startCaretRect.x(),
3281             startCaretRect.y(),
3282             startCaretRect.width() + extraWidthToEndOfLine,
3283             startCaretRect.height()) :
3284         IntRect(startCaretRect.x(),
3285             startCaretRect.y(),
3286             startCaretRect.width(),
3287             startCaretRect.height() + extraWidthToEndOfLine);
3288 }
3289 
3290 bool Editor::shouldChangeSelection(const VisibleSelection&amp; oldSelection, const VisibleSelection&amp; newSelection, EAffinity affinity, bool stillSelecting) const
3291 {
3292 #if PLATFORM(IOS_FAMILY)
3293     if (m_frame.selectionChangeCallbacksDisabled())
3294         return true;
3295 #endif
3296     return client() &amp;&amp; client()-&gt;shouldChangeSelectedRange(oldSelection.toNormalizedRange().get(), newSelection.toNormalizedRange().get(), affinity, stillSelecting);
3297 }
3298 
3299 void Editor::computeAndSetTypingStyle(EditingStyle&amp; style, EditAction editingAction)
3300 {
3301     if (style.isEmpty()) {
3302         m_frame.selection().clearTypingStyle();
3303         return;
3304     }
3305 
3306     // Calculate the current typing style.
3307     RefPtr&lt;EditingStyle&gt; typingStyle;
3308     if (auto existingTypingStyle = m_frame.selection().typingStyle())
3309         typingStyle = existingTypingStyle-&gt;copy();
3310     else
3311         typingStyle = EditingStyle::create();
3312     typingStyle-&gt;overrideTypingStyleAt(style, m_frame.selection().selection().visibleStart().deepEquivalent());
3313 
3314     // Handle block styles, substracting these from the typing style.
3315     RefPtr&lt;EditingStyle&gt; blockStyle = typingStyle-&gt;extractAndRemoveBlockProperties();
3316     if (!blockStyle-&gt;isEmpty())
3317         ApplyStyleCommand::create(document(), blockStyle.get(), editingAction)-&gt;apply();
3318 
3319     // Set the remaining style as the typing style.
3320     m_frame.selection().setTypingStyle(WTFMove(typingStyle));
3321 }
3322 
3323 void Editor::computeAndSetTypingStyle(StyleProperties&amp; properties, EditAction editingAction)
3324 {
3325     return computeAndSetTypingStyle(EditingStyle::create(&amp;properties), editingAction);
3326 }
3327 
3328 void Editor::textFieldDidBeginEditing(Element* e)
3329 {
3330     if (client())
3331         client()-&gt;textFieldDidBeginEditing(e);
3332 }
3333 
3334 void Editor::textFieldDidEndEditing(Element* e)
3335 {
3336     dismissCorrectionPanelAsIgnored();
3337     if (client())
3338         client()-&gt;textFieldDidEndEditing(e);
3339 }
3340 
3341 void Editor::textDidChangeInTextField(Element* e)
3342 {
3343     if (client())
3344         client()-&gt;textDidChangeInTextField(e);
3345 }
3346 
3347 bool Editor::doTextFieldCommandFromEvent(Element* e, KeyboardEvent* ke)
3348 {
3349     if (client())
3350         return client()-&gt;doTextFieldCommandFromEvent(e, ke);
3351 
3352     return false;
3353 }
3354 
3355 void Editor::textWillBeDeletedInTextField(Element* input)
3356 {
3357     if (client())
3358         client()-&gt;textWillBeDeletedInTextField(input);
3359 }
3360 
3361 void Editor::textDidChangeInTextArea(Element* e)
3362 {
3363     if (client())
3364         client()-&gt;textDidChangeInTextArea(e);
3365 }
3366 
3367 void Editor::applyEditingStyleToBodyElement() const
3368 {
3369     auto collection = document().getElementsByTagName(HTMLNames::bodyTag-&gt;localName());
3370     unsigned length = collection-&gt;length();
3371     for (unsigned i = 0; i &lt; length; ++i)
3372         applyEditingStyleToElement(collection-&gt;item(i));
3373 }
3374 
3375 void Editor::applyEditingStyleToElement(Element* element) const
3376 {
3377     ASSERT(!element || is&lt;StyledElement&gt;(*element));
3378     if (!is&lt;StyledElement&gt;(element))
3379         return;
3380 
3381     // Mutate using the CSSOM wrapper so we get the same event behavior as a script.
3382     auto&amp; style = downcast&lt;StyledElement&gt;(*element).cssomStyle();
3383     style.setPropertyInternal(CSSPropertyWordWrap, &quot;break-word&quot;, false);
3384     style.setPropertyInternal(CSSPropertyWebkitNbspMode, &quot;space&quot;, false);
3385     style.setPropertyInternal(CSSPropertyLineBreak, &quot;after-white-space&quot;, false);
3386 }
3387 
3388 bool Editor::findString(const String&amp; target, FindOptions options)
3389 {
3390     Ref&lt;Frame&gt; protection(m_frame);
3391 
3392     VisibleSelection selection = m_frame.selection().selection();
3393 
3394     RefPtr&lt;Range&gt; resultRange = rangeOfString(target, selection.firstRange().get(), options);
3395 
3396     if (!resultRange)
3397         return false;
3398 
3399     m_frame.selection().setSelection(VisibleSelection(*resultRange, DOWNSTREAM));
3400 
3401     if (!(options.contains(DoNotRevealSelection)))
3402         m_frame.selection().revealSelection();
3403 
3404     return true;
3405 }
3406 
3407 RefPtr&lt;Range&gt; Editor::rangeOfString(const String&amp; target, Range* referenceRange, FindOptions options)
3408 {
3409     if (target.isEmpty())
3410         return nullptr;
3411 
3412     // Start from an edge of the reference range, if there&#39;s a reference range that&#39;s not in shadow content. Which edge
3413     // is used depends on whether we&#39;re searching forward or backward, and whether startInSelection is set.
3414     RefPtr&lt;Range&gt; searchRange(rangeOfContents(document()));
3415 
3416     bool forward = !options.contains(Backwards);
3417     bool startInReferenceRange = referenceRange &amp;&amp; options.contains(StartInSelection);
3418     if (referenceRange) {
3419         if (forward)
3420             searchRange-&gt;setStart(startInReferenceRange ? referenceRange-&gt;startPosition() : referenceRange-&gt;endPosition());
3421         else
3422             searchRange-&gt;setEnd(startInReferenceRange ? referenceRange-&gt;endPosition() : referenceRange-&gt;startPosition());
3423     }
3424 
3425     RefPtr&lt;ShadowRoot&gt; shadowTreeRoot = referenceRange ? referenceRange-&gt;startContainer().containingShadowRoot() : nullptr;
3426     if (shadowTreeRoot) {
3427         if (forward)
3428             searchRange-&gt;setEnd(*shadowTreeRoot, shadowTreeRoot-&gt;countChildNodes());
3429         else
3430             searchRange-&gt;setStart(*shadowTreeRoot, 0);
3431     }
3432 
3433     RefPtr&lt;Range&gt; resultRange = findPlainText(*searchRange, target, options);
3434     // If we started in the reference range and the found range exactly matches the reference range, find again.
3435     // Build a selection with the found range to remove collapsed whitespace.
3436     // Compare ranges instead of selection objects to ignore the way that the current selection was made.
3437     if (startInReferenceRange &amp;&amp; areRangesEqual(VisibleSelection(*resultRange).toNormalizedRange().get(), referenceRange)) {
3438         searchRange = rangeOfContents(document());
3439         if (forward)
3440             searchRange-&gt;setStart(referenceRange-&gt;endPosition());
3441         else
3442             searchRange-&gt;setEnd(referenceRange-&gt;startPosition());
3443 
3444         if (shadowTreeRoot) {
3445             if (forward)
3446                 searchRange-&gt;setEnd(*shadowTreeRoot, shadowTreeRoot-&gt;countChildNodes());
3447             else
3448                 searchRange-&gt;setStart(*shadowTreeRoot, 0);
3449         }
3450 
3451         resultRange = findPlainText(*searchRange, target, options);
3452     }
3453 
3454     // If nothing was found in the shadow tree, search in main content following the shadow tree.
3455     if (resultRange-&gt;collapsed() &amp;&amp; shadowTreeRoot) {
3456         searchRange = rangeOfContents(document());
3457         if (shadowTreeRoot-&gt;shadowHost()) {
3458             if (forward)
3459                 searchRange-&gt;setStartAfter(*shadowTreeRoot-&gt;shadowHost());
3460             else
3461                 searchRange-&gt;setEndBefore(*shadowTreeRoot-&gt;shadowHost());
3462         }
3463 
3464         resultRange = findPlainText(*searchRange, target, options);
3465     }
3466 
3467     // If we didn&#39;t find anything and we&#39;re wrapping, search again in the entire document (this will
3468     // redundantly re-search the area already searched in some cases).
3469     if (resultRange-&gt;collapsed() &amp;&amp; options.contains(WrapAround)) {
3470         searchRange = rangeOfContents(document());
3471         resultRange = findPlainText(*searchRange, target, options);
3472         // We used to return false here if we ended up with the same range that we started with
3473         // (e.g., the reference range was already the only instance of this text). But we decided that
3474         // this should be a success case instead, so we&#39;ll just fall through in that case.
3475     }
3476 
3477     return resultRange-&gt;collapsed() ? nullptr : resultRange;
3478 }
3479 
3480 static bool isFrameInRange(Frame&amp; frame, Range&amp; range)
3481 {
3482     for (auto* ownerElement = frame.ownerElement(); ownerElement; ownerElement = ownerElement-&gt;document().ownerElement()) {
3483         if (&amp;ownerElement-&gt;document() == &amp;range.ownerDocument()) {
3484             auto result = range.intersectsNode(*ownerElement);
3485             return !result.hasException() &amp;&amp; result.releaseReturnValue();
3486         }
3487     }
3488     return false;
3489 }
3490 
3491 unsigned Editor::countMatchesForText(const String&amp; target, Range* range, FindOptions options, unsigned limit, bool markMatches, Vector&lt;RefPtr&lt;Range&gt;&gt;* matches)
3492 {
3493     if (target.isEmpty())
3494         return 0;
3495 
3496     RefPtr&lt;Range&gt; searchRange;
3497     if (range) {
3498         if (&amp;range-&gt;ownerDocument() == &amp;document())
3499             searchRange = range;
3500         else if (!isFrameInRange(m_frame, *range))
3501             return 0;
3502     }
3503     if (!searchRange)
3504         searchRange = rangeOfContents(document());
3505 
3506     Node&amp; originalEndContainer = searchRange-&gt;endContainer();
3507     int originalEndOffset = searchRange-&gt;endOffset();
3508 
3509     unsigned matchCount = 0;
3510     do {
3511         auto resultRange = findPlainText(*searchRange, target, options - Backwards);
3512         if (resultRange-&gt;collapsed()) {
3513             if (!resultRange-&gt;startContainer().isInShadowTree())
3514                 break;
3515 
3516             searchRange-&gt;setStartAfter(*resultRange-&gt;startContainer().shadowHost());
3517             searchRange-&gt;setEnd(originalEndContainer, originalEndOffset);
3518             continue;
3519         }
3520 
3521         ++matchCount;
3522         if (matches)
3523             matches-&gt;append(resultRange.ptr());
3524 
3525         if (markMatches)
3526             document().markers().addMarker(resultRange, DocumentMarker::TextMatch);
3527 
3528         // Stop looking if we hit the specified limit. A limit of 0 means no limit.
3529         if (limit &gt; 0 &amp;&amp; matchCount &gt;= limit)
3530             break;
3531 
3532         // Set the new start for the search range to be the end of the previous
3533         // result range. There is no need to use a VisiblePosition here,
3534         // since findPlainText will use a TextIterator to go over the visible
3535         // text nodes.
3536         searchRange-&gt;setStart(resultRange-&gt;endContainer(), resultRange-&gt;endOffset());
3537 
3538         Node* shadowTreeRoot = searchRange-&gt;shadowRoot();
3539         if (searchRange-&gt;collapsed() &amp;&amp; shadowTreeRoot)
3540             searchRange-&gt;setEnd(*shadowTreeRoot, shadowTreeRoot-&gt;countChildNodes());
3541     } while (true);
3542 
3543     return matchCount;
3544 }
3545 
3546 void Editor::setMarkedTextMatchesAreHighlighted(bool flag)
3547 {
3548     if (flag == m_areMarkedTextMatchesHighlighted)
3549         return;
3550 
3551     m_areMarkedTextMatchesHighlighted = flag;
3552     document().markers().repaintMarkers(DocumentMarker::TextMatch);
3553 }
3554 
3555 #if !PLATFORM(MAC)
3556 void Editor::selectionWillChange()
3557 {
3558 }
3559 #endif
3560 
3561 void Editor::respondToChangedSelection(const VisibleSelection&amp;, OptionSet&lt;FrameSelection::SetSelectionOption&gt; options)
3562 {
3563 #if PLATFORM(IOS_FAMILY)
3564     // FIXME: Should suppress selection change notifications during a composition change &lt;https://webkit.org/b/38830&gt;
3565     if (m_ignoreSelectionChanges)
3566         return;
3567 #endif
3568 
3569     if (client())
3570         client()-&gt;respondToChangedSelection(&amp;m_frame);
3571 
3572 #if ENABLE(TELEPHONE_NUMBER_DETECTION) &amp;&amp; !PLATFORM(IOS_FAMILY)
3573     if (shouldDetectTelephoneNumbers())
3574         m_telephoneNumberDetectionUpdateTimer.startOneShot(0_s);
3575 #endif
3576 
3577     setStartNewKillRingSequence(true);
3578 
3579     if (m_editorUIUpdateTimer.isActive())
3580         return;
3581 
3582     // Don&#39;t check spelling and grammar if the change of selection is triggered by spelling correction itself.
3583     m_editorUIUpdateTimerShouldCheckSpellingAndGrammar = options.contains(FrameSelection::CloseTyping) &amp;&amp; !options.contains(FrameSelection::SpellCorrectionTriggered);
3584     m_editorUIUpdateTimerWasTriggeredByDictation = options.contains(FrameSelection::DictationTriggered);
3585     scheduleEditorUIUpdate();
3586 }
3587 
3588 #if ENABLE(TELEPHONE_NUMBER_DETECTION) &amp;&amp; !PLATFORM(IOS_FAMILY)
3589 
3590 bool Editor::shouldDetectTelephoneNumbers()
3591 {
3592     if (!m_frame.document())
3593         return false;
3594     return document().isTelephoneNumberParsingEnabled() &amp;&amp; TelephoneNumberDetector::isSupported();
3595 }
3596 
3597 void Editor::scanSelectionForTelephoneNumbers()
3598 {
3599     if (!shouldDetectTelephoneNumbers() || !client())
3600         return;
3601 
3602     m_detectedTelephoneNumberRanges.clear();
3603 
3604     Vector&lt;RefPtr&lt;Range&gt;&gt; markedRanges;
3605 
3606     FrameSelection&amp; frameSelection = m_frame.selection();
3607     if (!frameSelection.isRange()) {
3608         if (auto* page = m_frame.page())
3609             page-&gt;servicesOverlayController().selectedTelephoneNumberRangesChanged();
3610         return;
3611     }
3612     RefPtr&lt;Range&gt; selectedRange = frameSelection.toNormalizedRange();
3613 
3614     // Extend the range a few characters in each direction to detect incompletely selected phone numbers.
3615     static const int charactersToExtend = 15;
3616     const VisibleSelection&amp; visibleSelection = frameSelection.selection();
3617     Position start = visibleSelection.start();
3618     Position end = visibleSelection.end();
3619     for (int i = 0; i &lt; charactersToExtend; ++i) {
3620         start = start.previous(Character);
3621         end = end.next(Character);
3622     }
3623 
3624     FrameSelection extendedSelection;
3625     extendedSelection.setStart(start);
3626     extendedSelection.setEnd(end);
3627     RefPtr&lt;Range&gt; extendedRange = extendedSelection.toNormalizedRange();
3628 
3629     if (!extendedRange) {
3630         if (auto* page = m_frame.page())
3631             page-&gt;servicesOverlayController().selectedTelephoneNumberRangesChanged();
3632         return;
3633     }
3634 
3635     scanRangeForTelephoneNumbers(*extendedRange, extendedRange-&gt;text(), markedRanges);
3636 
3637     // Only consider ranges with a detected telephone number if they overlap with the actual selection range.
3638     for (auto&amp; range : markedRanges) {
3639         if (rangesOverlap(range.get(), selectedRange.get()))
3640             m_detectedTelephoneNumberRanges.append(range);
3641     }
3642 
3643     if (auto* page = m_frame.page())
3644         page-&gt;servicesOverlayController().selectedTelephoneNumberRangesChanged();
3645 }
3646 
3647 void Editor::scanRangeForTelephoneNumbers(Range&amp; range, const StringView&amp; stringView, Vector&lt;RefPtr&lt;Range&gt;&gt;&amp; markedRanges)
3648 {
3649     // Don&#39;t scan for phone numbers inside editable regions.
3650     Node&amp; startNode = range.startContainer();
3651     if (startNode.hasEditableStyle())
3652         return;
3653 
3654     // relativeStartPosition and relativeEndPosition are the endpoints of the phone number range,
3655     // relative to the scannerPosition
3656     unsigned length = stringView.length();
3657     unsigned scannerPosition = 0;
3658     int relativeStartPosition = 0;
3659     int relativeEndPosition = 0;
3660 
3661     auto characters = stringView.upconvertedCharacters();
3662 
3663     while (scannerPosition &lt; length &amp;&amp; TelephoneNumberDetector::find(&amp;characters[scannerPosition], length - scannerPosition, &amp;relativeStartPosition, &amp;relativeEndPosition)) {
3664         // The convention in the Data Detectors framework is that the end position is the first character NOT in the phone number
3665         // (that is, the length of the range is relativeEndPosition - relativeStartPosition). So subtract 1 to get the same
3666         // convention as the old WebCore phone number parser (so that the rest of the code is still valid if we want to go back
3667         // to the old parser).
3668         --relativeEndPosition;
3669 
3670         ASSERT(scannerPosition + relativeEndPosition &lt; length);
3671 
3672         unsigned subrangeOffset = scannerPosition + relativeStartPosition;
3673         unsigned subrangeLength = relativeEndPosition - relativeStartPosition + 1;
3674 
3675         auto subrange = TextIterator::subrange(range, subrangeOffset, subrangeLength);
3676 
3677         markedRanges.append(subrange.ptr());
3678         range.ownerDocument().markers().addMarker(subrange, DocumentMarker::TelephoneNumber);
3679 
3680         scannerPosition += relativeEndPosition + 1;
3681     }
3682 }
3683 
3684 #endif // ENABLE(TELEPHONE_NUMBER_DETECTION) &amp;&amp; !PLATFORM(IOS_FAMILY)
3685 
3686 void Editor::updateEditorUINowIfScheduled()
3687 {
3688     if (!m_editorUIUpdateTimer.isActive())
3689         return;
3690     m_editorUIUpdateTimer.stop();
3691     editorUIUpdateTimerFired();
3692 }
3693 
3694 void Editor::editorUIUpdateTimerFired()
3695 {
3696     VisibleSelection oldSelection = m_oldSelectionForEditorUIUpdate;
3697 
3698     m_alternativeTextController-&gt;stopPendingCorrection(oldSelection);
3699 
3700     bool isContinuousSpellCheckingEnabled = this-&gt;isContinuousSpellCheckingEnabled();
3701     bool isContinuousGrammarCheckingEnabled = isContinuousSpellCheckingEnabled &amp;&amp; isGrammarCheckingEnabled();
3702     if (isContinuousSpellCheckingEnabled) {
3703         VisibleSelection newAdjacentWords;
3704         VisibleSelection newSelectedSentence;
3705         bool caretBrowsing = m_frame.settings().caretBrowsingEnabled();
3706         if (m_frame.selection().selection().isContentEditable() || caretBrowsing) {
3707             VisiblePosition newStart(m_frame.selection().selection().visibleStart());
3708 #if !PLATFORM(IOS_FAMILY)
3709             newAdjacentWords = VisibleSelection(startOfWord(newStart, LeftWordIfOnBoundary), endOfWord(newStart, RightWordIfOnBoundary));
3710 #else
3711             // If this bug gets fixed, this PLATFORM(IOS_FAMILY) code could be removed:
3712             // &lt;rdar://problem/7259611&gt; Word boundary code on iPhone gives different results than desktop
3713             EWordSide startWordSide = LeftWordIfOnBoundary;
3714             UChar32 c = newStart.characterBefore();
3715             // FIXME: VisiblePosition::characterAfter() and characterBefore() do not emit newlines the same
3716             // way as TextIterator, so we do an isStartOfParagraph check here.
3717             if (isSpaceOrNewline(c) || c == noBreakSpace || isStartOfParagraph(newStart)) {
3718                 startWordSide = RightWordIfOnBoundary;
3719             }
3720             newAdjacentWords = VisibleSelection(startOfWord(newStart, startWordSide), endOfWord(newStart, RightWordIfOnBoundary));
3721 #endif // !PLATFORM(IOS_FAMILY)
3722             if (isContinuousGrammarCheckingEnabled)
3723                 newSelectedSentence = VisibleSelection(startOfSentence(newStart), endOfSentence(newStart));
3724         }
3725 
3726         // When typing we check spelling elsewhere, so don&#39;t redo it here.
3727         // If this is a change in selection resulting from a delete operation,
3728         // oldSelection may no longer be in the document.
3729         if (m_editorUIUpdateTimerShouldCheckSpellingAndGrammar &amp;&amp; oldSelection.isContentEditable() &amp;&amp; oldSelection.start().deprecatedNode() &amp;&amp; oldSelection.start().anchorNode()-&gt;isConnected()) {
3730             VisiblePosition oldStart(oldSelection.visibleStart());
3731             VisibleSelection oldAdjacentWords = VisibleSelection(startOfWord(oldStart, LeftWordIfOnBoundary), endOfWord(oldStart, RightWordIfOnBoundary));
3732             if (oldAdjacentWords != newAdjacentWords) {
3733                 if (isContinuousGrammarCheckingEnabled) {
3734                     VisibleSelection oldSelectedSentence = VisibleSelection(startOfSentence(oldStart), endOfSentence(oldStart));
3735                     markMisspellingsAndBadGrammar(oldAdjacentWords, oldSelectedSentence != newSelectedSentence, oldSelectedSentence);
3736                 } else
3737                     markMisspellingsAndBadGrammar(oldAdjacentWords, false, oldAdjacentWords);
3738             }
3739         }
3740 
3741         if (!textChecker() || textChecker()-&gt;shouldEraseMarkersAfterChangeSelection(TextCheckingType::Spelling)) {
3742             if (RefPtr&lt;Range&gt; wordRange = newAdjacentWords.toNormalizedRange())
3743                 document().markers().removeMarkers(*wordRange, DocumentMarker::Spelling);
3744         }
3745         if (!textChecker() || textChecker()-&gt;shouldEraseMarkersAfterChangeSelection(TextCheckingType::Grammar)) {
3746             if (RefPtr&lt;Range&gt; sentenceRange = newSelectedSentence.toNormalizedRange())
3747                 document().markers().removeMarkers(*sentenceRange, DocumentMarker::Grammar);
3748         }
3749     }
3750 
3751     // When continuous spell checking is off, existing markers disappear after the selection changes.
3752     if (!isContinuousSpellCheckingEnabled)
3753         document().markers().removeMarkers(DocumentMarker::Spelling);
3754     if (!isContinuousGrammarCheckingEnabled)
3755         document().markers().removeMarkers(DocumentMarker::Grammar);
3756 
3757     if (!m_editorUIUpdateTimerWasTriggeredByDictation)
3758         m_alternativeTextController-&gt;respondToChangedSelection(oldSelection);
3759 
3760     m_oldSelectionForEditorUIUpdate = m_frame.selection().selection();
3761 
3762 #if ENABLE(ATTACHMENT_ELEMENT)
3763     notifyClientOfAttachmentUpdates();
3764 #endif
3765 }
3766 
3767 static Node* findFirstMarkable(Node* node)
3768 {
3769     while (node) {
3770         if (!node-&gt;renderer())
3771             return nullptr;
3772         if (node-&gt;renderer()-&gt;isTextOrLineBreak())
3773             return node;
3774         if (is&lt;Element&gt;(*node) &amp;&amp; downcast&lt;Element&gt;(*node).isTextField())
3775             node = downcast&lt;HTMLTextFormControlElement&gt;(*node).visiblePositionForIndex(1).deepEquivalent().deprecatedNode();
3776         else if (node-&gt;firstChild())
3777             node = node-&gt;firstChild();
3778         else
3779             node = node-&gt;nextSibling();
3780     }
3781 
3782     return nullptr;
3783 }
3784 
3785 bool Editor::selectionStartHasMarkerFor(DocumentMarker::MarkerType markerType, int from, int length) const
3786 {
3787     Node* node = findFirstMarkable(m_frame.selection().selection().start().deprecatedNode());
3788     if (!node)
3789         return false;
3790 
3791     unsigned int startOffset = static_cast&lt;unsigned int&gt;(from);
3792     unsigned int endOffset = static_cast&lt;unsigned int&gt;(from + length);
3793     Vector&lt;RenderedDocumentMarker*&gt; markers = document().markers().markersFor(*node);
3794     for (auto* marker : markers) {
3795         if (marker-&gt;startOffset() &lt;= startOffset &amp;&amp; endOffset &lt;= marker-&gt;endOffset() &amp;&amp; marker-&gt;type() == markerType)
3796             return true;
3797     }
3798 
3799     return false;
3800 }
3801 
3802 OptionSet&lt;TextCheckingType&gt; Editor::resolveTextCheckingTypeMask(const Node&amp; rootEditableElement, OptionSet&lt;TextCheckingType&gt; textCheckingOptions)
3803 {
3804 #if USE(AUTOMATIC_TEXT_REPLACEMENT) &amp;&amp; !PLATFORM(IOS_FAMILY)
3805     bool onlyAllowsTextReplacement = false;
3806     if (auto* host = rootEditableElement.shadowHost())
3807         onlyAllowsTextReplacement = is&lt;HTMLInputElement&gt;(host) &amp;&amp; downcast&lt;HTMLInputElement&gt;(*host).isSpellcheckDisabledExceptTextReplacement();
3808     if (onlyAllowsTextReplacement)
3809         textCheckingOptions = textCheckingOptions &amp; TextCheckingType::Replacement;
3810 #else
3811     UNUSED_PARAM(rootEditableElement);
3812 #endif
3813 
3814     bool shouldMarkSpelling = textCheckingOptions.contains(TextCheckingType::Spelling);
3815     bool shouldMarkGrammar = textCheckingOptions.contains(TextCheckingType::Grammar);
3816 #if !PLATFORM(IOS_FAMILY)
3817     bool shouldShowCorrectionPanel = textCheckingOptions.contains(TextCheckingType::ShowCorrectionPanel);
3818     bool shouldCheckForCorrection = shouldShowCorrectionPanel || textCheckingOptions.contains(TextCheckingType::Correction);
3819 #endif
3820 
3821     OptionSet&lt;TextCheckingType&gt; checkingTypes;
3822     if (shouldMarkSpelling)
3823         checkingTypes.add(TextCheckingType::Spelling);
3824     if (shouldMarkGrammar)
3825         checkingTypes.add(TextCheckingType::Grammar);
3826 #if !PLATFORM(IOS_FAMILY)
3827     if (shouldCheckForCorrection)
3828         checkingTypes.add(TextCheckingType::Correction);
3829     if (shouldShowCorrectionPanel)
3830         checkingTypes.add(TextCheckingType::ShowCorrectionPanel);
3831 
3832 #if USE(AUTOMATIC_TEXT_REPLACEMENT)
3833     bool shouldPerformReplacement = textCheckingOptions.contains(TextCheckingType::Replacement);
3834     if (shouldPerformReplacement) {
3835         if (!onlyAllowsTextReplacement) {
3836             if (isAutomaticLinkDetectionEnabled())
3837                 checkingTypes.add(TextCheckingType::Link);
3838             if (isAutomaticQuoteSubstitutionEnabled())
3839                 checkingTypes.add(TextCheckingType::Quote);
3840             if (isAutomaticDashSubstitutionEnabled())
3841                 checkingTypes.add(TextCheckingType::Dash);
3842             if (shouldMarkSpelling &amp;&amp; isAutomaticSpellingCorrectionEnabled())
3843                 checkingTypes.add(TextCheckingType::Correction);
3844         }
3845         if (isAutomaticTextReplacementEnabled())
3846             checkingTypes.add(TextCheckingType::Replacement);
3847     }
3848 #endif
3849 #endif // !PLATFORM(IOS_FAMILY)
3850 
3851     return checkingTypes;
3852 }
3853 
3854 static RefPtr&lt;Range&gt; candidateRangeForSelection(Frame&amp; frame)
3855 {
3856     const VisibleSelection&amp; selection = frame.selection().selection();
3857     return selection.isCaret() ? wordRangeFromPosition(selection.start()) : frame.selection().toNormalizedRange();
3858 }
3859 
3860 static bool candidateWouldReplaceText(const VisibleSelection&amp; selection)
3861 {
3862     // If the character behind the caret in the current selection is anything but a space or a newline then we should
3863     // replace the whole current word with the candidate.
3864     UChar32 characterAfterSelection, characterBeforeSelection, twoCharacterBeforeSelection = 0;
3865     charactersAroundPosition(selection.visibleStart(), characterAfterSelection, characterBeforeSelection, twoCharacterBeforeSelection);
3866     return !(characterBeforeSelection == &#39;\0&#39; || characterBeforeSelection == &#39;\n&#39; || characterBeforeSelection == &#39; &#39;);
3867 }
3868 
3869 String Editor::stringForCandidateRequest() const
3870 {
3871     const VisibleSelection&amp; selection = m_frame.selection().selection();
3872     RefPtr&lt;Range&gt; rangeForCurrentlyTypedString = candidateRangeForSelection(m_frame);
3873     if (rangeForCurrentlyTypedString &amp;&amp; candidateWouldReplaceText(selection))
3874         return plainText(rangeForCurrentlyTypedString.get());
3875 
3876     return String();
3877 }
3878 
3879 RefPtr&lt;Range&gt; Editor::contextRangeForCandidateRequest() const
3880 {
3881     const VisibleSelection&amp; selection = m_frame.selection().selection();
3882     return makeRange(startOfParagraph(selection.visibleStart()), endOfParagraph(selection.visibleEnd()));
3883 }
3884 
3885 RefPtr&lt;Range&gt; Editor::rangeForTextCheckingResult(const TextCheckingResult&amp; result) const
3886 {
3887     if (!result.length)
3888         return nullptr;
3889 
3890     RefPtr&lt;Range&gt; contextRange = contextRangeForCandidateRequest();
3891     if (!contextRange)
3892         return nullptr;
3893 
3894     return TextIterator::subrange(*contextRange, result.location, result.length);
3895 }
3896 
3897 void Editor::scheduleEditorUIUpdate()
3898 {
3899     m_editorUIUpdateTimer.startOneShot(0_s);
3900 }
3901 
3902 #if !PLATFORM(COCOA)
3903 
3904 void Editor::platformFontAttributesAtSelectionStart(FontAttributes&amp;, const RenderStyle&amp;) const
3905 {
3906 }
3907 
3908 #endif
3909 
3910 static Vector&lt;TextList&gt; editableTextListsAtPositionInDescendingOrder(const Position&amp; position)
3911 {
3912     auto startContainer = makeRefPtr(position.containerNode());
3913     if (!startContainer)
3914         return { };
3915 
3916     auto* editableRoot = highestEditableRoot(firstPositionInOrBeforeNode(startContainer.get()));
3917     if (!editableRoot)
3918         return { };
3919 
3920     Vector&lt;Ref&lt;HTMLElement&gt;&gt; enclosingLists;
3921     for (auto&amp; ancestor : ancestorsOfType&lt;HTMLElement&gt;(*startContainer)) {
3922         if (&amp;ancestor == editableRoot)
3923             break;
3924 
3925         auto* renderer = ancestor.renderer();
3926         if (!renderer)
3927             continue;
3928 
3929         if (is&lt;HTMLUListElement&gt;(ancestor) || is&lt;HTMLOListElement&gt;(ancestor))
3930             enclosingLists.append(ancestor);
3931     }
3932 
3933     Vector&lt;TextList&gt; textLists;
3934     textLists.reserveCapacity(enclosingLists.size());
3935     for (auto iterator = enclosingLists.rbegin(); iterator != enclosingLists.rend(); ++iterator) {
3936         auto&amp; list = iterator-&gt;get();
3937         bool ordered = is&lt;HTMLOListElement&gt;(list);
3938         textLists.uncheckedAppend({ list.renderer()-&gt;style().listStyleType(), ordered ? downcast&lt;HTMLOListElement&gt;(list).start() : 1, ordered });
3939     }
3940 
3941     return textLists;
3942 }
3943 
3944 FontAttributes Editor::fontAttributesAtSelectionStart() const
3945 {
3946     FontAttributes attributes;
3947     Node* nodeToRemove = nullptr;
3948     auto* style = styleForSelectionStart(&amp;m_frame, nodeToRemove);
3949     if (!style) {
3950         if (nodeToRemove)
3951             nodeToRemove-&gt;remove();
3952         return attributes;
3953     }
3954 
3955     platformFontAttributesAtSelectionStart(attributes, *style);
3956 
3957     // FIXME: for now, always report the colors after applying -apple-color-filter. In future not all clients
3958     // may want this, so we may have to add a setting to control it. See also editingAttributedStringFromRange().
3959     auto backgroundColor = style-&gt;visitedDependentColorWithColorFilter(CSSPropertyBackgroundColor);
3960     if (backgroundColor.isVisible())
3961         attributes.backgroundColor = backgroundColor;
3962 
3963     auto foregroundColor = style-&gt;visitedDependentColorWithColorFilter(CSSPropertyColor);
3964     // FIXME: isBlackColor not suitable for dark mode.
3965     if (foregroundColor.isValid() &amp;&amp; !Color::isBlackColor(foregroundColor))
3966         attributes.foregroundColor = foregroundColor;
3967 
3968     if (auto* shadowData = style-&gt;textShadow())
3969         attributes.fontShadow = { shadowData-&gt;color(), { static_cast&lt;float&gt;(shadowData-&gt;x()), static_cast&lt;float&gt;(shadowData-&gt;y()) }, static_cast&lt;double&gt;(shadowData-&gt;radius()) };
3970 
3971     switch (style-&gt;verticalAlign()) {
3972     case VerticalAlign::Baseline:
3973     case VerticalAlign::Bottom:
3974     case VerticalAlign::BaselineMiddle:
3975     case VerticalAlign::Length:
3976     case VerticalAlign::Middle:
3977     case VerticalAlign::TextBottom:
3978     case VerticalAlign::TextTop:
3979     case VerticalAlign::Top:
3980         break;
3981     case VerticalAlign::Sub:
3982         attributes.subscriptOrSuperscript = FontAttributes::SubscriptOrSuperscript::Subscript;
3983         break;
3984     case VerticalAlign::Super:
3985         attributes.subscriptOrSuperscript = FontAttributes::SubscriptOrSuperscript::Superscript;
3986         break;
3987     }
3988 
3989     attributes.textLists = editableTextListsAtPositionInDescendingOrder(m_frame.selection().selection().start());
3990 
3991     switch (style-&gt;textAlign()) {
3992     case TextAlignMode::Right:
3993     case TextAlignMode::WebKitRight:
3994         attributes.horizontalAlignment = FontAttributes::HorizontalAlignment::Right;
3995         break;
3996     case TextAlignMode::Left:
3997     case TextAlignMode::WebKitLeft:
3998         attributes.horizontalAlignment = FontAttributes::HorizontalAlignment::Left;
3999         break;
4000     case TextAlignMode::Center:
4001     case TextAlignMode::WebKitCenter:
4002         attributes.horizontalAlignment = FontAttributes::HorizontalAlignment::Center;
4003         break;
4004     case TextAlignMode::Justify:
4005         attributes.horizontalAlignment = FontAttributes::HorizontalAlignment::Justify;
4006         break;
4007     case TextAlignMode::Start:
4008         attributes.horizontalAlignment = FontAttributes::HorizontalAlignment::Natural;
4009         break;
4010     case TextAlignMode::End:
4011         attributes.horizontalAlignment = style-&gt;isLeftToRightDirection() ? FontAttributes::HorizontalAlignment::Right : FontAttributes::HorizontalAlignment::Left;
4012         break;
4013     }
4014 
4015     auto typingStyle = makeRefPtr(m_frame.selection().typingStyle());
4016     if (typingStyle &amp;&amp; typingStyle-&gt;style()) {
4017         auto value = typingStyle-&gt;style()-&gt;getPropertyCSSValue(CSSPropertyWebkitTextDecorationsInEffect);
4018         if (value &amp;&amp; value-&gt;isValueList()) {
4019             CSSValueList&amp; valueList = downcast&lt;CSSValueList&gt;(*value);
4020             if (valueList.hasValue(CSSValuePool::singleton().createIdentifierValue(CSSValueLineThrough).ptr()))
4021                 attributes.hasStrikeThrough = true;
4022             if (valueList.hasValue(CSSValuePool::singleton().createIdentifierValue(CSSValueUnderline).ptr()))
4023                 attributes.hasUnderline = true;
4024         }
4025     } else {
4026         auto decoration = style-&gt;textDecorationsInEffect();
4027         if (decoration &amp; TextDecoration::LineThrough)
4028             attributes.hasStrikeThrough = true;
4029         if (decoration &amp; TextDecoration::Underline)
4030             attributes.hasUnderline = true;
4031     }
4032 
4033     if (nodeToRemove)
4034         nodeToRemove-&gt;remove();
4035 
4036     return attributes;
4037 }
4038 
4039 #if ENABLE(ATTACHMENT_ELEMENT)
4040 
4041 void Editor::registerAttachmentIdentifier(const String&amp; identifier, const String&amp; contentType, const String&amp; preferredFileName, Ref&lt;SharedBuffer&gt;&amp;&amp; data)
4042 {
4043     if (auto* client = this-&gt;client())
4044         client-&gt;registerAttachmentIdentifier(identifier, contentType, preferredFileName, WTFMove(data));
4045 }
4046 
4047 void Editor::registerAttachmentIdentifier(const String&amp; identifier, const String&amp; contentType, const String&amp; filePath)
4048 {
4049     if (auto* client = this-&gt;client())
4050         client-&gt;registerAttachmentIdentifier(identifier, contentType, filePath);
4051 }
4052 
4053 void Editor::registerAttachments(Vector&lt;SerializedAttachmentData&gt;&amp;&amp; data)
4054 {
4055     if (auto* client = this-&gt;client())
4056         client-&gt;registerAttachments(WTFMove(data));
4057 }
4058 
4059 void Editor::registerAttachmentIdentifier(const String&amp; identifier)
4060 {
4061     if (auto* client = this-&gt;client())
4062         client-&gt;registerAttachmentIdentifier(identifier);
4063 }
4064 
4065 void Editor::cloneAttachmentData(const String&amp; fromIdentifier, const String&amp; toIdentifier)
4066 {
4067     if (auto* client = this-&gt;client())
4068         client-&gt;cloneAttachmentData(fromIdentifier, toIdentifier);
4069 }
4070 
4071 void Editor::didInsertAttachmentElement(HTMLAttachmentElement&amp; attachment)
4072 {
4073     auto identifier = attachment.uniqueIdentifier();
4074     if (identifier.isEmpty())
4075         return;
4076 
4077     if (!m_removedAttachmentIdentifiers.take(identifier))
4078         m_insertedAttachmentIdentifiers.add(identifier);
4079     scheduleEditorUIUpdate();
4080 }
4081 
4082 void Editor::didRemoveAttachmentElement(HTMLAttachmentElement&amp; attachment)
4083 {
4084     auto identifier = attachment.uniqueIdentifier();
4085     if (identifier.isEmpty())
4086         return;
4087 
4088     if (!m_insertedAttachmentIdentifiers.take(identifier))
4089         m_removedAttachmentIdentifiers.add(identifier);
4090     scheduleEditorUIUpdate();
4091 }
4092 
4093 void Editor::notifyClientOfAttachmentUpdates()
4094 {
4095     auto removedAttachmentIdentifiers = WTFMove(m_removedAttachmentIdentifiers);
4096     auto insertedAttachmentIdentifiers = WTFMove(m_insertedAttachmentIdentifiers);
4097     if (!client())
4098         return;
4099 
4100     for (auto&amp; identifier : removedAttachmentIdentifiers)
4101         client()-&gt;didRemoveAttachmentWithIdentifier(identifier);
4102 
4103     auto* document = m_frame.document();
4104     if (!document)
4105         return;
4106 
4107     for (auto&amp; identifier : insertedAttachmentIdentifiers) {
4108         if (auto attachment = document-&gt;attachmentForIdentifier(identifier))
4109             client()-&gt;didInsertAttachmentWithIdentifier(identifier, attachment-&gt;attributeWithoutSynchronization(HTMLNames::srcAttr), attachment-&gt;hasEnclosingImage());
4110         else
4111             ASSERT_NOT_REACHED();
4112     }
4113 }
4114 
4115 void Editor::insertAttachment(const String&amp; identifier, Optional&lt;uint64_t&gt;&amp;&amp; fileSize, const String&amp; fileName, const String&amp; contentType)
4116 {
4117     auto attachment = HTMLAttachmentElement::create(HTMLNames::attachmentTag, document());
4118     attachment-&gt;setUniqueIdentifier(identifier);
4119     attachment-&gt;updateAttributes(WTFMove(fileSize), contentType, fileName);
4120 
4121     auto fragmentToInsert = document().createDocumentFragment();
4122     fragmentToInsert-&gt;appendChild(attachment.get());
4123 
4124     replaceSelectionWithFragment(fragmentToInsert.get(), SelectReplacement::No, SmartReplace::No, MatchStyle::Yes);
4125 }
4126 
4127 #endif // ENABLE(ATTACHMENT_ELEMENT)
4128 
4129 void Editor::handleAcceptedCandidate(TextCheckingResult acceptedCandidate)
4130 {
4131     const VisibleSelection&amp; selection = m_frame.selection().selection();
4132 
4133     m_isHandlingAcceptedCandidate = true;
4134 
4135     if (auto range = rangeForTextCheckingResult(acceptedCandidate)) {
4136         if (shouldInsertText(acceptedCandidate.replacement, range.get(), EditorInsertAction::Typed))
4137             ReplaceRangeWithTextCommand::create(range.get(), acceptedCandidate.replacement)-&gt;apply();
4138     } else
4139         insertText(acceptedCandidate.replacement, nullptr);
4140 
4141     RefPtr&lt;Range&gt; insertedCandidateRange = rangeExpandedByCharactersInDirectionAtWordBoundary(selection.visibleStart(), acceptedCandidate.replacement.length(), DirectionBackward);
4142     if (insertedCandidateRange)
4143         insertedCandidateRange-&gt;startContainer().document().markers().addMarker(*insertedCandidateRange, DocumentMarker::AcceptedCandidate, acceptedCandidate.replacement);
4144 
4145     m_isHandlingAcceptedCandidate = false;
4146 }
4147 
4148 bool Editor::unifiedTextCheckerEnabled() const
4149 {
4150     return WebCore::unifiedTextCheckerEnabled(&amp;m_frame);
4151 }
4152 
4153 Vector&lt;String&gt; Editor::dictationAlternativesForMarker(const DocumentMarker&amp; marker)
4154 {
4155     return m_alternativeTextController-&gt;dictationAlternativesForMarker(marker);
4156 }
4157 
4158 void Editor::applyDictationAlternativelternative(const String&amp; alternativeString)
4159 {
4160     m_alternativeTextController-&gt;applyDictationAlternative(alternativeString);
4161 }
4162 
4163 void Editor::toggleOverwriteModeEnabled()
4164 {
4165     m_overwriteModeEnabled = !m_overwriteModeEnabled;
4166     m_frame.selection().setShouldShowBlockCursor(m_overwriteModeEnabled);
4167 }
4168 
4169 Document&amp; Editor::document() const
4170 {
4171     ASSERT(m_frame.document());
4172     return *m_frame.document();
4173 }
4174 
4175 RefPtr&lt;Range&gt; Editor::adjustedSelectionRange()
4176 {
4177     // FIXME: Why do we need to adjust the selection to include the anchor tag it&#39;s in?
4178     // Whoever wrote this code originally forgot to leave us a comment explaining the rationale.
4179     RefPtr&lt;Range&gt; range = selectedRange();
4180     Node* commonAncestor = range-&gt;commonAncestorContainer();
4181     ASSERT(commonAncestor);
4182     auto* enclosingAnchor = enclosingElementWithTag(firstPositionInNode(commonAncestor), HTMLNames::aTag);
4183     if (enclosingAnchor &amp;&amp; comparePositions(firstPositionInOrBeforeNode(range-&gt;startPosition().anchorNode()), range-&gt;startPosition()) &gt;= 0)
4184         range-&gt;setStart(*enclosingAnchor, 0);
4185     return range;
4186 }
4187 
4188 // FIXME: This figures out the current style by inserting a &lt;span&gt;!
4189 const RenderStyle* Editor::styleForSelectionStart(Frame* frame, Node*&amp; nodeToRemove)
4190 {
4191     nodeToRemove = nullptr;
4192 
4193     if (frame-&gt;selection().isNone())
4194         return nullptr;
4195 
4196     Position position = adjustedSelectionStartForStyleComputation(frame-&gt;selection().selection());
4197     if (!position.isCandidate() || position.isNull())
4198         return nullptr;
4199 
4200     RefPtr&lt;EditingStyle&gt; typingStyle = frame-&gt;selection().typingStyle();
4201     if (!typingStyle || !typingStyle-&gt;style())
4202         return &amp;position.deprecatedNode()-&gt;renderer()-&gt;style();
4203 
4204     auto styleElement = HTMLSpanElement::create(*frame-&gt;document());
4205 
4206     String styleText = typingStyle-&gt;style()-&gt;asText() + &quot; display: inline&quot;;
4207     styleElement-&gt;setAttribute(HTMLNames::styleAttr, styleText);
4208 
4209     styleElement-&gt;appendChild(frame-&gt;document()-&gt;createEditingTextNode(emptyString()));
4210 
4211     auto positionNode = position.deprecatedNode();
4212     if (!positionNode || !positionNode-&gt;parentNode() || positionNode-&gt;parentNode()-&gt;appendChild(styleElement).hasException())
4213         return nullptr;
4214 
4215     nodeToRemove = styleElement.ptr();
4216 
4217     frame-&gt;document()-&gt;updateStyleIfNeeded();
4218     return styleElement-&gt;renderer() ? &amp;styleElement-&gt;renderer()-&gt;style() : nullptr;
4219 }
4220 
4221 const Font* Editor::fontForSelection(bool&amp; hasMultipleFonts) const
4222 {
4223     hasMultipleFonts = false;
4224 
4225     if (!m_frame.selection().isRange()) {
4226         Node* nodeToRemove;
4227         auto* style = styleForSelectionStart(&amp;m_frame, nodeToRemove); // sets nodeToRemove
4228 
4229         const Font* font = nullptr;
4230         if (style) {
4231             font = &amp;style-&gt;fontCascade().primaryFont();
4232             if (nodeToRemove)
4233                 nodeToRemove-&gt;remove();
4234         }
4235 
4236         return font;
4237     }
4238 
4239     RefPtr&lt;Range&gt; range = m_frame.selection().toNormalizedRange();
4240     if (!range)
4241         return nullptr;
4242 
4243     Node* startNode = adjustedSelectionStartForStyleComputation(m_frame.selection().selection()).deprecatedNode();
4244     if (!startNode)
4245         return nullptr;
4246 
4247     const Font* font = nullptr;
4248     Node* pastEnd = range-&gt;pastLastNode();
4249     // In the loop below, node should eventually match pastEnd and not become null, but we&#39;ve seen at least one
4250     // unreproducible case where this didn&#39;t happen, so check for null also.
4251     for (Node* node = startNode; node &amp;&amp; node != pastEnd; node = NodeTraversal::next(*node)) {
4252         auto renderer = node-&gt;renderer();
4253         if (!renderer)
4254             continue;
4255         // FIXME: Are there any node types that have renderers, but that we should be skipping?
4256         const Font&amp; primaryFont = renderer-&gt;style().fontCascade().primaryFont();
4257         if (!font)
4258             font = &amp;primaryFont;
4259         else if (font != &amp;primaryFont) {
4260             hasMultipleFonts = true;
4261             break;
4262         }
4263     }
4264 
4265     return font;
4266 }
4267 
<a name="28" id="anc28"></a>







4268 RefPtr&lt;HTMLImageElement&gt; Editor::insertEditableImage()
4269 {
4270     return InsertEditableImageCommand::insertEditableImage(document());
4271 }
4272 
4273 bool Editor::canCopyExcludingStandaloneImages() const
4274 {
4275     auto&amp; selection = m_frame.selection().selection();
4276     return selection.isRange() &amp;&amp; !selection.isInPasswordField();
4277 }
4278 
4279 } // namespace WebCore
<a name="29" id="anc29"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="29" type="hidden" />
</body>
</html>