<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/page/scrolling/AsyncScrollingCoordinator.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2014-2015 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 
 28 #if ENABLE(ASYNC_SCROLLING)
 29 #include &quot;AsyncScrollingCoordinator.h&quot;
 30 
 31 #include &quot;DebugPageOverlays.h&quot;
 32 #include &quot;Document.h&quot;
 33 #include &quot;EditorClient.h&quot;
 34 #include &quot;Frame.h&quot;
 35 #include &quot;FrameView.h&quot;
 36 #include &quot;GraphicsLayer.h&quot;
 37 #include &quot;Logging.h&quot;
 38 #include &quot;Page.h&quot;
 39 #include &quot;PerformanceLoggingClient.h&quot;
 40 #include &quot;RenderLayerCompositor.h&quot;
 41 #include &quot;RenderView.h&quot;
 42 #include &quot;ScrollAnimator.h&quot;
 43 #include &quot;ScrollingConstraints.h&quot;
 44 #include &quot;ScrollingStateFixedNode.h&quot;
 45 #include &quot;ScrollingStateFrameHostingNode.h&quot;
 46 #include &quot;ScrollingStateFrameScrollingNode.h&quot;
 47 #include &quot;ScrollingStateOverflowScrollProxyNode.h&quot;
 48 #include &quot;ScrollingStateOverflowScrollingNode.h&quot;
 49 #include &quot;ScrollingStatePositionedNode.h&quot;
 50 #include &quot;ScrollingStateStickyNode.h&quot;
 51 #include &quot;ScrollingStateTree.h&quot;
 52 #include &quot;Settings.h&quot;
 53 #include &quot;WheelEventTestTrigger.h&quot;
 54 #include &lt;wtf/ProcessID.h&gt;
 55 #include &lt;wtf/text/TextStream.h&gt;
 56 
 57 namespace WebCore {
 58 
 59 AsyncScrollingCoordinator::AsyncScrollingCoordinator(Page* page)
 60     : ScrollingCoordinator(page)
 61     , m_updateNodeScrollPositionTimer(*this, &amp;AsyncScrollingCoordinator::updateScrollPositionAfterAsyncScrollTimerFired)
 62     , m_scrollingStateTree(makeUnique&lt;ScrollingStateTree&gt;(this))
 63 {
 64 }
 65 
 66 AsyncScrollingCoordinator::~AsyncScrollingCoordinator() = default;
 67 
 68 void AsyncScrollingCoordinator::scrollingStateTreePropertiesChanged()
 69 {
 70     scheduleTreeStateCommit();
 71 }
 72 
 73 #if ENABLE(CSS_SCROLL_SNAP)
 74 static inline void setStateScrollingNodeSnapOffsetsAsFloat(ScrollingStateScrollingNode&amp; node, ScrollEventAxis axis, const Vector&lt;LayoutUnit&gt;* snapOffsets, const Vector&lt;ScrollOffsetRange&lt;LayoutUnit&gt;&gt;* snapOffsetRanges, float deviceScaleFactor)
 75 {
 76     // FIXME: Incorporate current page scale factor in snapping to device pixel. Perhaps we should just convert to float here and let UI process do the pixel snapping?
 77     Vector&lt;float&gt; snapOffsetsAsFloat;
 78     if (snapOffsets) {
 79         snapOffsetsAsFloat.reserveInitialCapacity(snapOffsets-&gt;size());
 80         for (auto&amp; offset : *snapOffsets)
 81             snapOffsetsAsFloat.uncheckedAppend(roundToDevicePixel(offset, deviceScaleFactor, false));
 82     }
 83 
 84     Vector&lt;ScrollOffsetRange&lt;float&gt;&gt; snapOffsetRangesAsFloat;
 85     if (snapOffsetRanges) {
 86         snapOffsetRangesAsFloat.reserveInitialCapacity(snapOffsetRanges-&gt;size());
 87         for (auto&amp; range : *snapOffsetRanges)
 88             snapOffsetRangesAsFloat.uncheckedAppend({ roundToDevicePixel(range.start, deviceScaleFactor, false), roundToDevicePixel(range.end, deviceScaleFactor, false) });
 89     }
 90     if (axis == ScrollEventAxis::Horizontal) {
 91         node.setHorizontalSnapOffsets(snapOffsetsAsFloat);
 92         node.setHorizontalSnapOffsetRanges(snapOffsetRangesAsFloat);
 93     } else {
 94         node.setVerticalSnapOffsets(snapOffsetsAsFloat);
 95         node.setVerticalSnapOffsetRanges(snapOffsetRangesAsFloat);
 96     }
 97 }
 98 #endif
 99 
100 void AsyncScrollingCoordinator::setEventTrackingRegionsDirty()
101 {
102     m_eventTrackingRegionsDirty = true;
103     // We have to schedule a commit, but the computed non-fast region may not have actually changed.
104     scheduleTreeStateCommit();
105 }
106 
107 void AsyncScrollingCoordinator::willCommitTree()
108 {
109     updateEventTrackingRegions();
110 }
111 
112 void AsyncScrollingCoordinator::updateEventTrackingRegions()
113 {
114     if (!m_eventTrackingRegionsDirty)
115         return;
116 
117     if (!m_scrollingStateTree-&gt;rootStateNode())
118         return;
119 
120     m_scrollingStateTree-&gt;rootStateNode()-&gt;setEventTrackingRegions(absoluteEventTrackingRegions());
121     m_eventTrackingRegionsDirty = false;
122 }
123 
124 void AsyncScrollingCoordinator::frameViewLayoutUpdated(FrameView&amp; frameView)
125 {
126     ASSERT(isMainThread());
127     ASSERT(m_page);
128 
129     // If there isn&#39;t a root node yet, don&#39;t do anything. We&#39;ll be called again after creating one.
130     if (!m_scrollingStateTree-&gt;rootStateNode())
131         return;
132 
133     setEventTrackingRegionsDirty();
134 
135 #if PLATFORM(COCOA)
136     if (!coordinatesScrollingForFrameView(frameView))
137         return;
138 
139     auto* page = frameView.frame().page();
140     if (page &amp;&amp; page-&gt;expectsWheelEventTriggers()) {
141         LOG(WheelEventTestTriggers, &quot;    AsyncScrollingCoordinator::frameViewLayoutUpdated: Expects wheel event test trigger=%d&quot;, page-&gt;expectsWheelEventTriggers());
142 
143         auto* node = m_scrollingStateTree-&gt;stateNodeForID(frameView.scrollingNodeID());
144         if (!is&lt;ScrollingStateFrameScrollingNode&gt;(node))
145             return;
146 
147         auto&amp; frameScrollingNode = downcast&lt;ScrollingStateFrameScrollingNode&gt;(*node);
148         frameScrollingNode.setExpectsWheelEventTestTrigger(page-&gt;expectsWheelEventTriggers());
149     }
150 #else
151     UNUSED_PARAM(frameView);
152 #endif
153 }
154 
155 void AsyncScrollingCoordinator::frameViewVisualViewportChanged(FrameView&amp; frameView)
156 {
157     ASSERT(isMainThread());
158     ASSERT(m_page);
159 
160     if (!coordinatesScrollingForFrameView(frameView))
161         return;
162 
163     // If the root layer does not have a ScrollingStateNode, then we should create one.
164     auto* node = m_scrollingStateTree-&gt;stateNodeForID(frameView.scrollingNodeID());
165     if (!node)
166         return;
167 
168     auto&amp; frameScrollingNode = downcast&lt;ScrollingStateFrameScrollingNode&gt;(*node);
169 
170     auto visualViewportIsSmallerThanLayoutViewport = [](const FrameView&amp; frameView) {
171         auto layoutViewport = frameView.layoutViewportRect();
172         auto visualViewport = frameView.visualViewportRect();
173         return visualViewport.width() &lt; layoutViewport.width() || visualViewport.height() &lt; layoutViewport.height();
174     };
175     frameScrollingNode.setVisualViewportIsSmallerThanLayoutViewport(visualViewportIsSmallerThanLayoutViewport(frameView));
176 }
177 
178 void AsyncScrollingCoordinator::updateExpectsWheelEventTestTriggerWithFrameView(const FrameView&amp; frameView)
179 {
180     auto* page = frameView.frame().page();
181     if (!page)
182         return;
183 
184     auto* node = downcast&lt;ScrollingStateFrameScrollingNode&gt;(m_scrollingStateTree-&gt;stateNodeForID(frameView.scrollingNodeID()));
185     if (!node)
186         return;
187 
188     node-&gt;setExpectsWheelEventTestTrigger(page-&gt;expectsWheelEventTriggers());
189 }
190 
191 void AsyncScrollingCoordinator::frameViewEventTrackingRegionsChanged(FrameView&amp; frameView)
192 {
193     if (!m_scrollingStateTree-&gt;rootStateNode())
194         return;
195 
196     setEventTrackingRegionsDirty();
197     DebugPageOverlays::didChangeEventHandlers(frameView.frame());
198 }
199 
200 void AsyncScrollingCoordinator::frameViewRootLayerDidChange(FrameView&amp; frameView)
201 {
202     ASSERT(isMainThread());
203     ASSERT(m_page);
204 
205     if (!coordinatesScrollingForFrameView(frameView))
206         return;
207 
208     // FIXME: In some navigation scenarios, the FrameView has no RenderView or that RenderView has not been composited.
209     // This needs cleaning up: https://bugs.webkit.org/show_bug.cgi?id=132724
210     if (!frameView.scrollingNodeID())
211         return;
212 
213     // If the root layer does not have a ScrollingStateNode, then we should create one.
214     ensureRootStateNodeForFrameView(frameView);
215     ASSERT(m_scrollingStateTree-&gt;stateNodeForID(frameView.scrollingNodeID()));
216 
217     ScrollingCoordinator::frameViewRootLayerDidChange(frameView);
218 
219     auto* node = downcast&lt;ScrollingStateFrameScrollingNode&gt;(m_scrollingStateTree-&gt;stateNodeForID(frameView.scrollingNodeID()));
220     node-&gt;setScrollContainerLayer(scrollContainerLayerForFrameView(frameView));
221     node-&gt;setScrolledContentsLayer(scrolledContentsLayerForFrameView(frameView));
222     node-&gt;setRootContentsLayer(rootContentsLayerForFrameView(frameView));
223     node-&gt;setCounterScrollingLayer(counterScrollingLayerForFrameView(frameView));
224     node-&gt;setInsetClipLayer(insetClipLayerForFrameView(frameView));
225     node-&gt;setContentShadowLayer(contentShadowLayerForFrameView(frameView));
226     node-&gt;setHeaderLayer(headerLayerForFrameView(frameView));
227     node-&gt;setFooterLayer(footerLayerForFrameView(frameView));
228     node-&gt;setScrollBehaviorForFixedElements(frameView.scrollBehaviorForFixedElements());
229     node-&gt;setVerticalScrollbarLayer(frameView.layerForVerticalScrollbar());
230     node-&gt;setHorizontalScrollbarLayer(frameView.layerForHorizontalScrollbar());
231 }
232 
233 bool AsyncScrollingCoordinator::requestScrollPositionUpdate(ScrollableArea&amp; scrollableArea, const IntPoint&amp; scrollPosition)
234 {
235     ASSERT(isMainThread());
236     ASSERT(m_page);
237 
238     auto scrollingNodeID = scrollableArea.scrollingNodeID();
239     if (!scrollingNodeID)
240         return false;
241 
242     auto* frameView = frameViewForScrollingNode(scrollingNodeID);
243     if (!frameView)
244         return false;
245 
246     if (!coordinatesScrollingForFrameView(*frameView))
247         return false;
248 
249     bool inPageCache = frameView-&gt;frame().document()-&gt;pageCacheState() != Document::NotInPageCache;
250     bool inProgrammaticScroll = scrollableArea.currentScrollType() == ScrollType::Programmatic;
251     if (inProgrammaticScroll || inPageCache)
252         updateScrollPositionAfterAsyncScroll(scrollingNodeID, scrollPosition, { }, ScrollType::Programmatic, ScrollingLayerPositionAction::Set);
253 
254     // If this frame view&#39;s document is being put into the page cache, we don&#39;t want to update our
255     // main frame scroll position. Just let the FrameView think that we did.
256     if (inPageCache)
257         return true;
258 
259     auto* stateNode = downcast&lt;ScrollingStateScrollingNode&gt;(m_scrollingStateTree-&gt;stateNodeForID(scrollingNodeID));
260     if (!stateNode)
261         return false;
262 
263     stateNode-&gt;setRequestedScrollPosition(scrollPosition, inProgrammaticScroll);
264     return true;
265 }
266 
267 void AsyncScrollingCoordinator::applyScrollingTreeLayerPositions()
268 {
269     m_scrollingTree-&gt;applyLayerPositions();
270 }
271 
272 void AsyncScrollingCoordinator::scheduleUpdateScrollPositionAfterAsyncScroll(ScrollingNodeID nodeID, const FloatPoint&amp; scrollPosition, const Optional&lt;FloatPoint&gt;&amp; layoutViewportOrigin, ScrollingLayerPositionAction scrollingLayerPositionAction)
273 {
274     ScheduledScrollUpdate scrollUpdate(nodeID, scrollPosition, layoutViewportOrigin, scrollingLayerPositionAction);
275 
276     if (m_updateNodeScrollPositionTimer.isActive()) {
277         if (m_scheduledScrollUpdate.matchesUpdateType(scrollUpdate)) {
278             m_scheduledScrollUpdate.scrollPosition = scrollPosition;
279             m_scheduledScrollUpdate.layoutViewportOrigin = layoutViewportOrigin;
280             return;
281         }
282 
283         // If the parameters don&#39;t match what was previously scheduled, dispatch immediately.
284         m_updateNodeScrollPositionTimer.stop();
285         updateScrollPositionAfterAsyncScroll(m_scheduledScrollUpdate.nodeID, m_scheduledScrollUpdate.scrollPosition, m_scheduledScrollUpdate.layoutViewportOrigin, ScrollType::User, m_scheduledScrollUpdate.updateLayerPositionAction);
286         updateScrollPositionAfterAsyncScroll(nodeID, scrollPosition, layoutViewportOrigin, ScrollType::User, scrollingLayerPositionAction);
287         return;
288     }
289 
290     m_scheduledScrollUpdate = scrollUpdate;
291     m_updateNodeScrollPositionTimer.startOneShot(0_s);
292 }
293 
294 void AsyncScrollingCoordinator::updateScrollPositionAfterAsyncScrollTimerFired()
295 {
296     updateScrollPositionAfterAsyncScroll(m_scheduledScrollUpdate.nodeID, m_scheduledScrollUpdate.scrollPosition, m_scheduledScrollUpdate.layoutViewportOrigin, ScrollType::User, m_scheduledScrollUpdate.updateLayerPositionAction);
297 }
298 
299 FrameView* AsyncScrollingCoordinator::frameViewForScrollingNode(ScrollingNodeID scrollingNodeID) const
300 {
301     if (!m_scrollingStateTree-&gt;rootStateNode())
302         return nullptr;
303 
304     if (scrollingNodeID == m_scrollingStateTree-&gt;rootStateNode()-&gt;scrollingNodeID())
305         return m_page-&gt;mainFrame().view();
306 
307     auto* stateNode = m_scrollingStateTree-&gt;stateNodeForID(scrollingNodeID);
308     if (!stateNode)
309         return nullptr;
310 
311     // Find the enclosing frame scrolling node.
312     auto* parentNode = stateNode;
313     while (parentNode &amp;&amp; !parentNode-&gt;isFrameScrollingNode())
314         parentNode = parentNode-&gt;parent();
315 
316     if (!parentNode)
317         return nullptr;
318 
319     // Walk the frame tree to find the matching FrameView. This is not ideal, but avoids back pointers to FrameViews
320     // from ScrollingTreeStateNodes.
321     for (Frame* frame = &amp;m_page-&gt;mainFrame(); frame; frame = frame-&gt;tree().traverseNext()) {
322         if (auto* view = frame-&gt;view()) {
323             if (view-&gt;scrollingNodeID() == parentNode-&gt;scrollingNodeID())
324                 return view;
325         }
326     }
327 
328     return nullptr;
329 }
330 
331 void AsyncScrollingCoordinator::updateScrollPositionAfterAsyncScroll(ScrollingNodeID scrollingNodeID, const FloatPoint&amp; scrollPosition, Optional&lt;FloatPoint&gt; layoutViewportOrigin, ScrollType scrollType, ScrollingLayerPositionAction scrollingLayerPositionAction)
332 {
333     ASSERT(isMainThread());
334 
335     if (!m_page)
336         return;
337 
338     auto* frameViewPtr = frameViewForScrollingNode(scrollingNodeID);
339     if (!frameViewPtr)
340         return;
341 
342     LOG_WITH_STREAM(Scrolling, stream &lt;&lt; &quot;AsyncScrollingCoordinator::updateScrollPositionAfterAsyncScroll node &quot; &lt;&lt; scrollingNodeID &lt;&lt; &quot; scrollPosition &quot; &lt;&lt; scrollPosition &lt;&lt; &quot; action &quot; &lt;&lt; scrollingLayerPositionAction);
343 
344     auto&amp; frameView = *frameViewPtr;
345 
346     if (scrollingNodeID == frameView.scrollingNodeID()) {
347         reconcileScrollingState(frameView, scrollPosition, layoutViewportOrigin, scrollType, ViewportRectStability::Stable, scrollingLayerPositionAction);
348 
349 #if PLATFORM(COCOA)
350         if (m_page-&gt;expectsWheelEventTriggers()) {
351             frameView.scrollAnimator().setWheelEventTestTrigger(m_page-&gt;testTrigger());
352             if (const auto&amp; trigger = m_page-&gt;testTrigger())
353                 trigger-&gt;removeTestDeferralForReason(reinterpret_cast&lt;WheelEventTestTrigger::ScrollableAreaIdentifier&gt;(scrollingNodeID), WheelEventTestTrigger::ScrollingThreadSyncNeeded);
354         }
355 #endif
356 
357         return;
358     }
359 
360     // Overflow-scroll area.
361     if (auto* scrollableArea = frameView.scrollableAreaForScrollLayerID(scrollingNodeID)) {
362         auto previousScrollType = scrollableArea-&gt;currentScrollType();
363         scrollableArea-&gt;setCurrentScrollType(scrollType);
364         scrollableArea-&gt;scrollToOffsetWithoutAnimation(ScrollableArea::scrollOffsetFromPosition(scrollPosition, toFloatSize(scrollableArea-&gt;scrollOrigin())));
365         scrollableArea-&gt;setCurrentScrollType(previousScrollType);
366 
367         if (scrollingLayerPositionAction == ScrollingLayerPositionAction::Set)
368             m_page-&gt;editorClient().overflowScrollPositionChanged();
369 
370 #if PLATFORM(COCOA)
371         if (m_page-&gt;expectsWheelEventTriggers()) {
372             frameView.scrollAnimator().setWheelEventTestTrigger(m_page-&gt;testTrigger());
373             if (const auto&amp; trigger = m_page-&gt;testTrigger())
374                 trigger-&gt;removeTestDeferralForReason(reinterpret_cast&lt;WheelEventTestTrigger::ScrollableAreaIdentifier&gt;(scrollingNodeID), WheelEventTestTrigger::ScrollingThreadSyncNeeded);
375         }
376 #endif
377     }
378 }
379 
380 void AsyncScrollingCoordinator::reconcileScrollingState(FrameView&amp; frameView, const FloatPoint&amp; scrollPosition, const LayoutViewportOriginOrOverrideRect&amp; layoutViewportOriginOrOverrideRect, ScrollType scrollType, ViewportRectStability viewportRectStability, ScrollingLayerPositionAction scrollingLayerPositionAction)
381 {
382     auto previousScrollType = frameView.currentScrollType();
383     frameView.setCurrentScrollType(scrollType);
384 
385     LOG_WITH_STREAM(Scrolling, stream &lt;&lt; getCurrentProcessID() &lt;&lt; &quot; AsyncScrollingCoordinator &quot; &lt;&lt; this &lt;&lt; &quot; reconcileScrollingState scrollPosition &quot; &lt;&lt; scrollPosition &lt;&lt; &quot; type &quot; &lt;&lt; scrollType &lt;&lt; &quot; stability &quot; &lt;&lt; viewportRectStability &lt;&lt; &quot; &quot; &lt;&lt; scrollingLayerPositionAction);
386 
387     Optional&lt;FloatRect&gt; layoutViewportRect;
388 
389     WTF::switchOn(layoutViewportOriginOrOverrideRect,
390         [&amp;frameView](Optional&lt;FloatPoint&gt; origin) {
391             if (origin)
392                 frameView.setBaseLayoutViewportOrigin(LayoutPoint(origin.value()), FrameView::TriggerLayoutOrNot::No);
393         }, [&amp;frameView, &amp;layoutViewportRect, viewportRectStability](Optional&lt;FloatRect&gt; overrideRect) {
394             if (!overrideRect)
395                 return;
396 
397             layoutViewportRect = overrideRect;
398             if (viewportRectStability != ViewportRectStability::ChangingObscuredInsetsInteractively)
399                 frameView.setLayoutViewportOverrideRect(LayoutRect(overrideRect.value()), viewportRectStability == ViewportRectStability::Stable ? FrameView::TriggerLayoutOrNot::Yes : FrameView::TriggerLayoutOrNot::No);
400         }
401     );
402 
403     frameView.setConstrainsScrollingToContentEdge(false);
404     frameView.notifyScrollPositionChanged(roundedIntPoint(scrollPosition));
405     frameView.setConstrainsScrollingToContentEdge(true);
406 
407     frameView.setCurrentScrollType(previousScrollType);
408 
409     if (scrollType == ScrollType::User &amp;&amp; scrollingLayerPositionAction != ScrollingLayerPositionAction::Set) {
410         auto scrollingNodeID = frameView.scrollingNodeID();
411         if (viewportRectStability == ViewportRectStability::Stable)
412             reconcileViewportConstrainedLayerPositions(scrollingNodeID, frameView.rectForFixedPositionLayout(), scrollingLayerPositionAction);
413         else if (layoutViewportRect)
414             reconcileViewportConstrainedLayerPositions(scrollingNodeID, LayoutRect(layoutViewportRect.value()), scrollingLayerPositionAction);
415     }
416 
417     if (!scrolledContentsLayerForFrameView(frameView))
418         return;
419 
420     auto* counterScrollingLayer = counterScrollingLayerForFrameView(frameView);
421     auto* insetClipLayer = insetClipLayerForFrameView(frameView);
422     auto* contentShadowLayer = contentShadowLayerForFrameView(frameView);
423     auto* rootContentsLayer = rootContentsLayerForFrameView(frameView);
424     auto* headerLayer = headerLayerForFrameView(frameView);
425     auto* footerLayer = footerLayerForFrameView(frameView);
426 
427     ASSERT(frameView.scrollPosition() == roundedIntPoint(scrollPosition));
428     LayoutPoint scrollPositionForFixed = frameView.scrollPositionForFixedPosition();
429     float topContentInset = frameView.topContentInset();
430 
431     FloatPoint positionForInsetClipLayer;
432     if (insetClipLayer)
433         positionForInsetClipLayer = FloatPoint(insetClipLayer-&gt;position().x(), FrameView::yPositionForInsetClipLayer(scrollPosition, topContentInset));
434     FloatPoint positionForContentsLayer = frameView.positionForRootContentLayer();
435 
436     FloatPoint positionForHeaderLayer = FloatPoint(scrollPositionForFixed.x(), FrameView::yPositionForHeaderLayer(scrollPosition, topContentInset));
437     FloatPoint positionForFooterLayer = FloatPoint(scrollPositionForFixed.x(),
438         FrameView::yPositionForFooterLayer(scrollPosition, topContentInset, frameView.totalContentsSize().height(), frameView.footerHeight()));
439 
440     if (scrollType == ScrollType::Programmatic || scrollingLayerPositionAction == ScrollingLayerPositionAction::Set) {
441         reconcileScrollPosition(frameView, ScrollingLayerPositionAction::Set);
442 
443         if (counterScrollingLayer)
444             counterScrollingLayer-&gt;setPosition(scrollPositionForFixed);
445         if (insetClipLayer)
446             insetClipLayer-&gt;setPosition(positionForInsetClipLayer);
447         if (contentShadowLayer)
448             contentShadowLayer-&gt;setPosition(positionForContentsLayer);
449         if (rootContentsLayer)
450             rootContentsLayer-&gt;setPosition(positionForContentsLayer);
451         if (headerLayer)
452             headerLayer-&gt;setPosition(positionForHeaderLayer);
453         if (footerLayer)
454             footerLayer-&gt;setPosition(positionForFooterLayer);
455     } else {
456         reconcileScrollPosition(frameView, ScrollingLayerPositionAction::Sync);
457 
458         if (counterScrollingLayer)
459             counterScrollingLayer-&gt;syncPosition(scrollPositionForFixed);
460         if (insetClipLayer)
461             insetClipLayer-&gt;syncPosition(positionForInsetClipLayer);
462         if (contentShadowLayer)
463             contentShadowLayer-&gt;syncPosition(positionForContentsLayer);
464         if (rootContentsLayer)
465             rootContentsLayer-&gt;syncPosition(positionForContentsLayer);
466         if (headerLayer)
467             headerLayer-&gt;syncPosition(positionForHeaderLayer);
468         if (footerLayer)
469             footerLayer-&gt;syncPosition(positionForFooterLayer);
470     }
471 }
472 
473 void AsyncScrollingCoordinator::reconcileScrollPosition(FrameView&amp; frameView, ScrollingLayerPositionAction scrollingLayerPositionAction)
474 {
475 #if PLATFORM(IOS_FAMILY)
476     // Doing all scrolling like this (UIScrollView style) would simplify code.
477     auto* scrollContainerLayer = scrollContainerLayerForFrameView(frameView);
478     if (!scrollContainerLayer)
479         return;
480     if (scrollingLayerPositionAction == ScrollingLayerPositionAction::Set)
481         scrollContainerLayer-&gt;setBoundsOrigin(frameView.scrollPosition());
482     else
483         scrollContainerLayer-&gt;syncBoundsOrigin(frameView.scrollPosition());
484 #else
485     // This uses scrollPosition because the root content layer accounts for scrollOrigin (see FrameView::positionForRootContentLayer()).
486     auto* scrolledContentsLayer = scrolledContentsLayerForFrameView(frameView);
487     if (!scrolledContentsLayer)
488         return;
489     if (scrollingLayerPositionAction == ScrollingLayerPositionAction::Set)
490         scrolledContentsLayer-&gt;setPosition(-frameView.scrollPosition());
491     else
492         scrolledContentsLayer-&gt;syncPosition(-frameView.scrollPosition());
493 #endif
494 }
495 
496 void AsyncScrollingCoordinator::scrollableAreaScrollbarLayerDidChange(ScrollableArea&amp; scrollableArea, ScrollbarOrientation orientation)
497 {
498     ASSERT(isMainThread());
499     ASSERT(m_page);
500 
501     auto* node = m_scrollingStateTree-&gt;stateNodeForID(scrollableArea.scrollingNodeID());
502     if (is&lt;ScrollingStateScrollingNode&gt;(node)) {
503         auto&amp; scrollingNode = downcast&lt;ScrollingStateScrollingNode&gt;(*node);
504         if (orientation == VerticalScrollbar)
505             scrollingNode.setVerticalScrollbarLayer(scrollableArea.layerForVerticalScrollbar());
506         else
507             scrollingNode.setHorizontalScrollbarLayer(scrollableArea.layerForHorizontalScrollbar());
508     }
509 
510     if (orientation == VerticalScrollbar)
511         scrollableArea.verticalScrollbarLayerDidChange();
512     else
513         scrollableArea.horizontalScrollbarLayerDidChange();
514 }
515 
516 ScrollingNodeID AsyncScrollingCoordinator::createNode(ScrollingNodeType nodeType, ScrollingNodeID newNodeID)
517 {
518     LOG_WITH_STREAM(Scrolling, stream &lt;&lt; &quot;AsyncScrollingCoordinator::createNode &quot; &lt;&lt; nodeType &lt;&lt; &quot; node &quot; &lt;&lt; newNodeID);
519     return m_scrollingStateTree-&gt;createUnparentedNode(nodeType, newNodeID);
520 }
521 
522 ScrollingNodeID AsyncScrollingCoordinator::insertNode(ScrollingNodeType nodeType, ScrollingNodeID newNodeID, ScrollingNodeID parentID, size_t childIndex)
523 {
524     LOG_WITH_STREAM(Scrolling, stream &lt;&lt; &quot;AsyncScrollingCoordinator::insertNode &quot; &lt;&lt; nodeType &lt;&lt; &quot; node &quot; &lt;&lt; newNodeID &lt;&lt; &quot; parent &quot; &lt;&lt; parentID &lt;&lt; &quot; index &quot; &lt;&lt; childIndex);
525     return m_scrollingStateTree-&gt;insertNode(nodeType, newNodeID, parentID, childIndex);
526 }
527 
528 void AsyncScrollingCoordinator::unparentNode(ScrollingNodeID nodeID)
529 {
530     m_scrollingStateTree-&gt;unparentNode(nodeID);
531 }
532 
533 void AsyncScrollingCoordinator::unparentChildrenAndDestroyNode(ScrollingNodeID nodeID)
534 {
535     m_scrollingStateTree-&gt;unparentChildrenAndDestroyNode(nodeID);
536 }
537 
538 void AsyncScrollingCoordinator::detachAndDestroySubtree(ScrollingNodeID nodeID)
539 {
540     m_scrollingStateTree-&gt;detachAndDestroySubtree(nodeID);
541 }
542 
543 void AsyncScrollingCoordinator::clearAllNodes()
544 {
545     m_scrollingStateTree-&gt;clear();
546 }
547 
548 ScrollingNodeID AsyncScrollingCoordinator::parentOfNode(ScrollingNodeID nodeID) const
549 {
550     auto* scrollingNode = m_scrollingStateTree-&gt;stateNodeForID(nodeID);
551     if (!scrollingNode)
552         return 0;
553 
554     return scrollingNode-&gt;parentNodeID();
555 }
556 
557 Vector&lt;ScrollingNodeID&gt; AsyncScrollingCoordinator::childrenOfNode(ScrollingNodeID nodeID) const
558 {
559     auto* scrollingNode = m_scrollingStateTree-&gt;stateNodeForID(nodeID);
560     if (!scrollingNode)
561         return { };
562 
563     auto* children = scrollingNode-&gt;children();
564     if (!children || children-&gt;isEmpty())
565         return { };
566 
567     Vector&lt;ScrollingNodeID&gt; childNodeIDs;
568     childNodeIDs.reserveInitialCapacity(children-&gt;size());
569     for (const auto&amp; childNode : *children)
570         childNodeIDs.uncheckedAppend(childNode-&gt;scrollingNodeID());
571 
572     return childNodeIDs;
573 }
574 
575 void AsyncScrollingCoordinator::reconcileViewportConstrainedLayerPositions(ScrollingNodeID scrollingNodeID, const LayoutRect&amp; viewportRect, ScrollingLayerPositionAction action)
576 {
577     LOG_WITH_STREAM(Scrolling, stream &lt;&lt; getCurrentProcessID() &lt;&lt; &quot; AsyncScrollingCoordinator::reconcileViewportConstrainedLayerPositions for viewport rect &quot; &lt;&lt; viewportRect &lt;&lt; &quot; and node &quot; &lt;&lt; scrollingNodeID);
578 
579     m_scrollingStateTree-&gt;reconcileViewportConstrainedLayerPositions(scrollingNodeID, viewportRect, action);
580 }
581 
582 void AsyncScrollingCoordinator::ensureRootStateNodeForFrameView(FrameView&amp; frameView)
583 {
584     ASSERT(frameView.scrollingNodeID());
585     if (m_scrollingStateTree-&gt;stateNodeForID(frameView.scrollingNodeID()))
586         return;
587 
588     // For non-main frames, it is only possible to arrive in this function from
589     // RenderLayerCompositor::updateBacking where the node has already been created.
590     ASSERT(frameView.frame().isMainFrame());
591     insertNode(ScrollingNodeType::MainFrame, frameView.scrollingNodeID(), 0, 0);
592 }
593 
594 void AsyncScrollingCoordinator::setNodeLayers(ScrollingNodeID nodeID, const NodeLayers&amp; nodeLayers)
595 {
596     auto* node = m_scrollingStateTree-&gt;stateNodeForID(nodeID);
597     ASSERT(node);
598     if (!node)
599         return;
600 
601     node-&gt;setLayer(nodeLayers.layer);
602 
603     if (is&lt;ScrollingStateScrollingNode&gt;(node)) {
604         auto&amp; scrollingNode = downcast&lt;ScrollingStateScrollingNode&gt;(*node);
605         scrollingNode.setScrollContainerLayer(nodeLayers.scrollContainerLayer);
606         scrollingNode.setScrolledContentsLayer(nodeLayers.scrolledContentsLayer);
607         scrollingNode.setHorizontalScrollbarLayer(nodeLayers.horizontalScrollbarLayer);
608         scrollingNode.setVerticalScrollbarLayer(nodeLayers.verticalScrollbarLayer);
609 
610         if (is&lt;ScrollingStateFrameScrollingNode&gt;(node)) {
611             auto&amp; frameScrollingNode = downcast&lt;ScrollingStateFrameScrollingNode&gt;(*node);
612             frameScrollingNode.setInsetClipLayer(nodeLayers.insetClipLayer);
613             frameScrollingNode.setCounterScrollingLayer(nodeLayers.counterScrollingLayer);
614             frameScrollingNode.setRootContentsLayer(nodeLayers.rootContentsLayer);
615         }
616     }
617 }
618 
619 void AsyncScrollingCoordinator::setRectRelativeToParentNode(ScrollingNodeID nodeID, const LayoutRect&amp; parentRelativeScrollableRect)
620 {
621     auto* stateNode = m_scrollingStateTree-&gt;stateNodeForID(nodeID);
622     ASSERT(stateNode);
623     if (!stateNode)
624         return;
625 
626     if (is&lt;ScrollingStateFrameHostingNode&gt;(*stateNode)) {
627         auto&amp; frameHostingStateNode = downcast&lt;ScrollingStateFrameHostingNode&gt;(*stateNode);
628         frameHostingStateNode.setParentRelativeScrollableRect(parentRelativeScrollableRect);
629         return;
630     }
631 
632     if (is&lt;ScrollingStateScrollingNode&gt;(stateNode)) {
633         auto&amp; scrollingStateNode = downcast&lt;ScrollingStateScrollingNode&gt;(*stateNode);
634         scrollingStateNode.setParentRelativeScrollableRect(parentRelativeScrollableRect);
635     }
636 }
637 
638 void AsyncScrollingCoordinator::setFrameScrollingNodeState(ScrollingNodeID nodeID, const FrameView&amp; frameView)
639 {
640     auto* stateNode = m_scrollingStateTree-&gt;stateNodeForID(nodeID);
641     ASSERT(stateNode);
642     if (!is&lt;ScrollingStateFrameScrollingNode&gt;(stateNode))
643         return;
644 
645     auto&amp; frameScrollingNode = downcast&lt;ScrollingStateFrameScrollingNode&gt;(*stateNode);
646 
647     frameScrollingNode.setFrameScaleFactor(frameView.frame().frameScaleFactor());
648     frameScrollingNode.setHeaderHeight(frameView.headerHeight());
649     frameScrollingNode.setFooterHeight(frameView.footerHeight());
650     frameScrollingNode.setTopContentInset(frameView.topContentInset());
651     frameScrollingNode.setLayoutViewport(frameView.layoutViewportRect());
652     frameScrollingNode.setAsyncFrameOrOverflowScrollingEnabled(asyncFrameOrOverflowScrollingEnabled());
653 
654     frameScrollingNode.setMinLayoutViewportOrigin(frameView.minStableLayoutViewportOrigin());
655     frameScrollingNode.setMaxLayoutViewportOrigin(frameView.maxStableLayoutViewportOrigin());
656 
657     if (auto visualOverrideRect = frameView.visualViewportOverrideRect())
658         frameScrollingNode.setOverrideVisualViewportSize(FloatSize(visualOverrideRect.value().size()));
659     else
660         frameScrollingNode.setOverrideVisualViewportSize(WTF::nullopt);
661 
662     frameScrollingNode.setFixedElementsLayoutRelativeToFrame(frameView.fixedElementsLayoutRelativeToFrame());
663 
664     auto visualViewportIsSmallerThanLayoutViewport = [](const FrameView&amp; frameView) {
665         auto layoutViewport = frameView.layoutViewportRect();
666         auto visualViewport = frameView.visualViewportRect();
667         return visualViewport.width() &lt; layoutViewport.width() || visualViewport.height() &lt; layoutViewport.height();
668     };
669     frameScrollingNode.setVisualViewportIsSmallerThanLayoutViewport(visualViewportIsSmallerThanLayoutViewport(frameView));
670 
671     frameScrollingNode.setScrollBehaviorForFixedElements(frameView.scrollBehaviorForFixedElements());
672 }
673 
674 void AsyncScrollingCoordinator::setScrollingNodeScrollableAreaGeometry(ScrollingNodeID nodeID, ScrollableArea&amp; scrollableArea)
675 {
676     auto* stateNode = m_scrollingStateTree-&gt;stateNodeForID(nodeID);
677     ASSERT(stateNode);
678     if (!stateNode)
679         return;
680 
681     auto&amp; scrollingNode = downcast&lt;ScrollingStateScrollingNode&gt;(*stateNode);
682 
683     auto* verticalScrollbar = scrollableArea.verticalScrollbar();
684     auto* horizontalScrollbar = scrollableArea.horizontalScrollbar();
685     scrollingNode.setScrollerImpsFromScrollbars(verticalScrollbar, horizontalScrollbar);
686 
687     scrollingNode.setScrollOrigin(scrollableArea.scrollOrigin());
688     scrollingNode.setScrollPosition(scrollableArea.scrollPosition());
689     scrollingNode.setTotalContentsSize(scrollableArea.totalContentsSize());
690     scrollingNode.setReachableContentsSize(scrollableArea.reachableTotalContentsSize());
691     scrollingNode.setScrollableAreaSize(scrollableArea.visibleSize());
692 
693     ScrollableAreaParameters scrollParameters;
694     scrollParameters.horizontalScrollElasticity = scrollableArea.horizontalScrollElasticity();
695     scrollParameters.verticalScrollElasticity = scrollableArea.verticalScrollElasticity();
696     scrollParameters.hasEnabledHorizontalScrollbar = horizontalScrollbar &amp;&amp; horizontalScrollbar-&gt;enabled();
697     scrollParameters.hasEnabledVerticalScrollbar = verticalScrollbar &amp;&amp; verticalScrollbar-&gt;enabled();
698     scrollParameters.horizontalScrollbarMode = scrollableArea.horizontalScrollbarMode();
699     scrollParameters.verticalScrollbarMode = scrollableArea.verticalScrollbarMode();
700     scrollParameters.horizontalScrollbarHiddenByStyle = scrollableArea.horizontalScrollbarHiddenByStyle();
701     scrollParameters.verticalScrollbarHiddenByStyle = scrollableArea.verticalScrollbarHiddenByStyle();
702     scrollParameters.useDarkAppearanceForScrollbars = scrollableArea.useDarkAppearanceForScrollbars();
703 
704     scrollingNode.setScrollableAreaParameters(scrollParameters);
705 
706 #if ENABLE(CSS_SCROLL_SNAP)
707     scrollableArea.updateSnapOffsets();
708     setStateScrollingNodeSnapOffsetsAsFloat(scrollingNode, ScrollEventAxis::Horizontal, scrollableArea.horizontalSnapOffsets(), scrollableArea.horizontalSnapOffsetRanges(), m_page-&gt;deviceScaleFactor());
709     setStateScrollingNodeSnapOffsetsAsFloat(scrollingNode, ScrollEventAxis::Vertical, scrollableArea.verticalSnapOffsets(), scrollableArea.verticalSnapOffsetRanges(), m_page-&gt;deviceScaleFactor());
710     scrollingNode.setCurrentHorizontalSnapPointIndex(scrollableArea.currentHorizontalSnapPointIndex());
711     scrollingNode.setCurrentVerticalSnapPointIndex(scrollableArea.currentVerticalSnapPointIndex());
712 #endif
713 }
714 
715 void AsyncScrollingCoordinator::setViewportConstraintedNodeConstraints(ScrollingNodeID nodeID, const ViewportConstraints&amp; constraints)
716 {
717     auto* node = m_scrollingStateTree-&gt;stateNodeForID(nodeID);
718     if (!node)
719         return;
720 
721     switch (constraints.constraintType()) {
722     case ViewportConstraints::FixedPositionConstraint: {
723         auto&amp; fixedNode = downcast&lt;ScrollingStateFixedNode&gt;(*node);
724         fixedNode.updateConstraints((const FixedPositionViewportConstraints&amp;)constraints);
725         break;
726     }
727     case ViewportConstraints::StickyPositionConstraint: {
728         auto&amp; stickyNode = downcast&lt;ScrollingStateStickyNode&gt;(*node);
729         stickyNode.updateConstraints((const StickyPositionViewportConstraints&amp;)constraints);
730         break;
731     }
732     }
733 }
734 
735 void AsyncScrollingCoordinator::setPositionedNodeConstraints(ScrollingNodeID nodeID, const AbsolutePositionConstraints&amp; constraints)
736 {
737     auto* node = m_scrollingStateTree-&gt;stateNodeForID(nodeID);
738     if (!node)
739         return;
740 
741     ASSERT(is&lt;ScrollingStatePositionedNode&gt;(*node));
742     if (auto* positionedNode = downcast&lt;ScrollingStatePositionedNode&gt;(node))
743         positionedNode-&gt;updateConstraints(constraints);
744 }
745 
746 void AsyncScrollingCoordinator::setRelatedOverflowScrollingNodes(ScrollingNodeID nodeID, Vector&lt;ScrollingNodeID&gt;&amp;&amp; relatedNodes)
747 {
748     auto* node = m_scrollingStateTree-&gt;stateNodeForID(nodeID);
749     if (!node)
750         return;
751 
752     if (is&lt;ScrollingStatePositionedNode&gt;(node))
753         downcast&lt;ScrollingStatePositionedNode&gt;(node)-&gt;setRelatedOverflowScrollingNodes(WTFMove(relatedNodes));
754     else if (is&lt;ScrollingStateOverflowScrollProxyNode&gt;(node)) {
755         auto* overflowScrollProxyNode = downcast&lt;ScrollingStateOverflowScrollProxyNode&gt;(node);
756         if (!relatedNodes.isEmpty())
757             overflowScrollProxyNode-&gt;setOverflowScrollingNode(relatedNodes[0]);
758         else
759             overflowScrollProxyNode-&gt;setOverflowScrollingNode(0);
760     } else
761         ASSERT_NOT_REACHED();
762 }
763 
764 void AsyncScrollingCoordinator::setSynchronousScrollingReasons(FrameView&amp; frameView, SynchronousScrollingReasons reasons)
765 {
766     auto* scrollingStateNode = static_cast&lt;ScrollingStateFrameScrollingNode*&gt;(m_scrollingStateTree-&gt;stateNodeForID(frameView.scrollingNodeID()));
767     if (!scrollingStateNode)
768         return;
769 
770     // The FrameView&#39;s GraphicsLayer is likely to be out-of-synch with the PlatformLayer
771     // at this point. So we&#39;ll update it before we switch back to main thread scrolling
772     // in order to avoid layer positioning bugs.
773     if (reasons)
774         reconcileScrollPosition(frameView, ScrollingLayerPositionAction::Set);
775     scrollingStateNode-&gt;setSynchronousScrollingReasons(reasons);
776 }
777 
778 bool AsyncScrollingCoordinator::isRubberBandInProgress() const
779 {
780     return scrollingTree()-&gt;isRubberBandInProgress();
781 }
782 
783 void AsyncScrollingCoordinator::setScrollPinningBehavior(ScrollPinningBehavior pinning)
784 {
785     scrollingTree()-&gt;setScrollPinningBehavior(pinning);
786 }
787 
788 bool AsyncScrollingCoordinator::asyncFrameOrOverflowScrollingEnabled() const
789 {
790     auto&amp; settings = m_page-&gt;mainFrame().settings();
791     return settings.asyncFrameScrollingEnabled() || settings.asyncOverflowScrollingEnabled();
792 }
793 
794 ScrollingNodeID AsyncScrollingCoordinator::scrollableContainerNodeID(const RenderObject&amp; renderer) const
795 {
796     if (auto overflowScrollingNodeID = renderer.view().compositor().asyncScrollableContainerNodeID(renderer))
797         return overflowScrollingNodeID;
798 
799     // If we&#39;re in a scrollable frame, return that.
800     auto* frameView = renderer.frame().view();
801     if (!frameView)
802         return 0;
803 
804     if (auto scrollingNodeID = frameView-&gt;scrollingNodeID())
805         return scrollingNodeID;
806 
807     // Otherwise, look for a scrollable element in the containing frame.
808     if (auto* ownerElement = renderer.document().ownerElement()) {
809         if (auto* frameRenderer = ownerElement-&gt;renderer())
810             return scrollableContainerNodeID(*frameRenderer);
811     }
812 
813     return 0;
814 }
815 
816 String AsyncScrollingCoordinator::scrollingStateTreeAsText(ScrollingStateTreeAsTextBehavior behavior) const
817 {
818     if (m_scrollingStateTree-&gt;rootStateNode()) {
819         if (m_eventTrackingRegionsDirty)
820             m_scrollingStateTree-&gt;rootStateNode()-&gt;setEventTrackingRegions(absoluteEventTrackingRegions());
821         return m_scrollingStateTree-&gt;rootStateNode()-&gt;scrollingStateTreeAsText(behavior);
822     }
823 
824     return String();
825 }
826 
827 #if PLATFORM(COCOA)
828 void AsyncScrollingCoordinator::setActiveScrollSnapIndices(ScrollingNodeID scrollingNodeID, unsigned horizontalIndex, unsigned verticalIndex)
829 {
830     ASSERT(isMainThread());
831 
832     if (!m_page)
833         return;
834 
835     auto* frameView = frameViewForScrollingNode(scrollingNodeID);
836     if (!frameView)
837         return;
838 
839     if (scrollingNodeID == frameView-&gt;scrollingNodeID()) {
840         frameView-&gt;setCurrentHorizontalSnapPointIndex(horizontalIndex);
841         frameView-&gt;setCurrentVerticalSnapPointIndex(verticalIndex);
842         return;
843     }
844 
845     // Overflow-scroll area.
846     if (auto* scrollableArea = frameView-&gt;scrollableAreaForScrollLayerID(scrollingNodeID)) {
847         scrollableArea-&gt;setCurrentHorizontalSnapPointIndex(horizontalIndex);
848         scrollableArea-&gt;setCurrentVerticalSnapPointIndex(verticalIndex);
849     }
850 }
851 
852 void AsyncScrollingCoordinator::deferTestsForReason(WheelEventTestTrigger::ScrollableAreaIdentifier identifier, WheelEventTestTrigger::DeferTestTriggerReason reason) const
853 {
854     ASSERT(isMainThread());
855     if (!m_page || !m_page-&gt;expectsWheelEventTriggers())
856         return;
857 
858     if (const auto&amp; trigger = m_page-&gt;testTrigger()) {
859         LOG(WheelEventTestTriggers, &quot;    (!) AsyncScrollingCoordinator::deferTestsForReason: Deferring %p for reason %d.&quot;, identifier, reason);
860         trigger-&gt;deferTestsForReason(identifier, reason);
861     }
862 }
863 
864 void AsyncScrollingCoordinator::removeTestDeferralForReason(WheelEventTestTrigger::ScrollableAreaIdentifier identifier, WheelEventTestTrigger::DeferTestTriggerReason reason) const
865 {
866     ASSERT(isMainThread());
867     if (!m_page || !m_page-&gt;expectsWheelEventTriggers())
868         return;
869 
870     if (const auto&amp; trigger = m_page-&gt;testTrigger()) {
871         LOG(WheelEventTestTriggers, &quot;    (!) AsyncScrollingCoordinator::removeTestDeferralForReason: Deferring %p for reason %d.&quot;, identifier, reason);
872         trigger-&gt;removeTestDeferralForReason(identifier, reason);
873     }
874 }
875 #endif
876 
877 #if ENABLE(CSS_SCROLL_SNAP)
878 bool AsyncScrollingCoordinator::isScrollSnapInProgress() const
879 {
880     return scrollingTree()-&gt;isScrollSnapInProgress();
881 }
882 
883 void AsyncScrollingCoordinator::updateScrollSnapPropertiesWithFrameView(const FrameView&amp; frameView)
884 {
885     if (auto node = downcast&lt;ScrollingStateFrameScrollingNode&gt;(m_scrollingStateTree-&gt;stateNodeForID(frameView.scrollingNodeID()))) {
886         setStateScrollingNodeSnapOffsetsAsFloat(*node, ScrollEventAxis::Horizontal, frameView.horizontalSnapOffsets(), frameView.horizontalSnapOffsetRanges(), m_page-&gt;deviceScaleFactor());
887         setStateScrollingNodeSnapOffsetsAsFloat(*node, ScrollEventAxis::Vertical, frameView.verticalSnapOffsets(), frameView.verticalSnapOffsetRanges(), m_page-&gt;deviceScaleFactor());
888         node-&gt;setCurrentHorizontalSnapPointIndex(frameView.currentHorizontalSnapPointIndex());
889         node-&gt;setCurrentVerticalSnapPointIndex(frameView.currentVerticalSnapPointIndex());
890     }
891 }
892 #endif
893 
894 void AsyncScrollingCoordinator::reportExposedUnfilledArea(MonotonicTime timestamp, unsigned unfilledArea)
895 {
896     if (m_page &amp;&amp; m_page-&gt;performanceLoggingClient())
897         m_page-&gt;performanceLoggingClient()-&gt;logScrollingEvent(PerformanceLoggingClient::ScrollingEvent::ExposedTilelessArea, timestamp, unfilledArea);
898 }
899 
900 void AsyncScrollingCoordinator::reportSynchronousScrollingReasonsChanged(MonotonicTime timestamp, SynchronousScrollingReasons reasons)
901 {
902     if (m_page &amp;&amp; m_page-&gt;performanceLoggingClient())
903         m_page-&gt;performanceLoggingClient()-&gt;logScrollingEvent(PerformanceLoggingClient::ScrollingEvent::SwitchedScrollingMode, timestamp, reasons);
904 }
905 
906 } // namespace WebCore
907 
908 #endif // ENABLE(ASYNC_SCROLLING)
    </pre>
  </body>
</html>