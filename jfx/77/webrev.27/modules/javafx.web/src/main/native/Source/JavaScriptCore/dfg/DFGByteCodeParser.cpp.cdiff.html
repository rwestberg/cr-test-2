<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGByteCodeParser.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="DFGBasicBlock.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DFGCFAPhase.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGByteCodeParser.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 265,11 ***</span>
  
      VariableAccessData* newVariableAccessData(VirtualRegister operand)
      {
          ASSERT(!operand.isConstant());
  
<span class="line-modified">!         m_graph.m_variableAccessData.append(VariableAccessData(operand));</span>
          return &amp;m_graph.m_variableAccessData.last();
      }
  
      // Get/Set the operands/result of a bytecode instruction.
      Node* getDirect(VirtualRegister operand)
<span class="line-new-header">--- 265,11 ---</span>
  
      VariableAccessData* newVariableAccessData(VirtualRegister operand)
      {
          ASSERT(!operand.isConstant());
  
<span class="line-modified">!         m_graph.m_variableAccessData.append(operand);</span>
          return &amp;m_graph.m_variableAccessData.last();
      }
  
      // Get/Set the operands/result of a bytecode instruction.
      Node* getDirect(VirtualRegister operand)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 319,14 ***</span>
          } else if (operand.offset() == CallFrameSlot::callee) {
              // We have to do some constant-folding here because this enables CreateThis folding. Note
              // that we don&#39;t have such watchpoint-based folding for inlined uses of Callee, since in that
              // case if the function is a singleton then we already know it.
              if (FunctionExecutable* executable = jsDynamicCast&lt;FunctionExecutable*&gt;(*m_vm, m_codeBlock-&gt;ownerExecutable())) {
<span class="line-modified">!                 InferredValue* singleton = executable-&gt;singletonFunction();</span>
<span class="line-modified">!                 if (JSValue value = singleton-&gt;inferredValue()) {</span>
<span class="line-removed">-                     m_graph.watchpoints().addLazily(singleton);</span>
<span class="line-removed">-                     JSFunction* function = jsCast&lt;JSFunction*&gt;(value);</span>
                      return weakJSConstant(function);
                  }
              }
              return addToGraph(GetCallee);
          }
<span class="line-new-header">--- 319,12 ---</span>
          } else if (operand.offset() == CallFrameSlot::callee) {
              // We have to do some constant-folding here because this enables CreateThis folding. Note
              // that we don&#39;t have such watchpoint-based folding for inlined uses of Callee, since in that
              // case if the function is a singleton then we already know it.
              if (FunctionExecutable* executable = jsDynamicCast&lt;FunctionExecutable*&gt;(*m_vm, m_codeBlock-&gt;ownerExecutable())) {
<span class="line-modified">!                 if (JSFunction* function = executable-&gt;singleton().inferredValue()) {</span>
<span class="line-modified">!                     m_graph.watchpoints().addLazily(executable);</span>
                      return weakJSConstant(function);
                  }
              }
              return addToGraph(GetCallee);
          }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 383,11 ***</span>
      }
  
      Node* injectLazyOperandSpeculation(Node* node)
      {
          ASSERT(node-&gt;op() == GetLocal);
<span class="line-modified">!         ASSERT(node-&gt;origin.semantic.bytecodeIndex == m_currentIndex);</span>
          ConcurrentJSLocker locker(m_inlineStackTop-&gt;m_profiledBlock-&gt;m_lock);
          LazyOperandValueProfileKey key(m_currentIndex, node-&gt;local());
          SpeculatedType prediction = m_inlineStackTop-&gt;m_lazyOperands.prediction(locker, key);
          node-&gt;variableAccessData()-&gt;predict(prediction);
          return node;
<span class="line-new-header">--- 381,11 ---</span>
      }
  
      Node* injectLazyOperandSpeculation(Node* node)
      {
          ASSERT(node-&gt;op() == GetLocal);
<span class="line-modified">!         ASSERT(node-&gt;origin.semantic.bytecodeIndex() == m_currentIndex);</span>
          ConcurrentJSLocker locker(m_inlineStackTop-&gt;m_profiledBlock-&gt;m_lock);
          LazyOperandValueProfileKey key(m_currentIndex, node-&gt;local());
          SpeculatedType prediction = m_inlineStackTop-&gt;m_lazyOperands.prediction(locker, key);
          node-&gt;variableAccessData()-&gt;predict(prediction);
          return node;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 440,13 ***</span>
                  flush(operand);
          }
  
          VariableAccessData* variableAccessData = newVariableAccessData(operand);
          variableAccessData-&gt;mergeStructureCheckHoistingFailed(
<span class="line-modified">!             m_inlineStackTop-&gt;m_exitProfile.hasExitSite(semanticOrigin.bytecodeIndex, BadCache));</span>
          variableAccessData-&gt;mergeCheckArrayHoistingFailed(
<span class="line-modified">!             m_inlineStackTop-&gt;m_exitProfile.hasExitSite(semanticOrigin.bytecodeIndex, BadIndexingType));</span>
          Node* node = addToGraph(SetLocal, OpInfo(variableAccessData), value);
          m_currentBlock-&gt;variablesAtTail.local(local) = node;
          return node;
      }
  
<span class="line-new-header">--- 438,13 ---</span>
                  flush(operand);
          }
  
          VariableAccessData* variableAccessData = newVariableAccessData(operand);
          variableAccessData-&gt;mergeStructureCheckHoistingFailed(
<span class="line-modified">!             m_inlineStackTop-&gt;m_exitProfile.hasExitSite(semanticOrigin.bytecodeIndex(), BadCache));</span>
          variableAccessData-&gt;mergeCheckArrayHoistingFailed(
<span class="line-modified">!             m_inlineStackTop-&gt;m_exitProfile.hasExitSite(semanticOrigin.bytecodeIndex(), BadIndexingType));</span>
          Node* node = addToGraph(SetLocal, OpInfo(variableAccessData), value);
          m_currentBlock-&gt;variablesAtTail.local(local) = node;
          return node;
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 496,13 ***</span>
  
          if (!argument &amp;&amp; m_codeBlock-&gt;specializationKind() == CodeForConstruct)
              variableAccessData-&gt;mergeShouldNeverUnbox(true);
  
          variableAccessData-&gt;mergeStructureCheckHoistingFailed(
<span class="line-modified">!             m_inlineStackTop-&gt;m_exitProfile.hasExitSite(semanticOrigin.bytecodeIndex, BadCache));</span>
          variableAccessData-&gt;mergeCheckArrayHoistingFailed(
<span class="line-modified">!             m_inlineStackTop-&gt;m_exitProfile.hasExitSite(semanticOrigin.bytecodeIndex, BadIndexingType));</span>
          Node* node = addToGraph(SetLocal, OpInfo(variableAccessData), value);
          m_currentBlock-&gt;variablesAtTail.argument(argument) = node;
          return node;
      }
  
<span class="line-new-header">--- 494,13 ---</span>
  
          if (!argument &amp;&amp; m_codeBlock-&gt;specializationKind() == CodeForConstruct)
              variableAccessData-&gt;mergeShouldNeverUnbox(true);
  
          variableAccessData-&gt;mergeStructureCheckHoistingFailed(
<span class="line-modified">!             m_inlineStackTop-&gt;m_exitProfile.hasExitSite(semanticOrigin.bytecodeIndex(), BadCache));</span>
          variableAccessData-&gt;mergeCheckArrayHoistingFailed(
<span class="line-modified">!             m_inlineStackTop-&gt;m_exitProfile.hasExitSite(semanticOrigin.bytecodeIndex(), BadIndexingType));</span>
          Node* node = addToGraph(SetLocal, OpInfo(variableAccessData), value);
          m_currentBlock-&gt;variablesAtTail.argument(argument) = node;
          return node;
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 561,12 ***</span>
      template&lt;typename AddFlushDirectFunc, typename AddPhantomLocalDirectFunc&gt;
      void flushForTerminalImpl(CodeOrigin origin, const AddFlushDirectFunc&amp; addFlushDirect, const AddPhantomLocalDirectFunc&amp; addPhantomLocalDirect)
      {
          origin.walkUpInlineStack(
              [&amp;] (CodeOrigin origin) {
<span class="line-modified">!                 unsigned bytecodeIndex = origin.bytecodeIndex;</span>
<span class="line-modified">!                 InlineCallFrame* inlineCallFrame = origin.inlineCallFrame;</span>
                  flushImpl(inlineCallFrame, addFlushDirect);
  
                  CodeBlock* codeBlock = m_graph.baselineCodeBlockFor(inlineCallFrame);
                  FullBytecodeLiveness&amp; fullLiveness = m_graph.livenessFor(codeBlock);
                  const FastBitVector&amp; livenessAtBytecode = fullLiveness.getLiveness(bytecodeIndex);
<span class="line-new-header">--- 559,12 ---</span>
      template&lt;typename AddFlushDirectFunc, typename AddPhantomLocalDirectFunc&gt;
      void flushForTerminalImpl(CodeOrigin origin, const AddFlushDirectFunc&amp; addFlushDirect, const AddPhantomLocalDirectFunc&amp; addPhantomLocalDirect)
      {
          origin.walkUpInlineStack(
              [&amp;] (CodeOrigin origin) {
<span class="line-modified">!                 unsigned bytecodeIndex = origin.bytecodeIndex();</span>
<span class="line-modified">!                 InlineCallFrame* inlineCallFrame = origin.inlineCallFrame();</span>
                  flushImpl(inlineCallFrame, addFlushDirect);
  
                  CodeBlock* codeBlock = m_graph.baselineCodeBlockFor(inlineCallFrame);
                  FullBytecodeLiveness&amp; fullLiveness = m_graph.livenessFor(codeBlock);
                  const FastBitVector&amp; livenessAtBytecode = fullLiveness.getLiveness(bytecodeIndex);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 830,16 ***</span>
          return objectNode;
      }
  
      SpeculatedType getPredictionWithoutOSRExit(unsigned bytecodeIndex)
      {
<span class="line-modified">!         SpeculatedType prediction;</span>
          {
<span class="line-modified">!             ConcurrentJSLocker locker(m_inlineStackTop-&gt;m_profiledBlock-&gt;m_lock);</span>
<span class="line-modified">!             prediction = m_inlineStackTop-&gt;m_profiledBlock-&gt;valueProfilePredictionForBytecodeOffset(locker, bytecodeIndex);</span>
<span class="line-modified">!         }</span>
  
          if (prediction != SpecNone)
              return prediction;
  
          // If we have no information about the values this
          // node generates, we check if by any chance it is
<span class="line-new-header">--- 828,24 ---</span>
          return objectNode;
      }
  
      SpeculatedType getPredictionWithoutOSRExit(unsigned bytecodeIndex)
      {
<span class="line-modified">!         auto getValueProfilePredictionFromForCodeBlockAndBytecodeOffset = [&amp;] (CodeBlock* codeBlock, const CodeOrigin&amp; codeOrigin)</span>
          {
<span class="line-modified">!             SpeculatedType prediction;</span>
<span class="line-modified">!             {</span>
<span class="line-modified">!                 ConcurrentJSLocker locker(codeBlock-&gt;m_lock);</span>
<span class="line-added">+                 prediction = codeBlock-&gt;valueProfilePredictionForBytecodeOffset(locker, codeOrigin.bytecodeIndex());</span>
<span class="line-added">+             }</span>
<span class="line-added">+             auto* fuzzerAgent = m_vm-&gt;fuzzerAgent();</span>
<span class="line-added">+             if (UNLIKELY(fuzzerAgent))</span>
<span class="line-added">+                 return fuzzerAgent-&gt;getPrediction(codeBlock, codeOrigin, prediction) &amp; SpecBytecodeTop;</span>
<span class="line-added">+             return prediction;</span>
<span class="line-added">+         };</span>
  
<span class="line-added">+         SpeculatedType prediction = getValueProfilePredictionFromForCodeBlockAndBytecodeOffset(m_inlineStackTop-&gt;m_profiledBlock, CodeOrigin(bytecodeIndex, inlineCallFrame()));</span>
          if (prediction != SpecNone)
              return prediction;
  
          // If we have no information about the values this
          // node generates, we check if by any chance it is
</pre>
<hr />
<pre>
<span class="line-old-header">*** 866,17 ***</span>
              CodeOrigin* codeOrigin = inlineCallFrame()-&gt;getCallerSkippingTailCalls();
              if (!codeOrigin)
                  return SpecFullTop;
  
              InlineStackEntry* stack = m_inlineStackTop;
<span class="line-modified">!             while (stack-&gt;m_inlineCallFrame != codeOrigin-&gt;inlineCallFrame)</span>
                  stack = stack-&gt;m_caller;
  
<span class="line-modified">!             bytecodeIndex = codeOrigin-&gt;bytecodeIndex;</span>
<span class="line-removed">-             CodeBlock* profiledBlock = stack-&gt;m_profiledBlock;</span>
<span class="line-removed">-             ConcurrentJSLocker locker(profiledBlock-&gt;m_lock);</span>
<span class="line-removed">-             return profiledBlock-&gt;valueProfilePredictionForBytecodeOffset(locker, bytecodeIndex);</span>
          }
  
          default:
              return SpecNone;
          }
<span class="line-new-header">--- 872,14 ---</span>
              CodeOrigin* codeOrigin = inlineCallFrame()-&gt;getCallerSkippingTailCalls();
              if (!codeOrigin)
                  return SpecFullTop;
  
              InlineStackEntry* stack = m_inlineStackTop;
<span class="line-modified">!             while (stack-&gt;m_inlineCallFrame != codeOrigin-&gt;inlineCallFrame())</span>
                  stack = stack-&gt;m_caller;
  
<span class="line-modified">!             return getValueProfilePredictionFromForCodeBlockAndBytecodeOffset(stack-&gt;m_profiledBlock, *codeOrigin);</span>
          }
  
          default:
              return SpecNone;
          }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 928,11 ***</span>
          if (m_inlineStackTop-&gt;m_exitProfile.hasExitSite(m_currentIndex, Overflow))
              node-&gt;mergeFlags(NodeMayOverflowInt32InDFG);
          if (m_inlineStackTop-&gt;m_exitProfile.hasExitSite(m_currentIndex, NegativeZero))
              node-&gt;mergeFlags(NodeMayNegZeroInDFG);
  
<span class="line-modified">!         if (!isX86() &amp;&amp; node-&gt;op() == ArithMod)</span>
              return node;
  
          {
              ArithProfile* arithProfile = m_inlineStackTop-&gt;m_profiledBlock-&gt;arithProfileForBytecodeOffset(m_currentIndex);
              if (arithProfile) {
<span class="line-new-header">--- 931,11 ---</span>
          if (m_inlineStackTop-&gt;m_exitProfile.hasExitSite(m_currentIndex, Overflow))
              node-&gt;mergeFlags(NodeMayOverflowInt32InDFG);
          if (m_inlineStackTop-&gt;m_exitProfile.hasExitSite(m_currentIndex, NegativeZero))
              node-&gt;mergeFlags(NodeMayNegZeroInDFG);
  
<span class="line-modified">!         if (!isX86() &amp;&amp; (node-&gt;op() == ArithMod || node-&gt;op() == ValueMod))</span>
              return node;
  
          {
              ArithProfile* arithProfile = m_inlineStackTop-&gt;m_profiledBlock-&gt;arithProfileForBytecodeOffset(m_currentIndex);
              if (arithProfile) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 989,10 ***</span>
<span class="line-new-header">--- 992,11 ---</span>
              switch (node-&gt;op()) {
              case UInt32ToNumber:
              case ArithAdd:
              case ArithSub:
              case ValueAdd:
<span class="line-added">+             case ValueMod:</span>
              case ArithMod: // for ArithMod &quot;MayOverflow&quot; means we tried to divide by zero, or we saw double.
                  node-&gt;mergeFlags(NodeMayOverflowInt32InBaseline);
                  break;
  
              default:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1435,14 ***</span>
          // We must repeat the work of op_enter here as we will jump right after it.
          // We jump right after it and not before it, because of some invariant saying that a CFG root cannot have predecessors in the IR.
          for (int i = 0; i &lt; stackEntry-&gt;m_codeBlock-&gt;numVars(); ++i)
              setDirect(stackEntry-&gt;remapOperand(virtualRegisterForLocal(i)), undefined, NormalSet);
  
<span class="line-removed">-         // We want to emit the SetLocals with an exit origin that points to the place we are jumping to.</span>
          unsigned oldIndex = m_currentIndex;
          auto oldStackTop = m_inlineStackTop;
          m_inlineStackTop = stackEntry;
          m_currentIndex = opcodeLengths[op_enter];
          m_exitOK = true;
          processSetLocalQueue();
          m_currentIndex = oldIndex;
          m_inlineStackTop = oldStackTop;
<span class="line-new-header">--- 1439,20 ---</span>
          // We must repeat the work of op_enter here as we will jump right after it.
          // We jump right after it and not before it, because of some invariant saying that a CFG root cannot have predecessors in the IR.
          for (int i = 0; i &lt; stackEntry-&gt;m_codeBlock-&gt;numVars(); ++i)
              setDirect(stackEntry-&gt;remapOperand(virtualRegisterForLocal(i)), undefined, NormalSet);
  
          unsigned oldIndex = m_currentIndex;
          auto oldStackTop = m_inlineStackTop;
<span class="line-added">+ </span>
<span class="line-added">+         // First, we emit check-traps operation pointing to bc#0 as exit.</span>
          m_inlineStackTop = stackEntry;
<span class="line-added">+         m_currentIndex = 0;</span>
<span class="line-added">+         m_exitOK = true;</span>
<span class="line-added">+         addToGraph(Options::usePollingTraps() ? CheckTraps : InvalidationPoint);</span>
<span class="line-added">+ </span>
<span class="line-added">+         // Then, we want to emit the SetLocals with an exit origin that points to the place we are jumping to.</span>
          m_currentIndex = opcodeLengths[op_enter];
          m_exitOK = true;
          processSetLocalQueue();
          m_currentIndex = oldIndex;
          m_inlineStackTop = oldStackTop;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1552,21 ***</span>
      }
  
      VERBOSE_LOG(&quot;    Inlining should be possible.\n&quot;);
  
      // It might be possible to inline.
<span class="line-modified">!     return codeBlock-&gt;instructionCount();</span>
  }
  
  template&lt;typename ChecksFunctor&gt;
  void ByteCodeParser::inlineCall(Node* callTargetNode, VirtualRegister result, CallVariant callee, int registerOffset, int argumentCountIncludingThis, InlineCallFrame::Kind kind, BasicBlock* continuationBlock, const ChecksFunctor&amp; insertChecks)
  {
      const Instruction* savedCurrentInstruction = m_currentInstruction;
      CodeSpecializationKind specializationKind = InlineCallFrame::specializationKindFor(kind);
  
<span class="line-removed">-     ASSERT(inliningCost(callee, argumentCountIncludingThis, kind) != UINT_MAX);</span>
<span class="line-removed">- </span>
      CodeBlock* codeBlock = callee.functionExecutable()-&gt;baselineCodeBlockFor(specializationKind);
      insertChecks(codeBlock);
  
      // FIXME: Don&#39;t flush constants!
  
<span class="line-new-header">--- 1562,19 ---</span>
      }
  
      VERBOSE_LOG(&quot;    Inlining should be possible.\n&quot;);
  
      // It might be possible to inline.
<span class="line-modified">!     return codeBlock-&gt;bytecodeCost();</span>
  }
  
  template&lt;typename ChecksFunctor&gt;
  void ByteCodeParser::inlineCall(Node* callTargetNode, VirtualRegister result, CallVariant callee, int registerOffset, int argumentCountIncludingThis, InlineCallFrame::Kind kind, BasicBlock* continuationBlock, const ChecksFunctor&amp; insertChecks)
  {
      const Instruction* savedCurrentInstruction = m_currentInstruction;
      CodeSpecializationKind specializationKind = InlineCallFrame::specializationKindFor(kind);
  
      CodeBlock* codeBlock = callee.functionExecutable()-&gt;baselineCodeBlockFor(specializationKind);
      insertChecks(codeBlock);
  
      // FIXME: Don&#39;t flush constants!
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1601,26 ***</span>
  
          calleeVariable = calleeSet-&gt;variableAccessData();
          calleeVariable-&gt;mergeShouldNeverUnbox(true);
      }
  
      if (arityFixupCount) {
          // Note: we do arity fixup in two phases:
          // 1. We get all the values we need and MovHint them to the expected locals.
<span class="line-modified">!         // 2. We SetLocal them inside the callee&#39;s CodeOrigin. This way, if we exit, the callee&#39;s</span>
          //    frame is already set up. If any SetLocal exits, we have a valid exit state.
          //    This is required because if we didn&#39;t do this in two phases, we may exit in
<span class="line-modified">!         //    the middle of arity fixup from the caller&#39;s CodeOrigin. This is unsound because if</span>
<span class="line-modified">!         //    we did the SetLocals in the caller&#39;s frame, the memcpy may clobber needed parts</span>
<span class="line-modified">!         //    of the frame right before exiting. For example, consider if we need to pad two args:</span>
          //    [arg3][arg2][arg1][arg0]
          //    [fix ][fix ][arg3][arg2][arg1][arg0]
          //    We memcpy starting from arg0 in the direction of arg3. If we were to exit at a type check
<span class="line-modified">!         //    for arg3&#39;s SetLocal in the caller&#39;s CodeOrigin, we&#39;d exit with a frame like so:</span>
          //    [arg3][arg2][arg1][arg2][arg1][arg0]
<span class="line-modified">!         //    And the caller would then just end up thinking its argument are:</span>
<span class="line-modified">!         //    [arg3][arg2][arg1][arg2]</span>
          //    which is incorrect.
  
          Node* undefined = addToGraph(JSConstant, OpInfo(m_constantUndefined));
          // The stack needs to be aligned due to the JS calling convention. Thus, we have a hole if the count of arguments is not aligned.
          // We call this hole &quot;extra slot&quot;. Consider the following case, the number of arguments is 2. If this argument
<span class="line-new-header">--- 1609,75 ---</span>
  
          calleeVariable = calleeSet-&gt;variableAccessData();
          calleeVariable-&gt;mergeShouldNeverUnbox(true);
      }
  
<span class="line-added">+     InlineStackEntry* callerStackTop = m_inlineStackTop;</span>
<span class="line-added">+     InlineStackEntry inlineStackEntry(this, codeBlock, codeBlock, callee.function(), result,</span>
<span class="line-added">+         (VirtualRegister)inlineCallFrameStart, argumentCountIncludingThis, kind, continuationBlock);</span>
<span class="line-added">+ </span>
<span class="line-added">+     // This is where the actual inlining really happens.</span>
<span class="line-added">+     unsigned oldIndex = m_currentIndex;</span>
<span class="line-added">+     m_currentIndex = 0;</span>
<span class="line-added">+ </span>
<span class="line-added">+     switch (kind) {</span>
<span class="line-added">+     case InlineCallFrame::GetterCall:</span>
<span class="line-added">+     case InlineCallFrame::SetterCall: {</span>
<span class="line-added">+         // When inlining getter and setter calls, we setup a stack frame which does not appear in the bytecode.</span>
<span class="line-added">+         // Because Inlining can switch on executable, we could have a graph like this.</span>
<span class="line-added">+         //</span>
<span class="line-added">+         // BB#0</span>
<span class="line-added">+         //     ...</span>
<span class="line-added">+         //     30: GetSetter</span>
<span class="line-added">+         //     31: MovHint(loc10)</span>
<span class="line-added">+         //     32: SetLocal(loc10)</span>
<span class="line-added">+         //     33: MovHint(loc9)</span>
<span class="line-added">+         //     34: SetLocal(loc9)</span>
<span class="line-added">+         //     ...</span>
<span class="line-added">+         //     37: GetExecutable(@30)</span>
<span class="line-added">+         //     ...</span>
<span class="line-added">+         //     41: Switch(@37)</span>
<span class="line-added">+         //</span>
<span class="line-added">+         // BB#2</span>
<span class="line-added">+         //     42: GetLocal(loc12, bc#7 of caller)</span>
<span class="line-added">+         //     ...</span>
<span class="line-added">+         //     --&gt; callee: loc9 and loc10 are arguments of callee.</span>
<span class="line-added">+         //       ...</span>
<span class="line-added">+         //       &lt;HERE, exit to callee, loc9 and loc10 are required in the bytecode&gt;</span>
<span class="line-added">+         //</span>
<span class="line-added">+         // When we prune OSR availability at the beginning of BB#2 (bc#7 in the caller), we prune loc9 and loc10&#39;s liveness because the caller does not actually have loc9 and loc10.</span>
<span class="line-added">+         // However, when we begin executing the callee, we need OSR exit to be aware of where it can recover the arguments to the setter, loc9 and loc10. The MovHints in the inlined</span>
<span class="line-added">+         // callee make it so that if we exit at &lt;HERE&gt;, we can recover loc9 and loc10.</span>
<span class="line-added">+         for (int index = 0; index &lt; argumentCountIncludingThis; ++index) {</span>
<span class="line-added">+             VirtualRegister argumentToGet = callerStackTop-&gt;remapOperand(virtualRegisterForArgument(index, registerOffset));</span>
<span class="line-added">+             Node* value = getDirect(argumentToGet);</span>
<span class="line-added">+             addToGraph(MovHint, OpInfo(argumentToGet.offset()), value);</span>
<span class="line-added">+             m_setLocalQueue.append(DelayedSetLocal { currentCodeOrigin(), argumentToGet, value, ImmediateNakedSet });</span>
<span class="line-added">+         }</span>
<span class="line-added">+         break;</span>
<span class="line-added">+     }</span>
<span class="line-added">+     default:</span>
<span class="line-added">+         break;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      if (arityFixupCount) {
          // Note: we do arity fixup in two phases:
          // 1. We get all the values we need and MovHint them to the expected locals.
<span class="line-modified">!         // 2. We SetLocal them after that. This way, if we exit, the callee&#39;s</span>
          //    frame is already set up. If any SetLocal exits, we have a valid exit state.
          //    This is required because if we didn&#39;t do this in two phases, we may exit in
<span class="line-modified">!         //    the middle of arity fixup from the callee&#39;s CodeOrigin. This is unsound because exited</span>
<span class="line-modified">!         //    code does not have arity fixup so that remaining necessary fixups are not executed.</span>
<span class="line-modified">!         //    For example, consider if we need to pad two args:</span>
          //    [arg3][arg2][arg1][arg0]
          //    [fix ][fix ][arg3][arg2][arg1][arg0]
          //    We memcpy starting from arg0 in the direction of arg3. If we were to exit at a type check
<span class="line-modified">!         //    for arg3&#39;s SetLocal in the callee&#39;s CodeOrigin, we&#39;d exit with a frame like so:</span>
          //    [arg3][arg2][arg1][arg2][arg1][arg0]
<span class="line-modified">!         //    Since we do not perform arity fixup in the callee, this is the frame used by the callee.</span>
<span class="line-modified">!         //    And the callee would then just end up thinking its argument are:</span>
<span class="line-added">+         //    [fix ][fix ][arg3][arg2][arg1][arg0]</span>
          //    which is incorrect.
  
          Node* undefined = addToGraph(JSConstant, OpInfo(m_constantUndefined));
          // The stack needs to be aligned due to the JS calling convention. Thus, we have a hole if the count of arguments is not aligned.
          // We call this hole &quot;extra slot&quot;. Consider the following case, the number of arguments is 2. If this argument
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1635,33 ***</span>
          // after:  [ ... ][arg2][arg1][arg0][header]
          //
          // In such cases, we do not need to move frames.
          if (registerOffsetAfterFixup != registerOffset) {
              for (int index = 0; index &lt; argumentCountIncludingThis; ++index) {
<span class="line-modified">!                 Node* value = get(virtualRegisterForArgument(index, registerOffset));</span>
<span class="line-modified">!                 VirtualRegister argumentToSet = m_inlineStackTop-&gt;remapOperand(virtualRegisterForArgument(index, registerOffsetAfterFixup));</span>
                  addToGraph(MovHint, OpInfo(argumentToSet.offset()), value);
                  m_setLocalQueue.append(DelayedSetLocal { currentCodeOrigin(), argumentToSet, value, ImmediateNakedSet });
              }
          }
          for (int index = 0; index &lt; arityFixupCount; ++index) {
<span class="line-modified">!             VirtualRegister argumentToSet = m_inlineStackTop-&gt;remapOperand(virtualRegisterForArgument(argumentCountIncludingThis + index, registerOffsetAfterFixup));</span>
              addToGraph(MovHint, OpInfo(argumentToSet.offset()), undefined);
              m_setLocalQueue.append(DelayedSetLocal { currentCodeOrigin(), argumentToSet, undefined, ImmediateNakedSet });
          }
  
          // At this point, it&#39;s OK to OSR exit because we finished setting up
<span class="line-modified">!         // our callee&#39;s frame. We emit an ExitOK below from the callee&#39;s CodeOrigin.</span>
      }
  
<span class="line-removed">-     InlineStackEntry inlineStackEntry(this, codeBlock, codeBlock, callee.function(), result,</span>
<span class="line-removed">-         (VirtualRegister)inlineCallFrameStart, argumentCountIncludingThis, kind, continuationBlock);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     // This is where the actual inlining really happens.</span>
<span class="line-removed">-     unsigned oldIndex = m_currentIndex;</span>
<span class="line-removed">-     m_currentIndex = 0;</span>
<span class="line-removed">- </span>
      // At this point, it&#39;s again OK to OSR exit.
      m_exitOK = true;
      addToGraph(ExitOK);
  
      processSetLocalQueue();
<span class="line-new-header">--- 1692,27 ---</span>
          // after:  [ ... ][arg2][arg1][arg0][header]
          //
          // In such cases, we do not need to move frames.
          if (registerOffsetAfterFixup != registerOffset) {
              for (int index = 0; index &lt; argumentCountIncludingThis; ++index) {
<span class="line-modified">!                 VirtualRegister argumentToGet = callerStackTop-&gt;remapOperand(virtualRegisterForArgument(index, registerOffset));</span>
<span class="line-modified">!                 Node* value = getDirect(argumentToGet);</span>
<span class="line-added">+                 VirtualRegister argumentToSet = m_inlineStackTop-&gt;remapOperand(virtualRegisterForArgument(index));</span>
                  addToGraph(MovHint, OpInfo(argumentToSet.offset()), value);
                  m_setLocalQueue.append(DelayedSetLocal { currentCodeOrigin(), argumentToSet, value, ImmediateNakedSet });
              }
          }
          for (int index = 0; index &lt; arityFixupCount; ++index) {
<span class="line-modified">!             VirtualRegister argumentToSet = m_inlineStackTop-&gt;remapOperand(virtualRegisterForArgument(argumentCountIncludingThis + index));</span>
              addToGraph(MovHint, OpInfo(argumentToSet.offset()), undefined);
              m_setLocalQueue.append(DelayedSetLocal { currentCodeOrigin(), argumentToSet, undefined, ImmediateNakedSet });
          }
  
          // At this point, it&#39;s OK to OSR exit because we finished setting up
<span class="line-modified">!         // our callee&#39;s frame. We emit an ExitOK below.</span>
      }
  
      // At this point, it&#39;s again OK to OSR exit.
      m_exitOK = true;
      addToGraph(ExitOK);
  
      processSetLocalQueue();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1822,12 ***</span>
          m_inlineStackTop-&gt;remapOperand(VirtualRegister(registerOffset)).offset();
  
          ensureLocals(VirtualRegister(remappedRegisterOffset).toLocal());
  
          int argumentStart = registerOffset + CallFrame::headerSizeInRegisters;
<span class="line-modified">!         int remappedArgumentStart =</span>
<span class="line-removed">-         m_inlineStackTop-&gt;remapOperand(VirtualRegister(argumentStart)).offset();</span>
  
          LoadVarargsData* data = m_graph.m_loadVarargsData.add();
          data-&gt;start = VirtualRegister(remappedArgumentStart + 1);
          data-&gt;count = VirtualRegister(remappedRegisterOffset + CallFrameSlot::argumentCount);
          data-&gt;offset = argumentsOffset;
<span class="line-new-header">--- 1873,11 ---</span>
          m_inlineStackTop-&gt;remapOperand(VirtualRegister(registerOffset)).offset();
  
          ensureLocals(VirtualRegister(remappedRegisterOffset).toLocal());
  
          int argumentStart = registerOffset + CallFrame::headerSizeInRegisters;
<span class="line-modified">!         int remappedArgumentStart = m_inlineStackTop-&gt;remapOperand(VirtualRegister(argumentStart)).offset();</span>
  
          LoadVarargsData* data = m_graph.m_loadVarargsData.add();
          data-&gt;start = VirtualRegister(remappedArgumentStart + 1);
          data-&gt;count = VirtualRegister(remappedRegisterOffset + CallFrameSlot::argumentCount);
          data-&gt;offset = argumentsOffset;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1843,24 ***</span>
          // and argumentsArgument for the baseline JIT. However, we only need a Phantom for
          // callTargetNode because the other 2 are still in use and alive at this point.
          addToGraph(Phantom, callTargetNode);
  
          // In DFG IR before SSA, we cannot insert control flow between after the
<span class="line-modified">!         // LoadVarargs and the last SetArgument. This isn&#39;t a problem once we get to DFG</span>
          // SSA. Fortunately, we also have other reasons for not inserting control flow
          // before SSA.
  
          VariableAccessData* countVariable = newVariableAccessData(VirtualRegister(remappedRegisterOffset + CallFrameSlot::argumentCount));
          // This is pretty lame, but it will force the count to be flushed as an int. This doesn&#39;t
<span class="line-modified">!         // matter very much, since our use of a SetArgument and Flushes for this local slot is</span>
          // mostly just a formality.
          countVariable-&gt;predict(SpecInt32Only);
          countVariable-&gt;mergeIsProfitableToUnbox(true);
<span class="line-modified">!         Node* setArgumentCount = addToGraph(SetArgument, OpInfo(countVariable));</span>
          m_currentBlock-&gt;variablesAtTail.setOperand(countVariable-&gt;local(), setArgumentCount);
  
          set(VirtualRegister(argumentStart), get(thisArgument), ImmediateNakedSet);
          for (unsigned argument = 1; argument &lt; maxNumArguments; ++argument) {
              VariableAccessData* variable = newVariableAccessData(VirtualRegister(remappedArgumentStart + argument));
              variable-&gt;mergeShouldNeverUnbox(true); // We currently have nowhere to put the type check on the LoadVarargs. LoadVarargs is effectful, so after it finishes, we cannot exit.
  
              // For a while it had been my intention to do things like this inside the
<span class="line-new-header">--- 1893,25 ---</span>
          // and argumentsArgument for the baseline JIT. However, we only need a Phantom for
          // callTargetNode because the other 2 are still in use and alive at this point.
          addToGraph(Phantom, callTargetNode);
  
          // In DFG IR before SSA, we cannot insert control flow between after the
<span class="line-modified">!         // LoadVarargs and the last SetArgumentDefinitely. This isn&#39;t a problem once we get to DFG</span>
          // SSA. Fortunately, we also have other reasons for not inserting control flow
          // before SSA.
  
          VariableAccessData* countVariable = newVariableAccessData(VirtualRegister(remappedRegisterOffset + CallFrameSlot::argumentCount));
          // This is pretty lame, but it will force the count to be flushed as an int. This doesn&#39;t
<span class="line-modified">!         // matter very much, since our use of a SetArgumentDefinitely and Flushes for this local slot is</span>
          // mostly just a formality.
          countVariable-&gt;predict(SpecInt32Only);
          countVariable-&gt;mergeIsProfitableToUnbox(true);
<span class="line-modified">!         Node* setArgumentCount = addToGraph(SetArgumentDefinitely, OpInfo(countVariable));</span>
          m_currentBlock-&gt;variablesAtTail.setOperand(countVariable-&gt;local(), setArgumentCount);
  
          set(VirtualRegister(argumentStart), get(thisArgument), ImmediateNakedSet);
<span class="line-added">+         unsigned numSetArguments = 0;</span>
          for (unsigned argument = 1; argument &lt; maxNumArguments; ++argument) {
              VariableAccessData* variable = newVariableAccessData(VirtualRegister(remappedArgumentStart + argument));
              variable-&gt;mergeShouldNeverUnbox(true); // We currently have nowhere to put the type check on the LoadVarargs. LoadVarargs is effectful, so after it finishes, we cannot exit.
  
              // For a while it had been my intention to do things like this inside the
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1876,12 ***</span>
                  ConcurrentJSLocker locker(codeBlock-&gt;m_lock);
                  ValueProfile&amp; profile = codeBlock-&gt;valueProfileForArgument(argument);
                  variable-&gt;predict(profile.computeUpdatedPrediction(locker));
              }
  
<span class="line-modified">!             Node* setArgument = addToGraph(SetArgument, OpInfo(variable));</span>
              m_currentBlock-&gt;variablesAtTail.setOperand(variable-&gt;local(), setArgument);
          }
      };
  
      // Intrinsics and internal functions can only be inlined if we&#39;re not doing varargs. This is because
      // we currently don&#39;t have any way of getting profiling information for arguments to non-JS varargs
<span class="line-new-header">--- 1927,13 ---</span>
                  ConcurrentJSLocker locker(codeBlock-&gt;m_lock);
                  ValueProfile&amp; profile = codeBlock-&gt;valueProfileForArgument(argument);
                  variable-&gt;predict(profile.computeUpdatedPrediction(locker));
              }
  
<span class="line-modified">!             Node* setArgument = addToGraph(numSetArguments &gt;= mandatoryMinimum ? SetArgumentMaybe : SetArgumentDefinitely, OpInfo(variable));</span>
              m_currentBlock-&gt;variablesAtTail.setOperand(variable-&gt;local(), setArgument);
<span class="line-added">+             ++numSetArguments;</span>
          }
      };
  
      // Intrinsics and internal functions can only be inlined if we&#39;re not doing varargs. This is because
      // we currently don&#39;t have any way of getting profiling information for arguments to non-JS varargs
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1890,21 ***</span>
      // those arguments. Even worse, if the intrinsic decides to exit, it won&#39;t really have anywhere to
      // exit to: LoadVarargs is effectful and it&#39;s part of the op_call_varargs, so we can&#39;t exit without
      // calling LoadVarargs twice.
      inlineCall(callTargetNode, result, callVariant, registerOffset, maxNumArguments, kind, nullptr, insertChecks);
  
      VERBOSE_LOG(&quot;Successful inlining (varargs, monomorphic).\nStack: &quot;, currentCodeOrigin(), &quot;\n&quot;);
      return true;
  }
  
  unsigned ByteCodeParser::getInliningBalance(const CallLinkStatus&amp; callLinkStatus, CodeSpecializationKind specializationKind)
  {
<span class="line-modified">!     unsigned inliningBalance = Options::maximumFunctionForCallInlineCandidateInstructionCount();</span>
      if (specializationKind == CodeForConstruct)
<span class="line-modified">!         inliningBalance = std::min(inliningBalance, Options::maximumFunctionForConstructInlineCandidateInstructionCount());</span>
      if (callLinkStatus.isClosureCall())
<span class="line-modified">!         inliningBalance = std::min(inliningBalance, Options::maximumFunctionForClosureCallInlineCandidateInstructionCount());</span>
      return inliningBalance;
  }
  
  ByteCodeParser::CallOptimizationResult ByteCodeParser::handleInlining(
      Node* callTargetNode, VirtualRegister result, const CallLinkStatus&amp; callLinkStatus,
<span class="line-new-header">--- 1942,22 ---</span>
      // those arguments. Even worse, if the intrinsic decides to exit, it won&#39;t really have anywhere to
      // exit to: LoadVarargs is effectful and it&#39;s part of the op_call_varargs, so we can&#39;t exit without
      // calling LoadVarargs twice.
      inlineCall(callTargetNode, result, callVariant, registerOffset, maxNumArguments, kind, nullptr, insertChecks);
  
<span class="line-added">+ </span>
      VERBOSE_LOG(&quot;Successful inlining (varargs, monomorphic).\nStack: &quot;, currentCodeOrigin(), &quot;\n&quot;);
      return true;
  }
  
  unsigned ByteCodeParser::getInliningBalance(const CallLinkStatus&amp; callLinkStatus, CodeSpecializationKind specializationKind)
  {
<span class="line-modified">!     unsigned inliningBalance = Options::maximumFunctionForCallInlineCandidateBytecodeCost();</span>
      if (specializationKind == CodeForConstruct)
<span class="line-modified">!         inliningBalance = std::min(inliningBalance, Options::maximumFunctionForConstructInlineCandidateBytecoodeCost());</span>
      if (callLinkStatus.isClosureCall())
<span class="line-modified">!         inliningBalance = std::min(inliningBalance, Options::maximumFunctionForClosureCallInlineCandidateBytecodeCost());</span>
      return inliningBalance;
  }
  
  ByteCodeParser::CallOptimizationResult ByteCodeParser::handleInlining(
      Node* callTargetNode, VirtualRegister result, const CallLinkStatus&amp; callLinkStatus,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2055,11 ***</span>
      } else {
          addToGraph(CheckBadCell);
          addToGraph(Phantom, myCallTargetNode);
          emitArgumentPhantoms(registerOffset, argumentCountIncludingThis);
  
<span class="line-modified">!         set(result, addToGraph(BottomValue));</span>
          VERBOSE_LOG(&quot;couldTakeSlowPath was false\n&quot;);
      }
  
      m_currentIndex = nextOffset;
      m_exitOK = true; // Origin changed, so it&#39;s fine to exit again.
<span class="line-new-header">--- 2108,12 ---</span>
      } else {
          addToGraph(CheckBadCell);
          addToGraph(Phantom, myCallTargetNode);
          emitArgumentPhantoms(registerOffset, argumentCountIncludingThis);
  
<span class="line-modified">!         if (result.isValid())</span>
<span class="line-added">+             set(result, addToGraph(BottomValue));</span>
          VERBOSE_LOG(&quot;couldTakeSlowPath was false\n&quot;);
      }
  
      m_currentIndex = nextOffset;
      m_exitOK = true; // Origin changed, so it&#39;s fine to exit again.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2294,17 ***</span>
                  Structure* arrayPrototypeStructure = globalObject-&gt;arrayPrototype()-&gt;structure(*m_vm);
                  Structure* objectPrototypeStructure = globalObject-&gt;objectPrototype()-&gt;structure(*m_vm);
  
                  // FIXME: We could easily relax the Array/Object.prototype transition as long as we OSR exitted if we saw a hole.
                  // https://bugs.webkit.org/show_bug.cgi?id=173171
<span class="line-modified">!                 if (globalObject-&gt;arraySpeciesWatchpoint().state() == IsWatched</span>
                      &amp;&amp; globalObject-&gt;havingABadTimeWatchpoint()-&gt;isStillValid()
                      &amp;&amp; arrayPrototypeStructure-&gt;transitionWatchpointSetIsStillValid()
                      &amp;&amp; objectPrototypeStructure-&gt;transitionWatchpointSetIsStillValid()
                      &amp;&amp; globalObject-&gt;arrayPrototypeChainIsSane()) {
  
<span class="line-modified">!                     m_graph.watchpoints().addLazily(globalObject-&gt;arraySpeciesWatchpoint());</span>
                      m_graph.watchpoints().addLazily(globalObject-&gt;havingABadTimeWatchpoint());
                      m_graph.registerAndWatchStructureTransition(arrayPrototypeStructure);
                      m_graph.registerAndWatchStructureTransition(objectPrototypeStructure);
  
                      insertChecks();
<span class="line-new-header">--- 2348,17 ---</span>
                  Structure* arrayPrototypeStructure = globalObject-&gt;arrayPrototype()-&gt;structure(*m_vm);
                  Structure* objectPrototypeStructure = globalObject-&gt;objectPrototype()-&gt;structure(*m_vm);
  
                  // FIXME: We could easily relax the Array/Object.prototype transition as long as we OSR exitted if we saw a hole.
                  // https://bugs.webkit.org/show_bug.cgi?id=173171
<span class="line-modified">!                 if (globalObject-&gt;arraySpeciesWatchpointSet().state() == IsWatched</span>
                      &amp;&amp; globalObject-&gt;havingABadTimeWatchpoint()-&gt;isStillValid()
                      &amp;&amp; arrayPrototypeStructure-&gt;transitionWatchpointSetIsStillValid()
                      &amp;&amp; objectPrototypeStructure-&gt;transitionWatchpointSetIsStillValid()
                      &amp;&amp; globalObject-&gt;arrayPrototypeChainIsSane()) {
  
<span class="line-modified">!                     m_graph.watchpoints().addLazily(globalObject-&gt;arraySpeciesWatchpointSet());</span>
                      m_graph.watchpoints().addLazily(globalObject-&gt;havingABadTimeWatchpoint());
                      m_graph.registerAndWatchStructureTransition(arrayPrototypeStructure);
                      m_graph.registerAndWatchStructureTransition(objectPrototypeStructure);
  
                      insertChecks();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3187,13 ***</span>
                      isLittleEndian = FalseTriState;
                  else {
                      littleEndianChild = get(virtualRegisterForArgument(2, registerOffset));
                      if (littleEndianChild-&gt;hasConstant()) {
                          JSValue constant = littleEndianChild-&gt;constant()-&gt;value();
<span class="line-modified">!                         isLittleEndian = constant.pureToBoolean();</span>
<span class="line-modified">!                         if (isLittleEndian != MixedTriState)</span>
<span class="line-modified">!                             littleEndianChild = nullptr;</span>
                      } else
                          isLittleEndian = MixedTriState;
                  }
              }
  
<span class="line-new-header">--- 3241,15 ---</span>
                      isLittleEndian = FalseTriState;
                  else {
                      littleEndianChild = get(virtualRegisterForArgument(2, registerOffset));
                      if (littleEndianChild-&gt;hasConstant()) {
                          JSValue constant = littleEndianChild-&gt;constant()-&gt;value();
<span class="line-modified">!                         if (constant) {</span>
<span class="line-modified">!                             isLittleEndian = constant.pureToBoolean();</span>
<span class="line-modified">!                             if (isLittleEndian != MixedTriState)</span>
<span class="line-added">+                                 littleEndianChild = nullptr;</span>
<span class="line-added">+                         }</span>
                      } else
                          isLittleEndian = MixedTriState;
                  }
              }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3270,13 ***</span>
                      isLittleEndian = FalseTriState;
                  else {
                      littleEndianChild = get(virtualRegisterForArgument(3, registerOffset));
                      if (littleEndianChild-&gt;hasConstant()) {
                          JSValue constant = littleEndianChild-&gt;constant()-&gt;value();
<span class="line-modified">!                         isLittleEndian = constant.pureToBoolean();</span>
<span class="line-modified">!                         if (isLittleEndian != MixedTriState)</span>
<span class="line-modified">!                             littleEndianChild = nullptr;</span>
                      } else
                          isLittleEndian = MixedTriState;
                  }
              }
  
<span class="line-new-header">--- 3326,15 ---</span>
                      isLittleEndian = FalseTriState;
                  else {
                      littleEndianChild = get(virtualRegisterForArgument(3, registerOffset));
                      if (littleEndianChild-&gt;hasConstant()) {
                          JSValue constant = littleEndianChild-&gt;constant()-&gt;value();
<span class="line-modified">!                         if (constant) {</span>
<span class="line-modified">!                             isLittleEndian = constant.pureToBoolean();</span>
<span class="line-modified">!                             if (isLittleEndian != MixedTriState)</span>
<span class="line-added">+                                 littleEndianChild = nullptr;</span>
<span class="line-added">+                         }</span>
                      } else
                          isLittleEndian = MixedTriState;
                  }
              }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3452,11 ***</span>
          }
  
          // We can use a BitLShift here because typed arrays will never have a byteLength
          // that overflows int32.
          Node* shiftNode = jsConstant(jsNumber(logSize));
<span class="line-modified">!         set(result, addToGraph(BitLShift, lengthNode, shiftNode));</span>
  
          return true;
      }
  
      case TypedArrayLengthIntrinsic: {
<span class="line-new-header">--- 3510,11 ---</span>
          }
  
          // We can use a BitLShift here because typed arrays will never have a byteLength
          // that overflows int32.
          Node* shiftNode = jsConstant(jsNumber(logSize));
<span class="line-modified">!         set(result, addToGraph(ArithBitLShift, lengthNode, shiftNode));</span>
  
          return true;
      }
  
      case TypedArrayLengthIntrinsic: {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4363,12 ***</span>
      // 1) That&#39;s how handleCall() sees the arguments.
      // 2) If we inline then this ensures that the arguments are flushed so that if you use
      //    the dreaded arguments object on the getter, the right things happen. Well, sort of -
      //    since we only really care about &#39;this&#39; in this case. But we&#39;re not going to take that
      //    shortcut.
<span class="line-modified">!     int nextRegister = registerOffset + CallFrame::headerSizeInRegisters;</span>
<span class="line-removed">-     set(VirtualRegister(nextRegister++), base, ImmediateNakedSet);</span>
  
      // We&#39;ve set some locals, but they are not user-visible. It&#39;s still OK to exit from here.
      m_exitOK = true;
      addToGraph(ExitOK);
  
<span class="line-new-header">--- 4421,11 ---</span>
      // 1) That&#39;s how handleCall() sees the arguments.
      // 2) If we inline then this ensures that the arguments are flushed so that if you use
      //    the dreaded arguments object on the getter, the right things happen. Well, sort of -
      //    since we only really care about &#39;this&#39; in this case. But we&#39;re not going to take that
      //    shortcut.
<span class="line-modified">!     set(virtualRegisterForArgument(0, registerOffset), base, ImmediateNakedSet);</span>
  
      // We&#39;ve set some locals, but they are not user-visible. It&#39;s still OK to exit from here.
      m_exitOK = true;
      addToGraph(ExitOK);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4547,13 ***</span>
  
          ensureLocals(
              m_inlineStackTop-&gt;remapOperand(
                  VirtualRegister(registerOffset)).toLocal());
  
<span class="line-modified">!         int nextRegister = registerOffset + CallFrame::headerSizeInRegisters;</span>
<span class="line-modified">!         set(VirtualRegister(nextRegister++), base, ImmediateNakedSet);</span>
<span class="line-removed">-         set(VirtualRegister(nextRegister++), value, ImmediateNakedSet);</span>
  
          // We&#39;ve set some locals, but they are not user-visible. It&#39;s still OK to exit from here.
          m_exitOK = true;
          addToGraph(ExitOK);
  
<span class="line-new-header">--- 4604,12 ---</span>
  
          ensureLocals(
              m_inlineStackTop-&gt;remapOperand(
                  VirtualRegister(registerOffset)).toLocal());
  
<span class="line-modified">!         set(virtualRegisterForArgument(0, registerOffset), base, ImmediateNakedSet);</span>
<span class="line-modified">!         set(virtualRegisterForArgument(1, registerOffset), value, ImmediateNakedSet);</span>
  
          // We&#39;ve set some locals, but they are not user-visible. It&#39;s still OK to exit from here.
          m_exitOK = true;
          addToGraph(ExitOK);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4663,22 ***</span>
          auto addResult = m_graph.m_rootToArguments.add(m_currentBlock, ArgumentsVector());
          RELEASE_ASSERT(addResult.isNewEntry);
          ArgumentsVector&amp; entrypointArguments = addResult.iterator-&gt;value;
          entrypointArguments.resize(m_numArguments);
  
<span class="line-modified">!         // We will emit SetArgument nodes. They don&#39;t exit, but we&#39;re at the top of an op_enter so</span>
          // exitOK = true.
          m_exitOK = true;
          for (unsigned argument = 0; argument &lt; m_numArguments; ++argument) {
              VariableAccessData* variable = newVariableAccessData(
                  virtualRegisterForArgument(argument));
              variable-&gt;mergeStructureCheckHoistingFailed(
                  m_inlineStackTop-&gt;m_exitProfile.hasExitSite(m_currentIndex, BadCache));
              variable-&gt;mergeCheckArrayHoistingFailed(
                  m_inlineStackTop-&gt;m_exitProfile.hasExitSite(m_currentIndex, BadIndexingType));
  
<span class="line-modified">!             Node* setArgument = addToGraph(SetArgument, OpInfo(variable));</span>
              entrypointArguments[argument] = setArgument;
              m_currentBlock-&gt;variablesAtTail.setArgumentFirstTime(argument, setArgument);
          }
      }
  
<span class="line-new-header">--- 4719,22 ---</span>
          auto addResult = m_graph.m_rootToArguments.add(m_currentBlock, ArgumentsVector());
          RELEASE_ASSERT(addResult.isNewEntry);
          ArgumentsVector&amp; entrypointArguments = addResult.iterator-&gt;value;
          entrypointArguments.resize(m_numArguments);
  
<span class="line-modified">!         // We will emit SetArgumentDefinitely nodes. They don&#39;t exit, but we&#39;re at the top of an op_enter so</span>
          // exitOK = true.
          m_exitOK = true;
          for (unsigned argument = 0; argument &lt; m_numArguments; ++argument) {
              VariableAccessData* variable = newVariableAccessData(
                  virtualRegisterForArgument(argument));
              variable-&gt;mergeStructureCheckHoistingFailed(
                  m_inlineStackTop-&gt;m_exitProfile.hasExitSite(m_currentIndex, BadCache));
              variable-&gt;mergeCheckArrayHoistingFailed(
                  m_inlineStackTop-&gt;m_exitProfile.hasExitSite(m_currentIndex, BadIndexingType));
  
<span class="line-modified">!             Node* setArgument = addToGraph(SetArgumentDefinitely, OpInfo(variable));</span>
              entrypointArguments[argument] = setArgument;
              m_currentBlock-&gt;variablesAtTail.setArgumentFirstTime(argument, setArgument);
          }
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4727,22 ***</span>
          switch (opcodeID) {
  
          // === Function entry opcodes ===
  
          case op_enter: {
              Node* undefined = addToGraph(JSConstant, OpInfo(m_constantUndefined));
              // Initialize all locals to undefined.
              for (int i = 0; i &lt; m_inlineStackTop-&gt;m_codeBlock-&gt;numVars(); ++i)
                  set(virtualRegisterForLocal(i), undefined, ImmediateNakedSet);
<span class="line-removed">- </span>
              NEXT_OPCODE(op_enter);
          }
  
          case op_to_this: {
              Node* op1 = getThis();
              auto&amp; metadata = currentInstruction-&gt;as&lt;OpToThis&gt;().metadata(codeBlock);
<span class="line-modified">!             Structure* cachedStructure = metadata.m_cachedStructure.get();</span>
              if (metadata.m_toThisStatus != ToThisOK
                  || !cachedStructure
                  || cachedStructure-&gt;classInfo()-&gt;methodTable.toThis != JSObject::info()-&gt;methodTable.toThis
                  || m_inlineStackTop-&gt;m_profiledBlock-&gt;couldTakeSlowCase(m_currentIndex)
                  || m_inlineStackTop-&gt;m_exitProfile.hasExitSite(m_currentIndex, BadCache)
<span class="line-new-header">--- 4783,25 ---</span>
          switch (opcodeID) {
  
          // === Function entry opcodes ===
  
          case op_enter: {
<span class="line-added">+             addToGraph(Options::usePollingTraps() ? CheckTraps : InvalidationPoint);</span>
              Node* undefined = addToGraph(JSConstant, OpInfo(m_constantUndefined));
              // Initialize all locals to undefined.
              for (int i = 0; i &lt; m_inlineStackTop-&gt;m_codeBlock-&gt;numVars(); ++i)
                  set(virtualRegisterForLocal(i), undefined, ImmediateNakedSet);
              NEXT_OPCODE(op_enter);
          }
  
          case op_to_this: {
              Node* op1 = getThis();
              auto&amp; metadata = currentInstruction-&gt;as&lt;OpToThis&gt;().metadata(codeBlock);
<span class="line-modified">!             StructureID cachedStructureID = metadata.m_cachedStructureID;</span>
<span class="line-added">+             Structure* cachedStructure = nullptr;</span>
<span class="line-added">+             if (cachedStructureID)</span>
<span class="line-added">+                 cachedStructure = m_vm-&gt;heap.structureIDTable().get(cachedStructureID);</span>
              if (metadata.m_toThisStatus != ToThisOK
                  || !cachedStructure
                  || cachedStructure-&gt;classInfo()-&gt;methodTable.toThis != JSObject::info()-&gt;methodTable.toThis
                  || m_inlineStackTop-&gt;m_profiledBlock-&gt;couldTakeSlowCase(m_currentIndex)
                  || m_inlineStackTop-&gt;m_exitProfile.hasExitSite(m_currentIndex, BadCache)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4825,12 ***</span>
              int startOperand = bytecode.m_argv.offset();
              int numOperands = bytecode.m_argc;
              ArrayAllocationProfile&amp; profile = bytecode.metadata(codeBlock).m_arrayAllocationProfile;
              for (int operandIdx = startOperand; operandIdx &gt; startOperand - numOperands; --operandIdx)
                  addVarArgChild(get(VirtualRegister(operandIdx)));
<span class="line-modified">!             unsigned vectorLengthHint = std::max&lt;unsigned&gt;(profile.vectorLengthHint(), numOperands);</span>
<span class="line-modified">!             set(bytecode.m_dst, addToGraph(Node::VarArg, NewArray, OpInfo(profile.selectIndexingType()), OpInfo(vectorLengthHint)));</span>
              NEXT_OPCODE(op_new_array);
          }
  
          case op_new_array_with_spread: {
              auto bytecode = currentInstruction-&gt;as&lt;OpNewArrayWithSpread&gt;();
<span class="line-new-header">--- 4884,12 ---</span>
              int startOperand = bytecode.m_argv.offset();
              int numOperands = bytecode.m_argc;
              ArrayAllocationProfile&amp; profile = bytecode.metadata(codeBlock).m_arrayAllocationProfile;
              for (int operandIdx = startOperand; operandIdx &gt; startOperand - numOperands; --operandIdx)
                  addVarArgChild(get(VirtualRegister(operandIdx)));
<span class="line-modified">!             unsigned vectorLengthHint = std::max&lt;unsigned&gt;(profile.vectorLengthHintConcurrently(), numOperands);</span>
<span class="line-modified">!             set(bytecode.m_dst, addToGraph(Node::VarArg, NewArray, OpInfo(profile.selectIndexingTypeConcurrently()), OpInfo(vectorLengthHint)));</span>
              NEXT_OPCODE(op_new_array);
          }
  
          case op_new_array_with_spread: {
              auto bytecode = currentInstruction-&gt;as&lt;OpNewArrayWithSpread&gt;();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4856,11 ***</span>
          }
  
          case op_new_array_with_size: {
              auto bytecode = currentInstruction-&gt;as&lt;OpNewArrayWithSize&gt;();
              ArrayAllocationProfile&amp; profile = bytecode.metadata(codeBlock).m_arrayAllocationProfile;
<span class="line-modified">!             set(bytecode.m_dst, addToGraph(NewArrayWithSize, OpInfo(profile.selectIndexingType()), get(bytecode.m_length)));</span>
              NEXT_OPCODE(op_new_array_with_size);
          }
  
          case op_new_array_buffer: {
              auto bytecode = currentInstruction-&gt;as&lt;OpNewArrayBuffer&gt;();
<span class="line-new-header">--- 4915,11 ---</span>
          }
  
          case op_new_array_with_size: {
              auto bytecode = currentInstruction-&gt;as&lt;OpNewArrayWithSize&gt;();
              ArrayAllocationProfile&amp; profile = bytecode.metadata(codeBlock).m_arrayAllocationProfile;
<span class="line-modified">!             set(bytecode.m_dst, addToGraph(NewArrayWithSize, OpInfo(profile.selectIndexingTypeConcurrently()), get(bytecode.m_length)));</span>
              NEXT_OPCODE(op_new_array_with_size);
          }
  
          case op_new_array_buffer: {
              auto bytecode = currentInstruction-&gt;as&lt;OpNewArrayBuffer&gt;();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4916,12 ***</span>
  
          // === Bitwise operations ===
  
          case op_bitnot: {
              auto bytecode = currentInstruction-&gt;as&lt;OpBitnot&gt;();
              Node* op1 = get(bytecode.m_operand);
<span class="line-modified">!             set(bytecode.m_dst, addToGraph(ArithBitNot, op1));</span>
              NEXT_OPCODE(op_bitnot);
          }
  
          case op_bitand: {
              auto bytecode = currentInstruction-&gt;as&lt;OpBitand&gt;();
<span class="line-new-header">--- 4975,16 ---</span>
  
          // === Bitwise operations ===
  
          case op_bitnot: {
              auto bytecode = currentInstruction-&gt;as&lt;OpBitnot&gt;();
<span class="line-added">+             SpeculatedType prediction = getPrediction();</span>
              Node* op1 = get(bytecode.m_operand);
<span class="line-modified">!             if (op1-&gt;hasNumberOrAnyIntResult())</span>
<span class="line-added">+                 set(bytecode.m_dst, addToGraph(ArithBitNot, op1));</span>
<span class="line-added">+             else</span>
<span class="line-added">+                 set(bytecode.m_dst, addToGraph(ValueBitNot, OpInfo(), OpInfo(prediction), op1));</span>
              NEXT_OPCODE(op_bitnot);
          }
  
          case op_bitand: {
              auto bytecode = currentInstruction-&gt;as&lt;OpBitand&gt;();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4969,11 ***</span>
  
          case op_lshift: {
              auto bytecode = currentInstruction-&gt;as&lt;OpLshift&gt;();
              Node* op1 = get(bytecode.m_lhs);
              Node* op2 = get(bytecode.m_rhs);
<span class="line-modified">!             set(bytecode.m_dst, addToGraph(BitLShift, op1, op2));</span>
              NEXT_OPCODE(op_lshift);
          }
  
          case op_urshift: {
              auto bytecode = currentInstruction-&gt;as&lt;OpUrshift&gt;();
<span class="line-new-header">--- 5032,16 ---</span>
  
          case op_lshift: {
              auto bytecode = currentInstruction-&gt;as&lt;OpLshift&gt;();
              Node* op1 = get(bytecode.m_lhs);
              Node* op2 = get(bytecode.m_rhs);
<span class="line-modified">!             if (op1-&gt;hasNumberOrAnyIntResult() &amp;&amp; op2-&gt;hasNumberOrAnyIntResult())</span>
<span class="line-added">+                 set(bytecode.m_dst, addToGraph(ArithBitLShift, op1, op2));</span>
<span class="line-added">+             else {</span>
<span class="line-added">+                 SpeculatedType prediction = getPredictionWithoutOSRExit();</span>
<span class="line-added">+                 set(bytecode.m_dst, addToGraph(ValueBitLShift, OpInfo(), OpInfo(prediction), op1, op2));</span>
<span class="line-added">+             }</span>
              NEXT_OPCODE(op_lshift);
          }
  
          case op_urshift: {
              auto bytecode = currentInstruction-&gt;as&lt;OpUrshift&gt;();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5053,21 ***</span>
  
          case op_mod: {
              auto bytecode = currentInstruction-&gt;as&lt;OpMod&gt;();
              Node* op1 = get(bytecode.m_lhs);
              Node* op2 = get(bytecode.m_rhs);
<span class="line-modified">!             set(bytecode.m_dst, makeSafe(addToGraph(ArithMod, op1, op2)));</span>
              NEXT_OPCODE(op_mod);
          }
  
          case op_pow: {
<span class="line-removed">-             // FIXME: ArithPow(Untyped, Untyped) should be supported as the same to ArithMul, ArithSub etc.</span>
<span class="line-removed">-             // https://bugs.webkit.org/show_bug.cgi?id=160012</span>
              auto bytecode = currentInstruction-&gt;as&lt;OpPow&gt;();
              Node* op1 = get(bytecode.m_lhs);
              Node* op2 = get(bytecode.m_rhs);
<span class="line-modified">!             set(bytecode.m_dst, addToGraph(ArithPow, op1, op2));</span>
              NEXT_OPCODE(op_pow);
          }
  
          case op_div: {
              auto bytecode = currentInstruction-&gt;as&lt;OpDiv&gt;();
<span class="line-new-header">--- 5121,25 ---</span>
  
          case op_mod: {
              auto bytecode = currentInstruction-&gt;as&lt;OpMod&gt;();
              Node* op1 = get(bytecode.m_lhs);
              Node* op2 = get(bytecode.m_rhs);
<span class="line-modified">!             if (op1-&gt;hasNumberResult() &amp;&amp; op2-&gt;hasNumberResult())</span>
<span class="line-added">+                 set(bytecode.m_dst, makeSafe(addToGraph(ArithMod, op1, op2)));</span>
<span class="line-added">+             else</span>
<span class="line-added">+                 set(bytecode.m_dst, makeSafe(addToGraph(ValueMod, op1, op2)));</span>
              NEXT_OPCODE(op_mod);
          }
  
          case op_pow: {
              auto bytecode = currentInstruction-&gt;as&lt;OpPow&gt;();
              Node* op1 = get(bytecode.m_lhs);
              Node* op2 = get(bytecode.m_rhs);
<span class="line-modified">!             if (op1-&gt;hasNumberOrAnyIntResult() &amp;&amp; op2-&gt;hasNumberOrAnyIntResult())</span>
<span class="line-added">+                 set(bytecode.m_dst, addToGraph(ArithPow, op1, op2));</span>
<span class="line-added">+             else</span>
<span class="line-added">+                 set(bytecode.m_dst, addToGraph(ValuePow, op1, op2));</span>
              NEXT_OPCODE(op_pow);
          }
  
          case op_div: {
              auto bytecode = currentInstruction-&gt;as&lt;OpDiv&gt;();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5390,11 ***</span>
              bool compiledAsGetById = false;
              GetByIdStatus getByIdStatus;
              unsigned identifierNumber = 0;
              {
                  ConcurrentJSLocker locker(m_inlineStackTop-&gt;m_profiledBlock-&gt;m_lock);
<span class="line-modified">!                 ByValInfo* byValInfo = m_inlineStackTop-&gt;m_baselineMap.get(CodeOrigin(currentCodeOrigin().bytecodeIndex)).byValInfo;</span>
                  // FIXME: When the bytecode is not compiled in the baseline JIT, byValInfo becomes null.
                  // At that time, there is no information.
                  if (byValInfo
                      &amp;&amp; byValInfo-&gt;stubInfo
                      &amp;&amp; !byValInfo-&gt;tookSlowPath
<span class="line-new-header">--- 5462,11 ---</span>
              bool compiledAsGetById = false;
              GetByIdStatus getByIdStatus;
              unsigned identifierNumber = 0;
              {
                  ConcurrentJSLocker locker(m_inlineStackTop-&gt;m_profiledBlock-&gt;m_lock);
<span class="line-modified">!                 ByValInfo* byValInfo = m_inlineStackTop-&gt;m_baselineMap.get(CodeOrigin(currentCodeOrigin().bytecodeIndex())).byValInfo;</span>
                  // FIXME: When the bytecode is not compiled in the baseline JIT, byValInfo becomes null.
                  // At that time, there is no information.
                  if (byValInfo
                      &amp;&amp; byValInfo-&gt;stubInfo
                      &amp;&amp; !byValInfo-&gt;tookSlowPath
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5664,10 ***</span>
<span class="line-new-header">--- 5736,28 ---</span>
              Node* condition = addToGraph(CompareEq, value, nullConstant);
              addToGraph(Branch, OpInfo(branchData(m_currentIndex + currentInstruction-&gt;size(), m_currentIndex + relativeOffset)), condition);
              LAST_OPCODE(op_jneq_null);
          }
  
<span class="line-added">+         case op_jundefined_or_null: {</span>
<span class="line-added">+             auto bytecode = currentInstruction-&gt;as&lt;OpJundefinedOrNull&gt;();</span>
<span class="line-added">+             unsigned relativeOffset = jumpTarget(bytecode.m_targetLabel);</span>
<span class="line-added">+             Node* value = get(bytecode.m_value);</span>
<span class="line-added">+             Node* condition = addToGraph(IsUndefinedOrNull, value);</span>
<span class="line-added">+             addToGraph(Branch, OpInfo(branchData(m_currentIndex + relativeOffset, m_currentIndex + currentInstruction-&gt;size())), condition);</span>
<span class="line-added">+             LAST_OPCODE(op_jundefined_or_null);</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         case op_jnundefined_or_null: {</span>
<span class="line-added">+             auto bytecode = currentInstruction-&gt;as&lt;OpJnundefinedOrNull&gt;();</span>
<span class="line-added">+             unsigned relativeOffset = jumpTarget(bytecode.m_targetLabel);</span>
<span class="line-added">+             Node* value = get(bytecode.m_value);</span>
<span class="line-added">+             Node* condition = addToGraph(IsUndefinedOrNull, value);</span>
<span class="line-added">+             addToGraph(Branch, OpInfo(branchData(m_currentIndex + currentInstruction-&gt;size(), m_currentIndex + relativeOffset)), condition);</span>
<span class="line-added">+             LAST_OPCODE(op_jnundefined_or_null);</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
          case op_jless: {
              auto bytecode = currentInstruction-&gt;as&lt;OpJless&gt;();
              unsigned relativeOffset = jumpTarget(bytecode.m_targetLabel);
              Node* op1 = get(bytecode.m_lhs);
              Node* op2 = get(bytecode.m_rhs);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5947,11 ***</span>
              {
                  ConcurrentJSLocker locker(m_inlineStackTop-&gt;m_profiledBlock-&gt;m_lock);
  
                  buffer-&gt;forEach([&amp;] (ValueProfileAndOperand&amp; profile) {
                      VirtualRegister operand(profile.m_operand);
<span class="line-modified">!                     SpeculatedType prediction = profile.m_profile.computeUpdatedPrediction(locker);</span>
                      if (operand.isLocal())
                          localPredictions.append(prediction);
                      else {
                          RELEASE_ASSERT(operand.isArgument());
                          RELEASE_ASSERT(static_cast&lt;uint32_t&gt;(operand.toArgument()) &lt; argumentPredictions.size());
<span class="line-new-header">--- 6037,11 ---</span>
              {
                  ConcurrentJSLocker locker(m_inlineStackTop-&gt;m_profiledBlock-&gt;m_lock);
  
                  buffer-&gt;forEach([&amp;] (ValueProfileAndOperand&amp; profile) {
                      VirtualRegister operand(profile.m_operand);
<span class="line-modified">!                     SpeculatedType prediction = profile.computeUpdatedPrediction(locker);</span>
                      if (operand.isLocal())
                          localPredictions.append(prediction);
                      else {
                          RELEASE_ASSERT(operand.isArgument());
                          RELEASE_ASSERT(static_cast&lt;uint32_t&gt;(operand.toArgument()) &lt; argumentPredictions.size());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5996,11 ***</span>
              // recovery for live locals. The above IR sets up the necessary state so we can recover values
              // during OSR exit.
              //
              // The nodes that follow here all exit to the following bytecode instruction, not
              // the op_catch. Exiting to op_catch is reserved for when an exception is thrown.
<span class="line-modified">!             // The SetArgument nodes that follow below may exit because we may hoist type checks</span>
              // to them. The SetLocal nodes that follow below may exit because we may choose
              // a flush format that speculates on the type of the local.
              m_exitOK = true;
              addToGraph(ExitOK);
  
<span class="line-new-header">--- 6086,11 ---</span>
              // recovery for live locals. The above IR sets up the necessary state so we can recover values
              // during OSR exit.
              //
              // The nodes that follow here all exit to the following bytecode instruction, not
              // the op_catch. Exiting to op_catch is reserved for when an exception is thrown.
<span class="line-modified">!             // The SetArgumentDefinitely nodes that follow below may exit because we may hoist type checks</span>
              // to them. The SetLocal nodes that follow below may exit because we may choose
              // a flush format that speculates on the type of the local.
              m_exitOK = true;
              addToGraph(ExitOK);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 6019,12 ***</span>
                      variable-&gt;mergeStructureCheckHoistingFailed(
                          m_inlineStackTop-&gt;m_exitProfile.hasExitSite(exitBytecodeIndex, BadCache));
                      variable-&gt;mergeCheckArrayHoistingFailed(
                          m_inlineStackTop-&gt;m_exitProfile.hasExitSite(exitBytecodeIndex, BadIndexingType));
  
<span class="line-modified">!                     Node* setArgument = addToGraph(SetArgument, OpInfo(variable));</span>
<span class="line-modified">!                     setArgument-&gt;origin.forExit.bytecodeIndex = exitBytecodeIndex;</span>
                      m_currentBlock-&gt;variablesAtTail.setArgumentFirstTime(argument, setArgument);
                      entrypointArguments[argument] = setArgument;
                  }
              }
  
<span class="line-new-header">--- 6109,12 ---</span>
                      variable-&gt;mergeStructureCheckHoistingFailed(
                          m_inlineStackTop-&gt;m_exitProfile.hasExitSite(exitBytecodeIndex, BadCache));
                      variable-&gt;mergeCheckArrayHoistingFailed(
                          m_inlineStackTop-&gt;m_exitProfile.hasExitSite(exitBytecodeIndex, BadIndexingType));
  
<span class="line-modified">!                     Node* setArgument = addToGraph(SetArgumentDefinitely, OpInfo(variable));</span>
<span class="line-modified">!                     setArgument-&gt;origin.forExit = CodeOrigin(exitBytecodeIndex, setArgument-&gt;origin.forExit.inlineCallFrame());</span>
                      m_currentBlock-&gt;variablesAtTail.setArgumentFirstTime(argument, setArgument);
                      entrypointArguments[argument] = setArgument;
                  }
              }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 6208,15 ***</span>
                  Node* localBase = get(bytecode.m_scope);
                  addToGraph(Phantom, localBase); // OSR exit cannot handle resolve_scope on a DCE&#39;d scope.
  
                  // We have various forms of constant folding here. This is necessary to avoid
                  // spurious recompiles in dead-but-foldable code.
                  if (symbolTable) {
<span class="line-modified">!                     InferredValue* singleton = symbolTable-&gt;singletonScope();</span>
<span class="line-modified">!                     if (JSValue value = singleton-&gt;inferredValue()) {</span>
<span class="line-modified">!                         m_graph.watchpoints().addLazily(singleton);</span>
<span class="line-removed">-                         set(bytecode.m_dst, weakJSConstant(value));</span>
                          break;
                      }
                  }
                  if (JSScope* scope = localBase-&gt;dynamicCastConstant&lt;JSScope*&gt;(*m_vm)) {
                      for (unsigned n = depth; n--;)
<span class="line-new-header">--- 6298,15 ---</span>
                  Node* localBase = get(bytecode.m_scope);
                  addToGraph(Phantom, localBase); // OSR exit cannot handle resolve_scope on a DCE&#39;d scope.
  
                  // We have various forms of constant folding here. This is necessary to avoid
                  // spurious recompiles in dead-but-foldable code.
<span class="line-added">+ </span>
                  if (symbolTable) {
<span class="line-modified">!                     if (JSScope* scope = symbolTable-&gt;singleton().inferredValue()) {</span>
<span class="line-modified">!                         m_graph.watchpoints().addLazily(symbolTable);</span>
<span class="line-modified">!                         set(bytecode.m_dst, weakJSConstant(scope));</span>
                          break;
                      }
                  }
                  if (JSScope* scope = localBase-&gt;dynamicCastConstant&lt;JSScope*&gt;(*m_vm)) {
                      for (unsigned n = depth; n--;)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 6243,11 ***</span>
              NEXT_OPCODE(op_resolve_scope);
          }
          case op_resolve_scope_for_hoisting_func_decl_in_eval: {
              auto bytecode = currentInstruction-&gt;as&lt;OpResolveScopeForHoistingFuncDeclInEval&gt;();
              unsigned identifierNumber = m_inlineStackTop-&gt;m_identifierRemap[bytecode.m_property];
<span class="line-removed">- </span>
              set(bytecode.m_dst, addToGraph(ResolveScopeForHoistingFuncDeclInEval, OpInfo(identifierNumber), get(bytecode.m_scope)));
  
              NEXT_OPCODE(op_resolve_scope_for_hoisting_func_decl_in_eval);
          }
  
<span class="line-new-header">--- 6333,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 6555,16 ***</span>
              // block. Hence, machine code block = true code block = not inline code block.
              if (!m_inlineStackTop-&gt;m_caller)
                  m_currentBlock-&gt;isOSRTarget = true;
  
              addToGraph(LoopHint);
<span class="line-removed">-             NEXT_OPCODE(op_loop_hint);</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
<span class="line-removed">-         case op_check_traps: {</span>
              addToGraph(Options::usePollingTraps() ? CheckTraps : InvalidationPoint);
<span class="line-modified">!             NEXT_OPCODE(op_check_traps);</span>
          }
  
          case op_nop: {
              addToGraph(Check); // We add a nop here so that basic block linking doesn&#39;t break.
              NEXT_OPCODE(op_nop);
<span class="line-new-header">--- 6644,12 ---</span>
              // block. Hence, machine code block = true code block = not inline code block.
              if (!m_inlineStackTop-&gt;m_caller)
                  m_currentBlock-&gt;isOSRTarget = true;
  
              addToGraph(LoopHint);
              addToGraph(Options::usePollingTraps() ? CheckTraps : InvalidationPoint);
<span class="line-modified">!             NEXT_OPCODE(op_loop_hint);</span>
          }
  
          case op_nop: {
              addToGraph(Check); // We add a nop here so that basic block linking doesn&#39;t break.
              NEXT_OPCODE(op_nop);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 7031,11 ***</span>
              unsigned index = byteCodeParser-&gt;m_graph.identifiers().ensure(rep);
              m_identifierRemap[i] = index;
          }
          for (unsigned i = 0; i &lt; codeBlock-&gt;numberOfSwitchJumpTables(); ++i) {
              m_switchRemap[i] = byteCodeParser-&gt;m_codeBlock-&gt;numberOfSwitchJumpTables();
<span class="line-modified">!             byteCodeParser-&gt;m_codeBlock-&gt;addSwitchJumpTable() = codeBlock-&gt;switchJumpTable(i);</span>
          }
      } else {
          // Machine code block case.
          ASSERT(codeBlock == byteCodeParser-&gt;m_codeBlock);
          ASSERT(!callee);
<span class="line-new-header">--- 7116,11 ---</span>
              unsigned index = byteCodeParser-&gt;m_graph.identifiers().ensure(rep);
              m_identifierRemap[i] = index;
          }
          for (unsigned i = 0; i &lt; codeBlock-&gt;numberOfSwitchJumpTables(); ++i) {
              m_switchRemap[i] = byteCodeParser-&gt;m_codeBlock-&gt;numberOfSwitchJumpTables();
<span class="line-modified">!             byteCodeParser-&gt;m_codeBlock-&gt;addSwitchJumpTableFromProfiledCodeBlock(codeBlock-&gt;switchJumpTable(i));</span>
          }
      } else {
          // Machine code block case.
          ASSERT(codeBlock == byteCodeParser-&gt;m_codeBlock);
          ASSERT(!callee);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 7082,21 ***</span>
      }
  
      if (UNLIKELY(Options::dumpSourceAtDFGTime())) {
          Vector&lt;DeferredSourceDump&gt;&amp; deferredSourceDump = m_graph.m_plan.callback()-&gt;ensureDeferredSourceDump();
          if (inlineCallFrame()) {
<span class="line-modified">!             DeferredSourceDump dump(codeBlock-&gt;baselineVersion(), m_codeBlock, JITCode::DFGJIT, inlineCallFrame()-&gt;directCaller.bytecodeIndex);</span>
              deferredSourceDump.append(dump);
          } else
              deferredSourceDump.append(DeferredSourceDump(codeBlock-&gt;baselineVersion()));
      }
  
      if (Options::dumpBytecodeAtDFGTime()) {
          dataLog(&quot;Parsing &quot;, *codeBlock);
          if (inlineCallFrame()) {
              dataLog(
<span class="line-modified">!                 &quot; for inlining at &quot;, CodeBlockWithJITType(m_codeBlock, JITCode::DFGJIT),</span>
                  &quot; &quot;, inlineCallFrame()-&gt;directCaller);
          }
          dataLog(
              &quot;, isStrictMode = &quot;, codeBlock-&gt;ownerExecutable()-&gt;isStrictMode(), &quot;\n&quot;);
          codeBlock-&gt;baselineVersion()-&gt;dumpBytecode();
<span class="line-new-header">--- 7167,21 ---</span>
      }
  
      if (UNLIKELY(Options::dumpSourceAtDFGTime())) {
          Vector&lt;DeferredSourceDump&gt;&amp; deferredSourceDump = m_graph.m_plan.callback()-&gt;ensureDeferredSourceDump();
          if (inlineCallFrame()) {
<span class="line-modified">!             DeferredSourceDump dump(codeBlock-&gt;baselineVersion(), m_codeBlock, JITType::DFGJIT, inlineCallFrame()-&gt;directCaller.bytecodeIndex());</span>
              deferredSourceDump.append(dump);
          } else
              deferredSourceDump.append(DeferredSourceDump(codeBlock-&gt;baselineVersion()));
      }
  
      if (Options::dumpBytecodeAtDFGTime()) {
          dataLog(&quot;Parsing &quot;, *codeBlock);
          if (inlineCallFrame()) {
              dataLog(
<span class="line-modified">!                 &quot; for inlining at &quot;, CodeBlockWithJITType(m_codeBlock, JITType::DFGJIT),</span>
                  &quot; &quot;, inlineCallFrame()-&gt;directCaller);
          }
          dataLog(
              &quot;, isStrictMode = &quot;, codeBlock-&gt;ownerExecutable()-&gt;isStrictMode(), &quot;\n&quot;);
          codeBlock-&gt;baselineVersion()-&gt;dumpBytecode();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 7170,11 ***</span>
      {
          unsigned identifierNumber = std::numeric_limits&lt;unsigned&gt;::max();
          PutByIdStatus putByIdStatus;
          {
              ConcurrentJSLocker locker(m_inlineStackTop-&gt;m_profiledBlock-&gt;m_lock);
<span class="line-modified">!             ByValInfo* byValInfo = m_inlineStackTop-&gt;m_baselineMap.get(CodeOrigin(currentCodeOrigin().bytecodeIndex)).byValInfo;</span>
              // FIXME: When the bytecode is not compiled in the baseline JIT, byValInfo becomes null.
              // At that time, there is no information.
              if (byValInfo
                  &amp;&amp; byValInfo-&gt;stubInfo
                  &amp;&amp; !byValInfo-&gt;tookSlowPath
<span class="line-new-header">--- 7255,11 ---</span>
      {
          unsigned identifierNumber = std::numeric_limits&lt;unsigned&gt;::max();
          PutByIdStatus putByIdStatus;
          {
              ConcurrentJSLocker locker(m_inlineStackTop-&gt;m_profiledBlock-&gt;m_lock);
<span class="line-modified">!             ByValInfo* byValInfo = m_inlineStackTop-&gt;m_baselineMap.get(CodeOrigin(currentCodeOrigin().bytecodeIndex())).byValInfo;</span>
              // FIXME: When the bytecode is not compiled in the baseline JIT, byValInfo becomes null.
              // At that time, there is no information.
              if (byValInfo
                  &amp;&amp; byValInfo-&gt;stubInfo
                  &amp;&amp; !byValInfo-&gt;tookSlowPath
</pre>
<hr />
<pre>
<span class="line-old-header">*** 7324,30 ***</span>
                      RELEASE_ASSERT(!node);
                  }
              }
  
              for (unsigned nodeIndex = 0; nodeIndex &lt; block-&gt;size(); ++nodeIndex) {
<span class="line-modified">!                 Node* node = block-&gt;at(nodeIndex);</span>
  
<span class="line-modified">!                 if (node-&gt;hasVariableAccessData(m_graph))</span>
<span class="line-modified">!                     mapping.operand(node-&gt;local()) = node-&gt;variableAccessData();</span>
  
<span class="line-modified">!                 if (node-&gt;op() == ForceOSRExit) {</span>
<span class="line-removed">-                     NodeOrigin endOrigin = node-&gt;origin.withExitOK(true);</span>
  
                      if (validationEnabled()) {
                          // This verifies that we don&#39;t need to change any of the successors&#39;s predecessor
                          // list after planting the Unreachable below. At this point in the bytecode
                          // parser, we haven&#39;t linked up the predecessor lists yet.
                          for (BasicBlock* successor : block-&gt;successors())
                              RELEASE_ASSERT(successor-&gt;predecessors.isEmpty());
                      }
  
<span class="line-removed">-                     block-&gt;resize(nodeIndex + 1);</span>
<span class="line-removed">- </span>
<span class="line-removed">-                     insertionSet.insertNode(block-&gt;size(), SpecNone, ExitOK, endOrigin);</span>
<span class="line-removed">- </span>
                      auto insertLivenessPreservingOp = [&amp;] (InlineCallFrame* inlineCallFrame, NodeType op, VirtualRegister operand) {
                          VariableAccessData* variable = mapping.operand(operand);
                          if (!variable) {
                              variable = newVariableAccessData(operand);
                              mapping.operand(operand) = variable;
<span class="line-new-header">--- 7409,34 ---</span>
                      RELEASE_ASSERT(!node);
                  }
              }
  
              for (unsigned nodeIndex = 0; nodeIndex &lt; block-&gt;size(); ++nodeIndex) {
<span class="line-modified">!                 {</span>
<span class="line-added">+                     Node* node = block-&gt;at(nodeIndex);</span>
<span class="line-added">+ </span>
<span class="line-added">+                     if (node-&gt;hasVariableAccessData(m_graph))</span>
<span class="line-added">+                         mapping.operand(node-&gt;local()) = node-&gt;variableAccessData();</span>
  
<span class="line-modified">!                     if (node-&gt;op() != ForceOSRExit)</span>
<span class="line-modified">!                         continue;</span>
<span class="line-added">+                 }</span>
<span class="line-added">+ </span>
<span class="line-added">+                 NodeOrigin origin = block-&gt;at(nodeIndex)-&gt;origin;</span>
<span class="line-added">+                 RELEASE_ASSERT(origin.exitOK);</span>
  
<span class="line-modified">!                 ++nodeIndex;</span>
  
<span class="line-added">+                 {</span>
                      if (validationEnabled()) {
                          // This verifies that we don&#39;t need to change any of the successors&#39;s predecessor
                          // list after planting the Unreachable below. At this point in the bytecode
                          // parser, we haven&#39;t linked up the predecessor lists yet.
                          for (BasicBlock* successor : block-&gt;successors())
                              RELEASE_ASSERT(successor-&gt;predecessors.isEmpty());
                      }
  
                      auto insertLivenessPreservingOp = [&amp;] (InlineCallFrame* inlineCallFrame, NodeType op, VirtualRegister operand) {
                          VariableAccessData* variable = mapping.operand(operand);
                          if (!variable) {
                              variable = newVariableAccessData(operand);
                              mapping.operand(operand) = variable;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 7355,24 ***</span>
  
                          VirtualRegister argument = operand - (inlineCallFrame ? inlineCallFrame-&gt;stackOffset : 0);
                          if (argument.isArgument() &amp;&amp; !argument.isHeader()) {
                              const Vector&lt;ArgumentPosition*&gt;&amp; arguments = m_inlineCallFrameToArgumentPositions.get(inlineCallFrame);
                              arguments[argument.toArgument()]-&gt;addVariable(variable);
<span class="line-modified">!                         } insertionSet.insertNode(block-&gt;size(), SpecNone, op, endOrigin, OpInfo(variable));</span>
                      };
                      auto addFlushDirect = [&amp;] (InlineCallFrame* inlineCallFrame, VirtualRegister operand) {
                          insertLivenessPreservingOp(inlineCallFrame, Flush, operand);
                      };
                      auto addPhantomLocalDirect = [&amp;] (InlineCallFrame* inlineCallFrame, VirtualRegister operand) {
                          insertLivenessPreservingOp(inlineCallFrame, PhantomLocal, operand);
                      };
<span class="line-modified">!                     flushForTerminalImpl(endOrigin.semantic, addFlushDirect, addPhantomLocalDirect);</span>
  
<span class="line-modified">!                     insertionSet.insertNode(block-&gt;size(), SpecNone, Unreachable, endOrigin);</span>
<span class="line-modified">!                     insertionSet.execute(block);</span>
<span class="line-modified">!                     break;</span>
                  }
              }
          }
      } else if (validationEnabled()) {
          // Ensure our bookkeeping for ForceOSRExit nodes is working.
          for (BasicBlock* block : m_graph.blocksInNaturalOrder()) {
<span class="line-new-header">--- 7444,58 ---</span>
  
                          VirtualRegister argument = operand - (inlineCallFrame ? inlineCallFrame-&gt;stackOffset : 0);
                          if (argument.isArgument() &amp;&amp; !argument.isHeader()) {
                              const Vector&lt;ArgumentPosition*&gt;&amp; arguments = m_inlineCallFrameToArgumentPositions.get(inlineCallFrame);
                              arguments[argument.toArgument()]-&gt;addVariable(variable);
<span class="line-modified">!                         }</span>
<span class="line-added">+                         insertionSet.insertNode(nodeIndex, SpecNone, op, origin, OpInfo(variable));</span>
                      };
                      auto addFlushDirect = [&amp;] (InlineCallFrame* inlineCallFrame, VirtualRegister operand) {
                          insertLivenessPreservingOp(inlineCallFrame, Flush, operand);
                      };
                      auto addPhantomLocalDirect = [&amp;] (InlineCallFrame* inlineCallFrame, VirtualRegister operand) {
                          insertLivenessPreservingOp(inlineCallFrame, PhantomLocal, operand);
                      };
<span class="line-modified">!                     flushForTerminalImpl(origin.semantic, addFlushDirect, addPhantomLocalDirect);</span>
<span class="line-added">+                 }</span>
  
<span class="line-modified">!                 while (true) {</span>
<span class="line-modified">!                     RELEASE_ASSERT(nodeIndex &lt; block-&gt;size());</span>
<span class="line-modified">! </span>
<span class="line-added">+                     Node* node = block-&gt;at(nodeIndex);</span>
<span class="line-added">+ </span>
<span class="line-added">+                     node-&gt;origin = origin;</span>
<span class="line-added">+                     m_graph.doToChildren(node, [&amp;] (Edge edge) {</span>
<span class="line-added">+                         // We only need to keep data flow edges to nodes defined prior to the ForceOSRExit. The reason</span>
<span class="line-added">+                         // for this is we rely on backwards propagation being able to see the &quot;full&quot; bytecode. To model</span>
<span class="line-added">+                         // this, we preserve uses of a node in a generic way so that backwards propagation can reason</span>
<span class="line-added">+                         // about them. Therefore, we can&#39;t remove uses of a node which is defined before the ForceOSRExit</span>
<span class="line-added">+                         // even when we&#39;re at a point in the program after the ForceOSRExit, because that would break backwards</span>
<span class="line-added">+                         // propagation&#39;s analysis over the uses of a node. However, we don&#39;t need this same preservation for</span>
<span class="line-added">+                         // nodes defined after ForceOSRExit, as we&#39;ve already exitted before those defs.</span>
<span class="line-added">+                         if (edge-&gt;hasResult())</span>
<span class="line-added">+                             insertionSet.insertNode(nodeIndex, SpecNone, Phantom, origin, Edge(edge.node(), UntypedUse));</span>
<span class="line-added">+                     });</span>
<span class="line-added">+ </span>
<span class="line-added">+                     bool isTerminal = node-&gt;isTerminal();</span>
<span class="line-added">+ </span>
<span class="line-added">+                     node-&gt;removeWithoutChecks();</span>
<span class="line-added">+ </span>
<span class="line-added">+                     if (isTerminal) {</span>
<span class="line-added">+                         insertionSet.insertNode(nodeIndex, SpecNone, Unreachable, origin);</span>
<span class="line-added">+                         break;</span>
<span class="line-added">+                     }</span>
<span class="line-added">+ </span>
<span class="line-added">+                     ++nodeIndex;</span>
                  }
<span class="line-added">+ </span>
<span class="line-added">+                 insertionSet.execute(block);</span>
<span class="line-added">+ </span>
<span class="line-added">+                 auto nodeAndIndex = block-&gt;findTerminal();</span>
<span class="line-added">+                 RELEASE_ASSERT(nodeAndIndex.node-&gt;op() == Unreachable);</span>
<span class="line-added">+                 block-&gt;resize(nodeAndIndex.index + 1);</span>
<span class="line-added">+                 break;</span>
              }
          }
      } else if (validationEnabled()) {
          // Ensure our bookkeeping for ForceOSRExit nodes is working.
          for (BasicBlock* block : m_graph.blocksInNaturalOrder()) {
</pre>
<center><a href="DFGBasicBlock.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DFGCFAPhase.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>