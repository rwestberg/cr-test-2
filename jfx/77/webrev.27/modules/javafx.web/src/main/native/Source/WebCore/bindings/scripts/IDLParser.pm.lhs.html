<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/bindings/scripts/IDLParser.pm</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 # 
   2 # KDOM IDL parser
   3 #
   4 # Copyright (C) 2005 Nikolas Zimmermann &lt;wildfox@kde.org&gt;
   5 # 
   6 # This library is free software; you can redistribute it and/or
   7 # modify it under the terms of the GNU Library General Public
   8 # License as published by the Free Software Foundation; either
   9 # version 2 of the License, or (at your option) any later version.
  10 # 
  11 # This library is distributed in the hope that it will be useful,
  12 # but WITHOUT ANY WARRANTY; without even the implied warranty of
  13 # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  14 # Library General Public License for more details.
  15 # 
  16 # You should have received a copy of the GNU Library General Public License
  17 # along with this library; see the file COPYING.LIB.  If not, write to
  18 # the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  19 # Boston, MA 02110-1301, USA.
  20 # 
  21 
  22 package IDLParser;
  23 
  24 use strict;
  25 
  26 use Carp qw&lt;longmess&gt;;
  27 use Data::Dumper;
  28 
  29 use preprocessor;
  30 use Class::Struct;
  31 
  32 use constant StringToken =&gt; 0;
  33 use constant IntegerToken =&gt; 1;
  34 use constant FloatToken =&gt; 2;
  35 use constant IdentifierToken =&gt; 3;
  36 use constant OtherToken =&gt; 4;
  37 use constant EmptyToken =&gt; 5;
  38 
  39 # Used to represent a parsed IDL document
  40 struct( IDLDocument =&gt; {
  41     interfaces =&gt; &#39;@&#39;, # List of &#39;IDLInterface&#39;
  42     enumerations =&gt; &#39;@&#39;, # List of &#39;IDLEnum&#39;
  43     dictionaries =&gt; &#39;@&#39;, # List of &#39;IDLDictionary&#39;
  44     callbackFunctions =&gt; &#39;@&#39;, # List of &#39;IDLCallbackFunction&#39;
  45     fileName =&gt; &#39;$&#39;,
  46 });
  47 
  48 # https://heycam.github.io/webidl/#idl-types
  49 struct( IDLType =&gt; {
  50     name =&gt;         &#39;$&#39;, # Type identifier
  51     isNullable =&gt;   &#39;$&#39;, # Is the type Nullable (T?)
  52     isUnion =&gt;      &#39;$&#39;, # Is the type a union (T or U)
  53     subtypes =&gt;     &#39;@&#39;, # Array of subtypes, only valid if isUnion or sequence
  54     extendedAttributes =&gt; &#39;%&#39;,
  55 });
  56 
  57 # Used to represent &#39;interface&#39; blocks
  58 struct( IDLInterface =&gt; {
  59     type =&gt; &#39;IDLType&#39;,
  60     parentType =&gt; &#39;IDLType&#39;,
  61     constants =&gt; &#39;@&#39;,    # List of &#39;IDLConstant&#39;
  62     operations =&gt; &#39;@&#39;,    # List of &#39;IDLOperation&#39;
  63     anonymousOperations =&gt; &#39;@&#39;, # List of &#39;IDLOperation&#39;
  64     attributes =&gt; &#39;@&#39;,    # List of &#39;IDLAttribute&#39;
  65     constructors =&gt; &#39;@&#39;, # Constructors, list of &#39;IDLOperation&#39;
  66     customConstructors =&gt; &#39;@&#39;, # Custom constructors, list of &#39;IDLOperation&#39;
  67     isException =&gt; &#39;$&#39;, # Used for exception interfaces
  68     isCallback =&gt; &#39;$&#39;, # Used for callback interfaces
  69     isPartial =&gt; &#39;$&#39;, # Used for partial interfaces
  70     iterable =&gt; &#39;$&#39;, # Used for iterable interfaces
  71     mapLike =&gt; &#39;$&#39;, # Used for mapLike interfaces
  72     serializable =&gt; &#39;$&#39;, # Used for serializable interfaces
  73     extendedAttributes =&gt; &#39;$&#39;,
  74 });
  75 
  76 # Used to represent an argument to a IDLOperation.
  77 struct( IDLArgument =&gt; {
  78     name =&gt; &#39;$&#39;,
  79     type =&gt; &#39;IDLType&#39;,
  80     isVariadic =&gt; &#39;$&#39;,
  81     isOptional =&gt; &#39;$&#39;,
  82     default =&gt; &#39;$&#39;,
  83     extendedAttributes =&gt; &#39;%&#39;,
  84 });
  85 
  86 # https://heycam.github.io/webidl/#idl-operations
  87 struct( IDLOperation =&gt; {
  88     name =&gt; &#39;$&#39;,
  89     type =&gt; &#39;IDLType&#39;, # Return type
  90     arguments =&gt; &#39;@&#39;, # List of &#39;IDLArgument&#39;
  91     isStatic =&gt; &#39;$&#39;,
  92     isIterable =&gt; &#39;$&#39;,
  93     isSerializer =&gt; &#39;$&#39;,
  94     isStringifier =&gt; &#39;$&#39;,
  95     isMapLike =&gt; &#39;$&#39;,
  96     specials =&gt; &#39;@&#39;,
  97     extendedAttributes =&gt; &#39;%&#39;,
  98 });
  99 
 100 
 101 # https://heycam.github.io/webidl/#idl-attributes
 102 struct( IDLAttribute =&gt; {
 103     name =&gt; &#39;$&#39;,
 104     type =&gt; &#39;IDLType&#39;,
 105     isStatic =&gt; &#39;$&#39;,
 106     isMapLike =&gt; &#39;$&#39;,
 107     isStringifier =&gt; &#39;$&#39;,
 108     isReadOnly =&gt; &#39;$&#39;,
 109     isInherit =&gt; &#39;$&#39;,
 110     extendedAttributes =&gt; &#39;$&#39;,
 111 });
 112 
 113 # https://heycam.github.io/webidl/#idl-iterable
 114 struct( IDLIterable =&gt; {
 115     isKeyValue =&gt; &#39;$&#39;,
 116     keyType =&gt; &#39;IDLType&#39;,
 117     valueType =&gt; &#39;IDLType&#39;,
 118     operations =&gt; &#39;@&#39;, # Iterable operations (entries, keys, values, [Symbol.Iterator], forEach)
 119     extendedAttributes =&gt; &#39;$&#39;,
 120 });
 121 
 122 # https://heycam.github.io/webidl/#es-maplike
 123 struct( IDLMapLike =&gt; {
 124     isReadOnly =&gt; &#39;$&#39;,
 125     keyType =&gt; &#39;IDLType&#39;,
 126     valueType =&gt; &#39;IDLType&#39;,
 127     attributes =&gt; &#39;@&#39;, # MapLike attributes (size)
 128     operations =&gt; &#39;@&#39;, # MapLike operations (entries, keys, values, forEach, get, has and if not readonly, delete, set and clear)
 129     extendedAttributes =&gt; &#39;$&#39;,
 130 });
 131 
 132 # https://heycam.github.io/webidl/#idl-serializers
 133 struct( IDLSerializable =&gt; {
 134     attributes =&gt; &#39;@&#39;, # List of attributes to serialize
 135     hasAttribute =&gt; &#39;$&#39;, # serializer = { attribute }
 136     hasInherit =&gt; &#39;$&#39;, # serializer = { inherit }
 137     hasGetter =&gt; &#39;$&#39;, # serializer = { getter }
 138     operations =&gt; &#39;@&#39;, # toJSON operation
 139 });
 140 
 141 # https://heycam.github.io/webidl/#idl-constants
 142 struct( IDLConstant =&gt; {
 143     name =&gt; &#39;$&#39;,
 144     type =&gt; &#39;IDLType&#39;,
 145     value =&gt; &#39;$&#39;,
 146     extendedAttributes =&gt; &#39;$&#39;,
 147 });
 148 
 149 # https://heycam.github.io/webidl/#idl-enums
 150 struct( IDLEnum =&gt; {
 151     name =&gt; &#39;$&#39;,
 152     type =&gt; &#39;IDLType&#39;,
 153     values =&gt; &#39;@&#39;,
 154     extendedAttributes =&gt; &#39;$&#39;,
 155 });
 156 
 157 # https://heycam.github.io/webidl/#dfn-dictionary-member
 158 struct( IDLDictionaryMember =&gt; {
 159     name =&gt; &#39;$&#39;,
 160     type =&gt; &#39;IDLType&#39;,
 161     isRequired =&gt; &#39;$&#39;,
 162     default =&gt; &#39;$&#39;,
 163     extendedAttributes =&gt; &#39;$&#39;,
 164 });
 165 
 166 # https://heycam.github.io/webidl/#idl-dictionaries
 167 struct( IDLDictionary =&gt; {
 168     type =&gt; &#39;IDLType&#39;,
 169     parentType =&gt; &#39;IDLType&#39;,
 170     members =&gt; &#39;@&#39;, # List of &#39;IDLDictionaryMember&#39;
 171     extendedAttributes =&gt; &#39;$&#39;,
<a name="1" id="anc1"></a>
 172 });
 173 
 174 # https://heycam.github.io/webidl/#idl-callback-functions
 175 struct( IDLCallbackFunction =&gt; {
 176     type =&gt; &#39;$&#39;,
 177     operation =&gt; &#39;IDLOperation&#39;,
 178     extendedAttributes =&gt; &#39;$&#39;,
 179 });
 180 
 181 # https://heycam.github.io/webidl/#idl-typedefs
 182 struct( IDLTypedef =&gt; {
 183     type =&gt; &#39;IDLType&#39;,
 184 });
 185 
 186 struct( Token =&gt; {
 187     type =&gt; &#39;$&#39;, # type of token
 188     value =&gt; &#39;$&#39; # value of token
 189 });
 190 
 191 # Maps &#39;typedef name&#39; -&gt; Typedef
 192 my %typedefs = ();
 193 
 194 sub new {
 195     my $class = shift;
 196 
 197     my $emptyToken = Token-&gt;new();
 198     $emptyToken-&gt;type(EmptyToken);
 199     $emptyToken-&gt;value(&quot;empty&quot;);
 200 
 201     my $self = {
 202         DocumentContent =&gt; &quot;&quot;,
 203         EmptyToken =&gt; $emptyToken,
 204         NextToken =&gt; $emptyToken,
 205         Token =&gt; $emptyToken,
 206         Line =&gt; &quot;&quot;,
 207         LineNumber =&gt; 1,
 208         ExtendedAttributeMap =&gt; &quot;&quot;
 209     };
 210     return bless $self, $class;
 211 }
 212 
 213 sub assert
 214 {
 215     my $message = shift;
 216 
 217     my $mess = longmess();
 218     print Dumper($mess);
 219 
 220     die $message;
 221 }
 222 
 223 sub assertTokenValue
 224 {
 225     my $self = shift;
 226     my $token = shift;
 227     my $value = shift;
 228     my $line = shift;
 229     my $msg = &quot;Next token should be &quot; . $value . &quot;, but &quot; . $token-&gt;value() . &quot; on line &quot; . $self-&gt;{Line};
 230     if (defined ($line)) {
 231         $msg .= &quot; IDLParser.pm:&quot; . $line;
 232     }
 233 
 234     assert $msg unless $token-&gt;value() eq $value;
 235 }
 236 
 237 sub assertTokenType
 238 {
 239     my $self = shift;
 240     my $token = shift;
 241     my $type = shift;
 242     
 243     assert &quot;Next token&#39;s type should be &quot; . $type . &quot;, but &quot; . $token-&gt;type() . &quot; on line &quot; . $self-&gt;{Line} unless $token-&gt;type() eq $type;
 244 }
 245 
 246 sub assertUnexpectedToken
 247 {
 248     my $self = shift;
 249     my $token = shift;
 250     my $line = shift;
 251     my $msg = &quot;Unexpected token &quot; . $token . &quot; on line &quot; . $self-&gt;{Line};
 252     if (defined ($line)) {
 253         $msg .= &quot; IDLParser.pm:&quot; . $line;
 254     }
 255 
 256     assert $msg;
 257 }
 258 
 259 sub assertExtendedAttributesValidForContext
 260 {
 261     my $self = shift;
 262     my $extendedAttributeList = shift;
 263     my @contexts = @_;
 264 
 265     for my $extendedAttribute (keys %{$extendedAttributeList}) {
 266         # FIXME: Should this be done here, or when parsing the exteded attribute itself?
 267         # Either way, we should add validation of the values, if any, at the same place.
 268 
 269         # Extended attribute parsing collapses multiple &#39;Constructor&#39; or &#39;CustomConstructor&#39;
 270         # attributes into a single plural version. Eventually, it would be nice if that conversion
 271         # hapened later, and the parser kept things relatively simply, but for now, we just undo
 272         # this transformation for the type check.
 273         if ($extendedAttribute eq &quot;Constructors&quot;) {
 274             $extendedAttribute = &quot;Constructor&quot;;
 275         } elsif ($extendedAttribute eq &quot;CustomConstructors&quot;) {
 276             $extendedAttribute = &quot;CustomConstructor&quot;;
 277         }
 278 
 279         if (!exists $self-&gt;{ExtendedAttributeMap}-&gt;{$extendedAttribute}) {
 280             assert &quot;Unknown extended attribute: &#39;${extendedAttribute}&#39;&quot;;
 281         }
 282 
 283         my $foundAllowedContext = 0;
 284         for my $contextAllowed (@{$self-&gt;{ExtendedAttributeMap}-&gt;{$extendedAttribute}-&gt;{&quot;contextsAllowed&quot;}}) {
 285             for my $context (@contexts) {
 286                 if ($contextAllowed eq $context) {
 287                     $foundAllowedContext = 1;
 288                     last;
 289                 }
 290             }
 291         }
 292 
 293         if (!$foundAllowedContext) {
 294             if (scalar(@contexts) == 1) {
 295                 assert &quot;Extended attribute &#39;${extendedAttribute}&#39; used in invalid context &#39;&quot; . $contexts[0] . &quot;&#39;&quot;;
 296             } else {
 297                 # FIXME: Improved this error message a bit.
 298                 assert &quot;Extended attribute &#39;${extendedAttribute}&#39; used in invalid context&quot;;
 299             }
 300         }
 301     }
 302 }
 303 
 304 sub Parse
 305 {
 306     my $self = shift;
 307     my $fileName = shift;
 308     my $defines = shift;
 309     my $preprocessor = shift;
 310     my $idlAttributes = shift;
 311 
 312     my @definitions = ();
 313 
 314     my @lines = applyPreprocessor($fileName, $defines, $preprocessor);
 315     $self-&gt;{Line} = $lines[0];
 316     $self-&gt;{DocumentContent} = join(&#39; &#39;, @lines);
 317     $self-&gt;{ExtendedAttributeMap} = $idlAttributes;
 318 
 319     addBuiltinTypedefs();
 320 
 321     $self-&gt;getToken();
 322     eval {
 323         my $result = $self-&gt;parseDefinitions();
 324         push(@definitions, @{$result});
 325 
 326         my $next = $self-&gt;nextToken();
 327         $self-&gt;assertTokenType($next, EmptyToken);
 328     };
 329     assert $@ . &quot; in $fileName&quot; if $@;
 330 
 331     my $document = IDLDocument-&gt;new();
 332     $document-&gt;fileName($fileName);
 333     foreach my $definition (@definitions) {
 334         if (ref($definition) eq &quot;IDLInterface&quot;) {
 335             push(@{$document-&gt;interfaces}, $definition);
 336         } elsif (ref($definition) eq &quot;IDLEnum&quot;) {
 337             push(@{$document-&gt;enumerations}, $definition);
 338         } elsif (ref($definition) eq &quot;IDLDictionary&quot;) {
 339             push(@{$document-&gt;dictionaries}, $definition);
 340         } elsif (ref($definition) eq &quot;IDLCallbackFunction&quot;) {
 341             push(@{$document-&gt;callbackFunctions}, $definition);
 342         } else {
 343             die &quot;Unrecognized IDL definition kind: \&quot;&quot; . ref($definition) . &quot;\&quot;&quot;;
 344         }
 345     }
 346     return $document;
 347 }
 348 
 349 sub ParseType
 350 {
 351     my ($self, $type, $idlAttributes) = @_;
 352 
 353     $self-&gt;{Line} = $type;
 354     $self-&gt;{DocumentContent} = $type;
 355     $self-&gt;{ExtendedAttributeMap} = $idlAttributes;
 356 
 357     addBuiltinTypedefs();
 358 
 359     my $result;
 360 
 361     $self-&gt;getToken();
 362     eval {
 363         $result = $self-&gt;parseType();
 364 
 365         my $next = $self-&gt;nextToken();
 366         $self-&gt;assertTokenType($next, EmptyToken);
 367     };
 368     assert $@ . &quot; parsing type ${type}&quot; if $@;
 369 
 370     return $result;
 371 }
 372 
 373 sub nextToken
 374 {
 375     my $self = shift;
 376     return $self-&gt;{NextToken};
 377 }
 378 
 379 sub getToken
 380 {
 381     my $self = shift;
 382     $self-&gt;{Token} = $self-&gt;{NextToken};
 383     $self-&gt;{NextToken} = $self-&gt;getTokenInternal();
 384     return $self-&gt;{Token};
 385 }
 386 
 387 my $whitespaceTokenPattern = &#39;^[\t\n\r ]*[\n\r]&#39;;
 388 my $floatTokenPattern = &#39;^(-?(([0-9]+\.[0-9]*|[0-9]*\.[0-9]+)([Ee][+-]?[0-9]+)?|[0-9]+[Ee][+-]?[0-9]+))&#39;;
 389 my $integerTokenPattern = &#39;^(-?[1-9][0-9]*|-?0[Xx][0-9A-Fa-f]+|-?0[0-7]*)&#39;;
 390 my $stringTokenPattern = &#39;^(\&quot;[^\&quot;]*\&quot;)&#39;;
 391 my $identifierTokenPattern = &#39;^([A-Z_a-z][0-9A-Z_a-z]*)&#39;;
 392 my $otherTokenPattern = &#39;^(\.\.\.|[^\t\n\r 0-9A-Z_a-z])&#39;;
 393 
 394 sub getTokenInternal
 395 {
 396     my $self = shift;
 397 
 398     if ($self-&gt;{DocumentContent} =~ /$whitespaceTokenPattern/) {
 399         $self-&gt;{DocumentContent} =~ s/($whitespaceTokenPattern)//;
 400         my $skipped = $1;
 401         $self-&gt;{LineNumber}++ while ($skipped =~ /\n/g);
 402         if ($self-&gt;{DocumentContent} =~ /^([^\n\r]+)/) {
 403             $self-&gt;{Line} = $self-&gt;{LineNumber} . &quot;:&quot; . $1;
 404         } else {
 405             $self-&gt;{Line} = &quot;Unknown&quot;;
 406         }
 407     }
 408     $self-&gt;{DocumentContent} =~ s/^([\t\n\r ]+)//;
 409     if ($self-&gt;{DocumentContent} eq &quot;&quot;) {
 410         return $self-&gt;{EmptyToken};
 411     }
 412 
 413     my $token = Token-&gt;new();
 414     if ($self-&gt;{DocumentContent} =~ /$floatTokenPattern/) {
 415         $token-&gt;type(FloatToken);
 416         $token-&gt;value($1);
 417         $self-&gt;{DocumentContent} =~ s/$floatTokenPattern//;
 418         return $token;
 419     }
 420     if ($self-&gt;{DocumentContent} =~ /$integerTokenPattern/) {
 421         $token-&gt;type(IntegerToken);
 422         $token-&gt;value($1);
 423         $self-&gt;{DocumentContent} =~ s/$integerTokenPattern//;
 424         return $token;
 425     }
 426     if ($self-&gt;{DocumentContent} =~ /$stringTokenPattern/) {
 427         $token-&gt;type(StringToken);
 428         $token-&gt;value($1);
 429         $self-&gt;{DocumentContent} =~ s/$stringTokenPattern//;
 430         return $token;
 431     }
 432     if ($self-&gt;{DocumentContent} =~ /$identifierTokenPattern/) {
 433         $token-&gt;type(IdentifierToken);
 434         $token-&gt;value($1);
 435         $self-&gt;{DocumentContent} =~ s/$identifierTokenPattern//;
 436         return $token;
 437     }
 438     if ($self-&gt;{DocumentContent} =~ /$otherTokenPattern/) {
 439         $token-&gt;type(OtherToken);
 440         $token-&gt;value($1);
 441         $self-&gt;{DocumentContent} =~ s/$otherTokenPattern//;
 442         return $token;
 443     }
 444     die &quot;Failed in tokenizing at &quot; . $self-&gt;{Line};
 445 }
 446 
 447 sub unquoteString
 448 {
 449     my $self = shift;
 450     my $quotedString = shift;
 451     if ($quotedString =~ /^&quot;([^&quot;]*)&quot;$/) {
 452         return $1;
 453     }
 454     die &quot;Failed to parse string (&quot; . $quotedString . &quot;) at &quot; . $self-&gt;{Line};
 455 }
 456 
 457 sub identifierRemoveNullablePrefix
 458 {
 459     my $type = shift;
 460     $type =~ s/^_//;
 461     return $type;
 462 }
 463 
 464 sub copyExtendedAttributes
 465 {
 466     my $extendedAttributeList = shift;
 467     my $attr = shift;
 468 
 469     for my $key (keys %{$attr}) {
 470         if ($key eq &quot;Constructor&quot;) {
 471             push(@{$extendedAttributeList-&gt;{&quot;Constructors&quot;}}, $attr-&gt;{$key});
 472         } elsif ($key eq &quot;Constructors&quot;) {
 473             my @constructors = @{$attr-&gt;{$key}};
 474             foreach my $constructor (@constructors) {
 475                 push(@{$extendedAttributeList-&gt;{&quot;Constructors&quot;}}, $constructor);
 476             }
 477         } elsif ($key eq &quot;CustomConstructor&quot;) {
 478             push(@{$extendedAttributeList-&gt;{&quot;CustomConstructors&quot;}}, $attr-&gt;{$key});
 479         } elsif ($key eq &quot;CustomConstructors&quot;) {
 480            my @customConstructors = @{$attr-&gt;{$key}};
 481             foreach my $customConstructor (@customConstructors) {
 482                 push(@{$extendedAttributeList-&gt;{&quot;CustomConstructors&quot;}}, $customConstructor);
 483             }
 484         } else {
 485             $extendedAttributeList-&gt;{$key} = $attr-&gt;{$key};
 486         }
 487     }
 488 }
 489 
 490 sub isExtendedAttributeApplicableToTypes
 491 {
 492     my $self = shift;
 493     my $extendedAttribute = shift;
 494 
 495     if (!exists $self-&gt;{ExtendedAttributeMap}-&gt;{$extendedAttribute}) {
 496         assert &quot;Unknown extended attribute: &#39;${extendedAttribute}&#39;&quot;;
 497     }
 498 
 499     for my $contextAllowed (@{$self-&gt;{ExtendedAttributeMap}-&gt;{$extendedAttribute}-&gt;{&quot;contextsAllowed&quot;}}) {
 500         if ($contextAllowed eq &quot;type&quot;) {
 501             return 1;
 502         }
 503     }
 504 
 505     return 0;
 506 }
 507 
 508 sub moveExtendedAttributesApplicableToTypes
 509 {
 510     my $self = shift;
 511     my $type = shift;
 512     my $extendedAttributeList = shift;
 513 
 514     for my $key (keys %{$extendedAttributeList}) {
 515         if ($self-&gt;isExtendedAttributeApplicableToTypes($key)) {
 516             if (!defined $type-&gt;extendedAttributes-&gt;{$key}) {
 517                 $type-&gt;extendedAttributes-&gt;{$key} = $extendedAttributeList-&gt;{$key};
 518             }
 519             delete $extendedAttributeList-&gt;{$key};
 520         }
 521     }
 522 }
 523 
 524 sub typeDescription
 525 {
 526     my $type = shift;
 527 
 528     if (scalar @{$type-&gt;subtypes}) {
 529         return $type-&gt;name . &#39;&lt;&#39; . join(&#39;, &#39;, map { typeDescription($_) } @{$type-&gt;subtypes}) . &#39;&gt;&#39; . ($type-&gt;isNullable ? &quot;?&quot; : &quot;&quot;);
 530     }
 531 
 532     return $type-&gt;name . ($type-&gt;isNullable ? &quot;?&quot; : &quot;&quot;);
 533 }
 534 
 535 sub cloneType
 536 {
 537     my $type = shift;
 538 
 539     my $clonedType = IDLType-&gt;new();
 540     $clonedType-&gt;name($type-&gt;name);
 541     $clonedType-&gt;isNullable($type-&gt;isNullable);
 542     $clonedType-&gt;isUnion($type-&gt;isUnion);
 543 
 544     copyExtendedAttributes($clonedType-&gt;extendedAttributes, $type-&gt;extendedAttributes);
 545 
 546     foreach my $subtype (@{$type-&gt;subtypes}) {
 547         push(@{$clonedType-&gt;subtypes}, cloneType($subtype));
 548     }
 549 
 550     return $clonedType;
 551 }
 552 
 553 sub cloneArgument
 554 {
 555     my $argument = shift;
 556 
 557     my $clonedArgument = IDLArgument-&gt;new();
 558     $clonedArgument-&gt;name($argument-&gt;name);
 559     $clonedArgument-&gt;type(cloneType($argument-&gt;type));
 560     $clonedArgument-&gt;isVariadic($argument-&gt;isVariadic);
 561     $clonedArgument-&gt;isOptional($argument-&gt;isOptional);
 562     $clonedArgument-&gt;default($argument-&gt;default);
 563     copyExtendedAttributes($clonedArgument-&gt;extendedAttributes, $argument-&gt;extendedAttributes);
 564 
 565     return $clonedArgument;
 566 }
 567 
 568 sub cloneOperation
 569 {
 570     my $operation = shift;
 571 
 572     my $clonedOperation = IDLOperation-&gt;new();
 573     $clonedOperation-&gt;name($operation-&gt;name);
 574     $clonedOperation-&gt;type(cloneType($operation-&gt;type));
 575     
 576     foreach my $argument (@{$operation-&gt;arguments}) {
 577         push(@{$clonedOperation-&gt;arguments}, cloneArgument($argument));
 578     }
 579 
 580     $clonedOperation-&gt;isStatic($operation-&gt;isStatic);
 581     $clonedOperation-&gt;isIterable($operation-&gt;isIterable);
 582     $clonedOperation-&gt;isSerializer($operation-&gt;isSerializer);
 583     $clonedOperation-&gt;isStringifier($operation-&gt;isStringifier);
 584     $clonedOperation-&gt;isMapLike($operation-&gt;isMapLike);
 585     $clonedOperation-&gt;specials($operation-&gt;specials);
 586 
 587     copyExtendedAttributes($clonedOperation-&gt;extendedAttributes, $operation-&gt;extendedAttributes);
 588 
 589     return $clonedOperation;
 590 }
 591 
 592 sub makeSimpleType
 593 {
 594     my $typeName = shift;
 595 
 596     return IDLType-&gt;new(name =&gt; $typeName);
 597 }
 598 
 599 sub addBuiltinTypedefs()
 600 {
 601     # NOTE: This leaves out the ArrayBufferView definition as it is
 602     # treated as its own type, and not a union, to allow us to utilize
 603     # the shared base class all the members of the union have.
 604 
 605     # typedef (ArrayBufferView or ArrayBuffer) BufferSource;
 606 
 607     my $bufferSourceType = IDLType-&gt;new(name =&gt; &quot;UNION&quot;, isUnion =&gt; 1);
 608     push(@{$bufferSourceType-&gt;subtypes}, makeSimpleType(&quot;ArrayBufferView&quot;));
 609     push(@{$bufferSourceType-&gt;subtypes}, makeSimpleType(&quot;ArrayBuffer&quot;));
 610     $typedefs{&quot;BufferSource&quot;} = IDLTypedef-&gt;new(type =&gt; $bufferSourceType);
 611 
 612     # typedef unsigned long long DOMTimeStamp;
 613 
 614     my $DOMTimeStampType = IDLType-&gt;new(name =&gt; &quot;unsigned long long&quot;);
 615     $typedefs{&quot;DOMTimeStamp&quot;} = IDLTypedef-&gt;new(type =&gt; $DOMTimeStampType);
 616 }
 617 
 618 my $nextAttribute_1 = &#39;^(attribute|inherit)$&#39;;
 619 my $nextAttribute_2 = &#39;^(readonly|attribute)$&#39;;
 620 my $nextPrimitiveType_1 = &#39;^(int|long|short|unsigned)$&#39;;
 621 my $nextPrimitiveType_2 = &#39;^(double|float|unrestricted)$&#39;;
 622 my $nextArgumentList_1 = &#39;^(\(|ByteString|DOMString|USVString|Date|\[|any|boolean|byte|double|float|in|long|object|octet|optional|sequence|short|unrestricted|unsigned)$&#39;;
 623 my $nextNonAnyType_1 = &#39;^(boolean|byte|double|float|long|octet|short|unrestricted|unsigned)$&#39;;
 624 my $nextStringType_1 = &#39;^(ByteString|DOMString|USVString)$&#39;;
 625 my $nextInterfaceMember_1 = &#39;^(\(|ByteString|DOMString|USVString|Date|any|attribute|boolean|byte|deleter|double|float|getter|inherit|legacycaller|long|object|octet|readonly|sequence|setter|short|unrestricted|unsigned|void)$&#39;;
 626 my $nextOperation_1 = &#39;^(\(|ByteString|DOMString|USVString|Date|any|boolean|byte|deleter|double|float|getter|legacycaller|long|object|octet|sequence|setter|short|unrestricted|unsigned|void)$&#39;;
 627 my $nextUnrestrictedFloatType_1 = &#39;^(double|float)$&#39;;
 628 my $nextExtendedAttributeRest3_1 = &#39;^(\,|\])$&#39;;
 629 my $nextExceptionField_1 = &#39;^(\(|ByteString|DOMString|USVString|Date|any|boolean|byte|double|float|long|object|octet|sequence|short|unrestricted|unsigned)$&#39;;
 630 my $nextType_1 = &#39;^(ByteString|DOMString|USVString|Date|any|boolean|byte|double|float|long|object|octet|sequence|short|unrestricted|unsigned)$&#39;;
 631 my $nextSpecials_1 = &#39;^(deleter|getter|legacycaller|setter)$&#39;;
 632 my $nextDefinitions_1 = &#39;^(callback|dictionary|enum|exception|interface|partial|typedef)$&#39;;
 633 my $nextExceptionMembers_1 = &#39;^(\(|ByteString|DOMString|USVString|Date|\[|any|boolean|byte|const|double|float|long|object|octet|optional|sequence|short|unrestricted|unsigned)$&#39;;
 634 my $nextInterfaceMembers_1 = &#39;^(\(|ByteString|DOMString|USVString|Date|any|attribute|boolean|byte|const|deleter|double|float|getter|inherit|legacycaller|long|object|octet|readonly|sequence|serializer|setter|short|static|stringifier|unrestricted|unsigned|void)$&#39;;
 635 my $nextSingleType_1 = &#39;^(ByteString|DOMString|USVString|Date|boolean|byte|double|float|long|object|octet|sequence|short|unrestricted|unsigned)$&#39;;
 636 my $nextArgumentName_1 = &#39;^(attribute|callback|const|deleter|dictionary|enum|exception|getter|implements|inherit|interface|legacycaller|partial|serializer|setter|static|stringifier|typedef|unrestricted)$&#39;;
 637 my $nextConstValue_1 = &#39;^(false|true)$&#39;;
 638 my $nextConstValue_2 = &#39;^(-|Infinity|NaN)$&#39;;
 639 my $nextDefinition_1 = &#39;^(callback|interface)$&#39;;
 640 my $nextOperationRest_1 = &#39;^(\(|ByteString|DOMString|USVString|Date|any|boolean|byte|double|float|long|object|octet|sequence|short|unrestricted|unsigned|void)$&#39;;
 641 my $nextUnsignedIntegerType_1 = &#39;^(long|short)$&#39;;
 642 my $nextDefaultValue_1 = &#39;^(-|Infinity|NaN|false|null|true)$&#39;;
 643 
 644 
 645 sub parseDefinitions
 646 {
 647     my $self = shift;
 648     my @definitions = ();
 649 
 650     while (1) {
 651         my $extendedAttributeList = $self-&gt;parseExtendedAttributeListAllowEmpty();
 652         my $next = $self-&gt;nextToken();
 653         my $definition;
 654         if ($next-&gt;type() == IdentifierToken || $next-&gt;value() =~ /$nextDefinitions_1/) {
 655             $definition = $self-&gt;parseDefinition($extendedAttributeList);
 656         } else {
 657             last;
 658         }
 659         if (defined ($definition)) {
 660             push(@definitions, $definition);
 661         }
 662     }
 663     $self-&gt;applyTypedefs(\@definitions);
 664     return \@definitions;
 665 }
 666 
 667 sub applyTypedefs
 668 {
 669     my $self = shift;
 670     my $definitions = shift;
 671    
 672     if (!%typedefs) {
 673         return;
 674     }
 675     
 676     foreach my $definition (@$definitions) {
 677         if (ref($definition) eq &quot;IDLInterface&quot;) {
 678             foreach my $constant (@{$definition-&gt;constants}) {
 679                 $constant-&gt;type($self-&gt;typeByApplyingTypedefs($constant-&gt;type));
 680             }
 681             foreach my $attribute (@{$definition-&gt;attributes}) {
 682                 $attribute-&gt;type($self-&gt;typeByApplyingTypedefs($attribute-&gt;type));
 683             }
 684             foreach my $operation (@{$definition-&gt;operations}, @{$definition-&gt;anonymousOperations}, @{$definition-&gt;constructors}, @{$definition-&gt;customConstructors}) {
 685                 $self-&gt;applyTypedefsToOperation($operation);
 686             }
 687             if ($definition-&gt;iterable) {
 688                 if ($definition-&gt;iterable-&gt;keyType) {
 689                     $definition-&gt;iterable-&gt;keyType($self-&gt;typeByApplyingTypedefs($definition-&gt;iterable-&gt;keyType));
 690                 }
 691                 if ($definition-&gt;iterable-&gt;valueType) {
 692                     $definition-&gt;iterable-&gt;valueType($self-&gt;typeByApplyingTypedefs($definition-&gt;iterable-&gt;valueType));
 693                 }
 694                 foreach my $operation (@{$definition-&gt;iterable-&gt;operations}) {
 695                     $self-&gt;applyTypedefsToOperation($operation);
 696                 }
 697             }
 698             if ($definition-&gt;mapLike) {
 699                 if ($definition-&gt;mapLike-&gt;keyType) {
 700                     $definition-&gt;mapLike-&gt;keyType($self-&gt;typeByApplyingTypedefs($definition-&gt;mapLike-&gt;keyType));
 701                 }
 702                 if ($definition-&gt;mapLike-&gt;valueType) {
 703                     $definition-&gt;mapLike-&gt;valueType($self-&gt;typeByApplyingTypedefs($definition-&gt;mapLike-&gt;valueType));
 704                 }
 705                 foreach my $attribute (@{$definition-&gt;mapLike-&gt;attributes}) {
 706                     $attribute-&gt;type($self-&gt;typeByApplyingTypedefs($attribute-&gt;type));
 707                 }
 708                 foreach my $operation (@{$definition-&gt;mapLike-&gt;operations}) {
 709                     $self-&gt;applyTypedefsToOperation($operation);
 710                 }
 711             }
 712         } elsif (ref($definition) eq &quot;IDLDictionary&quot;) {
 713             foreach my $member (@{$definition-&gt;members}) {
 714                 $member-&gt;type($self-&gt;typeByApplyingTypedefs($member-&gt;type));
 715             }
 716         } elsif (ref($definition) eq &quot;IDLCallbackFunction&quot;) {
 717             $self-&gt;applyTypedefsToOperation($definition-&gt;operation);
 718         }
 719     }
 720 }
 721 
 722 sub applyTypedefsToOperation
 723 {
 724     my $self = shift;
 725     my $operation = shift;
 726 
 727     if ($operation-&gt;type) {
 728         $operation-&gt;type($self-&gt;typeByApplyingTypedefs($operation-&gt;type));
 729     }
 730 
 731     foreach my $argument (@{$operation-&gt;arguments}) {
 732         $argument-&gt;type($self-&gt;typeByApplyingTypedefs($argument-&gt;type));
 733     }
 734 }
 735 
 736 sub typeByApplyingTypedefs
 737 {
 738     my $self = shift;
 739     my $type = shift;
 740 
 741     assert(&quot;Missing type&quot;) if !$type;
 742 
 743     my $numberOfSubtypes = scalar @{$type-&gt;subtypes};
 744     if ($numberOfSubtypes) {
 745         for my $i (0..$numberOfSubtypes - 1) {
 746             my $subtype = @{$type-&gt;subtypes}[$i];
 747             my $replacementSubtype = $self-&gt;typeByApplyingTypedefs($subtype);
 748             @{$type-&gt;subtypes}[$i] = $replacementSubtype
 749         }
 750 
 751         return $type;
 752     }
 753 
 754     if (exists $typedefs{$type-&gt;name}) {
 755         my $typedef = $typedefs{$type-&gt;name};
 756 
 757         my $clonedType = cloneType($typedef-&gt;type);
 758         $clonedType-&gt;isNullable($clonedType-&gt;isNullable || $type-&gt;isNullable);
 759         $self-&gt;moveExtendedAttributesApplicableToTypes($clonedType, $type-&gt;extendedAttributes);
 760 
 761         return $self-&gt;typeByApplyingTypedefs($clonedType);
 762     }
 763     
 764     return $type;
 765 }
 766 
 767 sub parseDefinition
 768 {
 769     my $self = shift;
 770     my $extendedAttributeList = shift;
 771 
 772     my $next = $self-&gt;nextToken();
 773     if ($next-&gt;value() =~ /$nextDefinition_1/) {
 774         return $self-&gt;parseCallbackOrInterface($extendedAttributeList);
 775     }
 776     if ($next-&gt;value() eq &quot;partial&quot;) {
 777         return $self-&gt;parsePartial($extendedAttributeList);
 778     }
 779     if ($next-&gt;value() eq &quot;dictionary&quot;) {
 780         return $self-&gt;parseDictionary($extendedAttributeList);
 781     }
 782     if ($next-&gt;value() eq &quot;exception&quot;) {
 783         return $self-&gt;parseException($extendedAttributeList);
 784     }
 785     if ($next-&gt;value() eq &quot;enum&quot;) {
 786         return $self-&gt;parseEnum($extendedAttributeList);
 787     }
 788     if ($next-&gt;value() eq &quot;typedef&quot;) {
 789         return $self-&gt;parseTypedef($extendedAttributeList);
 790     }
 791     if ($next-&gt;type() == IdentifierToken) {
 792         return $self-&gt;parseImplementsStatement($extendedAttributeList);
 793     }
 794     $self-&gt;assertUnexpectedToken($next-&gt;value(), __LINE__);
 795 }
 796 
 797 sub parseCallbackOrInterface
 798 {
 799     my $self = shift;
 800     my $extendedAttributeList = shift;
 801 
 802     my $next = $self-&gt;nextToken();
 803     if ($next-&gt;value() eq &quot;callback&quot;) {
 804         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;callback&quot;, __LINE__);
 805         return $self-&gt;parseCallbackRestOrInterface($extendedAttributeList);
 806     }
 807     if ($next-&gt;value() eq &quot;interface&quot;) {
 808         return $self-&gt;parseInterface($extendedAttributeList);
 809     }
 810     $self-&gt;assertUnexpectedToken($next-&gt;value(), __LINE__);
 811 }
 812 
 813 sub parseCallbackRestOrInterface
 814 {
 815     my $self = shift;
 816     my $extendedAttributeList = shift;
 817 
 818     my $next = $self-&gt;nextToken();
 819     if ($next-&gt;value() eq &quot;interface&quot;) {
 820         my $interface = $self-&gt;parseInterface($extendedAttributeList);
 821         $interface-&gt;isCallback(1);
 822         return $interface;
 823     }
 824     if ($next-&gt;type() == IdentifierToken) {
 825         return $self-&gt;parseCallbackRest($extendedAttributeList);
 826     }
 827     $self-&gt;assertUnexpectedToken($next-&gt;value(), __LINE__);
 828 }
 829 
 830 sub parseInterface
 831 {
 832     my $self = shift;
 833     my $extendedAttributeList = shift;
 834 
 835     my $next = $self-&gt;nextToken();
 836     if ($next-&gt;value() eq &quot;interface&quot;) {
 837         my $interface = IDLInterface-&gt;new();
 838         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;interface&quot;, __LINE__);
 839         my $interfaceNameToken = $self-&gt;getToken();
 840         $self-&gt;assertTokenType($interfaceNameToken, IdentifierToken);
 841         
 842         my $name = identifierRemoveNullablePrefix($interfaceNameToken-&gt;value());
 843         $interface-&gt;type(makeSimpleType($name));
 844 
 845         $next = $self-&gt;nextToken();
 846         if ($next-&gt;value() eq &quot;:&quot;) {
 847             my $parent = $self-&gt;parseInheritance();
 848             $interface-&gt;parentType(makeSimpleType($parent));
 849         }
 850 
 851         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;{&quot;, __LINE__);
 852         my $interfaceMembers = $self-&gt;parseInterfaceMembers();
 853         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;}&quot;, __LINE__);
 854         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;;&quot;, __LINE__);
 855         applyMemberList($interface, $interfaceMembers);
 856 
 857         $self-&gt;assertExtendedAttributesValidForContext($extendedAttributeList, &quot;interface&quot;);
 858         applyExtendedAttributeList($interface, $extendedAttributeList);
 859 
 860         return $interface;
 861     }
 862     $self-&gt;assertUnexpectedToken($next-&gt;value(), __LINE__);
 863 }
 864 
 865 sub parsePartial
 866 {
 867     my $self = shift;
 868     my $extendedAttributeList = shift;
 869 
 870     my $next = $self-&gt;nextToken();
 871     if ($next-&gt;value() eq &quot;partial&quot;) {
 872         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;partial&quot;, __LINE__);
 873         return $self-&gt;parsePartialDefinition($extendedAttributeList);
 874     }
 875     $self-&gt;assertUnexpectedToken($next-&gt;value(), __LINE__);
 876 }
 877 
 878 sub parsePartialDefinition
 879 {
 880     my $self = shift;
 881     my $extendedAttributeList = shift;
 882 
 883     my $next = $self-&gt;nextToken();
 884     if ($next-&gt;value() eq &quot;interface&quot;) {
 885         my $interface = $self-&gt;parseInterface($extendedAttributeList);
 886         $interface-&gt;isPartial(1);
 887         return $interface;
 888     }
 889     if ($next-&gt;value() eq &quot;dictionary&quot;) {
<a name="2" id="anc2"></a><span class="line-modified"> 890         return $self-&gt;parsePartialDictionary($extendedAttributeList);</span>
<span class="line-modified"> 891     }</span>
<span class="line-modified"> 892     $self-&gt;assertUnexpectedToken($next-&gt;value(), __LINE__);</span>
<span class="line-removed"> 893 }</span>
<span class="line-removed"> 894 </span>
<span class="line-removed"> 895 sub parsePartialInterface</span>
<span class="line-removed"> 896 {</span>
<span class="line-removed"> 897     my $self = shift;</span>
<span class="line-removed"> 898     my $extendedAttributeList = shift;</span>
<span class="line-removed"> 899 </span>
<span class="line-removed"> 900     my $next = $self-&gt;nextToken();</span>
<span class="line-removed"> 901     if ($next-&gt;value() eq &quot;interface&quot;) {</span>
<span class="line-removed"> 902         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;interface&quot;, __LINE__);</span>
<span class="line-removed"> 903         $self-&gt;assertTokenType($self-&gt;getToken(), IdentifierToken);</span>
<span class="line-removed"> 904         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;{&quot;, __LINE__);</span>
<span class="line-removed"> 905         $self-&gt;parseInterfaceMembers();</span>
<span class="line-removed"> 906         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;}&quot;, __LINE__);</span>
<span class="line-removed"> 907         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;;&quot;, __LINE__);</span>
<span class="line-removed"> 908         return;</span>
 909     }
 910     $self-&gt;assertUnexpectedToken($next-&gt;value(), __LINE__);
 911 }
 912 
 913 sub parseInterfaceMembers
 914 {
 915     my $self = shift;
 916     my @interfaceMembers = ();
 917 
 918     while (1) {
 919         my $extendedAttributeList = $self-&gt;parseExtendedAttributeListAllowEmpty();
 920         my $next = $self-&gt;nextToken();
 921         my $interfaceMember;
 922 
 923         if ($next-&gt;type() == IdentifierToken || $next-&gt;value() =~ /$nextInterfaceMembers_1/) {
 924             $interfaceMember = $self-&gt;parseInterfaceMember($extendedAttributeList);
 925         } else {
 926             last;
 927         }
 928         if (defined $interfaceMember) {
 929             push(@interfaceMembers, $interfaceMember);
 930         }
 931     }
 932     return \@interfaceMembers;
 933 }
 934 
 935 sub parseInterfaceMember
 936 {
 937     my $self = shift;
 938     my $extendedAttributeList = shift;
 939 
 940     my $next = $self-&gt;nextToken();
 941     if ($next-&gt;value() eq &quot;const&quot;) {
 942         return $self-&gt;parseConst($extendedAttributeList);
 943     }
 944 
 945     if ($next-&gt;value() eq &quot;serializer&quot;) {
 946         return $self-&gt;parseSerializer($extendedAttributeList);
 947     }
 948 
 949     if ($next-&gt;value() eq &quot;stringifier&quot;) {
 950         return $self-&gt;parseStringifier($extendedAttributeList);
 951     }
 952 
 953     if ($next-&gt;value() eq &quot;static&quot;) {
 954         return $self-&gt;parseStaticMember($extendedAttributeList);
 955     }
 956 
 957     if ($next-&gt;value() eq &quot;iterable&quot;) {
 958         return $self-&gt;parseIterableRest($extendedAttributeList);
 959     }
 960 
 961     if ($next-&gt;value() eq &quot;readonly&quot;) {
 962         return $self-&gt;parseReadOnlyMember($extendedAttributeList);
 963     }
 964 
 965     if ($next-&gt;type() == IdentifierToken || $next-&gt;value() =~ /$nextInterfaceMember_1/) {
 966         return $self-&gt;parseOperationOrReadWriteAttributeOrMaplike($extendedAttributeList);
 967     }
 968 
 969     $self-&gt;assertUnexpectedToken($next-&gt;value(), __LINE__);
 970 }
 971 
 972 sub parseDictionary
 973 {
 974     my $self = shift;
 975     my $extendedAttributeList = shift;
 976 
 977     my $next = $self-&gt;nextToken();
 978     if ($next-&gt;value() eq &quot;dictionary&quot;) {
 979         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;dictionary&quot;, __LINE__);
 980 
 981         my $dictionary = IDLDictionary-&gt;new();
 982 
 983         $self-&gt;assertExtendedAttributesValidForContext($extendedAttributeList, &quot;dictionary&quot;);
 984         $dictionary-&gt;extendedAttributes($extendedAttributeList);
 985 
 986         my $nameToken = $self-&gt;getToken();
 987         $self-&gt;assertTokenType($nameToken, IdentifierToken);
 988 
 989         my $name = $nameToken-&gt;value();
 990         $dictionary-&gt;type(makeSimpleType($name));
 991 
 992         $next = $self-&gt;nextToken();
 993         if ($next-&gt;value() eq &quot;:&quot;) {
 994             my $parent = $self-&gt;parseInheritance();
 995             $dictionary-&gt;parentType(makeSimpleType($parent));
 996         }
 997         
 998         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;{&quot;, __LINE__);
 999         $dictionary-&gt;members($self-&gt;parseDictionaryMembers());
1000         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;}&quot;, __LINE__);
1001         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;;&quot;, __LINE__);
1002         return $dictionary;
1003     }
1004     $self-&gt;assertUnexpectedToken($next-&gt;value(), __LINE__);
1005 }
1006 
1007 sub parseDictionaryMembers
1008 {
1009     my $self = shift;
1010 
1011     my @members = ();
1012 
1013     while (1) {
1014         my $extendedAttributeList = $self-&gt;parseExtendedAttributeListAllowEmpty();
1015         my $next = $self-&gt;nextToken();
1016         if ($next-&gt;type() == IdentifierToken || $next-&gt;value() =~ /$nextExceptionField_1/) {
1017             push(@members, $self-&gt;parseDictionaryMember($extendedAttributeList));
1018         } else {
1019             last;
1020         }
1021     }
1022 
1023     return \@members;
1024 }
1025 
1026 sub parseDictionaryMember
1027 {
1028     my $self = shift;
1029     my $extendedAttributeList = shift;
1030 
1031     my $next = $self-&gt;nextToken();
1032     if ($next-&gt;type() == IdentifierToken || $next-&gt;value() =~ /$nextExceptionField_1/) {
1033         my $member = IDLDictionaryMember-&gt;new();
1034 
1035         if ($next-&gt;value eq &quot;required&quot;) {
1036             $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;required&quot;, __LINE__);
1037             $member-&gt;isRequired(1);
1038 
1039             my $type = $self-&gt;parseTypeWithExtendedAttributes();
1040             $member-&gt;type($type);
1041         } else {
1042             $member-&gt;isRequired(0);
1043 
1044             my $type = $self-&gt;parseType();
1045             $self-&gt;moveExtendedAttributesApplicableToTypes($type, $extendedAttributeList);
1046             
1047             $member-&gt;type($type);
1048         }
1049 
1050         $self-&gt;assertExtendedAttributesValidForContext($extendedAttributeList, &quot;dictionary-member&quot;);
1051         $member-&gt;extendedAttributes($extendedAttributeList);
1052 
1053         my $nameToken = $self-&gt;getToken();
1054         $self-&gt;assertTokenType($nameToken, IdentifierToken);
1055         $member-&gt;name($nameToken-&gt;value);
1056         $member-&gt;default($self-&gt;parseDefault());
1057         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;;&quot;, __LINE__);
1058         return $member;
1059     }
1060     $self-&gt;assertUnexpectedToken($next-&gt;value(), __LINE__);
1061 }
1062 
<a name="3" id="anc3"></a><span class="line-removed">1063 sub parsePartialDictionary</span>
<span class="line-removed">1064 {</span>
<span class="line-removed">1065     my $self = shift;</span>
<span class="line-removed">1066     my $next = $self-&gt;nextToken();</span>
<span class="line-removed">1067     if ($next-&gt;value() eq &quot;dictionary&quot;) {</span>
<span class="line-removed">1068         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;dictionary&quot;, __LINE__);</span>
<span class="line-removed">1069         $self-&gt;assertTokenType($self-&gt;getToken(), IdentifierToken);</span>
<span class="line-removed">1070         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;{&quot;, __LINE__);</span>
<span class="line-removed">1071         $self-&gt;parseDictionaryMembers();</span>
<span class="line-removed">1072         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;}&quot;, __LINE__);</span>
<span class="line-removed">1073         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;;&quot;, __LINE__);</span>
<span class="line-removed">1074         return;</span>
<span class="line-removed">1075     }</span>
<span class="line-removed">1076     $self-&gt;assertUnexpectedToken($next-&gt;value(), __LINE__);</span>
<span class="line-removed">1077 }</span>
<span class="line-removed">1078 </span>
1079 sub parseDefault
1080 {
1081     my $self = shift;
1082     my $next = $self-&gt;nextToken();
1083     if ($next-&gt;value() eq &quot;=&quot;) {
1084         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;=&quot;, __LINE__);
1085         return $self-&gt;parseDefaultValue();
1086     }
1087     return undef;
1088 }
1089 
1090 sub parseDefaultValue
1091 {
1092     my $self = shift;
1093     my $next = $self-&gt;nextToken();
1094     if ($next-&gt;type() == FloatToken || $next-&gt;type() == IntegerToken || $next-&gt;value() =~ /$nextDefaultValue_1/) {
1095         return $self-&gt;parseConstValue();
1096     }
1097     if ($next-&gt;type() == StringToken) {
1098         return $self-&gt;getToken()-&gt;value();
1099     }
1100     if ($next-&gt;value() eq &quot;[&quot;) {
1101         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;[&quot;, __LINE__);
1102         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;]&quot;, __LINE__);
1103         return &quot;[]&quot;;
1104     }
1105     $self-&gt;assertUnexpectedToken($next-&gt;value(), __LINE__);
1106 }
1107 
1108 sub parseException
1109 {
1110     my $self = shift;
1111     my $extendedAttributeList = shift;
1112 
1113     my $next = $self-&gt;nextToken();
1114     if ($next-&gt;value() eq &quot;exception&quot;) {
1115         my $interface = IDLInterface-&gt;new();
1116         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;exception&quot;, __LINE__);
1117         my $exceptionNameToken = $self-&gt;getToken();
1118         $self-&gt;assertTokenType($exceptionNameToken, IdentifierToken);
1119 
1120         my $name = identifierRemoveNullablePrefix($exceptionNameToken-&gt;value());
1121         $interface-&gt;type(makeSimpleType($name));
1122         $interface-&gt;isException(1);
1123 
1124         $next = $self-&gt;nextToken();
1125         if ($next-&gt;value() eq &quot;:&quot;) {
1126             my $parent = $self-&gt;parseInheritance();
1127             $interface-&gt;parentType(makeSimpleType($parent));
1128         }
1129         
1130         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;{&quot;, __LINE__);
1131         my $exceptionMembers = $self-&gt;parseExceptionMembers();
1132         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;}&quot;, __LINE__);
1133         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;;&quot;, __LINE__);
1134         applyMemberList($interface, $exceptionMembers);
1135         
1136         $self-&gt;assertExtendedAttributesValidForContext($extendedAttributeList, &quot;interface&quot;);
1137         applyExtendedAttributeList($interface, $extendedAttributeList);
1138 
1139         return $interface;
1140     }
1141     $self-&gt;assertUnexpectedToken($next-&gt;value(), __LINE__);
1142 }
1143 
1144 sub parseExceptionMembers
1145 {
1146     my $self = shift;
1147     my @members = ();
1148 
1149     while (1) {
1150         my $next = $self-&gt;nextToken();
1151         if ($next-&gt;type() == IdentifierToken || $next-&gt;value() =~ /$nextExceptionMembers_1/) {
1152             my $extendedAttributeList = $self-&gt;parseExtendedAttributeListAllowEmpty();
1153             #my $member = $self-&gt;parseExceptionMember($extendedAttributeList);
1154             my $member = $self-&gt;parseInterfaceMember($extendedAttributeList);
1155             if (defined ($member)) {
1156                 push(@members, $member);
1157             }
1158         } else {
1159             last;
1160         }
1161     }
1162     return \@members;
1163 }
1164 
1165 sub parseInheritance
1166 {
1167     my $self = shift;
1168 
1169     my $next = $self-&gt;nextToken();
1170     if ($next-&gt;value() eq &quot;:&quot;) {
1171         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;:&quot;, __LINE__);
1172         return $self-&gt;parseName();
1173     }
1174     $self-&gt;assertUnexpectedToken($next-&gt;value(), __LINE__);
1175 }
1176 
1177 sub parseEnum
1178 {
1179     my $self = shift;
1180     my $extendedAttributeList = shift;
1181 
1182     my $next = $self-&gt;nextToken();
1183     if ($next-&gt;value() eq &quot;enum&quot;) {
1184         my $enum = IDLEnum-&gt;new();
1185         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;enum&quot;, __LINE__);
1186         my $enumNameToken = $self-&gt;getToken();
1187         $self-&gt;assertTokenType($enumNameToken, IdentifierToken);
1188         my $name = identifierRemoveNullablePrefix($enumNameToken-&gt;value());
1189         $enum-&gt;name($name);
1190         $enum-&gt;type(makeSimpleType($name));
1191         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;{&quot;, __LINE__);
1192         push(@{$enum-&gt;values}, @{$self-&gt;parseEnumValueList()});
1193         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;}&quot;, __LINE__);
1194         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;;&quot;, __LINE__);
1195         
1196         $self-&gt;assertExtendedAttributesValidForContext($extendedAttributeList, &quot;enum&quot;);
1197         $enum-&gt;extendedAttributes($extendedAttributeList);
1198         return $enum;
1199     }
1200     $self-&gt;assertUnexpectedToken($next-&gt;value(), __LINE__);
1201 }
1202 
1203 sub parseEnumValueList
1204 {
1205     my $self = shift;
1206     my @values = ();
1207     my $next = $self-&gt;nextToken();
1208     if ($next-&gt;type() == StringToken) {
1209         my $enumValueToken = $self-&gt;getToken();
1210         $self-&gt;assertTokenType($enumValueToken, StringToken);
1211         my $enumValue = $self-&gt;unquoteString($enumValueToken-&gt;value());
1212         push(@values, $enumValue);
1213         push(@values, @{$self-&gt;parseEnumValues()});
1214         return \@values;
1215     }
1216     # value list must be non-empty
1217     $self-&gt;assertUnexpectedToken($next-&gt;value(), __LINE__);
1218 }
1219 
1220 sub parseEnumValues
1221 {
1222     my $self = shift;
1223     my @values = ();
1224     my $next = $self-&gt;nextToken();
1225     if ($next-&gt;value() eq &quot;,&quot;) {
1226         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;,&quot;, __LINE__);
1227         my $enumValueToken = $self-&gt;getToken();
1228         $self-&gt;assertTokenType($enumValueToken, StringToken);
1229         my $enumValue = $self-&gt;unquoteString($enumValueToken-&gt;value());
1230         push(@values, $enumValue);
1231         push(@values, @{$self-&gt;parseEnumValues()});
1232         return \@values;
1233     }
1234     return \@values; # empty list (end of enumeration-values)
1235 }
1236 
1237 sub parseCallbackRest
1238 {
1239     my $self = shift;
1240     my $extendedAttributeList = shift;
1241 
1242     my $next = $self-&gt;nextToken();
1243     if ($next-&gt;type() == IdentifierToken) {
1244         my $callback = IDLCallbackFunction-&gt;new();
1245 
1246         my $nameToken = $self-&gt;getToken();
1247         $self-&gt;assertTokenType($nameToken, IdentifierToken);
1248 
1249         $callback-&gt;type(makeSimpleType($nameToken-&gt;value()));
1250 
1251         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;=&quot;, __LINE__);
1252 
1253         my $operation = IDLOperation-&gt;new();
1254         $operation-&gt;type($self-&gt;parseReturnType());
1255         
1256         $self-&gt;assertExtendedAttributesValidForContext($extendedAttributeList, &quot;callback-function&quot;, &quot;operation&quot;);
1257         $operation-&gt;extendedAttributes($extendedAttributeList);
1258 
1259         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;(&quot;, __LINE__);
1260 
1261         push(@{$operation-&gt;arguments}, @{$self-&gt;parseArgumentList()});
1262 
1263         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;)&quot;, __LINE__);
1264         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;;&quot;, __LINE__);
1265 
1266         $callback-&gt;operation($operation);
1267         $callback-&gt;extendedAttributes($extendedAttributeList);
1268 
1269         return $callback;
1270     }
1271     $self-&gt;assertUnexpectedToken($next-&gt;value(), __LINE__);
1272 }
1273 
1274 sub parseTypedef
1275 {
1276     my $self = shift;
1277     my $extendedAttributeList = shift;
1278     die &quot;Extended attributes are not applicable to typedefs themselves: &quot; . $self-&gt;{Line} if %{$extendedAttributeList};
1279 
1280     my $next = $self-&gt;nextToken();
1281     if ($next-&gt;value() eq &quot;typedef&quot;) {
1282         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;typedef&quot;, __LINE__);
1283         my $typedef = IDLTypedef-&gt;new();
1284 
1285         my $type = $self-&gt;parseTypeWithExtendedAttributes();
1286         $typedef-&gt;type($type);
1287 
1288         my $nameToken = $self-&gt;getToken();
1289         $self-&gt;assertTokenType($nameToken, IdentifierToken);
1290         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;;&quot;, __LINE__);
1291         my $name = $nameToken-&gt;value();
1292         die &quot;typedef redefinition for &quot; . $name . &quot; at &quot; . $self-&gt;{Line} if (exists $typedefs{$name} &amp;&amp; $typedef-&gt;type-&gt;name ne $typedefs{$name}-&gt;type-&gt;name);
1293         $typedefs{$name} = $typedef;
1294         return;
1295     }
1296     $self-&gt;assertUnexpectedToken($next-&gt;value(), __LINE__);
1297 }
1298 
1299 sub parseImplementsStatement
1300 {
1301     my $self = shift;
1302     my $extendedAttributeList = shift;
1303 
1304     my $next = $self-&gt;nextToken();
1305     if ($next-&gt;type() == IdentifierToken) {
1306         $self-&gt;parseName();
1307         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;implements&quot;, __LINE__);
1308         $self-&gt;parseName();
1309         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;;&quot;, __LINE__);
1310         return;
1311     }
1312     $self-&gt;assertUnexpectedToken($next-&gt;value(), __LINE__);
1313 }
1314 
1315 sub parseConst
1316 {
1317     my $self = shift;
1318     my $extendedAttributeList = shift;
1319 
1320     my $next = $self-&gt;nextToken();
1321     if ($next-&gt;value() eq &quot;const&quot;) {
1322         my $newDataNode = IDLConstant-&gt;new();
1323         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;const&quot;, __LINE__);
1324         my $type = $self-&gt;parseConstType();
1325         $newDataNode-&gt;type($type);
1326         my $constNameToken = $self-&gt;getToken();
1327         $self-&gt;assertTokenType($constNameToken, IdentifierToken);
1328         $newDataNode-&gt;name(identifierRemoveNullablePrefix($constNameToken-&gt;value()));
1329         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;=&quot;, __LINE__);
1330         $newDataNode-&gt;value($self-&gt;parseConstValue());
1331         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;;&quot;, __LINE__);
1332 
1333         $self-&gt;assertExtendedAttributesValidForContext($extendedAttributeList, &quot;constant&quot;);
1334         $newDataNode-&gt;extendedAttributes($extendedAttributeList);
1335 
1336         return $newDataNode;
1337     }
1338     $self-&gt;assertUnexpectedToken($next-&gt;value(), __LINE__);
1339 }
1340 
1341 sub parseConstValue
1342 {
1343     my $self = shift;
1344     my $next = $self-&gt;nextToken();
1345     if ($next-&gt;value() =~ /$nextConstValue_1/) {
1346         return $self-&gt;parseBooleanLiteral();
1347     }
1348     if ($next-&gt;value() eq &quot;null&quot;) {
1349         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;null&quot;, __LINE__);
1350         return &quot;null&quot;;
1351     }
1352     if ($next-&gt;type() == FloatToken || $next-&gt;value() =~ /$nextConstValue_2/) {
1353         return $self-&gt;parseFloatLiteral();
1354     }
1355     if ($next-&gt;type() == IntegerToken) {
1356         return $self-&gt;getToken()-&gt;value();
1357     }
1358     $self-&gt;assertUnexpectedToken($next-&gt;value(), __LINE__);
1359 }
1360 
1361 sub parseBooleanLiteral
1362 {
1363     my $self = shift;
1364     my $next = $self-&gt;nextToken();
1365     if ($next-&gt;value() eq &quot;true&quot;) {
1366         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;true&quot;, __LINE__);
1367         return &quot;true&quot;;
1368     }
1369     if ($next-&gt;value() eq &quot;false&quot;) {
1370         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;false&quot;, __LINE__);
1371         return &quot;false&quot;;
1372     }
1373     $self-&gt;assertUnexpectedToken($next-&gt;value(), __LINE__);
1374 }
1375 
1376 sub parseFloatLiteral
1377 {
1378     my $self = shift;
1379     my $next = $self-&gt;nextToken();
1380     if ($next-&gt;value() eq &quot;-&quot;) {
1381         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;-&quot;, __LINE__);
1382         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;Infinity&quot;, __LINE__);
1383         return &quot;-Infinity&quot;;
1384     }
1385     if ($next-&gt;value() eq &quot;Infinity&quot;) {
1386         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;Infinity&quot;, __LINE__);
1387         return &quot;Infinity&quot;;
1388     }
1389     if ($next-&gt;value() eq &quot;NaN&quot;) {
1390         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;NaN&quot;, __LINE__);
1391         return &quot;NaN&quot;;
1392     }
1393     if ($next-&gt;type() == FloatToken) {
1394         return $self-&gt;getToken()-&gt;value();
1395     }
1396     $self-&gt;assertUnexpectedToken($next-&gt;value(), __LINE__);
1397 }
1398 
1399 sub parseOperationOrReadWriteAttributeOrMaplike
1400 {
1401     my $self = shift;
1402     my $extendedAttributeList = shift;
1403 
1404     my $next = $self-&gt;nextToken();
1405     if ($next-&gt;value() =~ /$nextAttribute_1/) {
1406         return $self-&gt;parseReadWriteAttribute($extendedAttributeList);
1407     }
1408     if ($next-&gt;value() eq &quot;maplike&quot;) {
1409         return $self-&gt;parseMapLikeRest($extendedAttributeList, 0);
1410     }
1411     if ($next-&gt;type() == IdentifierToken || $next-&gt;value() =~ /$nextOperation_1/) {
1412         return $self-&gt;parseOperation($extendedAttributeList);
1413     }
1414     $self-&gt;assertUnexpectedToken($next-&gt;value(), __LINE__);
1415 }
1416 
1417 sub parseReadOnlyMember
1418 {
1419     my $self = shift;
1420     my $extendedAttributeList = shift;
1421 
1422     my $next = $self-&gt;nextToken();
1423     if ($next-&gt;value() eq &quot;readonly&quot;) {
1424         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;readonly&quot;, __LINE__);
1425 
1426         my $next = $self-&gt;nextToken();
1427         if ($next-&gt;value() eq &quot;attribute&quot;) {
1428             my $attribute = $self-&gt;parseAttributeRest($extendedAttributeList);
1429             $attribute-&gt;isReadOnly(1);
1430             return $attribute;
1431         }
1432         if ($next-&gt;value() eq &quot;maplike&quot;) {
1433             return $self-&gt;parseMapLikeRest($extendedAttributeList, 1);
1434         }
1435     }
1436     $self-&gt;assertUnexpectedToken($next-&gt;value(), __LINE__);
1437 }
1438 
1439 sub parseSerializer
1440 {
1441     my $self = shift;
1442     my $extendedAttributeList = shift;
1443 
1444     my $next = $self-&gt;nextToken();
1445     if ($next-&gt;value() eq &quot;serializer&quot;) {
1446         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;serializer&quot;, __LINE__);
1447         my $next = $self-&gt;nextToken();
1448         my $newDataNode;
1449         if ($next-&gt;value() ne &quot;;&quot;) {
1450             $newDataNode = $self-&gt;parseSerializerRest($extendedAttributeList);
1451             my $next = $self-&gt;nextToken();
1452         } else {
1453             $newDataNode = IDLSerializable-&gt;new();
1454         }
1455 
1456         my $toJSONOperation = IDLOperation-&gt;new();
1457         $toJSONOperation-&gt;name(&quot;toJSON&quot;);
1458 
1459         $self-&gt;assertExtendedAttributesValidForContext($extendedAttributeList, &quot;operation&quot;);
1460         $toJSONOperation-&gt;extendedAttributes($extendedAttributeList);
1461         $toJSONOperation-&gt;isSerializer(1);
1462         push(@{$newDataNode-&gt;operations}, $toJSONOperation);
1463 
1464         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;;&quot;, __LINE__);
1465         return $newDataNode;
1466     }
1467     $self-&gt;assertUnexpectedToken($next-&gt;value(), __LINE__);
1468 }
1469 
1470 sub parseSerializerRest
1471 {
1472     my $self = shift;
1473     my $extendedAttributeList = shift;
1474 
1475     my $next = $self-&gt;nextToken();
1476     if ($next-&gt;value() eq &quot;=&quot;) {
1477         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;=&quot;, __LINE__);
1478 
1479         return $self-&gt;parseSerializationPattern();
1480 
1481     }
1482     if ($next-&gt;type() == IdentifierToken || $next-&gt;value() eq &quot;(&quot;) {
1483         return $self-&gt;parseOperationRest($extendedAttributeList);
1484     }
1485 }
1486 
1487 sub parseSerializationPattern
1488 {
1489     my $self = shift;
1490 
1491     my $next = $self-&gt;nextToken();
1492     if ($next-&gt;value() eq &quot;{&quot;) {
1493         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;{&quot;, __LINE__);
1494         my $newDataNode = IDLSerializable-&gt;new();
1495         $self-&gt;parseSerializationAttributes($newDataNode);
1496         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;}&quot;, __LINE__);
1497         return $newDataNode;
1498     }
1499     if ($next-&gt;value() eq &quot;[&quot;) {
1500         die &quot;Serialization of lists pattern is not currently supported.&quot;;
1501     }
1502     if ($next-&gt;type() == IdentifierToken) {
1503         my @attributes = ();
1504         my $token = $self-&gt;getToken();
1505         $self-&gt;assertTokenType($token, IdentifierToken);
1506         push(@attributes, $token-&gt;value());
1507 
1508         my $newDataNode = IDLSerializable-&gt;new();
1509         $newDataNode-&gt;attributes(\@attributes);
1510 
1511         return $newDataNode;
1512     }
1513     $self-&gt;assertUnexpectedToken($next-&gt;value(), __LINE__);
1514 }
1515 
1516 sub parseSerializationAttributes
1517 {
1518     my $self = shift;
1519     my $serializable = shift;
1520 
1521     my @attributes = ();
1522     my @identifiers = $self-&gt;parseIdentifierList();
1523 
1524     for my $identifier (@identifiers) {
1525         if ($identifier eq &quot;getter&quot;) {
1526             $serializable-&gt;hasGetter(1);
1527             die &quot;Serializer getter keyword is not currently supported.&quot;;
1528         }
1529 
1530         if ($identifier eq &quot;inherit&quot;) {
1531             $serializable-&gt;hasInherit(1);
1532             next;
1533         }
1534 
1535         if ($identifier eq &quot;attribute&quot;) {
1536             $serializable-&gt;hasAttribute(1);
1537             # Attributes will be filled in via applyMemberList()
1538             next;
1539         }
1540 
1541         push(@attributes, $identifier);
1542     }
1543 
1544     $serializable-&gt;attributes(\@attributes);
1545 }
1546 
1547 sub parseIdentifierList
1548 {
1549     my $self = shift;
1550     my $next = $self-&gt;nextToken();
1551 
1552     my @identifiers = ();
1553     if ($next-&gt;type == IdentifierToken) {
1554         push(@identifiers, $self-&gt;getToken()-&gt;value());
1555         push(@identifiers, @{$self-&gt;parseIdentifiers()});
1556     }
1557     return @identifiers;
1558 }
1559 
1560 sub parseIdentifiers
1561 {
1562     my $self = shift;
1563     my @idents = ();
1564 
1565     while (1) {
1566         my $next = $self-&gt;nextToken();
1567         if ($next-&gt;value() eq &quot;,&quot;) {
1568             $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;,&quot;, __LINE__);
1569             my $token = $self-&gt;getToken();
1570             $self-&gt;assertTokenType($token, IdentifierToken);
1571             push(@idents, $token-&gt;value());
1572         } else {
1573             last;
1574         }
1575     }
1576     return \@idents;
1577 }
1578 
1579 sub parseStringifier
1580 {
1581     my $self = shift;
1582     my $extendedAttributeList = shift;
1583 
1584     my $next = $self-&gt;nextToken();
1585     if ($next-&gt;value() eq &quot;stringifier&quot;) {
1586         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;stringifier&quot;, __LINE__);
1587 
1588         $next = $self-&gt;nextToken();
1589         if ($next-&gt;value() eq &quot;;&quot;) {
1590             $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;;&quot;, __LINE__);
1591 
1592             my $operation = IDLOperation-&gt;new();
1593             $operation-&gt;isStringifier(1);
1594             $operation-&gt;name(&quot;&quot;);
1595             $operation-&gt;type(makeSimpleType(&quot;DOMString&quot;));
1596             $operation-&gt;extendedAttributes($extendedAttributeList);
1597 
1598             return $operation;
1599         } else {
1600             my $attributeOrOperation = $self-&gt;parseAttributeOrOperationForStringifierOrStatic($extendedAttributeList);
1601             $attributeOrOperation-&gt;isStringifier(1);
1602 
1603             return $attributeOrOperation;
1604         }
1605     }
1606     $self-&gt;assertUnexpectedToken($next-&gt;value(), __LINE__);
1607 }
1608 
1609 sub parseStaticMember
1610 {
1611     my $self = shift;
1612     my $extendedAttributeList = shift;
1613 
1614     my $next = $self-&gt;nextToken();
1615     if ($next-&gt;value() eq &quot;static&quot;) {
1616         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;static&quot;, __LINE__);
1617 
1618         my $attributeOrOperation = $self-&gt;parseAttributeOrOperationForStringifierOrStatic($extendedAttributeList);
1619         $attributeOrOperation-&gt;isStatic(1);
1620 
1621         return $attributeOrOperation;
1622     }
1623     $self-&gt;assertUnexpectedToken($next-&gt;value(), __LINE__);
1624 }
1625 
1626 sub parseAttributeOrOperationForStringifierOrStatic
1627 {
1628     my $self = shift;
1629     my $extendedAttributeList = shift;
1630 
1631     my $next = $self-&gt;nextToken();
1632     if ($next-&gt;value() =~ /$nextAttribute_2/) {
1633         my $isReadOnly = $self-&gt;parseReadOnly();
1634 
1635         my $attribute = $self-&gt;parseAttributeRest($extendedAttributeList);
1636         $attribute-&gt;isReadOnly($isReadOnly);
1637 
1638         return $attribute;
1639     }
1640 
1641     if ($next-&gt;type() == IdentifierToken || $next-&gt;value() =~ /$nextOperationRest_1/) {
1642         my $returnType = $self-&gt;parseReturnType();
1643 
1644         # NOTE: This is a non-standard addition. In WebIDL, there is no way to associate
1645         # extended attributes with a return type.
1646         $self-&gt;moveExtendedAttributesApplicableToTypes($returnType, $extendedAttributeList);
1647 
1648         my $operation = $self-&gt;parseOperationRest($extendedAttributeList);
1649         $operation-&gt;type($returnType);
1650 
1651         return $operation;
1652     }
1653     $self-&gt;assertUnexpectedToken($next-&gt;value(), __LINE__);
1654 }
1655 
1656 sub parseReadWriteAttribute
1657 {
1658     my $self = shift;
1659     my $extendedAttributeList = shift;
1660 
1661     my $next = $self-&gt;nextToken();
1662     if ($next-&gt;value() eq &quot;inherit&quot;) {
1663         my $isInherit = $self-&gt;parseInherit();
1664         my $isReadOnly = $self-&gt;parseReadOnly();
1665 
1666         my $attribute = $self-&gt;parseAttributeRest($extendedAttributeList);
1667 
1668         $attribute-&gt;isInherit($isInherit);
1669         $attribute-&gt;isReadOnly($isReadOnly);
1670 
1671         return $attribute;
1672     } else {
1673         return $self-&gt;parseAttributeRest($extendedAttributeList);
1674     }
1675     $self-&gt;assertUnexpectedToken($next-&gt;value(), __LINE__);
1676 }
1677 
1678 sub parseAttributeRest
1679 {
1680     my $self = shift;
1681     my $extendedAttributeList = shift;
1682 
1683     my $next = $self-&gt;nextToken();
1684     if ($next-&gt;value() eq &quot;attribute&quot;) {
1685         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;attribute&quot;, __LINE__);
1686 
1687         my $attribute = IDLAttribute-&gt;new();
1688         
1689         $self-&gt;assertExtendedAttributesValidForContext($extendedAttributeList, &quot;attribute&quot;);
1690         $attribute-&gt;extendedAttributes($extendedAttributeList);
1691 
1692         my $type = $self-&gt;parseTypeWithExtendedAttributes();
1693         $attribute-&gt;type($type);
1694 
1695         my $token = $self-&gt;getToken();
1696         $self-&gt;assertTokenType($token, IdentifierToken);
1697         $attribute-&gt;name(identifierRemoveNullablePrefix($token-&gt;value()));
1698         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;;&quot;, __LINE__);
1699 
1700         return $attribute;
1701     }
1702     $self-&gt;assertUnexpectedToken($next-&gt;value(), __LINE__);
1703 }
1704 
1705 sub parseInherit
1706 {
1707     my $self = shift;
1708     my $next = $self-&gt;nextToken();
1709     if ($next-&gt;value() eq &quot;inherit&quot;) {
1710         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;inherit&quot;, __LINE__);
1711         return 1;
1712     }
1713     return 0;
1714 }
1715 
1716 sub parseReadOnly
1717 {
1718     my $self = shift;
1719     my $next = $self-&gt;nextToken();
1720     if ($next-&gt;value() eq &quot;readonly&quot;) {
1721         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;readonly&quot;, __LINE__);
1722         return 1;
1723     }
1724     return 0;
1725 }
1726 
1727 sub parseOperation
1728 {
1729     my $self = shift;
1730     my $extendedAttributeList = shift;
1731 
1732     my $next = $self-&gt;nextToken();
1733     if ($next-&gt;value() =~ /$nextSpecials_1/) {
1734         return $self-&gt;parseSpecialOperation($extendedAttributeList);
1735     }
1736     if ($next-&gt;type() == IdentifierToken || $next-&gt;value() =~ /$nextOperationRest_1/) {
1737         my $returnType = $self-&gt;parseReturnType();
1738 
1739         # NOTE: This is a non-standard addition. In WebIDL, there is no way to associate
1740         # extended attributes with a return type.
1741         $self-&gt;moveExtendedAttributesApplicableToTypes($returnType, $extendedAttributeList);
1742 
1743         my $operation = $self-&gt;parseOperationRest($extendedAttributeList);
1744         $operation-&gt;type($returnType);
1745 
1746         return $operation;
1747     }
1748     $self-&gt;assertUnexpectedToken($next-&gt;value(), __LINE__);
1749 }
1750 
1751 sub parseSpecialOperation
1752 {
1753     my $self = shift;
1754     my $extendedAttributeList = shift;
1755 
1756     my $next = $self-&gt;nextToken();
1757     if ($next-&gt;value() =~ /$nextSpecials_1/) {
1758         my @specials = ();
1759         push(@specials, @{$self-&gt;parseSpecials()});
1760         my $returnType = $self-&gt;parseReturnType();
1761 
1762         # NOTE: This is a non-standard addition. In WebIDL, there is no way to associate
1763         # extended attributes with a return type.
1764         $self-&gt;moveExtendedAttributesApplicableToTypes($returnType, $extendedAttributeList);
1765 
1766         my $operation = $self-&gt;parseOperationRest($extendedAttributeList);
1767         $operation-&gt;type($returnType);
1768         $operation-&gt;specials(\@specials);
1769 
1770         return $operation;
1771     }
1772     $self-&gt;assertUnexpectedToken($next-&gt;value(), __LINE__);
1773 }
1774 
1775 sub parseSpecials
1776 {
1777     my $self = shift;
1778     my @specials = ();
1779 
1780     while (1) {
1781         my $next = $self-&gt;nextToken();
1782         if ($next-&gt;value() =~ /$nextSpecials_1/) {
1783             push(@specials, $self-&gt;parseSpecial());
1784         } else {
1785             last;
1786         }
1787     }
1788     return \@specials;
1789 }
1790 
1791 sub parseSpecial
1792 {
1793     my $self = shift;
1794     my $next = $self-&gt;nextToken();
1795     if ($next-&gt;value() eq &quot;getter&quot;) {
1796         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;getter&quot;, __LINE__);
1797         return &quot;getter&quot;;
1798     }
1799     if ($next-&gt;value() eq &quot;setter&quot;) {
1800         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;setter&quot;, __LINE__);
1801         return &quot;setter&quot;;
1802     }
1803     if ($next-&gt;value() eq &quot;deleter&quot;) {
1804         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;deleter&quot;, __LINE__);
1805         return &quot;deleter&quot;;
1806     }
1807     if ($next-&gt;value() eq &quot;legacycaller&quot;) {
1808         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;legacycaller&quot;, __LINE__);
1809         return &quot;legacycaller&quot;;
1810     }
1811     $self-&gt;assertUnexpectedToken($next-&gt;value(), __LINE__);
1812 }
1813 
1814 sub parseIterableRest
1815 {
1816     my $self = shift;
1817     my $extendedAttributeList = shift;
1818 
1819     my $next = $self-&gt;nextToken();
1820     if ($next-&gt;value() eq &quot;iterable&quot;) {
1821         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;iterable&quot;, __LINE__);
1822         my $iterableNode = $self-&gt;parseOptionalIterableInterface($extendedAttributeList);
1823         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;;&quot;, __LINE__);
1824         return $iterableNode;
1825     }
1826     $self-&gt;assertUnexpectedToken($next-&gt;value(), __LINE__);
1827 }
1828 
1829 sub parseOptionalIterableInterface
1830 {
1831     my $self = shift;
1832     my $extendedAttributeList = shift;
1833 
1834     my $newDataNode = IDLIterable-&gt;new();
1835 
1836     $self-&gt;assertExtendedAttributesValidForContext($extendedAttributeList, &quot;iterable&quot;);
1837     $newDataNode-&gt;extendedAttributes($extendedAttributeList);
1838 
1839     $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;&lt;&quot;, __LINE__);
1840     my $type1 = $self-&gt;parseTypeWithExtendedAttributes();
1841 
1842     if ($self-&gt;nextToken()-&gt;value() eq &quot;,&quot;) {
1843         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;,&quot;, __LINE__);
1844 
1845         my $type2 = $self-&gt;parseTypeWithExtendedAttributes();
1846         $newDataNode-&gt;isKeyValue(1);
1847         $newDataNode-&gt;keyType($type1);
1848         $newDataNode-&gt;valueType($type2);
1849     } else {
1850         $newDataNode-&gt;isKeyValue(0);
1851         $newDataNode-&gt;valueType($type1);
1852     }
1853     $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;&gt;&quot;, __LINE__);
1854 
1855     my $symbolIteratorOperation = IDLOperation-&gt;new();
1856     $symbolIteratorOperation-&gt;name(&quot;[Symbol.Iterator]&quot;);
1857     $symbolIteratorOperation-&gt;extendedAttributes($extendedAttributeList);
1858     $symbolIteratorOperation-&gt;isIterable(1);
1859 
1860     my $entriesOperation = IDLOperation-&gt;new();
1861     $entriesOperation-&gt;name(&quot;entries&quot;);
1862     $entriesOperation-&gt;extendedAttributes($extendedAttributeList);
1863     $entriesOperation-&gt;isIterable(1);
1864 
1865     my $keysOperation = IDLOperation-&gt;new();
1866     $keysOperation-&gt;name(&quot;keys&quot;);
1867     $keysOperation-&gt;extendedAttributes($extendedAttributeList);
1868     $keysOperation-&gt;isIterable(1);
1869 
1870     my $valuesOperation = IDLOperation-&gt;new();
1871     $valuesOperation-&gt;name(&quot;values&quot;);
1872     $valuesOperation-&gt;extendedAttributes($extendedAttributeList);
1873     $valuesOperation-&gt;isIterable(1);
1874 
1875     my $forEachOperation = IDLOperation-&gt;new();
1876     $forEachOperation-&gt;name(&quot;forEach&quot;);
1877     $forEachOperation-&gt;extendedAttributes($extendedAttributeList);
1878     $forEachOperation-&gt;isIterable(1);
1879     my $forEachArgument = IDLArgument-&gt;new();
1880     $forEachArgument-&gt;name(&quot;callback&quot;);
1881     $forEachArgument-&gt;type(makeSimpleType(&quot;any&quot;));
1882     push(@{$forEachOperation-&gt;arguments}, ($forEachArgument));
1883 
1884     push(@{$newDataNode-&gt;operations}, $symbolIteratorOperation);
1885     push(@{$newDataNode-&gt;operations}, $entriesOperation);
1886     push(@{$newDataNode-&gt;operations}, $keysOperation);
1887     push(@{$newDataNode-&gt;operations}, $valuesOperation);
1888     push(@{$newDataNode-&gt;operations}, $forEachOperation);
1889 
1890     return $newDataNode;
1891 }
1892 
1893 sub parseMapLikeRest
1894 {
1895     my $self = shift;
1896     my $extendedAttributeList = shift;
1897     my $isReadOnly = shift;
1898 
1899     my $next = $self-&gt;nextToken();
1900     if ($next-&gt;value() eq &quot;maplike&quot;) {
1901         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;maplike&quot;, __LINE__);
1902         my $mapLikeNode = $self-&gt;parseMapLikeProperties($extendedAttributeList, $isReadOnly);
1903         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;;&quot;, __LINE__);
1904         return $mapLikeNode;
1905     }
1906     $self-&gt;assertUnexpectedToken($next-&gt;value(), __LINE__);
1907 }
1908 
1909 sub parseMapLikeProperties
1910 {
1911     my $self = shift;
1912     my $extendedAttributeList = shift;
1913     my $isReadOnly = shift;
1914 
1915     my $maplike = IDLMapLike-&gt;new();
1916     $maplike-&gt;extendedAttributes($extendedAttributeList);
1917     $maplike-&gt;isReadOnly($isReadOnly);
1918 
1919     $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;&lt;&quot;, __LINE__);
1920     $maplike-&gt;keyType($self-&gt;parseTypeWithExtendedAttributes());
1921     $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;,&quot;, __LINE__);
1922     $maplike-&gt;valueType($self-&gt;parseTypeWithExtendedAttributes());
1923     $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;&gt;&quot;, __LINE__);
1924 
1925     # FIXME: Synthetic operations should not be added during parsing. Instead, the CodeGenerator
1926     # should be responsible for them.
1927 
1928     my $notEnumerableExtendedAttributeList = $extendedAttributeList;
1929     $notEnumerableExtendedAttributeList-&gt;{NotEnumerable} = 1;
1930 
1931     my $sizeAttribute = IDLAttribute-&gt;new();
1932     $sizeAttribute-&gt;name(&quot;size&quot;);
1933     $sizeAttribute-&gt;isMapLike(1);
1934     $sizeAttribute-&gt;extendedAttributes($extendedAttributeList);
1935     $sizeAttribute-&gt;isReadOnly(1);
1936     $sizeAttribute-&gt;type(makeSimpleType(&quot;any&quot;));
1937     push(@{$maplike-&gt;attributes}, $sizeAttribute);
1938 
1939     my $getOperation = IDLOperation-&gt;new();
1940     $getOperation-&gt;name(&quot;get&quot;);
1941     $getOperation-&gt;isMapLike(1);
1942     my $getArgument = IDLArgument-&gt;new();
1943     $getArgument-&gt;name(&quot;key&quot;);
1944     $getArgument-&gt;type($maplike-&gt;keyType);
1945     $getArgument-&gt;extendedAttributes($extendedAttributeList);
1946     push(@{$getOperation-&gt;arguments}, ($getArgument));
1947     $getOperation-&gt;extendedAttributes($notEnumerableExtendedAttributeList);
1948     $getOperation-&gt;type(makeSimpleType(&quot;any&quot;));
1949 
1950     my $hasOperation = IDLOperation-&gt;new();
1951     $hasOperation-&gt;name(&quot;has&quot;);
1952     $hasOperation-&gt;isMapLike(1);
1953     my $hasArgument = IDLArgument-&gt;new();
1954     $hasArgument-&gt;name(&quot;key&quot;);
1955     $hasArgument-&gt;type($maplike-&gt;keyType);
1956     $hasArgument-&gt;extendedAttributes($extendedAttributeList);
1957     push(@{$hasOperation-&gt;arguments}, ($hasArgument));
1958     $hasOperation-&gt;extendedAttributes($notEnumerableExtendedAttributeList);
1959     $hasOperation-&gt;type(makeSimpleType(&quot;any&quot;));
1960 
1961     my $entriesOperation = IDLOperation-&gt;new();
1962     $entriesOperation-&gt;name(&quot;entries&quot;);
1963     $entriesOperation-&gt;isMapLike(1);
1964     $entriesOperation-&gt;extendedAttributes($notEnumerableExtendedAttributeList);
1965     $entriesOperation-&gt;type(makeSimpleType(&quot;any&quot;));
1966 
1967     my $keysOperation = IDLOperation-&gt;new();
1968     $keysOperation-&gt;name(&quot;keys&quot;);
1969     $keysOperation-&gt;isMapLike(1);
1970     $keysOperation-&gt;extendedAttributes($notEnumerableExtendedAttributeList);
1971     $keysOperation-&gt;type(makeSimpleType(&quot;any&quot;));
1972 
1973     my $valuesOperation = IDLOperation-&gt;new();
1974     $valuesOperation-&gt;name(&quot;values&quot;);
1975     $valuesOperation-&gt;isMapLike(1);
1976     $valuesOperation-&gt;extendedAttributes($extendedAttributeList);
1977     $valuesOperation-&gt;extendedAttributes-&gt;{NotEnumerable} = 1;
1978     $valuesOperation-&gt;type(makeSimpleType(&quot;any&quot;));
1979 
1980     my $forEachOperation = IDLOperation-&gt;new();
1981     $forEachOperation-&gt;name(&quot;forEach&quot;);
1982     $forEachOperation-&gt;isMapLike(1);
1983     $forEachOperation-&gt;extendedAttributes({});
1984     $forEachOperation-&gt;type(makeSimpleType(&quot;any&quot;));
1985     my $forEachArgument = IDLArgument-&gt;new();
1986     $forEachArgument-&gt;name(&quot;callback&quot;);
1987     $forEachArgument-&gt;type(makeSimpleType(&quot;any&quot;));
1988     $forEachArgument-&gt;extendedAttributes($extendedAttributeList);
1989     push(@{$forEachOperation-&gt;arguments}, ($forEachArgument));
1990 
1991     push(@{$maplike-&gt;operations}, $getOperation);
1992     push(@{$maplike-&gt;operations}, $hasOperation);
1993     push(@{$maplike-&gt;operations}, $entriesOperation);
1994     push(@{$maplike-&gt;operations}, $keysOperation);
1995     push(@{$maplike-&gt;operations}, $valuesOperation);
1996     push(@{$maplike-&gt;operations}, $forEachOperation);
1997 
1998     return $maplike if $isReadOnly;
1999 
2000     my $addOperation = IDLOperation-&gt;new();
2001     $addOperation-&gt;name(&quot;add&quot;);
2002     $addOperation-&gt;isMapLike(1);
2003     my $addArgument = IDLArgument-&gt;new();
2004     $addArgument-&gt;name(&quot;key&quot;);
2005     $addArgument-&gt;type($maplike-&gt;keyType);
2006     $addArgument-&gt;extendedAttributes($extendedAttributeList);
2007     push(@{$addOperation-&gt;arguments}, ($addArgument));
2008     $addOperation-&gt;extendedAttributes($notEnumerableExtendedAttributeList);
2009     $addOperation-&gt;type(makeSimpleType(&quot;any&quot;));
2010 
2011     my $clearOperation = IDLOperation-&gt;new();
2012     $clearOperation-&gt;name(&quot;clear&quot;);
2013     $clearOperation-&gt;isMapLike(1);
2014     $clearOperation-&gt;extendedAttributes($notEnumerableExtendedAttributeList);
2015     $clearOperation-&gt;type(makeSimpleType(&quot;void&quot;));
2016 
2017     my $deleteOperation = IDLOperation-&gt;new();
2018     $deleteOperation-&gt;name(&quot;delete&quot;);
2019     $deleteOperation-&gt;isMapLike(1);
2020     my $deleteArgument = IDLArgument-&gt;new();
2021     $deleteArgument-&gt;name(&quot;key&quot;);
2022     $deleteArgument-&gt;type($maplike-&gt;keyType);
2023     $deleteArgument-&gt;extendedAttributes($extendedAttributeList);
2024     push(@{$deleteOperation-&gt;arguments}, ($deleteArgument));
2025     $deleteOperation-&gt;extendedAttributes($notEnumerableExtendedAttributeList);
2026     $deleteOperation-&gt;type(makeSimpleType(&quot;any&quot;));
2027 
2028     push(@{$maplike-&gt;operations}, $addOperation);
2029     push(@{$maplike-&gt;operations}, $clearOperation);
2030     push(@{$maplike-&gt;operations}, $deleteOperation);
2031 
2032     return $maplike;
2033 }
2034 
2035 sub parseOperationRest
2036 {
2037     my $self = shift;
2038     my $extendedAttributeList = shift;
2039 
2040     my $next = $self-&gt;nextToken();
2041     if ($next-&gt;type() == IdentifierToken || $next-&gt;value() eq &quot;(&quot;) {
2042         my $operation = IDLOperation-&gt;new();
2043 
2044         my $name = $self-&gt;parseOptionalIdentifier();
2045         $operation-&gt;name(identifierRemoveNullablePrefix($name));
2046 
2047         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;(&quot;, $name, __LINE__);
2048 
2049         push(@{$operation-&gt;arguments}, @{$self-&gt;parseArgumentList()});
2050 
2051         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;)&quot;, __LINE__);
2052         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;;&quot;, __LINE__);
2053 
2054         $self-&gt;assertExtendedAttributesValidForContext($extendedAttributeList, &quot;operation&quot;);
2055         $operation-&gt;extendedAttributes($extendedAttributeList);
2056 
2057         return $operation;
2058     }
2059     $self-&gt;assertUnexpectedToken($next-&gt;value(), __LINE__);
2060 }
2061 
2062 sub parseOptionalIdentifier
2063 {
2064     my $self = shift;
2065     my $next = $self-&gt;nextToken();
2066     if ($next-&gt;type() == IdentifierToken) {
2067         my $token = $self-&gt;getToken();
2068         return $token-&gt;value();
2069     }
2070     return &quot;&quot;;
2071 }
2072 
2073 sub parseArgumentList
2074 {
2075     my $self = shift;
2076     my @arguments = ();
2077 
2078     my $next = $self-&gt;nextToken();
2079     if ($next-&gt;type() == IdentifierToken || $next-&gt;value() =~ /$nextArgumentList_1/) {
2080         push(@arguments, $self-&gt;parseArgument());
2081         push(@arguments, @{$self-&gt;parseArguments()});
2082     }
2083     return \@arguments;
2084 }
2085 
2086 sub parseArguments
2087 {
2088     my $self = shift;
2089     my @arguments = ();
2090 
2091     while (1) {
2092         my $next = $self-&gt;nextToken();
2093         if ($next-&gt;value() eq &quot;,&quot;) {
2094             $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;,&quot;, __LINE__);
2095             push(@arguments, $self-&gt;parseArgument());
2096         } else {
2097             last;
2098         }
2099     }
2100     return \@arguments;
2101 }
2102 
2103 sub parseArgument
2104 {
2105     my $self = shift;
2106     my $next = $self-&gt;nextToken();
2107     if ($next-&gt;type() == IdentifierToken || $next-&gt;value() =~ /$nextArgumentList_1/) {
2108         my $extendedAttributeList = $self-&gt;parseExtendedAttributeListAllowEmpty();
2109         my $argument = $self-&gt;parseOptionalOrRequiredArgument($extendedAttributeList);
2110         return $argument;
2111     }
2112     $self-&gt;assertUnexpectedToken($next-&gt;value(), __LINE__);
2113 }
2114 
2115 sub parseOptionalOrRequiredArgument
2116 {
2117     my $self = shift;
2118     my $extendedAttributeList = shift;
2119 
2120     my $argument = IDLArgument-&gt;new();
2121 
2122     my $next = $self-&gt;nextToken();
2123     if ($next-&gt;value() eq &quot;optional&quot;) {
2124         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;optional&quot;, __LINE__);
2125 
2126         my $type = $self-&gt;parseTypeWithExtendedAttributes();
2127         $argument-&gt;type($type);
2128         $argument-&gt;isOptional(1);
2129         $argument-&gt;name($self-&gt;parseArgumentName());
2130         $argument-&gt;default($self-&gt;parseDefault());
2131 
2132         $self-&gt;assertExtendedAttributesValidForContext($extendedAttributeList, &quot;argument&quot;);
2133         $argument-&gt;extendedAttributes($extendedAttributeList);
2134 
2135         return $argument;
2136     }
2137     if ($next-&gt;type() == IdentifierToken || $next-&gt;value() =~ /$nextExceptionField_1/) {
2138         my $type = $self-&gt;parseType();
2139         $self-&gt;moveExtendedAttributesApplicableToTypes($type, $extendedAttributeList);
2140 
2141         $argument-&gt;type($type);
2142         $argument-&gt;isOptional(0);
2143         $argument-&gt;isVariadic($self-&gt;parseEllipsis());
2144         $argument-&gt;name($self-&gt;parseArgumentName());
2145 
2146         $self-&gt;assertExtendedAttributesValidForContext($extendedAttributeList, &quot;argument&quot;);
2147         $argument-&gt;extendedAttributes($extendedAttributeList);
2148 
2149         return $argument;
2150     }
2151     $self-&gt;assertUnexpectedToken($next-&gt;value(), __LINE__);
2152 }
2153 
2154 sub parseArgumentName
2155 {
2156     my $self = shift;
2157     my $next = $self-&gt;nextToken();
2158     if ($next-&gt;value() =~ /$nextArgumentName_1/) {
2159         return $self-&gt;parseArgumentNameKeyword();
2160     }
2161     if ($next-&gt;type() == IdentifierToken) {
2162         return $self-&gt;getToken()-&gt;value();
2163     }
2164     $self-&gt;assertUnexpectedToken($next-&gt;value(), __LINE__);
2165 }
2166 
2167 sub parseEllipsis
2168 {
2169     my $self = shift;
2170     my $next = $self-&gt;nextToken();
2171     if ($next-&gt;value() eq &quot;...&quot;) {
2172         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;...&quot;, __LINE__);
2173         return 1;
2174     }
2175     return 0;
2176 }
2177 
2178 sub parseExceptionMember
2179 {
2180     my $self = shift;
2181     my $extendedAttributeList = shift;
2182 
2183     my $next = $self-&gt;nextToken();
2184     if ($next-&gt;value() eq &quot;const&quot;) {
2185         return $self-&gt;parseConst($extendedAttributeList);
2186     }
2187     if ($next-&gt;type() == IdentifierToken || $next-&gt;value() =~ /$nextExceptionField_1/) {
2188         return $self-&gt;parseExceptionField($extendedAttributeList);
2189     }
2190     $self-&gt;assertUnexpectedToken($next-&gt;value(), __LINE__);
2191 }
2192 
2193 sub parseExceptionField
2194 {
2195     my $self = shift;
2196     my $extendedAttributeList = shift;
2197 
2198     my $next = $self-&gt;nextToken();
2199     if ($next-&gt;type() == IdentifierToken || $next-&gt;value() =~ /$nextExceptionField_1/) {
2200         my $newDataNode = IDLAttribute-&gt;new();
2201         $newDataNode-&gt;isReadOnly(1);
2202 
2203         my $type = $self-&gt;parseType();
2204         $newDataNode-&gt;type($type);
2205         
2206         my $token = $self-&gt;getToken();
2207         $self-&gt;assertTokenType($token, IdentifierToken);
2208         $newDataNode-&gt;name(identifierRemoveNullablePrefix($token-&gt;value()));
2209         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;;&quot;, __LINE__);
2210         $newDataNode-&gt;extendedAttributes($extendedAttributeList);
2211         return $newDataNode;
2212     }
2213     $self-&gt;assertUnexpectedToken($next-&gt;value(), __LINE__);
2214 }
2215 
2216 sub parseExtendedAttributeListAllowEmpty
2217 {
2218     my $self = shift;
2219     my $next = $self-&gt;nextToken();
2220     if ($next-&gt;value() eq &quot;[&quot;) {
2221         return $self-&gt;parseExtendedAttributeList();
2222     }
2223     return {};
2224 }
2225 
2226 sub parseExtendedAttributeList
2227 {
2228     my $self = shift;
2229     my $next = $self-&gt;nextToken();
2230     if ($next-&gt;value() eq &quot;[&quot;) {
2231         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;[&quot;, __LINE__);
2232         my $extendedAttributeList = {};
2233         my $attr = $self-&gt;parseExtendedAttribute();
2234         copyExtendedAttributes($extendedAttributeList, $attr);
2235         $attr = $self-&gt;parseExtendedAttributes();
2236         copyExtendedAttributes($extendedAttributeList, $attr);
2237         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;]&quot;, __LINE__);
2238         return $extendedAttributeList;
2239     }
2240     $self-&gt;assertUnexpectedToken($next-&gt;value(), __LINE__);
2241 }
2242 
2243 sub parseExtendedAttributes
2244 {
2245     my $self = shift;
2246     my $extendedAttributeList = {};
2247 
2248     while (1) {
2249         my $next = $self-&gt;nextToken();
2250         if ($next-&gt;value() eq &quot;,&quot;) {
2251             $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;,&quot;, __LINE__);
2252             my $attr = $self-&gt;parseExtendedAttribute2();
2253             copyExtendedAttributes($extendedAttributeList, $attr);
2254         } else {
2255             last;
2256         }
2257     }
2258     return $extendedAttributeList;
2259 }
2260 
2261 sub parseExtendedAttribute
2262 {
2263     my $self = shift;
2264     my $next = $self-&gt;nextToken();
2265     if ($next-&gt;type() == IdentifierToken) {
2266         my $name = $self-&gt;parseName();
2267         return $self-&gt;parseExtendedAttributeRest($name);
2268     }
2269     # backward compatibility. Spec doesn&#39; allow &quot;[]&quot;. But WebKit requires.
2270     if ($next-&gt;value() eq &#39;]&#39;) {
2271         return {};
2272     }
2273     $self-&gt;assertUnexpectedToken($next-&gt;value(), __LINE__);
2274 }
2275 
2276 sub parseExtendedAttribute2
2277 {
2278     my $self = shift;
2279     my $next = $self-&gt;nextToken();
2280     if ($next-&gt;type() == IdentifierToken) {
2281         my $name = $self-&gt;parseName();
2282         return $self-&gt;parseExtendedAttributeRest($name);
2283     }
2284     return {};
2285 }
2286 
2287 sub parseExtendedAttributeRest
2288 {
2289     my $self = shift;
2290     my $name = shift;
2291     my $attrs = {};
2292 
2293     my $next = $self-&gt;nextToken();
2294     if ($next-&gt;value() eq &quot;(&quot;) {
2295         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;(&quot;, __LINE__);
2296         $attrs-&gt;{$name} = $self-&gt;parseArgumentList();
2297         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;)&quot;, __LINE__);
2298         return $attrs;
2299     }
2300     if ($next-&gt;value() eq &quot;=&quot;) {
2301         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;=&quot;, __LINE__);
2302         $attrs-&gt;{$name} = $self-&gt;parseExtendedAttributeRest2();
2303         return $attrs;
2304     }
2305 
2306     if ($name eq &quot;Constructor&quot; || $name eq &quot;CustomConstructor&quot;) {
2307         $attrs-&gt;{$name} = [];
2308     } else {
2309         $attrs-&gt;{$name} = &quot;VALUE_IS_MISSING&quot;;
2310     }
2311     return $attrs;
2312 }
2313 
2314 sub parseExtendedAttributeRest2
2315 {
2316     my $self = shift;
2317     my $next = $self-&gt;nextToken();
2318     if ($next-&gt;value() eq &quot;(&quot;) {
2319         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;(&quot;, __LINE__);
2320         my @arguments = $self-&gt;parseIdentifierList();
2321         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;)&quot;, __LINE__);
2322         return \@arguments;
2323     }
2324     if ($next-&gt;type() == IdentifierToken) {
2325         my $name = $self-&gt;parseName();
2326         return $self-&gt;parseExtendedAttributeRest3($name);
2327     }
2328     if ($next-&gt;type() == IntegerToken) {
2329         my $token = $self-&gt;getToken();
2330         return $token-&gt;value();
2331     }
2332     $self-&gt;assertUnexpectedToken($next-&gt;value(), __LINE__);
2333 }
2334 
2335 sub parseExtendedAttributeRest3
2336 {
2337     my $self = shift;
2338     my $name = shift;
2339 
2340     my $next = $self-&gt;nextToken();
2341     if ($next-&gt;value() eq &quot;&amp;&quot;) {
2342         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;&amp;&quot;, __LINE__);
2343         my $rightValue = $self-&gt;parseName();
2344         return $name . &quot;&amp;&quot; . $rightValue;
2345     }
2346     if ($next-&gt;value() eq &quot;|&quot;) {
2347         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;|&quot;, __LINE__);
2348         my $rightValue = $self-&gt;parseName();
2349         return $name . &quot;|&quot; . $rightValue;
2350     }
2351     if ($next-&gt;value() eq &quot;(&quot;) {
2352         my $attr = {};
2353         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;(&quot;, __LINE__);
2354         $attr-&gt;{$name} = $self-&gt;parseArgumentList();
2355         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;)&quot;, __LINE__);
2356         return $attr;
2357     }
2358     if ($next-&gt;type() == IdentifierToken || $next-&gt;value() =~ /$nextExtendedAttributeRest3_1/) {
2359         $self-&gt;parseNameNoComma();
2360         return $name;
2361     }
2362     $self-&gt;assertUnexpectedToken($next-&gt;value());
2363 }
2364 
2365 sub parseArgumentNameKeyword
2366 {
2367     my $self = shift;
2368     my $next = $self-&gt;nextToken();
2369     if ($next-&gt;value() eq &quot;attribute&quot;) {
2370         return $self-&gt;getToken()-&gt;value();
2371     }
2372     if ($next-&gt;value() eq &quot;callback&quot;) {
2373         return $self-&gt;getToken()-&gt;value();
2374     }
2375     if ($next-&gt;value() eq &quot;const&quot;) {
2376         return $self-&gt;getToken()-&gt;value();
2377     }
2378     if ($next-&gt;value() eq &quot;deleter&quot;) {
2379         return $self-&gt;getToken()-&gt;value();
2380     }
2381     if ($next-&gt;value() eq &quot;dictionary&quot;) {
2382         return $self-&gt;getToken()-&gt;value();
2383     }
2384     if ($next-&gt;value() eq &quot;enum&quot;) {
2385         return $self-&gt;getToken()-&gt;value();
2386     }
2387     if ($next-&gt;value() eq &quot;exception&quot;) {
2388         return $self-&gt;getToken()-&gt;value();
2389     }
2390     if ($next-&gt;value() eq &quot;getter&quot;) {
2391         return $self-&gt;getToken()-&gt;value();
2392     }
2393     if ($next-&gt;value() eq &quot;implements&quot;) {
2394         return $self-&gt;getToken()-&gt;value();
2395     }
2396     if ($next-&gt;value() eq &quot;inherit&quot;) {
2397         return $self-&gt;getToken()-&gt;value();
2398     }
2399     if ($next-&gt;value() eq &quot;interface&quot;) {
2400         return $self-&gt;getToken()-&gt;value();
2401     }
2402     if ($next-&gt;value() eq &quot;legacycaller&quot;) {
2403         return $self-&gt;getToken()-&gt;value();
2404     }
2405     if ($next-&gt;value() eq &quot;partial&quot;) {
2406         return $self-&gt;getToken()-&gt;value();
2407     }
2408     if ($next-&gt;value() eq &quot;serializer&quot;) {
2409         return $self-&gt;getToken()-&gt;value();
2410     }
2411     if ($next-&gt;value() eq &quot;setter&quot;) {
2412         return $self-&gt;getToken()-&gt;value();
2413     }
2414     if ($next-&gt;value() eq &quot;static&quot;) {
2415         return $self-&gt;getToken()-&gt;value();
2416     }
2417     if ($next-&gt;value() eq &quot;stringifier&quot;) {
2418         return $self-&gt;getToken()-&gt;value();
2419     }
2420     if ($next-&gt;value() eq &quot;typedef&quot;) {
2421         return $self-&gt;getToken()-&gt;value();
2422     }
2423     if ($next-&gt;value() eq &quot;unrestricted&quot;) {
2424         return $self-&gt;getToken()-&gt;value();
2425     }
2426     $self-&gt;assertUnexpectedToken($next-&gt;value(), __LINE__);
2427 }
2428 
2429 sub parseType
2430 {
2431     my $self = shift;
2432     my $next = $self-&gt;nextToken();
2433 
2434     my $extendedAttributeList = {};
2435 
2436     if ($next-&gt;value() eq &quot;(&quot;) {
2437         my $unionType = $self-&gt;parseUnionType();
2438         $unionType-&gt;isNullable($self-&gt;parseNull());
2439         $unionType-&gt;extendedAttributes($extendedAttributeList);
2440         return $unionType;
2441     }
2442     if ($next-&gt;type() == IdentifierToken || $next-&gt;value() =~ /$nextType_1/) {
2443         my $singleType = $self-&gt;parseSingleType();
2444         $singleType-&gt;extendedAttributes($extendedAttributeList);
2445         return $singleType;
2446     }
2447     $self-&gt;assertUnexpectedToken($next-&gt;value(), __LINE__);
2448 }
2449 
2450 sub parseTypeWithExtendedAttributes
2451 {
2452     my $self = shift;
2453     
2454     my $extendedAttributeList = $self-&gt;parseExtendedAttributeListAllowEmpty();
2455     $self-&gt;assertExtendedAttributesValidForContext($extendedAttributeList, &quot;type&quot;);
2456 
2457     my $next = $self-&gt;nextToken();
2458     if ($next-&gt;value() eq &quot;(&quot;) {
2459         my $unionType = $self-&gt;parseUnionType();
2460         $unionType-&gt;isNullable($self-&gt;parseNull());
2461         $unionType-&gt;extendedAttributes($extendedAttributeList);
2462         return $unionType;
2463     }
2464     if ($next-&gt;type() == IdentifierToken || $next-&gt;value() =~ /$nextType_1/) {
2465         my $singleType = $self-&gt;parseSingleType();
2466         $singleType-&gt;extendedAttributes($extendedAttributeList);
2467         return $singleType;
2468     }
2469     $self-&gt;assertUnexpectedToken($next-&gt;value(), __LINE__);
2470 }
2471 
2472 sub parseSingleType
2473 {
2474     my $self = shift;
2475     my $next = $self-&gt;nextToken();
2476     if ($next-&gt;value() eq &quot;any&quot;) {
2477         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;any&quot;, __LINE__);
2478         
2479         my $anyType = IDLType-&gt;new();
2480         $anyType-&gt;name(&quot;any&quot;);
2481         return $anyType;
2482     }
2483     if ($next-&gt;type() == IdentifierToken || $next-&gt;value() =~ /$nextSingleType_1/) {
2484         my $nonAnyType = $self-&gt;parseNonAnyType();
2485         $nonAnyType-&gt;isNullable($self-&gt;parseNull());
2486         return $nonAnyType;
2487     }
2488     $self-&gt;assertUnexpectedToken($next-&gt;value(), __LINE__);
2489 }
2490 
2491 sub parseUnionType
2492 {
2493     my $self = shift;
2494     my $next = $self-&gt;nextToken();
2495 
2496     my $unionType = IDLType-&gt;new();
2497     $unionType-&gt;name(&quot;UNION&quot;);
2498     $unionType-&gt;isUnion(1);
2499 
2500     if ($next-&gt;value() eq &quot;(&quot;) {
2501         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;(&quot;, __LINE__);
2502         
2503         push(@{$unionType-&gt;subtypes}, $self-&gt;parseUnionMemberType());
2504         push(@{$unionType-&gt;subtypes}, $self-&gt;parseUnionMemberTypes());
2505         
2506         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;)&quot;, __LINE__);
2507 
2508         return $unionType;
2509     }
2510     $self-&gt;assertUnexpectedToken($next-&gt;value(), __LINE__);
2511 }
2512 
2513 sub parseUnionMemberType
2514 {
2515     my $self = shift;
2516 
2517     my $extendedAttributeList = $self-&gt;parseExtendedAttributeListAllowEmpty();
2518     $self-&gt;assertExtendedAttributesValidForContext($extendedAttributeList, &quot;type&quot;);
2519 
2520     my $next = $self-&gt;nextToken();
2521 
2522     if ($next-&gt;value() eq &quot;(&quot;) {
2523         my $unionType = $self-&gt;parseUnionType();
2524         $unionType-&gt;isNullable($self-&gt;parseNull());
2525         $unionType-&gt;extendedAttributes($extendedAttributeList);
2526         return $unionType;
2527     }
2528 
2529     if ($next-&gt;type() == IdentifierToken || $next-&gt;value() =~ /$nextSingleType_1/) {
2530         my $nonAnyType = $self-&gt;parseNonAnyType();
2531         $nonAnyType-&gt;isNullable($self-&gt;parseNull());
2532         $nonAnyType-&gt;extendedAttributes($extendedAttributeList);
2533         return $nonAnyType;
2534     }
2535     $self-&gt;assertUnexpectedToken($next-&gt;value(), __LINE__);
2536 }
2537 
2538 sub parseUnionMemberTypes
2539 {
2540     my $self = shift;
2541     my $next = $self-&gt;nextToken();
2542 
2543     my @subtypes = ();
2544 
2545     if ($next-&gt;value() eq &quot;or&quot;) {
2546         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;or&quot;, __LINE__);
2547         push(@subtypes, $self-&gt;parseUnionMemberType());
2548         push(@subtypes, $self-&gt;parseUnionMemberTypes());
2549     }
2550 
2551     return @subtypes;
2552 }
2553 
2554 sub parseNonAnyType
2555 {
2556     my $self = shift;
2557     my $next = $self-&gt;nextToken();
2558 
2559     my $type = IDLType-&gt;new();
2560 
2561     if ($next-&gt;value() =~ /$nextNonAnyType_1/) {
2562         $type-&gt;name($self-&gt;parsePrimitiveType());
2563         return $type;
2564     }
2565     if ($next-&gt;value() =~ /$nextStringType_1/) {
2566         $type-&gt;name($self-&gt;parseStringType());
2567         return $type;
2568     }
2569     if ($next-&gt;value() eq &quot;object&quot;) {
2570         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;object&quot;, __LINE__);
2571 
2572         $type-&gt;name(&quot;object&quot;);
2573         return $type;
2574     }
2575     if ($next-&gt;value() eq &quot;Error&quot;) {
2576         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;Error&quot;, __LINE__);
2577 
2578         $type-&gt;name(&quot;Error&quot;);
2579         return $type;
2580     }
2581     if ($next-&gt;value() eq &quot;DOMException&quot;) {
2582         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;DOMException&quot;, __LINE__);
2583 
2584         $type-&gt;name(&quot;DOMException&quot;);
2585         return $type;
2586     }
2587     if ($next-&gt;value() eq &quot;Date&quot;) {
2588         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;Date&quot;, __LINE__);
2589 
2590         $type-&gt;name(&quot;Date&quot;);
2591         return $type;
2592     }
2593     if ($next-&gt;value() eq &quot;sequence&quot;) {
2594         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;sequence&quot;, __LINE__);
2595         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;&lt;&quot;, __LINE__);
2596 
2597         my $subtype = $self-&gt;parseTypeWithExtendedAttributes();
2598 
2599         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;&gt;&quot;, __LINE__);
2600 
2601         $type-&gt;name(&quot;sequence&quot;);
2602         push(@{$type-&gt;subtypes}, $subtype);
2603 
2604         return $type;
2605     }
2606     if ($next-&gt;value() eq &quot;FrozenArray&quot;) {
2607         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;FrozenArray&quot;, __LINE__);
2608         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;&lt;&quot;, __LINE__);
2609 
2610         my $subtype = $self-&gt;parseTypeWithExtendedAttributes();
2611 
2612         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;&gt;&quot;, __LINE__);
2613 
2614         $type-&gt;name(&quot;FrozenArray&quot;);
2615         push(@{$type-&gt;subtypes}, $subtype);
2616 
2617         return $type;
2618     }
2619     if ($next-&gt;value() eq &quot;Promise&quot;) {
2620         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;Promise&quot;, __LINE__);
2621         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;&lt;&quot;, __LINE__);
2622 
2623         my $subtype = $self-&gt;parseReturnType();
2624 
2625         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;&gt;&quot;, __LINE__);
2626 
2627         $type-&gt;name(&quot;Promise&quot;);
2628         push(@{$type-&gt;subtypes}, $subtype);
2629 
2630         return $type;
2631     }
2632     if ($next-&gt;value() eq &quot;record&quot;) {
2633         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;record&quot;, __LINE__);
2634         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;&lt;&quot;, __LINE__);
2635 
2636         my $keyType = IDLType-&gt;new();
2637         $keyType-&gt;name($self-&gt;parseStringType());
2638 
2639         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;,&quot;, __LINE__);
2640 
2641         my $valueType = $self-&gt;parseTypeWithExtendedAttributes();
2642 
2643         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;&gt;&quot;, __LINE__);
2644 
2645         $type-&gt;name(&quot;record&quot;);
2646         push(@{$type-&gt;subtypes}, $keyType);
2647         push(@{$type-&gt;subtypes}, $valueType);
2648 
2649         return $type;
2650     }
2651     if ($next-&gt;type() == IdentifierToken) {
2652         my $identifier = $self-&gt;getToken();
2653 
2654         $type-&gt;name(identifierRemoveNullablePrefix($identifier-&gt;value()));
2655         return $type;
2656     }
2657     $self-&gt;assertUnexpectedToken($next-&gt;value(), __LINE__);
2658 }
2659 
2660 sub parseConstType
2661 {
2662     my $self = shift;
2663     my $next = $self-&gt;nextToken();
2664 
2665     my $type = IDLType-&gt;new();
2666 
2667     if ($next-&gt;value() =~ /$nextNonAnyType_1/) {
2668         $type-&gt;name($self-&gt;parsePrimitiveType());
2669         $type-&gt;isNullable($self-&gt;parseNull());
2670         return $type;
2671     }
2672     if ($next-&gt;type() == IdentifierToken) {
2673         my $identifier = $self-&gt;getToken();
2674         
2675         $type-&gt;name($identifier-&gt;value());
2676         $type-&gt;isNullable($self-&gt;parseNull());
2677 
2678         return $type;
2679     }
2680     $self-&gt;assertUnexpectedToken($next-&gt;value(), __LINE__);
2681 }
2682 
2683 sub parseStringType
2684 {
2685     my $self = shift;
2686     my $next = $self-&gt;nextToken();
2687     if ($next-&gt;value() eq &quot;ByteString&quot;) {
2688         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;ByteString&quot;, __LINE__);
2689         return &quot;ByteString&quot;;
2690     }
2691     if ($next-&gt;value() eq &quot;DOMString&quot;) {
2692         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;DOMString&quot;, __LINE__);
2693         return &quot;DOMString&quot;;
2694     }
2695     if ($next-&gt;value() eq &quot;USVString&quot;) {
2696         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;USVString&quot;, __LINE__);
2697         return &quot;USVString&quot;;
2698     }
2699     $self-&gt;assertUnexpectedToken($next-&gt;value(), __LINE__);
2700 }
2701 
2702 sub parsePrimitiveType
2703 {
2704     my $self = shift;
2705     my $next = $self-&gt;nextToken();
2706     if ($next-&gt;value() =~ /$nextPrimitiveType_1/) {
2707         return $self-&gt;parseUnsignedIntegerType();
2708     }
2709     if ($next-&gt;value() =~ /$nextPrimitiveType_2/) {
2710         return $self-&gt;parseUnrestrictedFloatType();
2711     }
2712     if ($next-&gt;value() eq &quot;boolean&quot;) {
2713         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;boolean&quot;, __LINE__);
2714         return &quot;boolean&quot;;
2715     }
2716     if ($next-&gt;value() eq &quot;byte&quot;) {
2717         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;byte&quot;, __LINE__);
2718         return &quot;byte&quot;;
2719     }
2720     if ($next-&gt;value() eq &quot;octet&quot;) {
2721         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;octet&quot;, __LINE__);
2722         return &quot;octet&quot;;
2723     }
2724     $self-&gt;assertUnexpectedToken($next-&gt;value(), __LINE__);
2725 }
2726 
2727 sub parseUnrestrictedFloatType
2728 {
2729     my $self = shift;
2730     my $next = $self-&gt;nextToken();
2731     if ($next-&gt;value() eq &quot;unrestricted&quot;) {
2732         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;unrestricted&quot;, __LINE__);
2733         return &quot;unrestricted &quot; . $self-&gt;parseFloatType();
2734     }
2735     if ($next-&gt;value() =~ /$nextUnrestrictedFloatType_1/) {
2736         return $self-&gt;parseFloatType();
2737     }
2738     $self-&gt;assertUnexpectedToken($next-&gt;value(), __LINE__);
2739 }
2740 
2741 sub parseFloatType
2742 {
2743     my $self = shift;
2744     my $next = $self-&gt;nextToken();
2745     if ($next-&gt;value() eq &quot;float&quot;) {
2746         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;float&quot;, __LINE__);
2747         return &quot;float&quot;;
2748     }
2749     if ($next-&gt;value() eq &quot;double&quot;) {
2750         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;double&quot;, __LINE__);
2751         return &quot;double&quot;;
2752     }
2753     $self-&gt;assertUnexpectedToken($next-&gt;value(), __LINE__);
2754 }
2755 
2756 sub parseUnsignedIntegerType
2757 {
2758     my $self = shift;
2759     my $next = $self-&gt;nextToken();
2760     if ($next-&gt;value() eq &quot;unsigned&quot;) {
2761         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;unsigned&quot;, __LINE__);
2762         return &quot;unsigned &quot; . $self-&gt;parseIntegerType();
2763     }
2764     if ($next-&gt;value() =~ /$nextUnsignedIntegerType_1/) {
2765         return $self-&gt;parseIntegerType();
2766     }
2767     $self-&gt;assertUnexpectedToken($next-&gt;value(), __LINE__);
2768 }
2769 
2770 sub parseIntegerType
2771 {
2772     my $self = shift;
2773     my $next = $self-&gt;nextToken();
2774     if ($next-&gt;value() eq &quot;short&quot;) {
2775         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;short&quot;, __LINE__);
2776         return &quot;short&quot;;
2777     }
2778     if ($next-&gt;value() eq &quot;int&quot;) {
2779         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;int&quot;, __LINE__);
2780         return &quot;int&quot;;
2781     }
2782     if ($next-&gt;value() eq &quot;long&quot;) {
2783         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;long&quot;, __LINE__);
2784         if ($self-&gt;parseOptionalLong()) {
2785             return &quot;long long&quot;;
2786         }
2787         return &quot;long&quot;;
2788     }
2789     $self-&gt;assertUnexpectedToken($next-&gt;value(), __LINE__);
2790 }
2791 
2792 sub parseOptionalLong
2793 {
2794     my $self = shift;
2795     my $next = $self-&gt;nextToken();
2796     if ($next-&gt;value() eq &quot;long&quot;) {
2797         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;long&quot;, __LINE__);
2798         return 1;
2799     }
2800     return 0;
2801 }
2802 
2803 sub parseNull
2804 {
2805     my $self = shift;
2806     my $next = $self-&gt;nextToken();
2807     if ($next-&gt;value() eq &quot;?&quot;) {
2808         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;?&quot;, __LINE__);
2809         return 1;
2810     }
2811     return 0;
2812 }
2813 
2814 sub parseReturnType
2815 {
2816     my $self = shift;
2817     my $next = $self-&gt;nextToken();
2818     if ($next-&gt;value() eq &quot;void&quot;) {
2819         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;void&quot;, __LINE__);
2820         
2821         my $voidType = IDLType-&gt;new();
2822         $voidType-&gt;name(&quot;void&quot;);
2823         return $voidType;
2824     }
2825     if ($next-&gt;type() == IdentifierToken || $next-&gt;value() =~ /$nextExceptionField_1/) {
2826         return $self-&gt;parseType();
2827     }
2828     $self-&gt;assertUnexpectedToken($next-&gt;value(), __LINE__);
2829 }
2830 
2831 sub parseOptionalSemicolon
2832 {
2833     my $self = shift;
2834     my $next = $self-&gt;nextToken();
2835     if ($next-&gt;value() eq &quot;;&quot;) {
2836         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;;&quot;, __LINE__);
2837     }
2838 }
2839 
2840 sub parseNameNoComma
2841 {
2842     my $self = shift;
2843     my $next = $self-&gt;nextToken();
2844     if ($next-&gt;type() == IdentifierToken) {
2845         my $identifier = $self-&gt;getToken();
2846         return ($identifier-&gt;value());
2847     }
2848 
2849     return ();
2850 }
2851 
2852 sub parseName
2853 {
2854     my $self = shift;
2855     my $next = $self-&gt;nextToken();
2856     if ($next-&gt;type() == IdentifierToken) {
2857         my $identifier = $self-&gt;getToken();
2858         return $identifier-&gt;value();
2859     }
2860     $self-&gt;assertUnexpectedToken($next-&gt;value());
2861 }
2862 
2863 sub applyMemberList
2864 {
2865     my $interface = shift;
2866     my $members = shift;
2867 
2868     for my $item (@{$members}) {
2869         if (ref($item) eq &quot;IDLAttribute&quot;) {
2870             push(@{$interface-&gt;attributes}, $item);
2871             next;
2872         }
2873         if (ref($item) eq &quot;IDLConstant&quot;) {
2874             push(@{$interface-&gt;constants}, $item);
2875             next;
2876         }
2877         if (ref($item) eq &quot;IDLIterable&quot;) {
2878             $interface-&gt;iterable($item);
2879             next;
2880         }
2881         if (ref($item) eq &quot;IDLMapLike&quot;) {
2882             $interface-&gt;mapLike($item);
2883             next;
2884         }
2885         if (ref($item) eq &quot;IDLOperation&quot;) {
2886             if ($item-&gt;name eq &quot;&quot;) {
2887                 push(@{$interface-&gt;anonymousOperations}, $item);
2888             } else {
2889                 push(@{$interface-&gt;operations}, $item);
2890             }
2891             next;
2892         }
2893         if (ref($item) eq &quot;IDLSerializable&quot;) {
2894             $interface-&gt;serializable($item);
2895             next;
2896         }
2897     }
2898 
2899     if ($interface-&gt;serializable) {
2900         my $numSerializerAttributes = @{$interface-&gt;serializable-&gt;attributes};
2901         if ($interface-&gt;serializable-&gt;hasAttribute) {
2902             foreach my $attribute (@{$interface-&gt;attributes}) {
2903                 push(@{$interface-&gt;serializable-&gt;attributes}, $attribute-&gt;name);
2904             }
2905         } elsif ($numSerializerAttributes == 0) {
2906             foreach my $attribute (@{$interface-&gt;attributes}) {
2907                 push(@{$interface-&gt;serializable-&gt;attributes}, $attribute-&gt;name);
2908             }
2909         }
2910     }
2911 }
2912 
2913 sub applyExtendedAttributeList
2914 {
2915     my $interface = shift;
2916     my $extendedAttributeList = shift;
2917 
2918     if (defined $extendedAttributeList-&gt;{&quot;Constructors&quot;}) {
2919         my @constructorParams = @{$extendedAttributeList-&gt;{&quot;Constructors&quot;}};
2920         my $index = (@constructorParams == 1) ? 0 : 1;
2921         foreach my $param (@constructorParams) {
2922             my $constructor = IDLOperation-&gt;new();
2923             $constructor-&gt;name(&quot;Constructor&quot;);
2924             $constructor-&gt;extendedAttributes($extendedAttributeList);
2925             $constructor-&gt;arguments($param);
2926             push(@{$interface-&gt;constructors}, $constructor);
2927         }
2928         delete $extendedAttributeList-&gt;{&quot;Constructors&quot;};
2929         $extendedAttributeList-&gt;{&quot;Constructor&quot;} = &quot;VALUE_IS_MISSING&quot;;
2930     } elsif (defined $extendedAttributeList-&gt;{&quot;NamedConstructor&quot;}) {
2931         my $newDataNode = IDLOperation-&gt;new();
2932         $newDataNode-&gt;name(&quot;NamedConstructor&quot;);
2933         $newDataNode-&gt;extendedAttributes($extendedAttributeList);
2934         my %attributes = %{$extendedAttributeList-&gt;{&quot;NamedConstructor&quot;}};
2935         my @attributeKeys = keys (%attributes);
2936         my $constructorName = $attributeKeys[0];
2937         push(@{$newDataNode-&gt;arguments}, @{$attributes{$constructorName}});
2938         $extendedAttributeList-&gt;{&quot;NamedConstructor&quot;} = $constructorName;
2939         push(@{$interface-&gt;constructors}, $newDataNode);
2940     }
2941     if (defined $extendedAttributeList-&gt;{&quot;CustomConstructors&quot;}) {
2942         my @customConstructorParams = @{$extendedAttributeList-&gt;{&quot;CustomConstructors&quot;}};
2943         my $index = (@customConstructorParams == 1) ? 0 : 1;
2944         foreach my $param (@customConstructorParams) {
2945             my $customConstructor = IDLOperation-&gt;new();
2946             $customConstructor-&gt;name(&quot;CustomConstructor&quot;);
2947             $customConstructor-&gt;extendedAttributes($extendedAttributeList);
2948             $customConstructor-&gt;arguments($param);
2949             push(@{$interface-&gt;customConstructors}, $customConstructor);
2950         }
2951         delete $extendedAttributeList-&gt;{&quot;CustomConstructors&quot;};
2952         $extendedAttributeList-&gt;{&quot;CustomConstructor&quot;} = &quot;VALUE_IS_MISSING&quot;;
2953     }
2954     
2955     $interface-&gt;extendedAttributes($extendedAttributeList);
2956 }
2957 
2958 1;
2959 
<a name="4" id="anc4"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="4" type="hidden" />
</body>
</html>