<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGSpeculativeJIT32_64.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (C) 2011-2019 Apple Inc. All rights reserved.</span>
   3  * Copyright (C) 2011 Intel Corporation. All rights reserved.
   4  *
   5  * Redistribution and use in source and binary forms, with or without
   6  * modification, are permitted provided that the following conditions
   7  * are met:
   8  * 1. Redistributions of source code must retain the above copyright
   9  *    notice, this list of conditions and the following disclaimer.
  10  * 2. Redistributions in binary form must reproduce the above copyright
  11  *    notice, this list of conditions and the following disclaimer in the
  12  *    documentation and/or other materials provided with the distribution.
  13  *
  14  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  15  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  16  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  17  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  18  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  19  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  20  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  21  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  22  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  23  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  24  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  25  */
  26 
  27 #include &quot;config.h&quot;
  28 #include &quot;DFGSpeculativeJIT.h&quot;
  29 
  30 #if ENABLE(DFG_JIT)
  31 
  32 #include &quot;ArrayPrototype.h&quot;
  33 #include &quot;CallFrameShuffler.h&quot;
  34 #include &quot;DFGAbstractInterpreterInlines.h&quot;
  35 #include &quot;DFGCallArrayAllocatorSlowPathGenerator.h&quot;
  36 #include &quot;DFGOperations.h&quot;
  37 #include &quot;DFGSlowPathGenerator.h&quot;
  38 #include &quot;DirectArguments.h&quot;
  39 #include &quot;GetterSetter.h&quot;
  40 #include &quot;HasOwnPropertyCache.h&quot;
  41 #include &quot;HashMapImpl.h&quot;
  42 #include &quot;JSLexicalEnvironment.h&quot;
  43 #include &quot;JSPropertyNameEnumerator.h&quot;
  44 #include &quot;ObjectPrototype.h&quot;
  45 #include &quot;JSCInlines.h&quot;
  46 #include &quot;SetupVarargsFrame.h&quot;
  47 #include &quot;SuperSampler.h&quot;
  48 #include &quot;Watchdog.h&quot;
  49 
  50 namespace JSC { namespace DFG {
  51 
  52 #if USE(JSVALUE32_64)
  53 
  54 static_assert(SpecCellCheck == SpecCell, &quot;This is strongly assumed in the 32-bit DFG backend.&quot;);
  55 
  56 bool SpeculativeJIT::fillJSValue(Edge edge, GPRReg&amp; tagGPR, GPRReg&amp; payloadGPR, FPRReg&amp; fpr)
  57 {
  58     // FIXME: For double we could fill with a FPR.
  59     UNUSED_PARAM(fpr);
  60 
  61     VirtualRegister virtualRegister = edge-&gt;virtualRegister();
  62     GenerationInfo&amp; info = generationInfoFromVirtualRegister(virtualRegister);
  63 
  64     switch (info.registerFormat()) {
  65     case DataFormatNone: {
  66 
  67         if (edge-&gt;hasConstant()) {
  68             tagGPR = allocate();
  69             payloadGPR = allocate();
  70             JSValue value = edge-&gt;asJSValue();
  71             m_jit.move(Imm32(value.tag()), tagGPR);
  72             m_jit.move(Imm32(value.payload()), payloadGPR);
  73             m_gprs.retain(tagGPR, virtualRegister, SpillOrderConstant);
  74             m_gprs.retain(payloadGPR, virtualRegister, SpillOrderConstant);
  75             info.fillJSValue(*m_stream, tagGPR, payloadGPR, DataFormatJS);
  76         } else {
  77             DataFormat spillFormat = info.spillFormat();
  78             ASSERT(spillFormat != DataFormatNone &amp;&amp; spillFormat != DataFormatStorage);
  79             tagGPR = allocate();
  80             payloadGPR = allocate();
  81             switch (spillFormat) {
  82             case DataFormatInt32:
  83                 m_jit.move(TrustedImm32(JSValue::Int32Tag), tagGPR);
  84                 spillFormat = DataFormatJSInt32; // This will be used as the new register format.
  85                 break;
  86             case DataFormatCell:
  87                 m_jit.move(TrustedImm32(JSValue::CellTag), tagGPR);
  88                 spillFormat = DataFormatJSCell; // This will be used as the new register format.
  89                 break;
  90             case DataFormatBoolean:
  91                 m_jit.move(TrustedImm32(JSValue::BooleanTag), tagGPR);
  92                 spillFormat = DataFormatJSBoolean; // This will be used as the new register format.
  93                 break;
  94             default:
  95                 m_jit.load32(JITCompiler::tagFor(virtualRegister), tagGPR);
  96                 break;
  97             }
  98             m_jit.load32(JITCompiler::payloadFor(virtualRegister), payloadGPR);
  99             m_gprs.retain(tagGPR, virtualRegister, SpillOrderSpilled);
 100             m_gprs.retain(payloadGPR, virtualRegister, SpillOrderSpilled);
 101             info.fillJSValue(*m_stream, tagGPR, payloadGPR, spillFormat == DataFormatJSDouble ? DataFormatJS : spillFormat);
 102         }
 103 
 104         return true;
 105     }
 106 
 107     case DataFormatInt32:
 108     case DataFormatCell:
 109     case DataFormatBoolean: {
 110         GPRReg gpr = info.gpr();
 111         // If the register has already been locked we need to take a copy.
 112         if (m_gprs.isLocked(gpr)) {
 113             payloadGPR = allocate();
 114             m_jit.move(gpr, payloadGPR);
 115         } else {
 116             payloadGPR = gpr;
 117             m_gprs.lock(gpr);
 118         }
 119         tagGPR = allocate();
 120         int32_t tag = JSValue::EmptyValueTag;
 121         DataFormat fillFormat = DataFormatJS;
 122         switch (info.registerFormat()) {
 123         case DataFormatInt32:
 124             tag = JSValue::Int32Tag;
 125             fillFormat = DataFormatJSInt32;
 126             break;
 127         case DataFormatCell:
 128             tag = JSValue::CellTag;
 129             fillFormat = DataFormatJSCell;
 130             break;
 131         case DataFormatBoolean:
 132             tag = JSValue::BooleanTag;
 133             fillFormat = DataFormatJSBoolean;
 134             break;
 135         default:
 136             RELEASE_ASSERT_NOT_REACHED();
 137             break;
 138         }
 139         m_jit.move(TrustedImm32(tag), tagGPR);
 140         m_gprs.release(gpr);
 141         m_gprs.retain(tagGPR, virtualRegister, SpillOrderJS);
 142         m_gprs.retain(payloadGPR, virtualRegister, SpillOrderJS);
 143         info.fillJSValue(*m_stream, tagGPR, payloadGPR, fillFormat);
 144         return true;
 145     }
 146 
 147     case DataFormatJSDouble:
 148     case DataFormatJS:
 149     case DataFormatJSInt32:
 150     case DataFormatJSCell:
 151     case DataFormatJSBoolean: {
 152         tagGPR = info.tagGPR();
 153         payloadGPR = info.payloadGPR();
 154         m_gprs.lock(tagGPR);
 155         m_gprs.lock(payloadGPR);
 156         return true;
 157     }
 158 
 159     case DataFormatStorage:
 160     case DataFormatDouble:
 161         // this type currently never occurs
 162         RELEASE_ASSERT_NOT_REACHED();
 163 
 164     default:
 165         RELEASE_ASSERT_NOT_REACHED();
 166         return true;
 167     }
 168 }
 169 
 170 void SpeculativeJIT::cachedGetById(CodeOrigin origin, JSValueRegs base, JSValueRegs result, unsigned identifierNumber, JITCompiler::Jump slowPathTarget , SpillRegistersMode mode, AccessType type)
 171 {
 172     cachedGetById(origin, base.tagGPR(), base.payloadGPR(), result.tagGPR(), result.payloadGPR(), identifierNumber, slowPathTarget, mode, type);
 173 }
 174 
 175 void SpeculativeJIT::cachedGetById(
 176     CodeOrigin codeOrigin, GPRReg baseTagGPROrNone, GPRReg basePayloadGPR, GPRReg resultTagGPR, GPRReg resultPayloadGPR,
 177     unsigned identifierNumber, JITCompiler::Jump slowPathTarget, SpillRegistersMode spillMode, AccessType type)
 178 {
 179     // This is a hacky fix for when the register allocator decides to alias the base payload with the result tag. This only happens
 180     // in the case of GetByIdFlush/GetByIdDirectFlush, which has a relatively expensive register allocation story already so we probably don&#39;t need to
 181     // trip over one move instruction.
 182     if (basePayloadGPR == resultTagGPR) {
 183         RELEASE_ASSERT(basePayloadGPR != resultPayloadGPR);
 184 
 185         if (baseTagGPROrNone == resultPayloadGPR) {
 186             m_jit.swap(basePayloadGPR, baseTagGPROrNone);
 187             baseTagGPROrNone = resultTagGPR;
 188         } else
 189             m_jit.move(basePayloadGPR, resultPayloadGPR);
 190         basePayloadGPR = resultPayloadGPR;
 191     }
 192 
 193     RegisterSet usedRegisters = this-&gt;usedRegisters();
 194     if (spillMode == DontSpill) {
 195         // We&#39;ve already flushed registers to the stack, we don&#39;t need to spill these.
 196         usedRegisters.set(JSValueRegs(baseTagGPROrNone, basePayloadGPR), false);
 197         usedRegisters.set(JSValueRegs(resultTagGPR, resultPayloadGPR), false);
 198     }
 199 
 200     CallSiteIndex callSite = m_jit.recordCallSiteAndGenerateExceptionHandlingOSRExitIfNeeded(codeOrigin, m_stream-&gt;size());
 201     JITGetByIdGenerator gen(
 202         m_jit.codeBlock(), codeOrigin, callSite, usedRegisters, identifierUID(identifierNumber),
 203         JSValueRegs(baseTagGPROrNone, basePayloadGPR), JSValueRegs(resultTagGPR, resultPayloadGPR), type);
 204 
 205     gen.generateFastPath(m_jit);
 206 
 207     JITCompiler::JumpList slowCases;
 208     if (slowPathTarget.isSet())
 209         slowCases.append(slowPathTarget);
 210     slowCases.append(gen.slowPathJump());
 211 
 212     std::unique_ptr&lt;SlowPathGenerator&gt; slowPath;
 213     if (baseTagGPROrNone == InvalidGPRReg) {
 214         slowPath = slowPathCall(
 215             slowCases, this, appropriateOptimizingGetByIdFunction(type),
 216             JSValueRegs(resultTagGPR, resultPayloadGPR), gen.stubInfo(),
 217             CCallHelpers::CellValue(basePayloadGPR),
 218             identifierUID(identifierNumber));
 219     } else {
 220         slowPath = slowPathCall(
 221             slowCases, this, appropriateOptimizingGetByIdFunction(type),
 222             JSValueRegs(resultTagGPR, resultPayloadGPR), gen.stubInfo(), JSValueRegs(baseTagGPROrNone, basePayloadGPR), identifierUID(identifierNumber));
 223     }
 224 
 225     m_jit.addGetById(gen, slowPath.get());
 226     addSlowPathGenerator(WTFMove(slowPath));
 227 }
 228 
 229 void SpeculativeJIT::cachedGetByIdWithThis(
 230     CodeOrigin codeOrigin, GPRReg baseTagGPROrNone, GPRReg basePayloadGPR, GPRReg thisTagGPR, GPRReg thisPayloadGPR, GPRReg resultTagGPR, GPRReg resultPayloadGPR,
 231     unsigned identifierNumber, const JITCompiler::JumpList&amp; slowPathTarget)
 232 {
 233     RegisterSet usedRegisters = this-&gt;usedRegisters();
 234 
 235     CallSiteIndex callSite = m_jit.recordCallSiteAndGenerateExceptionHandlingOSRExitIfNeeded(codeOrigin, m_stream-&gt;size());
 236     JITGetByIdWithThisGenerator gen(
 237         m_jit.codeBlock(), codeOrigin, callSite, usedRegisters, identifierUID(identifierNumber),
 238         JSValueRegs(resultTagGPR, resultPayloadGPR), JSValueRegs(baseTagGPROrNone, basePayloadGPR), JSValueRegs(thisTagGPR, thisPayloadGPR), AccessType::GetWithThis);
 239 
 240     gen.generateFastPath(m_jit);
 241 
 242     JITCompiler::JumpList slowCases;
 243     if (!slowPathTarget.empty())
 244         slowCases.append(slowPathTarget);
 245     slowCases.append(gen.slowPathJump());
 246 
 247     std::unique_ptr&lt;SlowPathGenerator&gt; slowPath;
 248     if (baseTagGPROrNone == InvalidGPRReg &amp;&amp; thisTagGPR == InvalidGPRReg) {
 249         slowPath = slowPathCall(
 250             slowCases, this, operationGetByIdWithThisOptimize,
 251             JSValueRegs(resultTagGPR, resultPayloadGPR), gen.stubInfo(),
 252             CCallHelpers::CellValue(basePayloadGPR),
 253             CCallHelpers::CellValue(thisPayloadGPR),
 254             identifierUID(identifierNumber));
 255     } else {
 256         ASSERT(baseTagGPROrNone != InvalidGPRReg);
 257         ASSERT(thisTagGPR != InvalidGPRReg);
 258 
 259         slowPath = slowPathCall(
 260             slowCases, this, operationGetByIdWithThisOptimize,
 261             JSValueRegs(resultTagGPR, resultPayloadGPR), gen.stubInfo(), JSValueRegs(baseTagGPROrNone, basePayloadGPR), JSValueRegs(thisTagGPR, thisPayloadGPR), identifierUID(identifierNumber));
 262     }
 263 
 264     m_jit.addGetByIdWithThis(gen, slowPath.get());
 265     addSlowPathGenerator(WTFMove(slowPath));
 266 }
 267 
 268 void SpeculativeJIT::nonSpeculativeNonPeepholeCompareNullOrUndefined(Edge operand)
 269 {
 270     JSValueOperand arg(this, operand, ManualOperandSpeculation);
 271     GPRReg argTagGPR = arg.tagGPR();
 272     GPRReg argPayloadGPR = arg.payloadGPR();
 273 
 274     GPRTemporary resultPayload(this, Reuse, arg, PayloadWord);
 275     GPRReg resultPayloadGPR = resultPayload.gpr();
 276 
 277     JITCompiler::Jump notCell;
 278     JITCompiler::Jump notMasqueradesAsUndefined;
 279     if (masqueradesAsUndefinedWatchpointIsStillValid()) {
 280         if (!isKnownCell(operand.node()))
 281             notCell = m_jit.branchIfNotCell(arg.jsValueRegs());
 282 
 283         m_jit.move(TrustedImm32(0), resultPayloadGPR);
 284         notMasqueradesAsUndefined = m_jit.jump();
 285     } else {
 286         GPRTemporary localGlobalObject(this);
 287         GPRTemporary remoteGlobalObject(this);
 288 
 289         if (!isKnownCell(operand.node()))
 290             notCell = m_jit.branchIfNotCell(arg.jsValueRegs());
 291 
 292         JITCompiler::Jump isMasqueradesAsUndefined = m_jit.branchTest8(
 293             JITCompiler::NonZero,
 294             JITCompiler::Address(argPayloadGPR, JSCell::typeInfoFlagsOffset()),
 295             JITCompiler::TrustedImm32(MasqueradesAsUndefined));
 296 
 297         m_jit.move(TrustedImm32(0), resultPayloadGPR);
 298         notMasqueradesAsUndefined = m_jit.jump();
 299 
 300         isMasqueradesAsUndefined.link(&amp;m_jit);
 301         GPRReg localGlobalObjectGPR = localGlobalObject.gpr();
 302         GPRReg remoteGlobalObjectGPR = remoteGlobalObject.gpr();
 303         m_jit.move(TrustedImmPtr::weakPointer(m_jit.graph(), m_jit.graph().globalObjectFor(m_currentNode-&gt;origin.semantic)), localGlobalObjectGPR);
 304         m_jit.loadPtr(JITCompiler::Address(argPayloadGPR, JSCell::structureIDOffset()), resultPayloadGPR);
 305         m_jit.loadPtr(JITCompiler::Address(resultPayloadGPR, Structure::globalObjectOffset()), remoteGlobalObjectGPR);
 306         m_jit.compare32(JITCompiler::Equal, localGlobalObjectGPR, remoteGlobalObjectGPR, resultPayloadGPR);
 307     }
 308 
 309     if (!isKnownCell(operand.node())) {
 310         JITCompiler::Jump done = m_jit.jump();
 311 
 312         notCell.link(&amp;m_jit);
 313         // null or undefined?
 314         COMPILE_ASSERT((JSValue::UndefinedTag | 1) == JSValue::NullTag, UndefinedTag_OR_1_EQUALS_NullTag);
 315         m_jit.or32(TrustedImm32(1), argTagGPR, resultPayloadGPR);
 316         m_jit.compare32(JITCompiler::Equal, resultPayloadGPR, TrustedImm32(JSValue::NullTag), resultPayloadGPR);
 317 
 318         done.link(&amp;m_jit);
 319     }
 320 
 321     notMasqueradesAsUndefined.link(&amp;m_jit);
 322 
 323     booleanResult(resultPayloadGPR, m_currentNode);
 324 }
 325 
 326 void SpeculativeJIT::nonSpeculativePeepholeBranchNullOrUndefined(Edge operand, Node* branchNode)
 327 {
 328     BasicBlock* taken = branchNode-&gt;branchData()-&gt;taken.block;
 329     BasicBlock* notTaken = branchNode-&gt;branchData()-&gt;notTaken.block;
 330 
 331     bool invert = false;
 332     if (taken == nextBlock()) {
 333         invert = !invert;
 334         BasicBlock* tmp = taken;
 335         taken = notTaken;
 336         notTaken = tmp;
 337     }
 338 
 339     JSValueOperand arg(this, operand, ManualOperandSpeculation);
 340     GPRReg argTagGPR = arg.tagGPR();
 341     GPRReg argPayloadGPR = arg.payloadGPR();
 342 
 343     GPRTemporary result(this, Reuse, arg, TagWord);
 344     GPRReg resultGPR = result.gpr();
 345 
 346     JITCompiler::Jump notCell;
 347 
 348     if (masqueradesAsUndefinedWatchpointIsStillValid()) {
 349         if (!isKnownCell(operand.node()))
 350             notCell = m_jit.branchIfNotCell(arg.jsValueRegs());
 351 
 352         jump(invert ? taken : notTaken, ForceJump);
 353     } else {
 354         GPRTemporary localGlobalObject(this);
 355         GPRTemporary remoteGlobalObject(this);
 356 
 357         if (!isKnownCell(operand.node()))
 358             notCell = m_jit.branchIfNotCell(arg.jsValueRegs());
 359 
 360         branchTest8(JITCompiler::Zero,
 361             JITCompiler::Address(argPayloadGPR, JSCell::typeInfoFlagsOffset()),
 362             JITCompiler::TrustedImm32(MasqueradesAsUndefined),
 363             invert ? taken : notTaken);
 364 
 365         GPRReg localGlobalObjectGPR = localGlobalObject.gpr();
 366         GPRReg remoteGlobalObjectGPR = remoteGlobalObject.gpr();
 367         m_jit.move(TrustedImmPtr::weakPointer(m_jit.graph(), m_jit.graph().globalObjectFor(m_currentNode-&gt;origin.semantic)), localGlobalObjectGPR);
 368         m_jit.loadPtr(JITCompiler::Address(argPayloadGPR, JSCell::structureIDOffset()), resultGPR);
 369         m_jit.loadPtr(JITCompiler::Address(resultGPR, Structure::globalObjectOffset()), remoteGlobalObjectGPR);
 370         branchPtr(JITCompiler::Equal, localGlobalObjectGPR, remoteGlobalObjectGPR, invert ? notTaken : taken);
 371     }
 372 
 373     if (!isKnownCell(operand.node())) {
 374         jump(notTaken, ForceJump);
 375 
 376         notCell.link(&amp;m_jit);
 377         // null or undefined?
 378         COMPILE_ASSERT((JSValue::UndefinedTag | 1) == JSValue::NullTag, UndefinedTag_OR_1_EQUALS_NullTag);
 379         m_jit.or32(TrustedImm32(1), argTagGPR, resultGPR);
 380         branch32(invert ? JITCompiler::NotEqual : JITCompiler::Equal, resultGPR, JITCompiler::TrustedImm32(JSValue::NullTag), taken);
 381     }
 382 
 383     jump(notTaken);
 384 }
 385 
 386 void SpeculativeJIT::nonSpeculativePeepholeStrictEq(Node* node, Node* branchNode, bool invert)
 387 {
 388     BasicBlock* taken = branchNode-&gt;branchData()-&gt;taken.block;
 389     BasicBlock* notTaken = branchNode-&gt;branchData()-&gt;notTaken.block;
 390 
 391     // The branch instruction will branch to the taken block.
 392     // If taken is next, switch taken with notTaken &amp; invert the branch condition so we can fall through.
 393     if (taken == nextBlock()) {
 394         invert = !invert;
 395         BasicBlock* tmp = taken;
 396         taken = notTaken;
 397         notTaken = tmp;
 398     }
 399 
 400     JSValueOperand arg1(this, node-&gt;child1());
 401     JSValueOperand arg2(this, node-&gt;child2());
 402     GPRReg arg1PayloadGPR = arg1.payloadGPR();
 403     GPRReg arg2PayloadGPR = arg2.payloadGPR();
 404     JSValueRegs arg1Regs = arg1.jsValueRegs();
 405     JSValueRegs arg2Regs = arg2.jsValueRegs();
 406 
 407     GPRTemporary resultPayload(this, Reuse, arg1, PayloadWord);
 408     GPRReg resultPayloadGPR = resultPayload.gpr();
 409 
 410     arg1.use();
 411     arg2.use();
 412 
 413     if (isKnownCell(node-&gt;child1().node()) &amp;&amp; isKnownCell(node-&gt;child2().node())) {
 414         // see if we get lucky: if the arguments are cells and they reference the same
 415         // cell, then they must be strictly equal.
 416         branchPtr(JITCompiler::Equal, arg1PayloadGPR, arg2PayloadGPR, invert ? notTaken : taken);
 417 
 418         silentSpillAllRegisters(resultPayloadGPR);
 419         callOperation(operationCompareStrictEqCell, resultPayloadGPR, arg1PayloadGPR, arg2PayloadGPR);
 420         m_jit.exceptionCheck();
 421         silentFillAllRegisters();
 422 
 423         branchTest32(invert ? JITCompiler::Zero : JITCompiler::NonZero, resultPayloadGPR, taken);
 424     } else {
 425         // FIXME: Add fast paths for twoCells, number etc.
 426 
 427         silentSpillAllRegisters(resultPayloadGPR);
 428         callOperation(operationCompareStrictEq, resultPayloadGPR, arg1Regs, arg2Regs);
 429         m_jit.exceptionCheck();
 430         silentFillAllRegisters();
 431 
 432         branchTest32(invert ? JITCompiler::Zero : JITCompiler::NonZero, resultPayloadGPR, taken);
 433     }
 434 
 435     jump(notTaken);
 436 }
 437 
 438 void SpeculativeJIT::nonSpeculativeNonPeepholeStrictEq(Node* node, bool invert)
 439 {
 440     JSValueOperand arg1(this, node-&gt;child1());
 441     JSValueOperand arg2(this, node-&gt;child2());
 442     GPRReg arg1PayloadGPR = arg1.payloadGPR();
 443     GPRReg arg2PayloadGPR = arg2.payloadGPR();
 444     JSValueRegs arg1Regs = arg1.jsValueRegs();
 445     JSValueRegs arg2Regs = arg2.jsValueRegs();
 446 
 447     GPRTemporary resultPayload(this, Reuse, arg1, PayloadWord);
 448     GPRReg resultPayloadGPR = resultPayload.gpr();
 449 
 450     arg1.use();
 451     arg2.use();
 452 
 453     if (isKnownCell(node-&gt;child1().node()) &amp;&amp; isKnownCell(node-&gt;child2().node())) {
 454         // see if we get lucky: if the arguments are cells and they reference the same
 455         // cell, then they must be strictly equal.
 456         // FIXME: this should flush registers instead of silent spill/fill.
 457         JITCompiler::Jump notEqualCase = m_jit.branchPtr(JITCompiler::NotEqual, arg1PayloadGPR, arg2PayloadGPR);
 458 
 459         m_jit.move(JITCompiler::TrustedImm32(!invert), resultPayloadGPR);
 460         JITCompiler::Jump done = m_jit.jump();
 461 
 462         notEqualCase.link(&amp;m_jit);
 463 
 464         silentSpillAllRegisters(resultPayloadGPR);
 465         callOperation(operationCompareStrictEqCell, resultPayloadGPR, arg1PayloadGPR, arg2PayloadGPR);
 466         m_jit.exceptionCheck();
 467         silentFillAllRegisters();
 468 
 469         m_jit.andPtr(JITCompiler::TrustedImm32(1), resultPayloadGPR);
 470 
 471         done.link(&amp;m_jit);
 472     } else {
 473         // FIXME: Add fast paths.
 474 
 475         silentSpillAllRegisters(resultPayloadGPR);
 476         callOperation(operationCompareStrictEq, resultPayloadGPR, arg1Regs, arg2Regs);
 477         silentFillAllRegisters();
 478         m_jit.exceptionCheck();
 479 
 480         m_jit.andPtr(JITCompiler::TrustedImm32(1), resultPayloadGPR);
 481     }
 482 
 483     booleanResult(resultPayloadGPR, node, UseChildrenCalledExplicitly);
 484 }
 485 
 486 void SpeculativeJIT::compileCompareEqPtr(Node* node)
 487 {
 488     JSValueOperand operand(this, node-&gt;child1());
 489     GPRTemporary result(this);
 490     JSValueRegs regs = operand.jsValueRegs();
 491     GPRReg resultGPR = result.gpr();
 492     m_jit.boxBooleanPayload(false, resultGPR);
 493     JITCompiler::JumpList notEqual = m_jit.branchIfNotEqual(regs, node-&gt;cellOperand()-&gt;value());
 494     m_jit.boxBooleanPayload(true, resultGPR);
 495     notEqual.link(&amp;m_jit);
 496     blessedBooleanResult(resultGPR, node);
 497 }
 498 
 499 void SpeculativeJIT::emitCall(Node* node)
 500 {
 501     CallLinkInfo::CallType callType;
 502     bool isVarargs = false;
 503     bool isForwardVarargs = false;
 504     bool isTail = false;
 505     bool isDirect = false;
 506     bool isEmulatedTail = false;
 507     switch (node-&gt;op()) {
 508     case Call:
 509     case CallEval:
 510         callType = CallLinkInfo::Call;
 511         break;
 512     case TailCall:
 513         callType = CallLinkInfo::TailCall;
 514         isTail = true;
 515         break;
 516     case TailCallInlinedCaller:
 517         callType = CallLinkInfo::Call;
 518         isEmulatedTail = true;
 519         break;
 520     case Construct:
 521         callType = CallLinkInfo::Construct;
 522         break;
 523     case CallVarargs:
 524         callType = CallLinkInfo::CallVarargs;
 525         isVarargs = true;
 526         break;
 527     case TailCallVarargs:
 528         callType = CallLinkInfo::TailCallVarargs;
 529         isVarargs = true;
 530         isTail = true;
 531         break;
 532     case TailCallVarargsInlinedCaller:
 533         callType = CallLinkInfo::CallVarargs;
 534         isVarargs = true;
 535         isEmulatedTail = true;
 536         break;
 537     case ConstructVarargs:
 538         callType = CallLinkInfo::ConstructVarargs;
 539         isVarargs = true;
 540         break;
 541     case CallForwardVarargs:
 542         callType = CallLinkInfo::CallVarargs;
 543         isForwardVarargs = true;
 544         break;
 545     case TailCallForwardVarargs:
 546         callType = CallLinkInfo::TailCallVarargs;
 547         isTail = true;
 548         isForwardVarargs = true;
 549         break;
 550     case TailCallForwardVarargsInlinedCaller:
 551         callType = CallLinkInfo::CallVarargs;
 552         isEmulatedTail = true;
 553         isForwardVarargs = true;
 554         break;
 555     case ConstructForwardVarargs:
 556         callType = CallLinkInfo::ConstructVarargs;
 557         isForwardVarargs = true;
 558         break;
 559     case DirectCall:
 560         callType = CallLinkInfo::DirectCall;
 561         isDirect = true;
 562         break;
 563     case DirectConstruct:
 564         callType = CallLinkInfo::DirectConstruct;
 565         isDirect = true;
 566         break;
 567     case DirectTailCall:
 568         callType = CallLinkInfo::DirectTailCall;
 569         isTail = true;
 570         isDirect = true;
 571         break;
 572     case DirectTailCallInlinedCaller:
 573         callType = CallLinkInfo::DirectCall;
 574         isEmulatedTail = true;
 575         isDirect = true;
 576         break;
 577     default:
 578         DFG_CRASH(m_jit.graph(), node, &quot;bad node type&quot;);
 579         break;
 580     }
 581 
 582     Edge calleeEdge = m_jit.graph().child(node, 0);
 583     GPRReg calleeTagGPR = InvalidGPRReg;
 584     GPRReg calleePayloadGPR = InvalidGPRReg;
 585     CallFrameShuffleData shuffleData;
 586 
 587     ExecutableBase* executable = nullptr;
 588     FunctionExecutable* functionExecutable = nullptr;
 589     if (isDirect) {
 590         executable = node-&gt;castOperand&lt;ExecutableBase*&gt;();
<a name="2" id="anc2"></a><span class="line-modified"> 591         functionExecutable = jsDynamicCast&lt;FunctionExecutable*&gt;(vm(), executable);</span>
 592     }
 593 
 594     unsigned numPassedArgs = 0;
 595     unsigned numAllocatedArgs = 0;
 596 
 597     // Gotta load the arguments somehow. Varargs is trickier.
 598     if (isVarargs || isForwardVarargs) {
 599         RELEASE_ASSERT(!isDirect);
 600         CallVarargsData* data = node-&gt;callVarargsData();
 601 
 602         int numUsedStackSlots = m_jit.graph().m_nextMachineLocal;
 603 
 604         if (isForwardVarargs) {
 605             flushRegisters();
 606             if (node-&gt;child3())
 607                 use(node-&gt;child3());
 608 
 609             GPRReg scratchGPR1;
 610             GPRReg scratchGPR2;
 611             GPRReg scratchGPR3;
 612 
 613             scratchGPR1 = JITCompiler::selectScratchGPR();
 614             scratchGPR2 = JITCompiler::selectScratchGPR(scratchGPR1);
 615             scratchGPR3 = JITCompiler::selectScratchGPR(scratchGPR1, scratchGPR2);
 616 
 617             m_jit.move(TrustedImm32(numUsedStackSlots), scratchGPR2);
 618             JITCompiler::JumpList slowCase;
 619             InlineCallFrame* inlineCallFrame;
 620             if (node-&gt;child3())
<a name="3" id="anc3"></a><span class="line-modified"> 621                 inlineCallFrame = node-&gt;child3()-&gt;origin.semantic.inlineCallFrame();</span>
 622             else
<a name="4" id="anc4"></a><span class="line-modified"> 623                 inlineCallFrame = node-&gt;origin.semantic.inlineCallFrame();</span>
 624             // emitSetupVarargsFrameFastCase modifies the stack pointer if it succeeds.
<a name="5" id="anc5"></a><span class="line-modified"> 625             emitSetupVarargsFrameFastCase(vm(), m_jit, scratchGPR2, scratchGPR1, scratchGPR2, scratchGPR3, inlineCallFrame, data-&gt;firstVarArgOffset, slowCase);</span>
 626             JITCompiler::Jump done = m_jit.jump();
 627             slowCase.link(&amp;m_jit);
 628             callOperation(operationThrowStackOverflowForVarargs);
 629             m_jit.exceptionCheck();
 630             m_jit.abortWithReason(DFGVarargsThrowingPathDidNotThrow);
 631             done.link(&amp;m_jit);
 632         } else {
 633             GPRReg argumentsPayloadGPR;
 634             GPRReg argumentsTagGPR;
 635             GPRReg scratchGPR1;
 636             GPRReg scratchGPR2;
 637             GPRReg scratchGPR3;
 638 
 639             auto loadArgumentsGPR = [&amp;] (GPRReg reservedGPR) {
 640                 if (reservedGPR != InvalidGPRReg)
 641                     lock(reservedGPR);
 642                 JSValueOperand arguments(this, node-&gt;child3());
 643                 argumentsTagGPR = arguments.tagGPR();
 644                 argumentsPayloadGPR = arguments.payloadGPR();
 645                 if (reservedGPR != InvalidGPRReg)
 646                     unlock(reservedGPR);
 647                 flushRegisters();
 648 
 649                 scratchGPR1 = JITCompiler::selectScratchGPR(argumentsPayloadGPR, argumentsTagGPR, reservedGPR);
 650                 scratchGPR2 = JITCompiler::selectScratchGPR(argumentsPayloadGPR, argumentsTagGPR, scratchGPR1, reservedGPR);
 651                 scratchGPR3 = JITCompiler::selectScratchGPR(argumentsPayloadGPR, argumentsTagGPR, scratchGPR1, scratchGPR2, reservedGPR);
 652             };
 653 
 654             loadArgumentsGPR(InvalidGPRReg);
 655 
 656             DFG_ASSERT(m_jit.graph(), node, isFlushed());
 657 
 658             // Right now, arguments is in argumentsTagGPR/argumentsPayloadGPR and the register file is
 659             // flushed.
 660             callOperation(operationSizeFrameForVarargs, GPRInfo::returnValueGPR, JSValueRegs(argumentsTagGPR, argumentsPayloadGPR), numUsedStackSlots, data-&gt;firstVarArgOffset);
 661             m_jit.exceptionCheck();
 662 
 663             // Now we have the argument count of the callee frame, but we&#39;ve lost the arguments operand.
 664             // Reconstruct the arguments operand while preserving the callee frame.
 665             loadArgumentsGPR(GPRInfo::returnValueGPR);
 666             m_jit.move(TrustedImm32(numUsedStackSlots), scratchGPR1);
 667             emitSetVarargsFrame(m_jit, GPRInfo::returnValueGPR, false, scratchGPR1, scratchGPR1);
 668             m_jit.addPtr(TrustedImm32(-(sizeof(CallerFrameAndPC) + WTF::roundUpToMultipleOf(stackAlignmentBytes(), 6 * sizeof(void*)))), scratchGPR1, JITCompiler::stackPointerRegister);
 669 
 670             callOperation(operationSetupVarargsFrame, GPRInfo::returnValueGPR, scratchGPR1, JSValueRegs(argumentsTagGPR, argumentsPayloadGPR), data-&gt;firstVarArgOffset, GPRInfo::returnValueGPR);
 671             m_jit.exceptionCheck();
 672             m_jit.addPtr(TrustedImm32(sizeof(CallerFrameAndPC)), GPRInfo::returnValueGPR, JITCompiler::stackPointerRegister);
 673         }
 674 
 675         DFG_ASSERT(m_jit.graph(), node, isFlushed());
 676 
 677         // We don&#39;t need the arguments array anymore.
 678         if (isVarargs)
 679             use(node-&gt;child3());
 680 
 681         // Now set up the &quot;this&quot; argument.
 682         JSValueOperand thisArgument(this, node-&gt;child2());
 683         GPRReg thisArgumentTagGPR = thisArgument.tagGPR();
 684         GPRReg thisArgumentPayloadGPR = thisArgument.payloadGPR();
 685         thisArgument.use();
 686 
 687         m_jit.store32(thisArgumentTagGPR, JITCompiler::calleeArgumentTagSlot(0));
 688         m_jit.store32(thisArgumentPayloadGPR, JITCompiler::calleeArgumentPayloadSlot(0));
 689     } else {
 690         // The call instruction&#39;s first child is either the function (normal call) or the
 691         // receiver (method call). subsequent children are the arguments.
 692         numPassedArgs = node-&gt;numChildren() - 1;
 693         numAllocatedArgs = numPassedArgs;
 694 
 695         if (functionExecutable) {
 696             // Allocate more args if this would let us avoid arity checks. This is throttled by
 697             // CallLinkInfo&#39;s limit. It&#39;s probably good to throttle it - if the callee wants a
 698             // ginormous amount of argument space then it&#39;s better for them to do it so that when we
 699             // make calls to other things, we don&#39;t waste space.
 700             unsigned desiredNumAllocatedArgs = static_cast&lt;unsigned&gt;(functionExecutable-&gt;parameterCount()) + 1;
 701             if (desiredNumAllocatedArgs &lt;= Options::maximumDirectCallStackSize()) {
 702                 numAllocatedArgs = std::max(numAllocatedArgs, desiredNumAllocatedArgs);
 703 
 704                 // Whoever converts to DirectCall should do this adjustment. It&#39;s too late for us to
 705                 // do this adjustment now since we will have already emitted code that relied on the
 706                 // value of m_parameterSlots.
 707                 DFG_ASSERT(
 708                     m_jit.graph(), node,
 709                     Graph::parameterSlotsForArgCount(numAllocatedArgs)
 710                     &lt;= m_jit.graph().m_parameterSlots);
 711             }
 712         }
 713 
 714         if (isTail) {
 715             JSValueOperand callee(this, calleeEdge);
 716             calleeTagGPR = callee.tagGPR();
 717             calleePayloadGPR = callee.payloadGPR();
 718             if (!isDirect)
 719                 use(calleeEdge);
 720 
 721             shuffleData.numLocals = m_jit.graph().frameRegisterCount();
 722             shuffleData.callee = ValueRecovery::inPair(calleeTagGPR, calleePayloadGPR);
 723             shuffleData.args.resize(numAllocatedArgs);
 724             shuffleData.numPassedArgs = numPassedArgs;
 725 
 726             for (unsigned i = 0; i &lt; numPassedArgs; ++i) {
 727                 Edge argEdge = m_jit.graph().varArgChild(node, i + 1);
 728                 GenerationInfo&amp; info = generationInfo(argEdge.node());
 729                 if (!isDirect)
 730                     use(argEdge);
 731                 shuffleData.args[i] = info.recovery(argEdge-&gt;virtualRegister());
 732             }
 733 
 734             for (unsigned i = numPassedArgs; i &lt; numAllocatedArgs; ++i)
 735                 shuffleData.args[i] = ValueRecovery::constant(jsUndefined());
 736         } else {
 737             m_jit.store32(MacroAssembler::TrustedImm32(numPassedArgs), m_jit.calleeFramePayloadSlot(CallFrameSlot::argumentCount));
 738 
 739             for (unsigned i = 0; i &lt; numPassedArgs; i++) {
 740                 Edge argEdge = m_jit.graph().m_varArgChildren[node-&gt;firstChild() + 1 + i];
 741                 JSValueOperand arg(this, argEdge);
 742                 GPRReg argTagGPR = arg.tagGPR();
 743                 GPRReg argPayloadGPR = arg.payloadGPR();
 744                 use(argEdge);
 745 
 746                 m_jit.store32(argTagGPR, m_jit.calleeArgumentTagSlot(i));
 747                 m_jit.store32(argPayloadGPR, m_jit.calleeArgumentPayloadSlot(i));
 748             }
 749 
 750             for (unsigned i = numPassedArgs; i &lt; numAllocatedArgs; ++i)
 751                 m_jit.storeTrustedValue(jsUndefined(), JITCompiler::calleeArgumentSlot(i));
 752         }
 753     }
 754 
 755     if (!isTail || isVarargs || isForwardVarargs) {
 756         JSValueOperand callee(this, calleeEdge);
 757         calleeTagGPR = callee.tagGPR();
 758         calleePayloadGPR = callee.payloadGPR();
 759         use(calleeEdge);
 760         m_jit.store32(calleePayloadGPR, m_jit.calleeFramePayloadSlot(CallFrameSlot::callee));
 761         m_jit.store32(calleeTagGPR, m_jit.calleeFrameTagSlot(CallFrameSlot::callee));
 762 
 763         if (!isTail)
 764             flushRegisters();
 765     }
 766 
 767     JITCompiler::DataLabelPtr targetToCheck;
 768     JITCompiler::JumpList slowPath;
 769 
 770     CodeOrigin staticOrigin = node-&gt;origin.semantic;
<a name="6" id="anc6"></a><span class="line-modified"> 771     InlineCallFrame* staticInlineCallFrame = staticOrigin.inlineCallFrame();</span>
<span class="line-modified"> 772     ASSERT(!isTail || !staticInlineCallFrame || !staticInlineCallFrame-&gt;getCallerSkippingTailCalls());</span>
<span class="line-added"> 773     ASSERT(!isEmulatedTail || (staticInlineCallFrame &amp;&amp; staticInlineCallFrame-&gt;getCallerSkippingTailCalls()));</span>
 774     CodeOrigin dynamicOrigin =
<a name="7" id="anc7"></a><span class="line-modified"> 775         isEmulatedTail ? *staticInlineCallFrame-&gt;getCallerSkippingTailCalls() : staticOrigin;</span>
 776     CallSiteIndex callSite = m_jit.recordCallSiteAndGenerateExceptionHandlingOSRExitIfNeeded(dynamicOrigin, m_stream-&gt;size());
 777 
 778     CallLinkInfo* info = m_jit.codeBlock()-&gt;addCallLinkInfo();
 779     info-&gt;setUpCall(callType, node-&gt;origin.semantic, calleePayloadGPR);
 780 
 781     auto setResultAndResetStack = [&amp;] () {
 782         JSValueRegsFlushedCallResult result(this);
 783         JSValueRegs resultRegs = result.regs();
 784 
 785         m_jit.setupResults(resultRegs);
 786 
 787         jsValueResult(resultRegs, node, DataFormatJS, UseChildrenCalledExplicitly);
 788         // After the calls are done, we need to reestablish our stack
 789         // pointer. We rely on this for varargs calls, calls with arity
 790         // mismatch (the callframe is slided) and tail calls.
 791         m_jit.addPtr(TrustedImm32(m_jit.graph().stackPointerOffset() * sizeof(Register)), GPRInfo::callFrameRegister, JITCompiler::stackPointerRegister);
 792     };
 793 
 794     if (node-&gt;op() == CallEval) {
 795         // We want to call operationCallEval but we don&#39;t want to overwrite the parameter area in
 796         // which we have created a prototypical eval call frame. This means that we have to
 797         // subtract stack to make room for the call. Lucky for us, at this point we have the whole
 798         // register file to ourselves.
 799 
 800         m_jit.emitStoreCallSiteIndex(callSite);
 801         m_jit.addPtr(TrustedImm32(-static_cast&lt;ptrdiff_t&gt;(sizeof(CallerFrameAndPC))), JITCompiler::stackPointerRegister, GPRInfo::regT0);
 802         m_jit.storePtr(GPRInfo::callFrameRegister, JITCompiler::Address(GPRInfo::regT0, CallFrame::callerFrameOffset()));
 803 
 804         // Now we need to make room for:
 805         // - The caller frame and PC of a call to operationCallEval.
 806         // - Potentially two arguments on the stack.
 807         unsigned requiredBytes = sizeof(CallerFrameAndPC) + sizeof(ExecState*) * 2;
 808         requiredBytes = WTF::roundUpToMultipleOf(stackAlignmentBytes(), requiredBytes);
 809         m_jit.subPtr(TrustedImm32(requiredBytes), JITCompiler::stackPointerRegister);
 810         m_jit.setupArguments&lt;decltype(operationCallEval)&gt;(GPRInfo::regT0);
 811         prepareForExternalCall();
 812         m_jit.appendCall(operationCallEval);
 813         m_jit.exceptionCheck();
 814         JITCompiler::Jump done = m_jit.branchIfNotEmpty(GPRInfo::returnValueGPR2);
 815 
 816         // This is the part where we meant to make a normal call. Oops.
 817         m_jit.addPtr(TrustedImm32(requiredBytes), JITCompiler::stackPointerRegister);
 818         m_jit.load32(JITCompiler::calleeFrameSlot(CallFrameSlot::callee).withOffset(PayloadOffset), GPRInfo::regT0);
 819         m_jit.load32(JITCompiler::calleeFrameSlot(CallFrameSlot::callee).withOffset(TagOffset), GPRInfo::regT1);
<a name="8" id="anc8"></a><span class="line-modified"> 820         m_jit.emitDumbVirtualCall(vm(), info);</span>
 821 
 822         done.link(&amp;m_jit);
 823         setResultAndResetStack();
 824         return;
 825     }
 826 
 827     if (isDirect) {
 828         info-&gt;setExecutableDuringCompilation(executable);
 829         info-&gt;setMaxNumArguments(numAllocatedArgs);
 830 
 831         if (isTail) {
 832             RELEASE_ASSERT(node-&gt;op() == DirectTailCall);
 833 
 834             JITCompiler::PatchableJump patchableJump = m_jit.patchableJump();
 835             JITCompiler::Label mainPath = m_jit.label();
 836 
 837             m_jit.emitStoreCallSiteIndex(callSite);
 838 
 839             info-&gt;setFrameShuffleData(shuffleData);
 840             CallFrameShuffler(m_jit, shuffleData).prepareForTailCall();
 841 
 842             JITCompiler::Call call = m_jit.nearTailCall();
 843 
 844             JITCompiler::Label slowPath = m_jit.label();
 845             patchableJump.m_jump.linkTo(slowPath, &amp;m_jit);
 846 
 847             silentSpillAllRegisters(InvalidGPRReg);
 848             callOperation(operationLinkDirectCall, info, calleePayloadGPR);
 849             silentFillAllRegisters();
 850             m_jit.exceptionCheck();
 851             m_jit.jump().linkTo(mainPath, &amp;m_jit);
 852 
 853             useChildren(node);
 854 
 855             m_jit.addJSDirectTailCall(patchableJump, call, slowPath, info);
 856             return;
 857         }
 858 
 859         JITCompiler::Label mainPath = m_jit.label();
 860 
 861         m_jit.emitStoreCallSiteIndex(callSite);
 862 
 863         JITCompiler::Call call = m_jit.nearCall();
 864         JITCompiler::Jump done = m_jit.jump();
 865 
 866         JITCompiler::Label slowPath = m_jit.label();
 867         if (isX86())
 868             m_jit.pop(JITCompiler::selectScratchGPR(calleePayloadGPR));
 869 
 870         callOperation(operationLinkDirectCall, info, calleePayloadGPR);
 871         m_jit.exceptionCheck();
 872         m_jit.jump().linkTo(mainPath, &amp;m_jit);
 873 
 874         done.link(&amp;m_jit);
 875 
 876         setResultAndResetStack();
 877 
 878         m_jit.addJSDirectCall(call, slowPath, info);
 879         return;
 880     }
 881 
 882     m_jit.emitStoreCallSiteIndex(callSite);
 883 
 884     slowPath.append(m_jit.branchIfNotCell(JSValueRegs(calleeTagGPR, calleePayloadGPR)));
 885     slowPath.append(m_jit.branchPtrWithPatch(MacroAssembler::NotEqual, calleePayloadGPR, targetToCheck));
 886 
 887     if (isTail) {
 888         if (node-&gt;op() == TailCall) {
 889             info-&gt;setFrameShuffleData(shuffleData);
 890             CallFrameShuffler(m_jit, shuffleData).prepareForTailCall();
 891         } else {
 892             m_jit.emitRestoreCalleeSaves();
 893             m_jit.prepareForTailCallSlow();
 894         }
 895     }
 896 
 897     JITCompiler::Call fastCall = isTail ? m_jit.nearTailCall() : m_jit.nearCall();
 898 
 899     JITCompiler::Jump done = m_jit.jump();
 900 
 901     slowPath.link(&amp;m_jit);
 902 
 903     if (node-&gt;op() == TailCall) {
 904         CallFrameShuffler callFrameShuffler(m_jit, shuffleData);
 905         callFrameShuffler.setCalleeJSValueRegs(JSValueRegs(
 906             GPRInfo::regT1, GPRInfo::regT0));
 907         callFrameShuffler.prepareForSlowPath();
 908     } else {
 909         // Callee payload needs to be in regT0, tag in regT1
 910         if (calleeTagGPR == GPRInfo::regT0) {
 911             if (calleePayloadGPR == GPRInfo::regT1)
 912                 m_jit.swap(GPRInfo::regT1, GPRInfo::regT0);
 913             else {
 914                 m_jit.move(calleeTagGPR, GPRInfo::regT1);
 915                 m_jit.move(calleePayloadGPR, GPRInfo::regT0);
 916             }
 917         } else {
 918             m_jit.move(calleePayloadGPR, GPRInfo::regT0);
 919             m_jit.move(calleeTagGPR, GPRInfo::regT1);
 920         }
 921 
 922         if (isTail)
 923             m_jit.emitRestoreCalleeSaves();
 924     }
 925 
 926     m_jit.move(TrustedImmPtr(info), GPRInfo::regT2);
 927     JITCompiler::Call slowCall = m_jit.nearCall();
 928 
 929     done.link(&amp;m_jit);
 930 
 931     if (isTail)
 932         m_jit.abortWithReason(JITDidReturnFromTailCall);
 933     else
 934         setResultAndResetStack();
 935 
 936     m_jit.addJSCall(fastCall, slowCall, targetToCheck, info);
 937 }
 938 
 939 template&lt;bool strict&gt;
 940 GPRReg SpeculativeJIT::fillSpeculateInt32Internal(Edge edge, DataFormat&amp; returnFormat)
 941 {
 942     AbstractValue&amp; value = m_state.forNode(edge);
 943     SpeculatedType type = value.m_type;
 944     ASSERT(edge.useKind() != KnownInt32Use || !(value.m_type &amp; ~SpecInt32Only));
 945 
 946     m_interpreter.filter(value, SpecInt32Only);
 947     if (value.isClear()) {
 948         terminateSpeculativeExecution(Uncountable, JSValueRegs(), 0);
 949         returnFormat = DataFormatInt32;
 950         return allocate();
 951     }
 952 
 953     VirtualRegister virtualRegister = edge-&gt;virtualRegister();
 954     GenerationInfo&amp; info = generationInfoFromVirtualRegister(virtualRegister);
 955 
 956     switch (info.registerFormat()) {
 957     case DataFormatNone: {
 958         if (edge-&gt;hasConstant()) {
 959             ASSERT(edge-&gt;isInt32Constant());
 960             GPRReg gpr = allocate();
 961             m_jit.move(MacroAssembler::Imm32(edge-&gt;asInt32()), gpr);
 962             m_gprs.retain(gpr, virtualRegister, SpillOrderConstant);
 963             info.fillInt32(*m_stream, gpr);
 964             returnFormat = DataFormatInt32;
 965             return gpr;
 966         }
 967 
 968         DataFormat spillFormat = info.spillFormat();
 969 
 970         ASSERT_UNUSED(spillFormat, (spillFormat &amp; DataFormatJS) || spillFormat == DataFormatInt32);
 971 
 972         // If we know this was spilled as an integer we can fill without checking.
 973         if (type &amp; ~SpecInt32Only)
 974             speculationCheck(BadType, JSValueSource(JITCompiler::addressFor(virtualRegister)), edge, m_jit.branch32(MacroAssembler::NotEqual, JITCompiler::tagFor(virtualRegister), TrustedImm32(JSValue::Int32Tag)));
 975 
 976         GPRReg gpr = allocate();
 977         m_jit.load32(JITCompiler::payloadFor(virtualRegister), gpr);
 978         m_gprs.retain(gpr, virtualRegister, SpillOrderSpilled);
 979         info.fillInt32(*m_stream, gpr);
 980         returnFormat = DataFormatInt32;
 981         return gpr;
 982     }
 983 
 984     case DataFormatJSInt32:
 985     case DataFormatJS: {
 986         // Check the value is an integer.
 987         GPRReg tagGPR = info.tagGPR();
 988         GPRReg payloadGPR = info.payloadGPR();
 989         m_gprs.lock(tagGPR);
 990         m_gprs.lock(payloadGPR);
 991         if (type &amp; ~SpecInt32Only)
 992             speculationCheck(BadType, JSValueRegs(tagGPR, payloadGPR), edge, m_jit.branchIfNotInt32(tagGPR));
 993         m_gprs.unlock(tagGPR);
 994         m_gprs.release(tagGPR);
 995         m_gprs.release(payloadGPR);
 996         m_gprs.retain(payloadGPR, virtualRegister, SpillOrderInteger);
 997         info.fillInt32(*m_stream, payloadGPR);
 998         // If !strict we&#39;re done, return.
 999         returnFormat = DataFormatInt32;
1000         return payloadGPR;
1001     }
1002 
1003     case DataFormatInt32: {
1004         GPRReg gpr = info.gpr();
1005         m_gprs.lock(gpr);
1006         returnFormat = DataFormatInt32;
1007         return gpr;
1008     }
1009 
1010     case DataFormatCell:
1011     case DataFormatBoolean:
1012     case DataFormatJSDouble:
1013     case DataFormatJSCell:
1014     case DataFormatJSBoolean:
1015     case DataFormatDouble:
1016     case DataFormatStorage:
1017     default:
1018         RELEASE_ASSERT_NOT_REACHED();
1019         return InvalidGPRReg;
1020     }
1021 }
1022 
1023 GPRReg SpeculativeJIT::fillSpeculateInt32(Edge edge, DataFormat&amp; returnFormat)
1024 {
1025     return fillSpeculateInt32Internal&lt;false&gt;(edge, returnFormat);
1026 }
1027 
1028 GPRReg SpeculativeJIT::fillSpeculateInt32Strict(Edge edge)
1029 {
1030     DataFormat mustBeDataFormatInt32;
1031     GPRReg result = fillSpeculateInt32Internal&lt;true&gt;(edge, mustBeDataFormatInt32);
1032     ASSERT(mustBeDataFormatInt32 == DataFormatInt32);
1033     return result;
1034 }
1035 
1036 FPRReg SpeculativeJIT::fillSpeculateDouble(Edge edge)
1037 {
1038     ASSERT(isDouble(edge.useKind()));
1039     ASSERT(edge-&gt;hasDoubleResult());
1040     VirtualRegister virtualRegister = edge-&gt;virtualRegister();
1041     GenerationInfo&amp; info = generationInfoFromVirtualRegister(virtualRegister);
1042 
1043     if (info.registerFormat() == DataFormatNone) {
1044 
1045         if (edge-&gt;hasConstant()) {
1046             RELEASE_ASSERT(edge-&gt;isNumberConstant());
1047             FPRReg fpr = fprAllocate();
1048             m_jit.loadDouble(TrustedImmPtr(m_jit.addressOfDoubleConstant(edge.node())), fpr);
1049             m_fprs.retain(fpr, virtualRegister, SpillOrderConstant);
1050             info.fillDouble(*m_stream, fpr);
1051             return fpr;
1052         }
1053 
1054         RELEASE_ASSERT(info.spillFormat() == DataFormatDouble);
1055         FPRReg fpr = fprAllocate();
1056         m_jit.loadDouble(JITCompiler::addressFor(virtualRegister), fpr);
1057         m_fprs.retain(fpr, virtualRegister, SpillOrderSpilled);
1058         info.fillDouble(*m_stream, fpr);
1059         return fpr;
1060     }
1061 
1062     RELEASE_ASSERT(info.registerFormat() == DataFormatDouble);
1063     FPRReg fpr = info.fpr();
1064     m_fprs.lock(fpr);
1065     return fpr;
1066 }
1067 
1068 GPRReg SpeculativeJIT::fillSpeculateCell(Edge edge)
1069 {
1070     AbstractValue&amp; value = m_state.forNode(edge);
1071     SpeculatedType type = value.m_type;
1072     ASSERT((edge.useKind() != KnownCellUse &amp;&amp; edge.useKind() != KnownStringUse) || !(value.m_type &amp; ~SpecCell));
1073 
1074     m_interpreter.filter(value, SpecCell);
1075     if (value.isClear()) {
1076         terminateSpeculativeExecution(Uncountable, JSValueRegs(), 0);
1077         return allocate();
1078     }
1079 
1080     VirtualRegister virtualRegister = edge-&gt;virtualRegister();
1081     GenerationInfo&amp; info = generationInfoFromVirtualRegister(virtualRegister);
1082 
1083     switch (info.registerFormat()) {
1084     case DataFormatNone: {
1085         if (edge-&gt;hasConstant()) {
1086             GPRReg gpr = allocate();
1087             m_gprs.retain(gpr, virtualRegister, SpillOrderConstant);
1088             m_jit.move(TrustedImmPtr(edge-&gt;constant()), gpr);
1089             info.fillCell(*m_stream, gpr);
1090             return gpr;
1091         }
1092 
1093         ASSERT((info.spillFormat() &amp; DataFormatJS) || info.spillFormat() == DataFormatCell);
1094         if (type &amp; ~SpecCell) {
1095             speculationCheck(
1096                 BadType,
1097                 JSValueSource(JITCompiler::addressFor(virtualRegister)),
1098                 edge,
1099                 m_jit.branch32(
1100                     MacroAssembler::NotEqual,
1101                     JITCompiler::tagFor(virtualRegister),
1102                     TrustedImm32(JSValue::CellTag)));
1103         }
1104         GPRReg gpr = allocate();
1105         m_jit.load32(JITCompiler::payloadFor(virtualRegister), gpr);
1106         m_gprs.retain(gpr, virtualRegister, SpillOrderSpilled);
1107         info.fillCell(*m_stream, gpr);
1108         return gpr;
1109     }
1110 
1111     case DataFormatCell: {
1112         GPRReg gpr = info.gpr();
1113         m_gprs.lock(gpr);
1114         return gpr;
1115     }
1116 
1117     case DataFormatJSCell:
1118     case DataFormatJS: {
1119         GPRReg tagGPR = info.tagGPR();
1120         GPRReg payloadGPR = info.payloadGPR();
1121         m_gprs.lock(tagGPR);
1122         m_gprs.lock(payloadGPR);
1123         if (type &amp; ~SpecCell) {
1124             speculationCheck(
1125                 BadType, JSValueRegs(tagGPR, payloadGPR), edge,
1126                 m_jit.branchIfNotCell(info.jsValueRegs()));
1127         }
1128         m_gprs.unlock(tagGPR);
1129         m_gprs.release(tagGPR);
1130         m_gprs.release(payloadGPR);
1131         m_gprs.retain(payloadGPR, virtualRegister, SpillOrderCell);
1132         info.fillCell(*m_stream, payloadGPR);
1133         return payloadGPR;
1134     }
1135 
1136     case DataFormatJSInt32:
1137     case DataFormatInt32:
1138     case DataFormatJSDouble:
1139     case DataFormatJSBoolean:
1140     case DataFormatBoolean:
1141     case DataFormatDouble:
1142     case DataFormatStorage:
1143         RELEASE_ASSERT_NOT_REACHED();
1144 
1145     default:
1146         RELEASE_ASSERT_NOT_REACHED();
1147         return InvalidGPRReg;
1148     }
1149 }
1150 
1151 GPRReg SpeculativeJIT::fillSpeculateBoolean(Edge edge)
1152 {
1153     AbstractValue&amp; value = m_state.forNode(edge);
1154     SpeculatedType type = value.m_type;
1155     ASSERT(edge.useKind() != KnownBooleanUse || !(value.m_type &amp; ~SpecBoolean));
1156 
1157     m_interpreter.filter(value, SpecBoolean);
1158     if (value.isClear()) {
1159         terminateSpeculativeExecution(Uncountable, JSValueRegs(), 0);
1160         return allocate();
1161     }
1162 
1163     VirtualRegister virtualRegister = edge-&gt;virtualRegister();
1164     GenerationInfo&amp; info = generationInfoFromVirtualRegister(virtualRegister);
1165 
1166     switch (info.registerFormat()) {
1167     case DataFormatNone: {
1168         if (edge-&gt;hasConstant()) {
1169             JSValue jsValue = edge-&gt;asJSValue();
1170             GPRReg gpr = allocate();
1171             m_gprs.retain(gpr, virtualRegister, SpillOrderConstant);
1172             m_jit.move(MacroAssembler::TrustedImm32(jsValue.asBoolean()), gpr);
1173             info.fillBoolean(*m_stream, gpr);
1174             return gpr;
1175         }
1176 
1177         ASSERT((info.spillFormat() &amp; DataFormatJS) || info.spillFormat() == DataFormatBoolean);
1178 
1179         if (type &amp; ~SpecBoolean)
1180             speculationCheck(BadType, JSValueSource(JITCompiler::addressFor(virtualRegister)), edge, m_jit.branch32(MacroAssembler::NotEqual, JITCompiler::tagFor(virtualRegister), TrustedImm32(JSValue::BooleanTag)));
1181 
1182         GPRReg gpr = allocate();
1183         m_jit.load32(JITCompiler::payloadFor(virtualRegister), gpr);
1184         m_gprs.retain(gpr, virtualRegister, SpillOrderSpilled);
1185         info.fillBoolean(*m_stream, gpr);
1186         return gpr;
1187     }
1188 
1189     case DataFormatBoolean: {
1190         GPRReg gpr = info.gpr();
1191         m_gprs.lock(gpr);
1192         return gpr;
1193     }
1194 
1195     case DataFormatJSBoolean:
1196     case DataFormatJS: {
1197         GPRReg tagGPR = info.tagGPR();
1198         GPRReg payloadGPR = info.payloadGPR();
1199         m_gprs.lock(tagGPR);
1200         m_gprs.lock(payloadGPR);
1201         if (type &amp; ~SpecBoolean)
1202             speculationCheck(BadType, JSValueRegs(tagGPR, payloadGPR), edge, m_jit.branchIfNotBoolean(tagGPR, InvalidGPRReg));
1203 
1204         m_gprs.unlock(tagGPR);
1205         m_gprs.release(tagGPR);
1206         m_gprs.release(payloadGPR);
1207         m_gprs.retain(payloadGPR, virtualRegister, SpillOrderBoolean);
1208         info.fillBoolean(*m_stream, payloadGPR);
1209         return payloadGPR;
1210     }
1211 
1212     case DataFormatJSInt32:
1213     case DataFormatInt32:
1214     case DataFormatJSDouble:
1215     case DataFormatJSCell:
1216     case DataFormatCell:
1217     case DataFormatDouble:
1218     case DataFormatStorage:
1219         RELEASE_ASSERT_NOT_REACHED();
1220 
1221     default:
1222         RELEASE_ASSERT_NOT_REACHED();
1223         return InvalidGPRReg;
1224     }
1225 }
1226 
1227 void SpeculativeJIT::compileObjectStrictEquality(Edge objectChild, Edge otherChild)
1228 {
1229     SpeculateCellOperand op1(this, objectChild);
1230     JSValueOperand op2(this, otherChild);
1231 
1232     GPRReg op1GPR = op1.gpr();
1233     GPRReg op2GPR = op2.payloadGPR();
1234 
1235     DFG_TYPE_CHECK(JSValueSource::unboxedCell(op1GPR), objectChild, SpecObject, m_jit.branchIfNotObject(op1GPR));
1236 
1237     GPRTemporary resultPayload(this, Reuse, op1);
1238     GPRReg resultPayloadGPR = resultPayload.gpr();
1239 
1240     MacroAssembler::Jump op2CellJump = m_jit.branchIfCell(op2.jsValueRegs());
1241 
1242     m_jit.move(TrustedImm32(0), resultPayloadGPR);
1243     MacroAssembler::Jump op2NotCellJump = m_jit.jump();
1244 
1245     // At this point we know that we can perform a straight-forward equality comparison on pointer
1246     // values because we are doing strict equality.
1247     op2CellJump.link(&amp;m_jit);
1248     m_jit.compare32(MacroAssembler::Equal, op1GPR, op2GPR, resultPayloadGPR);
1249 
1250     op2NotCellJump.link(&amp;m_jit);
1251     booleanResult(resultPayloadGPR, m_currentNode);
1252 }
1253 
1254 void SpeculativeJIT::compilePeepHoleObjectStrictEquality(Edge objectChild, Edge otherChild, Node* branchNode)
1255 {
1256     BasicBlock* taken = branchNode-&gt;branchData()-&gt;taken.block;
1257     BasicBlock* notTaken = branchNode-&gt;branchData()-&gt;notTaken.block;
1258 
1259     SpeculateCellOperand op1(this, objectChild);
1260     JSValueOperand op2(this, otherChild);
1261 
1262     GPRReg op1GPR = op1.gpr();
1263     GPRReg op2GPR = op2.payloadGPR();
1264 
1265     DFG_TYPE_CHECK(JSValueSource::unboxedCell(op1GPR), objectChild, SpecObject, m_jit.branchIfNotObject(op1GPR));
1266 
1267     branch32(MacroAssembler::NotEqual, op2.tagGPR(), TrustedImm32(JSValue::CellTag), notTaken);
1268 
1269     if (taken == nextBlock()) {
1270         branch32(MacroAssembler::NotEqual, op1GPR, op2GPR, notTaken);
1271         jump(taken);
1272     } else {
1273         branch32(MacroAssembler::Equal, op1GPR, op2GPR, taken);
1274         jump(notTaken);
1275     }
1276 }
1277 
1278 void SpeculativeJIT::compileObjectToObjectOrOtherEquality(Edge leftChild, Edge rightChild)
1279 {
1280     SpeculateCellOperand op1(this, leftChild);
1281     JSValueOperand op2(this, rightChild, ManualOperandSpeculation);
1282     GPRTemporary result(this);
1283 
1284     GPRReg op1GPR = op1.gpr();
1285     GPRReg op2TagGPR = op2.tagGPR();
1286     GPRReg op2PayloadGPR = op2.payloadGPR();
1287     GPRReg resultGPR = result.gpr();
1288 
1289     bool masqueradesAsUndefinedWatchpointValid =
1290         masqueradesAsUndefinedWatchpointIsStillValid();
1291 
1292     if (masqueradesAsUndefinedWatchpointValid) {
1293         DFG_TYPE_CHECK(
1294             JSValueSource::unboxedCell(op1GPR), leftChild, SpecObject, m_jit.branchIfNotObject(op1GPR));
1295     } else {
1296         DFG_TYPE_CHECK(
1297             JSValueSource::unboxedCell(op1GPR), leftChild, SpecObject, m_jit.branchIfNotObject(op1GPR));
1298         speculationCheck(BadType, JSValueSource::unboxedCell(op1GPR), leftChild,
1299             m_jit.branchTest8(
1300                 MacroAssembler::NonZero,
1301                 MacroAssembler::Address(op1GPR, JSCell::typeInfoFlagsOffset()),
1302                 MacroAssembler::TrustedImm32(MasqueradesAsUndefined)));
1303     }
1304 
1305 
1306     // It seems that most of the time when programs do a == b where b may be either null/undefined
1307     // or an object, b is usually an object. Balance the branches to make that case fast.
1308     MacroAssembler::Jump rightNotCell = m_jit.branchIfNotCell(op2.jsValueRegs());
1309 
1310     // We know that within this branch, rightChild must be a cell.
1311     if (masqueradesAsUndefinedWatchpointValid) {
1312         DFG_TYPE_CHECK(
1313             JSValueRegs(op2TagGPR, op2PayloadGPR), rightChild, (~SpecCell) | SpecObject, m_jit.branchIfNotObject(op2PayloadGPR));
1314     } else {
1315         DFG_TYPE_CHECK(
1316             JSValueRegs(op2TagGPR, op2PayloadGPR), rightChild, (~SpecCell) | SpecObject, m_jit.branchIfNotObject(op2PayloadGPR));
1317         speculationCheck(BadType, JSValueRegs(op2TagGPR, op2PayloadGPR), rightChild,
1318             m_jit.branchTest8(
1319                 MacroAssembler::NonZero,
1320                 MacroAssembler::Address(op2PayloadGPR, JSCell::typeInfoFlagsOffset()),
1321                 MacroAssembler::TrustedImm32(MasqueradesAsUndefined)));
1322     }
1323 
1324     // At this point we know that we can perform a straight-forward equality comparison on pointer
1325     // values because both left and right are pointers to objects that have no special equality
1326     // protocols.
1327     MacroAssembler::Jump falseCase = m_jit.branchPtr(MacroAssembler::NotEqual, op1GPR, op2PayloadGPR);
1328     MacroAssembler::Jump trueCase = m_jit.jump();
1329 
1330     rightNotCell.link(&amp;m_jit);
1331 
1332     // We know that within this branch, rightChild must not be a cell. Check if that is enough to
1333     // prove that it is either null or undefined.
1334     if (needsTypeCheck(rightChild, SpecCell | SpecOther)) {
1335         m_jit.or32(TrustedImm32(1), op2TagGPR, resultGPR);
1336 
1337         typeCheck(
1338             JSValueRegs(op2TagGPR, op2PayloadGPR), rightChild, SpecCell | SpecOther,
1339             m_jit.branch32(
1340                 MacroAssembler::NotEqual, resultGPR,
1341                 MacroAssembler::TrustedImm32(JSValue::NullTag)));
1342     }
1343 
1344     falseCase.link(&amp;m_jit);
1345     m_jit.move(TrustedImm32(0), resultGPR);
1346     MacroAssembler::Jump done = m_jit.jump();
1347     trueCase.link(&amp;m_jit);
1348     m_jit.move(TrustedImm32(1), resultGPR);
1349     done.link(&amp;m_jit);
1350 
1351     booleanResult(resultGPR, m_currentNode);
1352 }
1353 
1354 void SpeculativeJIT::compilePeepHoleObjectToObjectOrOtherEquality(Edge leftChild, Edge rightChild, Node* branchNode)
1355 {
1356     BasicBlock* taken = branchNode-&gt;branchData()-&gt;taken.block;
1357     BasicBlock* notTaken = branchNode-&gt;branchData()-&gt;notTaken.block;
1358 
1359     SpeculateCellOperand op1(this, leftChild);
1360     JSValueOperand op2(this, rightChild, ManualOperandSpeculation);
1361     GPRTemporary result(this);
1362 
1363     GPRReg op1GPR = op1.gpr();
1364     GPRReg op2TagGPR = op2.tagGPR();
1365     GPRReg op2PayloadGPR = op2.payloadGPR();
1366     GPRReg resultGPR = result.gpr();
1367 
1368     bool masqueradesAsUndefinedWatchpointValid =
1369         masqueradesAsUndefinedWatchpointIsStillValid();
1370 
1371     if (masqueradesAsUndefinedWatchpointValid) {
1372         DFG_TYPE_CHECK(
1373             JSValueSource::unboxedCell(op1GPR), leftChild, SpecObject, m_jit.branchIfNotObject(op1GPR));
1374     } else {
1375         DFG_TYPE_CHECK(
1376             JSValueSource::unboxedCell(op1GPR), leftChild, SpecObject, m_jit.branchIfNotObject(op1GPR));
1377         speculationCheck(BadType, JSValueSource::unboxedCell(op1GPR), leftChild,
1378             m_jit.branchTest8(
1379                 MacroAssembler::NonZero,
1380                 MacroAssembler::Address(op1GPR, JSCell::typeInfoFlagsOffset()),
1381                 MacroAssembler::TrustedImm32(MasqueradesAsUndefined)));
1382     }
1383 
1384     // It seems that most of the time when programs do a == b where b may be either null/undefined
1385     // or an object, b is usually an object. Balance the branches to make that case fast.
1386     MacroAssembler::Jump rightNotCell = m_jit.branchIfNotCell(op2.jsValueRegs());
1387 
1388     // We know that within this branch, rightChild must be a cell.
1389     if (masqueradesAsUndefinedWatchpointValid) {
1390         DFG_TYPE_CHECK(
1391             JSValueRegs(op2TagGPR, op2PayloadGPR), rightChild, (~SpecCell) | SpecObject,
1392             m_jit.branchIfNotObject(op2PayloadGPR));
1393     } else {
1394         DFG_TYPE_CHECK(
1395             JSValueRegs(op2TagGPR, op2PayloadGPR), rightChild, (~SpecCell) | SpecObject,
1396             m_jit.branchIfNotObject(op2PayloadGPR));
1397         speculationCheck(BadType, JSValueRegs(op2TagGPR, op2PayloadGPR), rightChild,
1398             m_jit.branchTest8(
1399                 MacroAssembler::NonZero,
1400                 MacroAssembler::Address(op2PayloadGPR, JSCell::typeInfoFlagsOffset()),
1401                 MacroAssembler::TrustedImm32(MasqueradesAsUndefined)));
1402     }
1403 
1404     // At this point we know that we can perform a straight-forward equality comparison on pointer
1405     // values because both left and right are pointers to objects that have no special equality
1406     // protocols.
1407     branch32(MacroAssembler::Equal, op1GPR, op2PayloadGPR, taken);
1408 
1409     // We know that within this branch, rightChild must not be a cell. Check if that is enough to
1410     // prove that it is either null or undefined.
1411     if (!needsTypeCheck(rightChild, SpecCell | SpecOther))
1412         rightNotCell.link(&amp;m_jit);
1413     else {
1414         jump(notTaken, ForceJump);
1415 
1416         rightNotCell.link(&amp;m_jit);
1417         m_jit.or32(TrustedImm32(1), op2TagGPR, resultGPR);
1418 
1419         typeCheck(
1420             JSValueRegs(op2TagGPR, op2PayloadGPR), rightChild, SpecCell | SpecOther,
1421             m_jit.branch32(
1422                 MacroAssembler::NotEqual, resultGPR,
1423                 MacroAssembler::TrustedImm32(JSValue::NullTag)));
1424     }
1425 
1426     jump(notTaken);
1427 }
1428 
1429 void SpeculativeJIT::compileSymbolUntypedEquality(Node* node, Edge symbolEdge, Edge untypedEdge)
1430 {
1431     SpeculateCellOperand symbol(this, symbolEdge);
1432     JSValueOperand untyped(this, untypedEdge);
1433 
1434     GPRReg symbolGPR = symbol.gpr();
1435     GPRReg untypedGPR = untyped.payloadGPR();
1436 
1437     speculateSymbol(symbolEdge, symbolGPR);
1438 
1439     GPRTemporary resultPayload(this, Reuse, symbol);
1440     GPRReg resultPayloadGPR = resultPayload.gpr();
1441 
1442     MacroAssembler::Jump untypedCellJump = m_jit.branchIfCell(untyped.jsValueRegs());
1443 
1444     m_jit.move(TrustedImm32(0), resultPayloadGPR);
1445     MacroAssembler::Jump untypedNotCellJump = m_jit.jump();
1446 
1447     // At this point we know that we can perform a straight-forward equality comparison on pointer
1448     // values because we are doing strict equality.
1449     untypedCellJump.link(&amp;m_jit);
1450     m_jit.compare32(MacroAssembler::Equal, symbolGPR, untypedGPR, resultPayloadGPR);
1451 
1452     untypedNotCellJump.link(&amp;m_jit);
1453     booleanResult(resultPayloadGPR, node);
1454 }
1455 
1456 void SpeculativeJIT::compileObjectOrOtherLogicalNot(Edge nodeUse)
1457 {
1458     JSValueOperand value(this, nodeUse, ManualOperandSpeculation);
1459     GPRTemporary resultPayload(this);
1460     GPRReg valueTagGPR = value.tagGPR();
1461     GPRReg valuePayloadGPR = value.payloadGPR();
1462     GPRReg resultPayloadGPR = resultPayload.gpr();
1463     GPRTemporary structure;
1464     GPRReg structureGPR = InvalidGPRReg;
1465 
1466     bool masqueradesAsUndefinedWatchpointValid =
1467         masqueradesAsUndefinedWatchpointIsStillValid();
1468 
1469     if (!masqueradesAsUndefinedWatchpointValid) {
1470         // The masquerades as undefined case will use the structure register, so allocate it here.
1471         // Do this at the top of the function to avoid branching around a register allocation.
1472         GPRTemporary realStructure(this);
1473         structure.adopt(realStructure);
1474         structureGPR = structure.gpr();
1475     }
1476 
1477     MacroAssembler::Jump notCell = m_jit.branchIfNotCell(value.jsValueRegs());
1478     if (masqueradesAsUndefinedWatchpointValid) {
1479         DFG_TYPE_CHECK(
1480             JSValueRegs(valueTagGPR, valuePayloadGPR), nodeUse, (~SpecCell) | SpecObject,
1481             m_jit.branchIfNotObject(valuePayloadGPR));
1482     } else {
1483         DFG_TYPE_CHECK(
1484             JSValueRegs(valueTagGPR, valuePayloadGPR), nodeUse, (~SpecCell) | SpecObject,
1485             m_jit.branchIfNotObject(valuePayloadGPR));
1486 
1487         MacroAssembler::Jump isNotMasqueradesAsUndefined =
1488             m_jit.branchTest8(
1489                 MacroAssembler::Zero,
1490                 MacroAssembler::Address(valuePayloadGPR, JSCell::typeInfoFlagsOffset()),
1491                 MacroAssembler::TrustedImm32(MasqueradesAsUndefined));
1492 
1493         m_jit.loadPtr(MacroAssembler::Address(valuePayloadGPR, JSCell::structureIDOffset()), structureGPR);
1494         speculationCheck(BadType, JSValueRegs(valueTagGPR, valuePayloadGPR), nodeUse,
1495             m_jit.branchPtr(
1496                 MacroAssembler::Equal,
1497                 MacroAssembler::Address(structureGPR, Structure::globalObjectOffset()),
1498                 TrustedImmPtr::weakPointer(m_jit.graph(), m_jit.graph().globalObjectFor(m_currentNode-&gt;origin.semantic))));
1499 
1500         isNotMasqueradesAsUndefined.link(&amp;m_jit);
1501     }
1502     m_jit.move(TrustedImm32(0), resultPayloadGPR);
1503     MacroAssembler::Jump done = m_jit.jump();
1504 
1505     notCell.link(&amp;m_jit);
1506 
1507     COMPILE_ASSERT((JSValue::UndefinedTag | 1) == JSValue::NullTag, UndefinedTag_OR_1_EQUALS_NullTag);
1508     if (needsTypeCheck(nodeUse, SpecCell | SpecOther)) {
1509         m_jit.or32(TrustedImm32(1), valueTagGPR, resultPayloadGPR);
1510         typeCheck(
1511             JSValueRegs(valueTagGPR, valuePayloadGPR), nodeUse, SpecCell | SpecOther,
1512             m_jit.branch32(
1513                 MacroAssembler::NotEqual,
1514                 resultPayloadGPR,
1515                 TrustedImm32(JSValue::NullTag)));
1516     }
1517     m_jit.move(TrustedImm32(1), resultPayloadGPR);
1518 
1519     done.link(&amp;m_jit);
1520 
1521     booleanResult(resultPayloadGPR, m_currentNode);
1522 }
1523 
1524 void SpeculativeJIT::compileLogicalNot(Node* node)
1525 {
1526     switch (node-&gt;child1().useKind()) {
1527     case BooleanUse:
1528     case KnownBooleanUse: {
1529         SpeculateBooleanOperand value(this, node-&gt;child1());
1530         GPRTemporary result(this, Reuse, value);
1531         m_jit.xor32(TrustedImm32(1), value.gpr(), result.gpr());
1532         booleanResult(result.gpr(), node);
1533         return;
1534     }
1535 
1536     case ObjectOrOtherUse: {
1537         compileObjectOrOtherLogicalNot(node-&gt;child1());
1538         return;
1539     }
1540 
1541     case Int32Use: {
1542         SpeculateInt32Operand value(this, node-&gt;child1());
1543         GPRTemporary resultPayload(this, Reuse, value);
1544         m_jit.compare32(MacroAssembler::Equal, value.gpr(), MacroAssembler::TrustedImm32(0), resultPayload.gpr());
1545         booleanResult(resultPayload.gpr(), node);
1546         return;
1547     }
1548 
1549     case DoubleRepUse: {
1550         SpeculateDoubleOperand value(this, node-&gt;child1());
1551         FPRTemporary scratch(this);
1552         GPRTemporary resultPayload(this);
1553         m_jit.move(TrustedImm32(0), resultPayload.gpr());
1554         MacroAssembler::Jump nonZero = m_jit.branchDoubleNonZero(value.fpr(), scratch.fpr());
1555         m_jit.move(TrustedImm32(1), resultPayload.gpr());
1556         nonZero.link(&amp;m_jit);
1557         booleanResult(resultPayload.gpr(), node);
1558         return;
1559     }
1560 
1561     case UntypedUse: {
1562         JSValueOperand arg1(this, node-&gt;child1());
1563         GPRTemporary result(this);
1564         GPRTemporary temp(this);
1565         FPRTemporary valueFPR(this);
1566         FPRTemporary tempFPR(this);
1567 
1568         GPRReg resultGPR = result.gpr();
1569 
1570         bool shouldCheckMasqueradesAsUndefined = !masqueradesAsUndefinedWatchpointIsStillValid();
1571         JSGlobalObject* globalObject = m_jit.graph().globalObjectFor(node-&gt;origin.semantic);
1572         bool negateResult = true;
<a name="9" id="anc9"></a><span class="line-modified">1573         m_jit.emitConvertValueToBoolean(vm(), arg1.jsValueRegs(), resultGPR, temp.gpr(), valueFPR.fpr(), tempFPR.fpr(), shouldCheckMasqueradesAsUndefined, globalObject, negateResult);</span>
1574         booleanResult(resultGPR, node);
1575         return;
1576     }
1577     case StringUse:
1578         return compileStringZeroLength(node);
1579 
1580     case StringOrOtherUse:
1581         return compileLogicalNotStringOrOther(node);
1582 
1583     default:
1584         RELEASE_ASSERT_NOT_REACHED();
1585         break;
1586     }
1587 }
1588 
1589 void SpeculativeJIT::emitObjectOrOtherBranch(Edge nodeUse, BasicBlock* taken, BasicBlock* notTaken)
1590 {
1591     JSValueOperand value(this, nodeUse, ManualOperandSpeculation);
1592     GPRTemporary scratch(this);
1593     GPRReg valueTagGPR = value.tagGPR();
1594     GPRReg valuePayloadGPR = value.payloadGPR();
1595     GPRReg scratchGPR = scratch.gpr();
1596 
1597     MacroAssembler::Jump notCell = m_jit.branchIfNotCell(value.jsValueRegs());
1598     if (masqueradesAsUndefinedWatchpointIsStillValid()) {
1599         DFG_TYPE_CHECK(
1600             JSValueRegs(valueTagGPR, valuePayloadGPR), nodeUse, (~SpecCell) | SpecObject,
1601             m_jit.branchIfNotObject(valuePayloadGPR));
1602     } else {
1603         DFG_TYPE_CHECK(
1604             JSValueRegs(valueTagGPR, valuePayloadGPR), nodeUse, (~SpecCell) | SpecObject,
1605             m_jit.branchIfNotObject(valuePayloadGPR));
1606 
1607         JITCompiler::Jump isNotMasqueradesAsUndefined = m_jit.branchTest8(
1608             JITCompiler::Zero,
1609             MacroAssembler::Address(valuePayloadGPR, JSCell::typeInfoFlagsOffset()),
1610             TrustedImm32(MasqueradesAsUndefined));
1611 
1612         m_jit.loadPtr(MacroAssembler::Address(valuePayloadGPR, JSCell::structureIDOffset()), scratchGPR);
1613         speculationCheck(BadType, JSValueRegs(valueTagGPR, valuePayloadGPR), nodeUse,
1614             m_jit.branchPtr(
1615                 MacroAssembler::Equal,
1616                 MacroAssembler::Address(scratchGPR, Structure::globalObjectOffset()),
1617                 TrustedImmPtr::weakPointer(m_jit.graph(), m_jit.graph().globalObjectFor(m_currentNode-&gt;origin.semantic))));
1618 
1619         isNotMasqueradesAsUndefined.link(&amp;m_jit);
1620     }
1621     jump(taken, ForceJump);
1622 
1623     notCell.link(&amp;m_jit);
1624 
1625     COMPILE_ASSERT((JSValue::UndefinedTag | 1) == JSValue::NullTag, UndefinedTag_OR_1_EQUALS_NullTag);
1626     if (needsTypeCheck(nodeUse, SpecCell | SpecOther)) {
1627         m_jit.or32(TrustedImm32(1), valueTagGPR, scratchGPR);
1628         typeCheck(
1629             JSValueRegs(valueTagGPR, valuePayloadGPR), nodeUse, SpecCell | SpecOther,
1630             m_jit.branch32(MacroAssembler::NotEqual, scratchGPR, TrustedImm32(JSValue::NullTag)));
1631     }
1632 
1633     jump(notTaken);
1634 
1635     noResult(m_currentNode);
1636 }
1637 
1638 void SpeculativeJIT::emitBranch(Node* node)
1639 {
1640     BasicBlock* taken = node-&gt;branchData()-&gt;taken.block;
1641     BasicBlock* notTaken = node-&gt;branchData()-&gt;notTaken.block;
1642 
1643     switch (node-&gt;child1().useKind()) {
1644     case BooleanUse:
1645     case KnownBooleanUse: {
1646         SpeculateBooleanOperand value(this, node-&gt;child1());
1647         MacroAssembler::ResultCondition condition = MacroAssembler::NonZero;
1648 
1649         if (taken == nextBlock()) {
1650             condition = MacroAssembler::Zero;
1651             BasicBlock* tmp = taken;
1652             taken = notTaken;
1653             notTaken = tmp;
1654         }
1655 
1656         branchTest32(condition, value.gpr(), TrustedImm32(1), taken);
1657         jump(notTaken);
1658 
1659         noResult(node);
1660         return;
1661     }
1662 
1663     case ObjectOrOtherUse: {
1664         emitObjectOrOtherBranch(node-&gt;child1(), taken, notTaken);
1665         return;
1666     }
1667 
1668     case StringUse: {
1669         emitStringBranch(node-&gt;child1(), taken, notTaken);
1670         return;
1671     }
1672 
1673     case StringOrOtherUse: {
1674         emitStringOrOtherBranch(node-&gt;child1(), taken, notTaken);
1675         return;
1676     }
1677 
1678     case DoubleRepUse:
1679     case Int32Use: {
1680         if (node-&gt;child1().useKind() == Int32Use) {
1681             bool invert = false;
1682 
1683             if (taken == nextBlock()) {
1684                 invert = true;
1685                 BasicBlock* tmp = taken;
1686                 taken = notTaken;
1687                 notTaken = tmp;
1688             }
1689 
1690             SpeculateInt32Operand value(this, node-&gt;child1());
1691             branchTest32(invert ? MacroAssembler::Zero : MacroAssembler::NonZero, value.gpr(), taken);
1692         } else {
1693             SpeculateDoubleOperand value(this, node-&gt;child1());
1694             FPRTemporary scratch(this);
1695             branchDoubleNonZero(value.fpr(), scratch.fpr(), taken);
1696         }
1697 
1698         jump(notTaken);
1699 
1700         noResult(node);
1701         return;
1702     }
1703 
1704     case UntypedUse: {
1705         JSValueOperand value(this, node-&gt;child1());
1706         FPRTemporary valueFPR(this);
1707         FPRTemporary tempFPR(this);
1708         GPRTemporary result(this);
1709         GPRTemporary temp(this);
1710 
1711         JSValueRegs valueRegs = value.jsValueRegs();
1712         GPRReg resultGPR = result.gpr();
1713 
1714         use(node-&gt;child1());
1715 
1716         bool shouldCheckMasqueradesAsUndefined = !masqueradesAsUndefinedWatchpointIsStillValid();
1717         JSGlobalObject* globalObject = m_jit.graph().globalObjectFor(node-&gt;origin.semantic);
<a name="10" id="anc10"></a><span class="line-modified">1718         auto falsey = m_jit.branchIfFalsey(vm(), valueRegs, resultGPR, temp.gpr(), valueFPR.fpr(), tempFPR.fpr(), shouldCheckMasqueradesAsUndefined, globalObject);</span>
1719         addBranch(falsey, notTaken);
1720         jump(taken, ForceJump);
1721 
1722         noResult(node, UseChildrenCalledExplicitly);
1723         return;
1724     }
1725 
1726     default:
1727         RELEASE_ASSERT_NOT_REACHED();
1728         break;
1729     }
1730 }
1731 
1732 template&lt;typename BaseOperandType, typename PropertyOperandType, typename ValueOperandType, typename TagType&gt;
1733 void SpeculativeJIT::compileContiguousPutByVal(Node* node, BaseOperandType&amp; base, PropertyOperandType&amp; property, ValueOperandType&amp; value, GPRReg valuePayloadReg, TagType valueTag)
1734 {
1735     Edge child4 = m_jit.graph().varArgChild(node, 3);
1736 
1737     ArrayMode arrayMode = node-&gt;arrayMode();
1738 
1739     GPRReg baseReg = base.gpr();
1740     GPRReg propertyReg = property.gpr();
1741 
1742     StorageOperand storage(this, child4);
1743     GPRReg storageReg = storage.gpr();
1744 
1745     if (node-&gt;op() == PutByValAlias) {
1746         // Store the value to the array.
1747         GPRReg propertyReg = property.gpr();
1748         m_jit.store32(valueTag, MacroAssembler::BaseIndex(storageReg, propertyReg, MacroAssembler::TimesEight, OBJECT_OFFSETOF(JSValue, u.asBits.tag)));
1749         m_jit.store32(valuePayloadReg, MacroAssembler::BaseIndex(storageReg, propertyReg, MacroAssembler::TimesEight, OBJECT_OFFSETOF(JSValue, u.asBits.payload)));
1750 
1751         noResult(node);
1752         return;
1753     }
1754 
1755     MacroAssembler::Jump slowCase;
1756 
1757     if (arrayMode.isInBounds()) {
1758         speculationCheck(
1759             OutOfBounds, JSValueRegs(), 0,
1760             m_jit.branch32(MacroAssembler::AboveOrEqual, propertyReg, MacroAssembler::Address(storageReg, Butterfly::offsetOfPublicLength())));
1761     } else {
1762         MacroAssembler::Jump inBounds = m_jit.branch32(MacroAssembler::Below, propertyReg, MacroAssembler::Address(storageReg, Butterfly::offsetOfPublicLength()));
1763 
1764         slowCase = m_jit.branch32(MacroAssembler::AboveOrEqual, propertyReg, MacroAssembler::Address(storageReg, Butterfly::offsetOfVectorLength()));
1765 
1766         if (!arrayMode.isOutOfBounds())
1767             speculationCheck(OutOfBounds, JSValueRegs(), 0, slowCase);
1768 
1769         m_jit.add32(TrustedImm32(1), propertyReg);
1770         m_jit.store32(propertyReg, MacroAssembler::Address(storageReg, Butterfly::offsetOfPublicLength()));
1771         m_jit.sub32(TrustedImm32(1), propertyReg);
1772 
1773         inBounds.link(&amp;m_jit);
1774     }
1775 
1776     m_jit.store32(valueTag, MacroAssembler::BaseIndex(storageReg, propertyReg, MacroAssembler::TimesEight, OBJECT_OFFSETOF(JSValue, u.asBits.tag)));
1777     m_jit.store32(valuePayloadReg, MacroAssembler::BaseIndex(storageReg, propertyReg, MacroAssembler::TimesEight, OBJECT_OFFSETOF(JSValue, u.asBits.payload)));
1778 
1779     base.use();
1780     property.use();
1781     value.use();
1782     storage.use();
1783 
1784     if (arrayMode.isOutOfBounds()) {
1785         if (node-&gt;op() == PutByValDirect) {
1786             addSlowPathGenerator(slowPathCall(
1787                 slowCase, this,
<a name="11" id="anc11"></a><span class="line-modified">1788                 m_jit.isStrictModeFor(node-&gt;origin.semantic) ? operationPutByValDirectBeyondArrayBoundsStrict : operationPutByValDirectBeyondArrayBoundsNonStrict,</span>
1789                 NoResult, baseReg, propertyReg, JSValueRegs(valueTag, valuePayloadReg)));
1790         } else {
1791             addSlowPathGenerator(slowPathCall(
1792                 slowCase, this,
<a name="12" id="anc12"></a><span class="line-modified">1793                 m_jit.isStrictModeFor(node-&gt;origin.semantic) ? operationPutByValBeyondArrayBoundsStrict : operationPutByValBeyondArrayBoundsNonStrict,</span>
1794                 NoResult, baseReg, propertyReg, JSValueRegs(valueTag, valuePayloadReg)));
1795         }
1796     }
1797 
1798     noResult(node, UseChildrenCalledExplicitly);
1799 }
1800 
1801 void SpeculativeJIT::compile(Node* node)
1802 {
1803     NodeType op = node-&gt;op();
1804 
1805 #if ENABLE(DFG_REGISTER_ALLOCATION_VALIDATION)
1806     m_jit.clearRegisterAllocationOffsets();
1807 #endif
1808 
1809     switch (op) {
1810     case JSConstant:
1811     case DoubleConstant:
1812     case PhantomDirectArguments:
1813     case PhantomClonedArguments:
1814         initConstantInfo(node);
1815         break;
1816 
1817     case LazyJSConstant:
1818         compileLazyJSConstant(node);
1819         break;
1820 
1821     case Identity: {
1822         compileIdentity(node);
1823         break;
1824     }
1825 
1826     case GetLocal: {
1827         AbstractValue&amp; value = m_state.operand(node-&gt;local());
1828 
1829         // If the CFA is tracking this variable and it found that the variable
1830         // cannot have been assigned, then don&#39;t attempt to proceed.
1831         if (value.isClear()) {
1832             m_compileOkay = false;
1833             break;
1834         }
1835 
1836         switch (node-&gt;variableAccessData()-&gt;flushFormat()) {
1837         case FlushedDouble: {
1838             FPRTemporary result(this);
1839             m_jit.loadDouble(JITCompiler::addressFor(node-&gt;machineLocal()), result.fpr());
1840             VirtualRegister virtualRegister = node-&gt;virtualRegister();
1841             m_fprs.retain(result.fpr(), virtualRegister, SpillOrderDouble);
1842             generationInfoFromVirtualRegister(virtualRegister).initDouble(node, node-&gt;refCount(), result.fpr());
1843             break;
1844         }
1845 
1846         case FlushedInt32: {
1847             GPRTemporary result(this);
1848             m_jit.load32(JITCompiler::payloadFor(node-&gt;machineLocal()), result.gpr());
1849 
1850             // Like int32Result, but don&#39;t useChildren - our children are phi nodes,
1851             // and don&#39;t represent values within this dataflow with virtual registers.
1852             VirtualRegister virtualRegister = node-&gt;virtualRegister();
1853             m_gprs.retain(result.gpr(), virtualRegister, SpillOrderInteger);
1854             generationInfoFromVirtualRegister(virtualRegister).initInt32(node, node-&gt;refCount(), result.gpr());
1855             break;
1856         }
1857 
1858         case FlushedCell: {
1859             GPRTemporary result(this);
1860             m_jit.load32(JITCompiler::payloadFor(node-&gt;machineLocal()), result.gpr());
1861 
1862             // Like cellResult, but don&#39;t useChildren - our children are phi nodes,
1863             // and don&#39;t represent values within this dataflow with virtual registers.
1864             VirtualRegister virtualRegister = node-&gt;virtualRegister();
1865             m_gprs.retain(result.gpr(), virtualRegister, SpillOrderCell);
1866             generationInfoFromVirtualRegister(virtualRegister).initCell(node, node-&gt;refCount(), result.gpr());
1867             break;
1868         }
1869 
1870         case FlushedBoolean: {
1871             GPRTemporary result(this);
1872             m_jit.load32(JITCompiler::payloadFor(node-&gt;machineLocal()), result.gpr());
1873 
1874             // Like booleanResult, but don&#39;t useChildren - our children are phi nodes,
1875             // and don&#39;t represent values within this dataflow with virtual registers.
1876             VirtualRegister virtualRegister = node-&gt;virtualRegister();
1877             m_gprs.retain(result.gpr(), virtualRegister, SpillOrderBoolean);
1878             generationInfoFromVirtualRegister(virtualRegister).initBoolean(node, node-&gt;refCount(), result.gpr());
1879             break;
1880         }
1881 
1882         case FlushedJSValue: {
1883             GPRTemporary result(this);
1884             GPRTemporary tag(this);
1885             m_jit.load32(JITCompiler::payloadFor(node-&gt;machineLocal()), result.gpr());
1886             m_jit.load32(JITCompiler::tagFor(node-&gt;machineLocal()), tag.gpr());
1887 
1888             // Like jsValueResult, but don&#39;t useChildren - our children are phi nodes,
1889             // and don&#39;t represent values within this dataflow with virtual registers.
1890             VirtualRegister virtualRegister = node-&gt;virtualRegister();
1891             m_gprs.retain(result.gpr(), virtualRegister, SpillOrderJS);
1892             m_gprs.retain(tag.gpr(), virtualRegister, SpillOrderJS);
1893 
1894             generationInfoFromVirtualRegister(virtualRegister).initJSValue(node, node-&gt;refCount(), tag.gpr(), result.gpr(), DataFormatJS);
1895             break;
1896         }
1897 
1898         default:
1899             RELEASE_ASSERT_NOT_REACHED();
1900         }
1901         break;
1902     }
1903 
1904     case MovHint: {
1905         compileMovHint(m_currentNode);
1906         noResult(node);
1907         break;
1908     }
1909 
1910     case ZombieHint: {
1911         recordSetLocal(m_currentNode-&gt;unlinkedLocal(), VirtualRegister(), DataFormatDead);
1912         noResult(node);
1913         break;
1914     }
1915 
1916     case ExitOK: {
1917         noResult(node);
1918         break;
1919     }
1920 
1921     case SetLocal: {
1922         switch (node-&gt;variableAccessData()-&gt;flushFormat()) {
1923         case FlushedDouble: {
1924             SpeculateDoubleOperand value(this, node-&gt;child1());
1925             m_jit.storeDouble(value.fpr(), JITCompiler::addressFor(node-&gt;machineLocal()));
1926             noResult(node);
1927             // Indicate that it&#39;s no longer necessary to retrieve the value of
1928             // this bytecode variable from registers or other locations in the stack,
1929             // but that it is stored as a double.
1930             recordSetLocal(DataFormatDouble);
1931             break;
1932         }
1933 
1934         case FlushedInt32: {
1935             SpeculateInt32Operand value(this, node-&gt;child1());
1936             m_jit.store32(value.gpr(), JITCompiler::payloadFor(node-&gt;machineLocal()));
1937             noResult(node);
1938             recordSetLocal(DataFormatInt32);
1939             break;
1940         }
1941 
1942         case FlushedCell: {
1943             SpeculateCellOperand cell(this, node-&gt;child1());
1944             GPRReg cellGPR = cell.gpr();
1945             m_jit.storePtr(cellGPR, JITCompiler::payloadFor(node-&gt;machineLocal()));
1946             noResult(node);
1947             recordSetLocal(DataFormatCell);
1948             break;
1949         }
1950 
1951         case FlushedBoolean: {
1952             SpeculateBooleanOperand value(this, node-&gt;child1());
1953             m_jit.store32(value.gpr(), JITCompiler::payloadFor(node-&gt;machineLocal()));
1954             noResult(node);
1955             recordSetLocal(DataFormatBoolean);
1956             break;
1957         }
1958 
1959         case FlushedJSValue: {
1960             JSValueOperand value(this, node-&gt;child1());
1961             m_jit.store32(value.payloadGPR(), JITCompiler::payloadFor(node-&gt;machineLocal()));
1962             m_jit.store32(value.tagGPR(), JITCompiler::tagFor(node-&gt;machineLocal()));
1963             noResult(node);
1964             recordSetLocal(dataFormatFor(node-&gt;variableAccessData()-&gt;flushFormat()));
1965             break;
1966         }
1967 
1968         default:
1969             RELEASE_ASSERT_NOT_REACHED();
1970             break;
1971         }
1972         break;
1973     }
1974 
<a name="13" id="anc13"></a><span class="line-modified">1975     case SetArgumentDefinitely:</span>
<span class="line-added">1976     case SetArgumentMaybe:</span>
1977         // This is a no-op; it just marks the fact that the argument is being used.
1978         // But it may be profitable to use this as a hook to run speculation checks
1979         // on arguments, thereby allowing us to trivially eliminate such checks if
1980         // the argument is not used.
1981         recordSetLocal(dataFormatFor(node-&gt;variableAccessData()-&gt;flushFormat()));
1982         break;
1983 
1984     case ValueBitOr:
1985     case ValueBitAnd:
1986     case ValueBitXor:
1987         compileValueBitwiseOp(node);
1988         break;
1989 
1990     case ArithBitAnd:
1991     case ArithBitOr:
1992     case ArithBitXor:
1993         compileBitwiseOp(node);
1994         break;
1995 
<a name="14" id="anc14"></a><span class="line-added">1996     case ValueBitNot:</span>
<span class="line-added">1997         compileValueBitNot(node);</span>
<span class="line-added">1998         break;</span>
<span class="line-added">1999 </span>
2000     case ArithBitNot:
2001         compileBitwiseNot(node);
2002         break;
2003 
<a name="15" id="anc15"></a><span class="line-added">2004     case ValueBitLShift:</span>
<span class="line-added">2005         compileValueLShiftOp(node);</span>
<span class="line-added">2006         break;</span>
<span class="line-added">2007 </span>
2008     case BitRShift:
<a name="16" id="anc16"></a><span class="line-modified">2009     case ArithBitLShift:</span>
2010     case BitURShift:
2011         compileShiftOp(node);
2012         break;
2013 
2014     case UInt32ToNumber: {
2015         compileUInt32ToNumber(node);
2016         break;
2017     }
2018 
2019     case DoubleAsInt32: {
2020         compileDoubleAsInt32(node);
2021         break;
2022     }
2023 
2024     case ValueToInt32: {
2025         compileValueToInt32(node);
2026         break;
2027     }
2028 
2029     case DoubleRep: {
2030         compileDoubleRep(node);
2031         break;
2032     }
2033 
2034     case ValueRep: {
2035         compileValueRep(node);
2036         break;
2037     }
2038 
2039     case ValueNegate:
2040         compileValueNegate(node);
2041         break;
2042 
2043     case ValueAdd:
2044         compileValueAdd(node);
2045         break;
2046 
2047     case ValueSub:
2048         compileValueSub(node);
2049         break;
2050 
2051     case StrCat: {
2052         compileStrCat(node);
2053         break;
2054     }
2055 
2056     case ArithAdd:
2057         compileArithAdd(node);
2058         break;
2059 
2060     case ArithClz32:
2061         compileArithClz32(node);
2062         break;
2063 
2064     case MakeRope:
2065         compileMakeRope(node);
2066         break;
2067 
2068     case ArithSub:
2069         compileArithSub(node);
2070         break;
2071 
2072     case ArithNegate:
2073         compileArithNegate(node);
2074         break;
2075 
2076     case ArithMul:
2077         compileArithMul(node);
2078         break;
2079 
2080     case ValueMul:
2081         compileValueMul(node);
2082         break;
2083 
2084     case ValueDiv: {
2085         compileValueDiv(node);
2086         break;
2087     }
2088 
2089     case ArithDiv: {
2090         compileArithDiv(node);
2091         break;
2092     }
2093 
<a name="17" id="anc17"></a><span class="line-added">2094     case ValueMod: {</span>
<span class="line-added">2095         compileValueMod(node);</span>
<span class="line-added">2096         break;</span>
<span class="line-added">2097     }</span>
<span class="line-added">2098 </span>
2099     case ArithMod: {
2100         compileArithMod(node);
2101         break;
2102     }
2103 
<a name="18" id="anc18"></a><span class="line-added">2104     case ValuePow: {</span>
<span class="line-added">2105         compileValuePow(node);</span>
<span class="line-added">2106         break;</span>
<span class="line-added">2107     }</span>
<span class="line-added">2108 </span>
2109     case ArithPow: {
2110         compileArithPow(node);
2111         break;
2112     }
2113 
2114     case ArithAbs:
2115         compileArithAbs(node);
2116         break;
2117 
2118     case ArithMin:
2119     case ArithMax: {
2120         compileArithMinMax(node);
2121         break;
2122     }
2123 
2124     case ArithSqrt:
2125         compileArithSqrt(node);
2126         break;
2127 
2128     case ArithFRound:
2129         compileArithFRound(node);
2130         break;
2131 
2132     case ArithRandom:
2133         compileArithRandom(node);
2134         break;
2135 
2136     case ArithRound:
2137     case ArithFloor:
2138     case ArithCeil:
2139     case ArithTrunc:
2140         compileArithRounding(node);
2141         break;
2142 
2143     case ArithUnary:
2144         compileArithUnary(node);
2145         break;
2146 
2147     case LogicalNot:
2148         compileLogicalNot(node);
2149         break;
2150 
2151     case CompareLess:
2152         if (compare(node, JITCompiler::LessThan, JITCompiler::DoubleLessThan, operationCompareLess))
2153             return;
2154         break;
2155 
2156     case CompareLessEq:
2157         if (compare(node, JITCompiler::LessThanOrEqual, JITCompiler::DoubleLessThanOrEqual, operationCompareLessEq))
2158             return;
2159         break;
2160 
2161     case CompareGreater:
2162         if (compare(node, JITCompiler::GreaterThan, JITCompiler::DoubleGreaterThan, operationCompareGreater))
2163             return;
2164         break;
2165 
2166     case CompareGreaterEq:
2167         if (compare(node, JITCompiler::GreaterThanOrEqual, JITCompiler::DoubleGreaterThanOrEqual, operationCompareGreaterEq))
2168             return;
2169         break;
2170 
2171     case CompareBelow:
2172         compileCompareUnsigned(node, JITCompiler::Below);
2173         break;
2174 
2175     case CompareBelowEq:
2176         compileCompareUnsigned(node, JITCompiler::BelowOrEqual);
2177         break;
2178 
2179     case CompareEq:
2180         if (compare(node, JITCompiler::Equal, JITCompiler::DoubleEqual, operationCompareEq))
2181             return;
2182         break;
2183 
2184     case CompareStrictEq:
2185         if (compileStrictEq(node))
2186             return;
2187         break;
2188 
2189     case CompareEqPtr:
2190         compileCompareEqPtr(node);
2191         break;
2192 
2193     case SameValue:
2194         compileSameValue(node);
2195         break;
2196 
2197     case StringCharCodeAt: {
2198         compileGetCharCodeAt(node);
2199         break;
2200     }
2201 
2202     case StringCharAt: {
2203         // Relies on StringCharAt node having same basic layout as GetByVal
2204         compileGetByValOnString(node);
2205         break;
2206     }
2207 
2208     case StringFromCharCode: {
2209         compileFromCharCode(node);
2210         break;
2211     }
2212 
2213     case CheckArray: {
2214         checkArray(node);
2215         break;
2216     }
2217 
2218     case Arrayify:
2219     case ArrayifyToStructure: {
2220         arrayify(node);
2221         break;
2222     }
2223 
2224     case GetByVal: {
2225         switch (node-&gt;arrayMode().type()) {
2226         case Array::SelectUsingPredictions:
2227         case Array::ForceExit:
2228             RELEASE_ASSERT_NOT_REACHED();
2229 #if COMPILER_QUIRK(CONSIDERS_UNREACHABLE_CODE)
2230             terminateSpeculativeExecution(InadequateCoverage, JSValueRegs(), 0);
2231 #endif
2232             break;
2233         case Array::Undecided: {
2234             SpeculateStrictInt32Operand index(this, m_graph.varArgChild(node, 1));
2235             GPRTemporary resultTag(this, Reuse, index);
2236             GPRTemporary resultPayload(this);
2237 
2238             GPRReg indexGPR = index.gpr();
2239             GPRReg resultTagGPR = resultTag.gpr();
2240             GPRReg resultPayloadGPR = resultPayload.gpr();
2241 
2242             speculationCheck(OutOfBounds, JSValueRegs(), node,
2243                 m_jit.branch32(MacroAssembler::LessThan, indexGPR, MacroAssembler::TrustedImm32(0)));
2244 
2245             use(m_graph.varArgChild(node, 0));
2246             index.use();
2247 
2248             m_jit.move(MacroAssembler::TrustedImm32(JSValue::UndefinedTag), resultTagGPR);
2249             m_jit.move(MacroAssembler::TrustedImm32(0), resultPayloadGPR);
2250             jsValueResult(resultTagGPR, resultPayloadGPR, node, UseChildrenCalledExplicitly);
2251             break;
2252         }
2253         case Array::Generic: {
2254             if (m_graph.varArgChild(node, 0).useKind() == ObjectUse) {
2255                 if (m_graph.varArgChild(node, 1).useKind() == StringUse) {
2256                     compileGetByValForObjectWithString(node);
2257                     break;
2258                 }
2259 
2260                 if (m_graph.varArgChild(node, 1).useKind() == SymbolUse) {
2261                     compileGetByValForObjectWithSymbol(node);
2262                     break;
2263                 }
2264             }
2265 
2266             SpeculateCellOperand base(this, m_graph.varArgChild(node, 0)); // Save a register, speculate cell. We&#39;ll probably be right.
2267             JSValueOperand property(this, m_graph.varArgChild(node, 1));
2268             GPRReg baseGPR = base.gpr();
2269             JSValueRegs propertyRegs = property.jsValueRegs();
2270 
2271             flushRegisters();
2272             JSValueRegsFlushedCallResult result(this);
2273             JSValueRegs resultRegs = result.regs();
2274             callOperation(operationGetByValCell, resultRegs, baseGPR, propertyRegs);
2275             m_jit.exceptionCheck();
2276 
2277             jsValueResult(resultRegs, node);
2278             break;
2279         }
2280         case Array::Int32:
2281         case Array::Contiguous: {
2282             if (node-&gt;arrayMode().isInBounds()) {
2283                 SpeculateStrictInt32Operand property(this, m_graph.varArgChild(node, 1));
2284                 StorageOperand storage(this, m_graph.varArgChild(node, 2));
2285 
2286                 GPRReg propertyReg = property.gpr();
2287                 GPRReg storageReg = storage.gpr();
2288 
2289                 if (!m_compileOkay)
2290                     return;
2291 
2292                 speculationCheck(OutOfBounds, JSValueRegs(), 0, m_jit.branch32(MacroAssembler::AboveOrEqual, propertyReg, MacroAssembler::Address(storageReg, Butterfly::offsetOfPublicLength())));
2293 
2294                 GPRTemporary resultPayload(this);
2295                 if (node-&gt;arrayMode().type() == Array::Int32) {
2296                     ASSERT(!node-&gt;arrayMode().isSaneChain());
2297 
2298                     speculationCheck(
2299                         OutOfBounds, JSValueRegs(), 0,
2300                         m_jit.branch32(
2301                             MacroAssembler::Equal,
2302                             MacroAssembler::BaseIndex(
2303                                 storageReg, propertyReg, MacroAssembler::TimesEight, TagOffset),
2304                             TrustedImm32(JSValue::EmptyValueTag)));
2305                     m_jit.load32(
2306                         MacroAssembler::BaseIndex(
2307                             storageReg, propertyReg, MacroAssembler::TimesEight, PayloadOffset),
2308                         resultPayload.gpr());
2309                     int32Result(resultPayload.gpr(), node);
2310                     break;
2311                 }
2312 
2313                 GPRTemporary resultTag(this);
2314                 m_jit.load32(
2315                     MacroAssembler::BaseIndex(
2316                         storageReg, propertyReg, MacroAssembler::TimesEight, TagOffset),
2317                     resultTag.gpr());
2318                 m_jit.load32(
2319                     MacroAssembler::BaseIndex(
2320                         storageReg, propertyReg, MacroAssembler::TimesEight, PayloadOffset),
2321                     resultPayload.gpr());
2322                 if (node-&gt;arrayMode().isSaneChain()) {
2323                     JITCompiler::Jump notHole = m_jit.branchIfNotEmpty(resultTag.gpr());
2324                     m_jit.move(TrustedImm32(JSValue::UndefinedTag), resultTag.gpr());
2325                     m_jit.move(TrustedImm32(0), resultPayload.gpr());
2326                     notHole.link(&amp;m_jit);
2327                 } else {
2328                     speculationCheck(
2329                         LoadFromHole, JSValueRegs(), 0,
2330                         m_jit.branchIfEmpty(resultTag.gpr()));
2331                 }
2332                 jsValueResult(resultTag.gpr(), resultPayload.gpr(), node);
2333                 break;
2334             }
2335 
2336             SpeculateCellOperand base(this, m_graph.varArgChild(node, 0));
2337             SpeculateStrictInt32Operand property(this, m_graph.varArgChild(node, 1));
2338             StorageOperand storage(this, m_graph.varArgChild(node, 2));
2339 
2340             GPRReg baseReg = base.gpr();
2341             GPRReg propertyReg = property.gpr();
2342             GPRReg storageReg = storage.gpr();
2343 
2344             if (!m_compileOkay)
2345                 return;
2346 
2347             GPRTemporary resultTag(this);
2348             GPRTemporary resultPayload(this);
2349             GPRReg resultTagReg = resultTag.gpr();
2350             GPRReg resultPayloadReg = resultPayload.gpr();
2351 
2352             MacroAssembler::JumpList slowCases;
2353 
2354             slowCases.append(m_jit.branch32(MacroAssembler::AboveOrEqual, propertyReg, MacroAssembler::Address(storageReg, Butterfly::offsetOfPublicLength())));
2355 
2356             m_jit.load32(MacroAssembler::BaseIndex(storageReg, propertyReg, MacroAssembler::TimesEight, OBJECT_OFFSETOF(JSValue, u.asBits.tag)), resultTagReg);
2357             m_jit.load32(MacroAssembler::BaseIndex(storageReg, propertyReg, MacroAssembler::TimesEight, OBJECT_OFFSETOF(JSValue, u.asBits.payload)), resultPayloadReg);
2358             slowCases.append(m_jit.branchIfEmpty(resultTagReg));
2359 
2360             addSlowPathGenerator(
2361                 slowPathCall(
2362                     slowCases, this, operationGetByValObjectInt,
2363                     JSValueRegs(resultTagReg, resultPayloadReg), baseReg, propertyReg));
2364 
2365             jsValueResult(resultTagReg, resultPayloadReg, node);
2366             break;
2367         }
2368         case Array::Double: {
2369             if (node-&gt;arrayMode().isInBounds()) {
2370                 SpeculateStrictInt32Operand property(this, m_graph.varArgChild(node, 1));
2371                 StorageOperand storage(this, m_graph.varArgChild(node, 2));
2372 
2373                 GPRReg propertyReg = property.gpr();
2374                 GPRReg storageReg = storage.gpr();
2375 
2376                 if (!m_compileOkay)
2377                     return;
2378 
2379                 speculationCheck(OutOfBounds, JSValueRegs(), 0, m_jit.branch32(MacroAssembler::AboveOrEqual, propertyReg, MacroAssembler::Address(storageReg, Butterfly::offsetOfPublicLength())));
2380 
2381                 FPRTemporary result(this);
2382                 m_jit.loadDouble(MacroAssembler::BaseIndex(storageReg, propertyReg, MacroAssembler::TimesEight), result.fpr());
2383                 if (!node-&gt;arrayMode().isSaneChain())
2384                     speculationCheck(LoadFromHole, JSValueRegs(), 0, m_jit.branchIfNaN(result.fpr()));
2385                 doubleResult(result.fpr(), node);
2386                 break;
2387             }
2388 
2389             SpeculateCellOperand base(this, m_graph.varArgChild(node, 0));
2390             SpeculateStrictInt32Operand property(this, m_graph.varArgChild(node, 1));
2391             StorageOperand storage(this, m_graph.varArgChild(node, 2));
2392 
2393             GPRReg baseReg = base.gpr();
2394             GPRReg propertyReg = property.gpr();
2395             GPRReg storageReg = storage.gpr();
2396 
2397             if (!m_compileOkay)
2398                 return;
2399 
2400             GPRTemporary resultTag(this);
2401             GPRTemporary resultPayload(this);
2402             FPRTemporary temp(this);
2403             GPRReg resultTagReg = resultTag.gpr();
2404             GPRReg resultPayloadReg = resultPayload.gpr();
2405             FPRReg tempReg = temp.fpr();
2406 
2407             MacroAssembler::JumpList slowCases;
2408 
2409             slowCases.append(m_jit.branch32(MacroAssembler::AboveOrEqual, propertyReg, MacroAssembler::Address(storageReg, Butterfly::offsetOfPublicLength())));
2410 
2411             m_jit.loadDouble(MacroAssembler::BaseIndex(storageReg, propertyReg, MacroAssembler::TimesEight), tempReg);
2412             slowCases.append(m_jit.branchIfNaN(tempReg));
2413             boxDouble(tempReg, resultTagReg, resultPayloadReg);
2414 
2415             addSlowPathGenerator(
2416                 slowPathCall(
2417                     slowCases, this, operationGetByValObjectInt,
2418                     JSValueRegs(resultTagReg, resultPayloadReg), baseReg, propertyReg));
2419 
2420             jsValueResult(resultTagReg, resultPayloadReg, node);
2421             break;
2422         }
2423         case Array::ArrayStorage:
2424         case Array::SlowPutArrayStorage: {
2425             if (node-&gt;arrayMode().isInBounds()) {
2426                 SpeculateStrictInt32Operand property(this, m_graph.varArgChild(node, 1));
2427                 StorageOperand storage(this, m_graph.varArgChild(node, 2));
2428                 GPRReg propertyReg = property.gpr();
2429                 GPRReg storageReg = storage.gpr();
2430 
2431                 if (!m_compileOkay)
2432                     return;
2433 
2434                 speculationCheck(OutOfBounds, JSValueRegs(), 0, m_jit.branch32(MacroAssembler::AboveOrEqual, propertyReg, MacroAssembler::Address(storageReg, ArrayStorage::vectorLengthOffset())));
2435 
2436                 GPRTemporary resultTag(this);
2437                 GPRTemporary resultPayload(this);
2438 
2439                 m_jit.load32(MacroAssembler::BaseIndex(storageReg, propertyReg, MacroAssembler::TimesEight, ArrayStorage::vectorOffset() + OBJECT_OFFSETOF(JSValue, u.asBits.tag)), resultTag.gpr());
2440                 speculationCheck(LoadFromHole, JSValueRegs(), 0, m_jit.branchIfEmpty(resultTag.gpr()));
2441                 m_jit.load32(MacroAssembler::BaseIndex(storageReg, propertyReg, MacroAssembler::TimesEight, ArrayStorage::vectorOffset() + OBJECT_OFFSETOF(JSValue, u.asBits.payload)), resultPayload.gpr());
2442 
2443                 jsValueResult(resultTag.gpr(), resultPayload.gpr(), node);
2444                 break;
2445             }
2446 
2447             SpeculateCellOperand base(this, m_graph.varArgChild(node, 0));
2448             SpeculateStrictInt32Operand property(this, m_graph.varArgChild(node, 1));
2449             StorageOperand storage(this, m_graph.varArgChild(node, 2));
2450             GPRReg propertyReg = property.gpr();
2451             GPRReg storageReg = storage.gpr();
2452             GPRReg baseReg = base.gpr();
2453 
2454             if (!m_compileOkay)
2455                 return;
2456 
2457             GPRTemporary resultTag(this);
2458             GPRTemporary resultPayload(this);
2459             GPRReg resultTagReg = resultTag.gpr();
2460             GPRReg resultPayloadReg = resultPayload.gpr();
2461 
2462             JITCompiler::Jump outOfBounds = m_jit.branch32(
2463                 MacroAssembler::AboveOrEqual, propertyReg,
2464                 MacroAssembler::Address(storageReg, ArrayStorage::vectorLengthOffset()));
2465 
2466             m_jit.load32(MacroAssembler::BaseIndex(storageReg, propertyReg, MacroAssembler::TimesEight, ArrayStorage::vectorOffset() + OBJECT_OFFSETOF(JSValue, u.asBits.tag)), resultTagReg);
2467             JITCompiler::Jump hole = m_jit.branchIfEmpty(resultTag.gpr());
2468             m_jit.load32(MacroAssembler::BaseIndex(storageReg, propertyReg, MacroAssembler::TimesEight, ArrayStorage::vectorOffset() + OBJECT_OFFSETOF(JSValue, u.asBits.payload)), resultPayloadReg);
2469 
2470             JITCompiler::JumpList slowCases;
2471             slowCases.append(outOfBounds);
2472             slowCases.append(hole);
2473             addSlowPathGenerator(
2474                 slowPathCall(
2475                     slowCases, this, operationGetByValObjectInt,
2476                     JSValueRegs(resultTagReg, resultPayloadReg),
2477                     baseReg, propertyReg));
2478 
2479             jsValueResult(resultTagReg, resultPayloadReg, node);
2480             break;
2481         }
2482         case Array::String:
2483             compileGetByValOnString(node);
2484             break;
2485         case Array::DirectArguments:
2486             compileGetByValOnDirectArguments(node);
2487             break;
2488         case Array::ScopedArguments:
2489             compileGetByValOnScopedArguments(node);
2490             break;
2491         default: {
2492             TypedArrayType type = node-&gt;arrayMode().typedArrayType();
2493             if (isInt(type))
2494                 compileGetByValOnIntTypedArray(node, type);
2495             else
2496                 compileGetByValOnFloatTypedArray(node, type);
2497         } }
2498         break;
2499     }
2500 
2501     case StringSlice: {
2502         compileStringSlice(node);
2503         break;
2504     }
2505 
2506     case ToLowerCase: {
2507         compileToLowerCase(node);
2508         break;
2509     }
2510 
2511     case NumberToStringWithRadix: {
2512         compileNumberToStringWithRadix(node);
2513         break;
2514     }
2515 
2516     case NumberToStringWithValidRadixConstant: {
2517         compileNumberToStringWithValidRadixConstant(node);
2518         break;
2519     }
2520 
2521     case GetByValWithThis: {
2522         compileGetByValWithThis(node);
2523         break;
2524     }
2525 
2526     case PutByValDirect:
2527     case PutByVal:
2528     case PutByValAlias: {
2529         Edge child1 = m_jit.graph().varArgChild(node, 0);
2530         Edge child2 = m_jit.graph().varArgChild(node, 1);
2531         Edge child3 = m_jit.graph().varArgChild(node, 2);
2532         Edge child4 = m_jit.graph().varArgChild(node, 3);
2533 
2534         ArrayMode arrayMode = node-&gt;arrayMode().modeForPut();
2535         bool alreadyHandled = false;
2536 
2537         switch (arrayMode.type()) {
2538         case Array::SelectUsingPredictions:
2539         case Array::ForceExit:
2540             RELEASE_ASSERT_NOT_REACHED();
2541 #if COMPILER_QUIRK(CONSIDERS_UNREACHABLE_CODE)
2542             terminateSpeculativeExecution(InadequateCoverage, JSValueRegs(), 0);
2543             alreadyHandled = true;
2544 #endif
2545             break;
2546         case Array::Generic: {
2547             ASSERT(node-&gt;op() == PutByVal || node-&gt;op() == PutByValDirect);
2548 
2549             if (child1.useKind() == CellUse) {
2550                 if (child2.useKind() == StringUse) {
2551                     compilePutByValForCellWithString(node, child1, child2, child3);
2552                     alreadyHandled = true;
2553                     break;
2554                 }
2555 
2556                 if (child2.useKind() == SymbolUse) {
2557                     compilePutByValForCellWithSymbol(node, child1, child2, child3);
2558                     alreadyHandled = true;
2559                     break;
2560                 }
2561             }
2562 
2563             SpeculateCellOperand base(this, child1); // Save a register, speculate cell. We&#39;ll probably be right.
2564             JSValueOperand property(this, child2);
2565             JSValueOperand value(this, child3);
2566             GPRReg baseGPR = base.gpr();
2567             JSValueRegs propertyRegs = property.jsValueRegs();
2568             JSValueRegs valueRegs = value.jsValueRegs();
2569 
2570             flushRegisters();
2571             if (node-&gt;op() == PutByValDirect)
<a name="19" id="anc19"></a><span class="line-modified">2572                 callOperation(m_jit.isStrictModeFor(node-&gt;origin.semantic) ? operationPutByValDirectCellStrict : operationPutByValDirectCellNonStrict, baseGPR, propertyRegs, valueRegs);</span>
2573             else
<a name="20" id="anc20"></a><span class="line-modified">2574                 callOperation(m_jit.isStrictModeFor(node-&gt;origin.semantic) ? operationPutByValCellStrict : operationPutByValCellNonStrict, baseGPR, propertyRegs, valueRegs);</span>
2575             m_jit.exceptionCheck();
2576 
2577             noResult(node);
2578             alreadyHandled = true;
2579             break;
2580         }
2581         default:
2582             break;
2583         }
2584 
2585         if (alreadyHandled)
2586             break;
2587 
2588         SpeculateCellOperand base(this, child1);
2589         SpeculateStrictInt32Operand property(this, child2);
2590 
2591         GPRReg baseReg = base.gpr();
2592         GPRReg propertyReg = property.gpr();
2593 
2594         switch (arrayMode.type()) {
2595         case Array::Int32: {
2596             speculateInt32(child3);
2597             FALLTHROUGH;
2598         }
2599         case Array::Contiguous: {
2600             JSValueOperand value(this, child3, ManualOperandSpeculation);
2601 
2602             GPRReg valueTagReg = value.tagGPR();
2603             GPRReg valuePayloadReg = value.payloadGPR();
2604 
2605             if (!m_compileOkay)
2606                 return;
2607 
2608             compileContiguousPutByVal(node, base, property, value, valuePayloadReg, valueTagReg);
2609             break;
2610         }
2611         case Array::Double: {
2612             compileDoublePutByVal(node, base, property);
2613             break;
2614         }
2615         case Array::ArrayStorage:
2616         case Array::SlowPutArrayStorage: {
2617             JSValueOperand value(this, child3);
2618 
2619             GPRReg valueTagReg = value.tagGPR();
2620             GPRReg valuePayloadReg = value.payloadGPR();
2621 
2622             if (!m_compileOkay)
2623                 return;
2624 
2625             StorageOperand storage(this, child4);
2626             GPRReg storageReg = storage.gpr();
2627 
2628             if (node-&gt;op() == PutByValAlias) {
2629                 // Store the value to the array.
2630                 GPRReg propertyReg = property.gpr();
2631                 m_jit.store32(value.tagGPR(), MacroAssembler::BaseIndex(storageReg, propertyReg, MacroAssembler::TimesEight, ArrayStorage::vectorOffset() + OBJECT_OFFSETOF(JSValue, u.asBits.tag)));
2632                 m_jit.store32(value.payloadGPR(), MacroAssembler::BaseIndex(storageReg, propertyReg, MacroAssembler::TimesEight, ArrayStorage::vectorOffset() + OBJECT_OFFSETOF(JSValue, u.asBits.payload)));
2633 
2634                 noResult(node);
2635                 break;
2636             }
2637 
2638             MacroAssembler::JumpList slowCases;
2639 
2640             MacroAssembler::Jump beyondArrayBounds = m_jit.branch32(MacroAssembler::AboveOrEqual, propertyReg, MacroAssembler::Address(storageReg, ArrayStorage::vectorLengthOffset()));
2641             if (!arrayMode.isOutOfBounds())
2642                 speculationCheck(OutOfBounds, JSValueRegs(), 0, beyondArrayBounds);
2643             else
2644                 slowCases.append(beyondArrayBounds);
2645 
2646             // Check if we&#39;re writing to a hole; if so increment m_numValuesInVector.
2647             if (arrayMode.isInBounds()) {
2648                 speculationCheck(
2649                     StoreToHole, JSValueRegs(), 0,
2650                     m_jit.branch32(MacroAssembler::Equal, MacroAssembler::BaseIndex(storageReg, propertyReg, MacroAssembler::TimesEight, ArrayStorage::vectorOffset() + OBJECT_OFFSETOF(JSValue, u.asBits.tag)), TrustedImm32(JSValue::EmptyValueTag)));
2651             } else {
2652                 MacroAssembler::Jump notHoleValue = m_jit.branch32(MacroAssembler::NotEqual, MacroAssembler::BaseIndex(storageReg, propertyReg, MacroAssembler::TimesEight, ArrayStorage::vectorOffset() + OBJECT_OFFSETOF(JSValue, u.asBits.tag)), TrustedImm32(JSValue::EmptyValueTag));
2653                 if (arrayMode.isSlowPut()) {
2654                     // This is sort of strange. If we wanted to optimize this code path, we would invert
2655                     // the above branch. But it&#39;s simply not worth it since this only happens if we&#39;re
2656                     // already having a bad time.
2657                     slowCases.append(m_jit.jump());
2658                 } else {
2659                     m_jit.add32(TrustedImm32(1), MacroAssembler::Address(storageReg, ArrayStorage::numValuesInVectorOffset()));
2660 
2661                     // If we&#39;re writing to a hole we might be growing the array;
2662                     MacroAssembler::Jump lengthDoesNotNeedUpdate = m_jit.branch32(MacroAssembler::Below, propertyReg, MacroAssembler::Address(storageReg, ArrayStorage::lengthOffset()));
2663                     m_jit.add32(TrustedImm32(1), propertyReg);
2664                     m_jit.store32(propertyReg, MacroAssembler::Address(storageReg, ArrayStorage::lengthOffset()));
2665                     m_jit.sub32(TrustedImm32(1), propertyReg);
2666 
2667                     lengthDoesNotNeedUpdate.link(&amp;m_jit);
2668                 }
2669                 notHoleValue.link(&amp;m_jit);
2670             }
2671 
2672             // Store the value to the array.
2673             m_jit.store32(valueTagReg, MacroAssembler::BaseIndex(storageReg, propertyReg, MacroAssembler::TimesEight, ArrayStorage::vectorOffset() + OBJECT_OFFSETOF(JSValue, u.asBits.tag)));
2674             m_jit.store32(valuePayloadReg, MacroAssembler::BaseIndex(storageReg, propertyReg, MacroAssembler::TimesEight, ArrayStorage::vectorOffset() + OBJECT_OFFSETOF(JSValue, u.asBits.payload)));
2675 
2676             base.use();
2677             property.use();
2678             value.use();
2679             storage.use();
2680 
2681             if (!slowCases.empty()) {
2682                 if (node-&gt;op() == PutByValDirect) {
2683                     addSlowPathGenerator(slowPathCall(
2684                         slowCases, this,
<a name="21" id="anc21"></a><span class="line-modified">2685                         m_jit.isStrictModeFor(node-&gt;origin.semantic) ? operationPutByValDirectBeyondArrayBoundsStrict : operationPutByValDirectBeyondArrayBoundsNonStrict,</span>
2686                         NoResult, baseReg, propertyReg, JSValueRegs(valueTagReg, valuePayloadReg)));
2687                 } else {
2688                     addSlowPathGenerator(slowPathCall(
2689                         slowCases, this,
<a name="22" id="anc22"></a><span class="line-modified">2690                         m_jit.isStrictModeFor(node-&gt;origin.semantic) ? operationPutByValBeyondArrayBoundsStrict : operationPutByValBeyondArrayBoundsNonStrict,</span>
2691                         NoResult, baseReg, propertyReg, JSValueRegs(valueTagReg, valuePayloadReg)));
2692                 }
2693             }
2694 
2695             noResult(node, UseChildrenCalledExplicitly);
2696             break;
2697         }
2698 
2699         default: {
2700             TypedArrayType type = arrayMode.typedArrayType();
2701             if (isInt(type))
2702                 compilePutByValForIntTypedArray(base.gpr(), property.gpr(), node, type);
2703             else
2704                 compilePutByValForFloatTypedArray(base.gpr(), property.gpr(), node, type);
2705         } }
2706         break;
2707     }
2708 
2709     case PutByValWithThis: {
2710 #if CPU(X86)
2711         // We don&#39;t have enough registers on X86 to do this
2712         // without setting up the call frame incrementally.
2713         unsigned index = 0;
2714         m_jit.poke(GPRInfo::callFrameRegister, index++);
2715 
2716         {
2717             JSValueOperand base(this, m_jit.graph().varArgChild(node, 0));
2718             GPRReg baseTag = base.tagGPR();
2719             GPRReg basePayload = base.payloadGPR();
2720 
2721             JSValueOperand thisValue(this, m_jit.graph().varArgChild(node, 1));
2722             GPRReg thisValueTag = thisValue.tagGPR();
2723             GPRReg thisValuePayload = thisValue.payloadGPR();
2724 
2725             JSValueOperand property(this, m_jit.graph().varArgChild(node, 2));
2726             GPRReg propertyTag = property.tagGPR();
2727             GPRReg propertyPayload = property.payloadGPR();
2728 
2729             m_jit.poke(basePayload, index++);
2730             m_jit.poke(baseTag, index++);
2731 
2732             m_jit.poke(thisValuePayload, index++);
2733             m_jit.poke(thisValueTag, index++);
2734 
2735             m_jit.poke(propertyPayload, index++);
2736             m_jit.poke(propertyTag, index++);
2737 
2738             flushRegisters();
2739         }
2740 
2741         JSValueOperand value(this, m_jit.graph().varArgChild(node, 3));
2742         GPRReg valueTag = value.tagGPR();
2743         GPRReg valuePayload = value.payloadGPR();
2744         m_jit.poke(valuePayload, index++);
2745         m_jit.poke(valueTag, index++);
2746 
2747         flushRegisters();
2748         appendCall(m_jit.isStrictModeFor(node-&gt;origin.semantic) ? operationPutByValWithThisStrict : operationPutByValWithThis);
2749         m_jit.exceptionCheck();
2750 #else
2751         static_assert(GPRInfo::numberOfRegisters &gt;= 8, &quot;We are assuming we have enough registers to make this call without incrementally setting up the arguments.&quot;);
2752 
2753         JSValueOperand base(this, m_jit.graph().varArgChild(node, 0));
2754         JSValueRegs baseRegs = base.jsValueRegs();
2755 
2756         JSValueOperand thisValue(this, m_jit.graph().varArgChild(node, 1));
2757         JSValueRegs thisRegs = thisValue.jsValueRegs();
2758 
2759         JSValueOperand property(this, m_jit.graph().varArgChild(node, 2));
2760         JSValueRegs propertyRegs = property.jsValueRegs();
2761 
2762         JSValueOperand value(this, m_jit.graph().varArgChild(node, 3));
2763         JSValueRegs valueRegs = value.jsValueRegs();
2764 
2765         flushRegisters();
2766         callOperation(m_jit.isStrictModeFor(node-&gt;origin.semantic) ? operationPutByValWithThisStrict : operationPutByValWithThis,
2767             NoResult, baseRegs, thisRegs, propertyRegs, valueRegs);
2768         m_jit.exceptionCheck();
2769 #endif // CPU(X86)
2770 
2771         noResult(node);
2772         break;
2773     }
2774 
2775     case RegExpExec: {
2776         compileRegExpExec(node);
2777         break;
2778     }
2779 
2780     case RegExpExecNonGlobalOrSticky: {
2781         compileRegExpExecNonGlobalOrSticky(node);
2782         break;
2783     }
2784 
2785     case RegExpMatchFastGlobal: {
2786         compileRegExpMatchFastGlobal(node);
2787         break;
2788     }
2789 
2790     case RegExpTest: {
2791         compileRegExpTest(node);
2792         break;
2793     }
2794 
2795     case RegExpMatchFast: {
2796         compileRegExpMatchFast(node);
2797         break;
2798     }
2799 
2800     case StringReplace:
2801     case StringReplaceRegExp: {
2802         compileStringReplace(node);
2803         break;
2804     }
2805 
2806     case GetRegExpObjectLastIndex: {
2807         compileGetRegExpObjectLastIndex(node);
2808         break;
2809     }
2810 
2811     case SetRegExpObjectLastIndex: {
2812         compileSetRegExpObjectLastIndex(node);
2813         break;
2814     }
2815 
2816     case RecordRegExpCachedResult: {
2817         compileRecordRegExpCachedResult(node);
2818         break;
2819     }
2820 
2821     case ArrayPush: {
2822         compileArrayPush(node);
2823         break;
2824     }
2825 
2826     case ArrayPop: {
2827         ASSERT(node-&gt;arrayMode().isJSArray());
2828 
2829         SpeculateCellOperand base(this, node-&gt;child1());
2830         StorageOperand storage(this, node-&gt;child2());
2831         GPRTemporary valueTag(this);
2832         GPRTemporary valuePayload(this);
2833 
2834         GPRReg baseGPR = base.gpr();
2835         GPRReg valueTagGPR = valueTag.gpr();
2836         GPRReg valuePayloadGPR = valuePayload.gpr();
2837         GPRReg storageGPR = storage.gpr();
2838 
2839         switch (node-&gt;arrayMode().type()) {
2840         case Array::Int32:
2841         case Array::Contiguous: {
2842             m_jit.load32(
2843                 MacroAssembler::Address(storageGPR, Butterfly::offsetOfPublicLength()), valuePayloadGPR);
2844             MacroAssembler::Jump undefinedCase =
2845                 m_jit.branchTest32(MacroAssembler::Zero, valuePayloadGPR);
2846             m_jit.sub32(TrustedImm32(1), valuePayloadGPR);
2847             m_jit.store32(
2848                 valuePayloadGPR, MacroAssembler::Address(storageGPR, Butterfly::offsetOfPublicLength()));
2849             m_jit.load32(
2850                 MacroAssembler::BaseIndex(storageGPR, valuePayloadGPR, MacroAssembler::TimesEight, OBJECT_OFFSETOF(JSValue, u.asBits.tag)),
2851                 valueTagGPR);
2852             MacroAssembler::Jump slowCase = m_jit.branchIfEmpty(valueTagGPR);
2853             m_jit.store32(
2854                 MacroAssembler::TrustedImm32(JSValue::EmptyValueTag),
2855                 MacroAssembler::BaseIndex(storageGPR, valuePayloadGPR, MacroAssembler::TimesEight, OBJECT_OFFSETOF(JSValue, u.asBits.tag)));
2856             m_jit.load32(
2857                 MacroAssembler::BaseIndex(storageGPR, valuePayloadGPR, MacroAssembler::TimesEight, OBJECT_OFFSETOF(JSValue, u.asBits.payload)),
2858                 valuePayloadGPR);
2859 
2860             addSlowPathGenerator(
2861                 slowPathMove(
2862                     undefinedCase, this,
2863                     MacroAssembler::TrustedImm32(jsUndefined().tag()), valueTagGPR,
2864                     MacroAssembler::TrustedImm32(jsUndefined().payload()), valuePayloadGPR));
2865             addSlowPathGenerator(
2866                 slowPathCall(
2867                     slowCase, this, operationArrayPopAndRecoverLength,
2868                     JSValueRegs(valueTagGPR, valuePayloadGPR), baseGPR));
2869 
2870             jsValueResult(valueTagGPR, valuePayloadGPR, node);
2871             break;
2872         }
2873 
2874         case Array::Double: {
2875             FPRTemporary temp(this);
2876             FPRReg tempFPR = temp.fpr();
2877 
2878             m_jit.load32(
2879                 MacroAssembler::Address(storageGPR, Butterfly::offsetOfPublicLength()), valuePayloadGPR);
2880             MacroAssembler::Jump undefinedCase =
2881                 m_jit.branchTest32(MacroAssembler::Zero, valuePayloadGPR);
2882             m_jit.sub32(TrustedImm32(1), valuePayloadGPR);
2883             m_jit.store32(
2884                 valuePayloadGPR, MacroAssembler::Address(storageGPR, Butterfly::offsetOfPublicLength()));
2885             m_jit.loadDouble(
2886                 MacroAssembler::BaseIndex(storageGPR, valuePayloadGPR, MacroAssembler::TimesEight),
2887                 tempFPR);
2888             MacroAssembler::Jump slowCase = m_jit.branchIfNaN(tempFPR);
2889             JSValue nan = JSValue(JSValue::EncodeAsDouble, PNaN);
2890             m_jit.store32(
2891                 MacroAssembler::TrustedImm32(nan.u.asBits.tag),
2892                 MacroAssembler::BaseIndex(storageGPR, valuePayloadGPR, MacroAssembler::TimesEight, OBJECT_OFFSETOF(JSValue, u.asBits.tag)));
2893             m_jit.store32(
2894                 MacroAssembler::TrustedImm32(nan.u.asBits.payload),
2895                 MacroAssembler::BaseIndex(storageGPR, valuePayloadGPR, MacroAssembler::TimesEight, OBJECT_OFFSETOF(JSValue, u.asBits.payload)));
2896             boxDouble(tempFPR, valueTagGPR, valuePayloadGPR);
2897 
2898             addSlowPathGenerator(
2899                 slowPathMove(
2900                     undefinedCase, this,
2901                     MacroAssembler::TrustedImm32(jsUndefined().tag()), valueTagGPR,
2902                     MacroAssembler::TrustedImm32(jsUndefined().payload()), valuePayloadGPR));
2903             addSlowPathGenerator(
2904                 slowPathCall(
2905                     slowCase, this, operationArrayPopAndRecoverLength,
2906                     JSValueRegs(valueTagGPR, valuePayloadGPR), baseGPR));
2907 
2908             jsValueResult(valueTagGPR, valuePayloadGPR, node);
2909             break;
2910         }
2911 
2912         case Array::ArrayStorage: {
2913             GPRTemporary storageLength(this);
2914             GPRReg storageLengthGPR = storageLength.gpr();
2915 
2916             m_jit.load32(MacroAssembler::Address(storageGPR, ArrayStorage::lengthOffset()), storageLengthGPR);
2917 
2918             JITCompiler::JumpList setUndefinedCases;
2919             setUndefinedCases.append(m_jit.branchTest32(MacroAssembler::Zero, storageLengthGPR));
2920 
2921             m_jit.sub32(TrustedImm32(1), storageLengthGPR);
2922 
2923             MacroAssembler::Jump slowCase = m_jit.branch32(MacroAssembler::AboveOrEqual, storageLengthGPR, MacroAssembler::Address(storageGPR, ArrayStorage::vectorLengthOffset()));
2924 
2925             m_jit.load32(MacroAssembler::BaseIndex(storageGPR, storageLengthGPR, MacroAssembler::TimesEight, ArrayStorage::vectorOffset() + OBJECT_OFFSETOF(JSValue, u.asBits.tag)), valueTagGPR);
2926             m_jit.load32(MacroAssembler::BaseIndex(storageGPR, storageLengthGPR, MacroAssembler::TimesEight, ArrayStorage::vectorOffset() + OBJECT_OFFSETOF(JSValue, u.asBits.payload)), valuePayloadGPR);
2927 
2928             m_jit.store32(storageLengthGPR, MacroAssembler::Address(storageGPR, ArrayStorage::lengthOffset()));
2929 
2930             setUndefinedCases.append(m_jit.branchIfEmpty(valueTagGPR));
2931 
2932             m_jit.store32(TrustedImm32(JSValue::EmptyValueTag), MacroAssembler::BaseIndex(storageGPR, storageLengthGPR, MacroAssembler::TimesEight, ArrayStorage::vectorOffset() + OBJECT_OFFSETOF(JSValue, u.asBits.tag)));
2933 
2934             m_jit.sub32(TrustedImm32(1), MacroAssembler::Address(storageGPR, OBJECT_OFFSETOF(ArrayStorage, m_numValuesInVector)));
2935 
2936             addSlowPathGenerator(
2937                 slowPathMove(
2938                     setUndefinedCases, this,
2939                     MacroAssembler::TrustedImm32(jsUndefined().tag()), valueTagGPR,
2940                     MacroAssembler::TrustedImm32(jsUndefined().payload()), valuePayloadGPR));
2941 
2942             addSlowPathGenerator(
2943                 slowPathCall(
2944                     slowCase, this, operationArrayPop,
2945                     JSValueRegs(valueTagGPR, valuePayloadGPR), baseGPR));
2946 
2947             jsValueResult(valueTagGPR, valuePayloadGPR, node);
2948             break;
2949         }
2950 
2951         default:
2952             CRASH();
2953             break;
2954         }
2955         break;
2956     }
2957 
2958     case ArraySlice: {
2959         compileArraySlice(node);
2960         break;
2961     }
2962 
2963     case ArrayIndexOf: {
2964         compileArrayIndexOf(node);
2965         break;
2966     }
2967 
2968     case DFG::Jump: {
2969         jump(node-&gt;targetBlock());
2970         noResult(node);
2971         break;
2972     }
2973 
2974     case Branch:
2975         emitBranch(node);
2976         break;
2977 
2978     case Switch:
2979         emitSwitch(node);
2980         break;
2981 
2982     case Return: {
2983         ASSERT(GPRInfo::callFrameRegister != GPRInfo::regT2);
2984         ASSERT(GPRInfo::regT1 != GPRInfo::returnValueGPR);
2985         ASSERT(GPRInfo::returnValueGPR != GPRInfo::callFrameRegister);
2986 
2987         // Return the result in returnValueGPR.
2988         JSValueOperand op1(this, node-&gt;child1());
2989         op1.fill();
2990         if (op1.isDouble())
2991             boxDouble(op1.fpr(), GPRInfo::returnValueGPR2, GPRInfo::returnValueGPR);
2992         else {
2993             if (op1.payloadGPR() == GPRInfo::returnValueGPR2 &amp;&amp; op1.tagGPR() == GPRInfo::returnValueGPR)
2994                 m_jit.swap(GPRInfo::returnValueGPR, GPRInfo::returnValueGPR2);
2995             else if (op1.payloadGPR() == GPRInfo::returnValueGPR2) {
2996                 m_jit.move(op1.payloadGPR(), GPRInfo::returnValueGPR);
2997                 m_jit.move(op1.tagGPR(), GPRInfo::returnValueGPR2);
2998             } else {
2999                 m_jit.move(op1.tagGPR(), GPRInfo::returnValueGPR2);
3000                 m_jit.move(op1.payloadGPR(), GPRInfo::returnValueGPR);
3001             }
3002         }
3003 
3004         m_jit.emitRestoreCalleeSaves();
3005         m_jit.emitFunctionEpilogue();
3006         m_jit.ret();
3007 
3008         noResult(node);
3009         break;
3010     }
3011 
3012     case Throw: {
3013         compileThrow(node);
3014         break;
3015     }
3016 
3017     case ThrowStaticError: {
3018         compileThrowStaticError(node);
3019         break;
3020     }
3021 
3022     case BooleanToNumber: {
3023         switch (node-&gt;child1().useKind()) {
3024         case BooleanUse: {
3025             SpeculateBooleanOperand value(this, node-&gt;child1());
3026             GPRTemporary result(this); // FIXME: We could reuse, but on speculation fail would need recovery to restore tag (akin to add).
3027 
3028             m_jit.move(value.gpr(), result.gpr());
3029 
3030             int32Result(result.gpr(), node);
3031             break;
3032         }
3033 
3034         case UntypedUse: {
3035             JSValueOperand value(this, node-&gt;child1());
3036 
3037             if (!m_interpreter.needsTypeCheck(node-&gt;child1(), SpecBoolInt32 | SpecBoolean)) {
3038                 GPRTemporary result(this);
3039 
3040                 GPRReg valueGPR = value.payloadGPR();
3041                 GPRReg resultGPR = result.gpr();
3042 
3043                 m_jit.move(valueGPR, resultGPR);
3044                 int32Result(result.gpr(), node);
3045                 break;
3046             }
3047 
3048             GPRTemporary resultTag(this);
3049             GPRTemporary resultPayload(this);
3050 
3051             GPRReg valueTagGPR = value.tagGPR();
3052             GPRReg valuePayloadGPR = value.payloadGPR();
3053             GPRReg resultTagGPR = resultTag.gpr();
3054             GPRReg resultPayloadGPR = resultPayload.gpr();
3055 
3056             m_jit.move(valuePayloadGPR, resultPayloadGPR);
3057             JITCompiler::Jump isBoolean = m_jit.branchIfBoolean(valueTagGPR, InvalidGPRReg);
3058             m_jit.move(valueTagGPR, resultTagGPR);
3059             JITCompiler::Jump done = m_jit.jump();
3060             isBoolean.link(&amp;m_jit);
3061             m_jit.move(TrustedImm32(JSValue::Int32Tag), resultTagGPR);
3062             done.link(&amp;m_jit);
3063 
3064             jsValueResult(resultTagGPR, resultPayloadGPR, node);
3065             break;
3066         }
3067 
3068         default:
3069             RELEASE_ASSERT_NOT_REACHED();
3070             break;
3071         }
3072         break;
3073     }
3074 
3075     case ToPrimitive: {
3076         compileToPrimitive(node);
3077         break;
3078     }
3079 
3080     case ToNumber: {
3081         JSValueOperand argument(this, node-&gt;child1());
3082         GPRTemporary resultTag(this, Reuse, argument, TagWord);
3083         GPRTemporary resultPayload(this, Reuse, argument, PayloadWord);
3084 
3085         GPRReg argumentPayloadGPR = argument.payloadGPR();
3086         GPRReg argumentTagGPR = argument.tagGPR();
3087         JSValueRegs argumentRegs = argument.jsValueRegs();
3088         JSValueRegs resultRegs(resultTag.gpr(), resultPayload.gpr());
3089 
3090         argument.use();
3091 
3092         // We have several attempts to remove ToNumber. But ToNumber still exists.
3093         // It means that converting non-numbers to numbers by this ToNumber is not rare.
3094         // Instead of the slow path generator, we emit callOperation here.
3095         if (!(m_state.forNode(node-&gt;child1()).m_type &amp; SpecBytecodeNumber)) {
3096             flushRegisters();
3097             callOperation(operationToNumber, resultRegs, argumentRegs);
3098             m_jit.exceptionCheck();
3099         } else {
3100             MacroAssembler::Jump notNumber;
3101             {
3102                 GPRTemporary scratch(this);
3103                 notNumber = m_jit.branchIfNotNumber(argument.jsValueRegs(), scratch.gpr());
3104             }
3105             m_jit.move(argumentTagGPR, resultRegs.tagGPR());
3106             m_jit.move(argumentPayloadGPR, resultRegs.payloadGPR());
3107             MacroAssembler::Jump done = m_jit.jump();
3108 
3109             notNumber.link(&amp;m_jit);
3110             silentSpillAllRegisters(resultRegs);
3111             callOperation(operationToNumber, resultRegs, argumentRegs);
3112             silentFillAllRegisters();
3113             m_jit.exceptionCheck();
3114 
3115             done.link(&amp;m_jit);
3116         }
3117 
3118         jsValueResult(resultRegs.tagGPR(), resultRegs.payloadGPR(), node, UseChildrenCalledExplicitly);
3119         break;
3120     }
3121 
3122     case ToString:
3123     case CallStringConstructor:
3124     case StringValueOf: {
3125         compileToStringOrCallStringConstructorOrStringValueOf(node);
3126         break;
3127     }
3128 
3129     case NewStringObject: {
3130         compileNewStringObject(node);
3131         break;
3132     }
3133 
3134     case NewSymbol: {
3135         compileNewSymbol(node);
3136         break;
3137     }
3138 
3139     case NewArray: {
3140         compileNewArray(node);
3141         break;
3142     }
3143 
3144     case NewArrayWithSpread: {
3145         compileNewArrayWithSpread(node);
3146         break;
3147     }
3148 
3149     case Spread: {
3150         compileSpread(node);
3151         break;
3152     }
3153 
3154     case NewArrayWithSize: {
3155         compileNewArrayWithSize(node);
3156         break;
3157     }
3158 
3159     case NewArrayBuffer: {
3160         compileNewArrayBuffer(node);
3161         break;
3162     }
3163 
3164     case NewTypedArray: {
3165         compileNewTypedArray(node);
3166         break;
3167     }
3168 
3169     case NewRegexp: {
3170         compileNewRegexp(node);
3171         break;
3172     }
3173 
3174     case ToObject:
3175     case CallObjectConstructor: {
3176         compileToObjectOrCallObjectConstructor(node);
3177         break;
3178     }
3179 
3180     case ToThis: {
3181         compileToThis(node);
3182         break;
3183     }
3184 
3185     case ObjectCreate: {
3186         compileObjectCreate(node);
3187         break;
3188     }
3189 
3190     case ObjectKeys: {
3191         compileObjectKeys(node);
3192         break;
3193     }
3194 
3195     case CreateThis: {
3196         compileCreateThis(node);
3197         break;
3198     }
3199 
3200     case NewObject: {
3201         compileNewObject(node);
3202         break;
3203     }
3204 
3205     case GetCallee: {
3206         compileGetCallee(node);
3207         break;
3208     }
3209 
3210     case SetCallee: {
3211         compileSetCallee(node);
3212         break;
3213     }
3214 
3215     case GetArgumentCountIncludingThis: {
3216         compileGetArgumentCountIncludingThis(node);
3217         break;
3218     }
3219 
3220     case SetArgumentCountIncludingThis:
3221         compileSetArgumentCountIncludingThis(node);
3222         break;
3223 
3224     case GetScope:
3225         compileGetScope(node);
3226         break;
3227 
3228     case SkipScope:
3229         compileSkipScope(node);
3230         break;
3231 
3232     case GetGlobalObject:
3233         compileGetGlobalObject(node);
3234         break;
3235 
3236     case GetGlobalThis:
3237         compileGetGlobalThis(node);
3238         break;
3239 
3240     case GetClosureVar: {
3241         compileGetClosureVar(node);
3242         break;
3243     }
3244 
3245     case PutClosureVar: {
3246         compilePutClosureVar(node);
3247         break;
3248     }
3249 
3250     case TryGetById: {
3251         compileGetById(node, AccessType::TryGet);
3252         break;
3253     }
3254 
3255     case GetByIdDirect: {
3256         compileGetById(node, AccessType::GetDirect);
3257         break;
3258     }
3259 
3260     case GetByIdDirectFlush: {
3261         compileGetByIdFlush(node, AccessType::GetDirect);
3262         break;
3263     }
3264 
3265     case GetById: {
3266         compileGetById(node, AccessType::Get);
3267         break;
3268     }
3269 
3270     case GetByIdFlush: {
3271         compileGetByIdFlush(node, AccessType::Get);
3272         break;
3273     }
3274 
3275     case GetByIdWithThis: {
3276         if (node-&gt;child1().useKind() == CellUse &amp;&amp; node-&gt;child2().useKind() == CellUse) {
3277             SpeculateCellOperand base(this, node-&gt;child1());
3278             SpeculateCellOperand thisValue(this, node-&gt;child2());
3279             GPRTemporary resultTag(this);
3280             GPRTemporary resultPayload(this);
3281 
3282             GPRReg baseGPR = base.gpr();
3283             GPRReg thisGPR = thisValue.gpr();
3284             GPRReg resultTagGPR = resultTag.gpr();
3285             GPRReg resultPayloadGPR = resultPayload.gpr();
3286 
3287             cachedGetByIdWithThis(node-&gt;origin.semantic, InvalidGPRReg, baseGPR, InvalidGPRReg, thisGPR, resultTagGPR, resultPayloadGPR, node-&gt;identifierNumber());
3288 
3289             jsValueResult(resultTagGPR, resultPayloadGPR, node);
3290         } else {
3291             JSValueOperand base(this, node-&gt;child1());
3292             JSValueOperand thisValue(this, node-&gt;child2());
3293             GPRTemporary resultTag(this);
3294             GPRTemporary resultPayload(this);
3295 
3296             GPRReg baseTagGPR = base.tagGPR();
3297             GPRReg basePayloadGPR = base.payloadGPR();
3298             GPRReg thisTagGPR = thisValue.tagGPR();
3299             GPRReg thisPayloadGPR = thisValue.payloadGPR();
3300             GPRReg resultTagGPR = resultTag.gpr();
3301             GPRReg resultPayloadGPR = resultPayload.gpr();
3302 
3303             JITCompiler::JumpList notCellList;
3304             notCellList.append(m_jit.branchIfNotCell(base.jsValueRegs()));
3305             notCellList.append(m_jit.branchIfNotCell(thisValue.jsValueRegs()));
3306 
3307             cachedGetByIdWithThis(node-&gt;origin.semantic, baseTagGPR, basePayloadGPR, thisTagGPR, thisPayloadGPR, resultTagGPR, resultPayloadGPR, node-&gt;identifierNumber(), notCellList);
3308 
3309             jsValueResult(resultTagGPR, resultPayloadGPR, node);
3310         }
3311 
3312         break;
3313     }
3314 
3315     case GetArrayLength:
3316         compileGetArrayLength(node);
3317         break;
3318 
3319     case DeleteById: {
3320         compileDeleteById(node);
3321         break;
3322     }
3323 
3324     case DeleteByVal: {
3325         compileDeleteByVal(node);
3326         break;
3327     }
3328 
3329     case CheckCell: {
3330         compileCheckCell(node);
3331         break;
3332     }
3333 
3334     case CheckNotEmpty: {
3335         compileCheckNotEmpty(node);
3336         break;
3337     }
3338 
3339     case CheckStringIdent:
3340         compileCheckStringIdent(node);
3341         break;
3342 
3343     case GetExecutable: {
3344         compileGetExecutable(node);
3345         break;
3346     }
3347 
3348     case CheckStructure: {
3349         compileCheckStructure(node);
3350         break;
3351     }
3352 
3353     case PutStructure: {
3354         RegisteredStructure oldStructure = node-&gt;transition()-&gt;previous;
3355         RegisteredStructure newStructure = node-&gt;transition()-&gt;next;
3356 
3357         m_jit.jitCode()-&gt;common.notifyCompilingStructureTransition(m_jit.graph().m_plan, m_jit.codeBlock(), node);
3358 
3359         SpeculateCellOperand base(this, node-&gt;child1());
3360         GPRReg baseGPR = base.gpr();
3361 
3362         ASSERT_UNUSED(oldStructure, oldStructure-&gt;indexingMode() == newStructure-&gt;indexingMode());
3363         ASSERT(oldStructure-&gt;typeInfo().type() == newStructure-&gt;typeInfo().type());
3364         ASSERT(oldStructure-&gt;typeInfo().inlineTypeFlags() == newStructure-&gt;typeInfo().inlineTypeFlags());
3365         m_jit.storePtr(TrustedImmPtr(newStructure), MacroAssembler::Address(baseGPR, JSCell::structureIDOffset()));
3366 
3367         noResult(node);
3368         break;
3369     }
3370 
3371     case AllocatePropertyStorage:
3372         compileAllocatePropertyStorage(node);
3373         break;
3374 
3375     case ReallocatePropertyStorage:
3376         compileReallocatePropertyStorage(node);
3377         break;
3378 
3379     case NukeStructureAndSetButterfly:
3380         compileNukeStructureAndSetButterfly(node);
3381         break;
3382 
3383     case GetButterfly:
3384         compileGetButterfly(node);
3385         break;
3386 
3387     case GetIndexedPropertyStorage: {
3388         compileGetIndexedPropertyStorage(node);
3389         break;
3390     }
3391 
3392     case ConstantStoragePointer: {
3393         compileConstantStoragePointer(node);
3394         break;
3395     }
3396 
3397     case GetTypedArrayByteOffset: {
3398         compileGetTypedArrayByteOffset(node);
3399         break;
3400     }
3401 
3402     case GetPrototypeOf: {
3403         compileGetPrototypeOf(node);
3404         break;
3405     }
3406 
3407     case GetByOffset: {
3408         compileGetByOffset(node);
3409         break;
3410     }
3411 
3412     case GetGetterSetterByOffset: {
3413         StorageOperand storage(this, node-&gt;child1());
3414         GPRTemporary resultPayload(this);
3415 
3416         GPRReg storageGPR = storage.gpr();
3417         GPRReg resultPayloadGPR = resultPayload.gpr();
3418 
3419         StorageAccessData&amp; storageAccessData = node-&gt;storageAccessData();
3420 
3421         m_jit.load32(JITCompiler::Address(storageGPR, offsetRelativeToBase(storageAccessData.offset) + OBJECT_OFFSETOF(EncodedValueDescriptor, asBits.payload)), resultPayloadGPR);
3422 
3423         cellResult(resultPayloadGPR, node);
3424         break;
3425     }
3426 
3427     case MatchStructure: {
3428         compileMatchStructure(node);
3429         break;
3430     }
3431 
3432     case GetGetter: {
3433         compileGetGetter(node);
3434         break;
3435     }
3436 
3437     case GetSetter: {
3438         compileGetSetter(node);
3439         break;
3440     }
3441 
3442     case PutByOffset: {
3443         compilePutByOffset(node);
3444         break;
3445     }
3446 
3447     case PutByIdFlush: {
3448         compilePutByIdFlush(node);
3449         break;
3450     }
3451 
3452     case PutById: {
3453         compilePutById(node);
3454         break;
3455     }
3456 
3457     case PutByIdDirect: {
3458         compilePutByIdDirect(node);
3459         break;
3460     }
3461 
3462     case PutByIdWithThis: {
3463         compilePutByIdWithThis(node);
3464         break;
3465     }
3466 
3467     case PutGetterById:
3468     case PutSetterById: {
3469         compilePutAccessorById(node);
3470         break;
3471     }
3472 
3473     case PutGetterSetterById: {
3474         compilePutGetterSetterById(node);
3475         break;
3476     }
3477 
3478     case PutGetterByVal:
3479     case PutSetterByVal: {
3480         compilePutAccessorByVal(node);
3481         break;
3482     }
3483 
3484     case DefineDataProperty: {
3485         compileDefineDataProperty(node);
3486         break;
3487     }
3488 
3489     case DefineAccessorProperty: {
3490         compileDefineAccessorProperty(node);
3491         break;
3492     }
3493 
3494     case GetGlobalLexicalVariable:
3495     case GetGlobalVar: {
3496         compileGetGlobalVariable(node);
3497         break;
3498     }
3499 
3500     case PutGlobalVariable: {
3501         compilePutGlobalVariable(node);
3502         break;
3503     }
3504 
3505     case NotifyWrite: {
3506         compileNotifyWrite(node);
3507         break;
3508     }
3509 
3510     case ParseInt: {
3511         compileParseInt(node);
3512         break;
3513     }
3514 
3515     case CheckTypeInfoFlags: {
3516         compileCheckTypeInfoFlags(node);
3517         break;
3518     }
3519 
3520     case OverridesHasInstance: {
3521         compileOverridesHasInstance(node);
3522         break;
3523     }
3524 
3525     case InstanceOf: {
3526         compileInstanceOf(node);
3527         break;
3528     }
3529 
3530     case InstanceOfCustom: {
3531         compileInstanceOfCustom(node);
3532         break;
3533     }
3534 
3535     case IsEmpty: {
3536         JSValueOperand value(this, node-&gt;child1());
3537         GPRTemporary result(this, Reuse, value, TagWord);
3538         m_jit.comparePtr(JITCompiler::Equal, value.tagGPR(), TrustedImm32(JSValue::EmptyValueTag), result.gpr());
3539         booleanResult(result.gpr(), node);
3540         break;
3541     }
3542 
3543     case IsUndefined: {
3544         JSValueOperand value(this, node-&gt;child1());
3545         GPRTemporary result(this);
3546         GPRTemporary localGlobalObject(this);
3547         GPRTemporary remoteGlobalObject(this);
3548 
3549         JITCompiler::Jump isCell = m_jit.branchIfCell(value.jsValueRegs());
3550 
3551         m_jit.compare32(JITCompiler::Equal, value.tagGPR(), TrustedImm32(JSValue::UndefinedTag), result.gpr());
3552         JITCompiler::Jump done = m_jit.jump();
3553 
3554         isCell.link(&amp;m_jit);
3555         JITCompiler::Jump notMasqueradesAsUndefined;
3556         if (masqueradesAsUndefinedWatchpointIsStillValid()) {
3557             m_jit.move(TrustedImm32(0), result.gpr());
3558             notMasqueradesAsUndefined = m_jit.jump();
3559         } else {
3560             JITCompiler::Jump isMasqueradesAsUndefined = m_jit.branchTest8(
3561                 JITCompiler::NonZero,
3562                 JITCompiler::Address(value.payloadGPR(), JSCell::typeInfoFlagsOffset()),
3563                 TrustedImm32(MasqueradesAsUndefined));
3564             m_jit.move(TrustedImm32(0), result.gpr());
3565             notMasqueradesAsUndefined = m_jit.jump();
3566 
3567             isMasqueradesAsUndefined.link(&amp;m_jit);
3568             GPRReg localGlobalObjectGPR = localGlobalObject.gpr();
3569             GPRReg remoteGlobalObjectGPR = remoteGlobalObject.gpr();
3570             m_jit.move(TrustedImmPtr::weakPointer(m_jit.graph(), m_jit.globalObjectFor(node-&gt;origin.semantic)), localGlobalObjectGPR);
3571             m_jit.loadPtr(JITCompiler::Address(value.payloadGPR(), JSCell::structureIDOffset()), result.gpr());
3572             m_jit.loadPtr(JITCompiler::Address(result.gpr(), Structure::globalObjectOffset()), remoteGlobalObjectGPR);
3573             m_jit.compare32(JITCompiler::Equal, localGlobalObjectGPR, remoteGlobalObjectGPR, result.gpr());
3574         }
3575 
3576         notMasqueradesAsUndefined.link(&amp;m_jit);
3577         done.link(&amp;m_jit);
3578         booleanResult(result.gpr(), node);
3579         break;
3580     }
3581 
3582     case IsUndefinedOrNull: {
3583         JSValueOperand value(this, node-&gt;child1());
3584         GPRTemporary result(this, Reuse, value, TagWord);
3585 
3586         GPRReg valueTagGPR = value.tagGPR();
3587         GPRReg resultGPR = result.gpr();
3588 
3589         m_jit.move(valueTagGPR, resultGPR);
3590         static_assert((JSValue::UndefinedTag + 1 == JSValue::NullTag) &amp;&amp; (JSValue::NullTag &amp; 0x1), &quot;&quot;);
3591         m_jit.or32(CCallHelpers::TrustedImm32(1), resultGPR);
3592         m_jit.compare32(CCallHelpers::Equal, resultGPR, CCallHelpers::TrustedImm32(JSValue::NullTag), resultGPR);
3593 
3594         booleanResult(resultGPR, node);
3595         break;
3596     }
3597 
3598 
3599     case IsBoolean: {
3600         JSValueOperand value(this, node-&gt;child1());
3601         GPRTemporary result(this, Reuse, value, TagWord);
3602 
3603         m_jit.compare32(JITCompiler::Equal, value.tagGPR(), JITCompiler::TrustedImm32(JSValue::BooleanTag), result.gpr());
3604         booleanResult(result.gpr(), node);
3605         break;
3606     }
3607 
3608     case IsNumber: {
3609         JSValueOperand value(this, node-&gt;child1());
3610         GPRTemporary result(this, Reuse, value, TagWord);
3611 
3612         m_jit.add32(TrustedImm32(1), value.tagGPR(), result.gpr());
3613         m_jit.compare32(JITCompiler::Below, result.gpr(), JITCompiler::TrustedImm32(JSValue::LowestTag + 1), result.gpr());
3614         booleanResult(result.gpr(), node);
3615         break;
3616     }
3617 
3618     case NumberIsInteger: {
3619         JSValueOperand input(this, node-&gt;child1());
3620         JSValueRegs inputRegs = input.jsValueRegs();
3621         flushRegisters();
3622         GPRFlushedCallResult result(this);
3623         GPRReg resultGPR = result.gpr();
3624         callOperation(operationNumberIsInteger, resultGPR, inputRegs);
3625         booleanResult(resultGPR, node);
3626         break;
3627     }
3628 
3629     case IsObject: {
3630         compileIsObject(node);
3631         break;
3632     }
3633 
3634     case IsObjectOrNull: {
3635         compileIsObjectOrNull(node);
3636         break;
3637     }
3638 
3639     case IsFunction: {
3640         compileIsFunction(node);
3641         break;
3642     }
3643 
3644     case IsCellWithType: {
3645         compileIsCellWithType(node);
3646         break;
3647     }
3648 
3649     case IsTypedArrayView: {
3650         compileIsTypedArrayView(node);
3651         break;
3652     }
3653 
3654     case TypeOf: {
3655         compileTypeOf(node);
3656         break;
3657     }
3658 
3659     case MapHash: {
3660         JSValueOperand input(this, node-&gt;child1());
3661 
3662         JSValueRegs inputRegs = input.jsValueRegs();
3663 
3664         flushRegisters();
3665         GPRFlushedCallResult result(this);
3666         GPRReg resultGPR = result.gpr();
3667         callOperation(operationMapHash, resultGPR, inputRegs);
3668         m_jit.exceptionCheck();
3669         int32Result(resultGPR, node);
3670         break;
3671     }
3672 
3673     case NormalizeMapKey: {
3674         compileNormalizeMapKey(node);
3675         break;
3676     }
3677 
3678     case GetMapBucket: {
3679         SpeculateCellOperand map(this, node-&gt;child1());
3680         JSValueOperand key(this, node-&gt;child2());
3681         SpeculateInt32Operand hash(this, node-&gt;child3());
3682 
3683         GPRReg mapGPR = map.gpr();
3684         JSValueRegs keyRegs = key.jsValueRegs();
3685         GPRReg hashGPR = hash.gpr();
3686 
3687         if (node-&gt;child1().useKind() == MapObjectUse)
3688             speculateMapObject(node-&gt;child1(), mapGPR);
3689         else if (node-&gt;child1().useKind() == SetObjectUse)
3690             speculateSetObject(node-&gt;child1(), mapGPR);
3691         else
3692             RELEASE_ASSERT_NOT_REACHED();
3693 
3694         flushRegisters();
3695         GPRFlushedCallResult result(this);
3696         GPRReg resultGPR = result.gpr();
3697         if (node-&gt;child1().useKind() == MapObjectUse)
3698             callOperation(operationJSMapFindBucket, resultGPR, mapGPR, keyRegs, hashGPR);
3699         else
3700             callOperation(operationJSSetFindBucket, resultGPR, mapGPR, keyRegs, hashGPR);
3701         m_jit.exceptionCheck();
3702         cellResult(resultGPR, node);
3703         break;
3704     }
3705 
3706     case GetMapBucketHead:
3707         compileGetMapBucketHead(node);
3708         break;
3709 
3710     case GetMapBucketNext:
3711         compileGetMapBucketNext(node);
3712         break;
3713 
3714     case LoadKeyFromMapBucket:
3715         compileLoadKeyFromMapBucket(node);
3716         break;
3717 
3718     case LoadValueFromMapBucket:
3719         compileLoadValueFromMapBucket(node);
3720         break;
3721 
3722     case ExtractValueFromWeakMapGet:
3723         compileExtractValueFromWeakMapGet(node);
3724         break;
3725 
3726     case SetAdd:
3727         compileSetAdd(node);
3728         break;
3729 
3730     case MapSet:
3731         compileMapSet(node);
3732         break;
3733 
3734     case WeakMapGet:
3735         compileWeakMapGet(node);
3736         break;
3737 
3738     case WeakSetAdd:
3739         compileWeakSetAdd(node);
3740         break;
3741 
3742     case WeakMapSet:
3743         compileWeakMapSet(node);
3744         break;
3745 
3746     case Flush:
3747         break;
3748 
3749     case Call:
3750     case TailCall:
3751     case TailCallInlinedCaller:
3752     case Construct:
3753     case CallVarargs:
3754     case TailCallVarargs:
3755     case TailCallVarargsInlinedCaller:
3756     case ConstructVarargs:
3757     case CallForwardVarargs:
3758     case TailCallForwardVarargs:
3759     case TailCallForwardVarargsInlinedCaller:
3760     case ConstructForwardVarargs:
3761     case CallEval:
3762     case DirectCall:
3763     case DirectConstruct:
3764     case DirectTailCall:
3765     case DirectTailCallInlinedCaller:
3766         emitCall(node);
3767         break;
3768 
3769     case LoadVarargs: {
3770         compileLoadVarargs(node);
3771         break;
3772     }
3773 
3774     case ForwardVarargs: {
3775         compileForwardVarargs(node);
3776         break;
3777     }
3778 
3779     case CreateActivation: {
3780         compileCreateActivation(node);
3781         break;
3782     }
3783 
3784     case PushWithScope: {
3785         compilePushWithScope(node);
3786         break;
3787     }
3788 
3789     case CreateDirectArguments: {
3790         compileCreateDirectArguments(node);
3791         break;
3792     }
3793 
3794     case GetFromArguments: {
3795         compileGetFromArguments(node);
3796         break;
3797     }
3798 
3799     case PutToArguments: {
3800         compilePutToArguments(node);
3801         break;
3802     }
3803 
3804     case GetArgument: {
3805         compileGetArgument(node);
3806         break;
3807     }
3808 
3809     case CreateScopedArguments: {
3810         compileCreateScopedArguments(node);
3811         break;
3812     }
3813 
3814     case CreateClonedArguments: {
3815         compileCreateClonedArguments(node);
3816         break;
3817     }
3818 
3819     case CreateRest: {
3820         compileCreateRest(node);
3821         break;
3822     }
3823 
3824     case GetRestLength: {
3825         compileGetRestLength(node);
3826         break;
3827     }
3828 
3829     case NewFunction:
3830     case NewGeneratorFunction:
3831     case NewAsyncFunction:
3832     case NewAsyncGeneratorFunction:
3833         compileNewFunction(node);
3834         break;
3835 
3836     case SetFunctionName:
3837         compileSetFunctionName(node);
3838         break;
3839 
3840     case InById:
3841         compileInById(node);
3842         break;
3843 
3844     case InByVal:
3845         compileInByVal(node);
3846         break;
3847 
3848     case HasOwnProperty: {
3849 #if CPU(X86)
3850         ASSERT(node-&gt;child2().useKind() == UntypedUse);
3851         SpeculateCellOperand object(this, node-&gt;child1());
3852         JSValueOperand key(this, node-&gt;child2());
3853         GPRTemporary result(this, Reuse, object);
3854 
3855         JSValueRegs keyRegs = key.jsValueRegs();
3856         GPRReg objectGPR = object.gpr();
3857         GPRReg resultGPR = result.gpr();
3858 
3859         speculateObject(node-&gt;child1());
3860 
3861         flushRegisters();
3862         callOperation(operationHasOwnProperty, resultGPR, objectGPR, keyRegs);
3863         booleanResult(resultGPR, node);
3864 #else
3865         SpeculateCellOperand object(this, node-&gt;child1());
3866         GPRTemporary uniquedStringImpl(this);
3867         GPRTemporary temp(this);
3868         GPRTemporary hash(this);
3869         GPRTemporary structureID(this);
3870         GPRTemporary result(this);
3871 
3872         Optional&lt;SpeculateCellOperand&gt; keyAsCell;
3873         Optional&lt;JSValueOperand&gt; keyAsValue;
3874         JSValueRegs keyRegs;
3875         if (node-&gt;child2().useKind() == UntypedUse) {
3876             keyAsValue.emplace(this, node-&gt;child2());
3877             keyRegs = keyAsValue-&gt;jsValueRegs();
3878         } else {
3879             ASSERT(node-&gt;child2().useKind() == StringUse || node-&gt;child2().useKind() == SymbolUse);
3880             keyAsCell.emplace(this, node-&gt;child2());
3881             keyRegs = JSValueRegs::payloadOnly(keyAsCell-&gt;gpr());
3882         }
3883 
3884         GPRReg objectGPR = object.gpr();
3885         GPRReg implGPR = uniquedStringImpl.gpr();
3886         GPRReg tempGPR = temp.gpr();
3887         GPRReg hashGPR = hash.gpr();
3888         GPRReg structureIDGPR = structureID.gpr();
3889         GPRReg resultGPR = result.gpr();
3890 
3891         speculateObject(node-&gt;child1());
3892 
3893         MacroAssembler::JumpList slowPath;
3894         switch (node-&gt;child2().useKind()) {
3895         case SymbolUse: {
3896             speculateSymbol(node-&gt;child2(), keyRegs.payloadGPR());
3897             m_jit.loadPtr(MacroAssembler::Address(keyRegs.payloadGPR(), Symbol::offsetOfSymbolImpl()), implGPR);
3898             break;
3899         }
3900         case StringUse: {
3901             speculateString(node-&gt;child2(), keyRegs.payloadGPR());
3902             m_jit.loadPtr(MacroAssembler::Address(keyRegs.payloadGPR(), JSString::offsetOfValue()), implGPR);
3903             slowPath.append(m_jit.branchIfRopeStringImpl(implGPR));
3904             slowPath.append(m_jit.branchTest32(
3905                 MacroAssembler::Zero, MacroAssembler::Address(implGPR, StringImpl::flagsOffset()),
<a name="23" id="anc23"></a><span class="line-modified">3906                 MacroAssembler::TrustedImm32(StringImpl::flagIsAtom())));</span>
3907             break;
3908         }
3909         case UntypedUse: {
3910             slowPath.append(m_jit.branchIfNotCell(keyRegs));
3911             auto isNotString = m_jit.branchIfNotString(keyRegs.payloadGPR());
3912             m_jit.loadPtr(MacroAssembler::Address(keyRegs.payloadGPR(), JSString::offsetOfValue()), implGPR);
3913             slowPath.append(m_jit.branchIfRopeStringImpl(implGPR));
3914             slowPath.append(m_jit.branchTest32(
3915                 MacroAssembler::Zero, MacroAssembler::Address(implGPR, StringImpl::flagsOffset()),
<a name="24" id="anc24"></a><span class="line-modified">3916                 MacroAssembler::TrustedImm32(StringImpl::flagIsAtom())));</span>
3917             auto hasUniquedImpl = m_jit.jump();
3918 
3919             isNotString.link(&amp;m_jit);
3920             slowPath.append(m_jit.branchIfNotSymbol(keyRegs.payloadGPR()));
3921             m_jit.loadPtr(MacroAssembler::Address(keyRegs.payloadGPR(), Symbol::offsetOfSymbolImpl()), implGPR);
3922 
3923             hasUniquedImpl.link(&amp;m_jit);
3924             break;
3925         }
3926         default:
3927             RELEASE_ASSERT_NOT_REACHED();
3928         }
3929 
<a name="25" id="anc25"></a><span class="line-modified">3930         // Note that we don&#39;t test if the hash is zero here. AtomStringImpl&#39;s can&#39;t have a zero</span>
3931         // hash, however, a SymbolImpl may. But, because this is a cache, we don&#39;t care. We only
3932         // ever load the result from the cache if the cache entry matches what we are querying for.
3933         // So we either get super lucky and use zero for the hash and somehow collide with the entity
3934         // we&#39;re looking for, or we realize we&#39;re comparing against another entity, and go to the
3935         // slow path anyways.
3936         m_jit.load32(MacroAssembler::Address(implGPR, UniquedStringImpl::flagsOffset()), hashGPR);
3937         m_jit.urshift32(MacroAssembler::TrustedImm32(StringImpl::s_flagCount), hashGPR);
3938         m_jit.load32(MacroAssembler::Address(objectGPR, JSCell::structureIDOffset()), structureIDGPR);
3939         m_jit.add32(structureIDGPR, hashGPR);
3940         m_jit.and32(TrustedImm32(HasOwnPropertyCache::mask), hashGPR);
3941         m_jit.mul32(TrustedImm32(sizeof(HasOwnPropertyCache::Entry)), hashGPR, hashGPR);
<a name="26" id="anc26"></a><span class="line-modified">3942         ASSERT(vm().hasOwnPropertyCache());</span>
<span class="line-modified">3943         m_jit.move(TrustedImmPtr(vm().hasOwnPropertyCache()), tempGPR);</span>
3944         slowPath.append(m_jit.branchPtr(MacroAssembler::NotEqual,
3945             MacroAssembler::BaseIndex(tempGPR, hashGPR, MacroAssembler::TimesOne, HasOwnPropertyCache::Entry::offsetOfImpl()), implGPR));
3946         m_jit.load8(MacroAssembler::BaseIndex(tempGPR, hashGPR, MacroAssembler::TimesOne, HasOwnPropertyCache::Entry::offsetOfResult()), resultGPR);
3947         m_jit.load32(MacroAssembler::BaseIndex(tempGPR, hashGPR, MacroAssembler::TimesOne, HasOwnPropertyCache::Entry::offsetOfStructureID()), tempGPR);
3948         slowPath.append(m_jit.branch32(MacroAssembler::NotEqual, tempGPR, structureIDGPR));
3949         auto done = m_jit.jump();
3950 
3951         slowPath.link(&amp;m_jit);
3952         silentSpillAllRegisters(resultGPR);
3953         if (node-&gt;child2().useKind() != UntypedUse) {
3954             m_jit.move(MacroAssembler::TrustedImm32(JSValue::CellTag), tempGPR);
3955             keyRegs = JSValueRegs(tempGPR, keyRegs.payloadGPR());
3956         }
3957         callOperation(operationHasOwnProperty, resultGPR, objectGPR, keyRegs);
3958         silentFillAllRegisters();
3959         m_jit.exceptionCheck();
3960 
3961         done.link(&amp;m_jit);
3962         booleanResult(resultGPR, node);
3963 #endif // CPU(X86)
3964         break;
3965     }
3966 
3967     case StoreBarrier:
3968     case FencedStoreBarrier: {
3969         compileStoreBarrier(node);
3970         break;
3971     }
3972 
3973     case GetEnumerableLength: {
3974         compileGetEnumerableLength(node);
3975         break;
3976     }
3977     case HasGenericProperty: {
3978         compileHasGenericProperty(node);
3979         break;
3980     }
3981     case HasStructureProperty: {
3982         compileHasStructureProperty(node);
3983         break;
3984     }
3985     case HasIndexedProperty: {
3986         compileHasIndexedProperty(node);
3987         break;
3988     }
3989     case GetDirectPname: {
3990         compileGetDirectPname(node);
3991         break;
3992     }
3993     case GetPropertyEnumerator: {
3994         compileGetPropertyEnumerator(node);
3995         break;
3996     }
3997     case GetEnumeratorStructurePname:
3998     case GetEnumeratorGenericPname: {
3999         compileGetEnumeratorPname(node);
4000         break;
4001     }
4002     case ToIndexString: {
4003         compileToIndexString(node);
4004         break;
4005     }
4006     case ProfileType: {
4007         compileProfileType(node);
4008         break;
4009     }
4010     case ProfileControlFlow: {
4011         GPRTemporary scratch1(this);
4012         BasicBlockLocation* basicBlockLocation = node-&gt;basicBlockLocation();
4013         basicBlockLocation-&gt;emitExecuteCode(m_jit, scratch1.gpr());
4014         noResult(node);
4015         break;
4016     }
4017 
4018     case LogShadowChickenPrologue: {
4019         compileLogShadowChickenPrologue(node);
4020         break;
4021     }
4022 
4023     case LogShadowChickenTail: {
4024         compileLogShadowChickenTail(node);
4025         break;
4026     }
4027 
4028     case ForceOSRExit: {
4029         terminateSpeculativeExecution(InadequateCoverage, JSValueRegs(), 0);
4030         break;
4031     }
4032 
4033     case InvalidationPoint:
4034         emitInvalidationPoint(node);
4035         break;
4036 
4037     case CheckTraps:
4038         compileCheckTraps(node);
4039         break;
4040 
4041     case CountExecution:
4042         m_jit.add64(TrustedImm32(1), MacroAssembler::AbsoluteAddress(node-&gt;executionCounter()-&gt;address()));
4043         break;
4044 
4045     case SuperSamplerBegin:
4046         m_jit.add32(TrustedImm32(1), MacroAssembler::AbsoluteAddress(bitwise_cast&lt;void*&gt;(&amp;g_superSamplerCount)));
4047         break;
4048 
4049     case SuperSamplerEnd:
4050         m_jit.sub32(TrustedImm32(1), MacroAssembler::AbsoluteAddress(bitwise_cast&lt;void*&gt;(&amp;g_superSamplerCount)));
4051         break;
4052 
4053     case Phantom:
4054     case Check:
4055     case CheckVarargs:
4056         DFG_NODE_DO_TO_CHILDREN(m_jit.graph(), node, speculate);
4057         noResult(node);
4058         break;
4059 
4060     case PhantomLocal:
4061     case LoopHint:
4062         // This is a no-op.
4063         noResult(node);
4064         break;
4065 
4066     case MaterializeNewObject:
4067         compileMaterializeNewObject(node);
4068         break;
4069 
4070     case PutDynamicVar: {
4071         compilePutDynamicVar(node);
4072         break;
4073     }
4074 
4075     case GetDynamicVar: {
4076         compileGetDynamicVar(node);
4077         break;
4078     }
4079 
4080     case ResolveScopeForHoistingFuncDeclInEval: {
4081         compileResolveScopeForHoistingFuncDeclInEval(node);
4082         break;
4083     }
4084 
4085     case ResolveScope: {
4086         compileResolveScope(node);
4087         break;
4088     }
4089 
4090     case CallDOM:
4091         compileCallDOM(node);
4092         break;
4093 
4094     case CallDOMGetter:
4095         compileCallDOMGetter(node);
4096         break;
4097 
4098     case CheckSubClass:
4099         compileCheckSubClass(node);
4100         break;
4101 
4102     case Unreachable:
4103         unreachable(node);
4104         break;
4105 
4106     case ExtractCatchLocal: {
4107         compileExtractCatchLocal(node);
4108         break;
4109     }
4110 
4111     case ClearCatchLocals:
4112         compileClearCatchLocals(node);
4113         break;
4114 
4115     case CheckStructureOrEmpty:
4116         DFG_CRASH(m_jit.graph(), node, &quot;CheckStructureOrEmpty only used in 64-bit DFG&quot;);
4117         break;
4118 
4119     case FilterCallLinkStatus:
4120     case FilterGetByIdStatus:
4121     case FilterPutByIdStatus:
4122     case FilterInByIdStatus:
4123         m_interpreter.filterICStatus(node);
4124         noResult(node);
4125         break;
4126 
4127     case LastNodeType:
4128     case Phi:
4129     case Upsilon:
4130     case ExtractOSREntryLocal:
4131     case CheckTierUpInLoop:
4132     case CheckTierUpAtReturn:
4133     case CheckTierUpAndOSREnter:
4134     case Int52Rep:
4135     case FiatInt52:
4136     case Int52Constant:
4137     case CheckInBounds:
4138     case ArithIMul:
4139     case MultiGetByOffset:
4140     case MultiPutByOffset:
4141     case CheckBadCell:
4142     case BottomValue:
4143     case PhantomNewObject:
4144     case PhantomNewFunction:
4145     case PhantomNewGeneratorFunction:
4146     case PhantomNewAsyncFunction:
4147     case PhantomNewAsyncGeneratorFunction:
4148     case PhantomCreateActivation:
4149     case PhantomNewRegexp:
4150     case PutHint:
4151     case CheckStructureImmediate:
4152     case MaterializeCreateActivation:
4153     case PutStack:
4154     case KillStack:
4155     case GetStack:
4156     case GetMyArgumentByVal:
4157     case GetMyArgumentByValOutOfBounds:
4158     case GetVectorLength:
4159     case PhantomCreateRest:
4160     case PhantomSpread:
4161     case PhantomNewArrayWithSpread:
4162     case PhantomNewArrayBuffer:
4163     case AtomicsIsLockFree:
4164     case AtomicsAdd:
4165     case AtomicsAnd:
4166     case AtomicsCompareExchange:
4167     case AtomicsExchange:
4168     case AtomicsLoad:
4169     case AtomicsOr:
4170     case AtomicsStore:
4171     case AtomicsSub:
4172     case AtomicsXor:
4173     case IdentityWithProfile:
4174     case InitializeEntrypointArguments:
4175     case EntrySwitch:
4176     case CPUIntrinsic:
4177     case AssertNotEmpty:
4178     case DataViewGetInt:
4179     case DataViewGetFloat:
4180     case DataViewSet:
4181         DFG_CRASH(m_jit.graph(), node, &quot;unexpected node in DFG backend&quot;);
4182         break;
4183     }
4184 
4185     if (!m_compileOkay)
4186         return;
4187 
4188     if (node-&gt;hasResult() &amp;&amp; node-&gt;mustGenerate())
4189         use(node);
4190 }
4191 
4192 void SpeculativeJIT::moveTrueTo(GPRReg gpr)
4193 {
4194     m_jit.move(TrustedImm32(1), gpr);
4195 }
4196 
4197 void SpeculativeJIT::moveFalseTo(GPRReg gpr)
4198 {
4199     m_jit.move(TrustedImm32(0), gpr);
4200 }
4201 
4202 void SpeculativeJIT::blessBoolean(GPRReg)
4203 {
4204 }
4205 
4206 void SpeculativeJIT::compileArithRandom(Node* node)
4207 {
4208     JSGlobalObject* globalObject = m_jit.graph().globalObjectFor(node-&gt;origin.semantic);
4209 
4210     flushRegisters();
4211 
4212     FPRResult result(this);
4213     callOperation(operationRandom, result.fpr(), globalObject);
4214     // operationRandom does not raise any exception.
4215     doubleResult(result.fpr(), node);
4216 }
4217 
4218 #endif
4219 
4220 } } // namespace JSC::DFG
4221 
4222 #endif
<a name="27" id="anc27"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="27" type="hidden" />
</body>
</html>