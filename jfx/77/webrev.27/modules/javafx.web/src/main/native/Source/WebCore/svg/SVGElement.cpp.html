<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/svg/SVGElement.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (C) 2004, 2005, 2006, 2007, 2008 Nikolas Zimmermann &lt;zimmermann@kde.org&gt;
   3  * Copyright (C) 2004, 2005, 2006, 2008 Rob Buis &lt;buis@kde.org&gt;
   4  * Copyright (C) 2008-2019 Apple Inc. All rights reserved.
   5  * Copyright (C) 2008 Alp Toker &lt;alp@atoker.com&gt;
   6  * Copyright (C) 2009 Cameron McCormack &lt;cam@mcc.id.au&gt;
   7  * Copyright (C) 2013 Samsung Electronics. All rights reserved.
   8  * Copyright (C) 2014 Adobe Systems Incorporated. All rights reserved.
   9  *
  10  * This library is free software; you can redistribute it and/or
  11  * modify it under the terms of the GNU Library General Public
  12  * License as published by the Free Software Foundation; either
  13  * version 2 of the License, or (at your option) any later version.
  14  *
  15  * This library is distributed in the hope that it will be useful,
  16  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  17  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  18  * Library General Public License for more details.
  19  *
  20  * You should have received a copy of the GNU Library General Public License
  21  * along with this library; see the file COPYING.LIB.  If not, write to
  22  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  23  * Boston, MA 02110-1301, USA.
  24  */
  25 
  26 #include &quot;config.h&quot;
  27 #include &quot;SVGElement.h&quot;
  28 
  29 #include &quot;CSSPropertyParser.h&quot;
  30 #include &quot;DeprecatedCSSOMValue.h&quot;
  31 #include &quot;Document.h&quot;
  32 #include &quot;ElementIterator.h&quot;
  33 #include &quot;Event.h&quot;
  34 #include &quot;EventNames.h&quot;
  35 #include &quot;HTMLElement.h&quot;
  36 #include &quot;HTMLNames.h&quot;
  37 #include &quot;HTMLParserIdioms.h&quot;
  38 #include &quot;RenderObject.h&quot;
  39 #include &quot;RenderSVGResource.h&quot;
  40 #include &quot;RenderSVGResourceFilter.h&quot;
  41 #include &quot;RenderSVGResourceMasker.h&quot;
  42 #include &quot;SVGDocumentExtensions.h&quot;
  43 #include &quot;SVGElementRareData.h&quot;
  44 #include &quot;SVGGraphicsElement.h&quot;
  45 #include &quot;SVGImageElement.h&quot;
  46 #include &quot;SVGNames.h&quot;
  47 #include &quot;SVGPropertyAnimatorFactory.h&quot;
  48 #include &quot;SVGRenderStyle.h&quot;
  49 #include &quot;SVGRenderSupport.h&quot;
  50 #include &quot;SVGSVGElement.h&quot;
  51 #include &quot;SVGTitleElement.h&quot;
  52 #include &quot;SVGUseElement.h&quot;
  53 #include &quot;ShadowRoot.h&quot;
  54 #include &quot;XMLNames.h&quot;
  55 #include &lt;wtf/Assertions.h&gt;
  56 #include &lt;wtf/HashMap.h&gt;
  57 #include &lt;wtf/IsoMallocInlines.h&gt;
  58 #include &lt;wtf/NeverDestroyed.h&gt;
  59 #include &lt;wtf/StdLibExtras.h&gt;
  60 #include &lt;wtf/text/WTFString.h&gt;
  61 
  62 
  63 namespace WebCore {
  64 
  65 WTF_MAKE_ISO_ALLOCATED_IMPL(SVGElement);
  66 
  67 static NEVER_INLINE HashMap&lt;AtomStringImpl*, CSSPropertyID&gt; createAttributeNameToCSSPropertyIDMap()
  68 {
  69     using namespace HTMLNames;
  70     using namespace SVGNames;
  71 
  72     // This list should include all base CSS and SVG CSS properties which are exposed as SVG XML attributes.
  73     static const QualifiedName* const attributeNames[] = {
  74         &amp;alignment_baselineAttr.get(),
  75         &amp;baseline_shiftAttr.get(),
  76         &amp;buffered_renderingAttr.get(),
  77         &amp;clipAttr.get(),
  78         &amp;clip_pathAttr.get(),
  79         &amp;clip_ruleAttr.get(),
  80         &amp;SVGNames::colorAttr.get(),
  81         &amp;color_interpolationAttr.get(),
  82         &amp;color_interpolation_filtersAttr.get(),
  83         &amp;color_profileAttr.get(),
  84         &amp;color_renderingAttr.get(),
  85         &amp;cursorAttr.get(),
  86         &amp;cxAttr.get(),
  87         &amp;cyAttr.get(),
  88         &amp;SVGNames::directionAttr.get(),
  89         &amp;displayAttr.get(),
  90         &amp;dominant_baselineAttr.get(),
  91         &amp;enable_backgroundAttr.get(),
  92         &amp;fillAttr.get(),
  93         &amp;fill_opacityAttr.get(),
  94         &amp;fill_ruleAttr.get(),
  95         &amp;filterAttr.get(),
  96         &amp;flood_colorAttr.get(),
  97         &amp;flood_opacityAttr.get(),
  98         &amp;font_familyAttr.get(),
  99         &amp;font_sizeAttr.get(),
 100         &amp;font_stretchAttr.get(),
 101         &amp;font_styleAttr.get(),
 102         &amp;font_variantAttr.get(),
 103         &amp;font_weightAttr.get(),
 104         &amp;glyph_orientation_horizontalAttr.get(),
 105         &amp;glyph_orientation_verticalAttr.get(),
 106         &amp;image_renderingAttr.get(),
 107         &amp;SVGNames::heightAttr.get(),
 108         &amp;kerningAttr.get(),
 109         &amp;letter_spacingAttr.get(),
 110         &amp;lighting_colorAttr.get(),
 111         &amp;marker_endAttr.get(),
 112         &amp;marker_midAttr.get(),
 113         &amp;marker_startAttr.get(),
 114         &amp;maskAttr.get(),
 115         &amp;mask_typeAttr.get(),
 116         &amp;opacityAttr.get(),
 117         &amp;overflowAttr.get(),
 118         &amp;paint_orderAttr.get(),
 119         &amp;pointer_eventsAttr.get(),
 120         &amp;rAttr.get(),
 121         &amp;rxAttr.get(),
 122         &amp;ryAttr.get(),
 123         &amp;shape_renderingAttr.get(),
 124         &amp;stop_colorAttr.get(),
 125         &amp;stop_opacityAttr.get(),
 126         &amp;strokeAttr.get(),
 127         &amp;stroke_dasharrayAttr.get(),
 128         &amp;stroke_dashoffsetAttr.get(),
 129         &amp;stroke_linecapAttr.get(),
 130         &amp;stroke_linejoinAttr.get(),
 131         &amp;stroke_miterlimitAttr.get(),
 132         &amp;stroke_opacityAttr.get(),
 133         &amp;stroke_widthAttr.get(),
 134         &amp;text_anchorAttr.get(),
 135         &amp;text_decorationAttr.get(),
 136         &amp;text_renderingAttr.get(),
 137         &amp;unicode_bidiAttr.get(),
 138         &amp;vector_effectAttr.get(),
 139         &amp;visibilityAttr.get(),
 140         &amp;SVGNames::widthAttr.get(),
 141         &amp;word_spacingAttr.get(),
 142         &amp;writing_modeAttr.get(),
 143         &amp;xAttr.get(),
 144         &amp;yAttr.get(),
 145     };
 146 
 147     HashMap&lt;AtomStringImpl*, CSSPropertyID&gt; map;
 148 
 149     for (auto&amp; name : attributeNames) {
 150         const AtomString&amp; localName = name-&gt;localName();
 151         map.add(localName.impl(), cssPropertyID(localName));
 152     }
 153 
 154     // FIXME: When CSS supports &quot;transform-origin&quot; this special case can be removed,
 155     // and we can add transform_originAttr to the table above instead.
 156     map.add(transform_originAttr-&gt;localName().impl(), CSSPropertyTransformOrigin);
 157 
 158     return map;
 159 }
 160 
 161 SVGElement::SVGElement(const QualifiedName&amp; tagName, Document&amp; document)
 162     : StyledElement(tagName, document, CreateSVGElement)
 163     , SVGLangSpace(this)
 164     , m_propertyAnimatorFactory(makeUnique&lt;SVGPropertyAnimatorFactory&gt;())
 165 {
 166     static std::once_flag onceFlag;
 167     std::call_once(onceFlag, [] {
 168         PropertyRegistry::registerProperty&lt;HTMLNames::classAttr, &amp;SVGElement::m_className&gt;();
 169     });
 170 }
 171 
 172 SVGElement::~SVGElement()
 173 {
 174     if (m_svgRareData) {
 175         for (SVGElement* instance : m_svgRareData-&gt;instances())
 176             instance-&gt;m_svgRareData-&gt;setCorrespondingElement(nullptr);
 177         if (auto correspondingElement = makeRefPtr(m_svgRareData-&gt;correspondingElement()))
 178             correspondingElement-&gt;m_svgRareData-&gt;instances().remove(this);
 179 
 180         m_svgRareData = nullptr;
 181     }
 182     document().accessSVGExtensions().rebuildAllElementReferencesForTarget(*this);
 183     document().accessSVGExtensions().removeAllElementReferencesForTarget(*this);
 184 }
 185 
 186 void SVGElement::willRecalcStyle(Style::Change change)
 187 {
 188     if (!m_svgRareData || styleResolutionShouldRecompositeLayer())
 189         return;
 190     // If the style changes because of a regular property change (not induced by SMIL animations themselves)
 191     // reset the &quot;computed style without SMIL style properties&quot;, so the base value change gets reflected.
 192     if (change &gt; Style::NoChange || needsStyleRecalc())
 193         m_svgRareData-&gt;setNeedsOverrideComputedStyleUpdate();
 194 }
 195 
 196 SVGElementRareData&amp; SVGElement::ensureSVGRareData()
 197 {
 198     if (!m_svgRareData)
 199         m_svgRareData = makeUnique&lt;SVGElementRareData&gt;();
 200     return *m_svgRareData;
 201 }
 202 
 203 bool SVGElement::isOutermostSVGSVGElement() const
 204 {
 205     if (!is&lt;SVGSVGElement&gt;(*this))
 206         return false;
 207 
 208     // If we&#39;re living in a shadow tree, we&#39;re a &lt;svg&gt; element that got created as replacement
 209     // for a &lt;symbol&gt; element or a cloned &lt;svg&gt; element in the referenced tree. In that case
 210     // we&#39;re always an inner &lt;svg&gt; element.
 211     if (isInShadowTree() &amp;&amp; parentOrShadowHostElement() &amp;&amp; parentOrShadowHostElement()-&gt;isSVGElement())
 212         return false;
 213 
 214     // Element may not be in the document, pretend we&#39;re outermost for viewport(), getCTM(), etc.
 215     if (!parentNode())
 216         return true;
 217 
 218     // We act like an outermost SVG element, if we&#39;re a direct child of a &lt;foreignObject&gt; element.
 219     if (parentNode()-&gt;hasTagName(SVGNames::foreignObjectTag))
 220         return true;
 221 
 222     // This is true whenever this is the outermost SVG, even if there are HTML elements outside it
 223     return !parentNode()-&gt;isSVGElement();
 224 }
 225 
 226 void SVGElement::reportAttributeParsingError(SVGParsingError error, const QualifiedName&amp; name, const AtomString&amp; value)
 227 {
 228     if (error == NoError)
 229         return;
 230 
 231     String errorString = &quot;&lt;&quot; + tagName() + &quot;&gt; attribute &quot; + name.toString() + &quot;=\&quot;&quot; + value + &quot;\&quot;&quot;;
 232     SVGDocumentExtensions&amp; extensions = document().accessSVGExtensions();
 233 
 234     if (error == NegativeValueForbiddenError) {
 235         extensions.reportError(&quot;Invalid negative value for &quot; + errorString);
 236         return;
 237     }
 238 
 239     if (error == ParsingAttributeFailedError) {
 240         extensions.reportError(&quot;Invalid value for &quot; + errorString);
 241         return;
 242     }
 243 
 244     ASSERT_NOT_REACHED();
 245 }
 246 
 247 void SVGElement::removedFromAncestor(RemovalType removalType, ContainerNode&amp; oldParentOfRemovedTree)
 248 {
 249     if (removalType.disconnectedFromDocument)
 250         updateRelativeLengthsInformation(false, this);
 251 
 252     StyledElement::removedFromAncestor(removalType, oldParentOfRemovedTree);
 253 
 254     if (removalType.disconnectedFromDocument) {
 255         document().accessSVGExtensions().clearTargetDependencies(*this);
 256         document().accessSVGExtensions().removeAllElementReferencesForTarget(*this);
 257     }
 258     invalidateInstances();
 259 }
 260 
 261 SVGSVGElement* SVGElement::ownerSVGElement() const
 262 {
 263     ContainerNode* node = parentOrShadowHostNode();
 264     while (node) {
 265         if (is&lt;SVGSVGElement&gt;(*node))
 266             return downcast&lt;SVGSVGElement&gt;(node);
 267 
 268         node = node-&gt;parentOrShadowHostNode();
 269     }
 270 
 271     return nullptr;
 272 }
 273 
 274 SVGElement* SVGElement::viewportElement() const
 275 {
 276     // This function needs shadow tree support - as RenderSVGContainer uses this function
 277     // to determine the &quot;overflow&quot; property. &lt;use&gt; on &lt;symbol&gt; wouldn&#39;t work otherwhise.
 278     ContainerNode* node = parentOrShadowHostNode();
 279     while (node) {
 280         if (is&lt;SVGSVGElement&gt;(*node) || is&lt;SVGImageElement&gt;(*node) || node-&gt;hasTagName(SVGNames::symbolTag))
 281             return downcast&lt;SVGElement&gt;(node);
 282 
 283         node = node-&gt;parentOrShadowHostNode();
 284     }
 285 
 286     return nullptr;
 287 }
 288 
 289 const HashSet&lt;SVGElement*&gt;&amp; SVGElement::instances() const
 290 {
 291     if (!m_svgRareData) {
 292         static NeverDestroyed&lt;HashSet&lt;SVGElement*&gt;&gt; emptyInstances;
 293         return emptyInstances;
 294     }
 295     return m_svgRareData-&gt;instances();
 296 }
 297 
 298 bool SVGElement::getBoundingBox(FloatRect&amp; rect, SVGLocatable::StyleUpdateStrategy styleUpdateStrategy)
 299 {
 300     if (is&lt;SVGGraphicsElement&gt;(*this)) {
 301         rect = downcast&lt;SVGGraphicsElement&gt;(*this).getBBox(styleUpdateStrategy);
 302         return true;
 303     }
 304     return false;
 305 }
 306 
 307 SVGElement* SVGElement::correspondingElement() const
 308 {
 309     return m_svgRareData ? m_svgRareData-&gt;correspondingElement() : nullptr;
 310 }
 311 
 312 RefPtr&lt;SVGUseElement&gt; SVGElement::correspondingUseElement() const
 313 {
 314     auto* root = containingShadowRoot();
 315     if (!root)
 316         return nullptr;
 317     if (root-&gt;mode() != ShadowRootMode::UserAgent)
 318         return nullptr;
 319     auto* host = root-&gt;host();
 320     if (!is&lt;SVGUseElement&gt;(host))
 321         return nullptr;
 322     return &amp;downcast&lt;SVGUseElement&gt;(*host);
 323 }
 324 
 325 void SVGElement::setCorrespondingElement(SVGElement* correspondingElement)
 326 {
 327     if (m_svgRareData) {
 328         if (auto oldCorrespondingElement = makeRefPtr(m_svgRareData-&gt;correspondingElement()))
 329             oldCorrespondingElement-&gt;m_svgRareData-&gt;instances().remove(this);
 330     }
 331     if (m_svgRareData || correspondingElement)
 332         ensureSVGRareData().setCorrespondingElement(correspondingElement);
 333     if (correspondingElement)
 334         correspondingElement-&gt;ensureSVGRareData().instances().add(this);
 335 }
 336 
 337 void SVGElement::parseAttribute(const QualifiedName&amp; name, const AtomString&amp; value)
 338 {
 339     if (name == HTMLNames::classAttr) {
 340         m_className-&gt;setBaseValInternal(value);
 341         return;
 342     }
 343 
 344     if (name == HTMLNames::tabindexAttr) {
 345         if (value.isEmpty())
 346             clearTabIndexExplicitlyIfNeeded();
 347         else if (auto optionalTabIndex = parseHTMLInteger(value))
 348             setTabIndexExplicitly(optionalTabIndex.value());
 349         return;
 350     }
 351 
 352     auto&amp; eventName = HTMLElement::eventNameForEventHandlerAttribute(name);
 353     if (!eventName.isNull()) {
 354         setAttributeEventListener(eventName, name, value);
 355         return;
 356     }
 357 
 358     SVGLangSpace::parseAttribute(name, value);
 359 }
 360 
 361 bool SVGElement::haveLoadedRequiredResources()
 362 {
 363     for (auto&amp; child : childrenOfType&lt;SVGElement&gt;(*this)) {
 364         if (!child.haveLoadedRequiredResources())
 365             return false;
 366     }
 367     return true;
 368 }
 369 
 370 bool SVGElement::addEventListener(const AtomString&amp; eventType, Ref&lt;EventListener&gt;&amp;&amp; listener, const AddEventListenerOptions&amp; options)
 371 {
 372     // Add event listener to regular DOM element
 373     if (!Node::addEventListener(eventType, listener.copyRef(), options))
 374         return false;
 375 
 376     if (containingShadowRoot())
 377         return true;
 378 
 379     // Add event listener to all shadow tree DOM element instances
 380     ASSERT(!instanceUpdatesBlocked());
 381     for (auto* instance : instances()) {
 382         ASSERT(instance-&gt;correspondingElement() == this);
 383         bool result = instance-&gt;Node::addEventListener(eventType, listener.copyRef(), options);
 384         ASSERT_UNUSED(result, result);
 385     }
 386 
 387     return true;
 388 }
 389 
 390 bool SVGElement::removeEventListener(const AtomString&amp; eventType, EventListener&amp; listener, const ListenerOptions&amp; options)
 391 {
 392     if (containingShadowRoot())
 393         return Node::removeEventListener(eventType, listener, options);
 394 
 395     // EventTarget::removeEventListener creates a Ref around the given EventListener
 396     // object when creating a temporary RegisteredEventListener object used to look up the
 397     // event listener in a cache. If we want to be able to call removeEventListener() multiple
 398     // times on different nodes, we have to delay its immediate destruction, which would happen
 399     // after the first call below.
 400     Ref&lt;EventListener&gt; protector(listener);
 401 
 402     // Remove event listener from regular DOM element
 403     if (!Node::removeEventListener(eventType, listener, options))
 404         return false;
 405 
 406     // Remove event listener from all shadow tree DOM element instances
 407     ASSERT(!instanceUpdatesBlocked());
 408     for (auto&amp; instance : instances()) {
 409         ASSERT(instance-&gt;correspondingElement() == this);
 410 
 411         if (instance-&gt;Node::removeEventListener(eventType, listener, options))
 412             continue;
 413 
 414         // This case can only be hit for event listeners created from markup
 415         ASSERT(listener.wasCreatedFromMarkup());
 416 
 417         // If the event listener &#39;listener&#39; has been created from markup and has been fired before
 418         // then JSLazyEventListener::parseCode() has been called and m_jsFunction of that listener
 419         // has been created (read: it&#39;s not 0 anymore). During shadow tree creation, the event
 420         // listener DOM attribute has been cloned, and another event listener has been setup in
 421         // the shadow tree. If that event listener has not been used yet, m_jsFunction is still 0,
 422         // and tryRemoveEventListener() above will fail. Work around that very rare problem.
 423         ASSERT(instance-&gt;eventTargetData());
 424         instance-&gt;eventTargetData()-&gt;eventListenerMap.removeFirstEventListenerCreatedFromMarkup(eventType);
 425     }
 426 
 427     return true;
 428 }
 429 
 430 static bool hasLoadListener(Element* element)
 431 {
 432     if (element-&gt;hasEventListeners(eventNames().loadEvent))
 433         return true;
 434 
 435     for (element = element-&gt;parentOrShadowHostElement(); element; element = element-&gt;parentOrShadowHostElement()) {
 436         if (element-&gt;hasCapturingEventListeners(eventNames().loadEvent))
 437             return true;
 438     }
 439 
 440     return false;
 441 }
 442 
 443 void SVGElement::sendSVGLoadEventIfPossible(bool sendParentLoadEvents)
 444 {
 445     if (!isConnected() || !document().frame())
 446         return;
 447 
 448     RefPtr&lt;SVGElement&gt; currentTarget = this;
 449     while (currentTarget &amp;&amp; currentTarget-&gt;haveLoadedRequiredResources()) {
 450         RefPtr&lt;Element&gt; parent;
 451         if (sendParentLoadEvents)
 452             parent = currentTarget-&gt;parentOrShadowHostElement(); // save the next parent to dispatch too incase dispatching the event changes the tree
 453         if (hasLoadListener(currentTarget.get()))
 454             currentTarget-&gt;dispatchEvent(Event::create(eventNames().loadEvent, Event::CanBubble::No, Event::IsCancelable::No));
 455         currentTarget = (parent &amp;&amp; parent-&gt;isSVGElement()) ? static_pointer_cast&lt;SVGElement&gt;(parent) : RefPtr&lt;SVGElement&gt;();
 456         SVGElement* element = currentTarget.get();
 457         if (!element || !element-&gt;isOutermostSVGSVGElement())
 458             continue;
 459 
 460         // Consider &lt;svg onload=&quot;foo()&quot;&gt;&lt;image xlink:href=&quot;foo.png&quot; externalResourcesRequired=&quot;true&quot;/&gt;&lt;/svg&gt;.
 461         // If foo.png is not yet loaded, the first SVGLoad event will go to the &lt;svg&gt; element, sent through
 462         // Document::implicitClose(). Then the SVGLoad event will fire for &lt;image&gt;, once its loaded.
 463         ASSERT(sendParentLoadEvents);
 464 
 465         // If the load event was not sent yet by Document::implicitClose(), but the &lt;image&gt; from the example
 466         // above, just appeared, don&#39;t send the SVGLoad event to the outermost &lt;svg&gt;, but wait for the document
 467         // to be &quot;ready to render&quot;, first.
 468         if (!document().loadEventFinished())
 469             break;
 470     }
 471 }
 472 
 473 void SVGElement::sendSVGLoadEventIfPossibleAsynchronously()
 474 {
 475     svgLoadEventTimer()-&gt;startOneShot(0_s);
 476 }
 477 
 478 void SVGElement::svgLoadEventTimerFired()
 479 {
 480     sendSVGLoadEventIfPossible();
 481 }
 482 
 483 Timer* SVGElement::svgLoadEventTimer()
 484 {
 485     ASSERT_NOT_REACHED();
 486     return nullptr;
 487 }
 488 
 489 void SVGElement::finishParsingChildren()
 490 {
 491     StyledElement::finishParsingChildren();
 492 
 493     // The outermost SVGSVGElement SVGLoad event is fired through Document::dispatchWindowLoadEvent.
 494     if (isOutermostSVGSVGElement())
 495         return;
 496 
 497     // finishParsingChildren() is called when the close tag is reached for an element (e.g. &lt;/svg&gt;)
 498     // we send SVGLoad events here if we can, otherwise they&#39;ll be sent when any required loads finish
 499     sendSVGLoadEventIfPossible();
 500 
 501     // Notify all the elements which have references to this element to rebuild their shadow and render
 502     // trees, e.g. a &lt;use&gt; element references a target element before this target element is defined.
 503     invalidateInstances();
 504 }
 505 
 506 bool SVGElement::childShouldCreateRenderer(const Node&amp; child) const
 507 {
 508     if (!child.isSVGElement())
 509         return false;
 510     auto&amp; svgChild = downcast&lt;SVGElement&gt;(child);
 511 
 512     static const QualifiedName* const invalidTextContent[] {
 513 #if ENABLE(SVG_FONTS)
 514         &amp;SVGNames::altGlyphTag.get(),
 515 #endif
 516         &amp;SVGNames::textPathTag.get(),
 517         &amp;SVGNames::trefTag.get(),
 518         &amp;SVGNames::tspanTag.get(),
 519     };
 520     auto&amp; name = svgChild.localName();
 521     for (auto* tag : invalidTextContent) {
 522         if (name == tag-&gt;localName())
 523             return false;
 524     }
 525 
 526     return svgChild.isValid();
 527 }
 528 
 529 void SVGElement::attributeChanged(const QualifiedName&amp; name, const AtomString&amp; oldValue, const AtomString&amp; newValue, AttributeModificationReason)
 530 {
 531     StyledElement::attributeChanged(name, oldValue, newValue);
 532 
 533     if (name == HTMLNames::idAttr)
 534         document().accessSVGExtensions().rebuildAllElementReferencesForTarget(*this);
 535 
 536     // Changes to the style attribute are processed lazily (see Element::getAttribute() and related methods),
 537     // so we don&#39;t want changes to the style attribute to result in extra work here except invalidateInstances().
 538     if (name == HTMLNames::styleAttr)
 539         invalidateInstances();
 540     else
 541         svgAttributeChanged(name);
 542 }
 543 
 544 void SVGElement::synchronizeAttribute(const QualifiedName&amp; name)
 545 {
 546     // If the value of the property has changed, serialize the new value to the attribute.
 547     if (auto value = propertyRegistry().synchronize(name))
 548         setSynchronizedLazyAttribute(name, *value);
 549 }
 550 
 551 void SVGElement::synchronizeAllAttributes()
 552 {
 553     // SVGPropertyRegistry::synchronizeAllAttributes() returns the new values of
 554     // the properties which have changed but not committed yet.
 555     auto map = propertyRegistry().synchronizeAllAttributes();
 556     for (const auto&amp; entry : map)
 557         setSynchronizedLazyAttribute(entry.key, entry.value);
 558 }
 559 
 560 void SVGElement::synchronizeAllAnimatedSVGAttribute(SVGElement&amp; svgElement)
 561 {
 562     svgElement.synchronizeAllAttributes();
 563 }
 564 
 565 void SVGElement::commitPropertyChange(SVGProperty* property)
 566 {
 567     // We want to dirty the top-level property when a descendant changes. For example
 568     // a change in an SVGLength item in SVGLengthList should set the dirty flag on
 569     // SVGLengthList and not the SVGLength.
 570     property-&gt;setDirty();
 571 
 572     invalidateSVGAttributes();
 573     svgAttributeChanged(propertyRegistry().propertyAttributeName(*property));
 574 }
 575 
 576 void SVGElement::commitPropertyChange(SVGAnimatedProperty&amp; animatedProperty)
 577 {
 578     QualifiedName attributeName = propertyRegistry().animatedPropertyAttributeName(animatedProperty);
 579     ASSERT(attributeName != nullQName());
 580 
 581     // A change in a style property, e.g SVGRectElement::x should be serialized to
 582     // the attribute immediately. Otherwise it is okay to be lazy in this regard.
 583     if (!propertyRegistry().isAnimatedStylePropertyAttribute(attributeName))
 584         animatedProperty.setDirty();
 585     else
 586         setSynchronizedLazyAttribute(attributeName, animatedProperty.baseValAsString());
 587 
 588     invalidateSVGAttributes();
 589     svgAttributeChanged(attributeName);
 590 }
 591 
 592 bool SVGElement::isAnimatedPropertyAttribute(const QualifiedName&amp; attributeName) const
 593 {
 594     return propertyRegistry().isAnimatedPropertyAttribute(attributeName);
 595 }
 596 
 597 bool SVGElement::isAnimatedAttribute(const QualifiedName&amp; attributeName) const
 598 {
 599     return SVGPropertyAnimatorFactory::isKnownAttribute(attributeName) || isAnimatedPropertyAttribute(attributeName);
 600 }
 601 
 602 bool SVGElement::isAnimatedStyleAttribute(const QualifiedName&amp; attributeName) const
 603 {
 604     return SVGPropertyAnimatorFactory::isKnownAttribute(attributeName) || propertyRegistry().isAnimatedStylePropertyAttribute(attributeName);
 605 }
 606 
 607 RefPtr&lt;SVGAttributeAnimator&gt; SVGElement::createAnimator(const QualifiedName&amp; attributeName, AnimationMode animationMode, CalcMode calcMode, bool isAccumulated, bool isAdditive)
 608 {
 609     // Property animator, e.g. &quot;fill&quot; or &quot;fill-opacity&quot;.
 610     if (auto animator = propertyAnimatorFactory().createAnimator(attributeName, animationMode, calcMode, isAccumulated, isAdditive))
 611         return animator;
 612 
 613     // Animated property animator.
 614     auto animator = propertyRegistry().createAnimator(attributeName, animationMode, calcMode, isAccumulated, isAdditive);
 615     if (!animator)
 616         return animator;
 617     for (auto* instance : instances())
 618         instance-&gt;propertyRegistry().appendAnimatedInstance(attributeName, *animator);
 619     return animator;
 620 }
 621 
 622 void SVGElement::animatorWillBeDeleted(const QualifiedName&amp; attributeName)
 623 {
 624     propertyAnimatorFactory().animatorWillBeDeleted(attributeName);
 625 }
 626 
 627 Optional&lt;ElementStyle&gt; SVGElement::resolveCustomStyle(const RenderStyle&amp; parentStyle, const RenderStyle*)
 628 {
 629     // If the element is in a &lt;use&gt; tree we get the style from the definition tree.
 630     if (auto styleElement = makeRefPtr(this-&gt;correspondingElement())) {
 631         Optional&lt;ElementStyle&gt; style = styleElement-&gt;resolveStyle(&amp;parentStyle);
 632         StyleResolver::adjustSVGElementStyle(*this, *style-&gt;renderStyle);
 633         return style;
 634     }
 635 
 636     return resolveStyle(&amp;parentStyle);
 637 }
 638 
 639 MutableStyleProperties* SVGElement::animatedSMILStyleProperties() const
 640 {
 641     if (m_svgRareData)
 642         return m_svgRareData-&gt;animatedSMILStyleProperties();
 643     return 0;
 644 }
 645 
 646 MutableStyleProperties&amp; SVGElement::ensureAnimatedSMILStyleProperties()
 647 {
 648     return ensureSVGRareData().ensureAnimatedSMILStyleProperties();
 649 }
 650 
 651 void SVGElement::setUseOverrideComputedStyle(bool value)
 652 {
 653     if (m_svgRareData)
 654         m_svgRareData-&gt;setUseOverrideComputedStyle(value);
 655 }
 656 
 657 const RenderStyle* SVGElement::computedStyle(PseudoId pseudoElementSpecifier)
 658 {
 659     if (!m_svgRareData || !m_svgRareData-&gt;useOverrideComputedStyle())
 660         return Element::computedStyle(pseudoElementSpecifier);
 661 
 662     const RenderStyle* parentStyle = nullptr;
 663     if (auto parent = makeRefPtr(parentOrShadowHostElement())) {
 664         if (auto renderer = parent-&gt;renderer())
 665             parentStyle = &amp;renderer-&gt;style();
 666     }
 667 
 668     return m_svgRareData-&gt;overrideComputedStyle(*this, parentStyle);
 669 }
 670 
 671 QualifiedName SVGElement::animatableAttributeForName(const AtomString&amp; localName)
 672 {
 673     static const auto animatableAttributes = makeNeverDestroyed([] {
 674         static const QualifiedName* const names[] = {
 675             &amp;HTMLNames::classAttr.get(),
 676             &amp;SVGNames::amplitudeAttr.get(),
 677             &amp;SVGNames::azimuthAttr.get(),
 678             &amp;SVGNames::baseFrequencyAttr.get(),
 679             &amp;SVGNames::biasAttr.get(),
 680             &amp;SVGNames::clipPathUnitsAttr.get(),
 681             &amp;SVGNames::cxAttr.get(),
 682             &amp;SVGNames::cyAttr.get(),
 683             &amp;SVGNames::diffuseConstantAttr.get(),
 684             &amp;SVGNames::divisorAttr.get(),
 685             &amp;SVGNames::dxAttr.get(),
 686             &amp;SVGNames::dyAttr.get(),
 687             &amp;SVGNames::edgeModeAttr.get(),
 688             &amp;SVGNames::elevationAttr.get(),
 689             &amp;SVGNames::exponentAttr.get(),
 690             &amp;SVGNames::externalResourcesRequiredAttr.get(),
 691             &amp;SVGNames::filterUnitsAttr.get(),
 692             &amp;SVGNames::fxAttr.get(),
 693             &amp;SVGNames::fyAttr.get(),
 694             &amp;SVGNames::gradientTransformAttr.get(),
 695             &amp;SVGNames::gradientUnitsAttr.get(),
 696             &amp;SVGNames::heightAttr.get(),
 697             &amp;SVGNames::in2Attr.get(),
 698             &amp;SVGNames::inAttr.get(),
 699             &amp;SVGNames::interceptAttr.get(),
 700             &amp;SVGNames::k1Attr.get(),
 701             &amp;SVGNames::k2Attr.get(),
 702             &amp;SVGNames::k3Attr.get(),
 703             &amp;SVGNames::k4Attr.get(),
 704             &amp;SVGNames::kernelMatrixAttr.get(),
 705             &amp;SVGNames::kernelUnitLengthAttr.get(),
 706             &amp;SVGNames::lengthAdjustAttr.get(),
 707             &amp;SVGNames::limitingConeAngleAttr.get(),
 708             &amp;SVGNames::markerHeightAttr.get(),
 709             &amp;SVGNames::markerUnitsAttr.get(),
 710             &amp;SVGNames::markerWidthAttr.get(),
 711             &amp;SVGNames::maskContentUnitsAttr.get(),
 712             &amp;SVGNames::maskUnitsAttr.get(),
 713             &amp;SVGNames::methodAttr.get(),
 714             &amp;SVGNames::modeAttr.get(),
 715             &amp;SVGNames::numOctavesAttr.get(),
 716             &amp;SVGNames::offsetAttr.get(),
 717             &amp;SVGNames::operatorAttr.get(),
 718             &amp;SVGNames::orderAttr.get(),
 719             &amp;SVGNames::orientAttr.get(),
 720             &amp;SVGNames::pathLengthAttr.get(),
 721             &amp;SVGNames::patternContentUnitsAttr.get(),
 722             &amp;SVGNames::patternTransformAttr.get(),
 723             &amp;SVGNames::patternUnitsAttr.get(),
 724             &amp;SVGNames::pointsAtXAttr.get(),
 725             &amp;SVGNames::pointsAtYAttr.get(),
 726             &amp;SVGNames::pointsAtZAttr.get(),
 727             &amp;SVGNames::preserveAlphaAttr.get(),
 728             &amp;SVGNames::preserveAspectRatioAttr.get(),
 729             &amp;SVGNames::primitiveUnitsAttr.get(),
 730             &amp;SVGNames::radiusAttr.get(),
 731             &amp;SVGNames::rAttr.get(),
 732             &amp;SVGNames::refXAttr.get(),
 733             &amp;SVGNames::refYAttr.get(),
 734             &amp;SVGNames::resultAttr.get(),
 735             &amp;SVGNames::rotateAttr.get(),
 736             &amp;SVGNames::rxAttr.get(),
 737             &amp;SVGNames::ryAttr.get(),
 738             &amp;SVGNames::scaleAttr.get(),
 739             &amp;SVGNames::seedAttr.get(),
 740             &amp;SVGNames::slopeAttr.get(),
 741             &amp;SVGNames::spacingAttr.get(),
 742             &amp;SVGNames::specularConstantAttr.get(),
 743             &amp;SVGNames::specularExponentAttr.get(),
 744             &amp;SVGNames::spreadMethodAttr.get(),
 745             &amp;SVGNames::startOffsetAttr.get(),
 746             &amp;SVGNames::stdDeviationAttr.get(),
 747             &amp;SVGNames::stitchTilesAttr.get(),
 748             &amp;SVGNames::surfaceScaleAttr.get(),
 749             &amp;SVGNames::tableValuesAttr.get(),
 750             &amp;SVGNames::targetAttr.get(),
 751             &amp;SVGNames::targetXAttr.get(),
 752             &amp;SVGNames::targetYAttr.get(),
 753             &amp;SVGNames::transformAttr.get(),
 754             &amp;SVGNames::typeAttr.get(),
 755             &amp;SVGNames::valuesAttr.get(),
 756             &amp;SVGNames::viewBoxAttr.get(),
 757             &amp;SVGNames::widthAttr.get(),
 758             &amp;SVGNames::x1Attr.get(),
 759             &amp;SVGNames::x2Attr.get(),
 760             &amp;SVGNames::xAttr.get(),
 761             &amp;SVGNames::xChannelSelectorAttr.get(),
 762             &amp;SVGNames::y1Attr.get(),
 763             &amp;SVGNames::y2Attr.get(),
 764             &amp;SVGNames::yAttr.get(),
 765             &amp;SVGNames::yChannelSelectorAttr.get(),
 766             &amp;SVGNames::zAttr.get(),
 767             &amp;SVGNames::hrefAttr.get(),
 768         };
 769         HashMap&lt;AtomString, QualifiedName&gt; map;
 770         for (auto&amp; name : names) {
 771             auto addResult = map.add(name-&gt;localName(), *name);
 772             ASSERT_UNUSED(addResult, addResult.isNewEntry);
 773         }
 774         return map;
 775     }());
 776     return animatableAttributes.get().get(localName);
 777 }
 778 
 779 #ifndef NDEBUG
 780 
 781 bool SVGElement::isAnimatableAttribute(const QualifiedName&amp; name) const
 782 {
 783     if (animatableAttributeForName(name.localName()) == name)
 784         return !filterOutAnimatableAttribute(name);
 785     return false;
 786 }
 787 
 788 bool SVGElement::filterOutAnimatableAttribute(const QualifiedName&amp;) const
 789 {
 790     return false;
 791 }
 792 
 793 #endif
 794 
 795 String SVGElement::title() const
 796 {
 797     // According to spec, for stand-alone SVG documents we should not return a title when
 798     // hovering over the rootmost SVG element (the first &lt;title&gt; element is the title of
 799     // the document, not a tooltip) so we instantly return.
 800     if (isOutermostSVGSVGElement() &amp;&amp; document().topDocument().isSVGDocument())
 801         return String();
 802     auto firstTitle = childrenOfType&lt;SVGTitleElement&gt;(*this).first();
 803     return firstTitle ? const_cast&lt;SVGTitleElement*&gt;(firstTitle)-&gt;innerText() : String();
 804 }
 805 
 806 bool SVGElement::rendererIsNeeded(const RenderStyle&amp; style)
 807 {
 808     // http://www.w3.org/TR/SVG/extend.html#PrivateData
 809     // Prevent anything other than SVG renderers from appearing in our render tree
 810     // Spec: SVG allows inclusion of elements from foreign namespaces anywhere
 811     // with the SVG content. In general, the SVG user agent will include the unknown
 812     // elements in the DOM but will otherwise ignore unknown elements.
 813     if (!parentOrShadowHostElement() || parentOrShadowHostElement()-&gt;isSVGElement())
 814         return StyledElement::rendererIsNeeded(style);
 815 
 816     return false;
 817 }
 818 
 819 CSSPropertyID SVGElement::cssPropertyIdForSVGAttributeName(const QualifiedName&amp; attrName)
 820 {
 821     if (!attrName.namespaceURI().isNull())
 822         return CSSPropertyInvalid;
 823 
 824     static const auto properties = makeNeverDestroyed(createAttributeNameToCSSPropertyIDMap());
 825     return properties.get().get(attrName.localName().impl());
 826 }
 827 
 828 bool SVGElement::isPresentationAttribute(const QualifiedName&amp; name) const
 829 {
 830     if (cssPropertyIdForSVGAttributeName(name) &gt; 0)
 831         return true;
 832     return StyledElement::isPresentationAttribute(name);
 833 }
 834 
 835 void SVGElement::collectStyleForPresentationAttribute(const QualifiedName&amp; name, const AtomString&amp; value, MutableStyleProperties&amp; style)
 836 {
 837     CSSPropertyID propertyID = cssPropertyIdForSVGAttributeName(name);
 838     if (propertyID &gt; 0)
 839         addPropertyToPresentationAttributeStyle(style, propertyID, value);
 840 }
 841 
 842 void SVGElement::svgAttributeChanged(const QualifiedName&amp; attrName)
 843 {
 844     CSSPropertyID propId = cssPropertyIdForSVGAttributeName(attrName);
 845     if (propId &gt; 0) {
 846         invalidateInstances();
 847         return;
 848     }
 849 
 850     if (attrName == HTMLNames::classAttr) {
 851         classAttributeChanged(className());
 852         invalidateInstances();
 853         return;
 854     }
 855 
 856     if (attrName == HTMLNames::idAttr) {
 857         auto renderer = this-&gt;renderer();
 858         // Notify resources about id changes, this is important as we cache resources by id in SVGDocumentExtensions
 859         if (is&lt;RenderSVGResourceContainer&gt;(renderer))
 860             downcast&lt;RenderSVGResourceContainer&gt;(*renderer).idChanged();
 861         if (isConnected())
 862             buildPendingResourcesIfNeeded();
 863         invalidateInstances();
 864         return;
 865     }
 866 
 867     SVGLangSpace::svgAttributeChanged(attrName);
 868 }
 869 
 870 Node::InsertedIntoAncestorResult SVGElement::insertedIntoAncestor(InsertionType insertionType, ContainerNode&amp; parentOfInsertedTree)
 871 {
 872     StyledElement::insertedIntoAncestor(insertionType, parentOfInsertedTree);
 873     updateRelativeLengthsInformation();
 874     buildPendingResourcesIfNeeded();
 875     return InsertedIntoAncestorResult::Done;
 876 }
 877 
 878 void SVGElement::buildPendingResourcesIfNeeded()
 879 {
 880     if (!needsPendingResourceHandling() || !isConnected() || isInShadowTree())
 881         return;
 882 
 883     SVGDocumentExtensions&amp; extensions = document().accessSVGExtensions();
 884     String resourceId = getIdAttribute();
 885     if (!extensions.isIdOfPendingResource(resourceId))
 886         return;
 887 
 888     // Mark pending resources as pending for removal.
 889     extensions.markPendingResourcesForRemoval(resourceId);
 890 
 891     // Rebuild pending resources for each client of a pending resource that is being removed.
 892     while (auto clientElement = extensions.removeElementFromPendingResourcesForRemovalMap(resourceId)) {
 893         ASSERT(clientElement-&gt;hasPendingResources());
 894         if (clientElement-&gt;hasPendingResources()) {
 895             clientElement-&gt;buildPendingResource();
 896             extensions.clearHasPendingResourcesIfPossible(*clientElement);
 897         }
 898     }
 899 }
 900 
 901 void SVGElement::childrenChanged(const ChildChange&amp; change)
 902 {
 903     StyledElement::childrenChanged(change);
 904 
 905     if (change.source == ChildChangeSource::Parser)
 906         return;
 907     invalidateInstances();
 908 }
 909 
 910 RefPtr&lt;DeprecatedCSSOMValue&gt; SVGElement::getPresentationAttribute(const String&amp; name)
 911 {
 912     if (!hasAttributesWithoutUpdate())
 913         return 0;
 914 
 915     QualifiedName attributeName(nullAtom(), name, nullAtom());
 916     const Attribute* attribute = findAttributeByName(attributeName);
 917     if (!attribute)
 918         return 0;
 919 
 920     auto style = MutableStyleProperties::create(SVGAttributeMode);
 921     CSSPropertyID propertyID = cssPropertyIdForSVGAttributeName(attribute-&gt;name());
 922     style-&gt;setProperty(propertyID, attribute-&gt;value());
 923     auto cssValue = style-&gt;getPropertyCSSValue(propertyID);
 924     if (!cssValue)
 925         return nullptr;
 926     return cssValue-&gt;createDeprecatedCSSOMWrapper(style-&gt;ensureCSSStyleDeclaration());
 927 }
 928 
 929 bool SVGElement::instanceUpdatesBlocked() const
 930 {
 931     return m_svgRareData &amp;&amp; m_svgRareData-&gt;instanceUpdatesBlocked();
 932 }
 933 
 934 void SVGElement::setInstanceUpdatesBlocked(bool value)
 935 {
 936     // Catch any callers that calls setInstanceUpdatesBlocked(true) twice in a row.
 937     // That probably indicates nested use of InstanceUpdateBlocker and a bug.
 938     ASSERT(!value || !instanceUpdatesBlocked());
 939 
 940     if (m_svgRareData)
 941         m_svgRareData-&gt;setInstanceUpdatesBlocked(value);
 942 }
 943 
 944 AffineTransform SVGElement::localCoordinateSpaceTransform(SVGLocatable::CTMScope) const
 945 {
 946     // To be overridden by SVGGraphicsElement (or as special case SVGTextElement and SVGPatternElement)
 947     return AffineTransform();
 948 }
 949 
 950 void SVGElement::updateRelativeLengthsInformation(bool hasRelativeLengths, SVGElement* element)
 951 {
 952     // If we&#39;re not yet in a document, this function will be called again from insertedIntoAncestor(). Do nothing now.
 953     if (!isConnected())
 954         return;
 955 
 956     // An element wants to notify us that its own relative lengths state changed.
 957     // Register it in the relative length map, and register us in the parent relative length map.
 958     // Register the parent in the grandparents map, etc. Repeat procedure until the root of the SVG tree.
 959 
 960     if (hasRelativeLengths)
 961         m_elementsWithRelativeLengths.add(element);
 962     else {
 963         if (!m_elementsWithRelativeLengths.contains(element)) {
 964             // We were never registered. Do nothing.
 965             return;
 966         }
 967 
 968         m_elementsWithRelativeLengths.remove(element);
 969     }
 970 
 971     if (!element-&gt;isSVGGraphicsElement())
 972         return;
 973 
 974     // Find first styled parent node, and notify it that we&#39;ve changed our relative length state.
 975     auto node = makeRefPtr(parentNode());
 976     while (node) {
 977         if (!node-&gt;isSVGElement())
 978             break;
 979 
 980         // Register us in the parent element map.
 981         downcast&lt;SVGElement&gt;(*node).updateRelativeLengthsInformation(hasRelativeLengths, this);
 982         break;
 983     }
 984 }
 985 
 986 void SVGElement::accessKeyAction(bool sendMouseEvents)
 987 {
 988     dispatchSimulatedClick(0, sendMouseEvents ? SendMouseUpDownEvents : SendNoEvents);
 989 }
 990 
 991 void SVGElement::invalidateInstances()
 992 {
 993     if (instanceUpdatesBlocked())
 994         return;
 995 
 996     auto&amp; instances = this-&gt;instances();
 997     while (!instances.isEmpty()) {
 998         auto instance = makeRefPtr(*instances.begin());
 999         if (auto useElement = instance-&gt;correspondingUseElement())
1000             useElement-&gt;invalidateShadowTree();
1001         instance-&gt;setCorrespondingElement(nullptr);
1002     } while (!instances.isEmpty());
1003 }
1004 
1005 }
    </pre>
  </body>
</html>