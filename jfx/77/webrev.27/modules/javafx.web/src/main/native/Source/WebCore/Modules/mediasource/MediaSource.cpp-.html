<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.web/src/main/native/Source/WebCore/Modules/mediasource/MediaSource.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (C) 2013 Google Inc. All rights reserved.
   3  * Copyright (C) 2013-2017 Apple Inc. All rights reserved.
   4  *
   5  * Redistribution and use in source and binary forms, with or without
   6  * modification, are permitted provided that the following conditions are
   7  * met:
   8  *
   9  *     * Redistributions of source code must retain the above copyright
  10  * notice, this list of conditions and the following disclaimer.
  11  *     * Redistributions in binary form must reproduce the above
  12  * copyright notice, this list of conditions and the following disclaimer
  13  * in the documentation and/or other materials provided with the
  14  * distribution.
  15  *     * Neither the name of Google Inc. nor the names of its
  16  * contributors may be used to endorse or promote products derived from
  17  * this software without specific prior written permission.
  18  *
  19  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  20  * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  21  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
  22  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
  23  * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
  24  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
  25  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
  26  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
  27  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  28  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  29  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  30  */
  31 
  32 #include &quot;config.h&quot;
  33 #include &quot;MediaSource.h&quot;
  34 
  35 #if ENABLE(MEDIA_SOURCE)
  36 
  37 #include &quot;AudioTrackList.h&quot;
  38 #include &quot;ContentType.h&quot;
  39 #include &quot;Event.h&quot;
  40 #include &quot;EventNames.h&quot;
  41 #include &quot;HTMLMediaElement.h&quot;
  42 #include &quot;Logging.h&quot;
  43 #include &quot;MediaSourcePrivate.h&quot;
  44 #include &quot;MediaSourceRegistry.h&quot;
  45 #include &quot;SourceBuffer.h&quot;
  46 #include &quot;SourceBufferList.h&quot;
  47 #include &quot;SourceBufferPrivate.h&quot;
  48 #include &quot;TextTrackList.h&quot;
  49 #include &quot;TimeRanges.h&quot;
  50 #include &quot;VideoTrackList.h&quot;
  51 
  52 namespace WebCore {
  53 
  54 String convertEnumerationToString(MediaSourcePrivate::AddStatus enumerationValue)
  55 {
  56     static const NeverDestroyed&lt;String&gt; values[] = {
  57         MAKE_STATIC_STRING_IMPL(&quot;Ok&quot;),
  58         MAKE_STATIC_STRING_IMPL(&quot;NotSupported&quot;),
  59         MAKE_STATIC_STRING_IMPL(&quot;ReachedIdLimit&quot;),
  60     };
  61     static_assert(static_cast&lt;size_t&gt;(MediaSourcePrivate::AddStatus::Ok) == 0, &quot;MediaSourcePrivate::AddStatus::Ok is not 0 as expected&quot;);
  62     static_assert(static_cast&lt;size_t&gt;(MediaSourcePrivate::AddStatus::NotSupported) == 1, &quot;MediaSourcePrivate::AddStatus::NotSupported is not 1 as expected&quot;);
  63     static_assert(static_cast&lt;size_t&gt;(MediaSourcePrivate::AddStatus::ReachedIdLimit) == 2, &quot;MediaSourcePrivate::AddStatus::ReachedIdLimit is not 2 as expected&quot;);
  64     ASSERT(static_cast&lt;size_t&gt;(enumerationValue) &lt; WTF_ARRAY_LENGTH(values));
  65     return values[static_cast&lt;size_t&gt;(enumerationValue)];
  66 }
  67 
  68 String convertEnumerationToString(MediaSourcePrivate::EndOfStreamStatus enumerationValue)
  69 {
  70     static const NeverDestroyed&lt;String&gt; values[] = {
  71         MAKE_STATIC_STRING_IMPL(&quot;EosNoError&quot;),
  72         MAKE_STATIC_STRING_IMPL(&quot;EosNetworkError&quot;),
  73         MAKE_STATIC_STRING_IMPL(&quot;EosDecodeError&quot;),
  74     };
  75     static_assert(static_cast&lt;size_t&gt;(MediaSourcePrivate::EndOfStreamStatus::EosNoError) == 0, &quot;MediaSourcePrivate::EndOfStreamStatus::EosNoError is not 0 as expected&quot;);
  76     static_assert(static_cast&lt;size_t&gt;(MediaSourcePrivate::EndOfStreamStatus::EosNetworkError) == 1, &quot;MediaSourcePrivate::EndOfStreamStatus::EosNetworkError is not 1 as expected&quot;);
  77     static_assert(static_cast&lt;size_t&gt;(MediaSourcePrivate::EndOfStreamStatus::EosDecodeError) == 2, &quot;MediaSourcePrivate::EndOfStreamStatus::EosDecodeError is not 2 as expected&quot;);
  78     ASSERT(static_cast&lt;size_t&gt;(enumerationValue) &lt; WTF_ARRAY_LENGTH(values));
  79     return values[static_cast&lt;size_t&gt;(enumerationValue)];
  80 }
  81 
  82 URLRegistry* MediaSource::s_registry;
  83 
  84 void MediaSource::setRegistry(URLRegistry* registry)
  85 {
  86     ASSERT(!s_registry);
  87     s_registry = registry;
  88 }
  89 
  90 Ref&lt;MediaSource&gt; MediaSource::create(ScriptExecutionContext&amp; context)
  91 {
  92     auto mediaSource = adoptRef(*new MediaSource(context));
  93     mediaSource-&gt;suspendIfNeeded();
  94     return mediaSource;
  95 }
  96 
  97 MediaSource::MediaSource(ScriptExecutionContext&amp; context)
  98     : ActiveDOMObject(&amp;context)
  99     , m_duration(MediaTime::invalidTime())
 100     , m_pendingSeekTime(MediaTime::invalidTime())
 101     , m_asyncEventQueue(*this)
 102 #if !RELEASE_LOG_DISABLED
 103     , m_logger(downcast&lt;Document&gt;(context).logger())
 104 #endif
 105 {
 106     m_sourceBuffers = SourceBufferList::create(scriptExecutionContext());
 107     m_activeSourceBuffers = SourceBufferList::create(scriptExecutionContext());
 108 }
 109 
 110 MediaSource::~MediaSource()
 111 {
 112     ALWAYS_LOG(LOGIDENTIFIER);
 113     ASSERT(isClosed());
 114 }
 115 
 116 void MediaSource::setPrivateAndOpen(Ref&lt;MediaSourcePrivate&gt;&amp;&amp; mediaSourcePrivate)
 117 {
 118     DEBUG_LOG(LOGIDENTIFIER);
 119     ASSERT(!m_private);
 120     ASSERT(m_mediaElement);
 121     m_private = WTFMove(mediaSourcePrivate);
 122 
 123     // 2.4.1 Attaching to a media element
 124     // https://rawgit.com/w3c/media-source/45627646344eea0170dd1cbc5a3d508ca751abb8/media-source-respec.html#mediasource-attach
 125 
 126     // ↳ If readyState is NOT set to &quot;closed&quot;
 127     //    Run the &quot;If the media data cannot be fetched at all, due to network errors, causing the user agent to give up trying
 128     //    to fetch the resource&quot; steps of the resource fetch algorithm&#39;s media data processing steps list.
 129     if (!isClosed()) {
 130         m_mediaElement-&gt;mediaLoadingFailedFatally(MediaPlayer::NetworkError);
 131         return;
 132     }
 133 
 134     // ↳ Otherwise
 135     // 1. Set the media element&#39;s delaying-the-load-event-flag to false.
 136     m_mediaElement-&gt;setShouldDelayLoadEvent(false);
 137 
 138     // 2. Set the readyState attribute to &quot;open&quot;.
 139     // 3. Queue a task to fire a simple event named sourceopen at the MediaSource.
 140     setReadyState(ReadyState::Open);
 141 
 142     // 4. Continue the resource fetch algorithm by running the remaining &quot;Otherwise (mode is local)&quot; steps,
 143     // with these clarifications:
 144     // NOTE: This is handled in HTMLMediaElement.
 145 }
 146 
 147 void MediaSource::addedToRegistry()
 148 {
 149     DEBUG_LOG(LOGIDENTIFIER);
 150     setPendingActivity(*this);
 151 }
 152 
 153 void MediaSource::removedFromRegistry()
 154 {
 155     DEBUG_LOG(LOGIDENTIFIER);
 156     unsetPendingActivity(*this);
 157 }
 158 
 159 MediaTime MediaSource::duration() const
 160 {
 161     return m_duration;
 162 }
 163 
 164 void MediaSource::durationChanged(const MediaTime&amp; duration)
 165 {
 166     ALWAYS_LOG(LOGIDENTIFIER, duration);
 167     m_duration = duration;
 168 }
 169 
 170 MediaTime MediaSource::currentTime() const
 171 {
 172     return m_mediaElement ? m_mediaElement-&gt;currentMediaTime() : MediaTime::zeroTime();
 173 }
 174 
 175 std::unique_ptr&lt;PlatformTimeRanges&gt; MediaSource::buffered() const
 176 {
 177     if (m_buffered &amp;&amp; m_activeSourceBuffers-&gt;length() &amp;&amp; std::all_of(m_activeSourceBuffers-&gt;begin(), m_activeSourceBuffers-&gt;end(), [](auto&amp; buffer) { return !buffer-&gt;isBufferedDirty(); }))
 178         return std::make_unique&lt;PlatformTimeRanges&gt;(*m_buffered);
 179 
 180     m_buffered = std::make_unique&lt;PlatformTimeRanges&gt;();
 181     for (auto&amp; sourceBuffer : *m_activeSourceBuffers)
 182         sourceBuffer-&gt;setBufferedDirty(false);
 183 
 184     // Implements MediaSource algorithm for HTMLMediaElement.buffered.
 185     // https://dvcs.w3.org/hg/html-media/raw-file/default/media-source/media-source.html#htmlmediaelement-extensions
 186     Vector&lt;PlatformTimeRanges&gt; activeRanges = this-&gt;activeRanges();
 187 
 188     // 1. If activeSourceBuffers.length equals 0 then return an empty TimeRanges object and abort these steps.
 189     if (activeRanges.isEmpty())
 190         return std::make_unique&lt;PlatformTimeRanges&gt;(*m_buffered);
 191 
 192     // 2. Let active ranges be the ranges returned by buffered for each SourceBuffer object in activeSourceBuffers.
 193     // 3. Let highest end time be the largest range end time in the active ranges.
 194     MediaTime highestEndTime = MediaTime::zeroTime();
 195     for (auto&amp; ranges : activeRanges) {
 196         unsigned length = ranges.length();
 197         if (length)
 198             highestEndTime = std::max(highestEndTime, ranges.end(length - 1));
 199     }
 200 
 201     // Return an empty range if all ranges are empty.
 202     if (!highestEndTime)
 203         return std::make_unique&lt;PlatformTimeRanges&gt;(*m_buffered);
 204 
 205     // 4. Let intersection ranges equal a TimeRange object containing a single range from 0 to highest end time.
 206     m_buffered-&gt;add(MediaTime::zeroTime(), highestEndTime);
 207 
 208     // 5. For each SourceBuffer object in activeSourceBuffers run the following steps:
 209     bool ended = readyState() == ReadyState::Ended;
 210     for (auto&amp; sourceRanges : activeRanges) {
 211         // 5.1 Let source ranges equal the ranges returned by the buffered attribute on the current SourceBuffer.
 212         // 5.2 If readyState is &quot;ended&quot;, then set the end time on the last range in source ranges to highest end time.
 213         if (ended &amp;&amp; sourceRanges.length())
 214             sourceRanges.add(sourceRanges.start(sourceRanges.length() - 1), highestEndTime);
 215 
 216         // 5.3 Let new intersection ranges equal the intersection between the intersection ranges and the source ranges.
 217         // 5.4 Replace the ranges in intersection ranges with the new intersection ranges.
 218         m_buffered-&gt;intersectWith(sourceRanges);
 219     }
 220 
 221     return std::make_unique&lt;PlatformTimeRanges&gt;(*m_buffered);
 222 }
 223 
 224 void MediaSource::seekToTime(const MediaTime&amp; time)
 225 {
 226     if (isClosed())
 227         return;
 228 
 229     ALWAYS_LOG(LOGIDENTIFIER, time);
 230 
 231     // 2.4.3 Seeking
 232     // https://rawgit.com/w3c/media-source/45627646344eea0170dd1cbc5a3d508ca751abb8/media-source-respec.html#mediasource-seeking
 233 
 234     m_pendingSeekTime = time;
 235 
 236     // Run the following steps as part of the &quot;Wait until the user agent has established whether or not the
 237     // media data for the new playback position is available, and, if it is, until it has decoded enough data
 238     // to play back that position&quot; step of the seek algorithm:
 239     // ↳ If new playback position is not in any TimeRange of HTMLMediaElement.buffered
 240     if (!hasBufferedTime(time)) {
 241         // 1. If the HTMLMediaElement.readyState attribute is greater than HAVE_METADATA,
 242         // then set the HTMLMediaElement.readyState attribute to HAVE_METADATA.
 243         m_private-&gt;setReadyState(MediaPlayer::HaveMetadata);
 244 
 245         // 2. The media element waits until an appendBuffer() or an appendStream() call causes the coded
 246         // frame processing algorithm to set the HTMLMediaElement.readyState attribute to a value greater
 247         // than HAVE_METADATA.
 248         m_private-&gt;waitForSeekCompleted();
 249         return;
 250     }
 251     // ↳ Otherwise
 252     // Continue
 253 
 254 // https://bugs.webkit.org/show_bug.cgi?id=125157 broke seek on MediaPlayerPrivateGStreamerMSE
 255 #if !USE(GSTREAMER)
 256     m_private-&gt;waitForSeekCompleted();
 257 #endif
 258     completeSeek();
 259 }
 260 
 261 void MediaSource::completeSeek()
 262 {
 263     if (isClosed())
 264         return;
 265 
 266     // 2.4.3 Seeking, ctd.
 267     // https://dvcs.w3.org/hg/html-media/raw-file/tip/media-source/media-source.html#mediasource-seeking
 268 
 269     ASSERT(m_pendingSeekTime.isValid());
 270 
 271     ALWAYS_LOG(LOGIDENTIFIER, m_pendingSeekTime);
 272 
 273     // 2. The media element resets all decoders and initializes each one with data from the appropriate
 274     // initialization segment.
 275     // 3. The media element feeds coded frames from the active track buffers into the decoders starting
 276     // with the closest random access point before the new playback position.
 277     MediaTime pendingSeekTime = m_pendingSeekTime;
 278     m_pendingSeekTime = MediaTime::invalidTime();
 279     for (auto&amp; sourceBuffer : *m_activeSourceBuffers)
 280         sourceBuffer-&gt;seekToTime(pendingSeekTime);
 281 
 282     // 4. Resume the seek algorithm at the &quot;Await a stable state&quot; step.
 283     m_private-&gt;seekCompleted();
 284 
 285     monitorSourceBuffers();
 286 }
 287 
 288 Ref&lt;TimeRanges&gt; MediaSource::seekable()
 289 {
 290     // 6. HTMLMediaElement Extensions, seekable
 291     // W3C Editor&#39;s Draft 16 September 2016
 292     // https://rawgit.com/w3c/media-source/45627646344eea0170dd1cbc5a3d508ca751abb8/media-source-respec.html#htmlmediaelement-extensions
 293 
 294     // ↳ If duration equals NaN:
 295     // Return an empty TimeRanges object.
 296     if (m_duration.isInvalid())
 297         return TimeRanges::create();
 298 
 299     // ↳ If duration equals positive Infinity:
 300     if (m_duration.isPositiveInfinite()) {
 301         auto buffered = this-&gt;buffered();
 302         // If live seekable range is not empty:
 303         if (m_liveSeekable &amp;&amp; m_liveSeekable-&gt;length()) {
 304             // Let union ranges be the union of live seekable range and the HTMLMediaElement.buffered attribute.
 305             buffered-&gt;unionWith(*m_liveSeekable);
 306             // Return a single range with a start time equal to the earliest start time in union ranges
 307             // and an end time equal to the highest end time in union ranges and abort these steps.
 308             buffered-&gt;add(buffered-&gt;start(0), buffered-&gt;maximumBufferedTime());
 309             return TimeRanges::create(*buffered);
 310         }
 311 
 312         // If the HTMLMediaElement.buffered attribute returns an empty TimeRanges object, then return
 313         // an empty TimeRanges object and abort these steps.
 314         if (!buffered-&gt;length())
 315             return TimeRanges::create();
 316 
 317         // Return a single range with a start time of 0 and an end time equal to the highest end time
 318         // reported by the HTMLMediaElement.buffered attribute.
 319         return TimeRanges::create({MediaTime::zeroTime(), buffered-&gt;maximumBufferedTime()});
 320     }
 321 
 322     // ↳ Otherwise:
 323     // Return a single range with a start time of 0 and an end time equal to duration.
 324     return TimeRanges::create({MediaTime::zeroTime(), m_duration});
 325 }
 326 
 327 ExceptionOr&lt;void&gt; MediaSource::setLiveSeekableRange(double start, double end)
 328 {
 329     // W3C Editor&#39;s Draft 16 September 2016
 330     // https://rawgit.com/w3c/media-source/45627646344eea0170dd1cbc5a3d508ca751abb8/media-source-respec.html#dom-mediasource-setliveseekablerange
 331 
 332     ALWAYS_LOG(LOGIDENTIFIER, &quot;start = &quot;, start, &quot;, end = &quot;, end);
 333 
 334     // If the readyState attribute is not &quot;open&quot; then throw an InvalidStateError exception and abort these steps.
 335     if (!isOpen())
 336         return Exception { InvalidStateError };
 337 
 338     // If start is negative or greater than end, then throw a TypeError exception and abort these steps.
 339     if (start &lt; 0 || start &gt; end)
 340         return Exception { TypeError };
 341 
 342     // Set live seekable range to be a new normalized TimeRanges object containing a single range
 343     // whose start position is start and end position is end.
 344     m_liveSeekable = std::make_unique&lt;PlatformTimeRanges&gt;(MediaTime::createWithDouble(start), MediaTime::createWithDouble(end));
 345 
 346     return { };
 347 }
 348 
 349 ExceptionOr&lt;void&gt; MediaSource::clearLiveSeekableRange()
 350 {
 351     // W3C Editor&#39;s Draft 16 September 2016
 352     // https://rawgit.com/w3c/media-source/45627646344eea0170dd1cbc5a3d508ca751abb8/media-source-respec.html#dom-mediasource-clearliveseekablerange
 353 
 354     ALWAYS_LOG(LOGIDENTIFIER);
 355 
 356     // If the readyState attribute is not &quot;open&quot; then throw an InvalidStateError exception and abort these steps.
 357     if (!isOpen())
 358         return Exception { InvalidStateError };
 359     m_liveSeekable = nullptr;
 360     return { };
 361 }
 362 
 363 const MediaTime&amp; MediaSource::currentTimeFudgeFactor()
 364 {
 365     // Allow hasCurrentTime() to be off by as much as the length of two 24fps video frames
 366     static NeverDestroyed&lt;MediaTime&gt; fudgeFactor(2002, 24000);
 367     return fudgeFactor;
 368 }
 369 
 370 bool MediaSource::contentTypeShouldGenerateTimestamps(const ContentType&amp; contentType)
 371 {
 372     return contentType.containerType() == &quot;audio/aac&quot; || contentType.containerType() == &quot;audio/mpeg&quot;;
 373 }
 374 
 375 bool MediaSource::hasBufferedTime(const MediaTime&amp; time)
 376 {
 377     if (time &gt; duration())
 378         return false;
 379 
 380     auto ranges = buffered();
 381     if (!ranges-&gt;length())
 382         return false;
 383 
 384     return abs(ranges-&gt;nearest(time) - time) &lt;= currentTimeFudgeFactor();
 385 }
 386 
 387 bool MediaSource::hasCurrentTime()
 388 {
 389     return hasBufferedTime(currentTime());
 390 }
 391 
 392 bool MediaSource::hasFutureTime()
 393 {
 394     MediaTime currentTime = this-&gt;currentTime();
 395     MediaTime duration = this-&gt;duration();
 396 
 397     if (currentTime &gt;= duration)
 398         return true;
 399 
 400     auto ranges = buffered();
 401     MediaTime nearest = ranges-&gt;nearest(currentTime);
 402     if (abs(nearest - currentTime) &gt; currentTimeFudgeFactor())
 403         return false;
 404 
 405     size_t found = ranges-&gt;find(nearest);
 406     if (found == notFound)
 407         return false;
 408 
 409     MediaTime localEnd = ranges-&gt;end(found);
 410     if (localEnd == duration)
 411         return true;
 412 
 413     return localEnd - currentTime &gt; currentTimeFudgeFactor();
 414 }
 415 
 416 void MediaSource::monitorSourceBuffers()
 417 {
 418     if (isClosed())
 419         return;
 420 
 421     // 2.4.4 SourceBuffer Monitoring
 422     // https://rawgit.com/w3c/media-source/45627646344eea0170dd1cbc5a3d508ca751abb8/media-source-respec.html#buffer-monitoring
 423 
 424     // Note, the behavior if activeSourceBuffers is empty is undefined.
 425     if (!m_activeSourceBuffers) {
 426         m_private-&gt;setReadyState(MediaPlayer::HaveNothing);
 427         return;
 428     }
 429 
 430     // ↳ If the HTMLMediaElement.readyState attribute equals HAVE_NOTHING:
 431     if (mediaElement()-&gt;readyState() == HTMLMediaElement::HAVE_NOTHING) {
 432         // 1. Abort these steps.
 433         return;
 434     }
 435 
 436     // ↳ If HTMLMediaElement.buffered does not contain a TimeRange for the current playback position:
 437     if (!hasCurrentTime()) {
 438         // 1. Set the HTMLMediaElement.readyState attribute to HAVE_METADATA.
 439         // 2. If this is the first transition to HAVE_METADATA, then queue a task to fire a simple event
 440         // named loadedmetadata at the media element.
 441         m_private-&gt;setReadyState(MediaPlayer::HaveMetadata);
 442 
 443         // 3. Abort these steps.
 444         return;
 445     }
 446 
 447     // ↳ If HTMLMediaElement.buffered contains a TimeRange that includes the current
 448     //  playback position and enough data to ensure uninterrupted playback:
 449     auto ranges = buffered();
 450     if (std::all_of(m_activeSourceBuffers-&gt;begin(), m_activeSourceBuffers-&gt;end(), [&amp;](auto&amp; sourceBuffer) {
 451         return sourceBuffer-&gt;canPlayThroughRange(*ranges);
 452     })) {
 453         // 1. Set the HTMLMediaElement.readyState attribute to HAVE_ENOUGH_DATA.
 454         // 2. Queue a task to fire a simple event named canplaythrough at the media element.
 455         // 3. Playback may resume at this point if it was previously suspended by a transition to HAVE_CURRENT_DATA.
 456         m_private-&gt;setReadyState(MediaPlayer::HaveEnoughData);
 457 
 458         if (m_pendingSeekTime.isValid())
 459             completeSeek();
 460 
 461         // 4. Abort these steps.
 462         return;
 463     }
 464 
 465     // ↳ If HTMLMediaElement.buffered contains a TimeRange that includes the current playback
 466     //  position and some time beyond the current playback position, then run the following steps:
 467     if (hasFutureTime()) {
 468         // 1. Set the HTMLMediaElement.readyState attribute to HAVE_FUTURE_DATA.
 469         // 2. If the previous value of HTMLMediaElement.readyState was less than HAVE_FUTURE_DATA, then queue a task to fire a simple event named canplay at the media element.
 470         // 3. Playback may resume at this point if it was previously suspended by a transition to HAVE_CURRENT_DATA.
 471         m_private-&gt;setReadyState(MediaPlayer::HaveFutureData);
 472 
 473         if (m_pendingSeekTime.isValid())
 474             completeSeek();
 475 
 476         // 4. Abort these steps.
 477         return;
 478     }
 479 
 480     // ↳ If HTMLMediaElement.buffered contains a TimeRange that ends at the current playback position and does not have a range covering the time immediately after the current position:
 481     // NOTE: Logically, !(all objects do not contain currentTime) == (some objects contain current time)
 482 
 483     // 1. Set the HTMLMediaElement.readyState attribute to HAVE_CURRENT_DATA.
 484     // 2. If this is the first transition to HAVE_CURRENT_DATA, then queue a task to fire a simple
 485     // event named loadeddata at the media element.
 486     // 3. Playback is suspended at this point since the media element doesn&#39;t have enough data to
 487     // advance the media timeline.
 488     m_private-&gt;setReadyState(MediaPlayer::HaveCurrentData);
 489 
 490     if (m_pendingSeekTime.isValid())
 491         completeSeek();
 492 
 493     // 4. Abort these steps.
 494 }
 495 
 496 ExceptionOr&lt;void&gt; MediaSource::setDuration(double duration)
 497 {
 498     // 2.1 Attributes - Duration
 499     // https://www.w3.org/TR/2016/REC-media-source-20161117/#attributes
 500 
 501     ALWAYS_LOG(LOGIDENTIFIER, duration);
 502 
 503     // On setting, run the following steps:
 504     // 1. If the value being set is negative or NaN then throw a TypeError exception and abort these steps.
 505     if (duration &lt; 0.0 || std::isnan(duration))
 506         return Exception { TypeError };
 507 
 508     // 2. If the readyState attribute is not &quot;open&quot; then throw an InvalidStateError exception and abort these steps.
 509     if (!isOpen())
 510         return Exception { InvalidStateError };
 511 
 512     // 3. If the updating attribute equals true on any SourceBuffer in sourceBuffers, then throw an InvalidStateError
 513     // exception and abort these steps.
 514     for (auto&amp; sourceBuffer : *m_sourceBuffers) {
 515         if (sourceBuffer-&gt;updating())
 516             return Exception { InvalidStateError };
 517     }
 518 
 519     // 4. Run the duration change algorithm with new duration set to the value being assigned to this attribute.
 520     return setDurationInternal(MediaTime::createWithDouble(duration));
 521 }
 522 
 523 ExceptionOr&lt;void&gt; MediaSource::setDurationInternal(const MediaTime&amp; duration)
 524 {
 525     // 2.4.6 Duration Change
 526     // https://www.w3.org/TR/2016/REC-media-source-20161117/#duration-change-algorithm
 527 
 528     MediaTime newDuration = duration;
 529 
 530     // 1. If the current value of duration is equal to new duration, then return.
 531     if (newDuration == m_duration)
 532         return { };
 533 
 534     // 2. If new duration is less than the highest presentation timestamp of any buffered coded frames
 535     // for all SourceBuffer objects in sourceBuffers, then throw an InvalidStateError exception and
 536     // abort these steps.
 537     // 3. Let highest end time be the largest track buffer ranges end time across all the track buffers
 538     // across all SourceBuffer objects in sourceBuffers.
 539     MediaTime highestPresentationTimestamp;
 540     MediaTime highestEndTime;
 541     for (auto&amp; sourceBuffer : *m_sourceBuffers) {
 542         highestPresentationTimestamp = std::max(highestPresentationTimestamp, sourceBuffer-&gt;highestPresentationTimestamp());
 543         highestEndTime = std::max(highestEndTime, sourceBuffer-&gt;bufferedInternal().ranges().maximumBufferedTime());
 544     }
 545     if (highestPresentationTimestamp.isValid() &amp;&amp; newDuration &lt; highestPresentationTimestamp)
 546         return Exception { InvalidStateError };
 547 
 548     // 4. If new duration is less than highest end time, then
 549     // 4.1. Update new duration to equal highest end time.
 550     if (highestEndTime.isValid() &amp;&amp; newDuration &lt; highestEndTime)
 551         newDuration = highestEndTime;
 552 
 553     // 5. Update duration to new duration.
 554     m_duration = newDuration;
 555     ALWAYS_LOG(LOGIDENTIFIER, duration);
 556 
 557     // 6. Update the media duration to new duration and run the HTMLMediaElement duration change algorithm.
 558     m_private-&gt;durationChanged();
 559 
 560     return { };
 561 }
 562 
 563 void MediaSource::setReadyState(ReadyState state)
 564 {
 565     auto oldState = readyState();
 566     if (oldState == state)
 567         return;
 568 
 569     m_readyState = state;
 570 
 571     onReadyStateChange(oldState, state);
 572 }
 573 
 574 ExceptionOr&lt;void&gt; MediaSource::endOfStream(Optional&lt;EndOfStreamError&gt; error)
 575 {
 576     ALWAYS_LOG(LOGIDENTIFIER);
 577 
 578     // 2.2 https://dvcs.w3.org/hg/html-media/raw-file/tip/media-source/media-source.html#widl-MediaSource-endOfStream-void-EndOfStreamError-error
 579     // 1. If the readyState attribute is not in the &quot;open&quot; state then throw an
 580     // InvalidStateError exception and abort these steps.
 581     if (!isOpen())
 582         return Exception { InvalidStateError };
 583 
 584     // 2. If the updating attribute equals true on any SourceBuffer in sourceBuffers, then throw an
 585     // InvalidStateError exception and abort these steps.
 586     if (std::any_of(m_sourceBuffers-&gt;begin(), m_sourceBuffers-&gt;end(), [](auto&amp; sourceBuffer) { return sourceBuffer-&gt;updating(); }))
 587         return Exception { InvalidStateError };
 588 
 589     // 3. Run the end of stream algorithm with the error parameter set to error.
 590     streamEndedWithError(error);
 591 
 592     return { };
 593 }
 594 
 595 void MediaSource::streamEndedWithError(Optional&lt;EndOfStreamError&gt; error)
 596 {
 597 #if !RELEASE_LOG_DISABLED
 598     if (error)
 599         ALWAYS_LOG(LOGIDENTIFIER, error.value());
 600     else
 601         ALWAYS_LOG(LOGIDENTIFIER);
 602 #endif
 603 
 604     if (isClosed())
 605         return;
 606 
 607     // 2.4.7 https://dvcs.w3.org/hg/html-media/raw-file/tip/media-source/media-source.html#end-of-stream-algorithm
 608 
 609     // 1. Change the readyState attribute value to &quot;ended&quot;.
 610     // 2. Queue a task to fire a simple event named sourceended at the MediaSource.
 611     setReadyState(ReadyState::Ended);
 612 
 613     // 3.
 614     if (!error) {
 615         // ↳ If error is not set, is null, or is an empty string
 616         // 1. Run the duration change algorithm with new duration set to the highest end time reported by
 617         // the buffered attribute across all SourceBuffer objects in sourceBuffers.
 618         MediaTime maxEndTime;
 619         for (auto&amp; sourceBuffer : *m_sourceBuffers) {
 620             if (auto length = sourceBuffer-&gt;bufferedInternal().length())
 621                 maxEndTime = std::max(sourceBuffer-&gt;bufferedInternal().ranges().end(length - 1), maxEndTime);
 622         }
 623         setDurationInternal(maxEndTime);
 624 
 625         // 2. Notify the media element that it now has all of the media data.
 626         for (auto&amp; sourceBuffer : *m_sourceBuffers)
 627             sourceBuffer-&gt;trySignalAllSamplesEnqueued();
 628         m_private-&gt;markEndOfStream(MediaSourcePrivate::EosNoError);
 629     } else if (error == EndOfStreamError::Network) {
 630         // ↳ If error is set to &quot;network&quot;
 631         ASSERT(m_mediaElement);
 632         if (m_mediaElement-&gt;readyState() == HTMLMediaElement::HAVE_NOTHING) {
 633             //  ↳ If the HTMLMediaElement.readyState attribute equals HAVE_NOTHING
 634             //    Run the &quot;If the media data cannot be fetched at all, due to network errors, causing
 635             //    the user agent to give up trying to fetch the resource&quot; steps of the resource fetch algorithm.
 636             //    NOTE: This step is handled by HTMLMediaElement::mediaLoadingFailed().
 637             m_mediaElement-&gt;mediaLoadingFailed(MediaPlayer::NetworkError);
 638         } else {
 639             //  ↳ If the HTMLMediaElement.readyState attribute is greater than HAVE_NOTHING
 640             //    Run the &quot;If the connection is interrupted after some media data has been received, causing the
 641             //    user agent to give up trying to fetch the resource&quot; steps of the resource fetch algorithm.
 642             //    NOTE: This step is handled by HTMLMediaElement::mediaLoadingFailedFatally().
 643             m_mediaElement-&gt;mediaLoadingFailedFatally(MediaPlayer::NetworkError);
 644         }
 645     } else {
 646         // ↳ If error is set to &quot;decode&quot;
 647         ASSERT(error == EndOfStreamError::Decode);
 648         ASSERT(m_mediaElement);
 649         if (m_mediaElement-&gt;readyState() == HTMLMediaElement::HAVE_NOTHING) {
 650             //  ↳ If the HTMLMediaElement.readyState attribute equals HAVE_NOTHING
 651             //    Run the &quot;If the media data can be fetched but is found by inspection to be in an unsupported
 652             //    format, or can otherwise not be rendered at all&quot; steps of the resource fetch algorithm.
 653             //    NOTE: This step is handled by HTMLMediaElement::mediaLoadingFailed().
 654             m_mediaElement-&gt;mediaLoadingFailed(MediaPlayer::FormatError);
 655         } else {
 656             //  ↳ If the HTMLMediaElement.readyState attribute is greater than HAVE_NOTHING
 657             //    Run the media data is corrupted steps of the resource fetch algorithm.
 658             //    NOTE: This step is handled by HTMLMediaElement::mediaLoadingFailedFatally().
 659             m_mediaElement-&gt;mediaLoadingFailedFatally(MediaPlayer::DecodeError);
 660         }
 661     }
 662 }
 663 
 664 ExceptionOr&lt;Ref&lt;SourceBuffer&gt;&gt; MediaSource::addSourceBuffer(const String&amp; type)
 665 {
 666     DEBUG_LOG(LOGIDENTIFIER, type);
 667 
 668     // 2.2 http://www.w3.org/TR/media-source/#widl-MediaSource-addSourceBuffer-SourceBuffer-DOMString-type
 669     // When this method is invoked, the user agent must run the following steps:
 670 
 671     // 1. If type is an empty string then throw a TypeError exception and abort these steps.
 672     if (type.isEmpty())
 673         return Exception { TypeError };
 674 
 675     // 2. If type contains a MIME type that is not supported ..., then throw a
 676     // NotSupportedError exception and abort these steps.
 677     if (!isTypeSupported(type))
 678         return Exception { NotSupportedError };
 679 
 680     // 4. If the readyState attribute is not in the &quot;open&quot; state then throw an
 681     // InvalidStateError exception and abort these steps.
 682     if (!isOpen())
 683         return Exception { InvalidStateError };
 684 
 685     // 5. Create a new SourceBuffer object and associated resources.
 686     ContentType contentType(type);
 687     auto sourceBufferPrivate = createSourceBufferPrivate(contentType);
 688 
 689     if (sourceBufferPrivate.hasException()) {
 690         // 2. If type contains a MIME type that is not supported ..., then throw a NotSupportedError exception and abort these steps.
 691         // 3. If the user agent can&#39;t handle any more SourceBuffer objects then throw a QuotaExceededError exception and abort these steps
 692         return sourceBufferPrivate.releaseException();
 693     }
 694 
 695     auto buffer = SourceBuffer::create(sourceBufferPrivate.releaseReturnValue(), this);
 696     DEBUG_LOG(LOGIDENTIFIER, &quot;created SourceBuffer&quot;);
 697 
 698     // 6. Set the generate timestamps flag on the new object to the value in the &quot;Generate Timestamps Flag&quot;
 699     // column of the byte stream format registry [MSE-REGISTRY] entry that is associated with type.
 700     // NOTE: In the current byte stream format registry &lt;http://www.w3.org/2013/12/byte-stream-format-registry/&gt;
 701     // only the &quot;MPEG Audio Byte Stream Format&quot; has the &quot;Generate Timestamps Flag&quot; value set.
 702     bool shouldGenerateTimestamps = contentTypeShouldGenerateTimestamps(contentType);
 703     buffer-&gt;setShouldGenerateTimestamps(shouldGenerateTimestamps);
 704 
 705     // 7. If the generate timestamps flag equals true:
 706     // ↳ Set the mode attribute on the new object to &quot;sequence&quot;.
 707     // Otherwise:
 708     // ↳ Set the mode attribute on the new object to &quot;segments&quot;.
 709     buffer-&gt;setMode(shouldGenerateTimestamps ? SourceBuffer::AppendMode::Sequence : SourceBuffer::AppendMode::Segments);
 710 
 711     // 8. Add the new object to sourceBuffers and fire a addsourcebuffer on that object.
 712     m_sourceBuffers-&gt;add(buffer.copyRef());
 713     regenerateActiveSourceBuffers();
 714 
 715     // 9. Return the new object to the caller.
 716     return WTFMove(buffer);
 717 }
 718 
 719 ExceptionOr&lt;void&gt; MediaSource::removeSourceBuffer(SourceBuffer&amp; buffer)
 720 {
 721     DEBUG_LOG(LOGIDENTIFIER);
 722 
 723     Ref&lt;SourceBuffer&gt; protect(buffer);
 724 
 725     // 2. If sourceBuffer specifies an object that is not in sourceBuffers then
 726     // throw a NotFoundError exception and abort these steps.
 727     if (!m_sourceBuffers-&gt;length() || !m_sourceBuffers-&gt;contains(buffer))
 728         return Exception { NotFoundError };
 729 
 730     // 3. If the sourceBuffer.updating attribute equals true, then run the following steps: ...
 731     buffer.abortIfUpdating();
 732 
 733     ASSERT(scriptExecutionContext());
 734     if (!scriptExecutionContext()-&gt;activeDOMObjectsAreStopped()) {
 735         // 4. Let SourceBuffer audioTracks list equal the AudioTrackList object returned by sourceBuffer.audioTracks.
 736         auto&amp; audioTracks = buffer.audioTracks();
 737 
 738         // 5. If the SourceBuffer audioTracks list is not empty, then run the following steps:
 739         if (audioTracks.length()) {
 740             // 5.1 Let HTMLMediaElement audioTracks list equal the AudioTrackList object returned by the audioTracks
 741             // attribute on the HTMLMediaElement.
 742             // 5.2 Let the removed enabled audio track flag equal false.
 743             bool removedEnabledAudioTrack = false;
 744 
 745             // 5.3 For each AudioTrack object in the SourceBuffer audioTracks list, run the following steps:
 746             while (audioTracks.length()) {
 747                 auto&amp; track = *audioTracks.lastItem();
 748 
 749                 // 5.3.1 Set the sourceBuffer attribute on the AudioTrack object to null.
 750                 track.setSourceBuffer(nullptr);
 751 
 752                 // 5.3.2 If the enabled attribute on the AudioTrack object is true, then set the removed enabled
 753                 // audio track flag to true.
 754                 if (track.enabled())
 755                     removedEnabledAudioTrack = true;
 756 
 757                 // 5.3.3 Remove the AudioTrack object from the HTMLMediaElement audioTracks list.
 758                 // 5.3.4 Queue a task to fire a trusted event named removetrack, that does not bubble and is not
 759                 // cancelable, and that uses the TrackEvent interface, at the HTMLMediaElement audioTracks list.
 760                 if (mediaElement())
 761                     mediaElement()-&gt;removeAudioTrack(track);
 762 
 763                 // 5.3.5 Remove the AudioTrack object from the SourceBuffer audioTracks list.
 764                 // 5.3.6 Queue a task to fire a trusted event named removetrack, that does not bubble and is not
 765                 // cancelable, and that uses the TrackEvent interface, at the SourceBuffer audioTracks list.
 766                 audioTracks.remove(track);
 767             }
 768 
 769             // 5.4 If the removed enabled audio track flag equals true, then queue a task to fire a simple event
 770             // named change at the HTMLMediaElement audioTracks list.
 771             if (removedEnabledAudioTrack)
 772                 mediaElement()-&gt;ensureAudioTracks().scheduleChangeEvent();
 773         }
 774 
 775         // 6. Let SourceBuffer videoTracks list equal the VideoTrackList object returned by sourceBuffer.videoTracks.
 776         auto&amp; videoTracks = buffer.videoTracks();
 777 
 778         // 7. If the SourceBuffer videoTracks list is not empty, then run the following steps:
 779         if (videoTracks.length()) {
 780             // 7.1 Let HTMLMediaElement videoTracks list equal the VideoTrackList object returned by the videoTracks
 781             // attribute on the HTMLMediaElement.
 782             // 7.2 Let the removed selected video track flag equal false.
 783             bool removedSelectedVideoTrack = false;
 784 
 785             // 7.3 For each VideoTrack object in the SourceBuffer videoTracks list, run the following steps:
 786             while (videoTracks.length()) {
 787                 auto&amp; track = *videoTracks.lastItem();
 788 
 789                 // 7.3.1 Set the sourceBuffer attribute on the VideoTrack object to null.
 790                 track.setSourceBuffer(nullptr);
 791 
 792                 // 7.3.2 If the selected attribute on the VideoTrack object is true, then set the removed selected
 793                 // video track flag to true.
 794                 if (track.selected())
 795                     removedSelectedVideoTrack = true;
 796 
 797                 // 7.3.3 Remove the VideoTrack object from the HTMLMediaElement videoTracks list.
 798                 // 7.3.4 Queue a task to fire a trusted event named removetrack, that does not bubble and is not
 799                 // cancelable, and that uses the TrackEvent interface, at the HTMLMediaElement videoTracks list.
 800                 if (mediaElement())
 801                     mediaElement()-&gt;removeVideoTrack(track);
 802 
 803                 // 7.3.5 Remove the VideoTrack object from the SourceBuffer videoTracks list.
 804                 // 7.3.6 Queue a task to fire a trusted event named removetrack, that does not bubble and is not
 805                 // cancelable, and that uses the TrackEvent interface, at the SourceBuffer videoTracks list.
 806                 videoTracks.remove(track);
 807             }
 808 
 809             // 7.4 If the removed selected video track flag equals true, then queue a task to fire a simple event
 810             // named change at the HTMLMediaElement videoTracks list.
 811             if (removedSelectedVideoTrack)
 812                 mediaElement()-&gt;ensureVideoTracks().scheduleChangeEvent();
 813         }
 814 
 815         // 8. Let SourceBuffer textTracks list equal the TextTrackList object returned by sourceBuffer.textTracks.
 816         auto&amp; textTracks = buffer.textTracks();
 817 
 818         // 9. If the SourceBuffer textTracks list is not empty, then run the following steps:
 819         if (textTracks.length()) {
 820             // 9.1 Let HTMLMediaElement textTracks list equal the TextTrackList object returned by the textTracks
 821             // attribute on the HTMLMediaElement.
 822             // 9.2 Let the removed enabled text track flag equal false.
 823             bool removedEnabledTextTrack = false;
 824 
 825             // 9.3 For each TextTrack object in the SourceBuffer textTracks list, run the following steps:
 826             while (textTracks.length()) {
 827                 auto&amp; track = *textTracks.lastItem();
 828 
 829                 // 9.3.1 Set the sourceBuffer attribute on the TextTrack object to null.
 830                 track.setSourceBuffer(nullptr);
 831 
 832                 // 9.3.2 If the mode attribute on the TextTrack object is set to &quot;showing&quot; or &quot;hidden&quot;, then
 833                 // set the removed enabled text track flag to true.
 834                 if (track.mode() == TextTrack::Mode::Showing || track.mode() == TextTrack::Mode::Hidden)
 835                     removedEnabledTextTrack = true;
 836 
 837                 // 9.3.3 Remove the TextTrack object from the HTMLMediaElement textTracks list.
 838                 // 9.3.4 Queue a task to fire a trusted event named removetrack, that does not bubble and is not
 839                 // cancelable, and that uses the TrackEvent interface, at the HTMLMediaElement textTracks list.
 840                 if (mediaElement())
 841                     mediaElement()-&gt;removeTextTrack(track);
 842 
 843                 // 9.3.5 Remove the TextTrack object from the SourceBuffer textTracks list.
 844                 // 9.3.6 Queue a task to fire a trusted event named removetrack, that does not bubble and is not
 845                 // cancelable, and that uses the TrackEvent interface, at the SourceBuffer textTracks list.
 846                 textTracks.remove(track);
 847             }
 848 
 849             // 9.4 If the removed enabled text track flag equals true, then queue a task to fire a simple event
 850             // named change at the HTMLMediaElement textTracks list.
 851             if (removedEnabledTextTrack)
 852                 mediaElement()-&gt;ensureTextTracks().scheduleChangeEvent();
 853         }
 854     }
 855 
 856     // 10. If sourceBuffer is in activeSourceBuffers, then remove sourceBuffer from activeSourceBuffers ...
 857     m_activeSourceBuffers-&gt;remove(buffer);
 858 
 859     // 11. Remove sourceBuffer from sourceBuffers and fire a removesourcebuffer event
 860     // on that object.
 861     m_sourceBuffers-&gt;remove(buffer);
 862 
 863     // 12. Destroy all resources for sourceBuffer.
 864     buffer.removedFromMediaSource();
 865 
 866     return { };
 867 }
 868 
 869 bool MediaSource::isTypeSupported(const String&amp; type)
 870 {
 871     // Section 2.2 isTypeSupported() method steps.
 872     // https://dvcs.w3.org/hg/html-media/raw-file/tip/media-source/media-source.html#widl-MediaSource-isTypeSupported-boolean-DOMString-type
 873     // 1. If type is an empty string, then return false.
 874     if (type.isNull() || type.isEmpty())
 875         return false;
 876 
 877     ContentType contentType(type);
 878     String codecs = contentType.parameter(&quot;codecs&quot;);
 879 
 880     // 2. If type does not contain a valid MIME type string, then return false.
 881     if (contentType.containerType().isEmpty())
 882         return false;
 883 
 884     // 3. If type contains a media type or media subtype that the MediaSource does not support, then return false.
 885     // 4. If type contains at a codec that the MediaSource does not support, then return false.
 886     // 5. If the MediaSource does not support the specified combination of media type, media subtype, and codecs then return false.
 887     // 6. Return true.
 888     MediaEngineSupportParameters parameters;
 889     parameters.type = contentType;
 890     parameters.isMediaSource = true;
 891     MediaPlayer::SupportsType supported = MediaPlayer::supportsType(parameters);
 892 
 893     if (codecs.isEmpty())
 894         return supported != MediaPlayer::IsNotSupported;
 895 
 896     return supported == MediaPlayer::IsSupported;
 897 }
 898 
 899 bool MediaSource::isOpen() const
 900 {
 901     return readyState() == ReadyState::Open;
 902 }
 903 
 904 bool MediaSource::isClosed() const
 905 {
 906     return readyState() == ReadyState::Closed;
 907 }
 908 
 909 bool MediaSource::isEnded() const
 910 {
 911     return readyState() == ReadyState::Ended;
 912 }
 913 
 914 void MediaSource::detachFromElement(HTMLMediaElement&amp; element)
 915 {
 916     ALWAYS_LOG(LOGIDENTIFIER);
 917 
 918     ASSERT_UNUSED(element, m_mediaElement == &amp;element);
 919 
 920     // 2.4.2 Detaching from a media element
 921     // https://rawgit.com/w3c/media-source/45627646344eea0170dd1cbc5a3d508ca751abb8/media-source-respec.html#mediasource-detach
 922 
 923     // 1. Set the readyState attribute to &quot;closed&quot;.
 924     // 7. Queue a task to fire a simple event named sourceclose at the MediaSource.
 925     setReadyState(ReadyState::Closed);
 926 
 927     // 2. Update duration to NaN.
 928     m_duration = MediaTime::invalidTime();
 929 
 930     // 3. Remove all the SourceBuffer objects from activeSourceBuffers.
 931     // 4. Queue a task to fire a simple event named removesourcebuffer at activeSourceBuffers.
 932     while (m_activeSourceBuffers-&gt;length())
 933         removeSourceBuffer(*m_activeSourceBuffers-&gt;item(0));
 934 
 935     // 5. Remove all the SourceBuffer objects from sourceBuffers.
 936     // 6. Queue a task to fire a simple event named removesourcebuffer at sourceBuffers.
 937     while (m_sourceBuffers-&gt;length())
 938         removeSourceBuffer(*m_sourceBuffers-&gt;item(0));
 939 
 940     m_private = nullptr;
 941     m_mediaElement = nullptr;
 942 }
 943 
 944 void MediaSource::sourceBufferDidChangeActiveState(SourceBuffer&amp;, bool)
 945 {
 946     regenerateActiveSourceBuffers();
 947 }
 948 
 949 bool MediaSource::attachToElement(HTMLMediaElement&amp; element)
 950 {
 951     if (m_mediaElement)
 952         return false;
 953 
 954     ASSERT(isClosed());
 955 
 956     m_mediaElement = &amp;element;
 957     return true;
 958 }
 959 
 960 void MediaSource::openIfInEndedState()
 961 {
 962     if (m_readyState != ReadyState::Ended)
 963         return;
 964 
 965     ALWAYS_LOG(LOGIDENTIFIER);
 966 
 967     setReadyState(ReadyState::Open);
 968     m_private-&gt;unmarkEndOfStream();
 969 }
 970 
 971 bool MediaSource::hasPendingActivity() const
 972 {
 973     return m_private || m_asyncEventQueue.hasPendingEvents()
 974         || ActiveDOMObject::hasPendingActivity();
 975 }
 976 
 977 void MediaSource::suspend(ReasonForSuspension reason)
 978 {
 979     ALWAYS_LOG(LOGIDENTIFIER, static_cast&lt;int&gt;(reason));
 980 
 981     switch (reason) {
 982     case ReasonForSuspension::PageCache:
 983     case ReasonForSuspension::PageWillBeSuspended:
 984         m_asyncEventQueue.suspend();
 985         break;
 986     case ReasonForSuspension::JavaScriptDebuggerPaused:
 987     case ReasonForSuspension::WillDeferLoading:
 988         // Do nothing, we don&#39;t pause media playback in these cases.
 989         break;
 990     }
 991 }
 992 
 993 void MediaSource::resume()
 994 {
 995     ALWAYS_LOG(LOGIDENTIFIER);
 996 
 997     m_asyncEventQueue.resume();
 998 }
 999 
1000 void MediaSource::stop()
1001 {
1002     ALWAYS_LOG(LOGIDENTIFIER);
1003 
1004     m_asyncEventQueue.close();
1005     if (m_mediaElement)
1006         m_mediaElement-&gt;detachMediaSource();
1007     m_readyState = ReadyState::Closed;
1008     m_private = nullptr;
1009 }
1010 
1011 bool MediaSource::canSuspendForDocumentSuspension() const
1012 {
1013     return isClosed() &amp;&amp; !m_asyncEventQueue.hasPendingEvents();
1014 }
1015 
1016 const char* MediaSource::activeDOMObjectName() const
1017 {
1018     return &quot;MediaSource&quot;;
1019 }
1020 
1021 void MediaSource::onReadyStateChange(ReadyState oldState, ReadyState newState)
1022 {
1023     ALWAYS_LOG(LOGIDENTIFIER, &quot;old state = &quot;, oldState, &quot;, new state = &quot;, newState);
1024 
1025     for (auto&amp; buffer : *m_sourceBuffers)
1026         buffer-&gt;readyStateChanged();
1027 
1028     if (isOpen()) {
1029         scheduleEvent(eventNames().sourceopenEvent);
1030         return;
1031     }
1032 
1033     if (oldState == ReadyState::Open &amp;&amp; newState == ReadyState::Ended) {
1034         scheduleEvent(eventNames().sourceendedEvent);
1035         return;
1036     }
1037 
1038     ASSERT(isClosed());
1039     scheduleEvent(eventNames().sourcecloseEvent);
1040 }
1041 
1042 Vector&lt;PlatformTimeRanges&gt; MediaSource::activeRanges() const
1043 {
1044     Vector&lt;PlatformTimeRanges&gt; activeRanges;
1045     for (auto&amp; sourceBuffer : *m_activeSourceBuffers)
1046         activeRanges.append(sourceBuffer-&gt;bufferedInternal().ranges());
1047     return activeRanges;
1048 }
1049 
1050 ExceptionOr&lt;Ref&lt;SourceBufferPrivate&gt;&gt; MediaSource::createSourceBufferPrivate(const ContentType&amp; type)
1051 {
1052     RefPtr&lt;SourceBufferPrivate&gt; sourceBufferPrivate;
1053     switch (m_private-&gt;addSourceBuffer(type, sourceBufferPrivate)) {
1054     case MediaSourcePrivate::Ok:
1055         return sourceBufferPrivate.releaseNonNull();
1056     case MediaSourcePrivate::NotSupported:
1057         // 2.2 https://dvcs.w3.org/hg/html-media/raw-file/default/media-source/media-source.html#widl-MediaSource-addSourceBuffer-SourceBuffer-DOMString-type
1058         // Step 2: If type contains a MIME type ... that is not supported with the types
1059         // specified for the other SourceBuffer objects in sourceBuffers, then throw
1060         // a NotSupportedError exception and abort these steps.
1061         return Exception { NotSupportedError };
1062     case MediaSourcePrivate::ReachedIdLimit:
1063         // 2.2 https://dvcs.w3.org/hg/html-media/raw-file/default/media-source/media-source.html#widl-MediaSource-addSourceBuffer-SourceBuffer-DOMString-type
1064         // Step 3: If the user agent can&#39;t handle any more SourceBuffer objects then throw
1065         // a QuotaExceededError exception and abort these steps.
1066         return Exception { QuotaExceededError };
1067     }
1068 
1069     ASSERT_NOT_REACHED();
1070     return Exception { QuotaExceededError };
1071 }
1072 
1073 void MediaSource::scheduleEvent(const AtomicString&amp; eventName)
1074 {
1075     DEBUG_LOG(LOGIDENTIFIER, &quot;scheduling &#39;&quot;, eventName, &quot;&#39;&quot;);
1076 
1077     auto event = Event::create(eventName, Event::CanBubble::No, Event::IsCancelable::No);
1078     event-&gt;setTarget(this);
1079 
1080     m_asyncEventQueue.enqueueEvent(WTFMove(event));
1081 }
1082 
1083 ScriptExecutionContext* MediaSource::scriptExecutionContext() const
1084 {
1085     return ActiveDOMObject::scriptExecutionContext();
1086 }
1087 
1088 EventTargetInterface MediaSource::eventTargetInterface() const
1089 {
1090     return MediaSourceEventTargetInterfaceType;
1091 }
1092 
1093 URLRegistry&amp; MediaSource::registry() const
1094 {
1095     return MediaSourceRegistry::registry();
1096 }
1097 
1098 void MediaSource::regenerateActiveSourceBuffers()
1099 {
1100     Vector&lt;RefPtr&lt;SourceBuffer&gt;&gt; newList;
1101     for (auto&amp; sourceBuffer : *m_sourceBuffers) {
1102         if (sourceBuffer-&gt;active())
1103             newList.append(sourceBuffer);
1104     }
1105     m_activeSourceBuffers-&gt;swap(newList);
1106     for (auto&amp; sourceBuffer : *m_activeSourceBuffers)
1107         sourceBuffer-&gt;setBufferedDirty(true);
1108 }
1109 
1110 #if !RELEASE_LOG_DISABLED
1111 void MediaSource::setLogIdentifier(const void* identifier)
1112 {
1113     m_logIdentifier = identifier;
1114     ALWAYS_LOG(LOGIDENTIFIER);
1115 }
1116 
1117 WTFLogChannel&amp; MediaSource::logChannel() const
1118 {
1119     return LogMediaSource;
1120 }
1121 #endif
1122 
1123 }
1124 
1125 #endif
    </pre>
  </body>
</html>