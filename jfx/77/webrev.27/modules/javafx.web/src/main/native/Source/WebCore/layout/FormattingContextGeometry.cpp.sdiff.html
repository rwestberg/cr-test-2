<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/layout/FormattingContextGeometry.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="FormattingContext.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="FormattingContextQuirks.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/layout/FormattingContextGeometry.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
  15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
  17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
  23  * THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #include &quot;config.h&quot;
  27 #include &quot;FormattingContext.h&quot;
  28 
  29 #if ENABLE(LAYOUT_FORMATTING_CONTEXT)
  30 
  31 #include &quot;FloatingState.h&quot;
  32 #include &quot;FormattingState.h&quot;
  33 #include &quot;InlineFormattingState.h&quot;


  34 
  35 namespace WebCore {
  36 namespace Layout {
  37 
  38 static inline bool isHeightAuto(const Box&amp; layoutBox)
  39 {
  40     // 10.5 Content height: the &#39;height&#39; property
  41     //
  42     // The percentage is calculated with respect to the height of the generated box&#39;s containing block.
  43     // If the height of the containing block is not specified explicitly (i.e., it depends on content height),
  44     // and this element is not absolutely positioned, the used height is calculated as if &#39;auto&#39; was specified.
  45 
  46     auto height = layoutBox.style().logicalHeight();
  47     if (height.isAuto())
  48         return true;
  49 
  50     if (height.isPercent()) {
  51         if (layoutBox.isOutOfFlowPositioned())
  52             return false;
  53 
  54         return !layoutBox.containingBlock()-&gt;style().logicalHeight().isFixed();
  55     }
  56 
  57     return false;
  58 }
  59 
  60 Optional&lt;LayoutUnit&gt; FormattingContext::Geometry::computedHeightValue(const LayoutState&amp; layoutState, const Box&amp; layoutBox, HeightType heightType)
  61 {
  62     auto&amp; style = layoutBox.style();
  63     auto height = heightType == HeightType::Normal ? style.logicalHeight() : heightType == HeightType::Min ? style.logicalMinHeight() : style.logicalMaxHeight();
  64     if (height.isUndefined() || height.isAuto())
  65         return { };
  66 
  67     if (height.isFixed())
<span class="line-modified">  68         return { height.value() };</span>
  69 
  70     Optional&lt;LayoutUnit&gt; containingBlockHeightValue;
  71     if (layoutBox.isOutOfFlowPositioned()) {
  72         // Containing block&#39;s height is already computed since we layout the out-of-flow boxes as the last step.
  73         containingBlockHeightValue = layoutState.displayBoxForLayoutBox(*layoutBox.containingBlock()).height();
  74     } else {
  75         if (layoutState.inQuirksMode())
  76             containingBlockHeightValue = FormattingContext::Quirks::heightValueOfNearestContainingBlockWithFixedHeight(layoutState, layoutBox);
  77         else {
  78             auto containingBlockHeight = layoutBox.containingBlock()-&gt;style().logicalHeight();
  79             if (containingBlockHeight.isFixed())
<span class="line-modified">  80                 containingBlockHeightValue = { containingBlockHeight.value() };</span>
  81         }
  82     }
  83 
  84     if (!containingBlockHeightValue)
  85         return { };
  86 
  87     return valueForLength(height, *containingBlockHeightValue);
  88 }
  89 
<span class="line-modified">  90 static LayoutUnit contentHeightForFormattingContextRoot(const LayoutState&amp; layoutState, const Box&amp; layoutBox)</span>
  91 {
  92     ASSERT(isHeightAuto(layoutBox) &amp;&amp; (layoutBox.establishesFormattingContext() || layoutBox.isDocumentBox()));
  93 
  94     // 10.6.7 &#39;Auto&#39; heights for block formatting context roots
  95 
  96     // If it only has inline-level children, the height is the distance between the top of the topmost line box and the bottom of the bottommost line box.
  97     // If it has block-level children, the height is the distance between the top margin-edge of the topmost block-level
  98     // child box and the bottom margin-edge of the bottommost block-level child box.
  99 
 100     // In addition, if the element has any floating descendants whose bottom margin edge is below the element&#39;s bottom content edge,
 101     // then the height is increased to include those edges. Only floats that participate in this block formatting context are taken
 102     // into account, e.g., floats inside absolutely positioned descendants or other floats are not.
 103     if (!is&lt;Container&gt;(layoutBox) || !downcast&lt;Container&gt;(layoutBox).hasInFlowOrFloatingChild())
<span class="line-modified"> 104         return 0;</span>
 105 
 106     auto&amp; displayBox = layoutState.displayBoxForLayoutBox(layoutBox);
 107     auto borderAndPaddingTop = displayBox.borderTop() + displayBox.paddingTop().valueOr(0);
 108     auto top = borderAndPaddingTop;
 109     auto bottom = borderAndPaddingTop;
 110     auto&amp; formattingRootContainer = downcast&lt;Container&gt;(layoutBox);
 111     if (formattingRootContainer.establishesInlineFormattingContext()) {
<span class="line-modified"> 112         // This is temp and will be replaced by the correct display box once inline runs move over to the display tree.</span>
<span class="line-modified"> 113         auto&amp; inlineRuns = downcast&lt;InlineFormattingState&gt;(layoutState.establishedFormattingState(layoutBox)).inlineRuns();</span>
<span class="line-modified"> 114         if (!inlineRuns.isEmpty()) {</span>
<span class="line-modified"> 115             top = inlineRuns[0].logicalTop();</span>
<span class="line-modified"> 116             bottom =  inlineRuns.last().logicalBottom();</span>
<span class="line-removed"> 117         }</span>
 118     } else if (formattingRootContainer.establishesBlockFormattingContext() || layoutBox.isDocumentBox()) {
 119         if (formattingRootContainer.hasInFlowChild()) {
 120             auto&amp; firstDisplayBox = layoutState.displayBoxForLayoutBox(*formattingRootContainer.firstInFlowChild());
 121             auto&amp; lastDisplayBox = layoutState.displayBoxForLayoutBox(*formattingRootContainer.lastInFlowChild());
 122             top = firstDisplayBox.rectWithMargin().top();
 123             bottom = lastDisplayBox.rectWithMargin().bottom();
 124         }
<span class="line-modified"> 125     }</span>







 126 
 127     auto* formattingContextRoot = &amp;layoutBox;
 128     // TODO: The document renderer is not a formatting context root by default at all. Need to find out what it is.
 129     if (!layoutBox.establishesFormattingContext()) {
 130         ASSERT(layoutBox.isDocumentBox());
 131         formattingContextRoot = &amp;layoutBox.formattingContextRoot();
 132     }
 133 
 134     auto&amp; floatingState = layoutState.establishedFormattingState(*formattingContextRoot).floatingState();
 135     auto floatBottom = floatingState.bottom(*formattingContextRoot);
 136     if (floatBottom) {
 137         bottom = std::max&lt;LayoutUnit&gt;(*floatBottom, bottom);
 138         auto floatTop = floatingState.top(*formattingContextRoot);
 139         ASSERT(floatTop);
 140         top = std::min&lt;LayoutUnit&gt;(*floatTop, top);
 141     }
 142 
 143     auto computedHeight = bottom - top;
 144     LOG_WITH_STREAM(FormattingContextLayout, stream &lt;&lt; &quot;[Height] -&gt; content height for formatting context root -&gt; height(&quot; &lt;&lt; computedHeight &lt;&lt; &quot;px) layoutBox(&quot;&lt;&lt; &amp;layoutBox &lt;&lt; &quot;)&quot;);
 145     return computedHeight;
 146 }
 147 
 148 Optional&lt;LayoutUnit&gt; FormattingContext::Geometry::computedValueIfNotAuto(const Length&amp; geometryProperty, LayoutUnit containingBlockWidth)
 149 {
 150     if (geometryProperty.isUndefined())
 151         return WTF::nullopt;
 152 
 153     if (geometryProperty.isAuto())
 154         return WTF::nullopt;
 155 
 156     return valueForLength(geometryProperty, containingBlockWidth);
 157 }
 158 
 159 Optional&lt;LayoutUnit&gt; FormattingContext::Geometry::fixedValue(const Length&amp; geometryProperty)
 160 {
 161     if (!geometryProperty.isFixed())
 162         return WTF::nullopt;
<span class="line-modified"> 163     return { geometryProperty.value() };</span>
 164 }
 165 
 166 // https://www.w3.org/TR/CSS22/visudet.html#min-max-heights
 167 // Specifies a percentage for determining the used value. The percentage is calculated with respect to the height of the generated box&#39;s containing block.
 168 // If the height of the containing block is not specified explicitly (i.e., it depends on content height), and this element is not absolutely positioned,
 169 // the percentage value is treated as &#39;0&#39; (for &#39;min-height&#39;) or &#39;none&#39; (for &#39;max-height&#39;).
 170 Optional&lt;LayoutUnit&gt; FormattingContext::Geometry::computedMaxHeight(const LayoutState&amp; layoutState, const Box&amp; layoutBox)
 171 {
 172     return computedHeightValue(layoutState, layoutBox, HeightType::Max);
 173 }
 174 
 175 Optional&lt;LayoutUnit&gt; FormattingContext::Geometry::computedMinHeight(const LayoutState&amp; layoutState, const Box&amp; layoutBox)
 176 {
 177     if (auto minHeightValue = computedHeightValue(layoutState, layoutBox, HeightType::Min))
 178         return minHeightValue;
 179 
 180     return { 0 };
 181 }
 182 
 183 static LayoutUnit staticVerticalPositionForOutOfFlowPositioned(const LayoutState&amp; layoutState, const Box&amp; layoutBox)
</pre>
<hr />
<pre>
 185     ASSERT(layoutBox.isOutOfFlowPositioned());
 186 
 187     // For the purposes of this section and the next, the term &quot;static position&quot; (of an element) refers, roughly, to the position an element would have
 188     // had in the normal flow. More precisely, the static position for &#39;top&#39; is the distance from the top edge of the containing block to the top margin
 189     // edge of a hypothetical box that would have been the first box of the element if its specified &#39;position&#39; value had been &#39;static&#39; and its specified
 190     // &#39;float&#39; had been &#39;none&#39; and its specified &#39;clear&#39; had been &#39;none&#39;. (Note that due to the rules in section 9.7 this might require also assuming a different
 191     // computed value for &#39;display&#39;.) The value is negative if the hypothetical box is above the containing block.
 192 
 193     // Start with this box&#39;s border box offset from the parent&#39;s border box.
 194     LayoutUnit top;
 195     if (auto* previousInFlowSibling = layoutBox.previousInFlowSibling()) {
 196         // Add sibling offset
 197         auto&amp; previousInFlowDisplayBox = layoutState.displayBoxForLayoutBox(*previousInFlowSibling);
 198         top += previousInFlowDisplayBox.bottom() + previousInFlowDisplayBox.nonCollapsedMarginAfter();
 199     } else {
 200         ASSERT(layoutBox.parent());
 201         top = layoutState.displayBoxForLayoutBox(*layoutBox.parent()).contentBoxTop();
 202     }
 203 
 204     // Resolve top all the way up to the containing block.
<span class="line-modified"> 205     auto* containingBlock = layoutBox.containingBlock();</span>
 206     // Start with the parent since we pretend that this box is normal flow.
<span class="line-modified"> 207     for (auto* container = layoutBox.parent(); container != containingBlock; container = container-&gt;containingBlock()) {</span>
 208         auto&amp; displayBox = layoutState.displayBoxForLayoutBox(*container);
 209         // Display::Box::top is the border box top position in its containing block&#39;s coordinate system.
 210         top += displayBox.top();
 211         ASSERT(!container-&gt;isPositioned() || layoutBox.isFixedPositioned());
 212     }
<span class="line-modified"> 213     return top;</span>


 214 }
 215 
 216 static LayoutUnit staticHorizontalPositionForOutOfFlowPositioned(const LayoutState&amp; layoutState, const Box&amp; layoutBox)
 217 {
 218     ASSERT(layoutBox.isOutOfFlowPositioned());
 219     // See staticVerticalPositionForOutOfFlowPositioned for the definition of the static position.
 220 
 221     // Start with this box&#39;s border box offset from the parent&#39;s border box.
 222     ASSERT(layoutBox.parent());
 223     auto left = layoutState.displayBoxForLayoutBox(*layoutBox.parent()).contentBoxLeft();
 224 
 225     // Resolve left all the way up to the containing block.
<span class="line-modified"> 226     auto* containingBlock = layoutBox.containingBlock();</span>
 227     // Start with the parent since we pretend that this box is normal flow.
<span class="line-modified"> 228     for (auto* container = layoutBox.parent(); container != containingBlock; container = container-&gt;containingBlock()) {</span>
 229         auto&amp; displayBox = layoutState.displayBoxForLayoutBox(*container);
 230         // Display::Box::left is the border box left position in its containing block&#39;s coordinate system.
 231         left += displayBox.left();
 232         ASSERT(!container-&gt;isPositioned() || layoutBox.isFixedPositioned());
 233     }
<span class="line-modified"> 234     return left;</span>


 235 }
 236 
 237 LayoutUnit FormattingContext::Geometry::shrinkToFitWidth(LayoutState&amp; layoutState, const Box&amp; formattingRoot, UsedHorizontalValues usedValues)
 238 {
 239     LOG_WITH_STREAM(FormattingContextLayout, stream &lt;&lt; &quot;[Width] -&gt; shrink to fit -&gt; unsupported -&gt; width(&quot; &lt;&lt; LayoutUnit { } &lt;&lt; &quot;px) layoutBox: &quot; &lt;&lt; &amp;formattingRoot &lt;&lt; &quot;)&quot;);
 240     ASSERT(formattingRoot.establishesFormattingContext());
 241     ASSERT(usedValues.containingBlockWidth.hasValue());
 242 
 243     // Calculation of the shrink-to-fit width is similar to calculating the width of a table cell using the automatic table layout algorithm.
 244     // Roughly: calculate the preferred width by formatting the content without breaking lines other than where explicit line breaks occur,
 245     // and also calculate the preferred minimum width, e.g., by trying all possible line breaks. CSS 2.2 does not define the exact algorithm.
 246     // Thirdly, find the available width: in this case, this is the width of the containing block minus the used values of &#39;margin-left&#39;, &#39;border-left-width&#39;,
 247     // &#39;padding-left&#39;, &#39;padding-right&#39;, &#39;border-right-width&#39;, &#39;margin-right&#39;, and the widths of any relevant scroll bars.
 248 
 249     // Then the shrink-to-fit width is: min(max(preferred minimum width, available width), preferred width).
<span class="line-modified"> 250     auto&amp; formattingStateForRoot = layoutState.formattingStateForBox(formattingRoot);</span>
<span class="line-modified"> 251     auto intrinsicWidthConstraints = formattingStateForRoot.intrinsicWidthConstraints(formattingRoot);</span>
<span class="line-modified"> 252     if (!intrinsicWidthConstraints) {</span>
<span class="line-modified"> 253         layoutState.createFormattingContext(formattingRoot)-&gt;computeIntrinsicWidthConstraints();</span>
<span class="line-removed"> 254         intrinsicWidthConstraints = formattingStateForRoot.intrinsicWidthConstraints(formattingRoot);</span>
<span class="line-removed"> 255     }</span>
 256     auto availableWidth = *usedValues.containingBlockWidth;
 257     return std::min(std::max(intrinsicWidthConstraints-&gt;minimum, availableWidth), intrinsicWidthConstraints-&gt;maximum);
 258 }
 259 
 260 VerticalGeometry FormattingContext::Geometry::outOfFlowNonReplacedVerticalGeometry(const LayoutState&amp; layoutState, const Box&amp; layoutBox, UsedVerticalValues usedValues)
 261 {
 262     ASSERT(layoutBox.isOutOfFlowPositioned() &amp;&amp; !layoutBox.replaced());
 263 
 264     // 10.6.4 Absolutely positioned, non-replaced elements
 265     //
 266     // For absolutely positioned elements, the used values of the vertical dimensions must satisfy this constraint:
 267     // &#39;top&#39; + &#39;margin-top&#39; + &#39;border-top-width&#39; + &#39;padding-top&#39; + &#39;height&#39; + &#39;padding-bottom&#39; + &#39;border-bottom-width&#39; + &#39;margin-bottom&#39; + &#39;bottom&#39;
 268     // = height of containing block
 269 
 270     // If all three of &#39;top&#39;, &#39;height&#39;, and &#39;bottom&#39; are auto, set &#39;top&#39; to the static position and apply rule number three below.
 271 
 272     // If none of the three are &#39;auto&#39;: If both &#39;margin-top&#39; and &#39;margin-bottom&#39; are &#39;auto&#39;, solve the equation under the extra
 273     // constraint that the two margins get equal values. If one of &#39;margin-top&#39; or &#39;margin-bottom&#39; is &#39;auto&#39;, solve the equation for that value.
 274     // If the values are over-constrained, ignore the value for &#39;bottom&#39; and solve for that value.
 275 
 276     // Otherwise, pick the one of the following six rules that applies.
 277 
 278     // 1. &#39;top&#39; and &#39;height&#39; are &#39;auto&#39; and &#39;bottom&#39; is not &#39;auto&#39;, then the height is based on the content per 10.6.7,
 279     //     set &#39;auto&#39; values for &#39;margin-top&#39; and &#39;margin-bottom&#39; to 0, and solve for &#39;top&#39;
 280     // 2. &#39;top&#39; and &#39;bottom&#39; are &#39;auto&#39; and &#39;height&#39; is not &#39;auto&#39;, then set &#39;top&#39; to the static position, set &#39;auto&#39; values for
 281     //    &#39;margin-top&#39; and &#39;margin-bottom&#39; to 0, and solve for &#39;bottom&#39;
 282     // 3. &#39;height&#39; and &#39;bottom&#39; are &#39;auto&#39; and &#39;top&#39; is not &#39;auto&#39;, then the height is based on the content per 10.6.7, set &#39;auto&#39;
 283     //     values for &#39;margin-top&#39; and &#39;margin-bottom&#39; to 0, and solve for &#39;bottom&#39;
 284     // 4. &#39;top&#39; is &#39;auto&#39;, &#39;height&#39; and &#39;bottom&#39; are not &#39;auto&#39;, then set &#39;auto&#39; values for &#39;margin-top&#39; and &#39;margin-bottom&#39; to 0, and solve for &#39;top&#39;
 285     // 5. &#39;height&#39; is &#39;auto&#39;, &#39;top&#39; and &#39;bottom&#39; are not &#39;auto&#39;, then &#39;auto&#39; values for &#39;margin-top&#39; and &#39;margin-bottom&#39; are set to 0 and solve for &#39;height&#39;
 286     // 6. &#39;bottom&#39; is &#39;auto&#39;, &#39;top&#39; and &#39;height&#39; are not &#39;auto&#39;, then set &#39;auto&#39; values for &#39;margin-top&#39; and &#39;margin-bottom&#39; to 0 and solve for &#39;bottom&#39;
 287 
 288     auto&amp; style = layoutBox.style();
 289     auto&amp; displayBox = layoutState.displayBoxForLayoutBox(layoutBox);
 290     auto&amp; containingBlockDisplayBox = layoutState.displayBoxForLayoutBox(*layoutBox.containingBlock());
 291     auto containingBlockHeight = containingBlockDisplayBox.paddingBoxHeight();
 292     auto containingBlockWidth = containingBlockDisplayBox.paddingBoxWidth();
 293 
 294     auto top = computedValueIfNotAuto(style.logicalTop(), containingBlockWidth);
 295     auto bottom = computedValueIfNotAuto(style.logicalBottom(), containingBlockWidth);
<span class="line-removed"> 296     auto isStaticallyPositioned = !top &amp;&amp; !bottom;</span>
 297     auto height = usedValues.height ? usedValues.height.value() : computedHeightValue(layoutState, layoutBox, HeightType::Normal);
 298     auto computedVerticalMargin = Geometry::computedVerticalMargin(layoutBox, UsedHorizontalValues { containingBlockWidth });
 299     UsedVerticalMargin::NonCollapsedValues usedVerticalMargin;
 300     auto paddingTop = displayBox.paddingTop().valueOr(0);
 301     auto paddingBottom = displayBox.paddingBottom().valueOr(0);
 302     auto borderTop = displayBox.borderTop();
 303     auto borderBottom = displayBox.borderBottom();
 304     auto contentHeight = [&amp;] {
 305         ASSERT(height);
 306         return style.boxSizing() == BoxSizing::ContentBox ? *height : *height - (borderTop + paddingTop + paddingBottom + borderBottom);
 307     };
 308 
 309     if (!top &amp;&amp; !height &amp;&amp; !bottom)
 310         top = staticVerticalPositionForOutOfFlowPositioned(layoutState, layoutBox);
 311 
 312     if (top &amp;&amp; height &amp;&amp; bottom) {
 313         if (!computedVerticalMargin.before &amp;&amp; !computedVerticalMargin.after) {
 314             auto marginBeforeAndAfter = containingBlockHeight - (*top + borderTop + paddingTop + contentHeight() + paddingBottom + borderBottom + *bottom);
 315             usedVerticalMargin = { marginBeforeAndAfter / 2, marginBeforeAndAfter / 2 };
 316         } else if (!computedVerticalMargin.before) {
</pre>
<hr />
<pre>
 354         top = containingBlockHeight - (usedVerticalMargin.before + borderTop + paddingTop + contentHeight() + paddingBottom + borderBottom + usedVerticalMargin.after + *bottom);
 355     }
 356 
 357     if (!height &amp;&amp; top &amp;&amp; bottom) {
 358         // #5
 359         usedVerticalMargin = { computedVerticalMargin.before.valueOr(0), computedVerticalMargin.after.valueOr(0) };
 360         height = containingBlockHeight - (*top + usedVerticalMargin.before + borderTop + paddingTop + paddingBottom + borderBottom + usedVerticalMargin.after + *bottom);
 361     }
 362 
 363     if (!bottom &amp;&amp; top &amp;&amp; height) {
 364         // #6
 365         usedVerticalMargin = { computedVerticalMargin.before.valueOr(0), computedVerticalMargin.after.valueOr(0) };
 366         bottom = containingBlockHeight - (*top + usedVerticalMargin.before + borderTop + paddingTop + contentHeight() + paddingBottom + borderBottom + usedVerticalMargin.after);
 367     }
 368 
 369     ASSERT(top);
 370     ASSERT(bottom);
 371     ASSERT(height);
 372 
 373     // For out-of-flow elements the containing block is formed by the padding edge of the ancestor.
<span class="line-modified"> 374     // At this point the non-statically positioned value is in the coordinate system of the padding box. Let&#39;s convert it to border box coordinate system.</span>
<span class="line-modified"> 375     if (!isStaticallyPositioned) {</span>
<span class="line-modified"> 376         auto containingBlockPaddingVerticalEdge = containingBlockDisplayBox.paddingBoxTop();</span>
<span class="line-modified"> 377         *top += containingBlockPaddingVerticalEdge;</span>
<span class="line-removed"> 378         *bottom += containingBlockPaddingVerticalEdge;</span>
<span class="line-removed"> 379     }</span>
 380 
 381     LOG_WITH_STREAM(FormattingContextLayout, stream &lt;&lt; &quot;[Position][Height][Margin] -&gt; out-of-flow non-replaced -&gt; top(&quot; &lt;&lt; *top &lt;&lt; &quot;px) bottom(&quot;  &lt;&lt; *bottom &lt;&lt; &quot;px) height(&quot; &lt;&lt; *height &lt;&lt; &quot;px) margin(&quot; &lt;&lt; usedVerticalMargin.before &lt;&lt; &quot;px, &quot;  &lt;&lt; usedVerticalMargin.after &lt;&lt; &quot;px) layoutBox(&quot; &lt;&lt; &amp;layoutBox &lt;&lt; &quot;)&quot;);
 382     return { *top, *bottom, { contentHeight(), usedVerticalMargin } };
 383 }
 384 
 385 HorizontalGeometry FormattingContext::Geometry::outOfFlowNonReplacedHorizontalGeometry(LayoutState&amp; layoutState, const Box&amp; layoutBox, UsedHorizontalValues usedValues)
 386 {
 387     ASSERT(layoutBox.isOutOfFlowPositioned() &amp;&amp; !layoutBox.replaced());
 388 
 389     // 10.3.7 Absolutely positioned, non-replaced elements
 390     //
 391     // &#39;left&#39; + &#39;margin-left&#39; + &#39;border-left-width&#39; + &#39;padding-left&#39; + &#39;width&#39; + &#39;padding-right&#39; + &#39;border-right-width&#39; + &#39;margin-right&#39; + &#39;right&#39;
 392     // = width of containing block
 393 
 394     // If all three of &#39;left&#39;, &#39;width&#39;, and &#39;right&#39; are &#39;auto&#39;: First set any &#39;auto&#39; values for &#39;margin-left&#39; and &#39;margin-right&#39; to 0.
 395     // Then, if the &#39;direction&#39; property of the element establishing the static-position containing block is &#39;ltr&#39; set &#39;left&#39; to the static
 396     // position and apply rule number three below; otherwise, set &#39;right&#39; to the static position and apply rule number one below.
 397     //
 398     // If none of the three is &#39;auto&#39;: If both &#39;margin-left&#39; and &#39;margin-right&#39; are &#39;auto&#39;, solve the equation under the extra constraint that the two margins get equal values,
 399     // unless this would make them negative, in which case when direction of the containing block is &#39;ltr&#39; (&#39;rtl&#39;), set &#39;margin-left&#39; (&#39;margin-right&#39;) to zero and
</pre>
<hr />
<pre>
 404     // Otherwise, set &#39;auto&#39; values for &#39;margin-left&#39; and &#39;margin-right&#39; to 0, and pick the one of the following six rules that applies.
 405     //
 406     // 1. &#39;left&#39; and &#39;width&#39; are &#39;auto&#39; and &#39;right&#39; is not &#39;auto&#39;, then the width is shrink-to-fit. Then solve for &#39;left&#39;
 407     // 2. &#39;left&#39; and &#39;right&#39; are &#39;auto&#39; and &#39;width&#39; is not &#39;auto&#39;, then if the &#39;direction&#39; property of the element establishing the static-position
 408     //    containing block is &#39;ltr&#39; set &#39;left&#39; to the static position, otherwise set &#39;right&#39; to the static position.
 409     //    Then solve for &#39;left&#39; (if &#39;direction is &#39;rtl&#39;) or &#39;right&#39; (if &#39;direction&#39; is &#39;ltr&#39;).
 410     // 3. &#39;width&#39; and &#39;right&#39; are &#39;auto&#39; and &#39;left&#39; is not &#39;auto&#39;, then the width is shrink-to-fit . Then solve for &#39;right&#39;
 411     // 4. &#39;left&#39; is &#39;auto&#39;, &#39;width&#39; and &#39;right&#39; are not &#39;auto&#39;, then solve for &#39;left&#39;
 412     // 5. &#39;width&#39; is &#39;auto&#39;, &#39;left&#39; and &#39;right&#39; are not &#39;auto&#39;, then solve for &#39;width&#39;
 413     // 6. &#39;right&#39; is &#39;auto&#39;, &#39;left&#39; and &#39;width&#39; are not &#39;auto&#39;, then solve for &#39;right&#39;
 414 
 415     auto&amp; style = layoutBox.style();
 416     auto&amp; displayBox = layoutState.displayBoxForLayoutBox(layoutBox);
 417     auto&amp; containingBlock = *layoutBox.containingBlock();
 418     auto&amp; containingBlockDisplayBox = layoutState.displayBoxForLayoutBox(containingBlock);
 419     auto containingBlockWidth = usedValues.containingBlockWidth.valueOr(0);
 420     auto isLeftToRightDirection = containingBlock.style().isLeftToRightDirection();
 421 
 422     auto left = computedValueIfNotAuto(style.logicalLeft(), containingBlockWidth);
 423     auto right = computedValueIfNotAuto(style.logicalRight(), containingBlockWidth);
<span class="line-removed"> 424     auto isStaticallyPositioned = !left &amp;&amp; !right;</span>
 425     auto width = computedValueIfNotAuto(usedValues.width ? Length { usedValues.width.value(), Fixed } : style.logicalWidth(), containingBlockWidth);
 426     auto computedHorizontalMargin = Geometry::computedHorizontalMargin(layoutBox, usedValues);
 427     UsedHorizontalMargin usedHorizontalMargin;
 428     auto paddingLeft = displayBox.paddingLeft().valueOr(0);
 429     auto paddingRight = displayBox.paddingRight().valueOr(0);
 430     auto borderLeft = displayBox.borderLeft();
 431     auto borderRight = displayBox.borderRight();
 432     auto contentWidth = [&amp;] {
 433         ASSERT(width);
 434         return style.boxSizing() == BoxSizing::ContentBox ? *width : *width - (borderLeft + paddingLeft + paddingRight + borderRight);
 435     };
 436 
 437     if (!left &amp;&amp; !width &amp;&amp; !right) {
 438         // If all three of &#39;left&#39;, &#39;width&#39;, and &#39;right&#39; are &#39;auto&#39;: First set any &#39;auto&#39; values for &#39;margin-left&#39; and &#39;margin-right&#39; to 0.
 439         // Then, if the &#39;direction&#39; property of the element establishing the static-position containing block is &#39;ltr&#39; set &#39;left&#39; to the static
 440         // position and apply rule number three below; otherwise, set &#39;right&#39; to the static position and apply rule number one below.
 441         usedHorizontalMargin = { computedHorizontalMargin.start.valueOr(0), computedHorizontalMargin.end.valueOr(0) };
 442 
 443         auto staticHorizontalPosition = staticHorizontalPositionForOutOfFlowPositioned(layoutState, layoutBox);
 444         if (isLeftToRightDirection)
</pre>
<hr />
<pre>
 450         // unless this would make them negative, in which case when direction of the containing block is &#39;ltr&#39; (&#39;rtl&#39;), set &#39;margin-left&#39; (&#39;margin-right&#39;) to zero and
 451         // solve for &#39;margin-right&#39; (&#39;margin-left&#39;). If one of &#39;margin-left&#39; or &#39;margin-right&#39; is &#39;auto&#39;, solve the equation for that value.
 452         // If the values are over-constrained, ignore the value for &#39;left&#39; (in case the &#39;direction&#39; property of the containing block is &#39;rtl&#39;) or &#39;right&#39;
 453         // (in case &#39;direction&#39; is &#39;ltr&#39;) and solve for that value.
 454         if (!computedHorizontalMargin.start &amp;&amp; !computedHorizontalMargin.end) {
 455             auto marginStartAndEnd = containingBlockWidth - (*left + borderLeft + paddingLeft + contentWidth() + paddingRight + borderRight + *right);
 456             if (marginStartAndEnd &gt;= 0)
 457                 usedHorizontalMargin = { marginStartAndEnd / 2, marginStartAndEnd / 2 };
 458             else {
 459                 if (isLeftToRightDirection) {
 460                     usedHorizontalMargin.start = 0_lu;
 461                     usedHorizontalMargin.end = containingBlockWidth - (*left + usedHorizontalMargin.start + borderLeft + paddingLeft + contentWidth() + paddingRight + borderRight + *right);
 462                 } else {
 463                     usedHorizontalMargin.end = 0_lu;
 464                     usedHorizontalMargin.start = containingBlockWidth - (*left + borderLeft + paddingLeft + contentWidth() + paddingRight + borderRight + usedHorizontalMargin.end + *right);
 465                 }
 466             }
 467         } else if (!computedHorizontalMargin.start) {
 468             usedHorizontalMargin.end = *computedHorizontalMargin.end;
 469             usedHorizontalMargin.start = containingBlockWidth - (*left + borderLeft + paddingLeft + contentWidth() + paddingRight + borderRight + usedHorizontalMargin.end + *right);
<span class="line-removed"> 470             // Overconstrained? Ignore right (left).</span>
<span class="line-removed"> 471             if (usedHorizontalMargin.start &lt; 0) {</span>
<span class="line-removed"> 472                 if (isLeftToRightDirection)</span>
<span class="line-removed"> 473                     usedHorizontalMargin.start = containingBlockWidth - (*left + borderLeft + paddingLeft + contentWidth() + paddingRight + borderRight + usedHorizontalMargin.end);</span>
<span class="line-removed"> 474                 else</span>
<span class="line-removed"> 475                     usedHorizontalMargin.start = containingBlockWidth - (borderLeft + paddingLeft + contentWidth() + paddingRight + borderRight + usedHorizontalMargin.end + *right);</span>
<span class="line-removed"> 476             }</span>
 477         } else if (!computedHorizontalMargin.end) {
 478             usedHorizontalMargin.start = *computedHorizontalMargin.start;
 479             usedHorizontalMargin.end = containingBlockWidth - (*left + usedHorizontalMargin.start + borderLeft + paddingLeft + contentWidth() + paddingRight + borderRight + *right);
<span class="line-modified"> 480             // Overconstrained? Ignore right (left).</span>
<span class="line-removed"> 481             if (usedHorizontalMargin.end &lt; 0) {</span>
<span class="line-removed"> 482                 if (isLeftToRightDirection)</span>
<span class="line-removed"> 483                     usedHorizontalMargin.end = containingBlockWidth - (*left + usedHorizontalMargin.start + borderLeft + paddingLeft + contentWidth() + paddingRight + borderRight);</span>
<span class="line-removed"> 484                 else</span>
<span class="line-removed"> 485                     usedHorizontalMargin.end = containingBlockWidth - (usedHorizontalMargin.start + borderLeft + paddingLeft + contentWidth() + paddingRight + borderRight + *right);</span>
<span class="line-removed"> 486             }</span>
<span class="line-removed"> 487         } else</span>
 488             usedHorizontalMargin = { *computedHorizontalMargin.start, *computedHorizontalMargin.end };






 489     } else {
 490         // Otherwise, set &#39;auto&#39; values for &#39;margin-left&#39; and &#39;margin-right&#39; to 0, and pick the one of the following six rules that applies.
 491         usedHorizontalMargin = { computedHorizontalMargin.start.valueOr(0), computedHorizontalMargin.end.valueOr(0) };
 492     }
 493 
 494     if (!left &amp;&amp; !width &amp;&amp; right) {
 495         // #1
<span class="line-modified"> 496         width = shrinkToFitWidth(layoutState, layoutBox, usedValues);</span>



 497         left = containingBlockWidth - (usedHorizontalMargin.start + borderLeft + paddingLeft + *width + paddingRight  + borderRight + usedHorizontalMargin.end + *right);
 498     } else if (!left &amp;&amp; !right &amp;&amp; width) {
 499         // #2
 500         auto staticHorizontalPosition = staticHorizontalPositionForOutOfFlowPositioned(layoutState, layoutBox);
 501         if (isLeftToRightDirection) {
 502             left = staticHorizontalPosition;
 503             right = containingBlockWidth - (*left + usedHorizontalMargin.start + borderLeft + paddingLeft + contentWidth() + paddingRight + borderRight + usedHorizontalMargin.end);
 504         } else {
 505             right = staticHorizontalPosition;
 506             left = containingBlockWidth - (usedHorizontalMargin.start + borderLeft + paddingLeft + contentWidth() + paddingRight + borderRight + usedHorizontalMargin.end + *right);
 507         }
 508     } else if (!width &amp;&amp; !right &amp;&amp; left) {
 509         // #3
<span class="line-modified"> 510         width = shrinkToFitWidth(layoutState, layoutBox, usedValues);</span>



 511         right = containingBlockWidth - (*left + usedHorizontalMargin.start + borderLeft + paddingLeft + *width + paddingRight + borderRight + usedHorizontalMargin.end);
 512     } else if (!left &amp;&amp; width &amp;&amp; right) {
 513         // #4
 514         left = containingBlockWidth - (usedHorizontalMargin.start + borderLeft + paddingLeft + contentWidth() + paddingRight + borderRight + usedHorizontalMargin.end + *right);
 515     } else if (!width &amp;&amp; left &amp;&amp; right) {
 516         // #5
 517         width = containingBlockWidth - (*left + usedHorizontalMargin.start + borderLeft + paddingLeft + paddingRight + borderRight + usedHorizontalMargin.end + *right);
 518     } else if (!right &amp;&amp; left &amp;&amp; width) {
 519         // #6
 520         right = containingBlockWidth - (*left + usedHorizontalMargin.start + borderLeft + paddingLeft + contentWidth() + paddingRight + borderRight + usedHorizontalMargin.end);
 521     }
 522 
 523     ASSERT(left);
 524     ASSERT(right);
 525     ASSERT(width);
 526 
 527     // For out-of-flow elements the containing block is formed by the padding edge of the ancestor.
<span class="line-modified"> 528     // At this point the non-statically positioned value is in the coordinate system of the padding box. Let&#39;s convert it to border box coordinate system.</span>
<span class="line-modified"> 529     if (!isStaticallyPositioned) {</span>
<span class="line-modified"> 530         auto containingBlockPaddingVerticalEdge = containingBlockDisplayBox.paddingBoxLeft();</span>
<span class="line-modified"> 531         *left += containingBlockPaddingVerticalEdge;</span>
<span class="line-removed"> 532         *right += containingBlockPaddingVerticalEdge;</span>
<span class="line-removed"> 533     }</span>
 534 
 535     LOG_WITH_STREAM(FormattingContextLayout, stream &lt;&lt; &quot;[Position][Width][Margin] -&gt; out-of-flow non-replaced -&gt; left(&quot; &lt;&lt; *left &lt;&lt; &quot;px) right(&quot;  &lt;&lt; *right &lt;&lt; &quot;px) width(&quot; &lt;&lt; *width &lt;&lt; &quot;px) margin(&quot; &lt;&lt; usedHorizontalMargin.start &lt;&lt; &quot;px, &quot;  &lt;&lt; usedHorizontalMargin.end &lt;&lt; &quot;px) layoutBox(&quot; &lt;&lt; &amp;layoutBox &lt;&lt; &quot;)&quot;);
 536     return { *left, *right, { contentWidth(), usedHorizontalMargin, computedHorizontalMargin } };
 537 }
 538 
 539 VerticalGeometry FormattingContext::Geometry::outOfFlowReplacedVerticalGeometry(const LayoutState&amp; layoutState, const Box&amp; layoutBox, UsedVerticalValues usedValues)
 540 {
 541     ASSERT(layoutBox.isOutOfFlowPositioned() &amp;&amp; layoutBox.replaced());
 542 
 543     // 10.6.5 Absolutely positioned, replaced elements
 544     //
 545     // The used value of &#39;height&#39; is determined as for inline replaced elements.
 546     // If &#39;margin-top&#39; or &#39;margin-bottom&#39; is specified as &#39;auto&#39; its used value is determined by the rules below.
 547     // 1. If both &#39;top&#39; and &#39;bottom&#39; have the value &#39;auto&#39;, replace &#39;top&#39; with the element&#39;s static position.
 548     // 2. If &#39;bottom&#39; is &#39;auto&#39;, replace any &#39;auto&#39; on &#39;margin-top&#39; or &#39;margin-bottom&#39; with &#39;0&#39;.
 549     // 3. If at this point both &#39;margin-top&#39; and &#39;margin-bottom&#39; are still &#39;auto&#39;, solve the equation under the extra constraint that the two margins must get equal values.
 550     // 4. If at this point there is only one &#39;auto&#39; left, solve the equation for that value.
 551     // 5. If at this point the values are over-constrained, ignore the value for &#39;bottom&#39; and solve for that value.
 552 
 553     auto&amp; style = layoutBox.style();
 554     auto&amp; displayBox = layoutState.displayBoxForLayoutBox(layoutBox);
 555     auto&amp; containingBlockDisplayBox = layoutState.displayBoxForLayoutBox(*layoutBox.containingBlock());
 556     auto containingBlockHeight = containingBlockDisplayBox.paddingBoxHeight();
 557     auto containingBlockWidth = containingBlockDisplayBox.paddingBoxWidth();
 558 
 559     auto top = computedValueIfNotAuto(style.logicalTop(), containingBlockWidth);
 560     auto bottom = computedValueIfNotAuto(style.logicalBottom(), containingBlockWidth);
<span class="line-removed"> 561     auto isStaticallyPositioned = !top &amp;&amp; !bottom;</span>
 562     auto height = inlineReplacedHeightAndMargin(layoutState, layoutBox, usedValues).height;
 563     auto computedVerticalMargin = Geometry::computedVerticalMargin(layoutBox, UsedHorizontalValues { containingBlockWidth });
 564     Optional&lt;LayoutUnit&gt; usedMarginBefore = computedVerticalMargin.before;
 565     Optional&lt;LayoutUnit&gt; usedMarginAfter = computedVerticalMargin.after;
 566     auto paddingTop = displayBox.paddingTop().valueOr(0);
 567     auto paddingBottom = displayBox.paddingBottom().valueOr(0);
 568     auto borderTop = displayBox.borderTop();
 569     auto borderBottom = displayBox.borderBottom();
 570 
 571     if (!top &amp;&amp; !bottom) {
 572         // #1
 573         top = staticVerticalPositionForOutOfFlowPositioned(layoutState, layoutBox);
 574     }
 575 
 576     if (!bottom) {
 577         // #2
 578         usedMarginBefore = computedVerticalMargin.before.valueOr(0);
 579         usedMarginAfter = usedMarginBefore;
 580     }
 581 
</pre>
<hr />
<pre>
 588 
 589     // #4
 590     if (!top)
 591         top = containingBlockHeight - (*usedMarginBefore + borderTop + paddingTop + height + paddingBottom + borderBottom + *usedMarginAfter + *bottom);
 592 
 593     if (!bottom)
 594         bottom = containingBlockHeight - (*top + *usedMarginBefore + borderTop + paddingTop + height + paddingBottom + borderBottom + *usedMarginAfter);
 595 
 596     if (!usedMarginBefore)
 597         usedMarginBefore = containingBlockHeight - (*top + borderTop + paddingTop + height + paddingBottom + borderBottom + *usedMarginAfter + *bottom);
 598 
 599     if (!usedMarginAfter)
 600         usedMarginAfter = containingBlockHeight - (*top + *usedMarginBefore + borderTop + paddingTop + height + paddingBottom + borderBottom + *bottom);
 601 
 602     // #5
 603     auto boxHeight = *top + *usedMarginBefore + borderTop + paddingTop + height + paddingBottom + borderBottom + *usedMarginAfter + *bottom;
 604     if (boxHeight &gt; containingBlockHeight)
 605         bottom = containingBlockHeight - (*top + *usedMarginBefore + borderTop + paddingTop + height + paddingBottom + borderBottom + *usedMarginAfter);
 606 
 607     // For out-of-flow elements the containing block is formed by the padding edge of the ancestor.
<span class="line-modified"> 608     // At this point the non-statically positioned value is in the coordinate system of the padding box. Let&#39;s convert it to border box coordinate system.</span>
<span class="line-modified"> 609     if (!isStaticallyPositioned) {</span>
<span class="line-modified"> 610         auto containingBlockPaddingVerticalEdge = containingBlockDisplayBox.paddingBoxTop();</span>
<span class="line-modified"> 611         *top += containingBlockPaddingVerticalEdge;</span>
<span class="line-removed"> 612         *bottom += containingBlockPaddingVerticalEdge;</span>
<span class="line-removed"> 613     }</span>
 614 
 615     ASSERT(top);
 616     ASSERT(bottom);
 617     ASSERT(usedMarginBefore);
 618     ASSERT(usedMarginAfter);
 619     LOG_WITH_STREAM(FormattingContextLayout, stream &lt;&lt; &quot;[Position][Height][Margin] -&gt; out-of-flow replaced -&gt; top(&quot; &lt;&lt; *top &lt;&lt; &quot;px) bottom(&quot;  &lt;&lt; *bottom &lt;&lt; &quot;px) height(&quot; &lt;&lt; height &lt;&lt; &quot;px) margin(&quot; &lt;&lt; *usedMarginBefore &lt;&lt; &quot;px, &quot;  &lt;&lt; *usedMarginAfter &lt;&lt; &quot;px) layoutBox(&quot; &lt;&lt; &amp;layoutBox &lt;&lt; &quot;)&quot;);
 620     return { *top, *bottom, { height, { *usedMarginBefore, *usedMarginAfter } } };
 621 }
 622 
 623 HorizontalGeometry FormattingContext::Geometry::outOfFlowReplacedHorizontalGeometry(const LayoutState&amp; layoutState, const Box&amp; layoutBox, UsedHorizontalValues usedValues)
 624 {
 625     ASSERT(layoutBox.isOutOfFlowPositioned() &amp;&amp; layoutBox.replaced());
 626 
 627     // 10.3.8 Absolutely positioned, replaced elements
 628     // In this case, section 10.3.7 applies up through and including the constraint equation, but the rest of section 10.3.7 is replaced by the following rules:
 629     //
 630     // The used value of &#39;width&#39; is determined as for inline replaced elements. If &#39;margin-left&#39; or &#39;margin-right&#39; is specified as &#39;auto&#39; its used value is determined by the rules below.
 631     // 1. If both &#39;left&#39; and &#39;right&#39; have the value &#39;auto&#39;, then if the &#39;direction&#39; property of the element establishing the static-position containing block is &#39;ltr&#39;,
 632     //   set &#39;left&#39; to the static position; else if &#39;direction&#39; is &#39;rtl&#39;, set &#39;right&#39; to the static position.
 633     // 2. If &#39;left&#39; or &#39;right&#39; are &#39;auto&#39;, replace any &#39;auto&#39; on &#39;margin-left&#39; or &#39;margin-right&#39; with &#39;0&#39;.
 634     // 3. If at this point both &#39;margin-left&#39; and &#39;margin-right&#39; are still &#39;auto&#39;, solve the equation under the extra constraint that the two margins must get equal values,
 635     //   unless this would make them negative, in which case when the direction of the containing block is &#39;ltr&#39; (&#39;rtl&#39;), set &#39;margin-left&#39; (&#39;margin-right&#39;) to zero and
 636     //   solve for &#39;margin-right&#39; (&#39;margin-left&#39;).
 637     // 4. If at this point there is an &#39;auto&#39; left, solve the equation for that value.
 638     // 5. If at this point the values are over-constrained, ignore the value for either &#39;left&#39; (in case the &#39;direction&#39; property of the containing block is &#39;rtl&#39;) or
 639     //   &#39;right&#39; (in case &#39;direction&#39; is &#39;ltr&#39;) and solve for that value.
 640 
 641     auto&amp; style = layoutBox.style();
 642     auto&amp; displayBox = layoutState.displayBoxForLayoutBox(layoutBox);
 643     auto&amp; containingBlock = *layoutBox.containingBlock();
 644     auto containingBlockWidth = usedValues.containingBlockWidth.valueOr(0);
 645     auto isLeftToRightDirection = containingBlock.style().isLeftToRightDirection();
 646 
 647     auto left = computedValueIfNotAuto(style.logicalLeft(), containingBlockWidth);
 648     auto right = computedValueIfNotAuto(style.logicalRight(), containingBlockWidth);
<span class="line-removed"> 649     auto isStaticallyPositioned = !left &amp;&amp; !right;</span>
 650     auto computedHorizontalMargin = Geometry::computedHorizontalMargin(layoutBox, usedValues);
 651     Optional&lt;LayoutUnit&gt; usedMarginStart = computedHorizontalMargin.start;
 652     Optional&lt;LayoutUnit&gt; usedMarginEnd = computedHorizontalMargin.end;
 653     auto width = inlineReplacedWidthAndMargin(layoutState, layoutBox, usedValues).width;
 654     auto paddingLeft = displayBox.paddingLeft().valueOr(0);
 655     auto paddingRight = displayBox.paddingRight().valueOr(0);
 656     auto borderLeft = displayBox.borderLeft();
 657     auto borderRight = displayBox.borderRight();
 658 
 659     if (!left &amp;&amp; !right) {
 660         // #1
 661         auto staticHorizontalPosition = staticHorizontalPositionForOutOfFlowPositioned(layoutState, layoutBox);
 662         if (isLeftToRightDirection)
 663             left = staticHorizontalPosition;
 664         else
 665             right = staticHorizontalPosition;
 666     }
 667 
 668     if (!left || !right) {
 669         // #2
</pre>
<hr />
<pre>
 699         usedMarginStart = containingBlockWidth - (*left + borderLeft + paddingLeft + width + paddingRight + borderRight + *usedMarginEnd + *right);
 700 
 701     if (!usedMarginEnd)
 702         usedMarginEnd = containingBlockWidth - (*left + *usedMarginStart + borderLeft + paddingLeft + width + paddingRight + borderRight + *right);
 703 
 704     auto boxWidth = (*left + *usedMarginStart + borderLeft + paddingLeft + width + paddingRight + borderRight + *usedMarginEnd + *right);
 705     if (boxWidth &gt; containingBlockWidth) {
 706         // #5 Over-constrained?
 707         if (isLeftToRightDirection)
 708             right = containingBlockWidth - (*left + *usedMarginStart + borderLeft + paddingLeft + width + paddingRight + borderRight + *usedMarginEnd);
 709         else
 710             left = containingBlockWidth - (*usedMarginStart + borderLeft + paddingLeft + width + paddingRight + borderRight + *usedMarginEnd + *right);
 711     }
 712 
 713     ASSERT(left);
 714     ASSERT(right);
 715     ASSERT(usedMarginStart);
 716     ASSERT(usedMarginEnd);
 717 
 718     // For out-of-flow elements the containing block is formed by the padding edge of the ancestor.
<span class="line-modified"> 719     // At this point the non-statically positioned value is in the coordinate system of the padding box. Let&#39;s convert it to border box coordinate system.</span>
<span class="line-modified"> 720     if (!isStaticallyPositioned) {</span>
<span class="line-modified"> 721         auto containingBlockPaddingVerticalEdge = layoutState.displayBoxForLayoutBox(containingBlock).paddingBoxLeft();</span>
<span class="line-modified"> 722         *left += containingBlockPaddingVerticalEdge;</span>
<span class="line-removed"> 723         *right += containingBlockPaddingVerticalEdge;</span>
<span class="line-removed"> 724     }</span>
 725 
 726     LOG_WITH_STREAM(FormattingContextLayout, stream &lt;&lt; &quot;[Position][Width][Margin] -&gt; out-of-flow replaced -&gt; left(&quot; &lt;&lt; *left &lt;&lt; &quot;px) right(&quot;  &lt;&lt; *right &lt;&lt; &quot;px) width(&quot; &lt;&lt; width &lt;&lt; &quot;px) margin(&quot; &lt;&lt; *usedMarginStart &lt;&lt; &quot;px, &quot;  &lt;&lt; *usedMarginEnd &lt;&lt; &quot;px) layoutBox(&quot; &lt;&lt; &amp;layoutBox &lt;&lt; &quot;)&quot;);
 727     return { *left, *right, { width, { *usedMarginStart, *usedMarginEnd }, computedHorizontalMargin } };
 728 }
 729 
 730 HeightAndMargin FormattingContext::Geometry::complicatedCases(const LayoutState&amp; layoutState, const Box&amp; layoutBox, UsedVerticalValues usedValues, UsedHorizontalValues usedHorizontalValues)
 731 {
 732     ASSERT(!layoutBox.replaced());
 733     // TODO: Use complicated-case for document renderer for now (see BlockFormattingContext::Geometry::inFlowHeightAndMargin).
 734     ASSERT((layoutBox.isBlockLevelBox() &amp;&amp; layoutBox.isInFlow() &amp;&amp; !layoutBox.isOverflowVisible()) || layoutBox.isInlineBlockBox() || layoutBox.isFloatingPositioned() || layoutBox.isDocumentBox());
 735 
 736     // 10.6.6 Complicated cases
 737     //
 738     // Block-level, non-replaced elements in normal flow when &#39;overflow&#39; does not compute to &#39;visible&#39; (except if the &#39;overflow&#39; property&#39;s value has been propagated to the viewport).
 739     // &#39;Inline-block&#39;, non-replaced elements.
 740     // Floating, non-replaced elements.
 741     //
 742     // 1. If &#39;margin-top&#39;, or &#39;margin-bottom&#39; are &#39;auto&#39;, their used value is 0.
 743     // 2. If &#39;height&#39; is &#39;auto&#39;, the height depends on the element&#39;s descendants per 10.6.7.
 744 
</pre>
<hr />
<pre>
1022             right = -*left;
1023         else
1024             left = WTF::nullopt;
1025     }
1026 
1027     ASSERT(!bottom || *top == -*bottom);
1028     ASSERT(!left || *left == -*right);
1029 
1030     auto topPositionOffset = *top;
1031     auto leftPositionOffset = left.valueOr(-*right);
1032 
1033     LOG_WITH_STREAM(FormattingContextLayout, stream &lt;&lt; &quot;[Position] -&gt; positioned inflow -&gt; top offset(&quot; &lt;&lt; topPositionOffset &lt;&lt; &quot;px) left offset(&quot; &lt;&lt; leftPositionOffset &lt;&lt; &quot;px) layoutBox(&quot; &lt;&lt; &amp;layoutBox &lt;&lt; &quot;)&quot;);
1034     return { leftPositionOffset, topPositionOffset };
1035 }
1036 
1037 Edges FormattingContext::Geometry::computedBorder(const Box&amp; layoutBox)
1038 {
1039     auto&amp; style = layoutBox.style();
1040     LOG_WITH_STREAM(FormattingContextLayout, stream &lt;&lt; &quot;[Border] -&gt; layoutBox: &quot; &lt;&lt; &amp;layoutBox);
1041     return {
<span class="line-modified">1042         { style.borderLeft().boxModelWidth(), style.borderRight().boxModelWidth() },</span>
<span class="line-modified">1043         { style.borderTop().boxModelWidth(), style.borderBottom().boxModelWidth() }</span>
1044     };
1045 }
1046 
1047 Optional&lt;Edges&gt; FormattingContext::Geometry::computedPadding(const Box&amp; layoutBox, UsedHorizontalValues usedValues)
1048 {
1049     if (!layoutBox.isPaddingApplicable())
1050         return WTF::nullopt;
1051 
1052     auto&amp; style = layoutBox.style();
1053     auto containingBlockWidth = usedValues.containingBlockWidth.valueOr(0);
1054     LOG_WITH_STREAM(FormattingContextLayout, stream &lt;&lt; &quot;[Padding] -&gt; layoutBox: &quot; &lt;&lt; &amp;layoutBox);
1055     return Edges {
1056         { valueForLength(style.paddingLeft(), containingBlockWidth), valueForLength(style.paddingRight(), containingBlockWidth) },
1057         { valueForLength(style.paddingTop(), containingBlockWidth), valueForLength(style.paddingBottom(), containingBlockWidth) }
1058     };
1059 }
1060 
1061 ComputedHorizontalMargin FormattingContext::Geometry::computedHorizontalMargin(const Box&amp; layoutBox, UsedHorizontalValues usedValues)
1062 {
1063     auto&amp; style = layoutBox.style();
</pre>
</td>
<td>
<hr />
<pre>
  14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
  15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
  17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
  23  * THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #include &quot;config.h&quot;
  27 #include &quot;FormattingContext.h&quot;
  28 
  29 #if ENABLE(LAYOUT_FORMATTING_CONTEXT)
  30 
  31 #include &quot;FloatingState.h&quot;
  32 #include &quot;FormattingState.h&quot;
  33 #include &quot;InlineFormattingState.h&quot;
<span class="line-added">  34 #include &quot;TableFormattingState.h&quot;</span>
<span class="line-added">  35 #include &quot;TableGrid.h&quot;</span>
  36 
  37 namespace WebCore {
  38 namespace Layout {
  39 
  40 static inline bool isHeightAuto(const Box&amp; layoutBox)
  41 {
  42     // 10.5 Content height: the &#39;height&#39; property
  43     //
  44     // The percentage is calculated with respect to the height of the generated box&#39;s containing block.
  45     // If the height of the containing block is not specified explicitly (i.e., it depends on content height),
  46     // and this element is not absolutely positioned, the used height is calculated as if &#39;auto&#39; was specified.
  47 
  48     auto height = layoutBox.style().logicalHeight();
  49     if (height.isAuto())
  50         return true;
  51 
  52     if (height.isPercent()) {
  53         if (layoutBox.isOutOfFlowPositioned())
  54             return false;
  55 
  56         return !layoutBox.containingBlock()-&gt;style().logicalHeight().isFixed();
  57     }
  58 
  59     return false;
  60 }
  61 
  62 Optional&lt;LayoutUnit&gt; FormattingContext::Geometry::computedHeightValue(const LayoutState&amp; layoutState, const Box&amp; layoutBox, HeightType heightType)
  63 {
  64     auto&amp; style = layoutBox.style();
  65     auto height = heightType == HeightType::Normal ? style.logicalHeight() : heightType == HeightType::Min ? style.logicalMinHeight() : style.logicalMaxHeight();
  66     if (height.isUndefined() || height.isAuto())
  67         return { };
  68 
  69     if (height.isFixed())
<span class="line-modified">  70         return LayoutUnit(height.value());</span>
  71 
  72     Optional&lt;LayoutUnit&gt; containingBlockHeightValue;
  73     if (layoutBox.isOutOfFlowPositioned()) {
  74         // Containing block&#39;s height is already computed since we layout the out-of-flow boxes as the last step.
  75         containingBlockHeightValue = layoutState.displayBoxForLayoutBox(*layoutBox.containingBlock()).height();
  76     } else {
  77         if (layoutState.inQuirksMode())
  78             containingBlockHeightValue = FormattingContext::Quirks::heightValueOfNearestContainingBlockWithFixedHeight(layoutState, layoutBox);
  79         else {
  80             auto containingBlockHeight = layoutBox.containingBlock()-&gt;style().logicalHeight();
  81             if (containingBlockHeight.isFixed())
<span class="line-modified">  82                 containingBlockHeightValue = LayoutUnit(containingBlockHeight.value());</span>
  83         }
  84     }
  85 
  86     if (!containingBlockHeightValue)
  87         return { };
  88 
  89     return valueForLength(height, *containingBlockHeightValue);
  90 }
  91 
<span class="line-modified">  92 LayoutUnit FormattingContext::Geometry::contentHeightForFormattingContextRoot(const LayoutState&amp; layoutState, const Box&amp; layoutBox)</span>
  93 {
  94     ASSERT(isHeightAuto(layoutBox) &amp;&amp; (layoutBox.establishesFormattingContext() || layoutBox.isDocumentBox()));
  95 
  96     // 10.6.7 &#39;Auto&#39; heights for block formatting context roots
  97 
  98     // If it only has inline-level children, the height is the distance between the top of the topmost line box and the bottom of the bottommost line box.
  99     // If it has block-level children, the height is the distance between the top margin-edge of the topmost block-level
 100     // child box and the bottom margin-edge of the bottommost block-level child box.
 101 
 102     // In addition, if the element has any floating descendants whose bottom margin edge is below the element&#39;s bottom content edge,
 103     // then the height is increased to include those edges. Only floats that participate in this block formatting context are taken
 104     // into account, e.g., floats inside absolutely positioned descendants or other floats are not.
 105     if (!is&lt;Container&gt;(layoutBox) || !downcast&lt;Container&gt;(layoutBox).hasInFlowOrFloatingChild())
<span class="line-modified"> 106         return { };</span>
 107 
 108     auto&amp; displayBox = layoutState.displayBoxForLayoutBox(layoutBox);
 109     auto borderAndPaddingTop = displayBox.borderTop() + displayBox.paddingTop().valueOr(0);
 110     auto top = borderAndPaddingTop;
 111     auto bottom = borderAndPaddingTop;
 112     auto&amp; formattingRootContainer = downcast&lt;Container&gt;(layoutBox);
 113     if (formattingRootContainer.establishesInlineFormattingContext()) {
<span class="line-modified"> 114         auto&amp; lineBoxes = downcast&lt;InlineFormattingState&gt;(layoutState.establishedFormattingState(layoutBox)).lineBoxes();</span>
<span class="line-modified"> 115         // Even empty containers generate one line.</span>
<span class="line-modified"> 116         ASSERT(!lineBoxes.isEmpty());</span>
<span class="line-modified"> 117         top = lineBoxes.first().logicalTop();</span>
<span class="line-modified"> 118         bottom = lineBoxes.last().logicalBottom();</span>

 119     } else if (formattingRootContainer.establishesBlockFormattingContext() || layoutBox.isDocumentBox()) {
 120         if (formattingRootContainer.hasInFlowChild()) {
 121             auto&amp; firstDisplayBox = layoutState.displayBoxForLayoutBox(*formattingRootContainer.firstInFlowChild());
 122             auto&amp; lastDisplayBox = layoutState.displayBoxForLayoutBox(*formattingRootContainer.lastInFlowChild());
 123             top = firstDisplayBox.rectWithMargin().top();
 124             bottom = lastDisplayBox.rectWithMargin().bottom();
 125         }
<span class="line-modified"> 126     } else if (formattingRootContainer.establishesTableFormattingContext()) {</span>
<span class="line-added"> 127         auto&amp; rowList = downcast&lt;TableFormattingState&gt;(layoutState.establishedFormattingState(formattingRootContainer)).tableGrid().rows();</span>
<span class="line-added"> 128         ASSERT(!rowList.isEmpty());</span>
<span class="line-added"> 129         top += rowList.first().logicalTop();</span>
<span class="line-added"> 130         auto&amp; lastRow = rowList.last();</span>
<span class="line-added"> 131         bottom += lastRow.logicalBottom();</span>
<span class="line-added"> 132     } else</span>
<span class="line-added"> 133         ASSERT_NOT_REACHED();</span>
 134 
 135     auto* formattingContextRoot = &amp;layoutBox;
 136     // TODO: The document renderer is not a formatting context root by default at all. Need to find out what it is.
 137     if (!layoutBox.establishesFormattingContext()) {
 138         ASSERT(layoutBox.isDocumentBox());
 139         formattingContextRoot = &amp;layoutBox.formattingContextRoot();
 140     }
 141 
 142     auto&amp; floatingState = layoutState.establishedFormattingState(*formattingContextRoot).floatingState();
 143     auto floatBottom = floatingState.bottom(*formattingContextRoot);
 144     if (floatBottom) {
 145         bottom = std::max&lt;LayoutUnit&gt;(*floatBottom, bottom);
 146         auto floatTop = floatingState.top(*formattingContextRoot);
 147         ASSERT(floatTop);
 148         top = std::min&lt;LayoutUnit&gt;(*floatTop, top);
 149     }
 150 
 151     auto computedHeight = bottom - top;
 152     LOG_WITH_STREAM(FormattingContextLayout, stream &lt;&lt; &quot;[Height] -&gt; content height for formatting context root -&gt; height(&quot; &lt;&lt; computedHeight &lt;&lt; &quot;px) layoutBox(&quot;&lt;&lt; &amp;layoutBox &lt;&lt; &quot;)&quot;);
 153     return computedHeight;
 154 }
 155 
 156 Optional&lt;LayoutUnit&gt; FormattingContext::Geometry::computedValueIfNotAuto(const Length&amp; geometryProperty, LayoutUnit containingBlockWidth)
 157 {
 158     if (geometryProperty.isUndefined())
 159         return WTF::nullopt;
 160 
 161     if (geometryProperty.isAuto())
 162         return WTF::nullopt;
 163 
 164     return valueForLength(geometryProperty, containingBlockWidth);
 165 }
 166 
 167 Optional&lt;LayoutUnit&gt; FormattingContext::Geometry::fixedValue(const Length&amp; geometryProperty)
 168 {
 169     if (!geometryProperty.isFixed())
 170         return WTF::nullopt;
<span class="line-modified"> 171     return LayoutUnit(geometryProperty.value());</span>
 172 }
 173 
 174 // https://www.w3.org/TR/CSS22/visudet.html#min-max-heights
 175 // Specifies a percentage for determining the used value. The percentage is calculated with respect to the height of the generated box&#39;s containing block.
 176 // If the height of the containing block is not specified explicitly (i.e., it depends on content height), and this element is not absolutely positioned,
 177 // the percentage value is treated as &#39;0&#39; (for &#39;min-height&#39;) or &#39;none&#39; (for &#39;max-height&#39;).
 178 Optional&lt;LayoutUnit&gt; FormattingContext::Geometry::computedMaxHeight(const LayoutState&amp; layoutState, const Box&amp; layoutBox)
 179 {
 180     return computedHeightValue(layoutState, layoutBox, HeightType::Max);
 181 }
 182 
 183 Optional&lt;LayoutUnit&gt; FormattingContext::Geometry::computedMinHeight(const LayoutState&amp; layoutState, const Box&amp; layoutBox)
 184 {
 185     if (auto minHeightValue = computedHeightValue(layoutState, layoutBox, HeightType::Min))
 186         return minHeightValue;
 187 
 188     return { 0 };
 189 }
 190 
 191 static LayoutUnit staticVerticalPositionForOutOfFlowPositioned(const LayoutState&amp; layoutState, const Box&amp; layoutBox)
</pre>
<hr />
<pre>
 193     ASSERT(layoutBox.isOutOfFlowPositioned());
 194 
 195     // For the purposes of this section and the next, the term &quot;static position&quot; (of an element) refers, roughly, to the position an element would have
 196     // had in the normal flow. More precisely, the static position for &#39;top&#39; is the distance from the top edge of the containing block to the top margin
 197     // edge of a hypothetical box that would have been the first box of the element if its specified &#39;position&#39; value had been &#39;static&#39; and its specified
 198     // &#39;float&#39; had been &#39;none&#39; and its specified &#39;clear&#39; had been &#39;none&#39;. (Note that due to the rules in section 9.7 this might require also assuming a different
 199     // computed value for &#39;display&#39;.) The value is negative if the hypothetical box is above the containing block.
 200 
 201     // Start with this box&#39;s border box offset from the parent&#39;s border box.
 202     LayoutUnit top;
 203     if (auto* previousInFlowSibling = layoutBox.previousInFlowSibling()) {
 204         // Add sibling offset
 205         auto&amp; previousInFlowDisplayBox = layoutState.displayBoxForLayoutBox(*previousInFlowSibling);
 206         top += previousInFlowDisplayBox.bottom() + previousInFlowDisplayBox.nonCollapsedMarginAfter();
 207     } else {
 208         ASSERT(layoutBox.parent());
 209         top = layoutState.displayBoxForLayoutBox(*layoutBox.parent()).contentBoxTop();
 210     }
 211 
 212     // Resolve top all the way up to the containing block.
<span class="line-modified"> 213     auto&amp; containingBlock = *layoutBox.containingBlock();</span>
 214     // Start with the parent since we pretend that this box is normal flow.
<span class="line-modified"> 215     for (auto* container = layoutBox.parent(); container != &amp;containingBlock; container = container-&gt;containingBlock()) {</span>
 216         auto&amp; displayBox = layoutState.displayBoxForLayoutBox(*container);
 217         // Display::Box::top is the border box top position in its containing block&#39;s coordinate system.
 218         top += displayBox.top();
 219         ASSERT(!container-&gt;isPositioned() || layoutBox.isFixedPositioned());
 220     }
<span class="line-modified"> 221     // Move the static position relative to the padding box. This is very specific to abolutely positioned boxes.</span>
<span class="line-added"> 222     auto paddingBoxTop = layoutState.displayBoxForLayoutBox(containingBlock).paddingBoxTop();</span>
<span class="line-added"> 223     return top - paddingBoxTop;</span>
 224 }
 225 
 226 static LayoutUnit staticHorizontalPositionForOutOfFlowPositioned(const LayoutState&amp; layoutState, const Box&amp; layoutBox)
 227 {
 228     ASSERT(layoutBox.isOutOfFlowPositioned());
 229     // See staticVerticalPositionForOutOfFlowPositioned for the definition of the static position.
 230 
 231     // Start with this box&#39;s border box offset from the parent&#39;s border box.
 232     ASSERT(layoutBox.parent());
 233     auto left = layoutState.displayBoxForLayoutBox(*layoutBox.parent()).contentBoxLeft();
 234 
 235     // Resolve left all the way up to the containing block.
<span class="line-modified"> 236     auto&amp; containingBlock = *layoutBox.containingBlock();</span>
 237     // Start with the parent since we pretend that this box is normal flow.
<span class="line-modified"> 238     for (auto* container = layoutBox.parent(); container != &amp;containingBlock; container = container-&gt;containingBlock()) {</span>
 239         auto&amp; displayBox = layoutState.displayBoxForLayoutBox(*container);
 240         // Display::Box::left is the border box left position in its containing block&#39;s coordinate system.
 241         left += displayBox.left();
 242         ASSERT(!container-&gt;isPositioned() || layoutBox.isFixedPositioned());
 243     }
<span class="line-modified"> 244     // Move the static position relative to the padding box. This is very specific to abolutely positioned boxes.</span>
<span class="line-added"> 245     auto paddingBoxLeft = layoutState.displayBoxForLayoutBox(containingBlock).paddingBoxLeft();</span>
<span class="line-added"> 246     return left - paddingBoxLeft;</span>
 247 }
 248 
 249 LayoutUnit FormattingContext::Geometry::shrinkToFitWidth(LayoutState&amp; layoutState, const Box&amp; formattingRoot, UsedHorizontalValues usedValues)
 250 {
 251     LOG_WITH_STREAM(FormattingContextLayout, stream &lt;&lt; &quot;[Width] -&gt; shrink to fit -&gt; unsupported -&gt; width(&quot; &lt;&lt; LayoutUnit { } &lt;&lt; &quot;px) layoutBox: &quot; &lt;&lt; &amp;formattingRoot &lt;&lt; &quot;)&quot;);
 252     ASSERT(formattingRoot.establishesFormattingContext());
 253     ASSERT(usedValues.containingBlockWidth.hasValue());
 254 
 255     // Calculation of the shrink-to-fit width is similar to calculating the width of a table cell using the automatic table layout algorithm.
 256     // Roughly: calculate the preferred width by formatting the content without breaking lines other than where explicit line breaks occur,
 257     // and also calculate the preferred minimum width, e.g., by trying all possible line breaks. CSS 2.2 does not define the exact algorithm.
 258     // Thirdly, find the available width: in this case, this is the width of the containing block minus the used values of &#39;margin-left&#39;, &#39;border-left-width&#39;,
 259     // &#39;padding-left&#39;, &#39;padding-right&#39;, &#39;border-right-width&#39;, &#39;margin-right&#39;, and the widths of any relevant scroll bars.
 260 
 261     // Then the shrink-to-fit width is: min(max(preferred minimum width, available width), preferred width).
<span class="line-modified"> 262     auto&amp; formattingStateForRoot = layoutState.createFormattingStateForFormattingRootIfNeeded(formattingRoot);</span>
<span class="line-modified"> 263     auto intrinsicWidthConstraints = formattingStateForRoot.intrinsicWidthConstraints();</span>
<span class="line-modified"> 264     if (!intrinsicWidthConstraints)</span>
<span class="line-modified"> 265         intrinsicWidthConstraints = layoutState.createFormattingContext(formattingRoot)-&gt;computedIntrinsicWidthConstraints();</span>


 266     auto availableWidth = *usedValues.containingBlockWidth;
 267     return std::min(std::max(intrinsicWidthConstraints-&gt;minimum, availableWidth), intrinsicWidthConstraints-&gt;maximum);
 268 }
 269 
 270 VerticalGeometry FormattingContext::Geometry::outOfFlowNonReplacedVerticalGeometry(const LayoutState&amp; layoutState, const Box&amp; layoutBox, UsedVerticalValues usedValues)
 271 {
 272     ASSERT(layoutBox.isOutOfFlowPositioned() &amp;&amp; !layoutBox.replaced());
 273 
 274     // 10.6.4 Absolutely positioned, non-replaced elements
 275     //
 276     // For absolutely positioned elements, the used values of the vertical dimensions must satisfy this constraint:
 277     // &#39;top&#39; + &#39;margin-top&#39; + &#39;border-top-width&#39; + &#39;padding-top&#39; + &#39;height&#39; + &#39;padding-bottom&#39; + &#39;border-bottom-width&#39; + &#39;margin-bottom&#39; + &#39;bottom&#39;
 278     // = height of containing block
 279 
 280     // If all three of &#39;top&#39;, &#39;height&#39;, and &#39;bottom&#39; are auto, set &#39;top&#39; to the static position and apply rule number three below.
 281 
 282     // If none of the three are &#39;auto&#39;: If both &#39;margin-top&#39; and &#39;margin-bottom&#39; are &#39;auto&#39;, solve the equation under the extra
 283     // constraint that the two margins get equal values. If one of &#39;margin-top&#39; or &#39;margin-bottom&#39; is &#39;auto&#39;, solve the equation for that value.
 284     // If the values are over-constrained, ignore the value for &#39;bottom&#39; and solve for that value.
 285 
 286     // Otherwise, pick the one of the following six rules that applies.
 287 
 288     // 1. &#39;top&#39; and &#39;height&#39; are &#39;auto&#39; and &#39;bottom&#39; is not &#39;auto&#39;, then the height is based on the content per 10.6.7,
 289     //     set &#39;auto&#39; values for &#39;margin-top&#39; and &#39;margin-bottom&#39; to 0, and solve for &#39;top&#39;
 290     // 2. &#39;top&#39; and &#39;bottom&#39; are &#39;auto&#39; and &#39;height&#39; is not &#39;auto&#39;, then set &#39;top&#39; to the static position, set &#39;auto&#39; values for
 291     //    &#39;margin-top&#39; and &#39;margin-bottom&#39; to 0, and solve for &#39;bottom&#39;
 292     // 3. &#39;height&#39; and &#39;bottom&#39; are &#39;auto&#39; and &#39;top&#39; is not &#39;auto&#39;, then the height is based on the content per 10.6.7, set &#39;auto&#39;
 293     //     values for &#39;margin-top&#39; and &#39;margin-bottom&#39; to 0, and solve for &#39;bottom&#39;
 294     // 4. &#39;top&#39; is &#39;auto&#39;, &#39;height&#39; and &#39;bottom&#39; are not &#39;auto&#39;, then set &#39;auto&#39; values for &#39;margin-top&#39; and &#39;margin-bottom&#39; to 0, and solve for &#39;top&#39;
 295     // 5. &#39;height&#39; is &#39;auto&#39;, &#39;top&#39; and &#39;bottom&#39; are not &#39;auto&#39;, then &#39;auto&#39; values for &#39;margin-top&#39; and &#39;margin-bottom&#39; are set to 0 and solve for &#39;height&#39;
 296     // 6. &#39;bottom&#39; is &#39;auto&#39;, &#39;top&#39; and &#39;height&#39; are not &#39;auto&#39;, then set &#39;auto&#39; values for &#39;margin-top&#39; and &#39;margin-bottom&#39; to 0 and solve for &#39;bottom&#39;
 297 
 298     auto&amp; style = layoutBox.style();
 299     auto&amp; displayBox = layoutState.displayBoxForLayoutBox(layoutBox);
 300     auto&amp; containingBlockDisplayBox = layoutState.displayBoxForLayoutBox(*layoutBox.containingBlock());
 301     auto containingBlockHeight = containingBlockDisplayBox.paddingBoxHeight();
 302     auto containingBlockWidth = containingBlockDisplayBox.paddingBoxWidth();
 303 
 304     auto top = computedValueIfNotAuto(style.logicalTop(), containingBlockWidth);
 305     auto bottom = computedValueIfNotAuto(style.logicalBottom(), containingBlockWidth);

 306     auto height = usedValues.height ? usedValues.height.value() : computedHeightValue(layoutState, layoutBox, HeightType::Normal);
 307     auto computedVerticalMargin = Geometry::computedVerticalMargin(layoutBox, UsedHorizontalValues { containingBlockWidth });
 308     UsedVerticalMargin::NonCollapsedValues usedVerticalMargin;
 309     auto paddingTop = displayBox.paddingTop().valueOr(0);
 310     auto paddingBottom = displayBox.paddingBottom().valueOr(0);
 311     auto borderTop = displayBox.borderTop();
 312     auto borderBottom = displayBox.borderBottom();
 313     auto contentHeight = [&amp;] {
 314         ASSERT(height);
 315         return style.boxSizing() == BoxSizing::ContentBox ? *height : *height - (borderTop + paddingTop + paddingBottom + borderBottom);
 316     };
 317 
 318     if (!top &amp;&amp; !height &amp;&amp; !bottom)
 319         top = staticVerticalPositionForOutOfFlowPositioned(layoutState, layoutBox);
 320 
 321     if (top &amp;&amp; height &amp;&amp; bottom) {
 322         if (!computedVerticalMargin.before &amp;&amp; !computedVerticalMargin.after) {
 323             auto marginBeforeAndAfter = containingBlockHeight - (*top + borderTop + paddingTop + contentHeight() + paddingBottom + borderBottom + *bottom);
 324             usedVerticalMargin = { marginBeforeAndAfter / 2, marginBeforeAndAfter / 2 };
 325         } else if (!computedVerticalMargin.before) {
</pre>
<hr />
<pre>
 363         top = containingBlockHeight - (usedVerticalMargin.before + borderTop + paddingTop + contentHeight() + paddingBottom + borderBottom + usedVerticalMargin.after + *bottom);
 364     }
 365 
 366     if (!height &amp;&amp; top &amp;&amp; bottom) {
 367         // #5
 368         usedVerticalMargin = { computedVerticalMargin.before.valueOr(0), computedVerticalMargin.after.valueOr(0) };
 369         height = containingBlockHeight - (*top + usedVerticalMargin.before + borderTop + paddingTop + paddingBottom + borderBottom + usedVerticalMargin.after + *bottom);
 370     }
 371 
 372     if (!bottom &amp;&amp; top &amp;&amp; height) {
 373         // #6
 374         usedVerticalMargin = { computedVerticalMargin.before.valueOr(0), computedVerticalMargin.after.valueOr(0) };
 375         bottom = containingBlockHeight - (*top + usedVerticalMargin.before + borderTop + paddingTop + contentHeight() + paddingBottom + borderBottom + usedVerticalMargin.after);
 376     }
 377 
 378     ASSERT(top);
 379     ASSERT(bottom);
 380     ASSERT(height);
 381 
 382     // For out-of-flow elements the containing block is formed by the padding edge of the ancestor.
<span class="line-modified"> 383     // At this point the positioned value is in the coordinate system of the padding box. Let&#39;s convert it to border box coordinate system.</span>
<span class="line-modified"> 384     auto containingBlockPaddingVerticalEdge = containingBlockDisplayBox.paddingBoxTop();</span>
<span class="line-modified"> 385     *top += containingBlockPaddingVerticalEdge;</span>
<span class="line-modified"> 386     *bottom += containingBlockPaddingVerticalEdge;</span>


 387 
 388     LOG_WITH_STREAM(FormattingContextLayout, stream &lt;&lt; &quot;[Position][Height][Margin] -&gt; out-of-flow non-replaced -&gt; top(&quot; &lt;&lt; *top &lt;&lt; &quot;px) bottom(&quot;  &lt;&lt; *bottom &lt;&lt; &quot;px) height(&quot; &lt;&lt; *height &lt;&lt; &quot;px) margin(&quot; &lt;&lt; usedVerticalMargin.before &lt;&lt; &quot;px, &quot;  &lt;&lt; usedVerticalMargin.after &lt;&lt; &quot;px) layoutBox(&quot; &lt;&lt; &amp;layoutBox &lt;&lt; &quot;)&quot;);
 389     return { *top, *bottom, { contentHeight(), usedVerticalMargin } };
 390 }
 391 
 392 HorizontalGeometry FormattingContext::Geometry::outOfFlowNonReplacedHorizontalGeometry(LayoutState&amp; layoutState, const Box&amp; layoutBox, UsedHorizontalValues usedValues)
 393 {
 394     ASSERT(layoutBox.isOutOfFlowPositioned() &amp;&amp; !layoutBox.replaced());
 395 
 396     // 10.3.7 Absolutely positioned, non-replaced elements
 397     //
 398     // &#39;left&#39; + &#39;margin-left&#39; + &#39;border-left-width&#39; + &#39;padding-left&#39; + &#39;width&#39; + &#39;padding-right&#39; + &#39;border-right-width&#39; + &#39;margin-right&#39; + &#39;right&#39;
 399     // = width of containing block
 400 
 401     // If all three of &#39;left&#39;, &#39;width&#39;, and &#39;right&#39; are &#39;auto&#39;: First set any &#39;auto&#39; values for &#39;margin-left&#39; and &#39;margin-right&#39; to 0.
 402     // Then, if the &#39;direction&#39; property of the element establishing the static-position containing block is &#39;ltr&#39; set &#39;left&#39; to the static
 403     // position and apply rule number three below; otherwise, set &#39;right&#39; to the static position and apply rule number one below.
 404     //
 405     // If none of the three is &#39;auto&#39;: If both &#39;margin-left&#39; and &#39;margin-right&#39; are &#39;auto&#39;, solve the equation under the extra constraint that the two margins get equal values,
 406     // unless this would make them negative, in which case when direction of the containing block is &#39;ltr&#39; (&#39;rtl&#39;), set &#39;margin-left&#39; (&#39;margin-right&#39;) to zero and
</pre>
<hr />
<pre>
 411     // Otherwise, set &#39;auto&#39; values for &#39;margin-left&#39; and &#39;margin-right&#39; to 0, and pick the one of the following six rules that applies.
 412     //
 413     // 1. &#39;left&#39; and &#39;width&#39; are &#39;auto&#39; and &#39;right&#39; is not &#39;auto&#39;, then the width is shrink-to-fit. Then solve for &#39;left&#39;
 414     // 2. &#39;left&#39; and &#39;right&#39; are &#39;auto&#39; and &#39;width&#39; is not &#39;auto&#39;, then if the &#39;direction&#39; property of the element establishing the static-position
 415     //    containing block is &#39;ltr&#39; set &#39;left&#39; to the static position, otherwise set &#39;right&#39; to the static position.
 416     //    Then solve for &#39;left&#39; (if &#39;direction is &#39;rtl&#39;) or &#39;right&#39; (if &#39;direction&#39; is &#39;ltr&#39;).
 417     // 3. &#39;width&#39; and &#39;right&#39; are &#39;auto&#39; and &#39;left&#39; is not &#39;auto&#39;, then the width is shrink-to-fit . Then solve for &#39;right&#39;
 418     // 4. &#39;left&#39; is &#39;auto&#39;, &#39;width&#39; and &#39;right&#39; are not &#39;auto&#39;, then solve for &#39;left&#39;
 419     // 5. &#39;width&#39; is &#39;auto&#39;, &#39;left&#39; and &#39;right&#39; are not &#39;auto&#39;, then solve for &#39;width&#39;
 420     // 6. &#39;right&#39; is &#39;auto&#39;, &#39;left&#39; and &#39;width&#39; are not &#39;auto&#39;, then solve for &#39;right&#39;
 421 
 422     auto&amp; style = layoutBox.style();
 423     auto&amp; displayBox = layoutState.displayBoxForLayoutBox(layoutBox);
 424     auto&amp; containingBlock = *layoutBox.containingBlock();
 425     auto&amp; containingBlockDisplayBox = layoutState.displayBoxForLayoutBox(containingBlock);
 426     auto containingBlockWidth = usedValues.containingBlockWidth.valueOr(0);
 427     auto isLeftToRightDirection = containingBlock.style().isLeftToRightDirection();
 428 
 429     auto left = computedValueIfNotAuto(style.logicalLeft(), containingBlockWidth);
 430     auto right = computedValueIfNotAuto(style.logicalRight(), containingBlockWidth);

 431     auto width = computedValueIfNotAuto(usedValues.width ? Length { usedValues.width.value(), Fixed } : style.logicalWidth(), containingBlockWidth);
 432     auto computedHorizontalMargin = Geometry::computedHorizontalMargin(layoutBox, usedValues);
 433     UsedHorizontalMargin usedHorizontalMargin;
 434     auto paddingLeft = displayBox.paddingLeft().valueOr(0);
 435     auto paddingRight = displayBox.paddingRight().valueOr(0);
 436     auto borderLeft = displayBox.borderLeft();
 437     auto borderRight = displayBox.borderRight();
 438     auto contentWidth = [&amp;] {
 439         ASSERT(width);
 440         return style.boxSizing() == BoxSizing::ContentBox ? *width : *width - (borderLeft + paddingLeft + paddingRight + borderRight);
 441     };
 442 
 443     if (!left &amp;&amp; !width &amp;&amp; !right) {
 444         // If all three of &#39;left&#39;, &#39;width&#39;, and &#39;right&#39; are &#39;auto&#39;: First set any &#39;auto&#39; values for &#39;margin-left&#39; and &#39;margin-right&#39; to 0.
 445         // Then, if the &#39;direction&#39; property of the element establishing the static-position containing block is &#39;ltr&#39; set &#39;left&#39; to the static
 446         // position and apply rule number three below; otherwise, set &#39;right&#39; to the static position and apply rule number one below.
 447         usedHorizontalMargin = { computedHorizontalMargin.start.valueOr(0), computedHorizontalMargin.end.valueOr(0) };
 448 
 449         auto staticHorizontalPosition = staticHorizontalPositionForOutOfFlowPositioned(layoutState, layoutBox);
 450         if (isLeftToRightDirection)
</pre>
<hr />
<pre>
 456         // unless this would make them negative, in which case when direction of the containing block is &#39;ltr&#39; (&#39;rtl&#39;), set &#39;margin-left&#39; (&#39;margin-right&#39;) to zero and
 457         // solve for &#39;margin-right&#39; (&#39;margin-left&#39;). If one of &#39;margin-left&#39; or &#39;margin-right&#39; is &#39;auto&#39;, solve the equation for that value.
 458         // If the values are over-constrained, ignore the value for &#39;left&#39; (in case the &#39;direction&#39; property of the containing block is &#39;rtl&#39;) or &#39;right&#39;
 459         // (in case &#39;direction&#39; is &#39;ltr&#39;) and solve for that value.
 460         if (!computedHorizontalMargin.start &amp;&amp; !computedHorizontalMargin.end) {
 461             auto marginStartAndEnd = containingBlockWidth - (*left + borderLeft + paddingLeft + contentWidth() + paddingRight + borderRight + *right);
 462             if (marginStartAndEnd &gt;= 0)
 463                 usedHorizontalMargin = { marginStartAndEnd / 2, marginStartAndEnd / 2 };
 464             else {
 465                 if (isLeftToRightDirection) {
 466                     usedHorizontalMargin.start = 0_lu;
 467                     usedHorizontalMargin.end = containingBlockWidth - (*left + usedHorizontalMargin.start + borderLeft + paddingLeft + contentWidth() + paddingRight + borderRight + *right);
 468                 } else {
 469                     usedHorizontalMargin.end = 0_lu;
 470                     usedHorizontalMargin.start = containingBlockWidth - (*left + borderLeft + paddingLeft + contentWidth() + paddingRight + borderRight + usedHorizontalMargin.end + *right);
 471                 }
 472             }
 473         } else if (!computedHorizontalMargin.start) {
 474             usedHorizontalMargin.end = *computedHorizontalMargin.end;
 475             usedHorizontalMargin.start = containingBlockWidth - (*left + borderLeft + paddingLeft + contentWidth() + paddingRight + borderRight + usedHorizontalMargin.end + *right);







 476         } else if (!computedHorizontalMargin.end) {
 477             usedHorizontalMargin.start = *computedHorizontalMargin.start;
 478             usedHorizontalMargin.end = containingBlockWidth - (*left + usedHorizontalMargin.start + borderLeft + paddingLeft + contentWidth() + paddingRight + borderRight + *right);
<span class="line-modified"> 479         } else {</span>







 480             usedHorizontalMargin = { *computedHorizontalMargin.start, *computedHorizontalMargin.end };
<span class="line-added"> 481             // Overconstrained? Ignore right (left).</span>
<span class="line-added"> 482             if (isLeftToRightDirection)</span>
<span class="line-added"> 483                 right = containingBlockWidth - (usedHorizontalMargin.start + *left + borderLeft + paddingLeft + contentWidth() + paddingRight + borderRight + usedHorizontalMargin.end);</span>
<span class="line-added"> 484             else</span>
<span class="line-added"> 485                 left = containingBlockWidth - (usedHorizontalMargin.start + borderLeft + paddingLeft + contentWidth() + paddingRight + borderRight + usedHorizontalMargin.end + *right);</span>
<span class="line-added"> 486         }</span>
 487     } else {
 488         // Otherwise, set &#39;auto&#39; values for &#39;margin-left&#39; and &#39;margin-right&#39; to 0, and pick the one of the following six rules that applies.
 489         usedHorizontalMargin = { computedHorizontalMargin.start.valueOr(0), computedHorizontalMargin.end.valueOr(0) };
 490     }
 491 
 492     if (!left &amp;&amp; !width &amp;&amp; right) {
 493         // #1
<span class="line-modified"> 494         // Calculate the available width by solving for &#39;width&#39; after setting &#39;left&#39; (in case 1) to 0</span>
<span class="line-added"> 495         left = LayoutUnit { 0 };</span>
<span class="line-added"> 496         auto availableWidth = containingBlockWidth - (*left + usedHorizontalMargin.start + borderLeft + paddingLeft + paddingRight + borderRight + usedHorizontalMargin.end + *right);</span>
<span class="line-added"> 497         width = shrinkToFitWidth(layoutState, layoutBox, UsedHorizontalValues { availableWidth, usedValues.width, usedValues.margin });</span>
 498         left = containingBlockWidth - (usedHorizontalMargin.start + borderLeft + paddingLeft + *width + paddingRight  + borderRight + usedHorizontalMargin.end + *right);
 499     } else if (!left &amp;&amp; !right &amp;&amp; width) {
 500         // #2
 501         auto staticHorizontalPosition = staticHorizontalPositionForOutOfFlowPositioned(layoutState, layoutBox);
 502         if (isLeftToRightDirection) {
 503             left = staticHorizontalPosition;
 504             right = containingBlockWidth - (*left + usedHorizontalMargin.start + borderLeft + paddingLeft + contentWidth() + paddingRight + borderRight + usedHorizontalMargin.end);
 505         } else {
 506             right = staticHorizontalPosition;
 507             left = containingBlockWidth - (usedHorizontalMargin.start + borderLeft + paddingLeft + contentWidth() + paddingRight + borderRight + usedHorizontalMargin.end + *right);
 508         }
 509     } else if (!width &amp;&amp; !right &amp;&amp; left) {
 510         // #3
<span class="line-modified"> 511         // Calculate the available width by solving for &#39;width&#39; after setting &#39;right&#39; (in case 3) to 0</span>
<span class="line-added"> 512         right = LayoutUnit { 0 };</span>
<span class="line-added"> 513         auto availableWidth = containingBlockWidth - (*left + usedHorizontalMargin.start + borderLeft + paddingLeft + paddingRight + borderRight + usedHorizontalMargin.end + *right);</span>
<span class="line-added"> 514         width = shrinkToFitWidth(layoutState, layoutBox, UsedHorizontalValues { availableWidth, usedValues.width, usedValues.margin });</span>
 515         right = containingBlockWidth - (*left + usedHorizontalMargin.start + borderLeft + paddingLeft + *width + paddingRight + borderRight + usedHorizontalMargin.end);
 516     } else if (!left &amp;&amp; width &amp;&amp; right) {
 517         // #4
 518         left = containingBlockWidth - (usedHorizontalMargin.start + borderLeft + paddingLeft + contentWidth() + paddingRight + borderRight + usedHorizontalMargin.end + *right);
 519     } else if (!width &amp;&amp; left &amp;&amp; right) {
 520         // #5
 521         width = containingBlockWidth - (*left + usedHorizontalMargin.start + borderLeft + paddingLeft + paddingRight + borderRight + usedHorizontalMargin.end + *right);
 522     } else if (!right &amp;&amp; left &amp;&amp; width) {
 523         // #6
 524         right = containingBlockWidth - (*left + usedHorizontalMargin.start + borderLeft + paddingLeft + contentWidth() + paddingRight + borderRight + usedHorizontalMargin.end);
 525     }
 526 
 527     ASSERT(left);
 528     ASSERT(right);
 529     ASSERT(width);
 530 
 531     // For out-of-flow elements the containing block is formed by the padding edge of the ancestor.
<span class="line-modified"> 532     // At this point the positioned value is in the coordinate system of the padding box. Let&#39;s convert it to border box coordinate system.</span>
<span class="line-modified"> 533     auto containingBlockPaddingVerticalEdge = containingBlockDisplayBox.paddingBoxLeft();</span>
<span class="line-modified"> 534     *left += containingBlockPaddingVerticalEdge;</span>
<span class="line-modified"> 535     *right += containingBlockPaddingVerticalEdge;</span>


 536 
 537     LOG_WITH_STREAM(FormattingContextLayout, stream &lt;&lt; &quot;[Position][Width][Margin] -&gt; out-of-flow non-replaced -&gt; left(&quot; &lt;&lt; *left &lt;&lt; &quot;px) right(&quot;  &lt;&lt; *right &lt;&lt; &quot;px) width(&quot; &lt;&lt; *width &lt;&lt; &quot;px) margin(&quot; &lt;&lt; usedHorizontalMargin.start &lt;&lt; &quot;px, &quot;  &lt;&lt; usedHorizontalMargin.end &lt;&lt; &quot;px) layoutBox(&quot; &lt;&lt; &amp;layoutBox &lt;&lt; &quot;)&quot;);
 538     return { *left, *right, { contentWidth(), usedHorizontalMargin, computedHorizontalMargin } };
 539 }
 540 
 541 VerticalGeometry FormattingContext::Geometry::outOfFlowReplacedVerticalGeometry(const LayoutState&amp; layoutState, const Box&amp; layoutBox, UsedVerticalValues usedValues)
 542 {
 543     ASSERT(layoutBox.isOutOfFlowPositioned() &amp;&amp; layoutBox.replaced());
 544 
 545     // 10.6.5 Absolutely positioned, replaced elements
 546     //
 547     // The used value of &#39;height&#39; is determined as for inline replaced elements.
 548     // If &#39;margin-top&#39; or &#39;margin-bottom&#39; is specified as &#39;auto&#39; its used value is determined by the rules below.
 549     // 1. If both &#39;top&#39; and &#39;bottom&#39; have the value &#39;auto&#39;, replace &#39;top&#39; with the element&#39;s static position.
 550     // 2. If &#39;bottom&#39; is &#39;auto&#39;, replace any &#39;auto&#39; on &#39;margin-top&#39; or &#39;margin-bottom&#39; with &#39;0&#39;.
 551     // 3. If at this point both &#39;margin-top&#39; and &#39;margin-bottom&#39; are still &#39;auto&#39;, solve the equation under the extra constraint that the two margins must get equal values.
 552     // 4. If at this point there is only one &#39;auto&#39; left, solve the equation for that value.
 553     // 5. If at this point the values are over-constrained, ignore the value for &#39;bottom&#39; and solve for that value.
 554 
 555     auto&amp; style = layoutBox.style();
 556     auto&amp; displayBox = layoutState.displayBoxForLayoutBox(layoutBox);
 557     auto&amp; containingBlockDisplayBox = layoutState.displayBoxForLayoutBox(*layoutBox.containingBlock());
 558     auto containingBlockHeight = containingBlockDisplayBox.paddingBoxHeight();
 559     auto containingBlockWidth = containingBlockDisplayBox.paddingBoxWidth();
 560 
 561     auto top = computedValueIfNotAuto(style.logicalTop(), containingBlockWidth);
 562     auto bottom = computedValueIfNotAuto(style.logicalBottom(), containingBlockWidth);

 563     auto height = inlineReplacedHeightAndMargin(layoutState, layoutBox, usedValues).height;
 564     auto computedVerticalMargin = Geometry::computedVerticalMargin(layoutBox, UsedHorizontalValues { containingBlockWidth });
 565     Optional&lt;LayoutUnit&gt; usedMarginBefore = computedVerticalMargin.before;
 566     Optional&lt;LayoutUnit&gt; usedMarginAfter = computedVerticalMargin.after;
 567     auto paddingTop = displayBox.paddingTop().valueOr(0);
 568     auto paddingBottom = displayBox.paddingBottom().valueOr(0);
 569     auto borderTop = displayBox.borderTop();
 570     auto borderBottom = displayBox.borderBottom();
 571 
 572     if (!top &amp;&amp; !bottom) {
 573         // #1
 574         top = staticVerticalPositionForOutOfFlowPositioned(layoutState, layoutBox);
 575     }
 576 
 577     if (!bottom) {
 578         // #2
 579         usedMarginBefore = computedVerticalMargin.before.valueOr(0);
 580         usedMarginAfter = usedMarginBefore;
 581     }
 582 
</pre>
<hr />
<pre>
 589 
 590     // #4
 591     if (!top)
 592         top = containingBlockHeight - (*usedMarginBefore + borderTop + paddingTop + height + paddingBottom + borderBottom + *usedMarginAfter + *bottom);
 593 
 594     if (!bottom)
 595         bottom = containingBlockHeight - (*top + *usedMarginBefore + borderTop + paddingTop + height + paddingBottom + borderBottom + *usedMarginAfter);
 596 
 597     if (!usedMarginBefore)
 598         usedMarginBefore = containingBlockHeight - (*top + borderTop + paddingTop + height + paddingBottom + borderBottom + *usedMarginAfter + *bottom);
 599 
 600     if (!usedMarginAfter)
 601         usedMarginAfter = containingBlockHeight - (*top + *usedMarginBefore + borderTop + paddingTop + height + paddingBottom + borderBottom + *bottom);
 602 
 603     // #5
 604     auto boxHeight = *top + *usedMarginBefore + borderTop + paddingTop + height + paddingBottom + borderBottom + *usedMarginAfter + *bottom;
 605     if (boxHeight &gt; containingBlockHeight)
 606         bottom = containingBlockHeight - (*top + *usedMarginBefore + borderTop + paddingTop + height + paddingBottom + borderBottom + *usedMarginAfter);
 607 
 608     // For out-of-flow elements the containing block is formed by the padding edge of the ancestor.
<span class="line-modified"> 609     // At this point the positioned value is in the coordinate system of the padding box. Let&#39;s convert it to border box coordinate system.</span>
<span class="line-modified"> 610     auto containingBlockPaddingVerticalEdge = containingBlockDisplayBox.paddingBoxTop();</span>
<span class="line-modified"> 611     *top += containingBlockPaddingVerticalEdge;</span>
<span class="line-modified"> 612     *bottom += containingBlockPaddingVerticalEdge;</span>


 613 
 614     ASSERT(top);
 615     ASSERT(bottom);
 616     ASSERT(usedMarginBefore);
 617     ASSERT(usedMarginAfter);
 618     LOG_WITH_STREAM(FormattingContextLayout, stream &lt;&lt; &quot;[Position][Height][Margin] -&gt; out-of-flow replaced -&gt; top(&quot; &lt;&lt; *top &lt;&lt; &quot;px) bottom(&quot;  &lt;&lt; *bottom &lt;&lt; &quot;px) height(&quot; &lt;&lt; height &lt;&lt; &quot;px) margin(&quot; &lt;&lt; *usedMarginBefore &lt;&lt; &quot;px, &quot;  &lt;&lt; *usedMarginAfter &lt;&lt; &quot;px) layoutBox(&quot; &lt;&lt; &amp;layoutBox &lt;&lt; &quot;)&quot;);
 619     return { *top, *bottom, { height, { *usedMarginBefore, *usedMarginAfter } } };
 620 }
 621 
 622 HorizontalGeometry FormattingContext::Geometry::outOfFlowReplacedHorizontalGeometry(const LayoutState&amp; layoutState, const Box&amp; layoutBox, UsedHorizontalValues usedValues)
 623 {
 624     ASSERT(layoutBox.isOutOfFlowPositioned() &amp;&amp; layoutBox.replaced());
 625 
 626     // 10.3.8 Absolutely positioned, replaced elements
 627     // In this case, section 10.3.7 applies up through and including the constraint equation, but the rest of section 10.3.7 is replaced by the following rules:
 628     //
 629     // The used value of &#39;width&#39; is determined as for inline replaced elements. If &#39;margin-left&#39; or &#39;margin-right&#39; is specified as &#39;auto&#39; its used value is determined by the rules below.
 630     // 1. If both &#39;left&#39; and &#39;right&#39; have the value &#39;auto&#39;, then if the &#39;direction&#39; property of the element establishing the static-position containing block is &#39;ltr&#39;,
 631     //   set &#39;left&#39; to the static position; else if &#39;direction&#39; is &#39;rtl&#39;, set &#39;right&#39; to the static position.
 632     // 2. If &#39;left&#39; or &#39;right&#39; are &#39;auto&#39;, replace any &#39;auto&#39; on &#39;margin-left&#39; or &#39;margin-right&#39; with &#39;0&#39;.
 633     // 3. If at this point both &#39;margin-left&#39; and &#39;margin-right&#39; are still &#39;auto&#39;, solve the equation under the extra constraint that the two margins must get equal values,
 634     //   unless this would make them negative, in which case when the direction of the containing block is &#39;ltr&#39; (&#39;rtl&#39;), set &#39;margin-left&#39; (&#39;margin-right&#39;) to zero and
 635     //   solve for &#39;margin-right&#39; (&#39;margin-left&#39;).
 636     // 4. If at this point there is an &#39;auto&#39; left, solve the equation for that value.
 637     // 5. If at this point the values are over-constrained, ignore the value for either &#39;left&#39; (in case the &#39;direction&#39; property of the containing block is &#39;rtl&#39;) or
 638     //   &#39;right&#39; (in case &#39;direction&#39; is &#39;ltr&#39;) and solve for that value.
 639 
 640     auto&amp; style = layoutBox.style();
 641     auto&amp; displayBox = layoutState.displayBoxForLayoutBox(layoutBox);
 642     auto&amp; containingBlock = *layoutBox.containingBlock();
 643     auto containingBlockWidth = usedValues.containingBlockWidth.valueOr(0);
 644     auto isLeftToRightDirection = containingBlock.style().isLeftToRightDirection();
 645 
 646     auto left = computedValueIfNotAuto(style.logicalLeft(), containingBlockWidth);
 647     auto right = computedValueIfNotAuto(style.logicalRight(), containingBlockWidth);

 648     auto computedHorizontalMargin = Geometry::computedHorizontalMargin(layoutBox, usedValues);
 649     Optional&lt;LayoutUnit&gt; usedMarginStart = computedHorizontalMargin.start;
 650     Optional&lt;LayoutUnit&gt; usedMarginEnd = computedHorizontalMargin.end;
 651     auto width = inlineReplacedWidthAndMargin(layoutState, layoutBox, usedValues).width;
 652     auto paddingLeft = displayBox.paddingLeft().valueOr(0);
 653     auto paddingRight = displayBox.paddingRight().valueOr(0);
 654     auto borderLeft = displayBox.borderLeft();
 655     auto borderRight = displayBox.borderRight();
 656 
 657     if (!left &amp;&amp; !right) {
 658         // #1
 659         auto staticHorizontalPosition = staticHorizontalPositionForOutOfFlowPositioned(layoutState, layoutBox);
 660         if (isLeftToRightDirection)
 661             left = staticHorizontalPosition;
 662         else
 663             right = staticHorizontalPosition;
 664     }
 665 
 666     if (!left || !right) {
 667         // #2
</pre>
<hr />
<pre>
 697         usedMarginStart = containingBlockWidth - (*left + borderLeft + paddingLeft + width + paddingRight + borderRight + *usedMarginEnd + *right);
 698 
 699     if (!usedMarginEnd)
 700         usedMarginEnd = containingBlockWidth - (*left + *usedMarginStart + borderLeft + paddingLeft + width + paddingRight + borderRight + *right);
 701 
 702     auto boxWidth = (*left + *usedMarginStart + borderLeft + paddingLeft + width + paddingRight + borderRight + *usedMarginEnd + *right);
 703     if (boxWidth &gt; containingBlockWidth) {
 704         // #5 Over-constrained?
 705         if (isLeftToRightDirection)
 706             right = containingBlockWidth - (*left + *usedMarginStart + borderLeft + paddingLeft + width + paddingRight + borderRight + *usedMarginEnd);
 707         else
 708             left = containingBlockWidth - (*usedMarginStart + borderLeft + paddingLeft + width + paddingRight + borderRight + *usedMarginEnd + *right);
 709     }
 710 
 711     ASSERT(left);
 712     ASSERT(right);
 713     ASSERT(usedMarginStart);
 714     ASSERT(usedMarginEnd);
 715 
 716     // For out-of-flow elements the containing block is formed by the padding edge of the ancestor.
<span class="line-modified"> 717     // At this point the positioned value is in the coordinate system of the padding box. Let&#39;s convert it to border box coordinate system.</span>
<span class="line-modified"> 718     auto containingBlockPaddingVerticalEdge = layoutState.displayBoxForLayoutBox(containingBlock).paddingBoxLeft();</span>
<span class="line-modified"> 719     *left += containingBlockPaddingVerticalEdge;</span>
<span class="line-modified"> 720     *right += containingBlockPaddingVerticalEdge;</span>


 721 
 722     LOG_WITH_STREAM(FormattingContextLayout, stream &lt;&lt; &quot;[Position][Width][Margin] -&gt; out-of-flow replaced -&gt; left(&quot; &lt;&lt; *left &lt;&lt; &quot;px) right(&quot;  &lt;&lt; *right &lt;&lt; &quot;px) width(&quot; &lt;&lt; width &lt;&lt; &quot;px) margin(&quot; &lt;&lt; *usedMarginStart &lt;&lt; &quot;px, &quot;  &lt;&lt; *usedMarginEnd &lt;&lt; &quot;px) layoutBox(&quot; &lt;&lt; &amp;layoutBox &lt;&lt; &quot;)&quot;);
 723     return { *left, *right, { width, { *usedMarginStart, *usedMarginEnd }, computedHorizontalMargin } };
 724 }
 725 
 726 HeightAndMargin FormattingContext::Geometry::complicatedCases(const LayoutState&amp; layoutState, const Box&amp; layoutBox, UsedVerticalValues usedValues, UsedHorizontalValues usedHorizontalValues)
 727 {
 728     ASSERT(!layoutBox.replaced());
 729     // TODO: Use complicated-case for document renderer for now (see BlockFormattingContext::Geometry::inFlowHeightAndMargin).
 730     ASSERT((layoutBox.isBlockLevelBox() &amp;&amp; layoutBox.isInFlow() &amp;&amp; !layoutBox.isOverflowVisible()) || layoutBox.isInlineBlockBox() || layoutBox.isFloatingPositioned() || layoutBox.isDocumentBox());
 731 
 732     // 10.6.6 Complicated cases
 733     //
 734     // Block-level, non-replaced elements in normal flow when &#39;overflow&#39; does not compute to &#39;visible&#39; (except if the &#39;overflow&#39; property&#39;s value has been propagated to the viewport).
 735     // &#39;Inline-block&#39;, non-replaced elements.
 736     // Floating, non-replaced elements.
 737     //
 738     // 1. If &#39;margin-top&#39;, or &#39;margin-bottom&#39; are &#39;auto&#39;, their used value is 0.
 739     // 2. If &#39;height&#39; is &#39;auto&#39;, the height depends on the element&#39;s descendants per 10.6.7.
 740 
</pre>
<hr />
<pre>
1018             right = -*left;
1019         else
1020             left = WTF::nullopt;
1021     }
1022 
1023     ASSERT(!bottom || *top == -*bottom);
1024     ASSERT(!left || *left == -*right);
1025 
1026     auto topPositionOffset = *top;
1027     auto leftPositionOffset = left.valueOr(-*right);
1028 
1029     LOG_WITH_STREAM(FormattingContextLayout, stream &lt;&lt; &quot;[Position] -&gt; positioned inflow -&gt; top offset(&quot; &lt;&lt; topPositionOffset &lt;&lt; &quot;px) left offset(&quot; &lt;&lt; leftPositionOffset &lt;&lt; &quot;px) layoutBox(&quot; &lt;&lt; &amp;layoutBox &lt;&lt; &quot;)&quot;);
1030     return { leftPositionOffset, topPositionOffset };
1031 }
1032 
1033 Edges FormattingContext::Geometry::computedBorder(const Box&amp; layoutBox)
1034 {
1035     auto&amp; style = layoutBox.style();
1036     LOG_WITH_STREAM(FormattingContextLayout, stream &lt;&lt; &quot;[Border] -&gt; layoutBox: &quot; &lt;&lt; &amp;layoutBox);
1037     return {
<span class="line-modified">1038         { LayoutUnit(style.borderLeft().boxModelWidth()), LayoutUnit(style.borderRight().boxModelWidth()) },</span>
<span class="line-modified">1039         { LayoutUnit(style.borderTop().boxModelWidth()), LayoutUnit(style.borderBottom().boxModelWidth()) }</span>
1040     };
1041 }
1042 
1043 Optional&lt;Edges&gt; FormattingContext::Geometry::computedPadding(const Box&amp; layoutBox, UsedHorizontalValues usedValues)
1044 {
1045     if (!layoutBox.isPaddingApplicable())
1046         return WTF::nullopt;
1047 
1048     auto&amp; style = layoutBox.style();
1049     auto containingBlockWidth = usedValues.containingBlockWidth.valueOr(0);
1050     LOG_WITH_STREAM(FormattingContextLayout, stream &lt;&lt; &quot;[Padding] -&gt; layoutBox: &quot; &lt;&lt; &amp;layoutBox);
1051     return Edges {
1052         { valueForLength(style.paddingLeft(), containingBlockWidth), valueForLength(style.paddingRight(), containingBlockWidth) },
1053         { valueForLength(style.paddingTop(), containingBlockWidth), valueForLength(style.paddingBottom(), containingBlockWidth) }
1054     };
1055 }
1056 
1057 ComputedHorizontalMargin FormattingContext::Geometry::computedHorizontalMargin(const Box&amp; layoutBox, UsedHorizontalValues usedValues)
1058 {
1059     auto&amp; style = layoutBox.style();
</pre>
</td>
</tr>
</table>
<center><a href="FormattingContext.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="FormattingContextQuirks.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>