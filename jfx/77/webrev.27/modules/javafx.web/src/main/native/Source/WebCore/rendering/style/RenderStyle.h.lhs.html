<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/rendering/style/RenderStyle.h</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (C) 2000 Lars Knoll (knoll@kde.org)
   3  *           (C) 2000 Antti Koivisto (koivisto@kde.org)
   4  *           (C) 2000 Dirk Mueller (mueller@kde.org)
   5  * Copyright (C) 2003-2017 Apple Inc. All rights reserved.
   6  * Copyright (C) 2006 Graham Dennis (graham.dennis@gmail.com)
   7  *
   8  * This library is free software; you can redistribute it and/or
   9  * modify it under the terms of the GNU Library General Public
  10  * License as published by the Free Software Foundation; either
  11  * version 2 of the License, or (at your option) any later version.
  12  *
  13  * This library is distributed in the hope that it will be useful,
  14  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  15  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  16  * Library General Public License for more details.
  17  *
  18  * You should have received a copy of the GNU Library General Public License
  19  * along with this library; see the file COPYING.LIB.  If not, write to
  20  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  21  * Boston, MA 02110-1301, USA.
  22  *
  23  */
  24 
  25 #pragma once
  26 
  27 #include &quot;AnimationList.h&quot;
  28 #include &quot;BorderValue.h&quot;
  29 #include &quot;CSSLineBoxContainValue.h&quot;
  30 #include &quot;CSSPrimitiveValue.h&quot;
  31 #include &quot;CSSPropertyNames.h&quot;
  32 #include &quot;Color.h&quot;
  33 #include &quot;CounterDirectives.h&quot;
  34 #include &quot;DataRef.h&quot;
  35 #include &quot;FilterOperations.h&quot;
  36 #include &quot;FontCascadeDescription.h&quot;
  37 #include &quot;GapLength.h&quot;
  38 #include &quot;GraphicsTypes.h&quot;
  39 #include &quot;Length.h&quot;
  40 #include &quot;LengthBox.h&quot;
  41 #include &quot;LengthFunctions.h&quot;
  42 #include &quot;LengthPoint.h&quot;
  43 #include &quot;LengthSize.h&quot;
  44 #include &quot;LineClampValue.h&quot;
  45 #include &quot;NinePieceImage.h&quot;
  46 #include &quot;Pagination.h&quot;
  47 #include &quot;RenderStyleConstants.h&quot;
  48 #include &quot;RoundedRect.h&quot;
  49 #include &quot;SVGRenderStyle.h&quot;
  50 #include &quot;ShadowData.h&quot;
  51 #include &quot;ShapeValue.h&quot;
  52 #include &quot;StyleBackgroundData.h&quot;
  53 #include &quot;StyleBoxData.h&quot;
  54 #include &quot;StyleDeprecatedFlexibleBoxData.h&quot;
  55 #include &quot;StyleFilterData.h&quot;
  56 #include &quot;StyleFlexibleBoxData.h&quot;
  57 #include &quot;StyleMarqueeData.h&quot;
  58 #include &quot;StyleMultiColData.h&quot;
  59 #include &quot;StyleRareInheritedData.h&quot;
  60 #include &quot;StyleRareNonInheritedData.h&quot;
  61 #include &quot;StyleReflection.h&quot;
  62 #include &quot;StyleSurroundData.h&quot;
  63 #include &quot;StyleTransformData.h&quot;
  64 #include &quot;StyleVisualData.h&quot;
  65 #include &quot;TextFlags.h&quot;
  66 #include &quot;ThemeTypes.h&quot;
  67 #include &quot;TouchAction.h&quot;
  68 #include &quot;TransformOperations.h&quot;
  69 #include &quot;UnicodeBidi.h&quot;
  70 #include &lt;memory&gt;
  71 #include &lt;wtf/Forward.h&gt;
  72 #include &lt;wtf/NeverDestroyed.h&gt;
  73 #include &lt;wtf/OptionSet.h&gt;
  74 #include &lt;wtf/StdLibExtras.h&gt;
  75 #include &lt;wtf/Vector.h&gt;
  76 
  77 #include &quot;StyleGridData.h&quot;
  78 #include &quot;StyleGridItemData.h&quot;
  79 
<a name="1" id="anc1"></a><span class="line-removed">  80 #if ENABLE(DASHBOARD_SUPPORT)</span>
<span class="line-removed">  81 #include &quot;StyleDashboardRegion.h&quot;</span>
<span class="line-removed">  82 #endif</span>
<span class="line-removed">  83 </span>
  84 #if ENABLE(TEXT_AUTOSIZING)
  85 #include &quot;TextSizeAdjustment.h&quot;
  86 #endif
  87 
  88 #if ENABLE(DARK_MODE_CSS)
<a name="2" id="anc2"></a><span class="line-modified">  89 #include &quot;StyleSupportedColorSchemes.h&quot;</span>
  90 #endif
  91 
  92 #define SET_VAR(group, variable, value) do { \
  93         if (!compareEqual(group-&gt;variable, value)) \
  94             group.access().variable = value; \
  95     } while (0)
  96 
  97 #define SET_NESTED_VAR(group, parentVariable, variable, value) do { \
  98         if (!compareEqual(group-&gt;parentVariable-&gt;variable, value)) \
  99             group.access().parentVariable.access().variable = value; \
 100     } while (0)
 101 
 102 #define SET_BORDERVALUE_COLOR(group, variable, value) do { \
 103         if (!compareEqual(group-&gt;variable.color(), value)) \
 104             group.access().variable.setColor(value); \
 105     } while (0)
 106 
 107 namespace WebCore {
 108 
 109 class BorderData;
 110 class ContentData;
 111 class CounterContent;
 112 class CursorList;
 113 class FontCascade;
 114 class FontMetrics;
 115 class IntRect;
 116 class Pair;
 117 class ShadowData;
 118 class StyleImage;
 119 class StyleInheritedData;
 120 class StyleResolver;
 121 class StyleScrollSnapArea;
 122 class StyleScrollSnapPort;
 123 class TransformationMatrix;
 124 
 125 struct ScrollSnapAlign;
 126 struct ScrollSnapType;
 127 
 128 using PseudoStyleCache = Vector&lt;std::unique_ptr&lt;RenderStyle&gt;, 4&gt;;
 129 
 130 template&lt;typename T, typename U&gt; inline bool compareEqual(const T&amp; t, const U&amp; u) { return t == static_cast&lt;const T&amp;&gt;(u); }
 131 
 132 class RenderStyle {
 133     WTF_MAKE_FAST_ALLOCATED;
 134 
 135 private:
 136     enum CloneTag { Clone };
 137     enum CreateDefaultStyleTag { CreateDefaultStyle };
 138 
 139 public:
 140     RenderStyle(RenderStyle&amp;&amp;);
 141     RenderStyle&amp; operator=(RenderStyle&amp;&amp;);
 142     ~RenderStyle();
 143 
 144     RenderStyle replace(RenderStyle&amp;&amp;) WARN_UNUSED_RETURN;
 145 
 146     explicit RenderStyle(CreateDefaultStyleTag);
 147     RenderStyle(const RenderStyle&amp;, CloneTag);
 148 
 149     static RenderStyle&amp; defaultStyle();
 150 
 151     static RenderStyle create();
 152     static std::unique_ptr&lt;RenderStyle&gt; createPtr();
 153 
 154     static RenderStyle clone(const RenderStyle&amp;);
 155     static std::unique_ptr&lt;RenderStyle&gt; clonePtr(const RenderStyle&amp;);
 156 
 157     static RenderStyle createAnonymousStyleWithDisplay(const RenderStyle&amp; parentStyle, DisplayType);
 158     static RenderStyle createStyleInheritingFromPseudoStyle(const RenderStyle&amp; pseudoStyle);
 159 
 160 #if !ASSERT_DISABLED || ENABLE(SECURITY_ASSERTIONS)
 161     bool deletionHasBegun() const { return m_deletionHasBegun; }
 162 #endif
 163 
 164     bool operator==(const RenderStyle&amp;) const;
 165     bool operator!=(const RenderStyle&amp; other) const { return !(*this == other); }
 166 
 167     void inheritFrom(const RenderStyle&amp; inheritParent);
 168     void copyNonInheritedFrom(const RenderStyle&amp;);
 169     void copyContentFrom(const RenderStyle&amp;);
 170 
 171     ContentPosition resolvedJustifyContentPosition(const StyleContentAlignmentData&amp; normalValueBehavior) const;
 172     ContentDistribution resolvedJustifyContentDistribution(const StyleContentAlignmentData&amp; normalValueBehavior) const;
 173     ContentPosition resolvedAlignContentPosition(const StyleContentAlignmentData&amp; normalValueBehavior) const;
 174     ContentDistribution resolvedAlignContentDistribution(const StyleContentAlignmentData&amp; normalValueBehavior) const;
 175     StyleSelfAlignmentData resolvedAlignItems(ItemPosition normalValueBehaviour) const;
 176     StyleSelfAlignmentData resolvedAlignSelf(const RenderStyle* parentStyle, ItemPosition normalValueBehaviour) const;
 177     StyleContentAlignmentData resolvedAlignContent(const StyleContentAlignmentData&amp; normalValueBehaviour) const;
 178     StyleSelfAlignmentData resolvedJustifyItems(ItemPosition normalValueBehaviour) const;
 179     StyleSelfAlignmentData resolvedJustifySelf(const RenderStyle* parentStyle, ItemPosition normalValueBehaviour) const;
 180     StyleContentAlignmentData resolvedJustifyContent(const StyleContentAlignmentData&amp; normalValueBehaviour) const;
 181 
 182     PseudoId styleType() const { return static_cast&lt;PseudoId&gt;(m_nonInheritedFlags.styleType); }
 183     void setStyleType(PseudoId styleType) { m_nonInheritedFlags.styleType = static_cast&lt;unsigned&gt;(styleType); }
 184 
 185     RenderStyle* getCachedPseudoStyle(PseudoId) const;
 186     RenderStyle* addCachedPseudoStyle(std::unique_ptr&lt;RenderStyle&gt;);
 187     void removeCachedPseudoStyle(PseudoId);
 188 
 189     const PseudoStyleCache* cachedPseudoStyles() const { return m_cachedPseudoStyles.get(); }
 190 
 191     const CustomPropertyValueMap&amp; inheritedCustomProperties() const { return m_rareInheritedData-&gt;customProperties-&gt;values; }
 192     const CustomPropertyValueMap&amp; nonInheritedCustomProperties() const { return m_rareNonInheritedData-&gt;customProperties-&gt;values; }
<a name="3" id="anc3"></a><span class="line-modified"> 193     const CSSCustomPropertyValue* getCustomProperty(const AtomicString&amp;) const;</span>
<span class="line-modified"> 194     void setInheritedCustomPropertyValue(const AtomicString&amp; name, Ref&lt;CSSCustomPropertyValue&gt;&amp;&amp; value) { return m_rareInheritedData.access().customProperties.access().setCustomPropertyValue(name, WTFMove(value)); }</span>
<span class="line-modified"> 195     void setNonInheritedCustomPropertyValue(const AtomicString&amp; name, Ref&lt;CSSCustomPropertyValue&gt;&amp;&amp; value) { return m_rareNonInheritedData.access().customProperties.access().setCustomPropertyValue(name, WTFMove(value)); }</span>
 196 
 197     void setHasViewportUnits(bool v = true) { m_nonInheritedFlags.hasViewportUnits = v; }
 198     bool hasViewportUnits() const { return m_nonInheritedFlags.hasViewportUnits; }
 199 
 200     bool affectedByHover() const { return m_nonInheritedFlags.affectedByHover; }
 201     bool affectedByActive() const { return m_nonInheritedFlags.affectedByActive; }
 202     bool affectedByDrag() const { return m_nonInheritedFlags.affectedByDrag; }
 203 
 204     void setAffectedByHover() { m_nonInheritedFlags.affectedByHover = true; }
 205     void setAffectedByActive() { m_nonInheritedFlags.affectedByActive = true; }
 206     void setAffectedByDrag() { m_nonInheritedFlags.affectedByDrag = true; }
 207 
 208     void setColumnStylesFromPaginationMode(const Pagination::Mode&amp;);
 209 
 210     bool isFloating() const { return static_cast&lt;Float&gt;(m_nonInheritedFlags.floating) != Float::No; }
 211     bool hasMargin() const { return !m_surroundData-&gt;margin.isZero(); }
 212     bool hasBorder() const { return m_surroundData-&gt;border.hasBorder(); }
 213     bool hasBorderFill() const { return m_surroundData-&gt;border.hasFill(); }
 214     bool hasVisibleBorderDecoration() const { return hasVisibleBorder() || hasBorderFill(); }
 215     bool hasVisibleBorder() const { return m_surroundData-&gt;border.hasVisibleBorder(); }
 216     bool hasPadding() const { return !m_surroundData-&gt;padding.isZero(); }
 217     bool hasOffset() const { return !m_surroundData-&gt;offset.isZero(); }
 218     bool hasMarginBeforeQuirk() const { return marginBefore().hasQuirk(); }
 219     bool hasMarginAfterQuirk() const { return marginAfter().hasQuirk(); }
 220 
 221     bool hasBackgroundImage() const { return m_backgroundData-&gt;background.hasImage(); }
 222     bool hasFixedBackgroundImage() const { return m_backgroundData-&gt;background.hasFixedImage(); }
 223 
 224     bool hasEntirelyFixedBackground() const;
 225 
 226     bool hasAppearance() const { return appearance() != NoControlPart; }
 227 
 228     bool hasBackground() const;
 229 
 230     LayoutBoxExtent imageOutsets(const NinePieceImage&amp;) const;
 231     bool hasBorderImageOutsets() const { return borderImage().hasImage() &amp;&amp; !borderImage().outset().isZero(); }
 232     LayoutBoxExtent borderImageOutsets() const { return imageOutsets(borderImage()); }
 233 
 234     LayoutBoxExtent maskBoxImageOutsets() const { return imageOutsets(maskBoxImage()); }
 235 
 236     bool hasFilterOutsets() const { return hasFilter() &amp;&amp; filter().hasOutsets(); }
 237     FilterOutsets filterOutsets() const { return hasFilter() ? filter().outsets() : FilterOutsets(); }
 238 
 239     Order rtlOrdering() const { return static_cast&lt;Order&gt;(m_inheritedFlags.rtlOrdering); }
 240     void setRTLOrdering(Order ordering) { m_inheritedFlags.rtlOrdering = static_cast&lt;unsigned&gt;(ordering); }
 241 
 242     bool isStyleAvailable() const;
 243 
 244     bool hasAnyPublicPseudoStyles() const;
 245     bool hasPseudoStyle(PseudoId) const;
 246     void setHasPseudoStyle(PseudoId);
 247     void setHasPseudoStyles(PseudoIdSet);
 248     bool hasUniquePseudoStyle() const;
 249 
 250     // attribute getter methods
 251 
 252     DisplayType display() const { return static_cast&lt;DisplayType&gt;(m_nonInheritedFlags.effectiveDisplay); }
 253 
 254     const Length&amp; left() const { return m_surroundData-&gt;offset.left(); }
 255     const Length&amp; right() const { return m_surroundData-&gt;offset.right(); }
 256     const Length&amp; top() const { return m_surroundData-&gt;offset.top(); }
 257     const Length&amp; bottom() const { return m_surroundData-&gt;offset.bottom(); }
 258 
 259     // Accessors for positioned object edges that take into account writing mode.
 260     const Length&amp; logicalLeft() const { return m_surroundData-&gt;offset.start(writingMode()); }
 261     const Length&amp; logicalRight() const { return m_surroundData-&gt;offset.end(writingMode()); }
 262     const Length&amp; logicalTop() const { return m_surroundData-&gt;offset.before(writingMode()); }
 263     const Length&amp; logicalBottom() const { return m_surroundData-&gt;offset.after(writingMode()); }
 264 
 265     // Whether or not a positioned element requires normal flow x/y to be computed  to determine its position.
 266     bool hasStaticInlinePosition(bool horizontal) const { return horizontal ? hasAutoLeftAndRight() : hasAutoTopAndBottom(); }
 267     bool hasStaticBlockPosition(bool horizontal) const { return horizontal ? hasAutoTopAndBottom() : hasAutoLeftAndRight(); }
 268 
 269     PositionType position() const { return static_cast&lt;PositionType&gt;(m_nonInheritedFlags.position); }
 270     bool hasOutOfFlowPosition() const { return position() == PositionType::Absolute || position() == PositionType::Fixed; }
 271     bool hasInFlowPosition() const { return position() == PositionType::Relative || position() == PositionType::Sticky; }
 272     bool hasViewportConstrainedPosition() const { return position() == PositionType::Fixed || position() == PositionType::Sticky; }
 273     Float floating() const { return static_cast&lt;Float&gt;(m_nonInheritedFlags.floating); }
 274 
 275     const Length&amp; width() const { return m_boxData-&gt;width(); }
 276     const Length&amp; height() const { return m_boxData-&gt;height(); }
 277     const Length&amp; minWidth() const { return m_boxData-&gt;minWidth(); }
 278     const Length&amp; maxWidth() const { return m_boxData-&gt;maxWidth(); }
 279     const Length&amp; minHeight() const { return m_boxData-&gt;minHeight(); }
 280     const Length&amp; maxHeight() const { return m_boxData-&gt;maxHeight(); }
 281 
 282     const Length&amp; logicalWidth() const { return isHorizontalWritingMode() ? width() : height(); }
 283     const Length&amp; logicalHeight() const { return isHorizontalWritingMode() ? height() : width(); }
 284     const Length&amp; logicalMinWidth() const { return isHorizontalWritingMode() ? minWidth() : minHeight(); }
 285     const Length&amp; logicalMaxWidth() const { return isHorizontalWritingMode() ? maxWidth() : maxHeight(); }
 286     const Length&amp; logicalMinHeight() const { return isHorizontalWritingMode() ? minHeight() : minWidth(); }
 287     const Length&amp; logicalMaxHeight() const { return isHorizontalWritingMode() ? maxHeight() : maxWidth(); }
 288 
 289     const BorderData&amp; border() const { return m_surroundData-&gt;border; }
 290     const BorderValue&amp; borderLeft() const { return m_surroundData-&gt;border.left(); }
 291     const BorderValue&amp; borderRight() const { return m_surroundData-&gt;border.right(); }
 292     const BorderValue&amp; borderTop() const { return m_surroundData-&gt;border.top(); }
 293     const BorderValue&amp; borderBottom() const { return m_surroundData-&gt;border.bottom(); }
 294 
 295     const BorderValue&amp; borderBefore() const;
 296     const BorderValue&amp; borderAfter() const;
 297     const BorderValue&amp; borderStart() const;
 298     const BorderValue&amp; borderEnd() const;
 299 
 300     const NinePieceImage&amp; borderImage() const { return m_surroundData-&gt;border.image(); }
 301     StyleImage* borderImageSource() const { return m_surroundData-&gt;border.image().image(); }
 302     const LengthBox&amp; borderImageSlices() const { return m_surroundData-&gt;border.image().imageSlices(); }
 303     const LengthBox&amp; borderImageWidth() const { return m_surroundData-&gt;border.image().borderSlices(); }
 304     const LengthBox&amp; borderImageOutset() const { return m_surroundData-&gt;border.image().outset(); }
 305 
 306     const LengthSize&amp; borderTopLeftRadius() const { return m_surroundData-&gt;border.topLeft(); }
 307     const LengthSize&amp; borderTopRightRadius() const { return m_surroundData-&gt;border.topRight(); }
 308     const LengthSize&amp; borderBottomLeftRadius() const { return m_surroundData-&gt;border.bottomLeft(); }
 309     const LengthSize&amp; borderBottomRightRadius() const { return m_surroundData-&gt;border.bottomRight(); }
 310     bool hasBorderRadius() const { return m_surroundData-&gt;border.hasBorderRadius(); }
 311 
 312     float borderLeftWidth() const { return m_surroundData-&gt;border.borderLeftWidth(); }
 313     BorderStyle borderLeftStyle() const { return m_surroundData-&gt;border.left().style(); }
 314     bool borderLeftIsTransparent() const { return m_surroundData-&gt;border.left().isTransparent(); }
 315     float borderRightWidth() const { return m_surroundData-&gt;border.borderRightWidth(); }
 316     BorderStyle borderRightStyle() const { return m_surroundData-&gt;border.right().style(); }
 317     bool borderRightIsTransparent() const { return m_surroundData-&gt;border.right().isTransparent(); }
 318     float borderTopWidth() const { return m_surroundData-&gt;border.borderTopWidth(); }
 319     BorderStyle borderTopStyle() const { return m_surroundData-&gt;border.top().style(); }
 320     bool borderTopIsTransparent() const { return m_surroundData-&gt;border.top().isTransparent(); }
 321     float borderBottomWidth() const { return m_surroundData-&gt;border.borderBottomWidth(); }
 322     BorderStyle borderBottomStyle() const { return m_surroundData-&gt;border.bottom().style(); }
 323     bool borderBottomIsTransparent() const { return m_surroundData-&gt;border.bottom().isTransparent(); }
 324     FloatBoxExtent borderWidth() const { return m_surroundData-&gt;border.borderWidth(); }
 325 
 326     float borderBeforeWidth() const;
 327     float borderAfterWidth() const;
 328     float borderStartWidth() const;
 329     float borderEndWidth() const;
 330 
 331     float outlineSize() const { return std::max&lt;float&gt;(0, outlineWidth() + outlineOffset()); }
 332     float outlineWidth() const;
 333     bool hasOutline() const { return outlineStyle() &gt; BorderStyle::Hidden &amp;&amp; outlineWidth() &gt; 0; }
 334     BorderStyle outlineStyle() const { return m_backgroundData-&gt;outline.style(); }
 335     OutlineIsAuto outlineStyleIsAuto() const { return static_cast&lt;OutlineIsAuto&gt;(m_backgroundData-&gt;outline.isAuto()); }
 336     bool hasOutlineInVisualOverflow() const { return hasOutline() &amp;&amp; outlineSize() &gt; 0; }
 337 
 338     Overflow overflowX() const { return static_cast&lt;Overflow&gt;(m_nonInheritedFlags.overflowX); }
 339     Overflow overflowY() const { return static_cast&lt;Overflow&gt;(m_nonInheritedFlags.overflowY); }
 340     Overflow overflowInlineDirection() const { return isHorizontalWritingMode() ? overflowX() : overflowY(); }
 341     Overflow overflowBlockDirection() const { return isHorizontalWritingMode() ? overflowY() : overflowX(); }
 342     bool isOverflowVisible() const { return overflowX() == Overflow::Visible || overflowY() == Overflow::Visible; }
 343 
 344     Visibility visibility() const { return static_cast&lt;Visibility&gt;(m_inheritedFlags.visibility); }
 345     VerticalAlign verticalAlign() const { return static_cast&lt;VerticalAlign&gt;(m_nonInheritedFlags.verticalAlign); }
 346     const Length&amp; verticalAlignLength() const { return m_boxData-&gt;verticalAlign(); }
 347 
 348     const Length&amp; clipLeft() const { return m_visualData-&gt;clip.left(); }
 349     const Length&amp; clipRight() const { return m_visualData-&gt;clip.right(); }
 350     const Length&amp; clipTop() const { return m_visualData-&gt;clip.top(); }
 351     const Length&amp; clipBottom() const { return m_visualData-&gt;clip.bottom(); }
 352     const LengthBox&amp; clip() const { return m_visualData-&gt;clip; }
 353     bool hasClip() const { return m_visualData-&gt;hasClip; }
 354 
 355     EUnicodeBidi unicodeBidi() const { return static_cast&lt;EUnicodeBidi&gt;(m_nonInheritedFlags.unicodeBidi); }
 356 
 357     Clear clear() const { return static_cast&lt;Clear&gt;(m_nonInheritedFlags.clear); }
 358     TableLayoutType tableLayout() const { return static_cast&lt;TableLayoutType&gt;(m_nonInheritedFlags.tableLayout); }
 359 
 360     WEBCORE_EXPORT const FontCascade&amp; fontCascade() const;
 361     WEBCORE_EXPORT const FontMetrics&amp; fontMetrics() const;
 362     WEBCORE_EXPORT const FontCascadeDescription&amp; fontDescription() const;
 363     float specifiedFontSize() const;
 364     float computedFontSize() const;
 365     unsigned computedFontPixelSize() const;
 366     std::pair&lt;FontOrientation, NonCJKGlyphOrientation&gt; fontAndGlyphOrientation();
 367 
 368 #if ENABLE(VARIATION_FONTS)
 369     FontVariationSettings fontVariationSettings() const { return fontDescription().variationSettings(); }
 370 #endif
 371     FontSelectionValue fontWeight() const { return fontDescription().weight(); }
 372     FontSelectionValue fontStretch() const { return fontDescription().stretch(); }
 373     Optional&lt;FontSelectionValue&gt; fontItalic() const { return fontDescription().italic(); }
 374 
 375     const Length&amp; textIndent() const { return m_rareInheritedData-&gt;indent; }
 376     TextAlignMode textAlign() const { return static_cast&lt;TextAlignMode&gt;(m_inheritedFlags.textAlign); }
 377     TextTransform textTransform() const { return static_cast&lt;TextTransform&gt;(m_inheritedFlags.textTransform); }
 378     OptionSet&lt;TextDecoration&gt; textDecorationsInEffect() const { return OptionSet&lt;TextDecoration&gt;::fromRaw(m_inheritedFlags.textDecorations); }
 379     OptionSet&lt;TextDecoration&gt; textDecoration() const { return OptionSet&lt;TextDecoration&gt;::fromRaw(m_visualData-&gt;textDecoration); }
 380     TextDecorationStyle textDecorationStyle() const { return static_cast&lt;TextDecorationStyle&gt;(m_rareNonInheritedData-&gt;textDecorationStyle); }
 381     OptionSet&lt;TextDecorationSkip&gt; textDecorationSkip() const { return OptionSet&lt;TextDecorationSkip&gt;::fromRaw(m_rareInheritedData-&gt;textDecorationSkip); }
 382     TextUnderlinePosition textUnderlinePosition() const { return static_cast&lt;TextUnderlinePosition&gt;(m_rareInheritedData-&gt;textUnderlinePosition); }
 383     TextUnderlineOffset textUnderlineOffset() const { return m_rareInheritedData-&gt;textUnderlineOffset; }
 384     TextDecorationThickness textDecorationThickness() const { return m_rareInheritedData-&gt;textDecorationThickness; }
 385 
 386 #if ENABLE(CSS3_TEXT)
 387     TextIndentLine textIndentLine() const { return static_cast&lt;TextIndentLine&gt;(m_rareInheritedData-&gt;textIndentLine); }
 388     TextIndentType textIndentType() const { return static_cast&lt;TextIndentType&gt;(m_rareInheritedData-&gt;textIndentType); }
 389     TextAlignLast textAlignLast() const { return static_cast&lt;TextAlignLast&gt;(m_rareInheritedData-&gt;textAlignLast); }
 390     TextJustify textJustify() const { return static_cast&lt;TextJustify&gt;(m_rareInheritedData-&gt;textJustify); }
 391 #endif
 392 
 393     const Length&amp; wordSpacing() const;
 394     float letterSpacing() const;
 395 
 396     float zoom() const { return m_visualData-&gt;zoom; }
 397     float effectiveZoom() const { return m_rareInheritedData-&gt;effectiveZoom; }
 398 
 399     TextZoom textZoom() const { return static_cast&lt;TextZoom&gt;(m_rareInheritedData-&gt;textZoom); }
 400 
 401     TextDirection direction() const { return static_cast&lt;TextDirection&gt;(m_inheritedFlags.direction); }
 402     bool isLeftToRightDirection() const { return direction() == TextDirection::LTR; }
 403     bool hasExplicitlySetDirection() const { return m_nonInheritedFlags.hasExplicitlySetDirection; }
 404 
 405     const Length&amp; specifiedLineHeight() const;
 406     WEBCORE_EXPORT const Length&amp; lineHeight() const;
 407     WEBCORE_EXPORT int computedLineHeight() const;
 408 
 409     WhiteSpace whiteSpace() const { return static_cast&lt;WhiteSpace&gt;(m_inheritedFlags.whiteSpace); }
 410     static bool autoWrap(WhiteSpace);
 411     bool autoWrap() const { return autoWrap(whiteSpace()); }
 412     static bool preserveNewline(WhiteSpace);
 413     bool preserveNewline() const { return preserveNewline(whiteSpace()); }
 414     static bool collapseWhiteSpace(WhiteSpace);
 415     bool collapseWhiteSpace() const { return collapseWhiteSpace(whiteSpace()); }
 416     bool isCollapsibleWhiteSpace(UChar) const;
 417     bool breakOnlyAfterWhiteSpace() const;
 418     bool breakWords() const;
 419 
 420     FillRepeat backgroundRepeatX() const { return static_cast&lt;FillRepeat&gt;(m_backgroundData-&gt;background.repeatX()); }
 421     FillRepeat backgroundRepeatY() const { return static_cast&lt;FillRepeat&gt;(m_backgroundData-&gt;background.repeatY()); }
 422     CompositeOperator backgroundComposite() const { return static_cast&lt;CompositeOperator&gt;(m_backgroundData-&gt;background.composite()); }
 423     FillAttachment backgroundAttachment() const { return static_cast&lt;FillAttachment&gt;(m_backgroundData-&gt;background.attachment()); }
 424     FillBox backgroundClip() const { return static_cast&lt;FillBox&gt;(m_backgroundData-&gt;background.clip()); }
 425     FillBox backgroundOrigin() const { return static_cast&lt;FillBox&gt;(m_backgroundData-&gt;background.origin()); }
 426     const Length&amp; backgroundXPosition() const { return m_backgroundData-&gt;background.xPosition(); }
 427     const Length&amp; backgroundYPosition() const { return m_backgroundData-&gt;background.yPosition(); }
 428     FillSizeType backgroundSizeType() const { return m_backgroundData-&gt;background.sizeType(); }
 429     const LengthSize&amp; backgroundSizeLength() const { return m_backgroundData-&gt;background.sizeLength(); }
 430     FillLayer&amp; ensureBackgroundLayers() { return m_backgroundData.access().background; }
 431     const FillLayer&amp; backgroundLayers() const { return m_backgroundData-&gt;background; }
 432 
 433     StyleImage* maskImage() const { return m_rareNonInheritedData-&gt;mask.image(); }
 434     FillRepeat maskRepeatX() const { return static_cast&lt;FillRepeat&gt;(m_rareNonInheritedData-&gt;mask.repeatX()); }
 435     FillRepeat maskRepeatY() const { return static_cast&lt;FillRepeat&gt;(m_rareNonInheritedData-&gt;mask.repeatY()); }
 436     CompositeOperator maskComposite() const { return static_cast&lt;CompositeOperator&gt;(m_rareNonInheritedData-&gt;mask.composite()); }
 437     FillBox maskClip() const { return static_cast&lt;FillBox&gt;(m_rareNonInheritedData-&gt;mask.clip()); }
 438     FillBox maskOrigin() const { return static_cast&lt;FillBox&gt;(m_rareNonInheritedData-&gt;mask.origin()); }
 439     const Length&amp; maskXPosition() const { return m_rareNonInheritedData-&gt;mask.xPosition(); }
 440     const Length&amp; maskYPosition() const { return m_rareNonInheritedData-&gt;mask.yPosition(); }
 441     FillSizeType maskSizeType() const { return m_rareNonInheritedData-&gt;mask.sizeType(); }
 442     const LengthSize&amp; maskSizeLength() const { return m_rareNonInheritedData-&gt;mask.sizeLength(); }
 443     FillLayer&amp; ensureMaskLayers() { return m_rareNonInheritedData.access().mask; }
 444     const FillLayer&amp; maskLayers() const { return m_rareNonInheritedData-&gt;mask; }
 445     const NinePieceImage&amp; maskBoxImage() const { return m_rareNonInheritedData-&gt;maskBoxImage; }
 446     StyleImage* maskBoxImageSource() const { return m_rareNonInheritedData-&gt;maskBoxImage.image(); }
 447 
 448     BorderCollapse borderCollapse() const { return static_cast&lt;BorderCollapse&gt;(m_inheritedFlags.borderCollapse); }
 449     float horizontalBorderSpacing() const;
 450     float verticalBorderSpacing() const;
 451     EmptyCell emptyCells() const { return static_cast&lt;EmptyCell&gt;(m_inheritedFlags.emptyCells); }
 452     CaptionSide captionSide() const { return static_cast&lt;CaptionSide&gt;(m_inheritedFlags.captionSide); }
 453 
 454     ListStyleType listStyleType() const { return static_cast&lt;ListStyleType&gt;(m_inheritedFlags.listStyleType); }
 455     StyleImage* listStyleImage() const;
 456     ListStylePosition listStylePosition() const { return static_cast&lt;ListStylePosition&gt;(m_inheritedFlags.listStylePosition); }
 457 
 458     const Length&amp; marginTop() const { return m_surroundData-&gt;margin.top(); }
 459     const Length&amp; marginBottom() const { return m_surroundData-&gt;margin.bottom(); }
 460     const Length&amp; marginLeft() const { return m_surroundData-&gt;margin.left(); }
 461     const Length&amp; marginRight() const { return m_surroundData-&gt;margin.right(); }
 462     const Length&amp; marginBefore() const { return m_surroundData-&gt;margin.before(writingMode()); }
 463     const Length&amp; marginAfter() const { return m_surroundData-&gt;margin.after(writingMode()); }
 464     const Length&amp; marginStart() const { return m_surroundData-&gt;margin.start(writingMode(), direction()); }
 465     const Length&amp; marginEnd() const { return m_surroundData-&gt;margin.end(writingMode(), direction()); }
 466     const Length&amp; marginStartUsing(const RenderStyle* otherStyle) const { return m_surroundData-&gt;margin.start(otherStyle-&gt;writingMode(), otherStyle-&gt;direction()); }
 467     const Length&amp; marginEndUsing(const RenderStyle* otherStyle) const { return m_surroundData-&gt;margin.end(otherStyle-&gt;writingMode(), otherStyle-&gt;direction()); }
 468     const Length&amp; marginBeforeUsing(const RenderStyle* otherStyle) const { return m_surroundData-&gt;margin.before(otherStyle-&gt;writingMode()); }
 469     const Length&amp; marginAfterUsing(const RenderStyle* otherStyle) const { return m_surroundData-&gt;margin.after(otherStyle-&gt;writingMode()); }
 470 
 471     const LengthBox&amp; paddingBox() const { return m_surroundData-&gt;padding; }
 472     const Length&amp; paddingTop() const { return m_surroundData-&gt;padding.top(); }
 473     const Length&amp; paddingBottom() const { return m_surroundData-&gt;padding.bottom(); }
 474     const Length&amp; paddingLeft() const { return m_surroundData-&gt;padding.left(); }
 475     const Length&amp; paddingRight() const { return m_surroundData-&gt;padding.right(); }
 476     const Length&amp; paddingBefore() const { return m_surroundData-&gt;padding.before(writingMode()); }
 477     const Length&amp; paddingAfter() const { return m_surroundData-&gt;padding.after(writingMode()); }
 478     const Length&amp; paddingStart() const { return m_surroundData-&gt;padding.start(writingMode(), direction()); }
 479     const Length&amp; paddingEnd() const { return m_surroundData-&gt;padding.end(writingMode(), direction()); }
 480 
 481     CursorType cursor() const { return static_cast&lt;CursorType&gt;(m_inheritedFlags.cursor); }
 482 
 483 #if ENABLE(CURSOR_VISIBILITY)
 484     CursorVisibility cursorVisibility() const { return static_cast&lt;CursorVisibility&gt;(m_inheritedFlags.cursorVisibility); }
 485 #endif
 486 
 487     CursorList* cursors() const { return m_rareInheritedData-&gt;cursorData.get(); }
 488 
 489     InsideLink insideLink() const { return static_cast&lt;InsideLink&gt;(m_inheritedFlags.insideLink); }
 490     bool isLink() const { return m_nonInheritedFlags.isLink; }
 491 
 492     bool insideDefaultButton() const { return m_inheritedFlags.insideDefaultButton; }
 493 
 494     short widows() const { return m_rareInheritedData-&gt;widows; }
 495     short orphans() const { return m_rareInheritedData-&gt;orphans; }
 496     bool hasAutoWidows() const { return m_rareInheritedData-&gt;hasAutoWidows; }
 497     bool hasAutoOrphans() const { return m_rareInheritedData-&gt;hasAutoOrphans; }
 498 
 499     BreakInside breakInside() const { return static_cast&lt;BreakInside&gt;(m_rareNonInheritedData-&gt;breakInside); }
 500     BreakBetween breakBefore() const { return static_cast&lt;BreakBetween&gt;(m_rareNonInheritedData-&gt;breakBefore); }
 501     BreakBetween breakAfter() const { return static_cast&lt;BreakBetween&gt;(m_rareNonInheritedData-&gt;breakAfter); }
 502 
 503     OptionSet&lt;HangingPunctuation&gt; hangingPunctuation() const { return OptionSet&lt;HangingPunctuation&gt;::fromRaw(m_rareInheritedData-&gt;hangingPunctuation); }
 504 
 505     float outlineOffset() const;
 506     const ShadowData* textShadow() const { return m_rareInheritedData-&gt;textShadow.get(); }
 507     void getTextShadowInlineDirectionExtent(LayoutUnit&amp; logicalLeft, LayoutUnit&amp; logicalRight) const { getShadowInlineDirectionExtent(textShadow(), logicalLeft, logicalRight); }
 508     void getTextShadowBlockDirectionExtent(LayoutUnit&amp; logicalTop, LayoutUnit&amp; logicalBottom) const { getShadowBlockDirectionExtent(textShadow(), logicalTop, logicalBottom); }
 509 
 510     float textStrokeWidth() const { return m_rareInheritedData-&gt;textStrokeWidth; }
 511     float opacity() const { return m_rareNonInheritedData-&gt;opacity; }
 512     ControlPart appearance() const { return static_cast&lt;ControlPart&gt;(m_rareNonInheritedData-&gt;appearance); }
 513     AspectRatioType aspectRatioType() const { return static_cast&lt;AspectRatioType&gt;(m_rareNonInheritedData-&gt;aspectRatioType); }
 514     float aspectRatioDenominator() const { return m_rareNonInheritedData-&gt;aspectRatioDenominator; }
 515     float aspectRatioNumerator() const { return m_rareNonInheritedData-&gt;aspectRatioNumerator; }
 516     BoxAlignment boxAlign() const { return static_cast&lt;BoxAlignment&gt;(m_rareNonInheritedData-&gt;deprecatedFlexibleBox-&gt;align); }
 517     BoxDirection boxDirection() const { return static_cast&lt;BoxDirection&gt;(m_inheritedFlags.boxDirection); }
 518     float boxFlex() const { return m_rareNonInheritedData-&gt;deprecatedFlexibleBox-&gt;flex; }
 519     unsigned boxFlexGroup() const { return m_rareNonInheritedData-&gt;deprecatedFlexibleBox-&gt;flexGroup; }
 520     BoxLines boxLines() const { return static_cast&lt;BoxLines&gt;(m_rareNonInheritedData-&gt;deprecatedFlexibleBox-&gt;lines); }
 521     unsigned boxOrdinalGroup() const { return m_rareNonInheritedData-&gt;deprecatedFlexibleBox-&gt;ordinalGroup; }
 522     BoxOrient boxOrient() const { return static_cast&lt;BoxOrient&gt;(m_rareNonInheritedData-&gt;deprecatedFlexibleBox-&gt;orient); }
 523     BoxPack boxPack() const { return static_cast&lt;BoxPack&gt;(m_rareNonInheritedData-&gt;deprecatedFlexibleBox-&gt;pack); }
 524 
 525     int order() const { return m_rareNonInheritedData-&gt;order; }
 526     float flexGrow() const { return m_rareNonInheritedData-&gt;flexibleBox-&gt;flexGrow; }
 527     float flexShrink() const { return m_rareNonInheritedData-&gt;flexibleBox-&gt;flexShrink; }
 528     const Length&amp; flexBasis() const { return m_rareNonInheritedData-&gt;flexibleBox-&gt;flexBasis; }
 529     const StyleContentAlignmentData&amp; alignContent() const { return m_rareNonInheritedData-&gt;alignContent; }
 530     const StyleSelfAlignmentData&amp; alignItems() const { return m_rareNonInheritedData-&gt;alignItems; }
 531     const StyleSelfAlignmentData&amp; alignSelf() const { return m_rareNonInheritedData-&gt;alignSelf; }
 532     FlexDirection flexDirection() const { return static_cast&lt;FlexDirection&gt;(m_rareNonInheritedData-&gt;flexibleBox-&gt;flexDirection); }
 533     bool isColumnFlexDirection() const { return flexDirection() == FlexDirection::Column || flexDirection() == FlexDirection::ColumnReverse; }
 534     bool isReverseFlexDirection() const { return flexDirection() == FlexDirection::RowReverse || flexDirection() == FlexDirection::ColumnReverse; }
 535     FlexWrap flexWrap() const { return static_cast&lt;FlexWrap&gt;(m_rareNonInheritedData-&gt;flexibleBox-&gt;flexWrap); }
 536     const StyleContentAlignmentData&amp; justifyContent() const { return m_rareNonInheritedData-&gt;justifyContent; }
 537     const StyleSelfAlignmentData&amp; justifyItems() const { return m_rareNonInheritedData-&gt;justifyItems; }
 538     const StyleSelfAlignmentData&amp; justifySelf() const { return m_rareNonInheritedData-&gt;justifySelf; }
 539 
 540     const Vector&lt;GridTrackSize&gt;&amp; gridColumns() const { return m_rareNonInheritedData-&gt;grid-&gt;gridColumns; }
 541     const Vector&lt;GridTrackSize&gt;&amp; gridRows() const { return m_rareNonInheritedData-&gt;grid-&gt;gridRows; }
 542     const Vector&lt;GridTrackSize&gt;&amp; gridAutoRepeatColumns() const { return m_rareNonInheritedData-&gt;grid-&gt;gridAutoRepeatColumns; }
 543     const Vector&lt;GridTrackSize&gt;&amp; gridAutoRepeatRows() const { return m_rareNonInheritedData-&gt;grid-&gt;gridAutoRepeatRows; }
 544     unsigned gridAutoRepeatColumnsInsertionPoint() const { return m_rareNonInheritedData-&gt;grid-&gt;autoRepeatColumnsInsertionPoint; }
 545     unsigned gridAutoRepeatRowsInsertionPoint() const { return m_rareNonInheritedData-&gt;grid-&gt;autoRepeatRowsInsertionPoint; }
 546     AutoRepeatType gridAutoRepeatColumnsType() const  { return m_rareNonInheritedData-&gt;grid-&gt;autoRepeatColumnsType; }
 547     AutoRepeatType gridAutoRepeatRowsType() const  { return m_rareNonInheritedData-&gt;grid-&gt;autoRepeatRowsType; }
 548     const NamedGridLinesMap&amp; namedGridColumnLines() const { return m_rareNonInheritedData-&gt;grid-&gt;namedGridColumnLines; }
 549     const NamedGridLinesMap&amp; namedGridRowLines() const { return m_rareNonInheritedData-&gt;grid-&gt;namedGridRowLines; }
 550     const OrderedNamedGridLinesMap&amp; orderedNamedGridColumnLines() const { return m_rareNonInheritedData-&gt;grid-&gt;orderedNamedGridColumnLines; }
 551     const OrderedNamedGridLinesMap&amp; orderedNamedGridRowLines() const { return m_rareNonInheritedData-&gt;grid-&gt;orderedNamedGridRowLines; }
 552     const NamedGridLinesMap&amp; autoRepeatNamedGridColumnLines() const { return m_rareNonInheritedData-&gt;grid-&gt;autoRepeatNamedGridColumnLines; }
 553     const NamedGridLinesMap&amp; autoRepeatNamedGridRowLines() const { return m_rareNonInheritedData-&gt;grid-&gt;autoRepeatNamedGridRowLines; }
 554     const OrderedNamedGridLinesMap&amp; autoRepeatOrderedNamedGridColumnLines() const { return m_rareNonInheritedData-&gt;grid-&gt;autoRepeatOrderedNamedGridColumnLines; }
 555     const OrderedNamedGridLinesMap&amp; autoRepeatOrderedNamedGridRowLines() const { return m_rareNonInheritedData-&gt;grid-&gt;autoRepeatOrderedNamedGridRowLines; }
 556     const NamedGridAreaMap&amp; namedGridArea() const { return m_rareNonInheritedData-&gt;grid-&gt;namedGridArea; }
 557     size_t namedGridAreaRowCount() const { return m_rareNonInheritedData-&gt;grid-&gt;namedGridAreaRowCount; }
 558     size_t namedGridAreaColumnCount() const { return m_rareNonInheritedData-&gt;grid-&gt;namedGridAreaColumnCount; }
 559     GridAutoFlow gridAutoFlow() const { return static_cast&lt;GridAutoFlow&gt;(m_rareNonInheritedData-&gt;grid-&gt;gridAutoFlow); }
 560     bool isGridAutoFlowDirectionRow() const { return (m_rareNonInheritedData-&gt;grid-&gt;gridAutoFlow &amp; InternalAutoFlowDirectionRow); }
 561     bool isGridAutoFlowDirectionColumn() const { return (m_rareNonInheritedData-&gt;grid-&gt;gridAutoFlow &amp; InternalAutoFlowDirectionColumn); }
 562     bool isGridAutoFlowAlgorithmSparse() const { return (m_rareNonInheritedData-&gt;grid-&gt;gridAutoFlow &amp; InternalAutoFlowAlgorithmSparse); }
 563     bool isGridAutoFlowAlgorithmDense() const { return (m_rareNonInheritedData-&gt;grid-&gt;gridAutoFlow &amp; InternalAutoFlowAlgorithmDense); }
 564     const Vector&lt;GridTrackSize&gt;&amp; gridAutoColumns() const { return m_rareNonInheritedData-&gt;grid-&gt;gridAutoColumns; }
 565     const Vector&lt;GridTrackSize&gt;&amp; gridAutoRows() const { return m_rareNonInheritedData-&gt;grid-&gt;gridAutoRows; }
 566 
 567     const GridPosition&amp; gridItemColumnStart() const { return m_rareNonInheritedData-&gt;gridItem-&gt;gridColumnStart; }
 568     const GridPosition&amp; gridItemColumnEnd() const { return m_rareNonInheritedData-&gt;gridItem-&gt;gridColumnEnd; }
 569     const GridPosition&amp; gridItemRowStart() const { return m_rareNonInheritedData-&gt;gridItem-&gt;gridRowStart; }
 570     const GridPosition&amp; gridItemRowEnd() const { return m_rareNonInheritedData-&gt;gridItem-&gt;gridRowEnd; }
 571 
 572     const ShadowData* boxShadow() const { return m_rareNonInheritedData-&gt;boxShadow.get(); }
 573     void getBoxShadowExtent(LayoutUnit&amp; top, LayoutUnit&amp; right, LayoutUnit&amp; bottom, LayoutUnit&amp; left) const { getShadowExtent(boxShadow(), top, right, bottom, left); }
 574     LayoutBoxExtent getBoxShadowInsetExtent() const { return getShadowInsetExtent(boxShadow()); }
 575     void getBoxShadowHorizontalExtent(LayoutUnit&amp; left, LayoutUnit&amp; right) const { getShadowHorizontalExtent(boxShadow(), left, right); }
 576     void getBoxShadowVerticalExtent(LayoutUnit&amp; top, LayoutUnit&amp; bottom) const { getShadowVerticalExtent(boxShadow(), top, bottom); }
 577     void getBoxShadowInlineDirectionExtent(LayoutUnit&amp; logicalLeft, LayoutUnit&amp; logicalRight) const { getShadowInlineDirectionExtent(boxShadow(), logicalLeft, logicalRight); }
 578     void getBoxShadowBlockDirectionExtent(LayoutUnit&amp; logicalTop, LayoutUnit&amp; logicalBottom) const { getShadowBlockDirectionExtent(boxShadow(), logicalTop, logicalBottom); }
 579 
 580 #if ENABLE(CSS_BOX_DECORATION_BREAK)
 581     BoxDecorationBreak boxDecorationBreak() const { return m_boxData-&gt;boxDecorationBreak(); }
 582 #endif
 583 
 584     StyleReflection* boxReflect() const { return m_rareNonInheritedData-&gt;boxReflect.get(); }
 585     BoxSizing boxSizing() const { return m_boxData-&gt;boxSizing(); }
 586     const Length&amp; marqueeIncrement() const { return m_rareNonInheritedData-&gt;marquee-&gt;increment; }
 587     int marqueeSpeed() const { return m_rareNonInheritedData-&gt;marquee-&gt;speed; }
 588     int marqueeLoopCount() const { return m_rareNonInheritedData-&gt;marquee-&gt;loops; }
 589     MarqueeBehavior marqueeBehavior() const { return static_cast&lt;MarqueeBehavior&gt;(m_rareNonInheritedData-&gt;marquee-&gt;behavior); }
 590     MarqueeDirection marqueeDirection() const { return static_cast&lt;MarqueeDirection&gt;(m_rareNonInheritedData-&gt;marquee-&gt;direction); }
 591     UserModify userModify() const { return static_cast&lt;UserModify&gt;(m_rareInheritedData-&gt;userModify); }
 592     UserDrag userDrag() const { return static_cast&lt;UserDrag&gt;(m_rareNonInheritedData-&gt;userDrag); }
 593     UserSelect userSelect() const { return static_cast&lt;UserSelect&gt;(m_rareInheritedData-&gt;userSelect); }
 594     TextOverflow textOverflow() const { return static_cast&lt;TextOverflow&gt;(m_rareNonInheritedData-&gt;textOverflow); }
 595     MarginCollapse marginBeforeCollapse() const { return static_cast&lt;MarginCollapse&gt;(m_rareNonInheritedData-&gt;marginBeforeCollapse); }
 596     MarginCollapse marginAfterCollapse() const { return static_cast&lt;MarginCollapse&gt;(m_rareNonInheritedData-&gt;marginAfterCollapse); }
 597     WordBreak wordBreak() const { return static_cast&lt;WordBreak&gt;(m_rareInheritedData-&gt;wordBreak); }
 598     OverflowWrap overflowWrap() const { return static_cast&lt;OverflowWrap&gt;(m_rareInheritedData-&gt;overflowWrap); }
 599     NBSPMode nbspMode() const { return static_cast&lt;NBSPMode&gt;(m_rareInheritedData-&gt;nbspMode); }
 600     LineBreak lineBreak() const { return static_cast&lt;LineBreak&gt;(m_rareInheritedData-&gt;lineBreak); }
 601     Hyphens hyphens() const { return static_cast&lt;Hyphens&gt;(m_rareInheritedData-&gt;hyphens); }
 602     short hyphenationLimitBefore() const { return m_rareInheritedData-&gt;hyphenationLimitBefore; }
 603     short hyphenationLimitAfter() const { return m_rareInheritedData-&gt;hyphenationLimitAfter; }
 604     short hyphenationLimitLines() const { return m_rareInheritedData-&gt;hyphenationLimitLines; }
<a name="4" id="anc4"></a><span class="line-modified"> 605     const AtomicString&amp; hyphenationString() const { return m_rareInheritedData-&gt;hyphenationString; }</span>
<span class="line-modified"> 606     const AtomicString&amp; locale() const { return fontDescription().locale(); }</span>
 607     BorderFit borderFit() const { return static_cast&lt;BorderFit&gt;(m_rareNonInheritedData-&gt;borderFit); }
 608     Resize resize() const { return static_cast&lt;Resize&gt;(m_rareNonInheritedData-&gt;resize); }
 609     ColumnAxis columnAxis() const { return static_cast&lt;ColumnAxis&gt;(m_rareNonInheritedData-&gt;multiCol-&gt;axis); }
 610     bool hasInlineColumnAxis() const;
 611     ColumnProgression columnProgression() const { return static_cast&lt;ColumnProgression&gt;(m_rareNonInheritedData-&gt;multiCol-&gt;progression); }
 612     float columnWidth() const { return m_rareNonInheritedData-&gt;multiCol-&gt;width; }
 613     bool hasAutoColumnWidth() const { return m_rareNonInheritedData-&gt;multiCol-&gt;autoWidth; }
 614     unsigned short columnCount() const { return m_rareNonInheritedData-&gt;multiCol-&gt;count; }
 615     bool hasAutoColumnCount() const { return m_rareNonInheritedData-&gt;multiCol-&gt;autoCount; }
 616     bool specifiesColumns() const { return !hasAutoColumnCount() || !hasAutoColumnWidth() || !hasInlineColumnAxis(); }
 617     ColumnFill columnFill() const { return static_cast&lt;ColumnFill&gt;(m_rareNonInheritedData-&gt;multiCol-&gt;fill); }
 618     const GapLength&amp; columnGap() const { return m_rareNonInheritedData-&gt;columnGap; }
 619     const GapLength&amp; rowGap() const { return m_rareNonInheritedData-&gt;rowGap; }
 620     BorderStyle columnRuleStyle() const { return m_rareNonInheritedData-&gt;multiCol-&gt;rule.style(); }
 621     unsigned short columnRuleWidth() const { return m_rareNonInheritedData-&gt;multiCol-&gt;ruleWidth(); }
 622     bool columnRuleIsTransparent() const { return m_rareNonInheritedData-&gt;multiCol-&gt;rule.isTransparent(); }
 623     ColumnSpan columnSpan() const { return static_cast&lt;ColumnSpan&gt;(m_rareNonInheritedData-&gt;multiCol-&gt;columnSpan); }
 624 
 625     const TransformOperations&amp; transform() const { return m_rareNonInheritedData-&gt;transform-&gt;operations; }
 626     bool hasTransform() const { return !m_rareNonInheritedData-&gt;transform-&gt;operations.operations().isEmpty(); }
 627     const Length&amp; transformOriginX() const { return m_rareNonInheritedData-&gt;transform-&gt;x; }
 628     const Length&amp; transformOriginY() const { return m_rareNonInheritedData-&gt;transform-&gt;y; }
 629     float transformOriginZ() const { return m_rareNonInheritedData-&gt;transform-&gt;z; }
 630     TransformBox transformBox() const { return m_rareNonInheritedData-&gt;transform-&gt;transformBox; }
 631 
 632     TextEmphasisFill textEmphasisFill() const { return static_cast&lt;TextEmphasisFill&gt;(m_rareInheritedData-&gt;textEmphasisFill); }
 633     TextEmphasisMark textEmphasisMark() const;
<a name="5" id="anc5"></a><span class="line-modified"> 634     const AtomicString&amp; textEmphasisCustomMark() const { return m_rareInheritedData-&gt;textEmphasisCustomMark; }</span>
 635     OptionSet&lt;TextEmphasisPosition&gt; textEmphasisPosition() const { return OptionSet&lt;TextEmphasisPosition&gt;::fromRaw(m_rareInheritedData-&gt;textEmphasisPosition); }
<a name="6" id="anc6"></a><span class="line-modified"> 636     const AtomicString&amp; textEmphasisMarkString() const;</span>
 637 
 638     RubyPosition rubyPosition() const { return static_cast&lt;RubyPosition&gt;(m_rareInheritedData-&gt;rubyPosition); }
 639 
 640 #if ENABLE(DARK_MODE_CSS)
<a name="7" id="anc7"></a><span class="line-modified"> 641     StyleSupportedColorSchemes supportedColorSchemes() const { return m_rareInheritedData-&gt;supportedColorSchemes; }</span>
<span class="line-modified"> 642     void setHasExplicitlySetSupportedColorSchemes(bool v) { m_nonInheritedFlags.hasExplicitlySetSupportedColorSchemes = v; }</span>
<span class="line-modified"> 643     bool hasExplicitlySetSupportedColorSchemes() const { return m_nonInheritedFlags.hasExplicitlySetSupportedColorSchemes; };</span>
 644 #endif
 645 
 646     TextOrientation textOrientation() const { return static_cast&lt;TextOrientation&gt;(m_rareInheritedData-&gt;textOrientation); }
 647 
 648     ObjectFit objectFit() const { return static_cast&lt;ObjectFit&gt;(m_rareNonInheritedData-&gt;objectFit); }
 649     LengthPoint objectPosition() const { return m_rareNonInheritedData-&gt;objectPosition; }
 650 
 651     // Return true if any transform related property (currently transform, transformStyle3D or perspective)
 652     // indicates that we are transforming.
 653     bool hasTransformRelatedProperty() const { return hasTransform() || preserves3D() || hasPerspective(); }
 654 
 655     enum ApplyTransformOrigin { IncludeTransformOrigin, ExcludeTransformOrigin };
 656     void applyTransform(TransformationMatrix&amp;, const FloatRect&amp; boundingBox, ApplyTransformOrigin = IncludeTransformOrigin) const;
 657     void setPageScaleTransform(float);
 658 
 659     bool hasMask() const { return m_rareNonInheritedData-&gt;mask.hasImage() || m_rareNonInheritedData-&gt;maskBoxImage.hasImage(); }
 660 
 661     TextCombine textCombine() const { return static_cast&lt;TextCombine&gt;(m_rareNonInheritedData-&gt;textCombine); }
 662     bool hasTextCombine() const { return textCombine() != TextCombine::None; }
 663 
<a name="8" id="anc8"></a><span class="line-modified"> 664     unsigned tabSize() const { return m_rareInheritedData-&gt;tabSize; }</span>
 665 
 666     // End CSS3 Getters
 667 
<a name="9" id="anc9"></a><span class="line-modified"> 668     const AtomicString&amp; lineGrid() const { return m_rareInheritedData-&gt;lineGrid; }</span>
 669     LineSnap lineSnap() const { return static_cast&lt;LineSnap&gt;(m_rareInheritedData-&gt;lineSnap); }
 670     LineAlign lineAlign() const { return static_cast&lt;LineAlign&gt;(m_rareInheritedData-&gt;lineAlign); }
 671 
 672     PointerEvents pointerEvents() const { return static_cast&lt;PointerEvents&gt;(m_inheritedFlags.pointerEvents); }
 673     const AnimationList* animations() const { return m_rareNonInheritedData-&gt;animations.get(); }
 674     const AnimationList* transitions() const { return m_rareNonInheritedData-&gt;transitions.get(); }
 675 
 676     AnimationList* animations() { return m_rareNonInheritedData-&gt;animations.get(); }
 677     AnimationList* transitions() { return m_rareNonInheritedData-&gt;transitions.get(); }
 678 
 679     bool hasAnimationsOrTransitions() const { return hasAnimations() || hasTransitions(); }
 680 
 681     AnimationList&amp; ensureAnimations();
 682     AnimationList&amp; ensureTransitions();
 683 
 684     bool hasAnimations() const { return m_rareNonInheritedData-&gt;animations &amp;&amp; m_rareNonInheritedData-&gt;animations-&gt;size() &gt; 0; }
 685     bool hasTransitions() const { return m_rareNonInheritedData-&gt;transitions &amp;&amp; m_rareNonInheritedData-&gt;transitions-&gt;size() &gt; 0; }
 686 
 687     // Return the first found Animation (including &#39;all&#39; transitions).
 688     const Animation* transitionForProperty(CSSPropertyID) const;
 689 
 690     TransformStyle3D transformStyle3D() const { return static_cast&lt;TransformStyle3D&gt;(m_rareNonInheritedData-&gt;transformStyle3D); }
 691     bool preserves3D() const { return transformStyle3D() == TransformStyle3D::Preserve3D; }
 692 
 693     BackfaceVisibility backfaceVisibility() const { return static_cast&lt;BackfaceVisibility&gt;(m_rareNonInheritedData-&gt;backfaceVisibility); }
 694     float perspective() const { return m_rareNonInheritedData-&gt;perspective; }
 695     bool hasPerspective() const { return m_rareNonInheritedData-&gt;perspective &gt; 0; }
 696     const Length&amp; perspectiveOriginX() const { return m_rareNonInheritedData-&gt;perspectiveOriginX; }
 697     const Length&amp; perspectiveOriginY() const { return m_rareNonInheritedData-&gt;perspectiveOriginY; }
 698     const LengthSize&amp; pageSize() const { return m_rareNonInheritedData-&gt;pageSize; }
 699     PageSizeType pageSizeType() const { return static_cast&lt;PageSizeType&gt;(m_rareNonInheritedData-&gt;pageSizeType); }
 700 
 701     LineBoxContain lineBoxContain() const { return m_rareInheritedData-&gt;lineBoxContain; }
 702     const LineClampValue&amp; lineClamp() const { return m_rareNonInheritedData-&gt;lineClamp; }
 703     const IntSize&amp; initialLetter() const { return m_rareNonInheritedData-&gt;initialLetter; }
 704     int initialLetterDrop() const { return initialLetter().width(); }
 705     int initialLetterHeight() const { return initialLetter().height(); }
 706 
 707 #if ENABLE(POINTER_EVENTS)
 708     OptionSet&lt;TouchAction&gt; touchActions() const { return OptionSet&lt;TouchAction&gt;::fromRaw(m_rareNonInheritedData-&gt;touchActions); }
<a name="10" id="anc10"></a>

 709 #endif
 710 
 711 #if ENABLE(CSS_SCROLL_SNAP)
 712     // Scroll snap port style.
 713     const StyleScrollSnapPort&amp; scrollSnapPort() const;
 714     const ScrollSnapType&amp; scrollSnapType() const;
 715     const LengthBox&amp; scrollPadding() const;
 716     const Length&amp; scrollPaddingTop() const;
 717     const Length&amp; scrollPaddingBottom() const;
 718     const Length&amp; scrollPaddingLeft() const;
 719     const Length&amp; scrollPaddingRight() const;
 720 
 721     // Scroll snap area style.
 722     const StyleScrollSnapArea&amp; scrollSnapArea() const;
 723     const ScrollSnapAlign&amp; scrollSnapAlign() const;
 724     const LengthBox&amp; scrollSnapMargin() const;
 725     const Length&amp; scrollSnapMarginTop() const;
 726     const Length&amp; scrollSnapMarginBottom() const;
 727     const Length&amp; scrollSnapMarginLeft() const;
 728     const Length&amp; scrollSnapMarginRight() const;
 729 #endif
 730 
 731 #if ENABLE(TOUCH_EVENTS)
 732     Color tapHighlightColor() const { return m_rareInheritedData-&gt;tapHighlightColor; }
 733 #endif
 734 
 735 #if PLATFORM(IOS_FAMILY)
 736     bool touchCalloutEnabled() const { return m_rareInheritedData-&gt;touchCalloutEnabled; }
 737 #endif
 738 
<a name="11" id="anc11"></a><span class="line-modified"> 739 #if ENABLE(ACCELERATED_OVERFLOW_SCROLLING)</span>
 740     bool useTouchOverflowScrolling() const { return m_rareInheritedData-&gt;useTouchOverflowScrolling; }
 741 #endif
 742 
 743 #if ENABLE(TEXT_AUTOSIZING)
 744     TextSizeAdjustment textSizeAdjust() const { return m_rareInheritedData-&gt;textSizeAdjust; }
<a name="12" id="anc12"></a>

 745 #endif
 746 
 747     TextSecurity textSecurity() const { return static_cast&lt;TextSecurity&gt;(m_rareInheritedData-&gt;textSecurity); }
 748 
 749     WritingMode writingMode() const { return static_cast&lt;WritingMode&gt;(m_inheritedFlags.writingMode); }
 750     bool isHorizontalWritingMode() const { return WebCore::isHorizontalWritingMode(writingMode()); }
 751     bool isVerticalWritingMode() const { return WebCore::isVerticalWritingMode(writingMode()); }
 752     bool isFlippedLinesWritingMode() const { return WebCore::isFlippedLinesWritingMode(writingMode()); }
 753     bool isFlippedBlocksWritingMode() const { return WebCore::isFlippedWritingMode(writingMode()); }
 754 
<a name="13" id="anc13"></a><span class="line-modified"> 755     ImageOrientationEnum imageOrientation() const;</span>
 756 
 757     ImageRendering imageRendering() const { return static_cast&lt;ImageRendering&gt;(m_rareInheritedData-&gt;imageRendering); }
 758 
 759 #if ENABLE(CSS_IMAGE_RESOLUTION)
 760     ImageResolutionSource imageResolutionSource() const { return static_cast&lt;ImageResolutionSource&gt;(m_rareInheritedData-&gt;imageResolutionSource); }
 761     ImageResolutionSnap imageResolutionSnap() const { return static_cast&lt;ImageResolutionSnap&gt;(m_rareInheritedData-&gt;imageResolutionSnap); }
 762     float imageResolution() const { return m_rareInheritedData-&gt;imageResolution; }
 763 #endif
 764 
 765     OptionSet&lt;SpeakAs&gt; speakAs() const { return OptionSet&lt;SpeakAs&gt;::fromRaw(m_rareInheritedData-&gt;speakAs); }
 766 
 767     FilterOperations&amp; mutableFilter() { return m_rareNonInheritedData.access().filter.access().operations; }
 768     const FilterOperations&amp; filter() const { return m_rareNonInheritedData-&gt;filter-&gt;operations; }
 769     bool hasFilter() const { return !m_rareNonInheritedData-&gt;filter-&gt;operations.operations().isEmpty(); }
 770     bool hasReferenceFilterOnly() const;
 771 
 772     FilterOperations&amp; mutableAppleColorFilter() { return m_rareInheritedData.access().appleColorFilter.access().operations; }
 773     const FilterOperations&amp; appleColorFilter() const { return m_rareInheritedData-&gt;appleColorFilter-&gt;operations; }
 774     bool hasAppleColorFilter() const { return !m_rareInheritedData-&gt;appleColorFilter-&gt;operations.operations().isEmpty(); }
 775 
 776 #if ENABLE(FILTERS_LEVEL_2)
 777     FilterOperations&amp; mutableBackdropFilter() { return m_rareNonInheritedData.access().backdropFilter.access().operations; }
 778     const FilterOperations&amp; backdropFilter() const { return m_rareNonInheritedData-&gt;backdropFilter-&gt;operations; }
 779     bool hasBackdropFilter() const { return !m_rareNonInheritedData-&gt;backdropFilter-&gt;operations.operations().isEmpty(); }
 780 #else
 781     bool hasBackdropFilter() const { return false; }
 782 #endif
 783 
 784 #if ENABLE(CSS_COMPOSITING)
 785     BlendMode blendMode() const { return static_cast&lt;BlendMode&gt;(m_rareNonInheritedData-&gt;effectiveBlendMode); }
 786     void setBlendMode(BlendMode mode) { SET_VAR(m_rareNonInheritedData, effectiveBlendMode, static_cast&lt;unsigned&gt;(mode)); }
 787     bool hasBlendMode() const { return static_cast&lt;BlendMode&gt;(m_rareNonInheritedData-&gt;effectiveBlendMode) != BlendMode::Normal; }
 788 
 789     Isolation isolation() const { return static_cast&lt;Isolation&gt;(m_rareNonInheritedData-&gt;isolation); }
 790     void setIsolation(Isolation isolation) { SET_VAR(m_rareNonInheritedData, isolation, static_cast&lt;unsigned&gt;(isolation)); }
 791     bool hasIsolation() const { return isolation() != Isolation::Auto; }
 792 #else
 793     BlendMode blendMode() const { return BlendMode::Normal; }
 794     bool hasBlendMode() const { return false; }
 795 
 796     Isolation isolation() const { return Isolation::Auto; }
 797     bool hasIsolation() const { return false; }
 798 #endif
 799 
 800     bool shouldPlaceBlockDirectionScrollbarOnLeft() const;
 801 
 802 #if ENABLE(CSS_TRAILING_WORD)
 803     TrailingWord trailingWord() const { return TrailingWord::Auto; }
 804 #endif
 805 
 806 #if ENABLE(APPLE_PAY)
 807     ApplePayButtonStyle applePayButtonStyle() const { return static_cast&lt;ApplePayButtonStyle&gt;(m_rareNonInheritedData-&gt;applePayButtonStyle); }
 808     ApplePayButtonType applePayButtonType() const { return static_cast&lt;ApplePayButtonType&gt;(m_rareNonInheritedData-&gt;applePayButtonType); }
 809 #endif
 810 
 811 // attribute setter methods
 812 
 813     void setDisplay(DisplayType v) { m_nonInheritedFlags.effectiveDisplay = static_cast&lt;unsigned&gt;(v); }
 814     void setOriginalDisplay(DisplayType v) { m_nonInheritedFlags.originalDisplay = static_cast&lt;unsigned&gt;(v); }
 815     void setPosition(PositionType v) { m_nonInheritedFlags.position = static_cast&lt;unsigned&gt;(v); }
 816     void setFloating(Float v) { m_nonInheritedFlags.floating = static_cast&lt;unsigned&gt;(v); }
 817 
 818     void setLeft(Length&amp;&amp; length) { SET_VAR(m_surroundData, offset.left(), WTFMove(length)); }
 819     void setRight(Length&amp;&amp; length) { SET_VAR(m_surroundData, offset.right(), WTFMove(length)); }
 820     void setTop(Length&amp;&amp; length) { SET_VAR(m_surroundData, offset.top(), WTFMove(length)); }
 821     void setBottom(Length&amp;&amp; length) { SET_VAR(m_surroundData, offset.bottom(), WTFMove(length)); }
 822 
 823     void setWidth(Length&amp;&amp; length) { SET_VAR(m_boxData, m_width, WTFMove(length)); }
 824     void setHeight(Length&amp;&amp; length) { SET_VAR(m_boxData, m_height, WTFMove(length)); }
 825 
 826     void setLogicalWidth(Length&amp;&amp;);
 827     void setLogicalHeight(Length&amp;&amp;);
 828 
 829     void setMinWidth(Length&amp;&amp; length) { SET_VAR(m_boxData, m_minWidth, WTFMove(length)); }
 830     void setMaxWidth(Length&amp;&amp; length) { SET_VAR(m_boxData, m_maxWidth, WTFMove(length)); }
 831     void setMinHeight(Length&amp;&amp; length) { SET_VAR(m_boxData, m_minHeight, WTFMove(length)); }
 832     void setMaxHeight(Length&amp;&amp; length) { SET_VAR(m_boxData, m_maxHeight, WTFMove(length)); }
 833 
<a name="14" id="anc14"></a><span class="line-removed"> 834 #if ENABLE(DASHBOARD_SUPPORT)</span>
<span class="line-removed"> 835     const Vector&lt;StyleDashboardRegion&gt;&amp; dashboardRegions() const { return m_rareNonInheritedData-&gt;dashboardRegions; }</span>
<span class="line-removed"> 836     void setDashboardRegions(const Vector&lt;StyleDashboardRegion&gt;&amp; regions) { SET_VAR(m_rareNonInheritedData, dashboardRegions, regions); }</span>
<span class="line-removed"> 837     void setDashboardRegion(int type, const String&amp; label, Length&amp;&amp; top, Length&amp;&amp; right, Length&amp;&amp; bottom, Length&amp;&amp; left, bool append);</span>
<span class="line-removed"> 838 #endif</span>
<span class="line-removed"> 839 </span>
 840     void resetBorder() { resetBorderImage(); resetBorderTop(); resetBorderRight(); resetBorderBottom(); resetBorderLeft(); resetBorderRadius(); }
 841     void resetBorderTop() { SET_VAR(m_surroundData, border.m_top, BorderValue()); }
 842     void resetBorderRight() { SET_VAR(m_surroundData, border.m_right, BorderValue()); }
 843     void resetBorderBottom() { SET_VAR(m_surroundData, border.m_bottom, BorderValue()); }
 844     void resetBorderLeft() { SET_VAR(m_surroundData, border.m_left, BorderValue()); }
 845     void resetBorderImage() { SET_VAR(m_surroundData, border.m_image, NinePieceImage()); }
 846     void resetBorderRadius() { resetBorderTopLeftRadius(); resetBorderTopRightRadius(); resetBorderBottomLeftRadius(); resetBorderBottomRightRadius(); }
 847     void resetBorderTopLeftRadius() { SET_VAR(m_surroundData, border.m_topLeft, initialBorderRadius()); }
 848     void resetBorderTopRightRadius() { SET_VAR(m_surroundData, border.m_topRight, initialBorderRadius()); }
 849     void resetBorderBottomLeftRadius() { SET_VAR(m_surroundData, border.m_bottomLeft, initialBorderRadius()); }
 850     void resetBorderBottomRightRadius() { SET_VAR(m_surroundData, border.m_bottomRight, initialBorderRadius()); }
 851 
 852     void setBackgroundColor(const Color&amp; v) { SET_VAR(m_backgroundData, color, v); }
 853 
 854     void setBackgroundXPosition(Length&amp;&amp; length) { SET_VAR(m_backgroundData, background.m_xPosition, WTFMove(length)); }
 855     void setBackgroundYPosition(Length&amp;&amp; length) { SET_VAR(m_backgroundData, background.m_yPosition, WTFMove(length)); }
 856     void setBackgroundSize(FillSizeType b) { SET_VAR(m_backgroundData, background.m_sizeType, static_cast&lt;unsigned&gt;(b)); }
 857     void setBackgroundSizeLength(LengthSize&amp;&amp; size) { SET_VAR(m_backgroundData, background.m_sizeLength, WTFMove(size)); }
 858 
 859     void setBorderImage(const NinePieceImage&amp; b) { SET_VAR(m_surroundData, border.m_image, b); }
 860     void setBorderImageSource(RefPtr&lt;StyleImage&gt;&amp;&amp;);
 861     void setBorderImageSlices(LengthBox&amp;&amp;);
 862     void setBorderImageWidth(LengthBox&amp;&amp;);
 863     void setBorderImageOutset(LengthBox&amp;&amp;);
 864 
 865     void setBorderTopLeftRadius(LengthSize&amp;&amp; size) { SET_VAR(m_surroundData, border.m_topLeft, WTFMove(size)); }
 866     void setBorderTopRightRadius(LengthSize&amp;&amp; size) { SET_VAR(m_surroundData, border.m_topRight, WTFMove(size)); }
 867     void setBorderBottomLeftRadius(LengthSize&amp;&amp; size) { SET_VAR(m_surroundData, border.m_bottomLeft, WTFMove(size)); }
 868     void setBorderBottomRightRadius(LengthSize&amp;&amp; size) { SET_VAR(m_surroundData, border.m_bottomRight, WTFMove(size)); }
 869 
 870     void setBorderRadius(LengthSize&amp;&amp;);
 871     void setBorderRadius(const IntSize&amp;);
 872 
 873     RoundedRect getRoundedBorderFor(const LayoutRect&amp; borderRect, bool includeLogicalLeftEdge = true, bool includeLogicalRightEdge = true) const;
 874     RoundedRect getRoundedInnerBorderFor(const LayoutRect&amp; borderRect, bool includeLogicalLeftEdge = true, bool includeLogicalRightEdge = true) const;
 875 
 876     RoundedRect getRoundedInnerBorderFor(const LayoutRect&amp; borderRect, LayoutUnit topWidth, LayoutUnit bottomWidth,
 877         LayoutUnit leftWidth, LayoutUnit rightWidth, bool includeLogicalLeftEdge = true, bool includeLogicalRightEdge = true) const;
 878 
 879     void setBorderLeftWidth(float v) { SET_VAR(m_surroundData, border.m_left.m_width, v); }
 880     void setBorderLeftStyle(BorderStyle v) { SET_VAR(m_surroundData, border.m_left.m_style, static_cast&lt;unsigned&gt;(v)); }
 881     void setBorderLeftColor(const Color&amp; v) { SET_BORDERVALUE_COLOR(m_surroundData, border.m_left, v); }
 882     void setBorderRightWidth(float v) { SET_VAR(m_surroundData, border.m_right.m_width, v); }
 883     void setBorderRightStyle(BorderStyle v) { SET_VAR(m_surroundData, border.m_right.m_style, static_cast&lt;unsigned&gt;(v)); }
 884     void setBorderRightColor(const Color&amp; v) { SET_BORDERVALUE_COLOR(m_surroundData, border.m_right, v); }
 885     void setBorderTopWidth(float v) { SET_VAR(m_surroundData, border.m_top.m_width, v); }
 886     void setBorderTopStyle(BorderStyle v) { SET_VAR(m_surroundData, border.m_top.m_style, static_cast&lt;unsigned&gt;(v)); }
 887     void setBorderTopColor(const Color&amp; v) { SET_BORDERVALUE_COLOR(m_surroundData, border.m_top, v); }
 888     void setBorderBottomWidth(float v) { SET_VAR(m_surroundData, border.m_bottom.m_width, v); }
 889     void setBorderBottomStyle(BorderStyle v) { SET_VAR(m_surroundData, border.m_bottom.m_style, static_cast&lt;unsigned&gt;(v)); }
 890     void setBorderBottomColor(const Color&amp; v) { SET_BORDERVALUE_COLOR(m_surroundData, border.m_bottom, v); }
 891 
 892     void setOutlineWidth(float v) { SET_VAR(m_backgroundData, outline.m_width, v); }
 893     void setOutlineStyleIsAuto(OutlineIsAuto isAuto) { SET_VAR(m_backgroundData, outline.m_isAuto, static_cast&lt;unsigned&gt;(isAuto)); }
 894     void setOutlineStyle(BorderStyle v) { SET_VAR(m_backgroundData, outline.m_style, static_cast&lt;unsigned&gt;(v)); }
 895     void setOutlineColor(const Color&amp; v) { SET_BORDERVALUE_COLOR(m_backgroundData, outline, v); }
 896 
 897     void setOverflowX(Overflow v) { m_nonInheritedFlags.overflowX =  static_cast&lt;unsigned&gt;(v); }
 898     void setOverflowY(Overflow v) { m_nonInheritedFlags.overflowY = static_cast&lt;unsigned&gt;(v); }
 899     void setVisibility(Visibility v) { m_inheritedFlags.visibility = static_cast&lt;unsigned&gt;(v); }
 900     void setVerticalAlign(VerticalAlign v) { m_nonInheritedFlags.verticalAlign = static_cast&lt;unsigned&gt;(v); }
 901     void setVerticalAlignLength(Length&amp;&amp; length) { setVerticalAlign(VerticalAlign::Length); SET_VAR(m_boxData, m_verticalAlign, WTFMove(length)); }
 902 
 903     void setHasClip(bool b = true) { SET_VAR(m_visualData, hasClip, b); }
 904     void setClipLeft(Length&amp;&amp; length) { SET_VAR(m_visualData, clip.left(), WTFMove(length)); }
 905     void setClipRight(Length&amp;&amp; length) { SET_VAR(m_visualData, clip.right(), WTFMove(length)); }
 906     void setClipTop(Length&amp;&amp; length) { SET_VAR(m_visualData, clip.top(), WTFMove(length)); }
 907     void setClipBottom(Length&amp;&amp; length) { SET_VAR(m_visualData, clip.bottom(), WTFMove(length)); }
 908     void setClip(Length&amp;&amp; top, Length&amp;&amp; right, Length&amp;&amp; bottom, Length&amp;&amp; left);
 909     void setClip(LengthBox&amp;&amp; box) { SET_VAR(m_visualData, clip, WTFMove(box)); }
 910 
 911     void setUnicodeBidi(EUnicodeBidi v) { m_nonInheritedFlags.unicodeBidi = v; }
 912 
 913     void setClear(Clear v) { m_nonInheritedFlags.clear = static_cast&lt;unsigned&gt;(v); }
 914     void setTableLayout(TableLayoutType v) { m_nonInheritedFlags.tableLayout = static_cast&lt;unsigned&gt;(v); }
 915 
 916     bool setFontDescription(FontCascadeDescription&amp;&amp;);
 917 
 918     // Only used for blending font sizes when animating, for MathML anonymous blocks, and for text autosizing.
 919     void setFontSize(float);
 920 
 921 #if ENABLE(VARIATION_FONTS)
 922     void setFontVariationSettings(FontVariationSettings);
 923 #endif
 924     void setFontWeight(FontSelectionValue);
 925     void setFontStretch(FontSelectionValue);
 926     void setFontItalic(Optional&lt;FontSelectionValue&gt;);
 927 
 928     void setColor(const Color&amp;);
 929     void setTextIndent(Length&amp;&amp; length) { SET_VAR(m_rareInheritedData, indent, WTFMove(length)); }
 930     void setTextAlign(TextAlignMode v) { m_inheritedFlags.textAlign = static_cast&lt;unsigned&gt;(v); }
 931     void setTextTransform(TextTransform v) { m_inheritedFlags.textTransform = static_cast&lt;unsigned&gt;(v); }
 932     void addToTextDecorationsInEffect(OptionSet&lt;TextDecoration&gt; v) { m_inheritedFlags.textDecorations |= static_cast&lt;unsigned&gt;(v.toRaw()); }
 933     void setTextDecorationsInEffect(OptionSet&lt;TextDecoration&gt; v) { m_inheritedFlags.textDecorations = v.toRaw(); }
 934     void setTextDecoration(OptionSet&lt;TextDecoration&gt; v) { SET_VAR(m_visualData, textDecoration, v.toRaw()); }
 935     void setTextDecorationStyle(TextDecorationStyle v) { SET_VAR(m_rareNonInheritedData, textDecorationStyle, static_cast&lt;unsigned&gt;(v)); }
 936     void setTextDecorationSkip(OptionSet&lt;TextDecorationSkip&gt; skip) { SET_VAR(m_rareInheritedData, textDecorationSkip, skip.toRaw()); }
 937     void setTextUnderlinePosition(TextUnderlinePosition position) { SET_VAR(m_rareInheritedData, textUnderlinePosition, static_cast&lt;unsigned&gt;(position)); }
 938     void setTextUnderlineOffset(TextUnderlineOffset textUnderlineOffset) { SET_VAR(m_rareInheritedData, textUnderlineOffset, textUnderlineOffset); }
 939     void setTextDecorationThickness(TextDecorationThickness textDecorationThickness) { SET_VAR(m_rareInheritedData, textDecorationThickness, textDecorationThickness); }
 940     void setDirection(TextDirection v) { m_inheritedFlags.direction = static_cast&lt;unsigned&gt;(v); }
 941     void setHasExplicitlySetDirection(bool v) { m_nonInheritedFlags.hasExplicitlySetDirection = v; }
 942     void setLineHeight(Length&amp;&amp;);
 943     bool setZoom(float);
 944     void setZoomWithoutReturnValue(float f) { setZoom(f); }
 945     bool setEffectiveZoom(float);
 946     void setTextZoom(TextZoom v) { SET_VAR(m_rareInheritedData, textZoom, static_cast&lt;unsigned&gt;(v)); }
 947 
 948 #if ENABLE(CSS3_TEXT)
 949     void setTextIndentLine(TextIndentLine v) { SET_VAR(m_rareInheritedData, textIndentLine, v); }
 950     void setTextIndentType(TextIndentType v) { SET_VAR(m_rareInheritedData, textIndentType, v); }
 951     void setTextAlignLast(TextAlignLast v) { SET_VAR(m_rareInheritedData, textAlignLast, v); }
 952     void setTextJustify(TextJustify v) { SET_VAR(m_rareInheritedData, textJustify, v); }
 953 #endif
 954 
 955 #if ENABLE(TEXT_AUTOSIZING)
 956     void setSpecifiedLineHeight(Length&amp;&amp;);
 957 #endif
 958 
 959 #if ENABLE(CSS_IMAGE_ORIENTATION)
<a name="15" id="anc15"></a><span class="line-modified"> 960     void setImageOrientation(ImageOrientationEnum v) { SET_VAR(m_rareInheritedData, imageOrientation, static_cast&lt;int&gt;(v)); }</span>
 961 #endif
 962 
 963     void setImageRendering(ImageRendering v) { SET_VAR(m_rareInheritedData, imageRendering, static_cast&lt;unsigned&gt;(v)); }
 964 
 965 #if ENABLE(CSS_IMAGE_RESOLUTION)
 966     void setImageResolutionSource(ImageResolutionSource v) { SET_VAR(m_rareInheritedData, imageResolutionSource, v); }
 967     void setImageResolutionSnap(ImageResolutionSnap v) { SET_VAR(m_rareInheritedData, imageResolutionSnap, v); }
 968     void setImageResolution(float f) { SET_VAR(m_rareInheritedData, imageResolution, f); }
 969 #endif
 970 
 971     void setWhiteSpace(WhiteSpace v) { m_inheritedFlags.whiteSpace = static_cast&lt;unsigned&gt;(v); }
 972 
 973     void setWordSpacing(Length&amp;&amp;);
 974     void setLetterSpacing(float);
 975 
 976     void clearBackgroundLayers() { m_backgroundData.access().background = FillLayer(FillLayerType::Background); }
 977     void inheritBackgroundLayers(const FillLayer&amp; parent) { m_backgroundData.access().background = parent; }
 978 
 979     void adjustBackgroundLayers();
 980 
 981     void clearMaskLayers() { m_rareNonInheritedData.access().mask = FillLayer(FillLayerType::Mask); }
 982     void inheritMaskLayers(const FillLayer&amp; parent) { m_rareNonInheritedData.access().mask = parent; }
 983 
 984     void adjustMaskLayers();
 985 
 986     void setMaskImage(RefPtr&lt;StyleImage&gt;&amp;&amp; v) { m_rareNonInheritedData.access().mask.setImage(WTFMove(v)); }
 987 
 988     void setMaskBoxImage(const NinePieceImage&amp; b) { SET_VAR(m_rareNonInheritedData, maskBoxImage, b); }
 989     void setMaskBoxImageSource(RefPtr&lt;StyleImage&gt;&amp;&amp; v) { m_rareNonInheritedData.access().maskBoxImage.setImage(WTFMove(v)); }
 990     void setMaskXPosition(Length&amp;&amp; length) { SET_VAR(m_rareNonInheritedData, mask.m_xPosition, WTFMove(length)); }
 991     void setMaskYPosition(Length&amp;&amp; length) { SET_VAR(m_rareNonInheritedData, mask.m_yPosition, WTFMove(length)); }
 992     void setMaskSize(LengthSize size) { SET_VAR(m_rareNonInheritedData, mask.m_sizeLength, WTFMove(size)); }
 993 
 994     void setBorderCollapse(BorderCollapse collapse) { m_inheritedFlags.borderCollapse = static_cast&lt;unsigned&gt;(collapse); }
 995     void setHorizontalBorderSpacing(float);
 996     void setVerticalBorderSpacing(float);
 997     void setEmptyCells(EmptyCell v) { m_inheritedFlags.emptyCells = static_cast&lt;unsigned&gt;(v); }
 998     void setCaptionSide(CaptionSide v) { m_inheritedFlags.captionSide = static_cast&lt;unsigned&gt;(v); }
 999 
1000     void setAspectRatioType(AspectRatioType aspectRatioType) { SET_VAR(m_rareNonInheritedData, aspectRatioType, static_cast&lt;unsigned&gt;(aspectRatioType)); }
1001     void setAspectRatioDenominator(float v) { SET_VAR(m_rareNonInheritedData, aspectRatioDenominator, v); }
1002     void setAspectRatioNumerator(float v) { SET_VAR(m_rareNonInheritedData, aspectRatioNumerator, v); }
1003 
1004     void setListStyleType(ListStyleType v) { m_inheritedFlags.listStyleType = static_cast&lt;unsigned&gt;(v); }
1005     void setListStyleImage(RefPtr&lt;StyleImage&gt;&amp;&amp;);
1006     void setListStylePosition(ListStylePosition v) { m_inheritedFlags.listStylePosition = static_cast&lt;unsigned&gt;(v); }
1007 
1008     void resetMargin() { SET_VAR(m_surroundData, margin, LengthBox(Fixed)); }
1009     void setMarginTop(Length&amp;&amp; length) { SET_VAR(m_surroundData, margin.top(), WTFMove(length)); }
1010     void setMarginBottom(Length&amp;&amp; length) { SET_VAR(m_surroundData, margin.bottom(), WTFMove(length)); }
1011     void setMarginLeft(Length&amp;&amp; length) { SET_VAR(m_surroundData, margin.left(), WTFMove(length)); }
1012     void setMarginRight(Length&amp;&amp; length) { SET_VAR(m_surroundData, margin.right(), WTFMove(length)); }
1013     void setMarginStart(Length&amp;&amp;);
1014     void setMarginEnd(Length&amp;&amp;);
1015 
1016     void resetPadding() { SET_VAR(m_surroundData, padding, LengthBox(Auto)); }
1017     void setPaddingBox(LengthBox&amp;&amp; box) { SET_VAR(m_surroundData, padding, WTFMove(box)); }
1018     void setPaddingTop(Length&amp;&amp; length) { SET_VAR(m_surroundData, padding.top(), WTFMove(length)); }
1019     void setPaddingBottom(Length&amp;&amp; length) { SET_VAR(m_surroundData, padding.bottom(), WTFMove(length)); }
1020     void setPaddingLeft(Length&amp;&amp; length) { SET_VAR(m_surroundData, padding.left(), WTFMove(length)); }
1021     void setPaddingRight(Length&amp;&amp; length) { SET_VAR(m_surroundData, padding.right(), WTFMove(length)); }
1022 
1023     void setCursor(CursorType c) { m_inheritedFlags.cursor = static_cast&lt;unsigned&gt;(c); }
1024     void addCursor(RefPtr&lt;StyleImage&gt;&amp;&amp;, const IntPoint&amp; hotSpot = IntPoint());
1025     void setCursorList(RefPtr&lt;CursorList&gt;&amp;&amp;);
1026     void clearCursorList();
1027 
1028 #if ENABLE(CURSOR_VISIBILITY)
1029     void setCursorVisibility(CursorVisibility c) { m_inheritedFlags.cursorVisibility = static_cast&lt;unsigned&gt;(c); }
1030 #endif
1031 
1032     void setInsideLink(InsideLink insideLink) { m_inheritedFlags.insideLink = static_cast&lt;unsigned&gt;(insideLink); }
1033     void setIsLink(bool v) { m_nonInheritedFlags.isLink = v; }
1034 
1035     void setInsideDefaultButton(bool insideDefaultButton) { m_inheritedFlags.insideDefaultButton = insideDefaultButton; }
1036 
1037     PrintColorAdjust printColorAdjust() const { return static_cast&lt;PrintColorAdjust&gt;(m_inheritedFlags.printColorAdjust); }
1038     void setPrintColorAdjust(PrintColorAdjust value) { m_inheritedFlags.printColorAdjust = static_cast&lt;unsigned&gt;(value); }
1039 
1040     bool hasAutoZIndex() const { return m_boxData-&gt;hasAutoZIndex(); }
1041     void setHasAutoZIndex() { SET_VAR(m_boxData, m_hasAutoZIndex, true); SET_VAR(m_boxData, m_zIndex, 0); }
1042     int zIndex() const { return m_boxData-&gt;zIndex(); }
1043     void setZIndex(int v) { SET_VAR(m_boxData, m_hasAutoZIndex, false); SET_VAR(m_boxData, m_zIndex, v); }
1044 
1045     void setHasAutoWidows() { SET_VAR(m_rareInheritedData, hasAutoWidows, true); SET_VAR(m_rareInheritedData, widows, initialWidows()); }
1046     void setWidows(short w) { SET_VAR(m_rareInheritedData, hasAutoWidows, false); SET_VAR(m_rareInheritedData, widows, w); }
1047 
1048     void setHasAutoOrphans() { SET_VAR(m_rareInheritedData, hasAutoOrphans, true); SET_VAR(m_rareInheritedData, orphans, initialOrphans()); }
1049     void setOrphans(short o) { SET_VAR(m_rareInheritedData, hasAutoOrphans, false); SET_VAR(m_rareInheritedData, orphans, o); }
1050 
1051     // CSS3 Setters
1052     void setOutlineOffset(float v) { SET_VAR(m_backgroundData, outline.m_offset, v); }
1053     void setTextShadow(std::unique_ptr&lt;ShadowData&gt;, bool add = false);
1054     void setTextStrokeColor(const Color&amp; c) { SET_VAR(m_rareInheritedData, textStrokeColor, c); }
1055     void setTextStrokeWidth(float w) { SET_VAR(m_rareInheritedData, textStrokeWidth, w); }
1056     void setTextFillColor(const Color&amp; c) { SET_VAR(m_rareInheritedData, textFillColor, c); }
1057     void setCaretColor(const Color&amp; c) { SET_VAR(m_rareInheritedData, caretColor, c); }
1058     void setOpacity(float f) { float v = clampTo&lt;float&gt;(f, 0.f, 1.f); SET_VAR(m_rareNonInheritedData, opacity, v); }
1059     void setAppearance(ControlPart a) { SET_VAR(m_rareNonInheritedData, appearance, a); }
1060     // For valid values of box-align see http://www.w3.org/TR/2009/WD-css3-flexbox-20090723/#alignment
1061     void setBoxAlign(BoxAlignment a) { SET_NESTED_VAR(m_rareNonInheritedData, deprecatedFlexibleBox, align, static_cast&lt;unsigned&gt;(a)); }
1062     void setBoxDirection(BoxDirection d) { m_inheritedFlags.boxDirection = static_cast&lt;unsigned&gt;(d); }
1063     void setBoxFlex(float f) { SET_NESTED_VAR(m_rareNonInheritedData, deprecatedFlexibleBox, flex, f); }
1064     void setBoxFlexGroup(unsigned group) { SET_NESTED_VAR(m_rareNonInheritedData, deprecatedFlexibleBox, flexGroup, group); }
1065     void setBoxLines(BoxLines lines) { SET_NESTED_VAR(m_rareNonInheritedData, deprecatedFlexibleBox, lines, static_cast&lt;unsigned&gt;(lines)); }
1066     void setBoxOrdinalGroup(unsigned group) { SET_NESTED_VAR(m_rareNonInheritedData, deprecatedFlexibleBox, ordinalGroup, group); }
1067     void setBoxOrient(BoxOrient o) { SET_NESTED_VAR(m_rareNonInheritedData, deprecatedFlexibleBox, orient, static_cast&lt;unsigned&gt;(o)); }
1068     void setBoxPack(BoxPack p) { SET_NESTED_VAR(m_rareNonInheritedData, deprecatedFlexibleBox, pack, static_cast&lt;unsigned&gt;(p)); }
1069     void setBoxShadow(std::unique_ptr&lt;ShadowData&gt;, bool add = false);
1070     void setBoxReflect(RefPtr&lt;StyleReflection&gt;&amp;&amp;);
1071     void setBoxSizing(BoxSizing s) { SET_VAR(m_boxData, m_boxSizing, static_cast&lt;unsigned&gt;(s)); }
1072     void setFlexGrow(float f) { SET_NESTED_VAR(m_rareNonInheritedData, flexibleBox, flexGrow, f); }
1073     void setFlexShrink(float f) { SET_NESTED_VAR(m_rareNonInheritedData, flexibleBox, flexShrink, f); }
1074     void setFlexBasis(Length&amp;&amp; length) { SET_NESTED_VAR(m_rareNonInheritedData, flexibleBox, flexBasis, WTFMove(length)); }
1075     void setOrder(int o) { SET_VAR(m_rareNonInheritedData, order, o); }
1076     void setAlignContent(const StyleContentAlignmentData&amp; data) { SET_VAR(m_rareNonInheritedData, alignContent, data); }
1077     void setAlignItems(const StyleSelfAlignmentData&amp; data) { SET_VAR(m_rareNonInheritedData, alignItems, data); }
1078     void setAlignItemsPosition(ItemPosition position) { m_rareNonInheritedData.access().alignItems.setPosition(position); }
1079     void setAlignSelf(const StyleSelfAlignmentData&amp; data) { SET_VAR(m_rareNonInheritedData, alignSelf, data); }
1080     void setAlignSelfPosition(ItemPosition position) { m_rareNonInheritedData.access().alignSelf.setPosition(position); }
1081     void setFlexDirection(FlexDirection direction) { SET_NESTED_VAR(m_rareNonInheritedData, flexibleBox, flexDirection, static_cast&lt;unsigned&gt;(direction)); }
1082     void setFlexWrap(FlexWrap w) { SET_NESTED_VAR(m_rareNonInheritedData, flexibleBox, flexWrap, static_cast&lt;unsigned&gt;(w)); }
1083     void setJustifyContent(const StyleContentAlignmentData&amp; data) { SET_VAR(m_rareNonInheritedData, justifyContent, data); }
1084     void setJustifyContentPosition(ContentPosition position) { m_rareNonInheritedData.access().justifyContent.setPosition(position); }
1085     void setJustifyItems(const StyleSelfAlignmentData&amp; data) { SET_VAR(m_rareNonInheritedData, justifyItems, data); }
1086     void setJustifySelf(const StyleSelfAlignmentData&amp; data) { SET_VAR(m_rareNonInheritedData, justifySelf, data); }
1087     void setJustifySelfPosition(ItemPosition position) { m_rareNonInheritedData.access().justifySelf.setPosition(position); }
1088 
1089 #if ENABLE(CSS_BOX_DECORATION_BREAK)
1090     void setBoxDecorationBreak(BoxDecorationBreak b) { SET_VAR(m_boxData, m_boxDecorationBreak, static_cast&lt;unsigned&gt;(b)); }
1091 #endif
1092 
1093     void setGridAutoColumns(const Vector&lt;GridTrackSize&gt;&amp; trackSizeList) { SET_NESTED_VAR(m_rareNonInheritedData, grid, gridAutoColumns, trackSizeList); }
1094     void setGridAutoRows(const Vector&lt;GridTrackSize&gt;&amp; trackSizeList) { SET_NESTED_VAR(m_rareNonInheritedData, grid, gridAutoRows, trackSizeList); }
1095     void setGridColumns(const Vector&lt;GridTrackSize&gt;&amp; lengths) { SET_NESTED_VAR(m_rareNonInheritedData, grid, gridColumns, lengths); }
1096     void setGridRows(const Vector&lt;GridTrackSize&gt;&amp; lengths) { SET_NESTED_VAR(m_rareNonInheritedData, grid, gridRows, lengths); }
1097     void setGridAutoRepeatColumns(const Vector&lt;GridTrackSize&gt;&amp; lengths) { SET_NESTED_VAR(m_rareNonInheritedData, grid, gridAutoRepeatColumns, lengths); }
1098     void setGridAutoRepeatRows(const Vector&lt;GridTrackSize&gt;&amp; lengths) { SET_NESTED_VAR(m_rareNonInheritedData, grid, gridAutoRepeatRows, lengths); }
1099     void setGridAutoRepeatColumnsInsertionPoint(const unsigned insertionPoint) { SET_NESTED_VAR(m_rareNonInheritedData, grid, autoRepeatColumnsInsertionPoint, insertionPoint); }
1100     void setGridAutoRepeatRowsInsertionPoint(const unsigned insertionPoint) { SET_NESTED_VAR(m_rareNonInheritedData, grid, autoRepeatRowsInsertionPoint, insertionPoint); }
1101     void setGridAutoRepeatColumnsType(const AutoRepeatType autoRepeatType) { SET_NESTED_VAR(m_rareNonInheritedData, grid, autoRepeatColumnsType, autoRepeatType); }
1102     void setGridAutoRepeatRowsType(const AutoRepeatType autoRepeatType) { SET_NESTED_VAR(m_rareNonInheritedData, grid, autoRepeatRowsType, autoRepeatType); }
1103     void setNamedGridColumnLines(const NamedGridLinesMap&amp; namedGridColumnLines) { SET_NESTED_VAR(m_rareNonInheritedData, grid, namedGridColumnLines, namedGridColumnLines); }
1104     void setNamedGridRowLines(const NamedGridLinesMap&amp; namedGridRowLines) { SET_NESTED_VAR(m_rareNonInheritedData, grid, namedGridRowLines, namedGridRowLines); }
1105     void setOrderedNamedGridColumnLines(const OrderedNamedGridLinesMap&amp; orderedNamedGridColumnLines) { SET_NESTED_VAR(m_rareNonInheritedData, grid, orderedNamedGridColumnLines, orderedNamedGridColumnLines); }
1106     void setOrderedNamedGridRowLines(const OrderedNamedGridLinesMap&amp; orderedNamedGridRowLines) { SET_NESTED_VAR(m_rareNonInheritedData, grid, orderedNamedGridRowLines, orderedNamedGridRowLines); }
1107     void setAutoRepeatNamedGridColumnLines(const NamedGridLinesMap&amp; namedGridColumnLines) { SET_NESTED_VAR(m_rareNonInheritedData, grid, autoRepeatNamedGridColumnLines, namedGridColumnLines); }
1108     void setAutoRepeatNamedGridRowLines(const NamedGridLinesMap&amp; namedGridRowLines) { SET_NESTED_VAR(m_rareNonInheritedData, grid, autoRepeatNamedGridRowLines, namedGridRowLines); }
1109     void setAutoRepeatOrderedNamedGridColumnLines(const OrderedNamedGridLinesMap&amp; orderedNamedGridColumnLines) { SET_NESTED_VAR(m_rareNonInheritedData, grid, autoRepeatOrderedNamedGridColumnLines, orderedNamedGridColumnLines); }
1110     void setAutoRepeatOrderedNamedGridRowLines(const OrderedNamedGridLinesMap&amp; orderedNamedGridRowLines) { SET_NESTED_VAR(m_rareNonInheritedData, grid, autoRepeatOrderedNamedGridRowLines, orderedNamedGridRowLines); }
1111     void setNamedGridArea(const NamedGridAreaMap&amp; namedGridArea) { SET_NESTED_VAR(m_rareNonInheritedData, grid, namedGridArea, namedGridArea); }
1112     void setNamedGridAreaRowCount(size_t rowCount) { SET_NESTED_VAR(m_rareNonInheritedData, grid, namedGridAreaRowCount, rowCount); }
1113     void setNamedGridAreaColumnCount(size_t columnCount) { SET_NESTED_VAR(m_rareNonInheritedData, grid, namedGridAreaColumnCount, columnCount); }
1114     void setGridAutoFlow(GridAutoFlow flow) { SET_NESTED_VAR(m_rareNonInheritedData, grid, gridAutoFlow, flow); }
1115     void setGridItemColumnStart(const GridPosition&amp; columnStartPosition) { SET_NESTED_VAR(m_rareNonInheritedData, gridItem, gridColumnStart, columnStartPosition); }
1116     void setGridItemColumnEnd(const GridPosition&amp; columnEndPosition) { SET_NESTED_VAR(m_rareNonInheritedData, gridItem, gridColumnEnd, columnEndPosition); }
1117     void setGridItemRowStart(const GridPosition&amp; rowStartPosition) { SET_NESTED_VAR(m_rareNonInheritedData, gridItem, gridRowStart, rowStartPosition); }
1118     void setGridItemRowEnd(const GridPosition&amp; rowEndPosition) { SET_NESTED_VAR(m_rareNonInheritedData, gridItem, gridRowEnd, rowEndPosition); }
1119 
1120     void setMarqueeIncrement(Length&amp;&amp; length) { SET_NESTED_VAR(m_rareNonInheritedData, marquee, increment, WTFMove(length)); }
1121     void setMarqueeSpeed(int f) { SET_NESTED_VAR(m_rareNonInheritedData, marquee, speed, f); }
1122     void setMarqueeDirection(MarqueeDirection d) { SET_NESTED_VAR(m_rareNonInheritedData, marquee, direction, static_cast&lt;unsigned&gt;(d)); }
1123     void setMarqueeBehavior(MarqueeBehavior b) { SET_NESTED_VAR(m_rareNonInheritedData, marquee, behavior, static_cast&lt;unsigned&gt;(b)); }
1124     void setMarqueeLoopCount(int i) { SET_NESTED_VAR(m_rareNonInheritedData, marquee, loops, i); }
1125     void setUserModify(UserModify u) { SET_VAR(m_rareInheritedData, userModify, static_cast&lt;unsigned&gt;(u)); }
1126     void setUserDrag(UserDrag d) { SET_VAR(m_rareNonInheritedData, userDrag, static_cast&lt;unsigned&gt;(d)); }
1127     void setUserSelect(UserSelect s) { SET_VAR(m_rareInheritedData, userSelect, static_cast&lt;unsigned&gt;(s)); }
1128     void setTextOverflow(TextOverflow overflow) { SET_VAR(m_rareNonInheritedData, textOverflow, static_cast&lt;unsigned&gt;(overflow)); }
1129     void setMarginBeforeCollapse(MarginCollapse c) { SET_VAR(m_rareNonInheritedData, marginBeforeCollapse, static_cast&lt;unsigned&gt;(c)); }
1130     void setMarginAfterCollapse(MarginCollapse c) { SET_VAR(m_rareNonInheritedData, marginAfterCollapse, static_cast&lt;unsigned&gt;(c)); }
1131     void setWordBreak(WordBreak b) { SET_VAR(m_rareInheritedData, wordBreak, static_cast&lt;unsigned&gt;(b)); }
1132     void setOverflowWrap(OverflowWrap b) { SET_VAR(m_rareInheritedData, overflowWrap, static_cast&lt;unsigned&gt;(b)); }
1133     void setNBSPMode(NBSPMode b) { SET_VAR(m_rareInheritedData, nbspMode, static_cast&lt;unsigned&gt;(b)); }
1134     void setLineBreak(LineBreak b) { SET_VAR(m_rareInheritedData, lineBreak, static_cast&lt;unsigned&gt;(b)); }
1135     void setHyphens(Hyphens h) { SET_VAR(m_rareInheritedData, hyphens, static_cast&lt;unsigned&gt;(h)); }
1136     void setHyphenationLimitBefore(short limit) { SET_VAR(m_rareInheritedData, hyphenationLimitBefore, limit); }
1137     void setHyphenationLimitAfter(short limit) { SET_VAR(m_rareInheritedData, hyphenationLimitAfter, limit); }
1138     void setHyphenationLimitLines(short limit) { SET_VAR(m_rareInheritedData, hyphenationLimitLines, limit); }
<a name="16" id="anc16"></a><span class="line-modified">1139     void setHyphenationString(const AtomicString&amp; h) { SET_VAR(m_rareInheritedData, hyphenationString, h); }</span>
1140     void setBorderFit(BorderFit b) { SET_VAR(m_rareNonInheritedData, borderFit, static_cast&lt;unsigned&gt;(b)); }
1141     void setResize(Resize r) { SET_VAR(m_rareNonInheritedData, resize, static_cast&lt;unsigned&gt;(r)); }
1142     void setColumnAxis(ColumnAxis axis) { SET_NESTED_VAR(m_rareNonInheritedData, multiCol, axis, static_cast&lt;unsigned&gt;(axis)); }
1143     void setColumnProgression(ColumnProgression progression) { SET_NESTED_VAR(m_rareNonInheritedData, multiCol, progression, static_cast&lt;unsigned&gt;(progression)); }
1144     void setColumnWidth(float f) { SET_NESTED_VAR(m_rareNonInheritedData, multiCol, autoWidth, false); SET_NESTED_VAR(m_rareNonInheritedData, multiCol, width, f); }
1145     void setHasAutoColumnWidth() { SET_NESTED_VAR(m_rareNonInheritedData, multiCol, autoWidth, true); SET_NESTED_VAR(m_rareNonInheritedData, multiCol, width, 0); }
1146     void setColumnCount(unsigned short c) { SET_NESTED_VAR(m_rareNonInheritedData, multiCol, autoCount, false); SET_NESTED_VAR(m_rareNonInheritedData, multiCol, count, c); }
1147     void setHasAutoColumnCount() { SET_NESTED_VAR(m_rareNonInheritedData, multiCol, autoCount, true); SET_NESTED_VAR(m_rareNonInheritedData, multiCol, count, 0); }
1148     void setColumnFill(ColumnFill columnFill) { SET_NESTED_VAR(m_rareNonInheritedData, multiCol, fill, static_cast&lt;unsigned&gt;(columnFill)); }
1149     void setColumnGap(GapLength&amp;&amp; gapLength) { SET_VAR(m_rareNonInheritedData, columnGap, WTFMove(gapLength)); }
1150     void setRowGap(GapLength&amp;&amp; gapLength) { SET_VAR(m_rareNonInheritedData, rowGap, WTFMove(gapLength)); }
1151     void setColumnRuleColor(const Color&amp; c) { SET_BORDERVALUE_COLOR(m_rareNonInheritedData.access().multiCol, rule, c); }
1152     void setColumnRuleStyle(BorderStyle b) { SET_NESTED_VAR(m_rareNonInheritedData, multiCol, rule.m_style, static_cast&lt;unsigned&gt;(b)); }
1153     void setColumnRuleWidth(unsigned short w) { SET_NESTED_VAR(m_rareNonInheritedData, multiCol, rule.m_width, w); }
1154     void resetColumnRule() { SET_NESTED_VAR(m_rareNonInheritedData, multiCol, rule, BorderValue()); }
1155     void setColumnSpan(ColumnSpan columnSpan) { SET_NESTED_VAR(m_rareNonInheritedData, multiCol, columnSpan, static_cast&lt;unsigned&gt;(columnSpan)); }
1156     void inheritColumnPropertiesFrom(const RenderStyle&amp; parent) { m_rareNonInheritedData.access().multiCol = parent.m_rareNonInheritedData-&gt;multiCol; }
1157 
1158     void setTransform(const TransformOperations&amp; ops) { SET_NESTED_VAR(m_rareNonInheritedData, transform, operations, ops); }
1159     void setTransformOriginX(Length&amp;&amp; length) { SET_NESTED_VAR(m_rareNonInheritedData, transform, x, WTFMove(length)); }
1160     void setTransformOriginY(Length&amp;&amp; length) { SET_NESTED_VAR(m_rareNonInheritedData, transform, y, WTFMove(length)); }
1161     void setTransformOriginZ(float f) { SET_NESTED_VAR(m_rareNonInheritedData, transform, z, f); }
1162     void setTransformBox(TransformBox box) { SET_NESTED_VAR(m_rareNonInheritedData, transform, transformBox, box); }
1163 
1164     void setSpeakAs(OptionSet&lt;SpeakAs&gt; s) { SET_VAR(m_rareInheritedData, speakAs, s.toRaw()); }
1165     void setTextCombine(TextCombine v) { SET_VAR(m_rareNonInheritedData, textCombine, static_cast&lt;unsigned&gt;(v)); }
1166     void setTextDecorationColor(const Color&amp; c) { SET_VAR(m_rareNonInheritedData, textDecorationColor, c); }
1167     void setTextEmphasisColor(const Color&amp; c) { SET_VAR(m_rareInheritedData, textEmphasisColor, c); }
1168     void setTextEmphasisFill(TextEmphasisFill fill) { SET_VAR(m_rareInheritedData, textEmphasisFill, static_cast&lt;unsigned&gt;(fill)); }
1169     void setTextEmphasisMark(TextEmphasisMark mark) { SET_VAR(m_rareInheritedData, textEmphasisMark, static_cast&lt;unsigned&gt;(mark)); }
<a name="17" id="anc17"></a><span class="line-modified">1170     void setTextEmphasisCustomMark(const AtomicString&amp; mark) { SET_VAR(m_rareInheritedData, textEmphasisCustomMark, mark); }</span>
1171     void setTextEmphasisPosition(OptionSet&lt;TextEmphasisPosition&gt; position) { SET_VAR(m_rareInheritedData, textEmphasisPosition, static_cast&lt;unsigned&gt;(position.toRaw())); }
1172     bool setTextOrientation(TextOrientation);
1173 
1174     void setObjectFit(ObjectFit fit) { SET_VAR(m_rareNonInheritedData, objectFit, static_cast&lt;unsigned&gt;(fit)); }
1175     void setObjectPosition(LengthPoint&amp;&amp; position) { SET_VAR(m_rareNonInheritedData, objectPosition, WTFMove(position)); }
1176 
1177     void setRubyPosition(RubyPosition position) { SET_VAR(m_rareInheritedData, rubyPosition, static_cast&lt;unsigned&gt;(position)); }
1178 
1179 #if ENABLE(DARK_MODE_CSS)
<a name="18" id="anc18"></a><span class="line-modified">1180     void setSupportedColorSchemes(StyleSupportedColorSchemes supported) { SET_VAR(m_rareInheritedData, supportedColorSchemes, supported); }</span>
1181 #endif
1182 
1183     void setFilter(const FilterOperations&amp; ops) { SET_NESTED_VAR(m_rareNonInheritedData, filter, operations, ops); }
1184     void setAppleColorFilter(const FilterOperations&amp; ops) { SET_NESTED_VAR(m_rareInheritedData, appleColorFilter, operations, ops); }
1185 
1186 #if ENABLE(FILTERS_LEVEL_2)
1187     void setBackdropFilter(const FilterOperations&amp; ops) { SET_NESTED_VAR(m_rareNonInheritedData, backdropFilter, operations, ops); }
1188 #endif
1189 
<a name="19" id="anc19"></a><span class="line-modified">1190     void setTabSize(unsigned size) { SET_VAR(m_rareInheritedData, tabSize, size); }</span>
1191 
1192     void setBreakBefore(BreakBetween breakBehavior) { SET_VAR(m_rareNonInheritedData, breakBefore, static_cast&lt;unsigned&gt;(breakBehavior)); }
1193     void setBreakAfter(BreakBetween breakBehavior) { SET_VAR(m_rareNonInheritedData, breakAfter, static_cast&lt;unsigned&gt;(breakBehavior)); }
1194     void setBreakInside(BreakInside breakBehavior) { SET_VAR(m_rareNonInheritedData, breakInside, static_cast&lt;unsigned&gt;(breakBehavior)); }
1195 
1196     void setHangingPunctuation(OptionSet&lt;HangingPunctuation&gt; punctuation) { SET_VAR(m_rareInheritedData, hangingPunctuation, punctuation.toRaw()); }
1197 
1198     // End CSS3 Setters
1199 
<a name="20" id="anc20"></a><span class="line-modified">1200     void setLineGrid(const AtomicString&amp; lineGrid) { SET_VAR(m_rareInheritedData, lineGrid, lineGrid); }</span>
1201     void setLineSnap(LineSnap lineSnap) { SET_VAR(m_rareInheritedData, lineSnap, static_cast&lt;unsigned&gt;(lineSnap)); }
1202     void setLineAlign(LineAlign lineAlign) { SET_VAR(m_rareInheritedData, lineAlign, static_cast&lt;unsigned&gt;(lineAlign)); }
1203 
1204     void setPointerEvents(PointerEvents p) { m_inheritedFlags.pointerEvents = static_cast&lt;unsigned&gt;(p); }
1205 
1206     void clearAnimations();
1207     void clearTransitions();
1208 
1209     void adjustAnimations();
1210     void adjustTransitions();
1211 
1212     void setTransformStyle3D(TransformStyle3D b) { SET_VAR(m_rareNonInheritedData, transformStyle3D, static_cast&lt;unsigned&gt;(b)); }
1213     void setBackfaceVisibility(BackfaceVisibility b) { SET_VAR(m_rareNonInheritedData, backfaceVisibility, static_cast&lt;unsigned&gt;(b)); }
1214     void setPerspective(float p) { SET_VAR(m_rareNonInheritedData, perspective, p); }
1215     void setPerspectiveOriginX(Length&amp;&amp; length) { SET_VAR(m_rareNonInheritedData, perspectiveOriginX, WTFMove(length)); }
1216     void setPerspectiveOriginY(Length&amp;&amp; length) { SET_VAR(m_rareNonInheritedData, perspectiveOriginY, WTFMove(length)); }
1217     void setPageSize(LengthSize size) { SET_VAR(m_rareNonInheritedData, pageSize, WTFMove(size)); }
1218     void setPageSizeType(PageSizeType t) { SET_VAR(m_rareNonInheritedData, pageSizeType, t); }
1219     void resetPageSizeType() { SET_VAR(m_rareNonInheritedData, pageSizeType, PAGE_SIZE_AUTO); }
1220 
1221     void setLineBoxContain(LineBoxContain c) { SET_VAR(m_rareInheritedData, lineBoxContain, c); }
1222     void setLineClamp(LineClampValue c) { SET_VAR(m_rareNonInheritedData, lineClamp, c); }
1223 
1224     void setInitialLetter(const IntSize&amp; size) { SET_VAR(m_rareNonInheritedData, initialLetter, size); }
1225 
1226 #if ENABLE(POINTER_EVENTS)
1227     void setTouchActions(OptionSet&lt;TouchAction&gt; touchActions) { SET_VAR(m_rareNonInheritedData, touchActions, touchActions.toRaw()); }
<a name="21" id="anc21"></a>
1228 #endif
1229 
1230 #if ENABLE(CSS_SCROLL_SNAP)
1231     void setScrollSnapType(const ScrollSnapType&amp;);
1232     void setScrollPaddingTop(Length&amp;&amp;);
1233     void setScrollPaddingBottom(Length&amp;&amp;);
1234     void setScrollPaddingLeft(Length&amp;&amp;);
1235     void setScrollPaddingRight(Length&amp;&amp;);
1236 
1237     void setScrollSnapAlign(const ScrollSnapAlign&amp;);
1238     void setScrollSnapMarginTop(Length&amp;&amp;);
1239     void setScrollSnapMarginBottom(Length&amp;&amp;);
1240     void setScrollSnapMarginLeft(Length&amp;&amp;);
1241     void setScrollSnapMarginRight(Length&amp;&amp;);
1242 #endif
1243 
1244 #if ENABLE(TOUCH_EVENTS)
1245     void setTapHighlightColor(const Color&amp; c) { SET_VAR(m_rareInheritedData, tapHighlightColor, c); }
1246 #endif
1247 
1248 #if PLATFORM(IOS_FAMILY)
1249     void setTouchCalloutEnabled(bool v) { SET_VAR(m_rareInheritedData, touchCalloutEnabled, v); }
1250 #endif
1251 
<a name="22" id="anc22"></a><span class="line-modified">1252 #if ENABLE(ACCELERATED_OVERFLOW_SCROLLING)</span>
1253     void setUseTouchOverflowScrolling(bool v) { SET_VAR(m_rareInheritedData, useTouchOverflowScrolling, v); }
1254 #endif
1255 
1256 #if ENABLE(TEXT_AUTOSIZING)
1257     void setTextSizeAdjust(TextSizeAdjustment adjustment) { SET_VAR(m_rareInheritedData, textSizeAdjust, adjustment); }
<a name="23" id="anc23"></a>
1258 #endif
1259 
1260     void setTextSecurity(TextSecurity security) { SET_VAR(m_rareInheritedData, textSecurity, static_cast&lt;unsigned&gt;(security)); }
1261 
1262 #if ENABLE(CSS_TRAILING_WORD)
1263     void setTrailingWord(TrailingWord) { }
1264 #endif
1265 
1266 #if ENABLE(APPLE_PAY)
1267     void setApplePayButtonStyle(ApplePayButtonStyle style) { SET_VAR(m_rareNonInheritedData, applePayButtonStyle, static_cast&lt;unsigned&gt;(style)); }
1268     void setApplePayButtonType(ApplePayButtonType type) { SET_VAR(m_rareNonInheritedData, applePayButtonType, static_cast&lt;unsigned&gt;(type)); }
1269 #endif
1270 
1271 #if ENABLE(CSS_PAINTING_API)
1272     void addCustomPaintWatchProperty(const String&amp; name);
1273 #endif
1274 
1275     // Support for paint-order, stroke-linecap, stroke-linejoin, and stroke-miterlimit from https://drafts.fxtf.org/paint/.
1276     void setPaintOrder(PaintOrder order) { SET_VAR(m_rareInheritedData, paintOrder, static_cast&lt;unsigned&gt;(order)); }
1277     PaintOrder paintOrder() const { return static_cast&lt;PaintOrder&gt;(m_rareInheritedData-&gt;paintOrder); }
1278     static PaintOrder initialPaintOrder() { return PaintOrder::Normal; }
1279     static Vector&lt;PaintType, 3&gt; paintTypesForPaintOrder(PaintOrder);
1280 
1281     void setCapStyle(LineCap val) { SET_VAR(m_rareInheritedData, capStyle, val); }
1282     LineCap capStyle() const { return static_cast&lt;LineCap&gt;(m_rareInheritedData-&gt;capStyle); }
1283     static LineCap initialCapStyle() { return ButtCap; }
1284 
1285     void setJoinStyle(LineJoin val) { SET_VAR(m_rareInheritedData, joinStyle, val); }
1286     LineJoin joinStyle() const { return static_cast&lt;LineJoin&gt;(m_rareInheritedData-&gt;joinStyle); }
1287     static LineJoin initialJoinStyle() { return MiterJoin; }
1288 
1289     const Length&amp; strokeWidth() const { return m_rareInheritedData-&gt;strokeWidth; }
1290     void setStrokeWidth(Length&amp;&amp; w) { SET_VAR(m_rareInheritedData, strokeWidth, WTFMove(w)); }
1291     bool hasVisibleStroke() const { return svgStyle().hasStroke() &amp;&amp; !strokeWidth().isZero(); }
1292     static Length initialStrokeWidth() { return initialOneLength(); }
1293 
1294     float computedStrokeWidth(const IntSize&amp; viewportSize) const;
1295     void setHasExplicitlySetStrokeWidth(bool v) { SET_VAR(m_rareInheritedData, hasSetStrokeWidth, static_cast&lt;unsigned&gt;(v)); }
1296     bool hasExplicitlySetStrokeWidth() const { return m_rareInheritedData-&gt;hasSetStrokeWidth; };
1297     bool hasPositiveStrokeWidth() const;
1298 
1299     Color strokeColor() const { return m_rareInheritedData-&gt;strokeColor; }
1300     void setStrokeColor(const Color&amp; v)  { SET_VAR(m_rareInheritedData, strokeColor, v); }
1301     void setVisitedLinkStrokeColor(const Color&amp; v) { SET_VAR(m_rareInheritedData, visitedLinkStrokeColor, v); }
1302     const Color&amp; visitedLinkStrokeColor() const { return m_rareInheritedData-&gt;visitedLinkStrokeColor; }
1303     void setHasExplicitlySetStrokeColor(bool v) { SET_VAR(m_rareInheritedData, hasSetStrokeColor, static_cast&lt;unsigned&gt;(v)); }
1304     bool hasExplicitlySetStrokeColor() const { return m_rareInheritedData-&gt;hasSetStrokeColor; };
1305     static Color initialStrokeColor() { return Color(Color::transparent); }
1306     Color computedStrokeColor() const;
1307 
1308     float strokeMiterLimit() const { return m_rareInheritedData-&gt;miterLimit; }
1309     void setStrokeMiterLimit(float f) { SET_VAR(m_rareInheritedData, miterLimit, f); }
1310     static float initialStrokeMiterLimit() { return defaultMiterLimit; }
1311 
1312 
1313     const SVGRenderStyle&amp; svgStyle() const { return m_svgStyle; }
1314     SVGRenderStyle&amp; accessSVGStyle() { return m_svgStyle.access(); }
1315 
1316     SVGPaintType fillPaintType() const { return svgStyle().fillPaintType(); }
1317     Color fillPaintColor() const { return svgStyle().fillPaintColor(); }
1318     void setFillPaintColor(const Color&amp; color) { accessSVGStyle().setFillPaint(SVGPaintType::RGBColor, color, emptyString()); }
1319     float fillOpacity() const { return svgStyle().fillOpacity(); }
1320     void setFillOpacity(float f) { accessSVGStyle().setFillOpacity(f); }
1321 
1322     SVGPaintType strokePaintType() const { return svgStyle().strokePaintType(); }
1323     Color strokePaintColor() const { return svgStyle().strokePaintColor(); }
1324     void setStrokePaintColor(const Color&amp; color) { accessSVGStyle().setStrokePaint(SVGPaintType::RGBColor, color, emptyString()); }
1325     float strokeOpacity() const { return svgStyle().strokeOpacity(); }
1326     void setStrokeOpacity(float f) { accessSVGStyle().setStrokeOpacity(f); }
1327     Vector&lt;SVGLengthValue&gt; strokeDashArray() const { return svgStyle().strokeDashArray(); }
1328     void setStrokeDashArray(Vector&lt;SVGLengthValue&gt; array) { accessSVGStyle().setStrokeDashArray(array); }
1329     const Length&amp; strokeDashOffset() const { return svgStyle().strokeDashOffset(); }
1330     void setStrokeDashOffset(Length&amp;&amp; d) { accessSVGStyle().setStrokeDashOffset(WTFMove(d)); }
1331 
1332     const Length&amp; cx() const { return svgStyle().cx(); }
1333     void setCx(Length&amp;&amp; cx) { accessSVGStyle().setCx(WTFMove(cx)); }
1334     const Length&amp; cy() const { return svgStyle().cy(); }
1335     void setCy(Length&amp;&amp; cy) { accessSVGStyle().setCy(WTFMove(cy)); }
1336     const Length&amp; r() const { return svgStyle().r(); }
1337     void setR(Length&amp;&amp; r) { accessSVGStyle().setR(WTFMove(r)); }
1338     const Length&amp; rx() const { return svgStyle().rx(); }
1339     void setRx(Length&amp;&amp; rx) { accessSVGStyle().setRx(WTFMove(rx)); }
1340     const Length&amp; ry() const { return svgStyle().ry(); }
1341     void setRy(Length&amp;&amp; ry) { accessSVGStyle().setRy(WTFMove(ry)); }
1342     const Length&amp; x() const { return svgStyle().x(); }
1343     void setX(Length&amp;&amp; x) { accessSVGStyle().setX(WTFMove(x)); }
1344     const Length&amp; y() const { return svgStyle().y(); }
1345     void setY(Length&amp;&amp; y) { accessSVGStyle().setY(WTFMove(y)); }
1346 
1347     float floodOpacity() const { return svgStyle().floodOpacity(); }
1348     void setFloodOpacity(float f) { accessSVGStyle().setFloodOpacity(f); }
1349 
1350     float stopOpacity() const { return svgStyle().stopOpacity(); }
1351     void setStopOpacity(float f) { accessSVGStyle().setStopOpacity(f); }
1352 
1353     void setStopColor(const Color&amp; c) { accessSVGStyle().setStopColor(c); }
1354     void setFloodColor(const Color&amp; c) { accessSVGStyle().setFloodColor(c); }
1355     void setLightingColor(const Color&amp; c) { accessSVGStyle().setLightingColor(c); }
1356 
1357     SVGLengthValue baselineShiftValue() const { return svgStyle().baselineShiftValue(); }
1358     void setBaselineShiftValue(SVGLengthValue s) { accessSVGStyle().setBaselineShiftValue(s); }
1359     SVGLengthValue kerning() const { return svgStyle().kerning(); }
1360     void setKerning(SVGLengthValue k) { accessSVGStyle().setKerning(k); }
1361 
1362     void setShapeOutside(RefPtr&lt;ShapeValue&gt;&amp;&amp;);
1363     ShapeValue* shapeOutside() const { return m_rareNonInheritedData-&gt;shapeOutside.get(); }
1364     static ShapeValue* initialShapeOutside() { return nullptr; }
1365 
1366     const Length&amp; shapeMargin() const { return m_rareNonInheritedData-&gt;shapeMargin; }
1367     void setShapeMargin(Length&amp;&amp; shapeMargin) { SET_VAR(m_rareNonInheritedData, shapeMargin, WTFMove(shapeMargin)); }
1368     static Length initialShapeMargin() { return Length(0, Fixed); }
1369 
1370     float shapeImageThreshold() const { return m_rareNonInheritedData-&gt;shapeImageThreshold; }
1371     void setShapeImageThreshold(float);
1372     static float initialShapeImageThreshold() { return 0; }
1373 
1374     void setClipPath(RefPtr&lt;ClipPathOperation&gt;&amp;&amp;);
1375     ClipPathOperation* clipPath() const { return m_rareNonInheritedData-&gt;clipPath.get(); }
1376     static ClipPathOperation* initialClipPath() { return nullptr; }
1377 
1378     bool hasContent() const { return contentData(); }
1379     const ContentData* contentData() const { return m_rareNonInheritedData-&gt;content.get(); }
1380     bool contentDataEquivalent(const RenderStyle* otherStyle) const { return const_cast&lt;RenderStyle*&gt;(this)-&gt;m_rareNonInheritedData-&gt;contentDataEquivalent(*const_cast&lt;RenderStyle*&gt;(otherStyle)-&gt;m_rareNonInheritedData); }
1381     void clearContent();
1382     void setContent(const String&amp;, bool add = false);
1383     void setContent(RefPtr&lt;StyleImage&gt;&amp;&amp;, bool add = false);
1384     void setContent(std::unique_ptr&lt;CounterContent&gt;, bool add = false);
1385     void setContent(QuoteType, bool add = false);
1386     void setContentAltText(const String&amp;);
1387     const String&amp; contentAltText() const;
1388     bool hasAttrContent() const { return m_rareNonInheritedData-&gt;hasAttrContent; }
1389     void setHasAttrContent();
1390 
1391     const CounterDirectiveMap* counterDirectives() const;
1392     CounterDirectiveMap&amp; accessCounterDirectives();
1393 
1394     QuotesData* quotes() const { return m_rareInheritedData-&gt;quotes.get(); }
1395     void setQuotes(RefPtr&lt;QuotesData&gt;&amp;&amp;);
1396 
1397     WillChangeData* willChange() const { return m_rareNonInheritedData-&gt;willChange.get(); }
1398     void setWillChange(RefPtr&lt;WillChangeData&gt;&amp;&amp;);
1399 
1400     bool willChangeCreatesStackingContext() const;
1401 
<a name="24" id="anc24"></a><span class="line-modified">1402     const AtomicString&amp; hyphenString() const;</span>
1403 
1404     bool inheritedNotEqual(const RenderStyle*) const;
1405     bool inheritedDataShared(const RenderStyle*) const;
1406 
1407 #if ENABLE(TEXT_AUTOSIZING)
1408     uint32_t hashForTextAutosizing() const;
1409     bool equalForTextAutosizing(const RenderStyle&amp;) const;
1410 #endif
1411 
1412     StyleDifference diff(const RenderStyle&amp;, OptionSet&lt;StyleDifferenceContextSensitiveProperty&gt;&amp; changedContextSensitiveProperties) const;
1413     bool diffRequiresLayerRepaint(const RenderStyle&amp;, bool isComposited) const;
1414 
1415     bool isDisplayInlineType() const { return isDisplayInlineType(display()); }
1416     bool isOriginalDisplayInlineType() const { return isDisplayInlineType(originalDisplay()); }
1417     bool isDisplayFlexibleOrGridBox() const { return isDisplayFlexibleOrGridBox(display()); }
1418     bool isDisplayRegionType() const;
1419 
1420     bool setWritingMode(WritingMode);
1421 
1422     bool hasExplicitlySetWritingMode() const { return m_nonInheritedFlags.hasExplicitlySetWritingMode; }
1423     void setHasExplicitlySetWritingMode(bool v) { m_nonInheritedFlags.hasExplicitlySetWritingMode = v; }
1424 
1425     bool hasExplicitlySetTextAlign() const { return m_nonInheritedFlags.hasExplicitlySetTextAlign; }
1426     void setHasExplicitlySetTextAlign(bool v) { m_nonInheritedFlags.hasExplicitlySetTextAlign = v; }
1427 
1428     // A unique style is one that has matches something that makes it impossible to share.
1429     bool unique() const { return m_nonInheritedFlags.isUnique; }
1430     void setUnique() { m_nonInheritedFlags.isUnique = true; }
1431 
1432     bool emptyState() const { return m_nonInheritedFlags.emptyState; }
1433     void setEmptyState(bool v) { setUnique(); m_nonInheritedFlags.emptyState = v; }
1434     bool firstChildState() const { return m_nonInheritedFlags.firstChildState; }
1435     void setFirstChildState() { setUnique(); m_nonInheritedFlags.firstChildState = true; }
1436     bool lastChildState() const { return m_nonInheritedFlags.lastChildState; }
1437     void setLastChildState() { setUnique(); m_nonInheritedFlags.lastChildState = true; }
1438 
1439     WEBCORE_EXPORT Color visitedDependentColor(CSSPropertyID) const;
1440     WEBCORE_EXPORT Color visitedDependentColorWithColorFilter(CSSPropertyID) const;
1441 
1442     WEBCORE_EXPORT Color colorByApplyingColorFilter(const Color&amp;) const;
1443 
1444     bool backgroundColorEqualsToColorIgnoringVisited(const Color&amp; color) const { return color == backgroundColor(); }
1445 
1446     void setHasExplicitlyInheritedProperties() { m_nonInheritedFlags.hasExplicitlyInheritedProperties = true; }
1447     bool hasExplicitlyInheritedProperties() const { return m_nonInheritedFlags.hasExplicitlyInheritedProperties; }
1448 
1449     // Initial values for all the properties
1450     static Overflow initialOverflowX() { return Overflow::Visible; }
1451     static Overflow initialOverflowY() { return Overflow::Visible; }
1452     static Clear initialClear() { return Clear::None; }
1453     static DisplayType initialDisplay() { return DisplayType::Inline; }
1454     static EUnicodeBidi initialUnicodeBidi() { return UBNormal; }
1455     static PositionType initialPosition() { return PositionType::Static; }
1456     static VerticalAlign initialVerticalAlign() { return VerticalAlign::Baseline; }
1457     static Float initialFloating() { return Float::No; }
1458     static BreakBetween initialBreakBetween() { return BreakBetween::Auto; }
1459     static BreakInside initialBreakInside() { return BreakInside::Auto; }
1460     static OptionSet&lt;HangingPunctuation&gt; initialHangingPunctuation() { return OptionSet&lt;HangingPunctuation&gt; { }; }
1461     static TableLayoutType initialTableLayout() { return TableLayoutType::Auto; }
1462     static BorderCollapse initialBorderCollapse() { return BorderCollapse::Separate; }
1463     static BorderStyle initialBorderStyle() { return BorderStyle::None; }
1464     static OutlineIsAuto initialOutlineStyleIsAuto() { return OutlineIsAuto::Off; }
1465     static NinePieceImage initialNinePieceImage() { return NinePieceImage(); }
1466     static LengthSize initialBorderRadius() { return { { 0, Fixed }, { 0, Fixed } }; }
1467     static CaptionSide initialCaptionSide() { return CaptionSide::Top; }
1468     static ColumnAxis initialColumnAxis() { return ColumnAxis::Auto; }
1469     static ColumnProgression initialColumnProgression() { return ColumnProgression::Normal; }
1470     static TextDirection initialDirection() { return TextDirection::LTR; }
1471     static WritingMode initialWritingMode() { return TopToBottomWritingMode; }
1472     static TextCombine initialTextCombine() { return TextCombine::None; }
1473     static TextOrientation initialTextOrientation() { return TextOrientation::Mixed; }
1474     static ObjectFit initialObjectFit() { return ObjectFit::Fill; }
1475     static LengthPoint initialObjectPosition() { return LengthPoint(Length(50.0f, Percent), Length(50.0f, Percent)); }
1476     static EmptyCell initialEmptyCells() { return EmptyCell::Show; }
1477     static ListStylePosition initialListStylePosition() { return ListStylePosition::Outside; }
1478     static ListStyleType initialListStyleType() { return ListStyleType::Disc; }
1479     static TextTransform initialTextTransform() { return TextTransform::None; }
1480     static Visibility initialVisibility() { return Visibility::Visible; }
1481     static WhiteSpace initialWhiteSpace() { return WhiteSpace::Normal; }
1482     static float initialHorizontalBorderSpacing() { return 0; }
1483     static float initialVerticalBorderSpacing() { return 0; }
1484     static CursorType initialCursor() { return CursorType::Auto; }
1485     static Color initialColor() { return Color::black; }
1486     static StyleImage* initialListStyleImage() { return 0; }
1487     static float initialBorderWidth() { return 3; }
1488     static unsigned short initialColumnRuleWidth() { return 3; }
1489     static float initialOutlineWidth() { return 3; }
1490     static float initialLetterSpacing() { return 0; }
1491     static Length initialWordSpacing() { return Length(Fixed); }
1492     static Length initialSize() { return Length(); }
1493     static Length initialMinSize() { return Length(); }
1494     static Length initialMaxSize() { return Length(Undefined); }
1495     static Length initialOffset() { return Length(); }
1496     static Length initialMargin() { return Length(Fixed); }
1497     static Length initialPadding() { return Length(Fixed); }
1498     static Length initialTextIndent() { return Length(Fixed); }
1499     static Length initialZeroLength() { return Length(Fixed); }
1500     static Length initialOneLength() { return Length(1, Fixed); }
1501     static short initialWidows() { return 2; }
1502     static short initialOrphans() { return 2; }
1503     static Length initialLineHeight() { return Length(-100.0f, Percent); }
1504     static TextAlignMode initialTextAlign() { return TextAlignMode::Start; }
1505     static OptionSet&lt;TextDecoration&gt; initialTextDecoration() { return OptionSet&lt;TextDecoration&gt; { }; }
1506     static TextDecorationStyle initialTextDecorationStyle() { return TextDecorationStyle::Solid; }
1507     static OptionSet&lt;TextDecorationSkip&gt; initialTextDecorationSkip() { return TextDecorationSkip::Auto; }
1508     static TextUnderlinePosition initialTextUnderlinePosition() { return TextUnderlinePosition::Auto; }
1509     static TextUnderlineOffset initialTextUnderlineOffset() { return TextUnderlineOffset::createWithAuto(); }
1510     static TextDecorationThickness initialTextDecorationThickness() { return TextDecorationThickness::createWithAuto(); }
1511     static float initialZoom() { return 1.0f; }
1512     static TextZoom initialTextZoom() { return TextZoom::Normal; }
1513     static float initialOutlineOffset() { return 0; }
1514     static float initialOpacity() { return 1.0f; }
1515     static BoxAlignment initialBoxAlign() { return BoxAlignment::Stretch; }
1516     static BoxDecorationBreak initialBoxDecorationBreak() { return BoxDecorationBreak::Slice; }
1517     static BoxDirection initialBoxDirection() { return BoxDirection::Normal; }
1518     static BoxLines initialBoxLines() { return BoxLines::Single; }
1519     static BoxOrient initialBoxOrient() { return BoxOrient::Horizontal; }
1520     static BoxPack initialBoxPack() { return BoxPack::Start; }
1521     static float initialBoxFlex() { return 0.0f; }
1522     static unsigned initialBoxFlexGroup() { return 1; }
1523     static unsigned initialBoxOrdinalGroup() { return 1; }
1524     static BoxSizing initialBoxSizing() { return BoxSizing::ContentBox; }
1525     static StyleReflection* initialBoxReflect() { return 0; }
1526     static float initialFlexGrow() { return 0; }
1527     static float initialFlexShrink() { return 1; }
1528     static Length initialFlexBasis() { return Length(Auto); }
1529     static int initialOrder() { return 0; }
1530     static StyleSelfAlignmentData initialJustifyItems() { return StyleSelfAlignmentData(ItemPosition::Legacy, OverflowAlignment::Default); }
1531     static StyleSelfAlignmentData initialSelfAlignment() { return StyleSelfAlignmentData(ItemPosition::Auto, OverflowAlignment::Default); }
1532     static StyleSelfAlignmentData initialDefaultAlignment() { return StyleSelfAlignmentData(ItemPosition::Normal, OverflowAlignment::Default); }
1533     static StyleContentAlignmentData initialContentAlignment() { return StyleContentAlignmentData(ContentPosition::Normal, ContentDistribution::Default, OverflowAlignment::Default); }
1534     static FlexDirection initialFlexDirection() { return FlexDirection::Row; }
1535     static FlexWrap initialFlexWrap() { return FlexWrap::NoWrap; }
1536     static int initialMarqueeLoopCount() { return -1; }
1537     static int initialMarqueeSpeed() { return 85; }
1538     static Length initialMarqueeIncrement() { return Length(6, Fixed); }
1539     static MarqueeBehavior initialMarqueeBehavior() { return MarqueeBehavior::Scroll; }
1540     static MarqueeDirection initialMarqueeDirection() { return MarqueeDirection::Auto; }
1541     static UserModify initialUserModify() { return UserModify::ReadOnly; }
1542     static UserDrag initialUserDrag() { return UserDrag::Auto; }
1543     static UserSelect initialUserSelect() { return UserSelect::Text; }
1544     static TextOverflow initialTextOverflow() { return TextOverflow::Clip; }
1545     static MarginCollapse initialMarginBeforeCollapse() { return MarginCollapse::Collapse; }
1546     static MarginCollapse initialMarginAfterCollapse() { return MarginCollapse::Collapse; }
1547     static WordBreak initialWordBreak() { return WordBreak::Normal; }
1548     static OverflowWrap initialOverflowWrap() { return OverflowWrap::Normal; }
1549     static NBSPMode initialNBSPMode() { return NBSPMode::Normal; }
1550     static LineBreak initialLineBreak() { return LineBreak::Auto; }
1551     static OptionSet&lt;SpeakAs&gt; initialSpeakAs() { return OptionSet&lt;SpeakAs&gt; { }; }
1552     static Hyphens initialHyphens() { return Hyphens::Manual; }
1553     static short initialHyphenationLimitBefore() { return -1; }
1554     static short initialHyphenationLimitAfter() { return -1; }
1555     static short initialHyphenationLimitLines() { return -1; }
<a name="25" id="anc25"></a><span class="line-modified">1556     static const AtomicString&amp; initialHyphenationString() { return nullAtom(); }</span>
1557     static BorderFit initialBorderFit() { return BorderFit::Border; }
1558     static Resize initialResize() { return Resize::None; }
1559     static ControlPart initialAppearance() { return NoControlPart; }
1560     static AspectRatioType initialAspectRatioType() { return AspectRatioType::Auto; }
1561     static float initialAspectRatioDenominator() { return 1; }
1562     static float initialAspectRatioNumerator() { return 1; }
1563     static Order initialRTLOrdering() { return Order::Logical; }
1564     static float initialTextStrokeWidth() { return 0; }
1565     static unsigned short initialColumnCount() { return 1; }
1566     static ColumnFill initialColumnFill() { return ColumnFill::Balance; }
1567     static ColumnSpan initialColumnSpan() { return ColumnSpan::None; }
1568     static GapLength initialColumnGap() { return GapLength(); }
1569     static GapLength initialRowGap() { return GapLength(); }
1570     static const TransformOperations&amp; initialTransform() { static NeverDestroyed&lt;TransformOperations&gt; ops; return ops; }
1571     static Length initialTransformOriginX() { return Length(50.0f, Percent); }
1572     static Length initialTransformOriginY() { return Length(50.0f, Percent); }
1573     static TransformBox initialTransformBox() { return TransformBox::BorderBox; }
1574     static PointerEvents initialPointerEvents() { return PointerEvents::Auto; }
1575     static float initialTransformOriginZ() { return 0; }
1576     static TransformStyle3D initialTransformStyle3D() { return TransformStyle3D::Flat; }
1577     static BackfaceVisibility initialBackfaceVisibility() { return BackfaceVisibility::Visible; }
1578     static float initialPerspective() { return 0; }
1579     static Length initialPerspectiveOriginX() { return Length(50.0f, Percent); }
1580     static Length initialPerspectiveOriginY() { return Length(50.0f, Percent); }
1581     static Color initialBackgroundColor() { return Color::transparent; }
1582     static Color initialTextEmphasisColor() { return Color(); }
1583     static TextEmphasisFill initialTextEmphasisFill() { return TextEmphasisFill::Filled; }
1584     static TextEmphasisMark initialTextEmphasisMark() { return TextEmphasisMark::None; }
<a name="26" id="anc26"></a><span class="line-modified">1585     static const AtomicString&amp; initialTextEmphasisCustomMark() { return nullAtom(); }</span>
1586     static OptionSet&lt;TextEmphasisPosition&gt; initialTextEmphasisPosition() { return { TextEmphasisPosition::Over, TextEmphasisPosition::Right }; }
1587     static RubyPosition initialRubyPosition() { return RubyPosition::Before; }
1588     static LineBoxContain initialLineBoxContain() { return LineBoxContainBlock | LineBoxContainInline | LineBoxContainReplaced; }
<a name="27" id="anc27"></a><span class="line-modified">1589     static ImageOrientationEnum initialImageOrientation() { return OriginTopLeft; }</span>
1590     static ImageRendering initialImageRendering() { return ImageRendering::Auto; }
1591     static ImageResolutionSource initialImageResolutionSource() { return ImageResolutionSource::Specified; }
1592     static ImageResolutionSnap initialImageResolutionSnap() { return ImageResolutionSnap::None; }
1593     static float initialImageResolution() { return 1; }
1594     static StyleImage* initialBorderImageSource() { return nullptr; }
1595     static StyleImage* initialMaskBoxImageSource() { return nullptr; }
1596     static PrintColorAdjust initialPrintColorAdjust() { return PrintColorAdjust::Economy; }
1597     static QuotesData* initialQuotes() { return nullptr; }
<a name="28" id="anc28"></a><span class="line-modified">1598     static const AtomicString&amp; initialContentAltText() { return emptyAtom(); }</span>
1599 
1600 #if ENABLE(DARK_MODE_CSS)
<a name="29" id="anc29"></a><span class="line-modified">1601     static StyleSupportedColorSchemes initialSupportedColorSchemes() { return { }; }</span>
1602 #endif
1603 
1604 #if ENABLE(CSS3_TEXT)
1605     static TextIndentLine initialTextIndentLine() { return TextIndentLine::FirstLine; }
1606     static TextIndentType initialTextIndentType() { return TextIndentType::Normal; }
1607     static TextAlignLast initialTextAlignLast() { return TextAlignLast::Auto; }
1608     static TextJustify initialTextJustify() { return TextJustify::Auto; }
1609 #endif
1610 
1611 #if ENABLE(CURSOR_VISIBILITY)
1612     static CursorVisibility initialCursorVisibility() { return CursorVisibility::Auto; }
1613 #endif
1614 
1615 #if ENABLE(TEXT_AUTOSIZING)
1616     static Length initialSpecifiedLineHeight() { return Length(-100.0f, Percent); }
1617     static TextSizeAdjustment initialTextSizeAdjust() { return TextSizeAdjustment(); }
1618 #endif
1619 
1620     static WillChangeData* initialWillChange() { return nullptr; }
1621 
1622 #if ENABLE(POINTER_EVENTS)
1623     static TouchAction initialTouchActions() { return TouchAction::Auto; }
1624 #endif
1625 
1626 #if ENABLE(CSS_SCROLL_SNAP)
1627     static ScrollSnapType initialScrollSnapType();
1628     static ScrollSnapAlign initialScrollSnapAlign();
1629     static Length initialScrollSnapMargin() { return Length(Fixed); }
1630     static Length initialScrollPadding() { return Length(Fixed); }
1631 #endif
1632 
1633 #if ENABLE(CSS_TRAILING_WORD)
1634     static TrailingWord initialTrailingWord() { return TrailingWord::Auto; }
1635 #endif
1636 
1637 #if ENABLE(APPLE_PAY)
1638     static ApplePayButtonStyle initialApplePayButtonStyle() { return ApplePayButtonStyle::Black; }
1639     static ApplePayButtonType initialApplePayButtonType() { return ApplePayButtonType::Plain; }
1640 #endif
1641 
1642     // The initial value is &#39;none&#39; for grid tracks.
1643     static Vector&lt;GridTrackSize&gt; initialGridColumns() { return Vector&lt;GridTrackSize&gt;(); }
1644     static Vector&lt;GridTrackSize&gt; initialGridRows() { return Vector&lt;GridTrackSize&gt;(); }
1645 
1646     static Vector&lt;GridTrackSize&gt; initialGridAutoRepeatTracks() { return Vector&lt;GridTrackSize&gt;(); }
1647     static unsigned initialGridAutoRepeatInsertionPoint() { return 0; }
1648     static AutoRepeatType initialGridAutoRepeatType() { return AutoRepeatType::None; }
1649 
1650     static GridAutoFlow initialGridAutoFlow() { return AutoFlowRow; }
1651 
1652     static Vector&lt;GridTrackSize&gt; initialGridAutoColumns() { return { GridTrackSize(Length(Auto)) }; }
1653     static Vector&lt;GridTrackSize&gt; initialGridAutoRows() { return { GridTrackSize(Length(Auto)) }; }
1654 
1655     static NamedGridAreaMap initialNamedGridArea() { return NamedGridAreaMap(); }
1656     static size_t initialNamedGridAreaCount() { return 0; }
1657 
1658     static NamedGridLinesMap initialNamedGridColumnLines() { return NamedGridLinesMap(); }
1659     static NamedGridLinesMap initialNamedGridRowLines() { return NamedGridLinesMap(); }
1660 
1661     static OrderedNamedGridLinesMap initialOrderedNamedGridColumnLines() { return OrderedNamedGridLinesMap(); }
1662     static OrderedNamedGridLinesMap initialOrderedNamedGridRowLines() { return OrderedNamedGridLinesMap(); }
1663 
1664     // &#39;auto&#39; is the default.
1665     static GridPosition initialGridItemColumnStart() { return GridPosition(); }
1666     static GridPosition initialGridItemColumnEnd() { return GridPosition(); }
1667     static GridPosition initialGridItemRowStart() { return GridPosition(); }
1668     static GridPosition initialGridItemRowEnd() { return GridPosition(); }
1669 
<a name="30" id="anc30"></a><span class="line-modified">1670     static unsigned initialTabSize() { return 8; }</span>
1671 
<a name="31" id="anc31"></a><span class="line-modified">1672     static const AtomicString&amp; initialLineGrid() { return nullAtom(); }</span>
1673     static LineSnap initialLineSnap() { return LineSnap::None; }
1674     static LineAlign initialLineAlign() { return LineAlign::None; }
1675 
1676     static IntSize initialInitialLetter() { return IntSize(); }
1677     static LineClampValue initialLineClamp() { return LineClampValue(); }
1678     static TextSecurity initialTextSecurity() { return TextSecurity::None; }
1679 
1680 #if PLATFORM(IOS_FAMILY)
1681     static bool initialTouchCalloutEnabled() { return true; }
1682 #endif
1683 
1684 #if ENABLE(TOUCH_EVENTS)
1685     static Color initialTapHighlightColor();
1686 #endif
1687 
<a name="32" id="anc32"></a><span class="line-modified">1688 #if ENABLE(ACCELERATED_OVERFLOW_SCROLLING)</span>
1689     static bool initialUseTouchOverflowScrolling() { return false; }
1690 #endif
1691 
<a name="33" id="anc33"></a><span class="line-removed">1692 #if ENABLE(DASHBOARD_SUPPORT)</span>
<span class="line-removed">1693     static const Vector&lt;StyleDashboardRegion&gt;&amp; initialDashboardRegions();</span>
<span class="line-removed">1694     static const Vector&lt;StyleDashboardRegion&gt;&amp; noneDashboardRegions();</span>
<span class="line-removed">1695 #endif</span>
<span class="line-removed">1696 </span>
1697     static const FilterOperations&amp; initialFilter() { static NeverDestroyed&lt;FilterOperations&gt; ops; return ops; }
1698     static const FilterOperations&amp; initialAppleColorFilter() { static NeverDestroyed&lt;FilterOperations&gt; ops; return ops; }
1699 
1700 #if ENABLE(FILTERS_LEVEL_2)
1701     static const FilterOperations&amp; initialBackdropFilter() { static NeverDestroyed&lt;FilterOperations&gt; ops; return ops; }
1702 #endif
1703 
1704 #if ENABLE(CSS_COMPOSITING)
1705     static BlendMode initialBlendMode() { return BlendMode::Normal; }
1706     static Isolation initialIsolation() { return Isolation::Auto; }
1707 #endif
1708 
1709     // Indicates the style is likely to change due to a pending stylesheet load.
1710     bool isNotFinal() const { return m_rareNonInheritedData-&gt;isNotFinal; }
1711     void setIsNotFinal() { SET_VAR(m_rareNonInheritedData, isNotFinal, true); }
1712 
1713     void setVisitedLinkColor(const Color&amp;);
1714     void setVisitedLinkBackgroundColor(const Color&amp; v) { SET_VAR(m_rareNonInheritedData, visitedLinkBackgroundColor, v); }
1715     void setVisitedLinkBorderLeftColor(const Color&amp; v) { SET_VAR(m_rareNonInheritedData, visitedLinkBorderLeftColor, v); }
1716     void setVisitedLinkBorderRightColor(const Color&amp; v) { SET_VAR(m_rareNonInheritedData, visitedLinkBorderRightColor, v); }
1717     void setVisitedLinkBorderBottomColor(const Color&amp; v) { SET_VAR(m_rareNonInheritedData, visitedLinkBorderBottomColor, v); }
1718     void setVisitedLinkBorderTopColor(const Color&amp; v) { SET_VAR(m_rareNonInheritedData, visitedLinkBorderTopColor, v); }
1719     void setVisitedLinkOutlineColor(const Color&amp; v) { SET_VAR(m_rareNonInheritedData, visitedLinkOutlineColor, v); }
1720     void setVisitedLinkColumnRuleColor(const Color&amp; v) { SET_NESTED_VAR(m_rareNonInheritedData, multiCol, visitedLinkColumnRuleColor, v); }
1721     void setVisitedLinkTextDecorationColor(const Color&amp; v) { SET_VAR(m_rareNonInheritedData, visitedLinkTextDecorationColor, v); }
1722     void setVisitedLinkTextEmphasisColor(const Color&amp; v) { SET_VAR(m_rareInheritedData, visitedLinkTextEmphasisColor, v); }
1723     void setVisitedLinkTextFillColor(const Color&amp; v) { SET_VAR(m_rareInheritedData, visitedLinkTextFillColor, v); }
1724     void setVisitedLinkTextStrokeColor(const Color&amp; v) { SET_VAR(m_rareInheritedData, visitedLinkTextStrokeColor, v); }
1725     void setVisitedLinkCaretColor(const Color&amp; v) { SET_VAR(m_rareInheritedData, visitedLinkCaretColor, v); }
1726 
1727     void inheritUnicodeBidiFrom(const RenderStyle* parent) { m_nonInheritedFlags.unicodeBidi = parent-&gt;m_nonInheritedFlags.unicodeBidi; }
1728     void getShadowExtent(const ShadowData*, LayoutUnit&amp; top, LayoutUnit&amp; right, LayoutUnit&amp; bottom, LayoutUnit&amp; left) const;
1729     void getShadowHorizontalExtent(const ShadowData*, LayoutUnit&amp; left, LayoutUnit&amp; right) const;
1730     void getShadowVerticalExtent(const ShadowData*, LayoutUnit&amp; top, LayoutUnit&amp; bottom) const;
1731     void getShadowInlineDirectionExtent(const ShadowData*, LayoutUnit&amp; logicalLeft, LayoutUnit&amp; logicalRight) const;
1732     void getShadowBlockDirectionExtent(const ShadowData*, LayoutUnit&amp; logicalTop, LayoutUnit&amp; logicalBottom) const;
1733 
1734     static Color invalidColor() { return Color(); }
1735     const Color&amp; borderLeftColor() const { return m_surroundData-&gt;border.left().color(); }
1736     const Color&amp; borderRightColor() const { return m_surroundData-&gt;border.right().color(); }
1737     const Color&amp; borderTopColor() const { return m_surroundData-&gt;border.top().color(); }
1738     const Color&amp; borderBottomColor() const { return m_surroundData-&gt;border.bottom().color(); }
1739     const Color&amp; backgroundColor() const { return m_backgroundData-&gt;color; }
1740     const Color&amp; color() const;
1741     const Color&amp; columnRuleColor() const { return m_rareNonInheritedData-&gt;multiCol-&gt;rule.color(); }
1742     const Color&amp; outlineColor() const { return m_backgroundData-&gt;outline.color(); }
1743     const Color&amp; textEmphasisColor() const { return m_rareInheritedData-&gt;textEmphasisColor; }
1744     const Color&amp; textFillColor() const { return m_rareInheritedData-&gt;textFillColor; }
1745     const Color&amp; textStrokeColor() const { return m_rareInheritedData-&gt;textStrokeColor; }
1746     const Color&amp; caretColor() const { return m_rareInheritedData-&gt;caretColor; }
1747     const Color&amp; visitedLinkColor() const;
1748     const Color&amp; visitedLinkBackgroundColor() const { return m_rareNonInheritedData-&gt;visitedLinkBackgroundColor; }
1749     const Color&amp; visitedLinkBorderLeftColor() const { return m_rareNonInheritedData-&gt;visitedLinkBorderLeftColor; }
1750     const Color&amp; visitedLinkBorderRightColor() const { return m_rareNonInheritedData-&gt;visitedLinkBorderRightColor; }
1751     const Color&amp; visitedLinkBorderBottomColor() const { return m_rareNonInheritedData-&gt;visitedLinkBorderBottomColor; }
1752     const Color&amp; visitedLinkBorderTopColor() const { return m_rareNonInheritedData-&gt;visitedLinkBorderTopColor; }
1753     const Color&amp; visitedLinkOutlineColor() const { return m_rareNonInheritedData-&gt;visitedLinkOutlineColor; }
1754     const Color&amp; visitedLinkColumnRuleColor() const { return m_rareNonInheritedData-&gt;multiCol-&gt;visitedLinkColumnRuleColor; }
1755     const Color&amp; textDecorationColor() const { return m_rareNonInheritedData-&gt;textDecorationColor; }
1756     const Color&amp; visitedLinkTextDecorationColor() const { return m_rareNonInheritedData-&gt;visitedLinkTextDecorationColor; }
1757     const Color&amp; visitedLinkTextEmphasisColor() const { return m_rareInheritedData-&gt;visitedLinkTextEmphasisColor; }
1758     const Color&amp; visitedLinkTextFillColor() const { return m_rareInheritedData-&gt;visitedLinkTextFillColor; }
1759     const Color&amp; visitedLinkTextStrokeColor() const { return m_rareInheritedData-&gt;visitedLinkTextStrokeColor; }
1760     const Color&amp; visitedLinkCaretColor() const { return m_rareInheritedData-&gt;visitedLinkCaretColor; }
1761 
1762     const Color&amp; stopColor() const { return svgStyle().stopColor(); }
1763     const Color&amp; floodColor() const { return svgStyle().floodColor(); }
1764     const Color&amp; lightingColor() const { return svgStyle().lightingColor(); }
1765 
1766 private:
1767     struct NonInheritedFlags {
1768         bool operator==(const NonInheritedFlags&amp;) const;
1769         bool operator!=(const NonInheritedFlags&amp; other) const { return !(*this == other); }
1770 
1771         void copyNonInheritedFrom(const NonInheritedFlags&amp;);
1772 
1773         bool hasAnyPublicPseudoStyles() const { return static_cast&lt;unsigned&gt;(PseudoId::PublicPseudoIdMask) &amp; pseudoBits; }
1774         bool hasPseudoStyle(PseudoId) const;
1775         void setHasPseudoStyle(PseudoId);
1776         void setHasPseudoStyles(PseudoIdSet);
1777 
1778         unsigned effectiveDisplay : 5; // DisplayType
1779         unsigned originalDisplay : 5; // DisplayType
1780         unsigned overflowX : 3; // Overflow
1781         unsigned overflowY : 3; // Overflow
1782         unsigned verticalAlign : 4; // VerticalAlign
1783         unsigned clear : 2; // Clear
1784         unsigned position : 3; // PositionType
1785         unsigned unicodeBidi : 3; // EUnicodeBidi
1786         unsigned floating : 2; // Float
1787         unsigned tableLayout : 1; // TableLayoutType
1788 
1789         unsigned hasExplicitlySetDirection : 1;
1790         unsigned hasExplicitlySetWritingMode : 1;
1791         unsigned hasExplicitlySetTextAlign : 1;
1792 #if ENABLE(DARK_MODE_CSS)
<a name="34" id="anc34"></a><span class="line-modified">1793         unsigned hasExplicitlySetSupportedColorSchemes : 1;</span>
1794 #endif
1795         unsigned hasViewportUnits : 1;
1796         unsigned hasExplicitlyInheritedProperties : 1; // Explicitly inherits a non-inherited property.
1797         unsigned isUnique : 1; // Style cannot be shared.
1798         unsigned emptyState : 1;
1799         unsigned firstChildState : 1;
1800         unsigned lastChildState : 1;
1801         unsigned affectedByHover : 1;
1802         unsigned affectedByActive : 1;
1803         unsigned affectedByDrag : 1;
1804         unsigned isLink : 1;
1805 
1806         unsigned styleType : 4; // PseudoId
1807         unsigned pseudoBits : (static_cast&lt;unsigned&gt;(PseudoId::FirstInternalPseudoId) - static_cast&lt;unsigned&gt;(PseudoId::FirstPublicPseudoId));
1808 
1809         // If you add more style bits here, you will also need to update RenderStyle::NonInheritedFlags::copyNonInheritedFrom().
1810     };
1811 
1812     struct InheritedFlags {
1813         bool operator==(const InheritedFlags&amp;) const;
1814         bool operator!=(const InheritedFlags&amp; other) const { return !(*this == other); }
1815 
1816         unsigned emptyCells : 1; // EmptyCell
1817         unsigned captionSide : 2; // CaptionSide
1818         unsigned listStyleType : 7; // ListStyleType
1819         unsigned listStylePosition : 1; // ListStylePosition
1820         unsigned visibility : 2; // Visibility
1821         unsigned textAlign : 4; // TextAlignMode
1822         unsigned textTransform : 2; // TextTransform
1823         unsigned textDecorations : TextDecorationBits;
1824         unsigned cursor : 6; // CursorType
1825 #if ENABLE(CURSOR_VISIBILITY)
1826         unsigned cursorVisibility : 1; // CursorVisibility
1827 #endif
1828         unsigned direction : 1; // TextDirection
1829         unsigned whiteSpace : 3; // WhiteSpace
1830         // 35 bits
1831         unsigned borderCollapse : 1; // BorderCollapse
1832         unsigned boxDirection : 1; // BoxDirection
1833 
1834         // non CSS2 inherited
1835         unsigned rtlOrdering : 1; // Order
1836         unsigned printColorAdjust : PrintColorAdjustBits; // PrintColorAdjust
1837         unsigned pointerEvents : 4; // PointerEvents
1838         unsigned insideLink : 2; // InsideLink
1839         unsigned insideDefaultButton : 1;
1840         // 46 bits
1841 
1842         // CSS Text Layout Module Level 3: Vertical writing support
1843         unsigned writingMode : 2; // WritingMode
1844         // 48 bits
<a name="35" id="anc35"></a>




1845     };
1846 
1847     // This constructor is used to implement the replace operation.
1848     RenderStyle(RenderStyle&amp;, RenderStyle&amp;&amp;);
1849 
1850     DisplayType originalDisplay() const { return static_cast&lt;DisplayType&gt;(m_nonInheritedFlags.originalDisplay); }
1851 
1852     bool hasAutoLeftAndRight() const { return left().isAuto() &amp;&amp; right().isAuto(); }
1853     bool hasAutoTopAndBottom() const { return top().isAuto() &amp;&amp; bottom().isAuto(); }
1854 
1855     void setContent(std::unique_ptr&lt;ContentData&gt;, bool add);
1856 
1857     LayoutBoxExtent getShadowInsetExtent(const ShadowData*) const;
1858 
1859     static bool isDisplayReplacedType(DisplayType);
1860     static bool isDisplayInlineType(DisplayType);
1861     static bool isDisplayFlexibleBox(DisplayType);
1862     static bool isDisplayGridBox(DisplayType);
1863     static bool isDisplayFlexibleOrGridBox(DisplayType);
1864 
1865     Color colorIncludingFallback(CSSPropertyID colorProperty, bool visitedLink) const;
1866 
1867     bool changeAffectsVisualOverflow(const RenderStyle&amp;) const;
1868     bool changeRequiresLayout(const RenderStyle&amp;, OptionSet&lt;StyleDifferenceContextSensitiveProperty&gt;&amp; changedContextSensitiveProperties) const;
1869     bool changeRequiresPositionedLayoutOnly(const RenderStyle&amp;, OptionSet&lt;StyleDifferenceContextSensitiveProperty&gt;&amp; changedContextSensitiveProperties) const;
1870     bool changeRequiresLayerRepaint(const RenderStyle&amp;, OptionSet&lt;StyleDifferenceContextSensitiveProperty&gt;&amp; changedContextSensitiveProperties) const;
1871     bool changeRequiresRepaint(const RenderStyle&amp;, OptionSet&lt;StyleDifferenceContextSensitiveProperty&gt;&amp; changedContextSensitiveProperties) const;
1872     bool changeRequiresRepaintIfTextOrBorderOrOutline(const RenderStyle&amp;, OptionSet&lt;StyleDifferenceContextSensitiveProperty&gt;&amp; changedContextSensitiveProperties) const;
1873     bool changeRequiresRecompositeLayer(const RenderStyle&amp;, OptionSet&lt;StyleDifferenceContextSensitiveProperty&gt;&amp; changedContextSensitiveProperties) const;
1874 
1875     // non-inherited attributes
1876     DataRef&lt;StyleBoxData&gt; m_boxData;
1877     DataRef&lt;StyleVisualData&gt; m_visualData;
1878     DataRef&lt;StyleBackgroundData&gt; m_backgroundData;
1879     DataRef&lt;StyleSurroundData&gt; m_surroundData;
1880     DataRef&lt;StyleRareNonInheritedData&gt; m_rareNonInheritedData;
1881     NonInheritedFlags m_nonInheritedFlags;
1882 
1883     // inherited attributes
1884     DataRef&lt;StyleRareInheritedData&gt; m_rareInheritedData;
1885     DataRef&lt;StyleInheritedData&gt; m_inheritedData;
1886     InheritedFlags m_inheritedFlags;
1887 
1888     // list of associated pseudo styles
1889     std::unique_ptr&lt;PseudoStyleCache&gt; m_cachedPseudoStyles;
1890 
1891     DataRef&lt;SVGRenderStyle&gt; m_svgStyle;
1892 
1893 #if !ASSERT_DISABLED || ENABLE(SECURITY_ASSERTIONS)
1894     bool m_deletionHasBegun { false };
1895 #endif
1896 };
1897 
1898 int adjustForAbsoluteZoom(int, const RenderStyle&amp;);
1899 float adjustFloatForAbsoluteZoom(float, const RenderStyle&amp;);
1900 LayoutUnit adjustLayoutUnitForAbsoluteZoom(LayoutUnit, const RenderStyle&amp;);
1901 
1902 BorderStyle collapsedBorderStyle(BorderStyle);
1903 
1904 bool pseudoElementRendererIsNeeded(const RenderStyle*);
1905 
1906 inline bool RenderStyle::NonInheritedFlags::operator==(const NonInheritedFlags&amp; other) const
1907 {
1908     return effectiveDisplay == other.effectiveDisplay
1909         &amp;&amp; originalDisplay == other.originalDisplay
1910         &amp;&amp; overflowX == other.overflowX
1911         &amp;&amp; overflowY == other.overflowY
1912         &amp;&amp; verticalAlign == other.verticalAlign
1913         &amp;&amp; clear == other.clear
1914         &amp;&amp; position == other.position
1915         &amp;&amp; unicodeBidi == other.unicodeBidi
1916         &amp;&amp; floating == other.floating
1917         &amp;&amp; tableLayout == other.tableLayout
1918         &amp;&amp; hasExplicitlySetDirection == other.hasExplicitlySetDirection
1919         &amp;&amp; hasExplicitlySetWritingMode == other.hasExplicitlySetWritingMode
1920         &amp;&amp; hasExplicitlySetTextAlign == other.hasExplicitlySetTextAlign
1921 #if ENABLE(DARK_MODE_CSS)
<a name="36" id="anc36"></a><span class="line-modified">1922         &amp;&amp; hasExplicitlySetSupportedColorSchemes == other.hasExplicitlySetSupportedColorSchemes</span>
1923 #endif
1924         &amp;&amp; hasViewportUnits == other.hasViewportUnits
1925         &amp;&amp; hasExplicitlyInheritedProperties == other.hasExplicitlyInheritedProperties
1926         &amp;&amp; isUnique == other.isUnique
1927         &amp;&amp; emptyState == other.emptyState
1928         &amp;&amp; firstChildState == other.firstChildState
1929         &amp;&amp; lastChildState == other.lastChildState
1930         &amp;&amp; affectedByHover == other.affectedByHover
1931         &amp;&amp; affectedByActive == other.affectedByActive
1932         &amp;&amp; affectedByDrag == other.affectedByDrag
1933         &amp;&amp; isLink == other.isLink
1934         &amp;&amp; styleType == other.styleType
1935         &amp;&amp; pseudoBits == other.pseudoBits;
1936 }
1937 
1938 inline void RenderStyle::NonInheritedFlags::copyNonInheritedFrom(const NonInheritedFlags&amp; other)
1939 {
1940     // Only a subset is copied because NonInheritedFlags contains a bunch of stuff other than real style data.
1941     effectiveDisplay = other.effectiveDisplay;
1942     originalDisplay = other.originalDisplay;
1943     overflowX = other.overflowX;
1944     overflowY = other.overflowY;
1945     verticalAlign = other.verticalAlign;
1946     clear = other.clear;
1947     position = other.position;
1948     unicodeBidi = other.unicodeBidi;
1949     floating = other.floating;
1950     tableLayout = other.tableLayout;
1951     hasViewportUnits = other.hasViewportUnits;
1952     hasExplicitlyInheritedProperties = other.hasExplicitlyInheritedProperties;
1953 }
1954 
1955 inline bool RenderStyle::NonInheritedFlags::hasPseudoStyle(PseudoId pseudo) const
1956 {
1957     ASSERT(pseudo &gt; PseudoId::None);
1958     ASSERT(pseudo &lt; PseudoId::FirstInternalPseudoId);
1959     return pseudoBits &amp; (1 &lt;&lt; (static_cast&lt;unsigned&gt;(pseudo) - 1 /* PseudoId::None */));
1960 }
1961 
1962 inline void RenderStyle::NonInheritedFlags::setHasPseudoStyle(PseudoId pseudo)
1963 {
1964     ASSERT(pseudo &gt; PseudoId::None);
1965     ASSERT(pseudo &lt; PseudoId::FirstInternalPseudoId);
1966     pseudoBits |= 1 &lt;&lt; (static_cast&lt;unsigned&gt;(pseudo) - 1 /* PseudoId::None */);
1967 }
1968 
1969 inline void RenderStyle::NonInheritedFlags::setHasPseudoStyles(PseudoIdSet pseudoIdSet)
1970 {
1971     ASSERT(pseudoIdSet);
1972     ASSERT((pseudoIdSet.data() &amp; static_cast&lt;unsigned&gt;(PseudoId::PublicPseudoIdMask)) == pseudoIdSet.data());
1973     pseudoBits |= pseudoIdSet.data() &gt;&gt; 1; // Shift down as we do not store a bit for PseudoId::None.
1974 }
1975 
1976 inline bool RenderStyle::InheritedFlags::operator==(const InheritedFlags&amp; other) const
1977 {
1978     return emptyCells == other.emptyCells
1979         &amp;&amp; captionSide == other.captionSide
1980         &amp;&amp; listStyleType == other.listStyleType
1981         &amp;&amp; listStylePosition == other.listStylePosition
1982         &amp;&amp; visibility == other.visibility
1983         &amp;&amp; textAlign == other.textAlign
1984         &amp;&amp; textTransform == other.textTransform
1985         &amp;&amp; textDecorations == other.textDecorations
1986         &amp;&amp; cursor == other.cursor
1987 #if ENABLE(CURSOR_VISIBILITY)
1988         &amp;&amp; cursorVisibility == other.cursorVisibility
1989 #endif
1990         &amp;&amp; direction == other.direction
1991         &amp;&amp; whiteSpace == other.whiteSpace
1992         &amp;&amp; borderCollapse == other.borderCollapse
1993         &amp;&amp; boxDirection == other.boxDirection
1994         &amp;&amp; rtlOrdering == other.rtlOrdering
1995         &amp;&amp; printColorAdjust == other.printColorAdjust
1996         &amp;&amp; pointerEvents == other.pointerEvents
1997         &amp;&amp; insideLink == other.insideLink
1998         &amp;&amp; insideDefaultButton == other.insideDefaultButton
1999         &amp;&amp; writingMode == other.writingMode;
2000 }
2001 
2002 inline int adjustForAbsoluteZoom(int value, const RenderStyle&amp; style)
2003 {
2004     double zoomFactor = style.effectiveZoom();
2005     if (zoomFactor == 1)
2006         return value;
2007     // Needed because computeLengthInt truncates (rather than rounds) when scaling up.
2008     if (zoomFactor &gt; 1) {
2009         if (value &lt; 0)
2010             value--;
2011         else
2012             value++;
2013     }
2014 
2015     return roundForImpreciseConversion&lt;int&gt;(value / zoomFactor);
2016 }
2017 
2018 inline float adjustFloatForAbsoluteZoom(float value, const RenderStyle&amp; style)
2019 {
2020     return value / style.effectiveZoom();
2021 }
2022 
2023 inline LayoutUnit adjustLayoutUnitForAbsoluteZoom(LayoutUnit value, const RenderStyle&amp; style)
2024 {
<a name="37" id="anc37"></a><span class="line-modified">2025     return value / style.effectiveZoom();</span>
2026 }
2027 
2028 inline BorderStyle collapsedBorderStyle(BorderStyle style)
2029 {
2030     if (style == BorderStyle::Outset)
2031         return BorderStyle::Groove;
2032     if (style == BorderStyle::Inset)
2033         return BorderStyle::Ridge;
2034     return style;
2035 }
2036 
<a name="38" id="anc38"></a><span class="line-modified">2037 inline const CSSCustomPropertyValue* RenderStyle::getCustomProperty(const AtomicString&amp; name) const</span>
2038 {
2039     for (auto* map : { &amp;nonInheritedCustomProperties(), &amp;inheritedCustomProperties() }) {
2040         if (auto* val = map-&gt;get(name))
2041             return val;
2042     }
2043     return nullptr;
2044 }
2045 
2046 inline bool RenderStyle::hasBackground() const
2047 {
2048     return visitedDependentColor(CSSPropertyBackgroundColor).isVisible() ||  hasBackgroundImage();
2049 }
2050 
2051 inline bool RenderStyle::autoWrap(WhiteSpace whiteSpace)
2052 {
2053     // Nowrap and pre don&#39;t automatically wrap.
2054     return whiteSpace != WhiteSpace::NoWrap &amp;&amp; whiteSpace != WhiteSpace::Pre;
2055 }
2056 
2057 inline bool RenderStyle::preserveNewline(WhiteSpace whiteSpace)
2058 {
2059     // Normal and nowrap do not preserve newlines.
2060     return whiteSpace != WhiteSpace::Normal &amp;&amp; whiteSpace != WhiteSpace::NoWrap;
2061 }
2062 
2063 inline bool RenderStyle::collapseWhiteSpace(WhiteSpace ws)
2064 {
2065     // Pre and prewrap do not collapse whitespace.
<a name="39" id="anc39"></a><span class="line-modified">2066     return ws != WhiteSpace::Pre &amp;&amp; ws != WhiteSpace::PreWrap;</span>
2067 }
2068 
2069 inline bool RenderStyle::isCollapsibleWhiteSpace(UChar character) const
2070 {
2071     switch (character) {
2072     case &#39; &#39;:
2073     case &#39;\t&#39;:
2074         return collapseWhiteSpace();
2075     case &#39;\n&#39;:
2076         return !preserveNewline();
2077     default:
2078         return false;
2079     }
2080 }
2081 
2082 inline bool RenderStyle::breakOnlyAfterWhiteSpace() const
2083 {
<a name="40" id="anc40"></a><span class="line-modified">2084     return whiteSpace() == WhiteSpace::PreWrap || lineBreak() == LineBreak::AfterWhiteSpace;</span>
2085 }
2086 
2087 inline bool RenderStyle::breakWords() const
2088 {
2089     return wordBreak() == WordBreak::BreakWord || overflowWrap() == OverflowWrap::Break;
2090 }
2091 
2092 inline bool RenderStyle::hasInlineColumnAxis() const
2093 {
2094     auto axis = columnAxis();
2095     return axis == ColumnAxis::Auto || isHorizontalWritingMode() == (axis == ColumnAxis::Horizontal);
2096 }
2097 
<a name="41" id="anc41"></a><span class="line-modified">2098 inline ImageOrientationEnum RenderStyle::imageOrientation() const</span>
2099 {
2100 #if ENABLE(CSS_IMAGE_ORIENTATION)
<a name="42" id="anc42"></a><span class="line-modified">2101     return static_cast&lt;ImageOrientationEnum&gt;(m_rareInheritedData-&gt;imageOrientation);</span>
2102 #else
<a name="43" id="anc43"></a><span class="line-modified">2103     return DefaultImageOrientation;</span>
2104 #endif
2105 }
2106 
2107 inline void RenderStyle::setLogicalWidth(Length&amp;&amp; logicalWidth)
2108 {
2109     if (isHorizontalWritingMode())
2110         setWidth(WTFMove(logicalWidth));
2111     else
2112         setHeight(WTFMove(logicalWidth));
2113 }
2114 
2115 inline void RenderStyle::setLogicalHeight(Length&amp;&amp; logicalHeight)
2116 {
2117     if (isHorizontalWritingMode())
2118         setHeight(WTFMove(logicalHeight));
2119     else
2120         setWidth(WTFMove(logicalHeight));
2121 }
2122 
2123 inline void RenderStyle::setBorderRadius(LengthSize&amp;&amp; size)
2124 {
2125     auto topLeft = size;
2126     setBorderTopLeftRadius(WTFMove(topLeft));
2127     auto topRight = size;
2128     setBorderTopRightRadius(WTFMove(topRight));
2129     auto bottomLeft = size;
2130     setBorderBottomLeftRadius(WTFMove(bottomLeft));
2131     setBorderBottomRightRadius(WTFMove(size));
2132 }
2133 
2134 inline void RenderStyle::setBorderRadius(const IntSize&amp; size)
2135 {
2136     setBorderRadius(LengthSize { { size.width(), Fixed }, { size.height(), Fixed } });
2137 }
2138 
2139 inline bool RenderStyle::setZoom(float zoomLevel)
2140 {
2141     setEffectiveZoom(effectiveZoom() * zoomLevel);
2142     if (compareEqual(m_visualData-&gt;zoom, zoomLevel))
2143         return false;
2144     m_visualData.access().zoom = zoomLevel;
2145     return true;
2146 }
2147 
2148 inline bool RenderStyle::setEffectiveZoom(float zoomLevel)
2149 {
2150     if (compareEqual(m_rareInheritedData-&gt;effectiveZoom, zoomLevel))
2151         return false;
2152     m_rareInheritedData.access().effectiveZoom = zoomLevel;
2153     return true;
2154 }
2155 
2156 inline bool RenderStyle::setTextOrientation(TextOrientation textOrientation)
2157 {
2158     if (compareEqual(static_cast&lt;TextOrientation&gt;(m_rareInheritedData-&gt;textOrientation), textOrientation))
2159         return false;
2160     m_rareInheritedData.access().textOrientation = static_cast&lt;unsigned&gt;(textOrientation);
2161     return true;
2162 }
2163 
2164 inline void RenderStyle::adjustBackgroundLayers()
2165 {
2166     if (backgroundLayers().next()) {
2167         ensureBackgroundLayers().cullEmptyLayers();
2168         ensureBackgroundLayers().fillUnsetProperties();
2169     }
2170 }
2171 
2172 inline void RenderStyle::adjustMaskLayers()
2173 {
2174     if (maskLayers().next()) {
2175         ensureMaskLayers().cullEmptyLayers();
2176         ensureMaskLayers().fillUnsetProperties();
2177     }
2178 }
2179 
2180 inline void RenderStyle::clearAnimations()
2181 {
2182     m_rareNonInheritedData.access().animations = nullptr;
2183 }
2184 
2185 inline void RenderStyle::clearTransitions()
2186 {
2187     m_rareNonInheritedData.access().transitions = nullptr;
2188 }
2189 
2190 inline void RenderStyle::setShapeOutside(RefPtr&lt;ShapeValue&gt;&amp;&amp; value)
2191 {
2192     if (m_rareNonInheritedData-&gt;shapeOutside == value)
2193         return;
2194     m_rareNonInheritedData.access().shapeOutside = WTFMove(value);
2195 }
2196 
2197 inline void RenderStyle::setShapeImageThreshold(float shapeImageThreshold)
2198 {
2199     float clampedShapeImageThreshold = clampTo&lt;float&gt;(shapeImageThreshold, 0.f, 1.f);
2200     SET_VAR(m_rareNonInheritedData, shapeImageThreshold, clampedShapeImageThreshold);
2201 }
2202 
2203 inline void RenderStyle::setClipPath(RefPtr&lt;ClipPathOperation&gt;&amp;&amp; operation)
2204 {
2205     if (m_rareNonInheritedData-&gt;clipPath != operation)
2206         m_rareNonInheritedData.access().clipPath = WTFMove(operation);
2207 }
2208 
2209 inline bool RenderStyle::willChangeCreatesStackingContext() const
2210 {
2211     return willChange() &amp;&amp; willChange()-&gt;canCreateStackingContext();
2212 }
2213 
2214 inline bool RenderStyle::isDisplayRegionType() const
2215 {
2216     return display() == DisplayType::Block || display() == DisplayType::InlineBlock
2217         || display() == DisplayType::TableCell || display() == DisplayType::TableCaption
2218         || display() == DisplayType::ListItem;
2219 }
2220 
2221 inline bool RenderStyle::setWritingMode(WritingMode v)
2222 {
2223     if (v == writingMode())
2224         return false;
2225     m_inheritedFlags.writingMode = v;
2226     return true;
2227 }
2228 
2229 inline void RenderStyle::getShadowInlineDirectionExtent(const ShadowData* shadow, LayoutUnit&amp; logicalLeft, LayoutUnit&amp; logicalRight) const
2230 {
2231     return isHorizontalWritingMode() ? getShadowHorizontalExtent(shadow, logicalLeft, logicalRight) : getShadowVerticalExtent(shadow, logicalLeft, logicalRight);
2232 }
2233 
2234 inline void RenderStyle::getShadowBlockDirectionExtent(const ShadowData* shadow, LayoutUnit&amp; logicalTop, LayoutUnit&amp; logicalBottom) const
2235 {
2236     return isHorizontalWritingMode() ? getShadowVerticalExtent(shadow, logicalTop, logicalBottom) : getShadowHorizontalExtent(shadow, logicalTop, logicalBottom);
2237 }
2238 
2239 inline bool RenderStyle::isDisplayReplacedType(DisplayType display)
2240 {
2241     return display == DisplayType::InlineBlock || display == DisplayType::InlineBox || display == DisplayType::InlineFlex
2242         || display == DisplayType::InlineGrid || display == DisplayType::InlineTable;
2243 }
2244 
2245 inline bool RenderStyle::isDisplayInlineType(DisplayType display)
2246 {
2247     return display == DisplayType::Inline || isDisplayReplacedType(display);
2248 }
2249 
2250 inline bool RenderStyle::isDisplayFlexibleBox(DisplayType display)
2251 {
2252     return display == DisplayType::Flex || display == DisplayType::InlineFlex;
2253 }
2254 
2255 inline bool RenderStyle::isDisplayGridBox(DisplayType display)
2256 {
2257     return display == DisplayType::Grid || display == DisplayType::InlineGrid;
2258 }
2259 
2260 inline bool RenderStyle::isDisplayFlexibleOrGridBox(DisplayType display)
2261 {
2262     return isDisplayFlexibleBox(display) || isDisplayGridBox(display);
2263 }
2264 
2265 inline bool RenderStyle::hasAnyPublicPseudoStyles() const
2266 {
2267     return m_nonInheritedFlags.hasAnyPublicPseudoStyles();
2268 }
2269 
2270 inline bool RenderStyle::hasPseudoStyle(PseudoId pseudo) const
2271 {
2272     return m_nonInheritedFlags.hasPseudoStyle(pseudo);
2273 }
2274 
2275 inline void RenderStyle::setHasPseudoStyle(PseudoId pseudo)
2276 {
2277     m_nonInheritedFlags.setHasPseudoStyle(pseudo);
2278 }
2279 
2280 inline void RenderStyle::setHasPseudoStyles(PseudoIdSet pseudoIdSet)
2281 {
2282     m_nonInheritedFlags.setHasPseudoStyles(pseudoIdSet);
2283 }
2284 
2285 inline void RenderStyle::setBoxReflect(RefPtr&lt;StyleReflection&gt;&amp;&amp; reflect)
2286 {
2287     SET_VAR(m_rareNonInheritedData, boxReflect, WTFMove(reflect));
2288 }
2289 
2290 inline bool pseudoElementRendererIsNeeded(const RenderStyle* style)
2291 {
2292     return style &amp;&amp; style-&gt;display() != DisplayType::None &amp;&amp; style-&gt;contentData();
2293 }
2294 
2295 } // namespace WebCore
<a name="44" id="anc44"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="44" type="hidden" />
</body>
</html>