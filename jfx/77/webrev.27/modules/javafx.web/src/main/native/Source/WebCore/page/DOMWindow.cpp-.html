<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.web/src/main/native/Source/WebCore/page/DOMWindow.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (C) 2006-2017 Apple Inc. All rights reserved.
   3  * Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies)
   4  *
   5  * Redistribution and use in source and binary forms, with or without
   6  * modification, are permitted provided that the following conditions
   7  * are met:
   8  * 1. Redistributions of source code must retain the above copyright
   9  *    notice, this list of conditions and the following disclaimer.
  10  * 2. Redistributions in binary form must reproduce the above copyright
  11  *    notice, this list of conditions and the following disclaimer in the
  12  *    documentation and/or other materials provided with the distribution.
  13  *
  14  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  15  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  16  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  17  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  18  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  19  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  20  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  21  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  22  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  23  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  24  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  25  */
  26 
  27 #include &quot;config.h&quot;
  28 #include &quot;DOMWindow.h&quot;
  29 
  30 #include &quot;BackForwardController.h&quot;
  31 #include &quot;BarProp.h&quot;
  32 #include &quot;CSSComputedStyleDeclaration.h&quot;
  33 #include &quot;CSSRule.h&quot;
  34 #include &quot;CSSRuleList.h&quot;
  35 #include &quot;Chrome.h&quot;
  36 #include &quot;ChromeClient.h&quot;
  37 #include &quot;ComposedTreeIterator.h&quot;
  38 #include &quot;ContentExtensionActions.h&quot;
  39 #include &quot;ContentExtensionRule.h&quot;
  40 #include &quot;Crypto.h&quot;
  41 #include &quot;CustomElementRegistry.h&quot;
  42 #include &quot;DOMApplicationCache.h&quot;
  43 #include &quot;DOMSelection.h&quot;
  44 #include &quot;DOMStringList.h&quot;
  45 #include &quot;DOMTimer.h&quot;
  46 #include &quot;DOMTokenList.h&quot;
  47 #include &quot;DOMURL.h&quot;
  48 #include &quot;DOMWindowExtension.h&quot;
  49 #include &quot;DeviceMotionController.h&quot;
  50 #include &quot;DeviceOrientationController.h&quot;
  51 #include &quot;Document.h&quot;
  52 #include &quot;DocumentLoader.h&quot;
  53 #include &quot;Editor.h&quot;
  54 #include &quot;Element.h&quot;
  55 #include &quot;EventHandler.h&quot;
  56 #include &quot;EventListener.h&quot;
  57 #include &quot;EventNames.h&quot;
  58 #include &quot;FloatRect.h&quot;
  59 #include &quot;FocusController.h&quot;
  60 #include &quot;Frame.h&quot;
  61 #include &quot;FrameLoadRequest.h&quot;
  62 #include &quot;FrameLoader.h&quot;
  63 #include &quot;FrameLoaderClient.h&quot;
  64 #include &quot;FrameTree.h&quot;
  65 #include &quot;FrameView.h&quot;
  66 #include &quot;HTTPParsers.h&quot;
  67 #include &quot;History.h&quot;
  68 #include &quot;InspectorInstrumentation.h&quot;
  69 #include &quot;JSDOMWindowBase.h&quot;
  70 #include &quot;JSExecState.h&quot;
  71 #include &quot;Location.h&quot;
  72 #include &quot;MediaQueryList.h&quot;
  73 #include &quot;MediaQueryMatcher.h&quot;
  74 #include &quot;MessageEvent.h&quot;
  75 #include &quot;MessageWithMessagePorts.h&quot;
  76 #include &quot;NavigationScheduler.h&quot;
  77 #include &quot;Navigator.h&quot;
  78 #include &quot;Page.h&quot;
  79 #include &quot;PageConsoleClient.h&quot;
  80 #include &quot;PageTransitionEvent.h&quot;
  81 #include &quot;Performance.h&quot;
  82 #include &quot;RequestAnimationFrameCallback.h&quot;
  83 #include &quot;ResourceLoadInfo.h&quot;
  84 #include &quot;ResourceLoadObserver.h&quot;
  85 #include &quot;RuntimeApplicationChecks.h&quot;
  86 #include &quot;RuntimeEnabledFeatures.h&quot;
  87 #include &quot;ScheduledAction.h&quot;
  88 #include &quot;Screen.h&quot;
  89 #include &quot;SecurityOrigin.h&quot;
  90 #include &quot;SecurityOriginData.h&quot;
  91 #include &quot;SecurityPolicy.h&quot;
  92 #include &quot;SelectorQuery.h&quot;
  93 #include &quot;SerializedScriptValue.h&quot;
  94 #include &quot;Settings.h&quot;
  95 #include &quot;StaticNodeList.h&quot;
  96 #include &quot;Storage.h&quot;
  97 #include &quot;StorageArea.h&quot;
  98 #include &quot;StorageNamespace.h&quot;
  99 #include &quot;StorageNamespaceProvider.h&quot;
 100 #include &quot;StyleMedia.h&quot;
 101 #include &quot;StyleResolver.h&quot;
 102 #include &quot;StyleScope.h&quot;
 103 #include &quot;SuddenTermination.h&quot;
 104 #include &lt;wtf/URL.h&gt;
 105 #include &quot;UserGestureIndicator.h&quot;
 106 #include &quot;VisualViewport.h&quot;
 107 #include &quot;WebKitPoint.h&quot;
 108 #include &quot;WindowFeatures.h&quot;
 109 #include &quot;WindowFocusAllowedIndicator.h&quot;
 110 #include &quot;WindowProxy.h&quot;
 111 #include &lt;JavaScriptCore/ScriptCallStack.h&gt;
 112 #include &lt;JavaScriptCore/ScriptCallStackFactory.h&gt;
 113 #include &lt;algorithm&gt;
 114 #include &lt;memory&gt;
 115 #include &lt;wtf/Language.h&gt;
 116 #include &lt;wtf/MainThread.h&gt;
 117 #include &lt;wtf/MathExtras.h&gt;
 118 #include &lt;wtf/NeverDestroyed.h&gt;
 119 #include &lt;wtf/Ref.h&gt;
 120 #include &lt;wtf/Variant.h&gt;
 121 #include &lt;wtf/text/WTFString.h&gt;
 122 
 123 #if ENABLE(USER_MESSAGE_HANDLERS)
 124 #include &quot;UserContentController.h&quot;
 125 #include &quot;UserMessageHandlerDescriptor.h&quot;
 126 #include &quot;WebKitNamespace.h&quot;
 127 #endif
 128 
 129 #if ENABLE(GAMEPAD)
 130 #include &quot;GamepadManager.h&quot;
 131 #endif
 132 
 133 #if ENABLE(GEOLOCATION)
 134 #include &quot;NavigatorGeolocation.h&quot;
 135 #endif
 136 
 137 #if ENABLE(POINTER_LOCK)
 138 #include &quot;PointerLockController.h&quot;
 139 #endif
 140 
 141 #if PLATFORM(IOS_FAMILY)
 142 #include &quot;WKContentObservation.h&quot;
 143 #include &quot;WKContentObservationInternal.h&quot;
 144 #endif
 145 
 146 
 147 namespace WebCore {
 148 using namespace Inspector;
 149 
 150 class PostMessageTimer : public TimerBase {
 151 public:
 152     PostMessageTimer(DOMWindow&amp; window, MessageWithMessagePorts&amp;&amp; message, const String&amp; sourceOrigin, RefPtr&lt;WindowProxy&gt;&amp;&amp; source, RefPtr&lt;SecurityOrigin&gt;&amp;&amp; targetOrigin, RefPtr&lt;ScriptCallStack&gt;&amp;&amp; stackTrace)
 153         : m_window(window)
 154         , m_message(WTFMove(message))
 155         , m_origin(sourceOrigin)
 156         , m_source(source)
 157         , m_targetOrigin(WTFMove(targetOrigin))
 158         , m_stackTrace(stackTrace)
 159         , m_userGestureToForward(UserGestureIndicator::currentUserGesture())
 160     {
 161     }
 162 
 163     Ref&lt;MessageEvent&gt; event(ScriptExecutionContext&amp; context)
 164     {
 165         return MessageEvent::create(MessagePort::entanglePorts(context, WTFMove(m_message.transferredPorts)), m_message.message.releaseNonNull(), m_origin, { }, m_source ? makeOptional(MessageEventSource(WTFMove(m_source))) : WTF::nullopt);
 166     }
 167 
 168     SecurityOrigin* targetOrigin() const { return m_targetOrigin.get(); }
 169     ScriptCallStack* stackTrace() const { return m_stackTrace.get(); }
 170 
 171 private:
 172     void fired() override
 173     {
 174         // This object gets deleted when std::unique_ptr falls out of scope..
 175         std::unique_ptr&lt;PostMessageTimer&gt; timer(this);
 176 
 177         UserGestureIndicator userGestureIndicator(m_userGestureToForward);
 178         m_window-&gt;postMessageTimerFired(*timer);
 179     }
 180 
 181     Ref&lt;DOMWindow&gt; m_window;
 182     MessageWithMessagePorts m_message;
 183     String m_origin;
 184     RefPtr&lt;WindowProxy&gt; m_source;
 185     RefPtr&lt;SecurityOrigin&gt; m_targetOrigin;
 186     RefPtr&lt;ScriptCallStack&gt; m_stackTrace;
 187     RefPtr&lt;UserGestureToken&gt; m_userGestureToForward;
 188 };
 189 
 190 typedef HashCountedSet&lt;DOMWindow*&gt; DOMWindowSet;
 191 
 192 static DOMWindowSet&amp; windowsWithUnloadEventListeners()
 193 {
 194     static NeverDestroyed&lt;DOMWindowSet&gt; windowsWithUnloadEventListeners;
 195     return windowsWithUnloadEventListeners;
 196 }
 197 
 198 static DOMWindowSet&amp; windowsWithBeforeUnloadEventListeners()
 199 {
 200     static NeverDestroyed&lt;DOMWindowSet&gt; windowsWithBeforeUnloadEventListeners;
 201     return windowsWithBeforeUnloadEventListeners;
 202 }
 203 
 204 static void addUnloadEventListener(DOMWindow* domWindow)
 205 {
 206     if (windowsWithUnloadEventListeners().add(domWindow).isNewEntry)
 207         domWindow-&gt;disableSuddenTermination();
 208 }
 209 
 210 static void removeUnloadEventListener(DOMWindow* domWindow)
 211 {
 212     if (windowsWithUnloadEventListeners().remove(domWindow))
 213         domWindow-&gt;enableSuddenTermination();
 214 }
 215 
 216 static void removeAllUnloadEventListeners(DOMWindow* domWindow)
 217 {
 218     if (windowsWithUnloadEventListeners().removeAll(domWindow))
 219         domWindow-&gt;enableSuddenTermination();
 220 }
 221 
 222 static void addBeforeUnloadEventListener(DOMWindow* domWindow)
 223 {
 224     if (windowsWithBeforeUnloadEventListeners().add(domWindow).isNewEntry)
 225         domWindow-&gt;disableSuddenTermination();
 226 }
 227 
 228 static void removeBeforeUnloadEventListener(DOMWindow* domWindow)
 229 {
 230     if (windowsWithBeforeUnloadEventListeners().remove(domWindow))
 231         domWindow-&gt;enableSuddenTermination();
 232 }
 233 
 234 static void removeAllBeforeUnloadEventListeners(DOMWindow* domWindow)
 235 {
 236     if (windowsWithBeforeUnloadEventListeners().removeAll(domWindow))
 237         domWindow-&gt;enableSuddenTermination();
 238 }
 239 
 240 static bool allowsBeforeUnloadListeners(DOMWindow* window)
 241 {
 242     ASSERT_ARG(window, window);
 243     Frame* frame = window-&gt;frame();
 244     if (!frame)
 245         return false;
 246     if (!frame-&gt;page())
 247         return false;
 248     return frame-&gt;isMainFrame();
 249 }
 250 
 251 bool DOMWindow::dispatchAllPendingBeforeUnloadEvents()
 252 {
 253     DOMWindowSet&amp; set = windowsWithBeforeUnloadEventListeners();
 254     if (set.isEmpty())
 255         return true;
 256 
 257     static bool alreadyDispatched = false;
 258     ASSERT(!alreadyDispatched);
 259     if (alreadyDispatched)
 260         return true;
 261 
 262     Vector&lt;Ref&lt;DOMWindow&gt;&gt; windows;
 263     windows.reserveInitialCapacity(set.size());
 264     for (auto&amp; window : set)
 265         windows.uncheckedAppend(*window.key);
 266 
 267     for (auto&amp; window : windows) {
 268         if (!set.contains(window.ptr()))
 269             continue;
 270 
 271         Frame* frame = window-&gt;frame();
 272         if (!frame)
 273             continue;
 274 
 275         if (!frame-&gt;loader().shouldClose())
 276             return false;
 277 
 278         window-&gt;enableSuddenTermination();
 279     }
 280 
 281     alreadyDispatched = true;
 282     return true;
 283 }
 284 
 285 unsigned DOMWindow::pendingUnloadEventListeners() const
 286 {
 287     return windowsWithUnloadEventListeners().count(const_cast&lt;DOMWindow*&gt;(this));
 288 }
 289 
 290 void DOMWindow::dispatchAllPendingUnloadEvents()
 291 {
 292     DOMWindowSet&amp; set = windowsWithUnloadEventListeners();
 293     if (set.isEmpty())
 294         return;
 295 
 296     static bool alreadyDispatched = false;
 297     ASSERT(!alreadyDispatched);
 298     if (alreadyDispatched)
 299         return;
 300 
 301     auto windows = WTF::map(set, [] (auto&amp; keyValue) {
 302         return Ref&lt;DOMWindow&gt;(*(keyValue.key));
 303     });
 304 
 305     for (auto&amp; window : windows) {
 306         if (!set.contains(window.ptr()))
 307             continue;
 308 
 309         window-&gt;dispatchEvent(PageTransitionEvent::create(eventNames().pagehideEvent, false), window-&gt;document());
 310         window-&gt;dispatchEvent(Event::create(eventNames().unloadEvent, Event::CanBubble::No, Event::IsCancelable::No), window-&gt;document());
 311 
 312         window-&gt;enableSuddenTermination();
 313     }
 314 
 315     alreadyDispatched = true;
 316 }
 317 
 318 // This function:
 319 // 1) Validates the pending changes are not changing any value to NaN; in that case keep original value.
 320 // 2) Constrains the window rect to the minimum window size and no bigger than the float rect&#39;s dimensions.
 321 // 3) Constrains the window rect to within the top and left boundaries of the available screen rect.
 322 // 4) Constrains the window rect to within the bottom and right boundaries of the available screen rect.
 323 // 5) Translate the window rect coordinates to be within the coordinate space of the screen.
 324 FloatRect DOMWindow::adjustWindowRect(Page&amp; page, const FloatRect&amp; pendingChanges)
 325 {
 326     FloatRect screen = screenAvailableRect(page.mainFrame().view());
 327     FloatRect window = page.chrome().windowRect();
 328 
 329     // Make sure we&#39;re in a valid state before adjusting dimensions.
 330     ASSERT(std::isfinite(screen.x()));
 331     ASSERT(std::isfinite(screen.y()));
 332     ASSERT(std::isfinite(screen.width()));
 333     ASSERT(std::isfinite(screen.height()));
 334     ASSERT(std::isfinite(window.x()));
 335     ASSERT(std::isfinite(window.y()));
 336     ASSERT(std::isfinite(window.width()));
 337     ASSERT(std::isfinite(window.height()));
 338 
 339     // Update window values if new requested values are not NaN.
 340     if (!std::isnan(pendingChanges.x()))
 341         window.setX(pendingChanges.x());
 342     if (!std::isnan(pendingChanges.y()))
 343         window.setY(pendingChanges.y());
 344     if (!std::isnan(pendingChanges.width()))
 345         window.setWidth(pendingChanges.width());
 346     if (!std::isnan(pendingChanges.height()))
 347         window.setHeight(pendingChanges.height());
 348 
 349     FloatSize minimumSize = page.chrome().client().minimumWindowSize();
 350     window.setWidth(std::min(std::max(minimumSize.width(), window.width()), screen.width()));
 351     window.setHeight(std::min(std::max(minimumSize.height(), window.height()), screen.height()));
 352 
 353     // Constrain the window position within the valid screen area.
 354     window.setX(std::max(screen.x(), std::min(window.x(), screen.maxX() - window.width())));
 355     window.setY(std::max(screen.y(), std::min(window.y(), screen.maxY() - window.height())));
 356 
 357     return window;
 358 }
 359 
 360 bool DOMWindow::allowPopUp(Frame&amp; firstFrame)
 361 {
 362     if (DocumentLoader* documentLoader = firstFrame.loader().documentLoader()) {
 363         // If pop-up policy was set during navigation, use it. If not, use the global settings.
 364         PopUpPolicy popUpPolicy = documentLoader-&gt;popUpPolicy();
 365         if (popUpPolicy == PopUpPolicy::Allow)
 366             return true;
 367 
 368         if (popUpPolicy == PopUpPolicy::Block)
 369             return false;
 370     }
 371 
 372     return UserGestureIndicator::processingUserGesture()
 373         || firstFrame.settings().javaScriptCanOpenWindowsAutomatically();
 374 }
 375 
 376 bool DOMWindow::allowPopUp()
 377 {
 378     auto* frame = this-&gt;frame();
 379     return frame &amp;&amp; allowPopUp(*frame);
 380 }
 381 
 382 bool DOMWindow::canShowModalDialog(const Frame&amp; frame)
 383 {
 384     // Override support for layout testing purposes.
 385     if (auto* document = frame.document()) {
 386         if (auto* window = document-&gt;domWindow()) {
 387             if (window-&gt;m_canShowModalDialogOverride)
 388                 return window-&gt;m_canShowModalDialogOverride.value();
 389         }
 390     }
 391 
 392     auto* page = frame.page();
 393     return page &amp;&amp; page-&gt;chrome().canRunModal();
 394 }
 395 
 396 static void languagesChangedCallback(void* context)
 397 {
 398     static_cast&lt;DOMWindow*&gt;(context)-&gt;languagesChanged();
 399 }
 400 
 401 void DOMWindow::setCanShowModalDialogOverride(bool allow)
 402 {
 403     m_canShowModalDialogOverride = allow;
 404 }
 405 
 406 DOMWindow::DOMWindow(Document&amp; document)
 407     : AbstractDOMWindow(GlobalWindowIdentifier { Process::identifier(), WindowIdentifier::generate() })
 408     , ContextDestructionObserver(&amp;document)
 409 {
 410     ASSERT(frame());
 411     addLanguageChangeObserver(this, &amp;languagesChangedCallback);
 412 }
 413 
 414 void DOMWindow::didSecureTransitionTo(Document&amp; document)
 415 {
 416     observeContext(&amp;document);
 417 }
 418 
 419 DOMWindow::~DOMWindow()
 420 {
 421     if (m_suspendedForDocumentSuspension)
 422         willDestroyCachedFrame();
 423     else
 424         willDestroyDocumentInFrame();
 425 
 426     removeAllUnloadEventListeners(this);
 427     removeAllBeforeUnloadEventListeners(this);
 428 
 429 #if ENABLE(GAMEPAD)
 430     if (m_gamepadEventListenerCount)
 431         GamepadManager::singleton().unregisterDOMWindow(this);
 432 #endif
 433 
 434     removeLanguageChangeObserver(this);
 435 }
 436 
 437 RefPtr&lt;MediaQueryList&gt; DOMWindow::matchMedia(const String&amp; media)
 438 {
 439     return document() ? document()-&gt;mediaQueryMatcher().matchMedia(media) : nullptr;
 440 }
 441 
 442 Page* DOMWindow::page()
 443 {
 444     return frame() ? frame()-&gt;page() : nullptr;
 445 }
 446 
 447 void DOMWindow::frameDestroyed()
 448 {
 449     Ref&lt;DOMWindow&gt; protectedThis(*this);
 450 
 451     willDestroyDocumentInFrame();
 452     JSDOMWindowBase::fireFrameClearedWatchpointsForWindow(this);
 453 }
 454 
 455 void DOMWindow::willDestroyCachedFrame()
 456 {
 457     // It is necessary to copy m_properties to a separate vector because the DOMWindowProperties may
 458     // unregister themselves from the DOMWindow as a result of the call to willDestroyGlobalObjectInCachedFrame.
 459     for (auto* property : copyToVector(m_properties)) {
 460         if (m_properties.contains(property))
 461         property-&gt;willDestroyGlobalObjectInCachedFrame();
 462     }
 463 }
 464 
 465 void DOMWindow::willDestroyDocumentInFrame()
 466 {
 467     // It is necessary to copy m_properties to a separate vector because the DOMWindowProperties may
 468     // unregister themselves from the DOMWindow as a result of the call to willDestroyGlobalObjectInFrame.
 469     for (auto* property : copyToVector(m_properties)) {
 470         if (m_properties.contains(property))
 471         property-&gt;willDestroyGlobalObjectInFrame();
 472     }
 473 }
 474 
 475 void DOMWindow::willDetachDocumentFromFrame()
 476 {
 477     if (!frame())
 478         return;
 479 
 480     // It is necessary to copy m_properties to a separate vector because the DOMWindowProperties may
 481     // unregister themselves from the DOMWindow as a result of the call to willDetachGlobalObjectFromFrame.
 482     for (auto&amp; property : copyToVector(m_properties)) {
 483         if (m_properties.contains(property))
 484         property-&gt;willDetachGlobalObjectFromFrame();
 485     }
 486 
 487     if (m_performance)
 488         m_performance-&gt;clearResourceTimings();
 489 
 490     JSDOMWindowBase::fireFrameClearedWatchpointsForWindow(this);
 491     InspectorInstrumentation::frameWindowDiscarded(*frame(), this);
 492 }
 493 
 494 #if ENABLE(GAMEPAD)
 495 
 496 void DOMWindow::incrementGamepadEventListenerCount()
 497 {
 498     if (++m_gamepadEventListenerCount == 1)
 499         GamepadManager::singleton().registerDOMWindow(this);
 500 }
 501 
 502 void DOMWindow::decrementGamepadEventListenerCount()
 503 {
 504     ASSERT(m_gamepadEventListenerCount);
 505 
 506     if (!--m_gamepadEventListenerCount)
 507         GamepadManager::singleton().unregisterDOMWindow(this);
 508 }
 509 
 510 #endif
 511 
 512 void DOMWindow::registerProperty(DOMWindowProperty&amp; property)
 513 {
 514     m_properties.add(&amp;property);
 515 }
 516 
 517 void DOMWindow::unregisterProperty(DOMWindowProperty&amp; property)
 518 {
 519     m_properties.remove(&amp;property);
 520 }
 521 
 522 void DOMWindow::resetUnlessSuspendedForDocumentSuspension()
 523 {
 524     if (m_suspendedForDocumentSuspension)
 525         return;
 526     willDestroyDocumentInFrame();
 527     resetDOMWindowProperties();
 528 }
 529 
 530 void DOMWindow::suspendForPageCache()
 531 {
 532     for (auto* property : copyToVector(m_properties)) {
 533         if (m_properties.contains(property))
 534         property-&gt;suspendForPageCache();
 535     }
 536 
 537     m_suspendedForDocumentSuspension = true;
 538 }
 539 
 540 void DOMWindow::resumeFromPageCache()
 541 {
 542     for (auto* property : copyToVector(m_properties)) {
 543         if (m_properties.contains(property))
 544         property-&gt;resumeFromPageCache();
 545     }
 546 
 547     m_suspendedForDocumentSuspension = false;
 548 }
 549 
 550 void DOMWindow::resetDOMWindowProperties()
 551 {
 552     m_properties.clear();
 553 
 554     m_applicationCache = nullptr;
 555     m_crypto = nullptr;
 556     m_history = nullptr;
 557     m_localStorage = nullptr;
 558     m_location = nullptr;
 559     m_locationbar = nullptr;
 560     m_media = nullptr;
 561     m_menubar = nullptr;
 562     m_navigator = nullptr;
 563     m_personalbar = nullptr;
 564     m_screen = nullptr;
 565     m_scrollbars = nullptr;
 566     m_selection = nullptr;
 567     m_sessionStorage = nullptr;
 568     m_statusbar = nullptr;
 569     m_toolbar = nullptr;
 570     m_performance = nullptr;
 571     m_visualViewport = nullptr;
 572 }
 573 
 574 bool DOMWindow::isCurrentlyDisplayedInFrame() const
 575 {
 576     auto* frame = this-&gt;frame();
 577     return frame &amp;&amp; frame-&gt;document()-&gt;domWindow() == this;
 578 }
 579 
 580 CustomElementRegistry&amp; DOMWindow::ensureCustomElementRegistry()
 581 {
 582     if (!m_customElementRegistry)
 583         m_customElementRegistry = CustomElementRegistry::create(*this, scriptExecutionContext());
 584     return *m_customElementRegistry;
 585 }
 586 
 587 static ExceptionOr&lt;SelectorQuery&amp;&gt; selectorQueryInFrame(Frame* frame, const String&amp; selectors)
 588 {
 589     if (!frame)
 590         return Exception { NotSupportedError };
 591 
 592     Document* document = frame-&gt;document();
 593     if (!document)
 594         return Exception { NotSupportedError };
 595 
 596     return document-&gt;selectorQueryForString(selectors);
 597 }
 598 
 599 ExceptionOr&lt;Ref&lt;NodeList&gt;&gt; DOMWindow::collectMatchingElementsInFlatTree(Node&amp; scope, const String&amp; selectors)
 600 {
 601     auto queryOrException = selectorQueryInFrame(frame(), selectors);
 602     if (queryOrException.hasException())
 603         return queryOrException.releaseException();
 604 
 605     if (!is&lt;ContainerNode&gt;(scope))
 606         return Ref&lt;NodeList&gt; { StaticElementList::create() };
 607 
 608     SelectorQuery&amp; query = queryOrException.releaseReturnValue();
 609 
 610     Vector&lt;Ref&lt;Element&gt;&gt; result;
 611     for (auto&amp; node : composedTreeDescendants(downcast&lt;ContainerNode&gt;(scope))) {
 612         if (is&lt;Element&gt;(node) &amp;&amp; query.matches(downcast&lt;Element&gt;(node)) &amp;&amp; !node.isInUserAgentShadowTree())
 613             result.append(downcast&lt;Element&gt;(node));
 614     }
 615 
 616     return Ref&lt;NodeList&gt; { StaticElementList::create(WTFMove(result)) };
 617 }
 618 
 619 ExceptionOr&lt;RefPtr&lt;Element&gt;&gt; DOMWindow::matchingElementInFlatTree(Node&amp; scope, const String&amp; selectors)
 620 {
 621     auto queryOrException = selectorQueryInFrame(frame(), selectors);
 622     if (queryOrException.hasException())
 623         return queryOrException.releaseException();
 624 
 625     if (!is&lt;ContainerNode&gt;(scope))
 626         return RefPtr&lt;Element&gt; { nullptr };
 627 
 628     SelectorQuery&amp; query = queryOrException.releaseReturnValue();
 629 
 630     for (auto&amp; node : composedTreeDescendants(downcast&lt;ContainerNode&gt;(scope))) {
 631         if (is&lt;Element&gt;(node) &amp;&amp; query.matches(downcast&lt;Element&gt;(node)) &amp;&amp; !node.isInUserAgentShadowTree())
 632             return &amp;downcast&lt;Element&gt;(node);
 633     }
 634 
 635     return RefPtr&lt;Element&gt; { nullptr };
 636 }
 637 
 638 #if ENABLE(ORIENTATION_EVENTS)
 639 
 640 int DOMWindow::orientation() const
 641 {
 642     auto* frame = this-&gt;frame();
 643     if (!frame)
 644         return 0;
 645 
 646     return frame-&gt;orientation();
 647 }
 648 
 649 #endif
 650 
 651 Screen&amp; DOMWindow::screen()
 652 {
 653     if (!m_screen)
 654         m_screen = Screen::create(*this);
 655     return *m_screen;
 656 }
 657 
 658 History&amp; DOMWindow::history()
 659 {
 660     if (!m_history)
 661         m_history = History::create(*this);
 662     return *m_history;
 663 }
 664 
 665 Crypto&amp; DOMWindow::crypto() const
 666 {
 667     if (!m_crypto)
 668         m_crypto = Crypto::create(document());
 669     return *m_crypto;
 670 }
 671 
 672 BarProp&amp; DOMWindow::locationbar()
 673 {
 674     if (!m_locationbar)
 675         m_locationbar = BarProp::create(*this, BarProp::Locationbar);
 676     return *m_locationbar;
 677 }
 678 
 679 BarProp&amp; DOMWindow::menubar()
 680 {
 681     if (!m_menubar)
 682         m_menubar = BarProp::create(*this, BarProp::Menubar);
 683     return *m_menubar;
 684 }
 685 
 686 BarProp&amp; DOMWindow::personalbar()
 687 {
 688     if (!m_personalbar)
 689         m_personalbar = BarProp::create(*this, BarProp::Personalbar);
 690     return *m_personalbar;
 691 }
 692 
 693 BarProp&amp; DOMWindow::scrollbars()
 694 {
 695     if (!m_scrollbars)
 696         m_scrollbars = BarProp::create(*this, BarProp::Scrollbars);
 697     return *m_scrollbars;
 698 }
 699 
 700 BarProp&amp; DOMWindow::statusbar()
 701 {
 702     if (!m_statusbar)
 703         m_statusbar = BarProp::create(*this, BarProp::Statusbar);
 704     return *m_statusbar;
 705 }
 706 
 707 BarProp&amp; DOMWindow::toolbar()
 708 {
 709     if (!m_toolbar)
 710         m_toolbar = BarProp::create(*this, BarProp::Toolbar);
 711     return *m_toolbar;
 712 }
 713 
 714 PageConsoleClient* DOMWindow::console() const
 715 {
 716     // FIXME: This should not return nullptr when frameless.
 717     if (!isCurrentlyDisplayedInFrame())
 718         return nullptr;
 719     auto* frame = this-&gt;frame();
 720     return frame-&gt;page() ? &amp;frame-&gt;page()-&gt;console() : nullptr;
 721 }
 722 
 723 DOMApplicationCache&amp; DOMWindow::applicationCache()
 724 {
 725     if (!m_applicationCache)
 726         m_applicationCache = DOMApplicationCache::create(*this);
 727     return *m_applicationCache;
 728 }
 729 
 730 Navigator&amp; DOMWindow::navigator()
 731 {
 732     if (!m_navigator)
 733         m_navigator = Navigator::create(scriptExecutionContext(), *this);
 734 
 735     return *m_navigator;
 736 }
 737 
 738 Performance&amp; DOMWindow::performance() const
 739 {
 740     if (!m_performance) {
 741         MonotonicTime timeOrigin = document() &amp;&amp; document()-&gt;loader() ? document()-&gt;loader()-&gt;timing().referenceMonotonicTime() : MonotonicTime::now();
 742         m_performance = Performance::create(document(), timeOrigin);
 743     }
 744     return *m_performance;
 745 }
 746 
 747 double DOMWindow::nowTimestamp() const
 748 {
 749     return performance().now() / 1000.;
 750 }
 751 
 752 Location&amp; DOMWindow::location()
 753 {
 754     if (!m_location)
 755         m_location = Location::create(*this);
 756     return *m_location;
 757 }
 758 
 759 VisualViewport&amp; DOMWindow::visualViewport()
 760 {
 761     if (!m_visualViewport)
 762         m_visualViewport = VisualViewport::create(*this);
 763     return *m_visualViewport;
 764 }
 765 
 766 #if ENABLE(USER_MESSAGE_HANDLERS)
 767 
 768 bool DOMWindow::shouldHaveWebKitNamespaceForWorld(DOMWrapperWorld&amp; world)
 769 {
 770     auto* frame = this-&gt;frame();
 771     if (!frame)
 772         return false;
 773 
 774     auto* page = frame-&gt;page();
 775     if (!page)
 776         return false;
 777 
 778     bool hasUserMessageHandler = false;
 779     page-&gt;userContentProvider().forEachUserMessageHandler([&amp;](const UserMessageHandlerDescriptor&amp; descriptor) {
 780         if (&amp;descriptor.world() == &amp;world) {
 781             hasUserMessageHandler = true;
 782             return;
 783         }
 784     });
 785 
 786     return hasUserMessageHandler;
 787 }
 788 
 789 WebKitNamespace* DOMWindow::webkitNamespace()
 790 {
 791     if (!isCurrentlyDisplayedInFrame())
 792         return nullptr;
 793     auto* page = frame()-&gt;page();
 794     if (!page)
 795         return nullptr;
 796     if (!m_webkitNamespace)
 797         m_webkitNamespace = WebKitNamespace::create(*this, page-&gt;userContentProvider());
 798     return m_webkitNamespace.get();
 799 }
 800 
 801 #endif
 802 
 803 ExceptionOr&lt;Storage*&gt; DOMWindow::sessionStorage()
 804 {
 805     if (!isCurrentlyDisplayedInFrame())
 806         return nullptr;
 807 
 808     auto* document = this-&gt;document();
 809     if (!document)
 810         return nullptr;
 811 
 812     if (!document-&gt;securityOrigin().canAccessSessionStorage(document-&gt;topOrigin()))
 813         return Exception { SecurityError };
 814 
 815     if (m_sessionStorage)
 816         return m_sessionStorage.get();
 817 
 818     auto* page = document-&gt;page();
 819     if (!page)
 820         return nullptr;
 821 
 822     auto storageArea = page-&gt;sessionStorage()-&gt;storageArea(document-&gt;securityOrigin().data());
 823     m_sessionStorage = Storage::create(*this, WTFMove(storageArea));
 824     return m_sessionStorage.get();
 825 }
 826 
 827 ExceptionOr&lt;Storage*&gt; DOMWindow::localStorage()
 828 {
 829     if (!isCurrentlyDisplayedInFrame())
 830         return nullptr;
 831 
 832     auto* document = this-&gt;document();
 833     if (!document)
 834         return nullptr;
 835 
 836     if (!document-&gt;securityOrigin().canAccessLocalStorage(nullptr))
 837         return Exception { SecurityError };
 838 
 839     auto* page = document-&gt;page();
 840     // FIXME: We should consider supporting access/modification to local storage
 841     // after calling window.close(). See &lt;https://bugs.webkit.org/show_bug.cgi?id=135330&gt;.
 842     if (!page || !page-&gt;isClosing()) {
 843         if (m_localStorage)
 844             return m_localStorage.get();
 845     }
 846 
 847     if (!page)
 848         return nullptr;
 849 
 850     if (page-&gt;isClosing())
 851         return nullptr;
 852 
 853     if (!page-&gt;settings().localStorageEnabled())
 854         return nullptr;
 855 
 856     auto storageArea = page-&gt;storageNamespaceProvider().localStorageArea(*document);
 857     m_localStorage = Storage::create(*this, WTFMove(storageArea));
 858     return m_localStorage.get();
 859 }
 860 
 861 ExceptionOr&lt;void&gt; DOMWindow::postMessage(JSC::ExecState&amp; state, DOMWindow&amp; incumbentWindow, JSC::JSValue messageValue, const String&amp; targetOrigin, Vector&lt;JSC::Strong&lt;JSC::JSObject&gt;&gt;&amp;&amp; transfer)
 862 {
 863     if (!isCurrentlyDisplayedInFrame())
 864         return { };
 865 
 866     Document* sourceDocument = incumbentWindow.document();
 867 
 868     // Compute the target origin.  We need to do this synchronously in order
 869     // to generate the SyntaxError exception correctly.
 870     RefPtr&lt;SecurityOrigin&gt; target;
 871     if (targetOrigin == &quot;/&quot;) {
 872         if (!sourceDocument)
 873             return { };
 874         target = &amp;sourceDocument-&gt;securityOrigin();
 875     } else if (targetOrigin != &quot;*&quot;) {
 876         target = SecurityOrigin::createFromString(targetOrigin);
 877         // It doesn&#39;t make sense target a postMessage at a unique origin
 878         // because there&#39;s no way to represent a unique origin in a string.
 879         if (target-&gt;isUnique())
 880             return Exception { SyntaxError };
 881     }
 882 
 883     Vector&lt;RefPtr&lt;MessagePort&gt;&gt; ports;
 884     auto messageData = SerializedScriptValue::create(state, messageValue, WTFMove(transfer), ports, SerializationContext::WindowPostMessage);
 885     if (messageData.hasException())
 886         return messageData.releaseException();
 887 
 888     auto disentangledPorts = MessagePort::disentanglePorts(WTFMove(ports));
 889     if (disentangledPorts.hasException())
 890         return disentangledPorts.releaseException();
 891 
 892     // Capture the source of the message.  We need to do this synchronously
 893     // in order to capture the source of the message correctly.
 894     if (!sourceDocument)
 895         return { };
 896     auto sourceOrigin = sourceDocument-&gt;securityOrigin().toString();
 897 
 898     // Capture stack trace only when inspector front-end is loaded as it may be time consuming.
 899     RefPtr&lt;ScriptCallStack&gt; stackTrace;
 900     if (InspectorInstrumentation::consoleAgentEnabled(sourceDocument))
 901         stackTrace = createScriptCallStack(JSExecState::currentState());
 902 
 903     MessageWithMessagePorts message { messageData.releaseReturnValue(), disentangledPorts.releaseReturnValue() };
 904 
 905     // Schedule the message.
 906     RefPtr&lt;WindowProxy&gt; incumbentWindowProxy = incumbentWindow.frame() ? &amp;incumbentWindow.frame()-&gt;windowProxy() : nullptr;
 907     auto* timer = new PostMessageTimer(*this, WTFMove(message), sourceOrigin, WTFMove(incumbentWindowProxy), WTFMove(target), WTFMove(stackTrace));
 908     timer-&gt;startOneShot(0_s);
 909 
 910     InspectorInstrumentation::didPostMessage(*frame(), *timer, state);
 911 
 912     return { };
 913 }
 914 
 915 void DOMWindow::postMessageTimerFired(PostMessageTimer&amp; timer)
 916 {
 917     if (!document() || !isCurrentlyDisplayedInFrame())
 918         return;
 919 
 920     Ref&lt;Frame&gt; frame = *this-&gt;frame();
 921     if (auto* intendedTargetOrigin = timer.targetOrigin()) {
 922         // Check target origin now since the target document may have changed since the timer was scheduled.
 923         if (!intendedTargetOrigin-&gt;isSameSchemeHostPort(document()-&gt;securityOrigin())) {
 924             if (auto* pageConsole = console()) {
 925                 String message = makeString(&quot;Unable to post message to &quot;, intendedTargetOrigin-&gt;toString(), &quot;. Recipient has origin &quot;, document()-&gt;securityOrigin().toString(), &quot;.\n&quot;);
 926                 if (timer.stackTrace())
 927                     pageConsole-&gt;addMessage(MessageSource::Security, MessageLevel::Error, message, *timer.stackTrace());
 928                 else
 929                     pageConsole-&gt;addMessage(MessageSource::Security, MessageLevel::Error, message);
 930             }
 931 
 932             InspectorInstrumentation::didFailPostMessage(frame, timer);
 933             return;
 934         }
 935     }
 936 
 937     InspectorInstrumentation::willDispatchPostMessage(frame, timer);
 938 
 939     dispatchEvent(timer.event(*document()));
 940 
 941     InspectorInstrumentation::didDispatchPostMessage(frame, timer);
 942 }
 943 
 944 DOMSelection* DOMWindow::getSelection()
 945 {
 946     if (!isCurrentlyDisplayedInFrame())
 947         return nullptr;
 948     if (!m_selection)
 949         m_selection = DOMSelection::create(*this);
 950     return m_selection.get();
 951 }
 952 
 953 Element* DOMWindow::frameElement() const
 954 {
 955     auto* frame = this-&gt;frame();
 956     if (!frame)
 957         return nullptr;
 958 
 959     return frame-&gt;ownerElement();
 960 }
 961 
 962 void DOMWindow::focus(DOMWindow&amp; incumbentWindow)
 963 {
 964     auto* opener = this-&gt;opener();
 965     focus(opener &amp;&amp; opener != self() &amp;&amp; incumbentWindow.self() == opener);
 966 }
 967 
 968 void DOMWindow::focus(bool allowFocus)
 969 {
 970     if (!frame())
 971         return;
 972 
 973     Page* page = frame()-&gt;page();
 974     if (!page)
 975         return;
 976 
 977     allowFocus = allowFocus || WindowFocusAllowedIndicator::windowFocusAllowed() || !frame()-&gt;settings().windowFocusRestricted();
 978 
 979     // If we&#39;re a top level window, bring the window to the front.
 980     if (frame()-&gt;isMainFrame() &amp;&amp; allowFocus)
 981         page-&gt;chrome().focus();
 982 
 983     if (!frame())
 984         return;
 985 
 986     // Clear the current frame&#39;s focused node if a new frame is about to be focused.
 987     Frame* focusedFrame = page-&gt;focusController().focusedFrame();
 988     if (focusedFrame &amp;&amp; focusedFrame != frame())
 989         focusedFrame-&gt;document()-&gt;setFocusedElement(nullptr);
 990 
 991     // setFocusedElement may clear frame(), so recheck before using it.
 992     if (auto* frame = this-&gt;frame())
 993         frame-&gt;eventHandler().focusDocumentView();
 994 }
 995 
 996 void DOMWindow::blur()
 997 {
 998     auto* frame = this-&gt;frame();
 999     if (!frame)
1000         return;
1001 
1002     Page* page = frame-&gt;page();
1003     if (!page)
1004         return;
1005 
1006     if (frame-&gt;settings().windowFocusRestricted())
1007         return;
1008 
1009     if (!frame-&gt;isMainFrame())
1010         return;
1011 
1012     page-&gt;chrome().unfocus();
1013 }
1014 
1015 void DOMWindow::close(Document&amp; document)
1016 {
1017     if (!document.canNavigate(frame()))
1018         return;
1019     close();
1020 }
1021 
1022 void DOMWindow::close()
1023 {
1024     auto* frame = this-&gt;frame();
1025     if (!frame)
1026         return;
1027 
1028     Page* page = frame-&gt;page();
1029     if (!page)
1030         return;
1031 
1032     if (!frame-&gt;isMainFrame())
1033         return;
1034 
1035     if (!(page-&gt;openedByDOM() || page-&gt;backForward().count() &lt;= 1)) {
1036         console()-&gt;addMessage(MessageSource::JS, MessageLevel::Warning, &quot;Can&#39;t close the window since it was not opened by JavaScript&quot;_s);
1037         return;
1038     }
1039 
1040     if (!frame-&gt;loader().shouldClose())
1041         return;
1042 
1043     page-&gt;setIsClosing();
1044     page-&gt;chrome().closeWindowSoon();
1045 }
1046 
1047 void DOMWindow::print()
1048 {
1049     auto* frame = this-&gt;frame();
1050     if (!frame)
1051         return;
1052 
1053     auto* page = frame-&gt;page();
1054     if (!page)
1055         return;
1056 
1057     if (!page-&gt;arePromptsAllowed()) {
1058         printErrorMessage(&quot;Use of window.print is not allowed while unloading a page.&quot;);
1059         return;
1060     }
1061 
1062     if (frame-&gt;loader().activeDocumentLoader()-&gt;isLoading()) {
1063         m_shouldPrintWhenFinishedLoading = true;
1064         return;
1065     }
1066     m_shouldPrintWhenFinishedLoading = false;
1067     page-&gt;chrome().print(*frame);
1068 }
1069 
1070 void DOMWindow::stop()
1071 {
1072     auto* frame = this-&gt;frame();
1073     if (!frame)
1074         return;
1075 
1076     // We must check whether the load is complete asynchronously, because we might still be parsing
1077     // the document until the callstack unwinds.
1078     frame-&gt;loader().stopForUserCancel(true);
1079 }
1080 
1081 void DOMWindow::alert(const String&amp; message)
1082 {
1083     auto* frame = this-&gt;frame();
1084     if (!frame)
1085         return;
1086 
1087     if (document()-&gt;isSandboxed(SandboxModals)) {
1088         printErrorMessage(&quot;Use of window.alert is not allowed in a sandboxed frame when the allow-modals flag is not set.&quot;);
1089         return;
1090     }
1091 
1092     auto* page = frame-&gt;page();
1093     if (!page)
1094         return;
1095 
1096     if (!page-&gt;arePromptsAllowed()) {
1097         printErrorMessage(&quot;Use of window.alert is not allowed while unloading a page.&quot;);
1098         return;
1099     }
1100 
1101     frame-&gt;document()-&gt;updateStyleIfNeeded();
1102 #if ENABLE(POINTER_LOCK)
1103     page-&gt;pointerLockController().requestPointerUnlock();
1104 #endif
1105 
1106     page-&gt;chrome().runJavaScriptAlert(*frame, message);
1107 }
1108 
1109 bool DOMWindow::confirm(const String&amp; message)
1110 {
1111     auto* frame = this-&gt;frame();
1112     if (!frame)
1113         return false;
1114 
1115     if (document()-&gt;isSandboxed(SandboxModals)) {
1116         printErrorMessage(&quot;Use of window.confirm is not allowed in a sandboxed frame when the allow-modals flag is not set.&quot;);
1117         return false;
1118     }
1119 
1120     auto* page = frame-&gt;page();
1121     if (!page)
1122         return false;
1123 
1124     if (!page-&gt;arePromptsAllowed()) {
1125         printErrorMessage(&quot;Use of window.confirm is not allowed while unloading a page.&quot;);
1126         return false;
1127     }
1128 
1129     frame-&gt;document()-&gt;updateStyleIfNeeded();
1130 #if ENABLE(POINTER_LOCK)
1131     page-&gt;pointerLockController().requestPointerUnlock();
1132 #endif
1133 
1134     return page-&gt;chrome().runJavaScriptConfirm(*frame, message);
1135 }
1136 
1137 String DOMWindow::prompt(const String&amp; message, const String&amp; defaultValue)
1138 {
1139     auto* frame = this-&gt;frame();
1140     if (!frame)
1141         return String();
1142 
1143     if (document()-&gt;isSandboxed(SandboxModals)) {
1144         printErrorMessage(&quot;Use of window.prompt is not allowed in a sandboxed frame when the allow-modals flag is not set.&quot;);
1145         return String();
1146     }
1147 
1148     auto* page = frame-&gt;page();
1149     if (!page)
1150         return String();
1151 
1152     if (!page-&gt;arePromptsAllowed()) {
1153         printErrorMessage(&quot;Use of window.prompt is not allowed while unloading a page.&quot;);
1154         return String();
1155     }
1156 
1157     frame-&gt;document()-&gt;updateStyleIfNeeded();
1158 #if ENABLE(POINTER_LOCK)
1159     page-&gt;pointerLockController().requestPointerUnlock();
1160 #endif
1161 
1162     String returnValue;
1163     if (page-&gt;chrome().runJavaScriptPrompt(*frame, message, defaultValue, returnValue))
1164         return returnValue;
1165 
1166     return String();
1167 }
1168 
1169 bool DOMWindow::find(const String&amp; string, bool caseSensitive, bool backwards, bool wrap, bool /*wholeWord*/, bool /*searchInFrames*/, bool /*showDialog*/) const
1170 {
1171     if (!isCurrentlyDisplayedInFrame())
1172         return false;
1173 
1174     // FIXME (13016): Support wholeWord, searchInFrames and showDialog.
1175     FindOptions options { DoNotTraverseFlatTree };
1176     if (backwards)
1177         options.add(Backwards);
1178     if (!caseSensitive)
1179         options.add(CaseInsensitive);
1180     if (wrap)
1181         options.add(WrapAround);
1182     return frame()-&gt;editor().findString(string, options);
1183 }
1184 
1185 bool DOMWindow::offscreenBuffering() const
1186 {
1187     return true;
1188 }
1189 
1190 int DOMWindow::outerHeight() const
1191 {
1192 #if PLATFORM(IOS_FAMILY)
1193     if (!frame())
1194         return 0;
1195 
1196     auto* view = frame()-&gt;isMainFrame() ? frame()-&gt;view() : frame()-&gt;mainFrame().view();
1197     if (!view)
1198         return 0;
1199 
1200     return view-&gt;frameRect().height();
1201 #else
1202     auto* frame = this-&gt;frame();
1203     if (!frame)
1204         return 0;
1205 
1206     Page* page = frame-&gt;page();
1207     if (!page)
1208         return 0;
1209 
1210     return static_cast&lt;int&gt;(page-&gt;chrome().windowRect().height());
1211 #endif
1212 }
1213 
1214 int DOMWindow::outerWidth() const
1215 {
1216 #if PLATFORM(IOS_FAMILY)
1217     if (!frame())
1218         return 0;
1219 
1220     auto* view = frame()-&gt;isMainFrame() ? frame()-&gt;view() : frame()-&gt;mainFrame().view();
1221     if (!view)
1222         return 0;
1223 
1224     return view-&gt;frameRect().width();
1225 #else
1226     auto* frame = this-&gt;frame();
1227     if (!frame)
1228         return 0;
1229 
1230     Page* page = frame-&gt;page();
1231     if (!page)
1232         return 0;
1233 
1234     return static_cast&lt;int&gt;(page-&gt;chrome().windowRect().width());
1235 #endif
1236 }
1237 
1238 int DOMWindow::innerHeight() const
1239 {
1240     if (!frame())
1241         return 0;
1242 
1243     // Force enough layout in the parent document to ensure that the FrameView has been resized.
1244     if (auto* frameElement = this-&gt;frameElement())
1245         frameElement-&gt;document().updateLayoutIfDimensionsOutOfDate(*frameElement, HeightDimensionsCheck);
1246 
1247     auto* frame = this-&gt;frame();
1248     if (!frame)
1249         return 0;
1250 
1251     FrameView* view = frame-&gt;view();
1252     if (!view)
1253         return 0;
1254 
1255     return view-&gt;mapFromLayoutToCSSUnits(static_cast&lt;int&gt;(view-&gt;unobscuredContentRectIncludingScrollbars().height()));
1256 }
1257 
1258 int DOMWindow::innerWidth() const
1259 {
1260     if (!frame())
1261         return 0;
1262 
1263     // Force enough layout in the parent document to ensure that the FrameView has been resized.
1264     if (auto* frameElement = this-&gt;frameElement())
1265         frameElement-&gt;document().updateLayoutIfDimensionsOutOfDate(*frameElement, WidthDimensionsCheck);
1266 
1267     auto* frame = this-&gt;frame();
1268     if (!frame)
1269         return 0;
1270 
1271     FrameView* view = frame-&gt;view();
1272     if (!view)
1273         return 0;
1274 
1275     return view-&gt;mapFromLayoutToCSSUnits(static_cast&lt;int&gt;(view-&gt;unobscuredContentRectIncludingScrollbars().width()));
1276 }
1277 
1278 int DOMWindow::screenX() const
1279 {
1280     auto* frame = this-&gt;frame();
1281     if (!frame)
1282         return 0;
1283 
1284     Page* page = frame-&gt;page();
1285     if (!page)
1286         return 0;
1287 
1288     return static_cast&lt;int&gt;(page-&gt;chrome().windowRect().x());
1289 }
1290 
1291 int DOMWindow::screenY() const
1292 {
1293     auto* frame = this-&gt;frame();
1294     if (!frame)
1295         return 0;
1296 
1297     Page* page = frame-&gt;page();
1298     if (!page)
1299         return 0;
1300 
1301     return static_cast&lt;int&gt;(page-&gt;chrome().windowRect().y());
1302 }
1303 
1304 int DOMWindow::scrollX() const
1305 {
1306     auto* frame = this-&gt;frame();
1307     if (!frame)
1308         return 0;
1309 
1310     FrameView* view = frame-&gt;view();
1311     if (!view)
1312         return 0;
1313 
1314     int scrollX = view-&gt;contentsScrollPosition().x();
1315     if (!scrollX)
1316         return 0;
1317 
1318     frame-&gt;document()-&gt;updateLayoutIgnorePendingStylesheets();
1319 
1320     // Layout may have affected the current frame:
1321     auto* frameAfterLayout = this-&gt;frame();
1322     if (!frameAfterLayout)
1323         return 0;
1324 
1325     FrameView* viewAfterLayout = frameAfterLayout-&gt;view();
1326     if (!viewAfterLayout)
1327         return 0;
1328 
1329     return viewAfterLayout-&gt;mapFromLayoutToCSSUnits(viewAfterLayout-&gt;contentsScrollPosition().x());
1330 }
1331 
1332 int DOMWindow::scrollY() const
1333 {
1334     auto* frame = this-&gt;frame();
1335     if (!frame)
1336         return 0;
1337 
1338     FrameView* view = frame-&gt;view();
1339     if (!view)
1340         return 0;
1341 
1342     int scrollY = view-&gt;contentsScrollPosition().y();
1343     if (!scrollY)
1344         return 0;
1345 
1346     frame-&gt;document()-&gt;updateLayoutIgnorePendingStylesheets();
1347 
1348     // Layout may have affected the current frame:
1349     auto* frameAfterLayout = this-&gt;frame();
1350     if (!frameAfterLayout)
1351         return 0;
1352 
1353     FrameView* viewAfterLayout = frameAfterLayout-&gt;view();
1354     if (!viewAfterLayout)
1355         return 0;
1356 
1357     return viewAfterLayout-&gt;mapFromLayoutToCSSUnits(viewAfterLayout-&gt;contentsScrollPosition().y());
1358 }
1359 
1360 bool DOMWindow::closed() const
1361 {
1362     return !frame();
1363 }
1364 
1365 unsigned DOMWindow::length() const
1366 {
1367     if (!isCurrentlyDisplayedInFrame())
1368         return 0;
1369 
1370     return frame()-&gt;tree().scopedChildCount();
1371 }
1372 
1373 String DOMWindow::name() const
1374 {
1375     auto* frame = this-&gt;frame();
1376     if (!frame)
1377         return String();
1378 
1379     return frame-&gt;tree().name();
1380 }
1381 
1382 void DOMWindow::setName(const String&amp; string)
1383 {
1384     auto* frame = this-&gt;frame();
1385     if (!frame)
1386         return;
1387 
1388     frame-&gt;tree().setName(string);
1389 }
1390 
1391 void DOMWindow::setStatus(const String&amp; string)
1392 {
1393     m_status = string;
1394 
1395     auto* frame = this-&gt;frame();
1396     if (!frame)
1397         return;
1398 
1399     Page* page = frame-&gt;page();
1400     if (!page)
1401         return;
1402 
1403     ASSERT(frame-&gt;document()); // Client calls shouldn&#39;t be made when the frame is in inconsistent state.
1404     page-&gt;chrome().setStatusbarText(*frame, m_status);
1405 }
1406 
1407 void DOMWindow::setDefaultStatus(const String&amp; string)
1408 {
1409     m_defaultStatus = string;
1410 
1411     auto* frame = this-&gt;frame();
1412     if (!frame)
1413         return;
1414 
1415     Page* page = frame-&gt;page();
1416     if (!page)
1417         return;
1418 
1419     ASSERT(frame-&gt;document()); // Client calls shouldn&#39;t be made when the frame is in inconsistent state.
1420     page-&gt;chrome().setStatusbarText(*frame, m_defaultStatus);
1421 }
1422 
1423 WindowProxy* DOMWindow::self() const
1424 {
1425     auto* frame = this-&gt;frame();
1426     if (!frame)
1427         return nullptr;
1428 
1429     return &amp;frame-&gt;windowProxy();
1430 }
1431 
1432 WindowProxy* DOMWindow::opener() const
1433 {
1434     auto* frame = this-&gt;frame();
1435     if (!frame)
1436         return nullptr;
1437 
1438     auto* openerFrame = frame-&gt;loader().opener();
1439     if (!openerFrame)
1440         return nullptr;
1441 
1442     return &amp;openerFrame-&gt;windowProxy();
1443 }
1444 
1445 void DOMWindow::disownOpener()
1446 {
1447     if (auto* frame = this-&gt;frame())
1448         frame-&gt;loader().setOpener(nullptr);
1449 }
1450 
1451 WindowProxy* DOMWindow::parent() const
1452 {
1453     auto* frame = this-&gt;frame();
1454     if (!frame)
1455         return nullptr;
1456 
1457     auto* parentFrame = frame-&gt;tree().parent();
1458     if (parentFrame)
1459         return &amp;parentFrame-&gt;windowProxy();
1460 
1461     return &amp;frame-&gt;windowProxy();
1462 }
1463 
1464 WindowProxy* DOMWindow::top() const
1465 {
1466     auto* frame = this-&gt;frame();
1467     if (!frame)
1468         return nullptr;
1469 
1470     if (!frame-&gt;page())
1471         return nullptr;
1472 
1473     return &amp;frame-&gt;tree().top().windowProxy();
1474 }
1475 
1476 String DOMWindow::origin() const
1477 {
1478     auto document = this-&gt;document();
1479     return document ? document-&gt;securityOrigin().toString() : emptyString();
1480 }
1481 
1482 Document* DOMWindow::document() const
1483 {
1484     return downcast&lt;Document&gt;(ContextDestructionObserver::scriptExecutionContext());
1485 }
1486 
1487 StyleMedia&amp; DOMWindow::styleMedia()
1488 {
1489     if (!m_media)
1490         m_media = StyleMedia::create(*this);
1491     return *m_media;
1492 }
1493 
1494 Ref&lt;CSSStyleDeclaration&gt; DOMWindow::getComputedStyle(Element&amp; element, const String&amp; pseudoElt) const
1495 {
1496     return CSSComputedStyleDeclaration::create(element, false, pseudoElt);
1497 }
1498 
1499 RefPtr&lt;CSSRuleList&gt; DOMWindow::getMatchedCSSRules(Element* element, const String&amp; pseudoElement, bool authorOnly) const
1500 {
1501     if (!isCurrentlyDisplayedInFrame())
1502         return nullptr;
1503 
1504     unsigned colonStart = pseudoElement[0] == &#39;:&#39; ? (pseudoElement[1] == &#39;:&#39; ? 2 : 1) : 0;
1505     CSSSelector::PseudoElementType pseudoType = CSSSelector::parsePseudoElementType(pseudoElement.substringSharingImpl(colonStart));
1506     if (pseudoType == CSSSelector::PseudoElementUnknown &amp;&amp; !pseudoElement.isEmpty())
1507         return nullptr;
1508 
1509     auto* frame = this-&gt;frame();
1510     frame-&gt;document()-&gt;styleScope().flushPendingUpdate();
1511 
1512     unsigned rulesToInclude = StyleResolver::AuthorCSSRules;
1513     if (!authorOnly)
1514         rulesToInclude |= StyleResolver::UAAndUserCSSRules;
1515 
1516     PseudoId pseudoId = CSSSelector::pseudoId(pseudoType);
1517 
1518     auto matchedRules = frame-&gt;document()-&gt;styleScope().resolver().pseudoStyleRulesForElement(element, pseudoId, rulesToInclude);
1519     if (matchedRules.isEmpty())
1520         return nullptr;
1521 
1522     bool allowCrossOrigin = frame-&gt;settings().crossOriginCheckInGetMatchedCSSRulesDisabled();
1523 
1524     auto ruleList = StaticCSSRuleList::create();
1525     for (auto&amp; rule : matchedRules) {
1526         if (!allowCrossOrigin &amp;&amp; !rule-&gt;hasDocumentSecurityOrigin())
1527             continue;
1528         ruleList-&gt;rules().append(rule-&gt;createCSSOMWrapper());
1529     }
1530 
1531     if (ruleList-&gt;rules().isEmpty())
1532         return nullptr;
1533 
1534     return WTFMove(ruleList);
1535 }
1536 
1537 RefPtr&lt;WebKitPoint&gt; DOMWindow::webkitConvertPointFromNodeToPage(Node* node, const WebKitPoint* p) const
1538 {
1539     if (!node || !p)
1540         return nullptr;
1541 
1542     if (!document())
1543         return nullptr;
1544 
1545     document()-&gt;updateLayoutIgnorePendingStylesheets();
1546 
1547     FloatPoint pagePoint(p-&gt;x(), p-&gt;y());
1548     pagePoint = node-&gt;convertToPage(pagePoint);
1549     return WebKitPoint::create(pagePoint.x(), pagePoint.y());
1550 }
1551 
1552 RefPtr&lt;WebKitPoint&gt; DOMWindow::webkitConvertPointFromPageToNode(Node* node, const WebKitPoint* p) const
1553 {
1554     if (!node || !p)
1555         return nullptr;
1556 
1557     if (!document())
1558         return nullptr;
1559 
1560     document()-&gt;updateLayoutIgnorePendingStylesheets();
1561 
1562     FloatPoint nodePoint(p-&gt;x(), p-&gt;y());
1563     nodePoint = node-&gt;convertFromPage(nodePoint);
1564     return WebKitPoint::create(nodePoint.x(), nodePoint.y());
1565 }
1566 
1567 double DOMWindow::devicePixelRatio() const
1568 {
1569     auto* frame = this-&gt;frame();
1570     if (!frame)
1571         return 0.0;
1572 
1573     Page* page = frame-&gt;page();
1574     if (!page)
1575         return 0.0;
1576 
1577     return page-&gt;deviceScaleFactor();
1578 }
1579 
1580 void DOMWindow::scrollBy(double x, double y) const
1581 {
1582     scrollBy({ x, y });
1583 }
1584 
1585 void DOMWindow::scrollBy(const ScrollToOptions&amp; options) const
1586 {
1587     if (!isCurrentlyDisplayedInFrame())
1588         return;
1589 
1590     document()-&gt;updateLayoutIgnorePendingStylesheets();
1591 
1592     FrameView* view = frame()-&gt;view();
1593     if (!view)
1594         return;
1595 
1596     ScrollToOptions scrollToOptions = normalizeNonFiniteCoordinatesOrFallBackTo(options, 0, 0);
1597     scrollToOptions.left.value() += view-&gt;mapFromLayoutToCSSUnits(view-&gt;contentsScrollPosition().x());
1598     scrollToOptions.top.value() += view-&gt;mapFromLayoutToCSSUnits(view-&gt;contentsScrollPosition().y());
1599     scrollTo(scrollToOptions);
1600 }
1601 
1602 void DOMWindow::scrollTo(double x, double y, ScrollClamping clamping) const
1603 {
1604     scrollTo({ x, y }, clamping);
1605 }
1606 
1607 void DOMWindow::scrollTo(const ScrollToOptions&amp; options, ScrollClamping) const
1608 {
1609     if (!isCurrentlyDisplayedInFrame())
1610         return;
1611 
1612     RefPtr&lt;FrameView&gt; view = frame()-&gt;view();
1613     if (!view)
1614         return;
1615 
1616     ScrollToOptions scrollToOptions = normalizeNonFiniteCoordinatesOrFallBackTo(options,
1617         view-&gt;contentsScrollPosition().x(), view-&gt;contentsScrollPosition().y()
1618     );
1619 
1620     if (!scrollToOptions.left.value() &amp;&amp; !scrollToOptions.top.value() &amp;&amp; view-&gt;contentsScrollPosition() == IntPoint(0, 0))
1621         return;
1622 
1623     document()-&gt;updateLayoutIgnorePendingStylesheets();
1624 
1625     IntPoint layoutPos(view-&gt;mapFromCSSToLayoutUnits(scrollToOptions.left.value()), view-&gt;mapFromCSSToLayoutUnits(scrollToOptions.top.value()));
1626     view-&gt;setContentsScrollPosition(layoutPos);
1627 }
1628 
1629 bool DOMWindow::allowedToChangeWindowGeometry() const
1630 {
1631     auto* frame = this-&gt;frame();
1632     if (!frame)
1633         return false;
1634     if (!frame-&gt;page())
1635         return false;
1636     if (!frame-&gt;isMainFrame())
1637         return false;
1638     // Prevent web content from tricking the user into initiating a drag.
1639     if (frame-&gt;eventHandler().mousePressed())
1640         return false;
1641     return true;
1642 }
1643 
1644 void DOMWindow::moveBy(float x, float y) const
1645 {
1646     if (!allowedToChangeWindowGeometry())
1647         return;
1648 
1649     auto* page = frame()-&gt;page();
1650     FloatRect fr = page-&gt;chrome().windowRect();
1651     FloatRect update = fr;
1652     update.move(x, y);
1653     page-&gt;chrome().setWindowRect(adjustWindowRect(*page, update));
1654 }
1655 
1656 void DOMWindow::moveTo(float x, float y) const
1657 {
1658     if (!allowedToChangeWindowGeometry())
1659         return;
1660 
1661     auto* page = frame()-&gt;page();
1662     FloatRect fr = page-&gt;chrome().windowRect();
1663     FloatRect sr = screenAvailableRect(page-&gt;mainFrame().view());
1664     fr.setLocation(sr.location());
1665     FloatRect update = fr;
1666     update.move(x, y);
1667     page-&gt;chrome().setWindowRect(adjustWindowRect(*page, update));
1668 }
1669 
1670 void DOMWindow::resizeBy(float x, float y) const
1671 {
1672     if (!allowedToChangeWindowGeometry())
1673         return;
1674 
1675     auto* page = frame()-&gt;page();
1676     FloatRect fr = page-&gt;chrome().windowRect();
1677     FloatSize dest = fr.size() + FloatSize(x, y);
1678     FloatRect update(fr.location(), dest);
1679     page-&gt;chrome().setWindowRect(adjustWindowRect(*page, update));
1680 }
1681 
1682 void DOMWindow::resizeTo(float width, float height) const
1683 {
1684     if (!allowedToChangeWindowGeometry())
1685         return;
1686 
1687     auto* page = frame()-&gt;page();
1688     FloatRect fr = page-&gt;chrome().windowRect();
1689     FloatSize dest = FloatSize(width, height);
1690     FloatRect update(fr.location(), dest);
1691     page-&gt;chrome().setWindowRect(adjustWindowRect(*page, update));
1692 }
1693 
1694 ExceptionOr&lt;int&gt; DOMWindow::setTimeout(JSC::ExecState&amp; state, std::unique_ptr&lt;ScheduledAction&gt; action, int timeout, Vector&lt;JSC::Strong&lt;JSC::Unknown&gt;&gt;&amp;&amp; arguments)
1695 {
1696     auto* context = scriptExecutionContext();
1697     if (!context)
1698         return Exception { InvalidAccessError };
1699 
1700     // FIXME: Should this check really happen here? Or should it happen when code is about to eval?
1701     if (action-&gt;type() == ScheduledAction::Type::Code) {
1702         if (!context-&gt;contentSecurityPolicy()-&gt;allowEval(&amp;state))
1703             return 0;
1704     }
1705 
1706     action-&gt;addArguments(WTFMove(arguments));
1707 
1708     return DOMTimer::install(*context, WTFMove(action), Seconds::fromMilliseconds(timeout), true);
1709 }
1710 
1711 void DOMWindow::clearTimeout(int timeoutId)
1712 {
1713 #if PLATFORM(IOS_FAMILY)
1714     if (auto* frame = this-&gt;frame()) {
1715         Document* document = frame-&gt;document();
1716         if (timeoutId &gt; 0 &amp;&amp; document) {
1717             DOMTimer* timer = document-&gt;findTimeout(timeoutId);
1718             if (timer &amp;&amp; WebThreadContainsObservedDOMTimer(timer)) {
1719                 LOG_WITH_STREAM(ContentObservation, stream &lt;&lt; &quot;DOMWindow::clearTimeout: remove registered timer (&quot; &lt;&lt; timer &lt;&lt; &quot;)&quot;);
1720                 WebThreadRemoveObservedDOMTimer(timer);
1721 
1722                 if (!WebThreadCountOfObservedDOMTimers()) {
1723                     if (Page* page = frame-&gt;page())
1724                         page-&gt;chrome().client().observedContentChange(*frame);
1725                 }
1726             }
1727         }
1728     }
1729 #endif
1730     ScriptExecutionContext* context = scriptExecutionContext();
1731     if (!context)
1732         return;
1733     DOMTimer::removeById(*context, timeoutId);
1734 }
1735 
1736 ExceptionOr&lt;int&gt; DOMWindow::setInterval(JSC::ExecState&amp; state, std::unique_ptr&lt;ScheduledAction&gt; action, int timeout, Vector&lt;JSC::Strong&lt;JSC::Unknown&gt;&gt;&amp;&amp; arguments)
1737 {
1738     auto* context = scriptExecutionContext();
1739     if (!context)
1740         return Exception { InvalidAccessError };
1741 
1742     // FIXME: Should this check really happen here? Or should it happen when code is about to eval?
1743     if (action-&gt;type() == ScheduledAction::Type::Code) {
1744         if (!context-&gt;contentSecurityPolicy()-&gt;allowEval(&amp;state))
1745             return 0;
1746     }
1747 
1748     action-&gt;addArguments(WTFMove(arguments));
1749 
1750     return DOMTimer::install(*context, WTFMove(action), Seconds::fromMilliseconds(timeout), false);
1751 }
1752 
1753 void DOMWindow::clearInterval(int timeoutId)
1754 {
1755     ScriptExecutionContext* context = scriptExecutionContext();
1756     if (!context)
1757         return;
1758     DOMTimer::removeById(*context, timeoutId);
1759 }
1760 
1761 int DOMWindow::requestAnimationFrame(Ref&lt;RequestAnimationFrameCallback&gt;&amp;&amp; callback)
1762 {
1763     callback-&gt;m_useLegacyTimeBase = false;
1764     auto* document = this-&gt;document();
1765     if (!document)
1766         return 0;
1767     return document-&gt;requestAnimationFrame(WTFMove(callback));
1768 }
1769 
1770 int DOMWindow::webkitRequestAnimationFrame(Ref&lt;RequestAnimationFrameCallback&gt;&amp;&amp; callback)
1771 {
1772     callback-&gt;m_useLegacyTimeBase = true;
1773     auto* document = this-&gt;document();
1774     if (!document)
1775         return 0;
1776     return document-&gt;requestAnimationFrame(WTFMove(callback));
1777 }
1778 
1779 void DOMWindow::cancelAnimationFrame(int id)
1780 {
1781     auto* document = this-&gt;document();
1782     if (!document)
1783         return;
1784     document-&gt;cancelAnimationFrame(id);
1785 }
1786 
1787 void DOMWindow::createImageBitmap(ImageBitmap::Source&amp;&amp; source, ImageBitmapOptions&amp;&amp; options, ImageBitmap::Promise&amp;&amp; promise)
1788 {
1789     auto* document = this-&gt;document();
1790     if (!document) {
1791         promise.reject(InvalidStateError);
1792         return;
1793     }
1794     ImageBitmap::createPromise(*document, WTFMove(source), WTFMove(options), WTFMove(promise));
1795 }
1796 
1797 void DOMWindow::createImageBitmap(ImageBitmap::Source&amp;&amp; source, int sx, int sy, int sw, int sh, ImageBitmapOptions&amp;&amp; options, ImageBitmap::Promise&amp;&amp; promise)
1798 {
1799     auto* document = this-&gt;document();
1800     if (!document) {
1801         promise.reject(InvalidStateError);
1802         return;
1803     }
1804     ImageBitmap::createPromise(*document, WTFMove(source), WTFMove(options), sx, sy, sw, sh, WTFMove(promise));
1805 }
1806 
1807 bool DOMWindow::isSecureContext() const
1808 {
1809     auto* document = this-&gt;document();
1810     if (!document)
1811         return false;
1812     return document-&gt;isSecureContext();
1813 }
1814 
1815 static void didAddStorageEventListener(DOMWindow&amp; window)
1816 {
1817     // Creating these WebCore::Storage objects informs the system that we&#39;d like to receive
1818     // notifications about storage events that might be triggered in other processes. Rather
1819     // than subscribe to these notifications explicitly, we subscribe to them implicitly to
1820     // simplify the work done by the system.
1821     window.localStorage();
1822     window.sessionStorage();
1823 }
1824 
1825 bool DOMWindow::isSameSecurityOriginAsMainFrame() const
1826 {
1827     auto* frame = this-&gt;frame();
1828     if (!frame || !frame-&gt;page() || !document())
1829         return false;
1830 
1831     if (frame-&gt;isMainFrame())
1832         return true;
1833 
1834     Document* mainFrameDocument = frame-&gt;mainFrame().document();
1835 
1836     if (mainFrameDocument &amp;&amp; document()-&gt;securityOrigin().canAccess(mainFrameDocument-&gt;securityOrigin()))
1837         return true;
1838 
1839     return false;
1840 }
1841 
1842 bool DOMWindow::addEventListener(const AtomicString&amp; eventType, Ref&lt;EventListener&gt;&amp;&amp; listener, const AddEventListenerOptions&amp; options)
1843 {
1844     if (!EventTarget::addEventListener(eventType, WTFMove(listener), options))
1845         return false;
1846 
1847     if (Document* document = this-&gt;document()) {
1848         document-&gt;addListenerTypeIfNeeded(eventType);
1849         if (eventNames().isWheelEventType(eventType))
1850             document-&gt;didAddWheelEventHandler(*document);
1851         else if (eventNames().isTouchEventType(eventType))
1852             document-&gt;didAddTouchEventHandler(*document);
1853         else if (eventType == eventNames().storageEvent)
1854             didAddStorageEventListener(*this);
1855     }
1856 
1857     if (eventType == eventNames().unloadEvent)
1858         addUnloadEventListener(this);
1859     else if (eventType == eventNames().beforeunloadEvent &amp;&amp; allowsBeforeUnloadListeners(this))
1860         addBeforeUnloadEventListener(this);
1861 #if PLATFORM(IOS_FAMILY)
1862     else if (eventType == eventNames().scrollEvent)
1863         incrementScrollEventListenersCount();
1864 #endif
1865 #if ENABLE(IOS_TOUCH_EVENTS)
1866     else if (eventNames().isTouchEventType(eventType))
1867         ++m_touchAndGestureEventListenerCount;
1868 #endif
1869 #if ENABLE(IOS_GESTURE_EVENTS)
1870     else if (eventNames().isGestureEventType(eventType))
1871         ++m_touchAndGestureEventListenerCount;
1872 #endif
1873 #if ENABLE(GAMEPAD)
1874     else if (eventNames().isGamepadEventType(eventType))
1875         incrementGamepadEventListenerCount();
1876 #endif
1877 
1878 #if ENABLE(DEVICE_ORIENTATION)
1879     if (frame() &amp;&amp; frame()-&gt;settings().deviceOrientationEventEnabled() &amp;&amp; document() &amp;&amp; document()-&gt;loader() &amp;&amp; document()-&gt;loader()-&gt;deviceOrientationEventEnabled()) {
1880 #if PLATFORM(IOS_FAMILY)
1881         if ((eventType == eventNames().devicemotionEvent || eventType == eventNames().deviceorientationEvent)) {
1882             if (isSameSecurityOriginAsMainFrame() &amp;&amp; isSecureContext()) {
1883                 if (eventType == eventNames().deviceorientationEvent)
1884                     document()-&gt;deviceOrientationController().addDeviceEventListener(*this);
1885                 else
1886                     document()-&gt;deviceMotionController().addDeviceEventListener(*this);
1887             } else if (document()) {
1888                 if (isSecureContext())
1889                     document()-&gt;addConsoleMessage(MessageSource::JS, MessageLevel::Warning, &quot;Blocked attempt to add a device motion or orientation listener from child frame that wasn&#39;t the same security origin as the main page.&quot;_s);
1890                 else
1891                     document()-&gt;addConsoleMessage(MessageSource::JS, MessageLevel::Warning, &quot;Blocked attempt to add a device motion or orientation listener because the browsing context is not secure.&quot;_s);
1892             }
1893         }
1894 #else
1895         if (eventType == eventNames().devicemotionEvent) {
1896             if (isSameSecurityOriginAsMainFrame() &amp;&amp; isSecureContext()) {
1897                 if (DeviceMotionController* controller = DeviceMotionController::from(page()))
1898                     controller-&gt;addDeviceEventListener(*this);
1899             } else
1900                 document()-&gt;addConsoleMessage(MessageSource::JS, MessageLevel::Warning, &quot;Blocked attempt to add a device motion listener from child frame that wasn&#39;t the same security origin as the main page.&quot;_s);
1901         } else if (eventType == eventNames().deviceorientationEvent) {
1902             if (isSameSecurityOriginAsMainFrame() &amp;&amp; isSecureContext()) {
1903                 if (DeviceOrientationController* controller = DeviceOrientationController::from(page()))
1904                     controller-&gt;addDeviceEventListener(*this);
1905             } else {
1906                 if (isSecureContext())
1907                     document()-&gt;addConsoleMessage(MessageSource::JS, MessageLevel::Warning, &quot;Blocked attempt to add a device orientation listener from child frame that wasn&#39;t the same security origin as the main page.&quot;_s);
1908                 else
1909                     document()-&gt;addConsoleMessage(MessageSource::JS, MessageLevel::Warning, &quot;Blocked attempt to add a device motion or orientation listener because the browsing context is not secure.&quot;_s);
1910             }
1911         }
1912 #endif // PLATFORM(IOS_FAMILY)
1913     }
1914 #endif // ENABLE(DEVICE_ORIENTATION)
1915 
1916     return true;
1917 }
1918 
1919 #if PLATFORM(IOS_FAMILY)
1920 
1921 void DOMWindow::incrementScrollEventListenersCount()
1922 {
1923     Document* document = this-&gt;document();
1924     if (++m_scrollEventListenerCount == 1 &amp;&amp; document == &amp;document-&gt;topDocument()) {
1925         Frame* frame = this-&gt;frame();
1926         if (frame &amp;&amp; frame-&gt;page())
1927             frame-&gt;page()-&gt;chrome().client().setNeedsScrollNotifications(*frame, true);
1928     }
1929 }
1930 
1931 void DOMWindow::decrementScrollEventListenersCount()
1932 {
1933     Document* document = this-&gt;document();
1934     if (!--m_scrollEventListenerCount &amp;&amp; document == &amp;document-&gt;topDocument()) {
1935         Frame* frame = this-&gt;frame();
1936         if (frame &amp;&amp; frame-&gt;page() &amp;&amp; document-&gt;pageCacheState() == Document::NotInPageCache)
1937             frame-&gt;page()-&gt;chrome().client().setNeedsScrollNotifications(*frame, false);
1938     }
1939 }
1940 
1941 #endif
1942 
1943 void DOMWindow::resetAllGeolocationPermission()
1944 {
1945     // FIXME: Can we remove the PLATFORM(IOS_FAMILY)-guard?
1946 #if ENABLE(GEOLOCATION) &amp;&amp; PLATFORM(IOS_FAMILY)
1947     if (m_navigator)
1948         NavigatorGeolocation::from(m_navigator.get())-&gt;resetAllGeolocationPermission();
1949 #endif
1950 }
1951 
1952 bool DOMWindow::removeEventListener(const AtomicString&amp; eventType, EventListener&amp; listener, const ListenerOptions&amp; options)
1953 {
1954     if (!EventTarget::removeEventListener(eventType, listener, options.capture))
1955         return false;
1956 
1957     if (Document* document = this-&gt;document()) {
1958         if (eventNames().isWheelEventType(eventType))
1959             document-&gt;didRemoveWheelEventHandler(*document);
1960         else if (eventNames().isTouchEventType(eventType))
1961             document-&gt;didRemoveTouchEventHandler(*document);
1962     }
1963 
1964     if (eventType == eventNames().unloadEvent)
1965         removeUnloadEventListener(this);
1966     else if (eventType == eventNames().beforeunloadEvent &amp;&amp; allowsBeforeUnloadListeners(this))
1967         removeBeforeUnloadEventListener(this);
1968 #if ENABLE(DEVICE_ORIENTATION)
1969 #if PLATFORM(IOS_FAMILY)
1970     else if (eventType == eventNames().devicemotionEvent &amp;&amp; document())
1971         document()-&gt;deviceMotionController().removeDeviceEventListener(*this);
1972     else if (eventType == eventNames().deviceorientationEvent &amp;&amp; document())
1973         document()-&gt;deviceOrientationController().removeDeviceEventListener(*this);
1974 #else
1975     else if (eventType == eventNames().devicemotionEvent) {
1976         if (DeviceMotionController* controller = DeviceMotionController::from(page()))
1977             controller-&gt;removeDeviceEventListener(*this);
1978     } else if (eventType == eventNames().deviceorientationEvent) {
1979         if (DeviceOrientationController* controller = DeviceOrientationController::from(page()))
1980             controller-&gt;removeDeviceEventListener(*this);
1981     }
1982 #endif // PLATFORM(IOS_FAMILY)
1983 #endif // ENABLE(DEVICE_ORIENTATION)
1984 #if PLATFORM(IOS_FAMILY)
1985     else if (eventType == eventNames().scrollEvent)
1986         decrementScrollEventListenersCount();
1987 #endif
1988 #if ENABLE(IOS_TOUCH_EVENTS)
1989     else if (eventNames().isTouchEventType(eventType)) {
1990         ASSERT(m_touchAndGestureEventListenerCount &gt; 0);
1991         --m_touchAndGestureEventListenerCount;
1992     }
1993 #endif
1994 #if ENABLE(IOS_GESTURE_EVENTS)
1995     else if (eventNames().isGestureEventType(eventType)) {
1996         ASSERT(m_touchAndGestureEventListenerCount &gt; 0);
1997         --m_touchAndGestureEventListenerCount;
1998     }
1999 #endif
2000 #if ENABLE(GAMEPAD)
2001     else if (eventNames().isGamepadEventType(eventType))
2002         decrementGamepadEventListenerCount();
2003 #endif
2004 
2005     return true;
2006 }
2007 
2008 void DOMWindow::languagesChanged()
2009 {
2010     if (auto* document = this-&gt;document())
2011         document-&gt;enqueueWindowEvent(Event::create(eventNames().languagechangeEvent, Event::CanBubble::No, Event::IsCancelable::No));
2012 }
2013 
2014 void DOMWindow::dispatchLoadEvent()
2015 {
2016     // If we did not protect it, the document loader and its timing subobject might get destroyed
2017     // as a side effect of what event handling code does.
2018     auto protectedThis = makeRef(*this);
2019     auto protectedLoader = makeRefPtr(frame() ? frame()-&gt;loader().documentLoader() : nullptr);
2020     bool shouldMarkLoadEventTimes = protectedLoader &amp;&amp; !protectedLoader-&gt;timing().loadEventStart();
2021 
2022     if (shouldMarkLoadEventTimes)
2023         protectedLoader-&gt;timing().markLoadEventStart();
2024 
2025     dispatchEvent(Event::create(eventNames().loadEvent, Event::CanBubble::No, Event::IsCancelable::No), document());
2026 
2027     if (shouldMarkLoadEventTimes)
2028         protectedLoader-&gt;timing().markLoadEventEnd();
2029 
2030     // Send a separate load event to the element that owns this frame.
2031     if (frame()) {
2032         if (auto* owner = frame()-&gt;ownerElement())
2033             owner-&gt;dispatchEvent(Event::create(eventNames().loadEvent, Event::CanBubble::No, Event::IsCancelable::No));
2034     }
2035 
2036     InspectorInstrumentation::loadEventFired(frame());
2037 }
2038 
2039 void DOMWindow::dispatchEvent(Event&amp; event, EventTarget* target)
2040 {
2041     // FIXME: It&#39;s confusing to have both the inherited EventTarget::dispatchEvent function
2042     // and this function, which does something nearly identical but subtly different if
2043     // called with a target of null. Most callers pass the document as the target, though.
2044     // Fixing this could allow us to remove the special case in DocumentEventQueue::dispatchEvent.
2045 
2046     auto protectedThis = makeRef(*this);
2047 
2048     // Pausing a page may trigger pagehide and pageshow events. WebCore also implicitly fires these
2049     // events when closing a WebView. Here we keep track of the state of the page to prevent duplicate,
2050     // unbalanced events per the definition of the pageshow event:
2051     // &lt;http://www.whatwg.org/specs/web-apps/current-work/multipage/history.html#event-pageshow&gt;.
2052     // FIXME: This code should go at call sites where pageshowEvent and pagehideEvents are
2053     // generated, not here inside the event dispatching process.
2054     if (event.eventInterface() == PageTransitionEventInterfaceType) {
2055         if (event.type() == eventNames().pageshowEvent) {
2056             if (m_lastPageStatus == PageStatus::Shown)
2057                 return; // Event was previously dispatched; do not fire a duplicate event.
2058             m_lastPageStatus = PageStatus::Shown;
2059         } else if (event.type() == eventNames().pagehideEvent) {
2060             if (m_lastPageStatus == PageStatus::Hidden)
2061                 return; // Event was previously dispatched; do not fire a duplicate event.
2062             m_lastPageStatus = PageStatus::Hidden;
2063         }
2064     }
2065 
2066     // FIXME: It doesn&#39;t seem right to have the inspector instrumentation here since not all
2067     // events dispatched to the window object are guaranteed to flow through this function.
2068     // But the instrumentation prevents us from calling EventDispatcher::dispatchEvent here.
2069     event.setTarget(target ? target : this);
2070     event.setCurrentTarget(this);
2071     event.setEventPhase(Event::AT_TARGET);
2072     event.resetBeforeDispatch();
2073     auto cookie = InspectorInstrumentation::willDispatchEventOnWindow(frame(), event, *this);
2074     // FIXME: We should use EventDispatcher everywhere.
2075     fireEventListeners(event, EventInvokePhase::Capturing);
2076     fireEventListeners(event, EventInvokePhase::Bubbling);
2077     InspectorInstrumentation::didDispatchEventOnWindow(cookie);
2078     event.resetAfterDispatch();
2079 }
2080 
2081 void DOMWindow::removeAllEventListeners()
2082 {
2083     EventTarget::removeAllEventListeners();
2084 
2085 #if ENABLE(DEVICE_ORIENTATION)
2086 #if PLATFORM(IOS_FAMILY)
2087     if (Document* document = this-&gt;document()) {
2088         document-&gt;deviceMotionController().removeAllDeviceEventListeners(*this);
2089         document-&gt;deviceOrientationController().removeAllDeviceEventListeners(*this);
2090     }
2091 #else
2092     if (DeviceMotionController* controller = DeviceMotionController::from(page()))
2093         controller-&gt;removeAllDeviceEventListeners(*this);
2094     if (DeviceOrientationController* controller = DeviceOrientationController::from(page()))
2095         controller-&gt;removeAllDeviceEventListeners(*this);
2096 #endif // PLATFORM(IOS_FAMILY)
2097 #endif // ENABLE(DEVICE_ORIENTATION)
2098 
2099 #if PLATFORM(IOS_FAMILY)
2100     if (m_scrollEventListenerCount) {
2101         m_scrollEventListenerCount = 1;
2102         decrementScrollEventListenersCount();
2103     }
2104 #endif
2105 
2106 #if ENABLE(IOS_TOUCH_EVENTS) || ENABLE(IOS_GESTURE_EVENTS)
2107     m_touchAndGestureEventListenerCount = 0;
2108 #endif
2109 
2110 #if ENABLE(TOUCH_EVENTS)
2111     if (Document* document = this-&gt;document())
2112         document-&gt;didRemoveEventTargetNode(*document);
2113 #endif
2114 
2115     if (m_performance) {
2116         m_performance-&gt;removeAllEventListeners();
2117         m_performance-&gt;removeAllObservers();
2118     }
2119 
2120     removeAllUnloadEventListeners(this);
2121     removeAllBeforeUnloadEventListeners(this);
2122 }
2123 
2124 void DOMWindow::captureEvents()
2125 {
2126     // Not implemented.
2127 }
2128 
2129 void DOMWindow::releaseEvents()
2130 {
2131     // Not implemented.
2132 }
2133 
2134 void DOMWindow::finishedLoading()
2135 {
2136     if (m_shouldPrintWhenFinishedLoading) {
2137         m_shouldPrintWhenFinishedLoading = false;
2138         if (frame()-&gt;loader().activeDocumentLoader()-&gt;mainDocumentError().isNull())
2139             print();
2140     }
2141 }
2142 
2143 void DOMWindow::setLocation(DOMWindow&amp; activeWindow, const URL&amp; completedURL, SetLocationLocking locking)
2144 {
2145     if (!isCurrentlyDisplayedInFrame())
2146         return;
2147 
2148     Document* activeDocument = activeWindow.document();
2149     if (!activeDocument)
2150         return;
2151 
2152     auto* frame = this-&gt;frame();
2153     if (!activeDocument-&gt;canNavigate(frame, completedURL))
2154         return;
2155 
2156     if (isInsecureScriptAccess(activeWindow, completedURL))
2157         return;
2158 
2159     // We want a new history item if we are processing a user gesture.
2160     LockHistory lockHistory = (locking != LockHistoryBasedOnGestureState || !UserGestureIndicator::processingUserGesture()) ? LockHistory::Yes : LockHistory::No;
2161     LockBackForwardList lockBackForwardList = (locking != LockHistoryBasedOnGestureState) ? LockBackForwardList::Yes : LockBackForwardList::No;
2162     frame-&gt;navigationScheduler().scheduleLocationChange(*activeDocument, activeDocument-&gt;securityOrigin(),
2163         // FIXME: What if activeDocument()-&gt;frame() is 0?
2164         completedURL, activeDocument-&gt;frame()-&gt;loader().outgoingReferrer(),
2165         lockHistory, lockBackForwardList);
2166 }
2167 
2168 void DOMWindow::printErrorMessage(const String&amp; message)
2169 {
2170     if (message.isEmpty())
2171         return;
2172 
2173     if (PageConsoleClient* pageConsole = console())
2174         pageConsole-&gt;addMessage(MessageSource::JS, MessageLevel::Error, message);
2175 }
2176 
2177 String DOMWindow::crossDomainAccessErrorMessage(const DOMWindow&amp; activeWindow, IncludeTargetOrigin includeTargetOrigin)
2178 {
2179     const URL&amp; activeWindowURL = activeWindow.document()-&gt;url();
2180     if (activeWindowURL.isNull())
2181         return String();
2182 
2183     ASSERT(!activeWindow.document()-&gt;securityOrigin().canAccess(document()-&gt;securityOrigin()));
2184 
2185     // FIXME: This message, and other console messages, have extra newlines. Should remove them.
2186     SecurityOrigin&amp; activeOrigin = activeWindow.document()-&gt;securityOrigin();
2187     SecurityOrigin&amp; targetOrigin = document()-&gt;securityOrigin();
2188     String message;
2189     if (includeTargetOrigin == IncludeTargetOrigin::Yes)
2190         message = makeString(&quot;Blocked a frame with origin \&quot;&quot;, activeOrigin.toString(), &quot;\&quot; from accessing a frame with origin \&quot;&quot;, targetOrigin.toString(), &quot;\&quot;. &quot;);
2191     else
2192         message = makeString(&quot;Blocked a frame with origin \&quot;&quot;, activeOrigin.toString(), &quot;\&quot; from accessing a cross-origin frame. &quot;);
2193 
2194     // Sandbox errors: Use the origin of the frames&#39; location, rather than their actual origin (since we know that at least one will be &quot;null&quot;).
2195     URL activeURL = activeWindow.document()-&gt;url();
2196     URL targetURL = document()-&gt;url();
2197     if (document()-&gt;isSandboxed(SandboxOrigin) || activeWindow.document()-&gt;isSandboxed(SandboxOrigin)) {
2198         if (includeTargetOrigin == IncludeTargetOrigin::Yes)
2199             message = makeString(&quot;Blocked a frame at \&quot;&quot;, SecurityOrigin::create(activeURL).get().toString(), &quot;\&quot; from accessing a frame at \&quot;&quot;, SecurityOrigin::create(targetURL).get().toString(), &quot;\&quot;. &quot;);
2200         else
2201             message = makeString(&quot;Blocked a frame at \&quot;&quot;, SecurityOrigin::create(activeURL).get().toString(), &quot;\&quot; from accessing a cross-origin frame. &quot;);
2202 
2203         if (document()-&gt;isSandboxed(SandboxOrigin) &amp;&amp; activeWindow.document()-&gt;isSandboxed(SandboxOrigin))
2204             return makeString(&quot;Sandbox access violation: &quot;, message, &quot; Both frames are sandboxed and lack the \&quot;allow-same-origin\&quot; flag.&quot;);
2205         if (document()-&gt;isSandboxed(SandboxOrigin))
2206             return makeString(&quot;Sandbox access violation: &quot;, message, &quot; The frame being accessed is sandboxed and lacks the \&quot;allow-same-origin\&quot; flag.&quot;);
2207         return makeString(&quot;Sandbox access violation: &quot;, message, &quot; The frame requesting access is sandboxed and lacks the \&quot;allow-same-origin\&quot; flag.&quot;);
2208     }
2209 
2210     if (includeTargetOrigin == IncludeTargetOrigin::Yes) {
2211         // Protocol errors: Use the URL&#39;s protocol rather than the origin&#39;s protocol so that we get a useful message for non-heirarchal URLs like &#39;data:&#39;.
2212         if (targetOrigin.protocol() != activeOrigin.protocol())
2213             return message + &quot; The frame requesting access has a protocol of \&quot;&quot; + activeURL.protocol() + &quot;\&quot;, the frame being accessed has a protocol of \&quot;&quot; + targetURL.protocol() + &quot;\&quot;. Protocols must match.\n&quot;;
2214 
2215         // &#39;document.domain&#39; errors.
2216         if (targetOrigin.domainWasSetInDOM() &amp;&amp; activeOrigin.domainWasSetInDOM())
2217             return message + &quot;The frame requesting access set \&quot;document.domain\&quot; to \&quot;&quot; + activeOrigin.domain() + &quot;\&quot;, the frame being accessed set it to \&quot;&quot; + targetOrigin.domain() + &quot;\&quot;. Both must set \&quot;document.domain\&quot; to the same value to allow access.&quot;;
2218         if (activeOrigin.domainWasSetInDOM())
2219             return message + &quot;The frame requesting access set \&quot;document.domain\&quot; to \&quot;&quot; + activeOrigin.domain() + &quot;\&quot;, but the frame being accessed did not. Both must set \&quot;document.domain\&quot; to the same value to allow access.&quot;;
2220         if (targetOrigin.domainWasSetInDOM())
2221             return message + &quot;The frame being accessed set \&quot;document.domain\&quot; to \&quot;&quot; + targetOrigin.domain() + &quot;\&quot;, but the frame requesting access did not. Both must set \&quot;document.domain\&quot; to the same value to allow access.&quot;;
2222     }
2223 
2224     // Default.
2225     return message + &quot;Protocols, domains, and ports must match.&quot;;
2226 }
2227 
2228 bool DOMWindow::isInsecureScriptAccess(DOMWindow&amp; activeWindow, const String&amp; urlString)
2229 {
2230     if (!WTF::protocolIsJavaScript(urlString))
2231         return false;
2232 
2233     // If this DOMWindow isn&#39;t currently active in the Frame, then there&#39;s no
2234     // way we should allow the access.
2235     // FIXME: Remove this check if we&#39;re able to disconnect DOMWindow from
2236     // Frame on navigation: https://bugs.webkit.org/show_bug.cgi?id=62054
2237     if (isCurrentlyDisplayedInFrame()) {
2238         // FIXME: Is there some way to eliminate the need for a separate &quot;activeWindow == this&quot; check?
2239         if (&amp;activeWindow == this)
2240             return false;
2241 
2242         // FIXME: The name canAccess seems to be a roundabout way to ask &quot;can execute script&quot;.
2243         // Can we name the SecurityOrigin function better to make this more clear?
2244         if (activeWindow.document()-&gt;securityOrigin().canAccess(document()-&gt;securityOrigin()))
2245             return false;
2246     }
2247 
2248     printErrorMessage(crossDomainAccessErrorMessage(activeWindow, IncludeTargetOrigin::Yes));
2249     return true;
2250 }
2251 
2252 ExceptionOr&lt;RefPtr&lt;Frame&gt;&gt; DOMWindow::createWindow(const String&amp; urlString, const AtomicString&amp; frameName, const WindowFeatures&amp; windowFeatures, DOMWindow&amp; activeWindow, Frame&amp; firstFrame, Frame&amp; openerFrame, const WTF::Function&lt;void(DOMWindow&amp;)&gt;&amp; prepareDialogFunction)
2253 {
2254     Frame* activeFrame = activeWindow.frame();
2255     if (!activeFrame)
2256         return RefPtr&lt;Frame&gt; { nullptr };
2257 
2258     Document* activeDocument = activeWindow.document();
2259     if (!activeDocument)
2260         return RefPtr&lt;Frame&gt; { nullptr };
2261 
2262     URL completedURL = urlString.isEmpty() ? URL({ }, emptyString()) : firstFrame.document()-&gt;completeURL(urlString);
2263     if (!completedURL.isEmpty() &amp;&amp; !completedURL.isValid())
2264         return Exception { SyntaxError };
2265 
2266     // For whatever reason, Firefox uses the first frame to determine the outgoingReferrer. We replicate that behavior here.
2267     String referrer = SecurityPolicy::generateReferrerHeader(firstFrame.document()-&gt;referrerPolicy(), completedURL, firstFrame.loader().outgoingReferrer());
2268     auto initiatedByMainFrame = activeFrame-&gt;isMainFrame() ? InitiatedByMainFrame::Yes : InitiatedByMainFrame::Unknown;
2269 
2270     ResourceRequest resourceRequest { completedURL, referrer };
2271     FrameLoader::addHTTPOriginIfNeeded(resourceRequest, firstFrame.loader().outgoingOrigin());
2272     FrameLoadRequest frameLoadRequest { *activeDocument, activeDocument-&gt;securityOrigin(), resourceRequest, frameName, LockHistory::No, LockBackForwardList::No, MaybeSendReferrer, AllowNavigationToInvalidURL::Yes, NewFrameOpenerPolicy::Allow, activeDocument-&gt;shouldOpenExternalURLsPolicyToPropagate(), initiatedByMainFrame };
2273 
2274     // We pass the opener frame for the lookupFrame in case the active frame is different from
2275     // the opener frame, and the name references a frame relative to the opener frame.
2276     bool created;
2277     auto newFrame = WebCore::createWindow(*activeFrame, openerFrame, WTFMove(frameLoadRequest), windowFeatures, created);
2278     if (!newFrame)
2279         return RefPtr&lt;Frame&gt; { nullptr };
2280 
2281     if (!windowFeatures.noopener)
2282         newFrame-&gt;loader().setOpener(&amp;openerFrame);
2283 
2284     if (created)
2285         newFrame-&gt;page()-&gt;setOpenedByDOM();
2286 
2287     if (newFrame-&gt;document()-&gt;domWindow()-&gt;isInsecureScriptAccess(activeWindow, completedURL))
2288         return windowFeatures.noopener ? RefPtr&lt;Frame&gt; { nullptr } : newFrame;
2289 
2290     if (prepareDialogFunction)
2291         prepareDialogFunction(*newFrame-&gt;document()-&gt;domWindow());
2292 
2293     if (created) {
2294         ResourceRequest resourceRequest { completedURL, referrer, ResourceRequestCachePolicy::UseProtocolCachePolicy };
2295         FrameLoader::addSameSiteInfoToRequestIfNeeded(resourceRequest, openerFrame.document());
2296         FrameLoadRequest frameLoadRequest { *activeWindow.document(), activeWindow.document()-&gt;securityOrigin(), resourceRequest, &quot;_self&quot;_s, LockHistory::No, LockBackForwardList::No, MaybeSendReferrer, AllowNavigationToInvalidURL::Yes, NewFrameOpenerPolicy::Allow, activeDocument-&gt;shouldOpenExternalURLsPolicyToPropagate(), initiatedByMainFrame };
2297         newFrame-&gt;loader().changeLocation(WTFMove(frameLoadRequest));
2298     } else if (!urlString.isEmpty()) {
2299         LockHistory lockHistory = UserGestureIndicator::processingUserGesture() ? LockHistory::No : LockHistory::Yes;
2300         newFrame-&gt;navigationScheduler().scheduleLocationChange(*activeDocument, activeDocument-&gt;securityOrigin(), completedURL, referrer, lockHistory, LockBackForwardList::No);
2301     }
2302 
2303     // Navigating the new frame could result in it being detached from its page by a navigation policy delegate.
2304     if (!newFrame-&gt;page())
2305         return RefPtr&lt;Frame&gt; { nullptr };
2306 
2307     return windowFeatures.noopener ? RefPtr&lt;Frame&gt; { nullptr } : newFrame;
2308 }
2309 
2310 ExceptionOr&lt;RefPtr&lt;WindowProxy&gt;&gt; DOMWindow::open(DOMWindow&amp; activeWindow, DOMWindow&amp; firstWindow, const String&amp; urlString, const AtomicString&amp; frameName, const String&amp; windowFeaturesString)
2311 {
2312     if (!isCurrentlyDisplayedInFrame())
2313         return RefPtr&lt;WindowProxy&gt; { nullptr };
2314 
2315     auto* activeDocument = activeWindow.document();
2316     if (!activeDocument)
2317         return RefPtr&lt;WindowProxy&gt; { nullptr };
2318 
2319     auto* firstFrame = firstWindow.frame();
2320     if (!firstFrame)
2321         return RefPtr&lt;WindowProxy&gt; { nullptr };
2322 
2323 #if ENABLE(CONTENT_EXTENSIONS)
2324     if (firstFrame-&gt;document()
2325         &amp;&amp; firstFrame-&gt;page()
2326         &amp;&amp; firstFrame-&gt;mainFrame().document()
2327         &amp;&amp; firstFrame-&gt;mainFrame().document()-&gt;loader()) {
2328         ResourceLoadInfo resourceLoadInfo { firstFrame-&gt;document()-&gt;completeURL(urlString), firstFrame-&gt;mainFrame().document()-&gt;url(), ResourceType::Popup };
2329         for (auto&amp; action : firstFrame-&gt;page()-&gt;userContentProvider().actionsForResourceLoad(resourceLoadInfo, *firstFrame-&gt;mainFrame().document()-&gt;loader()).first) {
2330             if (action.type() == ContentExtensions::ActionType::BlockLoad)
2331                 return RefPtr&lt;WindowProxy&gt; { nullptr };
2332         }
2333     }
2334 #endif
2335 
2336     auto* frame = this-&gt;frame();
2337     if (!firstWindow.allowPopUp()) {
2338         // Because FrameTree::findFrameForNavigation() returns true for empty strings, we must check for empty frame names.
2339         // Otherwise, illegitimate window.open() calls with no name will pass right through the popup blocker.
2340         if (frameName.isEmpty() || !frame-&gt;loader().findFrameForNavigation(frameName, activeDocument))
2341             return RefPtr&lt;WindowProxy&gt; { nullptr };
2342     }
2343 
2344     // Get the target frame for the special cases of _top and _parent.
2345     // In those cases, we schedule a location change right now and return early.
2346     Frame* targetFrame = nullptr;
2347     if (equalIgnoringASCIICase(frameName, &quot;_top&quot;))
2348         targetFrame = &amp;frame-&gt;tree().top();
2349     else if (equalIgnoringASCIICase(frameName, &quot;_parent&quot;)) {
2350         if (Frame* parent = frame-&gt;tree().parent())
2351             targetFrame = parent;
2352         else
2353             targetFrame = frame;
2354     }
2355     if (targetFrame) {
2356         if (!activeDocument-&gt;canNavigate(targetFrame))
2357             return RefPtr&lt;WindowProxy&gt; { nullptr };
2358 
2359         URL completedURL = firstFrame-&gt;document()-&gt;completeURL(urlString);
2360 
2361         if (targetFrame-&gt;document()-&gt;domWindow()-&gt;isInsecureScriptAccess(activeWindow, completedURL))
2362             return &amp;targetFrame-&gt;windowProxy();
2363 
2364         if (urlString.isEmpty())
2365             return &amp;targetFrame-&gt;windowProxy();
2366 
2367         // For whatever reason, Firefox uses the first window rather than the active window to
2368         // determine the outgoing referrer. We replicate that behavior here.
2369         LockHistory lockHistory = UserGestureIndicator::processingUserGesture() ? LockHistory::No : LockHistory::Yes;
2370         targetFrame-&gt;navigationScheduler().scheduleLocationChange(*activeDocument, activeDocument-&gt;securityOrigin(), completedURL, firstFrame-&gt;loader().outgoingReferrer(),
2371             lockHistory, LockBackForwardList::No);
2372         return &amp;targetFrame-&gt;windowProxy();
2373     }
2374 
2375     auto newFrameOrException = createWindow(urlString, frameName, parseWindowFeatures(windowFeaturesString), activeWindow, *firstFrame, *frame);
2376     if (newFrameOrException.hasException())
2377         return newFrameOrException.releaseException();
2378 
2379     auto newFrame = newFrameOrException.releaseReturnValue();
2380     return newFrame ? &amp;newFrame-&gt;windowProxy() : RefPtr&lt;WindowProxy&gt; { nullptr };
2381 }
2382 
2383 void DOMWindow::showModalDialog(const String&amp; urlString, const String&amp; dialogFeaturesString, DOMWindow&amp; activeWindow, DOMWindow&amp; firstWindow, const WTF::Function&lt;void (DOMWindow&amp;)&gt;&amp; prepareDialogFunction)
2384 {
2385     if (!isCurrentlyDisplayedInFrame())
2386         return;
2387     if (!activeWindow.frame())
2388         return;
2389     Frame* firstFrame = firstWindow.frame();
2390     if (!firstFrame)
2391         return;
2392 
2393     auto* frame = this-&gt;frame();
2394     auto* page = frame-&gt;page();
2395     if (!page)
2396         return;
2397 
2398     if (!page-&gt;arePromptsAllowed()) {
2399         printErrorMessage(&quot;Use of window.showModalDialog is not allowed while unloading a page.&quot;);
2400         return;
2401     }
2402 
2403     if (!canShowModalDialog(*frame) || !firstWindow.allowPopUp())
2404         return;
2405 
2406     auto dialogFrameOrException = createWindow(urlString, emptyAtom(), parseDialogFeatures(dialogFeaturesString, screenAvailableRect(frame-&gt;view())), activeWindow, *firstFrame, *frame, prepareDialogFunction);
2407     if (dialogFrameOrException.hasException())
2408         return;
2409     RefPtr&lt;Frame&gt; dialogFrame = dialogFrameOrException.releaseReturnValue();
2410     if (!dialogFrame)
2411         return;
2412     dialogFrame-&gt;page()-&gt;chrome().runModal();
2413 }
2414 
2415 void DOMWindow::enableSuddenTermination()
2416 {
2417     if (Page* page = this-&gt;page())
2418         page-&gt;chrome().enableSuddenTermination();
2419 }
2420 
2421 void DOMWindow::disableSuddenTermination()
2422 {
2423     if (Page* page = this-&gt;page())
2424         page-&gt;chrome().disableSuddenTermination();
2425 }
2426 
2427 Frame* DOMWindow::frame() const
2428 {
2429     auto* document = this-&gt;document();
2430     return document ? document-&gt;frame() : nullptr;
2431 }
2432 
2433 } // namespace WebCore
    </pre>
  </body>
</html>