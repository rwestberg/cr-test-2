<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGFixupPhase.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="DFGDriver.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DFGFlowIndexing.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGFixupPhase.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (C) 2012-2018 Apple Inc. All rights reserved.</span>
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  * 1. Redistributions of source code must retain the above copyright
   8  *    notice, this list of conditions and the following disclaimer.
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
</pre>
<hr />
<pre>
  58 
  59         while (m_profitabilityChanged) {
  60             m_profitabilityChanged = false;
  61 
  62             for (unsigned i = m_graph.m_argumentPositions.size(); i--;)
  63                 m_graph.m_argumentPositions[i].mergeArgumentUnboxingAwareness();
  64 
  65             for (BlockIndex blockIndex = 0; blockIndex &lt; m_graph.numBlocks(); ++blockIndex)
  66                 fixupGetAndSetLocalsInBlock(m_graph.block(blockIndex));
  67         }
  68 
  69         for (BlockIndex blockIndex = 0; blockIndex &lt; m_graph.numBlocks(); ++blockIndex)
  70             fixupChecksInBlock(m_graph.block(blockIndex));
  71 
  72         m_graph.m_planStage = PlanStage::AfterFixup;
  73 
  74         return true;
  75     }
  76 
  77 private:
<span class="line-removed">  78     void fixupArithDiv(Node* node, Edge&amp; leftChild, Edge&amp; rightChild)</span>
<span class="line-removed">  79     {</span>
<span class="line-removed">  80         if (m_graph.binaryArithShouldSpeculateInt32(node, FixupPass)) {</span>
<span class="line-removed">  81             if (optimizeForX86() || optimizeForARM64() || optimizeForARMv7IDIVSupported()) {</span>
<span class="line-removed">  82                 fixIntOrBooleanEdge(leftChild);</span>
<span class="line-removed">  83                 fixIntOrBooleanEdge(rightChild);</span>
<span class="line-removed">  84                 if (bytecodeCanTruncateInteger(node-&gt;arithNodeFlags()))</span>
<span class="line-removed">  85                     node-&gt;setArithMode(Arith::Unchecked);</span>
<span class="line-removed">  86                 else if (bytecodeCanIgnoreNegativeZero(node-&gt;arithNodeFlags()))</span>
<span class="line-removed">  87                     node-&gt;setArithMode(Arith::CheckOverflow);</span>
<span class="line-removed">  88                 else</span>
<span class="line-removed">  89                     node-&gt;setArithMode(Arith::CheckOverflowAndNegativeZero);</span>
<span class="line-removed">  90                 return;</span>
<span class="line-removed">  91             }</span>
<span class="line-removed">  92 </span>
<span class="line-removed">  93             // This will cause conversion nodes to be inserted later.</span>
<span class="line-removed">  94             fixDoubleOrBooleanEdge(leftChild);</span>
<span class="line-removed">  95             fixDoubleOrBooleanEdge(rightChild);</span>
<span class="line-removed">  96 </span>
<span class="line-removed">  97             // We don&#39;t need to do ref&#39;ing on the children because we&#39;re stealing them from</span>
<span class="line-removed">  98             // the original division.</span>
<span class="line-removed">  99             Node* newDivision = m_insertionSet.insertNode(m_indexInBlock, SpecBytecodeDouble, *node);</span>
<span class="line-removed"> 100             newDivision-&gt;setResult(NodeResultDouble);</span>
 101 
<span class="line-modified"> 102             node-&gt;setOp(DoubleAsInt32);</span>
<span class="line-modified"> 103             node-&gt;children.initialize(Edge(newDivision, DoubleRepUse), Edge(), Edge());</span>
<span class="line-modified"> 104             if (bytecodeCanIgnoreNegativeZero(node-&gt;arithNodeFlags()))</span>





 105                 node-&gt;setArithMode(Arith::CheckOverflow);
 106             else
 107                 node-&gt;setArithMode(Arith::CheckOverflowAndNegativeZero);
 108             return;
 109         }
 110 





































 111         fixDoubleOrBooleanEdge(leftChild);
 112         fixDoubleOrBooleanEdge(rightChild);
 113         node-&gt;setResult(NodeResultDouble);
 114     }
 115 
 116     void fixupArithMul(Node* node, Edge&amp; leftChild, Edge&amp; rightChild)
 117     {
 118         if (m_graph.binaryArithShouldSpeculateInt32(node, FixupPass)) {
 119             fixIntOrBooleanEdge(leftChild);
 120             fixIntOrBooleanEdge(rightChild);
 121             if (bytecodeCanTruncateInteger(node-&gt;arithNodeFlags()))
 122                 node-&gt;setArithMode(Arith::Unchecked);
 123             else if (bytecodeCanIgnoreNegativeZero(node-&gt;arithNodeFlags()) || leftChild.node() == rightChild.node())
 124                 node-&gt;setArithMode(Arith::CheckOverflow);
 125             else
 126                 node-&gt;setArithMode(Arith::CheckOverflowAndNegativeZero);
 127             return;
 128         }
<span class="line-modified"> 129         if (m_graph.binaryArithShouldSpeculateAnyInt(node, FixupPass)) {</span>
 130             fixEdge&lt;Int52RepUse&gt;(leftChild);
 131             fixEdge&lt;Int52RepUse&gt;(rightChild);
 132             if (bytecodeCanIgnoreNegativeZero(node-&gt;arithNodeFlags()) || leftChild.node() == rightChild.node())
 133                 node-&gt;setArithMode(Arith::CheckOverflow);
 134             else
 135                 node-&gt;setArithMode(Arith::CheckOverflowAndNegativeZero);
 136             node-&gt;setResult(NodeResultInt52);
 137             return;
 138         }
 139 
 140         fixDoubleOrBooleanEdge(leftChild);
 141         fixDoubleOrBooleanEdge(rightChild);
 142         node-&gt;setResult(NodeResultDouble);
 143     }
 144 
 145     void fixupBlock(BasicBlock* block)
 146     {
 147         if (!block)
 148             return;
 149         ASSERT(block-&gt;isReachable);
</pre>
<hr />
<pre>
 179                 fixEdge&lt;UntypedUse&gt;(child1);
 180                 fixEdge&lt;UntypedUse&gt;(child2);
 181                 break;
 182             }
 183 
 184             if (attemptToMakeIntegerAdd(node)) {
 185                 // FIXME: Clear ArithSub&#39;s NodeMustGenerate when ArithMode is unchecked
 186                 // https://bugs.webkit.org/show_bug.cgi?id=190607
 187                 node-&gt;setOp(ArithSub);
 188                 break;
 189             }
 190 
 191             fixDoubleOrBooleanEdge(node-&gt;child1());
 192             fixDoubleOrBooleanEdge(node-&gt;child2());
 193             node-&gt;setOp(ArithSub);
 194             node-&gt;setResult(NodeResultDouble);
 195 
 196             break;
 197         }
 198 

 199         case ValueBitXor:
 200         case ValueBitOr:
 201         case ValueBitAnd: {
 202             if (Node::shouldSpeculateBigInt(node-&gt;child1().node(), node-&gt;child2().node())) {
 203                 fixEdge&lt;BigIntUse&gt;(node-&gt;child1());
 204                 fixEdge&lt;BigIntUse&gt;(node-&gt;child2());

 205                 break;
 206             }
 207 
 208             if (Node::shouldSpeculateUntypedForBitOps(node-&gt;child1().node(), node-&gt;child2().node())) {
 209                 fixEdge&lt;UntypedUse&gt;(node-&gt;child1());
 210                 fixEdge&lt;UntypedUse&gt;(node-&gt;child2());
 211                 break;
 212             }
 213 
<span class="line-removed"> 214             // In such case, we need to fallback to ArithBitOp</span>
 215             switch (op) {
 216             case ValueBitXor:
 217                 node-&gt;setOp(ArithBitXor);
 218                 break;
 219             case ValueBitOr:
 220                 node-&gt;setOp(ArithBitOr);
 221                 break;
 222             case ValueBitAnd:
 223                 node-&gt;setOp(ArithBitAnd);
 224                 break;



 225             default:
 226                 DFG_CRASH(m_graph, node, &quot;Unexpected node during ValueBit operation fixup&quot;);
 227                 break;
 228             }
 229 
 230             node-&gt;clearFlags(NodeMustGenerate);
 231             node-&gt;setResult(NodeResultInt32);
 232             fixIntConvertingEdge(node-&gt;child1());
 233             fixIntConvertingEdge(node-&gt;child2());
 234             break;
 235         }
 236 
<span class="line-modified"> 237         case ArithBitNot: {</span>
<span class="line-modified"> 238             if (node-&gt;child1().node()-&gt;shouldSpeculateUntypedForBitOps()) {</span>
<span class="line-modified"> 239                 fixEdge&lt;UntypedUse&gt;(node-&gt;child1());</span>
<span class="line-modified"> 240                 break;</span>









 241             }


 242 
<span class="line-modified"> 243             fixIntConvertingEdge(node-&gt;child1());</span>
<span class="line-modified"> 244             node-&gt;clearFlags(NodeMustGenerate);</span>


 245             break;
 246         }
 247 

 248         case ArithBitXor:
 249         case ArithBitOr:
 250         case ArithBitAnd: {
 251             fixIntConvertingEdge(node-&gt;child1());
 252             fixIntConvertingEdge(node-&gt;child2());
 253             break;
 254         }
 255 
 256         case BitRShift:
<span class="line-removed"> 257         case BitLShift:</span>
 258         case BitURShift: {
 259             if (Node::shouldSpeculateUntypedForBitOps(node-&gt;child1().node(), node-&gt;child2().node())) {
 260                 fixEdge&lt;UntypedUse&gt;(node-&gt;child1());
 261                 fixEdge&lt;UntypedUse&gt;(node-&gt;child2());
 262                 break;
 263             }
 264             fixIntConvertingEdge(node-&gt;child1());
 265             fixIntConvertingEdge(node-&gt;child2());
 266             break;
 267         }
 268 
 269         case ArithIMul: {
 270             fixIntConvertingEdge(node-&gt;child1());
 271             fixIntConvertingEdge(node-&gt;child2());
 272             node-&gt;setOp(ArithMul);
 273             node-&gt;setArithMode(Arith::Unchecked);
 274             node-&gt;child1().setUseKind(Int32Use);
 275             node-&gt;child2().setUseKind(Int32Use);
 276             break;
 277         }
</pre>
<hr />
<pre>
 296                 node-&gt;setResult(enableInt52() ? NodeResultInt52 : NodeResultDouble);
 297             }
 298             break;
 299         }
 300 
 301         case ValueNegate: {
 302             if (node-&gt;child1()-&gt;shouldSpeculateInt32OrBoolean() &amp;&amp; node-&gt;canSpeculateInt32(FixupPass)) {
 303                 node-&gt;setOp(ArithNegate);
 304                 fixIntOrBooleanEdge(node-&gt;child1());
 305                 if (bytecodeCanTruncateInteger(node-&gt;arithNodeFlags()))
 306                     node-&gt;setArithMode(Arith::Unchecked);
 307                 else if (bytecodeCanIgnoreNegativeZero(node-&gt;arithNodeFlags()))
 308                     node-&gt;setArithMode(Arith::CheckOverflow);
 309                 else
 310                     node-&gt;setArithMode(Arith::CheckOverflowAndNegativeZero);
 311                 node-&gt;setResult(NodeResultInt32);
 312                 node-&gt;clearFlags(NodeMustGenerate);
 313                 break;
 314             }
 315 
<span class="line-modified"> 316             if (m_graph.unaryArithShouldSpeculateAnyInt(node, FixupPass)) {</span>
 317                 node-&gt;setOp(ArithNegate);
 318                 fixEdge&lt;Int52RepUse&gt;(node-&gt;child1());
 319                 if (bytecodeCanIgnoreNegativeZero(node-&gt;arithNodeFlags()))
 320                     node-&gt;setArithMode(Arith::CheckOverflow);
 321                 else
 322                     node-&gt;setArithMode(Arith::CheckOverflowAndNegativeZero);
 323                 node-&gt;setResult(NodeResultInt52);
 324                 node-&gt;clearFlags(NodeMustGenerate);
 325                 break;
 326             }
 327             if (node-&gt;child1()-&gt;shouldSpeculateNotCell()) {
 328                 node-&gt;setOp(ArithNegate);
 329                 fixDoubleOrBooleanEdge(node-&gt;child1());
 330                 node-&gt;setResult(NodeResultDouble);
 331                 node-&gt;clearFlags(NodeMustGenerate);
 332             } else {
 333                 fixEdge&lt;UntypedUse&gt;(node-&gt;child1());
 334                 node-&gt;setResult(NodeResultJS);
 335             }
 336             break;
</pre>
<hr />
<pre>
 420                 break;
 421             fixDoubleOrBooleanEdge(node-&gt;child1());
 422             fixDoubleOrBooleanEdge(node-&gt;child2());
 423             node-&gt;setResult(NodeResultDouble);
 424             break;
 425         }
 426 
 427         case ArithNegate: {
 428             if (node-&gt;child1()-&gt;shouldSpeculateInt32OrBoolean() &amp;&amp; node-&gt;canSpeculateInt32(FixupPass)) {
 429                 fixIntOrBooleanEdge(node-&gt;child1());
 430                 if (bytecodeCanTruncateInteger(node-&gt;arithNodeFlags()))
 431                     node-&gt;setArithMode(Arith::Unchecked);
 432                 else if (bytecodeCanIgnoreNegativeZero(node-&gt;arithNodeFlags()))
 433                     node-&gt;setArithMode(Arith::CheckOverflow);
 434                 else
 435                     node-&gt;setArithMode(Arith::CheckOverflowAndNegativeZero);
 436                 node-&gt;setResult(NodeResultInt32);
 437                 node-&gt;clearFlags(NodeMustGenerate);
 438                 break;
 439             }
<span class="line-modified"> 440             if (m_graph.unaryArithShouldSpeculateAnyInt(node, FixupPass)) {</span>
 441                 fixEdge&lt;Int52RepUse&gt;(node-&gt;child1());
 442                 if (bytecodeCanIgnoreNegativeZero(node-&gt;arithNodeFlags()))
 443                     node-&gt;setArithMode(Arith::CheckOverflow);
 444                 else
 445                     node-&gt;setArithMode(Arith::CheckOverflowAndNegativeZero);
 446                 node-&gt;setResult(NodeResultInt52);
 447                 node-&gt;clearFlags(NodeMustGenerate);
 448                 break;
 449             }
 450 
 451             fixDoubleOrBooleanEdge(node-&gt;child1());
 452             node-&gt;setResult(NodeResultDouble);
 453             node-&gt;clearFlags(NodeMustGenerate);
 454             break;
 455         }
 456 
 457         case ValueMul: {
 458             Edge&amp; leftChild = node-&gt;child1();
 459             Edge&amp; rightChild = node-&gt;child2();
 460 
 461             if (Node::shouldSpeculateBigInt(leftChild.node(), rightChild.node())) {
 462                 fixEdge&lt;BigIntUse&gt;(node-&gt;child1());
 463                 fixEdge&lt;BigIntUse&gt;(node-&gt;child2());

 464                 break;
 465             }
 466 
 467             // There are cases where we can have BigInt + Int32 operands reaching ValueMul.
 468             // Imagine the scenario where ValueMul was never executed, but we can predict types
 469             // reaching the node:
 470             //
 471             // 63: GetLocal(Check:Untyped:@72, JS|MustGen, NonBoolInt32, ...)  predicting NonBoolInt32
 472             // 64: GetLocal(Check:Untyped:@71, JS|MustGen, BigInt, ...)  predicting BigInt
 473             // 65: ValueMul(Check:Untyped:@63, Check:Untyped:@64, BigInt|BoolInt32|NonBoolInt32, ...)
 474             //
 475             // In such scenario, we need to emit ValueMul(Untyped, Untyped), so the runtime can throw
 476             // an exception whenever it gets excuted.
 477             if (Node::shouldSpeculateUntypedForArithmetic(leftChild.node(), rightChild.node())) {
 478                 fixEdge&lt;UntypedUse&gt;(leftChild);
 479                 fixEdge&lt;UntypedUse&gt;(rightChild);
 480                 break;
 481             }
 482 
 483             // At this point, all other possible specializations are only handled by ArithMul.
 484             node-&gt;setOp(ArithMul);
 485             node-&gt;setResult(NodeResultNumber);
 486             fixupArithMul(node, leftChild, rightChild);
 487             break;
 488         }
 489 
 490         case ArithMul: {
 491             Edge&amp; leftChild = node-&gt;child1();
 492             Edge&amp; rightChild = node-&gt;child2();
 493 
 494             fixupArithMul(node, leftChild, rightChild);
 495             break;
 496         }
 497 

 498         case ValueDiv: {
 499             Edge&amp; leftChild = node-&gt;child1();
 500             Edge&amp; rightChild = node-&gt;child2();
 501 
 502             if (Node::shouldSpeculateBigInt(leftChild.node(), rightChild.node())) {
 503                 fixEdge&lt;BigIntUse&gt;(leftChild);
 504                 fixEdge&lt;BigIntUse&gt;(rightChild);

 505                 break;
 506             }
 507 
 508             if (Node::shouldSpeculateUntypedForArithmetic(leftChild.node(), rightChild.node())) {
 509                 fixEdge&lt;UntypedUse&gt;(leftChild);
 510                 fixEdge&lt;UntypedUse&gt;(rightChild);
 511                 break;
 512             }
<span class="line-modified"> 513             node-&gt;setOp(ArithDiv);</span>





 514             node-&gt;setResult(NodeResultNumber);
 515             fixupArithDiv(node, leftChild, rightChild);
 516             break;
 517 
 518         }
 519 
 520         case ArithDiv:
 521         case ArithMod: {
 522             Edge&amp; leftChild = node-&gt;child1();
 523             Edge&amp; rightChild = node-&gt;child2();
 524 
 525             fixupArithDiv(node, leftChild, rightChild);
 526             break;
 527         }
 528 
 529         case ArithMin:
 530         case ArithMax: {
 531             if (m_graph.binaryArithShouldSpeculateInt32(node, FixupPass)) {
 532                 fixIntOrBooleanEdge(node-&gt;child1());
 533                 fixIntOrBooleanEdge(node-&gt;child2());
</pre>
<hr />
<pre>
 544                 &amp;&amp; node-&gt;canSpeculateInt32(FixupPass)) {
 545                 fixIntOrBooleanEdge(node-&gt;child1());
 546                 if (bytecodeCanTruncateInteger(node-&gt;arithNodeFlags()))
 547                     node-&gt;setArithMode(Arith::Unchecked);
 548                 else
 549                     node-&gt;setArithMode(Arith::CheckOverflow);
 550                 node-&gt;clearFlags(NodeMustGenerate);
 551                 node-&gt;setResult(NodeResultInt32);
 552                 break;
 553             }
 554 
 555             if (node-&gt;child1()-&gt;shouldSpeculateNotCell()) {
 556                 fixDoubleOrBooleanEdge(node-&gt;child1());
 557                 node-&gt;clearFlags(NodeMustGenerate);
 558             } else
 559                 fixEdge&lt;UntypedUse&gt;(node-&gt;child1());
 560             node-&gt;setResult(NodeResultDouble);
 561             break;
 562         }
 563 
<span class="line-modified"> 564         case ArithPow: {</span>
<span class="line-modified"> 565             if (node-&gt;child2()-&gt;shouldSpeculateInt32OrBooleanForArithmetic()) {</span>
<span class="line-modified"> 566                 fixDoubleOrBooleanEdge(node-&gt;child1());</span>
<span class="line-modified"> 567                 fixIntOrBooleanEdge(node-&gt;child2());</span>

 568                 break;
 569             }
 570 
<span class="line-modified"> 571             fixDoubleOrBooleanEdge(node-&gt;child1());</span>
<span class="line-modified"> 572             fixDoubleOrBooleanEdge(node-&gt;child2());</span>














 573             break;
 574         }
 575 
 576         case ArithRandom: {
 577             node-&gt;setResult(NodeResultDouble);
 578             break;
 579         }
 580 
 581         case ArithRound:
 582         case ArithFloor:
 583         case ArithCeil:
 584         case ArithTrunc: {
 585             if (node-&gt;child1()-&gt;shouldSpeculateInt32OrBoolean() &amp;&amp; m_graph.roundShouldSpeculateInt32(node, FixupPass)) {
 586                 fixIntOrBooleanEdge(node-&gt;child1());
 587                 insertCheck&lt;Int32Use&gt;(node-&gt;child1().node());
 588                 node-&gt;convertToIdentity();
 589                 break;
 590             }
 591             if (node-&gt;child1()-&gt;shouldSpeculateNotCell()) {
 592                 fixDoubleOrBooleanEdge(node-&gt;child1());
</pre>
<hr />
<pre>
 651         }
 652 
 653         case CompareEq:
 654         case CompareLess:
 655         case CompareLessEq:
 656         case CompareGreater:
 657         case CompareGreaterEq: {
 658             if (node-&gt;op() == CompareEq
 659                 &amp;&amp; Node::shouldSpeculateBoolean(node-&gt;child1().node(), node-&gt;child2().node())) {
 660                 fixEdge&lt;BooleanUse&gt;(node-&gt;child1());
 661                 fixEdge&lt;BooleanUse&gt;(node-&gt;child2());
 662                 node-&gt;clearFlags(NodeMustGenerate);
 663                 break;
 664             }
 665             if (Node::shouldSpeculateInt32OrBoolean(node-&gt;child1().node(), node-&gt;child2().node())) {
 666                 fixIntOrBooleanEdge(node-&gt;child1());
 667                 fixIntOrBooleanEdge(node-&gt;child2());
 668                 node-&gt;clearFlags(NodeMustGenerate);
 669                 break;
 670             }
<span class="line-modified"> 671             if (enableInt52()</span>
<span class="line-removed"> 672                 &amp;&amp; Node::shouldSpeculateAnyInt(node-&gt;child1().node(), node-&gt;child2().node())) {</span>
 673                 fixEdge&lt;Int52RepUse&gt;(node-&gt;child1());
 674                 fixEdge&lt;Int52RepUse&gt;(node-&gt;child2());
 675                 node-&gt;clearFlags(NodeMustGenerate);
 676                 break;
 677             }
 678             if (Node::shouldSpeculateNumberOrBoolean(node-&gt;child1().node(), node-&gt;child2().node())) {
 679                 fixDoubleOrBooleanEdge(node-&gt;child1());
 680                 fixDoubleOrBooleanEdge(node-&gt;child2());
 681             }
 682             if (node-&gt;op() != CompareEq
 683                 &amp;&amp; node-&gt;child1()-&gt;shouldSpeculateNotCell()
 684                 &amp;&amp; node-&gt;child2()-&gt;shouldSpeculateNotCell()) {
 685                 if (node-&gt;child1()-&gt;shouldSpeculateNumberOrBoolean())
 686                     fixDoubleOrBooleanEdge(node-&gt;child1());
 687                 else
 688                     fixEdge&lt;DoubleRepUse&gt;(node-&gt;child1());
 689                 if (node-&gt;child2()-&gt;shouldSpeculateNumberOrBoolean())
 690                     fixDoubleOrBooleanEdge(node-&gt;child2());
 691                 else
 692                     fixEdge&lt;DoubleRepUse&gt;(node-&gt;child2());
</pre>
<hr />
<pre>
 906             default:
 907                 fixEdge&lt;KnownCellUse&gt;(m_graph.varArgChild(node, 0));
 908                 fixEdge&lt;Int32Use&gt;(m_graph.varArgChild(node, 1));
 909                 break;
 910             }
 911 
 912             switch (arrayMode.type()) {
 913             case Array::Double:
 914                 if (!arrayMode.isOutOfBounds())
 915                     node-&gt;setResult(NodeResultDouble);
 916                 break;
 917 
 918             case Array::Float32Array:
 919             case Array::Float64Array:
 920                 node-&gt;setResult(NodeResultDouble);
 921                 break;
 922 
 923             case Array::Uint32Array:
 924                 if (node-&gt;shouldSpeculateInt32())
 925                     break;
<span class="line-modified"> 926                 if (node-&gt;shouldSpeculateAnyInt() &amp;&amp; enableInt52())</span>
 927                     node-&gt;setResult(NodeResultInt52);
 928                 else
 929                     node-&gt;setResult(NodeResultDouble);
 930                 break;
 931 
 932             default:
 933                 break;
 934             }
 935 
 936             break;
 937         }
 938 
 939         case PutByValDirect:
 940         case PutByVal:
 941         case PutByValAlias: {
 942             Edge&amp; child1 = m_graph.varArgChild(node, 0);
 943             Edge&amp; child2 = m_graph.varArgChild(node, 1);
 944             Edge&amp; child3 = m_graph.varArgChild(node, 2);
 945 
 946             node-&gt;setArrayMode(
</pre>
<hr />
<pre>
 985                 fixEdge&lt;KnownCellUse&gt;(child1);
 986                 fixEdge&lt;Int32Use&gt;(child2);
 987                 fixEdge&lt;Int32Use&gt;(child3);
 988                 break;
 989             case Array::Double:
 990                 fixEdge&lt;KnownCellUse&gt;(child1);
 991                 fixEdge&lt;Int32Use&gt;(child2);
 992                 fixEdge&lt;DoubleRepRealUse&gt;(child3);
 993                 break;
 994             case Array::Int8Array:
 995             case Array::Int16Array:
 996             case Array::Int32Array:
 997             case Array::Uint8Array:
 998             case Array::Uint8ClampedArray:
 999             case Array::Uint16Array:
1000             case Array::Uint32Array:
1001                 fixEdge&lt;KnownCellUse&gt;(child1);
1002                 fixEdge&lt;Int32Use&gt;(child2);
1003                 if (child3-&gt;shouldSpeculateInt32())
1004                     fixIntOrBooleanEdge(child3);
<span class="line-modified">1005                 else if (child3-&gt;shouldSpeculateAnyInt())</span>
1006                     fixEdge&lt;Int52RepUse&gt;(child3);
1007                 else
1008                     fixDoubleOrBooleanEdge(child3);
1009                 break;
1010             case Array::Float32Array:
1011             case Array::Float64Array:
1012                 fixEdge&lt;KnownCellUse&gt;(child1);
1013                 fixEdge&lt;Int32Use&gt;(child2);
1014                 fixDoubleOrBooleanEdge(child3);
1015                 break;
1016             case Array::Contiguous:
1017             case Array::ArrayStorage:
1018             case Array::SlowPutArrayStorage:
1019                 fixEdge&lt;KnownCellUse&gt;(child1);
1020                 fixEdge&lt;Int32Use&gt;(child2);
1021                 speculateForBarrier(child3);
1022                 break;
1023             default:
1024                 fixEdge&lt;KnownCellUse&gt;(child1);
1025                 fixEdge&lt;Int32Use&gt;(child2);
</pre>
<hr />
<pre>
1030 
1031         case AtomicsAdd:
1032         case AtomicsAnd:
1033         case AtomicsCompareExchange:
1034         case AtomicsExchange:
1035         case AtomicsLoad:
1036         case AtomicsOr:
1037         case AtomicsStore:
1038         case AtomicsSub:
1039         case AtomicsXor: {
1040             Edge&amp; base = m_graph.child(node, 0);
1041             Edge&amp; index = m_graph.child(node, 1);
1042 
1043             bool badNews = false;
1044             for (unsigned i = numExtraAtomicsArgs(node-&gt;op()); i--;) {
1045                 Edge&amp; child = m_graph.child(node, 2 + i);
1046                 // NOTE: DFG is not smart enough to handle double-&gt;int conversions in atomics. So, we
1047                 // just call the function when that happens. But the FTL is totally cool with those
1048                 // conversions.
1049                 if (!child-&gt;shouldSpeculateInt32()
<span class="line-modified">1050                     &amp;&amp; !child-&gt;shouldSpeculateAnyInt()</span>
1051                     &amp;&amp; !(child-&gt;shouldSpeculateNumberOrBoolean() &amp;&amp; m_graph.m_plan.isFTL()))
1052                     badNews = true;
1053             }
1054 
1055             if (badNews) {
1056                 node-&gt;setArrayMode(ArrayMode(Array::Generic, node-&gt;arrayMode().action()));
1057                 break;
1058             }
1059 
1060             node-&gt;setArrayMode(
1061                 node-&gt;arrayMode().refine(
1062                     m_graph, node, base-&gt;prediction(), index-&gt;prediction()));
1063 
1064             if (node-&gt;arrayMode().type() == Array::Generic)
1065                 break;
1066 
1067             for (unsigned i = numExtraAtomicsArgs(node-&gt;op()); i--;) {
1068                 Edge&amp; child = m_graph.child(node, 2 + i);
1069                 if (child-&gt;shouldSpeculateInt32())
1070                     fixIntOrBooleanEdge(child);
<span class="line-modified">1071                 else if (child-&gt;shouldSpeculateAnyInt())</span>
1072                     fixEdge&lt;Int52RepUse&gt;(child);
1073                 else {
1074                     RELEASE_ASSERT(child-&gt;shouldSpeculateNumberOrBoolean() &amp;&amp; m_graph.m_plan.isFTL());
1075                     fixDoubleOrBooleanEdge(child);
1076                 }
1077             }
1078 
1079             blessArrayOperation(base, index, m_graph.child(node, 2 + numExtraAtomicsArgs(node-&gt;op())));
1080             fixEdge&lt;CellUse&gt;(base);
1081             fixEdge&lt;Int32Use&gt;(index);
1082 
1083             if (node-&gt;arrayMode().type() == Array::Uint32Array) {
1084                 // NOTE: This means basically always doing Int52.
<span class="line-modified">1085                 if (node-&gt;shouldSpeculateAnyInt() &amp;&amp; enableInt52())</span>
1086                     node-&gt;setResult(NodeResultInt52);
1087                 else
1088                     node-&gt;setResult(NodeResultDouble);
1089             }
1090             break;
1091         }
1092 
1093         case AtomicsIsLockFree:
1094             if (node-&gt;child1()-&gt;shouldSpeculateInt32())
1095                 fixIntOrBooleanEdge(node-&gt;child1());
1096             break;
1097 
1098         case ArrayPush: {
1099             // May need to refine the array mode in case the value prediction contravenes
1100             // the array prediction. For example, we may have evidence showing that the
1101             // array is in Int32 mode, but the value we&#39;re storing is likely to be a double.
1102             // Then we should turn this into a conversion to Double array followed by the
1103             // push. On the other hand, we absolutely don&#39;t want to refine based on the
1104             // base prediction. If it has non-cell garbage in it, then we want that to be
1105             // ignored. That&#39;s because ArrayPush can&#39;t handle any array modes that aren&#39;t
</pre>
<hr />
<pre>
1119                         element-&gt;prediction()));
1120             }
1121             blessArrayOperation(arrayEdge, Edge(), storageEdge);
1122             fixEdge&lt;KnownCellUse&gt;(arrayEdge);
1123 
1124             // Convert `array.push()` to GetArrayLength.
1125             if (!elementCount &amp;&amp; node-&gt;arrayMode().supportsSelfLength()) {
1126                 node-&gt;setOpAndDefaultFlags(GetArrayLength);
1127                 node-&gt;child1() = arrayEdge;
1128                 node-&gt;child2() = storageEdge;
1129                 fixEdge&lt;KnownCellUse&gt;(node-&gt;child1());
1130                 break;
1131             }
1132 
1133             // We do not want to perform osr exit and retry for ArrayPush. We insert Check with appropriate type,
1134             // and ArrayPush uses the edge as known typed edge. Therefore, ArrayPush do not need to perform type checks.
1135             for (unsigned i = 0; i &lt; elementCount; ++i) {
1136                 Edge&amp; element = m_graph.varArgChild(node, i + elementOffset);
1137                 switch (node-&gt;arrayMode().type()) {
1138                 case Array::Int32:
<span class="line-modified">1139                     insertCheck&lt;Int32Use&gt;(element.node());</span>
<span class="line-removed">1140                     fixEdge&lt;KnownInt32Use&gt;(element);</span>
1141                     break;
1142                 case Array::Double:
<span class="line-modified">1143                     insertCheck&lt;DoubleRepRealUse&gt;(element.node());</span>
<span class="line-removed">1144                     fixEdge&lt;DoubleRepUse&gt;(element);</span>
1145                     break;
1146                 case Array::Contiguous:
1147                 case Array::ArrayStorage:
1148                     speculateForBarrier(element);
1149                     break;
1150                 default:
1151                     break;
1152                 }
<span class="line-removed">1153                 ASSERT(shouldNotHaveTypeCheck(element.useKind()));</span>
1154             }
1155             break;
1156         }
1157 
1158         case ArrayPop: {
1159             blessArrayOperation(node-&gt;child1(), Edge(), node-&gt;child2());
1160             fixEdge&lt;KnownCellUse&gt;(node-&gt;child1());
1161             break;
1162         }
1163 
1164         case ArraySlice: {
1165             fixEdge&lt;KnownCellUse&gt;(m_graph.varArgChild(node, 0));
1166             if (node-&gt;numChildren() &gt;= 3) {
1167                 fixEdge&lt;Int32Use&gt;(m_graph.varArgChild(node, 1));
1168                 if (node-&gt;numChildren() == 4)
1169                     fixEdge&lt;Int32Use&gt;(m_graph.varArgChild(node, 2));
1170             }
1171             break;
1172         }
1173 
</pre>
<hr />
<pre>
1492 
1493                 if (uid == vm().propertyNames-&gt;lastIndex.impl()
1494                     &amp;&amp; node-&gt;child1()-&gt;shouldSpeculateRegExpObject()) {
1495                     node-&gt;setOp(GetRegExpObjectLastIndex);
1496                     node-&gt;clearFlags(NodeMustGenerate);
1497                     fixEdge&lt;RegExpObjectUse&gt;(node-&gt;child1());
1498                     break;
1499                 }
1500             }
1501 
1502             if (node-&gt;child1()-&gt;shouldSpeculateNumber()) {
1503                 if (uid == vm().propertyNames-&gt;toString.impl()) {
1504                     if (m_graph.isWatchingNumberToStringWatchpoint(node)) {
1505                         JSGlobalObject* globalObject = m_graph.globalObjectFor(node-&gt;origin.semantic);
1506                         if (node-&gt;child1()-&gt;shouldSpeculateInt32()) {
1507                             insertCheck&lt;Int32Use&gt;(node-&gt;child1().node());
1508                             m_graph.convertToConstant(node, m_graph.freeze(globalObject-&gt;numberProtoToStringFunction()));
1509                             break;
1510                         }
1511 
<span class="line-modified">1512                         if (enableInt52() &amp;&amp; node-&gt;child1()-&gt;shouldSpeculateAnyInt()) {</span>
1513                             insertCheck&lt;Int52RepUse&gt;(node-&gt;child1().node());
1514                             m_graph.convertToConstant(node, m_graph.freeze(globalObject-&gt;numberProtoToStringFunction()));
1515                             break;
1516                         }
1517 
1518                         ASSERT(node-&gt;child1()-&gt;shouldSpeculateNumber());
1519                         insertCheck&lt;DoubleRepUse&gt;(node-&gt;child1().node());
1520                         m_graph.convertToConstant(node, m_graph.freeze(globalObject-&gt;numberProtoToStringFunction()));
1521                         break;
1522                     }
1523                 }
1524             }
1525 
1526             if (node-&gt;child1()-&gt;shouldSpeculateCell())
1527                 fixEdge&lt;CellUse&gt;(node-&gt;child1());
1528             break;
1529         }
1530 
1531         case GetByIdWithThis: {
1532             if (node-&gt;child1()-&gt;shouldSpeculateCell() &amp;&amp; node-&gt;child2()-&gt;shouldSpeculateCell()) {
</pre>
<hr />
<pre>
1838         }
1839         case HasGenericProperty: {
1840             fixEdge&lt;CellUse&gt;(node-&gt;child2());
1841             break;
1842         }
1843         case HasStructureProperty: {
1844             fixEdge&lt;StringUse&gt;(node-&gt;child2());
1845             fixEdge&lt;KnownCellUse&gt;(node-&gt;child3());
1846             break;
1847         }
1848         case HasIndexedProperty: {
1849             node-&gt;setArrayMode(
1850                 node-&gt;arrayMode().refine(
1851                     m_graph, node,
1852                     m_graph.varArgChild(node, 0)-&gt;prediction(),
1853                     m_graph.varArgChild(node, 1)-&gt;prediction(),
1854                     SpecNone));
1855 
1856             blessArrayOperation(m_graph.varArgChild(node, 0), m_graph.varArgChild(node, 1), m_graph.varArgChild(node, 2));
1857             fixEdge&lt;CellUse&gt;(m_graph.varArgChild(node, 0));
<span class="line-modified">1858             fixEdge&lt;KnownInt32Use&gt;(m_graph.varArgChild(node, 1));</span>
1859             break;
1860         }
1861         case GetDirectPname: {
1862             Edge&amp; base = m_graph.varArgChild(node, 0);
1863             Edge&amp; property = m_graph.varArgChild(node, 1);
1864             Edge&amp; index = m_graph.varArgChild(node, 2);
1865             Edge&amp; enumerator = m_graph.varArgChild(node, 3);
1866             fixEdge&lt;CellUse&gt;(base);
1867             fixEdge&lt;KnownCellUse&gt;(property);
<span class="line-modified">1868             fixEdge&lt;KnownInt32Use&gt;(index);</span>
1869             fixEdge&lt;KnownCellUse&gt;(enumerator);
1870             break;
1871         }
1872         case GetPropertyEnumerator: {
1873             if (node-&gt;child1()-&gt;shouldSpeculateCell())
1874                 fixEdge&lt;CellUse&gt;(node-&gt;child1());
1875             break;
1876         }
1877         case GetEnumeratorStructurePname: {
1878             fixEdge&lt;KnownCellUse&gt;(node-&gt;child1());
<span class="line-modified">1879             fixEdge&lt;KnownInt32Use&gt;(node-&gt;child2());</span>
1880             break;
1881         }
1882         case GetEnumeratorGenericPname: {
1883             fixEdge&lt;KnownCellUse&gt;(node-&gt;child1());
<span class="line-modified">1884             fixEdge&lt;KnownInt32Use&gt;(node-&gt;child2());</span>
1885             break;
1886         }
1887         case ToIndexString: {
<span class="line-modified">1888             fixEdge&lt;KnownInt32Use&gt;(node-&gt;child1());</span>
1889             break;
1890         }
1891         case ProfileType: {
1892             // We want to insert type checks based on the instructionTypeSet of the TypeLocation, not the globalTypeSet.
1893             // Because the instructionTypeSet is contained in globalTypeSet, if we produce a type check for
1894             // type T for the instructionTypeSet, the global type set must also have information for type T.
1895             // So if it the type check succeeds for type T in the instructionTypeSet, a type check for type T
1896             // in the globalTypeSet would&#39;ve also succeeded.
1897             // (The other direction does not hold in general).
1898 
1899             RefPtr&lt;TypeSet&gt; typeSet = node-&gt;typeLocation()-&gt;m_instructionTypeSet;
1900             RuntimeTypeMask seenTypes = typeSet-&gt;seenTypes();
1901             if (typeSet-&gt;doesTypeConformTo(TypeAnyInt)) {
1902                 if (node-&gt;child1()-&gt;shouldSpeculateInt32()) {
1903                     fixEdge&lt;Int32Use&gt;(node-&gt;child1());
1904                     node-&gt;remove(m_graph);
1905                     break;
1906                 }
1907 
1908                 if (enableInt52()) {
</pre>
<hr />
<pre>
1960 
1961         case PushWithScope: {
1962             // Child 1 is always the current scope, which is guaranteed to be an object
1963             // FIXME: should be KnownObjectUse once that exists (https://bugs.webkit.org/show_bug.cgi?id=175689)
1964             fixEdge&lt;KnownCellUse&gt;(node-&gt;child1());
1965             if (node-&gt;child2()-&gt;shouldSpeculateObject())
1966                 fixEdge&lt;ObjectUse&gt;(node-&gt;child2());
1967             break;
1968         }
1969 
1970         case SetFunctionName: {
1971             // The first child is guaranteed to be a cell because op_set_function_name is only used
1972             // on a newly instantiated function object (the first child).
1973             fixEdge&lt;KnownCellUse&gt;(node-&gt;child1());
1974             fixEdge&lt;UntypedUse&gt;(node-&gt;child2());
1975             break;
1976         }
1977 
1978         case CreateRest: {
1979             watchHavingABadTime(node);
<span class="line-modified">1980             fixEdge&lt;KnownInt32Use&gt;(node-&gt;child1());</span>
1981             break;
1982         }
1983 
1984         case ResolveScopeForHoistingFuncDeclInEval: {
1985             fixEdge&lt;KnownCellUse&gt;(node-&gt;child1());
1986             break;
1987         }
1988         case ResolveScope:
1989         case GetDynamicVar:
1990         case PutDynamicVar: {
1991             fixEdge&lt;KnownCellUse&gt;(node-&gt;child1());
1992             break;
1993         }
1994 
1995         case LogShadowChickenPrologue: {
1996             fixEdge&lt;KnownCellUse&gt;(node-&gt;child1());
1997             break;
1998         }
1999         case LogShadowChickenTail: {
2000             fixEdge&lt;UntypedUse&gt;(node-&gt;child1());
</pre>
<hr />
<pre>
2124 
2125         case WeakMapSet: {
2126             fixEdge&lt;WeakMapObjectUse&gt;(m_graph.varArgChild(node, 0));
2127             fixEdge&lt;ObjectUse&gt;(m_graph.varArgChild(node, 1));
2128             fixEdge&lt;Int32Use&gt;(m_graph.varArgChild(node, 3));
2129             break;
2130         }
2131 
2132         case DefineDataProperty: {
2133             fixEdge&lt;CellUse&gt;(m_graph.varArgChild(node, 0));
2134             Edge&amp; propertyEdge = m_graph.varArgChild(node, 1);
2135             if (propertyEdge-&gt;shouldSpeculateSymbol())
2136                 fixEdge&lt;SymbolUse&gt;(propertyEdge);
2137             else if (propertyEdge-&gt;shouldSpeculateStringIdent())
2138                 fixEdge&lt;StringIdentUse&gt;(propertyEdge);
2139             else if (propertyEdge-&gt;shouldSpeculateString())
2140                 fixEdge&lt;StringUse&gt;(propertyEdge);
2141             else
2142                 fixEdge&lt;UntypedUse&gt;(propertyEdge);
2143             fixEdge&lt;UntypedUse&gt;(m_graph.varArgChild(node, 2));
<span class="line-modified">2144             fixEdge&lt;KnownInt32Use&gt;(m_graph.varArgChild(node, 3));</span>
2145             break;
2146         }
2147 
2148         case StringValueOf: {
2149             fixupStringValueOf(node);
2150             break;
2151         }
2152 
2153         case StringSlice: {
2154             fixEdge&lt;StringUse&gt;(node-&gt;child1());
2155             fixEdge&lt;Int32Use&gt;(node-&gt;child2());
2156             if (node-&gt;child3())
2157                 fixEdge&lt;Int32Use&gt;(node-&gt;child3());
2158             break;
2159         }
2160 
2161         case ToLowerCase: {
2162             // We currently only support StringUse since that will ensure that
2163             // ToLowerCase is a pure operation. If we decide to update this with
2164             // more types in the future, we need to ensure that the clobberize rules
2165             // are correct.
2166             fixEdge&lt;StringUse&gt;(node-&gt;child1());
2167             break;
2168         }
2169 
2170         case NumberToStringWithRadix: {
2171             if (node-&gt;child1()-&gt;shouldSpeculateInt32())
2172                 fixEdge&lt;Int32Use&gt;(node-&gt;child1());
<span class="line-modified">2173             else if (enableInt52() &amp;&amp; node-&gt;child1()-&gt;shouldSpeculateAnyInt())</span>
2174                 fixEdge&lt;Int52RepUse&gt;(node-&gt;child1());
2175             else
2176                 fixEdge&lt;DoubleRepUse&gt;(node-&gt;child1());
2177             fixEdge&lt;Int32Use&gt;(node-&gt;child2());
2178             break;
2179         }
2180 
2181         case DefineAccessorProperty: {
2182             fixEdge&lt;CellUse&gt;(m_graph.varArgChild(node, 0));
2183             Edge&amp; propertyEdge = m_graph.varArgChild(node, 1);
2184             if (propertyEdge-&gt;shouldSpeculateSymbol())
2185                 fixEdge&lt;SymbolUse&gt;(propertyEdge);
2186             else if (propertyEdge-&gt;shouldSpeculateStringIdent())
2187                 fixEdge&lt;StringIdentUse&gt;(propertyEdge);
2188             else if (propertyEdge-&gt;shouldSpeculateString())
2189                 fixEdge&lt;StringUse&gt;(propertyEdge);
2190             else
2191                 fixEdge&lt;UntypedUse&gt;(propertyEdge);
2192             fixEdge&lt;CellUse&gt;(m_graph.varArgChild(node, 2));
2193             fixEdge&lt;CellUse&gt;(m_graph.varArgChild(node, 3));
<span class="line-modified">2194             fixEdge&lt;KnownInt32Use&gt;(m_graph.varArgChild(node, 4));</span>
2195             break;
2196         }
2197 
2198         case CheckSubClass: {
2199             fixupCheckSubClass(node);
2200             break;
2201         }
2202 
2203         case CallDOMGetter: {
2204             DOMJIT::CallDOMGetterSnippet* snippet = node-&gt;callDOMGetterData()-&gt;snippet;
2205             fixEdge&lt;CellUse&gt;(node-&gt;child1()); // DOM.
2206             if (snippet &amp;&amp; snippet-&gt;requireGlobalObject)
2207                 fixEdge&lt;KnownCellUse&gt;(node-&gt;child2()); // GlobalObject.
2208             break;
2209         }
2210 
2211         case CallDOM: {
2212             fixupCallDOM(node);
2213             break;
2214         }
</pre>
<hr />
<pre>
2298                 fixEdge&lt;DoubleRepUse&gt;(valueToStore);
2299             else {
2300                 switch (data.byteSize) {
2301                 case 1:
2302                 case 2:
2303                     fixEdge&lt;Int32Use&gt;(valueToStore);
2304                     break;
2305                 case 4:
2306                     if (data.isSigned)
2307                         fixEdge&lt;Int32Use&gt;(valueToStore);
2308                     else
2309                         fixEdge&lt;Int52RepUse&gt;(valueToStore);
2310                     break;
2311                 }
2312             }
2313             break;
2314         }
2315 
2316 #if !ASSERT_DISABLED
2317         // Have these no-op cases here to ensure that nobody forgets to add handlers for new opcodes.
<span class="line-modified">2318         case SetArgument:</span>

2319         case JSConstant:
2320         case LazyJSConstant:
2321         case DoubleConstant:
2322         case GetLocal:
2323         case GetCallee:
2324         case GetArgumentCountIncludingThis:
2325         case SetArgumentCountIncludingThis:
2326         case GetRestLength:
2327         case GetArgument:
2328         case Flush:
2329         case PhantomLocal:
2330         case GetGlobalVar:
2331         case GetGlobalLexicalVariable:
2332         case NotifyWrite:
2333         case DirectCall:
2334         case CheckTypeInfoFlags:
2335         case TailCallInlinedCaller:
2336         case DirectTailCallInlinedCaller:
2337         case Construct:
2338         case DirectConstruct:
</pre>
<hr />
<pre>
2587             m_graph.convertToConstant(node, jsBoolean(false));
2588             observeUseKindOnNode&lt;NotCellUse&gt;(node);
2589             return;
2590         }
2591     }
2592 
2593     void fixupGetPrototypeOf(Node* node)
2594     {
2595         // Reflect.getPrototypeOf only accepts Objects. For Reflect.getPrototypeOf, ByteCodeParser attaches ObjectUse edge filter before fixup phase.
2596         if (node-&gt;child1().useKind() != ObjectUse) {
2597             if (node-&gt;child1()-&gt;shouldSpeculateString()) {
2598                 insertCheck&lt;StringUse&gt;(node-&gt;child1().node());
2599                 m_graph.convertToConstant(node, m_graph.freeze(m_graph.globalObjectFor(node-&gt;origin.semantic)-&gt;stringPrototype()));
2600                 return;
2601             }
2602             if (node-&gt;child1()-&gt;shouldSpeculateInt32()) {
2603                 insertCheck&lt;Int32Use&gt;(node-&gt;child1().node());
2604                 m_graph.convertToConstant(node, m_graph.freeze(m_graph.globalObjectFor(node-&gt;origin.semantic)-&gt;numberPrototype()));
2605                 return;
2606             }
<span class="line-modified">2607             if (enableInt52() &amp;&amp; node-&gt;child1()-&gt;shouldSpeculateAnyInt()) {</span>
2608                 insertCheck&lt;Int52RepUse&gt;(node-&gt;child1().node());
2609                 m_graph.convertToConstant(node, m_graph.freeze(m_graph.globalObjectFor(node-&gt;origin.semantic)-&gt;numberPrototype()));
2610                 return;
2611             }
2612             if (node-&gt;child1()-&gt;shouldSpeculateNumber()) {
2613                 insertCheck&lt;NumberUse&gt;(node-&gt;child1().node());
2614                 m_graph.convertToConstant(node, m_graph.freeze(m_graph.globalObjectFor(node-&gt;origin.semantic)-&gt;numberPrototype()));
2615                 return;
2616             }
2617             if (node-&gt;child1()-&gt;shouldSpeculateSymbol()) {
2618                 insertCheck&lt;SymbolUse&gt;(node-&gt;child1().node());
2619                 m_graph.convertToConstant(node, m_graph.freeze(m_graph.globalObjectFor(node-&gt;origin.semantic)-&gt;symbolPrototype()));
2620                 return;
2621             }
2622             if (node-&gt;child1()-&gt;shouldSpeculateBoolean()) {
2623                 insertCheck&lt;BooleanUse&gt;(node-&gt;child1().node());
2624                 m_graph.convertToConstant(node, m_graph.freeze(m_graph.globalObjectFor(node-&gt;origin.semantic)-&gt;booleanPrototype()));
2625                 return;
2626             }
2627         }
2628 
2629         if (node-&gt;child1()-&gt;shouldSpeculateFinalObject()) {
2630             fixEdge&lt;FinalObjectUse&gt;(node-&gt;child1());
2631             node-&gt;clearFlags(NodeMustGenerate);
2632             return;
2633         }
2634         if (node-&gt;child1()-&gt;shouldSpeculateArray()) {
2635             fixEdge&lt;ArrayUse&gt;(node-&gt;child1());
2636             node-&gt;clearFlags(NodeMustGenerate);
2637             return;
2638         }
2639         if (node-&gt;child1()-&gt;shouldSpeculateFunction()) {
2640             fixEdge&lt;FunctionUse&gt;(node-&gt;child1());
2641             node-&gt;clearFlags(NodeMustGenerate);
2642             return;
2643         }
2644     }
2645 
2646     void fixupToThis(Node* node)
2647     {
<span class="line-modified">2648         ECMAMode ecmaMode = m_graph.executableFor(node-&gt;origin.semantic)-&gt;isStrictMode() ? StrictMode : NotStrictMode;</span>
2649 
<span class="line-modified">2650         if (ecmaMode == StrictMode) {</span>
2651             if (node-&gt;child1()-&gt;shouldSpeculateBoolean()) {
2652                 fixEdge&lt;BooleanUse&gt;(node-&gt;child1());
2653                 node-&gt;convertToIdentity();
2654                 return;
2655             }
2656 
2657             if (node-&gt;child1()-&gt;shouldSpeculateInt32()) {
2658                 fixEdge&lt;Int32Use&gt;(node-&gt;child1());
2659                 node-&gt;convertToIdentity();
2660                 return;
2661             }
2662 
<span class="line-modified">2663             if (enableInt52() &amp;&amp; node-&gt;child1()-&gt;shouldSpeculateAnyInt()) {</span>
2664                 fixEdge&lt;Int52RepUse&gt;(node-&gt;child1());
2665                 node-&gt;convertToIdentity();
2666                 node-&gt;setResult(NodeResultInt52);
2667                 return;
2668             }
2669 
2670             if (node-&gt;child1()-&gt;shouldSpeculateNumber()) {
2671                 fixEdge&lt;DoubleRepUse&gt;(node-&gt;child1());
2672                 node-&gt;convertToIdentity();
2673                 node-&gt;setResult(NodeResultDouble);
2674                 return;
2675             }
2676 
2677             if (node-&gt;child1()-&gt;shouldSpeculateSymbol()) {
2678                 fixEdge&lt;SymbolUse&gt;(node-&gt;child1());
2679                 node-&gt;convertToIdentity();
2680                 return;
2681             }
2682 
2683             if (node-&gt;child1()-&gt;shouldSpeculateStringIdent()) {
2684                 fixEdge&lt;StringIdentUse&gt;(node-&gt;child1());
2685                 node-&gt;convertToIdentity();
2686                 return;
2687             }
2688 
2689             if (node-&gt;child1()-&gt;shouldSpeculateString()) {
2690                 fixEdge&lt;StringUse&gt;(node-&gt;child1());
2691                 node-&gt;convertToIdentity();
2692                 return;
2693             }
2694 
2695             if (node-&gt;child1()-&gt;shouldSpeculateBigInt()) {
2696                 fixEdge&lt;BigIntUse&gt;(node-&gt;child1());
2697                 node-&gt;convertToIdentity();
2698                 return;
2699             }
2700         }
2701 
2702         if (node-&gt;child1()-&gt;shouldSpeculateOther()) {
<span class="line-modified">2703             if (ecmaMode == StrictMode) {</span>
2704                 fixEdge&lt;OtherUse&gt;(node-&gt;child1());
2705                 node-&gt;convertToIdentity();
2706                 return;
2707             }
2708 
2709             m_insertionSet.insertNode(
2710                 m_indexInBlock, SpecNone, Check, node-&gt;origin,
2711                 Edge(node-&gt;child1().node(), OtherUse));
2712             observeUseKindOnNode&lt;OtherUse&gt;(node-&gt;child1().node());
2713             m_graph.convertToConstant(
2714                 node, m_graph.globalThisObjectFor(node-&gt;origin.semantic));
2715             return;
2716         }
2717 
2718         // FIXME: This should cover other use cases but we don&#39;t have use kinds for them. It&#39;s not critical,
2719         // however, since we cover all the missing cases in constant folding.
2720         // https://bugs.webkit.org/show_bug.cgi?id=157213
2721         if (node-&gt;child1()-&gt;shouldSpeculateStringObject()) {
2722             fixEdge&lt;StringObjectUse&gt;(node-&gt;child1());
2723             node-&gt;convertToIdentity();
</pre>
<hr />
<pre>
2747 
2748         if (node-&gt;child1()-&gt;shouldSpeculateStringObject()
2749             &amp;&amp; m_graph.canOptimizeStringObjectAccess(node-&gt;origin.semantic)) {
2750             addCheckStructureForOriginalStringObjectUse(StringObjectUse, node-&gt;origin, node-&gt;child1().node());
2751             fixEdge&lt;StringObjectUse&gt;(node-&gt;child1());
2752             node-&gt;convertToToString();
2753             return;
2754         }
2755 
2756         if (node-&gt;child1()-&gt;shouldSpeculateStringOrStringObject()
2757             &amp;&amp; m_graph.canOptimizeStringObjectAccess(node-&gt;origin.semantic)) {
2758             addCheckStructureForOriginalStringObjectUse(StringOrStringObjectUse, node-&gt;origin, node-&gt;child1().node());
2759             fixEdge&lt;StringOrStringObjectUse&gt;(node-&gt;child1());
2760             node-&gt;convertToToString();
2761             return;
2762         }
2763     }
2764 
2765     void fixupToNumber(Node* node)
2766     {









2767         // If the prediction of the child is Number, we attempt to convert ToNumber to Identity.
2768         if (node-&gt;child1()-&gt;shouldSpeculateNumber()) {
2769             if (isInt32Speculation(node-&gt;getHeapPrediction())) {
2770                 // If the both predictions of this node and the child is Int32, we just convert ToNumber to Identity, that&#39;s simple.
2771                 if (node-&gt;child1()-&gt;shouldSpeculateInt32()) {
2772                     fixEdge&lt;Int32Use&gt;(node-&gt;child1());
2773                     node-&gt;convertToIdentity();
2774                     return;
2775                 }
2776 
2777                 // The another case is that the predicted type of the child is Int32, but the heap prediction tell the users that this will produce non Int32 values.
2778                 // In that case, let&#39;s receive the child value as a Double value and convert it to Int32. This case happens in misc-bugs-847389-jpeg2000.
2779                 fixEdge&lt;DoubleRepUse&gt;(node-&gt;child1());
2780                 node-&gt;setOp(DoubleAsInt32);
2781                 if (bytecodeCanIgnoreNegativeZero(node-&gt;arithNodeFlags()))
2782                     node-&gt;setArithMode(Arith::CheckOverflow);
2783                 else
2784                     node-&gt;setArithMode(Arith::CheckOverflowAndNegativeZero);
2785                 return;
2786             }
</pre>
<hr />
<pre>
2877         }
2878 
2879         if (node-&gt;child1()-&gt;shouldSpeculateStringOrStringObject()
2880             &amp;&amp; m_graph.canOptimizeStringObjectAccess(node-&gt;origin.semantic)) {
2881             addCheckStructureForOriginalStringObjectUse(StringOrStringObjectUse, node-&gt;origin, node-&gt;child1().node());
2882             fixEdge&lt;StringOrStringObjectUse&gt;(node-&gt;child1());
2883             return;
2884         }
2885 
2886         if (node-&gt;child1()-&gt;shouldSpeculateCell()) {
2887             fixEdge&lt;CellUse&gt;(node-&gt;child1());
2888             return;
2889         }
2890 
2891         if (node-&gt;child1()-&gt;shouldSpeculateInt32()) {
2892             fixEdge&lt;Int32Use&gt;(node-&gt;child1());
2893             node-&gt;clearFlags(NodeMustGenerate);
2894             return;
2895         }
2896 
<span class="line-modified">2897         if (enableInt52() &amp;&amp; node-&gt;child1()-&gt;shouldSpeculateAnyInt()) {</span>
2898             fixEdge&lt;Int52RepUse&gt;(node-&gt;child1());
2899             node-&gt;clearFlags(NodeMustGenerate);
2900             return;
2901         }
2902 
2903         if (node-&gt;child1()-&gt;shouldSpeculateNumber()) {
2904             fixEdge&lt;DoubleRepUse&gt;(node-&gt;child1());
2905             node-&gt;clearFlags(NodeMustGenerate);
2906             return;
2907         }
2908 
2909         // ToString(Symbol) throws an error. So if the child1 can include Symbols,
2910         // we need to care about it in the clobberize. In the following case,
2911         // since NotCellUse edge filter is used and this edge filters Symbols,
2912         // we can say that ToString never throws an error!
2913         if (node-&gt;child1()-&gt;shouldSpeculateNotCell()) {
2914             fixEdge&lt;NotCellUse&gt;(node-&gt;child1());
2915             node-&gt;clearFlags(NodeMustGenerate);
2916             return;
2917         }
</pre>
<hr />
<pre>
3198         case Int32Use:
3199         case KnownInt32Use:
3200             if (alwaysUnboxSimplePrimitives()
3201                 || isInt32Speculation(variable-&gt;prediction()))
3202                 m_profitabilityChanged |= variable-&gt;mergeIsProfitableToUnbox(true);
3203             break;
3204         case NumberUse:
3205         case RealNumberUse:
3206         case DoubleRepUse:
3207         case DoubleRepRealUse:
3208             if (variable-&gt;doubleFormatState() == UsingDoubleFormat)
3209                 m_profitabilityChanged |= variable-&gt;mergeIsProfitableToUnbox(true);
3210             break;
3211         case BooleanUse:
3212         case KnownBooleanUse:
3213             if (alwaysUnboxSimplePrimitives()
3214                 || isBooleanSpeculation(variable-&gt;prediction()))
3215                 m_profitabilityChanged |= variable-&gt;mergeIsProfitableToUnbox(true);
3216             break;
3217         case Int52RepUse:
<span class="line-modified">3218             if (isAnyIntSpeculation(variable-&gt;prediction()))</span>
3219                 m_profitabilityChanged |= variable-&gt;mergeIsProfitableToUnbox(true);
3220             break;
3221         case CellUse:
3222         case KnownCellUse:
3223         case ObjectUse:
3224         case FunctionUse:
3225         case StringUse:
3226         case KnownStringUse:
3227         case SymbolUse:
3228         case BigIntUse:
3229         case StringObjectUse:
3230         case StringOrStringObjectUse:
3231             if (alwaysUnboxSimplePrimitives()
3232                 || isCellSpeculation(variable-&gt;prediction()))
3233                 m_profitabilityChanged |= variable-&gt;mergeIsProfitableToUnbox(true);
3234             break;
3235         default:
3236             break;
3237         }
3238     }
</pre>
<hr />
<pre>
3289         }
3290     }
3291 
3292     template&lt;UseKind useKind&gt;
3293     void insertCheck(Node* node)
3294     {
3295         observeUseKindOnNode&lt;useKind&gt;(node);
3296         unsigned index = indexForChecks();
3297         m_insertionSet.insertNode(index, SpecNone, Check, originForCheck(index), Edge(node, useKind));
3298     }
3299 
3300     void fixIntConvertingEdge(Edge&amp; edge)
3301     {
3302         Node* node = edge.node();
3303         if (node-&gt;shouldSpeculateInt32OrBoolean()) {
3304             fixIntOrBooleanEdge(edge);
3305             return;
3306         }
3307 
3308         UseKind useKind;
<span class="line-modified">3309         if (node-&gt;shouldSpeculateAnyInt())</span>
3310             useKind = Int52RepUse;
3311         else if (node-&gt;shouldSpeculateNumber())
3312             useKind = DoubleRepUse;
3313         else
3314             useKind = NotCellUse;
3315         Node* newNode = m_insertionSet.insertNode(
3316             m_indexInBlock, SpecInt32Only, ValueToInt32, m_currentNode-&gt;origin,
3317             Edge(node, useKind));
3318         observeUseKindOnNode(node, useKind);
3319 
3320         edge = Edge(newNode, KnownInt32Use);
3321     }
3322 
3323     void fixIntOrBooleanEdge(Edge&amp; edge)
3324     {
3325         Node* node = edge.node();
3326         if (!node-&gt;sawBooleans()) {
3327             fixEdge&lt;Int32Use&gt;(edge);
3328             return;
3329         }
</pre>
<hr />
<pre>
3386         if (node-&gt;child1()-&gt;hasConstant())
3387             truncateConstantToInt32(node-&gt;child1());
3388         else
3389             truncateConstantToInt32(node-&gt;child2());
3390     }
3391 
3392     bool attemptToMakeIntegerAdd(Node* node)
3393     {
3394         AddSpeculationMode mode = m_graph.addSpeculationMode(node, FixupPass);
3395         if (mode != DontSpeculateInt32) {
3396             truncateConstantsIfNecessary(node, mode);
3397             fixIntOrBooleanEdge(node-&gt;child1());
3398             fixIntOrBooleanEdge(node-&gt;child2());
3399             if (bytecodeCanTruncateInteger(node-&gt;arithNodeFlags()))
3400                 node-&gt;setArithMode(Arith::Unchecked);
3401             else
3402                 node-&gt;setArithMode(Arith::CheckOverflow);
3403             return true;
3404         }
3405 
<span class="line-modified">3406         if (m_graph.addShouldSpeculateAnyInt(node)) {</span>
3407             fixEdge&lt;Int52RepUse&gt;(node-&gt;child1());
3408             fixEdge&lt;Int52RepUse&gt;(node-&gt;child2());
3409             node-&gt;setArithMode(Arith::CheckOverflow);
3410             node-&gt;setResult(NodeResultInt52);
3411             return true;
3412         }
3413 
3414         return false;
3415     }
3416 
3417     bool attemptToMakeGetArrayLength(Node* node)
3418     {
3419         if (!isInt32Speculation(node-&gt;prediction()))
3420             return false;
3421         CodeBlock* profiledBlock = m_graph.baselineCodeBlockFor(node-&gt;origin.semantic);
3422         ArrayProfile* arrayProfile =
<span class="line-modified">3423             profiledBlock-&gt;getArrayProfile(node-&gt;origin.semantic.bytecodeIndex);</span>
3424         ArrayMode arrayMode = ArrayMode(Array::SelectUsingPredictions, Array::Read);
3425         if (arrayProfile) {
3426             ConcurrentJSLocker locker(profiledBlock-&gt;m_lock);
3427             arrayProfile-&gt;computeUpdatedPrediction(locker, profiledBlock);
3428             arrayMode = ArrayMode::fromObserved(locker, arrayProfile, Array::Read, false);
3429             if (arrayMode.type() == Array::Unprofiled) {
3430                 // For normal array operations, it makes sense to treat Unprofiled
3431                 // accesses as ForceExit and get more data rather than using
3432                 // predictions and then possibly ending up with a Generic. But here,
3433                 // we treat anything that is Unprofiled as Generic and keep the
3434                 // GetById. I.e. ForceExit = Generic. So, there is no harm - and only
3435                 // profit - from treating the Unprofiled case as
3436                 // SelectUsingPredictions.
3437                 arrayMode = ArrayMode(Array::SelectUsingPredictions, Array::Read);
3438             }
3439         }
3440 
3441         arrayMode = arrayMode.refine(
3442             m_graph, node, node-&gt;child1()-&gt;prediction(), node-&gt;prediction());
3443 
</pre>
<hr />
<pre>
3705             return;
3706         }
3707     }
3708 
3709     void fixupCompareStrictEqAndSameValue(Node* node)
3710     {
3711         ASSERT(node-&gt;op() == SameValue || node-&gt;op() == CompareStrictEq);
3712 
3713         if (Node::shouldSpeculateBoolean(node-&gt;child1().node(), node-&gt;child2().node())) {
3714             fixEdge&lt;BooleanUse&gt;(node-&gt;child1());
3715             fixEdge&lt;BooleanUse&gt;(node-&gt;child2());
3716             node-&gt;setOpAndDefaultFlags(CompareStrictEq);
3717             return;
3718         }
3719         if (Node::shouldSpeculateInt32(node-&gt;child1().node(), node-&gt;child2().node())) {
3720             fixEdge&lt;Int32Use&gt;(node-&gt;child1());
3721             fixEdge&lt;Int32Use&gt;(node-&gt;child2());
3722             node-&gt;setOpAndDefaultFlags(CompareStrictEq);
3723             return;
3724         }
<span class="line-modified">3725         if (enableInt52()</span>
<span class="line-removed">3726             &amp;&amp; Node::shouldSpeculateAnyInt(node-&gt;child1().node(), node-&gt;child2().node())) {</span>
3727             fixEdge&lt;Int52RepUse&gt;(node-&gt;child1());
3728             fixEdge&lt;Int52RepUse&gt;(node-&gt;child2());
3729             node-&gt;setOpAndDefaultFlags(CompareStrictEq);
3730             return;
3731         }
3732         if (Node::shouldSpeculateNumber(node-&gt;child1().node(), node-&gt;child2().node())) {
3733             fixEdge&lt;DoubleRepUse&gt;(node-&gt;child1());
3734             fixEdge&lt;DoubleRepUse&gt;(node-&gt;child2());
3735             // Do not convert SameValue to CompareStrictEq in this case since SameValue(NaN, NaN) and SameValue(-0, +0)
3736             // are not the same to CompareStrictEq(NaN, NaN) and CompareStrictEq(-0, +0).
3737             return;
3738         }
3739         if (Node::shouldSpeculateSymbol(node-&gt;child1().node(), node-&gt;child2().node())) {
3740             fixEdge&lt;SymbolUse&gt;(node-&gt;child1());
3741             fixEdge&lt;SymbolUse&gt;(node-&gt;child2());
3742             node-&gt;setOpAndDefaultFlags(CompareStrictEq);
3743             return;
3744         }
3745         if (Node::shouldSpeculateBigInt(node-&gt;child1().node(), node-&gt;child2().node())) {
3746             fixEdge&lt;BigIntUse&gt;(node-&gt;child1());
</pre>
<hr />
<pre>
3946                                 useKind = NumberUse;
3947                             else
3948                                 useKind = NotCellUse;
3949 
3950                             result = m_insertionSet.insertNode(
3951                                 indexForChecks, SpecBytecodeDouble, DoubleRep, originForChecks,
3952                                 Edge(edge.node(), useKind));
3953                         }
3954 
3955                         edge.setNode(result);
3956                         break;
3957                     }
3958 
3959                     case Int52RepUse: {
3960                         if (edge-&gt;hasInt52Result())
3961                             break;
3962 
3963                         ASSERT(indexForChecks != UINT_MAX);
3964                         if (edge-&gt;isAnyIntConstant()) {
3965                             result = m_insertionSet.insertNode(
<span class="line-modified">3966                                 indexForChecks, SpecAnyInt, Int52Constant, originForChecks,</span>
3967                                 OpInfo(edge-&gt;constant()));
3968                         } else if (edge-&gt;hasDoubleResult()) {
3969                             result = m_insertionSet.insertNode(
<span class="line-modified">3970                                 indexForChecks, SpecAnyInt, Int52Rep, originForChecks,</span>
3971                                 Edge(edge.node(), DoubleRepAnyIntUse));
3972                         } else if (edge-&gt;shouldSpeculateInt32ForArithmetic()) {
3973                             result = m_insertionSet.insertNode(
3974                                 indexForChecks, SpecInt32Only, Int52Rep, originForChecks,
3975                                 Edge(edge.node(), Int32Use));
3976                         } else {
3977                             result = m_insertionSet.insertNode(
<span class="line-modified">3978                                 indexForChecks, SpecAnyInt, Int52Rep, originForChecks,</span>
3979                                 Edge(edge.node(), AnyIntUse));
3980                         }
3981 
3982                         edge.setNode(result);
3983                         break;
3984                     }
3985 
3986                     default: {
3987                         if (!edge-&gt;hasDoubleResult() &amp;&amp; !edge-&gt;hasInt52Result())
3988                             break;
3989 
3990                         ASSERT(indexForChecks != UINT_MAX);
3991                         if (edge-&gt;hasDoubleResult()) {
3992                             result = m_insertionSet.insertNode(
3993                                 indexForChecks, SpecBytecodeDouble, ValueRep, originForChecks,
3994                                 Edge(edge.node(), DoubleRepUse));
3995                         } else {
3996                             result = m_insertionSet.insertNode(
3997                                 indexForChecks, SpecInt32Only | SpecAnyIntAsDouble, ValueRep,
3998                                 originForChecks, Edge(edge.node(), Int52RepUse));
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (C) 2012-2019 Apple Inc. All rights reserved.</span>
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  * 1. Redistributions of source code must retain the above copyright
   8  *    notice, this list of conditions and the following disclaimer.
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
</pre>
<hr />
<pre>
  58 
  59         while (m_profitabilityChanged) {
  60             m_profitabilityChanged = false;
  61 
  62             for (unsigned i = m_graph.m_argumentPositions.size(); i--;)
  63                 m_graph.m_argumentPositions[i].mergeArgumentUnboxingAwareness();
  64 
  65             for (BlockIndex blockIndex = 0; blockIndex &lt; m_graph.numBlocks(); ++blockIndex)
  66                 fixupGetAndSetLocalsInBlock(m_graph.block(blockIndex));
  67         }
  68 
  69         for (BlockIndex blockIndex = 0; blockIndex &lt; m_graph.numBlocks(); ++blockIndex)
  70             fixupChecksInBlock(m_graph.block(blockIndex));
  71 
  72         m_graph.m_planStage = PlanStage::AfterFixup;
  73 
  74         return true;
  75     }
  76 
  77 private:























  78 
<span class="line-modified">  79     void fixupArithDivInt32(Node* node, Edge&amp; leftChild, Edge&amp; rightChild)</span>
<span class="line-modified">  80     {</span>
<span class="line-modified">  81         if (optimizeForX86() || optimizeForARM64() || optimizeForARMv7IDIVSupported()) {</span>
<span class="line-added">  82             fixIntOrBooleanEdge(leftChild);</span>
<span class="line-added">  83             fixIntOrBooleanEdge(rightChild);</span>
<span class="line-added">  84             if (bytecodeCanTruncateInteger(node-&gt;arithNodeFlags()))</span>
<span class="line-added">  85                 node-&gt;setArithMode(Arith::Unchecked);</span>
<span class="line-added">  86             else if (bytecodeCanIgnoreNegativeZero(node-&gt;arithNodeFlags()))</span>
  87                 node-&gt;setArithMode(Arith::CheckOverflow);
  88             else
  89                 node-&gt;setArithMode(Arith::CheckOverflowAndNegativeZero);
  90             return;
  91         }
  92 
<span class="line-added">  93         // This will cause conversion nodes to be inserted later.</span>
<span class="line-added">  94         fixDoubleOrBooleanEdge(leftChild);</span>
<span class="line-added">  95         fixDoubleOrBooleanEdge(rightChild);</span>
<span class="line-added">  96 </span>
<span class="line-added">  97         // We don&#39;t need to do ref&#39;ing on the children because we&#39;re stealing them from</span>
<span class="line-added">  98         // the original division.</span>
<span class="line-added">  99         Node* newDivision = m_insertionSet.insertNode(m_indexInBlock, SpecBytecodeDouble, *node);</span>
<span class="line-added"> 100         newDivision-&gt;setResult(NodeResultDouble);</span>
<span class="line-added"> 101 </span>
<span class="line-added"> 102         node-&gt;setOp(DoubleAsInt32);</span>
<span class="line-added"> 103         node-&gt;children.initialize(Edge(newDivision, DoubleRepUse), Edge(), Edge());</span>
<span class="line-added"> 104         if (bytecodeCanIgnoreNegativeZero(node-&gt;arithNodeFlags()))</span>
<span class="line-added"> 105             node-&gt;setArithMode(Arith::CheckOverflow);</span>
<span class="line-added"> 106         else</span>
<span class="line-added"> 107             node-&gt;setArithMode(Arith::CheckOverflowAndNegativeZero);</span>
<span class="line-added"> 108 </span>
<span class="line-added"> 109     }</span>
<span class="line-added"> 110 </span>
<span class="line-added"> 111     void fixupArithPow(Node* node)</span>
<span class="line-added"> 112     {</span>
<span class="line-added"> 113         if (node-&gt;child2()-&gt;shouldSpeculateInt32OrBooleanForArithmetic()) {</span>
<span class="line-added"> 114             fixDoubleOrBooleanEdge(node-&gt;child1());</span>
<span class="line-added"> 115             fixIntOrBooleanEdge(node-&gt;child2());</span>
<span class="line-added"> 116             return;</span>
<span class="line-added"> 117         }</span>
<span class="line-added"> 118 </span>
<span class="line-added"> 119         fixDoubleOrBooleanEdge(node-&gt;child1());</span>
<span class="line-added"> 120         fixDoubleOrBooleanEdge(node-&gt;child2());</span>
<span class="line-added"> 121     }</span>
<span class="line-added"> 122 </span>
<span class="line-added"> 123     void fixupArithDiv(Node* node, Edge&amp; leftChild, Edge&amp; rightChild)</span>
<span class="line-added"> 124     {</span>
<span class="line-added"> 125         if (m_graph.binaryArithShouldSpeculateInt32(node, FixupPass)) {</span>
<span class="line-added"> 126             fixupArithDivInt32(node, leftChild, rightChild);</span>
<span class="line-added"> 127             return;</span>
<span class="line-added"> 128         }</span>
<span class="line-added"> 129 </span>
 130         fixDoubleOrBooleanEdge(leftChild);
 131         fixDoubleOrBooleanEdge(rightChild);
 132         node-&gt;setResult(NodeResultDouble);
 133     }
 134 
 135     void fixupArithMul(Node* node, Edge&amp; leftChild, Edge&amp; rightChild)
 136     {
 137         if (m_graph.binaryArithShouldSpeculateInt32(node, FixupPass)) {
 138             fixIntOrBooleanEdge(leftChild);
 139             fixIntOrBooleanEdge(rightChild);
 140             if (bytecodeCanTruncateInteger(node-&gt;arithNodeFlags()))
 141                 node-&gt;setArithMode(Arith::Unchecked);
 142             else if (bytecodeCanIgnoreNegativeZero(node-&gt;arithNodeFlags()) || leftChild.node() == rightChild.node())
 143                 node-&gt;setArithMode(Arith::CheckOverflow);
 144             else
 145                 node-&gt;setArithMode(Arith::CheckOverflowAndNegativeZero);
 146             return;
 147         }
<span class="line-modified"> 148         if (m_graph.binaryArithShouldSpeculateInt52(node, FixupPass)) {</span>
 149             fixEdge&lt;Int52RepUse&gt;(leftChild);
 150             fixEdge&lt;Int52RepUse&gt;(rightChild);
 151             if (bytecodeCanIgnoreNegativeZero(node-&gt;arithNodeFlags()) || leftChild.node() == rightChild.node())
 152                 node-&gt;setArithMode(Arith::CheckOverflow);
 153             else
 154                 node-&gt;setArithMode(Arith::CheckOverflowAndNegativeZero);
 155             node-&gt;setResult(NodeResultInt52);
 156             return;
 157         }
 158 
 159         fixDoubleOrBooleanEdge(leftChild);
 160         fixDoubleOrBooleanEdge(rightChild);
 161         node-&gt;setResult(NodeResultDouble);
 162     }
 163 
 164     void fixupBlock(BasicBlock* block)
 165     {
 166         if (!block)
 167             return;
 168         ASSERT(block-&gt;isReachable);
</pre>
<hr />
<pre>
 198                 fixEdge&lt;UntypedUse&gt;(child1);
 199                 fixEdge&lt;UntypedUse&gt;(child2);
 200                 break;
 201             }
 202 
 203             if (attemptToMakeIntegerAdd(node)) {
 204                 // FIXME: Clear ArithSub&#39;s NodeMustGenerate when ArithMode is unchecked
 205                 // https://bugs.webkit.org/show_bug.cgi?id=190607
 206                 node-&gt;setOp(ArithSub);
 207                 break;
 208             }
 209 
 210             fixDoubleOrBooleanEdge(node-&gt;child1());
 211             fixDoubleOrBooleanEdge(node-&gt;child2());
 212             node-&gt;setOp(ArithSub);
 213             node-&gt;setResult(NodeResultDouble);
 214 
 215             break;
 216         }
 217 
<span class="line-added"> 218         case ValueBitLShift:</span>
 219         case ValueBitXor:
 220         case ValueBitOr:
 221         case ValueBitAnd: {
 222             if (Node::shouldSpeculateBigInt(node-&gt;child1().node(), node-&gt;child2().node())) {
 223                 fixEdge&lt;BigIntUse&gt;(node-&gt;child1());
 224                 fixEdge&lt;BigIntUse&gt;(node-&gt;child2());
<span class="line-added"> 225                 node-&gt;clearFlags(NodeMustGenerate);</span>
 226                 break;
 227             }
 228 
 229             if (Node::shouldSpeculateUntypedForBitOps(node-&gt;child1().node(), node-&gt;child2().node())) {
 230                 fixEdge&lt;UntypedUse&gt;(node-&gt;child1());
 231                 fixEdge&lt;UntypedUse&gt;(node-&gt;child2());
 232                 break;
 233             }
 234 

 235             switch (op) {
 236             case ValueBitXor:
 237                 node-&gt;setOp(ArithBitXor);
 238                 break;
 239             case ValueBitOr:
 240                 node-&gt;setOp(ArithBitOr);
 241                 break;
 242             case ValueBitAnd:
 243                 node-&gt;setOp(ArithBitAnd);
 244                 break;
<span class="line-added"> 245             case ValueBitLShift:</span>
<span class="line-added"> 246                 node-&gt;setOp(ArithBitLShift);</span>
<span class="line-added"> 247                 break;</span>
 248             default:
 249                 DFG_CRASH(m_graph, node, &quot;Unexpected node during ValueBit operation fixup&quot;);
 250                 break;
 251             }
 252 
 253             node-&gt;clearFlags(NodeMustGenerate);
 254             node-&gt;setResult(NodeResultInt32);
 255             fixIntConvertingEdge(node-&gt;child1());
 256             fixIntConvertingEdge(node-&gt;child2());
 257             break;
 258         }
 259 
<span class="line-modified"> 260         case ValueBitNot: {</span>
<span class="line-modified"> 261             Edge&amp; operandEdge = node-&gt;child1();</span>
<span class="line-modified"> 262 </span>
<span class="line-modified"> 263             if (operandEdge.node()-&gt;shouldSpeculateBigInt()) {</span>
<span class="line-added"> 264                 node-&gt;clearFlags(NodeMustGenerate);</span>
<span class="line-added"> 265                 fixEdge&lt;BigIntUse&gt;(operandEdge);</span>
<span class="line-added"> 266             } else if (operandEdge.node()-&gt;shouldSpeculateUntypedForBitOps())</span>
<span class="line-added"> 267                 fixEdge&lt;UntypedUse&gt;(operandEdge);</span>
<span class="line-added"> 268             else {</span>
<span class="line-added"> 269                 node-&gt;setOp(ArithBitNot);</span>
<span class="line-added"> 270                 node-&gt;setResult(NodeResultInt32);</span>
<span class="line-added"> 271                 node-&gt;clearFlags(NodeMustGenerate);</span>
<span class="line-added"> 272                 fixIntConvertingEdge(operandEdge);</span>
 273             }
<span class="line-added"> 274             break;</span>
<span class="line-added"> 275         }</span>
 276 
<span class="line-modified"> 277         case ArithBitNot: {</span>
<span class="line-modified"> 278             Edge&amp; operandEdge = node-&gt;child1();</span>
<span class="line-added"> 279 </span>
<span class="line-added"> 280             fixIntConvertingEdge(operandEdge);</span>
 281             break;
 282         }
 283 
<span class="line-added"> 284         case ArithBitLShift:</span>
 285         case ArithBitXor:
 286         case ArithBitOr:
 287         case ArithBitAnd: {
 288             fixIntConvertingEdge(node-&gt;child1());
 289             fixIntConvertingEdge(node-&gt;child2());
 290             break;
 291         }
 292 
 293         case BitRShift:

 294         case BitURShift: {
 295             if (Node::shouldSpeculateUntypedForBitOps(node-&gt;child1().node(), node-&gt;child2().node())) {
 296                 fixEdge&lt;UntypedUse&gt;(node-&gt;child1());
 297                 fixEdge&lt;UntypedUse&gt;(node-&gt;child2());
 298                 break;
 299             }
 300             fixIntConvertingEdge(node-&gt;child1());
 301             fixIntConvertingEdge(node-&gt;child2());
 302             break;
 303         }
 304 
 305         case ArithIMul: {
 306             fixIntConvertingEdge(node-&gt;child1());
 307             fixIntConvertingEdge(node-&gt;child2());
 308             node-&gt;setOp(ArithMul);
 309             node-&gt;setArithMode(Arith::Unchecked);
 310             node-&gt;child1().setUseKind(Int32Use);
 311             node-&gt;child2().setUseKind(Int32Use);
 312             break;
 313         }
</pre>
<hr />
<pre>
 332                 node-&gt;setResult(enableInt52() ? NodeResultInt52 : NodeResultDouble);
 333             }
 334             break;
 335         }
 336 
 337         case ValueNegate: {
 338             if (node-&gt;child1()-&gt;shouldSpeculateInt32OrBoolean() &amp;&amp; node-&gt;canSpeculateInt32(FixupPass)) {
 339                 node-&gt;setOp(ArithNegate);
 340                 fixIntOrBooleanEdge(node-&gt;child1());
 341                 if (bytecodeCanTruncateInteger(node-&gt;arithNodeFlags()))
 342                     node-&gt;setArithMode(Arith::Unchecked);
 343                 else if (bytecodeCanIgnoreNegativeZero(node-&gt;arithNodeFlags()))
 344                     node-&gt;setArithMode(Arith::CheckOverflow);
 345                 else
 346                     node-&gt;setArithMode(Arith::CheckOverflowAndNegativeZero);
 347                 node-&gt;setResult(NodeResultInt32);
 348                 node-&gt;clearFlags(NodeMustGenerate);
 349                 break;
 350             }
 351 
<span class="line-modified"> 352             if (m_graph.unaryArithShouldSpeculateInt52(node, FixupPass)) {</span>
 353                 node-&gt;setOp(ArithNegate);
 354                 fixEdge&lt;Int52RepUse&gt;(node-&gt;child1());
 355                 if (bytecodeCanIgnoreNegativeZero(node-&gt;arithNodeFlags()))
 356                     node-&gt;setArithMode(Arith::CheckOverflow);
 357                 else
 358                     node-&gt;setArithMode(Arith::CheckOverflowAndNegativeZero);
 359                 node-&gt;setResult(NodeResultInt52);
 360                 node-&gt;clearFlags(NodeMustGenerate);
 361                 break;
 362             }
 363             if (node-&gt;child1()-&gt;shouldSpeculateNotCell()) {
 364                 node-&gt;setOp(ArithNegate);
 365                 fixDoubleOrBooleanEdge(node-&gt;child1());
 366                 node-&gt;setResult(NodeResultDouble);
 367                 node-&gt;clearFlags(NodeMustGenerate);
 368             } else {
 369                 fixEdge&lt;UntypedUse&gt;(node-&gt;child1());
 370                 node-&gt;setResult(NodeResultJS);
 371             }
 372             break;
</pre>
<hr />
<pre>
 456                 break;
 457             fixDoubleOrBooleanEdge(node-&gt;child1());
 458             fixDoubleOrBooleanEdge(node-&gt;child2());
 459             node-&gt;setResult(NodeResultDouble);
 460             break;
 461         }
 462 
 463         case ArithNegate: {
 464             if (node-&gt;child1()-&gt;shouldSpeculateInt32OrBoolean() &amp;&amp; node-&gt;canSpeculateInt32(FixupPass)) {
 465                 fixIntOrBooleanEdge(node-&gt;child1());
 466                 if (bytecodeCanTruncateInteger(node-&gt;arithNodeFlags()))
 467                     node-&gt;setArithMode(Arith::Unchecked);
 468                 else if (bytecodeCanIgnoreNegativeZero(node-&gt;arithNodeFlags()))
 469                     node-&gt;setArithMode(Arith::CheckOverflow);
 470                 else
 471                     node-&gt;setArithMode(Arith::CheckOverflowAndNegativeZero);
 472                 node-&gt;setResult(NodeResultInt32);
 473                 node-&gt;clearFlags(NodeMustGenerate);
 474                 break;
 475             }
<span class="line-modified"> 476             if (m_graph.unaryArithShouldSpeculateInt52(node, FixupPass)) {</span>
 477                 fixEdge&lt;Int52RepUse&gt;(node-&gt;child1());
 478                 if (bytecodeCanIgnoreNegativeZero(node-&gt;arithNodeFlags()))
 479                     node-&gt;setArithMode(Arith::CheckOverflow);
 480                 else
 481                     node-&gt;setArithMode(Arith::CheckOverflowAndNegativeZero);
 482                 node-&gt;setResult(NodeResultInt52);
 483                 node-&gt;clearFlags(NodeMustGenerate);
 484                 break;
 485             }
 486 
 487             fixDoubleOrBooleanEdge(node-&gt;child1());
 488             node-&gt;setResult(NodeResultDouble);
 489             node-&gt;clearFlags(NodeMustGenerate);
 490             break;
 491         }
 492 
 493         case ValueMul: {
 494             Edge&amp; leftChild = node-&gt;child1();
 495             Edge&amp; rightChild = node-&gt;child2();
 496 
 497             if (Node::shouldSpeculateBigInt(leftChild.node(), rightChild.node())) {
 498                 fixEdge&lt;BigIntUse&gt;(node-&gt;child1());
 499                 fixEdge&lt;BigIntUse&gt;(node-&gt;child2());
<span class="line-added"> 500                 node-&gt;clearFlags(NodeMustGenerate);</span>
 501                 break;
 502             }
 503 
 504             // There are cases where we can have BigInt + Int32 operands reaching ValueMul.
 505             // Imagine the scenario where ValueMul was never executed, but we can predict types
 506             // reaching the node:
 507             //
 508             // 63: GetLocal(Check:Untyped:@72, JS|MustGen, NonBoolInt32, ...)  predicting NonBoolInt32
 509             // 64: GetLocal(Check:Untyped:@71, JS|MustGen, BigInt, ...)  predicting BigInt
 510             // 65: ValueMul(Check:Untyped:@63, Check:Untyped:@64, BigInt|BoolInt32|NonBoolInt32, ...)
 511             //
 512             // In such scenario, we need to emit ValueMul(Untyped, Untyped), so the runtime can throw
 513             // an exception whenever it gets excuted.
 514             if (Node::shouldSpeculateUntypedForArithmetic(leftChild.node(), rightChild.node())) {
 515                 fixEdge&lt;UntypedUse&gt;(leftChild);
 516                 fixEdge&lt;UntypedUse&gt;(rightChild);
 517                 break;
 518             }
 519 
 520             // At this point, all other possible specializations are only handled by ArithMul.
 521             node-&gt;setOp(ArithMul);
 522             node-&gt;setResult(NodeResultNumber);
 523             fixupArithMul(node, leftChild, rightChild);
 524             break;
 525         }
 526 
 527         case ArithMul: {
 528             Edge&amp; leftChild = node-&gt;child1();
 529             Edge&amp; rightChild = node-&gt;child2();
 530 
 531             fixupArithMul(node, leftChild, rightChild);
 532             break;
 533         }
 534 
<span class="line-added"> 535         case ValueMod:</span>
 536         case ValueDiv: {
 537             Edge&amp; leftChild = node-&gt;child1();
 538             Edge&amp; rightChild = node-&gt;child2();
 539 
 540             if (Node::shouldSpeculateBigInt(leftChild.node(), rightChild.node())) {
 541                 fixEdge&lt;BigIntUse&gt;(leftChild);
 542                 fixEdge&lt;BigIntUse&gt;(rightChild);
<span class="line-added"> 543                 node-&gt;clearFlags(NodeMustGenerate);</span>
 544                 break;
 545             }
 546 
 547             if (Node::shouldSpeculateUntypedForArithmetic(leftChild.node(), rightChild.node())) {
 548                 fixEdge&lt;UntypedUse&gt;(leftChild);
 549                 fixEdge&lt;UntypedUse&gt;(rightChild);
 550                 break;
 551             }
<span class="line-modified"> 552 </span>
<span class="line-added"> 553             if (op == ValueDiv)</span>
<span class="line-added"> 554                 node-&gt;setOp(ArithDiv);</span>
<span class="line-added"> 555             else</span>
<span class="line-added"> 556                 node-&gt;setOp(ArithMod);</span>
<span class="line-added"> 557 </span>
 558             node-&gt;setResult(NodeResultNumber);
 559             fixupArithDiv(node, leftChild, rightChild);
 560             break;
 561 
 562         }
 563 
 564         case ArithDiv:
 565         case ArithMod: {
 566             Edge&amp; leftChild = node-&gt;child1();
 567             Edge&amp; rightChild = node-&gt;child2();
 568 
 569             fixupArithDiv(node, leftChild, rightChild);
 570             break;
 571         }
 572 
 573         case ArithMin:
 574         case ArithMax: {
 575             if (m_graph.binaryArithShouldSpeculateInt32(node, FixupPass)) {
 576                 fixIntOrBooleanEdge(node-&gt;child1());
 577                 fixIntOrBooleanEdge(node-&gt;child2());
</pre>
<hr />
<pre>
 588                 &amp;&amp; node-&gt;canSpeculateInt32(FixupPass)) {
 589                 fixIntOrBooleanEdge(node-&gt;child1());
 590                 if (bytecodeCanTruncateInteger(node-&gt;arithNodeFlags()))
 591                     node-&gt;setArithMode(Arith::Unchecked);
 592                 else
 593                     node-&gt;setArithMode(Arith::CheckOverflow);
 594                 node-&gt;clearFlags(NodeMustGenerate);
 595                 node-&gt;setResult(NodeResultInt32);
 596                 break;
 597             }
 598 
 599             if (node-&gt;child1()-&gt;shouldSpeculateNotCell()) {
 600                 fixDoubleOrBooleanEdge(node-&gt;child1());
 601                 node-&gt;clearFlags(NodeMustGenerate);
 602             } else
 603                 fixEdge&lt;UntypedUse&gt;(node-&gt;child1());
 604             node-&gt;setResult(NodeResultDouble);
 605             break;
 606         }
 607 
<span class="line-modified"> 608         case ValuePow: {</span>
<span class="line-modified"> 609             if (Node::shouldSpeculateBigInt(node-&gt;child1().node(), node-&gt;child2().node())) {</span>
<span class="line-modified"> 610                 fixEdge&lt;BigIntUse&gt;(node-&gt;child1());</span>
<span class="line-modified"> 611                 fixEdge&lt;BigIntUse&gt;(node-&gt;child2());</span>
<span class="line-added"> 612                 node-&gt;clearFlags(NodeMustGenerate);</span>
 613                 break;
 614             }
 615 
<span class="line-modified"> 616             if (Node::shouldSpeculateUntypedForArithmetic(node-&gt;child1().node(), node-&gt;child2().node())) {</span>
<span class="line-modified"> 617                 fixEdge&lt;UntypedUse&gt;(node-&gt;child1());</span>
<span class="line-added"> 618                 fixEdge&lt;UntypedUse&gt;(node-&gt;child2());</span>
<span class="line-added"> 619                 break;</span>
<span class="line-added"> 620             }</span>
<span class="line-added"> 621 </span>
<span class="line-added"> 622             node-&gt;setOp(ArithPow);</span>
<span class="line-added"> 623             node-&gt;clearFlags(NodeMustGenerate);</span>
<span class="line-added"> 624             node-&gt;setResult(NodeResultDouble);</span>
<span class="line-added"> 625 </span>
<span class="line-added"> 626             fixupArithPow(node);</span>
<span class="line-added"> 627             break;</span>
<span class="line-added"> 628         }</span>
<span class="line-added"> 629 </span>
<span class="line-added"> 630         case ArithPow: {</span>
<span class="line-added"> 631             fixupArithPow(node);</span>
 632             break;
 633         }
 634 
 635         case ArithRandom: {
 636             node-&gt;setResult(NodeResultDouble);
 637             break;
 638         }
 639 
 640         case ArithRound:
 641         case ArithFloor:
 642         case ArithCeil:
 643         case ArithTrunc: {
 644             if (node-&gt;child1()-&gt;shouldSpeculateInt32OrBoolean() &amp;&amp; m_graph.roundShouldSpeculateInt32(node, FixupPass)) {
 645                 fixIntOrBooleanEdge(node-&gt;child1());
 646                 insertCheck&lt;Int32Use&gt;(node-&gt;child1().node());
 647                 node-&gt;convertToIdentity();
 648                 break;
 649             }
 650             if (node-&gt;child1()-&gt;shouldSpeculateNotCell()) {
 651                 fixDoubleOrBooleanEdge(node-&gt;child1());
</pre>
<hr />
<pre>
 710         }
 711 
 712         case CompareEq:
 713         case CompareLess:
 714         case CompareLessEq:
 715         case CompareGreater:
 716         case CompareGreaterEq: {
 717             if (node-&gt;op() == CompareEq
 718                 &amp;&amp; Node::shouldSpeculateBoolean(node-&gt;child1().node(), node-&gt;child2().node())) {
 719                 fixEdge&lt;BooleanUse&gt;(node-&gt;child1());
 720                 fixEdge&lt;BooleanUse&gt;(node-&gt;child2());
 721                 node-&gt;clearFlags(NodeMustGenerate);
 722                 break;
 723             }
 724             if (Node::shouldSpeculateInt32OrBoolean(node-&gt;child1().node(), node-&gt;child2().node())) {
 725                 fixIntOrBooleanEdge(node-&gt;child1());
 726                 fixIntOrBooleanEdge(node-&gt;child2());
 727                 node-&gt;clearFlags(NodeMustGenerate);
 728                 break;
 729             }
<span class="line-modified"> 730             if (Node::shouldSpeculateInt52(node-&gt;child1().node(), node-&gt;child2().node())) {</span>

 731                 fixEdge&lt;Int52RepUse&gt;(node-&gt;child1());
 732                 fixEdge&lt;Int52RepUse&gt;(node-&gt;child2());
 733                 node-&gt;clearFlags(NodeMustGenerate);
 734                 break;
 735             }
 736             if (Node::shouldSpeculateNumberOrBoolean(node-&gt;child1().node(), node-&gt;child2().node())) {
 737                 fixDoubleOrBooleanEdge(node-&gt;child1());
 738                 fixDoubleOrBooleanEdge(node-&gt;child2());
 739             }
 740             if (node-&gt;op() != CompareEq
 741                 &amp;&amp; node-&gt;child1()-&gt;shouldSpeculateNotCell()
 742                 &amp;&amp; node-&gt;child2()-&gt;shouldSpeculateNotCell()) {
 743                 if (node-&gt;child1()-&gt;shouldSpeculateNumberOrBoolean())
 744                     fixDoubleOrBooleanEdge(node-&gt;child1());
 745                 else
 746                     fixEdge&lt;DoubleRepUse&gt;(node-&gt;child1());
 747                 if (node-&gt;child2()-&gt;shouldSpeculateNumberOrBoolean())
 748                     fixDoubleOrBooleanEdge(node-&gt;child2());
 749                 else
 750                     fixEdge&lt;DoubleRepUse&gt;(node-&gt;child2());
</pre>
<hr />
<pre>
 964             default:
 965                 fixEdge&lt;KnownCellUse&gt;(m_graph.varArgChild(node, 0));
 966                 fixEdge&lt;Int32Use&gt;(m_graph.varArgChild(node, 1));
 967                 break;
 968             }
 969 
 970             switch (arrayMode.type()) {
 971             case Array::Double:
 972                 if (!arrayMode.isOutOfBounds())
 973                     node-&gt;setResult(NodeResultDouble);
 974                 break;
 975 
 976             case Array::Float32Array:
 977             case Array::Float64Array:
 978                 node-&gt;setResult(NodeResultDouble);
 979                 break;
 980 
 981             case Array::Uint32Array:
 982                 if (node-&gt;shouldSpeculateInt32())
 983                     break;
<span class="line-modified"> 984                 if (node-&gt;shouldSpeculateInt52())</span>
 985                     node-&gt;setResult(NodeResultInt52);
 986                 else
 987                     node-&gt;setResult(NodeResultDouble);
 988                 break;
 989 
 990             default:
 991                 break;
 992             }
 993 
 994             break;
 995         }
 996 
 997         case PutByValDirect:
 998         case PutByVal:
 999         case PutByValAlias: {
1000             Edge&amp; child1 = m_graph.varArgChild(node, 0);
1001             Edge&amp; child2 = m_graph.varArgChild(node, 1);
1002             Edge&amp; child3 = m_graph.varArgChild(node, 2);
1003 
1004             node-&gt;setArrayMode(
</pre>
<hr />
<pre>
1043                 fixEdge&lt;KnownCellUse&gt;(child1);
1044                 fixEdge&lt;Int32Use&gt;(child2);
1045                 fixEdge&lt;Int32Use&gt;(child3);
1046                 break;
1047             case Array::Double:
1048                 fixEdge&lt;KnownCellUse&gt;(child1);
1049                 fixEdge&lt;Int32Use&gt;(child2);
1050                 fixEdge&lt;DoubleRepRealUse&gt;(child3);
1051                 break;
1052             case Array::Int8Array:
1053             case Array::Int16Array:
1054             case Array::Int32Array:
1055             case Array::Uint8Array:
1056             case Array::Uint8ClampedArray:
1057             case Array::Uint16Array:
1058             case Array::Uint32Array:
1059                 fixEdge&lt;KnownCellUse&gt;(child1);
1060                 fixEdge&lt;Int32Use&gt;(child2);
1061                 if (child3-&gt;shouldSpeculateInt32())
1062                     fixIntOrBooleanEdge(child3);
<span class="line-modified">1063                 else if (child3-&gt;shouldSpeculateInt52())</span>
1064                     fixEdge&lt;Int52RepUse&gt;(child3);
1065                 else
1066                     fixDoubleOrBooleanEdge(child3);
1067                 break;
1068             case Array::Float32Array:
1069             case Array::Float64Array:
1070                 fixEdge&lt;KnownCellUse&gt;(child1);
1071                 fixEdge&lt;Int32Use&gt;(child2);
1072                 fixDoubleOrBooleanEdge(child3);
1073                 break;
1074             case Array::Contiguous:
1075             case Array::ArrayStorage:
1076             case Array::SlowPutArrayStorage:
1077                 fixEdge&lt;KnownCellUse&gt;(child1);
1078                 fixEdge&lt;Int32Use&gt;(child2);
1079                 speculateForBarrier(child3);
1080                 break;
1081             default:
1082                 fixEdge&lt;KnownCellUse&gt;(child1);
1083                 fixEdge&lt;Int32Use&gt;(child2);
</pre>
<hr />
<pre>
1088 
1089         case AtomicsAdd:
1090         case AtomicsAnd:
1091         case AtomicsCompareExchange:
1092         case AtomicsExchange:
1093         case AtomicsLoad:
1094         case AtomicsOr:
1095         case AtomicsStore:
1096         case AtomicsSub:
1097         case AtomicsXor: {
1098             Edge&amp; base = m_graph.child(node, 0);
1099             Edge&amp; index = m_graph.child(node, 1);
1100 
1101             bool badNews = false;
1102             for (unsigned i = numExtraAtomicsArgs(node-&gt;op()); i--;) {
1103                 Edge&amp; child = m_graph.child(node, 2 + i);
1104                 // NOTE: DFG is not smart enough to handle double-&gt;int conversions in atomics. So, we
1105                 // just call the function when that happens. But the FTL is totally cool with those
1106                 // conversions.
1107                 if (!child-&gt;shouldSpeculateInt32()
<span class="line-modified">1108                     &amp;&amp; !child-&gt;shouldSpeculateInt52()</span>
1109                     &amp;&amp; !(child-&gt;shouldSpeculateNumberOrBoolean() &amp;&amp; m_graph.m_plan.isFTL()))
1110                     badNews = true;
1111             }
1112 
1113             if (badNews) {
1114                 node-&gt;setArrayMode(ArrayMode(Array::Generic, node-&gt;arrayMode().action()));
1115                 break;
1116             }
1117 
1118             node-&gt;setArrayMode(
1119                 node-&gt;arrayMode().refine(
1120                     m_graph, node, base-&gt;prediction(), index-&gt;prediction()));
1121 
1122             if (node-&gt;arrayMode().type() == Array::Generic)
1123                 break;
1124 
1125             for (unsigned i = numExtraAtomicsArgs(node-&gt;op()); i--;) {
1126                 Edge&amp; child = m_graph.child(node, 2 + i);
1127                 if (child-&gt;shouldSpeculateInt32())
1128                     fixIntOrBooleanEdge(child);
<span class="line-modified">1129                 else if (child-&gt;shouldSpeculateInt52())</span>
1130                     fixEdge&lt;Int52RepUse&gt;(child);
1131                 else {
1132                     RELEASE_ASSERT(child-&gt;shouldSpeculateNumberOrBoolean() &amp;&amp; m_graph.m_plan.isFTL());
1133                     fixDoubleOrBooleanEdge(child);
1134                 }
1135             }
1136 
1137             blessArrayOperation(base, index, m_graph.child(node, 2 + numExtraAtomicsArgs(node-&gt;op())));
1138             fixEdge&lt;CellUse&gt;(base);
1139             fixEdge&lt;Int32Use&gt;(index);
1140 
1141             if (node-&gt;arrayMode().type() == Array::Uint32Array) {
1142                 // NOTE: This means basically always doing Int52.
<span class="line-modified">1143                 if (node-&gt;shouldSpeculateInt52())</span>
1144                     node-&gt;setResult(NodeResultInt52);
1145                 else
1146                     node-&gt;setResult(NodeResultDouble);
1147             }
1148             break;
1149         }
1150 
1151         case AtomicsIsLockFree:
1152             if (node-&gt;child1()-&gt;shouldSpeculateInt32())
1153                 fixIntOrBooleanEdge(node-&gt;child1());
1154             break;
1155 
1156         case ArrayPush: {
1157             // May need to refine the array mode in case the value prediction contravenes
1158             // the array prediction. For example, we may have evidence showing that the
1159             // array is in Int32 mode, but the value we&#39;re storing is likely to be a double.
1160             // Then we should turn this into a conversion to Double array followed by the
1161             // push. On the other hand, we absolutely don&#39;t want to refine based on the
1162             // base prediction. If it has non-cell garbage in it, then we want that to be
1163             // ignored. That&#39;s because ArrayPush can&#39;t handle any array modes that aren&#39;t
</pre>
<hr />
<pre>
1177                         element-&gt;prediction()));
1178             }
1179             blessArrayOperation(arrayEdge, Edge(), storageEdge);
1180             fixEdge&lt;KnownCellUse&gt;(arrayEdge);
1181 
1182             // Convert `array.push()` to GetArrayLength.
1183             if (!elementCount &amp;&amp; node-&gt;arrayMode().supportsSelfLength()) {
1184                 node-&gt;setOpAndDefaultFlags(GetArrayLength);
1185                 node-&gt;child1() = arrayEdge;
1186                 node-&gt;child2() = storageEdge;
1187                 fixEdge&lt;KnownCellUse&gt;(node-&gt;child1());
1188                 break;
1189             }
1190 
1191             // We do not want to perform osr exit and retry for ArrayPush. We insert Check with appropriate type,
1192             // and ArrayPush uses the edge as known typed edge. Therefore, ArrayPush do not need to perform type checks.
1193             for (unsigned i = 0; i &lt; elementCount; ++i) {
1194                 Edge&amp; element = m_graph.varArgChild(node, i + elementOffset);
1195                 switch (node-&gt;arrayMode().type()) {
1196                 case Array::Int32:
<span class="line-modified">1197                     fixEdge&lt;Int32Use&gt;(element);</span>

1198                     break;
1199                 case Array::Double:
<span class="line-modified">1200                     fixEdge&lt;DoubleRepRealUse&gt;(element);</span>

1201                     break;
1202                 case Array::Contiguous:
1203                 case Array::ArrayStorage:
1204                     speculateForBarrier(element);
1205                     break;
1206                 default:
1207                     break;
1208                 }

1209             }
1210             break;
1211         }
1212 
1213         case ArrayPop: {
1214             blessArrayOperation(node-&gt;child1(), Edge(), node-&gt;child2());
1215             fixEdge&lt;KnownCellUse&gt;(node-&gt;child1());
1216             break;
1217         }
1218 
1219         case ArraySlice: {
1220             fixEdge&lt;KnownCellUse&gt;(m_graph.varArgChild(node, 0));
1221             if (node-&gt;numChildren() &gt;= 3) {
1222                 fixEdge&lt;Int32Use&gt;(m_graph.varArgChild(node, 1));
1223                 if (node-&gt;numChildren() == 4)
1224                     fixEdge&lt;Int32Use&gt;(m_graph.varArgChild(node, 2));
1225             }
1226             break;
1227         }
1228 
</pre>
<hr />
<pre>
1547 
1548                 if (uid == vm().propertyNames-&gt;lastIndex.impl()
1549                     &amp;&amp; node-&gt;child1()-&gt;shouldSpeculateRegExpObject()) {
1550                     node-&gt;setOp(GetRegExpObjectLastIndex);
1551                     node-&gt;clearFlags(NodeMustGenerate);
1552                     fixEdge&lt;RegExpObjectUse&gt;(node-&gt;child1());
1553                     break;
1554                 }
1555             }
1556 
1557             if (node-&gt;child1()-&gt;shouldSpeculateNumber()) {
1558                 if (uid == vm().propertyNames-&gt;toString.impl()) {
1559                     if (m_graph.isWatchingNumberToStringWatchpoint(node)) {
1560                         JSGlobalObject* globalObject = m_graph.globalObjectFor(node-&gt;origin.semantic);
1561                         if (node-&gt;child1()-&gt;shouldSpeculateInt32()) {
1562                             insertCheck&lt;Int32Use&gt;(node-&gt;child1().node());
1563                             m_graph.convertToConstant(node, m_graph.freeze(globalObject-&gt;numberProtoToStringFunction()));
1564                             break;
1565                         }
1566 
<span class="line-modified">1567                         if (node-&gt;child1()-&gt;shouldSpeculateInt52()) {</span>
1568                             insertCheck&lt;Int52RepUse&gt;(node-&gt;child1().node());
1569                             m_graph.convertToConstant(node, m_graph.freeze(globalObject-&gt;numberProtoToStringFunction()));
1570                             break;
1571                         }
1572 
1573                         ASSERT(node-&gt;child1()-&gt;shouldSpeculateNumber());
1574                         insertCheck&lt;DoubleRepUse&gt;(node-&gt;child1().node());
1575                         m_graph.convertToConstant(node, m_graph.freeze(globalObject-&gt;numberProtoToStringFunction()));
1576                         break;
1577                     }
1578                 }
1579             }
1580 
1581             if (node-&gt;child1()-&gt;shouldSpeculateCell())
1582                 fixEdge&lt;CellUse&gt;(node-&gt;child1());
1583             break;
1584         }
1585 
1586         case GetByIdWithThis: {
1587             if (node-&gt;child1()-&gt;shouldSpeculateCell() &amp;&amp; node-&gt;child2()-&gt;shouldSpeculateCell()) {
</pre>
<hr />
<pre>
1893         }
1894         case HasGenericProperty: {
1895             fixEdge&lt;CellUse&gt;(node-&gt;child2());
1896             break;
1897         }
1898         case HasStructureProperty: {
1899             fixEdge&lt;StringUse&gt;(node-&gt;child2());
1900             fixEdge&lt;KnownCellUse&gt;(node-&gt;child3());
1901             break;
1902         }
1903         case HasIndexedProperty: {
1904             node-&gt;setArrayMode(
1905                 node-&gt;arrayMode().refine(
1906                     m_graph, node,
1907                     m_graph.varArgChild(node, 0)-&gt;prediction(),
1908                     m_graph.varArgChild(node, 1)-&gt;prediction(),
1909                     SpecNone));
1910 
1911             blessArrayOperation(m_graph.varArgChild(node, 0), m_graph.varArgChild(node, 1), m_graph.varArgChild(node, 2));
1912             fixEdge&lt;CellUse&gt;(m_graph.varArgChild(node, 0));
<span class="line-modified">1913             fixEdge&lt;Int32Use&gt;(m_graph.varArgChild(node, 1));</span>
1914             break;
1915         }
1916         case GetDirectPname: {
1917             Edge&amp; base = m_graph.varArgChild(node, 0);
1918             Edge&amp; property = m_graph.varArgChild(node, 1);
1919             Edge&amp; index = m_graph.varArgChild(node, 2);
1920             Edge&amp; enumerator = m_graph.varArgChild(node, 3);
1921             fixEdge&lt;CellUse&gt;(base);
1922             fixEdge&lt;KnownCellUse&gt;(property);
<span class="line-modified">1923             fixEdge&lt;Int32Use&gt;(index);</span>
1924             fixEdge&lt;KnownCellUse&gt;(enumerator);
1925             break;
1926         }
1927         case GetPropertyEnumerator: {
1928             if (node-&gt;child1()-&gt;shouldSpeculateCell())
1929                 fixEdge&lt;CellUse&gt;(node-&gt;child1());
1930             break;
1931         }
1932         case GetEnumeratorStructurePname: {
1933             fixEdge&lt;KnownCellUse&gt;(node-&gt;child1());
<span class="line-modified">1934             fixEdge&lt;Int32Use&gt;(node-&gt;child2());</span>
1935             break;
1936         }
1937         case GetEnumeratorGenericPname: {
1938             fixEdge&lt;KnownCellUse&gt;(node-&gt;child1());
<span class="line-modified">1939             fixEdge&lt;Int32Use&gt;(node-&gt;child2());</span>
1940             break;
1941         }
1942         case ToIndexString: {
<span class="line-modified">1943             fixEdge&lt;Int32Use&gt;(node-&gt;child1());</span>
1944             break;
1945         }
1946         case ProfileType: {
1947             // We want to insert type checks based on the instructionTypeSet of the TypeLocation, not the globalTypeSet.
1948             // Because the instructionTypeSet is contained in globalTypeSet, if we produce a type check for
1949             // type T for the instructionTypeSet, the global type set must also have information for type T.
1950             // So if it the type check succeeds for type T in the instructionTypeSet, a type check for type T
1951             // in the globalTypeSet would&#39;ve also succeeded.
1952             // (The other direction does not hold in general).
1953 
1954             RefPtr&lt;TypeSet&gt; typeSet = node-&gt;typeLocation()-&gt;m_instructionTypeSet;
1955             RuntimeTypeMask seenTypes = typeSet-&gt;seenTypes();
1956             if (typeSet-&gt;doesTypeConformTo(TypeAnyInt)) {
1957                 if (node-&gt;child1()-&gt;shouldSpeculateInt32()) {
1958                     fixEdge&lt;Int32Use&gt;(node-&gt;child1());
1959                     node-&gt;remove(m_graph);
1960                     break;
1961                 }
1962 
1963                 if (enableInt52()) {
</pre>
<hr />
<pre>
2015 
2016         case PushWithScope: {
2017             // Child 1 is always the current scope, which is guaranteed to be an object
2018             // FIXME: should be KnownObjectUse once that exists (https://bugs.webkit.org/show_bug.cgi?id=175689)
2019             fixEdge&lt;KnownCellUse&gt;(node-&gt;child1());
2020             if (node-&gt;child2()-&gt;shouldSpeculateObject())
2021                 fixEdge&lt;ObjectUse&gt;(node-&gt;child2());
2022             break;
2023         }
2024 
2025         case SetFunctionName: {
2026             // The first child is guaranteed to be a cell because op_set_function_name is only used
2027             // on a newly instantiated function object (the first child).
2028             fixEdge&lt;KnownCellUse&gt;(node-&gt;child1());
2029             fixEdge&lt;UntypedUse&gt;(node-&gt;child2());
2030             break;
2031         }
2032 
2033         case CreateRest: {
2034             watchHavingABadTime(node);
<span class="line-modified">2035             fixEdge&lt;Int32Use&gt;(node-&gt;child1());</span>
2036             break;
2037         }
2038 
2039         case ResolveScopeForHoistingFuncDeclInEval: {
2040             fixEdge&lt;KnownCellUse&gt;(node-&gt;child1());
2041             break;
2042         }
2043         case ResolveScope:
2044         case GetDynamicVar:
2045         case PutDynamicVar: {
2046             fixEdge&lt;KnownCellUse&gt;(node-&gt;child1());
2047             break;
2048         }
2049 
2050         case LogShadowChickenPrologue: {
2051             fixEdge&lt;KnownCellUse&gt;(node-&gt;child1());
2052             break;
2053         }
2054         case LogShadowChickenTail: {
2055             fixEdge&lt;UntypedUse&gt;(node-&gt;child1());
</pre>
<hr />
<pre>
2179 
2180         case WeakMapSet: {
2181             fixEdge&lt;WeakMapObjectUse&gt;(m_graph.varArgChild(node, 0));
2182             fixEdge&lt;ObjectUse&gt;(m_graph.varArgChild(node, 1));
2183             fixEdge&lt;Int32Use&gt;(m_graph.varArgChild(node, 3));
2184             break;
2185         }
2186 
2187         case DefineDataProperty: {
2188             fixEdge&lt;CellUse&gt;(m_graph.varArgChild(node, 0));
2189             Edge&amp; propertyEdge = m_graph.varArgChild(node, 1);
2190             if (propertyEdge-&gt;shouldSpeculateSymbol())
2191                 fixEdge&lt;SymbolUse&gt;(propertyEdge);
2192             else if (propertyEdge-&gt;shouldSpeculateStringIdent())
2193                 fixEdge&lt;StringIdentUse&gt;(propertyEdge);
2194             else if (propertyEdge-&gt;shouldSpeculateString())
2195                 fixEdge&lt;StringUse&gt;(propertyEdge);
2196             else
2197                 fixEdge&lt;UntypedUse&gt;(propertyEdge);
2198             fixEdge&lt;UntypedUse&gt;(m_graph.varArgChild(node, 2));
<span class="line-modified">2199             fixEdge&lt;Int32Use&gt;(m_graph.varArgChild(node, 3));</span>
2200             break;
2201         }
2202 
2203         case StringValueOf: {
2204             fixupStringValueOf(node);
2205             break;
2206         }
2207 
2208         case StringSlice: {
2209             fixEdge&lt;StringUse&gt;(node-&gt;child1());
2210             fixEdge&lt;Int32Use&gt;(node-&gt;child2());
2211             if (node-&gt;child3())
2212                 fixEdge&lt;Int32Use&gt;(node-&gt;child3());
2213             break;
2214         }
2215 
2216         case ToLowerCase: {
2217             // We currently only support StringUse since that will ensure that
2218             // ToLowerCase is a pure operation. If we decide to update this with
2219             // more types in the future, we need to ensure that the clobberize rules
2220             // are correct.
2221             fixEdge&lt;StringUse&gt;(node-&gt;child1());
2222             break;
2223         }
2224 
2225         case NumberToStringWithRadix: {
2226             if (node-&gt;child1()-&gt;shouldSpeculateInt32())
2227                 fixEdge&lt;Int32Use&gt;(node-&gt;child1());
<span class="line-modified">2228             else if (node-&gt;child1()-&gt;shouldSpeculateInt52())</span>
2229                 fixEdge&lt;Int52RepUse&gt;(node-&gt;child1());
2230             else
2231                 fixEdge&lt;DoubleRepUse&gt;(node-&gt;child1());
2232             fixEdge&lt;Int32Use&gt;(node-&gt;child2());
2233             break;
2234         }
2235 
2236         case DefineAccessorProperty: {
2237             fixEdge&lt;CellUse&gt;(m_graph.varArgChild(node, 0));
2238             Edge&amp; propertyEdge = m_graph.varArgChild(node, 1);
2239             if (propertyEdge-&gt;shouldSpeculateSymbol())
2240                 fixEdge&lt;SymbolUse&gt;(propertyEdge);
2241             else if (propertyEdge-&gt;shouldSpeculateStringIdent())
2242                 fixEdge&lt;StringIdentUse&gt;(propertyEdge);
2243             else if (propertyEdge-&gt;shouldSpeculateString())
2244                 fixEdge&lt;StringUse&gt;(propertyEdge);
2245             else
2246                 fixEdge&lt;UntypedUse&gt;(propertyEdge);
2247             fixEdge&lt;CellUse&gt;(m_graph.varArgChild(node, 2));
2248             fixEdge&lt;CellUse&gt;(m_graph.varArgChild(node, 3));
<span class="line-modified">2249             fixEdge&lt;Int32Use&gt;(m_graph.varArgChild(node, 4));</span>
2250             break;
2251         }
2252 
2253         case CheckSubClass: {
2254             fixupCheckSubClass(node);
2255             break;
2256         }
2257 
2258         case CallDOMGetter: {
2259             DOMJIT::CallDOMGetterSnippet* snippet = node-&gt;callDOMGetterData()-&gt;snippet;
2260             fixEdge&lt;CellUse&gt;(node-&gt;child1()); // DOM.
2261             if (snippet &amp;&amp; snippet-&gt;requireGlobalObject)
2262                 fixEdge&lt;KnownCellUse&gt;(node-&gt;child2()); // GlobalObject.
2263             break;
2264         }
2265 
2266         case CallDOM: {
2267             fixupCallDOM(node);
2268             break;
2269         }
</pre>
<hr />
<pre>
2353                 fixEdge&lt;DoubleRepUse&gt;(valueToStore);
2354             else {
2355                 switch (data.byteSize) {
2356                 case 1:
2357                 case 2:
2358                     fixEdge&lt;Int32Use&gt;(valueToStore);
2359                     break;
2360                 case 4:
2361                     if (data.isSigned)
2362                         fixEdge&lt;Int32Use&gt;(valueToStore);
2363                     else
2364                         fixEdge&lt;Int52RepUse&gt;(valueToStore);
2365                     break;
2366                 }
2367             }
2368             break;
2369         }
2370 
2371 #if !ASSERT_DISABLED
2372         // Have these no-op cases here to ensure that nobody forgets to add handlers for new opcodes.
<span class="line-modified">2373         case SetArgumentDefinitely:</span>
<span class="line-added">2374         case SetArgumentMaybe:</span>
2375         case JSConstant:
2376         case LazyJSConstant:
2377         case DoubleConstant:
2378         case GetLocal:
2379         case GetCallee:
2380         case GetArgumentCountIncludingThis:
2381         case SetArgumentCountIncludingThis:
2382         case GetRestLength:
2383         case GetArgument:
2384         case Flush:
2385         case PhantomLocal:
2386         case GetGlobalVar:
2387         case GetGlobalLexicalVariable:
2388         case NotifyWrite:
2389         case DirectCall:
2390         case CheckTypeInfoFlags:
2391         case TailCallInlinedCaller:
2392         case DirectTailCallInlinedCaller:
2393         case Construct:
2394         case DirectConstruct:
</pre>
<hr />
<pre>
2643             m_graph.convertToConstant(node, jsBoolean(false));
2644             observeUseKindOnNode&lt;NotCellUse&gt;(node);
2645             return;
2646         }
2647     }
2648 
2649     void fixupGetPrototypeOf(Node* node)
2650     {
2651         // Reflect.getPrototypeOf only accepts Objects. For Reflect.getPrototypeOf, ByteCodeParser attaches ObjectUse edge filter before fixup phase.
2652         if (node-&gt;child1().useKind() != ObjectUse) {
2653             if (node-&gt;child1()-&gt;shouldSpeculateString()) {
2654                 insertCheck&lt;StringUse&gt;(node-&gt;child1().node());
2655                 m_graph.convertToConstant(node, m_graph.freeze(m_graph.globalObjectFor(node-&gt;origin.semantic)-&gt;stringPrototype()));
2656                 return;
2657             }
2658             if (node-&gt;child1()-&gt;shouldSpeculateInt32()) {
2659                 insertCheck&lt;Int32Use&gt;(node-&gt;child1().node());
2660                 m_graph.convertToConstant(node, m_graph.freeze(m_graph.globalObjectFor(node-&gt;origin.semantic)-&gt;numberPrototype()));
2661                 return;
2662             }
<span class="line-modified">2663             if (node-&gt;child1()-&gt;shouldSpeculateInt52()) {</span>
2664                 insertCheck&lt;Int52RepUse&gt;(node-&gt;child1().node());
2665                 m_graph.convertToConstant(node, m_graph.freeze(m_graph.globalObjectFor(node-&gt;origin.semantic)-&gt;numberPrototype()));
2666                 return;
2667             }
2668             if (node-&gt;child1()-&gt;shouldSpeculateNumber()) {
2669                 insertCheck&lt;NumberUse&gt;(node-&gt;child1().node());
2670                 m_graph.convertToConstant(node, m_graph.freeze(m_graph.globalObjectFor(node-&gt;origin.semantic)-&gt;numberPrototype()));
2671                 return;
2672             }
2673             if (node-&gt;child1()-&gt;shouldSpeculateSymbol()) {
2674                 insertCheck&lt;SymbolUse&gt;(node-&gt;child1().node());
2675                 m_graph.convertToConstant(node, m_graph.freeze(m_graph.globalObjectFor(node-&gt;origin.semantic)-&gt;symbolPrototype()));
2676                 return;
2677             }
2678             if (node-&gt;child1()-&gt;shouldSpeculateBoolean()) {
2679                 insertCheck&lt;BooleanUse&gt;(node-&gt;child1().node());
2680                 m_graph.convertToConstant(node, m_graph.freeze(m_graph.globalObjectFor(node-&gt;origin.semantic)-&gt;booleanPrototype()));
2681                 return;
2682             }
2683         }
2684 
2685         if (node-&gt;child1()-&gt;shouldSpeculateFinalObject()) {
2686             fixEdge&lt;FinalObjectUse&gt;(node-&gt;child1());
2687             node-&gt;clearFlags(NodeMustGenerate);
2688             return;
2689         }
2690         if (node-&gt;child1()-&gt;shouldSpeculateArray()) {
2691             fixEdge&lt;ArrayUse&gt;(node-&gt;child1());
2692             node-&gt;clearFlags(NodeMustGenerate);
2693             return;
2694         }
2695         if (node-&gt;child1()-&gt;shouldSpeculateFunction()) {
2696             fixEdge&lt;FunctionUse&gt;(node-&gt;child1());
2697             node-&gt;clearFlags(NodeMustGenerate);
2698             return;
2699         }
2700     }
2701 
2702     void fixupToThis(Node* node)
2703     {
<span class="line-modified">2704         bool isStrictMode = m_graph.isStrictModeFor(node-&gt;origin.semantic);</span>
2705 
<span class="line-modified">2706         if (isStrictMode) {</span>
2707             if (node-&gt;child1()-&gt;shouldSpeculateBoolean()) {
2708                 fixEdge&lt;BooleanUse&gt;(node-&gt;child1());
2709                 node-&gt;convertToIdentity();
2710                 return;
2711             }
2712 
2713             if (node-&gt;child1()-&gt;shouldSpeculateInt32()) {
2714                 fixEdge&lt;Int32Use&gt;(node-&gt;child1());
2715                 node-&gt;convertToIdentity();
2716                 return;
2717             }
2718 
<span class="line-modified">2719             if (node-&gt;child1()-&gt;shouldSpeculateInt52()) {</span>
2720                 fixEdge&lt;Int52RepUse&gt;(node-&gt;child1());
2721                 node-&gt;convertToIdentity();
2722                 node-&gt;setResult(NodeResultInt52);
2723                 return;
2724             }
2725 
2726             if (node-&gt;child1()-&gt;shouldSpeculateNumber()) {
2727                 fixEdge&lt;DoubleRepUse&gt;(node-&gt;child1());
2728                 node-&gt;convertToIdentity();
2729                 node-&gt;setResult(NodeResultDouble);
2730                 return;
2731             }
2732 
2733             if (node-&gt;child1()-&gt;shouldSpeculateSymbol()) {
2734                 fixEdge&lt;SymbolUse&gt;(node-&gt;child1());
2735                 node-&gt;convertToIdentity();
2736                 return;
2737             }
2738 
2739             if (node-&gt;child1()-&gt;shouldSpeculateStringIdent()) {
2740                 fixEdge&lt;StringIdentUse&gt;(node-&gt;child1());
2741                 node-&gt;convertToIdentity();
2742                 return;
2743             }
2744 
2745             if (node-&gt;child1()-&gt;shouldSpeculateString()) {
2746                 fixEdge&lt;StringUse&gt;(node-&gt;child1());
2747                 node-&gt;convertToIdentity();
2748                 return;
2749             }
2750 
2751             if (node-&gt;child1()-&gt;shouldSpeculateBigInt()) {
2752                 fixEdge&lt;BigIntUse&gt;(node-&gt;child1());
2753                 node-&gt;convertToIdentity();
2754                 return;
2755             }
2756         }
2757 
2758         if (node-&gt;child1()-&gt;shouldSpeculateOther()) {
<span class="line-modified">2759             if (isStrictMode) {</span>
2760                 fixEdge&lt;OtherUse&gt;(node-&gt;child1());
2761                 node-&gt;convertToIdentity();
2762                 return;
2763             }
2764 
2765             m_insertionSet.insertNode(
2766                 m_indexInBlock, SpecNone, Check, node-&gt;origin,
2767                 Edge(node-&gt;child1().node(), OtherUse));
2768             observeUseKindOnNode&lt;OtherUse&gt;(node-&gt;child1().node());
2769             m_graph.convertToConstant(
2770                 node, m_graph.globalThisObjectFor(node-&gt;origin.semantic));
2771             return;
2772         }
2773 
2774         // FIXME: This should cover other use cases but we don&#39;t have use kinds for them. It&#39;s not critical,
2775         // however, since we cover all the missing cases in constant folding.
2776         // https://bugs.webkit.org/show_bug.cgi?id=157213
2777         if (node-&gt;child1()-&gt;shouldSpeculateStringObject()) {
2778             fixEdge&lt;StringObjectUse&gt;(node-&gt;child1());
2779             node-&gt;convertToIdentity();
</pre>
<hr />
<pre>
2803 
2804         if (node-&gt;child1()-&gt;shouldSpeculateStringObject()
2805             &amp;&amp; m_graph.canOptimizeStringObjectAccess(node-&gt;origin.semantic)) {
2806             addCheckStructureForOriginalStringObjectUse(StringObjectUse, node-&gt;origin, node-&gt;child1().node());
2807             fixEdge&lt;StringObjectUse&gt;(node-&gt;child1());
2808             node-&gt;convertToToString();
2809             return;
2810         }
2811 
2812         if (node-&gt;child1()-&gt;shouldSpeculateStringOrStringObject()
2813             &amp;&amp; m_graph.canOptimizeStringObjectAccess(node-&gt;origin.semantic)) {
2814             addCheckStructureForOriginalStringObjectUse(StringOrStringObjectUse, node-&gt;origin, node-&gt;child1().node());
2815             fixEdge&lt;StringOrStringObjectUse&gt;(node-&gt;child1());
2816             node-&gt;convertToToString();
2817             return;
2818         }
2819     }
2820 
2821     void fixupToNumber(Node* node)
2822     {
<span class="line-added">2823         // At first, attempt to fold Boolean or Int32 to Int32.</span>
<span class="line-added">2824         if (node-&gt;child1()-&gt;shouldSpeculateInt32OrBoolean()) {</span>
<span class="line-added">2825             if (isInt32Speculation(node-&gt;getHeapPrediction())) {</span>
<span class="line-added">2826                 fixIntOrBooleanEdge(node-&gt;child1());</span>
<span class="line-added">2827                 node-&gt;convertToIdentity();</span>
<span class="line-added">2828                 return;</span>
<span class="line-added">2829             }</span>
<span class="line-added">2830         }</span>
<span class="line-added">2831 </span>
2832         // If the prediction of the child is Number, we attempt to convert ToNumber to Identity.
2833         if (node-&gt;child1()-&gt;shouldSpeculateNumber()) {
2834             if (isInt32Speculation(node-&gt;getHeapPrediction())) {
2835                 // If the both predictions of this node and the child is Int32, we just convert ToNumber to Identity, that&#39;s simple.
2836                 if (node-&gt;child1()-&gt;shouldSpeculateInt32()) {
2837                     fixEdge&lt;Int32Use&gt;(node-&gt;child1());
2838                     node-&gt;convertToIdentity();
2839                     return;
2840                 }
2841 
2842                 // The another case is that the predicted type of the child is Int32, but the heap prediction tell the users that this will produce non Int32 values.
2843                 // In that case, let&#39;s receive the child value as a Double value and convert it to Int32. This case happens in misc-bugs-847389-jpeg2000.
2844                 fixEdge&lt;DoubleRepUse&gt;(node-&gt;child1());
2845                 node-&gt;setOp(DoubleAsInt32);
2846                 if (bytecodeCanIgnoreNegativeZero(node-&gt;arithNodeFlags()))
2847                     node-&gt;setArithMode(Arith::CheckOverflow);
2848                 else
2849                     node-&gt;setArithMode(Arith::CheckOverflowAndNegativeZero);
2850                 return;
2851             }
</pre>
<hr />
<pre>
2942         }
2943 
2944         if (node-&gt;child1()-&gt;shouldSpeculateStringOrStringObject()
2945             &amp;&amp; m_graph.canOptimizeStringObjectAccess(node-&gt;origin.semantic)) {
2946             addCheckStructureForOriginalStringObjectUse(StringOrStringObjectUse, node-&gt;origin, node-&gt;child1().node());
2947             fixEdge&lt;StringOrStringObjectUse&gt;(node-&gt;child1());
2948             return;
2949         }
2950 
2951         if (node-&gt;child1()-&gt;shouldSpeculateCell()) {
2952             fixEdge&lt;CellUse&gt;(node-&gt;child1());
2953             return;
2954         }
2955 
2956         if (node-&gt;child1()-&gt;shouldSpeculateInt32()) {
2957             fixEdge&lt;Int32Use&gt;(node-&gt;child1());
2958             node-&gt;clearFlags(NodeMustGenerate);
2959             return;
2960         }
2961 
<span class="line-modified">2962         if (node-&gt;child1()-&gt;shouldSpeculateInt52()) {</span>
2963             fixEdge&lt;Int52RepUse&gt;(node-&gt;child1());
2964             node-&gt;clearFlags(NodeMustGenerate);
2965             return;
2966         }
2967 
2968         if (node-&gt;child1()-&gt;shouldSpeculateNumber()) {
2969             fixEdge&lt;DoubleRepUse&gt;(node-&gt;child1());
2970             node-&gt;clearFlags(NodeMustGenerate);
2971             return;
2972         }
2973 
2974         // ToString(Symbol) throws an error. So if the child1 can include Symbols,
2975         // we need to care about it in the clobberize. In the following case,
2976         // since NotCellUse edge filter is used and this edge filters Symbols,
2977         // we can say that ToString never throws an error!
2978         if (node-&gt;child1()-&gt;shouldSpeculateNotCell()) {
2979             fixEdge&lt;NotCellUse&gt;(node-&gt;child1());
2980             node-&gt;clearFlags(NodeMustGenerate);
2981             return;
2982         }
</pre>
<hr />
<pre>
3263         case Int32Use:
3264         case KnownInt32Use:
3265             if (alwaysUnboxSimplePrimitives()
3266                 || isInt32Speculation(variable-&gt;prediction()))
3267                 m_profitabilityChanged |= variable-&gt;mergeIsProfitableToUnbox(true);
3268             break;
3269         case NumberUse:
3270         case RealNumberUse:
3271         case DoubleRepUse:
3272         case DoubleRepRealUse:
3273             if (variable-&gt;doubleFormatState() == UsingDoubleFormat)
3274                 m_profitabilityChanged |= variable-&gt;mergeIsProfitableToUnbox(true);
3275             break;
3276         case BooleanUse:
3277         case KnownBooleanUse:
3278             if (alwaysUnboxSimplePrimitives()
3279                 || isBooleanSpeculation(variable-&gt;prediction()))
3280                 m_profitabilityChanged |= variable-&gt;mergeIsProfitableToUnbox(true);
3281             break;
3282         case Int52RepUse:
<span class="line-modified">3283             if (!isInt32Speculation(variable-&gt;prediction()) &amp;&amp; isInt32OrInt52Speculation(variable-&gt;prediction()))</span>
3284                 m_profitabilityChanged |= variable-&gt;mergeIsProfitableToUnbox(true);
3285             break;
3286         case CellUse:
3287         case KnownCellUse:
3288         case ObjectUse:
3289         case FunctionUse:
3290         case StringUse:
3291         case KnownStringUse:
3292         case SymbolUse:
3293         case BigIntUse:
3294         case StringObjectUse:
3295         case StringOrStringObjectUse:
3296             if (alwaysUnboxSimplePrimitives()
3297                 || isCellSpeculation(variable-&gt;prediction()))
3298                 m_profitabilityChanged |= variable-&gt;mergeIsProfitableToUnbox(true);
3299             break;
3300         default:
3301             break;
3302         }
3303     }
</pre>
<hr />
<pre>
3354         }
3355     }
3356 
3357     template&lt;UseKind useKind&gt;
3358     void insertCheck(Node* node)
3359     {
3360         observeUseKindOnNode&lt;useKind&gt;(node);
3361         unsigned index = indexForChecks();
3362         m_insertionSet.insertNode(index, SpecNone, Check, originForCheck(index), Edge(node, useKind));
3363     }
3364 
3365     void fixIntConvertingEdge(Edge&amp; edge)
3366     {
3367         Node* node = edge.node();
3368         if (node-&gt;shouldSpeculateInt32OrBoolean()) {
3369             fixIntOrBooleanEdge(edge);
3370             return;
3371         }
3372 
3373         UseKind useKind;
<span class="line-modified">3374         if (node-&gt;shouldSpeculateInt52())</span>
3375             useKind = Int52RepUse;
3376         else if (node-&gt;shouldSpeculateNumber())
3377             useKind = DoubleRepUse;
3378         else
3379             useKind = NotCellUse;
3380         Node* newNode = m_insertionSet.insertNode(
3381             m_indexInBlock, SpecInt32Only, ValueToInt32, m_currentNode-&gt;origin,
3382             Edge(node, useKind));
3383         observeUseKindOnNode(node, useKind);
3384 
3385         edge = Edge(newNode, KnownInt32Use);
3386     }
3387 
3388     void fixIntOrBooleanEdge(Edge&amp; edge)
3389     {
3390         Node* node = edge.node();
3391         if (!node-&gt;sawBooleans()) {
3392             fixEdge&lt;Int32Use&gt;(edge);
3393             return;
3394         }
</pre>
<hr />
<pre>
3451         if (node-&gt;child1()-&gt;hasConstant())
3452             truncateConstantToInt32(node-&gt;child1());
3453         else
3454             truncateConstantToInt32(node-&gt;child2());
3455     }
3456 
3457     bool attemptToMakeIntegerAdd(Node* node)
3458     {
3459         AddSpeculationMode mode = m_graph.addSpeculationMode(node, FixupPass);
3460         if (mode != DontSpeculateInt32) {
3461             truncateConstantsIfNecessary(node, mode);
3462             fixIntOrBooleanEdge(node-&gt;child1());
3463             fixIntOrBooleanEdge(node-&gt;child2());
3464             if (bytecodeCanTruncateInteger(node-&gt;arithNodeFlags()))
3465                 node-&gt;setArithMode(Arith::Unchecked);
3466             else
3467                 node-&gt;setArithMode(Arith::CheckOverflow);
3468             return true;
3469         }
3470 
<span class="line-modified">3471         if (m_graph.addShouldSpeculateInt52(node)) {</span>
3472             fixEdge&lt;Int52RepUse&gt;(node-&gt;child1());
3473             fixEdge&lt;Int52RepUse&gt;(node-&gt;child2());
3474             node-&gt;setArithMode(Arith::CheckOverflow);
3475             node-&gt;setResult(NodeResultInt52);
3476             return true;
3477         }
3478 
3479         return false;
3480     }
3481 
3482     bool attemptToMakeGetArrayLength(Node* node)
3483     {
3484         if (!isInt32Speculation(node-&gt;prediction()))
3485             return false;
3486         CodeBlock* profiledBlock = m_graph.baselineCodeBlockFor(node-&gt;origin.semantic);
3487         ArrayProfile* arrayProfile =
<span class="line-modified">3488             profiledBlock-&gt;getArrayProfile(node-&gt;origin.semantic.bytecodeIndex());</span>
3489         ArrayMode arrayMode = ArrayMode(Array::SelectUsingPredictions, Array::Read);
3490         if (arrayProfile) {
3491             ConcurrentJSLocker locker(profiledBlock-&gt;m_lock);
3492             arrayProfile-&gt;computeUpdatedPrediction(locker, profiledBlock);
3493             arrayMode = ArrayMode::fromObserved(locker, arrayProfile, Array::Read, false);
3494             if (arrayMode.type() == Array::Unprofiled) {
3495                 // For normal array operations, it makes sense to treat Unprofiled
3496                 // accesses as ForceExit and get more data rather than using
3497                 // predictions and then possibly ending up with a Generic. But here,
3498                 // we treat anything that is Unprofiled as Generic and keep the
3499                 // GetById. I.e. ForceExit = Generic. So, there is no harm - and only
3500                 // profit - from treating the Unprofiled case as
3501                 // SelectUsingPredictions.
3502                 arrayMode = ArrayMode(Array::SelectUsingPredictions, Array::Read);
3503             }
3504         }
3505 
3506         arrayMode = arrayMode.refine(
3507             m_graph, node, node-&gt;child1()-&gt;prediction(), node-&gt;prediction());
3508 
</pre>
<hr />
<pre>
3770             return;
3771         }
3772     }
3773 
3774     void fixupCompareStrictEqAndSameValue(Node* node)
3775     {
3776         ASSERT(node-&gt;op() == SameValue || node-&gt;op() == CompareStrictEq);
3777 
3778         if (Node::shouldSpeculateBoolean(node-&gt;child1().node(), node-&gt;child2().node())) {
3779             fixEdge&lt;BooleanUse&gt;(node-&gt;child1());
3780             fixEdge&lt;BooleanUse&gt;(node-&gt;child2());
3781             node-&gt;setOpAndDefaultFlags(CompareStrictEq);
3782             return;
3783         }
3784         if (Node::shouldSpeculateInt32(node-&gt;child1().node(), node-&gt;child2().node())) {
3785             fixEdge&lt;Int32Use&gt;(node-&gt;child1());
3786             fixEdge&lt;Int32Use&gt;(node-&gt;child2());
3787             node-&gt;setOpAndDefaultFlags(CompareStrictEq);
3788             return;
3789         }
<span class="line-modified">3790         if (Node::shouldSpeculateInt52(node-&gt;child1().node(), node-&gt;child2().node())) {</span>

3791             fixEdge&lt;Int52RepUse&gt;(node-&gt;child1());
3792             fixEdge&lt;Int52RepUse&gt;(node-&gt;child2());
3793             node-&gt;setOpAndDefaultFlags(CompareStrictEq);
3794             return;
3795         }
3796         if (Node::shouldSpeculateNumber(node-&gt;child1().node(), node-&gt;child2().node())) {
3797             fixEdge&lt;DoubleRepUse&gt;(node-&gt;child1());
3798             fixEdge&lt;DoubleRepUse&gt;(node-&gt;child2());
3799             // Do not convert SameValue to CompareStrictEq in this case since SameValue(NaN, NaN) and SameValue(-0, +0)
3800             // are not the same to CompareStrictEq(NaN, NaN) and CompareStrictEq(-0, +0).
3801             return;
3802         }
3803         if (Node::shouldSpeculateSymbol(node-&gt;child1().node(), node-&gt;child2().node())) {
3804             fixEdge&lt;SymbolUse&gt;(node-&gt;child1());
3805             fixEdge&lt;SymbolUse&gt;(node-&gt;child2());
3806             node-&gt;setOpAndDefaultFlags(CompareStrictEq);
3807             return;
3808         }
3809         if (Node::shouldSpeculateBigInt(node-&gt;child1().node(), node-&gt;child2().node())) {
3810             fixEdge&lt;BigIntUse&gt;(node-&gt;child1());
</pre>
<hr />
<pre>
4010                                 useKind = NumberUse;
4011                             else
4012                                 useKind = NotCellUse;
4013 
4014                             result = m_insertionSet.insertNode(
4015                                 indexForChecks, SpecBytecodeDouble, DoubleRep, originForChecks,
4016                                 Edge(edge.node(), useKind));
4017                         }
4018 
4019                         edge.setNode(result);
4020                         break;
4021                     }
4022 
4023                     case Int52RepUse: {
4024                         if (edge-&gt;hasInt52Result())
4025                             break;
4026 
4027                         ASSERT(indexForChecks != UINT_MAX);
4028                         if (edge-&gt;isAnyIntConstant()) {
4029                             result = m_insertionSet.insertNode(
<span class="line-modified">4030                                 indexForChecks, SpecInt52Any, Int52Constant, originForChecks,</span>
4031                                 OpInfo(edge-&gt;constant()));
4032                         } else if (edge-&gt;hasDoubleResult()) {
4033                             result = m_insertionSet.insertNode(
<span class="line-modified">4034                                 indexForChecks, SpecInt52Any, Int52Rep, originForChecks,</span>
4035                                 Edge(edge.node(), DoubleRepAnyIntUse));
4036                         } else if (edge-&gt;shouldSpeculateInt32ForArithmetic()) {
4037                             result = m_insertionSet.insertNode(
4038                                 indexForChecks, SpecInt32Only, Int52Rep, originForChecks,
4039                                 Edge(edge.node(), Int32Use));
4040                         } else {
4041                             result = m_insertionSet.insertNode(
<span class="line-modified">4042                                 indexForChecks, SpecInt52Any, Int52Rep, originForChecks,</span>
4043                                 Edge(edge.node(), AnyIntUse));
4044                         }
4045 
4046                         edge.setNode(result);
4047                         break;
4048                     }
4049 
4050                     default: {
4051                         if (!edge-&gt;hasDoubleResult() &amp;&amp; !edge-&gt;hasInt52Result())
4052                             break;
4053 
4054                         ASSERT(indexForChecks != UINT_MAX);
4055                         if (edge-&gt;hasDoubleResult()) {
4056                             result = m_insertionSet.insertNode(
4057                                 indexForChecks, SpecBytecodeDouble, ValueRep, originForChecks,
4058                                 Edge(edge.node(), DoubleRepUse));
4059                         } else {
4060                             result = m_insertionSet.insertNode(
4061                                 indexForChecks, SpecInt32Only | SpecAnyIntAsDouble, ValueRep,
4062                                 originForChecks, Edge(edge.node(), Int52RepUse));
</pre>
</td>
</tr>
</table>
<center><a href="DFGDriver.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DFGFlowIndexing.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>