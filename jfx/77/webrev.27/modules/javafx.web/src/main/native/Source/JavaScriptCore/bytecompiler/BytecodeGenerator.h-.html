<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecompiler/BytecodeGenerator.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (C) 2008-2018 Apple Inc. All rights reserved.
   3  * Copyright (C) 2008 Cameron Zwarich &lt;cwzwarich@uwaterloo.ca&gt;
   4  * Copyright (C) 2012 Igalia, S.L.
   5  *
   6  * Redistribution and use in source and binary forms, with or without
   7  * modification, are permitted provided that the following conditions
   8  * are met:
   9  *
  10  * 1.  Redistributions of source code must retain the above copyright
  11  *     notice, this list of conditions and the following disclaimer.
  12  * 2.  Redistributions in binary form must reproduce the above copyright
  13  *     notice, this list of conditions and the following disclaimer in the
  14  *     documentation and/or other materials provided with the distribution.
  15  * 3.  Neither the name of Apple Inc. (&quot;Apple&quot;) nor the names of
  16  *     its contributors may be used to endorse or promote products derived
  17  *     from this software without specific prior written permission.
  18  *
  19  * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS &quot;AS IS&quot; AND ANY
  20  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  21  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  22  * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
  23  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  24  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  25  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  26  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  27  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  28  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  29  */
  30 
  31 #pragma once
  32 
  33 #include &quot;CodeBlock.h&quot;
  34 #include &quot;Instruction.h&quot;
  35 #include &quot;Interpreter.h&quot;
  36 #include &quot;JSAsyncGeneratorFunction.h&quot;
  37 #include &quot;JSBigInt.h&quot;
  38 #include &quot;JSGeneratorFunction.h&quot;
  39 #include &quot;JSTemplateObjectDescriptor.h&quot;
  40 #include &quot;Label.h&quot;
  41 #include &quot;LabelScope.h&quot;
  42 #include &quot;Nodes.h&quot;
  43 #include &quot;ParserError.h&quot;
  44 #include &quot;ProfileTypeBytecodeFlag.h&quot;
  45 #include &quot;RegisterID.h&quot;
  46 #include &quot;StaticPropertyAnalyzer.h&quot;
  47 #include &quot;SymbolTable.h&quot;
  48 #include &quot;UnlinkedCodeBlock.h&quot;
  49 #include &lt;functional&gt;
  50 #include &lt;wtf/CheckedArithmetic.h&gt;
  51 #include &lt;wtf/HashFunctions.h&gt;
  52 #include &lt;wtf/SegmentedVector.h&gt;
  53 #include &lt;wtf/SetForScope.h&gt;
  54 #include &lt;wtf/Vector.h&gt;
  55 
  56 namespace JSC {
  57 
  58     class JSImmutableButterfly;
  59     class Identifier;
  60     class IndexedForInContext;
  61     class StructureForInContext;
  62 
  63     enum ExpectedFunction {
  64         NoExpectedFunction,
  65         ExpectObjectConstructor,
  66         ExpectArrayConstructor
  67     };
  68 
  69     enum class EmitAwait { Yes, No };
  70 
  71     enum class DebuggableCall { Yes, No };
  72     enum class ThisResolutionType { Local, Scoped };
  73 
  74     class CallArguments {
  75     public:
  76         CallArguments(BytecodeGenerator&amp;, ArgumentsNode*, unsigned additionalArguments = 0);
  77 
  78         RegisterID* thisRegister() { return m_argv[0].get(); }
  79         RegisterID* argumentRegister(unsigned i) { return m_argv[i + 1].get(); }
  80         unsigned stackOffset() { return -m_argv[0]-&gt;index() + CallFrame::headerSizeInRegisters; }
  81         unsigned argumentCountIncludingThis() { return m_argv.size() - m_padding; }
  82         ArgumentsNode* argumentsNode() { return m_argumentsNode; }
  83 
  84     private:
  85         ArgumentsNode* m_argumentsNode;
  86         Vector&lt;RefPtr&lt;RegisterID&gt;, 8, UnsafeVectorOverflow&gt; m_argv;
  87         unsigned m_padding;
  88     };
  89 
  90     // https://tc39.github.io/ecma262/#sec-completion-record-specification-type
  91     //
  92     // For the Break and Continue cases, instead of using the Break and Continue enum values
  93     // below, we use the unique jumpID of the break and continue statement as the encoding
  94     // for the CompletionType value. emitFinallyCompletion() uses this jumpID value later
  95     // to determine the appropriate jump target to jump to after executing the relevant finally
  96     // blocks. The jumpID is computed as:
  97     //     jumpID = bytecodeOffset (of the break/continue node) + CompletionType::NumberOfTypes.
  98     // Hence, there won&#39;t be any collision between jumpIDs and CompletionType enums.
  99     enum class CompletionType : int {
 100         Normal,
 101         Break,
 102         Continue,
 103         Return,
 104         Throw,
 105 
 106         NumberOfTypes
 107     };
 108 
 109     inline CompletionType bytecodeOffsetToJumpID(unsigned offset)
 110     {
 111         int jumpIDAsInt = offset + static_cast&lt;int&gt;(CompletionType::NumberOfTypes);
 112         ASSERT(jumpIDAsInt &gt;= static_cast&lt;int&gt;(CompletionType::NumberOfTypes));
 113         return static_cast&lt;CompletionType&gt;(jumpIDAsInt);
 114     }
 115 
 116     struct FinallyJump {
 117         FinallyJump(CompletionType jumpID, int targetLexicalScopeIndex, Label&amp; targetLabel)
 118             : jumpID(jumpID)
 119             , targetLexicalScopeIndex(targetLexicalScopeIndex)
 120             , targetLabel(targetLabel)
 121         { }
 122 
 123         CompletionType jumpID;
 124         int targetLexicalScopeIndex;
 125         Ref&lt;Label&gt; targetLabel;
 126     };
 127 
 128     struct FinallyContext {
 129         FinallyContext() { }
 130         FinallyContext(FinallyContext* outerContext, Label&amp; finallyLabel)
 131             : m_outerContext(outerContext)
 132             , m_finallyLabel(&amp;finallyLabel)
 133         {
 134             ASSERT(m_jumps.isEmpty());
 135         }
 136 
 137         FinallyContext* outerContext() const { return m_outerContext; }
 138         Label* finallyLabel() const { return m_finallyLabel; }
 139 
 140         uint32_t numberOfBreaksOrContinues() const { return m_numberOfBreaksOrContinues.unsafeGet(); }
 141         void incNumberOfBreaksOrContinues() { m_numberOfBreaksOrContinues++; }
 142 
 143         bool handlesReturns() const { return m_handlesReturns; }
 144         void setHandlesReturns() { m_handlesReturns = true; }
 145 
 146         void registerJump(CompletionType jumpID, int lexicalScopeIndex, Label&amp; targetLabel)
 147         {
 148             m_jumps.append(FinallyJump(jumpID, lexicalScopeIndex, targetLabel));
 149         }
 150 
 151         size_t numberOfJumps() const { return m_jumps.size(); }
 152         FinallyJump&amp; jumps(size_t i) { return m_jumps[i]; }
 153 
 154     private:
 155         FinallyContext* m_outerContext { nullptr };
 156         Label* m_finallyLabel { nullptr };
 157         Checked&lt;uint32_t, WTF::CrashOnOverflow&gt; m_numberOfBreaksOrContinues;
 158         bool m_handlesReturns { false };
 159         Vector&lt;FinallyJump&gt; m_jumps;
 160     };
 161 
 162     struct ControlFlowScope {
 163         typedef uint8_t Type;
 164         enum {
 165             Label,
 166             Finally
 167         };
 168         ControlFlowScope(Type type, int lexicalScopeIndex, FinallyContext&amp;&amp; finallyContext = FinallyContext())
 169             : type(type)
 170             , lexicalScopeIndex(lexicalScopeIndex)
 171             , finallyContext(std::forward&lt;FinallyContext&gt;(finallyContext))
 172         { }
 173 
 174         bool isLabelScope() const { return type == Label; }
 175         bool isFinallyScope() const { return type == Finally; }
 176 
 177         Type type;
 178         int lexicalScopeIndex;
 179         FinallyContext finallyContext;
 180     };
 181 
 182     class ForInContext : public RefCounted&lt;ForInContext&gt; {
 183         WTF_MAKE_FAST_ALLOCATED;
 184         WTF_MAKE_NONCOPYABLE(ForInContext);
 185     public:
 186         virtual ~ForInContext() = default;
 187 
 188         bool isValid() const { return m_isValid; }
 189         void invalidate() { m_isValid = false; }
 190 
 191         enum class Type : uint8_t {
 192             IndexedForIn,
 193             StructureForIn
 194         };
 195 
 196         Type type() const { return m_type; }
 197         bool isIndexedForInContext() const { return m_type == Type::IndexedForIn; }
 198         bool isStructureForInContext() const { return m_type == Type::StructureForIn; }
 199 
 200         IndexedForInContext&amp; asIndexedForInContext()
 201         {
 202             ASSERT(isIndexedForInContext());
 203             return *reinterpret_cast&lt;IndexedForInContext*&gt;(this);
 204         }
 205 
 206         StructureForInContext&amp; asStructureForInContext()
 207         {
 208             ASSERT(isStructureForInContext());
 209             return *reinterpret_cast&lt;StructureForInContext*&gt;(this);
 210         }
 211 
 212         RegisterID* local() const { return m_localRegister.get(); }
 213 
 214     protected:
 215         ForInContext(RegisterID* localRegister, Type type, unsigned bodyBytecodeStartOffset)
 216             : m_localRegister(localRegister)
 217             , m_type(type)
 218             , m_bodyBytecodeStartOffset(bodyBytecodeStartOffset)
 219         { }
 220 
 221         unsigned bodyBytecodeStartOffset() const { return m_bodyBytecodeStartOffset; }
 222 
 223         void finalize(BytecodeGenerator&amp;, UnlinkedCodeBlock*, unsigned bodyBytecodeEndOffset);
 224 
 225     private:
 226         RefPtr&lt;RegisterID&gt; m_localRegister;
 227         bool m_isValid { true };
 228         Type m_type;
 229         unsigned m_bodyBytecodeStartOffset;
 230     };
 231 
 232     class StructureForInContext : public ForInContext {
 233         using Base = ForInContext;
 234     public:
 235         using GetInst = std::tuple&lt;unsigned, int&gt;;
 236 
 237         StructureForInContext(RegisterID* localRegister, RegisterID* indexRegister, RegisterID* propertyRegister, RegisterID* enumeratorRegister, unsigned bodyBytecodeStartOffset)
 238             : ForInContext(localRegister, Type::StructureForIn, bodyBytecodeStartOffset)
 239             , m_indexRegister(indexRegister)
 240             , m_propertyRegister(propertyRegister)
 241             , m_enumeratorRegister(enumeratorRegister)
 242         {
 243         }
 244 
 245         RegisterID* index() const { return m_indexRegister.get(); }
 246         RegisterID* property() const { return m_propertyRegister.get(); }
 247         RegisterID* enumerator() const { return m_enumeratorRegister.get(); }
 248 
 249         void addGetInst(unsigned instIndex, int propertyRegIndex)
 250         {
 251             m_getInsts.append(GetInst { instIndex, propertyRegIndex });
 252         }
 253 
 254         void finalize(BytecodeGenerator&amp;, UnlinkedCodeBlock*, unsigned bodyBytecodeEndOffset);
 255 
 256     private:
 257         RefPtr&lt;RegisterID&gt; m_indexRegister;
 258         RefPtr&lt;RegisterID&gt; m_propertyRegister;
 259         RefPtr&lt;RegisterID&gt; m_enumeratorRegister;
 260         Vector&lt;GetInst&gt; m_getInsts;
 261     };
 262 
 263     class IndexedForInContext : public ForInContext {
 264         using Base = ForInContext;
 265     public:
 266         IndexedForInContext(RegisterID* localRegister, RegisterID* indexRegister, unsigned bodyBytecodeStartOffset)
 267             : ForInContext(localRegister, Type::IndexedForIn, bodyBytecodeStartOffset)
 268             , m_indexRegister(indexRegister)
 269         {
 270         }
 271 
 272         RegisterID* index() const { return m_indexRegister.get(); }
 273 
 274         void finalize(BytecodeGenerator&amp;, UnlinkedCodeBlock*, unsigned bodyBytecodeEndOffset);
 275         void addGetInst(unsigned instIndex, int propertyIndex) { m_getInsts.append({ instIndex, propertyIndex }); }
 276 
 277     private:
 278         RefPtr&lt;RegisterID&gt; m_indexRegister;
 279         Vector&lt;std::pair&lt;unsigned, int&gt;&gt; m_getInsts;
 280     };
 281 
 282     struct TryData {
 283         Ref&lt;Label&gt; target;
 284         HandlerType handlerType;
 285     };
 286 
 287     struct TryContext {
 288         Ref&lt;Label&gt; start;
 289         TryData* tryData;
 290     };
 291 
 292     class Variable {
 293     public:
 294         enum VariableKind { NormalVariable, SpecialVariable };
 295 
 296         Variable()
 297             : m_offset()
 298             , m_local(nullptr)
 299             , m_attributes(0)
 300             , m_kind(NormalVariable)
 301             , m_symbolTableConstantIndex(0) // This is meaningless here for this kind of Variable.
 302             , m_isLexicallyScoped(false)
 303         {
 304         }
 305 
 306         Variable(const Identifier&amp; ident)
 307             : m_ident(ident)
 308             , m_local(nullptr)
 309             , m_attributes(0)
 310             , m_kind(NormalVariable) // This is somewhat meaningless here for this kind of Variable.
 311             , m_symbolTableConstantIndex(0) // This is meaningless here for this kind of Variable.
 312             , m_isLexicallyScoped(false)
 313         {
 314         }
 315 
 316         Variable(const Identifier&amp; ident, VarOffset offset, RegisterID* local, unsigned attributes, VariableKind kind, int symbolTableConstantIndex, bool isLexicallyScoped)
 317             : m_ident(ident)
 318             , m_offset(offset)
 319             , m_local(local)
 320             , m_attributes(attributes)
 321             , m_kind(kind)
 322             , m_symbolTableConstantIndex(symbolTableConstantIndex)
 323             , m_isLexicallyScoped(isLexicallyScoped)
 324         {
 325         }
 326 
 327         // If it&#39;s unset, then it is a non-locally-scoped variable. If it is set, then it could be
 328         // a stack variable, a scoped variable in a local scope, or a variable captured in the
 329         // direct arguments object.
 330         bool isResolved() const { return !!m_offset; }
 331         int symbolTableConstantIndex() const { ASSERT(isResolved() &amp;&amp; !isSpecial()); return m_symbolTableConstantIndex; }
 332 
 333         const Identifier&amp; ident() const { return m_ident; }
 334 
 335         VarOffset offset() const { return m_offset; }
 336         bool isLocal() const { return m_offset.isStack(); }
 337         RegisterID* local() const { return m_local; }
 338 
 339         bool isReadOnly() const { return m_attributes &amp; PropertyAttribute::ReadOnly; }
 340         bool isSpecial() const { return m_kind != NormalVariable; }
 341         bool isConst() const { return isReadOnly() &amp;&amp; m_isLexicallyScoped; }
 342         void setIsReadOnly() { m_attributes |= PropertyAttribute::ReadOnly; }
 343 
 344         void dump(PrintStream&amp;) const;
 345 
 346     private:
 347         Identifier m_ident;
 348         VarOffset m_offset;
 349         RegisterID* m_local;
 350         unsigned m_attributes;
 351         VariableKind m_kind;
 352         int m_symbolTableConstantIndex;
 353         bool m_isLexicallyScoped;
 354     };
 355 
 356     struct TryRange {
 357         Ref&lt;Label&gt; start;
 358         Ref&lt;Label&gt; end;
 359         TryData* tryData;
 360     };
 361 
 362     class BytecodeGenerator {
 363         WTF_MAKE_FAST_ALLOCATED;
 364         WTF_MAKE_NONCOPYABLE(BytecodeGenerator);
 365 
 366         friend class BoundLabel;
 367         friend class Label;
 368         friend class IndexedForInContext;
 369         friend class StructureForInContext;
 370     public:
 371         typedef DeclarationStacks::FunctionStack FunctionStack;
 372 
 373         BytecodeGenerator(VM&amp;, ProgramNode*, UnlinkedProgramCodeBlock*, DebuggerMode, const VariableEnvironment*);
 374         BytecodeGenerator(VM&amp;, FunctionNode*, UnlinkedFunctionCodeBlock*, DebuggerMode, const VariableEnvironment*);
 375         BytecodeGenerator(VM&amp;, EvalNode*, UnlinkedEvalCodeBlock*, DebuggerMode, const VariableEnvironment*);
 376         BytecodeGenerator(VM&amp;, ModuleProgramNode*, UnlinkedModuleProgramCodeBlock*, DebuggerMode, const VariableEnvironment*);
 377 
 378         ~BytecodeGenerator();
 379 
 380         VM* vm() const { return m_vm; }
 381         ParserArena&amp; parserArena() const { return m_scopeNode-&gt;parserArena(); }
 382         const CommonIdentifiers&amp; propertyNames() const { return *m_vm-&gt;propertyNames; }
 383 
 384         bool isConstructor() const { return m_codeBlock-&gt;isConstructor(); }
 385         DerivedContextType derivedContextType() const { return m_derivedContextType; }
 386         bool usesArrowFunction() const { return m_scopeNode-&gt;usesArrowFunction(); }
 387         bool needsToUpdateArrowFunctionContext() const { return m_needsToUpdateArrowFunctionContext; }
 388         bool usesEval() const { return m_scopeNode-&gt;usesEval(); }
 389         bool usesThis() const { return m_scopeNode-&gt;usesThis(); }
 390         ConstructorKind constructorKind() const { return m_codeBlock-&gt;constructorKind(); }
 391         SuperBinding superBinding() const { return m_codeBlock-&gt;superBinding(); }
 392         JSParserScriptMode scriptMode() const { return m_codeBlock-&gt;scriptMode(); }
 393 
 394         template&lt;typename Node, typename UnlinkedCodeBlock&gt;
 395         static ParserError generate(VM&amp; vm, Node* node, const SourceCode&amp; sourceCode, UnlinkedCodeBlock* unlinkedCodeBlock, DebuggerMode debuggerMode, const VariableEnvironment* environment)
 396         {
 397             MonotonicTime before;
 398             if (UNLIKELY(Options::reportBytecodeCompileTimes()))
 399                 before = MonotonicTime::now();
 400 
 401             DeferGC deferGC(vm.heap);
 402             auto bytecodeGenerator = std::make_unique&lt;BytecodeGenerator&gt;(vm, node, unlinkedCodeBlock, debuggerMode, environment);
 403             auto result = bytecodeGenerator-&gt;generate();
 404 
 405             if (UNLIKELY(Options::reportBytecodeCompileTimes())) {
 406                 MonotonicTime after = MonotonicTime::now();
 407                 dataLogLn(result.isValid() ? &quot;Failed to compile #&quot; : &quot;Compiled #&quot;, CodeBlockHash(sourceCode, unlinkedCodeBlock-&gt;isConstructor() ? CodeForConstruct : CodeForCall), &quot; into bytecode &quot;, bytecodeGenerator-&gt;instructions().size(), &quot; instructions in &quot;, (after - before).milliseconds(), &quot; ms.&quot;);
 408             }
 409             return result;
 410         }
 411 
 412         bool isArgumentNumber(const Identifier&amp;, int);
 413 
 414         Variable variable(const Identifier&amp;, ThisResolutionType = ThisResolutionType::Local);
 415 
 416         enum ExistingVariableMode { VerifyExisting, IgnoreExisting };
 417         void createVariable(const Identifier&amp;, VarKind, SymbolTable*, ExistingVariableMode = VerifyExisting); // Creates the variable, or asserts that the already-created variable is sufficiently compatible.
 418 
 419         // Returns the register storing &quot;this&quot;
 420         RegisterID* thisRegister() { return &amp;m_thisRegister; }
 421         RegisterID* argumentsRegister() { return m_argumentsRegister; }
 422         RegisterID* newTarget()
 423         {
 424             return m_newTargetRegister;
 425         }
 426 
 427         RegisterID* scopeRegister() { return m_scopeRegister; }
 428 
 429         RegisterID* generatorRegister() { return m_generatorRegister; }
 430 
 431         RegisterID* promiseCapabilityRegister() { return m_promiseCapabilityRegister; }
 432 
 433         // Returns the next available temporary register. Registers returned by
 434         // newTemporary require a modified form of reference counting: any
 435         // register with a refcount of 0 is considered &quot;available&quot;, meaning that
 436         // the next instruction may overwrite it.
 437         RegisterID* newTemporary();
 438 
 439         // The same as newTemporary(), but this function returns &quot;suggestion&quot; if
 440         // &quot;suggestion&quot; is a temporary. This function is helpful in situations
 441         // where you&#39;ve put &quot;suggestion&quot; in a RefPtr, but you&#39;d like to allow
 442         // the next instruction to overwrite it anyway.
 443         RegisterID* newTemporaryOr(RegisterID* suggestion) { return suggestion-&gt;isTemporary() ? suggestion : newTemporary(); }
 444 
 445         // Functions for handling of dst register
 446 
 447         RegisterID* ignoredResult() { return &amp;m_ignoredResultRegister; }
 448 
 449         // This will be allocated in the temporary region of registers, but it will
 450         // not be marked as a temporary. This will ensure that finalDestination() does
 451         // not overwrite a block scope variable that it mistakes as a temporary. These
 452         // registers can be (and are) reclaimed when the lexical scope they belong to
 453         // is no longer on the symbol table stack.
 454         RegisterID* newBlockScopeVariable();
 455 
 456         // Returns a place to write intermediate values of an operation
 457         // which reuses dst if it is safe to do so.
 458         RegisterID* tempDestination(RegisterID* dst)
 459         {
 460             return (dst &amp;&amp; dst != ignoredResult() &amp;&amp; dst-&gt;isTemporary()) ? dst : newTemporary();
 461         }
 462 
 463         // Returns the place to write the final output of an operation.
 464         RegisterID* finalDestination(RegisterID* originalDst, RegisterID* tempDst = 0)
 465         {
 466             if (originalDst &amp;&amp; originalDst != ignoredResult())
 467                 return originalDst;
 468             ASSERT(tempDst != ignoredResult());
 469             if (tempDst &amp;&amp; tempDst-&gt;isTemporary())
 470                 return tempDst;
 471             return newTemporary();
 472         }
 473 
 474         RegisterID* destinationForAssignResult(RegisterID* dst)
 475         {
 476             if (dst &amp;&amp; dst != ignoredResult())
 477                 return dst-&gt;isTemporary() ? dst : newTemporary();
 478             return 0;
 479         }
 480 
 481         // Moves src to dst if dst is not null and is different from src, otherwise just returns src.
 482         RegisterID* move(RegisterID* dst, RegisterID* src)
 483         {
 484             return dst == ignoredResult() ? nullptr : (dst &amp;&amp; dst != src) ? emitMove(dst, src) : src;
 485         }
 486 
 487         Ref&lt;LabelScope&gt; newLabelScope(LabelScope::Type, const Identifier* = 0);
 488         Ref&lt;Label&gt; newLabel();
 489         Ref&lt;Label&gt; newEmittedLabel();
 490 
 491         void emitNode(RegisterID* dst, StatementNode* n)
 492         {
 493             SetForScope&lt;bool&gt; tailPositionPoisoner(m_inTailPosition, false);
 494             return emitNodeInTailPosition(dst, n);
 495         }
 496 
 497         void emitNodeInTailPosition(RegisterID* dst, StatementNode* n)
 498         {
 499             // Node::emitCode assumes that dst, if provided, is either a local or a referenced temporary.
 500             ASSERT(!dst || dst == ignoredResult() || !dst-&gt;isTemporary() || dst-&gt;refCount());
 501             if (UNLIKELY(!m_vm-&gt;isSafeToRecurse())) {
 502                 emitThrowExpressionTooDeepException();
 503                 return;
 504             }
 505             if (UNLIKELY(n-&gt;needsDebugHook()))
 506                 emitDebugHook(n);
 507             n-&gt;emitBytecode(*this, dst);
 508         }
 509 
 510         void recordOpcode(OpcodeID);
 511 
 512         ALWAYS_INLINE unsigned addMetadataFor(OpcodeID opcodeID)
 513         {
 514             return m_codeBlock-&gt;metadata().addEntry(opcodeID);
 515         }
 516 
 517         void emitNode(StatementNode* n)
 518         {
 519             emitNode(nullptr, n);
 520         }
 521 
 522         void emitNodeInTailPosition(StatementNode* n)
 523         {
 524             emitNodeInTailPosition(nullptr, n);
 525         }
 526 
 527         RegisterID* emitNode(RegisterID* dst, ExpressionNode* n)
 528         {
 529             SetForScope&lt;bool&gt; tailPositionPoisoner(m_inTailPosition, false);
 530             return emitNodeInTailPosition(dst, n);
 531         }
 532 
 533         RegisterID* emitNodeInTailPosition(RegisterID* dst, ExpressionNode* n)
 534         {
 535             // Node::emitCode assumes that dst, if provided, is either a local or a referenced temporary.
 536             ASSERT(!dst || dst == ignoredResult() || !dst-&gt;isTemporary() || dst-&gt;refCount());
 537             if (UNLIKELY(!m_vm-&gt;isSafeToRecurse()))
 538                 return emitThrowExpressionTooDeepException();
 539             if (UNLIKELY(n-&gt;needsDebugHook()))
 540                 emitDebugHook(n);
 541             return n-&gt;emitBytecode(*this, dst);
 542         }
 543 
 544         RegisterID* emitNode(ExpressionNode* n)
 545         {
 546             return emitNode(nullptr, n);
 547         }
 548 
 549         RegisterID* emitNodeInTailPosition(ExpressionNode* n)
 550         {
 551             return emitNodeInTailPosition(nullptr, n);
 552         }
 553 
 554         RegisterID* emitDefineClassElements(PropertyListNode* n, RegisterID* constructor, RegisterID* prototype)
 555         {
 556             ASSERT(constructor-&gt;refCount() &amp;&amp; prototype-&gt;refCount());
 557             if (UNLIKELY(!m_vm-&gt;isSafeToRecurse()))
 558                 return emitThrowExpressionTooDeepException();
 559             if (UNLIKELY(n-&gt;needsDebugHook()))
 560                 emitDebugHook(n);
 561             return n-&gt;emitBytecode(*this, constructor, prototype);
 562         }
 563 
 564         RegisterID* emitNodeForProperty(RegisterID* dst, ExpressionNode* node)
 565         {
 566             if (node-&gt;isString()) {
 567                 if (Optional&lt;uint32_t&gt; index = parseIndex(static_cast&lt;StringNode*&gt;(node)-&gt;value()))
 568                     return emitLoad(dst, jsNumber(index.value()));
 569             }
 570             return emitNode(dst, node);
 571         }
 572 
 573         RegisterID* emitNodeForProperty(ExpressionNode* n)
 574         {
 575             return emitNodeForProperty(nullptr, n);
 576         }
 577 
 578         void emitNodeInConditionContext(ExpressionNode* n, Label&amp; trueTarget, Label&amp; falseTarget, FallThroughMode fallThroughMode)
 579         {
 580             if (UNLIKELY(!m_vm-&gt;isSafeToRecurse())) {
 581                 emitThrowExpressionTooDeepException();
 582                 return;
 583             }
 584             n-&gt;emitBytecodeInConditionContext(*this, trueTarget, falseTarget, fallThroughMode);
 585         }
 586 
 587         void emitExpressionInfo(const JSTextPosition&amp; divot, const JSTextPosition&amp; divotStart, const JSTextPosition&amp; divotEnd)
 588         {
 589             ASSERT(divot.offset &gt;= divotStart.offset);
 590             ASSERT(divotEnd.offset &gt;= divot.offset);
 591 
 592             int sourceOffset = m_scopeNode-&gt;source().startOffset();
 593             unsigned firstLine = m_scopeNode-&gt;source().firstLine().oneBasedInt();
 594 
 595             int divotOffset = divot.offset - sourceOffset;
 596             int startOffset = divot.offset - divotStart.offset;
 597             int endOffset = divotEnd.offset - divot.offset;
 598 
 599             unsigned line = divot.line;
 600             ASSERT(line &gt;= firstLine);
 601             line -= firstLine;
 602 
 603             int lineStart = divot.lineStartOffset;
 604             if (lineStart &gt; sourceOffset)
 605                 lineStart -= sourceOffset;
 606             else
 607                 lineStart = 0;
 608 
 609             if (divotOffset &lt; lineStart)
 610                 return;
 611 
 612             unsigned column = divotOffset - lineStart;
 613 
 614             unsigned instructionOffset = instructions().size();
 615             if (!m_isBuiltinFunction)
 616                 m_codeBlock-&gt;addExpressionInfo(instructionOffset, divotOffset, startOffset, endOffset, line, column);
 617         }
 618 
 619 
 620         ALWAYS_INLINE bool leftHandSideNeedsCopy(bool rightHasAssignments, bool rightIsPure)
 621         {
 622             return (m_codeType != FunctionCode || rightHasAssignments) &amp;&amp; !rightIsPure;
 623         }
 624 
 625         ALWAYS_INLINE RefPtr&lt;RegisterID&gt; emitNodeForLeftHandSide(ExpressionNode* n, bool rightHasAssignments, bool rightIsPure)
 626         {
 627             if (leftHandSideNeedsCopy(rightHasAssignments, rightIsPure)) {
 628                 RefPtr&lt;RegisterID&gt; dst = newTemporary();
 629                 emitNode(dst.get(), n);
 630                 return dst;
 631             }
 632 
 633             return emitNode(n);
 634         }
 635 
 636         ALWAYS_INLINE RefPtr&lt;RegisterID&gt; emitNodeForLeftHandSideForProperty(ExpressionNode* n, bool rightHasAssignments, bool rightIsPure)
 637         {
 638             if (leftHandSideNeedsCopy(rightHasAssignments, rightIsPure)) {
 639                 RefPtr&lt;RegisterID&gt; dst = newTemporary();
 640                 emitNodeForProperty(dst.get(), n);
 641                 return dst;
 642             }
 643 
 644             return emitNodeForProperty(n);
 645         }
 646 
 647         void hoistSloppyModeFunctionIfNecessary(const Identifier&amp; functionName);
 648 
 649     private:
 650         void emitTypeProfilerExpressionInfo(const JSTextPosition&amp; startDivot, const JSTextPosition&amp; endDivot);
 651     public:
 652 
 653         // This doesn&#39;t emit expression info. If using this, make sure you shouldn&#39;t be emitting text offset.
 654         void emitProfileType(RegisterID* registerToProfile, ProfileTypeBytecodeFlag);
 655         // These variables are associated with variables in a program. They could be Locals, LocalClosureVar, or ClosureVar.
 656         void emitProfileType(RegisterID* registerToProfile, const Variable&amp;, const JSTextPosition&amp; startDivot, const JSTextPosition&amp; endDivot);
 657 
 658         void emitProfileType(RegisterID* registerToProfile, ProfileTypeBytecodeFlag, const JSTextPosition&amp; startDivot, const JSTextPosition&amp; endDivot);
 659         // These are not associated with variables and don&#39;t have a global id.
 660         void emitProfileType(RegisterID* registerToProfile, const JSTextPosition&amp; startDivot, const JSTextPosition&amp; endDivot);
 661 
 662         void emitProfileControlFlow(int);
 663 
 664         RegisterID* emitLoadArrowFunctionLexicalEnvironment(const Identifier&amp;);
 665         RegisterID* ensureThis();
 666         void emitLoadThisFromArrowFunctionLexicalEnvironment();
 667         RegisterID* emitLoadNewTargetFromArrowFunctionLexicalEnvironment();
 668 
 669         unsigned addConstantIndex();
 670         RegisterID* emitLoad(RegisterID* dst, bool);
 671         RegisterID* emitLoad(RegisterID* dst, const Identifier&amp;);
 672         RegisterID* emitLoad(RegisterID* dst, JSValue, SourceCodeRepresentation = SourceCodeRepresentation::Other);
 673         RegisterID* emitLoad(RegisterID* dst, IdentifierSet&amp; excludedList);
 674 
 675         template&lt;typename UnaryOp, typename = std::enable_if_t&lt;UnaryOp::opcodeID != op_negate&gt;&gt;
 676         RegisterID* emitUnaryOp(RegisterID* dst, RegisterID* src)
 677         {
 678             UnaryOp::emit(this, dst, src);
 679             return dst;
 680         }
 681 
 682         RegisterID* emitUnaryOp(OpcodeID, RegisterID* dst, RegisterID* src, OperandTypes);
 683 
 684         template&lt;typename BinaryOp&gt;
 685         std::enable_if_t&lt;
 686             BinaryOp::opcodeID != op_add
 687             &amp;&amp; BinaryOp::opcodeID != op_mul
 688             &amp;&amp; BinaryOp::opcodeID != op_sub
 689             &amp;&amp; BinaryOp::opcodeID != op_div,
 690             RegisterID*&gt;
 691         emitBinaryOp(RegisterID* dst, RegisterID* src1, RegisterID* src2, OperandTypes)
 692         {
 693             BinaryOp::emit(this, dst, src1, src2);
 694             return dst;
 695         }
 696 
 697         template&lt;typename BinaryOp&gt;
 698         std::enable_if_t&lt;
 699             BinaryOp::opcodeID == op_add
 700             || BinaryOp::opcodeID == op_mul
 701             || BinaryOp::opcodeID == op_sub
 702             || BinaryOp::opcodeID == op_div,
 703             RegisterID*&gt;
 704         emitBinaryOp(RegisterID* dst, RegisterID* src1, RegisterID* src2, OperandTypes types)
 705         {
 706             BinaryOp::emit(this, dst, src1, src2, types);
 707             return dst;
 708         }
 709 
 710         RegisterID* emitBinaryOp(OpcodeID, RegisterID* dst, RegisterID* src1, RegisterID* src2, OperandTypes);
 711 
 712         template&lt;typename EqOp&gt;
 713         RegisterID* emitEqualityOp(RegisterID* dst, RegisterID* src1, RegisterID* src2);
 714         RegisterID* emitCreateThis(RegisterID* dst);
 715         void emitTDZCheck(RegisterID* target);
 716         bool needsTDZCheck(const Variable&amp;);
 717         void emitTDZCheckIfNecessary(const Variable&amp;, RegisterID* target, RegisterID* scope);
 718         void liftTDZCheckIfPossible(const Variable&amp;);
 719         RegisterID* emitNewObject(RegisterID* dst);
 720         RegisterID* emitNewArray(RegisterID* dst, ElementNode*, unsigned length, IndexingType recommendedIndexingType); // stops at first elision
 721         RegisterID* emitNewArrayBuffer(RegisterID* dst, JSImmutableButterfly*, IndexingType recommendedIndexingType);
 722         // FIXME: new_array_with_spread should use an array allocation profile and take a recommendedIndexingType
 723         RegisterID* emitNewArrayWithSpread(RegisterID* dst, ElementNode*);
 724         RegisterID* emitNewArrayWithSize(RegisterID* dst, RegisterID* length);
 725 
 726         RegisterID* emitNewFunction(RegisterID* dst, FunctionMetadataNode*);
 727         RegisterID* emitNewFunctionExpression(RegisterID* dst, FuncExprNode*);
 728         RegisterID* emitNewDefaultConstructor(RegisterID* dst, ConstructorKind, const Identifier&amp; name, const Identifier&amp; ecmaName, const SourceCode&amp; classSource);
 729         RegisterID* emitNewArrowFunctionExpression(RegisterID*, ArrowFuncExprNode*);
 730         RegisterID* emitNewMethodDefinition(RegisterID* dst, MethodDefinitionNode*);
 731         RegisterID* emitNewRegExp(RegisterID* dst, RegExp*);
 732 
 733         void emitSetFunctionNameIfNeeded(ExpressionNode* valueNode, RegisterID* value, RegisterID* name);
 734 
 735         RegisterID* moveLinkTimeConstant(RegisterID* dst, LinkTimeConstant);
 736         RegisterID* moveEmptyValue(RegisterID* dst);
 737 
 738         RegisterID* emitToNumber(RegisterID* dst, RegisterID* src);
 739         RegisterID* emitToString(RegisterID* dst, RegisterID* src);
 740         RegisterID* emitToObject(RegisterID* dst, RegisterID* src, const Identifier&amp; message);
 741         RegisterID* emitInc(RegisterID* srcDst);
 742         RegisterID* emitDec(RegisterID* srcDst);
 743 
 744         RegisterID* emitOverridesHasInstance(RegisterID* dst, RegisterID* constructor, RegisterID* hasInstanceValue);
 745         RegisterID* emitInstanceOf(RegisterID* dst, RegisterID* value, RegisterID* basePrototype);
 746         RegisterID* emitInstanceOfCustom(RegisterID* dst, RegisterID* value, RegisterID* constructor, RegisterID* hasInstanceValue);
 747         RegisterID* emitTypeOf(RegisterID* dst, RegisterID* src);
 748         RegisterID* emitInByVal(RegisterID* dst, RegisterID* property, RegisterID* base);
 749         RegisterID* emitInById(RegisterID* dst, RegisterID* base, const Identifier&amp; property);
 750 
 751         RegisterID* emitTryGetById(RegisterID* dst, RegisterID* base, const Identifier&amp; property);
 752         RegisterID* emitGetById(RegisterID* dst, RegisterID* base, const Identifier&amp; property);
 753         RegisterID* emitGetById(RegisterID* dst, RegisterID* base, RegisterID* thisVal, const Identifier&amp; property);
 754         RegisterID* emitDirectGetById(RegisterID* dst, RegisterID* base, const Identifier&amp; property);
 755         RegisterID* emitPutById(RegisterID* base, const Identifier&amp; property, RegisterID* value);
 756         RegisterID* emitPutById(RegisterID* base, RegisterID* thisValue, const Identifier&amp; property, RegisterID* value);
 757         RegisterID* emitDirectPutById(RegisterID* base, const Identifier&amp; property, RegisterID* value, PropertyNode::PutType);
 758         RegisterID* emitDeleteById(RegisterID* dst, RegisterID* base, const Identifier&amp;);
 759         RegisterID* emitGetByVal(RegisterID* dst, RegisterID* base, RegisterID* property);
 760         RegisterID* emitGetByVal(RegisterID* dst, RegisterID* base, RegisterID* thisValue, RegisterID* property);
 761         RegisterID* emitPutByVal(RegisterID* base, RegisterID* property, RegisterID* value);
 762         RegisterID* emitPutByVal(RegisterID* base, RegisterID* thisValue, RegisterID* property, RegisterID* value);
 763         RegisterID* emitDirectPutByVal(RegisterID* base, RegisterID* property, RegisterID* value);
 764         RegisterID* emitDeleteByVal(RegisterID* dst, RegisterID* base, RegisterID* property);
 765 
 766         void emitSuperSamplerBegin();
 767         void emitSuperSamplerEnd();
 768 
 769         RegisterID* emitIdWithProfile(RegisterID* src, SpeculatedType profile);
 770         void emitUnreachable();
 771 
 772         void emitPutGetterById(RegisterID* base, const Identifier&amp; property, unsigned propertyDescriptorOptions, RegisterID* getter);
 773         void emitPutSetterById(RegisterID* base, const Identifier&amp; property, unsigned propertyDescriptorOptions, RegisterID* setter);
 774         void emitPutGetterSetter(RegisterID* base, const Identifier&amp; property, unsigned attributes, RegisterID* getter, RegisterID* setter);
 775         void emitPutGetterByVal(RegisterID* base, RegisterID* property, unsigned propertyDescriptorOptions, RegisterID* getter);
 776         void emitPutSetterByVal(RegisterID* base, RegisterID* property, unsigned propertyDescriptorOptions, RegisterID* setter);
 777 
 778         RegisterID* emitGetArgument(RegisterID* dst, int32_t index);
 779 
 780         // Initialize object with generator fields (@generatorThis, @generatorNext, @generatorState, @generatorFrame)
 781         void emitPutGeneratorFields(RegisterID* nextFunction);
 782 
 783         void emitPutAsyncGeneratorFields(RegisterID* nextFunction);
 784 
 785         ExpectedFunction expectedFunctionForIdentifier(const Identifier&amp;);
 786         RegisterID* emitCall(RegisterID* dst, RegisterID* func, ExpectedFunction, CallArguments&amp;, const JSTextPosition&amp; divot, const JSTextPosition&amp; divotStart, const JSTextPosition&amp; divotEnd, DebuggableCall);
 787         RegisterID* emitCallInTailPosition(RegisterID* dst, RegisterID* func, ExpectedFunction, CallArguments&amp;, const JSTextPosition&amp; divot, const JSTextPosition&amp; divotStart, const JSTextPosition&amp; divotEnd, DebuggableCall);
 788         RegisterID* emitCallEval(RegisterID* dst, RegisterID* func, CallArguments&amp;, const JSTextPosition&amp; divot, const JSTextPosition&amp; divotStart, const JSTextPosition&amp; divotEnd, DebuggableCall);
 789         RegisterID* emitCallVarargs(RegisterID* dst, RegisterID* func, RegisterID* thisRegister, RegisterID* arguments, RegisterID* firstFreeRegister, int32_t firstVarArgOffset, const JSTextPosition&amp; divot, const JSTextPosition&amp; divotStart, const JSTextPosition&amp; divotEnd, DebuggableCall);
 790         RegisterID* emitCallVarargsInTailPosition(RegisterID* dst, RegisterID* func, RegisterID* thisRegister, RegisterID* arguments, RegisterID* firstFreeRegister, int32_t firstVarArgOffset, const JSTextPosition&amp; divot, const JSTextPosition&amp; divotStart, const JSTextPosition&amp; divotEnd, DebuggableCall);
 791         RegisterID* emitCallForwardArgumentsInTailPosition(RegisterID* dst, RegisterID* func, RegisterID* thisRegister, RegisterID* firstFreeRegister, int32_t firstVarArgOffset, const JSTextPosition&amp; divot, const JSTextPosition&amp; divotStart, const JSTextPosition&amp; divotEnd, DebuggableCall);
 792 
 793         enum PropertyDescriptorOption {
 794             PropertyConfigurable = 1,
 795             PropertyWritable     = 1 &lt;&lt; 1,
 796             PropertyEnumerable   = 1 &lt;&lt; 2,
 797         };
 798         void emitCallDefineProperty(RegisterID* newObj, RegisterID* propertyNameRegister,
 799             RegisterID* valueRegister, RegisterID* getterRegister, RegisterID* setterRegister, unsigned options, const JSTextPosition&amp;);
 800 
 801         void emitEnumeration(ThrowableExpressionData* enumerationNode, ExpressionNode* subjectNode, const ScopedLambda&lt;void(BytecodeGenerator&amp;, RegisterID*)&gt;&amp; callBack, ForOfNode* = nullptr, RegisterID* forLoopSymbolTable = nullptr);
 802 
 803         RegisterID* emitGetTemplateObject(RegisterID* dst, TaggedTemplateNode*);
 804         RegisterID* emitGetGlobalPrivate(RegisterID* dst, const Identifier&amp; property);
 805 
 806         enum class ReturnFrom { Normal, Finally };
 807         RegisterID* emitReturn(RegisterID* src, ReturnFrom = ReturnFrom::Normal);
 808         RegisterID* emitEnd(RegisterID* src);
 809 
 810         RegisterID* emitConstruct(RegisterID* dst, RegisterID* func, RegisterID* lazyThis, ExpectedFunction, CallArguments&amp;, const JSTextPosition&amp; divot, const JSTextPosition&amp; divotStart, const JSTextPosition&amp; divotEnd);
 811         RegisterID* emitStrcat(RegisterID* dst, RegisterID* src, int count);
 812         void emitToPrimitive(RegisterID* dst, RegisterID* src);
 813 
 814         ResolveType resolveType();
 815         RegisterID* emitResolveConstantLocal(RegisterID* dst, const Variable&amp;);
 816         RegisterID* emitResolveScope(RegisterID* dst, const Variable&amp;);
 817         RegisterID* emitGetFromScope(RegisterID* dst, RegisterID* scope, const Variable&amp;, ResolveMode);
 818         RegisterID* emitPutToScope(RegisterID* scope, const Variable&amp;, RegisterID* value, ResolveMode, InitializationMode);
 819 
 820         RegisterID* emitResolveScopeForHoistingFuncDeclInEval(RegisterID* dst, const Identifier&amp;);
 821 
 822         RegisterID* initializeVariable(const Variable&amp;, RegisterID* value);
 823 
 824         void emitLabel(Label&amp;);
 825         void emitLoopHint();
 826         void emitJump(Label&amp; target);
 827         void emitJumpIfTrue(RegisterID* cond, Label&amp; target);
 828         void emitJumpIfFalse(RegisterID* cond, Label&amp; target);
 829         void emitJumpIfNotFunctionCall(RegisterID* cond, Label&amp; target);
 830         void emitJumpIfNotFunctionApply(RegisterID* cond, Label&amp; target);
 831 
 832         template&lt;typename BinOp, typename JmpOp&gt;
 833         bool fuseCompareAndJump(RegisterID* cond, Label&amp; target, bool swapOperands = false);
 834 
 835         template&lt;typename UnaryOp, typename JmpOp&gt;
 836         bool fuseTestAndJmp(RegisterID* cond, Label&amp; target);
 837 
 838         void emitEnter();
 839         void emitCheckTraps();
 840 
 841         RegisterID* emitHasIndexedProperty(RegisterID* dst, RegisterID* base, RegisterID* propertyName);
 842         RegisterID* emitHasStructureProperty(RegisterID* dst, RegisterID* base, RegisterID* propertyName, RegisterID* enumerator);
 843         RegisterID* emitHasGenericProperty(RegisterID* dst, RegisterID* base, RegisterID* propertyName);
 844         RegisterID* emitGetPropertyEnumerator(RegisterID* dst, RegisterID* base);
 845         RegisterID* emitGetEnumerableLength(RegisterID* dst, RegisterID* base);
 846         RegisterID* emitGetStructurePropertyEnumerator(RegisterID* dst, RegisterID* base, RegisterID* length);
 847         RegisterID* emitGetGenericPropertyEnumerator(RegisterID* dst, RegisterID* base, RegisterID* length, RegisterID* structureEnumerator);
 848         RegisterID* emitEnumeratorStructurePropertyName(RegisterID* dst, RegisterID* enumerator, RegisterID* index);
 849         RegisterID* emitEnumeratorGenericPropertyName(RegisterID* dst, RegisterID* enumerator, RegisterID* index);
 850         RegisterID* emitToIndexString(RegisterID* dst, RegisterID* index);
 851 
 852         RegisterID* emitIsCellWithType(RegisterID* dst, RegisterID* src, JSType);
 853         RegisterID* emitIsJSArray(RegisterID* dst, RegisterID* src) { return emitIsCellWithType(dst, src, ArrayType); }
 854         RegisterID* emitIsProxyObject(RegisterID* dst, RegisterID* src) { return emitIsCellWithType(dst, src, ProxyObjectType); }
 855         RegisterID* emitIsRegExpObject(RegisterID* dst, RegisterID* src) { return emitIsCellWithType(dst, src, RegExpObjectType); }
 856         RegisterID* emitIsMap(RegisterID* dst, RegisterID* src) { return emitIsCellWithType(dst, src, JSMapType); }
 857         RegisterID* emitIsSet(RegisterID* dst, RegisterID* src) { return emitIsCellWithType(dst, src, JSSetType); }
 858         RegisterID* emitIsObject(RegisterID* dst, RegisterID* src);
 859         RegisterID* emitIsNumber(RegisterID* dst, RegisterID* src);
 860         RegisterID* emitIsUndefined(RegisterID* dst, RegisterID* src);
 861         RegisterID* emitIsUndefinedOrNull(RegisterID* dst, RegisterID* src);
 862         RegisterID* emitIsEmpty(RegisterID* dst, RegisterID* src);
 863         RegisterID* emitIsDerivedArray(RegisterID* dst, RegisterID* src) { return emitIsCellWithType(dst, src, DerivedArrayType); }
 864         void emitRequireObjectCoercible(RegisterID* value, const String&amp; error);
 865 
 866         RegisterID* emitIteratorNext(RegisterID* dst, RegisterID* nextMethod, RegisterID* iterator, const ThrowableExpressionData* node, JSC::EmitAwait = JSC::EmitAwait::No);
 867         RegisterID* emitIteratorNextWithValue(RegisterID* dst, RegisterID* nextMethod, RegisterID* iterator, RegisterID* value, const ThrowableExpressionData* node);
 868         void emitIteratorClose(RegisterID* iterator, const ThrowableExpressionData* node, EmitAwait = EmitAwait::No);
 869 
 870         RegisterID* emitRestParameter(RegisterID* result, unsigned numParametersToSkip);
 871 
 872         bool emitReadOnlyExceptionIfNeeded(const Variable&amp;);
 873 
 874         // Start a try block. &#39;start&#39; must have been emitted.
 875         TryData* pushTry(Label&amp; start, Label&amp; handlerLabel, HandlerType);
 876         // End a try block. &#39;end&#39; must have been emitted.
 877         void popTry(TryData*, Label&amp; end);
 878         void emitCatch(RegisterID* exceptionRegister, RegisterID* thrownValueRegister, TryData*);
 879 
 880     private:
 881         static const int CurrentLexicalScopeIndex = -2;
 882         static const int OutermostLexicalScopeIndex = -1;
 883 
 884         int currentLexicalScopeIndex() const
 885         {
 886             int size = static_cast&lt;int&gt;(m_lexicalScopeStack.size());
 887             ASSERT(static_cast&lt;size_t&gt;(size) == m_lexicalScopeStack.size());
 888             ASSERT(size &gt;= 0);
 889             if (!size)
 890                 return OutermostLexicalScopeIndex;
 891             return size - 1;
 892         }
 893 
 894     public:
 895         void restoreScopeRegister();
 896         void restoreScopeRegister(int lexicalScopeIndex);
 897 
 898         int labelScopeDepthToLexicalScopeIndex(int labelScopeDepth);
 899 
 900         void emitThrow(RegisterID*);
 901         RegisterID* emitArgumentCount(RegisterID*);
 902 
 903         void emitThrowStaticError(ErrorType, RegisterID*);
 904         void emitThrowStaticError(ErrorType, const Identifier&amp; message);
 905         void emitThrowReferenceError(const String&amp; message);
 906         void emitThrowTypeError(const String&amp; message);
 907         void emitThrowTypeError(const Identifier&amp; message);
 908         void emitThrowRangeError(const Identifier&amp; message);
 909         void emitThrowOutOfMemoryError();
 910 
 911         void emitPushCatchScope(VariableEnvironment&amp;);
 912         void emitPopCatchScope(VariableEnvironment&amp;);
 913 
 914         RegisterID* emitGetIterator(RegisterID*, ThrowableExpressionData*);
 915         RegisterID* emitGetAsyncIterator(RegisterID*, ThrowableExpressionData*);
 916 
 917         void emitAwait(RegisterID*);
 918         void emitGetScope();
 919         RegisterID* emitPushWithScope(RegisterID* objectScope);
 920         void emitPopWithScope();
 921         void emitPutThisToArrowFunctionContextScope();
 922         void emitPutNewTargetToArrowFunctionContextScope();
 923         void emitPutDerivedConstructorToArrowFunctionContextScope();
 924         RegisterID* emitLoadDerivedConstructorFromArrowFunctionLexicalEnvironment();
 925 
 926         void emitDebugHook(DebugHookType, const JSTextPosition&amp;);
 927         void emitDebugHook(DebugHookType, unsigned line, unsigned charOffset, unsigned lineStart);
 928         void emitDebugHook(StatementNode*);
 929         void emitDebugHook(ExpressionNode*);
 930         void emitWillLeaveCallFrameDebugHook();
 931 
 932         class CompletionRecordScope {
 933         public:
 934             CompletionRecordScope(BytecodeGenerator&amp; generator, bool needCompletionRecordRegisters = true)
 935                 : m_generator(generator)
 936             {
 937                 if (needCompletionRecordRegisters &amp;&amp; m_generator.allocateCompletionRecordRegisters())
 938                     m_needToReleaseOnDestruction = true;
 939             }
 940             ~CompletionRecordScope()
 941             {
 942                 if (m_needToReleaseOnDestruction)
 943                     m_generator.releaseCompletionRecordRegisters();
 944             }
 945 
 946         private:
 947             BytecodeGenerator&amp; m_generator;
 948             bool m_needToReleaseOnDestruction { false };
 949         };
 950 
 951         RegisterID* completionTypeRegister() const
 952         {
 953             ASSERT(m_completionTypeRegister);
 954             return m_completionTypeRegister.get();
 955         }
 956         RegisterID* completionValueRegister() const
 957         {
 958             ASSERT(m_completionValueRegister);
 959             return m_completionValueRegister.get();
 960         }
 961 
 962         void emitSetCompletionType(CompletionType type)
 963         {
 964             emitLoad(completionTypeRegister(), JSValue(static_cast&lt;int&gt;(type)));
 965         }
 966         void emitSetCompletionValue(RegisterID* reg)
 967         {
 968             move(completionValueRegister(), reg);
 969         }
 970 
 971         template&lt;typename CompareOp&gt;
 972         void emitJumpIf(RegisterID* completionTypeRegister, CompletionType, Label&amp; jumpTarget);
 973 
 974         bool emitJumpViaFinallyIfNeeded(int targetLabelScopeDepth, Label&amp; jumpTarget);
 975         bool emitReturnViaFinallyIfNeeded(RegisterID* returnRegister);
 976         void emitFinallyCompletion(FinallyContext&amp;, RegisterID* completionTypeRegister, Label&amp; normalCompletionLabel);
 977 
 978     private:
 979         bool allocateCompletionRecordRegisters();
 980         void releaseCompletionRecordRegisters();
 981 
 982     public:
 983         FinallyContext* pushFinallyControlFlowScope(Label&amp; finallyLabel);
 984         FinallyContext popFinallyControlFlowScope();
 985 
 986         void pushIndexedForInScope(RegisterID* local, RegisterID* index);
 987         void popIndexedForInScope(RegisterID* local);
 988         void pushStructureForInScope(RegisterID* local, RegisterID* index, RegisterID* property, RegisterID* enumerator);
 989         void popStructureForInScope(RegisterID* local);
 990 
 991         LabelScope* breakTarget(const Identifier&amp;);
 992         LabelScope* continueTarget(const Identifier&amp;);
 993 
 994         void beginSwitch(RegisterID*, SwitchInfo::SwitchType);
 995         void endSwitch(uint32_t clauseCount, const Vector&lt;Ref&lt;Label&gt;, 8&gt;&amp;, ExpressionNode**, Label&amp; defaultLabel, int32_t min, int32_t range);
 996 
 997         void emitYieldPoint(RegisterID*, JSAsyncGeneratorFunction::AsyncGeneratorSuspendReason);
 998 
 999         void emitGeneratorStateLabel();
1000         void emitGeneratorStateChange(int32_t state);
1001         RegisterID* emitYield(RegisterID* argument, JSAsyncGeneratorFunction::AsyncGeneratorSuspendReason = JSAsyncGeneratorFunction::AsyncGeneratorSuspendReason::Yield);
1002         RegisterID* emitDelegateYield(RegisterID* argument, ThrowableExpressionData*);
1003         RegisterID* generatorStateRegister() { return &amp;m_parameters[static_cast&lt;int32_t&gt;(JSGeneratorFunction::GeneratorArgument::State)]; }
1004         RegisterID* generatorValueRegister() { return &amp;m_parameters[static_cast&lt;int32_t&gt;(JSGeneratorFunction::GeneratorArgument::Value)]; }
1005         RegisterID* generatorResumeModeRegister() { return &amp;m_parameters[static_cast&lt;int32_t&gt;(JSGeneratorFunction::GeneratorArgument::ResumeMode)]; }
1006         RegisterID* generatorFrameRegister() { return &amp;m_parameters[static_cast&lt;int32_t&gt;(JSGeneratorFunction::GeneratorArgument::Frame)]; }
1007 
1008         CodeType codeType() const { return m_codeType; }
1009 
1010         bool shouldBeConcernedWithCompletionValue() const { return m_codeType != FunctionCode; }
1011 
1012         bool shouldEmitDebugHooks() const { return m_shouldEmitDebugHooks; }
1013 
1014         bool isStrictMode() const { return m_codeBlock-&gt;isStrictMode(); }
1015 
1016         SourceParseMode parseMode() const { return m_codeBlock-&gt;parseMode(); }
1017 
1018         bool isBuiltinFunction() const { return m_isBuiltinFunction; }
1019 
1020         OpcodeID lastOpcodeID() const { return m_lastOpcodeID; }
1021 
1022         bool isDerivedConstructorContext() { return m_derivedContextType == DerivedContextType::DerivedConstructorContext; }
1023         bool isDerivedClassContext() { return m_derivedContextType == DerivedContextType::DerivedMethodContext; }
1024         bool isArrowFunction() { return m_codeBlock-&gt;isArrowFunction(); }
1025 
1026         enum class TDZCheckOptimization { Optimize, DoNotOptimize };
1027         enum class NestedScopeType { IsNested, IsNotNested };
1028     private:
1029         enum class TDZRequirement { UnderTDZ, NotUnderTDZ };
1030         enum class ScopeType { CatchScope, LetConstScope, FunctionNameScope };
1031         enum class ScopeRegisterType { Var, Block };
1032         void pushLexicalScopeInternal(VariableEnvironment&amp;, TDZCheckOptimization, NestedScopeType, RegisterID** constantSymbolTableResult, TDZRequirement, ScopeType, ScopeRegisterType);
1033         void initializeBlockScopedFunctions(VariableEnvironment&amp;, FunctionStack&amp;, RegisterID* constantSymbolTable);
1034         void popLexicalScopeInternal(VariableEnvironment&amp;);
1035         template&lt;typename LookUpVarKindFunctor&gt;
1036         bool instantiateLexicalVariables(const VariableEnvironment&amp;, SymbolTable*, ScopeRegisterType, LookUpVarKindFunctor);
1037         void emitPrefillStackTDZVariables(const VariableEnvironment&amp;, SymbolTable*);
1038         void emitPopScope(RegisterID* dst, RegisterID* scope);
1039         RegisterID* emitGetParentScope(RegisterID* dst, RegisterID* scope);
1040         void emitPushFunctionNameScope(const Identifier&amp; property, RegisterID* value, bool isCaptured);
1041         void emitNewFunctionExpressionCommon(RegisterID*, FunctionMetadataNode*);
1042 
1043         bool isNewTargetUsedInInnerArrowFunction();
1044         bool isArgumentsUsedInInnerArrowFunction();
1045 
1046         void emitToThis();
1047 
1048         RegisterID* emitMove(RegisterID* dst, RegisterID* src);
1049 
1050     public:
1051         bool isSuperUsedInInnerArrowFunction();
1052         bool isSuperCallUsedInInnerArrowFunction();
1053         bool isThisUsedInInnerArrowFunction();
1054         void pushLexicalScope(VariableEnvironmentNode*, TDZCheckOptimization, NestedScopeType = NestedScopeType::IsNotNested, RegisterID** constantSymbolTableResult = nullptr, bool shouldInitializeBlockScopedFunctions = true);
1055         void popLexicalScope(VariableEnvironmentNode*);
1056         void prepareLexicalScopeForNextForLoopIteration(VariableEnvironmentNode*, RegisterID* loopSymbolTable);
1057         int labelScopeDepth() const;
1058         UnlinkedArrayProfile newArrayProfile();
1059 
1060     private:
1061         ParserError generate();
1062         void reclaimFreeRegisters();
1063         Variable variableForLocalEntry(const Identifier&amp;, const SymbolTableEntry&amp;, int symbolTableConstantIndex, bool isLexicallyScoped);
1064 
1065         RegisterID* kill(RegisterID* dst)
1066         {
1067             m_staticPropertyAnalyzer.kill(dst);
1068             return dst;
1069         }
1070 
1071         void retrieveLastUnaryOp(int&amp; dstIndex, int&amp; srcIndex);
1072         ALWAYS_INLINE void rewind();
1073 
1074         void allocateCalleeSaveSpace();
1075         void allocateAndEmitScope();
1076 
1077         template&lt;typename JumpOp&gt;
1078         void setTargetForJumpInstruction(InstructionStream::MutableRef&amp;, int target);
1079 
1080         using BigIntMapEntry = std::tuple&lt;UniquedStringImpl*, uint8_t, bool&gt;;
1081 
1082         using NumberMap = HashMap&lt;double, JSValue&gt;;
1083         using IdentifierStringMap = HashMap&lt;UniquedStringImpl*, JSString*, IdentifierRepHash&gt;;
1084         using IdentifierBigIntMap = HashMap&lt;BigIntMapEntry, JSBigInt*&gt;;
1085         using TemplateObjectDescriptorMap = HashMap&lt;Ref&lt;TemplateObjectDescriptor&gt;, JSTemplateObjectDescriptor*&gt;;
1086 
1087         // Helper for emitCall() and emitConstruct(). This works because the set of
1088         // expected functions have identical behavior for both call and construct
1089         // (i.e. &quot;Object()&quot; is identical to &quot;new Object()&quot;).
1090         ExpectedFunction emitExpectedFunctionSnippet(RegisterID* dst, RegisterID* func, ExpectedFunction, CallArguments&amp;, Label&amp; done);
1091 
1092         template&lt;typename CallOp&gt;
1093         RegisterID* emitCall(RegisterID* dst, RegisterID* func, ExpectedFunction, CallArguments&amp;, const JSTextPosition&amp; divot, const JSTextPosition&amp; divotStart, const JSTextPosition&amp; divotEnd, DebuggableCall);
1094 
1095         RegisterID* emitCallIterator(RegisterID* iterator, RegisterID* argument, ThrowableExpressionData*);
1096         RegisterID* newRegister();
1097 
1098         // Adds an anonymous local var slot. To give this slot a name, add it to symbolTable().
1099         RegisterID* addVar()
1100         {
1101             ++m_codeBlock-&gt;m_numVars;
1102             RegisterID* result = newRegister();
1103             ASSERT(VirtualRegister(result-&gt;index()).toLocal() == m_codeBlock-&gt;m_numVars - 1);
1104             result-&gt;ref(); // We should never free this slot.
1105             return result;
1106         }
1107 
1108         // Initializes the stack form the parameter; does nothing for the symbol table.
1109         RegisterID* initializeNextParameter();
1110         UniquedStringImpl* visibleNameForParameter(DestructuringPatternNode*);
1111 
1112         RegisterID&amp; registerFor(VirtualRegister reg)
1113         {
1114             if (reg.isLocal())
1115                 return m_calleeLocals[reg.toLocal()];
1116 
1117             if (reg.offset() == CallFrameSlot::callee)
1118                 return m_calleeRegister;
1119 
1120             ASSERT(m_parameters.size());
1121             return m_parameters[reg.toArgument()];
1122         }
1123 
1124         bool hasConstant(const Identifier&amp;) const;
1125         unsigned addConstant(const Identifier&amp;);
1126         RegisterID* addConstantValue(JSValue, SourceCodeRepresentation = SourceCodeRepresentation::Other);
1127         RegisterID* addConstantEmptyValue();
1128 
1129         UnlinkedFunctionExecutable* makeFunction(FunctionMetadataNode* metadata)
1130         {
1131             DerivedContextType newDerivedContextType = DerivedContextType::None;
1132 
1133             if (SourceParseModeSet(SourceParseMode::ArrowFunctionMode, SourceParseMode::AsyncArrowFunctionMode, SourceParseMode::AsyncArrowFunctionBodyMode).contains(metadata-&gt;parseMode())) {
1134                 if (constructorKind() == ConstructorKind::Extends || isDerivedConstructorContext())
1135                     newDerivedContextType = DerivedContextType::DerivedConstructorContext;
1136                 else if (m_codeBlock-&gt;isClassContext() || isDerivedClassContext())
1137                     newDerivedContextType = DerivedContextType::DerivedMethodContext;
1138             }
1139 
1140             CompactVariableMap::Handle variablesUnderTDZ = getVariablesUnderTDZ();
1141 
1142             // FIXME: These flags, ParserModes and propagation to XXXCodeBlocks should be reorganized.
1143             // https://bugs.webkit.org/show_bug.cgi?id=151547
1144             SourceParseMode parseMode = metadata-&gt;parseMode();
1145             ConstructAbility constructAbility = constructAbilityForParseMode(parseMode);
1146             if (parseMode == SourceParseMode::MethodMode &amp;&amp; metadata-&gt;constructorKind() != ConstructorKind::None)
1147                 constructAbility = ConstructAbility::CanConstruct;
1148 
1149             return UnlinkedFunctionExecutable::create(m_vm, m_scopeNode-&gt;source(), metadata, isBuiltinFunction() ? UnlinkedBuiltinFunction : UnlinkedNormalFunction, constructAbility, scriptMode(), WTFMove(variablesUnderTDZ), newDerivedContextType);
1150         }
1151 
1152         CompactVariableMap::Handle getVariablesUnderTDZ();
1153 
1154         RegisterID* emitConstructVarargs(RegisterID* dst, RegisterID* func, RegisterID* thisRegister, RegisterID* arguments, RegisterID* firstFreeRegister, int32_t firstVarArgOffset, const JSTextPosition&amp; divot, const JSTextPosition&amp; divotStart, const JSTextPosition&amp; divotEnd, DebuggableCall);
1155         template&lt;typename CallOp&gt;
1156         RegisterID* emitCallVarargs(RegisterID* dst, RegisterID* func, RegisterID* thisRegister, RegisterID* arguments, RegisterID* firstFreeRegister, int32_t firstVarArgOffset, const JSTextPosition&amp; divot, const JSTextPosition&amp; divotStart, const JSTextPosition&amp; divotEnd, DebuggableCall);
1157 
1158         void emitLogShadowChickenPrologueIfNecessary();
1159         void emitLogShadowChickenTailIfNecessary();
1160 
1161         void initializeParameters(FunctionParameters&amp;);
1162         void initializeVarLexicalEnvironment(int symbolTableConstantIndex, SymbolTable* functionSymbolTable, bool hasCapturedVariables);
1163         void initializeDefaultParameterValuesAndSetupFunctionScopeStack(FunctionParameters&amp;, bool isSimpleParameterList, FunctionNode*, SymbolTable*, int symbolTableConstantIndex, const ScopedLambda&lt;bool (UniquedStringImpl*)&gt;&amp; captures, bool shouldCreateArgumentsVariableInParameterScope);
1164         void initializeArrowFunctionContextScopeIfNeeded(SymbolTable* functionSymbolTable = nullptr, bool canReuseLexicalEnvironment = false);
1165         bool needsDerivedConstructorInArrowFunctionLexicalEnvironment();
1166 
1167         enum class TDZNecessityLevel {
1168             NotNeeded,
1169             Optimize,
1170             DoNotOptimize
1171         };
1172         typedef HashMap&lt;RefPtr&lt;UniquedStringImpl&gt;, TDZNecessityLevel, IdentifierRepHash&gt; TDZMap;
1173 
1174     public:
1175         JSString* addStringConstant(const Identifier&amp;);
1176         JSValue addBigIntConstant(const Identifier&amp;, uint8_t radix, bool sign);
1177         RegisterID* addTemplateObjectConstant(Ref&lt;TemplateObjectDescriptor&gt;&amp;&amp;);
1178 
1179         const InstructionStream&amp; instructions() const { return m_writer; }
1180 
1181         RegisterID* emitThrowExpressionTooDeepException();
1182 
1183         void write(uint8_t byte) { m_writer.write(byte); }
1184         void write(uint32_t i) { m_writer.write(i); }
1185         void alignWideOpcode();
1186 
1187         class PreservedTDZStack {
1188         private:
1189             Vector&lt;TDZMap&gt; m_preservedTDZStack;
1190             friend class BytecodeGenerator;
1191         };
1192 
1193         void preserveTDZStack(PreservedTDZStack&amp;);
1194         void restoreTDZStack(const PreservedTDZStack&amp;);
1195 
1196         template&lt;typename Func&gt;
1197         void withWriter(InstructionStreamWriter&amp; writer, const Func&amp; fn)
1198         {
1199             auto prevLastOpcodeID = m_lastOpcodeID;
1200             auto prevLastInstruction = m_lastInstruction;
1201             m_writer.swap(writer);
1202             m_lastOpcodeID = op_end;
1203             m_lastInstruction = m_writer.ref();
1204             fn();
1205             m_writer.swap(writer);
1206             m_lastOpcodeID = prevLastOpcodeID;
1207             m_lastInstruction = prevLastInstruction;
1208         }
1209 
1210     private:
1211         InstructionStreamWriter m_writer;
1212 
1213         bool m_shouldEmitDebugHooks;
1214 
1215         struct LexicalScopeStackEntry {
1216             SymbolTable* m_symbolTable;
1217             RegisterID* m_scope;
1218             bool m_isWithScope;
1219             int m_symbolTableConstantIndex;
1220         };
1221         Vector&lt;LexicalScopeStackEntry&gt; m_lexicalScopeStack;
1222 
1223         Vector&lt;TDZMap&gt; m_TDZStack;
1224         Optional&lt;size_t&gt; m_varScopeLexicalScopeStackIndex;
1225         void pushTDZVariables(const VariableEnvironment&amp;, TDZCheckOptimization, TDZRequirement);
1226 
1227         ScopeNode* const m_scopeNode;
1228         Strong&lt;UnlinkedCodeBlock&gt; m_codeBlock;
1229 
1230         // Some of these objects keep pointers to one another. They are arranged
1231         // to ensure a sane destruction order that avoids references to freed memory.
1232         HashSet&lt;RefPtr&lt;UniquedStringImpl&gt;, IdentifierRepHash&gt; m_functions;
1233         RegisterID m_ignoredResultRegister;
1234         RegisterID m_thisRegister;
1235         RegisterID m_calleeRegister;
1236         RegisterID* m_scopeRegister { nullptr };
1237         RegisterID* m_topMostScope { nullptr };
1238         RegisterID* m_argumentsRegister { nullptr };
1239         RegisterID* m_lexicalEnvironmentRegister { nullptr };
1240         RegisterID* m_generatorRegister { nullptr };
1241         RegisterID* m_emptyValueRegister { nullptr };
1242         RegisterID* m_newTargetRegister { nullptr };
1243         RegisterID* m_isDerivedConstuctor { nullptr };
1244         RegisterID* m_linkTimeConstantRegisters[LinkTimeConstantCount];
1245         RegisterID* m_arrowFunctionContextLexicalEnvironmentRegister { nullptr };
1246         RegisterID* m_promiseCapabilityRegister { nullptr };
1247 
1248         RefPtr&lt;RegisterID&gt; m_completionTypeRegister;
1249         RefPtr&lt;RegisterID&gt; m_completionValueRegister;
1250 
1251         FinallyContext* m_currentFinallyContext { nullptr };
1252 
1253         SegmentedVector&lt;RegisterID*, 16&gt; m_localRegistersForCalleeSaveRegisters;
1254         SegmentedVector&lt;RegisterID, 32&gt; m_constantPoolRegisters;
1255         SegmentedVector&lt;RegisterID, 32&gt; m_calleeLocals;
1256         SegmentedVector&lt;RegisterID, 32&gt; m_parameters;
1257         SegmentedVector&lt;Label, 32&gt; m_labels;
1258         SegmentedVector&lt;LabelScope, 32&gt; m_labelScopes;
1259         unsigned m_finallyDepth { 0 };
1260         int m_localScopeDepth { 0 };
1261         const CodeType m_codeType;
1262 
1263         int localScopeDepth() const;
1264         void pushLocalControlFlowScope();
1265         void popLocalControlFlowScope();
1266 
1267         // FIXME: Restore overflow checking with UnsafeVectorOverflow once SegmentVector supports it.
1268         // https://bugs.webkit.org/show_bug.cgi?id=165980
1269         SegmentedVector&lt;ControlFlowScope, 16&gt; m_controlFlowScopeStack;
1270         Vector&lt;SwitchInfo&gt; m_switchContextStack;
1271         Vector&lt;Ref&lt;ForInContext&gt;&gt; m_forInContextStack;
1272         Vector&lt;TryContext&gt; m_tryContextStack;
1273         unsigned m_yieldPoints { 0 };
1274 
1275         Strong&lt;SymbolTable&gt; m_generatorFrameSymbolTable;
1276         int m_generatorFrameSymbolTableIndex { 0 };
1277 
1278         enum FunctionVariableType : uint8_t { NormalFunctionVariable, TopLevelFunctionVariable };
1279         Vector&lt;std::pair&lt;FunctionMetadataNode*, FunctionVariableType&gt;&gt; m_functionsToInitialize;
1280         bool m_needToInitializeArguments { false };
1281         RestParameterNode* m_restParameter { nullptr };
1282 
1283         Vector&lt;TryRange&gt; m_tryRanges;
1284         SegmentedVector&lt;TryData, 8&gt; m_tryData;
1285 
1286         int m_nextConstantOffset { 0 };
1287 
1288         typedef HashMap&lt;FunctionMetadataNode*, unsigned&gt; FunctionOffsetMap;
1289         FunctionOffsetMap m_functionOffsets;
1290 
1291         // Constant pool
1292         IdentifierMap m_identifierMap;
1293 
1294         typedef HashMap&lt;EncodedJSValueWithRepresentation, unsigned, EncodedJSValueWithRepresentationHash, EncodedJSValueWithRepresentationHashTraits&gt; JSValueMap;
1295         JSValueMap m_jsValueMap;
1296         IdentifierStringMap m_stringMap;
1297         IdentifierBigIntMap m_bigIntMap;
1298         TemplateObjectDescriptorMap m_templateObjectDescriptorMap;
1299 
1300         StaticPropertyAnalyzer m_staticPropertyAnalyzer;
1301 
1302         VM* m_vm;
1303 
1304         OpcodeID m_lastOpcodeID = op_end;
1305         InstructionStream::MutableRef m_lastInstruction { m_writer.ref() };
1306 
1307         bool m_usesExceptions { false };
1308         bool m_expressionTooDeep { false };
1309         bool m_isBuiltinFunction { false };
1310         bool m_usesNonStrictEval { false };
1311         bool m_inTailPosition { false };
1312         bool m_needsToUpdateArrowFunctionContext;
1313         DerivedContextType m_derivedContextType { DerivedContextType::None };
1314 
1315         CompactVariableMap::Handle m_cachedVariablesUnderTDZ;
1316 
1317         using CatchEntry = std::tuple&lt;TryData*, VirtualRegister, VirtualRegister&gt;;
1318         Vector&lt;CatchEntry&gt; m_catchesToEmit;
1319     };
1320 
1321 
1322 } // namespace JSC
1323 
1324 namespace WTF {
1325 
1326 void printInternal(PrintStream&amp;, JSC::Variable::VariableKind);
1327 
1328 } // namespace WTF
    </pre>
  </body>
</html>