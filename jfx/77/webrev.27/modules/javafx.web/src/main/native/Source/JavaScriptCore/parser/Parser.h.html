<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/JavaScriptCore/parser/Parser.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  *  Copyright (C) 1999-2001 Harri Porten (porten@kde.org)
   3  *  Copyright (C) 2001 Peter Kelly (pmk@post.com)
   4  *  Copyright (C) 2003-2019 Apple Inc. All rights reserved.
   5  *
   6  *  This library is free software; you can redistribute it and/or
   7  *  modify it under the terms of the GNU Library General Public
   8  *  License as published by the Free Software Foundation; either
   9  *  version 2 of the License, or (at your option) any later version.
  10  *
  11  *  This library is distributed in the hope that it will be useful,
  12  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  13  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  14  *  Library General Public License for more details.
  15  *
  16  *  You should have received a copy of the GNU Library General Public License
  17  *  along with this library; see the file COPYING.LIB.  If not, write to
  18  *  the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  19  *  Boston, MA 02110-1301, USA.
  20  *
  21  */
  22 
  23 #pragma once
  24 
  25 #include &quot;ExecutableInfo.h&quot;
  26 #include &quot;Lexer.h&quot;
  27 #include &quot;ModuleScopeData.h&quot;
  28 #include &quot;Nodes.h&quot;
  29 #include &quot;ParseHash.h&quot;
  30 #include &quot;ParserArena.h&quot;
  31 #include &quot;ParserError.h&quot;
  32 #include &quot;ParserFunctionInfo.h&quot;
  33 #include &quot;ParserTokens.h&quot;
  34 #include &quot;SourceProvider.h&quot;
  35 #include &quot;SourceProviderCache.h&quot;
  36 #include &quot;SourceProviderCacheItem.h&quot;
  37 #include &quot;VariableEnvironment.h&quot;
  38 #include &lt;wtf/Forward.h&gt;
  39 #include &lt;wtf/Noncopyable.h&gt;
  40 #include &lt;wtf/RefPtr.h&gt;
  41 
  42 namespace JSC {
  43 
  44 class FunctionMetadataNode;
  45 class FunctionParameters;
  46 class Identifier;
  47 class VM;
  48 class SourceCode;
  49 class SyntaxChecker;
  50 struct DebuggerParseData;
  51 
  52 // Macros to make the more common TreeBuilder types a little less verbose
  53 #define TreeStatement typename TreeBuilder::Statement
  54 #define TreeExpression typename TreeBuilder::Expression
  55 #define TreeFormalParameterList typename TreeBuilder::FormalParameterList
  56 #define TreeSourceElements typename TreeBuilder::SourceElements
  57 #define TreeClause typename TreeBuilder::Clause
  58 #define TreeClauseList typename TreeBuilder::ClauseList
  59 #define TreeArguments typename TreeBuilder::Arguments
  60 #define TreeArgumentsList typename TreeBuilder::ArgumentsList
  61 #define TreeFunctionBody typename TreeBuilder::FunctionBody
  62 #define TreeClassExpression typename TreeBuilder::ClassExpression
  63 #define TreeProperty typename TreeBuilder::Property
  64 #define TreePropertyList typename TreeBuilder::PropertyList
  65 #define TreeDestructuringPattern typename TreeBuilder::DestructuringPattern
  66 
  67 COMPILE_ASSERT(LastUntaggedToken &lt; 64, LessThan64UntaggedTokens);
  68 
  69 enum SourceElementsMode { CheckForStrictMode, DontCheckForStrictMode };
  70 enum FunctionBodyType { ArrowFunctionBodyExpression, ArrowFunctionBodyBlock, StandardFunctionBodyBlock };
  71 enum class FunctionNameRequirements { None, Named, Unnamed };
  72 
  73 enum class DestructuringKind {
  74     DestructureToVariables,
  75     DestructureToLet,
  76     DestructureToConst,
  77     DestructureToCatchParameters,
  78     DestructureToParameters,
  79     DestructureToExpressions
  80 };
  81 
  82 enum class DeclarationType {
  83     VarDeclaration,
  84     LetDeclaration,
  85     ConstDeclaration
  86 };
  87 
  88 enum class DeclarationImportType {
  89     Imported,
  90     ImportedNamespace,
  91     NotImported
  92 };
  93 
  94 enum DeclarationResult {
  95     Valid = 0,
  96     InvalidStrictMode = 1 &lt;&lt; 0,
  97     InvalidDuplicateDeclaration = 1 &lt;&lt; 1
  98 };
  99 
 100 typedef uint8_t DeclarationResultMask;
 101 
 102 enum class DeclarationDefaultContext {
 103     Standard,
 104     ExportDefault,
 105 };
 106 
 107 enum class InferName {
 108     Allowed,
 109     Disallowed,
 110 };
 111 
 112 template &lt;typename T&gt; inline bool isEvalNode() { return false; }
 113 template &lt;&gt; inline bool isEvalNode&lt;EvalNode&gt;() { return true; }
 114 
 115 struct ScopeLabelInfo {
 116     UniquedStringImpl* uid;
 117     bool isLoop;
 118 };
 119 
 120 ALWAYS_INLINE static bool isArguments(const VM&amp; vm, const Identifier* ident)
 121 {
 122     return vm.propertyNames-&gt;arguments == *ident;
 123 }
 124 ALWAYS_INLINE static bool isEval(const VM&amp; vm, const Identifier* ident)
 125 {
 126     return vm.propertyNames-&gt;eval == *ident;
 127 }
 128 ALWAYS_INLINE static bool isEvalOrArgumentsIdentifier(const VM&amp; vm, const Identifier* ident)
 129 {
 130     return isEval(vm, ident) || isArguments(vm, ident);
 131 }
 132 ALWAYS_INLINE static bool isIdentifierOrKeyword(const JSToken&amp; token)
 133 {
 134     return token.m_type == IDENT || token.m_type &amp; KeywordTokenFlag;
 135 }
 136 // _Any_ContextualKeyword includes keywords such as &quot;let&quot; or &quot;yield&quot;, which have a specific meaning depending on the current parse mode
 137 // or strict mode. These helpers allow to treat all contextual keywords as identifiers as required.
 138 ALWAYS_INLINE static bool isAnyContextualKeyword(const JSToken&amp; token)
 139 {
 140     return token.m_type &gt;= FirstContextualKeywordToken &amp;&amp; token.m_type &lt;= LastContextualKeywordToken;
 141 }
 142 ALWAYS_INLINE static bool isIdentifierOrAnyContextualKeyword(const JSToken&amp; token)
 143 {
 144     return token.m_type == IDENT || isAnyContextualKeyword(token);
 145 }
 146 // _Safe_ContextualKeyword includes only contextual keywords which can be treated as identifiers independently from parse mode. The exeption
 147 // to this rule is `await`, but matchSpecIdentifier() always treats it as an identifier regardless.
 148 ALWAYS_INLINE static bool isSafeContextualKeyword(const JSToken&amp; token)
 149 {
 150     return token.m_type &gt;= FirstSafeContextualKeywordToken &amp;&amp; token.m_type &lt;= LastSafeContextualKeywordToken;
 151 }
 152 
 153 JS_EXPORT_PRIVATE extern std::atomic&lt;unsigned&gt; globalParseCount;
 154 
 155 struct Scope {
 156     WTF_MAKE_NONCOPYABLE(Scope);
 157 
 158 public:
 159     Scope(const VM&amp; vm, bool isFunction, bool isGenerator, bool strictMode, bool isArrowFunction, bool isAsyncFunction)
 160         : m_vm(vm)
 161         , m_shadowsArguments(false)
 162         , m_usesEval(false)
 163         , m_needsFullActivation(false)
 164         , m_hasDirectSuper(false)
 165         , m_needsSuperBinding(false)
 166         , m_allowsVarDeclarations(true)
 167         , m_allowsLexicalDeclarations(true)
 168         , m_strictMode(strictMode)
 169         , m_isFunction(isFunction)
 170         , m_isGenerator(isGenerator)
 171         , m_isGeneratorBoundary(false)
 172         , m_isArrowFunction(isArrowFunction)
 173         , m_isArrowFunctionBoundary(false)
 174         , m_isAsyncFunction(isAsyncFunction)
 175         , m_isAsyncFunctionBoundary(false)
 176         , m_isLexicalScope(false)
 177         , m_isGlobalCodeScope(false)
 178         , m_isSimpleCatchParameterScope(false)
 179         , m_isFunctionBoundary(false)
 180         , m_isValidStrictMode(true)
 181         , m_hasArguments(false)
 182         , m_isEvalContext(false)
 183         , m_hasNonSimpleParameterList(false)
 184         , m_evalContextType(EvalContextType::None)
 185         , m_constructorKind(static_cast&lt;unsigned&gt;(ConstructorKind::None))
 186         , m_expectedSuperBinding(static_cast&lt;unsigned&gt;(SuperBinding::NotNeeded))
 187         , m_loopDepth(0)
 188         , m_switchDepth(0)
 189         , m_innerArrowFunctionFeatures(0)
 190     {
 191         m_usedVariables.append(UniquedStringImplPtrSet());
 192     }
 193 
 194     Scope(Scope&amp;&amp;) = default;
 195 
 196     void startSwitch() { m_switchDepth++; }
 197     void endSwitch() { m_switchDepth--; }
 198     void startLoop() { m_loopDepth++; }
 199     void endLoop() { ASSERT(m_loopDepth); m_loopDepth--; }
 200     bool inLoop() { return !!m_loopDepth; }
 201     bool breakIsValid() { return m_loopDepth || m_switchDepth; }
 202     bool continueIsValid() { return m_loopDepth; }
 203 
 204     void pushLabel(const Identifier* label, bool isLoop)
 205     {
 206         if (!m_labels)
 207             m_labels = makeUnique&lt;LabelStack&gt;();
 208         m_labels-&gt;append(ScopeLabelInfo { label-&gt;impl(), isLoop });
 209     }
 210 
 211     void popLabel()
 212     {
 213         ASSERT(m_labels);
 214         ASSERT(m_labels-&gt;size());
 215         m_labels-&gt;removeLast();
 216     }
 217 
 218     ScopeLabelInfo* getLabel(const Identifier* label)
 219     {
 220         if (!m_labels)
 221             return 0;
 222         for (int i = m_labels-&gt;size(); i &gt; 0; i--) {
 223             if (m_labels-&gt;at(i - 1).uid == label-&gt;impl())
 224                 return &amp;m_labels-&gt;at(i - 1);
 225         }
 226         return 0;
 227     }
 228 
 229     void setSourceParseMode(SourceParseMode mode)
 230     {
 231         switch (mode) {
 232         case SourceParseMode::AsyncGeneratorBodyMode:
 233             setIsAsyncGeneratorFunctionBody();
 234             break;
 235         case SourceParseMode::AsyncArrowFunctionBodyMode:
 236             setIsAsyncArrowFunctionBody();
 237             break;
 238 
 239         case SourceParseMode::AsyncFunctionBodyMode:
 240             setIsAsyncFunctionBody();
 241             break;
 242 
 243         case SourceParseMode::GeneratorBodyMode:
 244             setIsGenerator();
 245             break;
 246 
 247         case SourceParseMode::GeneratorWrapperFunctionMode:
 248         case SourceParseMode::GeneratorWrapperMethodMode:
 249             setIsGeneratorFunction();
 250             break;
 251 
 252         case SourceParseMode::AsyncGeneratorWrapperMethodMode:
 253         case SourceParseMode::AsyncGeneratorWrapperFunctionMode:
 254             setIsAsyncGeneratorFunction();
 255             break;
 256 
 257         case SourceParseMode::NormalFunctionMode:
 258         case SourceParseMode::GetterMode:
 259         case SourceParseMode::SetterMode:
 260         case SourceParseMode::MethodMode:
 261             setIsFunction();
 262             break;
 263 
 264         case SourceParseMode::ArrowFunctionMode:
 265             setIsArrowFunction();
 266             break;
 267 
 268         case SourceParseMode::AsyncFunctionMode:
 269         case SourceParseMode::AsyncMethodMode:
 270             setIsAsyncFunction();
 271             break;
 272 
 273         case SourceParseMode::AsyncArrowFunctionMode:
 274             setIsAsyncArrowFunction();
 275             break;
 276 
 277         case SourceParseMode::ProgramMode:
 278         case SourceParseMode::ModuleAnalyzeMode:
 279         case SourceParseMode::ModuleEvaluateMode:
 280             break;
 281         }
 282     }
 283 
 284     bool isFunction() const { return m_isFunction; }
 285     bool isFunctionBoundary() const { return m_isFunctionBoundary; }
 286     bool isGenerator() const { return m_isGenerator; }
 287     bool isGeneratorBoundary() const { return m_isGeneratorBoundary; }
 288     bool isAsyncFunction() const { return m_isAsyncFunction; }
 289     bool isAsyncFunctionBoundary() const { return m_isAsyncFunctionBoundary; }
 290 
 291     bool hasArguments() const { return m_hasArguments; }
 292 
 293     void setIsGlobalCodeScope() { m_isGlobalCodeScope = true; }
 294     bool isGlobalCodeScope() const { return m_isGlobalCodeScope; }
 295 
 296     void setIsSimpleCatchParameterScope() { m_isSimpleCatchParameterScope = true; }
 297     bool isSimpleCatchParameterScope() { return m_isSimpleCatchParameterScope; }
 298 
 299     void setIsLexicalScope()
 300     {
 301         m_isLexicalScope = true;
 302         m_allowsLexicalDeclarations = true;
 303     }
 304     bool isLexicalScope() { return m_isLexicalScope; }
 305     bool usesEval() { return m_usesEval; }
 306 
 307     const HashSet&lt;UniquedStringImpl*&gt;&amp; closedVariableCandidates() const { return m_closedVariableCandidates; }
 308     VariableEnvironment&amp; declaredVariables() { return m_declaredVariables; }
 309     VariableEnvironment&amp; lexicalVariables() { return m_lexicalVariables; }
 310     VariableEnvironment&amp; finalizeLexicalEnvironment()
 311     {
 312         if (m_usesEval || m_needsFullActivation)
 313             m_lexicalVariables.markAllVariablesAsCaptured();
 314         else
 315             computeLexicallyCapturedVariablesAndPurgeCandidates();
 316 
 317         return m_lexicalVariables;
 318     }
 319 
 320     void computeLexicallyCapturedVariablesAndPurgeCandidates()
 321     {
 322         // Because variables may be defined at any time in the range of a lexical scope, we must
 323         // track lexical variables that might be captured. Then, when we&#39;re preparing to pop the top
 324         // lexical scope off the stack, we should find which variables are truly captured, and which
 325         // variable still may be captured in a parent scope.
 326         if (m_lexicalVariables.size() &amp;&amp; m_closedVariableCandidates.size()) {
 327             for (UniquedStringImpl* impl : m_closedVariableCandidates)
 328                 m_lexicalVariables.markVariableAsCapturedIfDefined(impl);
 329         }
 330 
 331         // We can now purge values from the captured candidates because they&#39;re captured in this scope.
 332         {
 333             for (auto entry : m_lexicalVariables) {
 334                 if (entry.value.isCaptured())
 335                     m_closedVariableCandidates.remove(entry.key.get());
 336             }
 337         }
 338     }
 339 
 340     DeclarationResultMask declareCallee(const Identifier* ident)
 341     {
 342         auto addResult = m_declaredVariables.add(ident-&gt;impl());
 343         // We want to track if callee is captured, but we don&#39;t want to act like it&#39;s a &#39;var&#39;
 344         // because that would cause the BytecodeGenerator to emit bad code.
 345         addResult.iterator-&gt;value.clearIsVar();
 346 
 347         DeclarationResultMask result = DeclarationResult::Valid;
 348         if (isEvalOrArgumentsIdentifier(m_vm, ident))
 349             result |= DeclarationResult::InvalidStrictMode;
 350         return result;
 351     }
 352 
 353     DeclarationResultMask declareVariable(const Identifier* ident)
 354     {
 355         ASSERT(m_allowsVarDeclarations);
 356         DeclarationResultMask result = DeclarationResult::Valid;
 357         bool isValidStrictMode = !isEvalOrArgumentsIdentifier(m_vm, ident);
 358         m_isValidStrictMode = m_isValidStrictMode &amp;&amp; isValidStrictMode;
 359         auto addResult = m_declaredVariables.add(ident-&gt;impl());
 360         addResult.iterator-&gt;value.setIsVar();
 361         if (!isValidStrictMode)
 362             result |= DeclarationResult::InvalidStrictMode;
 363         return result;
 364     }
 365 
 366     DeclarationResultMask declareFunction(const Identifier* ident, bool declareAsVar, bool isSloppyModeHoistingCandidate)
 367     {
 368         ASSERT(m_allowsVarDeclarations || m_allowsLexicalDeclarations);
 369         DeclarationResultMask result = DeclarationResult::Valid;
 370         bool isValidStrictMode = !isEvalOrArgumentsIdentifier(m_vm, ident);
 371         if (!isValidStrictMode)
 372             result |= DeclarationResult::InvalidStrictMode;
 373         m_isValidStrictMode = m_isValidStrictMode &amp;&amp; isValidStrictMode;
 374         auto addResult = declareAsVar ? m_declaredVariables.add(ident-&gt;impl()) : m_lexicalVariables.add(ident-&gt;impl());
 375         if (isSloppyModeHoistingCandidate)
 376             addResult.iterator-&gt;value.setIsSloppyModeHoistingCandidate();
 377         if (declareAsVar) {
 378             addResult.iterator-&gt;value.setIsVar();
 379             if (m_lexicalVariables.contains(ident-&gt;impl()))
 380                 result |= DeclarationResult::InvalidDuplicateDeclaration;
 381         } else {
 382             addResult.iterator-&gt;value.setIsLet();
 383             ASSERT_WITH_MESSAGE(!m_declaredVariables.size(), &quot;We should only declare a function as a lexically scoped variable in scopes where var declarations aren&#39;t allowed. I.e, in strict mode and not at the top-level scope of a function or program.&quot;);
 384             if (!addResult.isNewEntry) {
 385                 if (!isSloppyModeHoistingCandidate || !addResult.iterator-&gt;value.isFunction())
 386                     result |= DeclarationResult::InvalidDuplicateDeclaration;
 387             }
 388         }
 389 
 390         addResult.iterator-&gt;value.setIsFunction();
 391 
 392         return result;
 393     }
 394 
 395     void addVariableBeingHoisted(const Identifier* ident)
 396     {
 397         ASSERT(!m_allowsVarDeclarations);
 398         m_variablesBeingHoisted.add(ident-&gt;impl());
 399     }
 400 
 401     void addSloppyModeHoistableFunctionCandidate(const Identifier* ident)
 402     {
 403         ASSERT(m_allowsVarDeclarations);
 404         m_sloppyModeHoistableFunctionCandidates.add(ident-&gt;impl());
 405     }
 406 
 407     void appendFunction(FunctionMetadataNode* node)
 408     {
 409         ASSERT(node);
 410         m_functionDeclarations.append(node);
 411     }
 412     DeclarationStacks::FunctionStack&amp;&amp; takeFunctionDeclarations() { return WTFMove(m_functionDeclarations); }
 413 
 414 
 415     DeclarationResultMask declareLexicalVariable(const Identifier* ident, bool isConstant, DeclarationImportType importType = DeclarationImportType::NotImported)
 416     {
 417         ASSERT(m_allowsLexicalDeclarations);
 418         DeclarationResultMask result = DeclarationResult::Valid;
 419         bool isValidStrictMode = !isEvalOrArgumentsIdentifier(m_vm, ident);
 420         m_isValidStrictMode = m_isValidStrictMode &amp;&amp; isValidStrictMode;
 421         auto addResult = m_lexicalVariables.add(ident-&gt;impl());
 422         if (isConstant)
 423             addResult.iterator-&gt;value.setIsConst();
 424         else
 425             addResult.iterator-&gt;value.setIsLet();
 426 
 427         if (importType == DeclarationImportType::Imported)
 428             addResult.iterator-&gt;value.setIsImported();
 429         else if (importType == DeclarationImportType::ImportedNamespace) {
 430             addResult.iterator-&gt;value.setIsImported();
 431             addResult.iterator-&gt;value.setIsImportedNamespace();
 432         }
 433 
 434         if (!addResult.isNewEntry || m_variablesBeingHoisted.contains(ident-&gt;impl()))
 435             result |= DeclarationResult::InvalidDuplicateDeclaration;
 436         if (!isValidStrictMode)
 437             result |= DeclarationResult::InvalidStrictMode;
 438 
 439         return result;
 440     }
 441 
 442     ALWAYS_INLINE bool hasDeclaredVariable(const Identifier&amp; ident)
 443     {
 444         return hasDeclaredVariable(ident.impl());
 445     }
 446 
 447     bool hasDeclaredVariable(const RefPtr&lt;UniquedStringImpl&gt;&amp; ident)
 448     {
 449         auto iter = m_declaredVariables.find(ident.get());
 450         if (iter == m_declaredVariables.end())
 451             return false;
 452         VariableEnvironmentEntry entry = iter-&gt;value;
 453         return entry.isVar(); // The callee isn&#39;t a &quot;var&quot;.
 454     }
 455 
 456     ALWAYS_INLINE bool hasLexicallyDeclaredVariable(const Identifier&amp; ident)
 457     {
 458         return hasLexicallyDeclaredVariable(ident.impl());
 459     }
 460 
 461     bool hasLexicallyDeclaredVariable(const RefPtr&lt;UniquedStringImpl&gt;&amp; ident) const
 462     {
 463         return m_lexicalVariables.contains(ident.get());
 464     }
 465 
 466     ALWAYS_INLINE bool hasDeclaredParameter(const Identifier&amp; ident)
 467     {
 468         return hasDeclaredParameter(ident.impl());
 469     }
 470 
 471     bool hasDeclaredParameter(const RefPtr&lt;UniquedStringImpl&gt;&amp; ident)
 472     {
 473         return m_declaredParameters.contains(ident.get()) || hasDeclaredVariable(ident);
 474     }
 475 
 476     void preventAllVariableDeclarations()
 477     {
 478         m_allowsVarDeclarations = false;
 479         m_allowsLexicalDeclarations = false;
 480     }
 481     void preventVarDeclarations() { m_allowsVarDeclarations = false; }
 482     bool allowsVarDeclarations() const { return m_allowsVarDeclarations; }
 483     bool allowsLexicalDeclarations() const { return m_allowsLexicalDeclarations; }
 484 
 485     DeclarationResultMask declareParameter(const Identifier* ident)
 486     {
 487         ASSERT(m_allowsVarDeclarations);
 488         DeclarationResultMask result = DeclarationResult::Valid;
 489         bool isArgumentsIdent = isArguments(m_vm, ident);
 490         auto addResult = m_declaredVariables.add(ident-&gt;impl());
 491         bool isValidStrictMode = (addResult.isNewEntry || !addResult.iterator-&gt;value.isParameter())
 492             &amp;&amp; m_vm.propertyNames-&gt;eval != *ident &amp;&amp; !isArgumentsIdent;
 493         addResult.iterator-&gt;value.clearIsVar();
 494         addResult.iterator-&gt;value.setIsParameter();
 495         m_isValidStrictMode = m_isValidStrictMode &amp;&amp; isValidStrictMode;
 496         m_declaredParameters.add(ident-&gt;impl());
 497         if (!isValidStrictMode)
 498             result |= DeclarationResult::InvalidStrictMode;
 499         if (isArgumentsIdent)
 500             m_shadowsArguments = true;
 501         if (!addResult.isNewEntry)
 502             result |= DeclarationResult::InvalidDuplicateDeclaration;
 503 
 504         return result;
 505     }
 506 
 507     bool usedVariablesContains(UniquedStringImpl* impl) const
 508     {
 509         for (const UniquedStringImplPtrSet&amp; set : m_usedVariables) {
 510             if (set.contains(impl))
 511                 return true;
 512         }
 513         return false;
 514     }
 515     template &lt;typename Func&gt;
 516     void forEachUsedVariable(const Func&amp; func)
 517     {
 518         for (const UniquedStringImplPtrSet&amp; set : m_usedVariables) {
 519             for (UniquedStringImpl* impl : set)
 520                 func(impl);
 521         }
 522     }
 523     void useVariable(const Identifier* ident, bool isEval)
 524     {
 525         useVariable(ident-&gt;impl(), isEval);
 526     }
 527     void useVariable(UniquedStringImpl* impl, bool isEval)
 528     {
 529         m_usesEval |= isEval;
 530         m_usedVariables.last().add(impl);
 531     }
 532 
 533     void pushUsedVariableSet() { m_usedVariables.append(UniquedStringImplPtrSet()); }
 534     size_t currentUsedVariablesSize() { return m_usedVariables.size(); }
 535 
 536     void revertToPreviousUsedVariables(size_t size) { m_usedVariables.resize(size); }
 537 
 538     void setNeedsFullActivation() { m_needsFullActivation = true; }
 539     bool needsFullActivation() const { return m_needsFullActivation; }
 540     bool isArrowFunctionBoundary() { return m_isArrowFunctionBoundary; }
 541     bool isArrowFunction() { return m_isArrowFunction; }
 542 
 543     bool hasDirectSuper() const { return m_hasDirectSuper; }
 544     bool setHasDirectSuper() { return std::exchange(m_hasDirectSuper, true); }
 545 
 546     bool needsSuperBinding() const { return m_needsSuperBinding; }
 547     bool setNeedsSuperBinding() { return std::exchange(m_needsSuperBinding, true); }
 548 
 549     void setEvalContextType(EvalContextType evalContextType) { m_evalContextType = evalContextType; }
 550     EvalContextType evalContextType() { return m_evalContextType; }
 551 
 552     InnerArrowFunctionCodeFeatures innerArrowFunctionFeatures() { return m_innerArrowFunctionFeatures; }
 553 
 554     void setExpectedSuperBinding(SuperBinding superBinding) { m_expectedSuperBinding = static_cast&lt;unsigned&gt;(superBinding); }
 555     SuperBinding expectedSuperBinding() const { return static_cast&lt;SuperBinding&gt;(m_expectedSuperBinding); }
 556     void setConstructorKind(ConstructorKind constructorKind) { m_constructorKind = static_cast&lt;unsigned&gt;(constructorKind); }
 557     ConstructorKind constructorKind() const { return static_cast&lt;ConstructorKind&gt;(m_constructorKind); }
 558 
 559     void setInnerArrowFunctionUsesSuperCall() { m_innerArrowFunctionFeatures |= SuperCallInnerArrowFunctionFeature; }
 560     void setInnerArrowFunctionUsesSuperProperty() { m_innerArrowFunctionFeatures |= SuperPropertyInnerArrowFunctionFeature; }
 561     void setInnerArrowFunctionUsesEval() { m_innerArrowFunctionFeatures |= EvalInnerArrowFunctionFeature; }
 562     void setInnerArrowFunctionUsesThis() { m_innerArrowFunctionFeatures |= ThisInnerArrowFunctionFeature; }
 563     void setInnerArrowFunctionUsesNewTarget() { m_innerArrowFunctionFeatures |= NewTargetInnerArrowFunctionFeature; }
 564     void setInnerArrowFunctionUsesArguments() { m_innerArrowFunctionFeatures |= ArgumentsInnerArrowFunctionFeature; }
 565 
 566     bool isEvalContext() const { return m_isEvalContext; }
 567     void setIsEvalContext(bool isEvalContext) { m_isEvalContext = isEvalContext; }
 568 
 569     void setInnerArrowFunctionUsesEvalAndUseArgumentsIfNeeded()
 570     {
 571         ASSERT(m_isArrowFunction);
 572 
 573         if (m_usesEval)
 574             setInnerArrowFunctionUsesEval();
 575 
 576         if (usedVariablesContains(m_vm.propertyNames-&gt;arguments.impl()))
 577             setInnerArrowFunctionUsesArguments();
 578     }
 579 
 580     void addClosedVariableCandidateUnconditionally(UniquedStringImpl* impl)
 581     {
 582         m_closedVariableCandidates.add(impl);
 583     }
 584 
 585     void collectFreeVariables(Scope* nestedScope, bool shouldTrackClosedVariables)
 586     {
 587         if (nestedScope-&gt;m_usesEval)
 588             m_usesEval = true;
 589 
 590         {
 591             UniquedStringImplPtrSet&amp; destinationSet = m_usedVariables.last();
 592             for (const UniquedStringImplPtrSet&amp; usedVariablesSet : nestedScope-&gt;m_usedVariables) {
 593                 for (UniquedStringImpl* impl : usedVariablesSet) {
 594                     if (nestedScope-&gt;m_declaredVariables.contains(impl) || nestedScope-&gt;m_lexicalVariables.contains(impl))
 595                         continue;
 596 
 597                     // &quot;arguments&quot; reference should be resolved at function boudary.
 598                     if (nestedScope-&gt;isFunctionBoundary() &amp;&amp; nestedScope-&gt;hasArguments() &amp;&amp; impl == m_vm.propertyNames-&gt;arguments.impl() &amp;&amp; !nestedScope-&gt;isArrowFunctionBoundary())
 599                         continue;
 600 
 601                     destinationSet.add(impl);
 602                     // We don&#39;t want a declared variable that is used in an inner scope to be thought of as captured if
 603                     // that inner scope is both a lexical scope and not a function. Only inner functions and &quot;catch&quot;
 604                     // statements can cause variables to be captured.
 605                     if (shouldTrackClosedVariables &amp;&amp; (nestedScope-&gt;m_isFunctionBoundary || !nestedScope-&gt;m_isLexicalScope))
 606                         m_closedVariableCandidates.add(impl);
 607                 }
 608             }
 609         }
 610         // Propagate closed variable candidates downwards within the same function.
 611         // Cross function captures will be realized via m_usedVariables propagation.
 612         if (shouldTrackClosedVariables &amp;&amp; !nestedScope-&gt;m_isFunctionBoundary &amp;&amp; nestedScope-&gt;m_closedVariableCandidates.size()) {
 613             auto end = nestedScope-&gt;m_closedVariableCandidates.end();
 614             auto begin = nestedScope-&gt;m_closedVariableCandidates.begin();
 615             m_closedVariableCandidates.add(begin, end);
 616         }
 617     }
 618 
 619     void mergeInnerArrowFunctionFeatures(InnerArrowFunctionCodeFeatures arrowFunctionCodeFeatures)
 620     {
 621         m_innerArrowFunctionFeatures = m_innerArrowFunctionFeatures | arrowFunctionCodeFeatures;
 622     }
 623 
 624     void getSloppyModeHoistedFunctions(UniquedStringImplPtrSet&amp; sloppyModeHoistedFunctions)
 625     {
 626         for (UniquedStringImpl* function : m_sloppyModeHoistableFunctionCandidates) {
 627             // ES6 Annex B.3.3. The only time we can&#39;t hoist a function is if a syntax error would
 628             // be caused by declaring a var with that function&#39;s name or if we have a parameter with
 629             // that function&#39;s name. Note that we would only cause a syntax error if we had a let/const/class
 630             // variable with the same name.
 631             if (!m_lexicalVariables.contains(function)) {
 632                 auto iter = m_declaredVariables.find(function);
 633                 bool isParameter = iter != m_declaredVariables.end() &amp;&amp; iter-&gt;value.isParameter();
 634                 if (!isParameter) {
 635                     auto addResult = m_declaredVariables.add(function);
 636                     addResult.iterator-&gt;value.setIsVar();
 637                     addResult.iterator-&gt;value.setIsSloppyModeHoistingCandidate();
 638                     sloppyModeHoistedFunctions.add(function);
 639                 }
 640             }
 641         }
 642     }
 643 
 644     void getCapturedVars(IdentifierSet&amp; capturedVariables)
 645     {
 646         if (m_needsFullActivation || m_usesEval) {
 647             for (auto&amp; entry : m_declaredVariables)
 648                 capturedVariables.add(entry.key);
 649             return;
 650         }
 651         for (UniquedStringImpl* impl : m_closedVariableCandidates) {
 652             // We refer to m_declaredVariables here directly instead of a hasDeclaredVariable because we want to mark the callee as captured.
 653             if (!m_declaredVariables.contains(impl))
 654                 continue;
 655             capturedVariables.add(impl);
 656         }
 657     }
 658     void setStrictMode() { m_strictMode = true; }
 659     bool strictMode() const { return m_strictMode; }
 660     bool isValidStrictMode() const { return m_isValidStrictMode; }
 661     bool shadowsArguments() const { return m_shadowsArguments; }
 662     void setHasNonSimpleParameterList()
 663     {
 664         m_isValidStrictMode = false;
 665         m_hasNonSimpleParameterList = true;
 666     }
 667     bool hasNonSimpleParameterList() const { return m_hasNonSimpleParameterList; }
 668 
 669     void copyCapturedVariablesToVector(const UniquedStringImplPtrSet&amp; usedVariables, Vector&lt;UniquedStringImpl*, 8&gt;&amp; vector)
 670     {
 671         for (UniquedStringImpl* impl : usedVariables) {
 672             if (m_declaredVariables.contains(impl) || m_lexicalVariables.contains(impl))
 673                 continue;
 674             vector.append(impl);
 675         }
 676     }
 677 
 678     void fillParametersForSourceProviderCache(SourceProviderCacheItemCreationParameters&amp; parameters, const UniquedStringImplPtrSet&amp; capturesFromParameterExpressions)
 679     {
 680         ASSERT(m_isFunction);
 681         parameters.usesEval = m_usesEval;
 682         parameters.strictMode = m_strictMode;
 683         parameters.needsFullActivation = m_needsFullActivation;
 684         parameters.innerArrowFunctionFeatures = m_innerArrowFunctionFeatures;
 685         parameters.needsSuperBinding = m_needsSuperBinding;
 686         for (const UniquedStringImplPtrSet&amp; set : m_usedVariables)
 687             copyCapturedVariablesToVector(set, parameters.usedVariables);
 688 
 689         // FIXME: https://bugs.webkit.org/show_bug.cgi?id=156962
 690         // We add these unconditionally because we currently don&#39;t keep a separate
 691         // declaration scope for a function&#39;s parameters and its var/let/const declarations.
 692         // This is somewhat unfortunate and we should refactor to do this at some point
 693         // because parameters logically form a parent scope to var/let/const variables.
 694         // But because we don&#39;t do this, we must grab capture candidates from a parameter
 695         // list before we parse the body of a function because the body&#39;s declarations
 696         // might make us believe something isn&#39;t actually a capture candidate when it really
 697         // is.
 698         for (UniquedStringImpl* impl : capturesFromParameterExpressions)
 699             parameters.usedVariables.append(impl);
 700     }
 701 
 702     void restoreFromSourceProviderCache(const SourceProviderCacheItem* info)
 703     {
 704         ASSERT(m_isFunction);
 705         m_usesEval = info-&gt;usesEval;
 706         m_strictMode = info-&gt;strictMode;
 707         m_innerArrowFunctionFeatures = info-&gt;innerArrowFunctionFeatures;
 708         m_needsFullActivation = info-&gt;needsFullActivation;
 709         m_needsSuperBinding = info-&gt;needsSuperBinding;
 710         UniquedStringImplPtrSet&amp; destSet = m_usedVariables.last();
 711         for (unsigned i = 0; i &lt; info-&gt;usedVariablesCount; ++i)
 712             destSet.add(info-&gt;usedVariables()[i]);
 713     }
 714 
 715     class MaybeParseAsGeneratorForScope;
 716 
 717 private:
 718     void setIsFunction()
 719     {
 720         m_isFunction = true;
 721         m_isFunctionBoundary = true;
 722         m_hasArguments = true;
 723         setIsLexicalScope();
 724         m_isGenerator = false;
 725         m_isGeneratorBoundary = false;
 726         m_isArrowFunctionBoundary = false;
 727         m_isArrowFunction = false;
 728         m_isAsyncFunction = false;
 729         m_isAsyncFunctionBoundary = false;
 730     }
 731 
 732     void setIsGeneratorFunction()
 733     {
 734         setIsFunction();
 735         m_isGenerator = true;
 736     }
 737 
 738     void setIsGenerator()
 739     {
 740         setIsFunction();
 741         m_isGenerator = true;
 742         m_isGeneratorBoundary = true;
 743         m_hasArguments = false;
 744     }
 745 
 746     void setIsArrowFunction()
 747     {
 748         setIsFunction();
 749         m_isArrowFunctionBoundary = true;
 750         m_isArrowFunction = true;
 751     }
 752 
 753     void setIsAsyncArrowFunction()
 754     {
 755         setIsArrowFunction();
 756         m_isAsyncFunction = true;
 757     }
 758 
 759     void setIsAsyncFunction()
 760     {
 761         setIsFunction();
 762         m_isAsyncFunction = true;
 763     }
 764 
 765     void setIsAsyncGeneratorFunction()
 766     {
 767         setIsFunction();
 768         m_isAsyncFunction = true;
 769         m_isGenerator = true;
 770     }
 771 
 772     void setIsAsyncGeneratorFunctionBody()
 773     {
 774         setIsFunction();
 775         m_hasArguments = false;
 776         m_isGenerator = true;
 777         m_isGeneratorBoundary = true;
 778         m_isAsyncFunction = true;
 779         m_isAsyncFunctionBoundary = true;
 780     }
 781 
 782     void setIsAsyncFunctionBody()
 783     {
 784         setIsFunction();
 785         m_hasArguments = false;
 786         m_isAsyncFunction = true;
 787         m_isAsyncFunctionBoundary = true;
 788     }
 789 
 790     void setIsAsyncArrowFunctionBody()
 791     {
 792         setIsArrowFunction();
 793         m_hasArguments = false;
 794         m_isAsyncFunction = true;
 795         m_isAsyncFunctionBoundary = true;
 796     }
 797 
 798     const VM&amp; m_vm;
 799     bool m_shadowsArguments;
 800     bool m_usesEval;
 801     bool m_needsFullActivation;
 802     bool m_hasDirectSuper;
 803     bool m_needsSuperBinding;
 804     bool m_allowsVarDeclarations;
 805     bool m_allowsLexicalDeclarations;
 806     bool m_strictMode;
 807     bool m_isFunction;
 808     bool m_isGenerator;
 809     bool m_isGeneratorBoundary;
 810     bool m_isArrowFunction;
 811     bool m_isArrowFunctionBoundary;
 812     bool m_isAsyncFunction;
 813     bool m_isAsyncFunctionBoundary;
 814     bool m_isLexicalScope;
 815     bool m_isGlobalCodeScope;
 816     bool m_isSimpleCatchParameterScope;
 817     bool m_isFunctionBoundary;
 818     bool m_isValidStrictMode;
 819     bool m_hasArguments;
 820     bool m_isEvalContext;
 821     bool m_hasNonSimpleParameterList;
 822     EvalContextType m_evalContextType;
 823     unsigned m_constructorKind;
 824     unsigned m_expectedSuperBinding;
 825     int m_loopDepth;
 826     int m_switchDepth;
 827     InnerArrowFunctionCodeFeatures m_innerArrowFunctionFeatures;
 828 
 829     typedef Vector&lt;ScopeLabelInfo, 2&gt; LabelStack;
 830     std::unique_ptr&lt;LabelStack&gt; m_labels;
 831     UniquedStringImplPtrSet m_declaredParameters;
 832     VariableEnvironment m_declaredVariables;
 833     VariableEnvironment m_lexicalVariables;
 834     Vector&lt;UniquedStringImplPtrSet, 6&gt; m_usedVariables;
 835     UniquedStringImplPtrSet m_variablesBeingHoisted;
 836     UniquedStringImplPtrSet m_sloppyModeHoistableFunctionCandidates;
 837     HashSet&lt;UniquedStringImpl*&gt; m_closedVariableCandidates;
 838     DeclarationStacks::FunctionStack m_functionDeclarations;
 839 };
 840 
 841 typedef Vector&lt;Scope, 10&gt; ScopeStack;
 842 
 843 struct ScopeRef {
 844     ScopeRef(ScopeStack* scopeStack, unsigned index)
 845         : m_scopeStack(scopeStack)
 846         , m_index(index)
 847     {
 848     }
 849     Scope* operator-&gt;() { return &amp;m_scopeStack-&gt;at(m_index); }
 850     unsigned index() const { return m_index; }
 851 
 852     bool hasContainingScope()
 853     {
 854         return m_index &amp;&amp; !m_scopeStack-&gt;at(m_index).isFunctionBoundary();
 855     }
 856 
 857     ScopeRef containingScope()
 858     {
 859         ASSERT(hasContainingScope());
 860         return ScopeRef(m_scopeStack, m_index - 1);
 861     }
 862 
 863     bool operator==(const ScopeRef&amp; other)
 864     {
 865         ASSERT(other.m_scopeStack == m_scopeStack);
 866         return m_index == other.m_index;
 867     }
 868 
 869     bool operator!=(const ScopeRef&amp; other)
 870     {
 871         return !(*this == other);
 872     }
 873 
 874 private:
 875     ScopeStack* m_scopeStack;
 876     unsigned m_index;
 877 };
 878 
 879 enum class ArgumentType { Normal, Spread };
 880 enum class ParsingContext { Program, FunctionConstructor, Eval };
 881 
 882 template &lt;typename LexerType&gt;
 883 class Parser {
 884     WTF_MAKE_NONCOPYABLE(Parser);
 885     WTF_MAKE_FAST_ALLOCATED;
 886 
 887 public:
 888     Parser(VM&amp;, const SourceCode&amp;, JSParserBuiltinMode, JSParserStrictMode, JSParserScriptMode, SourceParseMode, SuperBinding, ConstructorKind defaultConstructorKind = ConstructorKind::None, DerivedContextType = DerivedContextType::None, bool isEvalContext = false, EvalContextType = EvalContextType::None, DebuggerParseData* = nullptr);
 889     ~Parser();
 890 
 891     template &lt;class ParsedNode&gt;
 892     std::unique_ptr&lt;ParsedNode&gt; parse(ParserError&amp;, const Identifier&amp;, SourceParseMode, ParsingContext, Optional&lt;int&gt; functionConstructorParametersEndPosition = WTF::nullopt);
 893 
 894     JSTextPosition positionBeforeLastNewline() const { return m_lexer-&gt;positionBeforeLastNewline(); }
 895     JSTokenLocation locationBeforeLastToken() const { return m_lexer-&gt;lastTokenLocation(); }
 896 
 897     struct CallOrApplyDepthScope {
 898         CallOrApplyDepthScope(Parser* parser)
 899             : m_parser(parser)
 900             , m_parent(parser-&gt;m_callOrApplyDepthScope)
 901             , m_depth(m_parent ? m_parent-&gt;m_depth + 1 : 0)
 902             , m_depthOfInnermostChild(m_depth)
 903         {
 904             parser-&gt;m_callOrApplyDepthScope = this;
 905         }
 906 
 907         size_t distanceToInnermostChild() const
 908         {
 909             ASSERT(m_depthOfInnermostChild &gt;= m_depth);
 910             return m_depthOfInnermostChild - m_depth;
 911         }
 912 
 913         ~CallOrApplyDepthScope()
 914         {
 915             if (m_parent)
 916                 m_parent-&gt;m_depthOfInnermostChild = std::max(m_depthOfInnermostChild, m_parent-&gt;m_depthOfInnermostChild);
 917             m_parser-&gt;m_callOrApplyDepthScope = m_parent;
 918         }
 919 
 920     private:
 921 
 922         Parser* m_parser;
 923         CallOrApplyDepthScope* m_parent;
 924         size_t m_depth;
 925         size_t m_depthOfInnermostChild;
 926     };
 927 
 928 private:
 929     struct AllowInOverride {
 930         AllowInOverride(Parser* parser)
 931             : m_parser(parser)
 932             , m_oldAllowsIn(parser-&gt;m_allowsIn)
 933         {
 934             parser-&gt;m_allowsIn = true;
 935         }
 936         ~AllowInOverride()
 937         {
 938             m_parser-&gt;m_allowsIn = m_oldAllowsIn;
 939         }
 940         Parser* m_parser;
 941         bool m_oldAllowsIn;
 942     };
 943 
 944     struct AutoPopScopeRef : public ScopeRef {
 945         AutoPopScopeRef(Parser* parser, ScopeRef scope)
 946         : ScopeRef(scope)
 947         , m_parser(parser)
 948         {
 949         }
 950 
 951         ~AutoPopScopeRef()
 952         {
 953             if (m_parser)
 954                 m_parser-&gt;popScope(*this, false);
 955         }
 956 
 957         void setPopped()
 958         {
 959             m_parser = 0;
 960         }
 961 
 962     private:
 963         Parser* m_parser;
 964     };
 965 
 966     struct AutoCleanupLexicalScope {
 967         // We can allocate this object on the stack without actually knowing beforehand if we&#39;re
 968         // going to create a new lexical scope. If we decide to create a new lexical scope, we
 969         // can pass the scope into this obejct and it will take care of the cleanup for us if the parse fails.
 970         // This is helpful if we may fail from syntax errors after creating a lexical scope conditionally.
 971         AutoCleanupLexicalScope()
 972             : m_scope(nullptr, UINT_MAX)
 973             , m_parser(nullptr)
 974         {
 975         }
 976 
 977         ~AutoCleanupLexicalScope()
 978         {
 979             // This should only ever be called if we fail from a syntax error. Otherwise
 980             // it&#39;s the intention that a user of this class pops this scope manually on a
 981             // successful parse.
 982             if (isValid())
 983                 m_parser-&gt;popScope(*this, false);
 984         }
 985 
 986         void setIsValid(ScopeRef&amp; scope, Parser* parser)
 987         {
 988             RELEASE_ASSERT(scope-&gt;isLexicalScope());
 989             m_scope = scope;
 990             m_parser = parser;
 991         }
 992 
 993         bool isValid() const { return !!m_parser; }
 994 
 995         void setPopped()
 996         {
 997             m_parser = nullptr;
 998         }
 999 
1000         ScopeRef&amp; scope() { return m_scope; }
1001 
1002     private:
1003         ScopeRef m_scope;
1004         Parser* m_parser;
1005     };
1006 
1007     enum ExpressionErrorClass {
1008         ErrorIndicatesNothing = 0,
1009         ErrorIndicatesPattern,
1010         ErrorIndicatesAsyncArrowFunction
1011     };
1012 
1013     struct ExpressionErrorClassifier {
1014         ExpressionErrorClassifier(Parser* parser)
1015             : m_class(ErrorIndicatesNothing)
1016             , m_previous(parser-&gt;m_expressionErrorClassifier)
1017             , m_parser(parser)
1018         {
1019             m_parser-&gt;m_expressionErrorClassifier = this;
1020         }
1021 
1022         ~ExpressionErrorClassifier()
1023         {
1024             m_parser-&gt;m_expressionErrorClassifier = m_previous;
1025         }
1026 
1027         void classifyExpressionError(ExpressionErrorClass classification)
1028         {
1029             if (m_class != ErrorIndicatesNothing)
1030                 return;
1031             m_class = classification;
1032         }
1033 
1034         void forceClassifyExpressionError(ExpressionErrorClass classification)
1035         {
1036             m_class = classification;
1037         }
1038 
1039         void reclassifyExpressionError(ExpressionErrorClass oldClassification, ExpressionErrorClass classification)
1040         {
1041             if (m_class != oldClassification)
1042                 return;
1043             m_class = classification;
1044         }
1045 
1046         void propagateExpressionErrorClass()
1047         {
1048             if (m_previous)
1049                 m_previous-&gt;m_class = m_class;
1050         }
1051 
1052         bool indicatesPossiblePattern() const { return m_class == ErrorIndicatesPattern; }
1053         bool indicatesPossibleAsyncArrowFunction() const { return m_class == ErrorIndicatesAsyncArrowFunction; }
1054 
1055     private:
1056         ExpressionErrorClass m_class;
1057         ExpressionErrorClassifier* m_previous;
1058         Parser* m_parser;
1059     };
1060 
1061     ALWAYS_INLINE void classifyExpressionError(ExpressionErrorClass classification)
1062     {
1063         if (m_expressionErrorClassifier)
1064             m_expressionErrorClassifier-&gt;classifyExpressionError(classification);
1065     }
1066 
1067     ALWAYS_INLINE void forceClassifyExpressionError(ExpressionErrorClass classification)
1068     {
1069         if (m_expressionErrorClassifier)
1070             m_expressionErrorClassifier-&gt;forceClassifyExpressionError(classification);
1071     }
1072 
1073     ALWAYS_INLINE void reclassifyExpressionError(ExpressionErrorClass oldClassification, ExpressionErrorClass classification)
1074     {
1075         if (m_expressionErrorClassifier)
1076             m_expressionErrorClassifier-&gt;reclassifyExpressionError(oldClassification, classification);
1077     }
1078 
1079     ALWAYS_INLINE DestructuringKind destructuringKindFromDeclarationType(DeclarationType type)
1080     {
1081         switch (type) {
1082         case DeclarationType::VarDeclaration:
1083             return DestructuringKind::DestructureToVariables;
1084         case DeclarationType::LetDeclaration:
1085             return DestructuringKind::DestructureToLet;
1086         case DeclarationType::ConstDeclaration:
1087             return DestructuringKind::DestructureToConst;
1088         }
1089 
1090         RELEASE_ASSERT_NOT_REACHED();
1091         return DestructuringKind::DestructureToVariables;
1092     }
1093 
1094     ALWAYS_INLINE const char* declarationTypeToVariableKind(DeclarationType type)
1095     {
1096         switch (type) {
1097         case DeclarationType::VarDeclaration:
1098             return &quot;variable name&quot;;
1099         case DeclarationType::LetDeclaration:
1100         case DeclarationType::ConstDeclaration:
1101             return &quot;lexical variable name&quot;;
1102         }
1103         RELEASE_ASSERT_NOT_REACHED();
1104         return &quot;invalid&quot;;
1105     }
1106 
1107     ALWAYS_INLINE AssignmentContext assignmentContextFromDeclarationType(DeclarationType type)
1108     {
1109         switch (type) {
1110         case DeclarationType::ConstDeclaration:
1111             return AssignmentContext::ConstDeclarationStatement;
1112         default:
1113             return AssignmentContext::DeclarationStatement;
1114         }
1115     }
1116 
1117     ALWAYS_INLINE bool isEvalOrArguments(const Identifier* ident) { return isEvalOrArgumentsIdentifier(m_vm, ident); }
1118 
1119     ScopeRef upperScope(int n)
1120     {
1121         ASSERT(m_scopeStack.size() &gt;= size_t(1 + n));
1122         return ScopeRef(&amp;m_scopeStack, m_scopeStack.size() - 1 - n);
1123     }
1124 
1125     ScopeRef currentScope()
1126     {
1127         return ScopeRef(&amp;m_scopeStack, m_scopeStack.size() - 1);
1128     }
1129 
1130     ScopeRef currentVariableScope()
1131     {
1132         unsigned i = m_scopeStack.size() - 1;
1133         ASSERT(i &lt; m_scopeStack.size());
1134         while (!m_scopeStack[i].allowsVarDeclarations()) {
1135             i--;
1136             ASSERT(i &lt; m_scopeStack.size());
1137         }
1138         return ScopeRef(&amp;m_scopeStack, i);
1139     }
1140 
1141     ScopeRef currentLexicalDeclarationScope()
1142     {
1143         unsigned i = m_scopeStack.size() - 1;
1144         ASSERT(i &lt; m_scopeStack.size());
1145         while (!m_scopeStack[i].allowsLexicalDeclarations()) {
1146             i--;
1147             ASSERT(i &lt; m_scopeStack.size());
1148         }
1149 
1150         return ScopeRef(&amp;m_scopeStack, i);
1151     }
1152 
1153     ScopeRef currentFunctionScope()
1154     {
1155         unsigned i = m_scopeStack.size() - 1;
1156         ASSERT(i &lt; m_scopeStack.size());
1157         while (i &amp;&amp; !m_scopeStack[i].isFunctionBoundary()) {
1158             i--;
1159             ASSERT(i &lt; m_scopeStack.size());
1160         }
1161         // When reaching the top level scope (it can be non function scope), we return it.
1162         return ScopeRef(&amp;m_scopeStack, i);
1163     }
1164 
1165     ScopeRef closestParentOrdinaryFunctionNonLexicalScope()
1166     {
1167         unsigned i = m_scopeStack.size() - 1;
1168         ASSERT(i &lt; m_scopeStack.size() &amp;&amp; m_scopeStack.size());
1169         while (i &amp;&amp; (!m_scopeStack[i].isFunctionBoundary() || m_scopeStack[i].isGeneratorBoundary() || m_scopeStack[i].isAsyncFunctionBoundary() || m_scopeStack[i].isArrowFunctionBoundary()))
1170             i--;
1171         // When reaching the top level scope (it can be non ordinary function scope), we return it.
1172         return ScopeRef(&amp;m_scopeStack, i);
1173     }
1174 
1175     ScopeRef pushScope()
1176     {
1177         bool isFunction = false;
1178         bool isStrict = false;
1179         bool isGenerator = false;
1180         bool isArrowFunction = false;
1181         bool isAsyncFunction = false;
1182         if (!m_scopeStack.isEmpty()) {
1183             isStrict = m_scopeStack.last().strictMode();
1184             isFunction = m_scopeStack.last().isFunction();
1185             isGenerator = m_scopeStack.last().isGenerator();
1186             isArrowFunction = m_scopeStack.last().isArrowFunction();
1187             isAsyncFunction = m_scopeStack.last().isAsyncFunction();
1188         }
1189         m_scopeStack.constructAndAppend(m_vm, isFunction, isGenerator, isStrict, isArrowFunction, isAsyncFunction);
1190         return currentScope();
1191     }
1192 
1193     void popScopeInternal(ScopeRef&amp; scope, bool shouldTrackClosedVariables)
1194     {
1195         EXCEPTION_ASSERT_UNUSED(scope, scope.index() == m_scopeStack.size() - 1);
1196         ASSERT(m_scopeStack.size() &gt; 1);
1197         m_scopeStack[m_scopeStack.size() - 2].collectFreeVariables(&amp;m_scopeStack.last(), shouldTrackClosedVariables);
1198 
1199         if (m_scopeStack.last().isArrowFunction())
1200             m_scopeStack.last().setInnerArrowFunctionUsesEvalAndUseArgumentsIfNeeded();
1201 
1202         if (!(m_scopeStack.last().isFunctionBoundary() &amp;&amp; !m_scopeStack.last().isArrowFunctionBoundary()))
1203             m_scopeStack[m_scopeStack.size() - 2].mergeInnerArrowFunctionFeatures(m_scopeStack.last().innerArrowFunctionFeatures());
1204 
1205         if (!m_scopeStack.last().isFunctionBoundary() &amp;&amp; m_scopeStack.last().needsFullActivation())
1206             m_scopeStack[m_scopeStack.size() - 2].setNeedsFullActivation();
1207         m_scopeStack.removeLast();
1208     }
1209 
1210     ALWAYS_INLINE void popScope(ScopeRef&amp; scope, bool shouldTrackClosedVariables)
1211     {
1212         popScopeInternal(scope, shouldTrackClosedVariables);
1213     }
1214 
1215     ALWAYS_INLINE void popScope(AutoPopScopeRef&amp; scope, bool shouldTrackClosedVariables)
1216     {
1217         scope.setPopped();
1218         popScopeInternal(scope, shouldTrackClosedVariables);
1219     }
1220 
1221     ALWAYS_INLINE void popScope(AutoCleanupLexicalScope&amp; cleanupScope, bool shouldTrackClosedVariables)
1222     {
1223         RELEASE_ASSERT(cleanupScope.isValid());
1224         ScopeRef&amp; scope = cleanupScope.scope();
1225         cleanupScope.setPopped();
1226         popScopeInternal(scope, shouldTrackClosedVariables);
1227     }
1228 
1229     NEVER_INLINE DeclarationResultMask declareHoistedVariable(const Identifier* ident)
1230     {
1231         unsigned i = m_scopeStack.size() - 1;
1232         ASSERT(i &lt; m_scopeStack.size());
1233         while (true) {
1234             // Annex B.3.5 exempts `try {} catch (e) { var e; }` from being a syntax error.
1235             if (m_scopeStack[i].hasLexicallyDeclaredVariable(*ident) &amp;&amp; !m_scopeStack[i].isSimpleCatchParameterScope())
1236                 return DeclarationResult::InvalidDuplicateDeclaration;
1237 
1238             if (m_scopeStack[i].allowsVarDeclarations())
1239                 return m_scopeStack[i].declareVariable(ident);
1240 
1241             m_scopeStack[i].addVariableBeingHoisted(ident);
1242 
1243             i--;
1244             ASSERT(i &lt; m_scopeStack.size());
1245         }
1246     }
1247 
1248     DeclarationResultMask declareVariable(const Identifier* ident, DeclarationType type = DeclarationType::VarDeclaration, DeclarationImportType importType = DeclarationImportType::NotImported)
1249     {
1250         if (type == DeclarationType::VarDeclaration)
1251             return declareHoistedVariable(ident);
1252 
1253         ASSERT(type == DeclarationType::LetDeclaration || type == DeclarationType::ConstDeclaration);
1254         // Lexical variables declared at a top level scope that shadow arguments or vars are not allowed.
1255         if (!m_lexer-&gt;isReparsingFunction() &amp;&amp; m_statementDepth == 1 &amp;&amp; (hasDeclaredParameter(*ident) || hasDeclaredVariable(*ident)))
1256             return DeclarationResult::InvalidDuplicateDeclaration;
1257 
1258         return currentLexicalDeclarationScope()-&gt;declareLexicalVariable(ident, type == DeclarationType::ConstDeclaration, importType);
1259     }
1260 
1261     std::pair&lt;DeclarationResultMask, ScopeRef&gt; declareFunction(const Identifier* ident)
1262     {
1263         if ((m_statementDepth == 1) || (!strictMode() &amp;&amp; !currentScope()-&gt;isFunction() &amp;&amp; !closestParentOrdinaryFunctionNonLexicalScope()-&gt;isEvalContext())) {
1264             // Functions declared at the top-most scope (both in sloppy and strict mode) are declared as vars
1265             // for backwards compatibility. This allows us to declare functions with the same name more than once.
1266             // In sloppy mode, we always declare functions as vars.
1267             bool declareAsVar = true;
1268             bool isSloppyModeHoistingCandidate = false;
1269             ScopeRef variableScope = currentVariableScope();
1270             return std::make_pair(variableScope-&gt;declareFunction(ident, declareAsVar, isSloppyModeHoistingCandidate), variableScope);
1271         }
1272 
1273         if (!strictMode()) {
1274             ASSERT(currentScope()-&gt;isFunction() || closestParentOrdinaryFunctionNonLexicalScope()-&gt;isEvalContext());
1275 
1276             // Functions declared inside a function inside a nested block scope in sloppy mode are subject to this
1277             // crazy rule defined inside Annex B.3.3 in the ES6 spec. It basically states that we will create
1278             // the function as a local block scoped variable, but when we evaluate the block that the function is
1279             // contained in, we will assign the function to a &quot;var&quot; variable only if declaring such a &quot;var&quot; wouldn&#39;t
1280             // be a syntax error and if there isn&#39;t a parameter with the same name. (It would only be a syntax error if
1281             // there are is a let/class/const with the same name). Note that this mean we only do the &quot;var&quot; hoisting
1282             // binding if the block evaluates. For example, this means we wont won&#39;t perform the binding if it&#39;s inside
1283             // the untaken branch of an if statement.
1284             bool declareAsVar = false;
1285             bool isSloppyModeHoistingCandidate = true;
1286             ScopeRef lexicalVariableScope = currentLexicalDeclarationScope();
1287             ScopeRef varScope = currentVariableScope();
1288             varScope-&gt;addSloppyModeHoistableFunctionCandidate(ident);
1289             ASSERT(varScope != lexicalVariableScope);
1290             return std::make_pair(lexicalVariableScope-&gt;declareFunction(ident, declareAsVar, isSloppyModeHoistingCandidate), lexicalVariableScope);
1291         }
1292 
1293         bool declareAsVar = false;
1294         bool isSloppyModeHoistingCandidate = false;
1295         ScopeRef lexicalVariableScope = currentLexicalDeclarationScope();
1296         return std::make_pair(lexicalVariableScope-&gt;declareFunction(ident, declareAsVar, isSloppyModeHoistingCandidate), lexicalVariableScope);
1297     }
1298 
1299     NEVER_INLINE bool hasDeclaredVariable(const Identifier&amp; ident)
1300     {
1301         unsigned i = m_scopeStack.size() - 1;
1302         ASSERT(i &lt; m_scopeStack.size());
1303         while (!m_scopeStack[i].allowsVarDeclarations()) {
1304             i--;
1305             ASSERT(i &lt; m_scopeStack.size());
1306         }
1307         return m_scopeStack[i].hasDeclaredVariable(ident);
1308     }
1309 
1310     NEVER_INLINE bool hasDeclaredParameter(const Identifier&amp; ident)
1311     {
1312         // FIXME: hasDeclaredParameter() is not valid during reparsing of generator or async function bodies, because their formal
1313         // parameters are declared in a scope unavailable during reparsing. Note that it is redundant to call this function during
1314         // reparsing anyways, as the function is already guaranteed to be valid by the original parsing.
1315         // https://bugs.webkit.org/show_bug.cgi?id=164087
1316         ASSERT(!m_lexer-&gt;isReparsingFunction());
1317 
1318         unsigned i = m_scopeStack.size() - 1;
1319         ASSERT(i &lt; m_scopeStack.size());
1320         while (!m_scopeStack[i].allowsVarDeclarations()) {
1321             i--;
1322             ASSERT(i &lt; m_scopeStack.size());
1323         }
1324 
1325         if (m_scopeStack[i].isGeneratorBoundary() || m_scopeStack[i].isAsyncFunctionBoundary()) {
1326             // The formal parameters which need to be verified for Generators and Async Function bodies occur
1327             // in the outer wrapper function, so pick the outer scope here.
1328             i--;
1329             ASSERT(i &lt; m_scopeStack.size());
1330         }
1331         return m_scopeStack[i].hasDeclaredParameter(ident);
1332     }
1333 
1334     bool exportName(const Identifier&amp; ident)
1335     {
1336         ASSERT(currentScope().index() == 0);
1337         ASSERT(m_moduleScopeData);
1338         return m_moduleScopeData-&gt;exportName(ident);
1339     }
1340 
1341     ScopeStack m_scopeStack;
1342 
1343     const SourceProviderCacheItem* findCachedFunctionInfo(int openBracePos)
1344     {
1345         return m_functionCache ? m_functionCache-&gt;get(openBracePos) : 0;
1346     }
1347 
1348     Parser();
1349 
1350     String parseInner(const Identifier&amp;, SourceParseMode, ParsingContext, Optional&lt;int&gt; functionConstructorParametersEndPosition = WTF::nullopt);
1351 
1352     void didFinishParsing(SourceElements*, DeclarationStacks::FunctionStack&amp;&amp;, VariableEnvironment&amp;, UniquedStringImplPtrSet&amp;&amp;, CodeFeatures, int);
1353 
1354     // Used to determine type of error to report.
1355     bool isFunctionMetadataNode(ScopeNode*) { return false; }
1356     bool isFunctionMetadataNode(FunctionMetadataNode*) { return true; }
1357 
1358     ALWAYS_INLINE void next(unsigned lexerFlags = 0)
1359     {
1360         int lastLine = m_token.m_location.line;
1361         int lastTokenEnd = m_token.m_location.endOffset;
1362         int lastTokenLineStart = m_token.m_location.lineStartOffset;
1363         m_lastTokenEndPosition = JSTextPosition(lastLine, lastTokenEnd, lastTokenLineStart);
1364         m_lexer-&gt;setLastLineNumber(lastLine);
1365         m_token.m_type = m_lexer-&gt;lex(&amp;m_token, lexerFlags, strictMode());
1366     }
1367 
1368     ALWAYS_INLINE void nextWithoutClearingLineTerminator(unsigned lexerFlags = 0)
1369     {
1370         int lastLine = m_token.m_location.line;
1371         int lastTokenEnd = m_token.m_location.endOffset;
1372         int lastTokenLineStart = m_token.m_location.lineStartOffset;
1373         m_lastTokenEndPosition = JSTextPosition(lastLine, lastTokenEnd, lastTokenLineStart);
1374         m_lexer-&gt;setLastLineNumber(lastLine);
1375         m_token.m_type = m_lexer-&gt;lexWithoutClearingLineTerminator(&amp;m_token, lexerFlags, strictMode());
1376     }
1377 
1378     ALWAYS_INLINE void nextExpectIdentifier(unsigned lexerFlags = 0)
1379     {
1380         int lastLine = m_token.m_location.line;
1381         int lastTokenEnd = m_token.m_location.endOffset;
1382         int lastTokenLineStart = m_token.m_location.lineStartOffset;
1383         m_lastTokenEndPosition = JSTextPosition(lastLine, lastTokenEnd, lastTokenLineStart);
1384         m_lexer-&gt;setLastLineNumber(lastLine);
1385         m_token.m_type = m_lexer-&gt;lexExpectIdentifier(&amp;m_token, lexerFlags, strictMode());
1386     }
1387 
1388     ALWAYS_INLINE void lexCurrentTokenAgainUnderCurrentContext()
1389     {
1390         auto savePoint = createSavePoint();
1391         restoreSavePoint(savePoint);
1392     }
1393 
1394     ALWAYS_INLINE bool nextTokenIsColon()
1395     {
1396         return m_lexer-&gt;nextTokenIsColon();
1397     }
1398 
1399     ALWAYS_INLINE bool consume(JSTokenType expected, unsigned flags = 0)
1400     {
1401         bool result = m_token.m_type == expected;
1402         if (result)
1403             next(flags);
1404         return result;
1405     }
1406 
1407     void printUnexpectedTokenText(WTF::PrintStream&amp;);
1408     ALWAYS_INLINE StringView getToken()
1409     {
1410         return m_lexer-&gt;getToken(m_token);
1411     }
1412 
1413     ALWAYS_INLINE StringView getToken(const JSToken&amp; token)
1414     {
1415         return m_lexer-&gt;getToken(token);
1416     }
1417 
1418     ALWAYS_INLINE bool match(JSTokenType expected)
1419     {
1420         return m_token.m_type == expected;
1421     }
1422 
1423     ALWAYS_INLINE bool matchContextualKeyword(const Identifier&amp; identifier)
1424     {
1425         return m_token.m_type == IDENT &amp;&amp; *m_token.m_data.ident == identifier &amp;&amp; !m_token.m_data.escaped;
1426     }
1427 
1428     ALWAYS_INLINE bool matchIdentifierOrKeyword()
1429     {
1430         return isIdentifierOrKeyword(m_token);
1431     }
1432 
1433     ALWAYS_INLINE unsigned tokenStart()
1434     {
1435         return m_token.m_location.startOffset;
1436     }
1437 
1438     ALWAYS_INLINE const JSTextPosition&amp; tokenStartPosition()
1439     {
1440         return m_token.m_startPosition;
1441     }
1442 
1443     ALWAYS_INLINE int tokenLine()
1444     {
1445         return m_token.m_location.line;
1446     }
1447 
1448     ALWAYS_INLINE int tokenColumn()
1449     {
1450         return tokenStart() - tokenLineStart();
1451     }
1452 
1453     ALWAYS_INLINE const JSTextPosition&amp; tokenEndPosition()
1454     {
1455         return m_token.m_endPosition;
1456     }
1457 
1458     ALWAYS_INLINE unsigned tokenLineStart()
1459     {
1460         return m_token.m_location.lineStartOffset;
1461     }
1462 
1463     ALWAYS_INLINE const JSTokenLocation&amp; tokenLocation()
1464     {
1465         return m_token.m_location;
1466     }
1467 
1468     void setErrorMessage(const String&amp; message)
1469     {
1470         ASSERT_WITH_MESSAGE(!message.isEmpty(), &quot;Attempted to set the empty string as an error message. Likely caused by invalid UTF8 used when creating the message.&quot;);
1471         m_errorMessage = message;
1472         if (m_errorMessage.isEmpty())
1473             m_errorMessage = &quot;Unparseable script&quot;_s;
1474     }
1475 
1476     NEVER_INLINE void logError(bool);
1477     template &lt;typename... Args&gt;
1478     NEVER_INLINE void logError(bool, Args&amp;&amp;...);
1479 
1480     NEVER_INLINE void updateErrorWithNameAndMessage(const char* beforeMessage, const String&amp; name, const char* afterMessage)
1481     {
1482         m_errorMessage = makeString(beforeMessage, &quot; &#39;&quot;, name, &quot;&#39; &quot;, afterMessage);
1483     }
1484 
1485     NEVER_INLINE void updateErrorMessage(const char* msg)
1486     {
1487         ASSERT(msg);
1488         m_errorMessage = String(msg);
1489         ASSERT(!m_errorMessage.isNull());
1490     }
1491 
1492     ALWAYS_INLINE void recordPauseLocation(const JSTextPosition&amp;);
1493     ALWAYS_INLINE void recordFunctionEntryLocation(const JSTextPosition&amp;);
1494     ALWAYS_INLINE void recordFunctionLeaveLocation(const JSTextPosition&amp;);
1495 
1496     void startLoop() { currentScope()-&gt;startLoop(); }
1497     void endLoop() { currentScope()-&gt;endLoop(); }
1498     void startSwitch() { currentScope()-&gt;startSwitch(); }
1499     void endSwitch() { currentScope()-&gt;endSwitch(); }
1500     void setStrictMode() { currentScope()-&gt;setStrictMode(); }
1501     bool strictMode() { return currentScope()-&gt;strictMode(); }
1502     bool isValidStrictMode()
1503     {
1504         int i = m_scopeStack.size() - 1;
1505         if (!m_scopeStack[i].isValidStrictMode())
1506             return false;
1507 
1508         // In the case of Generator or Async function bodies, also check the wrapper function, whose name or
1509         // arguments may be invalid.
1510         if (UNLIKELY((m_scopeStack[i].isGeneratorBoundary() || m_scopeStack[i].isAsyncFunctionBoundary()) &amp;&amp; i))
1511             return m_scopeStack[i - 1].isValidStrictMode();
1512         return true;
1513     }
1514     DeclarationResultMask declareParameter(const Identifier* ident) { return currentScope()-&gt;declareParameter(ident); }
1515     bool declareRestOrNormalParameter(const Identifier&amp;, const Identifier**);
1516 
1517     bool breakIsValid()
1518     {
1519         ScopeRef current = currentScope();
1520         while (!current-&gt;breakIsValid()) {
1521             if (!current.hasContainingScope())
1522                 return false;
1523             current = current.containingScope();
1524         }
1525         return true;
1526     }
1527     bool continueIsValid()
1528     {
1529         ScopeRef current = currentScope();
1530         while (!current-&gt;continueIsValid()) {
1531             if (!current.hasContainingScope())
1532                 return false;
1533             current = current.containingScope();
1534         }
1535         return true;
1536     }
1537     void pushLabel(const Identifier* label, bool isLoop) { currentScope()-&gt;pushLabel(label, isLoop); }
1538     void popLabel(ScopeRef scope) { scope-&gt;popLabel(); }
1539     ScopeLabelInfo* getLabel(const Identifier* label)
1540     {
1541         ScopeRef current = currentScope();
1542         ScopeLabelInfo* result = 0;
1543         while (!(result = current-&gt;getLabel(label))) {
1544             if (!current.hasContainingScope())
1545                 return 0;
1546             current = current.containingScope();
1547         }
1548         return result;
1549     }
1550 
1551     // http://ecma-international.org/ecma-262/6.0/#sec-identifiers-static-semantics-early-errors
1552     ALWAYS_INLINE bool isLETMaskedAsIDENT()
1553     {
1554         return match(LET) &amp;&amp; !strictMode();
1555     }
1556 
1557     // http://ecma-international.org/ecma-262/6.0/#sec-identifiers-static-semantics-early-errors
1558     ALWAYS_INLINE bool isYIELDMaskedAsIDENT(bool inGenerator)
1559     {
1560         return match(YIELD) &amp;&amp; !strictMode() &amp;&amp; !inGenerator;
1561     }
1562 
1563     // http://ecma-international.org/ecma-262/6.0/#sec-generator-function-definitions-static-semantics-early-errors
1564     ALWAYS_INLINE bool matchSpecIdentifier(bool inGenerator)
1565     {
1566         return match(IDENT) || isLETMaskedAsIDENT() || isYIELDMaskedAsIDENT(inGenerator) || isSafeContextualKeyword(m_token);
1567     }
1568 
1569     ALWAYS_INLINE bool matchSpecIdentifier()
1570     {
1571         return match(IDENT) || isLETMaskedAsIDENT() || isYIELDMaskedAsIDENT(currentScope()-&gt;isGenerator()) || isSafeContextualKeyword(m_token);
1572     }
1573 
1574     template &lt;class TreeBuilder&gt; TreeSourceElements parseSourceElements(TreeBuilder&amp;, SourceElementsMode);
1575     template &lt;class TreeBuilder&gt; TreeSourceElements parseGeneratorFunctionSourceElements(TreeBuilder&amp;, const Identifier&amp; name, SourceElementsMode);
1576     template &lt;class TreeBuilder&gt; TreeSourceElements parseAsyncFunctionSourceElements(TreeBuilder&amp;, SourceParseMode, bool isArrowFunctionBodyExpression, SourceElementsMode);
1577     template &lt;class TreeBuilder&gt; TreeSourceElements parseAsyncGeneratorFunctionSourceElements(TreeBuilder&amp;, SourceParseMode, bool isArrowFunctionBodyExpression, SourceElementsMode);
1578     template &lt;class TreeBuilder&gt; TreeSourceElements parseSingleFunction(TreeBuilder&amp;, Optional&lt;int&gt; functionConstructorParametersEndPosition);
1579     template &lt;class TreeBuilder&gt; TreeStatement parseStatementListItem(TreeBuilder&amp;, const Identifier*&amp; directive, unsigned* directiveLiteralLength);
1580     template &lt;class TreeBuilder&gt; TreeStatement parseStatement(TreeBuilder&amp;, const Identifier*&amp; directive, unsigned* directiveLiteralLength = 0);
1581     enum class ExportType { Exported, NotExported };
1582     template &lt;class TreeBuilder&gt; TreeStatement parseClassDeclaration(TreeBuilder&amp;, ExportType = ExportType::NotExported, DeclarationDefaultContext = DeclarationDefaultContext::Standard);
1583     template &lt;class TreeBuilder&gt; TreeStatement parseFunctionDeclaration(TreeBuilder&amp;, ExportType = ExportType::NotExported, DeclarationDefaultContext = DeclarationDefaultContext::Standard, Optional&lt;int&gt; functionConstructorParametersEndPosition = WTF::nullopt);
1584     template &lt;class TreeBuilder&gt; TreeStatement parseFunctionDeclarationStatement(TreeBuilder&amp;, bool isAsync, bool parentAllowsFunctionDeclarationAsStatement);
1585     template &lt;class TreeBuilder&gt; TreeStatement parseAsyncFunctionDeclaration(TreeBuilder&amp;, ExportType = ExportType::NotExported, DeclarationDefaultContext = DeclarationDefaultContext::Standard, Optional&lt;int&gt; functionConstructorParametersEndPosition = WTF::nullopt);
1586     template &lt;class TreeBuilder&gt; NEVER_INLINE bool maybeParseAsyncFunctionDeclarationStatement(TreeBuilder&amp; context, TreeStatement&amp; result, bool parentAllowsFunctionDeclarationAsStatement);
1587     template &lt;class TreeBuilder&gt; TreeStatement parseVariableDeclaration(TreeBuilder&amp;, DeclarationType, ExportType = ExportType::NotExported);
1588     template &lt;class TreeBuilder&gt; TreeStatement parseDoWhileStatement(TreeBuilder&amp;);
1589     template &lt;class TreeBuilder&gt; TreeStatement parseWhileStatement(TreeBuilder&amp;);
1590     template &lt;class TreeBuilder&gt; TreeStatement parseForStatement(TreeBuilder&amp;);
1591     template &lt;class TreeBuilder&gt; TreeStatement parseBreakStatement(TreeBuilder&amp;);
1592     template &lt;class TreeBuilder&gt; TreeStatement parseContinueStatement(TreeBuilder&amp;);
1593     template &lt;class TreeBuilder&gt; TreeStatement parseReturnStatement(TreeBuilder&amp;);
1594     template &lt;class TreeBuilder&gt; TreeStatement parseThrowStatement(TreeBuilder&amp;);
1595     template &lt;class TreeBuilder&gt; TreeStatement parseWithStatement(TreeBuilder&amp;);
1596     template &lt;class TreeBuilder&gt; TreeStatement parseSwitchStatement(TreeBuilder&amp;);
1597     template &lt;class TreeBuilder&gt; TreeClauseList parseSwitchClauses(TreeBuilder&amp;);
1598     template &lt;class TreeBuilder&gt; TreeClause parseSwitchDefaultClause(TreeBuilder&amp;);
1599     template &lt;class TreeBuilder&gt; TreeStatement parseTryStatement(TreeBuilder&amp;);
1600     template &lt;class TreeBuilder&gt; TreeStatement parseDebuggerStatement(TreeBuilder&amp;);
1601     template &lt;class TreeBuilder&gt; TreeStatement parseExpressionStatement(TreeBuilder&amp;);
1602     template &lt;class TreeBuilder&gt; TreeStatement parseExpressionOrLabelStatement(TreeBuilder&amp;, bool allowFunctionDeclarationAsStatement);
1603     template &lt;class TreeBuilder&gt; TreeStatement parseIfStatement(TreeBuilder&amp;);
1604     template &lt;class TreeBuilder&gt; TreeStatement parseBlockStatement(TreeBuilder&amp;);
1605     template &lt;class TreeBuilder&gt; TreeExpression parseExpression(TreeBuilder&amp;);
1606     template &lt;class TreeBuilder&gt; TreeExpression parseAssignmentExpression(TreeBuilder&amp;, ExpressionErrorClassifier&amp;);
1607     template &lt;class TreeBuilder&gt; TreeExpression parseAssignmentExpression(TreeBuilder&amp;);
1608     template &lt;class TreeBuilder&gt; TreeExpression parseAssignmentExpressionOrPropagateErrorClass(TreeBuilder&amp;);
1609     template &lt;class TreeBuilder&gt; TreeExpression parseYieldExpression(TreeBuilder&amp;);
1610     template &lt;class TreeBuilder&gt; ALWAYS_INLINE TreeExpression parseConditionalExpression(TreeBuilder&amp;);
1611     template &lt;class TreeBuilder&gt; ALWAYS_INLINE TreeExpression parseBinaryExpression(TreeBuilder&amp;);
1612     template &lt;class TreeBuilder&gt; ALWAYS_INLINE TreeExpression parseUnaryExpression(TreeBuilder&amp;);
1613     template &lt;class TreeBuilder&gt; NEVER_INLINE TreeExpression parseAwaitExpression(TreeBuilder&amp;);
1614     template &lt;class TreeBuilder&gt; TreeExpression parseMemberExpression(TreeBuilder&amp;);
1615     template &lt;class TreeBuilder&gt; ALWAYS_INLINE TreeExpression parsePrimaryExpression(TreeBuilder&amp;);
1616     template &lt;class TreeBuilder&gt; ALWAYS_INLINE TreeExpression parseArrayLiteral(TreeBuilder&amp;);
1617     template &lt;class TreeBuilder&gt; ALWAYS_INLINE TreeExpression parseObjectLiteral(TreeBuilder&amp;);
1618     template &lt;class TreeBuilder&gt; NEVER_INLINE TreeExpression parseStrictObjectLiteral(TreeBuilder&amp;);
1619     template &lt;class TreeBuilder&gt; ALWAYS_INLINE TreeClassExpression parseClassExpression(TreeBuilder&amp;);
1620     template &lt;class TreeBuilder&gt; ALWAYS_INLINE TreeExpression parseFunctionExpression(TreeBuilder&amp;);
1621     template &lt;class TreeBuilder&gt; ALWAYS_INLINE TreeExpression parseAsyncFunctionExpression(TreeBuilder&amp;);
1622     template &lt;class TreeBuilder&gt; ALWAYS_INLINE TreeArguments parseArguments(TreeBuilder&amp;);
1623     template &lt;class TreeBuilder&gt; ALWAYS_INLINE TreeExpression parseArgument(TreeBuilder&amp;, ArgumentType&amp;);
1624     template &lt;class TreeBuilder&gt; TreeProperty parseProperty(TreeBuilder&amp;, bool strict);
1625     template &lt;class TreeBuilder&gt; TreeExpression parsePropertyMethod(TreeBuilder&amp; context, const Identifier* methodName, SourceParseMode);
1626     template &lt;class TreeBuilder&gt; TreeProperty parseGetterSetter(TreeBuilder&amp;, bool strict, PropertyNode::Type, unsigned getterOrSetterStartOffset, ConstructorKind, ClassElementTag);
1627     template &lt;class TreeBuilder&gt; ALWAYS_INLINE TreeFunctionBody parseFunctionBody(TreeBuilder&amp;, SyntaxChecker&amp;, const JSTokenLocation&amp;, int, int functionKeywordStart, int functionNameStart, int parametersStart, ConstructorKind, SuperBinding, FunctionBodyType, unsigned, SourceParseMode);
1628     template &lt;class TreeBuilder&gt; ALWAYS_INLINE bool parseFormalParameters(TreeBuilder&amp;, TreeFormalParameterList, bool isArrowFunction, bool isMethod, unsigned&amp;);
1629     enum VarDeclarationListContext { ForLoopContext, VarDeclarationContext };
1630     template &lt;class TreeBuilder&gt; TreeExpression parseVariableDeclarationList(TreeBuilder&amp;, int&amp; declarations, TreeDestructuringPattern&amp; lastPattern, TreeExpression&amp; lastInitializer, JSTextPosition&amp; identStart, JSTextPosition&amp; initStart, JSTextPosition&amp; initEnd, VarDeclarationListContext, DeclarationType, ExportType, bool&amp; forLoopConstDoesNotHaveInitializer);
1631     template &lt;class TreeBuilder&gt; TreeSourceElements parseArrowFunctionSingleExpressionBodySourceElements(TreeBuilder&amp;);
1632     template &lt;class TreeBuilder&gt; TreeExpression parseArrowFunctionExpression(TreeBuilder&amp;, bool isAsync);
1633     template &lt;class TreeBuilder&gt; NEVER_INLINE TreeDestructuringPattern createBindingPattern(TreeBuilder&amp;, DestructuringKind, ExportType, const Identifier&amp;, JSToken, AssignmentContext, const Identifier** duplicateIdentifier);
1634     template &lt;class TreeBuilder&gt; NEVER_INLINE TreeDestructuringPattern createAssignmentElement(TreeBuilder&amp;, TreeExpression&amp;, const JSTextPosition&amp;, const JSTextPosition&amp;);
1635     template &lt;class TreeBuilder&gt; NEVER_INLINE TreeDestructuringPattern parseObjectRestBindingOrAssignmentElement(TreeBuilder&amp; context, DestructuringKind, ExportType, const Identifier** duplicateIdentifier, AssignmentContext bindingContext);
1636     template &lt;class TreeBuilder&gt; NEVER_INLINE TreeDestructuringPattern parseBindingOrAssignmentElement(TreeBuilder&amp; context, DestructuringKind, ExportType, const Identifier** duplicateIdentifier, bool* hasDestructuringPattern, AssignmentContext bindingContext, int depth);
1637     template &lt;class TreeBuilder&gt; NEVER_INLINE TreeDestructuringPattern parseObjectRestAssignmentElement(TreeBuilder&amp; context);
1638     template &lt;class TreeBuilder&gt; NEVER_INLINE TreeDestructuringPattern parseAssignmentElement(TreeBuilder&amp; context, DestructuringKind, ExportType, const Identifier** duplicateIdentifier, bool* hasDestructuringPattern, AssignmentContext bindingContext, int depth);
1639     template &lt;class TreeBuilder&gt; NEVER_INLINE TreeDestructuringPattern parseObjectRestElement(TreeBuilder&amp;, DestructuringKind, ExportType, const Identifier** duplicateIdentifier = nullptr, AssignmentContext = AssignmentContext::DeclarationStatement);
1640     template &lt;class TreeBuilder&gt; NEVER_INLINE TreeDestructuringPattern parseDestructuringPattern(TreeBuilder&amp;, DestructuringKind, ExportType, const Identifier** duplicateIdentifier = nullptr, bool* hasDestructuringPattern = nullptr, AssignmentContext = AssignmentContext::DeclarationStatement, int depth = 0);
1641     template &lt;class TreeBuilder&gt; NEVER_INLINE TreeDestructuringPattern tryParseDestructuringPatternExpression(TreeBuilder&amp;, AssignmentContext);
1642     template &lt;class TreeBuilder&gt; NEVER_INLINE TreeExpression parseDefaultValueForDestructuringPattern(TreeBuilder&amp;);
1643     template &lt;class TreeBuilder&gt; TreeSourceElements parseModuleSourceElements(TreeBuilder&amp;, SourceParseMode);
1644     enum class ImportSpecifierType { NamespaceImport, NamedImport, DefaultImport };
1645     template &lt;class TreeBuilder&gt; typename TreeBuilder::ImportSpecifier parseImportClauseItem(TreeBuilder&amp;, ImportSpecifierType);
1646     template &lt;class TreeBuilder&gt; typename TreeBuilder::ModuleName parseModuleName(TreeBuilder&amp;);
1647     template &lt;class TreeBuilder&gt; TreeStatement parseImportDeclaration(TreeBuilder&amp;);
1648     template &lt;class TreeBuilder&gt; typename TreeBuilder::ExportSpecifier parseExportSpecifier(TreeBuilder&amp; context, Vector&lt;std::pair&lt;const Identifier*, const Identifier*&gt;&gt;&amp; maybeExportedLocalNames, bool&amp; hasKeywordForLocalBindings);
1649     template &lt;class TreeBuilder&gt; TreeStatement parseExportDeclaration(TreeBuilder&amp;);
1650 
1651     template &lt;class TreeBuilder&gt; ALWAYS_INLINE TreeExpression createResolveAndUseVariable(TreeBuilder&amp;, const Identifier*, bool isEval, const JSTextPosition&amp;, const JSTokenLocation&amp;);
1652 
1653     enum class FunctionDefinitionType { Expression, Declaration, Method };
1654     template &lt;class TreeBuilder&gt; NEVER_INLINE bool parseFunctionInfo(TreeBuilder&amp;, FunctionNameRequirements, SourceParseMode, bool nameIsInContainingScope, ConstructorKind, SuperBinding, int functionKeywordStart, ParserFunctionInfo&lt;TreeBuilder&gt;&amp;, FunctionDefinitionType, Optional&lt;int&gt; functionConstructorParametersEndPosition = WTF::nullopt);
1655 
1656     ALWAYS_INLINE bool isArrowFunctionParameters();
1657 
1658     template &lt;class TreeBuilder, class FunctionInfoType&gt; NEVER_INLINE typename TreeBuilder::FormalParameterList parseFunctionParameters(TreeBuilder&amp;, SourceParseMode, FunctionInfoType&amp;);
1659     template &lt;class TreeBuilder&gt; NEVER_INLINE typename TreeBuilder::FormalParameterList createGeneratorParameters(TreeBuilder&amp;, unsigned&amp; parameterCount);
1660 
1661     template &lt;class TreeBuilder&gt; NEVER_INLINE TreeClassExpression parseClass(TreeBuilder&amp;, FunctionNameRequirements, ParserClassInfo&lt;TreeBuilder&gt;&amp;);
1662 
1663     template &lt;class TreeBuilder&gt; NEVER_INLINE typename TreeBuilder::TemplateString parseTemplateString(TreeBuilder&amp; context, bool isTemplateHead, typename LexerType::RawStringsBuildMode, bool&amp; elementIsTail);
1664     template &lt;class TreeBuilder&gt; NEVER_INLINE typename TreeBuilder::TemplateLiteral parseTemplateLiteral(TreeBuilder&amp;, typename LexerType::RawStringsBuildMode);
1665 
1666     template &lt;class TreeBuilder&gt; ALWAYS_INLINE bool shouldCheckPropertyForUnderscoreProtoDuplicate(TreeBuilder&amp;, const TreeProperty&amp;);
1667 
1668     template &lt;class TreeBuilder&gt; NEVER_INLINE const char* metaPropertyName(TreeBuilder&amp;, TreeExpression);
1669 
1670     template &lt;class TreeBuilder&gt; ALWAYS_INLINE bool isSimpleAssignmentTarget(TreeBuilder&amp;, TreeExpression);
1671 
1672     ALWAYS_INLINE int isBinaryOperator(JSTokenType);
1673     bool allowAutomaticSemicolon();
1674 
1675     bool autoSemiColon()
1676     {
1677         if (m_token.m_type == SEMICOLON) {
1678             next();
1679             return true;
1680         }
1681         return allowAutomaticSemicolon();
1682     }
1683 
1684     bool canRecurse()
1685     {
1686         return m_vm.isSafeToRecurse();
1687     }
1688 
1689     const JSTextPosition&amp; lastTokenEndPosition() const
1690     {
1691         return m_lastTokenEndPosition;
1692     }
1693 
1694     bool hasError() const
1695     {
1696         return !m_errorMessage.isNull();
1697     }
1698 
1699     bool isDisallowedIdentifierLet(const JSToken&amp; token)
1700     {
1701         return token.m_type == LET &amp;&amp; strictMode();
1702     }
1703 
1704     bool isDisallowedIdentifierAwait(const JSToken&amp; token)
1705     {
1706         return token.m_type == AWAIT &amp;&amp; (!m_parserState.allowAwait || currentScope()-&gt;isAsyncFunctionBoundary() || m_scriptMode == JSParserScriptMode::Module);
1707     }
1708 
1709     bool isDisallowedIdentifierYield(const JSToken&amp; token)
1710     {
1711         return token.m_type == YIELD &amp;&amp; (strictMode() || currentScope()-&gt;isGenerator());
1712     }
1713 
1714     ALWAYS_INLINE SuperBinding adjustSuperBindingForBaseConstructor(ConstructorKind constructorKind, SuperBinding superBinding, ScopeRef functionScope)
1715     {
1716         return adjustSuperBindingForBaseConstructor(constructorKind, superBinding, functionScope-&gt;needsSuperBinding(), functionScope-&gt;usesEval(), functionScope-&gt;innerArrowFunctionFeatures());
1717     }
1718 
1719     ALWAYS_INLINE SuperBinding adjustSuperBindingForBaseConstructor(ConstructorKind constructorKind, SuperBinding superBinding, bool scopeNeedsSuperBinding, bool currentScopeUsesEval, InnerArrowFunctionCodeFeatures innerArrowFunctionFeatures)
1720     {
1721         SuperBinding methodSuperBinding = superBinding;
1722 
1723         if (constructorKind == ConstructorKind::Base) {
1724             bool isSuperUsedInInnerArrowFunction = innerArrowFunctionFeatures &amp; SuperPropertyInnerArrowFunctionFeature;
1725             methodSuperBinding = (scopeNeedsSuperBinding || isSuperUsedInInnerArrowFunction || currentScopeUsesEval) ? SuperBinding::Needed : SuperBinding::NotNeeded;
1726         }
1727 
1728         return methodSuperBinding;
1729     }
1730 
1731     const char* disallowedIdentifierLetReason()
1732     {
1733         ASSERT(strictMode());
1734         return &quot;in strict mode&quot;;
1735     }
1736 
1737     const char* disallowedIdentifierAwaitReason()
1738     {
1739         if (!m_parserState.allowAwait || currentScope()-&gt;isAsyncFunctionBoundary())
1740             return &quot;in an async function&quot;;
1741         if (m_scriptMode == JSParserScriptMode::Module)
1742             return &quot;in a module&quot;;
1743         RELEASE_ASSERT_NOT_REACHED();
1744         return nullptr;
1745     }
1746 
1747     const char* disallowedIdentifierYieldReason()
1748     {
1749         if (strictMode())
1750             return &quot;in strict mode&quot;;
1751         if (currentScope()-&gt;isGenerator())
1752             return &quot;in a generator function&quot;;
1753         RELEASE_ASSERT_NOT_REACHED();
1754         return nullptr;
1755     }
1756 
1757     enum class FunctionParsePhase { Parameters, Body };
1758     struct ParserState {
1759         int assignmentCount { 0 };
1760         int nonLHSCount { 0 };
1761         int nonTrivialExpressionCount { 0 };
1762         FunctionParsePhase functionParsePhase { FunctionParsePhase::Body };
1763         const Identifier* lastIdentifier { nullptr };
1764         const Identifier* lastFunctionName { nullptr };
1765         bool allowAwait { true };
1766     };
1767 
1768     // If you&#39;re using this directly, you probably should be using
1769     // createSavePoint() instead.
1770     ALWAYS_INLINE ParserState internalSaveParserState()
1771     {
1772         return m_parserState;
1773     }
1774 
1775     ALWAYS_INLINE void restoreParserState(const ParserState&amp; state)
1776     {
1777         m_parserState = state;
1778     }
1779 
1780     struct LexerState {
1781         int startOffset;
1782         unsigned oldLineStartOffset;
1783         unsigned oldLastLineNumber;
1784         unsigned oldLineNumber;
1785         bool hasLineTerminatorBeforeToken;
1786     };
1787 
1788     // If you&#39;re using this directly, you probably should be using
1789     // createSavePoint() instead.
1790     // i.e, if you parse any kind of AssignmentExpression between
1791     // saving/restoring, you should definitely not be using this directly.
1792     ALWAYS_INLINE LexerState internalSaveLexerState()
1793     {
1794         LexerState result;
1795         result.startOffset = m_token.m_location.startOffset;
1796         result.oldLineStartOffset = m_token.m_location.lineStartOffset;
1797         result.oldLastLineNumber = m_lexer-&gt;lastLineNumber();
1798         result.oldLineNumber = m_lexer-&gt;lineNumber();
1799         result.hasLineTerminatorBeforeToken = m_lexer-&gt;hasLineTerminatorBeforeToken();
1800         ASSERT(static_cast&lt;unsigned&gt;(result.startOffset) &gt;= result.oldLineStartOffset);
1801         return result;
1802     }
1803 
1804     ALWAYS_INLINE void restoreLexerState(const LexerState&amp; lexerState)
1805     {
1806         // setOffset clears lexer errors.
1807         m_lexer-&gt;setOffset(lexerState.startOffset, lexerState.oldLineStartOffset);
1808         m_lexer-&gt;setLineNumber(lexerState.oldLineNumber);
1809         m_lexer-&gt;setHasLineTerminatorBeforeToken(lexerState.hasLineTerminatorBeforeToken);
1810         nextWithoutClearingLineTerminator();
1811         m_lexer-&gt;setLastLineNumber(lexerState.oldLastLineNumber);
1812     }
1813 
1814     struct SavePoint {
1815         ParserState parserState;
1816         LexerState lexerState;
1817     };
1818 
1819     struct SavePointWithError : public SavePoint {
1820         bool lexerError;
1821         String lexerErrorMessage;
1822         String parserErrorMessage;
1823     };
1824 
1825     ALWAYS_INLINE void internalSaveState(SavePoint&amp; savePoint)
1826     {
1827         savePoint.parserState = internalSaveParserState();
1828         savePoint.lexerState = internalSaveLexerState();
1829     }
1830 
1831     ALWAYS_INLINE SavePointWithError createSavePointForError()
1832     {
1833         SavePointWithError savePoint;
1834         internalSaveState(savePoint);
1835         savePoint.lexerError = m_lexer-&gt;sawError();
1836         savePoint.lexerErrorMessage = m_lexer-&gt;getErrorMessage();
1837         savePoint.parserErrorMessage = m_errorMessage;
1838         return savePoint;
1839     }
1840 
1841     ALWAYS_INLINE SavePoint createSavePoint()
1842     {
1843         ASSERT(!hasError());
1844         SavePoint savePoint;
1845         internalSaveState(savePoint);
1846         return savePoint;
1847     }
1848 
1849     ALWAYS_INLINE void internalRestoreState(const SavePoint&amp; savePoint)
1850     {
1851         restoreLexerState(savePoint.lexerState);
1852         restoreParserState(savePoint.parserState);
1853     }
1854 
1855     ALWAYS_INLINE void restoreSavePointWithError(const SavePointWithError&amp; savePoint)
1856     {
1857         internalRestoreState(savePoint);
1858         m_lexer-&gt;setSawError(savePoint.lexerError);
1859         m_lexer-&gt;setErrorMessage(savePoint.lexerErrorMessage);
1860         m_errorMessage = savePoint.parserErrorMessage;
1861     }
1862 
1863     ALWAYS_INLINE void restoreSavePoint(const SavePoint&amp; savePoint)
1864     {
1865         internalRestoreState(savePoint);
1866         m_errorMessage = String();
1867     }
1868 
1869     VM&amp; m_vm;
1870     const SourceCode* m_source;
1871     ParserArena m_parserArena;
1872     std::unique_ptr&lt;LexerType&gt; m_lexer;
1873     FunctionParameters* m_parameters { nullptr };
1874 
1875     ParserState m_parserState;
1876 
1877     bool m_hasStackOverflow;
1878     String m_errorMessage;
1879     JSToken m_token;
1880     bool m_allowsIn;
1881     JSTextPosition m_lastTokenEndPosition;
1882     int m_statementDepth;
1883     RefPtr&lt;SourceProviderCache&gt; m_functionCache;
1884     SourceElements* m_sourceElements;
1885     bool m_parsingBuiltin;
1886     JSParserScriptMode m_scriptMode;
1887     SuperBinding m_superBinding;
1888     ConstructorKind m_defaultConstructorKind;
1889     VariableEnvironment m_varDeclarations;
1890     DeclarationStacks::FunctionStack m_funcDeclarations;
1891     UniquedStringImplPtrSet m_sloppyModeHoistedFunctions;
1892     CodeFeatures m_features;
1893     int m_numConstants;
1894     ExpressionErrorClassifier* m_expressionErrorClassifier;
1895     bool m_isEvalContext;
1896     bool m_immediateParentAllowsFunctionDeclarationInStatement;
1897     RefPtr&lt;ModuleScopeData&gt; m_moduleScopeData;
1898     DebuggerParseData* m_debuggerParseData;
1899     CallOrApplyDepthScope* m_callOrApplyDepthScope { nullptr };
1900     bool m_seenTaggedTemplate { false };
1901 };
1902 
1903 
1904 template &lt;typename LexerType&gt;
1905 template &lt;class ParsedNode&gt;
1906 std::unique_ptr&lt;ParsedNode&gt; Parser&lt;LexerType&gt;::parse(ParserError&amp; error, const Identifier&amp; calleeName, SourceParseMode parseMode, ParsingContext parsingContext, Optional&lt;int&gt; functionConstructorParametersEndPosition)
1907 {
1908     int errLine;
1909     String errMsg;
1910 
1911     if (ParsedNode::scopeIsFunction)
1912         m_lexer-&gt;setIsReparsingFunction();
1913 
1914     m_sourceElements = 0;
1915 
1916     errLine = -1;
1917     errMsg = String();
1918 
1919     JSTokenLocation startLocation(tokenLocation());
1920     ASSERT(m_source-&gt;startColumn() &gt; OrdinalNumber::beforeFirst());
1921     unsigned startColumn = m_source-&gt;startColumn().zeroBasedInt();
1922 
1923     String parseError = parseInner(calleeName, parseMode, parsingContext, functionConstructorParametersEndPosition);
1924 
1925     int lineNumber = m_lexer-&gt;lineNumber();
1926     bool lexError = m_lexer-&gt;sawError();
1927     String lexErrorMessage = lexError ? m_lexer-&gt;getErrorMessage() : String();
1928     ASSERT(lexErrorMessage.isNull() != lexError);
1929     m_lexer-&gt;clear();
1930 
1931     if (!parseError.isNull() || lexError) {
1932         errLine = lineNumber;
1933         errMsg = !lexErrorMessage.isNull() ? lexErrorMessage : parseError;
1934         m_sourceElements = 0;
1935     }
1936 
1937     std::unique_ptr&lt;ParsedNode&gt; result;
1938     if (m_sourceElements) {
1939         JSTokenLocation endLocation;
1940         endLocation.line = m_lexer-&gt;lineNumber();
1941         endLocation.lineStartOffset = m_lexer-&gt;currentLineStartOffset();
1942         endLocation.startOffset = m_lexer-&gt;currentOffset();
1943         unsigned endColumn = endLocation.startOffset - endLocation.lineStartOffset;
1944         result = makeUnique&lt;ParsedNode&gt;(m_parserArena,
1945                                     startLocation,
1946                                     endLocation,
1947                                     startColumn,
1948                                     endColumn,
1949                                     m_sourceElements,
1950                                     m_varDeclarations,
1951                                     WTFMove(m_funcDeclarations),
1952                                     currentScope()-&gt;finalizeLexicalEnvironment(),
1953                                     WTFMove(m_sloppyModeHoistedFunctions),
1954                                     m_parameters,
1955                                     *m_source,
1956                                     m_features,
1957                                     currentScope()-&gt;innerArrowFunctionFeatures(),
1958                                     m_numConstants,
1959                                     WTFMove(m_moduleScopeData));
1960         result-&gt;setLoc(m_source-&gt;firstLine().oneBasedInt(), m_lexer-&gt;lineNumber(), m_lexer-&gt;currentOffset(), m_lexer-&gt;currentLineStartOffset());
1961         result-&gt;setEndOffset(m_lexer-&gt;currentOffset());
1962 
1963         if (!isFunctionParseMode(parseMode)) {
1964             m_source-&gt;provider()-&gt;setSourceURLDirective(m_lexer-&gt;sourceURLDirective());
1965             m_source-&gt;provider()-&gt;setSourceMappingURLDirective(m_lexer-&gt;sourceMappingURLDirective());
1966         }
1967     } else {
1968         // We can never see a syntax error when reparsing a function, since we should have
1969         // reported the error when parsing the containing program or eval code. So if we&#39;re
1970         // parsing a function body node, we assume that what actually happened here is that
1971         // we ran out of stack while parsing. If we see an error while parsing eval or program
1972         // code we assume that it was a syntax error since running out of stack is much less
1973         // likely, and we are currently unable to distinguish between the two cases.
1974         if (isFunctionMetadataNode(static_cast&lt;ParsedNode*&gt;(0)) || m_hasStackOverflow)
1975             error = ParserError(ParserError::StackOverflow, ParserError::SyntaxErrorNone, m_token);
1976         else {
1977             ParserError::SyntaxErrorType errorType = ParserError::SyntaxErrorIrrecoverable;
1978             if (m_token.m_type == EOFTOK)
1979                 errorType = ParserError::SyntaxErrorRecoverable;
1980             else if (m_token.m_type &amp; UnterminatedErrorTokenFlag) {
1981                 // Treat multiline capable unterminated literals as recoverable.
1982                 if (m_token.m_type == UNTERMINATED_MULTILINE_COMMENT_ERRORTOK || m_token.m_type == UNTERMINATED_TEMPLATE_LITERAL_ERRORTOK)
1983                     errorType = ParserError::SyntaxErrorRecoverable;
1984                 else
1985                     errorType = ParserError::SyntaxErrorUnterminatedLiteral;
1986             }
1987 
1988             if (isEvalNode&lt;ParsedNode&gt;())
1989                 error = ParserError(ParserError::EvalError, errorType, m_token, errMsg, errLine);
1990             else
1991                 error = ParserError(ParserError::SyntaxError, errorType, m_token, errMsg, errLine);
1992         }
1993     }
1994 
1995     return result;
1996 }
1997 
1998 template &lt;class ParsedNode&gt;
1999 std::unique_ptr&lt;ParsedNode&gt; parse(
2000     VM&amp; vm, const SourceCode&amp; source,
2001     const Identifier&amp; name, JSParserBuiltinMode builtinMode,
2002     JSParserStrictMode strictMode, JSParserScriptMode scriptMode, SourceParseMode parseMode, SuperBinding superBinding,
2003     ParserError&amp; error, JSTextPosition* positionBeforeLastNewline = nullptr,
2004     ConstructorKind defaultConstructorKind = ConstructorKind::None,
2005     DerivedContextType derivedContextType = DerivedContextType::None,
2006     EvalContextType evalContextType = EvalContextType::None,
2007     DebuggerParseData* debuggerParseData = nullptr)
2008 {
2009     ASSERT(!source.provider()-&gt;source().isNull());
2010 
2011     MonotonicTime before;
2012     if (UNLIKELY(Options::reportParseTimes()))
2013         before = MonotonicTime::now();
2014 
2015     std::unique_ptr&lt;ParsedNode&gt; result;
2016     if (source.provider()-&gt;source().is8Bit()) {
2017         Parser&lt;Lexer&lt;LChar&gt;&gt; parser(vm, source, builtinMode, strictMode, scriptMode, parseMode, superBinding, defaultConstructorKind, derivedContextType, isEvalNode&lt;ParsedNode&gt;(), evalContextType, debuggerParseData);
2018         result = parser.parse&lt;ParsedNode&gt;(error, name, parseMode, isEvalNode&lt;ParsedNode&gt;() ? ParsingContext::Eval : ParsingContext::Program);
2019         if (positionBeforeLastNewline)
2020             *positionBeforeLastNewline = parser.positionBeforeLastNewline();
2021         if (builtinMode == JSParserBuiltinMode::Builtin) {
2022             if (!result) {
2023                 ASSERT(error.isValid());
2024                 if (error.type() != ParserError::StackOverflow)
2025                     dataLogLn(&quot;Unexpected error compiling builtin: &quot;, error.message());
2026             }
2027         }
2028     } else {
2029         ASSERT_WITH_MESSAGE(defaultConstructorKind == ConstructorKind::None, &quot;BuiltinExecutables::createDefaultConstructor should always use a 8-bit string&quot;);
2030         Parser&lt;Lexer&lt;UChar&gt;&gt; parser(vm, source, builtinMode, strictMode, scriptMode, parseMode, superBinding, defaultConstructorKind, derivedContextType, isEvalNode&lt;ParsedNode&gt;(), evalContextType, debuggerParseData);
2031         result = parser.parse&lt;ParsedNode&gt;(error, name, parseMode, isEvalNode&lt;ParsedNode&gt;() ? ParsingContext::Eval : ParsingContext::Program);
2032         if (positionBeforeLastNewline)
2033             *positionBeforeLastNewline = parser.positionBeforeLastNewline();
2034     }
2035 
2036     if (UNLIKELY(Options::countParseTimes()))
2037         globalParseCount++;
2038 
2039     if (UNLIKELY(Options::reportParseTimes())) {
2040         MonotonicTime after = MonotonicTime::now();
2041         ParseHash hash(source);
2042         dataLogLn(result ? &quot;Parsed #&quot; : &quot;Failed to parse #&quot;, hash.hashForCall(), &quot;/#&quot;, hash.hashForConstruct(), &quot; in &quot;, (after - before).milliseconds(), &quot; ms.&quot;);
2043     }
2044 
2045     return result;
2046 }
2047 
2048 inline std::unique_ptr&lt;ProgramNode&gt; parseFunctionForFunctionConstructor(VM&amp; vm, const SourceCode&amp; source, ParserError&amp; error, JSTextPosition* positionBeforeLastNewline, Optional&lt;int&gt; functionConstructorParametersEndPosition)
2049 {
2050     ASSERT(!source.provider()-&gt;source().isNull());
2051 
2052     MonotonicTime before;
2053     if (UNLIKELY(Options::reportParseTimes()))
2054         before = MonotonicTime::now();
2055 
2056     Identifier name;
2057     bool isEvalNode = false;
2058     std::unique_ptr&lt;ProgramNode&gt; result;
2059     if (source.provider()-&gt;source().is8Bit()) {
2060         Parser&lt;Lexer&lt;LChar&gt;&gt; parser(vm, source, JSParserBuiltinMode::NotBuiltin, JSParserStrictMode::NotStrict, JSParserScriptMode::Classic, SourceParseMode::ProgramMode, SuperBinding::NotNeeded, ConstructorKind::None, DerivedContextType::None, isEvalNode, EvalContextType::None, nullptr);
2061         result = parser.parse&lt;ProgramNode&gt;(error, name, SourceParseMode::ProgramMode, ParsingContext::FunctionConstructor, functionConstructorParametersEndPosition);
2062         if (positionBeforeLastNewline)
2063             *positionBeforeLastNewline = parser.positionBeforeLastNewline();
2064     } else {
2065         Parser&lt;Lexer&lt;UChar&gt;&gt; parser(vm, source, JSParserBuiltinMode::NotBuiltin, JSParserStrictMode::NotStrict, JSParserScriptMode::Classic, SourceParseMode::ProgramMode, SuperBinding::NotNeeded, ConstructorKind::None, DerivedContextType::None, isEvalNode, EvalContextType::None, nullptr);
2066         result = parser.parse&lt;ProgramNode&gt;(error, name, SourceParseMode::ProgramMode, ParsingContext::FunctionConstructor, functionConstructorParametersEndPosition);
2067         if (positionBeforeLastNewline)
2068             *positionBeforeLastNewline = parser.positionBeforeLastNewline();
2069     }
2070 
2071     if (UNLIKELY(Options::countParseTimes()))
2072         globalParseCount++;
2073 
2074     if (UNLIKELY(Options::reportParseTimes())) {
2075         MonotonicTime after = MonotonicTime::now();
2076         ParseHash hash(source);
2077         dataLogLn(result ? &quot;Parsed #&quot; : &quot;Failed to parse #&quot;, hash.hashForCall(), &quot;/#&quot;, hash.hashForConstruct(), &quot; in &quot;, (after - before).milliseconds(), &quot; ms.&quot;);
2078     }
2079 
2080     return result;
2081 }
2082 
2083 
2084 } // namespace
    </pre>
  </body>
</html>