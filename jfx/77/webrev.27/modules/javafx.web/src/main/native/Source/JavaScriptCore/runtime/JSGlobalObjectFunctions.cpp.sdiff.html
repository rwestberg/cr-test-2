<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSGlobalObjectFunctions.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="JSGlobalObject.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="JSGlobalObjectFunctions.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSGlobalObjectFunctions.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
  2  *  Copyright (C) 1999-2002 Harri Porten (porten@kde.org)
  3  *  Copyright (C) 2001 Peter Kelly (pmk@post.com)
<span class="line-modified">  4  *  Copyright (C) 2003-2018 Apple Inc. All rights reserved.</span>
  5  *  Copyright (C) 2007 Cameron Zwarich (cwzwarich@uwaterloo.ca)
  6  *  Copyright (C) 2007 Maks Orlovich
  7  *
  8  *  This library is free software; you can redistribute it and/or
  9  *  modify it under the terms of the GNU Library General Public
 10  *  License as published by the Free Software Foundation; either
 11  *  version 2 of the License, or (at your option) any later version.
 12  *
 13  *  This library is distributed in the hope that it will be useful,
 14  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 15  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 16  *  Library General Public License for more details.
 17  *
 18  *  You should have received a copy of the GNU Library General Public License
 19  *  along with this library; see the file COPYING.LIB.  If not, write to
 20  *  the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 21  *  Boston, MA 02110-1301, USA.
 22  *
 23  */
 24 
</pre>
<hr />
<pre>
 27 
 28 #include &quot;CallFrame.h&quot;
 29 #include &quot;CatchScope.h&quot;
 30 #include &quot;EvalExecutable.h&quot;
 31 #include &quot;Exception.h&quot;
 32 #include &quot;IndirectEvalExecutable.h&quot;
 33 #include &quot;Interpreter.h&quot;
 34 #include &quot;IntlDateTimeFormat.h&quot;
 35 #include &quot;IntlObject.h&quot;
 36 #include &quot;JSCInlines.h&quot;
 37 #include &quot;JSFunction.h&quot;
 38 #include &quot;JSGlobalObject.h&quot;
 39 #include &quot;JSInternalPromise.h&quot;
 40 #include &quot;JSModuleLoader.h&quot;
 41 #include &quot;JSPromise.h&quot;
 42 #include &quot;JSPromiseDeferred.h&quot;
 43 #include &quot;JSString.h&quot;
 44 #include &quot;Lexer.h&quot;
 45 #include &quot;LiteralParser.h&quot;
 46 #include &quot;Nodes.h&quot;

 47 #include &quot;JSCInlines.h&quot;
 48 #include &quot;ParseInt.h&quot;
 49 #include &quot;Parser.h&quot;
 50 #include &quot;StackVisitor.h&quot;
 51 #include &lt;stdio.h&gt;
 52 #include &lt;stdlib.h&gt;
 53 #include &lt;unicode/utf8.h&gt;
 54 #include &lt;wtf/ASCIICType.h&gt;
 55 #include &lt;wtf/Assertions.h&gt;
 56 #include &lt;wtf/HexNumber.h&gt;
 57 #include &lt;wtf/MathExtras.h&gt;
 58 #include &lt;wtf/dtoa.h&gt;
 59 #include &lt;wtf/text/StringBuilder.h&gt;
<span class="line-removed"> 60 #include &lt;wtf/unicode/UTF8Conversion.h&gt;</span>
 61 
 62 namespace JSC {
 63 
<span class="line-removed"> 64 using namespace WTF::Unicode;</span>
<span class="line-removed"> 65 </span>
 66 const ASCIILiteral ObjectProtoCalledOnNullOrUndefinedError { &quot;Object.prototype.__proto__ called on null or undefined&quot;_s };
 67 
 68 template&lt;unsigned charactersCount&gt;
 69 static Bitmap&lt;256&gt; makeCharacterBitmap(const char (&amp;characters)[charactersCount])
 70 {
 71     static_assert(charactersCount &gt; 0, &quot;Since string literal is null terminated, characterCount is always larger than 0&quot;);
 72     Bitmap&lt;256&gt; bitmap;
 73     for (unsigned i = 0; i &lt; charactersCount - 1; ++i)
 74         bitmap.set(characters[i]);
 75     return bitmap;
 76 }
 77 
 78 template&lt;typename CharacterType&gt;
 79 static JSValue encode(ExecState* exec, const Bitmap&lt;256&gt;&amp; doNotEscape, const CharacterType* characters, unsigned length)
 80 {
 81     VM&amp; vm = exec-&gt;vm();
 82     auto scope = DECLARE_THROW_SCOPE(vm);
 83 
 84     // 18.2.6.1.1 Runtime Semantics: Encode ( string, unescapedSet )
 85     // https://tc39.github.io/ecma262/#sec-encode
</pre>
<hr />
<pre>
137         LChar utf8OctetsBuffer[U8_MAX_LENGTH];
138         unsigned utf8Length = 0;
139         // We can use U8_APPEND_UNSAFE here since codePoint is either
140         // 1. non surrogate one, correct code point.
141         // 2. correct code point generated from validated lead and trail surrogates.
142         U8_APPEND_UNSAFE(utf8OctetsBuffer, utf8Length, codePoint);
143 
144         // 4-d-v. Let j be 0.
145         // 4-d-vi. Repeat, while j &lt; L
146         for (unsigned index = 0; index &lt; utf8Length; ++index) {
147             // 4-d-vi-1. Let jOctet be the value at index j within Octets.
148             // 4-d-vi-2. Let S be a String containing three code units &quot;%XY&quot; where XY are two uppercase hexadecimal digits encoding the value of jOctet.
149             // 4-d-vi-3. Let R be a new String value computed by concatenating the previous value of R and S.
150             builder.append(&#39;%&#39;);
151             appendByteAsHex(utf8OctetsBuffer[index], builder);
152         }
153     }
154 
155     if (UNLIKELY(builder.hasOverflowed()))
156         return throwOutOfMemoryError(exec, scope);
<span class="line-modified">157     return jsString(exec, builder.toString());</span>
158 }
159 
160 static JSValue encode(ExecState* exec, const Bitmap&lt;256&gt;&amp; doNotEscape)
161 {
162     return toStringView(exec, exec-&gt;argument(0), [&amp;] (StringView view) {
163         if (view.is8Bit())
164             return encode(exec, doNotEscape, view.characters8(), view.length());
165         return encode(exec, doNotEscape, view.characters16(), view.length());
166     });
167 }
168 
169 template &lt;typename CharType&gt;
170 ALWAYS_INLINE
171 static JSValue decode(ExecState* exec, const CharType* characters, int length, const Bitmap&lt;256&gt;&amp; doNotUnescape, bool strict)
172 {
173     VM&amp; vm = exec-&gt;vm();
174     auto scope = DECLARE_THROW_SCOPE(vm);
175 
176     StringBuilder builder(StringBuilder::OverflowHandler::RecordOverflow);
177     int k = 0;
178     UChar u = 0;
179     while (k &lt; length) {
180         const CharType* p = characters + k;
181         CharType c = *p;
182         if (c == &#39;%&#39;) {
183             int charLen = 0;
184             if (k &lt;= length - 3 &amp;&amp; isASCIIHexDigit(p[1]) &amp;&amp; isASCIIHexDigit(p[2])) {
185                 const char b0 = Lexer&lt;CharType&gt;::convertHex(p[1], p[2]);
<span class="line-modified">186                 const int sequenceLen = UTF8SequenceLength(b0);</span>
<span class="line-modified">187                 if (sequenceLen &amp;&amp; k &lt;= length - sequenceLen * 3) {</span>
188                     charLen = sequenceLen * 3;
<span class="line-modified">189                     char sequence[5];</span>





190                     sequence[0] = b0;
191                     for (int i = 1; i &lt; sequenceLen; ++i) {
192                         const CharType* q = p + i * 3;
193                         if (q[0] == &#39;%&#39; &amp;&amp; isASCIIHexDigit(q[1]) &amp;&amp; isASCIIHexDigit(q[2]))
194                             sequence[i] = Lexer&lt;CharType&gt;::convertHex(q[1], q[2]);
195                         else {
196                             charLen = 0;
197                             break;
198                         }
199                     }
200                     if (charLen != 0) {
<span class="line-modified">201                         sequence[sequenceLen] = 0;</span>
<span class="line-modified">202                         const int character = decodeUTF8Sequence(sequence);</span>
<span class="line-modified">203                         if (character &lt; 0 || character &gt;= 0x110000)</span>

204                             charLen = 0;
<span class="line-modified">205                         else if (character &gt;= 0x10000) {</span>
206                             // Convert to surrogate pair.
<span class="line-modified">207                             builder.append(static_cast&lt;UChar&gt;(0xD800 | ((character - 0x10000) &gt;&gt; 10)));</span>
<span class="line-modified">208                             u = static_cast&lt;UChar&gt;(0xDC00 | ((character - 0x10000) &amp; 0x3FF));</span>
<span class="line-modified">209                         } else</span>


210                             u = static_cast&lt;UChar&gt;(character);

211                     }
212                 }
213             }
214             if (charLen == 0) {
215                 if (strict)
216                     return throwException(exec, scope, createURIError(exec, &quot;URI error&quot;_s));
217                 // The only case where we don&#39;t use &quot;strict&quot; mode is the &quot;unescape&quot; function.
218                 // For that, it&#39;s good to support the wonky &quot;%u&quot; syntax for compatibility with WinIE.
219                 if (k &lt;= length - 6 &amp;&amp; p[1] == &#39;u&#39;
220                         &amp;&amp; isASCIIHexDigit(p[2]) &amp;&amp; isASCIIHexDigit(p[3])
221                         &amp;&amp; isASCIIHexDigit(p[4]) &amp;&amp; isASCIIHexDigit(p[5])) {
222                     charLen = 6;
223                     u = Lexer&lt;UChar&gt;::convertUnicode(p[2], p[3], p[4], p[5]);
224                 }
225             }
226             if (charLen &amp;&amp; (u &gt;= 128 || !doNotUnescape.get(static_cast&lt;LChar&gt;(u)))) {
227                 builder.append(u);
228                 k += charLen;
229                 continue;
230             }
231         }
232         k++;
233         builder.append(c);
234     }
235     if (UNLIKELY(builder.hasOverflowed()))
236         return throwOutOfMemoryError(exec, scope);
<span class="line-modified">237     RELEASE_AND_RETURN(scope, jsString(&amp;vm, builder.toString()));</span>
238 }
239 
240 static JSValue decode(ExecState* exec, const Bitmap&lt;256&gt;&amp; doNotUnescape, bool strict)
241 {
242     return toStringView(exec, exec-&gt;argument(0), [&amp;] (StringView view) {
243         if (view.is8Bit())
244             return decode(exec, view.characters8(), view.length(), doNotUnescape, strict);
245         return decode(exec, view.characters16(), view.length(), doNotUnescape, strict);
246     });
247 }
248 
249 static const int SizeOfInfinity = 8;
250 
251 template &lt;typename CharType&gt;
252 static bool isInfinity(const CharType* data, const CharType* end)
253 {
254     return (end - data) &gt;= SizeOfInfinity
255         &amp;&amp; data[0] == &#39;I&#39;
256         &amp;&amp; data[1] == &#39;n&#39;
257         &amp;&amp; data[2] == &#39;f&#39;
</pre>
<hr />
<pre>
577     static Bitmap&lt;256&gt; doNotEscapeWhenEncodingURIComponent = makeCharacterBitmap(
578         &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;
579         &quot;abcdefghijklmnopqrstuvwxyz&quot;
580         &quot;0123456789&quot;
581         &quot;!&#39;()*-._~&quot;
582     );
583 
584     return JSValue::encode(encode(exec, doNotEscapeWhenEncodingURIComponent));
585 }
586 
587 EncodedJSValue JSC_HOST_CALL globalFuncEscape(ExecState* exec)
588 {
589     static Bitmap&lt;256&gt; doNotEscape = makeCharacterBitmap(
590         &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;
591         &quot;abcdefghijklmnopqrstuvwxyz&quot;
592         &quot;0123456789&quot;
593         &quot;*+-./@_&quot;
594     );
595 
596     return JSValue::encode(toStringView(exec, exec-&gt;argument(0), [&amp;] (StringView view) {

597         StringBuilder builder;
598         if (view.is8Bit()) {
599             const LChar* c = view.characters8();
600             for (unsigned k = 0; k &lt; view.length(); k++, c++) {
601                 int u = c[0];
602                 if (doNotEscape.get(static_cast&lt;LChar&gt;(u)))
603                     builder.append(*c);
604                 else {
605                     builder.append(&#39;%&#39;);
606                     appendByteAsHex(u, builder);
607                 }
608             }
<span class="line-modified">609             return jsString(exec, builder.toString());</span>
610         }
611 
612         const UChar* c = view.characters16();
613         for (unsigned k = 0; k &lt; view.length(); k++, c++) {
614             UChar u = c[0];
615             if (u &gt;= doNotEscape.size()) {
616                 builder.appendLiteral(&quot;%u&quot;);
617                 appendByteAsHex(u &gt;&gt; 8, builder);
618                 appendByteAsHex(u &amp; 0xFF, builder);
619             } else if (doNotEscape.get(static_cast&lt;LChar&gt;(u)))
620                 builder.append(*c);
621             else {
622                 builder.append(&#39;%&#39;);
623                 appendByteAsHex(u, builder);
624             }
625         }
626 
<span class="line-modified">627         return jsString(exec, builder.toString());</span>
628     }));
629 }
630 
631 EncodedJSValue JSC_HOST_CALL globalFuncUnescape(ExecState* exec)
632 {
633     return JSValue::encode(toStringView(exec, exec-&gt;argument(0), [&amp;] (StringView view) {
634         // We use int for k and length intentionally since we would like to evaluate
635         // the condition `k &lt;= length -6` even if length is less than 6.
636         int k = 0;
637         int length = view.length();
638 
639         StringBuilder builder;
640         builder.reserveCapacity(length);
641 
642         if (view.is8Bit()) {
643             const LChar* characters = view.characters8();
644             LChar convertedLChar;
645             while (k &lt; length) {
646                 const LChar* c = characters + k;
647                 if (c[0] == &#39;%&#39; &amp;&amp; k &lt;= length - 6 &amp;&amp; c[1] == &#39;u&#39;) {
</pre>
<hr />
<pre>
663 
664             while (k &lt; length) {
665                 const UChar* c = characters + k;
666                 UChar convertedUChar;
667                 if (c[0] == &#39;%&#39; &amp;&amp; k &lt;= length - 6 &amp;&amp; c[1] == &#39;u&#39;) {
668                     if (isASCIIHexDigit(c[2]) &amp;&amp; isASCIIHexDigit(c[3]) &amp;&amp; isASCIIHexDigit(c[4]) &amp;&amp; isASCIIHexDigit(c[5])) {
669                         convertedUChar = Lexer&lt;UChar&gt;::convertUnicode(c[2], c[3], c[4], c[5]);
670                         c = &amp;convertedUChar;
671                         k += 5;
672                     }
673                 } else if (c[0] == &#39;%&#39; &amp;&amp; k &lt;= length - 3 &amp;&amp; isASCIIHexDigit(c[1]) &amp;&amp; isASCIIHexDigit(c[2])) {
674                     convertedUChar = UChar(Lexer&lt;UChar&gt;::convertHex(c[1], c[2]));
675                     c = &amp;convertedUChar;
676                     k += 2;
677                 }
678                 k++;
679                 builder.append(*c);
680             }
681         }
682 
<span class="line-modified">683         return jsString(exec, builder.toString());</span>
684     }));
685 }
686 
687 EncodedJSValue JSC_HOST_CALL globalFuncThrowTypeError(ExecState* exec)
688 {
689     VM&amp; vm = exec-&gt;vm();
690     auto scope = DECLARE_THROW_SCOPE(vm);
691     return throwVMTypeError(exec, scope);
692 }
693 
694 EncodedJSValue JSC_HOST_CALL globalFuncThrowTypeErrorArgumentsCalleeAndCaller(ExecState* exec)
695 {
696     VM&amp; vm = exec-&gt;vm();
697     auto scope = DECLARE_THROW_SCOPE(vm);
698     return throwVMTypeError(exec, scope, &quot;&#39;arguments&#39;, &#39;callee&#39;, and &#39;caller&#39; cannot be accessed in this context.&quot;);
699 }
700 







701 EncodedJSValue JSC_HOST_CALL globalFuncProtoGetter(ExecState* exec)
702 {
703     VM&amp; vm = exec-&gt;vm();
704     auto scope = DECLARE_THROW_SCOPE(vm);
705 
706     JSValue thisValue = exec-&gt;thisValue().toThis(exec, StrictMode);
707     if (thisValue.isUndefinedOrNull())
708         return throwVMError(exec, scope, createNotAnObjectError(exec, thisValue));
709 
710     JSObject* thisObject = jsDynamicCast&lt;JSObject*&gt;(vm, thisValue);
711     if (!thisObject) {
712         JSObject* prototype = thisValue.synthesizePrototype(exec);
713         EXCEPTION_ASSERT(!!scope.exception() == !prototype);
714         if (UNLIKELY(!prototype))
715             return JSValue::encode(JSValue());
716         return JSValue::encode(prototype);
717     }
718 
719     RELEASE_AND_RETURN(scope, JSValue::encode(thisObject-&gt;getPrototype(vm, exec)));
720 }
</pre>
<hr />
<pre>
735     // Setting __proto__ of a primitive should have no effect.
736     if (!thisObject)
737         return JSValue::encode(jsUndefined());
738 
739     // Setting __proto__ to a non-object, non-null value is silently ignored to match Mozilla.
740     if (!value.isObject() &amp;&amp; !value.isNull())
741         return JSValue::encode(jsUndefined());
742 
743     scope.release();
744     bool shouldThrowIfCantSet = true;
745     thisObject-&gt;setPrototype(vm, exec, value, shouldThrowIfCantSet);
746     return JSValue::encode(jsUndefined());
747 }
748 
749 EncodedJSValue JSC_HOST_CALL globalFuncHostPromiseRejectionTracker(ExecState* exec)
750 {
751     JSGlobalObject* globalObject = exec-&gt;lexicalGlobalObject();
752     VM&amp; vm = globalObject-&gt;vm();
753     auto scope = DECLARE_THROW_SCOPE(vm);
754 
<span class="line-modified">755     if (!globalObject-&gt;globalObjectMethodTable()-&gt;promiseRejectionTracker)</span>



756         return JSValue::encode(jsUndefined());
757 
<span class="line-removed">758     JSPromise* promise = jsCast&lt;JSPromise*&gt;(exec-&gt;argument(0));</span>
759     JSValue operationValue = exec-&gt;argument(1);
760 
761     ASSERT(operationValue.isNumber());
762     auto operation = static_cast&lt;JSPromiseRejectionOperation&gt;(operationValue.toUInt32(exec));
763     ASSERT(operation == JSPromiseRejectionOperation::Reject || operation == JSPromiseRejectionOperation::Handle);
764     scope.assertNoException();
765 
<span class="line-modified">766     globalObject-&gt;globalObjectMethodTable()-&gt;promiseRejectionTracker(globalObject, exec, promise, operation);</span>











767     RETURN_IF_EXCEPTION(scope, { });
768 
769     return JSValue::encode(jsUndefined());
770 }
771 
772 EncodedJSValue JSC_HOST_CALL globalFuncBuiltinLog(ExecState* exec)
773 {
774     dataLog(exec-&gt;argument(0).toWTFString(exec), &quot;\n&quot;);
775     return JSValue::encode(jsUndefined());
776 }
777 
778 EncodedJSValue JSC_HOST_CALL globalFuncBuiltinDescribe(ExecState* exec)
779 {
<span class="line-modified">780     return JSValue::encode(jsString(exec, toString(exec-&gt;argument(0))));</span>
781 }
782 
783 EncodedJSValue JSC_HOST_CALL globalFuncImportModule(ExecState* exec)
784 {
785     VM&amp; vm = exec-&gt;vm();
786     auto throwScope = DECLARE_THROW_SCOPE(vm);
787 
788     auto* globalObject = exec-&gt;lexicalGlobalObject();
789 
790     auto* promise = JSPromiseDeferred::tryCreate(exec, globalObject);
791     RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
792 
793     auto catchScope = DECLARE_CATCH_SCOPE(vm);
794     auto reject = [&amp;] (JSValue rejectionReason) {
795         catchScope.clearException();
796         promise-&gt;reject(exec, rejectionReason);
797         catchScope.clearException();
798         return JSValue::encode(promise-&gt;promise());
799     };
800 
</pre>
<hr />
<pre>
815     catchScope.clearException();
816     return JSValue::encode(promise-&gt;promise());
817 }
818 
819 EncodedJSValue JSC_HOST_CALL globalFuncPropertyIsEnumerable(ExecState* exec)
820 {
821     VM&amp; vm = exec-&gt;vm();
822     auto scope = DECLARE_THROW_SCOPE(vm);
823 
824     RELEASE_ASSERT(exec-&gt;argumentCount() == 2);
825     JSObject* object = jsCast&lt;JSObject*&gt;(exec-&gt;uncheckedArgument(0));
826     auto propertyName = exec-&gt;uncheckedArgument(1).toPropertyKey(exec);
827     RETURN_IF_EXCEPTION(scope, encodedJSValue());
828 
829     scope.release();
830     PropertyDescriptor descriptor;
831     bool enumerable = object-&gt;getOwnPropertyDescriptor(exec, propertyName, descriptor) &amp;&amp; descriptor.enumerable();
832     return JSValue::encode(jsBoolean(enumerable));
833 }
834 









835 #if ENABLE(INTL)
836 EncodedJSValue JSC_HOST_CALL globalFuncDateTimeFormat(ExecState* exec)
837 {
838     VM&amp; vm = exec-&gt;vm();
839     auto scope = DECLARE_THROW_SCOPE(vm);
840 
841     JSGlobalObject* globalObject = exec-&gt;lexicalGlobalObject();
842     IntlDateTimeFormat* dateTimeFormat = IntlDateTimeFormat::create(vm, globalObject-&gt;dateTimeFormatStructure());
843     dateTimeFormat-&gt;initializeDateTimeFormat(*exec, exec-&gt;argument(0), exec-&gt;argument(1));
844     RETURN_IF_EXCEPTION(scope, encodedJSValue());
845     double value = exec-&gt;argument(2).toNumber(exec);
846     RETURN_IF_EXCEPTION(scope, encodedJSValue());
847     RELEASE_AND_RETURN(scope, JSValue::encode(dateTimeFormat-&gt;format(*exec, value)));
848 }
849 #endif
850 
851 } // namespace JSC
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
  2  *  Copyright (C) 1999-2002 Harri Porten (porten@kde.org)
  3  *  Copyright (C) 2001 Peter Kelly (pmk@post.com)
<span class="line-modified">  4  *  Copyright (C) 2003-2019 Apple Inc. All rights reserved.</span>
  5  *  Copyright (C) 2007 Cameron Zwarich (cwzwarich@uwaterloo.ca)
  6  *  Copyright (C) 2007 Maks Orlovich
  7  *
  8  *  This library is free software; you can redistribute it and/or
  9  *  modify it under the terms of the GNU Library General Public
 10  *  License as published by the Free Software Foundation; either
 11  *  version 2 of the License, or (at your option) any later version.
 12  *
 13  *  This library is distributed in the hope that it will be useful,
 14  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 15  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 16  *  Library General Public License for more details.
 17  *
 18  *  You should have received a copy of the GNU Library General Public License
 19  *  along with this library; see the file COPYING.LIB.  If not, write to
 20  *  the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 21  *  Boston, MA 02110-1301, USA.
 22  *
 23  */
 24 
</pre>
<hr />
<pre>
 27 
 28 #include &quot;CallFrame.h&quot;
 29 #include &quot;CatchScope.h&quot;
 30 #include &quot;EvalExecutable.h&quot;
 31 #include &quot;Exception.h&quot;
 32 #include &quot;IndirectEvalExecutable.h&quot;
 33 #include &quot;Interpreter.h&quot;
 34 #include &quot;IntlDateTimeFormat.h&quot;
 35 #include &quot;IntlObject.h&quot;
 36 #include &quot;JSCInlines.h&quot;
 37 #include &quot;JSFunction.h&quot;
 38 #include &quot;JSGlobalObject.h&quot;
 39 #include &quot;JSInternalPromise.h&quot;
 40 #include &quot;JSModuleLoader.h&quot;
 41 #include &quot;JSPromise.h&quot;
 42 #include &quot;JSPromiseDeferred.h&quot;
 43 #include &quot;JSString.h&quot;
 44 #include &quot;Lexer.h&quot;
 45 #include &quot;LiteralParser.h&quot;
 46 #include &quot;Nodes.h&quot;
<span class="line-added"> 47 #include &quot;ObjectConstructor.h&quot;</span>
 48 #include &quot;JSCInlines.h&quot;
 49 #include &quot;ParseInt.h&quot;
 50 #include &quot;Parser.h&quot;
 51 #include &quot;StackVisitor.h&quot;
 52 #include &lt;stdio.h&gt;
 53 #include &lt;stdlib.h&gt;
 54 #include &lt;unicode/utf8.h&gt;
 55 #include &lt;wtf/ASCIICType.h&gt;
 56 #include &lt;wtf/Assertions.h&gt;
 57 #include &lt;wtf/HexNumber.h&gt;
 58 #include &lt;wtf/MathExtras.h&gt;
 59 #include &lt;wtf/dtoa.h&gt;
 60 #include &lt;wtf/text/StringBuilder.h&gt;

 61 
 62 namespace JSC {
 63 


 64 const ASCIILiteral ObjectProtoCalledOnNullOrUndefinedError { &quot;Object.prototype.__proto__ called on null or undefined&quot;_s };
 65 
 66 template&lt;unsigned charactersCount&gt;
 67 static Bitmap&lt;256&gt; makeCharacterBitmap(const char (&amp;characters)[charactersCount])
 68 {
 69     static_assert(charactersCount &gt; 0, &quot;Since string literal is null terminated, characterCount is always larger than 0&quot;);
 70     Bitmap&lt;256&gt; bitmap;
 71     for (unsigned i = 0; i &lt; charactersCount - 1; ++i)
 72         bitmap.set(characters[i]);
 73     return bitmap;
 74 }
 75 
 76 template&lt;typename CharacterType&gt;
 77 static JSValue encode(ExecState* exec, const Bitmap&lt;256&gt;&amp; doNotEscape, const CharacterType* characters, unsigned length)
 78 {
 79     VM&amp; vm = exec-&gt;vm();
 80     auto scope = DECLARE_THROW_SCOPE(vm);
 81 
 82     // 18.2.6.1.1 Runtime Semantics: Encode ( string, unescapedSet )
 83     // https://tc39.github.io/ecma262/#sec-encode
</pre>
<hr />
<pre>
135         LChar utf8OctetsBuffer[U8_MAX_LENGTH];
136         unsigned utf8Length = 0;
137         // We can use U8_APPEND_UNSAFE here since codePoint is either
138         // 1. non surrogate one, correct code point.
139         // 2. correct code point generated from validated lead and trail surrogates.
140         U8_APPEND_UNSAFE(utf8OctetsBuffer, utf8Length, codePoint);
141 
142         // 4-d-v. Let j be 0.
143         // 4-d-vi. Repeat, while j &lt; L
144         for (unsigned index = 0; index &lt; utf8Length; ++index) {
145             // 4-d-vi-1. Let jOctet be the value at index j within Octets.
146             // 4-d-vi-2. Let S be a String containing three code units &quot;%XY&quot; where XY are two uppercase hexadecimal digits encoding the value of jOctet.
147             // 4-d-vi-3. Let R be a new String value computed by concatenating the previous value of R and S.
148             builder.append(&#39;%&#39;);
149             appendByteAsHex(utf8OctetsBuffer[index], builder);
150         }
151     }
152 
153     if (UNLIKELY(builder.hasOverflowed()))
154         return throwOutOfMemoryError(exec, scope);
<span class="line-modified">155     return jsString(vm, builder.toString());</span>
156 }
157 
158 static JSValue encode(ExecState* exec, const Bitmap&lt;256&gt;&amp; doNotEscape)
159 {
160     return toStringView(exec, exec-&gt;argument(0), [&amp;] (StringView view) {
161         if (view.is8Bit())
162             return encode(exec, doNotEscape, view.characters8(), view.length());
163         return encode(exec, doNotEscape, view.characters16(), view.length());
164     });
165 }
166 
167 template &lt;typename CharType&gt;
168 ALWAYS_INLINE
169 static JSValue decode(ExecState* exec, const CharType* characters, int length, const Bitmap&lt;256&gt;&amp; doNotUnescape, bool strict)
170 {
171     VM&amp; vm = exec-&gt;vm();
172     auto scope = DECLARE_THROW_SCOPE(vm);
173 
174     StringBuilder builder(StringBuilder::OverflowHandler::RecordOverflow);
175     int k = 0;
176     UChar u = 0;
177     while (k &lt; length) {
178         const CharType* p = characters + k;
179         CharType c = *p;
180         if (c == &#39;%&#39;) {
181             int charLen = 0;
182             if (k &lt;= length - 3 &amp;&amp; isASCIIHexDigit(p[1]) &amp;&amp; isASCIIHexDigit(p[2])) {
183                 const char b0 = Lexer&lt;CharType&gt;::convertHex(p[1], p[2]);
<span class="line-modified">184                 const int sequenceLen = 1 + U8_COUNT_TRAIL_BYTES(b0);</span>
<span class="line-modified">185                 if (k &lt;= length - sequenceLen * 3) {</span>
186                     charLen = sequenceLen * 3;
<span class="line-modified">187 #if U_ICU_VERSION_MAJOR_NUM &gt;= 60</span>
<span class="line-added">188                     uint8_t sequence[U8_MAX_LENGTH];</span>
<span class="line-added">189 #else</span>
<span class="line-added">190                     // In pre-60 ICU, U8_COUNT_TRAIL_BYTES returns 0..5</span>
<span class="line-added">191                     uint8_t sequence[6];</span>
<span class="line-added">192 #endif</span>
193                     sequence[0] = b0;
194                     for (int i = 1; i &lt; sequenceLen; ++i) {
195                         const CharType* q = p + i * 3;
196                         if (q[0] == &#39;%&#39; &amp;&amp; isASCIIHexDigit(q[1]) &amp;&amp; isASCIIHexDigit(q[2]))
197                             sequence[i] = Lexer&lt;CharType&gt;::convertHex(q[1], q[2]);
198                         else {
199                             charLen = 0;
200                             break;
201                         }
202                     }
203                     if (charLen != 0) {
<span class="line-modified">204                         UChar32 character;</span>
<span class="line-modified">205                         int32_t offset = 0;</span>
<span class="line-modified">206                         U8_NEXT(sequence, offset, sequenceLen, character);</span>
<span class="line-added">207                         if (character &lt; 0)</span>
208                             charLen = 0;
<span class="line-modified">209                         else if (!U_IS_BMP(character)) {</span>
210                             // Convert to surrogate pair.
<span class="line-modified">211                             ASSERT(U_IS_SUPPLEMENTARY(character));</span>
<span class="line-modified">212                             builder.append(U16_LEAD(character));</span>
<span class="line-modified">213                             u = U16_TRAIL(character);</span>
<span class="line-added">214                         } else {</span>
<span class="line-added">215                             ASSERT(!U_IS_SURROGATE(character));</span>
216                             u = static_cast&lt;UChar&gt;(character);
<span class="line-added">217                         }</span>
218                     }
219                 }
220             }
221             if (charLen == 0) {
222                 if (strict)
223                     return throwException(exec, scope, createURIError(exec, &quot;URI error&quot;_s));
224                 // The only case where we don&#39;t use &quot;strict&quot; mode is the &quot;unescape&quot; function.
225                 // For that, it&#39;s good to support the wonky &quot;%u&quot; syntax for compatibility with WinIE.
226                 if (k &lt;= length - 6 &amp;&amp; p[1] == &#39;u&#39;
227                         &amp;&amp; isASCIIHexDigit(p[2]) &amp;&amp; isASCIIHexDigit(p[3])
228                         &amp;&amp; isASCIIHexDigit(p[4]) &amp;&amp; isASCIIHexDigit(p[5])) {
229                     charLen = 6;
230                     u = Lexer&lt;UChar&gt;::convertUnicode(p[2], p[3], p[4], p[5]);
231                 }
232             }
233             if (charLen &amp;&amp; (u &gt;= 128 || !doNotUnescape.get(static_cast&lt;LChar&gt;(u)))) {
234                 builder.append(u);
235                 k += charLen;
236                 continue;
237             }
238         }
239         k++;
240         builder.append(c);
241     }
242     if (UNLIKELY(builder.hasOverflowed()))
243         return throwOutOfMemoryError(exec, scope);
<span class="line-modified">244     RELEASE_AND_RETURN(scope, jsString(vm, builder.toString()));</span>
245 }
246 
247 static JSValue decode(ExecState* exec, const Bitmap&lt;256&gt;&amp; doNotUnescape, bool strict)
248 {
249     return toStringView(exec, exec-&gt;argument(0), [&amp;] (StringView view) {
250         if (view.is8Bit())
251             return decode(exec, view.characters8(), view.length(), doNotUnescape, strict);
252         return decode(exec, view.characters16(), view.length(), doNotUnescape, strict);
253     });
254 }
255 
256 static const int SizeOfInfinity = 8;
257 
258 template &lt;typename CharType&gt;
259 static bool isInfinity(const CharType* data, const CharType* end)
260 {
261     return (end - data) &gt;= SizeOfInfinity
262         &amp;&amp; data[0] == &#39;I&#39;
263         &amp;&amp; data[1] == &#39;n&#39;
264         &amp;&amp; data[2] == &#39;f&#39;
</pre>
<hr />
<pre>
584     static Bitmap&lt;256&gt; doNotEscapeWhenEncodingURIComponent = makeCharacterBitmap(
585         &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;
586         &quot;abcdefghijklmnopqrstuvwxyz&quot;
587         &quot;0123456789&quot;
588         &quot;!&#39;()*-._~&quot;
589     );
590 
591     return JSValue::encode(encode(exec, doNotEscapeWhenEncodingURIComponent));
592 }
593 
594 EncodedJSValue JSC_HOST_CALL globalFuncEscape(ExecState* exec)
595 {
596     static Bitmap&lt;256&gt; doNotEscape = makeCharacterBitmap(
597         &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;
598         &quot;abcdefghijklmnopqrstuvwxyz&quot;
599         &quot;0123456789&quot;
600         &quot;*+-./@_&quot;
601     );
602 
603     return JSValue::encode(toStringView(exec, exec-&gt;argument(0), [&amp;] (StringView view) {
<span class="line-added">604         VM&amp; vm = exec-&gt;vm();</span>
605         StringBuilder builder;
606         if (view.is8Bit()) {
607             const LChar* c = view.characters8();
608             for (unsigned k = 0; k &lt; view.length(); k++, c++) {
609                 int u = c[0];
610                 if (doNotEscape.get(static_cast&lt;LChar&gt;(u)))
611                     builder.append(*c);
612                 else {
613                     builder.append(&#39;%&#39;);
614                     appendByteAsHex(u, builder);
615                 }
616             }
<span class="line-modified">617             return jsString(vm, builder.toString());</span>
618         }
619 
620         const UChar* c = view.characters16();
621         for (unsigned k = 0; k &lt; view.length(); k++, c++) {
622             UChar u = c[0];
623             if (u &gt;= doNotEscape.size()) {
624                 builder.appendLiteral(&quot;%u&quot;);
625                 appendByteAsHex(u &gt;&gt; 8, builder);
626                 appendByteAsHex(u &amp; 0xFF, builder);
627             } else if (doNotEscape.get(static_cast&lt;LChar&gt;(u)))
628                 builder.append(*c);
629             else {
630                 builder.append(&#39;%&#39;);
631                 appendByteAsHex(u, builder);
632             }
633         }
634 
<span class="line-modified">635         return jsString(vm, builder.toString());</span>
636     }));
637 }
638 
639 EncodedJSValue JSC_HOST_CALL globalFuncUnescape(ExecState* exec)
640 {
641     return JSValue::encode(toStringView(exec, exec-&gt;argument(0), [&amp;] (StringView view) {
642         // We use int for k and length intentionally since we would like to evaluate
643         // the condition `k &lt;= length -6` even if length is less than 6.
644         int k = 0;
645         int length = view.length();
646 
647         StringBuilder builder;
648         builder.reserveCapacity(length);
649 
650         if (view.is8Bit()) {
651             const LChar* characters = view.characters8();
652             LChar convertedLChar;
653             while (k &lt; length) {
654                 const LChar* c = characters + k;
655                 if (c[0] == &#39;%&#39; &amp;&amp; k &lt;= length - 6 &amp;&amp; c[1] == &#39;u&#39;) {
</pre>
<hr />
<pre>
671 
672             while (k &lt; length) {
673                 const UChar* c = characters + k;
674                 UChar convertedUChar;
675                 if (c[0] == &#39;%&#39; &amp;&amp; k &lt;= length - 6 &amp;&amp; c[1] == &#39;u&#39;) {
676                     if (isASCIIHexDigit(c[2]) &amp;&amp; isASCIIHexDigit(c[3]) &amp;&amp; isASCIIHexDigit(c[4]) &amp;&amp; isASCIIHexDigit(c[5])) {
677                         convertedUChar = Lexer&lt;UChar&gt;::convertUnicode(c[2], c[3], c[4], c[5]);
678                         c = &amp;convertedUChar;
679                         k += 5;
680                     }
681                 } else if (c[0] == &#39;%&#39; &amp;&amp; k &lt;= length - 3 &amp;&amp; isASCIIHexDigit(c[1]) &amp;&amp; isASCIIHexDigit(c[2])) {
682                     convertedUChar = UChar(Lexer&lt;UChar&gt;::convertHex(c[1], c[2]));
683                     c = &amp;convertedUChar;
684                     k += 2;
685                 }
686                 k++;
687                 builder.append(*c);
688             }
689         }
690 
<span class="line-modified">691         return jsString(exec-&gt;vm(), builder.toString());</span>
692     }));
693 }
694 
695 EncodedJSValue JSC_HOST_CALL globalFuncThrowTypeError(ExecState* exec)
696 {
697     VM&amp; vm = exec-&gt;vm();
698     auto scope = DECLARE_THROW_SCOPE(vm);
699     return throwVMTypeError(exec, scope);
700 }
701 
702 EncodedJSValue JSC_HOST_CALL globalFuncThrowTypeErrorArgumentsCalleeAndCaller(ExecState* exec)
703 {
704     VM&amp; vm = exec-&gt;vm();
705     auto scope = DECLARE_THROW_SCOPE(vm);
706     return throwVMTypeError(exec, scope, &quot;&#39;arguments&#39;, &#39;callee&#39;, and &#39;caller&#39; cannot be accessed in this context.&quot;);
707 }
708 
<span class="line-added">709 EncodedJSValue JSC_HOST_CALL globalFuncMakeTypeError(ExecState* exec)</span>
<span class="line-added">710 {</span>
<span class="line-added">711     JSGlobalObject* globalObject = exec-&gt;lexicalGlobalObject();</span>
<span class="line-added">712     Structure* errorStructure = globalObject-&gt;errorStructure(ErrorType::TypeError);</span>
<span class="line-added">713     return JSValue::encode(ErrorInstance::create(exec, errorStructure, exec-&gt;argument(0), nullptr, TypeNothing, false));</span>
<span class="line-added">714 }</span>
<span class="line-added">715 </span>
716 EncodedJSValue JSC_HOST_CALL globalFuncProtoGetter(ExecState* exec)
717 {
718     VM&amp; vm = exec-&gt;vm();
719     auto scope = DECLARE_THROW_SCOPE(vm);
720 
721     JSValue thisValue = exec-&gt;thisValue().toThis(exec, StrictMode);
722     if (thisValue.isUndefinedOrNull())
723         return throwVMError(exec, scope, createNotAnObjectError(exec, thisValue));
724 
725     JSObject* thisObject = jsDynamicCast&lt;JSObject*&gt;(vm, thisValue);
726     if (!thisObject) {
727         JSObject* prototype = thisValue.synthesizePrototype(exec);
728         EXCEPTION_ASSERT(!!scope.exception() == !prototype);
729         if (UNLIKELY(!prototype))
730             return JSValue::encode(JSValue());
731         return JSValue::encode(prototype);
732     }
733 
734     RELEASE_AND_RETURN(scope, JSValue::encode(thisObject-&gt;getPrototype(vm, exec)));
735 }
</pre>
<hr />
<pre>
750     // Setting __proto__ of a primitive should have no effect.
751     if (!thisObject)
752         return JSValue::encode(jsUndefined());
753 
754     // Setting __proto__ to a non-object, non-null value is silently ignored to match Mozilla.
755     if (!value.isObject() &amp;&amp; !value.isNull())
756         return JSValue::encode(jsUndefined());
757 
758     scope.release();
759     bool shouldThrowIfCantSet = true;
760     thisObject-&gt;setPrototype(vm, exec, value, shouldThrowIfCantSet);
761     return JSValue::encode(jsUndefined());
762 }
763 
764 EncodedJSValue JSC_HOST_CALL globalFuncHostPromiseRejectionTracker(ExecState* exec)
765 {
766     JSGlobalObject* globalObject = exec-&gt;lexicalGlobalObject();
767     VM&amp; vm = globalObject-&gt;vm();
768     auto scope = DECLARE_THROW_SCOPE(vm);
769 
<span class="line-modified">770     JSPromise* promise = jsCast&lt;JSPromise*&gt;(exec-&gt;argument(0));</span>
<span class="line-added">771 </span>
<span class="line-added">772     // InternalPromises should not be exposed to user scripts.</span>
<span class="line-added">773     if (jsDynamicCast&lt;JSInternalPromise*&gt;(vm, promise))</span>
774         return JSValue::encode(jsUndefined());
775 

776     JSValue operationValue = exec-&gt;argument(1);
777 
778     ASSERT(operationValue.isNumber());
779     auto operation = static_cast&lt;JSPromiseRejectionOperation&gt;(operationValue.toUInt32(exec));
780     ASSERT(operation == JSPromiseRejectionOperation::Reject || operation == JSPromiseRejectionOperation::Handle);
781     scope.assertNoException();
782 
<span class="line-modified">783     if (globalObject-&gt;globalObjectMethodTable()-&gt;promiseRejectionTracker)</span>
<span class="line-added">784         globalObject-&gt;globalObjectMethodTable()-&gt;promiseRejectionTracker(globalObject, exec, promise, operation);</span>
<span class="line-added">785     else {</span>
<span class="line-added">786         switch (operation) {</span>
<span class="line-added">787         case JSPromiseRejectionOperation::Reject:</span>
<span class="line-added">788             vm.promiseRejected(promise);</span>
<span class="line-added">789             break;</span>
<span class="line-added">790         case JSPromiseRejectionOperation::Handle:</span>
<span class="line-added">791             // do nothing</span>
<span class="line-added">792             break;</span>
<span class="line-added">793         }</span>
<span class="line-added">794     }</span>
795     RETURN_IF_EXCEPTION(scope, { });
796 
797     return JSValue::encode(jsUndefined());
798 }
799 
800 EncodedJSValue JSC_HOST_CALL globalFuncBuiltinLog(ExecState* exec)
801 {
802     dataLog(exec-&gt;argument(0).toWTFString(exec), &quot;\n&quot;);
803     return JSValue::encode(jsUndefined());
804 }
805 
806 EncodedJSValue JSC_HOST_CALL globalFuncBuiltinDescribe(ExecState* exec)
807 {
<span class="line-modified">808     return JSValue::encode(jsString(exec-&gt;vm(), toString(exec-&gt;argument(0))));</span>
809 }
810 
811 EncodedJSValue JSC_HOST_CALL globalFuncImportModule(ExecState* exec)
812 {
813     VM&amp; vm = exec-&gt;vm();
814     auto throwScope = DECLARE_THROW_SCOPE(vm);
815 
816     auto* globalObject = exec-&gt;lexicalGlobalObject();
817 
818     auto* promise = JSPromiseDeferred::tryCreate(exec, globalObject);
819     RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
820 
821     auto catchScope = DECLARE_CATCH_SCOPE(vm);
822     auto reject = [&amp;] (JSValue rejectionReason) {
823         catchScope.clearException();
824         promise-&gt;reject(exec, rejectionReason);
825         catchScope.clearException();
826         return JSValue::encode(promise-&gt;promise());
827     };
828 
</pre>
<hr />
<pre>
843     catchScope.clearException();
844     return JSValue::encode(promise-&gt;promise());
845 }
846 
847 EncodedJSValue JSC_HOST_CALL globalFuncPropertyIsEnumerable(ExecState* exec)
848 {
849     VM&amp; vm = exec-&gt;vm();
850     auto scope = DECLARE_THROW_SCOPE(vm);
851 
852     RELEASE_ASSERT(exec-&gt;argumentCount() == 2);
853     JSObject* object = jsCast&lt;JSObject*&gt;(exec-&gt;uncheckedArgument(0));
854     auto propertyName = exec-&gt;uncheckedArgument(1).toPropertyKey(exec);
855     RETURN_IF_EXCEPTION(scope, encodedJSValue());
856 
857     scope.release();
858     PropertyDescriptor descriptor;
859     bool enumerable = object-&gt;getOwnPropertyDescriptor(exec, propertyName, descriptor) &amp;&amp; descriptor.enumerable();
860     return JSValue::encode(jsBoolean(enumerable));
861 }
862 
<span class="line-added">863 EncodedJSValue JSC_HOST_CALL globalFuncOwnKeys(ExecState* exec)</span>
<span class="line-added">864 {</span>
<span class="line-added">865     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-added">866     auto scope = DECLARE_THROW_SCOPE(vm);</span>
<span class="line-added">867     JSObject* object = exec-&gt;argument(0).toObject(exec);</span>
<span class="line-added">868     RETURN_IF_EXCEPTION(scope, encodedJSValue());</span>
<span class="line-added">869     RELEASE_AND_RETURN(scope, JSValue::encode(ownPropertyKeys(exec, object, PropertyNameMode::StringsAndSymbols, DontEnumPropertiesMode::Include)));</span>
<span class="line-added">870 }</span>
<span class="line-added">871 </span>
872 #if ENABLE(INTL)
873 EncodedJSValue JSC_HOST_CALL globalFuncDateTimeFormat(ExecState* exec)
874 {
875     VM&amp; vm = exec-&gt;vm();
876     auto scope = DECLARE_THROW_SCOPE(vm);
877 
878     JSGlobalObject* globalObject = exec-&gt;lexicalGlobalObject();
879     IntlDateTimeFormat* dateTimeFormat = IntlDateTimeFormat::create(vm, globalObject-&gt;dateTimeFormatStructure());
880     dateTimeFormat-&gt;initializeDateTimeFormat(*exec, exec-&gt;argument(0), exec-&gt;argument(1));
881     RETURN_IF_EXCEPTION(scope, encodedJSValue());
882     double value = exec-&gt;argument(2).toNumber(exec);
883     RETURN_IF_EXCEPTION(scope, encodedJSValue());
884     RELEASE_AND_RETURN(scope, JSValue::encode(dateTimeFormat-&gt;format(*exec, value)));
885 }
886 #endif
887 
888 } // namespace JSC
</pre>
</td>
</tr>
</table>
<center><a href="JSGlobalObject.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="JSGlobalObjectFunctions.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>