<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/displaylists/DisplayListItems.h</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (C) 2015 Apple Inc. All rights reserved.
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  * 1. Redistributions of source code must retain the above copyright
   8  *    notice, this list of conditions and the following disclaimer.
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #pragma once
  27 
  28 #include &quot;FloatPoint.h&quot;
  29 #include &quot;FloatRect.h&quot;
  30 #include &quot;FloatRoundedRect.h&quot;
  31 #include &quot;Font.h&quot;
  32 #include &quot;GlyphBuffer.h&quot;
  33 #include &quot;GraphicsContext.h&quot;
  34 #include &quot;Image.h&quot;
  35 #include &lt;wtf/RefCounted.h&gt;
  36 #include &lt;wtf/TypeCasts.h&gt;
  37 
  38 #if USE(CG)
  39 #include &quot;GraphicsContextPlatformPrivateCG.h&quot;
  40 #endif
  41 
  42 namespace WTF {
  43 class TextStream;
  44 }
  45 
  46 namespace WebCore {
  47 
  48 struct ImagePaintingOptions;
  49 
  50 namespace DisplayList {
  51 
  52 enum class ItemType {
  53     Save,
  54     Restore,
  55     Translate,
  56     Rotate,
  57     Scale,
  58     ConcatenateCTM,
  59     SetState,
  60     SetLineCap,
  61     SetLineDash,
  62     SetLineJoin,
  63     SetMiterLimit,
  64     ClearShadow,
  65     Clip,
  66     ClipOut,
  67     ClipOutToPath,
  68     ClipPath,
  69     DrawGlyphs,
  70     DrawImage,
  71     DrawTiledImage,
  72     DrawTiledScaledImage,
  73 #if USE(CG) || USE(CAIRO) || USE(DIRECT2D)
  74     DrawNativeImage,
  75 #endif
  76     DrawPattern,
  77     DrawRect,
  78     DrawLine,
  79     DrawLinesForText,
  80     DrawDotsForDocumentMarker,
  81     DrawEllipse,
  82     DrawPath,
  83     DrawFocusRingPath,
  84     DrawFocusRingRects,
  85     FillRect,
  86     FillRectWithColor,
  87     FillRectWithGradient,
  88     FillCompositedRect,
  89     FillRoundedRect,
  90     FillRectWithRoundedHole,
  91     FillPath,
  92     FillEllipse,
  93     StrokeRect,
  94     StrokePath,
  95     StrokeEllipse,
  96     ClearRect,
  97     BeginTransparencyLayer,
  98     EndTransparencyLayer,
  99 #if USE(CG)
 100     ApplyStrokePattern, // FIXME: should not be a recorded item.
 101     ApplyFillPattern, // FIXME: should not be a recorded item.
 102 #endif
 103     ApplyDeviceScaleFactor,
 104 };
 105 
 106 class Item : public RefCounted&lt;Item&gt; {
 107 public:
 108     Item() = delete;
 109 
 110     Item(ItemType type)
 111         : m_type(type)
 112     {
 113     }
 114 
 115     virtual ~Item() = default;
 116 
 117     ItemType type() const
 118     {
 119         return m_type;
 120     }
 121 
 122     virtual void apply(GraphicsContext&amp;) const = 0;
 123 
 124     static constexpr bool isDisplayListItem = true;
 125 
 126     virtual bool isDrawingItem() const { return false; }
 127 
 128     // A state item is one preserved by Save/Restore.
 129     bool isStateItem() const
 130     {
 131         return isStateItemType(m_type);
 132     }
 133 
 134     static bool isStateItemType(ItemType itemType)
 135     {
 136         switch (itemType) {
 137         case ItemType:: Translate:
 138         case ItemType:: Rotate:
 139         case ItemType:: Scale:
 140         case ItemType:: ConcatenateCTM:
 141         case ItemType:: SetState:
 142         case ItemType:: SetLineCap:
 143         case ItemType:: SetLineDash:
 144         case ItemType:: SetLineJoin:
 145         case ItemType:: SetMiterLimit:
 146         case ItemType:: ClearShadow:
 147             return true;
 148         default:
 149             return false;
 150         }
 151         return false;
 152     }
 153 
 154 #if !defined(NDEBUG) || !LOG_DISABLED
 155     WTF::CString description() const;
 156 #endif
 157     static size_t sizeInBytes(const Item&amp;);
 158 
 159 private:
 160     ItemType m_type;
 161 };
 162 
 163 class DrawingItem : public Item {
 164 public:
 165     explicit DrawingItem(ItemType type)
 166         : Item(type)
 167     {
 168     }
 169 
 170     void setExtent(const FloatRect&amp; r) { m_extent = r; }
 171     const FloatRect&amp; extent() const { return m_extent.value(); }
 172 
 173     bool extentKnown() const { return static_cast&lt;bool&gt;(m_extent); }
 174 
 175     // Return bounds of this drawing operation in local coordinates.
 176     // Does not include effets of transform, shadow etc in the state.
 177     virtual Optional&lt;FloatRect&gt; localBounds(const GraphicsContext&amp;) const { return WTF::nullopt; }
 178 
 179 private:
 180     bool isDrawingItem() const override { return true; }
 181 
 182     Optional&lt;FloatRect&gt; m_extent; // In base coordinates, taking shadows and transforms into account.
 183 };
 184 
 185 class Save : public Item {
 186 public:
 187     static Ref&lt;Save&gt; create()
 188     {
 189         return adoptRef(*new Save);
 190     }
 191 
 192     // Index in the display list of the corresponding Restore item. 0 if unmatched.
 193     size_t restoreIndex() const { return m_restoreIndex; }
 194     void setRestoreIndex(size_t index) { m_restoreIndex = index; }
 195 
 196 private:
 197     Save()
 198         : Item(ItemType::Save)
 199     {
 200     }
 201 
 202     void apply(GraphicsContext&amp;) const override;
 203 
 204     size_t m_restoreIndex { 0 };
 205 };
 206 
 207 class Restore : public Item {
 208 public:
 209     static Ref&lt;Restore&gt; create()
 210     {
 211         return adoptRef(*new Restore);
 212     }
 213 
 214 private:
 215     Restore()
 216         : Item(ItemType::Restore)
 217     {
 218     }
 219 
 220     void apply(GraphicsContext&amp;) const override;
 221 };
 222 
 223 class Translate : public Item {
 224 public:
 225     static Ref&lt;Translate&gt; create(float x, float y)
 226     {
 227         return adoptRef(*new Translate(x, y));
 228     }
 229 
 230     float x() const { return m_x; }
 231     float y() const { return m_y; }
 232 
 233 private:
 234     Translate(float x, float y)
 235         : Item(ItemType::Translate)
 236         , m_x(x)
 237         , m_y(y)
 238     {
 239     }
 240 
 241     void apply(GraphicsContext&amp;) const override;
 242 
 243     float m_x;
 244     float m_y;
 245 };
 246 
 247 class Rotate : public Item {
 248 public:
 249     static Ref&lt;Rotate&gt; create(float angleInRadians)
 250     {
 251         return adoptRef(*new Rotate(angleInRadians));
 252     }
 253 
 254     float angle() const { return m_angle; }
 255 
 256 private:
 257     Rotate(float angle)
 258         : Item(ItemType::Rotate)
 259         , m_angle(angle)
 260     {
 261     }
 262 
 263     void apply(GraphicsContext&amp;) const override;
 264 
 265     float m_angle; // In radians.
 266 };
 267 
 268 class Scale : public Item {
 269 public:
 270     static Ref&lt;Scale&gt; create(const FloatSize&amp; size)
 271     {
 272         return adoptRef(*new Scale(size));
 273     }
 274 
 275     const FloatSize&amp; amount() const { return m_size; }
 276 
 277 private:
 278     Scale(const FloatSize&amp; size)
 279         : Item(ItemType::Scale)
 280         , m_size(size)
 281     {
 282     }
 283 
 284     void apply(GraphicsContext&amp;) const override;
 285 
 286     FloatSize m_size;
 287 };
 288 
 289 class ConcatenateCTM : public Item {
 290 public:
 291     static Ref&lt;ConcatenateCTM&gt; create(const AffineTransform&amp; matrix)
 292     {
 293         return adoptRef(*new ConcatenateCTM(matrix));
 294     }
 295 
 296     const AffineTransform&amp; transform() const { return m_transform; }
 297 
 298 private:
 299     ConcatenateCTM(const AffineTransform&amp;);
 300 
 301     void apply(GraphicsContext&amp;) const override;
 302 
 303     AffineTransform m_transform;
 304 };
 305 
 306 class SetState : public Item {
 307 public:
 308     static Ref&lt;SetState&gt; create(const GraphicsContextState&amp; state, GraphicsContextState::StateChangeFlags flags)
 309     {
 310         return adoptRef(*new SetState(state, flags));
 311     }
 312 
 313     const GraphicsContextStateChange&amp; state() const { return m_state; }
 314 
 315     void accumulate(const GraphicsContextState&amp;, GraphicsContextState::StateChangeFlags);
 316 
 317     void accumulate(GraphicsContextState&amp;) const;
 318 
 319     static void applyState(GraphicsContext&amp;, const GraphicsContextState&amp;, GraphicsContextState::StateChangeFlags);
 320 
 321     static void dumpStateChanges(WTF::TextStream&amp;, const GraphicsContextState&amp;, GraphicsContextState::StateChangeFlags);
 322 private:
 323     SetState(const GraphicsContextState&amp; state, GraphicsContextState::StateChangeFlags flags)
 324         : Item(ItemType::SetState)
 325         , m_state(state, flags)
 326     {
 327     }
 328 
 329     void apply(GraphicsContext&amp;) const override;
 330 
 331     GraphicsContextStateChange m_state;
 332 };
 333 
 334 class SetLineCap : public Item {
 335 public:
 336     static Ref&lt;SetLineCap&gt; create(LineCap lineCap)
 337     {
 338         return adoptRef(*new SetLineCap(lineCap));
 339     }
 340 
 341     LineCap lineCap() const { return m_lineCap; }
 342 
 343 private:
 344     SetLineCap(LineCap lineCap)
 345         : Item(ItemType::SetLineCap)
 346         , m_lineCap(lineCap)
 347     {
 348     }
 349 
 350     void apply(GraphicsContext&amp;) const override;
 351 
 352     LineCap m_lineCap;
 353 };
 354 
 355 class SetLineDash : public Item {
 356 public:
 357     static Ref&lt;SetLineDash&gt; create(const DashArray&amp; dashArray, float dashOffset)
 358     {
 359         return adoptRef(*new SetLineDash(dashArray, dashOffset));
 360     }
 361 
 362     const DashArray&amp; dashArray() const { return m_dashArray; }
 363     float dashOffset() const { return m_dashOffset; }
 364 
 365 private:
 366     SetLineDash(const DashArray&amp; dashArray, float dashOffset)
 367         : Item(ItemType::SetLineDash)
 368         , m_dashArray(dashArray)
 369         , m_dashOffset(dashOffset)
 370     {
 371     }
 372 
 373     void apply(GraphicsContext&amp;) const override;
 374 
 375     DashArray m_dashArray;
 376     float m_dashOffset;
 377 };
 378 
 379 class SetLineJoin : public Item {
 380 public:
 381     static Ref&lt;SetLineJoin&gt; create(LineJoin lineJoin)
 382     {
 383         return adoptRef(*new SetLineJoin(lineJoin));
 384     }
 385 
 386     LineJoin lineJoin() const { return m_lineJoin; }
 387 
 388 private:
 389     SetLineJoin(LineJoin lineJoin)
 390         : Item(ItemType::SetLineJoin)
 391         , m_lineJoin(lineJoin)
 392     {
 393     }
 394 
 395     void apply(GraphicsContext&amp;) const override;
 396 
 397     LineJoin m_lineJoin;
 398 };
 399 
 400 class SetMiterLimit : public Item {
 401 public:
 402     static Ref&lt;SetMiterLimit&gt; create(float limit)
 403     {
 404         return adoptRef(*new SetMiterLimit(limit));
 405     }
 406 
 407     float miterLimit() const { return m_miterLimit; }
 408 
 409 private:
 410     SetMiterLimit(float miterLimit)
 411         : Item(ItemType::SetMiterLimit)
 412         , m_miterLimit(miterLimit)
 413     {
 414     }
 415 
 416     void apply(GraphicsContext&amp;) const override;
 417 
 418     float m_miterLimit;
 419 };
 420 
 421 class ClearShadow : public Item {
 422 public:
 423     static Ref&lt;ClearShadow&gt; create()
 424     {
 425         return adoptRef(*new ClearShadow);
 426     }
 427 
 428 private:
 429     ClearShadow()
 430         : Item(ItemType::ClearShadow)
 431     {
 432     }
 433 
 434     void apply(GraphicsContext&amp;) const override;
 435 };
 436 
 437 // FIXME: treat as DrawingItem?
 438 class Clip : public Item {
 439 public:
 440     static Ref&lt;Clip&gt; create(const FloatRect&amp; rect)
 441     {
 442         return adoptRef(*new Clip(rect));
 443     }
 444 
 445     FloatRect rect() const { return m_rect; }
 446 
 447 private:
 448     Clip(const FloatRect&amp; rect)
 449         : Item(ItemType::Clip)
 450         , m_rect(rect)
 451     {
 452     }
 453 
 454     void apply(GraphicsContext&amp;) const override;
 455 
 456     FloatRect m_rect;
 457 };
 458 
 459 class ClipOut : public Item {
 460 public:
 461     static Ref&lt;ClipOut&gt; create(const FloatRect&amp; rect)
 462     {
 463         return adoptRef(*new ClipOut(rect));
 464     }
 465 
 466     FloatRect rect() const { return m_rect; }
 467 
 468 private:
 469     ClipOut(const FloatRect&amp; rect)
 470         : Item(ItemType::ClipOut)
 471         , m_rect(rect)
 472     {
 473     }
 474 
 475     void apply(GraphicsContext&amp;) const override;
 476 
 477     FloatRect m_rect;
 478 };
 479 
 480 class ClipOutToPath : public Item {
 481 public:
 482     static Ref&lt;ClipOutToPath&gt; create(const Path&amp; path)
 483     {
 484         return adoptRef(*new ClipOutToPath(path));
 485     }
 486 
 487     const Path&amp; path() const { return m_path; }
 488 
 489 private:
 490     ClipOutToPath(const Path&amp; path)
 491         : Item(ItemType::ClipOutToPath)
 492         , m_path(path)
 493     {
 494     }
 495 
 496     void apply(GraphicsContext&amp;) const override;
 497 
 498     const Path m_path;
 499 };
 500 
 501 class ClipPath : public Item {
 502 public:
 503     static Ref&lt;ClipPath&gt; create(const Path&amp; path, WindRule windRule)
 504     {
 505         return adoptRef(*new ClipPath(path, windRule));
 506     }
 507 
 508     const Path&amp; path() const { return m_path; }
 509     WindRule windRule() const { return m_windRule; }
 510 
 511 private:
 512     ClipPath(const Path&amp; path, WindRule windRule)
 513         : Item(ItemType::ClipPath)
 514         , m_path(path)
 515         , m_windRule(windRule)
 516     {
 517     }
 518 
 519     void apply(GraphicsContext&amp;) const override;
 520 
 521     const Path m_path;
 522     WindRule m_windRule;
 523 };
 524 
 525 class DrawGlyphs : public DrawingItem {
 526 public:
 527     static Ref&lt;DrawGlyphs&gt; create(const Font&amp; font, const GlyphBufferGlyph* glyphs, const GlyphBufferAdvance* advances, unsigned count, const FloatPoint&amp; blockLocation, const FloatSize&amp; localAnchor, FontSmoothingMode smoothingMode)
 528     {
 529         return adoptRef(*new DrawGlyphs(font, glyphs, advances, count, blockLocation, localAnchor, smoothingMode));
 530     }
 531 
 532     const FloatPoint&amp; blockLocation() const { return m_blockLocation; }
 533     void setBlockLocation(const FloatPoint&amp; blockLocation) { m_blockLocation = blockLocation; }
 534 
 535     const FloatSize&amp; localAnchor() const { return m_localAnchor; }
 536 
 537     FloatPoint anchorPoint() const { return m_blockLocation + m_localAnchor; }
 538 
 539     const Vector&lt;GlyphBufferGlyph, 128&gt;&amp; glyphs() const { return m_glyphs; }
 540 
 541 private:
 542     DrawGlyphs(const Font&amp;, const GlyphBufferGlyph*, const GlyphBufferAdvance*, unsigned count, const FloatPoint&amp; blockLocation, const FloatSize&amp; localAnchor, FontSmoothingMode);
 543 
 544     void computeBounds();
 545 
 546     void apply(GraphicsContext&amp;) const override;
 547 
 548     Optional&lt;FloatRect&gt; localBounds(const GraphicsContext&amp;) const override;
 549 
 550     GlyphBuffer generateGlyphBuffer() const;
 551 
 552     Ref&lt;Font&gt; m_font;
 553     Vector&lt;GlyphBufferGlyph, 128&gt; m_glyphs;
 554     Vector&lt;GlyphBufferAdvance, 128&gt; m_advances;
 555     FloatRect m_bounds;
 556     FloatPoint m_blockLocation;
 557     FloatSize m_localAnchor;
 558     FontSmoothingMode m_smoothingMode;
 559 };
 560 
 561 class DrawImage : public DrawingItem {
 562 public:
 563     static Ref&lt;DrawImage&gt; create(Image&amp; image, const FloatRect&amp; destination, const FloatRect&amp; source, const ImagePaintingOptions&amp; imagePaintingOptions)
 564     {
 565         return adoptRef(*new DrawImage(image, destination, source, imagePaintingOptions));
 566     }
 567 
 568     const Image&amp; image() const { return m_image.get(); }
 569     FloatRect source() const { return m_source; }
 570     FloatRect destination() const { return m_destination; }
 571 
 572 private:
 573     DrawImage(Image&amp;, const FloatRect&amp; destination, const FloatRect&amp; source, const ImagePaintingOptions&amp;);
 574 
 575     void apply(GraphicsContext&amp;) const override;
 576 
 577     Optional&lt;FloatRect&gt; localBounds(const GraphicsContext&amp;) const override { return m_destination; }
 578 
 579     mutable Ref&lt;Image&gt; m_image; // FIXME: Drawing images can cause their animations to progress. This shouldn&#39;t have to be mutable.
 580     FloatRect m_destination;
 581     FloatRect m_source;
 582     ImagePaintingOptions m_imagePaintingOptions;
 583 };
 584 
 585 class DrawTiledImage : public DrawingItem {
 586 public:
 587     static Ref&lt;DrawTiledImage&gt; create(Image&amp; image, const FloatRect&amp; destination, const FloatPoint&amp; source, const FloatSize&amp; tileSize, const FloatSize&amp; spacing, const ImagePaintingOptions&amp; imagePaintingOptions)
 588     {
 589         return adoptRef(*new DrawTiledImage(image, destination, source, tileSize, spacing, imagePaintingOptions));
 590     }
 591 
 592     const Image&amp; image() const { return m_image.get(); }
 593     FloatPoint source() const { return m_source; }
 594     FloatRect destination() const { return m_destination; }
 595 
 596     FloatSize tileSize() const { return m_tileSize; }
 597     FloatSize spacing() const { return m_spacing; }
 598 
 599 private:
 600     DrawTiledImage(Image&amp;, const FloatRect&amp; destination, const FloatPoint&amp; source, const FloatSize&amp; tileSize, const FloatSize&amp; spacing, const ImagePaintingOptions&amp;);
 601 
 602     void apply(GraphicsContext&amp;) const override;
 603 
 604     Optional&lt;FloatRect&gt; localBounds(const GraphicsContext&amp;) const override { return m_destination; }
 605 
 606     mutable Ref&lt;Image&gt; m_image; // FIXME: Drawing images can cause their animations to progress. This shouldn&#39;t have to be mutable.
 607     FloatRect m_destination;
 608     FloatPoint m_source;
 609     FloatSize m_tileSize;
 610     FloatSize m_spacing;
 611     ImagePaintingOptions m_imagePaintingOptions;
 612 };
 613 
 614 class DrawTiledScaledImage : public DrawingItem {
 615 public:
 616     static Ref&lt;DrawTiledScaledImage&gt; create(Image&amp; image, const FloatRect&amp; destination, const FloatRect&amp; source, const FloatSize&amp; tileScaleFactor, Image::TileRule hRule, Image::TileRule vRule, const ImagePaintingOptions&amp; imagePaintingOptions)
 617     {
 618         return adoptRef(*new DrawTiledScaledImage(image, destination, source, tileScaleFactor, hRule, vRule, imagePaintingOptions));
 619     }
 620 
 621     const Image&amp; image() const { return m_image.get(); }
 622     FloatRect source() const { return m_source; }
 623     FloatRect destination() const { return m_destination; }
 624 
 625 private:
 626     DrawTiledScaledImage(Image&amp;, const FloatRect&amp; destination, const FloatRect&amp; source, const FloatSize&amp; tileScaleFactor, Image::TileRule hRule, Image::TileRule vRule, const ImagePaintingOptions&amp;);
 627 
 628     void apply(GraphicsContext&amp;) const override;
 629 
 630     Optional&lt;FloatRect&gt; localBounds(const GraphicsContext&amp;) const override { return m_destination; }
 631 
 632     mutable Ref&lt;Image&gt; m_image; // FIXME: Drawing images can cause their animations to progress. This shouldn&#39;t have to be mutable.
 633     FloatRect m_destination;
 634     FloatRect m_source;
 635     FloatSize m_tileScaleFactor;
 636     Image::TileRule m_hRule;
 637     Image::TileRule m_vRule;
 638     ImagePaintingOptions m_imagePaintingOptions;
 639 };
 640 
 641 #if USE(CG) || USE(CAIRO) || USE(DIRECT2D)
 642 class DrawNativeImage : public DrawingItem {
 643 public:
 644     static Ref&lt;DrawNativeImage&gt; create(const NativeImagePtr&amp; image, const FloatSize&amp; imageSize, const FloatRect&amp; destRect, const FloatRect&amp; srcRect, const ImagePaintingOptions&amp; options)
 645     {
 646         return adoptRef(*new DrawNativeImage(image, imageSize, destRect, srcRect, options));
 647     }
 648 
 649     FloatRect source() const { return m_srcRect; }
 650     FloatRect destination() const { return m_destination; }
 651 
 652 private:
 653     DrawNativeImage(const NativeImagePtr&amp;, const FloatSize&amp; selfSize, const FloatRect&amp; destRect, const FloatRect&amp; srcRect, const ImagePaintingOptions&amp;);
 654 
 655     void apply(GraphicsContext&amp;) const override;
 656 
 657     Optional&lt;FloatRect&gt; localBounds(const GraphicsContext&amp;) const override { return m_destination; }
 658 
 659 #if USE(CG)
 660     RetainPtr&lt;CGImageRef&gt; m_image;
 661 #endif
 662     FloatSize m_imageSize;
 663     FloatRect m_destination;
 664     FloatRect m_srcRect;
 665     ImagePaintingOptions m_options;
 666 };
 667 #endif
 668 
 669 class DrawPattern : public DrawingItem {
 670 public:
 671     static Ref&lt;DrawPattern&gt; create(Image&amp; image, const FloatRect&amp; destRect, const FloatRect&amp; tileRect, const AffineTransform&amp; patternTransform, const FloatPoint&amp; phase, const FloatSize&amp; spacing, const ImagePaintingOptions&amp; options)
 672     {
 673         return adoptRef(*new DrawPattern(image, destRect, tileRect, patternTransform, phase, spacing, options));
 674     }
 675 
 676     const Image&amp; image() const { return m_image.get(); }
 677     const AffineTransform&amp; patternTransform() const { return m_patternTransform; }
 678     FloatRect tileRect() const { return m_tileRect; }
 679     FloatRect destRect() const { return m_destination; }
 680     FloatPoint phase() const { return m_phase; }
 681     FloatSize spacing() const { return m_spacing; }
 682 
 683 private:
 684     DrawPattern(Image&amp;, const FloatRect&amp; destRect, const FloatRect&amp; srcRect, const AffineTransform&amp;, const FloatPoint&amp; phase, const FloatSize&amp; spacing, const ImagePaintingOptions&amp; = { });
 685 
 686     void apply(GraphicsContext&amp;) const override;
 687 
 688     Optional&lt;FloatRect&gt; localBounds(const GraphicsContext&amp;) const override { return m_destination; }
 689 
 690     mutable Ref&lt;Image&gt; m_image; // FIXME: Drawing images can cause their animations to progress. This shouldn&#39;t have to be mutable.
 691     AffineTransform m_patternTransform;
 692     FloatRect m_tileRect;
 693     FloatRect m_destination;
 694     FloatPoint m_phase;
 695     FloatSize m_spacing;
 696     ImagePaintingOptions m_options;
 697 };
 698 
 699 // Is DrawingItem because the size of the transparency layer is implicitly the clip bounds.
 700 class BeginTransparencyLayer : public DrawingItem {
 701 public:
 702     static Ref&lt;BeginTransparencyLayer&gt; create(float opacity)
 703     {
 704         return adoptRef(*new BeginTransparencyLayer(opacity));
 705     }
 706 
 707     float opacity() const { return m_opacity; }
 708 
 709 private:
 710     BeginTransparencyLayer(float opacity)
 711         : DrawingItem(ItemType::BeginTransparencyLayer)
 712         , m_opacity(opacity)
 713     {
 714     }
 715 
 716     void apply(GraphicsContext&amp;) const override;
 717 
 718     float m_opacity;
 719 };
 720 
 721 class EndTransparencyLayer : public DrawingItem {
 722 public:
 723     static Ref&lt;EndTransparencyLayer&gt; create()
 724     {
 725         return adoptRef(*new EndTransparencyLayer);
 726     }
 727 
 728 private:
 729     EndTransparencyLayer()
 730         : DrawingItem(ItemType::EndTransparencyLayer)
 731     {
 732     }
 733 
 734     void apply(GraphicsContext&amp;) const override;
 735 };
 736 
 737 class DrawRect : public DrawingItem {
 738 public:
 739     static Ref&lt;DrawRect&gt; create(const FloatRect&amp; rect, float borderThickness)
 740     {
 741         return adoptRef(*new DrawRect(rect, borderThickness));
 742     }
 743 
 744     FloatRect rect() const { return m_rect; }
 745     float borderThickness() const { return m_borderThickness; }
 746 
 747 private:
 748     DrawRect(const FloatRect&amp; rect, float borderThickness)
 749         : DrawingItem(ItemType::DrawRect)
 750         , m_rect(rect)
 751         , m_borderThickness(borderThickness)
 752     {
 753     }
 754 
 755     void apply(GraphicsContext&amp;) const override;
 756     Optional&lt;FloatRect&gt; localBounds(const GraphicsContext&amp;) const override { return m_rect; }
 757 
 758     FloatRect m_rect;
 759     float m_borderThickness;
 760 };
 761 
 762 class DrawLine : public DrawingItem {
 763 public:
 764     static Ref&lt;DrawLine&gt; create(const FloatPoint&amp; point1, const FloatPoint&amp; point2)
 765     {
 766         return adoptRef(*new DrawLine(point1, point2));
 767     }
 768 
 769     FloatPoint point1() const { return m_point1; }
 770     FloatPoint point2() const { return m_point2; }
 771 
 772 private:
 773     DrawLine(const FloatPoint&amp; point1, const FloatPoint&amp; point2)
 774         : DrawingItem(ItemType::DrawLine)
 775         , m_point1(point1)
 776         , m_point2(point2)
 777     {
 778     }
 779 
 780     void apply(GraphicsContext&amp;) const override;
 781     Optional&lt;FloatRect&gt; localBounds(const GraphicsContext&amp;) const override;
 782 
 783     FloatPoint m_point1;
 784     FloatPoint m_point2;
 785 };
 786 
 787 class DrawLinesForText : public DrawingItem {
 788 public:
 789     static Ref&lt;DrawLinesForText&gt; create(const FloatPoint&amp; blockLocation, const FloatSize&amp; localAnchor, float thickness, const DashArray&amp; widths, bool printing, bool doubleLines)
 790     {
 791         return adoptRef(*new DrawLinesForText(blockLocation, localAnchor, thickness, widths, printing, doubleLines));
 792     }
 793 
 794     void setBlockLocation(const FloatPoint&amp; blockLocation) { m_blockLocation = blockLocation; }
 795     const FloatPoint&amp; blockLocation() const { return m_blockLocation; }
 796     const FloatSize&amp; localAnchor() const { return m_localAnchor; }
 797     FloatPoint point() const { return m_blockLocation + m_localAnchor; }
 798     float thickness() const { return m_thickness; }
 799     const DashArray&amp; widths() const { return m_widths; }
 800     bool isPrinting() const { return m_printing; }
 801     bool doubleLines() const { return m_doubleLines; }
 802 
 803 private:
 804     DrawLinesForText(const FloatPoint&amp; blockLocation, const FloatSize&amp; localAnchor, float thickness, const DashArray&amp; widths, bool printing, bool doubleLines)
 805         : DrawingItem(ItemType::DrawLinesForText)
 806         , m_blockLocation(blockLocation)
 807         , m_localAnchor(localAnchor)
 808         , m_widths(widths)
 809         , m_thickness(thickness)
 810         , m_printing(printing)
 811         , m_doubleLines(doubleLines)
 812     {
 813     }
 814 
 815     void apply(GraphicsContext&amp;) const override;
 816 
 817     Optional&lt;FloatRect&gt; localBounds(const GraphicsContext&amp;) const override;
 818 
 819     FloatPoint m_blockLocation;
 820     FloatSize m_localAnchor;
 821     DashArray m_widths;
 822     float m_thickness;
 823     bool m_printing;
 824     bool m_doubleLines;
 825 };
 826 
 827 class DrawDotsForDocumentMarker : public DrawingItem {
 828 public:
 829     static Ref&lt;DrawDotsForDocumentMarker&gt; create(const FloatRect&amp; rect, DocumentMarkerLineStyle style)
 830     {
 831         return adoptRef(*new DrawDotsForDocumentMarker(rect, style));
 832     }
 833 
 834     FloatRect rect() const { return m_rect; }
 835 
 836 private:
 837     DrawDotsForDocumentMarker(const FloatRect&amp; rect, DocumentMarkerLineStyle style)
 838         : DrawingItem(ItemType::DrawDotsForDocumentMarker)
 839         , m_rect(rect)
 840         , m_style(style)
 841     {
 842     }
 843 
 844     void apply(GraphicsContext&amp;) const override;
 845 
 846     Optional&lt;FloatRect&gt; localBounds(const GraphicsContext&amp;) const override;
 847 
 848     FloatRect m_rect;
 849     DocumentMarkerLineStyle m_style;
 850 };
 851 
 852 class DrawEllipse : public DrawingItem {
 853 public:
 854     static Ref&lt;DrawEllipse&gt; create(const FloatRect&amp; rect)
 855     {
 856         return adoptRef(*new DrawEllipse(rect));
 857     }
 858 
 859     FloatRect rect() const { return m_rect; }
 860 
 861 private:
 862     DrawEllipse(const FloatRect&amp; rect)
 863         : DrawingItem(ItemType::DrawEllipse)
 864         , m_rect(rect)
 865     {
 866     }
 867 
 868     void apply(GraphicsContext&amp;) const override;
 869     Optional&lt;FloatRect&gt; localBounds(const GraphicsContext&amp;) const override { return m_rect; }
 870 
 871     FloatRect m_rect;
 872 };
 873 
 874 class DrawPath : public DrawingItem {
 875 public:
 876     static Ref&lt;DrawPath&gt; create(const Path&amp; path)
 877     {
 878         return adoptRef(*new DrawPath(path));
 879     }
 880 
 881     const Path&amp; path() const { return m_path; }
 882 
 883 private:
 884     DrawPath(const Path&amp; path)
 885         : DrawingItem(ItemType::DrawPath)
 886         , m_path(path)
 887     {
 888     }
 889 
 890     void apply(GraphicsContext&amp;) const override;
 891 
 892     Optional&lt;FloatRect&gt; localBounds(const GraphicsContext&amp;) const override { return m_path.fastBoundingRect(); }
 893 
 894     const Path m_path;
 895 };
 896 
 897 class DrawFocusRingPath : public DrawingItem {
 898 public:
 899     static Ref&lt;DrawFocusRingPath&gt; create(const Path&amp; path, float width, float offset, const Color&amp; color)
 900     {
 901         return adoptRef(*new DrawFocusRingPath(path, width, offset, color));
 902     }
 903 
 904     const Path&amp; path() const { return m_path; }
 905     float width() const { return m_width; }
 906     float offset() const { return m_offset; }
 907     const Color&amp; color() const { return m_color; }
 908 
 909 private:
 910     DrawFocusRingPath(const Path&amp; path, float width, float offset, const Color&amp; color)
 911         : DrawingItem(ItemType::DrawFocusRingPath)
 912         , m_path(path)
 913         , m_width(width)
 914         , m_offset(offset)
 915         , m_color(color)
 916     {
 917     }
 918 
 919     void apply(GraphicsContext&amp;) const override;
 920 
 921     Optional&lt;FloatRect&gt; localBounds(const GraphicsContext&amp;) const override;
 922 
 923     const Path m_path;
 924     float m_width;
 925     float m_offset;
 926     Color m_color;
 927 };
 928 
 929 class DrawFocusRingRects : public DrawingItem {
 930 public:
 931     static Ref&lt;DrawFocusRingRects&gt; create(const Vector&lt;FloatRect&gt;&amp; rects, float width, float offset, const Color&amp; color)
 932     {
 933         return adoptRef(*new DrawFocusRingRects(rects, width, offset, color));
 934     }
 935 
 936     const Vector&lt;FloatRect&gt; rects() const { return m_rects; }
 937     float width() const { return m_width; }
 938     float offset() const { return m_offset; }
 939     const Color&amp; color() const { return m_color; }
 940 
 941 private:
 942     DrawFocusRingRects(const Vector&lt;FloatRect&gt;&amp; rects, float width, float offset, const Color&amp; color)
 943         : DrawingItem(ItemType::DrawFocusRingRects)
 944         , m_rects(rects)
 945         , m_width(width)
 946         , m_offset(offset)
 947         , m_color(color)
 948     {
 949     }
 950 
 951     void apply(GraphicsContext&amp;) const override;
 952 
 953     Optional&lt;FloatRect&gt; localBounds(const GraphicsContext&amp;) const override;
 954 
 955     Vector&lt;FloatRect&gt; m_rects;
 956     float m_width;
 957     float m_offset;
 958     Color m_color;
 959 };
 960 
 961 class FillRect : public DrawingItem {
 962 public:
 963     static Ref&lt;FillRect&gt; create(const FloatRect&amp; rect)
 964     {
 965         return adoptRef(*new FillRect(rect));
 966     }
 967 
 968     FloatRect rect() const { return m_rect; }
 969 
 970 private:
 971     FillRect(const FloatRect&amp; rect)
 972         : DrawingItem(ItemType::FillRect)
 973         , m_rect(rect)
 974     {
 975     }
 976 
 977     void apply(GraphicsContext&amp;) const override;
 978     Optional&lt;FloatRect&gt; localBounds(const GraphicsContext&amp;) const override { return m_rect; }
 979 
 980     FloatRect m_rect;
 981 };
 982 
 983 // FIXME: Make these inherit from FillRect proper.
 984 class FillRectWithColor : public DrawingItem {
 985 public:
 986     static Ref&lt;FillRectWithColor&gt; create(const FloatRect&amp; rect, const Color&amp; color)
 987     {
 988         return adoptRef(*new FillRectWithColor(rect, color));
 989     }
 990 
 991     FloatRect rect() const { return m_rect; }
 992     const Color&amp; color() const { return m_color; }
 993 
 994 private:
 995     FillRectWithColor(const FloatRect&amp; rect, const Color&amp; color)
 996         : DrawingItem(ItemType::FillRectWithColor)
 997         , m_rect(rect)
 998         , m_color(color)
 999     {
1000     }
1001 
1002     void apply(GraphicsContext&amp;) const override;
1003     Optional&lt;FloatRect&gt; localBounds(const GraphicsContext&amp;) const override { return m_rect; }
1004 
1005     FloatRect m_rect;
1006     Color m_color;
1007 };
1008 
1009 class FillRectWithGradient : public DrawingItem {
1010 public:
1011     static Ref&lt;FillRectWithGradient&gt; create(const FloatRect&amp; rect, Gradient&amp; gradient)
1012     {
1013         return adoptRef(*new FillRectWithGradient(rect, gradient));
1014     }
1015 
1016     FloatRect rect() const { return m_rect; }
1017 
1018 private:
1019     FillRectWithGradient(const FloatRect&amp; rect, Gradient&amp; gradient)
1020         : DrawingItem(ItemType::FillRectWithGradient)
1021         , m_rect(rect)
1022         , m_gradient(gradient)
1023     {
1024     }
1025 
1026     void apply(GraphicsContext&amp;) const override;
1027     Optional&lt;FloatRect&gt; localBounds(const GraphicsContext&amp;) const override { return m_rect; }
1028 
1029     FloatRect m_rect;
1030     mutable Ref&lt;Gradient&gt; m_gradient; // FIXME: Make this not mutable
1031 };
1032 
1033 class FillCompositedRect : public DrawingItem {
1034 public:
1035     static Ref&lt;FillCompositedRect&gt; create(const FloatRect&amp; rect, const Color&amp; color, CompositeOperator op, BlendMode blendMode)
1036     {
1037         return adoptRef(*new FillCompositedRect(rect, color, op, blendMode));
1038     }
1039 
1040     FloatRect rect() const { return m_rect; }
1041     const Color&amp; color() const { return m_color; }
1042     CompositeOperator compositeOperator() const { return m_op; }
1043     BlendMode blendMode() const { return m_blendMode; }
1044 
1045 private:
1046     FillCompositedRect(const FloatRect&amp; rect, const Color&amp; color, CompositeOperator op, BlendMode blendMode)
1047         : DrawingItem(ItemType::FillCompositedRect)
1048         , m_rect(rect)
1049         , m_color(color)
1050         , m_op(op)
1051         , m_blendMode(blendMode)
1052     {
1053     }
1054 
1055     void apply(GraphicsContext&amp;) const override;
1056     Optional&lt;FloatRect&gt; localBounds(const GraphicsContext&amp;) const override { return m_rect; }
1057 
1058     FloatRect m_rect;
1059     Color m_color;
1060     CompositeOperator m_op;
1061     BlendMode m_blendMode;
1062 };
1063 
1064 class FillRoundedRect : public DrawingItem {
1065 public:
1066     static Ref&lt;FillRoundedRect&gt; create(const FloatRoundedRect&amp; rect, const Color&amp; color, BlendMode blendMode)
1067     {
1068         return adoptRef(*new FillRoundedRect(rect, color, blendMode));
1069     }
1070 
1071     const FloatRoundedRect&amp; roundedRect() const { return m_rect; }
1072     const Color&amp; color() const { return m_color; }
1073     BlendMode blendMode() const { return m_blendMode; }
1074 
1075 private:
1076     FillRoundedRect(const FloatRoundedRect&amp; rect, const Color&amp; color, BlendMode blendMode)
1077         : DrawingItem(ItemType::FillRoundedRect)
1078         , m_rect(rect)
1079         , m_color(color)
1080         , m_blendMode(blendMode)
1081     {
1082     }
1083 
1084     void apply(GraphicsContext&amp;) const override;
1085     Optional&lt;FloatRect&gt; localBounds(const GraphicsContext&amp;) const override { return m_rect.rect(); }
1086 
1087     FloatRoundedRect m_rect;
1088     Color m_color;
1089     BlendMode m_blendMode;
1090 };
1091 
1092 class FillRectWithRoundedHole : public DrawingItem {
1093 public:
1094     static Ref&lt;FillRectWithRoundedHole&gt; create(const FloatRect&amp; rect, const FloatRoundedRect&amp; roundedHoleRect, const Color&amp; color)
1095     {
1096         return adoptRef(*new FillRectWithRoundedHole(rect, roundedHoleRect, color));
1097     }
1098 
1099     const FloatRect&amp; rect() const { return m_rect; }
1100     const FloatRoundedRect&amp; roundedHoleRect() const { return m_roundedHoleRect; }
1101     const Color&amp; color() const { return m_color; }
1102 
1103 private:
1104     FillRectWithRoundedHole(const FloatRect&amp; rect, const FloatRoundedRect&amp; roundedHoleRect, const Color&amp; color)
1105         : DrawingItem(ItemType::FillRectWithRoundedHole)
1106         , m_rect(rect)
1107         , m_roundedHoleRect(roundedHoleRect)
1108         , m_color(color)
1109     {
1110     }
1111 
1112     void apply(GraphicsContext&amp;) const override;
1113     Optional&lt;FloatRect&gt; localBounds(const GraphicsContext&amp;) const override { return m_rect; }
1114 
1115     FloatRect m_rect;
1116     FloatRoundedRect m_roundedHoleRect;
1117     Color m_color;
1118 };
1119 
1120 class FillPath : public DrawingItem {
1121 public:
1122     static Ref&lt;FillPath&gt; create(const Path&amp; path)
1123     {
1124         return adoptRef(*new FillPath(path));
1125     }
1126 
1127     const Path&amp; path() const { return m_path; }
1128 
1129 private:
1130     FillPath(const Path&amp; path)
1131         : DrawingItem(ItemType::FillPath)
1132         , m_path(path)
1133     {
1134     }
1135 
1136     void apply(GraphicsContext&amp;) const override;
1137     Optional&lt;FloatRect&gt; localBounds(const GraphicsContext&amp;) const override { return m_path.fastBoundingRect(); }
1138 
1139     const Path m_path;
1140 };
1141 
1142 class FillEllipse : public DrawingItem {
1143 public:
1144     static Ref&lt;FillEllipse&gt; create(const FloatRect&amp; rect)
1145     {
1146         return adoptRef(*new FillEllipse(rect));
1147     }
1148 
1149     FloatRect rect() const { return m_rect; }
1150 
1151 private:
1152     FillEllipse(const FloatRect&amp; rect)
1153         : DrawingItem(ItemType::FillEllipse)
1154         , m_rect(rect)
1155     {
1156     }
1157 
1158     void apply(GraphicsContext&amp;) const override;
1159 
1160     Optional&lt;FloatRect&gt; localBounds(const GraphicsContext&amp;) const override { return m_rect; }
1161 
1162     FloatRect m_rect;
1163 };
1164 
1165 class StrokeRect : public DrawingItem {
1166 public:
1167     static Ref&lt;StrokeRect&gt; create(const FloatRect&amp; rect, float lineWidth)
1168     {
1169         return adoptRef(*new StrokeRect(rect, lineWidth));
1170     }
1171 
1172     FloatRect rect() const { return m_rect; }
1173     float lineWidth() const { return m_lineWidth; }
1174 
1175 private:
1176     StrokeRect(const FloatRect&amp; rect, float lineWidth)
1177         : DrawingItem(ItemType::StrokeRect)
1178         , m_rect(rect)
1179         , m_lineWidth(lineWidth)
1180     {
1181     }
1182 
1183     void apply(GraphicsContext&amp;) const override;
1184     Optional&lt;FloatRect&gt; localBounds(const GraphicsContext&amp;) const override;
1185 
1186     FloatRect m_rect;
1187     float m_lineWidth;
1188 };
1189 
1190 class StrokePath : public DrawingItem {
1191 public:
1192     static Ref&lt;StrokePath&gt; create(const Path&amp; path)
1193     {
1194         return adoptRef(*new StrokePath(path));
1195     }
1196 
1197     const Path&amp; path() const { return m_path; }
1198 
1199 private:
1200     StrokePath(const Path&amp; path)
1201         : DrawingItem(ItemType::StrokePath)
1202         , m_path(path)
1203     {
1204     }
1205 
1206     void apply(GraphicsContext&amp;) const override;
1207     Optional&lt;FloatRect&gt; localBounds(const GraphicsContext&amp;) const override;
1208 
1209     const Path m_path;
1210     FloatPoint m_blockLocation;
1211 };
1212 
1213 class StrokeEllipse : public DrawingItem {
1214 public:
1215     static Ref&lt;StrokeEllipse&gt; create(const FloatRect&amp; rect)
1216     {
1217         return adoptRef(*new StrokeEllipse(rect));
1218     }
1219 
1220     FloatRect rect() const { return m_rect; }
1221 
1222 private:
1223     StrokeEllipse(const FloatRect&amp; rect)
1224         : DrawingItem(ItemType::StrokeEllipse)
1225         , m_rect(rect)
1226     {
1227     }
1228 
1229     void apply(GraphicsContext&amp;) const override;
1230     Optional&lt;FloatRect&gt; localBounds(const GraphicsContext&amp;) const override;
1231 
1232     FloatRect m_rect;
1233 };
1234 
1235 class ClearRect : public DrawingItem {
1236 public:
1237     static Ref&lt;ClearRect&gt; create(const FloatRect&amp; rect)
1238     {
1239         return adoptRef(*new ClearRect(rect));
1240     }
1241 
1242     FloatRect rect() const { return m_rect; }
1243 
1244 private:
1245     ClearRect(const FloatRect&amp; rect)
1246         : DrawingItem(ItemType::ClearRect)
1247         , m_rect(rect)
1248     {
1249     }
1250 
1251     void apply(GraphicsContext&amp;) const override;
1252     Optional&lt;FloatRect&gt; localBounds(const GraphicsContext&amp;) const override { return m_rect; }
1253 
1254     FloatRect m_rect;
1255 };
1256 
1257 #if USE(CG)
1258 class ApplyStrokePattern : public Item {
1259 public:
1260     static Ref&lt;ApplyStrokePattern&gt; create()
1261     {
1262         return adoptRef(*new ApplyStrokePattern);
1263     }
1264 
1265 private:
1266     ApplyStrokePattern()
1267         : Item(ItemType::ApplyStrokePattern)
1268     {
1269     }
1270 
1271     void apply(GraphicsContext&amp;) const override;
1272 };
1273 
1274 class ApplyFillPattern : public Item {
1275 public:
1276     static Ref&lt;ApplyFillPattern&gt; create()
1277     {
1278         return adoptRef(*new ApplyFillPattern);
1279     }
1280 
1281 private:
1282     ApplyFillPattern()
1283         : Item(ItemType::ApplyFillPattern)
1284     {
1285     }
1286 
1287     void apply(GraphicsContext&amp;) const override;
1288 };
1289 #endif
1290 
1291 class ApplyDeviceScaleFactor : public Item {
1292 public:
1293     static Ref&lt;ApplyDeviceScaleFactor&gt; create(float scaleFactor)
1294     {
1295         return adoptRef(*new ApplyDeviceScaleFactor(scaleFactor));
1296     }
1297 
1298     float scaleFactor() const { return m_scaleFactor; }
1299 
1300 private:
1301     ApplyDeviceScaleFactor(float scaleFactor)
1302         : Item(ItemType::ApplyDeviceScaleFactor)
1303         , m_scaleFactor(scaleFactor)
1304     {
1305     }
1306 
1307     void apply(GraphicsContext&amp;) const override;
1308 
1309     float m_scaleFactor;
1310 };
1311 
1312 WTF::TextStream&amp; operator&lt;&lt;(WTF::TextStream&amp;, const Item&amp;);
1313 
1314 } // namespace DisplayList
1315 } // namespace WebCore
1316 
1317 
1318 #define SPECIALIZE_TYPE_TRAITS_DISPLAYLIST_DRAWINGITEM(ToValueTypeName, predicate) \
1319 SPECIALIZE_TYPE_TRAITS_BEGIN(WebCore::DisplayList::ToValueTypeName) \
1320     static bool isType(const WebCore::DisplayList::Item&amp; object) { return object.predicate; } \
1321 SPECIALIZE_TYPE_TRAITS_END()
1322 
1323 SPECIALIZE_TYPE_TRAITS_DISPLAYLIST_DRAWINGITEM(DrawingItem, isDrawingItem())
1324 
1325 #define SPECIALIZE_TYPE_TRAITS_DISPLAYLIST_ITEM(ToValueTypeName) \
1326 SPECIALIZE_TYPE_TRAITS_BEGIN(WebCore::DisplayList::ToValueTypeName) \
1327     static bool isType(const WebCore::DisplayList::Item&amp; item) { return item.type() == WebCore::DisplayList::ItemType::ToValueTypeName; } \
1328 SPECIALIZE_TYPE_TRAITS_END()
1329 
1330 SPECIALIZE_TYPE_TRAITS_DISPLAYLIST_ITEM(Save)
1331 SPECIALIZE_TYPE_TRAITS_DISPLAYLIST_ITEM(Restore)
1332 SPECIALIZE_TYPE_TRAITS_DISPLAYLIST_ITEM(Translate)
1333 SPECIALIZE_TYPE_TRAITS_DISPLAYLIST_ITEM(Rotate)
1334 SPECIALIZE_TYPE_TRAITS_DISPLAYLIST_ITEM(Scale)
1335 SPECIALIZE_TYPE_TRAITS_DISPLAYLIST_ITEM(ConcatenateCTM)
1336 SPECIALIZE_TYPE_TRAITS_DISPLAYLIST_ITEM(SetState)
1337 SPECIALIZE_TYPE_TRAITS_DISPLAYLIST_ITEM(SetLineCap)
1338 SPECIALIZE_TYPE_TRAITS_DISPLAYLIST_ITEM(SetLineDash)
1339 SPECIALIZE_TYPE_TRAITS_DISPLAYLIST_ITEM(SetLineJoin)
1340 SPECIALIZE_TYPE_TRAITS_DISPLAYLIST_ITEM(SetMiterLimit)
1341 SPECIALIZE_TYPE_TRAITS_DISPLAYLIST_ITEM(Clip)
1342 SPECIALIZE_TYPE_TRAITS_DISPLAYLIST_ITEM(ClipOut)
1343 SPECIALIZE_TYPE_TRAITS_DISPLAYLIST_ITEM(ClipOutToPath)
1344 SPECIALIZE_TYPE_TRAITS_DISPLAYLIST_ITEM(ClipPath)
1345 SPECIALIZE_TYPE_TRAITS_DISPLAYLIST_ITEM(DrawGlyphs)
1346 SPECIALIZE_TYPE_TRAITS_DISPLAYLIST_ITEM(DrawImage)
1347 SPECIALIZE_TYPE_TRAITS_DISPLAYLIST_ITEM(DrawTiledImage)
1348 SPECIALIZE_TYPE_TRAITS_DISPLAYLIST_ITEM(DrawTiledScaledImage)
1349 #if USE(CG) || USE(CAIRO)
1350 SPECIALIZE_TYPE_TRAITS_DISPLAYLIST_ITEM(DrawNativeImage)
1351 #endif
1352 SPECIALIZE_TYPE_TRAITS_DISPLAYLIST_ITEM(DrawPattern)
1353 SPECIALIZE_TYPE_TRAITS_DISPLAYLIST_ITEM(DrawRect)
1354 SPECIALIZE_TYPE_TRAITS_DISPLAYLIST_ITEM(DrawLine)
1355 SPECIALIZE_TYPE_TRAITS_DISPLAYLIST_ITEM(DrawLinesForText)
1356 SPECIALIZE_TYPE_TRAITS_DISPLAYLIST_ITEM(DrawDotsForDocumentMarker)
1357 SPECIALIZE_TYPE_TRAITS_DISPLAYLIST_ITEM(DrawEllipse)
1358 SPECIALIZE_TYPE_TRAITS_DISPLAYLIST_ITEM(DrawPath)
1359 SPECIALIZE_TYPE_TRAITS_DISPLAYLIST_ITEM(DrawFocusRingPath)
1360 SPECIALIZE_TYPE_TRAITS_DISPLAYLIST_ITEM(DrawFocusRingRects)
1361 SPECIALIZE_TYPE_TRAITS_DISPLAYLIST_ITEM(FillRect)
1362 SPECIALIZE_TYPE_TRAITS_DISPLAYLIST_ITEM(FillRectWithColor)
1363 SPECIALIZE_TYPE_TRAITS_DISPLAYLIST_ITEM(FillRectWithGradient)
1364 SPECIALIZE_TYPE_TRAITS_DISPLAYLIST_ITEM(FillCompositedRect)
1365 SPECIALIZE_TYPE_TRAITS_DISPLAYLIST_ITEM(FillRoundedRect)
1366 SPECIALIZE_TYPE_TRAITS_DISPLAYLIST_ITEM(FillRectWithRoundedHole)
1367 SPECIALIZE_TYPE_TRAITS_DISPLAYLIST_ITEM(FillPath)
1368 SPECIALIZE_TYPE_TRAITS_DISPLAYLIST_ITEM(FillEllipse)
1369 SPECIALIZE_TYPE_TRAITS_DISPLAYLIST_ITEM(StrokeRect)
1370 SPECIALIZE_TYPE_TRAITS_DISPLAYLIST_ITEM(StrokePath)
1371 SPECIALIZE_TYPE_TRAITS_DISPLAYLIST_ITEM(StrokeEllipse)
1372 SPECIALIZE_TYPE_TRAITS_DISPLAYLIST_ITEM(ClearRect)
1373 SPECIALIZE_TYPE_TRAITS_DISPLAYLIST_ITEM(BeginTransparencyLayer)
1374 SPECIALIZE_TYPE_TRAITS_DISPLAYLIST_ITEM(EndTransparencyLayer)
1375 #if USE(CG)
1376 SPECIALIZE_TYPE_TRAITS_DISPLAYLIST_ITEM(ApplyStrokePattern)
1377 SPECIALIZE_TYPE_TRAITS_DISPLAYLIST_ITEM(ApplyFillPattern)
1378 #endif
1379 SPECIALIZE_TYPE_TRAITS_DISPLAYLIST_ITEM(ApplyDeviceScaleFactor)
1380 SPECIALIZE_TYPE_TRAITS_DISPLAYLIST_ITEM(ClearShadow)
1381 
    </pre>
  </body>
</html>