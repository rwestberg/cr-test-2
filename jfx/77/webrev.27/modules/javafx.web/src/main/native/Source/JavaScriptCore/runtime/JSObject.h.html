<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSObject.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  *  Copyright (C) 1999-2001 Harri Porten (porten@kde.org)
   3  *  Copyright (C) 2001 Peter Kelly (pmk@post.com)
   4  *  Copyright (C) 2003-2019 Apple Inc. All rights reserved.
   5  *
   6  *  This library is free software; you can redistribute it and/or
   7  *  modify it under the terms of the GNU Library General Public
   8  *  License as published by the Free Software Foundation; either
   9  *  version 2 of the License, or (at your option) any later version.
  10  *
  11  *  This library is distributed in the hope that it will be useful,
  12  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  13  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  14  *  Library General Public License for more details.
  15  *
  16  *  You should have received a copy of the GNU Library General Public License
  17  *  along with this library; see the file COPYING.LIB.  If not, write to
  18  *  the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  19  *  Boston, MA 02110-1301, USA.
  20  *
  21  */
  22 
  23 #pragma once
  24 
  25 #include &quot;ArrayConventions.h&quot;
  26 #include &quot;ArrayStorage.h&quot;
  27 #include &quot;Butterfly.h&quot;
  28 #include &quot;CPU.h&quot;
  29 #include &quot;CagedBarrierPtr.h&quot;
  30 #include &quot;CallFrame.h&quot;
  31 #include &quot;ClassInfo.h&quot;
  32 #include &quot;CustomGetterSetter.h&quot;
  33 #include &quot;DOMAttributeGetterSetter.h&quot;
  34 #include &quot;Heap.h&quot;
  35 #include &quot;IndexingHeaderInlines.h&quot;
  36 #include &quot;JSCast.h&quot;
  37 #include &quot;ObjectInitializationScope.h&quot;
  38 #include &quot;PropertySlot.h&quot;
  39 #include &quot;PropertyStorage.h&quot;
  40 #include &quot;PutDirectIndexMode.h&quot;
  41 #include &quot;PutPropertySlot.h&quot;
  42 #include &quot;Structure.h&quot;
  43 #include &quot;StructureTransitionTable.h&quot;
  44 #include &quot;VM.h&quot;
  45 #include &quot;JSString.h&quot;
  46 #include &quot;SparseArrayValueMap.h&quot;
  47 #include &lt;wtf/StdLibExtras.h&gt;
  48 
  49 namespace JSC {
  50 namespace DOMJIT {
  51 class Signature;
  52 }
  53 
  54 inline JSCell* getJSFunction(JSValue value)
  55 {
  56     if (value.isCell() &amp;&amp; (value.asCell()-&gt;type() == JSFunctionType))
  57         return value.asCell();
  58     return 0;
  59 }
  60 
  61 class Exception;
  62 class GetterSetter;
  63 class InternalFunction;
  64 class JSFunction;
  65 class LLIntOffsetsExtractor;
  66 class MarkedBlock;
  67 class PropertyDescriptor;
  68 class PropertyNameArray;
  69 class Structure;
  70 class ThrowScope;
  71 struct HashTable;
  72 struct HashTableValue;
  73 
  74 JS_EXPORT_PRIVATE Exception* throwTypeError(ExecState*, ThrowScope&amp;, const String&amp;);
  75 extern JS_EXPORT_PRIVATE const ASCIILiteral NonExtensibleObjectPropertyDefineError;
  76 extern JS_EXPORT_PRIVATE const ASCIILiteral ReadonlyPropertyWriteError;
  77 extern JS_EXPORT_PRIVATE const ASCIILiteral ReadonlyPropertyChangeError;
  78 extern JS_EXPORT_PRIVATE const ASCIILiteral UnableToDeletePropertyError;
  79 extern JS_EXPORT_PRIVATE const ASCIILiteral UnconfigurablePropertyChangeAccessMechanismError;
  80 extern JS_EXPORT_PRIVATE const ASCIILiteral UnconfigurablePropertyChangeConfigurabilityError;
  81 extern JS_EXPORT_PRIVATE const ASCIILiteral UnconfigurablePropertyChangeEnumerabilityError;
  82 extern JS_EXPORT_PRIVATE const ASCIILiteral UnconfigurablePropertyChangeWritabilityError;
  83 
  84 COMPILE_ASSERT(PropertyAttribute::None &lt; FirstInternalAttribute, None_is_below_FirstInternalAttribute);
  85 COMPILE_ASSERT(PropertyAttribute::ReadOnly &lt; FirstInternalAttribute, ReadOnly_is_below_FirstInternalAttribute);
  86 COMPILE_ASSERT(PropertyAttribute::DontEnum &lt; FirstInternalAttribute, DontEnum_is_below_FirstInternalAttribute);
  87 COMPILE_ASSERT(PropertyAttribute::DontDelete &lt; FirstInternalAttribute, DontDelete_is_below_FirstInternalAttribute);
  88 COMPILE_ASSERT(PropertyAttribute::Accessor &lt; FirstInternalAttribute, Accessor_is_below_FirstInternalAttribute);
  89 
  90 class JSFinalObject;
  91 
  92 class JSObject : public JSCell {
  93     friend class BatchedTransitionOptimizer;
  94     friend class JIT;
  95     friend class JSCell;
  96     friend class JSFinalObject;
  97     friend class MarkedBlock;
  98     JS_EXPORT_PRIVATE friend bool setUpStaticFunctionSlot(VM&amp;, const HashTableValue*, JSObject*, PropertyName, PropertySlot&amp;);
  99 
 100     enum PutMode {
 101         PutModePut,
 102         PutModeDefineOwnProperty,
 103     };
 104 
 105 public:
 106     typedef JSCell Base;
 107 
 108     // This is a super dangerous method for JITs. Sometimes the JITs will want to create either a
 109     // JSFinalObject or a JSArray. This is the method that will do that.
 110     static JSObject* createRawObject(ExecState* exec, Structure* structure, Butterfly* = nullptr);
 111 
 112     JS_EXPORT_PRIVATE static size_t estimatedSize(JSCell*, VM&amp;);
 113     JS_EXPORT_PRIVATE static void visitChildren(JSCell*, SlotVisitor&amp;);
 114     JS_EXPORT_PRIVATE static void analyzeHeap(JSCell*, HeapAnalyzer&amp;);
 115 
 116     JS_EXPORT_PRIVATE static String className(const JSObject*, VM&amp;);
 117     JS_EXPORT_PRIVATE static String calculatedClassName(JSObject*);
 118 
 119     // This function is what Object.prototype.toString() will use to get the name of
 120     // an object when using Symbol.toStringTag fails. For the most part there is no
 121     // difference between this and className(). The main use case is for new JS language
 122     // objects to set the default tag to &quot;Object&quot;.
 123     JS_EXPORT_PRIVATE static String toStringName(const JSObject*, ExecState*);
 124 
 125     // This is the fully virtual [[GetPrototypeOf]] internal function defined
 126     // in the ECMAScript 6 specification. Use this when doing a [[GetPrototypeOf]]
 127     // operation as dictated in the specification.
 128     JSValue getPrototype(VM&amp;, ExecState*);
 129     JS_EXPORT_PRIVATE static JSValue getPrototype(JSObject*, ExecState*);
 130     // This gets the prototype directly off of the structure. This does not do
 131     // dynamic dispatch on the getPrototype method table method. It is not valid
 132     // to use this when performing a [[GetPrototypeOf]] operation in the specification.
 133     // It is valid to use though when you know that you want to directly get it
 134     // without consulting the method table. This is akin to getting the [[Prototype]]
 135     // internal field directly as described in the specification.
 136     JSValue getPrototypeDirect(VM&amp;) const;
 137 
 138     // This sets the prototype without checking for cycles and without
 139     // doing dynamic dispatch on [[SetPrototypeOf]] operation in the specification.
 140     // It is not valid to use this when performing a [[SetPrototypeOf]] operation in
 141     // the specification. It is valid to use though when you know that you want to directly
 142     // set it without consulting the method table and when you definitely won&#39;t
 143     // introduce a cycle in the prototype chain. This is akin to setting the
 144     // [[Prototype]] internal field directly as described in the specification.
 145     JS_EXPORT_PRIVATE void setPrototypeDirect(VM&amp;, JSValue prototype);
 146 private:
 147     // This is OrdinarySetPrototypeOf in the specification. Section 9.1.2.1
 148     // https://tc39.github.io/ecma262/#sec-ordinarysetprototypeof
 149     JS_EXPORT_PRIVATE bool setPrototypeWithCycleCheck(VM&amp;, ExecState*, JSValue prototype, bool shouldThrowIfCantSet);
 150 public:
 151     // This is the fully virtual [[SetPrototypeOf]] internal function defined
 152     // in the ECMAScript 6 specification. Use this when doing a [[SetPrototypeOf]]
 153     // operation as dictated in the specification.
 154     bool setPrototype(VM&amp;, ExecState*, JSValue prototype, bool shouldThrowIfCantSet = false);
 155     JS_EXPORT_PRIVATE static bool setPrototype(JSObject*, ExecState*, JSValue prototype, bool shouldThrowIfCantSet);
 156 
 157     inline bool mayInterceptIndexedAccesses(VM&amp;);
 158 
 159     JSValue get(ExecState*, PropertyName) const;
 160     JSValue get(ExecState*, unsigned propertyName) const;
 161 
 162     template&lt;bool checkNullStructure = false&gt;
 163     bool getPropertySlot(ExecState*, PropertyName, PropertySlot&amp;);
 164     bool getPropertySlot(ExecState*, unsigned propertyName, PropertySlot&amp;);
 165     template&lt;typename CallbackWhenNoException&gt; typename std::result_of&lt;CallbackWhenNoException(bool, PropertySlot&amp;)&gt;::type getPropertySlot(ExecState*, PropertyName, CallbackWhenNoException) const;
 166     template&lt;typename CallbackWhenNoException&gt; typename std::result_of&lt;CallbackWhenNoException(bool, PropertySlot&amp;)&gt;::type getPropertySlot(ExecState*, PropertyName, PropertySlot&amp;, CallbackWhenNoException) const;
 167 
 168     static bool getOwnPropertySlot(JSObject*, ExecState*, PropertyName, PropertySlot&amp;);
 169     JS_EXPORT_PRIVATE static bool getOwnPropertySlotByIndex(JSObject*, ExecState*, unsigned propertyName, PropertySlot&amp;);
 170     bool getOwnPropertySlotInline(ExecState*, PropertyName, PropertySlot&amp;);
 171     static void doPutPropertySecurityCheck(JSObject*, ExecState*, PropertyName, PutPropertySlot&amp;);
 172 
 173     // The key difference between this and getOwnPropertySlot is that getOwnPropertySlot
 174     // currently returns incorrect results for the DOM window (with non-own properties)
 175     // being returned. Once this is fixed we should migrate code &amp; remove this method.
 176     JS_EXPORT_PRIVATE bool getOwnPropertyDescriptor(ExecState*, PropertyName, PropertyDescriptor&amp;);
 177 
 178     unsigned getArrayLength() const
 179     {
 180         if (!hasIndexedProperties(indexingType()))
 181             return 0;
 182         return m_butterfly-&gt;publicLength();
 183     }
 184 
 185     unsigned getVectorLength()
 186     {
 187         if (!hasIndexedProperties(indexingType()))
 188             return 0;
 189         return m_butterfly-&gt;vectorLength();
 190     }
 191 
 192     static bool putInlineForJSObject(JSCell*, ExecState*, PropertyName, JSValue, PutPropertySlot&amp;);
 193 
 194     JS_EXPORT_PRIVATE static bool put(JSCell*, ExecState*, PropertyName, JSValue, PutPropertySlot&amp;);
 195     // putByIndex assumes that the receiver is this JSCell object.
 196     JS_EXPORT_PRIVATE static bool putByIndex(JSCell*, ExecState*, unsigned propertyName, JSValue, bool shouldThrow);
 197 
 198     // This performs the ECMAScript Set() operation.
 199     ALWAYS_INLINE bool putByIndexInline(ExecState* exec, unsigned propertyName, JSValue value, bool shouldThrow)
 200     {
 201         VM&amp; vm = exec-&gt;vm();
 202         if (canSetIndexQuickly(propertyName, value)) {
 203             setIndexQuickly(vm, propertyName, value);
 204             return true;
 205         }
 206         return methodTable(vm)-&gt;putByIndex(this, exec, propertyName, value, shouldThrow);
 207     }
 208 
 209     // This is similar to the putDirect* methods:
 210     //  - the prototype chain is not consulted
 211     //  - accessors are not called.
 212     //  - it will ignore extensibility and read-only properties if PutDirectIndexLikePutDirect is passed as the mode (the default).
 213     // This method creates a property with attributes writable, enumerable and configurable all set to true if attributes is zero,
 214     // otherwise, it creates a property with the provided attributes. Semantically, this is performing defineOwnProperty.
 215     bool putDirectIndex(ExecState* exec, unsigned propertyName, JSValue value, unsigned attributes, PutDirectIndexMode mode)
 216     {
 217         ASSERT(!value.isCustomGetterSetter());
 218         auto canSetIndexQuicklyForPutDirect = [&amp;] () -&gt; bool {
 219             switch (indexingMode()) {
 220             case ALL_BLANK_INDEXING_TYPES:
 221             case ALL_UNDECIDED_INDEXING_TYPES:
 222                 return false;
 223             case ALL_WRITABLE_INT32_INDEXING_TYPES:
 224             case ALL_WRITABLE_DOUBLE_INDEXING_TYPES:
 225             case ALL_WRITABLE_CONTIGUOUS_INDEXING_TYPES:
 226             case ALL_ARRAY_STORAGE_INDEXING_TYPES:
 227                 return propertyName &lt; m_butterfly-&gt;vectorLength();
 228             default:
 229                 if (isCopyOnWrite(indexingMode()))
 230                     return false;
 231                 RELEASE_ASSERT_NOT_REACHED();
 232                 return false;
 233             }
 234         };
 235 
 236         if (!attributes &amp;&amp; canSetIndexQuicklyForPutDirect()) {
 237             setIndexQuickly(exec-&gt;vm(), propertyName, value);
 238             return true;
 239         }
 240         return putDirectIndexSlowOrBeyondVectorLength(exec, propertyName, value, attributes, mode);
 241     }
 242     // This is semantically equivalent to performing defineOwnProperty(propertyName, {configurable:true, writable:true, enumerable:true, value:value}).
 243     bool putDirectIndex(ExecState* exec, unsigned propertyName, JSValue value)
 244     {
 245         return putDirectIndex(exec, propertyName, value, 0, PutDirectIndexLikePutDirect);
 246     }
 247 
 248     // A generally non-throwing version of putDirect and putDirectIndex.
 249     // However, it&#39;s only guaranteed to not throw based on what the receiver is.
 250     // For example, if the receiver is a ProxyObject, this is not guaranteed, since
 251     // it may call into arbitrary JS code. It&#39;s the responsibility of the user of
 252     // this API to ensure that the receiver object is a well known type if they
 253     // want to ensure that this won&#39;t throw an exception.
 254     JS_EXPORT_PRIVATE bool putDirectMayBeIndex(ExecState*, PropertyName, JSValue);
 255 
 256     bool hasIndexingHeader(VM&amp; vm) const
 257     {
 258         return structure(vm)-&gt;hasIndexingHeader(this);
 259     }
 260 
 261     bool canGetIndexQuicklyForTypedArray(unsigned) const;
 262     JSValue getIndexQuicklyForTypedArray(unsigned) const;
 263 
 264     bool canGetIndexQuickly(unsigned i) const
 265     {
 266         const Butterfly* butterfly = this-&gt;butterfly();
 267         switch (indexingType()) {
 268         case ALL_BLANK_INDEXING_TYPES:
 269             return canGetIndexQuicklyForTypedArray(i);
 270         case ALL_UNDECIDED_INDEXING_TYPES:
 271             return false;
 272         case ALL_INT32_INDEXING_TYPES:
 273         case ALL_CONTIGUOUS_INDEXING_TYPES:
 274             return i &lt; butterfly-&gt;vectorLength() &amp;&amp; butterfly-&gt;contiguous().at(this, i);
 275         case ALL_DOUBLE_INDEXING_TYPES: {
 276             if (i &gt;= butterfly-&gt;vectorLength())
 277                 return false;
 278             double value = butterfly-&gt;contiguousDouble().at(this, i);
 279             if (value != value)
 280                 return false;
 281             return true;
 282         }
 283         case ALL_ARRAY_STORAGE_INDEXING_TYPES:
 284             return i &lt; butterfly-&gt;arrayStorage()-&gt;vectorLength() &amp;&amp; butterfly-&gt;arrayStorage()-&gt;m_vector[i];
 285         default:
 286             RELEASE_ASSERT_NOT_REACHED();
 287             return false;
 288         }
 289     }
 290 
 291     JSValue getIndexQuickly(unsigned i) const
 292     {
 293         const Butterfly* butterfly = this-&gt;butterfly();
 294         switch (indexingType()) {
 295         case ALL_INT32_INDEXING_TYPES:
 296             return jsNumber(butterfly-&gt;contiguous().at(this, i).get().asInt32());
 297         case ALL_CONTIGUOUS_INDEXING_TYPES:
 298             return butterfly-&gt;contiguous().at(this, i).get();
 299         case ALL_DOUBLE_INDEXING_TYPES:
 300             return JSValue(JSValue::EncodeAsDouble, butterfly-&gt;contiguousDouble().at(this, i));
 301         case ALL_ARRAY_STORAGE_INDEXING_TYPES:
 302             return butterfly-&gt;arrayStorage()-&gt;m_vector[i].get();
 303         case ALL_BLANK_INDEXING_TYPES:
 304             return getIndexQuicklyForTypedArray(i);
 305         default:
 306             RELEASE_ASSERT_NOT_REACHED();
 307             return JSValue();
 308         }
 309     }
 310 
 311     JSValue tryGetIndexQuickly(unsigned i) const
 312     {
 313         const Butterfly* butterfly = this-&gt;butterfly();
 314         switch (indexingType()) {
 315         case ALL_BLANK_INDEXING_TYPES:
 316             if (canGetIndexQuicklyForTypedArray(i))
 317                 return getIndexQuicklyForTypedArray(i);
 318             break;
 319         case ALL_UNDECIDED_INDEXING_TYPES:
 320             break;
 321         case ALL_INT32_INDEXING_TYPES:
 322             if (i &lt; butterfly-&gt;publicLength()) {
 323                 JSValue result = butterfly-&gt;contiguous().at(this, i).get();
 324                 ASSERT(result.isInt32() || !result);
 325                 return result;
 326             }
 327             break;
 328         case ALL_CONTIGUOUS_INDEXING_TYPES:
 329             if (i &lt; butterfly-&gt;publicLength())
 330                 return butterfly-&gt;contiguous().at(this, i).get();
 331             break;
 332         case ALL_DOUBLE_INDEXING_TYPES: {
 333             if (i &gt;= butterfly-&gt;publicLength())
 334                 break;
 335             double result = butterfly-&gt;contiguousDouble().at(this, i);
 336             if (result != result)
 337                 break;
 338             return JSValue(JSValue::EncodeAsDouble, result);
 339         }
 340         case ALL_ARRAY_STORAGE_INDEXING_TYPES:
 341             if (i &lt; butterfly-&gt;arrayStorage()-&gt;vectorLength())
 342                 return butterfly-&gt;arrayStorage()-&gt;m_vector[i].get();
 343             break;
 344         default:
 345             RELEASE_ASSERT_NOT_REACHED();
 346             break;
 347         }
 348         return JSValue();
 349     }
 350 
 351     JSValue getDirectIndex(ExecState* exec, unsigned i)
 352     {
 353         if (JSValue result = tryGetIndexQuickly(i))
 354             return result;
 355         PropertySlot slot(this, PropertySlot::InternalMethodType::Get);
 356         if (methodTable(exec-&gt;vm())-&gt;getOwnPropertySlotByIndex(this, exec, i, slot))
 357             return slot.getValue(exec, i);
 358         return JSValue();
 359     }
 360 
 361     JSValue getIndex(ExecState* exec, unsigned i) const
 362     {
 363         if (JSValue result = tryGetIndexQuickly(i))
 364             return result;
 365         return get(exec, i);
 366     }
 367 
 368     bool canSetIndexQuicklyForTypedArray(unsigned, JSValue) const;
 369     void setIndexQuicklyForTypedArray(unsigned, JSValue);
 370 
 371     bool canSetIndexQuickly(unsigned i, JSValue value)
 372     {
 373         Butterfly* butterfly = this-&gt;butterfly();
 374         switch (indexingMode()) {
 375         case ALL_BLANK_INDEXING_TYPES:
 376             return canSetIndexQuicklyForTypedArray(i, value);
 377         case ALL_UNDECIDED_INDEXING_TYPES:
 378             return false;
 379         case ALL_WRITABLE_INT32_INDEXING_TYPES:
 380         case ALL_WRITABLE_DOUBLE_INDEXING_TYPES:
 381         case ALL_WRITABLE_CONTIGUOUS_INDEXING_TYPES:
 382         case NonArrayWithArrayStorage:
 383         case ArrayWithArrayStorage:
 384             return i &lt; butterfly-&gt;vectorLength();
 385         case NonArrayWithSlowPutArrayStorage:
 386         case ArrayWithSlowPutArrayStorage:
 387             return i &lt; butterfly-&gt;arrayStorage()-&gt;vectorLength()
 388                 &amp;&amp; !!butterfly-&gt;arrayStorage()-&gt;m_vector[i];
 389         default:
 390             if (isCopyOnWrite(indexingMode()))
 391                 return false;
 392             RELEASE_ASSERT_NOT_REACHED();
 393             return false;
 394         }
 395     }
 396 
 397     void setIndexQuickly(VM&amp; vm, unsigned i, JSValue v)
 398     {
 399         Butterfly* butterfly = m_butterfly.get();
 400         ASSERT(!isCopyOnWrite(indexingMode()));
 401         switch (indexingType()) {
 402         case ALL_INT32_INDEXING_TYPES: {
 403             ASSERT(i &lt; butterfly-&gt;vectorLength());
 404             if (!v.isInt32()) {
 405                 convertInt32ToDoubleOrContiguousWhilePerformingSetIndex(vm, i, v);
 406                 return;
 407             }
 408             FALLTHROUGH;
 409         }
 410         case ALL_CONTIGUOUS_INDEXING_TYPES: {
 411             ASSERT(i &lt; butterfly-&gt;vectorLength());
 412             butterfly-&gt;contiguous().at(this, i).set(vm, this, v);
 413             if (i &gt;= butterfly-&gt;publicLength())
 414                 butterfly-&gt;setPublicLength(i + 1);
 415             break;
 416         }
 417         case ALL_DOUBLE_INDEXING_TYPES: {
 418             ASSERT(i &lt; butterfly-&gt;vectorLength());
 419             if (!v.isNumber()) {
 420                 convertDoubleToContiguousWhilePerformingSetIndex(vm, i, v);
 421                 return;
 422             }
 423             double value = v.asNumber();
 424             if (value != value) {
 425                 convertDoubleToContiguousWhilePerformingSetIndex(vm, i, v);
 426                 return;
 427             }
 428             butterfly-&gt;contiguousDouble().at(this, i) = value;
 429             if (i &gt;= butterfly-&gt;publicLength())
 430                 butterfly-&gt;setPublicLength(i + 1);
 431             break;
 432         }
 433         case ALL_ARRAY_STORAGE_INDEXING_TYPES: {
 434             ArrayStorage* storage = butterfly-&gt;arrayStorage();
 435             WriteBarrier&lt;Unknown&gt;&amp; x = storage-&gt;m_vector[i];
 436             JSValue old = x.get();
 437             x.set(vm, this, v);
 438             if (!old) {
 439                 ++storage-&gt;m_numValuesInVector;
 440                 if (i &gt;= storage-&gt;length())
 441                     storage-&gt;setLength(i + 1);
 442             }
 443             break;
 444         }
 445         case ALL_BLANK_INDEXING_TYPES:
 446             setIndexQuicklyForTypedArray(i, v);
 447             break;
 448         default:
 449             RELEASE_ASSERT_NOT_REACHED();
 450         }
 451     }
 452 
 453     void initializeIndex(ObjectInitializationScope&amp; scope, unsigned i, JSValue v)
 454     {
 455         initializeIndex(scope, i, v, indexingType());
 456     }
 457 
 458     // NOTE: Clients of this method may call it more than once for any index, and this is supposed
 459     // to work.
 460     ALWAYS_INLINE void initializeIndex(ObjectInitializationScope&amp; scope, unsigned i, JSValue v, IndexingType indexingType)
 461     {
 462         VM&amp; vm = scope.vm();
 463         Butterfly* butterfly = m_butterfly.get();
 464         switch (indexingType) {
 465         case ALL_UNDECIDED_INDEXING_TYPES: {
 466             setIndexQuicklyToUndecided(vm, i, v);
 467             break;
 468         }
 469         case ALL_INT32_INDEXING_TYPES: {
 470             ASSERT(i &lt; butterfly-&gt;publicLength());
 471             ASSERT(i &lt; butterfly-&gt;vectorLength());
 472             if (!v.isInt32()) {
 473                 convertInt32ToDoubleOrContiguousWhilePerformingSetIndex(vm, i, v);
 474                 break;
 475             }
 476             FALLTHROUGH;
 477         }
 478         case ALL_CONTIGUOUS_INDEXING_TYPES: {
 479             ASSERT(i &lt; butterfly-&gt;publicLength());
 480             ASSERT(i &lt; butterfly-&gt;vectorLength());
 481             butterfly-&gt;contiguous().at(this, i).set(vm, this, v);
 482             break;
 483         }
 484         case ALL_DOUBLE_INDEXING_TYPES: {
 485             ASSERT(i &lt; butterfly-&gt;publicLength());
 486             ASSERT(i &lt; butterfly-&gt;vectorLength());
 487             if (!v.isNumber()) {
 488                 convertDoubleToContiguousWhilePerformingSetIndex(vm, i, v);
 489                 return;
 490             }
 491             double value = v.asNumber();
 492             if (value != value) {
 493                 convertDoubleToContiguousWhilePerformingSetIndex(vm, i, v);
 494                 return;
 495             }
 496             butterfly-&gt;contiguousDouble().at(this, i) = value;
 497             break;
 498         }
 499         case ALL_ARRAY_STORAGE_INDEXING_TYPES: {
 500             ArrayStorage* storage = butterfly-&gt;arrayStorage();
 501             ASSERT(i &lt; storage-&gt;length());
 502             ASSERT(i &lt; storage-&gt;m_numValuesInVector);
 503             storage-&gt;m_vector[i].set(vm, this, v);
 504             break;
 505         }
 506         default:
 507             RELEASE_ASSERT_NOT_REACHED();
 508         }
 509     }
 510 
 511     void initializeIndexWithoutBarrier(ObjectInitializationScope&amp; scope, unsigned i, JSValue v)
 512     {
 513         initializeIndexWithoutBarrier(scope, i, v, indexingType());
 514     }
 515 
 516     // This version of initializeIndex is for cases where you know that you will not need any
 517     // barriers. This implies not having any data format conversions.
 518     ALWAYS_INLINE void initializeIndexWithoutBarrier(ObjectInitializationScope&amp;, unsigned i, JSValue v, IndexingType indexingType)
 519     {
 520         Butterfly* butterfly = m_butterfly.get();
 521         switch (indexingType) {
 522         case ALL_UNDECIDED_INDEXING_TYPES: {
 523             RELEASE_ASSERT_NOT_REACHED();
 524             break;
 525         }
 526         case ALL_INT32_INDEXING_TYPES: {
 527             ASSERT(i &lt; butterfly-&gt;publicLength());
 528             ASSERT(i &lt; butterfly-&gt;vectorLength());
 529             RELEASE_ASSERT(v.isInt32());
 530             FALLTHROUGH;
 531         }
 532         case ALL_CONTIGUOUS_INDEXING_TYPES: {
 533             ASSERT(i &lt; butterfly-&gt;publicLength());
 534             ASSERT(i &lt; butterfly-&gt;vectorLength());
 535             butterfly-&gt;contiguous().at(this, i).setWithoutWriteBarrier(v);
 536             break;
 537         }
 538         case ALL_DOUBLE_INDEXING_TYPES: {
 539             ASSERT(i &lt; butterfly-&gt;publicLength());
 540             ASSERT(i &lt; butterfly-&gt;vectorLength());
 541             RELEASE_ASSERT(v.isNumber());
 542             double value = v.asNumber();
 543             RELEASE_ASSERT(value == value);
 544             butterfly-&gt;contiguousDouble().at(this, i) = value;
 545             break;
 546         }
 547         case ALL_ARRAY_STORAGE_INDEXING_TYPES: {
 548             ArrayStorage* storage = butterfly-&gt;arrayStorage();
 549             ASSERT(i &lt; storage-&gt;length());
 550             ASSERT(i &lt; storage-&gt;m_numValuesInVector);
 551             storage-&gt;m_vector[i].setWithoutWriteBarrier(v);
 552             break;
 553         }
 554         default:
 555             RELEASE_ASSERT_NOT_REACHED();
 556         }
 557     }
 558 
 559     bool hasSparseMap()
 560     {
 561         switch (indexingType()) {
 562         case ALL_BLANK_INDEXING_TYPES:
 563         case ALL_UNDECIDED_INDEXING_TYPES:
 564         case ALL_INT32_INDEXING_TYPES:
 565         case ALL_DOUBLE_INDEXING_TYPES:
 566         case ALL_CONTIGUOUS_INDEXING_TYPES:
 567             return false;
 568         case ALL_ARRAY_STORAGE_INDEXING_TYPES:
 569             return !!m_butterfly-&gt;arrayStorage()-&gt;m_sparseMap;
 570         default:
 571             RELEASE_ASSERT_NOT_REACHED();
 572             return false;
 573         }
 574     }
 575 
 576     bool inSparseIndexingMode()
 577     {
 578         switch (indexingType()) {
 579         case ALL_BLANK_INDEXING_TYPES:
 580         case ALL_UNDECIDED_INDEXING_TYPES:
 581         case ALL_INT32_INDEXING_TYPES:
 582         case ALL_DOUBLE_INDEXING_TYPES:
 583         case ALL_CONTIGUOUS_INDEXING_TYPES:
 584             return false;
 585         case ALL_ARRAY_STORAGE_INDEXING_TYPES:
 586             return m_butterfly-&gt;arrayStorage()-&gt;inSparseMode();
 587         default:
 588             RELEASE_ASSERT_NOT_REACHED();
 589             return false;
 590         }
 591     }
 592 
 593     void enterDictionaryIndexingMode(VM&amp;);
 594 
 595     // putDirect is effectively an unchecked vesion of &#39;defineOwnProperty&#39;:
 596     //  - the prototype chain is not consulted
 597     //  - accessors are not called.
 598     //  - attributes will be respected (after the call the property will exist with the given attributes)
 599     //  - the property name is assumed to not be an index.
 600     bool putDirect(VM&amp;, PropertyName, JSValue, unsigned attributes = 0);
 601     bool putDirect(VM&amp;, PropertyName, JSValue, PutPropertySlot&amp;);
 602     void putDirectWithoutTransition(VM&amp;, PropertyName, JSValue, unsigned attributes = 0);
 603     bool putDirectNonIndexAccessor(VM&amp;, PropertyName, GetterSetter*, unsigned attributes);
 604     void putDirectNonIndexAccessorWithoutTransition(VM&amp;, PropertyName, GetterSetter*, unsigned attributes);
 605     bool putDirectAccessor(ExecState*, PropertyName, GetterSetter*, unsigned attributes);
 606     JS_EXPORT_PRIVATE bool putDirectCustomAccessor(VM&amp;, PropertyName, JSValue, unsigned attributes);
 607 
 608     bool putGetter(ExecState*, PropertyName, JSValue, unsigned attributes);
 609     bool putSetter(ExecState*, PropertyName, JSValue, unsigned attributes);
 610 
 611     JS_EXPORT_PRIVATE bool hasProperty(ExecState*, PropertyName) const;
 612     JS_EXPORT_PRIVATE bool hasProperty(ExecState*, unsigned propertyName) const;
 613     bool hasPropertyGeneric(ExecState*, PropertyName, PropertySlot::InternalMethodType) const;
 614     bool hasPropertyGeneric(ExecState*, unsigned propertyName, PropertySlot::InternalMethodType) const;
 615     bool hasOwnProperty(ExecState*, PropertyName, PropertySlot&amp;) const;
 616     bool hasOwnProperty(ExecState*, PropertyName) const;
 617     bool hasOwnProperty(ExecState*, unsigned) const;
 618 
 619     JS_EXPORT_PRIVATE static bool deleteProperty(JSCell*, ExecState*, PropertyName);
 620     JS_EXPORT_PRIVATE static bool deletePropertyByIndex(JSCell*, ExecState*, unsigned propertyName);
 621 
 622     JS_EXPORT_PRIVATE static JSValue defaultValue(const JSObject*, ExecState*, PreferredPrimitiveType);
 623     JSValue ordinaryToPrimitive(ExecState*, PreferredPrimitiveType) const;
 624 
 625     JS_EXPORT_PRIVATE bool hasInstance(ExecState*, JSValue value, JSValue hasInstanceValue);
 626     JS_EXPORT_PRIVATE bool hasInstance(ExecState*, JSValue);
 627     static bool defaultHasInstance(ExecState*, JSValue, JSValue prototypeProperty);
 628 
 629     JS_EXPORT_PRIVATE static void getOwnPropertyNames(JSObject*, ExecState*, PropertyNameArray&amp;, EnumerationMode);
 630     JS_EXPORT_PRIVATE static void getOwnNonIndexPropertyNames(JSObject*, ExecState*, PropertyNameArray&amp;, EnumerationMode);
 631     JS_EXPORT_PRIVATE static void getPropertyNames(JSObject*, ExecState*, PropertyNameArray&amp;, EnumerationMode);
 632 
 633     JS_EXPORT_PRIVATE static uint32_t getEnumerableLength(ExecState*, JSObject*);
 634     JS_EXPORT_PRIVATE static void getStructurePropertyNames(JSObject*, ExecState*, PropertyNameArray&amp;, EnumerationMode);
 635     JS_EXPORT_PRIVATE static void getGenericPropertyNames(JSObject*, ExecState*, PropertyNameArray&amp;, EnumerationMode);
 636 
 637     JS_EXPORT_PRIVATE JSValue toPrimitive(ExecState*, PreferredPrimitiveType = NoPreference) const;
 638     bool getPrimitiveNumber(ExecState*, double&amp; number, JSValue&amp;) const;
 639     JS_EXPORT_PRIVATE double toNumber(ExecState*) const;
 640     JS_EXPORT_PRIVATE JSString* toString(ExecState*) const;
 641 
 642     JS_EXPORT_PRIVATE static JSValue toThis(JSCell*, ExecState*, ECMAMode);
 643 
 644     // This get function only looks at the property map.
 645     JSValue getDirect(VM&amp; vm, PropertyName propertyName) const
 646     {
 647         Structure* structure = this-&gt;structure(vm);
 648         PropertyOffset offset = structure-&gt;get(vm, propertyName);
 649         checkOffset(offset, structure-&gt;inlineCapacity());
 650         return offset != invalidOffset ? getDirect(offset) : JSValue();
 651     }
 652 
 653     JSValue getDirect(VM&amp; vm, PropertyName propertyName, unsigned&amp; attributes) const
 654     {
 655         Structure* structure = this-&gt;structure(vm);
 656         PropertyOffset offset = structure-&gt;get(vm, propertyName, attributes);
 657         checkOffset(offset, structure-&gt;inlineCapacity());
 658         return offset != invalidOffset ? getDirect(offset) : JSValue();
 659     }
 660 
 661     PropertyOffset getDirectOffset(VM&amp; vm, PropertyName propertyName)
 662     {
 663         Structure* structure = this-&gt;structure(vm);
 664         PropertyOffset offset = structure-&gt;get(vm, propertyName);
 665         checkOffset(offset, structure-&gt;inlineCapacity());
 666         return offset;
 667     }
 668 
 669     PropertyOffset getDirectOffset(VM&amp; vm, PropertyName propertyName, unsigned&amp; attributes)
 670     {
 671         Structure* structure = this-&gt;structure(vm);
 672         PropertyOffset offset = structure-&gt;get(vm, propertyName, attributes);
 673         checkOffset(offset, structure-&gt;inlineCapacity());
 674         return offset;
 675     }
 676 
 677     bool hasInlineStorage() const { return structure()-&gt;hasInlineStorage(); }
 678     ConstPropertyStorage inlineStorageUnsafe() const
 679     {
 680         return bitwise_cast&lt;ConstPropertyStorage&gt;(this + 1);
 681     }
 682     PropertyStorage inlineStorageUnsafe()
 683     {
 684         return bitwise_cast&lt;PropertyStorage&gt;(this + 1);
 685     }
 686     ConstPropertyStorage inlineStorage() const
 687     {
 688         ASSERT(hasInlineStorage());
 689         return inlineStorageUnsafe();
 690     }
 691     PropertyStorage inlineStorage()
 692     {
 693         ASSERT(hasInlineStorage());
 694         return inlineStorageUnsafe();
 695     }
 696 
 697     const Butterfly* butterfly() const { return m_butterfly.get(); }
 698     Butterfly* butterfly() { return m_butterfly.get(); }
 699 
 700     ConstPropertyStorage outOfLineStorage() const { return m_butterfly-&gt;propertyStorage(); }
 701     PropertyStorage outOfLineStorage() { return m_butterfly-&gt;propertyStorage(); }
 702 
 703     ALWAYS_INLINE const WriteBarrierBase&lt;Unknown&gt;* locationForOffset(PropertyOffset offset) const
 704     {
 705         if (isInlineOffset(offset))
 706             return &amp;inlineStorage()[offsetInInlineStorage(offset)];
 707         return &amp;outOfLineStorage()[offsetInOutOfLineStorage(offset)];
 708     }
 709 
 710     ALWAYS_INLINE WriteBarrierBase&lt;Unknown&gt;* locationForOffset(PropertyOffset offset)
 711     {
 712         if (isInlineOffset(offset))
 713             return &amp;inlineStorage()[offsetInInlineStorage(offset)];
 714         return &amp;outOfLineStorage()[offsetInOutOfLineStorage(offset)];
 715     }
 716 
 717     void transitionTo(VM&amp;, Structure*);
 718 
 719     bool hasCustomProperties(VM&amp; vm) { return structure(vm)-&gt;didTransition(); }
 720     bool hasGetterSetterProperties(VM&amp; vm) { return structure(vm)-&gt;hasGetterSetterProperties(); }
 721     bool hasCustomGetterSetterProperties(VM&amp; vm) { return structure(vm)-&gt;hasCustomGetterSetterProperties(); }
 722 
 723     // putOwnDataProperty has &#39;put&#39; like semantics, however this method:
 724     //  - assumes the object contains no own getter/setter properties.
 725     //  - provides no special handling for __proto__
 726     //  - does not walk the prototype chain (to check for accessors or non-writable properties).
 727     // This is used by JSLexicalEnvironment.
 728     bool putOwnDataProperty(VM&amp;, PropertyName, JSValue, PutPropertySlot&amp;);
 729     bool putOwnDataPropertyMayBeIndex(ExecState*, PropertyName, JSValue, PutPropertySlot&amp;);
 730 
 731     // Fast access to known property offsets.
 732     ALWAYS_INLINE JSValue getDirect(PropertyOffset offset) const { return locationForOffset(offset)-&gt;get(); }
 733     JSValue getDirectConcurrently(Structure* expectedStructure, PropertyOffset) const;
 734     void putDirect(VM&amp; vm, PropertyOffset offset, JSValue value) { locationForOffset(offset)-&gt;set(vm, this, value); }
 735     void putDirectWithoutBarrier(PropertyOffset offset, JSValue value) { locationForOffset(offset)-&gt;setWithoutWriteBarrier(value); }
 736     void putDirectUndefined(PropertyOffset offset) { locationForOffset(offset)-&gt;setUndefined(); }
 737 
 738     JS_EXPORT_PRIVATE bool putDirectNativeIntrinsicGetter(VM&amp;, JSGlobalObject*, Identifier, NativeFunction, Intrinsic, unsigned attributes);
 739     JS_EXPORT_PRIVATE void putDirectNativeIntrinsicGetterWithoutTransition(VM&amp;, JSGlobalObject*, Identifier, NativeFunction, Intrinsic, unsigned attributes);
 740     JS_EXPORT_PRIVATE bool putDirectNativeFunction(VM&amp;, JSGlobalObject*, const PropertyName&amp;, unsigned functionLength, NativeFunction, Intrinsic, unsigned attributes);
 741     JS_EXPORT_PRIVATE bool putDirectNativeFunction(VM&amp;, JSGlobalObject*, const PropertyName&amp;, unsigned functionLength, NativeFunction, Intrinsic, const DOMJIT::Signature*, unsigned attributes);
 742     JS_EXPORT_PRIVATE void putDirectNativeFunctionWithoutTransition(VM&amp;, JSGlobalObject*, const PropertyName&amp;, unsigned functionLength, NativeFunction, Intrinsic, unsigned attributes);
 743 
 744     JS_EXPORT_PRIVATE JSFunction* putDirectBuiltinFunction(VM&amp;, JSGlobalObject*, const PropertyName&amp;, FunctionExecutable*, unsigned attributes);
 745     JSFunction* putDirectBuiltinFunctionWithoutTransition(VM&amp;, JSGlobalObject*, const PropertyName&amp;, FunctionExecutable*, unsigned attributes);
 746 
 747     JS_EXPORT_PRIVATE static bool defineOwnProperty(JSObject*, ExecState*, PropertyName, const PropertyDescriptor&amp;, bool shouldThrow);
 748 
 749     bool isEnvironment() const;
 750     bool isGlobalObject() const;
 751     bool isJSLexicalEnvironment() const;
 752     bool isGlobalLexicalEnvironment() const;
 753     bool isStrictEvalActivation() const;
 754     bool isWithScope() const;
 755 
 756     bool isErrorInstance() const;
 757 
 758     JS_EXPORT_PRIVATE void seal(VM&amp;);
 759     JS_EXPORT_PRIVATE void freeze(VM&amp;);
 760     JS_EXPORT_PRIVATE static bool preventExtensions(JSObject*, ExecState*);
 761     JS_EXPORT_PRIVATE static bool isExtensible(JSObject*, ExecState*);
 762     bool isSealed(VM&amp; vm) { return structure(vm)-&gt;isSealed(vm); }
 763     bool isFrozen(VM&amp; vm) { return structure(vm)-&gt;isFrozen(vm); }
 764 
 765     JS_EXPORT_PRIVATE bool anyObjectInChainMayInterceptIndexedAccesses(VM&amp;) const;
 766     JS_EXPORT_PRIVATE bool prototypeChainMayInterceptStoreTo(VM&amp;, PropertyName);
 767     bool needsSlowPutIndexing(VM&amp;) const;
 768 
 769 private:
 770     NonPropertyTransition suggestedArrayStorageTransition(VM&amp;) const;
 771 public:
 772     // You should only call isStructureExtensible() when:
 773     // - Performing this check in a way that isn&#39;t described in the specification
 774     //   as calling the virtual [[IsExtensible]] trap.
 775     // - When you&#39;re guaranteed that object-&gt;methodTable(vm)-&gt;isExtensible isn&#39;t
 776     //   overridden.
 777     ALWAYS_INLINE bool isStructureExtensible(VM&amp; vm) { return structure(vm)-&gt;isStructureExtensible(); }
 778     // You should call this when performing [[IsExtensible]] trap in a place
 779     // that is described in the specification. This performs the fully virtual
 780     // [[IsExtensible]] trap.
 781     bool isExtensible(ExecState*);
 782     bool indexingShouldBeSparse(VM&amp; vm)
 783     {
 784         return !isStructureExtensible(vm)
 785             || structure(vm)-&gt;typeInfo().interceptsGetOwnPropertySlotByIndexEvenWhenLengthIsNotZero();
 786     }
 787 
 788     bool staticPropertiesReified(VM&amp; vm) { return structure(vm)-&gt;staticPropertiesReified(); }
 789     void reifyAllStaticProperties(ExecState*);
 790 
 791     JS_EXPORT_PRIVATE Butterfly* allocateMoreOutOfLineStorage(VM&amp;, size_t oldSize, size_t newSize);
 792 
 793     // Call this when you do not need to change the structure.
 794     void setButterfly(VM&amp;, Butterfly*);
 795 
 796     // Call this if you do need to change the structure, or if you changed something about a structure
 797     // in-place.
 798     void nukeStructureAndSetButterfly(VM&amp;, StructureID oldStructureID, Butterfly*);
 799 
 800     void setStructure(VM&amp;, Structure*);
 801 
 802     JS_EXPORT_PRIVATE void convertToDictionary(VM&amp;);
 803 
 804     void flattenDictionaryObject(VM&amp; vm)
 805     {
 806         structure(vm)-&gt;flattenDictionaryStructure(vm, this);
 807     }
 808     void shiftButterflyAfterFlattening(const GCSafeConcurrentJSLocker&amp;, VM&amp;, Structure* structure, size_t outOfLineCapacityAfter);
 809 
 810     JSGlobalObject* globalObject() const
 811     {
 812         ASSERT(structure()-&gt;globalObject());
 813         ASSERT(!isGlobalObject() || ((JSObject*)structure()-&gt;globalObject()) == this);
 814         return structure()-&gt;globalObject();
 815     }
 816 
 817     JSGlobalObject* globalObject(VM&amp; vm) const
 818     {
 819         ASSERT(structure(vm)-&gt;globalObject());
 820         ASSERT(!isGlobalObject() || ((JSObject*)structure(vm)-&gt;globalObject()) == this);
 821         return structure(vm)-&gt;globalObject();
 822     }
 823 
 824     void switchToSlowPutArrayStorage(VM&amp;);
 825 
 826     // The receiver is the prototype in this case. The following:
 827     //
 828     // asObject(foo-&gt;structure()-&gt;storedPrototype())-&gt;attemptToInterceptPutByIndexOnHoleForPrototype(...)
 829     //
 830     // is equivalent to:
 831     //
 832     // foo-&gt;attemptToInterceptPutByIndexOnHole(...);
 833     bool attemptToInterceptPutByIndexOnHoleForPrototype(ExecState*, JSValue thisValue, unsigned propertyName, JSValue, bool shouldThrow, bool&amp; putResult);
 834 
 835     // Returns 0 if int32 storage cannot be created - either because
 836     // indexing should be sparse, we&#39;re having a bad time, or because
 837     // we already have a more general form of storage (double,
 838     // contiguous, array storage).
 839     ContiguousJSValues tryMakeWritableInt32(VM&amp; vm)
 840     {
 841         if (LIKELY(hasInt32(indexingType()) &amp;&amp; !isCopyOnWrite(indexingMode())))
 842             return m_butterfly-&gt;contiguousInt32();
 843 
 844         return tryMakeWritableInt32Slow(vm);
 845     }
 846 
 847     // Returns 0 if double storage cannot be created - either because
 848     // indexing should be sparse, we&#39;re having a bad time, or because
 849     // we already have a more general form of storage (contiguous,
 850     // or array storage).
 851     ContiguousDoubles tryMakeWritableDouble(VM&amp; vm)
 852     {
 853         if (LIKELY(hasDouble(indexingType()) &amp;&amp; !isCopyOnWrite(indexingMode())))
 854             return m_butterfly-&gt;contiguousDouble();
 855 
 856         return tryMakeWritableDoubleSlow(vm);
 857     }
 858 
 859     // Returns 0 if contiguous storage cannot be created - either because
 860     // indexing should be sparse or because we&#39;re having a bad time.
 861     ContiguousJSValues tryMakeWritableContiguous(VM&amp; vm)
 862     {
 863         if (LIKELY(hasContiguous(indexingType()) &amp;&amp; !isCopyOnWrite(indexingMode())))
 864             return m_butterfly-&gt;contiguous();
 865 
 866         return tryMakeWritableContiguousSlow(vm);
 867     }
 868 
 869     // Ensure that the object is in a mode where it has array storage. Use
 870     // this if you&#39;re about to perform actions that would have required the
 871     // object to be converted to have array storage, if it didn&#39;t have it
 872     // already.
 873     ArrayStorage* ensureArrayStorage(VM&amp; vm)
 874     {
 875         if (LIKELY(hasAnyArrayStorage(indexingType())))
 876             return m_butterfly-&gt;arrayStorage();
 877 
 878         return ensureArrayStorageSlow(vm);
 879     }
 880 
 881     void ensureWritable(VM&amp; vm)
 882     {
 883         if (isCopyOnWrite(indexingMode()))
 884             convertFromCopyOnWrite(vm);
 885     }
 886 
 887     static size_t offsetOfInlineStorage();
 888 
 889     static ptrdiff_t butterflyOffset()
 890     {
 891         return OBJECT_OFFSETOF(JSObject, m_butterfly);
 892     }
 893     void* butterflyAddress()
 894     {
 895         return &amp;m_butterfly;
 896     }
 897 
 898     JS_EXPORT_PRIVATE JSValue getMethod(ExecState*, CallData&amp;, CallType&amp;, const Identifier&amp;, const String&amp; errorMessage);
 899 
 900     bool canPerformFastPutInline(VM&amp;, PropertyName);
 901     bool canPerformFastPutInlineExcludingProto(VM&amp;);
 902 
 903     bool mayBePrototype() const;
 904     void didBecomePrototype();
 905 
 906     DECLARE_EXPORT_INFO;
 907 
 908 protected:
 909     void finishCreation(VM&amp; vm)
 910     {
 911         Base::finishCreation(vm);
 912         ASSERT(jsDynamicCast&lt;JSObject*&gt;(vm, this));
 913         ASSERT(structure(vm)-&gt;hasPolyProto() || getPrototypeDirect(vm).isNull() || Heap::heap(this) == Heap::heap(getPrototypeDirect(vm)));
 914         ASSERT(structure(vm)-&gt;isObject());
 915         ASSERT(classInfo(vm));
 916     }
 917 
 918     static Structure* createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
 919     {
 920         return Structure::create(vm, globalObject, prototype, TypeInfo(ObjectType, StructureFlags), info());
 921     }
 922 
 923     // To instantiate objects you likely want JSFinalObject, below.
 924     // To create derived types you likely want JSNonFinalObject, below.
 925     JSObject(VM&amp;, Structure*, Butterfly* = nullptr);
 926 
 927     // Visits the butterfly unless there is a race. Returns the structure if there was no race.
 928     Structure* visitButterfly(SlotVisitor&amp;);
 929 
 930     Structure* visitButterflyImpl(SlotVisitor&amp;);
 931 
 932     void markAuxiliaryAndVisitOutOfLineProperties(SlotVisitor&amp;, Butterfly*, Structure*, PropertyOffset lastOffset);
 933 
 934     // Call this if you know that the object is in a mode where it has array
 935     // storage. This will assert otherwise.
 936     ArrayStorage* arrayStorage()
 937     {
 938         ASSERT(hasAnyArrayStorage(indexingType()));
 939         return m_butterfly-&gt;arrayStorage();
 940     }
 941 
 942     // Call this if you want to predicate some actions on whether or not the
 943     // object is in a mode where it has array storage.
 944     ArrayStorage* arrayStorageOrNull()
 945     {
 946         switch (indexingType()) {
 947         case ALL_ARRAY_STORAGE_INDEXING_TYPES:
 948             return m_butterfly-&gt;arrayStorage();
 949 
 950         default:
 951             return 0;
 952         }
 953     }
 954 
 955     size_t butterflyTotalSize();
 956     size_t butterflyPreCapacity();
 957 
 958     Butterfly* createInitialUndecided(VM&amp;, unsigned length);
 959     ContiguousJSValues createInitialInt32(VM&amp;, unsigned length);
 960     ContiguousDoubles createInitialDouble(VM&amp;, unsigned length);
 961     ContiguousJSValues createInitialContiguous(VM&amp;, unsigned length);
 962 
 963     void convertUndecidedForValue(VM&amp;, JSValue);
 964     void createInitialForValueAndSet(VM&amp;, unsigned index, JSValue);
 965     void convertInt32ForValue(VM&amp;, JSValue);
 966     void convertDoubleForValue(VM&amp;, JSValue);
 967     void convertFromCopyOnWrite(VM&amp;);
 968 
 969     static Butterfly* createArrayStorageButterfly(VM&amp;, JSObject* intendedOwner, Structure*, unsigned length, unsigned vectorLength, Butterfly* oldButterfly = nullptr);
 970     ArrayStorage* createArrayStorage(VM&amp;, unsigned length, unsigned vectorLength);
 971     ArrayStorage* createInitialArrayStorage(VM&amp;);
 972 
 973     ContiguousJSValues convertUndecidedToInt32(VM&amp;);
 974     ContiguousDoubles convertUndecidedToDouble(VM&amp;);
 975     ContiguousJSValues convertUndecidedToContiguous(VM&amp;);
 976     ArrayStorage* convertUndecidedToArrayStorage(VM&amp;, NonPropertyTransition);
 977     ArrayStorage* convertUndecidedToArrayStorage(VM&amp;);
 978 
 979     ContiguousDoubles convertInt32ToDouble(VM&amp;);
 980     ContiguousJSValues convertInt32ToContiguous(VM&amp;);
 981     ArrayStorage* convertInt32ToArrayStorage(VM&amp;, NonPropertyTransition);
 982     ArrayStorage* convertInt32ToArrayStorage(VM&amp;);
 983 
 984     ContiguousJSValues convertDoubleToContiguous(VM&amp;);
 985     ArrayStorage* convertDoubleToArrayStorage(VM&amp;, NonPropertyTransition);
 986     ArrayStorage* convertDoubleToArrayStorage(VM&amp;);
 987 
 988     ArrayStorage* convertContiguousToArrayStorage(VM&amp;, NonPropertyTransition);
 989     ArrayStorage* convertContiguousToArrayStorage(VM&amp;);
 990 
 991 
 992     ArrayStorage* ensureArrayStorageExistsAndEnterDictionaryIndexingMode(VM&amp;);
 993 
 994     bool defineOwnNonIndexProperty(ExecState*, PropertyName, const PropertyDescriptor&amp;, bool throwException);
 995 
 996     template&lt;IndexingType indexingShape&gt;
 997     bool putByIndexBeyondVectorLengthWithoutAttributes(ExecState*, unsigned propertyName, JSValue);
 998     bool putByIndexBeyondVectorLengthWithArrayStorage(ExecState*, unsigned propertyName, JSValue, bool shouldThrow, ArrayStorage*);
 999 
1000     bool increaseVectorLength(VM&amp;, unsigned newLength);
1001     void deallocateSparseIndexMap();
1002     bool defineOwnIndexedProperty(ExecState*, unsigned, const PropertyDescriptor&amp;, bool throwException);
1003     SparseArrayValueMap* allocateSparseIndexMap(VM&amp;);
1004 
1005     void notifyPresenceOfIndexedAccessors(VM&amp;);
1006 
1007     bool attemptToInterceptPutByIndexOnHole(ExecState*, unsigned index, JSValue, bool shouldThrow, bool&amp; putResult);
1008 
1009     // Call this if you want setIndexQuickly to succeed and you&#39;re sure that
1010     // the array is contiguous.
1011     bool WARN_UNUSED_RETURN ensureLength(VM&amp; vm, unsigned length)
1012     {
1013         RELEASE_ASSERT(length &lt;= MAX_STORAGE_VECTOR_LENGTH);
1014         ASSERT(hasContiguous(indexingType()) || hasInt32(indexingType()) || hasDouble(indexingType()) || hasUndecided(indexingType()));
1015 
1016         if (m_butterfly-&gt;vectorLength() &lt; length || isCopyOnWrite(indexingMode())) {
1017             if (!ensureLengthSlow(vm, length))
1018                 return false;
1019         }
1020 
1021         if (m_butterfly-&gt;publicLength() &lt; length)
1022             m_butterfly-&gt;setPublicLength(length);
1023         return true;
1024     }
1025 
1026     // Call this if you want to shrink the butterfly backing store, and you&#39;re
1027     // sure that the array is contiguous.
1028     void reallocateAndShrinkButterfly(VM&amp;, unsigned length);
1029 
1030     template&lt;IndexingType indexingShape&gt;
1031     unsigned countElements(Butterfly*);
1032 
1033     // This is relevant to undecided, int32, double, and contiguous.
1034     unsigned countElements();
1035 
1036 private:
1037     friend class LLIntOffsetsExtractor;
1038     friend class VMInspector;
1039 
1040     // Nobody should ever ask any of these questions on something already known to be a JSObject.
1041     using JSCell::isAPIValueWrapper;
1042     using JSCell::isGetterSetter;
1043     void getObject();
1044     void getString(ExecState* exec);
1045     void isObject();
1046     void isString();
1047 
1048     Butterfly* createInitialIndexedStorage(VM&amp;, unsigned length);
1049 
1050     ArrayStorage* enterDictionaryIndexingModeWhenArrayStorageAlreadyExists(VM&amp;, ArrayStorage*);
1051 
1052     template&lt;PutMode&gt;
1053     bool putDirectInternal(VM&amp;, PropertyName, JSValue, unsigned attr, PutPropertySlot&amp;);
1054 
1055     JS_EXPORT_PRIVATE NEVER_INLINE bool putInlineSlow(ExecState*, PropertyName, JSValue, PutPropertySlot&amp;);
1056 
1057     bool getNonIndexPropertySlot(ExecState*, PropertyName, PropertySlot&amp;);
1058     bool getOwnNonIndexPropertySlot(VM&amp;, Structure*, PropertyName, PropertySlot&amp;);
1059     JS_EXPORT_PRIVATE void fillGetterPropertySlot(VM&amp;, PropertySlot&amp;, JSCell*, unsigned, PropertyOffset);
1060     void fillCustomGetterPropertySlot(VM&amp;, PropertySlot&amp;, CustomGetterSetter*, unsigned, Structure*);
1061 
1062     JS_EXPORT_PRIVATE bool getOwnStaticPropertySlot(VM&amp;, PropertyName, PropertySlot&amp;);
1063     struct PropertyHashEntry {
1064         const HashTable* table;
1065         const HashTableValue* value;
1066     };
1067     Optional&lt;PropertyHashEntry&gt; findPropertyHashEntry(VM&amp;, PropertyName) const;
1068 
1069     bool putByIndexBeyondVectorLength(ExecState*, unsigned propertyName, JSValue, bool shouldThrow);
1070     bool putDirectIndexBeyondVectorLengthWithArrayStorage(ExecState*, unsigned propertyName, JSValue, unsigned attributes, PutDirectIndexMode, ArrayStorage*);
1071     JS_EXPORT_PRIVATE bool putDirectIndexSlowOrBeyondVectorLength(ExecState*, unsigned propertyName, JSValue, unsigned attributes, PutDirectIndexMode);
1072 
1073     unsigned getNewVectorLength(VM&amp;, unsigned indexBias, unsigned currentVectorLength, unsigned currentLength, unsigned desiredLength);
1074     unsigned getNewVectorLength(VM&amp;, unsigned desiredLength);
1075 
1076     ArrayStorage* constructConvertedArrayStorageWithoutCopyingElements(VM&amp;, unsigned neededLength);
1077 
1078     JS_EXPORT_PRIVATE void setIndexQuicklyToUndecided(VM&amp;, unsigned index, JSValue);
1079     JS_EXPORT_PRIVATE void convertInt32ToDoubleOrContiguousWhilePerformingSetIndex(VM&amp;, unsigned index, JSValue);
1080     JS_EXPORT_PRIVATE void convertDoubleToContiguousWhilePerformingSetIndex(VM&amp;, unsigned index, JSValue);
1081 
1082     bool ensureLengthSlow(VM&amp;, unsigned length);
1083 
1084     ContiguousJSValues tryMakeWritableInt32Slow(VM&amp;);
1085     ContiguousDoubles tryMakeWritableDoubleSlow(VM&amp;);
1086     ContiguousJSValues tryMakeWritableContiguousSlow(VM&amp;);
1087     JS_EXPORT_PRIVATE ArrayStorage* ensureArrayStorageSlow(VM&amp;);
1088 
1089     PropertyOffset prepareToPutDirectWithoutTransition(VM&amp;, PropertyName, unsigned attributes, StructureID, Structure*);
1090 
1091     AuxiliaryBarrier&lt;Butterfly*&gt; m_butterfly;
1092 #if CPU(ADDRESS32)
1093     unsigned m_32BitPadding;
1094 #endif
1095 };
1096 
1097 // JSNonFinalObject is a type of JSObject that has some internal storage,
1098 // but also preserves some space in the collector cell for additional
1099 // data members in derived types.
1100 class JSNonFinalObject : public JSObject {
1101     friend class JSObject;
1102 
1103 public:
1104     typedef JSObject Base;
1105 
1106     static Structure* createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
1107     {
1108         return Structure::create(vm, globalObject, prototype, TypeInfo(ObjectType, StructureFlags), info());
1109     }
1110 
1111 protected:
1112     explicit JSNonFinalObject(VM&amp; vm, Structure* structure, Butterfly* butterfly = 0)
1113         : JSObject(vm, structure, butterfly)
1114     {
1115     }
1116 
1117     void finishCreation(VM&amp; vm)
1118     {
1119         Base::finishCreation(vm);
1120         ASSERT(!this-&gt;structure(vm)-&gt;hasInlineStorage());
1121         ASSERT(classInfo(vm));
1122     }
1123 };
1124 
1125 class JSFinalObject;
1126 
1127 // JSFinalObject is a type of JSObject that contains sufficient internal
1128 // storage to fully make use of the collector cell containing it.
1129 class JSFinalObject final : public JSObject {
1130     friend class JSObject;
1131 
1132 public:
1133     typedef JSObject Base;
1134     static const unsigned StructureFlags = Base::StructureFlags;
1135 
1136     static size_t allocationSize(Checked&lt;size_t&gt; inlineCapacity)
1137     {
1138         return (sizeof(JSObject) + inlineCapacity * sizeof(WriteBarrierBase&lt;Unknown&gt;)).unsafeGet();
1139     }
1140 
1141     static inline const TypeInfo typeInfo() { return TypeInfo(FinalObjectType, StructureFlags); }
1142     static const IndexingType defaultIndexingType = NonArray;
1143 
1144     static const unsigned defaultSize = 64;
1145     static inline unsigned defaultInlineCapacity()
1146     {
1147         return (defaultSize - allocationSize(0)) / sizeof(WriteBarrier&lt;Unknown&gt;);
1148     }
1149 
1150     static const unsigned maxSize = 512;
1151     static inline unsigned maxInlineCapacity()
1152     {
1153         return (maxSize - allocationSize(0)) / sizeof(WriteBarrier&lt;Unknown&gt;);
1154     }
1155 
1156     static JSFinalObject* create(ExecState*, Structure*, Butterfly* = nullptr);
1157     static JSFinalObject* create(VM&amp;, Structure*);
1158     static Structure* createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype, unsigned inlineCapacity)
1159     {
1160         return Structure::create(vm, globalObject, prototype, typeInfo(), info(), defaultIndexingType, inlineCapacity);
1161     }
1162 
1163     JS_EXPORT_PRIVATE static void visitChildren(JSCell*, SlotVisitor&amp;);
1164 
1165     DECLARE_EXPORT_INFO;
1166 
1167 protected:
1168     void visitChildrenCommon(SlotVisitor&amp;);
1169 
1170     void finishCreation(VM&amp; vm)
1171     {
1172         Base::finishCreation(vm);
1173         ASSERT(structure(vm)-&gt;totalStorageCapacity() == structure(vm)-&gt;inlineCapacity());
1174         ASSERT(classInfo(vm));
1175     }
1176 
1177 private:
1178     friend class LLIntOffsetsExtractor;
1179 
1180     explicit JSFinalObject(VM&amp; vm, Structure* structure, Butterfly* butterfly = nullptr)
1181         : JSObject(vm, structure, butterfly)
1182     {
1183         memset(inlineStorageUnsafe(), 0, structure-&gt;inlineCapacity() * sizeof(EncodedJSValue));
1184     }
1185 };
1186 
1187 JS_EXPORT_PRIVATE EncodedJSValue JSC_HOST_CALL objectPrivateFuncInstanceOf(ExecState*);
1188 
1189 inline JSObject* JSObject::createRawObject(
1190     ExecState* exec, Structure* structure, Butterfly* butterfly)
1191 {
1192     VM&amp; vm = exec-&gt;vm();
1193     JSObject* finalObject = new (
1194         NotNull,
1195         allocateCell&lt;JSFinalObject&gt;(
1196             vm.heap,
1197             JSFinalObject::allocationSize(structure-&gt;inlineCapacity())
1198         )
1199     ) JSObject(vm, structure, butterfly);
1200     finalObject-&gt;finishCreation(vm);
1201     return finalObject;
1202 }
1203 
1204 inline JSFinalObject* JSFinalObject::create(
1205     ExecState* exec, Structure* structure, Butterfly* butterfly)
1206 {
1207     VM&amp; vm = exec-&gt;vm();
1208     JSFinalObject* finalObject = new (
1209         NotNull,
1210         allocateCell&lt;JSFinalObject&gt;(
1211             vm.heap,
1212             allocationSize(structure-&gt;inlineCapacity())
1213         )
1214     ) JSFinalObject(vm, structure, butterfly);
1215     finalObject-&gt;finishCreation(vm);
1216     return finalObject;
1217 }
1218 
1219 inline JSFinalObject* JSFinalObject::create(VM&amp; vm, Structure* structure)
1220 {
1221     JSFinalObject* finalObject = new (NotNull, allocateCell&lt;JSFinalObject&gt;(vm.heap, allocationSize(structure-&gt;inlineCapacity()))) JSFinalObject(vm, structure);
1222     finalObject-&gt;finishCreation(vm);
1223     return finalObject;
1224 }
1225 
1226 inline size_t JSObject::offsetOfInlineStorage()
1227 {
1228     return sizeof(JSObject);
1229 }
1230 
1231 inline bool JSObject::isGlobalObject() const
1232 {
1233     return type() == GlobalObjectType;
1234 }
1235 
1236 inline bool JSObject::isJSLexicalEnvironment() const
1237 {
1238     return type() == LexicalEnvironmentType || type() == ModuleEnvironmentType;
1239 }
1240 
1241 inline bool JSObject::isGlobalLexicalEnvironment() const
1242 {
1243     return type() == GlobalLexicalEnvironmentType;
1244 }
1245 
1246 inline bool JSObject::isStrictEvalActivation() const
1247 {
1248     return type() == StrictEvalActivationType;
1249 }
1250 
1251 inline bool JSObject::isEnvironment() const
1252 {
1253     bool result = GlobalObjectType &lt;= type() &amp;&amp; type() &lt;= StrictEvalActivationType;
1254     ASSERT((isGlobalObject() || isJSLexicalEnvironment() || isGlobalLexicalEnvironment() || isStrictEvalActivation()) == result);
1255     return result;
1256 }
1257 
1258 inline bool JSObject::isErrorInstance() const
1259 {
1260     return type() == ErrorInstanceType;
1261 }
1262 
1263 inline bool JSObject::isWithScope() const
1264 {
1265     return type() == WithScopeType;
1266 }
1267 
1268 inline void JSObject::setStructure(VM&amp; vm, Structure* structure)
1269 {
1270     ASSERT(structure);
1271     ASSERT(!m_butterfly == !(structure-&gt;outOfLineCapacity() || structure-&gt;hasIndexingHeader(this)));
1272     JSCell::setStructure(vm, structure);
1273 }
1274 
1275 inline void JSObject::setButterfly(VM&amp; vm, Butterfly* butterfly)
1276 {
1277     if (isX86() || vm.heap.mutatorShouldBeFenced()) {
1278         WTF::storeStoreFence();
1279         m_butterfly.set(vm, this, butterfly);
1280         WTF::storeStoreFence();
1281         return;
1282     }
1283 
1284     m_butterfly.set(vm, this, butterfly);
1285 }
1286 
1287 inline void JSObject::nukeStructureAndSetButterfly(VM&amp; vm, StructureID oldStructureID, Butterfly* butterfly)
1288 {
1289     if (isX86() || vm.heap.mutatorShouldBeFenced()) {
1290         setStructureIDDirectly(nuke(oldStructureID));
1291         WTF::storeStoreFence();
1292         m_butterfly.set(vm, this, butterfly);
1293         WTF::storeStoreFence();
1294         return;
1295     }
1296 
1297     m_butterfly.set(vm, this, butterfly);
1298 }
1299 
1300 inline CallType getCallData(VM&amp; vm, JSValue value, CallData&amp; callData)
1301 {
1302     CallType result = value.isCell() ? value.asCell()-&gt;methodTable(vm)-&gt;getCallData(value.asCell(), callData) : CallType::None;
1303     ASSERT(result == CallType::None || value.isValidCallee());
1304     return result;
1305 }
1306 
1307 inline ConstructType getConstructData(VM&amp; vm, JSValue value, ConstructData&amp; constructData)
1308 {
1309     ConstructType result = value.isCell() ? value.asCell()-&gt;methodTable(vm)-&gt;getConstructData(value.asCell(), constructData) : ConstructType::None;
1310     ASSERT(result == ConstructType::None || value.isValidCallee());
1311     return result;
1312 }
1313 
1314 inline JSObject* asObject(JSCell* cell)
1315 {
1316     ASSERT(cell-&gt;isObject());
1317     return jsCast&lt;JSObject*&gt;(cell);
1318 }
1319 
1320 inline JSObject* asObject(JSValue value)
1321 {
1322     return asObject(value.asCell());
1323 }
1324 
1325 inline JSObject::JSObject(VM&amp; vm, Structure* structure, Butterfly* butterfly)
1326     : JSCell(vm, structure)
1327     , m_butterfly(vm, this, butterfly)
1328 {
1329 }
1330 
1331 inline JSValue JSObject::getPrototypeDirect(VM&amp; vm) const
1332 {
1333     return structure(vm)-&gt;storedPrototype(this);
1334 }
1335 
1336 inline JSValue JSObject::getPrototype(VM&amp; vm, ExecState* exec)
1337 {
1338     auto getPrototypeMethod = methodTable(vm)-&gt;getPrototype;
1339     MethodTable::GetPrototypeFunctionPtr defaultGetPrototype = JSObject::getPrototype;
1340     if (LIKELY(getPrototypeMethod == defaultGetPrototype))
1341         return getPrototypeDirect(vm);
1342     return getPrototypeMethod(this, exec);
1343 }
1344 
1345 // Normally, we never shrink the butterfly so if we know an offset is valid for some
1346 // past structure then it should be valid for any new structure. However, we may sometimes
1347 // shrink the butterfly when we are holding the Structure&#39;s ConcurrentJSLock, such as when we
1348 // flatten an object.
1349 inline JSValue JSObject::getDirectConcurrently(Structure* structure, PropertyOffset offset) const
1350 {
1351     ConcurrentJSLocker locker(structure-&gt;lock());
1352     if (!structure-&gt;isValidOffset(offset))
1353         return { };
1354     return getDirect(offset);
1355 }
1356 
1357 // It is safe to call this method with a PropertyName that is actually an index,
1358 // but if so will always return false (doesn&#39;t search index storage).
1359 ALWAYS_INLINE bool JSObject::getOwnNonIndexPropertySlot(VM&amp; vm, Structure* structure, PropertyName propertyName, PropertySlot&amp; slot)
1360 {
1361     unsigned attributes;
1362     PropertyOffset offset = structure-&gt;get(vm, propertyName, attributes);
1363     if (!isValidOffset(offset)) {
1364         if (!TypeInfo::hasStaticPropertyTable(inlineTypeFlags()))
1365             return false;
1366         return getOwnStaticPropertySlot(vm, propertyName, slot);
1367     }
1368 
1369     // getPropertySlot relies on this method never returning index properties!
1370     ASSERT(!parseIndex(propertyName));
1371 
1372     JSValue value = getDirect(offset);
1373     if (value.isCell()) {
1374         ASSERT(value);
1375         JSCell* cell = value.asCell();
1376         JSType type = cell-&gt;type();
1377         switch (type) {
1378         case GetterSetterType:
1379             fillGetterPropertySlot(vm, slot, cell, attributes, offset);
1380             return true;
1381         case CustomGetterSetterType:
1382             fillCustomGetterPropertySlot(vm, slot, jsCast&lt;CustomGetterSetter*&gt;(cell), attributes, structure);
1383             return true;
1384         default:
1385             break;
1386         }
1387     }
1388 
1389     slot.setValue(this, attributes, value, offset);
1390     return true;
1391 }
1392 
1393 ALWAYS_INLINE void JSObject::fillCustomGetterPropertySlot(VM&amp; vm, PropertySlot&amp; slot, CustomGetterSetter* customGetterSetter, unsigned attributes, Structure* structure)
1394 {
1395     ASSERT(attributes &amp; PropertyAttribute::CustomAccessorOrValue);
1396     if (customGetterSetter-&gt;inherits&lt;DOMAttributeGetterSetter&gt;(vm)) {
1397         auto* domAttribute = jsCast&lt;DOMAttributeGetterSetter*&gt;(customGetterSetter);
1398         if (structure-&gt;isUncacheableDictionary())
1399             slot.setCustom(this, attributes, domAttribute-&gt;getter(), domAttribute-&gt;domAttribute());
1400         else
1401             slot.setCacheableCustom(this, attributes, domAttribute-&gt;getter(), domAttribute-&gt;domAttribute());
1402         return;
1403     }
1404 
1405     if (structure-&gt;isUncacheableDictionary())
1406         slot.setCustom(this, attributes, customGetterSetter-&gt;getter());
1407     else
1408         slot.setCacheableCustom(this, attributes, customGetterSetter-&gt;getter());
1409 }
1410 
1411 // It may seem crazy to inline a function this large, especially a virtual function,
1412 // but it makes a big difference to property lookup that derived classes can inline their
1413 // base class call to this.
1414 ALWAYS_INLINE bool JSObject::getOwnPropertySlot(JSObject* object, ExecState* exec, PropertyName propertyName, PropertySlot&amp; slot)
1415 {
1416     VM&amp; vm = exec-&gt;vm();
1417     Structure* structure = object-&gt;structure(vm);
1418     if (object-&gt;getOwnNonIndexPropertySlot(vm, structure, propertyName, slot))
1419         return true;
1420     if (Optional&lt;uint32_t&gt; index = parseIndex(propertyName))
1421         return getOwnPropertySlotByIndex(object, exec, index.value(), slot);
1422     return false;
1423 }
1424 
1425 ALWAYS_INLINE void JSObject::doPutPropertySecurityCheck(JSObject*, ExecState*, PropertyName, PutPropertySlot&amp;)
1426 {
1427 }
1428 
1429 // It may seem crazy to inline a function this large but it makes a big difference
1430 // since this is function very hot in variable lookup
1431 template&lt;bool checkNullStructure&gt;
1432 ALWAYS_INLINE bool JSObject::getPropertySlot(ExecState* exec, PropertyName propertyName, PropertySlot&amp; slot)
1433 {
1434     VM&amp; vm = exec-&gt;vm();
1435     auto&amp; structureIDTable = vm.heap.structureIDTable();
1436     JSObject* object = this;
1437     while (true) {
1438         if (UNLIKELY(TypeInfo::overridesGetOwnPropertySlot(object-&gt;inlineTypeFlags()))) {
1439             // If propertyName is an index then we may have missed it (as this loop is using
1440             // getOwnNonIndexPropertySlot), so we cannot safely call the overridden getOwnPropertySlot
1441             // (lest we return a property from a prototype that is shadowed). Check now for an index,
1442             // if so we need to start afresh from this object.
1443             if (Optional&lt;uint32_t&gt; index = parseIndex(propertyName))
1444                 return getPropertySlot(exec, index.value(), slot);
1445             // Safe to continue searching from current position; call getNonIndexPropertySlot to avoid
1446             // parsing the int again.
1447             return object-&gt;getNonIndexPropertySlot(exec, propertyName, slot);
1448         }
1449         ASSERT(object-&gt;type() != ProxyObjectType);
1450         Structure* structure = structureIDTable.get(object-&gt;structureID());
1451 #if USE(JSVALUE64)
1452         if (checkNullStructure &amp;&amp; UNLIKELY(!structure))
1453             CRASH_WITH_INFO(object-&gt;type(), object-&gt;structureID(), structureIDTable.size());
1454 #endif
1455         if (object-&gt;getOwnNonIndexPropertySlot(vm, structure, propertyName, slot))
1456             return true;
1457         // FIXME: This doesn&#39;t look like it&#39;s following the specification:
1458         // https://bugs.webkit.org/show_bug.cgi?id=172572
1459         JSValue prototype = structure-&gt;storedPrototype(object);
1460         if (!prototype.isObject())
1461             break;
1462         object = asObject(prototype);
1463     }
1464 
1465     if (Optional&lt;uint32_t&gt; index = parseIndex(propertyName))
1466         return getPropertySlot(exec, index.value(), slot);
1467     return false;
1468 }
1469 
1470 inline JSValue JSObject::get(ExecState* exec, PropertyName propertyName) const
1471 {
1472     VM&amp; vm = exec-&gt;vm();
1473     auto scope = DECLARE_THROW_SCOPE(vm);
1474     PropertySlot slot(this, PropertySlot::InternalMethodType::Get);
1475     bool hasProperty = const_cast&lt;JSObject*&gt;(this)-&gt;getPropertySlot(exec, propertyName, slot);
1476     EXCEPTION_ASSERT(!scope.exception() || !hasProperty);
1477     if (hasProperty)
1478         RELEASE_AND_RETURN(scope, slot.getValue(exec, propertyName));
1479 
1480     return jsUndefined();
1481 }
1482 
1483 inline JSValue JSObject::get(ExecState* exec, unsigned propertyName) const
1484 {
1485     VM&amp; vm = exec-&gt;vm();
1486     auto scope = DECLARE_THROW_SCOPE(vm);
1487     PropertySlot slot(this, PropertySlot::InternalMethodType::Get);
1488     bool hasProperty = const_cast&lt;JSObject*&gt;(this)-&gt;getPropertySlot(exec, propertyName, slot);
1489     EXCEPTION_ASSERT(!scope.exception() || !hasProperty);
1490     if (hasProperty)
1491         RELEASE_AND_RETURN(scope, slot.getValue(exec, propertyName));
1492 
1493     return jsUndefined();
1494 }
1495 
1496 inline bool JSObject::putOwnDataProperty(VM&amp; vm, PropertyName propertyName, JSValue value, PutPropertySlot&amp; slot)
1497 {
1498     ASSERT(value);
1499     ASSERT(!Heap::heap(value) || Heap::heap(value) == Heap::heap(this));
1500     ASSERT(!structure(vm)-&gt;hasGetterSetterProperties());
1501     ASSERT(!structure(vm)-&gt;hasCustomGetterSetterProperties());
1502 
1503     return putDirectInternal&lt;PutModePut&gt;(vm, propertyName, value, 0, slot);
1504 }
1505 
1506 inline bool JSObject::putOwnDataPropertyMayBeIndex(ExecState* exec, PropertyName propertyName, JSValue value, PutPropertySlot&amp; slot)
1507 {
1508     VM&amp; vm = exec-&gt;vm();
1509     ASSERT(value);
1510     ASSERT(!Heap::heap(value) || Heap::heap(value) == Heap::heap(this));
1511     ASSERT(!structure(vm)-&gt;hasGetterSetterProperties());
1512     ASSERT(!structure(vm)-&gt;hasCustomGetterSetterProperties());
1513 
1514     if (Optional&lt;uint32_t&gt; index = parseIndex(propertyName))
1515         return putDirectIndex(exec, index.value(), value, 0, PutDirectIndexLikePutDirect);
1516 
1517     return putDirectInternal&lt;PutModePut&gt;(vm, propertyName, value, 0, slot);
1518 }
1519 
1520 inline bool JSObject::putDirect(VM&amp; vm, PropertyName propertyName, JSValue value, unsigned attributes)
1521 {
1522     ASSERT(!value.isGetterSetter() &amp;&amp; !(attributes &amp; PropertyAttribute::Accessor));
1523     ASSERT(!value.isCustomGetterSetter() &amp;&amp; !(attributes &amp; PropertyAttribute::CustomAccessorOrValue));
1524     PutPropertySlot slot(this);
1525     return putDirectInternal&lt;PutModeDefineOwnProperty&gt;(vm, propertyName, value, attributes, slot);
1526 }
1527 
1528 inline bool JSObject::putDirect(VM&amp; vm, PropertyName propertyName, JSValue value, PutPropertySlot&amp; slot)
1529 {
1530     ASSERT(!value.isGetterSetter());
1531     ASSERT(!value.isCustomGetterSetter());
1532     return putDirectInternal&lt;PutModeDefineOwnProperty&gt;(vm, propertyName, value, 0, slot);
1533 }
1534 
1535 ALWAYS_INLINE JSObject* Register::object() const
1536 {
1537     return asObject(jsValue());
1538 }
1539 
1540 ALWAYS_INLINE Register&amp; Register::operator=(JSObject* object)
1541 {
1542     u.value = JSValue::encode(JSValue(object));
1543     return *this;
1544 }
1545 
1546 inline size_t offsetInButterfly(PropertyOffset offset)
1547 {
1548     return offsetInOutOfLineStorage(offset) + Butterfly::indexOfPropertyStorage();
1549 }
1550 
1551 inline size_t JSObject::butterflyPreCapacity()
1552 {
1553     VM&amp; vm = this-&gt;vm();
1554     if (UNLIKELY(hasIndexingHeader(vm)))
1555         return butterfly()-&gt;indexingHeader()-&gt;preCapacity(structure(vm));
1556     return 0;
1557 }
1558 
1559 inline size_t JSObject::butterflyTotalSize()
1560 {
1561     VM&amp; vm = this-&gt;vm();
1562     Structure* structure = this-&gt;structure(vm);
1563     Butterfly* butterfly = this-&gt;butterfly();
1564     size_t preCapacity;
1565     size_t indexingPayloadSizeInBytes;
1566     bool hasIndexingHeader = this-&gt;hasIndexingHeader(vm);
1567 
1568     if (UNLIKELY(hasIndexingHeader)) {
1569         preCapacity = butterfly-&gt;indexingHeader()-&gt;preCapacity(structure);
1570         indexingPayloadSizeInBytes = butterfly-&gt;indexingHeader()-&gt;indexingPayloadSizeInBytes(structure);
1571     } else {
1572         preCapacity = 0;
1573         indexingPayloadSizeInBytes = 0;
1574     }
1575 
1576     return Butterfly::totalSize(preCapacity, structure-&gt;outOfLineCapacity(), hasIndexingHeader, indexingPayloadSizeInBytes);
1577 }
1578 
1579 inline int indexRelativeToBase(PropertyOffset offset)
1580 {
1581     if (isOutOfLineOffset(offset))
1582         return offsetInOutOfLineStorage(offset) + Butterfly::indexOfPropertyStorage();
1583     ASSERT(!(JSObject::offsetOfInlineStorage() % sizeof(EncodedJSValue)));
1584     return JSObject::offsetOfInlineStorage() / sizeof(EncodedJSValue) + offsetInInlineStorage(offset);
1585 }
1586 
1587 inline int offsetRelativeToBase(PropertyOffset offset)
1588 {
1589     if (isOutOfLineOffset(offset))
1590         return offsetInOutOfLineStorage(offset) * sizeof(EncodedJSValue) + Butterfly::offsetOfPropertyStorage();
1591     return JSObject::offsetOfInlineStorage() + offsetInInlineStorage(offset) * sizeof(EncodedJSValue);
1592 }
1593 
1594 // Returns the maximum offset (away from zero) a load instruction will encode.
1595 inline size_t maxOffsetRelativeToBase(PropertyOffset offset)
1596 {
1597     ptrdiff_t addressOffset = offsetRelativeToBase(offset);
1598 #if USE(JSVALUE32_64)
1599     if (addressOffset &gt;= 0)
1600         return static_cast&lt;size_t&gt;(addressOffset) + OBJECT_OFFSETOF(EncodedValueDescriptor, asBits.tag);
1601 #endif
1602     return static_cast&lt;size_t&gt;(addressOffset);
1603 }
1604 
1605 COMPILE_ASSERT(!(sizeof(JSObject) % sizeof(WriteBarrierBase&lt;Unknown&gt;)), JSObject_inline_storage_has_correct_alignment);
1606 
1607 template&lt;unsigned charactersCount&gt;
1608 ALWAYS_INLINE Identifier makeIdentifier(VM&amp; vm, const char (&amp;characters)[charactersCount])
1609 {
1610     return Identifier::fromString(vm, characters);
1611 }
1612 
1613 ALWAYS_INLINE Identifier makeIdentifier(VM&amp; vm, const char* name)
1614 {
1615     return Identifier::fromString(vm, name);
1616 }
1617 
1618 ALWAYS_INLINE Identifier makeIdentifier(VM&amp;, const Identifier&amp; name)
1619 {
1620     return name;
1621 }
1622 
1623 bool validateAndApplyPropertyDescriptor(ExecState*, JSObject*, PropertyName, bool isExtensible,
1624     const PropertyDescriptor&amp; descriptor, bool isCurrentDefined, const PropertyDescriptor&amp; current, bool throwException);
1625 
1626 JS_EXPORT_PRIVATE NEVER_INLINE bool ordinarySetSlow(ExecState*, JSObject*, PropertyName, JSValue, JSValue receiver, bool shouldThrow);
1627 
1628 // Helper for defining native functions, if you&#39;re not using a static hash table.
1629 // Use this macro from within finishCreation() methods in prototypes. This assumes
1630 // you&#39;ve defined variables called exec, globalObject, and vm, and they
1631 // have the expected meanings.
1632 #define JSC_NATIVE_INTRINSIC_FUNCTION(jsName, cppName, attributes, length, intrinsic) \
1633     putDirectNativeFunction(\
1634         vm, globalObject, makeIdentifier(vm, (jsName)), (length), cppName, \
1635         (intrinsic), (attributes))
1636 
1637 #define JSC_NATIVE_INTRINSIC_FUNCTION_WITHOUT_TRANSITION(jsName, cppName, attributes, length, intrinsic) \
1638     putDirectNativeFunctionWithoutTransition(\
1639         vm, globalObject, makeIdentifier(vm, (jsName)), (length), cppName, \
1640         (intrinsic), (attributes))
1641 
1642 // As above, but this assumes that the function you&#39;re defining doesn&#39;t have an
1643 // intrinsic.
1644 #define JSC_NATIVE_FUNCTION(jsName, cppName, attributes, length) \
1645     JSC_NATIVE_INTRINSIC_FUNCTION(jsName, cppName, (attributes), (length), NoIntrinsic)
1646 
1647 #define JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION(jsName, cppName, attributes, length) \
1648     JSC_NATIVE_INTRINSIC_FUNCTION_WITHOUT_TRANSITION(jsName, cppName, (attributes), (length), NoIntrinsic)
1649 
1650 // Identical helpers but for builtins. Note that currently, we don&#39;t support builtins that are
1651 // also intrinsics, but we probably will do that eventually.
1652 #define JSC_BUILTIN_FUNCTION(jsName, generatorName, attributes) \
1653     putDirectBuiltinFunction(\
1654         vm, globalObject, makeIdentifier(vm, (jsName)), (generatorName)(vm), (attributes))
1655 
1656 #define JSC_BUILTIN_FUNCTION_WITHOUT_TRANSITION(jsName, generatorName, attributes) \
1657     putDirectBuiltinFunctionWithoutTransition(\
1658         vm, globalObject, makeIdentifier(vm, (jsName)), (generatorName)(vm), (attributes))
1659 
1660 // Helper for defining native getters on properties.
1661 #define JSC_NATIVE_INTRINSIC_GETTER(jsName, cppName, attributes, intrinsic)  \
1662     putDirectNativeIntrinsicGetter(\
1663         vm, globalObject, makeIdentifier(vm, (jsName)), (cppName), \
1664         (intrinsic), ((attributes) | PropertyAttribute::Accessor))
1665 
1666 #define JSC_NATIVE_INTRINSIC_GETTER_WITHOUT_TRANSITION(jsName, cppName, attributes, intrinsic)  \
1667     putDirectNativeIntrinsicGetterWithoutTransition(\
1668         vm, globalObject, makeIdentifier(vm, (jsName)), (cppName), \
1669         (intrinsic), ((attributes) | PropertyAttribute::Accessor))
1670 
1671 #define JSC_NATIVE_GETTER(jsName, cppName, attributes) \
1672     JSC_NATIVE_INTRINSIC_GETTER((jsName), (cppName), (attributes), NoIntrinsic)
1673 
1674 #define JSC_NATIVE_GETTER_WITHOUT_TRANSITION(jsName, cppName, attributes) \
1675     JSC_NATIVE_INTRINSIC_GETTER_WITHOUT_TRANSITION((jsName), (cppName), (attributes), NoIntrinsic)
1676 
1677 } // namespace JSC
    </pre>
  </body>
</html>