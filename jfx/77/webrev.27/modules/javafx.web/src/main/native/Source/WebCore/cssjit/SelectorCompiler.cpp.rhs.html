<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/cssjit/SelectorCompiler.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (C) 2013-2018 Apple Inc. All rights reserved.
   3  * Copyright (C) 2014 Yusuke Suzuki &lt;utatane.tea@gmail.com&gt;
   4  *
   5  * Redistribution and use in source and binary forms, with or without
   6  * modification, are permitted provided that the following conditions
   7  * are met:
   8  * 1. Redistributions of source code must retain the above copyright
   9  *    notice, this list of conditions and the following disclaimer.
  10  * 2. Redistributions in binary form must reproduce the above copyright
  11  *    notice, this list of conditions and the following disclaimer in the
  12  *    documentation and/or other materials provided with the distribution.
  13  *
  14  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
  15  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
  16  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  17  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
  18  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  19  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  20  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  21  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  22  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  23  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
  24  * THE POSSIBILITY OF SUCH DAMAGE.
  25  */
  26 
  27 #include &quot;config.h&quot;
  28 #include &quot;SelectorCompiler.h&quot;
  29 
  30 #if ENABLE(CSS_SELECTOR_JIT)
  31 
  32 #include &quot;CSSSelector.h&quot;
  33 #include &quot;CSSSelectorList.h&quot;
  34 #include &quot;DOMJITHelpers.h&quot;
  35 #include &quot;Element.h&quot;
  36 #include &quot;ElementData.h&quot;
  37 #include &quot;ElementRareData.h&quot;
  38 #include &quot;FunctionCall.h&quot;
  39 #include &quot;HTMLDocument.h&quot;
  40 #include &quot;HTMLNames.h&quot;
  41 #include &quot;HTMLParserIdioms.h&quot;
  42 #include &quot;InspectorInstrumentation.h&quot;
  43 #include &quot;NodeRenderStyle.h&quot;
  44 #include &quot;QualifiedName.h&quot;
  45 #include &quot;RegisterAllocator.h&quot;
  46 #include &quot;RenderElement.h&quot;
  47 #include &quot;RenderStyle.h&quot;
  48 #include &quot;SVGElement.h&quot;
  49 #include &quot;SelectorCheckerTestFunctions.h&quot;
  50 #include &quot;StackAllocator.h&quot;
  51 #include &quot;StyleRelations.h&quot;
  52 #include &quot;StyledElement.h&quot;
  53 #include &lt;JavaScriptCore/GPRInfo.h&gt;
  54 #include &lt;JavaScriptCore/LinkBuffer.h&gt;
  55 #include &lt;JavaScriptCore/MacroAssembler.h&gt;
  56 #include &lt;JavaScriptCore/VM.h&gt;
  57 #include &lt;limits&gt;
  58 #include &lt;wtf/Deque.h&gt;
  59 #include &lt;wtf/HashMap.h&gt;
  60 #include &lt;wtf/HashSet.h&gt;
  61 #include &lt;wtf/Vector.h&gt;
  62 #include &lt;wtf/text/CString.h&gt;
  63 
  64 namespace WebCore {
  65 namespace SelectorCompiler {
  66 
  67 #define CSS_SELECTOR_JIT_DEBUGGING 0
  68 
  69 enum class BacktrackingAction {
  70     NoBacktracking,
  71     JumpToDescendantEntryPoint,
  72     JumpToIndirectAdjacentEntryPoint,
  73     JumpToDescendantTreeWalkerEntryPoint,
  74     JumpToIndirectAdjacentTreeWalkerEntryPoint,
  75     JumpToDescendantTail,
  76     JumpToDirectAdjacentTail
  77 };
  78 
  79 struct BacktrackingFlag {
  80     enum {
  81         DescendantEntryPoint = 1,
  82         IndirectAdjacentEntryPoint = 1 &lt;&lt; 1,
  83         SaveDescendantBacktrackingStart = 1 &lt;&lt; 2,
  84         SaveAdjacentBacktrackingStart = 1 &lt;&lt; 3,
  85         DirectAdjacentTail = 1 &lt;&lt; 4,
  86         DescendantTail = 1 &lt;&lt; 5,
  87         InChainWithDescendantTail = 1 &lt;&lt; 6,
  88         InChainWithAdjacentTail = 1 &lt;&lt; 7
  89     };
  90 };
  91 
  92 enum class FragmentRelation {
  93     Rightmost,
  94     Descendant,
  95     Child,
  96     DirectAdjacent,
  97     IndirectAdjacent
  98 };
  99 
 100 enum class FunctionType {
 101     SimpleSelectorChecker,
 102     SelectorCheckerWithCheckingContext,
 103     CannotMatchAnything,
 104     CannotCompile
 105 };
 106 
 107 enum class FragmentPositionInRootFragments {
 108     Rightmost,
 109     AdjacentToRightmost,
 110     Other
 111 };
 112 
 113 enum class VisitedMode {
 114     None,
 115     Visited
 116 };
 117 
 118 enum class AttributeCaseSensitivity {
 119     CaseSensitive,
 120     // Some values are matched case-insensitively for HTML elements.
 121     // That is a legacy behavior decided by HTMLDocument::isCaseSensitiveAttribute().
 122     HTMLLegacyCaseInsensitive,
 123     CaseInsensitive
 124 };
 125 
 126 static AttributeCaseSensitivity attributeSelectorCaseSensitivity(const CSSSelector&amp; selector)
 127 {
 128     ASSERT(selector.isAttributeSelector());
 129 
 130     // This is by convention, the case is irrelevant for Set.
 131     if (selector.match() == CSSSelector::Set)
 132         return AttributeCaseSensitivity::CaseSensitive;
 133 
 134     if (selector.attributeValueMatchingIsCaseInsensitive())
 135         return AttributeCaseSensitivity::CaseInsensitive;
 136     if (HTMLDocument::isCaseSensitiveAttribute(selector.attribute()))
 137         return AttributeCaseSensitivity::CaseSensitive;
 138     return AttributeCaseSensitivity::HTMLLegacyCaseInsensitive;
 139 }
 140 
 141 class AttributeMatchingInfo {
 142 public:
 143     explicit AttributeMatchingInfo(const CSSSelector&amp; selector)
 144         : m_selector(&amp;selector)
 145         , m_attributeCaseSensitivity(attributeSelectorCaseSensitivity(selector))
 146     {
 147         ASSERT(!(m_attributeCaseSensitivity == AttributeCaseSensitivity::CaseInsensitive &amp;&amp; !selector.attributeValueMatchingIsCaseInsensitive()));
 148         ASSERT(!(selector.match() == CSSSelector::Set &amp;&amp; m_attributeCaseSensitivity != AttributeCaseSensitivity::CaseSensitive));
 149     }
 150 
 151     AttributeCaseSensitivity attributeCaseSensitivity() const { return m_attributeCaseSensitivity; }
 152     const CSSSelector&amp; selector() const { return *m_selector; }
 153 
 154 private:
 155     const CSSSelector* m_selector;
 156     AttributeCaseSensitivity m_attributeCaseSensitivity;
 157 };
 158 
 159 static const unsigned invalidHeight = std::numeric_limits&lt;unsigned&gt;::max();
 160 static const unsigned invalidWidth = std::numeric_limits&lt;unsigned&gt;::max();
 161 
 162 struct SelectorFragment;
 163 class SelectorFragmentList;
 164 
 165 class SelectorList : public Vector&lt;SelectorFragmentList&gt; {
 166 public:
 167     unsigned registerRequirements = std::numeric_limits&lt;unsigned&gt;::max();
 168     unsigned stackRequirements = std::numeric_limits&lt;unsigned&gt;::max();
 169     bool clobberElementAddressRegister = true;
 170 };
 171 
 172 struct NthChildOfSelectorInfo {
 173     int a;
 174     int b;
 175     SelectorList selectorList;
 176 };
 177 
 178 struct SelectorFragment {
 179     FragmentRelation relationToLeftFragment;
 180     FragmentRelation relationToRightFragment;
 181     FragmentPositionInRootFragments positionInRootFragments;
 182     bool isRightmostOrAdjacent { false };
 183 
 184     BacktrackingAction traversalBacktrackingAction = BacktrackingAction::NoBacktracking;
 185     BacktrackingAction matchingTagNameBacktrackingAction = BacktrackingAction::NoBacktracking;
 186     BacktrackingAction matchingPostTagNameBacktrackingAction = BacktrackingAction::NoBacktracking;
 187     unsigned char backtrackingFlags = 0;
 188     unsigned tagNameMatchedBacktrackingStartHeightFromDescendant = invalidHeight;
 189     unsigned tagNameNotMatchedBacktrackingStartHeightFromDescendant = invalidHeight;
 190     unsigned heightFromDescendant = 0;
 191     unsigned tagNameMatchedBacktrackingStartWidthFromIndirectAdjacent = invalidWidth;
 192     unsigned tagNameNotMatchedBacktrackingStartWidthFromIndirectAdjacent = invalidWidth;
 193     unsigned widthFromIndirectAdjacent = 0;
 194 
 195     FunctionType appendUnoptimizedPseudoClassWithContext(bool (*matcher)(const SelectorChecker::CheckingContext&amp;));
 196 
 197     // FIXME: the large stack allocation caused by the inline capacity causes memory inefficiency. We should dump
 198     // the min/max/average of the vectors and pick better inline capacity.
 199     const CSSSelector* tagNameSelector = nullptr;
<a name="1" id="anc1"></a><span class="line-modified"> 200     const AtomString* id = nullptr;</span>
<span class="line-modified"> 201     Vector&lt;const Vector&lt;AtomString&gt;*&gt; languageArgumentsList;</span>
<span class="line-modified"> 202     Vector&lt;const AtomStringImpl*, 8&gt; classNames;</span>
 203     HashSet&lt;unsigned&gt; pseudoClasses;
 204     Vector&lt;JSC::FunctionPtr&lt;CSSOperationPtrTag&gt;, 4&gt; unoptimizedPseudoClasses;
 205     Vector&lt;JSC::FunctionPtr&lt;CSSOperationPtrTag&gt;, 4&gt; unoptimizedPseudoClassesWithContext;
 206     Vector&lt;AttributeMatchingInfo, 4&gt; attributes;
 207     Vector&lt;std::pair&lt;int, int&gt;, 2&gt; nthChildFilters;
 208     Vector&lt;NthChildOfSelectorInfo&gt; nthChildOfFilters;
 209     Vector&lt;std::pair&lt;int, int&gt;, 2&gt; nthLastChildFilters;
 210     Vector&lt;NthChildOfSelectorInfo&gt; nthLastChildOfFilters;
 211     SelectorList notFilters;
 212     Vector&lt;SelectorList&gt; matchesFilters;
 213     Vector&lt;Vector&lt;SelectorFragment&gt;&gt; anyFilters;
 214     const CSSSelector* pseudoElementSelector = nullptr;
 215 
 216     // For quirks mode, follow this: http://quirks.spec.whatwg.org/#the-:active-and-:hover-quirk
 217     // In quirks mode, a compound selector &#39;selector&#39; that matches the following conditions must not match elements that would not also match the &#39;:any-link&#39; selector.
 218     //
 219     //    selector uses the &#39;:active&#39; or &#39;:hover&#39; pseudo-classes.
 220     //    selector does not use a type selector.
 221     //    selector does not use an attribute selector.
 222     //    selector does not use an ID selector.
 223     //    selector does not use a class selector.
 224     //    selector does not use a pseudo-class selector other than &#39;:active&#39; and &#39;:hover&#39;.
 225     //    selector does not use a pseudo-element selector.
 226     //    selector is not part of an argument to a functional pseudo-class or pseudo-element.
 227     bool onlyMatchesLinksInQuirksMode = true;
 228 };
 229 
 230 class SelectorFragmentList : public Vector&lt;SelectorFragment, 4&gt; {
 231 public:
 232     unsigned registerRequirements = std::numeric_limits&lt;unsigned&gt;::max();
 233     unsigned stackRequirements = std::numeric_limits&lt;unsigned&gt;::max();
 234     unsigned staticSpecificity = 0;
 235     bool clobberElementAddressRegister = true;
 236 };
 237 
 238 struct TagNamePattern {
 239     const CSSSelector* tagNameSelector = nullptr;
 240     bool inverted = false;
 241 };
 242 
 243 typedef JSC::MacroAssembler Assembler;
 244 typedef Vector&lt;TagNamePattern, 32&gt; TagNameList;
 245 
 246 struct BacktrackingLevel {
 247     Assembler::Label descendantEntryPoint;
 248     Assembler::Label indirectAdjacentEntryPoint;
 249     Assembler::Label descendantTreeWalkerBacktrackingPoint;
 250     Assembler::Label indirectAdjacentTreeWalkerBacktrackingPoint;
 251 
 252     StackAllocator::StackReference descendantBacktrackingStart;
 253     Assembler::JumpList descendantBacktrackingFailureCases;
 254     StackAllocator::StackReference adjacentBacktrackingStart;
 255     Assembler::JumpList adjacentBacktrackingFailureCases;
 256 };
 257 
 258 class SelectorCodeGenerator {
 259 public:
 260     SelectorCodeGenerator(const CSSSelector*, SelectorContext);
 261     SelectorCompilationStatus compile(JSC::MacroAssemblerCodeRef&lt;CSSSelectorPtrTag&gt;&amp;);
 262 
 263 private:
 264     static const Assembler::RegisterID returnRegister;
 265     static const Assembler::RegisterID elementAddressRegister;
 266     static const Assembler::RegisterID checkingContextRegister;
 267     static const Assembler::RegisterID callFrameRegister;
 268 
 269     void generateSelectorChecker();
 270     void generateSelectorCheckerExcludingPseudoElements(Assembler::JumpList&amp; failureCases, const SelectorFragmentList&amp;);
 271     void generateElementMatchesSelectorList(Assembler::JumpList&amp; failureCases, Assembler::RegisterID elementToMatch, const SelectorList&amp;);
 272 
 273     // Element relations tree walker.
 274     void generateRightmostTreeWalker(Assembler::JumpList&amp; failureCases, const SelectorFragment&amp;);
 275     void generateWalkToParentNode(Assembler::RegisterID targetRegister);
 276     void generateWalkToParentElement(Assembler::JumpList&amp; failureCases, Assembler::RegisterID targetRegister);
 277     void generateWalkToParentElementOrShadowRoot(Assembler::JumpList&amp; failureCases, Assembler::RegisterID targetRegister);
 278     void generateParentElementTreeWalker(Assembler::JumpList&amp; failureCases, const SelectorFragment&amp;);
 279     void generateAncestorTreeWalker(Assembler::JumpList&amp; failureCases, const SelectorFragment&amp;);
 280 
 281     void generateWalkToNextAdjacentElement(Assembler::JumpList&amp; failureCases, Assembler::RegisterID);
 282     void generateWalkToPreviousAdjacentElement(Assembler::JumpList&amp; failureCases, Assembler::RegisterID);
 283     void generateWalkToPreviousAdjacent(Assembler::JumpList&amp; failureCases, const SelectorFragment&amp;);
 284     void generateDirectAdjacentTreeWalker(Assembler::JumpList&amp; failureCases, const SelectorFragment&amp;);
 285     void generateIndirectAdjacentTreeWalker(Assembler::JumpList&amp; failureCases, const SelectorFragment&amp;);
 286 
 287     void linkFailures(Assembler::JumpList&amp; globalFailureCases, BacktrackingAction, Assembler::JumpList&amp; localFailureCases);
 288     void generateAdjacentBacktrackingTail();
 289     void generateDescendantBacktrackingTail();
 290     void generateBacktrackingTailsIfNeeded(Assembler::JumpList&amp; failureCases, const SelectorFragment&amp;);
 291 
 292     // Element properties matchers.
 293     void generateElementMatching(Assembler::JumpList&amp; matchingTagNameFailureCases, Assembler::JumpList&amp; matchingPostTagNameFailureCases, const SelectorFragment&amp;);
 294     void generateElementDataMatching(Assembler::JumpList&amp; failureCases, const SelectorFragment&amp;);
 295     void generateElementLinkMatching(Assembler::JumpList&amp; failureCases, const SelectorFragment&amp;);
 296     void generateElementFunctionCallTest(Assembler::JumpList&amp; failureCases, JSC::FunctionPtr&lt;CSSOperationPtrTag&gt;);
 297     void generateContextFunctionCallTest(Assembler::JumpList&amp; failureCases, JSC::FunctionPtr&lt;CSSOperationPtrTag&gt;);
 298     void generateElementIsActive(Assembler::JumpList&amp; failureCases, const SelectorFragment&amp;);
 299     void generateElementIsEmpty(Assembler::JumpList&amp; failureCases);
 300     void generateElementIsFirstChild(Assembler::JumpList&amp; failureCases);
 301     void generateElementIsHovered(Assembler::JumpList&amp; failureCases, const SelectorFragment&amp;);
 302     void generateElementIsInLanguage(Assembler::JumpList&amp; failureCases, const SelectorFragment&amp;);
<a name="2" id="anc2"></a><span class="line-modified"> 303     void generateElementIsInLanguage(Assembler::JumpList&amp; failureCases, const Vector&lt;AtomString&gt;*);</span>
 304     void generateElementIsLastChild(Assembler::JumpList&amp; failureCases);
 305     void generateElementIsOnlyChild(Assembler::JumpList&amp; failureCases);
 306     void generateElementHasPlaceholderShown(Assembler::JumpList&amp; failureCases);
 307     void generateSynchronizeStyleAttribute(Assembler::RegisterID elementDataArraySizeAndFlags);
 308     void generateSynchronizeAllAnimatedSVGAttribute(Assembler::RegisterID elementDataArraySizeAndFlags);
 309     void generateElementAttributesMatching(Assembler::JumpList&amp; failureCases, const LocalRegister&amp; elementDataAddress, const SelectorFragment&amp;);
 310     void generateElementAttributeMatching(Assembler::JumpList&amp; failureCases, Assembler::RegisterID currentAttributeAddress, Assembler::RegisterID decIndexRegister, const AttributeMatchingInfo&amp; attributeInfo);
 311     void generateElementAttributeValueMatching(Assembler::JumpList&amp; failureCases, Assembler::RegisterID currentAttributeAddress, const AttributeMatchingInfo&amp; attributeInfo);
<a name="3" id="anc3"></a><span class="line-modified"> 312     void generateElementAttributeValueExactMatching(Assembler::JumpList&amp; failureCases, Assembler::RegisterID currentAttributeAddress, const AtomString&amp; expectedValue, AttributeCaseSensitivity valueCaseSensitivity);</span>
<span class="line-modified"> 313     void generateElementAttributeFunctionCallValueMatching(Assembler::JumpList&amp; failureCases, Assembler::RegisterID currentAttributeAddress, const AtomString&amp; expectedValue, AttributeCaseSensitivity valueCaseSensitivity, JSC::FunctionPtr&lt;CSSOperationPtrTag&gt; caseSensitiveTest, JSC::FunctionPtr&lt;CSSOperationPtrTag&gt; caseInsensitiveTest);</span>
 314     void generateElementHasTagName(Assembler::JumpList&amp; failureCases, const CSSSelector&amp; tagMatchingSelector);
<a name="4" id="anc4"></a><span class="line-modified"> 315     void generateElementHasId(Assembler::JumpList&amp; failureCases, const LocalRegister&amp; elementDataAddress, const AtomString&amp; idToMatch);</span>
<span class="line-modified"> 316     void generateElementHasClasses(Assembler::JumpList&amp; failureCases, const LocalRegister&amp; elementDataAddress, const Vector&lt;const AtomStringImpl*, 8&gt;&amp; classNames);</span>
 317     void generateElementIsLink(Assembler::JumpList&amp; failureCases);
 318     void generateElementIsNthChild(Assembler::JumpList&amp; failureCases, const SelectorFragment&amp;);
 319     void generateElementIsNthChildOf(Assembler::JumpList&amp; failureCases, const SelectorFragment&amp;);
 320     void generateElementIsNthLastChild(Assembler::JumpList&amp; failureCases, const SelectorFragment&amp;);
 321     void generateElementIsNthLastChildOf(Assembler::JumpList&amp; failureCases, const SelectorFragment&amp;);
 322     void generateElementMatchesNotPseudoClass(Assembler::JumpList&amp; failureCases, const SelectorFragment&amp;);
 323     void generateElementMatchesAnyPseudoClass(Assembler::JumpList&amp; failureCases, const SelectorFragment&amp;);
 324     void generateElementMatchesMatchesPseudoClass(Assembler::JumpList&amp; failureCases, const SelectorFragment&amp;);
 325     void generateElementHasPseudoElement(Assembler::JumpList&amp; failureCases, const SelectorFragment&amp;);
 326     void generateElementIsRoot(Assembler::JumpList&amp; failureCases);
 327     void generateElementIsScopeRoot(Assembler::JumpList&amp; failureCases);
 328     void generateElementIsTarget(Assembler::JumpList&amp; failureCases);
 329     void generateElementHasFocusWithin(Assembler::JumpList&amp; failureCases);
 330 
 331     // Helpers.
 332     void generateAddStyleRelationIfResolvingStyle(Assembler::RegisterID element, Style::Relation::Type, Optional&lt;Assembler::RegisterID&gt; value = { });
 333     void generateAddStyleRelation(Assembler::RegisterID checkingContext, Assembler::RegisterID element, Style::Relation::Type, Optional&lt;Assembler::RegisterID&gt; value = { });
 334     Assembler::Jump branchOnResolvingModeWithCheckingContext(Assembler::RelationalCondition, SelectorChecker::Mode, Assembler::RegisterID checkingContext);
 335     Assembler::Jump branchOnResolvingMode(Assembler::RelationalCondition, SelectorChecker::Mode, Assembler::RegisterID checkingContext);
 336     void generateElementIsFirstLink(Assembler::JumpList&amp; failureCases, Assembler::RegisterID element);
 337     void generateStoreLastVisitedElement(Assembler::RegisterID element);
 338     void generateMarkPseudoStyleForPseudoElement(Assembler::JumpList&amp; failureCases, const SelectorFragment&amp;);
 339     void generateNthFilterTest(Assembler::JumpList&amp; failureCases, Assembler::RegisterID counter, int a, int b);
 340     void generateRequestedPseudoElementEqualsToSelectorPseudoElement(Assembler::JumpList&amp; failureCases, const SelectorFragment&amp;, Assembler::RegisterID checkingContext);
 341     void generateSpecialFailureInQuirksModeForActiveAndHoverIfNeeded(Assembler::JumpList&amp; failureCases, const SelectorFragment&amp;);
 342     Assembler::JumpList jumpIfNoPreviousAdjacentElement();
 343     Assembler::JumpList jumpIfNoNextAdjacentElement();
 344     Assembler::Jump jumpIfNotResolvingStyle(Assembler::RegisterID checkingContextRegister);
 345     void loadCheckingContext(Assembler::RegisterID checkingContext);
 346     Assembler::Jump modulo(JSC::MacroAssembler::ResultCondition, Assembler::RegisterID inputDividend, int divisor);
 347     void moduloIsZero(Assembler::JumpList&amp; failureCases, Assembler::RegisterID inputDividend, int divisor);
 348 
 349     void generateNthChildParentCheckAndRelationUpdate(Assembler::JumpList&amp; failureCases, const SelectorFragment&amp;);
 350     void generateNthLastChildParentCheckAndRelationUpdate(Assembler::JumpList&amp; failureCases, const SelectorFragment&amp;);
 351 
 352     void pushMacroAssemblerRegisters();
 353     void popMacroAssemblerRegisters(StackAllocator&amp;);
 354     bool generatePrologue();
 355     void generateEpilogue(StackAllocator&amp;);
 356     StackAllocator::StackReferenceVector m_macroAssemblerRegistersStackReferences;
 357     StackAllocator::StackReferenceVector m_prologueStackReferences;
 358 
 359     Assembler m_assembler;
 360     RegisterAllocator m_registerAllocator;
 361     StackAllocator m_stackAllocator;
 362     Vector&lt;std::pair&lt;Assembler::Call, JSC::FunctionPtr&lt;CSSOperationPtrTag&gt;&gt;, 32&gt; m_functionCalls;
 363 
 364     SelectorContext m_selectorContext;
 365     FunctionType m_functionType;
 366     SelectorFragmentList m_selectorFragments;
 367     VisitedMode m_visitedMode;
 368 
 369     StackAllocator::StackReference m_checkingContextStackReference;
 370 
 371     bool m_descendantBacktrackingStartInUse;
 372     Assembler::RegisterID m_descendantBacktrackingStart;
 373     StackAllocator::StackReferenceVector m_backtrackingStack;
 374     Deque&lt;BacktrackingLevel, 32&gt; m_backtrackingLevels;
 375     StackAllocator::StackReference m_lastVisitedElement;
 376     StackAllocator::StackReference m_startElement;
 377 
 378 #if CSS_SELECTOR_JIT_DEBUGGING
 379     const CSSSelector* m_originalSelector;
 380 #endif
 381 };
 382 
 383 const Assembler::RegisterID SelectorCodeGenerator::returnRegister = JSC::GPRInfo::returnValueGPR;
 384 const Assembler::RegisterID SelectorCodeGenerator::elementAddressRegister = JSC::GPRInfo::argumentGPR0;
 385 const Assembler::RegisterID SelectorCodeGenerator::checkingContextRegister = JSC::GPRInfo::argumentGPR1;
 386 const Assembler::RegisterID SelectorCodeGenerator::callFrameRegister = JSC::GPRInfo::callFrameRegister;
 387 
 388 enum class FragmentsLevel {
 389     Root = 0,
 390     InFunctionalPseudoType = 1
 391 };
 392 
 393 enum class PseudoElementMatchingBehavior { CanMatch, NeverMatch };
 394 
 395 static FunctionType constructFragments(const CSSSelector* rootSelector, SelectorContext, SelectorFragmentList&amp; selectorFragments, FragmentsLevel, FragmentPositionInRootFragments, bool visitedMatchEnabled, VisitedMode&amp;, PseudoElementMatchingBehavior);
 396 
 397 static void computeBacktrackingInformation(SelectorFragmentList&amp; selectorFragments, unsigned level = 0);
 398 
 399 SelectorCompilationStatus compileSelector(const CSSSelector* lastSelector, SelectorContext selectorContext, JSC::MacroAssemblerCodeRef&lt;CSSSelectorPtrTag&gt;&amp; codeRef)
 400 {
 401     if (!JSC::VM::canUseJIT())
 402         return SelectorCompilationStatus::CannotCompile;
 403     SelectorCodeGenerator codeGenerator(lastSelector, selectorContext);
 404     return codeGenerator.compile(codeRef);
 405 }
 406 
 407 static inline FragmentRelation fragmentRelationForSelectorRelation(CSSSelector::RelationType relation)
 408 {
 409     switch (relation) {
 410     case CSSSelector::DescendantSpace:
 411         return FragmentRelation::Descendant;
 412     case CSSSelector::Child:
 413         return FragmentRelation::Child;
 414     case CSSSelector::DirectAdjacent:
 415         return FragmentRelation::DirectAdjacent;
 416     case CSSSelector::IndirectAdjacent:
 417         return FragmentRelation::IndirectAdjacent;
 418     case CSSSelector::Subselector:
 419     case CSSSelector::ShadowDescendant:
 420         ASSERT_NOT_REACHED();
 421     }
 422     ASSERT_NOT_REACHED();
 423     return FragmentRelation::Descendant;
 424 }
 425 
 426 static inline FunctionType mostRestrictiveFunctionType(FunctionType a, FunctionType b)
 427 {
 428     return std::max(a, b);
 429 }
 430 
 431 static inline bool fragmentMatchesTheRightmostElement(const SelectorFragment&amp; fragment)
 432 {
 433     return fragment.relationToRightFragment == FragmentRelation::Rightmost &amp;&amp; fragment.positionInRootFragments == FragmentPositionInRootFragments::Rightmost;
 434 }
 435 
 436 static inline bool fragmentMatchesRightmostOrAdjacentElement(const SelectorFragment&amp; fragment)
 437 {
 438     return fragment.isRightmostOrAdjacent &amp;&amp; fragment.positionInRootFragments != FragmentPositionInRootFragments::Other;
 439 }
 440 
 441 FunctionType SelectorFragment::appendUnoptimizedPseudoClassWithContext(bool (*matcher)(const SelectorChecker::CheckingContext&amp;))
 442 {
 443     unoptimizedPseudoClassesWithContext.append(JSC::FunctionPtr&lt;CSSOperationPtrTag&gt;(matcher));
 444     return FunctionType::SelectorCheckerWithCheckingContext;
 445 }
 446 
 447 static inline FunctionType addScrollbarPseudoClassType(const CSSSelector&amp;, SelectorFragment&amp;)
 448 {
 449     // FIXME: scrollbar pseudoclass interaction with :not doesn&#39;t behave correctly.
 450     // Compile them when they are fixed and tested.
 451     // https://bugs.webkit.org/show_bug.cgi?id=146221
 452     return FunctionType::CannotCompile;
 453 }
 454 
 455 // Handle the forward :nth-child() and backward :nth-last-child().
 456 static FunctionType addNthChildType(const CSSSelector&amp; selector, SelectorContext selectorContext, FragmentPositionInRootFragments positionInRootFragments, CSSSelector::PseudoClassType firstMatchAlternative, bool visitedMatchEnabled, Vector&lt;std::pair&lt;int, int&gt;, 2&gt;&amp; simpleCases, Vector&lt;NthChildOfSelectorInfo&gt;&amp; filteredCases, HashSet&lt;unsigned&gt;&amp; pseudoClasses, unsigned&amp; internalSpecificity)
 457 {
 458     int a = selector.nthA();
 459     int b = selector.nthB();
 460 
 461     // The element count is always positive.
 462     if (a &lt;= 0 &amp;&amp; b &lt; 1)
 463         return FunctionType::CannotMatchAnything;
 464 
 465     if (const CSSSelectorList* selectorList = selector.selectorList()) {
 466         NthChildOfSelectorInfo nthChildOfSelectorInfo;
 467         nthChildOfSelectorInfo.a = a;
 468         nthChildOfSelectorInfo.b = b;
 469 
 470         FunctionType globalFunctionType = FunctionType::SimpleSelectorChecker;
 471         if (selectorContext != SelectorContext::QuerySelector)
 472             globalFunctionType = FunctionType::SelectorCheckerWithCheckingContext;
 473 
 474         unsigned firstFragmentListSpecificity = 0;
 475         bool firstFragmentListSpecificitySet = false;
 476 
 477         SelectorFragmentList* selectorFragments = nullptr;
 478         for (const CSSSelector* subselector = selectorList-&gt;first(); subselector; subselector = CSSSelectorList::next(subselector)) {
 479             if (!selectorFragments) {
 480                 nthChildOfSelectorInfo.selectorList.append(SelectorFragmentList());
 481                 selectorFragments = &amp;nthChildOfSelectorInfo.selectorList.last();
 482             }
 483 
 484             VisitedMode ignoreVisitedMode = VisitedMode::None;
 485             FunctionType functionType = constructFragments(subselector, selectorContext, *selectorFragments, FragmentsLevel::InFunctionalPseudoType, positionInRootFragments, visitedMatchEnabled, ignoreVisitedMode, PseudoElementMatchingBehavior::NeverMatch);
 486             ASSERT_WITH_MESSAGE(ignoreVisitedMode == VisitedMode::None, &quot;:visited is disabled in the functional pseudo classes&quot;);
 487             switch (functionType) {
 488             case FunctionType::SimpleSelectorChecker:
 489             case FunctionType::SelectorCheckerWithCheckingContext:
 490                 break;
 491             case FunctionType::CannotMatchAnything:
 492                 continue;
 493             case FunctionType::CannotCompile:
 494                 return FunctionType::CannotCompile;
 495             }
 496 
 497             if (firstFragmentListSpecificitySet) {
 498                 // The CSS JIT does not handle dynamic specificity yet.
 499                 if (selectorContext == SelectorContext::RuleCollector &amp;&amp; selectorFragments-&gt;staticSpecificity != firstFragmentListSpecificity)
 500                     return FunctionType::CannotCompile;
 501             } else {
 502                 firstFragmentListSpecificitySet = true;
 503                 firstFragmentListSpecificity = selectorFragments-&gt;staticSpecificity;
 504             }
 505 
 506             globalFunctionType = mostRestrictiveFunctionType(globalFunctionType, functionType);
 507             selectorFragments = nullptr;
 508         }
 509 
 510         // If there is still a SelectorFragmentList open, the last Fragment(s) cannot match anything,
 511         // we have one FragmentList too many in our selector list.
 512         if (selectorFragments)
 513             nthChildOfSelectorInfo.selectorList.removeLast();
 514 
 515         if (nthChildOfSelectorInfo.selectorList.isEmpty())
 516             return FunctionType::CannotMatchAnything;
 517 
 518         internalSpecificity = firstFragmentListSpecificity;
 519         filteredCases.append(nthChildOfSelectorInfo);
 520         return globalFunctionType;
 521     }
 522 
 523     if (b == 1 &amp;&amp; a &lt;= 0)
 524         pseudoClasses.add(firstMatchAlternative);
 525     else
 526         simpleCases.append(std::pair&lt;int, int&gt;(a, b));
 527     if (selectorContext == SelectorContext::QuerySelector)
 528         return FunctionType::SimpleSelectorChecker;
 529     return FunctionType::SelectorCheckerWithCheckingContext;
 530 }
 531 
 532 static inline FunctionType addPseudoClassType(const CSSSelector&amp; selector, SelectorFragment&amp; fragment, unsigned&amp; internalSpecificity, SelectorContext selectorContext, FragmentsLevel fragmentLevel, FragmentPositionInRootFragments positionInRootFragments, bool visitedMatchEnabled, VisitedMode&amp; visitedMode, PseudoElementMatchingBehavior pseudoElementMatchingBehavior)
 533 {
 534     CSSSelector::PseudoClassType type = selector.pseudoClassType();
 535     switch (type) {
 536     // Unoptimized pseudo selector. They are just function call to a simple testing function.
 537     case CSSSelector::PseudoClassAutofill:
 538         fragment.unoptimizedPseudoClasses.append(JSC::FunctionPtr&lt;CSSOperationPtrTag&gt;(isAutofilled));
 539         return FunctionType::SimpleSelectorChecker;
 540     case CSSSelector::PseudoClassAutofillStrongPassword:
 541         fragment.unoptimizedPseudoClasses.append(JSC::FunctionPtr&lt;CSSOperationPtrTag&gt;(isAutofilledStrongPassword));
 542         return FunctionType::SimpleSelectorChecker;
<a name="5" id="anc5"></a><span class="line-added"> 543     case CSSSelector::PseudoClassAutofillStrongPasswordViewable:</span>
<span class="line-added"> 544         fragment.unoptimizedPseudoClasses.append(JSC::FunctionPtr&lt;CSSOperationPtrTag&gt;(isAutofilledStrongPasswordViewable));</span>
<span class="line-added"> 545         return FunctionType::SimpleSelectorChecker;</span>
 546     case CSSSelector::PseudoClassChecked:
 547         fragment.unoptimizedPseudoClasses.append(JSC::FunctionPtr&lt;CSSOperationPtrTag&gt;(isChecked));
 548         return FunctionType::SimpleSelectorChecker;
 549     case CSSSelector::PseudoClassDefault:
 550         fragment.unoptimizedPseudoClasses.append(JSC::FunctionPtr&lt;CSSOperationPtrTag&gt;(matchesDefaultPseudoClass));
 551         return FunctionType::SimpleSelectorChecker;
 552     case CSSSelector::PseudoClassDisabled:
 553         fragment.unoptimizedPseudoClasses.append(JSC::FunctionPtr&lt;CSSOperationPtrTag&gt;(matchesDisabledPseudoClass));
 554         return FunctionType::SimpleSelectorChecker;
 555     case CSSSelector::PseudoClassEnabled:
 556         fragment.unoptimizedPseudoClasses.append(JSC::FunctionPtr&lt;CSSOperationPtrTag&gt;(matchesEnabledPseudoClass));
 557         return FunctionType::SimpleSelectorChecker;
 558     case CSSSelector::PseudoClassDefined:
 559         fragment.unoptimizedPseudoClasses.append(JSC::FunctionPtr&lt;CSSOperationPtrTag&gt;(isDefinedElement));
 560         return FunctionType::SimpleSelectorChecker;
 561     case CSSSelector::PseudoClassFocus:
 562         fragment.unoptimizedPseudoClasses.append(JSC::FunctionPtr&lt;CSSOperationPtrTag&gt;(SelectorChecker::matchesFocusPseudoClass));
 563         return FunctionType::SimpleSelectorChecker;
 564     case CSSSelector::PseudoClassFullPageMedia:
 565         fragment.unoptimizedPseudoClasses.append(JSC::FunctionPtr&lt;CSSOperationPtrTag&gt;(isMediaDocument));
 566         return FunctionType::SimpleSelectorChecker;
 567     case CSSSelector::PseudoClassInRange:
 568         fragment.unoptimizedPseudoClasses.append(JSC::FunctionPtr&lt;CSSOperationPtrTag&gt;(isInRange));
 569         return FunctionType::SimpleSelectorChecker;
 570     case CSSSelector::PseudoClassIndeterminate:
 571         fragment.unoptimizedPseudoClasses.append(JSC::FunctionPtr&lt;CSSOperationPtrTag&gt;(matchesIndeterminatePseudoClass));
 572         return FunctionType::SimpleSelectorChecker;
 573     case CSSSelector::PseudoClassInvalid:
 574         fragment.unoptimizedPseudoClasses.append(JSC::FunctionPtr&lt;CSSOperationPtrTag&gt;(isInvalid));
 575         return FunctionType::SimpleSelectorChecker;
 576     case CSSSelector::PseudoClassOptional:
 577         fragment.unoptimizedPseudoClasses.append(JSC::FunctionPtr&lt;CSSOperationPtrTag&gt;(isOptionalFormControl));
 578         return FunctionType::SimpleSelectorChecker;
 579     case CSSSelector::PseudoClassOutOfRange:
 580         fragment.unoptimizedPseudoClasses.append(JSC::FunctionPtr&lt;CSSOperationPtrTag&gt;(isOutOfRange));
 581         return FunctionType::SimpleSelectorChecker;
 582     case CSSSelector::PseudoClassReadOnly:
 583         fragment.unoptimizedPseudoClasses.append(JSC::FunctionPtr&lt;CSSOperationPtrTag&gt;(matchesReadOnlyPseudoClass));
 584         return FunctionType::SimpleSelectorChecker;
 585     case CSSSelector::PseudoClassReadWrite:
 586         fragment.unoptimizedPseudoClasses.append(JSC::FunctionPtr&lt;CSSOperationPtrTag&gt;(matchesReadWritePseudoClass));
 587         return FunctionType::SimpleSelectorChecker;
 588     case CSSSelector::PseudoClassRequired:
 589         fragment.unoptimizedPseudoClasses.append(JSC::FunctionPtr&lt;CSSOperationPtrTag&gt;(isRequiredFormControl));
 590         return FunctionType::SimpleSelectorChecker;
 591     case CSSSelector::PseudoClassValid:
 592         fragment.unoptimizedPseudoClasses.append(JSC::FunctionPtr&lt;CSSOperationPtrTag&gt;(isValid));
 593         return FunctionType::SimpleSelectorChecker;
 594     case CSSSelector::PseudoClassWindowInactive:
 595         fragment.unoptimizedPseudoClasses.append(JSC::FunctionPtr&lt;CSSOperationPtrTag&gt;(isWindowInactive));
 596         return FunctionType::SimpleSelectorChecker;
 597 
 598 #if ENABLE(FULLSCREEN_API)
 599     case CSSSelector::PseudoClassFullScreen:
 600         fragment.unoptimizedPseudoClasses.append(JSC::FunctionPtr&lt;CSSOperationPtrTag&gt;(matchesFullScreenPseudoClass));
 601         return FunctionType::SimpleSelectorChecker;
 602     case CSSSelector::PseudoClassFullScreenDocument:
 603         fragment.unoptimizedPseudoClasses.append(JSC::FunctionPtr&lt;CSSOperationPtrTag&gt;(matchesFullScreenDocumentPseudoClass));
 604         return FunctionType::SimpleSelectorChecker;
 605     case CSSSelector::PseudoClassFullScreenAncestor:
 606         fragment.unoptimizedPseudoClasses.append(JSC::FunctionPtr&lt;CSSOperationPtrTag&gt;(matchesFullScreenAncestorPseudoClass));
 607         return FunctionType::SimpleSelectorChecker;
 608     case CSSSelector::PseudoClassAnimatingFullScreenTransition:
 609         fragment.unoptimizedPseudoClasses.append(JSC::FunctionPtr&lt;CSSOperationPtrTag&gt;(matchesFullScreenAnimatingFullScreenTransitionPseudoClass));
 610         return FunctionType::SimpleSelectorChecker;
 611 
 612     case CSSSelector::PseudoClassFullScreenControlsHidden:
 613         fragment.unoptimizedPseudoClasses.append(JSC::FunctionPtr&lt;CSSOperationPtrTag&gt;(matchesFullScreenControlsHiddenPseudoClass));
 614         return FunctionType::SimpleSelectorChecker;
 615 #endif
 616 #if ENABLE(VIDEO_TRACK)
 617     case CSSSelector::PseudoClassFuture:
 618         fragment.unoptimizedPseudoClasses.append(JSC::FunctionPtr&lt;CSSOperationPtrTag&gt;(matchesFutureCuePseudoClass));
 619         return FunctionType::SimpleSelectorChecker;
 620     case CSSSelector::PseudoClassPast:
 621         fragment.unoptimizedPseudoClasses.append(JSC::FunctionPtr&lt;CSSOperationPtrTag&gt;(matchesPastCuePseudoClass));
 622         return FunctionType::SimpleSelectorChecker;
 623 #endif
 624 
 625 #if ENABLE(ATTACHMENT_ELEMENT)
 626     case CSSSelector::PseudoClassHasAttachment:
 627         fragment.unoptimizedPseudoClasses.append(JSC::FunctionPtr&lt;CSSOperationPtrTag&gt;(hasAttachment));
 628         return FunctionType::SimpleSelectorChecker;
 629 #endif
 630 
 631     // These pseudo-classes only have meaning with scrollbars.
 632     case CSSSelector::PseudoClassHorizontal:
 633     case CSSSelector::PseudoClassVertical:
 634     case CSSSelector::PseudoClassDecrement:
 635     case CSSSelector::PseudoClassIncrement:
 636     case CSSSelector::PseudoClassStart:
 637     case CSSSelector::PseudoClassEnd:
 638     case CSSSelector::PseudoClassDoubleButton:
 639     case CSSSelector::PseudoClassSingleButton:
 640     case CSSSelector::PseudoClassNoButton:
 641     case CSSSelector::PseudoClassCornerPresent:
 642         return FunctionType::CannotMatchAnything;
 643 
 644     // FIXME: Compile these pseudoclasses, too!
 645     case CSSSelector::PseudoClassFirstOfType:
 646     case CSSSelector::PseudoClassLastOfType:
 647     case CSSSelector::PseudoClassOnlyOfType:
 648     case CSSSelector::PseudoClassNthOfType:
 649     case CSSSelector::PseudoClassNthLastOfType:
 650     case CSSSelector::PseudoClassDrag:
 651 #if ENABLE(CSS_SELECTORS_LEVEL4)
 652     case CSSSelector::PseudoClassDir:
 653     case CSSSelector::PseudoClassRole:
 654 #endif
 655         return FunctionType::CannotCompile;
 656 
 657     // Optimized pseudo selectors.
 658     case CSSSelector::PseudoClassAnyLink:
 659     case CSSSelector::PseudoClassLink:
 660     case CSSSelector::PseudoClassRoot:
 661     case CSSSelector::PseudoClassTarget:
 662         fragment.pseudoClasses.add(type);
 663         return FunctionType::SimpleSelectorChecker;
 664     case CSSSelector::PseudoClassAnyLinkDeprecated:
 665         fragment.pseudoClasses.add(CSSSelector::PseudoClassAnyLink);
 666         return FunctionType::SimpleSelectorChecker;
 667 
 668     case CSSSelector::PseudoClassVisited:
 669         // Determine this :visited cannot match anything statically.
 670         if (!visitedMatchEnabled)
 671             return FunctionType::CannotMatchAnything;
 672 
 673         // Inside functional pseudo class except for :not, :visited never matches.
 674         // And in the case inside :not, returning CannotMatchAnything indicates that :not(:visited) can match over anything.
 675         if (fragmentLevel == FragmentsLevel::InFunctionalPseudoType)
 676             return FunctionType::CannotMatchAnything;
 677 
 678         fragment.pseudoClasses.add(type);
 679         visitedMode = VisitedMode::Visited;
 680         return FunctionType::SimpleSelectorChecker;
 681 
 682     case CSSSelector::PseudoClassScope:
 683         if (selectorContext != SelectorContext::QuerySelector) {
 684             fragment.pseudoClasses.add(CSSSelector::PseudoClassRoot);
 685             return FunctionType::SimpleSelectorChecker;
 686         }
 687         fragment.pseudoClasses.add(CSSSelector::PseudoClassScope);
 688         return FunctionType::SelectorCheckerWithCheckingContext;
 689 
 690     case CSSSelector::PseudoClassActive:
 691     case CSSSelector::PseudoClassEmpty:
 692     case CSSSelector::PseudoClassFirstChild:
 693     case CSSSelector::PseudoClassHover:
 694     case CSSSelector::PseudoClassLastChild:
 695     case CSSSelector::PseudoClassOnlyChild:
 696     case CSSSelector::PseudoClassPlaceholderShown:
 697     case CSSSelector::PseudoClassFocusWithin:
 698         fragment.pseudoClasses.add(type);
 699         if (selectorContext == SelectorContext::QuerySelector)
 700             return FunctionType::SimpleSelectorChecker;
 701         return FunctionType::SelectorCheckerWithCheckingContext;
 702 
 703     case CSSSelector::PseudoClassNthChild:
 704         return addNthChildType(selector, selectorContext, positionInRootFragments, CSSSelector::PseudoClassFirstChild, visitedMatchEnabled, fragment.nthChildFilters, fragment.nthChildOfFilters, fragment.pseudoClasses, internalSpecificity);
 705 
 706     case CSSSelector::PseudoClassNthLastChild:
 707         return addNthChildType(selector, selectorContext, positionInRootFragments, CSSSelector::PseudoClassLastChild, visitedMatchEnabled, fragment.nthLastChildFilters, fragment.nthLastChildOfFilters, fragment.pseudoClasses, internalSpecificity);
 708 
 709     case CSSSelector::PseudoClassNot:
 710         {
 711             const CSSSelectorList* selectorList = selector.selectorList();
 712 
 713             ASSERT_WITH_MESSAGE(selectorList, &quot;The CSS Parser should never produce valid :not() CSSSelector with an empty selectorList.&quot;);
 714             if (!selectorList)
 715                 return FunctionType::CannotMatchAnything;
 716 
 717             FunctionType functionType = FunctionType::SimpleSelectorChecker;
 718             SelectorFragmentList* selectorFragments = nullptr;
 719             for (const CSSSelector* subselector = selectorList-&gt;first(); subselector; subselector = CSSSelectorList::next(subselector)) {
 720                 if (!selectorFragments) {
 721                     fragment.notFilters.append(SelectorFragmentList());
 722                     selectorFragments = &amp;fragment.notFilters.last();
 723                 }
 724 
 725                 VisitedMode ignoreVisitedMode = VisitedMode::None;
 726                 FunctionType localFunctionType = constructFragments(subselector, selectorContext, *selectorFragments, FragmentsLevel::InFunctionalPseudoType, positionInRootFragments, visitedMatchEnabled, ignoreVisitedMode, PseudoElementMatchingBehavior::NeverMatch);
 727                 ASSERT_WITH_MESSAGE(ignoreVisitedMode == VisitedMode::None, &quot;:visited is disabled in the functional pseudo classes&quot;);
 728 
 729                 // Since this is not pseudo class filter, CannotMatchAnything implies this filter always passes.
 730                 if (localFunctionType == FunctionType::CannotMatchAnything)
 731                     continue;
 732 
 733                 if (localFunctionType == FunctionType::CannotCompile)
 734                     return FunctionType::CannotCompile;
 735 
 736                 functionType = mostRestrictiveFunctionType(functionType, localFunctionType);
 737                 selectorFragments = nullptr;
 738             }
 739 
 740             // If there is still a SelectorFragmentList open, the last Fragment(s) cannot match anything,
 741             // we have one FragmentList too many in our selector list.
 742             if (selectorFragments)
 743                 fragment.notFilters.removeLast();
 744 
 745             return functionType;
 746         }
 747 
 748     case CSSSelector::PseudoClassAny:
 749         {
 750             Vector&lt;SelectorFragment, 32&gt; anyFragments;
 751             FunctionType functionType = FunctionType::SimpleSelectorChecker;
 752             for (const CSSSelector* rootSelector = selector.selectorList()-&gt;first(); rootSelector; rootSelector = CSSSelectorList::next(rootSelector)) {
 753                 SelectorFragmentList fragmentList;
 754                 VisitedMode ignoreVisitedMode = VisitedMode::None;
 755                 FunctionType subFunctionType = constructFragments(rootSelector, selectorContext, fragmentList, FragmentsLevel::InFunctionalPseudoType, positionInRootFragments, visitedMatchEnabled, ignoreVisitedMode, PseudoElementMatchingBehavior::NeverMatch);
 756                 ASSERT_WITH_MESSAGE(ignoreVisitedMode == VisitedMode::None, &quot;:visited is disabled in the functional pseudo classes&quot;);
 757 
 758                 // Since this fragment always unmatch against the element, don&#39;t insert it to anyFragments.
 759                 if (subFunctionType == FunctionType::CannotMatchAnything)
 760                     continue;
 761 
 762                 if (subFunctionType == FunctionType::CannotCompile)
 763                     return FunctionType::CannotCompile;
 764 
 765                 // :any() may not contain complex selectors which have combinators.
 766                 ASSERT(fragmentList.size() == 1);
 767                 if (fragmentList.size() != 1)
 768                     return FunctionType::CannotCompile;
 769 
 770                 const SelectorFragment&amp; subFragment = fragmentList.first();
 771                 anyFragments.append(subFragment);
 772                 functionType = mostRestrictiveFunctionType(functionType, subFunctionType);
 773             }
 774 
 775             // Since all fragments in :any() cannot match anything, this :any() filter cannot match anything.
 776             if (anyFragments.isEmpty())
 777                 return FunctionType::CannotMatchAnything;
 778 
 779             ASSERT(!anyFragments.isEmpty());
 780             fragment.anyFilters.append(anyFragments);
 781 
 782             return functionType;
 783         }
 784 
 785     case CSSSelector::PseudoClassLang:
 786         {
<a name="6" id="anc6"></a><span class="line-modified"> 787             const Vector&lt;AtomString&gt;* selectorLangArgumentList = selector.langArgumentList();</span>
 788             ASSERT(selectorLangArgumentList &amp;&amp; !selectorLangArgumentList-&gt;isEmpty());
 789             fragment.languageArgumentsList.append(selectorLangArgumentList);
 790             return FunctionType::SimpleSelectorChecker;
 791         }
 792 
 793     case CSSSelector::PseudoClassMatches:
 794         {
 795             SelectorList matchesList;
 796             const CSSSelectorList* selectorList = selector.selectorList();
 797             FunctionType functionType = FunctionType::SimpleSelectorChecker;
 798             unsigned firstFragmentListSpecificity = 0;
 799             bool firstFragmentListSpecificitySet = false;
 800             SelectorFragmentList* selectorFragments = nullptr;
 801             for (const CSSSelector* subselector = selectorList-&gt;first(); subselector; subselector = CSSSelectorList::next(subselector)) {
 802                 if (!selectorFragments) {
 803                     matchesList.append(SelectorFragmentList());
 804                     selectorFragments = &amp;matchesList.last();
 805                 }
 806 
 807                 VisitedMode ignoreVisitedMode = VisitedMode::None;
 808                 FunctionType localFunctionType = constructFragments(subselector, selectorContext, *selectorFragments, FragmentsLevel::InFunctionalPseudoType, positionInRootFragments, visitedMatchEnabled, ignoreVisitedMode, pseudoElementMatchingBehavior);
 809                 ASSERT_WITH_MESSAGE(ignoreVisitedMode == VisitedMode::None, &quot;:visited is disabled in the functional pseudo classes&quot;);
 810 
 811                 // Since this fragment never matches against the element, don&#39;t insert it to matchesList.
 812                 if (localFunctionType == FunctionType::CannotMatchAnything)
 813                     continue;
 814 
 815                 if (localFunctionType == FunctionType::CannotCompile)
 816                     return FunctionType::CannotCompile;
 817 
 818                 // FIXME: Currently pseudo elements inside :matches are supported in non-JIT code.
 819                 if (selectorFragments-&gt;first().pseudoElementSelector)
 820                     return FunctionType::CannotCompile;
 821 
 822                 if (firstFragmentListSpecificitySet) {
 823                     // The CSS JIT does not handle dynamic specificity yet.
 824                     if (selectorContext == SelectorContext::RuleCollector &amp;&amp; selectorFragments-&gt;staticSpecificity != firstFragmentListSpecificity)
 825                         return FunctionType::CannotCompile;
 826                 } else {
 827                     firstFragmentListSpecificitySet = true;
 828                     firstFragmentListSpecificity = selectorFragments-&gt;staticSpecificity;
 829                 }
 830 
 831                 functionType = mostRestrictiveFunctionType(functionType, localFunctionType);
 832                 selectorFragments = nullptr;
 833             }
 834 
 835             // If there is still a SelectorFragmentList open, the last Fragment(s) cannot match anything,
 836             // we have one FragmentList too many in our selector list.
 837             if (selectorFragments)
 838                 matchesList.removeLast();
 839 
 840             // Since all selector list in :matches() cannot match anything, the whole :matches() filter cannot match anything.
 841             if (matchesList.isEmpty())
 842                 return FunctionType::CannotMatchAnything;
 843 
 844             internalSpecificity = firstFragmentListSpecificity;
 845 
 846             fragment.matchesFilters.append(matchesList);
 847 
 848             return functionType;
 849         }
 850     case CSSSelector::PseudoClassHost:
 851         return FunctionType::CannotCompile;
 852     case CSSSelector::PseudoClassUnknown:
 853         ASSERT_NOT_REACHED();
 854         return FunctionType::CannotMatchAnything;
 855     }
 856 
 857     ASSERT_NOT_REACHED();
 858     return FunctionType::CannotCompile;
 859 }
 860 
 861 inline SelectorCodeGenerator::SelectorCodeGenerator(const CSSSelector* rootSelector, SelectorContext selectorContext)
 862     : m_stackAllocator(m_assembler)
 863     , m_selectorContext(selectorContext)
 864     , m_functionType(FunctionType::SimpleSelectorChecker)
 865     , m_visitedMode(VisitedMode::None)
 866     , m_descendantBacktrackingStartInUse(false)
 867 #if CSS_SELECTOR_JIT_DEBUGGING
 868     , m_originalSelector(rootSelector)
 869 #endif
 870 {
 871 #if CSS_SELECTOR_JIT_DEBUGGING
 872     dataLogF(&quot;Compiling \&quot;%s\&quot;\n&quot;, m_originalSelector-&gt;selectorText().utf8().data());
 873 #endif
 874 
 875     // In QuerySelector context, :visited always has no effect due to security issues.
 876     bool visitedMatchEnabled = selectorContext != SelectorContext::QuerySelector;
 877 
 878     m_functionType = constructFragments(rootSelector, m_selectorContext, m_selectorFragments, FragmentsLevel::Root, FragmentPositionInRootFragments::Rightmost, visitedMatchEnabled, m_visitedMode, PseudoElementMatchingBehavior::CanMatch);
 879     if (m_functionType != FunctionType::CannotCompile &amp;&amp; m_functionType != FunctionType::CannotMatchAnything)
 880         computeBacktrackingInformation(m_selectorFragments);
 881 }
 882 
 883 static bool pseudoClassOnlyMatchesLinksInQuirksMode(const CSSSelector&amp; selector)
 884 {
 885     CSSSelector::PseudoClassType pseudoClassType = selector.pseudoClassType();
 886     return pseudoClassType == CSSSelector::PseudoClassHover || pseudoClassType == CSSSelector::PseudoClassActive;
 887 }
 888 
 889 static bool isScrollbarPseudoElement(CSSSelector::PseudoElementType type)
 890 {
 891     return type &gt;= CSSSelector::PseudoElementScrollbar &amp;&amp; type &lt;= CSSSelector::PseudoElementScrollbarTrackPiece;
 892 }
 893 
 894 static FunctionType constructFragmentsInternal(const CSSSelector* rootSelector, SelectorContext selectorContext, SelectorFragmentList&amp; selectorFragments, FragmentsLevel fragmentLevel, FragmentPositionInRootFragments positionInRootFragments, bool visitedMatchEnabled, VisitedMode&amp; visitedMode, PseudoElementMatchingBehavior pseudoElementMatchingBehavior)
 895 {
 896     FragmentRelation relationToPreviousFragment = FragmentRelation::Rightmost;
 897     bool isRightmostOrAdjacent = positionInRootFragments != FragmentPositionInRootFragments::Other;
 898     FunctionType functionType = FunctionType::SimpleSelectorChecker;
 899     SelectorFragment* fragment = nullptr;
 900     unsigned specificity = 0;
 901     for (const CSSSelector* selector = rootSelector; selector; selector = selector-&gt;tagHistory()) {
 902         if (!fragment) {
 903             selectorFragments.append(SelectorFragment());
 904             fragment = &amp;selectorFragments.last();
 905         }
 906 
 907         specificity = CSSSelector::addSpecificities(specificity, selector-&gt;simpleSelectorSpecificity());
 908 
 909         // A selector is invalid if something follows a pseudo-element.
 910         // We make an exception for scrollbar pseudo elements and allow a set of pseudo classes (but nothing else)
 911         // to follow the pseudo elements.
 912         if (fragment-&gt;pseudoElementSelector &amp;&amp; !isScrollbarPseudoElement(fragment-&gt;pseudoElementSelector-&gt;pseudoElementType()))
 913             return FunctionType::CannotMatchAnything;
 914 
 915         switch (selector-&gt;match()) {
 916         case CSSSelector::Tag:
 917             ASSERT(!fragment-&gt;tagNameSelector);
 918             fragment-&gt;tagNameSelector = selector;
 919             if (fragment-&gt;tagNameSelector-&gt;tagQName() != anyQName())
 920                 fragment-&gt;onlyMatchesLinksInQuirksMode = false;
 921             break;
 922         case CSSSelector::Id: {
<a name="7" id="anc7"></a><span class="line-modified"> 923             const AtomString&amp; id = selector-&gt;value();</span>
 924             if (fragment-&gt;id) {
 925                 if (id != *fragment-&gt;id)
 926                     return FunctionType::CannotMatchAnything;
 927             } else
 928                 fragment-&gt;id = &amp;(selector-&gt;value());
 929             fragment-&gt;onlyMatchesLinksInQuirksMode = false;
 930             break;
 931         }
 932         case CSSSelector::Class:
 933             fragment-&gt;classNames.append(selector-&gt;value().impl());
 934             fragment-&gt;onlyMatchesLinksInQuirksMode = false;
 935             break;
 936         case CSSSelector::PseudoClass: {
 937             FragmentPositionInRootFragments subPosition = positionInRootFragments;
 938             if (relationToPreviousFragment != FragmentRelation::Rightmost)
 939                 subPosition = isRightmostOrAdjacent ? FragmentPositionInRootFragments::AdjacentToRightmost : FragmentPositionInRootFragments::Other;
 940             if (fragment-&gt;pseudoElementSelector &amp;&amp; isScrollbarPseudoElement(fragment-&gt;pseudoElementSelector-&gt;pseudoElementType()))
 941                 functionType = mostRestrictiveFunctionType(functionType, addScrollbarPseudoClassType(*selector, *fragment));
 942             else {
 943                 unsigned internalSpecificity = 0;
 944                 functionType = mostRestrictiveFunctionType(functionType, addPseudoClassType(*selector, *fragment, internalSpecificity, selectorContext, fragmentLevel, subPosition, visitedMatchEnabled, visitedMode, pseudoElementMatchingBehavior));
 945                 specificity = CSSSelector::addSpecificities(specificity, internalSpecificity);
 946             }
 947             if (!pseudoClassOnlyMatchesLinksInQuirksMode(*selector))
 948                 fragment-&gt;onlyMatchesLinksInQuirksMode = false;
 949             if (functionType == FunctionType::CannotCompile || functionType == FunctionType::CannotMatchAnything)
 950                 return functionType;
 951             break;
 952         }
 953         case CSSSelector::PseudoElement: {
 954             fragment-&gt;onlyMatchesLinksInQuirksMode = false;
 955 
 956             // In the QuerySelector context, PseudoElement selectors always fail.
 957             if (selectorContext == SelectorContext::QuerySelector)
 958                 return FunctionType::CannotMatchAnything;
 959 
 960             switch (selector-&gt;pseudoElementType()) {
 961             case CSSSelector::PseudoElementAfter:
 962             case CSSSelector::PseudoElementBefore:
 963             case CSSSelector::PseudoElementFirstLetter:
 964             case CSSSelector::PseudoElementFirstLine:
 965             case CSSSelector::PseudoElementScrollbar:
 966             case CSSSelector::PseudoElementScrollbarButton:
 967             case CSSSelector::PseudoElementScrollbarCorner:
 968             case CSSSelector::PseudoElementScrollbarThumb:
 969             case CSSSelector::PseudoElementScrollbarTrack:
 970             case CSSSelector::PseudoElementScrollbarTrackPiece:
 971                 ASSERT(!fragment-&gt;pseudoElementSelector);
 972                 fragment-&gt;pseudoElementSelector = selector;
 973                 break;
 974             case CSSSelector::PseudoElementUnknown:
 975                 ASSERT_NOT_REACHED();
 976                 return FunctionType::CannotMatchAnything;
 977             // FIXME: Support PseudoId::Resizer, PseudoId::Selection etc.
 978             default:
 979                 // This branch includes custom pseudo elements.
 980                 return FunctionType::CannotCompile;
 981             }
 982 
 983             if (pseudoElementMatchingBehavior == PseudoElementMatchingBehavior::NeverMatch)
 984                 return FunctionType::CannotMatchAnything;
 985 
 986             functionType = FunctionType::SelectorCheckerWithCheckingContext;
 987             break;
 988         }
 989         case CSSSelector::List:
 990             if (selector-&gt;value().find(isHTMLSpace&lt;UChar&gt;) != notFound)
 991                 return FunctionType::CannotMatchAnything;
 992             FALLTHROUGH;
 993         case CSSSelector::Begin:
 994         case CSSSelector::End:
 995         case CSSSelector::Contain:
 996             if (selector-&gt;value().isEmpty())
 997                 return FunctionType::CannotMatchAnything;
 998             FALLTHROUGH;
 999         case CSSSelector::Exact:
1000         case CSSSelector::Hyphen:
1001             fragment-&gt;onlyMatchesLinksInQuirksMode = false;
1002             fragment-&gt;attributes.append(AttributeMatchingInfo(*selector));
1003             break;
1004 
1005         case CSSSelector::Set:
1006             fragment-&gt;onlyMatchesLinksInQuirksMode = false;
1007             fragment-&gt;attributes.append(AttributeMatchingInfo(*selector));
1008             break;
1009         case CSSSelector::PagePseudoClass:
1010             fragment-&gt;onlyMatchesLinksInQuirksMode = false;
1011             // Pseudo page class are only relevant for style resolution, they are ignored for matching.
1012             break;
1013         case CSSSelector::Unknown:
1014             ASSERT_NOT_REACHED();
1015             return FunctionType::CannotMatchAnything;
1016         }
1017 
1018         auto relation = selector-&gt;relation();
1019         if (relation == CSSSelector::Subselector)
1020             continue;
1021 
1022         if (relation == CSSSelector::ShadowDescendant &amp;&amp; !selector-&gt;isLastInTagHistory())
1023             return FunctionType::CannotCompile;
1024 
1025         if (relation == CSSSelector::DirectAdjacent || relation == CSSSelector::IndirectAdjacent) {
1026             FunctionType relationFunctionType = FunctionType::SelectorCheckerWithCheckingContext;
1027             if (selectorContext == SelectorContext::QuerySelector)
1028                 relationFunctionType = FunctionType::SimpleSelectorChecker;
1029             functionType = mostRestrictiveFunctionType(functionType, relationFunctionType);
1030 
1031             // When the relation is adjacent, disable :visited match.
1032             visitedMatchEnabled = false;
1033         }
1034 
1035         // Virtual pseudo element is only effective in the rightmost fragment.
1036         pseudoElementMatchingBehavior = PseudoElementMatchingBehavior::NeverMatch;
1037 
1038         fragment-&gt;relationToLeftFragment = fragmentRelationForSelectorRelation(relation);
1039         fragment-&gt;relationToRightFragment = relationToPreviousFragment;
1040         fragment-&gt;positionInRootFragments = positionInRootFragments;
1041         fragment-&gt;isRightmostOrAdjacent = isRightmostOrAdjacent;
1042         relationToPreviousFragment = fragment-&gt;relationToLeftFragment;
1043         if (relationToPreviousFragment != FragmentRelation::Rightmost &amp;&amp; relationToPreviousFragment != FragmentRelation::DirectAdjacent &amp;&amp; relationToPreviousFragment != FragmentRelation::IndirectAdjacent)
1044             isRightmostOrAdjacent = false;
1045 
1046         if (fragmentLevel != FragmentsLevel::Root)
1047             fragment-&gt;onlyMatchesLinksInQuirksMode = false;
1048 
1049         fragment = nullptr;
1050     }
1051 
1052     ASSERT(!fragment);
1053 
1054     selectorFragments.staticSpecificity = specificity;
1055 
1056     return functionType;
1057 }
1058 
1059 static FunctionType constructFragments(const CSSSelector* rootSelector, SelectorContext selectorContext, SelectorFragmentList&amp; selectorFragments, FragmentsLevel fragmentLevel, FragmentPositionInRootFragments positionInRootFragments, bool visitedMatchEnabled, VisitedMode&amp; visitedMode, PseudoElementMatchingBehavior pseudoElementMatchingBehavior)
1060 {
1061     ASSERT(selectorFragments.isEmpty());
1062 
1063     FunctionType functionType = constructFragmentsInternal(rootSelector, selectorContext, selectorFragments, fragmentLevel, positionInRootFragments, visitedMatchEnabled, visitedMode, pseudoElementMatchingBehavior);
1064     if (functionType != FunctionType::SimpleSelectorChecker &amp;&amp; functionType != FunctionType::SelectorCheckerWithCheckingContext)
1065         selectorFragments.clear();
1066     return functionType;
1067 }
1068 
1069 static inline bool attributeNameTestingRequiresNamespaceRegister(const CSSSelector&amp; attributeSelector)
1070 {
1071     return attributeSelector.attribute().prefix() != starAtom() &amp;&amp; !attributeSelector.attribute().namespaceURI().isNull();
1072 }
1073 
1074 static inline bool attributeValueTestingRequiresExtraRegister(const AttributeMatchingInfo&amp; attributeInfo)
1075 {
1076     switch (attributeInfo.attributeCaseSensitivity()) {
1077     case AttributeCaseSensitivity::CaseSensitive:
1078         return false;
1079     case AttributeCaseSensitivity::HTMLLegacyCaseInsensitive:
1080         return true;
1081     case AttributeCaseSensitivity::CaseInsensitive:
1082         return attributeInfo.selector().match() == CSSSelector::Exact;
1083     }
1084     return true;
1085 }
1086 
1087 // Element + ElementData + a pointer to values + an index on that pointer + the value we expect;
1088 static const unsigned minimumRequiredRegisterCount = 5;
1089 // Element + ElementData + scratchRegister + attributeArrayPointer + expectedLocalName + (qualifiedNameImpl &amp;&amp; expectedValue).
1090 static const unsigned minimumRequiredRegisterCountForAttributeFilter = 6;
1091 // On x86, we always need 6 registers: Element + SiblingCounter + SiblingCounterCopy + divisor + dividend + remainder.
1092 // On other architectures, we need 6 registers for style resolution:
1093 //     Element + elementCounter + previousSibling + checkingContext + lastRelation + nextSiblingElement.
1094 static const unsigned minimumRequiredRegisterCountForNthChildFilter = 6;
1095 
1096 static unsigned minimumRegisterRequirements(const SelectorFragment&amp; selectorFragment)
1097 {
1098     unsigned minimum = minimumRequiredRegisterCount;
1099     const auto&amp; attributes = selectorFragment.attributes;
1100 
1101     // Attributes cause some register pressure.
1102     unsigned attributeCount = attributes.size();
1103     for (unsigned attributeIndex = 0; attributeIndex &lt; attributeCount; ++attributeIndex) {
1104         unsigned attributeMinimum = minimumRequiredRegisterCountForAttributeFilter;
1105 
1106         if (attributeIndex + 1 &lt; attributeCount)
1107             attributeMinimum += 2; // For the local copy of the counter and attributeArrayPointer.
1108 
1109         const AttributeMatchingInfo&amp; attributeInfo = attributes[attributeIndex];
1110         const CSSSelector&amp; attributeSelector = attributeInfo.selector();
1111         if (attributeNameTestingRequiresNamespaceRegister(attributeSelector)
1112             || attributeValueTestingRequiresExtraRegister(attributeInfo))
1113             attributeMinimum += 1;
1114 
1115         minimum = std::max(minimum, attributeMinimum);
1116     }
1117 
1118     if (!selectorFragment.nthChildFilters.isEmpty() || !selectorFragment.nthChildOfFilters.isEmpty() || !selectorFragment.nthLastChildFilters.isEmpty() || !selectorFragment.nthLastChildOfFilters.isEmpty())
1119         minimum = std::max(minimum, minimumRequiredRegisterCountForNthChildFilter);
1120 
1121     // :any pseudo class filters cause some register pressure.
1122     for (const auto&amp; subFragments : selectorFragment.anyFilters) {
1123         for (const SelectorFragment&amp; subFragment : subFragments) {
1124             unsigned anyFilterMinimum = minimumRegisterRequirements(subFragment);
1125             minimum = std::max(minimum, anyFilterMinimum);
1126         }
1127     }
1128 
1129     return minimum;
1130 }
1131 
1132 bool hasAnyCombinators(const Vector&lt;SelectorFragmentList&gt;&amp; selectorList);
1133 template &lt;size_t inlineCapacity&gt;
1134 bool hasAnyCombinators(const Vector&lt;SelectorFragment, inlineCapacity&gt;&amp; selectorFragmentList);
1135 
1136 bool hasAnyCombinators(const Vector&lt;SelectorFragmentList&gt;&amp; selectorList)
1137 {
1138     for (const SelectorFragmentList&amp; selectorFragmentList : selectorList) {
1139         if (hasAnyCombinators(selectorFragmentList))
1140             return true;
1141     }
1142     return false;
1143 }
1144 
1145 template &lt;size_t inlineCapacity&gt;
1146 bool hasAnyCombinators(const Vector&lt;SelectorFragment, inlineCapacity&gt;&amp; selectorFragmentList)
1147 {
1148     if (selectorFragmentList.isEmpty())
1149         return false;
1150     if (selectorFragmentList.size() != 1)
1151         return true;
1152     if (hasAnyCombinators(selectorFragmentList.first().notFilters))
1153         return true;
1154     for (const SelectorList&amp; matchesList : selectorFragmentList.first().matchesFilters) {
1155         if (hasAnyCombinators(matchesList))
1156             return true;
1157     }
1158     for (const NthChildOfSelectorInfo&amp; nthChildOfSelectorInfo : selectorFragmentList.first().nthChildOfFilters) {
1159         if (hasAnyCombinators(nthChildOfSelectorInfo.selectorList))
1160             return true;
1161     }
1162     for (const NthChildOfSelectorInfo&amp; nthLastChildOfSelectorInfo : selectorFragmentList.first().nthLastChildOfFilters) {
1163         if (hasAnyCombinators(nthLastChildOfSelectorInfo.selectorList))
1164             return true;
1165     }
1166     return false;
1167 }
1168 
1169 // The CSS JIT has only been validated with a strict minimum of 6 allocated registers.
1170 const unsigned minimumRegisterRequirement = 6;
1171 
1172 void computeBacktrackingMemoryRequirements(SelectorFragmentList&amp; selectorFragments, bool backtrackingRegisterReserved = false);
1173 
1174 static void computeBacktrackingMemoryRequirements(SelectorList&amp; selectorList, unsigned&amp; totalRegisterRequirements, unsigned&amp; totalStackRequirements, bool backtrackingRegisterReservedForFragment = false)
1175 {
1176     unsigned selectorListRegisterRequirements = 0;
1177     unsigned selectorListStackRequirements = 0;
1178     bool clobberElementAddressRegister = false;
1179 
1180     for (SelectorFragmentList&amp; selectorFragmentList : selectorList) {
1181         computeBacktrackingMemoryRequirements(selectorFragmentList, backtrackingRegisterReservedForFragment);
1182 
1183         selectorListRegisterRequirements = std::max(selectorListRegisterRequirements, selectorFragmentList.registerRequirements);
1184         selectorListStackRequirements = std::max(selectorListStackRequirements, selectorFragmentList.stackRequirements);
1185         clobberElementAddressRegister = clobberElementAddressRegister || selectorFragmentList.clobberElementAddressRegister;
1186     }
1187 
1188     totalRegisterRequirements = std::max(totalRegisterRequirements, selectorListRegisterRequirements);
1189     totalStackRequirements = std::max(totalStackRequirements, selectorListStackRequirements);
1190 
1191     selectorList.registerRequirements = std::max(selectorListRegisterRequirements, minimumRegisterRequirement);
1192     selectorList.stackRequirements = selectorListStackRequirements;
1193     selectorList.clobberElementAddressRegister = clobberElementAddressRegister;
1194 }
1195 
1196 void computeBacktrackingMemoryRequirements(SelectorFragmentList&amp; selectorFragments, bool backtrackingRegisterReserved)
1197 {
1198     selectorFragments.registerRequirements = minimumRegisterRequirement;
1199     selectorFragments.stackRequirements = 0;
1200     selectorFragments.clobberElementAddressRegister = hasAnyCombinators(selectorFragments);
1201 
1202     for (SelectorFragment&amp; selectorFragment : selectorFragments) {
1203         unsigned fragmentRegisterRequirements = minimumRegisterRequirements(selectorFragment);
1204         unsigned fragmentStackRequirements = 0;
1205 
1206         bool backtrackingRegisterReservedForFragment = backtrackingRegisterReserved || selectorFragment.backtrackingFlags &amp; BacktrackingFlag::InChainWithDescendantTail;
1207 
1208         computeBacktrackingMemoryRequirements(selectorFragment.notFilters, fragmentRegisterRequirements, fragmentStackRequirements, backtrackingRegisterReservedForFragment);
1209 
1210         for (SelectorList&amp; matchesList : selectorFragment.matchesFilters)
1211             computeBacktrackingMemoryRequirements(matchesList, fragmentRegisterRequirements, fragmentStackRequirements, backtrackingRegisterReservedForFragment);
1212 
1213         for (NthChildOfSelectorInfo&amp; nthChildOfSelectorInfo : selectorFragment.nthChildOfFilters)
1214             computeBacktrackingMemoryRequirements(nthChildOfSelectorInfo.selectorList, fragmentRegisterRequirements, fragmentStackRequirements, backtrackingRegisterReservedForFragment);
1215 
1216         for (NthChildOfSelectorInfo&amp; nthLastChildOfSelectorInfo : selectorFragment.nthLastChildOfFilters)
1217             computeBacktrackingMemoryRequirements(nthLastChildOfSelectorInfo.selectorList, fragmentRegisterRequirements, fragmentStackRequirements, backtrackingRegisterReservedForFragment);
1218 
1219         if (selectorFragment.backtrackingFlags &amp; BacktrackingFlag::InChainWithDescendantTail) {
1220             if (!backtrackingRegisterReserved)
1221                 ++fragmentRegisterRequirements;
1222             else
1223                 ++fragmentStackRequirements;
1224         }
1225         if (selectorFragment.backtrackingFlags &amp; BacktrackingFlag::InChainWithAdjacentTail)
1226             ++fragmentStackRequirements;
1227 
1228         selectorFragments.registerRequirements = std::max(selectorFragments.registerRequirements, fragmentRegisterRequirements);
1229         selectorFragments.stackRequirements = std::max(selectorFragments.stackRequirements, fragmentStackRequirements);
1230     }
1231 }
1232 
1233 inline SelectorCompilationStatus SelectorCodeGenerator::compile(JSC::MacroAssemblerCodeRef&lt;CSSSelectorPtrTag&gt;&amp; codeRef)
1234 {
1235     switch (m_functionType) {
1236     case FunctionType::SimpleSelectorChecker:
1237     case FunctionType::SelectorCheckerWithCheckingContext:
1238         generateSelectorChecker();
1239         break;
1240     case FunctionType::CannotMatchAnything:
1241         m_assembler.tagReturnAddress();
1242         m_assembler.move(Assembler::TrustedImm32(0), returnRegister);
1243         m_assembler.ret();
1244         break;
1245     case FunctionType::CannotCompile:
1246         return SelectorCompilationStatus::CannotCompile;
1247     }
1248 
1249     JSC::LinkBuffer linkBuffer(m_assembler, CSS_CODE_ID, JSC::JITCompilationCanFail);
1250     if (!linkBuffer.isValid()) {
1251         // This could be SelectorCompilationStatus::NotCompiled but that would cause us to re-enter
1252         // the CSS JIT every time we evaluate that selector.
1253         // If we failed to allocate the buffer, we have bigger problems than CSS performance, it is fine
1254         // to be slower.
1255         return SelectorCompilationStatus::CannotCompile;
1256     }
1257 
1258     for (unsigned i = 0; i &lt; m_functionCalls.size(); i++)
1259         linkBuffer.link(m_functionCalls[i].first, m_functionCalls[i].second);
1260 
1261 #if CSS_SELECTOR_JIT_DEBUGGING
1262     codeRef = linkBuffer.finalizeCodeWithDisassembly(CSSSelectorPtrTag, &quot;CSS Selector JIT for \&quot;%s\&quot;&quot;, m_originalSelector-&gt;selectorText().utf8().data());
1263 #else
1264     codeRef = FINALIZE_CODE(linkBuffer, CSSSelectorPtrTag, &quot;CSS Selector JIT&quot;);
1265 #endif
1266 
1267     if (m_functionType == FunctionType::SimpleSelectorChecker || m_functionType == FunctionType::CannotMatchAnything)
1268         return SelectorCompilationStatus::SimpleSelectorChecker;
1269     return SelectorCompilationStatus::SelectorCheckerWithCheckingContext;
1270 }
1271 
1272 
1273 static inline void updateChainStates(const SelectorFragment&amp; fragment, bool&amp; hasDescendantRelationOnTheRight, unsigned&amp; ancestorPositionSinceDescendantRelation, bool&amp; hasIndirectAdjacentRelationOnTheRightOfDirectAdjacentChain, unsigned&amp; adjacentPositionSinceIndirectAdjacentTreeWalk)
1274 {
1275     switch (fragment.relationToRightFragment) {
1276     case FragmentRelation::Rightmost:
1277         break;
1278     case FragmentRelation::Descendant:
1279         hasDescendantRelationOnTheRight = true;
1280         ancestorPositionSinceDescendantRelation = 0;
1281         hasIndirectAdjacentRelationOnTheRightOfDirectAdjacentChain = false;
1282         break;
1283     case FragmentRelation::Child:
1284         if (hasDescendantRelationOnTheRight)
1285             ++ancestorPositionSinceDescendantRelation;
1286         hasIndirectAdjacentRelationOnTheRightOfDirectAdjacentChain = false;
1287         break;
1288     case FragmentRelation::DirectAdjacent:
1289         if (hasIndirectAdjacentRelationOnTheRightOfDirectAdjacentChain)
1290             ++adjacentPositionSinceIndirectAdjacentTreeWalk;
1291         break;
1292     case FragmentRelation::IndirectAdjacent:
1293         hasIndirectAdjacentRelationOnTheRightOfDirectAdjacentChain = true;
1294         adjacentPositionSinceIndirectAdjacentTreeWalk = 0;
1295         break;
1296     }
1297 }
1298 
1299 static inline bool isFirstAncestor(unsigned ancestorPositionSinceDescendantRelation)
1300 {
1301     return ancestorPositionSinceDescendantRelation == 1;
1302 }
1303 
1304 static inline bool isFirstAdjacent(unsigned adjacentPositionSinceIndirectAdjacentTreeWalk)
1305 {
1306     return adjacentPositionSinceIndirectAdjacentTreeWalk == 1;
1307 }
1308 
1309 static inline BacktrackingAction solveDescendantBacktrackingActionForChild(const SelectorFragment&amp; fragment, unsigned backtrackingStartHeightFromDescendant)
1310 {
1311     // If height is invalid (e.g. There&#39;s no tag name).
1312     if (backtrackingStartHeightFromDescendant == invalidHeight)
1313         return BacktrackingAction::NoBacktracking;
1314 
1315     // Start backtracking from the current element.
1316     if (backtrackingStartHeightFromDescendant == fragment.heightFromDescendant)
1317         return BacktrackingAction::JumpToDescendantEntryPoint;
1318 
1319     // Start backtracking from the parent of current element.
1320     if (backtrackingStartHeightFromDescendant == (fragment.heightFromDescendant + 1))
1321         return BacktrackingAction::JumpToDescendantTreeWalkerEntryPoint;
1322 
1323     return BacktrackingAction::JumpToDescendantTail;
1324 }
1325 
1326 static inline BacktrackingAction solveAdjacentBacktrackingActionForDirectAdjacent(const SelectorFragment&amp; fragment, unsigned backtrackingStartWidthFromIndirectAdjacent)
1327 {
1328     // If width is invalid (e.g. There&#39;s no tag name).
1329     if (backtrackingStartWidthFromIndirectAdjacent == invalidWidth)
1330         return BacktrackingAction::NoBacktracking;
1331 
1332     // Start backtracking from the current element.
1333     if (backtrackingStartWidthFromIndirectAdjacent == fragment.widthFromIndirectAdjacent)
1334         return BacktrackingAction::JumpToIndirectAdjacentEntryPoint;
1335 
1336     // Start backtracking from the previous adjacent of current element.
1337     if (backtrackingStartWidthFromIndirectAdjacent == (fragment.widthFromIndirectAdjacent + 1))
1338         return BacktrackingAction::JumpToIndirectAdjacentTreeWalkerEntryPoint;
1339 
1340     return BacktrackingAction::JumpToDirectAdjacentTail;
1341 }
1342 
1343 static inline BacktrackingAction solveAdjacentTraversalBacktrackingAction(const SelectorFragment&amp; fragment, bool hasDescendantRelationOnTheRight)
1344 {
1345     if (!hasDescendantRelationOnTheRight)
1346         return BacktrackingAction::NoBacktracking;
1347 
1348     if (fragment.tagNameMatchedBacktrackingStartHeightFromDescendant == (fragment.heightFromDescendant + 1))
1349         return BacktrackingAction::JumpToDescendantTreeWalkerEntryPoint;
1350 
1351     return BacktrackingAction::JumpToDescendantTail;
1352 }
1353 
1354 static inline void solveBacktrackingAction(SelectorFragment&amp; fragment, bool hasDescendantRelationOnTheRight, bool hasIndirectAdjacentRelationOnTheRightOfDirectAdjacentChain)
1355 {
1356     switch (fragment.relationToRightFragment) {
1357     case FragmentRelation::Rightmost:
1358     case FragmentRelation::Descendant:
1359         break;
1360     case FragmentRelation::Child:
1361         // Failure to match the element should resume matching at the nearest ancestor/descendant entry point.
1362         if (hasDescendantRelationOnTheRight) {
1363             fragment.matchingTagNameBacktrackingAction = solveDescendantBacktrackingActionForChild(fragment, fragment.tagNameNotMatchedBacktrackingStartHeightFromDescendant);
1364             fragment.matchingPostTagNameBacktrackingAction = solveDescendantBacktrackingActionForChild(fragment, fragment.tagNameMatchedBacktrackingStartHeightFromDescendant);
1365         }
1366         break;
1367     case FragmentRelation::DirectAdjacent:
1368         // Failure on traversal implies no other sibling traversal can match. Matching should resume at the
1369         // nearest ancestor/descendant traversal.
1370         fragment.traversalBacktrackingAction = solveAdjacentTraversalBacktrackingAction(fragment, hasDescendantRelationOnTheRight);
1371 
1372         // If the rightmost relation is a indirect adjacent, matching sould resume from there.
1373         // Otherwise, we resume from the latest ancestor/descendant if any.
1374         if (hasIndirectAdjacentRelationOnTheRightOfDirectAdjacentChain) {
1375             fragment.matchingTagNameBacktrackingAction = solveAdjacentBacktrackingActionForDirectAdjacent(fragment, fragment.tagNameNotMatchedBacktrackingStartWidthFromIndirectAdjacent);
1376             fragment.matchingPostTagNameBacktrackingAction = solveAdjacentBacktrackingActionForDirectAdjacent(fragment, fragment.tagNameMatchedBacktrackingStartWidthFromIndirectAdjacent);
1377         } else if (hasDescendantRelationOnTheRight) {
1378             // Since we resume from the latest ancestor/descendant, the action is the same as the traversal action.
1379             fragment.matchingTagNameBacktrackingAction = fragment.traversalBacktrackingAction;
1380             fragment.matchingPostTagNameBacktrackingAction = fragment.traversalBacktrackingAction;
1381         }
1382         break;
1383     case FragmentRelation::IndirectAdjacent:
1384         // Failure on traversal implies no other sibling matching will succeed. Matching can resume
1385         // from the latest ancestor/descendant.
1386         fragment.traversalBacktrackingAction = solveAdjacentTraversalBacktrackingAction(fragment, hasDescendantRelationOnTheRight);
1387         break;
1388     }
1389 }
1390 
1391 enum class TagNameEquality {
1392     StrictlyNotEqual,
1393     MaybeEqual,
1394     StrictlyEqual
1395 };
1396 
1397 static inline TagNameEquality equalTagNames(const CSSSelector* lhs, const CSSSelector* rhs)
1398 {
1399     if (!lhs || !rhs)
1400         return TagNameEquality::MaybeEqual;
1401 
1402     const QualifiedName&amp; lhsQualifiedName = lhs-&gt;tagQName();
1403     if (lhsQualifiedName == anyQName())
1404         return TagNameEquality::MaybeEqual;
1405 
1406     const QualifiedName&amp; rhsQualifiedName = rhs-&gt;tagQName();
1407     if (rhsQualifiedName == anyQName())
1408         return TagNameEquality::MaybeEqual;
1409 
<a name="8" id="anc8"></a><span class="line-modified">1410     const AtomString&amp; lhsLocalName = lhsQualifiedName.localName();</span>
<span class="line-modified">1411     const AtomString&amp; rhsLocalName = rhsQualifiedName.localName();</span>
1412     if (lhsLocalName != starAtom() &amp;&amp; rhsLocalName != starAtom()) {
<a name="9" id="anc9"></a><span class="line-modified">1413         const AtomString&amp; lhsLowercaseLocalName = lhs-&gt;tagLowercaseLocalName();</span>
<span class="line-modified">1414         const AtomString&amp; rhsLowercaseLocalName = rhs-&gt;tagLowercaseLocalName();</span>
1415 
1416         if (lhsLowercaseLocalName != rhsLowercaseLocalName)
1417             return TagNameEquality::StrictlyNotEqual;
1418 
1419         if (lhsLocalName == lhsLowercaseLocalName &amp;&amp; rhsLocalName == rhsLowercaseLocalName)
1420             return TagNameEquality::StrictlyEqual;
1421         return TagNameEquality::MaybeEqual;
1422     }
1423 
<a name="10" id="anc10"></a><span class="line-modified">1424     const AtomString&amp; lhsNamespaceURI = lhsQualifiedName.namespaceURI();</span>
<span class="line-modified">1425     const AtomString&amp; rhsNamespaceURI = rhsQualifiedName.namespaceURI();</span>
1426     if (lhsNamespaceURI != starAtom() &amp;&amp; rhsNamespaceURI != starAtom()) {
1427         if (lhsNamespaceURI != rhsNamespaceURI)
1428             return TagNameEquality::StrictlyNotEqual;
1429         return TagNameEquality::StrictlyEqual;
1430     }
1431 
1432     return TagNameEquality::MaybeEqual;
1433 }
1434 
1435 static inline bool equalTagNamePatterns(const TagNamePattern&amp; lhs, const TagNamePattern&amp; rhs)
1436 {
1437     TagNameEquality result = equalTagNames(lhs.tagNameSelector, rhs.tagNameSelector);
1438     if (result == TagNameEquality::MaybeEqual)
1439         return true;
1440 
1441     // If both rhs &amp; lhs have actual localName (or NamespaceURI),
1442     // TagNameEquality result becomes StrictlyEqual or StrictlyNotEqual Since inverted lhs never matches on rhs.
1443     bool equal = result == TagNameEquality::StrictlyEqual;
1444     if (lhs.inverted)
1445         return !equal;
1446     return equal;
1447 }
1448 
1449 // Find the largest matching prefix from already known tagNames.
1450 // And by using this, compute an appropriate height of backtracking start element from the closest base element in the chain.
1451 static inline unsigned computeBacktrackingStartOffsetInChain(const TagNameList&amp; tagNames, unsigned maxPrefixSize)
1452 {
1453     RELEASE_ASSERT(!tagNames.isEmpty());
1454     RELEASE_ASSERT(maxPrefixSize &lt; tagNames.size());
1455 
1456     for (unsigned largestPrefixSize = maxPrefixSize; largestPrefixSize &gt; 0; --largestPrefixSize) {
1457         unsigned offsetToLargestPrefix = tagNames.size() - largestPrefixSize;
1458         bool matched = true;
1459         // Since TagNamePatterns are pushed to a tagNames, check tagNames with reverse order.
1460         for (unsigned i = 0; i &lt; largestPrefixSize; ++i) {
1461             unsigned lastIndex = tagNames.size() - 1;
1462             unsigned currentIndex = lastIndex - i;
1463             if (!equalTagNamePatterns(tagNames[currentIndex], tagNames[currentIndex - offsetToLargestPrefix])) {
1464                 matched = false;
1465                 break;
1466             }
1467         }
1468         if (matched)
1469             return offsetToLargestPrefix;
1470     }
1471     return tagNames.size();
1472 }
1473 
1474 static inline void computeBacktrackingHeightFromDescendant(SelectorFragment&amp; fragment, TagNameList&amp; tagNamesForChildChain, bool hasDescendantRelationOnTheRight, const SelectorFragment*&amp; previousChildFragmentInChildChain)
1475 {
1476     if (!hasDescendantRelationOnTheRight)
1477         return;
1478 
1479     if (fragment.relationToRightFragment == FragmentRelation::Descendant) {
1480         tagNamesForChildChain.clear();
1481 
1482         TagNamePattern pattern;
1483         pattern.tagNameSelector = fragment.tagNameSelector;
1484         tagNamesForChildChain.append(pattern);
1485         fragment.heightFromDescendant = 0;
1486         previousChildFragmentInChildChain = nullptr;
1487     } else if (fragment.relationToRightFragment == FragmentRelation::Child) {
1488         TagNamePattern pattern;
1489         pattern.tagNameSelector = fragment.tagNameSelector;
1490         tagNamesForChildChain.append(pattern);
1491 
1492         unsigned maxPrefixSize = tagNamesForChildChain.size() - 1;
1493         if (previousChildFragmentInChildChain) {
1494             RELEASE_ASSERT(tagNamesForChildChain.size() &gt;= previousChildFragmentInChildChain-&gt;tagNameMatchedBacktrackingStartHeightFromDescendant);
1495             maxPrefixSize = tagNamesForChildChain.size() - previousChildFragmentInChildChain-&gt;tagNameMatchedBacktrackingStartHeightFromDescendant;
1496         }
1497 
1498         if (pattern.tagNameSelector) {
1499             // Compute height from descendant in the case that tagName is not matched.
1500             tagNamesForChildChain.last().inverted = true;
1501             fragment.tagNameNotMatchedBacktrackingStartHeightFromDescendant = computeBacktrackingStartOffsetInChain(tagNamesForChildChain, maxPrefixSize);
1502         }
1503 
1504         // Compute height from descendant in the case that tagName is matched.
1505         tagNamesForChildChain.last().inverted = false;
1506         fragment.tagNameMatchedBacktrackingStartHeightFromDescendant = computeBacktrackingStartOffsetInChain(tagNamesForChildChain, maxPrefixSize);
1507         fragment.heightFromDescendant = tagNamesForChildChain.size() - 1;
1508         previousChildFragmentInChildChain = &amp;fragment;
1509     } else {
1510         if (previousChildFragmentInChildChain) {
1511             fragment.tagNameNotMatchedBacktrackingStartHeightFromDescendant = previousChildFragmentInChildChain-&gt;tagNameNotMatchedBacktrackingStartHeightFromDescendant;
1512             fragment.tagNameMatchedBacktrackingStartHeightFromDescendant = previousChildFragmentInChildChain-&gt;tagNameMatchedBacktrackingStartHeightFromDescendant;
1513             fragment.heightFromDescendant = previousChildFragmentInChildChain-&gt;heightFromDescendant;
1514         } else {
1515             fragment.tagNameNotMatchedBacktrackingStartHeightFromDescendant = tagNamesForChildChain.size();
1516             fragment.tagNameMatchedBacktrackingStartHeightFromDescendant = tagNamesForChildChain.size();
1517             fragment.heightFromDescendant = 0;
1518         }
1519     }
1520 }
1521 
1522 static inline void computeBacktrackingWidthFromIndirectAdjacent(SelectorFragment&amp; fragment, TagNameList&amp; tagNamesForDirectAdjacentChain, bool hasIndirectAdjacentRelationOnTheRightOfDirectAdjacentChain, const SelectorFragment*&amp; previousDirectAdjacentFragmentInDirectAdjacentChain)
1523 {
1524     if (!hasIndirectAdjacentRelationOnTheRightOfDirectAdjacentChain)
1525         return;
1526 
1527     if (fragment.relationToRightFragment == FragmentRelation::IndirectAdjacent) {
1528         tagNamesForDirectAdjacentChain.clear();
1529 
1530         TagNamePattern pattern;
1531         pattern.tagNameSelector = fragment.tagNameSelector;
1532         tagNamesForDirectAdjacentChain.append(pattern);
1533         fragment.widthFromIndirectAdjacent = 0;
1534         previousDirectAdjacentFragmentInDirectAdjacentChain = nullptr;
1535     } else if (fragment.relationToRightFragment == FragmentRelation::DirectAdjacent) {
1536         TagNamePattern pattern;
1537         pattern.tagNameSelector = fragment.tagNameSelector;
1538         tagNamesForDirectAdjacentChain.append(pattern);
1539 
1540         unsigned maxPrefixSize = tagNamesForDirectAdjacentChain.size() - 1;
1541         if (previousDirectAdjacentFragmentInDirectAdjacentChain) {
1542             RELEASE_ASSERT(tagNamesForDirectAdjacentChain.size() &gt;= previousDirectAdjacentFragmentInDirectAdjacentChain-&gt;tagNameMatchedBacktrackingStartWidthFromIndirectAdjacent);
1543             maxPrefixSize = tagNamesForDirectAdjacentChain.size() - previousDirectAdjacentFragmentInDirectAdjacentChain-&gt;tagNameMatchedBacktrackingStartWidthFromIndirectAdjacent;
1544         }
1545 
1546         if (pattern.tagNameSelector) {
1547             // Compute height from descendant in the case that tagName is not matched.
1548             tagNamesForDirectAdjacentChain.last().inverted = true;
1549             fragment.tagNameNotMatchedBacktrackingStartWidthFromIndirectAdjacent = computeBacktrackingStartOffsetInChain(tagNamesForDirectAdjacentChain, maxPrefixSize);
1550         }
1551 
1552         // Compute height from descendant in the case that tagName is matched.
1553         tagNamesForDirectAdjacentChain.last().inverted = false;
1554         fragment.tagNameMatchedBacktrackingStartWidthFromIndirectAdjacent = computeBacktrackingStartOffsetInChain(tagNamesForDirectAdjacentChain, maxPrefixSize);
1555         fragment.widthFromIndirectAdjacent = tagNamesForDirectAdjacentChain.size() - 1;
1556         previousDirectAdjacentFragmentInDirectAdjacentChain = &amp;fragment;
1557     }
1558 }
1559 
1560 static bool requiresAdjacentTail(const SelectorFragment&amp; fragment)
1561 {
1562     ASSERT(fragment.traversalBacktrackingAction != BacktrackingAction::JumpToDirectAdjacentTail);
1563     return fragment.matchingTagNameBacktrackingAction == BacktrackingAction::JumpToDirectAdjacentTail || fragment.matchingPostTagNameBacktrackingAction == BacktrackingAction::JumpToDirectAdjacentTail;
1564 }
1565 
1566 static bool requiresDescendantTail(const SelectorFragment&amp; fragment)
1567 {
1568     return fragment.matchingTagNameBacktrackingAction == BacktrackingAction::JumpToDescendantTail || fragment.matchingPostTagNameBacktrackingAction == BacktrackingAction::JumpToDescendantTail || fragment.traversalBacktrackingAction == BacktrackingAction::JumpToDescendantTail;
1569 }
1570 
1571 void computeBacktrackingInformation(SelectorFragmentList&amp; selectorFragments, unsigned level)
1572 {
1573     bool hasDescendantRelationOnTheRight = false;
1574     unsigned ancestorPositionSinceDescendantRelation = 0;
1575     bool hasIndirectAdjacentRelationOnTheRightOfDirectAdjacentChain = false;
1576     unsigned adjacentPositionSinceIndirectAdjacentTreeWalk = 0;
1577 
1578     bool needsAdjacentTail = false;
1579     bool needsDescendantTail = false;
1580     unsigned saveDescendantBacktrackingStartFragmentIndex = std::numeric_limits&lt;unsigned&gt;::max();
1581     unsigned saveIndirectAdjacentBacktrackingStartFragmentIndex = std::numeric_limits&lt;unsigned&gt;::max();
1582 
1583     TagNameList tagNamesForChildChain;
1584     TagNameList tagNamesForDirectAdjacentChain;
1585     const SelectorFragment* previousChildFragmentInChildChain = nullptr;
1586     const SelectorFragment* previousDirectAdjacentFragmentInDirectAdjacentChain = nullptr;
1587 
1588     for (unsigned i = 0; i &lt; selectorFragments.size(); ++i) {
1589         SelectorFragment&amp; fragment = selectorFragments[i];
1590 
1591         updateChainStates(fragment, hasDescendantRelationOnTheRight, ancestorPositionSinceDescendantRelation, hasIndirectAdjacentRelationOnTheRightOfDirectAdjacentChain, adjacentPositionSinceIndirectAdjacentTreeWalk);
1592 
1593         computeBacktrackingHeightFromDescendant(fragment, tagNamesForChildChain, hasDescendantRelationOnTheRight, previousChildFragmentInChildChain);
1594 
1595         computeBacktrackingWidthFromIndirectAdjacent(fragment, tagNamesForDirectAdjacentChain, hasIndirectAdjacentRelationOnTheRightOfDirectAdjacentChain, previousDirectAdjacentFragmentInDirectAdjacentChain);
1596 
1597 #if CSS_SELECTOR_JIT_DEBUGGING
1598         dataLogF(&quot;%*sComputing fragment[%d] backtracking height %u. NotMatched %u / Matched %u | width %u. NotMatched %u / Matched %u\n&quot;, level * 4, &quot;&quot;, i, fragment.heightFromDescendant, fragment.tagNameNotMatchedBacktrackingStartHeightFromDescendant, fragment.tagNameMatchedBacktrackingStartHeightFromDescendant, fragment.widthFromIndirectAdjacent, fragment.tagNameNotMatchedBacktrackingStartWidthFromIndirectAdjacent, fragment.tagNameMatchedBacktrackingStartWidthFromIndirectAdjacent);
1599 #endif
1600 
1601         solveBacktrackingAction(fragment, hasDescendantRelationOnTheRight, hasIndirectAdjacentRelationOnTheRightOfDirectAdjacentChain);
1602 
1603         needsAdjacentTail |= requiresAdjacentTail(fragment);
1604         needsDescendantTail |= requiresDescendantTail(fragment);
1605 
1606         // Add code generation flags.
1607         if (fragment.relationToLeftFragment != FragmentRelation::Descendant &amp;&amp; fragment.relationToRightFragment == FragmentRelation::Descendant)
1608             fragment.backtrackingFlags |= BacktrackingFlag::DescendantEntryPoint;
1609         if (fragment.relationToLeftFragment == FragmentRelation::DirectAdjacent &amp;&amp; fragment.relationToRightFragment == FragmentRelation::IndirectAdjacent)
1610             fragment.backtrackingFlags |= BacktrackingFlag::IndirectAdjacentEntryPoint;
1611         if (fragment.relationToLeftFragment != FragmentRelation::Descendant &amp;&amp; fragment.relationToRightFragment == FragmentRelation::Child &amp;&amp; isFirstAncestor(ancestorPositionSinceDescendantRelation)) {
1612             ASSERT(saveDescendantBacktrackingStartFragmentIndex == std::numeric_limits&lt;unsigned&gt;::max());
1613             saveDescendantBacktrackingStartFragmentIndex = i;
1614         }
1615         if (fragment.relationToLeftFragment == FragmentRelation::DirectAdjacent &amp;&amp; fragment.relationToRightFragment == FragmentRelation::DirectAdjacent &amp;&amp; isFirstAdjacent(adjacentPositionSinceIndirectAdjacentTreeWalk)) {
1616             ASSERT(saveIndirectAdjacentBacktrackingStartFragmentIndex == std::numeric_limits&lt;unsigned&gt;::max());
1617             saveIndirectAdjacentBacktrackingStartFragmentIndex = i;
1618         }
1619         if (fragment.relationToLeftFragment != FragmentRelation::DirectAdjacent) {
1620             if (needsAdjacentTail) {
1621                 ASSERT(fragment.relationToRightFragment == FragmentRelation::DirectAdjacent);
1622                 ASSERT(saveIndirectAdjacentBacktrackingStartFragmentIndex != std::numeric_limits&lt;unsigned&gt;::max());
1623                 fragment.backtrackingFlags |= BacktrackingFlag::DirectAdjacentTail;
1624                 selectorFragments[saveIndirectAdjacentBacktrackingStartFragmentIndex].backtrackingFlags |= BacktrackingFlag::SaveAdjacentBacktrackingStart;
1625                 needsAdjacentTail = false;
1626                 for (unsigned j = saveIndirectAdjacentBacktrackingStartFragmentIndex; j &lt;= i; ++j)
1627                     selectorFragments[j].backtrackingFlags |= BacktrackingFlag::InChainWithAdjacentTail;
1628             }
1629             saveIndirectAdjacentBacktrackingStartFragmentIndex = std::numeric_limits&lt;unsigned&gt;::max();
1630         }
1631         if (fragment.relationToLeftFragment == FragmentRelation::Descendant) {
1632             if (needsDescendantTail) {
1633                 ASSERT(saveDescendantBacktrackingStartFragmentIndex != std::numeric_limits&lt;unsigned&gt;::max());
1634                 fragment.backtrackingFlags |= BacktrackingFlag::DescendantTail;
1635                 selectorFragments[saveDescendantBacktrackingStartFragmentIndex].backtrackingFlags |= BacktrackingFlag::SaveDescendantBacktrackingStart;
1636                 needsDescendantTail = false;
1637                 for (unsigned j = saveDescendantBacktrackingStartFragmentIndex; j &lt;= i; ++j)
1638                     selectorFragments[j].backtrackingFlags |= BacktrackingFlag::InChainWithDescendantTail;
1639             }
1640             saveDescendantBacktrackingStartFragmentIndex = std::numeric_limits&lt;unsigned&gt;::max();
1641         }
1642     }
1643 
1644     for (SelectorFragment&amp; fragment : selectorFragments) {
1645         if (!fragment.notFilters.isEmpty()) {
1646 #if CSS_SELECTOR_JIT_DEBUGGING
1647             dataLogF(&quot;%*s  Subselectors for :not():\n&quot;, level * 4, &quot;&quot;);
1648 #endif
1649 
1650             for (SelectorFragmentList&amp; selectorList : fragment.notFilters)
1651                 computeBacktrackingInformation(selectorList, level + 1);
1652         }
1653 
1654         if (!fragment.matchesFilters.isEmpty()) {
1655             for (SelectorList&amp; matchesList : fragment.matchesFilters) {
1656 #if CSS_SELECTOR_JIT_DEBUGGING
1657                 dataLogF(&quot;%*s  Subselectors for :matches():\n&quot;, level * 4, &quot;&quot;);
1658 #endif
1659 
1660                 for (SelectorFragmentList&amp; selectorList : matchesList)
1661                     computeBacktrackingInformation(selectorList, level + 1);
1662             }
1663         }
1664 
1665         for (NthChildOfSelectorInfo&amp; nthChildOfSelectorInfo : fragment.nthChildOfFilters) {
1666 #if CSS_SELECTOR_JIT_DEBUGGING
1667             dataLogF(&quot;%*s  Subselectors for %dn+%d:\n&quot;, level * 4, &quot;&quot;, nthChildOfSelectorInfo.a, nthChildOfSelectorInfo.b);
1668 #endif
1669 
1670             for (SelectorFragmentList&amp; selectorList : nthChildOfSelectorInfo.selectorList)
1671                 computeBacktrackingInformation(selectorList, level + 1);
1672         }
1673 
1674         for (NthChildOfSelectorInfo&amp; nthLastChildOfSelectorInfo : fragment.nthLastChildOfFilters) {
1675 #if CSS_SELECTOR_JIT_DEBUGGING
1676             dataLogF(&quot;%*s  Subselectors for %dn+%d:\n&quot;, level * 4, &quot;&quot;, nthLastChildOfSelectorInfo.a, nthLastChildOfSelectorInfo.b);
1677 #endif
1678 
1679             for (SelectorFragmentList&amp; selectorList : nthLastChildOfSelectorInfo.selectorList)
1680                 computeBacktrackingInformation(selectorList, level + 1);
1681         }
1682     }
1683 }
1684 
1685 inline void SelectorCodeGenerator::pushMacroAssemblerRegisters()
1686 {
1687 #if CPU(ARM_THUMB2)
1688     // r6 is tempRegister in RegisterAllocator.h and addressTempRegister in MacroAssemblerARMv7.h and must be preserved by the callee.
1689     Vector&lt;JSC::MacroAssembler::RegisterID, 1&gt; macroAssemblerRegisters({ JSC::ARMRegisters::r6 });
1690     m_macroAssemblerRegistersStackReferences = m_stackAllocator.push(macroAssemblerRegisters);
1691 #endif
1692 }
1693 
1694 inline void SelectorCodeGenerator::popMacroAssemblerRegisters(StackAllocator&amp; stackAllocator)
1695 {
1696 #if CPU(ARM_THUMB2)
1697     Vector&lt;JSC::MacroAssembler::RegisterID, 1&gt; macroAssemblerRegisters({ JSC::ARMRegisters::r6 });
1698     stackAllocator.pop(m_macroAssemblerRegistersStackReferences, macroAssemblerRegisters);
1699 #else
1700     UNUSED_PARAM(stackAllocator);
1701 #endif
1702 }
1703 
1704 inline bool SelectorCodeGenerator::generatePrologue()
1705 {
1706 #if CPU(ARM64)
1707     Vector&lt;JSC::MacroAssembler::RegisterID, 2&gt; prologueRegisters;
1708     prologueRegisters.append(JSC::ARM64Registers::lr);
1709     prologueRegisters.append(JSC::ARM64Registers::fp);
1710     m_prologueStackReferences = m_stackAllocator.push(prologueRegisters);
1711     return true;
1712 #elif CPU(ARM_THUMB2)
1713     Vector&lt;JSC::MacroAssembler::RegisterID, 1&gt; prologueRegisters;
1714     prologueRegisters.append(JSC::ARMRegisters::lr);
1715     m_prologueStackReferences = m_stackAllocator.push(prologueRegisters);
1716     return true;
1717 #elif CPU(X86_64) &amp;&amp; CSS_SELECTOR_JIT_DEBUGGING
1718     Vector&lt;JSC::MacroAssembler::RegisterID, 1&gt; prologueRegister;
1719     prologueRegister.append(callFrameRegister);
1720     m_prologueStackReferences = m_stackAllocator.push(prologueRegister);
1721     return true;
1722 #endif
1723     return false;
1724 }
1725 
1726 inline void SelectorCodeGenerator::generateEpilogue(StackAllocator&amp; stackAllocator)
1727 {
1728 #if CPU(ARM64)
1729     Vector&lt;JSC::MacroAssembler::RegisterID, 2&gt; prologueRegisters({ JSC::ARM64Registers::lr, JSC::ARM64Registers::fp });
1730     stackAllocator.pop(m_prologueStackReferences, prologueRegisters);
1731 #elif CPU(ARM_THUMB2)
1732     Vector&lt;JSC::MacroAssembler::RegisterID, 1&gt; prologueRegister({ JSC::ARMRegisters::lr });
1733     stackAllocator.pop(m_prologueStackReferences, prologueRegister);
1734 #elif CPU(X86_64) &amp;&amp; CSS_SELECTOR_JIT_DEBUGGING
1735     Vector&lt;JSC::MacroAssembler::RegisterID, 1&gt; prologueRegister({ callFrameRegister });
1736     stackAllocator.pop(m_prologueStackReferences, prologueRegister);
1737 #else
1738     UNUSED_PARAM(stackAllocator);
1739 #endif
1740 }
1741 
1742 static bool isAdjacentRelation(FragmentRelation relation)
1743 {
1744     return relation == FragmentRelation::DirectAdjacent || relation == FragmentRelation::IndirectAdjacent;
1745 }
1746 
1747 static bool shouldMarkStyleIsAffectedByPreviousSibling(const SelectorFragment&amp; fragment)
1748 {
1749     return isAdjacentRelation(fragment.relationToLeftFragment) &amp;&amp; !isAdjacentRelation(fragment.relationToRightFragment);
1750 }
1751 
1752 void SelectorCodeGenerator::generateSelectorChecker()
1753 {
1754     m_assembler.tagReturnAddress();
1755     pushMacroAssemblerRegisters();
1756     StackAllocator earlyFailureStack = m_stackAllocator;
1757 
1758     Assembler::JumpList failureOnFunctionEntry;
1759     // Test selector&#39;s pseudo element equals to requested PseudoId.
1760     if (m_selectorContext != SelectorContext::QuerySelector &amp;&amp; m_functionType == FunctionType::SelectorCheckerWithCheckingContext) {
1761         ASSERT_WITH_MESSAGE(fragmentMatchesTheRightmostElement(m_selectorFragments.first()), &quot;Matching pseudo elements only make sense for the rightmost fragment.&quot;);
1762         generateRequestedPseudoElementEqualsToSelectorPseudoElement(failureOnFunctionEntry, m_selectorFragments.first(), checkingContextRegister);
1763     }
1764 
1765     if (m_selectorContext == SelectorContext::RuleCollector) {
1766         unsigned specificity = m_selectorFragments.staticSpecificity;
1767         if (m_functionType == FunctionType::SelectorCheckerWithCheckingContext)
1768             m_assembler.store32(Assembler::TrustedImm32(specificity), JSC::GPRInfo::argumentGPR2);
1769         else
1770             m_assembler.store32(Assembler::TrustedImm32(specificity), JSC::GPRInfo::argumentGPR1);
1771     }
1772 
1773     computeBacktrackingMemoryRequirements(m_selectorFragments);
1774     unsigned availableRegisterCount = m_registerAllocator.reserveCallerSavedRegisters(m_selectorFragments.registerRequirements);
1775 
1776 #if CSS_SELECTOR_JIT_DEBUGGING
1777     dataLogF(&quot;Compiling with minimum required register count %u, minimum stack space %u\n&quot;, m_selectorFragments.registerRequirements, m_selectorFragments.stackRequirements);
1778 #endif
1779 
1780     // We do not want unbounded stack allocation for backtracking. Going down 8 enry points would already be incredibly inefficient.
1781     unsigned maximumBacktrackingAllocations = 8;
1782     if (m_selectorFragments.stackRequirements &gt; maximumBacktrackingAllocations) {
1783         m_assembler.move(Assembler::TrustedImm32(0), returnRegister);
1784         popMacroAssemblerRegisters(m_stackAllocator);
1785         m_assembler.ret();
1786         return;
1787     }
1788 
1789     bool needsEpilogue = generatePrologue();
1790 
1791     StackAllocator::StackReferenceVector calleeSavedRegisterStackReferences;
1792     bool reservedCalleeSavedRegisters = false;
1793     ASSERT(m_selectorFragments.registerRequirements &lt;= maximumRegisterCount);
1794     if (availableRegisterCount &lt; m_selectorFragments.registerRequirements) {
1795         reservedCalleeSavedRegisters = true;
1796         calleeSavedRegisterStackReferences = m_stackAllocator.push(m_registerAllocator.reserveCalleeSavedRegisters(m_selectorFragments.registerRequirements - availableRegisterCount));
1797     }
1798 
1799     m_registerAllocator.allocateRegister(elementAddressRegister);
1800 
1801     StackAllocator::StackReference temporaryStackBase = m_stackAllocator.stackTop();
1802 
1803     if (m_functionType == FunctionType::SelectorCheckerWithCheckingContext)
1804         m_checkingContextStackReference = m_stackAllocator.push(checkingContextRegister);
1805 
1806     unsigned stackRequirementCount = m_selectorFragments.stackRequirements;
1807     if (m_visitedMode == VisitedMode::Visited)
1808         stackRequirementCount += 2;
1809 
1810     StackAllocator::StackReferenceVector temporaryStack;
1811     if (stackRequirementCount)
1812         temporaryStack = m_stackAllocator.allocateUninitialized(stackRequirementCount);
1813 
1814     if (m_visitedMode == VisitedMode::Visited) {
1815         m_lastVisitedElement = temporaryStack.takeLast();
1816         m_startElement = temporaryStack.takeLast();
1817         m_assembler.storePtr(elementAddressRegister, m_stackAllocator.addressOf(m_startElement));
1818         m_assembler.storePtr(Assembler::TrustedImmPtr(nullptr), m_stackAllocator.addressOf(m_lastVisitedElement));
1819     }
1820 
1821     m_backtrackingStack = temporaryStack;
1822 
1823     Assembler::JumpList failureCases;
1824     generateSelectorCheckerExcludingPseudoElements(failureCases, m_selectorFragments);
1825 
1826     if (m_selectorContext != SelectorContext::QuerySelector &amp;&amp; m_functionType == FunctionType::SelectorCheckerWithCheckingContext) {
1827         ASSERT(!m_selectorFragments.isEmpty());
1828         generateMarkPseudoStyleForPseudoElement(failureCases, m_selectorFragments.first());
1829     }
1830 
1831     if (m_visitedMode == VisitedMode::Visited) {
1832         LocalRegister lastVisitedElement(m_registerAllocator);
1833         m_assembler.loadPtr(m_stackAllocator.addressOf(m_lastVisitedElement), lastVisitedElement);
1834         Assembler::Jump noLastVisitedElement = m_assembler.branchTestPtr(Assembler::Zero, lastVisitedElement);
1835         generateElementIsFirstLink(failureCases, lastVisitedElement);
1836         noLastVisitedElement.link(&amp;m_assembler);
1837     }
1838 
1839     m_registerAllocator.deallocateRegister(elementAddressRegister);
1840 
1841     if (m_functionType == FunctionType::SimpleSelectorChecker) {
1842         if (temporaryStackBase == m_stackAllocator.stackTop() &amp;&amp; !reservedCalleeSavedRegisters &amp;&amp; !needsEpilogue) {
1843             StackAllocator successStack = m_stackAllocator;
1844             StackAllocator failureStack = m_stackAllocator;
1845 
1846             ASSERT(!m_selectorFragments.stackRequirements);
1847             // Success.
1848             m_assembler.move(Assembler::TrustedImm32(1), returnRegister);
1849             popMacroAssemblerRegisters(successStack);
1850             m_assembler.ret();
1851 
1852             // Failure.
1853             ASSERT_WITH_MESSAGE(failureOnFunctionEntry.empty(), &quot;Early failure on function entry is used for pseudo element. When early failure is used, function type is SelectorCheckerWithCheckingContext.&quot;);
1854             if (!failureCases.empty()) {
1855                 failureCases.link(&amp;m_assembler);
1856                 m_assembler.move(Assembler::TrustedImm32(0), returnRegister);
1857                 popMacroAssemblerRegisters(failureStack);
1858                 m_assembler.ret();
1859             } else
1860                 failureStack = successStack;
1861 
1862             m_stackAllocator.merge(WTFMove(successStack), WTFMove(failureStack));
1863             return;
1864         }
1865     }
1866 
1867     // Success.
1868     m_assembler.move(Assembler::TrustedImm32(1), returnRegister);
1869 
1870     // Failure.
1871     if (!failureCases.empty()) {
1872         Assembler::Jump skipFailureCase = m_assembler.jump();
1873         failureCases.link(&amp;m_assembler);
1874         m_assembler.move(Assembler::TrustedImm32(0), returnRegister);
1875         skipFailureCase.link(&amp;m_assembler);
1876     }
1877 
1878     if (temporaryStackBase != m_stackAllocator.stackTop())
1879         m_stackAllocator.popAndDiscardUpTo(temporaryStackBase);
1880     if (reservedCalleeSavedRegisters)
1881         m_stackAllocator.pop(calleeSavedRegisterStackReferences, m_registerAllocator.restoreCalleeSavedRegisters());
1882 
1883     StackAllocator successStack = m_stackAllocator;
1884     if (needsEpilogue)
1885         generateEpilogue(successStack);
1886     popMacroAssemblerRegisters(successStack);
1887     m_assembler.ret();
1888 
1889     // Early failure on function entry case.
1890     if (!failureOnFunctionEntry.empty()) {
1891         failureOnFunctionEntry.link(&amp;m_assembler);
1892         m_assembler.move(Assembler::TrustedImm32(0), returnRegister);
1893         popMacroAssemblerRegisters(earlyFailureStack);
1894         m_assembler.ret();
1895     } else
1896         earlyFailureStack = successStack;
1897     m_stackAllocator.merge(WTFMove(successStack), WTFMove(earlyFailureStack));
1898 }
1899 
1900 void SelectorCodeGenerator::generateSelectorCheckerExcludingPseudoElements(Assembler::JumpList&amp; failureCases, const SelectorFragmentList&amp; selectorFragmentList)
1901 {
1902     m_backtrackingLevels.append(BacktrackingLevel());
1903 
1904     for (const SelectorFragment&amp; fragment : selectorFragmentList) {
1905         switch (fragment.relationToRightFragment) {
1906         case FragmentRelation::Rightmost:
1907             generateRightmostTreeWalker(failureCases, fragment);
1908             break;
1909         case FragmentRelation::Descendant:
1910             generateAncestorTreeWalker(failureCases, fragment);
1911             break;
1912         case FragmentRelation::Child:
1913             generateParentElementTreeWalker(failureCases, fragment);
1914             break;
1915         case FragmentRelation::DirectAdjacent:
1916             generateDirectAdjacentTreeWalker(failureCases, fragment);
1917             break;
1918         case FragmentRelation::IndirectAdjacent:
1919             generateIndirectAdjacentTreeWalker(failureCases, fragment);
1920             break;
1921         }
1922         if (shouldMarkStyleIsAffectedByPreviousSibling(fragment)) {
1923             if (fragmentMatchesTheRightmostElement(fragment))
1924                 generateAddStyleRelationIfResolvingStyle(elementAddressRegister, Style::Relation::AffectedByPreviousSibling);
1925             else
1926                 generateAddStyleRelationIfResolvingStyle(elementAddressRegister, Style::Relation::DescendantsAffectedByPreviousSibling);
1927         }
1928         generateBacktrackingTailsIfNeeded(failureCases, fragment);
1929     }
1930 
1931     ASSERT(!m_backtrackingLevels.last().descendantBacktrackingStart.isValid());
1932     ASSERT(!m_backtrackingLevels.last().adjacentBacktrackingStart.isValid());
1933     m_backtrackingLevels.takeLast();
1934 }
1935 
1936 void SelectorCodeGenerator::generateElementMatchesSelectorList(Assembler::JumpList&amp; failingCases, Assembler::RegisterID elementToMatch, const SelectorList&amp; selectorList)
1937 {
1938     ASSERT(!selectorList.isEmpty());
1939 
1940     RegisterVector registersToSave;
1941 
1942     // The contract is that existing registers are preserved. Two special cases are elementToMatch and elementAddressRegister
1943     // because they are used by the matcher itself.
1944     // To simplify things for now, we just always preserve them on the stack.
1945     unsigned elementToTestIndex = std::numeric_limits&lt;unsigned&gt;::max();
1946     bool isElementToMatchOnStack = false;
1947     if (selectorList.clobberElementAddressRegister) {
1948         if (elementToMatch != elementAddressRegister) {
1949             registersToSave.append(elementAddressRegister);
1950             registersToSave.append(elementToMatch);
1951             elementToTestIndex = 1;
1952             isElementToMatchOnStack = true;
1953         } else {
1954             registersToSave.append(elementAddressRegister);
1955             elementToTestIndex = 0;
1956         }
1957     } else if (elementToMatch != elementAddressRegister)
1958         registersToSave.append(elementAddressRegister);
1959 
1960     // Next, we need to free as many registers as needed by the nested selector list.
1961     unsigned availableRegisterCount = m_registerAllocator.availableRegisterCount();
1962 
1963     // Do not count elementAddressRegister, it will remain allocated.
1964     ++availableRegisterCount;
1965 
1966     if (isElementToMatchOnStack)
1967         ++availableRegisterCount;
1968 
1969     if (selectorList.registerRequirements &gt; availableRegisterCount) {
1970         unsigned registerToPushCount = selectorList.registerRequirements - availableRegisterCount;
1971         for (Assembler::RegisterID registerId : m_registerAllocator.allocatedRegisters()) {
1972             if (registerId == elementAddressRegister)
1973                 continue; // Handled separately above.
1974             if (isElementToMatchOnStack &amp;&amp; registerId == elementToMatch)
1975                 continue; // Do not push the element twice to the stack!
1976 
1977             registersToSave.append(registerId);
1978 
1979             --registerToPushCount;
1980             if (!registerToPushCount)
1981                 break;
1982         }
1983     }
1984 
1985     StackAllocator::StackReferenceVector allocatedRegistersOnStack = m_stackAllocator.push(registersToSave);
1986     for (Assembler::RegisterID registerID : registersToSave) {
1987         if (registerID != elementAddressRegister)
1988             m_registerAllocator.deallocateRegister(registerID);
1989     }
1990 
1991 
1992     if (elementToMatch != elementAddressRegister)
1993         m_assembler.move(elementToMatch, elementAddressRegister);
1994 
1995     Assembler::JumpList localFailureCases;
1996     if (selectorList.size() == 1) {
1997         const SelectorFragmentList&amp; nestedSelectorFragmentList = selectorList.first();
1998         generateSelectorCheckerExcludingPseudoElements(localFailureCases, nestedSelectorFragmentList);
1999     } else {
2000         Assembler::JumpList matchFragmentList;
2001 
2002         unsigned selectorListSize = selectorList.size();
2003         unsigned selectorListLastIndex = selectorListSize - 1;
2004         for (unsigned i = 0; i &lt; selectorList.size(); ++i) {
2005             const SelectorFragmentList&amp; nestedSelectorFragmentList = selectorList[i];
2006             Assembler::JumpList localSelectorFailureCases;
2007             generateSelectorCheckerExcludingPseudoElements(localSelectorFailureCases, nestedSelectorFragmentList);
2008             if (i != selectorListLastIndex) {
2009                 matchFragmentList.append(m_assembler.jump());
2010                 localSelectorFailureCases.link(&amp;m_assembler);
2011 
2012                 if (nestedSelectorFragmentList.clobberElementAddressRegister) {
2013                     RELEASE_ASSERT(elementToTestIndex != std::numeric_limits&lt;unsigned&gt;::max());
2014                     m_assembler.loadPtr(m_stackAllocator.addressOf(allocatedRegistersOnStack[elementToTestIndex]), elementAddressRegister);
2015                 }
2016             } else
2017                 localFailureCases.append(localSelectorFailureCases);
2018         }
2019         matchFragmentList.link(&amp;m_assembler);
2020     }
2021 
2022     // Finally, restore all the registers in the state they were before this selector checker.
2023     for (Assembler::RegisterID registerID : registersToSave) {
2024         if (registerID != elementAddressRegister)
2025             m_registerAllocator.allocateRegister(registerID);
2026     }
2027 
2028     if (allocatedRegistersOnStack.isEmpty()) {
2029         failingCases.append(localFailureCases);
2030         return;
2031     }
2032 
2033     if (localFailureCases.empty())
2034         m_stackAllocator.pop(allocatedRegistersOnStack, registersToSave);
2035     else {
2036         StackAllocator successStack = m_stackAllocator;
2037         StackAllocator failureStack = m_stackAllocator;
2038 
2039         successStack.pop(allocatedRegistersOnStack, registersToSave);
2040 
2041         Assembler::Jump skipFailureCase = m_assembler.jump();
2042         localFailureCases.link(&amp;m_assembler);
2043         failureStack.pop(allocatedRegistersOnStack, registersToSave);
2044         failingCases.append(m_assembler.jump());
2045 
2046         skipFailureCase.link(&amp;m_assembler);
2047 
2048         m_stackAllocator.merge(WTFMove(successStack), WTFMove(failureStack));
2049     }
2050 }
2051 
2052 void SelectorCodeGenerator::generateRightmostTreeWalker(Assembler::JumpList&amp; failureCases, const SelectorFragment&amp; fragment)
2053 {
2054     generateElementMatching(failureCases, failureCases, fragment);
2055 }
2056 
2057 void SelectorCodeGenerator::generateWalkToParentNode(Assembler::RegisterID targetRegister)
2058 {
2059     m_assembler.loadPtr(Assembler::Address(elementAddressRegister, Node::parentNodeMemoryOffset()), targetRegister);
2060 }
2061 
2062 void SelectorCodeGenerator::generateWalkToParentElement(Assembler::JumpList&amp; failureCases, Assembler::RegisterID targetRegister)
2063 {
2064     //    ContainerNode* parent = parentNode()
2065     //    if (!parent || !parent-&gt;isElementNode())
2066     //         failure
2067     generateWalkToParentNode(targetRegister);
2068     failureCases.append(m_assembler.branchTestPtr(Assembler::Zero, targetRegister));
2069     failureCases.append(DOMJIT::branchTestIsElementFlagOnNode(m_assembler, Assembler::Zero, targetRegister));
2070 }
2071 
2072 void SelectorCodeGenerator::generateWalkToParentElementOrShadowRoot(Assembler::JumpList&amp; failureCases, Assembler::RegisterID targetRegister)
2073 {
2074     //    ContainerNode* parent = parentNode()
2075     //    if (!parent || !(parent-&gt;isElementNode() || parent-&gt;isShadowRoot()))
2076     //         failure
2077     generateWalkToParentNode(targetRegister);
2078     failureCases.append(m_assembler.branchTestPtr(Assembler::Zero, targetRegister));
2079     failureCases.append(DOMJIT::branchTestIsElementOrShadowRootFlagOnNode(m_assembler, Assembler::Zero, targetRegister));
2080 }
2081 
2082 void SelectorCodeGenerator::generateParentElementTreeWalker(Assembler::JumpList&amp; failureCases, const SelectorFragment&amp; fragment)
2083 {
2084     Assembler::JumpList traversalFailureCases;
2085     generateWalkToParentElement(traversalFailureCases, elementAddressRegister);
2086     linkFailures(failureCases, fragment.traversalBacktrackingAction, traversalFailureCases);
2087 
2088     Assembler::JumpList matchingTagNameFailureCases;
2089     Assembler::JumpList matchingPostTagNameFailureCases;
2090     generateElementMatching(matchingTagNameFailureCases, matchingPostTagNameFailureCases, fragment);
2091     linkFailures(failureCases, fragment.matchingTagNameBacktrackingAction, matchingTagNameFailureCases);
2092     linkFailures(failureCases, fragment.matchingPostTagNameBacktrackingAction, matchingPostTagNameFailureCases);
2093 
2094     if (fragment.backtrackingFlags &amp; BacktrackingFlag::SaveDescendantBacktrackingStart) {
2095         if (!m_descendantBacktrackingStartInUse) {
2096             m_descendantBacktrackingStart = m_registerAllocator.allocateRegister();
2097             m_assembler.move(elementAddressRegister, m_descendantBacktrackingStart);
2098             m_descendantBacktrackingStartInUse = true;
2099         } else {
2100             BacktrackingLevel&amp; currentBacktrackingLevel = m_backtrackingLevels.last();
2101             ASSERT(!currentBacktrackingLevel.descendantBacktrackingStart.isValid());
2102             currentBacktrackingLevel.descendantBacktrackingStart = m_backtrackingStack.takeLast();
2103 
2104             m_assembler.storePtr(elementAddressRegister, m_stackAllocator.addressOf(currentBacktrackingLevel.descendantBacktrackingStart));
2105         }
2106     }
2107 }
2108 
2109 void SelectorCodeGenerator::generateAncestorTreeWalker(Assembler::JumpList&amp; failureCases, const SelectorFragment&amp; fragment)
2110 {
2111     // Loop over the ancestors until one of them matches the fragment.
2112     Assembler::Label loopStart(m_assembler.label());
2113 
2114     if (fragment.backtrackingFlags &amp; BacktrackingFlag::DescendantEntryPoint)
2115         m_backtrackingLevels.last().descendantTreeWalkerBacktrackingPoint = m_assembler.label();
2116 
2117     generateWalkToParentElement(failureCases, elementAddressRegister);
2118 
2119     if (fragment.backtrackingFlags &amp; BacktrackingFlag::DescendantEntryPoint)
2120         m_backtrackingLevels.last().descendantEntryPoint = m_assembler.label();
2121 
2122     Assembler::JumpList matchingFailureCases;
2123     generateElementMatching(matchingFailureCases, matchingFailureCases, fragment);
2124     matchingFailureCases.linkTo(loopStart, &amp;m_assembler);
2125 }
2126 
2127 inline void SelectorCodeGenerator::generateWalkToNextAdjacentElement(Assembler::JumpList&amp; failureCases, Assembler::RegisterID workRegister)
2128 {
2129     Assembler::Label loopStart = m_assembler.label();
2130     m_assembler.loadPtr(Assembler::Address(workRegister, Node::nextSiblingMemoryOffset()), workRegister);
2131     failureCases.append(m_assembler.branchTestPtr(Assembler::Zero, workRegister));
2132     DOMJIT::branchTestIsElementFlagOnNode(m_assembler, Assembler::Zero, workRegister).linkTo(loopStart, &amp;m_assembler);
2133 }
2134 
2135 inline void SelectorCodeGenerator::generateWalkToPreviousAdjacentElement(Assembler::JumpList&amp; failureCases, Assembler::RegisterID workRegister)
2136 {
2137     Assembler::Label loopStart = m_assembler.label();
2138     m_assembler.loadPtr(Assembler::Address(workRegister, Node::previousSiblingMemoryOffset()), workRegister);
2139     failureCases.append(m_assembler.branchTestPtr(Assembler::Zero, workRegister));
2140     DOMJIT::branchTestIsElementFlagOnNode(m_assembler, Assembler::Zero, workRegister).linkTo(loopStart, &amp;m_assembler);
2141 }
2142 
2143 void SelectorCodeGenerator::generateWalkToPreviousAdjacent(Assembler::JumpList&amp; failureCases, const SelectorFragment&amp; fragment)
2144 {
2145     //    do {
2146     //        previousSibling = previousSibling-&gt;previousSibling();
2147     //        if (!previousSibling)
2148     //            failure!
2149     //    while (!previousSibling-&gt;isElement());
2150     Assembler::RegisterID previousSibling;
2151     bool useTailOnTraversalFailure = fragment.traversalBacktrackingAction &gt;= BacktrackingAction::JumpToDescendantTail;
2152     if (!useTailOnTraversalFailure) {
2153         // If the current fragment is not dependant on a previously saved elementAddressRegister, a fast recover
2154         // from a failure would resume with elementAddressRegister.
2155         // When walking to the previous sibling, the failure can be that previousSibling is null. We cannot backtrack
2156         // with a null elementAddressRegister so we do the traversal on a copy.
2157         previousSibling = m_registerAllocator.allocateRegister();
2158         m_assembler.move(elementAddressRegister, previousSibling);
2159     } else
2160         previousSibling = elementAddressRegister;
2161 
2162     Assembler::JumpList traversalFailureCases;
2163     generateWalkToPreviousAdjacentElement(traversalFailureCases, previousSibling);
2164     linkFailures(failureCases, fragment.traversalBacktrackingAction, traversalFailureCases);
2165 
2166     // On success, move previousSibling over to elementAddressRegister if we could not work on elementAddressRegister directly.
2167     if (!useTailOnTraversalFailure) {
2168         m_assembler.move(previousSibling, elementAddressRegister);
2169         m_registerAllocator.deallocateRegister(previousSibling);
2170     }
2171 }
2172 
2173 void SelectorCodeGenerator::generateDirectAdjacentTreeWalker(Assembler::JumpList&amp; failureCases, const SelectorFragment&amp; fragment)
2174 {
2175     generateWalkToPreviousAdjacent(failureCases, fragment);
2176     generateAddStyleRelationIfResolvingStyle(elementAddressRegister, Style::Relation::AffectsNextSibling);
2177 
2178     Assembler::JumpList matchingTagNameFailureCases;
2179     Assembler::JumpList matchingPostTagNameFailureCases;
2180     generateElementMatching(matchingTagNameFailureCases, matchingPostTagNameFailureCases, fragment);
2181     linkFailures(failureCases, fragment.matchingTagNameBacktrackingAction, matchingTagNameFailureCases);
2182     linkFailures(failureCases, fragment.matchingPostTagNameBacktrackingAction, matchingPostTagNameFailureCases);
2183 
2184     if (fragment.backtrackingFlags &amp; BacktrackingFlag::SaveAdjacentBacktrackingStart) {
2185         BacktrackingLevel&amp; currentBacktrackingLevel = m_backtrackingLevels.last();
2186         ASSERT(!currentBacktrackingLevel.adjacentBacktrackingStart.isValid());
2187         currentBacktrackingLevel.adjacentBacktrackingStart = m_backtrackingStack.takeLast();
2188 
2189         m_assembler.storePtr(elementAddressRegister, m_stackAllocator.addressOf(currentBacktrackingLevel.adjacentBacktrackingStart));
2190     }
2191 }
2192 
2193 void SelectorCodeGenerator::generateIndirectAdjacentTreeWalker(Assembler::JumpList&amp; failureCases, const SelectorFragment&amp; fragment)
2194 {
2195     Assembler::Label loopStart(m_assembler.label());
2196 
2197     if (fragment.backtrackingFlags &amp; BacktrackingFlag::IndirectAdjacentEntryPoint)
2198         m_backtrackingLevels.last().indirectAdjacentTreeWalkerBacktrackingPoint = m_assembler.label();
2199 
2200     generateWalkToPreviousAdjacent(failureCases, fragment);
2201     generateAddStyleRelationIfResolvingStyle(elementAddressRegister, Style::Relation::AffectsNextSibling);
2202 
2203     if (fragment.backtrackingFlags &amp; BacktrackingFlag::IndirectAdjacentEntryPoint)
2204         m_backtrackingLevels.last().indirectAdjacentEntryPoint = m_assembler.label();
2205 
2206     Assembler::JumpList localFailureCases;
2207     generateElementMatching(localFailureCases, localFailureCases, fragment);
2208     localFailureCases.linkTo(loopStart, &amp;m_assembler);
2209 }
2210 
2211 void SelectorCodeGenerator::generateAddStyleRelationIfResolvingStyle(Assembler::RegisterID element, Style::Relation::Type relationType, Optional&lt;Assembler::RegisterID&gt; value)
2212 {
2213     if (m_selectorContext == SelectorContext::QuerySelector)
2214         return;
2215 
2216     LocalRegister checkingContext(m_registerAllocator);
2217     Assembler::Jump notResolvingStyle = jumpIfNotResolvingStyle(checkingContext);
2218 
2219     generateAddStyleRelation(checkingContext, element, relationType, value);
2220 
2221     notResolvingStyle.link(&amp;m_assembler);
2222 }
2223 
2224 static void addStyleRelationFunction(SelectorChecker::CheckingContext* checkingContext, const Element* element)
2225 {
2226     checkingContext-&gt;styleRelations.append({ *element, Style::Relation::AffectedByActive, 1 });
2227 }
2228 
2229 void SelectorCodeGenerator::generateAddStyleRelation(Assembler::RegisterID checkingContext, Assembler::RegisterID element, Style::Relation::Type relationType, Optional&lt;Assembler::RegisterID&gt; value)
2230 {
2231     ASSERT(m_selectorContext != SelectorContext::QuerySelector);
2232 
2233     Assembler::Address vectorAddress(checkingContext, OBJECT_OFFSETOF(SelectorChecker::CheckingContext, styleRelations));
2234     auto dataAddress = vectorAddress.withOffset(Style::Relations::dataMemoryOffset());
2235     auto sizeAddress = vectorAddress.withOffset(Style::Relations::sizeMemoryOffset());
2236 
2237     auto getLastRelationPointer = [&amp;] (Assembler::RegisterID sizeAndTarget) {
2238         m_assembler.sub32(Assembler::TrustedImm32(1), sizeAndTarget);
2239 #if CPU(ADDRESS64)
2240         static_assert(sizeof(Style::Relation) == 16, &quot;&quot;);
2241         static_assert(1 &lt;&lt; 4 == 16, &quot;&quot;);
2242         m_assembler.lshiftPtr(Assembler::TrustedImm32(4), sizeAndTarget);
2243 #else
2244         m_assembler.mul32(Assembler::TrustedImm32(sizeof(Style::Relation)), sizeAndTarget, sizeAndTarget);
2245 #endif
2246         m_assembler.addPtr(dataAddress, sizeAndTarget);
2247     };
2248 
2249     // For AffectsNextSibling we just increment the count if the previous added relation was in the same sibling chain.
2250     Assembler::JumpList mergeSuccess;
2251     if (relationType == Style::Relation::AffectsNextSibling) {
2252         Assembler::JumpList mergeFailure;
2253 
2254         LocalRegister lastRelation(m_registerAllocator);
2255         m_assembler.load32(sizeAddress, lastRelation);
2256 
2257         // if (!checkingContext.styleRelations.isEmpty())
2258         mergeFailure.append(m_assembler.branchTest32(Assembler::Zero, lastRelation));
2259 
2260         // Style::Relation&amp; lastRelation = checkingContext.styleRelations.last();
2261         getLastRelationPointer(lastRelation);
2262 
2263         // if (lastRelation.type == Style::Relation::AffectsNextSibling)
2264         Assembler::Address typeAddress(lastRelation, OBJECT_OFFSETOF(Style::Relation, type));
2265         mergeFailure.append(m_assembler.branch32(Assembler::NotEqual, typeAddress, Assembler::TrustedImm32(Style::Relation::AffectsNextSibling)));
2266 
2267         Assembler::Address elementAddress(lastRelation, OBJECT_OFFSETOF(Style::Relation, element));
2268         {
2269             // if (element.nextSiblingElement() == lastRelation.element)
2270             LocalRegister nextSiblingElement(m_registerAllocator);
2271             m_assembler.move(element, nextSiblingElement);
2272             generateWalkToNextAdjacentElement(mergeFailure, nextSiblingElement);
2273             mergeFailure.append(m_assembler.branchPtr(Assembler::NotEqual, nextSiblingElement, elementAddress));
2274         }
2275 
2276         // ++lastRelation.value;
2277         Assembler::Address valueAddress(lastRelation, OBJECT_OFFSETOF(Style::Relation, value));
2278         m_assembler.add32(Assembler::TrustedImm32(1), valueAddress);
2279 
2280         // lastRelation.element = &amp;element;
2281         m_assembler.storePtr(element, elementAddress);
2282 
2283         mergeSuccess.append(m_assembler.jump());
2284         mergeFailure.link(&amp;m_assembler);
2285     }
2286 
2287     // FIXME: Append to vector without a function call at least when there is sufficient capacity.
2288     FunctionCall functionCall(m_assembler, m_registerAllocator, m_stackAllocator, m_functionCalls);
2289     functionCall.setFunctionAddress(addStyleRelationFunction);
2290     functionCall.setTwoArguments(checkingContext, element);
2291     functionCall.call();
2292 
2293     LocalRegister relationPointer(m_registerAllocator);
2294     m_assembler.load32(sizeAddress, relationPointer);
2295     getLastRelationPointer(relationPointer);
2296 
2297     Assembler::Address typeAddress(relationPointer, OBJECT_OFFSETOF(Style::Relation, type));
2298     m_assembler.store32(Assembler::TrustedImm32(relationType), typeAddress);
2299 
2300     if (value) {
2301         Assembler::Address valueAddress(relationPointer, OBJECT_OFFSETOF(Style::Relation, value));
2302         m_assembler.store32(*value, valueAddress);
2303     }
2304 
2305     mergeSuccess.link(&amp;m_assembler);
2306 }
2307 
2308 Assembler::JumpList SelectorCodeGenerator::jumpIfNoPreviousAdjacentElement()
2309 {
2310     Assembler::JumpList successCase;
2311     LocalRegister previousSibling(m_registerAllocator);
2312     m_assembler.move(elementAddressRegister, previousSibling);
2313     generateWalkToPreviousAdjacentElement(successCase, previousSibling);
2314     return successCase;
2315 }
2316 
2317 Assembler::JumpList SelectorCodeGenerator::jumpIfNoNextAdjacentElement()
2318 {
2319     Assembler::JumpList successCase;
2320     LocalRegister nextSibling(m_registerAllocator);
2321     m_assembler.move(elementAddressRegister, nextSibling);
2322     generateWalkToNextAdjacentElement(successCase, nextSibling);
2323     return successCase;
2324 }
2325 
2326 
2327 void SelectorCodeGenerator::loadCheckingContext(Assembler::RegisterID checkingContext)
2328 {
2329     // Get the checking context.
2330     RELEASE_ASSERT(m_functionType == FunctionType::SelectorCheckerWithCheckingContext);
2331     m_assembler.loadPtr(m_stackAllocator.addressOf(m_checkingContextStackReference), checkingContext);
2332 }
2333 
2334 Assembler::Jump SelectorCodeGenerator::branchOnResolvingModeWithCheckingContext(Assembler::RelationalCondition condition, SelectorChecker::Mode mode, Assembler::RegisterID checkingContext)
2335 {
2336     // Depend on the specified resolving mode and our current mode, branch.
2337     static_assert(sizeof(SelectorChecker::Mode) == 1, &quot;We generate a byte load/test for the SelectorChecker::Mode.&quot;);
2338     return m_assembler.branch8(condition, Assembler::Address(checkingContext, OBJECT_OFFSETOF(SelectorChecker::CheckingContext, resolvingMode)), Assembler::TrustedImm32(static_cast&lt;std::underlying_type&lt;SelectorChecker::Mode&gt;::type&gt;(mode)));
2339 
2340 }
2341 
2342 Assembler::Jump SelectorCodeGenerator::branchOnResolvingMode(Assembler::RelationalCondition condition, SelectorChecker::Mode mode, Assembler::RegisterID checkingContext)
2343 {
2344     loadCheckingContext(checkingContext);
2345     return branchOnResolvingModeWithCheckingContext(condition, mode, checkingContext);
2346 }
2347 
2348 Assembler::Jump SelectorCodeGenerator::jumpIfNotResolvingStyle(Assembler::RegisterID checkingContext)
2349 {
2350     return branchOnResolvingMode(Assembler::NotEqual, SelectorChecker::Mode::ResolvingStyle, checkingContext);
2351 }
2352 
2353 void SelectorCodeGenerator::generateSpecialFailureInQuirksModeForActiveAndHoverIfNeeded(Assembler::JumpList&amp; failureCases, const SelectorFragment&amp; fragment)
2354 {
2355     if (fragment.onlyMatchesLinksInQuirksMode) {
2356         // If the element is a link, it can always match :hover or :active.
2357         Assembler::Jump isLink = m_assembler.branchTest32(Assembler::NonZero, Assembler::Address(elementAddressRegister, Node::nodeFlagsMemoryOffset()), Assembler::TrustedImm32(Node::flagIsLink()));
2358 
2359         // Only quirks mode restrict :hover and :active.
2360         static_assert(sizeof(DocumentCompatibilityMode) == 1, &quot;We generate a byte load/test for the compatibility mode.&quot;);
2361         LocalRegister documentAddress(m_registerAllocator);
2362         DOMJIT::loadDocument(m_assembler, elementAddressRegister, documentAddress);
2363         failureCases.append(m_assembler.branchTest8(Assembler::NonZero, Assembler::Address(documentAddress, Document::compatibilityModeMemoryOffset()), Assembler::TrustedImm32(static_cast&lt;std::underlying_type&lt;DocumentCompatibilityMode&gt;::type&gt;(DocumentCompatibilityMode::QuirksMode))));
2364 
2365         isLink.link(&amp;m_assembler);
2366     }
2367 }
2368 
2369 #if CPU(ARM_THUMB2) &amp;&amp; !CPU(APPLE_ARMV7S)
2370 // FIXME: This could be implemented in assembly to avoid a function call, and we know the divisor at jit-compile time.
2371 static int moduloHelper(int dividend, int divisor)
2372 {
2373     return dividend % divisor;
2374 }
2375 #endif
2376 
2377 // The value in inputDividend is destroyed by the modulo operation.
2378 Assembler::Jump SelectorCodeGenerator::modulo(Assembler::ResultCondition condition, Assembler::RegisterID inputDividend, int divisor)
2379 {
2380     RELEASE_ASSERT(divisor);
2381 #if CPU(ARM64) || CPU(APPLE_ARMV7S)
2382     LocalRegister divisorRegister(m_registerAllocator);
2383     m_assembler.move(Assembler::TrustedImm32(divisor), divisorRegister);
2384 
2385     LocalRegister resultRegister(m_registerAllocator);
2386     m_assembler.m_assembler.sdiv&lt;32&gt;(resultRegister, inputDividend, divisorRegister);
2387     m_assembler.mul32(divisorRegister, resultRegister);
2388     return m_assembler.branchSub32(condition, inputDividend, resultRegister, resultRegister);
2389 #elif CPU(ARM_THUMB2) &amp;&amp; !CPU(APPLE_ARMV7S)
2390     LocalRegisterWithPreference divisorRegister(m_registerAllocator, JSC::GPRInfo::argumentGPR1);
2391     m_assembler.move(Assembler::TrustedImm32(divisor), divisorRegister);
2392     FunctionCall functionCall(m_assembler, m_registerAllocator, m_stackAllocator, m_functionCalls);
2393     functionCall.setFunctionAddress(moduloHelper);
2394     functionCall.setTwoArguments(inputDividend, divisorRegister);
2395     return functionCall.callAndBranchOnBooleanReturnValue(condition);
2396 #elif CPU(X86_64)
2397     // idiv takes RAX + an arbitrary register, and return RAX + RDX. Most of this code is about doing
2398     // an efficient allocation of those registers. If a register is already in use and is not the inputDividend,
2399     // we first try to copy it to a temporary register, it that is not possible we fall back to the stack.
2400     enum class RegisterAllocationType {
2401         External,
2402         AllocatedLocally,
2403         CopiedToTemporary,
2404         PushedToStack
2405     };
2406 
2407     // 1) Get RAX and RDX.
2408     // If they are already used, push them to the stack.
2409     Assembler::RegisterID dividend = JSC::X86Registers::eax;
2410     RegisterAllocationType dividendAllocation = RegisterAllocationType::External;
2411     StackAllocator::StackReference temporaryDividendStackReference;
2412     Assembler::RegisterID temporaryDividendCopy = JSC::InvalidGPRReg;
2413     if (inputDividend != dividend) {
2414         bool registerIsInUse = m_registerAllocator.allocatedRegisters().contains(dividend);
2415         if (registerIsInUse) {
2416             if (m_registerAllocator.availableRegisterCount() &gt; 1) {
2417                 temporaryDividendCopy = m_registerAllocator.allocateRegister();
2418                 m_assembler.move(dividend, temporaryDividendCopy);
2419                 dividendAllocation = RegisterAllocationType::CopiedToTemporary;
2420             } else {
2421                 temporaryDividendStackReference = m_stackAllocator.push(dividend);
2422                 dividendAllocation = RegisterAllocationType::PushedToStack;
2423             }
2424         } else {
2425             m_registerAllocator.allocateRegister(dividend);
2426             dividendAllocation = RegisterAllocationType::AllocatedLocally;
2427         }
2428         m_assembler.move(inputDividend, dividend);
2429     }
2430 
2431     Assembler::RegisterID remainder = JSC::X86Registers::edx;
2432     RegisterAllocationType remainderAllocation = RegisterAllocationType::External;
2433     StackAllocator::StackReference temporaryRemainderStackReference;
2434     Assembler::RegisterID temporaryRemainderCopy = JSC::InvalidGPRReg;
2435     if (inputDividend != remainder) {
2436         bool registerIsInUse = m_registerAllocator.allocatedRegisters().contains(remainder);
2437         if (registerIsInUse) {
2438             if (m_registerAllocator.availableRegisterCount() &gt; 1) {
2439                 temporaryRemainderCopy = m_registerAllocator.allocateRegister();
2440                 m_assembler.move(remainder, temporaryRemainderCopy);
2441                 remainderAllocation = RegisterAllocationType::CopiedToTemporary;
2442             } else {
2443                 temporaryRemainderStackReference = m_stackAllocator.push(remainder);
2444                 remainderAllocation = RegisterAllocationType::PushedToStack;
2445             }
2446         } else {
2447             m_registerAllocator.allocateRegister(remainder);
2448             remainderAllocation = RegisterAllocationType::AllocatedLocally;
2449         }
2450     }
2451 
2452     // If the input register is used by idiv, save its value to restore it after the operation.
2453     Assembler::RegisterID inputDividendCopy;
2454     StackAllocator::StackReference pushedInputDividendStackReference;
2455     RegisterAllocationType savedInputDividendAllocationType = RegisterAllocationType::External;
2456     if (inputDividend == dividend || inputDividend == remainder) {
2457         if (m_registerAllocator.availableRegisterCount() &gt; 1) {
2458             inputDividendCopy = m_registerAllocator.allocateRegister();
2459             m_assembler.move(inputDividend, inputDividendCopy);
2460             savedInputDividendAllocationType = RegisterAllocationType::CopiedToTemporary;
2461         } else {
2462             pushedInputDividendStackReference = m_stackAllocator.push(inputDividend);
2463             savedInputDividendAllocationType = RegisterAllocationType::PushedToStack;
2464         }
2465     }
2466 
2467     m_assembler.m_assembler.cdq();
2468 
2469     // 2) Perform the division with idiv.
2470     {
2471         LocalRegister divisorRegister(m_registerAllocator);
2472         m_assembler.move(Assembler::TrustedImm64(divisor), divisorRegister);
2473         m_assembler.m_assembler.idivl_r(divisorRegister);
2474         m_assembler.test32(remainder);
2475     }
2476 
2477     // 3) Return RAX and RDX.
2478     if (remainderAllocation == RegisterAllocationType::AllocatedLocally)
2479         m_registerAllocator.deallocateRegister(remainder);
2480     else if (remainderAllocation == RegisterAllocationType::CopiedToTemporary) {
2481         m_assembler.move(temporaryRemainderCopy, remainder);
2482         m_registerAllocator.deallocateRegister(temporaryRemainderCopy);
2483     } else if (remainderAllocation == RegisterAllocationType::PushedToStack)
2484         m_stackAllocator.pop(temporaryRemainderStackReference, remainder);
2485 
2486     if (dividendAllocation == RegisterAllocationType::AllocatedLocally)
2487         m_registerAllocator.deallocateRegister(dividend);
2488     else if (dividendAllocation == RegisterAllocationType::CopiedToTemporary) {
2489         m_assembler.move(temporaryDividendCopy, dividend);
2490         m_registerAllocator.deallocateRegister(temporaryDividendCopy);
2491     } else if (dividendAllocation == RegisterAllocationType::PushedToStack)
2492         m_stackAllocator.pop(temporaryDividendStackReference, dividend);
2493 
2494     if (savedInputDividendAllocationType != RegisterAllocationType::External) {
2495         if (savedInputDividendAllocationType == RegisterAllocationType::CopiedToTemporary) {
2496             m_assembler.move(inputDividendCopy, inputDividend);
2497             m_registerAllocator.deallocateRegister(inputDividendCopy);
2498         } else if (savedInputDividendAllocationType == RegisterAllocationType::PushedToStack)
2499             m_stackAllocator.pop(pushedInputDividendStackReference, inputDividend);
2500     }
2501 
2502     // 4) Branch on the test.
2503     return m_assembler.branch(condition);
2504 #else
2505 #error Modulo is not implemented for this architecture.
2506 #endif
2507 }
2508 
2509 void SelectorCodeGenerator::moduloIsZero(Assembler::JumpList&amp; failureCases, Assembler::RegisterID inputDividend, int divisor)
2510 {
2511     if (divisor == 1 || divisor == -1)
2512         return;
2513     if (divisor == 2 || divisor == -2) {
2514         failureCases.append(m_assembler.branchTest32(Assembler::NonZero, inputDividend, Assembler::TrustedImm32(1)));
2515         return;
2516     }
2517 
2518     failureCases.append(modulo(Assembler::NonZero, inputDividend, divisor));
2519 }
2520 
2521 void SelectorCodeGenerator::linkFailures(Assembler::JumpList&amp; globalFailureCases, BacktrackingAction backtrackingAction, Assembler::JumpList&amp; localFailureCases)
2522 {
2523     switch (backtrackingAction) {
2524     case BacktrackingAction::NoBacktracking:
2525         globalFailureCases.append(localFailureCases);
2526         break;
2527     case BacktrackingAction::JumpToDescendantEntryPoint:
2528         localFailureCases.linkTo(m_backtrackingLevels.last().descendantEntryPoint, &amp;m_assembler);
2529         break;
2530     case BacktrackingAction::JumpToDescendantTreeWalkerEntryPoint:
2531         localFailureCases.linkTo(m_backtrackingLevels.last().descendantTreeWalkerBacktrackingPoint, &amp;m_assembler);
2532         break;
2533     case BacktrackingAction::JumpToDescendantTail:
2534         m_backtrackingLevels.last().descendantBacktrackingFailureCases.append(localFailureCases);
2535         break;
2536     case BacktrackingAction::JumpToIndirectAdjacentEntryPoint:
2537         localFailureCases.linkTo(m_backtrackingLevels.last().indirectAdjacentEntryPoint, &amp;m_assembler);
2538         break;
2539     case BacktrackingAction::JumpToIndirectAdjacentTreeWalkerEntryPoint:
2540         localFailureCases.linkTo(m_backtrackingLevels.last().indirectAdjacentTreeWalkerBacktrackingPoint, &amp;m_assembler);
2541         break;
2542     case BacktrackingAction::JumpToDirectAdjacentTail:
2543         m_backtrackingLevels.last().adjacentBacktrackingFailureCases.append(localFailureCases);
2544         break;
2545     }
2546 }
2547 
2548 void SelectorCodeGenerator::generateAdjacentBacktrackingTail()
2549 {
2550     // Recovering tail.
2551     m_backtrackingLevels.last().adjacentBacktrackingFailureCases.link(&amp;m_assembler);
2552     m_backtrackingLevels.last().adjacentBacktrackingFailureCases.clear();
2553 
2554     BacktrackingLevel&amp; currentBacktrackingLevel = m_backtrackingLevels.last();
2555     m_assembler.loadPtr(m_stackAllocator.addressOf(currentBacktrackingLevel.adjacentBacktrackingStart), elementAddressRegister);
2556     m_backtrackingStack.append(currentBacktrackingLevel.adjacentBacktrackingStart);
2557     currentBacktrackingLevel.adjacentBacktrackingStart = StackAllocator::StackReference();
2558 
2559     m_assembler.jump(m_backtrackingLevels.last().indirectAdjacentEntryPoint);
2560 }
2561 
2562 void SelectorCodeGenerator::generateDescendantBacktrackingTail()
2563 {
2564     m_backtrackingLevels.last().descendantBacktrackingFailureCases.link(&amp;m_assembler);
2565     m_backtrackingLevels.last().descendantBacktrackingFailureCases.clear();
2566 
2567     BacktrackingLevel&amp; currentBacktrackingLevel = m_backtrackingLevels.last();
2568     if (!currentBacktrackingLevel.descendantBacktrackingStart.isValid()) {
2569         m_assembler.move(m_descendantBacktrackingStart, elementAddressRegister);
2570         m_registerAllocator.deallocateRegister(m_descendantBacktrackingStart);
2571         m_descendantBacktrackingStartInUse = false;
2572     } else {
2573         m_assembler.loadPtr(m_stackAllocator.addressOf(currentBacktrackingLevel.descendantBacktrackingStart), elementAddressRegister);
2574         m_backtrackingStack.append(currentBacktrackingLevel.descendantBacktrackingStart);
2575         currentBacktrackingLevel.descendantBacktrackingStart = StackAllocator::StackReference();
2576     }
2577 
2578     m_assembler.jump(m_backtrackingLevels.last().descendantEntryPoint);
2579 }
2580 
2581 void SelectorCodeGenerator::generateBacktrackingTailsIfNeeded(Assembler::JumpList&amp; failureCases, const SelectorFragment&amp; fragment)
2582 {
2583     if (fragment.backtrackingFlags &amp; BacktrackingFlag::DirectAdjacentTail &amp;&amp; fragment.backtrackingFlags &amp; BacktrackingFlag::DescendantTail) {
2584         Assembler::Jump normalCase = m_assembler.jump();
2585         generateAdjacentBacktrackingTail();
2586         generateDescendantBacktrackingTail();
2587         normalCase.link(&amp;m_assembler);
2588     } else if (fragment.backtrackingFlags &amp; BacktrackingFlag::DirectAdjacentTail) {
2589         Assembler::Jump normalCase = m_assembler.jump();
2590         generateAdjacentBacktrackingTail();
2591         failureCases.append(m_assembler.jump());
2592         normalCase.link(&amp;m_assembler);
2593     } else if (fragment.backtrackingFlags &amp; BacktrackingFlag::DescendantTail) {
2594         Assembler::Jump normalCase = m_assembler.jump();
2595         generateDescendantBacktrackingTail();
2596         normalCase.link(&amp;m_assembler);
2597     }
2598 }
2599 
2600 void SelectorCodeGenerator::generateElementMatching(Assembler::JumpList&amp; matchingTagNameFailureCases, Assembler::JumpList&amp; matchingPostTagNameFailureCases, const SelectorFragment&amp; fragment)
2601 {
2602     if (fragment.tagNameSelector)
2603         generateElementHasTagName(matchingTagNameFailureCases, *(fragment.tagNameSelector));
2604 
2605     generateElementLinkMatching(matchingPostTagNameFailureCases, fragment);
2606 
2607     if (fragment.pseudoClasses.contains(CSSSelector::PseudoClassRoot))
2608         generateElementIsRoot(matchingPostTagNameFailureCases);
2609 
2610     if (fragment.pseudoClasses.contains(CSSSelector::PseudoClassScope))
2611         generateElementIsScopeRoot(matchingPostTagNameFailureCases);
2612 
2613     if (fragment.pseudoClasses.contains(CSSSelector::PseudoClassTarget))
2614         generateElementIsTarget(matchingPostTagNameFailureCases);
2615 
2616     if (fragment.pseudoClasses.contains(CSSSelector::PseudoClassFocusWithin))
2617         generateElementHasFocusWithin(matchingPostTagNameFailureCases);
2618 
2619     for (unsigned i = 0; i &lt; fragment.unoptimizedPseudoClasses.size(); ++i)
2620         generateElementFunctionCallTest(matchingPostTagNameFailureCases, fragment.unoptimizedPseudoClasses[i]);
2621 
2622     for (unsigned i = 0; i &lt; fragment.unoptimizedPseudoClassesWithContext.size(); ++i)
2623         generateContextFunctionCallTest(matchingPostTagNameFailureCases, fragment.unoptimizedPseudoClassesWithContext[i]);
2624 
2625     generateElementDataMatching(matchingPostTagNameFailureCases, fragment);
2626 
2627     if (fragment.pseudoClasses.contains(CSSSelector::PseudoClassActive))
2628         generateElementIsActive(matchingPostTagNameFailureCases, fragment);
2629     if (fragment.pseudoClasses.contains(CSSSelector::PseudoClassEmpty))
2630         generateElementIsEmpty(matchingPostTagNameFailureCases);
2631     if (fragment.pseudoClasses.contains(CSSSelector::PseudoClassHover))
2632         generateElementIsHovered(matchingPostTagNameFailureCases, fragment);
2633     if (fragment.pseudoClasses.contains(CSSSelector::PseudoClassOnlyChild))
2634         generateElementIsOnlyChild(matchingPostTagNameFailureCases);
2635     if (fragment.pseudoClasses.contains(CSSSelector::PseudoClassPlaceholderShown))
2636         generateElementHasPlaceholderShown(matchingPostTagNameFailureCases);
2637     if (fragment.pseudoClasses.contains(CSSSelector::PseudoClassFirstChild))
2638         generateElementIsFirstChild(matchingPostTagNameFailureCases);
2639     if (fragment.pseudoClasses.contains(CSSSelector::PseudoClassLastChild))
2640         generateElementIsLastChild(matchingPostTagNameFailureCases);
2641     if (!fragment.nthChildFilters.isEmpty())
2642         generateElementIsNthChild(matchingPostTagNameFailureCases, fragment);
2643     if (!fragment.nthLastChildFilters.isEmpty())
2644         generateElementIsNthLastChild(matchingPostTagNameFailureCases, fragment);
2645     if (!fragment.notFilters.isEmpty())
2646         generateElementMatchesNotPseudoClass(matchingPostTagNameFailureCases, fragment);
2647     if (!fragment.anyFilters.isEmpty())
2648         generateElementMatchesAnyPseudoClass(matchingPostTagNameFailureCases, fragment);
2649     if (!fragment.matchesFilters.isEmpty())
2650         generateElementMatchesMatchesPseudoClass(matchingPostTagNameFailureCases, fragment);
2651     if (!fragment.languageArgumentsList.isEmpty())
2652         generateElementIsInLanguage(matchingPostTagNameFailureCases, fragment);
2653     if (!fragment.nthChildOfFilters.isEmpty())
2654         generateElementIsNthChildOf(matchingPostTagNameFailureCases, fragment);
2655     if (!fragment.nthLastChildOfFilters.isEmpty())
2656         generateElementIsNthLastChildOf(matchingPostTagNameFailureCases, fragment);
2657     if (fragment.pseudoElementSelector)
2658         generateElementHasPseudoElement(matchingPostTagNameFailureCases, fragment);
2659 
2660     // Reach here when the generateElementMatching matching succeeded.
2661     // Only when the matching succeeeded, the last visited element should be stored and checked at the end of the whole matching.
2662     if (fragment.pseudoClasses.contains(CSSSelector::PseudoClassVisited))
2663         generateStoreLastVisitedElement(elementAddressRegister);
2664 }
2665 
2666 void SelectorCodeGenerator::generateElementDataMatching(Assembler::JumpList&amp; failureCases, const SelectorFragment&amp; fragment)
2667 {
2668     if (!fragment.id &amp;&amp; fragment.classNames.isEmpty() &amp;&amp; fragment.attributes.isEmpty())
2669         return;
2670 
2671     //  Generate:
2672     //     elementDataAddress = element-&gt;elementData();
2673     //     if (!elementDataAddress)
2674     //         failure!
2675     LocalRegister elementDataAddress(m_registerAllocator);
2676     m_assembler.loadPtr(Assembler::Address(elementAddressRegister, Element::elementDataMemoryOffset()), elementDataAddress);
2677     failureCases.append(m_assembler.branchTestPtr(Assembler::Zero, elementDataAddress));
2678 
2679     if (fragment.id)
2680         generateElementHasId(failureCases, elementDataAddress, *fragment.id);
2681     if (!fragment.classNames.isEmpty())
2682         generateElementHasClasses(failureCases, elementDataAddress, fragment.classNames);
2683     if (!fragment.attributes.isEmpty())
2684         generateElementAttributesMatching(failureCases, elementDataAddress, fragment);
2685 }
2686 
2687 void SelectorCodeGenerator::generateElementLinkMatching(Assembler::JumpList&amp; failureCases, const SelectorFragment&amp; fragment)
2688 {
2689     if (fragment.pseudoClasses.contains(CSSSelector::PseudoClassLink)
2690         || fragment.pseudoClasses.contains(CSSSelector::PseudoClassAnyLink)
2691         || fragment.pseudoClasses.contains(CSSSelector::PseudoClassVisited))
2692         generateElementIsLink(failureCases);
2693 }
2694 
2695 static inline bool canMatchStyleAttribute(const SelectorFragment&amp; fragment)
2696 {
2697     for (unsigned i = 0; i &lt; fragment.attributes.size(); ++i) {
2698         const CSSSelector&amp; attributeSelector = fragment.attributes[i].selector();
2699         const QualifiedName&amp; attributeName = attributeSelector.attribute();
2700         if (Attribute::nameMatchesFilter(HTMLNames::styleAttr, attributeName.prefix(), attributeName.localName(), attributeName.namespaceURI()))
2701             return true;
2702 
<a name="11" id="anc11"></a><span class="line-modified">2703         const AtomString&amp; canonicalLocalName = attributeSelector.attributeCanonicalLocalName();</span>
2704         if (attributeName.localName() != canonicalLocalName
2705             &amp;&amp; Attribute::nameMatchesFilter(HTMLNames::styleAttr, attributeName.prefix(), attributeSelector.attributeCanonicalLocalName(), attributeName.namespaceURI())) {
2706             return true;
2707         }
2708     }
2709     return false;
2710 }
2711 
2712 void SelectorCodeGenerator::generateSynchronizeStyleAttribute(Assembler::RegisterID elementDataArraySizeAndFlags)
2713 {
2714     // The style attribute is updated lazily based on the flag styleAttributeIsDirty.
2715     Assembler::Jump styleAttributeNotDirty = m_assembler.branchTest32(Assembler::Zero, elementDataArraySizeAndFlags, Assembler::TrustedImm32(ElementData::styleAttributeIsDirtyFlag()));
2716 
2717     FunctionCall functionCall(m_assembler, m_registerAllocator, m_stackAllocator, m_functionCalls);
2718     functionCall.setFunctionAddress(StyledElement::synchronizeStyleAttributeInternal);
2719     Assembler::RegisterID elementAddress = elementAddressRegister;
2720     functionCall.setOneArgument(elementAddress);
2721     functionCall.call();
2722 
2723     styleAttributeNotDirty.link(&amp;m_assembler);
2724 }
2725 
2726 static inline bool canMatchAnimatableSVGAttribute(const SelectorFragment&amp; fragment)
2727 {
2728     for (unsigned i = 0; i &lt; fragment.attributes.size(); ++i) {
2729         const CSSSelector&amp; attributeSelector = fragment.attributes[i].selector();
2730         const QualifiedName&amp; selectorAttributeName = attributeSelector.attribute();
2731 
2732         const QualifiedName&amp; candidateForLocalName = SVGElement::animatableAttributeForName(selectorAttributeName.localName());
2733         if (Attribute::nameMatchesFilter(candidateForLocalName, selectorAttributeName.prefix(), selectorAttributeName.localName(), selectorAttributeName.namespaceURI()))
2734             return true;
2735 
<a name="12" id="anc12"></a><span class="line-modified">2736         const AtomString&amp; canonicalLocalName = attributeSelector.attributeCanonicalLocalName();</span>
2737         if (selectorAttributeName.localName() != canonicalLocalName) {
2738             const QualifiedName&amp; candidateForCanonicalLocalName = SVGElement::animatableAttributeForName(selectorAttributeName.localName());
2739             if (Attribute::nameMatchesFilter(candidateForCanonicalLocalName, selectorAttributeName.prefix(), selectorAttributeName.localName(), selectorAttributeName.namespaceURI()))
2740                 return true;
2741         }
2742     }
2743     return false;
2744 }
2745 
2746 void SelectorCodeGenerator::generateSynchronizeAllAnimatedSVGAttribute(Assembler::RegisterID elementDataArraySizeAndFlags)
2747 {
2748     // SVG attributes can be updated lazily depending on the flag AnimatedSVGAttributesAreDirty. We need to check
2749     // that first.
2750     Assembler::Jump animatedSVGAttributesNotDirty = m_assembler.branchTest32(Assembler::Zero, elementDataArraySizeAndFlags, Assembler::TrustedImm32(ElementData::animatedSVGAttributesAreDirtyFlag()));
2751 
2752     FunctionCall functionCall(m_assembler, m_registerAllocator, m_stackAllocator, m_functionCalls);
2753     functionCall.setFunctionAddress(SVGElement::synchronizeAllAnimatedSVGAttribute);
2754     Assembler::RegisterID elementAddress = elementAddressRegister;
2755     functionCall.setOneArgument(elementAddress);
2756     functionCall.call();
2757 
2758     animatedSVGAttributesNotDirty.link(&amp;m_assembler);
2759 }
2760 
2761 void SelectorCodeGenerator::generateElementAttributesMatching(Assembler::JumpList&amp; failureCases, const LocalRegister&amp; elementDataAddress, const SelectorFragment&amp; fragment)
2762 {
2763     LocalRegister scratchRegister(m_registerAllocator);
2764     Assembler::RegisterID elementDataArraySizeAndFlags = scratchRegister;
2765     Assembler::RegisterID attributeArrayLength = scratchRegister;
2766 
2767     m_assembler.load32(Assembler::Address(elementDataAddress, ElementData::arraySizeAndFlagsMemoryOffset()), elementDataArraySizeAndFlags);
2768 
2769     if (canMatchStyleAttribute(fragment))
2770         generateSynchronizeStyleAttribute(elementDataArraySizeAndFlags);
2771 
2772     if (canMatchAnimatableSVGAttribute(fragment))
2773         generateSynchronizeAllAnimatedSVGAttribute(elementDataArraySizeAndFlags);
2774 
2775     // Attributes can be stored either in a separate vector for UniqueElementData, or after the elementData itself
2776     // for ShareableElementData.
2777     LocalRegister attributeArrayPointer(m_registerAllocator);
2778     Assembler::Jump isShareableElementData  = m_assembler.branchTest32(Assembler::Zero, elementDataArraySizeAndFlags, Assembler::TrustedImm32(ElementData::isUniqueFlag()));
2779     {
2780         ptrdiff_t attributeVectorOffset = UniqueElementData::attributeVectorMemoryOffset();
2781         m_assembler.loadPtr(Assembler::Address(elementDataAddress, attributeVectorOffset + UniqueElementData::AttributeVector::dataMemoryOffset()), attributeArrayPointer);
2782         m_assembler.load32(Assembler::Address(elementDataAddress, attributeVectorOffset + UniqueElementData::AttributeVector::sizeMemoryOffset()), attributeArrayLength);
2783     }
2784     Assembler::Jump skipShareable = m_assembler.jump();
2785 
2786     {
2787         isShareableElementData.link(&amp;m_assembler);
2788         m_assembler.urshift32(elementDataArraySizeAndFlags, Assembler::TrustedImm32(ElementData::arraySizeOffset()), attributeArrayLength);
2789         m_assembler.addPtr(Assembler::TrustedImm32(ShareableElementData::attributeArrayMemoryOffset()), elementDataAddress, attributeArrayPointer);
2790     }
2791 
2792     skipShareable.link(&amp;m_assembler);
2793 
2794     // If there are no attributes, fail immediately.
2795     failureCases.append(m_assembler.branchTest32(Assembler::Zero, attributeArrayLength));
2796 
2797     unsigned attributeCount = fragment.attributes.size();
2798     for (unsigned i = 0; i &lt; attributeCount; ++i) {
2799         Assembler::RegisterID decIndexRegister;
2800         Assembler::RegisterID currentAttributeAddress;
2801 
2802         bool isLastAttribute = i == (attributeCount - 1);
2803         if (!isLastAttribute) {
2804             // We need to make a copy to let the next iterations use the values.
2805             currentAttributeAddress = m_registerAllocator.allocateRegister();
2806             decIndexRegister = m_registerAllocator.allocateRegister();
2807             m_assembler.move(attributeArrayPointer, currentAttributeAddress);
2808             m_assembler.move(attributeArrayLength, decIndexRegister);
2809         } else {
2810             currentAttributeAddress = attributeArrayPointer;
2811             decIndexRegister = attributeArrayLength;
2812         }
2813 
2814         generateElementAttributeMatching(failureCases, currentAttributeAddress, decIndexRegister, fragment.attributes[i]);
2815 
2816         if (!isLastAttribute) {
2817             m_registerAllocator.deallocateRegister(decIndexRegister);
2818             m_registerAllocator.deallocateRegister(currentAttributeAddress);
2819         }
2820     }
2821 }
2822 
2823 void SelectorCodeGenerator::generateElementAttributeMatching(Assembler::JumpList&amp; failureCases, Assembler::RegisterID currentAttributeAddress, Assembler::RegisterID decIndexRegister, const AttributeMatchingInfo&amp; attributeInfo)
2824 {
2825     // Get the localName used for comparison. HTML elements use a lowercase local name known in selectors as canonicalLocalName.
2826     LocalRegister localNameToMatch(m_registerAllocator);
2827 
2828     // In general, canonicalLocalName and localName are the same. When they differ, we have to check if the node is HTML to know
2829     // which one to use.
2830     const CSSSelector&amp; attributeSelector = attributeInfo.selector();
<a name="13" id="anc13"></a><span class="line-modified">2831     const AtomStringImpl* canonicalLocalName = attributeSelector.attributeCanonicalLocalName().impl();</span>
<span class="line-modified">2832     const AtomStringImpl* localName = attributeSelector.attribute().localName().impl();</span>
2833     if (canonicalLocalName == localName)
2834         m_assembler.move(Assembler::TrustedImmPtr(canonicalLocalName), localNameToMatch);
2835     else {
2836         m_assembler.move(Assembler::TrustedImmPtr(canonicalLocalName), localNameToMatch);
2837         Assembler::Jump elementIsHTML = DOMJIT::branchTestIsHTMLFlagOnNode(m_assembler, Assembler::NonZero, elementAddressRegister);
2838         m_assembler.move(Assembler::TrustedImmPtr(localName), localNameToMatch);
2839         elementIsHTML.link(&amp;m_assembler);
2840     }
2841 
2842     Assembler::JumpList successCases;
2843     Assembler::Label loopStart(m_assembler.label());
2844 
2845     {
2846         LocalRegister qualifiedNameImpl(m_registerAllocator);
2847         m_assembler.loadPtr(Assembler::Address(currentAttributeAddress, Attribute::nameMemoryOffset()), qualifiedNameImpl);
2848 
2849         bool shouldCheckNamespace = attributeSelector.attribute().prefix() != starAtom();
2850         if (shouldCheckNamespace) {
2851             Assembler::Jump nameDoesNotMatch = m_assembler.branchPtr(Assembler::NotEqual, Assembler::Address(qualifiedNameImpl, QualifiedName::QualifiedNameImpl::localNameMemoryOffset()), localNameToMatch);
2852 
<a name="14" id="anc14"></a><span class="line-modified">2853             const AtomStringImpl* namespaceURI = attributeSelector.attribute().namespaceURI().impl();</span>
2854             if (namespaceURI) {
2855                 LocalRegister namespaceToMatch(m_registerAllocator);
2856                 m_assembler.move(Assembler::TrustedImmPtr(namespaceURI), namespaceToMatch);
2857                 successCases.append(m_assembler.branchPtr(Assembler::Equal, Assembler::Address(qualifiedNameImpl, QualifiedName::QualifiedNameImpl::namespaceMemoryOffset()), namespaceToMatch));
2858             } else
2859                 successCases.append(m_assembler.branchTestPtr(Assembler::Zero, Assembler::Address(qualifiedNameImpl, QualifiedName::QualifiedNameImpl::namespaceMemoryOffset())));
2860             nameDoesNotMatch.link(&amp;m_assembler);
2861         } else
2862             successCases.append(m_assembler.branchPtr(Assembler::Equal, Assembler::Address(qualifiedNameImpl, QualifiedName::QualifiedNameImpl::localNameMemoryOffset()), localNameToMatch));
2863     }
2864 
2865     Assembler::Label loopReEntry(m_assembler.label());
2866 
2867     // If we reached the last element -&gt; failure.
2868     failureCases.append(m_assembler.branchSub32(Assembler::Zero, Assembler::TrustedImm32(1), decIndexRegister));
2869 
2870     // Otherwise just loop over.
2871     m_assembler.addPtr(Assembler::TrustedImm32(sizeof(Attribute)), currentAttributeAddress);
2872     m_assembler.jump().linkTo(loopStart, &amp;m_assembler);
2873 
2874     successCases.link(&amp;m_assembler);
2875 
2876     if (attributeSelector.match() != CSSSelector::Set) {
2877         // We make the assumption that name matching fails in most cases and we keep value matching outside
2878         // of the loop. We re-enter the loop if needed.
2879         // FIXME: exact case sensitive value matching is so simple that it should be done in the loop.
2880         Assembler::JumpList localFailureCases;
2881         generateElementAttributeValueMatching(localFailureCases, currentAttributeAddress, attributeInfo);
2882         localFailureCases.linkTo(loopReEntry, &amp;m_assembler);
2883     }
2884 }
2885 
2886 enum CaseSensitivity {
2887     CaseSensitive,
2888     CaseInsensitive
2889 };
2890 
2891 template&lt;CaseSensitivity caseSensitivity&gt;
<a name="15" id="anc15"></a><span class="line-modified">2892 static bool attributeValueBeginsWith(const Attribute* attribute, AtomStringImpl* expectedString)</span>
2893 {
2894     ASSERT(expectedString);
2895 
<a name="16" id="anc16"></a><span class="line-modified">2896     AtomStringImpl&amp; valueImpl = *attribute-&gt;value().impl();</span>
2897     if (caseSensitivity == CaseSensitive)
2898         return valueImpl.startsWith(*expectedString);
2899     return valueImpl.startsWithIgnoringASCIICase(*expectedString);
2900 }
2901 
2902 template&lt;CaseSensitivity caseSensitivity&gt;
<a name="17" id="anc17"></a><span class="line-modified">2903 static bool attributeValueContains(const Attribute* attribute, AtomStringImpl* expectedString)</span>
2904 {
<a name="18" id="anc18"></a><span class="line-modified">2905     AtomStringImpl&amp; valueImpl = *attribute-&gt;value().impl();</span>
2906     if (caseSensitivity == CaseSensitive)
2907         return valueImpl.find(expectedString) != notFound;
2908     return valueImpl.findIgnoringASCIICase(expectedString) != notFound;
2909 }
2910 
2911 template&lt;CaseSensitivity caseSensitivity&gt;
<a name="19" id="anc19"></a><span class="line-modified">2912 static bool attributeValueEndsWith(const Attribute* attribute, AtomStringImpl* expectedString)</span>
2913 {
2914     ASSERT(expectedString);
2915 
<a name="20" id="anc20"></a><span class="line-modified">2916     AtomStringImpl&amp; valueImpl = *attribute-&gt;value().impl();</span>
2917     if (caseSensitivity == CaseSensitive)
2918         return valueImpl.endsWith(*expectedString);
2919     return valueImpl.endsWithIgnoringASCIICase(*expectedString);
2920 }
2921 
2922 template&lt;CaseSensitivity caseSensitivity&gt;
<a name="21" id="anc21"></a><span class="line-modified">2923 static bool attributeValueMatchHyphenRule(const Attribute* attribute, AtomStringImpl* expectedString)</span>
2924 {
2925     ASSERT(expectedString);
2926 
<a name="22" id="anc22"></a><span class="line-modified">2927     AtomStringImpl&amp; valueImpl = *attribute-&gt;value().impl();</span>
2928     if (valueImpl.length() &lt; expectedString-&gt;length())
2929         return false;
2930 
2931     bool valueStartsWithExpectedString;
2932     if (caseSensitivity == CaseSensitive)
2933         valueStartsWithExpectedString = valueImpl.startsWith(*expectedString);
2934     else
2935         valueStartsWithExpectedString = valueImpl.startsWithIgnoringASCIICase(*expectedString);
2936 
2937     if (!valueStartsWithExpectedString)
2938         return false;
2939 
2940     return valueImpl.length() == expectedString-&gt;length() || valueImpl[expectedString-&gt;length()] == &#39;-&#39;;
2941 }
2942 
2943 template&lt;CaseSensitivity caseSensitivity&gt;
<a name="23" id="anc23"></a><span class="line-modified">2944 static bool attributeValueSpaceSeparetedListContains(const Attribute* attribute, AtomStringImpl* expectedString)</span>
2945 {
<a name="24" id="anc24"></a><span class="line-modified">2946     AtomStringImpl&amp; value = *attribute-&gt;value().impl();</span>
2947 
2948     unsigned startSearchAt = 0;
2949     while (true) {
2950         size_t foundPos;
2951         if (caseSensitivity == CaseSensitive)
2952             foundPos = value.find(expectedString, startSearchAt);
2953         else
2954             foundPos = value.findIgnoringASCIICase(expectedString, startSearchAt);
2955         if (foundPos == notFound)
2956             return false;
2957         if (!foundPos || isHTMLSpace(value[foundPos - 1])) {
2958             unsigned endStr = foundPos + expectedString-&gt;length();
2959             if (endStr == value.length() || isHTMLSpace(value[endStr]))
2960                 return true;
2961         }
2962         startSearchAt = foundPos + 1;
2963     }
2964     return false;
2965 }
2966 
2967 void SelectorCodeGenerator::generateElementAttributeValueMatching(Assembler::JumpList&amp; failureCases, Assembler::RegisterID currentAttributeAddress, const AttributeMatchingInfo&amp; attributeInfo)
2968 {
2969     const CSSSelector&amp; attributeSelector = attributeInfo.selector();
<a name="25" id="anc25"></a><span class="line-modified">2970     const AtomString&amp; expectedValue = attributeSelector.value();</span>
2971     ASSERT(!expectedValue.isNull());
2972     AttributeCaseSensitivity valueCaseSensitivity = attributeInfo.attributeCaseSensitivity();
2973 
2974     switch (attributeSelector.match()) {
2975     case CSSSelector::Begin:
2976         generateElementAttributeFunctionCallValueMatching(failureCases, currentAttributeAddress, expectedValue, valueCaseSensitivity, attributeValueBeginsWith&lt;CaseSensitive&gt;, attributeValueBeginsWith&lt;CaseInsensitive&gt;);
2977         break;
2978     case CSSSelector::Contain:
2979         generateElementAttributeFunctionCallValueMatching(failureCases, currentAttributeAddress, expectedValue, valueCaseSensitivity, attributeValueContains&lt;CaseSensitive&gt;, attributeValueContains&lt;CaseInsensitive&gt;);
2980         break;
2981     case CSSSelector::End:
2982         generateElementAttributeFunctionCallValueMatching(failureCases, currentAttributeAddress, expectedValue, valueCaseSensitivity, attributeValueEndsWith&lt;CaseSensitive&gt;, attributeValueEndsWith&lt;CaseInsensitive&gt;);
2983         break;
2984     case CSSSelector::Exact:
2985         generateElementAttributeValueExactMatching(failureCases, currentAttributeAddress, expectedValue, valueCaseSensitivity);
2986         break;
2987     case CSSSelector::Hyphen:
2988         generateElementAttributeFunctionCallValueMatching(failureCases, currentAttributeAddress, expectedValue, valueCaseSensitivity, attributeValueMatchHyphenRule&lt;CaseSensitive&gt;, attributeValueMatchHyphenRule&lt;CaseInsensitive&gt;);
2989         break;
2990     case CSSSelector::List:
2991         generateElementAttributeFunctionCallValueMatching(failureCases, currentAttributeAddress, expectedValue, valueCaseSensitivity, attributeValueSpaceSeparetedListContains&lt;CaseSensitive&gt;, attributeValueSpaceSeparetedListContains&lt;CaseInsensitive&gt;);
2992         break;
2993     default:
2994         ASSERT_NOT_REACHED();
2995     }
2996 }
2997 
2998 static inline Assembler::Jump testIsHTMLClassOnDocument(Assembler::ResultCondition condition, Assembler&amp; assembler, Assembler::RegisterID documentAddress)
2999 {
3000     return assembler.branchTest32(condition, Assembler::Address(documentAddress, Document::documentClassesMemoryOffset()), Assembler::TrustedImm32(Document::isHTMLDocumentClassFlag()));
3001 }
3002 
<a name="26" id="anc26"></a><span class="line-modified">3003 void SelectorCodeGenerator::generateElementAttributeValueExactMatching(Assembler::JumpList&amp; failureCases, Assembler::RegisterID currentAttributeAddress, const AtomString&amp; expectedValue, AttributeCaseSensitivity valueCaseSensitivity)</span>
3004 {
3005     LocalRegisterWithPreference expectedValueRegister(m_registerAllocator, JSC::GPRInfo::argumentGPR1);
3006     m_assembler.move(Assembler::TrustedImmPtr(expectedValue.impl()), expectedValueRegister);
3007 
3008     switch (valueCaseSensitivity) {
3009     case AttributeCaseSensitivity::CaseSensitive: {
3010         failureCases.append(m_assembler.branchPtr(Assembler::NotEqual, Assembler::Address(currentAttributeAddress, Attribute::valueMemoryOffset()), expectedValueRegister));
3011         break;
3012     }
3013     case AttributeCaseSensitivity::HTMLLegacyCaseInsensitive: {
3014         Assembler::Jump skipCaseInsensitiveComparison = m_assembler.branchPtr(Assembler::Equal, Assembler::Address(currentAttributeAddress, Attribute::valueMemoryOffset()), expectedValueRegister);
3015 
3016         // If the element is an HTML element, in a HTML dcoument (not including XHTML), value matching is case insensitive.
3017         // Taking the contrapositive, if we find the element is not HTML or is not in a HTML document, the condition above
3018         // sould be sufficient and we can fail early.
3019         failureCases.append(DOMJIT::branchTestIsHTMLFlagOnNode(m_assembler, Assembler::Zero, elementAddressRegister));
3020 
3021         {
3022             LocalRegister document(m_registerAllocator);
3023             DOMJIT::loadDocument(m_assembler, elementAddressRegister, document);
3024             failureCases.append(testIsHTMLClassOnDocument(Assembler::Zero, m_assembler, document));
3025         }
3026 
3027         LocalRegister valueStringImpl(m_registerAllocator);
3028         m_assembler.loadPtr(Assembler::Address(currentAttributeAddress, Attribute::valueMemoryOffset()), valueStringImpl);
3029 
3030         FunctionCall functionCall(m_assembler, m_registerAllocator, m_stackAllocator, m_functionCalls);
3031         functionCall.setFunctionAddress(WTF::equalIgnoringASCIICaseNonNull);
3032         functionCall.setTwoArguments(valueStringImpl, expectedValueRegister);
3033         failureCases.append(functionCall.callAndBranchOnBooleanReturnValue(Assembler::Zero));
3034 
3035         skipCaseInsensitiveComparison.link(&amp;m_assembler);
3036         break;
3037     }
3038     case AttributeCaseSensitivity::CaseInsensitive: {
3039         LocalRegister valueStringImpl(m_registerAllocator);
3040         m_assembler.loadPtr(Assembler::Address(currentAttributeAddress, Attribute::valueMemoryOffset()), valueStringImpl);
3041 
3042         Assembler::Jump skipCaseInsensitiveComparison = m_assembler.branchPtr(Assembler::Equal, valueStringImpl, expectedValueRegister);
3043         FunctionCall functionCall(m_assembler, m_registerAllocator, m_stackAllocator, m_functionCalls);
3044         functionCall.setFunctionAddress(WTF::equalIgnoringASCIICaseNonNull);
3045         functionCall.setTwoArguments(valueStringImpl, expectedValueRegister);
3046         failureCases.append(functionCall.callAndBranchOnBooleanReturnValue(Assembler::Zero));
3047         skipCaseInsensitiveComparison.link(&amp;m_assembler);
3048         break;
3049     }
3050     }
3051 }
3052 
<a name="27" id="anc27"></a><span class="line-modified">3053 void SelectorCodeGenerator::generateElementAttributeFunctionCallValueMatching(Assembler::JumpList&amp; failureCases, Assembler::RegisterID currentAttributeAddress, const AtomString&amp; expectedValue, AttributeCaseSensitivity valueCaseSensitivity, JSC::FunctionPtr&lt;CSSOperationPtrTag&gt; caseSensitiveTest, JSC::FunctionPtr&lt;CSSOperationPtrTag&gt; caseInsensitiveTest)</span>
3054 {
3055     LocalRegisterWithPreference expectedValueRegister(m_registerAllocator, JSC::GPRInfo::argumentGPR1);
3056     m_assembler.move(Assembler::TrustedImmPtr(expectedValue.impl()), expectedValueRegister);
3057 
3058 
3059     switch (valueCaseSensitivity) {
3060     case AttributeCaseSensitivity::CaseSensitive: {
3061         FunctionCall functionCall(m_assembler, m_registerAllocator, m_stackAllocator, m_functionCalls);
3062         functionCall.setFunctionAddress(caseSensitiveTest);
3063         functionCall.setTwoArguments(currentAttributeAddress, expectedValueRegister);
3064         failureCases.append(functionCall.callAndBranchOnBooleanReturnValue(Assembler::Zero));
3065         break;
3066     }
3067     case AttributeCaseSensitivity::HTMLLegacyCaseInsensitive: {
3068         Assembler::JumpList shouldUseCaseSensitiveComparison;
3069         shouldUseCaseSensitiveComparison.append(DOMJIT::branchTestIsHTMLFlagOnNode(m_assembler, Assembler::Zero, elementAddressRegister));
3070         {
3071             LocalRegister scratchRegister(m_registerAllocator);
3072             // scratchRegister = pointer to treeScope.
3073             m_assembler.loadPtr(Assembler::Address(elementAddressRegister, Node::treeScopeMemoryOffset()), scratchRegister);
3074             // scratchRegister = pointer to document.
3075             m_assembler.loadPtr(Assembler::Address(scratchRegister, TreeScope::documentScopeMemoryOffset()), scratchRegister);
3076             shouldUseCaseSensitiveComparison.append(testIsHTMLClassOnDocument(Assembler::Zero, m_assembler, scratchRegister));
3077         }
3078 
3079         {
3080             FunctionCall functionCall(m_assembler, m_registerAllocator, m_stackAllocator, m_functionCalls);
3081             functionCall.setFunctionAddress(caseInsensitiveTest);
3082             functionCall.setTwoArguments(currentAttributeAddress, expectedValueRegister);
3083             failureCases.append(functionCall.callAndBranchOnBooleanReturnValue(Assembler::Zero));
3084         }
3085 
3086         Assembler::Jump skipCaseSensitiveCase = m_assembler.jump();
3087 
3088         {
3089             shouldUseCaseSensitiveComparison.link(&amp;m_assembler);
3090             FunctionCall functionCall(m_assembler, m_registerAllocator, m_stackAllocator, m_functionCalls);
3091             functionCall.setFunctionAddress(caseSensitiveTest);
3092             functionCall.setTwoArguments(currentAttributeAddress, expectedValueRegister);
3093             failureCases.append(functionCall.callAndBranchOnBooleanReturnValue(Assembler::Zero));
3094         }
3095 
3096         skipCaseSensitiveCase.link(&amp;m_assembler);
3097         break;
3098     }
3099     case AttributeCaseSensitivity::CaseInsensitive: {
3100         FunctionCall functionCall(m_assembler, m_registerAllocator, m_stackAllocator, m_functionCalls);
3101         functionCall.setFunctionAddress(caseInsensitiveTest);
3102         functionCall.setTwoArguments(currentAttributeAddress, expectedValueRegister);
3103         failureCases.append(functionCall.callAndBranchOnBooleanReturnValue(Assembler::Zero));
3104         break;
3105     }
3106     }
3107 }
3108 
3109 void SelectorCodeGenerator::generateElementFunctionCallTest(Assembler::JumpList&amp; failureCases, JSC::FunctionPtr&lt;CSSOperationPtrTag&gt; testFunction)
3110 {
3111     Assembler::RegisterID elementAddress = elementAddressRegister;
3112     FunctionCall functionCall(m_assembler, m_registerAllocator, m_stackAllocator, m_functionCalls);
3113     functionCall.setFunctionAddress(testFunction);
3114     functionCall.setOneArgument(elementAddress);
3115     failureCases.append(functionCall.callAndBranchOnBooleanReturnValue(Assembler::Zero));
3116 }
3117 
3118 void SelectorCodeGenerator::generateContextFunctionCallTest(Assembler::JumpList&amp; failureCases, JSC::FunctionPtr&lt;CSSOperationPtrTag&gt; testFunction)
3119 {
3120     Assembler::RegisterID checkingContext = m_registerAllocator.allocateRegister();
3121     loadCheckingContext(checkingContext);
3122     m_registerAllocator.deallocateRegister(checkingContext);
3123 
3124     FunctionCall functionCall(m_assembler, m_registerAllocator, m_stackAllocator, m_functionCalls);
3125     functionCall.setFunctionAddress(testFunction);
3126     functionCall.setOneArgument(checkingContext);
3127     failureCases.append(functionCall.callAndBranchOnBooleanReturnValue(Assembler::Zero));
3128 }
3129 
3130 static bool elementIsActive(const Element* element)
3131 {
3132     return element-&gt;active() || InspectorInstrumentation::forcePseudoState(*element, CSSSelector::PseudoClassActive);
3133 }
3134 
3135 void SelectorCodeGenerator::generateElementIsActive(Assembler::JumpList&amp; failureCases, const SelectorFragment&amp; fragment)
3136 {
3137     generateSpecialFailureInQuirksModeForActiveAndHoverIfNeeded(failureCases, fragment);
3138 
3139     generateAddStyleRelationIfResolvingStyle(elementAddressRegister, Style::Relation::AffectedByActive);
3140 
3141     FunctionCall functionCall(m_assembler, m_registerAllocator, m_stackAllocator, m_functionCalls);
3142     functionCall.setFunctionAddress(elementIsActive);
3143     functionCall.setOneArgument(elementAddressRegister);
3144     failureCases.append(functionCall.callAndBranchOnBooleanReturnValue(Assembler::Zero));
3145 }
3146 
3147 static void jumpIfElementIsNotEmpty(Assembler&amp; assembler, RegisterAllocator&amp; registerAllocator, Assembler::JumpList&amp; notEmptyCases, Assembler::RegisterID element)
3148 {
3149     LocalRegister currentChild(registerAllocator);
3150     assembler.loadPtr(Assembler::Address(element, ContainerNode::firstChildMemoryOffset()), currentChild);
3151 
3152     Assembler::Label loopStart(assembler.label());
3153     Assembler::Jump noMoreChildren = assembler.branchTestPtr(Assembler::Zero, currentChild);
3154 
3155     notEmptyCases.append(DOMJIT::branchTestIsElementFlagOnNode(assembler, Assembler::NonZero, currentChild));
3156 
3157     {
3158         Assembler::Jump skipTextNodeCheck = assembler.branchTest32(Assembler::Zero, Assembler::Address(currentChild, Node::nodeFlagsMemoryOffset()), Assembler::TrustedImm32(Node::flagIsText()));
3159 
3160         LocalRegister textStringImpl(registerAllocator);
3161         assembler.loadPtr(Assembler::Address(currentChild, CharacterData::dataMemoryOffset()), textStringImpl);
3162         notEmptyCases.append(assembler.branchTest32(Assembler::NonZero, Assembler::Address(textStringImpl, StringImpl::lengthMemoryOffset())));
3163 
3164         skipTextNodeCheck.link(&amp;assembler);
3165     }
3166 
3167     assembler.loadPtr(Assembler::Address(currentChild, Node::nextSiblingMemoryOffset()), currentChild);
3168     assembler.jump().linkTo(loopStart, &amp;assembler);
3169 
3170     noMoreChildren.link(&amp;assembler);
3171 }
3172 
3173 void SelectorCodeGenerator::generateElementIsEmpty(Assembler::JumpList&amp; failureCases)
3174 {
3175     if (m_selectorContext == SelectorContext::QuerySelector) {
3176         jumpIfElementIsNotEmpty(m_assembler, m_registerAllocator, failureCases, elementAddressRegister);
3177         return;
3178     }
3179 
3180     LocalRegisterWithPreference isEmptyResults(m_registerAllocator, JSC::GPRInfo::argumentGPR1);
3181     m_assembler.move(Assembler::TrustedImm32(0), isEmptyResults);
3182 
3183     Assembler::JumpList notEmpty;
3184     jumpIfElementIsNotEmpty(m_assembler, m_registerAllocator, notEmpty, elementAddressRegister);
3185     m_assembler.move(Assembler::TrustedImm32(1), isEmptyResults);
3186     notEmpty.link(&amp;m_assembler);
3187 
3188     generateAddStyleRelationIfResolvingStyle(elementAddressRegister, Style::Relation::AffectedByEmpty, Assembler::RegisterID(isEmptyResults));
3189 
3190     failureCases.append(m_assembler.branchTest32(Assembler::Zero, isEmptyResults));
3191 }
3192 
3193 void SelectorCodeGenerator::generateElementIsFirstChild(Assembler::JumpList&amp; failureCases)
3194 {
3195     if (m_selectorContext == SelectorContext::QuerySelector) {
3196         Assembler::JumpList successCase = jumpIfNoPreviousAdjacentElement();
3197         failureCases.append(m_assembler.jump());
3198         successCase.link(&amp;m_assembler);
3199         LocalRegister parent(m_registerAllocator);
3200         generateWalkToParentElementOrShadowRoot(failureCases, parent);
3201         return;
3202     }
3203 
3204     // Zero in isFirstChildRegister is the success case. The register is set to non-zero if a sibling if found.
3205     LocalRegister isFirstChildRegister(m_registerAllocator);
3206     m_assembler.move(Assembler::TrustedImm32(0), isFirstChildRegister);
3207 
3208     {
3209         Assembler::JumpList successCase = jumpIfNoPreviousAdjacentElement();
3210 
3211         // If there was a sibling element, the element was not the first child -&gt; failure case.
3212         m_assembler.move(Assembler::TrustedImm32(1), isFirstChildRegister);
3213 
3214         successCase.link(&amp;m_assembler);
3215     }
3216 
3217     LocalRegister parentNode(m_registerAllocator);
3218     generateWalkToParentNode(parentNode);
3219     failureCases.append(m_assembler.branchTestPtr(Assembler::Zero, parentNode));
3220     Assembler::Jump notElement = DOMJIT::branchTestIsElementFlagOnNode(m_assembler, Assembler::Zero, parentNode);
3221 
3222     LocalRegister checkingContext(m_registerAllocator);
3223     Assembler::Jump notResolvingStyle = jumpIfNotResolvingStyle(checkingContext);
3224 
3225     generateAddStyleRelation(checkingContext, parentNode, Style::Relation::ChildrenAffectedByFirstChildRules);
3226     // The parent marking is unconditional. If the matching is not a success, we can now fail.
3227     // Otherwise we need to apply setFirstChildState() on the RenderStyle.
3228     Assembler::Label checkWithRelation(m_assembler.label());
3229     failureCases.append(m_assembler.branchTest32(Assembler::NonZero, isFirstChildRegister));
3230     generateAddStyleRelation(checkingContext, elementAddressRegister, Style::Relation::FirstChild);
3231     Assembler::Jump successCase = m_assembler.jump();
3232 
3233     notElement.link(&amp;m_assembler);
3234     failureCases.append(DOMJIT::branchTestIsShadowRootFlagOnNode(m_assembler, Assembler::Zero, parentNode));
3235     jumpIfNotResolvingStyle(checkingContext).linkTo(checkWithRelation, &amp;m_assembler);
3236 
3237     notResolvingStyle.link(&amp;m_assembler);
3238     failureCases.append(m_assembler.branchTest32(Assembler::NonZero, isFirstChildRegister));
3239 
3240     successCase.link(&amp;m_assembler);
3241 }
3242 
3243 static bool elementIsHovered(const Element* element)
3244 {
3245     return element-&gt;hovered() || InspectorInstrumentation::forcePseudoState(*element, CSSSelector::PseudoClassHover);
3246 }
3247 
3248 void SelectorCodeGenerator::generateElementIsHovered(Assembler::JumpList&amp; failureCases, const SelectorFragment&amp; fragment)
3249 {
3250     generateSpecialFailureInQuirksModeForActiveAndHoverIfNeeded(failureCases, fragment);
3251 
3252     generateAddStyleRelationIfResolvingStyle(elementAddressRegister, Style::Relation::AffectedByHover);
3253 
3254     Assembler::JumpList successCases;
3255     if (m_selectorContext != SelectorContext::QuerySelector &amp;&amp; fragment.relationToRightFragment != FragmentRelation::Rightmost) {
3256         // :hover always matches when not in rightmost position when collecting rules for descendant style invalidation optimization.
3257         // Resolving style for a matching descendant will set parent childrenAffectedByHover bit even when the element is not currently hovered.
3258         // This bit has to be set for the event based :hover invalidation to work.
3259         // FIXME: We should just collect style relation bits and apply them as needed when computing style invalidation optimization.
3260         LocalRegister checkingContext(m_registerAllocator);
3261         successCases.append(branchOnResolvingMode(Assembler::Equal, SelectorChecker::Mode::CollectingRulesIgnoringVirtualPseudoElements, checkingContext));
3262     }
3263 
3264     FunctionCall functionCall(m_assembler, m_registerAllocator, m_stackAllocator, m_functionCalls);
3265     functionCall.setFunctionAddress(elementIsHovered);
3266     functionCall.setOneArgument(elementAddressRegister);
3267     failureCases.append(functionCall.callAndBranchOnBooleanReturnValue(Assembler::Zero));
3268 
3269     successCases.link(&amp;m_assembler);
3270 }
3271 
3272 void SelectorCodeGenerator::generateElementIsInLanguage(Assembler::JumpList&amp; failureCases, const SelectorFragment&amp; fragment)
3273 {
<a name="28" id="anc28"></a><span class="line-modified">3274     for (const Vector&lt;AtomString&gt;* languageArguments : fragment.languageArgumentsList)</span>
3275         generateElementIsInLanguage(failureCases, languageArguments);
3276 }
3277 
<a name="29" id="anc29"></a><span class="line-modified">3278 void SelectorCodeGenerator::generateElementIsInLanguage(Assembler::JumpList&amp; failureCases, const Vector&lt;AtomString&gt;* languageArguments)</span>
3279 {
3280     LocalRegisterWithPreference langRangeRegister(m_registerAllocator, JSC::GPRInfo::argumentGPR1);
3281     m_assembler.move(Assembler::TrustedImmPtr(languageArguments), langRangeRegister);
3282 
3283     Assembler::RegisterID elementAddress = elementAddressRegister;
3284     FunctionCall functionCall(m_assembler, m_registerAllocator, m_stackAllocator, m_functionCalls);
3285     functionCall.setFunctionAddress(matchesLangPseudoClass);
3286     functionCall.setTwoArguments(elementAddress, langRangeRegister);
3287     failureCases.append(functionCall.callAndBranchOnBooleanReturnValue(Assembler::Zero));
3288 }
3289 
3290 void SelectorCodeGenerator::generateElementIsLastChild(Assembler::JumpList&amp; failureCases)
3291 {
3292     if (m_selectorContext == SelectorContext::QuerySelector) {
3293         Assembler::JumpList successCase = jumpIfNoNextAdjacentElement();
3294         failureCases.append(m_assembler.jump());
3295 
3296         successCase.link(&amp;m_assembler);
3297         LocalRegister parent(m_registerAllocator);
3298         generateWalkToParentElementOrShadowRoot(failureCases, parent);
3299 
3300         failureCases.append(m_assembler.branchTest32(Assembler::Zero, Assembler::Address(parent, Node::nodeFlagsMemoryOffset()), Assembler::TrustedImm32(Node::flagIsParsingChildrenFinished())));
3301 
3302         return;
3303     }
3304 
3305     LocalRegister parentNode(m_registerAllocator);
3306     generateWalkToParentNode(parentNode);
3307     failureCases.append(m_assembler.branchTestPtr(Assembler::Zero, parentNode));
3308 
3309     // Zero in isLastChildRegister is the success case. The register is set to non-zero if a sibling if found.
3310     LocalRegister isLastChildRegister(m_registerAllocator);
3311     m_assembler.move(Assembler::TrustedImm32(0), isLastChildRegister);
3312 
3313     {
3314         Assembler::Jump notFinishedParsingChildren = m_assembler.branchTest32(Assembler::Zero, Assembler::Address(parentNode, Node::nodeFlagsMemoryOffset()), Assembler::TrustedImm32(Node::flagIsParsingChildrenFinished()));
3315 
3316         Assembler::JumpList successCase = jumpIfNoNextAdjacentElement();
3317 
3318         notFinishedParsingChildren.link(&amp;m_assembler);
3319         m_assembler.move(Assembler::TrustedImm32(1), isLastChildRegister);
3320 
3321         successCase.link(&amp;m_assembler);
3322     }
3323 
3324     Assembler::Jump notElement = DOMJIT::branchTestIsElementFlagOnNode(m_assembler, Assembler::Zero, parentNode);
3325 
3326     LocalRegister checkingContext(m_registerAllocator);
3327     Assembler::Jump notResolvingStyle = jumpIfNotResolvingStyle(checkingContext);
3328 
3329     generateAddStyleRelation(checkingContext, parentNode, Style::Relation::ChildrenAffectedByLastChildRules);
3330     // The parent marking is unconditional. If the matching is not a success, we can now fail.
3331     // Otherwise we need to apply setLastChildState() on the RenderStyle.
3332     Assembler::Label checkWithRelation(m_assembler.label());
3333     failureCases.append(m_assembler.branchTest32(Assembler::NonZero, isLastChildRegister));
3334     generateAddStyleRelation(checkingContext, elementAddressRegister, Style::Relation::LastChild);
3335     Assembler::Jump successCase = m_assembler.jump();
3336 
3337     notElement.link(&amp;m_assembler);
3338     failureCases.append(DOMJIT::branchTestIsShadowRootFlagOnNode(m_assembler, Assembler::Zero, parentNode));
3339     jumpIfNotResolvingStyle(checkingContext).linkTo(checkWithRelation, &amp;m_assembler);
3340 
3341     notResolvingStyle.link(&amp;m_assembler);
3342     failureCases.append(m_assembler.branchTest32(Assembler::NonZero, isLastChildRegister));
3343 
3344     successCase.link(&amp;m_assembler);
3345 }
3346 
3347 void SelectorCodeGenerator::generateElementIsOnlyChild(Assembler::JumpList&amp; failureCases)
3348 {
3349     // Is Only child is pretty much a combination of isFirstChild + isLastChild. The main difference is that tree marking is combined.
3350     if (m_selectorContext == SelectorContext::QuerySelector) {
3351         Assembler::JumpList previousSuccessCase = jumpIfNoPreviousAdjacentElement();
3352         failureCases.append(m_assembler.jump());
3353         previousSuccessCase.link(&amp;m_assembler);
3354 
3355         Assembler::JumpList nextSuccessCase = jumpIfNoNextAdjacentElement();
3356         failureCases.append(m_assembler.jump());
3357         nextSuccessCase.link(&amp;m_assembler);
3358 
3359         LocalRegister parent(m_registerAllocator);
3360         generateWalkToParentElementOrShadowRoot(failureCases, parent);
3361 
3362         failureCases.append(m_assembler.branchTest32(Assembler::Zero, Assembler::Address(parent, Node::nodeFlagsMemoryOffset()), Assembler::TrustedImm32(Node::flagIsParsingChildrenFinished())));
3363 
3364         return;
3365     }
3366 
3367     LocalRegister parentNode(m_registerAllocator);
3368     generateWalkToParentNode(parentNode);
3369     failureCases.append(m_assembler.branchTestPtr(Assembler::Zero, parentNode));
3370 
3371     // Zero in isOnlyChildRegister is the success case. The register is set to non-zero if a sibling if found.
3372     LocalRegister isOnlyChildRegister(m_registerAllocator);
3373     m_assembler.move(Assembler::TrustedImm32(0), isOnlyChildRegister);
3374 
3375     {
3376         Assembler::JumpList localFailureCases;
3377         {
3378             Assembler::JumpList successCase = jumpIfNoPreviousAdjacentElement();
3379             localFailureCases.append(m_assembler.jump());
3380             successCase.link(&amp;m_assembler);
3381         }
3382         localFailureCases.append(m_assembler.branchTest32(Assembler::Zero, Assembler::Address(parentNode, Node::nodeFlagsMemoryOffset()), Assembler::TrustedImm32(Node::flagIsParsingChildrenFinished())));
3383         Assembler::JumpList successCase = jumpIfNoNextAdjacentElement();
3384 
3385         localFailureCases.link(&amp;m_assembler);
3386         m_assembler.move(Assembler::TrustedImm32(1), isOnlyChildRegister);
3387 
3388         successCase.link(&amp;m_assembler);
3389     }
3390 
3391     Assembler::Jump notElement = DOMJIT::branchTestIsElementFlagOnNode(m_assembler, Assembler::Zero, parentNode);
3392 
3393     LocalRegister checkingContext(m_registerAllocator);
3394     Assembler::Jump notResolvingStyle = jumpIfNotResolvingStyle(checkingContext);
3395 
3396     generateAddStyleRelation(checkingContext, parentNode, Style::Relation::ChildrenAffectedByFirstChildRules);
3397     generateAddStyleRelation(checkingContext, parentNode, Style::Relation::ChildrenAffectedByLastChildRules);
3398     // The parent marking is unconditional. If the matching is not a success, we can now fail.
3399     // Otherwise we need to apply setLastChildState() on the RenderStyle.
3400     Assembler::Label checkWithRelation(m_assembler.label());
3401     failureCases.append(m_assembler.branchTest32(Assembler::NonZero, isOnlyChildRegister));
3402     generateAddStyleRelation(checkingContext, elementAddressRegister, Style::Relation::FirstChild);
3403     generateAddStyleRelation(checkingContext, elementAddressRegister, Style::Relation::LastChild);
3404     Assembler::Jump successCase = m_assembler.jump();
3405 
3406     notElement.link(&amp;m_assembler);
3407     failureCases.append(DOMJIT::branchTestIsShadowRootFlagOnNode(m_assembler, Assembler::Zero, parentNode));
3408     jumpIfNotResolvingStyle(checkingContext).linkTo(checkWithRelation, &amp;m_assembler);
3409 
3410     notResolvingStyle.link(&amp;m_assembler);
3411     failureCases.append(m_assembler.branchTest32(Assembler::NonZero, isOnlyChildRegister));
3412 
3413     successCase.link(&amp;m_assembler);
3414 }
3415 
3416 static bool makeContextStyleUniqueIfNecessaryAndTestIsPlaceholderShown(const Element* element, SelectorChecker::CheckingContext* checkingContext)
3417 {
3418     if (is&lt;HTMLTextFormControlElement&gt;(*element) &amp;&amp; element-&gt;isTextField()) {
3419         if (checkingContext-&gt;resolvingMode == SelectorChecker::Mode::ResolvingStyle)
3420             checkingContext-&gt;styleRelations.append({ *element, Style::Relation::Unique, 1 });
3421         return downcast&lt;HTMLTextFormControlElement&gt;(*element).isPlaceholderVisible();
3422     }
3423     return false;
3424 }
3425 
3426 static bool isPlaceholderShown(const Element* element)
3427 {
3428     return is&lt;HTMLTextFormControlElement&gt;(*element) &amp;&amp; downcast&lt;HTMLTextFormControlElement&gt;(*element).isPlaceholderVisible();
3429 }
3430 
3431 void SelectorCodeGenerator::generateElementHasPlaceholderShown(Assembler::JumpList&amp; failureCases)
3432 {
3433     if (m_selectorContext == SelectorContext::QuerySelector) {
3434         FunctionCall functionCall(m_assembler, m_registerAllocator, m_stackAllocator, m_functionCalls);
3435         functionCall.setFunctionAddress(isPlaceholderShown);
3436         functionCall.setOneArgument(elementAddressRegister);
3437         failureCases.append(functionCall.callAndBranchOnBooleanReturnValue(Assembler::Zero));
3438         return;
3439     }
3440 
3441     Assembler::RegisterID checkingContext = m_registerAllocator.allocateRegisterWithPreference(JSC::GPRInfo::argumentGPR1);
3442     loadCheckingContext(checkingContext);
3443     m_registerAllocator.deallocateRegister(checkingContext);
3444 
3445     FunctionCall functionCall(m_assembler, m_registerAllocator, m_stackAllocator, m_functionCalls);
3446     functionCall.setFunctionAddress(makeContextStyleUniqueIfNecessaryAndTestIsPlaceholderShown);
3447     functionCall.setTwoArguments(elementAddressRegister, checkingContext);
3448     failureCases.append(functionCall.callAndBranchOnBooleanReturnValue(Assembler::Zero));
3449 }
3450 
3451 inline void SelectorCodeGenerator::generateElementHasTagName(Assembler::JumpList&amp; failureCases, const CSSSelector&amp; tagMatchingSelector)
3452 {
3453     const QualifiedName&amp; nameToMatch = tagMatchingSelector.tagQName();
3454     if (nameToMatch == anyQName())
3455         return;
3456 
3457     // Load the QualifiedNameImpl from the input.
3458     LocalRegister qualifiedNameImpl(m_registerAllocator);
3459     m_assembler.loadPtr(Assembler::Address(elementAddressRegister, Element::tagQNameMemoryOffset() + QualifiedName::implMemoryOffset()), qualifiedNameImpl);
3460 
<a name="30" id="anc30"></a><span class="line-modified">3461     const AtomString&amp; selectorLocalName = nameToMatch.localName();</span>
3462     if (selectorLocalName != starAtom()) {
<a name="31" id="anc31"></a><span class="line-modified">3463         const AtomString&amp; lowercaseLocalName = tagMatchingSelector.tagLowercaseLocalName();</span>
3464 
3465         if (selectorLocalName == lowercaseLocalName) {
3466             // Generate localName == element-&gt;localName().
3467             LocalRegister constantRegister(m_registerAllocator);
3468             m_assembler.move(Assembler::TrustedImmPtr(selectorLocalName.impl()), constantRegister);
3469             failureCases.append(m_assembler.branchPtr(Assembler::NotEqual, Assembler::Address(qualifiedNameImpl, QualifiedName::QualifiedNameImpl::localNameMemoryOffset()), constantRegister));
3470         } else {
3471             Assembler::JumpList caseSensitiveCases;
3472             caseSensitiveCases.append(DOMJIT::branchTestIsHTMLFlagOnNode(m_assembler, Assembler::Zero, elementAddressRegister));
3473             {
3474                 LocalRegister document(m_registerAllocator);
3475                 DOMJIT::loadDocument(m_assembler, elementAddressRegister, document);
3476                 caseSensitiveCases.append(testIsHTMLClassOnDocument(Assembler::Zero, m_assembler, document));
3477             }
3478 
3479             LocalRegister constantRegister(m_registerAllocator);
3480             m_assembler.move(Assembler::TrustedImmPtr(lowercaseLocalName.impl()), constantRegister);
3481             Assembler::Jump skipCaseSensitiveCase = m_assembler.jump();
3482 
3483             caseSensitiveCases.link(&amp;m_assembler);
3484             m_assembler.move(Assembler::TrustedImmPtr(selectorLocalName.impl()), constantRegister);
3485             skipCaseSensitiveCase.link(&amp;m_assembler);
3486 
3487             failureCases.append(m_assembler.branchPtr(Assembler::NotEqual, Assembler::Address(qualifiedNameImpl, QualifiedName::QualifiedNameImpl::localNameMemoryOffset()), constantRegister));
3488         }
3489     }
3490 
<a name="32" id="anc32"></a><span class="line-modified">3491     const AtomString&amp; selectorNamespaceURI = nameToMatch.namespaceURI();</span>
3492     if (selectorNamespaceURI != starAtom()) {
3493         // Generate namespaceURI == element-&gt;namespaceURI().
3494         LocalRegister constantRegister(m_registerAllocator);
3495         m_assembler.move(Assembler::TrustedImmPtr(selectorNamespaceURI.impl()), constantRegister);
3496         failureCases.append(m_assembler.branchPtr(Assembler::NotEqual, Assembler::Address(qualifiedNameImpl, QualifiedName::QualifiedNameImpl::namespaceMemoryOffset()), constantRegister));
3497     }
3498 }
3499 
<a name="33" id="anc33"></a><span class="line-modified">3500 void SelectorCodeGenerator::generateElementHasId(Assembler::JumpList&amp; failureCases, const LocalRegister&amp; elementDataAddress, const AtomString&amp; idToMatch)</span>
3501 {
<a name="34" id="anc34"></a><span class="line-modified">3502     // Compare the pointers of the AtomStringImpl from idForStyleResolution with the reference idToMatch.</span>
3503     LocalRegister idToMatchRegister(m_registerAllocator);
3504     m_assembler.move(Assembler::TrustedImmPtr(idToMatch.impl()), idToMatchRegister);
3505     failureCases.append(m_assembler.branchPtr(Assembler::NotEqual, Assembler::Address(elementDataAddress, ElementData::idForStyleResolutionMemoryOffset()), idToMatchRegister));
3506 }
3507 
<a name="35" id="anc35"></a><span class="line-modified">3508 void SelectorCodeGenerator::generateElementHasClasses(Assembler::JumpList&amp; failureCases, const LocalRegister&amp; elementDataAddress, const Vector&lt;const AtomStringImpl*, 8&gt;&amp; classNames)</span>
3509 {
3510     // Load m_classNames.
3511     LocalRegister spaceSplitStringData(m_registerAllocator);
3512     m_assembler.loadPtr(Assembler::Address(elementDataAddress, ElementData::classNamesMemoryOffset()), spaceSplitStringData);
3513 
3514     // If SpaceSplitString does not have a SpaceSplitStringData pointer, it is empty -&gt; failure case.
3515     failureCases.append(m_assembler.branchTestPtr(Assembler::Zero, spaceSplitStringData));
3516 
3517     // We loop over the classes of SpaceSplitStringData for each class name we need to match.
3518     LocalRegister indexRegister(m_registerAllocator);
3519     for (unsigned i = 0; i &lt; classNames.size(); ++i) {
3520         LocalRegister classNameToMatch(m_registerAllocator);
3521         m_assembler.move(Assembler::TrustedImmPtr(classNames[i]), classNameToMatch);
3522         m_assembler.move(Assembler::TrustedImm32(0), indexRegister);
3523 
3524         // Beginning of a loop over all the class name of element to find the one we are looking for.
3525         Assembler::Label loopStart(m_assembler.label());
3526 
3527         // If the pointers match, proceed to the next matcher.
3528         Assembler::Jump classFound = m_assembler.branchPtr(Assembler::Equal, Assembler::BaseIndex(spaceSplitStringData, indexRegister, Assembler::timesPtr(), SpaceSplitStringData::tokensMemoryOffset()), classNameToMatch);
3529 
3530         // Increment the index.
3531         m_assembler.add32(Assembler::TrustedImm32(1), indexRegister);
3532 
3533         // If we reached the last element -&gt; failure.
3534         failureCases.append(m_assembler.branch32(Assembler::Equal, Assembler::Address(spaceSplitStringData, SpaceSplitStringData::sizeMemoryOffset()), indexRegister));
3535         // Otherwise just loop over.
3536         m_assembler.jump().linkTo(loopStart, &amp;m_assembler);
3537 
3538         // Success case.
3539         classFound.link(&amp;m_assembler);
3540     }
3541 }
3542 
3543 void SelectorCodeGenerator::generateElementIsLink(Assembler::JumpList&amp; failureCases)
3544 {
3545     failureCases.append(m_assembler.branchTest32(Assembler::Zero, Assembler::Address(elementAddressRegister, Node::nodeFlagsMemoryOffset()), Assembler::TrustedImm32(Node::flagIsLink())));
3546 }
3547 
3548 static bool nthFilterIsAlwaysSatisified(int a, int b)
3549 {
3550     // Anything modulo 1 is zero. Unless b restricts the range, this does not filter anything out.
3551     if (a == 1 &amp;&amp; (!b || (b == 1)))
3552         return true;
3553     return false;
3554 }
3555 
3556 void SelectorCodeGenerator::generateNthChildParentCheckAndRelationUpdate(Assembler::JumpList&amp; failureCases, const SelectorFragment&amp; fragment)
3557 {
3558     LocalRegister parentNode(m_registerAllocator);
3559     generateWalkToParentNode(parentNode);
3560     failureCases.append(m_assembler.branchTestPtr(Assembler::Zero, parentNode));
3561     Assembler::Jump notElement = DOMJIT::branchTestIsElementFlagOnNode(m_assembler, Assembler::Zero, parentNode);
3562 
3563     auto relation = fragmentMatchesRightmostOrAdjacentElement(fragment)
3564         ? Style::Relation::ChildrenAffectedByForwardPositionalRules
3565         : Style::Relation::DescendantsAffectedByForwardPositionalRules;
3566     generateAddStyleRelationIfResolvingStyle(parentNode, relation);
3567     Assembler::Jump parentNodeCheckEnd = m_assembler.jump();
3568 
3569     notElement.link(&amp;m_assembler);
3570     failureCases.append(DOMJIT::branchTestIsShadowRootFlagOnNode(m_assembler, Assembler::Zero, parentNode));
3571 
3572     parentNodeCheckEnd.link(&amp;m_assembler);
3573 }
3574 
3575 void SelectorCodeGenerator::generateElementIsNthChild(Assembler::JumpList&amp; failureCases, const SelectorFragment&amp; fragment)
3576 {
3577     generateNthChildParentCheckAndRelationUpdate(failureCases, fragment);
3578 
3579     Vector&lt;std::pair&lt;int, int&gt;, 32&gt; validSubsetFilters;
3580     validSubsetFilters.reserveInitialCapacity(fragment.nthChildFilters.size());
3581     for (const auto&amp; slot : fragment.nthChildFilters) {
3582         if (nthFilterIsAlwaysSatisified(slot.first, slot.second))
3583             continue;
3584         validSubsetFilters.uncheckedAppend(slot);
3585     }
3586     if (validSubsetFilters.isEmpty())
3587         return;
3588 
3589     // Setup the counter at 1.
3590     LocalRegisterWithPreference elementCounter(m_registerAllocator, JSC::GPRInfo::argumentGPR1);
3591     m_assembler.move(Assembler::TrustedImm32(1), elementCounter);
3592 
3593     // Loop over the previous adjacent elements and increment the counter.
3594     {
3595         LocalRegister previousSibling(m_registerAllocator);
3596         m_assembler.move(elementAddressRegister, previousSibling);
3597 
3598         // Getting the child index is very efficient when it works. When there is no child index,
3599         // querying at every iteration is very inefficient. We solve this by only testing the child
3600         // index on the first direct adjacent.
3601         Assembler::JumpList noMoreSiblingsCases;
3602 
3603         Assembler::JumpList noCachedChildIndexCases;
3604         generateWalkToPreviousAdjacentElement(noMoreSiblingsCases, previousSibling);
<a name="36" id="anc36"></a><span class="line-modified">3605 </span>
<span class="line-added">3606         LocalRegister elementRareData(m_registerAllocator);</span>
<span class="line-added">3607         m_assembler.loadPtr(Assembler::Address(previousSibling, Node::rareDataMemoryOffset()), elementRareData);</span>
<span class="line-added">3608 </span>
<span class="line-added">3609         noCachedChildIndexCases.append(m_assembler.branchTestPtr(Assembler::Zero, elementRareData));</span>
3610         {
<a name="37" id="anc37"></a>

3611             LocalRegister cachedChildIndex(m_registerAllocator);
3612             m_assembler.load16(Assembler::Address(elementRareData, ElementRareData::childIndexMemoryOffset()), cachedChildIndex);
3613             noCachedChildIndexCases.append(m_assembler.branchTest32(Assembler::Zero, cachedChildIndex));
3614             m_assembler.add32(cachedChildIndex, elementCounter);
3615             noMoreSiblingsCases.append(m_assembler.jump());
3616         }
3617         noCachedChildIndexCases.link(&amp;m_assembler);
3618         m_assembler.add32(Assembler::TrustedImm32(1), elementCounter);
3619 
3620         Assembler::Label loopStart = m_assembler.label();
3621         generateWalkToPreviousAdjacentElement(noMoreSiblingsCases, previousSibling);
3622         m_assembler.add32(Assembler::TrustedImm32(1), elementCounter);
3623         m_assembler.jump().linkTo(loopStart, &amp;m_assembler);
3624         noMoreSiblingsCases.link(&amp;m_assembler);
3625     }
3626 
3627     generateAddStyleRelationIfResolvingStyle(elementAddressRegister, Style::Relation::NthChildIndex, Assembler::RegisterID(elementCounter));
3628 
3629     for (const auto&amp; slot : validSubsetFilters)
3630         generateNthFilterTest(failureCases, elementCounter, slot.first, slot.second);
3631 }
3632 
3633 void SelectorCodeGenerator::generateElementIsNthChildOf(Assembler::JumpList&amp; failureCases, const SelectorFragment&amp; fragment)
3634 {
3635     generateNthChildParentCheckAndRelationUpdate(failureCases, fragment);
3636 
3637     // The initial element must match the selector list.
3638     for (const NthChildOfSelectorInfo&amp; nthChildOfSelectorInfo : fragment.nthChildOfFilters)
3639         generateElementMatchesSelectorList(failureCases, elementAddressRegister, nthChildOfSelectorInfo.selectorList);
3640 
3641     Vector&lt;const NthChildOfSelectorInfo*&gt; validSubsetFilters;
3642     for (const NthChildOfSelectorInfo&amp; nthChildOfSelectorInfo : fragment.nthChildOfFilters) {
3643         if (nthFilterIsAlwaysSatisified(nthChildOfSelectorInfo.a, nthChildOfSelectorInfo.b))
3644             continue;
3645         validSubsetFilters.append(&amp;nthChildOfSelectorInfo);
3646     }
3647     if (validSubsetFilters.isEmpty())
3648         return;
3649 
3650     for (const NthChildOfSelectorInfo* nthChildOfSelectorInfo : validSubsetFilters) {
3651         // Setup the counter at 1.
3652         LocalRegisterWithPreference elementCounter(m_registerAllocator, JSC::GPRInfo::argumentGPR1);
3653         m_assembler.move(Assembler::TrustedImm32(1), elementCounter);
3654 
3655         // Loop over the previous adjacent elements and increment the counter.
3656         {
3657             LocalRegister previousSibling(m_registerAllocator);
3658             m_assembler.move(elementAddressRegister, previousSibling);
3659 
3660             Assembler::JumpList noMoreSiblingsCases;
3661 
3662             Assembler::Label loopStart = m_assembler.label();
3663 
3664             generateWalkToPreviousAdjacentElement(noMoreSiblingsCases, previousSibling);
3665 
3666             Assembler::JumpList localFailureCases;
3667             generateElementMatchesSelectorList(localFailureCases, previousSibling, nthChildOfSelectorInfo-&gt;selectorList);
3668             localFailureCases.linkTo(loopStart, &amp;m_assembler);
3669             m_assembler.add32(Assembler::TrustedImm32(1), elementCounter);
3670             m_assembler.jump().linkTo(loopStart, &amp;m_assembler);
3671 
3672             noMoreSiblingsCases.link(&amp;m_assembler);
3673         }
3674 
3675         generateNthFilterTest(failureCases, elementCounter, nthChildOfSelectorInfo-&gt;a, nthChildOfSelectorInfo-&gt;b);
3676     }
3677 }
3678 
3679 void SelectorCodeGenerator::generateNthLastChildParentCheckAndRelationUpdate(Assembler::JumpList&amp; failureCases, const SelectorFragment&amp; fragment)
3680 {
3681     LocalRegister parentNode(m_registerAllocator);
3682     generateWalkToParentNode(parentNode);
3683     failureCases.append(m_assembler.branchTestPtr(Assembler::Zero, parentNode));
3684     Assembler::Jump notElement = DOMJIT::branchTestIsElementFlagOnNode(m_assembler, Assembler::Zero, parentNode);
3685 
3686     auto relation = fragmentMatchesRightmostOrAdjacentElement(fragment)
3687         ? Style::Relation::ChildrenAffectedByBackwardPositionalRules
3688         : Style::Relation::DescendantsAffectedByBackwardPositionalRules;
3689     generateAddStyleRelationIfResolvingStyle(parentNode, relation);
3690     failureCases.append(m_assembler.branchTest32(Assembler::Zero, Assembler::Address(parentNode, Node::nodeFlagsMemoryOffset()),
3691         Assembler::TrustedImm32(Node::flagIsParsingChildrenFinished())));
3692     Assembler::Jump parentNodeCheckEnd = m_assembler.jump();
3693 
3694     notElement.link(&amp;m_assembler);
3695     failureCases.append(DOMJIT::branchTestIsShadowRootFlagOnNode(m_assembler, Assembler::Zero, parentNode));
3696 
3697     parentNodeCheckEnd.link(&amp;m_assembler);
3698 }
3699 
3700 void SelectorCodeGenerator::generateElementIsNthLastChild(Assembler::JumpList&amp; failureCases, const SelectorFragment&amp; fragment)
3701 {
3702     generateNthLastChildParentCheckAndRelationUpdate(failureCases, fragment);
3703 
3704     Vector&lt;std::pair&lt;int, int&gt;, 32&gt; validSubsetFilters;
3705     validSubsetFilters.reserveInitialCapacity(fragment.nthLastChildFilters.size());
3706     for (const auto&amp; slot : fragment.nthLastChildFilters) {
3707         if (nthFilterIsAlwaysSatisified(slot.first, slot.second))
3708             continue;
3709         validSubsetFilters.uncheckedAppend(slot);
3710     }
3711     if (validSubsetFilters.isEmpty())
3712         return;
3713 
3714     LocalRegister elementCounter(m_registerAllocator);
3715     { // Loop over the following sibling elements and increment the counter.
3716         LocalRegister nextSibling(m_registerAllocator);
3717         m_assembler.move(elementAddressRegister, nextSibling);
3718         // Setup the counter at 1.
3719         m_assembler.move(Assembler::TrustedImm32(1), elementCounter);
3720 
3721         Assembler::JumpList noMoreSiblingsCases;
3722 
3723         generateWalkToNextAdjacentElement(noMoreSiblingsCases, nextSibling);
3724 
3725         Assembler::Label loopStart = m_assembler.label();
3726         m_assembler.add32(Assembler::TrustedImm32(1), elementCounter);
3727         generateWalkToNextAdjacentElement(noMoreSiblingsCases, nextSibling);
3728         m_assembler.jump().linkTo(loopStart, &amp;m_assembler);
3729         noMoreSiblingsCases.link(&amp;m_assembler);
3730     }
3731 
3732     for (const auto&amp; slot : validSubsetFilters)
3733         generateNthFilterTest(failureCases, elementCounter, slot.first, slot.second);
3734 }
3735 
3736 void SelectorCodeGenerator::generateElementIsNthLastChildOf(Assembler::JumpList&amp; failureCases, const SelectorFragment&amp; fragment)
3737 {
3738     generateNthLastChildParentCheckAndRelationUpdate(failureCases, fragment);
3739 
3740     Vector&lt;const NthChildOfSelectorInfo*&gt; validSubsetFilters;
3741     validSubsetFilters.reserveInitialCapacity(fragment.nthLastChildOfFilters.size());
3742 
3743     // The initial element must match the selector list.
3744     for (const NthChildOfSelectorInfo&amp; nthLastChildOfSelectorInfo : fragment.nthLastChildOfFilters)
3745         generateElementMatchesSelectorList(failureCases, elementAddressRegister, nthLastChildOfSelectorInfo.selectorList);
3746 
3747     for (const NthChildOfSelectorInfo&amp; nthLastChildOfSelectorInfo : fragment.nthLastChildOfFilters) {
3748         if (nthFilterIsAlwaysSatisified(nthLastChildOfSelectorInfo.a, nthLastChildOfSelectorInfo.b))
3749             continue;
3750         validSubsetFilters.uncheckedAppend(&amp;nthLastChildOfSelectorInfo);
3751     }
3752     if (validSubsetFilters.isEmpty())
3753         return;
3754 
3755     for (const NthChildOfSelectorInfo* nthLastChildOfSelectorInfo : validSubsetFilters) {
3756         // Setup the counter at 1.
3757         LocalRegisterWithPreference elementCounter(m_registerAllocator, JSC::GPRInfo::argumentGPR1);
3758         m_assembler.move(Assembler::TrustedImm32(1), elementCounter);
3759 
3760         // Loop over the following adjacent elements and increment the counter.
3761         {
3762             LocalRegister nextSibling(m_registerAllocator);
3763             m_assembler.move(elementAddressRegister, nextSibling);
3764 
3765             Assembler::JumpList noMoreSiblingsCases;
3766 
3767             Assembler::Label loopStart = m_assembler.label();
3768 
3769             generateWalkToNextAdjacentElement(noMoreSiblingsCases, nextSibling);
3770 
3771             Assembler::JumpList localFailureCases;
3772             generateElementMatchesSelectorList(localFailureCases, nextSibling, nthLastChildOfSelectorInfo-&gt;selectorList);
3773             localFailureCases.linkTo(loopStart, &amp;m_assembler);
3774             m_assembler.add32(Assembler::TrustedImm32(1), elementCounter);
3775             m_assembler.jump().linkTo(loopStart, &amp;m_assembler);
3776 
3777             noMoreSiblingsCases.link(&amp;m_assembler);
3778         }
3779 
3780         generateNthFilterTest(failureCases, elementCounter, nthLastChildOfSelectorInfo-&gt;a, nthLastChildOfSelectorInfo-&gt;b);
3781     }
3782 }
3783 
3784 void SelectorCodeGenerator::generateElementMatchesNotPseudoClass(Assembler::JumpList&amp; failureCases, const SelectorFragment&amp; fragment)
3785 {
3786     Assembler::JumpList localFailureCases;
3787     generateElementMatchesSelectorList(localFailureCases, elementAddressRegister, fragment.notFilters);
3788     // Since this is a not pseudo class filter, reaching here is a failure.
3789     failureCases.append(m_assembler.jump());
3790     localFailureCases.link(&amp;m_assembler);
3791 }
3792 
3793 void SelectorCodeGenerator::generateElementMatchesAnyPseudoClass(Assembler::JumpList&amp; failureCases, const SelectorFragment&amp; fragment)
3794 {
3795     for (const auto&amp; subFragments : fragment.anyFilters) {
3796         RELEASE_ASSERT(!subFragments.isEmpty());
3797 
3798         // Don&#39;t handle the last fragment in this loop.
3799         Assembler::JumpList successCases;
3800         for (unsigned i = 0; i &lt; subFragments.size() - 1; ++i) {
3801             Assembler::JumpList localFailureCases;
3802             generateElementMatching(localFailureCases, localFailureCases, subFragments[i]);
3803             successCases.append(m_assembler.jump());
3804             localFailureCases.link(&amp;m_assembler);
3805         }
3806 
3807         // At the last fragment, optimize the failure jump to jump to the non-local failure directly.
3808         generateElementMatching(failureCases, failureCases, subFragments.last());
3809         successCases.link(&amp;m_assembler);
3810     }
3811 }
3812 
3813 void SelectorCodeGenerator::generateElementMatchesMatchesPseudoClass(Assembler::JumpList&amp; failureCases, const SelectorFragment&amp; fragment)
3814 {
3815     for (const SelectorList&amp; matchesList : fragment.matchesFilters)
3816         generateElementMatchesSelectorList(failureCases, elementAddressRegister, matchesList);
3817 }
3818 
3819 void SelectorCodeGenerator::generateElementHasPseudoElement(Assembler::JumpList&amp;, const SelectorFragment&amp; fragment)
3820 {
3821     ASSERT_UNUSED(fragment, fragment.pseudoElementSelector);
3822     ASSERT_WITH_MESSAGE(m_selectorContext != SelectorContext::QuerySelector, &quot;When the fragment has pseudo element, the selector becomes CannotMatchAnything for QuerySelector and this test function is not called.&quot;);
3823     ASSERT_WITH_MESSAGE_UNUSED(fragment, fragmentMatchesTheRightmostElement(fragment), &quot;Virtual pseudo elements handling is only effective in the rightmost fragment. If the current fragment is not rightmost fragment, CSS JIT compiler makes it CannotMatchAnything in fragment construction phase, so never reach here.&quot;);
3824 }
3825 
3826 void SelectorCodeGenerator::generateRequestedPseudoElementEqualsToSelectorPseudoElement(Assembler::JumpList&amp; failureCases, const SelectorFragment&amp; fragment, Assembler::RegisterID checkingContext)
3827 {
3828     ASSERT(m_selectorContext != SelectorContext::QuerySelector);
3829 
3830     // Make sure that the requested pseudoId equals to the pseudo element of the rightmost fragment.
3831     // If the rightmost fragment doesn&#39;t have a pseudo element, the requested pseudoId need to be PseudoId::None to succeed the matching.
3832     // Otherwise, if the requested pseudoId is not PseudoId::None, the requested pseudoId need to equal to the pseudo element of the rightmost fragment.
3833     if (fragmentMatchesTheRightmostElement(fragment)) {
3834         if (!fragment.pseudoElementSelector)
3835             failureCases.append(m_assembler.branch8(Assembler::NotEqual, Assembler::Address(checkingContext, OBJECT_OFFSETOF(SelectorChecker::CheckingContext, pseudoId)), Assembler::TrustedImm32(static_cast&lt;unsigned&gt;(PseudoId::None))));
3836         else {
3837             Assembler::Jump skip = m_assembler.branch8(Assembler::Equal, Assembler::Address(checkingContext, OBJECT_OFFSETOF(SelectorChecker::CheckingContext, pseudoId)), Assembler::TrustedImm32(static_cast&lt;unsigned&gt;(PseudoId::None)));
3838             failureCases.append(m_assembler.branch8(Assembler::NotEqual, Assembler::Address(checkingContext, OBJECT_OFFSETOF(SelectorChecker::CheckingContext, pseudoId)), Assembler::TrustedImm32(static_cast&lt;unsigned&gt;(CSSSelector::pseudoId(fragment.pseudoElementSelector-&gt;pseudoElementType())))));
3839             skip.link(&amp;m_assembler);
3840         }
3841     }
3842 }
3843 
3844 void SelectorCodeGenerator::generateElementIsRoot(Assembler::JumpList&amp; failureCases)
3845 {
3846     LocalRegister document(m_registerAllocator);
3847     DOMJIT::loadDocument(m_assembler, elementAddressRegister, document);
3848     failureCases.append(m_assembler.branchPtr(Assembler::NotEqual, Assembler::Address(document, Document::documentElementMemoryOffset()), elementAddressRegister));
3849 }
3850 
3851 void SelectorCodeGenerator::generateElementIsScopeRoot(Assembler::JumpList&amp; failureCases)
3852 {
3853     ASSERT(m_selectorContext == SelectorContext::QuerySelector);
3854 
3855     LocalRegister scope(m_registerAllocator);
3856     loadCheckingContext(scope);
3857     m_assembler.loadPtr(Assembler::Address(scope, OBJECT_OFFSETOF(SelectorChecker::CheckingContext, scope)), scope);
3858 
3859     Assembler::Jump scopeIsNotNull = m_assembler.branchTestPtr(Assembler::NonZero, scope);
3860 
3861     DOMJIT::loadDocument(m_assembler, elementAddressRegister, scope);
3862     DOMJIT::loadDocumentElement(m_assembler, scope, scope);
3863 
3864     scopeIsNotNull.link(&amp;m_assembler);
3865     failureCases.append(m_assembler.branchPtr(Assembler::NotEqual, scope, elementAddressRegister));
3866 }
3867 
3868 void SelectorCodeGenerator::generateElementIsTarget(Assembler::JumpList&amp; failureCases)
3869 {
3870     LocalRegister document(m_registerAllocator);
3871     DOMJIT::loadDocument(m_assembler, elementAddressRegister, document);
3872     failureCases.append(m_assembler.branchPtr(Assembler::NotEqual, Assembler::Address(document, Document::cssTargetMemoryOffset()), elementAddressRegister));
3873 }
3874 
3875 void SelectorCodeGenerator::generateElementHasFocusWithin(Assembler::JumpList&amp; failureCases)
3876 {
3877     generateAddStyleRelationIfResolvingStyle(elementAddressRegister, Style::Relation::AffectedByFocusWithin);
3878     failureCases.append(m_assembler.branchTest32(Assembler::Zero, Assembler::Address(elementAddressRegister, Node::nodeFlagsMemoryOffset()), Assembler::TrustedImm32(Node::flagHasFocusWithin())));
3879 }
3880 
3881 void SelectorCodeGenerator::generateElementIsFirstLink(Assembler::JumpList&amp; failureCases, Assembler::RegisterID element)
3882 {
3883     LocalRegister currentElement(m_registerAllocator);
3884     m_assembler.loadPtr(m_stackAllocator.addressOf(m_startElement), currentElement);
3885 
3886     // Tree walking up to the provided element until link node is found.
3887     Assembler::Label loopStart(m_assembler.label());
3888 
3889     // The target element is always in the ancestors from the start element to the root node.
3890     // So the tree walking doesn&#39;t loop infinitely and it will be stopped with the following `currentElement == element` condition.
3891     Assembler::Jump reachedToElement = m_assembler.branchPtr(Assembler::Equal, currentElement, element);
3892 
3893     failureCases.append(m_assembler.branchTest32(Assembler::NonZero, Assembler::Address(currentElement, Node::nodeFlagsMemoryOffset()), Assembler::TrustedImm32(Node::flagIsLink())));
3894 
3895     // And these ancestors are guaranteed that they are element nodes.
3896     // So there&#39;s no need to check whether it is an element node and whether it is not a nullptr.
3897     m_assembler.loadPtr(Assembler::Address(currentElement, Node::parentNodeMemoryOffset()), currentElement);
3898     m_assembler.jump(loopStart);
3899 
3900     reachedToElement.link(&amp;m_assembler);
3901 }
3902 
3903 void SelectorCodeGenerator::generateStoreLastVisitedElement(Assembler::RegisterID element)
3904 {
3905     m_assembler.storePtr(element, m_stackAllocator.addressOf(m_lastVisitedElement));
3906 }
3907 
3908 void SelectorCodeGenerator::generateMarkPseudoStyleForPseudoElement(Assembler::JumpList&amp; failureCases, const SelectorFragment&amp; fragment)
3909 {
3910     ASSERT(m_selectorContext != SelectorContext::QuerySelector);
3911 
3912     // When fragment doesn&#39;t have a pseudo element, there&#39;s no need to mark the pseudo element style.
3913     if (!fragment.pseudoElementSelector)
3914         return;
3915 
3916     LocalRegister checkingContext(m_registerAllocator);
3917     loadCheckingContext(checkingContext);
3918 
3919     Assembler::JumpList successCases;
3920 
3921     // When the requested pseudoId isn&#39;t PseudoId::None, there&#39;s no need to mark the pseudo element style.
3922     successCases.append(m_assembler.branch8(Assembler::NotEqual, Assembler::Address(checkingContext, OBJECT_OFFSETOF(SelectorChecker::CheckingContext, pseudoId)), Assembler::TrustedImm32(static_cast&lt;unsigned&gt;(PseudoId::None))));
3923 
3924     // When resolving mode is CollectingRulesIgnoringVirtualPseudoElements, there&#39;s no need to mark the pseudo element style.
3925     successCases.append(branchOnResolvingModeWithCheckingContext(Assembler::Equal, SelectorChecker::Mode::CollectingRulesIgnoringVirtualPseudoElements, checkingContext));
3926 
3927     // When resolving mode is ResolvingStyle, mark the pseudo style for pseudo element.
3928     PseudoId dynamicPseudo = CSSSelector::pseudoId(fragment.pseudoElementSelector-&gt;pseudoElementType());
3929     if (dynamicPseudo &lt; PseudoId::FirstInternalPseudoId) {
3930         failureCases.append(branchOnResolvingModeWithCheckingContext(Assembler::NotEqual, SelectorChecker::Mode::ResolvingStyle, checkingContext));
3931 
3932         Assembler::Address pseudoIDSetAddress(checkingContext, OBJECT_OFFSETOF(SelectorChecker::CheckingContext, pseudoIDSet));
3933         auto pseudoIDSetDataAddress = pseudoIDSetAddress.withOffset(PseudoIdSet::dataMemoryOffset());
3934         PseudoIdSet value { dynamicPseudo };
3935         m_assembler.store32(Assembler::TrustedImm32(value.data()), pseudoIDSetDataAddress);
3936     }
3937 
3938     // We have a pseudoElementSelector, we are not in CollectingRulesIgnoringVirtualPseudoElements so
3939     // we must match that pseudo element. Since the context&#39;s pseudo selector is PseudoId::None, we fail matching
3940     // after the marking.
3941     failureCases.append(m_assembler.jump());
3942 
3943     successCases.link(&amp;m_assembler);
3944 }
3945 
3946 void SelectorCodeGenerator::generateNthFilterTest(Assembler::JumpList&amp; failureCases, Assembler::RegisterID counter, int a, int b)
3947 {
3948     if (!a)
3949         failureCases.append(m_assembler.branch32(Assembler::NotEqual, Assembler::TrustedImm32(b), counter));
3950     else if (a &gt; 0) {
3951         if (a == 2 &amp;&amp; b == 1) {
3952             // This is the common case 2n+1 (or &quot;odd&quot;), we can test for odd values without doing the arithmetic.
3953             failureCases.append(m_assembler.branchTest32(Assembler::Zero, counter, Assembler::TrustedImm32(1)));
3954         } else {
3955             if (b) {
3956                 LocalRegister counterCopy(m_registerAllocator);
3957                 m_assembler.move(counter, counterCopy);
3958                 failureCases.append(m_assembler.branchSub32(Assembler::Signed, Assembler::TrustedImm32(b), counterCopy));
3959                 moduloIsZero(failureCases, counterCopy, a);
3960             } else
3961                 moduloIsZero(failureCases, counter, a);
3962         }
3963     } else {
3964         LocalRegister bRegister(m_registerAllocator);
3965         m_assembler.move(Assembler::TrustedImm32(b), bRegister);
3966 
3967         failureCases.append(m_assembler.branchSub32(Assembler::Signed, counter, bRegister));
3968         moduloIsZero(failureCases, bRegister, a);
3969     }
3970 }
3971 
3972 }; // namespace SelectorCompiler.
3973 }; // namespace WebCore.
3974 
3975 #endif // ENABLE(CSS_SELECTOR_JIT)
<a name="38" id="anc38"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="38" type="hidden" />
</body>
</html>