<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/Modules/webgpu/WHLSL/WHLSLChecker.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (C) 2019 Apple Inc. All rights reserved.
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  * 1. Redistributions of source code must retain the above copyright
   8  *    notice, this list of conditions and the following disclaimer.
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
  14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
  15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
  17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
  23  * THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #include &quot;config.h&quot;
  27 #include &quot;WHLSLChecker.h&quot;
  28 
  29 #if ENABLE(WEBGPU)
  30 
  31 #include &quot;WHLSLArrayReferenceType.h&quot;
  32 #include &quot;WHLSLArrayType.h&quot;
  33 #include &quot;WHLSLAssignmentExpression.h&quot;
  34 #include &quot;WHLSLCallExpression.h&quot;
  35 #include &quot;WHLSLCommaExpression.h&quot;
  36 #include &quot;WHLSLDereferenceExpression.h&quot;
  37 #include &quot;WHLSLDoWhileLoop.h&quot;
  38 #include &quot;WHLSLDotExpression.h&quot;
<a name="1" id="anc1"></a>
  39 #include &quot;WHLSLForLoop.h&quot;
  40 #include &quot;WHLSLGatherEntryPointItems.h&quot;
  41 #include &quot;WHLSLIfStatement.h&quot;
  42 #include &quot;WHLSLIndexExpression.h&quot;
  43 #include &quot;WHLSLInferTypes.h&quot;
  44 #include &quot;WHLSLLogicalExpression.h&quot;
  45 #include &quot;WHLSLLogicalNotExpression.h&quot;
  46 #include &quot;WHLSLMakeArrayReferenceExpression.h&quot;
  47 #include &quot;WHLSLMakePointerExpression.h&quot;
<a name="2" id="anc2"></a>
  48 #include &quot;WHLSLPointerType.h&quot;
  49 #include &quot;WHLSLProgram.h&quot;
  50 #include &quot;WHLSLReadModifyWriteExpression.h&quot;
  51 #include &quot;WHLSLResolvableType.h&quot;
  52 #include &quot;WHLSLResolveOverloadImpl.h&quot;
  53 #include &quot;WHLSLResolvingType.h&quot;
  54 #include &quot;WHLSLReturn.h&quot;
  55 #include &quot;WHLSLSwitchStatement.h&quot;
  56 #include &quot;WHLSLTernaryExpression.h&quot;
  57 #include &quot;WHLSLVisitor.h&quot;
  58 #include &quot;WHLSLWhileLoop.h&quot;
  59 #include &lt;wtf/HashMap.h&gt;
  60 #include &lt;wtf/HashSet.h&gt;
  61 #include &lt;wtf/Ref.h&gt;
  62 #include &lt;wtf/Vector.h&gt;
  63 #include &lt;wtf/text/WTFString.h&gt;
  64 
  65 namespace WebCore {
  66 
  67 namespace WHLSL {
  68 
  69 class PODChecker : public Visitor {
  70 public:
  71     PODChecker() = default;
  72 
  73     virtual ~PODChecker() = default;
  74 
  75     void visit(AST::EnumerationDefinition&amp; enumerationDefinition) override
  76     {
  77         Visitor::visit(enumerationDefinition);
  78     }
  79 
  80     void visit(AST::NativeTypeDeclaration&amp; nativeTypeDeclaration) override
  81     {
  82         if (!nativeTypeDeclaration.isNumber()
  83             &amp;&amp; !nativeTypeDeclaration.isVector()
  84             &amp;&amp; !nativeTypeDeclaration.isMatrix())
<a name="3" id="anc3"></a><span class="line-modified">  85             setError();</span>
  86     }
  87 
  88     void visit(AST::StructureDefinition&amp; structureDefinition) override
  89     {
  90         Visitor::visit(structureDefinition);
  91     }
  92 
  93     void visit(AST::TypeDefinition&amp; typeDefinition) override
  94     {
  95         Visitor::visit(typeDefinition);
  96     }
  97 
  98     void visit(AST::ArrayType&amp; arrayType) override
  99     {
 100         Visitor::visit(arrayType);
 101     }
 102 
<a name="4" id="anc4"></a><span class="line-modified"> 103     void visit(AST::PointerType&amp;) override</span>
 104     {
<a name="5" id="anc5"></a><span class="line-modified"> 105         setError();</span>
 106     }
 107 
<a name="6" id="anc6"></a><span class="line-modified"> 108     void visit(AST::ArrayReferenceType&amp;) override</span>
 109     {
<a name="7" id="anc7"></a><span class="line-modified"> 110         setError();</span>
 111     }
 112 
 113     void visit(AST::TypeReference&amp; typeReference) override
 114     {
<a name="8" id="anc8"></a><span class="line-modified"> 115         ASSERT(typeReference.resolvedType());</span>
<span class="line-removed"> 116         checkErrorAndVisit(*typeReference.resolvedType());</span>
 117     }
 118 };
 119 
<a name="9" id="anc9"></a><span class="line-modified"> 120 static AST::NativeFunctionDeclaration resolveWithOperatorAnderIndexer(AST::CallExpression&amp; callExpression, AST::ArrayReferenceType&amp; firstArgument, const Intrinsics&amp; intrinsics)</span>




































































































































 121 {
 122     const bool isOperator = true;
<a name="10" id="anc10"></a><span class="line-modified"> 123     auto returnType = makeUniqueRef&lt;AST::PointerType&gt;(Lexer::Token(callExpression.origin()), firstArgument.addressSpace(), firstArgument.elementType().clone());</span>
 124     AST::VariableDeclarations parameters;
<a name="11" id="anc11"></a><span class="line-modified"> 125     parameters.append(AST::VariableDeclaration(Lexer::Token(callExpression.origin()), AST::Qualifiers(), { firstArgument.clone() }, String(), WTF::nullopt, WTF::nullopt));</span>
<span class="line-modified"> 126     parameters.append(AST::VariableDeclaration(Lexer::Token(callExpression.origin()), AST::Qualifiers(), { AST::TypeReference::wrap(Lexer::Token(callExpression.origin()), intrinsics.uintType()) }, String(), WTF::nullopt, WTF::nullopt));</span>
<span class="line-modified"> 127     return AST::NativeFunctionDeclaration(AST::FunctionDeclaration(Lexer::Token(callExpression.origin()), AST::AttributeBlock(), WTF::nullopt, WTFMove(returnType), String(&quot;operator&amp;[]&quot;, String::ConstructFromLiteral), WTFMove(parameters), WTF::nullopt, isOperator));</span>
 128 }
 129 
<a name="12" id="anc12"></a><span class="line-modified"> 130 static AST::NativeFunctionDeclaration resolveWithOperatorLength(AST::CallExpression&amp; callExpression, AST::UnnamedType&amp; firstArgument, const Intrinsics&amp; intrinsics)</span>
 131 {
 132     const bool isOperator = true;
<a name="13" id="anc13"></a><span class="line-modified"> 133     auto returnType = AST::TypeReference::wrap(Lexer::Token(callExpression.origin()), intrinsics.uintType());</span>
 134     AST::VariableDeclarations parameters;
<a name="14" id="anc14"></a><span class="line-modified"> 135     parameters.append(AST::VariableDeclaration(Lexer::Token(callExpression.origin()), AST::Qualifiers(), { firstArgument.clone() }, String(), WTF::nullopt, WTF::nullopt));</span>
<span class="line-modified"> 136     return AST::NativeFunctionDeclaration(AST::FunctionDeclaration(Lexer::Token(callExpression.origin()), AST::AttributeBlock(), WTF::nullopt, WTFMove(returnType), String(&quot;operator.length&quot;, String::ConstructFromLiteral), WTFMove(parameters), WTF::nullopt, isOperator));</span>
 137 }
 138 
<a name="15" id="anc15"></a><span class="line-modified"> 139 static AST::NativeFunctionDeclaration resolveWithReferenceComparator(AST::CallExpression&amp; callExpression, ResolvingType&amp; firstArgument, ResolvingType&amp; secondArgument, const Intrinsics&amp; intrinsics)</span>
 140 {
 141     const bool isOperator = true;
<a name="16" id="anc16"></a><span class="line-modified"> 142     auto returnType = AST::TypeReference::wrap(Lexer::Token(callExpression.origin()), intrinsics.boolType());</span>
<span class="line-modified"> 143     auto argumentType = WTF::visit(WTF::makeVisitor([](UniqueRef&lt;AST::UnnamedType&gt;&amp; unnamedType) -&gt; UniqueRef&lt;AST::UnnamedType&gt; {</span>
<span class="line-modified"> 144         return unnamedType-&gt;clone();</span>
<span class="line-modified"> 145     }, [&amp;](Ref&lt;ResolvableTypeReference&gt;&amp;) -&gt; UniqueRef&lt;AST::UnnamedType&gt; {</span>
<span class="line-modified"> 146         return WTF::visit(WTF::makeVisitor([](UniqueRef&lt;AST::UnnamedType&gt;&amp; unnamedType) -&gt; UniqueRef&lt;AST::UnnamedType&gt; {</span>
<span class="line-modified"> 147             return unnamedType-&gt;clone();</span>
<span class="line-modified"> 148         }, [&amp;](Ref&lt;ResolvableTypeReference&gt;&amp;) -&gt; UniqueRef&lt;AST::UnnamedType&gt; {</span>
 149             // We encountered &quot;null == null&quot;.
<a name="17" id="anc17"></a><span class="line-modified"> 150             // The type isn&#39;t observable, so we can pick whatever we want.</span>
<span class="line-modified"> 151             // FIXME: This can probably be generalized, using the &quot;preferred type&quot; infrastructure used by generic literals</span>
<span class="line-modified"> 152             return AST::TypeReference::wrap(Lexer::Token(callExpression.origin()), intrinsics.intType());</span>
<span class="line-modified"> 153         }), secondArgument);</span>
<span class="line-modified"> 154     }), firstArgument);</span>
 155     AST::VariableDeclarations parameters;
<a name="18" id="anc18"></a><span class="line-modified"> 156     parameters.append(AST::VariableDeclaration(Lexer::Token(callExpression.origin()), AST::Qualifiers(), { argumentType-&gt;clone() }, String(), WTF::nullopt, WTF::nullopt));</span>
<span class="line-modified"> 157     parameters.append(AST::VariableDeclaration(Lexer::Token(callExpression.origin()), AST::Qualifiers(), { WTFMove(argumentType) }, String(), WTF::nullopt, WTF::nullopt));</span>
<span class="line-modified"> 158     return AST::NativeFunctionDeclaration(AST::FunctionDeclaration(Lexer::Token(callExpression.origin()), AST::AttributeBlock(), WTF::nullopt, WTFMove(returnType), String(&quot;operator==&quot;, String::ConstructFromLiteral), WTFMove(parameters), WTF::nullopt, isOperator));</span>
 159 }
 160 
<a name="19" id="anc19"></a><span class="line-modified"> 161 static Optional&lt;AST::NativeFunctionDeclaration&gt; resolveByInstantiation(AST::CallExpression&amp; callExpression, const Vector&lt;std::reference_wrapper&lt;ResolvingType&gt;&gt;&amp; types, const Intrinsics&amp; intrinsics)</span>






 162 {
<a name="20" id="anc20"></a><span class="line-modified"> 163     if (callExpression.name() == &quot;operator&amp;[]&quot; &amp;&amp; types.size() == 2) {</span>
<span class="line-modified"> 164         auto* firstArgumentArrayRef = WTF::visit(WTF::makeVisitor([](UniqueRef&lt;AST::UnnamedType&gt;&amp; unnamedType) -&gt; AST::ArrayReferenceType* {</span>
 165             if (is&lt;AST::ArrayReferenceType&gt;(static_cast&lt;AST::UnnamedType&amp;&gt;(unnamedType)))
 166                 return &amp;downcast&lt;AST::ArrayReferenceType&gt;(static_cast&lt;AST::UnnamedType&amp;&gt;(unnamedType));
 167             return nullptr;
<a name="21" id="anc21"></a><span class="line-modified"> 168         }, [](Ref&lt;ResolvableTypeReference&gt;&amp;) -&gt; AST::ArrayReferenceType* {</span>
 169             return nullptr;
<a name="22" id="anc22"></a><span class="line-modified"> 170         }), types[0].get());</span>
<span class="line-modified"> 171         bool secondArgumentIsUint = WTF::visit(WTF::makeVisitor([&amp;](UniqueRef&lt;AST::UnnamedType&gt;&amp; unnamedType) -&gt; bool {</span>
 172             return matches(unnamedType, intrinsics.uintType());
<a name="23" id="anc23"></a><span class="line-modified"> 173         }, [&amp;](Ref&lt;ResolvableTypeReference&gt;&amp; resolvableTypeReference) -&gt; bool {</span>
 174             return resolvableTypeReference-&gt;resolvableType().canResolve(intrinsics.uintType());
<a name="24" id="anc24"></a><span class="line-modified"> 175         }), types[1].get());</span>
 176         if (firstArgumentArrayRef &amp;&amp; secondArgumentIsUint)
<a name="25" id="anc25"></a><span class="line-modified"> 177             return resolveWithOperatorAnderIndexer(callExpression, *firstArgumentArrayRef, intrinsics);</span>
<span class="line-modified"> 178     } else if (callExpression.name() == &quot;operator.length&quot; &amp;&amp; types.size() == 1) {</span>
<span class="line-modified"> 179         auto* firstArgumentReference = WTF::visit(WTF::makeVisitor([](UniqueRef&lt;AST::UnnamedType&gt;&amp; unnamedType) -&gt; AST::UnnamedType* {</span>
 180             if (is&lt;AST::ArrayReferenceType&gt;(static_cast&lt;AST::UnnamedType&amp;&gt;(unnamedType)) || is&lt;AST::ArrayType&gt;(static_cast&lt;AST::UnnamedType&amp;&gt;(unnamedType)))
<a name="26" id="anc26"></a><span class="line-modified"> 181                 return &amp;unnamedType;</span>
 182             return nullptr;
<a name="27" id="anc27"></a><span class="line-modified"> 183         }, [](Ref&lt;ResolvableTypeReference&gt;&amp;) -&gt; AST::UnnamedType* {</span>
 184             return nullptr;
<a name="28" id="anc28"></a><span class="line-modified"> 185         }), types[0].get());</span>
 186         if (firstArgumentReference)
<a name="29" id="anc29"></a><span class="line-modified"> 187             return resolveWithOperatorLength(callExpression, *firstArgumentReference, intrinsics);</span>
<span class="line-modified"> 188     } else if (callExpression.name() == &quot;operator==&quot; &amp;&amp; types.size() == 2) {</span>
<span class="line-modified"> 189         auto isAcceptable = [](ResolvingType&amp; resolvingType) -&gt; bool {</span>
<span class="line-modified"> 190             return WTF::visit(WTF::makeVisitor([](UniqueRef&lt;AST::UnnamedType&gt;&amp; unnamedType) -&gt; bool {</span>
<span class="line-modified"> 191                 return is&lt;AST::ReferenceType&gt;(static_cast&lt;AST::UnnamedType&amp;&gt;(unnamedType));</span>
<span class="line-modified"> 192             }, [](Ref&lt;ResolvableTypeReference&gt;&amp; resolvableTypeReference) -&gt; bool {</span>
<span class="line-modified"> 193                 return is&lt;AST::NullLiteralType&gt;(resolvableTypeReference-&gt;resolvableType());</span>
<span class="line-modified"> 194             }), resolvingType);</span>

 195         };
<a name="30" id="anc30"></a><span class="line-modified"> 196         if (isAcceptable(types[0].get()) &amp;&amp; isAcceptable(types[1].get()))</span>
<span class="line-modified"> 197             return resolveWithReferenceComparator(callExpression, types[0].get(), types[1].get(), intrinsics);</span>










 198     }
 199     return WTF::nullopt;
 200 }
 201 
 202 static bool checkSemantics(Vector&lt;EntryPointItem&gt;&amp; inputItems, Vector&lt;EntryPointItem&gt;&amp; outputItems, const Optional&lt;AST::EntryPointType&gt;&amp; entryPointType, const Intrinsics&amp; intrinsics)
 203 {
 204     {
 205         auto checkDuplicateSemantics = [&amp;](const Vector&lt;EntryPointItem&gt;&amp; items) -&gt; bool {
 206             for (size_t i = 0; i &lt; items.size(); ++i) {
 207                 for (size_t j = i + 1; j &lt; items.size(); ++j) {
 208                     if (items[i].semantic == items[j].semantic)
 209                         return false;
 210                 }
 211             }
 212             return true;
 213         };
 214         if (!checkDuplicateSemantics(inputItems))
 215             return false;
 216         if (!checkDuplicateSemantics(outputItems))
 217             return false;
 218     }
 219 
 220     {
 221         auto checkSemanticTypes = [&amp;](const Vector&lt;EntryPointItem&gt;&amp; items) -&gt; bool {
 222             for (auto&amp; item : items) {
 223                 auto acceptable = WTF::visit(WTF::makeVisitor([&amp;](const AST::BaseSemantic&amp; semantic) -&gt; bool {
 224                     return semantic.isAcceptableType(*item.unnamedType, intrinsics);
 225                 }), *item.semantic);
 226                 if (!acceptable)
 227                     return false;
 228             }
 229             return true;
 230         };
 231         if (!checkSemanticTypes(inputItems))
 232             return false;
 233         if (!checkSemanticTypes(outputItems))
 234             return false;
 235     }
 236 
 237     {
 238         auto checkSemanticForShaderType = [&amp;](const Vector&lt;EntryPointItem&gt;&amp; items, AST::BaseSemantic::ShaderItemDirection direction) -&gt; bool {
 239             for (auto&amp; item : items) {
 240                 auto acceptable = WTF::visit(WTF::makeVisitor([&amp;](const AST::BaseSemantic&amp; semantic) -&gt; bool {
 241                     return semantic.isAcceptableForShaderItemDirection(direction, entryPointType);
 242                 }), *item.semantic);
 243                 if (!acceptable)
 244                     return false;
 245             }
 246             return true;
 247         };
 248         if (!checkSemanticForShaderType(inputItems, AST::BaseSemantic::ShaderItemDirection::Input))
 249             return false;
 250         if (!checkSemanticForShaderType(outputItems, AST::BaseSemantic::ShaderItemDirection::Output))
 251             return false;
 252     }
 253 
 254     {
 255         auto checkPODData = [&amp;](const Vector&lt;EntryPointItem&gt;&amp; items) -&gt; bool {
 256             for (auto&amp; item : items) {
 257                 PODChecker podChecker;
 258                 if (is&lt;AST::PointerType&gt;(item.unnamedType))
 259                     podChecker.checkErrorAndVisit(downcast&lt;AST::PointerType&gt;(*item.unnamedType).elementType());
 260                 else if (is&lt;AST::ArrayReferenceType&gt;(item.unnamedType))
 261                     podChecker.checkErrorAndVisit(downcast&lt;AST::ArrayReferenceType&gt;(*item.unnamedType).elementType());
 262                 else if (is&lt;AST::ArrayType&gt;(item.unnamedType))
 263                     podChecker.checkErrorAndVisit(downcast&lt;AST::ArrayType&gt;(*item.unnamedType).type());
 264                 else
 265                     continue;
<a name="31" id="anc31"></a><span class="line-modified"> 266                 if (podChecker.error())</span>
 267                     return false;
 268             }
 269             return true;
 270         };
 271         if (!checkPODData(inputItems))
 272             return false;
 273         if (!checkPODData(outputItems))
 274             return false;
 275     }
 276 
 277     return true;
 278 }
 279 
<a name="32" id="anc32"></a><span class="line-modified"> 280 static bool checkOperatorOverload(const AST::FunctionDefinition&amp; functionDefinition, const Intrinsics&amp; intrinsics, NameContext&amp; nameContext)</span>
 281 {
 282     enum class CheckKind {
 283         Index,
 284         Dot
 285     };
 286 
 287     auto checkGetter = [&amp;](CheckKind kind) -&gt; bool {
 288         size_t numExpectedParameters = kind == CheckKind::Index ? 2 : 1;
 289         if (functionDefinition.parameters().size() != numExpectedParameters)
 290             return false;
<a name="33" id="anc33"></a><span class="line-modified"> 291         auto&amp; firstParameterUnifyNode = (*functionDefinition.parameters()[0].type())-&gt;unifyNode();</span>
 292         if (is&lt;AST::UnnamedType&gt;(firstParameterUnifyNode)) {
 293             auto&amp; unnamedType = downcast&lt;AST::UnnamedType&gt;(firstParameterUnifyNode);
 294             if (is&lt;AST::PointerType&gt;(unnamedType) || is&lt;AST::ArrayReferenceType&gt;(unnamedType) || is&lt;AST::ArrayType&gt;(unnamedType))
 295                 return false;
 296         }
 297         if (kind == CheckKind::Index) {
<a name="34" id="anc34"></a><span class="line-modified"> 298             auto&amp; secondParameterUnifyNode = (*functionDefinition.parameters()[1].type())-&gt;unifyNode();</span>
 299             if (!is&lt;AST::NamedType&gt;(secondParameterUnifyNode))
 300                 return false;
 301             auto&amp; namedType = downcast&lt;AST::NamedType&gt;(secondParameterUnifyNode);
 302             if (!is&lt;AST::NativeTypeDeclaration&gt;(namedType))
 303                 return false;
 304             auto&amp; nativeTypeDeclaration = downcast&lt;AST::NativeTypeDeclaration&gt;(namedType);
 305             if (!nativeTypeDeclaration.isInt())
 306                 return false;
 307         }
 308         return true;
 309     };
 310 
 311     auto checkSetter = [&amp;](CheckKind kind) -&gt; bool {
 312         size_t numExpectedParameters = kind == CheckKind::Index ? 3 : 2;
 313         if (functionDefinition.parameters().size() != numExpectedParameters)
 314             return false;
<a name="35" id="anc35"></a><span class="line-modified"> 315         auto&amp; firstArgumentUnifyNode = (*functionDefinition.parameters()[0].type())-&gt;unifyNode();</span>
 316         if (is&lt;AST::UnnamedType&gt;(firstArgumentUnifyNode)) {
 317             auto&amp; unnamedType = downcast&lt;AST::UnnamedType&gt;(firstArgumentUnifyNode);
 318             if (is&lt;AST::PointerType&gt;(unnamedType) || is&lt;AST::ArrayReferenceType&gt;(unnamedType) || is&lt;AST::ArrayType&gt;(unnamedType))
 319                 return false;
 320         }
 321         if (kind == CheckKind::Index) {
<a name="36" id="anc36"></a><span class="line-modified"> 322             auto&amp; secondParameterUnifyNode = (*functionDefinition.parameters()[1].type())-&gt;unifyNode();</span>
 323             if (!is&lt;AST::NamedType&gt;(secondParameterUnifyNode))
 324                 return false;
 325             auto&amp; namedType = downcast&lt;AST::NamedType&gt;(secondParameterUnifyNode);
 326             if (!is&lt;AST::NativeTypeDeclaration&gt;(namedType))
 327                 return false;
 328             auto&amp; nativeTypeDeclaration = downcast&lt;AST::NativeTypeDeclaration&gt;(namedType);
 329             if (!nativeTypeDeclaration.isInt())
 330                 return false;
 331         }
<a name="37" id="anc37"></a><span class="line-modified"> 332         if (!matches(functionDefinition.type(), *functionDefinition.parameters()[0].type()))</span>
 333             return false;
<a name="38" id="anc38"></a><span class="line-modified"> 334         auto&amp; valueType = *functionDefinition.parameters()[numExpectedParameters - 1].type();</span>
 335         auto getterName = functionDefinition.name().substring(0, functionDefinition.name().length() - 1);
<a name="39" id="anc39"></a><span class="line-modified"> 336         auto* getterFuncs = nameContext.getFunctions(getterName);</span>
<span class="line-removed"> 337         if (!getterFuncs)</span>
<span class="line-removed"> 338             return false;</span>
 339         Vector&lt;ResolvingType&gt; argumentTypes;
 340         Vector&lt;std::reference_wrapper&lt;ResolvingType&gt;&gt; argumentTypeReferences;
 341         for (size_t i = 0; i &lt; numExpectedParameters - 1; ++i)
<a name="40" id="anc40"></a><span class="line-modified"> 342             argumentTypes.append((*functionDefinition.parameters()[0].type())-&gt;clone());</span>
 343         for (auto&amp; argumentType : argumentTypes)
 344             argumentTypeReferences.append(argumentType);
<a name="41" id="anc41"></a><span class="line-modified"> 345         Optional&lt;std::reference_wrapper&lt;AST::NamedType&gt;&gt; castReturnType;</span>
<span class="line-removed"> 346         auto* overload = resolveFunctionOverloadImpl(*getterFuncs, argumentTypeReferences, castReturnType);</span>
 347         if (!overload)
 348             return false;
 349         auto&amp; resultType = overload-&gt;type();
 350         return matches(resultType, valueType);
 351     };
 352 
 353     auto checkAnder = [&amp;](CheckKind kind) -&gt; bool {
 354         size_t numExpectedParameters = kind == CheckKind::Index ? 2 : 1;
 355         if (functionDefinition.parameters().size() != numExpectedParameters)
 356             return false;
 357         {
 358             auto&amp; unifyNode = functionDefinition.type().unifyNode();
 359             if (!is&lt;AST::UnnamedType&gt;(unifyNode))
 360                 return false;
 361             auto&amp; unnamedType = downcast&lt;AST::UnnamedType&gt;(unifyNode);
 362             if (!is&lt;AST::PointerType&gt;(unnamedType))
 363                 return false;
 364         }
 365         {
<a name="42" id="anc42"></a><span class="line-modified"> 366             auto&amp; unifyNode = (*functionDefinition.parameters()[0].type())-&gt;unifyNode();</span>
 367             if (!is&lt;AST::UnnamedType&gt;(unifyNode))
 368                 return false;
 369             auto&amp; unnamedType = downcast&lt;AST::UnnamedType&gt;(unifyNode);
 370             return is&lt;AST::PointerType&gt;(unnamedType) || is&lt;AST::ArrayReferenceType&gt;(unnamedType);
 371         }
 372     };
 373 
 374     if (!functionDefinition.isOperator())
 375         return true;
 376     if (functionDefinition.isCast())
 377         return true;
 378     if (functionDefinition.name() == &quot;operator++&quot; || functionDefinition.name() == &quot;operator--&quot;) {
 379         return functionDefinition.parameters().size() == 1
<a name="43" id="anc43"></a><span class="line-modified"> 380             &amp;&amp; matches(*functionDefinition.parameters()[0].type(), functionDefinition.type());</span>
 381     }
 382     if (functionDefinition.name() == &quot;operator+&quot; || functionDefinition.name() == &quot;operator-&quot;)
 383         return functionDefinition.parameters().size() == 1 || functionDefinition.parameters().size() == 2;
 384     if (functionDefinition.name() == &quot;operator*&quot;
 385         || functionDefinition.name() == &quot;operator/&quot;
 386         || functionDefinition.name() == &quot;operator%&quot;
 387         || functionDefinition.name() == &quot;operator&amp;&quot;
 388         || functionDefinition.name() == &quot;operator|&quot;
 389         || functionDefinition.name() == &quot;operator^&quot;
 390         || functionDefinition.name() == &quot;operator&lt;&lt;&quot;
<a name="44" id="anc44"></a><span class="line-modified"> 391         || functionDefinition.name() == &quot;opreator&gt;&gt;&quot;)</span>
 392         return functionDefinition.parameters().size() == 2;
 393     if (functionDefinition.name() == &quot;operator~&quot;)
 394         return functionDefinition.parameters().size() == 1;
<a name="45" id="anc45"></a><span class="line-removed"> 395     if (functionDefinition.name() == &quot;operator==&quot;</span>
<span class="line-removed"> 396         || functionDefinition.name() == &quot;operator&lt;&quot;</span>
<span class="line-removed"> 397         || functionDefinition.name() == &quot;operator&lt;=&quot;</span>
<span class="line-removed"> 398         || functionDefinition.name() == &quot;operator&gt;&quot;</span>
<span class="line-removed"> 399         || functionDefinition.name() == &quot;operator&gt;=&quot;) {</span>
<span class="line-removed"> 400         return functionDefinition.parameters().size() == 2</span>
<span class="line-removed"> 401             &amp;&amp; matches(functionDefinition.type(), intrinsics.boolType());</span>
<span class="line-removed"> 402     }</span>
 403     if (functionDefinition.name() == &quot;operator[]&quot;)
 404         return checkGetter(CheckKind::Index);
 405     if (functionDefinition.name() == &quot;operator[]=&quot;)
 406         return checkSetter(CheckKind::Index);
 407     if (functionDefinition.name() == &quot;operator&amp;[]&quot;)
 408         return checkAnder(CheckKind::Index);
 409     if (functionDefinition.name().startsWith(&quot;operator.&quot;)) {
 410         if (functionDefinition.name().endsWith(&quot;=&quot;))
 411             return checkSetter(CheckKind::Dot);
 412         return checkGetter(CheckKind::Dot);
 413     }
 414     if (functionDefinition.name().startsWith(&quot;operator&amp;.&quot;))
 415         return checkAnder(CheckKind::Dot);
 416     return false;
 417 }
 418 
 419 class Checker : public Visitor {
 420 public:
 421     Checker(const Intrinsics&amp; intrinsics, Program&amp; program)
 422         : m_intrinsics(intrinsics)
 423         , m_program(program)
 424     {
<a name="46" id="anc46"></a>


















 425     }
 426 
<a name="47" id="anc47"></a><span class="line-modified"> 427     ~Checker() = default;</span>
 428 
 429     void visit(Program&amp;) override;
 430 
<a name="48" id="anc48"></a><span class="line-modified"> 431     bool assignTypes();</span>
 432 
 433 private:
 434     bool checkShaderType(const AST::FunctionDefinition&amp;);
<a name="49" id="anc49"></a><span class="line-removed"> 435     void finishVisitingPropertyAccess(AST::PropertyAccessExpression&amp;, AST::UnnamedType&amp; wrappedBaseType, AST::UnnamedType* extraArgumentType = nullptr);</span>
 436     bool isBoolType(ResolvingType&amp;);
 437     struct RecurseInfo {
 438         ResolvingType&amp; resolvingType;
<a name="50" id="anc50"></a><span class="line-modified"> 439         Optional&lt;AST::AddressSpace&gt;&amp; addressSpace;</span>
 440     };
<a name="51" id="anc51"></a><span class="line-modified"> 441     Optional&lt;RecurseInfo&gt; recurseAndGetInfo(AST::Expression&amp;, bool requiresLValue = false);</span>
<span class="line-modified"> 442     Optional&lt;RecurseInfo&gt; getInfo(AST::Expression&amp;, bool requiresLValue = false);</span>
<span class="line-modified"> 443     Optional&lt;UniqueRef&lt;AST::UnnamedType&gt;&gt; recurseAndWrapBaseType(AST::PropertyAccessExpression&amp;);</span>
 444     bool recurseAndRequireBoolType(AST::Expression&amp;);
<a name="52" id="anc52"></a><span class="line-modified"> 445     void assignType(AST::Expression&amp;, UniqueRef&lt;AST::UnnamedType&gt;&amp;&amp;, Optional&lt;AST::AddressSpace&gt; = WTF::nullopt);</span>
<span class="line-modified"> 446     void assignType(AST::Expression&amp;, Ref&lt;ResolvableTypeReference&gt;&amp;&amp;, Optional&lt;AST::AddressSpace&gt; = WTF::nullopt);</span>
<span class="line-modified"> 447     void forwardType(AST::Expression&amp;, ResolvingType&amp;, Optional&lt;AST::AddressSpace&gt; = WTF::nullopt);</span>
 448 
 449     void visit(AST::FunctionDefinition&amp;) override;
 450     void visit(AST::EnumerationDefinition&amp;) override;
 451     void visit(AST::TypeReference&amp;) override;
 452     void visit(AST::VariableDeclaration&amp;) override;
 453     void visit(AST::AssignmentExpression&amp;) override;
 454     void visit(AST::ReadModifyWriteExpression&amp;) override;
 455     void visit(AST::DereferenceExpression&amp;) override;
 456     void visit(AST::MakePointerExpression&amp;) override;
 457     void visit(AST::MakeArrayReferenceExpression&amp;) override;
 458     void visit(AST::DotExpression&amp;) override;
 459     void visit(AST::IndexExpression&amp;) override;
 460     void visit(AST::VariableReference&amp;) override;
 461     void visit(AST::Return&amp;) override;
 462     void visit(AST::PointerType&amp;) override;
 463     void visit(AST::ArrayReferenceType&amp;) override;
 464     void visit(AST::IntegerLiteral&amp;) override;
 465     void visit(AST::UnsignedIntegerLiteral&amp;) override;
 466     void visit(AST::FloatLiteral&amp;) override;
 467     void visit(AST::NullLiteral&amp;) override;
 468     void visit(AST::BooleanLiteral&amp;) override;
 469     void visit(AST::EnumerationMemberLiteral&amp;) override;
 470     void visit(AST::LogicalNotExpression&amp;) override;
 471     void visit(AST::LogicalExpression&amp;) override;
 472     void visit(AST::IfStatement&amp;) override;
 473     void visit(AST::WhileLoop&amp;) override;
 474     void visit(AST::DoWhileLoop&amp;) override;
 475     void visit(AST::ForLoop&amp;) override;
 476     void visit(AST::SwitchStatement&amp;) override;
 477     void visit(AST::CommaExpression&amp;) override;
 478     void visit(AST::TernaryExpression&amp;) override;
 479     void visit(AST::CallExpression&amp;) override;
 480 
<a name="53" id="anc53"></a><span class="line-modified"> 481     HashMap&lt;AST::Expression*, ResolvingType&gt; m_typeMap;</span>
<span class="line-modified"> 482     HashMap&lt;AST::Expression*, Optional&lt;AST::AddressSpace&gt;&gt; m_addressSpaceMap;</span>
<span class="line-modified"> 483     HashSet&lt;String&gt; m_vertexEntryPoints;</span>
<span class="line-modified"> 484     HashSet&lt;String&gt; m_fragmentEntryPoints;</span>
<span class="line-modified"> 485     HashSet&lt;String&gt; m_computeEntryPoints;</span>

































 486     const Intrinsics&amp; m_intrinsics;
 487     Program&amp; m_program;
<a name="54" id="anc54"></a>



 488 };
 489 
 490 void Checker::visit(Program&amp; program)
 491 {
 492     // These visiting functions might add new global statements, so don&#39;t use foreach syntax.
 493     for (size_t i = 0; i &lt; program.typeDefinitions().size(); ++i)
 494         checkErrorAndVisit(program.typeDefinitions()[i]);
 495     for (size_t i = 0; i &lt; program.structureDefinitions().size(); ++i)
 496         checkErrorAndVisit(program.structureDefinitions()[i]);
 497     for (size_t i = 0; i &lt; program.enumerationDefinitions().size(); ++i)
 498         checkErrorAndVisit(program.enumerationDefinitions()[i]);
 499     for (size_t i = 0; i &lt; program.nativeTypeDeclarations().size(); ++i)
 500         checkErrorAndVisit(program.nativeTypeDeclarations()[i]);
 501 
 502     for (size_t i = 0; i &lt; program.functionDefinitions().size(); ++i)
 503         checkErrorAndVisit(program.functionDefinitions()[i]);
 504     for (size_t i = 0; i &lt; program.nativeFunctionDeclarations().size(); ++i)
 505         checkErrorAndVisit(program.nativeFunctionDeclarations()[i]);
 506 }
 507 
<a name="55" id="anc55"></a><span class="line-modified"> 508 bool Checker::assignTypes()</span>
 509 {
 510     for (auto&amp; keyValuePair : m_typeMap) {
<a name="56" id="anc56"></a><span class="line-modified"> 511         auto success = WTF::visit(WTF::makeVisitor([&amp;](UniqueRef&lt;AST::UnnamedType&gt;&amp; unnamedType) -&gt; bool {</span>
<span class="line-modified"> 512             keyValuePair.key-&gt;setType(unnamedType-&gt;clone());</span>
 513             return true;
<a name="57" id="anc57"></a><span class="line-modified"> 514         }, [&amp;](Ref&lt;ResolvableTypeReference&gt;&amp; resolvableTypeReference) -&gt; bool {</span>
<span class="line-modified"> 515             if (!resolvableTypeReference-&gt;resolvableType().resolvedType()) {</span>
<span class="line-removed"> 516                 // FIXME: Instead of trying to commit, it might be better to just return an error instead.</span>
 517                 if (!static_cast&lt;bool&gt;(commit(resolvableTypeReference-&gt;resolvableType())))
 518                     return false;
 519             }
<a name="58" id="anc58"></a><span class="line-modified"> 520             keyValuePair.key-&gt;setType(resolvableTypeReference-&gt;resolvableType().resolvedType()-&gt;clone());</span>
 521             return true;
<a name="59" id="anc59"></a><span class="line-modified"> 522         }), keyValuePair.value);</span>
 523         if (!success)
<a name="60" id="anc60"></a><span class="line-modified"> 524             return false;</span>
 525     }
 526 
<a name="61" id="anc61"></a><span class="line-modified"> 527     for (auto&amp; keyValuePair : m_addressSpaceMap)</span>
<span class="line-removed"> 528         keyValuePair.key-&gt;setAddressSpace(keyValuePair.value);</span>
<span class="line-removed"> 529     return true;</span>
 530 }
 531 
 532 bool Checker::checkShaderType(const AST::FunctionDefinition&amp; functionDefinition)
 533 {
<a name="62" id="anc62"></a>
 534     switch (*functionDefinition.entryPointType()) {
 535     case AST::EntryPointType::Vertex:
<a name="63" id="anc63"></a><span class="line-modified"> 536         return !m_vertexEntryPoints.add(functionDefinition.name()).isNewEntry;</span>
 537     case AST::EntryPointType::Fragment:
<a name="64" id="anc64"></a><span class="line-modified"> 538         return !m_fragmentEntryPoints.add(functionDefinition.name()).isNewEntry;</span>
 539     case AST::EntryPointType::Compute:
<a name="65" id="anc65"></a><span class="line-modified"> 540         return !m_computeEntryPoints.add(functionDefinition.name()).isNewEntry;</span>
 541     }
 542 }
 543 
 544 void Checker::visit(AST::FunctionDefinition&amp; functionDefinition)
 545 {
<a name="66" id="anc66"></a>

 546     if (functionDefinition.entryPointType()) {
 547         if (!checkShaderType(functionDefinition)) {
<a name="67" id="anc67"></a><span class="line-modified"> 548             setError();</span>
 549             return;
 550         }
 551         auto entryPointItems = gatherEntryPointItems(m_intrinsics, functionDefinition);
 552         if (!entryPointItems) {
<a name="68" id="anc68"></a><span class="line-modified"> 553             setError();</span>
 554             return;
 555         }
 556         if (!checkSemantics(entryPointItems-&gt;inputs, entryPointItems-&gt;outputs, functionDefinition.entryPointType(), m_intrinsics)) {
<a name="69" id="anc69"></a><span class="line-modified"> 557             setError();</span>
 558             return;
 559         }
 560     }
<a name="70" id="anc70"></a><span class="line-modified"> 561     if (!checkOperatorOverload(functionDefinition, m_intrinsics, m_program.nameContext())) {</span>
<span class="line-modified"> 562         setError();</span>
 563         return;
 564     }
 565 
<a name="71" id="anc71"></a><span class="line-modified"> 566     checkErrorAndVisit(functionDefinition);</span>
 567 }
 568 
<a name="72" id="anc72"></a><span class="line-modified"> 569 static Optional&lt;UniqueRef&lt;AST::UnnamedType&gt;&gt; matchAndCommit(ResolvingType&amp; left, ResolvingType&amp; right)</span>
 570 {
<a name="73" id="anc73"></a><span class="line-modified"> 571     return WTF::visit(WTF::makeVisitor([&amp;](UniqueRef&lt;AST::UnnamedType&gt;&amp; left) -&gt; Optional&lt;UniqueRef&lt;AST::UnnamedType&gt;&gt; {</span>
<span class="line-modified"> 572         return WTF::visit(WTF::makeVisitor([&amp;](UniqueRef&lt;AST::UnnamedType&gt;&amp; right) -&gt; Optional&lt;UniqueRef&lt;AST::UnnamedType&gt;&gt; {</span>
 573             if (matches(left, right))
<a name="74" id="anc74"></a><span class="line-modified"> 574                 return left-&gt;clone();</span>
<span class="line-modified"> 575             return WTF::nullopt;</span>
<span class="line-modified"> 576         }, [&amp;](Ref&lt;ResolvableTypeReference&gt;&amp; right) -&gt; Optional&lt;UniqueRef&lt;AST::UnnamedType&gt;&gt; {</span>
 577             return matchAndCommit(left, right-&gt;resolvableType());
<a name="75" id="anc75"></a><span class="line-modified"> 578         }), right);</span>
<span class="line-modified"> 579     }, [&amp;](Ref&lt;ResolvableTypeReference&gt;&amp; left) -&gt; Optional&lt;UniqueRef&lt;AST::UnnamedType&gt;&gt; {</span>
<span class="line-modified"> 580         return WTF::visit(WTF::makeVisitor([&amp;](UniqueRef&lt;AST::UnnamedType&gt;&amp; right) -&gt; Optional&lt;UniqueRef&lt;AST::UnnamedType&gt;&gt; {</span>
 581             return matchAndCommit(right, left-&gt;resolvableType());
<a name="76" id="anc76"></a><span class="line-modified"> 582         }, [&amp;](Ref&lt;ResolvableTypeReference&gt;&amp; right) -&gt; Optional&lt;UniqueRef&lt;AST::UnnamedType&gt;&gt; {</span>
 583             return matchAndCommit(left-&gt;resolvableType(), right-&gt;resolvableType());
<a name="77" id="anc77"></a><span class="line-modified"> 584         }), right);</span>
<span class="line-modified"> 585     }), left);</span>
 586 }
 587 
<a name="78" id="anc78"></a><span class="line-modified"> 588 static Optional&lt;UniqueRef&lt;AST::UnnamedType&gt;&gt; matchAndCommit(ResolvingType&amp; resolvingType, AST::UnnamedType&amp; unnamedType)</span>
 589 {
<a name="79" id="anc79"></a><span class="line-modified"> 590     return WTF::visit(WTF::makeVisitor([&amp;](UniqueRef&lt;AST::UnnamedType&gt;&amp; resolvingType) -&gt; Optional&lt;UniqueRef&lt;AST::UnnamedType&gt;&gt; {</span>
 591         if (matches(unnamedType, resolvingType))
<a name="80" id="anc80"></a><span class="line-modified"> 592             return unnamedType.clone();</span>
<span class="line-modified"> 593         return WTF::nullopt;</span>
<span class="line-modified"> 594     }, [&amp;](Ref&lt;ResolvableTypeReference&gt;&amp; resolvingType) -&gt; Optional&lt;UniqueRef&lt;AST::UnnamedType&gt;&gt; {</span>
 595         return matchAndCommit(unnamedType, resolvingType-&gt;resolvableType());
<a name="81" id="anc81"></a><span class="line-modified"> 596     }), resolvingType);</span>
 597 }
 598 
<a name="82" id="anc82"></a><span class="line-modified"> 599 static Optional&lt;UniqueRef&lt;AST::UnnamedType&gt;&gt; matchAndCommit(ResolvingType&amp; resolvingType, AST::NamedType&amp; namedType)</span>
 600 {
<a name="83" id="anc83"></a><span class="line-modified"> 601     return WTF::visit(WTF::makeVisitor([&amp;](UniqueRef&lt;AST::UnnamedType&gt;&amp; resolvingType) -&gt; Optional&lt;UniqueRef&lt;AST::UnnamedType&gt;&gt; {</span>
<span class="line-modified"> 602         if (matches(resolvingType, namedType))</span>
<span class="line-modified"> 603             return resolvingType-&gt;clone();</span>
<span class="line-modified"> 604         return WTF::nullopt;</span>
<span class="line-modified"> 605     }, [&amp;](Ref&lt;ResolvableTypeReference&gt;&amp; resolvingType) -&gt; Optional&lt;UniqueRef&lt;AST::UnnamedType&gt;&gt; {</span>
<span class="line-modified"> 606         return matchAndCommit(namedType, resolvingType-&gt;resolvableType());</span>
<span class="line-modified"> 607     }), resolvingType);</span>















































 608 }
 609 
 610 void Checker::visit(AST::EnumerationDefinition&amp; enumerationDefinition)
 611 {
<a name="84" id="anc84"></a>
 612     auto* baseType = ([&amp;]() -&gt; AST::NativeTypeDeclaration* {
 613         checkErrorAndVisit(enumerationDefinition.type());
 614         auto&amp; baseType = enumerationDefinition.type().unifyNode();
 615         if (!is&lt;AST::NamedType&gt;(baseType))
 616             return nullptr;
 617         auto&amp; namedType = downcast&lt;AST::NamedType&gt;(baseType);
 618         if (!is&lt;AST::NativeTypeDeclaration&gt;(namedType))
 619             return nullptr;
 620         auto&amp; nativeTypeDeclaration = downcast&lt;AST::NativeTypeDeclaration&gt;(namedType);
 621         if (!nativeTypeDeclaration.isInt())
 622             return nullptr;
<a name="85" id="anc85"></a>
 623         return &amp;nativeTypeDeclaration;
 624     })();
 625     if (!baseType) {
<a name="86" id="anc86"></a><span class="line-modified"> 626         setError();</span>
 627         return;
 628     }
 629 
 630     auto enumerationMembers = enumerationDefinition.enumerationMembers();
 631 
 632     for (auto&amp; member : enumerationMembers) {
<a name="87" id="anc87"></a><span class="line-modified"> 633         if (!member.get().value())</span>
<span class="line-modified"> 634             continue;</span>
<span class="line-modified"> 635 </span>
<span class="line-modified"> 636         bool success = false;</span>
<span class="line-removed"> 637         member.get().value()-&gt;visit(WTF::makeVisitor([&amp;](AST::Expression&amp; value) {</span>
<span class="line-removed"> 638             auto valueInfo = recurseAndGetInfo(value);</span>
<span class="line-removed"> 639             if (!valueInfo)</span>
 640                 return;
<a name="88" id="anc88"></a><span class="line-modified"> 641             success = static_cast&lt;bool&gt;(matchAndCommit(valueInfo-&gt;resolvingType, *baseType));</span>
<span class="line-removed"> 642         }));</span>
<span class="line-removed"> 643         if (!success) {</span>
<span class="line-removed"> 644             setError();</span>
<span class="line-removed"> 645             return;</span>
<span class="line-removed"> 646         }</span>
<span class="line-removed"> 647     }</span>
<span class="line-removed"> 648 </span>
<span class="line-removed"> 649     int64_t nextValue = 0;</span>
<span class="line-removed"> 650     for (auto&amp; member : enumerationMembers) {</span>
<span class="line-removed"> 651         if (member.get().value()) {</span>
<span class="line-removed"> 652             int64_t value;</span>
<span class="line-removed"> 653             member.get().value()-&gt;visit(WTF::makeVisitor([&amp;](AST::IntegerLiteral&amp; integerLiteral) {</span>
<span class="line-removed"> 654                 value = integerLiteral.valueForSelectedType();</span>
<span class="line-removed"> 655             }, [&amp;](AST::UnsignedIntegerLiteral&amp; unsignedIntegerLiteral) {</span>
<span class="line-removed"> 656                 value = unsignedIntegerLiteral.valueForSelectedType();</span>
<span class="line-removed"> 657             }, [&amp;](auto&amp;) {</span>
<span class="line-removed"> 658                 ASSERT_NOT_REACHED();</span>
<span class="line-removed"> 659             }));</span>
<span class="line-removed"> 660             nextValue = baseType-&gt;successor()(value);</span>
 661         } else {
<a name="89" id="anc89"></a><span class="line-modified"> 662             if (nextValue &gt; std::numeric_limits&lt;int&gt;::max()) {</span>
<span class="line-modified"> 663                 ASSERT(nextValue &lt;= std::numeric_limits&lt;unsigned&gt;::max());</span>
<span class="line-modified"> 664                 member.get().setValue(AST::ConstantExpression(AST::UnsignedIntegerLiteral(Lexer::Token(member.get().origin()), static_cast&lt;unsigned&gt;(nextValue))));</span>
 665             }
<a name="90" id="anc90"></a><span class="line-removed"> 666             ASSERT(nextValue &gt;= std::numeric_limits&lt;int&gt;::min());</span>
<span class="line-removed"> 667             member.get().setValue(AST::ConstantExpression(AST::IntegerLiteral(Lexer::Token(member.get().origin()), static_cast&lt;int&gt;(nextValue))));</span>
<span class="line-removed"> 668             nextValue = baseType-&gt;successor()(nextValue);</span>
 669         }
 670     }
 671 
<a name="91" id="anc91"></a><span class="line-removed"> 672     auto getValue = [&amp;](AST::EnumerationMember&amp; member) -&gt; int64_t {</span>
<span class="line-removed"> 673         int64_t value;</span>
<span class="line-removed"> 674         ASSERT(member.value());</span>
<span class="line-removed"> 675         member.value()-&gt;visit(WTF::makeVisitor([&amp;](AST::IntegerLiteral&amp; integerLiteral) {</span>
<span class="line-removed"> 676             value = integerLiteral.value();</span>
<span class="line-removed"> 677         }, [&amp;](AST::UnsignedIntegerLiteral&amp; unsignedIntegerLiteral) {</span>
<span class="line-removed"> 678             value = unsignedIntegerLiteral.value();</span>
<span class="line-removed"> 679         }, [&amp;](auto&amp;) {</span>
<span class="line-removed"> 680             ASSERT_NOT_REACHED();</span>
<span class="line-removed"> 681         }));</span>
<span class="line-removed"> 682         return value;</span>
<span class="line-removed"> 683     };</span>
<span class="line-removed"> 684 </span>
 685     for (size_t i = 0; i &lt; enumerationMembers.size(); ++i) {
<a name="92" id="anc92"></a><span class="line-modified"> 686         auto value = getValue(enumerationMembers[i].get());</span>
 687         for (size_t j = i + 1; j &lt; enumerationMembers.size(); ++j) {
<a name="93" id="anc93"></a><span class="line-modified"> 688             auto otherValue = getValue(enumerationMembers[j].get());</span>
 689             if (value == otherValue) {
<a name="94" id="anc94"></a><span class="line-modified"> 690                 setError();</span>
 691                 return;
 692             }
 693         }
 694     }
 695 
 696     bool foundZero = false;
 697     for (auto&amp; member : enumerationMembers) {
<a name="95" id="anc95"></a><span class="line-modified"> 698         if (!getValue(member.get())) {</span>
 699             foundZero = true;
 700             break;
 701         }
 702     }
 703     if (!foundZero) {
<a name="96" id="anc96"></a><span class="line-modified"> 704         setError();</span>
 705         return;
 706     }
 707 }
 708 
 709 void Checker::visit(AST::TypeReference&amp; typeReference)
 710 {
<a name="97" id="anc97"></a><span class="line-modified"> 711     ASSERT(typeReference.resolvedType());</span>
 712 
<a name="98" id="anc98"></a><span class="line-modified"> 713     checkErrorAndVisit(typeReference);</span>

 714 }
 715 
<a name="99" id="anc99"></a><span class="line-modified"> 716 auto Checker::recurseAndGetInfo(AST::Expression&amp; expression, bool requiresLValue) -&gt; Optional&lt;RecurseInfo&gt;</span>
 717 {
<a name="100" id="anc100"></a><span class="line-modified"> 718     checkErrorAndVisit(expression);</span>
<span class="line-modified"> 719     if (!error())</span>
 720         return WTF::nullopt;
<a name="101" id="anc101"></a><span class="line-modified"> 721     return getInfo(expression, requiresLValue);</span>
 722 }
 723 
<a name="102" id="anc102"></a><span class="line-modified"> 724 auto Checker::getInfo(AST::Expression&amp; expression, bool requiresLValue) -&gt; Optional&lt;RecurseInfo&gt;</span>
 725 {
 726     auto typeIterator = m_typeMap.find(&amp;expression);
 727     ASSERT(typeIterator != m_typeMap.end());
 728 
<a name="103" id="anc103"></a><span class="line-modified"> 729     auto addressSpaceIterator = m_addressSpaceMap.find(&amp;expression);</span>
<span class="line-modified"> 730     ASSERT(addressSpaceIterator != m_addressSpaceMap.end());</span>
<span class="line-modified"> 731     if (requiresLValue &amp;&amp; !addressSpaceIterator-&gt;value) {</span>
<span class="line-removed"> 732         setError();</span>
 733         return WTF::nullopt;
 734     }
<a name="104" id="anc104"></a><span class="line-modified"> 735     return {{ typeIterator-&gt;value, addressSpaceIterator-&gt;value }};</span>
 736 }
 737 
 738 void Checker::visit(AST::VariableDeclaration&amp; variableDeclaration)
 739 {
 740     // ReadModifyWriteExpressions are the only place where anonymous variables exist,
 741     // and that doesn&#39;t recurse on the anonymous variables, so we can assume the variable has a type.
 742     checkErrorAndVisit(*variableDeclaration.type());
<a name="105" id="anc105"></a>



 743     if (variableDeclaration.initializer()) {
 744         auto&amp; lhsType = *variableDeclaration.type();
 745         auto initializerInfo = recurseAndGetInfo(*variableDeclaration.initializer());
 746         if (!initializerInfo)
 747             return;
 748         if (!matchAndCommit(initializerInfo-&gt;resolvingType, lhsType)) {
<a name="106" id="anc106"></a><span class="line-modified"> 749             setError();</span>
 750             return;
 751         }
 752     }
 753 }
 754 
<a name="107" id="anc107"></a><span class="line-modified"> 755 void Checker::assignType(AST::Expression&amp; expression, UniqueRef&lt;AST::UnnamedType&gt;&amp;&amp; unnamedType, Optional&lt;AST::AddressSpace&gt; addressSpace)</span>
 756 {
<a name="108" id="anc108"></a><span class="line-modified"> 757     auto addResult = m_typeMap.add(&amp;expression, WTFMove(unnamedType));</span>
 758     ASSERT_UNUSED(addResult, addResult.isNewEntry);
<a name="109" id="anc109"></a><span class="line-modified"> 759     auto addressSpaceAddResult = m_addressSpaceMap.add(&amp;expression, addressSpace);</span>
<span class="line-removed"> 760     ASSERT_UNUSED(addressSpaceAddResult, addressSpaceAddResult.isNewEntry);</span>
 761 }
 762 
<a name="110" id="anc110"></a><span class="line-modified"> 763 void Checker::assignType(AST::Expression&amp; expression, Ref&lt;ResolvableTypeReference&gt;&amp;&amp; resolvableTypeReference, Optional&lt;AST::AddressSpace&gt; addressSpace)</span>
 764 {
<a name="111" id="anc111"></a><span class="line-modified"> 765     auto addResult = m_typeMap.add(&amp;expression, WTFMove(resolvableTypeReference));</span>
 766     ASSERT_UNUSED(addResult, addResult.isNewEntry);
<a name="112" id="anc112"></a><span class="line-modified"> 767     auto addressSpaceAddResult = m_addressSpaceMap.add(&amp;expression, addressSpace);</span>
<span class="line-modified"> 768     ASSERT_UNUSED(addressSpaceAddResult, addressSpaceAddResult.isNewEntry);</span>











 769 }
 770 
 771 void Checker::visit(AST::AssignmentExpression&amp; assignmentExpression)
 772 {
 773     auto leftInfo = recurseAndGetInfo(assignmentExpression.left(), true);
 774     if (!leftInfo)
 775         return;
 776 
 777     auto rightInfo = recurseAndGetInfo(assignmentExpression.right());
 778     if (!rightInfo)
 779         return;
 780 
 781     auto resultType = matchAndCommit(leftInfo-&gt;resolvingType, rightInfo-&gt;resolvingType);
 782     if (!resultType) {
<a name="113" id="anc113"></a><span class="line-modified"> 783         setError();</span>
 784         return;
 785     }
 786 
<a name="114" id="anc114"></a><span class="line-modified"> 787     assignType(assignmentExpression, WTFMove(*resultType));</span>
<span class="line-removed"> 788 }</span>
<span class="line-removed"> 789 </span>
<span class="line-removed"> 790 void Checker::forwardType(AST::Expression&amp; expression, ResolvingType&amp; resolvingType, Optional&lt;AST::AddressSpace&gt; addressSpace)</span>
<span class="line-removed"> 791 {</span>
<span class="line-removed"> 792     WTF::visit(WTF::makeVisitor([&amp;](UniqueRef&lt;AST::UnnamedType&gt;&amp; result) {</span>
<span class="line-removed"> 793         auto addResult = m_typeMap.add(&amp;expression, result-&gt;clone());</span>
<span class="line-removed"> 794         ASSERT_UNUSED(addResult, addResult.isNewEntry);</span>
<span class="line-removed"> 795     }, [&amp;](Ref&lt;ResolvableTypeReference&gt;&amp; result) {</span>
<span class="line-removed"> 796         auto addResult = m_typeMap.add(&amp;expression, result.copyRef());</span>
<span class="line-removed"> 797         ASSERT_UNUSED(addResult, addResult.isNewEntry);</span>
<span class="line-removed"> 798     }), resolvingType);</span>
<span class="line-removed"> 799     auto addressSpaceAddResult = m_addressSpaceMap.add(&amp;expression, addressSpace);</span>
<span class="line-removed"> 800     ASSERT_UNUSED(addressSpaceAddResult, addressSpaceAddResult.isNewEntry);</span>
 801 }
 802 
 803 void Checker::visit(AST::ReadModifyWriteExpression&amp; readModifyWriteExpression)
 804 {
<a name="115" id="anc115"></a><span class="line-modified"> 805     auto lValueInfo = recurseAndGetInfo(readModifyWriteExpression.lValue(), true);</span>
<span class="line-modified"> 806     if (!lValueInfo)</span>
 807         return;
 808 
<a name="116" id="anc116"></a><span class="line-modified"> 809     // FIXME: Figure out what to do with the ReadModifyWriteExpression&#39;s AnonymousVariables.</span>
 810 
<a name="117" id="anc117"></a><span class="line-modified"> 811     auto newValueInfo = recurseAndGetInfo(*readModifyWriteExpression.newValueExpression());</span>
 812     if (!newValueInfo)
 813         return;
 814 
<a name="118" id="anc118"></a><span class="line-modified"> 815     if (!matchAndCommit(lValueInfo-&gt;resolvingType, newValueInfo-&gt;resolvingType)) {</span>
<span class="line-modified"> 816         setError();</span>


 817         return;
 818     }
 819 
<a name="119" id="anc119"></a><span class="line-modified"> 820     auto resultInfo = recurseAndGetInfo(*readModifyWriteExpression.resultExpression());</span>
 821     if (!resultInfo)
 822         return;
 823 
 824     forwardType(readModifyWriteExpression, resultInfo-&gt;resolvingType);
 825 }
 826 
 827 static AST::UnnamedType* getUnnamedType(ResolvingType&amp; resolvingType)
 828 {
<a name="120" id="anc120"></a><span class="line-modified"> 829     return WTF::visit(WTF::makeVisitor([](UniqueRef&lt;AST::UnnamedType&gt;&amp; type) -&gt; AST::UnnamedType* {</span>
<span class="line-modified"> 830         return &amp;type;</span>
<span class="line-modified"> 831     }, [](Ref&lt;ResolvableTypeReference&gt;&amp; type) -&gt; AST::UnnamedType* {</span>
 832         // FIXME: If the type isn&#39;t committed, should we just commit() it now?
<a name="121" id="anc121"></a><span class="line-modified"> 833         return type-&gt;resolvableType().resolvedType();</span>
<span class="line-modified"> 834     }), resolvingType);</span>
 835 }
 836 
 837 void Checker::visit(AST::DereferenceExpression&amp; dereferenceExpression)
 838 {
 839     auto pointerInfo = recurseAndGetInfo(dereferenceExpression.pointer());
 840     if (!pointerInfo)
 841         return;
 842 
 843     auto* unnamedType = getUnnamedType(pointerInfo-&gt;resolvingType);
 844 
 845     auto* pointerType = ([&amp;](AST::UnnamedType* unnamedType) -&gt; AST::PointerType* {
 846         if (!unnamedType)
 847             return nullptr;
 848         auto&amp; unifyNode = unnamedType-&gt;unifyNode();
 849         if (!is&lt;AST::UnnamedType&gt;(unifyNode))
 850             return nullptr;
 851         auto&amp; unnamedUnifyType = downcast&lt;AST::UnnamedType&gt;(unifyNode);
 852         if (!is&lt;AST::PointerType&gt;(unnamedUnifyType))
 853             return nullptr;
 854         return &amp;downcast&lt;AST::PointerType&gt;(unnamedUnifyType);
 855     })(unnamedType);
 856     if (!pointerType) {
<a name="122" id="anc122"></a><span class="line-modified"> 857         setError();</span>
 858         return;
 859     }
 860 
<a name="123" id="anc123"></a><span class="line-modified"> 861     assignType(dereferenceExpression, pointerType-&gt;clone(), pointerType-&gt;addressSpace());</span>
 862 }
 863 
 864 void Checker::visit(AST::MakePointerExpression&amp; makePointerExpression)
 865 {
<a name="124" id="anc124"></a><span class="line-modified"> 866     auto lValueInfo = recurseAndGetInfo(makePointerExpression.lValue(), true);</span>
<span class="line-modified"> 867     if (!lValueInfo)</span>
 868         return;
 869 
<a name="125" id="anc125"></a><span class="line-modified"> 870     auto* lValueType = getUnnamedType(lValueInfo-&gt;resolvingType);</span>
<span class="line-modified"> 871     if (!lValueType) {</span>
<span class="line-modified"> 872         setError();</span>
 873         return;
 874     }
 875 
<a name="126" id="anc126"></a><span class="line-modified"> 876     assignType(makePointerExpression, makeUniqueRef&lt;AST::PointerType&gt;(Lexer::Token(makePointerExpression.origin()), *lValueInfo-&gt;addressSpace, lValueType-&gt;clone()));</span>






 877 }
 878 
 879 void Checker::visit(AST::MakeArrayReferenceExpression&amp; makeArrayReferenceExpression)
 880 {
<a name="127" id="anc127"></a><span class="line-modified"> 881     auto lValueInfo = recurseAndGetInfo(makeArrayReferenceExpression.lValue());</span>
<span class="line-modified"> 882     if (!lValueInfo)</span>
 883         return;
 884 
<a name="128" id="anc128"></a><span class="line-modified"> 885     auto* lValueType = getUnnamedType(lValueInfo-&gt;resolvingType);</span>
<span class="line-modified"> 886     if (!lValueType) {</span>
<span class="line-modified"> 887         setError();</span>
 888         return;
 889     }
 890 
<a name="129" id="anc129"></a><span class="line-modified"> 891     auto&amp; unifyNode = lValueType-&gt;unifyNode();</span>
 892     if (is&lt;AST::UnnamedType&gt;(unifyNode)) {
 893         auto&amp; unnamedType = downcast&lt;AST::UnnamedType&gt;(unifyNode);
 894         if (is&lt;AST::PointerType&gt;(unnamedType)) {
 895             auto&amp; pointerType = downcast&lt;AST::PointerType&gt;(unnamedType);
<a name="130" id="anc130"></a><span class="line-modified"> 896             // FIXME: Save the fact that we&#39;re not targetting the item; we&#39;re targetting the item&#39;s inner element.</span>
<span class="line-modified"> 897             assignType(makeArrayReferenceExpression, makeUniqueRef&lt;AST::ArrayReferenceType&gt;(Lexer::Token(makeArrayReferenceExpression.origin()), pointerType.addressSpace(), pointerType.elementType().clone()));</span>
 898             return;
 899         }
 900 
<a name="131" id="anc131"></a><span class="line-modified"> 901         if (!lValueInfo-&gt;addressSpace) {</span>
<span class="line-modified"> 902             setError();</span>

 903             return;
 904         }
 905 
 906         if (is&lt;AST::ArrayType&gt;(unnamedType)) {
 907             auto&amp; arrayType = downcast&lt;AST::ArrayType&gt;(unnamedType);
<a name="132" id="anc132"></a><span class="line-modified"> 908             // FIXME: Save the number of elements.</span>
<span class="line-modified"> 909             assignType(makeArrayReferenceExpression, makeUniqueRef&lt;AST::ArrayReferenceType&gt;(Lexer::Token(makeArrayReferenceExpression.origin()), *lValueInfo-&gt;addressSpace, arrayType.type().clone()));</span>
 910             return;
 911         }
 912     }
 913 
<a name="133" id="anc133"></a><span class="line-modified"> 914     if (!lValueInfo-&gt;addressSpace) {</span>
<span class="line-modified"> 915         setError();</span>

 916         return;
 917     }
 918 
<a name="134" id="anc134"></a><span class="line-modified"> 919     assignType(makeArrayReferenceExpression, makeUniqueRef&lt;AST::ArrayReferenceType&gt;(Lexer::Token(makeArrayReferenceExpression.origin()), *lValueInfo-&gt;addressSpace, lValueType-&gt;clone()));</span>
 920 }
 921 
<a name="135" id="anc135"></a><span class="line-modified"> 922 void Checker::finishVisitingPropertyAccess(AST::PropertyAccessExpression&amp; propertyAccessExpression, AST::UnnamedType&amp; wrappedBaseType, AST::UnnamedType* extraArgumentType)</span>
 923 {
<a name="136" id="anc136"></a><span class="line-modified"> 924     Optional&lt;std::reference_wrapper&lt;AST::NamedType&gt;&gt; castReturnType;</span>
<span class="line-modified"> 925     using OverloadResolution = std::tuple&lt;AST::FunctionDeclaration*, AST::UnnamedType*&gt;;</span>
<span class="line-modified"> 926 </span>
<span class="line-modified"> 927     AST::FunctionDeclaration* getFunction;</span>
<span class="line-modified"> 928     AST::UnnamedType* getReturnType;</span>
<span class="line-modified"> 929     std::tie(getFunction, getReturnType) = ([&amp;]() -&gt; OverloadResolution {</span>
<span class="line-removed"> 930         ResolvingType getArgumentType1(wrappedBaseType.clone());</span>
<span class="line-removed"> 931         Optional&lt;ResolvingType&gt; getArgumentType2;</span>
<span class="line-removed"> 932         if (extraArgumentType)</span>
<span class="line-removed"> 933             getArgumentType2 = ResolvingType(extraArgumentType-&gt;clone());</span>
<span class="line-removed"> 934 </span>
<span class="line-removed"> 935         Vector&lt;std::reference_wrapper&lt;ResolvingType&gt;&gt; getArgumentTypes;</span>
<span class="line-removed"> 936         getArgumentTypes.append(getArgumentType1);</span>
<span class="line-removed"> 937         if (getArgumentType2)</span>
<span class="line-removed"> 938             getArgumentTypes.append(*getArgumentType2);</span>
<span class="line-removed"> 939 </span>
<span class="line-removed"> 940         auto* getFunction = resolveFunctionOverloadImpl(propertyAccessExpression.possibleGetOverloads(), getArgumentTypes, castReturnType);</span>
<span class="line-removed"> 941         if (!getFunction)</span>
<span class="line-removed"> 942             return std::make_pair(nullptr, nullptr);</span>
<span class="line-removed"> 943         return std::make_pair(getFunction, &amp;getFunction-&gt;type());</span>
<span class="line-removed"> 944     })();</span>
 945 
<a name="137" id="anc137"></a><span class="line-modified"> 946     AST::FunctionDeclaration* andFunction;</span>
<span class="line-modified"> 947     AST::UnnamedType* andReturnType;</span>
<span class="line-modified"> 948     std::tie(andFunction, andReturnType) = ([&amp;]() -&gt; OverloadResolution {</span>
<span class="line-modified"> 949         auto computeAndArgumentType = [&amp;](AST::UnnamedType&amp; unnamedType) -&gt; Optional&lt;ResolvingType&gt; {</span>
<span class="line-modified"> 950             if (is&lt;AST::ArrayReferenceType&gt;(unnamedType))</span>
<span class="line-modified"> 951                 return { unnamedType.clone() };</span>
<span class="line-modified"> 952             if (is&lt;AST::ArrayType&gt;(unnamedType))</span>
<span class="line-modified"> 953                 return { makeUniqueRef&lt;AST::ArrayReferenceType&gt;(Lexer::Token(propertyAccessExpression.origin()), AST::AddressSpace::Thread, downcast&lt;AST::ArrayType&gt;(unnamedType).type().clone()) };</span>
<span class="line-modified"> 954             if (is&lt;AST::PointerType&gt;(unnamedType))</span>
<span class="line-modified"> 955                 return WTF::nullopt;</span>
<span class="line-modified"> 956             return { makeUniqueRef&lt;AST::PointerType&gt;(Lexer::Token(propertyAccessExpression.origin()), AST::AddressSpace::Thread, downcast&lt;AST::ArrayType&gt;(unnamedType).type().clone()) };</span>
<span class="line-modified"> 957         };</span>
<span class="line-modified"> 958         auto computeAndReturnType = [&amp;](AST::UnnamedType&amp; unnamedType) -&gt; AST::UnnamedType* {</span>
<span class="line-modified"> 959             if (is&lt;AST::PointerType&gt;(unnamedType))</span>
<span class="line-modified"> 960                 return &amp;downcast&lt;AST::PointerType&gt;(unnamedType).elementType();</span>

 961             return nullptr;
<a name="138" id="anc138"></a><span class="line-removed"> 962         };</span>
 963 
<a name="139" id="anc139"></a><span class="line-modified"> 964         auto andArgumentType1 = computeAndArgumentType(wrappedBaseType);</span>
<span class="line-modified"> 965         if (!andArgumentType1)</span>
<span class="line-removed"> 966             return std::make_pair(nullptr, nullptr);</span>
<span class="line-removed"> 967         Optional&lt;ResolvingType&gt; andArgumentType2;</span>
<span class="line-removed"> 968         if (extraArgumentType)</span>
<span class="line-removed"> 969             andArgumentType2 = ResolvingType(extraArgumentType-&gt;clone());</span>
<span class="line-removed"> 970 </span>
<span class="line-removed"> 971         Vector&lt;std::reference_wrapper&lt;ResolvingType&gt;&gt; andArgumentTypes;</span>
<span class="line-removed"> 972         andArgumentTypes.append(*andArgumentType1);</span>
<span class="line-removed"> 973         if (andArgumentType2)</span>
<span class="line-removed"> 974             andArgumentTypes.append(*andArgumentType2);</span>
<span class="line-removed"> 975 </span>
<span class="line-removed"> 976         auto* andFunction = resolveFunctionOverloadImpl(propertyAccessExpression.possibleAndOverloads(), andArgumentTypes, castReturnType);</span>
<span class="line-removed"> 977         if (!andFunction)</span>
<span class="line-removed"> 978             return std::make_pair(nullptr, nullptr);</span>
<span class="line-removed"> 979         return std::make_pair(andFunction, computeAndReturnType(andFunction-&gt;type()));</span>
<span class="line-removed"> 980     })();</span>
 981 
<a name="140" id="anc140"></a><span class="line-modified"> 982     if (!getReturnType &amp;&amp; !andReturnType) {</span>
<span class="line-modified"> 983         setError();</span>
<span class="line-modified"> 984         return;</span>
<span class="line-modified"> 985     }</span>
 986 
<a name="141" id="anc141"></a><span class="line-modified"> 987     if (getReturnType &amp;&amp; andReturnType &amp;&amp; !matches(*getReturnType, *andReturnType)) {</span>
<span class="line-modified"> 988         setError();</span>






 989         return;
 990     }
 991 
<a name="142" id="anc142"></a><span class="line-modified"> 992     AST::FunctionDeclaration* setFunction;</span>
<span class="line-modified"> 993     AST::UnnamedType* setReturnType;</span>
<span class="line-modified"> 994     std::tie(setFunction, setReturnType) = ([&amp;]() -&gt; OverloadResolution {</span>
<span class="line-modified"> 995         ResolvingType setArgument1Type(wrappedBaseType.clone());</span>
<span class="line-modified"> 996         Optional&lt;ResolvingType&gt; setArgumentType2;</span>
<span class="line-modified"> 997         if (extraArgumentType)</span>
<span class="line-modified"> 998             setArgumentType2 = ResolvingType(extraArgumentType-&gt;clone());</span>
<span class="line-modified"> 999         ResolvingType setArgument3Type(getReturnType ? getReturnType-&gt;clone() : andReturnType-&gt;clone());</span>
<span class="line-modified">1000 </span>
<span class="line-removed">1001         Vector&lt;std::reference_wrapper&lt;ResolvingType&gt;&gt; setArgumentTypes;</span>
<span class="line-removed">1002         setArgumentTypes.append(setArgument1Type);</span>
<span class="line-removed">1003         if (setArgumentType2)</span>
<span class="line-removed">1004             setArgumentTypes.append(*setArgumentType2);</span>
<span class="line-removed">1005         setArgumentTypes.append(setArgument3Type);</span>
<span class="line-removed">1006 </span>
<span class="line-removed">1007         auto* setFunction = resolveFunctionOverloadImpl(propertyAccessExpression.possibleSetOverloads(), setArgumentTypes, castReturnType);</span>
<span class="line-removed">1008         if (!setFunction)</span>
<span class="line-removed">1009             return std::make_pair(nullptr, nullptr);</span>
<span class="line-removed">1010         return std::make_pair(setFunction, &amp;setFunction-&gt;type());</span>
<span class="line-removed">1011     })();</span>
<span class="line-removed">1012 </span>
<span class="line-removed">1013     if (setFunction) {</span>
<span class="line-removed">1014         if (!matches(setFunction-&gt;type(), wrappedBaseType)) {</span>
<span class="line-removed">1015             setError();</span>
1016             return;
<a name="143" id="anc143"></a><span class="line-modified">1017         }</span>

1018     }
1019 
<a name="144" id="anc144"></a><span class="line-modified">1020     Optional&lt;AST::AddressSpace&gt; addressSpace;</span>
<span class="line-modified">1021     if (getReturnType || andReturnType) {</span>
<span class="line-modified">1022         // FIXME: The reference compiler has &quot;else if (!node.base.isLValue &amp;&amp; !baseType.isArrayRef)&quot;,</span>
<span class="line-modified">1023         // but I don&#39;t understand why it exists. I haven&#39;t written it here, and I&#39;ll investigate</span>
<span class="line-modified">1024         // if we can remove it from the reference compiler.</span>
<span class="line-modified">1025         if (is&lt;AST::ReferenceType&gt;(wrappedBaseType))</span>
<span class="line-modified">1026             addressSpace = downcast&lt;AST::ReferenceType&gt;(wrappedBaseType).addressSpace();</span>
<span class="line-modified">1027         else {</span>
<span class="line-modified">1028             auto addressSpaceIterator = m_addressSpaceMap.find(&amp;propertyAccessExpression.base());</span>
<span class="line-modified">1029             ASSERT(addressSpaceIterator != m_addressSpaceMap.end());</span>
<span class="line-modified">1030             if (addressSpaceIterator-&gt;value)</span>
<span class="line-modified">1031                 addressSpace = *addressSpaceIterator-&gt;value;</span>
<span class="line-removed">1032             else {</span>
<span class="line-removed">1033                 setError();</span>
1034                 return;
<a name="145" id="anc145"></a><span class="line-modified">1035             }</span>

1036         }
1037     }
1038 
<a name="146" id="anc146"></a><span class="line-modified">1039     // FIXME: Generate the call expressions</span>
<span class="line-modified">1040 </span>
<span class="line-modified">1041     assignType(propertyAccessExpression, getReturnType ? getReturnType-&gt;clone() : andReturnType-&gt;clone(), addressSpace);</span>
<span class="line-modified">1042 }</span>










1043 
<a name="147" id="anc147"></a><span class="line-modified">1044 Optional&lt;UniqueRef&lt;AST::UnnamedType&gt;&gt; Checker::recurseAndWrapBaseType(AST::PropertyAccessExpression&amp; propertyAccessExpression)</span>
<span class="line-modified">1045 {</span>
<span class="line-modified">1046     auto baseInfo = recurseAndGetInfo(propertyAccessExpression.base());</span>
<span class="line-modified">1047     if (!baseInfo)</span>
<span class="line-removed">1048         return WTF::nullopt;</span>
1049 
<a name="148" id="anc148"></a><span class="line-modified">1050     auto* baseType = getUnnamedType(baseInfo-&gt;resolvingType);</span>
<span class="line-modified">1051     if (!baseType) {</span>
<span class="line-modified">1052         setError();</span>
<span class="line-removed">1053         return WTF::nullopt;</span>
1054     }
<a name="149" id="anc149"></a><span class="line-removed">1055     auto&amp; baseUnifyNode = baseType-&gt;unifyNode();</span>
<span class="line-removed">1056     if (is&lt;AST::UnnamedType&gt;(baseUnifyNode))</span>
<span class="line-removed">1057         return downcast&lt;AST::UnnamedType&gt;(baseUnifyNode).clone();</span>
<span class="line-removed">1058     ASSERT(is&lt;AST::NamedType&gt;(baseUnifyNode));</span>
<span class="line-removed">1059     return { AST::TypeReference::wrap(Lexer::Token(propertyAccessExpression.origin()), downcast&lt;AST::NamedType&gt;(baseUnifyNode)) };</span>
<span class="line-removed">1060 }</span>
1061 
<a name="150" id="anc150"></a><span class="line-modified">1062 void Checker::visit(AST::DotExpression&amp; dotExpression)</span>
<span class="line-modified">1063 {</span>
<span class="line-removed">1064     auto baseType = recurseAndWrapBaseType(dotExpression);</span>
<span class="line-removed">1065     if (!baseType)</span>
1066         return;
<a name="151" id="anc151"></a>
1067 
<a name="152" id="anc152"></a><span class="line-modified">1068     finishVisitingPropertyAccess(dotExpression, *baseType);</span>
<span class="line-modified">1069 }</span>


1070 
<a name="153" id="anc153"></a><span class="line-modified">1071 void Checker::visit(AST::IndexExpression&amp; indexExpression)</span>
<span class="line-modified">1072 {</span>
<span class="line-removed">1073     auto baseType = recurseAndWrapBaseType(indexExpression);</span>
<span class="line-removed">1074     if (!baseType)</span>
1075         return;
<a name="154" id="anc154"></a>
1076 
<a name="155" id="anc155"></a><span class="line-modified">1077     auto indexInfo = recurseAndGetInfo(indexExpression.indexExpression());</span>
<span class="line-modified">1078     if (!indexInfo)</span>
1079         return;
<a name="156" id="anc156"></a><span class="line-modified">1080     auto indexExpressionType = getUnnamedType(indexInfo-&gt;resolvingType);</span>
<span class="line-modified">1081     if (!indexExpressionType) {</span>
<span class="line-modified">1082         setError();</span>



















1083         return;
1084     }
1085 
<a name="157" id="anc157"></a><span class="line-modified">1086     finishVisitingPropertyAccess(indexExpression, WTFMove(*baseType), indexExpressionType);</span>


























1087 }
1088 
1089 void Checker::visit(AST::VariableReference&amp; variableReference)
1090 {
1091     ASSERT(variableReference.variable());
1092     ASSERT(variableReference.variable()-&gt;type());
1093 
<a name="158" id="anc158"></a><span class="line-modified">1094     Optional&lt;AST::AddressSpace&gt; addressSpace;</span>
<span class="line-removed">1095     if (!variableReference.variable()-&gt;isAnonymous())</span>
<span class="line-removed">1096         addressSpace = AST::AddressSpace::Thread;</span>
<span class="line-removed">1097     assignType(variableReference, variableReference.variable()-&gt;type()-&gt;clone(), addressSpace);</span>
1098 }
1099 
1100 void Checker::visit(AST::Return&amp; returnStatement)
1101 {
<a name="159" id="anc159"></a><span class="line-removed">1102     ASSERT(returnStatement.function());</span>
1103     if (returnStatement.value()) {
1104         auto valueInfo = recurseAndGetInfo(*returnStatement.value());
1105         if (!valueInfo)
1106             return;
<a name="160" id="anc160"></a><span class="line-modified">1107         if (!matchAndCommit(valueInfo-&gt;resolvingType, returnStatement.function()-&gt;type()))</span>
<span class="line-modified">1108             setError();</span>
1109         return;
1110     }
1111 
<a name="161" id="anc161"></a><span class="line-modified">1112     if (!matches(returnStatement.function()-&gt;type(), m_intrinsics.voidType()))</span>
<span class="line-modified">1113         setError();</span>
1114 }
1115 
1116 void Checker::visit(AST::PointerType&amp;)
1117 {
1118     // Following pointer types can cause infinite loops because of data structures
1119     // like linked lists.
1120     // FIXME: Make sure this function should be empty
1121 }
1122 
1123 void Checker::visit(AST::ArrayReferenceType&amp;)
1124 {
1125     // Following array reference types can cause infinite loops because of data
1126     // structures like linked lists.
1127     // FIXME: Make sure this function should be empty
1128 }
1129 
1130 void Checker::visit(AST::IntegerLiteral&amp; integerLiteral)
1131 {
1132     assignType(integerLiteral, adoptRef(*new ResolvableTypeReference(integerLiteral.type())));
1133 }
1134 
1135 void Checker::visit(AST::UnsignedIntegerLiteral&amp; unsignedIntegerLiteral)
1136 {
1137     assignType(unsignedIntegerLiteral, adoptRef(*new ResolvableTypeReference(unsignedIntegerLiteral.type())));
1138 }
1139 
1140 void Checker::visit(AST::FloatLiteral&amp; floatLiteral)
1141 {
1142     assignType(floatLiteral, adoptRef(*new ResolvableTypeReference(floatLiteral.type())));
1143 }
1144 
1145 void Checker::visit(AST::NullLiteral&amp; nullLiteral)
1146 {
1147     assignType(nullLiteral, adoptRef(*new ResolvableTypeReference(nullLiteral.type())));
1148 }
1149 
1150 void Checker::visit(AST::BooleanLiteral&amp; booleanLiteral)
1151 {
<a name="162" id="anc162"></a><span class="line-modified">1152     assignType(booleanLiteral, AST::TypeReference::wrap(Lexer::Token(booleanLiteral.origin()), m_intrinsics.boolType()));</span>
1153 }
1154 
1155 void Checker::visit(AST::EnumerationMemberLiteral&amp; enumerationMemberLiteral)
1156 {
1157     ASSERT(enumerationMemberLiteral.enumerationDefinition());
1158     auto&amp; enumerationDefinition = *enumerationMemberLiteral.enumerationDefinition();
<a name="163" id="anc163"></a><span class="line-modified">1159     assignType(enumerationMemberLiteral, AST::TypeReference::wrap(Lexer::Token(enumerationMemberLiteral.origin()), enumerationDefinition));</span>
1160 }
1161 
1162 bool Checker::isBoolType(ResolvingType&amp; resolvingType)
1163 {
<a name="164" id="anc164"></a><span class="line-modified">1164     return WTF::visit(WTF::makeVisitor([&amp;](UniqueRef&lt;AST::UnnamedType&gt;&amp; left) -&gt; bool {</span>
1165         return matches(left, m_intrinsics.boolType());
<a name="165" id="anc165"></a><span class="line-modified">1166     }, [&amp;](Ref&lt;ResolvableTypeReference&gt;&amp; left) -&gt; bool {</span>
1167         return static_cast&lt;bool&gt;(matchAndCommit(m_intrinsics.boolType(), left-&gt;resolvableType()));
<a name="166" id="anc166"></a><span class="line-modified">1168     }), resolvingType);</span>
1169 }
1170 
1171 bool Checker::recurseAndRequireBoolType(AST::Expression&amp; expression)
1172 {
1173     auto expressionInfo = recurseAndGetInfo(expression);
1174     if (!expressionInfo)
1175         return false;
1176     if (!isBoolType(expressionInfo-&gt;resolvingType)) {
<a name="167" id="anc167"></a><span class="line-modified">1177         setError();</span>
1178         return false;
1179     }
1180     return true;
1181 }
1182 
1183 void Checker::visit(AST::LogicalNotExpression&amp; logicalNotExpression)
1184 {
1185     if (!recurseAndRequireBoolType(logicalNotExpression.operand()))
1186         return;
<a name="168" id="anc168"></a><span class="line-modified">1187     assignType(logicalNotExpression, AST::TypeReference::wrap(Lexer::Token(logicalNotExpression.origin()), m_intrinsics.boolType()));</span>
1188 }
1189 
1190 void Checker::visit(AST::LogicalExpression&amp; logicalExpression)
1191 {
1192     if (!recurseAndRequireBoolType(logicalExpression.left()))
1193         return;
1194     if (!recurseAndRequireBoolType(logicalExpression.right()))
1195         return;
<a name="169" id="anc169"></a><span class="line-modified">1196     assignType(logicalExpression, AST::TypeReference::wrap(Lexer::Token(logicalExpression.origin()), m_intrinsics.boolType()));</span>
1197 }
1198 
1199 void Checker::visit(AST::IfStatement&amp; ifStatement)
1200 {
1201     if (!recurseAndRequireBoolType(ifStatement.conditional()))
1202         return;
1203     checkErrorAndVisit(ifStatement.body());
1204     if (ifStatement.elseBody())
1205         checkErrorAndVisit(*ifStatement.elseBody());
1206 }
1207 
1208 void Checker::visit(AST::WhileLoop&amp; whileLoop)
1209 {
1210     if (!recurseAndRequireBoolType(whileLoop.conditional()))
1211         return;
1212     checkErrorAndVisit(whileLoop.body());
1213 }
1214 
1215 void Checker::visit(AST::DoWhileLoop&amp; doWhileLoop)
1216 {
1217     checkErrorAndVisit(doWhileLoop.body());
1218     recurseAndRequireBoolType(doWhileLoop.conditional());
1219 }
1220 
1221 void Checker::visit(AST::ForLoop&amp; forLoop)
1222 {
<a name="170" id="anc170"></a><span class="line-modified">1223     WTF::visit(WTF::makeVisitor([&amp;](AST::VariableDeclarationsStatement&amp; variableDeclarationsStatement) {</span>
<span class="line-modified">1224         checkErrorAndVisit(variableDeclarationsStatement);</span>
<span class="line-removed">1225     }, [&amp;](UniqueRef&lt;AST::Expression&gt;&amp; expression) {</span>
<span class="line-removed">1226         checkErrorAndVisit(expression);</span>
<span class="line-removed">1227     }), forLoop.initialization());</span>
<span class="line-removed">1228     if (error())</span>
1229         return;
1230     if (forLoop.condition()) {
1231         if (!recurseAndRequireBoolType(*forLoop.condition()))
1232             return;
1233     }
1234     if (forLoop.increment())
1235         checkErrorAndVisit(*forLoop.increment());
1236     checkErrorAndVisit(forLoop.body());
1237 }
1238 
1239 void Checker::visit(AST::SwitchStatement&amp; switchStatement)
1240 {
1241     auto* valueType = ([&amp;]() -&gt; AST::NamedType* {
1242         auto valueInfo = recurseAndGetInfo(switchStatement.value());
1243         if (!valueInfo)
1244             return nullptr;
1245         auto* valueType = getUnnamedType(valueInfo-&gt;resolvingType);
1246         if (!valueType)
1247             return nullptr;
1248         auto&amp; valueUnifyNode = valueType-&gt;unifyNode();
1249         if (!is&lt;AST::NamedType&gt;(valueUnifyNode))
1250             return nullptr;
1251         auto&amp; valueNamedUnifyNode = downcast&lt;AST::NamedType&gt;(valueUnifyNode);
1252         if (!(is&lt;AST::NativeTypeDeclaration&gt;(valueNamedUnifyNode) &amp;&amp; downcast&lt;AST::NativeTypeDeclaration&gt;(valueNamedUnifyNode).isInt())
1253             &amp;&amp; !is&lt;AST::EnumerationDefinition&gt;(valueNamedUnifyNode))
1254             return nullptr;
1255         return &amp;valueNamedUnifyNode;
1256     })();
1257     if (!valueType) {
<a name="171" id="anc171"></a><span class="line-modified">1258         setError();</span>
1259         return;
1260     }
1261 
1262     bool hasDefault = false;
1263     for (auto&amp; switchCase : switchStatement.switchCases()) {
1264         checkErrorAndVisit(switchCase.block());
1265         if (!switchCase.value()) {
1266             hasDefault = true;
1267             continue;
1268         }
<a name="172" id="anc172"></a><span class="line-modified">1269         bool success;</span>
<span class="line-modified">1270         switchCase.value()-&gt;visit(WTF::makeVisitor([&amp;](AST::IntegerLiteral&amp; integerLiteral) {</span>
<span class="line-modified">1271             success = static_cast&lt;bool&gt;(matchAndCommit(*valueType, integerLiteral.type()));</span>
<span class="line-modified">1272         }, [&amp;](AST::UnsignedIntegerLiteral&amp; unsignedIntegerLiteral) {</span>
<span class="line-modified">1273             success = static_cast&lt;bool&gt;(matchAndCommit(*valueType, unsignedIntegerLiteral.type()));</span>
<span class="line-modified">1274         }, [&amp;](AST::FloatLiteral&amp; floatLiteral) {</span>
<span class="line-modified">1275             success = static_cast&lt;bool&gt;(matchAndCommit(*valueType, floatLiteral.type()));</span>
<span class="line-modified">1276         }, [&amp;](AST::NullLiteral&amp; nullLiteral) {</span>
<span class="line-modified">1277             success = static_cast&lt;bool&gt;(matchAndCommit(*valueType, nullLiteral.type()));</span>
<span class="line-modified">1278         }, [&amp;](AST::BooleanLiteral&amp;) {</span>
<span class="line-modified">1279             success = matches(*valueType, m_intrinsics.boolType());</span>
<span class="line-removed">1280         }, [&amp;](AST::EnumerationMemberLiteral&amp; enumerationMemberLiteral) {</span>
1281             ASSERT(enumerationMemberLiteral.enumerationDefinition());
<a name="173" id="anc173"></a><span class="line-modified">1282             success = matches(*valueType, *enumerationMemberLiteral.enumerationDefinition());</span>
1283         }));
1284         if (!success) {
<a name="174" id="anc174"></a><span class="line-modified">1285             setError();</span>
1286             return;
1287         }
1288     }
1289 
1290     for (size_t i = 0; i &lt; switchStatement.switchCases().size(); ++i) {
1291         auto&amp; firstCase = switchStatement.switchCases()[i];
1292         for (size_t j = i + 1; j &lt; switchStatement.switchCases().size(); ++j) {
1293             auto&amp; secondCase = switchStatement.switchCases()[j];
1294 
1295             if (static_cast&lt;bool&gt;(firstCase.value()) != static_cast&lt;bool&gt;(secondCase.value()))
1296                 continue;
1297 
1298             if (!static_cast&lt;bool&gt;(firstCase.value())) {
<a name="175" id="anc175"></a><span class="line-modified">1299                 setError();</span>
1300                 return;
1301             }
1302 
<a name="176" id="anc176"></a><span class="line-modified">1303             bool success = true;</span>
<span class="line-modified">1304             firstCase.value()-&gt;visit(WTF::makeVisitor([&amp;](AST::IntegerLiteral&amp; firstIntegerLiteral) {</span>
<span class="line-modified">1305                 secondCase.value()-&gt;visit(WTF::makeVisitor([&amp;](AST::IntegerLiteral&amp; secondIntegerLiteral) {</span>
<span class="line-modified">1306                     success = firstIntegerLiteral.value() != secondIntegerLiteral.value();</span>
<span class="line-modified">1307                 }, [&amp;](AST::UnsignedIntegerLiteral&amp; secondUnsignedIntegerLiteral) {</span>
<span class="line-modified">1308                     success = static_cast&lt;int64_t&gt;(firstIntegerLiteral.value()) != static_cast&lt;int64_t&gt;(secondUnsignedIntegerLiteral.value());</span>
<span class="line-modified">1309                 }, [](auto&amp;) {</span>
1310                 }));
<a name="177" id="anc177"></a><span class="line-modified">1311             }, [&amp;](AST::UnsignedIntegerLiteral&amp; firstUnsignedIntegerLiteral) {</span>
<span class="line-modified">1312                 secondCase.value()-&gt;visit(WTF::makeVisitor([&amp;](AST::IntegerLiteral&amp; secondIntegerLiteral) {</span>
<span class="line-modified">1313                     success = static_cast&lt;int64_t&gt;(firstUnsignedIntegerLiteral.value()) != static_cast&lt;int64_t&gt;(secondIntegerLiteral.value());</span>
<span class="line-modified">1314                 }, [&amp;](AST::UnsignedIntegerLiteral&amp; secondUnsignedIntegerLiteral) {</span>
<span class="line-modified">1315                     success = firstUnsignedIntegerLiteral.value() != secondUnsignedIntegerLiteral.value();</span>
<span class="line-modified">1316                 }, [](auto&amp;) {</span>

1317                 }));
<a name="178" id="anc178"></a><span class="line-modified">1318             }, [&amp;](AST::EnumerationMemberLiteral&amp; firstEnumerationMemberLiteral) {</span>
<span class="line-modified">1319                 secondCase.value()-&gt;visit(WTF::makeVisitor([&amp;](AST::IntegerLiteral&amp;) {</span>
<span class="line-removed">1320                 }, [&amp;](AST::EnumerationMemberLiteral&amp; secondEnumerationMemberLiteral) {</span>
1321                     ASSERT(firstEnumerationMemberLiteral.enumerationMember());
1322                     ASSERT(secondEnumerationMemberLiteral.enumerationMember());
<a name="179" id="anc179"></a><span class="line-modified">1323                     success = firstEnumerationMemberLiteral.enumerationMember() != secondEnumerationMemberLiteral.enumerationMember();</span>
<span class="line-modified">1324                 }, [](auto&amp;) {</span>

1325                 }));
<a name="180" id="anc180"></a><span class="line-modified">1326             }, [](auto&amp;) {</span>

1327             }));
<a name="181" id="anc181"></a>



1328         }
1329     }
1330 
1331     if (!hasDefault) {
1332         if (is&lt;AST::NativeTypeDeclaration&gt;(*valueType)) {
1333             HashSet&lt;int64_t&gt; values;
1334             bool zeroValueExists;
1335             for (auto&amp; switchCase : switchStatement.switchCases()) {
<a name="182" id="anc182"></a><span class="line-modified">1336                 int64_t value;</span>
<span class="line-modified">1337                 switchCase.value()-&gt;visit(WTF::makeVisitor([&amp;](AST::IntegerLiteral&amp; integerLiteral) {</span>
<span class="line-modified">1338                     value = integerLiteral.valueForSelectedType();</span>
<span class="line-modified">1339                 }, [&amp;](AST::UnsignedIntegerLiteral&amp; unsignedIntegerLiteral) {</span>
<span class="line-modified">1340                     value = unsignedIntegerLiteral.valueForSelectedType();</span>
<span class="line-removed">1341                 }, [](auto&amp;) {</span>
1342                     ASSERT_NOT_REACHED();
<a name="183" id="anc183"></a>
1343                 }));
1344                 if (!value)
1345                     zeroValueExists = true;
1346                 else
1347                     values.add(value);
1348             }
1349             bool success = true;
1350             downcast&lt;AST::NativeTypeDeclaration&gt;(*valueType).iterateAllValues([&amp;](int64_t value) -&gt; bool {
1351                 if (!value) {
1352                     if (!zeroValueExists) {
1353                         success = false;
1354                         return true;
1355                     }
1356                     return false;
1357                 }
1358                 if (!values.contains(value)) {
1359                     success = false;
1360                     return true;
1361                 }
1362                 return false;
1363             });
1364             if (!success) {
<a name="184" id="anc184"></a><span class="line-modified">1365                 setError();</span>
1366                 return;
1367             }
1368         } else {
<a name="185" id="anc185"></a><span class="line-removed">1369             ASSERT(is&lt;AST::EnumerationDefinition&gt;(*valueType));</span>
1370             HashSet&lt;AST::EnumerationMember*&gt; values;
1371             for (auto&amp; switchCase : switchStatement.switchCases()) {
1372                 switchCase.value()-&gt;visit(WTF::makeVisitor([&amp;](AST::EnumerationMemberLiteral&amp; enumerationMemberLiteral) {
1373                     ASSERT(enumerationMemberLiteral.enumerationMember());
1374                     values.add(enumerationMemberLiteral.enumerationMember());
1375                 }, [](auto&amp;) {
1376                     ASSERT_NOT_REACHED();
1377                 }));
1378             }
1379             for (auto&amp; enumerationMember : downcast&lt;AST::EnumerationDefinition&gt;(*valueType).enumerationMembers()) {
1380                 if (!values.contains(&amp;enumerationMember.get())) {
<a name="186" id="anc186"></a><span class="line-modified">1381                     setError();</span>
1382                     return;
1383                 }
1384             }
1385         }
1386     }
1387 }
1388 
1389 void Checker::visit(AST::CommaExpression&amp; commaExpression)
1390 {
1391     ASSERT(commaExpression.list().size() &gt; 0);
1392     Visitor::visit(commaExpression);
<a name="187" id="anc187"></a><span class="line-modified">1393     if (error())</span>
1394         return;
1395     auto lastInfo = getInfo(commaExpression.list().last());
1396     forwardType(commaExpression, lastInfo-&gt;resolvingType);
1397 }
1398 
1399 void Checker::visit(AST::TernaryExpression&amp; ternaryExpression)
1400 {
1401     auto predicateInfo = recurseAndRequireBoolType(ternaryExpression.predicate());
1402     if (!predicateInfo)
1403         return;
1404 
1405     auto bodyInfo = recurseAndGetInfo(ternaryExpression.bodyExpression());
1406     auto elseInfo = recurseAndGetInfo(ternaryExpression.elseExpression());
1407 
1408     auto resultType = matchAndCommit(bodyInfo-&gt;resolvingType, elseInfo-&gt;resolvingType);
1409     if (!resultType) {
<a name="188" id="anc188"></a><span class="line-modified">1410         setError();</span>
1411         return;
1412     }
1413 
<a name="189" id="anc189"></a><span class="line-modified">1414     assignType(ternaryExpression, WTFMove(*resultType));</span>
1415 }
1416 
1417 void Checker::visit(AST::CallExpression&amp; callExpression)
1418 {
1419     Vector&lt;std::reference_wrapper&lt;ResolvingType&gt;&gt; types;
1420     types.reserveInitialCapacity(callExpression.arguments().size());
1421     for (auto&amp; argument : callExpression.arguments()) {
1422         auto argumentInfo = recurseAndGetInfo(argument);
1423         if (!argumentInfo)
1424             return;
1425         types.uncheckedAppend(argumentInfo-&gt;resolvingType);
1426     }
<a name="190" id="anc190"></a><span class="line-modified">1427     if (callExpression.castReturnType()) {</span>
<span class="line-modified">1428         checkErrorAndVisit(callExpression.castReturnType()-&gt;get());</span>
<span class="line-modified">1429         if (error())</span>
<span class="line-modified">1430             return;</span>
<span class="line-modified">1431     }</span>

1432 
<a name="191" id="anc191"></a><span class="line-removed">1433     ASSERT(callExpression.hasOverloads());</span>
<span class="line-removed">1434     auto* function = resolveFunctionOverloadImpl(*callExpression.overloads(), types, callExpression.castReturnType());</span>
1435     if (!function) {
<a name="192" id="anc192"></a><span class="line-modified">1436         if (auto newFunction = resolveByInstantiation(callExpression, types, m_intrinsics)) {</span>
<span class="line-modified">1437             m_program.append(WTFMove(*newFunction));</span>
<span class="line-modified">1438             function = &amp;m_program.nativeFunctionDeclarations().last();</span>






1439         }
1440     }
1441 
1442     if (!function) {
<a name="193" id="anc193"></a><span class="line-modified">1443         setError();</span>


1444         return;
1445     }
1446 
1447     for (size_t i = 0; i &lt; function-&gt;parameters().size(); ++i) {
<a name="194" id="anc194"></a><span class="line-modified">1448         if (!matchAndCommit(types[i].get(), *function-&gt;parameters()[i].type())) {</span>
<span class="line-modified">1449             setError();</span>
1450             return;
1451         }
1452     }
1453 
1454     callExpression.setFunction(*function);
1455 
<a name="195" id="anc195"></a><span class="line-modified">1456     assignType(callExpression, function-&gt;type().clone());</span>
1457 }
1458 
<a name="196" id="anc196"></a><span class="line-modified">1459 bool check(Program&amp; program)</span>
1460 {
1461     Checker checker(program.intrinsics(), program);
1462     checker.checkErrorAndVisit(program);
<a name="197" id="anc197"></a><span class="line-modified">1463     if (checker.error())</span>
<span class="line-modified">1464         return false;</span>
1465     return checker.assignTypes();
1466 }
1467 
1468 } // namespace WHLSL
1469 
1470 } // namespace WebCore
1471 
1472 #endif // ENABLE(WEBGPU)
<a name="198" id="anc198"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="198" type="hidden" />
</body>
</html>