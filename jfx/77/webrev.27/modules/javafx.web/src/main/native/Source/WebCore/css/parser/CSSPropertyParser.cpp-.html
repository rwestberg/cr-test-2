<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.web/src/main/native/Source/WebCore/css/parser/CSSPropertyParser.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 // Copyright 2015 The Chromium Authors. All rights reserved.
   2 // Copyright (C) 2016 Apple Inc. All rights reserved.
   3 //
   4 // Redistribution and use in source and binary forms, with or without
   5 // modification, are permitted provided that the following conditions are
   6 // met:
   7 //
   8 //    * Redistributions of source code must retain the above copyright
   9 // notice, this list of conditions and the following disclaimer.
  10 //    * Redistributions in binary form must reproduce the above
  11 // copyright notice, this list of conditions and the following disclaimer
  12 // in the documentation and/or other materials provided with the
  13 // distribution.
  14 //    * Neither the name of Google Inc. nor the names of its
  15 // contributors may be used to endorse or promote products derived from
  16 // this software without specific prior written permission.
  17 //
  18 // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  19 // &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  20 // LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
  21 // A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
  22 // OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
  23 // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
  24 // LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
  25 // DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
  26 // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  27 // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  28 // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  29 
  30 #include &quot;config.h&quot;
  31 #include &quot;CSSPropertyParser.h&quot;
  32 
  33 #include &quot;CSSAspectRatioValue.h&quot;
  34 #include &quot;CSSBasicShapes.h&quot;
  35 #include &quot;CSSBorderImage.h&quot;
  36 #include &quot;CSSBorderImageSliceValue.h&quot;
  37 #include &quot;CSSContentDistributionValue.h&quot;
  38 #include &quot;CSSCursorImageValue.h&quot;
  39 #include &quot;CSSCustomIdentValue.h&quot;
  40 #include &quot;CSSCustomPropertyValue.h&quot;
  41 #include &quot;CSSFontFaceSrcValue.h&quot;
  42 #include &quot;CSSFontFeatureValue.h&quot;
  43 #if ENABLE(VARIATION_FONTS)
  44 #include &quot;CSSFontVariationValue.h&quot;
  45 #endif
  46 #include &quot;CSSFontStyleRangeValue.h&quot;
  47 #include &quot;CSSFontStyleValue.h&quot;
  48 #include &quot;CSSFunctionValue.h&quot;
  49 #include &quot;CSSGridAutoRepeatValue.h&quot;
  50 #include &quot;CSSGridLineNamesValue.h&quot;
  51 #include &quot;CSSGridTemplateAreasValue.h&quot;
  52 #include &quot;CSSLineBoxContainValue.h&quot;
  53 #include &quot;CSSParserFastPaths.h&quot;
  54 #include &quot;CSSParserIdioms.h&quot;
  55 #include &quot;CSSPendingSubstitutionValue.h&quot;
  56 #include &quot;CSSPrimitiveValueMappings.h&quot;
  57 #include &quot;CSSPropertyParserHelpers.h&quot;
  58 #include &quot;CSSReflectValue.h&quot;
  59 #include &quot;CSSShadowValue.h&quot;
  60 #include &quot;CSSTimingFunctionValue.h&quot;
  61 #include &quot;CSSUnicodeRangeValue.h&quot;
  62 #include &quot;CSSVariableParser.h&quot;
  63 #include &quot;CSSVariableReferenceValue.h&quot;
  64 #include &quot;Counter.h&quot;
  65 #if ENABLE(DASHBOARD_SUPPORT)
  66 #include &quot;DashboardRegion.h&quot;
  67 #endif
  68 #include &quot;FontFace.h&quot;
  69 #include &quot;HashTools.h&quot;
  70 // FIXME-NEWPARSER: Replace Pair and Rect with actual CSSValue subclasses (CSSValuePair and CSSQuadValue).
  71 #include &quot;Pair.h&quot;
  72 #include &quot;Rect.h&quot;
  73 #include &quot;RenderTheme.h&quot;
  74 #include &quot;RuntimeEnabledFeatures.h&quot;
  75 #include &quot;SVGPathByteStream.h&quot;
  76 #include &quot;SVGPathUtilities.h&quot;
  77 #include &quot;StyleBuilderConverter.h&quot;
  78 #include &quot;StylePropertyShorthand.h&quot;
  79 #include &quot;StylePropertyShorthandFunctions.h&quot;
  80 #include &quot;StyleResolver.h&quot;
  81 #include &lt;bitset&gt;
  82 #include &lt;memory&gt;
  83 #include &lt;wtf/text/StringBuilder.h&gt;
  84 
  85 namespace WebCore {
  86 
  87 bool isCustomPropertyName(const String&amp; propertyName)
  88 {
  89     return propertyName.length() &gt; 2 &amp;&amp; propertyName.characterAt(0) == &#39;-&#39; &amp;&amp; propertyName.characterAt(1) == &#39;-&#39;;
  90 }
  91 
  92 static bool hasPrefix(const char* string, unsigned length, const char* prefix)
  93 {
  94     for (unsigned i = 0; i &lt; length; ++i) {
  95         if (!prefix[i])
  96             return true;
  97         if (string[i] != prefix[i])
  98             return false;
  99     }
 100     return false;
 101 }
 102 
 103 #if PLATFORM(IOS_FAMILY)
 104 void cssPropertyNameIOSAliasing(const char* propertyName, const char*&amp; propertyNameAlias, unsigned&amp; newLength)
 105 {
 106     if (!strcmp(propertyName, &quot;-webkit-hyphenate-locale&quot;)) {
 107         // Worked in iOS 4.2.
 108         static const char webkitLocale[] = &quot;-webkit-locale&quot;;
 109         propertyNameAlias = webkitLocale;
 110         newLength = strlen(webkitLocale);
 111     }
 112 }
 113 #endif
 114 
 115 template &lt;typename CharacterType&gt;
 116 static CSSPropertyID cssPropertyID(const CharacterType* propertyName, unsigned length)
 117 {
 118     char buffer[maxCSSPropertyNameLength + 1 + 1]; // 1 to turn &quot;apple&quot;/&quot;khtml&quot; into &quot;webkit&quot;, 1 for null character
 119 
 120     for (unsigned i = 0; i != length; ++i) {
 121         CharacterType c = propertyName[i];
 122         if (!c || c &gt;= 0x7F)
 123             return CSSPropertyInvalid; // illegal character
 124         buffer[i] = toASCIILower(c);
 125     }
 126     buffer[length] = &#39;\0&#39;;
 127 
 128     const char* name = buffer;
 129     if (buffer[0] == &#39;-&#39;) {
 130 #if ENABLE(LEGACY_CSS_VENDOR_PREFIXES)
 131         // If the prefix is -apple- or -khtml-, change it to -webkit-.
 132         // This makes the string one character longer.
 133         if (RuntimeEnabledFeatures::sharedFeatures().legacyCSSVendorPrefixesEnabled()
 134             &amp;&amp; (hasPrefix(buffer, length, &quot;-apple-&quot;) || hasPrefix(buffer, length, &quot;-khtml-&quot;))) {
 135             memmove(buffer + 7, buffer + 6, length + 1 - 6);
 136             memcpy(buffer, &quot;-webkit&quot;, 7);
 137             ++length;
 138         }
 139 #endif
 140 #if PLATFORM(IOS_FAMILY)
 141         cssPropertyNameIOSAliasing(buffer, name, length);
 142 #endif
 143     }
 144 
 145     const Property* hashTableEntry = findProperty(name, length);
 146     if (hashTableEntry) {
 147         auto propertyID = static_cast&lt;CSSPropertyID&gt;(hashTableEntry-&gt;id);
 148         if (isEnabledCSSProperty(propertyID))
 149             return propertyID;
 150     }
 151     return CSSPropertyInvalid;
 152 }
 153 
 154 static bool isAppleLegacyCssValueKeyword(const char* valueKeyword, unsigned length)
 155 {
 156     static const char applePrefix[] = &quot;-apple-&quot;;
 157     static const char appleSystemPrefix[] = &quot;-apple-system&quot;;
 158     static const char applePayPrefix[] = &quot;-apple-pay&quot;;
 159     static const char* appleWirelessPlaybackTargetActive = getValueName(CSSValueAppleWirelessPlaybackTargetActive);
 160 
 161     return hasPrefix(valueKeyword, length, applePrefix)
 162     &amp;&amp; !hasPrefix(valueKeyword, length, appleSystemPrefix)
 163     &amp;&amp; !hasPrefix(valueKeyword, length, applePayPrefix)
 164     &amp;&amp; !WTF::equal(reinterpret_cast&lt;const LChar*&gt;(valueKeyword), reinterpret_cast&lt;const LChar*&gt;(appleWirelessPlaybackTargetActive), length);
 165 }
 166 
 167 template &lt;typename CharacterType&gt;
 168 static CSSValueID cssValueKeywordID(const CharacterType* valueKeyword, unsigned length)
 169 {
 170     char buffer[maxCSSValueKeywordLength + 1 + 1]; // 1 to turn &quot;apple&quot;/&quot;khtml&quot; into &quot;webkit&quot;, 1 for null character
 171 
 172     for (unsigned i = 0; i != length; ++i) {
 173         CharacterType c = valueKeyword[i];
 174         if (!c || c &gt;= 0x7F)
 175             return CSSValueInvalid; // illegal keyword.
 176         buffer[i] = WTF::toASCIILower(c);
 177     }
 178     buffer[length] = &#39;\0&#39;;
 179 
 180     if (buffer[0] == &#39;-&#39;) {
 181         // If the prefix is -apple- or -khtml-, change it to -webkit-.
 182         // This makes the string one character longer.
 183         // On iOS we don&#39;t want to change values starting with -apple-system to -webkit-system.
 184         // FIXME: Remove this mangling without breaking the web.
 185         if (isAppleLegacyCssValueKeyword(buffer, length) || hasPrefix(buffer, length, &quot;-khtml-&quot;)) {
 186             memmove(buffer + 7, buffer + 6, length + 1 - 6);
 187             memcpy(buffer, &quot;-webkit&quot;, 7);
 188             ++length;
 189         }
 190     }
 191 
 192     const Value* hashTableEntry = findValue(buffer, length);
 193     return hashTableEntry ? static_cast&lt;CSSValueID&gt;(hashTableEntry-&gt;id) : CSSValueInvalid;
 194 }
 195 
 196 CSSValueID cssValueKeywordID(StringView string)
 197 {
 198     unsigned length = string.length();
 199     if (!length)
 200         return CSSValueInvalid;
 201     if (length &gt; maxCSSValueKeywordLength)
 202         return CSSValueInvalid;
 203 
 204     return string.is8Bit() ? cssValueKeywordID(string.characters8(), length) : cssValueKeywordID(string.characters16(), length);
 205 }
 206 
 207 CSSPropertyID cssPropertyID(StringView string)
 208 {
 209     unsigned length = string.length();
 210 
 211     if (!length)
 212         return CSSPropertyInvalid;
 213     if (length &gt; maxCSSPropertyNameLength)
 214         return CSSPropertyInvalid;
 215 
 216     return string.is8Bit() ? cssPropertyID(string.characters8(), length) : cssPropertyID(string.characters16(), length);
 217 }
 218 
 219 using namespace CSSPropertyParserHelpers;
 220 
 221 CSSPropertyParser::CSSPropertyParser(const CSSParserTokenRange&amp; range, const CSSParserContext&amp; context, Vector&lt;CSSProperty, 256&gt;* parsedProperties, bool consumeWhitespace)
 222     : m_range(range)
 223     , m_context(context)
 224     , m_parsedProperties(parsedProperties)
 225 {
 226     if (consumeWhitespace)
 227         m_range.consumeWhitespace();
 228 }
 229 
 230 void CSSPropertyParser::addProperty(CSSPropertyID property, CSSPropertyID currentShorthand, Ref&lt;CSSValue&gt;&amp;&amp; value, bool important, bool implicit)
 231 {
 232     if (!isEnabledCSSProperty(property))
 233         return;
 234 
 235     int shorthandIndex = 0;
 236     bool setFromShorthand = false;
 237 
 238     if (currentShorthand) {
 239         auto shorthands = matchingShorthandsForLonghand(property);
 240         setFromShorthand = true;
 241         if (shorthands.size() &gt; 1)
 242             shorthandIndex = indexOfShorthandForLonghand(currentShorthand, shorthands);
 243     }
 244 
 245     m_parsedProperties-&gt;append(CSSProperty(property, WTFMove(value), important, setFromShorthand, shorthandIndex, implicit));
 246 }
 247 
 248 void CSSPropertyParser::addExpandedPropertyForValue(CSSPropertyID property, Ref&lt;CSSValue&gt;&amp;&amp; value, bool important)
 249 {
 250     const StylePropertyShorthand&amp; shorthand = shorthandForProperty(property);
 251     unsigned shorthandLength = shorthand.length();
 252     ASSERT(shorthandLength);
 253     const CSSPropertyID* longhands = shorthand.properties();
 254     for (unsigned i = 0; i &lt; shorthandLength; ++i)
 255         addProperty(longhands[i], property, value.copyRef(), important);
 256 }
 257 
 258 bool CSSPropertyParser::parseValue(CSSPropertyID propertyID, bool important, const CSSParserTokenRange&amp; range, const CSSParserContext&amp; context, ParsedPropertyVector&amp; parsedProperties, StyleRule::Type ruleType)
 259 {
 260     int parsedPropertiesSize = parsedProperties.size();
 261 
 262     CSSPropertyParser parser(range, context, &amp;parsedProperties);
 263     bool parseSuccess;
 264 
 265 #if ENABLE(CSS_DEVICE_ADAPTATION)
 266     if (ruleType == StyleRule::Viewport)
 267         parseSuccess = parser.parseViewportDescriptor(propertyID, important);
 268     else
 269 #endif
 270     if (ruleType == StyleRule::FontFace)
 271         parseSuccess = parser.parseFontFaceDescriptor(propertyID);
 272     else
 273         parseSuccess = parser.parseValueStart(propertyID, important);
 274 
 275     if (!parseSuccess)
 276         parsedProperties.shrink(parsedPropertiesSize);
 277 
 278     return parseSuccess;
 279 }
 280 
 281 RefPtr&lt;CSSValue&gt; CSSPropertyParser::parseSingleValue(CSSPropertyID property, const CSSParserTokenRange&amp; range, const CSSParserContext&amp; context)
 282 {
 283     CSSPropertyParser parser(range, context, nullptr);
 284     RefPtr&lt;CSSValue&gt; value = parser.parseSingleValue(property);
 285     if (!value || !parser.m_range.atEnd())
 286         return nullptr;
 287     return value;
 288 }
 289 
 290 bool CSSPropertyParser::canParseTypedCustomPropertyValue(const String&amp; syntax, const CSSParserTokenRange&amp; tokens, const CSSParserContext&amp; context)
 291 {
 292     CSSPropertyParser parser(tokens, context, nullptr);
 293     return parser.canParseTypedCustomPropertyValue(syntax);
 294 }
 295 
 296 RefPtr&lt;CSSCustomPropertyValue&gt; CSSPropertyParser::parseTypedCustomPropertyValue(const String&amp; name, const String&amp; syntax, const CSSParserTokenRange&amp; tokens, const StyleResolver&amp; styleResolver, const CSSParserContext&amp; context)
 297 {
 298     CSSPropertyParser parser(tokens, context, nullptr, false);
 299     RefPtr&lt;CSSCustomPropertyValue&gt; value = parser.parseTypedCustomPropertyValue(name, syntax, styleResolver);
 300     if (!value || !parser.m_range.atEnd())
 301         return nullptr;
 302     return value;
 303 }
 304 
 305 void CSSPropertyParser::collectParsedCustomPropertyValueDependencies(const String&amp; syntax, bool isRoot, HashSet&lt;CSSPropertyID&gt;&amp; dependencies, const CSSParserTokenRange&amp; tokens, const CSSParserContext&amp; context)
 306 {
 307     CSSPropertyParser parser(tokens, context, nullptr);
 308     parser.collectParsedCustomPropertyValueDependencies(syntax, isRoot, dependencies);
 309 }
 310 
 311 static bool isLegacyBreakProperty(CSSPropertyID propertyID)
 312 {
 313     switch (propertyID) {
 314     case CSSPropertyPageBreakAfter:
 315     case CSSPropertyPageBreakBefore:
 316     case CSSPropertyPageBreakInside:
 317     case CSSPropertyWebkitColumnBreakAfter:
 318     case CSSPropertyWebkitColumnBreakBefore:
 319     case CSSPropertyWebkitColumnBreakInside:
 320         return true;
 321     default:
 322         break;
 323     }
 324     return false;
 325 }
 326 
 327 bool CSSPropertyParser::parseValueStart(CSSPropertyID propertyID, bool important)
 328 {
 329     if (consumeCSSWideKeyword(propertyID, important))
 330         return true;
 331 
 332     CSSParserTokenRange originalRange = m_range;
 333     bool isShorthand = isShorthandCSSProperty(propertyID);
 334 
 335     if (isShorthand) {
 336         // Variable references will fail to parse here and will fall out to the variable ref parser below.
 337         if (parseShorthand(propertyID, important))
 338             return true;
 339     } else if (isLegacyBreakProperty(propertyID)) {
 340         // FIXME-NEWPARSER: Can turn this into a shorthand once old parser is gone, and then
 341         // we don&#39;t need the special case.
 342         if (consumeLegacyBreakProperty(propertyID, important))
 343             return true;
 344     } else {
 345         RefPtr&lt;CSSValue&gt; parsedValue = parseSingleValue(propertyID);
 346         if (parsedValue &amp;&amp; m_range.atEnd()) {
 347             addProperty(propertyID, CSSPropertyInvalid, *parsedValue, important);
 348             return true;
 349         }
 350     }
 351 
 352     if (CSSVariableParser::containsValidVariableReferences(originalRange, m_context)) {
 353         RefPtr&lt;CSSVariableReferenceValue&gt; variable = CSSVariableReferenceValue::create(originalRange);
 354 
 355         if (isShorthand) {
 356             RefPtr&lt;CSSPendingSubstitutionValue&gt; pendingValue = CSSPendingSubstitutionValue::create(propertyID, variable.releaseNonNull());
 357             addExpandedPropertyForValue(propertyID, pendingValue.releaseNonNull(), important);
 358         } else
 359             addProperty(propertyID, CSSPropertyInvalid, variable.releaseNonNull(), important);
 360         return true;
 361     }
 362 
 363     return false;
 364 }
 365 
 366 bool CSSPropertyParser::consumeCSSWideKeyword(CSSPropertyID propertyID, bool important)
 367 {
 368     CSSParserTokenRange rangeCopy = m_range;
 369     CSSValueID valueID = rangeCopy.consumeIncludingWhitespace().id();
 370     if (!rangeCopy.atEnd())
 371         return false;
 372 
 373     RefPtr&lt;CSSValue&gt; value;
 374     if (valueID == CSSValueInherit)
 375         value = CSSValuePool::singleton().createInheritedValue();
 376     else if (valueID == CSSValueInitial)
 377         value = CSSValuePool::singleton().createExplicitInitialValue();
 378     else if (valueID == CSSValueUnset)
 379         value = CSSValuePool::singleton().createUnsetValue();
 380     else if (valueID == CSSValueRevert)
 381         value = CSSValuePool::singleton().createRevertValue();
 382     else
 383         return false;
 384 
 385     const StylePropertyShorthand&amp; shorthand = shorthandForProperty(propertyID);
 386     if (!shorthand.length()) {
 387         if (CSSProperty::isDescriptorOnly(propertyID))
 388             return false;
 389         addProperty(propertyID, CSSPropertyInvalid, value.releaseNonNull(), important);
 390     } else
 391         addExpandedPropertyForValue(propertyID, value.releaseNonNull(), important);
 392     m_range = rangeCopy;
 393     return true;
 394 }
 395 
 396 bool CSSPropertyParser::consumeTransformOrigin(bool important)
 397 {
 398     RefPtr&lt;CSSPrimitiveValue&gt; resultX;
 399     RefPtr&lt;CSSPrimitiveValue&gt; resultY;
 400     if (consumeOneOrTwoValuedPosition(m_range, m_context.mode, UnitlessQuirk::Forbid, resultX, resultY)) {
 401         m_range.consumeWhitespace();
 402         bool atEnd = m_range.atEnd();
 403         RefPtr&lt;CSSPrimitiveValue&gt; resultZ = consumeLength(m_range, m_context.mode, ValueRangeAll);
 404         bool hasZ = resultZ;
 405         if (!hasZ &amp;&amp; !atEnd)
 406             return false;
 407         addProperty(CSSPropertyTransformOriginX, CSSPropertyTransformOrigin, resultX.releaseNonNull(), important);
 408         addProperty(CSSPropertyTransformOriginY, CSSPropertyTransformOrigin, resultY.releaseNonNull(), important);
 409         addProperty(CSSPropertyTransformOriginZ, CSSPropertyTransformOrigin, resultZ ? resultZ.releaseNonNull() : CSSValuePool::singleton().createValue(0, CSSPrimitiveValue::UnitType::CSS_PX), important, !hasZ);
 410 
 411         return true;
 412     }
 413     return false;
 414 }
 415 
 416 bool CSSPropertyParser::consumePerspectiveOrigin(bool important)
 417 {
 418     RefPtr&lt;CSSPrimitiveValue&gt; resultX;
 419     RefPtr&lt;CSSPrimitiveValue&gt; resultY;
 420     if (consumePosition(m_range, m_context.mode, UnitlessQuirk::Forbid, resultX, resultY)) {
 421         addProperty(CSSPropertyPerspectiveOriginX, CSSPropertyPerspectiveOrigin, resultX.releaseNonNull(), important);
 422         addProperty(CSSPropertyPerspectiveOriginY, CSSPropertyPerspectiveOrigin, resultY.releaseNonNull(), important);
 423         return true;
 424     }
 425     return false;
 426 }
 427 
 428 // Methods for consuming non-shorthand properties starts here.
 429 static RefPtr&lt;CSSValue&gt; consumeWillChange(CSSParserTokenRange&amp; range)
 430 {
 431     if (range.peek().id() == CSSValueAuto)
 432         return consumeIdent(range);
 433 
 434     RefPtr&lt;CSSValueList&gt; values = CSSValueList::createCommaSeparated();
 435     // Every comma-separated list of identifiers is a valid will-change value,
 436     // unless the list includes an explicitly disallowed identifier.
 437     while (true) {
 438         if (range.peek().type() != IdentToken)
 439             return nullptr;
 440         CSSPropertyID propertyID = cssPropertyID(range.peek().value());
 441         if (propertyID != CSSPropertyInvalid) {
 442             // Now &quot;all&quot; is used by both CSSValue and CSSPropertyValue.
 443             // Need to return nullptr when currentValue is CSSPropertyAll.
 444             if (propertyID == CSSPropertyWillChange || propertyID == CSSPropertyAll)
 445                 return nullptr;
 446             // FIXME-NEWPARSER: Use CSSCustomIdentValue someday.
 447             values-&gt;append(CSSValuePool::singleton().createIdentifierValue(propertyID));
 448             range.consumeIncludingWhitespace();
 449         } else {
 450             switch (range.peek().id()) {
 451             case CSSValueNone:
 452             case CSSValueAll:
 453             case CSSValueAuto:
 454             case CSSValueDefault:
 455             case CSSValueInitial:
 456             case CSSValueInherit:
 457                 return nullptr;
 458             case CSSValueContents:
 459             case CSSValueScrollPosition:
 460                 values-&gt;append(consumeIdent(range).releaseNonNull());
 461                 break;
 462             default:
 463                 // Append properties we don&#39;t recognize, but that are legal, as strings.
 464                 values-&gt;append(consumeCustomIdent(range).releaseNonNull());
 465                 break;
 466             }
 467         }
 468 
 469         if (range.atEnd())
 470             break;
 471         if (!consumeCommaIncludingWhitespace(range))
 472             return nullptr;
 473     }
 474 
 475     return values;
 476 }
 477 
 478 static RefPtr&lt;CSSFontFeatureValue&gt; consumeFontFeatureTag(CSSParserTokenRange&amp; range)
 479 {
 480     // Feature tag name consists of 4-letter characters.
 481     static const unsigned tagNameLength = 4;
 482 
 483     const CSSParserToken&amp; token = range.consumeIncludingWhitespace();
 484     // Feature tag name comes first
 485     if (token.type() != StringToken)
 486         return nullptr;
 487     if (token.value().length() != tagNameLength)
 488         return nullptr;
 489 
 490     FontTag tag;
 491     for (unsigned i = 0; i &lt; tag.size(); ++i) {
 492         // Limits the range of characters to 0x20-0x7E, following the tag name rules defiend in the OpenType specification.
 493         UChar character = token.value()[i];
 494         if (character &lt; 0x20 || character &gt; 0x7E)
 495             return nullptr;
 496         tag[i] = toASCIILower(character);
 497     }
 498 
 499     int tagValue = 1;
 500     if (!range.atEnd() &amp;&amp; range.peek().type() != CommaToken) {
 501         // Feature tag values could follow: &lt;integer&gt; | on | off
 502         if (auto primitiveValue = consumeInteger(range, 0))
 503             tagValue = primitiveValue-&gt;intValue();
 504         else if (range.peek().id() == CSSValueOn || range.peek().id() == CSSValueOff)
 505             tagValue = range.consumeIncludingWhitespace().id() == CSSValueOn;
 506         else
 507             return nullptr;
 508     }
 509     return CSSFontFeatureValue::create(WTFMove(tag), tagValue);
 510 }
 511 
 512 static RefPtr&lt;CSSValue&gt; consumeFontFeatureSettings(CSSParserTokenRange&amp; range)
 513 {
 514     if (range.peek().id() == CSSValueNormal)
 515         return consumeIdent(range);
 516     RefPtr&lt;CSSValueList&gt; settings = CSSValueList::createCommaSeparated();
 517     do {
 518         RefPtr&lt;CSSFontFeatureValue&gt; fontFeatureValue = consumeFontFeatureTag(range);
 519         if (!fontFeatureValue)
 520             return nullptr;
 521         settings-&gt;append(fontFeatureValue.releaseNonNull());
 522     } while (consumeCommaIncludingWhitespace(range));
 523     return settings;
 524 }
 525 
 526 #if ENABLE(VARIATION_FONTS)
 527 static RefPtr&lt;CSSValue&gt; consumeFontVariationTag(CSSParserTokenRange&amp; range)
 528 {
 529     if (range.peek().type() != StringToken)
 530         return nullptr;
 531 
 532     auto string = range.consumeIncludingWhitespace().value().toString();
 533 
 534     FontTag tag;
 535     if (string.length() != tag.size())
 536         return nullptr;
 537     for (unsigned i = 0; i &lt; tag.size(); ++i) {
 538         // Limits the range of characters to 0x20-0x7E, following the tag name rules defiend in the OpenType specification.
 539         UChar character = string[i];
 540         if (character &lt; 0x20 || character &gt; 0x7E)
 541             return nullptr;
 542         tag[i] = character;
 543     }
 544 
 545     if (range.atEnd())
 546         return nullptr;
 547 
 548     double tagValue = 0;
 549     auto success = consumeNumberRaw(range, tagValue);
 550     if (!success)
 551         return nullptr;
 552 
 553     return CSSFontVariationValue::create(tag, tagValue);
 554 }
 555 
 556 static RefPtr&lt;CSSValue&gt; consumeFontVariationSettings(CSSParserTokenRange&amp; range)
 557 {
 558     if (range.peek().id() == CSSValueNormal)
 559         return consumeIdent(range);
 560 
 561     auto settings = CSSValueList::createCommaSeparated();
 562     do {
 563         RefPtr&lt;CSSValue&gt; variationValue = consumeFontVariationTag(range);
 564         if (!variationValue)
 565             return nullptr;
 566         settings-&gt;append(variationValue.releaseNonNull());
 567     } while (consumeCommaIncludingWhitespace(range));
 568 
 569     if (!settings-&gt;length())
 570         return nullptr;
 571 
 572     return WTFMove(settings);
 573 }
 574 #endif // ENABLE(VARIATION_FONTS)
 575 
 576 static RefPtr&lt;CSSValue&gt; consumePage(CSSParserTokenRange&amp; range)
 577 {
 578     if (range.peek().id() == CSSValueAuto)
 579         return consumeIdent(range);
 580     return consumeCustomIdent(range);
 581 }
 582 
 583 static RefPtr&lt;CSSValue&gt; consumeQuotes(CSSParserTokenRange&amp; range)
 584 {
 585     if (range.peek().id() == CSSValueNone)
 586         return consumeIdent(range);
 587     RefPtr&lt;CSSValueList&gt; values = CSSValueList::createSpaceSeparated();
 588     while (!range.atEnd()) {
 589         RefPtr&lt;CSSPrimitiveValue&gt; parsedValue = consumeString(range);
 590         if (!parsedValue)
 591             return nullptr;
 592         values-&gt;append(parsedValue.releaseNonNull());
 593     }
 594     if (values-&gt;length() &amp;&amp; values-&gt;length() % 2 == 0)
 595         return values;
 596     return nullptr;
 597 }
 598 
 599 class FontVariantLigaturesParser {
 600 public:
 601     FontVariantLigaturesParser()
 602         : m_sawCommonLigaturesValue(false)
 603         , m_sawDiscretionaryLigaturesValue(false)
 604         , m_sawHistoricalLigaturesValue(false)
 605         , m_sawContextualLigaturesValue(false)
 606         , m_result(CSSValueList::createSpaceSeparated())
 607     {
 608     }
 609 
 610     enum class ParseResult {
 611         ConsumedValue,
 612         DisallowedValue,
 613         UnknownValue
 614     };
 615 
 616     ParseResult consumeLigature(CSSParserTokenRange&amp; range)
 617     {
 618         CSSValueID valueID = range.peek().id();
 619         switch (valueID) {
 620         case CSSValueNoCommonLigatures:
 621         case CSSValueCommonLigatures:
 622             if (m_sawCommonLigaturesValue)
 623                 return ParseResult::DisallowedValue;
 624             m_sawCommonLigaturesValue = true;
 625             break;
 626         case CSSValueNoDiscretionaryLigatures:
 627         case CSSValueDiscretionaryLigatures:
 628             if (m_sawDiscretionaryLigaturesValue)
 629                 return ParseResult::DisallowedValue;
 630             m_sawDiscretionaryLigaturesValue = true;
 631             break;
 632         case CSSValueNoHistoricalLigatures:
 633         case CSSValueHistoricalLigatures:
 634             if (m_sawHistoricalLigaturesValue)
 635                 return ParseResult::DisallowedValue;
 636             m_sawHistoricalLigaturesValue = true;
 637             break;
 638         case CSSValueNoContextual:
 639         case CSSValueContextual:
 640             if (m_sawContextualLigaturesValue)
 641                 return ParseResult::DisallowedValue;
 642             m_sawContextualLigaturesValue = true;
 643             break;
 644         default:
 645             return ParseResult::UnknownValue;
 646         }
 647         m_result-&gt;append(consumeIdent(range).releaseNonNull());
 648         return ParseResult::ConsumedValue;
 649     }
 650 
 651     RefPtr&lt;CSSValue&gt; finalizeValue()
 652     {
 653         if (!m_result-&gt;length())
 654             return CSSValuePool::singleton().createIdentifierValue(CSSValueNormal);
 655         return WTFMove(m_result);
 656     }
 657 
 658 private:
 659     bool m_sawCommonLigaturesValue;
 660     bool m_sawDiscretionaryLigaturesValue;
 661     bool m_sawHistoricalLigaturesValue;
 662     bool m_sawContextualLigaturesValue;
 663     RefPtr&lt;CSSValueList&gt; m_result;
 664 };
 665 
 666 static RefPtr&lt;CSSValue&gt; consumeFontVariantLigatures(CSSParserTokenRange&amp; range)
 667 {
 668     if (range.peek().id() == CSSValueNormal || range.peek().id() == CSSValueNone)
 669         return consumeIdent(range);
 670 
 671     FontVariantLigaturesParser ligaturesParser;
 672     do {
 673         if (ligaturesParser.consumeLigature(range) !=
 674             FontVariantLigaturesParser::ParseResult::ConsumedValue)
 675             return nullptr;
 676     } while (!range.atEnd());
 677 
 678     return ligaturesParser.finalizeValue();
 679 }
 680 
 681 static RefPtr&lt;CSSValue&gt; consumeFontVariantEastAsian(CSSParserTokenRange&amp; range)
 682 {
 683     if (range.peek().id() == CSSValueNormal)
 684         return consumeIdent(range);
 685 
 686     RefPtr&lt;CSSValueList&gt; values = CSSValueList::createSpaceSeparated();
 687     FontVariantEastAsianVariant variant = FontVariantEastAsianVariant::Normal;
 688     FontVariantEastAsianWidth width = FontVariantEastAsianWidth::Normal;
 689     FontVariantEastAsianRuby ruby = FontVariantEastAsianRuby::Normal;
 690 
 691     while (!range.atEnd()) {
 692         if (range.peek().type() != IdentToken)
 693             return nullptr;
 694 
 695         auto id = range.peek().id();
 696 
 697         switch (id) {
 698         case CSSValueJis78:
 699             variant = FontVariantEastAsianVariant::Jis78;
 700             break;
 701         case CSSValueJis83:
 702             variant = FontVariantEastAsianVariant::Jis83;
 703             break;
 704         case CSSValueJis90:
 705             variant = FontVariantEastAsianVariant::Jis90;
 706             break;
 707         case CSSValueJis04:
 708             variant = FontVariantEastAsianVariant::Jis04;
 709             break;
 710         case CSSValueSimplified:
 711             variant = FontVariantEastAsianVariant::Simplified;
 712             break;
 713         case CSSValueTraditional:
 714             variant = FontVariantEastAsianVariant::Traditional;
 715             break;
 716         case CSSValueFullWidth:
 717             width = FontVariantEastAsianWidth::Full;
 718             break;
 719         case CSSValueProportionalWidth:
 720             width = FontVariantEastAsianWidth::Proportional;
 721             break;
 722         case CSSValueRuby:
 723             ruby = FontVariantEastAsianRuby::Yes;
 724             break;
 725         default:
 726             return nullptr;
 727         }
 728 
 729         range.consumeIncludingWhitespace();
 730     }
 731 
 732     switch (variant) {
 733     case FontVariantEastAsianVariant::Normal:
 734         break;
 735     case FontVariantEastAsianVariant::Jis78:
 736         values-&gt;append(CSSValuePool::singleton().createIdentifierValue(CSSValueJis78));
 737         break;
 738     case FontVariantEastAsianVariant::Jis83:
 739         values-&gt;append(CSSValuePool::singleton().createIdentifierValue(CSSValueJis83));
 740         break;
 741     case FontVariantEastAsianVariant::Jis90:
 742         values-&gt;append(CSSValuePool::singleton().createIdentifierValue(CSSValueJis90));
 743         break;
 744     case FontVariantEastAsianVariant::Jis04:
 745         values-&gt;append(CSSValuePool::singleton().createIdentifierValue(CSSValueJis04));
 746         break;
 747     case FontVariantEastAsianVariant::Simplified:
 748         values-&gt;append(CSSValuePool::singleton().createIdentifierValue(CSSValueSimplified));
 749         break;
 750     case FontVariantEastAsianVariant::Traditional:
 751         values-&gt;append(CSSValuePool::singleton().createIdentifierValue(CSSValueTraditional));
 752         break;
 753     }
 754 
 755     switch (width) {
 756     case FontVariantEastAsianWidth::Normal:
 757         break;
 758     case FontVariantEastAsianWidth::Full:
 759         values-&gt;append(CSSValuePool::singleton().createIdentifierValue(CSSValueFullWidth));
 760         break;
 761     case FontVariantEastAsianWidth::Proportional:
 762         values-&gt;append(CSSValuePool::singleton().createIdentifierValue(CSSValueProportionalWidth));
 763         break;
 764     }
 765 
 766     switch (ruby) {
 767     case FontVariantEastAsianRuby::Normal:
 768         break;
 769     case FontVariantEastAsianRuby::Yes:
 770         values-&gt;append(CSSValuePool::singleton().createIdentifierValue(CSSValueRuby));
 771     }
 772 
 773     if (!values-&gt;length())
 774         return nullptr;
 775 
 776     return values;
 777 }
 778 
 779 static RefPtr&lt;CSSPrimitiveValue&gt; consumeFontVariantCaps(CSSParserTokenRange&amp; range)
 780 {
 781     return consumeIdent&lt;CSSValueNormal, CSSValueSmallCaps, CSSValueAllSmallCaps,
 782         CSSValuePetiteCaps, CSSValueAllPetiteCaps,
 783         CSSValueUnicase, CSSValueTitlingCaps&gt;(range);
 784 }
 785 
 786 static RefPtr&lt;CSSPrimitiveValue&gt; consumeFontVariantAlternates(CSSParserTokenRange&amp; range)
 787 {
 788     return consumeIdent&lt;CSSValueNormal, CSSValueHistoricalForms&gt;(range);
 789 }
 790 
 791 static RefPtr&lt;CSSPrimitiveValue&gt; consumeFontVariantPosition(CSSParserTokenRange&amp; range)
 792 {
 793     return consumeIdent&lt;CSSValueNormal, CSSValueSub, CSSValueSuper&gt;(range);
 794 }
 795 
 796 class FontVariantNumericParser {
 797 public:
 798     FontVariantNumericParser()
 799         : m_sawNumericFigureValue(false)
 800         , m_sawNumericSpacingValue(false)
 801         , m_sawNumericFractionValue(false)
 802         , m_sawOrdinalValue(false)
 803         , m_sawSlashedZeroValue(false)
 804         , m_result(CSSValueList::createSpaceSeparated())
 805     {
 806     }
 807 
 808     enum class ParseResult {
 809         ConsumedValue,
 810         DisallowedValue,
 811         UnknownValue
 812     };
 813 
 814     ParseResult consumeNumeric(CSSParserTokenRange&amp; range)
 815     {
 816         CSSValueID valueID = range.peek().id();
 817         switch (valueID) {
 818         case CSSValueLiningNums:
 819         case CSSValueOldstyleNums:
 820             if (m_sawNumericFigureValue)
 821                 return ParseResult::DisallowedValue;
 822             m_sawNumericFigureValue = true;
 823             break;
 824         case CSSValueProportionalNums:
 825         case CSSValueTabularNums:
 826             if (m_sawNumericSpacingValue)
 827                 return ParseResult::DisallowedValue;
 828             m_sawNumericSpacingValue = true;
 829             break;
 830         case CSSValueDiagonalFractions:
 831         case CSSValueStackedFractions:
 832             if (m_sawNumericFractionValue)
 833                 return ParseResult::DisallowedValue;
 834             m_sawNumericFractionValue = true;
 835             break;
 836         case CSSValueOrdinal:
 837             if (m_sawOrdinalValue)
 838                 return ParseResult::DisallowedValue;
 839             m_sawOrdinalValue = true;
 840             break;
 841         case CSSValueSlashedZero:
 842             if (m_sawSlashedZeroValue)
 843                 return ParseResult::DisallowedValue;
 844             m_sawSlashedZeroValue = true;
 845             break;
 846         default:
 847             return ParseResult::UnknownValue;
 848         }
 849         m_result-&gt;append(consumeIdent(range).releaseNonNull());
 850         return ParseResult::ConsumedValue;
 851     }
 852 
 853     RefPtr&lt;CSSValue&gt; finalizeValue()
 854     {
 855         if (!m_result-&gt;length())
 856             return CSSValuePool::singleton().createIdentifierValue(CSSValueNormal);
 857         return WTFMove(m_result);
 858     }
 859 
 860 
 861 private:
 862     bool m_sawNumericFigureValue;
 863     bool m_sawNumericSpacingValue;
 864     bool m_sawNumericFractionValue;
 865     bool m_sawOrdinalValue;
 866     bool m_sawSlashedZeroValue;
 867     RefPtr&lt;CSSValueList&gt; m_result;
 868 };
 869 
 870 static RefPtr&lt;CSSValue&gt; consumeFontVariantNumeric(CSSParserTokenRange&amp; range)
 871 {
 872     if (range.peek().id() == CSSValueNormal)
 873         return consumeIdent(range);
 874 
 875     FontVariantNumericParser numericParser;
 876     do {
 877         if (numericParser.consumeNumeric(range) !=
 878             FontVariantNumericParser::ParseResult::ConsumedValue)
 879             return nullptr;
 880     } while (!range.atEnd());
 881 
 882     return numericParser.finalizeValue();
 883 }
 884 
 885 static RefPtr&lt;CSSPrimitiveValue&gt; consumeFontVariantCSS21(CSSParserTokenRange&amp; range)
 886 {
 887     return consumeIdent&lt;CSSValueNormal, CSSValueSmallCaps&gt;(range);
 888 }
 889 
 890 static RefPtr&lt;CSSPrimitiveValue&gt; consumeFontWeightKeywordValue(CSSParserTokenRange&amp; range)
 891 {
 892     return consumeIdent&lt;CSSValueNormal, CSSValueBold, CSSValueBolder, CSSValueLighter&gt;(range);
 893 }
 894 
 895 static RefPtr&lt;CSSPrimitiveValue&gt; consumeFontWeight(CSSParserTokenRange&amp; range)
 896 {
 897     if (auto result = consumeFontWeightKeywordValue(range))
 898         return result;
 899     return consumeFontWeightNumber(range);
 900 }
 901 
 902 #if ENABLE(VARIATION_FONTS)
 903 static RefPtr&lt;CSSValue&gt; consumeFontWeightRange(CSSParserTokenRange&amp; range)
 904 {
 905     if (auto result = consumeFontWeightKeywordValue(range))
 906         return result;
 907     auto firstNumber = consumeFontWeightNumber(range);
 908     if (!firstNumber)
 909         return nullptr;
 910     if (range.atEnd())
 911         return firstNumber;
 912     auto secondNumber = consumeFontWeightNumber(range);
 913     if (!secondNumber || firstNumber-&gt;floatValue() &gt; secondNumber-&gt;floatValue())
 914         return nullptr;
 915     auto result = CSSValueList::createSpaceSeparated();
 916     result-&gt;append(firstNumber.releaseNonNull());
 917     result-&gt;append(secondNumber.releaseNonNull());
 918     return RefPtr&lt;CSSValue&gt;(WTFMove(result));
 919 }
 920 #endif
 921 
 922 static RefPtr&lt;CSSPrimitiveValue&gt; consumeFontStretchKeywordValue(CSSParserTokenRange&amp; range)
 923 {
 924     return consumeIdent&lt;CSSValueUltraCondensed, CSSValueExtraCondensed, CSSValueCondensed, CSSValueSemiCondensed, CSSValueNormal, CSSValueSemiExpanded, CSSValueExpanded, CSSValueExtraExpanded, CSSValueUltraExpanded&gt;(range);
 925 }
 926 
 927 #if ENABLE(VARIATION_FONTS)
 928 static bool fontStretchIsWithinRange(float stretch)
 929 {
 930     return stretch &gt; 0;
 931 }
 932 #endif
 933 
 934 static RefPtr&lt;CSSPrimitiveValue&gt; consumeFontStretch(CSSParserTokenRange&amp; range)
 935 {
 936     if (auto result = consumeFontStretchKeywordValue(range))
 937         return result;
 938 #if ENABLE(VARIATION_FONTS)
 939     if (auto percent = consumePercent(range, ValueRangeNonNegative))
 940         return fontStretchIsWithinRange(percent-&gt;value&lt;float&gt;()) ? percent : nullptr;
 941 #endif
 942     return nullptr;
 943 }
 944 
 945 #if ENABLE(VARIATION_FONTS)
 946 static RefPtr&lt;CSSValue&gt; consumeFontStretchRange(CSSParserTokenRange&amp; range)
 947 {
 948     if (auto result = consumeFontStretchKeywordValue(range))
 949         return result;
 950     auto firstPercent = consumePercent(range, ValueRangeNonNegative);
 951     if (!firstPercent || !fontStretchIsWithinRange(firstPercent-&gt;value&lt;float&gt;()))
 952         return nullptr;
 953     if (range.atEnd())
 954         return firstPercent;
 955     auto secondPercent = consumePercent(range, ValueRangeNonNegative);
 956     if (!secondPercent || !fontStretchIsWithinRange(secondPercent-&gt;value&lt;float&gt;()) || firstPercent-&gt;floatValue() &gt; secondPercent-&gt;floatValue())
 957         return nullptr;
 958     auto result = CSSValueList::createSpaceSeparated();
 959     result-&gt;append(firstPercent.releaseNonNull());
 960     result-&gt;append(secondPercent.releaseNonNull());
 961     return RefPtr&lt;CSSValue&gt;(WTFMove(result));
 962 }
 963 #endif
 964 
 965 static RefPtr&lt;CSSPrimitiveValue&gt; consumeFontStyleKeywordValue(CSSParserTokenRange&amp; range)
 966 {
 967     return consumeIdent&lt;CSSValueNormal, CSSValueItalic, CSSValueOblique&gt;(range);
 968 }
 969 
 970 #if ENABLE(VARIATION_FONTS)
 971 static bool fontStyleIsWithinRange(float oblique)
 972 {
 973     return oblique &gt; -90 &amp;&amp; oblique &lt; 90;
 974 }
 975 #endif
 976 
 977 static RefPtr&lt;CSSFontStyleValue&gt; consumeFontStyle(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode)
 978 {
 979     auto result = consumeFontStyleKeywordValue(range);
 980     if (!result)
 981         return nullptr;
 982 
 983     auto valueID = result-&gt;valueID();
 984     if (valueID == CSSValueNormal || valueID == CSSValueItalic)
 985         return CSSFontStyleValue::create(CSSValuePool::singleton().createIdentifierValue(valueID));
 986     ASSERT(result-&gt;valueID() == CSSValueOblique);
 987 #if ENABLE(VARIATION_FONTS)
 988     if (!range.atEnd()) {
 989         if (auto angle = consumeAngle(range, cssParserMode)) {
 990             if (fontStyleIsWithinRange(angle-&gt;value&lt;float&gt;(CSSPrimitiveValue::CSS_DEG)))
 991                 return CSSFontStyleValue::create(CSSValuePool::singleton().createIdentifierValue(CSSValueOblique), WTFMove(angle));
 992             return nullptr;
 993         }
 994     }
 995 #else
 996     UNUSED_PARAM(cssParserMode);
 997 #endif
 998     return CSSFontStyleValue::create(CSSValuePool::singleton().createIdentifierValue(CSSValueOblique));
 999 }
1000 
1001 #if ENABLE(VARIATION_FONTS)
1002 static RefPtr&lt;CSSFontStyleRangeValue&gt; consumeFontStyleRange(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode)
1003 {
1004     auto keyword = consumeFontStyleKeywordValue(range);
1005     if (!keyword)
1006         return nullptr;
1007 
1008     if (keyword-&gt;valueID() != CSSValueOblique || range.atEnd())
1009         return CSSFontStyleRangeValue::create(keyword.releaseNonNull());
1010 
1011     if (auto firstAngle = consumeAngle(range, cssParserMode)) {
1012         if (!fontStyleIsWithinRange(firstAngle-&gt;value&lt;float&gt;(CSSPrimitiveValue::CSS_DEG)))
1013             return nullptr;
1014         if (range.atEnd()) {
1015             auto result = CSSValueList::createSpaceSeparated();
1016             result-&gt;append(firstAngle.releaseNonNull());
1017             return CSSFontStyleRangeValue::create(keyword.releaseNonNull(), WTFMove(result));
1018         }
1019         auto secondAngle = consumeAngle(range, cssParserMode);
1020         if (!secondAngle || !fontStyleIsWithinRange(secondAngle-&gt;value&lt;float&gt;(CSSPrimitiveValue::CSS_DEG)) || firstAngle-&gt;floatValue(CSSPrimitiveValue::CSS_DEG) &gt; secondAngle-&gt;floatValue(CSSPrimitiveValue::CSS_DEG))
1021             return nullptr;
1022         auto result = CSSValueList::createSpaceSeparated();
1023         result-&gt;append(firstAngle.releaseNonNull());
1024         result-&gt;append(secondAngle.releaseNonNull());
1025         return CSSFontStyleRangeValue::create(keyword.releaseNonNull(), WTFMove(result));
1026     }
1027 
1028     return nullptr;
1029 }
1030 #endif
1031 
1032 static String concatenateFamilyName(CSSParserTokenRange&amp; range)
1033 {
1034     StringBuilder builder;
1035     bool addedSpace = false;
1036     const CSSParserToken&amp; firstToken = range.peek();
1037     while (range.peek().type() == IdentToken) {
1038         if (!builder.isEmpty()) {
1039             builder.append(&#39; &#39;);
1040             addedSpace = true;
1041         }
1042         builder.append(range.consumeIncludingWhitespace().value());
1043     }
1044     if (!addedSpace &amp;&amp; isCSSWideKeyword(firstToken.id()))
1045         return String();
1046     return builder.toString();
1047 }
1048 
1049 static RefPtr&lt;CSSValue&gt; consumeFamilyName(CSSParserTokenRange&amp; range)
1050 {
1051     if (range.peek().type() == StringToken)
1052         return CSSValuePool::singleton().createFontFamilyValue(range.consumeIncludingWhitespace().value().toString());
1053     if (range.peek().type() != IdentToken)
1054         return nullptr;
1055     String familyName = concatenateFamilyName(range);
1056     if (familyName.isNull())
1057         return nullptr;
1058     return CSSValuePool::singleton().createFontFamilyValue(familyName);
1059 }
1060 
1061 static RefPtr&lt;CSSValue&gt; consumeGenericFamily(CSSParserTokenRange&amp; range)
1062 {
1063     return consumeIdentRange(range, CSSValueSerif, CSSValueWebkitBody);
1064 }
1065 
1066 static RefPtr&lt;CSSValueList&gt; consumeFontFamily(CSSParserTokenRange&amp; range)
1067 {
1068     RefPtr&lt;CSSValueList&gt; list = CSSValueList::createCommaSeparated();
1069     do {
1070         if (auto parsedValue = consumeGenericFamily(range))
1071             list-&gt;append(parsedValue.releaseNonNull());
1072         else {
1073             if (auto parsedValue = consumeFamilyName(range))
1074                 list-&gt;append(parsedValue.releaseNonNull());
1075             else
1076                 return nullptr;
1077         }
1078     } while (consumeCommaIncludingWhitespace(range));
1079     return list;
1080 }
1081 
1082 static RefPtr&lt;CSSValueList&gt; consumeFontFamilyDescriptor(CSSParserTokenRange&amp; range)
1083 {
1084     // FIXME-NEWPARSER: For compatibility with the old parser, we have to make
1085     // a list here, even though the list always contains only a single family name.
1086     // Once the old parser is gone, we can delete this function, make the caller
1087     // use consumeFamilyName instead, and then patch the @font-face code to
1088     // not expect a list with a single name in it.
1089     RefPtr&lt;CSSValueList&gt; list = CSSValueList::createCommaSeparated();
1090     RefPtr&lt;CSSValue&gt; parsedValue = consumeFamilyName(range);
1091     if (parsedValue)
1092         list-&gt;append(parsedValue.releaseNonNull());
1093 
1094     if (!range.atEnd() || !list-&gt;length())
1095         return nullptr;
1096 
1097     return list;
1098 }
1099 
1100 static RefPtr&lt;CSSValue&gt; consumeFontSynthesis(CSSParserTokenRange&amp; range)
1101 {
1102     // none | [ weight || style || small-caps ]
1103     CSSValueID id = range.peek().id();
1104     if (id == CSSValueNone)
1105         return consumeIdent(range);
1106 
1107     RefPtr&lt;CSSValueList&gt; list = CSSValueList::createSpaceSeparated();
1108     while (true) {
1109         auto ident = consumeIdent&lt;CSSValueWeight, CSSValueStyle, CSSValueSmallCaps&gt;(range);
1110         if (!ident)
1111             break;
1112         if (list-&gt;hasValue(ident.get()))
1113             return nullptr;
1114         list-&gt;append(ident.releaseNonNull());
1115     }
1116 
1117     if (!list-&gt;length())
1118         return nullptr;
1119     return list;
1120 }
1121 
1122 static RefPtr&lt;CSSValue&gt; consumeLetterSpacing(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode)
1123 {
1124     if (range.peek().id() == CSSValueNormal)
1125         return consumeIdent(range);
1126 
1127     return consumeLength(range, cssParserMode, ValueRangeAll, UnitlessQuirk::Allow);
1128 }
1129 
1130 static RefPtr&lt;CSSValue&gt; consumeWordSpacing(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode)
1131 {
1132     if (range.peek().id() == CSSValueNormal)
1133         return consumeIdent(range);
1134 
1135     return consumeLengthOrPercent(range, cssParserMode, ValueRangeAll, UnitlessQuirk::Allow);
1136 }
1137 
1138 static RefPtr&lt;CSSValue&gt; consumeTabSize(CSSParserTokenRange&amp; range, CSSParserMode)
1139 {
1140     return consumeInteger(range, 0);
1141 }
1142 
1143 #if ENABLE(TEXT_AUTOSIZING)
1144 static RefPtr&lt;CSSValue&gt; consumeTextSizeAdjust(CSSParserTokenRange&amp; range, CSSParserMode /* cssParserMode */)
1145 {
1146     if (range.peek().id() == CSSValueAuto)
1147         return consumeIdent(range);
1148     if (range.peek().id() == CSSValueNone)
1149         return consumeIdent(range);
1150     return consumePercent(range, ValueRangeNonNegative);
1151 }
1152 #endif
1153 
1154 static RefPtr&lt;CSSValue&gt; consumeFontSize(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode, UnitlessQuirk unitless = UnitlessQuirk::Forbid)
1155 {
1156     if (range.peek().id() &gt;= CSSValueXxSmall &amp;&amp; range.peek().id() &lt;= CSSValueLarger)
1157         return consumeIdent(range);
1158     return consumeLengthOrPercent(range, cssParserMode, ValueRangeNonNegative, unitless);
1159 }
1160 
1161 static RefPtr&lt;CSSPrimitiveValue&gt; consumeLineHeight(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode)
1162 {
1163     if (range.peek().id() == CSSValueNormal)
1164         return consumeIdent(range);
1165 
1166     RefPtr&lt;CSSPrimitiveValue&gt; lineHeight = consumeNumber(range, ValueRangeNonNegative);
1167     if (lineHeight)
1168         return lineHeight;
1169     return consumeLengthOrPercent(range, cssParserMode, ValueRangeNonNegative);
1170 }
1171 
1172 template&lt;typename... Args&gt;
1173 static Ref&lt;CSSPrimitiveValue&gt; createPrimitiveValuePair(Args&amp;&amp;... args)
1174 {
1175     return CSSValuePool::singleton().createValue(Pair::create(std::forward&lt;Args&gt;(args)...));
1176 }
1177 
1178 
1179 static RefPtr&lt;CSSValue&gt; consumeCounter(CSSParserTokenRange&amp; range, int defaultValue)
1180 {
1181     if (range.peek().id() == CSSValueNone)
1182         return consumeIdent(range);
1183 
1184     RefPtr&lt;CSSValueList&gt; list = CSSValueList::createSpaceSeparated();
1185     do {
1186         RefPtr&lt;CSSPrimitiveValue&gt; counterName = consumeCustomIdent(range);
1187         if (!counterName)
1188             return nullptr;
1189         int i = defaultValue;
1190         if (RefPtr&lt;CSSPrimitiveValue&gt; counterValue = consumeInteger(range))
1191             i = counterValue-&gt;intValue();
1192         list-&gt;append(createPrimitiveValuePair(counterName.releaseNonNull(), CSSPrimitiveValue::create(i, CSSPrimitiveValue::UnitType::CSS_NUMBER), Pair::IdenticalValueEncoding::Coalesce));
1193     } while (!range.atEnd());
1194     return list;
1195 }
1196 
1197 static RefPtr&lt;CSSValue&gt; consumePageSize(CSSParserTokenRange&amp; range)
1198 {
1199     return consumeIdent&lt;CSSValueA3, CSSValueA4, CSSValueA5, CSSValueB4, CSSValueB5, CSSValueLedger, CSSValueLegal, CSSValueLetter&gt;(range);
1200 }
1201 
1202 static RefPtr&lt;CSSValueList&gt; consumeSize(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode)
1203 {
1204     RefPtr&lt;CSSValueList&gt; result = CSSValueList::createSpaceSeparated();
1205 
1206     if (range.peek().id() == CSSValueAuto) {
1207         result-&gt;append(consumeIdent(range).releaseNonNull());
1208         return result;
1209     }
1210 
1211     if (RefPtr&lt;CSSValue&gt; width = consumeLength(range, cssParserMode, ValueRangeNonNegative)) {
1212         RefPtr&lt;CSSValue&gt; height = consumeLength(range, cssParserMode, ValueRangeNonNegative);
1213         result-&gt;append(width.releaseNonNull());
1214         if (height)
1215             result-&gt;append(height.releaseNonNull());
1216         return result;
1217     }
1218 
1219     RefPtr&lt;CSSValue&gt; pageSize = consumePageSize(range);
1220     RefPtr&lt;CSSValue&gt; orientation = consumeIdent&lt;CSSValuePortrait, CSSValueLandscape&gt;(range);
1221     if (!pageSize)
1222         pageSize = consumePageSize(range);
1223 
1224     if (!orientation &amp;&amp; !pageSize)
1225         return nullptr;
1226     if (pageSize)
1227         result-&gt;append(pageSize.releaseNonNull());
1228     if (orientation)
1229         result-&gt;append(orientation.releaseNonNull());
1230     return result;
1231 }
1232 
1233 static RefPtr&lt;CSSValue&gt; consumeTextIndent(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode)
1234 {
1235     // [ &lt;length&gt; | &lt;percentage&gt; ] &amp;&amp; hanging? &amp;&amp; each-line?
1236     // Keywords only allowed when css3Text is enabled.
1237     RefPtr&lt;CSSValueList&gt; list = CSSValueList::createSpaceSeparated();
1238 
1239     bool hasLengthOrPercentage = false;
1240 //    bool hasEachLine = false;
1241     bool hasHanging = false;
1242 
1243     do {
1244         if (!hasLengthOrPercentage) {
1245             if (RefPtr&lt;CSSValue&gt; textIndent = consumeLengthOrPercent(range, cssParserMode, ValueRangeAll, UnitlessQuirk::Allow)) {
1246                 list-&gt;append(*textIndent);
1247                 hasLengthOrPercentage = true;
1248                 continue;
1249             }
1250         }
1251 
1252         CSSValueID id = range.peek().id();
1253  /* FIXME-NEWPARSER: We don&#39;t support this yet.
1254         if (!hasEachLine &amp;&amp; id == CSSValueEachLine) {
1255             list-&gt;append(*consumeIdent(range));
1256             hasEachLine = true;
1257             continue;
1258         }
1259 */
1260 
1261         if (!hasHanging &amp;&amp; id == CSSValueHanging) {
1262             list-&gt;append(consumeIdent(range).releaseNonNull());
1263             hasHanging = true;
1264             continue;
1265         }
1266 
1267         return nullptr;
1268     } while (!range.atEnd());
1269 
1270     if (!hasLengthOrPercentage)
1271         return nullptr;
1272 
1273     return list;
1274 }
1275 
1276 static bool validWidthOrHeightKeyword(CSSValueID id, const CSSParserContext&amp; /*context*/)
1277 {
1278     if (id == CSSValueIntrinsic || id == CSSValueMinIntrinsic || id == CSSValueMinContent || id == CSSValueWebkitMinContent || id == CSSValueMaxContent || id == CSSValueWebkitMaxContent || id == CSSValueWebkitFillAvailable || id == CSSValueFitContent || id == CSSValueWebkitFitContent) {
1279         return true;
1280     }
1281     return false;
1282 }
1283 
1284 static RefPtr&lt;CSSValue&gt; consumeMaxWidthOrHeight(CSSParserTokenRange&amp; range, const CSSParserContext&amp; context, UnitlessQuirk unitless = UnitlessQuirk::Forbid)
1285 {
1286     if (range.peek().id() == CSSValueNone || validWidthOrHeightKeyword(range.peek().id(), context))
1287         return consumeIdent(range);
1288     return consumeLengthOrPercent(range, context.mode, ValueRangeNonNegative, unitless);
1289 }
1290 
1291 static RefPtr&lt;CSSValue&gt; consumeWidthOrHeight(CSSParserTokenRange&amp; range, const CSSParserContext&amp; context, UnitlessQuirk unitless = UnitlessQuirk::Forbid)
1292 {
1293     if (range.peek().id() == CSSValueAuto || validWidthOrHeightKeyword(range.peek().id(), context))
1294         return consumeIdent(range);
1295     return consumeLengthOrPercent(range, context.mode, ValueRangeNonNegative, unitless);
1296 }
1297 
1298 static RefPtr&lt;CSSValue&gt; consumeMarginOrOffset(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode, UnitlessQuirk unitless)
1299 {
1300     if (range.peek().id() == CSSValueAuto)
1301         return consumeIdent(range);
1302     return consumeLengthOrPercent(range, cssParserMode, ValueRangeAll, unitless);
1303 }
1304 
1305 static RefPtr&lt;CSSPrimitiveValue&gt; consumeClipComponent(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode)
1306 {
1307     if (range.peek().id() == CSSValueAuto)
1308         return consumeIdent(range);
1309     return consumeLength(range, cssParserMode, ValueRangeAll, UnitlessQuirk::Allow);
1310 }
1311 
1312 static RefPtr&lt;CSSValue&gt; consumeClip(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode)
1313 {
1314     if (range.peek().id() == CSSValueAuto)
1315         return consumeIdent(range);
1316 
1317     if (range.peek().functionId() != CSSValueRect)
1318         return nullptr;
1319 
1320     CSSParserTokenRange args = consumeFunction(range);
1321     // rect(t, r, b, l) || rect(t r b l)
1322     RefPtr&lt;CSSPrimitiveValue&gt; top = consumeClipComponent(args, cssParserMode);
1323     if (!top)
1324         return nullptr;
1325     bool needsComma = consumeCommaIncludingWhitespace(args);
1326     RefPtr&lt;CSSPrimitiveValue&gt; right = consumeClipComponent(args, cssParserMode);
1327     if (!right || (needsComma &amp;&amp; !consumeCommaIncludingWhitespace(args)))
1328         return nullptr;
1329     RefPtr&lt;CSSPrimitiveValue&gt; bottom = consumeClipComponent(args, cssParserMode);
1330     if (!bottom || (needsComma &amp;&amp; !consumeCommaIncludingWhitespace(args)))
1331         return nullptr;
1332     RefPtr&lt;CSSPrimitiveValue&gt; left = consumeClipComponent(args, cssParserMode);
1333     if (!left || !args.atEnd())
1334         return nullptr;
1335 
1336     auto rect = Rect::create();
1337     rect-&gt;setLeft(left.releaseNonNull());
1338     rect-&gt;setTop(top.releaseNonNull());
1339     rect-&gt;setRight(right.releaseNonNull());
1340     rect-&gt;setBottom(bottom.releaseNonNull());
1341     return CSSValuePool::singleton().createValue(WTFMove(rect));
1342 }
1343 
1344 #if ENABLE(POINTER_EVENTS)
1345 static RefPtr&lt;CSSValue&gt; consumeTouchAction(CSSParserTokenRange&amp; range)
1346 {
1347     CSSValueID id = range.peek().id();
1348     if (id == CSSValueNone || id == CSSValueAuto || id == CSSValueManipulation)
1349         return consumeIdent(range);
1350 
1351     auto list = CSSValueList::createSpaceSeparated();
1352     while (true) {
1353         auto ident = consumeIdent&lt;CSSValuePanX, CSSValuePanY, CSSValuePinchZoom&gt;(range);
1354         if (!ident)
1355             break;
1356         if (list-&gt;hasValue(ident.get()))
1357             return nullptr;
1358         list-&gt;append(ident.releaseNonNull());
1359     }
1360 
1361     if (!list-&gt;length())
1362         return nullptr;
1363     return list;
1364 }
1365 #endif
1366 
1367 static RefPtr&lt;CSSPrimitiveValue&gt; consumeLineClamp(CSSParserTokenRange&amp; range)
1368 {
1369     RefPtr&lt;CSSPrimitiveValue&gt; clampValue = consumePercent(range, ValueRangeNonNegative);
1370     if (clampValue)
1371         return clampValue;
1372     // When specifying number of lines, don&#39;t allow 0 as a valid value.
1373     return consumePositiveInteger(range);
1374 }
1375 
1376 static RefPtr&lt;CSSValue&gt; consumeAutoOrString(CSSParserTokenRange&amp; range)
1377 {
1378     if (range.peek().id() == CSSValueAuto)
1379         return consumeIdent(range);
1380     return consumeString(range);
1381 }
1382 
1383 static RefPtr&lt;CSSValue&gt; consumeHyphenateLimit(CSSParserTokenRange&amp; range, CSSValueID valueID)
1384 {
1385     if (range.peek().id() == valueID)
1386         return consumeIdent(range);
1387     return consumeNumber(range, ValueRangeNonNegative);
1388 }
1389 
1390 static RefPtr&lt;CSSValue&gt; consumeColumnWidth(CSSParserTokenRange&amp; range)
1391 {
1392     if (range.peek().id() == CSSValueAuto)
1393         return consumeIdent(range);
1394     // Always parse lengths in strict mode here, since it would be ambiguous otherwise when used in
1395     // the &#39;columns&#39; shorthand property.
1396     RefPtr&lt;CSSPrimitiveValue&gt; columnWidth = consumeLength(range, HTMLStandardMode, ValueRangeNonNegative);
1397     if (!columnWidth || (!columnWidth-&gt;isCalculated() &amp;&amp; !columnWidth-&gt;doubleValue()) || (columnWidth-&gt;cssCalcValue() &amp;&amp; !columnWidth-&gt;cssCalcValue()-&gt;doubleValue()))
1398         return nullptr;
1399     return columnWidth;
1400 }
1401 
1402 static RefPtr&lt;CSSValue&gt; consumeColumnCount(CSSParserTokenRange&amp; range)
1403 {
1404     if (range.peek().id() == CSSValueAuto)
1405         return consumeIdent(range);
1406     return consumePositiveInteger(range);
1407 }
1408 
1409 static RefPtr&lt;CSSValue&gt; consumeGapLength(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode)
1410 {
1411     if (range.peek().id() == CSSValueNormal)
1412         return consumeIdent(range);
1413     return consumeLengthOrPercent(range, cssParserMode, ValueRangeNonNegative);
1414 }
1415 
1416 static RefPtr&lt;CSSValue&gt; consumeColumnSpan(CSSParserTokenRange&amp; range)
1417 {
1418     return consumeIdent&lt;CSSValueAll, CSSValueNone&gt;(range);
1419 }
1420 
1421 static RefPtr&lt;CSSValue&gt; consumeZoom(CSSParserTokenRange&amp; range, const CSSParserContext&amp; /*context*/)
1422 {
1423     const CSSParserToken&amp; token = range.peek();
1424     RefPtr&lt;CSSPrimitiveValue&gt; zoom;
1425     if (token.type() == IdentToken)
1426         zoom = consumeIdent&lt;CSSValueNormal, CSSValueReset, CSSValueDocument&gt;(range);
1427     else {
1428         zoom = consumePercent(range, ValueRangeNonNegative);
1429         if (!zoom)
1430             zoom = consumeNumber(range, ValueRangeNonNegative);
1431     }
1432     return zoom;
1433 }
1434 
1435 static RefPtr&lt;CSSValue&gt; consumeAnimationIterationCount(CSSParserTokenRange&amp; range)
1436 {
1437     if (range.peek().id() == CSSValueInfinite)
1438         return consumeIdent(range);
1439     return consumeNumber(range, ValueRangeNonNegative);
1440 }
1441 
1442 static RefPtr&lt;CSSValue&gt; consumeAnimationName(CSSParserTokenRange&amp; range)
1443 {
1444     if (range.peek().id() == CSSValueNone)
1445         return consumeIdent(range);
1446 
1447     if (range.peek().type() == StringToken) {
1448         const CSSParserToken&amp; token = range.consumeIncludingWhitespace();
1449         if (equalIgnoringASCIICase(token.value(), &quot;none&quot;))
1450             return CSSValuePool::singleton().createIdentifierValue(CSSValueNone);
1451         // FIXME-NEWPARSER: Want to use a CSSCustomIdentValue here eventually.
1452         return CSSValuePool::singleton().createValue(token.value().toString(), CSSPrimitiveValue::UnitType::CSS_STRING);
1453     }
1454 
1455     return consumeCustomIdent(range);
1456 }
1457 
1458 static RefPtr&lt;CSSValue&gt; consumeTransitionProperty(CSSParserTokenRange&amp; range)
1459 {
1460     const CSSParserToken&amp; token = range.peek();
1461     if (token.type() != IdentToken)
1462         return nullptr;
1463     if (token.id() == CSSValueNone)
1464         return consumeIdent(range);
1465 
1466     if (CSSPropertyID property = token.parseAsCSSPropertyID()) {
1467         range.consumeIncludingWhitespace();
1468 
1469         // FIXME-NEWPARSER: No reason why we can&#39;t use the &quot;all&quot; property now that it exists.
1470         // The old parser used a value keyword for &quot;all&quot;, though, since it predated support for
1471         // the property.
1472         if (property == CSSPropertyAll)
1473             return CSSValuePool::singleton().createIdentifierValue(CSSValueAll);
1474 
1475         // FIXME-NEWPARSER: Want to use a CSSCustomIdentValue here eventually.
1476         return CSSValuePool::singleton().createIdentifierValue(property);
1477     }
1478     return consumeCustomIdent(range);
1479 }
1480 
1481 
1482 static RefPtr&lt;CSSValue&gt; consumeSteps(CSSParserTokenRange&amp; range)
1483 {
1484     ASSERT(range.peek().functionId() == CSSValueSteps);
1485     CSSParserTokenRange rangeCopy = range;
1486     CSSParserTokenRange args = consumeFunction(rangeCopy);
1487 
1488     RefPtr&lt;CSSPrimitiveValue&gt; steps = consumePositiveInteger(args);
1489     if (!steps)
1490         return nullptr;
1491 
1492     // FIXME-NEWPARSER: Support the middle value and change from a boolean to an enum.
1493     bool stepAtStart = false;
1494     if (consumeCommaIncludingWhitespace(args)) {
1495         switch (args.consumeIncludingWhitespace().id()) {
1496             case CSSValueStart:
1497                 stepAtStart = true;
1498             break;
1499             case CSSValueEnd:
1500                 stepAtStart = false;
1501                 break;
1502             default:
1503                 return nullptr;
1504         }
1505     }
1506 
1507     if (!args.atEnd())
1508         return nullptr;
1509 
1510     range = rangeCopy;
1511     return CSSStepsTimingFunctionValue::create(steps-&gt;intValue(), stepAtStart);
1512 }
1513 
1514 static RefPtr&lt;CSSValue&gt; consumeCubicBezier(CSSParserTokenRange&amp; range)
1515 {
1516     ASSERT(range.peek().functionId() == CSSValueCubicBezier);
1517     CSSParserTokenRange rangeCopy = range;
1518     CSSParserTokenRange args = consumeFunction(rangeCopy);
1519 
1520     double x1, y1, x2, y2;
1521     if (consumeNumberRaw(args, x1)
1522         &amp;&amp; x1 &gt;= 0 &amp;&amp; x1 &lt;= 1
1523         &amp;&amp; consumeCommaIncludingWhitespace(args)
1524         &amp;&amp; consumeNumberRaw(args, y1)
1525         &amp;&amp; consumeCommaIncludingWhitespace(args)
1526         &amp;&amp; consumeNumberRaw(args, x2)
1527         &amp;&amp; x2 &gt;= 0 &amp;&amp; x2 &lt;= 1
1528         &amp;&amp; consumeCommaIncludingWhitespace(args)
1529         &amp;&amp; consumeNumberRaw(args, y2)
1530         &amp;&amp; args.atEnd()) {
1531         range = rangeCopy;
1532         return CSSCubicBezierTimingFunctionValue::create(x1, y1, x2, y2);
1533     }
1534 
1535     return nullptr;
1536 }
1537 
1538 static RefPtr&lt;CSSValue&gt; consumeSpringFunction(CSSParserTokenRange&amp; range)
1539 {
1540     ASSERT(range.peek().functionId() == CSSValueSpring);
1541     CSSParserTokenRange rangeCopy = range;
1542     CSSParserTokenRange args = consumeFunction(rangeCopy);
1543 
1544     // Mass must be greater than 0.
1545     double mass;
1546     if (!consumeNumberRaw(args, mass) || mass &lt;= 0)
1547         return nullptr;
1548 
1549     // Stiffness must be greater than 0.
1550     double stiffness;
1551     if (!consumeNumberRaw(args, stiffness) || stiffness &lt;= 0)
1552         return nullptr;
1553 
1554     // Damping coefficient must be greater than or equal to 0.
1555     double damping;
1556     if (!consumeNumberRaw(args, damping) || damping &lt; 0)
1557         return nullptr;
1558 
1559     // Initial velocity may have any value.
1560     double initialVelocity;
1561     if (!consumeNumberRaw(args, initialVelocity))
1562         return nullptr;
1563 
1564     if (!args.atEnd())
1565         return nullptr;
1566 
1567     range = rangeCopy;
1568 
1569     return CSSSpringTimingFunctionValue::create(mass, stiffness, damping, initialVelocity);
1570 }
1571 
1572 static RefPtr&lt;CSSValue&gt; consumeAnimationTimingFunction(CSSParserTokenRange&amp; range, const CSSParserContext&amp; context)
1573 {
1574     CSSValueID id = range.peek().id();
1575     if (id == CSSValueEase || id == CSSValueLinear || id == CSSValueEaseIn
1576         || id == CSSValueEaseOut || id == CSSValueEaseInOut || id == CSSValueStepStart || id == CSSValueStepEnd)
1577         return consumeIdent(range);
1578 
1579     CSSValueID function = range.peek().functionId();
1580     if (function == CSSValueCubicBezier)
1581         return consumeCubicBezier(range);
1582     if (function == CSSValueSteps)
1583         return consumeSteps(range);
1584     if (context.springTimingFunctionEnabled &amp;&amp; function == CSSValueSpring)
1585         return consumeSpringFunction(range);
1586     return nullptr;
1587 }
1588 
1589 static RefPtr&lt;CSSValue&gt; consumeAnimationValue(CSSPropertyID property, CSSParserTokenRange&amp; range, const CSSParserContext&amp; context)
1590 {
1591     switch (property) {
1592     case CSSPropertyAnimationDelay:
1593     case CSSPropertyTransitionDelay:
1594         return consumeTime(range, context.mode, ValueRangeAll, UnitlessQuirk::Forbid);
1595     case CSSPropertyAnimationDirection:
1596         return consumeIdent&lt;CSSValueNormal, CSSValueAlternate, CSSValueReverse, CSSValueAlternateReverse&gt;(range);
1597     case CSSPropertyAnimationDuration:
1598     case CSSPropertyTransitionDuration:
1599         return consumeTime(range, context.mode, ValueRangeNonNegative, UnitlessQuirk::Forbid);
1600     case CSSPropertyAnimationFillMode:
1601         return consumeIdent&lt;CSSValueNone, CSSValueForwards, CSSValueBackwards, CSSValueBoth&gt;(range);
1602     case CSSPropertyAnimationIterationCount:
1603         return consumeAnimationIterationCount(range);
1604     case CSSPropertyAnimationName:
1605         return consumeAnimationName(range);
1606     case CSSPropertyAnimationPlayState:
1607         return consumeIdent&lt;CSSValueRunning, CSSValuePaused&gt;(range);
1608     case CSSPropertyTransitionProperty:
1609         return consumeTransitionProperty(range);
1610     case CSSPropertyAnimationTimingFunction:
1611     case CSSPropertyTransitionTimingFunction:
1612         return consumeAnimationTimingFunction(range, context);
1613     default:
1614         ASSERT_NOT_REACHED();
1615         return nullptr;
1616     }
1617 }
1618 
1619 static bool isValidAnimationPropertyList(CSSPropertyID property, const CSSValueList&amp; valueList)
1620 {
1621     if (property != CSSPropertyTransitionProperty || valueList.length() &lt; 2)
1622         return true;
1623     for (auto&amp; value : valueList) {
1624         if (value-&gt;isPrimitiveValue() &amp;&amp; downcast&lt;CSSPrimitiveValue&gt;(value.get()).isValueID()
1625             &amp;&amp; downcast&lt;CSSPrimitiveValue&gt;(value.get()).valueID() == CSSValueNone)
1626             return false;
1627     }
1628     return true;
1629 }
1630 
1631 static RefPtr&lt;CSSValue&gt; consumeAnimationPropertyList(CSSPropertyID property, CSSParserTokenRange&amp; range, const CSSParserContext&amp; context)
1632 {
1633     RefPtr&lt;CSSValueList&gt; list;
1634     RefPtr&lt;CSSValue&gt; singleton;
1635     do {
1636         RefPtr&lt;CSSValue&gt; currentValue = consumeAnimationValue(property, range, context);
1637         if (!currentValue)
1638             return nullptr;
1639 
1640         if (singleton &amp;&amp; !list) {
1641             list = CSSValueList::createCommaSeparated();
1642             list-&gt;append(singleton.releaseNonNull());
1643         }
1644 
1645         if (list)
1646             list-&gt;append(currentValue.releaseNonNull());
1647         else
1648             singleton = WTFMove(currentValue);
1649 
1650     } while (consumeCommaIncludingWhitespace(range));
1651 
1652     if (list) {
1653         if (!isValidAnimationPropertyList(property, *list))
1654             return nullptr;
1655 
1656         ASSERT(list-&gt;length());
1657         return list;
1658     }
1659 
1660     return singleton;
1661 }
1662 
1663 bool CSSPropertyParser::consumeAnimationShorthand(const StylePropertyShorthand&amp; shorthand, bool important)
1664 {
1665     const unsigned longhandCount = shorthand.length();
1666     RefPtr&lt;CSSValueList&gt; longhands[8];
1667     ASSERT(longhandCount &lt;= 8);
1668     for (size_t i = 0; i &lt; longhandCount; ++i)
1669         longhands[i] = CSSValueList::createCommaSeparated();
1670 
1671     do {
1672         bool parsedLonghand[8] = { false };
1673         do {
1674             bool foundProperty = false;
1675             for (size_t i = 0; i &lt; longhandCount; ++i) {
1676                 if (parsedLonghand[i])
1677                     continue;
1678 
1679                 if (RefPtr&lt;CSSValue&gt; value = consumeAnimationValue(shorthand.properties()[i], m_range, m_context)) {
1680                     parsedLonghand[i] = true;
1681                     foundProperty = true;
1682                     longhands[i]-&gt;append(*value);
1683                     break;
1684                 }
1685             }
1686             if (!foundProperty)
1687                 return false;
1688         } while (!m_range.atEnd() &amp;&amp; m_range.peek().type() != CommaToken);
1689 
1690         // FIXME: This will make invalid longhands, see crbug.com/386459
1691         for (size_t i = 0; i &lt; longhandCount; ++i) {
1692             if (!parsedLonghand[i])
1693                 longhands[i]-&gt;append(CSSValuePool::singleton().createImplicitInitialValue());
1694             parsedLonghand[i] = false;
1695         }
1696     } while (consumeCommaIncludingWhitespace(m_range));
1697 
1698     for (size_t i = 0; i &lt; longhandCount; ++i) {
1699         if (!isValidAnimationPropertyList(shorthand.properties()[i], *longhands[i]))
1700             return false;
1701     }
1702 
1703     for (size_t i = 0; i &lt; longhandCount; ++i)
1704         addProperty(shorthand.properties()[i], shorthand.id(), *longhands[i], important);
1705 
1706     return m_range.atEnd();
1707 }
1708 
1709 static RefPtr&lt;CSSValue&gt; consumeZIndex(CSSParserTokenRange&amp; range)
1710 {
1711     if (range.peek().id() == CSSValueAuto)
1712         return consumeIdent(range);
1713     return consumeInteger(range);
1714 }
1715 
1716 static RefPtr&lt;CSSValue&gt; consumeShadow(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode, bool isBoxShadowProperty)
1717 {
1718     if (range.peek().id() == CSSValueNone)
1719         return consumeIdent(range);
1720 
1721     RefPtr&lt;CSSValueList&gt; shadowValueList = CSSValueList::createCommaSeparated();
1722     do {
1723         if (RefPtr&lt;CSSShadowValue&gt; shadowValue = consumeSingleShadow(range, cssParserMode, isBoxShadowProperty, isBoxShadowProperty))
1724             shadowValueList-&gt;append(*shadowValue);
1725         else
1726             return nullptr;
1727     } while (consumeCommaIncludingWhitespace(range));
1728     return shadowValueList;
1729 }
1730 
1731 static RefPtr&lt;CSSValue&gt; consumeTextDecorationLine(CSSParserTokenRange&amp; range)
1732 {
1733     CSSValueID id = range.peek().id();
1734     if (id == CSSValueNone)
1735         return consumeIdent(range);
1736 
1737     RefPtr&lt;CSSValueList&gt; list = CSSValueList::createSpaceSeparated();
1738     while (true) {
1739 #if ENABLE(LETTERPRESS)
1740         RefPtr&lt;CSSPrimitiveValue&gt; ident = consumeIdent&lt;CSSValueBlink, CSSValueUnderline, CSSValueOverline, CSSValueLineThrough, CSSValueWebkitLetterpress&gt;(range);
1741 #else
1742         RefPtr&lt;CSSPrimitiveValue&gt; ident = consumeIdent&lt;CSSValueBlink, CSSValueUnderline, CSSValueOverline, CSSValueLineThrough&gt;(range);
1743 #endif
1744         if (!ident)
1745             break;
1746         if (list-&gt;hasValue(ident.get()))
1747             return nullptr;
1748         list-&gt;append(ident.releaseNonNull());
1749     }
1750 
1751     if (!list-&gt;length())
1752         return nullptr;
1753     return list;
1754 }
1755 
1756 static RefPtr&lt;CSSValue&gt; consumeTextDecorationSkip(CSSParserTokenRange&amp; range)
1757 {
1758     CSSValueID id = range.peek().id();
1759     if (id == CSSValueNone)
1760         return consumeIdent(range);
1761 
1762     RefPtr&lt;CSSValueList&gt; list = CSSValueList::createSpaceSeparated();
1763     while (true) {
1764         auto ident = consumeIdent&lt;CSSValueAuto, CSSValueInk, CSSValueObjects&gt;(range);
1765         if (!ident)
1766             break;
1767         if (list-&gt;hasValue(ident.get()))
1768             return nullptr;
1769         list-&gt;append(ident.releaseNonNull());
1770     }
1771 
1772     if (!list-&gt;length())
1773         return nullptr;
1774     return list;
1775 }
1776 
1777 static RefPtr&lt;CSSValue&gt; consumeTextEmphasisStyle(CSSParserTokenRange&amp; range)
1778 {
1779     CSSValueID id = range.peek().id();
1780     if (id == CSSValueNone)
1781         return consumeIdent(range);
1782 
1783     if (RefPtr&lt;CSSValue&gt; textEmphasisStyle = consumeString(range))
1784         return textEmphasisStyle;
1785 
1786     RefPtr&lt;CSSPrimitiveValue&gt; fill = consumeIdent&lt;CSSValueFilled, CSSValueOpen&gt;(range);
1787     RefPtr&lt;CSSPrimitiveValue&gt; shape = consumeIdent&lt;CSSValueDot, CSSValueCircle, CSSValueDoubleCircle, CSSValueTriangle, CSSValueSesame&gt;(range);
1788     if (!fill)
1789         fill = consumeIdent&lt;CSSValueFilled, CSSValueOpen&gt;(range);
1790     if (fill &amp;&amp; shape) {
1791         RefPtr&lt;CSSValueList&gt; parsedValues = CSSValueList::createSpaceSeparated();
1792         parsedValues-&gt;append(fill.releaseNonNull());
1793         parsedValues-&gt;append(shape.releaseNonNull());
1794         return parsedValues;
1795     }
1796     if (fill)
1797         return fill;
1798     if (shape)
1799         return shape;
1800     return nullptr;
1801 }
1802 
1803 static RefPtr&lt;CSSPrimitiveValue&gt; consumeCaretColor(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode)
1804 {
1805     if (range.peek().id() == CSSValueAuto)
1806         return consumeIdent(range);
1807     return consumeColor(range, cssParserMode);
1808 }
1809 
1810 static RefPtr&lt;CSSValue&gt; consumeOutlineColor(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode)
1811 {
1812     // Allow the special focus color even in HTML Standard parsing mode.
1813     if (range.peek().id() == CSSValueWebkitFocusRingColor)
1814         return consumeIdent(range);
1815     return consumeColor(range, cssParserMode);
1816 }
1817 
1818 static RefPtr&lt;CSSPrimitiveValue&gt; consumeLineWidth(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode, UnitlessQuirk unitless)
1819 {
1820     CSSValueID id = range.peek().id();
1821     if (id == CSSValueThin || id == CSSValueMedium || id == CSSValueThick)
1822         return consumeIdent(range);
1823     return consumeLength(range, cssParserMode, ValueRangeNonNegative, unitless);
1824 }
1825 
1826 static RefPtr&lt;CSSPrimitiveValue&gt; consumeBorderWidth(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode, UnitlessQuirk unitless)
1827 {
1828     return consumeLineWidth(range, cssParserMode, unitless);
1829 }
1830 
1831 static RefPtr&lt;CSSPrimitiveValue&gt; consumeTextStrokeWidth(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode)
1832 {
1833     return consumeLineWidth(range, cssParserMode, UnitlessQuirk::Forbid);
1834 }
1835 
1836 static RefPtr&lt;CSSPrimitiveValue&gt; consumeColumnRuleWidth(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode)
1837 {
1838     return consumeLineWidth(range, cssParserMode, UnitlessQuirk::Forbid);
1839 }
1840 
1841 static bool consumeTranslate3d(CSSParserTokenRange&amp; args, CSSParserMode cssParserMode, RefPtr&lt;CSSFunctionValue&gt;&amp; transformValue)
1842 {
1843     unsigned numberOfArguments = 2;
1844     RefPtr&lt;CSSValue&gt; parsedValue;
1845     do {
1846         parsedValue = consumeLengthOrPercent(args, cssParserMode, ValueRangeAll);
1847         if (!parsedValue)
1848             return false;
1849         transformValue-&gt;append(*parsedValue);
1850         if (!consumeCommaIncludingWhitespace(args))
1851             return false;
1852     } while (--numberOfArguments);
1853     parsedValue = consumeLength(args, cssParserMode, ValueRangeAll);
1854     if (!parsedValue)
1855         return false;
1856     transformValue-&gt;append(*parsedValue);
1857     return true;
1858 }
1859 
1860 static bool consumeNumbers(CSSParserTokenRange&amp; args, RefPtr&lt;CSSFunctionValue&gt;&amp; transformValue, unsigned numberOfArguments)
1861 {
1862     do {
1863         RefPtr&lt;CSSPrimitiveValue&gt; parsedValue = consumeNumber(args, ValueRangeAll);
1864         if (!parsedValue)
1865             return false;
1866         transformValue-&gt;append(parsedValue.releaseNonNull());
1867         if (--numberOfArguments &amp;&amp; !consumeCommaIncludingWhitespace(args))
1868             return false;
1869     } while (numberOfArguments);
1870     return true;
1871 }
1872 
1873 static bool consumePerspective(CSSParserTokenRange&amp; args, CSSParserMode cssParserMode, RefPtr&lt;CSSFunctionValue&gt;&amp; transformValue)
1874 {
1875     RefPtr&lt;CSSPrimitiveValue&gt; parsedValue = consumeLength(args, cssParserMode, ValueRangeNonNegative);
1876     if (!parsedValue) {
1877         double perspective;
1878         if (!consumeNumberRaw(args, perspective) || perspective &lt; 0)
1879             return false;
1880         parsedValue = CSSPrimitiveValue::create(perspective, CSSPrimitiveValue::UnitType::CSS_PX);
1881     }
1882     if (!parsedValue)
1883         return false;
1884     transformValue-&gt;append(parsedValue.releaseNonNull());
1885     return true;
1886 }
1887 
1888 static RefPtr&lt;CSSValue&gt; consumeTransformValue(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode)
1889 {
1890     CSSValueID functionId = range.peek().functionId();
1891     if (functionId == CSSValueInvalid)
1892         return nullptr;
1893     CSSParserTokenRange args = consumeFunction(range);
1894     if (args.atEnd())
1895         return nullptr;
1896 
1897     RefPtr&lt;CSSFunctionValue&gt; transformValue = CSSFunctionValue::create(functionId);
1898     RefPtr&lt;CSSValue&gt; parsedValue;
1899     switch (functionId) {
1900     case CSSValueRotate:
1901     case CSSValueRotateX:
1902     case CSSValueRotateY:
1903     case CSSValueRotateZ:
1904     case CSSValueSkewX:
1905     case CSSValueSkewY:
1906     case CSSValueSkew:
1907         parsedValue = consumeAngle(args, cssParserMode, UnitlessQuirk::Forbid);
1908         if (!parsedValue)
1909             return nullptr;
1910         if (functionId == CSSValueSkew &amp;&amp; consumeCommaIncludingWhitespace(args)) {
1911             transformValue-&gt;append(*parsedValue);
1912             parsedValue = consumeAngle(args, cssParserMode, UnitlessQuirk::Forbid);
1913             if (!parsedValue)
1914                 return nullptr;
1915         }
1916         break;
1917     case CSSValueScaleX:
1918     case CSSValueScaleY:
1919     case CSSValueScaleZ:
1920     case CSSValueScale:
1921         parsedValue = consumeNumber(args, ValueRangeAll);
1922         if (!parsedValue)
1923             return nullptr;
1924         if (functionId == CSSValueScale &amp;&amp; consumeCommaIncludingWhitespace(args)) {
1925             transformValue-&gt;append(*parsedValue);
1926             parsedValue = consumeNumber(args, ValueRangeAll);
1927             if (!parsedValue)
1928                 return nullptr;
1929         }
1930         break;
1931     case CSSValuePerspective:
1932         if (!consumePerspective(args, cssParserMode, transformValue))
1933             return nullptr;
1934         break;
1935     case CSSValueTranslateX:
1936     case CSSValueTranslateY:
1937     case CSSValueTranslate:
1938         parsedValue = consumeLengthOrPercent(args, cssParserMode, ValueRangeAll);
1939         if (!parsedValue)
1940             return nullptr;
1941         if (functionId == CSSValueTranslate &amp;&amp; consumeCommaIncludingWhitespace(args)) {
1942             transformValue-&gt;append(*parsedValue);
1943             parsedValue = consumeLengthOrPercent(args, cssParserMode, ValueRangeAll);
1944             if (!parsedValue)
1945                 return nullptr;
1946         }
1947         break;
1948     case CSSValueTranslateZ:
1949         parsedValue = consumeLength(args, cssParserMode, ValueRangeAll);
1950         break;
1951     case CSSValueMatrix:
1952     case CSSValueMatrix3d:
1953         if (!consumeNumbers(args, transformValue, (functionId == CSSValueMatrix3d) ? 16 : 6))
1954             return nullptr;
1955         break;
1956     case CSSValueScale3d:
1957         if (!consumeNumbers(args, transformValue, 3))
1958             return nullptr;
1959         break;
1960     case CSSValueRotate3d:
1961         if (!consumeNumbers(args, transformValue, 3) || !consumeCommaIncludingWhitespace(args))
1962             return nullptr;
1963         parsedValue = consumeAngle(args, cssParserMode, UnitlessQuirk::Forbid);
1964         if (!parsedValue)
1965             return nullptr;
1966         break;
1967     case CSSValueTranslate3d:
1968         if (!consumeTranslate3d(args, cssParserMode, transformValue))
1969             return nullptr;
1970         break;
1971     default:
1972         return nullptr;
1973     }
1974     if (parsedValue)
1975         transformValue-&gt;append(*parsedValue);
1976     if (!args.atEnd())
1977         return nullptr;
1978     return transformValue;
1979 }
1980 
1981 static RefPtr&lt;CSSValue&gt; consumeTransform(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode)
1982 {
1983     if (range.peek().id() == CSSValueNone)
1984         return consumeIdent(range);
1985 
1986     RefPtr&lt;CSSValueList&gt; list = CSSValueList::createSpaceSeparated();
1987     do {
1988         RefPtr&lt;CSSValue&gt; parsedTransformValue = consumeTransformValue(range, cssParserMode);
1989         if (!parsedTransformValue)
1990             return nullptr;
1991         list-&gt;append(parsedTransformValue.releaseNonNull());
1992     } while (!range.atEnd());
1993 
1994     return list;
1995 }
1996 
1997 template &lt;CSSValueID start, CSSValueID end&gt;
1998 static RefPtr&lt;CSSPrimitiveValue&gt; consumePositionLonghand(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode)
1999 {
2000     if (range.peek().type() == IdentToken) {
2001         CSSValueID id = range.peek().id();
2002         int percent;
2003         if (id == start)
2004             percent = 0;
2005         else if (id == CSSValueCenter)
2006             percent = 50;
2007         else if (id == end)
2008             percent = 100;
2009         else
2010             return nullptr;
2011         range.consumeIncludingWhitespace();
2012         return CSSPrimitiveValue::create(percent, CSSPrimitiveValue::UnitType::CSS_PERCENTAGE);
2013     }
2014     return consumeLengthOrPercent(range, cssParserMode, ValueRangeAll);
2015 }
2016 
2017 static RefPtr&lt;CSSPrimitiveValue&gt; consumePositionX(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode)
2018 {
2019     return consumePositionLonghand&lt;CSSValueLeft, CSSValueRight&gt;(range, cssParserMode);
2020 }
2021 
2022 static RefPtr&lt;CSSPrimitiveValue&gt; consumePositionY(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode)
2023 {
2024     return consumePositionLonghand&lt;CSSValueTop, CSSValueBottom&gt;(range, cssParserMode);
2025 }
2026 
2027 static RefPtr&lt;CSSValue&gt; consumePaintStroke(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode)
2028 {
2029     if (range.peek().id() == CSSValueNone)
2030         return consumeIdent(range);
2031     RefPtr&lt;CSSPrimitiveValue&gt; url = consumeUrl(range);
2032     if (url) {
2033         RefPtr&lt;CSSValue&gt; parsedValue;
2034         if (range.peek().id() == CSSValueNone)
2035             parsedValue = consumeIdent(range);
2036         else
2037             parsedValue = consumeColor(range, cssParserMode);
2038         if (parsedValue) {
2039             RefPtr&lt;CSSValueList&gt; values = CSSValueList::createSpaceSeparated();
2040             values-&gt;append(url.releaseNonNull());
2041             values-&gt;append(parsedValue.releaseNonNull());
2042             return values;
2043         }
2044         return url;
2045     }
2046     return consumeColor(range, cssParserMode);
2047 }
2048 
2049 static RefPtr&lt;CSSValue&gt; consumeGlyphOrientation(CSSParserTokenRange&amp; range, CSSParserMode mode, CSSPropertyID property)
2050 {
2051     if (range.peek().id() == CSSValueAuto) {
2052         if (property == CSSPropertyGlyphOrientationVertical)
2053             return consumeIdent(range);
2054         return nullptr;
2055     }
2056 
2057     return consumeAngle(range, mode, UnitlessQuirk::Allow);
2058 }
2059 
2060 static RefPtr&lt;CSSValue&gt; consumePaintOrder(CSSParserTokenRange&amp; range)
2061 {
2062     if (range.peek().id() == CSSValueNormal)
2063         return consumeIdent(range);
2064 
2065     Vector&lt;CSSValueID, 3&gt; paintTypeList;
2066     RefPtr&lt;CSSPrimitiveValue&gt; fill;
2067     RefPtr&lt;CSSPrimitiveValue&gt; stroke;
2068     RefPtr&lt;CSSPrimitiveValue&gt; markers;
2069     do {
2070         CSSValueID id = range.peek().id();
2071         if (id == CSSValueFill &amp;&amp; !fill)
2072             fill = consumeIdent(range);
2073         else if (id == CSSValueStroke &amp;&amp; !stroke)
2074             stroke = consumeIdent(range);
2075         else if (id == CSSValueMarkers &amp;&amp; !markers)
2076             markers = consumeIdent(range);
2077         else
2078             return nullptr;
2079         paintTypeList.append(id);
2080     } while (!range.atEnd());
2081 
2082     // After parsing we serialize the paint-order list. Since it is not possible to
2083     // pop a last list items from CSSValueList without bigger cost, we create the
2084     // list after parsing.
2085     CSSValueID firstPaintOrderType = paintTypeList.at(0);
2086     RefPtr&lt;CSSValueList&gt; paintOrderList = CSSValueList::createSpaceSeparated();
2087     switch (firstPaintOrderType) {
2088     case CSSValueFill:
2089     case CSSValueStroke:
2090         paintOrderList-&gt;append(firstPaintOrderType == CSSValueFill ? fill.releaseNonNull() : stroke.releaseNonNull());
2091         if (paintTypeList.size() &gt; 1) {
2092             if (paintTypeList.at(1) == CSSValueMarkers)
2093                 paintOrderList-&gt;append(markers.releaseNonNull());
2094         }
2095         break;
2096     case CSSValueMarkers:
2097         paintOrderList-&gt;append(markers.releaseNonNull());
2098         if (paintTypeList.size() &gt; 1) {
2099             if (paintTypeList.at(1) == CSSValueStroke)
2100                 paintOrderList-&gt;append(stroke.releaseNonNull());
2101         }
2102         break;
2103     default:
2104         ASSERT_NOT_REACHED();
2105     }
2106 
2107     return paintOrderList;
2108 }
2109 
2110 static RefPtr&lt;CSSValue&gt; consumeNoneOrURI(CSSParserTokenRange&amp; range)
2111 {
2112     if (range.peek().id() == CSSValueNone)
2113         return consumeIdent(range);
2114     return consumeUrl(range);
2115 }
2116 
2117 static RefPtr&lt;CSSValue&gt; consumeFlexBasis(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode)
2118 {
2119     // FIXME: Support intrinsic dimensions too.
2120     if (range.peek().id() == CSSValueAuto)
2121         return consumeIdent(range);
2122     return consumeLengthOrPercent(range, cssParserMode, ValueRangeNonNegative);
2123 }
2124 
2125 static RefPtr&lt;CSSValue&gt; consumeKerning(CSSParserTokenRange&amp; range, CSSParserMode mode)
2126 {
2127     RefPtr&lt;CSSValue&gt; result = consumeIdent&lt;CSSValueAuto, CSSValueNormal&gt;(range);
2128     if (result)
2129         return result;
2130     return consumeLength(range, mode, ValueRangeAll, UnitlessQuirk::Allow);
2131 }
2132 
2133 static RefPtr&lt;CSSValue&gt; consumeStrokeDasharray(CSSParserTokenRange&amp; range)
2134 {
2135     CSSValueID id = range.peek().id();
2136     if (id == CSSValueNone)
2137         return consumeIdent(range);
2138 
2139     RefPtr&lt;CSSValueList&gt; dashes = CSSValueList::createCommaSeparated();
2140     do {
2141         RefPtr&lt;CSSPrimitiveValue&gt; dash = consumeLengthOrPercent(range, SVGAttributeMode, ValueRangeNonNegative);
2142         if (!dash || (consumeCommaIncludingWhitespace(range) &amp;&amp; range.atEnd()))
2143             return nullptr;
2144         dashes-&gt;append(dash.releaseNonNull());
2145     } while (!range.atEnd());
2146     return dashes;
2147 }
2148 
2149 static RefPtr&lt;CSSPrimitiveValue&gt; consumeBaselineShift(CSSParserTokenRange&amp; range)
2150 {
2151     CSSValueID id = range.peek().id();
2152     if (id == CSSValueBaseline || id == CSSValueSub || id == CSSValueSuper)
2153         return consumeIdent(range);
2154     return consumeLengthOrPercent(range, SVGAttributeMode, ValueRangeAll);
2155 }
2156 
2157 static RefPtr&lt;CSSPrimitiveValue&gt; consumeRxOrRy(CSSParserTokenRange&amp; range)
2158 {
2159     // FIXME-NEWPARSER: We don&#39;t support auto values when mapping, so for now turn this
2160     // off until we can figure out if we&#39;re even supposed to support it.
2161     // if (range.peek().id() == CSSValueAuto)
2162     //     return consumeIdent(range);
2163     return consumeLengthOrPercent(range, SVGAttributeMode, ValueRangeAll, UnitlessQuirk::Forbid);
2164 }
2165 
2166 static RefPtr&lt;CSSValue&gt; consumeCursor(CSSParserTokenRange&amp; range, const CSSParserContext&amp; context, bool inQuirksMode)
2167 {
2168     RefPtr&lt;CSSValueList&gt; list;
2169     while (RefPtr&lt;CSSValue&gt; image = consumeImage(range, context, ConsumeGeneratedImage::Forbid)) {
2170         double num;
2171         IntPoint hotSpot(-1, -1);
2172         bool hotSpotSpecified = false;
2173         if (consumeNumberRaw(range, num)) {
2174             hotSpot.setX(int(num));
2175             if (!consumeNumberRaw(range, num))
2176                 return nullptr;
2177             hotSpot.setY(int(num));
2178             hotSpotSpecified = true;
2179         }
2180 
2181         if (!list)
2182             list = CSSValueList::createCommaSeparated();
2183 
2184         list-&gt;append(CSSCursorImageValue::create(image.releaseNonNull(), hotSpotSpecified, hotSpot, context.isContentOpaque ? LoadedFromOpaqueSource::Yes : LoadedFromOpaqueSource::No));
2185         if (!consumeCommaIncludingWhitespace(range))
2186             return nullptr;
2187     }
2188 
2189     CSSValueID id = range.peek().id();
2190     RefPtr&lt;CSSValue&gt; cursorType;
2191     if (id == CSSValueHand) {
2192         if (!inQuirksMode) // Non-standard behavior
2193             return nullptr;
2194         cursorType = CSSValuePool::singleton().createIdentifierValue(CSSValuePointer);
2195         range.consumeIncludingWhitespace();
2196     } else if ((id &gt;= CSSValueAuto &amp;&amp; id &lt;= CSSValueWebkitZoomOut) || id == CSSValueCopy || id == CSSValueNone) {
2197         cursorType = consumeIdent(range);
2198     } else {
2199         return nullptr;
2200     }
2201 
2202     if (!list)
2203         return cursorType;
2204     list-&gt;append(cursorType.releaseNonNull());
2205     return list;
2206 }
2207 
2208 static RefPtr&lt;CSSValue&gt; consumeAttr(CSSParserTokenRange args, CSSParserContext context)
2209 {
2210     if (args.peek().type() != IdentToken)
2211         return nullptr;
2212 
2213     CSSParserToken token = args.consumeIncludingWhitespace();
2214     auto attrName = token.value().toAtomicString();
2215     if (context.isHTMLDocument)
2216         attrName = attrName.convertToASCIILowercase();
2217 
2218     if (!args.atEnd())
2219         return nullptr;
2220 
2221     // FIXME-NEWPARSER: We want to use a CSSCustomIdentValue here eventually for the attrName.
2222     // FIXME-NEWPARSER: We want to use a CSSFunctionValue rather than relying on a custom
2223     // attr() primitive value.
2224     return CSSValuePool::singleton().createValue(attrName, CSSPrimitiveValue::CSS_ATTR);
2225 }
2226 
2227 static RefPtr&lt;CSSValue&gt; consumeCounterContent(CSSParserTokenRange args, bool counters)
2228 {
2229     RefPtr&lt;CSSPrimitiveValue&gt; identifier = consumeCustomIdent(args);
2230     if (!identifier)
2231         return nullptr;
2232 
2233     RefPtr&lt;CSSPrimitiveValue&gt; separator;
2234     if (!counters)
2235         separator = CSSPrimitiveValue::create(String(), CSSPrimitiveValue::UnitType::CSS_STRING);
2236     else {
2237         if (!consumeCommaIncludingWhitespace(args) || args.peek().type() != StringToken)
2238             return nullptr;
2239         separator = CSSPrimitiveValue::create(args.consumeIncludingWhitespace().value().toString(), CSSPrimitiveValue::UnitType::CSS_STRING);
2240     }
2241 
2242     RefPtr&lt;CSSPrimitiveValue&gt; listStyle;
2243     if (consumeCommaIncludingWhitespace(args)) {
2244         CSSValueID id = args.peek().id();
2245         if ((id != CSSValueNone &amp;&amp; (id &lt; CSSValueDisc || id &gt; CSSValueKatakanaIroha)))
2246             return nullptr;
2247         listStyle = consumeIdent(args);
2248     } else
2249         listStyle = CSSValuePool::singleton().createIdentifierValue(CSSValueDecimal);
2250 
2251     if (!args.atEnd())
2252         return nullptr;
2253 
2254     // FIXME-NEWPARSER: Should just have a CSSCounterValue.
2255     return CSSValuePool::singleton().createValue(Counter::create(identifier.releaseNonNull(), listStyle.releaseNonNull(), separator.releaseNonNull()));
2256 }
2257 
2258 static RefPtr&lt;CSSValue&gt; consumeContent(CSSParserTokenRange&amp; range, CSSParserContext context)
2259 {
2260     if (identMatches&lt;CSSValueNone, CSSValueNormal&gt;(range.peek().id()))
2261         return consumeIdent(range);
2262 
2263     RefPtr&lt;CSSValueList&gt; values = CSSValueList::createSpaceSeparated();
2264 
2265     do {
2266         RefPtr&lt;CSSValue&gt; parsedValue = consumeImage(range, context);
2267         if (!parsedValue)
2268             parsedValue = consumeIdent&lt;CSSValueOpenQuote, CSSValueCloseQuote, CSSValueNoOpenQuote, CSSValueNoCloseQuote&gt;(range);
2269         if (!parsedValue)
2270             parsedValue = consumeString(range);
2271         if (!parsedValue) {
2272             if (range.peek().functionId() == CSSValueAttr)
2273                 parsedValue = consumeAttr(consumeFunction(range), context);
2274             else if (range.peek().functionId() == CSSValueCounter)
2275                 parsedValue = consumeCounterContent(consumeFunction(range), false);
2276             else if (range.peek().functionId() == CSSValueCounters)
2277                 parsedValue = consumeCounterContent(consumeFunction(range), true);
2278             if (!parsedValue)
2279                 return nullptr;
2280         }
2281         values-&gt;append(parsedValue.releaseNonNull());
2282     } while (!range.atEnd());
2283 
2284     return values;
2285 }
2286 
2287 static RefPtr&lt;CSSPrimitiveValue&gt; consumePerspective(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode)
2288 {
2289     if (range.peek().id() == CSSValueNone)
2290         return consumeIdent(range);
2291     RefPtr&lt;CSSPrimitiveValue&gt; parsedValue = consumeLength(range, cssParserMode, ValueRangeAll);
2292     if (!parsedValue) {
2293         // FIXME: Make this quirk only apply to the webkit prefixed version of the property.
2294         double perspective;
2295         if (!consumeNumberRaw(range, perspective))
2296             return nullptr;
2297         parsedValue = CSSPrimitiveValue::create(perspective, CSSPrimitiveValue::UnitType::CSS_PX);
2298     }
2299     if (parsedValue &amp;&amp; (parsedValue-&gt;isCalculated() || parsedValue-&gt;doubleValue() &gt; 0))
2300         return parsedValue;
2301     return nullptr;
2302 }
2303 
2304 #if ENABLE(CSS_SCROLL_SNAP)
2305 
2306 static RefPtr&lt;CSSValueList&gt; consumeScrollSnapAlign(CSSParserTokenRange&amp; range)
2307 {
2308     RefPtr&lt;CSSValueList&gt; alignmentValue = CSSValueList::createSpaceSeparated();
2309     if (RefPtr&lt;CSSPrimitiveValue&gt; firstValue = consumeIdent&lt;CSSValueNone, CSSValueStart, CSSValueCenter, CSSValueEnd&gt;(range)) {
2310         alignmentValue-&gt;append(firstValue.releaseNonNull());
2311         if (auto secondValue = consumeIdent&lt;CSSValueNone, CSSValueStart, CSSValueCenter, CSSValueEnd&gt;(range))
2312             alignmentValue-&gt;append(secondValue.releaseNonNull());
2313     }
2314     return alignmentValue-&gt;length() ? alignmentValue : nullptr;
2315 }
2316 
2317 static RefPtr&lt;CSSValueList&gt; consumeScrollSnapType(CSSParserTokenRange&amp; range)
2318 {
2319     RefPtr&lt;CSSValueList&gt; typeValue = CSSValueList::createSpaceSeparated();
2320     RefPtr&lt;CSSPrimitiveValue&gt; secondValue;
2321 
2322     auto firstValue = consumeIdent&lt;CSSValueX, CSSValueY, CSSValueBlock, CSSValueInline, CSSValueBoth&gt;(range);
2323     if (firstValue)
2324         secondValue = consumeIdent&lt;CSSValueProximity, CSSValueMandatory&gt;(range);
2325     else
2326         firstValue = consumeIdent&lt;CSSValueNone, CSSValueProximity, CSSValueMandatory&gt;(range);
2327 
2328     if (!firstValue)
2329         return nullptr;
2330 
2331     typeValue-&gt;append(firstValue.releaseNonNull());
2332     if (secondValue)
2333         typeValue-&gt;append(secondValue.releaseNonNull());
2334 
2335     return typeValue;
2336 }
2337 
2338 #endif
2339 
2340 static RefPtr&lt;CSSValue&gt; consumeBorderRadiusCorner(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode)
2341 {
2342     RefPtr&lt;CSSPrimitiveValue&gt; parsedValue1 = consumeLengthOrPercent(range, cssParserMode, ValueRangeNonNegative);
2343     if (!parsedValue1)
2344         return nullptr;
2345     RefPtr&lt;CSSPrimitiveValue&gt; parsedValue2 = consumeLengthOrPercent(range, cssParserMode, ValueRangeNonNegative);
2346     if (!parsedValue2)
2347         parsedValue2 = parsedValue1;
2348     return createPrimitiveValuePair(parsedValue1.releaseNonNull(), parsedValue2.releaseNonNull(), Pair::IdenticalValueEncoding::Coalesce);
2349 }
2350 
2351 static RefPtr&lt;CSSValue&gt; consumeTextUnderlineOffset(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode)
2352 {
2353     if (auto value = consumeIdent&lt;CSSValueAuto&gt;(range))
2354         return value;
2355     return consumeLength(range, cssParserMode, ValueRangeAll);
2356 }
2357 
2358 static RefPtr&lt;CSSValue&gt; consumeTextDecorationThickness(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode)
2359 {
2360     if (auto value = consumeIdent&lt;CSSValueAuto, CSSValueFromFont&gt;(range))
2361         return value;
2362     return consumeLength(range, cssParserMode, ValueRangeAll);
2363 }
2364 
2365 static RefPtr&lt;CSSPrimitiveValue&gt; consumeVerticalAlign(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode)
2366 {
2367     RefPtr&lt;CSSPrimitiveValue&gt; parsedValue = consumeIdentRange(range, CSSValueBaseline, CSSValueWebkitBaselineMiddle);
2368     if (!parsedValue)
2369         parsedValue = consumeLengthOrPercent(range, cssParserMode, ValueRangeAll, UnitlessQuirk::Allow);
2370     return parsedValue;
2371 }
2372 
2373 static RefPtr&lt;CSSPrimitiveValue&gt; consumeShapeRadius(CSSParserTokenRange&amp; args, CSSParserMode cssParserMode)
2374 {
2375     if (identMatches&lt;CSSValueClosestSide, CSSValueFarthestSide&gt;(args.peek().id()))
2376         return consumeIdent(args);
2377     return consumeLengthOrPercent(args, cssParserMode, ValueRangeNonNegative);
2378 }
2379 
2380 static RefPtr&lt;CSSBasicShapeCircle&gt; consumeBasicShapeCircle(CSSParserTokenRange&amp; args, const CSSParserContext&amp; context)
2381 {
2382     // spec: https://drafts.csswg.org/css-shapes/#supported-basic-shapes
2383     // circle( [&lt;shape-radius&gt;]? [at &lt;position&gt;]? )
2384     RefPtr&lt;CSSBasicShapeCircle&gt; shape = CSSBasicShapeCircle::create();
2385     if (RefPtr&lt;CSSPrimitiveValue&gt; radius = consumeShapeRadius(args, context.mode))
2386         shape-&gt;setRadius(radius.releaseNonNull());
2387     if (consumeIdent&lt;CSSValueAt&gt;(args)) {
2388         RefPtr&lt;CSSPrimitiveValue&gt; centerX;
2389         RefPtr&lt;CSSPrimitiveValue&gt; centerY;
2390         if (!consumePosition(args, context.mode, UnitlessQuirk::Forbid, centerX, centerY))
2391             return nullptr;
2392         shape-&gt;setCenterX(centerX.releaseNonNull());
2393         shape-&gt;setCenterY(centerY.releaseNonNull());
2394     }
2395     return shape;
2396 }
2397 
2398 static RefPtr&lt;CSSBasicShapeEllipse&gt; consumeBasicShapeEllipse(CSSParserTokenRange&amp; args, const CSSParserContext&amp; context)
2399 {
2400     // spec: https://drafts.csswg.org/css-shapes/#supported-basic-shapes
2401     // ellipse( [&lt;shape-radius&gt;{2}]? [at &lt;position&gt;]? )
2402     RefPtr&lt;CSSBasicShapeEllipse&gt; shape = CSSBasicShapeEllipse::create();
2403     if (RefPtr&lt;CSSPrimitiveValue&gt; radiusX = consumeShapeRadius(args, context.mode)) {
2404         shape-&gt;setRadiusX(radiusX.releaseNonNull());
2405         if (RefPtr&lt;CSSPrimitiveValue&gt; radiusY = consumeShapeRadius(args, context.mode))
2406             shape-&gt;setRadiusY(radiusY.releaseNonNull());
2407     }
2408     if (consumeIdent&lt;CSSValueAt&gt;(args)) {
2409         RefPtr&lt;CSSPrimitiveValue&gt; centerX;
2410         RefPtr&lt;CSSPrimitiveValue&gt; centerY;
2411         if (!consumePosition(args, context.mode, UnitlessQuirk::Forbid, centerX, centerY))
2412             return nullptr;
2413         shape-&gt;setCenterX(centerX.releaseNonNull());
2414         shape-&gt;setCenterY(centerY.releaseNonNull());
2415     }
2416     return shape;
2417 }
2418 
2419 static RefPtr&lt;CSSBasicShapePolygon&gt; consumeBasicShapePolygon(CSSParserTokenRange&amp; args, const CSSParserContext&amp; context)
2420 {
2421     RefPtr&lt;CSSBasicShapePolygon&gt; shape = CSSBasicShapePolygon::create();
2422     if (identMatches&lt;CSSValueEvenodd, CSSValueNonzero&gt;(args.peek().id())) {
2423         shape-&gt;setWindRule(args.consumeIncludingWhitespace().id() == CSSValueEvenodd ? WindRule::EvenOdd : WindRule::NonZero);
2424         if (!consumeCommaIncludingWhitespace(args))
2425             return nullptr;
2426     }
2427 
2428     do {
2429         RefPtr&lt;CSSPrimitiveValue&gt; xLength = consumeLengthOrPercent(args, context.mode, ValueRangeAll);
2430         if (!xLength)
2431             return nullptr;
2432         RefPtr&lt;CSSPrimitiveValue&gt; yLength = consumeLengthOrPercent(args, context.mode, ValueRangeAll);
2433         if (!yLength)
2434             return nullptr;
2435         shape-&gt;appendPoint(xLength.releaseNonNull(), yLength.releaseNonNull());
2436     } while (consumeCommaIncludingWhitespace(args));
2437     return shape;
2438 }
2439 
2440 static RefPtr&lt;CSSBasicShapePath&gt; consumeBasicShapePath(CSSParserTokenRange&amp; args)
2441 {
2442     WindRule windRule = WindRule::NonZero;
2443     if (identMatches&lt;CSSValueEvenodd, CSSValueNonzero&gt;(args.peek().id())) {
2444         windRule = args.consumeIncludingWhitespace().id() == CSSValueEvenodd ? WindRule::EvenOdd : WindRule::NonZero;
2445         if (!consumeCommaIncludingWhitespace(args))
2446             return nullptr;
2447     }
2448 
2449     if (args.peek().type() != StringToken)
2450         return nullptr;
2451 
2452     auto byteStream = std::make_unique&lt;SVGPathByteStream&gt;();
2453     if (!buildSVGPathByteStreamFromString(args.consumeIncludingWhitespace().value().toString(), *byteStream, UnalteredParsing))
2454         return nullptr;
2455 
2456     auto shape = CSSBasicShapePath::create(WTFMove(byteStream));
2457     shape-&gt;setWindRule(windRule);
2458 
2459     return WTFMove(shape);
2460 }
2461 
2462 static void complete4Sides(RefPtr&lt;CSSPrimitiveValue&gt; side[4])
2463 {
2464     if (side[3])
2465         return;
2466     if (!side[2]) {
2467         if (!side[1])
2468             side[1] = side[0];
2469         side[2] = side[0];
2470     }
2471     side[3] = side[1];
2472 }
2473 
2474 static bool consumeRadii(RefPtr&lt;CSSPrimitiveValue&gt; horizontalRadii[4], RefPtr&lt;CSSPrimitiveValue&gt; verticalRadii[4], CSSParserTokenRange&amp; range, CSSParserMode cssParserMode, bool useLegacyParsing)
2475 {
2476     unsigned i = 0;
2477     for (; i &lt; 4 &amp;&amp; !range.atEnd() &amp;&amp; range.peek().type() != DelimiterToken; ++i) {
2478         horizontalRadii[i] = consumeLengthOrPercent(range, cssParserMode, ValueRangeNonNegative);
2479         if (!horizontalRadii[i])
2480             return false;
2481     }
2482     if (!horizontalRadii[0])
2483         return false;
2484     if (range.atEnd()) {
2485         // Legacy syntax: -webkit-border-radius: l1 l2; is equivalent to border-radius: l1 / l2;
2486         if (useLegacyParsing &amp;&amp; i == 2) {
2487             verticalRadii[0] = horizontalRadii[1];
2488             horizontalRadii[1] = nullptr;
2489         } else {
2490             complete4Sides(horizontalRadii);
2491             for (unsigned i = 0; i &lt; 4; ++i)
2492                 verticalRadii[i] = horizontalRadii[i];
2493             return true;
2494         }
2495     } else {
2496         if (!consumeSlashIncludingWhitespace(range))
2497             return false;
2498         for (i = 0; i &lt; 4 &amp;&amp; !range.atEnd(); ++i) {
2499             verticalRadii[i] = consumeLengthOrPercent(range, cssParserMode, ValueRangeNonNegative);
2500             if (!verticalRadii[i])
2501                 return false;
2502         }
2503         if (!verticalRadii[0] || !range.atEnd())
2504             return false;
2505     }
2506     complete4Sides(horizontalRadii);
2507     complete4Sides(verticalRadii);
2508     return true;
2509 }
2510 
2511 static RefPtr&lt;CSSBasicShapeInset&gt; consumeBasicShapeInset(CSSParserTokenRange&amp; args, const CSSParserContext&amp; context)
2512 {
2513     RefPtr&lt;CSSBasicShapeInset&gt; shape = CSSBasicShapeInset::create();
2514     RefPtr&lt;CSSPrimitiveValue&gt; top = consumeLengthOrPercent(args, context.mode, ValueRangeAll);
2515     if (!top)
2516         return nullptr;
2517     RefPtr&lt;CSSPrimitiveValue&gt; right = consumeLengthOrPercent(args, context.mode, ValueRangeAll);
2518     RefPtr&lt;CSSPrimitiveValue&gt; bottom;
2519     RefPtr&lt;CSSPrimitiveValue&gt; left;
2520     if (right) {
2521         bottom = consumeLengthOrPercent(args, context.mode, ValueRangeAll);
2522         if (bottom)
2523             left = consumeLengthOrPercent(args, context.mode, ValueRangeAll);
2524     }
2525     if (left)
2526         shape-&gt;updateShapeSize4Values(top.releaseNonNull(), right.releaseNonNull(), bottom.releaseNonNull(), left.releaseNonNull());
2527     else if (bottom)
2528         shape-&gt;updateShapeSize3Values(top.releaseNonNull(), right.releaseNonNull(), bottom.releaseNonNull());
2529     else if (right)
2530         shape-&gt;updateShapeSize2Values(top.releaseNonNull(), right.releaseNonNull());
2531     else
2532         shape-&gt;updateShapeSize1Value(top.releaseNonNull());
2533 
2534     if (consumeIdent&lt;CSSValueRound&gt;(args)) {
2535         RefPtr&lt;CSSPrimitiveValue&gt; horizontalRadii[4] = { 0 };
2536         RefPtr&lt;CSSPrimitiveValue&gt; verticalRadii[4] = { 0 };
2537         if (!consumeRadii(horizontalRadii, verticalRadii, args, context.mode, false))
2538             return nullptr;
2539         shape-&gt;setTopLeftRadius(createPrimitiveValuePair(horizontalRadii[0].releaseNonNull(), verticalRadii[0].releaseNonNull(), Pair::IdenticalValueEncoding::Coalesce));
2540         shape-&gt;setTopRightRadius(createPrimitiveValuePair(horizontalRadii[1].releaseNonNull(), verticalRadii[1].releaseNonNull(), Pair::IdenticalValueEncoding::Coalesce));
2541         shape-&gt;setBottomRightRadius(createPrimitiveValuePair(horizontalRadii[2].releaseNonNull(), verticalRadii[2].releaseNonNull(), Pair::IdenticalValueEncoding::Coalesce));
2542         shape-&gt;setBottomLeftRadius(createPrimitiveValuePair(horizontalRadii[3].releaseNonNull(), verticalRadii[3].releaseNonNull(), Pair::IdenticalValueEncoding::Coalesce));
2543     }
2544     return shape;
2545 }
2546 
2547 static RefPtr&lt;CSSValue&gt; consumeBasicShape(CSSParserTokenRange&amp; range, const CSSParserContext&amp; context)
2548 {
2549     RefPtr&lt;CSSValue&gt; result;
2550     if (range.peek().type() != FunctionToken)
2551         return nullptr;
2552     CSSValueID id = range.peek().functionId();
2553     CSSParserTokenRange rangeCopy = range;
2554     CSSParserTokenRange args = consumeFunction(rangeCopy);
2555 
2556     // FIXME-NEWPARSER: CSSBasicShape should be a CSSValue, and shapes should not be primitive values.
2557     RefPtr&lt;CSSBasicShape&gt; shape;
2558     if (id == CSSValueCircle)
2559         shape = consumeBasicShapeCircle(args, context);
2560     else if (id == CSSValueEllipse)
2561         shape = consumeBasicShapeEllipse(args, context);
2562     else if (id == CSSValuePolygon)
2563         shape = consumeBasicShapePolygon(args, context);
2564     else if (id == CSSValueInset)
2565         shape = consumeBasicShapeInset(args, context);
2566     else if (id == CSSValuePath)
2567         shape = consumeBasicShapePath(args);
2568     if (!shape)
2569         return nullptr;
2570     range = rangeCopy;
2571 
2572     if (!args.atEnd())
2573         return nullptr;
2574 
2575     return CSSValuePool::singleton().createValue(shape.releaseNonNull());
2576 }
2577 
2578 static RefPtr&lt;CSSValue&gt; consumeBasicShapeOrBox(CSSParserTokenRange&amp; range, const CSSParserContext&amp; context)
2579 {
2580     RefPtr&lt;CSSValueList&gt; list = CSSValueList::createSpaceSeparated();
2581     bool shapeFound = false;
2582     bool boxFound = false;
2583     while (!range.atEnd() &amp;&amp; !(shapeFound &amp;&amp; boxFound)) {
2584         RefPtr&lt;CSSValue&gt; componentValue;
2585         if (range.peek().type() == FunctionToken &amp;&amp; !shapeFound) {
2586             componentValue = consumeBasicShape(range, context);
2587             shapeFound = true;
2588         } else if (range.peek().type() == IdentToken &amp;&amp; !boxFound) {
2589             componentValue = consumeIdent&lt;CSSValueContentBox, CSSValuePaddingBox, CSSValueBorderBox, CSSValueMarginBox, CSSValueFillBox, CSSValueStrokeBox, CSSValueViewBox&gt;(range);
2590             boxFound = true;
2591         }
2592         if (!componentValue)
2593             return nullptr;
2594         list-&gt;append(componentValue.releaseNonNull());
2595     }
2596 
2597     if (!range.atEnd() || !list-&gt;length())
2598         return nullptr;
2599 
2600     return list;
2601 }
2602 
2603 static RefPtr&lt;CSSValue&gt; consumeWebkitClipPath(CSSParserTokenRange&amp; range, const CSSParserContext&amp; context)
2604 {
2605     if (range.peek().id() == CSSValueNone)
2606         return consumeIdent(range);
2607     if (RefPtr&lt;CSSPrimitiveValue&gt; url = consumeUrl(range))
2608         return url;
2609     return consumeBasicShapeOrBox(range, context);
2610 }
2611 
2612 static RefPtr&lt;CSSValue&gt; consumeShapeOutside(CSSParserTokenRange&amp; range, const CSSParserContext&amp; context)
2613 {
2614     if (RefPtr&lt;CSSValue&gt; imageValue = consumeImageOrNone(range, context))
2615         return imageValue;
2616     RefPtr&lt;CSSValueList&gt; list = CSSValueList::createSpaceSeparated();
2617     if (RefPtr&lt;CSSValue&gt; boxValue = consumeIdent&lt;CSSValueContentBox, CSSValuePaddingBox, CSSValueBorderBox, CSSValueMarginBox&gt;(range))
2618         list-&gt;append(boxValue.releaseNonNull());
2619     if (RefPtr&lt;CSSValue&gt; shapeValue = consumeBasicShape(range, context)) {
2620         list-&gt;append(shapeValue.releaseNonNull());
2621         if (list-&gt;length() &lt; 2) {
2622             if (RefPtr&lt;CSSValue&gt; boxValue = consumeIdent&lt;CSSValueContentBox, CSSValuePaddingBox, CSSValueBorderBox, CSSValueMarginBox&gt;(range))
2623                 list-&gt;append(boxValue.releaseNonNull());
2624         }
2625     }
2626     if (!list-&gt;length())
2627         return nullptr;
2628     return list;
2629 }
2630 
2631 static bool isAuto(CSSValueID id)
2632 {
2633     return identMatches&lt;CSSValueAuto&gt;(id);
2634 }
2635 
2636 static bool isNormalOrStretch(CSSValueID id)
2637 {
2638     return identMatches&lt;CSSValueNormal, CSSValueStretch&gt;(id);
2639 }
2640 
2641 static bool isLeftOrRightKeyword(CSSValueID id)
2642 {
2643     return identMatches&lt;CSSValueLeft, CSSValueRight&gt;(id);
2644 }
2645 
2646 static bool isContentDistributionKeyword(CSSValueID id)
2647 {
2648     return identMatches&lt;CSSValueSpaceBetween, CSSValueSpaceAround, CSSValueSpaceEvenly, CSSValueStretch&gt;(id);
2649 }
2650 
2651 static bool isContentPositionKeyword(CSSValueID id)
2652 {
2653     return identMatches&lt;CSSValueStart, CSSValueEnd, CSSValueCenter, CSSValueFlexStart, CSSValueFlexEnd&gt;(id);
2654 }
2655 
2656 static bool isContentPositionOrLeftOrRightKeyword(CSSValueID id)
2657 {
2658     return isContentPositionKeyword(id) || isLeftOrRightKeyword(id);
2659 }
2660 
2661 static bool isOverflowKeyword(CSSValueID id)
2662 {
2663     return CSSPropertyParserHelpers::identMatches&lt;CSSValueUnsafe, CSSValueSafe&gt;(id);
2664 }
2665 
2666 static bool isBaselineKeyword(CSSValueID id)
2667 {
2668     return identMatches&lt;CSSValueFirst, CSSValueLast, CSSValueBaseline&gt;(id);
2669 }
2670 
2671 static RefPtr&lt;CSSPrimitiveValue&gt; consumeOverflowPositionKeyword(CSSParserTokenRange&amp; range)
2672 {
2673     return isOverflowKeyword(range.peek().id()) ? consumeIdent(range) : nullptr;
2674 }
2675 
2676 static CSSValueID getBaselineKeyword(RefPtr&lt;CSSValue&gt; value)
2677 {
2678     auto&amp; primitiveValue = downcast&lt;CSSPrimitiveValue&gt;(*value);
2679     if (primitiveValue.pairValue()) {
2680         ASSERT(primitiveValue.pairValue()-&gt;first()-&gt;valueID() == CSSValueLast);
2681         ASSERT(primitiveValue.pairValue()-&gt;second()-&gt;valueID() == CSSValueBaseline);
2682         return CSSValueLastBaseline;
2683     }
2684     ASSERT(primitiveValue.valueID() == CSSValueBaseline);
2685     return CSSValueBaseline;
2686 }
2687 
2688 static RefPtr&lt;CSSValue&gt; consumeBaselineKeyword(CSSParserTokenRange&amp; range)
2689 {
2690     RefPtr&lt;CSSPrimitiveValue&gt; preference = consumeIdent&lt;CSSValueFirst, CSSValueLast&gt;(range);
2691     RefPtr&lt;CSSPrimitiveValue&gt; baseline = consumeIdent&lt;CSSValueBaseline&gt;(range);
2692     if (!baseline)
2693         return nullptr;
2694     if (preference &amp;&amp; preference-&gt;valueID() == CSSValueLast)
2695         return createPrimitiveValuePair(preference.releaseNonNull(), baseline.releaseNonNull(), Pair::IdenticalValueEncoding::Coalesce);
2696     return baseline;
2697 }
2698 
2699 using IsPositionKeyword = bool (*)(CSSValueID);
2700 
2701 static RefPtr&lt;CSSValue&gt; consumeContentDistributionOverflowPosition(CSSParserTokenRange&amp; range, IsPositionKeyword isPositionKeyword)
2702 {
2703     ASSERT(isPositionKeyword);
2704     CSSValueID id = range.peek().id();
2705     if (identMatches&lt;CSSValueNormal&gt;(id))
2706         return CSSContentDistributionValue::create(CSSValueInvalid, range.consumeIncludingWhitespace().id(), CSSValueInvalid);
2707 
2708     if (isBaselineKeyword(id)) {
2709         RefPtr&lt;CSSValue&gt; baseline = consumeBaselineKeyword(range);
2710         if (!baseline)
2711             return nullptr;
2712         return CSSContentDistributionValue::create(CSSValueInvalid, getBaselineKeyword(baseline), CSSValueInvalid);
2713     }
2714 
2715     if (isContentDistributionKeyword(id))
2716         return CSSContentDistributionValue::create(range.consumeIncludingWhitespace().id(), CSSValueInvalid, CSSValueInvalid);
2717 
2718     CSSValueID overflow = isOverflowKeyword(id) ? range.consumeIncludingWhitespace().id() : CSSValueInvalid;
2719     if (isPositionKeyword(range.peek().id()))
2720         return CSSContentDistributionValue::create(CSSValueInvalid, range.consumeIncludingWhitespace().id(), overflow);
2721 
2722     return nullptr;
2723 }
2724 
2725 static RefPtr&lt;CSSPrimitiveValue&gt; consumeBorderImageRepeatKeyword(CSSParserTokenRange&amp; range)
2726 {
2727     return consumeIdent&lt;CSSValueStretch, CSSValueRepeat, CSSValueSpace, CSSValueRound&gt;(range);
2728 }
2729 
2730 static RefPtr&lt;CSSValue&gt; consumeBorderImageRepeat(CSSParserTokenRange&amp; range)
2731 {
2732     RefPtr&lt;CSSPrimitiveValue&gt; horizontal = consumeBorderImageRepeatKeyword(range);
2733     if (!horizontal)
2734         return nullptr;
2735     RefPtr&lt;CSSPrimitiveValue&gt; vertical = consumeBorderImageRepeatKeyword(range);
2736     if (!vertical)
2737         vertical = horizontal;
2738     return createPrimitiveValuePair(horizontal.releaseNonNull(), vertical.releaseNonNull(), Pair::IdenticalValueEncoding::Coalesce);
2739 }
2740 
2741 static RefPtr&lt;CSSValue&gt; consumeBorderImageSlice(CSSPropertyID property, CSSParserTokenRange&amp; range)
2742 {
2743     bool fill = consumeIdent&lt;CSSValueFill&gt;(range);
2744     RefPtr&lt;CSSPrimitiveValue&gt; slices[4] = { 0 };
2745 
2746     for (size_t index = 0; index &lt; 4; ++index) {
2747         RefPtr&lt;CSSPrimitiveValue&gt; value = consumePercent(range, ValueRangeNonNegative);
2748         if (!value)
2749             value = consumeNumber(range, ValueRangeNonNegative);
2750         if (!value)
2751             break;
2752         slices[index] = value;
2753     }
2754     if (!slices[0])
2755         return nullptr;
2756     if (consumeIdent&lt;CSSValueFill&gt;(range)) {
2757         if (fill)
2758             return nullptr;
2759         fill = true;
2760     }
2761     complete4Sides(slices);
2762     // FIXME: For backwards compatibility, -webkit-border-image, -webkit-mask-box-image and -webkit-box-reflect have to do a fill by default.
2763     // FIXME: What do we do with -webkit-box-reflect and -webkit-mask-box-image? Probably just have to leave them filling...
2764     if (property == CSSPropertyWebkitBorderImage || property == CSSPropertyWebkitMaskBoxImage || property == CSSPropertyWebkitBoxReflect)
2765         fill = true;
2766 
2767     // Now build a rect value to hold all four of our primitive values.
2768     // FIXME-NEWPARSER: Should just have a CSSQuadValue.
2769     auto quad = Quad::create();
2770     quad-&gt;setTop(slices[0].releaseNonNull());
2771     quad-&gt;setRight(slices[1].releaseNonNull());
2772     quad-&gt;setBottom(slices[2].releaseNonNull());
2773     quad-&gt;setLeft(slices[3].releaseNonNull());
2774 
2775     // Make our new border image value now.
2776     return CSSBorderImageSliceValue::create(CSSValuePool::singleton().createValue(WTFMove(quad)), fill);
2777 }
2778 
2779 static RefPtr&lt;CSSValue&gt; consumeBorderImageOutset(CSSParserTokenRange&amp; range)
2780 {
2781     RefPtr&lt;CSSPrimitiveValue&gt; outsets[4] = { 0 };
2782 
2783     RefPtr&lt;CSSPrimitiveValue&gt; value;
2784     for (size_t index = 0; index &lt; 4; ++index) {
2785         value = consumeNumber(range, ValueRangeNonNegative);
2786         if (!value)
2787             value = consumeLength(range, HTMLStandardMode, ValueRangeNonNegative);
2788         if (!value)
2789             break;
2790         outsets[index] = value;
2791     }
2792     if (!outsets[0])
2793         return nullptr;
2794     complete4Sides(outsets);
2795 
2796     // FIXME-NEWPARSER: Should just have a CSSQuadValue.
2797     auto quad = Quad::create();
2798     quad-&gt;setTop(outsets[0].releaseNonNull());
2799     quad-&gt;setRight(outsets[1].releaseNonNull());
2800     quad-&gt;setBottom(outsets[2].releaseNonNull());
2801     quad-&gt;setLeft(outsets[3].releaseNonNull());
2802 
2803     return CSSValuePool::singleton().createValue(WTFMove(quad));
2804 }
2805 
2806 static RefPtr&lt;CSSValue&gt; consumeBorderImageWidth(CSSParserTokenRange&amp; range)
2807 {
2808     RefPtr&lt;CSSPrimitiveValue&gt; widths[4];
2809 
2810     RefPtr&lt;CSSPrimitiveValue&gt; value;
2811     for (size_t index = 0; index &lt; 4; ++index) {
2812         value = consumeNumber(range, ValueRangeNonNegative);
2813         if (!value)
2814             value = consumeLengthOrPercent(range, HTMLStandardMode, ValueRangeNonNegative, UnitlessQuirk::Forbid);
2815         if (!value)
2816             value = consumeIdent&lt;CSSValueAuto&gt;(range);
2817         if (!value)
2818             break;
2819         widths[index] = value;
2820     }
2821     if (!widths[0])
2822         return nullptr;
2823     complete4Sides(widths);
2824 
2825     // FIXME-NEWPARSER: Should just have a CSSQuadValue.
2826     auto quad = Quad::create();
2827     quad-&gt;setTop(widths[0].releaseNonNull());
2828     quad-&gt;setRight(widths[1].releaseNonNull());
2829     quad-&gt;setBottom(widths[2].releaseNonNull());
2830     quad-&gt;setLeft(widths[3].releaseNonNull());
2831 
2832     return CSSValuePool::singleton().createValue(WTFMove(quad));
2833 }
2834 
2835 static bool consumeBorderImageComponents(CSSPropertyID property, CSSParserTokenRange&amp; range, const CSSParserContext&amp; context, RefPtr&lt;CSSValue&gt;&amp; source,
2836     RefPtr&lt;CSSValue&gt;&amp; slice, RefPtr&lt;CSSValue&gt;&amp; width, RefPtr&lt;CSSValue&gt;&amp; outset, RefPtr&lt;CSSValue&gt;&amp; repeat)
2837 {
2838     do {
2839         if (!source) {
2840             source = consumeImageOrNone(range, context);
2841             if (source)
2842                 continue;
2843         }
2844         if (!repeat) {
2845             repeat = consumeBorderImageRepeat(range);
2846             if (repeat)
2847                 continue;
2848         }
2849         if (!slice) {
2850             slice = consumeBorderImageSlice(property, range);
2851             if (slice) {
2852                 ASSERT(!width &amp;&amp; !outset);
2853                 if (consumeSlashIncludingWhitespace(range)) {
2854                     width = consumeBorderImageWidth(range);
2855                     if (consumeSlashIncludingWhitespace(range)) {
2856                         outset = consumeBorderImageOutset(range);
2857                         if (!outset)
2858                             return false;
2859                     } else if (!width) {
2860                         return false;
2861                     }
2862                 }
2863             } else {
2864                 return false;
2865             }
2866         } else {
2867             return false;
2868         }
2869     } while (!range.atEnd());
2870     return true;
2871 }
2872 
2873 static RefPtr&lt;CSSValue&gt; consumeWebkitBorderImage(CSSPropertyID property, CSSParserTokenRange&amp; range, const CSSParserContext&amp; context)
2874 {
2875     RefPtr&lt;CSSValue&gt; source;
2876     RefPtr&lt;CSSValue&gt; slice;
2877     RefPtr&lt;CSSValue&gt; width;
2878     RefPtr&lt;CSSValue&gt; outset;
2879     RefPtr&lt;CSSValue&gt; repeat;
2880     if (consumeBorderImageComponents(property, range, context, source, slice, width, outset, repeat))
2881         return createBorderImageValue(WTFMove(source), WTFMove(slice), WTFMove(width), WTFMove(outset), WTFMove(repeat));
2882     return nullptr;
2883 }
2884 
2885 static RefPtr&lt;CSSValue&gt; consumeReflect(CSSParserTokenRange&amp; range, const CSSParserContext&amp; context)
2886 {
2887     if (range.peek().id() == CSSValueNone)
2888         return consumeIdent(range);
2889 
2890     RefPtr&lt;CSSPrimitiveValue&gt; direction = consumeIdent&lt;CSSValueAbove, CSSValueBelow, CSSValueLeft, CSSValueRight&gt;(range);
2891     if (!direction)
2892         return nullptr;
2893 
2894     RefPtr&lt;CSSPrimitiveValue&gt; offset;
2895     if (range.atEnd())
2896         offset = CSSValuePool::singleton().createValue(0, CSSPrimitiveValue::UnitType::CSS_PX);
2897     else {
2898         offset = consumeLengthOrPercent(range, context.mode, ValueRangeAll, UnitlessQuirk::Forbid);
2899         if (!offset)
2900             return nullptr;
2901     }
2902 
2903     RefPtr&lt;CSSValue&gt; mask;
2904     if (!range.atEnd()) {
2905         mask = consumeWebkitBorderImage(CSSPropertyWebkitBoxReflect, range, context);
2906         if (!mask)
2907             return nullptr;
2908     }
2909     return CSSReflectValue::create(direction.releaseNonNull(), offset.releaseNonNull(), WTFMove(mask));
2910 }
2911 
2912 #if ENABLE(CSS_IMAGE_ORIENTATION)
2913 static RefPtr&lt;CSSValue&gt; consumeImageOrientation(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode, UnitlessQuirk unitless = UnitlessQuirk::Forbid)
2914 {
2915     if (range.peek().type() != NumberToken) {
2916         RefPtr&lt;CSSPrimitiveValue&gt; angle = consumeAngle(range, cssParserMode, unitless);
2917         if (angle &amp;&amp; angle-&gt;doubleValue() == 0)
2918             return angle;
2919     }
2920     return nullptr;
2921 }
2922 #endif
2923 
2924 static RefPtr&lt;CSSPrimitiveValue&gt; consumeBackgroundBlendMode(CSSParserTokenRange&amp; range)
2925 {
2926     CSSValueID id = range.peek().id();
2927     if (id == CSSValueNormal || id == CSSValueOverlay || (id &gt;= CSSValueMultiply &amp;&amp; id &lt;= CSSValueLuminosity))
2928         return consumeIdent(range);
2929     return nullptr;
2930 }
2931 
2932 static RefPtr&lt;CSSPrimitiveValue&gt; consumeBackgroundAttachment(CSSParserTokenRange&amp; range)
2933 {
2934     return consumeIdent&lt;CSSValueScroll, CSSValueFixed, CSSValueLocal&gt;(range);
2935 }
2936 
2937 static RefPtr&lt;CSSPrimitiveValue&gt; consumeBackgroundBox(CSSParserTokenRange&amp; range)
2938 {
2939     return consumeIdent&lt;CSSValueBorderBox, CSSValuePaddingBox, CSSValueContentBox, CSSValueWebkitText&gt;(range);
2940 }
2941 
2942 static RefPtr&lt;CSSPrimitiveValue&gt; consumeBackgroundComposite(CSSParserTokenRange&amp; range)
2943 {
2944     return consumeIdentRange(range, CSSValueClear, CSSValuePlusLighter);
2945 }
2946 
2947 static RefPtr&lt;CSSPrimitiveValue&gt; consumeWebkitMaskSourceType(CSSParserTokenRange&amp; range)
2948 {
2949     return consumeIdent&lt;CSSValueAuto, CSSValueAlpha, CSSValueLuminance&gt;(range);
2950 }
2951 
2952 static RefPtr&lt;CSSPrimitiveValue&gt; consumePrefixedBackgroundBox(CSSPropertyID property, CSSParserTokenRange&amp; range, const CSSParserContext&amp; /*context*/)
2953 {
2954     // The values &#39;border&#39;, &#39;padding&#39; and &#39;content&#39; are deprecated and do not apply to the version of the property that has the -webkit- prefix removed.
2955     if (RefPtr&lt;CSSPrimitiveValue&gt; value = consumeIdentRange(range, CSSValueBorder, CSSValuePaddingBox))
2956         return value;
2957     if (range.peek().id() == CSSValueWebkitText || ((property == CSSPropertyWebkitBackgroundClip || property == CSSPropertyWebkitMaskClip) &amp;&amp; range.peek().id() == CSSValueText))
2958         return consumeIdent(range);
2959     return nullptr;
2960 }
2961 
2962 static RefPtr&lt;CSSPrimitiveValue&gt; consumeBackgroundSize(CSSPropertyID property, CSSParserTokenRange&amp; range, CSSParserMode cssParserMode)
2963 {
2964     if (identMatches&lt;CSSValueContain, CSSValueCover&gt;(range.peek().id()))
2965         return consumeIdent(range);
2966 
2967     // FIXME: We&#39;re allowing the unitless quirk on this property because our
2968     // tests assume that. Other browser engines don&#39;t allow it though.
2969     RefPtr&lt;CSSPrimitiveValue&gt; horizontal = consumeIdent&lt;CSSValueAuto&gt;(range);
2970     if (!horizontal)
2971         horizontal = consumeLengthOrPercent(range, cssParserMode, ValueRangeAll, UnitlessQuirk::Allow);
2972 
2973     RefPtr&lt;CSSPrimitiveValue&gt; vertical;
2974     if (!range.atEnd()) {
2975         if (range.peek().id() == CSSValueAuto) // `auto&#39; is the default
2976             range.consumeIncludingWhitespace();
2977         else
2978             vertical = consumeLengthOrPercent(range, cssParserMode, ValueRangeAll, UnitlessQuirk::Allow);
2979     } else if (!vertical &amp;&amp; property == CSSPropertyWebkitBackgroundSize) {
2980         // Legacy syntax: &quot;-webkit-background-size: 10px&quot; is equivalent to &quot;background-size: 10px 10px&quot;.
2981         vertical = horizontal;
2982     }
2983     if (!vertical)
2984         return horizontal;
2985     return createPrimitiveValuePair(horizontal.releaseNonNull(), vertical.releaseNonNull(), property == CSSPropertyWebkitBackgroundSize ? Pair::IdenticalValueEncoding::Coalesce : Pair::IdenticalValueEncoding::DoNotCoalesce);
2986 }
2987 
2988 static RefPtr&lt;CSSValueList&gt; consumeGridAutoFlow(CSSParserTokenRange&amp; range)
2989 {
2990     RefPtr&lt;CSSPrimitiveValue&gt; rowOrColumnValue = consumeIdent&lt;CSSValueRow, CSSValueColumn&gt;(range);
2991     RefPtr&lt;CSSPrimitiveValue&gt; denseAlgorithm = consumeIdent&lt;CSSValueDense&gt;(range);
2992     if (!rowOrColumnValue) {
2993         rowOrColumnValue = consumeIdent&lt;CSSValueRow, CSSValueColumn&gt;(range);
2994         if (!rowOrColumnValue &amp;&amp; !denseAlgorithm)
2995             return nullptr;
2996     }
2997     RefPtr&lt;CSSValueList&gt; parsedValues = CSSValueList::createSpaceSeparated();
2998     if (rowOrColumnValue)
2999         parsedValues-&gt;append(rowOrColumnValue.releaseNonNull());
3000     if (denseAlgorithm)
3001         parsedValues-&gt;append(denseAlgorithm.releaseNonNull());
3002     return parsedValues;
3003 }
3004 
3005 static RefPtr&lt;CSSValue&gt; consumeBackgroundComponent(CSSPropertyID property, CSSParserTokenRange&amp; range, const CSSParserContext&amp; context)
3006 {
3007     switch (property) {
3008     case CSSPropertyBackgroundClip:
3009         return consumeBackgroundBox(range);
3010     case CSSPropertyBackgroundBlendMode:
3011         return consumeBackgroundBlendMode(range);
3012     case CSSPropertyBackgroundAttachment:
3013         return consumeBackgroundAttachment(range);
3014     case CSSPropertyBackgroundOrigin:
3015         return consumeBackgroundBox(range);
3016     case CSSPropertyWebkitMaskComposite:
3017     case CSSPropertyWebkitBackgroundComposite:
3018         return consumeBackgroundComposite(range);
3019     case CSSPropertyWebkitBackgroundClip:
3020     case CSSPropertyWebkitBackgroundOrigin:
3021     case CSSPropertyWebkitMaskClip:
3022     case CSSPropertyWebkitMaskOrigin:
3023         return consumePrefixedBackgroundBox(property, range, context);
3024     case CSSPropertyBackgroundImage:
3025     case CSSPropertyWebkitMaskImage:
3026         return consumeImageOrNone(range, context);
3027     case CSSPropertyWebkitMaskSourceType:
3028         return consumeWebkitMaskSourceType(range);
3029     case CSSPropertyBackgroundPositionX:
3030     case CSSPropertyWebkitMaskPositionX:
3031         return consumePositionX(range, context.mode);
3032     case CSSPropertyBackgroundPositionY:
3033     case CSSPropertyWebkitMaskPositionY:
3034         return consumePositionY(range, context.mode);
3035     case CSSPropertyBackgroundSize:
3036     case CSSPropertyWebkitBackgroundSize:
3037     case CSSPropertyWebkitMaskSize:
3038         return consumeBackgroundSize(property, range, context.mode);
3039     case CSSPropertyBackgroundColor:
3040         return consumeColor(range, context.mode);
3041     default:
3042         break;
3043     };
3044     return nullptr;
3045 }
3046 
3047 static void addBackgroundValue(RefPtr&lt;CSSValue&gt;&amp; list, Ref&lt;CSSValue&gt;&amp;&amp; value)
3048 {
3049     if (list) {
3050         if (!list-&gt;isBaseValueList()) {
3051             RefPtr&lt;CSSValue&gt; firstValue = list;
3052             list = CSSValueList::createCommaSeparated();
3053             downcast&lt;CSSValueList&gt;(*list).append(firstValue.releaseNonNull());
3054         }
3055         downcast&lt;CSSValueList&gt;(*list).append(WTFMove(value));
3056     } else {
3057         // To conserve memory we don&#39;t actually wrap a single value in a list.
3058         list = WTFMove(value);
3059     }
3060 }
3061 
3062 static RefPtr&lt;CSSValue&gt; consumeCommaSeparatedBackgroundComponent(CSSPropertyID property, CSSParserTokenRange&amp; range, const CSSParserContext&amp; context)
3063 {
3064     RefPtr&lt;CSSValue&gt; result;
3065     do {
3066         RefPtr&lt;CSSValue&gt; value = consumeBackgroundComponent(property, range, context);
3067         if (!value)
3068             return nullptr;
3069         addBackgroundValue(result, value.releaseNonNull());
3070     } while (consumeCommaIncludingWhitespace(range));
3071     return result;
3072 }
3073 
3074 static bool isSelfPositionKeyword(CSSValueID id)
3075 {
3076     return identMatches&lt;CSSValueStart, CSSValueEnd, CSSValueCenter, CSSValueSelfStart, CSSValueSelfEnd, CSSValueFlexStart, CSSValueFlexEnd&gt;(id);
3077 }
3078 
3079 static bool isSelfPositionOrLeftOrRightKeyword(CSSValueID id)
3080 {
3081     return isSelfPositionKeyword(id) || isLeftOrRightKeyword(id);
3082 }
3083 
3084 static RefPtr&lt;CSSValue&gt; consumeSelfPositionOverflowPosition(CSSParserTokenRange&amp; range, IsPositionKeyword isPositionKeyword)
3085 {
3086     ASSERT(isPositionKeyword);
3087     CSSValueID id = range.peek().id();
3088     if (isAuto(id) || isNormalOrStretch(id))
3089         return consumeIdent(range);
3090 
3091     if (isBaselineKeyword(id))
3092         return consumeBaselineKeyword(range);
3093 
3094     RefPtr&lt;CSSPrimitiveValue&gt; overflowPosition = consumeOverflowPositionKeyword(range);
3095     if (!isPositionKeyword(range.peek().id()))
3096         return nullptr;
3097     RefPtr&lt;CSSPrimitiveValue&gt; selfPosition = consumeIdent(range);
3098     if (overflowPosition)
3099         return createPrimitiveValuePair(overflowPosition.releaseNonNull(), selfPosition.releaseNonNull(), Pair::IdenticalValueEncoding::Coalesce);
3100     return selfPosition;
3101 }
3102 
3103 static RefPtr&lt;CSSValue&gt; consumeAlignItems(CSSParserTokenRange&amp; range)
3104 {
3105     // align-items property does not allow the &#39;auto&#39; value.
3106     if (identMatches&lt;CSSValueAuto&gt;(range.peek().id()))
3107         return nullptr;
3108     return consumeSelfPositionOverflowPosition(range, isSelfPositionKeyword);
3109 }
3110 
3111 static RefPtr&lt;CSSValue&gt; consumeJustifyItems(CSSParserTokenRange&amp; range)
3112 {
3113     // justify-items property does not allow the &#39;auto&#39; value.
3114     if (identMatches&lt;CSSValueAuto&gt;(range.peek().id()))
3115         return nullptr;
3116     CSSParserTokenRange rangeCopy = range;
3117     RefPtr&lt;CSSPrimitiveValue&gt; legacy = consumeIdent&lt;CSSValueLegacy&gt;(rangeCopy);
3118     RefPtr&lt;CSSPrimitiveValue&gt; positionKeyword = consumeIdent&lt;CSSValueCenter, CSSValueLeft, CSSValueRight&gt;(rangeCopy);
3119     if (!legacy)
3120         legacy = consumeIdent&lt;CSSValueLegacy&gt;(rangeCopy);
3121     if (legacy) {
3122         range = rangeCopy;
3123         if (positionKeyword)
3124             return createPrimitiveValuePair(legacy.releaseNonNull(), positionKeyword.releaseNonNull(), Pair::IdenticalValueEncoding::Coalesce);
3125         return legacy;
3126     }
3127     return consumeSelfPositionOverflowPosition(range, isSelfPositionOrLeftOrRightKeyword);
3128 }
3129 
3130 static RefPtr&lt;CSSValue&gt; consumeFitContent(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode)
3131 {
3132     CSSParserTokenRange rangeCopy = range;
3133     CSSParserTokenRange args = consumeFunction(rangeCopy);
3134     RefPtr&lt;CSSPrimitiveValue&gt; length = consumeLengthOrPercent(args, cssParserMode, ValueRangeNonNegative, UnitlessQuirk::Allow);
3135     if (!length || !args.atEnd())
3136         return nullptr;
3137     range = rangeCopy;
3138     RefPtr&lt;CSSFunctionValue&gt; result = CSSFunctionValue::create(CSSValueFitContent);
3139     result-&gt;append(length.releaseNonNull());
3140     return result;
3141 }
3142 
3143 static RefPtr&lt;CSSPrimitiveValue&gt; consumeCustomIdentForGridLine(CSSParserTokenRange&amp; range)
3144 {
3145     if (range.peek().id() == CSSValueAuto || range.peek().id() == CSSValueSpan)
3146         return nullptr;
3147     return consumeCustomIdent(range);
3148 }
3149 
3150 static RefPtr&lt;CSSValue&gt; consumeGridLine(CSSParserTokenRange&amp; range)
3151 {
3152     if (range.peek().id() == CSSValueAuto)
3153         return consumeIdent(range);
3154 
3155     RefPtr&lt;CSSPrimitiveValue&gt; spanValue;
3156     RefPtr&lt;CSSPrimitiveValue&gt; gridLineName;
3157     RefPtr&lt;CSSPrimitiveValue&gt; numericValue = consumeInteger(range);
3158     if (numericValue) {
3159         gridLineName = consumeCustomIdentForGridLine(range);
3160         spanValue = consumeIdent&lt;CSSValueSpan&gt;(range);
3161     } else {
3162         spanValue = consumeIdent&lt;CSSValueSpan&gt;(range);
3163         if (spanValue) {
3164             numericValue = consumeInteger(range);
3165             gridLineName = consumeCustomIdentForGridLine(range);
3166             if (!numericValue)
3167                 numericValue = consumeInteger(range);
3168         } else {
3169             gridLineName = consumeCustomIdentForGridLine(range);
3170             if (gridLineName) {
3171                 numericValue = consumeInteger(range);
3172                 spanValue = consumeIdent&lt;CSSValueSpan&gt;(range);
3173                 if (!spanValue &amp;&amp; !numericValue)
3174                     return gridLineName;
3175             } else {
3176                 return nullptr;
3177             }
3178         }
3179     }
3180 
3181     if (spanValue &amp;&amp; !numericValue &amp;&amp; !gridLineName)
3182         return nullptr; // &quot;span&quot; keyword alone is invalid.
3183     if (spanValue &amp;&amp; numericValue &amp;&amp; numericValue-&gt;intValue() &lt; 0)
3184         return nullptr; // Negative numbers are not allowed for span.
3185     if (numericValue &amp;&amp; numericValue-&gt;intValue() == 0)
3186         return nullptr; // An &lt;integer&gt; value of zero makes the declaration invalid.
3187 
3188     RefPtr&lt;CSSValueList&gt; values = CSSValueList::createSpaceSeparated();
3189     if (spanValue)
3190         values-&gt;append(spanValue.releaseNonNull());
3191     if (numericValue)
3192         values-&gt;append(numericValue.releaseNonNull());
3193     if (gridLineName)
3194         values-&gt;append(gridLineName.releaseNonNull());
3195     ASSERT(values-&gt;length());
3196     return values;
3197 }
3198 
3199 static bool isGridTrackFixedSized(const CSSPrimitiveValue&amp; primitiveValue)
3200 {
3201     CSSValueID valueID = primitiveValue.valueID();
3202     if (valueID == CSSValueMinContent || valueID == CSSValueWebkitMinContent || valueID == CSSValueMaxContent || valueID == CSSValueWebkitMaxContent || valueID == CSSValueAuto || primitiveValue.isFlex())
3203         return false;
3204 
3205     return true;
3206 }
3207 
3208 static bool isGridTrackFixedSized(const CSSValue&amp; value)
3209 {
3210     if (value.isPrimitiveValue())
3211         return isGridTrackFixedSized(downcast&lt;CSSPrimitiveValue&gt;(value));
3212 
3213     ASSERT(value.isFunctionValue());
3214     auto&amp; function = downcast&lt;CSSFunctionValue&gt;(value);
3215     if (function.name() == CSSValueFitContent || function.length() &lt; 2)
3216         return false;
3217 
3218     const CSSValue* minPrimitiveValue = downcast&lt;CSSPrimitiveValue&gt;(function.item(0));
3219     const CSSValue* maxPrimitiveValue = downcast&lt;CSSPrimitiveValue&gt;(function.item(1));
3220     return isGridTrackFixedSized(*minPrimitiveValue) || isGridTrackFixedSized(*maxPrimitiveValue);
3221 }
3222 
3223 static Vector&lt;String&gt; parseGridTemplateAreasColumnNames(const String&amp; gridRowNames)
3224 {
3225     ASSERT(!gridRowNames.isEmpty());
3226     Vector&lt;String&gt; columnNames;
3227     // Using StringImpl to avoid checks and indirection in every call to String::operator[].
3228     StringImpl&amp; text = *gridRowNames.impl();
3229 
3230     StringBuilder areaName;
3231     for (unsigned i = 0; i &lt; text.length(); ++i) {
3232         if (isCSSSpace(text[i])) {
3233             if (!areaName.isEmpty()) {
3234                 columnNames.append(areaName.toString());
3235                 areaName.clear();
3236             }
3237             continue;
3238         }
3239         if (text[i] == &#39;.&#39;) {
3240             if (areaName == &quot;.&quot;)
3241                 continue;
3242             if (!areaName.isEmpty()) {
3243                 columnNames.append(areaName.toString());
3244                 areaName.clear();
3245             }
3246         } else {
3247             if (!isNameCodePoint(text[i]))
3248                 return Vector&lt;String&gt;();
3249             if (areaName == &quot;.&quot;) {
3250                 columnNames.append(areaName.toString());
3251                 areaName.clear();
3252             }
3253         }
3254 
3255         areaName.append(text[i]);
3256     }
3257 
3258     if (!areaName.isEmpty())
3259         columnNames.append(areaName.toString());
3260 
3261     return columnNames;
3262 }
3263 
3264 static bool parseGridTemplateAreasRow(const String&amp; gridRowNames, NamedGridAreaMap&amp; gridAreaMap, const size_t rowCount, size_t&amp; columnCount)
3265 {
3266     if (gridRowNames.isAllSpecialCharacters&lt;isCSSSpace&gt;())
3267         return false;
3268 
3269     Vector&lt;String&gt; columnNames = parseGridTemplateAreasColumnNames(gridRowNames);
3270     if (rowCount == 0) {
3271         columnCount = columnNames.size();
3272         if (columnCount == 0)
3273             return false;
3274     } else if (columnCount != columnNames.size()) {
3275         // The declaration is invalid if all the rows don&#39;t have the number of columns.
3276         return false;
3277     }
3278 
3279     for (size_t currentColumn = 0; currentColumn &lt; columnCount; ++currentColumn) {
3280         const String&amp; gridAreaName = columnNames[currentColumn];
3281 
3282         // Unamed areas are always valid (we consider them to be 1x1).
3283         if (gridAreaName == &quot;.&quot;)
3284             continue;
3285 
3286         size_t lookAheadColumn = currentColumn + 1;
3287         while (lookAheadColumn &lt; columnCount &amp;&amp; columnNames[lookAheadColumn] == gridAreaName)
3288             lookAheadColumn++;
3289 
3290         NamedGridAreaMap::iterator gridAreaIt = gridAreaMap.find(gridAreaName);
3291         if (gridAreaIt == gridAreaMap.end()) {
3292             gridAreaMap.add(gridAreaName, GridArea(GridSpan::translatedDefiniteGridSpan(rowCount, rowCount + 1), GridSpan::translatedDefiniteGridSpan(currentColumn, lookAheadColumn)));
3293         } else {
3294             GridArea&amp; gridArea = gridAreaIt-&gt;value;
3295 
3296             // The following checks test that the grid area is a single filled-in rectangle.
3297             // 1. The new row is adjacent to the previously parsed row.
3298             if (rowCount != gridArea.rows.endLine())
3299                 return false;
3300 
3301             // 2. The new area starts at the same position as the previously parsed area.
3302             if (currentColumn != gridArea.columns.startLine())
3303                 return false;
3304 
3305             // 3. The new area ends at the same position as the previously parsed area.
3306             if (lookAheadColumn != gridArea.columns.endLine())
3307                 return false;
3308 
3309             gridArea.rows = GridSpan::translatedDefiniteGridSpan(gridArea.rows.startLine(), gridArea.rows.endLine() + 1);
3310         }
3311         currentColumn = lookAheadColumn - 1;
3312     }
3313 
3314     return true;
3315 }
3316 
3317 static RefPtr&lt;CSSPrimitiveValue&gt; consumeGridBreadth(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode)
3318 {
3319     const CSSParserToken&amp; token = range.peek();
3320     if (identMatches&lt;CSSValueMinContent, CSSValueWebkitMinContent, CSSValueMaxContent, CSSValueWebkitMaxContent, CSSValueAuto&gt;(token.id()))
3321         return consumeIdent(range);
3322     if (token.type() == DimensionToken &amp;&amp; token.unitType() == CSSPrimitiveValue::UnitType::CSS_FR) {
3323         if (range.peek().numericValue() &lt; 0)
3324             return nullptr;
3325         return CSSPrimitiveValue::create(range.consumeIncludingWhitespace().numericValue(), CSSPrimitiveValue::UnitType::CSS_FR);
3326     }
3327     return consumeLengthOrPercent(range, cssParserMode, ValueRangeNonNegative, UnitlessQuirk::Allow);
3328 }
3329 
3330 static RefPtr&lt;CSSValue&gt; consumeGridTrackSize(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode)
3331 {
3332     const CSSParserToken&amp; token = range.peek();
3333     if (identMatches&lt;CSSValueAuto&gt;(token.id()))
3334         return consumeIdent(range);
3335 
3336     if (token.functionId() == CSSValueMinmax) {
3337         CSSParserTokenRange rangeCopy = range;
3338         CSSParserTokenRange args = consumeFunction(rangeCopy);
3339         RefPtr&lt;CSSPrimitiveValue&gt; minTrackBreadth = consumeGridBreadth(args, cssParserMode);
3340         if (!minTrackBreadth || minTrackBreadth-&gt;isFlex() || !consumeCommaIncludingWhitespace(args))
3341             return nullptr;
3342         RefPtr&lt;CSSPrimitiveValue&gt; maxTrackBreadth = consumeGridBreadth(args, cssParserMode);
3343         if (!maxTrackBreadth || !args.atEnd())
3344             return nullptr;
3345         range = rangeCopy;
3346         RefPtr&lt;CSSFunctionValue&gt; result = CSSFunctionValue::create(CSSValueMinmax);
3347         result-&gt;append(minTrackBreadth.releaseNonNull());
3348         result-&gt;append(maxTrackBreadth.releaseNonNull());
3349         return result;
3350     }
3351 
3352     if (token.functionId() == CSSValueFitContent)
3353         return consumeFitContent(range, cssParserMode);
3354 
3355     return consumeGridBreadth(range, cssParserMode);
3356 }
3357 
3358 // Appends to the passed in CSSGridLineNamesValue if any, otherwise creates a new one.
3359 static RefPtr&lt;CSSGridLineNamesValue&gt; consumeGridLineNames(CSSParserTokenRange&amp; range, CSSGridLineNamesValue* lineNames = nullptr)
3360 {
3361     CSSParserTokenRange rangeCopy = range;
3362     if (rangeCopy.consumeIncludingWhitespace().type() != LeftBracketToken)
3363         return nullptr;
3364 
3365     RefPtr&lt;CSSGridLineNamesValue&gt; result = lineNames;
3366     if (!result)
3367         result = CSSGridLineNamesValue::create();
3368     while (RefPtr&lt;CSSPrimitiveValue&gt; lineName = consumeCustomIdentForGridLine(rangeCopy))
3369         result-&gt;append(lineName.releaseNonNull());
3370     if (rangeCopy.consumeIncludingWhitespace().type() != RightBracketToken)
3371         return nullptr;
3372     range = rangeCopy;
3373     return result;
3374 }
3375 
3376 static bool consumeGridTrackRepeatFunction(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode, CSSValueList&amp; list, bool&amp; isAutoRepeat, bool&amp; allTracksAreFixedSized)
3377 {
3378     CSSParserTokenRange args = consumeFunction(range);
3379     // The number of repetitions for &lt;auto-repeat&gt; is not important at parsing level
3380     // because it will be computed later, let&#39;s set it to 1.
3381     size_t repetitions = 1;
3382     isAutoRepeat = identMatches&lt;CSSValueAutoFill, CSSValueAutoFit&gt;(args.peek().id());
3383     RefPtr&lt;CSSValueList&gt; repeatedValues;
3384     if (isAutoRepeat)
3385         repeatedValues = CSSGridAutoRepeatValue::create(args.consumeIncludingWhitespace().id());
3386     else {
3387         // FIXME: a consumeIntegerRaw would be more efficient here.
3388         RefPtr&lt;CSSPrimitiveValue&gt; repetition = consumePositiveInteger(args);
3389         if (!repetition)
3390             return false;
3391         repetitions = clampTo&lt;size_t&gt;(repetition-&gt;doubleValue(), 0, GridPosition::max());
3392         repeatedValues = CSSValueList::createSpaceSeparated();
3393     }
3394     if (!consumeCommaIncludingWhitespace(args))
3395         return false;
3396     RefPtr&lt;CSSGridLineNamesValue&gt; lineNames = consumeGridLineNames(args);
3397     if (lineNames)
3398         repeatedValues-&gt;append(lineNames.releaseNonNull());
3399 
3400     size_t numberOfTracks = 0;
3401     while (!args.atEnd()) {
3402         RefPtr&lt;CSSValue&gt; trackSize = consumeGridTrackSize(args, cssParserMode);
3403         if (!trackSize)
3404             return false;
3405         if (allTracksAreFixedSized)
3406             allTracksAreFixedSized = isGridTrackFixedSized(*trackSize);
3407         repeatedValues-&gt;append(trackSize.releaseNonNull());
3408         ++numberOfTracks;
3409         lineNames = consumeGridLineNames(args);
3410         if (lineNames)
3411             repeatedValues-&gt;append(lineNames.releaseNonNull());
3412     }
3413     // We should have found at least one &lt;track-size&gt; or else it is not a valid &lt;track-list&gt;.
3414     if (!numberOfTracks)
3415         return false;
3416 
3417     if (isAutoRepeat)
3418         list.append(repeatedValues.releaseNonNull());
3419     else {
3420         // We clamp the repetitions to a multiple of the repeat() track list&#39;s size, while staying below the max grid size.
3421         repetitions = std::min(repetitions, GridPosition::max() / numberOfTracks);
3422         for (size_t i = 0; i &lt; repetitions; ++i) {
3423             for (size_t j = 0; j &lt; repeatedValues-&gt;length(); ++j)
3424                 list.append(*repeatedValues-&gt;itemWithoutBoundsCheck(j));
3425         }
3426     }
3427     return true;
3428 }
3429 
3430 enum TrackListType { GridTemplate, GridTemplateNoRepeat, GridAuto };
3431 
3432 static RefPtr&lt;CSSValue&gt; consumeGridTrackList(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode, TrackListType trackListType)
3433 {
3434     bool allowGridLineNames = trackListType != GridAuto;
3435     RefPtr&lt;CSSValueList&gt; values = CSSValueList::createSpaceSeparated();
3436     RefPtr&lt;CSSGridLineNamesValue&gt; lineNames = consumeGridLineNames(range);
3437     if (lineNames) {
3438         if (!allowGridLineNames)
3439             return nullptr;
3440         values-&gt;append(lineNames.releaseNonNull());
3441     }
3442 
3443     bool allowRepeat = trackListType == GridTemplate;
3444     bool seenAutoRepeat = false;
3445     bool allTracksAreFixedSized = true;
3446     do {
3447         bool isAutoRepeat;
3448         if (range.peek().functionId() == CSSValueRepeat) {
3449             if (!allowRepeat)
3450                 return nullptr;
3451             if (!consumeGridTrackRepeatFunction(range, cssParserMode, *values, isAutoRepeat, allTracksAreFixedSized))
3452                 return nullptr;
3453             if (isAutoRepeat &amp;&amp; seenAutoRepeat)
3454                 return nullptr;
3455             seenAutoRepeat = seenAutoRepeat || isAutoRepeat;
3456         } else if (RefPtr&lt;CSSValue&gt; value = consumeGridTrackSize(range, cssParserMode)) {
3457             if (allTracksAreFixedSized)
3458                 allTracksAreFixedSized = isGridTrackFixedSized(*value);
3459             values-&gt;append(value.releaseNonNull());
3460         } else {
3461             return nullptr;
3462         }
3463         if (seenAutoRepeat &amp;&amp; !allTracksAreFixedSized)
3464             return nullptr;
3465         lineNames = consumeGridLineNames(range);
3466         if (lineNames) {
3467             if (!allowGridLineNames)
3468                 return nullptr;
3469             values-&gt;append(lineNames.releaseNonNull());
3470         }
3471     } while (!range.atEnd() &amp;&amp; range.peek().type() != DelimiterToken);
3472     return values;
3473 }
3474 
3475 static RefPtr&lt;CSSValue&gt; consumeGridTemplatesRowsOrColumns(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode)
3476 {
3477     if (range.peek().id() == CSSValueNone)
3478         return consumeIdent(range);
3479     return consumeGridTrackList(range, cssParserMode, GridTemplate);
3480 }
3481 
3482 static RefPtr&lt;CSSValue&gt; consumeGridTemplateAreas(CSSParserTokenRange&amp; range)
3483 {
3484     if (range.peek().id() == CSSValueNone)
3485         return consumeIdent(range);
3486 
3487     NamedGridAreaMap gridAreaMap;
3488     size_t rowCount = 0;
3489     size_t columnCount = 0;
3490 
3491     while (range.peek().type() == StringToken) {
3492         if (!parseGridTemplateAreasRow(range.consumeIncludingWhitespace().value().toString(), gridAreaMap, rowCount, columnCount))
3493             return nullptr;
3494         ++rowCount;
3495     }
3496 
3497     if (rowCount == 0)
3498         return nullptr;
3499     ASSERT(columnCount);
3500     return CSSGridTemplateAreasValue::create(gridAreaMap, rowCount, columnCount);
3501 }
3502 
3503 static RefPtr&lt;CSSValue&gt; consumeLineBoxContain(CSSParserTokenRange&amp; range)
3504 {
3505     if (range.peek().id() == CSSValueNone)
3506         return consumeIdent(range);
3507 
3508     LineBoxContain lineBoxContain = LineBoxContainNone;
3509 
3510     while (range.peek().type() == IdentToken) {
3511         auto id = range.peek().id();
3512         if (id == CSSValueBlock) {
3513             if (lineBoxContain &amp; LineBoxContainBlock)
3514                 return nullptr;
3515             lineBoxContain |= LineBoxContainBlock;
3516         } else if (id == CSSValueInline) {
3517             if (lineBoxContain &amp; LineBoxContainInline)
3518                 return nullptr;
3519             lineBoxContain |= LineBoxContainInline;
3520         } else if (id == CSSValueFont) {
3521             if (lineBoxContain &amp; LineBoxContainFont)
3522                 return nullptr;
3523             lineBoxContain |= LineBoxContainFont;
3524         } else if (id == CSSValueGlyphs) {
3525             if (lineBoxContain &amp; LineBoxContainGlyphs)
3526                 return nullptr;
3527             lineBoxContain |= LineBoxContainGlyphs;
3528         } else if (id == CSSValueReplaced) {
3529             if (lineBoxContain &amp; LineBoxContainReplaced)
3530                 return nullptr;
3531             lineBoxContain |= LineBoxContainReplaced;
3532         } else if (id == CSSValueInlineBox) {
3533             if (lineBoxContain &amp; LineBoxContainInlineBox)
3534                 return nullptr;
3535             lineBoxContain |= LineBoxContainInlineBox;
3536         } else if (id == CSSValueInitialLetter) {
3537             if (lineBoxContain &amp; LineBoxContainInitialLetter)
3538                 return nullptr;
3539             lineBoxContain |= LineBoxContainInitialLetter;
3540         } else
3541             return nullptr;
3542         range.consumeIncludingWhitespace();
3543     }
3544 
3545     if (!lineBoxContain)
3546         return nullptr;
3547 
3548     return CSSLineBoxContainValue::create(lineBoxContain);
3549 }
3550 
3551 static RefPtr&lt;CSSValue&gt; consumeLineGrid(CSSParserTokenRange&amp; range)
3552 {
3553     if (range.peek().id() == CSSValueNone)
3554         return consumeIdent(range);
3555     return consumeCustomIdent(range);
3556 }
3557 
3558 static RefPtr&lt;CSSValue&gt; consumeInitialLetter(CSSParserTokenRange&amp; range)
3559 {
3560     RefPtr&lt;CSSValue&gt; ident = consumeIdent&lt;CSSValueNormal&gt;(range);
3561     if (ident)
3562         return ident;
3563 
3564     RefPtr&lt;CSSPrimitiveValue&gt; height = consumeNumber(range, ValueRangeNonNegative);
3565     if (!height)
3566         return nullptr;
3567 
3568     RefPtr&lt;CSSPrimitiveValue&gt; position;
3569     if (!range.atEnd()) {
3570         position = consumeNumber(range, ValueRangeNonNegative);
3571         if (!position || !range.atEnd())
3572             return nullptr;
3573     } else
3574         position = height.copyRef();
3575 
3576     return createPrimitiveValuePair(position.releaseNonNull(), WTFMove(height));
3577 }
3578 
3579 static RefPtr&lt;CSSValue&gt; consumeSpeakAs(CSSParserTokenRange&amp; range)
3580 {
3581     if (range.peek().id() == CSSValueNone)
3582         return consumeIdent(range);
3583 
3584     RefPtr&lt;CSSValueList&gt; list = CSSValueList::createSpaceSeparated();
3585 
3586     bool seenNormal = false;
3587     bool seenSpellOut = false;
3588     bool seenLiteralPunctuation = false;
3589     bool seenNoPunctuation = false;
3590 
3591     // normal | spell-out || digits || [ literal-punctuation | no-punctuation ]
3592     while (!range.atEnd()) {
3593         CSSValueID valueID = range.peek().id();
3594         if ((valueID == CSSValueNormal &amp;&amp; seenSpellOut)
3595             || (valueID == CSSValueSpellOut &amp;&amp; seenNormal)
3596             || (valueID == CSSValueLiteralPunctuation &amp;&amp; seenNoPunctuation)
3597             || (valueID == CSSValueNoPunctuation &amp;&amp; seenLiteralPunctuation))
3598             return nullptr;
3599         RefPtr&lt;CSSValue&gt; ident = consumeIdent&lt;CSSValueNormal, CSSValueSpellOut, CSSValueDigits, CSSValueLiteralPunctuation, CSSValueNoPunctuation&gt;(range);
3600         if (!ident)
3601             return nullptr;
3602         switch (valueID) {
3603         case CSSValueNormal:
3604             seenNormal = true;
3605             break;
3606         case CSSValueSpellOut:
3607             seenSpellOut = true;
3608             break;
3609         case CSSValueLiteralPunctuation:
3610             seenLiteralPunctuation = true;
3611             break;
3612         case CSSValueNoPunctuation:
3613             seenNoPunctuation = true;
3614             break;
3615         default:
3616             break;
3617         }
3618         list-&gt;append(ident.releaseNonNull());
3619     }
3620 
3621     return list-&gt;length() ? list : nullptr;
3622 }
3623 
3624 static RefPtr&lt;CSSValue&gt; consumeHangingPunctuation(CSSParserTokenRange&amp; range)
3625 {
3626     if (range.peek().id() == CSSValueNone)
3627         return consumeIdent(range);
3628 
3629     RefPtr&lt;CSSValueList&gt; list = CSSValueList::createSpaceSeparated();
3630 
3631     bool seenForceEnd = false;
3632     bool seenAllowEnd = false;
3633     bool seenFirst = false;
3634     bool seenLast = false;
3635 
3636     while (!range.atEnd()) {
3637         CSSValueID valueID = range.peek().id();
3638         if ((valueID == CSSValueFirst &amp;&amp; seenFirst)
3639             || (valueID == CSSValueLast &amp;&amp; seenLast)
3640             || (valueID == CSSValueAllowEnd &amp;&amp; (seenAllowEnd || seenForceEnd))
3641             || (valueID == CSSValueForceEnd &amp;&amp; (seenAllowEnd || seenForceEnd)))
3642             return nullptr;
3643         RefPtr&lt;CSSValue&gt; ident = consumeIdent&lt;CSSValueAllowEnd, CSSValueForceEnd, CSSValueFirst, CSSValueLast&gt;(range);
3644         if (!ident)
3645             return nullptr;
3646         switch (valueID) {
3647         case CSSValueAllowEnd:
3648             seenAllowEnd = true;
3649             break;
3650         case CSSValueForceEnd:
3651             seenForceEnd = true;
3652             break;
3653         case CSSValueFirst:
3654             seenFirst = true;
3655             break;
3656         case CSSValueLast:
3657             seenLast = true;
3658             break;
3659         default:
3660             break;
3661         }
3662         list-&gt;append(ident.releaseNonNull());
3663     }
3664 
3665     return list-&gt;length() ? list : nullptr;
3666 }
3667 
3668 static RefPtr&lt;CSSValue&gt; consumeWebkitMarqueeIncrement(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode)
3669 {
3670     if (range.peek().type() == IdentToken)
3671         return consumeIdent&lt;CSSValueSmall, CSSValueMedium, CSSValueLarge&gt;(range);
3672     return consumeLengthOrPercent(range, cssParserMode, ValueRangeAll, UnitlessQuirk::Allow);
3673 }
3674 
3675 static RefPtr&lt;CSSValue&gt; consumeWebkitMarqueeRepetition(CSSParserTokenRange&amp; range)
3676 {
3677     if (range.peek().type() == IdentToken)
3678         return consumeIdent&lt;CSSValueInfinite&gt;(range);
3679     return consumeNumber(range, ValueRangeNonNegative);
3680 }
3681 
3682 static RefPtr&lt;CSSValue&gt; consumeWebkitMarqueeSpeed(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode)
3683 {
3684     if (range.peek().type() == IdentToken)
3685         return consumeIdent&lt;CSSValueSlow, CSSValueNormal, CSSValueFast&gt;(range);
3686     return consumeTime(range, cssParserMode, ValueRangeNonNegative, UnitlessQuirk::Allow);
3687 }
3688 
3689 static RefPtr&lt;CSSValue&gt; consumeAlt(CSSParserTokenRange&amp; range, const CSSParserContext&amp; context)
3690 {
3691     if (range.peek().type() == StringToken)
3692         return consumeString(range);
3693 
3694     if (range.peek().functionId() != CSSValueAttr)
3695         return nullptr;
3696 
3697     return consumeAttr(consumeFunction(range), context);
3698 }
3699 
3700 static RefPtr&lt;CSSValue&gt; consumeWebkitAspectRatio(CSSParserTokenRange&amp; range)
3701 {
3702     if (range.peek().type() == IdentToken)
3703         return consumeIdent&lt;CSSValueAuto, CSSValueFromDimensions, CSSValueFromIntrinsic&gt;(range);
3704 
3705     RefPtr&lt;CSSPrimitiveValue&gt; leftValue = consumeNumber(range, ValueRangeNonNegative);
3706     if (!leftValue || !leftValue-&gt;floatValue() || range.atEnd() || !consumeSlashIncludingWhitespace(range))
3707         return nullptr;
3708     RefPtr&lt;CSSPrimitiveValue&gt; rightValue = consumeNumber(range, ValueRangeNonNegative);
3709     if (!rightValue || !rightValue-&gt;floatValue())
3710         return nullptr;
3711 
3712     return CSSAspectRatioValue::create(leftValue-&gt;floatValue(), rightValue-&gt;floatValue());
3713 }
3714 
3715 static RefPtr&lt;CSSValue&gt; consumeTextEmphasisPosition(CSSParserTokenRange&amp; range)
3716 {
3717     bool foundOverOrUnder = false;
3718     CSSValueID overUnderValueID = CSSValueOver;
3719     bool foundLeftOrRight = false;
3720     CSSValueID leftRightValueID = CSSValueRight;
3721     while (!range.atEnd()) {
3722         switch (range.peek().id()) {
3723         case CSSValueOver:
3724             if (foundOverOrUnder)
3725                 return nullptr;
3726             foundOverOrUnder = true;
3727             overUnderValueID = CSSValueOver;
3728             break;
3729         case CSSValueUnder:
3730             if (foundOverOrUnder)
3731                 return nullptr;
3732             foundOverOrUnder = true;
3733             overUnderValueID = CSSValueUnder;
3734             break;
3735         case CSSValueLeft:
3736             if (foundLeftOrRight)
3737                 return nullptr;
3738             foundLeftOrRight = true;
3739             leftRightValueID = CSSValueLeft;
3740             break;
3741         case CSSValueRight:
3742             if (foundLeftOrRight)
3743                 return nullptr;
3744             foundLeftOrRight = true;
3745             leftRightValueID = CSSValueRight;
3746             break;
3747         default:
3748             return nullptr;
3749         }
3750 
3751         range.consumeIncludingWhitespace();
3752     }
3753     if (!foundOverOrUnder)
3754         return nullptr;
3755     RefPtr&lt;CSSValueList&gt; list = CSSValueList::createSpaceSeparated();
3756     list-&gt;append(CSSValuePool::singleton().createIdentifierValue(overUnderValueID));
3757     if (foundLeftOrRight)
3758         list-&gt;append(CSSValuePool::singleton().createIdentifierValue(leftRightValueID));
3759     return list;
3760 }
3761 
3762 #if ENABLE(DARK_MODE_CSS)
3763 
3764 static RefPtr&lt;CSSValue&gt; consumeSupportedColorSchemes(CSSParserTokenRange&amp; range)
3765 {
3766     if (isAuto(range.peek().id()))
3767         return consumeIdent(range);
3768 
3769     Vector&lt;CSSValueID, 3&gt; identifiers;
3770 
3771     while (!range.atEnd()) {
3772         if (range.peek().type() != IdentToken)
3773             return nullptr;
3774 
3775         CSSValueID id = range.peek().id();
3776 
3777         switch (id) {
3778         case CSSValueAuto:
3779             // Auto is only allowed as a single value, and was handled earlier.
3780             // Don&#39;t allow it in the list.
3781             return nullptr;
3782 
3783         case CSSValueOnly:
3784         case CSSValueLight:
3785         case CSSValueDark:
3786             if (!identifiers.appendIfNotContains(id))
3787                 return nullptr;
3788             break;
3789 
3790         default:
3791             // Unknown identifiers are allowed and ignored.
3792             break;
3793         }
3794 
3795         range.consumeIncludingWhitespace();
3796     }
3797 
3798     RefPtr&lt;CSSValueList&gt; list = CSSValueList::createSpaceSeparated();
3799     for (auto id : identifiers)
3800         list-&gt;append(CSSValuePool::singleton().createIdentifierValue(id));
3801     return list;
3802 }
3803 
3804 #endif
3805 
3806 #if ENABLE(DASHBOARD_SUPPORT)
3807 
3808 static RefPtr&lt;CSSValue&gt; consumeWebkitDashboardRegion(CSSParserTokenRange&amp; range, CSSParserMode mode)
3809 {
3810     if (range.atEnd())
3811         return nullptr;
3812 
3813     if (range.peek().id() == CSSValueNone)
3814         return consumeIdent(range);
3815 
3816     auto firstRegion = DashboardRegion::create();
3817     DashboardRegion* region = nullptr;
3818 
3819     bool requireCommas = false;
3820 
3821     while (!range.atEnd()) {
3822         if (!region)
3823             region = firstRegion.ptr();
3824         else {
3825             auto nextRegion = DashboardRegion::create();
3826             region-&gt;m_next = nextRegion.copyRef();
3827             region = nextRegion.ptr();
3828         }
3829 
3830         if (range.peek().functionId() != CSSValueDashboardRegion)
3831             return nullptr;
3832 
3833         CSSParserTokenRange rangeCopy = range;
3834         CSSParserTokenRange args = consumeFunction(rangeCopy);
3835         if (rangeCopy.end() == args.end())
3836             return nullptr; // No ) was found. Be strict about this, since tests are.
3837 
3838         // First arg is a label.
3839         if (args.peek().type() != IdentToken)
3840             return nullptr;
3841         region-&gt;m_label = args.consumeIncludingWhitespace().value().toString();
3842 
3843         // Comma is optional, so don&#39;t fail if we can&#39;t consume one.
3844         requireCommas = consumeCommaIncludingWhitespace(args);
3845 
3846         // Second arg is a type.
3847         if (args.peek().type() != IdentToken)
3848             return nullptr;
3849         region-&gt;m_geometryType = args.consumeIncludingWhitespace().value().toString();
3850         if (equalLettersIgnoringASCIICase(region-&gt;m_geometryType, &quot;circle&quot;))
3851             region-&gt;m_isCircle = true;
3852         else if (equalLettersIgnoringASCIICase(region-&gt;m_geometryType, &quot;rectangle&quot;))
3853             region-&gt;m_isRectangle = true;
3854         else
3855             return nullptr;
3856 
3857         if (args.atEnd()) {
3858             // This originally used CSSValueInvalid by accident. It might be more logical to use something else.
3859             RefPtr&lt;CSSPrimitiveValue&gt; amount = CSSValuePool::singleton().createIdentifierValue(CSSValueInvalid);
3860             region-&gt;setTop(amount.copyRef());
3861             region-&gt;setRight(amount.copyRef());
3862             region-&gt;setBottom(amount.copyRef());
3863             region-&gt;setLeft(WTFMove(amount));
3864             range = rangeCopy;
3865             continue;
3866         }
3867 
3868         // Next four arguments must be offset numbers or auto.
3869         for (int i = 0; i &lt; 4; ++i) {
3870             if (args.atEnd() || (requireCommas &amp;&amp; !consumeCommaIncludingWhitespace(args)))
3871                 return nullptr;
3872 
3873             if (args.atEnd())
3874                 return nullptr;
3875 
3876             RefPtr&lt;CSSPrimitiveValue&gt; amount;
3877             if (args.peek().id() == CSSValueAuto)
3878                 amount = consumeIdent(args);
3879             else
3880                 amount = consumeLength(args, mode, ValueRangeAll);
3881 
3882             if (!i)
3883                 region-&gt;setTop(WTFMove(amount));
3884             else if (i == 1)
3885                 region-&gt;setRight(WTFMove(amount));
3886             else if (i == 2)
3887                 region-&gt;setBottom(WTFMove(amount));
3888             else
3889                 region-&gt;setLeft(WTFMove(amount));
3890         }
3891 
3892         if (!args.atEnd())
3893             return nullptr;
3894 
3895         range = rangeCopy;
3896     }
3897 
3898     return CSSValuePool::singleton().createValue(RefPtr&lt;DashboardRegion&gt;(WTFMove(firstRegion)));
3899 }
3900 
3901 #endif
3902 
3903 RefPtr&lt;CSSValue&gt; CSSPropertyParser::parseSingleValue(CSSPropertyID property, CSSPropertyID currentShorthand)
3904 {
3905     if (CSSParserFastPaths::isKeywordPropertyID(property)) {
3906         if (!CSSParserFastPaths::isValidKeywordPropertyAndValue(property, m_range.peek().id(), m_context.mode))
3907             return nullptr;
3908         return consumeIdent(m_range);
3909     }
3910     switch (property) {
3911     case CSSPropertyWillChange:
3912         return consumeWillChange(m_range);
3913     case CSSPropertyPage:
3914         return consumePage(m_range);
3915     case CSSPropertyQuotes:
3916         return consumeQuotes(m_range);
3917     case CSSPropertyFontVariantCaps:
3918         return consumeFontVariantCaps(m_range);
3919     case CSSPropertyFontVariantLigatures:
3920         return consumeFontVariantLigatures(m_range);
3921     case CSSPropertyFontVariantNumeric:
3922         return consumeFontVariantNumeric(m_range);
3923     case CSSPropertyFontVariantEastAsian:
3924         return consumeFontVariantEastAsian(m_range);
3925     case CSSPropertyFontFeatureSettings:
3926         return consumeFontFeatureSettings(m_range);
3927     case CSSPropertyFontFamily:
3928         return consumeFontFamily(m_range);
3929     case CSSPropertyFontWeight:
3930         return consumeFontWeight(m_range);
3931     case CSSPropertyFontStretch:
3932         return consumeFontStretch(m_range);
3933     case CSSPropertyFontStyle:
3934         return consumeFontStyle(m_range, m_context.mode);
3935     case CSSPropertyFontSynthesis:
3936         return consumeFontSynthesis(m_range);
3937 #if ENABLE(VARIATION_FONTS)
3938     case CSSPropertyFontVariationSettings:
3939         return consumeFontVariationSettings(m_range);
3940 #endif
3941     case CSSPropertyLetterSpacing:
3942         return consumeLetterSpacing(m_range, m_context.mode);
3943     case CSSPropertyWordSpacing:
3944         return consumeWordSpacing(m_range, m_context.mode);
3945     case CSSPropertyTabSize:
3946         return consumeTabSize(m_range, m_context.mode);
3947 #if ENABLE(TEXT_AUTOSIZING)
3948     case CSSPropertyWebkitTextSizeAdjust:
3949         // FIXME: Support toggling the validation of this property via a runtime setting that is independent of
3950         // whether isTextAutosizingEnabled() is true. We want to enable this property on iOS, when simulating
3951         // a iOS device in Safari&#39;s responsive design mode and when optionally enabled in DRT/WTR. Otherwise,
3952         // this property should be disabled by default.
3953 #if !PLATFORM(IOS_FAMILY)
3954         if (!m_context.textAutosizingEnabled)
3955             return nullptr;
3956 #endif
3957         return consumeTextSizeAdjust(m_range, m_context.mode);
3958 #endif
3959     case CSSPropertyFontSize:
3960         return consumeFontSize(m_range, m_context.mode, UnitlessQuirk::Allow);
3961     case CSSPropertyLineHeight:
3962         return consumeLineHeight(m_range, m_context.mode);
3963     case CSSPropertyWebkitBorderHorizontalSpacing:
3964     case CSSPropertyWebkitBorderVerticalSpacing:
3965         return consumeLength(m_range, m_context.mode, ValueRangeNonNegative);
3966     case CSSPropertyCounterIncrement:
3967     case CSSPropertyCounterReset:
3968         return consumeCounter(m_range, property == CSSPropertyCounterIncrement ? 1 : 0);
3969     case CSSPropertySize:
3970         return consumeSize(m_range, m_context.mode);
3971     case CSSPropertyTextIndent:
3972         return consumeTextIndent(m_range, m_context.mode);
3973     case CSSPropertyMaxWidth:
3974     case CSSPropertyMaxHeight:
3975         return consumeMaxWidthOrHeight(m_range, m_context, UnitlessQuirk::Allow);
3976     case CSSPropertyMaxInlineSize:
3977     case CSSPropertyMaxBlockSize:
3978         return consumeMaxWidthOrHeight(m_range, m_context);
3979     case CSSPropertyMinWidth:
3980     case CSSPropertyMinHeight:
3981     case CSSPropertyWidth:
3982     case CSSPropertyHeight:
3983         return consumeWidthOrHeight(m_range, m_context, UnitlessQuirk::Allow);
3984     case CSSPropertyMinInlineSize:
3985     case CSSPropertyMinBlockSize:
3986     case CSSPropertyInlineSize:
3987     case CSSPropertyBlockSize:
3988         return consumeWidthOrHeight(m_range, m_context);
3989     case CSSPropertyMarginTop:
3990     case CSSPropertyMarginRight:
3991     case CSSPropertyMarginBottom:
3992     case CSSPropertyMarginLeft:
3993     case CSSPropertyBottom:
3994     case CSSPropertyLeft:
3995     case CSSPropertyRight:
3996     case CSSPropertyTop: {
3997         UnitlessQuirk unitless = currentShorthand != CSSPropertyInset ? UnitlessQuirk::Allow : UnitlessQuirk::Forbid;
3998         return consumeMarginOrOffset(m_range, m_context.mode, unitless);
3999     }
4000     case CSSPropertyInsetInlineStart:
4001     case CSSPropertyInsetInlineEnd:
4002     case CSSPropertyInsetBlockStart:
4003     case CSSPropertyInsetBlockEnd:
4004     case CSSPropertyMarginInlineStart:
4005     case CSSPropertyMarginInlineEnd:
4006     case CSSPropertyMarginBlockStart:
4007     case CSSPropertyMarginBlockEnd:
4008         return consumeMarginOrOffset(m_range, m_context.mode, UnitlessQuirk::Forbid);
4009     case CSSPropertyPaddingTop:
4010     case CSSPropertyPaddingRight:
4011     case CSSPropertyPaddingBottom:
4012     case CSSPropertyPaddingLeft:
4013         return consumeLengthOrPercent(m_range, m_context.mode, ValueRangeNonNegative, UnitlessQuirk::Allow);
4014     case CSSPropertyPaddingInlineStart:
4015     case CSSPropertyPaddingInlineEnd:
4016     case CSSPropertyPaddingBlockStart:
4017     case CSSPropertyPaddingBlockEnd:
4018         return consumeLengthOrPercent(m_range, m_context.mode, ValueRangeNonNegative, UnitlessQuirk::Forbid);
4019 #if ENABLE(CSS_SCROLL_SNAP)
4020     case CSSPropertyScrollSnapMarginBottom:
4021     case CSSPropertyScrollSnapMarginLeft:
4022     case CSSPropertyScrollSnapMarginRight:
4023     case CSSPropertyScrollSnapMarginTop:
4024         return consumeLength(m_range, m_context.mode, ValueRangeAll);
4025     case CSSPropertyScrollPaddingBottom:
4026     case CSSPropertyScrollPaddingLeft:
4027     case CSSPropertyScrollPaddingRight:
4028     case CSSPropertyScrollPaddingTop:
4029         return consumeLengthOrPercent(m_range, m_context.mode, ValueRangeAll);
4030     case CSSPropertyScrollSnapAlign:
4031         return consumeScrollSnapAlign(m_range);
4032     case CSSPropertyScrollSnapType:
4033         return consumeScrollSnapType(m_range);
4034 #endif
4035     case CSSPropertyClip:
4036         return consumeClip(m_range, m_context.mode);
4037 #if ENABLE(POINTER_EVENTS)
4038     case CSSPropertyTouchAction:
4039         return consumeTouchAction(m_range);
4040 #endif
4041     case CSSPropertyObjectPosition:
4042         return consumePosition(m_range, m_context.mode, UnitlessQuirk::Forbid);
4043     case CSSPropertyWebkitLineClamp:
4044         return consumeLineClamp(m_range);
4045     case CSSPropertyWebkitFontSizeDelta:
4046         return consumeLength(m_range, m_context.mode, ValueRangeAll, UnitlessQuirk::Allow);
4047     case CSSPropertyWebkitHyphenateCharacter:
4048     case CSSPropertyWebkitLocale:
4049         return consumeAutoOrString(m_range);
4050     case CSSPropertyWebkitHyphenateLimitBefore:
4051     case CSSPropertyWebkitHyphenateLimitAfter:
4052         return consumeHyphenateLimit(m_range, CSSValueAuto);
4053     case CSSPropertyWebkitHyphenateLimitLines:
4054         return consumeHyphenateLimit(m_range, CSSValueNoLimit);
4055     case CSSPropertyColumnWidth:
4056         return consumeColumnWidth(m_range);
4057     case CSSPropertyColumnCount:
4058         return consumeColumnCount(m_range);
4059     case CSSPropertyColumnGap:
4060         return consumeGapLength(m_range, m_context.mode);
4061     case CSSPropertyRowGap:
4062         return consumeGapLength(m_range, m_context.mode);
4063     case CSSPropertyColumnSpan:
4064         return consumeColumnSpan(m_range);
4065     case CSSPropertyZoom:
4066         return consumeZoom(m_range, m_context);
4067     case CSSPropertyAnimationDelay:
4068     case CSSPropertyTransitionDelay:
4069     case CSSPropertyAnimationDirection:
4070     case CSSPropertyAnimationDuration:
4071     case CSSPropertyTransitionDuration:
4072     case CSSPropertyAnimationFillMode:
4073     case CSSPropertyAnimationIterationCount:
4074     case CSSPropertyAnimationName:
4075     case CSSPropertyAnimationPlayState:
4076     case CSSPropertyTransitionProperty:
4077     case CSSPropertyAnimationTimingFunction:
4078     case CSSPropertyTransitionTimingFunction:
4079         return consumeAnimationPropertyList(property, m_range, m_context);
4080     case CSSPropertyShapeMargin:
4081         return consumeLengthOrPercent(m_range, m_context.mode, ValueRangeNonNegative);
4082     case CSSPropertyShapeImageThreshold:
4083         return consumeNumber(m_range, ValueRangeAll);
4084     case CSSPropertyWebkitBoxOrdinalGroup:
4085     case CSSPropertyOrphans:
4086     case CSSPropertyWidows:
4087         return consumePositiveInteger(m_range);
4088     case CSSPropertyTextDecorationColor:
4089         return consumeColor(m_range, m_context.mode);
4090     case CSSPropertyTextDecorationSkip:
4091         return consumeTextDecorationSkip(m_range);
4092     case CSSPropertyWebkitTextStrokeWidth:
4093         return consumeTextStrokeWidth(m_range, m_context.mode);
4094     case CSSPropertyWebkitTextFillColor:
4095 #if ENABLE(TOUCH_EVENTS)
4096     case CSSPropertyWebkitTapHighlightColor:
4097 #endif
4098     case CSSPropertyWebkitTextEmphasisColor:
4099     case CSSPropertyBorderInlineStartColor:
4100     case CSSPropertyBorderInlineEndColor:
4101     case CSSPropertyBorderBlockStartColor:
4102     case CSSPropertyBorderBlockEndColor:
4103     case CSSPropertyWebkitTextStrokeColor:
4104     case CSSPropertyStrokeColor:
4105     case CSSPropertyStopColor:
4106     case CSSPropertyFloodColor:
4107     case CSSPropertyLightingColor:
4108     case CSSPropertyColumnRuleColor:
4109         return consumeColor(m_range, m_context.mode);
4110     case CSSPropertyCaretColor:
4111         return consumeCaretColor(m_range, m_context.mode);
4112     case CSSPropertyColor:
4113     case CSSPropertyBackgroundColor:
4114         return consumeColor(m_range, m_context.mode, inQuirksMode());
4115     case CSSPropertyBorderInlineStartWidth:
4116     case CSSPropertyBorderInlineEndWidth:
4117     case CSSPropertyBorderBlockStartWidth:
4118     case CSSPropertyBorderBlockEndWidth:
4119         return consumeBorderWidth(m_range, m_context.mode, UnitlessQuirk::Forbid);
4120     case CSSPropertyBorderBottomColor:
4121     case CSSPropertyBorderLeftColor:
4122     case CSSPropertyBorderRightColor:
4123     case CSSPropertyBorderTopColor: {
4124         bool allowQuirkyColors = inQuirksMode()
4125             &amp;&amp; (currentShorthand == CSSPropertyInvalid || currentShorthand == CSSPropertyBorderColor);
4126         return consumeColor(m_range, m_context.mode, allowQuirkyColors);
4127     }
4128     case CSSPropertyBorderBottomWidth:
4129     case CSSPropertyBorderLeftWidth:
4130     case CSSPropertyBorderRightWidth:
4131     case CSSPropertyBorderTopWidth: {
4132         bool allowQuirkyLengths = inQuirksMode()
4133             &amp;&amp; (currentShorthand == CSSPropertyInvalid || currentShorthand == CSSPropertyBorderWidth);
4134         UnitlessQuirk unitless = allowQuirkyLengths ? UnitlessQuirk::Allow : UnitlessQuirk::Forbid;
4135         return consumeBorderWidth(m_range, m_context.mode, unitless);
4136     }
4137     case CSSPropertyZIndex:
4138         return consumeZIndex(m_range);
4139     case CSSPropertyTextShadow: // CSS2 property, dropped in CSS2.1, back in CSS3, so treat as CSS3
4140     case CSSPropertyBoxShadow:
4141     case CSSPropertyWebkitBoxShadow:
4142         return consumeShadow(m_range, m_context.mode, property == CSSPropertyBoxShadow || property == CSSPropertyWebkitBoxShadow);
4143     case CSSPropertyFilter:
4144 #if ENABLE(FILTERS_LEVEL_2)
4145     case CSSPropertyWebkitBackdropFilter:
4146 #endif
4147         return consumeFilter(m_range, m_context, AllowedFilterFunctions::PixelFilters);
4148     case CSSPropertyAppleColorFilter:
4149         if (!m_context.colorFilterEnabled)
4150             return nullptr;
4151         return consumeFilter(m_range, m_context, AllowedFilterFunctions::ColorFilters);
4152     case CSSPropertyTextDecoration:
4153     case CSSPropertyWebkitTextDecorationsInEffect:
4154     case CSSPropertyTextDecorationLine:
4155         return consumeTextDecorationLine(m_range);
4156     case CSSPropertyWebkitTextEmphasisStyle:
4157         return consumeTextEmphasisStyle(m_range);
4158     case CSSPropertyOutlineColor:
4159         return consumeOutlineColor(m_range, m_context.mode);
4160     case CSSPropertyOutlineOffset:
4161         return consumeLength(m_range, m_context.mode, ValueRangeAll);
4162     case CSSPropertyOutlineWidth:
4163         return consumeLineWidth(m_range, m_context.mode, UnitlessQuirk::Forbid);
4164     case CSSPropertyTransform:
4165         return consumeTransform(m_range, m_context.mode);
4166     case CSSPropertyTransformBox:
4167         return consumeIdent&lt;CSSValueBorderBox, CSSValueViewBox, CSSValueFillBox&gt;(m_range);
4168     case CSSPropertyTransformOriginX:
4169     case CSSPropertyPerspectiveOriginX:
4170         return consumePositionX(m_range, m_context.mode);
4171     case CSSPropertyTransformOriginY:
4172     case CSSPropertyPerspectiveOriginY:
4173         return consumePositionY(m_range, m_context.mode);
4174     case CSSPropertyTransformOriginZ:
4175         return consumeLength(m_range, m_context.mode, ValueRangeAll);
4176     case CSSPropertyFill:
4177     case CSSPropertyStroke:
4178         return consumePaintStroke(m_range, m_context.mode);
4179     case CSSPropertyGlyphOrientationVertical:
4180     case CSSPropertyGlyphOrientationHorizontal:
4181         return consumeGlyphOrientation(m_range, m_context.mode, property);
4182     case CSSPropertyPaintOrder:
4183         return consumePaintOrder(m_range);
4184     case CSSPropertyMarkerStart:
4185     case CSSPropertyMarkerMid:
4186     case CSSPropertyMarkerEnd:
4187     case CSSPropertyClipPath:
4188     case CSSPropertyMask:
4189         return consumeNoneOrURI(m_range);
4190     case CSSPropertyFlexBasis:
4191         return consumeFlexBasis(m_range, m_context.mode);
4192     case CSSPropertyFlexGrow:
4193     case CSSPropertyFlexShrink:
4194         return consumeNumber(m_range, ValueRangeNonNegative);
4195     case CSSPropertyStrokeDasharray:
4196         return consumeStrokeDasharray(m_range);
4197     case CSSPropertyColumnRuleWidth:
4198         return consumeColumnRuleWidth(m_range, m_context.mode);
4199     case CSSPropertyStrokeOpacity:
4200     case CSSPropertyFillOpacity:
4201     case CSSPropertyStopOpacity:
4202     case CSSPropertyFloodOpacity:
4203     case CSSPropertyOpacity:
4204     case CSSPropertyWebkitBoxFlex:
4205         return consumeNumber(m_range, ValueRangeAll);
4206     case CSSPropertyBaselineShift:
4207         return consumeBaselineShift(m_range);
4208     case CSSPropertyKerning:
4209         return consumeKerning(m_range, m_context.mode);
4210     case CSSPropertyStrokeMiterlimit:
4211         return consumeNumber(m_range, ValueRangeNonNegative);
4212     case CSSPropertyStrokeWidth:
4213     case CSSPropertyStrokeDashoffset:
4214     case CSSPropertyCx:
4215     case CSSPropertyCy:
4216     case CSSPropertyX:
4217     case CSSPropertyY:
4218     case CSSPropertyR:
4219         return consumeLengthOrPercent(m_range, SVGAttributeMode, ValueRangeAll, UnitlessQuirk::Forbid);
4220     case CSSPropertyRx:
4221     case CSSPropertyRy:
4222         return consumeRxOrRy(m_range);
4223     case CSSPropertyCursor:
4224         return consumeCursor(m_range, m_context, inQuirksMode());
4225     case CSSPropertyContent:
4226         return consumeContent(m_range, m_context);
4227     case CSSPropertyListStyleImage:
4228     case CSSPropertyBorderImageSource:
4229     case CSSPropertyWebkitMaskBoxImageSource:
4230         return consumeImageOrNone(m_range, m_context);
4231     case CSSPropertyPerspective:
4232         return consumePerspective(m_range, m_context.mode);
4233     case CSSPropertyBorderTopRightRadius:
4234     case CSSPropertyBorderTopLeftRadius:
4235     case CSSPropertyBorderBottomLeftRadius:
4236     case CSSPropertyBorderBottomRightRadius:
4237         return consumeBorderRadiusCorner(m_range, m_context.mode);
4238     case CSSPropertyWebkitBoxFlexGroup:
4239         return consumeInteger(m_range, 0);
4240     case CSSPropertyOrder:
4241         return consumeInteger(m_range);
4242     case CSSPropertyTextUnderlinePosition:
4243         // auto | [ [ under | from-font ] || [ left | right ] ], but we only support auto | under | from-font for now
4244         return consumeIdent&lt;CSSValueAuto, CSSValueUnder, CSSValueFromFont&gt;(m_range);
4245     case CSSPropertyTextUnderlineOffset:
4246         return consumeTextUnderlineOffset(m_range, m_context.mode);
4247     case CSSPropertyTextDecorationThickness:
4248         return consumeTextDecorationThickness(m_range, m_context.mode);
4249     case CSSPropertyVerticalAlign:
4250         return consumeVerticalAlign(m_range, m_context.mode);
4251     case CSSPropertyShapeOutside:
4252         return consumeShapeOutside(m_range, m_context);
4253     case CSSPropertyWebkitClipPath:
4254         return consumeWebkitClipPath(m_range, m_context);
4255     case CSSPropertyJustifyContent:
4256         // justify-content property does not allow the &lt;baseline-position&gt; values.
4257         if (isBaselineKeyword(m_range.peek().id()))
4258             return nullptr;
4259         return consumeContentDistributionOverflowPosition(m_range, isContentPositionOrLeftOrRightKeyword);
4260     case CSSPropertyAlignContent:
4261         return consumeContentDistributionOverflowPosition(m_range, isContentPositionKeyword);
4262     case CSSPropertyBorderImageRepeat:
4263     case CSSPropertyWebkitMaskBoxImageRepeat:
4264         return consumeBorderImageRepeat(m_range);
4265     case CSSPropertyBorderImageSlice:
4266     case CSSPropertyWebkitMaskBoxImageSlice:
4267         return consumeBorderImageSlice(property, m_range);
4268     case CSSPropertyBorderImageOutset:
4269     case CSSPropertyWebkitMaskBoxImageOutset:
4270         return consumeBorderImageOutset(m_range);
4271     case CSSPropertyBorderImageWidth:
4272     case CSSPropertyWebkitMaskBoxImageWidth:
4273         return consumeBorderImageWidth(m_range);
4274     case CSSPropertyWebkitBorderImage:
4275     case CSSPropertyWebkitMaskBoxImage:
4276         return consumeWebkitBorderImage(property, m_range, m_context);
4277     case CSSPropertyWebkitBoxReflect:
4278         return consumeReflect(m_range, m_context);
4279     case CSSPropertyWebkitLineBoxContain:
4280         return consumeLineBoxContain(m_range);
4281 #if ENABLE(CSS_IMAGE_ORIENTATION)
4282     case CSSPropertyImageOrientation:
4283         return consumeImageOrientation(m_range, m_context.mode);
4284 #endif
4285     case CSSPropertyBackgroundAttachment:
4286     case CSSPropertyBackgroundBlendMode:
4287     case CSSPropertyBackgroundClip:
4288     case CSSPropertyBackgroundImage:
4289     case CSSPropertyBackgroundOrigin:
4290     case CSSPropertyBackgroundPositionX:
4291     case CSSPropertyBackgroundPositionY:
4292     case CSSPropertyBackgroundSize:
4293     case CSSPropertyWebkitBackgroundClip:
4294     case CSSPropertyWebkitBackgroundOrigin:
4295     case CSSPropertyWebkitBackgroundComposite:
4296     case CSSPropertyWebkitBackgroundSize:
4297     case CSSPropertyWebkitMaskClip:
4298     case CSSPropertyWebkitMaskComposite:
4299     case CSSPropertyWebkitMaskImage:
4300     case CSSPropertyWebkitMaskOrigin:
4301     case CSSPropertyWebkitMaskPositionX:
4302     case CSSPropertyWebkitMaskPositionY:
4303     case CSSPropertyWebkitMaskSize:
4304     case CSSPropertyWebkitMaskSourceType:
4305         return consumeCommaSeparatedBackgroundComponent(property, m_range, m_context);
4306     case CSSPropertyWebkitMaskRepeatX:
4307     case CSSPropertyWebkitMaskRepeatY:
4308         return nullptr;
4309     case CSSPropertyAlignItems:
4310         return consumeAlignItems(m_range);
4311     case CSSPropertyJustifySelf:
4312         return consumeSelfPositionOverflowPosition(m_range, isSelfPositionOrLeftOrRightKeyword);
4313     case CSSPropertyAlignSelf:
4314         return consumeSelfPositionOverflowPosition(m_range, isSelfPositionKeyword);
4315     case CSSPropertyJustifyItems:
4316         return consumeJustifyItems(m_range);
4317     case CSSPropertyGridColumnEnd:
4318     case CSSPropertyGridColumnStart:
4319     case CSSPropertyGridRowEnd:
4320     case CSSPropertyGridRowStart:
4321         return consumeGridLine(m_range);
4322     case CSSPropertyGridAutoColumns:
4323     case CSSPropertyGridAutoRows:
4324         return consumeGridTrackList(m_range, m_context.mode, GridAuto);
4325     case CSSPropertyGridTemplateColumns:
4326     case CSSPropertyGridTemplateRows:
4327         return consumeGridTemplatesRowsOrColumns(m_range, m_context.mode);
4328     case CSSPropertyGridTemplateAreas:
4329         return consumeGridTemplateAreas(m_range);
4330     case CSSPropertyGridAutoFlow:
4331         return consumeGridAutoFlow(m_range);
4332     case CSSPropertyWebkitLineGrid:
4333         return consumeLineGrid(m_range);
4334     case CSSPropertyWebkitInitialLetter:
4335         return consumeInitialLetter(m_range);
4336     case CSSPropertySpeakAs:
4337         return consumeSpeakAs(m_range);
4338     case CSSPropertyHangingPunctuation:
4339         return consumeHangingPunctuation(m_range);
4340     case CSSPropertyWebkitMarqueeIncrement:
4341         return consumeWebkitMarqueeIncrement(m_range, m_context.mode);
4342     case CSSPropertyWebkitMarqueeRepetition:
4343         return consumeWebkitMarqueeRepetition(m_range);
4344     case CSSPropertyWebkitMarqueeSpeed:
4345         return consumeWebkitMarqueeSpeed(m_range, m_context.mode);
4346     case CSSPropertyAlt:
4347         return consumeAlt(m_range, m_context);
4348     case CSSPropertyWebkitAspectRatio:
4349         return consumeWebkitAspectRatio(m_range);
4350     case CSSPropertyWebkitTextEmphasisPosition:
4351         return consumeTextEmphasisPosition(m_range);
4352 #if ENABLE(DARK_MODE_CSS)
4353     case CSSPropertySupportedColorSchemes:
4354         if (!RuntimeEnabledFeatures::sharedFeatures().darkModeCSSEnabled())
4355             return nullptr;
4356         return consumeSupportedColorSchemes(m_range);
4357 #endif
4358 #if ENABLE(DASHBOARD_SUPPORT)
4359     case CSSPropertyWebkitDashboardRegion:
4360         return consumeWebkitDashboardRegion(m_range, m_context.mode);
4361 #endif
4362     default:
4363         return nullptr;
4364     }
4365 }
4366 
4367 bool CSSPropertyParser::canParseTypedCustomPropertyValue(const String&amp; syntax)
4368 {
4369     if (syntax != &quot;*&quot;) {
4370         m_range.consumeWhitespace();
4371 
4372         // First check for keywords
4373         CSSValueID id = m_range.peek().id();
4374         if (id == CSSValueInherit || id == CSSValueInitial || id == CSSValueRevert)
4375             return true;
4376 
4377         auto localRange = m_range;
4378         while (!localRange.atEnd()) {
4379             auto id = localRange.consume().functionId();
4380             if (id == CSSValueVar || id == CSSValueEnv)
4381                 return true; // For variables, we just permit everything
4382         }
4383 
4384         auto primitiveVal = consumeWidthOrHeight(m_range, m_context);
4385         if (primitiveVal &amp;&amp; primitiveVal-&gt;isPrimitiveValue() &amp;&amp; m_range.atEnd())
4386             return true;
4387         return false;
4388     }
4389 
4390     return true;
4391 }
4392 
4393 void CSSPropertyParser::collectParsedCustomPropertyValueDependencies(const String&amp; syntax, bool isRoot, HashSet&lt;CSSPropertyID&gt;&amp; dependencies)
4394 {
4395     if (syntax != &quot;*&quot;) {
4396         m_range.consumeWhitespace();
4397         auto primitiveVal = consumeWidthOrHeight(m_range, m_context);
4398         if (!m_range.atEnd())
4399             return;
4400         if (primitiveVal &amp;&amp; primitiveVal-&gt;isPrimitiveValue()) {
4401             primitiveVal-&gt;collectDirectComputationalDependencies(dependencies);
4402             if (isRoot)
4403                 primitiveVal-&gt;collectDirectRootComputationalDependencies(dependencies);
4404         }
4405     }
4406 }
4407 
4408 RefPtr&lt;CSSCustomPropertyValue&gt; CSSPropertyParser::parseTypedCustomPropertyValue(const String&amp; name, const String&amp; syntax, const StyleResolver&amp; styleResolver)
4409 {
4410     if (syntax != &quot;*&quot;) {
4411         m_range.consumeWhitespace();
4412         auto primitiveVal = consumeWidthOrHeight(m_range, m_context);
4413         if (primitiveVal &amp;&amp; primitiveVal-&gt;isPrimitiveValue() &amp;&amp; downcast&lt;CSSPrimitiveValue&gt;(*primitiveVal).isLength()) {
4414             auto length = StyleBuilderConverter::convertLength(styleResolver, *primitiveVal);
4415             if (!length.isCalculated() &amp;&amp; !length.isUndefined())
4416                 return CSSCustomPropertyValue::createSyntaxLength(name, WTFMove(length));
4417         }
4418     } else {
4419         auto propertyValue = CSSCustomPropertyValue::createSyntaxAll(name, CSSVariableData::create(m_range));
4420         while (!m_range.atEnd())
4421             m_range.consume();
4422         return { WTFMove(propertyValue) };
4423     }
4424 
4425     return nullptr;
4426 }
4427 
4428 static RefPtr&lt;CSSValueList&gt; consumeFontFaceUnicodeRange(CSSParserTokenRange&amp; range)
4429 {
4430     RefPtr&lt;CSSValueList&gt; values = CSSValueList::createCommaSeparated();
4431 
4432     do {
4433         const CSSParserToken&amp; token = range.consumeIncludingWhitespace();
4434         if (token.type() != UnicodeRangeToken)
4435             return nullptr;
4436 
4437         UChar32 start = token.unicodeRangeStart();
4438         UChar32 end = token.unicodeRangeEnd();
4439         if (start &gt; end)
4440             return nullptr;
4441         values-&gt;append(CSSUnicodeRangeValue::create(start, end));
4442     } while (consumeCommaIncludingWhitespace(range));
4443 
4444     return values;
4445 }
4446 
4447 static RefPtr&lt;CSSPrimitiveValue&gt; consumeFontFaceFontDisplay(CSSParserTokenRange&amp; range)
4448 {
4449     return consumeIdent&lt;CSSValueAuto, CSSValueBlock, CSSValueSwap, CSSValueFallback, CSSValueOptional&gt;(range);
4450 }
4451 
4452 static RefPtr&lt;CSSValue&gt; consumeFontFaceSrcURI(CSSParserTokenRange&amp; range, const CSSParserContext&amp; context)
4453 {
4454     String url = consumeUrlAsStringView(range).toString();
4455     if (url.isNull())
4456         return nullptr;
4457 
4458     RefPtr&lt;CSSFontFaceSrcValue&gt; uriValue = CSSFontFaceSrcValue::create(context.completeURL(url), context.isContentOpaque ? LoadedFromOpaqueSource::Yes : LoadedFromOpaqueSource::No);
4459 
4460     if (range.peek().functionId() != CSSValueFormat)
4461         return uriValue;
4462 
4463     // FIXME: https://drafts.csswg.org/css-fonts says that format() contains a comma-separated list of strings,
4464     // but CSSFontFaceSrcValue stores only one format. Allowing one format for now.
4465     // FIXME: We&#39;re allowing the format to be an identifier as well as a string, because the old
4466     // parser did. It&#39;s not clear if we need to continue to support this behavior, but we have lots of
4467     // layout tests that rely on it.
4468     CSSParserTokenRange args = consumeFunction(range);
4469     const CSSParserToken&amp; arg = args.consumeIncludingWhitespace();
4470     if ((arg.type() != StringToken &amp;&amp; arg.type() != IdentToken) || !args.atEnd())
4471         return nullptr;
4472     uriValue-&gt;setFormat(arg.value().toString());
4473     return uriValue;
4474 }
4475 
4476 static RefPtr&lt;CSSValue&gt; consumeFontFaceSrcLocal(CSSParserTokenRange&amp; range)
4477 {
4478     CSSParserTokenRange args = consumeFunction(range);
4479     if (args.peek().type() == StringToken) {
4480         const CSSParserToken&amp; arg = args.consumeIncludingWhitespace();
4481         if (!args.atEnd())
4482             return nullptr;
4483         return CSSFontFaceSrcValue::createLocal(arg.value().toString());
4484     }
4485     if (args.peek().type() == IdentToken) {
4486         String familyName = concatenateFamilyName(args);
4487         if (!args.atEnd())
4488             return nullptr;
4489         return CSSFontFaceSrcValue::createLocal(familyName);
4490     }
4491     return nullptr;
4492 }
4493 
4494 static RefPtr&lt;CSSValueList&gt; consumeFontFaceSrc(CSSParserTokenRange&amp; range, const CSSParserContext&amp; context)
4495 {
4496     RefPtr&lt;CSSValueList&gt; values = CSSValueList::createCommaSeparated();
4497 
4498     do {
4499         const CSSParserToken&amp; token = range.peek();
4500         RefPtr&lt;CSSValue&gt; parsedValue;
4501         if (token.functionId() == CSSValueLocal)
4502             parsedValue = consumeFontFaceSrcLocal(range);
4503         else
4504             parsedValue = consumeFontFaceSrcURI(range, context);
4505         if (!parsedValue)
4506             return nullptr;
4507         values-&gt;append(parsedValue.releaseNonNull());
4508     } while (consumeCommaIncludingWhitespace(range));
4509     return values;
4510 }
4511 
4512 bool CSSPropertyParser::parseFontFaceDescriptor(CSSPropertyID propId)
4513 {
4514     RefPtr&lt;CSSValue&gt; parsedValue;
4515     switch (propId) {
4516     case CSSPropertyFontFamily:
4517         parsedValue = consumeFontFamilyDescriptor(m_range);
4518         break;
4519     case CSSPropertySrc: // This is a list of urls or local references.
4520         parsedValue = consumeFontFaceSrc(m_range, m_context);
4521         break;
4522     case CSSPropertyUnicodeRange:
4523         parsedValue = consumeFontFaceUnicodeRange(m_range);
4524         break;
4525     case CSSPropertyFontDisplay:
4526         parsedValue = consumeFontFaceFontDisplay(m_range);
4527         break;
4528     case CSSPropertyFontWeight:
4529 #if ENABLE(VARIATION_FONTS)
4530         parsedValue = consumeFontWeightRange(m_range);
4531 #else
4532         parsedValue = consumeFontWeight(m_range);
4533 #endif
4534         break;
4535     case CSSPropertyFontStretch:
4536 #if ENABLE(VARIATION_FONTS)
4537         parsedValue = consumeFontStretchRange(m_range);
4538 #else
4539         parsedValue = consumeFontStretch(m_range);
4540 #endif
4541         break;
4542     case CSSPropertyFontStyle:
4543 #if ENABLE(VARIATION_FONTS)
4544         parsedValue = consumeFontStyleRange(m_range, m_context.mode);
4545 #else
4546         parsedValue = consumeFontStyle(m_range, m_context.mode);
4547 #endif
4548         break;
4549     case CSSPropertyFontVariantCaps:
4550         parsedValue = consumeFontVariantCaps(m_range);
4551         break;
4552     case CSSPropertyFontVariantLigatures:
4553         parsedValue = consumeFontVariantLigatures(m_range);
4554         break;
4555     case CSSPropertyFontVariantNumeric:
4556         parsedValue = consumeFontVariantNumeric(m_range);
4557         break;
4558     case CSSPropertyFontVariantEastAsian:
4559         parsedValue = consumeFontVariantEastAsian(m_range);
4560         break;
4561     case CSSPropertyFontVariantAlternates:
4562         parsedValue = consumeFontVariantAlternates(m_range);
4563         break;
4564     case CSSPropertyFontVariantPosition:
4565         parsedValue = consumeFontVariantPosition(m_range);
4566         break;
4567     case CSSPropertyFontVariant:
4568         return consumeFontVariantShorthand(false);
4569     case CSSPropertyFontFeatureSettings:
4570         parsedValue = consumeFontFeatureSettings(m_range);
4571         break;
4572     default:
4573         break;
4574     }
4575 
4576     if (!parsedValue || !m_range.atEnd())
4577         return false;
4578 
4579     addProperty(propId, CSSPropertyInvalid, *parsedValue, false);
4580     return true;
4581 }
4582 
4583 bool CSSPropertyParser::consumeSystemFont(bool important)
4584 {
4585     CSSValueID systemFontID = m_range.consumeIncludingWhitespace().id();
4586     ASSERT(systemFontID &gt;= CSSValueCaption &amp;&amp; systemFontID &lt;= CSSValueStatusBar);
4587     if (!m_range.atEnd())
4588         return false;
4589 
4590     FontCascadeDescription fontDescription;
4591     RenderTheme::singleton().systemFont(systemFontID, fontDescription);
4592     if (!fontDescription.isAbsoluteSize())
4593         return false;
4594 
4595     addProperty(CSSPropertyFontStyle, CSSPropertyFont, CSSFontStyleValue::create(CSSValuePool::singleton().createIdentifierValue(isItalic(fontDescription.italic()) ? CSSValueItalic : CSSValueNormal)), important);
4596     addProperty(CSSPropertyFontWeight, CSSPropertyFont, CSSValuePool::singleton().createValue(static_cast&lt;float&gt;(fontDescription.weight())), important);
4597     addProperty(CSSPropertyFontSize, CSSPropertyFont, CSSValuePool::singleton().createValue(fontDescription.specifiedSize(), CSSPrimitiveValue::CSS_PX), important);
4598     Ref&lt;CSSValueList&gt; fontFamilyList = CSSValueList::createCommaSeparated();
4599     fontFamilyList-&gt;append(CSSValuePool::singleton().createFontFamilyValue(fontDescription.familyAt(0), FromSystemFontID::Yes));
4600     addProperty(CSSPropertyFontFamily, CSSPropertyFont, WTFMove(fontFamilyList), important);
4601     addProperty(CSSPropertyFontVariantCaps, CSSPropertyFont, CSSValuePool::singleton().createIdentifierValue(CSSValueNormal), important);
4602     addProperty(CSSPropertyLineHeight, CSSPropertyFont, CSSValuePool::singleton().createIdentifierValue(CSSValueNormal), important);
4603 
4604     // FIXME_NEWPARSER: What about FontVariantNumeric and FontVariantLigatures?
4605 
4606     return true;
4607 }
4608 
4609 bool CSSPropertyParser::consumeFont(bool important)
4610 {
4611     // Let&#39;s check if there is an inherit or initial somewhere in the shorthand.
4612     CSSParserTokenRange range = m_range;
4613     while (!range.atEnd()) {
4614         CSSValueID id = range.consumeIncludingWhitespace().id();
4615         if (id == CSSValueInherit || id == CSSValueInitial)
4616             return false;
4617     }
4618     // Optional font-style, font-variant, font-stretch and font-weight.
4619     RefPtr&lt;CSSFontStyleValue&gt; fontStyle;
4620     RefPtr&lt;CSSPrimitiveValue&gt; fontVariantCaps;
4621     RefPtr&lt;CSSPrimitiveValue&gt; fontWeight;
4622     RefPtr&lt;CSSPrimitiveValue&gt; fontStretch;
4623 
4624     while (!m_range.atEnd()) {
4625         CSSValueID id = m_range.peek().id();
4626         if (!fontStyle) {
4627             fontStyle = consumeFontStyle(m_range, m_context.mode);
4628             if (fontStyle)
4629                 continue;
4630         }
4631         if (!fontVariantCaps &amp;&amp; (id == CSSValueNormal || id == CSSValueSmallCaps)) {
4632             // Font variant in the shorthand is particular, it only accepts normal or small-caps.
4633             // See https://drafts.csswg.org/css-fonts/#propdef-font
4634             fontVariantCaps = consumeFontVariantCSS21(m_range);
4635             if (fontVariantCaps)
4636                 continue;
4637         }
4638         if (!fontWeight) {
4639             fontWeight = consumeFontWeight(m_range);
4640             if (fontWeight)
4641                 continue;
4642         }
4643         if (!fontStretch) {
4644             fontStretch = consumeFontStretchKeywordValue(m_range);
4645             if (fontStretch)
4646                 continue;
4647         }
4648         break;
4649     }
4650 
4651     if (m_range.atEnd())
4652         return false;
4653 
4654     bool hasStyle = fontStyle;
4655     bool hasVariant = fontVariantCaps;
4656     bool hasWeight = fontWeight;
4657     bool hasStretch = fontStretch;
4658 
4659     if (!fontStyle)
4660         fontStyle = CSSFontStyleValue::create(CSSValuePool::singleton().createIdentifierValue(CSSValueNormal));
4661 
4662     addProperty(CSSPropertyFontStyle, CSSPropertyFont, fontStyle.releaseNonNull(), important, !hasStyle);
4663     addProperty(CSSPropertyFontVariantCaps, CSSPropertyFont, fontVariantCaps ? fontVariantCaps.releaseNonNull() : CSSValuePool::singleton().createIdentifierValue(CSSValueNormal), important, !hasVariant);
4664 /*
4665     // FIXME-NEWPARSER: What do we do with these? They aren&#39;t part of our fontShorthand().
4666     addProperty(CSSPropertyFontVariantLigatures, CSSPropertyFont, CSSValuePool::singleton().createIdentifierValue(CSSValueNormal), important, true);
4667     addProperty(CSSPropertyFontVariantNumeric, CSSPropertyFont, CSSValuePool::singleton().createIdentifierValue(CSSValueNormal), important, true);
4668 */
4669 
4670     addProperty(CSSPropertyFontWeight, CSSPropertyFont, fontWeight ? fontWeight.releaseNonNull() : CSSValuePool::singleton().createIdentifierValue(CSSValueNormal), important, !hasWeight);
4671     addProperty(CSSPropertyFontStretch, CSSPropertyFont, fontStretch ? fontStretch.releaseNonNull() : CSSValuePool::singleton().createIdentifierValue(CSSValueNormal), important, !hasStretch);
4672 
4673     // Now a font size _must_ come.
4674     RefPtr&lt;CSSValue&gt; fontSize = consumeFontSize(m_range, m_context.mode);
4675     if (!fontSize || m_range.atEnd())
4676         return false;
4677 
4678     addProperty(CSSPropertyFontSize, CSSPropertyFont, *fontSize, important);
4679 
4680     if (consumeSlashIncludingWhitespace(m_range)) {
4681         RefPtr&lt;CSSPrimitiveValue&gt; lineHeight = consumeLineHeight(m_range, m_context.mode);
4682         if (!lineHeight)
4683             return false;
4684         addProperty(CSSPropertyLineHeight, CSSPropertyFont, lineHeight.releaseNonNull(), important);
4685     } else
4686         addProperty(CSSPropertyLineHeight, CSSPropertyFont, CSSValuePool::singleton().createIdentifierValue(CSSValueNormal), important, true);
4687 
4688     // Font family must come now.
4689     RefPtr&lt;CSSValue&gt; parsedFamilyValue = consumeFontFamily(m_range);
4690     if (!parsedFamilyValue)
4691         return false;
4692 
4693     addProperty(CSSPropertyFontFamily, CSSPropertyFont, parsedFamilyValue.releaseNonNull(), important);
4694 
4695     return m_range.atEnd();
4696 }
4697 
4698 bool CSSPropertyParser::consumeFontVariantShorthand(bool important)
4699 {
4700     if (identMatches&lt;CSSValueNormal, CSSValueNone&gt;(m_range.peek().id())) {
4701         addProperty(CSSPropertyFontVariantLigatures, CSSPropertyFontVariant, consumeIdent(m_range).releaseNonNull(), important);
4702         addProperty(CSSPropertyFontVariantCaps, CSSPropertyFontVariant, CSSValuePool::singleton().createIdentifierValue(CSSValueNormal), important);
4703         addProperty(CSSPropertyFontVariantEastAsian, CSSPropertyFontVariant, CSSValuePool::singleton().createIdentifierValue(CSSValueNormal), important);
4704         addProperty(CSSPropertyFontVariantPosition, CSSPropertyFontVariant, CSSValuePool::singleton().createIdentifierValue(CSSValueNormal), important);
4705         return m_range.atEnd();
4706     }
4707 
4708     RefPtr&lt;CSSPrimitiveValue&gt; capsValue;
4709     RefPtr&lt;CSSPrimitiveValue&gt; alternatesValue;
4710     RefPtr&lt;CSSPrimitiveValue&gt; positionValue;
4711 
4712     RefPtr&lt;CSSValue&gt; eastAsianValue;
4713     FontVariantLigaturesParser ligaturesParser;
4714     FontVariantNumericParser numericParser;
4715     do {
4716         if (!capsValue) {
4717             capsValue = consumeFontVariantCaps(m_range);
4718             if (capsValue)
4719                 continue;
4720         }
4721 
4722         if (!positionValue) {
4723             positionValue = consumeFontVariantPosition(m_range);
4724             if (positionValue)
4725                 continue;
4726         }
4727 
4728         if (!alternatesValue) {
4729             alternatesValue = consumeFontVariantAlternates(m_range);
4730             if (alternatesValue)
4731                 continue;
4732         }
4733 
4734         FontVariantLigaturesParser::ParseResult ligaturesParseResult = ligaturesParser.consumeLigature(m_range);
4735         FontVariantNumericParser::ParseResult numericParseResult = numericParser.consumeNumeric(m_range);
4736         if (ligaturesParseResult == FontVariantLigaturesParser::ParseResult::ConsumedValue
4737             || numericParseResult == FontVariantNumericParser::ParseResult::ConsumedValue)
4738             continue;
4739 
4740         if (ligaturesParseResult == FontVariantLigaturesParser::ParseResult::DisallowedValue
4741             || numericParseResult == FontVariantNumericParser::ParseResult::DisallowedValue)
4742             return false;
4743 
4744         if (!eastAsianValue) {
4745             eastAsianValue = consumeFontVariantEastAsian(m_range);
4746             if (eastAsianValue)
4747             continue;
4748         }
4749 
4750         // Saw some value that didn&#39;t match anything else.
4751         return false;
4752 
4753     } while (!m_range.atEnd());
4754 
4755     addProperty(CSSPropertyFontVariantLigatures, CSSPropertyFontVariant, ligaturesParser.finalizeValue().releaseNonNull(), important);
4756     addProperty(CSSPropertyFontVariantNumeric, CSSPropertyFontVariant, numericParser.finalizeValue().releaseNonNull(), important);
4757     addProperty(CSSPropertyFontVariantCaps, CSSPropertyFontVariant, capsValue ? capsValue.releaseNonNull() : CSSValuePool::singleton().createIdentifierValue(CSSValueNormal), important);
4758     addProperty(CSSPropertyFontVariantAlternates, CSSPropertyFontVariant, alternatesValue ? alternatesValue.releaseNonNull() : CSSValuePool::singleton().createIdentifierValue(CSSValueNormal), important);
4759     addProperty(CSSPropertyFontVariantPosition, CSSPropertyFontVariant, positionValue ? positionValue.releaseNonNull() : CSSValuePool::singleton().createIdentifierValue(CSSValueNormal), important);
4760 
4761     if (!eastAsianValue)
4762         eastAsianValue = CSSValuePool::singleton().createIdentifierValue(CSSValueNormal);
4763     addProperty(CSSPropertyFontVariantEastAsian, CSSPropertyFontVariant, eastAsianValue.releaseNonNull(), important);
4764 
4765     return true;
4766 }
4767 
4768 bool CSSPropertyParser::consumeBorderSpacing(bool important)
4769 {
4770     RefPtr&lt;CSSValue&gt; horizontalSpacing = consumeLength(m_range, m_context.mode, ValueRangeNonNegative, UnitlessQuirk::Allow);
4771     if (!horizontalSpacing)
4772         return false;
4773     RefPtr&lt;CSSValue&gt; verticalSpacing = horizontalSpacing;
4774     if (!m_range.atEnd())
4775         verticalSpacing = consumeLength(m_range, m_context.mode, ValueRangeNonNegative, UnitlessQuirk::Allow);
4776     if (!verticalSpacing || !m_range.atEnd())
4777         return false;
4778     addProperty(CSSPropertyWebkitBorderHorizontalSpacing, CSSPropertyBorderSpacing, horizontalSpacing.releaseNonNull(), important);
4779     addProperty(CSSPropertyWebkitBorderVerticalSpacing, CSSPropertyBorderSpacing, verticalSpacing.releaseNonNull(), important);
4780     return true;
4781 }
4782 
4783 #if ENABLE(CSS_DEVICE_ADAPTATION)
4784 
4785 static RefPtr&lt;CSSValue&gt; consumeSingleViewportDescriptor(CSSParserTokenRange&amp; range, CSSPropertyID propId, CSSParserMode cssParserMode)
4786 {
4787     CSSValueID id = range.peek().id();
4788     switch (propId) {
4789     case CSSPropertyMinWidth:
4790     case CSSPropertyMaxWidth:
4791     case CSSPropertyMinHeight:
4792     case CSSPropertyMaxHeight:
4793         if (id == CSSValueAuto)
4794             return consumeIdent(range);
4795         return consumeLengthOrPercent(range, cssParserMode, ValueRangeNonNegative);
4796     case CSSPropertyMinZoom:
4797     case CSSPropertyMaxZoom:
4798     case CSSPropertyZoom: {
4799         if (id == CSSValueAuto)
4800             return consumeIdent(range);
4801         RefPtr&lt;CSSValue&gt; parsedValue = consumeNumber(range, ValueRangeNonNegative);
4802         if (parsedValue)
4803             return parsedValue;
4804         return consumePercent(range, ValueRangeNonNegative);
4805     }
4806     case CSSPropertyUserZoom:
4807         return consumeIdent&lt;CSSValueZoom, CSSValueFixed&gt;(range);
4808     case CSSPropertyOrientation:
4809         return consumeIdent&lt;CSSValueAuto, CSSValuePortrait, CSSValueLandscape&gt;(range);
4810     default:
4811         ASSERT_NOT_REACHED();
4812         break;
4813     }
4814 
4815     ASSERT_NOT_REACHED();
4816     return nullptr;
4817 }
4818 
4819 bool CSSPropertyParser::parseViewportDescriptor(CSSPropertyID propId, bool important)
4820 {
4821     switch (propId) {
4822     case CSSPropertyWidth: {
4823         RefPtr&lt;CSSValue&gt; minWidth = consumeSingleViewportDescriptor(m_range, CSSPropertyMinWidth, m_context.mode);
4824         if (!minWidth)
4825             return false;
4826         RefPtr&lt;CSSValue&gt; maxWidth = minWidth;
4827         if (!m_range.atEnd())
4828             maxWidth = consumeSingleViewportDescriptor(m_range, CSSPropertyMaxWidth, m_context.mode);
4829         if (!maxWidth || !m_range.atEnd())
4830             return false;
4831         addProperty(CSSPropertyMinWidth, CSSPropertyInvalid, *minWidth, important);
4832         addProperty(CSSPropertyMaxWidth, CSSPropertyInvalid, *maxWidth, important);
4833         return true;
4834     }
4835     case CSSPropertyHeight: {
4836         RefPtr&lt;CSSValue&gt; minHeight = consumeSingleViewportDescriptor(m_range, CSSPropertyMinHeight, m_context.mode);
4837         if (!minHeight)
4838             return false;
4839         RefPtr&lt;CSSValue&gt; maxHeight = minHeight;
4840         if (!m_range.atEnd())
4841             maxHeight = consumeSingleViewportDescriptor(m_range, CSSPropertyMaxHeight, m_context.mode);
4842         if (!maxHeight || !m_range.atEnd())
4843             return false;
4844         addProperty(CSSPropertyMinHeight, CSSPropertyInvalid, *minHeight, important);
4845         addProperty(CSSPropertyMaxHeight, CSSPropertyInvalid, *maxHeight, important);
4846         return true;
4847     }
4848     case CSSPropertyMinWidth:
4849     case CSSPropertyMaxWidth:
4850     case CSSPropertyMinHeight:
4851     case CSSPropertyMaxHeight:
4852     case CSSPropertyMinZoom:
4853     case CSSPropertyMaxZoom:
4854     case CSSPropertyZoom:
4855     case CSSPropertyUserZoom:
4856     case CSSPropertyOrientation: {
4857         RefPtr&lt;CSSValue&gt; parsedValue = consumeSingleViewportDescriptor(m_range, propId, m_context.mode);
4858         if (!parsedValue || !m_range.atEnd())
4859             return false;
4860         addProperty(propId, CSSPropertyInvalid, parsedValue.releaseNonNull(), important);
4861         return true;
4862     }
4863     default:
4864         return false;
4865     }
4866 }
4867 
4868 #endif
4869 
4870 bool CSSPropertyParser::consumeColumns(bool important)
4871 {
4872     RefPtr&lt;CSSValue&gt; columnWidth;
4873     RefPtr&lt;CSSValue&gt; columnCount;
4874     bool hasPendingExplicitAuto = false;
4875 
4876     for (unsigned propertiesParsed = 0; propertiesParsed &lt; 2 &amp;&amp; !m_range.atEnd(); ++propertiesParsed) {
4877         if (!propertiesParsed &amp;&amp; m_range.peek().id() == CSSValueAuto) {
4878             // &#39;auto&#39; is a valid value for any of the two longhands, and at this point
4879             // we don&#39;t know which one(s) it is meant for. We need to see if there are other values first.
4880             consumeIdent(m_range);
4881             hasPendingExplicitAuto = true;
4882         } else {
4883             if (!columnWidth) {
4884                 if ((columnWidth = consumeColumnWidth(m_range)))
4885                     continue;
4886             }
4887             if (!columnCount) {
4888                 if ((columnCount = consumeColumnCount(m_range)))
4889                     continue;
4890             }
4891             // If we didn&#39;t find at least one match, this is an invalid shorthand and we have to ignore it.
4892             return false;
4893         }
4894     }
4895 
4896     if (!m_range.atEnd())
4897         return false;
4898 
4899     // Any unassigned property at this point will become implicit &#39;auto&#39;.
4900     if (columnWidth)
4901         addProperty(CSSPropertyColumnWidth, CSSPropertyInvalid, columnWidth.releaseNonNull(), important);
4902     else {
4903         addProperty(CSSPropertyColumnWidth, CSSPropertyInvalid, CSSValuePool::singleton().createIdentifierValue(CSSValueAuto), important, !hasPendingExplicitAuto /* implicit */);
4904         hasPendingExplicitAuto = false;
4905     }
4906 
4907     if (columnCount)
4908         addProperty(CSSPropertyColumnCount, CSSPropertyInvalid, columnCount.releaseNonNull(), important);
4909     else
4910         addProperty(CSSPropertyColumnCount, CSSPropertyInvalid, CSSValuePool::singleton().createIdentifierValue(CSSValueAuto), important, !hasPendingExplicitAuto /* implicit */);
4911 
4912     return true;
4913 }
4914 
4915 bool CSSPropertyParser::consumeShorthandGreedily(const StylePropertyShorthand&amp; shorthand, bool important)
4916 {
4917     ASSERT(shorthand.length() &lt;= 6); // Existing shorthands have at most 6 longhands.
4918     RefPtr&lt;CSSValue&gt; longhands[6];
4919     const CSSPropertyID* shorthandProperties = shorthand.properties();
4920     do {
4921         bool foundLonghand = false;
4922         for (size_t i = 0; !foundLonghand &amp;&amp; i &lt; shorthand.length(); ++i) {
4923             if (longhands[i])
4924                 continue;
4925             longhands[i] = parseSingleValue(shorthandProperties[i], shorthand.id());
4926             if (longhands[i])
4927                 foundLonghand = true;
4928         }
4929         if (!foundLonghand)
4930             return false;
4931     } while (!m_range.atEnd());
4932 
4933     for (size_t i = 0; i &lt; shorthand.length(); ++i) {
4934         if (longhands[i])
4935             addProperty(shorthandProperties[i], shorthand.id(), longhands[i].releaseNonNull(), important);
4936         else
4937             addProperty(shorthandProperties[i], shorthand.id(), CSSValuePool::singleton().createImplicitInitialValue(), important);
4938     }
4939     return true;
4940 }
4941 
4942 bool CSSPropertyParser::consumeFlex(bool important)
4943 {
4944     static const double unsetValue = -1;
4945     double flexGrow = unsetValue;
4946     double flexShrink = unsetValue;
4947     RefPtr&lt;CSSPrimitiveValue&gt; flexBasis;
4948 
4949     if (m_range.peek().id() == CSSValueNone) {
4950         flexGrow = 0;
4951         flexShrink = 0;
4952         flexBasis = CSSValuePool::singleton().createIdentifierValue(CSSValueAuto);
4953         m_range.consumeIncludingWhitespace();
4954     } else {
4955         unsigned index = 0;
4956         while (!m_range.atEnd() &amp;&amp; index++ &lt; 3) {
4957             double num;
4958             if (consumeNumberRaw(m_range, num)) {
4959                 if (num &lt; 0)
4960                     return false;
4961                 if (flexGrow == unsetValue)
4962                     flexGrow = num;
4963                 else if (flexShrink == unsetValue)
4964                     flexShrink = num;
4965                 else if (!num) // flex only allows a basis of 0 (sans units) if flex-grow and flex-shrink values have already been set.
4966                     flexBasis = CSSPrimitiveValue::create(0, CSSPrimitiveValue::UnitType::CSS_PX);
4967                 else
4968                     return false;
4969             } else if (!flexBasis) {
4970                 if (m_range.peek().id() == CSSValueAuto)
4971                     flexBasis = consumeIdent(m_range);
4972                 if (!flexBasis)
4973                     flexBasis = consumeLengthOrPercent(m_range, m_context.mode, ValueRangeNonNegative);
4974                 if (index == 2 &amp;&amp; !m_range.atEnd())
4975                     return false;
4976             }
4977         }
4978         if (index == 0)
4979             return false;
4980         if (flexGrow == unsetValue)
4981             flexGrow = 1;
4982         if (flexShrink == unsetValue)
4983             flexShrink = 1;
4984 
4985         // FIXME: Using % here is a hack to work around intrinsic sizing implementation being
4986         // a mess (e.g., turned off for nested column flexboxes, failing to relayout properly even
4987         // if turned back on for nested columns, etc.). We have layout test coverage of both
4988         // scenarios.
4989         if (!flexBasis)
4990             flexBasis = CSSPrimitiveValue::create(0, CSSPrimitiveValue::UnitType::CSS_PERCENTAGE);
4991     }
4992 
4993     if (!m_range.atEnd())
4994         return false;
4995     addProperty(CSSPropertyFlexGrow, CSSPropertyFlex, CSSPrimitiveValue::create(clampTo&lt;float&gt;(flexGrow), CSSPrimitiveValue::UnitType::CSS_NUMBER), important);
4996     addProperty(CSSPropertyFlexShrink, CSSPropertyFlex, CSSPrimitiveValue::create(clampTo&lt;float&gt;(flexShrink), CSSPrimitiveValue::UnitType::CSS_NUMBER), important);
4997     addProperty(CSSPropertyFlexBasis, CSSPropertyFlex, flexBasis.releaseNonNull(), important);
4998     return true;
4999 }
5000 
5001 bool CSSPropertyParser::consumeBorder(RefPtr&lt;CSSValue&gt;&amp; width, RefPtr&lt;CSSValue&gt;&amp; style, RefPtr&lt;CSSValue&gt;&amp; color)
5002 {
5003     while (!width || !style || !color) {
5004         if (!width) {
5005             width = consumeLineWidth(m_range, m_context.mode, UnitlessQuirk::Forbid);
5006             if (width)
5007                 continue;
5008         }
5009         if (!style) {
5010             style = parseSingleValue(CSSPropertyBorderLeftStyle, CSSPropertyBorder);
5011             if (style)
5012                 continue;
5013         }
5014         if (!color) {
5015             color = consumeColor(m_range, m_context.mode);
5016             if (color)
5017                 continue;
5018         }
5019         break;
5020     }
5021 
5022     if (!width &amp;&amp; !style &amp;&amp; !color)
5023         return false;
5024 
5025     if (!width)
5026         width = CSSValuePool::singleton().createImplicitInitialValue();
5027     if (!style)
5028         style = CSSValuePool::singleton().createImplicitInitialValue();
5029     if (!color)
5030         color = CSSValuePool::singleton().createImplicitInitialValue();
5031 
5032     return m_range.atEnd();
5033 }
5034 
5035 bool CSSPropertyParser::consume2ValueShorthand(const StylePropertyShorthand&amp; shorthand, bool important)
5036 {
5037     ASSERT(shorthand.length() == 2);
5038     const CSSPropertyID* longhands = shorthand.properties();
5039     RefPtr&lt;CSSValue&gt; start = parseSingleValue(longhands[0], shorthand.id());
5040     if (!start)
5041         return false;
5042 
5043     RefPtr&lt;CSSValue&gt; end = parseSingleValue(longhands[1], shorthand.id());
5044     bool endImplicit = !end;
5045     if (endImplicit)
5046         end = start;
5047     addProperty(longhands[0], shorthand.id(), start.releaseNonNull(), important);
5048     addProperty(longhands[1], shorthand.id(), end.releaseNonNull(), important, endImplicit);
5049 
5050     return m_range.atEnd();
5051 }
5052 
5053 bool CSSPropertyParser::consume4ValueShorthand(const StylePropertyShorthand&amp; shorthand, bool important)
5054 {
5055     ASSERT(shorthand.length() == 4);
5056     const CSSPropertyID* longhands = shorthand.properties();
5057     RefPtr&lt;CSSValue&gt; top = parseSingleValue(longhands[0], shorthand.id());
5058     if (!top)
5059         return false;
5060 
5061     RefPtr&lt;CSSValue&gt; right = parseSingleValue(longhands[1], shorthand.id());
5062     RefPtr&lt;CSSValue&gt; bottom;
5063     RefPtr&lt;CSSValue&gt; left;
5064     if (right) {
5065         bottom = parseSingleValue(longhands[2], shorthand.id());
5066         if (bottom)
5067             left = parseSingleValue(longhands[3], shorthand.id());
5068     }
5069 
5070     bool rightImplicit = !right;
5071     bool bottomImplicit = !bottom;
5072     bool leftImplicit = !left;
5073 
5074     if (!right)
5075         right = top;
5076     if (!bottom)
5077         bottom = top;
5078     if (!left)
5079         left = right;
5080 
5081     addProperty(longhands[0], shorthand.id(), top.releaseNonNull(), important);
5082     addProperty(longhands[1], shorthand.id(), right.releaseNonNull(), important, rightImplicit);
5083     addProperty(longhands[2], shorthand.id(), bottom.releaseNonNull(), important, bottomImplicit);
5084     addProperty(longhands[3], shorthand.id(), left.releaseNonNull(), important, leftImplicit);
5085 
5086     return m_range.atEnd();
5087 }
5088 
5089 bool CSSPropertyParser::consumeBorderImage(CSSPropertyID property, bool important)
5090 {
5091     RefPtr&lt;CSSValue&gt; source;
5092     RefPtr&lt;CSSValue&gt; slice;
5093     RefPtr&lt;CSSValue&gt; width;
5094     RefPtr&lt;CSSValue&gt; outset;
5095     RefPtr&lt;CSSValue&gt; repeat;
5096 
5097     if (consumeBorderImageComponents(property, m_range, m_context, source, slice, width, outset, repeat)) {
5098         if (!source)
5099             source = CSSValuePool::singleton().createImplicitInitialValue();
5100         if (!slice)
5101             slice = CSSValuePool::singleton().createImplicitInitialValue();
5102         if (!width)
5103             width = CSSValuePool::singleton().createImplicitInitialValue();
5104         if (!outset)
5105             outset = CSSValuePool::singleton().createImplicitInitialValue();
5106         if (!repeat)
5107             repeat = CSSValuePool::singleton().createImplicitInitialValue();
5108         switch (property) {
5109         case CSSPropertyWebkitMaskBoxImage:
5110             addProperty(CSSPropertyWebkitMaskBoxImageSource, CSSPropertyWebkitMaskBoxImage, source.releaseNonNull(), important);
5111             addProperty(CSSPropertyWebkitMaskBoxImageSlice, CSSPropertyWebkitMaskBoxImage, slice.releaseNonNull(), important);
5112             addProperty(CSSPropertyWebkitMaskBoxImageWidth, CSSPropertyWebkitMaskBoxImage, width.releaseNonNull(), important);
5113             addProperty(CSSPropertyWebkitMaskBoxImageOutset, CSSPropertyWebkitMaskBoxImage, outset.releaseNonNull(), important);
5114             addProperty(CSSPropertyWebkitMaskBoxImageRepeat, CSSPropertyWebkitMaskBoxImage, repeat.releaseNonNull(), important);
5115             return true;
5116         case CSSPropertyBorderImage:
5117             addProperty(CSSPropertyBorderImageSource, CSSPropertyBorderImage, source.releaseNonNull(), important);
5118             addProperty(CSSPropertyBorderImageSlice, CSSPropertyBorderImage, slice.releaseNonNull(), important);
5119             addProperty(CSSPropertyBorderImageWidth, CSSPropertyBorderImage, width.releaseNonNull() , important);
5120             addProperty(CSSPropertyBorderImageOutset, CSSPropertyBorderImage, outset.releaseNonNull(), important);
5121             addProperty(CSSPropertyBorderImageRepeat, CSSPropertyBorderImage, repeat.releaseNonNull(), important);
5122             return true;
5123         default:
5124             ASSERT_NOT_REACHED();
5125             return false;
5126         }
5127     }
5128     return false;
5129 }
5130 
5131 static inline CSSValueID mapFromPageBreakBetween(CSSValueID value)
5132 {
5133     if (value == CSSValueAlways)
5134         return CSSValuePage;
5135     if (value == CSSValueAuto || value == CSSValueLeft || value == CSSValueRight)
5136         return value;
5137     if (value == CSSValueAvoid)
5138         return CSSValueAvoidPage;
5139     return CSSValueInvalid;
5140 }
5141 
5142 static inline CSSValueID mapFromColumnBreakBetween(CSSValueID value)
5143 {
5144     if (value == CSSValueAlways)
5145         return CSSValueColumn;
5146     if (value == CSSValueAuto)
5147         return value;
5148     if (value == CSSValueAvoid)
5149         return CSSValueAvoidColumn;
5150     return CSSValueInvalid;
5151 }
5152 
5153 static inline CSSValueID mapFromColumnRegionOrPageBreakInside(CSSValueID value)
5154 {
5155     if (value == CSSValueAuto || value == CSSValueAvoid)
5156         return value;
5157     return CSSValueInvalid;
5158 }
5159 
5160 static inline CSSPropertyID mapFromLegacyBreakProperty(CSSPropertyID property)
5161 {
5162     if (property == CSSPropertyPageBreakAfter || property == CSSPropertyWebkitColumnBreakAfter)
5163         return CSSPropertyBreakAfter;
5164     if (property == CSSPropertyPageBreakBefore || property == CSSPropertyWebkitColumnBreakBefore)
5165         return CSSPropertyBreakBefore;
5166     ASSERT(property == CSSPropertyPageBreakInside || property == CSSPropertyWebkitColumnBreakInside);
5167     return CSSPropertyBreakInside;
5168 }
5169 
5170 bool CSSPropertyParser::consumeLegacyBreakProperty(CSSPropertyID property, bool important)
5171 {
5172     // The fragmentation spec says that page-break-(after|before|inside) are to be treated as
5173     // shorthands for their break-(after|before|inside) counterparts. We&#39;ll do the same for the
5174     // non-standard properties -webkit-column-break-(after|before|inside).
5175     RefPtr&lt;CSSPrimitiveValue&gt; keyword = consumeIdent(m_range);
5176     if (!keyword)
5177         return false;
5178     if (!m_range.atEnd())
5179         return false;
5180     CSSValueID value = keyword-&gt;valueID();
5181     switch (property) {
5182     case CSSPropertyPageBreakAfter:
5183     case CSSPropertyPageBreakBefore:
5184         value = mapFromPageBreakBetween(value);
5185         break;
5186     case CSSPropertyWebkitColumnBreakAfter:
5187     case CSSPropertyWebkitColumnBreakBefore:
5188         value = mapFromColumnBreakBetween(value);
5189         break;
5190     case CSSPropertyPageBreakInside:
5191     case CSSPropertyWebkitColumnBreakInside:
5192         value = mapFromColumnRegionOrPageBreakInside(value);
5193         break;
5194     default:
5195         ASSERT_NOT_REACHED();
5196     }
5197     if (value == CSSValueInvalid)
5198         return false;
5199 
5200     CSSPropertyID genericBreakProperty = mapFromLegacyBreakProperty(property);
5201     addProperty(genericBreakProperty, property, CSSValuePool::singleton().createIdentifierValue(value), important);
5202     return true;
5203 }
5204 
5205 static bool consumeBackgroundPosition(CSSParserTokenRange&amp; range, const CSSParserContext&amp; context, UnitlessQuirk unitless, RefPtr&lt;CSSValue&gt;&amp; resultX, RefPtr&lt;CSSValue&gt;&amp; resultY)
5206 {
5207     do {
5208         RefPtr&lt;CSSPrimitiveValue&gt; positionX;
5209         RefPtr&lt;CSSPrimitiveValue&gt; positionY;
5210         if (!consumePosition(range, context.mode, unitless, positionX, positionY))
5211             return false;
5212         addBackgroundValue(resultX, positionX.releaseNonNull());
5213         addBackgroundValue(resultY, positionY.releaseNonNull());
5214     } while (consumeCommaIncludingWhitespace(range));
5215     return true;
5216 }
5217 
5218 static bool consumeRepeatStyleComponent(CSSParserTokenRange&amp; range, RefPtr&lt;CSSPrimitiveValue&gt;&amp; value1, RefPtr&lt;CSSPrimitiveValue&gt;&amp; value2, bool&amp; implicit)
5219 {
5220     if (consumeIdent&lt;CSSValueRepeatX&gt;(range)) {
5221         value1 = CSSValuePool::singleton().createIdentifierValue(CSSValueRepeat);
5222         value2 = CSSValuePool::singleton().createIdentifierValue(CSSValueNoRepeat);
5223         implicit = true;
5224         return true;
5225     }
5226     if (consumeIdent&lt;CSSValueRepeatY&gt;(range)) {
5227         value1 = CSSValuePool::singleton().createIdentifierValue(CSSValueNoRepeat);
5228         value2 = CSSValuePool::singleton().createIdentifierValue(CSSValueRepeat);
5229         implicit = true;
5230         return true;
5231     }
5232     value1 = consumeIdent&lt;CSSValueRepeat, CSSValueNoRepeat, CSSValueRound, CSSValueSpace&gt;(range);
5233     if (!value1)
5234         return false;
5235 
5236     value2 = consumeIdent&lt;CSSValueRepeat, CSSValueNoRepeat, CSSValueRound, CSSValueSpace&gt;(range);
5237     if (!value2) {
5238         value2 = value1;
5239         implicit = true;
5240     }
5241     return true;
5242 }
5243 
5244 static bool consumeRepeatStyle(CSSParserTokenRange&amp; range, RefPtr&lt;CSSValue&gt;&amp; resultX, RefPtr&lt;CSSValue&gt;&amp; resultY, bool&amp; implicit)
5245 {
5246     do {
5247         RefPtr&lt;CSSPrimitiveValue&gt; repeatX;
5248         RefPtr&lt;CSSPrimitiveValue&gt; repeatY;
5249         if (!consumeRepeatStyleComponent(range, repeatX, repeatY, implicit))
5250             return false;
5251         addBackgroundValue(resultX, repeatX.releaseNonNull());
5252         addBackgroundValue(resultY, repeatY.releaseNonNull());
5253     } while (consumeCommaIncludingWhitespace(range));
5254     return true;
5255 }
5256 
5257 // Note: consumeBackgroundShorthand assumes y properties (for example background-position-y) follow
5258 // the x properties in the shorthand array.
5259 bool CSSPropertyParser::consumeBackgroundShorthand(const StylePropertyShorthand&amp; shorthand, bool important)
5260 {
5261     const unsigned longhandCount = shorthand.length();
5262     RefPtr&lt;CSSValue&gt; longhands[10];
5263     ASSERT(longhandCount &lt;= 10);
5264 
5265     bool implicit = false;
5266     do {
5267         bool parsedLonghand[10] = { false };
5268         RefPtr&lt;CSSValue&gt; originValue;
5269         do {
5270             bool foundProperty = false;
5271             for (size_t i = 0; i &lt; longhandCount; ++i) {
5272                 if (parsedLonghand[i])
5273                     continue;
5274 
5275                 RefPtr&lt;CSSValue&gt; value;
5276                 RefPtr&lt;CSSValue&gt; valueY;
5277                 CSSPropertyID property = shorthand.properties()[i];
5278                 if (property == CSSPropertyBackgroundRepeatX || property == CSSPropertyWebkitMaskRepeatX) {
5279                     RefPtr&lt;CSSPrimitiveValue&gt; primitiveValue;
5280                     RefPtr&lt;CSSPrimitiveValue&gt; primitiveValueY;
5281                     consumeRepeatStyleComponent(m_range, primitiveValue, primitiveValueY, implicit);
5282                     value = primitiveValue;
5283                     valueY = primitiveValueY;
5284                 } else if (property == CSSPropertyBackgroundPositionX || property == CSSPropertyWebkitMaskPositionX) {
5285                     CSSParserTokenRange rangeCopy = m_range;
5286                     RefPtr&lt;CSSPrimitiveValue&gt; primitiveValue;
5287                     RefPtr&lt;CSSPrimitiveValue&gt; primitiveValueY;
5288                     if (!consumePosition(rangeCopy, m_context.mode, UnitlessQuirk::Forbid, primitiveValue, primitiveValueY))
5289                         continue;
5290                     value = primitiveValue;
5291                     valueY = primitiveValueY;
5292                     m_range = rangeCopy;
5293                 } else if (property == CSSPropertyBackgroundSize || property == CSSPropertyWebkitMaskSize) {
5294                     if (!consumeSlashIncludingWhitespace(m_range))
5295                         continue;
5296                     value = consumeBackgroundSize(property, m_range, m_context.mode);
5297                     if (!value || !parsedLonghand[i - 1]) // Position must have been parsed in the current layer.
5298                         return false;
5299                 } else if (property == CSSPropertyBackgroundPositionY || property == CSSPropertyBackgroundRepeatY
5300                     || property == CSSPropertyWebkitMaskPositionY || property == CSSPropertyWebkitMaskRepeatY) {
5301                     continue;
5302                 } else {
5303                     value = consumeBackgroundComponent(property, m_range, m_context);
5304                 }
5305                 if (value) {
5306                     if (property == CSSPropertyBackgroundOrigin || property == CSSPropertyWebkitMaskOrigin)
5307                         originValue = value;
5308                     parsedLonghand[i] = true;
5309                     foundProperty = true;
5310                     addBackgroundValue(longhands[i], value.releaseNonNull());
5311                     if (valueY) {
5312                         parsedLonghand[i + 1] = true;
5313                         addBackgroundValue(longhands[i + 1], valueY.releaseNonNull());
5314                     }
5315                 }
5316             }
5317             if (!foundProperty)
5318                 return false;
5319         } while (!m_range.atEnd() &amp;&amp; m_range.peek().type() != CommaToken);
5320 
5321         // FIXME: This will make invalid longhands, see crbug.com/386459
5322         for (size_t i = 0; i &lt; longhandCount; ++i) {
5323             CSSPropertyID property = shorthand.properties()[i];
5324             if (property == CSSPropertyBackgroundColor &amp;&amp; !m_range.atEnd()) {
5325                 if (parsedLonghand[i])
5326                     return false; // Colors are only allowed in the last layer.
5327                 continue;
5328             }
5329             if ((property == CSSPropertyBackgroundClip || property == CSSPropertyWebkitMaskClip) &amp;&amp; !parsedLonghand[i] &amp;&amp; originValue) {
5330                 addBackgroundValue(longhands[i], originValue.releaseNonNull());
5331                 continue;
5332             }
5333             if (!parsedLonghand[i])
5334                 addBackgroundValue(longhands[i], CSSValuePool::singleton().createImplicitInitialValue());
5335         }
5336     } while (consumeCommaIncludingWhitespace(m_range));
5337     if (!m_range.atEnd())
5338         return false;
5339 
5340     for (size_t i = 0; i &lt; longhandCount; ++i) {
5341         CSSPropertyID property = shorthand.properties()[i];
5342         if (property == CSSPropertyBackgroundSize &amp;&amp; longhands[i] &amp;&amp; m_context.useLegacyBackgroundSizeShorthandBehavior)
5343             continue;
5344         addProperty(property, shorthand.id(), *longhands[i], important, implicit);
5345     }
5346     return true;
5347 }
5348 
5349 // FIXME-NEWPARSER: Hack to work around the fact that we aren&#39;t using CSSCustomIdentValue
5350 // for stuff yet. This can be replaced by CSSValue::isCustomIdentValue() once we switch
5351 // to using CSSCustomIdentValue everywhere.
5352 static bool isCustomIdentValue(const CSSValue&amp; value)
5353 {
5354     return is&lt;CSSPrimitiveValue&gt;(value) &amp;&amp; downcast&lt;CSSPrimitiveValue&gt;(value).isString();
5355 }
5356 
5357 bool CSSPropertyParser::consumeGridItemPositionShorthand(CSSPropertyID shorthandId, bool important)
5358 {
5359     const StylePropertyShorthand&amp; shorthand = shorthandForProperty(shorthandId);
5360     ASSERT(shorthand.length() == 2);
5361     RefPtr&lt;CSSValue&gt; startValue = consumeGridLine(m_range);
5362     if (!startValue)
5363         return false;
5364 
5365     RefPtr&lt;CSSValue&gt; endValue;
5366     if (consumeSlashIncludingWhitespace(m_range)) {
5367         endValue = consumeGridLine(m_range);
5368         if (!endValue)
5369             return false;
5370     } else {
5371         endValue = isCustomIdentValue(*startValue) ? startValue : CSSValuePool::singleton().createIdentifierValue(CSSValueAuto);
5372     }
5373     if (!m_range.atEnd())
5374         return false;
5375     addProperty(shorthand.properties()[0], shorthandId, startValue.releaseNonNull(), important);
5376     addProperty(shorthand.properties()[1], shorthandId, endValue.releaseNonNull(), important);
5377     return true;
5378 }
5379 
5380 bool CSSPropertyParser::consumeGridAreaShorthand(bool important)
5381 {
5382     RefPtr&lt;CSSValue&gt; rowStartValue = consumeGridLine(m_range);
5383     if (!rowStartValue)
5384         return false;
5385     RefPtr&lt;CSSValue&gt; columnStartValue;
5386     RefPtr&lt;CSSValue&gt; rowEndValue;
5387     RefPtr&lt;CSSValue&gt; columnEndValue;
5388     if (consumeSlashIncludingWhitespace(m_range)) {
5389         columnStartValue = consumeGridLine(m_range);
5390         if (!columnStartValue)
5391             return false;
5392         if (consumeSlashIncludingWhitespace(m_range)) {
5393             rowEndValue = consumeGridLine(m_range);
5394             if (!rowEndValue)
5395                 return false;
5396             if (consumeSlashIncludingWhitespace(m_range)) {
5397                 columnEndValue = consumeGridLine(m_range);
5398                 if (!columnEndValue)
5399                     return false;
5400             }
5401         }
5402     }
5403     if (!m_range.atEnd())
5404         return false;
5405     if (!columnStartValue)
5406         columnStartValue = isCustomIdentValue(*rowStartValue) ? rowStartValue : CSSValuePool::singleton().createIdentifierValue(CSSValueAuto);
5407     if (!rowEndValue)
5408         rowEndValue = isCustomIdentValue(*rowStartValue) ? rowStartValue : CSSValuePool::singleton().createIdentifierValue(CSSValueAuto);
5409     if (!columnEndValue)
5410         columnEndValue = isCustomIdentValue(*columnStartValue) ? columnStartValue : CSSValuePool::singleton().createIdentifierValue(CSSValueAuto);
5411 
5412     addProperty(CSSPropertyGridRowStart, CSSPropertyGridArea, rowStartValue.releaseNonNull(), important);
5413     addProperty(CSSPropertyGridColumnStart, CSSPropertyGridArea, columnStartValue.releaseNonNull(), important);
5414     addProperty(CSSPropertyGridRowEnd, CSSPropertyGridArea, rowEndValue.releaseNonNull(), important);
5415     addProperty(CSSPropertyGridColumnEnd, CSSPropertyGridArea, columnEndValue.releaseNonNull(), important);
5416     return true;
5417 }
5418 
5419 bool CSSPropertyParser::consumeGridTemplateRowsAndAreasAndColumns(CSSPropertyID shorthandId, bool important)
5420 {
5421     NamedGridAreaMap gridAreaMap;
5422     size_t rowCount = 0;
5423     size_t columnCount = 0;
5424     RefPtr&lt;CSSValueList&gt; templateRows = CSSValueList::createSpaceSeparated();
5425 
5426     // Persists between loop iterations so we can use the same value for
5427     // consecutive &lt;line-names&gt; values
5428     RefPtr&lt;CSSGridLineNamesValue&gt; lineNames;
5429 
5430     do {
5431         // Handle leading &lt;custom-ident&gt;*.
5432         bool hasPreviousLineNames = lineNames;
5433         lineNames = consumeGridLineNames(m_range, lineNames.get());
5434         if (lineNames &amp;&amp; !hasPreviousLineNames)
5435             templateRows-&gt;append(*lineNames);
5436 
5437         // Handle a template-area&#39;s row.
5438         if (m_range.peek().type() != StringToken || !parseGridTemplateAreasRow(m_range.consumeIncludingWhitespace().value().toString(), gridAreaMap, rowCount, columnCount))
5439             return false;
5440         ++rowCount;
5441 
5442         // Handle template-rows&#39;s track-size.
5443         RefPtr&lt;CSSValue&gt; value = consumeGridTrackSize(m_range, m_context.mode);
5444         if (!value)
5445             value = CSSValuePool::singleton().createIdentifierValue(CSSValueAuto);
5446         templateRows-&gt;append(*value);
5447 
5448         // This will handle the trailing/leading &lt;custom-ident&gt;* in the grammar.
5449         lineNames = consumeGridLineNames(m_range);
5450         if (lineNames)
5451             templateRows-&gt;append(lineNames.releaseNonNull());
5452     } while (!m_range.atEnd() &amp;&amp; !(m_range.peek().type() == DelimiterToken &amp;&amp; m_range.peek().delimiter() == &#39;/&#39;));
5453 
5454     RefPtr&lt;CSSValue&gt; columnsValue;
5455     if (!m_range.atEnd()) {
5456         if (!consumeSlashIncludingWhitespace(m_range))
5457             return false;
5458         columnsValue = consumeGridTrackList(m_range, m_context.mode, GridTemplateNoRepeat);
5459         if (!columnsValue || !m_range.atEnd())
5460             return false;
5461     } else {
5462         columnsValue = CSSValuePool::singleton().createIdentifierValue(CSSValueNone);
5463     }
5464     addProperty(CSSPropertyGridTemplateRows, shorthandId, templateRows.releaseNonNull(), important);
5465     addProperty(CSSPropertyGridTemplateColumns, shorthandId, columnsValue.releaseNonNull(), important);
5466     addProperty(CSSPropertyGridTemplateAreas, shorthandId, CSSGridTemplateAreasValue::create(gridAreaMap, rowCount, columnCount), important);
5467     return true;
5468 }
5469 
5470 bool CSSPropertyParser::consumeGridTemplateShorthand(CSSPropertyID shorthandId, bool important)
5471 {
5472     CSSParserTokenRange rangeCopy = m_range;
5473     RefPtr&lt;CSSValue&gt; rowsValue = consumeIdent&lt;CSSValueNone&gt;(m_range);
5474 
5475     // 1- &#39;none&#39; case.
5476     if (rowsValue &amp;&amp; m_range.atEnd()) {
5477         addProperty(CSSPropertyGridTemplateRows, shorthandId, CSSValuePool::singleton().createIdentifierValue(CSSValueNone), important);
5478         addProperty(CSSPropertyGridTemplateColumns, shorthandId, CSSValuePool::singleton().createIdentifierValue(CSSValueNone), important);
5479         addProperty(CSSPropertyGridTemplateAreas, shorthandId, CSSValuePool::singleton().createIdentifierValue(CSSValueNone), important);
5480         return true;
5481     }
5482 
5483     // 2- &lt;grid-template-rows&gt; / &lt;grid-template-columns&gt;
5484     if (!rowsValue)
5485         rowsValue = consumeGridTrackList(m_range, m_context.mode, GridTemplate);
5486 
5487     if (rowsValue) {
5488         if (!consumeSlashIncludingWhitespace(m_range))
5489             return false;
5490         RefPtr&lt;CSSValue&gt; columnsValue = consumeGridTemplatesRowsOrColumns(m_range, m_context.mode);
5491         if (!columnsValue || !m_range.atEnd())
5492             return false;
5493 
5494         addProperty(CSSPropertyGridTemplateRows, shorthandId, rowsValue.releaseNonNull(), important);
5495         addProperty(CSSPropertyGridTemplateColumns, shorthandId, columnsValue.releaseNonNull(), important);
5496         addProperty(CSSPropertyGridTemplateAreas, shorthandId, CSSValuePool::singleton().createIdentifierValue(CSSValueNone), important);
5497         return true;
5498     }
5499 
5500     // 3- [ &lt;line-names&gt;? &lt;string&gt; &lt;track-size&gt;? &lt;line-names&gt;? ]+ [ / &lt;track-list&gt; ]?
5501     m_range = rangeCopy;
5502     return consumeGridTemplateRowsAndAreasAndColumns(shorthandId, important);
5503 }
5504 
5505 static RefPtr&lt;CSSValue&gt; consumeImplicitGridAutoFlow(CSSParserTokenRange&amp; range, Ref&lt;CSSPrimitiveValue&gt;&amp;&amp; flowDirection)
5506 {
5507     // [ auto-flow &amp;&amp; dense? ]
5508     if (range.atEnd())
5509         return nullptr;
5510     auto list = CSSValueList::createSpaceSeparated();
5511     list-&gt;append(WTFMove(flowDirection));
5512     if (range.peek().id() == CSSValueAutoFlow) {
5513         range.consumeIncludingWhitespace();
5514         RefPtr&lt;CSSValue&gt; denseIdent = consumeIdent&lt;CSSValueDense&gt;(range);
5515         if (denseIdent)
5516             list-&gt;append(denseIdent.releaseNonNull());
5517     } else {
5518         // Dense case
5519         if (range.peek().id() != CSSValueDense)
5520             return nullptr;
5521         range.consumeIncludingWhitespace();
5522         if (range.atEnd() || range.peek().id() != CSSValueAutoFlow)
5523             return nullptr;
5524         range.consumeIncludingWhitespace();
5525         list-&gt;append(CSSValuePool::singleton().createIdentifierValue(CSSValueDense));
5526     }
5527 
5528     return WTFMove(list);
5529 }
5530 
5531 bool CSSPropertyParser::consumeGridShorthand(bool important)
5532 {
5533     ASSERT(shorthandForProperty(CSSPropertyGrid).length() == 6);
5534 
5535     CSSParserTokenRange rangeCopy = m_range;
5536 
5537     // 1- &lt;grid-template&gt;
5538     if (consumeGridTemplateShorthand(CSSPropertyGrid, important)) {
5539         // It can only be specified the explicit or the implicit grid properties in a single grid declaration.
5540         // The sub-properties not specified are set to their initial value, as normal for shorthands.
5541         addProperty(CSSPropertyGridAutoFlow, CSSPropertyGrid, CSSValuePool::singleton().createImplicitInitialValue(), important);
5542         addProperty(CSSPropertyGridAutoColumns, CSSPropertyGrid, CSSValuePool::singleton().createImplicitInitialValue(), important);
5543         addProperty(CSSPropertyGridAutoRows, CSSPropertyGrid, CSSValuePool::singleton().createImplicitInitialValue(), important);
5544         return true;
5545     }
5546 
5547     m_range = rangeCopy;
5548 
5549     RefPtr&lt;CSSValue&gt; autoColumnsValue;
5550     RefPtr&lt;CSSValue&gt; autoRowsValue;
5551     RefPtr&lt;CSSValue&gt; templateRows;
5552     RefPtr&lt;CSSValue&gt; templateColumns;
5553     RefPtr&lt;CSSValue&gt; gridAutoFlow;
5554 
5555     if (m_range.peek().id() == CSSValueAutoFlow || m_range.peek().id() == CSSValueDense) {
5556         // 2- [ auto-flow &amp;&amp; dense? ] &lt;grid-auto-rows&gt;? / &lt;grid-template-columns&gt;
5557         gridAutoFlow = consumeImplicitGridAutoFlow(m_range, CSSValuePool::singleton().createIdentifierValue(CSSValueRow));
5558         if (!gridAutoFlow || m_range.atEnd())
5559             return false;
5560         if (consumeSlashIncludingWhitespace(m_range))
5561             autoRowsValue = CSSValuePool::singleton().createImplicitInitialValue();
5562         else {
5563             autoRowsValue = consumeGridTrackList(m_range, m_context.mode, GridAuto);
5564             if (!autoRowsValue)
5565                 return false;
5566             if (!consumeSlashIncludingWhitespace(m_range))
5567                 return false;
5568         }
5569         if (m_range.atEnd())
5570             return false;
5571         templateColumns = consumeGridTemplatesRowsOrColumns(m_range, m_context.mode);
5572         if (!templateColumns)
5573             return false;
5574         templateRows = CSSValuePool::singleton().createImplicitInitialValue();
5575         autoColumnsValue = CSSValuePool::singleton().createImplicitInitialValue();
5576     } else {
5577         // 3- &lt;grid-template-rows&gt; / [ auto-flow &amp;&amp; dense? ] &lt;grid-auto-columns&gt;?
5578         templateRows = consumeGridTemplatesRowsOrColumns(m_range, m_context.mode);
5579         if (!templateRows)
5580             return false;
5581         if (!consumeSlashIncludingWhitespace(m_range) || m_range.atEnd())
5582             return false;
5583         gridAutoFlow = consumeImplicitGridAutoFlow(m_range, CSSValuePool::singleton().createIdentifierValue(CSSValueColumn));
5584         if (!gridAutoFlow)
5585             return false;
5586         if (m_range.atEnd())
5587             autoColumnsValue = CSSValuePool::singleton().createImplicitInitialValue();
5588         else {
5589             autoColumnsValue = consumeGridTrackList(m_range, m_context.mode, GridAuto);
5590             if (!autoColumnsValue)
5591                 return false;
5592         }
5593         templateColumns = CSSValuePool::singleton().createImplicitInitialValue();
5594         autoRowsValue = CSSValuePool::singleton().createImplicitInitialValue();
5595     }
5596 
5597     if (!m_range.atEnd())
5598         return false;
5599 
5600     // It can only be specified the explicit or the implicit grid properties in a single grid declaration.
5601     // The sub-properties not specified are set to their initial value, as normal for shorthands.
5602     addProperty(CSSPropertyGridTemplateColumns, CSSPropertyGrid, templateColumns.releaseNonNull(), important);
5603     addProperty(CSSPropertyGridTemplateRows, CSSPropertyGrid, templateRows.releaseNonNull(), important);
5604     addProperty(CSSPropertyGridTemplateAreas, CSSPropertyGrid, CSSValuePool::singleton().createImplicitInitialValue(), important);
5605     addProperty(CSSPropertyGridAutoFlow, CSSPropertyGrid, gridAutoFlow.releaseNonNull(), important);
5606     addProperty(CSSPropertyGridAutoColumns, CSSPropertyGrid, autoColumnsValue.releaseNonNull(), important);
5607     addProperty(CSSPropertyGridAutoRows, CSSPropertyGrid, autoRowsValue.releaseNonNull(), important);
5608 
5609     return true;
5610 }
5611 
5612 bool CSSPropertyParser::consumePlaceContentShorthand(bool important)
5613 {
5614     ASSERT(shorthandForProperty(CSSPropertyPlaceContent).length() == 2);
5615 
5616     if (m_range.atEnd())
5617         return false;
5618 
5619     CSSParserTokenRange rangeCopy = m_range;
5620     bool isBaseline = isBaselineKeyword(m_range.peek().id());
5621     RefPtr&lt;CSSValue&gt; alignContentValue = consumeContentDistributionOverflowPosition(m_range, isContentPositionKeyword);
5622     if (!alignContentValue)
5623         return false;
5624 
5625     // justify-content property does not allow the &lt;baseline-position&gt; values.
5626     if (m_range.atEnd() &amp;&amp; isBaseline)
5627         return false;
5628     if (isBaselineKeyword(m_range.peek().id()))
5629         return false;
5630 
5631     if (m_range.atEnd())
5632         m_range = rangeCopy;
5633     RefPtr&lt;CSSValue&gt; justifyContentValue = consumeContentDistributionOverflowPosition(m_range, isContentPositionOrLeftOrRightKeyword);
5634     if (!justifyContentValue)
5635         return false;
5636     if (!m_range.atEnd())
5637         return false;
5638 
5639     addProperty(CSSPropertyAlignContent, CSSPropertyPlaceContent, alignContentValue.releaseNonNull(), important);
5640     addProperty(CSSPropertyJustifyContent, CSSPropertyPlaceContent, justifyContentValue.releaseNonNull(), important);
5641     return true;
5642 }
5643 
5644 bool CSSPropertyParser::consumePlaceItemsShorthand(bool important)
5645 {
5646     ASSERT(shorthandForProperty(CSSPropertyPlaceItems).length() == 2);
5647 
5648     CSSParserTokenRange rangeCopy = m_range;
5649     RefPtr&lt;CSSValue&gt; alignItemsValue = consumeAlignItems(m_range);
5650     if (!alignItemsValue)
5651         return false;
5652 
5653     if (m_range.atEnd())
5654         m_range = rangeCopy;
5655     RefPtr&lt;CSSValue&gt; justifyItemsValue = consumeJustifyItems(m_range);
5656     if (!justifyItemsValue)
5657         return false;
5658 
5659     if (!m_range.atEnd())
5660         return false;
5661 
5662     addProperty(CSSPropertyAlignItems, CSSPropertyPlaceItems, alignItemsValue.releaseNonNull(), important);
5663     addProperty(CSSPropertyJustifyItems, CSSPropertyPlaceItems, justifyItemsValue.releaseNonNull(), important);
5664     return true;
5665 }
5666 
5667 bool CSSPropertyParser::consumePlaceSelfShorthand(bool important)
5668 {
5669     ASSERT(shorthandForProperty(CSSPropertyPlaceSelf).length() == 2);
5670 
5671     CSSParserTokenRange rangeCopy = m_range;
5672     RefPtr&lt;CSSValue&gt; alignSelfValue = consumeSelfPositionOverflowPosition(m_range, isSelfPositionKeyword);
5673     if (!alignSelfValue)
5674         return false;
5675 
5676     if (m_range.atEnd())
5677         m_range = rangeCopy;
5678     RefPtr&lt;CSSValue&gt; justifySelfValue = consumeSelfPositionOverflowPosition(m_range, isSelfPositionOrLeftOrRightKeyword);
5679     if (!justifySelfValue)
5680         return false;
5681 
5682     if (!m_range.atEnd())
5683         return false;
5684 
5685     addProperty(CSSPropertyAlignSelf, CSSPropertyPlaceSelf, alignSelfValue.releaseNonNull(), important);
5686     addProperty(CSSPropertyJustifySelf, CSSPropertyPlaceSelf, justifySelfValue.releaseNonNull(), important);
5687     return true;
5688 }
5689 
5690 bool CSSPropertyParser::parseShorthand(CSSPropertyID property, bool important)
5691 {
5692     switch (property) {
5693     case CSSPropertyWebkitMarginCollapse: {
5694         CSSValueID id = m_range.consumeIncludingWhitespace().id();
5695         if (!CSSParserFastPaths::isValidKeywordPropertyAndValue(CSSPropertyWebkitMarginBeforeCollapse, id, m_context.mode))
5696             return false;
5697         addProperty(CSSPropertyWebkitMarginBeforeCollapse, CSSPropertyWebkitMarginCollapse, CSSValuePool::singleton().createIdentifierValue(id), important);
5698         if (m_range.atEnd()) {
5699             addProperty(CSSPropertyWebkitMarginAfterCollapse, CSSPropertyWebkitMarginCollapse, CSSValuePool::singleton().createIdentifierValue(id), important);
5700             return true;
5701         }
5702         id = m_range.consumeIncludingWhitespace().id();
5703         if (!CSSParserFastPaths::isValidKeywordPropertyAndValue(CSSPropertyWebkitMarginAfterCollapse, id, m_context.mode))
5704             return false;
5705         addProperty(CSSPropertyWebkitMarginAfterCollapse, CSSPropertyWebkitMarginCollapse, CSSValuePool::singleton().createIdentifierValue(id), important);
5706         return true;
5707     }
5708     case CSSPropertyOverflow: {
5709         CSSValueID id = m_range.consumeIncludingWhitespace().id();
5710         if (!CSSParserFastPaths::isValidKeywordPropertyAndValue(CSSPropertyOverflowY, id, m_context.mode))
5711             return false;
5712         if (!m_range.atEnd())
5713             return false;
5714         RefPtr&lt;CSSValue&gt; overflowYValue = CSSValuePool::singleton().createIdentifierValue(id);
5715         RefPtr&lt;CSSValue&gt; overflowXValue;
5716 
5717         // FIXME: -webkit-paged-x or -webkit-paged-y only apply to overflow-y. If this value has been
5718         // set using the shorthand, then for now overflow-x will default to auto, but once we implement
5719         // pagination controls, it should default to hidden. If the overflow-y value is anything but
5720         // paged-x or paged-y, then overflow-x and overflow-y should have the same value.
5721         if (id == CSSValueWebkitPagedX || id == CSSValueWebkitPagedY)
5722             overflowXValue = CSSValuePool::singleton().createIdentifierValue(CSSValueAuto);
5723         else
5724             overflowXValue = overflowYValue;
5725         addProperty(CSSPropertyOverflowX, CSSPropertyOverflow, *overflowXValue, important);
5726         addProperty(CSSPropertyOverflowY, CSSPropertyOverflow, *overflowYValue, important);
5727         return true;
5728     }
5729     case CSSPropertyFont: {
5730         const CSSParserToken&amp; token = m_range.peek();
5731         if (token.id() &gt;= CSSValueCaption &amp;&amp; token.id() &lt;= CSSValueStatusBar)
5732             return consumeSystemFont(important);
5733         return consumeFont(important);
5734     }
5735     case CSSPropertyFontVariant:
5736         return consumeFontVariantShorthand(important);
5737     case CSSPropertyBorderSpacing:
5738         return consumeBorderSpacing(important);
5739     case CSSPropertyColumns:
5740         return consumeColumns(important);
5741     case CSSPropertyAnimation:
5742         return consumeAnimationShorthand(animationShorthandForParsing(), important);
5743     case CSSPropertyTransition:
5744         return consumeAnimationShorthand(transitionShorthandForParsing(), important);
5745     case CSSPropertyTextDecoration:
5746     case CSSPropertyWebkitTextDecoration:
5747         // FIXME-NEWPARSER: We need to unprefix -line/-style/-color ASAP and get rid
5748         // of -webkit-text-decoration completely.
5749         return consumeShorthandGreedily(webkitTextDecorationShorthand(), important);
5750     case CSSPropertyInset:
5751         return consume4ValueShorthand(insetShorthand(), important);
5752     case CSSPropertyInsetBlock:
5753         return consume2ValueShorthand(insetBlockShorthand(), important);
5754     case CSSPropertyInsetInline:
5755         return consume2ValueShorthand(insetInlineShorthand(), important);
5756     case CSSPropertyMargin:
5757         return consume4ValueShorthand(marginShorthand(), important);
5758     case CSSPropertyMarginBlock:
5759         return consume2ValueShorthand(marginBlockShorthand(), important);
5760     case CSSPropertyMarginInline:
5761         return consume2ValueShorthand(marginInlineShorthand(), important);
5762     case CSSPropertyPadding:
5763         return consume4ValueShorthand(paddingShorthand(), important);
5764     case CSSPropertyPaddingBlock:
5765         return consume2ValueShorthand(paddingBlockShorthand(), important);
5766     case CSSPropertyPaddingInline:
5767         return consume2ValueShorthand(paddingInlineShorthand(), important);
5768 #if ENABLE(CSS_SCROLL_SNAP)
5769     case CSSPropertyScrollSnapMargin:
5770         return consume4ValueShorthand(scrollSnapMarginShorthand(), important);
5771     case CSSPropertyScrollPadding:
5772         return consume4ValueShorthand(scrollPaddingShorthand(), important);
5773 #endif
5774     case CSSPropertyWebkitTextEmphasis:
5775         return consumeShorthandGreedily(webkitTextEmphasisShorthand(), important);
5776     case CSSPropertyOutline:
5777         return consumeShorthandGreedily(outlineShorthand(), important);
5778     case CSSPropertyBorderInline: {
5779         RefPtr&lt;CSSValue&gt; width;
5780         RefPtr&lt;CSSValue&gt; style;
5781         RefPtr&lt;CSSValue&gt; color;
5782         if (!consumeBorder(width, style, color))
5783             return false;
5784 
5785         addExpandedPropertyForValue(CSSPropertyBorderInlineWidth, width.releaseNonNull(), important);
5786         addExpandedPropertyForValue(CSSPropertyBorderInlineStyle, style.releaseNonNull(), important);
5787         addExpandedPropertyForValue(CSSPropertyBorderInlineColor, color.releaseNonNull(), important);
5788         return true;
5789     }
5790     case CSSPropertyBorderInlineColor:
5791         return consume2ValueShorthand(borderInlineColorShorthand(), important);
5792     case CSSPropertyBorderInlineStyle:
5793         return consume2ValueShorthand(borderInlineStyleShorthand(), important);
5794     case CSSPropertyBorderInlineWidth:
5795         return consume2ValueShorthand(borderInlineWidthShorthand(), important);
5796     case CSSPropertyBorderInlineStart:
5797         return consumeShorthandGreedily(borderInlineStartShorthand(), important);
5798     case CSSPropertyBorderInlineEnd:
5799         return consumeShorthandGreedily(borderInlineEndShorthand(), important);
5800     case CSSPropertyBorderBlock: {
5801         RefPtr&lt;CSSValue&gt; width;
5802         RefPtr&lt;CSSValue&gt; style;
5803         RefPtr&lt;CSSValue&gt; color;
5804         if (!consumeBorder(width, style, color))
5805             return false;
5806 
5807         addExpandedPropertyForValue(CSSPropertyBorderBlockWidth, width.releaseNonNull(), important);
5808         addExpandedPropertyForValue(CSSPropertyBorderBlockStyle, style.releaseNonNull(), important);
5809         addExpandedPropertyForValue(CSSPropertyBorderBlockColor, color.releaseNonNull(), important);
5810         return true;
5811     }
5812     case CSSPropertyBorderBlockColor:
5813         return consume2ValueShorthand(borderBlockColorShorthand(), important);
5814     case CSSPropertyBorderBlockStyle:
5815         return consume2ValueShorthand(borderBlockStyleShorthand(), important);
5816     case CSSPropertyBorderBlockWidth:
5817         return consume2ValueShorthand(borderBlockWidthShorthand(), important);
5818     case CSSPropertyBorderBlockStart:
5819         return consumeShorthandGreedily(borderBlockStartShorthand(), important);
5820     case CSSPropertyBorderBlockEnd:
5821         return consumeShorthandGreedily(borderBlockEndShorthand(), important);
5822     case CSSPropertyWebkitTextStroke:
5823         return consumeShorthandGreedily(webkitTextStrokeShorthand(), important);
5824     case CSSPropertyMarker: {
5825         RefPtr&lt;CSSValue&gt; marker = parseSingleValue(CSSPropertyMarkerStart);
5826         if (!marker || !m_range.atEnd())
5827             return false;
5828         auto markerRef = marker.releaseNonNull();
5829         addProperty(CSSPropertyMarkerStart, CSSPropertyMarker, markerRef.copyRef(), important);
5830         addProperty(CSSPropertyMarkerMid, CSSPropertyMarker, markerRef.copyRef(), important);
5831         addProperty(CSSPropertyMarkerEnd, CSSPropertyMarker, markerRef.copyRef(), important);
5832         return true;
5833     }
5834     case CSSPropertyFlex:
5835         return consumeFlex(important);
5836     case CSSPropertyFlexFlow:
5837         return consumeShorthandGreedily(flexFlowShorthand(), important);
5838     case CSSPropertyColumnRule:
5839         return consumeShorthandGreedily(columnRuleShorthand(), important);
5840     case CSSPropertyListStyle:
5841         return consumeShorthandGreedily(listStyleShorthand(), important);
5842     case CSSPropertyBorderRadius:
5843     case CSSPropertyWebkitBorderRadius: {
5844         RefPtr&lt;CSSPrimitiveValue&gt; horizontalRadii[4];
5845         RefPtr&lt;CSSPrimitiveValue&gt; verticalRadii[4];
5846         if (!consumeRadii(horizontalRadii, verticalRadii, m_range, m_context.mode, property == CSSPropertyWebkitBorderRadius))
5847             return false;
5848         addProperty(CSSPropertyBorderTopLeftRadius, CSSPropertyBorderRadius, createPrimitiveValuePair(horizontalRadii[0].releaseNonNull(), verticalRadii[0].releaseNonNull(), Pair::IdenticalValueEncoding::Coalesce), important);
5849         addProperty(CSSPropertyBorderTopRightRadius, CSSPropertyBorderRadius, createPrimitiveValuePair(horizontalRadii[1].releaseNonNull(), verticalRadii[1].releaseNonNull(), Pair::IdenticalValueEncoding::Coalesce), important);
5850         addProperty(CSSPropertyBorderBottomRightRadius, CSSPropertyBorderRadius, createPrimitiveValuePair(horizontalRadii[2].releaseNonNull(), verticalRadii[2].releaseNonNull(), Pair::IdenticalValueEncoding::Coalesce), important);
5851         addProperty(CSSPropertyBorderBottomLeftRadius, CSSPropertyBorderRadius, createPrimitiveValuePair(horizontalRadii[3].releaseNonNull(), verticalRadii[3].releaseNonNull(), Pair::IdenticalValueEncoding::Coalesce), important);
5852         return true;
5853     }
5854     case CSSPropertyBorderColor:
5855         return consume4ValueShorthand(borderColorShorthand(), important);
5856     case CSSPropertyBorderStyle:
5857         return consume4ValueShorthand(borderStyleShorthand(), important);
5858     case CSSPropertyBorderWidth:
5859         return consume4ValueShorthand(borderWidthShorthand(), important);
5860     case CSSPropertyBorderTop:
5861         return consumeShorthandGreedily(borderTopShorthand(), important);
5862     case CSSPropertyBorderRight:
5863         return consumeShorthandGreedily(borderRightShorthand(), important);
5864     case CSSPropertyBorderBottom:
5865         return consumeShorthandGreedily(borderBottomShorthand(), important);
5866     case CSSPropertyBorderLeft:
5867         return consumeShorthandGreedily(borderLeftShorthand(), important);
5868     case CSSPropertyBorder: {
5869         RefPtr&lt;CSSValue&gt; width;
5870         RefPtr&lt;CSSValue&gt; style;
5871         RefPtr&lt;CSSValue&gt; color;
5872         if (!consumeBorder(width, style, color))
5873             return false;
5874 
5875         addExpandedPropertyForValue(CSSPropertyBorderWidth, width.releaseNonNull(), important);
5876         addExpandedPropertyForValue(CSSPropertyBorderStyle, style.releaseNonNull(), important);
5877         addExpandedPropertyForValue(CSSPropertyBorderColor, color.releaseNonNull(), important);
5878         addExpandedPropertyForValue(CSSPropertyBorderImage, CSSValuePool::singleton().createImplicitInitialValue(), important);
5879         return true;
5880     }
5881     case CSSPropertyBorderImage:
5882         return consumeBorderImage(property, important);
5883     case CSSPropertyWebkitMaskPosition:
5884     case CSSPropertyBackgroundPosition: {
5885         RefPtr&lt;CSSValue&gt; resultX;
5886         RefPtr&lt;CSSValue&gt; resultY;
5887         if (!consumeBackgroundPosition(m_range, m_context, UnitlessQuirk::Allow, resultX, resultY) || !m_range.atEnd())
5888             return false;
5889         addProperty(property == CSSPropertyBackgroundPosition ? CSSPropertyBackgroundPositionX : CSSPropertyWebkitMaskPositionX, property, resultX.releaseNonNull(), important);
5890         addProperty(property == CSSPropertyBackgroundPosition ? CSSPropertyBackgroundPositionY : CSSPropertyWebkitMaskPositionY, property, resultY.releaseNonNull(), important);
5891         return true;
5892     }
5893     case CSSPropertyBackgroundRepeat:
5894     case CSSPropertyWebkitMaskRepeat: {
5895         RefPtr&lt;CSSValue&gt; resultX;
5896         RefPtr&lt;CSSValue&gt; resultY;
5897         bool implicit = false;
5898         if (!consumeRepeatStyle(m_range, resultX, resultY, implicit) || !m_range.atEnd())
5899             return false;
5900         addProperty(property == CSSPropertyBackgroundRepeat ? CSSPropertyBackgroundRepeatX : CSSPropertyWebkitMaskRepeatX, property, resultX.releaseNonNull(), important, implicit);
5901         addProperty(property == CSSPropertyBackgroundRepeat ? CSSPropertyBackgroundRepeatY : CSSPropertyWebkitMaskRepeatY, property, resultY.releaseNonNull(), important, implicit);
5902         return true;
5903     }
5904     case CSSPropertyBackground:
5905         return consumeBackgroundShorthand(backgroundShorthand(), important);
5906     case CSSPropertyWebkitMask:
5907         return consumeBackgroundShorthand(webkitMaskShorthand(), important);
5908     case CSSPropertyTransformOrigin:
5909         return consumeTransformOrigin(important);
5910     case CSSPropertyPerspectiveOrigin:
5911         return consumePerspectiveOrigin(important);
5912     case CSSPropertyGap: {
5913         RefPtr&lt;CSSValue&gt; rowGap = consumeGapLength(m_range, m_context.mode);
5914         RefPtr&lt;CSSValue&gt; columnGap = consumeGapLength(m_range, m_context.mode);
5915         if (!rowGap || !m_range.atEnd())
5916             return false;
5917         if (!columnGap)
5918             columnGap = rowGap;
5919         addProperty(CSSPropertyRowGap, CSSPropertyGap, rowGap.releaseNonNull(), important);
5920         addProperty(CSSPropertyColumnGap, CSSPropertyGap, columnGap.releaseNonNull(), important);
5921         return true;
5922     }
5923     case CSSPropertyGridColumn:
5924     case CSSPropertyGridRow:
5925         return consumeGridItemPositionShorthand(property, important);
5926     case CSSPropertyGridArea:
5927         return consumeGridAreaShorthand(important);
5928     case CSSPropertyGridTemplate:
5929         return consumeGridTemplateShorthand(CSSPropertyGridTemplate, important);
5930     case CSSPropertyGrid:
5931         return consumeGridShorthand(important);
5932     case CSSPropertyPlaceContent:
5933         return consumePlaceContentShorthand(important);
5934     case CSSPropertyPlaceItems:
5935         return consumePlaceItemsShorthand(important);
5936     case CSSPropertyPlaceSelf:
5937         return consumePlaceSelfShorthand(important);
5938     case CSSPropertyWebkitMarquee:
5939         return consumeShorthandGreedily(webkitMarqueeShorthand(), important);
5940     default:
5941         return false;
5942     }
5943 }
5944 
5945 } // namespace WebCore
    </pre>
  </body>
</html>