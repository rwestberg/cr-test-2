<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/editing/EditingStyle.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (C) 2007, 2008, 2009, 2013 Apple Inc.
   3  * Copyright (C) 2010, 2011 Google Inc. All rights reserved.
   4  *
   5  * Redistribution and use in source and binary forms, with or without
   6  * modification, are permitted provided that the following conditions
   7  * are met:
   8  * 1. Redistributions of source code must retain the above copyright
   9  *    notice, this list of conditions and the following disclaimer.
  10  * 2. Redistributions in binary form must reproduce the above copyright
  11  *    notice, this list of conditions and the following disclaimer in the
  12  *    documentation and/or other materials provided with the distribution.
  13  *
  14  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  15  * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  16  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
  17  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
  18  * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
  19  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
  20  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
  21  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
  22  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  23  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  24  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  25  */
  26 
  27 #include &quot;config.h&quot;
  28 #include &quot;EditingStyle.h&quot;
  29 
  30 #include &quot;ApplyStyleCommand.h&quot;
  31 #include &quot;CSSComputedStyleDeclaration.h&quot;
  32 #include &quot;CSSFontFamily.h&quot;
  33 #include &quot;CSSFontStyleValue.h&quot;
  34 #include &quot;CSSParser.h&quot;
  35 #include &quot;CSSRuleList.h&quot;
  36 #include &quot;CSSStyleRule.h&quot;
  37 #include &quot;CSSValueList.h&quot;
  38 #include &quot;CSSValuePool.h&quot;
  39 #include &quot;Editing.h&quot;
  40 #include &quot;Editor.h&quot;
  41 #include &quot;FontCache.h&quot;
  42 #include &quot;FontCascade.h&quot;
  43 #include &quot;Frame.h&quot;
  44 #include &quot;HTMLFontElement.h&quot;
  45 #include &quot;HTMLInterchange.h&quot;
  46 #include &quot;HTMLNames.h&quot;
  47 #include &quot;HTMLSpanElement.h&quot;
  48 #include &quot;Node.h&quot;
  49 #include &quot;NodeTraversal.h&quot;
  50 #include &quot;QualifiedName.h&quot;
  51 #include &quot;RenderElement.h&quot;
  52 #include &quot;RenderStyle.h&quot;
  53 #include &quot;StyleFontSizeFunctions.h&quot;
  54 #include &quot;StyleProperties.h&quot;
  55 #include &quot;StyleResolver.h&quot;
  56 #include &quot;StyleRule.h&quot;
  57 #include &quot;StyledElement.h&quot;
  58 #include &quot;VisibleUnits.h&quot;
  59 #include &lt;wtf/Optional.h&gt;
  60 
  61 namespace WebCore {
  62 
  63 // Editing style properties must be preserved during editing operation.
  64 // e.g. when a user inserts a new paragraph, all properties listed here must be copied to the new paragraph.
  65 static const CSSPropertyID editingProperties[] = {
  66     CSSPropertyCaretColor,
  67     CSSPropertyColor,
  68     CSSPropertyFontFamily,
  69     CSSPropertyFontSize,
  70     CSSPropertyFontStyle,
  71     CSSPropertyFontVariantCaps,
  72     CSSPropertyFontWeight,
  73     CSSPropertyLetterSpacing,
  74     CSSPropertyOrphans,
  75     CSSPropertyTextAlign,
  76     CSSPropertyTextIndent,
  77     CSSPropertyTextTransform,
  78     CSSPropertyWhiteSpace,
  79     CSSPropertyWidows,
  80     CSSPropertyWordSpacing,
  81 #if ENABLE(TOUCH_EVENTS)
  82     CSSPropertyWebkitTapHighlightColor,
  83 #endif
  84     CSSPropertyWebkitTextDecorationsInEffect,
  85     CSSPropertyWebkitTextFillColor,
  86 #if ENABLE(TEXT_AUTOSIZING)
  87     CSSPropertyWebkitTextSizeAdjust,
  88 #endif
  89     CSSPropertyWebkitTextStrokeColor,
  90     CSSPropertyWebkitTextStrokeWidth,
  91 
  92     // Non-inheritable properties
  93     CSSPropertyBackgroundColor,
  94     CSSPropertyTextDecoration,
  95 };
  96 
  97 const unsigned numAllEditingProperties = WTF_ARRAY_LENGTH(editingProperties);
  98 const unsigned numInheritableEditingProperties = numAllEditingProperties - 2;
  99 
 100 enum EditingPropertiesToInclude { OnlyInheritableEditingProperties, AllEditingProperties };
 101 template &lt;class StyleDeclarationType&gt;
 102 static Ref&lt;MutableStyleProperties&gt; copyEditingProperties(StyleDeclarationType* style, EditingPropertiesToInclude type)
 103 {
 104     if (type == AllEditingProperties)
 105         return style-&gt;copyPropertiesInSet(editingProperties, numAllEditingProperties);
 106     return style-&gt;copyPropertiesInSet(editingProperties, numInheritableEditingProperties);
 107 }
 108 
 109 static inline bool isEditingProperty(int id)
 110 {
 111     for (auto&amp; editingProperty : editingProperties) {
 112         if (editingProperty == id)
 113             return true;
 114     }
 115     return false;
 116 }
 117 
 118 static Ref&lt;MutableStyleProperties&gt; copyPropertiesFromComputedStyle(ComputedStyleExtractor&amp; computedStyle, EditingStyle::PropertiesToInclude propertiesToInclude)
 119 {
 120     switch (propertiesToInclude) {
 121     case EditingStyle::OnlyEditingInheritableProperties:
 122         return copyEditingProperties(&amp;computedStyle, OnlyInheritableEditingProperties);
 123     case EditingStyle::EditingPropertiesInEffect:
 124         return copyEditingProperties(&amp;computedStyle, AllEditingProperties);
 125     case EditingStyle::AllProperties:
 126         break;
 127     }
 128     return computedStyle.copyProperties();
 129 }
 130 
 131 static Ref&lt;MutableStyleProperties&gt; copyPropertiesFromComputedStyle(Node* node, EditingStyle::PropertiesToInclude propertiesToInclude)
 132 {
 133     ComputedStyleExtractor computedStyle(node);
 134     return copyPropertiesFromComputedStyle(computedStyle, propertiesToInclude);
 135 }
 136 
 137 static RefPtr&lt;CSSValue&gt; extractPropertyValue(const StyleProperties&amp; style, CSSPropertyID propertyID)
 138 {
 139     return style.getPropertyCSSValue(propertyID);
 140 }
 141 
 142 static RefPtr&lt;CSSValue&gt; extractPropertyValue(ComputedStyleExtractor&amp; computedStyle, CSSPropertyID propertyID)
 143 {
 144     return computedStyle.propertyValue(propertyID);
 145 }
 146 
 147 template&lt;typename T&gt;
 148 int identifierForStyleProperty(T&amp; style, CSSPropertyID propertyID)
 149 {
 150     RefPtr&lt;CSSValue&gt; value = extractPropertyValue(style, propertyID);
 151     if (propertyID == CSSPropertyFontStyle &amp;&amp; is&lt;CSSFontStyleValue&gt;(value) &amp;&amp; downcast&lt;CSSFontStyleValue&gt;(value.get())-&gt;isItalicOrOblique())
 152         return CSSValueItalic;
 153     if (!is&lt;CSSPrimitiveValue&gt;(value))
 154         return 0;
 155     return downcast&lt;CSSPrimitiveValue&gt;(*value).valueID();
 156 }
 157 
 158 template&lt;typename T&gt; Ref&lt;MutableStyleProperties&gt; getPropertiesNotIn(StyleProperties&amp; styleWithRedundantProperties, T&amp; baseStyle);
 159 enum LegacyFontSizeMode { AlwaysUseLegacyFontSize, UseLegacyFontSizeOnlyIfPixelValuesMatch };
 160 static int legacyFontSizeFromCSSValue(Document&amp;, CSSPrimitiveValue*, bool shouldUseFixedFontDefaultSize, LegacyFontSizeMode);
 161 static bool hasTransparentBackgroundColor(StyleProperties*);
 162 static RefPtr&lt;CSSValue&gt; backgroundColorInEffect(Node*);
 163 
 164 class HTMLElementEquivalent {
 165     WTF_MAKE_FAST_ALLOCATED;
 166 public:
 167     HTMLElementEquivalent(CSSPropertyID, CSSValueID primitiveValue, const QualifiedName&amp; tagName);
 168     virtual ~HTMLElementEquivalent() = default;
 169 
 170     virtual bool matches(const Element&amp; element) const { return !m_tagName || element.hasTagName(*m_tagName); }
 171     virtual bool hasAttribute() const { return false; }
 172     virtual bool propertyExistsInStyle(const EditingStyle&amp; style) const { return style.m_mutableStyle &amp;&amp; style.m_mutableStyle-&gt;getPropertyCSSValue(m_propertyID); }
 173     virtual bool valueIsPresentInStyle(Element&amp;, const EditingStyle&amp;) const;
 174     virtual void addToStyle(Element*, EditingStyle*) const;
 175 
 176 protected:
 177     HTMLElementEquivalent(CSSPropertyID);
 178     HTMLElementEquivalent(CSSPropertyID, const QualifiedName&amp; tagName);
 179     const CSSPropertyID m_propertyID;
 180     const RefPtr&lt;CSSPrimitiveValue&gt; m_primitiveValue;
 181     const QualifiedName* m_tagName { nullptr }; // We can store a pointer because HTML tag names are const global.
 182 };
 183 
 184 HTMLElementEquivalent::HTMLElementEquivalent(CSSPropertyID id)
 185     : m_propertyID(id)
 186 {
 187 }
 188 
 189 HTMLElementEquivalent::HTMLElementEquivalent(CSSPropertyID id, const QualifiedName&amp; tagName)
 190     : m_propertyID(id)
 191     , m_tagName(&amp;tagName)
 192 {
 193 }
 194 
 195 HTMLElementEquivalent::HTMLElementEquivalent(CSSPropertyID id, CSSValueID primitiveValue, const QualifiedName&amp; tagName)
 196     : m_propertyID(id)
 197     , m_primitiveValue(CSSPrimitiveValue::createIdentifier(primitiveValue))
 198     , m_tagName(&amp;tagName)
 199 {
 200     ASSERT(primitiveValue != CSSValueInvalid);
 201 }
 202 
 203 bool HTMLElementEquivalent::valueIsPresentInStyle(Element&amp; element, const EditingStyle&amp; style) const
 204 {
 205     RefPtr&lt;CSSValue&gt; value = style.m_mutableStyle-&gt;getPropertyCSSValue(m_propertyID);
 206     return matches(element) &amp;&amp; is&lt;CSSPrimitiveValue&gt;(value) &amp;&amp; downcast&lt;CSSPrimitiveValue&gt;(*value).valueID() == m_primitiveValue-&gt;valueID();
 207 }
 208 
 209 void HTMLElementEquivalent::addToStyle(Element*, EditingStyle* style) const
 210 {
 211     style-&gt;setProperty(m_propertyID, m_primitiveValue-&gt;cssText());
 212 }
 213 
 214 class HTMLTextDecorationEquivalent : public HTMLElementEquivalent {
 215 public:
 216     HTMLTextDecorationEquivalent(CSSValueID primitiveValue, const QualifiedName&amp; tagName)
 217         : HTMLElementEquivalent(CSSPropertyTextDecoration, primitiveValue, tagName)
 218         , m_isUnderline(primitiveValue == CSSValueUnderline)
 219     {
 220     }
 221 
 222     bool propertyExistsInStyle(const EditingStyle&amp; style) const override
 223     {
 224         if (changeInStyle(style) != TextDecorationChange::None)
 225             return true;
 226 
 227         if (!style.m_mutableStyle)
 228             return false;
 229 
 230         auto&amp; mutableStyle = *style.m_mutableStyle;
 231         return mutableStyle.getPropertyCSSValue(CSSPropertyWebkitTextDecorationsInEffect)
 232             || mutableStyle.getPropertyCSSValue(CSSPropertyTextDecoration);
 233     }
 234 
 235     bool valueIsPresentInStyle(Element&amp; element, const EditingStyle&amp; style) const override
 236     {
 237         if (!matches(element))
 238             return false;
 239         auto change = changeInStyle(style);
 240         if (change != TextDecorationChange::None)
 241             return change == TextDecorationChange::Add;
 242         RefPtr&lt;CSSValue&gt; styleValue = style.m_mutableStyle-&gt;getPropertyCSSValue(CSSPropertyWebkitTextDecorationsInEffect);
 243         if (!styleValue)
 244             styleValue = style.m_mutableStyle-&gt;getPropertyCSSValue(CSSPropertyTextDecoration);
 245         return is&lt;CSSValueList&gt;(styleValue) &amp;&amp; downcast&lt;CSSValueList&gt;(*styleValue).hasValue(m_primitiveValue.get());
 246     }
 247 
 248 private:
 249     TextDecorationChange changeInStyle(const EditingStyle&amp; style) const
 250     {
 251         return m_isUnderline ? style.underlineChange() : style.strikeThroughChange();
 252     }
 253 
 254     bool m_isUnderline;
 255 };
 256 
 257 class HTMLAttributeEquivalent : public HTMLElementEquivalent {
 258 public:
 259     HTMLAttributeEquivalent(CSSPropertyID, const QualifiedName&amp; tagName, const QualifiedName&amp; attrName);
 260     HTMLAttributeEquivalent(CSSPropertyID, const QualifiedName&amp; attrName);
 261 
 262     bool matches(const Element&amp; element) const override { return HTMLElementEquivalent::matches(element) &amp;&amp; element.hasAttribute(m_attrName); }
 263     bool hasAttribute() const override { return true; }
 264     bool valueIsPresentInStyle(Element&amp;, const EditingStyle&amp;) const override;
 265     void addToStyle(Element*, EditingStyle*) const override;
 266     virtual RefPtr&lt;CSSValue&gt; attributeValueAsCSSValue(Element*) const;
 267     inline const QualifiedName&amp; attributeName() const { return m_attrName; }
 268 
 269 protected:
 270     const QualifiedName&amp; m_attrName; // We can store a reference because HTML attribute names are const global.
 271 };
 272 
 273 HTMLAttributeEquivalent::HTMLAttributeEquivalent(CSSPropertyID id, const QualifiedName&amp; tagName, const QualifiedName&amp; attrName)
 274     : HTMLElementEquivalent(id, tagName)
 275     , m_attrName(attrName)
 276 {
 277 }
 278 
 279 HTMLAttributeEquivalent::HTMLAttributeEquivalent(CSSPropertyID id, const QualifiedName&amp; attrName)
 280     : HTMLElementEquivalent(id)
 281     , m_attrName(attrName)
 282 {
 283 }
 284 
 285 bool HTMLAttributeEquivalent::valueIsPresentInStyle(Element&amp; element, const EditingStyle&amp; style) const
 286 {
 287     RefPtr&lt;CSSValue&gt; value = attributeValueAsCSSValue(&amp;element);
 288     RefPtr&lt;CSSValue&gt; styleValue = style.m_mutableStyle-&gt;getPropertyCSSValue(m_propertyID);
 289 
 290     return compareCSSValuePtr(value, styleValue);
 291 }
 292 
 293 void HTMLAttributeEquivalent::addToStyle(Element* element, EditingStyle* style) const
 294 {
 295     if (RefPtr&lt;CSSValue&gt; value = attributeValueAsCSSValue(element))
 296         style-&gt;setProperty(m_propertyID, value-&gt;cssText());
 297 }
 298 
 299 RefPtr&lt;CSSValue&gt; HTMLAttributeEquivalent::attributeValueAsCSSValue(Element* element) const
 300 {
 301     ASSERT(element);
 302     const AtomString&amp; value = element-&gt;getAttribute(m_attrName);
 303     if (value.isNull())
 304         return nullptr;
 305 
 306     RefPtr&lt;MutableStyleProperties&gt; dummyStyle;
 307     dummyStyle = MutableStyleProperties::create();
 308     dummyStyle-&gt;setProperty(m_propertyID, value);
 309     return dummyStyle-&gt;getPropertyCSSValue(m_propertyID);
 310 }
 311 
 312 class HTMLFontSizeEquivalent : public HTMLAttributeEquivalent {
 313 public:
 314     HTMLFontSizeEquivalent();
 315 
 316     RefPtr&lt;CSSValue&gt; attributeValueAsCSSValue(Element*) const override;
 317 };
 318 
 319 HTMLFontSizeEquivalent::HTMLFontSizeEquivalent()
 320     : HTMLAttributeEquivalent(CSSPropertyFontSize, HTMLNames::fontTag, HTMLNames::sizeAttr)
 321 {
 322 }
 323 
 324 RefPtr&lt;CSSValue&gt; HTMLFontSizeEquivalent::attributeValueAsCSSValue(Element* element) const
 325 {
 326     ASSERT(element);
 327     const AtomString&amp; value = element-&gt;getAttribute(m_attrName);
 328     if (value.isNull())
 329         return nullptr;
 330     CSSValueID size;
 331     if (!HTMLFontElement::cssValueFromFontSizeNumber(value, size))
 332         return nullptr;
 333     return CSSPrimitiveValue::createIdentifier(size);
 334 }
 335 
 336 float EditingStyle::NoFontDelta = 0.0f;
 337 
 338 EditingStyle::EditingStyle()
 339     : m_shouldUseFixedDefaultFontSize(false)
 340     , m_underlineChange(static_cast&lt;unsigned&gt;(TextDecorationChange::None))
 341     , m_strikeThroughChange(static_cast&lt;unsigned&gt;(TextDecorationChange::None))
 342 {
 343 }
 344 
 345 EditingStyle::EditingStyle(Node* node, PropertiesToInclude propertiesToInclude)
 346     : EditingStyle()
 347 {
 348     init(node, propertiesToInclude);
 349 }
 350 
 351 EditingStyle::EditingStyle(const Position&amp; position, PropertiesToInclude propertiesToInclude)
 352     : EditingStyle()
 353 {
 354     init(position.deprecatedNode(), propertiesToInclude);
 355 }
 356 
 357 EditingStyle::EditingStyle(const CSSStyleDeclaration* style)
 358     : EditingStyle()
 359 {
 360     if (style)
 361         m_mutableStyle = style-&gt;copyProperties();
 362     extractFontSizeDelta();
 363 }
 364 
 365 EditingStyle::EditingStyle(const StyleProperties* style)
 366     : EditingStyle()
 367 {
 368     if (style)
 369         m_mutableStyle = style-&gt;mutableCopy();
 370     extractFontSizeDelta();
 371 }
 372 
 373 EditingStyle::EditingStyle(CSSPropertyID propertyID, const String&amp; value)
 374     : EditingStyle()
 375 {
 376     setProperty(propertyID, value);
 377     extractFontSizeDelta();
 378 }
 379 
 380 EditingStyle::EditingStyle(CSSPropertyID propertyID, CSSValueID value)
 381     : EditingStyle()
 382 {
 383     m_mutableStyle = MutableStyleProperties::create();
 384     m_mutableStyle-&gt;setProperty(propertyID, value);
 385     extractFontSizeDelta();
 386 }
 387 
 388 EditingStyle::~EditingStyle() = default;
 389 
 390 static Color cssValueToColor(CSSValue* colorValue)
 391 {
 392     if (!is&lt;CSSPrimitiveValue&gt;(colorValue))
 393         return Color::transparent;
 394 
 395     CSSPrimitiveValue&amp; primitiveColor = downcast&lt;CSSPrimitiveValue&gt;(*colorValue);
 396     if (primitiveColor.isRGBColor())
 397         return primitiveColor.color();
 398 
 399     return CSSParser::parseColor(colorValue-&gt;cssText());
 400 }
 401 
 402 template&lt;typename T&gt;
 403 static inline Color textColorFromStyle(T&amp; style)
 404 {
 405     return cssValueToColor(extractPropertyValue(style, CSSPropertyColor).get());
 406 }
 407 
 408 template&lt;typename T&gt;
 409 static inline Color caretColorFromStyle(T&amp; style)
 410 {
 411     return cssValueToColor(extractPropertyValue(style, CSSPropertyCaretColor).get());
 412 }
 413 
 414 template&lt;typename T&gt;
 415 static inline Color backgroundColorFromStyle(T&amp; style)
 416 {
 417     return cssValueToColor(extractPropertyValue(style, CSSPropertyBackgroundColor).get());
 418 }
 419 
 420 static inline Color rgbaBackgroundColorInEffect(Node* node)
 421 {
 422     return cssValueToColor(backgroundColorInEffect(node).get());
 423 }
 424 
 425 static int textAlignResolvingStartAndEnd(int textAlign, int direction)
 426 {
 427     switch (textAlign) {
 428     case CSSValueCenter:
 429     case CSSValueWebkitCenter:
 430         return CSSValueCenter;
 431     case CSSValueJustify:
 432         return CSSValueJustify;
 433     case CSSValueLeft:
 434     case CSSValueWebkitLeft:
 435         return CSSValueLeft;
 436     case CSSValueRight:
 437     case CSSValueWebkitRight:
 438         return CSSValueRight;
 439     case CSSValueStart:
 440         return direction != CSSValueRtl ? CSSValueLeft : CSSValueRight;
 441     case CSSValueEnd:
 442         return direction == CSSValueRtl ? CSSValueRight : CSSValueLeft;
 443     }
 444     return CSSValueInvalid;
 445 }
 446 
 447 template&lt;typename T&gt;
 448 static int textAlignResolvingStartAndEnd(T&amp; style)
 449 {
 450     return textAlignResolvingStartAndEnd(identifierForStyleProperty(style, CSSPropertyTextAlign), identifierForStyleProperty(style, CSSPropertyDirection));
 451 }
 452 
 453 void EditingStyle::init(Node* node, PropertiesToInclude propertiesToInclude)
 454 {
 455     if (isTabSpanTextNode(node))
 456         node = tabSpanNode(node)-&gt;parentNode();
 457     else if (isTabSpanNode(node))
 458         node = node-&gt;parentNode();
 459 
 460     ComputedStyleExtractor computedStyleAtPosition(node);
 461     // FIXME: It&#39;s strange to not set background-color and text-decoration when propertiesToInclude is EditingPropertiesInEffect.
 462     // However editing/selection/contains-boundaries.html fails without this ternary.
 463     m_mutableStyle = copyPropertiesFromComputedStyle(computedStyleAtPosition,
 464         propertiesToInclude == EditingPropertiesInEffect ? OnlyEditingInheritableProperties : propertiesToInclude);
 465 
 466     if (propertiesToInclude == EditingPropertiesInEffect) {
 467         if (RefPtr&lt;CSSValue&gt; value = backgroundColorInEffect(node))
 468             m_mutableStyle-&gt;setProperty(CSSPropertyBackgroundColor, value-&gt;cssText());
 469         if (RefPtr&lt;CSSValue&gt; value = computedStyleAtPosition.propertyValue(CSSPropertyWebkitTextDecorationsInEffect)) {
 470             m_mutableStyle-&gt;setProperty(CSSPropertyTextDecoration, value-&gt;cssText());
 471             m_mutableStyle-&gt;removeProperty(CSSPropertyWebkitTextDecorationsInEffect);
 472         }
 473     }
 474 
 475     if (node &amp;&amp; node-&gt;computedStyle()) {
 476         auto* renderStyle = node-&gt;computedStyle();
 477         removeTextFillAndStrokeColorsIfNeeded(renderStyle);
 478         if (renderStyle-&gt;fontDescription().keywordSize())
 479             m_mutableStyle-&gt;setProperty(CSSPropertyFontSize, computedStyleAtPosition.getFontSizeCSSValuePreferringKeyword()-&gt;cssText());
 480     }
 481 
 482     m_shouldUseFixedDefaultFontSize = computedStyleAtPosition.useFixedFontDefaultSize();
 483     extractFontSizeDelta();
 484 }
 485 
 486 void EditingStyle::removeTextFillAndStrokeColorsIfNeeded(const RenderStyle* renderStyle)
 487 {
 488     // If a node&#39;s text fill color is invalid, then its children use
 489     // their font-color as their text fill color (they don&#39;t
 490     // inherit it).  Likewise for stroke color.
 491     if (!renderStyle-&gt;textFillColor().isValid())
 492         m_mutableStyle-&gt;removeProperty(CSSPropertyWebkitTextFillColor);
 493     if (!renderStyle-&gt;textStrokeColor().isValid())
 494         m_mutableStyle-&gt;removeProperty(CSSPropertyWebkitTextStrokeColor);
 495 }
 496 
 497 void EditingStyle::setProperty(CSSPropertyID propertyID, const String&amp; value, bool important)
 498 {
 499     if (!m_mutableStyle)
 500         m_mutableStyle = MutableStyleProperties::create();
 501 
 502     m_mutableStyle-&gt;setProperty(propertyID, value, important);
 503 }
 504 
 505 void EditingStyle::extractFontSizeDelta()
 506 {
 507     if (!m_mutableStyle)
 508         return;
 509 
 510     if (m_mutableStyle-&gt;getPropertyCSSValue(CSSPropertyFontSize)) {
 511         // Explicit font size overrides any delta.
 512         m_mutableStyle-&gt;removeProperty(CSSPropertyWebkitFontSizeDelta);
 513         return;
 514     }
 515 
 516     // Get the adjustment amount out of the style.
 517     RefPtr&lt;CSSValue&gt; value = m_mutableStyle-&gt;getPropertyCSSValue(CSSPropertyWebkitFontSizeDelta);
 518     if (!is&lt;CSSPrimitiveValue&gt;(value))
 519         return;
 520 
 521     CSSPrimitiveValue&amp; primitiveValue = downcast&lt;CSSPrimitiveValue&gt;(*value);
 522 
 523     // Only PX handled now. If we handle more types in the future, perhaps
 524     // a switch statement here would be more appropriate.
 525     if (!primitiveValue.isPx())
 526         return;
 527 
 528     m_fontSizeDelta = primitiveValue.floatValue();
 529     m_mutableStyle-&gt;removeProperty(CSSPropertyWebkitFontSizeDelta);
 530 }
 531 
 532 bool EditingStyle::isEmpty() const
 533 {
 534     return (!m_mutableStyle || m_mutableStyle-&gt;isEmpty()) &amp;&amp; m_fontSizeDelta == NoFontDelta
 535         &amp;&amp; underlineChange() == TextDecorationChange::None &amp;&amp; strikeThroughChange() == TextDecorationChange::None;
 536 }
 537 
 538 Ref&lt;MutableStyleProperties&gt; EditingStyle::styleWithResolvedTextDecorations() const
 539 {
 540     bool hasTextDecorationChanges = underlineChange() != TextDecorationChange::None || strikeThroughChange() != TextDecorationChange::None;
 541     if (m_mutableStyle &amp;&amp; !hasTextDecorationChanges)
 542         return *m_mutableStyle;
 543 
 544     Ref&lt;MutableStyleProperties&gt; style = m_mutableStyle ? m_mutableStyle-&gt;mutableCopy() : MutableStyleProperties::create();
 545 
 546     Ref&lt;CSSValueList&gt; valueList = CSSValueList::createSpaceSeparated();
 547     if (underlineChange() == TextDecorationChange::Add)
 548         valueList-&gt;append(CSSValuePool::singleton().createIdentifierValue(CSSValueUnderline));
 549     if (strikeThroughChange() == TextDecorationChange::Add)
 550         valueList-&gt;append(CSSValuePool::singleton().createIdentifierValue(CSSValueLineThrough));
 551 
 552     if (valueList-&gt;length())
 553         style-&gt;setProperty(CSSPropertyTextDecoration, valueList.ptr());
 554     else
 555         style-&gt;setProperty(CSSPropertyTextDecoration, CSSValuePool::singleton().createIdentifierValue(CSSValueNone));
 556 
 557     return style;
 558 }
 559 
 560 Optional&lt;WritingDirection&gt; EditingStyle::textDirection() const
 561 {
 562     if (!m_mutableStyle)
 563         return WTF::nullopt;
 564 
 565     RefPtr&lt;CSSValue&gt; unicodeBidi = m_mutableStyle-&gt;getPropertyCSSValue(CSSPropertyUnicodeBidi);
 566     if (!is&lt;CSSPrimitiveValue&gt;(unicodeBidi))
 567         return WTF::nullopt;
 568 
 569     CSSValueID unicodeBidiValue = downcast&lt;CSSPrimitiveValue&gt;(*unicodeBidi).valueID();
 570     if (unicodeBidiValue == CSSValueEmbed) {
 571         RefPtr&lt;CSSValue&gt; direction = m_mutableStyle-&gt;getPropertyCSSValue(CSSPropertyDirection);
 572         if (!is&lt;CSSPrimitiveValue&gt;(direction))
 573             return WTF::nullopt;
 574 
 575         return downcast&lt;CSSPrimitiveValue&gt;(*direction).valueID() == CSSValueLtr ? WritingDirection::LeftToRight : WritingDirection::RightToLeft;
 576     }
 577 
 578     if (unicodeBidiValue == CSSValueNormal)
 579         return WritingDirection::Natural;
 580 
 581     return WTF::nullopt;
 582 }
 583 
 584 void EditingStyle::setStyle(RefPtr&lt;MutableStyleProperties&gt;&amp;&amp; style)
 585 {
 586     m_mutableStyle = WTFMove(style);
 587     // FIXME: We should be able to figure out whether or not font is fixed width for mutable style.
 588     // We need to check font-family is monospace as in FontDescription but we don&#39;t want to duplicate code here.
 589     m_shouldUseFixedDefaultFontSize = false;
 590     extractFontSizeDelta();
 591 }
 592 
 593 void EditingStyle::overrideWithStyle(const StyleProperties&amp; style)
 594 {
 595     return mergeStyle(&amp;style, OverrideValues);
 596 }
 597 
 598 static void applyTextDecorationChangeToValueList(CSSValueList&amp; valueList, TextDecorationChange change, Ref&lt;CSSPrimitiveValue&gt;&amp;&amp; value)
 599 {
 600     switch (change) {
 601     case TextDecorationChange::None:
 602         break;
 603     case TextDecorationChange::Add:
 604         valueList.append(WTFMove(value));
 605         break;
 606     case TextDecorationChange::Remove:
 607         valueList.removeAll(&amp;value.get());
 608         break;
 609     }
 610 }
 611 
 612 void EditingStyle::overrideTypingStyleAt(const EditingStyle&amp; style, const Position&amp; position)
 613 {
 614     mergeStyle(style.m_mutableStyle.get(), OverrideValues);
 615 
 616     m_fontSizeDelta += style.m_fontSizeDelta;
 617 
 618     prepareToApplyAt(position, EditingStyle::PreserveWritingDirection);
 619 
 620     auto underlineChange = style.underlineChange();
 621     auto strikeThroughChange = style.strikeThroughChange();
 622     if (underlineChange == TextDecorationChange::None &amp;&amp; strikeThroughChange == TextDecorationChange::None)
 623         return;
 624 
 625     if (!m_mutableStyle)
 626         m_mutableStyle = MutableStyleProperties::create();
 627 
 628     auto&amp; cssValuePool = CSSValuePool::singleton();
 629     Ref&lt;CSSPrimitiveValue&gt; underline = cssValuePool.createIdentifierValue(CSSValueUnderline);
 630     Ref&lt;CSSPrimitiveValue&gt; lineThrough = cssValuePool.createIdentifierValue(CSSValueLineThrough);
 631     RefPtr&lt;CSSValue&gt; value = m_mutableStyle-&gt;getPropertyCSSValue(CSSPropertyWebkitTextDecorationsInEffect);
 632     RefPtr&lt;CSSValueList&gt; valueList;
 633     if (value &amp;&amp; value-&gt;isValueList()) {
 634         valueList = downcast&lt;CSSValueList&gt;(*value).copy();
 635         applyTextDecorationChangeToValueList(*valueList, underlineChange, WTFMove(underline));
 636         applyTextDecorationChangeToValueList(*valueList, strikeThroughChange, WTFMove(lineThrough));
 637     } else {
 638         valueList = CSSValueList::createSpaceSeparated();
 639         if (underlineChange == TextDecorationChange::Add)
 640             valueList-&gt;append(WTFMove(underline));
 641         if (strikeThroughChange == TextDecorationChange::Add)
 642             valueList-&gt;append(WTFMove(lineThrough));
 643     }
 644     m_mutableStyle-&gt;setProperty(CSSPropertyWebkitTextDecorationsInEffect, valueList.get());
 645 }
 646 
 647 void EditingStyle::clear()
 648 {
 649     m_mutableStyle = nullptr;
 650     m_shouldUseFixedDefaultFontSize = false;
 651     m_fontSizeDelta = NoFontDelta;
 652     setUnderlineChange(TextDecorationChange::None);
 653     setStrikeThroughChange(TextDecorationChange::None);
 654 }
 655 
 656 Ref&lt;EditingStyle&gt; EditingStyle::copy() const
 657 {
 658     auto copy = EditingStyle::create();
 659     if (m_mutableStyle)
 660         copy-&gt;m_mutableStyle = m_mutableStyle-&gt;mutableCopy();
 661     copy-&gt;m_shouldUseFixedDefaultFontSize = m_shouldUseFixedDefaultFontSize;
 662     copy-&gt;m_underlineChange = m_underlineChange;
 663     copy-&gt;m_strikeThroughChange = m_strikeThroughChange;
 664     copy-&gt;m_fontSizeDelta = m_fontSizeDelta;
 665     return copy;
 666 }
 667 
 668 Ref&lt;EditingStyle&gt; EditingStyle::extractAndRemoveBlockProperties()
 669 {
 670     auto blockProperties = EditingStyle::create();
 671     if (!m_mutableStyle)
 672         return blockProperties;
 673 
 674     blockProperties-&gt;m_mutableStyle = m_mutableStyle-&gt;copyBlockProperties();
 675     m_mutableStyle-&gt;removeBlockProperties();
 676 
 677     return blockProperties;
 678 }
 679 
 680 Ref&lt;EditingStyle&gt; EditingStyle::extractAndRemoveTextDirection()
 681 {
 682     auto textDirection = EditingStyle::create();
 683     textDirection-&gt;m_mutableStyle = MutableStyleProperties::create();
 684     textDirection-&gt;m_mutableStyle-&gt;setProperty(CSSPropertyUnicodeBidi, CSSValueEmbed, m_mutableStyle-&gt;propertyIsImportant(CSSPropertyUnicodeBidi));
 685     textDirection-&gt;m_mutableStyle-&gt;setProperty(CSSPropertyDirection, m_mutableStyle-&gt;getPropertyValue(CSSPropertyDirection),
 686         m_mutableStyle-&gt;propertyIsImportant(CSSPropertyDirection));
 687 
 688     m_mutableStyle-&gt;removeProperty(CSSPropertyUnicodeBidi);
 689     m_mutableStyle-&gt;removeProperty(CSSPropertyDirection);
 690 
 691     return textDirection;
 692 }
 693 
 694 void EditingStyle::removeBlockProperties()
 695 {
 696     if (!m_mutableStyle)
 697         return;
 698 
 699     m_mutableStyle-&gt;removeBlockProperties();
 700 }
 701 
 702 void EditingStyle::removeStyleAddedByNode(Node* node)
 703 {
 704     if (!node || !node-&gt;parentNode())
 705         return;
 706     RefPtr&lt;MutableStyleProperties&gt; parentStyle = copyPropertiesFromComputedStyle(node-&gt;parentNode(), EditingPropertiesInEffect);
 707     RefPtr&lt;MutableStyleProperties&gt; nodeStyle = copyPropertiesFromComputedStyle(node, EditingPropertiesInEffect);
 708     removeEquivalentProperties(*parentStyle);
 709     removeEquivalentProperties(*nodeStyle);
 710 }
 711 
 712 void EditingStyle::removeStyleConflictingWithStyleOfNode(Node&amp; node)
 713 {
 714     if (!node.parentNode() || !m_mutableStyle)
 715         return;
 716 
 717     RefPtr&lt;MutableStyleProperties&gt; parentStyle = copyPropertiesFromComputedStyle(node.parentNode(), EditingPropertiesInEffect);
 718     auto nodeStyle = EditingStyle::create(&amp;node, EditingPropertiesInEffect);
 719     nodeStyle-&gt;removeEquivalentProperties(*parentStyle);
 720 
 721     MutableStyleProperties* style = nodeStyle-&gt;style();
 722     unsigned propertyCount = style-&gt;propertyCount();
 723     for (unsigned i = 0; i &lt; propertyCount; ++i)
 724         m_mutableStyle-&gt;removeProperty(style-&gt;propertyAt(i).id());
 725 }
 726 
 727 void EditingStyle::collapseTextDecorationProperties()
 728 {
 729     if (!m_mutableStyle)
 730         return;
 731 
 732     RefPtr&lt;CSSValue&gt; textDecorationsInEffect = m_mutableStyle-&gt;getPropertyCSSValue(CSSPropertyWebkitTextDecorationsInEffect);
 733     if (!textDecorationsInEffect)
 734         return;
 735 
 736     if (textDecorationsInEffect-&gt;isValueList())
 737         m_mutableStyle-&gt;setProperty(CSSPropertyTextDecoration, textDecorationsInEffect-&gt;cssText(), m_mutableStyle-&gt;propertyIsImportant(CSSPropertyTextDecoration));
 738     else
 739         m_mutableStyle-&gt;removeProperty(CSSPropertyTextDecoration);
 740     m_mutableStyle-&gt;removeProperty(CSSPropertyWebkitTextDecorationsInEffect);
 741 }
 742 
 743 // CSS properties that create a visual difference only when applied to text.
 744 static const CSSPropertyID textOnlyProperties[] = {
 745     CSSPropertyTextDecoration,
 746     CSSPropertyWebkitTextDecorationsInEffect,
 747     CSSPropertyFontStyle,
 748     CSSPropertyFontWeight,
 749     CSSPropertyColor,
 750 };
 751 
 752 TriState EditingStyle::triStateOfStyle(EditingStyle* style) const
 753 {
 754     if (!style || !style-&gt;m_mutableStyle)
 755         return FalseTriState;
 756     return triStateOfStyle(*style-&gt;m_mutableStyle, DoNotIgnoreTextOnlyProperties);
 757 }
 758 
 759 template&lt;typename T&gt;
 760 TriState EditingStyle::triStateOfStyle(T&amp; styleToCompare, ShouldIgnoreTextOnlyProperties shouldIgnoreTextOnlyProperties) const
 761 {
 762     if (!m_mutableStyle)
 763         return TrueTriState;
 764 
 765     RefPtr&lt;MutableStyleProperties&gt; difference = getPropertiesNotIn(*m_mutableStyle, styleToCompare);
 766 
 767     if (shouldIgnoreTextOnlyProperties == IgnoreTextOnlyProperties)
 768         difference-&gt;removePropertiesInSet(textOnlyProperties, WTF_ARRAY_LENGTH(textOnlyProperties));
 769 
 770     if (difference-&gt;isEmpty())
 771         return TrueTriState;
 772     if (difference-&gt;propertyCount() == m_mutableStyle-&gt;propertyCount())
 773         return FalseTriState;
 774 
 775     return MixedTriState;
 776 }
 777 
 778 TriState EditingStyle::triStateOfStyle(const VisibleSelection&amp; selection) const
 779 {
 780     if (!selection.isCaretOrRange())
 781         return FalseTriState;
 782 
 783     if (selection.isCaret())
 784         return triStateOfStyle(EditingStyle::styleAtSelectionStart(selection).get());
 785 
 786     TriState state = FalseTriState;
 787     bool nodeIsStart = true;
 788     for (Node* node = selection.start().deprecatedNode(); node; node = NodeTraversal::next(*node)) {
 789         if (node-&gt;renderer() &amp;&amp; node-&gt;hasEditableStyle()) {
 790             ComputedStyleExtractor computedStyle(node);
 791             TriState nodeState = triStateOfStyle(computedStyle, node-&gt;isTextNode() ? EditingStyle::DoNotIgnoreTextOnlyProperties : EditingStyle::IgnoreTextOnlyProperties);
 792             if (nodeIsStart) {
 793                 state = nodeState;
 794                 nodeIsStart = false;
 795             } else if (state != nodeState &amp;&amp; node-&gt;isTextNode()) {
 796                 state = MixedTriState;
 797                 break;
 798             }
 799         }
 800 
 801         if (node == selection.end().deprecatedNode())
 802             break;
 803     }
 804 
 805     return state;
 806 }
 807 
 808 static RefPtr&lt;CSSValueList&gt; textDecorationValueList(const StyleProperties&amp; properties)
 809 {
 810     RefPtr&lt;CSSValue&gt; value = properties.getPropertyCSSValue(CSSPropertyTextDecoration);
 811     if (!is&lt;CSSValueList&gt;(value))
 812         return nullptr;
 813     return downcast&lt;CSSValueList&gt;(value.get());
 814 }
 815 
 816 bool EditingStyle::conflictsWithInlineStyleOfElement(StyledElement&amp; element, RefPtr&lt;MutableStyleProperties&gt;* newInlineStylePtr, EditingStyle* extractedStyle) const
 817 {
 818     const StyleProperties* inlineStyle = element.inlineStyle();
 819     if (!inlineStyle)
 820         return false;
 821     bool conflicts = false;
 822     RefPtr&lt;MutableStyleProperties&gt; newInlineStyle;
 823     if (newInlineStylePtr) {
 824         newInlineStyle = inlineStyle-&gt;mutableCopy();
 825         *newInlineStylePtr = newInlineStyle;
 826     }
 827 
 828     bool shouldRemoveUnderline = underlineChange() == TextDecorationChange::Remove;
 829     bool shouldRemoveStrikeThrough = strikeThroughChange() == TextDecorationChange::Remove;
 830     if (shouldRemoveUnderline || shouldRemoveStrikeThrough) {
 831         if (RefPtr&lt;CSSValueList&gt; valueList = textDecorationValueList(*inlineStyle)) {
 832             auto newValueList = valueList-&gt;copy();
 833             auto extractedValueList = CSSValueList::createSpaceSeparated();
 834 
 835             Ref&lt;CSSPrimitiveValue&gt; underline = CSSValuePool::singleton().createIdentifierValue(CSSValueUnderline);
 836             if (shouldRemoveUnderline &amp;&amp; valueList-&gt;hasValue(underline.ptr())) {
 837                 if (!newInlineStyle)
 838                     return true;
 839                 newValueList-&gt;removeAll(underline.ptr());
 840                 extractedValueList-&gt;append(WTFMove(underline));
 841             }
 842 
 843             Ref&lt;CSSPrimitiveValue&gt; lineThrough = CSSValuePool::singleton().createIdentifierValue(CSSValueLineThrough);
 844             if (shouldRemoveStrikeThrough &amp;&amp; valueList-&gt;hasValue(lineThrough.ptr())) {
 845                 if (!newInlineStyle)
 846                     return true;
 847                 newValueList-&gt;removeAll(lineThrough.ptr());
 848                 extractedValueList-&gt;append(WTFMove(lineThrough));
 849             }
 850 
 851             if (extractedValueList-&gt;length()) {
 852                 conflicts = true;
 853                 if (newValueList-&gt;length())
 854                     newInlineStyle-&gt;setProperty(CSSPropertyTextDecoration, WTFMove(newValueList));
 855                 else
 856                     newInlineStyle-&gt;removeProperty(CSSPropertyTextDecoration);
 857 
 858                 if (extractedStyle) {
 859                     bool isImportant = inlineStyle-&gt;propertyIsImportant(CSSPropertyTextDecoration);
 860                     extractedStyle-&gt;setProperty(CSSPropertyTextDecoration, extractedValueList-&gt;cssText(), isImportant);
 861                 }
 862             }
 863         }
 864     }
 865 
 866     unsigned propertyCount = m_mutableStyle ? m_mutableStyle-&gt;propertyCount() : 0;
 867     for (unsigned i = 0; i &lt; propertyCount; ++i) {
 868         CSSPropertyID propertyID = m_mutableStyle-&gt;propertyAt(i).id();
 869 
 870         // We don&#39;t override whitespace property of a tab span because that would collapse the tab into a space.
 871         if (propertyID == CSSPropertyWhiteSpace &amp;&amp; isTabSpanNode(&amp;element))
 872             continue;
 873 
 874         if (propertyID == CSSPropertyWebkitTextDecorationsInEffect &amp;&amp; inlineStyle-&gt;getPropertyCSSValue(CSSPropertyTextDecoration)) {
 875             if (!newInlineStyle)
 876                 return true;
 877             conflicts = true;
 878             newInlineStyle-&gt;removeProperty(CSSPropertyTextDecoration);
 879             if (extractedStyle)
 880                 extractedStyle-&gt;setProperty(CSSPropertyTextDecoration, inlineStyle-&gt;getPropertyValue(CSSPropertyTextDecoration), inlineStyle-&gt;propertyIsImportant(CSSPropertyTextDecoration));
 881         }
 882 
 883         if (!inlineStyle-&gt;getPropertyCSSValue(propertyID))
 884             continue;
 885 
 886         if (propertyID == CSSPropertyUnicodeBidi &amp;&amp; inlineStyle-&gt;getPropertyCSSValue(CSSPropertyDirection)) {
 887             if (!newInlineStyle)
 888                 return true;
 889             conflicts = true;
 890             newInlineStyle-&gt;removeProperty(CSSPropertyDirection);
 891             if (extractedStyle)
 892                 extractedStyle-&gt;setProperty(propertyID, inlineStyle-&gt;getPropertyValue(propertyID), inlineStyle-&gt;propertyIsImportant(propertyID));
 893         }
 894 
 895         if (!newInlineStyle)
 896             return true;
 897 
 898         conflicts = true;
 899         newInlineStyle-&gt;removeProperty(propertyID);
 900         if (extractedStyle)
 901             extractedStyle-&gt;setProperty(propertyID, inlineStyle-&gt;getPropertyValue(propertyID), inlineStyle-&gt;propertyIsImportant(propertyID));
 902     }
 903 
 904     return conflicts;
 905 }
 906 
 907 static const Vector&lt;const HTMLElementEquivalent*&gt;&amp; htmlElementEquivalents()
 908 {
 909     static const auto equivalents = makeNeverDestroyed(Vector&lt;const HTMLElementEquivalent*&gt; {
 910         new HTMLElementEquivalent(CSSPropertyFontWeight, CSSValueBold, HTMLNames::bTag),
 911         new HTMLElementEquivalent(CSSPropertyFontWeight, CSSValueBold, HTMLNames::strongTag),
 912         new HTMLElementEquivalent(CSSPropertyVerticalAlign, CSSValueSub, HTMLNames::subTag),
 913         new HTMLElementEquivalent(CSSPropertyVerticalAlign, CSSValueSuper, HTMLNames::supTag),
 914         new HTMLElementEquivalent(CSSPropertyFontStyle, CSSValueItalic, HTMLNames::iTag),
 915         new HTMLElementEquivalent(CSSPropertyFontStyle, CSSValueItalic, HTMLNames::emTag),
 916 
 917         new HTMLTextDecorationEquivalent(CSSValueUnderline, HTMLNames::uTag),
 918         new HTMLTextDecorationEquivalent(CSSValueLineThrough, HTMLNames::sTag),
 919         new HTMLTextDecorationEquivalent(CSSValueLineThrough, HTMLNames::strikeTag),
 920     });
 921     return equivalents;
 922 }
 923 
 924 
 925 bool EditingStyle::conflictsWithImplicitStyleOfElement(HTMLElement&amp; element, EditingStyle* extractedStyle, ShouldExtractMatchingStyle shouldExtractMatchingStyle) const
 926 {
 927     if (isEmpty())
 928         return false;
 929 
 930     for (auto&amp; equivalent : htmlElementEquivalents()) {
 931         if (equivalent-&gt;matches(element) &amp;&amp; equivalent-&gt;propertyExistsInStyle(*this)
 932             &amp;&amp; (shouldExtractMatchingStyle == ExtractMatchingStyle || !equivalent-&gt;valueIsPresentInStyle(element, *this))) {
 933             if (extractedStyle)
 934                 equivalent-&gt;addToStyle(&amp;element, extractedStyle);
 935             return true;
 936         }
 937     }
 938     return false;
 939 }
 940 
 941 static const Vector&lt;const HTMLAttributeEquivalent*&gt;&amp; htmlAttributeEquivalents()
 942 {
 943     static const auto equivalents = makeNeverDestroyed(Vector&lt;const HTMLAttributeEquivalent*&gt; {
 944         // elementIsStyledSpanOrHTMLEquivalent depends on the fact each HTMLAttriuteEquivalent matches exactly one attribute
 945         // of exactly one element except dirAttr.
 946         new HTMLAttributeEquivalent(CSSPropertyColor, HTMLNames::fontTag, HTMLNames::colorAttr),
 947         new HTMLAttributeEquivalent(CSSPropertyFontFamily, HTMLNames::fontTag, HTMLNames::faceAttr),
 948         new HTMLFontSizeEquivalent,
 949 
 950         new HTMLAttributeEquivalent(CSSPropertyDirection, HTMLNames::dirAttr),
 951         new HTMLAttributeEquivalent(CSSPropertyUnicodeBidi, HTMLNames::dirAttr),
 952     });
 953     return equivalents;
 954 }
 955 
 956 bool EditingStyle::conflictsWithImplicitStyleOfAttributes(HTMLElement&amp; element) const
 957 {
 958     if (isEmpty())
 959         return false;
 960 
 961     for (auto&amp; equivalent : htmlAttributeEquivalents()) {
 962         if (equivalent-&gt;matches(element) &amp;&amp; equivalent-&gt;propertyExistsInStyle(*this) &amp;&amp; !equivalent-&gt;valueIsPresentInStyle(element, *this))
 963             return true;
 964     }
 965 
 966     return false;
 967 }
 968 
 969 bool EditingStyle::extractConflictingImplicitStyleOfAttributes(HTMLElement&amp; element, ShouldPreserveWritingDirection shouldPreserveWritingDirection,
 970     EditingStyle* extractedStyle, Vector&lt;QualifiedName&gt;&amp; conflictingAttributes, ShouldExtractMatchingStyle shouldExtractMatchingStyle) const
 971 {
 972     // HTMLAttributeEquivalent::addToStyle doesn&#39;t support unicode-bidi and direction properties
 973     ASSERT(!extractedStyle || shouldPreserveWritingDirection == PreserveWritingDirection);
 974     if (!m_mutableStyle)
 975         return false;
 976 
 977     bool removed = false;
 978     for (auto&amp; equivalent : htmlAttributeEquivalents()) {
 979         // unicode-bidi and direction are pushed down separately so don&#39;t push down with other styles.
 980         if (shouldPreserveWritingDirection == PreserveWritingDirection &amp;&amp; equivalent-&gt;attributeName() == HTMLNames::dirAttr)
 981             continue;
 982 
 983         if (!equivalent-&gt;matches(element) || !equivalent-&gt;propertyExistsInStyle(*this)
 984             || (shouldExtractMatchingStyle == DoNotExtractMatchingStyle &amp;&amp; equivalent-&gt;valueIsPresentInStyle(element, *this)))
 985             continue;
 986 
 987         if (extractedStyle)
 988             equivalent-&gt;addToStyle(&amp;element, extractedStyle);
 989         conflictingAttributes.append(equivalent-&gt;attributeName());
 990         removed = true;
 991     }
 992 
 993     return removed;
 994 }
 995 
 996 bool EditingStyle::styleIsPresentInComputedStyleOfNode(Node&amp; node) const
 997 {
 998     if (isEmpty())
 999         return true;
1000     ComputedStyleExtractor computedStyle(&amp;node);
1001 
1002     bool shouldAddUnderline = underlineChange() == TextDecorationChange::Add;
1003     bool shouldAddLineThrough = strikeThroughChange() == TextDecorationChange::Add;
1004     if (shouldAddUnderline || shouldAddLineThrough) {
1005         bool hasUnderline = false;
1006         bool hasLineThrough = false;
1007         if (RefPtr&lt;CSSValue&gt; value = computedStyle.propertyValue(CSSPropertyTextDecoration)) {
1008             if (value-&gt;isValueList()) {
1009                 auto&amp; cssValuePool = CSSValuePool::singleton();
1010                 const CSSValueList&amp; valueList = downcast&lt;CSSValueList&gt;(*value);
1011                 hasUnderline = valueList.hasValue(cssValuePool.createIdentifierValue(CSSValueUnderline).ptr());
1012                 hasLineThrough = valueList.hasValue(cssValuePool.createIdentifierValue(CSSValueLineThrough).ptr());
1013             }
1014         }
1015         if ((shouldAddUnderline &amp;&amp; !hasUnderline) || (shouldAddLineThrough &amp;&amp; !hasLineThrough))
1016             return false;
1017     }
1018 
1019     return !m_mutableStyle || getPropertiesNotIn(*m_mutableStyle, computedStyle)-&gt;isEmpty();
1020 }
1021 
1022 bool EditingStyle::elementIsStyledSpanOrHTMLEquivalent(const HTMLElement&amp; element)
1023 {
1024     bool elementIsSpanOrElementEquivalent = false;
1025     if (element.hasTagName(HTMLNames::spanTag))
1026         elementIsSpanOrElementEquivalent = true;
1027     else {
1028         for (auto&amp; equivalent : htmlElementEquivalents()) {
1029             if (equivalent-&gt;matches(element)) {
1030                 elementIsSpanOrElementEquivalent = true;
1031                 break;
1032             }
1033         }
1034     }
1035 
1036     if (!element.hasAttributes())
1037         return elementIsSpanOrElementEquivalent; // span, b, etc... without any attributes
1038 
1039     unsigned matchedAttributes = 0;
1040     for (auto&amp; equivalent : htmlAttributeEquivalents()) {
1041         if (equivalent-&gt;matches(element) &amp;&amp; equivalent-&gt;attributeName() != HTMLNames::dirAttr)
1042             matchedAttributes++;
1043     }
1044 
1045     if (!elementIsSpanOrElementEquivalent &amp;&amp; !matchedAttributes)
1046         return false; // element is not a span, a html element equivalent, or font element.
1047 
1048     if (element.attributeWithoutSynchronization(HTMLNames::classAttr) == AppleStyleSpanClass)
1049         matchedAttributes++;
1050 
1051     if (element.hasAttribute(HTMLNames::styleAttr)) {
1052         if (const StyleProperties* style = element.inlineStyle()) {
1053             unsigned propertyCount = style-&gt;propertyCount();
1054             for (unsigned i = 0; i &lt; propertyCount; ++i) {
1055                 if (!isEditingProperty(style-&gt;propertyAt(i).id()))
1056                     return false;
1057             }
1058         }
1059         matchedAttributes++;
1060     }
1061 
1062     // font with color attribute, span with style attribute, etc...
1063     ASSERT(matchedAttributes &lt;= element.attributeCount());
1064     return matchedAttributes &gt;= element.attributeCount();
1065 }
1066 
1067 void EditingStyle::prepareToApplyAt(const Position&amp; position, ShouldPreserveWritingDirection shouldPreserveWritingDirection)
1068 {
1069     if (!m_mutableStyle)
1070         return;
1071 
1072     // ReplaceSelectionCommand::handleStyleSpans() requires that this function only removes the editing style.
1073     // If this function was modified in the future to delete all redundant properties, then add a boolean value to indicate
1074     // which one of editingStyleAtPosition or computedStyle is called.
1075     auto editingStyleAtPosition = EditingStyle::create(position, EditingPropertiesInEffect);
1076     StyleProperties* styleAtPosition = editingStyleAtPosition-&gt;m_mutableStyle.get();
1077 
1078     RefPtr&lt;CSSValue&gt; unicodeBidi;
1079     RefPtr&lt;CSSValue&gt; direction;
1080     if (shouldPreserveWritingDirection == PreserveWritingDirection) {
1081         unicodeBidi = m_mutableStyle-&gt;getPropertyCSSValue(CSSPropertyUnicodeBidi);
1082         direction = m_mutableStyle-&gt;getPropertyCSSValue(CSSPropertyDirection);
1083     }
1084 
1085     removeEquivalentProperties(*styleAtPosition);
1086 
1087     if (textAlignResolvingStartAndEnd(*m_mutableStyle) == textAlignResolvingStartAndEnd(*styleAtPosition))
1088         m_mutableStyle-&gt;removeProperty(CSSPropertyTextAlign);
1089 
1090     if (equalIgnoringSemanticColor(textColorFromStyle(*m_mutableStyle), textColorFromStyle(*styleAtPosition)))
1091         m_mutableStyle-&gt;removeProperty(CSSPropertyColor);
1092 
1093     if (equalIgnoringSemanticColor(caretColorFromStyle(*m_mutableStyle), caretColorFromStyle(*styleAtPosition)))
1094         m_mutableStyle-&gt;removeProperty(CSSPropertyCaretColor);
1095 
1096     if (hasTransparentBackgroundColor(m_mutableStyle.get())
1097         || cssValueToColor(m_mutableStyle-&gt;getPropertyCSSValue(CSSPropertyBackgroundColor).get()) == rgbaBackgroundColorInEffect(position.containerNode()))
1098         m_mutableStyle-&gt;removeProperty(CSSPropertyBackgroundColor);
1099 
1100     if (is&lt;CSSPrimitiveValue&gt;(unicodeBidi)) {
1101         m_mutableStyle-&gt;setProperty(CSSPropertyUnicodeBidi, static_cast&lt;CSSValueID&gt;(downcast&lt;CSSPrimitiveValue&gt;(*unicodeBidi).valueID()));
1102         if (is&lt;CSSPrimitiveValue&gt;(direction))
1103             m_mutableStyle-&gt;setProperty(CSSPropertyDirection, static_cast&lt;CSSValueID&gt;(downcast&lt;CSSPrimitiveValue&gt;(*direction).valueID()));
1104     }
1105 }
1106 
1107 void EditingStyle::mergeTypingStyle(Document&amp; document)
1108 {
1109     RefPtr&lt;EditingStyle&gt; typingStyle = document.frame()-&gt;selection().typingStyle();
1110     if (!typingStyle || typingStyle == this)
1111         return;
1112 
1113     mergeStyle(typingStyle-&gt;style(), OverrideValues);
1114 }
1115 
1116 void EditingStyle::mergeInlineStyleOfElement(StyledElement&amp; element, CSSPropertyOverrideMode mode, PropertiesToInclude propertiesToInclude)
1117 {
1118     if (!element.inlineStyle())
1119         return;
1120 
1121     switch (propertiesToInclude) {
1122     case AllProperties:
1123         mergeStyle(element.inlineStyle(), mode);
1124         return;
1125     case OnlyEditingInheritableProperties:
1126         mergeStyle(copyEditingProperties(element.inlineStyle(), OnlyInheritableEditingProperties).ptr(), mode);
1127         return;
1128     case EditingPropertiesInEffect:
1129         mergeStyle(copyEditingProperties(element.inlineStyle(), AllEditingProperties).ptr(), mode);
1130         return;
1131     }
1132 }
1133 
1134 static inline bool elementMatchesAndPropertyIsNotInInlineStyleDecl(const HTMLElementEquivalent&amp; equivalent, const StyledElement&amp; element,
1135     EditingStyle::CSSPropertyOverrideMode mode, EditingStyle&amp; style)
1136 {
1137     if (!equivalent.matches(element))
1138         return false;
1139     if (mode != EditingStyle::OverrideValues &amp;&amp; equivalent.propertyExistsInStyle(style))
1140         return false;
1141 
1142     return !element.inlineStyle() || !equivalent.propertyExistsInStyle(EditingStyle::create(element.inlineStyle()).get());
1143 }
1144 
1145 static RefPtr&lt;MutableStyleProperties&gt; extractEditingProperties(const StyleProperties* style, EditingStyle::PropertiesToInclude propertiesToInclude)
1146 {
1147     if (!style)
1148         return nullptr;
1149 
1150     switch (propertiesToInclude) {
1151     case EditingStyle::OnlyEditingInheritableProperties:
1152         return copyEditingProperties(style, OnlyInheritableEditingProperties);
1153     case EditingStyle::AllProperties:
1154     case EditingStyle::EditingPropertiesInEffect:
1155         break;
1156     }
1157     return copyEditingProperties(style, AllEditingProperties);
1158 }
1159 
1160 void EditingStyle::mergeInlineAndImplicitStyleOfElement(StyledElement&amp; element, CSSPropertyOverrideMode mode, PropertiesToInclude propertiesToInclude)
1161 {
1162     auto styleFromRules = EditingStyle::create();
1163     styleFromRules-&gt;mergeStyleFromRulesForSerialization(element);
1164 
1165     if (element.inlineStyle())
1166         styleFromRules-&gt;m_mutableStyle-&gt;mergeAndOverrideOnConflict(*element.inlineStyle());
1167 
1168     styleFromRules-&gt;m_mutableStyle = extractEditingProperties(styleFromRules-&gt;m_mutableStyle.get(), propertiesToInclude);
1169     mergeStyle(styleFromRules-&gt;m_mutableStyle.get(), mode);
1170 
1171     for (auto&amp; equivalent : htmlElementEquivalents()) {
1172         if (elementMatchesAndPropertyIsNotInInlineStyleDecl(*equivalent, element, mode, *this))
1173             equivalent-&gt;addToStyle(&amp;element, this);
1174     }
1175 
1176     for (auto&amp; equivalent : htmlAttributeEquivalents()) {
1177         if (equivalent-&gt;attributeName() == HTMLNames::dirAttr)
1178             continue; // We don&#39;t want to include directionality
1179         if (elementMatchesAndPropertyIsNotInInlineStyleDecl(*equivalent, element, mode, *this))
1180             equivalent-&gt;addToStyle(&amp;element, this);
1181     }
1182 }
1183 
1184 Ref&lt;EditingStyle&gt; EditingStyle::wrappingStyleForSerialization(Node&amp; context, bool shouldAnnotate)
1185 {
1186     if (shouldAnnotate) {
1187         auto wrappingStyle = EditingStyle::create(&amp;context, EditingStyle::EditingPropertiesInEffect);
1188 
1189         // Styles that Mail blockquotes contribute should only be placed on the Mail blockquote,
1190         // to help us differentiate those styles from ones that the user has applied.
1191         // This helps us get the color of content pasted into blockquotes right.
1192         wrappingStyle-&gt;removeStyleAddedByNode(enclosingNodeOfType(firstPositionInOrBeforeNode(&amp;context), isMailBlockquote, CanCrossEditingBoundary));
1193 
1194         // Call collapseTextDecorationProperties first or otherwise it&#39;ll copy the value over from in-effect to text-decorations.
1195         wrappingStyle-&gt;collapseTextDecorationProperties();
1196 
1197         return wrappingStyle;
1198     }
1199 
1200     auto wrappingStyle = EditingStyle::create();
1201 
1202     // When not annotating for interchange, we only preserve inline style declarations.
1203     for (Node* node = &amp;context; node &amp;&amp; !node-&gt;isDocumentNode(); node = node-&gt;parentNode()) {
1204         if (is&lt;StyledElement&gt;(*node) &amp;&amp; !isMailBlockquote(node))
1205             wrappingStyle-&gt;mergeInlineAndImplicitStyleOfElement(downcast&lt;StyledElement&gt;(*node), EditingStyle::DoNotOverrideValues, EditingStyle::EditingPropertiesInEffect);
1206     }
1207 
1208     return wrappingStyle;
1209 }
1210 
1211 
1212 static void mergeTextDecorationValues(CSSValueList&amp; mergedValue, const CSSValueList&amp; valueToMerge)
1213 {
1214     auto&amp; cssValuePool = CSSValuePool::singleton();
1215     Ref&lt;CSSPrimitiveValue&gt; underline = cssValuePool.createIdentifierValue(CSSValueUnderline);
1216     Ref&lt;CSSPrimitiveValue&gt; lineThrough = cssValuePool.createIdentifierValue(CSSValueLineThrough);
1217 
1218     if (valueToMerge.hasValue(underline.ptr()) &amp;&amp; !mergedValue.hasValue(underline.ptr()))
1219         mergedValue.append(WTFMove(underline));
1220 
1221     if (valueToMerge.hasValue(lineThrough.ptr()) &amp;&amp; !mergedValue.hasValue(lineThrough.ptr()))
1222         mergedValue.append(WTFMove(lineThrough));
1223 }
1224 
1225 void EditingStyle::mergeStyle(const StyleProperties* style, CSSPropertyOverrideMode mode)
1226 {
1227     if (!style)
1228         return;
1229 
1230     if (!m_mutableStyle) {
1231         m_mutableStyle = style-&gt;mutableCopy();
1232         return;
1233     }
1234 
1235     unsigned propertyCount = style-&gt;propertyCount();
1236     for (unsigned i = 0; i &lt; propertyCount; ++i) {
1237         StyleProperties::PropertyReference property = style-&gt;propertyAt(i);
1238         RefPtr&lt;CSSValue&gt; value = m_mutableStyle-&gt;getPropertyCSSValue(property.id());
1239 
1240         // text decorations never override values.
1241         if ((property.id() == CSSPropertyTextDecoration || property.id() == CSSPropertyWebkitTextDecorationsInEffect)
1242             &amp;&amp; is&lt;CSSValueList&gt;(*property.value()) &amp;&amp; value) {
1243             if (is&lt;CSSValueList&gt;(*value)) {
1244                 auto newValue = downcast&lt;CSSValueList&gt;(*value).copy();
1245                 mergeTextDecorationValues(newValue, downcast&lt;CSSValueList&gt;(*property.value()));
1246                 m_mutableStyle-&gt;setProperty(property.id(), WTFMove(newValue), property.isImportant());
1247                 continue;
1248             }
1249             value = nullptr; // text-decoration: none is equivalent to not having the property.
1250         }
1251 
1252         if (mode == OverrideValues || (mode == DoNotOverrideValues &amp;&amp; !value))
1253             m_mutableStyle-&gt;setProperty(property.id(), property.value(), property.isImportant());
1254     }
1255 
1256     int oldFontSizeDelta = m_fontSizeDelta;
1257     extractFontSizeDelta();
1258     m_fontSizeDelta += oldFontSizeDelta;
1259 }
1260 
1261 static Ref&lt;MutableStyleProperties&gt; styleFromMatchedRulesForElement(Element&amp; element, unsigned rulesToInclude)
1262 {
1263     auto style = MutableStyleProperties::create();
1264     for (auto&amp; matchedRule : element.styleResolver().styleRulesForElement(&amp;element, rulesToInclude)) {
1265         if (matchedRule-&gt;isStyleRule())
1266             style-&gt;mergeAndOverrideOnConflict(static_pointer_cast&lt;StyleRule&gt;(matchedRule)-&gt;properties());
1267     }
1268 
1269     return style;
1270 }
1271 
1272 void EditingStyle::mergeStyleFromRules(StyledElement&amp; element)
1273 {
1274     RefPtr&lt;MutableStyleProperties&gt; styleFromMatchedRules = styleFromMatchedRulesForElement(element,
1275         StyleResolver::AuthorCSSRules);
1276     // Styles from the inline style declaration, held in the variable &quot;style&quot;, take precedence
1277     // over those from matched rules.
1278     if (m_mutableStyle)
1279         styleFromMatchedRules-&gt;mergeAndOverrideOnConflict(*m_mutableStyle);
1280 
1281     clear();
1282     m_mutableStyle = styleFromMatchedRules;
1283 }
1284 
1285 static bool usesForbiddenSystemFontAsOnlyFontFamilyName(CSSValue&amp; value)
1286 {
1287     if (!is&lt;CSSValueList&gt;(value) || downcast&lt;CSSValueList&gt;(value).length() != 1)
1288         return false;
1289 
1290     auto&amp; item = *downcast&lt;CSSValueList&gt;(value).item(0);
1291     if (!is&lt;CSSPrimitiveValue&gt;(item))
1292         return false;
1293 
1294     auto&amp; primitiveValue = downcast&lt;CSSPrimitiveValue&gt;(item);
1295     if (!primitiveValue.isFontFamily())
1296         return false;
1297     return FontCache::isSystemFontForbiddenForEditing(primitiveValue.fontFamily().familyName);
1298 }
1299 
1300 void EditingStyle::mergeStyleFromRulesForSerialization(StyledElement&amp; element)
1301 {
1302     mergeStyleFromRules(element);
1303 
1304     // The property value, if it&#39;s a percentage, may not reflect the actual computed value.
1305     // For example: style=&quot;height: 1%; overflow: visible;&quot; in quirksmode
1306     // FIXME: There are others like this, see &lt;rdar://problem/5195123&gt; Slashdot copy/paste fidelity problem
1307     auto fromComputedStyle = MutableStyleProperties::create();
1308     ComputedStyleExtractor computedStyle(&amp;element);
1309 
1310     bool shouldRemoveFontFamily = false;
1311     {
1312         unsigned propertyCount = m_mutableStyle-&gt;propertyCount();
1313         for (unsigned i = 0; i &lt; propertyCount; ++i) {
1314             StyleProperties::PropertyReference property = m_mutableStyle-&gt;propertyAt(i);
1315             CSSValue&amp; value = *property.value();
1316             if (property.id() == CSSPropertyFontFamily &amp;&amp; usesForbiddenSystemFontAsOnlyFontFamilyName(value)) {
1317                 shouldRemoveFontFamily = true;
1318                 continue;
1319             }
1320             if (!is&lt;CSSPrimitiveValue&gt;(value))
1321                 continue;
1322             if (downcast&lt;CSSPrimitiveValue&gt;(value).isPercentage()) {
1323                 if (auto computedPropertyValue = computedStyle.propertyValue(property.id()))
1324                     fromComputedStyle-&gt;addParsedProperty(CSSProperty(property.id(), WTFMove(computedPropertyValue)));
1325             }
1326         }
1327     }
1328     if (shouldRemoveFontFamily) {
1329         m_mutableStyle-&gt;removeProperty(CSSPropertyFontFamily);
1330         fromComputedStyle-&gt;removeProperty(CSSPropertyFontFamily);
1331     }
1332     m_mutableStyle-&gt;mergeAndOverrideOnConflict(fromComputedStyle.get());
1333 }
1334 
1335 static void removePropertiesInStyle(MutableStyleProperties* styleToRemovePropertiesFrom, MutableStyleProperties* style)
1336 {
1337     unsigned propertyCount = style-&gt;propertyCount();
1338     Vector&lt;CSSPropertyID&gt; propertiesToRemove(propertyCount);
1339     for (unsigned i = 0; i &lt; propertyCount; ++i)
1340         propertiesToRemove[i] = style-&gt;propertyAt(i).id();
1341 
1342     styleToRemovePropertiesFrom-&gt;removePropertiesInSet(propertiesToRemove.data(), propertiesToRemove.size());
1343 }
1344 
1345 void EditingStyle::removeStyleFromRulesAndContext(StyledElement&amp; element, Node* context)
1346 {
1347     if (!m_mutableStyle)
1348         return;
1349 
1350     // 1. Remove style from matched rules because style remain without repeating it in inline style declaration
1351     RefPtr&lt;MutableStyleProperties&gt; styleFromMatchedRules = styleFromMatchedRulesForElement(element, StyleResolver::AllButEmptyCSSRules);
1352     if (styleFromMatchedRules &amp;&amp; !styleFromMatchedRules-&gt;isEmpty())
1353         m_mutableStyle = getPropertiesNotIn(*m_mutableStyle, *styleFromMatchedRules);
1354 
1355     // 2. Remove style present in context and not overridden by matched rules.
1356     auto computedStyle = EditingStyle::create(context, EditingPropertiesInEffect);
1357     if (computedStyle-&gt;m_mutableStyle) {
1358         if (!computedStyle-&gt;m_mutableStyle-&gt;getPropertyCSSValue(CSSPropertyBackgroundColor))
1359             computedStyle-&gt;m_mutableStyle-&gt;setProperty(CSSPropertyBackgroundColor, CSSValueTransparent);
1360 
1361         removePropertiesInStyle(computedStyle-&gt;m_mutableStyle.get(), styleFromMatchedRules.get());
1362         m_mutableStyle = getPropertiesNotIn(*m_mutableStyle, *computedStyle-&gt;m_mutableStyle);
1363     }
1364 
1365     // 3. If this element is a span and has display: inline or float: none, remove them unless they are overridden by rules.
1366     // These rules are added by serialization code to wrap text nodes.
1367     if (isStyleSpanOrSpanWithOnlyStyleAttribute(element)) {
1368         if (!styleFromMatchedRules-&gt;getPropertyCSSValue(CSSPropertyDisplay) &amp;&amp; identifierForStyleProperty(*m_mutableStyle, CSSPropertyDisplay) == CSSValueInline)
1369             m_mutableStyle-&gt;removeProperty(CSSPropertyDisplay);
1370         if (!styleFromMatchedRules-&gt;getPropertyCSSValue(CSSPropertyFloat) &amp;&amp; identifierForStyleProperty(*m_mutableStyle, CSSPropertyFloat) == CSSValueNone)
1371             m_mutableStyle-&gt;removeProperty(CSSPropertyFloat);
1372     }
1373 }
1374 
1375 void EditingStyle::removePropertiesInElementDefaultStyle(Element&amp; element)
1376 {
1377     if (!m_mutableStyle || m_mutableStyle-&gt;isEmpty())
1378         return;
1379 
1380     RefPtr&lt;MutableStyleProperties&gt; defaultStyle = styleFromMatchedRulesForElement(element, StyleResolver::UAAndUserCSSRules);
1381 
1382     removePropertiesInStyle(m_mutableStyle.get(), defaultStyle.get());
1383 }
1384 
1385 template&lt;typename T&gt;
1386 void EditingStyle::removeEquivalentProperties(T&amp; style)
1387 {
1388     Vector&lt;CSSPropertyID&gt; propertiesToRemove;
1389     for (auto&amp; property : m_mutableStyle-&gt;m_propertyVector) {
1390         if (style.propertyMatches(property.id(), property.value()))
1391             propertiesToRemove.append(property.id());
1392     }
1393     // FIXME: This should use mass removal.
1394     for (auto&amp; property : propertiesToRemove)
1395         m_mutableStyle-&gt;removeProperty(property);
1396 }
1397 
1398 void EditingStyle::forceInline()
1399 {
1400     if (!m_mutableStyle)
1401         m_mutableStyle = MutableStyleProperties::create();
1402     const bool propertyIsImportant = true;
1403     m_mutableStyle-&gt;setProperty(CSSPropertyDisplay, CSSValueInline, propertyIsImportant);
1404 }
1405 
1406 void EditingStyle::addDisplayContents()
1407 {
1408     if (!m_mutableStyle)
1409         m_mutableStyle = MutableStyleProperties::create();
1410     m_mutableStyle-&gt;setProperty(CSSPropertyDisplay, CSSValueContents);
1411 }
1412 
1413 bool EditingStyle::convertPositionStyle()
1414 {
1415     if (!m_mutableStyle)
1416         return false;
1417 
1418     auto&amp; cssValuePool = CSSValuePool::singleton();
1419     RefPtr&lt;CSSPrimitiveValue&gt; sticky = cssValuePool.createIdentifierValue(CSSValueSticky);
1420     if (m_mutableStyle-&gt;propertyMatches(CSSPropertyPosition, sticky.get())) {
1421         m_mutableStyle-&gt;setProperty(CSSPropertyPosition, cssValuePool.createIdentifierValue(CSSValueStatic), m_mutableStyle-&gt;propertyIsImportant(CSSPropertyPosition));
1422         return false;
1423     }
1424     RefPtr&lt;CSSPrimitiveValue&gt; fixed = cssValuePool.createIdentifierValue(CSSValueFixed);
1425     if (m_mutableStyle-&gt;propertyMatches(CSSPropertyPosition, fixed.get())) {
1426         m_mutableStyle-&gt;setProperty(CSSPropertyPosition, cssValuePool.createIdentifierValue(CSSValueAbsolute), m_mutableStyle-&gt;propertyIsImportant(CSSPropertyPosition));
1427         return true;
1428     }
1429     RefPtr&lt;CSSPrimitiveValue&gt; absolute = cssValuePool.createIdentifierValue(CSSValueAbsolute);
1430     if (m_mutableStyle-&gt;propertyMatches(CSSPropertyPosition, absolute.get()))
1431         return true;
1432     return false;
1433 }
1434 
1435 bool EditingStyle::isFloating()
1436 {
1437     RefPtr&lt;CSSValue&gt; v = m_mutableStyle-&gt;getPropertyCSSValue(CSSPropertyFloat);
1438     RefPtr&lt;CSSPrimitiveValue&gt; noneValue = CSSValuePool::singleton().createIdentifierValue(CSSValueNone);
1439     return v &amp;&amp; !v-&gt;equals(*noneValue);
1440 }
1441 
1442 int EditingStyle::legacyFontSize(Document&amp; document) const
1443 {
1444     RefPtr&lt;CSSValue&gt; cssValue = m_mutableStyle-&gt;getPropertyCSSValue(CSSPropertyFontSize);
1445     if (!is&lt;CSSPrimitiveValue&gt;(cssValue))
1446         return 0;
1447     return legacyFontSizeFromCSSValue(document, downcast&lt;CSSPrimitiveValue&gt;(cssValue.get()),
1448         m_shouldUseFixedDefaultFontSize, AlwaysUseLegacyFontSize);
1449 }
1450 
1451 bool EditingStyle::hasStyle(CSSPropertyID propertyID, const String&amp; value)
1452 {
1453     return EditingStyle::create(propertyID, value)-&gt;triStateOfStyle(this) != FalseTriState;
1454 }
1455 
1456 RefPtr&lt;EditingStyle&gt; EditingStyle::styleAtSelectionStart(const VisibleSelection&amp; selection, bool shouldUseBackgroundColorInEffect)
1457 {
1458     if (selection.isNone())
1459         return nullptr;
1460 
1461     Position position = adjustedSelectionStartForStyleComputation(selection);
1462 
1463     // If the pos is at the end of a text node, then this node is not fully selected.
1464     // Move it to the next deep equivalent position to avoid removing the style from this node.
1465     // e.g. if pos was at Position(&quot;hello&quot;, 5) in &lt;b&gt;hello&lt;div&gt;world&lt;/div&gt;&lt;/b&gt;, we want Position(&quot;world&quot;, 0) instead.
1466     // We only do this for range because caret at Position(&quot;hello&quot;, 5) in &lt;b&gt;hello&lt;/b&gt;world should give you font-weight: bold.
1467     Node* positionNode = position.containerNode();
1468     if (selection.isRange() &amp;&amp; positionNode &amp;&amp; positionNode-&gt;isTextNode() &amp;&amp; position.computeOffsetInContainerNode() == positionNode-&gt;maxCharacterOffset())
1469         position = nextVisuallyDistinctCandidate(position);
1470 
1471     Element* element = position.element();
1472     if (!element)
1473         return nullptr;
1474 
1475     auto style = EditingStyle::create(element, EditingStyle::AllProperties);
1476     style-&gt;mergeTypingStyle(element-&gt;document());
1477 
1478     // If background color is transparent, traverse parent nodes until we hit a different value or document root
1479     // Also, if the selection is a range, ignore the background color at the start of selection,
1480     // and find the background color of the common ancestor.
1481     if (shouldUseBackgroundColorInEffect &amp;&amp; (selection.isRange() || hasTransparentBackgroundColor(style-&gt;m_mutableStyle.get()))) {
1482         if (auto range = selection.toNormalizedRange()) {
1483             if (auto value = backgroundColorInEffect(range-&gt;commonAncestorContainer()))
1484                 style-&gt;setProperty(CSSPropertyBackgroundColor, value-&gt;cssText());
1485         }
1486     }
1487 
1488     return style;
1489 }
1490 
1491 WritingDirection EditingStyle::textDirectionForSelection(const VisibleSelection&amp; selection, EditingStyle* typingStyle, bool&amp; hasNestedOrMultipleEmbeddings)
1492 {
1493     hasNestedOrMultipleEmbeddings = true;
1494 
1495     if (selection.isNone())
1496         return WritingDirection::Natural;
1497 
1498     Position position = selection.start().downstream();
1499 
1500     Node* node = position.deprecatedNode();
1501     if (!node)
1502         return WritingDirection::Natural;
1503 
1504     Position end;
1505     if (selection.isRange()) {
1506         end = selection.end().upstream();
1507 
1508         Node* pastLast = Range::create(*end.document(), position.parentAnchoredEquivalent(), end.parentAnchoredEquivalent())-&gt;pastLastNode();
1509         for (Node* n = node; n &amp;&amp; n != pastLast; n = NodeTraversal::next(*n)) {
1510             if (!n-&gt;isStyledElement())
1511                 continue;
1512 
1513             RefPtr&lt;CSSValue&gt; unicodeBidi = ComputedStyleExtractor(n).propertyValue(CSSPropertyUnicodeBidi);
1514             if (!is&lt;CSSPrimitiveValue&gt;(unicodeBidi))
1515                 continue;
1516 
1517             CSSValueID unicodeBidiValue = downcast&lt;CSSPrimitiveValue&gt;(*unicodeBidi).valueID();
1518             if (unicodeBidiValue == CSSValueEmbed || unicodeBidiValue == CSSValueBidiOverride)
1519                 return WritingDirection::Natural;
1520         }
1521     }
1522 
1523     if (selection.isCaret()) {
1524         if (typingStyle) {
1525             if (auto direction = typingStyle-&gt;textDirection()) {
1526                 hasNestedOrMultipleEmbeddings = false;
1527                 return *direction;
1528             }
1529         }
1530         node = selection.visibleStart().deepEquivalent().deprecatedNode();
1531     }
1532 
1533     // The selection is either a caret with no typing attributes or a range in which no embedding is added, so just use the start position
1534     // to decide.
1535     Node* block = enclosingBlock(node);
1536     auto foundDirection = WritingDirection::Natural;
1537 
1538     for (; node != block; node = node-&gt;parentNode()) {
1539         if (!node-&gt;isStyledElement())
1540             continue;
1541 
1542         ComputedStyleExtractor computedStyle(node);
1543         RefPtr&lt;CSSValue&gt; unicodeBidi = computedStyle.propertyValue(CSSPropertyUnicodeBidi);
1544         if (!is&lt;CSSPrimitiveValue&gt;(unicodeBidi))
1545             continue;
1546 
1547         CSSValueID unicodeBidiValue = downcast&lt;CSSPrimitiveValue&gt;(*unicodeBidi).valueID();
1548         if (unicodeBidiValue == CSSValueNormal)
1549             continue;
1550 
1551         if (unicodeBidiValue == CSSValueBidiOverride)
1552             return WritingDirection::Natural;
1553 
1554         ASSERT(unicodeBidiValue == CSSValueEmbed);
1555         RefPtr&lt;CSSValue&gt; direction = computedStyle.propertyValue(CSSPropertyDirection);
1556         if (!is&lt;CSSPrimitiveValue&gt;(direction))
1557             continue;
1558 
1559         CSSValueID directionValue = downcast&lt;CSSPrimitiveValue&gt;(*direction).valueID();
1560         if (directionValue != CSSValueLtr &amp;&amp; directionValue != CSSValueRtl)
1561             continue;
1562 
1563         if (foundDirection != WritingDirection::Natural)
1564             return WritingDirection::Natural;
1565 
1566         // In the range case, make sure that the embedding element persists until the end of the range.
1567         if (selection.isRange() &amp;&amp; !end.deprecatedNode()-&gt;isDescendantOf(*node))
1568             return WritingDirection::Natural;
1569 
1570         foundDirection = directionValue == CSSValueLtr ? WritingDirection::LeftToRight : WritingDirection::RightToLeft;
1571     }
1572     hasNestedOrMultipleEmbeddings = false;
1573     return foundDirection;
1574 }
1575 
1576 Ref&lt;EditingStyle&gt; EditingStyle::inverseTransformColorIfNeeded(Element&amp; element)
1577 {
1578     auto* renderer = element.renderer();
1579     if (!m_mutableStyle || !renderer || !renderer-&gt;style().hasAppleColorFilter())
1580         return *this;
1581 
1582     bool hasColor = m_mutableStyle-&gt;getPropertyCSSValue(CSSPropertyColor);
1583     bool hasBackgroundColor = m_mutableStyle-&gt;getPropertyCSSValue(CSSPropertyBackgroundColor);
1584     if (!hasColor &amp;&amp; !hasBackgroundColor)
1585         return *this;
1586 
1587     auto styleWithInvertedColors = copy();
1588     ASSERT(styleWithInvertedColors-&gt;m_mutableStyle);
1589 
1590     const auto&amp; colorFilter = renderer-&gt;style().appleColorFilter();
1591     auto invertedColor = [&amp;](CSSPropertyID propertyID) {
1592         Color newColor = cssValueToColor(extractPropertyValue(*m_mutableStyle, propertyID).get());
1593         colorFilter.inverseTransformColor(newColor);
1594         styleWithInvertedColors-&gt;m_mutableStyle-&gt;setProperty(propertyID, newColor.cssText());
1595     };
1596 
1597     if (hasColor)
1598         invertedColor(CSSPropertyColor);
1599 
1600     if (hasBackgroundColor)
1601         invertedColor(CSSPropertyBackgroundColor);
1602 
1603     return styleWithInvertedColors;
1604 }
1605 
1606 static void reconcileTextDecorationProperties(MutableStyleProperties* style)
1607 {
1608     RefPtr&lt;CSSValue&gt; textDecorationsInEffect = style-&gt;getPropertyCSSValue(CSSPropertyWebkitTextDecorationsInEffect);
1609     RefPtr&lt;CSSValue&gt; textDecoration = style-&gt;getPropertyCSSValue(CSSPropertyTextDecoration);
1610     // We shouldn&#39;t have both text-decoration and -webkit-text-decorations-in-effect because that wouldn&#39;t make sense.
1611     ASSERT(!textDecorationsInEffect || !textDecoration);
1612     if (textDecorationsInEffect) {
1613         style-&gt;setProperty(CSSPropertyTextDecoration, textDecorationsInEffect-&gt;cssText());
1614         style-&gt;removeProperty(CSSPropertyWebkitTextDecorationsInEffect);
1615         textDecoration = textDecorationsInEffect;
1616     }
1617 
1618     // If text-decoration is set to &quot;none&quot;, remove the property because we don&#39;t want to add redundant &quot;text-decoration: none&quot;.
1619     if (textDecoration &amp;&amp; !textDecoration-&gt;isValueList())
1620         style-&gt;removeProperty(CSSPropertyTextDecoration);
1621 }
1622 
1623 StyleChange::StyleChange(EditingStyle* style, const Position&amp; position)
1624     : m_applyBold(false)
1625     , m_applyItalic(false)
1626     , m_applyUnderline(false)
1627     , m_applyLineThrough(false)
1628     , m_applySubscript(false)
1629     , m_applySuperscript(false)
1630 {
1631     Document* document = position.deprecatedNode() ? &amp;position.deprecatedNode()-&gt;document() : 0;
1632     if (!style || style-&gt;isEmpty() || !document || !document-&gt;frame())
1633         return;
1634 
1635     Node* node = position.containerNode();
1636     if (!node)
1637         return;
1638 
1639     ComputedStyleExtractor computedStyle(node);
1640 
1641     // FIXME: take care of background-color in effect
1642     RefPtr&lt;MutableStyleProperties&gt; mutableStyle = style-&gt;style() ?
1643         getPropertiesNotIn(*style-&gt;style(), computedStyle) : MutableStyleProperties::create();
1644 
1645     reconcileTextDecorationProperties(mutableStyle.get());
1646     bool shouldStyleWithCSS = document-&gt;frame()-&gt;editor().shouldStyleWithCSS();
1647     if (!shouldStyleWithCSS)
1648         extractTextStyles(*document, *mutableStyle, computedStyle.useFixedFontDefaultSize());
1649 
1650     bool shouldAddUnderline = style-&gt;underlineChange() == TextDecorationChange::Add;
1651     bool shouldAddStrikeThrough = style-&gt;strikeThroughChange() == TextDecorationChange::Add;
1652     if (shouldAddUnderline || shouldAddStrikeThrough) {
1653         RefPtr&lt;CSSValue&gt; value = computedStyle.propertyValue(CSSPropertyWebkitTextDecorationsInEffect);
1654         if (!is&lt;CSSValueList&gt;(value))
1655             value = computedStyle.propertyValue(CSSPropertyTextDecoration);
1656 
1657         RefPtr&lt;CSSValueList&gt; valueList;
1658         if (is&lt;CSSValueList&gt;(value))
1659             valueList = downcast&lt;CSSValueList&gt;(value.get());
1660 
1661         auto&amp; cssValuePool = CSSValuePool::singleton();
1662         Ref&lt;CSSValue&gt; underline = cssValuePool.createIdentifierValue(CSSValueUnderline);
1663         bool hasUnderline = valueList &amp;&amp; valueList-&gt;hasValue(underline.ptr());
1664 
1665         Ref&lt;CSSValue&gt; lineThrough = cssValuePool.createIdentifierValue(CSSValueLineThrough);
1666         bool hasLineThrough = valueList &amp;&amp; valueList-&gt;hasValue(lineThrough.ptr());
1667 
1668         if (shouldStyleWithCSS) {
1669             valueList = valueList ? valueList-&gt;copy() : CSSValueList::createSpaceSeparated();
1670             if (shouldAddUnderline &amp;&amp; !hasUnderline)
1671                 valueList-&gt;append(WTFMove(underline));
1672             if (shouldAddStrikeThrough &amp;&amp; !hasLineThrough)
1673                 valueList-&gt;append(WTFMove(lineThrough));
1674             mutableStyle-&gt;setProperty(CSSPropertyTextDecoration, valueList.get());
1675         } else {
1676             m_applyUnderline = shouldAddUnderline &amp;&amp; !hasUnderline;
1677             m_applyLineThrough = shouldAddStrikeThrough &amp;&amp; !hasLineThrough;
1678         }
1679     }
1680 
1681     // Changing the whitespace style in a tab span would collapse the tab into a space.
1682     if (isTabSpanTextNode(position.deprecatedNode()) || isTabSpanNode((position.deprecatedNode())))
1683         mutableStyle-&gt;removeProperty(CSSPropertyWhiteSpace);
1684 
1685     // If unicode-bidi is present in mutableStyle and direction is not, then add direction to mutableStyle.
1686     // FIXME: Shouldn&#39;t this be done in getPropertiesNotIn?
1687     if (mutableStyle-&gt;getPropertyCSSValue(CSSPropertyUnicodeBidi) &amp;&amp; !style-&gt;style()-&gt;getPropertyCSSValue(CSSPropertyDirection))
1688         mutableStyle-&gt;setProperty(CSSPropertyDirection, style-&gt;style()-&gt;getPropertyValue(CSSPropertyDirection));
1689 
1690     if (!mutableStyle-&gt;isEmpty())
1691         m_cssStyle = mutableStyle;
1692 }
1693 
1694 bool StyleChange::operator==(const StyleChange&amp; other)
1695 {
1696     if (m_applyBold != other.m_applyBold
1697         || m_applyItalic != other.m_applyItalic
1698         || m_applyUnderline != other.m_applyUnderline
1699         || m_applyLineThrough != other.m_applyLineThrough
1700         || m_applySubscript != other.m_applySubscript
1701         || m_applySuperscript != other.m_applySuperscript
1702         || m_applyFontColor != other.m_applyFontColor
1703         || m_applyFontFace != other.m_applyFontFace
1704         || m_applyFontSize != other.m_applyFontSize)
1705         return false;
1706 
1707     return (!m_cssStyle &amp;&amp; !other.m_cssStyle)
1708         || (m_cssStyle &amp;&amp; other.m_cssStyle &amp;&amp; m_cssStyle-&gt;asText() == other.m_cssStyle-&gt;asText());
1709 }
1710 
1711 static void setTextDecorationProperty(MutableStyleProperties&amp; style, const CSSValueList* newTextDecoration, CSSPropertyID propertyID)
1712 {
1713     if (newTextDecoration-&gt;length())
1714         style.setProperty(propertyID, newTextDecoration-&gt;cssText(), style.propertyIsImportant(propertyID));
1715     else {
1716         // text-decoration: none is redundant since it does not remove any text decorations.
1717         style.removeProperty(propertyID);
1718     }
1719 }
1720 
1721 void StyleChange::extractTextStyles(Document&amp; document, MutableStyleProperties&amp; style, bool shouldUseFixedFontDefaultSize)
1722 {
1723     if (identifierForStyleProperty(style, CSSPropertyFontWeight) == CSSValueBold) {
1724         style.removeProperty(CSSPropertyFontWeight);
1725         m_applyBold = true;
1726     }
1727 
1728     int fontStyle = identifierForStyleProperty(style, CSSPropertyFontStyle);
1729     if (fontStyle == CSSValueItalic || fontStyle == CSSValueOblique) {
1730         style.removeProperty(CSSPropertyFontStyle);
1731         m_applyItalic = true;
1732     }
1733 
1734     // Assuming reconcileTextDecorationProperties has been called, there should not be -webkit-text-decorations-in-effect
1735     // Furthermore, text-decoration: none has been trimmed so that text-decoration property is always a CSSValueList.
1736     RefPtr&lt;CSSValue&gt; textDecoration = style.getPropertyCSSValue(CSSPropertyTextDecoration);
1737     if (is&lt;CSSValueList&gt;(textDecoration)) {
1738         auto&amp; cssValuePool = CSSValuePool::singleton();
1739         RefPtr&lt;CSSPrimitiveValue&gt; underline = cssValuePool.createIdentifierValue(CSSValueUnderline);
1740         RefPtr&lt;CSSPrimitiveValue&gt; lineThrough = cssValuePool.createIdentifierValue(CSSValueLineThrough);
1741 
1742         RefPtr&lt;CSSValueList&gt; newTextDecoration = downcast&lt;CSSValueList&gt;(*textDecoration).copy();
1743         if (newTextDecoration-&gt;removeAll(underline.get()))
1744             m_applyUnderline = true;
1745         if (newTextDecoration-&gt;removeAll(lineThrough.get()))
1746             m_applyLineThrough = true;
1747 
1748         // If trimTextDecorations, delete underline and line-through
1749         setTextDecorationProperty(style, newTextDecoration.get(), CSSPropertyTextDecoration);
1750     }
1751 
1752     int verticalAlign = identifierForStyleProperty(style, CSSPropertyVerticalAlign);
1753     switch (verticalAlign) {
1754     case CSSValueSub:
1755         style.removeProperty(CSSPropertyVerticalAlign);
1756         m_applySubscript = true;
1757         break;
1758     case CSSValueSuper:
1759         style.removeProperty(CSSPropertyVerticalAlign);
1760         m_applySuperscript = true;
1761         break;
1762     }
1763 
1764     if (style.getPropertyCSSValue(CSSPropertyColor)) {
1765         auto color = textColorFromStyle(style);
1766         if (color.isOpaque()) {
1767             m_applyFontColor = color.serialized();
1768             style.removeProperty(CSSPropertyColor);
1769         }
1770     }
1771 
1772     m_applyFontFace = style.getPropertyValue(CSSPropertyFontFamily);
1773     // Remove quotes for Outlook 2007 compatibility. See https://bugs.webkit.org/show_bug.cgi?id=79448
1774     m_applyFontFace.replaceWithLiteral(&#39;\&quot;&#39;, &quot;&quot;);
1775     style.removeProperty(CSSPropertyFontFamily);
1776 
1777     if (RefPtr&lt;CSSValue&gt; fontSize = style.getPropertyCSSValue(CSSPropertyFontSize)) {
1778         if (!is&lt;CSSPrimitiveValue&gt;(*fontSize))
1779             style.removeProperty(CSSPropertyFontSize); // Can&#39;t make sense of the number. Put no font size.
1780         else if (int legacyFontSize = legacyFontSizeFromCSSValue(document, downcast&lt;CSSPrimitiveValue&gt;(fontSize.get()),
1781                 shouldUseFixedFontDefaultSize, UseLegacyFontSizeOnlyIfPixelValuesMatch)) {
1782             m_applyFontSize = String::number(legacyFontSize);
1783             style.removeProperty(CSSPropertyFontSize);
1784         }
1785     }
1786 }
1787 
1788 static void diffTextDecorations(MutableStyleProperties&amp; style, CSSPropertyID propertID, CSSValue* refTextDecoration)
1789 {
1790     RefPtr&lt;CSSValue&gt; textDecoration = style.getPropertyCSSValue(propertID);
1791     if (!is&lt;CSSValueList&gt;(textDecoration) || !is&lt;CSSValueList&gt;(refTextDecoration))
1792         return;
1793 
1794     RefPtr&lt;CSSValueList&gt; newTextDecoration = downcast&lt;CSSValueList&gt;(*textDecoration).copy();
1795 
1796     for (auto&amp; value :  downcast&lt;CSSValueList&gt;(*refTextDecoration))
1797         newTextDecoration-&gt;removeAll(&amp;value.get());
1798 
1799     setTextDecorationProperty(style, newTextDecoration.get(), propertID);
1800 }
1801 
1802 static bool fontWeightIsBold(CSSValue&amp; fontWeight)
1803 {
1804     if (!is&lt;CSSPrimitiveValue&gt;(fontWeight))
1805         return false;
1806 
1807     auto&amp; primitiveValue = downcast&lt;CSSPrimitiveValue&gt;(fontWeight);
1808     switch (primitiveValue.valueID()) {
1809         case CSSValueNormal:
1810             return false;
1811         case CSSValueBold:
1812             return true;
1813         default:
1814             break;
1815     }
1816 
1817     ASSERT(primitiveValue.isNumber());
1818     return primitiveValue.floatValue() &gt;= static_cast&lt;float&gt;(boldThreshold());
1819 }
1820 
1821 template&lt;typename T&gt;
1822 static bool fontWeightIsBold(T&amp; style)
1823 {
1824     RefPtr&lt;CSSValue&gt; fontWeight = extractPropertyValue(style, CSSPropertyFontWeight);
1825     return fontWeight &amp;&amp; fontWeightIsBold(*fontWeight);
1826 }
1827 
1828 template&lt;typename T&gt;
1829 static Ref&lt;MutableStyleProperties&gt; extractPropertiesNotIn(StyleProperties&amp; styleWithRedundantProperties, T&amp; baseStyle)
1830 {
1831     auto result = EditingStyle::create(&amp;styleWithRedundantProperties);
1832     result-&gt;removeEquivalentProperties(baseStyle);
1833     ASSERT(result-&gt;style());
1834     Ref&lt;MutableStyleProperties&gt; mutableStyle = *result-&gt;style();
1835 
1836     RefPtr&lt;CSSValue&gt; baseTextDecorationsInEffect = extractPropertyValue(baseStyle, CSSPropertyWebkitTextDecorationsInEffect);
1837     diffTextDecorations(mutableStyle, CSSPropertyTextDecoration, baseTextDecorationsInEffect.get());
1838     diffTextDecorations(mutableStyle, CSSPropertyWebkitTextDecorationsInEffect, baseTextDecorationsInEffect.get());
1839 
1840     if (extractPropertyValue(baseStyle, CSSPropertyFontWeight) &amp;&amp; fontWeightIsBold(mutableStyle) == fontWeightIsBold(baseStyle))
1841         mutableStyle-&gt;removeProperty(CSSPropertyFontWeight);
1842 
1843     if (extractPropertyValue(baseStyle, CSSPropertyColor) &amp;&amp; equalIgnoringSemanticColor(textColorFromStyle(mutableStyle), textColorFromStyle(baseStyle)))
1844         mutableStyle-&gt;removeProperty(CSSPropertyColor);
1845 
1846     if (extractPropertyValue(baseStyle, CSSPropertyCaretColor) &amp;&amp; equalIgnoringSemanticColor(caretColorFromStyle(mutableStyle), caretColorFromStyle(baseStyle)))
1847         mutableStyle-&gt;removeProperty(CSSPropertyCaretColor);
1848 
1849     if (extractPropertyValue(baseStyle, CSSPropertyTextAlign)
1850         &amp;&amp; textAlignResolvingStartAndEnd(mutableStyle) == textAlignResolvingStartAndEnd(baseStyle))
1851         mutableStyle-&gt;removeProperty(CSSPropertyTextAlign);
1852 
1853     if (extractPropertyValue(baseStyle, CSSPropertyBackgroundColor) &amp;&amp; equalIgnoringSemanticColor(backgroundColorFromStyle(mutableStyle), backgroundColorFromStyle(baseStyle)))
1854         mutableStyle-&gt;removeProperty(CSSPropertyBackgroundColor);
1855 
1856     return mutableStyle;
1857 }
1858 
1859 template&lt;typename T&gt;
1860 Ref&lt;MutableStyleProperties&gt; getPropertiesNotIn(StyleProperties&amp; styleWithRedundantProperties, T&amp; baseStyle)
1861 {
1862     return extractPropertiesNotIn(styleWithRedundantProperties, baseStyle);
1863 }
1864 
1865 static bool isCSSValueLength(CSSPrimitiveValue* value)
1866 {
1867     return value-&gt;isFontIndependentLength();
1868 }
1869 
1870 int legacyFontSizeFromCSSValue(Document&amp; document, CSSPrimitiveValue* value, bool shouldUseFixedFontDefaultSize, LegacyFontSizeMode mode)
1871 {
1872     if (isCSSValueLength(value)) {
1873         int pixelFontSize = value-&gt;intValue(CSSPrimitiveValue::CSS_PX);
1874         int legacyFontSize = Style::legacyFontSizeForPixelSize(pixelFontSize, shouldUseFixedFontDefaultSize, document);
1875         // Use legacy font size only if pixel value matches exactly to that of legacy font size.
1876         int cssPrimitiveEquivalent = legacyFontSize - 1 + CSSValueXSmall;
1877         if (mode == AlwaysUseLegacyFontSize || Style::fontSizeForKeyword(cssPrimitiveEquivalent, shouldUseFixedFontDefaultSize, document) == pixelFontSize)
1878             return legacyFontSize;
1879 
1880         return 0;
1881     }
1882 
1883     if (CSSValueXSmall &lt;= value-&gt;valueID() &amp;&amp; value-&gt;valueID() &lt;= CSSValueWebkitXxxLarge)
1884         return value-&gt;valueID() - CSSValueXSmall + 1;
1885 
1886     return 0;
1887 }
1888 
1889 static bool isTransparentColorValue(CSSValue* value)
1890 {
1891     if (!value)
1892         return true;
1893     if (!is&lt;CSSPrimitiveValue&gt;(*value))
1894         return false;
1895     auto&amp; primitiveValue = downcast&lt;CSSPrimitiveValue&gt;(*value);
1896     if (primitiveValue.isRGBColor())
1897         return !primitiveValue.color().isVisible();
1898     return primitiveValue.valueID() == CSSValueTransparent;
1899 }
1900 
1901 bool hasTransparentBackgroundColor(StyleProperties* style)
1902 {
1903     return isTransparentColorValue(style-&gt;getPropertyCSSValue(CSSPropertyBackgroundColor).get());
1904 }
1905 
1906 RefPtr&lt;CSSValue&gt; backgroundColorInEffect(Node* node)
1907 {
1908     for (Node* ancestor = node; ancestor; ancestor = ancestor-&gt;parentNode()) {
1909         if (auto value = ComputedStyleExtractor(ancestor).propertyValue(CSSPropertyBackgroundColor)) {
1910             if (!isTransparentColorValue(value.get()))
1911                 return value;
1912         }
1913     }
1914     return nullptr;
1915 }
1916 
1917 }
    </pre>
  </body>
</html>