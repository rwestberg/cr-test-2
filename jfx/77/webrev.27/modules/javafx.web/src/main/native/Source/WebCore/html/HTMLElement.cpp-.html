<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.web/src/main/native/Source/WebCore/html/HTMLElement.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (C) 1999 Lars Knoll (knoll@kde.org)
   3  *           (C) 1999 Antti Koivisto (koivisto@kde.org)
   4  * Copyright (C) 2004-2018 Apple Inc. All rights reserved.
   5  * Copyright (C) 2009 Torch Mobile Inc. All rights reserved. (http://www.torchmobile.com/)
   6  * Copyright (C) 2011 Motorola Mobility. All rights reserved.
   7  *
   8  * This library is free software; you can redistribute it and/or
   9  * modify it under the terms of the GNU Library General Public
  10  * License as published by the Free Software Foundation; either
  11  * version 2 of the License, or (at your option) any later version.
  12  *
  13  * This library is distributed in the hope that it will be useful,
  14  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  15  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  16  * Library General Public License for more details.
  17  *
  18  * You should have received a copy of the GNU Library General Public License
  19  * along with this library; see the file COPYING.LIB.  If not, write to
  20  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  21  * Boston, MA 02110-1301, USA.
  22  *
  23  */
  24 
  25 #include &quot;config.h&quot;
  26 #include &quot;HTMLElement.h&quot;
  27 
  28 #include &quot;CSSMarkup.h&quot;
  29 #include &quot;CSSPropertyNames.h&quot;
  30 #include &quot;CSSValueKeywords.h&quot;
  31 #include &quot;CSSValuePool.h&quot;
  32 #include &quot;Chrome.h&quot;
  33 #include &quot;ChromeClient.h&quot;
  34 #include &quot;DOMTokenList.h&quot;
  35 #include &quot;DocumentFragment.h&quot;
  36 #include &quot;ElementAncestorIterator.h&quot;
  37 #include &quot;Event.h&quot;
  38 #include &quot;EventListener.h&quot;
  39 #include &quot;EventNames.h&quot;
  40 #include &quot;Frame.h&quot;
  41 #include &quot;FrameLoader.h&quot;
  42 #include &quot;FrameView.h&quot;
  43 #include &quot;HTMLBDIElement.h&quot;
  44 #include &quot;HTMLBRElement.h&quot;
  45 #include &quot;HTMLButtonElement.h&quot;
  46 #include &quot;HTMLCollection.h&quot;
  47 #include &quot;HTMLDocument.h&quot;
  48 #include &quot;HTMLElementFactory.h&quot;
  49 #include &quot;HTMLFieldSetElement.h&quot;
  50 #include &quot;HTMLFormElement.h&quot;
  51 #include &quot;HTMLInputElement.h&quot;
  52 #include &quot;HTMLNames.h&quot;
  53 #include &quot;HTMLOptGroupElement.h&quot;
  54 #include &quot;HTMLOptionElement.h&quot;
  55 #include &quot;HTMLParserIdioms.h&quot;
  56 #include &quot;HTMLSelectElement.h&quot;
  57 #include &quot;HTMLTextAreaElement.h&quot;
  58 #include &quot;HTMLTextFormControlElement.h&quot;
  59 #include &quot;NodeTraversal.h&quot;
  60 #include &quot;RenderElement.h&quot;
  61 #include &quot;ScriptController.h&quot;
  62 #include &quot;ShadowRoot.h&quot;
  63 #include &quot;SimulatedClick.h&quot;
  64 #include &quot;StyleProperties.h&quot;
  65 #include &quot;SubframeLoader.h&quot;
  66 #include &quot;Text.h&quot;
  67 #include &quot;XMLNames.h&quot;
  68 #include &quot;markup.h&quot;
  69 #include &lt;wtf/IsoMallocInlines.h&gt;
  70 #include &lt;wtf/NeverDestroyed.h&gt;
  71 #include &lt;wtf/StdLibExtras.h&gt;
  72 #include &lt;wtf/text/CString.h&gt;
  73 
  74 namespace WebCore {
  75 
  76 WTF_MAKE_ISO_ALLOCATED_IMPL(HTMLElement);
  77 
  78 using namespace HTMLNames;
  79 
  80 Ref&lt;HTMLElement&gt; HTMLElement::create(const QualifiedName&amp; tagName, Document&amp; document)
  81 {
  82     return adoptRef(*new HTMLElement(tagName, document));
  83 }
  84 
  85 String HTMLElement::nodeName() const
  86 {
  87     // FIXME: Would be nice to have an AtomicString lookup based off uppercase
  88     // ASCII characters that does not have to copy the string on a hit in the hash.
  89     if (document().isHTMLDocument()) {
  90         if (LIKELY(!tagQName().hasPrefix()))
  91             return tagQName().localNameUpper();
  92         return Element::nodeName().convertToASCIIUppercase();
  93     }
  94     return Element::nodeName();
  95 }
  96 
  97 static inline CSSValueID unicodeBidiAttributeForDirAuto(HTMLElement&amp; element)
  98 {
  99     if (element.hasTagName(preTag) || element.hasTagName(textareaTag))
 100         return CSSValuePlaintext;
 101     // FIXME: For bdo element, dir=&quot;auto&quot; should result in &quot;bidi-override isolate&quot; but we don&#39;t support having multiple values in unicode-bidi yet.
 102     // See https://bugs.webkit.org/show_bug.cgi?id=73164.
 103     return CSSValueIsolate;
 104 }
 105 
 106 unsigned HTMLElement::parseBorderWidthAttribute(const AtomicString&amp; value) const
 107 {
 108     if (auto optionalBorderWidth = parseHTMLNonNegativeInteger(value))
 109         return optionalBorderWidth.value();
 110 
 111     return hasTagName(tableTag) ? 1 : 0;
 112 }
 113 
 114 void HTMLElement::applyBorderAttributeToStyle(const AtomicString&amp; value, MutableStyleProperties&amp; style)
 115 {
 116     addPropertyToPresentationAttributeStyle(style, CSSPropertyBorderWidth, parseBorderWidthAttribute(value), CSSPrimitiveValue::CSS_PX);
 117     addPropertyToPresentationAttributeStyle(style, CSSPropertyBorderStyle, CSSValueSolid);
 118 }
 119 
 120 void HTMLElement::mapLanguageAttributeToLocale(const AtomicString&amp; value, MutableStyleProperties&amp; style)
 121 {
 122     if (!value.isEmpty()) {
 123         // Have to quote so the locale id is treated as a string instead of as a CSS keyword.
 124         addPropertyToPresentationAttributeStyle(style, CSSPropertyWebkitLocale, serializeString(value));
 125     } else {
 126         // The empty string means the language is explicitly unknown.
 127         addPropertyToPresentationAttributeStyle(style, CSSPropertyWebkitLocale, CSSValueAuto);
 128     }
 129 }
 130 
 131 bool HTMLElement::isPresentationAttribute(const QualifiedName&amp; name) const
 132 {
 133     if (name == alignAttr || name == contenteditableAttr || name == hiddenAttr || name == langAttr || name.matches(XMLNames::langAttr) || name == draggableAttr || name == dirAttr)
 134         return true;
 135     return StyledElement::isPresentationAttribute(name);
 136 }
 137 
 138 static bool isLTROrRTLIgnoringCase(const AtomicString&amp; dirAttributeValue)
 139 {
 140     return equalLettersIgnoringASCIICase(dirAttributeValue, &quot;rtl&quot;) || equalLettersIgnoringASCIICase(dirAttributeValue, &quot;ltr&quot;);
 141 }
 142 
 143 enum class ContentEditableType {
 144     Inherit,
 145     True,
 146     False,
 147     PlaintextOnly
 148 };
 149 
 150 static inline ContentEditableType contentEditableType(const AtomicString&amp; value)
 151 {
 152     if (value.isNull())
 153         return ContentEditableType::Inherit;
 154     if (value.isEmpty() || equalLettersIgnoringASCIICase(value, &quot;true&quot;))
 155         return ContentEditableType::True;
 156     if (equalLettersIgnoringASCIICase(value, &quot;false&quot;))
 157         return ContentEditableType::False;
 158     if (equalLettersIgnoringASCIICase(value, &quot;plaintext-only&quot;))
 159         return ContentEditableType::PlaintextOnly;
 160 
 161     return ContentEditableType::Inherit;
 162 }
 163 
 164 static ContentEditableType contentEditableType(const HTMLElement&amp; element)
 165 {
 166     return contentEditableType(element.attributeWithoutSynchronization(contenteditableAttr));
 167 }
 168 
 169 void HTMLElement::collectStyleForPresentationAttribute(const QualifiedName&amp; name, const AtomicString&amp; value, MutableStyleProperties&amp; style)
 170 {
 171     if (name == alignAttr) {
 172         if (equalLettersIgnoringASCIICase(value, &quot;middle&quot;))
 173             addPropertyToPresentationAttributeStyle(style, CSSPropertyTextAlign, CSSValueCenter);
 174         else
 175             addPropertyToPresentationAttributeStyle(style, CSSPropertyTextAlign, value);
 176     } else if (name == contenteditableAttr) {
 177         CSSValueID userModifyValue = CSSValueReadWrite;
 178         switch (contentEditableType(value)) {
 179         case ContentEditableType::Inherit:
 180             return;
 181         case ContentEditableType::False:
 182             userModifyValue = CSSValueReadOnly;
 183             break;
 184         case ContentEditableType::PlaintextOnly:
 185             userModifyValue = CSSValueReadWritePlaintextOnly;
 186             FALLTHROUGH;
 187         case ContentEditableType::True:
 188             addPropertyToPresentationAttributeStyle(style, CSSPropertyWordWrap, CSSValueBreakWord);
 189             addPropertyToPresentationAttributeStyle(style, CSSPropertyWebkitNbspMode, CSSValueSpace);
 190             addPropertyToPresentationAttributeStyle(style, CSSPropertyLineBreak, CSSValueAfterWhiteSpace);
 191 #if PLATFORM(IOS_FAMILY)
 192             addPropertyToPresentationAttributeStyle(style, CSSPropertyWebkitTextSizeAdjust, CSSValueNone);
 193 #endif
 194             break;
 195         }
 196         addPropertyToPresentationAttributeStyle(style, CSSPropertyWebkitUserModify, userModifyValue);
 197     } else if (name == hiddenAttr) {
 198         addPropertyToPresentationAttributeStyle(style, CSSPropertyDisplay, CSSValueNone);
 199     } else if (name == draggableAttr) {
 200         if (equalLettersIgnoringASCIICase(value, &quot;true&quot;)) {
 201             addPropertyToPresentationAttributeStyle(style, CSSPropertyWebkitUserDrag, CSSValueElement);
 202             addPropertyToPresentationAttributeStyle(style, CSSPropertyWebkitUserSelect, CSSValueNone);
 203         } else if (equalLettersIgnoringASCIICase(value, &quot;false&quot;))
 204             addPropertyToPresentationAttributeStyle(style, CSSPropertyWebkitUserDrag, CSSValueNone);
 205     } else if (name == dirAttr) {
 206         if (equalLettersIgnoringASCIICase(value, &quot;auto&quot;))
 207             addPropertyToPresentationAttributeStyle(style, CSSPropertyUnicodeBidi, unicodeBidiAttributeForDirAuto(*this));
 208         else {
 209             if (isLTROrRTLIgnoringCase(value))
 210                 addPropertyToPresentationAttributeStyle(style, CSSPropertyDirection, value);
 211             if (!hasTagName(bdiTag) &amp;&amp; !hasTagName(bdoTag) &amp;&amp; !hasTagName(outputTag))
 212                 addPropertyToPresentationAttributeStyle(style, CSSPropertyUnicodeBidi, CSSValueEmbed);
 213         }
 214     } else if (name.matches(XMLNames::langAttr))
 215         mapLanguageAttributeToLocale(value, style);
 216     else if (name == langAttr) {
 217         // xml:lang has a higher priority than lang.
 218         if (!hasAttributeWithoutSynchronization(XMLNames::langAttr))
 219             mapLanguageAttributeToLocale(value, style);
 220     } else
 221         StyledElement::collectStyleForPresentationAttribute(name, value, style);
 222 }
 223 
 224 HTMLElement::EventHandlerNameMap HTMLElement::createEventHandlerNameMap()
 225 {
 226     EventHandlerNameMap map;
 227 
 228     static const QualifiedName* const table[] = {
 229         &amp;onabortAttr.get(),
 230         &amp;onaccessiblecontextmenuAttr.get(),
 231         &amp;onaccessibleclickAttr.get(),
 232         &amp;onaccessibledecrementAttr.get(),
 233         &amp;onaccessibledismissAttr.get(),
 234         &amp;onaccessiblefocusAttr.get(),
 235         &amp;onaccessibleincrementAttr.get(),
 236         &amp;onaccessiblescrollintoviewAttr.get(),
 237         &amp;onaccessiblesetvalueAttr.get(),
 238         &amp;onaccessibleselectAttr.get(),
 239         &amp;onanimationendAttr.get(),
 240         &amp;onanimationiterationAttr.get(),
 241         &amp;onanimationstartAttr.get(),
 242         &amp;onanimationcancelAttr.get(),
 243         &amp;onautocompleteAttr.get(),
 244         &amp;onautocompleteerrorAttr.get(),
 245         &amp;onbeforecopyAttr.get(),
 246         &amp;onbeforecutAttr.get(),
 247         &amp;onbeforeinputAttr.get(),
 248         &amp;onbeforeloadAttr.get(),
 249         &amp;onbeforepasteAttr.get(),
 250         &amp;onblurAttr.get(),
 251         &amp;oncanplayAttr.get(),
 252         &amp;oncanplaythroughAttr.get(),
 253         &amp;onchangeAttr.get(),
 254         &amp;onclickAttr.get(),
 255         &amp;oncontextmenuAttr.get(),
 256         &amp;oncopyAttr.get(),
 257         &amp;oncutAttr.get(),
 258         &amp;ondblclickAttr.get(),
 259         &amp;ondragAttr.get(),
 260         &amp;ondragendAttr.get(),
 261         &amp;ondragenterAttr.get(),
 262         &amp;ondragleaveAttr.get(),
 263         &amp;ondragoverAttr.get(),
 264         &amp;ondragstartAttr.get(),
 265         &amp;ondropAttr.get(),
 266         &amp;ondurationchangeAttr.get(),
 267         &amp;onemptiedAttr.get(),
 268         &amp;onendedAttr.get(),
 269         &amp;onerrorAttr.get(),
 270         &amp;onfocusAttr.get(),
 271         &amp;onfocusinAttr.get(),
 272         &amp;onfocusoutAttr.get(),
 273         &amp;ongesturechangeAttr.get(),
 274         &amp;ongestureendAttr.get(),
 275         &amp;ongesturestartAttr.get(),
 276         &amp;oninputAttr.get(),
 277         &amp;oninvalidAttr.get(),
 278         &amp;onkeydownAttr.get(),
 279         &amp;onkeypressAttr.get(),
 280         &amp;onkeyupAttr.get(),
 281         &amp;onloadAttr.get(),
 282         &amp;onloadeddataAttr.get(),
 283         &amp;onloadedmetadataAttr.get(),
 284         &amp;onloadstartAttr.get(),
 285         &amp;onmousedownAttr.get(),
 286         &amp;onmouseenterAttr.get(),
 287         &amp;onmouseleaveAttr.get(),
 288         &amp;onmousemoveAttr.get(),
 289         &amp;onmouseoutAttr.get(),
 290         &amp;onmouseoverAttr.get(),
 291         &amp;onmouseupAttr.get(),
 292         &amp;onmousewheelAttr.get(),
 293         &amp;onpasteAttr.get(),
 294         &amp;onpauseAttr.get(),
 295         &amp;onplayAttr.get(),
 296         &amp;onplayingAttr.get(),
 297         &amp;onprogressAttr.get(),
 298         &amp;onratechangeAttr.get(),
 299         &amp;onresetAttr.get(),
 300         &amp;onresizeAttr.get(),
 301         &amp;onscrollAttr.get(),
 302         &amp;onsearchAttr.get(),
 303         &amp;onseekedAttr.get(),
 304         &amp;onseekingAttr.get(),
 305         &amp;onselectAttr.get(),
 306         &amp;onselectstartAttr.get(),
 307         &amp;onstalledAttr.get(),
 308         &amp;onsubmitAttr.get(),
 309         &amp;onsuspendAttr.get(),
 310         &amp;ontimeupdateAttr.get(),
 311         &amp;ontoggleAttr.get(),
 312         &amp;ontouchcancelAttr.get(),
 313         &amp;ontouchendAttr.get(),
 314         &amp;ontouchforcechangeAttr.get(),
 315         &amp;ontouchmoveAttr.get(),
 316         &amp;ontouchstartAttr.get(),
 317         &amp;ontransitioncancelAttr.get(),
 318         &amp;ontransitionendAttr.get(),
 319         &amp;ontransitionrunAttr.get(),
 320         &amp;ontransitionstartAttr.get(),
 321         &amp;onvolumechangeAttr.get(),
 322         &amp;onwaitingAttr.get(),
 323         &amp;onwebkitbeginfullscreenAttr.get(),
 324         &amp;onwebkitcurrentplaybacktargetiswirelesschangedAttr.get(),
 325         &amp;onwebkitendfullscreenAttr.get(),
 326         &amp;onwebkitfullscreenchangeAttr.get(),
 327         &amp;onwebkitfullscreenerrorAttr.get(),
 328         &amp;onwebkitkeyaddedAttr.get(),
 329         &amp;onwebkitkeyerrorAttr.get(),
 330         &amp;onwebkitkeymessageAttr.get(),
 331         &amp;onwebkitmouseforcechangedAttr.get(),
 332         &amp;onwebkitmouseforcedownAttr.get(),
 333         &amp;onwebkitmouseforcewillbeginAttr.get(),
 334         &amp;onwebkitmouseforceupAttr.get(),
 335         &amp;onwebkitneedkeyAttr.get(),
 336         &amp;onwebkitplaybacktargetavailabilitychangedAttr.get(),
 337         &amp;onwebkitpresentationmodechangedAttr.get(),
 338         &amp;onwebkitwillrevealbottomAttr.get(),
 339         &amp;onwebkitwillrevealleftAttr.get(),
 340         &amp;onwebkitwillrevealrightAttr.get(),
 341         &amp;onwebkitwillrevealtopAttr.get(),
 342         &amp;onwheelAttr.get(),
 343     };
 344 
 345     populateEventHandlerNameMap(map, table);
 346 
 347     struct UnusualMapping {
 348         const QualifiedName&amp; attributeName;
 349         const AtomicString&amp; eventName;
 350     };
 351 
 352     const UnusualMapping unusualPairsTable[] = {
 353         { onwebkitanimationendAttr, eventNames().webkitAnimationEndEvent },
 354         { onwebkitanimationiterationAttr, eventNames().webkitAnimationIterationEvent },
 355         { onwebkitanimationstartAttr, eventNames().webkitAnimationStartEvent },
 356         { onwebkittransitionendAttr, eventNames().webkitTransitionEndEvent },
 357     };
 358 
 359     for (auto&amp; entry : unusualPairsTable)
 360         map.add(entry.attributeName.localName().impl(), entry.eventName);
 361 
 362     return map;
 363 }
 364 
 365 void HTMLElement::populateEventHandlerNameMap(EventHandlerNameMap&amp; map, const QualifiedName* const table[], size_t tableSize)
 366 {
 367     for (size_t i = 0; i &lt; tableSize; ++i) {
 368         auto* entry = table[i];
 369 
 370         // FIXME: Would be nice to check these against the actual event names in eventNames().
 371         // Not obvious how to do that simply, though.
 372         auto&amp; attributeName = entry-&gt;localName();
 373 
 374         // Remove the &quot;on&quot; prefix. Requires some memory allocation and computing a hash, but by not
 375         // using pointers from eventNames(), the passed-in table can be initialized at compile time.
 376         AtomicString eventName = attributeName.string().substring(2);
 377 
 378         map.add(attributeName.impl(), WTFMove(eventName));
 379     }
 380 }
 381 
 382 const AtomicString&amp; HTMLElement::eventNameForEventHandlerAttribute(const QualifiedName&amp; attributeName, const EventHandlerNameMap&amp; map)
 383 {
 384     ASSERT(!attributeName.localName().isNull());
 385 
 386     // Event handler attributes have no namespace.
 387     if (!attributeName.namespaceURI().isNull())
 388         return nullAtom();
 389 
 390     // Fast early return for names that don&#39;t start with &quot;on&quot;.
 391     AtomicStringImpl&amp; localName = *attributeName.localName().impl();
 392     if (localName.length() &lt; 3 || localName[0] != &#39;o&#39; || localName[1] != &#39;n&#39;)
 393         return nullAtom();
 394 
 395     auto it = map.find(&amp;localName);
 396     return it == map.end() ? nullAtom() : it-&gt;value;
 397 }
 398 
 399 const AtomicString&amp; HTMLElement::eventNameForEventHandlerAttribute(const QualifiedName&amp; attributeName)
 400 {
 401     static NeverDestroyed&lt;EventHandlerNameMap&gt; map = createEventHandlerNameMap();
 402     return eventNameForEventHandlerAttribute(attributeName, map.get());
 403 }
 404 
 405 Node::Editability HTMLElement::editabilityFromContentEditableAttr(const Node&amp; node)
 406 {
 407     if (auto* startElement = is&lt;Element&gt;(node) ? &amp;downcast&lt;Element&gt;(node) : node.parentElement()) {
 408         for (auto&amp; element : lineageOfType&lt;HTMLElement&gt;(*startElement)) {
 409             switch (contentEditableType(element)) {
 410             case ContentEditableType::True:
 411                 return Editability::CanEditRichly;
 412             case ContentEditableType::PlaintextOnly:
 413                 return Editability::CanEditPlainText;
 414             case ContentEditableType::False:
 415                 return Editability::ReadOnly;
 416             case ContentEditableType::Inherit:
 417                 break;
 418             }
 419         }
 420     }
 421 
 422     auto containingShadowRoot = makeRefPtr(node.containingShadowRoot());
 423     if (containingShadowRoot &amp;&amp; containingShadowRoot-&gt;mode() == ShadowRootMode::UserAgent)
 424         return Editability::ReadOnly;
 425 
 426     auto&amp; document = node.document();
 427     if (is&lt;HTMLDocument&gt;(document))
 428         return downcast&lt;HTMLDocument&gt;(document).inDesignMode() ? Editability::CanEditRichly : Editability::ReadOnly;
 429 
 430     return Editability::ReadOnly;
 431 }
 432 
 433 bool HTMLElement::matchesReadWritePseudoClass() const
 434 {
 435     return editabilityFromContentEditableAttr(*this) != Editability::ReadOnly;
 436 }
 437 
 438 void HTMLElement::parseAttribute(const QualifiedName&amp; name, const AtomicString&amp; value)
 439 {
 440     if (name == dirAttr) {
 441         dirAttributeChanged(value);
 442         return;
 443     }
 444 
 445     if (name == tabindexAttr) {
 446         if (value.isEmpty())
 447             clearTabIndexExplicitlyIfNeeded();
 448         else if (auto optionalTabIndex = parseHTMLInteger(value))
 449             setTabIndexExplicitly(optionalTabIndex.value());
 450         return;
 451     }
 452 
 453     if (name == inputmodeAttr) {
 454         auto&amp; document = this-&gt;document();
 455         if (this == document.focusedElement()) {
 456             if (auto* page = document.page())
 457                 page-&gt;chrome().client().focusedElementDidChangeInputMode(*this, canonicalInputMode());
 458         }
 459     }
 460 
 461     auto&amp; eventName = eventNameForEventHandlerAttribute(name);
 462     if (!eventName.isNull())
 463         setAttributeEventListener(eventName, name, value);
 464 }
 465 
 466 static Ref&lt;DocumentFragment&gt; textToFragment(Document&amp; document, const String&amp; text)
 467 {
 468     auto fragment = DocumentFragment::create(document);
 469 
 470     // It&#39;s safe to dispatch events on the new fragment since author scripts have no access to it yet.
 471     ScriptDisallowedScope::EventAllowedScope allowedScope(fragment);
 472 
 473     for (unsigned start = 0, length = text.length(); start &lt; length; ) {
 474         // Find next line break.
 475         UChar c = 0;
 476         unsigned i;
 477         for (i = start; i &lt; length; i++) {
 478             c = text[i];
 479             if (c == &#39;\r&#39; || c == &#39;\n&#39;)
 480                 break;
 481         }
 482 
 483         // If text is not the empty string, then append a new Text node whose data is text and node document is document to fragment.
 484         if (i &gt; start)
 485             fragment-&gt;appendChild(Text::create(document, text.substring(start, i - start)));
 486 
 487         if (i == length)
 488             break;
 489 
 490         fragment-&gt;appendChild(HTMLBRElement::create(document));
 491         // Make sure \r\n doesn&#39;t result in two line breaks.
 492         if (c == &#39;\r&#39; &amp;&amp; i + 1 &lt; length &amp;&amp; text[i + 1] == &#39;\n&#39;)
 493             ++i;
 494 
 495         start = i + 1; // Character after line break.
 496     }
 497 
 498     return fragment;
 499 }
 500 
 501 // Returns the conforming &#39;dir&#39; value associated with the state the attribute is in (in its canonical case), if any,
 502 // or the empty string if the attribute is in a state that has no associated keyword value or if the attribute is
 503 // not in a defined state (e.g. the attribute is missing and there is no missing value default).
 504 // http://www.whatwg.org/specs/web-apps/current-work/multipage/common-dom-interfaces.html#limited-to-only-known-values
 505 static inline const AtomicString&amp; toValidDirValue(const AtomicString&amp; value)
 506 {
 507     static NeverDestroyed&lt;AtomicString&gt; ltrValue(&quot;ltr&quot;, AtomicString::ConstructFromLiteral);
 508     static NeverDestroyed&lt;AtomicString&gt; rtlValue(&quot;rtl&quot;, AtomicString::ConstructFromLiteral);
 509     static NeverDestroyed&lt;AtomicString&gt; autoValue(&quot;auto&quot;, AtomicString::ConstructFromLiteral);
 510     if (equalLettersIgnoringASCIICase(value, &quot;ltr&quot;))
 511         return ltrValue;
 512     if (equalLettersIgnoringASCIICase(value, &quot;rtl&quot;))
 513         return rtlValue;
 514     if (equalLettersIgnoringASCIICase(value, &quot;auto&quot;))
 515         return autoValue;
 516     return nullAtom();
 517 }
 518 
 519 const AtomicString&amp; HTMLElement::dir() const
 520 {
 521     return toValidDirValue(attributeWithoutSynchronization(dirAttr));
 522 }
 523 
 524 void HTMLElement::setDir(const AtomicString&amp; value)
 525 {
 526     setAttributeWithoutSynchronization(dirAttr, value);
 527 }
 528 
 529 ExceptionOr&lt;void&gt; HTMLElement::setInnerText(const String&amp; text)
 530 {
 531     // FIXME: This doesn&#39;t take whitespace collapsing into account at all.
 532 
 533     if (!text.contains(&#39;\n&#39;) &amp;&amp; !text.contains(&#39;\r&#39;)) {
 534         if (text.isEmpty())
 535             replaceAllChildren(nullptr);
 536         else
 537             replaceAllChildren(document().createTextNode(text));
 538         return { };
 539     }
 540 
 541     // FIXME: Do we need to be able to detect preserveNewline style even when there&#39;s no renderer?
 542     // FIXME: Can the renderer be out of date here? Do we need to call updateStyleIfNeeded?
 543     // For example, for the contents of textarea elements that are display:none?
 544     auto* r = renderer();
 545     if ((r &amp;&amp; r-&gt;style().preserveNewline()) || (isConnected() &amp;&amp; isTextControlInnerTextElement())) {
 546         if (!text.contains(&#39;\r&#39;)) {
 547             replaceAllChildren(document().createTextNode(text));
 548             return { };
 549         }
 550         String textWithConsistentLineBreaks = text;
 551         textWithConsistentLineBreaks.replace(&quot;\r\n&quot;, &quot;\n&quot;);
 552         textWithConsistentLineBreaks.replace(&#39;\r&#39;, &#39;\n&#39;);
 553         replaceAllChildren(document().createTextNode(textWithConsistentLineBreaks));
 554         return { };
 555     }
 556 
 557     // Add text nodes and &lt;br&gt; elements.
 558     auto fragment = textToFragment(document(), text);
 559     // FIXME: This should use replaceAllChildren() once it accepts DocumentFragments as input.
 560     // It&#39;s safe to dispatch events on the new fragment since author scripts have no access to it yet.
 561     ScriptDisallowedScope::EventAllowedScope allowedScope(fragment.get());
 562     return replaceChildrenWithFragment(*this, WTFMove(fragment));
 563 }
 564 
 565 ExceptionOr&lt;void&gt; HTMLElement::setOuterText(const String&amp; text)
 566 {
 567     RefPtr&lt;ContainerNode&gt; parent = parentNode();
 568     if (!parent)
 569         return Exception { NoModificationAllowedError };
 570 
 571     RefPtr&lt;Node&gt; prev = previousSibling();
 572     RefPtr&lt;Node&gt; next = nextSibling();
 573     RefPtr&lt;Node&gt; newChild;
 574 
 575     // Convert text to fragment with &lt;br&gt; tags instead of linebreaks if needed.
 576     if (text.contains(&#39;\r&#39;) || text.contains(&#39;\n&#39;))
 577         newChild = textToFragment(document(), text);
 578     else
 579         newChild = Text::create(document(), text);
 580 
 581     if (!parentNode())
 582         return Exception { HierarchyRequestError };
 583 
 584     auto replaceResult = parent-&gt;replaceChild(*newChild, *this);
 585     if (replaceResult.hasException())
 586         return replaceResult.releaseException();
 587 
 588     RefPtr&lt;Node&gt; node = next ? next-&gt;previousSibling() : nullptr;
 589     if (is&lt;Text&gt;(node)) {
 590         auto result = mergeWithNextTextNode(downcast&lt;Text&gt;(*node));
 591         if (result.hasException())
 592             return result.releaseException();
 593     }
 594     if (is&lt;Text&gt;(prev)) {
 595         auto result = mergeWithNextTextNode(downcast&lt;Text&gt;(*prev));
 596         if (result.hasException())
 597             return result.releaseException();
 598     }
 599     return { };
 600 }
 601 
 602 void HTMLElement::applyAlignmentAttributeToStyle(const AtomicString&amp; alignment, MutableStyleProperties&amp; style)
 603 {
 604     // Vertical alignment with respect to the current baseline of the text
 605     // right or left means floating images.
 606     CSSValueID floatValue = CSSValueInvalid;
 607     CSSValueID verticalAlignValue = CSSValueInvalid;
 608 
 609     if (equalLettersIgnoringASCIICase(alignment, &quot;absmiddle&quot;))
 610         verticalAlignValue = CSSValueMiddle;
 611     else if (equalLettersIgnoringASCIICase(alignment, &quot;absbottom&quot;))
 612         verticalAlignValue = CSSValueBottom;
 613     else if (equalLettersIgnoringASCIICase(alignment, &quot;left&quot;)) {
 614         floatValue = CSSValueLeft;
 615         verticalAlignValue = CSSValueTop;
 616     } else if (equalLettersIgnoringASCIICase(alignment, &quot;right&quot;)) {
 617         floatValue = CSSValueRight;
 618         verticalAlignValue = CSSValueTop;
 619     } else if (equalLettersIgnoringASCIICase(alignment, &quot;top&quot;))
 620         verticalAlignValue = CSSValueTop;
 621     else if (equalLettersIgnoringASCIICase(alignment, &quot;middle&quot;))
 622         verticalAlignValue = CSSValueWebkitBaselineMiddle;
 623     else if (equalLettersIgnoringASCIICase(alignment, &quot;center&quot;))
 624         verticalAlignValue = CSSValueMiddle;
 625     else if (equalLettersIgnoringASCIICase(alignment, &quot;bottom&quot;))
 626         verticalAlignValue = CSSValueBaseline;
 627     else if (equalLettersIgnoringASCIICase(alignment, &quot;texttop&quot;))
 628         verticalAlignValue = CSSValueTextTop;
 629 
 630     if (floatValue != CSSValueInvalid)
 631         addPropertyToPresentationAttributeStyle(style, CSSPropertyFloat, floatValue);
 632 
 633     if (verticalAlignValue != CSSValueInvalid)
 634         addPropertyToPresentationAttributeStyle(style, CSSPropertyVerticalAlign, verticalAlignValue);
 635 }
 636 
 637 bool HTMLElement::hasCustomFocusLogic() const
 638 {
 639     return false;
 640 }
 641 
 642 bool HTMLElement::supportsFocus() const
 643 {
 644     return Element::supportsFocus() || (hasEditableStyle() &amp;&amp; parentNode() &amp;&amp; !parentNode()-&gt;hasEditableStyle());
 645 }
 646 
 647 String HTMLElement::contentEditable() const
 648 {
 649     switch (contentEditableType(*this)) {
 650     case ContentEditableType::Inherit:
 651         return &quot;inherit&quot;_s;
 652     case ContentEditableType::True:
 653         return &quot;true&quot;_s;
 654     case ContentEditableType::False:
 655         return &quot;false&quot;_s;
 656     case ContentEditableType::PlaintextOnly:
 657         return &quot;plaintext-only&quot;_s;
 658     }
 659     return &quot;inherit&quot;_s;
 660 }
 661 
 662 ExceptionOr&lt;void&gt; HTMLElement::setContentEditable(const String&amp; enabled)
 663 {
 664     if (equalLettersIgnoringASCIICase(enabled, &quot;true&quot;))
 665         setAttributeWithoutSynchronization(contenteditableAttr, AtomicString(&quot;true&quot;, AtomicString::ConstructFromLiteral));
 666     else if (equalLettersIgnoringASCIICase(enabled, &quot;false&quot;))
 667         setAttributeWithoutSynchronization(contenteditableAttr, AtomicString(&quot;false&quot;, AtomicString::ConstructFromLiteral));
 668     else if (equalLettersIgnoringASCIICase(enabled, &quot;plaintext-only&quot;))
 669         setAttributeWithoutSynchronization(contenteditableAttr, AtomicString(&quot;plaintext-only&quot;, AtomicString::ConstructFromLiteral));
 670     else if (equalLettersIgnoringASCIICase(enabled, &quot;inherit&quot;))
 671         removeAttribute(contenteditableAttr);
 672     else
 673         return Exception { SyntaxError };
 674     return { };
 675 }
 676 
 677 bool HTMLElement::draggable() const
 678 {
 679     return equalLettersIgnoringASCIICase(attributeWithoutSynchronization(draggableAttr), &quot;true&quot;);
 680 }
 681 
 682 void HTMLElement::setDraggable(bool value)
 683 {
 684     setAttributeWithoutSynchronization(draggableAttr, value
 685         ? AtomicString(&quot;true&quot;, AtomicString::ConstructFromLiteral)
 686         : AtomicString(&quot;false&quot;, AtomicString::ConstructFromLiteral));
 687 }
 688 
 689 bool HTMLElement::spellcheck() const
 690 {
 691     return isSpellCheckingEnabled();
 692 }
 693 
 694 void HTMLElement::setSpellcheck(bool enable)
 695 {
 696     setAttributeWithoutSynchronization(spellcheckAttr, enable
 697         ? AtomicString(&quot;true&quot;, AtomicString::ConstructFromLiteral)
 698         : AtomicString(&quot;false&quot;, AtomicString::ConstructFromLiteral));
 699 }
 700 
 701 void HTMLElement::click()
 702 {
 703     simulateClick(*this, nullptr, SendNoEvents, DoNotShowPressedLook, SimulatedClickSource::Bindings);
 704 }
 705 
 706 void HTMLElement::accessKeyAction(bool sendMouseEvents)
 707 {
 708     dispatchSimulatedClick(nullptr, sendMouseEvents ? SendMouseUpDownEvents : SendNoEvents);
 709 }
 710 
 711 String HTMLElement::title() const
 712 {
 713     return attributeWithoutSynchronization(titleAttr);
 714 }
 715 
 716 int HTMLElement::tabIndex() const
 717 {
 718     if (supportsFocus())
 719         return Element::tabIndex();
 720     return -1;
 721 }
 722 
 723 bool HTMLElement::translate() const
 724 {
 725     for (auto&amp; element : lineageOfType&lt;HTMLElement&gt;(*this)) {
 726         const AtomicString&amp; value = element.attributeWithoutSynchronization(translateAttr);
 727         if (equalLettersIgnoringASCIICase(value, &quot;yes&quot;) || (value.isEmpty() &amp;&amp; !value.isNull()))
 728             return true;
 729         if (equalLettersIgnoringASCIICase(value, &quot;no&quot;))
 730             return false;
 731     }
 732     // Default on the root element is translate=yes.
 733     return true;
 734 }
 735 
 736 void HTMLElement::setTranslate(bool enable)
 737 {
 738     setAttributeWithoutSynchronization(translateAttr, enable ? &quot;yes&quot; : &quot;no&quot;);
 739 }
 740 
 741 bool HTMLElement::rendererIsNeeded(const RenderStyle&amp; style)
 742 {
 743     if (hasTagName(noscriptTag)) {
 744         RefPtr&lt;Frame&gt; frame = document().frame();
 745         if (frame &amp;&amp; frame-&gt;script().canExecuteScripts(NotAboutToExecuteScript))
 746             return false;
 747     } else if (hasTagName(noembedTag)) {
 748         RefPtr&lt;Frame&gt; frame = document().frame();
 749         if (frame &amp;&amp; frame-&gt;loader().subframeLoader().allowPlugins())
 750             return false;
 751     }
 752     return StyledElement::rendererIsNeeded(style);
 753 }
 754 
 755 RenderPtr&lt;RenderElement&gt; HTMLElement::createElementRenderer(RenderStyle&amp;&amp; style, const RenderTreePosition&amp;)
 756 {
 757     return RenderElement::createFor(*this, WTFMove(style));
 758 }
 759 
 760 HTMLFormElement* HTMLElement::form() const
 761 {
 762     return HTMLFormElement::findClosestFormAncestor(*this);
 763 }
 764 
 765 static inline bool elementAffectsDirectionality(const Node&amp; node)
 766 {
 767     if (!is&lt;HTMLElement&gt;(node))
 768         return false;
 769     const HTMLElement&amp; element = downcast&lt;HTMLElement&gt;(node);
 770     return is&lt;HTMLBDIElement&gt;(element) || element.hasAttributeWithoutSynchronization(dirAttr);
 771 }
 772 
 773 static void setHasDirAutoFlagRecursively(Node* firstNode, bool flag, Node* lastNode = nullptr)
 774 {
 775     firstNode-&gt;setSelfOrAncestorHasDirAutoAttribute(flag);
 776 
 777     RefPtr&lt;Node&gt; node = firstNode-&gt;firstChild();
 778 
 779     while (node) {
 780         if (node-&gt;selfOrAncestorHasDirAutoAttribute() == flag)
 781             return;
 782 
 783         if (elementAffectsDirectionality(*node)) {
 784             if (node == lastNode)
 785                 return;
 786             node = NodeTraversal::nextSkippingChildren(*node, firstNode);
 787             continue;
 788         }
 789         node-&gt;setSelfOrAncestorHasDirAutoAttribute(flag);
 790         if (node == lastNode)
 791             return;
 792         node = NodeTraversal::next(*node, firstNode);
 793     }
 794 }
 795 
 796 void HTMLElement::childrenChanged(const ChildChange&amp; change)
 797 {
 798     StyledElement::childrenChanged(change);
 799     adjustDirectionalityIfNeededAfterChildrenChanged(change.previousSiblingElement, change.type);
 800 }
 801 
 802 bool HTMLElement::hasDirectionAuto() const
 803 {
 804     const AtomicString&amp; direction = attributeWithoutSynchronization(dirAttr);
 805     return (hasTagName(bdiTag) &amp;&amp; direction.isNull()) || equalLettersIgnoringASCIICase(direction, &quot;auto&quot;);
 806 }
 807 
 808 TextDirection HTMLElement::directionalityIfhasDirAutoAttribute(bool&amp; isAuto) const
 809 {
 810     if (!(selfOrAncestorHasDirAutoAttribute() &amp;&amp; hasDirectionAuto())) {
 811         isAuto = false;
 812         return TextDirection::LTR;
 813     }
 814 
 815     isAuto = true;
 816     return directionality();
 817 }
 818 
 819 TextDirection HTMLElement::directionality(Node** strongDirectionalityTextNode) const
 820 {
 821     if (isTextField()) {
 822         HTMLTextFormControlElement&amp; textElement = downcast&lt;HTMLTextFormControlElement&gt;(const_cast&lt;HTMLElement&amp;&gt;(*this));
 823         bool hasStrongDirectionality;
 824         UCharDirection textDirection = textElement.value().defaultWritingDirection(&amp;hasStrongDirectionality);
 825         if (strongDirectionalityTextNode)
 826             *strongDirectionalityTextNode = hasStrongDirectionality ? &amp;textElement : nullptr;
 827         return (textDirection == U_LEFT_TO_RIGHT) ? TextDirection::LTR : TextDirection::RTL;
 828     }
 829 
 830     RefPtr&lt;Node&gt; node = firstChild();
 831     while (node) {
 832         // Skip bdi, script, style and text form controls.
 833         if (equalLettersIgnoringASCIICase(node-&gt;nodeName(), &quot;bdi&quot;) || node-&gt;hasTagName(scriptTag) || node-&gt;hasTagName(styleTag)
 834             || (is&lt;Element&gt;(*node) &amp;&amp; downcast&lt;Element&gt;(*node).isTextField())) {
 835             node = NodeTraversal::nextSkippingChildren(*node, this);
 836             continue;
 837         }
 838 
 839         // Skip elements with valid dir attribute
 840         if (is&lt;Element&gt;(*node)) {
 841             auto&amp; dirAttributeValue = downcast&lt;Element&gt;(*node).attributeWithoutSynchronization(dirAttr);
 842             if (isLTROrRTLIgnoringCase(dirAttributeValue) || equalLettersIgnoringASCIICase(dirAttributeValue, &quot;auto&quot;)) {
 843                 node = NodeTraversal::nextSkippingChildren(*node, this);
 844                 continue;
 845             }
 846         }
 847 
 848         if (node-&gt;isTextNode()) {
 849             bool hasStrongDirectionality;
 850             UCharDirection textDirection = node-&gt;textContent(true).defaultWritingDirection(&amp;hasStrongDirectionality);
 851             if (hasStrongDirectionality) {
 852                 if (strongDirectionalityTextNode)
 853                     *strongDirectionalityTextNode = node.get();
 854                 return (textDirection == U_LEFT_TO_RIGHT) ? TextDirection::LTR : TextDirection::RTL;
 855             }
 856         }
 857         node = NodeTraversal::next(*node, this);
 858     }
 859     if (strongDirectionalityTextNode)
 860         *strongDirectionalityTextNode = nullptr;
 861     return TextDirection::LTR;
 862 }
 863 
 864 void HTMLElement::dirAttributeChanged(const AtomicString&amp; value)
 865 {
 866     RefPtr&lt;Element&gt; parent = parentElement();
 867 
 868     if (is&lt;HTMLElement&gt;(parent) &amp;&amp; parent-&gt;selfOrAncestorHasDirAutoAttribute())
 869         downcast&lt;HTMLElement&gt;(*parent).adjustDirectionalityIfNeededAfterChildAttributeChanged(this);
 870 
 871     if (equalLettersIgnoringASCIICase(value, &quot;auto&quot;))
 872         calculateAndAdjustDirectionality();
 873 }
 874 
 875 void HTMLElement::adjustDirectionalityIfNeededAfterChildAttributeChanged(Element* child)
 876 {
 877     ASSERT(selfOrAncestorHasDirAutoAttribute());
 878     Node* strongDirectionalityTextNode;
 879     TextDirection textDirection = directionality(&amp;strongDirectionalityTextNode);
 880     setHasDirAutoFlagRecursively(child, false);
 881     if (!renderer() || renderer()-&gt;style().direction() == textDirection)
 882         return;
 883     for (auto&amp; elementToAdjust : elementLineage(this)) {
 884         if (elementAffectsDirectionality(elementToAdjust)) {
 885             elementToAdjust.invalidateStyleForSubtree();
 886             return;
 887         }
 888     }
 889 }
 890 
 891 void HTMLElement::calculateAndAdjustDirectionality()
 892 {
 893     Node* strongDirectionalityTextNode;
 894     TextDirection textDirection = directionality(&amp;strongDirectionalityTextNode);
 895     setHasDirAutoFlagRecursively(this, true, strongDirectionalityTextNode);
 896     if (renderer() &amp;&amp; renderer()-&gt;style().direction() != textDirection)
 897         invalidateStyleForSubtree();
 898 }
 899 
 900 void HTMLElement::adjustDirectionalityIfNeededAfterChildrenChanged(Element* beforeChange, ChildChangeType changeType)
 901 {
 902     // FIXME: This function looks suspicious.
 903 
 904     if (!selfOrAncestorHasDirAutoAttribute())
 905         return;
 906 
 907     RefPtr&lt;Node&gt; oldMarkedNode;
 908     if (beforeChange)
 909         oldMarkedNode = changeType == ElementInserted ? ElementTraversal::nextSibling(*beforeChange) : beforeChange-&gt;nextSibling();
 910 
 911     while (oldMarkedNode &amp;&amp; elementAffectsDirectionality(*oldMarkedNode))
 912         oldMarkedNode = oldMarkedNode-&gt;nextSibling();
 913     if (oldMarkedNode)
 914         setHasDirAutoFlagRecursively(oldMarkedNode.get(), false);
 915 
 916     for (auto&amp; elementToAdjust : lineageOfType&lt;HTMLElement&gt;(*this)) {
 917         if (elementAffectsDirectionality(elementToAdjust)) {
 918             elementToAdjust.calculateAndAdjustDirectionality();
 919             return;
 920         }
 921     }
 922 }
 923 
 924 void HTMLElement::addHTMLLengthToStyle(MutableStyleProperties&amp; style, CSSPropertyID propertyID, const String&amp; value)
 925 {
 926     // FIXME: This function should not spin up the CSS parser, but should instead just figure out the correct
 927     // length unit and make the appropriate parsed value.
 928 
 929     if (StringImpl* string = value.impl()) {
 930         unsigned parsedLength = 0;
 931 
 932         while (parsedLength &lt; string-&gt;length() &amp;&amp; (*string)[parsedLength] &lt;= &#39; &#39;)
 933             ++parsedLength;
 934 
 935         for (; parsedLength &lt; string-&gt;length(); ++parsedLength) {
 936             UChar cc = (*string)[parsedLength];
 937             if (cc &gt; &#39;9&#39;)
 938                 break;
 939             if (cc &lt; &#39;0&#39;) {
 940                 if (cc == &#39;%&#39; || cc == &#39;*&#39;)
 941                     ++parsedLength;
 942                 if (cc != &#39;.&#39;)
 943                     break;
 944             }
 945         }
 946 
 947         if (parsedLength != string-&gt;length()) {
 948             addPropertyToPresentationAttributeStyle(style, propertyID, string-&gt;substring(0, parsedLength));
 949             return;
 950         }
 951     }
 952 
 953     addPropertyToPresentationAttributeStyle(style, propertyID, value);
 954 }
 955 
 956 static RGBA32 parseColorStringWithCrazyLegacyRules(const String&amp; colorString)
 957 {
 958     // Per spec, only look at the first 128 digits of the string.
 959     const size_t maxColorLength = 128;
 960     // We&#39;ll pad the buffer with two extra 0s later, so reserve two more than the max.
 961     Vector&lt;char, maxColorLength+2&gt; digitBuffer;
 962 
 963     size_t i = 0;
 964     // Skip a leading #.
 965     if (colorString[0] == &#39;#&#39;)
 966         i = 1;
 967 
 968     // Grab the first 128 characters, replacing non-hex characters with 0.
 969     // Non-BMP characters are replaced with &quot;00&quot; due to them appearing as two &quot;characters&quot; in the String.
 970     for (; i &lt; colorString.length() &amp;&amp; digitBuffer.size() &lt; maxColorLength; i++) {
 971         if (!isASCIIHexDigit(colorString[i]))
 972             digitBuffer.append(&#39;0&#39;);
 973         else
 974             digitBuffer.append(colorString[i]);
 975     }
 976 
 977     if (!digitBuffer.size())
 978         return Color::black;
 979 
 980     // Pad the buffer out to at least the next multiple of three in size.
 981     digitBuffer.append(&#39;0&#39;);
 982     digitBuffer.append(&#39;0&#39;);
 983 
 984     if (digitBuffer.size() &lt; 6)
 985         return makeRGB(toASCIIHexValue(digitBuffer[0]), toASCIIHexValue(digitBuffer[1]), toASCIIHexValue(digitBuffer[2]));
 986 
 987     // Split the digits into three components, then search the last 8 digits of each component.
 988     ASSERT(digitBuffer.size() &gt;= 6);
 989     size_t componentLength = digitBuffer.size() / 3;
 990     size_t componentSearchWindowLength = std::min&lt;size_t&gt;(componentLength, 8);
 991     size_t redIndex = componentLength - componentSearchWindowLength;
 992     size_t greenIndex = componentLength * 2 - componentSearchWindowLength;
 993     size_t blueIndex = componentLength * 3 - componentSearchWindowLength;
 994     // Skip digits until one of them is non-zero, or we&#39;ve only got two digits left in the component.
 995     while (digitBuffer[redIndex] == &#39;0&#39; &amp;&amp; digitBuffer[greenIndex] == &#39;0&#39; &amp;&amp; digitBuffer[blueIndex] == &#39;0&#39; &amp;&amp; (componentLength - redIndex) &gt; 2) {
 996         redIndex++;
 997         greenIndex++;
 998         blueIndex++;
 999     }
1000     ASSERT(redIndex + 1 &lt; componentLength);
1001     ASSERT(greenIndex &gt;= componentLength);
1002     ASSERT(greenIndex + 1 &lt; componentLength * 2);
1003     ASSERT(blueIndex &gt;= componentLength * 2);
1004     ASSERT_WITH_SECURITY_IMPLICATION(blueIndex + 1 &lt; digitBuffer.size());
1005 
1006     int redValue = toASCIIHexValue(digitBuffer[redIndex], digitBuffer[redIndex + 1]);
1007     int greenValue = toASCIIHexValue(digitBuffer[greenIndex], digitBuffer[greenIndex + 1]);
1008     int blueValue = toASCIIHexValue(digitBuffer[blueIndex], digitBuffer[blueIndex + 1]);
1009     return makeRGB(redValue, greenValue, blueValue);
1010 }
1011 
1012 // Color parsing that matches HTML&#39;s &quot;rules for parsing a legacy color value&quot;
1013 void HTMLElement::addHTMLColorToStyle(MutableStyleProperties&amp; style, CSSPropertyID propertyID, const String&amp; attributeValue)
1014 {
1015     // An empty string doesn&#39;t apply a color. (One containing only whitespace does, which is why this check occurs before stripping.)
1016     if (attributeValue.isEmpty())
1017         return;
1018 
1019     String colorString = attributeValue.stripWhiteSpace();
1020 
1021     // &quot;transparent&quot; doesn&#39;t apply a color either.
1022     if (equalLettersIgnoringASCIICase(colorString, &quot;transparent&quot;))
1023         return;
1024 
1025     Color color;
1026     // We can&#39;t always use the default Color constructor because it accepts
1027     // 4/8-digit hex, which conflict with some legacy HTML content using attributes.
1028     if ((colorString.length() != 5 &amp;&amp; colorString.length() != 9) || colorString[0] != &#39;#&#39;)
1029         color = Color(colorString);
1030     if (!color.isValid())
1031         color = Color(parseColorStringWithCrazyLegacyRules(colorString));
1032 
1033     style.setProperty(propertyID, CSSValuePool::singleton().createColorValue(color.rgb()));
1034 }
1035 
1036 bool HTMLElement::willRespondToMouseMoveEvents()
1037 {
1038     return !isDisabledFormControl() &amp;&amp; Element::willRespondToMouseMoveEvents();
1039 }
1040 
1041 bool HTMLElement::willRespondToMouseWheelEvents()
1042 {
1043     return !isDisabledFormControl() &amp;&amp; Element::willRespondToMouseWheelEvents();
1044 }
1045 
1046 bool HTMLElement::willRespondToMouseClickEvents()
1047 {
1048     return !isDisabledFormControl() &amp;&amp; Element::willRespondToMouseClickEvents();
1049 }
1050 
1051 bool HTMLElement::canBeActuallyDisabled() const
1052 {
1053     return is&lt;HTMLButtonElement&gt;(*this)
1054         || is&lt;HTMLInputElement&gt;(*this)
1055         || is&lt;HTMLSelectElement&gt;(*this)
1056         || is&lt;HTMLTextAreaElement&gt;(*this)
1057         || is&lt;HTMLOptGroupElement&gt;(*this)
1058         || is&lt;HTMLOptionElement&gt;(*this)
1059         || is&lt;HTMLFieldSetElement&gt;(*this);
1060 }
1061 
1062 bool HTMLElement::isActuallyDisabled() const
1063 {
1064     return canBeActuallyDisabled() &amp;&amp; isDisabledFormControl();
1065 }
1066 
1067 #if ENABLE(IOS_AUTOCORRECT_AND_AUTOCAPITALIZE)
1068 
1069 const AtomicString&amp; HTMLElement::autocapitalize() const
1070 {
1071     return stringForAutocapitalizeType(autocapitalizeType());
1072 }
1073 
1074 AutocapitalizeType HTMLElement::autocapitalizeType() const
1075 {
1076     return autocapitalizeTypeForAttributeValue(attributeWithoutSynchronization(HTMLNames::autocapitalizeAttr));
1077 }
1078 
1079 void HTMLElement::setAutocapitalize(const AtomicString&amp; value)
1080 {
1081     setAttributeWithoutSynchronization(autocapitalizeAttr, value);
1082 }
1083 
1084 bool HTMLElement::shouldAutocorrect() const
1085 {
1086     auto&amp; autocorrectValue = attributeWithoutSynchronization(HTMLNames::autocorrectAttr);
1087     // Unrecognized values fall back to &quot;on&quot;.
1088     return !equalLettersIgnoringASCIICase(autocorrectValue, &quot;off&quot;);
1089 }
1090 
1091 void HTMLElement::setAutocorrect(bool autocorrect)
1092 {
1093     setAttributeWithoutSynchronization(autocorrectAttr, autocorrect ? AtomicString(&quot;on&quot;, AtomicString::ConstructFromLiteral) : AtomicString(&quot;off&quot;, AtomicString::ConstructFromLiteral));
1094 }
1095 
1096 #endif
1097 
1098 InputMode HTMLElement::canonicalInputMode() const
1099 {
1100     return inputModeForAttributeValue(attributeWithoutSynchronization(inputmodeAttr));
1101 }
1102 
1103 const AtomicString&amp; HTMLElement::inputMode() const
1104 {
1105     return stringForInputMode(canonicalInputMode());
1106 }
1107 
1108 void HTMLElement::setInputMode(const AtomicString&amp; value)
1109 {
1110     setAttributeWithoutSynchronization(inputmodeAttr, value);
1111 }
1112 
1113 } // namespace WebCore
1114 
1115 #ifndef NDEBUG
1116 
1117 // For use in the debugger
1118 void dumpInnerHTML(WebCore::HTMLElement*);
1119 
1120 void dumpInnerHTML(WebCore::HTMLElement* element)
1121 {
1122     printf(&quot;%s\n&quot;, element-&gt;innerHTML().ascii().data());
1123 }
1124 
1125 #endif
    </pre>
  </body>
</html>