<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/dom/TreeScope.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="TreeScope.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="TreeScopeOrderedMap.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/dom/TreeScope.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 28,17 ***</span>
  
  #include &quot;TreeScopeOrderedMap.h&quot;
  #include &lt;memory&gt;
  #include &lt;wtf/Forward.h&gt;
  #include &lt;wtf/Vector.h&gt;
<span class="line-modified">! #include &lt;wtf/text/AtomicString.h&gt;</span>
  
  namespace WebCore {
  
  class ContainerNode;
  class Document;
  class Element;
  class HTMLImageElement;
  class HTMLLabelElement;
  class HTMLMapElement;
  class LayoutPoint;
  class IdTargetObserverRegistry;
<span class="line-new-header">--- 28,18 ---</span>
  
  #include &quot;TreeScopeOrderedMap.h&quot;
  #include &lt;memory&gt;
  #include &lt;wtf/Forward.h&gt;
  #include &lt;wtf/Vector.h&gt;
<span class="line-modified">! #include &lt;wtf/text/AtomString.h&gt;</span>
  
  namespace WebCore {
  
  class ContainerNode;
  class Document;
  class Element;
<span class="line-added">+ class FloatPoint;</span>
  class HTMLImageElement;
  class HTMLLabelElement;
  class HTMLMapElement;
  class LayoutPoint;
  class IdTargetObserverRegistry;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 53,24 ***</span>
      void setParentTreeScope(TreeScope&amp;);
  
      Element* focusedElementInScope();
      Element* pointerLockElement() const;
  
<span class="line-modified">!     WEBCORE_EXPORT Element* getElementById(const AtomicString&amp;) const;</span>
      WEBCORE_EXPORT Element* getElementById(const String&amp;) const;
      Element* getElementById(StringView) const;
<span class="line-modified">!     const Vector&lt;Element*&gt;* getAllElementsById(const AtomicString&amp;) const;</span>
<span class="line-modified">!     bool hasElementWithId(const AtomicStringImpl&amp;) const;</span>
<span class="line-modified">!     bool containsMultipleElementsWithId(const AtomicString&amp; id) const;</span>
<span class="line-modified">!     void addElementById(const AtomicStringImpl&amp; elementId, Element&amp;, bool notifyObservers = true);</span>
<span class="line-modified">!     void removeElementById(const AtomicStringImpl&amp; elementId, Element&amp;, bool notifyObservers = true);</span>
<span class="line-modified">! </span>
<span class="line-modified">!     WEBCORE_EXPORT Element* getElementByName(const AtomicString&amp;) const;</span>
<span class="line-modified">!     bool hasElementWithName(const AtomicStringImpl&amp;) const;</span>
<span class="line-modified">!     bool containsMultipleElementsWithName(const AtomicString&amp;) const;</span>
<span class="line-modified">!     void addElementByName(const AtomicStringImpl&amp;, Element&amp;);</span>
<span class="line-modified">!     void removeElementByName(const AtomicStringImpl&amp;, Element&amp;);</span>
  
      Document&amp; documentScope() const { return m_documentScope.get(); }
      static ptrdiff_t documentScopeMemoryOffset() { return OBJECT_OFFSETOF(TreeScope, m_documentScope); }
  
      // https://dom.spec.whatwg.org/#retarget
<span class="line-new-header">--- 54,24 ---</span>
      void setParentTreeScope(TreeScope&amp;);
  
      Element* focusedElementInScope();
      Element* pointerLockElement() const;
  
<span class="line-modified">!     WEBCORE_EXPORT Element* getElementById(const AtomString&amp;) const;</span>
      WEBCORE_EXPORT Element* getElementById(const String&amp;) const;
      Element* getElementById(StringView) const;
<span class="line-modified">!     const Vector&lt;Element*&gt;* getAllElementsById(const AtomString&amp;) const;</span>
<span class="line-modified">!     bool hasElementWithId(const AtomStringImpl&amp;) const;</span>
<span class="line-modified">!     bool containsMultipleElementsWithId(const AtomString&amp; id) const;</span>
<span class="line-modified">!     void addElementById(const AtomStringImpl&amp; elementId, Element&amp;, bool notifyObservers = true);</span>
<span class="line-modified">!     void removeElementById(const AtomStringImpl&amp; elementId, Element&amp;, bool notifyObservers = true);</span>
<span class="line-modified">! </span>
<span class="line-modified">!     WEBCORE_EXPORT Element* getElementByName(const AtomString&amp;) const;</span>
<span class="line-modified">!     bool hasElementWithName(const AtomStringImpl&amp;) const;</span>
<span class="line-modified">!     bool containsMultipleElementsWithName(const AtomString&amp;) const;</span>
<span class="line-modified">!     void addElementByName(const AtomStringImpl&amp;, Element&amp;);</span>
<span class="line-modified">!     void removeElementByName(const AtomStringImpl&amp;, Element&amp;);</span>
  
      Document&amp; documentScope() const { return m_documentScope.get(); }
      static ptrdiff_t documentScopeMemoryOffset() { return OBJECT_OFFSETOF(TreeScope, m_documentScope); }
  
      // https://dom.spec.whatwg.org/#retarget
</pre>
<hr />
<pre>
<span class="line-old-header">*** 79,24 ***</span>
      WEBCORE_EXPORT Node* ancestorNodeInThisScope(Node*) const;
      WEBCORE_EXPORT Element* ancestorElementInThisScope(Element*) const;
  
      void addImageMap(HTMLMapElement&amp;);
      void removeImageMap(HTMLMapElement&amp;);
<span class="line-modified">!     HTMLMapElement* getImageMap(const AtomicString&amp;) const;</span>
  
<span class="line-modified">!     void addImageElementByUsemap(const AtomicStringImpl&amp;, HTMLImageElement&amp;);</span>
<span class="line-modified">!     void removeImageElementByUsemap(const AtomicStringImpl&amp;, HTMLImageElement&amp;);</span>
<span class="line-modified">!     HTMLImageElement* imageElementByUsemap(const AtomicStringImpl&amp;) const;</span>
  
      // For accessibility.
      bool shouldCacheLabelsByForAttribute() const { return !!m_labelsByForAttribute; }
<span class="line-modified">!     void addLabel(const AtomicStringImpl&amp; forAttributeValue, HTMLLabelElement&amp;);</span>
<span class="line-modified">!     void removeLabel(const AtomicStringImpl&amp; forAttributeValue, HTMLLabelElement&amp;);</span>
<span class="line-modified">!     HTMLLabelElement* labelElementForId(const AtomicString&amp; forAttributeValue);</span>
  
      WEBCORE_EXPORT RefPtr&lt;Element&gt; elementFromPoint(double clientX, double clientY);
      WEBCORE_EXPORT Vector&lt;RefPtr&lt;Element&gt;&gt; elementsFromPoint(double clientX, double clientY);
  
      // Find first anchor with the given name.
      // First searches for an element with the given ID, but if that fails, then looks
      // for an anchor with the given name. ID matching is always case sensitive, but
      // Anchor name matching is case sensitive in strict mode and not case sensitive in
<span class="line-new-header">--- 80,25 ---</span>
      WEBCORE_EXPORT Node* ancestorNodeInThisScope(Node*) const;
      WEBCORE_EXPORT Element* ancestorElementInThisScope(Element*) const;
  
      void addImageMap(HTMLMapElement&amp;);
      void removeImageMap(HTMLMapElement&amp;);
<span class="line-modified">!     HTMLMapElement* getImageMap(const AtomString&amp;) const;</span>
  
<span class="line-modified">!     void addImageElementByUsemap(const AtomStringImpl&amp;, HTMLImageElement&amp;);</span>
<span class="line-modified">!     void removeImageElementByUsemap(const AtomStringImpl&amp;, HTMLImageElement&amp;);</span>
<span class="line-modified">!     HTMLImageElement* imageElementByUsemap(const AtomStringImpl&amp;) const;</span>
  
      // For accessibility.
      bool shouldCacheLabelsByForAttribute() const { return !!m_labelsByForAttribute; }
<span class="line-modified">!     void addLabel(const AtomStringImpl&amp; forAttributeValue, HTMLLabelElement&amp;);</span>
<span class="line-modified">!     void removeLabel(const AtomStringImpl&amp; forAttributeValue, HTMLLabelElement&amp;);</span>
<span class="line-modified">!     HTMLLabelElement* labelElementForId(const AtomString&amp; forAttributeValue);</span>
  
      WEBCORE_EXPORT RefPtr&lt;Element&gt; elementFromPoint(double clientX, double clientY);
      WEBCORE_EXPORT Vector&lt;RefPtr&lt;Element&gt;&gt; elementsFromPoint(double clientX, double clientY);
<span class="line-added">+     WEBCORE_EXPORT Vector&lt;RefPtr&lt;Element&gt;&gt; elementsFromPoint(const FloatPoint&amp;);</span>
  
      // Find first anchor with the given name.
      // First searches for an element with the given ID, but if that fails, then looks
      // for an anchor with the given name. ID matching is always case sensitive, but
      // Anchor name matching is case sensitive in strict mode and not case sensitive in
</pre>
<hr />
<pre>
<span class="line-old-header">*** 133,26 ***</span>
      std::unique_ptr&lt;TreeScopeOrderedMap&gt; m_labelsByForAttribute;
  
      std::unique_ptr&lt;IdTargetObserverRegistry&gt; m_idTargetObserverRegistry;
  };
  
<span class="line-modified">! inline bool TreeScope::hasElementWithId(const AtomicStringImpl&amp; id) const</span>
  {
      return m_elementsById &amp;&amp; m_elementsById-&gt;contains(id);
  }
  
<span class="line-modified">! inline bool TreeScope::containsMultipleElementsWithId(const AtomicString&amp; id) const</span>
  {
      return m_elementsById &amp;&amp; id.impl() &amp;&amp; m_elementsById-&gt;containsMultiple(*id.impl());
  }
  
<span class="line-modified">! inline bool TreeScope::hasElementWithName(const AtomicStringImpl&amp; id) const</span>
  {
      return m_elementsByName &amp;&amp; m_elementsByName-&gt;contains(id);
  }
  
<span class="line-modified">! inline bool TreeScope::containsMultipleElementsWithName(const AtomicString&amp; name) const</span>
  {
      return m_elementsByName &amp;&amp; name.impl() &amp;&amp; m_elementsByName-&gt;containsMultiple(*name.impl());
  }
  
  TreeScope* commonTreeScope(Node*, Node*);
<span class="line-new-header">--- 135,26 ---</span>
      std::unique_ptr&lt;TreeScopeOrderedMap&gt; m_labelsByForAttribute;
  
      std::unique_ptr&lt;IdTargetObserverRegistry&gt; m_idTargetObserverRegistry;
  };
  
<span class="line-modified">! inline bool TreeScope::hasElementWithId(const AtomStringImpl&amp; id) const</span>
  {
      return m_elementsById &amp;&amp; m_elementsById-&gt;contains(id);
  }
  
<span class="line-modified">! inline bool TreeScope::containsMultipleElementsWithId(const AtomString&amp; id) const</span>
  {
      return m_elementsById &amp;&amp; id.impl() &amp;&amp; m_elementsById-&gt;containsMultiple(*id.impl());
  }
  
<span class="line-modified">! inline bool TreeScope::hasElementWithName(const AtomStringImpl&amp; id) const</span>
  {
      return m_elementsByName &amp;&amp; m_elementsByName-&gt;contains(id);
  }
  
<span class="line-modified">! inline bool TreeScope::containsMultipleElementsWithName(const AtomString&amp; name) const</span>
  {
      return m_elementsByName &amp;&amp; name.impl() &amp;&amp; m_elementsByName-&gt;containsMultiple(*name.impl());
  }
  
  TreeScope* commonTreeScope(Node*, Node*);
</pre>
<center><a href="TreeScope.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="TreeScopeOrderedMap.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>