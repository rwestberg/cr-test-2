<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/editing/ReplaceSelectionCommand.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="ReplaceRangeWithTextCommand.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ReplaceSelectionCommand.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/editing/ReplaceSelectionCommand.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  14  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  15  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  16  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  17  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  18  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  19  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  20  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  21  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  22  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  23  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  24  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  25  */
  26 
  27 #include &quot;config.h&quot;
  28 #include &quot;ReplaceSelectionCommand.h&quot;
  29 
  30 #include &quot;AXObjectCache.h&quot;
  31 #include &quot;ApplyStyleCommand.h&quot;
  32 #include &quot;BeforeTextInsertedEvent.h&quot;
  33 #include &quot;BreakBlockquoteCommand.h&quot;

  34 #include &quot;CSSStyleDeclaration.h&quot;
  35 #include &quot;DOMWrapperWorld.h&quot;
  36 #include &quot;DataTransfer.h&quot;
  37 #include &quot;Document.h&quot;
  38 #include &quot;DocumentFragment.h&quot;
  39 #include &quot;Editing.h&quot;

  40 #include &quot;ElementIterator.h&quot;
  41 #include &quot;EventNames.h&quot;
  42 #include &quot;Frame.h&quot;
  43 #include &quot;FrameSelection.h&quot;
  44 #include &quot;HTMLBRElement.h&quot;
  45 #include &quot;HTMLBaseElement.h&quot;

  46 #include &quot;HTMLInputElement.h&quot;
  47 #include &quot;HTMLLIElement.h&quot;
  48 #include &quot;HTMLLinkElement.h&quot;
  49 #include &quot;HTMLMetaElement.h&quot;
  50 #include &quot;HTMLNames.h&quot;
  51 #include &quot;HTMLStyleElement.h&quot;
  52 #include &quot;HTMLTitleElement.h&quot;
  53 #include &quot;NodeList.h&quot;
  54 #include &quot;NodeRenderStyle.h&quot;
  55 #include &quot;RenderInline.h&quot;
  56 #include &quot;RenderText.h&quot;

  57 #include &quot;SimplifyMarkupCommand.h&quot;
  58 #include &quot;SmartReplace.h&quot;
  59 #include &quot;StyleProperties.h&quot;
  60 #include &quot;Text.h&quot;
  61 #include &quot;TextIterator.h&quot;
  62 #include &quot;VisibleUnits.h&quot;
  63 #include &quot;markup.h&quot;
  64 #include &lt;wtf/NeverDestroyed.h&gt;
  65 #include &lt;wtf/StdLibExtras.h&gt;
  66 
  67 namespace WebCore {
  68 
  69 using namespace HTMLNames;
  70 
  71 enum EFragmentType { EmptyFragment, SingleTextNodeFragment, TreeFragment };
  72 
<span class="line-removed">  73 static void removeHeadContents(ReplacementFragment&amp;);</span>
<span class="line-removed">  74 </span>
  75 // --- ReplacementFragment helper class
  76 
  77 class ReplacementFragment {
  78     WTF_MAKE_FAST_ALLOCATED;
  79     WTF_MAKE_NONCOPYABLE(ReplacementFragment);
  80 public:
<span class="line-modified">  81     ReplacementFragment(Document&amp;, DocumentFragment*, const VisibleSelection&amp;);</span>
  82 
  83     DocumentFragment* fragment() { return m_fragment.get(); }
  84 
  85     Node* firstChild() const;
  86     Node* lastChild() const;
  87 
  88     bool isEmpty() const;
  89 
  90     bool hasInterchangeNewlineAtStart() const { return m_hasInterchangeNewlineAtStart; }
  91     bool hasInterchangeNewlineAtEnd() const { return m_hasInterchangeNewlineAtEnd; }
  92 
  93     void removeNode(Node&amp;);
  94     void removeNodePreservingChildren(Node&amp;);
  95 
  96 private:

  97     Ref&lt;HTMLElement&gt; insertFragmentForTestRendering(Node* rootEditableNode);
  98     void removeUnrenderedNodes(Node*);
  99     void restoreAndRemoveTestRenderingNodesToFragment(StyledElement*);
 100     void removeInterchangeNodes(Node*);
 101 
 102     void insertNodeBefore(Node&amp;, Node&amp; refNode);
 103 
<span class="line-removed"> 104     Document&amp; document() { return *m_document; }</span>
<span class="line-removed"> 105 </span>
<span class="line-removed"> 106     RefPtr&lt;Document&gt; m_document;</span>
 107     RefPtr&lt;DocumentFragment&gt; m_fragment;
 108     bool m_hasInterchangeNewlineAtStart;
 109     bool m_hasInterchangeNewlineAtEnd;
 110 };
 111 
 112 static bool isInterchangeNewlineNode(const Node* node)
 113 {
 114     static NeverDestroyed&lt;String&gt; interchangeNewlineClassString(AppleInterchangeNewline);
 115     return is&lt;HTMLBRElement&gt;(node) &amp;&amp; downcast&lt;HTMLBRElement&gt;(*node).attributeWithoutSynchronization(classAttr) == interchangeNewlineClassString;
 116 }
 117 
 118 static bool isInterchangeConvertedSpaceSpan(const Node* node)
 119 {
 120     static NeverDestroyed&lt;String&gt; convertedSpaceSpanClassString(AppleConvertedSpace);
 121     return is&lt;HTMLElement&gt;(node) &amp;&amp; downcast&lt;HTMLElement&gt;(*node).attributeWithoutSynchronization(classAttr) == convertedSpaceSpanClassString;
 122 }
 123 
 124 static Position positionAvoidingPrecedingNodes(Position position)
 125 {
 126     ASSERT(position.isNotNull());
</pre>
<hr />
<pre>
 134     //   &lt;div&gt;foo^&lt;/div&gt;^
 135     // The two positions above are the same visual position, but we want to stay in the same block.
 136     auto* enclosingBlockNode = enclosingBlock(position.containerNode());
 137     for (Position nextPosition = position; nextPosition.containerNode() != enclosingBlockNode; position = nextPosition) {
 138         if (lineBreakExistsAtPosition(position))
 139             break;
 140 
 141         if (position.containerNode()-&gt;nonShadowBoundaryParentNode())
 142             nextPosition = positionInParentAfterNode(position.containerNode());
 143 
 144         if (nextPosition == position)
 145             break;
 146         if (enclosingBlock(nextPosition.containerNode()) != enclosingBlockNode)
 147             break;
 148         if (VisiblePosition(position) != VisiblePosition(nextPosition))
 149             break;
 150     }
 151     return position;
 152 }
 153 
<span class="line-modified"> 154 ReplacementFragment::ReplacementFragment(Document&amp; document, DocumentFragment* fragment, const VisibleSelection&amp; selection)</span>
<span class="line-modified"> 155     : m_document(&amp;document)</span>
<span class="line-removed"> 156     , m_fragment(fragment)</span>
 157     , m_hasInterchangeNewlineAtStart(false)
 158     , m_hasInterchangeNewlineAtEnd(false)
 159 {
 160     if (!m_fragment)
 161         return;
 162     if (!m_fragment-&gt;firstChild())
 163         return;
 164 


 165     RefPtr&lt;Element&gt; editableRoot = selection.rootEditableElement();
 166     ASSERT(editableRoot);
 167     if (!editableRoot)
 168         return;
 169 
 170     auto* shadowHost = editableRoot-&gt;shadowHost();
 171     if (!editableRoot-&gt;attributeEventListener(eventNames().webkitBeforeTextInsertedEvent, mainThreadNormalWorld())
 172         &amp;&amp; !(shadowHost &amp;&amp; shadowHost-&gt;renderer() &amp;&amp; shadowHost-&gt;renderer()-&gt;isTextControl())
 173         &amp;&amp; editableRoot-&gt;hasRichlyEditableStyle()) {
 174         removeInterchangeNodes(m_fragment.get());
 175         return;
 176     }
 177 
<span class="line-modified"> 178     RefPtr&lt;StyledElement&gt; holder = insertFragmentForTestRendering(editableRoot.get());</span>







 179     if (!holder) {
 180         removeInterchangeNodes(m_fragment.get());
 181         return;
 182     }
 183 
 184     RefPtr&lt;Range&gt; range = VisibleSelection::selectionFromContentsOfNode(holder.get()).toNormalizedRange();
 185     String text = plainText(range.get(), static_cast&lt;TextIteratorBehavior&gt;(TextIteratorEmitsOriginalText | TextIteratorIgnoresStyleVisibility));
 186 
 187     removeInterchangeNodes(holder.get());
 188     removeUnrenderedNodes(holder.get());
 189     restoreAndRemoveTestRenderingNodesToFragment(holder.get());
 190 
 191     // Give the root a chance to change the text.
 192     auto event = BeforeTextInsertedEvent::create(text);
 193     editableRoot-&gt;dispatchEvent(event);
 194     if (text != event-&gt;text() || !editableRoot-&gt;hasRichlyEditableStyle()) {
 195         restoreAndRemoveTestRenderingNodesToFragment(holder.get());
 196 
 197         RefPtr&lt;Range&gt; range = selection.toNormalizedRange();
 198         if (!range)
 199             return;
 200 
 201         m_fragment = createFragmentFromText(*range, event-&gt;text());
 202         if (!m_fragment-&gt;firstChild())
 203             return;
 204 
<span class="line-modified"> 205         holder = insertFragmentForTestRendering(editableRoot.get());</span>
 206         removeInterchangeNodes(holder.get());
 207         removeUnrenderedNodes(holder.get());
 208         restoreAndRemoveTestRenderingNodesToFragment(holder.get());
 209     }
 210 }
 211 































 212 bool ReplacementFragment::isEmpty() const
 213 {
 214     return (!m_fragment || !m_fragment-&gt;firstChild()) &amp;&amp; !m_hasInterchangeNewlineAtStart &amp;&amp; !m_hasInterchangeNewlineAtEnd;
 215 }
 216 
 217 Node *ReplacementFragment::firstChild() const
 218 {
 219     return m_fragment ? m_fragment-&gt;firstChild() : 0;
 220 }
 221 
 222 Node *ReplacementFragment::lastChild() const
 223 {
 224     return m_fragment ? m_fragment-&gt;lastChild() : 0;
 225 }
 226 
 227 void ReplacementFragment::removeNodePreservingChildren(Node&amp; node)
 228 {
 229     Ref&lt;Node&gt; protectedNode = node;
 230     while (RefPtr&lt;Node&gt; n = node.firstChild()) {
 231         removeNode(*n);
</pre>
<hr />
<pre>
 235 }
 236 
 237 void ReplacementFragment::removeNode(Node&amp; node)
 238 {
 239     ContainerNode* parent = node.nonShadowBoundaryParentNode();
 240     if (!parent)
 241         return;
 242 
 243     parent-&gt;removeChild(node);
 244 }
 245 
 246 void ReplacementFragment::insertNodeBefore(Node&amp; node, Node&amp; refNode)
 247 {
 248     ContainerNode* parent = refNode.nonShadowBoundaryParentNode();
 249     if (!parent)
 250         return;
 251 
 252     parent-&gt;insertBefore(node, &amp;refNode);
 253 }
 254 
<span class="line-modified"> 255 Ref&lt;HTMLElement&gt; ReplacementFragment::insertFragmentForTestRendering(Node* rootEditableElement)</span>
 256 {
<span class="line-modified"> 257     auto holder = createDefaultParagraphElement(document());</span>

 258 
 259     holder-&gt;appendChild(*m_fragment);
<span class="line-modified"> 260     rootEditableElement-&gt;appendChild(holder);</span>
<span class="line-modified"> 261     document().updateLayoutIgnorePendingStylesheets();</span>
 262 
 263     return holder;
 264 }
 265 
 266 void ReplacementFragment::restoreAndRemoveTestRenderingNodesToFragment(StyledElement* holder)
 267 {
 268     if (!holder)
 269         return;
 270 
 271     while (RefPtr&lt;Node&gt; node = holder-&gt;firstChild()) {
 272         holder-&gt;removeChild(*node);
 273         m_fragment-&gt;appendChild(*node);
 274     }
 275 
 276     removeNode(*holder);
 277 }
 278 
 279 void ReplacementFragment::removeUnrenderedNodes(Node* holder)
 280 {
 281     Vector&lt;Ref&lt;Node&gt;&gt; unrendered;
</pre>
<hr />
<pre>
 554                 insertedNodes.willRemoveNodePreservingChildren(element);
 555                 removeNodePreservingChildren(*element);
 556                 continue;
 557             }
 558             // There are other styles that style rules can give to style spans,
 559             // but these are the two important ones because they&#39;ll prevent
 560             // inserted content from appearing in the right paragraph.
 561             // FIXME: Hyatt is concerned that selectively using display:inline will give inconsistent
 562             // results. We already know one issue because td elements ignore their display property
 563             // in quirks mode (which Mail.app is always in). We should look for an alternative.
 564 
 565             // Mutate using the CSSOM wrapper so we get the same event behavior as a script.
 566             if (isBlock(element))
 567                 element-&gt;cssomStyle().setPropertyInternal(CSSPropertyDisplay, &quot;inline&quot;, false);
 568             if (element-&gt;renderer() &amp;&amp; element-&gt;renderer()-&gt;style().isFloating())
 569                 element-&gt;cssomStyle().setPropertyInternal(CSSPropertyFloat, &quot;none&quot;, false);
 570         }
 571     }
 572 }
 573 
<span class="line-modified"> 574 static bool isProhibitedParagraphChild(const AtomicString&amp; name)</span>
 575 {
 576     // https://dvcs.w3.org/hg/editing/raw-file/57abe6d3cb60/editing.html#prohibited-paragraph-child
 577     static const auto localNames = makeNeverDestroyed([] {
 578         static const HTMLQualifiedName* const tags[] = {
 579             &amp;addressTag.get(),
 580             &amp;articleTag.get(),
 581             &amp;asideTag.get(),
 582             &amp;blockquoteTag.get(),
 583             &amp;captionTag.get(),
 584             &amp;centerTag.get(),
 585             &amp;colTag.get(),
 586             &amp;colgroupTag.get(),
 587             &amp;ddTag.get(),
 588             &amp;detailsTag.get(),
 589             &amp;dirTag.get(),
 590             &amp;divTag.get(),
 591             &amp;dlTag.get(),
 592             &amp;dtTag.get(),
 593             &amp;fieldsetTag.get(),
 594             &amp;figcaptionTag.get(),
</pre>
<hr />
<pre>
 608             &amp;listingTag.get(),
 609             &amp;mainTag.get(), // Missing in the specification.
 610             &amp;menuTag.get(),
 611             &amp;navTag.get(),
 612             &amp;olTag.get(),
 613             &amp;pTag.get(),
 614             &amp;plaintextTag.get(),
 615             &amp;preTag.get(),
 616             &amp;sectionTag.get(),
 617             &amp;summaryTag.get(),
 618             &amp;tableTag.get(),
 619             &amp;tbodyTag.get(),
 620             &amp;tdTag.get(),
 621             &amp;tfootTag.get(),
 622             &amp;thTag.get(),
 623             &amp;theadTag.get(),
 624             &amp;trTag.get(),
 625             &amp;ulTag.get(),
 626             &amp;xmpTag.get(),
 627         };
<span class="line-modified"> 628         HashSet&lt;AtomicString&gt; set;</span>
 629         for (auto&amp; tag : tags)
 630             set.add(tag-&gt;localName());
 631         return set;
 632     }());
 633     return localNames.get().contains(name);
 634 }
 635 
 636 void ReplaceSelectionCommand::makeInsertedContentRoundTrippableWithHTMLTreeBuilder(InsertedNodes&amp; insertedNodes)
 637 {
 638     RefPtr&lt;Node&gt; pastEndNode = insertedNodes.pastLastLeaf();
 639     RefPtr&lt;Node&gt; next;
 640     for (RefPtr&lt;Node&gt; node = insertedNodes.firstNodeInserted(); node &amp;&amp; node != pastEndNode; node = next) {
 641         next = NodeTraversal::next(*node);
 642 
 643         if (!is&lt;HTMLElement&gt;(*node))
 644             continue;
 645 
 646         if (isProhibitedParagraphChild(downcast&lt;HTMLElement&gt;(*node).localName())) {
 647             if (auto* paragraphElement = enclosingElementWithTag(positionInParentBeforeNode(node.get()), pTag)) {
 648                 auto* parent = paragraphElement-&gt;parentNode();
 649                 if (parent &amp;&amp; parent-&gt;hasEditableStyle())
 650                     moveNodeOutOfAncestor(*node, *paragraphElement, insertedNodes);
 651             }
 652         }
 653 
 654         if (isHeaderElement(node.get())) {
 655             if (auto* headerElement = highestEnclosingNodeOfType(positionInParentBeforeNode(node.get()), isHeaderElement)) {
 656                 if (headerElement-&gt;parentNode() &amp;&amp; headerElement-&gt;parentNode()-&gt;isContentRichlyEditable())
 657                     moveNodeOutOfAncestor(*node, *headerElement, insertedNodes);
 658                 else {
 659                     HTMLElement* newSpanElement = replaceElementWithSpanPreservingChildrenAndAttributes(downcast&lt;HTMLElement&gt;(*node));
 660                     insertedNodes.didReplaceNode(node.get(), newSpanElement);
 661                 }
 662             }
 663         }
 664     }
 665 }
 666 





 667 void ReplaceSelectionCommand::moveNodeOutOfAncestor(Node&amp; node, Node&amp; ancestor, InsertedNodes&amp; insertedNodes)
 668 {
 669     Ref&lt;Node&gt; protectedNode = node;
 670     Ref&lt;Node&gt; protectedAncestor = ancestor;
 671 
 672     VisiblePosition positionAtEndOfNode = lastPositionInOrAfterNode(&amp;node);
 673     VisiblePosition lastPositionInParagraph = lastPositionInNode(&amp;ancestor);
 674     if (positionAtEndOfNode == lastPositionInParagraph) {
 675         removeNode(node);
 676         if (ancestor.nextSibling())
 677             insertNodeBefore(WTFMove(protectedNode), *ancestor.nextSibling());
 678         else
 679             appendNode(WTFMove(protectedNode), *ancestor.parentNode());
 680     } else {
 681         RefPtr&lt;Node&gt; nodeToSplitTo = splitTreeToNode(node, ancestor, true);
 682         removeNode(node);
 683         insertNodeBefore(WTFMove(protectedNode), *nodeToSplitTo);
 684     }
<span class="line-modified"> 685     if (!ancestor.firstChild()) {</span>
















 686         insertedNodes.willRemoveNode(&amp;ancestor);
 687         removeNode(ancestor);
 688     }
 689 }
 690 
<span class="line-removed"> 691 static inline bool hasRenderedText(const Text&amp; text)</span>
<span class="line-removed"> 692 {</span>
<span class="line-removed"> 693     return text.renderer() &amp;&amp; text.renderer()-&gt;hasRenderedText();</span>
<span class="line-removed"> 694 }</span>
<span class="line-removed"> 695 </span>
 696 void ReplaceSelectionCommand::removeUnrenderedTextNodesAtEnds(InsertedNodes&amp; insertedNodes)
 697 {
 698     document().updateLayoutIgnorePendingStylesheets();
 699 
 700     Node* lastLeafInserted = insertedNodes.lastLeafInserted();
 701     if (is&lt;Text&gt;(lastLeafInserted) &amp;&amp; !hasRenderedText(downcast&lt;Text&gt;(*lastLeafInserted))
 702         &amp;&amp; !enclosingElementWithTag(firstPositionInOrBeforeNode(lastLeafInserted), selectTag)
 703         &amp;&amp; !enclosingElementWithTag(firstPositionInOrBeforeNode(lastLeafInserted), scriptTag)) {
 704         insertedNodes.willRemoveNode(lastLeafInserted);
 705         removeNode(*lastLeafInserted);
 706     }
 707 
 708     // We don&#39;t have to make sure that firstNodeInserted isn&#39;t inside a select or script element
 709     // because it is a top level node in the fragment and the user can&#39;t insert into those elements.
 710     Node* firstNodeInserted = insertedNodes.firstNodeInserted();
 711     if (is&lt;Text&gt;(firstNodeInserted) &amp;&amp; !hasRenderedText(downcast&lt;Text&gt;(*firstNodeInserted))) {
 712         insertedNodes.willRemoveNode(firstNodeInserted);
 713         removeNode(*firstNodeInserted);
 714     }
 715 }
 716 
 717 VisiblePosition ReplaceSelectionCommand::positionAtEndOfInsertedContent() const
 718 {
 719     // FIXME: Why is this hack here?  What&#39;s special about &lt;select&gt; tags?
 720     auto* enclosingSelect = enclosingElementWithTag(m_endOfInsertedContent, selectTag);
 721     return enclosingSelect ? lastPositionInOrAfterNode(enclosingSelect) : m_endOfInsertedContent;
 722 }
 723 
 724 VisiblePosition ReplaceSelectionCommand::positionAtStartOfInsertedContent() const
 725 {
 726     return m_startOfInsertedContent;
 727 }
 728 
<span class="line-removed"> 729 static void removeHeadContents(ReplacementFragment&amp; fragment)</span>
<span class="line-removed"> 730 {</span>
<span class="line-removed"> 731     if (fragment.isEmpty())</span>
<span class="line-removed"> 732         return;</span>
<span class="line-removed"> 733 </span>
<span class="line-removed"> 734     Vector&lt;Element*&gt; toRemove;</span>
<span class="line-removed"> 735 </span>
<span class="line-removed"> 736     auto it = descendantsOfType&lt;Element&gt;(*fragment.fragment()).begin();</span>
<span class="line-removed"> 737     auto end = descendantsOfType&lt;Element&gt;(*fragment.fragment()).end();</span>
<span class="line-removed"> 738     while (it != end) {</span>
<span class="line-removed"> 739         if (is&lt;HTMLBaseElement&gt;(*it) || is&lt;HTMLLinkElement&gt;(*it) || is&lt;HTMLMetaElement&gt;(*it) || is&lt;HTMLTitleElement&gt;(*it)</span>
<span class="line-removed"> 740             || (is&lt;HTMLStyleElement&gt;(*it) &amp;&amp; it-&gt;getAttribute(classAttr) != WebKitMSOListQuirksStyle)) {</span>
<span class="line-removed"> 741             toRemove.append(&amp;*it);</span>
<span class="line-removed"> 742             it.traverseNextSkippingChildren();</span>
<span class="line-removed"> 743             continue;</span>
<span class="line-removed"> 744         }</span>
<span class="line-removed"> 745         ++it;</span>
<span class="line-removed"> 746     }</span>
<span class="line-removed"> 747 </span>
<span class="line-removed"> 748     for (auto&amp; element : toRemove)</span>
<span class="line-removed"> 749         fragment.removeNode(*element);</span>
<span class="line-removed"> 750 }</span>
<span class="line-removed"> 751 </span>
 752 // Remove style spans before insertion if they are unnecessary.  It&#39;s faster because we&#39;ll
 753 // avoid doing a layout.
 754 static bool handleStyleSpansBeforeInsertion(ReplacementFragment&amp; fragment, const Position&amp; insertionPos)
 755 {
 756     Node* topNode = fragment.firstChild();
 757 
 758     // Handling the case where we are doing Paste as Quotation or pasting into quoted content is more complicated (see handleStyleSpans)
 759     // and doesn&#39;t receive the optimization.
 760     if (isMailPasteAsQuotationNode(topNode) || enclosingNodeOfType(firstPositionInOrBeforeNode(topNode), isMailBlockquote, CanCrossEditingBoundary))
 761         return false;
 762 
 763     // Either there are no style spans in the fragment or a WebKit client has added content to the fragment
 764     // before inserting it.  Look for and handle style spans after insertion.
 765     if (!isLegacyAppleStyleSpan(topNode))
 766         return false;
 767 
 768     Node* wrappingStyleSpan = topNode;
 769     auto styleAtInsertionPos = EditingStyle::create(insertionPos.parentAnchoredEquivalent());
 770     String styleText = styleAtInsertionPos-&gt;style()-&gt;asText();
 771 
</pre>
<hr />
<pre>
 885             if (isBlockFlowElement(*sibling))
 886                 return node;
 887         }
 888         node = parent;
 889     }
 890     return node;
 891 }
 892 
 893 static bool isInlineNodeWithStyle(const Node* node)
 894 {
 895     // We don&#39;t want to skip over any block elements.
 896     if (isBlock(node))
 897         return false;
 898 
 899     if (!node-&gt;isHTMLElement())
 900         return false;
 901 
 902     // We can skip over elements whose class attribute is
 903     // one of our internal classes.
 904     const HTMLElement* element = static_cast&lt;const HTMLElement*&gt;(node);
<span class="line-modified"> 905     const AtomicString&amp; classAttributeValue = element-&gt;attributeWithoutSynchronization(classAttr);</span>
 906     if (classAttributeValue == AppleTabSpanClass
 907         || classAttributeValue == AppleConvertedSpace
 908         || classAttributeValue == ApplePasteAsQuotation)
 909         return true;
 910 
 911     return EditingStyle::elementIsStyledSpanOrHTMLEquivalent(*element);
 912 }
 913 
 914 inline Node* nodeToSplitToAvoidPastingIntoInlineNodesWithStyle(const Position&amp; insertionPos)
 915 {
 916     Node* containgBlock = enclosingBlock(insertionPos.containerNode());
 917     return highestEnclosingNodeOfType(insertionPos, isInlineNodeWithStyle, CannotCrossEditingBoundary, containgBlock);
 918 }
 919 
 920 bool ReplaceSelectionCommand::willApplyCommand()
 921 {
<span class="line-removed"> 922     ensureReplacementFragment();</span>
 923     m_documentFragmentPlainText = m_documentFragment-&gt;textContent();
 924     m_documentFragmentHTMLMarkup = serializeFragment(*m_documentFragment, SerializedNodes::SubtreeIncludingNode);

 925     return CompositeEditCommand::willApplyCommand();
 926 }
 927 












 928 void ReplaceSelectionCommand::doApply()
 929 {
 930     VisibleSelection selection = endingSelection();
 931     ASSERT(selection.isCaretOrRange());
 932     ASSERT(selection.start().deprecatedNode());
 933     if (selection.isNoneOrOrphaned() || !selection.start().deprecatedNode() || !selection.isContentEditable())
 934         return;
 935 
 936     // In plain text only regions, we create style-less fragments, so the inserted content will automatically
 937     // match the style of the surrounding area and so we can avoid unnecessary work below for m_matchStyle.
 938     if (!selection.isContentRichlyEditable())
 939         m_matchStyle = false;
 940 
 941     ReplacementFragment&amp; fragment = *ensureReplacementFragment();
 942     if (performTrivialReplace(fragment))
 943         return;
 944 
 945     // We can skip matching the style if the selection is plain text.
 946     if ((selection.start().deprecatedNode()-&gt;renderer() &amp;&amp; selection.start().deprecatedNode()-&gt;renderer()-&gt;style().userModify() == UserModify::ReadWritePlaintextOnly)
 947         &amp;&amp; (selection.end().deprecatedNode()-&gt;renderer() &amp;&amp; selection.end().deprecatedNode()-&gt;renderer()-&gt;style().userModify() == UserModify::ReadWritePlaintextOnly))
</pre>
<hr />
<pre>
1052             insertionPos = positionInParentAfterNode(insertionBlock.get());
1053         else if (isStartOfBlock(visibleInsertionPos))
1054             insertionPos = positionInParentBeforeNode(insertionBlock.get());
1055     }
1056 
1057     // Paste at start or end of link goes outside of link.
1058     insertionPos = positionAvoidingSpecialElementBoundary(insertionPos);
1059 
1060     // FIXME: Can this wait until after the operation has been performed?  There doesn&#39;t seem to be
1061     // any work performed after this that queries or uses the typing style.
1062     frame().selection().clearTypingStyle();
1063 
1064     // We don&#39;t want the destination to end up inside nodes that weren&#39;t selected.  To avoid that, we move the
1065     // position forward without changing the visible position so we&#39;re still at the same visible location, but
1066     // outside of preceding tags.
1067     insertionPos = positionAvoidingPrecedingNodes(insertionPos);
1068 
1069     // Paste into run of tabs splits the tab span.
1070     insertionPos = positionOutsideTabSpan(insertionPos);
1071 


1072     bool handledStyleSpans = handleStyleSpansBeforeInsertion(fragment, insertionPos);
1073 
1074     // We&#39;re finished if there is nothing to add.
1075     if (fragment.isEmpty() || !fragment.firstChild())
1076         return;
1077 
1078     // If we are not trying to match the destination style we prefer a position
1079     // that is outside inline elements that provide style.
1080     // This way we can produce a less verbose markup.
1081     // We can skip this optimization for fragments not wrapped in one of
1082     // our style spans and for positions inside list items
1083     // since insertAsListItems already does the right thing.
1084     if (!m_matchStyle &amp;&amp; !enclosingList(insertionPos.containerNode())) {
1085         if (insertionPos.containerNode()-&gt;isTextNode() &amp;&amp; insertionPos.offsetInContainerNode() &amp;&amp; !insertionPos.atLastEditingPositionForNode()) {
1086             splitTextNode(*insertionPos.containerText(), insertionPos.offsetInContainerNode());
1087             insertionPos = firstPositionInNode(insertionPos.containerNode());
1088         }
1089 
1090         if (RefPtr&lt;Node&gt; nodeToSplitTo = nodeToSplitToAvoidPastingIntoInlineNodesWithStyle(insertionPos)) {
1091             if (insertionPos.containerNode() != nodeToSplitTo-&gt;parentNode()) {
</pre>
<hr />
<pre>
1103     // again here if they&#39;ve been removed.
1104 
1105     // 1) Insert the content.
1106     // 2) Remove redundant styles and style tags, this inner &lt;b&gt; for example: &lt;b&gt;foo &lt;b&gt;bar&lt;/b&gt; baz&lt;/b&gt;.
1107     // 3) Merge the start of the added content with the content before the position being pasted into.
1108     // 4) Do one of the following: a) expand the last br if the fragment ends with one and it collapsed,
1109     // b) merge the last paragraph of the incoming fragment with the paragraph that contained the
1110     // end of the selection that was pasted into, or c) handle an interchange newline at the end of the
1111     // incoming fragment.
1112     // 5) Add spaces for smart replace.
1113     // 6) Select the replacement if requested, and match style if requested.
1114 
1115     InsertedNodes insertedNodes;
1116     RefPtr&lt;Node&gt; refNode = fragment.firstChild();
1117     RefPtr&lt;Node&gt; node = refNode-&gt;nextSibling();
1118 
1119     if (refNode)
1120         fragment.removeNode(*refNode);
1121 
1122     Node* blockStart = enclosingBlock(insertionPos.deprecatedNode());
<span class="line-modified">1123     if ((isListHTMLElement(refNode.get()) || (isLegacyAppleStyleSpan(refNode.get()) &amp;&amp; isListHTMLElement(refNode-&gt;firstChild())))</span>
<span class="line-modified">1124         &amp;&amp; blockStart &amp;&amp; blockStart-&gt;renderer()-&gt;isListItem())</span>

1125         refNode = insertAsListItems(downcast&lt;HTMLElement&gt;(*refNode), blockStart, insertionPos, insertedNodes);
1126     else {
1127         insertNodeAt(*refNode, insertionPos);
1128         insertedNodes.respondToNodeInsertion(refNode.get());
1129     }
1130 
1131     // Mutation events (bug 22634) may have already removed the inserted content
1132     if (!refNode-&gt;isConnected())
1133         return;
1134 
1135     bool plainTextFragment = isPlainTextMarkup(refNode.get());
1136 
1137     while (node) {
1138         RefPtr&lt;Node&gt; next = node-&gt;nextSibling();
1139         fragment.removeNode(*node);
1140         insertNodeAfter(*node, *refNode);
1141         insertedNodes.respondToNodeInsertion(node.get());
1142 
1143         // Mutation events (bug 22634) may have already removed the inserted content
1144         if (!node-&gt;isConnected())
</pre>
<hr />
<pre>
1253                 }
1254 
1255                 // Select up to the paragraph separator that was added.
1256                 lastPositionToSelect = endingSelection().visibleStart().deepEquivalent();
1257                 updateNodesInserted(lastPositionToSelect.deprecatedNode());
1258             }
1259         } else {
1260             // Select up to the beginning of the next paragraph.
1261             lastPositionToSelect = next.deepEquivalent().downstream();
1262         }
1263 
1264     } else
1265         mergeEndIfNeeded();
1266 
1267     if (Node* mailBlockquote = enclosingNodeOfType(positionAtStartOfInsertedContent().deepEquivalent(), isMailPasteAsQuotationNode))
1268         removeNodeAttribute(downcast&lt;Element&gt;(*mailBlockquote), classAttr);
1269 
1270     if (shouldPerformSmartReplace())
1271         addSpacesForSmartReplace();
1272 



1273     // If we are dealing with a fragment created from plain text
1274     // no style matching is necessary.
1275     if (plainTextFragment)
1276         m_matchStyle = false;
1277 
1278     completeHTMLReplacement(lastPositionToSelect);
1279 }
1280 
1281 String ReplaceSelectionCommand::inputEventData() const
1282 {
1283     if (isEditingTextAreaOrTextInput())
1284         return m_documentFragment-&gt;textContent();
1285 
1286     return CompositeEditCommand::inputEventData();
1287 }
1288 
1289 RefPtr&lt;DataTransfer&gt; ReplaceSelectionCommand::inputEventDataTransfer() const
1290 {
1291     if (isEditingTextAreaOrTextInput())
1292         return CompositeEditCommand::inputEventDataTransfer();
1293 
<span class="line-modified">1294     return DataTransfer::createForInputEvent(m_documentFragmentPlainText, m_documentFragmentHTMLMarkup);</span>
1295 }
1296 
1297 bool ReplaceSelectionCommand::shouldRemoveEndBR(Node* endBR, const VisiblePosition&amp; originalVisPosBeforeEndBR)
1298 {
1299     if (!endBR || !endBR-&gt;isConnected())
1300         return false;
1301 
1302     VisiblePosition visiblePos(positionBeforeNode(endBR));
1303 
1304     // Don&#39;t remove the br if nothing was inserted.
1305     if (visiblePos.previous() == originalVisPosBeforeEndBR)
1306         return false;
1307 
1308     // Remove the br if it is collapsed away and so is unnecessary.
1309     if (!document().inNoQuirksMode() &amp;&amp; isEndOfBlock(visiblePos) &amp;&amp; !isStartOfParagraph(visiblePos))
1310         return true;
1311 
1312     // A br that was originally holding a line open should be displaced by inserted content or turned into a line break.
1313     // A br that was originally acting as a line break should still be acting as a line break, not as a placeholder.
1314     return isStartOfParagraph(visiblePos) &amp;&amp; isEndOfParagraph(visiblePos);
1315 }
1316 
1317 bool ReplaceSelectionCommand::shouldPerformSmartReplace() const
1318 {
1319     if (!m_smartReplace)
1320         return false;
1321 
1322     Element* textControl = enclosingTextFormControl(positionAtStartOfInsertedContent().deepEquivalent());
1323     if (is&lt;HTMLInputElement&gt;(textControl) &amp;&amp; downcast&lt;HTMLInputElement&gt;(*textControl).isPasswordField())
1324         return false; // Disable smart replace for password fields.
1325 
1326     return true;
1327 }
1328 











1329 static bool isCharacterSmartReplaceExemptConsideringNonBreakingSpace(UChar32 character, bool previousCharacter)
1330 {
1331     return isCharacterSmartReplaceExempt(character == noBreakSpace ? &#39; &#39; : character, previousCharacter);
1332 }
1333 








































1334 void ReplaceSelectionCommand::addSpacesForSmartReplace()
1335 {
1336     VisiblePosition startOfInsertedContent = positionAtStartOfInsertedContent();
1337     VisiblePosition endOfInsertedContent = positionAtEndOfInsertedContent();
1338 
1339     Position endUpstream = endOfInsertedContent.deepEquivalent().upstream();
1340     Node* endNode = endUpstream.computeNodeBeforePosition();
1341     int endOffset = is&lt;Text&gt;(endNode) ? downcast&lt;Text&gt;(*endNode).length() : 0;
1342     if (endUpstream.anchorType() == Position::PositionIsOffsetInAnchor) {
1343         endNode = endUpstream.containerNode();
1344         endOffset = endUpstream.offsetInContainerNode();
1345     }
1346 
1347     bool needsTrailingSpace = !isEndOfParagraph(endOfInsertedContent) &amp;&amp; !isStartOfParagraph(endOfInsertedContent) &amp;&amp; !isCharacterSmartReplaceExemptConsideringNonBreakingSpace(endOfInsertedContent.characterAfter(), false);
1348     if (needsTrailingSpace &amp;&amp; endNode) {
1349         bool collapseWhiteSpace = !endNode-&gt;renderer() || endNode-&gt;renderer()-&gt;style().collapseWhiteSpace();
1350         if (is&lt;Text&gt;(*endNode)) {
1351             insertTextIntoNode(downcast&lt;Text&gt;(*endNode), endOffset, collapseWhiteSpace ? nonBreakingSpaceString() : &quot; &quot;);
1352             if (m_endOfInsertedContent.containerNode() == endNode)
1353                 m_endOfInsertedContent.moveToOffset(m_endOfInsertedContent.offsetInContainerNode() + 1);
</pre>
<hr />
<pre>
1527             ASSERT_NOT_REACHED();
1528     }
1529     if ((isStart || isMiddle) &amp;&amp; lastNode-&gt;previousSibling())
1530         lastNode = lastNode-&gt;previousSibling();
1531     return lastNode;
1532 }
1533 
1534 void ReplaceSelectionCommand::updateNodesInserted(Node *node)
1535 {
1536     if (!node)
1537         return;
1538 
1539     if (m_startOfInsertedContent.isNull())
1540         m_startOfInsertedContent = firstPositionInOrBeforeNode(node);
1541 
1542     m_endOfInsertedContent = lastPositionInOrAfterNode(node-&gt;lastDescendant());
1543 }
1544 
1545 ReplacementFragment* ReplaceSelectionCommand::ensureReplacementFragment()
1546 {
<span class="line-modified">1547     if (!m_replacementFragment) {</span>
<span class="line-modified">1548         m_replacementFragment = std::make_unique&lt;ReplacementFragment&gt;(document(), m_documentFragment.get(), endingSelection());</span>
<span class="line-removed">1549         removeHeadContents(*m_replacementFragment);</span>
<span class="line-removed">1550     }</span>
<span class="line-removed">1551 </span>
1552     return m_replacementFragment.get();
1553 }
1554 
1555 // During simple pastes, where we&#39;re just pasting a text node into a run of text, we insert the text node
1556 // directly into the text node that holds the selection.  This is much faster than the generalized code in
1557 // ReplaceSelectionCommand, and works around &lt;https://bugs.webkit.org/show_bug.cgi?id=6148&gt; since we don&#39;t
1558 // split text nodes.
1559 bool ReplaceSelectionCommand::performTrivialReplace(const ReplacementFragment&amp; fragment)
1560 {
1561     if (!is&lt;Text&gt;(fragment.firstChild()) || fragment.firstChild() != fragment.lastChild())
1562         return false;
1563 
1564     // FIXME: Would be nice to handle smart replace in the fast path.
1565     if (m_smartReplace || fragment.hasInterchangeNewlineAtStart() || fragment.hasInterchangeNewlineAtEnd())
1566         return false;
1567 
1568     // e.g. when &quot;bar&quot; is inserted after &quot;foo&quot; in &lt;div&gt;&lt;u&gt;foo&lt;/u&gt;&lt;/div&gt;, &quot;bar&quot; should not be underlined.
1569     if (nodeToSplitToAvoidPastingIntoInlineNodesWithStyle(endingSelection().start()))
1570         return false;
1571 
</pre>
</td>
<td>
<hr />
<pre>
  14  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  15  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  16  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  17  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  18  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  19  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  20  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  21  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  22  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  23  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  24  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  25  */
  26 
  27 #include &quot;config.h&quot;
  28 #include &quot;ReplaceSelectionCommand.h&quot;
  29 
  30 #include &quot;AXObjectCache.h&quot;
  31 #include &quot;ApplyStyleCommand.h&quot;
  32 #include &quot;BeforeTextInsertedEvent.h&quot;
  33 #include &quot;BreakBlockquoteCommand.h&quot;
<span class="line-added">  34 #include &quot;CSSComputedStyleDeclaration.h&quot;</span>
  35 #include &quot;CSSStyleDeclaration.h&quot;
  36 #include &quot;DOMWrapperWorld.h&quot;
  37 #include &quot;DataTransfer.h&quot;
  38 #include &quot;Document.h&quot;
  39 #include &quot;DocumentFragment.h&quot;
  40 #include &quot;Editing.h&quot;
<span class="line-added">  41 #include &quot;EditingBehavior.h&quot;</span>
  42 #include &quot;ElementIterator.h&quot;
  43 #include &quot;EventNames.h&quot;
  44 #include &quot;Frame.h&quot;
  45 #include &quot;FrameSelection.h&quot;
  46 #include &quot;HTMLBRElement.h&quot;
  47 #include &quot;HTMLBaseElement.h&quot;
<span class="line-added">  48 #include &quot;HTMLBodyElement.h&quot;</span>
  49 #include &quot;HTMLInputElement.h&quot;
  50 #include &quot;HTMLLIElement.h&quot;
  51 #include &quot;HTMLLinkElement.h&quot;
  52 #include &quot;HTMLMetaElement.h&quot;
  53 #include &quot;HTMLNames.h&quot;
  54 #include &quot;HTMLStyleElement.h&quot;
  55 #include &quot;HTMLTitleElement.h&quot;
  56 #include &quot;NodeList.h&quot;
  57 #include &quot;NodeRenderStyle.h&quot;
  58 #include &quot;RenderInline.h&quot;
  59 #include &quot;RenderText.h&quot;
<span class="line-added">  60 #include &quot;ScriptElement.h&quot;</span>
  61 #include &quot;SimplifyMarkupCommand.h&quot;
  62 #include &quot;SmartReplace.h&quot;
  63 #include &quot;StyleProperties.h&quot;
  64 #include &quot;Text.h&quot;
  65 #include &quot;TextIterator.h&quot;
  66 #include &quot;VisibleUnits.h&quot;
  67 #include &quot;markup.h&quot;
  68 #include &lt;wtf/NeverDestroyed.h&gt;
  69 #include &lt;wtf/StdLibExtras.h&gt;
  70 
  71 namespace WebCore {
  72 
  73 using namespace HTMLNames;
  74 
  75 enum EFragmentType { EmptyFragment, SingleTextNodeFragment, TreeFragment };
  76 


  77 // --- ReplacementFragment helper class
  78 
  79 class ReplacementFragment {
  80     WTF_MAKE_FAST_ALLOCATED;
  81     WTF_MAKE_NONCOPYABLE(ReplacementFragment);
  82 public:
<span class="line-modified">  83     ReplacementFragment(DocumentFragment*, const VisibleSelection&amp;);</span>
  84 
  85     DocumentFragment* fragment() { return m_fragment.get(); }
  86 
  87     Node* firstChild() const;
  88     Node* lastChild() const;
  89 
  90     bool isEmpty() const;
  91 
  92     bool hasInterchangeNewlineAtStart() const { return m_hasInterchangeNewlineAtStart; }
  93     bool hasInterchangeNewlineAtEnd() const { return m_hasInterchangeNewlineAtEnd; }
  94 
  95     void removeNode(Node&amp;);
  96     void removeNodePreservingChildren(Node&amp;);
  97 
  98 private:
<span class="line-added">  99     void removeContentsWithSideEffects();</span>
 100     Ref&lt;HTMLElement&gt; insertFragmentForTestRendering(Node* rootEditableNode);
 101     void removeUnrenderedNodes(Node*);
 102     void restoreAndRemoveTestRenderingNodesToFragment(StyledElement*);
 103     void removeInterchangeNodes(Node*);
 104 
 105     void insertNodeBefore(Node&amp;, Node&amp; refNode);
 106 



 107     RefPtr&lt;DocumentFragment&gt; m_fragment;
 108     bool m_hasInterchangeNewlineAtStart;
 109     bool m_hasInterchangeNewlineAtEnd;
 110 };
 111 
 112 static bool isInterchangeNewlineNode(const Node* node)
 113 {
 114     static NeverDestroyed&lt;String&gt; interchangeNewlineClassString(AppleInterchangeNewline);
 115     return is&lt;HTMLBRElement&gt;(node) &amp;&amp; downcast&lt;HTMLBRElement&gt;(*node).attributeWithoutSynchronization(classAttr) == interchangeNewlineClassString;
 116 }
 117 
 118 static bool isInterchangeConvertedSpaceSpan(const Node* node)
 119 {
 120     static NeverDestroyed&lt;String&gt; convertedSpaceSpanClassString(AppleConvertedSpace);
 121     return is&lt;HTMLElement&gt;(node) &amp;&amp; downcast&lt;HTMLElement&gt;(*node).attributeWithoutSynchronization(classAttr) == convertedSpaceSpanClassString;
 122 }
 123 
 124 static Position positionAvoidingPrecedingNodes(Position position)
 125 {
 126     ASSERT(position.isNotNull());
</pre>
<hr />
<pre>
 134     //   &lt;div&gt;foo^&lt;/div&gt;^
 135     // The two positions above are the same visual position, but we want to stay in the same block.
 136     auto* enclosingBlockNode = enclosingBlock(position.containerNode());
 137     for (Position nextPosition = position; nextPosition.containerNode() != enclosingBlockNode; position = nextPosition) {
 138         if (lineBreakExistsAtPosition(position))
 139             break;
 140 
 141         if (position.containerNode()-&gt;nonShadowBoundaryParentNode())
 142             nextPosition = positionInParentAfterNode(position.containerNode());
 143 
 144         if (nextPosition == position)
 145             break;
 146         if (enclosingBlock(nextPosition.containerNode()) != enclosingBlockNode)
 147             break;
 148         if (VisiblePosition(position) != VisiblePosition(nextPosition))
 149             break;
 150     }
 151     return position;
 152 }
 153 
<span class="line-modified"> 154 ReplacementFragment::ReplacementFragment(DocumentFragment* fragment, const VisibleSelection&amp; selection)</span>
<span class="line-modified"> 155     : m_fragment(fragment)</span>

 156     , m_hasInterchangeNewlineAtStart(false)
 157     , m_hasInterchangeNewlineAtEnd(false)
 158 {
 159     if (!m_fragment)
 160         return;
 161     if (!m_fragment-&gt;firstChild())
 162         return;
 163 
<span class="line-added"> 164     removeContentsWithSideEffects();</span>
<span class="line-added"> 165 </span>
 166     RefPtr&lt;Element&gt; editableRoot = selection.rootEditableElement();
 167     ASSERT(editableRoot);
 168     if (!editableRoot)
 169         return;
 170 
 171     auto* shadowHost = editableRoot-&gt;shadowHost();
 172     if (!editableRoot-&gt;attributeEventListener(eventNames().webkitBeforeTextInsertedEvent, mainThreadNormalWorld())
 173         &amp;&amp; !(shadowHost &amp;&amp; shadowHost-&gt;renderer() &amp;&amp; shadowHost-&gt;renderer()-&gt;isTextControl())
 174         &amp;&amp; editableRoot-&gt;hasRichlyEditableStyle()) {
 175         removeInterchangeNodes(m_fragment.get());
 176         return;
 177     }
 178 
<span class="line-modified"> 179     auto page = createPageForSanitizingWebContent();</span>
<span class="line-added"> 180     Document* stagingDocument = page-&gt;mainFrame().document();</span>
<span class="line-added"> 181     ASSERT(stagingDocument-&gt;body());</span>
<span class="line-added"> 182 </span>
<span class="line-added"> 183     ComputedStyleExtractor computedStyleOfEditableRoot(editableRoot.get());</span>
<span class="line-added"> 184     stagingDocument-&gt;body()-&gt;setAttributeWithoutSynchronization(styleAttr, computedStyleOfEditableRoot.copyProperties()-&gt;asText());</span>
<span class="line-added"> 185 </span>
<span class="line-added"> 186     RefPtr&lt;StyledElement&gt; holder = insertFragmentForTestRendering(stagingDocument-&gt;body());</span>
 187     if (!holder) {
 188         removeInterchangeNodes(m_fragment.get());
 189         return;
 190     }
 191 
 192     RefPtr&lt;Range&gt; range = VisibleSelection::selectionFromContentsOfNode(holder.get()).toNormalizedRange();
 193     String text = plainText(range.get(), static_cast&lt;TextIteratorBehavior&gt;(TextIteratorEmitsOriginalText | TextIteratorIgnoresStyleVisibility));
 194 
 195     removeInterchangeNodes(holder.get());
 196     removeUnrenderedNodes(holder.get());
 197     restoreAndRemoveTestRenderingNodesToFragment(holder.get());
 198 
 199     // Give the root a chance to change the text.
 200     auto event = BeforeTextInsertedEvent::create(text);
 201     editableRoot-&gt;dispatchEvent(event);
 202     if (text != event-&gt;text() || !editableRoot-&gt;hasRichlyEditableStyle()) {
 203         restoreAndRemoveTestRenderingNodesToFragment(holder.get());
 204 
 205         RefPtr&lt;Range&gt; range = selection.toNormalizedRange();
 206         if (!range)
 207             return;
 208 
 209         m_fragment = createFragmentFromText(*range, event-&gt;text());
 210         if (!m_fragment-&gt;firstChild())
 211             return;
 212 
<span class="line-modified"> 213         holder = insertFragmentForTestRendering(stagingDocument-&gt;body());</span>
 214         removeInterchangeNodes(holder.get());
 215         removeUnrenderedNodes(holder.get());
 216         restoreAndRemoveTestRenderingNodesToFragment(holder.get());
 217     }
 218 }
 219 
<span class="line-added"> 220 void ReplacementFragment::removeContentsWithSideEffects()</span>
<span class="line-added"> 221 {</span>
<span class="line-added"> 222     Vector&lt;Ref&lt;Element&gt;&gt; elementsToRemove;</span>
<span class="line-added"> 223     Vector&lt;std::pair&lt;Ref&lt;Element&gt;, QualifiedName&gt;&gt; attributesToRemove;</span>
<span class="line-added"> 224 </span>
<span class="line-added"> 225     auto it = descendantsOfType&lt;Element&gt;(*m_fragment).begin();</span>
<span class="line-added"> 226     auto end = descendantsOfType&lt;Element&gt;(*m_fragment).end();</span>
<span class="line-added"> 227     while (it != end) {</span>
<span class="line-added"> 228         auto element = makeRef(*it);</span>
<span class="line-added"> 229         if (isScriptElement(element) || (is&lt;HTMLStyleElement&gt;(element) &amp;&amp; element-&gt;getAttribute(classAttr) != WebKitMSOListQuirksStyle)</span>
<span class="line-added"> 230             || is&lt;HTMLBaseElement&gt;(element) || is&lt;HTMLLinkElement&gt;(element) || is&lt;HTMLMetaElement&gt;(element) || is&lt;HTMLTitleElement&gt;(element)) {</span>
<span class="line-added"> 231             elementsToRemove.append(WTFMove(element));</span>
<span class="line-added"> 232             it.traverseNextSkippingChildren();</span>
<span class="line-added"> 233             continue;</span>
<span class="line-added"> 234         }</span>
<span class="line-added"> 235         if (element-&gt;hasAttributes()) {</span>
<span class="line-added"> 236             for (auto&amp; attribute : element-&gt;attributesIterator()) {</span>
<span class="line-added"> 237                 if (element-&gt;isEventHandlerAttribute(attribute) || element-&gt;isJavaScriptURLAttribute(attribute))</span>
<span class="line-added"> 238                     attributesToRemove.append({ element.copyRef(), attribute.name() });</span>
<span class="line-added"> 239             }</span>
<span class="line-added"> 240         }</span>
<span class="line-added"> 241         ++it;</span>
<span class="line-added"> 242     }</span>
<span class="line-added"> 243 </span>
<span class="line-added"> 244     for (auto&amp; element : elementsToRemove)</span>
<span class="line-added"> 245         removeNode(WTFMove(element));</span>
<span class="line-added"> 246 </span>
<span class="line-added"> 247     for (auto&amp; item : attributesToRemove)</span>
<span class="line-added"> 248         item.first-&gt;removeAttribute(item.second);</span>
<span class="line-added"> 249 }</span>
<span class="line-added"> 250 </span>
 251 bool ReplacementFragment::isEmpty() const
 252 {
 253     return (!m_fragment || !m_fragment-&gt;firstChild()) &amp;&amp; !m_hasInterchangeNewlineAtStart &amp;&amp; !m_hasInterchangeNewlineAtEnd;
 254 }
 255 
 256 Node *ReplacementFragment::firstChild() const
 257 {
 258     return m_fragment ? m_fragment-&gt;firstChild() : 0;
 259 }
 260 
 261 Node *ReplacementFragment::lastChild() const
 262 {
 263     return m_fragment ? m_fragment-&gt;lastChild() : 0;
 264 }
 265 
 266 void ReplacementFragment::removeNodePreservingChildren(Node&amp; node)
 267 {
 268     Ref&lt;Node&gt; protectedNode = node;
 269     while (RefPtr&lt;Node&gt; n = node.firstChild()) {
 270         removeNode(*n);
</pre>
<hr />
<pre>
 274 }
 275 
 276 void ReplacementFragment::removeNode(Node&amp; node)
 277 {
 278     ContainerNode* parent = node.nonShadowBoundaryParentNode();
 279     if (!parent)
 280         return;
 281 
 282     parent-&gt;removeChild(node);
 283 }
 284 
 285 void ReplacementFragment::insertNodeBefore(Node&amp; node, Node&amp; refNode)
 286 {
 287     ContainerNode* parent = refNode.nonShadowBoundaryParentNode();
 288     if (!parent)
 289         return;
 290 
 291     parent-&gt;insertBefore(node, &amp;refNode);
 292 }
 293 
<span class="line-modified"> 294 Ref&lt;HTMLElement&gt; ReplacementFragment::insertFragmentForTestRendering(Node* rootNode)</span>
 295 {
<span class="line-modified"> 296     auto document = makeRef(rootNode-&gt;document());</span>
<span class="line-added"> 297     auto holder = createDefaultParagraphElement(document.get());</span>
 298 
 299     holder-&gt;appendChild(*m_fragment);
<span class="line-modified"> 300     rootNode-&gt;appendChild(holder);</span>
<span class="line-modified"> 301     document-&gt;updateLayoutIgnorePendingStylesheets();</span>
 302 
 303     return holder;
 304 }
 305 
 306 void ReplacementFragment::restoreAndRemoveTestRenderingNodesToFragment(StyledElement* holder)
 307 {
 308     if (!holder)
 309         return;
 310 
 311     while (RefPtr&lt;Node&gt; node = holder-&gt;firstChild()) {
 312         holder-&gt;removeChild(*node);
 313         m_fragment-&gt;appendChild(*node);
 314     }
 315 
 316     removeNode(*holder);
 317 }
 318 
 319 void ReplacementFragment::removeUnrenderedNodes(Node* holder)
 320 {
 321     Vector&lt;Ref&lt;Node&gt;&gt; unrendered;
</pre>
<hr />
<pre>
 594                 insertedNodes.willRemoveNodePreservingChildren(element);
 595                 removeNodePreservingChildren(*element);
 596                 continue;
 597             }
 598             // There are other styles that style rules can give to style spans,
 599             // but these are the two important ones because they&#39;ll prevent
 600             // inserted content from appearing in the right paragraph.
 601             // FIXME: Hyatt is concerned that selectively using display:inline will give inconsistent
 602             // results. We already know one issue because td elements ignore their display property
 603             // in quirks mode (which Mail.app is always in). We should look for an alternative.
 604 
 605             // Mutate using the CSSOM wrapper so we get the same event behavior as a script.
 606             if (isBlock(element))
 607                 element-&gt;cssomStyle().setPropertyInternal(CSSPropertyDisplay, &quot;inline&quot;, false);
 608             if (element-&gt;renderer() &amp;&amp; element-&gt;renderer()-&gt;style().isFloating())
 609                 element-&gt;cssomStyle().setPropertyInternal(CSSPropertyFloat, &quot;none&quot;, false);
 610         }
 611     }
 612 }
 613 
<span class="line-modified"> 614 static bool isProhibitedParagraphChild(const AtomString&amp; name)</span>
 615 {
 616     // https://dvcs.w3.org/hg/editing/raw-file/57abe6d3cb60/editing.html#prohibited-paragraph-child
 617     static const auto localNames = makeNeverDestroyed([] {
 618         static const HTMLQualifiedName* const tags[] = {
 619             &amp;addressTag.get(),
 620             &amp;articleTag.get(),
 621             &amp;asideTag.get(),
 622             &amp;blockquoteTag.get(),
 623             &amp;captionTag.get(),
 624             &amp;centerTag.get(),
 625             &amp;colTag.get(),
 626             &amp;colgroupTag.get(),
 627             &amp;ddTag.get(),
 628             &amp;detailsTag.get(),
 629             &amp;dirTag.get(),
 630             &amp;divTag.get(),
 631             &amp;dlTag.get(),
 632             &amp;dtTag.get(),
 633             &amp;fieldsetTag.get(),
 634             &amp;figcaptionTag.get(),
</pre>
<hr />
<pre>
 648             &amp;listingTag.get(),
 649             &amp;mainTag.get(), // Missing in the specification.
 650             &amp;menuTag.get(),
 651             &amp;navTag.get(),
 652             &amp;olTag.get(),
 653             &amp;pTag.get(),
 654             &amp;plaintextTag.get(),
 655             &amp;preTag.get(),
 656             &amp;sectionTag.get(),
 657             &amp;summaryTag.get(),
 658             &amp;tableTag.get(),
 659             &amp;tbodyTag.get(),
 660             &amp;tdTag.get(),
 661             &amp;tfootTag.get(),
 662             &amp;thTag.get(),
 663             &amp;theadTag.get(),
 664             &amp;trTag.get(),
 665             &amp;ulTag.get(),
 666             &amp;xmpTag.get(),
 667         };
<span class="line-modified"> 668         HashSet&lt;AtomString&gt; set;</span>
 669         for (auto&amp; tag : tags)
 670             set.add(tag-&gt;localName());
 671         return set;
 672     }());
 673     return localNames.get().contains(name);
 674 }
 675 
 676 void ReplaceSelectionCommand::makeInsertedContentRoundTrippableWithHTMLTreeBuilder(InsertedNodes&amp; insertedNodes)
 677 {
 678     RefPtr&lt;Node&gt; pastEndNode = insertedNodes.pastLastLeaf();
 679     RefPtr&lt;Node&gt; next;
 680     for (RefPtr&lt;Node&gt; node = insertedNodes.firstNodeInserted(); node &amp;&amp; node != pastEndNode; node = next) {
 681         next = NodeTraversal::next(*node);
 682 
 683         if (!is&lt;HTMLElement&gt;(*node))
 684             continue;
 685 
 686         if (isProhibitedParagraphChild(downcast&lt;HTMLElement&gt;(*node).localName())) {
 687             if (auto* paragraphElement = enclosingElementWithTag(positionInParentBeforeNode(node.get()), pTag)) {
 688                 auto* parent = paragraphElement-&gt;parentNode();
 689                 if (parent &amp;&amp; parent-&gt;hasEditableStyle())
 690                     moveNodeOutOfAncestor(*node, *paragraphElement, insertedNodes);
 691             }
 692         }
 693 
 694         if (isHeaderElement(node.get())) {
 695             if (auto* headerElement = highestEnclosingNodeOfType(positionInParentBeforeNode(node.get()), isHeaderElement)) {
 696                 if (headerElement-&gt;parentNode() &amp;&amp; headerElement-&gt;parentNode()-&gt;isContentRichlyEditable())
 697                     moveNodeOutOfAncestor(*node, *headerElement, insertedNodes);
 698                 else {
 699                     HTMLElement* newSpanElement = replaceElementWithSpanPreservingChildrenAndAttributes(downcast&lt;HTMLElement&gt;(*node));
 700                     insertedNodes.didReplaceNode(node.get(), newSpanElement);
 701                 }
 702             }
 703         }
 704     }
 705 }
 706 
<span class="line-added"> 707 static inline bool hasRenderedText(const Text&amp; text)</span>
<span class="line-added"> 708 {</span>
<span class="line-added"> 709     return text.renderer() &amp;&amp; text.renderer()-&gt;hasRenderedText();</span>
<span class="line-added"> 710 }</span>
<span class="line-added"> 711 </span>
 712 void ReplaceSelectionCommand::moveNodeOutOfAncestor(Node&amp; node, Node&amp; ancestor, InsertedNodes&amp; insertedNodes)
 713 {
 714     Ref&lt;Node&gt; protectedNode = node;
 715     Ref&lt;Node&gt; protectedAncestor = ancestor;
 716 
 717     VisiblePosition positionAtEndOfNode = lastPositionInOrAfterNode(&amp;node);
 718     VisiblePosition lastPositionInParagraph = lastPositionInNode(&amp;ancestor);
 719     if (positionAtEndOfNode == lastPositionInParagraph) {
 720         removeNode(node);
 721         if (ancestor.nextSibling())
 722             insertNodeBefore(WTFMove(protectedNode), *ancestor.nextSibling());
 723         else
 724             appendNode(WTFMove(protectedNode), *ancestor.parentNode());
 725     } else {
 726         RefPtr&lt;Node&gt; nodeToSplitTo = splitTreeToNode(node, ancestor, true);
 727         removeNode(node);
 728         insertNodeBefore(WTFMove(protectedNode), *nodeToSplitTo);
 729     }
<span class="line-modified"> 730 </span>
<span class="line-added"> 731     document().updateLayoutIgnorePendingStylesheets();</span>
<span class="line-added"> 732 </span>
<span class="line-added"> 733     bool safeToRemoveAncestor = true;</span>
<span class="line-added"> 734     for (auto* child = ancestor.firstChild(); child; child = child-&gt;nextSibling()) {</span>
<span class="line-added"> 735         if (is&lt;Text&gt;(child) &amp;&amp; hasRenderedText(downcast&lt;Text&gt;(*child))) {</span>
<span class="line-added"> 736             safeToRemoveAncestor = false;</span>
<span class="line-added"> 737             break;</span>
<span class="line-added"> 738         }</span>
<span class="line-added"> 739 </span>
<span class="line-added"> 740         if (is&lt;Element&gt;(child)) {</span>
<span class="line-added"> 741             safeToRemoveAncestor = false;</span>
<span class="line-added"> 742             break;</span>
<span class="line-added"> 743         }</span>
<span class="line-added"> 744     }</span>
<span class="line-added"> 745 </span>
<span class="line-added"> 746     if (safeToRemoveAncestor) {</span>
 747         insertedNodes.willRemoveNode(&amp;ancestor);
 748         removeNode(ancestor);
 749     }
 750 }
 751 





 752 void ReplaceSelectionCommand::removeUnrenderedTextNodesAtEnds(InsertedNodes&amp; insertedNodes)
 753 {
 754     document().updateLayoutIgnorePendingStylesheets();
 755 
 756     Node* lastLeafInserted = insertedNodes.lastLeafInserted();
 757     if (is&lt;Text&gt;(lastLeafInserted) &amp;&amp; !hasRenderedText(downcast&lt;Text&gt;(*lastLeafInserted))
 758         &amp;&amp; !enclosingElementWithTag(firstPositionInOrBeforeNode(lastLeafInserted), selectTag)
 759         &amp;&amp; !enclosingElementWithTag(firstPositionInOrBeforeNode(lastLeafInserted), scriptTag)) {
 760         insertedNodes.willRemoveNode(lastLeafInserted);
 761         removeNode(*lastLeafInserted);
 762     }
 763 
 764     // We don&#39;t have to make sure that firstNodeInserted isn&#39;t inside a select or script element
 765     // because it is a top level node in the fragment and the user can&#39;t insert into those elements.
 766     Node* firstNodeInserted = insertedNodes.firstNodeInserted();
 767     if (is&lt;Text&gt;(firstNodeInserted) &amp;&amp; !hasRenderedText(downcast&lt;Text&gt;(*firstNodeInserted))) {
 768         insertedNodes.willRemoveNode(firstNodeInserted);
 769         removeNode(*firstNodeInserted);
 770     }
 771 }
 772 
 773 VisiblePosition ReplaceSelectionCommand::positionAtEndOfInsertedContent() const
 774 {
 775     // FIXME: Why is this hack here?  What&#39;s special about &lt;select&gt; tags?
 776     auto* enclosingSelect = enclosingElementWithTag(m_endOfInsertedContent, selectTag);
 777     return enclosingSelect ? lastPositionInOrAfterNode(enclosingSelect) : m_endOfInsertedContent;
 778 }
 779 
 780 VisiblePosition ReplaceSelectionCommand::positionAtStartOfInsertedContent() const
 781 {
 782     return m_startOfInsertedContent;
 783 }
 784 























 785 // Remove style spans before insertion if they are unnecessary.  It&#39;s faster because we&#39;ll
 786 // avoid doing a layout.
 787 static bool handleStyleSpansBeforeInsertion(ReplacementFragment&amp; fragment, const Position&amp; insertionPos)
 788 {
 789     Node* topNode = fragment.firstChild();
 790 
 791     // Handling the case where we are doing Paste as Quotation or pasting into quoted content is more complicated (see handleStyleSpans)
 792     // and doesn&#39;t receive the optimization.
 793     if (isMailPasteAsQuotationNode(topNode) || enclosingNodeOfType(firstPositionInOrBeforeNode(topNode), isMailBlockquote, CanCrossEditingBoundary))
 794         return false;
 795 
 796     // Either there are no style spans in the fragment or a WebKit client has added content to the fragment
 797     // before inserting it.  Look for and handle style spans after insertion.
 798     if (!isLegacyAppleStyleSpan(topNode))
 799         return false;
 800 
 801     Node* wrappingStyleSpan = topNode;
 802     auto styleAtInsertionPos = EditingStyle::create(insertionPos.parentAnchoredEquivalent());
 803     String styleText = styleAtInsertionPos-&gt;style()-&gt;asText();
 804 
</pre>
<hr />
<pre>
 918             if (isBlockFlowElement(*sibling))
 919                 return node;
 920         }
 921         node = parent;
 922     }
 923     return node;
 924 }
 925 
 926 static bool isInlineNodeWithStyle(const Node* node)
 927 {
 928     // We don&#39;t want to skip over any block elements.
 929     if (isBlock(node))
 930         return false;
 931 
 932     if (!node-&gt;isHTMLElement())
 933         return false;
 934 
 935     // We can skip over elements whose class attribute is
 936     // one of our internal classes.
 937     const HTMLElement* element = static_cast&lt;const HTMLElement*&gt;(node);
<span class="line-modified"> 938     const AtomString&amp; classAttributeValue = element-&gt;attributeWithoutSynchronization(classAttr);</span>
 939     if (classAttributeValue == AppleTabSpanClass
 940         || classAttributeValue == AppleConvertedSpace
 941         || classAttributeValue == ApplePasteAsQuotation)
 942         return true;
 943 
 944     return EditingStyle::elementIsStyledSpanOrHTMLEquivalent(*element);
 945 }
 946 
 947 inline Node* nodeToSplitToAvoidPastingIntoInlineNodesWithStyle(const Position&amp; insertionPos)
 948 {
 949     Node* containgBlock = enclosingBlock(insertionPos.containerNode());
 950     return highestEnclosingNodeOfType(insertionPos, isInlineNodeWithStyle, CannotCrossEditingBoundary, containgBlock);
 951 }
 952 
 953 bool ReplaceSelectionCommand::willApplyCommand()
 954 {

 955     m_documentFragmentPlainText = m_documentFragment-&gt;textContent();
 956     m_documentFragmentHTMLMarkup = serializeFragment(*m_documentFragment, SerializedNodes::SubtreeIncludingNode);
<span class="line-added"> 957     ensureReplacementFragment();</span>
 958     return CompositeEditCommand::willApplyCommand();
 959 }
 960 
<span class="line-added"> 961 static bool hasBlankLineBetweenParagraphs(Position&amp; position)</span>
<span class="line-added"> 962 {</span>
<span class="line-added"> 963     bool reachedBoundaryStart = false;</span>
<span class="line-added"> 964     bool reachedBoundaryEnd = false;</span>
<span class="line-added"> 965     VisiblePosition visiblePosition(position);</span>
<span class="line-added"> 966     VisiblePosition previousPosition = visiblePosition.previous(CannotCrossEditingBoundary, &amp;reachedBoundaryStart);</span>
<span class="line-added"> 967     VisiblePosition nextPosition = visiblePosition.next(CannotCrossEditingBoundary, &amp;reachedBoundaryStart);</span>
<span class="line-added"> 968     bool hasLineBeforePosition = isEndOfLine(previousPosition);</span>
<span class="line-added"> 969 </span>
<span class="line-added"> 970     return !reachedBoundaryStart &amp;&amp; !reachedBoundaryEnd &amp;&amp; isBlankParagraph(visiblePosition) &amp;&amp; hasLineBeforePosition &amp;&amp; isStartOfLine(nextPosition);</span>
<span class="line-added"> 971 }</span>
<span class="line-added"> 972 </span>
 973 void ReplaceSelectionCommand::doApply()
 974 {
 975     VisibleSelection selection = endingSelection();
 976     ASSERT(selection.isCaretOrRange());
 977     ASSERT(selection.start().deprecatedNode());
 978     if (selection.isNoneOrOrphaned() || !selection.start().deprecatedNode() || !selection.isContentEditable())
 979         return;
 980 
 981     // In plain text only regions, we create style-less fragments, so the inserted content will automatically
 982     // match the style of the surrounding area and so we can avoid unnecessary work below for m_matchStyle.
 983     if (!selection.isContentRichlyEditable())
 984         m_matchStyle = false;
 985 
 986     ReplacementFragment&amp; fragment = *ensureReplacementFragment();
 987     if (performTrivialReplace(fragment))
 988         return;
 989 
 990     // We can skip matching the style if the selection is plain text.
 991     if ((selection.start().deprecatedNode()-&gt;renderer() &amp;&amp; selection.start().deprecatedNode()-&gt;renderer()-&gt;style().userModify() == UserModify::ReadWritePlaintextOnly)
 992         &amp;&amp; (selection.end().deprecatedNode()-&gt;renderer() &amp;&amp; selection.end().deprecatedNode()-&gt;renderer()-&gt;style().userModify() == UserModify::ReadWritePlaintextOnly))
</pre>
<hr />
<pre>
1097             insertionPos = positionInParentAfterNode(insertionBlock.get());
1098         else if (isStartOfBlock(visibleInsertionPos))
1099             insertionPos = positionInParentBeforeNode(insertionBlock.get());
1100     }
1101 
1102     // Paste at start or end of link goes outside of link.
1103     insertionPos = positionAvoidingSpecialElementBoundary(insertionPos);
1104 
1105     // FIXME: Can this wait until after the operation has been performed?  There doesn&#39;t seem to be
1106     // any work performed after this that queries or uses the typing style.
1107     frame().selection().clearTypingStyle();
1108 
1109     // We don&#39;t want the destination to end up inside nodes that weren&#39;t selected.  To avoid that, we move the
1110     // position forward without changing the visible position so we&#39;re still at the same visible location, but
1111     // outside of preceding tags.
1112     insertionPos = positionAvoidingPrecedingNodes(insertionPos);
1113 
1114     // Paste into run of tabs splits the tab span.
1115     insertionPos = positionOutsideTabSpan(insertionPos);
1116 
<span class="line-added">1117     bool hasBlankLinesBetweenParagraphs = hasBlankLineBetweenParagraphs(insertionPos);</span>
<span class="line-added">1118 </span>
1119     bool handledStyleSpans = handleStyleSpansBeforeInsertion(fragment, insertionPos);
1120 
1121     // We&#39;re finished if there is nothing to add.
1122     if (fragment.isEmpty() || !fragment.firstChild())
1123         return;
1124 
1125     // If we are not trying to match the destination style we prefer a position
1126     // that is outside inline elements that provide style.
1127     // This way we can produce a less verbose markup.
1128     // We can skip this optimization for fragments not wrapped in one of
1129     // our style spans and for positions inside list items
1130     // since insertAsListItems already does the right thing.
1131     if (!m_matchStyle &amp;&amp; !enclosingList(insertionPos.containerNode())) {
1132         if (insertionPos.containerNode()-&gt;isTextNode() &amp;&amp; insertionPos.offsetInContainerNode() &amp;&amp; !insertionPos.atLastEditingPositionForNode()) {
1133             splitTextNode(*insertionPos.containerText(), insertionPos.offsetInContainerNode());
1134             insertionPos = firstPositionInNode(insertionPos.containerNode());
1135         }
1136 
1137         if (RefPtr&lt;Node&gt; nodeToSplitTo = nodeToSplitToAvoidPastingIntoInlineNodesWithStyle(insertionPos)) {
1138             if (insertionPos.containerNode() != nodeToSplitTo-&gt;parentNode()) {
</pre>
<hr />
<pre>
1150     // again here if they&#39;ve been removed.
1151 
1152     // 1) Insert the content.
1153     // 2) Remove redundant styles and style tags, this inner &lt;b&gt; for example: &lt;b&gt;foo &lt;b&gt;bar&lt;/b&gt; baz&lt;/b&gt;.
1154     // 3) Merge the start of the added content with the content before the position being pasted into.
1155     // 4) Do one of the following: a) expand the last br if the fragment ends with one and it collapsed,
1156     // b) merge the last paragraph of the incoming fragment with the paragraph that contained the
1157     // end of the selection that was pasted into, or c) handle an interchange newline at the end of the
1158     // incoming fragment.
1159     // 5) Add spaces for smart replace.
1160     // 6) Select the replacement if requested, and match style if requested.
1161 
1162     InsertedNodes insertedNodes;
1163     RefPtr&lt;Node&gt; refNode = fragment.firstChild();
1164     RefPtr&lt;Node&gt; node = refNode-&gt;nextSibling();
1165 
1166     if (refNode)
1167         fragment.removeNode(*refNode);
1168 
1169     Node* blockStart = enclosingBlock(insertionPos.deprecatedNode());
<span class="line-modified">1170     bool isInsertingIntoList = (isListHTMLElement(refNode.get()) || (isLegacyAppleStyleSpan(refNode.get()) &amp;&amp; isListHTMLElement(refNode-&gt;firstChild())))</span>
<span class="line-modified">1171     &amp;&amp; blockStart &amp;&amp; blockStart-&gt;renderer()-&gt;isListItem();</span>
<span class="line-added">1172     if (isInsertingIntoList)</span>
1173         refNode = insertAsListItems(downcast&lt;HTMLElement&gt;(*refNode), blockStart, insertionPos, insertedNodes);
1174     else {
1175         insertNodeAt(*refNode, insertionPos);
1176         insertedNodes.respondToNodeInsertion(refNode.get());
1177     }
1178 
1179     // Mutation events (bug 22634) may have already removed the inserted content
1180     if (!refNode-&gt;isConnected())
1181         return;
1182 
1183     bool plainTextFragment = isPlainTextMarkup(refNode.get());
1184 
1185     while (node) {
1186         RefPtr&lt;Node&gt; next = node-&gt;nextSibling();
1187         fragment.removeNode(*node);
1188         insertNodeAfter(*node, *refNode);
1189         insertedNodes.respondToNodeInsertion(node.get());
1190 
1191         // Mutation events (bug 22634) may have already removed the inserted content
1192         if (!node-&gt;isConnected())
</pre>
<hr />
<pre>
1301                 }
1302 
1303                 // Select up to the paragraph separator that was added.
1304                 lastPositionToSelect = endingSelection().visibleStart().deepEquivalent();
1305                 updateNodesInserted(lastPositionToSelect.deprecatedNode());
1306             }
1307         } else {
1308             // Select up to the beginning of the next paragraph.
1309             lastPositionToSelect = next.deepEquivalent().downstream();
1310         }
1311 
1312     } else
1313         mergeEndIfNeeded();
1314 
1315     if (Node* mailBlockquote = enclosingNodeOfType(positionAtStartOfInsertedContent().deepEquivalent(), isMailPasteAsQuotationNode))
1316         removeNodeAttribute(downcast&lt;Element&gt;(*mailBlockquote), classAttr);
1317 
1318     if (shouldPerformSmartReplace())
1319         addSpacesForSmartReplace();
1320 
<span class="line-added">1321     if (!isInsertingIntoList &amp;&amp; hasBlankLinesBetweenParagraphs &amp;&amp; shouldPerformSmartParagraphReplace())</span>
<span class="line-added">1322         addNewLinesForSmartReplace();</span>
<span class="line-added">1323 </span>
1324     // If we are dealing with a fragment created from plain text
1325     // no style matching is necessary.
1326     if (plainTextFragment)
1327         m_matchStyle = false;
1328 
1329     completeHTMLReplacement(lastPositionToSelect);
1330 }
1331 
1332 String ReplaceSelectionCommand::inputEventData() const
1333 {
1334     if (isEditingTextAreaOrTextInput())
1335         return m_documentFragment-&gt;textContent();
1336 
1337     return CompositeEditCommand::inputEventData();
1338 }
1339 
1340 RefPtr&lt;DataTransfer&gt; ReplaceSelectionCommand::inputEventDataTransfer() const
1341 {
1342     if (isEditingTextAreaOrTextInput())
1343         return CompositeEditCommand::inputEventDataTransfer();
1344 
<span class="line-modified">1345     return DataTransfer::createForInputEvent(document(), m_documentFragmentPlainText, m_documentFragmentHTMLMarkup);</span>
1346 }
1347 
1348 bool ReplaceSelectionCommand::shouldRemoveEndBR(Node* endBR, const VisiblePosition&amp; originalVisPosBeforeEndBR)
1349 {
1350     if (!endBR || !endBR-&gt;isConnected())
1351         return false;
1352 
1353     VisiblePosition visiblePos(positionBeforeNode(endBR));
1354 
1355     // Don&#39;t remove the br if nothing was inserted.
1356     if (visiblePos.previous() == originalVisPosBeforeEndBR)
1357         return false;
1358 
1359     // Remove the br if it is collapsed away and so is unnecessary.
1360     if (!document().inNoQuirksMode() &amp;&amp; isEndOfBlock(visiblePos) &amp;&amp; !isStartOfParagraph(visiblePos))
1361         return true;
1362 
1363     // A br that was originally holding a line open should be displaced by inserted content or turned into a line break.
1364     // A br that was originally acting as a line break should still be acting as a line break, not as a placeholder.
1365     return isStartOfParagraph(visiblePos) &amp;&amp; isEndOfParagraph(visiblePos);
1366 }
1367 
1368 bool ReplaceSelectionCommand::shouldPerformSmartReplace() const
1369 {
1370     if (!m_smartReplace)
1371         return false;
1372 
1373     Element* textControl = enclosingTextFormControl(positionAtStartOfInsertedContent().deepEquivalent());
1374     if (is&lt;HTMLInputElement&gt;(textControl) &amp;&amp; downcast&lt;HTMLInputElement&gt;(*textControl).isPasswordField())
1375         return false; // Disable smart replace for password fields.
1376 
1377     return true;
1378 }
1379 
<span class="line-added">1380 bool ReplaceSelectionCommand::shouldPerformSmartParagraphReplace() const</span>
<span class="line-added">1381 {</span>
<span class="line-added">1382     if (!m_smartReplace)</span>
<span class="line-added">1383         return false;</span>
<span class="line-added">1384 </span>
<span class="line-added">1385     if (!document().editingBehavior().shouldSmartInsertDeleteParagraphs())</span>
<span class="line-added">1386         return false;</span>
<span class="line-added">1387 </span>
<span class="line-added">1388     return true;</span>
<span class="line-added">1389 }</span>
<span class="line-added">1390 </span>
1391 static bool isCharacterSmartReplaceExemptConsideringNonBreakingSpace(UChar32 character, bool previousCharacter)
1392 {
1393     return isCharacterSmartReplaceExempt(character == noBreakSpace ? &#39; &#39; : character, previousCharacter);
1394 }
1395 
<span class="line-added">1396 void ReplaceSelectionCommand::addNewLinesForSmartReplace()</span>
<span class="line-added">1397 {</span>
<span class="line-added">1398     VisiblePosition startOfInsertedContent = positionAtStartOfInsertedContent();</span>
<span class="line-added">1399     VisiblePosition endOfInsertedContent = positionAtEndOfInsertedContent();</span>
<span class="line-added">1400 </span>
<span class="line-added">1401     bool isPastedContentEntireParagraphs = isStartOfParagraph(startOfInsertedContent) &amp;&amp; isEndOfParagraph(endOfInsertedContent);</span>
<span class="line-added">1402 </span>
<span class="line-added">1403     // If we aren&#39;t pasting a paragraph, no need to attempt to insert newlines.</span>
<span class="line-added">1404     if (!isPastedContentEntireParagraphs)</span>
<span class="line-added">1405         return;</span>
<span class="line-added">1406 </span>
<span class="line-added">1407     bool reachedBoundaryStart = false;</span>
<span class="line-added">1408     bool reachedBoundaryEnd = false;</span>
<span class="line-added">1409     VisiblePosition positionBeforeStart = startOfInsertedContent.previous(CannotCrossEditingBoundary, &amp;reachedBoundaryStart);</span>
<span class="line-added">1410     VisiblePosition positionAfterEnd = endOfInsertedContent.next(CannotCrossEditingBoundary, &amp;reachedBoundaryEnd);</span>
<span class="line-added">1411 </span>
<span class="line-added">1412     if (!reachedBoundaryStart &amp;&amp; !reachedBoundaryEnd) {</span>
<span class="line-added">1413         if (!isBlankParagraph(positionBeforeStart) &amp;&amp; !isBlankParagraph(startOfInsertedContent) &amp;&amp; isEndOfLine(positionBeforeStart) &amp;&amp; !isEndOfEditableOrNonEditableContent(positionAfterEnd) &amp;&amp; !isEndOfEditableOrNonEditableContent(endOfInsertedContent)) {</span>
<span class="line-added">1414             setEndingSelection(startOfInsertedContent);</span>
<span class="line-added">1415             insertParagraphSeparator();</span>
<span class="line-added">1416             auto newStart = endingSelection().visibleStart().previous(CannotCrossEditingBoundary, &amp;reachedBoundaryStart);</span>
<span class="line-added">1417             if (!reachedBoundaryStart)</span>
<span class="line-added">1418                 m_startOfInsertedContent = newStart.deepEquivalent();</span>
<span class="line-added">1419         }</span>
<span class="line-added">1420     }</span>
<span class="line-added">1421 </span>
<span class="line-added">1422     reachedBoundaryStart = false;</span>
<span class="line-added">1423     reachedBoundaryEnd = false;</span>
<span class="line-added">1424     positionAfterEnd = endOfInsertedContent.next(CannotCrossEditingBoundary, &amp;reachedBoundaryEnd);</span>
<span class="line-added">1425     positionBeforeStart = startOfInsertedContent.previous(CannotCrossEditingBoundary, &amp;reachedBoundaryStart);</span>
<span class="line-added">1426 </span>
<span class="line-added">1427     if (!reachedBoundaryEnd &amp;&amp; !reachedBoundaryStart) {</span>
<span class="line-added">1428         if (!isBlankParagraph(positionAfterEnd) &amp;&amp; !isBlankParagraph(endOfInsertedContent) &amp;&amp; isStartOfLine(positionAfterEnd) &amp;&amp; !isEndOfLine(positionAfterEnd) &amp;&amp; !isEndOfEditableOrNonEditableContent(positionAfterEnd)) {</span>
<span class="line-added">1429             setEndingSelection(endOfInsertedContent);</span>
<span class="line-added">1430             insertParagraphSeparator();</span>
<span class="line-added">1431             m_endOfInsertedContent = endingSelection().start();</span>
<span class="line-added">1432         }</span>
<span class="line-added">1433     }</span>
<span class="line-added">1434 }</span>
<span class="line-added">1435 </span>
1436 void ReplaceSelectionCommand::addSpacesForSmartReplace()
1437 {
1438     VisiblePosition startOfInsertedContent = positionAtStartOfInsertedContent();
1439     VisiblePosition endOfInsertedContent = positionAtEndOfInsertedContent();
1440 
1441     Position endUpstream = endOfInsertedContent.deepEquivalent().upstream();
1442     Node* endNode = endUpstream.computeNodeBeforePosition();
1443     int endOffset = is&lt;Text&gt;(endNode) ? downcast&lt;Text&gt;(*endNode).length() : 0;
1444     if (endUpstream.anchorType() == Position::PositionIsOffsetInAnchor) {
1445         endNode = endUpstream.containerNode();
1446         endOffset = endUpstream.offsetInContainerNode();
1447     }
1448 
1449     bool needsTrailingSpace = !isEndOfParagraph(endOfInsertedContent) &amp;&amp; !isStartOfParagraph(endOfInsertedContent) &amp;&amp; !isCharacterSmartReplaceExemptConsideringNonBreakingSpace(endOfInsertedContent.characterAfter(), false);
1450     if (needsTrailingSpace &amp;&amp; endNode) {
1451         bool collapseWhiteSpace = !endNode-&gt;renderer() || endNode-&gt;renderer()-&gt;style().collapseWhiteSpace();
1452         if (is&lt;Text&gt;(*endNode)) {
1453             insertTextIntoNode(downcast&lt;Text&gt;(*endNode), endOffset, collapseWhiteSpace ? nonBreakingSpaceString() : &quot; &quot;);
1454             if (m_endOfInsertedContent.containerNode() == endNode)
1455                 m_endOfInsertedContent.moveToOffset(m_endOfInsertedContent.offsetInContainerNode() + 1);
</pre>
<hr />
<pre>
1629             ASSERT_NOT_REACHED();
1630     }
1631     if ((isStart || isMiddle) &amp;&amp; lastNode-&gt;previousSibling())
1632         lastNode = lastNode-&gt;previousSibling();
1633     return lastNode;
1634 }
1635 
1636 void ReplaceSelectionCommand::updateNodesInserted(Node *node)
1637 {
1638     if (!node)
1639         return;
1640 
1641     if (m_startOfInsertedContent.isNull())
1642         m_startOfInsertedContent = firstPositionInOrBeforeNode(node);
1643 
1644     m_endOfInsertedContent = lastPositionInOrAfterNode(node-&gt;lastDescendant());
1645 }
1646 
1647 ReplacementFragment* ReplaceSelectionCommand::ensureReplacementFragment()
1648 {
<span class="line-modified">1649     if (!m_replacementFragment)</span>
<span class="line-modified">1650         m_replacementFragment = makeUnique&lt;ReplacementFragment&gt;(m_documentFragment.get(), endingSelection());</span>



1651     return m_replacementFragment.get();
1652 }
1653 
1654 // During simple pastes, where we&#39;re just pasting a text node into a run of text, we insert the text node
1655 // directly into the text node that holds the selection.  This is much faster than the generalized code in
1656 // ReplaceSelectionCommand, and works around &lt;https://bugs.webkit.org/show_bug.cgi?id=6148&gt; since we don&#39;t
1657 // split text nodes.
1658 bool ReplaceSelectionCommand::performTrivialReplace(const ReplacementFragment&amp; fragment)
1659 {
1660     if (!is&lt;Text&gt;(fragment.firstChild()) || fragment.firstChild() != fragment.lastChild())
1661         return false;
1662 
1663     // FIXME: Would be nice to handle smart replace in the fast path.
1664     if (m_smartReplace || fragment.hasInterchangeNewlineAtStart() || fragment.hasInterchangeNewlineAtEnd())
1665         return false;
1666 
1667     // e.g. when &quot;bar&quot; is inserted after &quot;foo&quot; in &lt;div&gt;&lt;u&gt;foo&lt;/u&gt;&lt;/div&gt;, &quot;bar&quot; should not be underlined.
1668     if (nodeToSplitToAvoidPastingIntoInlineNodesWithStyle(endingSelection().start()))
1669         return false;
1670 
</pre>
</td>
</tr>
</table>
<center><a href="ReplaceRangeWithTextCommand.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ReplaceSelectionCommand.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>