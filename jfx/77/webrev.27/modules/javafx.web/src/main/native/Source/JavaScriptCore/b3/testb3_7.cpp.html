<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/JavaScriptCore/b3/testb3_7.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (C) 2015-2019 Apple Inc. All rights reserved.
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  * 1. Redistributions of source code must retain the above copyright
   8  *    notice, this list of conditions and the following disclaimer.
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #include &quot;config.h&quot;
  27 #include &quot;testb3.h&quot;
  28 
  29 #if ENABLE(B3_JIT)
  30 
  31 void testPinRegisters()
  32 {
  33     auto go = [&amp;] (bool pin) {
  34         Procedure proc;
  35         RegisterSet csrs;
  36         csrs.merge(RegisterSet::calleeSaveRegisters());
  37         csrs.exclude(RegisterSet::stackRegisters());
  38         if (pin) {
  39             csrs.forEach(
  40                 [&amp;] (Reg reg) {
  41                     proc.pinRegister(reg);
  42                 });
  43         }
  44         BasicBlock* root = proc.addBlock();
  45         Value* a = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0);
  46         Value* b = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1);
  47         Value* c = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR2);
  48         Value* d = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::regCS0);
  49         root-&gt;appendNew&lt;CCallValue&gt;(
  50             proc, Void, Origin(),
  51             root-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), static_cast&lt;intptr_t&gt;(0x1234)));
  52         root-&gt;appendNew&lt;CCallValue&gt;(
  53             proc, Void, Origin(),
  54             root-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), static_cast&lt;intptr_t&gt;(0x1235)),
  55             a, b, c);
  56         PatchpointValue* patchpoint = root-&gt;appendNew&lt;PatchpointValue&gt;(proc, Void, Origin());
  57         patchpoint-&gt;appendSomeRegister(d);
  58         unsigned optLevel = proc.optLevel();
  59         patchpoint-&gt;setGenerator(
  60             [&amp;] (CCallHelpers&amp;, const StackmapGenerationParams&amp; params) {
  61                 if (optLevel &gt; 1)
  62                     CHECK_EQ(params[0].gpr(), GPRInfo::regCS0);
  63             });
  64         root-&gt;appendNew&lt;Value&gt;(proc, Return, Origin());
  65         auto code = compileProc(proc);
  66         bool usesCSRs = false;
  67         for (Air::BasicBlock* block : proc.code()) {
  68             for (Air::Inst&amp; inst : *block) {
  69                 if (inst.kind.opcode == Air::Patch &amp;&amp; inst.origin == patchpoint)
  70                     continue;
  71                 inst.forEachTmpFast(
  72                     [&amp;] (Air::Tmp tmp) {
  73                         if (tmp.isReg())
  74                             usesCSRs |= csrs.get(tmp.reg());
  75                     });
  76             }
  77         }
  78         if (proc.optLevel() &lt; 2) {
  79             // Our less good register allocators may use the
  80             // pinned CSRs in a move.
  81             usesCSRs = false;
  82         }
  83         for (const RegisterAtOffset&amp; regAtOffset : proc.calleeSaveRegisterAtOffsetList())
  84             usesCSRs |= csrs.get(regAtOffset.reg());
  85         CHECK_EQ(usesCSRs, !pin);
  86     };
  87 
  88     go(true);
  89     go(false);
  90 }
  91 
  92 void testX86LeaAddAddShlLeft()
  93 {
  94     // Add(Add(Shl(@x, $c), @y), $d)
  95     Procedure proc;
  96     BasicBlock* root = proc.addBlock();
  97     Value* result = root-&gt;appendNew&lt;Value&gt;(
  98         proc, Add, Origin(),
  99         root-&gt;appendNew&lt;Value&gt;(
 100             proc, Add, Origin(),
 101             root-&gt;appendNew&lt;Value&gt;(
 102                 proc, Shl, Origin(),
 103                 root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1),
 104                 root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 2)),
 105             root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0)),
 106         root-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), 100));
 107     root-&gt;appendNew&lt;Value&gt;(proc, Return, Origin(), result);
 108 
 109     auto code = compileProc(proc);
 110     if (proc.optLevel() &gt; 1)
 111         checkUsesInstruction(*code, &quot;lea 0x64(%rdi,%rsi,4), %rax&quot;);
 112     else
 113         checkUsesInstruction(*code, &quot;lea&quot;);
 114     CHECK_EQ(invoke&lt;intptr_t&gt;(*code, 1, 2), (1 + (2 &lt;&lt; 2)) + 100);
 115 }
 116 
 117 void testX86LeaAddAddShlRight()
 118 {
 119     // Add(Add(@x, Shl(@y, $c)), $d)
 120     Procedure proc;
 121     BasicBlock* root = proc.addBlock();
 122     Value* result = root-&gt;appendNew&lt;Value&gt;(
 123         proc, Add, Origin(),
 124         root-&gt;appendNew&lt;Value&gt;(
 125             proc, Add, Origin(),
 126             root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0),
 127             root-&gt;appendNew&lt;Value&gt;(
 128                 proc, Shl, Origin(),
 129                 root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1),
 130                 root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 2))),
 131         root-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), 100));
 132     root-&gt;appendNew&lt;Value&gt;(proc, Return, Origin(), result);
 133 
 134     auto code = compileProc(proc);
 135     if (proc.optLevel() &gt; 1)
 136         checkUsesInstruction(*code, &quot;lea 0x64(%rdi,%rsi,4), %rax&quot;);
 137     else
 138         checkUsesInstruction(*code, &quot;lea&quot;);
 139     CHECK_EQ(invoke&lt;intptr_t&gt;(*code, 1, 2), (1 + (2 &lt;&lt; 2)) + 100);
 140 }
 141 
 142 void testX86LeaAddAdd()
 143 {
 144     // Add(Add(@x, @y), $c)
 145     Procedure proc;
 146     BasicBlock* root = proc.addBlock();
 147     Value* result = root-&gt;appendNew&lt;Value&gt;(
 148         proc, Add, Origin(),
 149         root-&gt;appendNew&lt;Value&gt;(
 150             proc, Add, Origin(),
 151             root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1),
 152             root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0)),
 153         root-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), 100));
 154     root-&gt;appendNew&lt;Value&gt;(proc, Return, Origin(), result);
 155 
 156     auto code = compileProc(proc);
 157     CHECK_EQ(invoke&lt;intptr_t&gt;(*code, 1, 2), (1 + 2) + 100);
 158     if (proc.optLevel() &gt; 1) {
 159         checkDisassembly(
 160             *code,
 161             [&amp;] (const char* disassembly) -&gt; bool {
 162                 return strstr(disassembly, &quot;lea 0x64(%rdi,%rsi), %rax&quot;)
 163                     || strstr(disassembly, &quot;lea 0x64(%rsi,%rdi), %rax&quot;);
 164             },
 165             &quot;Expected to find something like lea 0x64(%rdi,%rsi), %rax but didn&#39;t!&quot;);
 166     }
 167 }
 168 
 169 void testX86LeaAddShlRight()
 170 {
 171     // Add(Shl(@x, $c), @y)
 172     Procedure proc;
 173     BasicBlock* root = proc.addBlock();
 174     Value* result = root-&gt;appendNew&lt;Value&gt;(
 175         proc, Add, Origin(),
 176         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0),
 177         root-&gt;appendNew&lt;Value&gt;(
 178             proc, Shl, Origin(),
 179             root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1),
 180             root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 2)));
 181     root-&gt;appendNew&lt;Value&gt;(proc, Return, Origin(), result);
 182 
 183     auto code = compileProc(proc);
 184     if (proc.optLevel() &gt; 1)
 185         checkUsesInstruction(*code, &quot;lea (%rdi,%rsi,4), %rax&quot;);
 186     else
 187         checkUsesInstruction(*code, &quot;lea&quot;);
 188     CHECK_EQ(invoke&lt;intptr_t&gt;(*code, 1, 2), 1 + (2 &lt;&lt; 2));
 189 }
 190 
 191 void testX86LeaAddShlLeftScale1()
 192 {
 193     // Add(Shl(@x, $c), @y)
 194     Procedure proc;
 195     BasicBlock* root = proc.addBlock();
 196     Value* result = root-&gt;appendNew&lt;Value&gt;(
 197         proc, Add, Origin(),
 198         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0),
 199         root-&gt;appendNew&lt;Value&gt;(
 200             proc, Shl, Origin(),
 201             root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1),
 202             root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 0)));
 203     root-&gt;appendNew&lt;Value&gt;(proc, Return, Origin(), result);
 204 
 205     auto code = compileProc(proc);
 206     CHECK_EQ(invoke&lt;intptr_t&gt;(*code, 1, 2), 1 + 2);
 207     if (proc.optLevel() &gt; 1) {
 208         checkDisassembly(
 209             *code,
 210             [&amp;] (const char* disassembly) -&gt; bool {
 211                 return strstr(disassembly, &quot;lea (%rdi,%rsi), %rax&quot;)
 212                     || strstr(disassembly, &quot;lea (%rsi,%rdi), %rax&quot;);
 213             },
 214             &quot;Expected to find something like lea (%rdi,%rsi), %rax but didn&#39;t!&quot;);
 215     }
 216 }
 217 
 218 void testX86LeaAddShlLeftScale2()
 219 {
 220     // Add(Shl(@x, $c), @y)
 221     Procedure proc;
 222     BasicBlock* root = proc.addBlock();
 223     Value* result = root-&gt;appendNew&lt;Value&gt;(
 224         proc, Add, Origin(),
 225         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0),
 226         root-&gt;appendNew&lt;Value&gt;(
 227             proc, Shl, Origin(),
 228             root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1),
 229             root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 1)));
 230     root-&gt;appendNew&lt;Value&gt;(proc, Return, Origin(), result);
 231 
 232     auto code = compileProc(proc);
 233     if (proc.optLevel() &gt; 1)
 234         checkUsesInstruction(*code, &quot;lea (%rdi,%rsi,2), %rax&quot;);
 235     else
 236         checkUsesInstruction(*code, &quot;lea&quot;);
 237     CHECK_EQ(invoke&lt;intptr_t&gt;(*code, 1, 2), 1 + (2 &lt;&lt; 1));
 238 }
 239 
 240 void testX86LeaAddShlLeftScale4()
 241 {
 242     // Add(Shl(@x, $c), @y)
 243     Procedure proc;
 244     BasicBlock* root = proc.addBlock();
 245     Value* result = root-&gt;appendNew&lt;Value&gt;(
 246         proc, Add, Origin(),
 247         root-&gt;appendNew&lt;Value&gt;(
 248             proc, Shl, Origin(),
 249             root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1),
 250             root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 2)),
 251         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0));
 252     root-&gt;appendNew&lt;Value&gt;(proc, Return, Origin(), result);
 253 
 254     auto code = compileProc(proc);
 255     if (proc.optLevel() &gt; 1)
 256         checkUsesInstruction(*code, &quot;lea (%rdi,%rsi,4), %rax&quot;);
 257     else
 258         checkUsesInstruction(*code, &quot;lea&quot;);
 259     CHECK_EQ(invoke&lt;intptr_t&gt;(*code, 1, 2), 1 + (2 &lt;&lt; 2));
 260 }
 261 
 262 void testX86LeaAddShlLeftScale8()
 263 {
 264     // Add(Shl(@x, $c), @y)
 265     Procedure proc;
 266     BasicBlock* root = proc.addBlock();
 267     Value* result = root-&gt;appendNew&lt;Value&gt;(
 268         proc, Add, Origin(),
 269         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0),
 270         root-&gt;appendNew&lt;Value&gt;(
 271             proc, Shl, Origin(),
 272             root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1),
 273             root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 3)));
 274     root-&gt;appendNew&lt;Value&gt;(proc, Return, Origin(), result);
 275 
 276     auto code = compileProc(proc);
 277     if (proc.optLevel() &gt; 1)
 278         checkUsesInstruction(*code, &quot;lea (%rdi,%rsi,8), %rax&quot;);
 279     else
 280         checkUsesInstruction(*code, &quot;lea&quot;);
 281     CHECK_EQ(invoke&lt;intptr_t&gt;(*code, 1, 2), 1 + (2 &lt;&lt; 3));
 282 }
 283 
 284 void testAddShl32()
 285 {
 286     // Add(Shl(@x, $c), @y)
 287     Procedure proc;
 288     BasicBlock* root = proc.addBlock();
 289     Value* result = root-&gt;appendNew&lt;Value&gt;(
 290         proc, Add, Origin(),
 291         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0),
 292         root-&gt;appendNew&lt;Value&gt;(
 293             proc, Shl, Origin(),
 294             root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1),
 295             root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 32)));
 296     root-&gt;appendNew&lt;Value&gt;(proc, Return, Origin(), result);
 297 
 298     auto code = compileProc(proc);
 299     CHECK_EQ(invoke&lt;int64_t&gt;(*code, 1, 2), 1 + (static_cast&lt;int64_t&gt;(2) &lt;&lt; static_cast&lt;int64_t&gt;(32)));
 300 }
 301 
 302 void testAddShl64()
 303 {
 304     // Add(Shl(@x, $c), @y)
 305     Procedure proc;
 306     BasicBlock* root = proc.addBlock();
 307     Value* result = root-&gt;appendNew&lt;Value&gt;(
 308         proc, Add, Origin(),
 309         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0),
 310         root-&gt;appendNew&lt;Value&gt;(
 311             proc, Shl, Origin(),
 312             root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1),
 313             root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 64)));
 314     root-&gt;appendNew&lt;Value&gt;(proc, Return, Origin(), result);
 315 
 316     auto code = compileProc(proc);
 317     CHECK_EQ(invoke&lt;intptr_t&gt;(*code, 1, 2), 1 + 2);
 318 }
 319 
 320 void testAddShl65()
 321 {
 322     // Add(Shl(@x, $c), @y)
 323     Procedure proc;
 324     BasicBlock* root = proc.addBlock();
 325     Value* result = root-&gt;appendNew&lt;Value&gt;(
 326         proc, Add, Origin(),
 327         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0),
 328         root-&gt;appendNew&lt;Value&gt;(
 329             proc, Shl, Origin(),
 330             root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1),
 331             root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 65)));
 332     root-&gt;appendNew&lt;Value&gt;(proc, Return, Origin(), result);
 333 
 334     auto code = compileProc(proc);
 335     CHECK_EQ(invoke&lt;intptr_t&gt;(*code, 1, 2), 1 + (2 &lt;&lt; 1));
 336 }
 337 
 338 void testReduceStrengthReassociation(bool flip)
 339 {
 340     // Add(Add(@x, $c), @y) -&gt; Add(Add(@x, @y), $c)
 341     // and
 342     // Add(@y, Add(@x, $c)) -&gt; Add(Add(@x, @y), $c)
 343     Procedure proc;
 344     BasicBlock* root = proc.addBlock();
 345     Value* arg1 = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0);
 346     Value* arg2 = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1);
 347 
 348     Value* innerAdd = root-&gt;appendNew&lt;Value&gt;(
 349         proc, Add, Origin(), arg1,
 350         root-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), 42));
 351 
 352     Value* outerAdd;
 353     if (flip)
 354         outerAdd = root-&gt;appendNew&lt;Value&gt;(proc, Add, Origin(), arg2, innerAdd);
 355     else
 356         outerAdd = root-&gt;appendNew&lt;Value&gt;(proc, Add, Origin(), innerAdd, arg2);
 357 
 358     root-&gt;appendNew&lt;Value&gt;(proc, Return, Origin(), outerAdd);
 359 
 360     proc.resetReachability();
 361 
 362     if (shouldBeVerbose()) {
 363         dataLog(&quot;IR before reduceStrength:\n&quot;);
 364         dataLog(proc);
 365     }
 366 
 367     reduceStrength(proc);
 368 
 369     if (shouldBeVerbose()) {
 370         dataLog(&quot;IR after reduceStrength:\n&quot;);
 371         dataLog(proc);
 372     }
 373 
 374     CHECK_EQ(root-&gt;last()-&gt;opcode(), Return);
 375     CHECK_EQ(root-&gt;last()-&gt;child(0)-&gt;opcode(), Add);
 376     CHECK(root-&gt;last()-&gt;child(0)-&gt;child(1)-&gt;isIntPtr(42));
 377     CHECK_EQ(root-&gt;last()-&gt;child(0)-&gt;child(0)-&gt;opcode(), Add);
 378     CHECK(
 379         (root-&gt;last()-&gt;child(0)-&gt;child(0)-&gt;child(0) == arg1 &amp;&amp; root-&gt;last()-&gt;child(0)-&gt;child(0)-&gt;child(1) == arg2) ||
 380         (root-&gt;last()-&gt;child(0)-&gt;child(0)-&gt;child(0) == arg2 &amp;&amp; root-&gt;last()-&gt;child(0)-&gt;child(0)-&gt;child(1) == arg1));
 381 }
 382 
 383 void testLoadBaseIndexShift2()
 384 {
 385     Procedure proc;
 386     BasicBlock* root = proc.addBlock();
 387     root-&gt;appendNew&lt;Value&gt;(
 388         proc, Return, Origin(),
 389         root-&gt;appendNew&lt;MemoryValue&gt;(
 390             proc, Load, Int32, Origin(),
 391             root-&gt;appendNew&lt;Value&gt;(
 392                 proc, Add, Origin(),
 393                 root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0),
 394                 root-&gt;appendNew&lt;Value&gt;(
 395                     proc, Shl, Origin(),
 396                     root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1),
 397                     root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 2)))));
 398     auto code = compileProc(proc);
 399     if (isX86() &amp;&amp; proc.optLevel() &gt; 1)
 400         checkUsesInstruction(*code, &quot;(%rdi,%rsi,4)&quot;);
 401     int32_t value = 12341234;
 402     char* ptr = bitwise_cast&lt;char*&gt;(&amp;value);
 403     for (unsigned i = 0; i &lt; 10; ++i)
 404         CHECK_EQ(invoke&lt;int32_t&gt;(*code, ptr - (static_cast&lt;intptr_t&gt;(1) &lt;&lt; static_cast&lt;intptr_t&gt;(2)) * i, i), 12341234);
 405 }
 406 
 407 void testLoadBaseIndexShift32()
 408 {
 409 #if CPU(ADDRESS64)
 410     Procedure proc;
 411     BasicBlock* root = proc.addBlock();
 412     root-&gt;appendNew&lt;Value&gt;(
 413         proc, Return, Origin(),
 414         root-&gt;appendNew&lt;MemoryValue&gt;(
 415             proc, Load, Int32, Origin(),
 416             root-&gt;appendNew&lt;Value&gt;(
 417                 proc, Add, Origin(),
 418                 root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0),
 419                 root-&gt;appendNew&lt;Value&gt;(
 420                     proc, Shl, Origin(),
 421                     root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1),
 422                     root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 32)))));
 423     auto code = compileProc(proc);
 424     int32_t value = 12341234;
 425     char* ptr = bitwise_cast&lt;char*&gt;(&amp;value);
 426     for (unsigned i = 0; i &lt; 10; ++i)
 427         CHECK_EQ(invoke&lt;int32_t&gt;(*code, ptr - (static_cast&lt;intptr_t&gt;(1) &lt;&lt; static_cast&lt;intptr_t&gt;(32)) * i, i), 12341234);
 428 #endif
 429 }
 430 
 431 void testOptimizeMaterialization()
 432 {
 433     Procedure proc;
 434     if (proc.optLevel() &lt; 2)
 435         return;
 436 
 437     BasicBlock* root = proc.addBlock();
 438     root-&gt;appendNew&lt;CCallValue&gt;(
 439         proc, Void, Origin(),
 440         root-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), 0x123423453456llu),
 441         root-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), 0x123423453456llu + 35));
 442     root-&gt;appendNew&lt;Value&gt;(proc, Return, Origin());
 443 
 444     auto code = compileProc(proc);
 445     bool found = false;
 446     for (Air::BasicBlock* block : proc.code()) {
 447         for (Air::Inst&amp; inst : *block) {
 448             if (inst.kind.opcode != Air::Add64)
 449                 continue;
 450             if (inst.args[0] != Air::Arg::imm(35))
 451                 continue;
 452             found = true;
 453         }
 454     }
 455     CHECK(found);
 456 }
 457 
 458 template&lt;typename Func&gt;
 459 void generateLoop(Procedure&amp; proc, const Func&amp; func)
 460 {
 461     BasicBlock* root = proc.addBlock();
 462     BasicBlock* loop = proc.addBlock();
 463     BasicBlock* end = proc.addBlock();
 464 
 465     UpsilonValue* initialIndex = root-&gt;appendNew&lt;UpsilonValue&gt;(
 466         proc, Origin(), root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 0));
 467     root-&gt;appendNew&lt;Value&gt;(proc, Jump, Origin());
 468     root-&gt;setSuccessors(loop);
 469 
 470     Value* index = loop-&gt;appendNew&lt;Value&gt;(proc, Phi, Int32, Origin());
 471     initialIndex-&gt;setPhi(index);
 472 
 473     Value* one = func(loop, index);
 474 
 475     Value* nextIndex = loop-&gt;appendNew&lt;Value&gt;(proc, Add, Origin(), index, one);
 476     UpsilonValue* loopIndex = loop-&gt;appendNew&lt;UpsilonValue&gt;(proc, Origin(), nextIndex);
 477     loopIndex-&gt;setPhi(index);
 478     loop-&gt;appendNew&lt;Value&gt;(
 479         proc, Branch, Origin(),
 480         loop-&gt;appendNew&lt;Value&gt;(
 481             proc, LessThan, Origin(), nextIndex,
 482             loop-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 100)));
 483     loop-&gt;setSuccessors(loop, end);
 484 
 485     end-&gt;appendNew&lt;Value&gt;(proc, Return, Origin());
 486 }
 487 
 488 static std::array&lt;int, 100&gt; makeArrayForLoops()
 489 {
 490     std::array&lt;int, 100&gt; result;
 491     for (unsigned i = 0; i &lt; result.size(); ++i)
 492         result[i] = i &amp; 1;
 493     return result;
 494 }
 495 
 496 template&lt;typename Func&gt;
 497 void generateLoopNotBackwardsDominant(Procedure&amp; proc, std::array&lt;int, 100&gt;&amp; array, const Func&amp; func)
 498 {
 499     BasicBlock* root = proc.addBlock();
 500     BasicBlock* loopHeader = proc.addBlock();
 501     BasicBlock* loopCall = proc.addBlock();
 502     BasicBlock* loopFooter = proc.addBlock();
 503     BasicBlock* end = proc.addBlock();
 504 
 505     UpsilonValue* initialIndex = root-&gt;appendNew&lt;UpsilonValue&gt;(
 506         proc, Origin(), root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 0));
 507     // If you look carefully, you&#39;ll notice that this is an extremely sneaky use of Upsilon that demonstrates
 508     // the extent to which our SSA is different from normal-person SSA.
 509     UpsilonValue* defaultOne = root-&gt;appendNew&lt;UpsilonValue&gt;(
 510         proc, Origin(), root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 1));
 511     root-&gt;appendNew&lt;Value&gt;(proc, Jump, Origin());
 512     root-&gt;setSuccessors(loopHeader);
 513 
 514     Value* index = loopHeader-&gt;appendNew&lt;Value&gt;(proc, Phi, Int32, Origin());
 515     initialIndex-&gt;setPhi(index);
 516 
 517     // if (array[index])
 518     loopHeader-&gt;appendNew&lt;Value&gt;(
 519         proc, Branch, Origin(),
 520         loopHeader-&gt;appendNew&lt;MemoryValue&gt;(
 521             proc, Load, Int32, Origin(),
 522             loopHeader-&gt;appendNew&lt;Value&gt;(
 523                 proc, Add, Origin(),
 524                 loopHeader-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), &amp;array),
 525                 loopHeader-&gt;appendNew&lt;Value&gt;(
 526                     proc, Mul, Origin(),
 527                     loopHeader-&gt;appendNew&lt;Value&gt;(proc, ZExt32, Origin(), index),
 528                     loopHeader-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), sizeof(int))))));
 529     loopHeader-&gt;setSuccessors(loopCall, loopFooter);
 530 
 531     Value* functionCall = func(loopCall, index);
 532     UpsilonValue* oneFromFunction = loopCall-&gt;appendNew&lt;UpsilonValue&gt;(proc, Origin(), functionCall);
 533     loopCall-&gt;appendNew&lt;Value&gt;(proc, Jump, Origin());
 534     loopCall-&gt;setSuccessors(loopFooter);
 535 
 536     Value* one = loopFooter-&gt;appendNew&lt;Value&gt;(proc, Phi, Int32, Origin());
 537     defaultOne-&gt;setPhi(one);
 538     oneFromFunction-&gt;setPhi(one);
 539     Value* nextIndex = loopFooter-&gt;appendNew&lt;Value&gt;(proc, Add, Origin(), index, one);
 540     UpsilonValue* loopIndex = loopFooter-&gt;appendNew&lt;UpsilonValue&gt;(proc, Origin(), nextIndex);
 541     loopIndex-&gt;setPhi(index);
 542     loopFooter-&gt;appendNew&lt;Value&gt;(
 543         proc, Branch, Origin(),
 544         loopFooter-&gt;appendNew&lt;Value&gt;(
 545             proc, LessThan, Origin(), nextIndex,
 546             loopFooter-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 100)));
 547     loopFooter-&gt;setSuccessors(loopHeader, end);
 548 
 549     end-&gt;appendNew&lt;Value&gt;(proc, Return, Origin());
 550 }
 551 
 552 static int oneFunction(int* callCount)
 553 {
 554     (*callCount)++;
 555     return 1;
 556 }
 557 
 558 static void noOpFunction()
 559 {
 560 }
 561 
 562 void testLICMPure()
 563 {
 564     Procedure proc;
 565 
 566     if (proc.optLevel() &lt; 2)
 567         return;
 568 
 569     generateLoop(
 570         proc,
 571         [&amp;] (BasicBlock* loop, Value*) -&gt; Value* {
 572             return loop-&gt;appendNew&lt;CCallValue&gt;(
 573                 proc, Int32, Origin(), Effects::none(),
 574                 loop-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), tagCFunctionPtr&lt;void*&gt;(oneFunction, B3CCallPtrTag)),
 575                 loop-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0));
 576         });
 577 
 578     unsigned callCount = 0;
 579     compileAndRun&lt;void&gt;(proc, &amp;callCount);
 580     CHECK_EQ(callCount, 1u);
 581 }
 582 
 583 void testLICMPureSideExits()
 584 {
 585     Procedure proc;
 586     if (proc.optLevel() &lt; 2)
 587         return;
 588     generateLoop(
 589         proc,
 590         [&amp;] (BasicBlock* loop, Value*) -&gt; Value* {
 591             Effects effects = Effects::none();
 592             effects.exitsSideways = true;
 593             loop-&gt;appendNew&lt;CCallValue&gt;(
 594                 proc, Void, Origin(), effects,
 595                 loop-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), tagCFunctionPtr&lt;void*&gt;(noOpFunction, B3CCallPtrTag)));
 596 
 597             return loop-&gt;appendNew&lt;CCallValue&gt;(
 598                 proc, Int32, Origin(), Effects::none(),
 599                 loop-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), tagCFunctionPtr&lt;void*&gt;(oneFunction, B3CCallPtrTag)),
 600                 loop-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0));
 601         });
 602 
 603     unsigned callCount = 0;
 604     compileAndRun&lt;void&gt;(proc, &amp;callCount);
 605     CHECK_EQ(callCount, 1u);
 606 }
 607 
 608 void testLICMPureWritesPinned()
 609 {
 610     Procedure proc;
 611     if (proc.optLevel() &lt; 2)
 612         return;
 613     generateLoop(
 614         proc,
 615         [&amp;] (BasicBlock* loop, Value*) -&gt; Value* {
 616             Effects effects = Effects::none();
 617             effects.writesPinned = true;
 618             loop-&gt;appendNew&lt;CCallValue&gt;(
 619                 proc, Void, Origin(), effects,
 620                 loop-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), tagCFunctionPtr&lt;void*&gt;(noOpFunction, B3CCallPtrTag)));
 621 
 622             return loop-&gt;appendNew&lt;CCallValue&gt;(
 623                 proc, Int32, Origin(), Effects::none(),
 624                 loop-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), tagCFunctionPtr&lt;void*&gt;(oneFunction, B3CCallPtrTag)),
 625                 loop-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0));
 626         });
 627 
 628     unsigned callCount = 0;
 629     compileAndRun&lt;void&gt;(proc, &amp;callCount);
 630     CHECK_EQ(callCount, 1u);
 631 }
 632 
 633 void testLICMPureWrites()
 634 {
 635     Procedure proc;
 636     if (proc.optLevel() &lt; 2)
 637         return;
 638     generateLoop(
 639         proc,
 640         [&amp;] (BasicBlock* loop, Value*) -&gt; Value* {
 641             Effects effects = Effects::none();
 642             effects.writes = HeapRange(63479);
 643             loop-&gt;appendNew&lt;CCallValue&gt;(
 644                 proc, Void, Origin(), effects,
 645                 loop-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), tagCFunctionPtr&lt;void*&gt;(noOpFunction, B3CCallPtrTag)));
 646 
 647             return loop-&gt;appendNew&lt;CCallValue&gt;(
 648                 proc, Int32, Origin(), Effects::none(),
 649                 loop-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), tagCFunctionPtr&lt;void*&gt;(oneFunction, B3CCallPtrTag)),
 650                 loop-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0));
 651         });
 652 
 653     unsigned callCount = 0;
 654     compileAndRun&lt;void&gt;(proc, &amp;callCount);
 655     CHECK_EQ(callCount, 1u);
 656 }
 657 
 658 void testLICMReadsLocalState()
 659 {
 660     Procedure proc;
 661     generateLoop(
 662         proc,
 663         [&amp;] (BasicBlock* loop, Value*) -&gt; Value* {
 664             Effects effects = Effects::none();
 665             effects.readsLocalState = true;
 666             return loop-&gt;appendNew&lt;CCallValue&gt;(
 667                 proc, Int32, Origin(), effects,
 668                 loop-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), tagCFunctionPtr&lt;void*&gt;(oneFunction, B3CCallPtrTag)),
 669                 loop-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0));
 670         });
 671 
 672     unsigned callCount = 0;
 673     compileAndRun&lt;void&gt;(proc, &amp;callCount);
 674     CHECK_EQ(callCount, 100u); // We&#39;ll fail to hoist because the loop has Upsilons.
 675 }
 676 
 677 void testLICMReadsPinned()
 678 {
 679     Procedure proc;
 680     if (proc.optLevel() &lt; 2)
 681         return;
 682     generateLoop(
 683         proc,
 684         [&amp;] (BasicBlock* loop, Value*) -&gt; Value* {
 685             Effects effects = Effects::none();
 686             effects.readsPinned = true;
 687             return loop-&gt;appendNew&lt;CCallValue&gt;(
 688                 proc, Int32, Origin(), effects,
 689                 loop-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), tagCFunctionPtr&lt;void*&gt;(oneFunction, B3CCallPtrTag)),
 690                 loop-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0));
 691         });
 692 
 693     unsigned callCount = 0;
 694     compileAndRun&lt;void&gt;(proc, &amp;callCount);
 695     CHECK_EQ(callCount, 1u);
 696 }
 697 
 698 void testLICMReads()
 699 {
 700     Procedure proc;
 701     if (proc.optLevel() &lt; 2)
 702         return;
 703     generateLoop(
 704         proc,
 705         [&amp;] (BasicBlock* loop, Value*) -&gt; Value* {
 706             Effects effects = Effects::none();
 707             effects.reads = HeapRange::top();
 708             return loop-&gt;appendNew&lt;CCallValue&gt;(
 709                 proc, Int32, Origin(), effects,
 710                 loop-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), tagCFunctionPtr&lt;void*&gt;(oneFunction, B3CCallPtrTag)),
 711                 loop-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0));
 712         });
 713 
 714     unsigned callCount = 0;
 715     compileAndRun&lt;void&gt;(proc, &amp;callCount);
 716     CHECK_EQ(callCount, 1u);
 717 }
 718 
 719 void testLICMPureNotBackwardsDominant()
 720 {
 721     Procedure proc;
 722     if (proc.optLevel() &lt; 2)
 723         return;
 724     auto array = makeArrayForLoops();
 725     generateLoopNotBackwardsDominant(
 726         proc, array,
 727         [&amp;] (BasicBlock* loop, Value*) -&gt; Value* {
 728             return loop-&gt;appendNew&lt;CCallValue&gt;(
 729                 proc, Int32, Origin(), Effects::none(),
 730                 loop-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), tagCFunctionPtr&lt;void*&gt;(oneFunction, B3CCallPtrTag)),
 731                 loop-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0));
 732         });
 733 
 734     unsigned callCount = 0;
 735     compileAndRun&lt;void&gt;(proc, &amp;callCount);
 736     CHECK_EQ(callCount, 1u);
 737 }
 738 
 739 void testLICMPureFoiledByChild()
 740 {
 741     Procedure proc;
 742     generateLoop(
 743         proc,
 744         [&amp;] (BasicBlock* loop, Value* index) -&gt; Value* {
 745             return loop-&gt;appendNew&lt;CCallValue&gt;(
 746                 proc, Int32, Origin(), Effects::none(),
 747                 loop-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), tagCFunctionPtr&lt;void*&gt;(oneFunction, B3CCallPtrTag)),
 748                 loop-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0),
 749                 index);
 750         });
 751 
 752     unsigned callCount = 0;
 753     compileAndRun&lt;void&gt;(proc, &amp;callCount);
 754     CHECK_EQ(callCount, 100u);
 755 }
 756 
 757 void testLICMPureNotBackwardsDominantFoiledByChild()
 758 {
 759     Procedure proc;
 760     if (proc.optLevel() &lt; 2)
 761         return;
 762     auto array = makeArrayForLoops();
 763     generateLoopNotBackwardsDominant(
 764         proc, array,
 765         [&amp;] (BasicBlock* loop, Value* index) -&gt; Value* {
 766             return loop-&gt;appendNew&lt;CCallValue&gt;(
 767                 proc, Int32, Origin(), Effects::none(),
 768                 loop-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), tagCFunctionPtr&lt;void*&gt;(oneFunction, B3CCallPtrTag)),
 769                 loop-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0),
 770                 index);
 771         });
 772 
 773     unsigned callCount = 0;
 774     compileAndRun&lt;void&gt;(proc, &amp;callCount);
 775     CHECK_EQ(callCount, 50u);
 776 }
 777 
 778 void testLICMExitsSideways()
 779 {
 780     Procedure proc;
 781     generateLoop(
 782         proc,
 783         [&amp;] (BasicBlock* loop, Value*) -&gt; Value* {
 784             Effects effects = Effects::none();
 785             effects.exitsSideways = true;
 786             return loop-&gt;appendNew&lt;CCallValue&gt;(
 787                 proc, Int32, Origin(), effects,
 788                 loop-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), tagCFunctionPtr&lt;void*&gt;(oneFunction, B3CCallPtrTag)),
 789                 loop-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0));
 790         });
 791 
 792     unsigned callCount = 0;
 793     compileAndRun&lt;void&gt;(proc, &amp;callCount);
 794     CHECK_EQ(callCount, 100u);
 795 }
 796 
 797 void testLICMWritesLocalState()
 798 {
 799     Procedure proc;
 800     generateLoop(
 801         proc,
 802         [&amp;] (BasicBlock* loop, Value*) -&gt; Value* {
 803             Effects effects = Effects::none();
 804             effects.writesLocalState = true;
 805             return loop-&gt;appendNew&lt;CCallValue&gt;(
 806                 proc, Int32, Origin(), effects,
 807                 loop-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), tagCFunctionPtr&lt;void*&gt;(oneFunction, B3CCallPtrTag)),
 808                 loop-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0));
 809         });
 810 
 811     unsigned callCount = 0;
 812     compileAndRun&lt;void&gt;(proc, &amp;callCount);
 813     CHECK_EQ(callCount, 100u);
 814 }
 815 
 816 void testLICMWrites()
 817 {
 818     Procedure proc;
 819     generateLoop(
 820         proc,
 821         [&amp;] (BasicBlock* loop, Value*) -&gt; Value* {
 822             Effects effects = Effects::none();
 823             effects.writes = HeapRange(666);
 824             return loop-&gt;appendNew&lt;CCallValue&gt;(
 825                 proc, Int32, Origin(), effects,
 826                 loop-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), tagCFunctionPtr&lt;void*&gt;(oneFunction, B3CCallPtrTag)),
 827                 loop-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0));
 828         });
 829 
 830     unsigned callCount = 0;
 831     compileAndRun&lt;void&gt;(proc, &amp;callCount);
 832     CHECK_EQ(callCount, 100u);
 833 }
 834 
 835 void testLICMFence()
 836 {
 837     Procedure proc;
 838     generateLoop(
 839         proc,
 840         [&amp;] (BasicBlock* loop, Value*) -&gt; Value* {
 841             Effects effects = Effects::none();
 842             effects.fence = true;
 843             return loop-&gt;appendNew&lt;CCallValue&gt;(
 844                 proc, Int32, Origin(), effects,
 845                 loop-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), tagCFunctionPtr&lt;void*&gt;(oneFunction, B3CCallPtrTag)),
 846                 loop-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0));
 847         });
 848 
 849     unsigned callCount = 0;
 850     compileAndRun&lt;void&gt;(proc, &amp;callCount);
 851     CHECK_EQ(callCount, 100u);
 852 }
 853 
 854 void testLICMWritesPinned()
 855 {
 856     Procedure proc;
 857     generateLoop(
 858         proc,
 859         [&amp;] (BasicBlock* loop, Value*) -&gt; Value* {
 860             Effects effects = Effects::none();
 861             effects.writesPinned = true;
 862             return loop-&gt;appendNew&lt;CCallValue&gt;(
 863                 proc, Int32, Origin(), effects,
 864                 loop-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), tagCFunctionPtr&lt;void*&gt;(oneFunction, B3CCallPtrTag)),
 865                 loop-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0));
 866         });
 867 
 868     unsigned callCount = 0;
 869     compileAndRun&lt;void&gt;(proc, &amp;callCount);
 870     CHECK_EQ(callCount, 100u);
 871 }
 872 
 873 void testLICMControlDependent()
 874 {
 875     Procedure proc;
 876     if (proc.optLevel() &lt; 2)
 877         return;
 878     generateLoop(
 879         proc,
 880         [&amp;] (BasicBlock* loop, Value*) -&gt; Value* {
 881             Effects effects = Effects::none();
 882             effects.controlDependent = true;
 883             return loop-&gt;appendNew&lt;CCallValue&gt;(
 884                 proc, Int32, Origin(), effects,
 885                 loop-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), tagCFunctionPtr&lt;void*&gt;(oneFunction, B3CCallPtrTag)),
 886                 loop-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0));
 887         });
 888 
 889     unsigned callCount = 0;
 890     compileAndRun&lt;void&gt;(proc, &amp;callCount);
 891     CHECK_EQ(callCount, 1u);
 892 }
 893 
 894 void testLICMControlDependentNotBackwardsDominant()
 895 {
 896     Procedure proc;
 897     if (proc.optLevel() &lt; 2)
 898         return;
 899     auto array = makeArrayForLoops();
 900     generateLoopNotBackwardsDominant(
 901         proc, array,
 902         [&amp;] (BasicBlock* loop, Value*) -&gt; Value* {
 903             Effects effects = Effects::none();
 904             effects.controlDependent = true;
 905             return loop-&gt;appendNew&lt;CCallValue&gt;(
 906                 proc, Int32, Origin(), effects,
 907                 loop-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), tagCFunctionPtr&lt;void*&gt;(oneFunction, B3CCallPtrTag)),
 908                 loop-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0));
 909         });
 910 
 911     unsigned callCount = 0;
 912     compileAndRun&lt;void&gt;(proc, &amp;callCount);
 913     CHECK_EQ(callCount, 50u);
 914 }
 915 
 916 void testLICMControlDependentSideExits()
 917 {
 918     Procedure proc;
 919     generateLoop(
 920         proc,
 921         [&amp;] (BasicBlock* loop, Value*) -&gt; Value* {
 922             Effects effects = Effects::none();
 923             effects.exitsSideways = true;
 924             loop-&gt;appendNew&lt;CCallValue&gt;(
 925                 proc, Void, Origin(), effects,
 926                 loop-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), tagCFunctionPtr&lt;void*&gt;(noOpFunction, B3CCallPtrTag)));
 927 
 928             effects = Effects::none();
 929             effects.controlDependent = true;
 930             return loop-&gt;appendNew&lt;CCallValue&gt;(
 931                 proc, Int32, Origin(), effects,
 932                 loop-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), tagCFunctionPtr&lt;void*&gt;(oneFunction, B3CCallPtrTag)),
 933                 loop-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0));
 934         });
 935 
 936     unsigned callCount = 0;
 937     compileAndRun&lt;void&gt;(proc, &amp;callCount);
 938     CHECK_EQ(callCount, 100u);
 939 }
 940 
 941 void testLICMReadsPinnedWritesPinned()
 942 {
 943     Procedure proc;
 944     generateLoop(
 945         proc,
 946         [&amp;] (BasicBlock* loop, Value*) -&gt; Value* {
 947             Effects effects = Effects::none();
 948             effects.writesPinned = true;
 949             loop-&gt;appendNew&lt;CCallValue&gt;(
 950                 proc, Void, Origin(), effects,
 951                 loop-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), tagCFunctionPtr&lt;void*&gt;(noOpFunction, B3CCallPtrTag)));
 952 
 953             effects = Effects::none();
 954             effects.readsPinned = true;
 955             return loop-&gt;appendNew&lt;CCallValue&gt;(
 956                 proc, Int32, Origin(), effects,
 957                 loop-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), tagCFunctionPtr&lt;void*&gt;(oneFunction, B3CCallPtrTag)),
 958                 loop-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0));
 959         });
 960 
 961     unsigned callCount = 0;
 962     compileAndRun&lt;void&gt;(proc, &amp;callCount);
 963     CHECK_EQ(callCount, 100u);
 964 }
 965 
 966 void testLICMReadsWritesDifferentHeaps()
 967 {
 968     Procedure proc;
 969     if (proc.optLevel() &lt; 2)
 970         return;
 971     generateLoop(
 972         proc,
 973         [&amp;] (BasicBlock* loop, Value*) -&gt; Value* {
 974             Effects effects = Effects::none();
 975             effects.writes = HeapRange(6436);
 976             loop-&gt;appendNew&lt;CCallValue&gt;(
 977                 proc, Void, Origin(), effects,
 978                 loop-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), tagCFunctionPtr&lt;void*&gt;(noOpFunction, B3CCallPtrTag)));
 979 
 980             effects = Effects::none();
 981             effects.reads = HeapRange(4886);
 982             return loop-&gt;appendNew&lt;CCallValue&gt;(
 983                 proc, Int32, Origin(), effects,
 984                 loop-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), tagCFunctionPtr&lt;void*&gt;(oneFunction, B3CCallPtrTag)),
 985                 loop-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0));
 986         });
 987 
 988     unsigned callCount = 0;
 989     compileAndRun&lt;void&gt;(proc, &amp;callCount);
 990     CHECK_EQ(callCount, 1u);
 991 }
 992 
 993 void testLICMReadsWritesOverlappingHeaps()
 994 {
 995     Procedure proc;
 996     generateLoop(
 997         proc,
 998         [&amp;] (BasicBlock* loop, Value*) -&gt; Value* {
 999             Effects effects = Effects::none();
1000             effects.writes = HeapRange(6436, 74458);
1001             loop-&gt;appendNew&lt;CCallValue&gt;(
1002                 proc, Void, Origin(), effects,
1003                 loop-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), tagCFunctionPtr&lt;void*&gt;(noOpFunction, B3CCallPtrTag)));
1004 
1005             effects = Effects::none();
1006             effects.reads = HeapRange(48864, 78239);
1007             return loop-&gt;appendNew&lt;CCallValue&gt;(
1008                 proc, Int32, Origin(), effects,
1009                 loop-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), tagCFunctionPtr&lt;void*&gt;(oneFunction, B3CCallPtrTag)),
1010                 loop-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0));
1011         });
1012 
1013     unsigned callCount = 0;
1014     compileAndRun&lt;void&gt;(proc, &amp;callCount);
1015     CHECK_EQ(callCount, 100u);
1016 }
1017 
1018 void testLICMDefaultCall()
1019 {
1020     Procedure proc;
1021     generateLoop(
1022         proc,
1023         [&amp;] (BasicBlock* loop, Value*) -&gt; Value* {
1024             return loop-&gt;appendNew&lt;CCallValue&gt;(
1025                 proc, Int32, Origin(),
1026                 loop-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), tagCFunctionPtr&lt;void*&gt;(oneFunction, B3CCallPtrTag)),
1027                 loop-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0));
1028         });
1029 
1030     unsigned callCount = 0;
1031     compileAndRun&lt;void&gt;(proc, &amp;callCount);
1032     CHECK_EQ(callCount, 100u);
1033 }
1034 
1035 void testDepend32()
1036 {
1037     Procedure proc;
1038     BasicBlock* root = proc.addBlock();
1039     Value* ptr = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0);
1040     Value* first = root-&gt;appendNew&lt;MemoryValue&gt;(proc, Load, Int32, Origin(), ptr, 0);
1041     Value* second = root-&gt;appendNew&lt;MemoryValue&gt;(
1042         proc, Load, Int32, Origin(),
1043         root-&gt;appendNew&lt;Value&gt;(
1044             proc, Add, Origin(), ptr,
1045             root-&gt;appendNew&lt;Value&gt;(
1046                 proc, ZExt32, Origin(),
1047                 root-&gt;appendNew&lt;Value&gt;(proc, Depend, Origin(), first))),
1048         4);
1049     root-&gt;appendNew&lt;Value&gt;(
1050         proc, Return, Origin(),
1051         root-&gt;appendNew&lt;Value&gt;(proc, Add, Origin(), first, second));
1052 
1053     int32_t values[2];
1054     values[0] = 42;
1055     values[1] = 0xbeef;
1056 
1057     auto code = compileProc(proc);
1058     if (isARM64())
1059         checkUsesInstruction(*code, &quot;eor&quot;);
1060     else if (isX86()) {
1061         checkDoesNotUseInstruction(*code, &quot;mfence&quot;);
1062         checkDoesNotUseInstruction(*code, &quot;lock&quot;);
1063     }
1064     CHECK_EQ(invoke&lt;int32_t&gt;(*code, values), 42 + 0xbeef);
1065 }
1066 
1067 void testDepend64()
1068 {
1069     Procedure proc;
1070     BasicBlock* root = proc.addBlock();
1071     Value* ptr = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0);
1072     Value* first = root-&gt;appendNew&lt;MemoryValue&gt;(proc, Load, Int64, Origin(), ptr, 0);
1073     Value* second = root-&gt;appendNew&lt;MemoryValue&gt;(
1074         proc, Load, Int64, Origin(),
1075         root-&gt;appendNew&lt;Value&gt;(
1076             proc, Add, Origin(), ptr,
1077             root-&gt;appendNew&lt;Value&gt;(proc, Depend, Origin(), first)),
1078         8);
1079     root-&gt;appendNew&lt;Value&gt;(
1080         proc, Return, Origin(),
1081         root-&gt;appendNew&lt;Value&gt;(proc, Add, Origin(), first, second));
1082 
1083     int64_t values[2];
1084     values[0] = 42;
1085     values[1] = 0xbeef;
1086 
1087     auto code = compileProc(proc);
1088     if (isARM64())
1089         checkUsesInstruction(*code, &quot;eor&quot;);
1090     else if (isX86()) {
1091         checkDoesNotUseInstruction(*code, &quot;mfence&quot;);
1092         checkDoesNotUseInstruction(*code, &quot;lock&quot;);
1093     }
1094     CHECK_EQ(invoke&lt;int64_t&gt;(*code, values), 42 + 0xbeef);
1095 }
1096 
1097 void testWasmBoundsCheck(unsigned offset)
1098 {
1099     Procedure proc;
1100     if (proc.optLevel() &lt; 1)
1101         return;
1102     GPRReg pinned = GPRInfo::argumentGPR1;
1103     proc.pinRegister(pinned);
1104 
1105     proc.setWasmBoundsCheckGenerator([=] (CCallHelpers&amp; jit, GPRReg pinnedGPR) {
1106         CHECK_EQ(pinnedGPR, pinned);
1107 
1108         // This should always work because a function this simple should never have callee
1109         // saves.
1110         jit.move(CCallHelpers::TrustedImm32(42), GPRInfo::returnValueGPR);
1111         jit.emitFunctionEpilogue();
1112         jit.ret();
1113     });
1114 
1115     BasicBlock* root = proc.addBlock();
1116     Value* left = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0);
1117     if (pointerType() != Int32)
1118         left = root-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(), left);
1119     root-&gt;appendNew&lt;WasmBoundsCheckValue&gt;(proc, Origin(), pinned, left, offset);
1120     Value* result = root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 0x42);
1121     root-&gt;appendNewControlValue(proc, Return, Origin(), result);
1122 
1123     auto code = compileProc(proc);
1124     uint32_t bound = 2 + offset;
1125     auto computeResult = [&amp;] (uint32_t input) {
1126         return input + offset &lt; bound ? 0x42 : 42;
1127     };
1128 
1129     CHECK_EQ(invoke&lt;int32_t&gt;(*code, 1, bound), computeResult(1));
1130     CHECK_EQ(invoke&lt;int32_t&gt;(*code, 3, bound), computeResult(3));
1131     CHECK_EQ(invoke&lt;int32_t&gt;(*code, 2, bound), computeResult(2));
1132 }
1133 
1134 void testWasmAddress()
1135 {
1136     Procedure proc;
1137     GPRReg pinnedGPR = GPRInfo::argumentGPR2;
1138     proc.pinRegister(pinnedGPR);
1139 
1140     unsigned loopCount = 100;
1141     Vector&lt;unsigned&gt; values(loopCount);
1142     unsigned numToStore = 42;
1143 
1144     BasicBlock* root = proc.addBlock();
1145     BasicBlock* header = proc.addBlock();
1146     BasicBlock* body = proc.addBlock();
1147     BasicBlock* continuation = proc.addBlock();
1148 
1149     // Root
1150     Value* loopCountValue = root-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(), root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0));
1151     Value* valueToStore = root-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(), root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1));
1152     UpsilonValue* beginUpsilon = root-&gt;appendNew&lt;UpsilonValue&gt;(proc, Origin(), root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 0));
1153     root-&gt;appendNewControlValue(proc, Jump, Origin(), header);
1154 
1155     // Header
1156     Value* indexPhi = header-&gt;appendNew&lt;Value&gt;(proc, Phi, Int32, Origin());
1157     header-&gt;appendNewControlValue(proc, Branch, Origin(),
1158         header-&gt;appendNew&lt;Value&gt;(proc, Below, Origin(), indexPhi, loopCountValue),
1159         body, continuation);
1160 
1161     // Body
1162     Value* pointer = body-&gt;appendNew&lt;Value&gt;(proc, Mul, Origin(), indexPhi,
1163         body-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), sizeof(unsigned)));
1164     pointer = body-&gt;appendNew&lt;Value&gt;(proc, ZExt32, Origin(), pointer);
1165     body-&gt;appendNew&lt;MemoryValue&gt;(proc, Store, Origin(), valueToStore,
1166         body-&gt;appendNew&lt;WasmAddressValue&gt;(proc, Origin(), pointer, pinnedGPR), 0);
1167     UpsilonValue* incUpsilon = body-&gt;appendNew&lt;UpsilonValue&gt;(proc, Origin(),
1168         body-&gt;appendNew&lt;Value&gt;(proc, Add, Origin(), indexPhi,
1169             body-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 1)));
1170     body-&gt;appendNewControlValue(proc, Jump, Origin(), header);
1171 
1172     // Continuation
1173     continuation-&gt;appendNewControlValue(proc, Return, Origin());
1174 
1175     beginUpsilon-&gt;setPhi(indexPhi);
1176     incUpsilon-&gt;setPhi(indexPhi);
1177 
1178 
1179     auto code = compileProc(proc);
1180     invoke&lt;void&gt;(*code, loopCount, numToStore, values.data());
1181     for (unsigned value : values)
1182         CHECK_EQ(numToStore, value);
1183 }
1184 
1185 void testFastTLSLoad()
1186 {
1187 #if ENABLE(FAST_TLS_JIT)
1188     _pthread_setspecific_direct(WTF_TESTING_KEY, bitwise_cast&lt;void*&gt;(static_cast&lt;uintptr_t&gt;(0xbeef)));
1189 
1190     Procedure proc;
1191     BasicBlock* root = proc.addBlock();
1192 
1193     PatchpointValue* patchpoint = root-&gt;appendNew&lt;PatchpointValue&gt;(proc, pointerType(), Origin());
1194     patchpoint-&gt;clobber(RegisterSet::macroScratchRegisters());
1195     patchpoint-&gt;setGenerator(
1196         [&amp;] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
1197             AllowMacroScratchRegisterUsage allowScratch(jit);
1198             jit.loadFromTLSPtr(fastTLSOffsetForKey(WTF_TESTING_KEY), params[0].gpr());
1199         });
1200 
1201     root-&gt;appendNew&lt;Value&gt;(proc, Return, Origin(), patchpoint);
1202 
1203     CHECK_EQ(compileAndRun&lt;uintptr_t&gt;(proc), static_cast&lt;uintptr_t&gt;(0xbeef));
1204 #endif
1205 }
1206 
1207 void testFastTLSStore()
1208 {
1209 #if ENABLE(FAST_TLS_JIT)
1210     Procedure proc;
1211     BasicBlock* root = proc.addBlock();
1212 
1213     PatchpointValue* patchpoint = root-&gt;appendNew&lt;PatchpointValue&gt;(proc, Void, Origin());
1214     patchpoint-&gt;clobber(RegisterSet::macroScratchRegisters());
1215     patchpoint-&gt;numGPScratchRegisters = 1;
1216     patchpoint-&gt;setGenerator(
1217         [&amp;] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
1218             AllowMacroScratchRegisterUsage allowScratch(jit);
1219             GPRReg scratch = params.gpScratch(0);
1220             jit.move(CCallHelpers::TrustedImm32(0xdead), scratch);
1221             jit.storeToTLSPtr(scratch, fastTLSOffsetForKey(WTF_TESTING_KEY));
1222         });
1223 
1224     root-&gt;appendNewControlValue(proc, Return, Origin());
1225 
1226     compileAndRun&lt;void&gt;(proc);
1227     CHECK_EQ(bitwise_cast&lt;uintptr_t&gt;(_pthread_getspecific_direct(WTF_TESTING_KEY)), static_cast&lt;uintptr_t&gt;(0xdead));
1228 #endif
1229 }
1230 
1231 static NEVER_INLINE bool doubleEq(double a, double b) { return a == b; }
1232 static NEVER_INLINE bool doubleNeq(double a, double b) { return a != b; }
1233 static NEVER_INLINE bool doubleGt(double a, double b) { return a &gt; b; }
1234 static NEVER_INLINE bool doubleGte(double a, double b) { return a &gt;= b; }
1235 static NEVER_INLINE bool doubleLt(double a, double b) { return a &lt; b; }
1236 static NEVER_INLINE bool doubleLte(double a, double b) { return a &lt;= b; }
1237 
1238 void testDoubleLiteralComparison(double a, double b)
1239 {
1240     using Test = std::tuple&lt;B3::Opcode, bool (*)(double, double)&gt;;
1241     StdList&lt;Test&gt; tests = {
1242         Test { NotEqual, doubleNeq },
1243         Test { Equal, doubleEq },
1244         Test { EqualOrUnordered, doubleEq },
1245         Test { GreaterThan, doubleGt },
1246         Test { GreaterEqual, doubleGte },
1247         Test { LessThan, doubleLt },
1248         Test { LessEqual, doubleLte },
1249     };
1250 
1251     for (const Test&amp; test : tests) {
1252         Procedure proc;
1253         BasicBlock* root = proc.addBlock();
1254         Value* valueA = root-&gt;appendNew&lt;ConstDoubleValue&gt;(proc, Origin(), a);
1255         Value* valueB = root-&gt;appendNew&lt;ConstDoubleValue&gt;(proc, Origin(), b);
1256 
1257         // This is here just to make reduceDoubleToFloat do things.
1258         Value* valueC = root-&gt;appendNew&lt;ConstDoubleValue&gt;(proc, Origin(), 0.0);
1259         Value* valueAsFloat = root-&gt;appendNew&lt;Value&gt;(proc, DoubleToFloat, Origin(), valueC);
1260 
1261         root-&gt;appendNewControlValue(
1262             proc, Return, Origin(),
1263                 root-&gt;appendNew&lt;Value&gt;(proc, BitAnd, Origin(),
1264                     root-&gt;appendNew&lt;Value&gt;(proc, std::get&lt;0&gt;(test), Origin(), valueA, valueB),
1265                     root-&gt;appendNew&lt;Value&gt;(proc, Equal, Origin(), valueAsFloat, valueAsFloat)));
1266 
1267         CHECK(!!compileAndRun&lt;int32_t&gt;(proc) == std::get&lt;1&gt;(test)(a, b));
1268     }
1269 }
1270 
1271 void testFloatEqualOrUnorderedFolding()
1272 {
1273     for (auto&amp; first : floatingPointOperands&lt;float&gt;()) {
1274         for (auto&amp; second : floatingPointOperands&lt;float&gt;()) {
1275             float a = first.value;
1276             float b = second.value;
1277             bool expectedResult = (a == b) || std::isunordered(a, b);
1278             Procedure proc;
1279             BasicBlock* root = proc.addBlock();
1280             Value* constA = root-&gt;appendNew&lt;ConstFloatValue&gt;(proc, Origin(), a);
1281             Value* constB = root-&gt;appendNew&lt;ConstFloatValue&gt;(proc, Origin(), b);
1282 
1283             root-&gt;appendNewControlValue(proc, Return, Origin(),
1284                 root-&gt;appendNew&lt;Value&gt;(
1285                     proc, EqualOrUnordered, Origin(),
1286                     constA,
1287                     constB));
1288             CHECK(!!compileAndRun&lt;int32_t&gt;(proc) == expectedResult);
1289         }
1290     }
1291 }
1292 
1293 void testFloatEqualOrUnorderedFoldingNaN()
1294 {
1295     StdList&lt;float&gt; nans = {
1296         bitwise_cast&lt;float&gt;(0xfffffffd),
1297         bitwise_cast&lt;float&gt;(0xfffffffe),
1298         bitwise_cast&lt;float&gt;(0xfffffff0),
1299         static_cast&lt;float&gt;(PNaN),
1300     };
1301 
1302     unsigned i = 0;
1303     for (float nan : nans) {
1304         RELEASE_ASSERT(std::isnan(nan));
1305         Procedure proc;
1306         BasicBlock* root = proc.addBlock();
1307         Value* a = root-&gt;appendNew&lt;ConstFloatValue&gt;(proc, Origin(), nan);
1308         Value* b = root-&gt;appendNew&lt;Value&gt;(proc, DoubleToFloat, Origin(),
1309             root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), FPRInfo::argumentFPR0));
1310 
1311         if (i % 2)
1312             std::swap(a, b);
1313         ++i;
1314         root-&gt;appendNewControlValue(proc, Return, Origin(),
1315             root-&gt;appendNew&lt;Value&gt;(proc, EqualOrUnordered, Origin(), a, b));
1316         CHECK(!!compileAndRun&lt;int32_t&gt;(proc, static_cast&lt;double&gt;(1.0)));
1317     }
1318 }
1319 
1320 void testFloatEqualOrUnorderedDontFold()
1321 {
1322     for (auto&amp; first : floatingPointOperands&lt;float&gt;()) {
1323         float a = first.value;
1324         Procedure proc;
1325         BasicBlock* root = proc.addBlock();
1326         Value* constA = root-&gt;appendNew&lt;ConstFloatValue&gt;(proc, Origin(), a);
1327         Value* b = root-&gt;appendNew&lt;Value&gt;(proc, DoubleToFloat, Origin(),
1328             root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), FPRInfo::argumentFPR0));
1329         root-&gt;appendNewControlValue(proc, Return, Origin(),
1330             root-&gt;appendNew&lt;Value&gt;(
1331                 proc, EqualOrUnordered, Origin(), constA, b));
1332 
1333         auto code = compileProc(proc);
1334 
1335         for (auto&amp; second : floatingPointOperands&lt;float&gt;()) {
1336             float b = second.value;
1337             bool expectedResult = (a == b) || std::isunordered(a, b);
1338             CHECK(!!invoke&lt;int32_t&gt;(*code, static_cast&lt;double&gt;(b)) == expectedResult);
1339         }
1340     }
1341 }
1342 
1343 static void functionNineArgs(int32_t, void*, void*, void*, void*, void*, void*, void*, void*) { }
1344 
1345 void testShuffleDoesntTrashCalleeSaves()
1346 {
1347     Procedure proc;
1348 
1349     BasicBlock* root = proc.addBlock();
1350     BasicBlock* likely = proc.addBlock();
1351     BasicBlock* unlikely = proc.addBlock();
1352 
1353     RegisterSet regs = RegisterSet::allGPRs();
1354     regs.exclude(RegisterSet::stackRegisters());
1355     regs.exclude(RegisterSet::reservedHardwareRegisters());
1356     regs.exclude(RegisterSet::calleeSaveRegisters());
1357     regs.exclude(RegisterSet::argumentGPRS());
1358 
1359     unsigned i = 0;
1360     Vector&lt;Value*&gt; patches;
1361     for (Reg reg : regs) {
1362         ++i;
1363         PatchpointValue* patchpoint = root-&gt;appendNew&lt;PatchpointValue&gt;(proc, Int32, Origin());
1364         patchpoint-&gt;clobber(RegisterSet::macroScratchRegisters());
1365         RELEASE_ASSERT(reg.isGPR());
1366         patchpoint-&gt;resultConstraints = { ValueRep::reg(reg.gpr()) };
1367         patchpoint-&gt;setGenerator(
1368             [=] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
1369                 AllowMacroScratchRegisterUsage allowScratch(jit);
1370                 jit.move(CCallHelpers::TrustedImm32(i), params[0].gpr());
1371             });
1372         patches.append(patchpoint);
1373     }
1374 
1375     Value* arg1 = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::toArgumentRegister(0 % GPRInfo::numberOfArgumentRegisters));
1376     Value* arg2 = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::toArgumentRegister(1 % GPRInfo::numberOfArgumentRegisters));
1377     Value* arg3 = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::toArgumentRegister(2 % GPRInfo::numberOfArgumentRegisters));
1378     Value* arg4 = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::toArgumentRegister(3 % GPRInfo::numberOfArgumentRegisters));
1379     Value* arg5 = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::toArgumentRegister(4 % GPRInfo::numberOfArgumentRegisters));
1380     Value* arg6 = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::toArgumentRegister(5 % GPRInfo::numberOfArgumentRegisters));
1381     Value* arg7 = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::toArgumentRegister(6 % GPRInfo::numberOfArgumentRegisters));
1382     Value* arg8 = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::toArgumentRegister(7 % GPRInfo::numberOfArgumentRegisters));
1383 
1384     PatchpointValue* ptr = root-&gt;appendNew&lt;PatchpointValue&gt;(proc, Int64, Origin());
1385     ptr-&gt;clobber(RegisterSet::macroScratchRegisters());
1386     ptr-&gt;resultConstraints = { ValueRep::reg(GPRInfo::regCS0) };
1387     ptr-&gt;appendSomeRegister(arg1);
1388     ptr-&gt;setGenerator(
1389         [=] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
1390             AllowMacroScratchRegisterUsage allowScratch(jit);
1391             jit.move(params[1].gpr(), params[0].gpr());
1392         });
1393 
1394     Value* condition = root-&gt;appendNew&lt;Value&gt;(
1395         proc, Equal, Origin(),
1396         ptr,
1397         root-&gt;appendNew&lt;Const64Value&gt;(proc, Origin(), 0));
1398 
1399     root-&gt;appendNewControlValue(
1400         proc, Branch, Origin(),
1401         condition,
1402         FrequentedBlock(likely, FrequencyClass::Normal), FrequentedBlock(unlikely, FrequencyClass::Rare));
1403 
1404     // Never executes.
1405     Value* const42 = likely-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 42);
1406     likely-&gt;appendNewControlValue(proc, Return, Origin(), const42);
1407 
1408     // Always executes.
1409     Value* constNumber = unlikely-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 0x1);
1410 
1411     unlikely-&gt;appendNew&lt;CCallValue&gt;(
1412         proc, Void, Origin(),
1413         unlikely-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), tagCFunctionPtr&lt;void*&gt;(functionNineArgs, B3CCallPtrTag)),
1414         constNumber, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);
1415 
1416     PatchpointValue* voidPatch = unlikely-&gt;appendNew&lt;PatchpointValue&gt;(proc, Void, Origin());
1417     voidPatch-&gt;clobber(RegisterSet::macroScratchRegisters());
1418     for (Value* v : patches)
1419         voidPatch-&gt;appendSomeRegister(v);
1420     voidPatch-&gt;appendSomeRegister(arg1);
1421     voidPatch-&gt;appendSomeRegister(arg2);
1422     voidPatch-&gt;appendSomeRegister(arg3);
1423     voidPatch-&gt;appendSomeRegister(arg4);
1424     voidPatch-&gt;appendSomeRegister(arg5);
1425     voidPatch-&gt;appendSomeRegister(arg6);
1426     voidPatch-&gt;setGenerator([=] (CCallHelpers&amp;, const StackmapGenerationParams&amp;) { });
1427 
1428     unlikely-&gt;appendNewControlValue(proc, Return, Origin(),
1429         unlikely-&gt;appendNew&lt;MemoryValue&gt;(proc, Load, Int32, Origin(), ptr));
1430 
1431     int32_t* inputPtr = static_cast&lt;int32_t*&gt;(fastMalloc(sizeof(int32_t)));
1432     *inputPtr = 48;
1433     CHECK(compileAndRun&lt;int32_t&gt;(proc, inputPtr) == 48);
1434     fastFree(inputPtr);
1435 }
1436 
1437 void testDemotePatchpointTerminal()
1438 {
1439     Procedure proc;
1440 
1441     BasicBlock* root = proc.addBlock();
1442     BasicBlock* done = proc.addBlock();
1443 
1444     PatchpointValue* patchpoint = root-&gt;appendNew&lt;PatchpointValue&gt;(proc, Int32, Origin());
1445     patchpoint-&gt;effects.terminal = true;
1446     root-&gt;setSuccessors(done);
1447 
1448     done-&gt;appendNew&lt;Value&gt;(proc, Return, Origin(), patchpoint);
1449 
1450     proc.resetReachability();
1451     breakCriticalEdges(proc);
1452     IndexSet&lt;Value*&gt; valuesToDemote;
1453     valuesToDemote.add(patchpoint);
1454     demoteValues(proc, valuesToDemote);
1455     validate(proc);
1456 }
1457 
1458 void testReportUsedRegistersLateUseFollowedByEarlyDefDoesNotMarkUseAsDead()
1459 {
1460     Procedure proc;
1461     if (proc.optLevel() &lt; 2)
1462         return;
1463     BasicBlock* root = proc.addBlock();
1464 
1465     RegisterSet allRegs = RegisterSet::allGPRs();
1466     allRegs.exclude(RegisterSet::stackRegisters());
1467     allRegs.exclude(RegisterSet::reservedHardwareRegisters());
1468 
1469     {
1470         // Make every reg 42 (just needs to be a value other than 10).
1471         PatchpointValue* patchpoint = root-&gt;appendNew&lt;PatchpointValue&gt;(proc, Void, Origin());
1472         Value* const42 = root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 42);
1473         for (Reg reg : allRegs)
1474             patchpoint-&gt;append(const42, ValueRep::reg(reg));
1475         patchpoint-&gt;setGenerator([&amp;] (CCallHelpers&amp;, const StackmapGenerationParams&amp;) { });
1476     }
1477 
1478     {
1479         PatchpointValue* patchpoint = root-&gt;appendNew&lt;PatchpointValue&gt;(proc, Void, Origin());
1480         Value* const10 = root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 10);
1481         for (Reg reg : allRegs)
1482             patchpoint-&gt;append(const10, ValueRep::lateReg(reg));
1483         patchpoint-&gt;setGenerator([&amp;] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp;) {
1484             for (Reg reg : allRegs) {
1485                 auto done = jit.branch32(CCallHelpers::Equal, reg.gpr(), CCallHelpers::TrustedImm32(10));
1486                 jit.breakpoint();
1487                 done.link(&amp;jit);
1488             }
1489         });
1490     }
1491 
1492     {
1493         PatchpointValue* patchpoint = root-&gt;appendNew&lt;PatchpointValue&gt;(proc, Int32, Origin());
1494         patchpoint-&gt;resultConstraints = { ValueRep::SomeEarlyRegister };
1495         patchpoint-&gt;setGenerator([&amp;] (CCallHelpers&amp;, const StackmapGenerationParams&amp; params) {
1496             RELEASE_ASSERT(allRegs.contains(params[0].gpr()));
1497         });
1498     }
1499 
1500     root-&gt;appendNewControlValue(proc, Return, Origin());
1501 
1502     compileAndRun&lt;void&gt;(proc);
1503 }
1504 
1505 void testInfiniteLoopDoesntCauseBadHoisting()
1506 {
1507     Procedure proc;
1508     if (proc.optLevel() &lt; 2)
1509         return;
1510     BasicBlock* root = proc.addBlock();
1511     BasicBlock* header = proc.addBlock();
1512     BasicBlock* loadBlock = proc.addBlock();
1513     BasicBlock* postLoadBlock = proc.addBlock();
1514 
1515     Value* arg = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0);
1516     root-&gt;appendNewControlValue(proc, Jump, Origin(), header);
1517 
1518     header-&gt;appendNewControlValue(
1519         proc, Branch, Origin(),
1520         header-&gt;appendNew&lt;Value&gt;(proc, Equal, Origin(),
1521             arg,
1522             header-&gt;appendNew&lt;Const64Value&gt;(proc, Origin(), 10)), header, loadBlock);
1523 
1524     PatchpointValue* patchpoint = loadBlock-&gt;appendNew&lt;PatchpointValue&gt;(proc, Void, Origin());
1525     patchpoint-&gt;effects = Effects::none();
1526     patchpoint-&gt;effects.writesLocalState = true; // Don&#39;t DCE this.
1527     patchpoint-&gt;setGenerator(
1528         [&amp;] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp;) {
1529             // This works because we don&#39;t have callee saves.
1530             jit.emitFunctionEpilogue();
1531             jit.ret();
1532         });
1533 
1534     Value* badLoad = loadBlock-&gt;appendNew&lt;MemoryValue&gt;(proc, Load, Int64, Origin(), arg, 0);
1535 
1536     loadBlock-&gt;appendNewControlValue(
1537         proc, Branch, Origin(),
1538         loadBlock-&gt;appendNew&lt;Value&gt;(proc, Equal, Origin(),
1539             badLoad,
1540             loadBlock-&gt;appendNew&lt;Const64Value&gt;(proc, Origin(), 45)), header, postLoadBlock);
1541 
1542     postLoadBlock-&gt;appendNewControlValue(proc, Return, Origin(), badLoad);
1543 
1544     // The patchpoint early ret() works because we don&#39;t have callee saves.
1545     auto code = compileProc(proc);
1546     RELEASE_ASSERT(!proc.calleeSaveRegisterAtOffsetList().size());
1547     invoke&lt;void&gt;(*code, static_cast&lt;uint64_t&gt;(55)); // Shouldn&#39;t crash dereferncing 55.
1548 }
1549 
1550 static void testSimpleTuplePair(unsigned first, int64_t second)
1551 {
1552     Procedure proc;
1553     BasicBlock* root = proc.addBlock();
1554 
1555     PatchpointValue* patchpoint = root-&gt;appendNew&lt;PatchpointValue&gt;(proc, proc.addTuple({ Int32, Int64 }), Origin());
1556     patchpoint-&gt;clobber(RegisterSet::macroScratchRegisters());
1557     patchpoint-&gt;resultConstraints = { ValueRep::SomeRegister, ValueRep::SomeRegister };
1558     patchpoint-&gt;setGenerator([&amp;] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
1559         AllowMacroScratchRegisterUsage allowScratch(jit);
1560         jit.move(CCallHelpers::TrustedImm32(first), params[0].gpr());
1561         jit.move(CCallHelpers::TrustedImm64(second), params[1].gpr());
1562     });
1563     Value* i32 = root-&gt;appendNew&lt;Value&gt;(proc, ZExt32, Origin(),
1564         root-&gt;appendNew&lt;ExtractValue&gt;(proc, Origin(), Int32, patchpoint, 0));
1565     Value* i64 = root-&gt;appendNew&lt;ExtractValue&gt;(proc, Origin(), Int64, patchpoint, 1);
1566     root-&gt;appendNew&lt;Value&gt;(proc, Return, Origin(), root-&gt;appendNew&lt;Value&gt;(proc, Add, Origin(), i32, i64));
1567 
1568     CHECK_EQ(compileAndRun&lt;int64_t&gt;(proc), first + second);
1569 }
1570 
1571 static void testSimpleTuplePairUnused(unsigned first, int64_t second)
1572 {
1573     Procedure proc;
1574     BasicBlock* root = proc.addBlock();
1575 
1576     PatchpointValue* patchpoint = root-&gt;appendNew&lt;PatchpointValue&gt;(proc, proc.addTuple({ Int32, Int64, Double }), Origin());
1577     patchpoint-&gt;clobber(RegisterSet::macroScratchRegisters());
1578     patchpoint-&gt;resultConstraints = { ValueRep::SomeRegister, ValueRep::SomeRegister, ValueRep::SomeRegister };
1579     patchpoint-&gt;setGenerator([&amp;] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
1580         AllowMacroScratchRegisterUsage allowScratch(jit);
1581         jit.move(CCallHelpers::TrustedImm32(first), params[0].gpr());
1582         jit.move(CCallHelpers::TrustedImm64(second), params[1].gpr());
1583         jit.moveDouble(CCallHelpers::Imm64(bitwise_cast&lt;uint64_t&gt;(0.0)), params[2].fpr());
1584     });
1585     Value* i32 = root-&gt;appendNew&lt;Value&gt;(proc, ZExt32, Origin(),
1586         root-&gt;appendNew&lt;ExtractValue&gt;(proc, Origin(), Int32, patchpoint, 0));
1587     Value* i64 = root-&gt;appendNew&lt;ExtractValue&gt;(proc, Origin(), Int64, patchpoint, 1);
1588     root-&gt;appendNew&lt;Value&gt;(proc, Return, Origin(), root-&gt;appendNew&lt;Value&gt;(proc, Add, Origin(), i32, i64));
1589 
1590     CHECK_EQ(compileAndRun&lt;int64_t&gt;(proc), first + second);
1591 }
1592 
1593 static void testSimpleTuplePairStack(unsigned first, int64_t second)
1594 {
1595     Procedure proc;
1596     BasicBlock* root = proc.addBlock();
1597 
1598     PatchpointValue* patchpoint = root-&gt;appendNew&lt;PatchpointValue&gt;(proc, proc.addTuple({ Int32, Int64 }), Origin());
1599     patchpoint-&gt;clobber(RegisterSet::macroScratchRegisters());
1600     patchpoint-&gt;resultConstraints = { ValueRep::SomeRegister, ValueRep::stackArgument(0) };
1601     patchpoint-&gt;setGenerator([&amp;] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
1602         AllowMacroScratchRegisterUsage allowScratch(jit);
1603         jit.move(CCallHelpers::TrustedImm32(first), params[0].gpr());
1604         jit.store64(CCallHelpers::TrustedImm64(second), CCallHelpers::Address(CCallHelpers::framePointerRegister, params[1].offsetFromFP()));
1605     });
1606     Value* i32 = root-&gt;appendNew&lt;Value&gt;(proc, ZExt32, Origin(),
1607         root-&gt;appendNew&lt;ExtractValue&gt;(proc, Origin(), Int32, patchpoint, 0));
1608     Value* i64 = root-&gt;appendNew&lt;ExtractValue&gt;(proc, Origin(), Int64, patchpoint, 1);
1609     root-&gt;appendNew&lt;Value&gt;(proc, Return, Origin(), root-&gt;appendNew&lt;Value&gt;(proc, Add, Origin(), i32, i64));
1610 
1611     CHECK_EQ(compileAndRun&lt;int64_t&gt;(proc), first + second);
1612 }
1613 
1614 template&lt;bool shouldFixSSA&gt;
1615 static void tailDupedTuplePair(unsigned first, double second)
1616 {
1617     Procedure proc;
1618     BasicBlock* root = proc.addBlock();
1619     BasicBlock* truthy = proc.addBlock();
1620     BasicBlock* falsey = proc.addBlock();
1621 
1622     Type tupleType = proc.addTuple({ Int32, Double });
1623     Variable* var = proc.addVariable(tupleType);
1624 
1625     Value* test = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0);
1626     PatchpointValue* patchpoint = root-&gt;appendNew&lt;PatchpointValue&gt;(proc, tupleType, Origin());
1627     patchpoint-&gt;clobber(RegisterSet::macroScratchRegisters());
1628     patchpoint-&gt;resultConstraints = { ValueRep::SomeRegister, ValueRep::stackArgument(0) };
1629     patchpoint-&gt;setGenerator([&amp;] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
1630         AllowMacroScratchRegisterUsage allowScratch(jit);
1631         jit.move(CCallHelpers::TrustedImm32(first), params[0].gpr());
1632         jit.store64(CCallHelpers::TrustedImm64(bitwise_cast&lt;uint64_t&gt;(second)), CCallHelpers::Address(CCallHelpers::framePointerRegister, params[1].offsetFromFP()));
1633     });
1634     root-&gt;appendNew&lt;VariableValue&gt;(proc, Set, Origin(), var, patchpoint);
1635     root-&gt;appendNewControlValue(proc, Branch, Origin(), test, FrequentedBlock(truthy), FrequentedBlock(falsey));
1636 
1637     auto addDup = [&amp;] (BasicBlock* block) {
1638         Value* tuple = block-&gt;appendNew&lt;VariableValue&gt;(proc, B3::Get, Origin(), var);
1639         Value* i32 = block-&gt;appendNew&lt;Value&gt;(proc, ZExt32, Origin(),
1640             block-&gt;appendNew&lt;ExtractValue&gt;(proc, Origin(), Int32, tuple, 0));
1641         i32 = block-&gt;appendNew&lt;Value&gt;(proc, IToD, Origin(), i32);
1642         Value* f64 = block-&gt;appendNew&lt;ExtractValue&gt;(proc, Origin(), Double, tuple, 1);
1643         block-&gt;appendNew&lt;Value&gt;(proc, Return, Origin(), block-&gt;appendNew&lt;Value&gt;(proc, Add, Origin(), i32, f64));
1644     };
1645 
1646     addDup(truthy);
1647     addDup(falsey);
1648 
1649     proc.resetReachability();
1650     if (shouldFixSSA)
1651         fixSSA(proc);
1652     CHECK_EQ(compileAndRun&lt;double&gt;(proc, first), first + second);
1653 }
1654 
1655 template&lt;bool shouldFixSSA&gt;
1656 static void tuplePairVariableLoop(unsigned first, uint64_t second)
1657 {
1658     Procedure proc;
1659     BasicBlock* root = proc.addBlock();
1660     BasicBlock* body = proc.addBlock();
1661     BasicBlock* exit = proc.addBlock();
1662 
1663     Type tupleType = proc.addTuple({ Int32, Int64 });
1664     Variable* var = proc.addVariable(tupleType);
1665 
1666     {
1667         Value* first = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0);
1668         Value* second = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1);
1669         PatchpointValue* patchpoint = root-&gt;appendNew&lt;PatchpointValue&gt;(proc, tupleType, Origin());
1670         patchpoint-&gt;append({ first, ValueRep::SomeRegister });
1671         patchpoint-&gt;append({ second, ValueRep::SomeRegister });
1672         patchpoint-&gt;resultConstraints = { ValueRep::SomeEarlyRegister, ValueRep::SomeEarlyRegister };
1673         patchpoint-&gt;setGenerator([&amp;] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
1674             jit.move(params[2].gpr(), params[0].gpr());
1675             jit.move(params[3].gpr(), params[1].gpr());
1676         });
1677         root-&gt;appendNew&lt;VariableValue&gt;(proc, Set, Origin(), var, patchpoint);
1678         root-&gt;appendNewControlValue(proc, Jump, Origin(), body);
1679     }
1680 
1681     {
1682         Value* tuple = body-&gt;appendNew&lt;VariableValue&gt;(proc, B3::Get, Origin(), var);
1683         Value* first = body-&gt;appendNew&lt;ExtractValue&gt;(proc, Origin(), Int32, tuple, 0);
1684         Value* second = body-&gt;appendNew&lt;ExtractValue&gt;(proc, Origin(), Int64, tuple, 1);
1685         PatchpointValue* patchpoint = body-&gt;appendNew&lt;PatchpointValue&gt;(proc, tupleType, Origin());
1686         patchpoint-&gt;clobber(RegisterSet::macroScratchRegisters());
1687         patchpoint-&gt;append({ first, ValueRep::SomeRegister });
1688         patchpoint-&gt;append({ second, ValueRep::SomeRegister });
1689         patchpoint-&gt;resultConstraints = { ValueRep::SomeEarlyRegister, ValueRep::stackArgument(0) };
1690         patchpoint-&gt;setGenerator([&amp;] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
1691             AllowMacroScratchRegisterUsage allowScratch(jit);
1692             CHECK(params[3].gpr() != params[0].gpr());
1693             CHECK(params[2].gpr() != params[0].gpr());
1694             jit.add64(CCallHelpers::TrustedImm32(1), params[3].gpr(), params[0].gpr());
1695             jit.store64(params[0].gpr(), CCallHelpers::Address(CCallHelpers::framePointerRegister, params[1].offsetFromFP()));
1696 
1697             jit.move(params[2].gpr(), params[0].gpr());
1698             jit.urshift32(CCallHelpers::TrustedImm32(1), params[0].gpr());
1699         });
1700         body-&gt;appendNew&lt;VariableValue&gt;(proc, Set, Origin(), var, patchpoint);
1701         Value* condition = body-&gt;appendNew&lt;ExtractValue&gt;(proc, Origin(), Int32, patchpoint, 0);
1702         body-&gt;appendNewControlValue(proc, Branch, Origin(), condition, FrequentedBlock(body), FrequentedBlock(exit));
1703     }
1704 
1705     {
1706         Value* tuple = exit-&gt;appendNew&lt;VariableValue&gt;(proc, B3::Get, Origin(), var);
1707         Value* second = exit-&gt;appendNew&lt;ExtractValue&gt;(proc, Origin(), Int64, tuple, 1);
1708         exit-&gt;appendNew&lt;Value&gt;(proc, Return, Origin(), second);
1709     }
1710 
1711     proc.resetReachability();
1712     validate(proc);
1713     if (shouldFixSSA)
1714         fixSSA(proc);
1715     CHECK_EQ(compileAndRun&lt;uint64_t&gt;(proc, first, second), second + (first ? getMSBSet(first) : first) + 1);
1716 }
1717 
1718 template&lt;bool shouldFixSSA&gt;
1719 static void tupleNestedLoop(int32_t first, double second)
1720 {
1721     Procedure proc;
1722     BasicBlock* root = proc.addBlock();
1723     BasicBlock* outerLoop = proc.addBlock();
1724     BasicBlock* innerLoop = proc.addBlock();
1725     BasicBlock* outerContinuation = proc.addBlock();
1726 
1727     Type tupleType = proc.addTuple({ Int32, Double, Int32 });
1728     Variable* varOuter = proc.addVariable(tupleType);
1729     Variable* varInner = proc.addVariable(tupleType);
1730     Variable* tookInner = proc.addVariable(Int32);
1731 
1732     {
1733         Value* first = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0);
1734         Value* second = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), FPRInfo::argumentFPR0);
1735         PatchpointValue* patchpoint = root-&gt;appendNew&lt;PatchpointValue&gt;(proc, tupleType, Origin());
1736         patchpoint-&gt;append({ first, ValueRep::SomeRegisterWithClobber });
1737         patchpoint-&gt;append({ second, ValueRep::SomeRegisterWithClobber });
1738         patchpoint-&gt;resultConstraints = { ValueRep::SomeRegister, ValueRep::SomeRegister, ValueRep::SomeEarlyRegister };
1739         patchpoint-&gt;setGenerator([&amp;] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
1740             jit.move(params[3].gpr(), params[0].gpr());
1741             jit.move(params[0].gpr(), params[2].gpr());
1742             jit.move(params[4].fpr(), params[1].fpr());
1743         });
1744         root-&gt;appendNew&lt;VariableValue&gt;(proc, Set, Origin(), varOuter, patchpoint);
1745         root-&gt;appendNew&lt;VariableValue&gt;(proc, Set, Origin(), tookInner, root-&gt;appendIntConstant(proc, Origin(), Int32, 0));
1746         root-&gt;appendNewControlValue(proc, Jump, Origin(), outerLoop);
1747     }
1748 
1749     {
1750         Value* tuple = outerLoop-&gt;appendNew&lt;VariableValue&gt;(proc, B3::Get, Origin(), varOuter);
1751         Value* first = outerLoop-&gt;appendNew&lt;ExtractValue&gt;(proc, Origin(), Int32, tuple, 0);
1752         Value* second = outerLoop-&gt;appendNew&lt;ExtractValue&gt;(proc, Origin(), Double, tuple, 1);
1753         Value* third = outerLoop-&gt;appendNew&lt;VariableValue&gt;(proc, B3::Get, Origin(), tookInner);
1754         PatchpointValue* patchpoint = outerLoop-&gt;appendNew&lt;PatchpointValue&gt;(proc, tupleType, Origin());
1755         patchpoint-&gt;clobber(RegisterSet::macroScratchRegisters());
1756         patchpoint-&gt;append({ first, ValueRep::SomeRegisterWithClobber });
1757         patchpoint-&gt;append({ second, ValueRep::SomeRegisterWithClobber });
1758         patchpoint-&gt;append({ third, ValueRep::SomeRegisterWithClobber });
1759         patchpoint-&gt;resultConstraints = { ValueRep::SomeRegister, ValueRep::SomeRegister, ValueRep::SomeRegister };
1760         patchpoint-&gt;setGenerator([&amp;] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
1761             AllowMacroScratchRegisterUsage allowScratch(jit);
1762             jit.move(params[3].gpr(), params[0].gpr());
1763             jit.moveConditionally32(CCallHelpers::Equal, params[5].gpr(), CCallHelpers::TrustedImm32(0), params[0].gpr(), params[5].gpr(), params[2].gpr());
1764             jit.move(params[4].fpr(), params[1].fpr());
1765         });
1766         outerLoop-&gt;appendNew&lt;VariableValue&gt;(proc, Set, Origin(), varOuter, patchpoint);
1767         outerLoop-&gt;appendNew&lt;VariableValue&gt;(proc, Set, Origin(), varInner, patchpoint);
1768         Value* condition = outerLoop-&gt;appendNew&lt;ExtractValue&gt;(proc, Origin(), Int32, patchpoint, 2);
1769         outerLoop-&gt;appendNewControlValue(proc, Branch, Origin(), condition, FrequentedBlock(outerContinuation), FrequentedBlock(innerLoop));
1770     }
1771 
1772     {
1773         Value* tuple = innerLoop-&gt;appendNew&lt;VariableValue&gt;(proc, B3::Get, Origin(), varInner);
1774         Value* first = innerLoop-&gt;appendNew&lt;ExtractValue&gt;(proc, Origin(), Int32, tuple, 0);
1775         Value* second = innerLoop-&gt;appendNew&lt;ExtractValue&gt;(proc, Origin(), Double, tuple, 1);
1776         PatchpointValue* patchpoint = innerLoop-&gt;appendNew&lt;PatchpointValue&gt;(proc, tupleType, Origin());
1777         patchpoint-&gt;clobber(RegisterSet::macroScratchRegisters());
1778         patchpoint-&gt;append({ first, ValueRep::SomeRegisterWithClobber });
1779         patchpoint-&gt;append({ second, ValueRep::SomeRegisterWithClobber });
1780         patchpoint-&gt;resultConstraints = { ValueRep::SomeRegister, ValueRep::SomeRegister, ValueRep::SomeEarlyRegister };
1781         patchpoint-&gt;setGenerator([&amp;] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
1782             AllowMacroScratchRegisterUsage allowScratch(jit);
1783             jit.move(params[3].gpr(), params[0].gpr());
1784             jit.move(CCallHelpers::TrustedImm32(0), params[2].gpr());
1785             jit.move(params[4].fpr(), params[1].fpr());
1786         });
1787         innerLoop-&gt;appendNew&lt;VariableValue&gt;(proc, Set, Origin(), varOuter, patchpoint);
1788         innerLoop-&gt;appendNew&lt;VariableValue&gt;(proc, Set, Origin(), varInner, patchpoint);
1789         Value* condition = innerLoop-&gt;appendNew&lt;ExtractValue&gt;(proc, Origin(), Int32, patchpoint, 2);
1790         innerLoop-&gt;appendNew&lt;VariableValue&gt;(proc, Set, Origin(), tookInner, innerLoop-&gt;appendIntConstant(proc, Origin(), Int32, 1));
1791         innerLoop-&gt;appendNewControlValue(proc, Branch, Origin(), condition, FrequentedBlock(innerLoop), FrequentedBlock(outerLoop));
1792     }
1793 
1794     {
1795         Value* tuple = outerContinuation-&gt;appendNew&lt;VariableValue&gt;(proc, B3::Get, Origin(), varInner);
1796         Value* first = outerContinuation-&gt;appendNew&lt;ExtractValue&gt;(proc, Origin(), Int32, tuple, 0);
1797         Value* second = outerContinuation-&gt;appendNew&lt;ExtractValue&gt;(proc, Origin(), Double, tuple, 1);
1798         Value* result = outerContinuation-&gt;appendNew&lt;Value&gt;(proc, Add, Origin(), second, outerContinuation-&gt;appendNew&lt;Value&gt;(proc, IToD, Origin(), first));
1799         outerContinuation-&gt;appendNewControlValue(proc, Return, Origin(), result);
1800     }
1801 
1802     proc.resetReachability();
1803     validate(proc);
1804     if (shouldFixSSA)
1805         fixSSA(proc);
1806     CHECK_EQ(compileAndRun&lt;double&gt;(proc, first, second), first + second);
1807 }
1808 
1809 void addTupleTests(const char* filter, Deque&lt;RefPtr&lt;SharedTask&lt;void()&gt;&gt;&gt;&amp; tasks)
1810 {
1811     RUN_BINARY(testSimpleTuplePair, int32Operands(), int64Operands());
1812     RUN_BINARY(testSimpleTuplePairUnused, int32Operands(), int64Operands());
1813     RUN_BINARY(testSimpleTuplePairStack, int32Operands(), int64Operands());
1814     // use int64 as second argument because checking for NaN is annoying and doesn&#39;t really matter for this test.
1815     RUN_BINARY(tailDupedTuplePair&lt;true&gt;, int32Operands(), int64Operands());
1816     RUN_BINARY(tailDupedTuplePair&lt;false&gt;, int32Operands(), int64Operands());
1817     RUN_BINARY(tuplePairVariableLoop&lt;true&gt;, int32Operands(), int64Operands());
1818     RUN_BINARY(tuplePairVariableLoop&lt;false&gt;, int32Operands(), int64Operands());
1819     RUN_BINARY(tupleNestedLoop&lt;true&gt;, int32Operands(), int64Operands());
1820     RUN_BINARY(tupleNestedLoop&lt;false&gt;, int32Operands(), int64Operands());
1821 }
1822 
1823 #endif // ENABLE(B3_JIT)
    </pre>
  </body>
</html>