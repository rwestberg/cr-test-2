<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderListBox.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2006-2018 Apple Inc. All rights reserved.
  3  *               2009 Torch Mobile Inc. All rights reserved. (http://www.torchmobile.com/)
  4  *
  5  * Redistribution and use in source and binary forms, with or without
  6  * modification, are permitted provided that the following conditions
  7  * are met:
  8  *
  9  * 1.  Redistributions of source code must retain the above copyright
 10  *     notice, this list of conditions and the following disclaimer.
 11  * 2.  Redistributions in binary form must reproduce the above copyright
 12  *     notice, this list of conditions and the following disclaimer in the
 13  *     documentation and/or other materials provided with the distribution.
 14  * 3.  Neither the name of Apple Inc. (&quot;Apple&quot;) nor the names of
 15  *     its contributors may be used to endorse or promote products derived
 16  *     from this software without specific prior written permission.
 17  *
 18  * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS &quot;AS IS&quot; AND ANY
 19  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 20  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 21  * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
 22  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 23  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 24  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 25  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 26  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 27  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 28  */
 29 
 30 #include &quot;config.h&quot;
 31 #include &quot;RenderListBox.h&quot;
 32 
 33 #include &quot;AXObjectCache.h&quot;
 34 #include &quot;CSSFontSelector.h&quot;
 35 #include &quot;DeprecatedGlobalSettings.h&quot;
 36 #include &quot;Document.h&quot;
 37 #include &quot;DocumentEventQueue.h&quot;
 38 #include &quot;EventHandler.h&quot;
 39 #include &quot;FocusController.h&quot;
 40 #include &quot;Frame.h&quot;
 41 #include &quot;FrameSelection.h&quot;
 42 #include &quot;FrameView.h&quot;
 43 #include &quot;GraphicsContext.h&quot;
 44 #include &quot;HTMLNames.h&quot;
 45 #include &quot;HTMLOptionElement.h&quot;
 46 #include &quot;HTMLOptGroupElement.h&quot;
 47 #include &quot;HTMLSelectElement.h&quot;
 48 #include &quot;HitTestResult.h&quot;
 49 #include &quot;NodeRenderStyle.h&quot;
 50 #include &quot;Page.h&quot;
 51 #include &quot;PaintInfo.h&quot;
 52 #include &quot;RenderLayer.h&quot;
 53 #include &quot;RenderLayoutState.h&quot;
 54 #include &quot;RenderScrollbar.h&quot;
 55 #include &quot;RenderText.h&quot;
 56 #include &quot;RenderTheme.h&quot;
 57 #include &quot;RenderView.h&quot;
 58 #include &quot;ScrollAnimator.h&quot;
 59 #include &quot;Scrollbar.h&quot;
 60 #include &quot;ScrollbarTheme.h&quot;
 61 #include &quot;Settings.h&quot;
 62 #include &quot;SpatialNavigation.h&quot;
 63 #include &quot;StyleResolver.h&quot;
 64 #include &quot;StyleTreeResolver.h&quot;
 65 #include &quot;WheelEventTestTrigger.h&quot;
 66 #include &lt;math.h&gt;
 67 #include &lt;wtf/IsoMallocInlines.h&gt;
 68 #include &lt;wtf/StackStats.h&gt;
 69 
 70 namespace WebCore {
 71 
 72 using namespace HTMLNames;
 73 
 74 WTF_MAKE_ISO_ALLOCATED_IMPL(RenderListBox);
 75 
 76 const int rowSpacing = 1;
 77 
 78 const int optionsSpacingHorizontal = 2;
 79 
 80 // The minSize constant was originally defined to render scrollbars correctly.
 81 // This might vary for different platforms.
 82 const int minSize = 4;
 83 
 84 // Default size when the multiple attribute is present but size attribute is absent.
 85 const int defaultSize = 4;
 86 
 87 // FIXME: This hardcoded baselineAdjustment is what we used to do for the old
 88 // widget, but I&#39;m not sure this is right for the new control.
 89 const int baselineAdjustment = 7;
 90 
 91 RenderListBox::RenderListBox(HTMLSelectElement&amp; element, RenderStyle&amp;&amp; style)
 92     : RenderBlockFlow(element, WTFMove(style))
 93     , m_optionsChanged(true)
 94     , m_scrollToRevealSelectionAfterLayout(false)
 95     , m_inAutoscroll(false)
 96     , m_optionsWidth(0)
 97     , m_indexOffset(0)
 98 {
 99     view().frameView().addScrollableArea(this);
100 }
101 
102 RenderListBox::~RenderListBox()
103 {
104     // Do not add any code here. Add it to willBeDestroyed() instead.
105 }
106 
107 void RenderListBox::willBeDestroyed()
108 {
109     setHasVerticalScrollbar(false);
110     view().frameView().removeScrollableArea(this);
111     RenderBlockFlow::willBeDestroyed();
112 }
113 
114 HTMLSelectElement&amp; RenderListBox::selectElement() const
115 {
116     return downcast&lt;HTMLSelectElement&gt;(nodeForNonAnonymous());
117 }
118 
119 static FontCascade bolder(Document&amp; document, const FontCascade&amp; font)
120 {
121     auto description = font.fontDescription();
122     description.setWeight(description.bolderWeight());
123     auto result = FontCascade { WTFMove(description), font.letterSpacing(), font.wordSpacing() };
124     result.update(&amp;document.fontSelector());
125     return result;
126 }
127 
128 void RenderListBox::updateFromElement()
129 {
130     if (m_optionsChanged) {
131         float width = 0;
132         auto&amp; normalFont = style().fontCascade();
133         Optional&lt;FontCascade&gt; boldFont;
134         for (auto* element : selectElement().listItems()) {
135             String text;
136             WTF::Function&lt;const FontCascade&amp;()&gt; selectFont = [&amp;normalFont] () -&gt; const FontCascade&amp; {
137                 return normalFont;
138             };
139             if (is&lt;HTMLOptionElement&gt;(*element))
140                 text = downcast&lt;HTMLOptionElement&gt;(*element).textIndentedToRespectGroupLabel();
141             else if (is&lt;HTMLOptGroupElement&gt;(*element)) {
142                 text = downcast&lt;HTMLOptGroupElement&gt;(*element).groupLabelText();
143                 selectFont = [this, &amp;normalFont, &amp;boldFont] () -&gt; const FontCascade&amp; {
144                     if (!boldFont)
145                         boldFont = bolder(document(), normalFont);
146                     return boldFont.value();
147                 };
148             }
149             if (text.isEmpty())
150                 continue;
151             text = applyTextTransform(style(), text, &#39; &#39;);
152             auto textRun = constructTextRun(text, style(), AllowTrailingExpansion);
153             width = std::max(width, selectFont().width(textRun));
154         }
155         // FIXME: Is ceiling right here, or should we be doing some kind of rounding instead?
156         m_optionsWidth = static_cast&lt;int&gt;(std::ceil(width));
157         m_optionsChanged = false;
158 
159         setHasVerticalScrollbar(true);
160 
161         computeFirstIndexesVisibleInPaddingTopBottomAreas();
162 
163         setNeedsLayoutAndPrefWidthsRecalc();
164     }
165 }
166 
167 void RenderListBox::selectionChanged()
168 {
169     repaint();
170     if (!m_inAutoscroll) {
171         if (m_optionsChanged || needsLayout())
172             m_scrollToRevealSelectionAfterLayout = true;
173         else
174             scrollToRevealSelection();
175     }
176 
177     if (AXObjectCache* cache = document().existingAXObjectCache())
178         cache-&gt;deferSelectedChildrenChangedIfNeeded(selectElement());
179 }
180 
181 void RenderListBox::layout()
182 {
183     StackStats::LayoutCheckPoint layoutCheckPoint;
184     RenderBlockFlow::layout();
185 
186     if (m_vBar) {
187         bool enabled = numVisibleItems() &lt; numItems();
188         m_vBar-&gt;setEnabled(enabled);
189         m_vBar-&gt;setSteps(1, std::max(1, numVisibleItems() - 1), itemHeight());
190         m_vBar-&gt;setProportion(numVisibleItems(), numItems());
191         if (!enabled) {
192             scrollToOffsetWithoutAnimation(VerticalScrollbar, 0);
193             m_indexOffset = 0;
194         }
195     }
196 
197     if (m_scrollToRevealSelectionAfterLayout) {
198         LayoutStateDisabler layoutStateDisabler(view().frameView().layoutContext());
199         scrollToRevealSelection();
200     }
201 }
202 
203 void RenderListBox::scrollToRevealSelection()
204 {
205     m_scrollToRevealSelectionAfterLayout = false;
206 
207     int firstIndex = selectElement().activeSelectionStartListIndex();
208     if (firstIndex &gt;= 0 &amp;&amp; !listIndexIsVisible(selectElement().activeSelectionEndListIndex()))
209         scrollToRevealElementAtListIndex(firstIndex);
210 }
211 
212 void RenderListBox::computeIntrinsicLogicalWidths(LayoutUnit&amp; minLogicalWidth, LayoutUnit&amp; maxLogicalWidth) const
213 {
214     maxLogicalWidth = m_optionsWidth + 2 * optionsSpacingHorizontal;
215     if (m_vBar)
216         maxLogicalWidth += m_vBar-&gt;width();
217     if (!style().width().isPercentOrCalculated())
218         minLogicalWidth = maxLogicalWidth;
219 }
220 
221 void RenderListBox::computePreferredLogicalWidths()
222 {
223     // Nested style recal do not fire post recal callbacks. see webkit.org/b/153767
224     ASSERT(!m_optionsChanged || Style::postResolutionCallbacksAreSuspended());
225 
226     m_minPreferredLogicalWidth = 0;
227     m_maxPreferredLogicalWidth = 0;
228 
229     if (style().width().isFixed() &amp;&amp; style().width().value() &gt; 0)
230         m_minPreferredLogicalWidth = m_maxPreferredLogicalWidth = adjustContentBoxLogicalWidthForBoxSizing(style().width().value());
231     else
232         computeIntrinsicLogicalWidths(m_minPreferredLogicalWidth, m_maxPreferredLogicalWidth);
233 
234     if (style().minWidth().isFixed() &amp;&amp; style().minWidth().value() &gt; 0) {
235         m_maxPreferredLogicalWidth = std::max(m_maxPreferredLogicalWidth, adjustContentBoxLogicalWidthForBoxSizing(style().minWidth().value()));
236         m_minPreferredLogicalWidth = std::max(m_minPreferredLogicalWidth, adjustContentBoxLogicalWidthForBoxSizing(style().minWidth().value()));
237     }
238 
239     if (style().maxWidth().isFixed()) {
240         m_maxPreferredLogicalWidth = std::min(m_maxPreferredLogicalWidth, adjustContentBoxLogicalWidthForBoxSizing(style().maxWidth().value()));
241         m_minPreferredLogicalWidth = std::min(m_minPreferredLogicalWidth, adjustContentBoxLogicalWidthForBoxSizing(style().maxWidth().value()));
242     }
243 
244     LayoutUnit toAdd = horizontalBorderAndPaddingExtent();
245     m_minPreferredLogicalWidth += toAdd;
246     m_maxPreferredLogicalWidth += toAdd;
247 
248     setPreferredLogicalWidthsDirty(false);
249 }
250 
251 int RenderListBox::size() const
252 {
253     int specifiedSize = selectElement().size();
254     if (specifiedSize &gt; 1)
255         return std::max(minSize, specifiedSize);
256 
257     return defaultSize;
258 }
259 
260 int RenderListBox::numVisibleItems(ConsiderPadding considerPadding) const
261 {
262     // Only count fully visible rows. But don&#39;t return 0 even if only part of a row shows.
263     int visibleItemsExcludingPadding = std::max&lt;int&gt;(1, (contentHeight() + rowSpacing) / itemHeight());
264     if (considerPadding == ConsiderPadding::No)
265         return visibleItemsExcludingPadding;
266 
267     return numberOfVisibleItemsInPaddingTop() + visibleItemsExcludingPadding + numberOfVisibleItemsInPaddingBottom();
268 }
269 
270 int RenderListBox::numItems() const
271 {
272     return selectElement().listItems().size();
273 }
274 
275 LayoutUnit RenderListBox::listHeight() const
276 {
277     return itemHeight() * numItems() - rowSpacing;
278 }
279 
280 RenderBox::LogicalExtentComputedValues RenderListBox::computeLogicalHeight(LayoutUnit, LayoutUnit logicalTop) const
281 {
282     LayoutUnit height = itemHeight() * size() - rowSpacing;
283     cacheIntrinsicContentLogicalHeightForFlexItem(height);
284     height += verticalBorderAndPaddingExtent();
285     return RenderBox::computeLogicalHeight(height, logicalTop);
286 }
287 
288 int RenderListBox::baselinePosition(FontBaseline baselineType, bool firstLine, LineDirectionMode lineDirection, LinePositionMode linePositionMode) const
289 {
290     return RenderBox::baselinePosition(baselineType, firstLine, lineDirection, linePositionMode) - baselineAdjustment;
291 }
292 
293 LayoutRect RenderListBox::itemBoundingBoxRect(const LayoutPoint&amp; additionalOffset, int index)
294 {
295     LayoutUnit x = additionalOffset.x() + borderLeft() + paddingLeft();
296     if (shouldPlaceBlockDirectionScrollbarOnLeft() &amp;&amp; m_vBar)
297         x += m_vBar-&gt;occupiedWidth();
298     LayoutUnit y = additionalOffset.y() + borderTop() + paddingTop() + itemHeight() * (index - m_indexOffset);
299     return LayoutRect(x, y, contentWidth(), itemHeight());
300 }
301 
302 void RenderListBox::paintItem(PaintInfo&amp; paintInfo, const LayoutPoint&amp; paintOffset, const PaintFunction&amp; paintFunction)
303 {
304     int listItemsSize = numItems();
305     int firstVisibleItem = m_indexOfFirstVisibleItemInsidePaddingTopArea.valueOr(m_indexOffset);
306     int endIndex = firstVisibleItem + numVisibleItems(ConsiderPadding::Yes);
307     for (int i = firstVisibleItem; i &lt; listItemsSize &amp;&amp; i &lt; endIndex; ++i)
308         paintFunction(paintInfo, paintOffset, i);
309 }
310 
311 void RenderListBox::paintObject(PaintInfo&amp; paintInfo, const LayoutPoint&amp; paintOffset)
312 {
313     if (style().visibility() != Visibility::Visible)
314         return;
315 
316     if (paintInfo.phase == PaintPhase::Foreground) {
317         paintItem(paintInfo, paintOffset, [this](PaintInfo&amp; paintInfo, const LayoutPoint&amp; paintOffset, int listItemIndex) {
318             paintItemForeground(paintInfo, paintOffset, listItemIndex);
319         });
320     }
321 
322     // Paint the children.
323     RenderBlockFlow::paintObject(paintInfo, paintOffset);
324 
325     switch (paintInfo.phase) {
326     // Depending on whether we have overlay scrollbars they
327     // get rendered in the foreground or background phases
328     case PaintPhase::Foreground:
329         if (m_vBar-&gt;isOverlayScrollbar())
330             paintScrollbar(paintInfo, paintOffset);
331         break;
332     case PaintPhase::BlockBackground:
333         if (!m_vBar-&gt;isOverlayScrollbar())
334             paintScrollbar(paintInfo, paintOffset);
335         break;
336     case PaintPhase::ChildBlockBackground:
337     case PaintPhase::ChildBlockBackgrounds: {
338         paintItem(paintInfo, paintOffset, [this](PaintInfo&amp; paintInfo, const LayoutPoint&amp; paintOffset, int listItemIndex) {
339             paintItemBackground(paintInfo, paintOffset, listItemIndex);
340         });
341         break;
342     }
343     default:
344         break;
345     }
346 }
347 
348 void RenderListBox::addFocusRingRects(Vector&lt;LayoutRect&gt;&amp; rects, const LayoutPoint&amp; additionalOffset, const RenderLayerModelObject* paintContainer)
349 {
350     if (!selectElement().allowsNonContiguousSelection())
351         return RenderBlockFlow::addFocusRingRects(rects, additionalOffset, paintContainer);
352 
353     // Focus the last selected item.
354     int selectedItem = selectElement().activeSelectionEndListIndex();
355     if (selectedItem &gt;= 0) {
356         rects.append(snappedIntRect(itemBoundingBoxRect(additionalOffset, selectedItem)));
357         return;
358     }
359 
360     // No selected items, find the first non-disabled item.
361     int size = numItems();
362     const Vector&lt;HTMLElement*&gt;&amp; listItems = selectElement().listItems();
363     for (int i = 0; i &lt; size; ++i) {
364         HTMLElement* element = listItems[i];
365         if (is&lt;HTMLOptionElement&gt;(*element) &amp;&amp; !element-&gt;isDisabledFormControl()) {
366             selectElement().setActiveSelectionEndIndex(i);
367             rects.append(itemBoundingBoxRect(additionalOffset, i));
368             return;
369         }
370     }
371 }
372 
373 void RenderListBox::paintScrollbar(PaintInfo&amp; paintInfo, const LayoutPoint&amp; paintOffset)
374 {
375     if (!m_vBar)
376         return;
377 
378     LayoutUnit left = paintOffset.x() + (shouldPlaceBlockDirectionScrollbarOnLeft() ? borderLeft() : width() - borderRight() - m_vBar-&gt;width());
379     LayoutUnit top = paintOffset.y() + borderTop();
380     LayoutUnit width = m_vBar-&gt;width();
381     LayoutUnit height = this-&gt;height() - (borderTop() + borderBottom());
382     IntRect scrollRect = snappedIntRect(left, top, width, height);
383     m_vBar-&gt;setFrameRect(scrollRect);
384     m_vBar-&gt;paint(paintInfo.context(), snappedIntRect(paintInfo.rect));
385 }
386 
387 static LayoutSize itemOffsetForAlignment(TextRun textRun, const RenderStyle* itemStyle, FontCascade itemFont, LayoutRect itemBoudingBox)
388 {
389     TextAlignMode actualAlignment = itemStyle-&gt;textAlign();
390     // FIXME: Firefox doesn&#39;t respect TextAlignMode::Justify. Should we?
391     // FIXME: Handle TextAlignMode::End here
392     if (actualAlignment == TextAlignMode::Start || actualAlignment == TextAlignMode::Justify)
393         actualAlignment = itemStyle-&gt;isLeftToRightDirection() ? TextAlignMode::Left : TextAlignMode::Right;
394 
395     LayoutSize offset = LayoutSize(0, itemFont.fontMetrics().ascent());
396     if (actualAlignment == TextAlignMode::Right || actualAlignment == TextAlignMode::WebKitRight) {
397         float textWidth = itemFont.width(textRun);
398         offset.setWidth(itemBoudingBox.width() - textWidth - optionsSpacingHorizontal);
399     } else if (actualAlignment == TextAlignMode::Center || actualAlignment == TextAlignMode::WebKitCenter) {
400         float textWidth = itemFont.width(textRun);
401         offset.setWidth((itemBoudingBox.width() - textWidth) / 2);
402     } else
403         offset.setWidth(optionsSpacingHorizontal);
404     return offset;
405 }
406 
407 void RenderListBox::paintItemForeground(PaintInfo&amp; paintInfo, const LayoutPoint&amp; paintOffset, int listIndex)
408 {
409     const Vector&lt;HTMLElement*&gt;&amp; listItems = selectElement().listItems();
410     HTMLElement* listItemElement = listItems[listIndex];
411 
412     auto&amp; itemStyle = *listItemElement-&gt;computedStyle();
413 
414     if (itemStyle.visibility() == Visibility::Hidden)
415         return;
416 
417     String itemText;
418     bool isOptionElement = is&lt;HTMLOptionElement&gt;(*listItemElement);
419     if (isOptionElement)
420         itemText = downcast&lt;HTMLOptionElement&gt;(*listItemElement).textIndentedToRespectGroupLabel();
421     else if (is&lt;HTMLOptGroupElement&gt;(*listItemElement))
422         itemText = downcast&lt;HTMLOptGroupElement&gt;(*listItemElement).groupLabelText();
423     itemText = applyTextTransform(style(), itemText, &#39; &#39;);
424 
425     if (itemText.isNull())
426         return;
427 
428     Color textColor = itemStyle.visitedDependentColorWithColorFilter(CSSPropertyColor);
429     if (isOptionElement &amp;&amp; downcast&lt;HTMLOptionElement&gt;(*listItemElement).selected()) {
430         if (frame().selection().isFocusedAndActive() &amp;&amp; document().focusedElement() == &amp;selectElement())
431             textColor = theme().activeListBoxSelectionForegroundColor(styleColorOptions());
432         // Honor the foreground color for disabled items
433         else if (!listItemElement-&gt;isDisabledFormControl() &amp;&amp; !selectElement().isDisabledFormControl())
434             textColor = theme().inactiveListBoxSelectionForegroundColor(styleColorOptions());
435     }
436 
437     paintInfo.context().setFillColor(textColor);
438 
439     TextRun textRun(itemText, 0, 0, AllowTrailingExpansion, itemStyle.direction(), isOverride(itemStyle.unicodeBidi()), true);
440     FontCascade itemFont = style().fontCascade();
441     LayoutRect r = itemBoundingBoxRect(paintOffset, listIndex);
442     r.move(itemOffsetForAlignment(textRun, &amp;itemStyle, itemFont, r));
443 
444     if (is&lt;HTMLOptGroupElement&gt;(*listItemElement)) {
445         auto description = itemFont.fontDescription();
446         description.setWeight(description.bolderWeight());
447         itemFont = FontCascade(WTFMove(description), itemFont.letterSpacing(), itemFont.wordSpacing());
448         itemFont.update(&amp;document().fontSelector());
449     }
450 
451     // Draw the item text
452     paintInfo.context().drawBidiText(itemFont, textRun, roundedIntPoint(r.location()));
453 }
454 
455 void RenderListBox::paintItemBackground(PaintInfo&amp; paintInfo, const LayoutPoint&amp; paintOffset, int listIndex)
456 {
457     const Vector&lt;HTMLElement*&gt;&amp; listItems = selectElement().listItems();
458     HTMLElement* listItemElement = listItems[listIndex];
459     auto&amp; itemStyle = *listItemElement-&gt;computedStyle();
460 
461     Color backColor;
462     if (is&lt;HTMLOptionElement&gt;(*listItemElement) &amp;&amp; downcast&lt;HTMLOptionElement&gt;(*listItemElement).selected()) {
463         if (frame().selection().isFocusedAndActive() &amp;&amp; document().focusedElement() == &amp;selectElement())
464             backColor = theme().activeListBoxSelectionBackgroundColor(styleColorOptions());
465         else
466             backColor = theme().inactiveListBoxSelectionBackgroundColor(styleColorOptions());
467     } else
468         backColor = itemStyle.visitedDependentColorWithColorFilter(CSSPropertyBackgroundColor);
469 
470     // Draw the background for this list box item
471     if (itemStyle.visibility() == Visibility::Hidden)
472         return;
473 
474     LayoutRect itemRect = itemBoundingBoxRect(paintOffset, listIndex);
475     itemRect.intersect(controlClipRect(paintOffset));
476     paintInfo.context().fillRect(snappedIntRect(itemRect), backColor);
477 }
478 
479 bool RenderListBox::isPointInOverflowControl(HitTestResult&amp; result, const LayoutPoint&amp; locationInContainer, const LayoutPoint&amp; accumulatedOffset)
480 {
481     if (!m_vBar || !m_vBar-&gt;shouldParticipateInHitTesting())
482         return false;
483 
484     LayoutUnit x = accumulatedOffset.x() + (shouldPlaceBlockDirectionScrollbarOnLeft() ? borderLeft() : width() - borderRight() - m_vBar-&gt;width());
485     LayoutUnit y = accumulatedOffset.y() + borderTop();
486     LayoutUnit width = m_vBar-&gt;width();
487     LayoutUnit height = this-&gt;height() - borderTop() - borderBottom();
488     LayoutRect vertRect(x, y, width, height);
489 
490     if (!vertRect.contains(locationInContainer))
491         return false;
492 
493     result.setScrollbar(m_vBar.get());
494     return true;
495 }
496 
497 int RenderListBox::listIndexAtOffset(const LayoutSize&amp; offset)
498 {
499     if (!numItems())
500         return -1;
501 
502     if (offset.height() &lt; borderTop() || offset.height() &gt; height() - borderBottom())
503         return -1;
504 
505     int scrollbarWidth = m_vBar ? m_vBar-&gt;width() : 0;
506     if (shouldPlaceBlockDirectionScrollbarOnLeft() &amp;&amp; (offset.width() &lt; borderLeft() + paddingLeft() + scrollbarWidth || offset.width() &gt; width() - borderRight() - paddingRight()))
507         return -1;
508     if (!shouldPlaceBlockDirectionScrollbarOnLeft() &amp;&amp; (offset.width() &lt; borderLeft() + paddingLeft() || offset.width() &gt; width() - borderRight() - paddingRight() - scrollbarWidth))
509         return -1;
510 
511     int newOffset = (offset.height() - borderTop() - paddingTop()) / itemHeight() + m_indexOffset;
512     return newOffset &lt; numItems() ? newOffset : -1;
513 }
514 
515 void RenderListBox::panScroll(const IntPoint&amp; panStartMousePosition)
516 {
517     const int maxSpeed = 20;
518     const int iconRadius = 7;
519     const int speedReducer = 4;
520 
521     // FIXME: This doesn&#39;t work correctly with transforms.
522     FloatPoint absOffset = localToAbsolute();
523 
524     IntPoint lastKnownMousePosition = frame().eventHandler().lastKnownMousePosition();
525     // We need to check if the last known mouse position is out of the window. When the mouse is out of the window, the position is incoherent
526     static IntPoint previousMousePosition;
527     if (lastKnownMousePosition.y() &lt; 0)
528         lastKnownMousePosition = previousMousePosition;
529     else
530         previousMousePosition = lastKnownMousePosition;
531 
532     int yDelta = lastKnownMousePosition.y() - panStartMousePosition.y();
533 
534     // If the point is too far from the center we limit the speed
535     yDelta = std::max&lt;int&gt;(std::min&lt;int&gt;(yDelta, maxSpeed), -maxSpeed);
536 
537     if (abs(yDelta) &lt; iconRadius) // at the center we let the space for the icon
538         return;
539 
540     if (yDelta &gt; 0)
541         //offsetY = view()-&gt;viewHeight();
542         absOffset.move(0, listHeight());
543     else if (yDelta &lt; 0)
544         yDelta--;
545 
546     // Let&#39;s attenuate the speed
547     yDelta /= speedReducer;
548 
549     IntPoint scrollPoint(0, 0);
550     scrollPoint.setY(absOffset.y() + yDelta);
551     int newOffset = scrollToward(scrollPoint);
552     if (newOffset &lt; 0)
553         return;
554 
555     m_inAutoscroll = true;
556     selectElement().updateListBoxSelection(!selectElement().multiple());
557     m_inAutoscroll = false;
558 }
559 
560 int RenderListBox::scrollToward(const IntPoint&amp; destination)
561 {
562     // FIXME: This doesn&#39;t work correctly with transforms.
563     FloatPoint absPos = localToAbsolute();
564     IntSize positionOffset = roundedIntSize(destination - absPos);
565 
566     int rows = numVisibleItems();
567     int offset = m_indexOffset;
568 
569     if (positionOffset.height() &lt; borderTop() + paddingTop() &amp;&amp; scrollToRevealElementAtListIndex(offset - 1))
570         return offset - 1;
571 
572     if (positionOffset.height() &gt; height() - paddingBottom() - borderBottom() &amp;&amp; scrollToRevealElementAtListIndex(offset + rows))
573         return offset + rows - 1;
574 
575     return listIndexAtOffset(positionOffset);
576 }
577 
578 void RenderListBox::autoscroll(const IntPoint&amp;)
579 {
580     IntPoint pos = frame().view()-&gt;windowToContents(frame().eventHandler().lastKnownMousePosition());
581 
582     int endIndex = scrollToward(pos);
583     if (selectElement().isDisabledFormControl())
584         return;
585 
586     if (endIndex &gt;= 0) {
587         m_inAutoscroll = true;
588 
589         if (!selectElement().multiple())
590             selectElement().setActiveSelectionAnchorIndex(endIndex);
591 
592         selectElement().setActiveSelectionEndIndex(endIndex);
593         selectElement().updateListBoxSelection(!selectElement().multiple());
594         m_inAutoscroll = false;
595     }
596 }
597 
598 void RenderListBox::stopAutoscroll()
599 {
600     if (selectElement().isDisabledFormControl())
601         return;
602 
603     selectElement().listBoxOnChange();
604 }
605 
606 bool RenderListBox::scrollToRevealElementAtListIndex(int index)
607 {
608     if (index &lt; 0 || index &gt;= numItems() || listIndexIsVisible(index))
609         return false;
610 
611     int newOffset;
612     if (index &lt; m_indexOffset)
613         newOffset = index;
614     else
615         newOffset = index - numVisibleItems() + 1;
616 
617     scrollToOffsetWithoutAnimation(VerticalScrollbar, newOffset);
618 
619     return true;
620 }
621 
622 bool RenderListBox::listIndexIsVisible(int index)
623 {
624     int firstIndex = m_indexOfFirstVisibleItemInsidePaddingTopArea.valueOr(m_indexOffset);
625     int endIndex = m_indexOfFirstVisibleItemInsidePaddingBottomArea
626         ? m_indexOfFirstVisibleItemInsidePaddingBottomArea.value() + numberOfVisibleItemsInPaddingBottom()
627         : m_indexOffset + numVisibleItems();
628 
629     return index &gt;= firstIndex &amp;&amp; index &lt; endIndex;
630 }
631 
632 bool RenderListBox::scroll(ScrollDirection direction, ScrollGranularity granularity, float multiplier, Element**, RenderBox*, const IntPoint&amp;)
633 {
634     return ScrollableArea::scroll(direction, granularity, multiplier);
635 }
636 
637 bool RenderListBox::logicalScroll(ScrollLogicalDirection direction, ScrollGranularity granularity, float multiplier, Element**)
638 {
639     return ScrollableArea::scroll(logicalToPhysical(direction, style().isHorizontalWritingMode(), style().isFlippedBlocksWritingMode()), granularity, multiplier);
640 }
641 
642 void RenderListBox::valueChanged(unsigned listIndex)
643 {
644     selectElement().setSelectedIndex(selectElement().listToOptionIndex(listIndex));
645     selectElement().dispatchFormControlChangeEvent();
646 }
647 
<a name="1" id="anc1"></a><span class="line-modified">648 ScrollPosition RenderListBox::scrollPosition() const</span>
649 {
<a name="2" id="anc2"></a><span class="line-modified">650     return { 0, m_indexOffset };</span>





651 }
652 
653 ScrollPosition RenderListBox::minimumScrollPosition() const
654 {
655     return { 0, 0 };
656 }
657 
658 ScrollPosition RenderListBox::maximumScrollPosition() const
659 {
660     return { 0, numItems() - numVisibleItems() };
661 }
662 
663 void RenderListBox::setScrollOffset(const ScrollOffset&amp; offset)
664 {
665     scrollTo(offset.y());
666 }
667 
668 int RenderListBox::maximumNumberOfItemsThatFitInPaddingBottomArea() const
669 {
670     return paddingBottom() / itemHeight();
671 }
672 
673 int RenderListBox::numberOfVisibleItemsInPaddingTop() const
674 {
675     if (!m_indexOfFirstVisibleItemInsidePaddingTopArea)
676         return 0;
677 
678     return m_indexOffset - m_indexOfFirstVisibleItemInsidePaddingTopArea.value();
679 }
680 
681 int RenderListBox::numberOfVisibleItemsInPaddingBottom() const
682 {
683     if (!m_indexOfFirstVisibleItemInsidePaddingBottomArea)
684         return 0;
685 
686     return std::min(maximumNumberOfItemsThatFitInPaddingBottomArea(), numItems() - m_indexOffset - numVisibleItems());
687 }
688 
689 void RenderListBox::computeFirstIndexesVisibleInPaddingTopBottomAreas()
690 {
691     m_indexOfFirstVisibleItemInsidePaddingTopArea = WTF::nullopt;
692     m_indexOfFirstVisibleItemInsidePaddingBottomArea = WTF::nullopt;
693 
694     int maximumNumberOfItemsThatFitInPaddingTopArea = paddingTop() / itemHeight();
695     if (maximumNumberOfItemsThatFitInPaddingTopArea) {
696         if (m_indexOffset)
697             m_indexOfFirstVisibleItemInsidePaddingTopArea = std::max(0, m_indexOffset - maximumNumberOfItemsThatFitInPaddingTopArea);
698     }
699 
700     if (maximumNumberOfItemsThatFitInPaddingBottomArea()) {
701         if (numItems() &gt; (m_indexOffset + numVisibleItems()))
702             m_indexOfFirstVisibleItemInsidePaddingBottomArea = m_indexOffset + numVisibleItems();
703     }
704 }
705 
706 void RenderListBox::scrollTo(int newOffset)
707 {
708     if (newOffset == m_indexOffset)
709         return;
710 
711     m_indexOffset = newOffset;
712 
713     computeFirstIndexesVisibleInPaddingTopBottomAreas();
714 
715     repaint();
716     document().eventQueue().enqueueOrDispatchScrollEvent(selectElement());
717 }
718 
719 LayoutUnit RenderListBox::itemHeight() const
720 {
721     return style().fontMetrics().height() + rowSpacing;
722 }
723 
724 int RenderListBox::verticalScrollbarWidth() const
725 {
726     return m_vBar ? m_vBar-&gt;occupiedWidth() : 0;
727 }
728 
729 // FIXME: We ignore padding in the vertical direction as far as these values are concerned, since that&#39;s
730 // how the control currently paints.
731 int RenderListBox::scrollWidth() const
732 {
733     // There is no horizontal scrolling allowed.
734     return roundToInt(clientWidth());
735 }
736 
737 int RenderListBox::scrollHeight() const
738 {
739     return roundToInt(std::max(clientHeight(), listHeight()));
740 }
741 
742 int RenderListBox::scrollLeft() const
743 {
744     return 0;
745 }
746 
<a name="3" id="anc3"></a><span class="line-modified">747 void RenderListBox::setScrollLeft(int, ScrollType, ScrollClamping)</span>
748 {
749 }
750 
751 int RenderListBox::scrollTop() const
752 {
753     return m_indexOffset * itemHeight();
754 }
755 
756 static void setupWheelEventTestTrigger(RenderListBox&amp; renderer)
757 {
758     if (!renderer.page().expectsWheelEventTriggers())
759         return;
760 
761     renderer.scrollAnimator().setWheelEventTestTrigger(renderer.page().testTrigger());
762 }
763 
<a name="4" id="anc4"></a><span class="line-modified">764 void RenderListBox::setScrollTop(int newTop, ScrollType, ScrollClamping)</span>
765 {
766     // Determine an index and scroll to it.
767     int index = newTop / itemHeight();
768     if (index &lt; 0 || index &gt;= numItems() || index == m_indexOffset)
769         return;
770     setupWheelEventTestTrigger(*this);
771     scrollToOffsetWithoutAnimation(VerticalScrollbar, index);
772 }
773 
774 bool RenderListBox::nodeAtPoint(const HitTestRequest&amp; request, HitTestResult&amp; result, const HitTestLocation&amp; locationInContainer, const LayoutPoint&amp; accumulatedOffset, HitTestAction hitTestAction)
775 {
776     if (!RenderBlockFlow::nodeAtPoint(request, result, locationInContainer, accumulatedOffset, hitTestAction))
777         return false;
778     const Vector&lt;HTMLElement*&gt;&amp; listItems = selectElement().listItems();
779     int size = numItems();
780     LayoutPoint adjustedLocation = accumulatedOffset + location();
781 
782     for (int i = 0; i &lt; size; ++i) {
783         if (!itemBoundingBoxRect(adjustedLocation, i).contains(locationInContainer.point()))
784             continue;
785         if (Element* node = listItems[i]) {
786             result.setInnerNode(node);
787             if (!result.innerNonSharedNode())
788                 result.setInnerNonSharedNode(node);
789             result.setLocalPoint(locationInContainer.point() - toLayoutSize(adjustedLocation));
790             break;
791         }
792     }
793 
794     return true;
795 }
796 
797 LayoutRect RenderListBox::controlClipRect(const LayoutPoint&amp; additionalOffset) const
798 {
799     // Clip against the padding box, to give &lt;option&gt;s and overlay scrollbar some extra space
800     // to get painted.
801     LayoutRect clipRect = paddingBoxRect();
<a name="5" id="anc5"></a>

802     clipRect.moveBy(additionalOffset);
803     return clipRect;
804 }
805 
806 bool RenderListBox::isActive() const
807 {
808     return page().focusController().isActive();
809 }
810 
811 void RenderListBox::invalidateScrollbarRect(Scrollbar&amp; scrollbar, const IntRect&amp; rect)
812 {
813     IntRect scrollRect = rect;
814     scrollRect.move(shouldPlaceBlockDirectionScrollbarOnLeft() ? borderLeft() : width() - borderRight() - scrollbar.width(), borderTop());
815     repaintRectangle(scrollRect);
816 }
817 
818 IntRect RenderListBox::convertFromScrollbarToContainingView(const Scrollbar&amp; scrollbar, const IntRect&amp; scrollbarRect) const
819 {
820     IntRect rect = scrollbarRect;
821     int scrollbarLeft = shouldPlaceBlockDirectionScrollbarOnLeft() ? borderLeft() : width() - borderRight() - scrollbar.width();
822     int scrollbarTop = borderTop();
823     rect.move(scrollbarLeft, scrollbarTop);
824     return view().frameView().convertFromRendererToContainingView(this, rect);
825 }
826 
827 IntRect RenderListBox::convertFromContainingViewToScrollbar(const Scrollbar&amp; scrollbar, const IntRect&amp; parentRect) const
828 {
829     IntRect rect = view().frameView().convertFromContainingViewToRenderer(this, parentRect);
830     int scrollbarLeft = shouldPlaceBlockDirectionScrollbarOnLeft() ? borderLeft() : width() - borderRight() - scrollbar.width();
831     int scrollbarTop = borderTop();
832     rect.move(-scrollbarLeft, -scrollbarTop);
833     return rect;
834 }
835 
836 IntPoint RenderListBox::convertFromScrollbarToContainingView(const Scrollbar&amp; scrollbar, const IntPoint&amp; scrollbarPoint) const
837 {
838     IntPoint point = scrollbarPoint;
839     int scrollbarLeft = shouldPlaceBlockDirectionScrollbarOnLeft() ? borderLeft() : width() - borderRight() - scrollbar.width();
840     int scrollbarTop = borderTop();
841     point.move(scrollbarLeft, scrollbarTop);
842     return view().frameView().convertFromRendererToContainingView(this, point);
843 }
844 
845 IntPoint RenderListBox::convertFromContainingViewToScrollbar(const Scrollbar&amp; scrollbar, const IntPoint&amp; parentPoint) const
846 {
847     IntPoint point = view().frameView().convertFromContainingViewToRenderer(this, parentPoint);
848     int scrollbarLeft = shouldPlaceBlockDirectionScrollbarOnLeft() ? borderLeft() : width() - borderRight() - scrollbar.width();
849     int scrollbarTop = borderTop();
850     point.move(-scrollbarLeft, -scrollbarTop);
851     return point;
852 }
853 
854 IntSize RenderListBox::contentsSize() const
855 {
856     return IntSize(scrollWidth(), scrollHeight());
857 }
858 
859 IntPoint RenderListBox::lastKnownMousePosition() const
860 {
861     return view().frameView().lastKnownMousePosition();
862 }
863 
864 bool RenderListBox::isHandlingWheelEvent() const
865 {
866     return view().frameView().isHandlingWheelEvent();
867 }
868 
869 bool RenderListBox::shouldSuspendScrollAnimations() const
870 {
871     return view().frameView().shouldSuspendScrollAnimations();
872 }
873 
874 bool RenderListBox::forceUpdateScrollbarsOnMainThreadForPerformanceTesting() const
875 {
876     return settings().forceUpdateScrollbarsOnMainThreadForPerformanceTesting();
877 }
878 
879 ScrollableArea* RenderListBox::enclosingScrollableArea() const
880 {
881     // FIXME: Return a RenderLayer that&#39;s scrollable.
882     return nullptr;
883 }
884 
885 bool RenderListBox::isScrollableOrRubberbandable()
886 {
887     return m_vBar;
888 }
889 
890 bool RenderListBox::hasScrollableOrRubberbandableAncestor()
891 {
892     return enclosingLayer() &amp;&amp; enclosingLayer()-&gt;hasScrollableOrRubberbandableAncestor();
893 }
894 
895 IntRect RenderListBox::scrollableAreaBoundingBox(bool*) const
896 {
897     return absoluteBoundingBoxRect();
898 }
899 
900 bool RenderListBox::usesMockScrollAnimator() const
901 {
902     return DeprecatedGlobalSettings::usesMockScrollAnimator();
903 }
904 
905 void RenderListBox::logMockScrollAnimatorMessage(const String&amp; message) const
906 {
907     document().addConsoleMessage(MessageSource::Other, MessageLevel::Debug, &quot;RenderListBox: &quot; + message);
908 }
909 
910 Ref&lt;Scrollbar&gt; RenderListBox::createScrollbar()
911 {
912     RefPtr&lt;Scrollbar&gt; widget;
913     bool hasCustomScrollbarStyle = style().hasPseudoStyle(PseudoId::Scrollbar);
914     if (hasCustomScrollbarStyle)
915         widget = RenderScrollbar::createCustomScrollbar(*this, VerticalScrollbar, &amp;selectElement());
916     else {
917         widget = Scrollbar::createNativeScrollbar(*this, VerticalScrollbar, theme().scrollbarControlSizeForPart(ListboxPart));
918         didAddScrollbar(widget.get(), VerticalScrollbar);
919         if (page().expectsWheelEventTriggers())
920             scrollAnimator().setWheelEventTestTrigger(page().testTrigger());
921     }
922     view().frameView().addChild(*widget);
923     return widget.releaseNonNull();
924 }
925 
926 void RenderListBox::destroyScrollbar()
927 {
928     if (!m_vBar)
929         return;
930 
931     if (!m_vBar-&gt;isCustomScrollbar())
932         ScrollableArea::willRemoveScrollbar(m_vBar.get(), VerticalScrollbar);
933     m_vBar-&gt;removeFromParent();
934     m_vBar = nullptr;
935 }
936 
937 void RenderListBox::setHasVerticalScrollbar(bool hasScrollbar)
938 {
939     if (hasScrollbar == (m_vBar != nullptr))
940         return;
941 
942     if (hasScrollbar)
943         m_vBar = createScrollbar();
944     else
945         destroyScrollbar();
946 
947     if (m_vBar)
948         m_vBar-&gt;styleChanged();
<a name="6" id="anc6"></a>

949 }
950 
951 bool RenderListBox::scrolledToTop() const
952 {
953     if (Scrollbar* vbar = verticalScrollbar())
954     return vbar-&gt;value() &lt;= 0;
955 
956     return true;
957 }
958 
959 bool RenderListBox::scrolledToBottom() const
960 {
961     Scrollbar* vbar = verticalScrollbar();
962     if (!vbar)
963         return true;
964 
965     return vbar-&gt;value() &gt;= vbar-&gt;maximum();
966 }
967 
968 bool RenderListBox::scrolledToLeft() const
969 {
970     // We do not scroll horizontally in a select element, so always report
971     // that we are at the full extent of the scroll.
972     return true;
973 }
974 
975 bool RenderListBox::scrolledToRight() const
976 {
977     // We do not scroll horizontally in a select element, so always report
978     // that we are at the full extent of the scroll.
979     return true;
980 }
981 
982 } // namespace WebCore
<a name="7" id="anc7"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="7" type="hidden" />
</body>
</html>