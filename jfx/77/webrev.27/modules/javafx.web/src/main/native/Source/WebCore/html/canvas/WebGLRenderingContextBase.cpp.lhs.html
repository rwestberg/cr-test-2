<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/html/canvas/WebGLRenderingContextBase.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (C) 2015-2017 Apple Inc. All rights reserved.
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  * 1. Redistributions of source code must retain the above copyright
   8  *    notice, this list of conditions and the following disclaimer.
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #include &quot;config.h&quot;
  27 #include &quot;WebGLRenderingContextBase.h&quot;
  28 
  29 #if ENABLE(WEBGL)
  30 
  31 #include &quot;ANGLEInstancedArrays.h&quot;
  32 #include &quot;CachedImage.h&quot;
  33 #include &quot;DOMWindow.h&quot;
  34 #include &quot;DiagnosticLoggingClient.h&quot;
  35 #include &quot;DiagnosticLoggingKeys.h&quot;
  36 #include &quot;Document.h&quot;
  37 #include &quot;EXTBlendMinMax.h&quot;
  38 #include &quot;EXTFragDepth.h&quot;
  39 #include &quot;EXTShaderTextureLOD.h&quot;
  40 #include &quot;EXTTextureFilterAnisotropic.h&quot;
  41 #include &quot;EXTsRGB.h&quot;
  42 #include &quot;EventNames.h&quot;
  43 #include &quot;Extensions3D.h&quot;
  44 #include &quot;Frame.h&quot;
  45 #include &quot;FrameLoader.h&quot;
  46 #include &quot;FrameLoaderClient.h&quot;
  47 #include &quot;FrameView.h&quot;
  48 #include &quot;GraphicsContext.h&quot;
  49 #include &quot;HTMLCanvasElement.h&quot;
  50 #include &quot;HTMLImageElement.h&quot;
  51 #include &quot;HTMLVideoElement.h&quot;
  52 #include &quot;ImageBuffer.h&quot;
  53 #include &quot;ImageData.h&quot;
  54 #include &quot;InspectorInstrumentation.h&quot;
  55 #include &quot;IntSize.h&quot;
  56 #include &quot;JSExecState.h&quot;
  57 #include &quot;Logging.h&quot;
  58 #include &quot;NotImplemented.h&quot;
  59 #include &quot;OESElementIndexUint.h&quot;
  60 #include &quot;OESStandardDerivatives.h&quot;
  61 #include &quot;OESTextureFloat.h&quot;
  62 #include &quot;OESTextureFloatLinear.h&quot;
  63 #include &quot;OESTextureHalfFloat.h&quot;
  64 #include &quot;OESTextureHalfFloatLinear.h&quot;
  65 #include &quot;OESVertexArrayObject.h&quot;
  66 #include &quot;OffscreenCanvas.h&quot;
  67 #include &quot;Page.h&quot;
  68 #include &quot;RenderBox.h&quot;
  69 #include &quot;RuntimeEnabledFeatures.h&quot;
  70 #include &quot;Settings.h&quot;
  71 #include &quot;WebGL2RenderingContext.h&quot;
  72 #include &quot;WebGLActiveInfo.h&quot;
  73 #include &quot;WebGLBuffer.h&quot;
  74 #include &quot;WebGLCompressedTextureASTC.h&quot;
  75 #include &quot;WebGLCompressedTextureATC.h&quot;
  76 #include &quot;WebGLCompressedTexturePVRTC.h&quot;
  77 #include &quot;WebGLCompressedTextureS3TC.h&quot;
  78 #include &quot;WebGLContextAttributes.h&quot;
  79 #include &quot;WebGLContextEvent.h&quot;
  80 #include &quot;WebGLContextGroup.h&quot;
  81 #include &quot;WebGLDebugRendererInfo.h&quot;
  82 #include &quot;WebGLDebugShaders.h&quot;
  83 #include &quot;WebGLDepthTexture.h&quot;
  84 #include &quot;WebGLDrawBuffers.h&quot;
  85 #include &quot;WebGLFramebuffer.h&quot;
  86 #include &quot;WebGLLoseContext.h&quot;
  87 #include &quot;WebGLProgram.h&quot;
  88 #include &quot;WebGLRenderbuffer.h&quot;
  89 #include &quot;WebGLRenderingContext.h&quot;
  90 #include &quot;WebGLShader.h&quot;
  91 #include &quot;WebGLShaderPrecisionFormat.h&quot;
  92 #include &quot;WebGLTexture.h&quot;
  93 #include &quot;WebGLUniformLocation.h&quot;
  94 #include &lt;JavaScriptCore/ConsoleMessage.h&gt;
  95 #include &lt;JavaScriptCore/JSCInlines.h&gt;
  96 #include &lt;JavaScriptCore/ScriptCallStack.h&gt;
  97 #include &lt;JavaScriptCore/ScriptCallStackFactory.h&gt;
  98 #include &lt;JavaScriptCore/TypedArrayInlines.h&gt;
  99 #include &lt;JavaScriptCore/Uint32Array.h&gt;
 100 #include &lt;wtf/CheckedArithmetic.h&gt;
<a name="1" id="anc1"></a>
 101 #include &lt;wtf/HexNumber.h&gt;
<a name="2" id="anc2"></a>

 102 #include &lt;wtf/StdLibExtras.h&gt;
 103 #include &lt;wtf/UniqueArray.h&gt;
 104 #include &lt;wtf/text/CString.h&gt;
 105 #include &lt;wtf/text/StringBuilder.h&gt;
 106 
 107 namespace WebCore {
 108 
<a name="3" id="anc3"></a>

 109 static const Seconds secondsBetweenRestoreAttempts { 1_s };
 110 const int maxGLErrorsAllowedToConsole = 256;
 111 static const Seconds checkContextLossHandlingDelay { 3_s };
 112 
 113 namespace {
 114 
<a name="4" id="anc4"></a><span class="line-removed"> 115     Platform3DObject objectOrZero(WebGLObject* object)</span>
<span class="line-removed"> 116     {</span>
<span class="line-removed"> 117         return object ? object-&gt;object() : 0;</span>
<span class="line-removed"> 118     }</span>
<span class="line-removed"> 119 </span>
 120     GC3Dint clamp(GC3Dint value, GC3Dint min, GC3Dint max)
 121     {
 122         if (value &lt; min)
 123             value = min;
 124         if (value &gt; max)
 125             value = max;
 126         return value;
 127     }
 128 
 129     // Return true if a character belongs to the ASCII subset as defined in
 130     // GLSL ES 1.0 spec section 3.1.
 131     bool validateCharacter(unsigned char c)
 132     {
 133         // Printing characters are valid except &quot; $ ` @ \ &#39; DEL.
 134         if (c &gt;= 32 &amp;&amp; c &lt;= 126
 135             &amp;&amp; c != &#39;&quot;&#39; &amp;&amp; c != &#39;$&#39; &amp;&amp; c != &#39;`&#39; &amp;&amp; c != &#39;@&#39; &amp;&amp; c != &#39;\\&#39; &amp;&amp; c != &#39;\&#39;&#39;)
 136             return true;
 137         // Horizontal tab, line feed, vertical tab, form feed, carriage return
 138         // are also valid.
 139         if (c &gt;= 9 &amp;&amp; c &lt;= 13)
 140             return true;
 141         return false;
 142     }
 143 
 144     bool isPrefixReserved(const String&amp; name)
 145     {
 146         if (name.startsWith(&quot;gl_&quot;) || name.startsWith(&quot;webgl_&quot;) || name.startsWith(&quot;_webgl_&quot;))
 147             return true;
 148         return false;
 149     }
 150 
 151     // Strips comments from shader text. This allows non-ASCII characters
 152     // to be used in comments without potentially breaking OpenGL
 153     // implementations not expecting characters outside the GLSL ES set.
 154     class StripComments {
 155     public:
 156         StripComments(const String&amp; str)
 157             : m_parseState(BeginningOfLine)
 158             , m_sourceString(str)
 159             , m_length(str.length())
 160             , m_position(0)
 161         {
 162             parse();
 163         }
 164 
 165         String result()
 166         {
 167             return m_builder.toString();
 168         }
 169 
 170     private:
 171         bool hasMoreCharacters() const
 172         {
 173             return (m_position &lt; m_length);
 174         }
 175 
 176         void parse()
 177         {
 178             while (hasMoreCharacters()) {
 179                 process(current());
 180                 // process() might advance the position.
 181                 if (hasMoreCharacters())
 182                     advance();
 183             }
 184         }
 185 
 186         void process(UChar);
 187 
 188         bool peek(UChar&amp; character) const
 189         {
 190             if (m_position + 1 &gt;= m_length)
 191                 return false;
 192             character = m_sourceString[m_position + 1];
 193             return true;
 194         }
 195 
 196         UChar current() const
 197         {
 198             ASSERT_WITH_SECURITY_IMPLICATION(m_position &lt; m_length);
 199             return m_sourceString[m_position];
 200         }
 201 
 202         void advance()
 203         {
 204             ++m_position;
 205         }
 206 
 207         bool isNewline(UChar character) const
 208         {
 209             // Don&#39;t attempt to canonicalize newline related characters.
 210             return (character == &#39;\n&#39; || character == &#39;\r&#39;);
 211         }
 212 
 213         void emit(UChar character)
 214         {
 215             m_builder.append(character);
 216         }
 217 
 218         enum ParseState {
 219             // Have not seen an ASCII non-whitespace character yet on
 220             // this line. Possible that we might see a preprocessor
 221             // directive.
 222             BeginningOfLine,
 223 
 224             // Have seen at least one ASCII non-whitespace character
 225             // on this line.
 226             MiddleOfLine,
 227 
 228             // Handling a preprocessor directive. Passes through all
 229             // characters up to the end of the line. Disables comment
 230             // processing.
 231             InPreprocessorDirective,
 232 
 233             // Handling a single-line comment. The comment text is
 234             // replaced with a single space.
 235             InSingleLineComment,
 236 
 237             // Handling a multi-line comment. Newlines are passed
 238             // through to preserve line numbers.
 239             InMultiLineComment
 240         };
 241 
 242         ParseState m_parseState;
 243         String m_sourceString;
 244         unsigned m_length;
 245         unsigned m_position;
 246         StringBuilder m_builder;
 247     };
 248 
 249     void StripComments::process(UChar c)
 250     {
 251         if (isNewline(c)) {
 252             // No matter what state we are in, pass through newlines
 253             // so we preserve line numbers.
 254             emit(c);
 255 
 256             if (m_parseState != InMultiLineComment)
 257                 m_parseState = BeginningOfLine;
 258 
 259             return;
 260         }
 261 
 262         UChar temp = 0;
 263         switch (m_parseState) {
 264         case BeginningOfLine:
 265             if (WTF::isASCIISpace(c)) {
 266                 emit(c);
 267                 break;
 268             }
 269 
 270             if (c == &#39;#&#39;) {
 271                 m_parseState = InPreprocessorDirective;
 272                 emit(c);
 273                 break;
 274             }
 275 
 276             // Transition to normal state and re-handle character.
 277             m_parseState = MiddleOfLine;
 278             process(c);
 279             break;
 280 
 281         case MiddleOfLine:
 282             if (c == &#39;/&#39; &amp;&amp; peek(temp)) {
 283                 if (temp == &#39;/&#39;) {
 284                     m_parseState = InSingleLineComment;
 285                     emit(&#39; &#39;);
 286                     advance();
 287                     break;
 288                 }
 289 
 290                 if (temp == &#39;*&#39;) {
 291                     m_parseState = InMultiLineComment;
 292                     // Emit the comment start in case the user has
 293                     // an unclosed comment and we want to later
 294                     // signal an error.
 295                     emit(&#39;/&#39;);
 296                     emit(&#39;*&#39;);
 297                     advance();
 298                     break;
 299                 }
 300             }
 301 
 302             emit(c);
 303             break;
 304 
 305         case InPreprocessorDirective:
 306             // No matter what the character is, just pass it
 307             // through. Do not parse comments in this state. This
 308             // might not be the right thing to do long term, but it
 309             // should handle the #error preprocessor directive.
 310             emit(c);
 311             break;
 312 
 313         case InSingleLineComment:
 314             // The newline code at the top of this function takes care
 315             // of resetting our state when we get out of the
 316             // single-line comment. Swallow all other characters.
 317             break;
 318 
 319         case InMultiLineComment:
 320             if (c == &#39;*&#39; &amp;&amp; peek(temp) &amp;&amp; temp == &#39;/&#39;) {
 321                 emit(&#39;*&#39;);
 322                 emit(&#39;/&#39;);
 323                 m_parseState = MiddleOfLine;
 324                 advance();
 325                 break;
 326             }
 327 
 328             // Swallow all other characters. Unclear whether we may
 329             // want or need to just emit a space per character to try
 330             // to preserve column numbers for debugging purposes.
 331             break;
 332         }
 333     }
 334 } // namespace anonymous
 335 
 336 // Returns false if no clipping is necessary, i.e., x, y, width, height stay the same.
 337 static bool clip2D(GC3Dint x, GC3Dint y, GC3Dsizei width, GC3Dsizei height,
 338     GC3Dsizei sourceWidth, GC3Dsizei sourceHeight,
 339     GC3Dint* clippedX, GC3Dint* clippedY, GC3Dsizei* clippedWidth, GC3Dsizei*clippedHeight)
 340 {
 341     ASSERT(clippedX &amp;&amp; clippedY &amp;&amp; clippedWidth &amp;&amp; clippedHeight);
 342 
 343     GC3Dint left = std::max(x, 0);
 344     GC3Dint top = std::max(y, 0);
 345     GC3Dint right = 0;
 346     GC3Dint bottom = 0;
 347 
 348     Checked&lt;GC3Dint, RecordOverflow&gt; checkedInputRight = Checked&lt;GC3Dint&gt;(x) + Checked&lt;GC3Dsizei&gt;(width);
 349     Checked&lt;GC3Dint, RecordOverflow&gt; checkedInputBottom = Checked&lt;GC3Dint&gt;(y) + Checked&lt;GC3Dsizei&gt;(height);
 350     if (!checkedInputRight.hasOverflowed() &amp;&amp; !checkedInputBottom.hasOverflowed()) {
 351         right = std::min(checkedInputRight.unsafeGet(), sourceWidth);
 352         bottom = std::min(checkedInputBottom.unsafeGet(), sourceHeight);
 353     }
 354 
 355     if (left &gt;= right || top &gt;= bottom) {
 356         *clippedX = 0;
 357         *clippedY = 0;
 358         *clippedWidth = 0;
 359         *clippedHeight = 0;
 360         return true;
 361     }
 362 
 363     *clippedX = left;
 364     *clippedY = top;
 365     *clippedWidth = right - left;
 366     *clippedHeight = bottom - top;
 367 
 368     return (*clippedX != x || *clippedY != y || *clippedWidth != width || *clippedHeight != height);
 369 }
 370 
 371 class WebGLRenderingContextLostCallback : public GraphicsContext3D::ContextLostCallback {
 372     WTF_MAKE_FAST_ALLOCATED;
 373 public:
 374     explicit WebGLRenderingContextLostCallback(WebGLRenderingContextBase* cb) : m_context(cb) { }
 375     virtual ~WebGLRenderingContextLostCallback() = default;
 376 
 377     void onContextLost() override { m_context-&gt;forceLostContext(WebGLRenderingContext::RealLostContext); }
 378 private:
 379     WebGLRenderingContextBase* m_context;
 380 };
 381 
 382 class WebGLRenderingContextErrorMessageCallback : public GraphicsContext3D::ErrorMessageCallback {
 383     WTF_MAKE_FAST_ALLOCATED;
 384 public:
 385     explicit WebGLRenderingContextErrorMessageCallback(WebGLRenderingContextBase* cb) : m_context(cb) { }
 386     virtual ~WebGLRenderingContextErrorMessageCallback() = default;
 387 
 388     void onErrorMessage(const String&amp; message, GC3Dint) override
 389     {
 390         if (m_context-&gt;m_synthesizedErrorsToConsole)
 391             m_context-&gt;printToConsole(MessageLevel::Error, message);
 392     }
 393 private:
 394     WebGLRenderingContextBase* m_context;
 395 };
 396 
 397 class InspectorScopedShaderProgramHighlight {
 398 public:
 399     InspectorScopedShaderProgramHighlight(WebGLRenderingContextBase&amp; context, WebGLProgram* program)
 400         : m_context(context)
 401         , m_program(program)
 402     {
 403         showHightlight();
 404     }
 405 
 406     ~InspectorScopedShaderProgramHighlight()
 407     {
 408         hideHighlight();
 409     }
 410 
 411 private:
 412     void showHightlight()
 413     {
 414         if (!m_program || LIKELY(!InspectorInstrumentation::isShaderProgramHighlighted(m_context, *m_program)))
 415             return;
 416 
 417         if (hasBufferBinding(GraphicsContext3D::FRAMEBUFFER_BINDING)) {
 418             if (!hasBufferBinding(GraphicsContext3D::RENDERBUFFER_BINDING))
 419                 return;
 420             if (hasFramebufferParameterAttachment(GraphicsContext3D::DEPTH_ATTACHMENT))
 421                 return;
 422             if (hasFramebufferParameterAttachment(GraphicsContext3D::STENCIL_ATTACHMENT))
 423                 return;
 424 #if ENABLE(WEBGL2)
 425             if (hasFramebufferParameterAttachment(GraphicsContext3D::DEPTH_STENCIL_ATTACHMENT))
 426                 return;
 427 #endif
 428         }
 429 
 430         saveBlendValue(GraphicsContext3D::BLEND_COLOR, m_savedBlend.color);
 431         saveBlendValue(GraphicsContext3D::BLEND_EQUATION_RGB, m_savedBlend.equationRGB);
 432         saveBlendValue(GraphicsContext3D::BLEND_EQUATION_ALPHA, m_savedBlend.equationAlpha);
 433         saveBlendValue(GraphicsContext3D::BLEND_SRC_RGB, m_savedBlend.srcRGB);
 434         saveBlendValue(GraphicsContext3D::BLEND_SRC_ALPHA, m_savedBlend.srcAlpha);
 435         saveBlendValue(GraphicsContext3D::BLEND_DST_RGB, m_savedBlend.dstRGB);
 436         saveBlendValue(GraphicsContext3D::BLEND_DST_ALPHA, m_savedBlend.dstAlpha);
 437         saveBlendValue(GraphicsContext3D::BLEND, m_savedBlend.enabled);
 438 
 439         static const GC3Dfloat red = 111.0 / 255.0;
 440         static const GC3Dfloat green = 168.0 / 255.0;
 441         static const GC3Dfloat blue = 220.0 / 255.0;
 442         static const GC3Dfloat alpha = 2.0 / 3.0;
 443 
 444         m_context.enable(GraphicsContext3D::BLEND);
 445         m_context.blendColor(red, green, blue, alpha);
 446         m_context.blendEquation(GraphicsContext3D::FUNC_ADD);
 447         m_context.blendFunc(GraphicsContext3D::CONSTANT_COLOR, GraphicsContext3D::ONE_MINUS_SRC_ALPHA);
 448 
 449         m_didApply = true;
 450     }
 451 
 452     void hideHighlight()
 453     {
 454         if (!m_didApply)
 455             return;
 456 
 457         if (!m_savedBlend.enabled)
 458             m_context.disable(GraphicsContext3D::BLEND);
 459 
 460         const RefPtr&lt;Float32Array&gt;&amp; color = m_savedBlend.color;
 461         m_context.blendColor(color-&gt;item(0), color-&gt;item(1), color-&gt;item(2), color-&gt;item(3));
 462         m_context.blendEquationSeparate(m_savedBlend.equationRGB, m_savedBlend.equationAlpha);
 463         m_context.blendFuncSeparate(m_savedBlend.srcRGB, m_savedBlend.dstRGB, m_savedBlend.srcAlpha, m_savedBlend.dstAlpha);
 464 
 465         m_savedBlend.color = nullptr;
 466 
 467         m_didApply = false;
 468     }
 469 
 470     template &lt;typename T&gt;
 471     void saveBlendValue(GC3Denum attachment, T&amp; destination)
 472     {
 473         WebGLAny param = m_context.getParameter(attachment);
 474         if (WTF::holds_alternative&lt;T&gt;(param))
 475             destination = WTF::get&lt;T&gt;(param);
 476     }
 477 
 478     bool hasBufferBinding(GC3Denum pname)
 479     {
 480         WebGLAny binding = m_context.getParameter(pname);
 481         if (pname == GraphicsContext3D::FRAMEBUFFER_BINDING)
 482             return WTF::holds_alternative&lt;RefPtr&lt;WebGLFramebuffer&gt;&gt;(binding) &amp;&amp; WTF::get&lt;RefPtr&lt;WebGLFramebuffer&gt;&gt;(binding);
 483         if (pname == GraphicsContext3D::RENDERBUFFER_BINDING)
 484             return WTF::holds_alternative&lt;RefPtr&lt;WebGLRenderbuffer&gt;&gt;(binding) &amp;&amp; WTF::get&lt;RefPtr&lt;WebGLRenderbuffer&gt;&gt;(binding);
 485         return false;
 486     }
 487 
 488     bool hasFramebufferParameterAttachment(GC3Denum attachment)
 489     {
 490         WebGLAny attachmentParameter = m_context.getFramebufferAttachmentParameter(GraphicsContext3D::FRAMEBUFFER, attachment, GraphicsContext3D::FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE);
 491         if (!WTF::holds_alternative&lt;unsigned&gt;(attachmentParameter))
 492             return false;
 493         if (WTF::get&lt;unsigned&gt;(attachmentParameter) != static_cast&lt;unsigned&gt;(GraphicsContext3D::RENDERBUFFER))
 494             return false;
 495         return true;
 496     }
 497 
 498     struct {
 499         RefPtr&lt;Float32Array&gt; color;
 500         unsigned equationRGB { 0 };
 501         unsigned equationAlpha { 0 };
 502         unsigned srcRGB { 0 };
 503         unsigned srcAlpha { 0 };
 504         unsigned dstRGB { 0 };
 505         unsigned dstAlpha { 0 };
 506         bool enabled { false };
 507     } m_savedBlend;
 508 
 509     WebGLRenderingContextBase&amp; m_context;
 510     WebGLProgram* m_program { nullptr };
 511     bool m_didApply { false };
 512 };
 513 
 514 static bool isHighPerformanceContext(const RefPtr&lt;GraphicsContext3D&gt;&amp; context)
 515 {
 516     return context-&gt;powerPreferenceUsedForCreation() == WebGLPowerPreference::HighPerformance;
 517 }
 518 
 519 std::unique_ptr&lt;WebGLRenderingContextBase&gt; WebGLRenderingContextBase::create(CanvasBase&amp; canvas, WebGLContextAttributes&amp; attributes, const String&amp; type)
 520 {
 521 #if ENABLE(WEBGL2)
 522     if (type == &quot;webgl2&quot; &amp;&amp; !RuntimeEnabledFeatures::sharedFeatures().webGL2Enabled())
 523         return nullptr;
 524 #else
 525     UNUSED_PARAM(type);
 526 #endif
 527 
 528     bool isPendingPolicyResolution = false;
 529     HostWindow* hostWindow = nullptr;
 530 
 531     auto* canvasElement = is&lt;HTMLCanvasElement&gt;(canvas) ? &amp;downcast&lt;HTMLCanvasElement&gt;(canvas) : nullptr;
 532 
 533     if (canvasElement) {
 534         Document&amp; document = canvasElement-&gt;document();
 535         RefPtr&lt;Frame&gt; frame = document.frame();
 536         if (!frame)
 537             return nullptr;
 538 
 539         // The FrameLoaderClient might block creation of a new WebGL context despite the page settings; in
 540         // particular, if WebGL contexts were lost one or more times via the GL_ARB_robustness extension.
 541         if (!frame-&gt;loader().client().allowWebGL(frame-&gt;settings().webGLEnabled())) {
 542             canvasElement-&gt;dispatchEvent(WebGLContextEvent::create(eventNames().webglcontextcreationerrorEvent,
 543                 Event::CanBubble::No, Event::IsCancelable::Yes, &quot;Web page was not allowed to create a WebGL context.&quot;));
 544             return nullptr;
 545         }
 546 
 547         Document&amp; topDocument = document.topDocument();
 548         Page* page = topDocument.page();
 549         bool forcingPendingPolicy = frame-&gt;settings().isForcePendingWebGLPolicy();
 550 
 551         if (forcingPendingPolicy || (page &amp;&amp; !topDocument.url().isLocalFile())) {
 552             WebGLLoadPolicy policy = forcingPendingPolicy ? WebGLPendingCreation : page-&gt;mainFrame().loader().client().webGLPolicyForURL(topDocument.url());
 553 
 554             if (policy == WebGLBlockCreation) {
 555                 LOG(WebGL, &quot;The policy for this URL (%s) is to block WebGL.&quot;, topDocument.url().host().utf8().data());
 556                 return nullptr;
 557             }
 558 
 559             if (policy == WebGLPendingCreation) {
 560                 LOG(WebGL, &quot;WebGL policy is pending. May need to be resolved later.&quot;);
 561                 isPendingPolicyResolution = true;
 562             }
 563         }
 564 
<a name="5" id="anc5"></a><span class="line-removed"> 565         if (frame-&gt;settings().forceSoftwareWebGLRendering())</span>
<span class="line-removed"> 566             attributes.forceSoftwareRenderer = true;</span>
<span class="line-removed"> 567 </span>
 568         if (frame-&gt;settings().forceWebGLUsesLowPower()) {
 569             if (attributes.powerPreference == GraphicsContext3DPowerPreference::HighPerformance)
 570                 LOG(WebGL, &quot;Overriding powerPreference from high-performance to low-power.&quot;);
 571             attributes.powerPreference = GraphicsContext3DPowerPreference::LowPower;
 572         }
 573 
 574         if (page)
 575             attributes.devicePixelRatio = page-&gt;deviceScaleFactor();
 576 
 577         hostWindow = document.view()-&gt;root()-&gt;hostWindow();
 578     }
 579 
 580     attributes.noExtensions = true;
 581     attributes.shareResources = false;
 582 
 583     attributes.initialPowerPreference = attributes.powerPreference;
 584 
 585 
 586 #if ENABLE(WEBGL2)
 587     if (type == &quot;webgl2&quot;)
 588         attributes.isWebGL2 = true;
 589 #endif
 590 
 591     if (isPendingPolicyResolution) {
 592         LOG(WebGL, &quot;Create a WebGL context that looks real, but will require a policy resolution if used.&quot;);
 593         std::unique_ptr&lt;WebGLRenderingContextBase&gt; renderingContext = nullptr;
 594 #if ENABLE(WEBGL2)
 595         if (type == &quot;webgl2&quot;)
 596             renderingContext = WebGL2RenderingContext::create(canvas, attributes);
 597         else
 598 #endif
 599             renderingContext = WebGLRenderingContext::create(canvas, attributes);
 600         renderingContext-&gt;suspendIfNeeded();
 601         return renderingContext;
 602     }
 603 
 604     auto context = GraphicsContext3D::create(attributes, hostWindow);
 605     if (!context || !context-&gt;makeContextCurrent()) {
 606         if (canvasElement) {
 607             canvasElement-&gt;dispatchEvent(WebGLContextEvent::create(eventNames().webglcontextcreationerrorEvent,
 608                 Event::CanBubble::No, Event::IsCancelable::Yes, &quot;Could not create a WebGL context.&quot;));
 609         }
 610         return nullptr;
 611     }
 612 
 613     auto&amp; extensions = context-&gt;getExtensions();
 614     if (extensions.supports(&quot;GL_EXT_debug_marker&quot;_s))
 615         extensions.pushGroupMarkerEXT(&quot;WebGLRenderingContext&quot;_s);
 616 
 617 #if ENABLE(WEBGL2) &amp;&amp; PLATFORM(MAC)
 618     // glTexStorage() was only added to Core in OpenGL 4.2.
 619     // However, according to https://developer.apple.com/opengl/capabilities/ all Apple GPUs support this extension.
 620     if (attributes.isWebGL2 &amp;&amp; !extensions.supports(&quot;GL_ARB_texture_storage&quot;))
 621         return nullptr;
 622 #endif
 623 
 624     std::unique_ptr&lt;WebGLRenderingContextBase&gt; renderingContext;
 625 #if ENABLE(WEBGL2)
 626     if (type == &quot;webgl2&quot;)
 627         renderingContext = WebGL2RenderingContext::create(canvas, context.releaseNonNull(), attributes);
 628     else
 629 #endif
 630         renderingContext = WebGLRenderingContext::create(canvas, context.releaseNonNull(), attributes);
 631     renderingContext-&gt;suspendIfNeeded();
 632 
 633     return renderingContext;
 634 }
 635 
 636 WebGLRenderingContextBase::WebGLRenderingContextBase(CanvasBase&amp; canvas, WebGLContextAttributes attributes)
 637     : GPUBasedCanvasRenderingContext(canvas)
 638     , m_dispatchContextLostEventTimer(*this, &amp;WebGLRenderingContextBase::dispatchContextLostEvent)
 639     , m_restoreTimer(*this, &amp;WebGLRenderingContextBase::maybeRestoreContext)
 640     , m_attributes(attributes)
 641     , m_numGLErrorsToConsoleAllowed(maxGLErrorsAllowedToConsole)
 642     , m_isPendingPolicyResolution(true)
 643     , m_checkForContextLossHandlingTimer(*this, &amp;WebGLRenderingContextBase::checkForContextLossHandling)
 644 {
 645     registerWithWebGLStateTracker();
 646     m_checkForContextLossHandlingTimer.startOneShot(checkContextLossHandlingDelay);
 647 }
 648 
 649 WebGLRenderingContextBase::WebGLRenderingContextBase(CanvasBase&amp; canvas, Ref&lt;GraphicsContext3D&gt;&amp;&amp; context, WebGLContextAttributes attributes)
 650     : GPUBasedCanvasRenderingContext(canvas)
 651     , m_context(WTFMove(context))
 652     , m_dispatchContextLostEventTimer(*this, &amp;WebGLRenderingContextBase::dispatchContextLostEvent)
 653     , m_restoreTimer(*this, &amp;WebGLRenderingContextBase::maybeRestoreContext)
 654     , m_generatedImageCache(4)
 655     , m_attributes(attributes)
 656     , m_numGLErrorsToConsoleAllowed(maxGLErrorsAllowedToConsole)
 657     , m_checkForContextLossHandlingTimer(*this, &amp;WebGLRenderingContextBase::checkForContextLossHandling)
 658 {
 659     m_contextGroup = WebGLContextGroup::create();
 660     m_contextGroup-&gt;addContext(*this);
 661 
<a name="6" id="anc6"></a><span class="line-modified"> 662     m_context-&gt;setWebGLContext(this);</span>
 663 
 664     m_context-&gt;getIntegerv(GraphicsContext3D::MAX_VIEWPORT_DIMS, m_maxViewportDims);
 665 
 666     setupFlags();
 667     initializeNewContext();
 668     registerWithWebGLStateTracker();
 669     m_checkForContextLossHandlingTimer.startOneShot(checkContextLossHandlingDelay);
 670 
 671     addActivityStateChangeObserverIfNecessary();
 672 }
 673 
 674 WebGLCanvas WebGLRenderingContextBase::canvas()
 675 {
 676     auto&amp; base = canvasBase();
 677     if (is&lt;OffscreenCanvas&gt;(base))
 678         return &amp;downcast&lt;OffscreenCanvas&gt;(base);
 679     return &amp;downcast&lt;HTMLCanvasElement&gt;(base);
 680 }
 681 
<a name="7" id="anc7"></a><span class="line-removed"> 682 HTMLCanvasElement* WebGLRenderingContextBase::htmlCanvas()</span>
<span class="line-removed"> 683 {</span>
<span class="line-removed"> 684     auto&amp; base = canvasBase();</span>
<span class="line-removed"> 685     if (!is&lt;HTMLCanvasElement&gt;(base))</span>
<span class="line-removed"> 686         return nullptr;</span>
<span class="line-removed"> 687     return &amp;downcast&lt;HTMLCanvasElement&gt;(base);</span>
<span class="line-removed"> 688 }</span>
<span class="line-removed"> 689 </span>
 690 OffscreenCanvas* WebGLRenderingContextBase::offscreenCanvas()
 691 {
 692     auto&amp; base = canvasBase();
 693     if (!is&lt;OffscreenCanvas&gt;(base))
 694         return nullptr;
 695     return &amp;downcast&lt;OffscreenCanvas&gt;(base);
 696 }
 697 
 698 // We check for context loss handling after a few seconds to give the JS a chance to register the event listeners
 699 // and to discard temporary GL contexts (e.g. feature detection).
 700 void WebGLRenderingContextBase::checkForContextLossHandling()
 701 {
 702     auto canvas = htmlCanvas();
 703     if (!canvas)
 704         return;
 705 
 706     if (!canvas-&gt;renderer())
 707         return;
 708 
 709     auto* page = canvas-&gt;document().page();
 710     if (!page)
 711         return;
 712 
 713     bool handlesContextLoss = canvas-&gt;hasEventListeners(eventNames().webglcontextlostEvent) &amp;&amp; canvas-&gt;hasEventListeners(eventNames().webglcontextrestoredEvent);
 714     page-&gt;diagnosticLoggingClient().logDiagnosticMessage(DiagnosticLoggingKeys::pageHandlesWebGLContextLossKey(), handlesContextLoss ? DiagnosticLoggingKeys::yesKey() : DiagnosticLoggingKeys::noKey(), ShouldSample::No);
 715 }
 716 
 717 void WebGLRenderingContextBase::registerWithWebGLStateTracker()
 718 {
 719     auto canvas = htmlCanvas();
 720     if (!canvas)
 721         return;
 722 
 723     auto* page = canvas-&gt;document().page();
 724     if (!page)
 725         return;
 726 
 727     auto* tracker = page-&gt;webGLStateTracker();
 728     if (!tracker)
 729         return;
 730 
 731     m_trackerToken = tracker-&gt;token(m_attributes.initialPowerPreference);
 732 }
 733 
 734 void WebGLRenderingContextBase::initializeNewContext()
 735 {
 736     ASSERT(!m_contextLost);
 737     m_needsUpdate = true;
 738     m_markedCanvasDirty = false;
 739     m_activeTextureUnit = 0;
 740     m_packAlignment = 4;
 741     m_unpackAlignment = 4;
 742     m_unpackFlipY = false;
 743     m_unpackPremultiplyAlpha = false;
 744     m_unpackColorspaceConversion = GraphicsContext3D::BROWSER_DEFAULT_WEBGL;
 745     m_boundArrayBuffer = nullptr;
 746     m_currentProgram = nullptr;
 747     m_framebufferBinding = nullptr;
 748     m_readFramebufferBinding = nullptr;
 749     m_renderbufferBinding = nullptr;
 750     m_depthMask = true;
 751     m_stencilEnabled = false;
 752     m_stencilMask = 0xFFFFFFFF;
 753     m_stencilMaskBack = 0xFFFFFFFF;
 754     m_stencilFuncRef = 0;
 755     m_stencilFuncRefBack = 0;
 756     m_stencilFuncMask = 0xFFFFFFFF;
 757     m_stencilFuncMaskBack = 0xFFFFFFFF;
 758     m_layerCleared = false;
 759     m_numGLErrorsToConsoleAllowed = maxGLErrorsAllowedToConsole;
 760 
 761     m_clearColor[0] = m_clearColor[1] = m_clearColor[2] = m_clearColor[3] = 0;
 762     m_scissorEnabled = false;
 763     m_clearDepth = 1;
 764     m_clearStencil = 0;
 765     m_colorMask[0] = m_colorMask[1] = m_colorMask[2] = m_colorMask[3] = true;
 766 
 767     GC3Dint numCombinedTextureImageUnits = 0;
 768     m_context-&gt;getIntegerv(GraphicsContext3D::MAX_COMBINED_TEXTURE_IMAGE_UNITS, &amp;numCombinedTextureImageUnits);
 769     m_textureUnits.clear();
 770     m_textureUnits.resize(numCombinedTextureImageUnits);
 771     for (GC3Dint i = 0; i &lt; numCombinedTextureImageUnits; ++i)
 772         m_unrenderableTextureUnits.add(i);
 773 
 774     GC3Dint numVertexAttribs = 0;
 775     m_context-&gt;getIntegerv(GraphicsContext3D::MAX_VERTEX_ATTRIBS, &amp;numVertexAttribs);
 776     m_maxVertexAttribs = numVertexAttribs;
 777 
 778     m_maxTextureSize = 0;
 779     m_context-&gt;getIntegerv(GraphicsContext3D::MAX_TEXTURE_SIZE, &amp;m_maxTextureSize);
 780     m_maxTextureLevel = WebGLTexture::computeLevelCount(m_maxTextureSize, m_maxTextureSize);
 781     m_maxCubeMapTextureSize = 0;
 782     m_context-&gt;getIntegerv(GraphicsContext3D::MAX_CUBE_MAP_TEXTURE_SIZE, &amp;m_maxCubeMapTextureSize);
 783     m_maxCubeMapTextureLevel = WebGLTexture::computeLevelCount(m_maxCubeMapTextureSize, m_maxCubeMapTextureSize);
 784     m_maxRenderbufferSize = 0;
 785     m_context-&gt;getIntegerv(GraphicsContext3D::MAX_RENDERBUFFER_SIZE, &amp;m_maxRenderbufferSize);
 786 
 787     // These two values from EXT_draw_buffers are lazily queried.
 788     m_maxDrawBuffers = 0;
 789     m_maxColorAttachments = 0;
 790 
 791     m_backDrawBuffer = GraphicsContext3D::BACK;
 792     m_drawBuffersWebGLRequirementsChecked = false;
 793     m_drawBuffersSupported = false;
 794 
 795     m_vertexAttribValue.resize(m_maxVertexAttribs);
 796 
 797     if (!isGLES2NPOTStrict())
 798         createFallbackBlackTextures1x1();
 799 
 800     IntSize canvasSize = clampedCanvasSize();
 801     m_context-&gt;reshape(canvasSize.width(), canvasSize.height());
 802     m_context-&gt;viewport(0, 0, canvasSize.width(), canvasSize.height());
 803     m_context-&gt;scissor(0, 0, canvasSize.width(), canvasSize.height());
 804 
<a name="8" id="anc8"></a><span class="line-modified"> 805     m_context-&gt;setContextLostCallback(std::make_unique&lt;WebGLRenderingContextLostCallback&gt;(this));</span>
<span class="line-modified"> 806     m_context-&gt;setErrorMessageCallback(std::make_unique&lt;WebGLRenderingContextErrorMessageCallback&gt;(this));</span>
 807 }
 808 
 809 void WebGLRenderingContextBase::setupFlags()
 810 {
 811     ASSERT(m_context);
 812 
 813     auto canvas = htmlCanvas();
 814     if (canvas) {
 815         if (Page* page = canvas-&gt;document().page())
 816             m_synthesizedErrorsToConsole = page-&gt;settings().webGLErrorsToConsoleEnabled();
 817     }
 818 
 819     m_isGLES2Compliant = m_context-&gt;isGLES2Compliant();
 820     if (m_isGLES2Compliant) {
 821         m_isGLES2NPOTStrict = !m_context-&gt;getExtensions().isEnabled(&quot;GL_OES_texture_npot&quot;);
 822         m_isDepthStencilSupported = m_context-&gt;getExtensions().isEnabled(&quot;GL_OES_packed_depth_stencil&quot;);
 823     } else {
 824         m_isGLES2NPOTStrict = !m_context-&gt;getExtensions().isEnabled(&quot;GL_ARB_texture_non_power_of_two&quot;);
 825         m_isDepthStencilSupported = m_context-&gt;getExtensions().isEnabled(&quot;GL_EXT_packed_depth_stencil&quot;);
 826     }
 827     m_isRobustnessEXTSupported = m_context-&gt;getExtensions().isEnabled(&quot;GL_EXT_robustness&quot;);
 828 }
 829 
 830 void WebGLRenderingContextBase::addCompressedTextureFormat(GC3Denum format)
 831 {
 832     if (!m_compressedTextureFormats.contains(format))
 833         m_compressedTextureFormats.append(format);
 834 }
 835 
 836 void WebGLRenderingContextBase::addActivityStateChangeObserverIfNecessary()
 837 {
 838     // We are only interested in visibility changes for contexts
 839     // that are using the high-performance GPU.
 840     if (!isHighPerformanceContext(m_context))
 841         return;
 842 
 843     auto* canvas = htmlCanvas();
 844     if (!canvas)
 845         return;
 846 
 847     auto* page = canvas-&gt;document().page();
 848     if (!page)
 849         return;
 850 
 851     page-&gt;addActivityStateChangeObserver(*this);
 852 
 853     // We won&#39;t get a state change right away, so
 854     // make sure the context knows if it visible or not.
 855     if (m_context)
 856         m_context-&gt;setContextVisibility(page-&gt;isVisible());
 857 }
 858 
 859 void WebGLRenderingContextBase::removeActivityStateChangeObserver()
 860 {
 861     auto* canvas = htmlCanvas();
 862     if (canvas) {
 863         if (auto* page = canvas-&gt;document().page())
 864             page-&gt;removeActivityStateChangeObserver(*this);
 865     }
 866 }
 867 
 868 WebGLRenderingContextBase::~WebGLRenderingContextBase()
 869 {
 870     // Remove all references to WebGLObjects so if they are the last reference
 871     // they will be freed before the last context is removed from the context group.
 872     m_boundArrayBuffer = nullptr;
 873     m_defaultVertexArrayObject = nullptr;
 874     m_boundVertexArrayObject = nullptr;
 875     m_vertexAttrib0Buffer = nullptr;
 876     m_currentProgram = nullptr;
 877     m_framebufferBinding = nullptr;
 878     m_readFramebufferBinding = nullptr;
 879     m_renderbufferBinding = nullptr;
 880 
 881     for (auto&amp; textureUnit : m_textureUnits) {
 882         textureUnit.texture2DBinding = nullptr;
 883         textureUnit.textureCubeMapBinding = nullptr;
 884     }
 885 
 886     m_blackTexture2D = nullptr;
 887     m_blackTextureCubeMap = nullptr;
 888 
 889     if (!m_isPendingPolicyResolution) {
 890         detachAndRemoveAllObjects();
 891         destroyGraphicsContext3D();
 892         m_contextGroup-&gt;removeContext(*this);
 893     }
<a name="9" id="anc9"></a>










 894 }
 895 
 896 void WebGLRenderingContextBase::destroyGraphicsContext3D()
 897 {
 898     if (m_isPendingPolicyResolution)
 899         return;
 900 
 901     removeActivityStateChangeObserver();
 902 
 903     if (m_context) {
<a name="10" id="anc10"></a>
 904         m_context-&gt;setContextLostCallback(nullptr);
 905         m_context-&gt;setErrorMessageCallback(nullptr);
 906         m_context = nullptr;
 907     }
 908 }
 909 
 910 void WebGLRenderingContextBase::markContextChanged()
 911 {
 912     if (m_framebufferBinding)
 913         return;
 914 
 915     m_context-&gt;markContextChanged();
 916 
 917     m_layerCleared = false;
 918 
 919     auto* canvas = htmlCanvas();
 920     if (!canvas)
 921         return;
 922 
 923     RenderBox* renderBox = canvas-&gt;renderBox();
 924     if (isAccelerated() &amp;&amp; renderBox &amp;&amp; renderBox-&gt;hasAcceleratedCompositing()) {
 925         m_markedCanvasDirty = true;
 926         htmlCanvas()-&gt;clearCopiedImage();
 927         renderBox-&gt;contentChanged(CanvasPixelsChanged);
 928     } else {
 929         if (!m_markedCanvasDirty) {
 930             m_markedCanvasDirty = true;
 931             canvas-&gt;didDraw(FloatRect(FloatPoint(0, 0), clampedCanvasSize()));
 932         }
 933     }
 934 }
 935 
 936 void WebGLRenderingContextBase::markContextChangedAndNotifyCanvasObserver()
 937 {
 938     markContextChanged();
 939     if (!isAccelerated())
 940         return;
 941 
 942     auto* canvas = htmlCanvas();
 943     if (!canvas)
 944         return;
 945 
 946     RenderBox* renderBox = canvas-&gt;renderBox();
 947     if (renderBox &amp;&amp; renderBox-&gt;hasAcceleratedCompositing())
 948         canvas-&gt;notifyObserversCanvasChanged(FloatRect(FloatPoint(0, 0), clampedCanvasSize()));
 949 }
 950 
 951 bool WebGLRenderingContextBase::clearIfComposited(GC3Dbitfield mask)
 952 {
 953     if (isContextLostOrPending())
 954         return false;
 955 
 956     if (!m_context-&gt;layerComposited() || m_layerCleared
 957         || m_attributes.preserveDrawingBuffer || (mask &amp;&amp; m_framebufferBinding)
 958         || m_preventBufferClearForInspector)
 959         return false;
 960 
 961     auto contextAttributes = getContextAttributes();
 962     ASSERT(contextAttributes);
 963 
 964     // Determine if it&#39;s possible to combine the clear the user asked for and this clear.
 965     bool combinedClear = mask &amp;&amp; !m_scissorEnabled;
 966 
 967     m_context-&gt;disable(GraphicsContext3D::SCISSOR_TEST);
 968     if (combinedClear &amp;&amp; (mask &amp; GraphicsContext3D::COLOR_BUFFER_BIT))
 969         m_context-&gt;clearColor(m_colorMask[0] ? m_clearColor[0] : 0,
 970                               m_colorMask[1] ? m_clearColor[1] : 0,
 971                               m_colorMask[2] ? m_clearColor[2] : 0,
 972                               m_colorMask[3] ? m_clearColor[3] : 0);
 973     else
 974         m_context-&gt;clearColor(0, 0, 0, 0);
 975     m_context-&gt;colorMask(true, true, true, true);
 976     GC3Dbitfield clearMask = GraphicsContext3D::COLOR_BUFFER_BIT;
 977     if (contextAttributes-&gt;depth) {
 978         if (!combinedClear || !m_depthMask || !(mask &amp; GraphicsContext3D::DEPTH_BUFFER_BIT))
 979             m_context-&gt;clearDepth(1.0f);
 980         clearMask |= GraphicsContext3D::DEPTH_BUFFER_BIT;
 981         m_context-&gt;depthMask(true);
 982     }
 983     if (contextAttributes-&gt;stencil) {
 984         if (combinedClear &amp;&amp; (mask &amp; GraphicsContext3D::STENCIL_BUFFER_BIT))
 985             m_context-&gt;clearStencil(m_clearStencil &amp; m_stencilMask);
 986         else
 987             m_context-&gt;clearStencil(0);
 988         clearMask |= GraphicsContext3D::STENCIL_BUFFER_BIT;
 989         m_context-&gt;stencilMaskSeparate(GraphicsContext3D::FRONT, 0xFFFFFFFF);
 990     }
 991     if (m_framebufferBinding)
 992         m_context-&gt;bindFramebuffer(GraphicsContext3D::FRAMEBUFFER, 0);
 993     m_context-&gt;clear(clearMask);
 994 
 995     restoreStateAfterClear();
 996     if (m_framebufferBinding)
 997         m_context-&gt;bindFramebuffer(GraphicsContext3D::FRAMEBUFFER, objectOrZero(m_framebufferBinding.get()));
 998     m_layerCleared = true;
 999 
1000     return combinedClear;
1001 }
1002 
1003 void WebGLRenderingContextBase::restoreStateAfterClear()
1004 {
1005     // Restore the state that the context set.
1006     if (m_scissorEnabled)
1007         m_context-&gt;enable(GraphicsContext3D::SCISSOR_TEST);
1008     m_context-&gt;clearColor(m_clearColor[0], m_clearColor[1],
1009                           m_clearColor[2], m_clearColor[3]);
1010     m_context-&gt;colorMask(m_colorMask[0], m_colorMask[1],
1011                          m_colorMask[2], m_colorMask[3]);
1012     m_context-&gt;clearDepth(m_clearDepth);
1013     m_context-&gt;clearStencil(m_clearStencil);
1014     m_context-&gt;stencilMaskSeparate(GraphicsContext3D::FRONT, m_stencilMask);
1015     m_context-&gt;depthMask(m_depthMask);
1016 }
1017 
1018 void WebGLRenderingContextBase::markLayerComposited()
1019 {
1020     if (isContextLostOrPending())
1021         return;
1022     m_context-&gt;markLayerComposited();
1023 }
1024 
1025 void WebGLRenderingContextBase::paintRenderingResultsToCanvas()
1026 {
1027     if (isContextLostOrPending())
1028         return;
1029 
1030     auto* canvas = htmlCanvas();
1031     if (!canvas)
1032         return;
1033 
1034     if (canvas-&gt;document().printing())
1035         canvas-&gt;clearPresentationCopy();
1036 
1037     // Until the canvas is written to by the application, the clear that
1038     // happened after it was composited should be ignored by the compositor.
1039     if (m_context-&gt;layerComposited() &amp;&amp; !m_attributes.preserveDrawingBuffer) {
1040         m_context-&gt;paintCompositedResultsToCanvas(canvas-&gt;buffer());
1041 
1042         canvas-&gt;makePresentationCopy();
1043     } else
1044         canvas-&gt;clearPresentationCopy();
1045     clearIfComposited();
1046 
1047     if (!m_markedCanvasDirty &amp;&amp; !m_layerCleared)
1048         return;
1049 
1050     canvas-&gt;clearCopiedImage();
1051     m_markedCanvasDirty = false;
1052 
1053     m_context-&gt;paintRenderingResultsToCanvas(canvas-&gt;buffer());
1054 }
1055 
1056 RefPtr&lt;ImageData&gt; WebGLRenderingContextBase::paintRenderingResultsToImageData()
1057 {
1058     if (isContextLostOrPending())
1059         return nullptr;
1060     clearIfComposited();
1061     return m_context-&gt;paintRenderingResultsToImageData();
1062 }
1063 
1064 WebGLTexture::TextureExtensionFlag WebGLRenderingContextBase::textureExtensionFlags() const
1065 {
1066     return static_cast&lt;WebGLTexture::TextureExtensionFlag&gt;((m_oesTextureFloatLinear ? WebGLTexture::TextureExtensionFloatLinearEnabled : 0) | (m_oesTextureHalfFloatLinear ? WebGLTexture::TextureExtensionHalfFloatLinearEnabled : 0));
1067 }
1068 
1069 void WebGLRenderingContextBase::reshape(int width, int height)
1070 {
1071     if (isContextLostOrPending())
1072         return;
1073 
1074     // This is an approximation because at WebGLRenderingContext level we don&#39;t
1075     // know if the underlying FBO uses textures or renderbuffers.
1076     GC3Dint maxSize = std::min(m_maxTextureSize, m_maxRenderbufferSize);
1077     GC3Dint maxWidth = std::min(maxSize, m_maxViewportDims[0]);
1078     GC3Dint maxHeight = std::min(maxSize, m_maxViewportDims[1]);
1079     width = clamp(width, 1, maxWidth);
1080     height = clamp(height, 1, maxHeight);
1081 
1082     if (m_needsUpdate) {
<a name="11" id="anc11"></a><span class="line-modified">1083         auto* canvas = htmlCanvas();</span>
<span class="line-removed">1084         if (canvas) {</span>
<span class="line-removed">1085             RenderBox* renderBox = htmlCanvas()-&gt;renderBox();</span>
<span class="line-removed">1086             if (renderBox &amp;&amp; renderBox-&gt;hasAcceleratedCompositing())</span>
<span class="line-removed">1087                 renderBox-&gt;contentChanged(CanvasChanged);</span>
<span class="line-removed">1088         }</span>
1089         m_needsUpdate = false;
1090     }
1091 
1092     // We don&#39;t have to mark the canvas as dirty, since the newly created image buffer will also start off
1093     // clear (and this matches what reshape will do).
1094     m_context-&gt;reshape(width, height);
1095 
1096     auto&amp; textureUnit = m_textureUnits[m_activeTextureUnit];
1097     m_context-&gt;bindTexture(GraphicsContext3D::TEXTURE_2D, objectOrZero(textureUnit.texture2DBinding.get()));
1098     if (textureUnit.texture2DBinding &amp;&amp; textureUnit.texture2DBinding-&gt;needToUseBlackTexture(textureExtensionFlags()))
1099         m_unrenderableTextureUnits.add(m_activeTextureUnit);
1100     m_context-&gt;bindRenderbuffer(GraphicsContext3D::RENDERBUFFER, objectOrZero(m_renderbufferBinding.get()));
1101     if (m_framebufferBinding)
1102       m_context-&gt;bindFramebuffer(GraphicsContext3D::FRAMEBUFFER, objectOrZero(m_framebufferBinding.get()));
1103 }
1104 
1105 int WebGLRenderingContextBase::drawingBufferWidth() const
1106 {
1107     if (isContextLost())
1108         return 0;
1109 
1110     if (m_isPendingPolicyResolution &amp;&amp; !m_hasRequestedPolicyResolution)
1111         return 0;
1112 
1113     return m_context-&gt;getInternalFramebufferSize().width();
1114 }
1115 
1116 int WebGLRenderingContextBase::drawingBufferHeight() const
1117 {
1118     if (isContextLost())
1119         return 0;
1120 
1121     if (m_isPendingPolicyResolution &amp;&amp; !m_hasRequestedPolicyResolution)
1122         return 0;
1123 
1124     return m_context-&gt;getInternalFramebufferSize().height();
1125 }
1126 
1127 unsigned WebGLRenderingContextBase::sizeInBytes(GC3Denum type)
1128 {
1129     switch (type) {
1130     case GraphicsContext3D::BYTE:
1131         return sizeof(GC3Dbyte);
1132     case GraphicsContext3D::UNSIGNED_BYTE:
1133         return sizeof(GC3Dubyte);
1134     case GraphicsContext3D::SHORT:
1135         return sizeof(GC3Dshort);
1136     case GraphicsContext3D::UNSIGNED_SHORT:
1137         return sizeof(GC3Dushort);
1138     case GraphicsContext3D::INT:
1139         return sizeof(GC3Dint);
1140     case GraphicsContext3D::UNSIGNED_INT:
1141         return sizeof(GC3Duint);
1142     case GraphicsContext3D::FLOAT:
1143         return sizeof(GC3Dfloat);
1144     }
1145     ASSERT_NOT_REACHED();
1146     return 0;
1147 }
1148 
1149 void WebGLRenderingContextBase::activeTexture(GC3Denum texture)
1150 {
1151     if (isContextLostOrPending())
1152         return;
1153     if (texture - GraphicsContext3D::TEXTURE0 &gt;= m_textureUnits.size()) {
1154         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;activeTexture&quot;, &quot;texture unit out of range&quot;);
1155         return;
1156     }
1157     m_activeTextureUnit = texture - GraphicsContext3D::TEXTURE0;
1158     m_context-&gt;activeTexture(texture);
1159 }
1160 
1161 void WebGLRenderingContextBase::attachShader(WebGLProgram* program, WebGLShader* shader)
1162 {
1163     if (isContextLostOrPending() || !validateWebGLObject(&quot;attachShader&quot;, program) || !validateWebGLObject(&quot;attachShader&quot;, shader))
1164         return;
1165     if (!program-&gt;attachShader(shader)) {
1166         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;attachShader&quot;, &quot;shader attachment already has shader&quot;);
1167         return;
1168     }
1169     m_context-&gt;attachShader(objectOrZero(program), objectOrZero(shader));
1170     shader-&gt;onAttached();
1171 }
1172 
1173 void WebGLRenderingContextBase::bindAttribLocation(WebGLProgram* program, GC3Duint index, const String&amp; name)
1174 {
1175     if (isContextLostOrPending() || !validateWebGLObject(&quot;bindAttribLocation&quot;, program))
1176         return;
1177     if (!validateLocationLength(&quot;bindAttribLocation&quot;, name))
1178         return;
1179     if (!validateString(&quot;bindAttribLocation&quot;, name))
1180         return;
1181     if (isPrefixReserved(name)) {
1182         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;bindAttribLocation&quot;, &quot;reserved prefix&quot;);
1183         return;
1184     }
1185     if (index &gt;= m_maxVertexAttribs) {
1186         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;bindAttribLocation&quot;, &quot;index out of range&quot;);
1187         return;
1188     }
1189     m_context-&gt;bindAttribLocation(objectOrZero(program), index, name);
1190 }
1191 
1192 bool WebGLRenderingContextBase::checkObjectToBeBound(const char* functionName, WebGLObject* object, bool&amp; deleted)
1193 {
1194     deleted = false;
1195     if (isContextLostOrPending())
1196         return false;
1197     if (object) {
1198         if (!object-&gt;validate(contextGroup(), *this)) {
1199             synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, functionName, &quot;object not from this context&quot;);
1200             return false;
1201         }
1202         deleted = !object-&gt;object();
1203     }
1204     return true;
1205 }
1206 
1207 void WebGLRenderingContextBase::bindBuffer(GC3Denum target, WebGLBuffer* buffer)
1208 {
1209     bool deleted;
1210     if (!checkObjectToBeBound(&quot;bindBuffer&quot;, buffer, deleted))
1211         return;
1212     if (deleted)
1213         buffer = nullptr;
1214     if (buffer &amp;&amp; buffer-&gt;getTarget() &amp;&amp; buffer-&gt;getTarget() != target) {
1215         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;bindBuffer&quot;, &quot;buffers can not be used with multiple targets&quot;);
1216         return;
1217     }
1218     if (target == GraphicsContext3D::ARRAY_BUFFER)
1219         m_boundArrayBuffer = buffer;
1220     else if (target == GraphicsContext3D::ELEMENT_ARRAY_BUFFER)
1221         m_boundVertexArrayObject-&gt;setElementArrayBuffer(buffer);
1222     else {
1223         bool success = false;
1224 #if ENABLE(WEBGL2)
1225         if (isWebGL2()) {
1226             success = true;
1227             switch (target) {
1228             case GraphicsContext3D::COPY_READ_BUFFER:
1229                 m_boundCopyReadBuffer = buffer;
1230                 break;
1231             case GraphicsContext3D::COPY_WRITE_BUFFER:
1232                 m_boundCopyWriteBuffer = buffer;
1233                 break;
1234             case GraphicsContext3D::PIXEL_PACK_BUFFER:
1235                 m_boundPixelPackBuffer = buffer;
1236                 break;
1237             case GraphicsContext3D::PIXEL_UNPACK_BUFFER:
1238                 m_boundPixelUnpackBuffer = buffer;
1239                 break;
1240             case GraphicsContext3D::TRANSFORM_FEEDBACK_BUFFER:
1241                 m_boundTransformFeedbackBuffer = buffer;
1242                 break;
1243             case GraphicsContext3D::UNIFORM_BUFFER:
1244                 m_boundUniformBuffer = buffer;
1245                 break;
1246             default:
1247                 success = false;
1248                 break;
1249             }
1250         }
1251 #endif
1252         if (!success) {
1253             synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;bindBuffer&quot;, &quot;invalid target&quot;);
1254             return;
1255         }
1256     }
1257 
1258     m_context-&gt;bindBuffer(target, objectOrZero(buffer));
1259     if (buffer)
1260         buffer-&gt;setTarget(target, isWebGL2());
1261 }
1262 
1263 void WebGLRenderingContextBase::bindFramebuffer(GC3Denum target, WebGLFramebuffer* buffer)
1264 {
1265     bool deleted;
1266     if (!checkObjectToBeBound(&quot;bindFramebuffer&quot;, buffer, deleted))
1267         return;
1268     if (deleted)
1269         buffer = 0;
1270 
1271     bool isWebGL2DrawFramebufferTarget = false;
1272 #if ENABLE(WEBGL2)
1273     isWebGL2DrawFramebufferTarget = isWebGL2() &amp;&amp; target == GraphicsContext3D::DRAW_FRAMEBUFFER;
1274 #endif
1275     bool success = false;
1276 
1277     if (target == GraphicsContext3D::FRAMEBUFFER || isWebGL2DrawFramebufferTarget) {
1278         m_framebufferBinding = buffer;
1279         success = true;
1280     }
1281 #if ENABLE(WEBGL2)
1282     if (isWebGL2() &amp;&amp; (target == GraphicsContext3D::FRAMEBUFFER || target == GraphicsContext3D::READ_FRAMEBUFFER)) {
1283         m_readFramebufferBinding = buffer;
1284         success = true;
1285     }
1286 #endif
1287 
1288     if (!success) {
1289         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;bindFramebuffer&quot;, &quot;invalid target&quot;);
1290         return;
1291     }
1292 
1293     m_context-&gt;bindFramebuffer(target, objectOrZero(buffer));
1294     if (buffer)
1295         buffer-&gt;setHasEverBeenBound();
1296     applyStencilTest();
1297 }
1298 
1299 void WebGLRenderingContextBase::bindRenderbuffer(GC3Denum target, WebGLRenderbuffer* renderBuffer)
1300 {
1301     bool deleted;
1302     if (!checkObjectToBeBound(&quot;bindRenderbuffer&quot;, renderBuffer, deleted))
1303         return;
1304     if (deleted)
1305         renderBuffer = 0;
1306     if (target != GraphicsContext3D::RENDERBUFFER) {
1307         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;bindRenderbuffer&quot;, &quot;invalid target&quot;);
1308         return;
1309     }
1310     m_renderbufferBinding = renderBuffer;
1311     m_context-&gt;bindRenderbuffer(target, objectOrZero(renderBuffer));
1312     if (renderBuffer)
1313         renderBuffer-&gt;setHasEverBeenBound();
1314 }
1315 
1316 void WebGLRenderingContextBase::bindTexture(GC3Denum target, WebGLTexture* texture)
1317 {
1318     bool deleted;
1319     if (!checkObjectToBeBound(&quot;bindTexture&quot;, texture, deleted))
1320         return;
1321     if (deleted)
1322         texture = nullptr;
1323     if (texture &amp;&amp; texture-&gt;getTarget() &amp;&amp; texture-&gt;getTarget() != target) {
1324         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;bindTexture&quot;, &quot;textures can not be used with multiple targets&quot;);
1325         return;
1326     }
1327     GC3Dint maxLevel = 0;
1328     auto&amp; textureUnit = m_textureUnits[m_activeTextureUnit];
1329     if (target == GraphicsContext3D::TEXTURE_2D) {
1330         textureUnit.texture2DBinding = texture;
1331         maxLevel = m_maxTextureLevel;
1332         if (texture &amp;&amp; texture-&gt;needToUseBlackTexture(textureExtensionFlags()))
1333             m_unrenderableTextureUnits.add(m_activeTextureUnit);
1334         else
1335             m_unrenderableTextureUnits.remove(m_activeTextureUnit);
1336     } else if (target == GraphicsContext3D::TEXTURE_CUBE_MAP) {
1337         textureUnit.textureCubeMapBinding = texture;
1338         maxLevel = m_maxCubeMapTextureLevel;
1339         if (texture &amp;&amp; texture-&gt;needToUseBlackTexture(textureExtensionFlags()))
1340             m_unrenderableTextureUnits.add(m_activeTextureUnit);
1341         else
1342             m_unrenderableTextureUnits.remove(m_activeTextureUnit);
1343     } else {
1344         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;bindTexture&quot;, &quot;invalid target&quot;);
1345         return;
1346     }
1347     m_context-&gt;bindTexture(target, objectOrZero(texture));
1348     if (texture)
1349         texture-&gt;setTarget(target, maxLevel);
1350 
1351     // Note: previously we used to automatically set the TEXTURE_WRAP_R
1352     // repeat mode to CLAMP_TO_EDGE for cube map textures, because OpenGL
1353     // ES 2.0 doesn&#39;t expose this flag (a bug in the specification) and
1354     // otherwise the application has no control over the seams in this
1355     // dimension. However, it appears that supporting this properly on all
1356     // platforms is fairly involved (will require a HashMap from texture ID
1357     // in all ports), and we have not had any complaints, so the logic has
1358     // been removed.
1359 }
1360 
1361 void WebGLRenderingContextBase::blendColor(GC3Dfloat red, GC3Dfloat green, GC3Dfloat blue, GC3Dfloat alpha)
1362 {
1363     if (isContextLostOrPending())
1364         return;
1365     m_context-&gt;blendColor(red, green, blue, alpha);
1366 }
1367 
1368 void WebGLRenderingContextBase::blendEquation(GC3Denum mode)
1369 {
1370     if (isContextLostOrPending() || !validateBlendEquation(&quot;blendEquation&quot;, mode))
1371         return;
1372     m_context-&gt;blendEquation(mode);
1373 }
1374 
1375 void WebGLRenderingContextBase::blendEquationSeparate(GC3Denum modeRGB, GC3Denum modeAlpha)
1376 {
1377     if (isContextLostOrPending() || !validateBlendEquation(&quot;blendEquation&quot;, modeRGB) || !validateBlendEquation(&quot;blendEquation&quot;, modeAlpha))
1378         return;
1379     m_context-&gt;blendEquationSeparate(modeRGB, modeAlpha);
1380 }
1381 
1382 
1383 void WebGLRenderingContextBase::blendFunc(GC3Denum sfactor, GC3Denum dfactor)
1384 {
1385     if (isContextLostOrPending() || !validateBlendFuncFactors(&quot;blendFunc&quot;, sfactor, dfactor))
1386         return;
1387     m_context-&gt;blendFunc(sfactor, dfactor);
1388 }
1389 
1390 void WebGLRenderingContextBase::blendFuncSeparate(GC3Denum srcRGB, GC3Denum dstRGB, GC3Denum srcAlpha, GC3Denum dstAlpha)
1391 {
1392     // Note: Alpha does not have the same restrictions as RGB.
1393     if (isContextLostOrPending() || !validateBlendFuncFactors(&quot;blendFunc&quot;, srcRGB, dstRGB))
1394         return;
1395     m_context-&gt;blendFuncSeparate(srcRGB, dstRGB, srcAlpha, dstAlpha);
1396 }
1397 
1398 void WebGLRenderingContextBase::bufferData(GC3Denum target, long long size, GC3Denum usage)
1399 {
1400     if (isContextLostOrPending())
1401         return;
1402     RefPtr&lt;WebGLBuffer&gt; buffer = validateBufferDataParameters(&quot;bufferData&quot;, target, usage);
1403     if (!buffer)
1404         return;
1405     if (size &lt; 0) {
1406         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;bufferData&quot;, &quot;size &lt; 0&quot;);
1407         return;
1408     }
1409     if (!size) {
1410         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;bufferData&quot;, &quot;size == 0&quot;);
1411         return;
1412     }
1413     if (!buffer-&gt;associateBufferData(static_cast&lt;GC3Dsizeiptr&gt;(size))) {
1414         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;bufferData&quot;, &quot;invalid buffer&quot;);
1415         return;
1416     }
1417 
1418     m_context-&gt;moveErrorsToSyntheticErrorList();
1419     m_context-&gt;bufferData(target, static_cast&lt;GC3Dsizeiptr&gt;(size), usage);
1420     if (m_context-&gt;moveErrorsToSyntheticErrorList()) {
1421         // The bufferData function failed. Tell the buffer it doesn&#39;t have the data it thinks it does.
1422         buffer-&gt;disassociateBufferData();
1423     }
1424 }
1425 
1426 void WebGLRenderingContextBase::bufferData(GC3Denum target, Optional&lt;BufferDataSource&gt;&amp;&amp; data, GC3Denum usage)
1427 {
1428     if (isContextLostOrPending())
1429         return;
1430     if (!data) {
1431         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;bufferData&quot;, &quot;null data&quot;);
1432         return;
1433     }
1434     RefPtr&lt;WebGLBuffer&gt; buffer = validateBufferDataParameters(&quot;bufferData&quot;, target, usage);
1435     if (!buffer)
1436         return;
1437 
1438     WTF::visit([&amp;](auto&amp; data) {
1439         if (!buffer-&gt;associateBufferData(data.get())) {
1440             this-&gt;synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;bufferData&quot;, &quot;invalid buffer&quot;);
1441             return;
1442         }
1443 
1444         m_context-&gt;moveErrorsToSyntheticErrorList();
1445         m_context-&gt;bufferData(target, data-&gt;byteLength(), data-&gt;data(), usage);
1446         if (m_context-&gt;moveErrorsToSyntheticErrorList()) {
1447             // The bufferData function failed. Tell the buffer it doesn&#39;t have the data it thinks it does.
1448             buffer-&gt;disassociateBufferData();
1449         }
1450     }, data.value());
1451 }
1452 
1453 void WebGLRenderingContextBase::bufferSubData(GC3Denum target, long long offset, Optional&lt;BufferDataSource&gt;&amp;&amp; data)
1454 {
1455     if (isContextLostOrPending())
1456         return;
1457     RefPtr&lt;WebGLBuffer&gt; buffer = validateBufferDataParameters(&quot;bufferSubData&quot;, target, GraphicsContext3D::STATIC_DRAW);
1458     if (!buffer)
1459         return;
1460     if (offset &lt; 0) {
1461         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;bufferSubData&quot;, &quot;offset &lt; 0&quot;);
1462         return;
1463     }
1464     if (!data)
1465         return;
1466 
1467     WTF::visit([&amp;](auto&amp; data) {
1468         if (!buffer-&gt;associateBufferSubData(static_cast&lt;GC3Dintptr&gt;(offset), data.get())) {
1469             this-&gt;synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;bufferSubData&quot;, &quot;offset out of range&quot;);
1470             return;
1471         }
1472 
1473         m_context-&gt;moveErrorsToSyntheticErrorList();
1474         m_context-&gt;bufferSubData(target, static_cast&lt;GC3Dintptr&gt;(offset), data-&gt;byteLength(), data-&gt;data());
1475         if (m_context-&gt;moveErrorsToSyntheticErrorList()) {
1476             // The bufferSubData function failed. Tell the buffer it doesn&#39;t have the data it thinks it does.
1477             buffer-&gt;disassociateBufferData();
1478         }
1479     }, data.value());
1480 }
1481 
1482 GC3Denum WebGLRenderingContextBase::checkFramebufferStatus(GC3Denum target)
1483 {
1484     if (isContextLostOrPending())
1485         return GraphicsContext3D::FRAMEBUFFER_UNSUPPORTED;
1486     if (target != GraphicsContext3D::FRAMEBUFFER) {
1487 #if ENABLE(WEBGL2)
1488         if (isWebGL1() || (target != GraphicsContext3D::DRAW_FRAMEBUFFER &amp;&amp; target != GraphicsContext3D::READ_FRAMEBUFFER)) {
1489 #endif
1490             synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;checkFramebufferStatus&quot;, &quot;invalid target&quot;);
1491             return 0;
1492 #if ENABLE(WEBGL2)
1493         }
1494 #endif
1495     }
1496 
1497     auto targetFramebuffer = (target == GraphicsContext3D::READ_FRAMEBUFFER) ? m_readFramebufferBinding : m_framebufferBinding;
1498 
1499     if (!targetFramebuffer || !targetFramebuffer-&gt;object())
1500         return GraphicsContext3D::FRAMEBUFFER_COMPLETE;
1501     const char* reason = &quot;framebuffer incomplete&quot;;
1502     GC3Denum result = targetFramebuffer-&gt;checkStatus(&amp;reason);
1503     if (result != GraphicsContext3D::FRAMEBUFFER_COMPLETE) {
1504         String str = &quot;WebGL: checkFramebufferStatus:&quot; + String(reason);
1505         printToConsole(MessageLevel::Warning, str);
1506         return result;
1507     }
1508     result = m_context-&gt;checkFramebufferStatus(target);
1509     return result;
1510 }
1511 
1512 void WebGLRenderingContextBase::clearColor(GC3Dfloat r, GC3Dfloat g, GC3Dfloat b, GC3Dfloat a)
1513 {
1514     if (isContextLostOrPending())
1515         return;
1516     if (std::isnan(r))
1517         r = 0;
1518     if (std::isnan(g))
1519         g = 0;
1520     if (std::isnan(b))
1521         b = 0;
1522     if (std::isnan(a))
1523         a = 1;
1524     m_clearColor[0] = r;
1525     m_clearColor[1] = g;
1526     m_clearColor[2] = b;
1527     m_clearColor[3] = a;
1528     m_context-&gt;clearColor(r, g, b, a);
1529 }
1530 
1531 void WebGLRenderingContextBase::clearDepth(GC3Dfloat depth)
1532 {
1533     if (isContextLostOrPending())
1534         return;
1535     m_clearDepth = depth;
1536     m_context-&gt;clearDepth(depth);
1537 }
1538 
1539 void WebGLRenderingContextBase::clearStencil(GC3Dint s)
1540 {
1541     if (isContextLostOrPending())
1542         return;
1543     m_clearStencil = s;
1544     m_context-&gt;clearStencil(s);
1545 }
1546 
1547 void WebGLRenderingContextBase::colorMask(GC3Dboolean red, GC3Dboolean green, GC3Dboolean blue, GC3Dboolean alpha)
1548 {
1549     if (isContextLostOrPending())
1550         return;
1551     m_colorMask[0] = red;
1552     m_colorMask[1] = green;
1553     m_colorMask[2] = blue;
1554     m_colorMask[3] = alpha;
1555     m_context-&gt;colorMask(red, green, blue, alpha);
1556 }
1557 
1558 void WebGLRenderingContextBase::compileShader(WebGLShader* shader)
1559 {
1560     if (isContextLostOrPending() || !validateWebGLObject(&quot;compileShader&quot;, shader))
1561         return;
1562     m_context-&gt;compileShader(objectOrZero(shader));
1563     GC3Dint value;
1564     m_context-&gt;getShaderiv(objectOrZero(shader), GraphicsContext3D::COMPILE_STATUS, &amp;value);
1565     shader-&gt;setValid(value);
1566 
1567     auto* canvas = htmlCanvas();
1568 
1569     if (canvas &amp;&amp; m_synthesizedErrorsToConsole &amp;&amp; !value) {
1570         Ref&lt;Inspector::ScriptCallStack&gt; stackTrace = Inspector::createScriptCallStack(JSExecState::currentState());
1571 
1572         for (auto&amp; error : getShaderInfoLog(shader).split(&#39;\n&#39;))
<a name="12" id="anc12"></a><span class="line-modified">1573             canvas-&gt;document().addConsoleMessage(std::make_unique&lt;Inspector::ConsoleMessage&gt;(MessageSource::Rendering, MessageType::Log, MessageLevel::Error, &quot;WebGL: &quot; + error, stackTrace.copyRef()));</span>
1574     }
1575 }
1576 
1577 void WebGLRenderingContextBase::compressedTexImage2D(GC3Denum target, GC3Dint level, GC3Denum internalformat, GC3Dsizei width, GC3Dsizei height, GC3Dint border, ArrayBufferView&amp; data)
1578 {
1579     if (isContextLostOrPending())
1580         return;
1581     if (!validateTexFuncLevel(&quot;compressedTexImage2D&quot;, target, level))
1582         return;
1583 
1584     if (!validateCompressedTexFormat(internalformat)) {
1585         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;compressedTexImage2D&quot;, &quot;invalid internalformat&quot;);
1586         return;
1587     }
1588     if (border) {
1589         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;compressedTexImage2D&quot;, &quot;border not 0&quot;);
1590         return;
1591     }
1592     if (!validateCompressedTexDimensions(&quot;compressedTexImage2D&quot;, target, level, width, height, internalformat))
1593         return;
1594     if (!validateCompressedTexFuncData(&quot;compressedTexImage2D&quot;, width, height, internalformat, data))
1595         return;
1596 
1597     auto tex = validateTextureBinding(&quot;compressedTexImage2D&quot;, target, true);
1598     if (!tex)
1599         return;
1600     if (!validateNPOTTextureLevel(width, height, level, &quot;compressedTexImage2D&quot;))
1601         return;
1602     m_context-&gt;moveErrorsToSyntheticErrorList();
1603     m_context-&gt;compressedTexImage2D(target, level, internalformat, width, height,
1604         border, data.byteLength(), data.baseAddress());
1605     if (m_context-&gt;moveErrorsToSyntheticErrorList()) {
1606         // The compressedTexImage2D function failed. Tell the WebGLTexture it doesn&#39;t have the data for this level.
1607         tex-&gt;markInvalid(target, level);
1608         return;
1609     }
1610 
1611     tex-&gt;setLevelInfo(target, level, internalformat, width, height, GraphicsContext3D::UNSIGNED_BYTE);
1612     tex-&gt;setCompressed();
1613 }
1614 
1615 void WebGLRenderingContextBase::compressedTexSubImage2D(GC3Denum target, GC3Dint level, GC3Dint xoffset, GC3Dint yoffset, GC3Dsizei width, GC3Dsizei height, GC3Denum format, ArrayBufferView&amp; data)
1616 {
1617     if (isContextLostOrPending())
1618         return;
1619     if (!validateTexFuncLevel(&quot;compressedTexSubImage2D&quot;, target, level))
1620         return;
1621     if (!validateCompressedTexFormat(format)) {
1622         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;compressedTexSubImage2D&quot;, &quot;invalid format&quot;);
1623         return;
1624     }
1625     if (!validateCompressedTexFuncData(&quot;compressedTexSubImage2D&quot;, width, height, format, data))
1626         return;
1627 
1628     auto tex = validateTextureBinding(&quot;compressedTexSubImage2D&quot;, target, true);
1629     if (!tex)
1630         return;
1631 
1632     if (format != tex-&gt;getInternalFormat(target, level)) {
1633         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;compressedTexSubImage2D&quot;, &quot;format does not match texture format&quot;);
1634         return;
1635     }
1636 
1637     if (!validateCompressedTexSubDimensions(&quot;compressedTexSubImage2D&quot;, target, level, xoffset, yoffset, width, height, format, tex.get()))
1638         return;
1639 
1640     graphicsContext3D()-&gt;compressedTexSubImage2D(target, level, xoffset, yoffset, width, height, format, data.byteLength(), data.baseAddress());
1641     tex-&gt;setCompressed();
1642 }
1643 
1644 bool WebGLRenderingContextBase::validateSettableTexInternalFormat(const char* functionName, GC3Denum internalFormat)
1645 {
1646     switch (internalFormat) {
1647     case GraphicsContext3D::DEPTH_COMPONENT:
1648     case GraphicsContext3D::DEPTH_STENCIL:
1649     case GraphicsContext3D::DEPTH_COMPONENT16:
1650     case GraphicsContext3D::DEPTH_COMPONENT24:
1651     case GraphicsContext3D::DEPTH_COMPONENT32F:
1652     case GraphicsContext3D::DEPTH24_STENCIL8:
1653     case GraphicsContext3D::DEPTH32F_STENCIL8:
1654     case GraphicsContext3D::STENCIL_INDEX8:
1655         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, functionName, &quot;format can not be set, only rendered to&quot;);
1656         return false;
1657     default:
1658         return true;
1659     }
1660 }
1661 
1662 void WebGLRenderingContextBase::copyTexSubImage2D(GC3Denum target, GC3Dint level, GC3Dint xoffset, GC3Dint yoffset, GC3Dint x, GC3Dint y, GC3Dsizei width, GC3Dsizei height)
1663 {
1664     if (isContextLostOrPending())
1665         return;
1666     if (!validateTexFuncLevel(&quot;copyTexSubImage2D&quot;, target, level))
1667         return;
1668     auto tex = validateTextureBinding(&quot;copyTexSubImage2D&quot;, target, true);
1669     if (!tex)
1670         return;
1671     if (!validateSize(&quot;copyTexSubImage2D&quot;, xoffset, yoffset) || !validateSize(&quot;copyTexSubImage2D&quot;, width, height))
1672         return;
1673     // Before checking if it is in the range, check if overflow happens first.
1674     if (xoffset + width &lt; 0 || yoffset + height &lt; 0) {
1675         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;copyTexSubImage2D&quot;, &quot;bad dimensions&quot;);
1676         return;
1677     }
1678     if (xoffset + width &gt; tex-&gt;getWidth(target, level) || yoffset + height &gt; tex-&gt;getHeight(target, level)) {
1679         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;copyTexSubImage2D&quot;, &quot;rectangle out of range&quot;);
1680         return;
1681     }
1682     GC3Denum internalFormat = tex-&gt;getInternalFormat(target, level);
1683     if (!validateSettableTexInternalFormat(&quot;copyTexSubImage2D&quot;, internalFormat))
1684         return;
1685     if (!isTexInternalFormatColorBufferCombinationValid(internalFormat, getBoundFramebufferColorFormat())) {
1686         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;copyTexSubImage2D&quot;, &quot;framebuffer is incompatible format&quot;);
1687         return;
1688     }
1689     const char* reason = &quot;framebuffer incomplete&quot;;
1690     if (m_framebufferBinding &amp;&amp; !m_framebufferBinding-&gt;onAccess(graphicsContext3D(), &amp;reason)) {
1691         synthesizeGLError(GraphicsContext3D::INVALID_FRAMEBUFFER_OPERATION, &quot;copyTexSubImage2D&quot;, reason);
1692         return;
1693     }
1694     clearIfComposited();
1695 
1696     GC3Dint clippedX, clippedY;
1697     GC3Dsizei clippedWidth, clippedHeight;
1698     if (clip2D(x, y, width, height, getBoundFramebufferWidth(), getBoundFramebufferHeight(), &amp;clippedX, &amp;clippedY, &amp;clippedWidth, &amp;clippedHeight)) {
1699         GC3Denum format;
1700         GC3Denum type;
1701         if (!GraphicsContext3D::possibleFormatAndTypeForInternalFormat(tex-&gt;getInternalFormat(target, level), format, type)) {
1702             synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;copyTexSubImage2D&quot;, &quot;Texture has unknown internal format&quot;);
1703             return;
1704         }
1705         UniqueArray&lt;unsigned char&gt; zero;
1706         if (width &amp;&amp; height) {
1707             unsigned size;
1708             GC3Denum error = m_context-&gt;computeImageSizeInBytes(format, type, width, height, m_unpackAlignment, &amp;size, nullptr);
1709             if (error != GraphicsContext3D::NO_ERROR) {
1710                 synthesizeGLError(error, &quot;copyTexSubImage2D&quot;, &quot;bad dimensions&quot;);
1711                 return;
1712             }
1713             zero = makeUniqueArray&lt;unsigned char&gt;(size);
1714             if (!zero) {
1715                 synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;copyTexSubImage2D&quot;, &quot;out of memory&quot;);
1716                 return;
1717             }
1718             memset(zero.get(), 0, size);
1719         }
1720         m_context-&gt;texSubImage2D(target, level, xoffset, yoffset, width, height, format, type, zero.get());
1721         if (clippedWidth &gt; 0 &amp;&amp; clippedHeight &gt; 0)
1722             m_context-&gt;copyTexSubImage2D(target, level, xoffset + clippedX - x, yoffset + clippedY - y, clippedX, clippedY, clippedWidth, clippedHeight);
1723     } else
1724         m_context-&gt;copyTexSubImage2D(target, level, xoffset, yoffset, x, y, width, height);
1725 }
1726 
1727 RefPtr&lt;WebGLBuffer&gt; WebGLRenderingContextBase::createBuffer()
1728 {
1729     if (isContextLostOrPending())
1730         return nullptr;
1731     auto buffer = WebGLBuffer::create(*this);
1732     addSharedObject(buffer.get());
<a name="13" id="anc13"></a><span class="line-modified">1733     return WTFMove(buffer);</span>
1734 }
1735 
1736 RefPtr&lt;WebGLFramebuffer&gt; WebGLRenderingContextBase::createFramebuffer()
1737 {
1738     if (isContextLostOrPending())
1739         return nullptr;
1740     auto buffer = WebGLFramebuffer::create(*this);
1741     addContextObject(buffer.get());
<a name="14" id="anc14"></a><span class="line-modified">1742     return WTFMove(buffer);</span>
1743 }
1744 
1745 RefPtr&lt;WebGLTexture&gt; WebGLRenderingContextBase::createTexture()
1746 {
1747     if (isContextLostOrPending())
1748         return nullptr;
1749     auto texture = WebGLTexture::create(*this);
1750     addSharedObject(texture.get());
<a name="15" id="anc15"></a><span class="line-modified">1751     return WTFMove(texture);</span>
1752 }
1753 
1754 RefPtr&lt;WebGLProgram&gt; WebGLRenderingContextBase::createProgram()
1755 {
1756     if (isContextLostOrPending())
1757         return nullptr;
1758     auto program = WebGLProgram::create(*this);
1759     addSharedObject(program.get());
1760 
1761     InspectorInstrumentation::didCreateProgram(*this, program.get());
1762 
<a name="16" id="anc16"></a><span class="line-modified">1763     return WTFMove(program);</span>
1764 }
1765 
1766 RefPtr&lt;WebGLRenderbuffer&gt; WebGLRenderingContextBase::createRenderbuffer()
1767 {
1768     if (isContextLostOrPending())
1769         return nullptr;
1770     auto buffer = WebGLRenderbuffer::create(*this);
1771     addSharedObject(buffer.get());
<a name="17" id="anc17"></a><span class="line-modified">1772     return WTFMove(buffer);</span>
1773 }
1774 
1775 RefPtr&lt;WebGLShader&gt; WebGLRenderingContextBase::createShader(GC3Denum type)
1776 {
1777     if (isContextLostOrPending())
1778         return nullptr;
1779     if (type != GraphicsContext3D::VERTEX_SHADER &amp;&amp; type != GraphicsContext3D::FRAGMENT_SHADER) {
1780         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;createShader&quot;, &quot;invalid shader type&quot;);
1781         return nullptr;
1782     }
1783 
1784     auto shader = WebGLShader::create(*this, type);
1785     addSharedObject(shader.get());
<a name="18" id="anc18"></a><span class="line-modified">1786     return WTFMove(shader);</span>
1787 }
1788 
1789 void WebGLRenderingContextBase::cullFace(GC3Denum mode)
1790 {
1791     if (isContextLostOrPending())
1792         return;
1793     m_context-&gt;cullFace(mode);
1794 }
1795 
1796 bool WebGLRenderingContextBase::deleteObject(WebGLObject* object)
1797 {
1798     if (isContextLostOrPending() || !object)
1799         return false;
1800     if (!object-&gt;validate(contextGroup(), *this)) {
1801         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;delete&quot;, &quot;object does not belong to this context&quot;);
1802         return false;
1803     }
1804     if (object-&gt;isDeleted())
1805         return false;
1806     if (object-&gt;object())
1807         // We need to pass in context here because we want
1808         // things in this context unbound.
1809         object-&gt;deleteObject(graphicsContext3D());
1810     return true;
1811 }
1812 
1813 void WebGLRenderingContextBase::deleteBuffer(WebGLBuffer* buffer)
1814 {
1815     if (!deleteObject(buffer))
1816         return;
1817     if (m_boundArrayBuffer == buffer)
1818         m_boundArrayBuffer = nullptr;
1819 
1820     m_boundVertexArrayObject-&gt;unbindBuffer(*buffer);
1821 }
1822 
1823 void WebGLRenderingContextBase::deleteFramebuffer(WebGLFramebuffer* framebuffer)
1824 {
1825     if (!deleteObject(framebuffer))
1826         return;
1827 #if ENABLE(WEBGL2)
1828     if (isWebGL2() &amp;&amp; framebuffer == m_readFramebufferBinding) {
1829         m_readFramebufferBinding = nullptr;
1830         m_context-&gt;bindFramebuffer(GraphicsContext3D::READ_FRAMEBUFFER, 0);
1831     }
1832 #endif
1833     if (framebuffer == m_framebufferBinding) {
1834         m_framebufferBinding = nullptr;
1835 #if ENABLE(WEBGL2)
1836         if (isWebGL2())
1837             m_context-&gt;bindFramebuffer(GraphicsContext3D::DRAW_FRAMEBUFFER, 0);
1838         else
1839 #endif
1840             m_context-&gt;bindFramebuffer(GraphicsContext3D::FRAMEBUFFER, 0);
1841     }
1842 }
1843 
1844 void WebGLRenderingContextBase::deleteProgram(WebGLProgram* program)
1845 {
1846     if (program)
1847         InspectorInstrumentation::willDeleteProgram(*this, *program);
1848 
1849     deleteObject(program);
1850     // We don&#39;t reset m_currentProgram to 0 here because the deletion of the
1851     // current program is delayed.
1852 }
1853 
1854 void WebGLRenderingContextBase::deleteRenderbuffer(WebGLRenderbuffer* renderbuffer)
1855 {
1856     if (!deleteObject(renderbuffer))
1857         return;
1858     if (renderbuffer == m_renderbufferBinding)
1859         m_renderbufferBinding = nullptr;
1860     if (m_framebufferBinding)
1861         m_framebufferBinding-&gt;removeAttachmentFromBoundFramebuffer(renderbuffer);
1862 }
1863 
1864 void WebGLRenderingContextBase::deleteShader(WebGLShader* shader)
1865 {
1866     deleteObject(shader);
1867 }
1868 
1869 void WebGLRenderingContextBase::deleteTexture(WebGLTexture* texture)
1870 {
1871     if (!deleteObject(texture))
1872         return;
1873 
1874     unsigned current = 0;
1875     for (auto&amp; textureUnit : m_textureUnits) {
1876         if (texture == textureUnit.texture2DBinding) {
1877             textureUnit.texture2DBinding = nullptr;
1878             m_unrenderableTextureUnits.remove(current);
1879         }
1880         if (texture == textureUnit.textureCubeMapBinding) {
1881             textureUnit.textureCubeMapBinding = nullptr;
1882             m_unrenderableTextureUnits.remove(current);
1883         }
1884         ++current;
1885     }
1886     if (m_framebufferBinding)
1887         m_framebufferBinding-&gt;removeAttachmentFromBoundFramebuffer(texture);
1888 }
1889 
1890 void WebGLRenderingContextBase::depthFunc(GC3Denum func)
1891 {
1892     if (isContextLostOrPending())
1893         return;
1894     m_context-&gt;depthFunc(func);
1895 }
1896 
1897 void WebGLRenderingContextBase::depthMask(GC3Dboolean flag)
1898 {
1899     if (isContextLostOrPending())
1900         return;
1901     m_depthMask = flag;
1902     m_context-&gt;depthMask(flag);
1903 }
1904 
1905 void WebGLRenderingContextBase::depthRange(GC3Dfloat zNear, GC3Dfloat zFar)
1906 {
1907     if (isContextLostOrPending())
1908         return;
1909     if (zNear &gt; zFar) {
1910         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;depthRange&quot;, &quot;zNear &gt; zFar&quot;);
1911         return;
1912     }
1913     m_context-&gt;depthRange(zNear, zFar);
1914 }
1915 
1916 void WebGLRenderingContextBase::detachShader(WebGLProgram* program, WebGLShader* shader)
1917 {
1918     if (isContextLostOrPending() || !validateWebGLObject(&quot;detachShader&quot;, program) || !validateWebGLObject(&quot;detachShader&quot;, shader))
1919         return;
1920     if (!program-&gt;detachShader(shader)) {
1921         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;detachShader&quot;, &quot;shader not attached&quot;);
1922         return;
1923     }
1924     m_context-&gt;detachShader(objectOrZero(program), objectOrZero(shader));
1925     shader-&gt;onDetached(graphicsContext3D());
1926 }
1927 
1928 void WebGLRenderingContextBase::disable(GC3Denum cap)
1929 {
1930     if (isContextLostOrPending() || !validateCapability(&quot;disable&quot;, cap))
1931         return;
1932     if (cap == GraphicsContext3D::STENCIL_TEST) {
1933         m_stencilEnabled = false;
1934         applyStencilTest();
1935         return;
1936     }
1937     if (cap == GraphicsContext3D::SCISSOR_TEST)
1938         m_scissorEnabled = false;
1939     m_context-&gt;disable(cap);
1940 }
1941 
1942 void WebGLRenderingContextBase::disableVertexAttribArray(GC3Duint index)
1943 {
1944     if (isContextLostOrPending())
1945         return;
1946     if (index &gt;= m_maxVertexAttribs) {
1947         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;disableVertexAttribArray&quot;, &quot;index out of range&quot;);
1948         return;
1949     }
1950 
1951     WebGLVertexArrayObjectBase::VertexAttribState&amp; state = m_boundVertexArrayObject-&gt;getVertexAttribState(index);
1952     state.enabled = false;
1953 
1954     if (index &gt; 0 || isGLES2Compliant())
1955         m_context-&gt;disableVertexAttribArray(index);
1956 }
1957 
1958 bool WebGLRenderingContextBase::validateNPOTTextureLevel(GC3Dsizei width, GC3Dsizei height, GC3Dint level, const char* functionName)
1959 {
1960     if (!isGLES2NPOTStrict() &amp;&amp; level &amp;&amp; WebGLTexture::isNPOT(width, height)) {
1961         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, functionName, &quot;level &gt; 0 not power of 2&quot;);
1962         return false;
1963     }
1964 
1965     return true;
1966 }
1967 
1968 bool WebGLRenderingContextBase::validateElementArraySize(GC3Dsizei count, GC3Denum type, GC3Dintptr offset)
1969 {
1970     RefPtr&lt;WebGLBuffer&gt; elementArrayBuffer = m_boundVertexArrayObject-&gt;getElementArrayBuffer();
1971 
1972     if (!elementArrayBuffer)
1973         return false;
1974 
1975     if (offset &lt; 0)
1976         return false;
1977 
1978     if (type == GraphicsContext3D::UNSIGNED_INT) {
1979         // For an unsigned int array, offset must be divisible by 4 for alignment reasons.
1980         if (offset % 4)
1981             return false;
1982 
1983         // Make uoffset an element offset.
1984         offset /= 4;
1985 
1986         GC3Dsizeiptr n = elementArrayBuffer-&gt;byteLength() / 4;
1987         if (offset &gt; n || count &gt; n - offset)
1988             return false;
1989     } else if (type == GraphicsContext3D::UNSIGNED_SHORT) {
1990         // For an unsigned short array, offset must be divisible by 2 for alignment reasons.
1991         if (offset % 2)
1992             return false;
1993 
1994         // Make uoffset an element offset.
1995         offset /= 2;
1996 
1997         GC3Dsizeiptr n = elementArrayBuffer-&gt;byteLength() / 2;
1998         if (offset &gt; n || count &gt; n - offset)
1999             return false;
2000     } else if (type == GraphicsContext3D::UNSIGNED_BYTE) {
2001         GC3Dsizeiptr n = elementArrayBuffer-&gt;byteLength();
2002         if (offset &gt; n || count &gt; n - offset)
2003             return false;
2004     }
2005     return true;
2006 }
2007 
2008 bool WebGLRenderingContextBase::validateIndexArrayPrecise(GC3Dsizei count, GC3Denum type, GC3Dintptr offset, unsigned&amp; numElementsRequired)
2009 {
2010     ASSERT(count &gt;= 0 &amp;&amp; offset &gt;= 0);
2011     unsigned maxIndex = 0;
2012 
2013     RefPtr&lt;WebGLBuffer&gt; elementArrayBuffer = m_boundVertexArrayObject-&gt;getElementArrayBuffer();
2014 
2015     if (!elementArrayBuffer)
2016         return false;
2017 
2018     if (!count) {
2019         numElementsRequired = 0;
2020         return true;
2021     }
2022 
2023     auto buffer = elementArrayBuffer-&gt;elementArrayBuffer();
2024     if (!buffer)
2025         return false;
2026 
2027     switch (type) {
2028     case GraphicsContext3D::UNSIGNED_INT:
2029         maxIndex = getMaxIndex&lt;GC3Duint&gt;(buffer, offset, count);
2030         break;
2031     case GraphicsContext3D::UNSIGNED_SHORT:
2032         maxIndex = getMaxIndex&lt;GC3Dushort&gt;(buffer, offset, count);
2033         break;
2034     case GraphicsContext3D::UNSIGNED_BYTE:
2035         maxIndex = getMaxIndex&lt;GC3Dubyte&gt;(buffer, offset, count);
2036         break;
2037     }
2038 
2039     // Then set the maxiumum index in the index array and make sure it is valid.
2040     auto checkedNumElementsRequired = checkedAddAndMultiply&lt;unsigned&gt;(maxIndex, 1, 1);
2041     if (!checkedNumElementsRequired)
2042         return false;
2043     numElementsRequired = checkedNumElementsRequired.value();
2044     return true;
2045 }
2046 
2047 bool WebGLRenderingContextBase::validateVertexAttributes(unsigned elementCount, unsigned primitiveCount)
2048 {
<a name="19" id="anc19"></a>
2049     if (!m_currentProgram)
2050         return false;
2051 
2052     // Look in each enabled vertex attrib and check if they&#39;ve been bound to a buffer.
2053     for (unsigned i = 0; i &lt; m_maxVertexAttribs; ++i) {
2054         if (!m_boundVertexArrayObject-&gt;getVertexAttribState(i).validateBinding())
2055             return false;
2056     }
2057 
2058     if (!elementCount)
2059         return true;
2060 
2061     // Look in each consumed vertex attrib (by the current program).
2062     bool sawNonInstancedAttrib = false;
2063     bool sawEnabledAttrib = false;
2064     int numActiveAttribLocations = m_currentProgram-&gt;numActiveAttribLocations();
2065     for (int i = 0; i &lt; numActiveAttribLocations; ++i) {
2066         int loc = m_currentProgram-&gt;getActiveAttribLocation(i);
2067         if (loc &gt;= 0 &amp;&amp; loc &lt; static_cast&lt;int&gt;(m_maxVertexAttribs)) {
2068             const WebGLVertexArrayObjectBase::VertexAttribState&amp; state = m_boundVertexArrayObject-&gt;getVertexAttribState(loc);
2069             if (state.enabled) {
2070                 sawEnabledAttrib = true;
2071                 // Avoid off-by-one errors in numElements computation.
2072                 // For the last element, we will only touch the data for the
2073                 // element and nothing beyond it.
2074                 int bytesRemaining = static_cast&lt;int&gt;(state.bufferBinding-&gt;byteLength() - state.offset);
2075                 if (bytesRemaining &lt;= 0)
2076                     return false;
2077                 unsigned numElements = 0;
2078                 ASSERT(state.stride &gt; 0);
2079                 if (bytesRemaining &gt;= state.bytesPerElement)
2080                     numElements = 1 + (bytesRemaining - state.bytesPerElement) / state.stride;
2081                 unsigned instancesRequired = 0;
2082                 if (state.divisor) {
2083                     instancesRequired = ceil(static_cast&lt;float&gt;(primitiveCount) / state.divisor);
2084                     if (instancesRequired &gt; numElements)
2085                         return false;
2086                 } else {
2087                     sawNonInstancedAttrib = true;
2088                     if (elementCount &gt; numElements)
2089                         return false;
2090                 }
2091             }
2092         }
2093     }
2094 
2095     if (!sawNonInstancedAttrib &amp;&amp; sawEnabledAttrib)
2096         return false;
2097 
2098     bool usingSimulatedArrayBuffer = m_currentProgram-&gt;isUsingVertexAttrib0();
2099 
2100     // Guard against access into non-existent buffers.
2101     if (elementCount &amp;&amp; !sawEnabledAttrib &amp;&amp; !usingSimulatedArrayBuffer)
2102         return false;
2103 
2104     if (elementCount &amp;&amp; sawEnabledAttrib) {
2105         if (!m_boundArrayBuffer &amp;&amp; !m_boundVertexArrayObject-&gt;getElementArrayBuffer()) {
2106             if (usingSimulatedArrayBuffer) {
2107                 auto&amp; state = m_boundVertexArrayObject-&gt;getVertexAttribState(0);
2108                 if (state.enabled &amp;&amp; state.isBound()) {
2109                     if (state.bufferBinding-&gt;getTarget() == GraphicsContext3D::ARRAY_BUFFER || state.bufferBinding-&gt;getTarget() == GraphicsContext3D::ELEMENT_ARRAY_BUFFER)
2110                         return !!state.bufferBinding-&gt;byteLength();
2111                 }
2112             }
2113             return false;
2114         }
2115     }
<a name="20" id="anc20"></a>
2116 
2117     return true;
2118 }
2119 
2120 bool WebGLRenderingContextBase::validateWebGLObject(const char* functionName, WebGLObject* object)
2121 {
2122     if (!object || !object-&gt;object()) {
2123         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, functionName, &quot;no object or object deleted&quot;);
2124         return false;
2125     }
2126     if (!object-&gt;validate(contextGroup(), *this)) {
2127         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, functionName, &quot;object does not belong to this context&quot;);
2128         return false;
2129     }
2130     return true;
2131 }
2132 
2133 bool WebGLRenderingContextBase::validateDrawArrays(const char* functionName, GC3Denum mode, GC3Dint first, GC3Dsizei count, GC3Dsizei primitiveCount)
2134 {
2135     if (isContextLostOrPending() || !validateDrawMode(functionName, mode))
2136         return false;
2137 
2138     if (!validateStencilSettings(functionName))
2139         return false;
2140 
2141     if (first &lt; 0 || count &lt; 0) {
2142         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, functionName, &quot;first or count &lt; 0&quot;);
2143         return false;
2144     }
2145 
2146     if (!count) {
2147         markContextChanged();
2148         return false;
2149     }
2150 
2151     if (primitiveCount &lt; 0) {
2152         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, functionName, &quot;primcount &lt; 0&quot;);
2153         return false;
2154     }
2155 
2156     // Ensure we have a valid rendering state.
2157     Checked&lt;GC3Dint, RecordOverflow&gt; checkedSum = Checked&lt;GC3Dint, RecordOverflow&gt;(first) + Checked&lt;GC3Dint, RecordOverflow&gt;(count);
2158     Checked&lt;GC3Dint, RecordOverflow&gt; checkedPrimitiveCount(primitiveCount);
2159     if (checkedSum.hasOverflowed() || checkedPrimitiveCount.hasOverflowed() || !validateVertexAttributes(checkedSum.unsafeGet(), checkedPrimitiveCount.unsafeGet())) {
2160         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, functionName, &quot;attempt to access out of bounds arrays&quot;);
2161         return false;
2162     }
2163     if (!validateSimulatedVertexAttrib0(checkedSum.unsafeGet() - 1)) {
2164         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, functionName, &quot;attempt to access outside the bounds of the simulated vertexAttrib0 array&quot;);
2165         return false;
2166     }
2167 
2168     const char* reason = &quot;framebuffer incomplete&quot;;
2169     if (m_framebufferBinding &amp;&amp; !m_framebufferBinding-&gt;onAccess(graphicsContext3D(), &amp;reason)) {
2170         synthesizeGLError(GraphicsContext3D::INVALID_FRAMEBUFFER_OPERATION, functionName, reason);
2171         return false;
2172     }
2173 
2174     return true;
2175 }
2176 
2177 bool WebGLRenderingContextBase::validateDrawElements(const char* functionName, GC3Denum mode, GC3Dsizei count, GC3Denum type, long long offset, unsigned&amp; numElements, GC3Dsizei primitiveCount)
2178 {
2179     if (isContextLostOrPending() || !validateDrawMode(functionName, mode))
2180         return false;
2181 
2182     if (!validateStencilSettings(functionName))
2183         return false;
2184 
2185     switch (type) {
2186     case GraphicsContext3D::UNSIGNED_BYTE:
2187     case GraphicsContext3D::UNSIGNED_SHORT:
2188         break;
2189     case GraphicsContext3D::UNSIGNED_INT:
2190         if (m_oesElementIndexUint || isWebGL2())
2191             break;
2192         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, functionName, &quot;invalid type&quot;);
2193         return false;
2194     default:
2195         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, functionName, &quot;invalid type&quot;);
2196         return false;
2197     }
2198 
2199     if (count &lt; 0 || offset &lt; 0) {
2200         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, functionName, &quot;count or offset &lt; 0&quot;);
2201         return false;
2202     }
2203 
2204     if (!count) {
2205         markContextChanged();
2206         return false;
2207     }
2208 
2209     if (primitiveCount &lt; 0) {
2210         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, functionName, &quot;primcount &lt; 0&quot;);
2211         return false;
2212     }
2213 
2214     if (!m_boundVertexArrayObject-&gt;getElementArrayBuffer()) {
2215         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, functionName, &quot;no ELEMENT_ARRAY_BUFFER bound&quot;);
2216         return false;
2217     }
2218 
2219     // Ensure we have a valid rendering state.
2220     if (!validateElementArraySize(count, type, static_cast&lt;GC3Dintptr&gt;(offset))) {
2221         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, functionName, &quot;request out of bounds for current ELEMENT_ARRAY_BUFFER&quot;);
2222         return false;
2223     }
2224     if (!count)
2225         return false;
2226 
2227     Checked&lt;GC3Dint, RecordOverflow&gt; checkedCount(count);
2228     Checked&lt;GC3Dint, RecordOverflow&gt; checkedPrimitiveCount(primitiveCount);
2229     if (checkedCount.hasOverflowed() || checkedPrimitiveCount.hasOverflowed()) {
2230         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, functionName, &quot;attempt to access out of bounds arrays&quot;);
2231         return false;
2232     }
2233 
2234     if (!validateIndexArrayConservative(type, numElements) || !validateVertexAttributes(numElements, checkedPrimitiveCount.unsafeGet())) {
2235         if (!validateIndexArrayPrecise(checkedCount.unsafeGet(), type, static_cast&lt;GC3Dintptr&gt;(offset), numElements) || !validateVertexAttributes(numElements, checkedPrimitiveCount.unsafeGet())) {
2236             synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, functionName, &quot;attempt to access out of bounds arrays&quot;);
2237             return false;
2238         }
2239     }
2240 
2241     if (!validateSimulatedVertexAttrib0(numElements)) {
2242         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, functionName, &quot;attempt to access outside the bounds of the simulated vertexAttrib0 array&quot;);
2243         return false;
2244     }
2245 
2246     const char* reason = &quot;framebuffer incomplete&quot;;
2247     if (m_framebufferBinding &amp;&amp; !m_framebufferBinding-&gt;onAccess(graphicsContext3D(), &amp;reason)) {
2248         synthesizeGLError(GraphicsContext3D::INVALID_FRAMEBUFFER_OPERATION, functionName, reason);
2249         return false;
2250     }
2251 
2252     return true;
2253 }
2254 
2255 void WebGLRenderingContextBase::drawArrays(GC3Denum mode, GC3Dint first, GC3Dsizei count)
2256 {
2257     if (!validateDrawArrays(&quot;drawArrays&quot;, mode, first, count, 0))
2258         return;
2259 
2260     if (m_currentProgram &amp;&amp; InspectorInstrumentation::isShaderProgramDisabled(*this, *m_currentProgram))
2261         return;
2262 
2263     clearIfComposited();
2264 
2265     bool vertexAttrib0Simulated = false;
2266     if (!isGLES2Compliant()) {
2267         auto simulateVertexAttrib0Status = simulateVertexAttrib0(first + count - 1);
2268         if (!simulateVertexAttrib0Status) {
2269             // We were unable to simulate the attribute buffer.
2270             synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;drawArrays&quot;, &quot;unable to simulate vertexAttrib0 array&quot;);
2271             return;
2272         }
2273         vertexAttrib0Simulated = simulateVertexAttrib0Status.value();
2274     }
2275     bool usesFallbackTexture = false;
2276     if (!isGLES2NPOTStrict())
2277         usesFallbackTexture = checkTextureCompleteness(&quot;drawArrays&quot;, true);
2278 
2279     {
2280         InspectorScopedShaderProgramHighlight scopedHighlight(*this, m_currentProgram.get());
2281 
2282         m_context-&gt;drawArrays(mode, first, count);
2283     }
2284 
2285     if (!isGLES2Compliant() &amp;&amp; vertexAttrib0Simulated)
2286         restoreStatesAfterVertexAttrib0Simulation();
2287     if (usesFallbackTexture)
2288         checkTextureCompleteness(&quot;drawArrays&quot;, false);
2289     markContextChangedAndNotifyCanvasObserver();
2290 }
2291 
2292 #if USE(OPENGL) &amp;&amp; ENABLE(WEBGL2)
2293 static GC3Duint getRestartIndex(GC3Denum type)
2294 {
2295     switch (type) {
2296     case GraphicsContext3D::UNSIGNED_BYTE:
2297         return std::numeric_limits&lt;GC3Dubyte&gt;::max();
2298     case GraphicsContext3D::UNSIGNED_SHORT:
2299         return std::numeric_limits&lt;GC3Dushort&gt;::max();
2300     case GraphicsContext3D::UNSIGNED_INT:
2301         return std::numeric_limits&lt;GC3Duint&gt;::max();
2302     }
2303 
2304     return 0;
2305 }
2306 #endif
2307 
2308 void WebGLRenderingContextBase::drawElements(GC3Denum mode, GC3Dsizei count, GC3Denum type, long long offset)
2309 {
2310     unsigned numElements = 0;
2311     if (!validateDrawElements(&quot;drawElements&quot;, mode, count, type, offset, numElements, 0))
2312         return;
2313 
2314     if (m_currentProgram &amp;&amp; InspectorInstrumentation::isShaderProgramDisabled(*this, *m_currentProgram))
2315         return;
2316 
2317     clearIfComposited();
2318 
2319     bool vertexAttrib0Simulated = false;
2320     if (!isGLES2Compliant()) {
2321         if (!numElements)
2322             validateIndexArrayPrecise(count, type, static_cast&lt;GC3Dintptr&gt;(offset), numElements);
2323         auto simulateVertexAttrib0Status = simulateVertexAttrib0(numElements);
2324         if (!simulateVertexAttrib0Status) {
2325             // We were unable to simulate the attribute buffer.
2326             synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;drawElements&quot;, &quot;unable to simulate vertexAttrib0 array&quot;);
2327             return;
2328         }
2329         vertexAttrib0Simulated = simulateVertexAttrib0Status.value();
2330     }
2331 
2332     bool usesFallbackTexture = false;
2333     if (!isGLES2NPOTStrict())
2334         usesFallbackTexture = checkTextureCompleteness(&quot;drawElements&quot;, true);
2335 
2336 #if USE(OPENGL) &amp;&amp; ENABLE(WEBGL2)
2337     if (isWebGL2())
2338         m_context-&gt;primitiveRestartIndex(getRestartIndex(type));
2339 #endif
2340 
2341     {
2342         InspectorScopedShaderProgramHighlight scopedHighlight(*this, m_currentProgram.get());
2343 
2344         m_context-&gt;drawElements(mode, count, type, static_cast&lt;GC3Dintptr&gt;(offset));
2345     }
2346 
2347     if (!isGLES2Compliant() &amp;&amp; vertexAttrib0Simulated)
2348         restoreStatesAfterVertexAttrib0Simulation();
2349     if (usesFallbackTexture)
2350         checkTextureCompleteness(&quot;drawElements&quot;, false);
2351     markContextChangedAndNotifyCanvasObserver();
2352 }
2353 
2354 void WebGLRenderingContextBase::enable(GC3Denum cap)
2355 {
2356     if (isContextLostOrPending() || !validateCapability(&quot;enable&quot;, cap))
2357         return;
2358     if (cap == GraphicsContext3D::STENCIL_TEST) {
2359         m_stencilEnabled = true;
2360         applyStencilTest();
2361         return;
2362     }
2363     if (cap == GraphicsContext3D::SCISSOR_TEST)
2364         m_scissorEnabled = true;
2365     m_context-&gt;enable(cap);
2366 }
2367 
2368 void WebGLRenderingContextBase::enableVertexAttribArray(GC3Duint index)
2369 {
2370     if (isContextLostOrPending())
2371         return;
2372     if (index &gt;= m_maxVertexAttribs) {
2373         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;enableVertexAttribArray&quot;, &quot;index out of range&quot;);
2374         return;
2375     }
2376 
2377     WebGLVertexArrayObjectBase::VertexAttribState&amp; state = m_boundVertexArrayObject-&gt;getVertexAttribState(index);
2378     state.enabled = true;
2379 
2380     m_context-&gt;enableVertexAttribArray(index);
2381 }
2382 
2383 void WebGLRenderingContextBase::finish()
2384 {
2385     if (isContextLostOrPending())
2386         return;
2387     m_context-&gt;finish();
2388 }
2389 
2390 void WebGLRenderingContextBase::flush()
2391 {
2392     if (isContextLostOrPending())
2393         return;
2394     m_context-&gt;flush();
2395 }
2396 
2397 void WebGLRenderingContextBase::framebufferRenderbuffer(GC3Denum target, GC3Denum attachment, GC3Denum renderbuffertarget, WebGLRenderbuffer* buffer)
2398 {
2399     if (isContextLostOrPending() || !validateFramebufferFuncParameters(&quot;framebufferRenderbuffer&quot;, target, attachment))
2400         return;
2401     if (renderbuffertarget != GraphicsContext3D::RENDERBUFFER) {
2402         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;framebufferRenderbuffer&quot;, &quot;invalid target&quot;);
2403         return;
2404     }
2405     if (buffer &amp;&amp; !buffer-&gt;validate(contextGroup(), *this)) {
2406         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;framebufferRenderbuffer&quot;, &quot;no buffer or buffer not from this context&quot;);
2407         return;
2408     }
2409 
2410     auto targetFramebuffer = (target == GraphicsContext3D::READ_FRAMEBUFFER) ? m_readFramebufferBinding : m_framebufferBinding;
2411 
2412     // Don&#39;t allow the default framebuffer to be mutated; all current
2413     // implementations use an FBO internally in place of the default
2414     // FBO.
2415     if (!targetFramebuffer || !targetFramebuffer-&gt;object()) {
2416         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;framebufferRenderbuffer&quot;, &quot;no framebuffer bound&quot;);
2417         return;
2418     }
2419     Platform3DObject bufferObject = objectOrZero(buffer);
2420     switch (attachment) {
2421     case GraphicsContext3D::DEPTH_STENCIL_ATTACHMENT:
2422         m_context-&gt;framebufferRenderbuffer(target, GraphicsContext3D::DEPTH_ATTACHMENT, renderbuffertarget, bufferObject);
2423         m_context-&gt;framebufferRenderbuffer(target, GraphicsContext3D::STENCIL_ATTACHMENT, renderbuffertarget, bufferObject);
2424         break;
2425     default:
2426         m_context-&gt;framebufferRenderbuffer(target, attachment, renderbuffertarget, bufferObject);
2427     }
2428     targetFramebuffer-&gt;setAttachmentForBoundFramebuffer(attachment, buffer);
2429     applyStencilTest();
2430 }
2431 
2432 void WebGLRenderingContextBase::framebufferTexture2D(GC3Denum target, GC3Denum attachment, GC3Denum textarget, WebGLTexture* texture, GC3Dint level)
2433 {
2434     if (isContextLostOrPending() || !validateFramebufferFuncParameters(&quot;framebufferTexture2D&quot;, target, attachment))
2435         return;
2436     if (level &amp;&amp; isWebGL1()) {
2437         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;framebufferTexture2D&quot;, &quot;level not 0&quot;);
2438         return;
2439     }
2440     if (texture &amp;&amp; !texture-&gt;validate(contextGroup(), *this)) {
2441         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;framebufferTexture2D&quot;, &quot;no texture or texture not from this context&quot;);
2442         return;
2443     }
2444 
2445     auto targetFramebuffer = (target == GraphicsContext3D::READ_FRAMEBUFFER) ? m_readFramebufferBinding : m_framebufferBinding;
2446 
2447     // Don&#39;t allow the default framebuffer to be mutated; all current
2448     // implementations use an FBO internally in place of the default
2449     // FBO.
2450     if (!targetFramebuffer || !targetFramebuffer-&gt;object()) {
2451         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;framebufferTexture2D&quot;, &quot;no framebuffer bound&quot;);
2452         return;
2453     }
2454     Platform3DObject textureObject = objectOrZero(texture);
2455     switch (attachment) {
2456     case GraphicsContext3D::DEPTH_STENCIL_ATTACHMENT:
2457         m_context-&gt;framebufferTexture2D(target, GraphicsContext3D::DEPTH_ATTACHMENT, textarget, textureObject, level);
2458         m_context-&gt;framebufferTexture2D(target, GraphicsContext3D::STENCIL_ATTACHMENT, textarget, textureObject, level);
2459         break;
2460     case GraphicsContext3D::DEPTH_ATTACHMENT:
2461         m_context-&gt;framebufferTexture2D(target, attachment, textarget, textureObject, level);
2462         break;
2463     case GraphicsContext3D::STENCIL_ATTACHMENT:
2464         m_context-&gt;framebufferTexture2D(target, attachment, textarget, textureObject, level);
2465         break;
2466     default:
2467         m_context-&gt;framebufferTexture2D(target, attachment, textarget, textureObject, level);
2468     }
2469     targetFramebuffer-&gt;setAttachmentForBoundFramebuffer(attachment, textarget, texture, level);
2470     applyStencilTest();
2471 }
2472 
2473 void WebGLRenderingContextBase::frontFace(GC3Denum mode)
2474 {
2475     if (isContextLostOrPending())
2476         return;
2477     m_context-&gt;frontFace(mode);
2478 }
2479 
2480 void WebGLRenderingContextBase::generateMipmap(GC3Denum target)
2481 {
2482     if (isContextLostOrPending())
2483         return;
2484     auto tex = validateTextureBinding(&quot;generateMipmap&quot;, target, false);
2485     if (!tex)
2486         return;
2487     if (!tex-&gt;canGenerateMipmaps()) {
2488         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;generateMipmap&quot;, &quot;level 0 not power of 2 or not all the same size&quot;);
2489         return;
2490     }
2491     // FIXME: https://bugs.webkit.org/show_bug.cgi?id=123916. Compressed textures should be allowed in WebGL 2:
2492     if (tex-&gt;isCompressed()) {
2493         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;generateMipmap&quot;, &quot;trying to generate mipmaps from compressed texture&quot;);
2494         return;
2495     }
2496     if (!validateSettableTexInternalFormat(&quot;generateMipmap&quot;, tex-&gt;getInternalFormat(target, 0)))
2497         return;
2498 
2499     // generateMipmap won&#39;t work properly if minFilter is not NEAREST_MIPMAP_LINEAR
2500     // on Mac.  Remove the hack once this driver bug is fixed.
2501 #if OS(DARWIN)
2502     bool needToResetMinFilter = false;
2503     if (tex-&gt;getMinFilter() != GraphicsContext3D::NEAREST_MIPMAP_LINEAR) {
2504         m_context-&gt;texParameteri(target, GraphicsContext3D::TEXTURE_MIN_FILTER, GraphicsContext3D::NEAREST_MIPMAP_LINEAR);
2505         needToResetMinFilter = true;
2506     }
2507 #endif
2508     m_context-&gt;generateMipmap(target);
2509 #if OS(DARWIN)
2510     if (needToResetMinFilter)
2511         m_context-&gt;texParameteri(target, GraphicsContext3D::TEXTURE_MIN_FILTER, tex-&gt;getMinFilter());
2512 #endif
2513     tex-&gt;generateMipmapLevelInfo();
2514 }
2515 
2516 RefPtr&lt;WebGLActiveInfo&gt; WebGLRenderingContextBase::getActiveAttrib(WebGLProgram* program, GC3Duint index)
2517 {
2518     if (isContextLostOrPending() || !validateWebGLObject(&quot;getActiveAttrib&quot;, program))
2519         return nullptr;
2520     ActiveInfo info;
2521     if (!m_context-&gt;getActiveAttrib(objectOrZero(program), index, info))
2522         return nullptr;
2523 
2524     LOG(WebGL, &quot;Returning active attribute %d: %s&quot;, index, info.name.utf8().data());
2525 
2526     return WebGLActiveInfo::create(info.name, info.type, info.size);
2527 }
2528 
2529 RefPtr&lt;WebGLActiveInfo&gt; WebGLRenderingContextBase::getActiveUniform(WebGLProgram* program, GC3Duint index)
2530 {
2531     if (isContextLostOrPending() || !validateWebGLObject(&quot;getActiveUniform&quot;, program))
2532         return nullptr;
2533     ActiveInfo info;
2534     if (!m_context-&gt;getActiveUniform(objectOrZero(program), index, info))
2535         return nullptr;
2536     if (!isGLES2Compliant())
2537         if (info.size &gt; 1 &amp;&amp; !info.name.endsWith(&quot;[0]&quot;))
2538             info.name.append(&quot;[0]&quot;);
2539 
2540     LOG(WebGL, &quot;Returning active uniform %d: %s&quot;, index, info.name.utf8().data());
2541 
2542     return WebGLActiveInfo::create(info.name, info.type, info.size);
2543 }
2544 
2545 Optional&lt;Vector&lt;RefPtr&lt;WebGLShader&gt;&gt;&gt; WebGLRenderingContextBase::getAttachedShaders(WebGLProgram* program)
2546 {
2547     if (isContextLostOrPending() || !validateWebGLObject(&quot;getAttachedShaders&quot;, program))
2548         return WTF::nullopt;
2549 
2550     const GC3Denum shaderTypes[] = {
2551         GraphicsContext3D::VERTEX_SHADER,
2552         GraphicsContext3D::FRAGMENT_SHADER
2553     };
2554     Vector&lt;RefPtr&lt;WebGLShader&gt;&gt; shaderObjects;
2555     for (auto shaderType : shaderTypes) {
2556         RefPtr&lt;WebGLShader&gt; shader = program-&gt;getAttachedShader(shaderType);
2557         if (shader)
2558             shaderObjects.append(shader);
2559     }
2560     return shaderObjects;
2561 }
2562 
2563 GC3Dint WebGLRenderingContextBase::getAttribLocation(WebGLProgram* program, const String&amp; name)
2564 {
2565     if (isContextLostOrPending() || !validateWebGLObject(&quot;getAttribLocation&quot;, program))
2566         return -1;
2567     if (!validateLocationLength(&quot;getAttribLocation&quot;, name))
2568         return -1;
2569     if (!validateString(&quot;getAttribLocation&quot;, name))
2570         return -1;
2571     if (isPrefixReserved(name))
2572         return -1;
2573     if (!program-&gt;getLinkStatus()) {
2574         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;getAttribLocation&quot;, &quot;program not linked&quot;);
2575         return -1;
2576     }
2577     return m_context-&gt;getAttribLocation(objectOrZero(program), name);
2578 }
2579 
2580 WebGLAny WebGLRenderingContextBase::getBufferParameter(GC3Denum target, GC3Denum pname)
2581 {
2582     if (isContextLostOrPending())
2583         return nullptr;
2584 
2585     bool valid = false;
2586     if (target == GraphicsContext3D::ARRAY_BUFFER || target == GraphicsContext3D::ELEMENT_ARRAY_BUFFER)
2587         valid = true;
2588 #if ENABLE(WEBGL2)
2589     if (isWebGL2()) {
2590         switch (target) {
2591         case GraphicsContext3D::COPY_READ_BUFFER:
2592         case GraphicsContext3D::COPY_WRITE_BUFFER:
2593         case GraphicsContext3D::PIXEL_PACK_BUFFER:
2594         case GraphicsContext3D::PIXEL_UNPACK_BUFFER:
2595         case GraphicsContext3D::TRANSFORM_FEEDBACK_BUFFER:
2596         case GraphicsContext3D::UNIFORM_BUFFER:
2597             valid = true;
2598         }
2599     }
2600 #endif
2601     if (!valid) {
2602         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;getBufferParameter&quot;, &quot;invalid target&quot;);
2603         return nullptr;
2604     }
2605 
2606     if (pname != GraphicsContext3D::BUFFER_SIZE &amp;&amp; pname != GraphicsContext3D::BUFFER_USAGE) {
2607         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;getBufferParameter&quot;, &quot;invalid parameter name&quot;);
2608         return nullptr;
2609     }
2610 
2611     GC3Dint value = 0;
2612     m_context-&gt;getBufferParameteriv(target, pname, &amp;value);
2613     if (pname == GraphicsContext3D::BUFFER_SIZE)
2614         return value;
2615     return static_cast&lt;unsigned&gt;(value);
2616 }
2617 
2618 Optional&lt;WebGLContextAttributes&gt; WebGLRenderingContextBase::getContextAttributes()
2619 {
2620     if (isContextLostOrPending())
2621         return WTF::nullopt;
2622 
2623     // Also, we need to enforce requested values of &quot;false&quot; for depth
2624     // and stencil, regardless of the properties of the underlying
2625     // GraphicsContext3D.
2626 
2627     auto attributes = m_context-&gt;getContextAttributes();
2628     if (!m_attributes.depth)
2629         attributes.depth = false;
2630     if (!m_attributes.stencil)
2631         attributes.stencil = false;
<a name="21" id="anc21"></a><span class="line-modified">2632     return WTFMove(attributes);</span>
2633 }
2634 
2635 GC3Denum WebGLRenderingContextBase::getError()
2636 {
2637     if (m_isPendingPolicyResolution)
2638         return GraphicsContext3D::NO_ERROR;
2639     return m_context-&gt;getError();
2640 }
2641 
2642 WebGLAny WebGLRenderingContextBase::getProgramParameter(WebGLProgram* program, GC3Denum pname)
2643 {
2644     if (isContextLostOrPending() || !validateWebGLObject(&quot;getProgramParameter&quot;, program))
2645         return nullptr;
2646 
2647     GC3Dint value = 0;
2648     switch (pname) {
2649     case GraphicsContext3D::DELETE_STATUS:
2650         return program-&gt;isDeleted();
2651     case GraphicsContext3D::VALIDATE_STATUS:
2652         m_context-&gt;getProgramiv(objectOrZero(program), pname, &amp;value);
2653         return static_cast&lt;bool&gt;(value);
2654     case GraphicsContext3D::LINK_STATUS:
2655         return program-&gt;getLinkStatus();
2656     case GraphicsContext3D::ATTACHED_SHADERS:
2657         m_context-&gt;getProgramiv(objectOrZero(program), pname, &amp;value);
2658         return value;
2659     case GraphicsContext3D::ACTIVE_ATTRIBUTES:
2660     case GraphicsContext3D::ACTIVE_UNIFORMS:
<a name="22" id="anc22"></a>


2661         m_context-&gt;getNonBuiltInActiveSymbolCount(objectOrZero(program), pname, &amp;value);
<a name="23" id="anc23"></a>
2662         return value;
2663     default:
2664         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;getProgramParameter&quot;, &quot;invalid parameter name&quot;);
2665         return nullptr;
2666     }
2667 }
2668 
2669 String WebGLRenderingContextBase::getProgramInfoLog(WebGLProgram* program)
2670 {
2671     if (isContextLostOrPending() || !validateWebGLObject(&quot;getProgramInfoLog&quot;, program))
2672         return String();
2673     return ensureNotNull(m_context-&gt;getProgramInfoLog(objectOrZero(program)));
2674 }
2675 
2676 WebGLAny WebGLRenderingContextBase::getRenderbufferParameter(GC3Denum target, GC3Denum pname)
2677 {
2678     if (isContextLostOrPending())
2679         return nullptr;
2680     if (target != GraphicsContext3D::RENDERBUFFER) {
2681         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;getRenderbufferParameter&quot;, &quot;invalid target&quot;);
2682         return nullptr;
2683     }
2684     if (!m_renderbufferBinding || !m_renderbufferBinding-&gt;object()) {
2685         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;getRenderbufferParameter&quot;, &quot;no renderbuffer bound&quot;);
2686         return nullptr;
2687     }
2688 
2689     if (m_renderbufferBinding-&gt;getInternalFormat() == GraphicsContext3D::DEPTH_STENCIL
2690         &amp;&amp; !m_renderbufferBinding-&gt;isValid()) {
2691         ASSERT(!isDepthStencilSupported());
2692         int value = 0;
2693         switch (pname) {
2694         case GraphicsContext3D::RENDERBUFFER_WIDTH:
2695             value = m_renderbufferBinding-&gt;getWidth();
2696             break;
2697         case GraphicsContext3D::RENDERBUFFER_HEIGHT:
2698             value = m_renderbufferBinding-&gt;getHeight();
2699             break;
2700         case GraphicsContext3D::RENDERBUFFER_RED_SIZE:
2701         case GraphicsContext3D::RENDERBUFFER_GREEN_SIZE:
2702         case GraphicsContext3D::RENDERBUFFER_BLUE_SIZE:
2703         case GraphicsContext3D::RENDERBUFFER_ALPHA_SIZE:
2704             value = 0;
2705             break;
2706         case GraphicsContext3D::RENDERBUFFER_DEPTH_SIZE:
2707             value = 24;
2708             break;
2709         case GraphicsContext3D::RENDERBUFFER_STENCIL_SIZE:
2710             value = 8;
2711             break;
2712         case GraphicsContext3D::RENDERBUFFER_INTERNAL_FORMAT:
2713             return m_renderbufferBinding-&gt;getInternalFormat();
2714         default:
2715             synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;getRenderbufferParameter&quot;, &quot;invalid parameter name&quot;);
2716             return nullptr;
2717         }
2718         return value;
2719     }
2720 
2721     GC3Dint value = 0;
2722     switch (pname) {
2723     case GraphicsContext3D::RENDERBUFFER_WIDTH:
2724     case GraphicsContext3D::RENDERBUFFER_HEIGHT:
2725     case GraphicsContext3D::RENDERBUFFER_RED_SIZE:
2726     case GraphicsContext3D::RENDERBUFFER_GREEN_SIZE:
2727     case GraphicsContext3D::RENDERBUFFER_BLUE_SIZE:
2728     case GraphicsContext3D::RENDERBUFFER_ALPHA_SIZE:
2729     case GraphicsContext3D::RENDERBUFFER_DEPTH_SIZE:
2730     case GraphicsContext3D::RENDERBUFFER_STENCIL_SIZE:
2731         m_context-&gt;getRenderbufferParameteriv(target, pname, &amp;value);
2732         return value;
2733     case GraphicsContext3D::RENDERBUFFER_INTERNAL_FORMAT:
2734         return m_renderbufferBinding-&gt;getInternalFormat();
2735     default:
2736         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;getRenderbufferParameter&quot;, &quot;invalid parameter name&quot;);
2737         return nullptr;
2738     }
2739 }
2740 
2741 WebGLAny WebGLRenderingContextBase::getShaderParameter(WebGLShader* shader, GC3Denum pname)
2742 {
2743     if (isContextLostOrPending() || !validateWebGLObject(&quot;getShaderParameter&quot;, shader))
2744         return nullptr;
2745     GC3Dint value = 0;
2746     switch (pname) {
2747     case GraphicsContext3D::DELETE_STATUS:
2748         return shader-&gt;isDeleted();
2749     case GraphicsContext3D::COMPILE_STATUS:
2750         m_context-&gt;getShaderiv(objectOrZero(shader), pname, &amp;value);
2751         return static_cast&lt;bool&gt;(value);
2752     case GraphicsContext3D::SHADER_TYPE:
2753         m_context-&gt;getShaderiv(objectOrZero(shader), pname, &amp;value);
2754         return static_cast&lt;unsigned&gt;(value);
2755     default:
2756         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;getShaderParameter&quot;, &quot;invalid parameter name&quot;);
2757         return nullptr;
2758     }
2759 }
2760 
2761 String WebGLRenderingContextBase::getShaderInfoLog(WebGLShader* shader)
2762 {
2763     if (isContextLostOrPending() || !validateWebGLObject(&quot;getShaderInfoLog&quot;, shader))
2764         return String();
2765     return ensureNotNull(m_context-&gt;getShaderInfoLog(objectOrZero(shader)));
2766 }
2767 
2768 RefPtr&lt;WebGLShaderPrecisionFormat&gt; WebGLRenderingContextBase::getShaderPrecisionFormat(GC3Denum shaderType, GC3Denum precisionType)
2769 {
2770     if (isContextLostOrPending())
2771         return nullptr;
2772     switch (shaderType) {
2773     case GraphicsContext3D::VERTEX_SHADER:
2774     case GraphicsContext3D::FRAGMENT_SHADER:
2775         break;
2776     default:
2777         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;getShaderPrecisionFormat&quot;, &quot;invalid shader type&quot;);
2778         return nullptr;
2779     }
2780     switch (precisionType) {
2781     case GraphicsContext3D::LOW_FLOAT:
2782     case GraphicsContext3D::MEDIUM_FLOAT:
2783     case GraphicsContext3D::HIGH_FLOAT:
2784     case GraphicsContext3D::LOW_INT:
2785     case GraphicsContext3D::MEDIUM_INT:
2786     case GraphicsContext3D::HIGH_INT:
2787         break;
2788     default:
2789         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;getShaderPrecisionFormat&quot;, &quot;invalid precision type&quot;);
2790         return nullptr;
2791     }
2792 
2793     GC3Dint range[2] = {0, 0};
2794     GC3Dint precision = 0;
2795     m_context-&gt;getShaderPrecisionFormat(shaderType, precisionType, range, &amp;precision);
2796     return WebGLShaderPrecisionFormat::create(range[0], range[1], precision);
2797 }
2798 
2799 String WebGLRenderingContextBase::getShaderSource(WebGLShader* shader)
2800 {
2801     if (isContextLostOrPending() || !validateWebGLObject(&quot;getShaderSource&quot;, shader))
2802         return String();
2803     return ensureNotNull(shader-&gt;getSource());
2804 }
2805 
2806 WebGLAny WebGLRenderingContextBase::getTexParameter(GC3Denum target, GC3Denum pname)
2807 {
2808     if (isContextLostOrPending())
2809         return nullptr;
2810     auto tex = validateTextureBinding(&quot;getTexParameter&quot;, target, false);
2811     if (!tex)
2812         return nullptr;
2813     GC3Dint value = 0;
2814     switch (pname) {
2815     case GraphicsContext3D::TEXTURE_MAG_FILTER:
2816     case GraphicsContext3D::TEXTURE_MIN_FILTER:
2817     case GraphicsContext3D::TEXTURE_WRAP_S:
2818     case GraphicsContext3D::TEXTURE_WRAP_T:
2819         m_context-&gt;getTexParameteriv(target, pname, &amp;value);
2820         return static_cast&lt;unsigned&gt;(value);
2821     case Extensions3D::TEXTURE_MAX_ANISOTROPY_EXT: // EXT_texture_filter_anisotropic
2822         if (m_extTextureFilterAnisotropic) {
2823             m_context-&gt;getTexParameteriv(target, pname, &amp;value);
2824             return static_cast&lt;unsigned&gt;(value);
2825         }
2826         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;getTexParameter&quot;, &quot;invalid parameter name, EXT_texture_filter_anisotropic not enabled&quot;);
2827         return nullptr;
2828     default:
2829         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;getTexParameter&quot;, &quot;invalid parameter name&quot;);
2830         return nullptr;
2831     }
2832 }
2833 
2834 WebGLAny WebGLRenderingContextBase::getUniform(WebGLProgram* program, const WebGLUniformLocation* uniformLocation)
2835 {
2836     if (isContextLostOrPending() || !validateWebGLObject(&quot;getUniform&quot;, program))
2837         return nullptr;
2838     if (!uniformLocation || uniformLocation-&gt;program() != program) {
2839         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;getUniform&quot;, &quot;no uniformlocation or not valid for this program&quot;);
2840         return nullptr;
2841     }
2842     GC3Dint location = uniformLocation-&gt;location();
2843 
2844     GC3Denum baseType;
2845     unsigned length;
2846     switch (uniformLocation-&gt;type()) {
2847     case GraphicsContext3D::BOOL:
2848         baseType = GraphicsContext3D::BOOL;
2849         length = 1;
2850         break;
2851     case GraphicsContext3D::BOOL_VEC2:
2852         baseType = GraphicsContext3D::BOOL;
2853         length = 2;
2854         break;
2855     case GraphicsContext3D::BOOL_VEC3:
2856         baseType = GraphicsContext3D::BOOL;
2857         length = 3;
2858         break;
2859     case GraphicsContext3D::BOOL_VEC4:
2860         baseType = GraphicsContext3D::BOOL;
2861         length = 4;
2862         break;
2863     case GraphicsContext3D::INT:
2864         baseType = GraphicsContext3D::INT;
2865         length = 1;
2866         break;
2867     case GraphicsContext3D::INT_VEC2:
2868         baseType = GraphicsContext3D::INT;
2869         length = 2;
2870         break;
2871     case GraphicsContext3D::INT_VEC3:
2872         baseType = GraphicsContext3D::INT;
2873         length = 3;
2874         break;
2875     case GraphicsContext3D::INT_VEC4:
2876         baseType = GraphicsContext3D::INT;
2877         length = 4;
2878         break;
2879     case GraphicsContext3D::FLOAT:
2880         baseType = GraphicsContext3D::FLOAT;
2881         length = 1;
2882         break;
2883     case GraphicsContext3D::FLOAT_VEC2:
2884         baseType = GraphicsContext3D::FLOAT;
2885         length = 2;
2886         break;
2887     case GraphicsContext3D::FLOAT_VEC3:
2888         baseType = GraphicsContext3D::FLOAT;
2889         length = 3;
2890         break;
2891     case GraphicsContext3D::FLOAT_VEC4:
2892         baseType = GraphicsContext3D::FLOAT;
2893         length = 4;
2894         break;
2895     case GraphicsContext3D::FLOAT_MAT2:
2896         baseType = GraphicsContext3D::FLOAT;
2897         length = 4;
2898         break;
2899     case GraphicsContext3D::FLOAT_MAT3:
2900         baseType = GraphicsContext3D::FLOAT;
2901         length = 9;
2902         break;
2903     case GraphicsContext3D::FLOAT_MAT4:
2904         baseType = GraphicsContext3D::FLOAT;
2905         length = 16;
2906         break;
2907     case GraphicsContext3D::SAMPLER_2D:
2908     case GraphicsContext3D::SAMPLER_CUBE:
2909         baseType = GraphicsContext3D::INT;
2910         length = 1;
2911         break;
2912     default:
2913         // Can&#39;t handle this type
2914         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;getUniform&quot;, &quot;unhandled type&quot;);
2915         return nullptr;
2916     }
2917     switch (baseType) {
2918     case GraphicsContext3D::FLOAT: {
2919         GC3Dfloat value[16] = {0};
2920         if (m_isRobustnessEXTSupported)
2921             m_context-&gt;getExtensions().getnUniformfvEXT(objectOrZero(program), location, 16 * sizeof(GC3Dfloat), value);
2922         else
2923             m_context-&gt;getUniformfv(objectOrZero(program), location, value);
2924         if (length == 1)
2925             return value[0];
2926         return Float32Array::tryCreate(value, length);
2927     }
2928     case GraphicsContext3D::INT: {
2929         GC3Dint value[4] = {0};
2930         if (m_isRobustnessEXTSupported)
2931             m_context-&gt;getExtensions().getnUniformivEXT(objectOrZero(program), location, 4 * sizeof(GC3Dint), value);
2932         else
2933             m_context-&gt;getUniformiv(objectOrZero(program), location, value);
2934         if (length == 1)
2935             return value[0];
2936         return Int32Array::tryCreate(value, length);
2937     }
2938     case GraphicsContext3D::BOOL: {
2939         GC3Dint value[4] = {0};
2940         if (m_isRobustnessEXTSupported)
2941             m_context-&gt;getExtensions().getnUniformivEXT(objectOrZero(program), location, 4 * sizeof(GC3Dint), value);
2942         else
2943             m_context-&gt;getUniformiv(objectOrZero(program), location, value);
2944         if (length &gt; 1) {
2945             Vector&lt;bool&gt; vector(length);
2946             for (unsigned j = 0; j &lt; length; j++)
2947                 vector[j] = value[j];
<a name="24" id="anc24"></a><span class="line-modified">2948             return WTFMove(vector);</span>
2949         }
2950         return static_cast&lt;bool&gt;(value[0]);
2951     }
2952     default:
2953         notImplemented();
2954     }
2955 
2956     // If we get here, something went wrong in our unfortunately complex logic above
2957     synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;getUniform&quot;, &quot;unknown error&quot;);
2958     return nullptr;
2959 }
2960 
2961 RefPtr&lt;WebGLUniformLocation&gt; WebGLRenderingContextBase::getUniformLocation(WebGLProgram* program, const String&amp; name)
2962 {
2963     if (isContextLostOrPending() || !validateWebGLObject(&quot;getUniformLocation&quot;, program))
2964         return nullptr;
2965     if (!validateLocationLength(&quot;getUniformLocation&quot;, name))
2966         return nullptr;
2967     if (!validateString(&quot;getUniformLocation&quot;, name))
2968         return nullptr;
2969     if (isPrefixReserved(name))
2970         return nullptr;
2971     if (!program-&gt;getLinkStatus()) {
2972         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;getUniformLocation&quot;, &quot;program not linked&quot;);
2973         return nullptr;
2974     }
2975     GC3Dint uniformLocation = m_context-&gt;getUniformLocation(objectOrZero(program), name);
2976     if (uniformLocation == -1)
2977         return nullptr;
2978 
2979     GC3Dint activeUniforms = 0;
<a name="25" id="anc25"></a>


2980     m_context-&gt;getNonBuiltInActiveSymbolCount(objectOrZero(program), GraphicsContext3D::ACTIVE_UNIFORMS, &amp;activeUniforms);
<a name="26" id="anc26"></a>
2981     for (GC3Dint i = 0; i &lt; activeUniforms; i++) {
2982         ActiveInfo info;
2983         if (!m_context-&gt;getActiveUniform(objectOrZero(program), i, info))
2984             return nullptr;
2985         // Strip &quot;[0]&quot; from the name if it&#39;s an array.
2986         if (info.name.endsWith(&quot;[0]&quot;))
2987             info.name = info.name.left(info.name.length() - 3);
2988         // If it&#39;s an array, we need to iterate through each element, appending &quot;[index]&quot; to the name.
2989         for (GC3Dint index = 0; index &lt; info.size; ++index) {
2990             String uniformName = makeString(info.name, &#39;[&#39;, index, &#39;]&#39;);
2991 
2992             if (name == uniformName || name == info.name)
2993                 return WebGLUniformLocation::create(program, uniformLocation, info.type);
2994         }
2995     }
2996     return nullptr;
2997 }
2998 
2999 WebGLAny WebGLRenderingContextBase::getVertexAttrib(GC3Duint index, GC3Denum pname)
3000 {
3001     if (isContextLostOrPending())
3002         return nullptr;
3003 
3004     if (index &gt;= m_maxVertexAttribs) {
3005         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;getVertexAttrib&quot;, &quot;index out of range&quot;);
3006         return nullptr;
3007     }
3008 
3009     const WebGLVertexArrayObjectBase::VertexAttribState&amp; state = m_boundVertexArrayObject-&gt;getVertexAttribState(index);
3010 
3011     if ((isWebGL2() || m_angleInstancedArrays) &amp;&amp; pname == GraphicsContext3D::VERTEX_ATTRIB_ARRAY_DIVISOR_ANGLE)
3012         return state.divisor;
3013 
3014     switch (pname) {
3015     case GraphicsContext3D::VERTEX_ATTRIB_ARRAY_BUFFER_BINDING:
3016         if ((!isGLES2Compliant() &amp;&amp; !index &amp;&amp; m_boundVertexArrayObject-&gt;getVertexAttribState(0).bufferBinding == m_vertexAttrib0Buffer)
3017             || !state.bufferBinding
3018             || !state.bufferBinding-&gt;object())
3019             return nullptr;
3020         return state.bufferBinding;
3021     case GraphicsContext3D::VERTEX_ATTRIB_ARRAY_ENABLED:
3022         return state.enabled;
3023     case GraphicsContext3D::VERTEX_ATTRIB_ARRAY_NORMALIZED:
3024         return state.normalized;
3025     case GraphicsContext3D::VERTEX_ATTRIB_ARRAY_SIZE:
3026         return state.size;
3027     case GraphicsContext3D::VERTEX_ATTRIB_ARRAY_STRIDE:
3028         return state.originalStride;
3029     case GraphicsContext3D::VERTEX_ATTRIB_ARRAY_TYPE:
3030         return state.type;
3031     case GraphicsContext3D::CURRENT_VERTEX_ATTRIB:
3032         return Float32Array::tryCreate(m_vertexAttribValue[index].value, 4);
3033     default:
3034         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;getVertexAttrib&quot;, &quot;invalid parameter name&quot;);
3035         return nullptr;
3036     }
3037 }
3038 
3039 long long WebGLRenderingContextBase::getVertexAttribOffset(GC3Duint index, GC3Denum pname)
3040 {
3041     if (isContextLostOrPending())
3042         return 0;
3043     return m_context-&gt;getVertexAttribOffset(index, pname);
3044 }
3045 
3046 bool WebGLRenderingContextBase::extensionIsEnabled(const String&amp; name)
3047 {
3048 #define CHECK_EXTENSION(variable, nameLiteral) \
3049     if (equalIgnoringASCIICase(name, nameLiteral)) \
3050         return variable != nullptr;
3051 
3052     CHECK_EXTENSION(m_extFragDepth, &quot;EXT_frag_depth&quot;);
3053     CHECK_EXTENSION(m_extBlendMinMax, &quot;EXT_blend_minmax&quot;);
3054     CHECK_EXTENSION(m_extsRGB, &quot;EXT_sRGB&quot;);
3055     CHECK_EXTENSION(m_extTextureFilterAnisotropic, &quot;EXT_texture_filter_anisotropic&quot;);
3056     CHECK_EXTENSION(m_extTextureFilterAnisotropic, &quot;WEBKIT_EXT_texture_filter_anisotropic&quot;);
3057     CHECK_EXTENSION(m_extShaderTextureLOD, &quot;EXT_shader_texture_lod&quot;);
3058     CHECK_EXTENSION(m_oesTextureFloat, &quot;OES_texture_float&quot;);
3059     CHECK_EXTENSION(m_oesTextureFloatLinear, &quot;OES_texture_float_linear&quot;);
3060     CHECK_EXTENSION(m_oesTextureHalfFloat, &quot;OES_texture_half_float&quot;);
3061     CHECK_EXTENSION(m_oesTextureHalfFloatLinear, &quot;OES_texture_half_float_linear&quot;);
3062     CHECK_EXTENSION(m_oesStandardDerivatives, &quot;OES_standard_derivatives&quot;);
3063     CHECK_EXTENSION(m_oesVertexArrayObject, &quot;OES_vertex_array_object&quot;);
3064     CHECK_EXTENSION(m_oesElementIndexUint, &quot;OES_element_index_uint&quot;);
3065     CHECK_EXTENSION(m_webglLoseContext, &quot;WEBGL_lose_context&quot;);
3066     CHECK_EXTENSION(m_webglDebugRendererInfo, &quot;WEBGL_debug_renderer_info&quot;);
3067     CHECK_EXTENSION(m_webglDebugShaders, &quot;WEBGL_debug_shaders&quot;);
3068     CHECK_EXTENSION(m_webglCompressedTextureATC, &quot;WEBKIT_WEBGL_compressed_texture_atc&quot;);
3069     CHECK_EXTENSION(m_webglCompressedTexturePVRTC, &quot;WEBKIT_WEBGL_compressed_texture_pvrtc&quot;);
3070     CHECK_EXTENSION(m_webglCompressedTextureS3TC, &quot;WEBGL_compressed_texture_s3tc&quot;);
3071     CHECK_EXTENSION(m_webglDepthTexture, &quot;WEBGL_depth_texture&quot;);
3072     CHECK_EXTENSION(m_webglDrawBuffers, &quot;WEBGL_draw_buffers&quot;);
3073     CHECK_EXTENSION(m_angleInstancedArrays, &quot;ANGLE_instanced_arrays&quot;);
3074     return false;
3075 }
3076 
3077 GC3Dboolean WebGLRenderingContextBase::isBuffer(WebGLBuffer* buffer)
3078 {
3079     if (!buffer || isContextLostOrPending())
3080         return 0;
3081 
3082     if (!buffer-&gt;hasEverBeenBound())
3083         return 0;
3084 
3085     return m_context-&gt;isBuffer(buffer-&gt;object());
3086 }
3087 
3088 bool WebGLRenderingContextBase::isContextLost() const
3089 {
3090     return m_contextLost;
3091 }
3092 
3093 bool WebGLRenderingContextBase::isContextLostOrPending()
3094 {
3095     if (m_isPendingPolicyResolution &amp;&amp; !m_hasRequestedPolicyResolution) {
3096         LOG(WebGL, &quot;Context is being used. Attempt to resolve the policy.&quot;);
3097         auto* canvas = htmlCanvas();
3098         if (canvas) {
3099             Document&amp; document = canvas-&gt;document().topDocument();
3100             Page* page = document.page();
3101             if (page &amp;&amp; !document.url().isLocalFile())
3102                 page-&gt;mainFrame().loader().client().resolveWebGLPolicyForURL(document.url());
3103             // FIXME: We don&#39;t currently do anything with the result from resolution. A more
3104             // complete implementation might try to construct a real context, etc and proceed
3105             // with normal operation.
3106             // https://bugs.webkit.org/show_bug.cgi?id=129122
3107         }
3108         m_hasRequestedPolicyResolution = true;
3109     }
3110 
3111     return m_contextLost || m_isPendingPolicyResolution;
3112 }
3113 
3114 GC3Dboolean WebGLRenderingContextBase::isEnabled(GC3Denum cap)
3115 {
3116     if (isContextLostOrPending() || !validateCapability(&quot;isEnabled&quot;, cap))
3117         return 0;
3118     if (cap == GraphicsContext3D::STENCIL_TEST)
3119         return m_stencilEnabled;
3120     return m_context-&gt;isEnabled(cap);
3121 }
3122 
3123 GC3Dboolean WebGLRenderingContextBase::isFramebuffer(WebGLFramebuffer* framebuffer)
3124 {
3125     if (!framebuffer || isContextLostOrPending())
3126         return 0;
3127 
3128     if (!framebuffer-&gt;hasEverBeenBound())
3129         return 0;
3130 
3131     return m_context-&gt;isFramebuffer(framebuffer-&gt;object());
3132 }
3133 
3134 GC3Dboolean WebGLRenderingContextBase::isProgram(WebGLProgram* program)
3135 {
3136     if (!program || isContextLostOrPending())
3137         return 0;
3138 
3139     return m_context-&gt;isProgram(program-&gt;object());
3140 }
3141 
3142 GC3Dboolean WebGLRenderingContextBase::isRenderbuffer(WebGLRenderbuffer* renderbuffer)
3143 {
3144     if (!renderbuffer || isContextLostOrPending())
3145         return 0;
3146 
3147     if (!renderbuffer-&gt;hasEverBeenBound())
3148         return 0;
3149 
3150     return m_context-&gt;isRenderbuffer(renderbuffer-&gt;object());
3151 }
3152 
3153 GC3Dboolean WebGLRenderingContextBase::isShader(WebGLShader* shader)
3154 {
3155     if (!shader || isContextLostOrPending())
3156         return 0;
3157 
3158     return m_context-&gt;isShader(shader-&gt;object());
3159 }
3160 
3161 GC3Dboolean WebGLRenderingContextBase::isTexture(WebGLTexture* texture)
3162 {
3163     if (!texture || isContextLostOrPending())
3164         return 0;
3165 
3166     if (!texture-&gt;hasEverBeenBound())
3167         return 0;
3168 
3169     return m_context-&gt;isTexture(texture-&gt;object());
3170 }
3171 
3172 void WebGLRenderingContextBase::lineWidth(GC3Dfloat width)
3173 {
3174     if (isContextLostOrPending())
3175         return;
3176     m_context-&gt;lineWidth(width);
3177 }
3178 
3179 void WebGLRenderingContextBase::linkProgram(WebGLProgram* program)
3180 {
3181     if (!linkProgramWithoutInvalidatingAttribLocations(program))
3182         return;
3183 
3184     program-&gt;increaseLinkCount();
3185 }
3186 
3187 bool WebGLRenderingContextBase::linkProgramWithoutInvalidatingAttribLocations(WebGLProgram* program)
3188 {
3189     if (isContextLostOrPending() || !validateWebGLObject(&quot;linkProgram&quot;, program))
3190         return false;
3191 
3192     RefPtr&lt;WebGLShader&gt; vertexShader = program-&gt;getAttachedShader(GraphicsContext3D::VERTEX_SHADER);
3193     RefPtr&lt;WebGLShader&gt; fragmentShader = program-&gt;getAttachedShader(GraphicsContext3D::FRAGMENT_SHADER);
<a name="27" id="anc27"></a><span class="line-modified">3194     if (!vertexShader || !vertexShader-&gt;isValid() || !fragmentShader || !fragmentShader-&gt;isValid() || !m_context-&gt;precisionsMatch(objectOrZero(vertexShader.get()), objectOrZero(fragmentShader.get())) || !m_context-&gt;checkVaryingsPacking(objectOrZero(vertexShader.get()), objectOrZero(fragmentShader.get()))) {</span>
3195         program-&gt;setLinkStatus(false);
3196         return false;
3197     }
3198 
<a name="28" id="anc28"></a>







3199     m_context-&gt;linkProgram(objectOrZero(program));
3200     return true;
3201 }
3202 
3203 void WebGLRenderingContextBase::pixelStorei(GC3Denum pname, GC3Dint param)
3204 {
3205     if (isContextLostOrPending())
3206         return;
3207     switch (pname) {
3208     case GraphicsContext3D::UNPACK_FLIP_Y_WEBGL:
3209         m_unpackFlipY = param;
3210         break;
3211     case GraphicsContext3D::UNPACK_PREMULTIPLY_ALPHA_WEBGL:
3212         m_unpackPremultiplyAlpha = param;
3213         break;
3214     case GraphicsContext3D::UNPACK_COLORSPACE_CONVERSION_WEBGL:
3215         if (param == GraphicsContext3D::BROWSER_DEFAULT_WEBGL || param == GraphicsContext3D::NONE)
3216             m_unpackColorspaceConversion = static_cast&lt;GC3Denum&gt;(param);
3217         else {
3218             synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;pixelStorei&quot;, &quot;invalid parameter for UNPACK_COLORSPACE_CONVERSION_WEBGL&quot;);
3219             return;
3220         }
3221         break;
3222     case GraphicsContext3D::PACK_ALIGNMENT:
3223     case GraphicsContext3D::UNPACK_ALIGNMENT:
3224         if (param == 1 || param == 2 || param == 4 || param == 8) {
3225             if (pname == GraphicsContext3D::PACK_ALIGNMENT)
3226                 m_packAlignment = param;
3227             else // GraphicsContext3D::UNPACK_ALIGNMENT:
3228                 m_unpackAlignment = param;
3229             m_context-&gt;pixelStorei(pname, param);
3230         } else {
3231             synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;pixelStorei&quot;, &quot;invalid parameter for alignment&quot;);
3232             return;
3233         }
3234         break;
3235     default:
3236         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;pixelStorei&quot;, &quot;invalid parameter name&quot;);
3237         return;
3238     }
3239 }
3240 
3241 void WebGLRenderingContextBase::polygonOffset(GC3Dfloat factor, GC3Dfloat units)
3242 {
3243     if (isContextLostOrPending())
3244         return;
3245     m_context-&gt;polygonOffset(factor, units);
3246 }
3247 
3248 enum class InternalFormatTheme {
3249     None,
3250     NormalizedFixedPoint,
3251     Packed,
3252     SignedNormalizedFixedPoint,
3253     FloatingPoint,
3254     SignedInteger,
3255     UnsignedInteger
3256 };
3257 
3258 static InternalFormatTheme internalFormatTheme(GC3Denum internalFormat)
3259 {
3260     switch (internalFormat) {
3261     case GraphicsContext3D::RGB:
3262     case GraphicsContext3D::RGBA:
3263     case GraphicsContext3D::LUMINANCE_ALPHA:
3264     case GraphicsContext3D::LUMINANCE:
3265     case GraphicsContext3D::ALPHA:
3266     case GraphicsContext3D::R8:
3267     case GraphicsContext3D::RG8:
3268     case GraphicsContext3D::RGB8:
3269     case GraphicsContext3D::SRGB8:
3270     case GraphicsContext3D::RGBA8:
3271     case GraphicsContext3D::SRGB8_ALPHA8:
3272     case GraphicsContext3D::SRGB_ALPHA:
3273         return InternalFormatTheme::NormalizedFixedPoint;
3274     case GraphicsContext3D::RGB565:
3275     case GraphicsContext3D::RGB5_A1:
3276     case GraphicsContext3D::RGBA4:
3277     case GraphicsContext3D::RGB9_E5:
3278     case GraphicsContext3D::RGB10_A2:
3279     case GraphicsContext3D::R11F_G11F_B10F:
3280     case GraphicsContext3D::RGB10_A2UI:
3281         return InternalFormatTheme::Packed;
3282     case GraphicsContext3D::R8_SNORM:
3283     case GraphicsContext3D::RG8_SNORM:
3284     case GraphicsContext3D::RGB8_SNORM:
3285     case GraphicsContext3D::RGBA8_SNORM:
3286         return InternalFormatTheme::SignedNormalizedFixedPoint;
3287     case GraphicsContext3D::R16F:
3288     case GraphicsContext3D::R32F:
3289     case GraphicsContext3D::RG16F:
3290     case GraphicsContext3D::RG32F:
3291     case GraphicsContext3D::RGB16F:
3292     case GraphicsContext3D::RGB32F:
3293     case GraphicsContext3D::RGBA16F:
3294     case GraphicsContext3D::RGBA32F:
3295         return InternalFormatTheme::FloatingPoint;
3296     case GraphicsContext3D::R8I:
3297     case GraphicsContext3D::R16I:
3298     case GraphicsContext3D::R32I:
3299     case GraphicsContext3D::RG8I:
3300     case GraphicsContext3D::RG16I:
3301     case GraphicsContext3D::RG32I:
3302     case GraphicsContext3D::RGB8I:
3303     case GraphicsContext3D::RGB16I:
3304     case GraphicsContext3D::RGB32I:
3305     case GraphicsContext3D::RGBA8I:
3306     case GraphicsContext3D::RGBA16I:
3307     case GraphicsContext3D::RGBA32I:
3308         return InternalFormatTheme::SignedInteger;
3309     case GraphicsContext3D::R8UI:
3310     case GraphicsContext3D::R16UI:
3311     case GraphicsContext3D::R32UI:
3312     case GraphicsContext3D::RG8UI:
3313     case GraphicsContext3D::RG16UI:
3314     case GraphicsContext3D::RG32UI:
3315     case GraphicsContext3D::RGB8UI:
3316     case GraphicsContext3D::RGB16UI:
3317     case GraphicsContext3D::RGB32UI:
3318     case GraphicsContext3D::RGBA8UI:
3319     case GraphicsContext3D::RGBA16UI:
3320     case GraphicsContext3D::RGBA32UI:
3321         return InternalFormatTheme::UnsignedInteger;
3322     default:
3323         return InternalFormatTheme::None;
3324     }
3325 }
3326 
3327 static int numberOfComponentsForFormat(GC3Denum format)
3328 {
3329     switch (format) {
3330     case GraphicsContext3D::RED:
3331     case GraphicsContext3D::RED_INTEGER:
3332         return 1;
3333     case GraphicsContext3D::RG:
3334     case GraphicsContext3D::RG_INTEGER:
3335         return 2;
3336     case GraphicsContext3D::RGB:
3337     case GraphicsContext3D::RGB_INTEGER:
3338         return 3;
3339     case GraphicsContext3D::RGBA:
3340     case GraphicsContext3D::RGBA_INTEGER:
3341         return 4;
3342     default:
3343         return 0;
3344     }
3345 }
3346 
3347 static int numberOfComponentsForInternalFormat(GC3Denum internalFormat)
3348 {
3349     switch (internalFormat) {
3350     case GraphicsContext3D::LUMINANCE:
3351     case GraphicsContext3D::ALPHA:
3352     case GraphicsContext3D::R8:
3353     case GraphicsContext3D::R8_SNORM:
3354     case GraphicsContext3D::R16F:
3355     case GraphicsContext3D::R32F:
3356     case GraphicsContext3D::R8UI:
3357     case GraphicsContext3D::R8I:
3358     case GraphicsContext3D::R16UI:
3359     case GraphicsContext3D::R16I:
3360     case GraphicsContext3D::R32UI:
3361     case GraphicsContext3D::R32I:
3362     case GraphicsContext3D::DEPTH_COMPONENT16:
3363     case GraphicsContext3D::DEPTH_COMPONENT24:
3364     case GraphicsContext3D::DEPTH_COMPONENT32F:
3365         return 1;
3366     case GraphicsContext3D::RG8:
3367     case GraphicsContext3D::LUMINANCE_ALPHA:
3368     case GraphicsContext3D::RG8_SNORM:
3369     case GraphicsContext3D::RG16F:
3370     case GraphicsContext3D::RG32F:
3371     case GraphicsContext3D::RG8UI:
3372     case GraphicsContext3D::RG8I:
3373     case GraphicsContext3D::RG16UI:
3374     case GraphicsContext3D::RG16I:
3375     case GraphicsContext3D::RG32UI:
3376     case GraphicsContext3D::RG32I:
3377     case GraphicsContext3D::DEPTH24_STENCIL8:
3378     case GraphicsContext3D::DEPTH32F_STENCIL8:
3379         return 2;
3380     case GraphicsContext3D::RGB:
3381     case GraphicsContext3D::RGB8:
3382     case GraphicsContext3D::SRGB8:
3383     case GraphicsContext3D::RGB565:
3384     case GraphicsContext3D::RGB8_SNORM:
3385     case GraphicsContext3D::R11F_G11F_B10F:
3386     case GraphicsContext3D::RGB9_E5:
3387     case GraphicsContext3D::RGB16F:
3388     case GraphicsContext3D::RGB32F:
3389     case GraphicsContext3D::RGB8UI:
3390     case GraphicsContext3D::RGB8I:
3391     case GraphicsContext3D::RGB16UI:
3392     case GraphicsContext3D::RGB16I:
3393     case GraphicsContext3D::RGB32UI:
3394     case GraphicsContext3D::RGB32I:
3395         return 3;
3396     case GraphicsContext3D::RGBA:
3397     case GraphicsContext3D::RGBA8:
3398     case GraphicsContext3D::SRGB_ALPHA:
3399     case GraphicsContext3D::SRGB8_ALPHA8:
3400     case GraphicsContext3D::RGBA8_SNORM:
3401     case GraphicsContext3D::RGB5_A1:
3402     case GraphicsContext3D::RGBA4:
3403     case GraphicsContext3D::RGB10_A2:
3404     case GraphicsContext3D::RGBA16F:
3405     case GraphicsContext3D::RGBA32F:
3406     case GraphicsContext3D::RGBA8UI:
3407     case GraphicsContext3D::RGBA8I:
3408     case GraphicsContext3D::RGB10_A2UI:
3409     case GraphicsContext3D::RGBA16UI:
3410     case GraphicsContext3D::RGBA16I:
3411     case GraphicsContext3D::RGBA32UI:
3412     case GraphicsContext3D::RGBA32I:
3413         return 4;
3414     default:
3415         return 0;
3416     }
3417 }
3418 
3419 void WebGLRenderingContextBase::readPixels(GC3Dint x, GC3Dint y, GC3Dsizei width, GC3Dsizei height, GC3Denum format, GC3Denum type, ArrayBufferView&amp; pixels)
3420 {
3421     if (isContextLostOrPending())
3422         return;
3423     // Due to WebGL&#39;s same-origin restrictions, it is not possible to
3424     // taint the origin using the WebGL API.
3425     ASSERT(canvasBase().originClean());
3426 
3427     GC3Denum internalFormat = 0;
3428     if (m_framebufferBinding) {
3429         const char* reason = &quot;framebuffer incomplete&quot;;
3430         if (!m_framebufferBinding-&gt;onAccess(graphicsContext3D(), &amp;reason)) {
3431             synthesizeGLError(GraphicsContext3D::INVALID_FRAMEBUFFER_OPERATION, &quot;readPixels&quot;, reason);
3432             return;
3433         }
3434         // FIXME: readBuffer() should affect this
3435         internalFormat = m_framebufferBinding-&gt;getColorBufferFormat();
3436     } else {
3437         if (m_attributes.alpha)
<a name="29" id="anc29"></a><span class="line-removed">3438             internalFormat = GraphicsContext3D::RGB8;</span>
<span class="line-removed">3439         else</span>
3440             internalFormat = GraphicsContext3D::RGBA8;
<a name="30" id="anc30"></a>

3441     }
3442 
3443     if (!internalFormat) {
3444         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;readPixels&quot;, &quot;Incorrect internal format&quot;);
3445         return;
3446     }
3447 
3448     if (isWebGL1()) {
3449         switch (format) {
3450         case GraphicsContext3D::ALPHA:
3451         case GraphicsContext3D::RGB:
3452         case GraphicsContext3D::RGBA:
3453             break;
3454         default:
3455             synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;readPixels&quot;, &quot;invalid format&quot;);
3456             return;
3457         }
3458         switch (type) {
3459         case GraphicsContext3D::UNSIGNED_BYTE:
3460         case GraphicsContext3D::UNSIGNED_SHORT_5_6_5:
3461         case GraphicsContext3D::UNSIGNED_SHORT_4_4_4_4:
3462         case GraphicsContext3D::UNSIGNED_SHORT_5_5_5_1:
3463             break;
<a name="31" id="anc31"></a>





3464         default:
3465             synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;readPixels&quot;, &quot;invalid type&quot;);
3466             return;
3467         }
<a name="32" id="anc32"></a><span class="line-modified">3468         if (format != GraphicsContext3D::RGBA || type != GraphicsContext3D::UNSIGNED_BYTE) {</span>
<span class="line-modified">3469             synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;readPixels&quot;, &quot;format not RGBA or type not UNSIGNED_BYTE&quot;);</span>
3470             return;
3471         }
3472     }
3473 
3474     InternalFormatTheme internalFormatTheme = WebCore::internalFormatTheme(internalFormat);
3475     int internalFormatComponentCount = numberOfComponentsForInternalFormat(internalFormat);
3476     if (internalFormatTheme == InternalFormatTheme::None || !internalFormatComponentCount) {
3477         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;readPixels&quot;, &quot;Incorrect internal format&quot;);
3478         return;
3479     }
3480 
<a name="33" id="anc33"></a><span class="line-modified">3481 #define INTERNAL_FORMAT_CHECK(themeMacro, typeMacro, pixelTypeMacro) case InternalFormatTheme::themeMacro: \</span>
<span class="line-modified">3482         if (type != GraphicsContext3D::typeMacro || pixels.getType() != JSC::pixelTypeMacro) { \</span>
<span class="line-modified">3483             synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;readPixels&quot;, &quot;type does not match internal format&quot;); \</span>
<span class="line-modified">3484             return; \</span>
<span class="line-modified">3485         } \</span>
<span class="line-removed">3486         if (format != GraphicsContext3D::RED &amp;&amp; format != GraphicsContext3D::RG &amp;&amp; format != GraphicsContext3D::RGB &amp;&amp; format != GraphicsContext3D::RGBA) { \</span>
<span class="line-removed">3487             synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;readPixels&quot;, &quot;Unknown format&quot;); \</span>
<span class="line-removed">3488             return; \</span>
<span class="line-removed">3489         } \</span>
<span class="line-removed">3490         if (numberOfComponentsForFormat(format) &lt; internalFormatComponentCount) { \</span>
<span class="line-removed">3491             synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;readPixels&quot;, &quot;Not enough components in format&quot;); \</span>
<span class="line-removed">3492             return; \</span>
<span class="line-removed">3493         } \</span>
<span class="line-removed">3494         break;</span>
3495 
<a name="34" id="anc34"></a><span class="line-modified">3496 #define INTERNAL_FORMAT_INTEGER_CHECK(themeMacro, typeMacro, pixelTypeMacro) case InternalFormatTheme::themeMacro: \</span>
<span class="line-modified">3497         if (type != GraphicsContext3D::typeMacro || pixels.getType() != JSC::pixelTypeMacro) { \</span>
<span class="line-modified">3498             synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;readPixels&quot;, &quot;type does not match internal format&quot;); \</span>
<span class="line-modified">3499             return; \</span>
<span class="line-modified">3500         } \</span>
<span class="line-modified">3501         if (format != GraphicsContext3D::RED_INTEGER &amp;&amp; format != GraphicsContext3D::RG_INTEGER &amp;&amp; format != GraphicsContext3D::RGB_INTEGER &amp;&amp; format != GraphicsContext3D::RGBA_INTEGER) { \</span>
<span class="line-modified">3502             synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;readPixels&quot;, &quot;Unknown format&quot;); \</span>
<span class="line-modified">3503             return; \</span>
<span class="line-modified">3504         } \</span>
<span class="line-modified">3505         if (numberOfComponentsForFormat(format) &lt; internalFormatComponentCount) { \</span>
<span class="line-removed">3506             synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;readPixels&quot;, &quot;Not enough components in format&quot;); \</span>
<span class="line-removed">3507             return; \</span>
<span class="line-removed">3508         } \</span>
<span class="line-removed">3509         break;</span>
3510 
<a name="35" id="anc35"></a><span class="line-modified">3511 #define PACKED_INTERNAL_FORMAT_CHECK(internalFormatMacro, formatMacro, type0Macro, pixelType0Macro, type1Macro, pixelType1Macro) case GraphicsContext3D::internalFormatMacro: \</span>
<span class="line-modified">3512         if (!(type == GraphicsContext3D::type0Macro &amp;&amp; pixels.getType() == JSC::pixelType0Macro) \</span>
<span class="line-modified">3513             &amp;&amp; !(type == GraphicsContext3D::type1Macro &amp;&amp; pixels.getType() == JSC::pixelType1Macro)) { \</span>
<span class="line-modified">3514             synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;readPixels&quot;, &quot;type does not match internal format&quot;); \</span>
<span class="line-modified">3515             return; \</span>
<span class="line-modified">3516         } \</span>
<span class="line-modified">3517         if (format != GraphicsContext3D::formatMacro) { \</span>
<span class="line-modified">3518             synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;readPixels&quot;, &quot;Invalid format&quot;); \</span>
<span class="line-modified">3519             return; \</span>
<span class="line-modified">3520         } \</span>
<span class="line-modified">3521         break;</span>











3522 
3523     switch (internalFormatTheme) {
<a name="36" id="anc36"></a><span class="line-modified">3524     INTERNAL_FORMAT_CHECK        (NormalizedFixedPoint      , UNSIGNED_BYTE, TypeUint8  );</span>
<span class="line-modified">3525     INTERNAL_FORMAT_CHECK        (SignedNormalizedFixedPoint, BYTE         , TypeInt8   );</span>
<span class="line-modified">3526     INTERNAL_FORMAT_CHECK        (FloatingPoint             , FLOAT        , TypeFloat32);</span>
<span class="line-modified">3527     INTERNAL_FORMAT_INTEGER_CHECK(SignedInteger             , INT          , TypeInt32  );</span>
<span class="line-modified">3528     INTERNAL_FORMAT_INTEGER_CHECK(UnsignedInteger           , UNSIGNED_INT , TypeUint32 );</span>














3529     case InternalFormatTheme::Packed:
3530         switch (internalFormat) {
<a name="37" id="anc37"></a><span class="line-modified">3531         PACKED_INTERNAL_FORMAT_CHECK(RGB565        , RGB         , UNSIGNED_SHORT_5_6_5        , TypeUint16, UNSIGNED_BYTE              , TypeUint8  );</span>
<span class="line-modified">3532         PACKED_INTERNAL_FORMAT_CHECK(RGB5_A1       , RGBA        , UNSIGNED_SHORT_5_5_5_1      , TypeUint16, UNSIGNED_BYTE              , TypeUint8  );</span>
<span class="line-modified">3533         PACKED_INTERNAL_FORMAT_CHECK(RGBA4         , RGBA        , UNSIGNED_SHORT_4_4_4_4      , TypeUint16, UNSIGNED_BYTE              , TypeUint8  );</span>
<span class="line-modified">3534         PACKED_INTERNAL_FORMAT_CHECK(RGB9_E5       , RGB         , UNSIGNED_INT_5_9_9_9_REV    , TypeUint32, UNSIGNED_INT_5_9_9_9_REV   , TypeUint32 );</span>
<span class="line-modified">3535         PACKED_INTERNAL_FORMAT_CHECK(RGB10_A2      , RGBA        , UNSIGNED_INT_2_10_10_10_REV , TypeUint32, UNSIGNED_INT_2_10_10_10_REV, TypeUint32 );</span>
<span class="line-modified">3536         PACKED_INTERNAL_FORMAT_CHECK(R11F_G11F_B10F, RGB         , UNSIGNED_INT_10F_11F_11F_REV, TypeUint32, FLOAT                      , TypeFloat32);</span>
<span class="line-modified">3537         PACKED_INTERNAL_FORMAT_CHECK(RGB10_A2UI    , RGBA_INTEGER, UNSIGNED_INT_2_10_10_10_REV , TypeUint32, UNSIGNED_INT_2_10_10_10_REV, TypeUint32 );</span>
3538         }
3539         break;
3540     case InternalFormatTheme::None:
3541         ASSERT_NOT_REACHED();
3542     }
<a name="38" id="anc38"></a>
3543 #undef INTERNAL_FORMAT_CHECK
3544 #undef INTERNAL_FORMAT_INTEGER_CHECK
<a name="39" id="anc39"></a><span class="line-modified">3545 #undef PACKED_INTERNAL_FORMAT_CHECK</span>
3546 
3547     // Calculate array size, taking into consideration of PACK_ALIGNMENT.
3548     unsigned totalBytesRequired = 0;
3549     unsigned padding = 0;
3550     if (!m_isRobustnessEXTSupported) {
3551         GC3Denum error = m_context-&gt;computeImageSizeInBytes(format, type, width, height, m_packAlignment, &amp;totalBytesRequired, &amp;padding);
3552         if (error != GraphicsContext3D::NO_ERROR) {
3553             synthesizeGLError(error, &quot;readPixels&quot;, &quot;invalid dimensions&quot;);
3554             return;
3555         }
3556         if (pixels.byteLength() &lt; totalBytesRequired) {
3557             synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;readPixels&quot;, &quot;ArrayBufferView not large enough for dimensions&quot;);
3558             return;
3559         }
3560     }
3561 
3562     clearIfComposited();
3563     void* data = pixels.baseAddress();
3564 
3565     if (m_isRobustnessEXTSupported)
3566         m_context-&gt;getExtensions().readnPixelsEXT(x, y, width, height, format, type, pixels.byteLength(), data);
3567     else
3568         m_context-&gt;readPixels(x, y, width, height, format, type, data);
3569 }
3570 
3571 void WebGLRenderingContextBase::releaseShaderCompiler()
3572 {
3573     if (isContextLostOrPending())
3574         return;
3575     m_context-&gt;releaseShaderCompiler();
3576 }
3577 
3578 void WebGLRenderingContextBase::sampleCoverage(GC3Dfloat value, GC3Dboolean invert)
3579 {
3580     if (isContextLostOrPending())
3581         return;
3582     m_context-&gt;sampleCoverage(value, invert);
3583 }
3584 
3585 void WebGLRenderingContextBase::scissor(GC3Dint x, GC3Dint y, GC3Dsizei width, GC3Dsizei height)
3586 {
3587     if (isContextLostOrPending())
3588         return;
3589     if (!validateSize(&quot;scissor&quot;, width, height))
3590         return;
3591     m_context-&gt;scissor(x, y, width, height);
3592 }
3593 
3594 void WebGLRenderingContextBase::shaderSource(WebGLShader* shader, const String&amp; string)
3595 {
3596     if (isContextLostOrPending() || !validateWebGLObject(&quot;shaderSource&quot;, shader))
3597         return;
3598     String stringWithoutComments = StripComments(string).result();
3599     if (!validateString(&quot;shaderSource&quot;, stringWithoutComments))
3600         return;
3601     shader-&gt;setSource(string);
3602     m_context-&gt;shaderSource(objectOrZero(shader), stringWithoutComments);
3603 }
3604 
3605 void WebGLRenderingContextBase::stencilFunc(GC3Denum func, GC3Dint ref, GC3Duint mask)
3606 {
3607     if (isContextLostOrPending())
3608         return;
3609     if (!validateStencilFunc(&quot;stencilFunc&quot;, func))
3610         return;
3611     m_stencilFuncRef = ref;
3612     m_stencilFuncRefBack = ref;
3613     m_stencilFuncMask = mask;
3614     m_stencilFuncMaskBack = mask;
3615     m_context-&gt;stencilFunc(func, ref, mask);
3616 }
3617 
3618 void WebGLRenderingContextBase::stencilFuncSeparate(GC3Denum face, GC3Denum func, GC3Dint ref, GC3Duint mask)
3619 {
3620     if (isContextLostOrPending())
3621         return;
3622     if (!validateStencilFunc(&quot;stencilFuncSeparate&quot;, func))
3623         return;
3624     switch (face) {
3625     case GraphicsContext3D::FRONT_AND_BACK:
3626         m_stencilFuncRef = ref;
3627         m_stencilFuncRefBack = ref;
3628         m_stencilFuncMask = mask;
3629         m_stencilFuncMaskBack = mask;
3630         break;
3631     case GraphicsContext3D::FRONT:
3632         m_stencilFuncRef = ref;
3633         m_stencilFuncMask = mask;
3634         break;
3635     case GraphicsContext3D::BACK:
3636         m_stencilFuncRefBack = ref;
3637         m_stencilFuncMaskBack = mask;
3638         break;
3639     default:
3640         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;stencilFuncSeparate&quot;, &quot;invalid face&quot;);
3641         return;
3642     }
3643     m_context-&gt;stencilFuncSeparate(face, func, ref, mask);
3644 }
3645 
3646 void WebGLRenderingContextBase::stencilMask(GC3Duint mask)
3647 {
3648     if (isContextLostOrPending())
3649         return;
3650     m_stencilMask = mask;
3651     m_stencilMaskBack = mask;
3652     m_context-&gt;stencilMask(mask);
3653 }
3654 
3655 void WebGLRenderingContextBase::stencilMaskSeparate(GC3Denum face, GC3Duint mask)
3656 {
3657     if (isContextLostOrPending())
3658         return;
3659     switch (face) {
3660     case GraphicsContext3D::FRONT_AND_BACK:
3661         m_stencilMask = mask;
3662         m_stencilMaskBack = mask;
3663         break;
3664     case GraphicsContext3D::FRONT:
3665         m_stencilMask = mask;
3666         break;
3667     case GraphicsContext3D::BACK:
3668         m_stencilMaskBack = mask;
3669         break;
3670     default:
3671         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;stencilMaskSeparate&quot;, &quot;invalid face&quot;);
3672         return;
3673     }
3674     m_context-&gt;stencilMaskSeparate(face, mask);
3675 }
3676 
3677 void WebGLRenderingContextBase::stencilOp(GC3Denum fail, GC3Denum zfail, GC3Denum zpass)
3678 {
3679     if (isContextLostOrPending())
3680         return;
3681     m_context-&gt;stencilOp(fail, zfail, zpass);
3682 }
3683 
3684 void WebGLRenderingContextBase::stencilOpSeparate(GC3Denum face, GC3Denum fail, GC3Denum zfail, GC3Denum zpass)
3685 {
3686     if (isContextLostOrPending())
3687         return;
3688     m_context-&gt;stencilOpSeparate(face, fail, zfail, zpass);
3689 }
3690 
3691 void WebGLRenderingContextBase::texImage2DBase(GC3Denum target, GC3Dint level, GC3Denum internalFormat, GC3Dsizei width, GC3Dsizei height, GC3Dint border, GC3Denum format, GC3Denum type, const void* pixels)
3692 {
3693     // FIXME: For now we ignore any errors returned.
3694     auto tex = validateTextureBinding(&quot;texImage2D&quot;, target, true);
3695     ASSERT(validateTexFuncParameters(&quot;texImage2D&quot;, TexImage, target, level, internalFormat, width, height, border, format, type));
3696     ASSERT(tex);
3697     ASSERT(validateNPOTTextureLevel(width, height, level, &quot;texImage2D&quot;));
3698     if (!pixels) {
3699         if (!m_context-&gt;texImage2DResourceSafe(target, level, internalFormat, width, height, border, format, type, m_unpackAlignment))
3700             return;
3701     } else {
3702         ASSERT(validateSettableTexInternalFormat(&quot;texImage2D&quot;, internalFormat));
3703         m_context-&gt;moveErrorsToSyntheticErrorList();
3704         m_context-&gt;texImage2D(target, level, internalFormat, width, height,
3705                               border, format, type, pixels);
3706         if (m_context-&gt;moveErrorsToSyntheticErrorList()) {
3707             // The texImage2D function failed. Tell the WebGLTexture it doesn&#39;t have the data for this level.
3708             tex-&gt;markInvalid(target, level);
3709             return;
3710         }
3711     }
3712     tex-&gt;setLevelInfo(target, level, internalFormat, width, height, type);
3713 }
3714 
3715 void WebGLRenderingContextBase::texImage2DImpl(GC3Denum target, GC3Dint level, GC3Denum internalformat, GC3Denum format, GC3Denum type, Image* image, GraphicsContext3D::ImageHtmlDomSource domSource, bool flipY, bool premultiplyAlpha)
3716 {
3717     Vector&lt;uint8_t&gt; data;
3718     GraphicsContext3D::ImageExtractor imageExtractor(image, domSource, premultiplyAlpha, m_unpackColorspaceConversion == GraphicsContext3D::NONE);
3719     if (!imageExtractor.extractSucceeded()) {
3720         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;texImage2D&quot;, &quot;bad image data&quot;);
3721         return;
3722     }
3723     GraphicsContext3D::DataFormat sourceDataFormat = imageExtractor.imageSourceFormat();
3724     GraphicsContext3D::AlphaOp alphaOp = imageExtractor.imageAlphaOp();
3725     const void* imagePixelData = imageExtractor.imagePixelData();
3726 
3727     bool needConversion = true;
3728     if (type == GraphicsContext3D::UNSIGNED_BYTE &amp;&amp; sourceDataFormat == GraphicsContext3D::DataFormatRGBA8 &amp;&amp; format == GraphicsContext3D::RGBA &amp;&amp; alphaOp == GraphicsContext3D::AlphaDoNothing &amp;&amp; !flipY)
3729         needConversion = false;
3730     else {
3731         if (!m_context-&gt;packImageData(image, imagePixelData, format, type, flipY, alphaOp, sourceDataFormat, imageExtractor.imageWidth(), imageExtractor.imageHeight(), imageExtractor.imageSourceUnpackAlignment(), data)) {
3732             synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;texImage2D&quot;, &quot;packImage error&quot;);
3733             return;
3734         }
3735     }
3736 
3737     if (m_unpackAlignment != 1)
3738         m_context-&gt;pixelStorei(GraphicsContext3D::UNPACK_ALIGNMENT, 1);
3739     texImage2DBase(target, level, internalformat, image-&gt;width(), image-&gt;height(), 0, format, type, needConversion ? data.data() : imagePixelData);
3740     if (m_unpackAlignment != 1)
3741         m_context-&gt;pixelStorei(GraphicsContext3D::UNPACK_ALIGNMENT, m_unpackAlignment);
3742 }
3743 
3744 bool WebGLRenderingContextBase::validateTexFunc(const char* functionName, TexFuncValidationFunctionType functionType, TexFuncValidationSourceType sourceType, GC3Denum target, GC3Dint level, GC3Denum internalFormat, GC3Dsizei width, GC3Dsizei height, GC3Dint border, GC3Denum format, GC3Denum type, GC3Dint xoffset, GC3Dint yoffset)
3745 {
3746     if (!validateTexFuncParameters(functionName, functionType, target, level, internalFormat, width, height, border, format, type))
3747         return false;
3748 
3749     auto texture = validateTextureBinding(functionName, target, true);
3750     if (!texture)
3751         return false;
3752 
3753     if (functionType != TexSubImage) {
3754         if (functionType == TexImage &amp;&amp; texture-&gt;immutable()) {
3755             synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, functionName, &quot;texStorage() called on this texture previously&quot;);
3756             return false;
3757         }
3758         if (!validateNPOTTextureLevel(width, height, level, functionName))
3759             return false;
3760         // For SourceArrayBufferView, function validateTexFuncData() would handle whether to validate the SettableTexFormat
3761         // by checking if the ArrayBufferView is null or not.
3762         if (sourceType != SourceArrayBufferView) {
3763             if (!validateSettableTexInternalFormat(functionName, internalFormat))
3764                 return false;
3765         }
3766     } else {
3767         if (!validateSettableTexInternalFormat(functionName, internalFormat))
3768             return false;
3769         if (!validateSize(functionName, xoffset, yoffset))
3770             return false;
3771         // Before checking if it is in the range, check if overflow happens first.
3772         if (xoffset + width &lt; 0 || yoffset + height &lt; 0) {
3773             synthesizeGLError(GraphicsContext3D::INVALID_VALUE, functionName, &quot;bad dimensions&quot;);
3774             return false;
3775         }
3776         if (xoffset + width &gt; texture-&gt;getWidth(target, level) || yoffset + height &gt; texture-&gt;getHeight(target, level)) {
3777             synthesizeGLError(GraphicsContext3D::INVALID_VALUE, functionName, &quot;dimensions out of range&quot;);
3778             return false;
3779         }
3780         if (texture-&gt;getInternalFormat(target, level) != internalFormat || (isWebGL1() &amp;&amp; texture-&gt;getType(target, level) != type)) {
3781             synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, functionName, &quot;type and format do not match texture&quot;);
3782             return false;
3783         }
3784     }
3785 
3786     return true;
3787 }
3788 
3789 void WebGLRenderingContextBase::texImage2D(GC3Denum target, GC3Dint level, GC3Denum internalFormat, GC3Dsizei width, GC3Dsizei height, GC3Dint border, GC3Denum format, GC3Denum type, RefPtr&lt;ArrayBufferView&gt;&amp;&amp; pixels)
3790 {
3791     if (isContextLostOrPending() || !validateTexFuncData(&quot;texImage2D&quot;, level, width, height, internalFormat, format, type, pixels.get(), NullAllowed)
3792         || !validateTexFunc(&quot;texImage2D&quot;, TexImage, SourceArrayBufferView, target, level, internalFormat, width, height, border, format, type, 0, 0))
3793         return;
3794     void* data = pixels ? pixels-&gt;baseAddress() : 0;
3795     Vector&lt;uint8_t&gt; tempData;
3796     bool changeUnpackAlignment = false;
3797     if (data &amp;&amp; (m_unpackFlipY || m_unpackPremultiplyAlpha)) {
3798         if (!m_context-&gt;extractTextureData(width, height, format, type,
3799                                            m_unpackAlignment,
3800                                            m_unpackFlipY, m_unpackPremultiplyAlpha,
3801                                            data,
3802                                            tempData))
3803             return;
3804         data = tempData.data();
3805         changeUnpackAlignment = true;
3806     }
3807     if (changeUnpackAlignment)
3808         m_context-&gt;pixelStorei(GraphicsContext3D::UNPACK_ALIGNMENT, 1);
3809     texImage2DBase(target, level, internalFormat, width, height, border, format, type, data);
3810     if (changeUnpackAlignment)
3811         m_context-&gt;pixelStorei(GraphicsContext3D::UNPACK_ALIGNMENT, m_unpackAlignment);
3812 }
3813 
3814 void WebGLRenderingContextBase::texSubImage2DImpl(GC3Denum target, GC3Dint level, GC3Dint xoffset, GC3Dint yoffset, GC3Denum format, GC3Denum type, Image* image, GraphicsContext3D::ImageHtmlDomSource domSource, bool flipY, bool premultiplyAlpha)
3815 {
3816     Vector&lt;uint8_t&gt; data;
3817     GraphicsContext3D::ImageExtractor imageExtractor(image, domSource, premultiplyAlpha, m_unpackColorspaceConversion == GraphicsContext3D::NONE);
3818     if (!imageExtractor.extractSucceeded()) {
3819         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;texSubImage2D&quot;, &quot;bad image&quot;);
3820         return;
3821     }
3822     GraphicsContext3D::DataFormat sourceDataFormat = imageExtractor.imageSourceFormat();
3823     GraphicsContext3D::AlphaOp alphaOp = imageExtractor.imageAlphaOp();
3824     const void* imagePixelData = imageExtractor.imagePixelData();
3825 
3826     bool needConversion = true;
3827     if (type == GraphicsContext3D::UNSIGNED_BYTE &amp;&amp; sourceDataFormat == GraphicsContext3D::DataFormatRGBA8 &amp;&amp; format == GraphicsContext3D::RGBA &amp;&amp; alphaOp == GraphicsContext3D::AlphaDoNothing &amp;&amp; !flipY)
3828         needConversion = false;
3829     else {
3830         if (!m_context-&gt;packImageData(image, imagePixelData, format, type, flipY, alphaOp, sourceDataFormat, imageExtractor.imageWidth(), imageExtractor.imageHeight(), imageExtractor.imageSourceUnpackAlignment(), data)) {
3831             synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;texImage2D&quot;, &quot;bad image data&quot;);
3832             return;
3833         }
3834     }
3835 
3836     if (m_unpackAlignment != 1)
3837         m_context-&gt;pixelStorei(GraphicsContext3D::UNPACK_ALIGNMENT, 1);
3838 
3839     texSubImage2DBase(target, level, xoffset, yoffset, image-&gt;width(), image-&gt;height(), format, format, type, needConversion ? data.data() : imagePixelData);
3840 
3841     if (m_unpackAlignment != 1)
3842         m_context-&gt;pixelStorei(GraphicsContext3D::UNPACK_ALIGNMENT, m_unpackAlignment);
3843 }
3844 
3845 void WebGLRenderingContextBase::texSubImage2D(GC3Denum target, GC3Dint level, GC3Dint xoffset, GC3Dint yoffset, GC3Dsizei width, GC3Dsizei height, GC3Denum format, GC3Denum type, RefPtr&lt;ArrayBufferView&gt;&amp;&amp; pixels)
3846 {
3847     if (isContextLostOrPending())
3848         return;
3849 
3850     auto texture = validateTextureBinding(&quot;texSubImage2D&quot;, target, true);
3851     if (!texture)
3852         return;
3853 
3854     GC3Denum internalFormat = texture-&gt;getInternalFormat(target, level);
3855     if (!internalFormat) {
3856         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;texSubImage2D&quot;, &quot;invalid texture target or level&quot;);
3857         return;
3858     }
3859 
3860     if (!validateTexFuncData(&quot;texSubImage2D&quot;, level, width, height, internalFormat, format, type, pixels.get(), NullNotAllowed))
3861         return;
3862 
3863     if (!validateTexFunc(&quot;texSubImage2D&quot;, TexSubImage, SourceArrayBufferView, target, level, internalFormat, width, height, 0, format, type, xoffset, yoffset))
3864         return;
3865 
3866     void* data = pixels-&gt;baseAddress();
3867     Vector&lt;uint8_t&gt; tempData;
3868     bool changeUnpackAlignment = false;
3869     if (data &amp;&amp; (m_unpackFlipY || m_unpackPremultiplyAlpha)) {
3870         if (!m_context-&gt;extractTextureData(width, height, format, type, m_unpackAlignment, m_unpackFlipY, m_unpackPremultiplyAlpha, data, tempData))
3871             return;
3872         data = tempData.data();
3873         changeUnpackAlignment = true;
3874     }
3875     if (changeUnpackAlignment)
3876         m_context-&gt;pixelStorei(GraphicsContext3D::UNPACK_ALIGNMENT, 1);
3877 
3878     texSubImage2DBase(target, level, xoffset, yoffset, width, height, internalFormat, format, type, data);
3879 
3880     if (changeUnpackAlignment)
3881         m_context-&gt;pixelStorei(GraphicsContext3D::UNPACK_ALIGNMENT, m_unpackAlignment);
3882 }
3883 
3884 ExceptionOr&lt;void&gt; WebGLRenderingContextBase::texSubImage2D(GC3Denum target, GC3Dint level, GC3Dint xoffset, GC3Dint yoffset, GC3Denum format, GC3Denum type, Optional&lt;TexImageSource&gt;&amp;&amp; source)
3885 {
3886     if (!source) {
3887         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;texSubImage2D&quot;, &quot;source is null&quot;);
3888         return { };
3889     }
3890 
3891     if (isContextLostOrPending())
3892         return { };
3893 
3894     auto visitor = WTF::makeVisitor([&amp;](const RefPtr&lt;ImageBitmap&gt;&amp; bitmap) -&gt; ExceptionOr&lt;void&gt; {
3895         auto texture = validateTextureBinding(&quot;texSubImage2D&quot;, target, true);
3896         if (!texture)
3897             return { };
3898 
3899         GC3Denum internalFormat = texture-&gt;getInternalFormat(target, level);
3900         if (!internalFormat) {
3901             synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;texSubImage2D&quot;, &quot;invalid texture target or level&quot;);
3902             return { };
3903         }
3904 
3905         if (!validateTexFunc(&quot;texSubImage2D&quot;, TexSubImage, SourceImageBitmap, target, level, internalFormat, bitmap-&gt;width(), bitmap-&gt;height(), 0, format, type, xoffset, yoffset))
3906             return { };
3907 
3908         ImageBuffer* buffer = bitmap-&gt;buffer();
3909         if (!buffer)
3910             return { };
3911 
3912         RefPtr&lt;Image&gt; image = buffer-&gt;copyImage(ImageBuffer::fastCopyImageMode());
3913         if (image)
3914             texSubImage2DImpl(target, level, xoffset, yoffset, format, type, image.get(), GraphicsContext3D::HtmlDomImage, m_unpackFlipY, m_unpackPremultiplyAlpha);
3915         return { };
3916     }, [&amp;](const RefPtr&lt;ImageData&gt;&amp; pixels) -&gt; ExceptionOr&lt;void&gt; {
3917         auto texture = validateTextureBinding(&quot;texSubImage2D&quot;, target, true);
3918         if (!texture)
3919             return { };
3920 
3921         GC3Denum internalFormat = texture-&gt;getInternalFormat(target, level);
3922         if (!internalFormat) {
3923             synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;texSubImage2D&quot;, &quot;invalid texture target or level&quot;);
3924             return { };
3925         }
3926 
3927         if (!validateTexFunc(&quot;texSubImage2D&quot;, TexSubImage, SourceImageData, target, level, internalFormat, pixels-&gt;width(), pixels-&gt;height(), 0, format, type, xoffset, yoffset))
3928             return { };
3929 
3930         Vector&lt;uint8_t&gt; data;
3931         bool needConversion = true;
3932         // The data from ImageData is always of format RGBA8.
3933         // No conversion is needed if destination format is RGBA and type is USIGNED_BYTE and no Flip or Premultiply operation is required.
3934         if (format == GraphicsContext3D::RGBA &amp;&amp; type == GraphicsContext3D::UNSIGNED_BYTE &amp;&amp; !m_unpackFlipY &amp;&amp; !m_unpackPremultiplyAlpha)
3935             needConversion = false;
3936         else {
3937             if (!m_context-&gt;extractImageData(pixels.get(), format, type, m_unpackFlipY, m_unpackPremultiplyAlpha, data)) {
3938                 synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;texSubImage2D&quot;, &quot;bad image data&quot;);
3939                 return { };
3940             }
3941         }
3942         if (m_unpackAlignment != 1)
3943             m_context-&gt;pixelStorei(GraphicsContext3D::UNPACK_ALIGNMENT, 1);
3944 
3945         texSubImage2DBase(target, level, xoffset, yoffset, pixels-&gt;width(), pixels-&gt;height(), format, format, type, needConversion ? data.data() : pixels-&gt;data()-&gt;data());
3946 
3947         if (m_unpackAlignment != 1)
3948             m_context-&gt;pixelStorei(GraphicsContext3D::UNPACK_ALIGNMENT, m_unpackAlignment);
3949 
3950         return { };
3951     } , [&amp;](const RefPtr&lt;HTMLImageElement&gt;&amp; image) -&gt; ExceptionOr&lt;void&gt; {
3952         if (isContextLostOrPending())
3953             return { };
3954         auto validationResult = validateHTMLImageElement(&quot;texSubImage2D&quot;, image.get());
3955         if (validationResult.hasException())
3956             return validationResult.releaseException();
3957         if (!validationResult.returnValue())
3958             return { };
3959 
3960         RefPtr&lt;Image&gt; imageForRender = image-&gt;cachedImage()-&gt;imageForRenderer(image-&gt;renderer());
3961         if (!imageForRender)
3962             return { };
3963 
3964         if (imageForRender-&gt;isSVGImage())
3965             imageForRender = drawImageIntoBuffer(*imageForRender, image-&gt;width(), image-&gt;height(), 1);
3966 
3967         auto texture = validateTextureBinding(&quot;texSubImage2D&quot;, target, true);
3968         if (!texture)
3969             return { };
3970 
3971         GC3Denum internalFormat = texture-&gt;getInternalFormat(target, level);
3972         if (!internalFormat) {
3973             synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;texSubImage2D&quot;, &quot;invalid texture target or level&quot;);
3974             return { };
3975         }
3976 
3977         if (!imageForRender || !validateTexFunc(&quot;texSubImage2D&quot;, TexSubImage, SourceHTMLImageElement, target, level, internalFormat, imageForRender-&gt;width(), imageForRender-&gt;height(), 0, format, type, xoffset, yoffset))
3978             return { };
3979 
3980         texSubImage2DImpl(target, level, xoffset, yoffset, format, type, imageForRender.get(), GraphicsContext3D::HtmlDomImage, m_unpackFlipY, m_unpackPremultiplyAlpha);
3981         return { };
3982     }, [&amp;](const RefPtr&lt;HTMLCanvasElement&gt;&amp; canvas) -&gt; ExceptionOr&lt;void&gt; {
3983         if (isContextLostOrPending())
3984             return { };
3985         auto validationResult = validateHTMLCanvasElement(&quot;texSubImage2D&quot;, canvas.get());
3986         if (validationResult.hasException())
3987             return validationResult.releaseException();
3988         if (!validationResult.returnValue())
3989             return { };
3990 
3991         auto texture = validateTextureBinding(&quot;texSubImage2D&quot;, target, true);
3992         if (!texture)
3993             return { };
3994 
3995         GC3Denum internalFormat = texture-&gt;getInternalFormat(target, level);
3996         if (!internalFormat) {
3997             synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;texSubImage2D&quot;, &quot;invalid texture target or level&quot;);
3998             return { };
3999         }
4000 
4001         if (!validateTexFunc(&quot;texSubImage2D&quot;, TexSubImage, SourceHTMLCanvasElement, target, level, internalFormat, canvas-&gt;width(), canvas-&gt;height(), 0, format, type, xoffset, yoffset))
4002             return { };
4003 
4004         RefPtr&lt;ImageData&gt; imageData = canvas-&gt;getImageData();
4005         if (imageData)
4006             texSubImage2D(target, level, xoffset, yoffset, format, type, TexImageSource(imageData.get()));
4007         else
4008             texSubImage2DImpl(target, level, xoffset, yoffset, format, type, canvas-&gt;copiedImage(), GraphicsContext3D::HtmlDomCanvas, m_unpackFlipY, m_unpackPremultiplyAlpha);
4009         return { };
4010     }
4011 #if ENABLE(VIDEO)
4012     , [&amp;](const RefPtr&lt;HTMLVideoElement&gt;&amp; video) -&gt; ExceptionOr&lt;void&gt; {
4013         if (isContextLostOrPending())
4014             return { };
4015         auto validationResult = validateHTMLVideoElement(&quot;texSubImage2D&quot;, video.get());
4016         if (validationResult.hasException())
4017             return validationResult.releaseException();
4018         if (!validationResult.returnValue())
4019             return { };
4020 
4021         auto texture = validateTextureBinding(&quot;texSubImage2D&quot;, target, true);
4022         if (!texture)
4023             return { };
4024 
4025         GC3Denum internalFormat = texture-&gt;getInternalFormat(target, level);
4026         if (!internalFormat) {
4027             synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;texSubImage2D&quot;, &quot;invalid texture target or level&quot;);
4028             return { };
4029         }
4030 
4031         if (!validateTexFunc(&quot;texSubImage2D&quot;, TexSubImage, SourceHTMLVideoElement, target, level, internalFormat, video-&gt;videoWidth(), video-&gt;videoHeight(), 0, format, type, xoffset, yoffset))
4032             return { };
4033 
4034         RefPtr&lt;Image&gt; image = videoFrameToImage(video.get(), ImageBuffer::fastCopyImageMode());
4035         if (!image)
4036             return { };
4037         texSubImage2DImpl(target, level, xoffset, yoffset, format, type, image.get(), GraphicsContext3D::HtmlDomVideo, m_unpackFlipY, m_unpackPremultiplyAlpha);
4038         return { };
4039     }
4040 #endif
4041     );
4042 
4043     return WTF::visit(visitor, source.value());
4044 }
4045 
4046 bool WebGLRenderingContextBase::validateArrayBufferType(const char* functionName, GC3Denum type, Optional&lt;JSC::TypedArrayType&gt; arrayType)
4047 {
4048 #define TYPE_VALIDATION_CASE(arrayTypeMacro) if (arrayType &amp;&amp; arrayType.value() != JSC::arrayTypeMacro) { \
4049             synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, functionName, &quot;ArrayBufferView not &quot; #arrayTypeMacro); \
4050             return false; \
4051         } \
4052         break;
4053 
4054     switch (type) {
4055     case GraphicsContext3D::UNSIGNED_BYTE:
4056         TYPE_VALIDATION_CASE(TypeUint8);
4057     case GraphicsContext3D::BYTE:
4058         TYPE_VALIDATION_CASE(TypeInt8);
4059     case GraphicsContext3D::UNSIGNED_SHORT:
4060     case GraphicsContext3D::UNSIGNED_SHORT_5_6_5:
4061     case GraphicsContext3D::UNSIGNED_SHORT_4_4_4_4:
4062     case GraphicsContext3D::UNSIGNED_SHORT_5_5_5_1:
4063         TYPE_VALIDATION_CASE(TypeUint16);
4064     case GraphicsContext3D::SHORT:
4065         TYPE_VALIDATION_CASE(TypeInt16);
4066     case GraphicsContext3D::UNSIGNED_INT_2_10_10_10_REV:
4067     case GraphicsContext3D::UNSIGNED_INT_10F_11F_11F_REV:
4068     case GraphicsContext3D::UNSIGNED_INT_5_9_9_9_REV:
4069     case GraphicsContext3D::UNSIGNED_INT_24_8:
4070     case GraphicsContext3D::UNSIGNED_INT:
4071         TYPE_VALIDATION_CASE(TypeUint32);
4072     case GraphicsContext3D::INT:
4073         TYPE_VALIDATION_CASE(TypeInt32);
4074     case GraphicsContext3D::FLOAT: // OES_texture_float
4075         TYPE_VALIDATION_CASE(TypeFloat32);
4076     case GraphicsContext3D::HALF_FLOAT_OES: // OES_texture_half_float
4077     case GraphicsContext3D::HALF_FLOAT:
4078     case GraphicsContext3D::FLOAT_32_UNSIGNED_INT_24_8_REV:
4079         // As per the specification, ArrayBufferView should be null when
4080         // OES_texture_half_float is enabled.
4081         if (arrayType) {
4082             synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, functionName, &quot;type HALF_FLOAT_OES but ArrayBufferView is not NULL&quot;);
4083             return false;
4084         }
4085         break;
4086     default:
4087         ASSERT_NOT_REACHED();
4088         return false;
4089     }
4090 #undef TYPE_VALIDATION_CASE
4091     return true;
4092 }
4093 
4094 bool WebGLRenderingContextBase::validateTexFuncData(const char* functionName, GC3Dint level, GC3Dsizei width, GC3Dsizei height, GC3Denum internalFormat, GC3Denum format, GC3Denum type, ArrayBufferView* pixels, NullDisposition disposition)
4095 {
4096     if (!pixels) {
4097         if (disposition == NullAllowed)
4098             return true;
4099         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, functionName, &quot;no pixels&quot;);
4100         return false;
4101     }
4102 
4103     if (!validateTexFuncFormatAndType(functionName, internalFormat, format, type, level))
4104         return false;
4105     if (!validateSettableTexInternalFormat(functionName, internalFormat))
4106         return false;
4107     if (!validateArrayBufferType(functionName, type, pixels ? Optional&lt;JSC::TypedArrayType&gt;(pixels-&gt;getType()) : WTF::nullopt))
4108         return false;
4109 
4110     unsigned totalBytesRequired;
4111     GC3Denum error = m_context-&gt;computeImageSizeInBytes(format, type, width, height, m_unpackAlignment, &amp;totalBytesRequired, nullptr);
4112     if (error != GraphicsContext3D::NO_ERROR) {
4113         synthesizeGLError(error, functionName, &quot;invalid texture dimensions&quot;);
4114         return false;
4115     }
4116     if (pixels-&gt;byteLength() &lt; totalBytesRequired) {
4117         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, functionName, &quot;ArrayBufferView not big enough for request&quot;);
4118         return false;
4119     }
4120     return true;
4121 }
4122 
4123 bool WebGLRenderingContextBase::validateTexFuncParameters(const char* functionName,
4124     TexFuncValidationFunctionType functionType,
4125     GC3Denum target, GC3Dint level,
4126     GC3Denum internalformat,
4127     GC3Dsizei width, GC3Dsizei height, GC3Dint border,
4128     GC3Denum format, GC3Denum type)
4129 {
4130     // We absolutely have to validate the format and type combination.
4131     // The texImage2D entry points taking HTMLImage, etc. will produce
4132     // temporary data based on this combination, so it must be legal.
4133     if (!validateTexFuncFormatAndType(functionName, internalformat, format, type, level) || !validateTexFuncLevel(functionName, target, level))
4134         return false;
4135 
4136     if (width &lt; 0 || height &lt; 0) {
4137         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, functionName, &quot;width or height &lt; 0&quot;);
4138         return false;
4139     }
4140 
4141     GC3Dint maxTextureSizeForLevel = pow(2.0, m_maxTextureLevel - 1 - level);
4142     switch (target) {
4143     case GraphicsContext3D::TEXTURE_2D:
4144         if (width &gt; maxTextureSizeForLevel || height &gt; maxTextureSizeForLevel) {
4145             synthesizeGLError(GraphicsContext3D::INVALID_VALUE, functionName, &quot;width or height out of range&quot;);
4146             return false;
4147         }
4148         break;
4149     case GraphicsContext3D::TEXTURE_CUBE_MAP_POSITIVE_X:
4150     case GraphicsContext3D::TEXTURE_CUBE_MAP_NEGATIVE_X:
4151     case GraphicsContext3D::TEXTURE_CUBE_MAP_POSITIVE_Y:
4152     case GraphicsContext3D::TEXTURE_CUBE_MAP_NEGATIVE_Y:
4153     case GraphicsContext3D::TEXTURE_CUBE_MAP_POSITIVE_Z:
4154     case GraphicsContext3D::TEXTURE_CUBE_MAP_NEGATIVE_Z:
4155         if (functionType != TexSubImage &amp;&amp; width != height) {
4156             synthesizeGLError(GraphicsContext3D::INVALID_VALUE, functionName, &quot;width != height for cube map&quot;);
4157             return false;
4158         }
4159         // No need to check height here. For texImage width == height.
4160         // For texSubImage that will be checked when checking yoffset + height is in range.
4161         if (width &gt; maxTextureSizeForLevel) {
4162             synthesizeGLError(GraphicsContext3D::INVALID_VALUE, functionName, &quot;width or height out of range for cube map&quot;);
4163             return false;
4164         }
4165         break;
4166     default:
4167         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, functionName, &quot;invalid target&quot;);
4168         return false;
4169     }
4170 
4171     if (border) {
4172         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, functionName, &quot;border != 0&quot;);
4173         return false;
4174     }
4175 
4176     return true;
4177 }
4178 
4179 bool WebGLRenderingContextBase::validateTexFuncFormatAndType(const char* functionName, GC3Denum internalFormat, GC3Denum format, GC3Denum type, GC3Dint level)
4180 {
4181     switch (format) {
4182     case GraphicsContext3D::ALPHA:
4183     case GraphicsContext3D::LUMINANCE:
4184     case GraphicsContext3D::LUMINANCE_ALPHA:
4185     case GraphicsContext3D::RGB:
4186     case GraphicsContext3D::RGBA:
4187         break;
4188     case GraphicsContext3D::DEPTH_STENCIL:
4189     case GraphicsContext3D::DEPTH_COMPONENT:
4190         if (!m_webglDepthTexture &amp;&amp; isWebGL1()) {
4191             synthesizeGLError(GraphicsContext3D::INVALID_ENUM, functionName, &quot;depth texture formats not enabled&quot;);
4192             return false;
4193         }
4194         if (level &gt; 0) {
4195             synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, functionName, &quot;level must be 0 for depth formats&quot;);
4196             return false;
4197         }
4198         break;
4199     case Extensions3D::SRGB_EXT:
4200     case Extensions3D::SRGB_ALPHA_EXT:
4201         if (!m_extsRGB) {
4202             synthesizeGLError(GraphicsContext3D::INVALID_ENUM, functionName, &quot;sRGB texture formats not enabled&quot;);
4203             return false;
4204         }
4205         break;
4206     default:
4207 #if ENABLE(WEBGL2)
4208         if (!isWebGL1()) {
4209             switch (format) {
4210             case GraphicsContext3D::RED:
4211             case GraphicsContext3D::RED_INTEGER:
4212             case GraphicsContext3D::RG:
4213             case GraphicsContext3D::RG_INTEGER:
4214             case GraphicsContext3D::RGB_INTEGER:
4215             case GraphicsContext3D::RGBA_INTEGER:
4216                 break;
4217             default:
4218                 synthesizeGLError(GraphicsContext3D::INVALID_ENUM, functionName, &quot;invalid texture format&quot;);
4219                 return false;
4220             }
4221         } else
4222 #endif
4223         {
4224             synthesizeGLError(GraphicsContext3D::INVALID_ENUM, functionName, &quot;invalid texture format&quot;);
4225             return false;
4226         }
4227     }
4228 
4229     switch (type) {
4230     case GraphicsContext3D::UNSIGNED_BYTE:
4231     case GraphicsContext3D::UNSIGNED_SHORT_5_6_5:
4232     case GraphicsContext3D::UNSIGNED_SHORT_4_4_4_4:
4233     case GraphicsContext3D::UNSIGNED_SHORT_5_5_5_1:
4234         break;
4235     case GraphicsContext3D::FLOAT:
4236         if (!m_oesTextureFloat &amp;&amp; isWebGL1()) {
4237             synthesizeGLError(GraphicsContext3D::INVALID_ENUM, functionName, &quot;invalid texture type&quot;);
4238             return false;
4239         }
4240         break;
4241     case GraphicsContext3D::HALF_FLOAT:
4242     case GraphicsContext3D::HALF_FLOAT_OES:
4243         if (!m_oesTextureHalfFloat &amp;&amp; isWebGL1()) {
4244             synthesizeGLError(GraphicsContext3D::INVALID_ENUM, functionName, &quot;invalid texture type&quot;);
4245             return false;
4246         }
4247         break;
4248     case GraphicsContext3D::UNSIGNED_INT:
4249     case GraphicsContext3D::UNSIGNED_INT_24_8:
4250     case GraphicsContext3D::UNSIGNED_SHORT:
4251         if (!m_webglDepthTexture &amp;&amp; isWebGL1()) {
4252             synthesizeGLError(GraphicsContext3D::INVALID_ENUM, functionName, &quot;invalid texture type&quot;);
4253             return false;
4254         }
4255         break;
4256     default:
4257 #if ENABLE(WEBGL2)
4258         if (!isWebGL1()) {
4259             switch (type) {
4260             case GraphicsContext3D::BYTE:
4261             case GraphicsContext3D::SHORT:
4262             case GraphicsContext3D::INT:
4263             case GraphicsContext3D::UNSIGNED_INT_2_10_10_10_REV:
4264             case GraphicsContext3D::UNSIGNED_INT_10F_11F_11F_REV:
4265             case GraphicsContext3D::UNSIGNED_INT_5_9_9_9_REV:
4266             case GraphicsContext3D::FLOAT_32_UNSIGNED_INT_24_8_REV:
4267                 break;
4268             default:
4269                 synthesizeGLError(GraphicsContext3D::INVALID_ENUM, functionName, &quot;invalid texture type&quot;);
4270                 return false;
4271             }
4272         } else
4273 #endif
4274         {
4275             synthesizeGLError(GraphicsContext3D::INVALID_ENUM, functionName, &quot;invalid texture type&quot;);
4276             return false;
4277         }
4278     }
4279 
4280     // Verify that the combination of internalformat, format, and type is supported.
4281 #define INTERNAL_FORMAT_CASE(internalFormatMacro, formatMacro, type0, type1, type2, type3, type4) case GraphicsContext3D::internalFormatMacro: \
4282     if (format != GraphicsContext3D::formatMacro) { \
4283         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, functionName, &quot;invalid format for internalformat&quot;); \
4284         return false; \
4285     } \
4286     if (type != type0 &amp;&amp; type != type1 &amp;&amp; type != type2 &amp;&amp; type != type3 &amp;&amp; type != type4) { \
4287         if (type != GraphicsContext3D::HALF_FLOAT_OES || (type0 != GraphicsContext3D::HALF_FLOAT &amp;&amp; type1 != GraphicsContext3D::HALF_FLOAT &amp;&amp; type2 != GraphicsContext3D::HALF_FLOAT &amp;&amp; type3 != GraphicsContext3D::HALF_FLOAT)) { \
4288             synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, functionName, &quot;invalid type for internalformat&quot;); \
4289             return false; \
4290         } \
4291     } \
4292     break;
4293     switch (internalFormat) {
4294     INTERNAL_FORMAT_CASE(RGB               , RGB            , GraphicsContext3D::UNSIGNED_BYTE                 , GraphicsContext3D::UNSIGNED_SHORT_5_6_5  , GraphicsContext3D::HALF_FLOAT                  , GraphicsContext3D::FLOAT     , 0                       );
4295     INTERNAL_FORMAT_CASE(RGBA              , RGBA           , GraphicsContext3D::UNSIGNED_BYTE                 , GraphicsContext3D::UNSIGNED_SHORT_4_4_4_4, GraphicsContext3D::UNSIGNED_SHORT_5_5_5_1      , GraphicsContext3D::HALF_FLOAT, GraphicsContext3D::FLOAT);
4296     INTERNAL_FORMAT_CASE(LUMINANCE_ALPHA   , LUMINANCE_ALPHA, GraphicsContext3D::UNSIGNED_BYTE                 , GraphicsContext3D::HALF_FLOAT            , GraphicsContext3D::FLOAT                       , 0                            , 0                       );
4297     INTERNAL_FORMAT_CASE(LUMINANCE         , LUMINANCE      , GraphicsContext3D::UNSIGNED_BYTE                 , GraphicsContext3D::HALF_FLOAT            , GraphicsContext3D::FLOAT                       , 0                            , 0                       );
4298     INTERNAL_FORMAT_CASE(ALPHA             , ALPHA          , GraphicsContext3D::UNSIGNED_BYTE                 , GraphicsContext3D::HALF_FLOAT            , GraphicsContext3D::FLOAT                       , 0                            , 0                       );
4299     INTERNAL_FORMAT_CASE(R8                , RED            , GraphicsContext3D::UNSIGNED_BYTE                 , 0                                        , 0                                              , 0                            , 0                       );
4300     INTERNAL_FORMAT_CASE(R8_SNORM          , RED            , GraphicsContext3D::BYTE                          , 0                                        , 0                                              , 0                            , 0                       );
4301     INTERNAL_FORMAT_CASE(R16F              , RED            , GraphicsContext3D::HALF_FLOAT                    , GraphicsContext3D::FLOAT                 , 0                                              , 0                            , 0                       );
4302     INTERNAL_FORMAT_CASE(R32F              , RED            , GraphicsContext3D::FLOAT                         , 0                                        , 0                                              , 0                            , 0                       );
4303     INTERNAL_FORMAT_CASE(R8UI              , RED_INTEGER    , GraphicsContext3D::UNSIGNED_BYTE                 , 0                                        , 0                                              , 0                            , 0                       );
4304     INTERNAL_FORMAT_CASE(R8I               , RED_INTEGER    , GraphicsContext3D::BYTE                          , 0                                        , 0                                              , 0                            , 0                       );
4305     INTERNAL_FORMAT_CASE(R16UI             , RED_INTEGER    , GraphicsContext3D::UNSIGNED_SHORT                , 0                                        , 0                                              , 0                            , 0                       );
4306     INTERNAL_FORMAT_CASE(R16I              , RED_INTEGER    , GraphicsContext3D::SHORT                         , 0                                        , 0                                              , 0                            , 0                       );
4307     INTERNAL_FORMAT_CASE(R32UI             , RED_INTEGER    , GraphicsContext3D::UNSIGNED_INT                  , 0                                        , 0                                              , 0                            , 0                       );
4308     INTERNAL_FORMAT_CASE(R32I              , RED_INTEGER    , GraphicsContext3D::INT                           , 0                                        , 0                                              , 0                            , 0                       );
4309     INTERNAL_FORMAT_CASE(RG8               , RG             , GraphicsContext3D::UNSIGNED_BYTE                 , 0                                        , 0                                              , 0                            , 0                       );
4310     INTERNAL_FORMAT_CASE(RG8_SNORM         , RG             , GraphicsContext3D::BYTE                          , 0                                        , 0                                              , 0                            , 0                       );
4311     INTERNAL_FORMAT_CASE(RG16F             , RG             , GraphicsContext3D::HALF_FLOAT                    , GraphicsContext3D::FLOAT                 , 0                                              , 0                            , 0                       );
4312     INTERNAL_FORMAT_CASE(RG32F             , RG             , GraphicsContext3D::FLOAT                         , 0                                        , 0                                              , 0                            , 0                       );
4313     INTERNAL_FORMAT_CASE(RG8UI             , RG_INTEGER     , GraphicsContext3D::UNSIGNED_BYTE                 , 0                                        , 0                                              , 0                            , 0                       );
4314     INTERNAL_FORMAT_CASE(RG8I              , RG_INTEGER     , GraphicsContext3D::BYTE                          , 0                                        , 0                                              , 0                            , 0                       );
4315     INTERNAL_FORMAT_CASE(RG16UI            , RG_INTEGER     , GraphicsContext3D::UNSIGNED_SHORT                , 0                                        , 0                                              , 0                            , 0                       );
4316     INTERNAL_FORMAT_CASE(RG16I             , RG_INTEGER     , GraphicsContext3D::SHORT                         , 0                                        , 0                                              , 0                            , 0                       );
4317     INTERNAL_FORMAT_CASE(RG32UI            , RG_INTEGER     , GraphicsContext3D::UNSIGNED_INT                  , 0                                        , 0                                              , 0                            , 0                       );
4318     INTERNAL_FORMAT_CASE(RG32I             , RG_INTEGER     , GraphicsContext3D::INT                           , 0                                        , 0                                              , 0                            , 0                       );
4319     INTERNAL_FORMAT_CASE(RGB8              , RGB            , GraphicsContext3D::UNSIGNED_BYTE                 , 0                                        , 0                                              , 0                            , 0                       );
4320     INTERNAL_FORMAT_CASE(SRGB8             , RGB            , GraphicsContext3D::UNSIGNED_BYTE                 , 0                                        , 0                                              , 0                            , 0                       );
4321     INTERNAL_FORMAT_CASE(RGB565            , RGB            , GraphicsContext3D::UNSIGNED_BYTE                 , GraphicsContext3D::UNSIGNED_SHORT_5_6_5  , 0                                              , 0                            , 0                       );
4322     INTERNAL_FORMAT_CASE(RGB8_SNORM        , RGB            , GraphicsContext3D::BYTE                          , 0                                        , 0                                              , 0                            , 0                       );
4323     INTERNAL_FORMAT_CASE(R11F_G11F_B10F    , RGB            , GraphicsContext3D::UNSIGNED_INT_10F_11F_11F_REV  , GraphicsContext3D::HALF_FLOAT            , GraphicsContext3D::FLOAT                       , 0                            , 0                       );
4324     INTERNAL_FORMAT_CASE(RGB9_E5           , RGB            , GraphicsContext3D::UNSIGNED_INT_5_9_9_9_REV      , GraphicsContext3D::HALF_FLOAT            , GraphicsContext3D::FLOAT                       , 0                            , 0                       );
4325     INTERNAL_FORMAT_CASE(RGB16F            , RGB            , GraphicsContext3D::HALF_FLOAT                    , GraphicsContext3D::FLOAT                 , 0                                              , 0                            , 0                       );
4326     INTERNAL_FORMAT_CASE(RGB32F            , RGB            , GraphicsContext3D::FLOAT                         , 0                                        , 0                                              , 0                            , 0                       );
4327     INTERNAL_FORMAT_CASE(RGB8UI            , RGB_INTEGER    , GraphicsContext3D::UNSIGNED_BYTE                 , 0                                        , 0                                              , 0                            , 0                       );
4328     INTERNAL_FORMAT_CASE(RGB8I             , RGB_INTEGER    , GraphicsContext3D::BYTE                          , 0                                        , 0                                              , 0                            , 0                       );
4329     INTERNAL_FORMAT_CASE(RGB16UI           , RGB_INTEGER    , GraphicsContext3D::UNSIGNED_SHORT                , 0                                        , 0                                              , 0                            , 0                       );
4330     INTERNAL_FORMAT_CASE(RGB16I            , RGB_INTEGER    , GraphicsContext3D::SHORT                         , 0                                        , 0                                              , 0                            , 0                       );
4331     INTERNAL_FORMAT_CASE(RGB32UI           , RGB_INTEGER    , GraphicsContext3D::UNSIGNED_INT                  , 0                                        , 0                                              , 0                            , 0                       );
4332     INTERNAL_FORMAT_CASE(RGB32I            , RGB_INTEGER    , GraphicsContext3D::INT                           , 0                                        , 0                                              , 0                            , 0                       );
4333     INTERNAL_FORMAT_CASE(RGBA8             , RGBA           , GraphicsContext3D::UNSIGNED_BYTE                 , 0                                        , 0                                              , 0                            , 0                       );
4334     INTERNAL_FORMAT_CASE(SRGB8_ALPHA8      , RGBA           , GraphicsContext3D::UNSIGNED_BYTE                 , 0                                        , 0                                              , 0                            , 0                       );
4335     INTERNAL_FORMAT_CASE(RGBA8_SNORM       , RGBA           , GraphicsContext3D::BYTE                          , 0                                        , 0                                              , 0                            , 0                       );
4336     INTERNAL_FORMAT_CASE(RGB5_A1           , RGBA           , GraphicsContext3D::UNSIGNED_BYTE                 , GraphicsContext3D::UNSIGNED_SHORT_5_5_5_1, GraphicsContext3D::UNSIGNED_INT_2_10_10_10_REV , 0                            , 0                       );
4337     INTERNAL_FORMAT_CASE(RGBA4             , RGBA           , GraphicsContext3D::UNSIGNED_BYTE                 , GraphicsContext3D::UNSIGNED_SHORT_4_4_4_4, 0                                              , 0                            , 0                       );
4338     INTERNAL_FORMAT_CASE(RGB10_A2          , RGBA           , GraphicsContext3D::UNSIGNED_INT_2_10_10_10_REV   , 0                                        , 0                                              , 0                            , 0                       );
4339     INTERNAL_FORMAT_CASE(RGBA16F           , RGBA           , GraphicsContext3D::HALF_FLOAT                    , GraphicsContext3D::FLOAT                 , 0                                              , 0                            , 0                       );
4340     INTERNAL_FORMAT_CASE(RGBA32F           , RGBA           , GraphicsContext3D::FLOAT                         , 0                                        , 0                                              , 0                            , 0                       );
4341     INTERNAL_FORMAT_CASE(RGBA8UI           , RGBA_INTEGER   , GraphicsContext3D::UNSIGNED_BYTE                 , 0                                        , 0                                              , 0                            , 0                       );
4342     INTERNAL_FORMAT_CASE(RGBA8I            , RGBA_INTEGER   , GraphicsContext3D::BYTE                          , 0                                        , 0                                              , 0                            , 0                       );
4343     INTERNAL_FORMAT_CASE(RGB10_A2UI        , RGBA_INTEGER   , GraphicsContext3D::UNSIGNED_INT_2_10_10_10_REV   , 0                                        , 0                                              , 0                            , 0                       );
4344     INTERNAL_FORMAT_CASE(RGBA16UI          , RGBA_INTEGER   , GraphicsContext3D::UNSIGNED_SHORT                , 0                                        , 0                                              , 0                            , 0                       );
4345     INTERNAL_FORMAT_CASE(RGBA16I           , RGBA_INTEGER   , GraphicsContext3D::SHORT                         , 0                                        , 0                                              , 0                            , 0                       );
4346     INTERNAL_FORMAT_CASE(RGBA32I           , RGBA_INTEGER   , GraphicsContext3D::INT                           , 0                                        , 0                                              , 0                            , 0                       );
4347     INTERNAL_FORMAT_CASE(RGBA32UI          , RGBA_INTEGER   , GraphicsContext3D::UNSIGNED_INT                  , 0                                        , 0                                              , 0                            , 0                       );
4348     INTERNAL_FORMAT_CASE(DEPTH_COMPONENT   , DEPTH_COMPONENT, GraphicsContext3D::UNSIGNED_SHORT                , GraphicsContext3D::UNSIGNED_INT          , 0                                              , 0                            , 0                       );
4349     INTERNAL_FORMAT_CASE(DEPTH_COMPONENT16 , DEPTH_COMPONENT, GraphicsContext3D::UNSIGNED_SHORT                , GraphicsContext3D::UNSIGNED_INT          , 0                                              , 0                            , 0                       );
4350     INTERNAL_FORMAT_CASE(DEPTH_COMPONENT24 , DEPTH_COMPONENT, GraphicsContext3D::UNSIGNED_INT                  , 0                                        , 0                                              , 0                            , 0                       );
4351     INTERNAL_FORMAT_CASE(DEPTH_COMPONENT32F, DEPTH_COMPONENT, GraphicsContext3D::FLOAT                         , 0                                        , 0                                              , 0                            , 0                       );
4352     INTERNAL_FORMAT_CASE(DEPTH_STENCIL     , DEPTH_STENCIL  , GraphicsContext3D::UNSIGNED_INT_24_8             , 0                                        , 0                                              , 0                            , 0                       );
4353     INTERNAL_FORMAT_CASE(DEPTH24_STENCIL8  , DEPTH_STENCIL  , GraphicsContext3D::UNSIGNED_INT_24_8             , 0                                        , 0                                              , 0                            , 0                       );
4354     INTERNAL_FORMAT_CASE(DEPTH32F_STENCIL8 , DEPTH_STENCIL  , GraphicsContext3D::FLOAT_32_UNSIGNED_INT_24_8_REV, 0                                        , 0                                              , 0                            , 0                       );
4355     case Extensions3D::SRGB_EXT:
4356         if (format != internalFormat) {
4357             synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, functionName, &quot;format and internalformat must match&quot;);
4358             return false;
4359         }
4360         if (type != GraphicsContext3D::UNSIGNED_BYTE &amp;&amp; type != GraphicsContext3D::UNSIGNED_SHORT_5_6_5 &amp;&amp; type != GraphicsContext3D::FLOAT &amp;&amp; type != GraphicsContext3D::HALF_FLOAT_OES &amp;&amp; type != GraphicsContext3D::HALF_FLOAT) {
4361             synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, functionName, &quot;invalid type for internal format&quot;);
4362             return false;
4363         }
4364         break;
4365     case Extensions3D::SRGB_ALPHA_EXT:
4366         if (format != internalFormat) {
4367             synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, functionName, &quot;format and internalformat must match&quot;);
4368             return false;
4369         }
4370         if (type != GraphicsContext3D::UNSIGNED_BYTE &amp;&amp; type != GraphicsContext3D::UNSIGNED_SHORT_4_4_4_4 &amp;&amp; type != GraphicsContext3D::UNSIGNED_SHORT_5_5_5_1 &amp;&amp; type != GraphicsContext3D::FLOAT &amp;&amp; type != GraphicsContext3D::HALF_FLOAT_OES &amp;&amp; type != GraphicsContext3D::HALF_FLOAT) {
4371             synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, functionName, &quot;invalid type for internal format&quot;);
4372             return false;
4373         }
4374         break;
4375     default:
4376         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, functionName, &quot;Unknown internal format&quot;);
4377         return false;
4378     }
4379 #undef INTERNAL_FORMAT_CASE
4380 
4381     return true;
4382 }
4383 
4384 void WebGLRenderingContextBase::texSubImage2DBase(GC3Denum target, GC3Dint level, GC3Dint xoffset, GC3Dint yoffset, GC3Dsizei width, GC3Dsizei height, GC3Denum internalFormat, GC3Denum format, GC3Denum type, const void* pixels)
4385 {
4386     ASSERT(!isContextLost());
4387     ASSERT(validateTexFuncParameters(&quot;texSubImage2D&quot;, TexSubImage, target, level, internalFormat, width, height, 0, format, type));
4388     ASSERT(validateSize(&quot;texSubImage2D&quot;, xoffset, yoffset));
4389     ASSERT(validateSettableTexInternalFormat(&quot;texSubImage2D&quot;, internalFormat));
4390     auto tex = validateTextureBinding(&quot;texSubImage2D&quot;, target, true);
4391     if (!tex) {
4392         ASSERT_NOT_REACHED();
4393         return;
4394     }
4395     ASSERT((xoffset + width) &gt;= 0);
4396     ASSERT((yoffset + height) &gt;= 0);
4397     ASSERT(tex-&gt;getWidth(target, level) &gt;= (xoffset + width));
4398     ASSERT(tex-&gt;getHeight(target, level) &gt;= (yoffset + height));
4399     ASSERT_UNUSED(internalFormat, tex-&gt;getInternalFormat(target, level) == internalFormat);
4400     m_context-&gt;texSubImage2D(target, level, xoffset, yoffset, width, height, format, type, pixels);
4401 }
4402 
4403 void WebGLRenderingContextBase::copyTexImage2D(GC3Denum target, GC3Dint level, GC3Denum internalFormat, GC3Dint x, GC3Dint y, GC3Dsizei width, GC3Dsizei height, GC3Dint border)
4404 {
4405     if (isContextLostOrPending())
4406         return;
4407     if (!validateTexFuncParameters(&quot;copyTexImage2D&quot;, CopyTexImage, target, level, internalFormat, width, height, border, internalFormat, GraphicsContext3D::UNSIGNED_BYTE))
4408         return;
4409     if (!validateSettableTexInternalFormat(&quot;copyTexImage2D&quot;, internalFormat))
4410         return;
4411     auto tex = validateTextureBinding(&quot;copyTexImage2D&quot;, target, true);
4412     if (!tex)
4413         return;
4414     if (!isTexInternalFormatColorBufferCombinationValid(internalFormat, getBoundFramebufferColorFormat())) {
4415         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;copyTexImage2D&quot;, &quot;framebuffer is incompatible format&quot;);
4416         return;
4417     }
4418     if (!isGLES2NPOTStrict() &amp;&amp; level &amp;&amp; WebGLTexture::isNPOT(width, height)) {
4419         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;copyTexImage2D&quot;, &quot;level &gt; 0 not power of 2&quot;);
4420         return;
4421     }
4422     const char* reason = &quot;framebuffer incomplete&quot;;
4423     if (m_framebufferBinding &amp;&amp; !m_framebufferBinding-&gt;onAccess(graphicsContext3D(), &amp;reason)) {
4424         synthesizeGLError(GraphicsContext3D::INVALID_FRAMEBUFFER_OPERATION, &quot;copyTexImage2D&quot;, reason);
4425         return;
4426     }
4427     clearIfComposited();
4428 
4429     GC3Dint clippedX, clippedY;
4430     GC3Dsizei clippedWidth, clippedHeight;
4431     if (clip2D(x, y, width, height, getBoundFramebufferWidth(), getBoundFramebufferHeight(), &amp;clippedX, &amp;clippedY, &amp;clippedWidth, &amp;clippedHeight)) {
4432         m_context-&gt;texImage2DResourceSafe(target, level, internalFormat, width, height, border,
4433             internalFormat, GraphicsContext3D::UNSIGNED_BYTE, m_unpackAlignment);
4434         if (clippedWidth &gt; 0 &amp;&amp; clippedHeight &gt; 0) {
4435             m_context-&gt;copyTexSubImage2D(target, level, clippedX - x, clippedY - y,
4436                 clippedX, clippedY, clippedWidth, clippedHeight);
4437         }
4438     } else
4439         m_context-&gt;copyTexImage2D(target, level, internalFormat, x, y, width, height, border);
4440 
4441     // FIXME: if the framebuffer is not complete, none of the below should be executed.
4442     tex-&gt;setLevelInfo(target, level, internalFormat, width, height, GraphicsContext3D::UNSIGNED_BYTE);
4443 }
4444 
4445 static bool isRGBFormat(GC3Denum internalFormat)
4446 {
4447     return internalFormat == GraphicsContext3D::RGB
4448         || internalFormat == GraphicsContext3D::RGBA
4449         || internalFormat == GraphicsContext3D::RGB8
4450         || internalFormat == GraphicsContext3D::RGBA8;
4451 }
4452 
4453 ExceptionOr&lt;void&gt; WebGLRenderingContextBase::texImage2D(GC3Denum target, GC3Dint level, GC3Denum internalformat, GC3Denum format, GC3Denum type, Optional&lt;TexImageSource&gt; source)
4454 {
4455     if (!source) {
4456         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;texImage2D&quot;, &quot;source is null&quot;);
4457         return { };
4458     }
4459 
4460     auto visitor = WTF::makeVisitor([&amp;](const RefPtr&lt;ImageBitmap&gt;&amp; bitmap) -&gt; ExceptionOr&lt;void&gt; {
4461         if (isContextLostOrPending() || !validateTexFunc(&quot;texImage2D&quot;, TexImage, SourceImageBitmap, target, level, internalformat, bitmap-&gt;width(), bitmap-&gt;height(), 0, format, type, 0, 0))
4462             return { };
4463 
4464         ImageBuffer* buffer = bitmap-&gt;buffer();
4465         if (!buffer)
4466             return { };
4467 
4468         auto texture = validateTextureBinding(&quot;texImage2D&quot;, target, true);
4469         // If possible, copy from the bitmap directly to the texture
4470         // via the GPU, without a read-back to system memory.
4471         //
4472         // FIXME: restriction of (RGB || RGBA)/UNSIGNED_BYTE should be lifted when
4473         // ImageBuffer::copyToPlatformTexture implementations are fully functional.
4474         if (texture
4475             &amp;&amp; (format == GraphicsContext3D::RGB || format == GraphicsContext3D::RGBA)
4476             &amp;&amp; type == GraphicsContext3D::UNSIGNED_BYTE) {
4477             auto textureInternalFormat = texture-&gt;getInternalFormat(target, level);
4478             if (isRGBFormat(textureInternalFormat) || !texture-&gt;isValid(target, level)) {
4479                 if (buffer-&gt;copyToPlatformTexture(*m_context.get(), target, texture-&gt;object(), internalformat, m_unpackPremultiplyAlpha, m_unpackFlipY)) {
4480                     texture-&gt;setLevelInfo(target, level, internalformat, bitmap-&gt;width(), bitmap-&gt;height(), type);
4481                     return { };
4482                 }
4483             }
4484         }
4485 
4486         // Normal pure SW path.
4487         RefPtr&lt;Image&gt; image = buffer-&gt;copyImage(ImageBuffer::fastCopyImageMode());
4488         if (image)
4489             texImage2DImpl(target, level, internalformat, format, type, image.get(), GraphicsContext3D::HtmlDomImage, m_unpackFlipY, m_unpackPremultiplyAlpha);
4490         return { };
4491     }, [&amp;](const RefPtr&lt;ImageData&gt;&amp; pixels) -&gt; ExceptionOr&lt;void&gt; {
4492         if (isContextLostOrPending() || !validateTexFunc(&quot;texImage2D&quot;, TexImage, SourceImageData, target, level, internalformat, pixels-&gt;width(), pixels-&gt;height(), 0, format, type, 0, 0))
4493             return { };
4494         Vector&lt;uint8_t&gt; data;
4495         bool needConversion = true;
4496         // The data from ImageData is always of format RGBA8.
4497         // No conversion is needed if destination format is RGBA and type is USIGNED_BYTE and no Flip or Premultiply operation is required.
4498         if (!m_unpackFlipY &amp;&amp; !m_unpackPremultiplyAlpha &amp;&amp; format == GraphicsContext3D::RGBA &amp;&amp; type == GraphicsContext3D::UNSIGNED_BYTE)
4499             needConversion = false;
4500         else {
4501             if (!m_context-&gt;extractImageData(pixels.get(), format, type, m_unpackFlipY, m_unpackPremultiplyAlpha, data)) {
4502                 synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;texImage2D&quot;, &quot;bad image data&quot;);
4503                 return { };
4504             }
4505         }
4506         if (m_unpackAlignment != 1)
4507             m_context-&gt;pixelStorei(GraphicsContext3D::UNPACK_ALIGNMENT, 1);
4508         texImage2DBase(target, level, internalformat, pixels-&gt;width(), pixels-&gt;height(), 0, format, type, needConversion ? data.data() : pixels-&gt;data()-&gt;data());
4509         if (m_unpackAlignment != 1)
4510             m_context-&gt;pixelStorei(GraphicsContext3D::UNPACK_ALIGNMENT, m_unpackAlignment);
4511         return { };
4512     }, [&amp;](const RefPtr&lt;HTMLImageElement&gt;&amp; image) -&gt; ExceptionOr&lt;void&gt; {
4513         if (isContextLostOrPending())
4514             return { };
4515         auto validationResult = validateHTMLImageElement(&quot;texImage2D&quot;, image.get());
4516         if (validationResult.hasException())
4517             return validationResult.releaseException();
4518         if (!validationResult.returnValue())
4519             return { };
4520 
4521         RefPtr&lt;Image&gt; imageForRender = image-&gt;cachedImage()-&gt;imageForRenderer(image-&gt;renderer());
4522         if (!imageForRender)
4523             return { };
4524 
4525         if (imageForRender-&gt;isSVGImage())
4526             imageForRender = drawImageIntoBuffer(*imageForRender, image-&gt;width(), image-&gt;height(), 1);
4527 
4528         if (!imageForRender || !validateTexFunc(&quot;texImage2D&quot;, TexImage, SourceHTMLImageElement, target, level, internalformat, imageForRender-&gt;width(), imageForRender-&gt;height(), 0, format, type, 0, 0))
4529             return { };
4530 
4531         texImage2DImpl(target, level, internalformat, format, type, imageForRender.get(), GraphicsContext3D::HtmlDomImage, m_unpackFlipY, m_unpackPremultiplyAlpha);
4532         return { };
4533     }, [&amp;](const RefPtr&lt;HTMLCanvasElement&gt;&amp; canvas) -&gt; ExceptionOr&lt;void&gt; {
4534         if (isContextLostOrPending())
4535             return { };
4536         auto validationResult = validateHTMLCanvasElement(&quot;texImage2D&quot;, canvas.get());
4537         if (validationResult.hasException())
4538             return validationResult.releaseException();
4539         if (!validationResult.returnValue())
4540             return { };
4541         if (!validateTexFunc(&quot;texImage2D&quot;, TexImage, SourceHTMLCanvasElement, target, level, internalformat, canvas-&gt;width(), canvas-&gt;height(), 0, format, type, 0, 0))
4542             return { };
4543 
4544         auto texture = validateTextureBinding(&quot;texImage2D&quot;, target, true);
4545         // If possible, copy from the canvas element directly to the texture
4546         // via the GPU, without a read-back to system memory.
4547         //
4548         // FIXME: restriction of (RGB || RGBA)/UNSIGNED_BYTE should be lifted when
4549         // ImageBuffer::copyToPlatformTexture implementations are fully functional.
4550         if (texture
4551             &amp;&amp; (format == GraphicsContext3D::RGB || format == GraphicsContext3D::RGBA)
4552             &amp;&amp; type == GraphicsContext3D::UNSIGNED_BYTE) {
4553             auto textureInternalFormat = texture-&gt;getInternalFormat(target, level);
4554             if (isRGBFormat(textureInternalFormat) || !texture-&gt;isValid(target, level)) {
4555                 ImageBuffer* buffer = canvas-&gt;buffer();
4556                 if (buffer &amp;&amp; buffer-&gt;copyToPlatformTexture(*m_context.get(), target, texture-&gt;object(), internalformat, m_unpackPremultiplyAlpha, m_unpackFlipY)) {
4557                     texture-&gt;setLevelInfo(target, level, internalformat, canvas-&gt;width(), canvas-&gt;height(), type);
4558                     return { };
4559                 }
4560             }
4561         }
4562 
4563         RefPtr&lt;ImageData&gt; imageData = canvas-&gt;getImageData();
4564         if (imageData)
4565             texImage2D(target, level, internalformat, format, type, TexImageSource(imageData.get()));
4566         else
4567             texImage2DImpl(target, level, internalformat, format, type, canvas-&gt;copiedImage(), GraphicsContext3D::HtmlDomCanvas, m_unpackFlipY, m_unpackPremultiplyAlpha);
4568         return { };
4569     }
4570 #if ENABLE(VIDEO)
4571     , [&amp;](const RefPtr&lt;HTMLVideoElement&gt;&amp; video) -&gt; ExceptionOr&lt;void&gt; {
4572         if (isContextLostOrPending())
4573             return { };
4574         auto validationResult = validateHTMLVideoElement(&quot;texImage2D&quot;, video.get());
4575         if (validationResult.hasException())
4576             return validationResult.releaseException();
4577         if (!validationResult.returnValue())
4578             return { };
4579         if (!validateTexFunc(&quot;texImage2D&quot;, TexImage, SourceHTMLVideoElement, target, level, internalformat, video-&gt;videoWidth(), video-&gt;videoHeight(), 0, format, type, 0, 0))
4580             return { };
4581 
4582         // Go through the fast path doing a GPU-GPU textures copy without a readback to system memory if possible.
4583         // Otherwise, it will fall back to the normal SW path.
4584         // FIXME: The current restrictions require that format shoud be RGB or RGBA,
4585         // type should be UNSIGNED_BYTE and level should be 0. It may be lifted in the future.
4586         auto texture = validateTextureBinding(&quot;texImage2D&quot;, target, true);
4587         if (GraphicsContext3D::TEXTURE_2D == target &amp;&amp; texture
4588             &amp;&amp; (format == GraphicsContext3D::RGB || format == GraphicsContext3D::RGBA)
4589             &amp;&amp; type == GraphicsContext3D::UNSIGNED_BYTE
4590             &amp;&amp; !level) {
4591             auto textureInternalFormat = texture-&gt;getInternalFormat(target, level);
4592             if (isRGBFormat(textureInternalFormat) || !texture-&gt;isValid(target, level)) {
4593                 if (video-&gt;copyVideoTextureToPlatformTexture(m_context.get(), texture-&gt;object(), target, level, internalformat, format, type, m_unpackPremultiplyAlpha, m_unpackFlipY)) {
4594                     texture-&gt;setLevelInfo(target, level, internalformat, video-&gt;videoWidth(), video-&gt;videoHeight(), type);
4595                     return { };
4596                 }
4597             }
4598         }
4599 
4600         // Normal pure SW path.
4601         RefPtr&lt;Image&gt; image = videoFrameToImage(video.get(), ImageBuffer::fastCopyImageMode());
4602         if (!image)
4603             return { };
4604         texImage2DImpl(target, level, internalformat, format, type, image.get(), GraphicsContext3D::HtmlDomVideo, m_unpackFlipY, m_unpackPremultiplyAlpha);
4605         return { };
4606     }
4607 #endif
4608     );
4609 
4610     return WTF::visit(visitor, source.value());
4611 }
4612 
4613 RefPtr&lt;Image&gt; WebGLRenderingContextBase::drawImageIntoBuffer(Image&amp; image, int width, int height, int deviceScaleFactor)
4614 {
4615     IntSize size(width, height);
4616     size.scale(deviceScaleFactor);
4617     ImageBuffer* buf = m_generatedImageCache.imageBuffer(size);
4618     if (!buf) {
4619         synthesizeGLError(GraphicsContext3D::OUT_OF_MEMORY, &quot;texImage2D&quot;, &quot;out of memory&quot;);
4620         return nullptr;
4621     }
4622 
4623     FloatRect srcRect(FloatPoint(), image.size());
4624     FloatRect destRect(FloatPoint(), size);
4625     buf-&gt;context().drawImage(image, destRect, srcRect);
4626     return buf-&gt;copyImage(ImageBuffer::fastCopyImageMode());
4627 }
4628 
4629 #if ENABLE(VIDEO)
4630 
4631 RefPtr&lt;Image&gt; WebGLRenderingContextBase::videoFrameToImage(HTMLVideoElement* video, BackingStoreCopy backingStoreCopy)
4632 {
4633     IntSize size(video-&gt;videoWidth(), video-&gt;videoHeight());
4634     ImageBuffer* buf = m_generatedImageCache.imageBuffer(size);
4635     if (!buf) {
4636         synthesizeGLError(GraphicsContext3D::OUT_OF_MEMORY, &quot;texImage2D&quot;, &quot;out of memory&quot;);
4637         return nullptr;
4638     }
4639     FloatRect destRect(0, 0, size.width(), size.height());
4640     // FIXME: Turn this into a GPU-GPU texture copy instead of CPU readback.
4641     video-&gt;paintCurrentFrameInContext(buf-&gt;context(), destRect);
4642     return buf-&gt;copyImage(backingStoreCopy);
4643 }
4644 
4645 #endif
4646 
4647 void WebGLRenderingContextBase::texParameter(GC3Denum target, GC3Denum pname, GC3Dfloat paramf, GC3Dint parami, bool isFloat)
4648 {
4649     if (isContextLostOrPending())
4650         return;
4651     auto tex = validateTextureBinding(&quot;texParameter&quot;, target, false);
4652     if (!tex)
4653         return;
4654     switch (pname) {
4655     case GraphicsContext3D::TEXTURE_MIN_FILTER:
4656     case GraphicsContext3D::TEXTURE_MAG_FILTER:
4657         break;
4658     case GraphicsContext3D::TEXTURE_WRAP_S:
4659     case GraphicsContext3D::TEXTURE_WRAP_T:
4660         if ((isFloat &amp;&amp; paramf != GraphicsContext3D::CLAMP_TO_EDGE &amp;&amp; paramf != GraphicsContext3D::MIRRORED_REPEAT &amp;&amp; paramf != GraphicsContext3D::REPEAT)
4661             || (!isFloat &amp;&amp; parami != GraphicsContext3D::CLAMP_TO_EDGE &amp;&amp; parami != GraphicsContext3D::MIRRORED_REPEAT &amp;&amp; parami != GraphicsContext3D::REPEAT)) {
4662             synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;texParameter&quot;, &quot;invalid parameter&quot;);
4663             return;
4664         }
4665         break;
4666     case Extensions3D::TEXTURE_MAX_ANISOTROPY_EXT: // EXT_texture_filter_anisotropic
4667         if (!m_extTextureFilterAnisotropic) {
4668             synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;texParameter&quot;, &quot;invalid parameter, EXT_texture_filter_anisotropic not enabled&quot;);
4669             return;
4670         }
4671         break;
4672     default:
4673         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;texParameter&quot;, &quot;invalid parameter name&quot;);
4674         return;
4675     }
4676     if (isFloat) {
4677         tex-&gt;setParameterf(pname, paramf);
4678         m_context-&gt;texParameterf(target, pname, paramf);
4679     } else {
4680         tex-&gt;setParameteri(pname, parami);
4681         m_context-&gt;texParameteri(target, pname, parami);
4682     }
4683 }
4684 
4685 void WebGLRenderingContextBase::texParameterf(GC3Denum target, GC3Denum pname, GC3Dfloat param)
4686 {
4687     texParameter(target, pname, param, 0, true);
4688 }
4689 
4690 void WebGLRenderingContextBase::texParameteri(GC3Denum target, GC3Denum pname, GC3Dint param)
4691 {
4692     texParameter(target, pname, 0, param, false);
4693 }
4694 
4695 void WebGLRenderingContextBase::uniform1f(const WebGLUniformLocation* location, GC3Dfloat x)
4696 {
4697     if (isContextLostOrPending() || !location)
4698         return;
4699 
4700     if (location-&gt;program() != m_currentProgram) {
4701         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;uniform1f&quot;, &quot;location not for current program&quot;);
4702         return;
4703     }
4704 
4705     m_context-&gt;uniform1f(location-&gt;location(), x);
4706 }
4707 
4708 void WebGLRenderingContextBase::uniform2f(const WebGLUniformLocation* location, GC3Dfloat x, GC3Dfloat y)
4709 {
4710     if (isContextLostOrPending() || !location)
4711         return;
4712 
4713     if (location-&gt;program() != m_currentProgram) {
4714         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;uniform2f&quot;, &quot;location not for current program&quot;);
4715         return;
4716     }
4717 
4718     m_context-&gt;uniform2f(location-&gt;location(), x, y);
4719 }
4720 
4721 void WebGLRenderingContextBase::uniform3f(const WebGLUniformLocation* location, GC3Dfloat x, GC3Dfloat y, GC3Dfloat z)
4722 {
4723     if (isContextLostOrPending() || !location)
4724         return;
4725 
4726     if (location-&gt;program() != m_currentProgram) {
4727         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;uniform3f&quot;, &quot;location not for current program&quot;);
4728         return;
4729     }
4730 
4731     m_context-&gt;uniform3f(location-&gt;location(), x, y, z);
4732 }
4733 
4734 void WebGLRenderingContextBase::uniform4f(const WebGLUniformLocation* location, GC3Dfloat x, GC3Dfloat y, GC3Dfloat z, GC3Dfloat w)
4735 {
4736     if (isContextLostOrPending() || !location)
4737         return;
4738 
4739     if (location-&gt;program() != m_currentProgram) {
4740         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;uniform4f&quot;, &quot;location not for current program&quot;);
4741         return;
4742     }
4743 
4744     m_context-&gt;uniform4f(location-&gt;location(), x, y, z, w);
4745 }
4746 
4747 void WebGLRenderingContextBase::uniform1i(const WebGLUniformLocation* location, GC3Dint x)
4748 {
4749     if (isContextLostOrPending() || !location)
4750         return;
4751 
4752     if (location-&gt;program() != m_currentProgram) {
4753         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;uniform1i&quot;, &quot;location not for current program&quot;);
4754         return;
4755     }
4756 
4757     if ((location-&gt;type() == GraphicsContext3D::SAMPLER_2D || location-&gt;type() == GraphicsContext3D::SAMPLER_CUBE) &amp;&amp; x &gt;= (int)m_textureUnits.size()) {
4758         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;uniform1i&quot;, &quot;invalid texture unit&quot;);
4759         return;
4760     }
4761 
4762     m_context-&gt;uniform1i(location-&gt;location(), x);
4763 }
4764 
4765 void WebGLRenderingContextBase::uniform2i(const WebGLUniformLocation* location, GC3Dint x, GC3Dint y)
4766 {
4767     if (isContextLostOrPending() || !location)
4768         return;
4769 
4770     if (location-&gt;program() != m_currentProgram) {
4771         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;uniform2i&quot;, &quot;location not for current program&quot;);
4772         return;
4773     }
4774 
4775     m_context-&gt;uniform2i(location-&gt;location(), x, y);
4776 }
4777 
4778 void WebGLRenderingContextBase::uniform3i(const WebGLUniformLocation* location, GC3Dint x, GC3Dint y, GC3Dint z)
4779 {
4780     if (isContextLostOrPending() || !location)
4781         return;
4782 
4783     if (location-&gt;program() != m_currentProgram) {
4784         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;uniform3i&quot;, &quot;location not for current program&quot;);
4785         return;
4786     }
4787 
4788     m_context-&gt;uniform3i(location-&gt;location(), x, y, z);
4789 }
4790 
4791 void WebGLRenderingContextBase::uniform4i(const WebGLUniformLocation* location, GC3Dint x, GC3Dint y, GC3Dint z, GC3Dint w)
4792 {
4793     if (isContextLostOrPending() || !location)
4794         return;
4795 
4796     if (location-&gt;program() != m_currentProgram) {
4797         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;uniform4i&quot;, &quot;location not for current program&quot;);
4798         return;
4799     }
4800 
4801     m_context-&gt;uniform4i(location-&gt;location(), x, y, z, w);
4802 }
4803 
4804 void WebGLRenderingContextBase::uniform1fv(const WebGLUniformLocation* location, Float32List&amp;&amp; v)
4805 {
4806     if (isContextLostOrPending() || !validateUniformParameters(&quot;uniform1fv&quot;, location, v, 1))
4807         return;
4808 
4809     m_context-&gt;uniform1fv(location-&gt;location(), v.length(), v.data());
4810 }
4811 
4812 void WebGLRenderingContextBase::uniform2fv(const WebGLUniformLocation* location, Float32List&amp;&amp; v)
4813 {
4814     if (isContextLostOrPending() || !validateUniformParameters(&quot;uniform2fv&quot;, location, v, 2))
4815         return;
4816 
4817     m_context-&gt;uniform2fv(location-&gt;location(), v.length() / 2, v.data());
4818 }
4819 
4820 void WebGLRenderingContextBase::uniform3fv(const WebGLUniformLocation* location, Float32List&amp;&amp; v)
4821 {
4822     if (isContextLostOrPending() || !validateUniformParameters(&quot;uniform3fv&quot;, location, v, 3))
4823         return;
4824 
4825     m_context-&gt;uniform3fv(location-&gt;location(), v.length() / 3, v.data());
4826 }
4827 
4828 void WebGLRenderingContextBase::uniform4fv(const WebGLUniformLocation* location, Float32List&amp;&amp; v)
4829 {
4830     if (isContextLostOrPending() || !validateUniformParameters(&quot;uniform4fv&quot;, location, v, 4))
4831         return;
4832 
4833     m_context-&gt;uniform4fv(location-&gt;location(), v.length() / 4, v.data());
4834 }
4835 
4836 void WebGLRenderingContextBase::uniform1iv(const WebGLUniformLocation* location, Int32List&amp;&amp; v)
4837 {
4838     if (isContextLostOrPending() || !validateUniformParameters(&quot;uniform1iv&quot;, location, v, 1))
4839         return;
4840 
4841     auto data = v.data();
4842     auto length = v.length();
4843 
4844     if (location-&gt;type() == GraphicsContext3D::SAMPLER_2D || location-&gt;type() == GraphicsContext3D::SAMPLER_CUBE) {
4845         for (auto i = 0; i &lt; length; ++i) {
4846             if (data[i] &gt;= static_cast&lt;int&gt;(m_textureUnits.size())) {
4847                 LOG(WebGL, &quot;Texture unit size=%zu, v[%d]=%d. Location type = %04X.&quot;, m_textureUnits.size(), i, data[i], location-&gt;type());
4848                 synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;uniform1iv&quot;, &quot;invalid texture unit&quot;);
4849                 return;
4850             }
4851         }
4852     }
4853 
4854     m_context-&gt;uniform1iv(location-&gt;location(), length, data);
4855 }
4856 
4857 void WebGLRenderingContextBase::uniform2iv(const WebGLUniformLocation* location, Int32List&amp;&amp; v)
4858 {
4859     if (isContextLostOrPending() || !validateUniformParameters(&quot;uniform2iv&quot;, location, v, 2))
4860         return;
4861 
4862     m_context-&gt;uniform2iv(location-&gt;location(), v.length() / 2, v.data());
4863 }
4864 
4865 void WebGLRenderingContextBase::uniform3iv(const WebGLUniformLocation* location, Int32List&amp;&amp; v)
4866 {
4867     if (isContextLostOrPending() || !validateUniformParameters(&quot;uniform3iv&quot;, location, v, 3))
4868         return;
4869 
4870     m_context-&gt;uniform3iv(location-&gt;location(), v.length() / 3, v.data());
4871 }
4872 
4873 void WebGLRenderingContextBase::uniform4iv(const WebGLUniformLocation* location, Int32List&amp;&amp; v)
4874 {
4875     if (isContextLostOrPending() || !validateUniformParameters(&quot;uniform4iv&quot;, location, v, 4))
4876         return;
4877 
4878     m_context-&gt;uniform4iv(location-&gt;location(), v.length() / 4, v.data());
4879 }
4880 
4881 void WebGLRenderingContextBase::uniformMatrix2fv(const WebGLUniformLocation* location, GC3Dboolean transpose, Float32List&amp;&amp; v)
4882 {
4883     if (isContextLostOrPending() || !validateUniformMatrixParameters(&quot;uniformMatrix2fv&quot;, location, transpose, v, 4))
4884         return;
4885     m_context-&gt;uniformMatrix2fv(location-&gt;location(), v.length() / 4, transpose, v.data());
4886 }
4887 
4888 void WebGLRenderingContextBase::uniformMatrix3fv(const WebGLUniformLocation* location, GC3Dboolean transpose, Float32List&amp;&amp; v)
4889 {
4890     if (isContextLostOrPending() || !validateUniformMatrixParameters(&quot;uniformMatrix3fv&quot;, location, transpose, v, 9))
4891         return;
4892     m_context-&gt;uniformMatrix3fv(location-&gt;location(), v.length() / 9, transpose, v.data());
4893 }
4894 
4895 void WebGLRenderingContextBase::uniformMatrix4fv(const WebGLUniformLocation* location, GC3Dboolean transpose, Float32List&amp;&amp; v)
4896 {
4897     if (isContextLostOrPending() || !validateUniformMatrixParameters(&quot;uniformMatrix4fv&quot;, location, transpose, v, 16))
4898         return;
4899     m_context-&gt;uniformMatrix4fv(location-&gt;location(), v.length() / 16, transpose, v.data());
4900 }
4901 
4902 void WebGLRenderingContextBase::useProgram(WebGLProgram* program)
4903 {
4904     bool deleted;
4905     if (!checkObjectToBeBound(&quot;useProgram&quot;, program, deleted))
4906         return;
4907     if (deleted)
4908         program = 0;
4909     if (program &amp;&amp; !program-&gt;getLinkStatus()) {
4910         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;useProgram&quot;, &quot;program not valid&quot;);
4911         return;
4912     }
4913     if (m_currentProgram != program) {
4914         if (m_currentProgram)
4915             m_currentProgram-&gt;onDetached(graphicsContext3D());
4916         m_currentProgram = program;
4917         m_context-&gt;useProgram(objectOrZero(program));
4918         if (program)
4919             program-&gt;onAttached();
4920     }
4921 }
4922 
4923 void WebGLRenderingContextBase::validateProgram(WebGLProgram* program)
4924 {
4925     if (isContextLostOrPending() || !validateWebGLObject(&quot;validateProgram&quot;, program))
4926         return;
4927     m_context-&gt;validateProgram(objectOrZero(program));
4928 }
4929 
4930 void WebGLRenderingContextBase::vertexAttrib1f(GC3Duint index, GC3Dfloat v0)
4931 {
4932     vertexAttribfImpl(&quot;vertexAttrib1f&quot;, index, 1, v0, 0.0f, 0.0f, 1.0f);
4933 }
4934 
4935 void WebGLRenderingContextBase::vertexAttrib2f(GC3Duint index, GC3Dfloat v0, GC3Dfloat v1)
4936 {
4937     vertexAttribfImpl(&quot;vertexAttrib2f&quot;, index, 2, v0, v1, 0.0f, 1.0f);
4938 }
4939 
4940 void WebGLRenderingContextBase::vertexAttrib3f(GC3Duint index, GC3Dfloat v0, GC3Dfloat v1, GC3Dfloat v2)
4941 {
4942     vertexAttribfImpl(&quot;vertexAttrib3f&quot;, index, 3, v0, v1, v2, 1.0f);
4943 }
4944 
4945 void WebGLRenderingContextBase::vertexAttrib4f(GC3Duint index, GC3Dfloat v0, GC3Dfloat v1, GC3Dfloat v2, GC3Dfloat v3)
4946 {
4947     vertexAttribfImpl(&quot;vertexAttrib4f&quot;, index, 4, v0, v1, v2, v3);
4948 }
4949 
4950 void WebGLRenderingContextBase::vertexAttrib1fv(GC3Duint index, Float32List&amp;&amp; v)
4951 {
4952     vertexAttribfvImpl(&quot;vertexAttrib1fv&quot;, index, WTFMove(v), 1);
4953 }
4954 
4955 void WebGLRenderingContextBase::vertexAttrib2fv(GC3Duint index, Float32List&amp;&amp; v)
4956 {
4957     vertexAttribfvImpl(&quot;vertexAttrib2fv&quot;, index, WTFMove(v), 2);
4958 }
4959 
4960 void WebGLRenderingContextBase::vertexAttrib3fv(GC3Duint index, Float32List&amp;&amp; v)
4961 {
4962     vertexAttribfvImpl(&quot;vertexAttrib3fv&quot;, index, WTFMove(v), 3);
4963 }
4964 
4965 void WebGLRenderingContextBase::vertexAttrib4fv(GC3Duint index, Float32List&amp;&amp; v)
4966 {
4967     vertexAttribfvImpl(&quot;vertexAttrib4fv&quot;, index, WTFMove(v), 4);
4968 }
4969 
4970 void WebGLRenderingContextBase::vertexAttribPointer(GC3Duint index, GC3Dint size, GC3Denum type, GC3Dboolean normalized, GC3Dsizei stride, long long offset)
4971 {
4972     if (isContextLostOrPending())
4973         return;
4974     switch (type) {
4975     case GraphicsContext3D::BYTE:
4976     case GraphicsContext3D::UNSIGNED_BYTE:
4977     case GraphicsContext3D::SHORT:
4978     case GraphicsContext3D::UNSIGNED_SHORT:
4979     case GraphicsContext3D::FLOAT:
4980         break;
4981     default:
4982         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;vertexAttribPointer&quot;, &quot;invalid type&quot;);
4983         return;
4984     }
4985     if (index &gt;= m_maxVertexAttribs) {
4986         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;vertexAttribPointer&quot;, &quot;index out of range&quot;);
4987         return;
4988     }
4989     if (size &lt; 1 || size &gt; 4) {
4990         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;vertexAttribPointer&quot;, &quot;bad size&quot;);
4991         return;
4992     }
4993     if (stride &lt; 0 || stride &gt; 255) {
4994         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;vertexAttribPointer&quot;, &quot;bad stride&quot;);
4995         return;
4996     }
4997     if (offset &lt; 0 || offset &gt; std::numeric_limits&lt;int32_t&gt;::max()) {
4998         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;vertexAttribPointer&quot;, &quot;bad offset&quot;);
4999         return;
5000     }
<a name="40" id="anc40"></a><span class="line-modified">5001     if (!m_boundArrayBuffer) {</span>
5002         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;vertexAttribPointer&quot;, &quot;no bound ARRAY_BUFFER&quot;);
5003         return;
5004     }
5005     // Determine the number of elements the bound buffer can hold, given the offset, size, type and stride
5006     auto typeSize = sizeInBytes(type);
5007     if (!typeSize) {
5008         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;vertexAttribPointer&quot;, &quot;invalid type&quot;);
5009         return;
5010     }
5011     if ((stride % typeSize) || (static_cast&lt;GC3Dintptr&gt;(offset) % typeSize)) {
5012         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;vertexAttribPointer&quot;, &quot;stride or offset not valid for type&quot;);
5013         return;
5014     }
5015     GC3Dsizei bytesPerElement = size * typeSize;
5016 
<a name="41" id="anc41"></a><span class="line-modified">5017     m_boundVertexArrayObject-&gt;setVertexAttribState(index, bytesPerElement, size, type, normalized, stride, static_cast&lt;GC3Dintptr&gt;(offset), *m_boundArrayBuffer);</span>
5018     m_context-&gt;vertexAttribPointer(index, size, type, normalized, stride, static_cast&lt;GC3Dintptr&gt;(offset));
5019 }
5020 
5021 void WebGLRenderingContextBase::viewport(GC3Dint x, GC3Dint y, GC3Dsizei width, GC3Dsizei height)
5022 {
5023     if (isContextLostOrPending())
5024         return;
5025     if (!validateSize(&quot;viewport&quot;, width, height))
5026         return;
5027     m_context-&gt;viewport(x, y, width, height);
5028 }
5029 
5030 void WebGLRenderingContextBase::forceLostContext(WebGLRenderingContextBase::LostContextMode mode)
5031 {
5032     if (isContextLostOrPending()) {
5033         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;loseContext&quot;, &quot;context already lost&quot;);
5034         return;
5035     }
5036 
5037     m_contextGroup-&gt;loseContextGroup(mode);
5038 }
5039 
<a name="42" id="anc42"></a><span class="line-removed">5040 void WebGLRenderingContextBase::recycleContext()</span>
<span class="line-removed">5041 {</span>
<span class="line-removed">5042     printToConsole(MessageLevel::Error, &quot;There are too many active WebGL contexts on this page, the oldest context will be lost.&quot;);</span>
<span class="line-removed">5043     // Using SyntheticLostContext means the developer won&#39;t be able to force the restoration</span>
<span class="line-removed">5044     // of the context by calling preventDefault() in a &quot;webglcontextlost&quot; event handler.</span>
<span class="line-removed">5045     forceLostContext(SyntheticLostContext);</span>
<span class="line-removed">5046     destroyGraphicsContext3D();</span>
<span class="line-removed">5047 }</span>
<span class="line-removed">5048 </span>
5049 void WebGLRenderingContextBase::loseContextImpl(WebGLRenderingContextBase::LostContextMode mode)
5050 {
5051     if (isContextLost())
5052         return;
5053 
5054     m_contextLost = true;
5055     m_contextLostMode = mode;
5056 
5057     if (mode == RealLostContext) {
5058         // Inform the embedder that a lost context was received. In response, the embedder might
5059         // decide to take action such as asking the user for permission to use WebGL again.
5060         auto* canvas = htmlCanvas();
5061         if (canvas) {
5062             if (RefPtr&lt;Frame&gt; frame = canvas-&gt;document().frame())
5063                 frame-&gt;loader().client().didLoseWebGLContext(m_context-&gt;getExtensions().getGraphicsResetStatusARB());
5064         }
5065     }
5066 
5067     detachAndRemoveAllObjects();
5068 
5069     // There is no direct way to clear errors from a GL implementation and
5070     // looping until getError() becomes NO_ERROR might cause an infinite loop if
5071     // the driver or context implementation had a bug. So, loop a reasonably
5072     // large number of times to clear any existing errors.
5073     for (int i = 0; i &lt; 100; ++i) {
5074         if (m_context-&gt;getError() == GraphicsContext3D::NO_ERROR)
5075             break;
5076     }
5077     ConsoleDisplayPreference display = (mode == RealLostContext) ? DisplayInConsole: DontDisplayInConsole;
5078     synthesizeGLError(GraphicsContext3D::CONTEXT_LOST_WEBGL, &quot;loseContext&quot;, &quot;context lost&quot;, display);
5079 
5080     // Don&#39;t allow restoration unless the context lost event has both been
5081     // dispatched and its default behavior prevented.
5082     m_restoreAllowed = false;
5083 
5084     // Always defer the dispatch of the context lost event, to implement
5085     // the spec behavior of queueing a task.
5086     m_dispatchContextLostEventTimer.startOneShot(0_s);
5087 }
5088 
5089 void WebGLRenderingContextBase::forceRestoreContext()
5090 {
5091     if (!isContextLostOrPending()) {
5092         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;restoreContext&quot;, &quot;context not lost&quot;);
5093         return;
5094     }
5095 
5096     if (!m_restoreAllowed) {
5097         if (m_contextLostMode == SyntheticLostContext)
5098             synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;restoreContext&quot;, &quot;context restoration not allowed&quot;);
5099         return;
5100     }
5101 
5102     if (!m_restoreTimer.isActive())
5103         m_restoreTimer.startOneShot(0_s);
5104 }
5105 
5106 PlatformLayer* WebGLRenderingContextBase::platformLayer() const
5107 {
5108     return (!isContextLost() &amp;&amp; !m_isPendingPolicyResolution) ? m_context-&gt;platformLayer() : 0;
5109 }
5110 
5111 void WebGLRenderingContextBase::removeSharedObject(WebGLSharedObject&amp; object)
5112 {
5113     if (m_isPendingPolicyResolution)
5114         return;
5115 
5116     m_contextGroup-&gt;removeObject(object);
5117 }
5118 
5119 void WebGLRenderingContextBase::addSharedObject(WebGLSharedObject&amp; object)
5120 {
5121     if (m_isPendingPolicyResolution)
5122         return;
5123 
5124     ASSERT(!isContextLost());
5125     m_contextGroup-&gt;addObject(object);
5126 }
5127 
5128 void WebGLRenderingContextBase::removeContextObject(WebGLContextObject&amp; object)
5129 {
5130     if (m_isPendingPolicyResolution)
5131         return;
5132 
5133     m_contextObjects.remove(&amp;object);
5134 }
5135 
5136 void WebGLRenderingContextBase::addContextObject(WebGLContextObject&amp; object)
5137 {
5138     if (m_isPendingPolicyResolution)
5139         return;
5140 
5141     ASSERT(!isContextLost());
5142     m_contextObjects.add(&amp;object);
5143 }
5144 
5145 void WebGLRenderingContextBase::detachAndRemoveAllObjects()
5146 {
5147     if (m_isPendingPolicyResolution)
5148         return;
5149 
5150     while (m_contextObjects.size() &gt; 0) {
5151         HashSet&lt;WebGLContextObject*&gt;::iterator it = m_contextObjects.begin();
5152         (*it)-&gt;detachContext();
5153     }
5154 }
5155 
5156 bool WebGLRenderingContextBase::hasPendingActivity() const
5157 {
5158     return false;
5159 }
5160 
5161 void WebGLRenderingContextBase::stop()
5162 {
5163     if (!isContextLost() &amp;&amp; !m_isPendingPolicyResolution) {
5164         forceLostContext(SyntheticLostContext);
5165         destroyGraphicsContext3D();
5166     }
5167 }
5168 
5169 const char* WebGLRenderingContextBase::activeDOMObjectName() const
5170 {
5171     return &quot;WebGLRenderingContext&quot;;
5172 }
5173 
5174 bool WebGLRenderingContextBase::canSuspendForDocumentSuspension() const
5175 {
5176     // FIXME: We should try and do better here.
5177     return false;
5178 }
5179 
5180 bool WebGLRenderingContextBase::getBooleanParameter(GC3Denum pname)
5181 {
5182     GC3Dboolean value = 0;
5183     m_context-&gt;getBooleanv(pname, &amp;value);
5184     return value;
5185 }
5186 
5187 Vector&lt;bool&gt; WebGLRenderingContextBase::getBooleanArrayParameter(GC3Denum pname)
5188 {
5189     if (pname != GraphicsContext3D::COLOR_WRITEMASK) {
5190         notImplemented();
5191         return { };
5192     }
5193     GC3Dboolean value[4] = { 0 };
5194     m_context-&gt;getBooleanv(pname, value);
5195     Vector&lt;bool&gt; vector(4);
5196     for (unsigned i = 0; i &lt; 4; ++i)
5197         vector[i] = value[i];
5198     return vector;
5199 }
5200 
5201 float WebGLRenderingContextBase::getFloatParameter(GC3Denum pname)
5202 {
5203     GC3Dfloat value = 0;
5204     m_context-&gt;getFloatv(pname, &amp;value);
5205     return value;
5206 }
5207 
5208 int WebGLRenderingContextBase::getIntParameter(GC3Denum pname)
5209 {
5210     GC3Dint value = 0;
5211     m_context-&gt;getIntegerv(pname, &amp;value);
5212     return value;
5213 }
5214 
5215 unsigned WebGLRenderingContextBase::getUnsignedIntParameter(GC3Denum pname)
5216 {
5217     GC3Dint value = 0;
5218     m_context-&gt;getIntegerv(pname, &amp;value);
5219     return value;
5220 }
5221 
5222 long long WebGLRenderingContextBase::getInt64Parameter(GC3Denum pname)
5223 {
5224     GC3Dint64 value = 0;
5225     m_context-&gt;getInteger64v(pname, &amp;value);
5226     return value;
5227 }
5228 
5229 RefPtr&lt;Float32Array&gt; WebGLRenderingContextBase::getWebGLFloatArrayParameter(GC3Denum pname)
5230 {
5231     GC3Dfloat value[4] = {0};
5232     m_context-&gt;getFloatv(pname, value);
5233     unsigned length = 0;
5234     switch (pname) {
5235     case GraphicsContext3D::ALIASED_POINT_SIZE_RANGE:
5236     case GraphicsContext3D::ALIASED_LINE_WIDTH_RANGE:
5237     case GraphicsContext3D::DEPTH_RANGE:
5238         length = 2;
5239         break;
5240     case GraphicsContext3D::BLEND_COLOR:
5241     case GraphicsContext3D::COLOR_CLEAR_VALUE:
5242         length = 4;
5243         break;
5244     default:
5245         notImplemented();
5246     }
5247     return Float32Array::tryCreate(value, length);
5248 }
5249 
5250 RefPtr&lt;Int32Array&gt; WebGLRenderingContextBase::getWebGLIntArrayParameter(GC3Denum pname)
5251 {
5252     GC3Dint value[4] = {0};
5253     m_context-&gt;getIntegerv(pname, value);
5254     unsigned length = 0;
5255     switch (pname) {
5256     case GraphicsContext3D::MAX_VIEWPORT_DIMS:
5257         length = 2;
5258         break;
5259     case GraphicsContext3D::SCISSOR_BOX:
5260     case GraphicsContext3D::VIEWPORT:
5261         length = 4;
5262         break;
5263     default:
5264         notImplemented();
5265     }
5266     return Int32Array::tryCreate(value, length);
5267 }
5268 
5269 bool WebGLRenderingContextBase::checkTextureCompleteness(const char* functionName, bool prepareToDraw)
5270 {
5271     bool resetActiveUnit = false;
5272     bool usesAtLeastOneBlackTexture = false;
5273     WebGLTexture::TextureExtensionFlag extensions = textureExtensionFlags();
5274 
5275     Vector&lt;unsigned&gt; noLongerUnrenderable;
5276     for (unsigned badTexture : m_unrenderableTextureUnits) {
5277         ASSERT(badTexture &lt; m_textureUnits.size());
5278         auto&amp; textureUnit = m_textureUnits[badTexture];
5279         bool needsToUseBlack2DTexture = textureUnit.texture2DBinding &amp;&amp; textureUnit.texture2DBinding-&gt;needToUseBlackTexture(extensions);
5280         bool needsToUseBlack3DTexture = textureUnit.textureCubeMapBinding &amp;&amp; textureUnit.textureCubeMapBinding-&gt;needToUseBlackTexture(extensions);
5281 
5282         if (!needsToUseBlack2DTexture &amp;&amp; !needsToUseBlack3DTexture) {
5283             noLongerUnrenderable.append(badTexture);
5284             continue;
5285         }
5286 
5287         usesAtLeastOneBlackTexture = true;
5288 
5289         if (badTexture != m_activeTextureUnit) {
5290             m_context-&gt;activeTexture(badTexture + GraphicsContext3D::TEXTURE0);
5291             resetActiveUnit = true;
5292         } else if (resetActiveUnit) {
5293             m_context-&gt;activeTexture(badTexture + GraphicsContext3D::TEXTURE0);
5294             resetActiveUnit = false;
5295         }
5296         RefPtr&lt;WebGLTexture&gt; tex2D;
5297         RefPtr&lt;WebGLTexture&gt; texCubeMap;
5298         if (prepareToDraw) {
5299             printToConsole(MessageLevel::Error, makeString(&quot;WebGL: &quot;, functionName, &quot;: texture bound to texture unit &quot;, badTexture,
5300                 &quot; is not renderable. It maybe non-power-of-2 and have incompatible texture filtering or is not &#39;texture complete&#39;,&quot;
5301                 &quot; or it is a float/half-float type with linear filtering and without the relevant float/half-float linear extension enabled.&quot;));
5302             tex2D = m_blackTexture2D.get();
5303             texCubeMap = m_blackTextureCubeMap.get();
5304         } else {
5305             tex2D = textureUnit.texture2DBinding.get();
5306             texCubeMap = textureUnit.textureCubeMapBinding.get();
5307         }
5308         if (needsToUseBlack2DTexture)
5309             m_context-&gt;bindTexture(GraphicsContext3D::TEXTURE_2D, objectOrZero(tex2D.get()));
5310         if (needsToUseBlack3DTexture)
5311             m_context-&gt;bindTexture(GraphicsContext3D::TEXTURE_CUBE_MAP, objectOrZero(texCubeMap.get()));
5312     }
5313     if (resetActiveUnit)
5314         m_context-&gt;activeTexture(m_activeTextureUnit + GraphicsContext3D::TEXTURE0);
5315 
5316     for (unsigned renderable : noLongerUnrenderable)
5317         m_unrenderableTextureUnits.remove(renderable);
5318 
5319     return usesAtLeastOneBlackTexture;
5320 }
5321 
5322 void WebGLRenderingContextBase::createFallbackBlackTextures1x1()
5323 {
5324     unsigned char black[] = {0, 0, 0, 255};
5325     m_blackTexture2D = createTexture();
5326     m_context-&gt;bindTexture(GraphicsContext3D::TEXTURE_2D, m_blackTexture2D-&gt;object());
5327     m_context-&gt;texImage2D(GraphicsContext3D::TEXTURE_2D, 0, GraphicsContext3D::RGBA, 1, 1,
5328                           0, GraphicsContext3D::RGBA, GraphicsContext3D::UNSIGNED_BYTE, black);
5329     m_context-&gt;bindTexture(GraphicsContext3D::TEXTURE_2D, 0);
5330     m_blackTextureCubeMap = createTexture();
5331     m_context-&gt;bindTexture(GraphicsContext3D::TEXTURE_CUBE_MAP, m_blackTextureCubeMap-&gt;object());
5332     m_context-&gt;texImage2D(GraphicsContext3D::TEXTURE_CUBE_MAP_POSITIVE_X, 0, GraphicsContext3D::RGBA, 1, 1,
5333                           0, GraphicsContext3D::RGBA, GraphicsContext3D::UNSIGNED_BYTE, black);
5334     m_context-&gt;texImage2D(GraphicsContext3D::TEXTURE_CUBE_MAP_NEGATIVE_X, 0, GraphicsContext3D::RGBA, 1, 1,
5335                           0, GraphicsContext3D::RGBA, GraphicsContext3D::UNSIGNED_BYTE, black);
5336     m_context-&gt;texImage2D(GraphicsContext3D::TEXTURE_CUBE_MAP_POSITIVE_Y, 0, GraphicsContext3D::RGBA, 1, 1,
5337                           0, GraphicsContext3D::RGBA, GraphicsContext3D::UNSIGNED_BYTE, black);
5338     m_context-&gt;texImage2D(GraphicsContext3D::TEXTURE_CUBE_MAP_NEGATIVE_Y, 0, GraphicsContext3D::RGBA, 1, 1,
5339                           0, GraphicsContext3D::RGBA, GraphicsContext3D::UNSIGNED_BYTE, black);
5340     m_context-&gt;texImage2D(GraphicsContext3D::TEXTURE_CUBE_MAP_POSITIVE_Z, 0, GraphicsContext3D::RGBA, 1, 1,
5341                           0, GraphicsContext3D::RGBA, GraphicsContext3D::UNSIGNED_BYTE, black);
5342     m_context-&gt;texImage2D(GraphicsContext3D::TEXTURE_CUBE_MAP_NEGATIVE_Z, 0, GraphicsContext3D::RGBA, 1, 1,
5343                           0, GraphicsContext3D::RGBA, GraphicsContext3D::UNSIGNED_BYTE, black);
5344     m_context-&gt;bindTexture(GraphicsContext3D::TEXTURE_CUBE_MAP, 0);
5345 }
5346 
5347 bool WebGLRenderingContextBase::isTexInternalFormatColorBufferCombinationValid(GC3Denum texInternalFormat,
5348                                                                            GC3Denum colorBufferFormat)
5349 {
5350     unsigned need = GraphicsContext3D::getChannelBitsByFormat(texInternalFormat);
5351     unsigned have = GraphicsContext3D::getChannelBitsByFormat(colorBufferFormat);
5352     return (need &amp; have) == need;
5353 }
5354 
5355 GC3Denum WebGLRenderingContextBase::getBoundFramebufferColorFormat()
5356 {
5357     if (m_framebufferBinding &amp;&amp; m_framebufferBinding-&gt;object())
5358         return m_framebufferBinding-&gt;getColorBufferFormat();
5359     if (m_attributes.alpha)
5360         return GraphicsContext3D::RGBA;
5361     return GraphicsContext3D::RGB;
5362 }
5363 
5364 int WebGLRenderingContextBase::getBoundFramebufferWidth()
5365 {
5366     if (m_framebufferBinding &amp;&amp; m_framebufferBinding-&gt;object())
5367         return m_framebufferBinding-&gt;getColorBufferWidth();
5368     return m_context-&gt;getInternalFramebufferSize().width();
5369 }
5370 
5371 int WebGLRenderingContextBase::getBoundFramebufferHeight()
5372 {
5373     if (m_framebufferBinding &amp;&amp; m_framebufferBinding-&gt;object())
5374         return m_framebufferBinding-&gt;getColorBufferHeight();
5375     return m_context-&gt;getInternalFramebufferSize().height();
5376 }
5377 
5378 RefPtr&lt;WebGLTexture&gt; WebGLRenderingContextBase::validateTextureBinding(const char* functionName, GC3Denum target, bool useSixEnumsForCubeMap)
5379 {
5380     RefPtr&lt;WebGLTexture&gt; texture;
5381     switch (target) {
5382     case GraphicsContext3D::TEXTURE_2D:
5383         texture = m_textureUnits[m_activeTextureUnit].texture2DBinding;
5384         break;
5385     case GraphicsContext3D::TEXTURE_CUBE_MAP_POSITIVE_X:
5386     case GraphicsContext3D::TEXTURE_CUBE_MAP_NEGATIVE_X:
5387     case GraphicsContext3D::TEXTURE_CUBE_MAP_POSITIVE_Y:
5388     case GraphicsContext3D::TEXTURE_CUBE_MAP_NEGATIVE_Y:
5389     case GraphicsContext3D::TEXTURE_CUBE_MAP_POSITIVE_Z:
5390     case GraphicsContext3D::TEXTURE_CUBE_MAP_NEGATIVE_Z:
5391         if (!useSixEnumsForCubeMap) {
5392             synthesizeGLError(GraphicsContext3D::INVALID_ENUM, functionName, &quot;invalid texture target&quot;);
5393             return nullptr;
5394         }
5395         texture = m_textureUnits[m_activeTextureUnit].textureCubeMapBinding;
5396         break;
5397     case GraphicsContext3D::TEXTURE_CUBE_MAP:
5398         if (useSixEnumsForCubeMap) {
5399             synthesizeGLError(GraphicsContext3D::INVALID_ENUM, functionName, &quot;invalid texture target&quot;);
5400             return nullptr;
5401         }
5402         texture = m_textureUnits[m_activeTextureUnit].textureCubeMapBinding;
5403         break;
5404     default:
5405         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, functionName, &quot;invalid texture target&quot;);
5406         return nullptr;
5407     }
5408 
5409     if (texture &amp;&amp; texture-&gt;needToUseBlackTexture(textureExtensionFlags()))
5410         m_unrenderableTextureUnits.add(m_activeTextureUnit);
5411 
5412     if (!texture)
5413         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, functionName, &quot;no texture&quot;);
5414     return texture;
5415 }
5416 
5417 bool WebGLRenderingContextBase::validateLocationLength(const char* functionName, const String&amp; string)
5418 {
5419     const unsigned maxWebGLLocationLength = 256;
5420     if (string.length() &gt; maxWebGLLocationLength) {
5421         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, functionName, &quot;location length &gt; 256&quot;);
5422         return false;
5423     }
5424     return true;
5425 }
5426 
5427 bool WebGLRenderingContextBase::validateSize(const char* functionName, GC3Dint x, GC3Dint y)
5428 {
5429     if (x &lt; 0 || y &lt; 0) {
5430         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, functionName, &quot;size &lt; 0&quot;);
5431         return false;
5432     }
5433     return true;
5434 }
5435 
5436 bool WebGLRenderingContextBase::validateString(const char* functionName, const String&amp; string)
5437 {
5438     for (size_t i = 0; i &lt; string.length(); ++i) {
5439         if (!validateCharacter(string[i])) {
5440             synthesizeGLError(GraphicsContext3D::INVALID_VALUE, functionName, &quot;string not ASCII&quot;);
5441             return false;
5442         }
5443     }
5444     return true;
5445 }
5446 
5447 bool WebGLRenderingContextBase::validateTexFuncLevel(const char* functionName, GC3Denum target, GC3Dint level)
5448 {
5449     if (level &lt; 0) {
5450         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, functionName, &quot;level &lt; 0&quot;);
5451         return false;
5452     }
5453     switch (target) {
5454     case GraphicsContext3D::TEXTURE_2D:
5455         if (level &gt;= m_maxTextureLevel) {
5456             synthesizeGLError(GraphicsContext3D::INVALID_VALUE, functionName, &quot;level out of range&quot;);
5457             return false;
5458         }
5459         break;
5460     case GraphicsContext3D::TEXTURE_CUBE_MAP_POSITIVE_X:
5461     case GraphicsContext3D::TEXTURE_CUBE_MAP_NEGATIVE_X:
5462     case GraphicsContext3D::TEXTURE_CUBE_MAP_POSITIVE_Y:
5463     case GraphicsContext3D::TEXTURE_CUBE_MAP_NEGATIVE_Y:
5464     case GraphicsContext3D::TEXTURE_CUBE_MAP_POSITIVE_Z:
5465     case GraphicsContext3D::TEXTURE_CUBE_MAP_NEGATIVE_Z:
5466         if (level &gt;= m_maxCubeMapTextureLevel) {
5467             synthesizeGLError(GraphicsContext3D::INVALID_VALUE, functionName, &quot;level out of range&quot;);
5468             return false;
5469         }
5470         break;
5471     }
5472     // This function only checks if level is legal, so we return true and don&#39;t
5473     // generate INVALID_ENUM if target is illegal.
5474     return true;
5475 }
5476 
5477 bool WebGLRenderingContextBase::validateCompressedTexFormat(GC3Denum format)
5478 {
5479     return m_compressedTextureFormats.contains(format);
5480 }
5481 
5482 struct BlockParameters {
5483     const int width;
5484     const int height;
5485     const int size;
5486 };
5487 
5488 static inline unsigned calculateBytesForASTC(GC3Dsizei width, GC3Dsizei height, const BlockParameters&amp; parameters)
5489 {
5490     return ((width + parameters.width - 1) / parameters.width) * ((height + parameters.height - 1) / parameters.height) * parameters.size;
5491 }
5492 
5493 bool WebGLRenderingContextBase::validateCompressedTexFuncData(const char* functionName, GC3Dsizei width, GC3Dsizei height, GC3Denum format, ArrayBufferView&amp; pixels)
5494 {
5495     if (width &lt; 0 || height &lt; 0) {
5496         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, functionName, &quot;width or height &lt; 0&quot;);
5497         return false;
5498     }
5499 
5500     unsigned bytesRequired = 0;
5501 
5502     // Block parameters for ASTC formats
5503     const int kASTCBlockSize = 16;
5504     static const BlockParameters ASTCParameters[] {
5505         BlockParameters { 4, 4, kASTCBlockSize },
5506         BlockParameters { 5, 4, kASTCBlockSize },
5507         BlockParameters { 5, 5, kASTCBlockSize },
5508         BlockParameters { 6, 5, kASTCBlockSize },
5509         BlockParameters { 6, 6, kASTCBlockSize },
5510         BlockParameters { 8, 5, kASTCBlockSize },
5511         BlockParameters { 8, 6, kASTCBlockSize },
5512         BlockParameters { 8, 8, kASTCBlockSize },
5513         BlockParameters { 10, 5, kASTCBlockSize },
5514         BlockParameters { 10, 6, kASTCBlockSize },
5515         BlockParameters { 10, 8, kASTCBlockSize },
5516         BlockParameters { 10, 10, kASTCBlockSize },
5517         BlockParameters { 12, 10, kASTCBlockSize },
5518         BlockParameters { 12, 12, kASTCBlockSize }
5519     };
5520     const GC3Denum ASTCEnumStartRGBA = Extensions3D::COMPRESSED_RGBA_ASTC_4x4_KHR;
5521     const GC3Denum ASTCEnumStartSRGB8 = Extensions3D::COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR;
5522 
5523     switch (format) {
5524     case Extensions3D::COMPRESSED_RGB_S3TC_DXT1_EXT:
5525     case Extensions3D::COMPRESSED_RGBA_S3TC_DXT1_EXT:
5526     case Extensions3D::COMPRESSED_ATC_RGB_AMD:
5527         {
5528             const int kBlockSize = 8;
5529             const int kBlockWidth = 4;
5530             const int kBlockHeight = 4;
5531             int numBlocksAcross = (width + kBlockWidth - 1) / kBlockWidth;
5532             int numBlocksDown = (height + kBlockHeight - 1) / kBlockHeight;
5533             bytesRequired = numBlocksAcross * numBlocksDown * kBlockSize;
5534         }
5535         break;
5536     case Extensions3D::COMPRESSED_RGBA_S3TC_DXT3_EXT:
5537     case Extensions3D::COMPRESSED_RGBA_S3TC_DXT5_EXT:
5538     case Extensions3D::COMPRESSED_ATC_RGBA_EXPLICIT_ALPHA_AMD:
5539     case Extensions3D::COMPRESSED_ATC_RGBA_INTERPOLATED_ALPHA_AMD:
5540         {
5541             const int kBlockSize = 16;
5542             const int kBlockWidth = 4;
5543             const int kBlockHeight = 4;
5544             int numBlocksAcross = (width + kBlockWidth - 1) / kBlockWidth;
5545             int numBlocksDown = (height + kBlockHeight - 1) / kBlockHeight;
5546             bytesRequired = numBlocksAcross * numBlocksDown * kBlockSize;
5547         }
5548         break;
5549     case Extensions3D::COMPRESSED_RGB_PVRTC_4BPPV1_IMG:
5550     case Extensions3D::COMPRESSED_RGBA_PVRTC_4BPPV1_IMG:
5551         {
5552             const int kBlockSize = 8;
5553             const int kBlockWidth = 8;
5554             const int kBlockHeight = 8;
5555             bytesRequired = (std::max(width, kBlockWidth) * std::max(height, kBlockHeight) * 4 + 7) / kBlockSize;
5556         }
5557         break;
5558     case Extensions3D::COMPRESSED_RGB_PVRTC_2BPPV1_IMG:
5559     case Extensions3D::COMPRESSED_RGBA_PVRTC_2BPPV1_IMG:
5560         {
5561             const int kBlockSize = 8;
5562             const int kBlockWidth = 16;
5563             const int kBlockHeight = 8;
5564             bytesRequired = (std::max(width, kBlockWidth) * std::max(height, kBlockHeight) * 2 + 7) / kBlockSize;
5565         }
5566         break;
5567     case Extensions3D::COMPRESSED_RGBA_ASTC_4x4_KHR:
5568     case Extensions3D::COMPRESSED_RGBA_ASTC_5x4_KHR:
5569     case Extensions3D::COMPRESSED_RGBA_ASTC_5x5_KHR:
5570     case Extensions3D::COMPRESSED_RGBA_ASTC_6x5_KHR:
5571     case Extensions3D::COMPRESSED_RGBA_ASTC_6x6_KHR:
5572     case Extensions3D::COMPRESSED_RGBA_ASTC_8x5_KHR:
5573     case Extensions3D::COMPRESSED_RGBA_ASTC_8x6_KHR:
5574     case Extensions3D::COMPRESSED_RGBA_ASTC_8x8_KHR:
5575     case Extensions3D::COMPRESSED_RGBA_ASTC_10x5_KHR:
5576     case Extensions3D::COMPRESSED_RGBA_ASTC_10x6_KHR:
5577     case Extensions3D::COMPRESSED_RGBA_ASTC_10x8_KHR:
5578     case Extensions3D::COMPRESSED_RGBA_ASTC_10x10_KHR:
5579     case Extensions3D::COMPRESSED_RGBA_ASTC_12x10_KHR:
5580     case Extensions3D::COMPRESSED_RGBA_ASTC_12x12_KHR:
5581         bytesRequired = calculateBytesForASTC(width, height, ASTCParameters[format - ASTCEnumStartRGBA]);
5582         break;
5583     case Extensions3D::COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:
5584     case Extensions3D::COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR:
5585     case Extensions3D::COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR:
5586     case Extensions3D::COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR:
5587     case Extensions3D::COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR:
5588     case Extensions3D::COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR:
5589     case Extensions3D::COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR:
5590     case Extensions3D::COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR:
5591     case Extensions3D::COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR:
5592     case Extensions3D::COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR:
5593     case Extensions3D::COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR:
5594     case Extensions3D::COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR:
5595     case Extensions3D::COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR:
5596     case Extensions3D::COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR:
5597         bytesRequired = calculateBytesForASTC(width, height, ASTCParameters[format - ASTCEnumStartSRGB8]);
5598         break;
5599     default:
5600         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, functionName, &quot;invalid format&quot;);
5601         return false;
5602     }
5603 
5604     if (pixels.byteLength() != bytesRequired) {
5605         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, functionName, &quot;length of ArrayBufferView is not correct for dimensions&quot;);
5606         return false;
5607     }
5608 
5609     return true;
5610 }
5611 
5612 bool WebGLRenderingContextBase::validateCompressedTexDimensions(const char* functionName, GC3Denum target, GC3Dint level, GC3Dsizei width, GC3Dsizei height, GC3Denum format)
5613 {
5614     switch (format) {
5615     case Extensions3D::COMPRESSED_RGB_S3TC_DXT1_EXT:
5616     case Extensions3D::COMPRESSED_RGBA_S3TC_DXT1_EXT:
5617     case Extensions3D::COMPRESSED_RGBA_S3TC_DXT3_EXT:
5618     case Extensions3D::COMPRESSED_RGBA_S3TC_DXT5_EXT: {
5619         const GC3Dsizei kBlockWidth = 4;
5620         const GC3Dsizei kBlockHeight = 4;
5621         const GC3Dint maxTextureSize = target ? m_maxTextureSize : m_maxCubeMapTextureSize;
5622         const GC3Dsizei maxCompressedDimension = maxTextureSize &gt;&gt; level;
5623         bool widthValid = (level &amp;&amp; width == 1) || (level &amp;&amp; width == 2) || (!(width % kBlockWidth) &amp;&amp; width &lt;= maxCompressedDimension);
5624         bool heightValid = (level &amp;&amp; height == 1) || (level &amp;&amp; height == 2) || (!(height % kBlockHeight) &amp;&amp; height &lt;= maxCompressedDimension);
5625         if (!widthValid || !heightValid) {
5626             synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, functionName, &quot;width or height invalid for level&quot;);
5627             return false;
5628         }
5629         return true;
5630     }
5631     case Extensions3D::COMPRESSED_RGB_PVRTC_4BPPV1_IMG:
5632     case Extensions3D::COMPRESSED_RGB_PVRTC_2BPPV1_IMG:
5633     case Extensions3D::COMPRESSED_RGBA_PVRTC_4BPPV1_IMG:
5634     case Extensions3D::COMPRESSED_RGBA_PVRTC_2BPPV1_IMG:
5635         // Height and width must be powers of 2.
5636         if ((width &amp; (width - 1)) || (height &amp; (height - 1))) {
5637             synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, functionName, &quot;width or height invalid for level&quot;);
5638             return false;
5639         }
5640         return true;
5641     case Extensions3D::COMPRESSED_RGBA_ASTC_4x4_KHR:
5642     case Extensions3D::COMPRESSED_RGBA_ASTC_5x4_KHR:
5643     case Extensions3D::COMPRESSED_RGBA_ASTC_5x5_KHR:
5644     case Extensions3D::COMPRESSED_RGBA_ASTC_6x5_KHR:
5645     case Extensions3D::COMPRESSED_RGBA_ASTC_6x6_KHR:
5646     case Extensions3D::COMPRESSED_RGBA_ASTC_8x5_KHR:
5647     case Extensions3D::COMPRESSED_RGBA_ASTC_8x6_KHR:
5648     case Extensions3D::COMPRESSED_RGBA_ASTC_8x8_KHR:
5649     case Extensions3D::COMPRESSED_RGBA_ASTC_10x5_KHR:
5650     case Extensions3D::COMPRESSED_RGBA_ASTC_10x6_KHR:
5651     case Extensions3D::COMPRESSED_RGBA_ASTC_10x8_KHR:
5652     case Extensions3D::COMPRESSED_RGBA_ASTC_10x10_KHR:
5653     case Extensions3D::COMPRESSED_RGBA_ASTC_12x10_KHR:
5654     case Extensions3D::COMPRESSED_RGBA_ASTC_12x12_KHR:
5655     case Extensions3D::COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:
5656     case Extensions3D::COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR:
5657     case Extensions3D::COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR:
5658     case Extensions3D::COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR:
5659     case Extensions3D::COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR:
5660     case Extensions3D::COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR:
5661     case Extensions3D::COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR:
5662     case Extensions3D::COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR:
5663     case Extensions3D::COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR:
5664     case Extensions3D::COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR:
5665     case Extensions3D::COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR:
5666     case Extensions3D::COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR:
5667     case Extensions3D::COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR:
5668     case Extensions3D::COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR:
5669         // No height and width restrictions on ASTC.
5670         return true;
5671     default:
5672         return false;
5673     }
5674 }
5675 
5676 bool WebGLRenderingContextBase::validateCompressedTexSubDimensions(const char* functionName, GC3Denum target, GC3Dint level, GC3Dint xoffset, GC3Dint yoffset,
5677                                                                GC3Dsizei width, GC3Dsizei height, GC3Denum format, WebGLTexture* tex)
5678 {
5679     if (xoffset &lt; 0 || yoffset &lt; 0) {
5680       synthesizeGLError(GraphicsContext3D::INVALID_VALUE, functionName, &quot;xoffset or yoffset &lt; 0&quot;);
5681       return false;
5682     }
5683 
5684     switch (format) {
5685     case Extensions3D::COMPRESSED_RGB_S3TC_DXT1_EXT:
5686     case Extensions3D::COMPRESSED_RGBA_S3TC_DXT1_EXT:
5687     case Extensions3D::COMPRESSED_RGBA_S3TC_DXT3_EXT:
5688     case Extensions3D::COMPRESSED_RGBA_S3TC_DXT5_EXT: {
5689         const int kBlockWidth = 4;
5690         const int kBlockHeight = 4;
5691         if ((xoffset % kBlockWidth) || (yoffset % kBlockHeight)) {
5692             synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, functionName, &quot;xoffset or yoffset not multiple of 4&quot;);
5693             return false;
5694         }
5695         if (width - xoffset &gt; tex-&gt;getWidth(target, level)
5696             || height - yoffset &gt; tex-&gt;getHeight(target, level)) {
5697             synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, functionName, &quot;dimensions out of range&quot;);
5698             return false;
5699         }
5700         return validateCompressedTexDimensions(functionName, target, level, width, height, format);
5701     }
5702     case Extensions3D::COMPRESSED_RGB_PVRTC_4BPPV1_IMG:
5703     case Extensions3D::COMPRESSED_RGB_PVRTC_2BPPV1_IMG:
5704     case Extensions3D::COMPRESSED_RGBA_PVRTC_4BPPV1_IMG:
5705     case Extensions3D::COMPRESSED_RGBA_PVRTC_2BPPV1_IMG: {
5706         if (xoffset || yoffset) {
5707             synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, functionName, &quot;xoffset and yoffset must be zero&quot;);
5708             return false;
5709         }
5710         if (width != tex-&gt;getWidth(target, level)
5711             || height != tex-&gt;getHeight(target, level)) {
5712             synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, functionName, &quot;dimensions must match existing level&quot;);
5713             return false;
5714         }
5715         return validateCompressedTexDimensions(functionName, target, level, width, height, format);
5716     }
5717     default:
5718         return false;
5719     }
5720 }
5721 
5722 bool WebGLRenderingContextBase::validateDrawMode(const char* functionName, GC3Denum mode)
5723 {
5724     switch (mode) {
5725     case GraphicsContext3D::POINTS:
5726     case GraphicsContext3D::LINE_STRIP:
5727     case GraphicsContext3D::LINE_LOOP:
5728     case GraphicsContext3D::LINES:
5729     case GraphicsContext3D::TRIANGLE_STRIP:
5730     case GraphicsContext3D::TRIANGLE_FAN:
5731     case GraphicsContext3D::TRIANGLES:
5732         return true;
5733     default:
5734         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, functionName, &quot;invalid draw mode&quot;);
5735         return false;
5736     }
5737 }
5738 
5739 bool WebGLRenderingContextBase::validateStencilSettings(const char* functionName)
5740 {
5741     if (m_stencilMask != m_stencilMaskBack || m_stencilFuncRef != m_stencilFuncRefBack || m_stencilFuncMask != m_stencilFuncMaskBack) {
5742         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, functionName, &quot;front and back stencils settings do not match&quot;);
5743         return false;
5744     }
5745     return true;
5746 }
5747 
5748 bool WebGLRenderingContextBase::validateStencilFunc(const char* functionName, GC3Denum func)
5749 {
5750     switch (func) {
5751     case GraphicsContext3D::NEVER:
5752     case GraphicsContext3D::LESS:
5753     case GraphicsContext3D::LEQUAL:
5754     case GraphicsContext3D::GREATER:
5755     case GraphicsContext3D::GEQUAL:
5756     case GraphicsContext3D::EQUAL:
5757     case GraphicsContext3D::NOTEQUAL:
5758     case GraphicsContext3D::ALWAYS:
5759         return true;
5760     default:
5761         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, functionName, &quot;invalid function&quot;);
5762         return false;
5763     }
5764 }
5765 
5766 void WebGLRenderingContextBase::printToConsole(MessageLevel level, const String&amp; message)
5767 {
5768     if (!m_synthesizedErrorsToConsole || !m_numGLErrorsToConsoleAllowed)
5769         return;
5770 
5771     std::unique_ptr&lt;Inspector::ConsoleMessage&gt; consoleMessage;
5772 
5773     // Error messages can occur during function calls, so show stack traces for them.
5774     if (level == MessageLevel::Error) {
5775         Ref&lt;Inspector::ScriptCallStack&gt; stackTrace = Inspector::createScriptCallStack(JSExecState::currentState());
<a name="43" id="anc43"></a><span class="line-modified">5776         consoleMessage = std::make_unique&lt;Inspector::ConsoleMessage&gt;(MessageSource::Rendering, MessageType::Log, level, message, WTFMove(stackTrace));</span>
5777     } else
<a name="44" id="anc44"></a><span class="line-modified">5778         consoleMessage = std::make_unique&lt;Inspector::ConsoleMessage&gt;(MessageSource::Rendering, MessageType::Log, level, message);</span>
5779 
5780     auto* canvas = htmlCanvas();
5781     if (canvas)
5782         canvas-&gt;document().addConsoleMessage(WTFMove(consoleMessage));
5783 
5784     --m_numGLErrorsToConsoleAllowed;
5785     if (!m_numGLErrorsToConsoleAllowed)
5786         printToConsole(MessageLevel::Warning, &quot;WebGL: too many errors, no more errors will be reported to the console for this context.&quot;);
5787 }
5788 
5789 bool WebGLRenderingContextBase::validateBlendFuncFactors(const char* functionName, GC3Denum src, GC3Denum dst)
5790 {
5791     if (((src == GraphicsContext3D::CONSTANT_COLOR || src == GraphicsContext3D::ONE_MINUS_CONSTANT_COLOR)
5792          &amp;&amp; (dst == GraphicsContext3D::CONSTANT_ALPHA || dst == GraphicsContext3D::ONE_MINUS_CONSTANT_ALPHA))
5793         || ((dst == GraphicsContext3D::CONSTANT_COLOR || dst == GraphicsContext3D::ONE_MINUS_CONSTANT_COLOR)
5794             &amp;&amp; (src == GraphicsContext3D::CONSTANT_ALPHA || src == GraphicsContext3D::ONE_MINUS_CONSTANT_ALPHA))) {
5795         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, functionName, &quot;incompatible src and dst&quot;);
5796         return false;
5797     }
5798     return true;
5799 }
5800 
5801 bool WebGLRenderingContextBase::validateUniformParameters(const char* functionName, const WebGLUniformLocation* location, const Float32List&amp; v, GC3Dsizei requiredMinSize)
5802 {
5803     return validateUniformMatrixParameters(functionName, location, false, v.data(), v.length(), requiredMinSize);
5804 }
5805 
5806 bool WebGLRenderingContextBase::validateUniformParameters(const char* functionName, const WebGLUniformLocation* location, const Int32List&amp; v, GC3Dsizei requiredMinSize)
5807 {
5808     return validateUniformMatrixParameters(functionName, location, false, v.data(), v.length(), requiredMinSize);
5809 }
5810 
5811 bool WebGLRenderingContextBase::validateUniformParameters(const char* functionName, const WebGLUniformLocation* location, void* v, GC3Dsizei size, GC3Dsizei requiredMinSize)
5812 {
5813     return validateUniformMatrixParameters(functionName, location, false, v, size, requiredMinSize);
5814 }
5815 
5816 bool WebGLRenderingContextBase::validateUniformMatrixParameters(const char* functionName, const WebGLUniformLocation* location, GC3Dboolean transpose, const Float32List&amp; v, GC3Dsizei requiredMinSize)
5817 {
5818     return validateUniformMatrixParameters(functionName, location, transpose, v.data(), v.length(), requiredMinSize);
5819 }
5820 
5821 bool WebGLRenderingContextBase::validateUniformMatrixParameters(const char* functionName, const WebGLUniformLocation* location, GC3Dboolean transpose, const void* v, GC3Dsizei size, GC3Dsizei requiredMinSize)
5822 {
5823     if (!location)
5824         return false;
5825     if (location-&gt;program() != m_currentProgram) {
5826         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, functionName, &quot;location is not from current program&quot;);
5827         return false;
5828     }
5829     if (!v) {
5830         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, functionName, &quot;no array&quot;);
5831         return false;
5832     }
5833     if (transpose) {
5834         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, functionName, &quot;transpose not FALSE&quot;);
5835         return false;
5836     }
5837     if (size &lt; requiredMinSize || (size % requiredMinSize)) {
5838         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, functionName, &quot;invalid size&quot;);
5839         return false;
5840     }
5841     return true;
5842 }
5843 
5844 WebGLBuffer* WebGLRenderingContextBase::validateBufferDataParameters(const char* functionName, GC3Denum target, GC3Denum usage)
5845 {
5846     Optional&lt;WebGLBuffer*&gt; buffer;
5847     switch (target) {
5848     case GraphicsContext3D::ELEMENT_ARRAY_BUFFER:
5849         buffer = m_boundVertexArrayObject-&gt;getElementArrayBuffer();
5850         break;
5851     case GraphicsContext3D::ARRAY_BUFFER:
5852         buffer = m_boundArrayBuffer.get();
5853         break;
5854     default:
5855 #if ENABLE(WEBGL2)
5856         if (isWebGL2()) {
5857             switch (target) {
5858             case GraphicsContext3D::COPY_READ_BUFFER:
5859                 buffer = m_boundCopyReadBuffer.get();
5860                 break;
5861             case GraphicsContext3D::COPY_WRITE_BUFFER:
5862                 buffer = m_boundCopyWriteBuffer.get();
5863                 break;
5864             case GraphicsContext3D::PIXEL_PACK_BUFFER:
5865                 buffer = m_boundPixelPackBuffer.get();
5866                 break;
5867             case GraphicsContext3D::PIXEL_UNPACK_BUFFER:
5868                 buffer = m_boundPixelUnpackBuffer.get();
5869                 break;
5870             case GraphicsContext3D::TRANSFORM_FEEDBACK_BUFFER:
5871                 buffer = m_boundTransformFeedbackBuffer.get();
5872                 break;
5873             case GraphicsContext3D::UNIFORM_BUFFER:
5874                 buffer = m_boundUniformBuffer.get();
5875                 break;
5876             }
5877             if (buffer)
5878                 break;
5879         }
5880 #endif
5881         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, functionName, &quot;invalid target&quot;);
5882         return nullptr;
5883     }
5884     if (!buffer || !buffer.value()) {
5885         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, functionName, &quot;no buffer&quot;);
5886         return nullptr;
5887     }
5888     switch (usage) {
5889     case GraphicsContext3D::STREAM_DRAW:
5890     case GraphicsContext3D::STATIC_DRAW:
5891     case GraphicsContext3D::DYNAMIC_DRAW:
5892         return buffer.value();
5893     }
5894     synthesizeGLError(GraphicsContext3D::INVALID_ENUM, functionName, &quot;invalid usage&quot;);
5895     return nullptr;
5896 }
5897 
5898 ExceptionOr&lt;bool&gt; WebGLRenderingContextBase::validateHTMLImageElement(const char* functionName, HTMLImageElement* image)
5899 {
5900     if (!image || !image-&gt;cachedImage()) {
5901         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, functionName, &quot;no image&quot;);
5902         return false;
5903     }
5904     const URL&amp; url = image-&gt;cachedImage()-&gt;response().url();
5905     if (url.isNull() || url.isEmpty() || !url.isValid()) {
5906         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, functionName, &quot;invalid image&quot;);
5907         return false;
5908     }
5909     if (wouldTaintOrigin(image))
5910         return Exception { SecurityError };
5911     return true;
5912 }
5913 
5914 ExceptionOr&lt;bool&gt; WebGLRenderingContextBase::validateHTMLCanvasElement(const char* functionName, HTMLCanvasElement* canvas)
5915 {
5916     if (!canvas || !canvas-&gt;buffer()) {
5917         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, functionName, &quot;no canvas&quot;);
5918         return false;
5919     }
5920     if (wouldTaintOrigin(canvas))
5921         return Exception { SecurityError };
5922     return true;
5923 }
5924 
5925 #if ENABLE(VIDEO)
5926 
5927 ExceptionOr&lt;bool&gt; WebGLRenderingContextBase::validateHTMLVideoElement(const char* functionName, HTMLVideoElement* video)
5928 {
5929     if (!video || !video-&gt;videoWidth() || !video-&gt;videoHeight()) {
5930         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, functionName, &quot;no video&quot;);
5931         return false;
5932     }
5933     if (wouldTaintOrigin(video))
5934         return Exception { SecurityError };
5935     return true;
5936 }
5937 
5938 #endif
5939 
5940 void WebGLRenderingContextBase::vertexAttribfImpl(const char* functionName, GC3Duint index, GC3Dsizei expectedSize, GC3Dfloat v0, GC3Dfloat v1, GC3Dfloat v2, GC3Dfloat v3)
5941 {
5942     if (isContextLostOrPending())
5943         return;
5944     if (index &gt;= m_maxVertexAttribs) {
5945         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, functionName, &quot;index out of range&quot;);
5946         return;
5947     }
5948     // In GL, we skip setting vertexAttrib0 values.
5949     if (index || isGLES2Compliant()) {
5950         switch (expectedSize) {
5951         case 1:
5952             m_context-&gt;vertexAttrib1f(index, v0);
5953             break;
5954         case 2:
5955             m_context-&gt;vertexAttrib2f(index, v0, v1);
5956             break;
5957         case 3:
5958             m_context-&gt;vertexAttrib3f(index, v0, v1, v2);
5959             break;
5960         case 4:
5961             m_context-&gt;vertexAttrib4f(index, v0, v1, v2, v3);
5962             break;
5963         }
5964     }
5965     VertexAttribValue&amp; attribValue = m_vertexAttribValue[index];
5966     attribValue.value[0] = v0;
5967     attribValue.value[1] = v1;
5968     attribValue.value[2] = v2;
5969     attribValue.value[3] = v3;
5970 }
5971 
5972 void WebGLRenderingContextBase::vertexAttribfvImpl(const char* functionName, GC3Duint index, Float32List&amp;&amp; list, GC3Dsizei expectedSize)
5973 {
5974     if (isContextLostOrPending())
5975         return;
5976 
5977     auto data = list.data();
5978     if (!data) {
5979         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, functionName, &quot;no array&quot;);
5980         return;
5981     }
5982 
5983     int size = list.length();
5984     if (size &lt; expectedSize) {
5985         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, functionName, &quot;invalid size&quot;);
5986         return;
5987     }
5988     if (index &gt;= m_maxVertexAttribs) {
5989         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, functionName, &quot;index out of range&quot;);
5990         return;
5991     }
5992     // In GL, we skip setting vertexAttrib0 values.
5993     if (index || isGLES2Compliant()) {
5994         switch (expectedSize) {
5995         case 1:
5996             m_context-&gt;vertexAttrib1fv(index, data);
5997             break;
5998         case 2:
5999             m_context-&gt;vertexAttrib2fv(index, data);
6000             break;
6001         case 3:
6002             m_context-&gt;vertexAttrib3fv(index, data);
6003             break;
6004         case 4:
6005             m_context-&gt;vertexAttrib4fv(index, data);
6006             break;
6007         }
6008     }
6009     VertexAttribValue&amp; attribValue = m_vertexAttribValue[index];
6010     attribValue.initValue();
6011     for (int ii = 0; ii &lt; expectedSize; ++ii)
6012         attribValue.value[ii] = data[ii];
6013 }
6014 
6015 void WebGLRenderingContextBase::initVertexAttrib0()
6016 {
6017     WebGLVertexArrayObjectBase::VertexAttribState&amp; state = m_boundVertexArrayObject-&gt;getVertexAttribState(0);
6018 
6019     m_vertexAttrib0Buffer = createBuffer();
6020     m_context-&gt;bindBuffer(GraphicsContext3D::ARRAY_BUFFER, m_vertexAttrib0Buffer-&gt;object());
6021     m_context-&gt;bufferData(GraphicsContext3D::ARRAY_BUFFER, 0, GraphicsContext3D::DYNAMIC_DRAW);
6022     m_context-&gt;vertexAttribPointer(0, 4, GraphicsContext3D::FLOAT, false, 0, 0);
6023     state.bufferBinding = m_vertexAttrib0Buffer;
6024     m_context-&gt;bindBuffer(GraphicsContext3D::ARRAY_BUFFER, 0);
6025     m_context-&gt;enableVertexAttribArray(0);
6026     m_vertexAttrib0BufferSize = 0;
6027     m_vertexAttrib0BufferValue[0] = 0.0f;
6028     m_vertexAttrib0BufferValue[1] = 0.0f;
6029     m_vertexAttrib0BufferValue[2] = 0.0f;
6030     m_vertexAttrib0BufferValue[3] = 1.0f;
6031     m_forceAttrib0BufferRefill = false;
6032     m_vertexAttrib0UsedBefore = false;
6033 }
6034 
6035 bool WebGLRenderingContextBase::validateSimulatedVertexAttrib0(GC3Duint numVertex)
6036 {
6037     if (!m_currentProgram)
6038         return true;
6039 
6040     bool usingVertexAttrib0 = m_currentProgram-&gt;isUsingVertexAttrib0();
6041     if (!usingVertexAttrib0)
6042         return true;
6043 
6044     auto&amp; state = m_boundVertexArrayObject-&gt;getVertexAttribState(0);
6045     if (state.enabled)
6046         return true;
6047 
6048     auto bufferSize = checkedAddAndMultiply&lt;GC3Duint&gt;(numVertex, 1, 4);
6049     if (!bufferSize)
6050         return false;
6051 
6052     Checked&lt;GC3Dsizeiptr, RecordOverflow&gt; bufferDataSize(bufferSize.value());
6053     bufferDataSize *= Checked&lt;GC3Dsizeiptr&gt;(sizeof(GC3Dfloat));
6054     return !bufferDataSize.hasOverflowed() &amp;&amp; bufferDataSize.unsafeGet() &gt; 0;
6055 }
6056 
6057 Optional&lt;bool&gt; WebGLRenderingContextBase::simulateVertexAttrib0(GC3Duint numVertex)
6058 {
6059     if (!m_currentProgram)
6060         return false;
6061     bool usingVertexAttrib0 = m_currentProgram-&gt;isUsingVertexAttrib0();
6062     if (usingVertexAttrib0)
6063         m_vertexAttrib0UsedBefore = true;
6064 
6065     auto&amp; state = m_boundVertexArrayObject-&gt;getVertexAttribState(0);
6066     if (state.enabled &amp;&amp; usingVertexAttrib0)
6067         return false;
6068     if (!usingVertexAttrib0 &amp;&amp; !m_vertexAttrib0UsedBefore)
6069         return false;
6070     m_vertexAttrib0UsedBefore = true;
6071     m_context-&gt;bindBuffer(GraphicsContext3D::ARRAY_BUFFER, m_vertexAttrib0Buffer-&gt;object());
6072 
6073     // We know bufferSize and bufferDataSize won&#39;t overflow or go negative, thanks to validateSimulatedVertexAttrib0
6074     GC3Duint bufferSize = (numVertex + 1) * 4;
6075     GC3Dsizeiptr bufferDataSize = bufferSize * sizeof(GC3Dfloat);
6076 
6077     if (bufferDataSize &gt; m_vertexAttrib0BufferSize) {
6078         m_context-&gt;moveErrorsToSyntheticErrorList();
6079         m_context-&gt;bufferData(GraphicsContext3D::ARRAY_BUFFER, bufferDataSize, 0, GraphicsContext3D::DYNAMIC_DRAW);
6080         if (m_context-&gt;getError() != GraphicsContext3D::NO_ERROR) {
6081             // We were unable to create a buffer.
6082             m_vertexAttrib0UsedBefore = false;
6083             m_vertexAttrib0BufferSize = 0;
6084             m_forceAttrib0BufferRefill = true;
6085             return WTF::nullopt;
6086         }
6087         m_vertexAttrib0BufferSize = bufferDataSize;
6088         m_forceAttrib0BufferRefill = true;
6089     }
6090 
6091     auto&amp; attribValue = m_vertexAttribValue[0];
6092 
6093     if (usingVertexAttrib0
6094         &amp;&amp; (m_forceAttrib0BufferRefill
6095             || attribValue.value[0] != m_vertexAttrib0BufferValue[0]
6096             || attribValue.value[1] != m_vertexAttrib0BufferValue[1]
6097             || attribValue.value[2] != m_vertexAttrib0BufferValue[2]
6098             || attribValue.value[3] != m_vertexAttrib0BufferValue[3])) {
6099 
6100         auto bufferData = makeUniqueArray&lt;GC3Dfloat&gt;(bufferSize);
6101         for (GC3Duint ii = 0; ii &lt; numVertex + 1; ++ii) {
6102             bufferData[ii * 4] = attribValue.value[0];
6103             bufferData[ii * 4 + 1] = attribValue.value[1];
6104             bufferData[ii * 4 + 2] = attribValue.value[2];
6105             bufferData[ii * 4 + 3] = attribValue.value[3];
6106         }
6107         m_vertexAttrib0BufferValue[0] = attribValue.value[0];
6108         m_vertexAttrib0BufferValue[1] = attribValue.value[1];
6109         m_vertexAttrib0BufferValue[2] = attribValue.value[2];
6110         m_vertexAttrib0BufferValue[3] = attribValue.value[3];
6111         m_forceAttrib0BufferRefill = false;
6112         m_context-&gt;bufferSubData(GraphicsContext3D::ARRAY_BUFFER, 0, bufferDataSize, bufferData.get());
6113     }
6114     m_context-&gt;vertexAttribPointer(0, 4, GraphicsContext3D::FLOAT, 0, 0, 0);
6115     return true;
6116 }
6117 
6118 void WebGLRenderingContextBase::restoreStatesAfterVertexAttrib0Simulation()
6119 {
6120     const WebGLVertexArrayObjectBase::VertexAttribState&amp; state = m_boundVertexArrayObject-&gt;getVertexAttribState(0);
6121     if (state.bufferBinding != m_vertexAttrib0Buffer) {
6122         m_context-&gt;bindBuffer(GraphicsContext3D::ARRAY_BUFFER, objectOrZero(state.bufferBinding.get()));
6123         m_context-&gt;vertexAttribPointer(0, state.size, state.type, state.normalized, state.originalStride, state.offset);
6124     }
6125     m_context-&gt;bindBuffer(GraphicsContext3D::ARRAY_BUFFER, objectOrZero(m_boundArrayBuffer.get()));
6126 }
6127 
6128 void WebGLRenderingContextBase::dispatchContextLostEvent()
6129 {
6130     auto* canvas = htmlCanvas();
6131     if (!canvas)
6132         return;
6133 
6134     Ref&lt;WebGLContextEvent&gt; event = WebGLContextEvent::create(eventNames().webglcontextlostEvent, Event::CanBubble::No, Event::IsCancelable::Yes, emptyString());
6135     canvas-&gt;dispatchEvent(event);
6136     m_restoreAllowed = event-&gt;defaultPrevented();
6137     if (m_contextLostMode == RealLostContext &amp;&amp; m_restoreAllowed)
6138         m_restoreTimer.startOneShot(0_s);
6139 }
6140 
6141 void WebGLRenderingContextBase::maybeRestoreContext()
6142 {
6143     ASSERT(m_contextLost);
6144     if (!m_contextLost)
6145         return;
6146 
6147     // The rendering context is not restored unless the default behavior of the
6148     // webglcontextlost event was prevented earlier.
6149     //
6150     // Because of the way m_restoreTimer is set up for real vs. synthetic lost
6151     // context events, we don&#39;t have to worry about this test short-circuiting
6152     // the retry loop for real context lost events.
6153     if (!m_restoreAllowed)
6154         return;
6155 
6156     int contextLostReason = m_context-&gt;getExtensions().getGraphicsResetStatusARB();
6157 
6158     switch (contextLostReason) {
6159     case GraphicsContext3D::NO_ERROR:
6160         // The GraphicsContext3D implementation might not fully
6161         // support GL_ARB_robustness semantics yet. Alternatively, the
6162         // WEBGL_lose_context extension might have been used to force
6163         // a lost context.
6164         break;
6165     case Extensions3D::GUILTY_CONTEXT_RESET_ARB:
6166         // The rendering context is not restored if this context was
6167         // guilty of causing the graphics reset.
6168         printToConsole(MessageLevel::Warning, &quot;WARNING: WebGL content on the page caused the graphics card to reset; not restoring the context&quot;);
6169         return;
6170     case Extensions3D::INNOCENT_CONTEXT_RESET_ARB:
6171         // Always allow the context to be restored.
6172         break;
6173     case Extensions3D::UNKNOWN_CONTEXT_RESET_ARB:
6174         // Warn. Ideally, prompt the user telling them that WebGL
6175         // content on the page might have caused the graphics card to
6176         // reset and ask them whether they want to continue running
6177         // the content. Only if they say &quot;yes&quot; should we start
6178         // attempting to restore the context.
6179         printToConsole(MessageLevel::Warning, &quot;WARNING: WebGL content on the page might have caused the graphics card to reset&quot;);
6180         break;
6181     }
6182 
6183     auto* canvas = htmlCanvas();
6184     if (!canvas)
6185         return;
6186 
6187     RefPtr&lt;Frame&gt; frame = canvas-&gt;document().frame();
6188     if (!frame)
6189         return;
6190 
6191     if (!frame-&gt;loader().client().allowWebGL(frame-&gt;settings().webGLEnabled()))
6192         return;
6193 
6194     RefPtr&lt;FrameView&gt; view = frame-&gt;view();
6195     if (!view)
6196         return;
6197     RefPtr&lt;ScrollView&gt; root = view-&gt;root();
6198     if (!root)
6199         return;
6200     HostWindow* hostWindow = root-&gt;hostWindow();
6201     if (!hostWindow)
6202         return;
6203 
6204     RefPtr&lt;GraphicsContext3D&gt; context(GraphicsContext3D::create(m_attributes, hostWindow));
6205     if (!context) {
6206         if (m_contextLostMode == RealLostContext)
6207             m_restoreTimer.startOneShot(secondsBetweenRestoreAttempts);
6208         else
6209             // This likely shouldn&#39;t happen but is the best way to report it to the WebGL app.
6210             synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;&quot;, &quot;error restoring context&quot;);
6211         return;
6212     }
6213 
6214     m_context = context;
6215     addActivityStateChangeObserverIfNecessary();
6216     m_contextLost = false;
6217     setupFlags();
6218     initializeNewContext();
6219     initializeVertexArrayObjects();
6220     canvas-&gt;dispatchEvent(WebGLContextEvent::create(eventNames().webglcontextrestoredEvent, Event::CanBubble::No, Event::IsCancelable::Yes, emptyString()));
6221 }
6222 
<a name="45" id="anc45"></a><span class="line-removed">6223 void WebGLRenderingContextBase::dispatchContextChangedEvent()</span>
<span class="line-removed">6224 {</span>
<span class="line-removed">6225     auto* canvas = htmlCanvas();</span>
<span class="line-removed">6226     if (!canvas)</span>
<span class="line-removed">6227         return;</span>
<span class="line-removed">6228 </span>
<span class="line-removed">6229     canvas-&gt;dispatchEvent(WebGLContextEvent::create(eventNames().webglcontextchangedEvent, Event::CanBubble::No, Event::IsCancelable::Yes, emptyString()));</span>
<span class="line-removed">6230 }</span>
<span class="line-removed">6231 </span>
6232 void WebGLRenderingContextBase::simulateContextChanged()
6233 {
6234     if (m_context)
6235         m_context-&gt;simulateContextChanged();
6236 }
6237 
6238 String WebGLRenderingContextBase::ensureNotNull(const String&amp; text) const
6239 {
6240     if (text.isNull())
6241         return WTF::emptyString();
6242     return text;
6243 }
6244 
6245 WebGLRenderingContextBase::LRUImageBufferCache::LRUImageBufferCache(int capacity)
6246     : m_buffers(capacity)
6247 {
6248 }
6249 
6250 ImageBuffer* WebGLRenderingContextBase::LRUImageBufferCache::imageBuffer(const IntSize&amp; size)
6251 {
6252     size_t i;
6253     for (i = 0; i &lt; m_buffers.size(); ++i) {
6254         ImageBuffer* buf = m_buffers[i].get();
6255         if (!buf)
6256             break;
6257         if (buf-&gt;logicalSize() != size)
6258             continue;
6259         bubbleToFront(i);
6260         buf-&gt;context().clearRect(FloatRect({ }, FloatSize(size)));
6261         return buf;
6262     }
6263 
6264     // FIXME (149423): Should this ImageBuffer be unconditionally unaccelerated?
6265     std::unique_ptr&lt;ImageBuffer&gt; temp = ImageBuffer::create(size, Unaccelerated);
6266     if (!temp)
6267         return nullptr;
6268     ASSERT(m_buffers.size() &gt; 0);
6269     i = std::min(m_buffers.size() - 1, i);
6270     m_buffers[i] = WTFMove(temp);
6271 
6272     ImageBuffer* buf = m_buffers[i].get();
6273     bubbleToFront(i);
6274     return buf;
6275 }
6276 
6277 void WebGLRenderingContextBase::LRUImageBufferCache::bubbleToFront(size_t idx)
6278 {
6279     for (size_t i = idx; i &gt; 0; --i)
6280         m_buffers[i].swap(m_buffers[i-1]);
6281 }
6282 
6283 namespace {
6284 
6285     String GetErrorString(GC3Denum error)
6286     {
6287         switch (error) {
6288         case GraphicsContext3D::INVALID_ENUM:
6289             return &quot;INVALID_ENUM&quot;_s;
6290         case GraphicsContext3D::INVALID_VALUE:
6291             return &quot;INVALID_VALUE&quot;_s;
6292         case GraphicsContext3D::INVALID_OPERATION:
6293             return &quot;INVALID_OPERATION&quot;_s;
6294         case GraphicsContext3D::OUT_OF_MEMORY:
6295             return &quot;OUT_OF_MEMORY&quot;_s;
6296         case GraphicsContext3D::INVALID_FRAMEBUFFER_OPERATION:
6297             return &quot;INVALID_FRAMEBUFFER_OPERATION&quot;_s;
6298         case GraphicsContext3D::CONTEXT_LOST_WEBGL:
6299             return &quot;CONTEXT_LOST_WEBGL&quot;_s;
6300         default:
6301             return makeString(&quot;WebGL ERROR(&quot;, hex(error, 4, Lowercase), &#39;)&#39;);
6302         }
6303     }
6304 
6305 } // namespace anonymous
6306 
6307 void WebGLRenderingContextBase::synthesizeGLError(GC3Denum error, const char* functionName, const char* description, ConsoleDisplayPreference display)
6308 {
6309     if (m_synthesizedErrorsToConsole &amp;&amp; display == DisplayInConsole) {
6310         String str = &quot;WebGL: &quot; + GetErrorString(error) +  &quot;: &quot; + String(functionName) + &quot;: &quot; + String(description);
6311         printToConsole(MessageLevel::Error, str);
6312     }
6313     m_context-&gt;synthesizeGLError(error);
6314 }
6315 
6316 void WebGLRenderingContextBase::applyStencilTest()
6317 {
6318     bool haveStencilBuffer = false;
6319 
6320     if (m_framebufferBinding)
6321         haveStencilBuffer = m_framebufferBinding-&gt;hasStencilBuffer();
6322     else {
6323         auto attributes = getContextAttributes();
6324         ASSERT(attributes);
6325         haveStencilBuffer = attributes-&gt;stencil;
6326     }
6327     enableOrDisable(GraphicsContext3D::STENCIL_TEST, m_stencilEnabled &amp;&amp; haveStencilBuffer);
6328 }
6329 
6330 void WebGLRenderingContextBase::enableOrDisable(GC3Denum capability, bool enable)
6331 {
6332     if (enable)
6333         m_context-&gt;enable(capability);
6334     else
6335         m_context-&gt;disable(capability);
6336 }
6337 
6338 IntSize WebGLRenderingContextBase::clampedCanvasSize()
6339 {
6340     return IntSize(clamp(canvasBase().width(), 1, m_maxViewportDims[0]),
6341         clamp(canvasBase().height(), 1, m_maxViewportDims[1]));
6342 }
6343 
6344 GC3Dint WebGLRenderingContextBase::getMaxDrawBuffers()
6345 {
6346     if (!supportsDrawBuffers())
6347         return 0;
6348     if (!m_maxDrawBuffers)
6349         m_context-&gt;getIntegerv(Extensions3D::MAX_DRAW_BUFFERS_EXT, &amp;m_maxDrawBuffers);
6350     if (!m_maxColorAttachments)
6351         m_context-&gt;getIntegerv(Extensions3D::MAX_COLOR_ATTACHMENTS_EXT, &amp;m_maxColorAttachments);
6352     // WEBGL_draw_buffers requires MAX_COLOR_ATTACHMENTS &gt;= MAX_DRAW_BUFFERS.
6353     return std::min(m_maxDrawBuffers, m_maxColorAttachments);
6354 }
6355 
6356 GC3Dint WebGLRenderingContextBase::getMaxColorAttachments()
6357 {
6358     if (!supportsDrawBuffers())
6359         return 0;
6360     if (!m_maxColorAttachments)
6361         m_context-&gt;getIntegerv(Extensions3D::MAX_COLOR_ATTACHMENTS_EXT, &amp;m_maxColorAttachments);
6362     return m_maxColorAttachments;
6363 }
6364 
6365 void WebGLRenderingContextBase::setBackDrawBuffer(GC3Denum buf)
6366 {
6367     m_backDrawBuffer = buf;
6368 }
6369 
6370 void WebGLRenderingContextBase::restoreCurrentFramebuffer()
6371 {
6372     bindFramebuffer(GraphicsContext3D::FRAMEBUFFER, m_framebufferBinding.get());
6373 }
6374 
6375 void WebGLRenderingContextBase::restoreCurrentTexture2D()
6376 {
6377     auto texture = m_textureUnits[m_activeTextureUnit].texture2DBinding.get();
6378     bindTexture(GraphicsContext3D::TEXTURE_2D, texture);
6379     if (texture &amp;&amp; texture-&gt;needToUseBlackTexture(textureExtensionFlags()))
6380         m_unrenderableTextureUnits.add(m_activeTextureUnit);
6381 }
6382 
6383 bool WebGLRenderingContextBase::supportsDrawBuffers()
6384 {
6385     if (!m_drawBuffersWebGLRequirementsChecked) {
6386         m_drawBuffersWebGLRequirementsChecked = true;
6387         m_drawBuffersSupported = WebGLDrawBuffers::supported(*this);
6388     }
6389     return m_drawBuffersSupported;
6390 }
6391 
6392 void WebGLRenderingContextBase::drawArraysInstanced(GC3Denum mode, GC3Dint first, GC3Dsizei count, GC3Dsizei primcount)
6393 {
6394     if (!primcount) {
6395         markContextChanged();
6396         return;
6397     }
6398 
6399     if (!validateDrawArrays(&quot;drawArraysInstanced&quot;, mode, first, count, primcount))
6400         return;
6401 
6402     clearIfComposited();
6403 
6404     bool vertexAttrib0Simulated = false;
6405     if (!isGLES2Compliant()) {
6406         auto simulateVertexAttrib0Status = simulateVertexAttrib0(first + count - 1);
6407         if (!simulateVertexAttrib0Status) {
6408             // We were unable to simulate the attribute buffer.
6409             synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;drawArraysInstanced&quot;, &quot;unable to simulate vertexAttrib0 array&quot;);
6410             return;
6411         }
6412         vertexAttrib0Simulated = simulateVertexAttrib0Status.value();
6413     }
6414     if (!isGLES2NPOTStrict())
6415         checkTextureCompleteness(&quot;drawArraysInstanced&quot;, true);
6416 
6417     m_context-&gt;drawArraysInstanced(mode, first, count, primcount);
6418 
6419     if (!isGLES2Compliant() &amp;&amp; vertexAttrib0Simulated)
6420         restoreStatesAfterVertexAttrib0Simulation();
6421     if (!isGLES2NPOTStrict())
6422         checkTextureCompleteness(&quot;drawArraysInstanced&quot;, false);
6423     markContextChangedAndNotifyCanvasObserver();
6424 }
6425 
6426 void WebGLRenderingContextBase::drawElementsInstanced(GC3Denum mode, GC3Dsizei count, GC3Denum type, long long offset, GC3Dsizei primcount)
6427 {
6428     if (!primcount) {
6429         markContextChanged();
6430         return;
6431     }
6432 
6433     unsigned numElements = 0;
6434     if (!validateDrawElements(&quot;drawElementsInstanced&quot;, mode, count, type, offset, numElements, primcount))
6435         return;
6436 
6437     clearIfComposited();
6438 
6439     bool vertexAttrib0Simulated = false;
6440     if (!isGLES2Compliant()) {
6441         if (!numElements)
6442             validateIndexArrayPrecise(count, type, static_cast&lt;GC3Dintptr&gt;(offset), numElements);
6443         auto simulateVertexAttrib0Status = simulateVertexAttrib0(numElements);
6444         if (!simulateVertexAttrib0Status) {
6445             // We were unable to simulate the attribute buffer.
6446             synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;drawArraysInstanced&quot;, &quot;unable to simulate vertexAttrib0 array&quot;);
6447             return;
6448         }
6449         vertexAttrib0Simulated = simulateVertexAttrib0Status.value();
6450     }
6451     if (!isGLES2NPOTStrict())
6452         checkTextureCompleteness(&quot;drawElementsInstanced&quot;, true);
6453 
6454 #if USE(OPENGL) &amp;&amp; ENABLE(WEBGL2)
6455     if (isWebGL2())
6456         m_context-&gt;primitiveRestartIndex(getRestartIndex(type));
6457 #endif
6458 
6459     m_context-&gt;drawElementsInstanced(mode, count, type, static_cast&lt;GC3Dintptr&gt;(offset), primcount);
6460 
6461     if (!isGLES2Compliant() &amp;&amp; vertexAttrib0Simulated)
6462         restoreStatesAfterVertexAttrib0Simulation();
6463     if (!isGLES2NPOTStrict())
6464         checkTextureCompleteness(&quot;drawElementsInstanced&quot;, false);
6465     markContextChangedAndNotifyCanvasObserver();
6466 }
6467 
6468 void WebGLRenderingContextBase::vertexAttribDivisor(GC3Duint index, GC3Duint divisor)
6469 {
6470     if (isContextLostOrPending())
6471         return;
6472 
6473     if (index &gt;= m_maxVertexAttribs) {
6474         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;vertexAttribDivisor&quot;, &quot;index out of range&quot;);
6475         return;
6476     }
6477 
6478     m_boundVertexArrayObject-&gt;setVertexAttribDivisor(index, divisor);
6479     m_context-&gt;vertexAttribDivisor(index, divisor);
6480 }
6481 
6482 bool WebGLRenderingContextBase::enableSupportedExtension(ASCIILiteral extensionNameLiteral)
6483 {
6484     ASSERT(m_context);
6485     auto&amp; extensions = m_context-&gt;getExtensions();
6486     String extensionName { extensionNameLiteral };
6487     if (!extensions.supports(extensionName))
6488         return false;
6489     extensions.ensureEnabled(extensionName);
6490     return true;
6491 }
6492 
6493 void WebGLRenderingContextBase::activityStateDidChange(OptionSet&lt;ActivityState::Flag&gt; oldActivityState, OptionSet&lt;ActivityState::Flag&gt; newActivityState)
6494 {
6495     if (!m_context)
6496         return;
6497 
6498     auto changed = oldActivityState ^ newActivityState;
6499     if (changed &amp; ActivityState::IsVisible)
6500         m_context-&gt;setContextVisibility(newActivityState.contains(ActivityState::IsVisible));
6501 }
6502 
6503 void WebGLRenderingContextBase::setFailNextGPUStatusCheck()
6504 {
6505     if (!m_context)
6506         return;
6507 
6508     m_context-&gt;setFailNextGPUStatusCheck();
6509 }
6510 
<a name="46" id="anc46"></a>





























6511 } // namespace WebCore
6512 
6513 #endif // ENABLE(WEBGL)
<a name="47" id="anc47"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="47" type="hidden" />
</body>
</html>