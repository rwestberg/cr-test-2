<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/rendering/style/RenderStyle.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="NinePieceImage.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="RenderStyle.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/rendering/style/RenderStyle.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  92     return style;
  93 }
  94 
  95 RenderStyle RenderStyle::create()
  96 {
  97     return clone(defaultStyle());
  98 }
  99 
 100 std::unique_ptr&lt;RenderStyle&gt; RenderStyle::createPtr()
 101 {
 102     return clonePtr(defaultStyle());
 103 }
 104 
 105 RenderStyle RenderStyle::clone(const RenderStyle&amp; style)
 106 {
 107     return RenderStyle(style, Clone);
 108 }
 109 
 110 std::unique_ptr&lt;RenderStyle&gt; RenderStyle::clonePtr(const RenderStyle&amp; style)
 111 {
<span class="line-modified"> 112     return std::make_unique&lt;RenderStyle&gt;(style, Clone);</span>
 113 }
 114 
 115 RenderStyle RenderStyle::createAnonymousStyleWithDisplay(const RenderStyle&amp; parentStyle, DisplayType display)
 116 {
 117     auto newStyle = create();
 118     newStyle.inheritFrom(parentStyle);
 119     newStyle.inheritUnicodeBidiFrom(&amp;parentStyle);
 120     newStyle.setDisplay(display);
 121     return newStyle;
 122 }
 123 
 124 RenderStyle RenderStyle::createStyleInheritingFromPseudoStyle(const RenderStyle&amp; pseudoStyle)
 125 {
 126     ASSERT(pseudoStyle.styleType() == PseudoId::Before || pseudoStyle.styleType() == PseudoId::After);
 127 
 128     auto style = create();
 129     style.inheritFrom(pseudoStyle);
 130     return style;
 131 }
 132 
</pre>
<hr />
<pre>
 148     m_inheritedFlags.listStyleType = static_cast&lt;unsigned&gt;(initialListStyleType());
 149     m_inheritedFlags.listStylePosition = static_cast&lt;unsigned&gt;(initialListStylePosition());
 150     m_inheritedFlags.visibility = static_cast&lt;unsigned&gt;(initialVisibility());
 151     m_inheritedFlags.textAlign = static_cast&lt;unsigned&gt;(initialTextAlign());
 152     m_inheritedFlags.textTransform = static_cast&lt;unsigned&gt;(initialTextTransform());
 153     m_inheritedFlags.textDecorations = initialTextDecoration().toRaw();
 154     m_inheritedFlags.cursor = static_cast&lt;unsigned&gt;(initialCursor());
 155 #if ENABLE(CURSOR_VISIBILITY)
 156     m_inheritedFlags.cursorVisibility = static_cast&lt;unsigned&gt;(initialCursorVisibility());
 157 #endif
 158     m_inheritedFlags.direction = static_cast&lt;unsigned&gt;(initialDirection());
 159     m_inheritedFlags.whiteSpace = static_cast&lt;unsigned&gt;(initialWhiteSpace());
 160     m_inheritedFlags.borderCollapse = static_cast&lt;unsigned&gt;(initialBorderCollapse());
 161     m_inheritedFlags.rtlOrdering = static_cast&lt;unsigned&gt;(initialRTLOrdering());
 162     m_inheritedFlags.boxDirection = static_cast&lt;unsigned&gt;(initialBoxDirection());
 163     m_inheritedFlags.printColorAdjust = static_cast&lt;unsigned&gt;(initialPrintColorAdjust());
 164     m_inheritedFlags.pointerEvents = static_cast&lt;unsigned&gt;(initialPointerEvents());
 165     m_inheritedFlags.insideLink = static_cast&lt;unsigned&gt;(InsideLink::NotInside);
 166     m_inheritedFlags.insideDefaultButton = false;
 167     m_inheritedFlags.writingMode = initialWritingMode();



 168 
 169     m_nonInheritedFlags.effectiveDisplay = static_cast&lt;unsigned&gt;(initialDisplay());
 170     m_nonInheritedFlags.originalDisplay = static_cast&lt;unsigned&gt;(initialDisplay());
 171     m_nonInheritedFlags.overflowX = static_cast&lt;unsigned&gt;(initialOverflowX());
 172     m_nonInheritedFlags.overflowY = static_cast&lt;unsigned&gt;(initialOverflowY());
 173     m_nonInheritedFlags.verticalAlign = static_cast&lt;unsigned&gt;(initialVerticalAlign());
 174     m_nonInheritedFlags.clear = static_cast&lt;unsigned&gt;(initialClear());
 175     m_nonInheritedFlags.position = static_cast&lt;unsigned&gt;(initialPosition());
 176     m_nonInheritedFlags.unicodeBidi = initialUnicodeBidi();
 177     m_nonInheritedFlags.floating = static_cast&lt;unsigned&gt;(initialFloating());
 178     m_nonInheritedFlags.tableLayout = static_cast&lt;unsigned&gt;(initialTableLayout());
 179     m_nonInheritedFlags.hasExplicitlySetDirection = false;
 180     m_nonInheritedFlags.hasExplicitlySetWritingMode = false;
 181     m_nonInheritedFlags.hasExplicitlySetTextAlign = false;
 182     m_nonInheritedFlags.hasViewportUnits = false;
 183     m_nonInheritedFlags.hasExplicitlyInheritedProperties = false;
 184     m_nonInheritedFlags.isUnique = false;
 185     m_nonInheritedFlags.emptyState = false;
 186     m_nonInheritedFlags.firstChildState = false;
 187     m_nonInheritedFlags.lastChildState = false;
</pre>
<hr />
<pre>
 389         return nullptr;
 390 
 391     for (auto&amp; pseudoStyle : *m_cachedPseudoStyles) {
 392         if (pseudoStyle-&gt;styleType() == pid)
 393             return pseudoStyle.get();
 394     }
 395 
 396     return nullptr;
 397 }
 398 
 399 RenderStyle* RenderStyle::addCachedPseudoStyle(std::unique_ptr&lt;RenderStyle&gt; pseudo)
 400 {
 401     if (!pseudo)
 402         return nullptr;
 403 
 404     ASSERT(pseudo-&gt;styleType() &gt; PseudoId::None);
 405 
 406     RenderStyle* result = pseudo.get();
 407 
 408     if (!m_cachedPseudoStyles)
<span class="line-modified"> 409         m_cachedPseudoStyles = std::make_unique&lt;PseudoStyleCache&gt;();</span>
 410 
 411     m_cachedPseudoStyles-&gt;append(WTFMove(pseudo));
 412 
 413     return result;
 414 }
 415 
 416 void RenderStyle::removeCachedPseudoStyle(PseudoId pid)
 417 {
 418     if (!m_cachedPseudoStyles)
 419         return;
 420     for (size_t i = 0; i &lt; m_cachedPseudoStyles-&gt;size(); ++i) {
 421         RenderStyle* pseudoStyle = m_cachedPseudoStyles-&gt;at(i).get();
 422         if (pseudoStyle-&gt;styleType() == pid) {
 423             m_cachedPseudoStyles-&gt;remove(i);
 424             return;
 425         }
 426     }
 427 }
 428 
 429 bool RenderStyle::inheritedNotEqual(const RenderStyle* other) const
</pre>
<hr />
<pre>
 472     return m_rareNonInheritedData-&gt;appearance == other.m_rareNonInheritedData-&gt;appearance
 473         &amp;&amp; m_rareNonInheritedData-&gt;marginBeforeCollapse == other.m_rareNonInheritedData-&gt;marginBeforeCollapse
 474         &amp;&amp; m_rareNonInheritedData-&gt;marginAfterCollapse == other.m_rareNonInheritedData-&gt;marginAfterCollapse
 475         &amp;&amp; m_rareNonInheritedData-&gt;lineClamp == other.m_rareNonInheritedData-&gt;lineClamp
 476         &amp;&amp; m_rareInheritedData-&gt;textSizeAdjust == other.m_rareInheritedData-&gt;textSizeAdjust
 477         &amp;&amp; m_rareInheritedData-&gt;overflowWrap == other.m_rareInheritedData-&gt;overflowWrap
 478         &amp;&amp; m_rareInheritedData-&gt;nbspMode == other.m_rareInheritedData-&gt;nbspMode
 479         &amp;&amp; m_rareInheritedData-&gt;lineBreak == other.m_rareInheritedData-&gt;lineBreak
 480         &amp;&amp; m_rareInheritedData-&gt;textSecurity == other.m_rareInheritedData-&gt;textSecurity
 481         &amp;&amp; m_inheritedData-&gt;specifiedLineHeight == other.m_inheritedData-&gt;specifiedLineHeight
 482         &amp;&amp; m_inheritedData-&gt;fontCascade.equalForTextAutoSizing(other.m_inheritedData-&gt;fontCascade)
 483         &amp;&amp; m_inheritedData-&gt;horizontalBorderSpacing == other.m_inheritedData-&gt;horizontalBorderSpacing
 484         &amp;&amp; m_inheritedData-&gt;verticalBorderSpacing == other.m_inheritedData-&gt;verticalBorderSpacing
 485         &amp;&amp; m_inheritedFlags.boxDirection == other.m_inheritedFlags.boxDirection
 486         &amp;&amp; m_inheritedFlags.rtlOrdering == other.m_inheritedFlags.rtlOrdering
 487         &amp;&amp; m_nonInheritedFlags.position == other.m_nonInheritedFlags.position
 488         &amp;&amp; m_nonInheritedFlags.floating == other.m_nonInheritedFlags.floating
 489         &amp;&amp; m_rareNonInheritedData-&gt;textOverflow == other.m_rareNonInheritedData-&gt;textOverflow;
 490 }
 491 
























































































 492 #endif // ENABLE(TEXT_AUTOSIZING)
 493 
 494 bool RenderStyle::inheritedDataShared(const RenderStyle* other) const
 495 {
 496     // This is a fast check that only looks if the data structures are shared.
 497     return m_inheritedFlags == other-&gt;m_inheritedFlags
 498         &amp;&amp; m_inheritedData.ptr() == other-&gt;m_inheritedData.ptr()
 499         &amp;&amp; m_svgStyle.ptr() == other-&gt;m_svgStyle.ptr()
 500         &amp;&amp; m_rareInheritedData.ptr() == other-&gt;m_rareInheritedData.ptr();
 501 }
 502 
 503 static bool positionChangeIsMovementOnly(const LengthBox&amp; a, const LengthBox&amp; b, const Length&amp; width)
 504 {
 505     // If any unit types are different, then we can&#39;t guarantee
 506     // that this was just a movement.
 507     if (a.left().type() != b.left().type()
 508         || a.right().type() != b.right().type()
 509         || a.top().type() != b.top().type()
 510         || a.bottom().type() != b.bottom().type())
 511         return false;
</pre>
<hr />
<pre>
 525     // One of the units is fixed or percent in both directions and stayed
 526     // that way in the new style.  Therefore all we are doing is moving.
 527     return true;
 528 }
 529 
 530 inline bool RenderStyle::changeAffectsVisualOverflow(const RenderStyle&amp; other) const
 531 {
 532     if (m_rareNonInheritedData.ptr() != other.m_rareNonInheritedData.ptr()
 533         &amp;&amp; !arePointingToEqualData(m_rareNonInheritedData-&gt;boxShadow, other.m_rareNonInheritedData-&gt;boxShadow))
 534         return true;
 535 
 536     if (m_rareInheritedData.ptr() != other.m_rareInheritedData.ptr()
 537         &amp;&amp; !arePointingToEqualData(m_rareInheritedData-&gt;textShadow, other.m_rareInheritedData-&gt;textShadow))
 538         return true;
 539 
 540     if (m_inheritedFlags.textDecorations != other.m_inheritedFlags.textDecorations
 541         || m_rareNonInheritedData-&gt;textDecorationStyle != other.m_rareNonInheritedData-&gt;textDecorationStyle
 542         || m_rareInheritedData-&gt;textDecorationThickness != other.m_rareInheritedData-&gt;textDecorationThickness
 543         || m_rareInheritedData-&gt;textUnderlineOffset != other.m_rareInheritedData-&gt;textUnderlineOffset
 544         || m_rareInheritedData-&gt;textUnderlinePosition != other.m_rareInheritedData-&gt;textUnderlinePosition) {
<span class="line-modified"> 545         return true;</span>




 546     }
 547 
 548     if (hasOutlineInVisualOverflow() != other.hasOutlineInVisualOverflow())
 549         return true;
 550     return false;
 551 }
 552 
 553 static bool rareNonInheritedDataChangeRequiresLayout(const StyleRareNonInheritedData&amp; first, const StyleRareNonInheritedData&amp; second, OptionSet&lt;StyleDifferenceContextSensitiveProperty&gt;&amp; changedContextSensitiveProperties)
 554 {
 555     ASSERT(&amp;first != &amp;second);
 556 
 557     if (first.appearance != second.appearance
 558         || first.marginBeforeCollapse != second.marginBeforeCollapse
 559         || first.marginAfterCollapse != second.marginAfterCollapse
 560         || first.lineClamp != second.lineClamp
 561         || first.initialLetter != second.initialLetter
 562         || first.textOverflow != second.textOverflow)
 563         return true;
 564 
 565     if (first.shapeMargin != second.shapeMargin)
</pre>
<hr />
<pre>
 582 
 583     if (!arePointingToEqualData(first.boxReflect, second.boxReflect))
 584         return true;
 585 
 586     if (first.multiCol != second.multiCol)
 587         return true;
 588 
 589     if (first.transform.ptr() != second.transform.ptr()) {
 590         if (first.transform-&gt;hasTransform() != second.transform-&gt;hasTransform())
 591             return true;
 592         if (*first.transform != *second.transform) {
 593             changedContextSensitiveProperties.add(StyleDifferenceContextSensitiveProperty::Transform);
 594             // Don&#39;t return; keep looking for another change
 595         }
 596     }
 597 
 598     if (first.grid != second.grid
 599         || first.gridItem != second.gridItem)
 600         return true;
 601 
<span class="line-removed"> 602 #if ENABLE(DASHBOARD_SUPPORT)</span>
<span class="line-removed"> 603     // If regions change, trigger a relayout to re-calc regions.</span>
<span class="line-removed"> 604     if (first.dashboardRegions != second.dashboardRegions)</span>
<span class="line-removed"> 605         return true;</span>
<span class="line-removed"> 606 #endif</span>
<span class="line-removed"> 607 </span>
 608     if (!arePointingToEqualData(first.willChange, second.willChange)) {
 609         changedContextSensitiveProperties.add(StyleDifferenceContextSensitiveProperty::WillChange);
 610         // Don&#39;t return; keep looking for another change
 611     }
 612 
 613     if (first.textCombine != second.textCombine)
 614         return true;
 615 
 616     if (first.breakBefore != second.breakBefore
 617         || first.breakAfter != second.breakAfter
 618         || first.breakInside != second.breakInside)
 619         return true;
 620 
 621     if (first.hasOpacity() != second.hasOpacity()) {
 622         // FIXME: We would like to use SimplifiedLayout here, but we can&#39;t quite do that yet.
 623         // We need to make sure SimplifiedLayout can operate correctly on RenderInlines (we will need
 624         // to add a selfNeedsSimplifiedLayout bit in order to not get confused and taint every line).
 625         // In addition we need to solve the floating object issue when layers come and go. Right now
 626         // a full layout is necessary to keep floating object lists sane.
 627         return true;
</pre>
<hr />
<pre>
 671         || first.hyphenationString != second.hyphenationString
 672         || first.rubyPosition != second.rubyPosition
 673         || first.textEmphasisMark != second.textEmphasisMark
 674         || first.textEmphasisPosition != second.textEmphasisPosition
 675         || first.textEmphasisCustomMark != second.textEmphasisCustomMark
 676         || first.textOrientation != second.textOrientation
 677         || first.tabSize != second.tabSize
 678         || first.lineBoxContain != second.lineBoxContain
 679         || first.lineGrid != second.lineGrid
 680 #if ENABLE(CSS_IMAGE_ORIENTATION)
 681         || first.imageOrientation != second.imageOrientation
 682 #endif
 683 #if ENABLE(CSS_IMAGE_RESOLUTION)
 684         || first.imageResolutionSource != second.imageResolutionSource
 685         || first.imageResolutionSnap != second.imageResolutionSnap
 686         || first.imageResolution != second.imageResolution
 687 #endif
 688         || first.lineSnap != second.lineSnap
 689         || first.lineAlign != second.lineAlign
 690         || first.hangingPunctuation != second.hangingPunctuation
<span class="line-modified"> 691 #if ENABLE(ACCELERATED_OVERFLOW_SCROLLING)</span>
 692         || first.useTouchOverflowScrolling != second.useTouchOverflowScrolling
 693 #endif
 694         || first.listStyleImage != second.listStyleImage) // FIXME: needs arePointingToEqualData()?
 695         return true;
 696 
 697     if (first.textStrokeWidth != second.textStrokeWidth)
 698         return true;
 699 
 700     // These properties affect the cached stroke bounding box rects.
 701     if (first.capStyle != second.capStyle
 702         || first.joinStyle != second.joinStyle
 703         || first.strokeWidth != second.strokeWidth
 704         || first.miterLimit != second.miterLimit)
 705         return true;
 706 
 707     if (!arePointingToEqualData(first.quotes, second.quotes))
 708         return true;
 709 
 710     return false;
 711 }
</pre>
<hr />
<pre>
 942 
 943     if (first.shapeOutside != second.shapeOutside)
 944         return true;
 945 
 946     // FIXME: this should probably be moved to changeRequiresLayerRepaint().
 947     if (first.clipPath != second.clipPath) {
 948         changedContextSensitiveProperties.add(StyleDifferenceContextSensitiveProperty::ClipPath);
 949         // Don&#39;t return true; keep looking for another change.
 950     }
 951 
 952     return false;
 953 }
 954 
 955 static bool rareInheritedDataChangeRequiresRepaint(const StyleRareInheritedData&amp; first, const StyleRareInheritedData&amp; second)
 956 {
 957     return first.userModify != second.userModify
 958         || first.userSelect != second.userSelect
 959         || first.appleColorFilter != second.appleColorFilter
 960         || first.imageRendering != second.imageRendering
 961 #if ENABLE(DARK_MODE_CSS)
<span class="line-modified"> 962         || first.supportedColorSchemes != second.supportedColorSchemes</span>
 963 #endif
 964     ;
 965 }
 966 
 967 #if ENABLE(CSS_PAINTING_API)
 968 void RenderStyle::addCustomPaintWatchProperty(const String&amp; name)
 969 {
 970     auto&amp; data = m_rareNonInheritedData.access();
 971     if (!data.customPaintWatchedProperties)
<span class="line-modified"> 972         data.customPaintWatchedProperties = std::make_unique&lt;HashSet&lt;String&gt;&gt;();</span>
 973     data.customPaintWatchedProperties-&gt;add(name);
 974 }
 975 
 976 inline static bool changedCustomPaintWatchedProperty(const RenderStyle&amp; a, const StyleRareNonInheritedData&amp; aData, const RenderStyle&amp; b, const StyleRareNonInheritedData&amp; bData)
 977 {
 978     auto* propertiesA = aData.customPaintWatchedProperties.get();
 979     auto* propertiesB = bData.customPaintWatchedProperties.get();
 980 
 981     if (UNLIKELY(propertiesA || propertiesB)) {
 982         // FIXME: We should not need to use ComputedStyleExtractor here.
 983         ComputedStyleExtractor extractor((Element*) nullptr);
 984 
 985         for (auto* watchPropertiesMap : { propertiesA, propertiesB }) {
 986             if (!watchPropertiesMap)
 987                 continue;
 988 
 989             for (auto&amp; name : *watchPropertiesMap) {
 990                 RefPtr&lt;CSSValue&gt; valueA;
 991                 RefPtr&lt;CSSValue&gt; valueB;
 992                 if (isCustomPropertyName(name)) {
 993                     if (a.getCustomProperty(name))
 994                         valueA = CSSCustomPropertyValue::create(*a.getCustomProperty(name));
 995                     if (b.getCustomProperty(name))
 996                         valueB = CSSCustomPropertyValue::create(*b.getCustomProperty(name));
 997                 } else {
 998                     CSSPropertyID propertyID = cssPropertyID(name);
 999                     if (!propertyID)
1000                         continue;
<span class="line-modified">1001                     valueA = extractor.valueForPropertyinStyle(a, propertyID);</span>
<span class="line-modified">1002                     valueB = extractor.valueForPropertyinStyle(b, propertyID);</span>
1003                 }
1004 
1005                 if ((valueA &amp;&amp; !valueB) || (!valueA &amp;&amp; valueB))
1006                     return true;
1007 
1008                 if (!valueA)
1009                     continue;
1010 
1011                 if (!(*valueA == *valueB))
1012                     return true;
1013             }
1014         }
1015     }
1016 
1017     return false;
1018 }
1019 #endif
1020 
1021 bool RenderStyle::changeRequiresRepaint(const RenderStyle&amp; other, OptionSet&lt;StyleDifferenceContextSensitiveProperty&gt;&amp; changedContextSensitiveProperties) const
1022 {
</pre>
<hr />
<pre>
1195     return *lastContent;
1196 }
1197 
1198 void RenderStyle::setContent(std::unique_ptr&lt;ContentData&gt; contentData, bool add)
1199 {
1200     auto&amp; data = m_rareNonInheritedData.access();
1201     if (add &amp;&amp; data.content)
1202         lastContent(*data.content).setNext(WTFMove(contentData));
1203     else {
1204         data.content = WTFMove(contentData);
1205         auto&amp; altText = data.altText;
1206         if (!altText.isNull())
1207             data.content-&gt;setAltText(altText);
1208     }
1209 }
1210 
1211 void RenderStyle::setContent(RefPtr&lt;StyleImage&gt;&amp;&amp; image, bool add)
1212 {
1213     if (!image)
1214         return;
<span class="line-modified">1215     setContent(std::make_unique&lt;ImageContentData&gt;(image.releaseNonNull()), add);</span>
1216 }
1217 
1218 void RenderStyle::setContent(const String&amp; string, bool add)
1219 {
1220     auto&amp; data = m_rareNonInheritedData.access();
1221     if (add &amp;&amp; data.content) {
1222         auto&amp; last = lastContent(*data.content);
1223         if (!is&lt;TextContentData&gt;(last))
<span class="line-modified">1224             last.setNext(std::make_unique&lt;TextContentData&gt;(string));</span>
1225         else {
1226             auto&amp; textContent = downcast&lt;TextContentData&gt;(last);
1227             textContent.setText(textContent.text() + string);
1228         }
1229     } else {
<span class="line-modified">1230         data.content = std::make_unique&lt;TextContentData&gt;(string);</span>
1231         auto&amp; altText = data.altText;
1232         if (!altText.isNull())
1233             data.content-&gt;setAltText(altText);
1234     }
1235 }
1236 
1237 void RenderStyle::setContent(std::unique_ptr&lt;CounterContent&gt; counter, bool add)
1238 {
1239     if (!counter)
1240         return;
<span class="line-modified">1241     setContent(std::make_unique&lt;CounterContentData&gt;(WTFMove(counter)), add);</span>
1242 }
1243 
1244 void RenderStyle::setContent(QuoteType quote, bool add)
1245 {
<span class="line-modified">1246     setContent(std::make_unique&lt;QuoteContentData&gt;(quote), add);</span>
1247 }
1248 
1249 void RenderStyle::setContentAltText(const String&amp; string)
1250 {
1251     auto&amp; data = m_rareNonInheritedData.access();
1252     data.altText = string;
1253     if (data.content)
1254         data.content-&gt;setAltText(string);
1255 }
1256 
1257 const String&amp; RenderStyle::contentAltText() const
1258 {
1259     return m_rareNonInheritedData-&gt;altText;
1260 }
1261 
1262 void RenderStyle::setHasAttrContent()
1263 {
1264     setUnique();
1265     SET_VAR(m_rareNonInheritedData, hasAttrContent, true);
1266 }
</pre>
<hr />
<pre>
1402 
1403 void RenderStyle::setVerticalBorderSpacing(float v)
1404 {
1405     SET_VAR(m_inheritedData, verticalBorderSpacing, v);
1406 }
1407 
1408 RoundedRect RenderStyle::getRoundedBorderFor(const LayoutRect&amp; borderRect, bool includeLogicalLeftEdge, bool includeLogicalRightEdge) const
1409 {
1410     RoundedRect roundedRect(borderRect);
1411     if (hasBorderRadius()) {
1412         RoundedRect::Radii radii = calcRadiiFor(m_surroundData-&gt;border, borderRect.size());
1413         radii.scale(calcBorderRadiiConstraintScaleFor(borderRect, radii));
1414         roundedRect.includeLogicalEdges(radii, isHorizontalWritingMode(), includeLogicalLeftEdge, includeLogicalRightEdge);
1415     }
1416     return roundedRect;
1417 }
1418 
1419 RoundedRect RenderStyle::getRoundedInnerBorderFor(const LayoutRect&amp; borderRect, bool includeLogicalLeftEdge, bool includeLogicalRightEdge) const
1420 {
1421     bool horizontal = isHorizontalWritingMode();
<span class="line-modified">1422     auto leftWidth = (!horizontal || includeLogicalLeftEdge) ? borderLeftWidth() : 0;</span>
<span class="line-modified">1423     auto rightWidth = (!horizontal || includeLogicalRightEdge) ? borderRightWidth() : 0;</span>
<span class="line-modified">1424     auto topWidth = (horizontal || includeLogicalLeftEdge) ? borderTopWidth() : 0;</span>
<span class="line-modified">1425     auto bottomWidth = (horizontal || includeLogicalRightEdge) ? borderBottomWidth() : 0;</span>
1426     return getRoundedInnerBorderFor(borderRect, topWidth, bottomWidth, leftWidth, rightWidth, includeLogicalLeftEdge, includeLogicalRightEdge);
1427 }
1428 
1429 RoundedRect RenderStyle::getRoundedInnerBorderFor(const LayoutRect&amp; borderRect, LayoutUnit topWidth, LayoutUnit bottomWidth,
1430     LayoutUnit leftWidth, LayoutUnit rightWidth, bool includeLogicalLeftEdge, bool includeLogicalRightEdge) const
1431 {
1432     RoundedRect roundedRect { { borderRect.x() + leftWidth, borderRect.y() + topWidth,
1433         borderRect.width() - leftWidth - rightWidth, borderRect.height() - topWidth - bottomWidth } };
1434     if (hasBorderRadius()) {
1435         auto radii = getRoundedBorderFor(borderRect).radii();
1436         radii.shrink(topWidth, bottomWidth, leftWidth, rightWidth);
1437         roundedRect.includeLogicalEdges(radii, isHorizontalWritingMode(), includeLogicalLeftEdge, includeLogicalRightEdge);
1438     }
1439     return roundedRect;
1440 }
1441 
1442 static bool allLayersAreFixed(const FillLayer&amp; layers)
1443 {
1444     for (auto* layer = &amp;layers; layer; layer = layer-&gt;next()) {
1445         if (!(layer-&gt;image() &amp;&amp; layer-&gt;attachment() == FillAttachment::FixedBackground))
1446             return false;
1447     }
1448     return true;
1449 }
1450 
1451 bool RenderStyle::hasEntirelyFixedBackground() const
1452 {
1453     return allLayersAreFixed(backgroundLayers());
1454 }
1455 
1456 const CounterDirectiveMap* RenderStyle::counterDirectives() const
1457 {
1458     return m_rareNonInheritedData-&gt;counterDirectives.get();
1459 }
1460 
1461 CounterDirectiveMap&amp; RenderStyle::accessCounterDirectives()
1462 {
1463     auto&amp; map = m_rareNonInheritedData.access().counterDirectives;
1464     if (!map)
<span class="line-modified">1465         map = std::make_unique&lt;CounterDirectiveMap&gt;();</span>
1466     return *map;
1467 }
1468 
<span class="line-modified">1469 const AtomicString&amp; RenderStyle::hyphenString() const</span>
1470 {
1471     ASSERT(hyphens() != Hyphens::None);
1472 
1473     auto&amp; hyphenationString = m_rareInheritedData-&gt;hyphenationString;
1474     if (!hyphenationString.isNull())
1475         return hyphenationString;
1476 
1477     // FIXME: This should depend on locale.
<span class="line-modified">1478     static NeverDestroyed&lt;AtomicString&gt; hyphenMinusString(&amp;hyphenMinus, 1);</span>
<span class="line-modified">1479     static NeverDestroyed&lt;AtomicString&gt; hyphenString(&amp;hyphen, 1);</span>
1480     return fontCascade().primaryFont().glyphForCharacter(hyphen) ? hyphenString : hyphenMinusString;
1481 }
1482 
<span class="line-modified">1483 const AtomicString&amp; RenderStyle::textEmphasisMarkString() const</span>
1484 {
1485     switch (textEmphasisMark()) {
1486     case TextEmphasisMark::None:
1487         return nullAtom();
1488     case TextEmphasisMark::Custom:
1489         return textEmphasisCustomMark();
1490     case TextEmphasisMark::Dot: {
<span class="line-modified">1491         static NeverDestroyed&lt;AtomicString&gt; filledDotString(&amp;bullet, 1);</span>
<span class="line-modified">1492         static NeverDestroyed&lt;AtomicString&gt; openDotString(&amp;whiteBullet, 1);</span>
1493         return textEmphasisFill() == TextEmphasisFill::Filled ? filledDotString : openDotString;
1494     }
1495     case TextEmphasisMark::Circle: {
<span class="line-modified">1496         static NeverDestroyed&lt;AtomicString&gt; filledCircleString(&amp;blackCircle, 1);</span>
<span class="line-modified">1497         static NeverDestroyed&lt;AtomicString&gt; openCircleString(&amp;whiteCircle, 1);</span>
1498         return textEmphasisFill() == TextEmphasisFill::Filled ? filledCircleString : openCircleString;
1499     }
1500     case TextEmphasisMark::DoubleCircle: {
<span class="line-modified">1501         static NeverDestroyed&lt;AtomicString&gt; filledDoubleCircleString(&amp;fisheye, 1);</span>
<span class="line-modified">1502         static NeverDestroyed&lt;AtomicString&gt; openDoubleCircleString(&amp;bullseye, 1);</span>
1503         return textEmphasisFill() == TextEmphasisFill::Filled ? filledDoubleCircleString : openDoubleCircleString;
1504     }
1505     case TextEmphasisMark::Triangle: {
<span class="line-modified">1506         static NeverDestroyed&lt;AtomicString&gt; filledTriangleString(&amp;blackUpPointingTriangle, 1);</span>
<span class="line-modified">1507         static NeverDestroyed&lt;AtomicString&gt; openTriangleString(&amp;whiteUpPointingTriangle, 1);</span>
1508         return textEmphasisFill() == TextEmphasisFill::Filled ? filledTriangleString : openTriangleString;
1509     }
1510     case TextEmphasisMark::Sesame: {
<span class="line-modified">1511         static NeverDestroyed&lt;AtomicString&gt; filledSesameString(&amp;sesameDot, 1);</span>
<span class="line-modified">1512         static NeverDestroyed&lt;AtomicString&gt; openSesameString(&amp;whiteSesameDot, 1);</span>
1513         return textEmphasisFill() == TextEmphasisFill::Filled ? filledSesameString : openSesameString;
1514     }
1515     case TextEmphasisMark::Auto:
1516         ASSERT_NOT_REACHED();
1517         return nullAtom();
1518     }
1519 
1520     ASSERT_NOT_REACHED();
1521     return nullAtom();
1522 }
1523 
<span class="line-removed">1524 #if ENABLE(DASHBOARD_SUPPORT)</span>
<span class="line-removed">1525 </span>
<span class="line-removed">1526 const Vector&lt;StyleDashboardRegion&gt;&amp; RenderStyle::initialDashboardRegions()</span>
<span class="line-removed">1527 {</span>
<span class="line-removed">1528     static NeverDestroyed&lt;Vector&lt;StyleDashboardRegion&gt;&gt; emptyList;</span>
<span class="line-removed">1529     return emptyList;</span>
<span class="line-removed">1530 }</span>
<span class="line-removed">1531 </span>
<span class="line-removed">1532 const Vector&lt;StyleDashboardRegion&gt;&amp; RenderStyle::noneDashboardRegions()</span>
<span class="line-removed">1533 {</span>
<span class="line-removed">1534     static NeverDestroyed&lt;Vector&lt;StyleDashboardRegion&gt;&gt; noneList;</span>
<span class="line-removed">1535     static bool noneListInitialized = false;</span>
<span class="line-removed">1536     if (!noneListInitialized) {</span>
<span class="line-removed">1537         noneList.get().append(StyleDashboardRegion { emptyString(), { }, StyleDashboardRegion::None });</span>
<span class="line-removed">1538         noneListInitialized = true;</span>
<span class="line-removed">1539     }</span>
<span class="line-removed">1540     return noneList;</span>
<span class="line-removed">1541 }</span>
<span class="line-removed">1542 </span>
<span class="line-removed">1543 #endif</span>
<span class="line-removed">1544 </span>
1545 void RenderStyle::adjustAnimations()
1546 {
1547     auto* animationList = m_rareNonInheritedData-&gt;animations.get();
1548     if (!animationList)
1549         return;
1550 
1551     // Get rid of empty animations and anything beyond them
1552     for (size_t i = 0, size = animationList-&gt;size(); i &lt; size; ++i) {
1553         if (animationList-&gt;animation(i).isEmpty()) {
1554             animationList-&gt;resize(i);
1555             break;
1556         }
1557     }
1558 
1559     if (animationList-&gt;isEmpty()) {
1560         clearAnimations();
1561         return;
1562     }
1563 
1564     // Repeat patterns into layers that don&#39;t have some properties set.
</pre>
<hr />
<pre>
1586 
1587     // Repeat patterns into layers that don&#39;t have some properties set.
1588     transitionList-&gt;fillUnsetProperties();
1589 
1590     // Make sure there are no duplicate properties.
1591     // This is an O(n^2) algorithm but the lists tend to be short, so it is probably OK.
1592     for (size_t i = 0; i &lt; transitionList-&gt;size(); ++i) {
1593         for (size_t j = i + 1; j &lt; transitionList-&gt;size(); ++j) {
1594             if (transitionList-&gt;animation(i).property() == transitionList-&gt;animation(j).property()) {
1595                 // toss i
1596                 transitionList-&gt;remove(i);
1597                 j = i;
1598             }
1599         }
1600     }
1601 }
1602 
1603 AnimationList&amp; RenderStyle::ensureAnimations()
1604 {
1605     if (!m_rareNonInheritedData.access().animations)
<span class="line-modified">1606         m_rareNonInheritedData.access().animations = std::make_unique&lt;AnimationList&gt;();</span>
1607     return *m_rareNonInheritedData-&gt;animations;
1608 }
1609 
1610 AnimationList&amp; RenderStyle::ensureTransitions()
1611 {
1612     if (!m_rareNonInheritedData.access().transitions)
<span class="line-modified">1613         m_rareNonInheritedData.access().transitions = std::make_unique&lt;AnimationList&gt;();</span>
1614     return *m_rareNonInheritedData-&gt;transitions;
1615 }
1616 
1617 const Animation* RenderStyle::transitionForProperty(CSSPropertyID property) const
1618 {
1619     auto* transitions = this-&gt;transitions();
1620     if (!transitions)
1621         return nullptr;
1622     for (size_t i = 0, size = transitions-&gt;size(); i &lt; size; ++i) {
1623         auto&amp; animation = transitions-&gt;animation(i);
1624         if (animation.animationMode() == Animation::AnimateAll || animation.property() == property)
1625             return &amp;animation;
1626     }
1627     return nullptr;
1628 }
1629 
1630 const FontCascade&amp; RenderStyle::fontCascade() const
1631 {
1632     return m_inheritedData-&gt;fontCascade;
1633 }
</pre>
<hr />
<pre>
2106 {
2107     auto mark = static_cast&lt;TextEmphasisMark&gt;(m_rareInheritedData-&gt;textEmphasisMark);
2108     if (mark != TextEmphasisMark::Auto)
2109         return mark;
2110     if (isHorizontalWritingMode())
2111         return TextEmphasisMark::Dot;
2112     return TextEmphasisMark::Sesame;
2113 }
2114 
2115 #if ENABLE(TOUCH_EVENTS)
2116 
2117 Color RenderStyle::initialTapHighlightColor()
2118 {
2119     return RenderTheme::tapHighlightColor();
2120 }
2121 
2122 #endif
2123 
2124 LayoutBoxExtent RenderStyle::imageOutsets(const NinePieceImage&amp; image) const
2125 {
<span class="line-modified">2126     return LayoutBoxExtent(NinePieceImage::computeOutset(image.outset().top(), borderTopWidth()),</span>
<span class="line-modified">2127                            NinePieceImage::computeOutset(image.outset().right(), borderRightWidth()),</span>
<span class="line-modified">2128                            NinePieceImage::computeOutset(image.outset().bottom(), borderBottomWidth()),</span>
<span class="line-modified">2129                            NinePieceImage::computeOutset(image.outset().left(), borderLeftWidth()));</span>


2130 }
2131 
2132 std::pair&lt;FontOrientation, NonCJKGlyphOrientation&gt; RenderStyle::fontAndGlyphOrientation()
2133 {
2134     // FIXME: TextOrientationSideways should map to sideways-left in vertical-lr, which is not supported yet.
2135 
2136     if (isHorizontalWritingMode())
2137         return { FontOrientation::Horizontal, NonCJKGlyphOrientation::Mixed };
2138 
2139     switch (textOrientation()) {
2140     case TextOrientation::Mixed:
2141         return { FontOrientation::Vertical, NonCJKGlyphOrientation::Mixed };
2142     case TextOrientation::Upright:
2143         return { FontOrientation::Vertical, NonCJKGlyphOrientation::Upright };
2144     case TextOrientation::Sideways:
2145         return { FontOrientation::Horizontal, NonCJKGlyphOrientation::Mixed };
2146     default:
2147         ASSERT_NOT_REACHED();
2148         return { FontOrientation::Horizontal, NonCJKGlyphOrientation::Mixed };
2149     }
</pre>
<hr />
<pre>
2367         return 0;
2368     if (outlineStyleIsAuto() == OutlineIsAuto::On)
2369         return std::max(m_backgroundData-&gt;outline.width(), RenderTheme::platformFocusRingWidth());
2370     return m_backgroundData-&gt;outline.width();
2371 }
2372 
2373 float RenderStyle::outlineOffset() const
2374 {
2375     if (m_backgroundData-&gt;outline.style() == BorderStyle::None)
2376         return 0;
2377     if (outlineStyleIsAuto() == OutlineIsAuto::On)
2378         return (m_backgroundData-&gt;outline.offset() + RenderTheme::platformFocusRingOffset(outlineWidth()));
2379     return m_backgroundData-&gt;outline.offset();
2380 }
2381 
2382 bool RenderStyle::shouldPlaceBlockDirectionScrollbarOnLeft() const
2383 {
2384     return !isLeftToRightDirection() &amp;&amp; isHorizontalWritingMode();
2385 }
2386 
<span class="line-removed">2387 #if ENABLE(DASHBOARD_SUPPORT)</span>
<span class="line-removed">2388 </span>
<span class="line-removed">2389 void RenderStyle::setDashboardRegion(int type, const String&amp; label, Length&amp;&amp; top, Length&amp;&amp; right, Length&amp;&amp; bottom, Length&amp;&amp; left, bool append)</span>
<span class="line-removed">2390 {</span>
<span class="line-removed">2391     if (!append)</span>
<span class="line-removed">2392         m_rareNonInheritedData.access().dashboardRegions.clear();</span>
<span class="line-removed">2393     m_rareNonInheritedData.access().dashboardRegions.append({ label, { WTFMove(top), WTFMove(right), WTFMove(bottom), WTFMove(left) }, type });</span>
<span class="line-removed">2394 }</span>
<span class="line-removed">2395 </span>
<span class="line-removed">2396 #endif</span>
<span class="line-removed">2397 </span>
2398 Vector&lt;PaintType, 3&gt; RenderStyle::paintTypesForPaintOrder(PaintOrder order)
2399 {
2400     Vector&lt;PaintType, 3&gt; paintOrder;
2401     switch (order) {
2402     case PaintOrder::Normal:
2403         FALLTHROUGH;
2404     case PaintOrder::Fill:
2405         paintOrder.append(PaintType::Fill);
2406         paintOrder.append(PaintType::Stroke);
2407         paintOrder.append(PaintType::Markers);
2408         break;
2409     case PaintOrder::FillMarkers:
2410         paintOrder.append(PaintType::Fill);
2411         paintOrder.append(PaintType::Markers);
2412         paintOrder.append(PaintType::Stroke);
2413         break;
2414     case PaintOrder::Stroke:
2415         paintOrder.append(PaintType::Stroke);
2416         paintOrder.append(PaintType::Fill);
2417         paintOrder.append(PaintType::Markers);
</pre>
</td>
<td>
<hr />
<pre>
  92     return style;
  93 }
  94 
  95 RenderStyle RenderStyle::create()
  96 {
  97     return clone(defaultStyle());
  98 }
  99 
 100 std::unique_ptr&lt;RenderStyle&gt; RenderStyle::createPtr()
 101 {
 102     return clonePtr(defaultStyle());
 103 }
 104 
 105 RenderStyle RenderStyle::clone(const RenderStyle&amp; style)
 106 {
 107     return RenderStyle(style, Clone);
 108 }
 109 
 110 std::unique_ptr&lt;RenderStyle&gt; RenderStyle::clonePtr(const RenderStyle&amp; style)
 111 {
<span class="line-modified"> 112     return makeUnique&lt;RenderStyle&gt;(style, Clone);</span>
 113 }
 114 
 115 RenderStyle RenderStyle::createAnonymousStyleWithDisplay(const RenderStyle&amp; parentStyle, DisplayType display)
 116 {
 117     auto newStyle = create();
 118     newStyle.inheritFrom(parentStyle);
 119     newStyle.inheritUnicodeBidiFrom(&amp;parentStyle);
 120     newStyle.setDisplay(display);
 121     return newStyle;
 122 }
 123 
 124 RenderStyle RenderStyle::createStyleInheritingFromPseudoStyle(const RenderStyle&amp; pseudoStyle)
 125 {
 126     ASSERT(pseudoStyle.styleType() == PseudoId::Before || pseudoStyle.styleType() == PseudoId::After);
 127 
 128     auto style = create();
 129     style.inheritFrom(pseudoStyle);
 130     return style;
 131 }
 132 
</pre>
<hr />
<pre>
 148     m_inheritedFlags.listStyleType = static_cast&lt;unsigned&gt;(initialListStyleType());
 149     m_inheritedFlags.listStylePosition = static_cast&lt;unsigned&gt;(initialListStylePosition());
 150     m_inheritedFlags.visibility = static_cast&lt;unsigned&gt;(initialVisibility());
 151     m_inheritedFlags.textAlign = static_cast&lt;unsigned&gt;(initialTextAlign());
 152     m_inheritedFlags.textTransform = static_cast&lt;unsigned&gt;(initialTextTransform());
 153     m_inheritedFlags.textDecorations = initialTextDecoration().toRaw();
 154     m_inheritedFlags.cursor = static_cast&lt;unsigned&gt;(initialCursor());
 155 #if ENABLE(CURSOR_VISIBILITY)
 156     m_inheritedFlags.cursorVisibility = static_cast&lt;unsigned&gt;(initialCursorVisibility());
 157 #endif
 158     m_inheritedFlags.direction = static_cast&lt;unsigned&gt;(initialDirection());
 159     m_inheritedFlags.whiteSpace = static_cast&lt;unsigned&gt;(initialWhiteSpace());
 160     m_inheritedFlags.borderCollapse = static_cast&lt;unsigned&gt;(initialBorderCollapse());
 161     m_inheritedFlags.rtlOrdering = static_cast&lt;unsigned&gt;(initialRTLOrdering());
 162     m_inheritedFlags.boxDirection = static_cast&lt;unsigned&gt;(initialBoxDirection());
 163     m_inheritedFlags.printColorAdjust = static_cast&lt;unsigned&gt;(initialPrintColorAdjust());
 164     m_inheritedFlags.pointerEvents = static_cast&lt;unsigned&gt;(initialPointerEvents());
 165     m_inheritedFlags.insideLink = static_cast&lt;unsigned&gt;(InsideLink::NotInside);
 166     m_inheritedFlags.insideDefaultButton = false;
 167     m_inheritedFlags.writingMode = initialWritingMode();
<span class="line-added"> 168 #if ENABLE(TEXT_AUTOSIZING)</span>
<span class="line-added"> 169     m_inheritedFlags.autosizeStatus = 0;</span>
<span class="line-added"> 170 #endif</span>
 171 
 172     m_nonInheritedFlags.effectiveDisplay = static_cast&lt;unsigned&gt;(initialDisplay());
 173     m_nonInheritedFlags.originalDisplay = static_cast&lt;unsigned&gt;(initialDisplay());
 174     m_nonInheritedFlags.overflowX = static_cast&lt;unsigned&gt;(initialOverflowX());
 175     m_nonInheritedFlags.overflowY = static_cast&lt;unsigned&gt;(initialOverflowY());
 176     m_nonInheritedFlags.verticalAlign = static_cast&lt;unsigned&gt;(initialVerticalAlign());
 177     m_nonInheritedFlags.clear = static_cast&lt;unsigned&gt;(initialClear());
 178     m_nonInheritedFlags.position = static_cast&lt;unsigned&gt;(initialPosition());
 179     m_nonInheritedFlags.unicodeBidi = initialUnicodeBidi();
 180     m_nonInheritedFlags.floating = static_cast&lt;unsigned&gt;(initialFloating());
 181     m_nonInheritedFlags.tableLayout = static_cast&lt;unsigned&gt;(initialTableLayout());
 182     m_nonInheritedFlags.hasExplicitlySetDirection = false;
 183     m_nonInheritedFlags.hasExplicitlySetWritingMode = false;
 184     m_nonInheritedFlags.hasExplicitlySetTextAlign = false;
 185     m_nonInheritedFlags.hasViewportUnits = false;
 186     m_nonInheritedFlags.hasExplicitlyInheritedProperties = false;
 187     m_nonInheritedFlags.isUnique = false;
 188     m_nonInheritedFlags.emptyState = false;
 189     m_nonInheritedFlags.firstChildState = false;
 190     m_nonInheritedFlags.lastChildState = false;
</pre>
<hr />
<pre>
 392         return nullptr;
 393 
 394     for (auto&amp; pseudoStyle : *m_cachedPseudoStyles) {
 395         if (pseudoStyle-&gt;styleType() == pid)
 396             return pseudoStyle.get();
 397     }
 398 
 399     return nullptr;
 400 }
 401 
 402 RenderStyle* RenderStyle::addCachedPseudoStyle(std::unique_ptr&lt;RenderStyle&gt; pseudo)
 403 {
 404     if (!pseudo)
 405         return nullptr;
 406 
 407     ASSERT(pseudo-&gt;styleType() &gt; PseudoId::None);
 408 
 409     RenderStyle* result = pseudo.get();
 410 
 411     if (!m_cachedPseudoStyles)
<span class="line-modified"> 412         m_cachedPseudoStyles = makeUnique&lt;PseudoStyleCache&gt;();</span>
 413 
 414     m_cachedPseudoStyles-&gt;append(WTFMove(pseudo));
 415 
 416     return result;
 417 }
 418 
 419 void RenderStyle::removeCachedPseudoStyle(PseudoId pid)
 420 {
 421     if (!m_cachedPseudoStyles)
 422         return;
 423     for (size_t i = 0; i &lt; m_cachedPseudoStyles-&gt;size(); ++i) {
 424         RenderStyle* pseudoStyle = m_cachedPseudoStyles-&gt;at(i).get();
 425         if (pseudoStyle-&gt;styleType() == pid) {
 426             m_cachedPseudoStyles-&gt;remove(i);
 427             return;
 428         }
 429     }
 430 }
 431 
 432 bool RenderStyle::inheritedNotEqual(const RenderStyle* other) const
</pre>
<hr />
<pre>
 475     return m_rareNonInheritedData-&gt;appearance == other.m_rareNonInheritedData-&gt;appearance
 476         &amp;&amp; m_rareNonInheritedData-&gt;marginBeforeCollapse == other.m_rareNonInheritedData-&gt;marginBeforeCollapse
 477         &amp;&amp; m_rareNonInheritedData-&gt;marginAfterCollapse == other.m_rareNonInheritedData-&gt;marginAfterCollapse
 478         &amp;&amp; m_rareNonInheritedData-&gt;lineClamp == other.m_rareNonInheritedData-&gt;lineClamp
 479         &amp;&amp; m_rareInheritedData-&gt;textSizeAdjust == other.m_rareInheritedData-&gt;textSizeAdjust
 480         &amp;&amp; m_rareInheritedData-&gt;overflowWrap == other.m_rareInheritedData-&gt;overflowWrap
 481         &amp;&amp; m_rareInheritedData-&gt;nbspMode == other.m_rareInheritedData-&gt;nbspMode
 482         &amp;&amp; m_rareInheritedData-&gt;lineBreak == other.m_rareInheritedData-&gt;lineBreak
 483         &amp;&amp; m_rareInheritedData-&gt;textSecurity == other.m_rareInheritedData-&gt;textSecurity
 484         &amp;&amp; m_inheritedData-&gt;specifiedLineHeight == other.m_inheritedData-&gt;specifiedLineHeight
 485         &amp;&amp; m_inheritedData-&gt;fontCascade.equalForTextAutoSizing(other.m_inheritedData-&gt;fontCascade)
 486         &amp;&amp; m_inheritedData-&gt;horizontalBorderSpacing == other.m_inheritedData-&gt;horizontalBorderSpacing
 487         &amp;&amp; m_inheritedData-&gt;verticalBorderSpacing == other.m_inheritedData-&gt;verticalBorderSpacing
 488         &amp;&amp; m_inheritedFlags.boxDirection == other.m_inheritedFlags.boxDirection
 489         &amp;&amp; m_inheritedFlags.rtlOrdering == other.m_inheritedFlags.rtlOrdering
 490         &amp;&amp; m_nonInheritedFlags.position == other.m_nonInheritedFlags.position
 491         &amp;&amp; m_nonInheritedFlags.floating == other.m_nonInheritedFlags.floating
 492         &amp;&amp; m_rareNonInheritedData-&gt;textOverflow == other.m_rareNonInheritedData-&gt;textOverflow;
 493 }
 494 
<span class="line-added"> 495 bool RenderStyle::isIdempotentTextAutosizingCandidate() const</span>
<span class="line-added"> 496 {</span>
<span class="line-added"> 497     // Refer to &lt;rdar://problem/51826266&gt; for more information regarding how this function was generated.</span>
<span class="line-added"> 498     auto fields = OptionSet&lt;AutosizeStatus::Fields&gt;::fromRaw(m_inheritedFlags.autosizeStatus);</span>
<span class="line-added"> 499     if (fields.contains(AutosizeStatus::Fields::AvoidSubtree))</span>
<span class="line-added"> 500         return false;</span>
<span class="line-added"> 501 </span>
<span class="line-added"> 502     const float smallMinimumDifferenceThresholdBetweenLineHeightAndSpecifiedFontSizeForBoostingText = 5;</span>
<span class="line-added"> 503     const float largeMinimumDifferenceThresholdBetweenLineHeightAndSpecifiedFontSizeForBoostingText = 25;</span>
<span class="line-added"> 504 </span>
<span class="line-added"> 505     if (fields.contains(AutosizeStatus::Fields::FixedHeight)) {</span>
<span class="line-added"> 506         if (fields.contains(AutosizeStatus::Fields::FixedWidth)) {</span>
<span class="line-added"> 507             if (whiteSpace() == WhiteSpace::NoWrap) {</span>
<span class="line-added"> 508                 if (width().isFixed())</span>
<span class="line-added"> 509                     return false;</span>
<span class="line-added"> 510 </span>
<span class="line-added"> 511                 if (height().isFixed() &amp;&amp; specifiedLineHeight().isFixed()) {</span>
<span class="line-added"> 512                     float specifiedSize = specifiedFontSize();</span>
<span class="line-added"> 513                     if (height().value() == specifiedSize &amp;&amp; specifiedLineHeight().value() == specifiedSize)</span>
<span class="line-added"> 514                         return false;</span>
<span class="line-added"> 515                 }</span>
<span class="line-added"> 516 </span>
<span class="line-added"> 517                 return true;</span>
<span class="line-added"> 518             }</span>
<span class="line-added"> 519 </span>
<span class="line-added"> 520             if (fields.contains(AutosizeStatus::Fields::Floating)) {</span>
<span class="line-added"> 521                 if (specifiedLineHeight().isFixed() &amp;&amp; height().isFixed()) {</span>
<span class="line-added"> 522                     float specifiedSize = specifiedFontSize();</span>
<span class="line-added"> 523                     if (specifiedLineHeight().value() - specifiedSize &gt; smallMinimumDifferenceThresholdBetweenLineHeightAndSpecifiedFontSizeForBoostingText</span>
<span class="line-added"> 524                         &amp;&amp; height().value() - specifiedSize &gt; smallMinimumDifferenceThresholdBetweenLineHeightAndSpecifiedFontSizeForBoostingText) {</span>
<span class="line-added"> 525                         return true;</span>
<span class="line-added"> 526                     }</span>
<span class="line-added"> 527                 }</span>
<span class="line-added"> 528                 return false;</span>
<span class="line-added"> 529             }</span>
<span class="line-added"> 530 </span>
<span class="line-added"> 531             if (fields.contains(AutosizeStatus::Fields::OverflowXHidden))</span>
<span class="line-added"> 532                 return false;</span>
<span class="line-added"> 533 </span>
<span class="line-added"> 534             return true;</span>
<span class="line-added"> 535         }</span>
<span class="line-added"> 536 </span>
<span class="line-added"> 537         if (fields.contains(AutosizeStatus::Fields::OverflowXHidden)) {</span>
<span class="line-added"> 538             if (fields.contains(AutosizeStatus::Fields::Floating))</span>
<span class="line-added"> 539                 return false;</span>
<span class="line-added"> 540 </span>
<span class="line-added"> 541             return true;</span>
<span class="line-added"> 542         }</span>
<span class="line-added"> 543 </span>
<span class="line-added"> 544         return true;</span>
<span class="line-added"> 545     }</span>
<span class="line-added"> 546 </span>
<span class="line-added"> 547     if (width().isFixed()) {</span>
<span class="line-added"> 548         if (breakWords())</span>
<span class="line-added"> 549             return true;</span>
<span class="line-added"> 550 </span>
<span class="line-added"> 551         return false;</span>
<span class="line-added"> 552     }</span>
<span class="line-added"> 553 </span>
<span class="line-added"> 554     if (textSizeAdjust().isPercentage() &amp;&amp; textSizeAdjust().percentage() == 100) {</span>
<span class="line-added"> 555         if (fields.contains(AutosizeStatus::Fields::Floating))</span>
<span class="line-added"> 556             return true;</span>
<span class="line-added"> 557 </span>
<span class="line-added"> 558         if (fields.contains(AutosizeStatus::Fields::FixedWidth))</span>
<span class="line-added"> 559             return true;</span>
<span class="line-added"> 560 </span>
<span class="line-added"> 561         if (specifiedLineHeight().isFixed() &amp;&amp; specifiedLineHeight().value() - specifiedFontSize() &gt; largeMinimumDifferenceThresholdBetweenLineHeightAndSpecifiedFontSizeForBoostingText)</span>
<span class="line-added"> 562             return true;</span>
<span class="line-added"> 563 </span>
<span class="line-added"> 564         return false;</span>
<span class="line-added"> 565     }</span>
<span class="line-added"> 566 </span>
<span class="line-added"> 567     if (hasBackgroundImage() &amp;&amp; backgroundRepeatX() == FillRepeat::NoRepeat &amp;&amp; backgroundRepeatY() == FillRepeat::NoRepeat)</span>
<span class="line-added"> 568         return false;</span>
<span class="line-added"> 569 </span>
<span class="line-added"> 570     return true;</span>
<span class="line-added"> 571 }</span>
<span class="line-added"> 572 </span>
<span class="line-added"> 573 AutosizeStatus RenderStyle::autosizeStatus() const</span>
<span class="line-added"> 574 {</span>
<span class="line-added"> 575     return OptionSet&lt;AutosizeStatus::Fields&gt;::fromRaw(m_inheritedFlags.autosizeStatus);</span>
<span class="line-added"> 576 }</span>
<span class="line-added"> 577 </span>
<span class="line-added"> 578 void RenderStyle::setAutosizeStatus(AutosizeStatus autosizeStatus)</span>
<span class="line-added"> 579 {</span>
<span class="line-added"> 580     m_inheritedFlags.autosizeStatus = autosizeStatus.fields().toRaw();</span>
<span class="line-added"> 581 }</span>
<span class="line-added"> 582 </span>
 583 #endif // ENABLE(TEXT_AUTOSIZING)
 584 
 585 bool RenderStyle::inheritedDataShared(const RenderStyle* other) const
 586 {
 587     // This is a fast check that only looks if the data structures are shared.
 588     return m_inheritedFlags == other-&gt;m_inheritedFlags
 589         &amp;&amp; m_inheritedData.ptr() == other-&gt;m_inheritedData.ptr()
 590         &amp;&amp; m_svgStyle.ptr() == other-&gt;m_svgStyle.ptr()
 591         &amp;&amp; m_rareInheritedData.ptr() == other-&gt;m_rareInheritedData.ptr();
 592 }
 593 
 594 static bool positionChangeIsMovementOnly(const LengthBox&amp; a, const LengthBox&amp; b, const Length&amp; width)
 595 {
 596     // If any unit types are different, then we can&#39;t guarantee
 597     // that this was just a movement.
 598     if (a.left().type() != b.left().type()
 599         || a.right().type() != b.right().type()
 600         || a.top().type() != b.top().type()
 601         || a.bottom().type() != b.bottom().type())
 602         return false;
</pre>
<hr />
<pre>
 616     // One of the units is fixed or percent in both directions and stayed
 617     // that way in the new style.  Therefore all we are doing is moving.
 618     return true;
 619 }
 620 
 621 inline bool RenderStyle::changeAffectsVisualOverflow(const RenderStyle&amp; other) const
 622 {
 623     if (m_rareNonInheritedData.ptr() != other.m_rareNonInheritedData.ptr()
 624         &amp;&amp; !arePointingToEqualData(m_rareNonInheritedData-&gt;boxShadow, other.m_rareNonInheritedData-&gt;boxShadow))
 625         return true;
 626 
 627     if (m_rareInheritedData.ptr() != other.m_rareInheritedData.ptr()
 628         &amp;&amp; !arePointingToEqualData(m_rareInheritedData-&gt;textShadow, other.m_rareInheritedData-&gt;textShadow))
 629         return true;
 630 
 631     if (m_inheritedFlags.textDecorations != other.m_inheritedFlags.textDecorations
 632         || m_rareNonInheritedData-&gt;textDecorationStyle != other.m_rareNonInheritedData-&gt;textDecorationStyle
 633         || m_rareInheritedData-&gt;textDecorationThickness != other.m_rareInheritedData-&gt;textDecorationThickness
 634         || m_rareInheritedData-&gt;textUnderlineOffset != other.m_rareInheritedData-&gt;textUnderlineOffset
 635         || m_rareInheritedData-&gt;textUnderlinePosition != other.m_rareInheritedData-&gt;textUnderlinePosition) {
<span class="line-modified"> 636         // Underlines are always drawn outside of their textbox bounds when text-underline-position: under;</span>
<span class="line-added"> 637         // is specified. We can take an early out here.</span>
<span class="line-added"> 638         if (textUnderlinePosition() == TextUnderlinePosition::Under || other.textUnderlinePosition() == TextUnderlinePosition::Under)</span>
<span class="line-added"> 639             return true;</span>
<span class="line-added"> 640         return visualOverflowForDecorations(*this, nullptr) != visualOverflowForDecorations(other, nullptr);</span>
 641     }
 642 
 643     if (hasOutlineInVisualOverflow() != other.hasOutlineInVisualOverflow())
 644         return true;
 645     return false;
 646 }
 647 
 648 static bool rareNonInheritedDataChangeRequiresLayout(const StyleRareNonInheritedData&amp; first, const StyleRareNonInheritedData&amp; second, OptionSet&lt;StyleDifferenceContextSensitiveProperty&gt;&amp; changedContextSensitiveProperties)
 649 {
 650     ASSERT(&amp;first != &amp;second);
 651 
 652     if (first.appearance != second.appearance
 653         || first.marginBeforeCollapse != second.marginBeforeCollapse
 654         || first.marginAfterCollapse != second.marginAfterCollapse
 655         || first.lineClamp != second.lineClamp
 656         || first.initialLetter != second.initialLetter
 657         || first.textOverflow != second.textOverflow)
 658         return true;
 659 
 660     if (first.shapeMargin != second.shapeMargin)
</pre>
<hr />
<pre>
 677 
 678     if (!arePointingToEqualData(first.boxReflect, second.boxReflect))
 679         return true;
 680 
 681     if (first.multiCol != second.multiCol)
 682         return true;
 683 
 684     if (first.transform.ptr() != second.transform.ptr()) {
 685         if (first.transform-&gt;hasTransform() != second.transform-&gt;hasTransform())
 686             return true;
 687         if (*first.transform != *second.transform) {
 688             changedContextSensitiveProperties.add(StyleDifferenceContextSensitiveProperty::Transform);
 689             // Don&#39;t return; keep looking for another change
 690         }
 691     }
 692 
 693     if (first.grid != second.grid
 694         || first.gridItem != second.gridItem)
 695         return true;
 696 






 697     if (!arePointingToEqualData(first.willChange, second.willChange)) {
 698         changedContextSensitiveProperties.add(StyleDifferenceContextSensitiveProperty::WillChange);
 699         // Don&#39;t return; keep looking for another change
 700     }
 701 
 702     if (first.textCombine != second.textCombine)
 703         return true;
 704 
 705     if (first.breakBefore != second.breakBefore
 706         || first.breakAfter != second.breakAfter
 707         || first.breakInside != second.breakInside)
 708         return true;
 709 
 710     if (first.hasOpacity() != second.hasOpacity()) {
 711         // FIXME: We would like to use SimplifiedLayout here, but we can&#39;t quite do that yet.
 712         // We need to make sure SimplifiedLayout can operate correctly on RenderInlines (we will need
 713         // to add a selfNeedsSimplifiedLayout bit in order to not get confused and taint every line).
 714         // In addition we need to solve the floating object issue when layers come and go. Right now
 715         // a full layout is necessary to keep floating object lists sane.
 716         return true;
</pre>
<hr />
<pre>
 760         || first.hyphenationString != second.hyphenationString
 761         || first.rubyPosition != second.rubyPosition
 762         || first.textEmphasisMark != second.textEmphasisMark
 763         || first.textEmphasisPosition != second.textEmphasisPosition
 764         || first.textEmphasisCustomMark != second.textEmphasisCustomMark
 765         || first.textOrientation != second.textOrientation
 766         || first.tabSize != second.tabSize
 767         || first.lineBoxContain != second.lineBoxContain
 768         || first.lineGrid != second.lineGrid
 769 #if ENABLE(CSS_IMAGE_ORIENTATION)
 770         || first.imageOrientation != second.imageOrientation
 771 #endif
 772 #if ENABLE(CSS_IMAGE_RESOLUTION)
 773         || first.imageResolutionSource != second.imageResolutionSource
 774         || first.imageResolutionSnap != second.imageResolutionSnap
 775         || first.imageResolution != second.imageResolution
 776 #endif
 777         || first.lineSnap != second.lineSnap
 778         || first.lineAlign != second.lineAlign
 779         || first.hangingPunctuation != second.hangingPunctuation
<span class="line-modified"> 780 #if ENABLE(OVERFLOW_SCROLLING_TOUCH)</span>
 781         || first.useTouchOverflowScrolling != second.useTouchOverflowScrolling
 782 #endif
 783         || first.listStyleImage != second.listStyleImage) // FIXME: needs arePointingToEqualData()?
 784         return true;
 785 
 786     if (first.textStrokeWidth != second.textStrokeWidth)
 787         return true;
 788 
 789     // These properties affect the cached stroke bounding box rects.
 790     if (first.capStyle != second.capStyle
 791         || first.joinStyle != second.joinStyle
 792         || first.strokeWidth != second.strokeWidth
 793         || first.miterLimit != second.miterLimit)
 794         return true;
 795 
 796     if (!arePointingToEqualData(first.quotes, second.quotes))
 797         return true;
 798 
 799     return false;
 800 }
</pre>
<hr />
<pre>
1031 
1032     if (first.shapeOutside != second.shapeOutside)
1033         return true;
1034 
1035     // FIXME: this should probably be moved to changeRequiresLayerRepaint().
1036     if (first.clipPath != second.clipPath) {
1037         changedContextSensitiveProperties.add(StyleDifferenceContextSensitiveProperty::ClipPath);
1038         // Don&#39;t return true; keep looking for another change.
1039     }
1040 
1041     return false;
1042 }
1043 
1044 static bool rareInheritedDataChangeRequiresRepaint(const StyleRareInheritedData&amp; first, const StyleRareInheritedData&amp; second)
1045 {
1046     return first.userModify != second.userModify
1047         || first.userSelect != second.userSelect
1048         || first.appleColorFilter != second.appleColorFilter
1049         || first.imageRendering != second.imageRendering
1050 #if ENABLE(DARK_MODE_CSS)
<span class="line-modified">1051         || first.colorScheme != second.colorScheme</span>
1052 #endif
1053     ;
1054 }
1055 
1056 #if ENABLE(CSS_PAINTING_API)
1057 void RenderStyle::addCustomPaintWatchProperty(const String&amp; name)
1058 {
1059     auto&amp; data = m_rareNonInheritedData.access();
1060     if (!data.customPaintWatchedProperties)
<span class="line-modified">1061         data.customPaintWatchedProperties = makeUnique&lt;HashSet&lt;String&gt;&gt;();</span>
1062     data.customPaintWatchedProperties-&gt;add(name);
1063 }
1064 
1065 inline static bool changedCustomPaintWatchedProperty(const RenderStyle&amp; a, const StyleRareNonInheritedData&amp; aData, const RenderStyle&amp; b, const StyleRareNonInheritedData&amp; bData)
1066 {
1067     auto* propertiesA = aData.customPaintWatchedProperties.get();
1068     auto* propertiesB = bData.customPaintWatchedProperties.get();
1069 
1070     if (UNLIKELY(propertiesA || propertiesB)) {
1071         // FIXME: We should not need to use ComputedStyleExtractor here.
1072         ComputedStyleExtractor extractor((Element*) nullptr);
1073 
1074         for (auto* watchPropertiesMap : { propertiesA, propertiesB }) {
1075             if (!watchPropertiesMap)
1076                 continue;
1077 
1078             for (auto&amp; name : *watchPropertiesMap) {
1079                 RefPtr&lt;CSSValue&gt; valueA;
1080                 RefPtr&lt;CSSValue&gt; valueB;
1081                 if (isCustomPropertyName(name)) {
1082                     if (a.getCustomProperty(name))
1083                         valueA = CSSCustomPropertyValue::create(*a.getCustomProperty(name));
1084                     if (b.getCustomProperty(name))
1085                         valueB = CSSCustomPropertyValue::create(*b.getCustomProperty(name));
1086                 } else {
1087                     CSSPropertyID propertyID = cssPropertyID(name);
1088                     if (!propertyID)
1089                         continue;
<span class="line-modified">1090                     valueA = extractor.valueForPropertyInStyle(a, propertyID);</span>
<span class="line-modified">1091                     valueB = extractor.valueForPropertyInStyle(b, propertyID);</span>
1092                 }
1093 
1094                 if ((valueA &amp;&amp; !valueB) || (!valueA &amp;&amp; valueB))
1095                     return true;
1096 
1097                 if (!valueA)
1098                     continue;
1099 
1100                 if (!(*valueA == *valueB))
1101                     return true;
1102             }
1103         }
1104     }
1105 
1106     return false;
1107 }
1108 #endif
1109 
1110 bool RenderStyle::changeRequiresRepaint(const RenderStyle&amp; other, OptionSet&lt;StyleDifferenceContextSensitiveProperty&gt;&amp; changedContextSensitiveProperties) const
1111 {
</pre>
<hr />
<pre>
1284     return *lastContent;
1285 }
1286 
1287 void RenderStyle::setContent(std::unique_ptr&lt;ContentData&gt; contentData, bool add)
1288 {
1289     auto&amp; data = m_rareNonInheritedData.access();
1290     if (add &amp;&amp; data.content)
1291         lastContent(*data.content).setNext(WTFMove(contentData));
1292     else {
1293         data.content = WTFMove(contentData);
1294         auto&amp; altText = data.altText;
1295         if (!altText.isNull())
1296             data.content-&gt;setAltText(altText);
1297     }
1298 }
1299 
1300 void RenderStyle::setContent(RefPtr&lt;StyleImage&gt;&amp;&amp; image, bool add)
1301 {
1302     if (!image)
1303         return;
<span class="line-modified">1304     setContent(makeUnique&lt;ImageContentData&gt;(image.releaseNonNull()), add);</span>
1305 }
1306 
1307 void RenderStyle::setContent(const String&amp; string, bool add)
1308 {
1309     auto&amp; data = m_rareNonInheritedData.access();
1310     if (add &amp;&amp; data.content) {
1311         auto&amp; last = lastContent(*data.content);
1312         if (!is&lt;TextContentData&gt;(last))
<span class="line-modified">1313             last.setNext(makeUnique&lt;TextContentData&gt;(string));</span>
1314         else {
1315             auto&amp; textContent = downcast&lt;TextContentData&gt;(last);
1316             textContent.setText(textContent.text() + string);
1317         }
1318     } else {
<span class="line-modified">1319         data.content = makeUnique&lt;TextContentData&gt;(string);</span>
1320         auto&amp; altText = data.altText;
1321         if (!altText.isNull())
1322             data.content-&gt;setAltText(altText);
1323     }
1324 }
1325 
1326 void RenderStyle::setContent(std::unique_ptr&lt;CounterContent&gt; counter, bool add)
1327 {
1328     if (!counter)
1329         return;
<span class="line-modified">1330     setContent(makeUnique&lt;CounterContentData&gt;(WTFMove(counter)), add);</span>
1331 }
1332 
1333 void RenderStyle::setContent(QuoteType quote, bool add)
1334 {
<span class="line-modified">1335     setContent(makeUnique&lt;QuoteContentData&gt;(quote), add);</span>
1336 }
1337 
1338 void RenderStyle::setContentAltText(const String&amp; string)
1339 {
1340     auto&amp; data = m_rareNonInheritedData.access();
1341     data.altText = string;
1342     if (data.content)
1343         data.content-&gt;setAltText(string);
1344 }
1345 
1346 const String&amp; RenderStyle::contentAltText() const
1347 {
1348     return m_rareNonInheritedData-&gt;altText;
1349 }
1350 
1351 void RenderStyle::setHasAttrContent()
1352 {
1353     setUnique();
1354     SET_VAR(m_rareNonInheritedData, hasAttrContent, true);
1355 }
</pre>
<hr />
<pre>
1491 
1492 void RenderStyle::setVerticalBorderSpacing(float v)
1493 {
1494     SET_VAR(m_inheritedData, verticalBorderSpacing, v);
1495 }
1496 
1497 RoundedRect RenderStyle::getRoundedBorderFor(const LayoutRect&amp; borderRect, bool includeLogicalLeftEdge, bool includeLogicalRightEdge) const
1498 {
1499     RoundedRect roundedRect(borderRect);
1500     if (hasBorderRadius()) {
1501         RoundedRect::Radii radii = calcRadiiFor(m_surroundData-&gt;border, borderRect.size());
1502         radii.scale(calcBorderRadiiConstraintScaleFor(borderRect, radii));
1503         roundedRect.includeLogicalEdges(radii, isHorizontalWritingMode(), includeLogicalLeftEdge, includeLogicalRightEdge);
1504     }
1505     return roundedRect;
1506 }
1507 
1508 RoundedRect RenderStyle::getRoundedInnerBorderFor(const LayoutRect&amp; borderRect, bool includeLogicalLeftEdge, bool includeLogicalRightEdge) const
1509 {
1510     bool horizontal = isHorizontalWritingMode();
<span class="line-modified">1511     LayoutUnit leftWidth { (!horizontal || includeLogicalLeftEdge) ? borderLeftWidth() : 0 };</span>
<span class="line-modified">1512     LayoutUnit rightWidth { (!horizontal || includeLogicalRightEdge) ? borderRightWidth() : 0 };</span>
<span class="line-modified">1513     LayoutUnit topWidth { (horizontal || includeLogicalLeftEdge) ? borderTopWidth() : 0 };</span>
<span class="line-modified">1514     LayoutUnit bottomWidth { (horizontal || includeLogicalRightEdge) ? borderBottomWidth() : 0 };</span>
1515     return getRoundedInnerBorderFor(borderRect, topWidth, bottomWidth, leftWidth, rightWidth, includeLogicalLeftEdge, includeLogicalRightEdge);
1516 }
1517 
1518 RoundedRect RenderStyle::getRoundedInnerBorderFor(const LayoutRect&amp; borderRect, LayoutUnit topWidth, LayoutUnit bottomWidth,
1519     LayoutUnit leftWidth, LayoutUnit rightWidth, bool includeLogicalLeftEdge, bool includeLogicalRightEdge) const
1520 {
1521     RoundedRect roundedRect { { borderRect.x() + leftWidth, borderRect.y() + topWidth,
1522         borderRect.width() - leftWidth - rightWidth, borderRect.height() - topWidth - bottomWidth } };
1523     if (hasBorderRadius()) {
1524         auto radii = getRoundedBorderFor(borderRect).radii();
1525         radii.shrink(topWidth, bottomWidth, leftWidth, rightWidth);
1526         roundedRect.includeLogicalEdges(radii, isHorizontalWritingMode(), includeLogicalLeftEdge, includeLogicalRightEdge);
1527     }
1528     return roundedRect;
1529 }
1530 
1531 static bool allLayersAreFixed(const FillLayer&amp; layers)
1532 {
1533     for (auto* layer = &amp;layers; layer; layer = layer-&gt;next()) {
1534         if (!(layer-&gt;image() &amp;&amp; layer-&gt;attachment() == FillAttachment::FixedBackground))
1535             return false;
1536     }
1537     return true;
1538 }
1539 
1540 bool RenderStyle::hasEntirelyFixedBackground() const
1541 {
1542     return allLayersAreFixed(backgroundLayers());
1543 }
1544 
1545 const CounterDirectiveMap* RenderStyle::counterDirectives() const
1546 {
1547     return m_rareNonInheritedData-&gt;counterDirectives.get();
1548 }
1549 
1550 CounterDirectiveMap&amp; RenderStyle::accessCounterDirectives()
1551 {
1552     auto&amp; map = m_rareNonInheritedData.access().counterDirectives;
1553     if (!map)
<span class="line-modified">1554         map = makeUnique&lt;CounterDirectiveMap&gt;();</span>
1555     return *map;
1556 }
1557 
<span class="line-modified">1558 const AtomString&amp; RenderStyle::hyphenString() const</span>
1559 {
1560     ASSERT(hyphens() != Hyphens::None);
1561 
1562     auto&amp; hyphenationString = m_rareInheritedData-&gt;hyphenationString;
1563     if (!hyphenationString.isNull())
1564         return hyphenationString;
1565 
1566     // FIXME: This should depend on locale.
<span class="line-modified">1567     static NeverDestroyed&lt;AtomString&gt; hyphenMinusString(&amp;hyphenMinus, 1);</span>
<span class="line-modified">1568     static NeverDestroyed&lt;AtomString&gt; hyphenString(&amp;hyphen, 1);</span>
1569     return fontCascade().primaryFont().glyphForCharacter(hyphen) ? hyphenString : hyphenMinusString;
1570 }
1571 
<span class="line-modified">1572 const AtomString&amp; RenderStyle::textEmphasisMarkString() const</span>
1573 {
1574     switch (textEmphasisMark()) {
1575     case TextEmphasisMark::None:
1576         return nullAtom();
1577     case TextEmphasisMark::Custom:
1578         return textEmphasisCustomMark();
1579     case TextEmphasisMark::Dot: {
<span class="line-modified">1580         static NeverDestroyed&lt;AtomString&gt; filledDotString(&amp;bullet, 1);</span>
<span class="line-modified">1581         static NeverDestroyed&lt;AtomString&gt; openDotString(&amp;whiteBullet, 1);</span>
1582         return textEmphasisFill() == TextEmphasisFill::Filled ? filledDotString : openDotString;
1583     }
1584     case TextEmphasisMark::Circle: {
<span class="line-modified">1585         static NeverDestroyed&lt;AtomString&gt; filledCircleString(&amp;blackCircle, 1);</span>
<span class="line-modified">1586         static NeverDestroyed&lt;AtomString&gt; openCircleString(&amp;whiteCircle, 1);</span>
1587         return textEmphasisFill() == TextEmphasisFill::Filled ? filledCircleString : openCircleString;
1588     }
1589     case TextEmphasisMark::DoubleCircle: {
<span class="line-modified">1590         static NeverDestroyed&lt;AtomString&gt; filledDoubleCircleString(&amp;fisheye, 1);</span>
<span class="line-modified">1591         static NeverDestroyed&lt;AtomString&gt; openDoubleCircleString(&amp;bullseye, 1);</span>
1592         return textEmphasisFill() == TextEmphasisFill::Filled ? filledDoubleCircleString : openDoubleCircleString;
1593     }
1594     case TextEmphasisMark::Triangle: {
<span class="line-modified">1595         static NeverDestroyed&lt;AtomString&gt; filledTriangleString(&amp;blackUpPointingTriangle, 1);</span>
<span class="line-modified">1596         static NeverDestroyed&lt;AtomString&gt; openTriangleString(&amp;whiteUpPointingTriangle, 1);</span>
1597         return textEmphasisFill() == TextEmphasisFill::Filled ? filledTriangleString : openTriangleString;
1598     }
1599     case TextEmphasisMark::Sesame: {
<span class="line-modified">1600         static NeverDestroyed&lt;AtomString&gt; filledSesameString(&amp;sesameDot, 1);</span>
<span class="line-modified">1601         static NeverDestroyed&lt;AtomString&gt; openSesameString(&amp;whiteSesameDot, 1);</span>
1602         return textEmphasisFill() == TextEmphasisFill::Filled ? filledSesameString : openSesameString;
1603     }
1604     case TextEmphasisMark::Auto:
1605         ASSERT_NOT_REACHED();
1606         return nullAtom();
1607     }
1608 
1609     ASSERT_NOT_REACHED();
1610     return nullAtom();
1611 }
1612 





















1613 void RenderStyle::adjustAnimations()
1614 {
1615     auto* animationList = m_rareNonInheritedData-&gt;animations.get();
1616     if (!animationList)
1617         return;
1618 
1619     // Get rid of empty animations and anything beyond them
1620     for (size_t i = 0, size = animationList-&gt;size(); i &lt; size; ++i) {
1621         if (animationList-&gt;animation(i).isEmpty()) {
1622             animationList-&gt;resize(i);
1623             break;
1624         }
1625     }
1626 
1627     if (animationList-&gt;isEmpty()) {
1628         clearAnimations();
1629         return;
1630     }
1631 
1632     // Repeat patterns into layers that don&#39;t have some properties set.
</pre>
<hr />
<pre>
1654 
1655     // Repeat patterns into layers that don&#39;t have some properties set.
1656     transitionList-&gt;fillUnsetProperties();
1657 
1658     // Make sure there are no duplicate properties.
1659     // This is an O(n^2) algorithm but the lists tend to be short, so it is probably OK.
1660     for (size_t i = 0; i &lt; transitionList-&gt;size(); ++i) {
1661         for (size_t j = i + 1; j &lt; transitionList-&gt;size(); ++j) {
1662             if (transitionList-&gt;animation(i).property() == transitionList-&gt;animation(j).property()) {
1663                 // toss i
1664                 transitionList-&gt;remove(i);
1665                 j = i;
1666             }
1667         }
1668     }
1669 }
1670 
1671 AnimationList&amp; RenderStyle::ensureAnimations()
1672 {
1673     if (!m_rareNonInheritedData.access().animations)
<span class="line-modified">1674         m_rareNonInheritedData.access().animations = makeUnique&lt;AnimationList&gt;();</span>
1675     return *m_rareNonInheritedData-&gt;animations;
1676 }
1677 
1678 AnimationList&amp; RenderStyle::ensureTransitions()
1679 {
1680     if (!m_rareNonInheritedData.access().transitions)
<span class="line-modified">1681         m_rareNonInheritedData.access().transitions = makeUnique&lt;AnimationList&gt;();</span>
1682     return *m_rareNonInheritedData-&gt;transitions;
1683 }
1684 
1685 const Animation* RenderStyle::transitionForProperty(CSSPropertyID property) const
1686 {
1687     auto* transitions = this-&gt;transitions();
1688     if (!transitions)
1689         return nullptr;
1690     for (size_t i = 0, size = transitions-&gt;size(); i &lt; size; ++i) {
1691         auto&amp; animation = transitions-&gt;animation(i);
1692         if (animation.animationMode() == Animation::AnimateAll || animation.property() == property)
1693             return &amp;animation;
1694     }
1695     return nullptr;
1696 }
1697 
1698 const FontCascade&amp; RenderStyle::fontCascade() const
1699 {
1700     return m_inheritedData-&gt;fontCascade;
1701 }
</pre>
<hr />
<pre>
2174 {
2175     auto mark = static_cast&lt;TextEmphasisMark&gt;(m_rareInheritedData-&gt;textEmphasisMark);
2176     if (mark != TextEmphasisMark::Auto)
2177         return mark;
2178     if (isHorizontalWritingMode())
2179         return TextEmphasisMark::Dot;
2180     return TextEmphasisMark::Sesame;
2181 }
2182 
2183 #if ENABLE(TOUCH_EVENTS)
2184 
2185 Color RenderStyle::initialTapHighlightColor()
2186 {
2187     return RenderTheme::tapHighlightColor();
2188 }
2189 
2190 #endif
2191 
2192 LayoutBoxExtent RenderStyle::imageOutsets(const NinePieceImage&amp; image) const
2193 {
<span class="line-modified">2194     return {</span>
<span class="line-modified">2195         NinePieceImage::computeOutset(image.outset().top(), LayoutUnit(borderTopWidth())),</span>
<span class="line-modified">2196         NinePieceImage::computeOutset(image.outset().right(), LayoutUnit(borderRightWidth())),</span>
<span class="line-modified">2197         NinePieceImage::computeOutset(image.outset().bottom(), LayoutUnit(borderBottomWidth())),</span>
<span class="line-added">2198         NinePieceImage::computeOutset(image.outset().left(), LayoutUnit(borderLeftWidth()))</span>
<span class="line-added">2199     };</span>
2200 }
2201 
2202 std::pair&lt;FontOrientation, NonCJKGlyphOrientation&gt; RenderStyle::fontAndGlyphOrientation()
2203 {
2204     // FIXME: TextOrientationSideways should map to sideways-left in vertical-lr, which is not supported yet.
2205 
2206     if (isHorizontalWritingMode())
2207         return { FontOrientation::Horizontal, NonCJKGlyphOrientation::Mixed };
2208 
2209     switch (textOrientation()) {
2210     case TextOrientation::Mixed:
2211         return { FontOrientation::Vertical, NonCJKGlyphOrientation::Mixed };
2212     case TextOrientation::Upright:
2213         return { FontOrientation::Vertical, NonCJKGlyphOrientation::Upright };
2214     case TextOrientation::Sideways:
2215         return { FontOrientation::Horizontal, NonCJKGlyphOrientation::Mixed };
2216     default:
2217         ASSERT_NOT_REACHED();
2218         return { FontOrientation::Horizontal, NonCJKGlyphOrientation::Mixed };
2219     }
</pre>
<hr />
<pre>
2437         return 0;
2438     if (outlineStyleIsAuto() == OutlineIsAuto::On)
2439         return std::max(m_backgroundData-&gt;outline.width(), RenderTheme::platformFocusRingWidth());
2440     return m_backgroundData-&gt;outline.width();
2441 }
2442 
2443 float RenderStyle::outlineOffset() const
2444 {
2445     if (m_backgroundData-&gt;outline.style() == BorderStyle::None)
2446         return 0;
2447     if (outlineStyleIsAuto() == OutlineIsAuto::On)
2448         return (m_backgroundData-&gt;outline.offset() + RenderTheme::platformFocusRingOffset(outlineWidth()));
2449     return m_backgroundData-&gt;outline.offset();
2450 }
2451 
2452 bool RenderStyle::shouldPlaceBlockDirectionScrollbarOnLeft() const
2453 {
2454     return !isLeftToRightDirection() &amp;&amp; isHorizontalWritingMode();
2455 }
2456 











2457 Vector&lt;PaintType, 3&gt; RenderStyle::paintTypesForPaintOrder(PaintOrder order)
2458 {
2459     Vector&lt;PaintType, 3&gt; paintOrder;
2460     switch (order) {
2461     case PaintOrder::Normal:
2462         FALLTHROUGH;
2463     case PaintOrder::Fill:
2464         paintOrder.append(PaintType::Fill);
2465         paintOrder.append(PaintType::Stroke);
2466         paintOrder.append(PaintType::Markers);
2467         break;
2468     case PaintOrder::FillMarkers:
2469         paintOrder.append(PaintType::Fill);
2470         paintOrder.append(PaintType::Markers);
2471         paintOrder.append(PaintType::Stroke);
2472         break;
2473     case PaintOrder::Stroke:
2474         paintOrder.append(PaintType::Stroke);
2475         paintOrder.append(PaintType::Fill);
2476         paintOrder.append(PaintType::Markers);
</pre>
</td>
</tr>
</table>
<center><a href="NinePieceImage.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="RenderStyle.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>