<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/Modules/indexeddb/server/SQLiteIDBBackingStore.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (C) 2016-2017 Apple Inc. All rights reserved.
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  * 1. Redistributions of source code must retain the above copyright
   8  *    notice, this list of conditions and the following disclaimer.
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
  14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
  15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
  17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
  23  * THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #include &quot;config.h&quot;
  27 #include &quot;SQLiteIDBBackingStore.h&quot;
  28 
  29 #if ENABLE(INDEXED_DATABASE)
  30 
  31 #include &quot;IDBBindingUtilities.h&quot;
  32 #include &quot;IDBCursorInfo.h&quot;
  33 #include &quot;IDBGetAllRecordsData.h&quot;
  34 #include &quot;IDBGetAllResult.h&quot;
  35 #include &quot;IDBGetRecordData.h&quot;
  36 #include &quot;IDBGetResult.h&quot;
  37 #include &quot;IDBIterateCursorData.h&quot;
  38 #include &quot;IDBKeyData.h&quot;
  39 #include &quot;IDBObjectStoreInfo.h&quot;
  40 #include &quot;IDBSerialization.h&quot;
  41 #include &quot;IDBSerializationContext.h&quot;
  42 #include &quot;IDBTransactionInfo.h&quot;
  43 #include &quot;IDBValue.h&quot;
  44 #include &quot;IndexKey.h&quot;
  45 #include &quot;Logging.h&quot;
  46 #include &quot;SQLiteDatabase.h&quot;
  47 #include &quot;SQLiteFileSystem.h&quot;
  48 #include &quot;SQLiteIDBCursor.h&quot;
  49 #include &quot;SQLiteStatement.h&quot;
  50 #include &quot;SQLiteTransaction.h&quot;
  51 #include &quot;ThreadSafeDataBuffer.h&quot;
  52 #include &lt;JavaScriptCore/AuxiliaryBarrierInlines.h&gt;
  53 #include &lt;JavaScriptCore/JSCInlines.h&gt;
  54 #include &lt;JavaScriptCore/StrongInlines.h&gt;
  55 #include &lt;wtf/FileSystem.h&gt;
  56 #include &lt;wtf/NeverDestroyed.h&gt;
  57 #include &lt;wtf/text/StringConcatenateNumbers.h&gt;
  58 
  59 namespace WebCore {
  60 using namespace JSC;
  61 namespace IDBServer {
  62 
  63 // Current version of the metadata schema being used in the metadata database.
  64 static const int currentMetadataVersion = 1;
  65 
  66 // The IndexedDatabase spec defines the max key generator value as 2^53.
  67 static const uint64_t maxGeneratorValue = 0x20000000000000;
  68 
  69 static int idbKeyCollate(int aLength, const void* aBuffer, int bLength, const void* bBuffer)
  70 {
  71     IDBKeyData a, b;
  72     if (!deserializeIDBKeyData(static_cast&lt;const uint8_t*&gt;(aBuffer), aLength, a)) {
  73         LOG_ERROR(&quot;Unable to deserialize key A in collation function.&quot;);
  74 
  75         // There&#39;s no way to indicate an error to SQLite - we have to return a sorting decision.
  76         // We arbitrarily choose &quot;A &gt; B&quot;
  77         return 1;
  78     }
  79     if (!deserializeIDBKeyData(static_cast&lt;const uint8_t*&gt;(bBuffer), bLength, b)) {
  80         LOG_ERROR(&quot;Unable to deserialize key B in collation function.&quot;);
  81 
  82         // There&#39;s no way to indicate an error to SQLite - we have to return a sorting decision.
  83         // We arbitrarily choose &quot;A &gt; B&quot;
  84         return 1;
  85     }
  86 
  87     return a.compare(b);
  88 }
  89 
  90 static const String v1RecordsTableSchema(const String&amp; tableName)
  91 {
  92     return makeString(&quot;CREATE TABLE &quot;, tableName, &quot; (objectStoreID INTEGER NOT NULL ON CONFLICT FAIL, key TEXT COLLATE IDBKEY NOT NULL ON CONFLICT FAIL UNIQUE ON CONFLICT REPLACE, value NOT NULL ON CONFLICT FAIL)&quot;);
  93 }
  94 
  95 static const String&amp; v1RecordsTableSchema()
  96 {
  97     static NeverDestroyed&lt;WTF::String&gt; v1RecordsTableSchemaString(v1RecordsTableSchema(&quot;Records&quot;));
  98     return v1RecordsTableSchemaString;
  99 }
 100 
 101 static const String&amp; v1RecordsTableSchemaAlternate()
 102 {
 103     static NeverDestroyed&lt;WTF::String&gt; v1RecordsTableSchemaString(v1RecordsTableSchema(&quot;\&quot;Records\&quot;&quot;));
 104     return v1RecordsTableSchemaString;
 105 }
 106 
 107 static const String v2RecordsTableSchema(const String&amp; tableName)
 108 {
 109     return makeString(&quot;CREATE TABLE &quot;, tableName, &quot; (objectStoreID INTEGER NOT NULL ON CONFLICT FAIL, key TEXT COLLATE IDBKEY NOT NULL ON CONFLICT FAIL, value NOT NULL ON CONFLICT FAIL)&quot;);
 110 }
 111 
 112 static const String&amp; v2RecordsTableSchema()
 113 {
 114     static NeverDestroyed&lt;WTF::String&gt; v2RecordsTableSchemaString(v2RecordsTableSchema(&quot;Records&quot;));
 115     return v2RecordsTableSchemaString;
 116 }
 117 
 118 static const String&amp; v2RecordsTableSchemaAlternate()
 119 {
 120     static NeverDestroyed&lt;WTF::String&gt; v2RecordsTableSchemaString(v2RecordsTableSchema(&quot;\&quot;Records\&quot;&quot;));
 121     return v2RecordsTableSchemaString;
 122 }
 123 
 124 static const String v3RecordsTableSchema(const String&amp; tableName)
 125 {
 126     return makeString(&quot;CREATE TABLE &quot;, tableName, &quot; (objectStoreID INTEGER NOT NULL ON CONFLICT FAIL, key TEXT COLLATE IDBKEY NOT NULL ON CONFLICT FAIL, value NOT NULL ON CONFLICT FAIL, recordID INTEGER PRIMARY KEY)&quot;);
 127 }
 128 
 129 static const String&amp; v3RecordsTableSchema()
 130 {
 131     static NeverDestroyed&lt;WTF::String&gt; v3RecordsTableSchemaString(v3RecordsTableSchema(&quot;Records&quot;));
 132     return v3RecordsTableSchemaString;
 133 }
 134 
 135 static const String&amp; v3RecordsTableSchemaAlternate()
 136 {
 137     static NeverDestroyed&lt;WTF::String&gt; v3RecordsTableSchemaString(v3RecordsTableSchema(&quot;\&quot;Records\&quot;&quot;));
 138     return v3RecordsTableSchemaString;
 139 }
 140 
 141 static const String v1IndexRecordsTableSchema(const String&amp; tableName)
 142 {
 143     return makeString(&quot;CREATE TABLE &quot;, tableName, &quot; (indexID INTEGER NOT NULL ON CONFLICT FAIL, objectStoreID INTEGER NOT NULL ON CONFLICT FAIL, key TEXT COLLATE IDBKEY NOT NULL ON CONFLICT FAIL, value NOT NULL ON CONFLICT FAIL)&quot;);
 144 }
 145 
 146 static const String&amp; v1IndexRecordsTableSchema()
 147 {
 148     static NeverDestroyed&lt;WTF::String&gt; v1IndexRecordsTableSchemaString(v1IndexRecordsTableSchema(&quot;IndexRecords&quot;));
 149     return v1IndexRecordsTableSchemaString;
 150 }
 151 
 152 static const String&amp; v1IndexRecordsTableSchemaAlternate()
 153 {
 154     static NeverDestroyed&lt;WTF::String&gt; v1IndexRecordsTableSchemaString(v1IndexRecordsTableSchema(&quot;\&quot;IndexRecords\&quot;&quot;));
 155     return v1IndexRecordsTableSchemaString;
 156 }
 157 
 158 static const String v2IndexRecordsTableSchema(const String&amp; tableName)
 159 {
 160     return makeString(&quot;CREATE TABLE &quot;, tableName, &quot; (indexID INTEGER NOT NULL ON CONFLICT FAIL, objectStoreID INTEGER NOT NULL ON CONFLICT FAIL, key TEXT COLLATE IDBKEY NOT NULL ON CONFLICT FAIL, value TEXT COLLATE IDBKEY NOT NULL ON CONFLICT FAIL)&quot;);
 161 }
 162 
 163 static const String&amp; v2IndexRecordsTableSchema()
 164 {
 165     static NeverDestroyed&lt;WTF::String&gt; v2IndexRecordsTableSchemaString(v2IndexRecordsTableSchema(&quot;IndexRecords&quot;));
 166     return v2IndexRecordsTableSchemaString;
 167 }
 168 
 169 static const String&amp; v2IndexRecordsTableSchemaAlternate()
 170 {
 171     static NeverDestroyed&lt;WTF::String&gt; v2IndexRecordsTableSchemaString(v2IndexRecordsTableSchema(&quot;\&quot;IndexRecords\&quot;&quot;));
 172     return v2IndexRecordsTableSchemaString;
 173 }
 174 
 175 static const String v3IndexRecordsTableSchema(const String&amp; tableName)
 176 {
 177     return makeString(&quot;CREATE TABLE &quot;, tableName, &quot; (indexID INTEGER NOT NULL ON CONFLICT FAIL, objectStoreID INTEGER NOT NULL ON CONFLICT FAIL, key TEXT COLLATE IDBKEY NOT NULL ON CONFLICT FAIL, value TEXT COLLATE IDBKEY NOT NULL ON CONFLICT FAIL, objectStoreRecordID INTEGER NOT NULL ON CONFLICT FAIL)&quot;);
 178 }
 179 
 180 static const String v3IndexRecordsTableSchema()
 181 {
 182     static NeverDestroyed&lt;WTF::String&gt; indexRecordsTableSchemaString = v3IndexRecordsTableSchema(&quot;IndexRecords&quot;);
 183     return indexRecordsTableSchemaString;
 184 }
 185 
 186 static const String v3IndexRecordsTableSchemaAlternate()
 187 {
 188     static NeverDestroyed&lt;WTF::String&gt; indexRecordsTableSchemaString = v3IndexRecordsTableSchema(&quot;\&quot;IndexRecords\&quot;&quot;);
 189     return indexRecordsTableSchemaString;
 190 }
 191 
 192 static const String&amp; v1IndexRecordsIndexSchema()
 193 {
 194     static NeverDestroyed&lt;WTF::String&gt; indexRecordsIndexSchemaString(&quot;CREATE INDEX IndexRecordsIndex ON IndexRecords (key)&quot;);
 195     return indexRecordsIndexSchemaString;
 196 }
 197 
 198 static const String blobRecordsTableSchema(const String&amp; tableName)
 199 {
 200     return makeString(&quot;CREATE TABLE &quot;, tableName, &quot; (objectStoreRow INTEGER NOT NULL ON CONFLICT FAIL, blobURL TEXT NOT NULL ON CONFLICT FAIL)&quot;);
 201 }
 202 
 203 static const String&amp; blobRecordsTableSchema()
 204 {
 205     static NeverDestroyed&lt;String&gt; blobRecordsTableSchemaString(blobRecordsTableSchema(&quot;BlobRecords&quot;));
 206     return blobRecordsTableSchemaString;
 207 }
 208 
 209 static const String&amp; blobRecordsTableSchemaAlternate()
 210 {
 211     static NeverDestroyed&lt;String&gt; blobRecordsTableSchemaString(blobRecordsTableSchema(&quot;\&quot;BlobRecords\&quot;&quot;));
 212     return blobRecordsTableSchemaString;
 213 }
 214 
 215 static const String blobFilesTableSchema(const String&amp; tableName)
 216 {
 217     return makeString(&quot;CREATE TABLE &quot;, tableName, &quot; (blobURL TEXT NOT NULL ON CONFLICT FAIL UNIQUE ON CONFLICT FAIL, fileName TEXT NOT NULL ON CONFLICT FAIL UNIQUE ON CONFLICT FAIL)&quot;);
 218 }
 219 
 220 static const String&amp; blobFilesTableSchema()
 221 {
 222     static NeverDestroyed&lt;String&gt; blobFilesTableSchemaString(blobFilesTableSchema(&quot;BlobFiles&quot;));
 223     return blobFilesTableSchemaString;
 224 }
 225 
 226 static const String&amp; blobFilesTableSchemaAlternate()
 227 {
 228     static NeverDestroyed&lt;String&gt; blobFilesTableSchemaString(blobFilesTableSchema(&quot;\&quot;BlobFiles\&quot;&quot;));
 229     return blobFilesTableSchemaString;
 230 }
 231 
 232 SQLiteIDBBackingStore::SQLiteIDBBackingStore(PAL::SessionID sessionID, const IDBDatabaseIdentifier&amp; identifier, const String&amp; databaseRootDirectory, IDBBackingStoreTemporaryFileHandler&amp; fileHandler)
 233     : m_sessionID(sessionID)
 234     , m_identifier(identifier)
 235     , m_databaseRootDirectory(databaseRootDirectory)
 236     , m_temporaryFileHandler(fileHandler)
 237     , m_serializationContext(IDBSerializationContext::getOrCreateIDBSerializationContext(sessionID))
 238 {
 239     m_databaseDirectory = fullDatabaseDirectoryWithUpgrade();
 240 }
 241 
 242 SQLiteIDBBackingStore::~SQLiteIDBBackingStore()
 243 {
 244     if (m_sqliteDB)
 245         closeSQLiteDB();
 246 }
 247 
 248 static bool createOrMigrateRecordsTableIfNecessary(SQLiteDatabase&amp; database)
 249 {
 250     String currentSchema;
 251     {
 252         // Fetch the schema for an existing records table.
 253         SQLiteStatement statement(database, &quot;SELECT type, sql FROM sqlite_master WHERE tbl_name=&#39;Records&#39;&quot;);
 254         if (statement.prepare() != SQLITE_OK) {
 255             LOG_ERROR(&quot;Unable to prepare statement to fetch schema for the Records table.&quot;);
 256             return false;
 257         }
 258 
 259         int sqliteResult = statement.step();
 260 
 261         // If there is no Records table at all, create it and then bail.
 262         if (sqliteResult == SQLITE_DONE) {
 263             if (!database.executeCommand(v3RecordsTableSchema())) {
 264                 LOG_ERROR(&quot;Could not create Records table in database (%i) - %s&quot;, database.lastError(), database.lastErrorMsg());
 265                 return false;
 266             }
 267 
 268             return true;
 269         }
 270 
 271         if (sqliteResult != SQLITE_ROW) {
 272             LOG_ERROR(&quot;Error executing statement to fetch schema for the Records table.&quot;);
 273             return false;
 274         }
 275 
 276         currentSchema = statement.getColumnText(1);
 277     }
 278 
 279     ASSERT(!currentSchema.isEmpty());
 280 
 281     // If the schema in the backing store is the current schema, we&#39;re done.
 282     if (currentSchema == v3RecordsTableSchema() || currentSchema == v3RecordsTableSchemaAlternate())
 283         return true;
 284 
 285     // If the record table is not the current schema then it must be one of the previous schemas.
 286     // If it is not then the database is in an unrecoverable state and this should be considered a fatal error.
 287     if (currentSchema != v1RecordsTableSchema() &amp;&amp; currentSchema != v1RecordsTableSchemaAlternate()
 288         &amp;&amp; currentSchema != v2RecordsTableSchema() &amp;&amp; currentSchema != v2RecordsTableSchemaAlternate())
 289         RELEASE_ASSERT_NOT_REACHED();
 290 
 291     SQLiteTransaction transaction(database);
 292     transaction.begin();
 293 
 294     // Create a temporary table with the correct schema and migrate all existing content over.
 295     if (!database.executeCommand(v3RecordsTableSchema(&quot;_Temp_Records&quot;))) {
 296         LOG_ERROR(&quot;Could not create temporary records table in database (%i) - %s&quot;, database.lastError(), database.lastErrorMsg());
 297         return false;
 298     }
 299 
 300     if (!database.executeCommand(&quot;INSERT INTO _Temp_Records (objectStoreID, key, value) SELECT objectStoreID, CAST(key AS TEXT), value FROM Records&quot;)) {
 301         LOG_ERROR(&quot;Could not migrate existing Records content (%i) - %s&quot;, database.lastError(), database.lastErrorMsg());
 302         return false;
 303     }
 304 
 305     if (!database.executeCommand(&quot;DROP TABLE Records&quot;)) {
 306         LOG_ERROR(&quot;Could not drop existing Records table (%i) - %s&quot;, database.lastError(), database.lastErrorMsg());
 307         return false;
 308     }
 309 
 310     if (!database.executeCommand(&quot;ALTER TABLE _Temp_Records RENAME TO Records&quot;)) {
 311         LOG_ERROR(&quot;Could not rename temporary Records table (%i) - %s&quot;, database.lastError(), database.lastErrorMsg());
 312         return false;
 313     }
 314 
 315     transaction.commit();
 316 
 317     return true;
 318 }
 319 
 320 bool SQLiteIDBBackingStore::ensureValidBlobTables()
 321 {
 322     ASSERT(m_sqliteDB);
 323     ASSERT(m_sqliteDB-&gt;isOpen());
 324 
 325     String currentSchema;
 326     {
 327         // Fetch the schema for an existing blob record table.
 328         SQLiteStatement statement(*m_sqliteDB, &quot;SELECT type, sql FROM sqlite_master WHERE tbl_name=&#39;BlobRecords&#39;&quot;);
 329         if (statement.prepare() != SQLITE_OK) {
 330             LOG_ERROR(&quot;Unable to prepare statement to fetch schema for the BlobRecords table.&quot;);
 331             return false;
 332         }
 333 
 334         int sqliteResult = statement.step();
 335 
 336         // If there is no BlobRecords table at all, create it..
 337         if (sqliteResult == SQLITE_DONE) {
 338             if (!m_sqliteDB-&gt;executeCommand(blobRecordsTableSchema())) {
 339                 LOG_ERROR(&quot;Could not create BlobRecords table in database (%i) - %s&quot;, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
 340                 return false;
 341             }
 342 
 343             currentSchema = blobRecordsTableSchema();
 344         } else if (sqliteResult != SQLITE_ROW) {
 345             LOG_ERROR(&quot;Error executing statement to fetch schema for the BlobRecords table.&quot;);
 346             return false;
 347         } else
 348             currentSchema = statement.getColumnText(1);
 349     }
 350 
 351     if (currentSchema != blobRecordsTableSchema() &amp;&amp; currentSchema != blobRecordsTableSchemaAlternate()) {
 352         LOG_ERROR(&quot;Invalid BlobRecords table schema found&quot;);
 353         return false;
 354     }
 355 
 356     {
 357         // Fetch the schema for an existing blob file table.
 358         SQLiteStatement statement(*m_sqliteDB, &quot;SELECT type, sql FROM sqlite_master WHERE tbl_name=&#39;BlobFiles&#39;&quot;);
 359         if (statement.prepare() != SQLITE_OK) {
 360             LOG_ERROR(&quot;Unable to prepare statement to fetch schema for the BlobFiles table.&quot;);
 361             return false;
 362         }
 363 
 364         int sqliteResult = statement.step();
 365 
 366         // If there is no BlobFiles table at all, create it and then bail.
 367         if (sqliteResult == SQLITE_DONE) {
 368             if (!m_sqliteDB-&gt;executeCommand(blobFilesTableSchema())) {
 369                 LOG_ERROR(&quot;Could not create BlobFiles table in database (%i) - %s&quot;, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
 370                 return false;
 371             }
 372 
 373             return true;
 374         }
 375 
 376         if (sqliteResult != SQLITE_ROW) {
 377             LOG_ERROR(&quot;Error executing statement to fetch schema for the BlobFiles table.&quot;);
 378             return false;
 379         }
 380 
 381         currentSchema = statement.getColumnText(1);
 382     }
 383 
 384     if (currentSchema != blobFilesTableSchema() &amp;&amp; currentSchema != blobFilesTableSchemaAlternate()) {
 385         LOG_ERROR(&quot;Invalid BlobFiles table schema found&quot;);
 386         return false;
 387     }
 388 
 389     return true;
 390 }
 391 
 392 bool SQLiteIDBBackingStore::ensureValidRecordsTable()
 393 {
 394     ASSERT(m_sqliteDB);
 395     ASSERT(m_sqliteDB-&gt;isOpen());
 396 
 397     if (!createOrMigrateRecordsTableIfNecessary(*m_sqliteDB))
 398         return false;
 399 
 400     // Whether the updated records table already existed or if it was just created and the data migrated over,
 401     // make sure the uniqueness index exists.
 402     if (!m_sqliteDB-&gt;executeCommand(&quot;CREATE UNIQUE INDEX IF NOT EXISTS RecordsIndex ON Records (objectStoreID, key);&quot;)) {
 403         LOG_ERROR(&quot;Could not create RecordsIndex on Records table in database (%i) - %s&quot;, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
 404         return false;
 405     }
 406 
 407     return true;
 408 }
 409 
 410 bool SQLiteIDBBackingStore::ensureValidIndexRecordsTable()
 411 {
 412     ASSERT(m_sqliteDB);
 413     ASSERT(m_sqliteDB-&gt;isOpen());
 414 
 415     String currentSchema;
 416     {
 417         // Fetch the schema for an existing index record table.
 418         SQLiteStatement statement(*m_sqliteDB, &quot;SELECT type, sql FROM sqlite_master WHERE tbl_name=&#39;IndexRecords&#39;&quot;);
 419         if (statement.prepare() != SQLITE_OK) {
 420             LOG_ERROR(&quot;Unable to prepare statement to fetch schema for the IndexRecords table.&quot;);
 421             return false;
 422         }
 423 
 424         int sqliteResult = statement.step();
 425 
 426         // If there is no IndexRecords table at all, create it and then bail.
 427         if (sqliteResult == SQLITE_DONE) {
 428             if (!m_sqliteDB-&gt;executeCommand(v3IndexRecordsTableSchema())) {
 429                 LOG_ERROR(&quot;Could not create IndexRecords table in database (%i) - %s&quot;, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
 430                 return false;
 431             }
 432 
 433             return true;
 434         }
 435 
 436         if (sqliteResult != SQLITE_ROW) {
 437             LOG_ERROR(&quot;Error executing statement to fetch schema for the IndexRecords table.&quot;);
 438             return false;
 439         }
 440 
 441         currentSchema = statement.getColumnText(1);
 442     }
 443 
 444     ASSERT(!currentSchema.isEmpty());
 445 
 446     // If the schema in the backing store is the current schema, we&#39;re done.
 447     if (currentSchema == v3IndexRecordsTableSchema() || currentSchema == v3IndexRecordsTableSchemaAlternate())
 448         return true;
 449 
 450     // If the record table is not the current schema then it must be one of the previous schemas.
 451     // If it is not then the database is in an unrecoverable state and this should be considered a fatal error.
 452     if (currentSchema != v1IndexRecordsTableSchema() &amp;&amp; currentSchema != v1IndexRecordsTableSchemaAlternate()
 453         &amp;&amp; currentSchema != v2IndexRecordsTableSchema() &amp;&amp; currentSchema != v2IndexRecordsTableSchemaAlternate())
 454         RELEASE_ASSERT_NOT_REACHED();
 455 
 456     SQLiteTransaction transaction(*m_sqliteDB);
 457     transaction.begin();
 458 
 459     // Create a temporary table with the correct schema and migrate all existing content over.
 460     if (!m_sqliteDB-&gt;executeCommand(v3IndexRecordsTableSchema(&quot;_Temp_IndexRecords&quot;))) {
 461         LOG_ERROR(&quot;Could not create temporary index records table in database (%i) - %s&quot;, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
 462         return false;
 463     }
 464 
 465     if (!m_sqliteDB-&gt;executeCommand(&quot;INSERT INTO _Temp_IndexRecords SELECT IndexRecords.indexID, IndexRecords.objectStoreID, IndexRecords.key, IndexRecords.value, Records.rowid FROM IndexRecords INNER JOIN Records ON Records.key = IndexRecords.value AND Records.objectStoreID = IndexRecords.objectStoreID&quot;)) {
 466         LOG_ERROR(&quot;Could not migrate existing IndexRecords content (%i) - %s&quot;, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
 467         return false;
 468     }
 469 
 470     if (!m_sqliteDB-&gt;executeCommand(&quot;DROP TABLE IndexRecords&quot;)) {
 471         LOG_ERROR(&quot;Could not drop existing IndexRecords table (%i) - %s&quot;, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
 472         return false;
 473     }
 474 
 475     if (!m_sqliteDB-&gt;executeCommand(&quot;ALTER TABLE _Temp_IndexRecords RENAME TO IndexRecords&quot;)) {
 476         LOG_ERROR(&quot;Could not rename temporary IndexRecords table (%i) - %s&quot;, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
 477         return false;
 478     }
 479 
 480     transaction.commit();
 481 
 482     return true;
 483 }
 484 
 485 bool SQLiteIDBBackingStore::ensureValidIndexRecordsIndex()
 486 {
 487     ASSERT(m_sqliteDB);
 488     ASSERT(m_sqliteDB-&gt;isOpen());
 489 
 490     String currentSchema;
 491     {
 492         // Fetch the schema for an existing index record index.
 493         SQLiteStatement statement(*m_sqliteDB, &quot;SELECT sql FROM sqlite_master WHERE name=&#39;IndexRecordsIndex&#39;&quot;);
 494         if (statement.prepare() != SQLITE_OK) {
 495             LOG_ERROR(&quot;Unable to prepare statement to fetch schema for the IndexRecordsIndex index.&quot;);
 496             return false;
 497         }
 498 
 499         int sqliteResult = statement.step();
 500 
 501         // If there is no IndexRecordsIndex index at all, create it and then bail.
 502         if (sqliteResult == SQLITE_DONE) {
 503             if (!m_sqliteDB-&gt;executeCommand(v1IndexRecordsIndexSchema())) {
 504                 LOG_ERROR(&quot;Could not create IndexRecordsIndex index in database (%i) - %s&quot;, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
 505                 return false;
 506             }
 507 
 508             return true;
 509         }
 510 
 511         if (sqliteResult != SQLITE_ROW) {
 512             LOG_ERROR(&quot;Error executing statement to fetch schema for the IndexRecordsIndex index.&quot;);
 513             return false;
 514         }
 515 
 516         currentSchema = statement.getColumnText(0);
 517     }
 518 
 519     ASSERT(!currentSchema.isEmpty());
 520 
 521     // If the schema in the backing store is the current schema, we&#39;re done.
 522     if (currentSchema == v1IndexRecordsIndexSchema())
 523         return true;
 524 
 525     // There is currently no outdated schema for the IndexRecordsIndex, so any other existing schema means this database is invalid.
 526     return false;
 527 }
 528 
 529 std::unique_ptr&lt;IDBDatabaseInfo&gt; SQLiteIDBBackingStore::createAndPopulateInitialDatabaseInfo()
 530 {
 531     ASSERT(m_sqliteDB);
 532     ASSERT(m_sqliteDB-&gt;isOpen());
 533 
 534     if (!m_sqliteDB-&gt;executeCommand(&quot;CREATE TABLE IDBDatabaseInfo (key TEXT NOT NULL ON CONFLICT FAIL UNIQUE ON CONFLICT REPLACE, value TEXT NOT NULL ON CONFLICT FAIL);&quot;)) {
 535         LOG_ERROR(&quot;Could not create IDBDatabaseInfo table in database (%i) - %s&quot;, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
 536         closeSQLiteDB();
 537         return nullptr;
 538     }
 539 
 540     if (!m_sqliteDB-&gt;executeCommand(&quot;CREATE TABLE ObjectStoreInfo (id INTEGER PRIMARY KEY NOT NULL ON CONFLICT FAIL UNIQUE ON CONFLICT FAIL, name TEXT NOT NULL ON CONFLICT FAIL UNIQUE ON CONFLICT FAIL, keyPath BLOB NOT NULL ON CONFLICT FAIL, autoInc INTEGER NOT NULL ON CONFLICT FAIL, maxIndexID INTEGER NOT NULL ON CONFLICT FAIL);&quot;)) {
 541         LOG_ERROR(&quot;Could not create ObjectStoreInfo table in database (%i) - %s&quot;, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
 542         closeSQLiteDB();
 543         return nullptr;
 544     }
 545 
 546     if (!m_sqliteDB-&gt;executeCommand(&quot;CREATE TABLE IndexInfo (id INTEGER NOT NULL ON CONFLICT FAIL, name TEXT NOT NULL ON CONFLICT FAIL, objectStoreID INTEGER NOT NULL ON CONFLICT FAIL, keyPath BLOB NOT NULL ON CONFLICT FAIL, isUnique INTEGER NOT NULL ON CONFLICT FAIL, multiEntry INTEGER NOT NULL ON CONFLICT FAIL);&quot;)) {
 547         LOG_ERROR(&quot;Could not create IndexInfo table in database (%i) - %s&quot;, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
 548         closeSQLiteDB();
 549         return nullptr;
 550     }
 551 
 552     if (!m_sqliteDB-&gt;executeCommand(&quot;CREATE TABLE KeyGenerators (objectStoreID INTEGER NOT NULL ON CONFLICT FAIL UNIQUE ON CONFLICT REPLACE, currentKey INTEGER NOT NULL ON CONFLICT FAIL);&quot;)) {
 553         LOG_ERROR(&quot;Could not create KeyGenerators table in database (%i) - %s&quot;, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
 554         closeSQLiteDB();
 555         return nullptr;
 556     }
 557 
 558     {
 559         SQLiteStatement sql(*m_sqliteDB, &quot;INSERT INTO IDBDatabaseInfo VALUES (&#39;MetadataVersion&#39;, ?);&quot;_s);
 560         if (sql.prepare() != SQLITE_OK
 561             || sql.bindInt(1, currentMetadataVersion) != SQLITE_OK
 562             || sql.step() != SQLITE_DONE) {
 563             LOG_ERROR(&quot;Could not insert database metadata version into IDBDatabaseInfo table (%i) - %s&quot;, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
 564             closeSQLiteDB();
 565             return nullptr;
 566         }
 567     }
 568     {
 569         SQLiteStatement sql(*m_sqliteDB, &quot;INSERT INTO IDBDatabaseInfo VALUES (&#39;DatabaseName&#39;, ?);&quot;_s);
 570         if (sql.prepare() != SQLITE_OK
 571             || sql.bindText(1, m_identifier.databaseName()) != SQLITE_OK
 572             || sql.step() != SQLITE_DONE) {
 573             LOG_ERROR(&quot;Could not insert database name into IDBDatabaseInfo table (%i) - %s&quot;, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
 574             closeSQLiteDB();
 575             return nullptr;
 576         }
 577     }
 578     {
 579         // Database versions are defined to be a uin64_t in the spec but sqlite3 doesn&#39;t support native binding of unsigned integers.
 580         // Therefore we&#39;ll store the version as a String.
 581         SQLiteStatement sql(*m_sqliteDB, &quot;INSERT INTO IDBDatabaseInfo VALUES (&#39;DatabaseVersion&#39;, ?);&quot;_s);
 582         if (sql.prepare() != SQLITE_OK
 583             || sql.bindText(1, String::number(0)) != SQLITE_OK
 584             || sql.step() != SQLITE_DONE) {
 585             LOG_ERROR(&quot;Could not insert default version into IDBDatabaseInfo table (%i) - %s&quot;, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
 586             closeSQLiteDB();
 587             return nullptr;
 588         }
 589     }
 590 
 591     if (!m_sqliteDB-&gt;executeCommand(&quot;INSERT INTO IDBDatabaseInfo VALUES (&#39;MaxObjectStoreID&#39;, 1);&quot;_s)) {
 592         LOG_ERROR(&quot;Could not insert default version into IDBDatabaseInfo table (%i) - %s&quot;, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
 593         closeSQLiteDB();
 594         return nullptr;
 595     }
 596 
 597     // This initial database info matches the default values we just put into the metadata database.
 598     return makeUnique&lt;IDBDatabaseInfo&gt;(m_identifier.databaseName(), 0);
 599 }
 600 
 601 std::unique_ptr&lt;IDBDatabaseInfo&gt; SQLiteIDBBackingStore::extractExistingDatabaseInfo()
 602 {
 603     ASSERT(m_sqliteDB);
 604 
 605     if (!m_sqliteDB-&gt;tableExists(&quot;IDBDatabaseInfo&quot;_s))
 606         return nullptr;
 607 
 608     String databaseName;
 609     {
 610         SQLiteStatement sql(*m_sqliteDB, &quot;SELECT value FROM IDBDatabaseInfo WHERE key = &#39;DatabaseName&#39;;&quot;);
 611         if (sql.isColumnNull(0))
 612             return nullptr;
 613         databaseName = sql.getColumnText(0);
 614         if (databaseName != m_identifier.databaseName()) {
 615             LOG_ERROR(&quot;Database name in the info database (&#39;%s&#39;) does not match the expected name (&#39;%s&#39;)&quot;, databaseName.utf8().data(), m_identifier.databaseName().utf8().data());
 616             return nullptr;
 617         }
 618     }
 619     uint64_t databaseVersion;
 620     {
 621         SQLiteStatement sql(*m_sqliteDB, &quot;SELECT value FROM IDBDatabaseInfo WHERE key = &#39;DatabaseVersion&#39;;&quot;_s);
 622         if (sql.isColumnNull(0))
 623             return nullptr;
 624         String stringVersion = sql.getColumnText(0);
 625         bool ok;
 626         databaseVersion = stringVersion.toUInt64Strict(&amp;ok);
 627         if (!ok) {
 628             LOG_ERROR(&quot;Database version on disk (&#39;%s&#39;) does not cleanly convert to an unsigned 64-bit integer version&quot;, stringVersion.utf8().data());
 629             return nullptr;
 630         }
 631     }
 632 
 633     auto databaseInfo = makeUnique&lt;IDBDatabaseInfo&gt;(databaseName, databaseVersion);
 634 
 635     {
 636         SQLiteStatement sql(*m_sqliteDB, &quot;SELECT id, name, keyPath, autoInc, maxIndexID FROM ObjectStoreInfo;&quot;_s);
 637         if (sql.prepare() != SQLITE_OK)
 638             return nullptr;
 639 
 640         int result = sql.step();
 641         while (result == SQLITE_ROW) {
 642             uint64_t objectStoreID = sql.getColumnInt64(0);
 643             String objectStoreName = sql.getColumnText(1);
 644 
 645             Vector&lt;char&gt; keyPathBuffer;
 646             sql.getColumnBlobAsVector(2, keyPathBuffer);
 647 
 648             Optional&lt;IDBKeyPath&gt; objectStoreKeyPath;
 649             if (!deserializeIDBKeyPath(reinterpret_cast&lt;const uint8_t*&gt;(keyPathBuffer.data()), keyPathBuffer.size(), objectStoreKeyPath)) {
 650                 LOG_ERROR(&quot;Unable to extract key path from database&quot;);
 651                 return nullptr;
 652             }
 653 
 654             bool autoIncrement = sql.getColumnInt(3);
 655 
 656             databaseInfo-&gt;addExistingObjectStore({ objectStoreID, objectStoreName, WTFMove(objectStoreKeyPath), autoIncrement });
 657 
 658             result = sql.step();
 659         }
 660 
 661         if (result != SQLITE_DONE) {
 662             LOG_ERROR(&quot;Error fetching object store info from database on disk&quot;);
 663             return nullptr;
 664         }
 665     }
 666 
 667     {
 668         SQLiteStatement sql(*m_sqliteDB, &quot;SELECT id, name, objectStoreID, keyPath, isUnique, multiEntry FROM IndexInfo;&quot;_s);
 669         if (sql.prepare() != SQLITE_OK)
 670             return nullptr;
 671 
 672         int result = sql.step();
 673         while (result == SQLITE_ROW) {
 674             uint64_t indexID = sql.getColumnInt64(0);
 675             String indexName = sql.getColumnText(1);
 676             uint64_t objectStoreID = sql.getColumnInt64(2);
 677 
 678             Vector&lt;char&gt; keyPathBuffer;
 679             sql.getColumnBlobAsVector(3, keyPathBuffer);
 680 
 681             Optional&lt;IDBKeyPath&gt; indexKeyPath;
 682             if (!deserializeIDBKeyPath(reinterpret_cast&lt;const uint8_t*&gt;(keyPathBuffer.data()), keyPathBuffer.size(), indexKeyPath)) {
 683                 LOG_ERROR(&quot;Unable to extract key path from database&quot;);
 684                 return nullptr;
 685             }
 686             if (!indexKeyPath) {
 687                 LOG_ERROR(&quot;Unable to extract key path from database&quot;);
 688                 return nullptr;
 689             }
 690 
 691             bool unique = sql.getColumnInt(4);
 692             bool multiEntry = sql.getColumnInt(5);
 693 
 694             auto objectStore = databaseInfo-&gt;infoForExistingObjectStore(objectStoreID);
 695             if (!objectStore) {
 696                 LOG_ERROR(&quot;Found index referring to a non-existant object store&quot;);
 697                 return nullptr;
 698             }
 699 
 700             objectStore-&gt;addExistingIndex({ indexID, objectStoreID, indexName, WTFMove(indexKeyPath.value()), unique, multiEntry });
 701 
 702             result = sql.step();
 703         }
 704 
 705         if (result != SQLITE_DONE) {
 706             LOG_ERROR(&quot;Error fetching index info from database on disk&quot;);
 707             return nullptr;
 708         }
 709     }
 710 
 711     return databaseInfo;
 712 }
 713 
 714 String SQLiteIDBBackingStore::databaseNameFromEncodedFilename(const String&amp; encodedName)
 715 {
 716     if (encodedName == &quot;%00&quot;_s)
 717         return { };
 718 
 719     String partiallyDecoded = encodedName;
 720     partiallyDecoded.replace(&quot;%2E&quot;_s, &quot;.&quot;_s);
 721 
 722     return FileSystem::decodeFromFilename(partiallyDecoded);
 723 }
 724 
 725 String SQLiteIDBBackingStore::filenameForDatabaseName() const
 726 {
 727     ASSERT(!m_identifier.databaseName().isNull());
 728 
 729     if (m_identifier.databaseName().isEmpty())
 730         return &quot;%00&quot;;
 731 
 732     String filename = FileSystem::encodeForFileName(m_identifier.databaseName());
 733     filename.replace(&#39;.&#39;, &quot;%2E&quot;);
 734 
 735     return filename;
 736 }
 737 
 738 String SQLiteIDBBackingStore::fullDatabasePathForDirectory(const String&amp; fullDatabaseDirectory)
 739 {
 740     return FileSystem::pathByAppendingComponent(fullDatabaseDirectory, &quot;IndexedDB.sqlite3&quot;);
 741 }
 742 
 743 String SQLiteIDBBackingStore::fullDatabasePath() const
 744 {
 745     return fullDatabasePathForDirectory(m_databaseDirectory);
 746 }
 747 
 748 String SQLiteIDBBackingStore::databaseNameFromFile(const String&amp; databasePath)
 749 {
 750     SQLiteDatabase database;
 751     if (!database.open(databasePath)) {
 752         LOG_ERROR(&quot;Failed to open SQLite database at path &#39;%s&#39; when getting database name&quot;, databasePath.utf8().data());
 753         return { };
 754     }
 755     if (!database.tableExists(&quot;IDBDatabaseInfo&quot;_s)) {
 756         LOG_ERROR(&quot;Could not find IDBDatabaseInfo table and get database name(%i) - %s&quot;, database.lastError(), database.lastErrorMsg());
 757         database.close();
 758         return { };
 759     }
 760     SQLiteStatement sql(database, &quot;SELECT value FROM IDBDatabaseInfo WHERE key = &#39;DatabaseName&#39;;&quot;);
 761     auto databaseName = sql.getColumnText(0);
 762     database.close();
 763     return databaseName;
 764 }
 765 
 766 String SQLiteIDBBackingStore::fullDatabaseDirectoryWithUpgrade()
 767 {
 768     auto databaseRootDirectory = this-&gt;databaseRootDirectoryIsolatedCopy();
 769     String oldOriginDirectory = m_identifier.databaseDirectoryRelativeToRoot(databaseRootDirectory, &quot;v0&quot;);
 770     String oldDatabaseDirectory = FileSystem::pathByAppendingComponent(oldOriginDirectory, filenameForDatabaseName());
 771     String newOriginDirectory = m_identifier.databaseDirectoryRelativeToRoot(databaseRootDirectory, &quot;v1&quot;);
 772     String fileNameHash = SQLiteFileSystem::computeHashForFileName(m_identifier.databaseName());
 773     Vector&lt;String&gt; directoriesWithSameHash = FileSystem::listDirectory(newOriginDirectory, fileNameHash + &quot;*&quot;);
 774     String newDatabaseDirectory = FileSystem::pathByAppendingComponent(newOriginDirectory, fileNameHash);
 775     FileSystem::makeAllDirectories(newDatabaseDirectory);
 776 
 777     if (FileSystem::fileExists(oldDatabaseDirectory)) {
 778         FileSystem::moveFile(oldDatabaseDirectory, newDatabaseDirectory);
 779         FileSystem::deleteEmptyDirectory(oldOriginDirectory);
 780     }
 781 
 782     return newDatabaseDirectory;
 783 }
 784 
 785 IDBError SQLiteIDBBackingStore::getOrEstablishDatabaseInfo(IDBDatabaseInfo&amp; info)
 786 {
 787     LOG(IndexedDB, &quot;SQLiteIDBBackingStore::getOrEstablishDatabaseInfo - database %s&quot;, m_identifier.databaseName().utf8().data());
 788 
 789     if (m_databaseInfo) {
 790         info = *m_databaseInfo;
 791         return IDBError { };
 792     }
 793 
 794     String dbFilename = fullDatabasePath();
 795 
 796     m_sqliteDB = makeUnique&lt;SQLiteDatabase&gt;();
 797     if (!m_sqliteDB-&gt;open(dbFilename)) {
 798         LOG_ERROR(&quot;Failed to open SQLite database at path &#39;%s&#39;&quot;, dbFilename.utf8().data());
 799         closeSQLiteDB();
 800     }
 801 
 802     if (!m_sqliteDB)
 803         return IDBError { UnknownError, &quot;Unable to open database file on disk&quot;_s };
 804 
 805     m_sqliteDB-&gt;setCollationFunction(&quot;IDBKEY&quot;, [](int aLength, const void* a, int bLength, const void* b) {
 806         return idbKeyCollate(aLength, a, bLength, b);
 807     });
 808 
 809     if (!ensureValidRecordsTable()) {
 810         LOG_ERROR(&quot;Error creating or migrating Records table in database&quot;);
 811         closeSQLiteDB();
 812         return IDBError { UnknownError, &quot;Error creating or migrating Records table in database&quot;_s };
 813     }
 814 
 815     if (!ensureValidIndexRecordsTable()) {
 816         LOG_ERROR(&quot;Error creating or migrating Index Records table in database&quot;);
 817         closeSQLiteDB();
 818         return IDBError { UnknownError, &quot;Error creating or migrating Index Records table in database&quot;_s };
 819     }
 820 
 821     if (!ensureValidIndexRecordsIndex()) {
 822         LOG_ERROR(&quot;Error creating or migrating Index Records index in database&quot;);
 823         closeSQLiteDB();
 824         return IDBError { UnknownError, &quot;Error creating or migrating Index Records index in database&quot;_s };
 825     }
 826 
 827     if (!ensureValidBlobTables()) {
 828         LOG_ERROR(&quot;Error creating or confirming Blob Records tables in database&quot;);
 829         closeSQLiteDB();
 830         return IDBError { UnknownError, &quot;Error creating or confirming Blob Records tables in database&quot;_s };
 831     }
 832 
 833     auto databaseInfo = extractExistingDatabaseInfo();
 834     if (!databaseInfo)
 835         databaseInfo = createAndPopulateInitialDatabaseInfo();
 836 
 837     if (!databaseInfo) {
 838         LOG_ERROR(&quot;Unable to establish IDB database at path &#39;%s&#39;&quot;, dbFilename.utf8().data());
 839         closeSQLiteDB();
 840         return IDBError { UnknownError, &quot;Unable to establish IDB database file&quot;_s };
 841     }
 842 
 843     m_databaseInfo = WTFMove(databaseInfo);
 844     info = *m_databaseInfo;
 845     return IDBError { };
 846 }
 847 
 848 uint64_t SQLiteIDBBackingStore::databasesSizeForDirectory(const String&amp; directory)
 849 {
 850     uint64_t diskUsage = 0;
 851     for (auto&amp; dbDirectory : FileSystem::listDirectory(directory, &quot;*&quot;)) {
 852         for (auto&amp; file : FileSystem::listDirectory(dbDirectory, &quot;*.sqlite3&quot;_s))
 853             diskUsage += SQLiteFileSystem::getDatabaseFileSize(file);
 854     }
 855     return diskUsage;
 856 }
 857 
 858 uint64_t SQLiteIDBBackingStore::databaseSize() const
 859 {
 860     ASSERT(!isMainThread());
 861     return SQLiteFileSystem::getDatabaseFileSize(fullDatabasePath());
 862 }
 863 
 864 IDBError SQLiteIDBBackingStore::beginTransaction(const IDBTransactionInfo&amp; info)
 865 {
 866     LOG(IndexedDB, &quot;SQLiteIDBBackingStore::beginTransaction - %s&quot;, info.identifier().loggingString().utf8().data());
 867 
 868     ASSERT(m_sqliteDB);
 869     ASSERT(m_sqliteDB-&gt;isOpen());
 870     ASSERT(m_databaseInfo);
 871 
 872     auto addResult = m_transactions.add(info.identifier(), nullptr);
 873     if (!addResult.isNewEntry) {
 874         LOG_ERROR(&quot;Attempt to establish transaction identifier that already exists&quot;);
 875         return IDBError { UnknownError, &quot;Attempt to establish transaction identifier that already exists&quot;_s };
 876     }
 877 
 878     addResult.iterator-&gt;value = makeUnique&lt;SQLiteIDBTransaction&gt;(*this, info);
 879 
 880     auto error = addResult.iterator-&gt;value-&gt;begin(*m_sqliteDB);
 881     if (error.isNull() &amp;&amp; info.mode() == IDBTransactionMode::Versionchange) {
 882         m_originalDatabaseInfoBeforeVersionChange = makeUnique&lt;IDBDatabaseInfo&gt;(*m_databaseInfo);
 883 
 884         SQLiteStatement sql(*m_sqliteDB, &quot;UPDATE IDBDatabaseInfo SET value = ? where key = &#39;DatabaseVersion&#39;;&quot;_s);
 885         if (sql.prepare() != SQLITE_OK
 886             || sql.bindText(1, String::number(info.newVersion())) != SQLITE_OK
 887             || sql.step() != SQLITE_DONE) {
 888             error = IDBError { UnknownError, &quot;Failed to store new database version in database&quot;_s };
 889         }
 890     }
 891 
 892     return error;
 893 }
 894 
 895 IDBError SQLiteIDBBackingStore::abortTransaction(const IDBResourceIdentifier&amp; identifier)
 896 {
 897     LOG(IndexedDB, &quot;SQLiteIDBBackingStore::abortTransaction - %s&quot;, identifier.loggingString().utf8().data());
 898 
 899     ASSERT(m_sqliteDB);
 900     ASSERT(m_sqliteDB-&gt;isOpen());
 901 
 902     auto transaction = m_transactions.take(identifier);
 903     if (!transaction) {
 904         LOG_ERROR(&quot;Attempt to commit a transaction that hasn&#39;t been established&quot;);
 905         return IDBError { UnknownError, &quot;Attempt to abort a transaction that hasn&#39;t been established&quot;_s };
 906     }
 907 
 908     if (transaction-&gt;mode() == IDBTransactionMode::Versionchange &amp;&amp; m_originalDatabaseInfoBeforeVersionChange)
 909         m_databaseInfo = WTFMove(m_originalDatabaseInfoBeforeVersionChange);
 910 
 911     return transaction-&gt;abort();
 912 }
 913 
 914 IDBError SQLiteIDBBackingStore::commitTransaction(const IDBResourceIdentifier&amp; identifier)
 915 {
 916     LOG(IndexedDB, &quot;SQLiteIDBBackingStore::commitTransaction - %s&quot;, identifier.loggingString().utf8().data());
 917 
 918     ASSERT(m_sqliteDB);
 919     ASSERT(m_sqliteDB-&gt;isOpen());
 920 
 921     auto transaction = m_transactions.take(identifier);
 922     if (!transaction) {
 923         LOG_ERROR(&quot;Attempt to commit a transaction that hasn&#39;t been established&quot;);
 924         return IDBError { UnknownError, &quot;Attempt to commit a transaction that hasn&#39;t been established&quot;_s };
 925     }
 926 
 927     auto error = transaction-&gt;commit();
 928     if (!error.isNull()) {
 929         if (transaction-&gt;mode() == IDBTransactionMode::Versionchange) {
 930             ASSERT(m_originalDatabaseInfoBeforeVersionChange);
 931             m_databaseInfo = WTFMove(m_originalDatabaseInfoBeforeVersionChange);
 932         }
 933     } else
 934         m_originalDatabaseInfoBeforeVersionChange = nullptr;
 935 
 936     return error;
 937 }
 938 
 939 IDBError SQLiteIDBBackingStore::createObjectStore(const IDBResourceIdentifier&amp; transactionIdentifier, const IDBObjectStoreInfo&amp; info)
 940 {
 941     LOG(IndexedDB, &quot;SQLiteIDBBackingStore::createObjectStore - adding OS %s with ID %&quot; PRIu64, info.name().utf8().data(), info.identifier());
 942 
 943     ASSERT(m_sqliteDB);
 944     ASSERT(m_sqliteDB-&gt;isOpen());
 945 
 946     auto* transaction = m_transactions.get(transactionIdentifier);
 947     if (!transaction || !transaction-&gt;inProgress())
 948         return IDBError { UnknownError, &quot;Attempt to create an object store without an in-progress transaction&quot;_s };
 949 
 950     if (transaction-&gt;mode() != IDBTransactionMode::Versionchange) {
 951         LOG_ERROR(&quot;Attempt to create an object store in a non-version-change transaction&quot;);
 952         return IDBError { UnknownError, &quot;Attempt to create an object store in a non-version-change transaction&quot;_s };
 953     }
 954 
 955     RefPtr&lt;SharedBuffer&gt; keyPathBlob = serializeIDBKeyPath(info.keyPath());
 956     if (!keyPathBlob) {
 957         LOG_ERROR(&quot;Unable to serialize IDBKeyPath to save in database for new object store&quot;);
 958         return IDBError { UnknownError, &quot;Unable to serialize IDBKeyPath to save in database for new object store&quot;_s };
 959     }
 960 
 961     {
 962         auto* sql = cachedStatement(SQL::CreateObjectStoreInfo, &quot;INSERT INTO ObjectStoreInfo VALUES (?, ?, ?, ?, ?);&quot;_s);
 963         if (!sql
 964             || sql-&gt;bindInt64(1, info.identifier()) != SQLITE_OK
 965             || sql-&gt;bindText(2, info.name()) != SQLITE_OK
 966             || sql-&gt;bindBlob(3, keyPathBlob-&gt;data(), keyPathBlob-&gt;size()) != SQLITE_OK
 967             || sql-&gt;bindInt(4, info.autoIncrement()) != SQLITE_OK
 968             || sql-&gt;bindInt64(5, info.maxIndexID()) != SQLITE_OK
 969             || sql-&gt;step() != SQLITE_DONE) {
 970             LOG_ERROR(&quot;Could not add object store &#39;%s&#39; to ObjectStoreInfo table (%i) - %s&quot;, info.name().utf8().data(), m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
 971             return IDBError { UnknownError, &quot;Could not create object store&quot;_s };
 972         }
 973     }
 974 
 975     {
 976         auto* sql = cachedStatement(SQL::CreateObjectStoreKeyGenerator, &quot;INSERT INTO KeyGenerators VALUES (?, 0);&quot;_s);
 977         if (!sql
 978             || sql-&gt;bindInt64(1, info.identifier()) != SQLITE_OK
 979             || sql-&gt;step() != SQLITE_DONE) {
 980             LOG_ERROR(&quot;Could not seed initial key generator value for ObjectStoreInfo table (%i) - %s&quot;, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
 981             return IDBError { UnknownError, &quot;Could not seed initial key generator value for object store&quot;_s };
 982         }
 983     }
 984 
 985     m_databaseInfo-&gt;addExistingObjectStore(info);
 986 
 987     return IDBError { };
 988 }
 989 
 990 IDBError SQLiteIDBBackingStore::deleteObjectStore(const IDBResourceIdentifier&amp; transactionIdentifier, uint64_t objectStoreIdentifier)
 991 {
 992     LOG(IndexedDB, &quot;SQLiteIDBBackingStore::deleteObjectStore - object store %&quot; PRIu64, objectStoreIdentifier);
 993 
 994     ASSERT(m_sqliteDB);
 995     ASSERT(m_sqliteDB-&gt;isOpen());
 996 
 997     auto* transaction = m_transactions.get(transactionIdentifier);
 998     if (!transaction || !transaction-&gt;inProgress())
 999         return IDBError { UnknownError, &quot;Attempt to delete an object store without an in-progress transaction&quot;_s };
1000 
1001     if (transaction-&gt;mode() != IDBTransactionMode::Versionchange) {
1002         LOG_ERROR(&quot;Attempt to delete an object store in a non-version-change transaction&quot;);
1003         return IDBError { UnknownError, &quot;Attempt to delete an object store in a non-version-change transaction&quot;_s };
1004     }
1005 
1006     // Delete the ObjectStore record
1007     {
1008         auto* sql = cachedStatement(SQL::DeleteObjectStoreInfo, &quot;DELETE FROM ObjectStoreInfo WHERE id = ?;&quot;_s);
1009         if (!sql
1010             || sql-&gt;bindInt64(1, objectStoreIdentifier) != SQLITE_OK
1011             || sql-&gt;step() != SQLITE_DONE) {
1012             LOG_ERROR(&quot;Could not delete object store id %&quot; PRIi64 &quot; from ObjectStoreInfo table (%i) - %s&quot;, objectStoreIdentifier, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
1013             return IDBError { UnknownError, &quot;Could not delete object store&quot;_s };
1014         }
1015     }
1016 
1017     // Delete the ObjectStore&#39;s key generator record if there is one.
1018     {
1019         auto* sql = cachedStatement(SQL::DeleteObjectStoreKeyGenerator, &quot;DELETE FROM KeyGenerators WHERE objectStoreID = ?;&quot;_s);
1020         if (!sql
1021             || sql-&gt;bindInt64(1, objectStoreIdentifier) != SQLITE_OK
1022             || sql-&gt;step() != SQLITE_DONE) {
1023             LOG_ERROR(&quot;Could not delete object store from KeyGenerators table (%i) - %s&quot;, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
1024             return IDBError { UnknownError, &quot;Could not delete key generator for deleted object store&quot;_s };
1025         }
1026     }
1027 
1028     // Delete all associated records
1029     {
1030         auto* sql = cachedStatement(SQL::DeleteObjectStoreRecords, &quot;DELETE FROM Records WHERE objectStoreID = ?;&quot;_s);
1031         if (!sql
1032             || sql-&gt;bindInt64(1, objectStoreIdentifier) != SQLITE_OK
1033             || sql-&gt;step() != SQLITE_DONE) {
1034             LOG_ERROR(&quot;Could not delete records for object store %&quot; PRIi64 &quot; (%i) - %s&quot;, objectStoreIdentifier, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
1035             return IDBError { UnknownError, &quot;Could not delete records for deleted object store&quot;_s };
1036         }
1037     }
1038 
1039     // Delete all associated Indexes
1040     {
1041         auto* sql = cachedStatement(SQL::DeleteObjectStoreIndexInfo, &quot;DELETE FROM IndexInfo WHERE objectStoreID = ?;&quot;_s);
1042         if (!sql
1043             || sql-&gt;bindInt64(1, objectStoreIdentifier) != SQLITE_OK
1044             || sql-&gt;step() != SQLITE_DONE) {
1045             LOG_ERROR(&quot;Could not delete index from IndexInfo table (%i) - %s&quot;, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
1046             return IDBError { UnknownError, &quot;Could not delete IDBIndex for deleted object store&quot;_s };
1047         }
1048     }
1049 
1050     // Delete all associated Index records
1051     {
1052         auto* sql = cachedStatement(SQL::DeleteObjectStoreIndexRecords, &quot;DELETE FROM IndexRecords WHERE objectStoreID = ?;&quot;_s);
1053         if (!sql
1054             || sql-&gt;bindInt64(1, objectStoreIdentifier) != SQLITE_OK
1055             || sql-&gt;step() != SQLITE_DONE) {
1056             LOG_ERROR(&quot;Could not delete index records(%i) - %s&quot;, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
1057             return IDBError { UnknownError, &quot;Could not delete IDBIndex records for deleted object store&quot;_s };
1058         }
1059     }
1060 
1061     // Delete all unused Blob URL records.
1062     {
1063         auto* sql = cachedStatement(SQL::DeleteObjectStoreBlobRecords, &quot;DELETE FROM BlobRecords WHERE objectStoreRow NOT IN (SELECT recordID FROM Records)&quot;_s);
1064         if (!sql
1065             || sql-&gt;step() != SQLITE_DONE) {
1066             LOG_ERROR(&quot;Could not delete Blob URL records(%i) - %s&quot;, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
1067             return IDBError { UnknownError, &quot;Could not delete stored blob records for deleted object store&quot;_s };
1068         }
1069     }
1070 
1071     // Delete all unused Blob File records.
1072     auto error = deleteUnusedBlobFileRecords(*transaction);
1073     if (!error.isNull())
1074         return error;
1075 
1076     m_databaseInfo-&gt;deleteObjectStore(objectStoreIdentifier);
1077 
1078     return IDBError { };
1079 }
1080 
1081 IDBError SQLiteIDBBackingStore::renameObjectStore(const IDBResourceIdentifier&amp; transactionIdentifier, uint64_t objectStoreIdentifier, const String&amp; newName)
1082 {
1083     LOG(IndexedDB, &quot;SQLiteIDBBackingStore::renameObjectStore - object store %&quot; PRIu64, objectStoreIdentifier);
1084 
1085     ASSERT(m_sqliteDB);
1086     ASSERT(m_sqliteDB-&gt;isOpen());
1087 
1088     auto* transaction = m_transactions.get(transactionIdentifier);
1089     if (!transaction || !transaction-&gt;inProgress())
1090         return IDBError { UnknownError, &quot;Attempt to rename an object store without an in-progress transaction&quot;_s };
1091 
1092     if (transaction-&gt;mode() != IDBTransactionMode::Versionchange) {
1093         LOG_ERROR(&quot;Attempt to rename an object store in a non-version-change transaction&quot;);
1094         return IDBError { UnknownError, &quot;Attempt to rename an object store in a non-version-change transaction&quot;_s };
1095     }
1096 
1097     {
1098         auto* sql = cachedStatement(SQL::RenameObjectStore, &quot;UPDATE ObjectStoreInfo SET name = ? WHERE id = ?;&quot;_s);
1099         if (!sql
1100             || sql-&gt;bindText(1, newName) != SQLITE_OK
1101             || sql-&gt;bindInt64(2, objectStoreIdentifier) != SQLITE_OK
1102             || sql-&gt;step() != SQLITE_DONE) {
1103             LOG_ERROR(&quot;Could not update name for object store id %&quot; PRIi64 &quot; in ObjectStoreInfo table (%i) - %s&quot;, objectStoreIdentifier, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
1104             return IDBError { UnknownError, &quot;Could not rename object store&quot;_s };
1105         }
1106     }
1107 
1108     m_databaseInfo-&gt;renameObjectStore(objectStoreIdentifier, newName);
1109 
1110     return IDBError { };
1111 }
1112 
1113 IDBError SQLiteIDBBackingStore::clearObjectStore(const IDBResourceIdentifier&amp; transactionIdentifier, uint64_t objectStoreID)
1114 {
1115     LOG(IndexedDB, &quot;SQLiteIDBBackingStore::clearObjectStore - object store %&quot; PRIu64, objectStoreID);
1116 
1117     ASSERT(m_sqliteDB);
1118     ASSERT(m_sqliteDB-&gt;isOpen());
1119 
1120     auto* transaction = m_transactions.get(transactionIdentifier);
1121     if (!transaction || !transaction-&gt;inProgress())
1122         return IDBError { UnknownError, &quot;Attempt to clear an object store without an in-progress transaction&quot;_s };
1123 
1124     if (transaction-&gt;mode() == IDBTransactionMode::Readonly) {
1125         LOG_ERROR(&quot;Attempt to clear an object store in a read-only transaction&quot;);
1126         return IDBError { UnknownError, &quot;Attempt to clear an object store in a read-only transaction&quot;_s };
1127     }
1128 
1129     {
1130         auto* sql = cachedStatement(SQL::ClearObjectStoreRecords, &quot;DELETE FROM Records WHERE objectStoreID = ?;&quot;_s);
1131         if (!sql
1132             || sql-&gt;bindInt64(1, objectStoreID) != SQLITE_OK
1133             || sql-&gt;step() != SQLITE_DONE) {
1134             LOG_ERROR(&quot;Could not clear records from object store id %&quot; PRIi64 &quot; (%i) - %s&quot;, objectStoreID, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
1135             return IDBError { UnknownError, &quot;Unable to clear object store&quot;_s };
1136         }
1137     }
1138 
1139     {
1140         auto* sql = cachedStatement(SQL::ClearObjectStoreIndexRecords, &quot;DELETE FROM IndexRecords WHERE objectStoreID = ?;&quot;_s);
1141         if (!sql
1142             || sql-&gt;bindInt64(1, objectStoreID) != SQLITE_OK
1143             || sql-&gt;step() != SQLITE_DONE) {
1144             LOG_ERROR(&quot;Could not delete records from index record store id %&quot; PRIi64 &quot; (%i) - %s&quot;, objectStoreID, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
1145             return IDBError { UnknownError, &quot;Unable to delete index records while clearing object store&quot;_s };
1146         }
1147     }
1148 
1149     transaction-&gt;notifyCursorsOfChanges(objectStoreID);
1150 
1151     return IDBError { };
1152 }
1153 
1154 IDBError SQLiteIDBBackingStore::createIndex(const IDBResourceIdentifier&amp; transactionIdentifier, const IDBIndexInfo&amp; info)
1155 {
1156     LOG(IndexedDB, &quot;SQLiteIDBBackingStore::createIndex - ObjectStore %&quot; PRIu64 &quot;, Index %&quot; PRIu64, info.objectStoreIdentifier(), info.identifier());
1157     ASSERT(m_sqliteDB);
1158     ASSERT(m_sqliteDB-&gt;isOpen());
1159 
1160     auto* transaction = m_transactions.get(transactionIdentifier);
1161     if (!transaction || !transaction-&gt;inProgress())
1162         return IDBError { UnknownError, &quot;Attempt to create an index without an in-progress transaction&quot;_s };
1163 
1164     if (transaction-&gt;mode() != IDBTransactionMode::Versionchange) {
1165         LOG_ERROR(&quot;Attempt to create an index in a non-version-change transaction&quot;);
1166         return IDBError { UnknownError, &quot;Attempt to create an index in a non-version-change transaction&quot;_s };
1167     }
1168 
1169     RefPtr&lt;SharedBuffer&gt; keyPathBlob = serializeIDBKeyPath(info.keyPath());
1170     if (!keyPathBlob) {
1171         LOG_ERROR(&quot;Unable to serialize IDBKeyPath to save in database&quot;);
1172         return IDBError { UnknownError, &quot;Unable to serialize IDBKeyPath to create index in database&quot;_s };
1173     }
1174 
1175     auto* sql = cachedStatement(SQL::CreateIndexInfo, &quot;INSERT INTO IndexInfo VALUES (?, ?, ?, ?, ?, ?);&quot;_s);
1176     if (!sql
1177         || sql-&gt;bindInt64(1, info.identifier()) != SQLITE_OK
1178         || sql-&gt;bindText(2, info.name()) != SQLITE_OK
1179         || sql-&gt;bindInt64(3, info.objectStoreIdentifier()) != SQLITE_OK
1180         || sql-&gt;bindBlob(4, keyPathBlob-&gt;data(), keyPathBlob-&gt;size()) != SQLITE_OK
1181         || sql-&gt;bindInt(5, info.unique()) != SQLITE_OK
1182         || sql-&gt;bindInt(6, info.multiEntry()) != SQLITE_OK
1183         || sql-&gt;step() != SQLITE_DONE) {
1184         LOG_ERROR(&quot;Could not add index &#39;%s&#39; to IndexInfo table (%i) - %s&quot;, info.name().utf8().data(), m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
1185         return IDBError { UnknownError, &quot;Unable to create index in database&quot;_s };
1186     }
1187 
1188     // Write index records for any records that already exist in this object store.
1189 
1190     auto cursor = transaction-&gt;maybeOpenBackingStoreCursor(info.objectStoreIdentifier(), 0, IDBKeyRangeData::allKeys());
1191 
1192     if (!cursor) {
1193         LOG_ERROR(&quot;Cannot open cursor to populate indexes in database&quot;);
1194         return IDBError { UnknownError, &quot;Unable to populate indexes in database&quot;_s };
1195     }
1196 
1197     while (!cursor-&gt;currentKey().isNull()) {
1198         auto&amp; key = cursor-&gt;currentKey();
1199         auto* value = cursor-&gt;currentValue();
1200         ThreadSafeDataBuffer valueBuffer = value ? value-&gt;data() : ThreadSafeDataBuffer();
1201 
1202         ASSERT(cursor-&gt;currentRecordRowID());
1203 
1204         IDBError error = updateOneIndexForAddRecord(info, key, valueBuffer, cursor-&gt;currentRecordRowID());
1205         if (!error.isNull()) {
1206             auto* sql = cachedStatement(SQL::DeleteIndexInfo, &quot;DELETE FROM IndexInfo WHERE id = ? AND objectStoreID = ?;&quot;_s);
1207             if (!sql
1208                 || sql-&gt;bindInt64(1, info.identifier()) != SQLITE_OK
1209                 || sql-&gt;bindInt64(2, info.objectStoreIdentifier()) != SQLITE_OK
1210                 || sql-&gt;step() != SQLITE_DONE) {
1211                 LOG_ERROR(&quot;Index creation failed due to uniqueness constraint failure, but there was an error deleting the Index record from the database&quot;);
1212                 return IDBError { UnknownError, &quot;Index creation failed due to uniqueness constraint failure, but there was an error deleting the Index record from the database&quot;_s };
1213             }
1214 
1215             return error;
1216         }
1217 
1218         if (!cursor-&gt;advance(1)) {
1219             LOG_ERROR(&quot;Error advancing cursor while indexing existing records for new index.&quot;);
1220             return IDBError { UnknownError, &quot;Error advancing cursor while indexing existing records for new index&quot;_s };
1221         }
1222     }
1223 
1224     ASSERT(m_databaseInfo);
1225     if (!m_databaseInfo) {
1226         RELEASE_LOG_ERROR(IndexedDB, &quot;%p - SQLiteIDBBackingStore::clearObjectStore: m_databaseInfo is null&quot;, this);
1227         return IDBError { UnknownError, &quot;Database info is invalid&quot;_s };
1228     }
1229 
1230     auto* objectStore = m_databaseInfo-&gt;infoForExistingObjectStore(info.objectStoreIdentifier());
1231     ASSERT(objectStore);
1232     objectStore-&gt;addExistingIndex(info);
1233 
1234     return IDBError { };
1235 }
1236 
1237 IDBError SQLiteIDBBackingStore::uncheckedHasIndexRecord(const IDBIndexInfo&amp; info, const IDBKeyData&amp; indexKey, bool&amp; hasRecord)
1238 {
1239     hasRecord = false;
1240 
1241     RefPtr&lt;SharedBuffer&gt; indexKeyBuffer = serializeIDBKeyData(indexKey);
1242     if (!indexKeyBuffer) {
1243         LOG_ERROR(&quot;Unable to serialize index key to be stored in the database&quot;);
1244         return IDBError { UnknownError, &quot;Unable to serialize IDBKey to check for index record in database&quot;_s };
1245     }
1246 
1247     auto* sql = cachedStatement(SQL::HasIndexRecord, &quot;SELECT rowid FROM IndexRecords WHERE indexID = ? AND objectStoreID = ? AND key = CAST(? AS TEXT);&quot;_s);
1248     if (!sql
1249         || sql-&gt;bindInt64(1, info.identifier()) != SQLITE_OK
1250         || sql-&gt;bindInt64(2, info.objectStoreIdentifier()) != SQLITE_OK
1251         || sql-&gt;bindBlob(3, indexKeyBuffer-&gt;data(), indexKeyBuffer-&gt;size()) != SQLITE_OK) {
1252         LOG_ERROR(&quot;Error checking for index record in database&quot;);
1253         return IDBError { UnknownError, &quot;Error checking for index record in database&quot;_s };
1254     }
1255 
1256     int sqlResult = sql-&gt;step();
1257     if (sqlResult == SQLITE_OK || sqlResult == SQLITE_DONE)
1258         return IDBError { };
1259 
1260     if (sqlResult != SQLITE_ROW) {
1261         // There was an error fetching the record from the database.
1262         LOG_ERROR(&quot;Could not check if key exists in index (%i) - %s&quot;, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
1263         return IDBError { UnknownError, &quot;Error checking for existence of IDBKey in index&quot;_s };
1264     }
1265 
1266     hasRecord = true;
1267     return IDBError { };
1268 }
1269 
1270 IDBError SQLiteIDBBackingStore::uncheckedPutIndexKey(const IDBIndexInfo&amp; info, const IDBKeyData&amp; key, const IndexKey&amp; indexKey, int64_t recordID)
1271 {
1272     LOG(IndexedDB, &quot;SQLiteIDBBackingStore::uncheckedPutIndexKey - (%&quot; PRIu64 &quot;) %s, %s&quot;, info.identifier(), key.loggingString().utf8().data(), indexKey.asOneKey().loggingString().utf8().data());
1273 
1274     Vector&lt;IDBKeyData&gt; indexKeys;
1275     if (info.multiEntry())
1276         indexKeys = indexKey.multiEntry();
1277     else
1278         indexKeys.append(indexKey.asOneKey());
1279 
1280     if (info.unique()) {
1281         bool hasRecord;
1282         IDBError error;
1283         for (auto&amp; indexKey : indexKeys) {
1284             if (!indexKey.isValid())
1285                 continue;
1286             error = uncheckedHasIndexRecord(info, indexKey, hasRecord);
1287             if (!error.isNull())
1288                 return error;
1289             if (hasRecord)
1290                 return IDBError(ConstraintError);
1291         }
1292     }
1293 
1294     for (auto&amp; indexKey : indexKeys) {
1295         if (!indexKey.isValid())
1296             continue;
1297         auto error = uncheckedPutIndexRecord(info.objectStoreIdentifier(), info.identifier(), key, indexKey, recordID);
1298         if (!error.isNull()) {
1299             LOG_ERROR(&quot;Unable to put index record for newly created index&quot;);
1300             return error;
1301         }
1302     }
1303 
1304     return IDBError { };
1305 }
1306 
1307 IDBError SQLiteIDBBackingStore::uncheckedPutIndexRecord(int64_t objectStoreID, int64_t indexID, const WebCore::IDBKeyData&amp; keyValue, const WebCore::IDBKeyData&amp; indexKey, int64_t recordID)
1308 {
1309     LOG(IndexedDB, &quot;SQLiteIDBBackingStore::uncheckedPutIndexRecord - %s, %s&quot;, keyValue.loggingString().utf8().data(), indexKey.loggingString().utf8().data());
1310 
1311     RefPtr&lt;SharedBuffer&gt; indexKeyBuffer = serializeIDBKeyData(indexKey);
1312     if (!indexKeyBuffer) {
1313         LOG_ERROR(&quot;Unable to serialize index key to be stored in the database&quot;);
1314         return IDBError { UnknownError, &quot;Unable to serialize index key to be stored in the database&quot;_s };
1315     }
1316 
1317     RefPtr&lt;SharedBuffer&gt; valueBuffer = serializeIDBKeyData(keyValue);
1318     if (!valueBuffer) {
1319         LOG_ERROR(&quot;Unable to serialize the value to be stored in the database&quot;);
1320         return IDBError { UnknownError, &quot;Unable to serialize value to be stored in the database&quot;_s };
1321     }
1322 
1323     {
1324         auto* sql = cachedStatement(SQL::PutIndexRecord, &quot;INSERT INTO IndexRecords VALUES (?, ?, CAST(? AS TEXT), CAST(? AS TEXT), ?);&quot;_s);
1325         if (!sql
1326             || sql-&gt;bindInt64(1, indexID) != SQLITE_OK
1327             || sql-&gt;bindInt64(2, objectStoreID) != SQLITE_OK
1328             || sql-&gt;bindBlob(3, indexKeyBuffer-&gt;data(), indexKeyBuffer-&gt;size()) != SQLITE_OK
1329             || sql-&gt;bindBlob(4, valueBuffer-&gt;data(), valueBuffer-&gt;size()) != SQLITE_OK
1330             || sql-&gt;bindInt64(5, recordID) != SQLITE_OK
1331             || sql-&gt;step() != SQLITE_DONE) {
1332             LOG_ERROR(&quot;Could not put index record for index %&quot; PRIi64 &quot; in object store %&quot; PRIi64 &quot; in Records table (%i) - %s&quot;, indexID, objectStoreID, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
1333             return IDBError { UnknownError, &quot;Error putting index record into database&quot;_s };
1334         }
1335     }
1336 
1337     return IDBError { };
1338 }
1339 
1340 
1341 IDBError SQLiteIDBBackingStore::deleteIndex(const IDBResourceIdentifier&amp; transactionIdentifier, uint64_t objectStoreIdentifier, uint64_t indexIdentifier)
1342 {
1343     LOG(IndexedDB, &quot;SQLiteIDBBackingStore::deleteIndex - object store %&quot; PRIu64, objectStoreIdentifier);
1344 
1345     ASSERT(m_sqliteDB);
1346     ASSERT(m_sqliteDB-&gt;isOpen());
1347 
1348     auto* transaction = m_transactions.get(transactionIdentifier);
1349     if (!transaction || !transaction-&gt;inProgress())
1350         return IDBError { UnknownError, &quot;Attempt to delete index without an in-progress transaction&quot;_s };
1351 
1352     if (transaction-&gt;mode() != IDBTransactionMode::Versionchange) {
1353         LOG_ERROR(&quot;Attempt to delete index during a non-version-change transaction&quot;);
1354         return IDBError { UnknownError, &quot;Attempt to delete index during a non-version-change transaction&quot;_s };
1355     }
1356 
1357     {
1358         auto* sql = cachedStatement(SQL::DeleteIndexInfo, &quot;DELETE FROM IndexInfo WHERE id = ? AND objectStoreID = ?;&quot;_s);
1359         if (!sql
1360             || sql-&gt;bindInt64(1, indexIdentifier) != SQLITE_OK
1361             || sql-&gt;bindInt64(2, objectStoreIdentifier) != SQLITE_OK
1362             || sql-&gt;step() != SQLITE_DONE) {
1363             LOG_ERROR(&quot;Could not delete index id %&quot; PRIi64 &quot; from IndexInfo table (%i) - %s&quot;, objectStoreIdentifier, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
1364             return IDBError { UnknownError, &quot;Error deleting index from database&quot;_s };
1365         }
1366     }
1367 
1368     {
1369         auto* sql = cachedStatement(SQL::DeleteIndexRecords, &quot;DELETE FROM IndexRecords WHERE indexID = ? AND objectStoreID = ?;&quot;_s);
1370         if (!sql
1371             || sql-&gt;bindInt64(1, indexIdentifier) != SQLITE_OK
1372             || sql-&gt;bindInt64(2, objectStoreIdentifier) != SQLITE_OK
1373             || sql-&gt;step() != SQLITE_DONE) {
1374             LOG_ERROR(&quot;Could not delete index records for index id %&quot; PRIi64 &quot; from IndexRecords table (%i) - %s&quot;, indexIdentifier, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
1375             return IDBError { UnknownError, &quot;Error deleting index records from database&quot;_s };
1376         }
1377     }
1378 
1379     auto* objectStore = m_databaseInfo-&gt;infoForExistingObjectStore(objectStoreIdentifier);
1380     ASSERT(objectStore);
1381     objectStore-&gt;deleteIndex(indexIdentifier);
1382 
1383     return IDBError { };
1384 }
1385 
1386 IDBError SQLiteIDBBackingStore::renameIndex(const IDBResourceIdentifier&amp; transactionIdentifier, uint64_t objectStoreIdentifier, uint64_t indexIdentifier, const String&amp; newName)
1387 {
1388     LOG(IndexedDB, &quot;SQLiteIDBBackingStore::renameIndex - object store %&quot; PRIu64 &quot;, index %&quot; PRIu64, objectStoreIdentifier, indexIdentifier);
1389 
1390     ASSERT(m_sqliteDB);
1391     ASSERT(m_sqliteDB-&gt;isOpen());
1392 
1393     auto* objectStoreInfo = m_databaseInfo-&gt;infoForExistingObjectStore(objectStoreIdentifier);
1394     if (!objectStoreInfo)
1395         return IDBError { UnknownError, &quot;Could not rename index&quot;_s };
1396 
1397     auto* indexInfo = objectStoreInfo-&gt;infoForExistingIndex(indexIdentifier);
1398     if (!indexInfo)
1399         return IDBError { UnknownError, &quot;Could not rename index&quot;_s };
1400 
1401     auto* transaction = m_transactions.get(transactionIdentifier);
1402     if (!transaction || !transaction-&gt;inProgress())
1403         return IDBError { UnknownError, &quot;Attempt to rename an index without an in-progress transaction&quot;_s };
1404 
1405     if (transaction-&gt;mode() != IDBTransactionMode::Versionchange) {
1406         LOG_ERROR(&quot;Attempt to rename an index in a non-version-change transaction&quot;);
1407         return IDBError { UnknownError, &quot;Attempt to rename an index in a non-version-change transaction&quot;_s };
1408     }
1409 
1410     {
1411         auto* sql = cachedStatement(SQL::RenameIndex, &quot;UPDATE IndexInfo SET name = ? WHERE objectStoreID = ? AND id = ?;&quot;_s);
1412         if (!sql
1413             || sql-&gt;bindText(1, newName) != SQLITE_OK
1414             || sql-&gt;bindInt64(2, objectStoreIdentifier) != SQLITE_OK
1415             || sql-&gt;bindInt64(3, indexIdentifier) != SQLITE_OK
1416             || sql-&gt;step() != SQLITE_DONE) {
1417             LOG_ERROR(&quot;Could not update name for index id (%&quot; PRIi64 &quot;, %&quot; PRIi64 &quot;) in IndexInfo table (%i) - %s&quot;, objectStoreIdentifier, indexIdentifier, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
1418             return IDBError { UnknownError, &quot;Could not rename index&quot;_s };
1419         }
1420     }
1421 
1422     indexInfo-&gt;rename(newName);
1423 
1424     return IDBError { };
1425 }
1426 
1427 IDBError SQLiteIDBBackingStore::keyExistsInObjectStore(const IDBResourceIdentifier&amp; transactionIdentifier, uint64_t objectStoreID, const IDBKeyData&amp; keyData, bool&amp; keyExists)
1428 {
1429     LOG(IndexedDB, &quot;SQLiteIDBBackingStore::keyExistsInObjectStore - key %s, object store %&quot; PRIu64, keyData.loggingString().utf8().data(), objectStoreID);
1430 
1431     ASSERT(m_sqliteDB);
1432     ASSERT(m_sqliteDB-&gt;isOpen());
1433 
1434     keyExists = false;
1435 
1436     auto* transaction = m_transactions.get(transactionIdentifier);
1437     if (!transaction || !transaction-&gt;inProgress())
1438         return IDBError { UnknownError, &quot;Attempt to see if key exists in objectstore without an in-progress transaction&quot;_s };
1439 
1440     RefPtr&lt;SharedBuffer&gt; keyBuffer = serializeIDBKeyData(keyData);
1441     if (!keyBuffer) {
1442         LOG_ERROR(&quot;Unable to serialize IDBKey to check for existence in object store&quot;);
1443         return IDBError { UnknownError, &quot;Unable to serialize IDBKey to check for existence in object store&quot;_s };
1444     }
1445     auto* sql = cachedStatement(SQL::KeyExistsInObjectStore, &quot;SELECT key FROM Records WHERE objectStoreID = ? AND key = CAST(? AS TEXT) LIMIT 1;&quot;_s);
1446     if (!sql
1447         || sql-&gt;bindInt64(1, objectStoreID) != SQLITE_OK
1448         || sql-&gt;bindBlob(2, keyBuffer-&gt;data(), keyBuffer-&gt;size()) != SQLITE_OK) {
1449         LOG_ERROR(&quot;Could not get record from object store %&quot; PRIi64 &quot; from Records table (%i) - %s&quot;, objectStoreID, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
1450         return IDBError { UnknownError, &quot;Unable to check for existence of IDBKey in object store&quot;_s };
1451     }
1452 
1453     int sqlResult = sql-&gt;step();
1454     if (sqlResult == SQLITE_OK || sqlResult == SQLITE_DONE)
1455         return IDBError { };
1456 
1457     if (sqlResult != SQLITE_ROW) {
1458         // There was an error fetching the record from the database.
1459         LOG_ERROR(&quot;Could not check if key exists in object store (%i) - %s&quot;, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
1460         return IDBError { UnknownError, &quot;Error checking for existence of IDBKey in object store&quot;_s };
1461     }
1462 
1463     keyExists = true;
1464     return IDBError { };
1465 }
1466 
1467 IDBError SQLiteIDBBackingStore::deleteUnusedBlobFileRecords(SQLiteIDBTransaction&amp; transaction)
1468 {
1469     LOG(IndexedDB, &quot;SQLiteIDBBackingStore::deleteUnusedBlobFileRecords&quot;);
1470 
1471     // Gather the set of blob URLs and filenames that are no longer in use.
1472     HashSet&lt;String&gt; removedBlobFilenames;
1473     {
1474         auto* sql = cachedStatement(SQL::GetUnusedBlobFilenames, &quot;SELECT fileName FROM BlobFiles WHERE blobURL NOT IN (SELECT blobURL FROM BlobRecords)&quot;_s);
1475 
1476         if (!sql) {
1477             LOG_ERROR(&quot;Error deleting stored blobs (%i) (Could not gather unused blobURLs) - %s&quot;, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
1478             return IDBError { UnknownError, &quot;Error deleting stored blobs&quot;_s };
1479         }
1480 
1481         int result = sql-&gt;step();
1482         while (result == SQLITE_ROW) {
1483             removedBlobFilenames.add(sql-&gt;getColumnText(0));
1484             result = sql-&gt;step();
1485         }
1486 
1487         if (result != SQLITE_DONE) {
1488             LOG_ERROR(&quot;Error deleting stored blobs (%i) (Could not gather unused blobURLs) - %s&quot;, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
1489             return IDBError { UnknownError, &quot;Error deleting stored blobs&quot;_s };
1490         }
1491     }
1492 
1493     // Remove the blob records that are no longer in use.
1494     if (!removedBlobFilenames.isEmpty()) {
1495         auto* sql = cachedStatement(SQL::DeleteUnusedBlobs, &quot;DELETE FROM BlobFiles WHERE blobURL NOT IN (SELECT blobURL FROM BlobRecords)&quot;_s);
1496 
1497         if (!sql
1498             || sql-&gt;step() != SQLITE_DONE) {
1499             LOG_ERROR(&quot;Error deleting stored blobs (%i) (Could not delete blobFile records) - %s&quot;, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
1500             return IDBError { UnknownError, &quot;Error deleting stored blobs&quot;_s };
1501         }
1502     }
1503 
1504     for (auto&amp; file : removedBlobFilenames)
1505         transaction.addRemovedBlobFile(file);
1506 
1507     return IDBError { };
1508 }
1509 
1510 IDBError SQLiteIDBBackingStore::deleteRecord(SQLiteIDBTransaction&amp; transaction, int64_t objectStoreID, const IDBKeyData&amp; keyData)
1511 {
1512     LOG(IndexedDB, &quot;SQLiteIDBBackingStore::deleteRecord - key %s, object store %&quot; PRIu64, keyData.loggingString().utf8().data(), objectStoreID);
1513 
1514     ASSERT(m_sqliteDB);
1515     ASSERT(m_sqliteDB-&gt;isOpen());
1516     ASSERT(transaction.inProgress());
1517     ASSERT(transaction.mode() != IDBTransactionMode::Readonly);
1518     UNUSED_PARAM(transaction);
1519 
1520     RefPtr&lt;SharedBuffer&gt; keyBuffer = serializeIDBKeyData(keyData);
1521     if (!keyBuffer) {
1522         LOG_ERROR(&quot;Unable to serialize IDBKeyData to be removed from the database&quot;);
1523         return IDBError { UnknownError, &quot;Unable to serialize IDBKeyData to be removed from the database&quot;_s };
1524     }
1525 
1526     // Get the record ID
1527     int64_t recordID;
1528     {
1529         auto* sql = cachedStatement(SQL::GetObjectStoreRecordID, &quot;SELECT recordID FROM Records WHERE objectStoreID = ? AND key = CAST(? AS TEXT);&quot;_s);
1530 
1531         if (!sql
1532             || sql-&gt;bindInt64(1, objectStoreID) != SQLITE_OK
1533             || sql-&gt;bindBlob(2, keyBuffer-&gt;data(), keyBuffer-&gt;size()) != SQLITE_OK) {
1534             LOG_ERROR(&quot;Could not delete record from object store %&quot; PRIi64 &quot; (%i) - %s&quot;, objectStoreID, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
1535             return IDBError { UnknownError, &quot;Failed to delete record from object store&quot;_s };
1536         }
1537 
1538         int result = sql-&gt;step();
1539 
1540         // If there&#39;s no record ID, there&#39;s no record to delete.
1541         if (result == SQLITE_DONE)
1542             return IDBError { };
1543 
1544         if (result != SQLITE_ROW) {
1545             LOG_ERROR(&quot;Could not delete record from object store %&quot; PRIi64 &quot; (%i) (unable to fetch record ID) - %s&quot;, objectStoreID, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
1546             return IDBError { UnknownError, &quot;Failed to delete record from object store&quot;_s };
1547         }
1548 
1549         recordID = sql-&gt;getColumnInt64(0);
1550     }
1551 
1552     if (recordID &lt; 1) {
1553         LOG_ERROR(&quot;Could not delete record from object store %&quot; PRIi64 &quot; (%i) (record ID is invalid) - %s&quot;, objectStoreID, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
1554         return IDBError { UnknownError, &quot;Failed to delete record from object store&quot;_s };
1555     }
1556 
1557     // Delete the blob records for this object store record.
1558     {
1559         auto* sql = cachedStatement(SQL::DeleteBlobRecord, &quot;DELETE FROM BlobRecords WHERE objectStoreRow = ?;&quot;_s);
1560 
1561         if (!sql
1562             || sql-&gt;bindInt64(1, recordID) != SQLITE_OK
1563             || sql-&gt;step() != SQLITE_DONE) {
1564             LOG_ERROR(&quot;Could not delete record from object store %&quot; PRIi64 &quot; (%i) (Could not delete BlobRecords records) - %s&quot;, objectStoreID, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
1565             return IDBError { UnknownError, &quot;Failed to delete record from object store&quot;_s };
1566         }
1567     }
1568 
1569     auto error = deleteUnusedBlobFileRecords(transaction);
1570     if (!error.isNull())
1571         return error;
1572 
1573     // Delete record from object store
1574     {
1575         auto* sql = cachedStatement(SQL::DeleteObjectStoreRecord, &quot;DELETE FROM Records WHERE objectStoreID = ? AND key = CAST(? AS TEXT);&quot;_s);
1576 
1577         if (!sql
1578             || sql-&gt;bindInt64(1, objectStoreID) != SQLITE_OK
1579             || sql-&gt;bindBlob(2, keyBuffer-&gt;data(), keyBuffer-&gt;size()) != SQLITE_OK
1580             || sql-&gt;step() != SQLITE_DONE) {
1581             LOG_ERROR(&quot;Could not delete record from object store %&quot; PRIi64 &quot; (%i) - %s&quot;, objectStoreID, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
1582             return IDBError { UnknownError, &quot;Failed to delete record from object store&quot;_s };
1583         }
1584     }
1585 
1586     // Delete record from indexes store
1587     {
1588         auto* sql = cachedStatement(SQL::DeleteObjectStoreIndexRecord, &quot;DELETE FROM IndexRecords WHERE objectStoreID = ? AND value = CAST(? AS TEXT);&quot;_s);
1589 
1590         if (!sql
1591             || sql-&gt;bindInt64(1, objectStoreID) != SQLITE_OK
1592             || sql-&gt;bindBlob(2, keyBuffer-&gt;data(), keyBuffer-&gt;size()) != SQLITE_OK
1593             || sql-&gt;step() != SQLITE_DONE) {
1594             LOG_ERROR(&quot;Could not delete record from indexes for object store %&quot; PRIi64 &quot; (%i) - %s&quot;, objectStoreID, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
1595             return IDBError { UnknownError, &quot;Failed to delete index entries for object store record&quot;_s };
1596         }
1597     }
1598 
1599     return IDBError { };
1600 }
1601 
1602 IDBError SQLiteIDBBackingStore::deleteRange(const IDBResourceIdentifier&amp; transactionIdentifier, uint64_t objectStoreID, const IDBKeyRangeData&amp; keyRange)
1603 {
1604     LOG(IndexedDB, &quot;SQLiteIDBBackingStore::deleteRange - range %s, object store %&quot; PRIu64, keyRange.loggingString().utf8().data(), objectStoreID);
1605 
1606     ASSERT(m_sqliteDB);
1607     ASSERT(m_sqliteDB-&gt;isOpen());
1608 
1609     auto* transaction = m_transactions.get(transactionIdentifier);
1610     if (!transaction || !transaction-&gt;inProgress())
1611         return IDBError { UnknownError, &quot;Attempt to delete range from database without an in-progress transaction&quot;_s };
1612 
1613     if (transaction-&gt;mode() == IDBTransactionMode::Readonly) {
1614         LOG_ERROR(&quot;Attempt to delete records from an object store in a read-only transaction&quot;);
1615         return IDBError { UnknownError, &quot;Attempt to delete records from an object store in a read-only transaction&quot;_s };
1616     }
1617 
1618     // If the range to delete is exactly one key we can delete it right now.
1619     if (keyRange.isExactlyOneKey()) {
1620         auto error = deleteRecord(*transaction, objectStoreID, keyRange.lowerKey);
1621         if (!error.isNull()) {
1622             LOG_ERROR(&quot;Failed to delete record for key &#39;%s&#39;&quot;, keyRange.lowerKey.loggingString().utf8().data());
1623             return error;
1624         }
1625 
1626         transaction-&gt;notifyCursorsOfChanges(objectStoreID);
1627 
1628         return IDBError { };
1629     }
1630 
1631     auto cursor = transaction-&gt;maybeOpenBackingStoreCursor(objectStoreID, 0, keyRange);
1632     if (!cursor) {
1633         LOG_ERROR(&quot;Cannot open cursor to delete range of records from the database&quot;);
1634         return IDBError { UnknownError, &quot;Cannot open cursor to delete range of records from the database&quot;_s };
1635     }
1636 
1637     Vector&lt;IDBKeyData&gt; keys;
1638     while (!cursor-&gt;didComplete() &amp;&amp; !cursor-&gt;didError()) {
1639         keys.append(cursor-&gt;currentKey());
1640         cursor-&gt;advance(1);
1641     }
1642 
1643     if (cursor-&gt;didError()) {
1644         LOG_ERROR(&quot;Cursor failed while accumulating range of records from the database&quot;);
1645         return IDBError { UnknownError, &quot;Cursor failed while accumulating range of records from the database&quot;_s };
1646     }
1647 
1648     IDBError error;
1649     for (auto&amp; key : keys) {
1650         error = deleteRecord(*transaction, objectStoreID, key);
1651         if (!error.isNull()) {
1652             LOG_ERROR(&quot;deleteRange: Error deleting keys in range&quot;);
1653             break;
1654         }
1655     }
1656 
1657     transaction-&gt;notifyCursorsOfChanges(objectStoreID);
1658 
1659     return error;
1660 }
1661 
1662 IDBError SQLiteIDBBackingStore::updateOneIndexForAddRecord(const IDBIndexInfo&amp; info, const IDBKeyData&amp; key, const ThreadSafeDataBuffer&amp; value, int64_t recordID)
1663 {
1664     JSLockHolder locker(m_serializationContext-&gt;vm());
1665 
1666     auto jsValue = deserializeIDBValueToJSValue(m_serializationContext-&gt;execState(), value);
1667     if (jsValue.isUndefinedOrNull())
1668         return IDBError { };
1669 
1670     IndexKey indexKey;
1671     auto* objectStoreInfo = infoForObjectStore(info.objectStoreIdentifier());
1672     ASSERT(objectStoreInfo);
1673     generateIndexKeyForValue(m_serializationContext-&gt;execState(), info, jsValue, indexKey, objectStoreInfo-&gt;keyPath(), key);
1674 
1675     if (indexKey.isNull())
1676         return IDBError { };
1677 
1678     return uncheckedPutIndexKey(info, key, indexKey, recordID);
1679 }
1680 
1681 IDBError SQLiteIDBBackingStore::updateAllIndexesForAddRecord(const IDBObjectStoreInfo&amp; info, const IDBKeyData&amp; key, const ThreadSafeDataBuffer&amp; value, int64_t recordID)
1682 {
1683     JSLockHolder locker(m_serializationContext-&gt;vm());
1684 
1685     auto jsValue = deserializeIDBValueToJSValue(m_serializationContext-&gt;execState(), value);
1686     if (jsValue.isUndefinedOrNull())
1687         return IDBError { };
1688 
1689     IDBError error;
1690     bool anyRecordsSucceeded = false;
1691     for (auto&amp; index : info.indexMap().values()) {
1692         IndexKey indexKey;
1693         generateIndexKeyForValue(m_serializationContext-&gt;execState(), index, jsValue, indexKey, info.keyPath(), key);
1694 
1695         if (indexKey.isNull())
1696             continue;
1697 
1698         error = uncheckedPutIndexKey(index, key, indexKey, recordID);
1699         if (!error.isNull())
1700             break;
1701 
1702         anyRecordsSucceeded = true;
1703     }
1704 
1705     if (!error.isNull() &amp;&amp; anyRecordsSucceeded) {
1706         RefPtr&lt;SharedBuffer&gt; keyBuffer = serializeIDBKeyData(key);
1707 
1708         auto* sql = cachedStatement(SQL::DeleteObjectStoreIndexRecord, &quot;DELETE FROM IndexRecords WHERE objectStoreID = ? AND value = CAST(? AS TEXT);&quot;_s);
1709 
1710         if (!sql
1711             || sql-&gt;bindInt64(1, info.identifier()) != SQLITE_OK
1712             || sql-&gt;bindBlob(2, keyBuffer-&gt;data(), keyBuffer-&gt;size()) != SQLITE_OK
1713             || sql-&gt;step() != SQLITE_DONE) {
1714             LOG_ERROR(&quot;Adding one Index record failed, but failed to remove all others that previously succeeded&quot;);
1715             return IDBError { UnknownError, &quot;Adding one Index record failed, but failed to remove all others that previously succeeded&quot;_s };
1716         }
1717     }
1718 
1719     return error;
1720 }
1721 
1722 IDBError SQLiteIDBBackingStore::addRecord(const IDBResourceIdentifier&amp; transactionIdentifier, const IDBObjectStoreInfo&amp; objectStoreInfo, const IDBKeyData&amp; keyData, const IDBValue&amp; value)
1723 {
1724     LOG(IndexedDB, &quot;SQLiteIDBBackingStore::addRecord - key %s, object store %&quot; PRIu64, keyData.loggingString().utf8().data(), objectStoreInfo.identifier());
1725 
1726     ASSERT(m_sqliteDB);
1727     ASSERT(m_sqliteDB-&gt;isOpen());
1728     ASSERT(value.data().data());
1729     ASSERT(value.blobURLs().size() == value.blobFilePaths().size());
1730 
1731     auto* transaction = m_transactions.get(transactionIdentifier);
1732     if (!transaction || !transaction-&gt;inProgress())
1733         return IDBError { UnknownError, &quot;Attempt to store a record in an object store without an in-progress transaction&quot;_s };
1734 
1735     if (transaction-&gt;mode() == IDBTransactionMode::Readonly) {
1736         LOG_ERROR(&quot;Attempt to store a record in an object store in a read-only transaction&quot;);
1737         return IDBError { UnknownError, &quot;Attempt to store a record in an object store in a read-only transaction&quot;_s };
1738     }
1739 
1740     RefPtr&lt;SharedBuffer&gt; keyBuffer = serializeIDBKeyData(keyData);
1741     if (!keyBuffer) {
1742         LOG_ERROR(&quot;Unable to serialize IDBKey to be stored in an object store&quot;);
1743         return IDBError { UnknownError, &quot;Unable to serialize IDBKey to be stored in an object store&quot;_s };
1744     }
1745 
1746     int64_t recordID = 0;
1747     {
1748         auto* sql = cachedStatement(SQL::AddObjectStoreRecord, &quot;INSERT INTO Records VALUES (?, CAST(? AS TEXT), ?, NULL);&quot;_s);
1749         if (!sql
1750             || sql-&gt;bindInt64(1, objectStoreInfo.identifier()) != SQLITE_OK
1751             || sql-&gt;bindBlob(2, keyBuffer-&gt;data(), keyBuffer-&gt;size()) != SQLITE_OK
1752             || sql-&gt;bindBlob(3, value.data().data()-&gt;data(), value.data().data()-&gt;size()) != SQLITE_OK
1753             || sql-&gt;step() != SQLITE_DONE) {
1754             LOG_ERROR(&quot;Could not put record for object store %&quot; PRIi64 &quot; in Records table (%i) - %s&quot;, objectStoreInfo.identifier(), m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
1755             return IDBError { UnknownError, &quot;Unable to store record in object store&quot;_s };
1756         }
1757 
1758         recordID = m_sqliteDB-&gt;lastInsertRowID();
1759     }
1760 
1761     auto error = updateAllIndexesForAddRecord(objectStoreInfo, keyData, value.data(), recordID);
1762 
1763     if (!error.isNull()) {
1764         auto* sql = cachedStatement(SQL::DeleteObjectStoreRecord, &quot;DELETE FROM Records WHERE objectStoreID = ? AND key = CAST(? AS TEXT);&quot;_s);
1765         if (!sql
1766             || sql-&gt;bindInt64(1, objectStoreInfo.identifier()) != SQLITE_OK
1767             || sql-&gt;bindBlob(2, keyBuffer-&gt;data(), keyBuffer-&gt;size()) != SQLITE_OK
1768             || sql-&gt;step() != SQLITE_DONE) {
1769             LOG_ERROR(&quot;Indexing new object store record failed, but unable to remove the object store record itself&quot;);
1770             return IDBError { UnknownError, &quot;Indexing new object store record failed, but unable to remove the object store record itself&quot;_s };
1771         }
1772 
1773         return error;
1774     }
1775 
1776     const Vector&lt;String&gt;&amp; blobURLs = value.blobURLs();
1777     const Vector&lt;String&gt;&amp; blobFiles = value.blobFilePaths();
1778     for (size_t i = 0; i &lt; blobURLs.size(); ++i) {
1779         auto&amp; url = blobURLs[i];
1780         {
1781             auto* sql = cachedStatement(SQL::AddBlobRecord, &quot;INSERT INTO BlobRecords VALUES (?, ?);&quot;_s);
1782             if (!sql
1783                 || sql-&gt;bindInt64(1, recordID) != SQLITE_OK
1784                 || sql-&gt;bindText(2, url) != SQLITE_OK
1785                 || sql-&gt;step() != SQLITE_DONE) {
1786                 LOG_ERROR(&quot;Unable to record Blob record in database&quot;);
1787                 return IDBError { UnknownError, &quot;Unable to record Blob record in database&quot;_s };
1788             }
1789         }
1790         int64_t potentialFileNameInteger = m_sqliteDB-&gt;lastInsertRowID();
1791 
1792         // If we already have a file for this blobURL, nothing left to do.
1793         {
1794             auto* sql = cachedStatement(SQL::BlobFilenameForBlobURL, &quot;SELECT fileName FROM BlobFiles WHERE blobURL = ?;&quot;_s);
1795             if (!sql
1796                 || sql-&gt;bindText(1, url) != SQLITE_OK) {
1797                 LOG_ERROR(&quot;Unable to examine Blob filenames in database&quot;);
1798                 return IDBError { UnknownError, &quot;Unable to examine Blob filenames in database&quot;_s };
1799             }
1800 
1801             int result = sql-&gt;step();
1802             if (result != SQLITE_ROW &amp;&amp; result != SQLITE_DONE) {
1803                 LOG_ERROR(&quot;Unable to examine Blob filenames in database&quot;);
1804                 return IDBError { UnknownError, &quot;Unable to examine Blob filenames in database&quot;_s };
1805             }
1806 
1807             if (result == SQLITE_ROW)
1808                 continue;
1809         }
1810 
1811         // We don&#39;t already have a file for this blobURL, so commit our file as a unique filename
1812         String storedFilename = makeString(potentialFileNameInteger, &quot;.blob&quot;);
1813         {
1814             auto* sql = cachedStatement(SQL::AddBlobFilename, &quot;INSERT INTO BlobFiles VALUES (?, ?);&quot;_s);
1815             if (!sql
1816                 || sql-&gt;bindText(1, url) != SQLITE_OK
1817                 || sql-&gt;bindText(2, storedFilename) != SQLITE_OK
1818                 || sql-&gt;step() != SQLITE_DONE) {
1819                 LOG_ERROR(&quot;Unable to record Blob file record in database&quot;);
1820                 return IDBError { UnknownError, &quot;Unable to record Blob file record in database&quot;_s };
1821             }
1822         }
1823 
1824         transaction-&gt;addBlobFile(blobFiles[i], storedFilename);
1825     }
1826 
1827     transaction-&gt;notifyCursorsOfChanges(objectStoreInfo.identifier());
1828 
1829     return error;
1830 }
1831 
1832 IDBError SQLiteIDBBackingStore::getBlobRecordsForObjectStoreRecord(int64_t objectStoreRecord, Vector&lt;String&gt;&amp; blobURLs, Vector&lt;String&gt;&amp; blobFilePaths)
1833 {
1834     ASSERT(objectStoreRecord);
1835 
1836     HashSet&lt;String&gt; blobURLSet;
1837     {
1838         auto* sql = cachedStatement(SQL::GetBlobURL, &quot;SELECT blobURL FROM BlobRecords WHERE objectStoreRow = ?&quot;_s);
1839         if (!sql
1840             || sql-&gt;bindInt64(1, objectStoreRecord) != SQLITE_OK) {
1841             LOG_ERROR(&quot;Could not prepare statement to fetch blob URLs for object store record (%i) - %s&quot;, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
1842             return IDBError { UnknownError, &quot;Failed to look up blobURL records in object store by key range&quot;_s };
1843         }
1844 
1845         int sqlResult = sql-&gt;step();
1846         if (sqlResult == SQLITE_OK || sqlResult == SQLITE_DONE) {
1847             // There are no blobURLs in the database for this object store record.
1848             return IDBError { };
1849         }
1850 
1851         while (sqlResult == SQLITE_ROW) {
1852             blobURLSet.add(sql-&gt;getColumnText(0));
1853             sqlResult = sql-&gt;step();
1854         }
1855 
1856         if (sqlResult != SQLITE_DONE) {
1857             LOG_ERROR(&quot;Could not fetch blob URLs for object store record (%i) - %s&quot;, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
1858             return IDBError { UnknownError, &quot;Failed to look up blobURL records in object store by key range&quot;_s };
1859         }
1860     }
1861 
1862     ASSERT(!blobURLSet.isEmpty());
1863     for (auto&amp; blobURL : blobURLSet) {
1864         auto* sql = cachedStatement(SQL::BlobFilenameForBlobURL, &quot;SELECT fileName FROM BlobFiles WHERE blobURL = ?;&quot;_s);
1865         if (!sql
1866             || sql-&gt;bindText(1, blobURL) != SQLITE_OK) {
1867             LOG_ERROR(&quot;Could not prepare statement to fetch blob filename for object store record (%i) - %s&quot;, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
1868             return IDBError { UnknownError, &quot;Failed to look up blobURL records in object store by key range&quot;_s };
1869         }
1870 
1871         if (sql-&gt;step() != SQLITE_ROW) {
1872             LOG_ERROR(&quot;Entry for blob filename for blob url %s does not exist (%i) - %s&quot;, blobURL.utf8().data(), m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
1873             return IDBError { UnknownError, &quot;Failed to look up blobURL records in object store by key range&quot;_s };
1874         }
1875 
1876         blobURLs.append(blobURL);
1877 
1878         String fileName = sql-&gt;getColumnText(0);
1879         blobFilePaths.append(FileSystem::pathByAppendingComponent(m_databaseDirectory, fileName));
1880     }
1881     return IDBError { };
1882 }
1883 
1884 IDBError SQLiteIDBBackingStore::getRecord(const IDBResourceIdentifier&amp; transactionIdentifier, uint64_t objectStoreID, const IDBKeyRangeData&amp; keyRange, IDBGetRecordDataType type, IDBGetResult&amp; resultValue)
1885 {
1886     LOG(IndexedDB, &quot;SQLiteIDBBackingStore::getRecord - key range %s, object store %&quot; PRIu64, keyRange.loggingString().utf8().data(), objectStoreID);
1887 
1888     ASSERT(m_sqliteDB);
1889     ASSERT(m_sqliteDB-&gt;isOpen());
1890 
1891     auto* transaction = m_transactions.get(transactionIdentifier);
1892     if (!transaction || !transaction-&gt;inProgress())
1893         return IDBError { UnknownError, &quot;Attempt to get a record from database without an in-progress transaction&quot;_s };
1894 
1895     auto key = keyRange.lowerKey;
1896     if (key.isNull())
1897         key = IDBKeyData::minimum();
1898     RefPtr&lt;SharedBuffer&gt; lowerBuffer = serializeIDBKeyData(key);
1899     if (!lowerBuffer) {
1900         LOG_ERROR(&quot;Unable to serialize lower IDBKey in lookup range&quot;);
1901         return IDBError { UnknownError, &quot;Unable to serialize lower IDBKey in lookup range&quot;_s };
1902     }
1903 
1904     key = keyRange.upperKey;
1905     if (key.isNull())
1906         key = IDBKeyData::maximum();
1907     RefPtr&lt;SharedBuffer&gt; upperBuffer = serializeIDBKeyData(key);
1908     if (!upperBuffer) {
1909         LOG_ERROR(&quot;Unable to serialize upper IDBKey in lookup range&quot;);
1910         return IDBError { UnknownError, &quot;Unable to serialize upper IDBKey in lookup range&quot;_s };
1911     }
1912 
1913     int64_t recordID = 0;
1914     ThreadSafeDataBuffer keyResultBuffer, valueResultBuffer;
1915     {
1916         static const char* const lowerOpenUpperOpen = &quot;SELECT key, value, ROWID FROM Records WHERE objectStoreID = ? AND key &gt; CAST(? AS TEXT) AND key &lt; CAST(? AS TEXT) ORDER BY key;&quot;;
1917         static const char* const lowerOpenUpperClosed = &quot;SELECT key, value, ROWID FROM Records WHERE objectStoreID = ? AND key &gt; CAST(? AS TEXT) AND key &lt;= CAST(? AS TEXT) ORDER BY key;&quot;;
1918         static const char* const lowerClosedUpperOpen = &quot;SELECT key, value, ROWID FROM Records WHERE objectStoreID = ? AND key &gt;= CAST(? AS TEXT) AND key &lt; CAST(? AS TEXT) ORDER BY key;&quot;;
1919         static const char* const lowerClosedUpperClosed = &quot;SELECT key, value, ROWID FROM Records WHERE objectStoreID = ? AND key &gt;= CAST(? AS TEXT) AND key &lt;= CAST(? AS TEXT) ORDER BY key;&quot;;
1920 
1921         static const char* const lowerOpenUpperOpenKeyOnly = &quot;SELECT key FROM Records WHERE objectStoreID = ? AND key &gt; CAST(? AS TEXT) AND key &lt; CAST(? AS TEXT) ORDER BY key;&quot;;
1922         static const char* const lowerOpenUpperClosedKeyOnly = &quot;SELECT key FROM Records WHERE objectStoreID = ? AND key &gt; CAST(? AS TEXT) AND key &lt;= CAST(? AS TEXT) ORDER BY key;&quot;;
1923         static const char* const lowerClosedUpperOpenKeyOnly = &quot;SELECT key FROM Records WHERE objectStoreID = ? AND key &gt;= CAST(? AS TEXT) AND key &lt; CAST(? AS TEXT) ORDER BY key;&quot;;
1924         static const char* const lowerClosedUpperClosedKeyOnly = &quot;SELECT key FROM Records WHERE objectStoreID = ? AND key &gt;= CAST(? AS TEXT) AND key &lt;= CAST(? AS TEXT) ORDER BY key;&quot;;
1925 
1926         SQLiteStatement* sql = nullptr;
1927 
1928         switch (type) {
1929         case IDBGetRecordDataType::KeyAndValue:
1930             if (keyRange.lowerOpen) {
1931                 if (keyRange.upperOpen)
1932                     sql = cachedStatement(SQL::GetValueRecordsLowerOpenUpperOpen, lowerOpenUpperOpen);
1933                 else
1934                     sql = cachedStatement(SQL::GetValueRecordsLowerOpenUpperClosed, lowerOpenUpperClosed);
1935             } else {
1936                 if (keyRange.upperOpen)
1937                     sql = cachedStatement(SQL::GetValueRecordsLowerClosedUpperOpen, lowerClosedUpperOpen);
1938                 else
1939                     sql = cachedStatement(SQL::GetValueRecordsLowerClosedUpperClosed, lowerClosedUpperClosed);
1940             }
1941             break;
1942         case IDBGetRecordDataType::KeyOnly:
1943             if (keyRange.lowerOpen) {
1944                 if (keyRange.upperOpen)
1945                     sql = cachedStatement(SQL::GetKeyRecordsLowerOpenUpperOpen, lowerOpenUpperOpenKeyOnly);
1946                 else
1947                     sql = cachedStatement(SQL::GetKeyRecordsLowerOpenUpperClosed, lowerOpenUpperClosedKeyOnly);
1948             } else {
1949                 if (keyRange.upperOpen)
1950                     sql = cachedStatement(SQL::GetKeyRecordsLowerClosedUpperOpen, lowerClosedUpperOpenKeyOnly);
1951                 else
1952                     sql = cachedStatement(SQL::GetKeyRecordsLowerClosedUpperClosed, lowerClosedUpperClosedKeyOnly);
1953             }
1954         }
1955 
1956         if (!sql
1957             || sql-&gt;bindInt64(1, objectStoreID) != SQLITE_OK
1958             || sql-&gt;bindBlob(2, lowerBuffer-&gt;data(), lowerBuffer-&gt;size()) != SQLITE_OK
1959             || sql-&gt;bindBlob(3, upperBuffer-&gt;data(), upperBuffer-&gt;size()) != SQLITE_OK) {
1960             LOG_ERROR(&quot;Could not get key range record from object store %&quot; PRIi64 &quot; from Records table (%i) - %s&quot;, objectStoreID, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
1961             return IDBError { UnknownError, &quot;Failed to look up record in object store by key range&quot;_s };
1962         }
1963 
1964         int sqlResult = sql-&gt;step();
1965 
1966         if (sqlResult == SQLITE_OK || sqlResult == SQLITE_DONE) {
1967             // There was no record for the key in the database.
1968             return IDBError { };
1969         }
1970         if (sqlResult != SQLITE_ROW) {
1971             // There was an error fetching the record from the database.
1972             LOG_ERROR(&quot;Could not get record from object store %&quot; PRIi64 &quot; from Records table (%i) - %s&quot;, objectStoreID, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
1973             return IDBError { UnknownError, &quot;Error looking up record in object store by key range&quot;_s };
1974         }
1975 
1976         Vector&lt;uint8_t&gt; keyBuffer;
1977         sql-&gt;getColumnBlobAsVector(0, keyBuffer);
1978         keyResultBuffer = ThreadSafeDataBuffer::create(WTFMove(keyBuffer));
1979 
1980         if (type == IDBGetRecordDataType::KeyAndValue) {
1981             Vector&lt;uint8_t&gt; valueBuffer;
1982             sql-&gt;getColumnBlobAsVector(1, valueBuffer);
1983             valueResultBuffer = ThreadSafeDataBuffer::create(WTFMove(valueBuffer));
1984             recordID = sql-&gt;getColumnInt64(2);
1985         }
1986     }
1987 
1988     auto* keyVector = keyResultBuffer.data();
1989     if (!keyVector) {
1990         LOG_ERROR(&quot;Unable to deserialize key data from database for IDBObjectStore&quot;);
1991         return IDBError { UnknownError, &quot;Error extracting key data from database executing IDBObjectStore get&quot;_s };
1992     }
1993 
1994     IDBKeyData keyData;
1995     if (!deserializeIDBKeyData(keyVector-&gt;data(), keyVector-&gt;size(), keyData)) {
1996         LOG_ERROR(&quot;Unable to deserialize key data from database for IDBObjectStore&quot;);
1997         return IDBError { UnknownError, &quot;Error extracting key data from database executing IDBObjectStore get&quot;_s };
1998     }
1999 
2000     if (type == IDBGetRecordDataType::KeyOnly) {
2001         resultValue = { keyData };
2002         return IDBError { };
2003     }
2004 
2005     ASSERT(recordID);
2006     Vector&lt;String&gt; blobURLs, blobFilePaths;
2007     auto error = getBlobRecordsForObjectStoreRecord(recordID, blobURLs, blobFilePaths);
2008     ASSERT(blobURLs.size() == blobFilePaths.size());
2009 
2010     if (!error.isNull())
2011         return error;
2012 
2013     auto* objectStoreInfo = infoForObjectStore(objectStoreID);
2014     ASSERT(objectStoreInfo);
2015     resultValue = { keyData, { valueResultBuffer, WTFMove(blobURLs), WTFMove(blobFilePaths) }, objectStoreInfo-&gt;keyPath()};
2016     return IDBError { };
2017 }
2018 
2019 IDBError SQLiteIDBBackingStore::getAllRecords(const IDBResourceIdentifier&amp; transactionIdentifier, const IDBGetAllRecordsData&amp; getAllRecordsData, IDBGetAllResult&amp; result)
2020 {
2021     return getAllRecordsData.indexIdentifier ? getAllIndexRecords(transactionIdentifier, getAllRecordsData, result) : getAllObjectStoreRecords(transactionIdentifier, getAllRecordsData, result);
2022 }
2023 
2024 SQLiteStatement* SQLiteIDBBackingStore::cachedStatementForGetAllObjectStoreRecords(const IDBGetAllRecordsData&amp; getAllRecordsData)
2025 {
2026     static const char* const lowerOpenUpperOpenKey =&quot;SELECT key FROM Records WHERE objectStoreID = ? AND key &gt; CAST(? AS TEXT) AND key &lt; CAST(? AS TEXT) ORDER BY key;&quot;;
2027     static const char* const lowerOpenUpperClosedKey = &quot;SELECT key FROM Records WHERE objectStoreID = ? AND key &gt; CAST(? AS TEXT) AND key &lt;= CAST(? AS TEXT) ORDER BY key;&quot;;
2028     static const char* const lowerClosedUpperOpenKey = &quot;SELECT key FROM Records WHERE objectStoreID = ? AND key &gt;= CAST(? AS TEXT) AND key &lt; CAST(? AS TEXT) ORDER BY key;&quot;;
2029     static const char* const lowerClosedUpperClosedKey = &quot;SELECT key FROM Records WHERE objectStoreID = ? AND key &gt;= CAST(? AS TEXT) AND key &lt;= CAST(? AS TEXT) ORDER BY key;&quot;;
2030     static const char* const lowerOpenUpperOpenValue = &quot;SELECT key, value, ROWID FROM Records WHERE objectStoreID = ? AND key &gt; CAST(? AS TEXT) AND key &lt; CAST(? AS TEXT) ORDER BY key;&quot;;
2031     static const char* const lowerOpenUpperClosedValue = &quot;SELECT key, value, ROWID FROM Records WHERE objectStoreID = ? AND key &gt; CAST(? AS TEXT) AND key &lt;= CAST(? AS TEXT) ORDER BY key;&quot;;
2032     static const char* const lowerClosedUpperOpenValue = &quot;SELECT key, value, ROWID FROM Records WHERE objectStoreID = ? AND key &gt;= CAST(? AS TEXT) AND key &lt; CAST(? AS TEXT) ORDER BY key;&quot;;
2033     static const char* const lowerClosedUpperClosedValue = &quot;SELECT key, value, ROWID FROM Records WHERE objectStoreID = ? AND key &gt;= CAST(? AS TEXT) AND key &lt;= CAST(? AS TEXT) ORDER BY key;&quot;;
2034 
2035     if (getAllRecordsData.getAllType == IndexedDB::GetAllType::Keys) {
2036         if (getAllRecordsData.keyRangeData.lowerOpen) {
2037             if (getAllRecordsData.keyRangeData.upperOpen)
2038                 return cachedStatement(SQL::GetAllKeyRecordsLowerOpenUpperOpen, lowerOpenUpperOpenKey);
2039             return cachedStatement(SQL::GetAllKeyRecordsLowerOpenUpperClosed, lowerOpenUpperClosedKey);
2040         }
2041 
2042         if (getAllRecordsData.keyRangeData.upperOpen)
2043             return cachedStatement(SQL::GetAllKeyRecordsLowerClosedUpperOpen, lowerClosedUpperOpenKey);
2044         return cachedStatement(SQL::GetAllKeyRecordsLowerClosedUpperClosed, lowerClosedUpperClosedKey);
2045     }
2046 
2047     if (getAllRecordsData.keyRangeData.lowerOpen) {
2048         if (getAllRecordsData.keyRangeData.upperOpen)
2049             return cachedStatement(SQL::GetValueRecordsLowerOpenUpperOpen, lowerOpenUpperOpenValue);
2050         return cachedStatement(SQL::GetValueRecordsLowerOpenUpperClosed, lowerOpenUpperClosedValue);
2051     }
2052 
2053     if (getAllRecordsData.keyRangeData.upperOpen)
2054         return cachedStatement(SQL::GetValueRecordsLowerClosedUpperOpen, lowerClosedUpperOpenValue);
2055     return cachedStatement(SQL::GetValueRecordsLowerClosedUpperClosed, lowerClosedUpperClosedValue);
2056 }
2057 
2058 IDBError SQLiteIDBBackingStore::getAllObjectStoreRecords(const IDBResourceIdentifier&amp; transactionIdentifier, const IDBGetAllRecordsData&amp; getAllRecordsData, IDBGetAllResult&amp; result)
2059 {
2060     LOG(IndexedDB, &quot;SQLiteIDBBackingStore::getAllObjectStoreRecords&quot;);
2061 
2062     ASSERT(m_sqliteDB);
2063     ASSERT(m_sqliteDB-&gt;isOpen());
2064 
2065     auto* transaction = m_transactions.get(transactionIdentifier);
2066     if (!transaction || !transaction-&gt;inProgress())
2067         return IDBError { UnknownError, &quot;Attempt to get records from database without an in-progress transaction&quot;_s };
2068 
2069     auto key = getAllRecordsData.keyRangeData.lowerKey;
2070     if (key.isNull())
2071         key = IDBKeyData::minimum();
2072     auto lowerBuffer = serializeIDBKeyData(key);
2073     if (!lowerBuffer) {
2074         LOG_ERROR(&quot;Unable to serialize lower IDBKey in lookup range&quot;);
2075         return IDBError { UnknownError, &quot;Unable to serialize lower IDBKey in lookup range&quot;_s };
2076     }
2077 
2078     key = getAllRecordsData.keyRangeData.upperKey;
2079     if (key.isNull())
2080         key = IDBKeyData::maximum();
2081     auto upperBuffer = serializeIDBKeyData(key);
2082     if (!upperBuffer) {
2083         LOG_ERROR(&quot;Unable to serialize upper IDBKey in lookup range&quot;);
2084         return IDBError { UnknownError, &quot;Unable to serialize upper IDBKey in lookup range&quot;_s };
2085     }
2086 
2087     auto* sql = cachedStatementForGetAllObjectStoreRecords(getAllRecordsData);
2088     if (!sql
2089         || sql-&gt;bindInt64(1, getAllRecordsData.objectStoreIdentifier) != SQLITE_OK
2090         || sql-&gt;bindBlob(2, lowerBuffer-&gt;data(), lowerBuffer-&gt;size()) != SQLITE_OK
2091         || sql-&gt;bindBlob(3, upperBuffer-&gt;data(), upperBuffer-&gt;size()) != SQLITE_OK) {
2092         LOG_ERROR(&quot;Could not get key range record from object store %&quot; PRIi64 &quot; from Records table (%i) - %s&quot;, getAllRecordsData.objectStoreIdentifier, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
2093         return IDBError { UnknownError, &quot;Failed to look up record in object store by key range&quot;_s };
2094     }
2095 
2096     auto* objectStoreInfo = infoForObjectStore(getAllRecordsData.objectStoreIdentifier);
2097     ASSERT(objectStoreInfo);
2098     result = { getAllRecordsData.getAllType, objectStoreInfo-&gt;keyPath() };
2099 
2100     uint32_t targetResults;
2101     if (getAllRecordsData.count &amp;&amp; getAllRecordsData.count.value())
2102         targetResults = getAllRecordsData.count.value();
2103     else
2104         targetResults = std::numeric_limits&lt;uint32_t&gt;::max();
2105 
2106     int sqlResult = sql-&gt;step();
2107     uint32_t returnedResults = 0;
2108 
2109     while (sqlResult == SQLITE_ROW &amp;&amp; returnedResults &lt; targetResults) {
2110         Vector&lt;uint8_t&gt; keyBuffer;
2111         IDBKeyData keyData;
2112         sql-&gt;getColumnBlobAsVector(0, keyBuffer);
2113         if (!deserializeIDBKeyData(keyBuffer.data(), keyBuffer.size(), keyData)) {
2114             LOG_ERROR(&quot;Unable to deserialize key data from database while getting all records&quot;);
2115             return IDBError { UnknownError, &quot;Unable to deserialize key data while getting all records&quot;_s };
2116         }
2117         result.addKey(WTFMove(keyData));
2118 
2119         if (getAllRecordsData.getAllType == IndexedDB::GetAllType::Values) {
2120             Vector&lt;uint8_t&gt; valueBuffer;
2121             sql-&gt;getColumnBlobAsVector(1, valueBuffer);
2122             ThreadSafeDataBuffer valueResultBuffer = ThreadSafeDataBuffer::create(WTFMove(valueBuffer));
2123 
2124             auto recordID = sql-&gt;getColumnInt64(2);
2125 
2126             ASSERT(recordID);
2127             Vector&lt;String&gt; blobURLs, blobFilePaths;
2128             auto error = getBlobRecordsForObjectStoreRecord(recordID, blobURLs, blobFilePaths);
2129             ASSERT(blobURLs.size() == blobFilePaths.size());
2130 
2131             if (!error.isNull())
2132                 return error;
2133 
2134             result.addValue({ valueResultBuffer, WTFMove(blobURLs), WTFMove(blobFilePaths) });
2135         }
2136 
2137         ++returnedResults;
2138         sqlResult = sql-&gt;step();
2139     }
2140 
2141     if (sqlResult == SQLITE_OK || sqlResult == SQLITE_DONE || sqlResult == SQLITE_ROW) {
2142         // Finished getting results
2143         return IDBError { };
2144     }
2145 
2146     // There was an error fetching records from the database.
2147     LOG_ERROR(&quot;Could not get record from object store %&quot; PRIi64 &quot; from Records table (%i) - %s&quot;, getAllRecordsData.objectStoreIdentifier, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
2148     return IDBError { UnknownError, &quot;Error looking up record in object store by key range&quot;_s };
2149 }
2150 
2151 IDBError SQLiteIDBBackingStore::getAllIndexRecords(const IDBResourceIdentifier&amp; transactionIdentifier, const IDBGetAllRecordsData&amp; getAllRecordsData, IDBGetAllResult&amp; result)
2152 {
2153     LOG(IndexedDB, &quot;SQLiteIDBBackingStore::getAllIndexRecords - %s&quot;, getAllRecordsData.keyRangeData.loggingString().utf8().data());
2154 
2155     ASSERT(m_sqliteDB);
2156     ASSERT(m_sqliteDB-&gt;isOpen());
2157 
2158     auto* transaction = m_transactions.get(transactionIdentifier);
2159     if (!transaction || !transaction-&gt;inProgress())
2160         return IDBError { UnknownError, &quot;Attempt to get all index records from database without an in-progress transaction&quot;_s };
2161 
2162     auto cursor = transaction-&gt;maybeOpenBackingStoreCursor(getAllRecordsData.objectStoreIdentifier, getAllRecordsData.indexIdentifier, getAllRecordsData.keyRangeData);
2163     if (!cursor) {
2164         LOG_ERROR(&quot;Cannot open cursor to perform index gets in database&quot;);
2165         return IDBError { UnknownError, &quot;Cannot open cursor to perform index gets in database&quot;_s };
2166     }
2167 
2168     if (cursor-&gt;didError()) {
2169         LOG_ERROR(&quot;Cursor failed while looking up index records in database&quot;);
2170         return IDBError { UnknownError, &quot;Cursor failed while looking up index records in database&quot;_s };
2171     }
2172 
2173     auto* objectStoreInfo = infoForObjectStore(getAllRecordsData.objectStoreIdentifier);
2174     ASSERT(objectStoreInfo);
2175     result = { getAllRecordsData.getAllType, objectStoreInfo-&gt;keyPath() };
2176 
2177     uint32_t currentCount = 0;
2178     uint32_t targetCount = getAllRecordsData.count ? getAllRecordsData.count.value() : 0;
2179     if (!targetCount)
2180         targetCount = std::numeric_limits&lt;uint32_t&gt;::max();
2181     while (!cursor-&gt;didComplete() &amp;&amp; !cursor-&gt;didError() &amp;&amp; currentCount &lt; targetCount) {
2182         IDBKeyData keyCopy = cursor-&gt;currentPrimaryKey();
2183         result.addKey(WTFMove(keyCopy));
2184         if (getAllRecordsData.getAllType == IndexedDB::GetAllType::Values)
2185             result.addValue(cursor-&gt;currentValue() ? *cursor-&gt;currentValue() : IDBValue());
2186 
2187         ++currentCount;
2188         cursor-&gt;advance(1);
2189     }
2190 
2191     if (cursor-&gt;didError()) {
2192         LOG_ERROR(&quot;Cursor failed while looking up index records in database&quot;);
2193         return IDBError { UnknownError, &quot;Cursor failed while looking up index records in database&quot;_s };
2194     }
2195 
2196     return IDBError { };
2197 }
2198 
2199 IDBError SQLiteIDBBackingStore::getIndexRecord(const IDBResourceIdentifier&amp; transactionIdentifier, uint64_t objectStoreID, uint64_t indexID, IndexedDB::IndexRecordType type, const IDBKeyRangeData&amp; range, IDBGetResult&amp; getResult)
2200 {
2201     LOG(IndexedDB, &quot;SQLiteIDBBackingStore::getIndexRecord - %s&quot;, range.loggingString().utf8().data());
2202 
2203     ASSERT(m_sqliteDB);
2204     ASSERT(m_sqliteDB-&gt;isOpen());
2205 
2206     auto* transaction = m_transactions.get(transactionIdentifier);
2207     if (!transaction || !transaction-&gt;inProgress())
2208         return IDBError { UnknownError, &quot;Attempt to get an index record from database without an in-progress transaction&quot;_s };
2209 
2210     if (range.isExactlyOneKey())
2211         return uncheckedGetIndexRecordForOneKey(indexID, objectStoreID, type, range.lowerKey, getResult);
2212 
2213     auto cursor = transaction-&gt;maybeOpenBackingStoreCursor(objectStoreID, indexID, range);
2214     if (!cursor) {
2215         LOG_ERROR(&quot;Cannot open cursor to perform index get in database&quot;);
2216         return IDBError { UnknownError, &quot;Cannot open cursor to perform index get in database&quot;_s };
2217     }
2218 
2219     if (cursor-&gt;didError()) {
2220         LOG_ERROR(&quot;Cursor failed while looking up index record in database&quot;);
2221         return IDBError { UnknownError, &quot;Cursor failed while looking up index record in database&quot;_s };
2222     }
2223 
2224     if (cursor-&gt;didComplete())
2225         getResult = { };
2226     else {
2227         if (type == IndexedDB::IndexRecordType::Key)
2228             getResult = { cursor-&gt;currentPrimaryKey() };
2229         else {
2230             auto* objectStoreInfo = infoForObjectStore(objectStoreID);
2231             ASSERT(objectStoreInfo);
2232             getResult = { cursor-&gt;currentPrimaryKey(), cursor-&gt;currentPrimaryKey(), cursor-&gt;currentValue() ? *cursor-&gt;currentValue() : IDBValue(), objectStoreInfo-&gt;keyPath() };
2233         }
2234     }
2235 
2236     return IDBError { };
2237 }
2238 
2239 IDBError SQLiteIDBBackingStore::uncheckedGetIndexRecordForOneKey(int64_t indexID, int64_t objectStoreID, IndexedDB::IndexRecordType type, const IDBKeyData&amp; key, IDBGetResult&amp; getResult)
2240 {
2241     LOG(IndexedDB, &quot;SQLiteIDBBackingStore::uncheckedGetIndexRecordForOneKey&quot;);
2242 
2243     ASSERT(key.isValid() &amp;&amp; key.type() != IndexedDB::KeyType::Max &amp;&amp; key.type() != IndexedDB::KeyType::Min);
2244 
2245     RefPtr&lt;SharedBuffer&gt; buffer = serializeIDBKeyData(key);
2246     if (!buffer) {
2247         LOG_ERROR(&quot;Unable to serialize IDBKey to look up one index record&quot;);
2248         return IDBError { UnknownError, &quot;Unable to serialize IDBKey to look up one index record&quot;_s };
2249     }
2250 
2251     auto* sql = cachedStatement(SQL::GetIndexRecordForOneKey, &quot;SELECT IndexRecords.value, Records.value, Records.recordID FROM Records INNER JOIN IndexRecords ON Records.recordID = IndexRecords.objectStoreRecordID WHERE IndexRecords.indexID = ? AND IndexRecords.objectStoreID = ? AND IndexRecords.key = CAST(? AS TEXT) ORDER BY IndexRecords.key, IndexRecords.value&quot;_s);
2252 
2253     if (!sql
2254         || sql-&gt;bindInt64(1, indexID) != SQLITE_OK
2255         || sql-&gt;bindInt64(2, objectStoreID) != SQLITE_OK
2256         || sql-&gt;bindBlob(3, buffer-&gt;data(), buffer-&gt;size()) != SQLITE_OK) {
2257         LOG_ERROR(&quot;Unable to lookup index record in database&quot;);
2258         return IDBError { UnknownError, &quot;Unable to lookup index record in database&quot;_s };
2259     }
2260 
2261     int result = sql-&gt;step();
2262     if (result != SQLITE_ROW &amp;&amp; result != SQLITE_DONE) {
2263         LOG_ERROR(&quot;Unable to lookup index record in database&quot;);
2264         return IDBError { UnknownError, &quot;Unable to lookup index record in database&quot;_s };
2265     }
2266 
2267     if (result == SQLITE_DONE)
2268         return IDBError { };
2269 
2270     IDBKeyData objectStoreKey;
2271     Vector&lt;uint8_t&gt; keyVector;
2272     sql-&gt;getColumnBlobAsVector(0, keyVector);
2273 
2274     if (!deserializeIDBKeyData(keyVector.data(), keyVector.size(), objectStoreKey)) {
2275         LOG_ERROR(&quot;Unable to deserialize key looking up index record in database&quot;);
2276         return IDBError { UnknownError, &quot;Unable to deserialize key looking up index record in database&quot;_s };
2277     }
2278 
2279     if (type == IndexedDB::IndexRecordType::Key) {
2280         getResult = { objectStoreKey };
2281         return IDBError { };
2282     }
2283 
2284     Vector&lt;uint8_t&gt; valueVector;
2285     sql-&gt;getColumnBlobAsVector(1, valueVector);
2286 
2287     int64_t recordID = sql-&gt;getColumnInt64(2);
2288     Vector&lt;String&gt; blobURLs, blobFilePaths;
2289     auto error = getBlobRecordsForObjectStoreRecord(recordID, blobURLs, blobFilePaths);
2290     ASSERT(blobURLs.size() == blobFilePaths.size());
2291 
2292     if (!error.isNull())
2293         return error;
2294 
2295     auto* objectStoreInfo = infoForObjectStore(objectStoreID);
2296     ASSERT(objectStoreInfo);
2297     getResult = { objectStoreKey, objectStoreKey, { ThreadSafeDataBuffer::create(WTFMove(valueVector)), WTFMove(blobURLs), WTFMove(blobFilePaths) }, objectStoreInfo-&gt;keyPath() };
2298     return IDBError { };
2299 }
2300 
2301 IDBError SQLiteIDBBackingStore::getCount(const IDBResourceIdentifier&amp; transactionIdentifier, uint64_t objectStoreIdentifier, uint64_t indexIdentifier, const IDBKeyRangeData&amp; range, uint64_t&amp; outCount)
2302 {
2303     LOG(IndexedDB, &quot;SQLiteIDBBackingStore::getCount - object store %&quot; PRIu64, objectStoreIdentifier);
2304     ASSERT(m_sqliteDB);
2305     ASSERT(m_sqliteDB-&gt;isOpen());
2306 
2307     outCount = 0;
2308 
2309     auto* transaction = m_transactions.get(transactionIdentifier);
2310     if (!transaction || !transaction-&gt;inProgress())
2311         return IDBError { UnknownError, &quot;Attempt to get count from database without an in-progress transaction&quot;_s };
2312 
2313     auto cursor = transaction-&gt;maybeOpenBackingStoreCursor(objectStoreIdentifier, indexIdentifier, range);
2314     if (!cursor) {
2315         LOG_ERROR(&quot;Cannot open cursor to populate indexes in database&quot;);
2316         return IDBError { UnknownError, &quot;Unable to populate indexes in database&quot;_s };
2317     }
2318 
2319     while (cursor-&gt;advance(1))
2320         ++outCount;
2321 
2322     return IDBError { };
2323 }
2324 
2325 IDBError SQLiteIDBBackingStore::uncheckedGetKeyGeneratorValue(int64_t objectStoreID, uint64_t&amp; outValue)
2326 {
2327     auto* sql = cachedStatement(SQL::GetKeyGeneratorValue, &quot;SELECT currentKey FROM KeyGenerators WHERE objectStoreID = ?;&quot;_s);
2328     if (!sql
2329         || sql-&gt;bindInt64(1, objectStoreID) != SQLITE_OK) {
2330         LOG_ERROR(&quot;Could not retrieve currentKey from KeyGenerators table (%i) - %s&quot;, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
2331         return IDBError { UnknownError, &quot;Error getting current key generator value from database&quot;_s };
2332     }
2333     int result = sql-&gt;step();
2334     if (result != SQLITE_ROW) {
2335         LOG_ERROR(&quot;Could not retreive key generator value for object store, but it should be there.&quot;);
2336         return IDBError { UnknownError, &quot;Error finding current key generator value in database&quot;_s };
2337     }
2338 
2339     int64_t value = sql-&gt;getColumnInt64(0);
2340     if (value &lt; 0)
2341         return IDBError { ConstraintError, &quot;Current key generator value from database is invalid&quot; };
2342 
2343     outValue = value;
2344     return IDBError { };
2345 }
2346 
2347 IDBError SQLiteIDBBackingStore::uncheckedSetKeyGeneratorValue(int64_t objectStoreID, uint64_t value)
2348 {
2349     auto* sql = cachedStatement(SQL::SetKeyGeneratorValue, &quot;INSERT INTO KeyGenerators VALUES (?, ?);&quot;_s);
2350     if (!sql
2351         || sql-&gt;bindInt64(1, objectStoreID) != SQLITE_OK
2352         || sql-&gt;bindInt64(2, value) != SQLITE_OK
2353         || sql-&gt;step() != SQLITE_DONE) {
2354         LOG_ERROR(&quot;Could not update key generator value (%i) - %s&quot;, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
2355         return IDBError { ConstraintError, &quot;Error storing new key generator value in database&quot; };
2356     }
2357 
2358     return IDBError { };
2359 }
2360 
2361 IDBError SQLiteIDBBackingStore::generateKeyNumber(const IDBResourceIdentifier&amp; transactionIdentifier, uint64_t objectStoreID, uint64_t&amp; generatedKey)
2362 {
2363     LOG(IndexedDB, &quot;SQLiteIDBBackingStore::generateKeyNumber&quot;);
2364 
2365     ASSERT(m_sqliteDB);
2366     ASSERT(m_sqliteDB-&gt;isOpen());
2367 
2368     auto* transaction = m_transactions.get(transactionIdentifier);
2369     if (!transaction || !transaction-&gt;inProgress())
2370         return IDBError { UnknownError, &quot;Attempt to generate key in database without an in-progress transaction&quot;_s };
2371 
2372     if (transaction-&gt;mode() == IDBTransactionMode::Readonly) {
2373         LOG_ERROR(&quot;Attempt to generate key in a read-only transaction&quot;);
2374         return IDBError { UnknownError, &quot;Attempt to generate key in a read-only transaction&quot;_s };
2375     }
2376 
2377     uint64_t currentValue;
2378     auto error = uncheckedGetKeyGeneratorValue(objectStoreID, currentValue);
2379     if (!error.isNull())
2380         return error;
2381 
2382     if (currentValue + 1 &gt; maxGeneratorValue)
2383         return IDBError { ConstraintError, &quot;Cannot generate new key value over 2^53 for object store operation&quot; };
2384 
2385     generatedKey = currentValue + 1;
2386     return uncheckedSetKeyGeneratorValue(objectStoreID, generatedKey);
2387 }
2388 
2389 IDBError SQLiteIDBBackingStore::revertGeneratedKeyNumber(const IDBResourceIdentifier&amp; transactionIdentifier, uint64_t objectStoreID, uint64_t newKeyNumber)
2390 {
2391     LOG(IndexedDB, &quot;SQLiteIDBBackingStore::revertGeneratedKeyNumber - object store %&quot; PRIu64 &quot;, reverted number %&quot; PRIu64, objectStoreID, newKeyNumber);
2392 
2393     ASSERT(m_sqliteDB);
2394     ASSERT(m_sqliteDB-&gt;isOpen());
2395 
2396     auto* transaction = m_transactions.get(transactionIdentifier);
2397     if (!transaction || !transaction-&gt;inProgress())
2398         return IDBError { UnknownError, &quot;Attempt to revert key generator value in database without an in-progress transaction&quot;_s };
2399 
2400     if (transaction-&gt;mode() == IDBTransactionMode::Readonly) {
2401         LOG_ERROR(&quot;Attempt to revert key generator value in a read-only transaction&quot;);
2402         return IDBError { UnknownError, &quot;Attempt to revert key generator value in a read-only transaction&quot;_s };
2403     }
2404 
2405     ASSERT(newKeyNumber);
2406     return uncheckedSetKeyGeneratorValue(objectStoreID, newKeyNumber - 1);
2407 }
2408 
2409 IDBError SQLiteIDBBackingStore::maybeUpdateKeyGeneratorNumber(const IDBResourceIdentifier&amp; transactionIdentifier, uint64_t objectStoreID, double newKeyNumber)
2410 {
2411     LOG(IndexedDB, &quot;SQLiteIDBBackingStore::maybeUpdateKeyGeneratorNumber&quot;);
2412 
2413     ASSERT(m_sqliteDB);
2414     ASSERT(m_sqliteDB-&gt;isOpen());
2415 
2416     auto* transaction = m_transactions.get(transactionIdentifier);
2417     if (!transaction || !transaction-&gt;inProgress())
2418         return IDBError { UnknownError, &quot;Attempt to update key generator value in database without an in-progress transaction&quot;_s };
2419 
2420     if (transaction-&gt;mode() == IDBTransactionMode::Readonly) {
2421         LOG_ERROR(&quot;Attempt to update key generator value in a read-only transaction&quot;);
2422         return IDBError { UnknownError, &quot;Attempt to update key generator value in a read-only transaction&quot;_s };
2423     }
2424 
2425     uint64_t currentValue;
2426     auto error = uncheckedGetKeyGeneratorValue(objectStoreID, currentValue);
2427     if (!error.isNull())
2428         return error;
2429 
2430     if (newKeyNumber &lt;= currentValue)
2431         return IDBError { };
2432 
2433     return uncheckedSetKeyGeneratorValue(objectStoreID, std::min(newKeyNumber, (double)maxGeneratorValue));
2434 }
2435 
2436 IDBError SQLiteIDBBackingStore::openCursor(const IDBResourceIdentifier&amp; transactionIdentifier, const IDBCursorInfo&amp; info, IDBGetResult&amp; result)
2437 {
2438     ASSERT(m_sqliteDB);
2439     ASSERT(m_sqliteDB-&gt;isOpen());
2440 
2441     auto* transaction = m_transactions.get(transactionIdentifier);
2442     if (!transaction || !transaction-&gt;inProgress())
2443         return IDBError { UnknownError, &quot;Attempt to open a cursor in database without an in-progress transaction&quot;_s };
2444 
2445     auto* cursor = transaction-&gt;maybeOpenCursor(info);
2446     if (!cursor) {
2447         LOG_ERROR(&quot;Unable to open cursor&quot;);
2448         return IDBError { UnknownError, &quot;Unable to open cursor&quot;_s };
2449     }
2450 
2451     m_cursors.set(cursor-&gt;identifier(), cursor);
2452 
2453     auto* objectStoreInfo = infoForObjectStore(info.objectStoreIdentifier());
2454     ASSERT(objectStoreInfo);
2455     cursor-&gt;currentData(result, objectStoreInfo-&gt;keyPath());
2456     return IDBError { };
2457 }
2458 
2459 IDBError SQLiteIDBBackingStore::iterateCursor(const IDBResourceIdentifier&amp; transactionIdentifier, const IDBResourceIdentifier&amp; cursorIdentifier, const IDBIterateCursorData&amp; data, IDBGetResult&amp; result)
2460 {
2461     LOG(IndexedDB, &quot;SQLiteIDBBackingStore::iterateCursor&quot;);
2462 
2463     ASSERT(m_sqliteDB);
2464     ASSERT(m_sqliteDB-&gt;isOpen());
2465 
2466     auto* cursor = m_cursors.get(cursorIdentifier);
2467     if (!cursor) {
2468         LOG_ERROR(&quot;Attempt to iterate a cursor that doesn&#39;t exist&quot;);
2469         return IDBError { UnknownError, &quot;Attempt to iterate a cursor that doesn&#39;t exist&quot;_s };
2470     }
2471 
2472     ASSERT_UNUSED(transactionIdentifier, cursor-&gt;transaction()-&gt;transactionIdentifier() == transactionIdentifier);
2473 
2474     if (!cursor-&gt;transaction() || !cursor-&gt;transaction()-&gt;inProgress())
2475         return IDBError { UnknownError, &quot;Attempt to iterate a cursor without an in-progress transaction&quot;_s };
2476 
2477     auto key = data.keyData;
2478     auto primaryKey = data.primaryKeyData;
2479     auto count = data.count;
2480 
2481     if (key.isValid()) {
2482         if (!cursor-&gt;iterate(key, primaryKey)) {
2483             LOG_ERROR(&quot;Attempt to iterate cursor failed&quot;);
2484             return IDBError { UnknownError, &quot;Attempt to iterate cursor failed&quot;_s };
2485         }
2486     } else {
2487         ASSERT(!primaryKey.isValid());
2488         if (!count)
2489             count = 1;
2490         if (!cursor-&gt;advance(count)) {
2491             LOG_ERROR(&quot;Attempt to advance cursor failed&quot;);
2492             return IDBError { UnknownError, &quot;Attempt to advance cursor failed&quot;_s };
2493         }
2494     }
2495 
2496     auto* objectStoreInfo = infoForObjectStore(cursor-&gt;objectStoreID());
2497     ASSERT(objectStoreInfo);
2498     cursor-&gt;currentData(result, objectStoreInfo-&gt;keyPath());
2499     return IDBError { };
2500 }
2501 
2502 bool SQLiteIDBBackingStore::prefetchCursor(const IDBResourceIdentifier&amp; transactionIdentifier, const IDBResourceIdentifier&amp; cursorIdentifier)
2503 {
2504     LOG(IndexedDB, &quot;SQLiteIDBBackingStore::prefetchCursor&quot;);
2505 
2506     ASSERT(m_sqliteDB);
2507     ASSERT(m_sqliteDB-&gt;isOpen());
2508 
2509     auto* cursor = m_cursors.get(cursorIdentifier);
2510     if (!cursor || !cursor-&gt;transaction() || !cursor-&gt;transaction()-&gt;inProgress())
2511         return false;
2512 
2513     ASSERT_UNUSED(transactionIdentifier, cursor-&gt;transaction()-&gt;transactionIdentifier() == transactionIdentifier);
2514 
2515     return cursor-&gt;prefetch();
2516 }
2517 
2518 IDBObjectStoreInfo* SQLiteIDBBackingStore::infoForObjectStore(uint64_t objectStoreIdentifier)
2519 {
2520     ASSERT(m_databaseInfo);
2521     return m_databaseInfo-&gt;infoForExistingObjectStore(objectStoreIdentifier);
2522 }
2523 
2524 void SQLiteIDBBackingStore::deleteBackingStore()
2525 {
2526     String dbFilename = fullDatabasePath();
2527 
2528     LOG(IndexedDB, &quot;SQLiteIDBBackingStore::deleteBackingStore deleting file &#39;%s&#39; on disk&quot;, dbFilename.utf8().data());
2529 
2530     Vector&lt;String&gt; blobFiles;
2531     {
2532         bool errored = true;
2533 
2534         if (m_sqliteDB) {
2535             SQLiteStatement sql(*m_sqliteDB, &quot;SELECT fileName FROM BlobFiles;&quot;_s);
2536             if (sql.prepare() == SQLITE_OK) {
2537                 int result = sql.step();
2538                 while (result == SQLITE_ROW) {
2539                     blobFiles.append(sql.getColumnText(0));
2540                     result = sql.step();
2541                 }
2542 
2543                 if (result == SQLITE_DONE)
2544                     errored = false;
2545             }
2546         }
2547 
2548         if (errored)
2549             LOG_ERROR(&quot;Error getting all blob filenames to be deleted&quot;);
2550     }
2551 
2552     for (auto&amp; file : blobFiles) {
2553         String fullPath = FileSystem::pathByAppendingComponent(m_databaseDirectory, file);
2554         if (!FileSystem::deleteFile(fullPath))
2555             LOG_ERROR(&quot;Error deleting blob file %s&quot;, fullPath.utf8().data());
2556     }
2557 
2558     if (m_sqliteDB)
2559         closeSQLiteDB();
2560 
2561     SQLiteFileSystem::deleteDatabaseFile(dbFilename);
2562     SQLiteFileSystem::deleteEmptyDatabaseDirectory(m_databaseDirectory);
2563     SQLiteFileSystem::deleteEmptyDatabaseDirectory(m_identifier.databaseDirectoryRelativeToRoot(databaseRootDirectoryIsolatedCopy()));
2564 }
2565 
2566 void SQLiteIDBBackingStore::unregisterCursor(SQLiteIDBCursor&amp; cursor)
2567 {
2568     ASSERT(m_cursors.contains(cursor.identifier()));
2569     m_cursors.remove(cursor.identifier());
2570 }
2571 
2572 SQLiteStatement* SQLiteIDBBackingStore::cachedStatement(SQLiteIDBBackingStore::SQL sql, const char* statement)
2573 {
2574     if (sql &gt;= SQL::Count) {
2575         LOG_ERROR(&quot;Invalid SQL statement ID passed to cachedStatement()&quot;);
2576         return nullptr;
2577     }
2578 
2579     if (m_cachedStatements[static_cast&lt;size_t&gt;(sql)]) {
2580         if (m_cachedStatements[static_cast&lt;size_t&gt;(sql)]-&gt;reset() == SQLITE_OK)
2581             return m_cachedStatements[static_cast&lt;size_t&gt;(sql)].get();
2582         m_cachedStatements[static_cast&lt;size_t&gt;(sql)] = nullptr;
2583     }
2584 
2585     if (m_sqliteDB) {
2586         m_cachedStatements[static_cast&lt;size_t&gt;(sql)] = makeUnique&lt;SQLiteStatement&gt;(*m_sqliteDB, statement);
2587         if (m_cachedStatements[static_cast&lt;size_t&gt;(sql)]-&gt;prepare() != SQLITE_OK)
2588             m_cachedStatements[static_cast&lt;size_t&gt;(sql)] = nullptr;
2589     }
2590 
2591     return m_cachedStatements[static_cast&lt;size_t&gt;(sql)].get();
2592 }
2593 
2594 void SQLiteIDBBackingStore::close()
2595 {
2596     closeSQLiteDB();
2597 }
2598 
2599 void SQLiteIDBBackingStore::closeSQLiteDB()
2600 {
2601     for (size_t i = 0; i &lt; static_cast&lt;int&gt;(SQL::Count); ++i)
2602         m_cachedStatements[i] = nullptr;
2603 
2604     if (m_sqliteDB)
2605         m_sqliteDB-&gt;close();
2606 
2607     m_sqliteDB = nullptr;
2608 }
2609 
2610 bool SQLiteIDBBackingStore::hasTransaction(const IDBResourceIdentifier&amp; transactionIdentifier) const
2611 {
2612     ASSERT(isMainThread());
2613     return m_transactions.contains(transactionIdentifier);
2614 }
2615 
2616 } // namespace IDBServer
2617 } // namespace WebCore
2618 
2619 #endif // ENABLE(INDEXED_DATABASE)
    </pre>
  </body>
</html>