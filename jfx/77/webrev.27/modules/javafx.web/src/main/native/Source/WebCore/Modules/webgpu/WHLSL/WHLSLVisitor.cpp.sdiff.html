<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/Modules/webgpu/WHLSL/WHLSLVisitor.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="WHLSLSynthesizeStructureAccessors.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="WHLSLVisitor.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/Modules/webgpu/WHLSL/WHLSLVisitor.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;WHLSLVisitor.h&quot;
 28 
 29 #if ENABLE(WEBGPU)
 30 
<span class="line-modified"> 31 #include &quot;WHLSLArrayReferenceType.h&quot;</span>
<span class="line-removed"> 32 #include &quot;WHLSLArrayType.h&quot;</span>
<span class="line-removed"> 33 #include &quot;WHLSLAssignmentExpression.h&quot;</span>
<span class="line-removed"> 34 #include &quot;WHLSLBaseFunctionAttribute.h&quot;</span>
<span class="line-removed"> 35 #include &quot;WHLSLBaseSemantic.h&quot;</span>
<span class="line-removed"> 36 #include &quot;WHLSLBlock.h&quot;</span>
<span class="line-removed"> 37 #include &quot;WHLSLBooleanLiteral.h&quot;</span>
<span class="line-removed"> 38 #include &quot;WHLSLBreak.h&quot;</span>
<span class="line-removed"> 39 #include &quot;WHLSLBuiltInSemantic.h&quot;</span>
<span class="line-removed"> 40 #include &quot;WHLSLCallExpression.h&quot;</span>
<span class="line-removed"> 41 #include &quot;WHLSLCommaExpression.h&quot;</span>
<span class="line-removed"> 42 #include &quot;WHLSLConstantExpression.h&quot;</span>
<span class="line-removed"> 43 #include &quot;WHLSLContinue.h&quot;</span>
<span class="line-removed"> 44 #include &quot;WHLSLDereferenceExpression.h&quot;</span>
<span class="line-removed"> 45 #include &quot;WHLSLDoWhileLoop.h&quot;</span>
<span class="line-removed"> 46 #include &quot;WHLSLDotExpression.h&quot;</span>
<span class="line-removed"> 47 #include &quot;WHLSLEffectfulExpressionStatement.h&quot;</span>
<span class="line-removed"> 48 #include &quot;WHLSLEnumerationDefinition.h&quot;</span>
<span class="line-removed"> 49 #include &quot;WHLSLEnumerationMember.h&quot;</span>
<span class="line-removed"> 50 #include &quot;WHLSLEnumerationMemberLiteral.h&quot;</span>
<span class="line-removed"> 51 #include &quot;WHLSLExpression.h&quot;</span>
<span class="line-removed"> 52 #include &quot;WHLSLFallthrough.h&quot;</span>
<span class="line-removed"> 53 #include &quot;WHLSLFloatLiteral.h&quot;</span>
<span class="line-removed"> 54 #include &quot;WHLSLForLoop.h&quot;</span>
<span class="line-removed"> 55 #include &quot;WHLSLFunctionAttribute.h&quot;</span>
<span class="line-removed"> 56 #include &quot;WHLSLFunctionDeclaration.h&quot;</span>
<span class="line-removed"> 57 #include &quot;WHLSLFunctionDefinition.h&quot;</span>
<span class="line-removed"> 58 #include &quot;WHLSLIfStatement.h&quot;</span>
<span class="line-removed"> 59 #include &quot;WHLSLIndexExpression.h&quot;</span>
<span class="line-removed"> 60 #include &quot;WHLSLIntegerLiteral.h&quot;</span>
<span class="line-removed"> 61 #include &quot;WHLSLLogicalExpression.h&quot;</span>
<span class="line-removed"> 62 #include &quot;WHLSLLogicalNotExpression.h&quot;</span>
<span class="line-removed"> 63 #include &quot;WHLSLMakeArrayReferenceExpression.h&quot;</span>
<span class="line-removed"> 64 #include &quot;WHLSLMakePointerExpression.h&quot;</span>
<span class="line-removed"> 65 #include &quot;WHLSLNativeFunctionDeclaration.h&quot;</span>
<span class="line-removed"> 66 #include &quot;WHLSLNativeTypeDeclaration.h&quot;</span>
<span class="line-removed"> 67 #include &quot;WHLSLNode.h&quot;</span>
<span class="line-removed"> 68 #include &quot;WHLSLNullLiteral.h&quot;</span>
<span class="line-removed"> 69 #include &quot;WHLSLNumThreadsFunctionAttribute.h&quot;</span>
<span class="line-removed"> 70 #include &quot;WHLSLPointerType.h&quot;</span>
 71 #include &quot;WHLSLProgram.h&quot;
<span class="line-removed"> 72 #include &quot;WHLSLPropertyAccessExpression.h&quot;</span>
<span class="line-removed"> 73 #include &quot;WHLSLQualifier.h&quot;</span>
<span class="line-removed"> 74 #include &quot;WHLSLReadModifyWriteExpression.h&quot;</span>
<span class="line-removed"> 75 #include &quot;WHLSLReferenceType.h&quot;</span>
<span class="line-removed"> 76 #include &quot;WHLSLResourceSemantic.h&quot;</span>
<span class="line-removed"> 77 #include &quot;WHLSLReturn.h&quot;</span>
<span class="line-removed"> 78 #include &quot;WHLSLSemantic.h&quot;</span>
<span class="line-removed"> 79 #include &quot;WHLSLSpecializationConstantSemantic.h&quot;</span>
<span class="line-removed"> 80 #include &quot;WHLSLStageInOutSemantic.h&quot;</span>
<span class="line-removed"> 81 #include &quot;WHLSLStatement.h&quot;</span>
<span class="line-removed"> 82 #include &quot;WHLSLStructureDefinition.h&quot;</span>
<span class="line-removed"> 83 #include &quot;WHLSLStructureElement.h&quot;</span>
<span class="line-removed"> 84 #include &quot;WHLSLSwitchCase.h&quot;</span>
<span class="line-removed"> 85 #include &quot;WHLSLSwitchStatement.h&quot;</span>
<span class="line-removed"> 86 #include &quot;WHLSLTernaryExpression.h&quot;</span>
<span class="line-removed"> 87 #include &quot;WHLSLTrap.h&quot;</span>
<span class="line-removed"> 88 #include &quot;WHLSLType.h&quot;</span>
<span class="line-removed"> 89 #include &quot;WHLSLTypeArgument.h&quot;</span>
<span class="line-removed"> 90 #include &quot;WHLSLTypeDefinition.h&quot;</span>
<span class="line-removed"> 91 #include &quot;WHLSLTypeReference.h&quot;</span>
<span class="line-removed"> 92 #include &quot;WHLSLUnsignedIntegerLiteral.h&quot;</span>
<span class="line-removed"> 93 #include &quot;WHLSLValue.h&quot;</span>
<span class="line-removed"> 94 #include &quot;WHLSLVariableDeclaration.h&quot;</span>
<span class="line-removed"> 95 #include &quot;WHLSLVariableDeclarationsStatement.h&quot;</span>
<span class="line-removed"> 96 #include &quot;WHLSLVariableReference.h&quot;</span>
<span class="line-removed"> 97 #include &quot;WHLSLWhileLoop.h&quot;</span>
 98 
 99 namespace WebCore {
100 
101 namespace WHLSL {
102 
103 void Visitor::visit(Program&amp; program)
104 {
105     // These visiting functions might add new global statements, so don&#39;t use foreach syntax.
106     for (size_t i = 0; i &lt; program.typeDefinitions().size(); ++i)
107         checkErrorAndVisit(program.typeDefinitions()[i]);
108     for (size_t i = 0; i &lt; program.structureDefinitions().size(); ++i)
109         checkErrorAndVisit(program.structureDefinitions()[i]);
110     for (size_t i = 0; i &lt; program.enumerationDefinitions().size(); ++i)
111         checkErrorAndVisit(program.enumerationDefinitions()[i]);
112     for (size_t i = 0; i &lt; program.functionDefinitions().size(); ++i)
113         checkErrorAndVisit(program.functionDefinitions()[i]);
114     for (size_t i = 0; i &lt; program.nativeFunctionDeclarations().size(); ++i)
115         checkErrorAndVisit(program.nativeFunctionDeclarations()[i]);
116     for (size_t i = 0; i &lt; program.nativeTypeDeclarations().size(); ++i)
117         checkErrorAndVisit(program.nativeTypeDeclarations()[i]);
118 }
119 
120 void Visitor::visit(AST::UnnamedType&amp; unnamedType)
121 {
122     if (is&lt;AST::TypeReference&gt;(unnamedType))
123         checkErrorAndVisit(downcast&lt;AST::TypeReference&gt;(unnamedType));
124     else if (is&lt;AST::PointerType&gt;(unnamedType))
125         checkErrorAndVisit(downcast&lt;AST::PointerType&gt;(unnamedType));
126     else if (is&lt;AST::ArrayReferenceType&gt;(unnamedType))
127         checkErrorAndVisit(downcast&lt;AST::ArrayReferenceType&gt;(unnamedType));
<span class="line-modified">128     else {</span>
<span class="line-removed">129         ASSERT(is&lt;AST::ArrayType&gt;(unnamedType));</span>
130         checkErrorAndVisit(downcast&lt;AST::ArrayType&gt;(unnamedType));
<span class="line-removed">131     }</span>
132 }
133 
134 void Visitor::visit(AST::NamedType&amp; namedType)
135 {
136     if (is&lt;AST::TypeDefinition&gt;(namedType))
137         checkErrorAndVisit(downcast&lt;AST::TypeDefinition&gt;(namedType));
138     else if (is&lt;AST::StructureDefinition&gt;(namedType))
139         checkErrorAndVisit(downcast&lt;AST::StructureDefinition&gt;(namedType));
140     else if (is&lt;AST::EnumerationDefinition&gt;(namedType))
141         checkErrorAndVisit(downcast&lt;AST::EnumerationDefinition&gt;(namedType));
<span class="line-modified">142     else {</span>
<span class="line-removed">143         ASSERT(is&lt;AST::NativeTypeDeclaration&gt;(namedType));</span>
144         checkErrorAndVisit(downcast&lt;AST::NativeTypeDeclaration&gt;(namedType));
<span class="line-removed">145     }</span>
146 }
147 
148 void Visitor::visit(AST::TypeDefinition&amp; typeDefinition)
149 {
150     checkErrorAndVisit(typeDefinition.type());
151 }
152 
153 void Visitor::visit(AST::StructureDefinition&amp; structureDefinition)
154 {
155     for (auto&amp; structureElement : structureDefinition.structureElements())
156         checkErrorAndVisit(structureElement);
157 }
158 
159 void Visitor::visit(AST::EnumerationDefinition&amp; enumerationDefinition)
160 {
161     checkErrorAndVisit(enumerationDefinition.type());
162     for (auto&amp; enumerationMember : enumerationDefinition.enumerationMembers())
163         checkErrorAndVisit(enumerationMember);
164 }
165 
</pre>
<hr />
<pre>
167 {
168     checkErrorAndVisit(static_cast&lt;AST::FunctionDeclaration&amp;&gt;(functionDefinition));
169     checkErrorAndVisit(functionDefinition.block());
170 }
171 
172 void Visitor::visit(AST::NativeFunctionDeclaration&amp; nativeFunctionDeclaration)
173 {
174     checkErrorAndVisit(static_cast&lt;AST::FunctionDeclaration&amp;&gt;(nativeFunctionDeclaration));
175 }
176 
177 void Visitor::visit(AST::NativeTypeDeclaration&amp; nativeTypeDeclaration)
178 {
179     for (auto&amp; typeArgument : nativeTypeDeclaration.typeArguments())
180         checkErrorAndVisit(typeArgument);
181 }
182 
183 void Visitor::visit(AST::TypeReference&amp; typeReference)
184 {
185     for (auto&amp; typeArgument : typeReference.typeArguments())
186         checkErrorAndVisit(typeArgument);
<span class="line-modified">187     if (typeReference.resolvedType() &amp;&amp; is&lt;AST::TypeDefinition&gt;(*typeReference.resolvedType())) {</span>
<span class="line-modified">188         auto&amp; typeDefinition = downcast&lt;AST::TypeDefinition&gt;(*typeReference.resolvedType());</span>
189         checkErrorAndVisit(typeDefinition.type());
190     }
191 }
192 
193 void Visitor::visit(AST::PointerType&amp; pointerType)
194 {
195     checkErrorAndVisit(static_cast&lt;AST::ReferenceType&amp;&gt;(pointerType));
196 }
197 
198 void Visitor::visit(AST::ArrayReferenceType&amp; arrayReferenceType)
199 {
200     checkErrorAndVisit(static_cast&lt;AST::ReferenceType&amp;&gt;(arrayReferenceType));
201 }
202 
203 void Visitor::visit(AST::ArrayType&amp; arrayType)
204 {
205     checkErrorAndVisit(arrayType.type());
206 }
207 
208 void Visitor::visit(AST::StructureElement&amp; structureElement)
209 {
210     checkErrorAndVisit(structureElement.type());
211     if (structureElement.semantic())
212         checkErrorAndVisit(*structureElement.semantic());
213 }
214 
<span class="line-modified">215 void Visitor::visit(AST::EnumerationMember&amp; enumerationMember)</span>
216 {
<span class="line-removed">217     if (enumerationMember.value())</span>
<span class="line-removed">218         checkErrorAndVisit(*enumerationMember.value());</span>
219 }
220 
221 void Visitor::visit(AST::FunctionDeclaration&amp; functionDeclaration)
222 {
223     checkErrorAndVisit(functionDeclaration.attributeBlock());
224     checkErrorAndVisit(functionDeclaration.type());
225     for (auto&amp; parameter : functionDeclaration.parameters())
226         checkErrorAndVisit(parameter);
227     if (functionDeclaration.semantic())
228         checkErrorAndVisit(*functionDeclaration.semantic());
229 }
230 
231 void Visitor::visit(AST::TypeArgument&amp; typeArgument)
232 {
233     WTF::visit(WTF::makeVisitor([&amp;](AST::ConstantExpression&amp; constantExpression) {
234         checkErrorAndVisit(constantExpression);
<span class="line-modified">235     }, [&amp;](UniqueRef&lt;AST::TypeReference&gt;&amp; typeReference) {</span>
236         checkErrorAndVisit(typeReference);
237     }), typeArgument);
238 }
239 
240 void Visitor::visit(AST::ReferenceType&amp; referenceType)
241 {
242     checkErrorAndVisit(referenceType.elementType());
243 }
244 
245 void Visitor::visit(AST::Semantic&amp; semantic)
246 {
247     WTF::visit(WTF::makeVisitor([&amp;](AST::BuiltInSemantic&amp; builtInSemantic) {
248         checkErrorAndVisit(builtInSemantic);
249     }, [&amp;](AST::ResourceSemantic&amp; resourceSemantic) {
250         checkErrorAndVisit(resourceSemantic);
251     }, [&amp;](AST::SpecializationConstantSemantic&amp; specializationConstantSemantic) {
252         checkErrorAndVisit(specializationConstantSemantic);
253     }, [&amp;](AST::StageInOutSemantic&amp; stageInOutSemantic) {
254         checkErrorAndVisit(stageInOutSemantic);
255     }), semantic);
</pre>
<hr />
<pre>
303 {
304     checkErrorAndVisit(unsignedIntegerLiteral.type());
305 }
306 
307 void Visitor::visit(AST::FloatLiteral&amp; floatLiteral)
308 {
309     checkErrorAndVisit(floatLiteral.type());
310 }
311 
312 void Visitor::visit(AST::NullLiteral&amp; nullLiteral)
313 {
314     checkErrorAndVisit(nullLiteral.type());
315 }
316 
317 void Visitor::visit(AST::BooleanLiteral&amp;)
318 {
319 }
320 
321 void Visitor::visit(AST::IntegerLiteralType&amp; integerLiteralType)
322 {
<span class="line-modified">323     if (integerLiteralType.resolvedType())</span>
<span class="line-modified">324         checkErrorAndVisit(*integerLiteralType.resolvedType());</span>
325     checkErrorAndVisit(integerLiteralType.preferredType());
326 }
327 
328 void Visitor::visit(AST::UnsignedIntegerLiteralType&amp; unsignedIntegerLiteralType)
329 {
<span class="line-modified">330     if (unsignedIntegerLiteralType.resolvedType())</span>
<span class="line-modified">331         checkErrorAndVisit(*unsignedIntegerLiteralType.resolvedType());</span>
332     checkErrorAndVisit(unsignedIntegerLiteralType.preferredType());
333 }
334 
335 void Visitor::visit(AST::FloatLiteralType&amp; floatLiteralType)
336 {
<span class="line-modified">337     if (floatLiteralType.resolvedType())</span>
<span class="line-modified">338         checkErrorAndVisit(*floatLiteralType.resolvedType());</span>
339     checkErrorAndVisit(floatLiteralType.preferredType());
340 }
341 
342 void Visitor::visit(AST::NullLiteralType&amp; nullLiteralType)
343 {
<span class="line-modified">344     if (nullLiteralType.resolvedType())</span>
<span class="line-modified">345         checkErrorAndVisit(*nullLiteralType.resolvedType());</span>
346 }
347 
348 void Visitor::visit(AST::EnumerationMemberLiteral&amp;)
349 {
350 }
351 
352 void Visitor::visit(AST::FunctionAttribute&amp; functionAttribute)
353 {
354     WTF::visit(WTF::makeVisitor([&amp;](AST::NumThreadsFunctionAttribute&amp; numThreadsFunctionAttribute) {
355         checkErrorAndVisit(numThreadsFunctionAttribute);
356     }), functionAttribute);
357 }
358 
359 void Visitor::visit(AST::NumThreadsFunctionAttribute&amp;)
360 {
361 }
362 
363 void Visitor::visit(AST::Block&amp; block)
364 {
365     for (auto&amp; statement : block.statements())
366         checkErrorAndVisit(statement);
367 }
368 






369 void Visitor::visit(AST::Statement&amp; statement)
370 {
<span class="line-modified">371     if (is&lt;AST::Block&gt;(statement))</span>

372         checkErrorAndVisit(downcast&lt;AST::Block&gt;(statement));
<span class="line-modified">373     else if (is&lt;AST::Break&gt;(statement))</span>

374         checkErrorAndVisit(downcast&lt;AST::Break&gt;(statement));
<span class="line-modified">375     else if (is&lt;AST::Continue&gt;(statement))</span>

376         checkErrorAndVisit(downcast&lt;AST::Continue&gt;(statement));
<span class="line-modified">377     else if (is&lt;AST::DoWhileLoop&gt;(statement))</span>

378         checkErrorAndVisit(downcast&lt;AST::DoWhileLoop&gt;(statement));
<span class="line-modified">379     else if (is&lt;AST::EffectfulExpressionStatement&gt;(statement))</span>

380         checkErrorAndVisit(downcast&lt;AST::EffectfulExpressionStatement&gt;(statement));
<span class="line-modified">381     else if (is&lt;AST::Fallthrough&gt;(statement))</span>

382         checkErrorAndVisit(downcast&lt;AST::Fallthrough&gt;(statement));
<span class="line-modified">383     else if (is&lt;AST::ForLoop&gt;(statement))</span>

384         checkErrorAndVisit(downcast&lt;AST::ForLoop&gt;(statement));
<span class="line-modified">385     else if (is&lt;AST::IfStatement&gt;(statement))</span>

386         checkErrorAndVisit(downcast&lt;AST::IfStatement&gt;(statement));
<span class="line-modified">387     else if (is&lt;AST::Return&gt;(statement))</span>

388         checkErrorAndVisit(downcast&lt;AST::Return&gt;(statement));
<span class="line-modified">389     else if (is&lt;AST::SwitchCase&gt;(statement))</span>




390         checkErrorAndVisit(downcast&lt;AST::SwitchCase&gt;(statement));
<span class="line-modified">391     else if (is&lt;AST::SwitchStatement&gt;(statement))</span>

392         checkErrorAndVisit(downcast&lt;AST::SwitchStatement&gt;(statement));
<span class="line-modified">393     else if (is&lt;AST::Trap&gt;(statement))</span>
<span class="line-modified">394         checkErrorAndVisit(downcast&lt;AST::Trap&gt;(statement));</span>
<span class="line-removed">395     else if (is&lt;AST::VariableDeclarationsStatement&gt;(statement))</span>
396         checkErrorAndVisit(downcast&lt;AST::VariableDeclarationsStatement&gt;(statement));
<span class="line-modified">397     else {</span>
<span class="line-modified">398         ASSERT(is&lt;AST::WhileLoop&gt;(statement));</span>
399         checkErrorAndVisit(downcast&lt;AST::WhileLoop&gt;(statement));

400     }
401 }
402 
403 void Visitor::visit(AST::Break&amp;)
404 {
405 }
406 
407 void Visitor::visit(AST::Continue&amp;)
408 {
409 }
410 
411 void Visitor::visit(AST::DoWhileLoop&amp; doWhileLoop)
412 {
413     checkErrorAndVisit(doWhileLoop.body());
414     checkErrorAndVisit(doWhileLoop.conditional());
415 }
416 
417 void Visitor::visit(AST::Expression&amp; expression)
418 {
<span class="line-modified">419     if (is&lt;AST::AssignmentExpression&gt;(expression))</span>

420         checkErrorAndVisit(downcast&lt;AST::AssignmentExpression&gt;(expression));
<span class="line-modified">421     else if (is&lt;AST::BooleanLiteral&gt;(expression))</span>

422         checkErrorAndVisit(downcast&lt;AST::BooleanLiteral&gt;(expression));
<span class="line-modified">423     else if (is&lt;AST::CallExpression&gt;(expression))</span>

424         checkErrorAndVisit(downcast&lt;AST::CallExpression&gt;(expression));
<span class="line-modified">425     else if (is&lt;AST::CommaExpression&gt;(expression))</span>

426         checkErrorAndVisit(downcast&lt;AST::CommaExpression&gt;(expression));
<span class="line-modified">427     else if (is&lt;AST::DereferenceExpression&gt;(expression))</span>

428         checkErrorAndVisit(downcast&lt;AST::DereferenceExpression&gt;(expression));
<span class="line-modified">429     else if (is&lt;AST::FloatLiteral&gt;(expression))</span>

430         checkErrorAndVisit(downcast&lt;AST::FloatLiteral&gt;(expression));
<span class="line-modified">431     else if (is&lt;AST::IntegerLiteral&gt;(expression))</span>

432         checkErrorAndVisit(downcast&lt;AST::IntegerLiteral&gt;(expression));
<span class="line-modified">433     else if (is&lt;AST::LogicalExpression&gt;(expression))</span>

434         checkErrorAndVisit(downcast&lt;AST::LogicalExpression&gt;(expression));
<span class="line-modified">435     else if (is&lt;AST::LogicalNotExpression&gt;(expression))</span>

436         checkErrorAndVisit(downcast&lt;AST::LogicalNotExpression&gt;(expression));
<span class="line-modified">437     else if (is&lt;AST::MakeArrayReferenceExpression&gt;(expression))</span>

438         checkErrorAndVisit(downcast&lt;AST::MakeArrayReferenceExpression&gt;(expression));
<span class="line-modified">439     else if (is&lt;AST::MakePointerExpression&gt;(expression))</span>

440         checkErrorAndVisit(downcast&lt;AST::MakePointerExpression&gt;(expression));
<span class="line-modified">441     else if (is&lt;AST::NullLiteral&gt;(expression))</span>

442         checkErrorAndVisit(downcast&lt;AST::NullLiteral&gt;(expression));
<span class="line-modified">443     else if (is&lt;AST::DotExpression&gt;(expression))</span>

444         checkErrorAndVisit(downcast&lt;AST::DotExpression&gt;(expression));
<span class="line-modified">445     else if (is&lt;AST::IndexExpression&gt;(expression))</span>




446         checkErrorAndVisit(downcast&lt;AST::IndexExpression&gt;(expression));
<span class="line-modified">447     else if (is&lt;AST::ReadModifyWriteExpression&gt;(expression))</span>

448         checkErrorAndVisit(downcast&lt;AST::ReadModifyWriteExpression&gt;(expression));
<span class="line-modified">449     else if (is&lt;AST::TernaryExpression&gt;(expression))</span>

450         checkErrorAndVisit(downcast&lt;AST::TernaryExpression&gt;(expression));
<span class="line-modified">451     else if (is&lt;AST::UnsignedIntegerLiteral&gt;(expression))</span>

452         checkErrorAndVisit(downcast&lt;AST::UnsignedIntegerLiteral&gt;(expression));
<span class="line-modified">453     else if (is&lt;AST::EnumerationMemberLiteral&gt;(expression))</span>

454         checkErrorAndVisit(downcast&lt;AST::EnumerationMemberLiteral&gt;(expression));
<span class="line-modified">455     else {</span>
<span class="line-modified">456         ASSERT(is&lt;AST::VariableReference&gt;(expression));</span>
457         checkErrorAndVisit(downcast&lt;AST::VariableReference&gt;(expression));

458     }
459 }
460 
461 void Visitor::visit(AST::DotExpression&amp; dotExpression)
462 {
463     checkErrorAndVisit(static_cast&lt;AST::PropertyAccessExpression&amp;&gt;(dotExpression));
464 }
465 





466 void Visitor::visit(AST::IndexExpression&amp; indexExpression)
467 {
468     checkErrorAndVisit(indexExpression.indexExpression());
469     checkErrorAndVisit(static_cast&lt;AST::PropertyAccessExpression&amp;&gt;(indexExpression));
470 }
471 
472 void Visitor::visit(AST::PropertyAccessExpression&amp; expression)
473 {
474     checkErrorAndVisit(expression.base());
475 }
476 
477 void Visitor::visit(AST::EffectfulExpressionStatement&amp; effectfulExpressionStatement)
478 {
479     checkErrorAndVisit(effectfulExpressionStatement.effectfulExpression());
480 }
481 
482 void Visitor::visit(AST::Fallthrough&amp;)
483 {
484 }
485 
486 void Visitor::visit(AST::ForLoop&amp; forLoop)
487 {
<span class="line-modified">488     WTF::visit(WTF::makeVisitor([&amp;](AST::VariableDeclarationsStatement&amp; variableDeclarationsStatement) {</span>
<span class="line-removed">489         checkErrorAndVisit(variableDeclarationsStatement);</span>
<span class="line-removed">490     }, [&amp;](UniqueRef&lt;AST::Expression&gt;&amp; expression) {</span>
<span class="line-removed">491         checkErrorAndVisit(expression);</span>
<span class="line-removed">492     }), forLoop.initialization());</span>
493     if (forLoop.condition())
494         checkErrorAndVisit(*forLoop.condition());
495     if (forLoop.increment())
496         checkErrorAndVisit(*forLoop.increment());
497     checkErrorAndVisit(forLoop.body());
498 }
499 
500 void Visitor::visit(AST::IfStatement&amp; ifStatement)
501 {
502     checkErrorAndVisit(ifStatement.conditional());
503     checkErrorAndVisit(ifStatement.body());
504     if (ifStatement.elseBody())
505         checkErrorAndVisit(*ifStatement.elseBody());
506 }
507 
508 void Visitor::visit(AST::Return&amp; returnStatement)
509 {
510     if (returnStatement.value())
511         checkErrorAndVisit(*returnStatement.value());
512 }
513 
514 void Visitor::visit(AST::SwitchCase&amp; switchCase)
515 {
516     if (switchCase.value())
517         checkErrorAndVisit(*switchCase.value());
518     checkErrorAndVisit(switchCase.block());
519 }
520 
521 void Visitor::visit(AST::SwitchStatement&amp; switchStatement)
522 {
523     checkErrorAndVisit(switchStatement.value());
524     for (auto&amp; switchCase : switchStatement.switchCases())
525         checkErrorAndVisit(switchCase);
526 }
527 
<span class="line-removed">528 void Visitor::visit(AST::Trap&amp;)</span>
<span class="line-removed">529 {</span>
<span class="line-removed">530 }</span>
<span class="line-removed">531 </span>
532 void Visitor::visit(AST::VariableDeclarationsStatement&amp; variableDeclarationsStatement)
533 {
534     for (auto&amp; variableDeclaration : variableDeclarationsStatement.variableDeclarations())
<span class="line-modified">535         checkErrorAndVisit(variableDeclaration);</span>
536 }
537 
538 void Visitor::visit(AST::WhileLoop&amp; whileLoop)
539 {
540     checkErrorAndVisit(whileLoop.conditional());
541     checkErrorAndVisit(whileLoop.body());
542 }
543 
544 void Visitor::visit(AST::VariableDeclaration&amp; variableDeclaration)
545 {
546     if (variableDeclaration.type())
547         checkErrorAndVisit(*variableDeclaration.type());
548     if (variableDeclaration.semantic())
549         checkErrorAndVisit(*variableDeclaration.semantic());
550     if (variableDeclaration.initializer())
551         checkErrorAndVisit(*variableDeclaration.initializer());
552 }
553 
554 void Visitor::visit(AST::AssignmentExpression&amp; assignmentExpression)
555 {
556     checkErrorAndVisit(assignmentExpression.left());
557     checkErrorAndVisit(assignmentExpression.right());
558 }
559 
560 void Visitor::visit(AST::CallExpression&amp; callExpression)
561 {
562     for (auto&amp; argument : callExpression.arguments())
563         checkErrorAndVisit(argument);
564     if (callExpression.castReturnType())
<span class="line-modified">565         checkErrorAndVisit(callExpression.castReturnType()-&gt;get());</span>
566 }
567 
568 void Visitor::visit(AST::CommaExpression&amp; commaExpression)
569 {
570     for (auto&amp; expression : commaExpression.list())
571         checkErrorAndVisit(expression);
572 }
573 
574 void Visitor::visit(AST::DereferenceExpression&amp; dereferenceExpression)
575 {
576     checkErrorAndVisit(dereferenceExpression.pointer());
577 }
578 
579 void Visitor::visit(AST::LogicalExpression&amp; logicalExpression)
580 {
581     checkErrorAndVisit(logicalExpression.left());
582     checkErrorAndVisit(logicalExpression.right());
583 }
584 
585 void Visitor::visit(AST::LogicalNotExpression&amp; logicalNotExpression)
586 {
587     checkErrorAndVisit(logicalNotExpression.operand());
588 }
589 
590 void Visitor::visit(AST::MakeArrayReferenceExpression&amp; makeArrayReferenceExpression)
591 {
<span class="line-modified">592     checkErrorAndVisit(makeArrayReferenceExpression.lValue());</span>
593 }
594 
595 void Visitor::visit(AST::MakePointerExpression&amp; makePointerExpression)
596 {
<span class="line-modified">597     checkErrorAndVisit(makePointerExpression.lValue());</span>
598 }
599 
600 void Visitor::visit(AST::ReadModifyWriteExpression&amp; readModifyWriteExpression)
601 {
<span class="line-modified">602     checkErrorAndVisit(readModifyWriteExpression.lValue());</span>
603     checkErrorAndVisit(readModifyWriteExpression.oldValue());
604     checkErrorAndVisit(readModifyWriteExpression.newValue());
<span class="line-modified">605     if (readModifyWriteExpression.newValueExpression())</span>
<span class="line-modified">606         checkErrorAndVisit(*readModifyWriteExpression.newValueExpression());</span>
<span class="line-removed">607     if (readModifyWriteExpression.resultExpression())</span>
<span class="line-removed">608         checkErrorAndVisit(*readModifyWriteExpression.resultExpression());</span>
609 }
610 
611 void Visitor::visit(AST::TernaryExpression&amp; ternaryExpression)
612 {
613     checkErrorAndVisit(ternaryExpression.predicate());
614     checkErrorAndVisit(ternaryExpression.bodyExpression());
615     checkErrorAndVisit(ternaryExpression.elseExpression());
616 }
617 
618 void Visitor::visit(AST::VariableReference&amp;)
619 {
620 }
621 
622 } // namespace WHLSL
623 
624 } // namespace WebCore
625 
626 #endif // ENABLE(WEBGPU)
</pre>
</td>
<td>
<hr />
<pre>
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;WHLSLVisitor.h&quot;
 28 
 29 #if ENABLE(WEBGPU)
 30 
<span class="line-modified"> 31 #include &quot;WHLSLAST.h&quot;</span>







































 32 #include &quot;WHLSLProgram.h&quot;


























 33 
 34 namespace WebCore {
 35 
 36 namespace WHLSL {
 37 
 38 void Visitor::visit(Program&amp; program)
 39 {
 40     // These visiting functions might add new global statements, so don&#39;t use foreach syntax.
 41     for (size_t i = 0; i &lt; program.typeDefinitions().size(); ++i)
 42         checkErrorAndVisit(program.typeDefinitions()[i]);
 43     for (size_t i = 0; i &lt; program.structureDefinitions().size(); ++i)
 44         checkErrorAndVisit(program.structureDefinitions()[i]);
 45     for (size_t i = 0; i &lt; program.enumerationDefinitions().size(); ++i)
 46         checkErrorAndVisit(program.enumerationDefinitions()[i]);
 47     for (size_t i = 0; i &lt; program.functionDefinitions().size(); ++i)
 48         checkErrorAndVisit(program.functionDefinitions()[i]);
 49     for (size_t i = 0; i &lt; program.nativeFunctionDeclarations().size(); ++i)
 50         checkErrorAndVisit(program.nativeFunctionDeclarations()[i]);
 51     for (size_t i = 0; i &lt; program.nativeTypeDeclarations().size(); ++i)
 52         checkErrorAndVisit(program.nativeTypeDeclarations()[i]);
 53 }
 54 
 55 void Visitor::visit(AST::UnnamedType&amp; unnamedType)
 56 {
 57     if (is&lt;AST::TypeReference&gt;(unnamedType))
 58         checkErrorAndVisit(downcast&lt;AST::TypeReference&gt;(unnamedType));
 59     else if (is&lt;AST::PointerType&gt;(unnamedType))
 60         checkErrorAndVisit(downcast&lt;AST::PointerType&gt;(unnamedType));
 61     else if (is&lt;AST::ArrayReferenceType&gt;(unnamedType))
 62         checkErrorAndVisit(downcast&lt;AST::ArrayReferenceType&gt;(unnamedType));
<span class="line-modified"> 63     else</span>

 64         checkErrorAndVisit(downcast&lt;AST::ArrayType&gt;(unnamedType));

 65 }
 66 
 67 void Visitor::visit(AST::NamedType&amp; namedType)
 68 {
 69     if (is&lt;AST::TypeDefinition&gt;(namedType))
 70         checkErrorAndVisit(downcast&lt;AST::TypeDefinition&gt;(namedType));
 71     else if (is&lt;AST::StructureDefinition&gt;(namedType))
 72         checkErrorAndVisit(downcast&lt;AST::StructureDefinition&gt;(namedType));
 73     else if (is&lt;AST::EnumerationDefinition&gt;(namedType))
 74         checkErrorAndVisit(downcast&lt;AST::EnumerationDefinition&gt;(namedType));
<span class="line-modified"> 75     else</span>

 76         checkErrorAndVisit(downcast&lt;AST::NativeTypeDeclaration&gt;(namedType));

 77 }
 78 
 79 void Visitor::visit(AST::TypeDefinition&amp; typeDefinition)
 80 {
 81     checkErrorAndVisit(typeDefinition.type());
 82 }
 83 
 84 void Visitor::visit(AST::StructureDefinition&amp; structureDefinition)
 85 {
 86     for (auto&amp; structureElement : structureDefinition.structureElements())
 87         checkErrorAndVisit(structureElement);
 88 }
 89 
 90 void Visitor::visit(AST::EnumerationDefinition&amp; enumerationDefinition)
 91 {
 92     checkErrorAndVisit(enumerationDefinition.type());
 93     for (auto&amp; enumerationMember : enumerationDefinition.enumerationMembers())
 94         checkErrorAndVisit(enumerationMember);
 95 }
 96 
</pre>
<hr />
<pre>
 98 {
 99     checkErrorAndVisit(static_cast&lt;AST::FunctionDeclaration&amp;&gt;(functionDefinition));
100     checkErrorAndVisit(functionDefinition.block());
101 }
102 
103 void Visitor::visit(AST::NativeFunctionDeclaration&amp; nativeFunctionDeclaration)
104 {
105     checkErrorAndVisit(static_cast&lt;AST::FunctionDeclaration&amp;&gt;(nativeFunctionDeclaration));
106 }
107 
108 void Visitor::visit(AST::NativeTypeDeclaration&amp; nativeTypeDeclaration)
109 {
110     for (auto&amp; typeArgument : nativeTypeDeclaration.typeArguments())
111         checkErrorAndVisit(typeArgument);
112 }
113 
114 void Visitor::visit(AST::TypeReference&amp; typeReference)
115 {
116     for (auto&amp; typeArgument : typeReference.typeArguments())
117         checkErrorAndVisit(typeArgument);
<span class="line-modified">118     if (typeReference.maybeResolvedType() &amp;&amp; is&lt;AST::TypeDefinition&gt;(typeReference.resolvedType())) {</span>
<span class="line-modified">119         auto&amp; typeDefinition = downcast&lt;AST::TypeDefinition&gt;(typeReference.resolvedType());</span>
120         checkErrorAndVisit(typeDefinition.type());
121     }
122 }
123 
124 void Visitor::visit(AST::PointerType&amp; pointerType)
125 {
126     checkErrorAndVisit(static_cast&lt;AST::ReferenceType&amp;&gt;(pointerType));
127 }
128 
129 void Visitor::visit(AST::ArrayReferenceType&amp; arrayReferenceType)
130 {
131     checkErrorAndVisit(static_cast&lt;AST::ReferenceType&amp;&gt;(arrayReferenceType));
132 }
133 
134 void Visitor::visit(AST::ArrayType&amp; arrayType)
135 {
136     checkErrorAndVisit(arrayType.type());
137 }
138 
139 void Visitor::visit(AST::StructureElement&amp; structureElement)
140 {
141     checkErrorAndVisit(structureElement.type());
142     if (structureElement.semantic())
143         checkErrorAndVisit(*structureElement.semantic());
144 }
145 
<span class="line-modified">146 void Visitor::visit(AST::EnumerationMember&amp;)</span>
147 {


148 }
149 
150 void Visitor::visit(AST::FunctionDeclaration&amp; functionDeclaration)
151 {
152     checkErrorAndVisit(functionDeclaration.attributeBlock());
153     checkErrorAndVisit(functionDeclaration.type());
154     for (auto&amp; parameter : functionDeclaration.parameters())
155         checkErrorAndVisit(parameter);
156     if (functionDeclaration.semantic())
157         checkErrorAndVisit(*functionDeclaration.semantic());
158 }
159 
160 void Visitor::visit(AST::TypeArgument&amp; typeArgument)
161 {
162     WTF::visit(WTF::makeVisitor([&amp;](AST::ConstantExpression&amp; constantExpression) {
163         checkErrorAndVisit(constantExpression);
<span class="line-modified">164     }, [&amp;](Ref&lt;AST::TypeReference&gt;&amp; typeReference) {</span>
165         checkErrorAndVisit(typeReference);
166     }), typeArgument);
167 }
168 
169 void Visitor::visit(AST::ReferenceType&amp; referenceType)
170 {
171     checkErrorAndVisit(referenceType.elementType());
172 }
173 
174 void Visitor::visit(AST::Semantic&amp; semantic)
175 {
176     WTF::visit(WTF::makeVisitor([&amp;](AST::BuiltInSemantic&amp; builtInSemantic) {
177         checkErrorAndVisit(builtInSemantic);
178     }, [&amp;](AST::ResourceSemantic&amp; resourceSemantic) {
179         checkErrorAndVisit(resourceSemantic);
180     }, [&amp;](AST::SpecializationConstantSemantic&amp; specializationConstantSemantic) {
181         checkErrorAndVisit(specializationConstantSemantic);
182     }, [&amp;](AST::StageInOutSemantic&amp; stageInOutSemantic) {
183         checkErrorAndVisit(stageInOutSemantic);
184     }), semantic);
</pre>
<hr />
<pre>
232 {
233     checkErrorAndVisit(unsignedIntegerLiteral.type());
234 }
235 
236 void Visitor::visit(AST::FloatLiteral&amp; floatLiteral)
237 {
238     checkErrorAndVisit(floatLiteral.type());
239 }
240 
241 void Visitor::visit(AST::NullLiteral&amp; nullLiteral)
242 {
243     checkErrorAndVisit(nullLiteral.type());
244 }
245 
246 void Visitor::visit(AST::BooleanLiteral&amp;)
247 {
248 }
249 
250 void Visitor::visit(AST::IntegerLiteralType&amp; integerLiteralType)
251 {
<span class="line-modified">252     if (integerLiteralType.maybeResolvedType())</span>
<span class="line-modified">253         checkErrorAndVisit(integerLiteralType.resolvedType());</span>
254     checkErrorAndVisit(integerLiteralType.preferredType());
255 }
256 
257 void Visitor::visit(AST::UnsignedIntegerLiteralType&amp; unsignedIntegerLiteralType)
258 {
<span class="line-modified">259     if (unsignedIntegerLiteralType.maybeResolvedType())</span>
<span class="line-modified">260         checkErrorAndVisit(unsignedIntegerLiteralType.resolvedType());</span>
261     checkErrorAndVisit(unsignedIntegerLiteralType.preferredType());
262 }
263 
264 void Visitor::visit(AST::FloatLiteralType&amp; floatLiteralType)
265 {
<span class="line-modified">266     if (floatLiteralType.maybeResolvedType())</span>
<span class="line-modified">267         checkErrorAndVisit(floatLiteralType.resolvedType());</span>
268     checkErrorAndVisit(floatLiteralType.preferredType());
269 }
270 
271 void Visitor::visit(AST::NullLiteralType&amp; nullLiteralType)
272 {
<span class="line-modified">273     if (nullLiteralType.maybeResolvedType())</span>
<span class="line-modified">274         checkErrorAndVisit(nullLiteralType.resolvedType());</span>
275 }
276 
277 void Visitor::visit(AST::EnumerationMemberLiteral&amp;)
278 {
279 }
280 
281 void Visitor::visit(AST::FunctionAttribute&amp; functionAttribute)
282 {
283     WTF::visit(WTF::makeVisitor([&amp;](AST::NumThreadsFunctionAttribute&amp; numThreadsFunctionAttribute) {
284         checkErrorAndVisit(numThreadsFunctionAttribute);
285     }), functionAttribute);
286 }
287 
288 void Visitor::visit(AST::NumThreadsFunctionAttribute&amp;)
289 {
290 }
291 
292 void Visitor::visit(AST::Block&amp; block)
293 {
294     for (auto&amp; statement : block.statements())
295         checkErrorAndVisit(statement);
296 }
297 
<span class="line-added">298 void Visitor::visit(AST::StatementList&amp; statementList)</span>
<span class="line-added">299 {</span>
<span class="line-added">300     for (auto&amp; statement : statementList.statements())</span>
<span class="line-added">301         checkErrorAndVisit(statement);</span>
<span class="line-added">302 }</span>
<span class="line-added">303 </span>
304 void Visitor::visit(AST::Statement&amp; statement)
305 {
<span class="line-modified">306     switch (statement.kind()) {</span>
<span class="line-added">307     case AST::Statement::Kind::Block:</span>
308         checkErrorAndVisit(downcast&lt;AST::Block&gt;(statement));
<span class="line-modified">309         break;</span>
<span class="line-added">310     case AST::Statement::Kind::Break:</span>
311         checkErrorAndVisit(downcast&lt;AST::Break&gt;(statement));
<span class="line-modified">312         break;</span>
<span class="line-added">313     case AST::Statement::Kind::Continue:</span>
314         checkErrorAndVisit(downcast&lt;AST::Continue&gt;(statement));
<span class="line-modified">315         break;</span>
<span class="line-added">316     case AST::Statement::Kind::DoWhileLoop:</span>
317         checkErrorAndVisit(downcast&lt;AST::DoWhileLoop&gt;(statement));
<span class="line-modified">318         break;</span>
<span class="line-added">319     case AST::Statement::Kind::EffectfulExpression:</span>
320         checkErrorAndVisit(downcast&lt;AST::EffectfulExpressionStatement&gt;(statement));
<span class="line-modified">321         break;</span>
<span class="line-added">322     case AST::Statement::Kind::Fallthrough:</span>
323         checkErrorAndVisit(downcast&lt;AST::Fallthrough&gt;(statement));
<span class="line-modified">324         break;</span>
<span class="line-added">325     case AST::Statement::Kind::ForLoop:</span>
326         checkErrorAndVisit(downcast&lt;AST::ForLoop&gt;(statement));
<span class="line-modified">327         break;</span>
<span class="line-added">328     case AST::Statement::Kind::If:</span>
329         checkErrorAndVisit(downcast&lt;AST::IfStatement&gt;(statement));
<span class="line-modified">330         break;</span>
<span class="line-added">331     case AST::Statement::Kind::Return:</span>
332         checkErrorAndVisit(downcast&lt;AST::Return&gt;(statement));
<span class="line-modified">333         break;</span>
<span class="line-added">334     case AST::Statement::Kind::StatementList:</span>
<span class="line-added">335         checkErrorAndVisit(downcast&lt;AST::StatementList&gt;(statement));</span>
<span class="line-added">336         break;</span>
<span class="line-added">337     case AST::Statement::Kind::SwitchCase:</span>
338         checkErrorAndVisit(downcast&lt;AST::SwitchCase&gt;(statement));
<span class="line-modified">339         break;</span>
<span class="line-added">340     case AST::Statement::Kind::Switch:</span>
341         checkErrorAndVisit(downcast&lt;AST::SwitchStatement&gt;(statement));
<span class="line-modified">342         break;</span>
<span class="line-modified">343     case AST::Statement::Kind::VariableDeclarations:</span>

344         checkErrorAndVisit(downcast&lt;AST::VariableDeclarationsStatement&gt;(statement));
<span class="line-modified">345         break;</span>
<span class="line-modified">346     case AST::Statement::Kind::WhileLoop:</span>
347         checkErrorAndVisit(downcast&lt;AST::WhileLoop&gt;(statement));
<span class="line-added">348         break;</span>
349     }
350 }
351 
352 void Visitor::visit(AST::Break&amp;)
353 {
354 }
355 
356 void Visitor::visit(AST::Continue&amp;)
357 {
358 }
359 
360 void Visitor::visit(AST::DoWhileLoop&amp; doWhileLoop)
361 {
362     checkErrorAndVisit(doWhileLoop.body());
363     checkErrorAndVisit(doWhileLoop.conditional());
364 }
365 
366 void Visitor::visit(AST::Expression&amp; expression)
367 {
<span class="line-modified">368     switch (expression.kind()) {</span>
<span class="line-added">369     case AST::Expression::Kind::Assignment:</span>
370         checkErrorAndVisit(downcast&lt;AST::AssignmentExpression&gt;(expression));
<span class="line-modified">371         break;</span>
<span class="line-added">372     case AST::Expression::Kind::BooleanLiteral:</span>
373         checkErrorAndVisit(downcast&lt;AST::BooleanLiteral&gt;(expression));
<span class="line-modified">374         break;</span>
<span class="line-added">375     case AST::Expression::Kind::Call:</span>
376         checkErrorAndVisit(downcast&lt;AST::CallExpression&gt;(expression));
<span class="line-modified">377         break;</span>
<span class="line-added">378     case AST::Expression::Kind::Comma:</span>
379         checkErrorAndVisit(downcast&lt;AST::CommaExpression&gt;(expression));
<span class="line-modified">380         break;</span>
<span class="line-added">381     case AST::Expression::Kind::Dereference:</span>
382         checkErrorAndVisit(downcast&lt;AST::DereferenceExpression&gt;(expression));
<span class="line-modified">383         break;</span>
<span class="line-added">384     case AST::Expression::Kind::FloatLiteral:</span>
385         checkErrorAndVisit(downcast&lt;AST::FloatLiteral&gt;(expression));
<span class="line-modified">386         break;</span>
<span class="line-added">387     case AST::Expression::Kind::IntegerLiteral:</span>
388         checkErrorAndVisit(downcast&lt;AST::IntegerLiteral&gt;(expression));
<span class="line-modified">389         break;</span>
<span class="line-added">390     case AST::Expression::Kind::Logical:</span>
391         checkErrorAndVisit(downcast&lt;AST::LogicalExpression&gt;(expression));
<span class="line-modified">392         break;</span>
<span class="line-added">393     case AST::Expression::Kind::LogicalNot:</span>
394         checkErrorAndVisit(downcast&lt;AST::LogicalNotExpression&gt;(expression));
<span class="line-modified">395         break;</span>
<span class="line-added">396     case AST::Expression::Kind::MakeArrayReference:</span>
397         checkErrorAndVisit(downcast&lt;AST::MakeArrayReferenceExpression&gt;(expression));
<span class="line-modified">398         break;</span>
<span class="line-added">399     case AST::Expression::Kind::MakePointer:</span>
400         checkErrorAndVisit(downcast&lt;AST::MakePointerExpression&gt;(expression));
<span class="line-modified">401         break;</span>
<span class="line-added">402     case AST::Expression::Kind::NullLiteral:</span>
403         checkErrorAndVisit(downcast&lt;AST::NullLiteral&gt;(expression));
<span class="line-modified">404         break;</span>
<span class="line-added">405     case AST::Expression::Kind::Dot:</span>
406         checkErrorAndVisit(downcast&lt;AST::DotExpression&gt;(expression));
<span class="line-modified">407         break;</span>
<span class="line-added">408     case AST::Expression::Kind::GlobalVariableReference:</span>
<span class="line-added">409         checkErrorAndVisit(downcast&lt;AST::GlobalVariableReference&gt;(expression));</span>
<span class="line-added">410         break;</span>
<span class="line-added">411     case AST::Expression::Kind::Index:</span>
412         checkErrorAndVisit(downcast&lt;AST::IndexExpression&gt;(expression));
<span class="line-modified">413         break;</span>
<span class="line-added">414     case AST::Expression::Kind::ReadModifyWrite:</span>
415         checkErrorAndVisit(downcast&lt;AST::ReadModifyWriteExpression&gt;(expression));
<span class="line-modified">416         break;</span>
<span class="line-added">417     case AST::Expression::Kind::Ternary:</span>
418         checkErrorAndVisit(downcast&lt;AST::TernaryExpression&gt;(expression));
<span class="line-modified">419         break;</span>
<span class="line-added">420     case AST::Expression::Kind::UnsignedIntegerLiteral:</span>
421         checkErrorAndVisit(downcast&lt;AST::UnsignedIntegerLiteral&gt;(expression));
<span class="line-modified">422         break;</span>
<span class="line-added">423     case AST::Expression::Kind::EnumerationMemberLiteral:</span>
424         checkErrorAndVisit(downcast&lt;AST::EnumerationMemberLiteral&gt;(expression));
<span class="line-modified">425         break;</span>
<span class="line-modified">426     case AST::Expression::Kind::VariableReference:</span>
427         checkErrorAndVisit(downcast&lt;AST::VariableReference&gt;(expression));
<span class="line-added">428         break;</span>
429     }
430 }
431 
432 void Visitor::visit(AST::DotExpression&amp; dotExpression)
433 {
434     checkErrorAndVisit(static_cast&lt;AST::PropertyAccessExpression&amp;&gt;(dotExpression));
435 }
436 
<span class="line-added">437 void Visitor::visit(AST::GlobalVariableReference&amp; globalVariableReference)</span>
<span class="line-added">438 {</span>
<span class="line-added">439     checkErrorAndVisit(globalVariableReference.base());</span>
<span class="line-added">440 }</span>
<span class="line-added">441 </span>
442 void Visitor::visit(AST::IndexExpression&amp; indexExpression)
443 {
444     checkErrorAndVisit(indexExpression.indexExpression());
445     checkErrorAndVisit(static_cast&lt;AST::PropertyAccessExpression&amp;&gt;(indexExpression));
446 }
447 
448 void Visitor::visit(AST::PropertyAccessExpression&amp; expression)
449 {
450     checkErrorAndVisit(expression.base());
451 }
452 
453 void Visitor::visit(AST::EffectfulExpressionStatement&amp; effectfulExpressionStatement)
454 {
455     checkErrorAndVisit(effectfulExpressionStatement.effectfulExpression());
456 }
457 
458 void Visitor::visit(AST::Fallthrough&amp;)
459 {
460 }
461 
462 void Visitor::visit(AST::ForLoop&amp; forLoop)
463 {
<span class="line-modified">464     checkErrorAndVisit(forLoop.initialization());</span>




465     if (forLoop.condition())
466         checkErrorAndVisit(*forLoop.condition());
467     if (forLoop.increment())
468         checkErrorAndVisit(*forLoop.increment());
469     checkErrorAndVisit(forLoop.body());
470 }
471 
472 void Visitor::visit(AST::IfStatement&amp; ifStatement)
473 {
474     checkErrorAndVisit(ifStatement.conditional());
475     checkErrorAndVisit(ifStatement.body());
476     if (ifStatement.elseBody())
477         checkErrorAndVisit(*ifStatement.elseBody());
478 }
479 
480 void Visitor::visit(AST::Return&amp; returnStatement)
481 {
482     if (returnStatement.value())
483         checkErrorAndVisit(*returnStatement.value());
484 }
485 
486 void Visitor::visit(AST::SwitchCase&amp; switchCase)
487 {
488     if (switchCase.value())
489         checkErrorAndVisit(*switchCase.value());
490     checkErrorAndVisit(switchCase.block());
491 }
492 
493 void Visitor::visit(AST::SwitchStatement&amp; switchStatement)
494 {
495     checkErrorAndVisit(switchStatement.value());
496     for (auto&amp; switchCase : switchStatement.switchCases())
497         checkErrorAndVisit(switchCase);
498 }
499 




500 void Visitor::visit(AST::VariableDeclarationsStatement&amp; variableDeclarationsStatement)
501 {
502     for (auto&amp; variableDeclaration : variableDeclarationsStatement.variableDeclarations())
<span class="line-modified">503         checkErrorAndVisit(variableDeclaration.get());</span>
504 }
505 
506 void Visitor::visit(AST::WhileLoop&amp; whileLoop)
507 {
508     checkErrorAndVisit(whileLoop.conditional());
509     checkErrorAndVisit(whileLoop.body());
510 }
511 
512 void Visitor::visit(AST::VariableDeclaration&amp; variableDeclaration)
513 {
514     if (variableDeclaration.type())
515         checkErrorAndVisit(*variableDeclaration.type());
516     if (variableDeclaration.semantic())
517         checkErrorAndVisit(*variableDeclaration.semantic());
518     if (variableDeclaration.initializer())
519         checkErrorAndVisit(*variableDeclaration.initializer());
520 }
521 
522 void Visitor::visit(AST::AssignmentExpression&amp; assignmentExpression)
523 {
524     checkErrorAndVisit(assignmentExpression.left());
525     checkErrorAndVisit(assignmentExpression.right());
526 }
527 
528 void Visitor::visit(AST::CallExpression&amp; callExpression)
529 {
530     for (auto&amp; argument : callExpression.arguments())
531         checkErrorAndVisit(argument);
532     if (callExpression.castReturnType())
<span class="line-modified">533         checkErrorAndVisit(*callExpression.castReturnType());</span>
534 }
535 
536 void Visitor::visit(AST::CommaExpression&amp; commaExpression)
537 {
538     for (auto&amp; expression : commaExpression.list())
539         checkErrorAndVisit(expression);
540 }
541 
542 void Visitor::visit(AST::DereferenceExpression&amp; dereferenceExpression)
543 {
544     checkErrorAndVisit(dereferenceExpression.pointer());
545 }
546 
547 void Visitor::visit(AST::LogicalExpression&amp; logicalExpression)
548 {
549     checkErrorAndVisit(logicalExpression.left());
550     checkErrorAndVisit(logicalExpression.right());
551 }
552 
553 void Visitor::visit(AST::LogicalNotExpression&amp; logicalNotExpression)
554 {
555     checkErrorAndVisit(logicalNotExpression.operand());
556 }
557 
558 void Visitor::visit(AST::MakeArrayReferenceExpression&amp; makeArrayReferenceExpression)
559 {
<span class="line-modified">560     checkErrorAndVisit(makeArrayReferenceExpression.leftValue());</span>
561 }
562 
563 void Visitor::visit(AST::MakePointerExpression&amp; makePointerExpression)
564 {
<span class="line-modified">565     checkErrorAndVisit(makePointerExpression.leftValue());</span>
566 }
567 
568 void Visitor::visit(AST::ReadModifyWriteExpression&amp; readModifyWriteExpression)
569 {
<span class="line-modified">570     checkErrorAndVisit(readModifyWriteExpression.leftValue());</span>
571     checkErrorAndVisit(readModifyWriteExpression.oldValue());
572     checkErrorAndVisit(readModifyWriteExpression.newValue());
<span class="line-modified">573     checkErrorAndVisit(readModifyWriteExpression.newValueExpression());</span>
<span class="line-modified">574     checkErrorAndVisit(readModifyWriteExpression.resultExpression());</span>


575 }
576 
577 void Visitor::visit(AST::TernaryExpression&amp; ternaryExpression)
578 {
579     checkErrorAndVisit(ternaryExpression.predicate());
580     checkErrorAndVisit(ternaryExpression.bodyExpression());
581     checkErrorAndVisit(ternaryExpression.elseExpression());
582 }
583 
584 void Visitor::visit(AST::VariableReference&amp;)
585 {
586 }
587 
588 } // namespace WHLSL
589 
590 } // namespace WebCore
591 
592 #endif // ENABLE(WEBGPU)
</pre>
</td>
</tr>
</table>
<center><a href="WHLSLSynthesizeStructureAccessors.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="WHLSLVisitor.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>