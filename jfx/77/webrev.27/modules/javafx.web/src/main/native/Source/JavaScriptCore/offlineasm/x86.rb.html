<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/JavaScriptCore/offlineasm/x86.rb</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 # Copyright (C) 2012-2018 Apple Inc. All rights reserved.
   2 # Copyright (C) 2013 Digia Plc. and/or its subsidiary(-ies)
   3 #
   4 # Redistribution and use in source and binary forms, with or without
   5 # modification, are permitted provided that the following conditions
   6 # are met:
   7 # 1. Redistributions of source code must retain the above copyright
   8 #    notice, this list of conditions and the following disclaimer.
   9 # 2. Redistributions in binary form must reproduce the above copyright
  10 #    notice, this list of conditions and the following disclaimer in the
  11 #    documentation and/or other materials provided with the distribution.
  12 #
  13 # THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
  14 # AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
  15 # THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16 # PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
  17 # BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  18 # CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  19 # SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  20 # INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  21 # CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  22 # ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
  23 # THE POSSIBILITY OF SUCH DAMAGE.
  24 
  25 require &quot;config&quot;
  26 
  27 # GPR conventions, to match the baseline JIT:
  28 #
  29 #
  30 # On x86-32 bits (windows and non-windows)
  31 # a0, a1, a2, a3 are only there for ease-of-use of offlineasm; they are not
  32 # actually considered as such by the ABI and we need to push/pop our arguments
  33 # on the stack. a0 and a1 are ecx and edx to follow fastcall.
  34 #
  35 # eax =&gt; t0, a2, r0
  36 # edx =&gt; t1, a1, r1
  37 # ecx =&gt; t2, a0
  38 # ebx =&gt; t3, a3     (callee-save)
  39 # esi =&gt; t4         (callee-save)
  40 # edi =&gt; t5         (callee-save)
  41 # ebp =&gt; cfr
  42 # esp =&gt; sp
  43 #
  44 # On x86-64 non-windows
  45 #
  46 # rax =&gt; t0,     r0
  47 # rdi =&gt;     a0
  48 # rsi =&gt; t1, a1
  49 # rdx =&gt; t2, a2, r1
  50 # rcx =&gt; t3, a3
  51 #  r8 =&gt; t4
  52 #  r9 =&gt; t5
  53 # r10 =&gt; t6
  54 # rbx =&gt;             csr0 (callee-save, PB, unused in baseline)
  55 # r12 =&gt;             csr1 (callee-save)
  56 # r13 =&gt;             csr2 (callee-save)
  57 # r14 =&gt;             csr3 (callee-save, tagTypeNumber)
  58 # r15 =&gt;             csr4 (callee-save, tagMask)
  59 # rsp =&gt; sp
  60 # rbp =&gt; cfr
  61 # r11 =&gt;                  (scratch)
  62 #
  63 # On x86-64 windows
  64 # Arguments need to be push/pop&#39;d on the stack in addition to being stored in
  65 # the registers. Also, &gt;8 return types are returned in a weird way.
  66 #
  67 # rax =&gt; t0,     r0
  68 # rcx =&gt; t5, a0
  69 # rdx =&gt; t1, a1, r1
  70 #  r8 =&gt; t2, a2
  71 #  r9 =&gt; t3, a3
  72 # r10 =&gt; t4
  73 # rbx =&gt;             csr0 (callee-save, PB, unused in baseline)
  74 # rsi =&gt;             csr1 (callee-save)
  75 # rdi =&gt;             csr2 (callee-save)
  76 # r12 =&gt;             csr3 (callee-save)
  77 # r13 =&gt;             csr4 (callee-save)
  78 # r14 =&gt;             csr5 (callee-save, tagTypeNumber)
  79 # r15 =&gt;             csr6 (callee-save, tagMask)
  80 # rsp =&gt; sp
  81 # rbp =&gt; cfr
  82 # r11 =&gt;                  (scratch)
  83 
  84 def isX64
  85     case $activeBackend
  86     when &quot;X86&quot;
  87         false
  88     when &quot;X86_WIN&quot;
  89         false
  90     when &quot;X86_64&quot;
  91         true
  92     when &quot;X86_64_WIN&quot;
  93         true
  94     else
  95         raise &quot;bad value for $activeBackend: #{$activeBackend}&quot;
  96     end
  97 end
  98 
  99 def isWin
 100     case $activeBackend
 101     when &quot;X86&quot;
 102         false
 103     when &quot;X86_WIN&quot;
 104         true
 105     when &quot;X86_64&quot;
 106         false
 107     when &quot;X86_64_WIN&quot;
 108         true
 109     else
 110         raise &quot;bad value for $activeBackend: #{$activeBackend}&quot;
 111     end
 112 end
 113 
 114 def isMSVC
 115     $options.has_key?(:assembler) &amp;&amp; $options[:assembler] == &quot;MASM&quot;
 116 end
 117 
 118 def isIntelSyntax
 119     $options.has_key?(:assembler) &amp;&amp; $options[:assembler] == &quot;MASM&quot;
 120 end
 121 
 122 def register(name)
 123     isIntelSyntax ? name : &quot;%&quot; + name
 124 end
 125 
 126 def offsetRegister(off, register)
 127     isIntelSyntax ? &quot;[#{off} + #{register}]&quot; : &quot;#{off}(#{register})&quot;
 128 end
 129 
 130 def callPrefix
 131     isIntelSyntax ? &quot;&quot; : &quot;*&quot;
 132 end
 133 
 134 def orderOperands(opA, opB)
 135     isIntelSyntax ? &quot;#{opB}, #{opA}&quot; : &quot;#{opA}, #{opB}&quot;
 136 end
 137 
 138 def const(c)
 139     isIntelSyntax ? &quot;#{c}&quot; : &quot;$#{c}&quot;
 140 end
 141 
 142 def getSizeString(kind)
 143     if !isIntelSyntax
 144         return &quot;&quot;
 145     end
 146 
 147     size = &quot;&quot;
 148     case kind
 149     when :byte
 150         size = &quot;byte&quot;
 151     when :half
 152         size = &quot;word&quot;
 153     when :int
 154         size = &quot;dword&quot;
 155     when :ptr
 156         size =  isX64 ? &quot;qword&quot; : &quot;dword&quot;
 157     when :double
 158         size = &quot;qword&quot;
 159     when :quad
 160         size = &quot;qword&quot;
 161     else
 162         raise &quot;Invalid kind #{kind}&quot;
 163     end
 164 
 165     return size + &quot; &quot; + &quot;ptr&quot; + &quot; &quot;;
 166 end
 167 
 168 class SpecialRegister &lt; NoChildren
 169     def x86Operand(kind)
 170         raise unless @name =~ /^r/
 171         raise unless isX64
 172         case kind
 173         when :half
 174             register(@name + &quot;w&quot;)
 175         when :int
 176             register(@name + &quot;d&quot;)
 177         when :ptr
 178             register(@name)
 179         when :quad
 180             register(@name)
 181         else
 182             raise
 183         end
 184     end
 185     def x86CallOperand(kind)
 186         # Call operands are not allowed to be partial registers.
 187         &quot;#{callPrefix}#{x86Operand(:quad)}&quot;
 188     end
 189 end
 190 
 191 X64_SCRATCH_REGISTER = SpecialRegister.new(&quot;r11&quot;)
 192 
 193 def x86GPRName(name, kind)
 194     case name
 195     when &quot;eax&quot;, &quot;ebx&quot;, &quot;ecx&quot;, &quot;edx&quot;
 196         name8 = name[1] + &#39;l&#39;
 197         name16 = name[1..2]
 198     when &quot;esi&quot;, &quot;edi&quot;, &quot;ebp&quot;, &quot;esp&quot;
 199         name16 = name[1..2]
 200         name8 = name16 + &#39;l&#39;
 201     when &quot;rax&quot;, &quot;rbx&quot;, &quot;rcx&quot;, &quot;rdx&quot;
 202         raise &quot;bad GPR name #{name} in 32-bit X86&quot; unless isX64
 203         name8 = name[1] + &#39;l&#39;
 204         name16 = name[1..2]
 205     when &quot;r8&quot;, &quot;r9&quot;, &quot;r10&quot;, &quot;r12&quot;, &quot;r13&quot;, &quot;r14&quot;, &quot;r15&quot;
 206         raise &quot;bad GPR name #{name} in 32-bit X86&quot; unless isX64
 207         case kind
 208         when :half
 209             return register(name + &quot;w&quot;)
 210         when :int
 211             return register(name + &quot;d&quot;)
 212         when :ptr
 213             return register(name)
 214         when :quad
 215             return register(name)
 216         end
 217     else
 218         raise &quot;bad GPR name #{name}&quot;
 219     end
 220     case kind
 221     when :byte
 222         register(name8)
 223     when :half
 224         register(name16)
 225     when :int
 226         register(&quot;e&quot; + name16)
 227     when :ptr
 228         register((isX64 ? &quot;r&quot; : &quot;e&quot;) + name16)
 229     when :quad
 230         isX64 ? register(&quot;r&quot; + name16) : raise
 231     else
 232         raise &quot;invalid kind #{kind} for GPR #{name} in X86&quot;
 233     end
 234 end
 235 
 236 class Node
 237     def x86LoadOperand(type, dst)
 238         x86Operand(type)
 239     end
 240 end
 241 
 242 class RegisterID
 243     def supports8BitOnX86
 244         case x86GPR
 245         when &quot;eax&quot;, &quot;ebx&quot;, &quot;ecx&quot;, &quot;edx&quot;, &quot;edi&quot;, &quot;esi&quot;, &quot;ebp&quot;, &quot;esp&quot;
 246             true
 247         when &quot;r8&quot;, &quot;r9&quot;, &quot;r10&quot;, &quot;r12&quot;, &quot;r13&quot;, &quot;r14&quot;, &quot;r15&quot;
 248             false
 249         else
 250             raise
 251         end
 252     end
 253 
 254     def x86GPR
 255         if isX64
 256             case name
 257             when &quot;t0&quot;, &quot;r0&quot;
 258                 &quot;eax&quot;
 259             when &quot;r1&quot;
 260                 &quot;edx&quot; # t1 = a1 when isWin, t2 = a2 otherwise
 261             when &quot;a0&quot;
 262                 isWin ? &quot;ecx&quot; : &quot;edi&quot;
 263             when &quot;t1&quot;, &quot;a1&quot;
 264                 isWin ? &quot;edx&quot; : &quot;esi&quot;
 265             when &quot;t2&quot;, &quot;a2&quot;
 266                 isWin ? &quot;r8&quot; : &quot;edx&quot;
 267             when &quot;t3&quot;, &quot;a3&quot;
 268                 isWin ? &quot;r9&quot; : &quot;ecx&quot;
 269             when &quot;t4&quot;
 270                 isWin ? &quot;r10&quot; : &quot;r8&quot;
 271             when &quot;t5&quot;
 272                 isWin ? &quot;ecx&quot; : &quot;r10&quot;
 273             when &quot;csr0&quot;
 274                 &quot;ebx&quot;
 275             when &quot;csr1&quot;
 276                 isWin ? &quot;esi&quot; : &quot;r12&quot;
 277             when &quot;csr2&quot;
 278                 isWin ? &quot;edi&quot; : &quot;r13&quot;
 279             when &quot;csr3&quot;
 280                 isWin ? &quot;r12&quot; : &quot;r14&quot;
 281             when &quot;csr4&quot;
 282                 isWin ? &quot;r13&quot; : &quot;r15&quot;
 283             when &quot;csr5&quot;
 284                 raise &quot;cannot use register #{name} on X86-64&quot; unless isWin
 285                 &quot;r14&quot;
 286             when &quot;csr6&quot;
 287                 raise &quot;cannot use register #{name} on X86-64&quot; unless isWin
 288                 &quot;r15&quot;
 289             when &quot;cfr&quot;
 290                 &quot;ebp&quot;
 291             when &quot;sp&quot;
 292                 &quot;esp&quot;
 293             else
 294                 raise &quot;cannot use register #{name} on X86&quot;
 295             end
 296         else
 297             case name
 298             when &quot;t0&quot;, &quot;r0&quot;, &quot;a2&quot;
 299                 &quot;eax&quot;
 300             when &quot;t1&quot;, &quot;r1&quot;, &quot;a1&quot;
 301                 &quot;edx&quot;
 302             when &quot;t2&quot;, &quot;a0&quot;
 303                 &quot;ecx&quot;
 304             when &quot;t3&quot;, &quot;a3&quot;
 305                 &quot;ebx&quot;
 306             when &quot;t4&quot;
 307                 &quot;esi&quot;
 308             when &quot;t5&quot;
 309                 &quot;edi&quot;
 310             when &quot;cfr&quot;
 311                 &quot;ebp&quot;
 312             when &quot;sp&quot;
 313                 &quot;esp&quot;
 314             end
 315         end
 316     end
 317 
 318     def x86Operand(kind)
 319         x86GPRName(x86GPR, kind)
 320     end
 321 
 322     def x86CallOperand(kind)
 323         &quot;#{callPrefix}#{x86Operand(:ptr)}&quot;
 324     end
 325 end
 326 
 327 class FPRegisterID
 328     def x86Operand(kind)
 329         raise unless kind == :double
 330         case name
 331         when &quot;ft0&quot;, &quot;fa0&quot;, &quot;fr&quot;
 332             register(&quot;xmm0&quot;)
 333         when &quot;ft1&quot;, &quot;fa1&quot;
 334             register(&quot;xmm1&quot;)
 335         when &quot;ft2&quot;, &quot;fa2&quot;
 336             register(&quot;xmm2&quot;)
 337         when &quot;ft3&quot;, &quot;fa3&quot;
 338             register(&quot;xmm3&quot;)
 339         when &quot;ft4&quot;
 340             register(&quot;xmm4&quot;)
 341         when &quot;ft5&quot;
 342             register(&quot;xmm5&quot;)
 343         else
 344             raise &quot;Bad register #{name} for X86 at #{codeOriginString}&quot;
 345         end
 346     end
 347     def x86CallOperand(kind)
 348         &quot;#{callPrefix}#{x86Operand(kind)}&quot;
 349     end
 350 end
 351 
 352 class Immediate
 353     def validX86Immediate?
 354         if isX64
 355             value &gt;= -0x80000000 and value &lt;= 0x7fffffff
 356         else
 357             true
 358         end
 359     end
 360     def x86Operand(kind)
 361         &quot;#{const(value)}&quot;
 362     end
 363     def x86CallOperand(kind)
 364         &quot;#{value}&quot;
 365     end
 366 end
 367 
 368 class Address
 369     def supports8BitOnX86
 370         true
 371     end
 372     
 373     def x86AddressOperand(addressKind)
 374         &quot;#{offsetRegister(offset.value, base.x86Operand(addressKind))}&quot;
 375     end
 376     def x86Operand(kind)
 377         &quot;#{getSizeString(kind)}#{x86AddressOperand(:ptr)}&quot;
 378     end
 379     def x86CallOperand(kind)
 380         &quot;#{callPrefix}#{x86Operand(kind)}&quot;
 381     end
 382 end
 383 
 384 class BaseIndex
 385     def supports8BitOnX86
 386         true
 387     end
 388     
 389     def x86AddressOperand(addressKind)
 390         if !isIntelSyntax
 391             &quot;#{offset.value}(#{base.x86Operand(addressKind)}, #{index.x86Operand(addressKind)}, #{scaleValue})&quot;
 392         else
 393             &quot;#{getSizeString(addressKind)}[#{offset.value} + #{base.x86Operand(addressKind)} + #{index.x86Operand(addressKind)} * #{scaleValue}]&quot;
 394         end
 395     end
 396     
 397     def x86Operand(kind)
 398         if !isIntelSyntax
 399             x86AddressOperand(:ptr)
 400         else
 401             &quot;#{getSizeString(kind)}[#{offset.value} + #{base.x86Operand(:ptr)} + #{index.x86Operand(:ptr)} * #{scaleValue}]&quot;
 402         end
 403     end
 404 
 405     def x86CallOperand(kind)
 406         &quot;#{callPrefix}#{x86Operand(kind)}&quot;
 407     end
 408 end
 409 
 410 class AbsoluteAddress
 411     def supports8BitOnX86
 412         true
 413     end
 414     
 415     def x86AddressOperand(addressKind)
 416         &quot;#{address.value}&quot;
 417     end
 418     
 419     def x86Operand(kind)
 420         &quot;#{address.value}&quot;
 421     end
 422 
 423     def x86CallOperand(kind)
 424         &quot;#{callPrefix}#{address.value}&quot;
 425     end
 426 end
 427 
 428 class LabelReference
 429     def x86CallOperand(kind)
 430         asmLabel
 431     end
 432     def x86LoadOperand(kind, dst)
 433         # FIXME: Implement this on platforms that aren&#39;t Mach-O.
 434         # https://bugs.webkit.org/show_bug.cgi?id=175104
 435         used
 436         if !isIntelSyntax
 437             $asm.puts &quot;movq #{asmLabel}@GOTPCREL(%rip), #{dst.x86Operand(:ptr)}&quot;
 438         else
 439             $asm.puts &quot;lea #{dst.x86Operand(:ptr)}, #{asmLabel}&quot;
 440         end
 441         &quot;#{offset}(#{dst.x86Operand(kind)})&quot;
 442     end
 443 end
 444 
 445 class LocalLabelReference
 446     def x86Operand(kind)
 447         asmLabel
 448     end
 449     def x86CallOperand(kind)
 450         asmLabel
 451     end
 452 end
 453 
 454 class Sequence
 455     def getModifiedListX86_64
 456         newList = []
 457         
 458         @list.each {
 459             | node |
 460             newNode = node
 461             if node.is_a? Instruction
 462                 unless node.opcode == &quot;move&quot;
 463                     usedScratch = false
 464                     newOperands = node.operands.map {
 465                         | operand |
 466                         if operand.immediate? and not operand.validX86Immediate?
 467                             if usedScratch
 468                                 raise &quot;Attempt to use scratch register twice at #{operand.codeOriginString}&quot;
 469                             end
 470                             newList &lt;&lt; Instruction.new(operand.codeOrigin, &quot;move&quot;, [operand, X64_SCRATCH_REGISTER])
 471                             usedScratch = true
 472                             X64_SCRATCH_REGISTER
 473                         else
 474                             operand
 475                         end
 476                     }
 477                     newNode = Instruction.new(node.codeOrigin, node.opcode, newOperands, node.annotation)
 478                 end
 479             else
 480                 unless node.is_a? Label or
 481                         node.is_a? LocalLabel or
 482                         node.is_a? Skip
 483                     raise &quot;Unexpected #{node.inspect} at #{node.codeOrigin}&quot; 
 484                 end
 485             end
 486             if newNode
 487                 newList &lt;&lt; newNode
 488             end
 489         }
 490         
 491         return newList
 492     end
 493     def getModifiedListX86_64_WIN
 494         getModifiedListX86_64
 495     end
 496 end
 497 
 498 class Instruction
 499     
 500     def x86Operands(*kinds)
 501         raise unless kinds.size == operands.size
 502         result = []
 503         kinds.size.times {
 504             | idx |
 505             i = isIntelSyntax ? (kinds.size - idx - 1) : idx
 506             result &lt;&lt; operands[i].x86Operand(kinds[i])
 507         }
 508         result.join(&quot;, &quot;)
 509     end
 510     
 511     def x86LoadOperands(srcKind, dstKind)
 512         orderOperands(operands[0].x86LoadOperand(srcKind, operands[1]), operands[1].x86Operand(dstKind))
 513     end
 514 
 515     def x86Suffix(kind)
 516         if isIntelSyntax
 517             return &quot;&quot;
 518         end
 519 
 520         case kind
 521         when :byte
 522             &quot;b&quot;
 523         when :half
 524             &quot;w&quot;
 525         when :int
 526             &quot;l&quot;
 527         when :ptr
 528             isX64 ? &quot;q&quot; : &quot;l&quot;
 529         when :quad
 530             isX64 ? &quot;q&quot; : raise
 531         when :double
 532             &quot;sd&quot;
 533         else
 534             raise
 535         end
 536     end
 537     
 538     def x86Bytes(kind)
 539         case kind
 540         when :byte
 541             1
 542         when :half
 543             2
 544         when :int
 545             4
 546         when :ptr
 547             isX64 ? 8 : 4
 548         when :quad
 549             isX64 ? 8 : raise
 550         when :double
 551             8
 552         else
 553             raise
 554         end
 555     end
 556 
 557     def emitX86Lea(src, dst, kind)
 558         if src.is_a? LabelReference
 559             src.used
 560             if !isIntelSyntax
 561                 $asm.puts &quot;movq #{src.asmLabel}@GOTPCREL(%rip), #{dst.x86Operand(:ptr)}&quot;
 562             else
 563                 $asm.puts &quot;lea #{dst.x86Operand(:ptr)}, #{src.asmLabel}&quot;
 564             end
 565         else
 566             $asm.puts &quot;lea#{x86Suffix(kind)} #{orderOperands(src.x86AddressOperand(kind), dst.x86Operand(kind))}&quot;
 567         end
 568     end
 569 
 570     def getImplicitOperandString
 571         isIntelSyntax ? &quot;st(0), &quot; : &quot;&quot;
 572     end
 573     
 574     def handleX86OpWithNumOperands(opcode, kind, numOperands)
 575         if numOperands == 3
 576             if operands[0] == operands[2]
 577                 $asm.puts &quot;#{opcode} #{orderOperands(operands[1].x86Operand(kind), operands[2].x86Operand(kind))}&quot;
 578             elsif operands[1] == operands[2]
 579                 $asm.puts &quot;#{opcode} #{orderOperands(operands[0].x86Operand(kind), operands[2].x86Operand(kind))}&quot;
 580             else
 581                 $asm.puts &quot;mov#{x86Suffix(kind)} #{orderOperands(operands[0].x86Operand(kind), operands[2].x86Operand(kind))}&quot;
 582                 $asm.puts &quot;#{opcode} #{orderOperands(operands[1].x86Operand(kind), operands[2].x86Operand(kind))}&quot;
 583             end
 584         else
 585             $asm.puts &quot;#{opcode} #{orderOperands(operands[0].x86Operand(kind), operands[1].x86Operand(kind))}&quot;
 586         end
 587     end
 588     
 589     def handleX86Op(opcode, kind)
 590         handleX86OpWithNumOperands(opcode, kind, operands.size)
 591     end
 592     
 593     def handleX86Shift(opcode, kind)
 594         if operands[0].is_a? Immediate or operands[0].x86GPR == &quot;ecx&quot;
 595             $asm.puts &quot;#{opcode} #{orderOperands(operands[0].x86Operand(:byte), operands[1].x86Operand(kind))}&quot;
 596         else
 597             $asm.puts &quot;xchg#{x86Suffix(:ptr)} #{operands[0].x86Operand(:ptr)}, #{x86GPRName(&quot;ecx&quot;, :ptr)}&quot;
 598             $asm.puts &quot;#{opcode} #{orderOperands(register(&quot;cl&quot;), operands[1].x86Operand(kind))}&quot;
 599             $asm.puts &quot;xchg#{x86Suffix(:ptr)} #{operands[0].x86Operand(:ptr)}, #{x86GPRName(&quot;ecx&quot;, :ptr)}&quot;
 600         end
 601     end
 602     
 603     def handleX86DoubleBranch(branchOpcode, mode)
 604         case mode
 605         when :normal
 606             $asm.puts &quot;ucomisd #{orderOperands(operands[1].x86Operand(:double), operands[0].x86Operand(:double))}&quot;
 607         when :reverse
 608             $asm.puts &quot;ucomisd #{orderOperands(operands[0].x86Operand(:double), operands[1].x86Operand(:double))}&quot;
 609         else
 610             raise mode.inspect
 611         end
 612         $asm.puts &quot;#{branchOpcode} #{operands[2].asmLabel}&quot;
 613     end
 614     
 615     def handleX86IntCompare(opcodeSuffix, kind)
 616         if operands[0].is_a? Immediate and operands[0].value == 0 and operands[1].is_a? RegisterID and (opcodeSuffix == &quot;e&quot; or opcodeSuffix == &quot;ne&quot;)
 617             $asm.puts &quot;test#{x86Suffix(kind)} #{orderOperands(operands[1].x86Operand(kind), operands[1].x86Operand(kind))}&quot;
 618         elsif operands[1].is_a? Immediate and operands[1].value == 0 and operands[0].is_a? RegisterID and (opcodeSuffix == &quot;e&quot; or opcodeSuffix == &quot;ne&quot;)
 619             $asm.puts &quot;test#{x86Suffix(kind)}  #{orderOperands(operands[0].x86Operand(kind), operands[0].x86Operand(kind))}&quot;
 620         else
 621             $asm.puts &quot;cmp#{x86Suffix(kind)} #{orderOperands(operands[1].x86Operand(kind), operands[0].x86Operand(kind))}&quot;
 622         end
 623     end
 624     
 625     def handleX86IntBranch(branchOpcode, kind)
 626         handleX86IntCompare(branchOpcode[1..-1], kind)
 627         $asm.puts &quot;#{branchOpcode} #{operands[2].asmLabel}&quot;
 628     end
 629     
 630     def handleX86Set(setOpcode, operand)
 631         if operand.supports8BitOnX86
 632             $asm.puts &quot;#{setOpcode} #{operand.x86Operand(:byte)}&quot;
 633             if !isIntelSyntax
 634                 $asm.puts &quot;movzbl #{orderOperands(operand.x86Operand(:byte), operand.x86Operand(:int))}&quot;
 635             else
 636                 $asm.puts &quot;movzx #{orderOperands(operand.x86Operand(:byte), operand.x86Operand(:int))}&quot;
 637             end
 638         else
 639             ax = RegisterID.new(nil, &quot;r0&quot;)
 640             $asm.puts &quot;xchg#{x86Suffix(:ptr)} #{operand.x86Operand(:ptr)}, #{ax.x86Operand(:ptr)}&quot;
 641             $asm.puts &quot;#{setOpcode} #{ax.x86Operand(:byte)}&quot;
 642             if !isIntelSyntax
 643                 $asm.puts &quot;movzbl #{ax.x86Operand(:byte)}, #{ax.x86Operand(:int)}&quot;
 644             else
 645                 $asm.puts &quot;movzx #{ax.x86Operand(:int)}, #{ax.x86Operand(:byte)}&quot;
 646             end
 647             $asm.puts &quot;xchg#{x86Suffix(:ptr)} #{operand.x86Operand(:ptr)}, #{ax.x86Operand(:ptr)}&quot;
 648         end
 649     end
 650     
 651     def handleX86IntCompareSet(setOpcode, kind)
 652         handleX86IntCompare(setOpcode[3..-1], kind)
 653         handleX86Set(setOpcode, operands[2])
 654     end
 655     
 656     def handleX86Test(kind)
 657         value = operands[0]
 658         case operands.size
 659         when 2
 660             mask = Immediate.new(codeOrigin, -1)
 661         when 3
 662             mask = operands[1]
 663         else
 664             raise &quot;Expected 2 or 3 operands, but got #{operands.size} at #{codeOriginString}&quot;
 665         end
 666         
 667         if mask.is_a? Immediate and mask.value == -1
 668             if value.is_a? RegisterID
 669                 $asm.puts &quot;test#{x86Suffix(kind)} #{value.x86Operand(kind)}, #{value.x86Operand(kind)}&quot;
 670             else
 671                 $asm.puts &quot;cmp#{x86Suffix(kind)} #{orderOperands(const(0), value.x86Operand(kind))}&quot;
 672             end
 673         else
 674             $asm.puts &quot;test#{x86Suffix(kind)} #{orderOperands(mask.x86Operand(kind), value.x86Operand(kind))}&quot;
 675         end
 676     end
 677     
 678     def handleX86BranchTest(branchOpcode, kind)
 679         handleX86Test(kind)
 680         $asm.puts &quot;#{branchOpcode} #{operands.last.asmLabel}&quot;
 681     end
 682     
 683     def handleX86SetTest(setOpcode, kind)
 684         handleX86Test(kind)
 685         handleX86Set(setOpcode, operands.last)
 686     end
 687     
 688     def handleX86OpBranch(opcode, branchOpcode, kind)
 689         handleX86OpWithNumOperands(opcode, kind, operands.size - 1)
 690         case operands.size
 691         when 4
 692             jumpTarget = operands[3]
 693         when 3
 694             jumpTarget = operands[2]
 695         else
 696             raise self.inspect
 697         end
 698         $asm.puts &quot;#{branchOpcode} #{jumpTarget.asmLabel}&quot;
 699     end
 700     
 701     def handleX86SubBranch(branchOpcode, kind)
 702         if operands.size == 4 and operands[1] == operands[2]
 703             $asm.puts &quot;neg#{x86Suffix(kind)} #{operands[2].x86Operand(kind)}&quot;
 704             $asm.puts &quot;add#{x86Suffix(kind)} #{orderOperands(operands[0].x86Operand(kind), operands[2].x86Operand(kind))}&quot;
 705         else
 706             handleX86OpWithNumOperands(&quot;sub#{x86Suffix(kind)}&quot;, kind, operands.size - 1)
 707         end
 708         case operands.size
 709         when 4
 710             jumpTarget = operands[3]
 711         when 3
 712             jumpTarget = operands[2]
 713         else
 714             raise self.inspect
 715         end
 716         $asm.puts &quot;#{branchOpcode} #{jumpTarget.asmLabel}&quot;
 717     end
 718 
 719     def handleX86Add(kind)
 720         if operands.size == 3 and operands[1] == operands[2]
 721             unless Immediate.new(nil, 0) == operands[0]
 722                 $asm.puts &quot;add#{x86Suffix(kind)} #{orderOperands(operands[0].x86Operand(kind), operands[2].x86Operand(kind))}&quot;
 723             end
 724         elsif operands.size == 3 and operands[0].is_a? Immediate
 725             raise unless operands[1].is_a? RegisterID
 726             raise unless operands[2].is_a? RegisterID
 727             if operands[0].value == 0
 728                 if operands[1] != operands[2]
 729                     $asm.puts &quot;mov#{x86Suffix(kind)} #{orderOperands(operands[1].x86Operand(kind), operands[2].x86Operand(kind))}&quot;
 730                 end
 731             else
 732                 $asm.puts &quot;lea#{x86Suffix(kind)} #{orderOperands(offsetRegister(operands[0].value, operands[1].x86Operand(kind)), operands[2].x86Operand(kind))}&quot;
 733             end
 734         elsif operands.size == 3 and operands[0].is_a? RegisterID
 735             raise unless operands[1].is_a? RegisterID
 736             raise unless operands[2].is_a? RegisterID
 737             if operands[0] == operands[2]
 738                 $asm.puts &quot;add#{x86Suffix(kind)} #{orderOperands(operands[1].x86Operand(kind), operands[2].x86Operand(kind))}&quot;
 739             else
 740                 if !isIntelSyntax
 741                     $asm.puts &quot;lea#{x86Suffix(kind)} (#{operands[0].x86Operand(kind)}, #{operands[1].x86Operand(kind)}), #{operands[2].x86Operand(kind)}&quot;
 742                 else
 743                     $asm.puts &quot;lea#{x86Suffix(kind)} #{operands[2].x86Operand(kind)}, [#{operands[0].x86Operand(kind)} + #{operands[1].x86Operand(kind)}]&quot;
 744                 end
 745             end
 746         else
 747             unless Immediate.new(nil, 0) == operands[0]
 748                 $asm.puts &quot;add#{x86Suffix(kind)} #{x86Operands(kind, kind)}&quot;
 749             end
 750         end
 751     end
 752     
 753     def handleX86Sub(kind)
 754         if operands.size == 3
 755             if Immediate.new(nil, 0) == operands[1]
 756                 raise unless operands[0].is_a? RegisterID
 757                 raise unless operands[2].is_a? RegisterID
 758                 if operands[0] != operands[2]
 759                     $asm.puts &quot;mov#{x86Suffix(kind)} #{orderOperands(operands[0].x86Operand(kind), operands[2].x86Operand(kind))}&quot;
 760                 end
 761                 return
 762             end
 763             if operands[1] == operands[2]
 764                 $asm.puts &quot;neg#{x86Suffix(kind)} #{operands[2].x86Operand(kind)}&quot;
 765                 if Immediate.new(nil, 0) != operands[0]
 766                     $asm.puts &quot;add#{x86Suffix(kind)} #{orderOperands(operands[0].x86Operand(kind), operands[2].x86Operand(kind))}&quot;
 767                 end
 768                 return
 769             end
 770         end
 771 
 772         if operands.size == 2
 773             if Immediate.new(nil, 0) == operands[0]
 774                 return
 775             end
 776         end
 777 
 778         handleX86Op(&quot;sub#{x86Suffix(kind)}&quot;, kind)
 779     end
 780     
 781     def handleX86Mul(kind)
 782         if operands.size == 3 and operands[0].is_a? Immediate
 783             $asm.puts &quot;imul#{x86Suffix(kind)} #{x86Operands(kind, kind, kind)}&quot;
 784             return
 785         end
 786 
 787         if operands.size == 2 and operands[0].is_a? Immediate
 788             imm = operands[0].value
 789             if imm &gt; 0 and isPowerOfTwo(imm)
 790                 $asm.puts &quot;sal#{x86Suffix(kind)} #{orderOperands(Immediate.new(nil, Math.log2(imm).to_i).x86Operand(kind), operands[1].x86Operand(kind))}&quot;
 791                 return
 792             end
 793         end
 794 
 795         handleX86Op(&quot;imul#{x86Suffix(kind)}&quot;, kind)
 796     end
 797     
 798     def handleX86Peek()
 799         sp = RegisterID.new(nil, &quot;sp&quot;)
 800         opA = offsetRegister(operands[0].value * x86Bytes(:ptr), sp.x86Operand(:ptr))
 801         opB = operands[1].x86Operand(:ptr)
 802         $asm.puts &quot;mov#{x86Suffix(:ptr)} #{orderOperands(opA, opB)}&quot;
 803     end
 804 
 805     def handleX86Poke()
 806         sp = RegisterID.new(nil, &quot;sp&quot;)
 807         opA = operands[0].x86Operand(:ptr)
 808         opB = offsetRegister(operands[1].value * x86Bytes(:ptr), sp.x86Operand(:ptr))
 809         $asm.puts &quot;mov#{x86Suffix(:ptr)} #{orderOperands(opA, opB)}&quot;
 810     end
 811 
 812     def handleMove
 813         if Immediate.new(nil, 0) == operands[0] and operands[1].is_a? RegisterID
 814             if isX64
 815                 $asm.puts &quot;xor#{x86Suffix(:quad)} #{operands[1].x86Operand(:quad)}, #{operands[1].x86Operand(:quad)}&quot;
 816             else
 817                 $asm.puts &quot;xor#{x86Suffix(:ptr)} #{operands[1].x86Operand(:ptr)}, #{operands[1].x86Operand(:ptr)}&quot;
 818             end
 819         elsif operands[0] != operands[1]
 820             if isX64
 821                 $asm.puts &quot;mov#{x86Suffix(:quad)} #{x86Operands(:quad, :quad)}&quot;
 822             else
 823                 $asm.puts &quot;mov#{x86Suffix(:ptr)} #{x86Operands(:ptr, :ptr)}&quot;
 824             end
 825         end
 826     end
 827 
 828     def lowerX86
 829         raise unless $activeBackend == &quot;X86&quot;
 830         lowerX86Common
 831     end
 832 
 833     def lowerX86_WIN
 834         raise unless $activeBackend == &quot;X86_WIN&quot; 
 835         lowerX86Common
 836     end
 837     
 838     def lowerX86_64
 839         raise unless $activeBackend == &quot;X86_64&quot;
 840         lowerX86Common
 841     end
 842 
 843     def lowerX86_64_WIN
 844         raise unless $activeBackend == &quot;X86_64_WIN&quot;
 845         lowerX86Common
 846     end
 847 
 848     def lowerX86Common
 849         case opcode
 850         when &quot;addi&quot;
 851             handleX86Add(:int)
 852         when &quot;addp&quot;
 853             handleX86Add(:ptr)
 854         when &quot;addq&quot;
 855             handleX86Add(:quad)
 856         when &quot;andi&quot;
 857             handleX86Op(&quot;and#{x86Suffix(:int)}&quot;, :int)
 858         when &quot;andp&quot;
 859             handleX86Op(&quot;and#{x86Suffix(:ptr)}&quot;, :ptr)
 860         when &quot;andq&quot;
 861             handleX86Op(&quot;and#{x86Suffix(:quad)}&quot;, :quad)
 862         when &quot;lshifti&quot;
 863             handleX86Shift(&quot;sal#{x86Suffix(:int)}&quot;, :int)
 864         when &quot;lshiftp&quot;
 865             handleX86Shift(&quot;sal#{x86Suffix(:ptr)}&quot;, :ptr)
 866         when &quot;lshiftq&quot;
 867             handleX86Shift(&quot;sal#{x86Suffix(:quad)}&quot;, :quad)
 868         when &quot;muli&quot;
 869             handleX86Mul(:int)
 870         when &quot;mulp&quot;
 871             handleX86Mul(:ptr)
 872         when &quot;mulq&quot;
 873             handleX86Mul(:quad)
 874         when &quot;negi&quot;
 875             $asm.puts &quot;neg#{x86Suffix(:int)} #{x86Operands(:int)}&quot;
 876         when &quot;negp&quot;
 877             $asm.puts &quot;neg#{x86Suffix(:ptr)} #{x86Operands(:ptr)}&quot;
 878         when &quot;negq&quot;
 879             $asm.puts &quot;neg#{x86Suffix(:quad)} #{x86Operands(:quad)}&quot;
 880         when &quot;noti&quot;
 881             $asm.puts &quot;not#{x86Suffix(:int)} #{x86Operands(:int)}&quot;
 882         when &quot;ori&quot;
 883             handleX86Op(&quot;or#{x86Suffix(:int)}&quot;, :int)
 884         when &quot;orp&quot;
 885             handleX86Op(&quot;or#{x86Suffix(:ptr)}&quot;, :ptr)
 886         when &quot;orq&quot;
 887             handleX86Op(&quot;or#{x86Suffix(:quad)}&quot;, :quad)
 888         when &quot;rshifti&quot;
 889             handleX86Shift(&quot;sar#{x86Suffix(:int)}&quot;, :int)
 890         when &quot;rshiftp&quot;
 891             handleX86Shift(&quot;sar#{x86Suffix(:ptr)}&quot;, :ptr)
 892         when &quot;rshiftq&quot;
 893             handleX86Shift(&quot;sar#{x86Suffix(:quad)}&quot;, :quad)
 894         when &quot;urshifti&quot;
 895             handleX86Shift(&quot;shr#{x86Suffix(:int)}&quot;, :int)
 896         when &quot;urshiftp&quot;
 897             handleX86Shift(&quot;shr#{x86Suffix(:ptr)}&quot;, :ptr)
 898         when &quot;urshiftq&quot;
 899             handleX86Shift(&quot;shr#{x86Suffix(:quad)}&quot;, :quad)
 900         when &quot;subi&quot;
 901             handleX86Sub(:int)
 902         when &quot;subp&quot;
 903             handleX86Sub(:ptr)
 904         when &quot;subq&quot;
 905             handleX86Sub(:quad)
 906         when &quot;xori&quot;
 907             handleX86Op(&quot;xor#{x86Suffix(:int)}&quot;, :int)
 908         when &quot;xorp&quot;
 909             handleX86Op(&quot;xor#{x86Suffix(:ptr)}&quot;, :ptr)
 910         when &quot;xorq&quot;
 911             handleX86Op(&quot;xor#{x86Suffix(:quad)}&quot;, :quad)
 912         when &quot;leap&quot;
 913             emitX86Lea(operands[0], operands[1], :ptr)
 914         when &quot;loadi&quot;
 915             $asm.puts &quot;mov#{x86Suffix(:int)} #{x86LoadOperands(:int, :int)}&quot;
 916         when &quot;storei&quot;
 917             $asm.puts &quot;mov#{x86Suffix(:int)} #{x86Operands(:int, :int)}&quot;
 918         when &quot;loadis&quot;
 919             if isX64
 920                 if !isIntelSyntax
 921                     $asm.puts &quot;movslq #{x86LoadOperands(:int, :quad)}&quot;
 922                 else
 923                     $asm.puts &quot;movsxd #{x86LoadOperands(:int, :quad)}&quot;
 924                 end
 925             else
 926                 $asm.puts &quot;mov#{x86Suffix(:int)} #{x86LoadOperands(:int, :int)}&quot;
 927             end
 928         when &quot;loadp&quot;
 929             $asm.puts &quot;mov#{x86Suffix(:ptr)} #{x86LoadOperands(:ptr, :ptr)}&quot;
 930         when &quot;storep&quot;
 931             $asm.puts &quot;mov#{x86Suffix(:ptr)} #{x86Operands(:ptr, :ptr)}&quot;
 932         when &quot;loadq&quot;
 933             $asm.puts &quot;mov#{x86Suffix(:quad)} #{x86LoadOperands(:quad, :quad)}&quot;
 934         when &quot;storeq&quot;
 935             $asm.puts &quot;mov#{x86Suffix(:quad)} #{x86Operands(:quad, :quad)}&quot;
 936         when &quot;loadb&quot;
 937             if !isIntelSyntax
 938                 $asm.puts &quot;movzbl #{x86LoadOperands(:byte, :int)}&quot;
 939             else
 940                 $asm.puts &quot;movzx #{x86LoadOperands(:byte, :int)}&quot;
 941             end
 942         when &quot;loadbsi&quot;
 943             if !isIntelSyntax
 944                 $asm.puts &quot;movsbl #{x86LoadOperands(:byte, :int)}&quot;
 945             else
 946                 $asm.puts &quot;movsx #{x86LoadOperands(:byte, :int)}&quot;
 947             end
 948         when &quot;loadbsq&quot;
 949             if !isIntelSyntax
 950                 $asm.puts &quot;movsbq #{x86LoadOperands(:byte, :quad)}&quot;
 951             else
 952                 $asm.puts &quot;movsx #{x86LoadOperands(:byte, :quad)}&quot;
 953             end
 954         when &quot;loadh&quot;
 955             if !isIntelSyntax
 956                 $asm.puts &quot;movzwl #{x86LoadOperands(:half, :int)}&quot;
 957             else
 958                 $asm.puts &quot;movzx #{x86LoadOperands(:half, :int)}&quot;
 959             end
 960         when &quot;loadhsi&quot;
 961             if !isIntelSyntax
 962                 $asm.puts &quot;movswl #{x86LoadOperands(:half, :int)}&quot;
 963             else
 964                 $asm.puts &quot;movsx #{x86LoadOperands(:half, :int)}&quot;
 965             end
 966         when &quot;loadhsq&quot;
 967             if !isIntelSyntax
 968                 $asm.puts &quot;movswq #{x86LoadOperands(:half, :quad)}&quot;
 969             else
 970                 $asm.puts &quot;movsx #{x86LoadOperands(:half, :quad)}&quot;
 971             end
 972         when &quot;storeb&quot;
 973             $asm.puts &quot;mov#{x86Suffix(:byte)} #{x86Operands(:byte, :byte)}&quot;
 974         when &quot;loadd&quot;
 975             $asm.puts &quot;movsd #{x86Operands(:double, :double)}&quot;
 976         when &quot;moved&quot;
 977             $asm.puts &quot;movsd #{x86Operands(:double, :double)}&quot;
 978         when &quot;stored&quot;
 979             $asm.puts &quot;movsd #{x86Operands(:double, :double)}&quot;
 980         when &quot;addd&quot;
 981             $asm.puts &quot;addsd #{x86Operands(:double, :double)}&quot;
 982         when &quot;muld&quot;
 983             $asm.puts &quot;mulsd #{x86Operands(:double, :double)}&quot;
 984         when &quot;subd&quot;
 985             $asm.puts &quot;subsd #{x86Operands(:double, :double)}&quot;
 986         when &quot;divd&quot;
 987             $asm.puts &quot;divsd #{x86Operands(:double, :double)}&quot;
 988         when &quot;sqrtd&quot;
 989             $asm.puts &quot;sqrtsd #{operands[0].x86Operand(:double)}, #{operands[1].x86Operand(:double)}&quot;
 990         when &quot;ci2d&quot;
 991             $asm.puts &quot;cvtsi2sd #{orderOperands(operands[0].x86Operand(:int), operands[1].x86Operand(:double))}&quot;
 992         when &quot;bdeq&quot;
 993             $asm.puts &quot;ucomisd #{orderOperands(operands[0].x86Operand(:double), operands[1].x86Operand(:double))}&quot;
 994             if operands[0] == operands[1]
 995                 # This is just a jump ordered, which is a jnp.
 996                 $asm.puts &quot;jnp #{operands[2].asmLabel}&quot;
 997             else
 998                 isUnordered = LocalLabel.unique(&quot;bdeq&quot;)
 999                 $asm.puts &quot;jp #{LabelReference.new(codeOrigin, isUnordered).asmLabel}&quot;
1000                 $asm.puts &quot;je #{LabelReference.new(codeOrigin, operands[2]).asmLabel}&quot;
1001                 isUnordered.lower(&quot;X86&quot;)
1002             end
1003         when &quot;bdneq&quot;
1004             handleX86DoubleBranch(&quot;jne&quot;, :normal)
1005         when &quot;bdgt&quot;
1006             handleX86DoubleBranch(&quot;ja&quot;, :normal)
1007         when &quot;bdgteq&quot;
1008             handleX86DoubleBranch(&quot;jae&quot;, :normal)
1009         when &quot;bdlt&quot;
1010             handleX86DoubleBranch(&quot;ja&quot;, :reverse)
1011         when &quot;bdlteq&quot;
1012             handleX86DoubleBranch(&quot;jae&quot;, :reverse)
1013         when &quot;bdequn&quot;
1014             handleX86DoubleBranch(&quot;je&quot;, :normal)
1015         when &quot;bdnequn&quot;
1016             $asm.puts &quot;ucomisd #{orderOperands(operands[0].x86Operand(:double), operands[1].x86Operand(:double))}&quot;
1017             if operands[0] == operands[1]
1018                 # This is just a jump unordered, which is a jp.
1019                 $asm.puts &quot;jp #{operands[2].asmLabel}&quot;
1020             else
1021                 isUnordered = LocalLabel.unique(&quot;bdnequn&quot;)
1022                 isEqual = LocalLabel.unique(&quot;bdnequn&quot;)
1023                 $asm.puts &quot;jp #{LabelReference.new(codeOrigin, isUnordered).asmLabel}&quot;
1024                 $asm.puts &quot;je #{LabelReference.new(codeOrigin, isEqual).asmLabel}&quot;
1025                 isUnordered.lower(&quot;X86&quot;)
1026                 $asm.puts &quot;jmp #{operands[2].asmLabel}&quot;
1027                 isEqual.lower(&quot;X86&quot;)
1028             end
1029         when &quot;bdgtun&quot;
1030             handleX86DoubleBranch(&quot;jb&quot;, :reverse)
1031         when &quot;bdgtequn&quot;
1032             handleX86DoubleBranch(&quot;jbe&quot;, :reverse)
1033         when &quot;bdltun&quot;
1034             handleX86DoubleBranch(&quot;jb&quot;, :normal)
1035         when &quot;bdltequn&quot;
1036             handleX86DoubleBranch(&quot;jbe&quot;, :normal)
1037         when &quot;btd2i&quot;
1038             $asm.puts &quot;cvttsd2si #{operands[0].x86Operand(:double)}, #{operands[1].x86Operand(:int)}&quot;
1039             $asm.puts &quot;cmpl $0x80000000 #{operands[1].x86Operand(:int)}&quot;
1040             $asm.puts &quot;je #{operands[2].asmLabel}&quot;
1041         when &quot;td2i&quot;
1042             $asm.puts &quot;cvttsd2si #{operands[0].x86Operand(:double)}, #{operands[1].x86Operand(:int)}&quot;
1043         when &quot;bcd2i&quot;
1044             $asm.puts &quot;cvttsd2si #{operands[0].x86Operand(:double)}, #{operands[1].x86Operand(:int)}&quot;
1045             $asm.puts &quot;test#{x86Suffix(:int)} #{operands[1].x86Operand(:int)}, #{operands[1].x86Operand(:int)}&quot;
1046             $asm.puts &quot;je #{operands[2].asmLabel}&quot;
1047             $asm.puts &quot;cvtsi2sd #{operands[1].x86Operand(:int)}, %xmm7&quot;
1048             $asm.puts &quot;ucomisd #{operands[0].x86Operand(:double)}, %xmm7&quot;
1049             $asm.puts &quot;jp #{operands[2].asmLabel}&quot;
1050             $asm.puts &quot;jne #{operands[2].asmLabel}&quot;
1051         when &quot;movdz&quot;
1052             $asm.puts &quot;xorpd #{operands[0].x86Operand(:double)}, #{operands[0].x86Operand(:double)}&quot;
1053         when &quot;pop&quot;
1054             operands.each {
1055                 | op |
1056                 $asm.puts &quot;pop #{op.x86Operand(:ptr)}&quot;
1057             }
1058         when &quot;push&quot;
1059             operands.each {
1060                 | op |
1061                 $asm.puts &quot;push #{op.x86Operand(:ptr)}&quot;
1062             }
1063         when &quot;move&quot;
1064             handleMove
1065         when &quot;sxi2q&quot;
1066             if !isIntelSyntax
1067                 $asm.puts &quot;movslq #{operands[0].x86Operand(:int)}, #{operands[1].x86Operand(:quad)}&quot;
1068             else
1069                 $asm.puts &quot;movsxd #{orderOperands(operands[0].x86Operand(:int), operands[1].x86Operand(:quad))}&quot;
1070             end
1071         when &quot;zxi2q&quot;
1072             $asm.puts &quot;mov#{x86Suffix(:int)} #{orderOperands(operands[0].x86Operand(:int), operands[1].x86Operand(:int))}&quot;
1073         when &quot;nop&quot;
1074             $asm.puts &quot;nop&quot;
1075         when &quot;bieq&quot;
1076             handleX86IntBranch(&quot;je&quot;, :int)
1077         when &quot;bpeq&quot;
1078             handleX86IntBranch(&quot;je&quot;, :ptr)
1079         when &quot;bqeq&quot;
1080             handleX86IntBranch(&quot;je&quot;, :quad)
1081         when &quot;bineq&quot;
1082             handleX86IntBranch(&quot;jne&quot;, :int)
1083         when &quot;bpneq&quot;
1084             handleX86IntBranch(&quot;jne&quot;, :ptr)
1085         when &quot;bqneq&quot;
1086             handleX86IntBranch(&quot;jne&quot;, :quad)
1087         when &quot;bia&quot;
1088             handleX86IntBranch(&quot;ja&quot;, :int)
1089         when &quot;bpa&quot;
1090             handleX86IntBranch(&quot;ja&quot;, :ptr)
1091         when &quot;bqa&quot;
1092             handleX86IntBranch(&quot;ja&quot;, :quad)
1093         when &quot;biaeq&quot;
1094             handleX86IntBranch(&quot;jae&quot;, :int)
1095         when &quot;bpaeq&quot;
1096             handleX86IntBranch(&quot;jae&quot;, :ptr)
1097         when &quot;bqaeq&quot;
1098             handleX86IntBranch(&quot;jae&quot;, :quad)
1099         when &quot;bib&quot;
1100             handleX86IntBranch(&quot;jb&quot;, :int)
1101         when &quot;bpb&quot;
1102             handleX86IntBranch(&quot;jb&quot;, :ptr)
1103         when &quot;bqb&quot;
1104             handleX86IntBranch(&quot;jb&quot;, :quad)
1105         when &quot;bibeq&quot;
1106             handleX86IntBranch(&quot;jbe&quot;, :int)
1107         when &quot;bpbeq&quot;
1108             handleX86IntBranch(&quot;jbe&quot;, :ptr)
1109         when &quot;bqbeq&quot;
1110             handleX86IntBranch(&quot;jbe&quot;, :quad)
1111         when &quot;bigt&quot;
1112             handleX86IntBranch(&quot;jg&quot;, :int)
1113         when &quot;bpgt&quot;
1114             handleX86IntBranch(&quot;jg&quot;, :ptr)
1115         when &quot;bqgt&quot;
1116             handleX86IntBranch(&quot;jg&quot;, :quad)
1117         when &quot;bigteq&quot;
1118             handleX86IntBranch(&quot;jge&quot;, :int)
1119         when &quot;bpgteq&quot;
1120             handleX86IntBranch(&quot;jge&quot;, :ptr)
1121         when &quot;bqgteq&quot;
1122             handleX86IntBranch(&quot;jge&quot;, :quad)
1123         when &quot;bilt&quot;
1124             handleX86IntBranch(&quot;jl&quot;, :int)
1125         when &quot;bplt&quot;
1126             handleX86IntBranch(&quot;jl&quot;, :ptr)
1127         when &quot;bqlt&quot;
1128             handleX86IntBranch(&quot;jl&quot;, :quad)
1129         when &quot;bilteq&quot;
1130             handleX86IntBranch(&quot;jle&quot;, :int)
1131         when &quot;bplteq&quot;
1132             handleX86IntBranch(&quot;jle&quot;, :ptr)
1133         when &quot;bqlteq&quot;
1134             handleX86IntBranch(&quot;jle&quot;, :quad)
1135         when &quot;bbeq&quot;
1136             handleX86IntBranch(&quot;je&quot;, :byte)
1137         when &quot;bbneq&quot;
1138             handleX86IntBranch(&quot;jne&quot;, :byte)
1139         when &quot;bba&quot;
1140             handleX86IntBranch(&quot;ja&quot;, :byte)
1141         when &quot;bbaeq&quot;
1142             handleX86IntBranch(&quot;jae&quot;, :byte)
1143         when &quot;bbb&quot;
1144             handleX86IntBranch(&quot;jb&quot;, :byte)
1145         when &quot;bbbeq&quot;
1146             handleX86IntBranch(&quot;jbe&quot;, :byte)
1147         when &quot;bbgt&quot;
1148             handleX86IntBranch(&quot;jg&quot;, :byte)
1149         when &quot;bbgteq&quot;
1150             handleX86IntBranch(&quot;jge&quot;, :byte)
1151         when &quot;bblt&quot;
1152             handleX86IntBranch(&quot;jl&quot;, :byte)
1153         when &quot;bblteq&quot;
1154             handleX86IntBranch(&quot;jlteq&quot;, :byte)
1155         when &quot;btis&quot;
1156             handleX86BranchTest(&quot;js&quot;, :int)
1157         when &quot;btps&quot;
1158             handleX86BranchTest(&quot;js&quot;, :ptr)
1159         when &quot;btqs&quot;
1160             handleX86BranchTest(&quot;js&quot;, :quad)
1161         when &quot;btiz&quot;
1162             handleX86BranchTest(&quot;jz&quot;, :int)
1163         when &quot;btpz&quot;
1164             handleX86BranchTest(&quot;jz&quot;, :ptr)
1165         when &quot;btqz&quot;
1166             handleX86BranchTest(&quot;jz&quot;, :quad)
1167         when &quot;btinz&quot;
1168             handleX86BranchTest(&quot;jnz&quot;, :int)
1169         when &quot;btpnz&quot;
1170             handleX86BranchTest(&quot;jnz&quot;, :ptr)
1171         when &quot;btqnz&quot;
1172             handleX86BranchTest(&quot;jnz&quot;, :quad)
1173         when &quot;btbs&quot;
1174             handleX86BranchTest(&quot;js&quot;, :byte)
1175         when &quot;btbz&quot;
1176             handleX86BranchTest(&quot;jz&quot;, :byte)
1177         when &quot;btbnz&quot;
1178             handleX86BranchTest(&quot;jnz&quot;, :byte)
1179         when &quot;jmp&quot;
1180             $asm.puts &quot;jmp #{operands[0].x86CallOperand(:ptr)}&quot;
1181         when &quot;baddio&quot;
1182             handleX86OpBranch(&quot;add#{x86Suffix(:int)}&quot;, &quot;jo&quot;, :int)
1183         when &quot;baddpo&quot;
1184             handleX86OpBranch(&quot;add#{x86Suffix(:ptr)}&quot;, &quot;jo&quot;, :ptr)
1185         when &quot;baddqo&quot;
1186             handleX86OpBranch(&quot;add#{x86Suffix(:quad)}&quot;, &quot;jo&quot;, :quad)
1187         when &quot;baddis&quot;
1188             handleX86OpBranch(&quot;add#{x86Suffix(:int)}&quot;, &quot;js&quot;, :int)
1189         when &quot;baddps&quot;
1190             handleX86OpBranch(&quot;add#{x86Suffix(:ptr)}&quot;, &quot;js&quot;, :ptr)
1191         when &quot;baddqs&quot;
1192             handleX86OpBranch(&quot;add#{x86Suffix(:quad)}&quot;, &quot;js&quot;, :quad)
1193         when &quot;baddiz&quot;
1194             handleX86OpBranch(&quot;add#{x86Suffix(:int)}&quot;, &quot;jz&quot;, :int)
1195         when &quot;baddpz&quot;
1196             handleX86OpBranch(&quot;add#{x86Suffix(:ptr)}&quot;, &quot;jz&quot;, :ptr)
1197         when &quot;baddqz&quot;
1198             handleX86OpBranch(&quot;add#{x86Suffix(:quad)}&quot;, &quot;jz&quot;, :quad)
1199         when &quot;baddinz&quot;
1200             handleX86OpBranch(&quot;add#{x86Suffix(:int)}&quot;, &quot;jnz&quot;, :int)
1201         when &quot;baddpnz&quot;
1202             handleX86OpBranch(&quot;add#{x86Suffix(:ptr)}&quot;, &quot;jnz&quot;, :ptr)
1203         when &quot;baddqnz&quot;
1204             handleX86OpBranch(&quot;add#{x86Suffix(:quad)}&quot;, &quot;jnz&quot;, :quad)
1205         when &quot;bsubio&quot;
1206             handleX86SubBranch(&quot;jo&quot;, :int)
1207         when &quot;bsubis&quot;
1208             handleX86SubBranch(&quot;js&quot;, :int)
1209         when &quot;bsubiz&quot;
1210             handleX86SubBranch(&quot;jz&quot;, :int)
1211         when &quot;bsubinz&quot;
1212             handleX86SubBranch(&quot;jnz&quot;, :int)
1213         when &quot;bmulio&quot;
1214             handleX86OpBranch(&quot;imul#{x86Suffix(:int)}&quot;, &quot;jo&quot;, :int)
1215         when &quot;bmulis&quot;
1216             handleX86OpBranch(&quot;imul#{x86Suffix(:int)}&quot;, &quot;js&quot;, :int)
1217         when &quot;bmuliz&quot;
1218             handleX86OpBranch(&quot;imul#{x86Suffix(:int)}&quot;, &quot;jz&quot;, :int)
1219         when &quot;bmulinz&quot;
1220             handleX86OpBranch(&quot;imul#{x86Suffix(:int)}&quot;, &quot;jnz&quot;, :int)
1221         when &quot;borio&quot;
1222             handleX86OpBranch(&quot;orl&quot;, &quot;jo&quot;, :int)
1223         when &quot;boris&quot;
1224             handleX86OpBranch(&quot;orl&quot;, &quot;js&quot;, :int)
1225         when &quot;boriz&quot;
1226             handleX86OpBranch(&quot;orl&quot;, &quot;jz&quot;, :int)
1227         when &quot;borinz&quot;
1228             handleX86OpBranch(&quot;orl&quot;, &quot;jnz&quot;, :int)
1229         when &quot;break&quot;
1230             $asm.puts &quot;int #{const(3)}&quot;
1231         when &quot;call&quot;
1232             op = operands[0].x86CallOperand(:ptr)
1233             if operands[0].is_a? LabelReference
1234                 operands[0].used
1235             end
1236             $asm.puts &quot;call #{op}&quot;
1237         when &quot;ret&quot;
1238             $asm.puts &quot;ret&quot;
1239         when &quot;cieq&quot;
1240             handleX86IntCompareSet(&quot;sete&quot;, :int)
1241         when &quot;cbeq&quot;
1242             handleX86IntCompareSet(&quot;sete&quot;, :byte)
1243         when &quot;cpeq&quot;
1244             handleX86IntCompareSet(&quot;sete&quot;, :ptr)
1245         when &quot;cqeq&quot;
1246             handleX86IntCompareSet(&quot;sete&quot;, :quad)
1247         when &quot;cineq&quot;
1248             handleX86IntCompareSet(&quot;setne&quot;, :int)
1249         when &quot;cbneq&quot;
1250             handleX86IntCompareSet(&quot;setne&quot;, :byte)
1251         when &quot;cpneq&quot;
1252             handleX86IntCompareSet(&quot;setne&quot;, :ptr)
1253         when &quot;cqneq&quot;
1254             handleX86IntCompareSet(&quot;setne&quot;, :quad)
1255         when &quot;cia&quot;
1256             handleX86IntCompareSet(&quot;seta&quot;, :int)
1257         when &quot;cba&quot;
1258             handleX86IntCompareSet(&quot;seta&quot;, :byte)
1259         when &quot;cpa&quot;
1260             handleX86IntCompareSet(&quot;seta&quot;, :ptr)
1261         when &quot;cqa&quot;
1262             handleX86IntCompareSet(&quot;seta&quot;, :quad)
1263         when &quot;ciaeq&quot;
1264             handleX86IntCompareSet(&quot;setae&quot;, :int)
1265         when &quot;cbaeq&quot;
1266             handleX86IntCompareSet(&quot;setae&quot;, :byte)
1267         when &quot;cpaeq&quot;
1268             handleX86IntCompareSet(&quot;setae&quot;, :ptr)
1269         when &quot;cqaeq&quot;
1270             handleX86IntCompareSet(&quot;setae&quot;, :quad)
1271         when &quot;cib&quot;
1272             handleX86IntCompareSet(&quot;setb&quot;, :int)
1273         when &quot;cbb&quot;
1274             handleX86IntCompareSet(&quot;setb&quot;, :byte)
1275         when &quot;cpb&quot;
1276             handleX86IntCompareSet(&quot;setb&quot;, :ptr)
1277         when &quot;cqb&quot;
1278             handleX86IntCompareSet(&quot;setb&quot;, :quad)
1279         when &quot;cibeq&quot;
1280             handleX86IntCompareSet(&quot;setbe&quot;, :int)
1281         when &quot;cbbeq&quot;
1282             handleX86IntCompareSet(&quot;setbe&quot;, :byte)
1283         when &quot;cpbeq&quot;
1284             handleX86IntCompareSet(&quot;setbe&quot;, :ptr)
1285         when &quot;cqbeq&quot;
1286             handleX86IntCompareSet(&quot;setbe&quot;, :quad)
1287         when &quot;cigt&quot;
1288             handleX86IntCompareSet(&quot;setg&quot;, :int)
1289         when &quot;cbgt&quot;
1290             handleX86IntCompareSet(&quot;setg&quot;, :byte)
1291         when &quot;cpgt&quot;
1292             handleX86IntCompareSet(&quot;setg&quot;, :ptr)
1293         when &quot;cqgt&quot;
1294             handleX86IntCompareSet(&quot;setg&quot;, :quad)
1295         when &quot;cigteq&quot;
1296             handleX86IntCompareSet(&quot;setge&quot;, :int)
1297         when &quot;cbgteq&quot;
1298             handleX86IntCompareSet(&quot;setge&quot;, :byte)
1299         when &quot;cpgteq&quot;
1300             handleX86IntCompareSet(&quot;setge&quot;, :ptr)
1301         when &quot;cqgteq&quot;
1302             handleX86IntCompareSet(&quot;setge&quot;, :quad)
1303         when &quot;cilt&quot;
1304             handleX86IntCompareSet(&quot;setl&quot;, :int)
1305         when &quot;cblt&quot;
1306             handleX86IntCompareSet(&quot;setl&quot;, :byte)
1307         when &quot;cplt&quot;
1308             handleX86IntCompareSet(&quot;setl&quot;, :ptr)
1309         when &quot;cqlt&quot;
1310             handleX86IntCompareSet(&quot;setl&quot;, :quad)
1311         when &quot;cilteq&quot;
1312             handleX86IntCompareSet(&quot;setle&quot;, :int)
1313         when &quot;cblteq&quot;
1314             handleX86IntCompareSet(&quot;setle&quot;, :byte)
1315         when &quot;cplteq&quot;
1316             handleX86IntCompareSet(&quot;setle&quot;, :ptr)
1317         when &quot;cqlteq&quot;
1318             handleX86IntCompareSet(&quot;setle&quot;, :quad)
1319         when &quot;tis&quot;
1320             handleX86SetTest(&quot;sets&quot;, :int)
1321         when &quot;tiz&quot;
1322             handleX86SetTest(&quot;setz&quot;, :int)
1323         when &quot;tinz&quot;
1324             handleX86SetTest(&quot;setnz&quot;, :int)
1325         when &quot;tps&quot;
1326             handleX86SetTest(&quot;sets&quot;, :ptr)
1327         when &quot;tpz&quot;
1328             handleX86SetTest(&quot;setz&quot;, :ptr)
1329         when &quot;tpnz&quot;
1330             handleX86SetTest(&quot;setnz&quot;, :ptr)
1331         when &quot;tqs&quot;
1332             handleX86SetTest(&quot;sets&quot;, :quad)
1333         when &quot;tqz&quot;
1334             handleX86SetTest(&quot;setz&quot;, :quad)
1335         when &quot;tqnz&quot;
1336             handleX86SetTest(&quot;setnz&quot;, :quad)
1337         when &quot;tbs&quot;
1338             handleX86SetTest(&quot;sets&quot;, :byte)
1339         when &quot;tbz&quot;
1340             handleX86SetTest(&quot;setz&quot;, :byte)
1341         when &quot;tbnz&quot;
1342             handleX86SetTest(&quot;setnz&quot;, :byte)
1343         when &quot;peek&quot;
1344             handleX86Peek()
1345         when &quot;poke&quot;
1346             handleX86Poke()
1347         when &quot;cdqi&quot;
1348             $asm.puts &quot;cdq&quot;
1349         when &quot;idivi&quot;
1350             $asm.puts &quot;idiv#{x86Suffix(:int)} #{operands[0].x86Operand(:int)}&quot;
1351         when &quot;fii2d&quot;
1352             $asm.puts &quot;movd #{operands[0].x86Operand(:int)}, #{operands[2].x86Operand(:double)}&quot;
1353             $asm.puts &quot;movd #{operands[1].x86Operand(:int)}, %xmm7&quot;
1354             $asm.puts &quot;psllq $32, %xmm7&quot;
1355             $asm.puts &quot;por %xmm7, #{operands[2].x86Operand(:double)}&quot;
1356         when &quot;fd2ii&quot;
1357             $asm.puts &quot;movd #{operands[0].x86Operand(:double)}, #{operands[1].x86Operand(:int)}&quot;
1358             $asm.puts &quot;movsd #{operands[0].x86Operand(:double)}, %xmm7&quot;
1359             $asm.puts &quot;psrlq $32, %xmm7&quot;
1360             $asm.puts &quot;movd %xmm7, #{operands[2].x86Operand(:int)}&quot;
1361         when &quot;fq2d&quot;
1362             if !isIntelSyntax
1363                 $asm.puts &quot;movq #{operands[0].x86Operand(:quad)}, #{operands[1].x86Operand(:double)}&quot;
1364             else
1365                 # MASM does not accept register operands with movq.
1366                 # Debugging shows that movd actually moves a qword when using MASM.
1367                 $asm.puts &quot;movd #{operands[1].x86Operand(:double)}, #{operands[0].x86Operand(:quad)}&quot;
1368             end
1369         when &quot;fd2q&quot;
1370             if !isIntelSyntax
1371                 $asm.puts &quot;movq #{operands[0].x86Operand(:double)}, #{operands[1].x86Operand(:quad)}&quot;
1372             else
1373                 # MASM does not accept register operands with movq.
1374                 # Debugging shows that movd actually moves a qword when using MASM.
1375                 $asm.puts &quot;movd #{operands[1].x86Operand(:quad)}, #{operands[0].x86Operand(:double)}&quot;
1376             end
1377         when &quot;bo&quot;
1378             $asm.puts &quot;jo #{operands[0].asmLabel}&quot;
1379         when &quot;bs&quot;
1380             $asm.puts &quot;js #{operands[0].asmLabel}&quot;
1381         when &quot;bz&quot;
1382             $asm.puts &quot;jz #{operands[0].asmLabel}&quot;
1383         when &quot;bnz&quot;
1384             $asm.puts &quot;jnz #{operands[0].asmLabel}&quot;
1385         when &quot;leai&quot;
1386             $asm.puts &quot;lea#{x86Suffix(:int)} #{orderOperands(operands[0].x86AddressOperand(:int), operands[1].x86Operand(:int))}&quot;
1387         when &quot;leap&quot;
1388             $asm.puts &quot;lea#{x86Suffix(:ptr)} #{orderOperands(operands[0].x86AddressOperand(:ptr), operands[1].x86Operand(:ptr))}&quot;
1389         when &quot;memfence&quot;
1390             sp = RegisterID.new(nil, &quot;sp&quot;)
1391             if isIntelSyntax
1392                 $asm.puts &quot;mfence&quot;
1393             else
1394                 $asm.puts &quot;lock; orl $0, (#{sp.x86Operand(:ptr)})&quot;
1395             end
1396         else
1397             lowerDefault
1398         end
1399     end
1400 end
1401 
    </pre>
  </body>
</html>