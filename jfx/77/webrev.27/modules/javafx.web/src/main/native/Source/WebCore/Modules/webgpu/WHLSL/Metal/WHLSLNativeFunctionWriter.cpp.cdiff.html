<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/Modules/webgpu/WHLSL/Metal/WHLSLNativeFunctionWriter.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="WHLSLMetalCodeGenerator.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="WHLSLNativeFunctionWriter.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/Modules/webgpu/WHLSL/Metal/WHLSLNativeFunctionWriter.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 26,15 ***</span>
<span class="line-new-header">--- 26,22 ---</span>
  #include &quot;config.h&quot;
  #include &quot;WHLSLNativeFunctionWriter.h&quot;
  
  #if ENABLE(WEBGPU)
  
<span class="line-added">+ #include &quot;NotImplemented.h&quot;</span>
  #include &quot;WHLSLAddressSpace.h&quot;
<span class="line-added">+ #include &quot;WHLSLArrayType.h&quot;</span>
<span class="line-added">+ #include &quot;WHLSLEnumerationDefinition.h&quot;</span>
<span class="line-added">+ #include &quot;WHLSLInferTypes.h&quot;</span>
<span class="line-added">+ #include &quot;WHLSLIntrinsics.h&quot;</span>
  #include &quot;WHLSLNamedType.h&quot;
  #include &quot;WHLSLNativeFunctionDeclaration.h&quot;
  #include &quot;WHLSLNativeTypeDeclaration.h&quot;
  #include &quot;WHLSLPointerType.h&quot;
<span class="line-added">+ #include &quot;WHLSLStructureDefinition.h&quot;</span>
<span class="line-added">+ #include &quot;WHLSLTypeDefinition.h&quot;</span>
  #include &quot;WHLSLTypeNamer.h&quot;
  #include &quot;WHLSLUnnamedType.h&quot;
  #include &quot;WHLSLVariableDeclaration.h&quot;
  #include &lt;wtf/text/StringBuilder.h&gt;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 42,19 ***</span>
  
  namespace WHLSL {
  
  namespace Metal {
  
<span class="line-removed">- static String getNativeName(AST::UnnamedType&amp; unnamedType, TypeNamer&amp; typeNamer)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     ASSERT(is&lt;AST::NamedType&gt;(unnamedType.unifyNode()));</span>
<span class="line-removed">-     auto&amp; namedType = downcast&lt;AST::NamedType&gt;(unnamedType.unifyNode());</span>
<span class="line-removed">-     ASSERT(is&lt;AST::NativeTypeDeclaration&gt;(namedType));</span>
<span class="line-removed">-     auto&amp; nativeTypeDeclaration = downcast&lt;AST::NativeTypeDeclaration&gt;(namedType);</span>
<span class="line-removed">-     return typeNamer.mangledNameForType(nativeTypeDeclaration);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  static String mapFunctionName(String&amp; functionName)
  {
      if (functionName == &quot;ddx&quot;)
          return &quot;dfdx&quot;_str;
      if (functionName == &quot;ddy&quot;)
<span class="line-new-header">--- 49,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 66,25 ***</span>
      if (functionName == &quot;asfloat&quot;)
          return &quot;as_type&lt;float&gt;&quot;_str;
      return functionName;
  }
  
<span class="line-removed">- static String convertAddressSpace(AST::AddressSpace addressSpace)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     switch (addressSpace) {</span>
<span class="line-removed">-     case AST::AddressSpace::Constant:</span>
<span class="line-removed">-         return &quot;constant&quot;_str;</span>
<span class="line-removed">-     case AST::AddressSpace::Device:</span>
<span class="line-removed">-         return &quot;device&quot;_str;</span>
<span class="line-removed">-     case AST::AddressSpace::Threadgroup:</span>
<span class="line-removed">-         return &quot;threadgroup&quot;_str;</span>
<span class="line-removed">-     default:</span>
<span class="line-removed">-         ASSERT(addressSpace == AST::AddressSpace::Thread);</span>
<span class="line-removed">-         return &quot;thread&quot;_str;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  static String atomicName(String input)
  {
      if (input == &quot;Add&quot;)
          return &quot;fetch_add&quot;_str;
      if (input == &quot;And&quot;)
<span class="line-new-header">--- 64,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 99,99 ***</span>
          return &quot;fetch_or&quot;_str;
      ASSERT(input == &quot;Xor&quot;);
          return &quot;fetch_xor&quot;_str;
  }
  
<span class="line-modified">! String writeNativeFunction(AST::NativeFunctionDeclaration&amp; nativeFunctionDeclaration, String&amp; outputFunctionName, TypeNamer&amp; typeNamer)</span>
  {
<span class="line-modified">!     StringBuilder stringBuilder;</span>
      if (nativeFunctionDeclaration.isCast()) {
          ASSERT(nativeFunctionDeclaration.parameters().size() == 1);
<span class="line-modified">!         auto metalParameterName = getNativeName(*nativeFunctionDeclaration.parameters()[0].type(), typeNamer);</span>
<span class="line-modified">!         auto metalReturnName = getNativeName(nativeFunctionDeclaration.type(), typeNamer);</span>
<span class="line-modified">!         if (metalParameterName != &quot;atomic_int&quot;_str &amp;&amp; metalParameterName != &quot;atomic_uint&quot;_str) {</span>
<span class="line-modified">!             stringBuilder.append(makeString(metalReturnName, &#39; &#39;, outputFunctionName, &#39;(&#39;, metalParameterName, &quot;x) {\n&quot;));</span>
<span class="line-modified">!             stringBuilder.append(makeString(&quot;    return static_cast&lt;&quot;, metalReturnName, &quot;&gt;(x);\n&quot;));</span>
<span class="line-modified">!             stringBuilder.append(&quot;}\n&quot;);</span>
<span class="line-modified">!             return stringBuilder.toString();</span>
          }
  
<span class="line-modified">!         stringBuilder.append(makeString(metalReturnName, &#39; &#39;, outputFunctionName, &#39;(&#39;, metalParameterName, &quot;x) {\n&quot;));</span>
<span class="line-modified">!         stringBuilder.append(&quot;    return atomic_load_explicit(&amp;x, memory_order_relaxed);\n&quot;);</span>
<span class="line-modified">!         stringBuilder.append(&quot;}\n&quot;);</span>
<span class="line-modified">!         return stringBuilder.toString();</span>
      }
  
      if (nativeFunctionDeclaration.name().startsWith(&quot;operator.&quot;_str)) {
          if (nativeFunctionDeclaration.name().endsWith(&quot;=&quot;)) {
              ASSERT(nativeFunctionDeclaration.parameters().size() == 2);
<span class="line-removed">-             auto metalParameter1Name = getNativeName(*nativeFunctionDeclaration.parameters()[0].type(), typeNamer);</span>
<span class="line-removed">-             auto metalParameter2Name = getNativeName(*nativeFunctionDeclaration.parameters()[1].type(), typeNamer);</span>
<span class="line-removed">-             auto metalReturnName = getNativeName(nativeFunctionDeclaration.type(), typeNamer);</span>
              auto fieldName = nativeFunctionDeclaration.name().substring(&quot;operator.&quot;_str.length());
              fieldName = fieldName.substring(0, fieldName.length() - 1);
<span class="line-modified">!             stringBuilder.append(makeString(metalReturnName, &#39; &#39;, outputFunctionName, &#39;(&#39;, metalParameter1Name, &quot;v, &quot;, metalParameter2Name, &quot; n) {\n&quot;));</span>
<span class="line-modified">!             stringBuilder.append(makeString(&quot;    v.&quot;, fieldName, &quot; = n;\n&quot;));</span>
<span class="line-modified">!             stringBuilder.append(makeString(&quot;    return v;\n&quot;));</span>
<span class="line-modified">!             stringBuilder.append(&quot;}\n&quot;);</span>
<span class="line-modified">!             return stringBuilder.toString();</span>
          }
  
          ASSERT(nativeFunctionDeclaration.parameters().size() == 1);
<span class="line-modified">!         auto metalParameterName = getNativeName(*nativeFunctionDeclaration.parameters()[0].type(), typeNamer);</span>
<span class="line-modified">!         auto metalReturnName = getNativeName(nativeFunctionDeclaration.type(), typeNamer);</span>
<span class="line-modified">!         stringBuilder.append(makeString(metalReturnName, &#39; &#39;, outputFunctionName, &#39;(&#39;, metalParameterName, &quot;v) {\n&quot;));</span>
<span class="line-modified">!         stringBuilder.append(makeString(&quot;    return v.&quot;, nativeFunctionDeclaration.name().substring(&quot;operator.&quot;_str.length()), &quot;;\n&quot;));</span>
<span class="line-modified">!         stringBuilder.append(&quot;}\n&quot;);</span>
<span class="line-modified">!         return stringBuilder.toString();</span>
  
      }
  
      if (nativeFunctionDeclaration.name() == &quot;operator[]&quot;) {
          ASSERT(nativeFunctionDeclaration.parameters().size() == 2);
<span class="line-modified">!         auto metalParameter1Name = getNativeName(*nativeFunctionDeclaration.parameters()[0].type(), typeNamer);</span>
<span class="line-modified">!         auto metalParameter2Name = getNativeName(*nativeFunctionDeclaration.parameters()[1].type(), typeNamer);</span>
<span class="line-modified">!         auto metalReturnName = getNativeName(nativeFunctionDeclaration.type(), typeNamer);</span>
<span class="line-modified">!         stringBuilder.append(makeString(metalReturnName, &#39; &#39;, outputFunctionName, &#39;(&#39;, metalParameter1Name, &quot;m, &quot;, metalParameter2Name, &quot; i) {\n&quot;));</span>
<span class="line-modified">!         stringBuilder.append(makeString(&quot;    return m[i];\n&quot;));</span>
<span class="line-modified">!         stringBuilder.append(&quot;}\n&quot;);</span>
<span class="line-modified">!         return stringBuilder.toString();</span>
      }
  
      if (nativeFunctionDeclaration.name() == &quot;operator[]=&quot;) {
<span class="line-modified">!         ASSERT(nativeFunctionDeclaration.parameters().size() == 3);</span>
<span class="line-modified">!         auto metalParameter1Name = getNativeName(*nativeFunctionDeclaration.parameters()[0].type(), typeNamer);</span>
<span class="line-modified">!         auto metalParameter2Name = getNativeName(*nativeFunctionDeclaration.parameters()[1].type(), typeNamer);</span>
<span class="line-modified">!         auto metalParameter3Name = getNativeName(*nativeFunctionDeclaration.parameters()[2].type(), typeNamer);</span>
<span class="line-modified">!         auto metalReturnName = getNativeName(nativeFunctionDeclaration.type(), typeNamer);</span>
<span class="line-modified">!         stringBuilder.append(makeString(metalReturnName, &#39; &#39;, outputFunctionName, &#39;(&#39;, metalParameter1Name, &quot;m, &quot;, metalParameter2Name, &quot; i, &quot;, metalParameter3Name, &quot; v) {\n&quot;));</span>
<span class="line-modified">!         stringBuilder.append(makeString(&quot;    m[i] = v;\n&quot;));</span>
<span class="line-modified">!         stringBuilder.append(makeString(&quot;    return m;\n&quot;));</span>
<span class="line-modified">!         stringBuilder.append(&quot;}\n&quot;);</span>
<span class="line-modified">!         return stringBuilder.toString();</span>
      }
  
      if (nativeFunctionDeclaration.isOperator()) {
          if (nativeFunctionDeclaration.parameters().size() == 1) {
<span class="line-modified">!             auto operatorName = nativeFunctionDeclaration.name().substring(&quot;operator&quot;_str.length());</span>
<span class="line-modified">!             auto metalParameterName = getNativeName(*nativeFunctionDeclaration.parameters()[0].type(), typeNamer);</span>
<span class="line-modified">!             auto metalReturnName = getNativeName(nativeFunctionDeclaration.type(), typeNamer);</span>
<span class="line-modified">!             stringBuilder.append(makeString(metalReturnName, &#39; &#39;, outputFunctionName, &#39;(&#39;, metalParameterName, &quot;x) {\n&quot;));</span>
<span class="line-modified">!             stringBuilder.append(makeString(&quot;    return &quot;, operatorName, &quot;x;\n&quot;));</span>
<span class="line-modified">!             stringBuilder.append(&quot;}\n&quot;);</span>
<span class="line-modified">!             return stringBuilder.toString();</span>
          }
  
          ASSERT(nativeFunctionDeclaration.parameters().size() == 2);
<span class="line-modified">!         auto operatorName = nativeFunctionDeclaration.name().substring(&quot;operator&quot;_str.length());</span>
<span class="line-modified">!         auto metalParameter1Name = getNativeName(*nativeFunctionDeclaration.parameters()[0].type(), typeNamer);</span>
<span class="line-modified">!         auto metalParameter2Name = getNativeName(*nativeFunctionDeclaration.parameters()[1].type(), typeNamer);</span>
<span class="line-modified">!         auto metalReturnName = getNativeName(nativeFunctionDeclaration.type(), typeNamer);</span>
<span class="line-modified">!         stringBuilder.append(makeString(metalReturnName, &#39; &#39;, outputFunctionName, &#39;(&#39;, metalParameter1Name, &quot;x, &quot;, metalParameter2Name, &quot; y) {\n&quot;));</span>
<span class="line-modified">!         stringBuilder.append(makeString(&quot;    return x &quot;, operatorName, &quot; y;\n&quot;));</span>
<span class="line-modified">!         stringBuilder.append(&quot;}\n&quot;);</span>
<span class="line-modified">!         return stringBuilder.toString();</span>
      }
  
      if (nativeFunctionDeclaration.name() == &quot;cos&quot;
          || nativeFunctionDeclaration.name() == &quot;sin&quot;
          || nativeFunctionDeclaration.name() == &quot;tan&quot;
<span class="line-new-header">--- 82,445 ---</span>
          return &quot;fetch_or&quot;_str;
      ASSERT(input == &quot;Xor&quot;);
          return &quot;fetch_xor&quot;_str;
  }
  
<span class="line-modified">! static int vectorLength(AST::NativeTypeDeclaration&amp; nativeTypeDeclaration)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     int vectorLength = 1;</span>
<span class="line-added">+     if (!nativeTypeDeclaration.typeArguments().isEmpty()) {</span>
<span class="line-added">+         ASSERT(nativeTypeDeclaration.typeArguments().size() == 2);</span>
<span class="line-added">+         ASSERT(WTF::holds_alternative&lt;AST::ConstantExpression&gt;(nativeTypeDeclaration.typeArguments()[1]));</span>
<span class="line-added">+         vectorLength = WTF::get&lt;AST::ConstantExpression&gt;(nativeTypeDeclaration.typeArguments()[1]).integerLiteral().value();</span>
<span class="line-added">+     }</span>
<span class="line-added">+     return vectorLength;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ static AST::NamedType&amp; vectorInnerType(AST::NativeTypeDeclaration&amp; nativeTypeDeclaration)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     if (nativeTypeDeclaration.typeArguments().isEmpty())</span>
<span class="line-added">+         return nativeTypeDeclaration;</span>
<span class="line-added">+ </span>
<span class="line-added">+     ASSERT(nativeTypeDeclaration.typeArguments().size() == 2);</span>
<span class="line-added">+     ASSERT(WTF::holds_alternative&lt;Ref&lt;AST::TypeReference&gt;&gt;(nativeTypeDeclaration.typeArguments()[0]));</span>
<span class="line-added">+     return WTF::get&lt;Ref&lt;AST::TypeReference&gt;&gt;(nativeTypeDeclaration.typeArguments()[0])-&gt;resolvedType();</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ static const char* vectorSuffix(int vectorLength)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     switch (vectorLength) {</span>
<span class="line-added">+     case 1:</span>
<span class="line-added">+         return &quot;&quot;;</span>
<span class="line-added">+     case 2:</span>
<span class="line-added">+         return &quot;2&quot;;</span>
<span class="line-added">+     case 3:</span>
<span class="line-added">+         return &quot;3&quot;;</span>
<span class="line-added">+     default:</span>
<span class="line-added">+         ASSERT(vectorLength == 4);</span>
<span class="line-added">+         return &quot;4&quot;;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void inlineNativeFunction(StringBuilder&amp; stringBuilder, AST::NativeFunctionDeclaration&amp; nativeFunctionDeclaration, MangledVariableName returnName, const Vector&lt;MangledVariableName&gt;&amp; args, Intrinsics&amp; intrinsics, TypeNamer&amp; typeNamer, std::function&lt;MangledVariableName()&gt;&amp;&amp; generateNextVariableName, Indentation&lt;4&gt; indent)</span>
  {
<span class="line-modified">!     auto asMatrixType = [&amp;] (AST::UnnamedType&amp; unnamedType) -&gt; AST::NativeTypeDeclaration* {</span>
<span class="line-added">+         auto&amp; realType = unnamedType.unifyNode();</span>
<span class="line-added">+         if (!realType.isNativeTypeDeclaration())</span>
<span class="line-added">+             return nullptr;</span>
<span class="line-added">+ </span>
<span class="line-added">+         auto&amp; maybeMatrixType = downcast&lt;AST::NativeTypeDeclaration&gt;(realType);</span>
<span class="line-added">+         if (maybeMatrixType.isMatrix())</span>
<span class="line-added">+             return &amp;maybeMatrixType;</span>
<span class="line-added">+ </span>
<span class="line-added">+         return nullptr;</span>
<span class="line-added">+     };</span>
<span class="line-added">+ </span>
      if (nativeFunctionDeclaration.isCast()) {
<span class="line-added">+         auto&amp; returnType = nativeFunctionDeclaration.type();</span>
<span class="line-added">+         auto metalReturnTypeName = typeNamer.mangledNameForType(returnType);</span>
<span class="line-added">+ </span>
<span class="line-added">+         if (!nativeFunctionDeclaration.parameters().size()) {</span>
<span class="line-added">+             stringBuilder.append(indent, returnName, &quot; = { };\n&quot;);</span>
<span class="line-added">+             return;</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         if (nativeFunctionDeclaration.parameters().size() == 1) {</span>
<span class="line-added">+             auto&amp; parameterType = *nativeFunctionDeclaration.parameters()[0]-&gt;type();</span>
<span class="line-added">+             auto metalParameterTypeName = typeNamer.mangledNameForType(parameterType);</span>
<span class="line-added">+ </span>
<span class="line-added">+             auto isEnumerationDefinition = [] (auto&amp; type) {</span>
<span class="line-added">+                 return is&lt;AST::NamedType&gt;(type) &amp;&amp; is&lt;AST::EnumerationDefinition&gt;(downcast&lt;AST::NamedType&gt;(type));</span>
<span class="line-added">+             };</span>
<span class="line-added">+             auto&amp; unifiedReturnType = returnType.unifyNode();</span>
<span class="line-added">+             if (isEnumerationDefinition(unifiedReturnType) &amp;&amp; !isEnumerationDefinition(parameterType.unifyNode())) {</span>
<span class="line-added">+                 auto variableName = generateNextVariableName();</span>
<span class="line-added">+                 stringBuilder.append(indent, metalParameterTypeName, &#39; &#39;, variableName, &quot; = &quot;, args[0], &quot;;\n&quot;);</span>
<span class="line-added">+                 auto&amp; enumerationDefinition = downcast&lt;AST::EnumerationDefinition&gt;(downcast&lt;AST::NamedType&gt;(unifiedReturnType));</span>
<span class="line-added">+                 stringBuilder.append(indent, &quot;switch (&quot;, variableName, &quot;) {\n&quot;);</span>
<span class="line-added">+                 {</span>
<span class="line-added">+                     IndentationScope switchScope(indent);</span>
<span class="line-added">+                     bool hasZeroCase = false;</span>
<span class="line-added">+                     for (auto&amp; member : enumerationDefinition.enumerationMembers()) {</span>
<span class="line-added">+                         hasZeroCase |= !member.get().value();</span>
<span class="line-added">+                         stringBuilder.append(</span>
<span class="line-added">+                             indent, &quot;case &quot;, member.get().value(), &quot;:\n&quot;,</span>
<span class="line-added">+                             indent, &quot;    break;\n&quot;);</span>
<span class="line-added">+                     }</span>
<span class="line-added">+                     ASSERT_UNUSED(hasZeroCase, hasZeroCase);</span>
<span class="line-added">+                     stringBuilder.append(</span>
<span class="line-added">+                         indent, &quot;default:\n&quot;,</span>
<span class="line-added">+                         indent, &quot;    &quot;, variableName, &quot; = 0;\n&quot;,</span>
<span class="line-added">+                         indent, &quot;    break;\n&quot;,</span>
<span class="line-added">+                         indent, &quot;}\n&quot;);</span>
<span class="line-added">+                 }</span>
<span class="line-added">+                 stringBuilder.append(indent, returnName, &quot; = static_cast&lt;&quot;, metalReturnTypeName, &quot;&gt;(&quot;, variableName, &quot;);\n&quot;);</span>
<span class="line-added">+             } else</span>
<span class="line-added">+                 stringBuilder.append(indent, returnName, &quot; = static_cast&lt;&quot;, metalReturnTypeName, &quot;&gt;(&quot;, args[0], &quot;);\n&quot;);</span>
<span class="line-added">+ </span>
<span class="line-added">+             return;</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         if (auto* matrixType = asMatrixType(returnType)) {</span>
<span class="line-added">+             unsigned numRows = matrixType-&gt;numberOfMatrixRows();</span>
<span class="line-added">+             unsigned numColumns = matrixType-&gt;numberOfMatrixColumns();</span>
<span class="line-added">+             RELEASE_ASSERT(nativeFunctionDeclaration.parameters().size() == numRows || nativeFunctionDeclaration.parameters().size() == numRows * numColumns);</span>
<span class="line-added">+ </span>
<span class="line-added">+             auto variableName = generateNextVariableName();</span>
<span class="line-added">+ </span>
<span class="line-added">+             stringBuilder.append(indent, metalReturnTypeName, &#39; &#39;, variableName, &quot;;\n&quot;);</span>
<span class="line-added">+ </span>
<span class="line-added">+             // We need to abide by the memory layout we use for matrices here.</span>
<span class="line-added">+             if (nativeFunctionDeclaration.parameters().size() == numRows) {</span>
<span class="line-added">+                 // operator matrixMxN (vectorN, ..., vectorN)</span>
<span class="line-added">+                 for (unsigned i = 0; i &lt; numRows; ++i) {</span>
<span class="line-added">+                     for (unsigned j = 0; j &lt; numColumns; ++j)</span>
<span class="line-added">+                         stringBuilder.append(indent, variableName, &quot;[&quot;, j * numRows + i, &quot;] = &quot;, args[i], &quot;[&quot;, j, &quot;];\n&quot;);</span>
<span class="line-added">+                 }</span>
<span class="line-added">+             } else {</span>
<span class="line-added">+                 // operator matrixMxN (scalar, ..., scalar)</span>
<span class="line-added">+                 unsigned index = 0;</span>
<span class="line-added">+                 for (unsigned i = 0; i &lt; numRows; ++i) {</span>
<span class="line-added">+                     for (unsigned j = 0; j &lt; numColumns; ++j) {</span>
<span class="line-added">+                         stringBuilder.append(indent, variableName, &#39;[&#39;, j * numRows + i, &quot;] = &quot;, args[index], &quot;;\n&quot;);</span>
<span class="line-added">+                         ++index;</span>
<span class="line-added">+                     }</span>
<span class="line-added">+                 }</span>
<span class="line-added">+             }</span>
<span class="line-added">+ </span>
<span class="line-added">+             stringBuilder.append(indent, returnName, &quot; = &quot;, variableName, &quot;;\n&quot;);</span>
<span class="line-added">+             return;</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         stringBuilder.append(indent, returnName, &quot; = &quot;, metalReturnTypeName, &quot;(&quot;);</span>
<span class="line-added">+         for (unsigned i = 0; i &lt; nativeFunctionDeclaration.parameters().size(); ++i) {</span>
<span class="line-added">+             if (i &gt; 0)</span>
<span class="line-added">+                 stringBuilder.append(&quot;, &quot;);</span>
<span class="line-added">+             stringBuilder.append(args[i]);</span>
<span class="line-added">+         }</span>
<span class="line-added">+         stringBuilder.append(&quot;);\n&quot;);</span>
<span class="line-added">+         return;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     // FIXME: https://bugs.webkit.org/show_bug.cgi?id=198077 Authors can make a struct field named &quot;length&quot; too. Autogenerated getters for those shouldn&#39;t take this codepath.</span>
<span class="line-added">+     if (nativeFunctionDeclaration.name() == &quot;operator.length&quot;) {</span>
<span class="line-added">+         ASSERT_UNUSED(intrinsics, matches(nativeFunctionDeclaration.type(), intrinsics.uintType()));</span>
          ASSERT(nativeFunctionDeclaration.parameters().size() == 1);
<span class="line-modified">!         auto&amp; parameterType = nativeFunctionDeclaration.parameters()[0]-&gt;type()-&gt;unifyNode();</span>
<span class="line-modified">!         auto&amp; unnamedParameterType = downcast&lt;AST::UnnamedType&gt;(parameterType);</span>
<span class="line-modified">!         if (is&lt;AST::ArrayType&gt;(unnamedParameterType)) {</span>
<span class="line-modified">!             auto&amp; arrayParameterType = downcast&lt;AST::ArrayType&gt;(unnamedParameterType);</span>
<span class="line-modified">!             stringBuilder.append(</span>
<span class="line-modified">!                 indent, returnName, &quot; = &quot;, arrayParameterType.numElements(), &quot;;\n&quot;);</span>
<span class="line-modified">!             return;</span>
          }
  
<span class="line-modified">!         ASSERT(is&lt;AST::ArrayReferenceType&gt;(unnamedParameterType));</span>
<span class="line-modified">!         stringBuilder.append(</span>
<span class="line-modified">!             indent, returnName, &quot; = &quot;, args[0], &quot;.length;\n&quot;);</span>
<span class="line-modified">!         return;</span>
      }
  
      if (nativeFunctionDeclaration.name().startsWith(&quot;operator.&quot;_str)) {
<span class="line-added">+         auto appendMangledFieldName = [&amp;] (const String&amp; fieldName) {</span>
<span class="line-added">+             auto&amp; unifyNode = nativeFunctionDeclaration.parameters()[0]-&gt;type()-&gt;unifyNode();</span>
<span class="line-added">+             auto&amp; namedType = downcast&lt;AST::NamedType&gt;(unifyNode);</span>
<span class="line-added">+             if (is&lt;AST::StructureDefinition&gt;(namedType)) {</span>
<span class="line-added">+                 auto&amp; structureDefinition = downcast&lt;AST::StructureDefinition&gt;(namedType);</span>
<span class="line-added">+                 auto* structureElement = structureDefinition.find(fieldName);</span>
<span class="line-added">+                 ASSERT(structureElement);</span>
<span class="line-added">+                 stringBuilder.append(typeNamer.mangledNameForStructureElement(*structureElement));</span>
<span class="line-added">+                 return;</span>
<span class="line-added">+             }</span>
<span class="line-added">+             ASSERT(is&lt;AST::NativeTypeDeclaration&gt;(namedType));</span>
<span class="line-added">+             stringBuilder.append(fieldName);</span>
<span class="line-added">+         };</span>
<span class="line-added">+ </span>
          if (nativeFunctionDeclaration.name().endsWith(&quot;=&quot;)) {
              ASSERT(nativeFunctionDeclaration.parameters().size() == 2);
              auto fieldName = nativeFunctionDeclaration.name().substring(&quot;operator.&quot;_str.length());
              fieldName = fieldName.substring(0, fieldName.length() - 1);
<span class="line-modified">! </span>
<span class="line-modified">!             stringBuilder.append(</span>
<span class="line-modified">!                 indent, returnName, &quot; = &quot;, args[0], &quot;;\n&quot;,</span>
<span class="line-modified">!                 indent, returnName, &#39;.&#39;);</span>
<span class="line-modified">!             appendMangledFieldName(fieldName);</span>
<span class="line-added">+             stringBuilder.append(&quot; = &quot;, args[1], &quot;;\n&quot;);</span>
<span class="line-added">+ </span>
<span class="line-added">+             return;</span>
          }
  
          ASSERT(nativeFunctionDeclaration.parameters().size() == 1);
<span class="line-modified">!         auto fieldName = nativeFunctionDeclaration.name().substring(&quot;operator.&quot;_str.length());</span>
<span class="line-modified">!         stringBuilder.append(</span>
<span class="line-modified">!             indent, returnName, &quot; = &quot;, args[0], &#39;.&#39;);</span>
<span class="line-modified">!         appendMangledFieldName(fieldName);</span>
<span class="line-modified">!         stringBuilder.append(&quot;;\n&quot;);</span>
<span class="line-modified">!         return;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (nativeFunctionDeclaration.name().startsWith(&quot;operator&amp;.&quot;_str)) {</span>
<span class="line-added">+         ASSERT(nativeFunctionDeclaration.parameters().size() == 1);</span>
<span class="line-added">+         auto fieldName = nativeFunctionDeclaration.name().substring(&quot;operator&amp;.&quot;_str.length());</span>
<span class="line-added">+ </span>
<span class="line-added">+         stringBuilder.append(</span>
<span class="line-added">+             indent, returnName, &quot; = &quot;, args[0], &quot; ? &amp;(&quot;, args[0], &quot;-&gt;&quot;);</span>
  
<span class="line-added">+         auto&amp; unnamedType = *nativeFunctionDeclaration.parameters()[0]-&gt;type();</span>
<span class="line-added">+         auto&amp; unifyNode = downcast&lt;AST::PointerType&gt;(unnamedType).elementType().unifyNode();</span>
<span class="line-added">+         auto&amp; namedType = downcast&lt;AST::NamedType&gt;(unifyNode);</span>
<span class="line-added">+         if (is&lt;AST::StructureDefinition&gt;(namedType)) {</span>
<span class="line-added">+             auto&amp; structureDefinition = downcast&lt;AST::StructureDefinition&gt;(namedType);</span>
<span class="line-added">+             auto* structureElement = structureDefinition.find(fieldName);</span>
<span class="line-added">+             ASSERT(structureElement);</span>
<span class="line-added">+             stringBuilder.append(typeNamer.mangledNameForStructureElement(*structureElement));</span>
<span class="line-added">+         } else</span>
<span class="line-added">+             stringBuilder.append(fieldName);</span>
<span class="line-added">+ </span>
<span class="line-added">+         stringBuilder.append(&quot;) : nullptr;\n&quot;);</span>
<span class="line-added">+ </span>
<span class="line-added">+         return;</span>
      }
  
<span class="line-added">+     if (nativeFunctionDeclaration.name() == &quot;operator&amp;[]&quot;) {</span>
<span class="line-added">+         ASSERT(nativeFunctionDeclaration.parameters().size() == 2);</span>
<span class="line-added">+         ASSERT(is&lt;AST::ArrayReferenceType&gt;(*nativeFunctionDeclaration.parameters()[0]-&gt;type()));</span>
<span class="line-added">+ </span>
<span class="line-added">+         stringBuilder.append(</span>
<span class="line-added">+             indent, returnName, &quot; = (&quot;, args[1], &quot; &lt; &quot;, args[0], &quot;.length) ? &quot;, &quot; &amp;(&quot;, args[0], &quot;.pointer[&quot;, args[1], &quot;]) : nullptr;\n&quot;);</span>
<span class="line-added">+ </span>
<span class="line-added">+         return;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     auto vectorSize = [&amp;] () -&gt; unsigned {</span>
<span class="line-added">+         auto&amp; typeReference = downcast&lt;AST::TypeReference&gt;(*nativeFunctionDeclaration.parameters()[0]-&gt;type());</span>
<span class="line-added">+         auto&amp; vectorType = downcast&lt;AST::NativeTypeDeclaration&gt;(downcast&lt;AST::TypeReference&gt;(downcast&lt;AST::TypeDefinition&gt;(typeReference.resolvedType()).type()).resolvedType());</span>
<span class="line-added">+         ASSERT(vectorType.name() == &quot;vector&quot;);</span>
<span class="line-added">+         ASSERT(vectorType.typeArguments().size() == 2);</span>
<span class="line-added">+         return WTF::get&lt;AST::ConstantExpression&gt;(vectorType.typeArguments()[1]).integerLiteral().value();</span>
<span class="line-added">+     };</span>
<span class="line-added">+ </span>
<span class="line-added">+     auto getMatrixType = [&amp;] () -&gt; AST::NativeTypeDeclaration&amp; {</span>
<span class="line-added">+         auto&amp; typeReference = downcast&lt;AST::TypeReference&gt;(*nativeFunctionDeclaration.parameters()[0]-&gt;type());</span>
<span class="line-added">+         auto&amp; result = downcast&lt;AST::NativeTypeDeclaration&gt;(downcast&lt;AST::TypeReference&gt;(downcast&lt;AST::TypeDefinition&gt;(typeReference.resolvedType()).type()).resolvedType());</span>
<span class="line-added">+         ASSERT(result.isMatrix());</span>
<span class="line-added">+         return result;</span>
<span class="line-added">+     };</span>
<span class="line-added">+ </span>
      if (nativeFunctionDeclaration.name() == &quot;operator[]&quot;) {
          ASSERT(nativeFunctionDeclaration.parameters().size() == 2);
<span class="line-modified">!         auto&amp; typeReference = downcast&lt;AST::TypeReference&gt;(*nativeFunctionDeclaration.parameters()[0]-&gt;type());</span>
<span class="line-modified">!         size_t numTypeArguments = downcast&lt;AST::NativeTypeDeclaration&gt;(downcast&lt;AST::TypeReference&gt;(downcast&lt;AST::TypeDefinition&gt;(typeReference.resolvedType()).type()).resolvedType()).typeArguments().size();</span>
<span class="line-modified">!         if (numTypeArguments == 3) {</span>
<span class="line-modified">!             auto metalReturnName = typeNamer.mangledNameForType(nativeFunctionDeclaration.type());</span>
<span class="line-modified">! </span>
<span class="line-modified">!             unsigned numberOfRows = getMatrixType().numberOfMatrixRows();</span>
<span class="line-modified">!             unsigned numberOfColumns = getMatrixType().numberOfMatrixColumns();</span>
<span class="line-added">+ </span>
<span class="line-added">+             stringBuilder.append(indent, &quot;do {\n&quot;);</span>
<span class="line-added">+             {</span>
<span class="line-added">+                 IndentationScope scope(indent);</span>
<span class="line-added">+ </span>
<span class="line-added">+                 stringBuilder.append(</span>
<span class="line-added">+                     indent, metalReturnName, &quot; result;\n&quot;,</span>
<span class="line-added">+                     indent, &quot;if (&quot;, args[1], &quot; &gt;= &quot;, numberOfRows, &quot;) {\n&quot;,</span>
<span class="line-added">+                     indent, &quot;    &quot;, returnName, &quot; = &quot;, metalReturnName, &quot;(0);\n&quot;,</span>
<span class="line-added">+                     indent, &quot;    break;\n&quot;,</span>
<span class="line-added">+                     indent, &quot;}\n&quot;,</span>
<span class="line-added">+                     indent, &quot;result[0] = &quot;, args[0], &#39;[&#39;, args[1], &quot;];\n&quot;,</span>
<span class="line-added">+                     indent, &quot;result[1] = &quot;, args[0], &#39;[&#39;, args[1], &quot; + &quot;, numberOfRows, &quot;];\n&quot;);</span>
<span class="line-added">+ </span>
<span class="line-added">+                 if (numberOfColumns &gt;= 3)</span>
<span class="line-added">+                     stringBuilder.append(indent, &quot;result[2] = &quot;, args[0], &#39;[&#39;, args[1], &quot; + &quot;, numberOfRows * 2, &quot;];\n&quot;);</span>
<span class="line-added">+                 if (numberOfColumns &gt;= 4)</span>
<span class="line-added">+                     stringBuilder.append(indent, &quot;result[3] = &quot;, args[0], &#39;[&#39;, args[1], &quot; + &quot;, numberOfRows * 3, &quot;];\n&quot;);</span>
<span class="line-added">+ </span>
<span class="line-added">+                 stringBuilder.append(indent, returnName, &quot; = result;\n&quot;);</span>
<span class="line-added">+             }</span>
<span class="line-added">+             stringBuilder.append(&quot;} while (0);\n&quot;);</span>
<span class="line-added">+         } else {</span>
<span class="line-added">+             RELEASE_ASSERT(numTypeArguments == 2);</span>
<span class="line-added">+             unsigned numElements = vectorSize();</span>
<span class="line-added">+ </span>
<span class="line-added">+             auto metalReturnName = typeNamer.mangledNameForType(nativeFunctionDeclaration.type());</span>
<span class="line-added">+ </span>
<span class="line-added">+             stringBuilder.append(indent, &quot;do {\n&quot;);</span>
<span class="line-added">+             {</span>
<span class="line-added">+                 IndentationScope scope(indent);</span>
<span class="line-added">+                 stringBuilder.append(</span>
<span class="line-added">+                     indent, metalReturnName, &quot; result;\n&quot;,</span>
<span class="line-added">+                     indent, &quot;if (&quot;, args[1], &quot; &gt;= &quot;, numElements, &quot;) {\n&quot;,</span>
<span class="line-added">+                     indent, &quot;    &quot;, returnName, &quot; = &quot;, metalReturnName, &quot;(0);\n&quot;,</span>
<span class="line-added">+                     indent, &quot;    break;\n&quot;,</span>
<span class="line-added">+                     indent, &quot;}\n&quot;,</span>
<span class="line-added">+                     indent, &quot;result = &quot;, args[0], &quot;[&quot;, args[1], &quot;];\n&quot;,</span>
<span class="line-added">+                     indent, returnName, &quot; = result;\n&quot;);</span>
<span class="line-added">+             }</span>
<span class="line-added">+             stringBuilder.append(indent, &quot;} while (0);\n&quot;);</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         return;</span>
      }
  
      if (nativeFunctionDeclaration.name() == &quot;operator[]=&quot;) {
<span class="line-modified">!         auto&amp; typeReference = downcast&lt;AST::TypeReference&gt;(*nativeFunctionDeclaration.parameters()[0]-&gt;type());</span>
<span class="line-modified">!         size_t numTypeArguments = downcast&lt;AST::NativeTypeDeclaration&gt;(downcast&lt;AST::TypeReference&gt;(downcast&lt;AST::TypeDefinition&gt;(typeReference.resolvedType()).type()).resolvedType()).typeArguments().size();</span>
<span class="line-modified">!         if (numTypeArguments == 3) {</span>
<span class="line-modified">!             ASSERT(nativeFunctionDeclaration.parameters().size() == 3);</span>
<span class="line-modified">!             auto metalParameter2Name = typeNamer.mangledNameForType(*nativeFunctionDeclaration.parameters()[1]-&gt;type());</span>
<span class="line-modified">!             auto metalReturnName = typeNamer.mangledNameForType(nativeFunctionDeclaration.type());</span>
<span class="line-modified">! </span>
<span class="line-modified">!             unsigned numberOfRows = getMatrixType().numberOfMatrixRows();</span>
<span class="line-modified">!             unsigned numberOfColumns = getMatrixType().numberOfMatrixColumns();</span>
<span class="line-modified">! </span>
<span class="line-added">+             stringBuilder.append(indent, &quot;do {\n&quot;);</span>
<span class="line-added">+             {</span>
<span class="line-added">+                 IndentationScope scope(indent);</span>
<span class="line-added">+ </span>
<span class="line-added">+                 stringBuilder.append(</span>
<span class="line-added">+                     indent, metalReturnName, &quot; m = &quot;, args[0], &quot;;\n&quot;,</span>
<span class="line-added">+                     indent, metalParameter2Name, &quot; i = &quot;, args[1], &quot;;\n&quot;,</span>
<span class="line-added">+                     indent, &quot;if (i &gt;= &quot;, numberOfRows, &quot;) {\n&quot;,</span>
<span class="line-added">+                     indent, &quot;    &quot;, returnName, &quot; = m;\n&quot;,</span>
<span class="line-added">+                     indent, &quot;    break;\n&quot;,</span>
<span class="line-added">+                     indent, &quot;}\n&quot;,</span>
<span class="line-added">+                     indent, &quot;m[i] = &quot;, args[2], &quot;[0];\n&quot;,</span>
<span class="line-added">+                     indent, &quot;m[i + &quot;, numberOfRows, &quot;] = &quot;, args[2], &quot;[1];\n&quot;);</span>
<span class="line-added">+                 if (numberOfColumns &gt;= 3)</span>
<span class="line-added">+                     stringBuilder.append(indent, &quot;m[i + &quot;, numberOfRows * 2, &quot;] = &quot;, args[2], &quot;[2];\n&quot;);</span>
<span class="line-added">+                 if (numberOfColumns &gt;= 4)</span>
<span class="line-added">+                     stringBuilder.append(indent, &quot;m[i + &quot;, numberOfRows * 3, &quot;] = &quot;, args[2], &quot;[3];\n&quot;);</span>
<span class="line-added">+                 stringBuilder.append(indent, returnName, &quot; = m;\n&quot;);</span>
<span class="line-added">+             }</span>
<span class="line-added">+ </span>
<span class="line-added">+             stringBuilder.append(indent, &quot;} while(0);\n&quot;);</span>
<span class="line-added">+         } else {</span>
<span class="line-added">+             RELEASE_ASSERT(numTypeArguments == 2);</span>
<span class="line-added">+ </span>
<span class="line-added">+             ASSERT(nativeFunctionDeclaration.parameters().size() == 3);</span>
<span class="line-added">+             auto metalParameter2Name = typeNamer.mangledNameForType(*nativeFunctionDeclaration.parameters()[1]-&gt;type());</span>
<span class="line-added">+             auto metalReturnName = typeNamer.mangledNameForType(nativeFunctionDeclaration.type());</span>
<span class="line-added">+ </span>
<span class="line-added">+             unsigned numElements = vectorSize();</span>
<span class="line-added">+ </span>
<span class="line-added">+             stringBuilder.append(indent, &quot;do {\n&quot;);</span>
<span class="line-added">+             {</span>
<span class="line-added">+                 IndentationScope scope(indent);</span>
<span class="line-added">+ </span>
<span class="line-added">+                 stringBuilder.append(</span>
<span class="line-added">+                     indent, metalReturnName, &quot; v = &quot;, args[0], &quot;;\n&quot;,</span>
<span class="line-added">+                     indent, metalParameter2Name, &quot; i = &quot;, args[1], &quot;;\n&quot;,</span>
<span class="line-added">+                     indent, &quot;if (i &gt;= &quot;, numElements, &quot;) {\n&quot;,</span>
<span class="line-added">+                     indent, &quot;    &quot;, returnName, &quot; = v;\n&quot;,</span>
<span class="line-added">+                     indent, &quot;    break;\n&quot;,</span>
<span class="line-added">+                     indent, &quot;}\n&quot;,</span>
<span class="line-added">+                     indent, &quot;v[i] = &quot;, args[2], &quot;;\n&quot;,</span>
<span class="line-added">+                     indent, returnName, &quot; = v;\n&quot;);</span>
<span class="line-added">+             }</span>
<span class="line-added">+             stringBuilder.append(indent, &quot;} while(0);\n&quot;);</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         return;</span>
      }
  
      if (nativeFunctionDeclaration.isOperator()) {
<span class="line-added">+         auto operatorName = nativeFunctionDeclaration.name().substring(&quot;operator&quot;_str.length());</span>
<span class="line-added">+         auto metalReturnType = typeNamer.mangledNameForType(nativeFunctionDeclaration.type());</span>
          if (nativeFunctionDeclaration.parameters().size() == 1) {
<span class="line-modified">!             if (auto* matrixType = asMatrixType(nativeFunctionDeclaration.type())) {</span>
<span class="line-modified">!                 stringBuilder.append(indent, &quot;{\n&quot;);</span>
<span class="line-modified">!                 {</span>
<span class="line-modified">!                     IndentationScope scope(indent);</span>
<span class="line-modified">!                     stringBuilder.append(</span>
<span class="line-modified">!                         indent, metalReturnType, &quot; x = &quot;, args[0], &quot;;\n&quot;,</span>
<span class="line-modified">!                         indent, &quot;for (size_t i = 0; i &lt; x.size(); ++i)\n&quot;,</span>
<span class="line-added">+                         indent, &quot;    x[i] = &quot;, operatorName, &quot;x[i];\n&quot;,</span>
<span class="line-added">+                         indent, returnName, &quot; = x;\n&quot;);</span>
<span class="line-added">+                 }</span>
<span class="line-added">+                 stringBuilder.append(indent, &quot;}\n&quot;);</span>
<span class="line-added">+             } else {</span>
<span class="line-added">+                 stringBuilder.append(indent, &quot;{\n&quot;);</span>
<span class="line-added">+                 {</span>
<span class="line-added">+                     IndentationScope scope(indent);</span>
<span class="line-added">+                     stringBuilder.append(</span>
<span class="line-added">+                         indent, metalReturnType, &quot; x = &quot;, args[0], &quot;;\n&quot;,</span>
<span class="line-added">+                         indent, returnName, &quot; = &quot;, operatorName, &quot;x;\n&quot;);</span>
<span class="line-added">+                 }</span>
<span class="line-added">+                 stringBuilder.append(indent, &quot;}\n&quot;);</span>
<span class="line-added">+             }</span>
<span class="line-added">+             return;</span>
          }
  
          ASSERT(nativeFunctionDeclaration.parameters().size() == 2);
<span class="line-modified">!         if (auto* leftMatrix = asMatrixType(*nativeFunctionDeclaration.parameters()[0]-&gt;type())) {</span>
<span class="line-modified">!             if (auto* rightMatrix = asMatrixType(*nativeFunctionDeclaration.parameters()[1]-&gt;type())) {</span>
<span class="line-modified">!                 // matrix &lt;op&gt; matrix</span>
<span class="line-modified">!                 stringBuilder.append(indent, &quot;{\n&quot;);</span>
<span class="line-modified">!                 {</span>
<span class="line-modified">!                     IndentationScope scope(indent);</span>
<span class="line-modified">!                     stringBuilder.append(</span>
<span class="line-modified">!                         indent, metalReturnType, &quot; x;\n&quot;,</span>
<span class="line-added">+                         indent, &quot;for (size_t i = 0; i &lt; x.size(); ++i)\n&quot;,</span>
<span class="line-added">+                         indent, &quot;    x[i] = &quot;, args[0], &quot;[i] &quot;, operatorName, &#39; &#39;, args[1], &quot;[i];\n&quot;,</span>
<span class="line-added">+                         indent, returnName, &quot; = x;\n&quot;);</span>
<span class="line-added">+                 }</span>
<span class="line-added">+                 stringBuilder.append(indent, &quot;}\n&quot;);</span>
<span class="line-added">+             } else {</span>
<span class="line-added">+                 // matrix &lt;op&gt; scalar</span>
<span class="line-added">+                 stringBuilder.append(indent, &quot;{\n&quot;);</span>
<span class="line-added">+                 {</span>
<span class="line-added">+                     IndentationScope scope(indent);</span>
<span class="line-added">+                     stringBuilder.append(</span>
<span class="line-added">+                         indent, metalReturnType, &quot; x;\n&quot;,</span>
<span class="line-added">+                         indent, &quot;for (size_t i = 0; i &lt; x.size(); ++i)\n&quot;,</span>
<span class="line-added">+                         indent, &quot;    x[i] = &quot;, args[0], &quot;[i] &quot;, operatorName, &#39; &#39;, args[1], &quot;;\n&quot;,</span>
<span class="line-added">+                         indent, returnName, &quot; = x;\n&quot;);</span>
<span class="line-added">+                 }</span>
<span class="line-added">+                 stringBuilder.append(indent, &quot;}\n&quot;);</span>
<span class="line-added">+             }</span>
<span class="line-added">+         } else if (auto* rightMatrix = asMatrixType(*nativeFunctionDeclaration.parameters()[1]-&gt;type())) {</span>
<span class="line-added">+             ASSERT(!asMatrixType(*nativeFunctionDeclaration.parameters()[0]-&gt;type()));</span>
<span class="line-added">+             // scalar &lt;op&gt; matrix</span>
<span class="line-added">+             stringBuilder.append(indent, &quot;{\n&quot;);</span>
<span class="line-added">+             {</span>
<span class="line-added">+                 IndentationScope scope(indent);</span>
<span class="line-added">+                 stringBuilder.append(</span>
<span class="line-added">+                     indent, metalReturnType, &quot; x;\n&quot;,</span>
<span class="line-added">+                     indent, &quot;for (size_t i = 0; i &lt; x.size(); ++i)\n&quot;,</span>
<span class="line-added">+                     indent, &quot;    x[i] = &quot;, args[0], &#39; &#39;, operatorName, &#39; &#39;, args[1], &quot;[i];\n&quot;,</span>
<span class="line-added">+                     indent, returnName, &quot; = x;\n&quot;);</span>
<span class="line-added">+             }</span>
<span class="line-added">+             stringBuilder.append(indent, &quot;}\n&quot;);</span>
<span class="line-added">+         } else {</span>
<span class="line-added">+             // scalar &lt;op&gt; scalar</span>
<span class="line-added">+             // vector &lt;op&gt; vector</span>
<span class="line-added">+             // vector &lt;op&gt; scalar</span>
<span class="line-added">+             // scalar &lt;op&gt; vector</span>
<span class="line-added">+             stringBuilder.append(</span>
<span class="line-added">+                 indent, returnName, &quot; = &quot;, args[0], &#39; &#39;, operatorName, &#39; &#39;, args[1], &quot;;\n&quot;);</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         return;</span>
      }
  
      if (nativeFunctionDeclaration.name() == &quot;cos&quot;
          || nativeFunctionDeclaration.name() == &quot;sin&quot;
          || nativeFunctionDeclaration.name() == &quot;tan&quot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 213,183 ***</span>
          || nativeFunctionDeclaration.name() == &quot;isfinite&quot;
          || nativeFunctionDeclaration.name() == &quot;isinf&quot;
          || nativeFunctionDeclaration.name() == &quot;isnan&quot;
          || nativeFunctionDeclaration.name() == &quot;asint&quot;
          || nativeFunctionDeclaration.name() == &quot;asuint&quot;
<span class="line-modified">!         || nativeFunctionDeclaration.name() == &quot;asfloat&quot;) {</span>
          ASSERT(nativeFunctionDeclaration.parameters().size() == 1);
<span class="line-modified">!         auto metalParameterName = getNativeName(*nativeFunctionDeclaration.parameters()[0].type(), typeNamer);</span>
<span class="line-modified">!         auto metalReturnName = getNativeName(nativeFunctionDeclaration.type(), typeNamer);</span>
<span class="line-modified">!         stringBuilder.append(makeString(metalReturnName, &#39; &#39;, outputFunctionName, &#39;(&#39;, metalParameterName, &quot;x) {\n&quot;));</span>
<span class="line-removed">-         stringBuilder.append(makeString(&quot;    return &quot;, mapFunctionName(nativeFunctionDeclaration.name()), &quot;(x);\n&quot;));</span>
<span class="line-removed">-         stringBuilder.append(&quot;}\n&quot;);</span>
<span class="line-removed">-         return stringBuilder.toString();</span>
      }
  
      if (nativeFunctionDeclaration.name() == &quot;pow&quot; || nativeFunctionDeclaration.name() == &quot;atan2&quot;) {
          ASSERT(nativeFunctionDeclaration.parameters().size() == 2);
<span class="line-modified">!         auto metalParameter1Name = getNativeName(*nativeFunctionDeclaration.parameters()[0].type(), typeNamer);</span>
<span class="line-modified">!         auto metalParameter2Name = getNativeName(*nativeFunctionDeclaration.parameters()[1].type(), typeNamer);</span>
<span class="line-modified">!         auto metalReturnName = getNativeName(nativeFunctionDeclaration.type(), typeNamer);</span>
<span class="line-removed">-         stringBuilder.append(makeString(metalReturnName, &#39; &#39;, outputFunctionName, &#39;(&#39;, metalParameter1Name, &quot;x, &quot;, metalParameter2Name, &quot; y) {\n&quot;));</span>
<span class="line-removed">-         stringBuilder.append(makeString(&quot;    return &quot;, nativeFunctionDeclaration.name(), &quot;(x, y);\n&quot;));</span>
<span class="line-removed">-         stringBuilder.append(&quot;}\n&quot;);</span>
<span class="line-removed">-         return stringBuilder.toString();</span>
      }
  
<span class="line-modified">!     if (nativeFunctionDeclaration.name() == &quot;f16tof32&quot; || nativeFunctionDeclaration.name() == &quot;f32tof16&quot;) {</span>
<span class="line-modified">!         // FIXME: Implement this</span>
<span class="line-modified">!         CRASH();</span>
      }
  
      if (nativeFunctionDeclaration.name() == &quot;AllMemoryBarrierWithGroupSync&quot;) {
          ASSERT(!nativeFunctionDeclaration.parameters().size());
<span class="line-modified">!         stringBuilder.append(makeString(&quot;void &quot;, outputFunctionName, &quot;() {\n&quot;));</span>
<span class="line-modified">!         stringBuilder.append(&quot;    threadgroup_barrier(mem_flags::mem_device);\n&quot;);</span>
<span class="line-modified">!         stringBuilder.append(&quot;    threadgroup_barrier(mem_flags::mem_threadgroup);\n&quot;);</span>
<span class="line-modified">!         stringBuilder.append(&quot;    threadgroup_barrier(mem_flags::mem_texture);\n&quot;);</span>
<span class="line-modified">!         stringBuilder.append(&quot;}\n&quot;);</span>
<span class="line-removed">-         return stringBuilder.toString();</span>
      }
  
      if (nativeFunctionDeclaration.name() == &quot;DeviceMemoryBarrierWithGroupSync&quot;) {
          ASSERT(!nativeFunctionDeclaration.parameters().size());
<span class="line-modified">!         stringBuilder.append(makeString(&quot;void &quot;, outputFunctionName, &quot;() {\n&quot;));</span>
<span class="line-modified">!         stringBuilder.append(&quot;    threadgroup_barrier(mem_flags::mem_device);\n&quot;);</span>
<span class="line-modified">!         stringBuilder.append(&quot;}\n&quot;);</span>
<span class="line-removed">-         return stringBuilder.toString();</span>
      }
  
      if (nativeFunctionDeclaration.name() == &quot;GroupMemoryBarrierWithGroupSync&quot;) {
          ASSERT(!nativeFunctionDeclaration.parameters().size());
<span class="line-modified">!         stringBuilder.append(makeString(&quot;void &quot;, outputFunctionName, &quot;() {\n&quot;));</span>
<span class="line-modified">!         stringBuilder.append(&quot;    threadgroup_barrier(mem_flags::mem_threadgroup);\n&quot;);</span>
<span class="line-modified">!         stringBuilder.append(&quot;}\n&quot;);</span>
<span class="line-removed">-         return stringBuilder.toString();</span>
      }
  
      if (nativeFunctionDeclaration.name().startsWith(&quot;Interlocked&quot;_str)) {
          if (nativeFunctionDeclaration.name() == &quot;InterlockedCompareExchange&quot;) {
              ASSERT(nativeFunctionDeclaration.parameters().size() == 4);
<span class="line-modified">!             ASSERT(is&lt;AST::PointerType&gt;(*nativeFunctionDeclaration.parameters()[0].type()));</span>
<span class="line-modified">!             auto&amp; firstArgumentPointer = downcast&lt;AST::PointerType&gt;(*nativeFunctionDeclaration.parameters()[0].type());</span>
<span class="line-modified">!             auto firstArgumentAddressSpace = firstArgumentPointer.addressSpace();</span>
<span class="line-modified">!             auto firstArgumentPointee = getNativeName(firstArgumentPointer.elementType(), typeNamer);</span>
<span class="line-removed">-             auto secondArgument = getNativeName(*nativeFunctionDeclaration.parameters()[1].type(), typeNamer);</span>
<span class="line-removed">-             auto thirdArgument = getNativeName(*nativeFunctionDeclaration.parameters()[2].type(), typeNamer);</span>
<span class="line-removed">-             ASSERT(is&lt;AST::PointerType&gt;(*nativeFunctionDeclaration.parameters()[3].type()));</span>
<span class="line-removed">-             auto&amp; fourthArgumentPointer = downcast&lt;AST::PointerType&gt;(*nativeFunctionDeclaration.parameters()[3].type());</span>
<span class="line-removed">-             auto fourthArgumentAddressSpace = fourthArgumentPointer.addressSpace();</span>
<span class="line-removed">-             auto fourthArgumentPointee = getNativeName(fourthArgumentPointer.elementType(), typeNamer);</span>
<span class="line-removed">-             stringBuilder.append(makeString(&quot;void &quot;, outputFunctionName, &#39;(&#39;, convertAddressSpace(firstArgumentAddressSpace), &#39; &#39;, firstArgumentPointee, &quot;* object, &quot;, secondArgument, &quot; compare, &quot;, thirdArgument, &quot; desired, &quot;, convertAddressSpace(fourthArgumentAddressSpace), &#39; &#39;, fourthArgumentPointee, &quot;* out) {\n&quot;));</span>
<span class="line-removed">-             stringBuilder.append(&quot;    atomic_compare_exchange_weak_explicit(object, &amp;compare, desired, memory_order_relaxed);\n&quot;);</span>
<span class="line-removed">-             stringBuilder.append(&quot;    *out = compare;\n&quot;);</span>
<span class="line-removed">-             stringBuilder.append(&quot;}\n&quot;);</span>
<span class="line-removed">-             return stringBuilder.toString();</span>
          }
  
          ASSERT(nativeFunctionDeclaration.parameters().size() == 3);
<span class="line-removed">-         ASSERT(is&lt;AST::PointerType&gt;(*nativeFunctionDeclaration.parameters()[0].type()));</span>
<span class="line-removed">-         auto&amp; firstArgumentPointer = downcast&lt;AST::PointerType&gt;(*nativeFunctionDeclaration.parameters()[0].type());</span>
<span class="line-removed">-         auto firstArgumentAddressSpace = firstArgumentPointer.addressSpace();</span>
<span class="line-removed">-         auto firstArgumentPointee = getNativeName(firstArgumentPointer.elementType(), typeNamer);</span>
<span class="line-removed">-         auto secondArgument = getNativeName(*nativeFunctionDeclaration.parameters()[1].type(), typeNamer);</span>
<span class="line-removed">-         ASSERT(is&lt;AST::PointerType&gt;(*nativeFunctionDeclaration.parameters()[2].type()));</span>
<span class="line-removed">-         auto&amp; thirdArgumentPointer = downcast&lt;AST::PointerType&gt;(*nativeFunctionDeclaration.parameters()[2].type());</span>
<span class="line-removed">-         auto thirdArgumentAddressSpace = thirdArgumentPointer.addressSpace();</span>
<span class="line-removed">-         auto thirdArgumentPointee = getNativeName(thirdArgumentPointer.elementType(), typeNamer);</span>
          auto name = atomicName(nativeFunctionDeclaration.name().substring(&quot;Interlocked&quot;_str.length()));
<span class="line-modified">!         stringBuilder.append(makeString(&quot;void &quot;, outputFunctionName, &#39;(&#39;, convertAddressSpace(firstArgumentAddressSpace), &#39; &#39;, firstArgumentPointee, &quot;* object, &quot;, secondArgument, &quot; operand, &quot;, convertAddressSpace(thirdArgumentAddressSpace), &#39; &#39;, thirdArgumentPointee, &quot;* out) {\n&quot;));</span>
<span class="line-modified">!         stringBuilder.append(makeString(&quot;    *out = atomic_fetch_&quot;, name, &quot;_explicit(object, operand, memory_order_relaxed);\n&quot;));</span>
<span class="line-modified">!         stringBuilder.append(&quot;}\n&quot;);</span>
<span class="line-removed">-         return stringBuilder.toString();</span>
      }
  
      if (nativeFunctionDeclaration.name() == &quot;Sample&quot;) {
<span class="line-modified">!         // FIXME: Implement this.</span>
<span class="line-modified">!         CRASH();</span>
      }
  
      if (nativeFunctionDeclaration.name() == &quot;Load&quot;) {
<span class="line-modified">!         // FIXME: Implement this.</span>
<span class="line-modified">!         CRASH();</span>
      }
  
      if (nativeFunctionDeclaration.name() == &quot;GetDimensions&quot;) {
<span class="line-modified">!         // FIXME: Implement this.</span>
<span class="line-modified">!         CRASH();</span>
      }
  
      if (nativeFunctionDeclaration.name() == &quot;SampleBias&quot;) {
<span class="line-modified">!         // FIXME: Implement this.</span>
<span class="line-modified">!         CRASH();</span>
      }
  
      if (nativeFunctionDeclaration.name() == &quot;SampleGrad&quot;) {
<span class="line-modified">!         // FIXME: Implement this.</span>
<span class="line-modified">!         CRASH();</span>
      }
  
      if (nativeFunctionDeclaration.name() == &quot;SampleLevel&quot;) {
<span class="line-modified">!         // FIXME: Implement this.</span>
<span class="line-modified">!         CRASH();</span>
      }
  
      if (nativeFunctionDeclaration.name() == &quot;Gather&quot;) {
<span class="line-modified">!         // FIXME: Implement this.</span>
<span class="line-modified">!         CRASH();</span>
      }
  
      if (nativeFunctionDeclaration.name() == &quot;GatherRed&quot;) {
<span class="line-modified">!         // FIXME: Implement this.</span>
<span class="line-modified">!         CRASH();</span>
      }
  
      if (nativeFunctionDeclaration.name() == &quot;SampleCmp&quot;) {
<span class="line-modified">!         // FIXME: Implement this.</span>
<span class="line-modified">!         CRASH();</span>
      }
  
      if (nativeFunctionDeclaration.name() == &quot;SampleCmpLevelZero&quot;) {
<span class="line-modified">!         // FIXME: Implement this.</span>
<span class="line-modified">!         CRASH();</span>
      }
  
      if (nativeFunctionDeclaration.name() == &quot;Store&quot;) {
<span class="line-modified">!         // FIXME: Implement this.</span>
<span class="line-modified">!         CRASH();</span>
      }
  
      if (nativeFunctionDeclaration.name() == &quot;GatherAlpha&quot;) {
<span class="line-modified">!         // FIXME: Implement this.</span>
<span class="line-modified">!         CRASH();</span>
      }
  
      if (nativeFunctionDeclaration.name() == &quot;GatherBlue&quot;) {
<span class="line-modified">!         // FIXME: Implement this.</span>
<span class="line-modified">!         CRASH();</span>
      }
  
      if (nativeFunctionDeclaration.name() == &quot;GatherCmp&quot;) {
<span class="line-modified">!         // FIXME: Implement this.</span>
<span class="line-modified">!         CRASH();</span>
      }
  
      if (nativeFunctionDeclaration.name() == &quot;GatherCmpRed&quot;) {
<span class="line-modified">!         // FIXME: Implement this.</span>
<span class="line-modified">!         CRASH();</span>
      }
  
      if (nativeFunctionDeclaration.name() == &quot;GatherGreen&quot;) {
<span class="line-modified">!         // FIXME: Implement this.</span>
<span class="line-modified">!         CRASH();</span>
      }
  
<span class="line-removed">-     // FIXME: Add all the functions that the compiler generated.</span>
<span class="line-removed">- </span>
      ASSERT_NOT_REACHED();
<span class="line-removed">-     return String();</span>
  }
  
  } // namespace Metal
  
  } // namespace WHLSL
<span class="line-new-header">--- 542,392 ---</span>
          || nativeFunctionDeclaration.name() == &quot;isfinite&quot;
          || nativeFunctionDeclaration.name() == &quot;isinf&quot;
          || nativeFunctionDeclaration.name() == &quot;isnan&quot;
          || nativeFunctionDeclaration.name() == &quot;asint&quot;
          || nativeFunctionDeclaration.name() == &quot;asuint&quot;
<span class="line-modified">!         || nativeFunctionDeclaration.name() == &quot;asfloat&quot;</span>
<span class="line-added">+         || nativeFunctionDeclaration.name() == &quot;length&quot;) {</span>
          ASSERT(nativeFunctionDeclaration.parameters().size() == 1);
<span class="line-modified">!         stringBuilder.append(</span>
<span class="line-modified">!             indent, returnName, &quot; = &quot;, mapFunctionName(nativeFunctionDeclaration.name()), &#39;(&#39;, args[0], &quot;);\n&quot;);</span>
<span class="line-modified">!         return;</span>
      }
  
      if (nativeFunctionDeclaration.name() == &quot;pow&quot; || nativeFunctionDeclaration.name() == &quot;atan2&quot;) {
          ASSERT(nativeFunctionDeclaration.parameters().size() == 2);
<span class="line-modified">!         stringBuilder.append(</span>
<span class="line-modified">!             indent, returnName, &quot; = &quot;, nativeFunctionDeclaration.name(), &quot;(&quot;, args[0], &quot;, &quot;, args[1], &quot;);\n&quot;);</span>
<span class="line-modified">!         return;</span>
      }
  
<span class="line-modified">!     if (nativeFunctionDeclaration.name() == &quot;clamp&quot;) {</span>
<span class="line-modified">!         ASSERT(nativeFunctionDeclaration.parameters().size() == 3);</span>
<span class="line-modified">!         if (asMatrixType(nativeFunctionDeclaration.type())) {</span>
<span class="line-added">+             auto metalReturnType = typeNamer.mangledNameForType(nativeFunctionDeclaration.type());</span>
<span class="line-added">+ </span>
<span class="line-added">+             stringBuilder.append(indent, &quot;{\n&quot;);</span>
<span class="line-added">+             {</span>
<span class="line-added">+                 IndentationScope scope(indent);</span>
<span class="line-added">+                 stringBuilder.append(</span>
<span class="line-added">+                     indent, metalReturnType, &quot; x;\n&quot;,</span>
<span class="line-added">+                     indent, &quot;for (size_t i = 0; i &lt; x.size(); ++i) \n&quot;,</span>
<span class="line-added">+                     indent, &quot;    x[i] = clamp(&quot;, args[0], &quot;[i], &quot;, args[1], &quot;[i], &quot;, args[2], &quot;[i]);&quot;,</span>
<span class="line-added">+                     indent, returnName, &quot; = x;\n&quot;);</span>
<span class="line-added">+             }</span>
<span class="line-added">+             stringBuilder.append(indent, &quot;}\n&quot;);</span>
<span class="line-added">+         } else {</span>
<span class="line-added">+             stringBuilder.append(</span>
<span class="line-added">+                 indent, returnName, &quot; = clamp(&quot;, args[0], &quot;, &quot;, args[1], &quot;, &quot;, args[2], &quot;);\n&quot;);</span>
<span class="line-added">+         }</span>
<span class="line-added">+         return;</span>
      }
  
      if (nativeFunctionDeclaration.name() == &quot;AllMemoryBarrierWithGroupSync&quot;) {
          ASSERT(!nativeFunctionDeclaration.parameters().size());
<span class="line-modified">!         stringBuilder.append(</span>
<span class="line-modified">!             indent, &quot;threadgroup_barrier(mem_flags::mem_device);\n&quot;,</span>
<span class="line-modified">!             indent, &quot;threadgroup_barrier(mem_flags::mem_threadgroup);\n&quot;,</span>
<span class="line-modified">!             indent, &quot;threadgroup_barrier(mem_flags::mem_texture);\n&quot;);</span>
<span class="line-modified">!         return;</span>
      }
  
      if (nativeFunctionDeclaration.name() == &quot;DeviceMemoryBarrierWithGroupSync&quot;) {
          ASSERT(!nativeFunctionDeclaration.parameters().size());
<span class="line-modified">!         stringBuilder.append(</span>
<span class="line-modified">!             indent, &quot;threadgroup_barrier(mem_flags::mem_device);\n&quot;);</span>
<span class="line-modified">!         return;</span>
      }
  
      if (nativeFunctionDeclaration.name() == &quot;GroupMemoryBarrierWithGroupSync&quot;) {
          ASSERT(!nativeFunctionDeclaration.parameters().size());
<span class="line-modified">!         stringBuilder.append(</span>
<span class="line-modified">!             indent, &quot;threadgroup_barrier(mem_flags::mem_threadgroup);\n&quot;);</span>
<span class="line-modified">!         return;</span>
      }
  
      if (nativeFunctionDeclaration.name().startsWith(&quot;Interlocked&quot;_str)) {
          if (nativeFunctionDeclaration.name() == &quot;InterlockedCompareExchange&quot;) {
              ASSERT(nativeFunctionDeclaration.parameters().size() == 4);
<span class="line-modified">!             stringBuilder.append(</span>
<span class="line-modified">!                 indent, &quot;atomic_compare_exchange_weak_explicit(&quot;, args[0], &quot;, &amp;&quot;, args[1], &quot;, &quot;, args[2], &quot;, memory_order_relaxed, memory_order_relaxed);\n&quot;,</span>
<span class="line-modified">!                 indent, &#39;*&#39;, args[3], &quot; = &quot;, args[1], &quot;;\n&quot;);</span>
<span class="line-modified">!             return;</span>
          }
  
          ASSERT(nativeFunctionDeclaration.parameters().size() == 3);
          auto name = atomicName(nativeFunctionDeclaration.name().substring(&quot;Interlocked&quot;_str.length()));
<span class="line-modified">!         stringBuilder.append(</span>
<span class="line-modified">!             indent, &#39;*&#39;, args[2], &quot; = atomic_&quot;, name, &quot;_explicit(&quot;, args[0], &quot;, &quot;, args[1], &quot;, memory_order_relaxed);\n&quot;);</span>
<span class="line-modified">!         return;</span>
      }
  
      if (nativeFunctionDeclaration.name() == &quot;Sample&quot;) {
<span class="line-modified">!         ASSERT(nativeFunctionDeclaration.parameters().size() == 3 || nativeFunctionDeclaration.parameters().size() == 4);</span>
<span class="line-modified">! </span>
<span class="line-added">+         auto&amp; textureType = downcast&lt;AST::NativeTypeDeclaration&gt;(downcast&lt;AST::NamedType&gt;(nativeFunctionDeclaration.parameters()[0]-&gt;type()-&gt;unifyNode()));</span>
<span class="line-added">+         auto&amp; locationType = downcast&lt;AST::NativeTypeDeclaration&gt;(downcast&lt;AST::NamedType&gt;(nativeFunctionDeclaration.parameters()[2]-&gt;type()-&gt;unifyNode()));</span>
<span class="line-added">+         auto locationVectorLength = vectorLength(locationType);</span>
<span class="line-added">+         auto&amp; returnType = downcast&lt;AST::NativeTypeDeclaration&gt;(downcast&lt;AST::NamedType&gt;(nativeFunctionDeclaration.type().unifyNode()));</span>
<span class="line-added">+         auto returnVectorLength = vectorLength(returnType);</span>
<span class="line-added">+ </span>
<span class="line-added">+         stringBuilder.append(</span>
<span class="line-added">+             indent, returnName, &quot; = &quot;, args[0], &quot;.sample(&quot;, args[1], &quot;, &quot;);</span>
<span class="line-added">+ </span>
<span class="line-added">+         if (textureType.isTextureArray()) {</span>
<span class="line-added">+             ASSERT(locationVectorLength &gt; 1);</span>
<span class="line-added">+             stringBuilder.append(args[2], &#39;.&#39;, &quot;xyzw&quot;_str.substring(0, locationVectorLength - 1), &quot;, &quot;, args[2], &#39;.&#39;, &quot;xyzw&quot;_str.substring(locationVectorLength - 1, 1));</span>
<span class="line-added">+         } else</span>
<span class="line-added">+             stringBuilder.append(args[2]);</span>
<span class="line-added">+         if (nativeFunctionDeclaration.parameters().size() == 4)</span>
<span class="line-added">+             stringBuilder.append(&quot;, &quot;, args[3]);</span>
<span class="line-added">+         stringBuilder.append(&quot;)&quot;);</span>
<span class="line-added">+         if (!textureType.isDepthTexture())</span>
<span class="line-added">+             stringBuilder.append(&quot;.&quot;, &quot;xyzw&quot;_str.substring(0, returnVectorLength));</span>
<span class="line-added">+         stringBuilder.append(&quot;;\n&quot;);</span>
<span class="line-added">+ </span>
<span class="line-added">+         return;</span>
      }
  
      if (nativeFunctionDeclaration.name() == &quot;Load&quot;) {
<span class="line-modified">!         ASSERT(nativeFunctionDeclaration.parameters().size() == 2);</span>
<span class="line-modified">! </span>
<span class="line-added">+         auto&amp; textureType = downcast&lt;AST::NativeTypeDeclaration&gt;(downcast&lt;AST::NamedType&gt;(nativeFunctionDeclaration.parameters()[0]-&gt;type()-&gt;unifyNode()));</span>
<span class="line-added">+         auto&amp; locationType = downcast&lt;AST::NativeTypeDeclaration&gt;(downcast&lt;AST::NamedType&gt;(nativeFunctionDeclaration.parameters()[1]-&gt;type()-&gt;unifyNode()));</span>
<span class="line-added">+         auto locationVectorLength = vectorLength(locationType);</span>
<span class="line-added">+         auto&amp; returnType = downcast&lt;AST::NativeTypeDeclaration&gt;(downcast&lt;AST::NamedType&gt;(nativeFunctionDeclaration.type().unifyNode()));</span>
<span class="line-added">+         auto returnVectorLength = vectorLength(returnType);</span>
<span class="line-added">+ </span>
<span class="line-added">+         auto metalReturnName = typeNamer.mangledNameForType(returnType);</span>
<span class="line-added">+ </span>
<span class="line-added">+         stringBuilder.append(indent, &quot;do {\n&quot;);</span>
<span class="line-added">+         {</span>
<span class="line-added">+             IndentationScope scope(indent);</span>
<span class="line-added">+ </span>
<span class="line-added">+             if (textureType.isTextureArray()) {</span>
<span class="line-added">+                 ASSERT(locationVectorLength &gt; 1);</span>
<span class="line-added">+                 String dimensions[] = { &quot;width&quot;_str, &quot;height&quot;_str, &quot;depth&quot;_str };</span>
<span class="line-added">+                 for (int i = 0; i &lt; locationVectorLength - 1; ++i) {</span>
<span class="line-added">+                     auto suffix = &quot;xyzw&quot;_str.substring(i, 1);</span>
<span class="line-added">+                     stringBuilder.append(</span>
<span class="line-added">+                         indent, &quot;if (&quot;, args[1], &#39;.&#39;, suffix, &quot; &lt; 0 || static_cast&lt;uint32_t&gt;(&quot;, args[1], &#39;.&#39;, suffix, &quot;) &gt;= &quot;, args[0], &quot;.get_&quot;, dimensions[i], &quot;()) {\n&quot;,</span>
<span class="line-added">+                         indent, &quot;    &quot;, returnName, &quot; = &quot;, metalReturnName, &quot;(0);\n&quot;,</span>
<span class="line-added">+                         indent, &quot;    break;\n&quot;,</span>
<span class="line-added">+                         indent, &quot;}\n&quot;);</span>
<span class="line-added">+                 }</span>
<span class="line-added">+                 auto suffix = &quot;xyzw&quot;_str.substring(locationVectorLength - 1, 1);</span>
<span class="line-added">+                 stringBuilder.append(</span>
<span class="line-added">+                     indent, &quot;if (&quot;, args[1], &#39;.&#39;, suffix, &quot; &lt; 0 || static_cast&lt;uint32_t&gt;(&quot;, args[1], &#39;.&#39;, suffix, &quot;) &gt;= &quot;, args[0], &quot;.get_array_size()) {\n&quot;,</span>
<span class="line-added">+                     indent, &quot;    &quot;, returnName, &quot; = &quot;, metalReturnName, &quot;(0);\n&quot;,</span>
<span class="line-added">+                     indent, &quot;    break;\n&quot;,</span>
<span class="line-added">+                     indent, &quot;}\n&quot;);</span>
<span class="line-added">+             } else {</span>
<span class="line-added">+                 if (locationVectorLength == 1) {</span>
<span class="line-added">+                     stringBuilder.append(</span>
<span class="line-added">+                         indent, &quot;if (&quot;, args[1], &quot; &lt; 0 || static_cast&lt;uint32_t&gt;(&quot;, args[1], &quot;) &gt;= &quot;, args[0], &quot;.get_width()) {\n&quot;,</span>
<span class="line-added">+                         indent, &quot;    &quot;, returnName, &quot; = &quot;, metalReturnName, &quot;(0);\n&quot;,</span>
<span class="line-added">+                         indent, &quot;    break;\n&quot;,</span>
<span class="line-added">+                         indent, &quot;}\n&quot;);</span>
<span class="line-added">+                 } else {</span>
<span class="line-added">+                     stringBuilder.append(</span>
<span class="line-added">+                         indent, &quot;if (&quot;, args[1], &quot;.x &lt; 0 || static_cast&lt;uint32_t&gt;(&quot;, args[1], &quot;.x) &gt;= &quot;, args[0], &quot;.get_width()) {\n&quot;,</span>
<span class="line-added">+                         indent, &quot;    &quot;, returnName, &quot; = &quot;, metalReturnName, &quot;(0);\n&quot;,</span>
<span class="line-added">+                         indent, &quot;    break;\n&quot;,</span>
<span class="line-added">+                         indent, &quot;}\n&quot;,</span>
<span class="line-added">+                         indent, &quot;if (&quot;, args[1], &quot;.y &lt; 0 || static_cast&lt;uint32_t&gt;(&quot;, args[1], &quot;.y) &gt;= &quot;, args[0], &quot;.get_height()) {\n&quot;,</span>
<span class="line-added">+                         indent, &quot;    &quot;, returnName, &quot; = &quot;, metalReturnName, &quot;(0);\n&quot;,</span>
<span class="line-added">+                         indent, &quot;    break;\n&quot;,</span>
<span class="line-added">+                         indent, &quot;}\n&quot;);</span>
<span class="line-added">+                     if (locationVectorLength &gt;= 3) {</span>
<span class="line-added">+                         stringBuilder.append(</span>
<span class="line-added">+                             indent, &quot;if (&quot;, args[1], &quot;.z &lt; 0 || static_cast&lt;uint32_t&gt;(&quot;, args[1], &quot;.z) &gt;= &quot;, args[0], &quot;.get_depth()) {\n&quot;,</span>
<span class="line-added">+                             indent, &quot;    &quot;, returnName, &quot; = &quot;, metalReturnName, &quot;(0);\n&quot;,</span>
<span class="line-added">+                             indent, &quot;    break;\n&quot;,</span>
<span class="line-added">+                             indent, &quot;}\n&quot;);</span>
<span class="line-added">+                     }</span>
<span class="line-added">+                 }</span>
<span class="line-added">+             }</span>
<span class="line-added">+             stringBuilder.append(indent, returnName, &quot; = &quot;, args[0], &quot;.read(&quot;);</span>
<span class="line-added">+             if (textureType.isTextureArray()) {</span>
<span class="line-added">+                 ASSERT(locationVectorLength &gt; 1);</span>
<span class="line-added">+                 stringBuilder.append(&quot;uint&quot;, vectorSuffix(locationVectorLength - 1), &#39;(&#39;, args[1], &#39;.&#39;, &quot;xyzw&quot;_str.substring(0, locationVectorLength - 1), &quot;), uint(&quot;, args[1], &#39;.&#39;, &quot;xyzw&quot;_str.substring(locationVectorLength - 1, 1), &#39;)&#39;);</span>
<span class="line-added">+             } else</span>
<span class="line-added">+                 stringBuilder.append(&quot;uint&quot;, vectorSuffix(locationVectorLength), &#39;(&#39;, args[1], &#39;)&#39;);</span>
<span class="line-added">+             stringBuilder.append(&#39;)&#39;);</span>
<span class="line-added">+             if (!textureType.isDepthTexture())</span>
<span class="line-added">+                 stringBuilder.append(&#39;.&#39;, &quot;xyzw&quot;_str.substring(0, returnVectorLength));</span>
<span class="line-added">+             stringBuilder.append(&quot;;\n&quot;);</span>
<span class="line-added">+         }</span>
<span class="line-added">+         stringBuilder.append(indent, &quot;} while(0);\n&quot;);</span>
<span class="line-added">+ </span>
<span class="line-added">+         return;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (nativeFunctionDeclaration.name() == &quot;load&quot;) {</span>
<span class="line-added">+         ASSERT(nativeFunctionDeclaration.parameters().size() == 1);</span>
<span class="line-added">+         stringBuilder.append(</span>
<span class="line-added">+             indent, returnName, &quot; = atomic_load_explicit(&quot;, args[0], &quot;, memory_order_relaxed);\n&quot;);</span>
<span class="line-added">+         return;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (nativeFunctionDeclaration.name() == &quot;store&quot;) {</span>
<span class="line-added">+         ASSERT(nativeFunctionDeclaration.parameters().size() == 2);</span>
<span class="line-added">+         stringBuilder.append(</span>
<span class="line-added">+             indent, &quot;atomic_store_explicit(&quot;, args[0], &quot;, &quot;, args[1], &quot;, memory_order_relaxed);\n&quot;);</span>
<span class="line-added">+         return;</span>
      }
  
      if (nativeFunctionDeclaration.name() == &quot;GetDimensions&quot;) {
<span class="line-modified">!         auto&amp; textureType = downcast&lt;AST::NativeTypeDeclaration&gt;(downcast&lt;AST::NamedType&gt;(nativeFunctionDeclaration.parameters()[0]-&gt;type()-&gt;unifyNode()));</span>
<span class="line-modified">! </span>
<span class="line-added">+         size_t index = 1;</span>
<span class="line-added">+         bool hasMipLevel = !textureType.isWritableTexture() &amp;&amp; textureType.textureDimension() != 1;</span>
<span class="line-added">+         if (hasMipLevel)</span>
<span class="line-added">+             ++index;</span>
<span class="line-added">+         const MangledVariableName&amp; widthName = args[index];</span>
<span class="line-added">+         ++index;</span>
<span class="line-added">+         Optional&lt;MangledVariableName&gt; heightName;</span>
<span class="line-added">+         if (textureType.textureDimension() &gt;= 2) {</span>
<span class="line-added">+             heightName = args[index];</span>
<span class="line-added">+             ++index;</span>
<span class="line-added">+         }</span>
<span class="line-added">+         Optional&lt;MangledVariableName&gt; depthName;</span>
<span class="line-added">+         if (textureType.textureDimension() &gt;= 3) {</span>
<span class="line-added">+             depthName = args[index];</span>
<span class="line-added">+             ++index;</span>
<span class="line-added">+         }</span>
<span class="line-added">+         Optional&lt;MangledVariableName&gt; elementsName;</span>
<span class="line-added">+         if (textureType.isTextureArray()) {</span>
<span class="line-added">+             elementsName = args[index];</span>
<span class="line-added">+             ++index;</span>
<span class="line-added">+         }</span>
<span class="line-added">+         Optional&lt;MangledVariableName&gt; numberOfLevelsName;</span>
<span class="line-added">+         if (!textureType.isWritableTexture() &amp;&amp; textureType.textureDimension() != 1) {</span>
<span class="line-added">+             numberOfLevelsName = args[index];</span>
<span class="line-added">+             ++index;</span>
<span class="line-added">+         }</span>
<span class="line-added">+         ASSERT(index == nativeFunctionDeclaration.parameters().size());</span>
<span class="line-added">+ </span>
<span class="line-added">+         stringBuilder.append(</span>
<span class="line-added">+             indent, &quot;if (&quot;, widthName, &quot;)\n&quot;,</span>
<span class="line-added">+             indent, &quot;    *&quot;, widthName, &quot; = &quot;, args[0], &quot;.get_width(&quot;);</span>
<span class="line-added">+         if (hasMipLevel)</span>
<span class="line-added">+             stringBuilder.append(args[1]);</span>
<span class="line-added">+         stringBuilder.append(&quot;);\n&quot;);</span>
<span class="line-added">+ </span>
<span class="line-added">+         if (heightName) {</span>
<span class="line-added">+             stringBuilder.append(</span>
<span class="line-added">+                 indent, &quot;if (&quot;, *heightName, &quot;)\n&quot;,</span>
<span class="line-added">+                 indent, &quot;    *&quot;, *heightName, &quot; = &quot;, args[0], &quot;.get_height(&quot;);</span>
<span class="line-added">+             if (hasMipLevel)</span>
<span class="line-added">+                 stringBuilder.append(args[1]);</span>
<span class="line-added">+             stringBuilder.append(&quot;);\n&quot;);</span>
<span class="line-added">+         }</span>
<span class="line-added">+         if (depthName) {</span>
<span class="line-added">+             stringBuilder.append(</span>
<span class="line-added">+                 indent, &quot;if (&quot;, *depthName, &quot;)\n&quot;,</span>
<span class="line-added">+                 indent, &quot;    *&quot;, *depthName, &quot; = &quot;, args[0], &quot;.get_depth(&quot;);</span>
<span class="line-added">+             if (hasMipLevel)</span>
<span class="line-added">+                 stringBuilder.append(args[1]);</span>
<span class="line-added">+             stringBuilder.append(&quot;);\n&quot;);</span>
<span class="line-added">+         }</span>
<span class="line-added">+         if (elementsName) {</span>
<span class="line-added">+             stringBuilder.append(</span>
<span class="line-added">+                 indent, &quot;if (&quot;, *elementsName, &quot;)\n&quot;,</span>
<span class="line-added">+                 indent, &quot;    *&quot;, *elementsName, &quot; = &quot;, args[0], &quot;.get_array_size();\n&quot;);</span>
<span class="line-added">+         }</span>
<span class="line-added">+         if (numberOfLevelsName) {</span>
<span class="line-added">+             stringBuilder.append(</span>
<span class="line-added">+                 indent, &quot;if (&quot;, *numberOfLevelsName, &quot;)\n&quot;,</span>
<span class="line-added">+                 indent, &quot;    *&quot;, *numberOfLevelsName, &quot; = &quot;, args[0], &quot;.get_num_mip_levels();\n&quot;);</span>
<span class="line-added">+         }</span>
<span class="line-added">+         return;</span>
      }
  
      if (nativeFunctionDeclaration.name() == &quot;SampleBias&quot;) {
<span class="line-modified">!         // FIXME: https://bugs.webkit.org/show_bug.cgi?id=195813 Implement this</span>
<span class="line-modified">!         notImplemented();</span>
      }
  
      if (nativeFunctionDeclaration.name() == &quot;SampleGrad&quot;) {
<span class="line-modified">!         // FIXME: https://bugs.webkit.org/show_bug.cgi?id=195813 Implement this</span>
<span class="line-modified">!         notImplemented();</span>
      }
  
      if (nativeFunctionDeclaration.name() == &quot;SampleLevel&quot;) {
<span class="line-modified">!         // FIXME: https://bugs.webkit.org/show_bug.cgi?id=195813 Implement this</span>
<span class="line-modified">!         notImplemented();</span>
      }
  
      if (nativeFunctionDeclaration.name() == &quot;Gather&quot;) {
<span class="line-modified">!         // FIXME: https://bugs.webkit.org/show_bug.cgi?id=195813 Implement this</span>
<span class="line-modified">!         notImplemented();</span>
      }
  
      if (nativeFunctionDeclaration.name() == &quot;GatherRed&quot;) {
<span class="line-modified">!         // FIXME: https://bugs.webkit.org/show_bug.cgi?id=195813 Implement this</span>
<span class="line-modified">!         notImplemented();</span>
      }
  
      if (nativeFunctionDeclaration.name() == &quot;SampleCmp&quot;) {
<span class="line-modified">!         // FIXME: https://bugs.webkit.org/show_bug.cgi?id=195813 Implement this</span>
<span class="line-modified">!         notImplemented();</span>
      }
  
      if (nativeFunctionDeclaration.name() == &quot;SampleCmpLevelZero&quot;) {
<span class="line-modified">!         // FIXME: https://bugs.webkit.org/show_bug.cgi?id=195813 Implement this</span>
<span class="line-modified">!         notImplemented();</span>
      }
  
      if (nativeFunctionDeclaration.name() == &quot;Store&quot;) {
<span class="line-modified">!         ASSERT(nativeFunctionDeclaration.parameters().size() == 3);</span>
<span class="line-modified">! </span>
<span class="line-added">+         auto&amp; textureType = downcast&lt;AST::NativeTypeDeclaration&gt;(downcast&lt;AST::NamedType&gt;(nativeFunctionDeclaration.parameters()[0]-&gt;type()-&gt;unifyNode()));</span>
<span class="line-added">+         auto&amp; itemType = downcast&lt;AST::NativeTypeDeclaration&gt;(downcast&lt;AST::NamedType&gt;(nativeFunctionDeclaration.parameters()[1]-&gt;type()-&gt;unifyNode()));</span>
<span class="line-added">+         auto&amp; itemVectorInnerType = vectorInnerType(itemType);</span>
<span class="line-added">+         auto itemVectorLength = vectorLength(itemType);</span>
<span class="line-added">+         auto&amp; locationType = downcast&lt;AST::NativeTypeDeclaration&gt;(downcast&lt;AST::NamedType&gt;(nativeFunctionDeclaration.parameters()[2]-&gt;type()-&gt;unifyNode()));</span>
<span class="line-added">+         auto locationVectorLength = vectorLength(locationType);</span>
<span class="line-added">+ </span>
<span class="line-added">+         auto metalInnerTypeName = typeNamer.mangledNameForType(itemVectorInnerType);</span>
<span class="line-added">+ </span>
<span class="line-added">+         stringBuilder.append(&quot;do {\n&quot;);</span>
<span class="line-added">+         {</span>
<span class="line-added">+             IndentationScope scope(indent);</span>
<span class="line-added">+ </span>
<span class="line-added">+             if (textureType.isTextureArray()) {</span>
<span class="line-added">+                 ASSERT(locationVectorLength &gt; 1);</span>
<span class="line-added">+                 String dimensions[] = { &quot;width&quot;_str, &quot;height&quot;_str, &quot;depth&quot;_str };</span>
<span class="line-added">+                 for (int i = 0; i &lt; locationVectorLength - 1; ++i) {</span>
<span class="line-added">+                     auto suffix = &quot;xyzw&quot;_str.substring(i, 1);</span>
<span class="line-added">+                     stringBuilder.append(</span>
<span class="line-added">+                         indent, &quot;if (&quot;, args[2], &quot;.&quot;, suffix, &quot; &gt;= &quot;, args[0], &quot;.get_&quot;, dimensions[i], &quot;())\n&quot;,</span>
<span class="line-added">+                         indent, &quot;    break;\n&quot;);</span>
<span class="line-added">+                 }</span>
<span class="line-added">+                 auto suffix = &quot;xyzw&quot;_str.substring(locationVectorLength - 1, 1);</span>
<span class="line-added">+                 stringBuilder.append(</span>
<span class="line-added">+                     indent, &quot;if (&quot;, args[2], &#39;.&#39;, suffix, &quot; &gt;= &quot;, args[0], &quot;.get_array_size())\n&quot;,</span>
<span class="line-added">+                     indent, &quot;    break;\n&quot;);</span>
<span class="line-added">+             } else {</span>
<span class="line-added">+                 if (locationVectorLength == 1) {</span>
<span class="line-added">+                     stringBuilder.append(</span>
<span class="line-added">+                         indent, &quot;if (&quot;, args[2], &quot; &gt;= &quot;, args[0], &quot;.get_width()) \n&quot;,</span>
<span class="line-added">+                         indent, &quot;    break;\n&quot;);</span>
<span class="line-added">+                 } else {</span>
<span class="line-added">+                     stringBuilder.append(</span>
<span class="line-added">+                         indent, &quot;if (&quot;, args[2], &quot;.x &gt;= &quot;, args[0], &quot;.get_width())\n&quot;,</span>
<span class="line-added">+                         indent, &quot;    break;\n&quot;,</span>
<span class="line-added">+                         indent, &quot;if (&quot;, args[2], &quot;.y &gt;= &quot;, args[0], &quot;.get_height())\n&quot;,</span>
<span class="line-added">+                         indent, &quot;    break;\n&quot;);</span>
<span class="line-added">+                     if (locationVectorLength &gt;= 3) {</span>
<span class="line-added">+                         stringBuilder.append(</span>
<span class="line-added">+                             indent, &quot;if (&quot;, args[2], &quot;.z &gt;= &quot;, args[0], &quot;.get_depth())\n&quot;,</span>
<span class="line-added">+                             indent, &quot;    break;\n&quot;);</span>
<span class="line-added">+                     }</span>
<span class="line-added">+                 }</span>
<span class="line-added">+             }</span>
<span class="line-added">+             stringBuilder.append(indent, args[0], &quot;.write(vec&lt;&quot;, metalInnerTypeName, &quot;, 4&gt;(&quot;, args[1]);</span>
<span class="line-added">+             for (int i = 0; i &lt; 4 - itemVectorLength; ++i)</span>
<span class="line-added">+                 stringBuilder.append(&quot;, 0&quot;);</span>
<span class="line-added">+             stringBuilder.append(&quot;), &quot;);</span>
<span class="line-added">+             if (textureType.isTextureArray()) {</span>
<span class="line-added">+                 ASSERT(locationVectorLength &gt; 1);</span>
<span class="line-added">+                 stringBuilder.append(&quot;uint&quot;, vectorSuffix(locationVectorLength - 1), &#39;(&#39;, args[2], &#39;.&#39;, &quot;xyzw&quot;_str.substring(0, locationVectorLength - 1), &quot;), uint(&quot;, args[2], &quot;.&quot;, &quot;xyzw&quot;_str.substring(locationVectorLength - 1, 1), &#39;)&#39;);</span>
<span class="line-added">+             } else</span>
<span class="line-added">+                 stringBuilder.append(&quot;uint&quot;, vectorSuffix(locationVectorLength), &#39;(&#39;, args[2], &#39;)&#39;);</span>
<span class="line-added">+             stringBuilder.append(&quot;);\n&quot;);</span>
<span class="line-added">+         }</span>
<span class="line-added">+         stringBuilder.append(indent, &quot;} while(0);\n&quot;);</span>
<span class="line-added">+ </span>
<span class="line-added">+         return;</span>
      }
  
      if (nativeFunctionDeclaration.name() == &quot;GatherAlpha&quot;) {
<span class="line-modified">!         // FIXME: https://bugs.webkit.org/show_bug.cgi?id=195813 Implement this</span>
<span class="line-modified">!         notImplemented();</span>
      }
  
      if (nativeFunctionDeclaration.name() == &quot;GatherBlue&quot;) {
<span class="line-modified">!         // FIXME: https://bugs.webkit.org/show_bug.cgi?id=195813 Implement this</span>
<span class="line-modified">!         notImplemented();</span>
      }
  
      if (nativeFunctionDeclaration.name() == &quot;GatherCmp&quot;) {
<span class="line-modified">!         // FIXME: https://bugs.webkit.org/show_bug.cgi?id=195813 Implement this</span>
<span class="line-modified">!         notImplemented();</span>
      }
  
      if (nativeFunctionDeclaration.name() == &quot;GatherCmpRed&quot;) {
<span class="line-modified">!         // FIXME: https://bugs.webkit.org/show_bug.cgi?id=195813 Implement this</span>
<span class="line-modified">!         notImplemented();</span>
      }
  
      if (nativeFunctionDeclaration.name() == &quot;GatherGreen&quot;) {
<span class="line-modified">!         // FIXME: https://bugs.webkit.org/show_bug.cgi?id=195813 Implement this</span>
<span class="line-modified">!         notImplemented();</span>
      }
  
      ASSERT_NOT_REACHED();
  }
  
  } // namespace Metal
  
  } // namespace WHLSL
</pre>
<center><a href="WHLSLMetalCodeGenerator.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="WHLSLNativeFunctionWriter.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>