<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/b3/B3ReduceStrength.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="B3PureCSE.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="B3SlotBaseValue.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/b3/B3ReduceStrength.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 31,10 ***</span>
<span class="line-new-header">--- 31,11 ---</span>
  #include &quot;B3AtomicValue.h&quot;
  #include &quot;B3BasicBlockInlines.h&quot;
  #include &quot;B3BlockInsertionSet.h&quot;
  #include &quot;B3ComputeDivisionMagic.h&quot;
  #include &quot;B3Dominators.h&quot;
<span class="line-added">+ #include &quot;B3EliminateDeadCode.h&quot;</span>
  #include &quot;B3InsertionSetInlines.h&quot;
  #include &quot;B3MemoryValueInlines.h&quot;
  #include &quot;B3PhaseScope.h&quot;
  #include &quot;B3PhiChildren.h&quot;
  #include &quot;B3ProcedureInlines.h&quot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 112,11 ***</span>
          return IntRange(std::numeric_limits&lt;T&gt;::min(), std::numeric_limits&lt;T&gt;::max());
      }
  
      static IntRange top(Type type)
      {
<span class="line-modified">!         switch (type) {</span>
          case Int32:
              return top&lt;int32_t&gt;();
          case Int64:
              return top&lt;int64_t&gt;();
          default:
<span class="line-new-header">--- 113,11 ---</span>
          return IntRange(std::numeric_limits&lt;T&gt;::min(), std::numeric_limits&lt;T&gt;::max());
      }
  
      static IntRange top(Type type)
      {
<span class="line-modified">!         switch (type.kind()) {</span>
          case Int32:
              return top&lt;int32_t&gt;();
          case Int64:
              return top&lt;int64_t&gt;();
          default:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 133,11 ***</span>
          return IntRange(0, mask);
      }
  
      static IntRange rangeForMask(int64_t mask, Type type)
      {
<span class="line-modified">!         switch (type) {</span>
          case Int32:
              return rangeForMask&lt;int32_t&gt;(static_cast&lt;int32_t&gt;(mask));
          case Int64:
              return rangeForMask&lt;int64_t&gt;(mask);
          default:
<span class="line-new-header">--- 134,11 ---</span>
          return IntRange(0, mask);
      }
  
      static IntRange rangeForMask(int64_t mask, Type type)
      {
<span class="line-modified">!         switch (type.kind()) {</span>
          case Int32:
              return rangeForMask&lt;int32_t&gt;(static_cast&lt;int32_t&gt;(mask));
          case Int64:
              return rangeForMask&lt;int64_t&gt;(mask);
          default:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 155,11 ***</span>
          return rangeForMask&lt;T&gt;(static_cast&lt;T&gt;(mask));
      }
  
      static IntRange rangeForZShr(int32_t shiftAmount, Type type)
      {
<span class="line-modified">!         switch (type) {</span>
          case Int32:
              return rangeForZShr&lt;int32_t&gt;(shiftAmount);
          case Int64:
              return rangeForZShr&lt;int64_t&gt;(shiftAmount);
          default:
<span class="line-new-header">--- 156,11 ---</span>
          return rangeForMask&lt;T&gt;(static_cast&lt;T&gt;(mask));
      }
  
      static IntRange rangeForZShr(int32_t shiftAmount, Type type)
      {
<span class="line-modified">!         switch (type.kind()) {</span>
          case Int32:
              return rangeForZShr&lt;int32_t&gt;(shiftAmount);
          case Int64:
              return rangeForZShr&lt;int64_t&gt;(shiftAmount);
          default:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 185,11 ***</span>
              || sumOverflows&lt;T&gt;(m_max, other.m_max);
      }
  
      bool couldOverflowAdd(const IntRange&amp; other, Type type)
      {
<span class="line-modified">!         switch (type) {</span>
          case Int32:
              return couldOverflowAdd&lt;int32_t&gt;(other);
          case Int64:
              return couldOverflowAdd&lt;int64_t&gt;(other);
          default:
<span class="line-new-header">--- 186,11 ---</span>
              || sumOverflows&lt;T&gt;(m_max, other.m_max);
      }
  
      bool couldOverflowAdd(const IntRange&amp; other, Type type)
      {
<span class="line-modified">!         switch (type.kind()) {</span>
          case Int32:
              return couldOverflowAdd&lt;int32_t&gt;(other);
          case Int64:
              return couldOverflowAdd&lt;int64_t&gt;(other);
          default:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 206,11 ***</span>
              || differenceOverflows&lt;T&gt;(m_max, other.m_max);
      }
  
      bool couldOverflowSub(const IntRange&amp; other, Type type)
      {
<span class="line-modified">!         switch (type) {</span>
          case Int32:
              return couldOverflowSub&lt;int32_t&gt;(other);
          case Int64:
              return couldOverflowSub&lt;int64_t&gt;(other);
          default:
<span class="line-new-header">--- 207,11 ---</span>
              || differenceOverflows&lt;T&gt;(m_max, other.m_max);
      }
  
      bool couldOverflowSub(const IntRange&amp; other, Type type)
      {
<span class="line-modified">!         switch (type.kind()) {</span>
          case Int32:
              return couldOverflowSub&lt;int32_t&gt;(other);
          case Int64:
              return couldOverflowSub&lt;int64_t&gt;(other);
          default:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 227,11 ***</span>
              || productOverflows&lt;T&gt;(m_max, other.m_max);
      }
  
      bool couldOverflowMul(const IntRange&amp; other, Type type)
      {
<span class="line-modified">!         switch (type) {</span>
          case Int32:
              return couldOverflowMul&lt;int32_t&gt;(other);
          case Int64:
              return couldOverflowMul&lt;int64_t&gt;(other);
          default:
<span class="line-new-header">--- 228,11 ---</span>
              || productOverflows&lt;T&gt;(m_max, other.m_max);
      }
  
      bool couldOverflowMul(const IntRange&amp; other, Type type)
      {
<span class="line-modified">!         switch (type.kind()) {</span>
          case Int32:
              return couldOverflowMul&lt;int32_t&gt;(other);
          case Int64:
              return couldOverflowMul&lt;int64_t&gt;(other);
          default:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 253,11 ***</span>
          return IntRange(newMin, newMax);
      }
  
      IntRange shl(int32_t shiftAmount, Type type)
      {
<span class="line-modified">!         switch (type) {</span>
          case Int32:
              return shl&lt;int32_t&gt;(shiftAmount);
          case Int64:
              return shl&lt;int64_t&gt;(shiftAmount);
          default:
<span class="line-new-header">--- 254,11 ---</span>
          return IntRange(newMin, newMax);
      }
  
      IntRange shl(int32_t shiftAmount, Type type)
      {
<span class="line-modified">!         switch (type.kind()) {</span>
          case Int32:
              return shl&lt;int32_t&gt;(shiftAmount);
          case Int64:
              return shl&lt;int64_t&gt;(shiftAmount);
          default:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 275,11 ***</span>
          return IntRange(newMin, newMax);
      }
  
      IntRange sShr(int32_t shiftAmount, Type type)
      {
<span class="line-modified">!         switch (type) {</span>
          case Int32:
              return sShr&lt;int32_t&gt;(shiftAmount);
          case Int64:
              return sShr&lt;int64_t&gt;(shiftAmount);
          default:
<span class="line-new-header">--- 276,11 ---</span>
          return IntRange(newMin, newMax);
      }
  
      IntRange sShr(int32_t shiftAmount, Type type)
      {
<span class="line-modified">!         switch (type.kind()) {</span>
          case Int32:
              return sShr&lt;int32_t&gt;(shiftAmount);
          case Int64:
              return sShr&lt;int64_t&gt;(shiftAmount);
          default:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 308,11 ***</span>
          return IntRange(newMin, newMax);
      }
  
      IntRange zShr(int32_t shiftAmount, Type type)
      {
<span class="line-modified">!         switch (type) {</span>
          case Int32:
              return zShr&lt;int32_t&gt;(shiftAmount);
          case Int64:
              return zShr&lt;int64_t&gt;(shiftAmount);
          default:
<span class="line-new-header">--- 309,11 ---</span>
          return IntRange(newMin, newMax);
      }
  
      IntRange zShr(int32_t shiftAmount, Type type)
      {
<span class="line-modified">!         switch (type.kind()) {</span>
          case Int32:
              return zShr&lt;int32_t&gt;(shiftAmount);
          case Int64:
              return zShr&lt;int64_t&gt;(shiftAmount);
          default:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 329,11 ***</span>
          return IntRange(m_min + other.m_min, m_max + other.m_max);
      }
  
      IntRange add(const IntRange&amp; other, Type type)
      {
<span class="line-modified">!         switch (type) {</span>
          case Int32:
              return add&lt;int32_t&gt;(other);
          case Int64:
              return add&lt;int64_t&gt;(other);
          default:
<span class="line-new-header">--- 330,11 ---</span>
          return IntRange(m_min + other.m_min, m_max + other.m_max);
      }
  
      IntRange add(const IntRange&amp; other, Type type)
      {
<span class="line-modified">!         switch (type.kind()) {</span>
          case Int32:
              return add&lt;int32_t&gt;(other);
          case Int64:
              return add&lt;int64_t&gt;(other);
          default:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 350,11 ***</span>
          return IntRange(m_min - other.m_max, m_max - other.m_min);
      }
  
      IntRange sub(const IntRange&amp; other, Type type)
      {
<span class="line-modified">!         switch (type) {</span>
          case Int32:
              return sub&lt;int32_t&gt;(other);
          case Int64:
              return sub&lt;int64_t&gt;(other);
          default:
<span class="line-new-header">--- 351,11 ---</span>
          return IntRange(m_min - other.m_max, m_max - other.m_min);
      }
  
      IntRange sub(const IntRange&amp; other, Type type)
      {
<span class="line-modified">!         switch (type.kind()) {</span>
          case Int32:
              return sub&lt;int32_t&gt;(other);
          case Int64:
              return sub&lt;int64_t&gt;(other);
          default:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 377,11 ***</span>
                  std::max(m_max * other.m_min, m_max * other.m_max)));
      }
  
      IntRange mul(const IntRange&amp; other, Type type)
      {
<span class="line-modified">!         switch (type) {</span>
          case Int32:
              return mul&lt;int32_t&gt;(other);
          case Int64:
              return mul&lt;int64_t&gt;(other);
          default:
<span class="line-new-header">--- 378,11 ---</span>
                  std::max(m_max * other.m_min, m_max * other.m_max)));
      }
  
      IntRange mul(const IntRange&amp; other, Type type)
      {
<span class="line-modified">!         switch (type.kind()) {</span>
          case Int32:
              return mul&lt;int32_t&gt;(other);
          case Int64:
              return mul&lt;int64_t&gt;(other);
          default:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 399,10 ***</span>
<span class="line-new-header">--- 400,11 ---</span>
  public:
      ReduceStrength(Procedure&amp; proc)
          : m_proc(proc)
          , m_insertionSet(proc)
          , m_blockInsertionSet(proc)
<span class="line-added">+         , m_root(proc.at(0))</span>
      {
      }
  
      bool run()
      {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 438,11 ***</span>
              //
              // If we do CSE before DCE, we will remove @thing and keep @dead. Effectively, we will
              // &quot;hoist&quot; @thing. On the other hand, if we run DCE before CSE, we will kill @dead and
              // keep @thing. That&#39;s better, since we usually want things to stay wherever the client
              // put them. We&#39;re not actually smart enough to move things around at random.
<span class="line-modified">!             killDeadCode();</span>
  
              simplifySSA();
  
              if (m_proc.optLevel() &gt;= 2) {
                  m_proc.resetValueOwners();
<span class="line-new-header">--- 440,12 ---</span>
              //
              // If we do CSE before DCE, we will remove @thing and keep @dead. Effectively, we will
              // &quot;hoist&quot; @thing. On the other hand, if we run DCE before CSE, we will kill @dead and
              // keep @thing. That&#39;s better, since we usually want things to stay wherever the client
              // put them. We&#39;re not actually smart enough to move things around at random.
<span class="line-modified">!             m_changed |= eliminateDeadCodeImpl(m_proc);</span>
<span class="line-added">+             m_valueForConstant.clear();</span>
  
              simplifySSA();
  
              if (m_proc.optLevel() &gt;= 2) {
                  m_proc.resetValueOwners();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 600,10 ***</span>
<span class="line-new-header">--- 603,13 ---</span>
                      &amp;&amp; m_value-&gt;child(1)-&gt;isInt(-1)
                      &amp;&amp; m_value-&gt;child(0)-&gt;child(0)-&gt;isInt(0)) {
                      replaceWithNew&lt;Value&gt;(BitXor, m_value-&gt;origin(), m_value-&gt;child(0)-&gt;child(1), m_value-&gt;child(1));
                      break;
                  }
<span class="line-added">+ </span>
<span class="line-added">+                 if (handleMulDistributivity())</span>
<span class="line-added">+                     break;</span>
              }
  
              break;
  
          case Sub:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 642,10 ***</span>
<span class="line-new-header">--- 648,46 ---</span>
                  // Into this: Add(value, otherValue)
                  if (m_value-&gt;child(1)-&gt;opcode() == Neg) {
                      replaceWithNew&lt;Value&gt;(Add, m_value-&gt;origin(), m_value-&gt;child(0), m_value-&gt;child(1)-&gt;child(0));
                      break;
                  }
<span class="line-added">+ </span>
<span class="line-added">+                 // Turn this: Sub(Neg(value), value2)</span>
<span class="line-added">+                 // Into this: Neg(Add(value, value2))</span>
<span class="line-added">+                 if (m_value-&gt;child(0)-&gt;opcode() == Neg) {</span>
<span class="line-added">+                     replaceWithNew&lt;Value&gt;(Neg, m_value-&gt;origin(),</span>
<span class="line-added">+                         m_insertionSet.insert&lt;Value&gt;(m_index, Add, m_value-&gt;origin(), m_value-&gt;child(0)-&gt;child(0), m_value-&gt;child(1)));</span>
<span class="line-added">+                     break;</span>
<span class="line-added">+                 }</span>
<span class="line-added">+ </span>
<span class="line-added">+                 // Turn this: Sub(Sub(a, b), c)</span>
<span class="line-added">+                 // Into this: Sub(a, Add(b, c))</span>
<span class="line-added">+                 if (m_value-&gt;child(0)-&gt;opcode() == Sub) {</span>
<span class="line-added">+                     replaceWithNew&lt;Value&gt;(Sub, m_value-&gt;origin(), m_value-&gt;child(0)-&gt;child(0),</span>
<span class="line-added">+                         m_insertionSet.insert&lt;Value&gt;(m_index, Add, m_value-&gt;origin(), m_value-&gt;child(0)-&gt;child(1), m_value-&gt;child(1)));</span>
<span class="line-added">+                     break;</span>
<span class="line-added">+                 }</span>
<span class="line-added">+ </span>
<span class="line-added">+                 // Turn this: Sub(a, Sub(b, c))</span>
<span class="line-added">+                 // Into this: Add(Sub(a, b), c)</span>
<span class="line-added">+                 if (m_value-&gt;child(1)-&gt;opcode() == Sub) {</span>
<span class="line-added">+                     replaceWithNew&lt;Value&gt;(Add, m_value-&gt;origin(),</span>
<span class="line-added">+                         m_insertionSet.insert&lt;Value&gt;(m_index, Sub, m_value-&gt;origin(), m_value-&gt;child(0), m_value-&gt;child(1)-&gt;child(0)),</span>
<span class="line-added">+                         m_value-&gt;child(1)-&gt;child(1));</span>
<span class="line-added">+                     break;</span>
<span class="line-added">+                 }</span>
<span class="line-added">+ </span>
<span class="line-added">+                 // Turn this: Sub(Add(a, b), c)</span>
<span class="line-added">+                 // Into this: Add(a, Sub(b, c))</span>
<span class="line-added">+                 if (m_value-&gt;child(0)-&gt;opcode() == Add) {</span>
<span class="line-added">+                     replaceWithNew&lt;Value&gt;(Add, m_value-&gt;origin(), m_value-&gt;child(0)-&gt;child(0),</span>
<span class="line-added">+                         m_insertionSet.insert&lt;Value&gt;(m_index, Sub, m_value-&gt;origin(), m_value-&gt;child(0)-&gt;child(1), m_value-&gt;child(1)));</span>
<span class="line-added">+                     break;</span>
<span class="line-added">+                 }</span>
<span class="line-added">+ </span>
<span class="line-added">+                 if (handleMulDistributivity())</span>
<span class="line-added">+                     break;</span>
              }
  
              break;
  
          case Neg:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 661,17 ***</span>
              if (m_value-&gt;child(0)-&gt;opcode() == Neg) {
                  replaceWithIdentity(m_value-&gt;child(0)-&gt;child(0));
                  break;
              }
  
<span class="line-modified">!             // Turn this: Integer Neg(Sub(value, otherValue))</span>
<span class="line-modified">!             // Into this: Sub(otherValue, value)</span>
<span class="line-modified">!             if (m_value-&gt;isInteger() &amp;&amp; m_value-&gt;child(0)-&gt;opcode() == Sub) {</span>
<span class="line-modified">!                 replaceWithNew&lt;Value&gt;(Sub, m_value-&gt;origin(), m_value-&gt;child(0)-&gt;child(1), m_value-&gt;child(0)-&gt;child(0));</span>
<span class="line-modified">!                 break;</span>
              }
  
              break;
  
          case Mul:
              handleCommutativity();
  
<span class="line-new-header">--- 703,33 ---</span>
              if (m_value-&gt;child(0)-&gt;opcode() == Neg) {
                  replaceWithIdentity(m_value-&gt;child(0)-&gt;child(0));
                  break;
              }
  
<span class="line-modified">!             if (m_value-&gt;isInteger()) {</span>
<span class="line-modified">!                 // Turn this: Integer Neg(Sub(value, otherValue))</span>
<span class="line-modified">!                 // Into this: Sub(otherValue, value)</span>
<span class="line-modified">!                 if (m_value-&gt;child(0)-&gt;opcode() == Sub) {</span>
<span class="line-modified">!                     replaceWithNew&lt;Value&gt;(Sub, m_value-&gt;origin(), m_value-&gt;child(0)-&gt;child(1), m_value-&gt;child(0)-&gt;child(0));</span>
<span class="line-added">+                     break;</span>
<span class="line-added">+                 }</span>
<span class="line-added">+ </span>
<span class="line-added">+                 // Turn this: Integer Neg(Mul(value, c))</span>
<span class="line-added">+                 // Into this: Mul(value, -c), as long as -c does not overflow</span>
<span class="line-added">+                 if (m_value-&gt;child(0)-&gt;opcode() == Mul &amp;&amp; m_value-&gt;child(0)-&gt;child(1)-&gt;hasInt()) {</span>
<span class="line-added">+                     int64_t factor = m_value-&gt;child(0)-&gt;child(1)-&gt;asInt();</span>
<span class="line-added">+                     if (m_value-&gt;type() == Int32 &amp;&amp; factor != std::numeric_limits&lt;int32_t&gt;::min()) {</span>
<span class="line-added">+                         Value* newFactor = m_insertionSet.insert&lt;Const32Value&gt;(m_index, m_value-&gt;child(0)-&gt;child(1)-&gt;origin(), -factor);</span>
<span class="line-added">+                         replaceWithNew&lt;Value&gt;(Mul, m_value-&gt;origin(), m_value-&gt;child(0)-&gt;child(0), newFactor);</span>
<span class="line-added">+                     } else if (m_value-&gt;type() == Int64 &amp;&amp; factor != std::numeric_limits&lt;int64_t&gt;::min()) {</span>
<span class="line-added">+                         Value* newFactor = m_insertionSet.insert&lt;Const64Value&gt;(m_index, m_value-&gt;child(0)-&gt;child(1)-&gt;origin(), -factor);</span>
<span class="line-added">+                         replaceWithNew&lt;Value&gt;(Mul, m_value-&gt;origin(), m_value-&gt;child(0)-&gt;child(0), newFactor);</span>
<span class="line-added">+                     }</span>
<span class="line-added">+                 }</span>
              }
  
<span class="line-added">+ </span>
              break;
  
          case Mul:
              handleCommutativity();
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 700,17 ***</span>
                      replaceWithIdentity(m_value-&gt;child(0));
                      break;
                  }
  
                  // Turn this: Mul(value, -1)
<span class="line-modified">!                 // Into this: Sub(0, value)</span>
                  if (factor == -1) {
<span class="line-modified">!                     replaceWithNewValue(</span>
<span class="line-removed">-                         m_proc.add&lt;Value&gt;(</span>
<span class="line-removed">-                             Sub, m_value-&gt;origin(),</span>
<span class="line-removed">-                             m_insertionSet.insertIntConstant(m_index, m_value, 0),</span>
<span class="line-removed">-                             m_value-&gt;child(0)));</span>
                      break;
                  }
  
                  // Turn this: Mul(value, constant)
                  // Into this: Shl(value, log2(constant))
<span class="line-new-header">--- 758,13 ---</span>
                      replaceWithIdentity(m_value-&gt;child(0));
                      break;
                  }
  
                  // Turn this: Mul(value, -1)
<span class="line-modified">!                 // Into this: Neg(value)</span>
                  if (factor == -1) {
<span class="line-modified">!                     replaceWithNew&lt;Value&gt;(Neg, m_value-&gt;origin(), m_value-&gt;child(0));</span>
                      break;
                  }
  
                  // Turn this: Mul(value, constant)
                  // Into this: Shl(value, log2(constant))
</pre>
<hr />
<pre>
<span class="line-old-header">*** 732,10 ***</span>
<span class="line-new-header">--- 786,27 ---</span>
                      replaceWithIdentity(m_value-&gt;child(0));
                      break;
                  }
              }
  
<span class="line-added">+             if (m_value-&gt;isInteger()) {</span>
<span class="line-added">+                 // Turn this: Integer Mul(value, Neg(otherValue))</span>
<span class="line-added">+                 // Into this: Neg(Mul(value, otherValue))</span>
<span class="line-added">+                 if (m_value-&gt;child(1)-&gt;opcode() == Neg) {</span>
<span class="line-added">+                     Value* newMul = m_insertionSet.insert&lt;Value&gt;(m_index, Mul, m_value-&gt;origin(), m_value-&gt;child(0), m_value-&gt;child(1)-&gt;child(0));</span>
<span class="line-added">+                     replaceWithNew&lt;Value&gt;(Neg, m_value-&gt;origin(), newMul);</span>
<span class="line-added">+                     break;</span>
<span class="line-added">+                 }</span>
<span class="line-added">+                 // Turn this: Integer Mul(Neg(value), otherValue)</span>
<span class="line-added">+                 // Into this: Neg(Mul(value, value2))</span>
<span class="line-added">+                 if (m_value-&gt;child(0)-&gt;opcode() == Neg) {</span>
<span class="line-added">+                     Value* newMul = m_insertionSet.insert&lt;Value&gt;(m_index, Mul, m_value-&gt;origin(), m_value-&gt;child(0)-&gt;child(0), m_value-&gt;child(1));</span>
<span class="line-added">+                     replaceWithNew&lt;Value&gt;(Neg, m_value-&gt;origin(), newMul);</span>
<span class="line-added">+                     break;</span>
<span class="line-added">+                 }</span>
<span class="line-added">+             }</span>
<span class="line-added">+ </span>
              break;
  
          case Div:
              // Turn this: Div(constant1, constant2)
              // Into this: constant1 / constant2
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1198,10 ***</span>
<span class="line-new-header">--- 1269,23 ---</span>
              if (Value* constant = m_value-&gt;child(0)-&gt;shlConstant(m_proc, m_value-&gt;child(1))) {
                  replaceWithNewValue(constant);
                  break;
              }
  
<span class="line-added">+             // Turn this: Shl(&lt;S|Z&gt;Shr(@x, @const), @const)</span>
<span class="line-added">+             // Into this: BitAnd(@x, -(1&lt;&lt;@const))</span>
<span class="line-added">+             if ((m_value-&gt;child(0)-&gt;opcode() == SShr || m_value-&gt;child(0)-&gt;opcode() == ZShr)</span>
<span class="line-added">+                 &amp;&amp; m_value-&gt;child(0)-&gt;child(1)-&gt;hasInt()</span>
<span class="line-added">+                 &amp;&amp; m_value-&gt;child(1)-&gt;hasInt()</span>
<span class="line-added">+                 &amp;&amp; m_value-&gt;child(0)-&gt;child(1)-&gt;asInt() == m_value-&gt;child(1)-&gt;asInt()) {</span>
<span class="line-added">+                 int shiftAmount = m_value-&gt;child(1)-&gt;asInt() &amp; (m_value-&gt;type() == Int32 ? 31 : 63);</span>
<span class="line-added">+                 Value* newConst = m_proc.addIntConstant(m_value, - static_cast&lt;int64_t&gt;(1ull &lt;&lt; shiftAmount));</span>
<span class="line-added">+                 m_insertionSet.insertValue(m_index, newConst);</span>
<span class="line-added">+                 replaceWithNew&lt;Value&gt;(BitAnd, m_value-&gt;origin(), m_value-&gt;child(0)-&gt;child(0), newConst);</span>
<span class="line-added">+                 break;</span>
<span class="line-added">+             }</span>
<span class="line-added">+ </span>
              handleShiftAmount();
              break;
  
          case SShr:
              // Turn this: SShr(constant1, constant2)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2095,10 ***</span>
<span class="line-new-header">--- 2179,33 ---</span>
                  }
              }
              break;
          }
  
<span class="line-added">+         case Const32:</span>
<span class="line-added">+         case Const64:</span>
<span class="line-added">+         case ConstFloat:</span>
<span class="line-added">+         case ConstDouble: {</span>
<span class="line-added">+             ValueKey key = m_value-&gt;key();</span>
<span class="line-added">+             if (Value* constInRoot = m_valueForConstant.get(key)) {</span>
<span class="line-added">+                 if (constInRoot != m_value) {</span>
<span class="line-added">+                     m_value-&gt;replaceWithIdentity(constInRoot);</span>
<span class="line-added">+                     m_changed = true;</span>
<span class="line-added">+                 }</span>
<span class="line-added">+             } else if (m_block == m_root)</span>
<span class="line-added">+                 m_valueForConstant.add(key, m_value);</span>
<span class="line-added">+             else {</span>
<span class="line-added">+                 Value* constInRoot = m_proc.clone(m_value);</span>
<span class="line-added">+                 ASSERT(m_root &amp;&amp; m_root-&gt;size() &gt;= 1);</span>
<span class="line-added">+                 m_root-&gt;appendNonTerminal(constInRoot);</span>
<span class="line-added">+                 m_valueForConstant.add(key, constInRoot);</span>
<span class="line-added">+                 m_value-&gt;replaceWithIdentity(constInRoot);</span>
<span class="line-added">+                 m_changed = true;</span>
<span class="line-added">+             }</span>
<span class="line-added">+             break;</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
          default:
              break;
          }
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2149,12 ***</span>
          if (B3ReduceStrengthInternal::verbose)
              dataLog(&quot;Specializing select: &quot;, deepDump(m_proc, source), &quot;\n&quot;);
  
          // This mutates startIndex to account for the fact that m_block got the front of it
          // chopped off.
<span class="line-modified">!         BasicBlock* predecessor =</span>
<span class="line-modified">!             m_blockInsertionSet.splitForward(m_block, m_index, &amp;m_insertionSet);</span>
  
          // Splitting will commit the insertion set, which changes the exact position of the
          // source. That&#39;s why we do the search after splitting.
          unsigned startIndex = UINT_MAX;
          for (unsigned i = predecessor-&gt;size(); i--;) {
<span class="line-new-header">--- 2256,15 ---</span>
          if (B3ReduceStrengthInternal::verbose)
              dataLog(&quot;Specializing select: &quot;, deepDump(m_proc, source), &quot;\n&quot;);
  
          // This mutates startIndex to account for the fact that m_block got the front of it
          // chopped off.
<span class="line-modified">!         BasicBlock* predecessor = m_blockInsertionSet.splitForward(m_block, m_index, &amp;m_insertionSet);</span>
<span class="line-modified">!         if (m_block == m_root) {</span>
<span class="line-added">+             m_root = predecessor;</span>
<span class="line-added">+             m_valueForConstant.clear();</span>
<span class="line-added">+         }</span>
  
          // Splitting will commit the insertion set, which changes the exact position of the
          // source. That&#39;s why we do the search after splitting.
          unsigned startIndex = UINT_MAX;
          for (unsigned i = predecessor-&gt;size(); i--;) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2281,10 ***</span>
<span class="line-new-header">--- 2391,54 ---</span>
              std::swap(m_value-&gt;child(0), m_value-&gt;child(1));
              m_changed = true;
          }
      }
  
<span class="line-added">+     // For Op==Add or Sub, turn any of these:</span>
<span class="line-added">+     //      Op(Mul(x1, x2), Mul(x1, x3))</span>
<span class="line-added">+     //      Op(Mul(x2, x1), Mul(x1, x3))</span>
<span class="line-added">+     //      Op(Mul(x1, x2), Mul(x3, x1))</span>
<span class="line-added">+     //      Op(Mul(x2, x1), Mul(x3, x1))</span>
<span class="line-added">+     // Into this: Mul(x1, Op(x2, x3))</span>
<span class="line-added">+     bool handleMulDistributivity()</span>
<span class="line-added">+     {</span>
<span class="line-added">+         ASSERT(m_value-&gt;opcode() == Add || m_value-&gt;opcode() == Sub);</span>
<span class="line-added">+         Value* x1 = nullptr;</span>
<span class="line-added">+         Value* x2 = nullptr;</span>
<span class="line-added">+         Value* x3 = nullptr;</span>
<span class="line-added">+         if (m_value-&gt;child(0)-&gt;opcode() == Mul &amp;&amp; m_value-&gt;child(1)-&gt;opcode() == Mul) {</span>
<span class="line-added">+             if (m_value-&gt;child(0)-&gt;child(0) == m_value-&gt;child(1)-&gt;child(0)) {</span>
<span class="line-added">+                 // Op(Mul(x1, x2), Mul(x1, x3))</span>
<span class="line-added">+                 x1 = m_value-&gt;child(0)-&gt;child(0);</span>
<span class="line-added">+                 x2 = m_value-&gt;child(0)-&gt;child(1);</span>
<span class="line-added">+                 x3 = m_value-&gt;child(1)-&gt;child(1);</span>
<span class="line-added">+             } else if (m_value-&gt;child(0)-&gt;child(1) == m_value-&gt;child(1)-&gt;child(0)) {</span>
<span class="line-added">+                 // Op(Mul(x2, x1), Mul(x1, x3))</span>
<span class="line-added">+                 x1 = m_value-&gt;child(0)-&gt;child(1);</span>
<span class="line-added">+                 x2 = m_value-&gt;child(0)-&gt;child(0);</span>
<span class="line-added">+                 x3 = m_value-&gt;child(1)-&gt;child(1);</span>
<span class="line-added">+             } else if (m_value-&gt;child(0)-&gt;child(0) == m_value-&gt;child(1)-&gt;child(1)) {</span>
<span class="line-added">+                 // Op(Mul(x1, x2), Mul(x3, x1))</span>
<span class="line-added">+                 x1 = m_value-&gt;child(0)-&gt;child(0);</span>
<span class="line-added">+                 x2 = m_value-&gt;child(0)-&gt;child(1);</span>
<span class="line-added">+                 x3 = m_value-&gt;child(1)-&gt;child(0);</span>
<span class="line-added">+             } else if (m_value-&gt;child(0)-&gt;child(1) == m_value-&gt;child(1)-&gt;child(1)) {</span>
<span class="line-added">+                 // Op(Mul(x2, x1), Mul(x3, x1))</span>
<span class="line-added">+                 x1 = m_value-&gt;child(0)-&gt;child(1);</span>
<span class="line-added">+                 x2 = m_value-&gt;child(0)-&gt;child(0);</span>
<span class="line-added">+                 x3 = m_value-&gt;child(1)-&gt;child(0);</span>
<span class="line-added">+             }</span>
<span class="line-added">+         }</span>
<span class="line-added">+         if (x1 != nullptr) {</span>
<span class="line-added">+             ASSERT(x2 != nullptr &amp;&amp; x3 != nullptr);</span>
<span class="line-added">+             Value* newOp = m_insertionSet.insert&lt;Value&gt;(m_index, m_value-&gt;opcode(), m_value-&gt;origin(), x2, x3);</span>
<span class="line-added">+             replaceWithNew&lt;Value&gt;(Mul, m_value-&gt;origin(), x1, newOp);</span>
<span class="line-added">+             return true;</span>
<span class="line-added">+         }</span>
<span class="line-added">+         return false;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      // For Op==BitOr or BitXor, turn any of these:
      //      Op(BitAnd(x1, x2), BitAnd(x1, x3))
      //      Op(BitAnd(x2, x1), BitAnd(x1, x3))
      //      Op(BitAnd(x1, x2), BitAnd(x3, x1))
      //      Op(BitAnd(x2, x1), BitAnd(x3, x1))
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2339,11 ***</span>
              }
          }
          if (x1 != nullptr) {
              ASSERT(x2 != nullptr &amp;&amp; x3 != nullptr);
              Value* bitOp = m_insertionSet.insert&lt;Value&gt;(m_index, m_value-&gt;opcode(), m_value-&gt;origin(), x2, x3);
<span class="line-modified">!             replaceWithNew&lt;Value&gt;(BitAnd, m_value-&gt;origin(), bitOp, x1);</span>
              return true;
          }
          return false;
      }
  
<span class="line-new-header">--- 2493,11 ---</span>
              }
          }
          if (x1 != nullptr) {
              ASSERT(x2 != nullptr &amp;&amp; x3 != nullptr);
              Value* bitOp = m_insertionSet.insert&lt;Value&gt;(m_index, m_value-&gt;opcode(), m_value-&gt;origin(), x2, x3);
<span class="line-modified">!             replaceWithNew&lt;Value&gt;(BitAnd, m_value-&gt;origin(), x1, bitOp);</span>
              return true;
          }
          return false;
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2635,74 ***</span>
              for (BasicBlock* successor : block-&gt;successorBlocks())
                  RELEASE_ASSERT(successor-&gt;containsPredecessor(block));
          }
      }
  
<span class="line-removed">-     void killDeadCode()</span>
<span class="line-removed">-     {</span>
<span class="line-removed">-         GraphNodeWorklist&lt;Value*, IndexSet&lt;Value*&gt;&gt; worklist;</span>
<span class="line-removed">-         Vector&lt;UpsilonValue*, 64&gt; upsilons;</span>
<span class="line-removed">-         for (BasicBlock* block : m_proc) {</span>
<span class="line-removed">-             for (Value* value : *block) {</span>
<span class="line-removed">-                 Effects effects;</span>
<span class="line-removed">-                 // We don&#39;t care about effects of SSA operations, since we model them more</span>
<span class="line-removed">-                 // accurately than the effects() method does.</span>
<span class="line-removed">-                 if (value-&gt;opcode() != Phi &amp;&amp; value-&gt;opcode() != Upsilon)</span>
<span class="line-removed">-                     effects = value-&gt;effects();</span>
<span class="line-removed">- </span>
<span class="line-removed">-                 if (effects.mustExecute())</span>
<span class="line-removed">-                     worklist.push(value);</span>
<span class="line-removed">- </span>
<span class="line-removed">-                 if (UpsilonValue* upsilon = value-&gt;as&lt;UpsilonValue&gt;())</span>
<span class="line-removed">-                     upsilons.append(upsilon);</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         for (;;) {</span>
<span class="line-removed">-             while (Value* value = worklist.pop()) {</span>
<span class="line-removed">-                 for (Value* child : value-&gt;children())</span>
<span class="line-removed">-                     worklist.push(child);</span>
<span class="line-removed">-             }</span>
<span class="line-removed">- </span>
<span class="line-removed">-             bool didPush = false;</span>
<span class="line-removed">-             for (size_t upsilonIndex = 0; upsilonIndex &lt; upsilons.size(); ++upsilonIndex) {</span>
<span class="line-removed">-                 UpsilonValue* upsilon = upsilons[upsilonIndex];</span>
<span class="line-removed">-                 if (worklist.saw(upsilon-&gt;phi())) {</span>
<span class="line-removed">-                     worklist.push(upsilon);</span>
<span class="line-removed">-                     upsilons[upsilonIndex--] = upsilons.last();</span>
<span class="line-removed">-                     upsilons.takeLast();</span>
<span class="line-removed">-                     didPush = true;</span>
<span class="line-removed">-                 }</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-             if (!didPush)</span>
<span class="line-removed">-                 break;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
<span class="line-removed">-         IndexSet&lt;Variable*&gt; liveVariables;</span>
<span class="line-removed">- </span>
<span class="line-removed">-         for (BasicBlock* block : m_proc) {</span>
<span class="line-removed">-             size_t sourceIndex = 0;</span>
<span class="line-removed">-             size_t targetIndex = 0;</span>
<span class="line-removed">-             while (sourceIndex &lt; block-&gt;size()) {</span>
<span class="line-removed">-                 Value* value = block-&gt;at(sourceIndex++);</span>
<span class="line-removed">-                 if (worklist.saw(value)) {</span>
<span class="line-removed">-                     if (VariableValue* variableValue = value-&gt;as&lt;VariableValue&gt;())</span>
<span class="line-removed">-                         liveVariables.add(variableValue-&gt;variable());</span>
<span class="line-removed">-                     block-&gt;at(targetIndex++) = value;</span>
<span class="line-removed">-                 } else {</span>
<span class="line-removed">-                     m_proc.deleteValue(value);</span>
<span class="line-removed">-                     m_changed = true;</span>
<span class="line-removed">-                 }</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-             block-&gt;values().resize(targetIndex);</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
<span class="line-removed">-         for (Variable* variable : m_proc.variables()) {</span>
<span class="line-removed">-             if (!liveVariables.contains(variable))</span>
<span class="line-removed">-                 m_proc.deleteVariable(variable);</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
      void simplifySSA()
      {
          // This runs Aycock and Horspool&#39;s algorithm on our Phi functions [1]. For most CFG patterns,
          // this can take a suboptimal arrangement of Phi functions and make it optimal, as if you had
          // run Cytron, Ferrante, Rosen, Wegman, and Zadeck. It&#39;s only suboptimal for irreducible
<span class="line-new-header">--- 2789,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2763,10 ***</span>
<span class="line-new-header">--- 2853,12 ---</span>
      }
  
      Procedure&amp; m_proc;
      InsertionSet m_insertionSet;
      BlockInsertionSet m_blockInsertionSet;
<span class="line-added">+     HashMap&lt;ValueKey, Value*&gt; m_valueForConstant;</span>
<span class="line-added">+     BasicBlock* m_root { nullptr };</span>
      BasicBlock* m_block { nullptr };
      unsigned m_index { 0 };
      Value* m_value { nullptr };
      Dominators* m_dominators { nullptr };
      PureCSE m_pureCSE;
</pre>
<center><a href="B3PureCSE.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="B3SlotBaseValue.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>