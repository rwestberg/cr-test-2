<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/page/animation/AnimationBase.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2007, 2008, 2009 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  *
  8  * 1.  Redistributions of source code must retain the above copyright
  9  *     notice, this list of conditions and the following disclaimer.
 10  * 2.  Redistributions in binary form must reproduce the above copyright
 11  *     notice, this list of conditions and the following disclaimer in the
 12  *     documentation and/or other materials provided with the distribution.
 13  * 3.  Neither the name of Apple Inc. (&quot;Apple&quot;) nor the names of
 14  *     its contributors may be used to endorse or promote products derived
 15  *     from this software without specific prior written permission.
 16  *
 17  * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS &quot;AS IS&quot; AND ANY
 18  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 19  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 20  * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
 21  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 22  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 23  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 24  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 25  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 26  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 27  */
 28 
 29 #include &quot;config.h&quot;
 30 #include &quot;AnimationBase.h&quot;
 31 
 32 #include &quot;CSSAnimationControllerPrivate.h&quot;
 33 #include &quot;CSSPrimitiveValue.h&quot;
 34 #include &quot;CSSPropertyAnimation.h&quot;
 35 #include &quot;CompositeAnimation.h&quot;
 36 #include &quot;Document.h&quot;
 37 #include &quot;FloatConversion.h&quot;
 38 #include &quot;GeometryUtilities.h&quot;
 39 #include &quot;Logging.h&quot;
 40 #include &quot;RenderBox.h&quot;
 41 #include &quot;RenderStyle.h&quot;
 42 #include &quot;RenderView.h&quot;
 43 #include &lt;algorithm&gt;
 44 #include &lt;wtf/Ref.h&gt;
 45 
 46 namespace WebCore {
 47 
 48 AnimationBase::AnimationBase(const Animation&amp; animation, Element&amp; element, CompositeAnimation&amp; compositeAnimation)
 49     : m_element(&amp;element)
 50     , m_compositeAnimation(&amp;compositeAnimation)
 51     , m_animation(const_cast&lt;Animation&amp;&gt;(animation))
 52 {
 53     // Compute the total duration
 54     if (m_animation-&gt;iterationCount() &gt; 0)
 55         m_totalDuration = m_animation-&gt;duration() * m_animation-&gt;iterationCount();
 56 }
 57 
 58 AnimationBase::~AnimationBase() = default;
 59 
 60 const RenderStyle&amp; AnimationBase::currentStyle() const
 61 {
 62     if (auto* renderer = this-&gt;renderer())
 63         return renderer-&gt;style();
 64     return unanimatedStyle();
 65 }
 66 
 67 RenderElement* AnimationBase::renderer() const
 68 {
 69     return m_element ? m_element-&gt;renderer() : nullptr;
 70 }
 71 
<a name="1" id="anc1"></a><span class="line-removed"> 72 RenderBoxModelObject* AnimationBase::compositedRenderer() const</span>
<span class="line-removed"> 73 {</span>
<span class="line-removed"> 74     auto* renderer = this-&gt;renderer();</span>
<span class="line-removed"> 75     if (!renderer || !renderer-&gt;isComposited())</span>
<span class="line-removed"> 76         return nullptr;</span>
<span class="line-removed"> 77     return downcast&lt;RenderBoxModelObject&gt;(renderer);</span>
<span class="line-removed"> 78 }</span>
<span class="line-removed"> 79 </span>
 80 void AnimationBase::clear()
 81 {
 82     endAnimation();
 83     m_element = nullptr;
 84     m_compositeAnimation = nullptr;
 85 }
 86 
 87 void AnimationBase::setNeedsStyleRecalc(Element* element)
 88 {
 89     if (!element || element-&gt;document().renderTreeBeingDestroyed())
 90         return;
 91 
 92     ASSERT(element-&gt;document().pageCacheState() == Document::NotInPageCache);
 93     element-&gt;invalidateStyle();
 94 }
 95 
 96 double AnimationBase::duration() const
 97 {
 98     return m_animation-&gt;duration();
 99 }
100 
101 bool AnimationBase::playStatePlaying() const
102 {
103     return m_animation-&gt;playState() == AnimationPlayState::Playing;
104 }
105 
106 bool AnimationBase::animationsMatch(const Animation&amp; animation) const
107 {
108     return m_animation-&gt;animationsMatch(animation);
109 }
110 
111 #if !LOG_DISABLED
112 static const char* nameForState(AnimationBase::AnimationState state)
113 {
114     switch (state) {
115     case AnimationBase::AnimationState::New: return &quot;New&quot;;
116     case AnimationBase::AnimationState::StartWaitTimer: return &quot;StartWaitTimer&quot;;
117     case AnimationBase::AnimationState::StartWaitStyleAvailable: return &quot;StartWaitStyleAvailable&quot;;
118     case AnimationBase::AnimationState::StartWaitResponse: return &quot;StartWaitResponse&quot;;
119     case AnimationBase::AnimationState::Looping: return &quot;Looping&quot;;
120     case AnimationBase::AnimationState::Ending: return &quot;Ending&quot;;
121     case AnimationBase::AnimationState::PausedNew: return &quot;PausedNew&quot;;
122     case AnimationBase::AnimationState::PausedWaitTimer: return &quot;PausedWaitTimer&quot;;
123     case AnimationBase::AnimationState::PausedWaitStyleAvailable: return &quot;PausedWaitStyleAvailable&quot;;
124     case AnimationBase::AnimationState::PausedWaitResponse: return &quot;PausedWaitResponse&quot;;
125     case AnimationBase::AnimationState::PausedRun: return &quot;PausedRun&quot;;
126     case AnimationBase::AnimationState::Done: return &quot;Done&quot;;
127     case AnimationBase::AnimationState::FillingForwards: return &quot;FillingForwards&quot;;
128     }
129     return &quot;&quot;;
130 }
131 
132 static const char* nameForStateInput(AnimationBase::AnimationStateInput input)
133 {
134     switch (input) {
135     case AnimationBase::AnimationStateInput::MakeNew: return &quot;MakeNew&quot;;
136     case AnimationBase::AnimationStateInput::StartAnimation: return &quot;StartAnimation&quot;;
137     case AnimationBase::AnimationStateInput::RestartAnimation: return &quot;RestartAnimation&quot;;
138     case AnimationBase::AnimationStateInput::StartTimerFired: return &quot;StartTimerFired&quot;;
139     case AnimationBase::AnimationStateInput::StyleAvailable: return &quot;StyleAvailable&quot;;
140     case AnimationBase::AnimationStateInput::StartTimeSet: return &quot;StartTimeSet&quot;;
141     case AnimationBase::AnimationStateInput::LoopTimerFired: return &quot;LoopTimerFired&quot;;
142     case AnimationBase::AnimationStateInput::EndTimerFired: return &quot;EndTimerFired&quot;;
143     case AnimationBase::AnimationStateInput::PauseOverride: return &quot;PauseOverride&quot;;
144     case AnimationBase::AnimationStateInput::ResumeOverride: return &quot;ResumeOverride&quot;;
145     case AnimationBase::AnimationStateInput::PlayStateRunning: return &quot;PlayStateRunning&quot;;
146     case AnimationBase::AnimationStateInput::PlayStatePaused: return &quot;PlayStatePaused&quot;;
147     case AnimationBase::AnimationStateInput::EndAnimation: return &quot;EndAnimation&quot;;
148     }
149     return &quot;&quot;;
150 }
151 #endif
152 
153 void AnimationBase::updateStateMachine(AnimationStateInput input, double param)
154 {
155     if (!m_compositeAnimation)
156         return;
157 
158     // If we get AnimationStateInput::RestartAnimation then we force a new animation, regardless of state.
159     if (input == AnimationStateInput::MakeNew) {
160         if (m_animationState == AnimationState::StartWaitStyleAvailable)
161             m_compositeAnimation-&gt;animationController().removeFromAnimationsWaitingForStyle(*this);
162         LOG(Animations, &quot;%p AnimationState %s -&gt; New&quot;, this, nameForState(m_animationState));
163         m_animationState = AnimationState::New;
164         m_startTime = WTF::nullopt;
165         m_pauseTime = WTF::nullopt;
166         m_requestedStartTime = 0;
167         m_nextIterationDuration = WTF::nullopt;
168         endAnimation();
169         return;
170     }
171 
172     if (input == AnimationStateInput::RestartAnimation) {
173         if (m_animationState == AnimationState::StartWaitStyleAvailable)
174             m_compositeAnimation-&gt;animationController().removeFromAnimationsWaitingForStyle(*this);
175         LOG(Animations, &quot;%p AnimationState %s -&gt; New&quot;, this, nameForState(m_animationState));
176         m_animationState = AnimationState::New;
177         m_startTime = WTF::nullopt;
178         m_pauseTime = WTF::nullopt;
179         m_requestedStartTime = 0;
180         m_nextIterationDuration = WTF::nullopt;
181         endAnimation();
182 
183         if (!paused())
184             updateStateMachine(AnimationStateInput::StartAnimation, -1);
185         return;
186     }
187 
188     if (input == AnimationStateInput::EndAnimation) {
189         if (m_animationState == AnimationState::StartWaitStyleAvailable)
190             m_compositeAnimation-&gt;animationController().removeFromAnimationsWaitingForStyle(*this);
191         LOG(Animations, &quot;%p AnimationState %s -&gt; Done&quot;, this, nameForState(m_animationState));
192         m_animationState = AnimationState::Done;
193         endAnimation();
194         return;
195     }
196 
197     if (input == AnimationStateInput::PauseOverride) {
198         if (m_animationState == AnimationState::StartWaitResponse) {
199             // If we are in AnimationState::StartWaitResponse, the animation will get canceled before
200             // we get a response, so move to the next state.
201             endAnimation();
202             updateStateMachine(AnimationStateInput::StartTimeSet, beginAnimationUpdateTime());
203         }
204         return;
205     }
206 
207     if (input == AnimationStateInput::ResumeOverride) {
208         if (m_animationState == AnimationState::Looping || m_animationState == AnimationState::Ending) {
209             // Start the animation
210             startAnimation(beginAnimationUpdateTime() - m_startTime.valueOr(0));
211         }
212         return;
213     }
214 
215     // Execute state machine
216     switch (m_animationState) {
217         case AnimationState::New:
218             ASSERT(input == AnimationStateInput::StartAnimation || input == AnimationStateInput::PlayStateRunning || input == AnimationStateInput::PlayStatePaused);
219 
220             if (input == AnimationStateInput::StartAnimation || input == AnimationStateInput::PlayStateRunning) {
221                 m_requestedStartTime = beginAnimationUpdateTime();
222                 LOG(Animations, &quot;%p AnimationState %s -&gt; StartWaitTimer&quot;, this, nameForState(m_animationState));
223                 m_animationState = AnimationState::StartWaitTimer;
224             } else {
225                 // We are pausing before we even started.
226                 LOG(Animations, &quot;%p AnimationState %s -&gt; AnimationState::PausedNew&quot;, this, nameForState(m_animationState));
227                 m_animationState = AnimationState::PausedNew;
228                 m_pauseTime = WTF::nullopt;
229             }
230 
231             break;
232         case AnimationState::StartWaitTimer:
233             ASSERT(input == AnimationStateInput::StartTimerFired || input == AnimationStateInput::PlayStatePaused);
234 
235             if (input == AnimationStateInput::StartTimerFired) {
236                 ASSERT(param &gt;= 0);
237                 // Start timer has fired, tell the animation to start and wait for it to respond with start time
238                 LOG(Animations, &quot;%p AnimationState %s -&gt; StartWaitStyleAvailable (time is %f)&quot;, this, nameForState(m_animationState), param);
239                 m_animationState = AnimationState::StartWaitStyleAvailable;
240                 m_compositeAnimation-&gt;animationController().addToAnimationsWaitingForStyle(*this);
241 
242                 // Trigger a render so we can start the animation
243                 if (m_element)
244                     m_compositeAnimation-&gt;animationController().addElementChangeToDispatch(*m_element);
245             } else {
246                 ASSERT(!paused());
247                 // We&#39;re waiting for the start timer to fire and we got a pause. Cancel the timer, pause and wait
248                 m_pauseTime = beginAnimationUpdateTime();
249                 LOG(Animations, &quot;%p AnimationState %s -&gt; PausedWaitTimer&quot;, this, nameForState(m_animationState));
250                 m_animationState = AnimationState::PausedWaitTimer;
251             }
252             break;
253         case AnimationState::StartWaitStyleAvailable:
254             ASSERT(input == AnimationStateInput::StyleAvailable || input == AnimationStateInput::PlayStatePaused);
255 
256             if (input == AnimationStateInput::StyleAvailable) {
257                 // Start timer has fired, tell the animation to start and wait for it to respond with start time
258                 LOG(Animations, &quot;%p AnimationState %s -&gt; StartWaitResponse (time is %f)&quot;, this, nameForState(m_animationState), param);
259                 m_animationState = AnimationState::StartWaitResponse;
260 
261                 overrideAnimations();
262 
263                 // Start the animation
264                 if (overridden()) {
265                     // We won&#39;t try to start accelerated animations if we are overridden and
266                     // just move on to the next state.
267                     LOG(Animations, &quot;%p AnimationState %s -&gt; StartWaitResponse&quot;, this, nameForState(m_animationState));
268                     m_animationState = AnimationState::StartWaitResponse;
269                     m_isAccelerated = false;
270                     updateStateMachine(AnimationStateInput::StartTimeSet, beginAnimationUpdateTime());
271                 } else {
272                     double timeOffset = 0;
273                     // If the value for &#39;animation-delay&#39; is negative then the animation appears to have started in the past.
274                     if (m_animation-&gt;delay() &lt; 0)
275                         timeOffset = -m_animation-&gt;delay();
276                     bool started = startAnimation(timeOffset);
277 
278                     m_compositeAnimation-&gt;animationController().addToAnimationsWaitingForStartTimeResponse(*this, started);
279                     m_isAccelerated = started;
280                 }
281             } else {
282                 // We&#39;re waiting for the style to be available and we got a pause. Pause and wait
283                 m_pauseTime = beginAnimationUpdateTime();
284                 LOG(Animations, &quot;%p AnimationState %s -&gt; PausedWaitStyleAvailable&quot;, this, nameForState(m_animationState));
285                 m_animationState = AnimationState::PausedWaitStyleAvailable;
286             }
287             break;
288         case AnimationState::StartWaitResponse:
289             ASSERT(input == AnimationStateInput::StartTimeSet || input == AnimationStateInput::PlayStatePaused);
290 
291             if (input == AnimationStateInput::StartTimeSet) {
292                 ASSERT(param &gt; -0.001); // Sometimes Core Animation gives us a beginTime slightly into the future.
293                 LOG(Animations, &quot;%p AnimationState %s -&gt; StartTimeSet (time is %f)&quot;, this, nameForState(m_animationState), param);
294 
295                 // We have a start time, set it, unless the startTime is already set
296                 if (!m_startTime) {
297                     m_startTime = param;
298                     // If the value for &#39;animation-delay&#39; is negative then the animation appears to have started in the past.
299                     if (m_animation-&gt;delay() &lt; 0)
300                         m_startTime = m_startTime.value() + m_animation-&gt;delay();
301                 }
302 
303                 // Now that we know the start time, fire the start event.
304                 onAnimationStart(0); // The elapsedTime is 0.
305 
306                 // Decide whether to go into looping or ending state
307                 goIntoEndingOrLoopingState();
308 
309                 // Dispatch updateStyleIfNeeded so we can start the animation
310                 if (m_element)
311                     m_compositeAnimation-&gt;animationController().addElementChangeToDispatch(*m_element);
312             } else {
313                 // We are pausing while waiting for a start response. Cancel the animation and wait. When
314                 // we unpause, we will act as though the start timer just fired
315                 m_pauseTime = beginAnimationUpdateTime();
316                 pauseAnimation(beginAnimationUpdateTime() - m_startTime.valueOr(0));
317                 LOG(Animations, &quot;%p AnimationState %s -&gt; PausedWaitResponse&quot;, this, nameForState(m_animationState));
318                 m_animationState = AnimationState::PausedWaitResponse;
319             }
320             break;
321         case AnimationState::Looping:
322             ASSERT(input == AnimationStateInput::LoopTimerFired || input == AnimationStateInput::PlayStatePaused);
323 
324             if (input == AnimationStateInput::LoopTimerFired) {
325                 ASSERT(param &gt;= 0);
326                 LOG(Animations, &quot;%p AnimationState %s -&gt; LoopTimerFired (time is %f)&quot;, this, nameForState(m_animationState), param);
327 
328                 // Loop timer fired, loop again or end.
329                 onAnimationIteration(param);
330 
331                 // Decide whether to go into looping or ending state
332                 goIntoEndingOrLoopingState();
333             } else {
334                 // We are pausing while running. Cancel the animation and wait
335                 m_pauseTime = beginAnimationUpdateTime();
336                 pauseAnimation(beginAnimationUpdateTime() - m_startTime.valueOr(0));
337                 LOG(Animations, &quot;%p AnimationState %s -&gt; PausedRun&quot;, this, nameForState(m_animationState));
338                 m_animationState = AnimationState::PausedRun;
339             }
340             break;
341         case AnimationState::Ending:
342 #if !LOG_DISABLED
343             if (input != AnimationStateInput::EndTimerFired &amp;&amp; input != AnimationStateInput::PlayStatePaused)
344                 LOG_ERROR(&quot;State is AnimationState::Ending, but input is not AnimationStateInput::EndTimerFired or AnimationStateInput::PlayStatePaused. It is %s.&quot;, nameForStateInput(input));
345 #endif
346             if (input == AnimationStateInput::EndTimerFired) {
347                 ASSERT(param &gt;= 0);
348                 // End timer fired, finish up
349                 onAnimationEnd(param);
350 
351                 LOG(Animations, &quot;%p AnimationState %s -&gt; Done (time is %f)&quot;, this, nameForState(m_animationState), param);
352                 m_animationState = AnimationState::Done;
353 
354                 if (m_element) {
355                     if (m_animation-&gt;fillsForwards()) {
356                         LOG(Animations, &quot;%p AnimationState %s -&gt; FillingForwards&quot;, this, nameForState(m_animationState));
357                         m_animationState = AnimationState::FillingForwards;
358                     } else
359                         resumeOverriddenAnimations();
360 
361                     // Fire off another style change so we can set the final value
362                     if (m_element)
363                         m_compositeAnimation-&gt;animationController().addElementChangeToDispatch(*m_element);
364                 }
365             } else {
366                 // We are pausing while running. Cancel the animation and wait
367                 m_pauseTime = beginAnimationUpdateTime();
368                 pauseAnimation(beginAnimationUpdateTime() - m_startTime.valueOr(0));
369                 LOG(Animations, &quot;%p AnimationState %s -&gt; PausedRun&quot;, this, nameForState(m_animationState));
370                 m_animationState = AnimationState::PausedRun;
371             }
372             // |this| may be deleted here
373             break;
374         case AnimationState::PausedWaitTimer:
375             ASSERT(input == AnimationStateInput::PlayStateRunning);
376             ASSERT(paused());
377             // Update the times
378             m_startTime = m_startTime.valueOr(0) + beginAnimationUpdateTime() - m_pauseTime.valueOr(0);
379             m_pauseTime = WTF::nullopt;
380 
381             // we were waiting for the start timer to fire, go back and wait again
382             LOG(Animations, &quot;%p AnimationState %s -&gt; New&quot;, this, nameForState(m_animationState));
383             m_animationState = AnimationState::New;
384             updateStateMachine(AnimationStateInput::StartAnimation, 0);
385             break;
386         case AnimationState::PausedNew:
387         case AnimationState::PausedWaitResponse:
388         case AnimationState::PausedWaitStyleAvailable:
389         case AnimationState::PausedRun:
390             // We treat these two cases the same. The only difference is that, when we are in
391             // AnimationState::PausedWaitResponse, we don&#39;t yet have a valid startTime, so we send 0 to startAnimation.
392             // When the AnimationStateInput::StartTimeSet comes in and we were in AnimationState::PausedRun, we will notice
393             // that we have already set the startTime and will ignore it.
394             ASSERT(input == AnimationStateInput::PlayStatePaused || input == AnimationStateInput::PlayStateRunning || input == AnimationStateInput::StartTimeSet || input == AnimationStateInput::StyleAvailable);
395             ASSERT(paused());
396 
397             if (input == AnimationStateInput::PlayStateRunning) {
398                 if (m_animationState == AnimationState::PausedNew) {
399                     // We were paused before we even started, and now we&#39;re supposed
400                     // to start, so jump back to the New state and reset.
401                     LOG(Animations, &quot;%p AnimationState %s -&gt; AnimationState::New&quot;, this, nameForState(m_animationState));
402                     m_animationState = AnimationState::New;
403                     m_pauseTime = WTF::nullopt;
404                     updateStateMachine(input, param);
405                     break;
406                 }
407 
408                 // Update the times
409                 if (m_animationState == AnimationState::PausedRun)
410                     m_startTime = m_startTime.valueOr(0) + beginAnimationUpdateTime() - m_pauseTime.valueOr(0);
411                 else
412                     m_startTime = 0;
413 
414                 m_pauseTime = WTF::nullopt;
415 
416                 if (m_animationState == AnimationState::PausedWaitStyleAvailable) {
417                     LOG(Animations, &quot;%p AnimationState %s -&gt; StartWaitStyleAvailable&quot;, this, nameForState(m_animationState));
418                     m_animationState = AnimationState::StartWaitStyleAvailable;
419                 } else {
420                     // We were either running or waiting for a begin time response from the animation.
421                     // Either way we need to restart the animation (possibly with an offset if we
422                     // had already been running) and wait for it to start.
423                     LOG(Animations, &quot;%p AnimationState %s -&gt; StartWaitResponse&quot;, this, nameForState(m_animationState));
424                     m_animationState = AnimationState::StartWaitResponse;
425 
426                     // Start the animation
427                     if (overridden()) {
428                         // We won&#39;t try to start accelerated animations if we are overridden and
429                         // just move on to the next state.
430                         updateStateMachine(AnimationStateInput::StartTimeSet, beginAnimationUpdateTime());
431                         m_isAccelerated = true;
432                     } else {
433                         bool started = startAnimation(beginAnimationUpdateTime() - m_startTime.valueOr(0));
434                         m_compositeAnimation-&gt;animationController().addToAnimationsWaitingForStartTimeResponse(*this, started);
435                         m_isAccelerated = started;
436                     }
437                 }
438                 break;
439             }
440 
441             if (input == AnimationStateInput::StartTimeSet) {
442                 ASSERT(m_animationState == AnimationState::PausedWaitResponse);
443 
444                 // We are paused but we got the callback that notifies us that an accelerated animation started.
445                 // We ignore the start time and just move into the paused-run state.
446                 LOG(Animations, &quot;%p AnimationState %s -&gt; PausedRun (time is %f)&quot;, this, nameForState(m_animationState), param);
447                 m_animationState = AnimationState::PausedRun;
448                 ASSERT(!m_startTime);
449                 m_startTime = param;
450                 m_pauseTime = m_pauseTime.valueOr(0) + param;
451                 break;
452             }
453 
454             ASSERT(m_animationState == AnimationState::PausedNew || m_animationState == AnimationState::PausedWaitStyleAvailable);
455 
456             if (input == AnimationStateInput::PlayStatePaused)
457                 break;
458 
459             ASSERT(input == AnimationStateInput::StyleAvailable);
460 
461             // We are paused but we got the callback that notifies us that style has been updated.
462             // We move to the AnimationState::PausedWaitResponse state
463             LOG(Animations, &quot;%p AnimationState %s -&gt; PausedWaitResponse&quot;, this, nameForState(m_animationState));
464             m_animationState = AnimationState::PausedWaitResponse;
465             overrideAnimations();
466             break;
467         case AnimationState::FillingForwards:
468         case AnimationState::Done:
469             // We&#39;re done. Stay in this state until we are deleted
470             break;
471     }
472 }
473 
474 void AnimationBase::fireAnimationEventsIfNeeded()
475 {
476     if (!m_compositeAnimation)
477         return;
478 
479     // If we are waiting for the delay time to expire and it has, go to the next state
480     if (m_animationState != AnimationState::StartWaitTimer &amp;&amp; m_animationState != AnimationState::Looping &amp;&amp; m_animationState != AnimationState::Ending)
481         return;
482 
483     // We have to make sure to keep a ref to the this pointer, because it could get destroyed
484     // during an animation callback that might get called. Since the owner is a CompositeAnimation
485     // and it ref counts this object, we will keep a ref to that instead. That way the AnimationBase
486     // can still access the resources of its CompositeAnimation as needed.
487     Ref&lt;AnimationBase&gt; protectedThis(*this);
488     Ref&lt;CompositeAnimation&gt; protectCompositeAnimation(*m_compositeAnimation);
489 
490     // Check for start timeout
491     if (m_animationState == AnimationState::StartWaitTimer) {
492         if (beginAnimationUpdateTime() - m_requestedStartTime &gt;= m_animation-&gt;delay())
493             updateStateMachine(AnimationStateInput::StartTimerFired, 0);
494         return;
495     }
496 
497     double elapsedDuration = beginAnimationUpdateTime() - m_startTime.valueOr(0);
498 
499     // FIXME: we need to ensure that elapsedDuration is never &lt; 0. If it is, this suggests that
500     // we had a recalcStyle() outside of beginAnimationUpdate()/endAnimationUpdate().
501     // Also check in getTimeToNextEvent().
502     elapsedDuration = std::max(elapsedDuration, 0.0);
503 
504     // Check for end timeout
505     if (m_totalDuration &amp;&amp; elapsedDuration &gt;= m_totalDuration.value()) {
506         // We may still be in AnimationState::Looping if we&#39;ve managed to skip a
507         // whole iteration, in which case we should jump to the end state.
508         LOG(Animations, &quot;%p AnimationState %s -&gt; Ending&quot;, this, nameForState(m_animationState));
509         m_animationState = AnimationState::Ending;
510 
511         // Fire an end event
512         updateStateMachine(AnimationStateInput::EndTimerFired, m_totalDuration.value());
513     } else {
514         // Check for iteration timeout
515         if (!m_nextIterationDuration) {
516             // Hasn&#39;t been set yet, set it
517             double durationLeft = m_animation-&gt;duration() - fmod(elapsedDuration, m_animation-&gt;duration());
518             m_nextIterationDuration = elapsedDuration + durationLeft;
519         }
520 
521         if (elapsedDuration &gt;= m_nextIterationDuration) {
522             // Set to the next iteration
523             double previous = m_nextIterationDuration.value();
524             double durationLeft = m_animation-&gt;duration() - fmod(elapsedDuration, m_animation-&gt;duration());
525             m_nextIterationDuration = elapsedDuration + durationLeft;
526 
527             // Send the event
528             updateStateMachine(AnimationStateInput::LoopTimerFired, previous);
529         }
530     }
531 }
532 
533 void AnimationBase::updatePlayState(AnimationPlayState playState)
534 {
535     if (!m_compositeAnimation)
536         return;
537 
538     // When we get here, we can have one of 4 desired states: running, paused, suspended, paused &amp; suspended.
539     // The state machine can be in one of two states: running, paused.
540     // Set the state machine to the desired state.
541     bool pause = playState == AnimationPlayState::Paused || m_compositeAnimation-&gt;isSuspended();
542 
543     if (pause == paused() &amp;&amp; !isNew())
544         return;
545 
546     updateStateMachine(pause ?  AnimationStateInput::PlayStatePaused : AnimationStateInput::PlayStateRunning, -1);
547 }
548 
549 Optional&lt;Seconds&gt; AnimationBase::timeToNextService()
550 {
551     // Returns the time at which next service is required. WTF::nullopt means no service is required. 0 means
552     // service is required now, and &gt; 0 means service is required that many seconds in the future.
553     if (paused() || isNew() || postActive() || fillingForwards())
554         return WTF::nullopt;
555 
556     if (m_animationState == AnimationState::StartWaitTimer) {
557         double timeFromNow = m_animation-&gt;delay() - (beginAnimationUpdateTime() - m_requestedStartTime);
558         return std::max(Seconds { timeFromNow }, 0_s);
559     }
560 
561     fireAnimationEventsIfNeeded();
562 
563     // In all other cases, we need service right away.
564     return 0_s;
565 }
566 
567 // Compute the fractional time, taking into account direction.
568 // There is no need to worry about iterations, we assume that we would have
569 // short circuited above if we were done.
570 
571 double AnimationBase::fractionalTime(double scale, double elapsedTime, double offset) const
572 {
573     double fractionalTime = m_animation-&gt;duration() ? (elapsedTime / m_animation-&gt;duration()) : 1;
574     // FIXME: startTime can be before the current animation &quot;frame&quot; time. This is to sync with the frame time
575     // concept in AnimationTimeController. So we need to somehow sync the two. Until then, the possible
576     // error is small and will probably not be noticeable. Until we fix this, remove the assert.
577     // https://bugs.webkit.org/show_bug.cgi?id=52037
578     // ASSERT(fractionalTime &gt;= 0);
579     if (fractionalTime &lt; 0)
580         fractionalTime = 0;
581 
582     int integralTime = static_cast&lt;int&gt;(fractionalTime);
583     const int integralIterationCount = static_cast&lt;int&gt;(m_animation-&gt;iterationCount());
584     const bool iterationCountHasFractional = m_animation-&gt;iterationCount() - integralIterationCount;
585     if (m_animation-&gt;iterationCount() != Animation::IterationCountInfinite &amp;&amp; !iterationCountHasFractional)
586         integralTime = std::min(integralTime, integralIterationCount - 1);
587 
588     fractionalTime -= integralTime;
589 
590     if (((m_animation-&gt;direction() == Animation::AnimationDirectionAlternate) &amp;&amp; (integralTime &amp; 1))
591         || ((m_animation-&gt;direction() == Animation::AnimationDirectionAlternateReverse) &amp;&amp; !(integralTime &amp; 1))
592         || m_animation-&gt;direction() == Animation::AnimationDirectionReverse)
593         fractionalTime = 1 - fractionalTime;
594 
595     if (scale != 1 || offset)
596         fractionalTime = (fractionalTime - offset) * scale;
597 
598     return fractionalTime;
599 }
600 
601 double AnimationBase::progress(double scale, double offset, const TimingFunction* timingFunction) const
602 {
603     if (preActive())
604         return 0;
605 
606     if (postActive())
607         return 1;
608 
609     double elapsedTime = getElapsedTime();
610 
611     double duration = m_animation-&gt;duration();
612     if (m_animation-&gt;iterationCount() &gt; 0)
613         duration *= m_animation-&gt;iterationCount();
614 
615     if (fillingForwards())
616         elapsedTime = duration;
617 
618     double fractionalTime = this-&gt;fractionalTime(scale, elapsedTime, offset);
619 
620     if (m_animation-&gt;iterationCount() &gt; 0 &amp;&amp; elapsedTime &gt;= duration) {
621         if (WTF::isIntegral(fractionalTime))
622             return fractionalTime;
623     }
624 
625     if (!timingFunction)
626         timingFunction = m_animation-&gt;timingFunction();
627 
628     return timingFunction-&gt;transformTime(fractionalTime, m_animation-&gt;duration());
629 }
630 
631 void AnimationBase::getTimeToNextEvent(Seconds&amp; time, bool&amp; isLooping) const
632 {
633     // Decide when the end or loop event needs to fire
634     const double elapsedDuration = std::max(beginAnimationUpdateTime() - m_startTime.valueOr(0), 0.0);
635     double durationLeft = 0;
636     double nextIterationTime = m_totalDuration.valueOr(0);
637 
638     if (!m_totalDuration || elapsedDuration &lt; m_totalDuration.value()) {
639         durationLeft = m_animation-&gt;duration() &gt; 0 ? (m_animation-&gt;duration() - fmod(elapsedDuration, m_animation-&gt;duration())) : 0;
640         nextIterationTime = elapsedDuration + durationLeft;
641     }
642 
643     if (!m_totalDuration || nextIterationTime &lt; m_totalDuration.value()) {
644         // We are not at the end yet
645         ASSERT(nextIterationTime &gt; 0);
646         isLooping = true;
647     } else {
648         // We are at the end
649         isLooping = false;
650     }
651 
652     time = Seconds { durationLeft };
653 }
654 
655 void AnimationBase::goIntoEndingOrLoopingState()
656 {
657     Seconds t;
658     bool isLooping;
659     getTimeToNextEvent(t, isLooping);
660     LOG(Animations, &quot;%p AnimationState %s -&gt; %s&quot;, this, nameForState(m_animationState), isLooping ? &quot;Looping&quot; : &quot;Ending&quot;);
661     m_animationState = isLooping ? AnimationState::Looping : AnimationState::Ending;
662 }
663 
664 void AnimationBase::freezeAtTime(double t)
665 {
666     if (!m_compositeAnimation)
667         return;
668 
669     if (!m_startTime) {
670         // If we haven&#39;t started yet, make it as if we started.
671         LOG(Animations, &quot;%p AnimationState %s -&gt; StartWaitResponse&quot;, this, nameForState(m_animationState));
672         m_animationState = AnimationState::StartWaitResponse;
673         onAnimationStartResponse(MonotonicTime::now());
674     }
675 
676     ASSERT(m_startTime); // If m_startTime is zero, we haven&#39;t started yet, so we&#39;ll get a bad pause time.
677     if (t &lt;= m_animation-&gt;delay())
678         m_pauseTime = m_startTime.valueOr(0);
679     else
680         m_pauseTime = m_startTime.valueOr(0) + t - m_animation-&gt;delay();
681 
<a name="2" id="anc2"></a><span class="line-modified">682     if (auto* renderer = compositedRenderer())</span>
683         renderer-&gt;suspendAnimations(MonotonicTime::fromRawSeconds(m_pauseTime.value()));
684 }
685 
686 double AnimationBase::beginAnimationUpdateTime() const
687 {
688     if (!m_compositeAnimation)
689         return 0;
690 
691     return m_compositeAnimation-&gt;animationController().beginAnimationUpdateTime().secondsSinceEpoch().seconds();
692 }
693 
694 double AnimationBase::getElapsedTime() const
695 {
696     if (paused()) {
697         double delayOffset = (!m_startTime &amp;&amp; m_animation-&gt;delay() &lt; 0) ? m_animation-&gt;delay() : 0;
698         return m_pauseTime.valueOr(0) - m_startTime.valueOr(0) - delayOffset;
699     }
700 
701     if (!m_startTime)
702         return 0;
703 
704     if (postActive() || fillingForwards())
705         return m_totalDuration.valueOr(0);
706 
707     return beginAnimationUpdateTime() - m_startTime.valueOr(0);
708 }
709 
710 void AnimationBase::setElapsedTime(double time)
711 {
712     // FIXME: implement this method
713     UNUSED_PARAM(time);
714 }
715 
716 void AnimationBase::play()
717 {
718     // FIXME: implement this method
719 }
720 
721 void AnimationBase::pause()
722 {
723     // FIXME: implement this method
724 }
725 
726 static bool containsRotation(const Vector&lt;RefPtr&lt;TransformOperation&gt;&gt;&amp; operations)
727 {
728     for (const auto&amp; operation : operations) {
729         if (operation-&gt;type() == TransformOperation::ROTATE)
730             return true;
731     }
732     return false;
733 }
734 
735 bool AnimationBase::computeTransformedExtentViaTransformList(const FloatRect&amp; rendererBox, const RenderStyle&amp; style, LayoutRect&amp; bounds) const
736 {
737     FloatRect floatBounds = bounds;
738     FloatPoint transformOrigin;
739 
740     bool applyTransformOrigin = containsRotation(style.transform().operations()) || style.transform().affectedByTransformOrigin();
741     if (applyTransformOrigin) {
742         transformOrigin.setX(rendererBox.x() + floatValueForLength(style.transformOriginX(), rendererBox.width()));
743         transformOrigin.setY(rendererBox.y() + floatValueForLength(style.transformOriginY(), rendererBox.height()));
744         // Ignore transformOriginZ because we&#39;ll bail if we encounter any 3D transforms.
745 
746         floatBounds.moveBy(-transformOrigin);
747     }
748 
749     for (const auto&amp; operation : style.transform().operations()) {
750         if (operation-&gt;type() == TransformOperation::ROTATE) {
751             // For now, just treat this as a full rotation. This could take angle into account to reduce inflation.
752             floatBounds = boundsOfRotatingRect(floatBounds);
753         } else {
754             TransformationMatrix transform;
755             operation-&gt;apply(transform, rendererBox.size());
756             if (!transform.isAffine())
757                 return false;
758 
759             if (operation-&gt;type() == TransformOperation::MATRIX || operation-&gt;type() == TransformOperation::MATRIX_3D) {
760                 TransformationMatrix::Decomposed2Type toDecomp;
761                 transform.decompose2(toDecomp);
762                 // Any rotation prevents us from using a simple start/end rect union.
763                 if (toDecomp.angle)
764                     return false;
765             }
766 
767             floatBounds = transform.mapRect(floatBounds);
768         }
769     }
770 
771     if (applyTransformOrigin)
772         floatBounds.moveBy(transformOrigin);
773 
774     bounds = LayoutRect(floatBounds);
775     return true;
776 }
777 
778 bool AnimationBase::computeTransformedExtentViaMatrix(const FloatRect&amp; rendererBox, const RenderStyle&amp; style, LayoutRect&amp; bounds) const
779 {
780     TransformationMatrix transform;
781     style.applyTransform(transform, rendererBox, RenderStyle::IncludeTransformOrigin);
782     if (!transform.isAffine())
783         return false;
784 
785     TransformationMatrix::Decomposed2Type fromDecomp;
786     transform.decompose2(fromDecomp);
787     // Any rotation prevents us from using a simple start/end rect union.
788     if (fromDecomp.angle)
789         return false;
790 
791     bounds = LayoutRect(transform.mapRect(bounds));
792     return true;
793 
794 }
795 
796 } // namespace WebCore
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>