<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/inspector/InspectorCanvas.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2017 Apple Inc.  All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;InspectorCanvas.h&quot;
 28 
 29 #include &quot;AffineTransform.h&quot;
 30 #include &quot;CachedImage.h&quot;
 31 #include &quot;CanvasGradient.h&quot;
 32 #include &quot;CanvasPattern.h&quot;
 33 #include &quot;CanvasRenderingContext.h&quot;
 34 #include &quot;CanvasRenderingContext2D.h&quot;
 35 #include &quot;Document.h&quot;
 36 #include &quot;FloatPoint.h&quot;
 37 #include &quot;Gradient.h&quot;
 38 #include &quot;HTMLCanvasElement.h&quot;
 39 #include &quot;HTMLImageElement.h&quot;
 40 #include &quot;HTMLVideoElement.h&quot;
 41 #include &quot;Image.h&quot;
 42 #include &quot;ImageBitmap.h&quot;
 43 #include &quot;ImageBitmapRenderingContext.h&quot;
 44 #include &quot;ImageBuffer.h&quot;
 45 #include &quot;ImageData.h&quot;
 46 #include &quot;InspectorDOMAgent.h&quot;
 47 #include &quot;JSCanvasDirection.h&quot;
 48 #include &quot;JSCanvasFillRule.h&quot;
 49 #include &quot;JSCanvasLineCap.h&quot;
 50 #include &quot;JSCanvasLineJoin.h&quot;
 51 #include &quot;JSCanvasTextAlign.h&quot;
 52 #include &quot;JSCanvasTextBaseline.h&quot;
 53 #include &quot;JSExecState.h&quot;
 54 #include &quot;JSImageSmoothingQuality.h&quot;
 55 #include &quot;Path2D.h&quot;
 56 #include &quot;Pattern.h&quot;
 57 #include &quot;RecordingSwizzleTypes.h&quot;
 58 #include &quot;SVGPathUtilities.h&quot;
 59 #include &quot;StringAdaptors.h&quot;
 60 #if ENABLE(CSS_TYPED_OM)
 61 #include &quot;TypedOMCSSImageValue.h&quot;
 62 #endif
 63 #if ENABLE(WEBGL)
 64 #include &quot;WebGLRenderingContext.h&quot;
 65 #endif
 66 #if ENABLE(WEBGL2)
 67 #include &quot;WebGL2RenderingContext.h&quot;
 68 #endif
 69 #if ENABLE(WEBGPU)
 70 #include &quot;GPUCanvasContext.h&quot;
 71 #endif
 72 #include &lt;JavaScriptCore/IdentifiersFactory.h&gt;
 73 #include &lt;JavaScriptCore/ScriptCallStackFactory.h&gt;
 74 #include &lt;wtf/Function.h&gt;
 75 
 76 namespace WebCore {
 77 
 78 using namespace Inspector;
 79 
 80 Ref&lt;InspectorCanvas&gt; InspectorCanvas::create(CanvasRenderingContext&amp; context)
 81 {
 82     return adoptRef(*new InspectorCanvas(context));
 83 }
 84 
 85 InspectorCanvas::InspectorCanvas(CanvasRenderingContext&amp; context)
 86     : m_identifier(&quot;canvas:&quot; + IdentifiersFactory::createIdentifier())
 87     , m_context(context)
 88 {
 89 }
 90 
 91 HTMLCanvasElement* InspectorCanvas::canvasElement()
 92 {
 93     if (is&lt;HTMLCanvasElement&gt;(m_context.canvasBase()))
 94         return &amp;downcast&lt;HTMLCanvasElement&gt;(m_context.canvasBase());
 95     return nullptr;
 96 }
 97 
 98 void InspectorCanvas::canvasChanged()
 99 {
100     if (!m_context.callTracingActive())
101         return;
102 
103     // Since 2D contexts are able to be fully reproduced in the frontend, we don&#39;t need snapshots.
104     if (is&lt;CanvasRenderingContext2D&gt;(m_context))
105         return;
106 
107     m_contentChanged = true;
108 }
109 
110 void InspectorCanvas::resetRecordingData()
111 {
112     m_initialState = nullptr;
113     m_frames = nullptr;
114     m_currentActions = nullptr;
115     m_serializedDuplicateData = nullptr;
116     m_indexedDuplicateData.clear();
117     m_recordingName = { };
118     m_bufferLimit = 100 * 1024 * 1024;
119     m_bufferUsed = 0;
120     m_frameCount = WTF::nullopt;
121     m_framesCaptured = 0;
122     m_contentChanged = false;
123 
124     m_context.setCallTracingActive(false);
125 }
126 
127 bool InspectorCanvas::hasRecordingData() const
128 {
129     return m_bufferUsed &gt; 0;
130 }
131 
132 bool InspectorCanvas::currentFrameHasData() const
133 {
134     return !!m_frames;
135 }
136 
137 static bool shouldSnapshotBitmapRendererAction(const String&amp; name)
138 {
139     return name == &quot;transferFromImageBitmap&quot;;
140 }
141 
142 #if ENABLE(WEBGL)
143 static bool shouldSnapshotWebGLAction(const String&amp; name)
144 {
145     return name == &quot;clear&quot;
146         || name == &quot;drawArrays&quot;
147         || name == &quot;drawElements&quot;;
148 }
149 #endif
150 
151 #if ENABLE(WEBGL2)
152 static bool shouldSnapshotWebGL2Action(const String&amp; name)
153 {
154     return name == &quot;clear&quot;
155         || name == &quot;drawArrays&quot;
156         || name == &quot;drawArraysInstanced&quot;
157         || name == &quot;drawElements&quot;
158         || name == &quot;drawElementsInstanced&quot;;
159 }
160 #endif
161 
162 void InspectorCanvas::recordAction(const String&amp; name, std::initializer_list&lt;RecordCanvasActionVariant&gt;&amp;&amp; parameters)
163 {
164     if (!m_initialState) {
165         // We should only construct the initial state for the first action of the recording.
166         ASSERT(!m_frames &amp;&amp; !m_currentActions);
167 
168         m_initialState = buildInitialState();
169         m_bufferUsed += m_initialState-&gt;memoryCost();
170     }
171 
172     if (!m_frames)
173         m_frames = JSON::ArrayOf&lt;Inspector::Protocol::Recording::Frame&gt;::create();
174 
175     if (!m_currentActions) {
176         m_currentActions = JSON::ArrayOf&lt;JSON::Value&gt;::create();
177 
178         auto frame = Inspector::Protocol::Recording::Frame::create()
179             .setActions(m_currentActions)
180             .release();
181 
182         m_frames-&gt;addItem(WTFMove(frame));
183         ++m_framesCaptured;
184 
185         m_currentFrameStartTime = MonotonicTime::now();
186     }
187 
188     appendActionSnapshotIfNeeded();
189 
190     m_lastRecordedAction = buildAction(name, WTFMove(parameters));
191     m_bufferUsed += m_lastRecordedAction-&gt;memoryCost();
192     m_currentActions-&gt;addItem(m_lastRecordedAction.get());
193 
194     if (is&lt;ImageBitmapRenderingContext&gt;(m_context) &amp;&amp; shouldSnapshotBitmapRendererAction(name))
195         m_contentChanged = true;
196 #if ENABLE(WEBGL)
197     else if (is&lt;WebGLRenderingContext&gt;(m_context) &amp;&amp; shouldSnapshotWebGLAction(name))
198         m_contentChanged = true;
199 #endif
200 #if ENABLE(WEBGL2)
201     else if (is&lt;WebGL2RenderingContext&gt;(m_context) &amp;&amp; shouldSnapshotWebGL2Action(name))
202         m_contentChanged = true;
203 #endif
204 }
205 
206 void InspectorCanvas::finalizeFrame()
207 {
208     appendActionSnapshotIfNeeded();
209 
210     if (m_frames &amp;&amp; m_frames-&gt;length() &amp;&amp; !std::isnan(m_currentFrameStartTime)) {
211         auto currentFrame = static_cast&lt;Inspector::Protocol::Recording::Frame*&gt;(m_frames-&gt;get(m_frames-&gt;length() - 1).get());
212         currentFrame-&gt;setDuration((MonotonicTime::now() - m_currentFrameStartTime).milliseconds());
213 
214         m_currentFrameStartTime = MonotonicTime::nan();
215     }
216 
217     m_currentActions = nullptr;
218 }
219 
220 void InspectorCanvas::markCurrentFrameIncomplete()
221 {
222     if (!m_currentActions || !m_frames || !m_frames-&gt;length())
223         return;
224 
225     static_cast&lt;Inspector::Protocol::Recording::Frame*&gt;(m_frames-&gt;get(m_frames-&gt;length() - 1).get())-&gt;setIncomplete(true);
226 }
227 
228 void InspectorCanvas::setBufferLimit(long memoryLimit)
229 {
230     m_bufferLimit = std::min&lt;long&gt;(memoryLimit, std::numeric_limits&lt;int&gt;::max());
231 }
232 
233 bool InspectorCanvas::hasBufferSpace() const
234 {
235     return m_bufferUsed &lt; m_bufferLimit;
236 }
237 
238 void InspectorCanvas::setFrameCount(long frameCount)
239 {
240     if (frameCount &gt; 0)
241         m_frameCount = std::min&lt;long&gt;(frameCount, std::numeric_limits&lt;int&gt;::max());
242     else
243         m_frameCount = WTF::nullopt;
244 }
245 
246 bool InspectorCanvas::overFrameCount() const
247 {
248     return m_frameCount &amp;&amp; m_framesCaptured &gt;= m_frameCount.value();
249 }
250 
251 Ref&lt;Inspector::Protocol::Canvas::Canvas&gt; InspectorCanvas::buildObjectForCanvas(bool captureBacktrace)
252 {
253     Inspector::Protocol::Canvas::ContextType contextType;
254     if (is&lt;CanvasRenderingContext2D&gt;(m_context))
255         contextType = Inspector::Protocol::Canvas::ContextType::Canvas2D;
256     else if (is&lt;ImageBitmapRenderingContext&gt;(m_context))
257         contextType = Inspector::Protocol::Canvas::ContextType::BitmapRenderer;
258 #if ENABLE(WEBGL)
259     else if (is&lt;WebGLRenderingContext&gt;(m_context))
260         contextType = Inspector::Protocol::Canvas::ContextType::WebGL;
261 #endif
262 #if ENABLE(WEBGL2)
263     else if (is&lt;WebGL2RenderingContext&gt;(m_context))
264         contextType = Inspector::Protocol::Canvas::ContextType::WebGL2;
265 #endif
266 #if ENABLE(WEBGPU)
267     else if (is&lt;GPUCanvasContext&gt;(m_context))
268         contextType = Inspector::Protocol::Canvas::ContextType::WebGPU;
269 #endif
270     else {
271         ASSERT_NOT_REACHED();
272         contextType = Inspector::Protocol::Canvas::ContextType::Canvas2D;
273     }
274 
275     auto canvas = Inspector::Protocol::Canvas::Canvas::create()
276         .setCanvasId(m_identifier)
277         .setContextType(contextType)
278         .release();
279 
280     if (auto* node = canvasElement()) {
281         String cssCanvasName = node-&gt;document().nameForCSSCanvasElement(*node);
282         if (!cssCanvasName.isEmpty())
283             canvas-&gt;setCssCanvasName(cssCanvasName);
284 
285         // FIXME: &lt;https://webkit.org/b/178282&gt; Web Inspector: send a DOM node with each Canvas payload and eliminate Canvas.requestNode
286     }
287 
288     if (is&lt;ImageBitmapRenderingContext&gt;(m_context)) {
289         auto contextAttributes = Inspector::Protocol::Canvas::ContextAttributes::create()
290             .release();
291         contextAttributes-&gt;setAlpha(downcast&lt;ImageBitmapRenderingContext&gt;(m_context).hasAlpha());
292         canvas-&gt;setContextAttributes(WTFMove(contextAttributes));
293     }
294 #if ENABLE(WEBGL)
295     else if (is&lt;WebGLRenderingContextBase&gt;(m_context)) {
296         if (Optional&lt;WebGLContextAttributes&gt; attributes = downcast&lt;WebGLRenderingContextBase&gt;(m_context).getContextAttributes()) {
297             auto contextAttributes = Inspector::Protocol::Canvas::ContextAttributes::create()
298                 .release();
299             contextAttributes-&gt;setAlpha(attributes-&gt;alpha);
300             contextAttributes-&gt;setDepth(attributes-&gt;depth);
301             contextAttributes-&gt;setStencil(attributes-&gt;stencil);
302             contextAttributes-&gt;setAntialias(attributes-&gt;antialias);
303             contextAttributes-&gt;setPremultipliedAlpha(attributes-&gt;premultipliedAlpha);
304             contextAttributes-&gt;setPreserveDrawingBuffer(attributes-&gt;preserveDrawingBuffer);
305             contextAttributes-&gt;setFailIfMajorPerformanceCaveat(attributes-&gt;failIfMajorPerformanceCaveat);
306             canvas-&gt;setContextAttributes(WTFMove(contextAttributes));
307         }
308     }
309 #endif
310 
311     // FIXME: &lt;https://webkit.org/b/180833&gt; Web Inspector: support OffscreenCanvas for Canvas related operations
312 
313     if (auto* node = canvasElement()) {
314         if (size_t memoryCost = node-&gt;memoryCost())
315             canvas-&gt;setMemoryCost(memoryCost);
316     }
317 
318     if (captureBacktrace) {
319         auto stackTrace = Inspector::createScriptCallStack(JSExecState::currentState(), Inspector::ScriptCallStack::maxCallStackSizeToCapture);
320         canvas-&gt;setBacktrace(stackTrace-&gt;buildInspectorArray());
321     }
322 
323     return canvas;
324 }
325 
326 Ref&lt;Inspector::Protocol::Recording::Recording&gt; InspectorCanvas::releaseObjectForRecording()
327 {
328     ASSERT(!m_currentActions);
329     ASSERT(!m_lastRecordedAction);
330     ASSERT(!m_frames);
331 
332     Inspector::Protocol::Recording::Type type;
333     if (is&lt;CanvasRenderingContext2D&gt;(m_context))
334         type = Inspector::Protocol::Recording::Type::Canvas2D;
335     else if (is&lt;ImageBitmapRenderingContext&gt;(m_context))
336         type = Inspector::Protocol::Recording::Type::CanvasBitmapRenderer;
337 #if ENABLE(WEBGL)
338     else if (is&lt;WebGLRenderingContext&gt;(m_context))
339         type = Inspector::Protocol::Recording::Type::CanvasWebGL;
340 #endif
341 #if ENABLE(WEBGL2)
342     else if (is&lt;WebGL2RenderingContext&gt;(m_context))
343         type = Inspector::Protocol::Recording::Type::CanvasWebGL2;
344 #endif
345     else {
346         ASSERT_NOT_REACHED();
347         type = Inspector::Protocol::Recording::Type::Canvas2D;
348     }
349 
350     auto recording = Inspector::Protocol::Recording::Recording::create()
351         .setVersion(Inspector::Protocol::Recording::VERSION)
352         .setType(type)
353         .setInitialState(m_initialState.releaseNonNull())
354         .setData(m_serializedDuplicateData.releaseNonNull())
355         .release();
356 
357     if (!m_recordingName.isEmpty())
358         recording-&gt;setName(m_recordingName);
359 
360     resetRecordingData();
361 
362     return recording;
363 }
364 
365 String InspectorCanvas::getCanvasContentAsDataURL(ErrorString&amp; errorString)
366 {
367     // FIXME: &lt;https://webkit.org/b/173621&gt; Web Inspector: Support getting the content of WebMetal context;
368     if (!is&lt;CanvasRenderingContext2D&gt;(m_context)
369 #if ENABLE(WEBGL)
370         &amp;&amp; !is&lt;WebGLRenderingContextBase&gt;(m_context)
371 #endif
372         &amp;&amp; !is&lt;ImageBitmapRenderingContext&gt;(m_context)) {
373         errorString = &quot;Unsupported canvas context type&quot;_s;
374         return emptyString();
375     }
376 
377     // FIXME: &lt;https://webkit.org/b/180833&gt; Web Inspector: support OffscreenCanvas for Canvas related operations
378     auto* node = canvasElement();
379     if (!node) {
380         errorString = &quot;Context isn&#39;t related to an HTMLCanvasElement&quot;_s;
381         return emptyString();
382     }
383 
384 #if ENABLE(WEBGL)
385     if (is&lt;WebGLRenderingContextBase&gt;(m_context))
386         downcast&lt;WebGLRenderingContextBase&gt;(m_context).setPreventBufferClearForInspector(true);
387 #endif
388 
389     ExceptionOr&lt;UncachedString&gt; result = node-&gt;toDataURL(&quot;image/png&quot;_s);
390 
391 #if ENABLE(WEBGL)
392     if (is&lt;WebGLRenderingContextBase&gt;(m_context))
393         downcast&lt;WebGLRenderingContextBase&gt;(m_context).setPreventBufferClearForInspector(false);
394 #endif
395 
396     if (result.hasException()) {
397         errorString = result.releaseException().releaseMessage();
398         return emptyString();
399     }
400 
401     return result.releaseReturnValue().string;
402 }
403 
404 void InspectorCanvas::appendActionSnapshotIfNeeded()
405 {
406     if (!m_lastRecordedAction)
407         return;
408 
409     if (m_contentChanged) {
410         m_bufferUsed -= m_lastRecordedAction-&gt;memoryCost();
411 
412         ErrorString ignored;
413         m_lastRecordedAction-&gt;addItem(indexForData(getCanvasContentAsDataURL(ignored)));
414 
415         m_bufferUsed += m_lastRecordedAction-&gt;memoryCost();
416     }
417 
418     m_lastRecordedAction = nullptr;
419     m_contentChanged = false;
420 }
421 
422 int InspectorCanvas::indexForData(DuplicateDataVariant data)
423 {
424     size_t index = m_indexedDuplicateData.findMatching([&amp;] (auto item) {
425         if (data == item)
426             return true;
427 
428         auto traceA = WTF::get_if&lt;RefPtr&lt;ScriptCallStack&gt;&gt;(data);
429         auto traceB = WTF::get_if&lt;RefPtr&lt;ScriptCallStack&gt;&gt;(item);
430         if (traceA &amp;&amp; *traceA &amp;&amp; traceB &amp;&amp; *traceB)
431             return (*traceA)-&gt;isEqual((*traceB).get());
432 
433         return false;
434     });
435     if (index != notFound) {
436         ASSERT(index &lt; static_cast&lt;size_t&gt;(std::numeric_limits&lt;int&gt;::max()));
437         return static_cast&lt;int&gt;(index);
438     }
439 
440     if (!m_serializedDuplicateData)
441         m_serializedDuplicateData = JSON::ArrayOf&lt;JSON::Value&gt;::create();
442 
443     RefPtr&lt;JSON::Value&gt; item;
444     WTF::switchOn(data,
445         [&amp;] (const RefPtr&lt;HTMLImageElement&gt;&amp; imageElement) {
446             String dataURL = &quot;data:,&quot;_s;
447 
448             if (CachedImage* cachedImage = imageElement-&gt;cachedImage()) {
449                 Image* image = cachedImage-&gt;image();
450                 if (image &amp;&amp; image != &amp;Image::nullImage()) {
451                     std::unique_ptr&lt;ImageBuffer&gt; imageBuffer = ImageBuffer::create(image-&gt;size(), RenderingMode::Unaccelerated);
452                     imageBuffer-&gt;context().drawImage(*image, FloatPoint(0, 0));
453                     dataURL = imageBuffer-&gt;toDataURL(&quot;image/png&quot;);
454                 }
455             }
456 
457             index = indexForData(dataURL);
458         },
459 #if ENABLE(VIDEO)
460         [&amp;] (RefPtr&lt;HTMLVideoElement&gt;&amp; videoElement) {
461             String dataURL = &quot;data:,&quot;_s;
462 
463             unsigned videoWidth = videoElement-&gt;videoWidth();
464             unsigned videoHeight = videoElement-&gt;videoHeight();
465             std::unique_ptr&lt;ImageBuffer&gt; imageBuffer = ImageBuffer::create(FloatSize(videoWidth, videoHeight), RenderingMode::Unaccelerated);
466             if (imageBuffer) {
467                 videoElement-&gt;paintCurrentFrameInContext(imageBuffer-&gt;context(), FloatRect(0, 0, videoWidth, videoHeight));
468                 dataURL = imageBuffer-&gt;toDataURL(&quot;image/png&quot;);
469             }
470 
471             index = indexForData(dataURL);
472         },
473 #endif
474         [&amp;] (RefPtr&lt;HTMLCanvasElement&gt;&amp; canvasElement) {
475             String dataURL = &quot;data:,&quot;_s;
476 
477             ExceptionOr&lt;UncachedString&gt; result = canvasElement-&gt;toDataURL(&quot;image/png&quot;_s);
478             if (!result.hasException())
479                 dataURL = result.releaseReturnValue().string;
480 
481             index = indexForData(dataURL);
482         },
483         [&amp;] (const RefPtr&lt;CanvasGradient&gt;&amp; canvasGradient) { item = buildArrayForCanvasGradient(*canvasGradient); },
484         [&amp;] (const RefPtr&lt;CanvasPattern&gt;&amp; canvasPattern) { item = buildArrayForCanvasPattern(*canvasPattern); },
485         [&amp;] (const RefPtr&lt;ImageData&gt;&amp; imageData) { item = buildArrayForImageData(*imageData); },
486         [&amp;] (RefPtr&lt;ImageBitmap&gt;&amp; imageBitmap) {
487             index = indexForData(imageBitmap-&gt;buffer()-&gt;toDataURL(&quot;image/png&quot;));
488         },
489         [&amp;] (const RefPtr&lt;ScriptCallStack&gt;&amp; scriptCallStack) {
490             auto array = JSON::ArrayOf&lt;double&gt;::create();
491             for (size_t i = 0; i &lt; scriptCallStack-&gt;size(); ++i)
492                 array-&gt;addItem(indexForData(scriptCallStack-&gt;at(i)));
493             item = WTFMove(array);
494         },
495 #if ENABLE(CSS_TYPED_OM)
496         [&amp;] (const RefPtr&lt;TypedOMCSSImageValue&gt;&amp; cssImageValue) {
497             String dataURL = &quot;data:,&quot;_s;
498 
499             if (auto* cachedImage = cssImageValue-&gt;image()) {
500                 auto* image = cachedImage-&gt;image();
501                 if (image &amp;&amp; image != &amp;Image::nullImage()) {
502                     auto imageBuffer = ImageBuffer::create(image-&gt;size(), RenderingMode::Unaccelerated);
503                     imageBuffer-&gt;context().drawImage(*image, FloatPoint(0, 0));
504                     dataURL = imageBuffer-&gt;toDataURL(&quot;image/png&quot;);
505                 }
506             }
507 
508             index = indexForData(dataURL);
509         },
510 #endif
511         [&amp;] (const ScriptCallFrame&amp; scriptCallFrame) {
512             auto array = JSON::ArrayOf&lt;double&gt;::create();
513             array-&gt;addItem(indexForData(scriptCallFrame.functionName()));
514             array-&gt;addItem(indexForData(scriptCallFrame.sourceURL()));
515             array-&gt;addItem(static_cast&lt;int&gt;(scriptCallFrame.lineNumber()));
516             array-&gt;addItem(static_cast&lt;int&gt;(scriptCallFrame.columnNumber()));
517             item = WTFMove(array);
518         },
519         [&amp;] (const String&amp; value) { item = JSON::Value::create(value); }
520     );
521 
522     if (item) {
523         m_bufferUsed += item-&gt;memoryCost();
524         m_serializedDuplicateData-&gt;addItem(WTFMove(item));
525 
526         m_indexedDuplicateData.append(data);
527         index = m_indexedDuplicateData.size() - 1;
528     }
529 
530     ASSERT(index &lt; static_cast&lt;size_t&gt;(std::numeric_limits&lt;int&gt;::max()));
531     return static_cast&lt;int&gt;(index);
532 }
533 
534 String InspectorCanvas::stringIndexForKey(const String&amp; key)
535 {
536     return String::number(indexForData(key));
537 }
538 
539 static Ref&lt;JSON::ArrayOf&lt;double&gt;&gt; buildArrayForAffineTransform(const AffineTransform&amp; affineTransform)
540 {
541     auto array = JSON::ArrayOf&lt;double&gt;::create();
542     array-&gt;addItem(affineTransform.a());
543     array-&gt;addItem(affineTransform.b());
544     array-&gt;addItem(affineTransform.c());
545     array-&gt;addItem(affineTransform.d());
546     array-&gt;addItem(affineTransform.e());
547     array-&gt;addItem(affineTransform.f());
548     return array;
549 }
550 
551 template&lt;typename T&gt; static Ref&lt;JSON::ArrayOf&lt;JSON::Value&gt;&gt; buildArrayForVector(const Vector&lt;T&gt;&amp; vector)
552 {
553     auto array = JSON::ArrayOf&lt;JSON::Value&gt;::create();
554     for (auto&amp; item : vector)
555         array-&gt;addItem(item);
556     return array;
557 }
558 
559 Ref&lt;Inspector::Protocol::Recording::InitialState&gt; InspectorCanvas::buildInitialState()
560 {
561     auto initialStatePayload = Inspector::Protocol::Recording::InitialState::create().release();
562 
563     auto attributesPayload = JSON::Object::create();
564     attributesPayload-&gt;setInteger(&quot;width&quot;_s, m_context.canvasBase().width());
565     attributesPayload-&gt;setInteger(&quot;height&quot;_s, m_context.canvasBase().height());
566 
567     auto statesPayload = JSON::ArrayOf&lt;JSON::Object&gt;::create();
568 
569     auto parametersPayload = JSON::ArrayOf&lt;JSON::Value&gt;::create();
570 
571     if (is&lt;CanvasRenderingContext2D&gt;(m_context)) {
572         auto&amp; context2d = downcast&lt;CanvasRenderingContext2D&gt;(m_context);
573         for (auto&amp; state : context2d.stateStack()) {
574             auto statePayload = JSON::Object::create();
575 
576             statePayload-&gt;setArray(stringIndexForKey(&quot;setTransform&quot;_s), buildArrayForAffineTransform(state.transform));
577             statePayload-&gt;setDouble(stringIndexForKey(&quot;globalAlpha&quot;_s), context2d.globalAlpha());
578             statePayload-&gt;setInteger(stringIndexForKey(&quot;globalCompositeOperation&quot;_s), indexForData(context2d.globalCompositeOperation()));
579             statePayload-&gt;setDouble(stringIndexForKey(&quot;lineWidth&quot;_s), context2d.lineWidth());
580             statePayload-&gt;setInteger(stringIndexForKey(&quot;lineCap&quot;_s), indexForData(convertEnumerationToString(context2d.lineCap())));
581             statePayload-&gt;setInteger(stringIndexForKey(&quot;lineJoin&quot;_s), indexForData(convertEnumerationToString(context2d.lineJoin())));
582             statePayload-&gt;setDouble(stringIndexForKey(&quot;miterLimit&quot;_s), context2d.miterLimit());
583             statePayload-&gt;setDouble(stringIndexForKey(&quot;shadowOffsetX&quot;_s), context2d.shadowOffsetX());
584             statePayload-&gt;setDouble(stringIndexForKey(&quot;shadowOffsetY&quot;_s), context2d.shadowOffsetY());
585             statePayload-&gt;setDouble(stringIndexForKey(&quot;shadowBlur&quot;_s), context2d.shadowBlur());
586             statePayload-&gt;setInteger(stringIndexForKey(&quot;shadowColor&quot;_s), indexForData(context2d.shadowColor()));
587 
588             // The parameter to `setLineDash` is itself an array, so we need to wrap the parameters
589             // list in an array to allow spreading.
590             auto setLineDash = JSON::ArrayOf&lt;JSON::Value&gt;::create();
591             setLineDash-&gt;addItem(buildArrayForVector(state.lineDash));
592             statePayload-&gt;setArray(stringIndexForKey(&quot;setLineDash&quot;_s), WTFMove(setLineDash));
593 
594             statePayload-&gt;setDouble(stringIndexForKey(&quot;lineDashOffset&quot;_s), context2d.lineDashOffset());
595             statePayload-&gt;setInteger(stringIndexForKey(&quot;font&quot;_s), indexForData(context2d.font()));
596             statePayload-&gt;setInteger(stringIndexForKey(&quot;textAlign&quot;_s), indexForData(convertEnumerationToString(context2d.textAlign())));
597             statePayload-&gt;setInteger(stringIndexForKey(&quot;textBaseline&quot;_s), indexForData(convertEnumerationToString(context2d.textBaseline())));
598             statePayload-&gt;setInteger(stringIndexForKey(&quot;direction&quot;_s), indexForData(convertEnumerationToString(context2d.direction())));
599 
600             int strokeStyleIndex;
601             if (auto canvasGradient = state.strokeStyle.canvasGradient())
602                 strokeStyleIndex = indexForData(canvasGradient);
603             else if (auto canvasPattern = state.strokeStyle.canvasPattern())
604                 strokeStyleIndex = indexForData(canvasPattern);
605             else
606                 strokeStyleIndex = indexForData(state.strokeStyle.color());
607             statePayload-&gt;setInteger(stringIndexForKey(&quot;strokeStyle&quot;_s), strokeStyleIndex);
608 
609             int fillStyleIndex;
610             if (auto canvasGradient = state.fillStyle.canvasGradient())
611                 fillStyleIndex = indexForData(canvasGradient);
612             else if (auto canvasPattern = state.fillStyle.canvasPattern())
613                 fillStyleIndex = indexForData(canvasPattern);
614             else
615                 fillStyleIndex = indexForData(state.fillStyle.color());
616             statePayload-&gt;setInteger(stringIndexForKey(&quot;fillStyle&quot;_s), fillStyleIndex);
617 
618             statePayload-&gt;setBoolean(stringIndexForKey(&quot;imageSmoothingEnabled&quot;_s), context2d.imageSmoothingEnabled());
619             statePayload-&gt;setInteger(stringIndexForKey(&quot;imageSmoothingQuality&quot;_s), indexForData(convertEnumerationToString(context2d.imageSmoothingQuality())));
620 
621             auto setPath = JSON::ArrayOf&lt;JSON::Value&gt;::create();
622             setPath-&gt;addItem(indexForData(buildStringFromPath(context2d.getPath()-&gt;path())));
623             statePayload-&gt;setArray(stringIndexForKey(&quot;setPath&quot;_s), WTFMove(setPath));
624 
625             statesPayload-&gt;addItem(WTFMove(statePayload));
626         }
627     }
628 #if ENABLE(WEBGL)
629     else if (is&lt;WebGLRenderingContextBase&gt;(m_context)) {
630         WebGLRenderingContextBase&amp; contextWebGLBase = downcast&lt;WebGLRenderingContextBase&gt;(m_context);
631         if (Optional&lt;WebGLContextAttributes&gt; webGLContextAttributes = contextWebGLBase.getContextAttributes()) {
632             auto webGLContextAttributesPayload = JSON::Object::create();
633             webGLContextAttributesPayload-&gt;setBoolean(&quot;alpha&quot;_s, webGLContextAttributes-&gt;alpha);
634             webGLContextAttributesPayload-&gt;setBoolean(&quot;depth&quot;_s, webGLContextAttributes-&gt;depth);
635             webGLContextAttributesPayload-&gt;setBoolean(&quot;stencil&quot;_s, webGLContextAttributes-&gt;stencil);
636             webGLContextAttributesPayload-&gt;setBoolean(&quot;antialias&quot;_s, webGLContextAttributes-&gt;antialias);
637             webGLContextAttributesPayload-&gt;setBoolean(&quot;premultipliedAlpha&quot;_s, webGLContextAttributes-&gt;premultipliedAlpha);
638             webGLContextAttributesPayload-&gt;setBoolean(&quot;preserveDrawingBuffer&quot;_s, webGLContextAttributes-&gt;preserveDrawingBuffer);
639             webGLContextAttributesPayload-&gt;setBoolean(&quot;failIfMajorPerformanceCaveat&quot;_s, webGLContextAttributes-&gt;failIfMajorPerformanceCaveat);
640             parametersPayload-&gt;addItem(WTFMove(webGLContextAttributesPayload));
641         }
642     }
643 #endif
644 
645     initialStatePayload-&gt;setAttributes(WTFMove(attributesPayload));
646 
647     if (statesPayload-&gt;length())
648         initialStatePayload-&gt;setStates(WTFMove(statesPayload));
649 
650     if (parametersPayload-&gt;length())
651         initialStatePayload-&gt;setParameters(WTFMove(parametersPayload));
652 
653     ErrorString ignored;
654     initialStatePayload-&gt;setContent(getCanvasContentAsDataURL(ignored));
655 
656     return initialStatePayload;
657 }
658 
659 Ref&lt;JSON::ArrayOf&lt;JSON::Value&gt;&gt; InspectorCanvas::buildAction(const String&amp; name, std::initializer_list&lt;RecordCanvasActionVariant&gt;&amp;&amp; parameters)
660 {
661     auto action = JSON::ArrayOf&lt;JSON::Value&gt;::create();
662     action-&gt;addItem(indexForData(name));
663 
664     auto parametersData = JSON::ArrayOf&lt;JSON::Value&gt;::create();
665     auto swizzleTypes = JSON::ArrayOf&lt;int&gt;::create();
666 
667     auto addParameter = [&amp;parametersData, &amp;swizzleTypes] (auto value, RecordingSwizzleTypes swizzleType) {
668         parametersData-&gt;addItem(value);
669         swizzleTypes-&gt;addItem(static_cast&lt;int&gt;(swizzleType));
670     };
671 
672     // Declared before it&#39;s initialized so it can be used recursively.
673     Function&lt;void(const RecordCanvasActionVariant&amp;)&gt; parseParameter;
674     parseParameter = [&amp;] (const auto&amp; parameter) {
675         WTF::switchOn(parameter,
676             [&amp;] (CanvasDirection value) { addParameter(indexForData(convertEnumerationToString(value)), RecordingSwizzleTypes::String); },
677             [&amp;] (CanvasFillRule value) { addParameter(indexForData(convertEnumerationToString(value)), RecordingSwizzleTypes::String); },
678             [&amp;] (CanvasLineCap value) { addParameter(indexForData(convertEnumerationToString(value)), RecordingSwizzleTypes::String); },
679             [&amp;] (CanvasLineJoin value) { addParameter(indexForData(convertEnumerationToString(value)), RecordingSwizzleTypes::String); },
680             [&amp;] (CanvasTextAlign value) { addParameter(indexForData(convertEnumerationToString(value)), RecordingSwizzleTypes::String); },
681             [&amp;] (CanvasTextBaseline value) { addParameter(indexForData(convertEnumerationToString(value)), RecordingSwizzleTypes::String); },
682             [&amp;] (ImageSmoothingQuality value) { addParameter(indexForData(convertEnumerationToString(value)), RecordingSwizzleTypes::String); },
683             [&amp;] (const DOMMatrix2DInit&amp; value) {
684                 auto array = JSON::ArrayOf&lt;double&gt;::create();
685                 array-&gt;addItem(value.a.valueOr(1));
686                 array-&gt;addItem(value.b.valueOr(0));
687                 array-&gt;addItem(value.c.valueOr(0));
688                 array-&gt;addItem(value.d.valueOr(1));
689                 array-&gt;addItem(value.e.valueOr(0));
690                 array-&gt;addItem(value.f.valueOr(0));
691                 addParameter(array.ptr(), RecordingSwizzleTypes::DOMMatrix);
692             },
693             [&amp;] (const Element* value) {
694                 if (value) {
695                     // Elements are not serializable, so add a string as a placeholder since the actual
696                     // element cannot be reconstructed in the frontend.
697                     addParameter(indexForData(&quot;Element&quot;), RecordingSwizzleTypes::None);
698                 }
699             },
700             [&amp;] (HTMLImageElement* value) {
701                 if (value)
702                     addParameter(indexForData(value), RecordingSwizzleTypes::Image); },
703             [&amp;] (ImageBitmap* value) {
704                 if (value)
705                     addParameter(indexForData(value), RecordingSwizzleTypes::ImageBitmap); },
706             [&amp;] (ImageData* value) {
707                 if (value)
708                     addParameter(indexForData(value), RecordingSwizzleTypes::ImageData); },
709             [&amp;] (const Path2D* value) {
710                 if (value)
711                     addParameter(indexForData(buildStringFromPath(value-&gt;path())), RecordingSwizzleTypes::Path2D); },
712 #if ENABLE(WEBGL)
713             // FIXME: &lt;https://webkit.org/b/176009&gt; Web Inspector: send data for WebGL objects during a recording instead of a placeholder string
714             [&amp;] (const WebGLBuffer* value) {
715                 if (value)
716                     addParameter(0, RecordingSwizzleTypes::WebGLBuffer);
717             },
718             [&amp;] (const WebGLFramebuffer* value) {
719                 if (value)
720                     addParameter(0, RecordingSwizzleTypes::WebGLFramebuffer);
721             },
722             [&amp;] (const WebGLProgram* value) {
723                 if (value)
724                     addParameter(0, RecordingSwizzleTypes::WebGLProgram);
725             },
726             [&amp;] (const WebGLQuery* value) {
727                 if (value)
728                     addParameter(0, RecordingSwizzleTypes::WebGLQuery);
729             },
730             [&amp;] (const WebGLRenderbuffer* value) {
731                 if (value)
732                     addParameter(0, RecordingSwizzleTypes::WebGLRenderbuffer);
733             },
734             [&amp;] (const WebGLSampler* value) {
735                 if (value)
736                     addParameter(0, RecordingSwizzleTypes::WebGLSampler);
737             },
738             [&amp;] (const WebGLShader* value) {
739                 if (value)
740                     addParameter(0, RecordingSwizzleTypes::WebGLShader);
741             },
742             [&amp;] (const WebGLSync* value) {
743                 if (value)
744                     addParameter(0, RecordingSwizzleTypes::WebGLSync);
745             },
746             [&amp;] (const WebGLTexture* value) {
747                 if (value)
748                     addParameter(0, RecordingSwizzleTypes::WebGLTexture);
749             },
750             [&amp;] (const WebGLTransformFeedback* value) {
751                 if (value)
752                     addParameter(0, RecordingSwizzleTypes::WebGLTransformFeedback);
753             },
754             [&amp;] (const WebGLUniformLocation* value) {
755                 if (value)
756                     addParameter(0, RecordingSwizzleTypes::WebGLUniformLocation);
757             },
758             [&amp;] (const WebGLVertexArrayObject* value) {
759                 if (value)
760                     addParameter(0, RecordingSwizzleTypes::WebGLVertexArrayObject);
761             },
762 #endif
763             [&amp;] (const RefPtr&lt;ArrayBuffer&gt;&amp; value) {
764                 if (value)
765                     addParameter(0, RecordingSwizzleTypes::TypedArray);
766             },
767             [&amp;] (const RefPtr&lt;ArrayBufferView&gt;&amp; value) {
768                 if (value)
769                     addParameter(0, RecordingSwizzleTypes::TypedArray);
770             },
771             [&amp;] (const RefPtr&lt;CanvasGradient&gt;&amp; value) {
772                 if (value)
773                     addParameter(indexForData(value), RecordingSwizzleTypes::CanvasGradient);
774             },
775             [&amp;] (const RefPtr&lt;CanvasPattern&gt;&amp; value) {
776                 if (value)
777                     addParameter(indexForData(value), RecordingSwizzleTypes::CanvasPattern);
778             },
779             [&amp;] (const RefPtr&lt;Float32Array&gt;&amp; value) {
780                 if (value)
781                     addParameter(0, RecordingSwizzleTypes::TypedArray);
782             },
783             [&amp;] (const RefPtr&lt;HTMLCanvasElement&gt;&amp; value) {
784                 if (value)
785                     addParameter(indexForData(value), RecordingSwizzleTypes::Image);
786             },
787             [&amp;] (const RefPtr&lt;HTMLImageElement&gt;&amp; value) {
788                 if (value)
789                     addParameter(indexForData(value), RecordingSwizzleTypes::Image);
790             },
791 #if ENABLE(VIDEO)
792             [&amp;] (const RefPtr&lt;HTMLVideoElement&gt;&amp; value) {
793                 if (value)
794                     addParameter(indexForData(value), RecordingSwizzleTypes::Image);
795             },
796 #endif
797 #if ENABLE(CSS_TYPED_OM)
798             [&amp;] (const RefPtr&lt;TypedOMCSSImageValue&gt;&amp; value) {
799                 if (value)
800                     addParameter(indexForData(value), RecordingSwizzleTypes::Image);
801             },
802 #endif
803             [&amp;] (const RefPtr&lt;ImageBitmap&gt;&amp; value) {
804                 if (value)
805                     addParameter(indexForData(value), RecordingSwizzleTypes::ImageBitmap);
806             },
807             [&amp;] (const RefPtr&lt;ImageData&gt;&amp; value) {
808                 if (value)
809                     addParameter(indexForData(value), RecordingSwizzleTypes::ImageData);
810             },
811             [&amp;] (const RefPtr&lt;Int32Array&gt;&amp; value) {
812                 if (value)
813                     addParameter(0, RecordingSwizzleTypes::TypedArray);
814             },
815             [&amp;] (const RefPtr&lt;Uint32Array&gt;&amp; value) {
816                 if (value)
817                     addParameter(0, RecordingSwizzleTypes::TypedArray);
818             },
819             [&amp;] (const CanvasImageSource&amp; value) {
820                 WTF::visit(parseParameter, value);
821             },
822             [&amp;] (const CanvasRenderingContext2DBase::Style&amp; value) {
823                 WTF::visit(parseParameter, value);
824             },
825 #if ENABLE(WEBGL)
826             [&amp;] (const WebGLRenderingContextBase::BufferDataSource&amp; value) {
827                 WTF::visit(parseParameter, value);
828             },
829             [&amp;] (const Optional&lt;WebGLRenderingContextBase::BufferDataSource&gt;&amp; value) {
830                 if (value)
831                     parseParameter(value.value());
832             },
833             [&amp;] (const WebGLRenderingContextBase::TexImageSource&amp; value) {
834                 WTF::visit(parseParameter, value);
835             },
836             [&amp;] (const Optional&lt;WebGLRenderingContextBase::TexImageSource&gt;&amp; value) {
837                 if (value)
838                     parseParameter(value.value());
839             },
840 #endif
841             [&amp;] (const Vector&lt;String&gt;&amp; value) {
842                 auto deduplicated = value.map([&amp;] (const String&amp; item) {
843                     return indexForData(item);
844                 });
845                 addParameter(buildArrayForVector(deduplicated).ptr(), RecordingSwizzleTypes::String);
846             },
847             [&amp;] (const Vector&lt;float&gt;&amp; value) { addParameter(buildArrayForVector(value).ptr(), RecordingSwizzleTypes::Array); },
848             [&amp;] (const Vector&lt;uint32_t&gt;&amp; value) {
849                 auto mapped = value.map([&amp;] (uint32_t item) {
850                     return static_cast&lt;double&gt;(item);
851                 });
852                 addParameter(buildArrayForVector(mapped).ptr(), RecordingSwizzleTypes::Array);
853             },
854             [&amp;] (const Vector&lt;int32_t&gt;&amp; value) { addParameter(buildArrayForVector(value).ptr(), RecordingSwizzleTypes::Array); },
855 #if ENABLE(WEBGL)
856             [&amp;] (const WebGLRenderingContextBase::Float32List::VariantType&amp; value) {
857                 WTF::visit(parseParameter, value);
858             },
859             [&amp;] (const WebGLRenderingContextBase::Int32List::VariantType&amp; value) {
860                 WTF::visit(parseParameter, value);
861             },
862 #endif
863 #if ENABLE(WEBGL2)
864             [&amp;] (const WebGL2RenderingContext::Uint32List::VariantType&amp; value) {
865                 WTF::visit(parseParameter, value);
866             },
867 #endif
868             [&amp;] (const String&amp; value) { addParameter(indexForData(value), RecordingSwizzleTypes::String); },
869             [&amp;] (double value) { addParameter(value, RecordingSwizzleTypes::Number); },
870             [&amp;] (float value) { addParameter(value, RecordingSwizzleTypes::Number); },
871             [&amp;] (const Optional&lt;float&gt;&amp; value) {
872                 if (value)
873                     parseParameter(value.value());
874             },
875             [&amp;] (uint64_t value) { addParameter(static_cast&lt;double&gt;(value), RecordingSwizzleTypes::Number); },
876             [&amp;] (int64_t value) { addParameter(static_cast&lt;double&gt;(value), RecordingSwizzleTypes::Number); },
877             [&amp;] (uint32_t value) { addParameter(static_cast&lt;double&gt;(value), RecordingSwizzleTypes::Number); },
878             [&amp;] (int32_t value) { addParameter(value, RecordingSwizzleTypes::Number); },
879             [&amp;] (uint8_t value) { addParameter(static_cast&lt;int&gt;(value), RecordingSwizzleTypes::Number); },
880             [&amp;] (bool value) { addParameter(value, RecordingSwizzleTypes::Boolean); }
881         );
882     };
883     for (auto&amp; parameter : parameters)
884         parseParameter(parameter);
885 
886     action-&gt;addItem(WTFMove(parametersData));
887     action-&gt;addItem(WTFMove(swizzleTypes));
888 
889     auto trace = Inspector::createScriptCallStack(JSExecState::currentState(), Inspector::ScriptCallStack::maxCallStackSizeToCapture);
890     action-&gt;addItem(indexForData(trace.ptr()));
891 
892     return action;
893 }
894 
895 Ref&lt;JSON::ArrayOf&lt;JSON::Value&gt;&gt; InspectorCanvas::buildArrayForCanvasGradient(const CanvasGradient&amp; canvasGradient)
896 {
897     const auto&amp; gradient = canvasGradient.gradient();
898 
899     String type = gradient.type() == Gradient::Type::Radial ? &quot;radial-gradient&quot;_s : gradient.type() == Gradient::Type::Linear ? &quot;linear-gradient&quot;_s : &quot;conic-gradient&quot;_s;
900 
901     auto parameters = JSON::ArrayOf&lt;float&gt;::create();
902     WTF::switchOn(gradient.data(),
903         [&amp;parameters] (const Gradient::LinearData&amp; data) {
904             parameters-&gt;addItem(data.point0.x());
905             parameters-&gt;addItem(data.point0.y());
906             parameters-&gt;addItem(data.point1.x());
907             parameters-&gt;addItem(data.point1.y());
908         },
909         [&amp;parameters] (const Gradient::RadialData&amp; data) {
910             parameters-&gt;addItem(data.point0.x());
911             parameters-&gt;addItem(data.point0.y());
912             parameters-&gt;addItem(data.startRadius);
913             parameters-&gt;addItem(data.point1.x());
914             parameters-&gt;addItem(data.point1.y());
915             parameters-&gt;addItem(data.endRadius);
916         },
917         [&amp;parameters] (const Gradient::ConicData&amp; data) {
918             parameters-&gt;addItem(data.point0.x());
919             parameters-&gt;addItem(data.point0.y());
920             parameters-&gt;addItem(data.angleRadians);
921         }
922     );
923 
924     auto stops = JSON::ArrayOf&lt;JSON::Value&gt;::create();
925     for (auto&amp; colorStop : gradient.stops()) {
926         auto stop = JSON::ArrayOf&lt;JSON::Value&gt;::create();
927         stop-&gt;addItem(colorStop.offset);
928         stop-&gt;addItem(indexForData(colorStop.color.cssText()));
929         stops-&gt;addItem(WTFMove(stop));
930     }
931 
932     auto array = JSON::ArrayOf&lt;JSON::Value&gt;::create();
933     array-&gt;addItem(indexForData(type));
934     array-&gt;addItem(WTFMove(parameters));
935     array-&gt;addItem(WTFMove(stops));
936     return array;
937 }
938 
939 Ref&lt;JSON::ArrayOf&lt;JSON::Value&gt;&gt; InspectorCanvas::buildArrayForCanvasPattern(const CanvasPattern&amp; canvasPattern)
940 {
941     Image&amp; tileImage = canvasPattern.pattern().tileImage();
942     auto imageBuffer = ImageBuffer::create(tileImage.size(), RenderingMode::Unaccelerated);
943     imageBuffer-&gt;context().drawImage(tileImage, FloatPoint(0, 0));
944 
945     String repeat;
946     bool repeatX = canvasPattern.pattern().repeatX();
947     bool repeatY = canvasPattern.pattern().repeatY();
948     if (repeatX &amp;&amp; repeatY)
949         repeat = &quot;repeat&quot;_s;
950     else if (repeatX &amp;&amp; !repeatY)
951         repeat = &quot;repeat-x&quot;_s;
952     else if (!repeatX &amp;&amp; repeatY)
953         repeat = &quot;repeat-y&quot;_s;
954     else
955         repeat = &quot;no-repeat&quot;_s;
956 
957     auto array = JSON::ArrayOf&lt;JSON::Value&gt;::create();
958     array-&gt;addItem(indexForData(imageBuffer-&gt;toDataURL(&quot;image/png&quot;)));
959     array-&gt;addItem(indexForData(repeat));
960     return array;
961 }
962 
963 Ref&lt;JSON::ArrayOf&lt;JSON::Value&gt;&gt; InspectorCanvas::buildArrayForImageData(const ImageData&amp; imageData)
964 {
965     auto data = JSON::ArrayOf&lt;int&gt;::create();
966     for (size_t i = 0; i &lt; imageData.data()-&gt;length(); ++i)
967         data-&gt;addItem(imageData.data()-&gt;item(i));
968 
969     auto array = JSON::ArrayOf&lt;JSON::Value&gt;::create();
970     array-&gt;addItem(WTFMove(data));
971     array-&gt;addItem(imageData.width());
972     array-&gt;addItem(imageData.height());
973     return array;
974 }
975 
976 } // namespace WebCore
977 
    </pre>
  </body>
</html>