<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderLayer.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="RenderLayer.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="RenderLayerBacking.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderLayer.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  46 #include &quot;ClipRect.h&quot;
  47 #include &quot;GraphicsLayer.h&quot;
  48 #include &quot;LayerFragment.h&quot;
  49 #include &quot;PaintFrequencyTracker.h&quot;
  50 #include &quot;PaintInfo.h&quot;
  51 #include &quot;RenderBox.h&quot;
  52 #include &quot;RenderPtr.h&quot;
  53 #include &quot;ScrollableArea.h&quot;
  54 #include &lt;memory&gt;
  55 #include &lt;wtf/WeakPtr.h&gt;
  56 
  57 namespace WTF {
  58 class TextStream;
  59 }
  60 
  61 namespace WebCore {
  62 
  63 class CSSFilter;
  64 class ClipRects;
  65 class ClipRectsCache;

  66 class HitTestRequest;
  67 class HitTestResult;
  68 class HitTestingTransformState;

  69 class RenderFragmentedFlow;
  70 class RenderGeometryMap;
  71 class RenderLayerBacking;
  72 class RenderLayerCompositor;
  73 class RenderLayerFilters;
  74 class RenderMarquee;
  75 class RenderReplica;
  76 class RenderScrollbarPart;
  77 class RenderStyle;
  78 class RenderView;
  79 class Scrollbar;
  80 class TransformationMatrix;
  81 
  82 enum BorderRadiusClippingRule { IncludeSelfForBorderRadius, DoNotIncludeSelfForBorderRadius };
  83 enum IncludeSelfOrNot { IncludeSelf, ExcludeSelf };
  84 
  85 enum RepaintStatus {
  86     NeedsNormalRepaint,
  87     NeedsFullRepaint,
  88     NeedsFullRepaintForPositionedMovementLayout
</pre>
<hr />
<pre>
  98 };
  99 
 100 enum ShouldRespectOverflowClip {
 101     IgnoreOverflowClip,
 102     RespectOverflowClip
 103 };
 104 
 105 enum ShouldApplyRootOffsetToFragments {
 106     ApplyRootOffsetToFragments,
 107     IgnoreRootOffsetForFragments
 108 };
 109 
 110 enum class RequestState {
 111     Unknown,
 112     DontCare,
 113     False,
 114     True,
 115     Undetermined
 116 };
 117 











 118 struct ScrollRectToVisibleOptions {
 119     SelectionRevealMode revealMode { SelectionRevealMode::Reveal };
 120     const ScrollAlignment&amp; alignX { ScrollAlignment::alignCenterIfNeeded };
 121     const ScrollAlignment&amp; alignY { ScrollAlignment::alignCenterIfNeeded };
 122     ShouldAllowCrossOriginScrolling shouldAllowCrossOriginScrolling { ShouldAllowCrossOriginScrolling::No };
 123 };
 124 
 125 class RenderLayer final : public ScrollableArea {
 126     WTF_MAKE_FAST_ALLOCATED;
 127 public:
 128     friend class RenderReplica;
 129     friend class RenderLayerFilters;


 130 
 131     explicit RenderLayer(RenderLayerModelObject&amp;);
 132     virtual ~RenderLayer();
 133 
 134 #if PLATFORM(IOS_FAMILY)
 135     // Called before the renderer&#39;s widget (if any) has been nulled out.
 136     void willBeDestroyed();
 137 #endif
 138     String name() const;
 139 
 140     Page&amp; page() const { return renderer().page(); }
 141     RenderLayerModelObject&amp; renderer() const { return m_renderer; }
 142     RenderBox* renderBox() const { return is&lt;RenderBox&gt;(renderer()) ? &amp;downcast&lt;RenderBox&gt;(renderer()) : nullptr; }
 143 
 144     RenderLayer* parent() const { return m_parent; }
 145     RenderLayer* previousSibling() const { return m_previous; }
 146     RenderLayer* nextSibling() const { return m_next; }
 147     RenderLayer* firstChild() const { return m_first; }
 148     RenderLayer* lastChild() const { return m_last; }
 149     bool isDescendantOf(const RenderLayer&amp;) const;
 150 
 151     // This does an ancestor tree walk. Avoid it!
 152     const RenderLayer* root() const
 153     {
 154         const RenderLayer* curr = this;
 155         while (curr-&gt;parent())
 156             curr = curr-&gt;parent();
 157         return curr;
 158     }
 159 
 160     void addChild(RenderLayer&amp; newChild, RenderLayer* beforeChild = nullptr);
 161     void removeChild(RenderLayer&amp;);
 162 
 163     void insertOnlyThisLayer();
 164     void removeOnlyThisLayer();
 165 
 166     bool isNormalFlowOnly() const { return m_isNormalFlowOnly; }
<span class="line-modified"> 167     bool isStackingContext() const { return m_isStackingContext; }</span>








 168 
 169     // Gets the enclosing stacking context for this layer, excluding this layer itself.
 170     RenderLayer* stackingContext() const;
 171 
 172     // Gets the enclosing stacking container for this layer, possibly the layer
 173     // itself, if it is a stacking container.
 174     RenderLayer* enclosingStackingContext() { return isStackingContext() ? this : stackingContext(); }
 175 
 176     RenderLayer* paintOrderParent() const;
 177 
 178     void dirtyNormalFlowList();
 179     void dirtyZOrderLists();
 180     void dirtyStackingContextZOrderLists();
 181 
 182     bool normalFlowListDirty() const { return m_normalFlowListDirty; }
 183     bool zOrderListsDirty() const { return m_zOrderListsDirty; }
 184 
 185 #if !ASSERT_DISABLED
 186     bool layerListMutationAllowed() const { return m_layerListMutationAllowed; }
 187     void setLayerListMutationAllowed(bool flag) { m_layerListMutationAllowed = flag; }
</pre>
<hr />
<pre>
 382     bool cannotBlitToWindow() const;
 383 
 384     bool isTransparent() const { return renderer().isTransparent() || renderer().hasMask(); }
 385 
 386     bool hasReflection() const { return renderer().hasReflection(); }
 387     bool isReflection() const { return renderer().isReplica(); }
 388     RenderReplica* reflection() const { return m_reflection.get(); }
 389     RenderLayer* reflectionLayer() const;
 390     bool isReflectionLayer(const RenderLayer&amp;) const;
 391 
 392     const LayoutPoint&amp; location() const { return m_topLeft; }
 393     void setLocation(const LayoutPoint&amp; p) { m_topLeft = p; }
 394 
 395     const IntSize&amp; size() const { return m_layerSize; }
 396     void setSize(const IntSize&amp; size) { m_layerSize = size; } // Only public for RenderTreeAsText.
 397 
 398     LayoutRect rect() const { return LayoutRect(location(), size()); }
 399 
 400     IntSize visibleSize() const override;
 401     IntSize contentsSize() const override;

 402 
 403     int scrollWidth() const;
 404     int scrollHeight() const;
 405 
 406     void panScrollFromPoint(const IntPoint&amp;);
 407 
 408     // Scrolling methods for layers that can scroll their overflow.
 409     void scrollByRecursively(const IntSize&amp; delta, ScrollableArea** scrolledArea = nullptr);
 410 
<span class="line-modified"> 411     WEBCORE_EXPORT void scrollToOffset(const ScrollOffset&amp;, ScrollClamping = ScrollClamping::Clamped);</span>
<span class="line-removed"> 412     void scrollToXOffset(int x, ScrollClamping clamping = ScrollClamping::Clamped) { scrollToOffset(ScrollOffset(x, scrollOffset().y()), clamping); }</span>
<span class="line-removed"> 413     void scrollToYOffset(int y, ScrollClamping clamping = ScrollClamping::Clamped) { scrollToOffset(ScrollOffset(scrollOffset().x(), y), clamping); }</span>
 414 
<span class="line-modified"> 415     void scrollToXPosition(int x, ScrollClamping = ScrollClamping::Clamped);</span>
<span class="line-modified"> 416     void scrollToYPosition(int y, ScrollClamping = ScrollClamping::Clamped);</span>




 417 
 418     void setPostLayoutScrollPosition(Optional&lt;ScrollPosition&gt;);
 419     void applyPostLayoutScrollPositionIfNeeded();
 420 
<span class="line-removed"> 421     ScrollOffset scrollOffset() const { return scrollOffsetFromPosition(m_scrollPosition); }</span>
<span class="line-removed"> 422     IntSize scrollableContentsSize() const;</span>
<span class="line-removed"> 423 </span>
 424     void availableContentSizeChanged(AvailableSizeChangeReason) override;
 425 
 426     // &quot;absoluteRect&quot; is in scaled document coordinates.
 427     void scrollRectToVisible(const LayoutRect&amp; absoluteRect, bool insideFixed, const ScrollRectToVisibleOptions&amp;);
 428 
 429     bool scrollsOverflow() const;


 430     bool hasScrollbars() const { return m_hBar || m_vBar; }
 431     void setHasHorizontalScrollbar(bool);
 432     void setHasVerticalScrollbar(bool);
 433 
 434     Ref&lt;Scrollbar&gt; createScrollbar(ScrollbarOrientation);
 435     void destroyScrollbar(ScrollbarOrientation);
 436 
 437     bool hasHorizontalScrollbar() const { return horizontalScrollbar(); }
 438     bool hasVerticalScrollbar() const { return verticalScrollbar(); }
 439 



 440     // ScrollableArea overrides
 441     ScrollPosition scrollPosition() const override { return m_scrollPosition; }
 442 
 443     Scrollbar* horizontalScrollbar() const override { return m_hBar.get(); }
 444     Scrollbar* verticalScrollbar() const override { return m_vBar.get(); }
 445     ScrollableArea* enclosingScrollableArea() const override;

 446     bool isScrollableOrRubberbandable() override;
 447     bool hasScrollableOrRubberbandableAncestor() override;
 448     bool useDarkAppearance() const final;
 449 #if ENABLE(CSS_SCROLL_SNAP)
 450     void updateSnapOffsets() override;
 451 #endif
 452 
<span class="line-removed"> 453     void setIsUserScroll(bool isUserScroll) override { m_inUserScroll = isUserScroll; }</span>
<span class="line-removed"> 454     bool isInUserScroll() const { return m_inUserScroll; }</span>
<span class="line-removed"> 455 </span>
 456     bool requiresScrollPositionReconciliation() const { return m_requiresScrollPositionReconciliation; }
 457     void setRequiresScrollPositionReconciliation(bool requiresReconciliation = true) { m_requiresScrollPositionReconciliation = requiresReconciliation; }
 458 
 459 #if PLATFORM(IOS_FAMILY)
 460 #if ENABLE(IOS_TOUCH_EVENTS)
 461     bool handleTouchEvent(const PlatformTouchEvent&amp;) override;
 462 #endif
 463 
 464     void didStartScroll() override;
 465     void didEndScroll() override;
 466     void didUpdateScroll() override;
 467 #endif
 468 
 469     // Returns true when the layer could do touch scrolling, but doesn&#39;t look at whether there is actually scrollable overflow.
 470     bool canUseCompositedScrolling() const;
 471     // Returns true when there is actually scrollable overflow (requires layout to be up-to-date).
<span class="line-modified"> 472     bool hasCompositedScrollableOverflow() const;</span>
 473 
 474     int verticalScrollbarWidth(OverlayScrollbarSizeRelevancy = IgnoreOverlayScrollbarSize) const;
 475     int horizontalScrollbarHeight(OverlayScrollbarSizeRelevancy = IgnoreOverlayScrollbarSize) const;
 476 
 477     bool hasOverflowControls() const;
 478     bool isPointInResizeControl(const IntPoint&amp; absolutePoint) const;
 479     bool hitTestOverflowControls(HitTestResult&amp;, const IntPoint&amp; localPoint);
 480     IntSize offsetFromResizeCorner(const IntPoint&amp; absolutePoint) const;
 481 
 482     void paintOverflowControls(GraphicsContext&amp;, const IntPoint&amp;, const IntRect&amp; damageRect, bool paintingOverlayControls = false);
 483     void paintScrollCorner(GraphicsContext&amp;, const IntPoint&amp;, const IntRect&amp; damageRect);
 484     void paintResizer(GraphicsContext&amp;, const LayoutPoint&amp;, const LayoutRect&amp; damageRect);
 485 
 486     void updateScrollInfoAfterLayout();
 487 
 488     bool scroll(ScrollDirection, ScrollGranularity, float multiplier = 1);
 489     void autoscroll(const IntPoint&amp;);
 490 
 491     bool canResize() const;
 492     void resize(const PlatformMouseEvent&amp;, const LayoutSize&amp;);
 493     bool inResizeMode() const { return m_inResizeMode; }
 494     void setInResizeMode(bool b) { m_inResizeMode = b; }
 495 
 496     bool isRenderViewLayer() const { return m_isRenderViewLayer; }
 497     bool isForcedStackingContext() const { return m_forcedStackingContext; }

 498 
 499     RenderLayerCompositor&amp; compositor() const;
 500 
 501     // Notification from the renderer that its content changed (e.g. current frame of image changed).
 502     // Allows updates of layer content without repainting.
 503     void contentChanged(ContentChangeType);
 504 
 505     bool canRender3DTransforms() const;
 506 
<span class="line-modified"> 507     enum UpdateLayerPositionsFlag {</span>
<span class="line-modified"> 508         CheckForRepaint                 = 1 &lt;&lt; 0,</span>
<span class="line-removed"> 509         NeedsFullRepaintInBacking       = 1 &lt;&lt; 1,</span>
<span class="line-removed"> 510         UpdatePagination                = 1 &lt;&lt; 2,</span>
<span class="line-removed"> 511         SeenTransformedLayer            = 1 &lt;&lt; 3,</span>
<span class="line-removed"> 512         Seen3DTransformedLayer          = 1 &lt;&lt; 4,</span>
<span class="line-removed"> 513     };</span>
<span class="line-removed"> 514     static constexpr OptionSet&lt;UpdateLayerPositionsFlag&gt; updateLayerPositionsDefaultFlags() { return { CheckForRepaint }; }</span>
<span class="line-removed"> 515 </span>
<span class="line-removed"> 516     void updateLayerPositionsAfterLayout(const RenderLayer* rootLayer, OptionSet&lt;UpdateLayerPositionsFlag&gt;);</span>
 517 
 518     void updateLayerPositionsAfterOverflowScroll();
 519     void updateLayerPositionsAfterDocumentScroll();
 520 
 521     bool hasCompositedLayerInEnclosingPaginationChain() const;
 522     enum PaginationInclusionMode { ExcludeCompositedPaginatedLayers, IncludeCompositedPaginatedLayers };
 523     RenderLayer* enclosingPaginationLayer(PaginationInclusionMode mode) const
 524     {
 525         if (mode == ExcludeCompositedPaginatedLayers &amp;&amp; hasCompositedLayerInEnclosingPaginationChain())
 526             return nullptr;
 527         return m_enclosingPaginationLayer.get();
 528     }
 529 
 530     void updateTransform();
 531 
 532 #if ENABLE(CSS_COMPOSITING)
 533     void updateBlendMode();

 534 #endif
 535 
 536     const LayoutSize&amp; offsetForInFlowPosition() const { return m_offsetForInFlowPosition; }
 537 
 538     void clearClipRectsIncludingDescendants(ClipRectsType typeToClear = AllClipRectTypes);
 539     void clearClipRects(ClipRectsType typeToClear = AllClipRectTypes);
 540 
 541     void addBlockSelectionGapsBounds(const LayoutRect&amp;);
 542     void clearBlockSelectionGapsBounds();
 543     void repaintBlockSelectionGaps();
 544 
 545     // FIXME: We should ASSERT(!m_visibleContentStatusDirty) here, but see https://bugs.webkit.org/show_bug.cgi?id=71044
 546     // ditto for hasVisibleDescendant(), see https://bugs.webkit.org/show_bug.cgi?id=71277
 547     bool hasVisibleContent() const { return m_hasVisibleContent; }
 548     bool hasVisibleDescendant() const { return m_hasVisibleDescendant; }
 549 
 550     void setHasVisibleContent();
 551     void dirtyVisibleContentStatus();
 552 
 553     bool hasVisibleBoxDecorationsOrBackground() const;
 554     bool hasVisibleBoxDecorations() const;
 555 


 556     struct PaintedContentRequest {
 557         void makeStatesUndetermined()
 558         {
 559             if (hasPaintedContent == RequestState::Unknown)
 560                 hasPaintedContent = RequestState::Undetermined;
 561 
 562             if (hasSubpixelAntialiasedText == RequestState::Unknown)
 563                 hasSubpixelAntialiasedText = RequestState::Undetermined;
 564         }
 565 
 566         void setHasPaintedContent() { hasPaintedContent = RequestState::True; }
 567         void setHasSubpixelAntialiasedText() { hasSubpixelAntialiasedText = RequestState::True; }
 568 
 569         bool needToDeterminePaintedContentState() const { return hasPaintedContent == RequestState::Unknown; }
 570         bool needToDetermineSubpixelAntialiasedTextState() const { return hasSubpixelAntialiasedText == RequestState::Unknown; }
 571 
 572         bool probablyHasPaintedContent() const { return hasPaintedContent == RequestState::True || hasPaintedContent == RequestState::Undetermined; }
 573         bool probablyHasSubpixelAntialiasedText() const { return hasSubpixelAntialiasedText == RequestState::True || hasSubpixelAntialiasedText == RequestState::Undetermined; }
 574 
 575         bool isSatisfied() const { return hasPaintedContent != RequestState::Unknown &amp;&amp; hasSubpixelAntialiasedText != RequestState::Unknown; }
 576 
 577         RequestState hasPaintedContent { RequestState::Unknown };
 578         RequestState hasSubpixelAntialiasedText { RequestState::DontCare };
 579     };
 580 
 581     // Returns true if this layer has visible content (ignoring any child layers).
 582     bool isVisuallyNonEmpty(PaintedContentRequest* = nullptr) const;
 583     // True if this layer container renderers that paint.
 584     bool hasNonEmptyChildRenderers(PaintedContentRequest&amp;) const;
 585 
 586     // FIXME: We should ASSERT(!m_hasSelfPaintingLayerDescendantDirty); here but we hit the same bugs as visible content above.
 587     // Part of the issue is with subtree relayout: we don&#39;t check if our ancestors have some descendant flags dirty, missing some updates.
 588     bool hasSelfPaintingLayerDescendant() const { return m_hasSelfPaintingLayerDescendant; }
 589 


 590     // Gets the nearest enclosing positioned ancestor layer (also includes
 591     // the &lt;html&gt; layer and the root layer).
 592     RenderLayer* enclosingAncestorForPosition(PositionType) const;
 593 
 594     // Returns the nearest enclosing layer that is scrollable.
 595     RenderLayer* enclosingScrollableLayer() const;
 596 
 597     // The layer relative to which clipping rects for this layer are computed.
 598     RenderLayer* clippingRootForPainting() const;
 599 
 600     RenderLayer* enclosingOverflowClipLayer(IncludeSelfOrNot) const;
 601 
 602     // Enclosing compositing layer; if includeSelf is true, may return this.
 603     RenderLayer* enclosingCompositingLayer(IncludeSelfOrNot = IncludeSelf) const;
 604     RenderLayer* enclosingCompositingLayerForRepaint(IncludeSelfOrNot = IncludeSelf) const;
 605     // Ancestor compositing layer, excluding this.
 606     RenderLayer* ancestorCompositingLayer() const { return enclosingCompositingLayer(ExcludeSelf); }
 607 
 608     RenderLayer* enclosingFilterLayer(IncludeSelfOrNot = IncludeSelf) const;
 609     RenderLayer* enclosingFilterRepaintLayer() const;
 610     void setFilterBackendNeedsRepaintingInRect(const LayoutRect&amp;);
 611     bool hasAncestorWithFilterOutsets() const;
 612 
<span class="line-modified"> 613     bool canUseConvertToLayerCoords() const</span>
 614     {
<span class="line-modified"> 615         // These RenderObject have an impact on their layers&#39; without them knowing about it.</span>

 616         return !renderer().hasTransform() &amp;&amp; !renderer().isSVGRoot();
 617     }
 618 
 619     // FIXME: adjustForColumns allows us to position compositing layers in columns correctly, but eventually they need to be split across columns too.
 620     enum ColumnOffsetAdjustment { DontAdjustForColumns, AdjustForColumns };
 621     void convertToPixelSnappedLayerCoords(const RenderLayer* ancestorLayer, IntPoint&amp; location, ColumnOffsetAdjustment adjustForColumns = DontAdjustForColumns) const;
 622     LayoutPoint convertToLayerCoords(const RenderLayer* ancestorLayer, const LayoutPoint&amp;, ColumnOffsetAdjustment adjustForColumns = DontAdjustForColumns) const;
 623     LayoutSize offsetFromAncestor(const RenderLayer*, ColumnOffsetAdjustment = DontAdjustForColumns) const;
 624 
 625     int zIndex() const { return renderer().style().zIndex(); }
 626 
 627     enum PaintLayerFlag {
 628         PaintLayerHaveTransparency                      = 1 &lt;&lt; 0,
 629         PaintLayerAppliedTransform                      = 1 &lt;&lt; 1,
 630         PaintLayerTemporaryClipRects                    = 1 &lt;&lt; 2,
 631         PaintLayerPaintingReflection                    = 1 &lt;&lt; 3,
 632         PaintLayerPaintingOverlayScrollbars             = 1 &lt;&lt; 4,
 633         PaintLayerPaintingCompositingBackgroundPhase    = 1 &lt;&lt; 5,
 634         PaintLayerPaintingCompositingForegroundPhase    = 1 &lt;&lt; 6,
 635         PaintLayerPaintingCompositingMaskPhase          = 1 &lt;&lt; 7,
 636         PaintLayerPaintingCompositingClipPathPhase      = 1 &lt;&lt; 8,
 637         PaintLayerPaintingCompositingScrollingPhase     = 1 &lt;&lt; 9,
 638         PaintLayerPaintingOverflowContents              = 1 &lt;&lt; 10,
 639         PaintLayerPaintingRootBackgroundOnly            = 1 &lt;&lt; 11,
 640         PaintLayerPaintingSkipRootBackground            = 1 &lt;&lt; 12,
 641         PaintLayerPaintingChildClippingMaskPhase        = 1 &lt;&lt; 13,

 642     };
<span class="line-modified"> 643     static constexpr OptionSet&lt;PaintLayerFlag&gt; paintLayerPaintingCompositingAllPhasesFlags() { return { PaintLayerPaintingCompositingBackgroundPhase,  PaintLayerPaintingCompositingForegroundPhase }; }</span>
 644 
 645     enum class SecurityOriginPaintPolicy { AnyOrigin, AccessibleOriginOnly };
 646 
 647     // The two main functions that use the layer system.  The paint method
 648     // paints the layers that intersect the damage rect from back to
 649     // front.  The hitTest method looks for mouse events by walking
 650     // layers that intersect the point from front to back.
 651     void paint(GraphicsContext&amp;, const LayoutRect&amp; damageRect, const LayoutSize&amp; subpixelOffset = LayoutSize(), OptionSet&lt;PaintBehavior&gt; = PaintBehavior::Normal,
 652         RenderObject* subtreePaintRoot = nullptr, OptionSet&lt;PaintLayerFlag&gt; = { }, SecurityOriginPaintPolicy = SecurityOriginPaintPolicy::AnyOrigin);
 653     bool hitTest(const HitTestRequest&amp;, HitTestResult&amp;);
 654     bool hitTest(const HitTestRequest&amp;, const HitTestLocation&amp;, HitTestResult&amp;);
 655     void paintOverlayScrollbars(GraphicsContext&amp;, const LayoutRect&amp; damageRect, OptionSet&lt;PaintBehavior&gt;, RenderObject* subtreePaintRoot = nullptr);
 656 
 657     struct ClipRectsContext {
 658         ClipRectsContext(const RenderLayer* inRootLayer, ClipRectsType inClipRectsType, OverlayScrollbarSizeRelevancy inOverlayScrollbarSizeRelevancy = IgnoreOverlayScrollbarSize, ShouldRespectOverflowClip inRespectOverflowClip = RespectOverflowClip)
 659             : rootLayer(inRootLayer)
 660             , clipRectsType(inClipRectsType)
 661             , overlayScrollbarSizeRelevancy(inOverlayScrollbarSizeRelevancy)
 662             , respectOverflowClip(inRespectOverflowClip)
 663         { }
</pre>
<hr />
<pre>
 667         ShouldRespectOverflowClip respectOverflowClip;
 668     };
 669 
 670     // This method figures out our layerBounds in coordinates relative to
 671     // |rootLayer}.  It also computes our background and foreground clip rects
 672     // for painting/event handling.
 673     // Pass offsetFromRoot if known.
 674     void calculateRects(const ClipRectsContext&amp;, const LayoutRect&amp; paintDirtyRect, LayoutRect&amp; layerBounds,
 675         ClipRect&amp; backgroundRect, ClipRect&amp; foregroundRect, const LayoutSize&amp; offsetFromRoot) const;
 676 
 677     // Public just for RenderTreeAsText.
 678     void collectFragments(LayerFragments&amp;, const RenderLayer* rootLayer, const LayoutRect&amp; dirtyRect,
 679         PaginationInclusionMode,
 680         ClipRectsType, OverlayScrollbarSizeRelevancy inOverlayScrollbarSizeRelevancy, ShouldRespectOverflowClip, const LayoutSize&amp; offsetFromRoot,
 681         const LayoutRect* layerBoundingBox = nullptr, ShouldApplyRootOffsetToFragments = IgnoreRootOffsetForFragments);
 682 
 683     LayoutRect childrenClipRect() const; // Returns the foreground clip rect of the layer in the document&#39;s coordinate space.
 684     LayoutRect selfClipRect() const; // Returns the background clip rect of the layer in the document&#39;s coordinate space.
 685     LayoutRect localClipRect(bool&amp; clipExceedsBounds) const; // Returns the background clip rect of the layer in the local coordinate space.
 686 


 687     // Pass offsetFromRoot if known.
 688     bool intersectsDamageRect(const LayoutRect&amp; layerBounds, const LayoutRect&amp; damageRect, const RenderLayer* rootLayer, const LayoutSize&amp; offsetFromRoot, const LayoutRect* cachedBoundingBox = nullptr) const;
 689 
 690     enum CalculateLayerBoundsFlag {
 691         IncludeSelfTransform                    = 1 &lt;&lt; 0,
 692         UseLocalClipRectIfPossible              = 1 &lt;&lt; 1,
 693         IncludeFilterOutsets                    = 1 &lt;&lt; 2,
 694         IncludePaintedFilterOutsets             = 1 &lt;&lt; 3,
 695         ExcludeHiddenDescendants                = 1 &lt;&lt; 4,
 696         DontConstrainForMask                    = 1 &lt;&lt; 5,
 697         IncludeCompositedDescendants            = 1 &lt;&lt; 6,
 698         UseFragmentBoxesExcludingCompositing    = 1 &lt;&lt; 7,
 699         UseFragmentBoxesIncludingCompositing    = 1 &lt;&lt; 8,
 700     };
 701     static constexpr OptionSet&lt;CalculateLayerBoundsFlag&gt; defaultCalculateLayerBoundsFlags() { return { IncludeSelfTransform, UseLocalClipRectIfPossible, IncludePaintedFilterOutsets, UseFragmentBoxesExcludingCompositing }; }
 702 
 703     // Bounding box relative to some ancestor layer. Pass offsetFromRoot if known.
 704     LayoutRect boundingBox(const RenderLayer* rootLayer, const LayoutSize&amp; offsetFromRoot = LayoutSize(), OptionSet&lt;CalculateLayerBoundsFlag&gt; = { }) const;
 705     // Bounding box in the coordinates of this layer.
 706     LayoutRect localBoundingBox(OptionSet&lt;CalculateLayerBoundsFlag&gt; = { }) const;
</pre>
<hr />
<pre>
 740     bool adjustForIOSCaretWhenScrolling() const { return m_adjustForIOSCaretWhenScrolling; }
 741     void setAdjustForIOSCaretWhenScrolling(bool adjustForIOSCaretWhenScrolling) { m_adjustForIOSCaretWhenScrolling = adjustForIOSCaretWhenScrolling; }
 742 #endif
 743 
 744     bool hasTransform() const { return renderer().hasTransform(); }
 745     // Note that this transform has the transform-origin baked in.
 746     TransformationMatrix* transform() const { return m_transform.get(); }
 747     // currentTransform computes a transform which takes accelerated animations into account. The
 748     // resulting transform has transform-origin baked in. If the layer does not have a transform,
 749     // returns the identity matrix.
 750     TransformationMatrix currentTransform(RenderStyle::ApplyTransformOrigin = RenderStyle::IncludeTransformOrigin) const;
 751     TransformationMatrix renderableTransform(OptionSet&lt;PaintBehavior&gt;) const;
 752 
 753     // Get the perspective transform, which is applied to transformed sublayers.
 754     // Returns true if the layer has a -webkit-perspective.
 755     // Note that this transform has the perspective-origin baked in.
 756     TransformationMatrix perspectiveTransform() const;
 757     FloatPoint perspectiveOrigin() const;
 758     bool preserves3D() const { return renderer().style().transformStyle3D() == TransformStyle3D::Preserve3D; }
 759     bool has3DTransform() const { return m_transform &amp;&amp; !m_transform-&gt;isAffine(); }

 760 
 761     void filterNeedsRepaint();
 762     bool hasFilter() const { return renderer().hasFilter(); }
 763     bool hasBackdropFilter() const
 764     {
 765 #if ENABLE(FILTERS_LEVEL_2)
 766         return renderer().hasBackdropFilter();
 767 #else
 768         return false;
 769 #endif
 770     }
 771 
 772 #if ENABLE(CSS_COMPOSITING)
 773     bool hasBlendMode() const { return renderer().hasBlendMode(); }
 774     BlendMode blendMode() const { return static_cast&lt;BlendMode&gt;(m_blendMode); }
 775 
<span class="line-modified"> 776     bool isolatesCompositedBlending() const { return m_hasNotIsolatedCompositedBlendingDescendants &amp;&amp; isStackingContext(); }</span>
 777     bool hasNotIsolatedCompositedBlendingDescendants() const { return m_hasNotIsolatedCompositedBlendingDescendants; }
 778     void setHasNotIsolatedCompositedBlendingDescendants(bool hasNotIsolatedCompositedBlendingDescendants)
 779     {
 780         m_hasNotIsolatedCompositedBlendingDescendants = hasNotIsolatedCompositedBlendingDescendants;
 781     }
 782 
<span class="line-modified"> 783     bool isolatesBlending() const { return hasNotIsolatedBlendingDescendants() &amp;&amp; isStackingContext(); }</span>
 784 
 785     // FIXME: We should ASSERT(!m_hasNotIsolatedBlendingDescendantsStatusDirty); here but we hit the same bugs as visible content above.
 786     bool hasNotIsolatedBlendingDescendants() const { return m_hasNotIsolatedBlendingDescendants; }
 787     bool hasNotIsolatedBlendingDescendantsStatusDirty() const { return m_hasNotIsolatedBlendingDescendantsStatusDirty; }
 788 #else
 789     bool hasBlendMode() const { return false; }
 790     bool isolatesCompositedBlending() const { return false; }
 791     bool isolatesBlending() const { return false; }
 792     bool hasNotIsolatedBlendingDescendantsStatusDirty() const { return false; }
 793 #endif
 794 
 795     bool isComposited() const { return m_backing != nullptr; }
 796     bool hasCompositingDescendant() const { return m_hasCompositingDescendant; }
 797     bool hasCompositedMask() const;
 798 







 799     RenderLayerBacking* backing() const { return m_backing.get(); }
 800     RenderLayerBacking* ensureBacking();
 801     void clearBacking(bool layerBeingDestroyed = false);
 802 
 803     GraphicsLayer* layerForHorizontalScrollbar() const override;
 804     GraphicsLayer* layerForVerticalScrollbar() const override;
 805     GraphicsLayer* layerForScrollCorner() const override;
 806 
 807     bool usesCompositedScrolling() const override;
 808     bool usesAsyncScrolling() const override;
 809 



 810     bool paintsWithTransparency(OptionSet&lt;PaintBehavior&gt; paintBehavior) const
 811     {
 812         return (isTransparent() || hasBlendMode() || (isolatesBlending() &amp;&amp; !renderer().isDocumentElementRenderer())) &amp;&amp; ((paintBehavior &amp; PaintBehavior::FlattenCompositingLayers) || !isComposited());
 813     }
 814 
 815     bool paintsWithTransform(OptionSet&lt;PaintBehavior&gt;) const;
 816     bool shouldPaintMask(OptionSet&lt;PaintBehavior&gt;, OptionSet&lt;PaintLayerFlag&gt;) const;
 817     bool shouldApplyClipPath(OptionSet&lt;PaintBehavior&gt;, OptionSet&lt;PaintLayerFlag&gt;) const;
 818 
 819     // Returns true if background phase is painted opaque in the given rect.
 820     // The query rect is given in local coordinates.
 821     bool backgroundIsKnownToBeOpaqueInRect(const LayoutRect&amp;) const;
 822 
 823     bool scrollingMayRevealBackground() const;
 824 
 825     bool containsDirtyOverlayScrollbars() const { return m_containsDirtyOverlayScrollbars; }
 826     void setContainsDirtyOverlayScrollbars(bool dirtyScrollbars) { m_containsDirtyOverlayScrollbars = dirtyScrollbars; }
 827 
 828     bool paintsWithFilters() const;
 829     bool requiresFullLayerImageForFilters() const;
 830 
 831     Element* enclosingElement() const;
 832 
 833     enum ViewportConstrainedNotCompositedReason {
 834         NoNotCompositedReason,
 835         NotCompositedForBoundsOutOfView,
 836         NotCompositedForNonViewContainer,
 837         NotCompositedForNoVisibleContent,
 838     };
 839 
 840     void setViewportConstrainedNotCompositedReason(ViewportConstrainedNotCompositedReason reason) { m_viewportConstrainedNotCompositedReason = reason; }
 841     ViewportConstrainedNotCompositedReason viewportConstrainedNotCompositedReason() const { return static_cast&lt;ViewportConstrainedNotCompositedReason&gt;(m_viewportConstrainedNotCompositedReason); }
 842 


 843     bool isRenderFragmentedFlow() const { return renderer().isRenderFragmentedFlow(); }
 844     bool isOutOfFlowRenderFragmentedFlow() const { return renderer().isOutOfFlowRenderFragmentedFlow(); }
 845     bool isInsideFragmentedFlow() const { return renderer().fragmentedFlowState() != RenderObject::NotInsideFragmentedFlow; }
 846     bool isDirtyRenderFragmentedFlow() const
 847     {
 848         ASSERT(isRenderFragmentedFlow());
 849         return zOrderListsDirty() || normalFlowListDirty();
 850     }
 851 
 852     RenderLayer* enclosingFragmentedFlowAncestor() const;
 853 
 854     bool shouldPlaceBlockDirectionScrollbarOnLeft() const final { return renderer().shouldPlaceBlockDirectionScrollbarOnLeft(); }
 855 
 856     void simulateFrequentPaint() { SinglePaintFrequencyTracking { m_paintFrequencyTracker }; }
 857     bool paintingFrequently() const { return m_paintFrequencyTracker.paintingFrequently(); }
 858 




 859 private:
 860 
 861     void setNextSibling(RenderLayer* next) { m_next = next; }
 862     void setPreviousSibling(RenderLayer* prev) { m_previous = prev; }
 863     void setParent(RenderLayer*);
 864     void setFirstChild(RenderLayer* first) { m_first = first; }
 865     void setLastChild(RenderLayer* last) { m_last = last; }
 866 
 867     void dirtyPaintOrderListsOnChildChange(RenderLayer&amp;);
 868 
 869     bool shouldBeNormalFlowOnly() const;
<span class="line-modified"> 870     bool shouldBeStackingContext() const;</span>
 871 
 872     // Return true if changed.
 873     bool setIsNormalFlowOnly(bool);
<span class="line-modified"> 874     bool setIsStackingContext(bool);</span>




 875 
 876     bool isDirtyStackingContext() const { return m_zOrderListsDirty &amp;&amp; isStackingContext(); }
 877 
 878     void updateZOrderLists();
 879     void rebuildZOrderLists();
 880     void rebuildZOrderLists(std::unique_ptr&lt;Vector&lt;RenderLayer*&gt;&gt;&amp;, std::unique_ptr&lt;Vector&lt;RenderLayer*&gt;&gt;&amp;);
 881     void collectLayers(bool includeHiddenLayers, std::unique_ptr&lt;Vector&lt;RenderLayer*&gt;&gt;&amp;, std::unique_ptr&lt;Vector&lt;RenderLayer*&gt;&gt;&amp;);
 882     void clearZOrderLists();
 883 
 884     void updateNormalFlowList();
 885 
 886     struct LayerPaintingInfo {
 887         LayerPaintingInfo(RenderLayer* inRootLayer, const LayoutRect&amp; inDirtyRect, OptionSet&lt;PaintBehavior&gt; inPaintBehavior, const LayoutSize&amp; inSubpixelOffset, RenderObject* inSubtreePaintRoot = nullptr, OverlapTestRequestMap* inOverlapTestRequests = nullptr, bool inRequireSecurityOriginAccessForWidgets = false)
 888             : rootLayer(inRootLayer)
 889             , subtreePaintRoot(inSubtreePaintRoot)
 890             , paintDirtyRect(inDirtyRect)
 891             , subpixelOffset(inSubpixelOffset)
 892             , overlapTestRequests(inOverlapTestRequests)
 893             , paintBehavior(inPaintBehavior)
 894             , requireSecurityOriginAccessForWidgets(inRequireSecurityOriginAccessForWidgets)
 895         { }
 896 
 897         RenderLayer* rootLayer;
 898         RenderObject* subtreePaintRoot; // Only paint descendants of this object.
 899         LayoutRect paintDirtyRect; // Relative to rootLayer;
 900         LayoutSize subpixelOffset;
 901         OverlapTestRequestMap* overlapTestRequests; // May be null.
 902         OptionSet&lt;PaintBehavior&gt; paintBehavior;
 903         bool requireSecurityOriginAccessForWidgets;
 904         bool clipToDirtyRect { true };

 905     };
 906 
 907     // Compute, cache and return clip rects computed with the given layer as the root.
 908     Ref&lt;ClipRects&gt; updateClipRects(const ClipRectsContext&amp;);
 909     // Compute and return the clip rects. If useCached is true, will used previously computed clip rects on ancestors
 910     // (rather than computing them all from scratch up the parent chain).
 911     void calculateClipRects(const ClipRectsContext&amp;, ClipRects&amp;) const;
 912     ClipRects* clipRects(const ClipRectsContext&amp;) const;
 913 
 914     void setAncestorChainHasSelfPaintingLayerDescendant();
 915     void dirtyAncestorChainHasSelfPaintingLayerDescendantStatus();
 916 
 917     void computeRepaintRects(const RenderLayerModelObject* repaintContainer, const RenderGeometryMap* = nullptr);
 918     void computeRepaintRectsIncludingDescendants();
 919     void clearRepaintRects();
 920 
 921     LayoutRect clipRectRelativeToAncestor(RenderLayer* ancestor, LayoutSize offsetFromAncestor, const LayoutRect&amp; constrainingRect) const;
 922 
 923     void clipToRect(GraphicsContext&amp;, const LayerPaintingInfo&amp;, const ClipRect&amp;, BorderRadiusClippingRule = IncludeSelfForBorderRadius);
 924     void restoreClip(GraphicsContext&amp;, const LayerPaintingInfo&amp;, const ClipRect&amp;);
 925 
 926     bool shouldRepaintAfterLayout() const;
 927 
 928     void updateSelfPaintingLayer();
 929 
 930     void updateScrollbarsAfterStyleChange(const RenderStyle* oldStyle);
 931     void updateScrollbarsAfterLayout();
 932 












 933     // Returns true if the position changed.
<span class="line-modified"> 934     bool updateLayerPosition();</span>
 935 
<span class="line-modified"> 936     void updateLayerPositions(RenderGeometryMap* = nullptr, OptionSet&lt;UpdateLayerPositionsFlag&gt; = updateLayerPositionsDefaultFlags());</span>
 937 
 938     enum UpdateLayerPositionsAfterScrollFlag {
 939         IsOverflowScroll                        = 1 &lt;&lt; 0,
 940         HasSeenViewportConstrainedAncestor      = 1 &lt;&lt; 1,
 941         HasSeenAncestorWithOverflowClip         = 1 &lt;&lt; 2,
 942         HasChangedAncestor                      = 1 &lt;&lt; 3,
 943     };
 944     void updateLayerPositionsAfterScroll(RenderGeometryMap*, OptionSet&lt;UpdateLayerPositionsAfterScrollFlag&gt; = { });
 945 
 946     ScrollOffset clampScrollOffset(const ScrollOffset&amp;) const;
 947 
 948     RenderLayer* enclosingPaginationLayerInSubtree(const RenderLayer* rootLayer, PaginationInclusionMode) const;
 949 
 950     LayoutPoint renderBoxLocation() const { return is&lt;RenderBox&gt;(renderer()) ? downcast&lt;RenderBox&gt;(renderer()).location() : LayoutPoint(); }
 951 
 952     bool setupFontSubpixelQuantization(GraphicsContext&amp;, bool&amp; didQuantizeFonts);
 953 
 954     Path computeClipPath(const LayoutSize&amp; offsetFromRoot, LayoutRect&amp; rootRelativeBounds, WindRule&amp;) const;
 955 
 956     bool setupClipPath(GraphicsContext&amp;, const LayerPaintingInfo&amp;, const LayoutSize&amp; offsetFromRoot, LayoutRect&amp; rootRelativeBounds, bool&amp; rootRelativeBoundsComputed);
 957 
 958     void ensureLayerFilters();
 959     void clearLayerFilters();
 960 
 961     RenderLayerFilters* filtersForPainting(GraphicsContext&amp;, OptionSet&lt;PaintLayerFlag&gt;) const;
 962     GraphicsContext* setupFilters(GraphicsContext&amp; destinationContext, LayerPaintingInfo&amp;, OptionSet&lt;PaintLayerFlag&gt;, const LayoutSize&amp; offsetFromRoot, LayoutRect&amp; rootRelativeBounds, bool&amp; rootRelativeBoundsComputed);
 963     void applyFilters(GraphicsContext&amp; originalContext, const LayerPaintingInfo&amp;, const LayerFragments&amp;);
 964 
 965     void paintLayer(GraphicsContext&amp;, const LayerPaintingInfo&amp;, OptionSet&lt;PaintLayerFlag&gt;);


 966     void paintLayerContentsAndReflection(GraphicsContext&amp;, const LayerPaintingInfo&amp;, OptionSet&lt;PaintLayerFlag&gt;);
 967     void paintLayerByApplyingTransform(GraphicsContext&amp;, const LayerPaintingInfo&amp;, OptionSet&lt;PaintLayerFlag&gt;, const LayoutSize&amp; translationOffset = LayoutSize());
 968     void paintLayerContents(GraphicsContext&amp;, const LayerPaintingInfo&amp;, OptionSet&lt;PaintLayerFlag&gt;);
 969     void paintList(LayerList, GraphicsContext&amp;, const LayerPaintingInfo&amp;, OptionSet&lt;PaintLayerFlag&gt;);
 970 
 971     void updatePaintingInfoForFragments(LayerFragments&amp;, const LayerPaintingInfo&amp;, OptionSet&lt;PaintLayerFlag&gt;, bool shouldPaintContent, const LayoutSize&amp; offsetFromRoot);
 972     void paintBackgroundForFragments(const LayerFragments&amp;, GraphicsContext&amp;, GraphicsContext&amp; transparencyLayerContext,
 973         const LayoutRect&amp; transparencyPaintDirtyRect, bool haveTransparency, const LayerPaintingInfo&amp;, OptionSet&lt;PaintBehavior&gt;, RenderObject* paintingRootForRenderer);
 974     void paintForegroundForFragments(const LayerFragments&amp;, GraphicsContext&amp;, GraphicsContext&amp; transparencyLayerContext,
 975         const LayoutRect&amp; transparencyPaintDirtyRect, bool haveTransparency, const LayerPaintingInfo&amp;, OptionSet&lt;PaintBehavior&gt;, RenderObject* paintingRootForRenderer);
 976     void paintForegroundForFragmentsWithPhase(PaintPhase, const LayerFragments&amp;, GraphicsContext&amp;, const LayerPaintingInfo&amp;, OptionSet&lt;PaintBehavior&gt;, RenderObject* paintingRootForRenderer);
 977     void paintOutlineForFragments(const LayerFragments&amp;, GraphicsContext&amp;, const LayerPaintingInfo&amp;, OptionSet&lt;PaintBehavior&gt;, RenderObject* paintingRootForRenderer);
 978     void paintOverflowControlsForFragments(const LayerFragments&amp;, GraphicsContext&amp;, const LayerPaintingInfo&amp;);
 979     void paintMaskForFragments(const LayerFragments&amp;, GraphicsContext&amp;, const LayerPaintingInfo&amp;, OptionSet&lt;PaintBehavior&gt;, RenderObject* paintingRootForRenderer);
 980     void paintChildClippingMaskForFragments(const LayerFragments&amp;, GraphicsContext&amp;, const LayerPaintingInfo&amp;, OptionSet&lt;PaintBehavior&gt;, RenderObject* paintingRootForRenderer);
 981     void paintTransformedLayerIntoFragments(GraphicsContext&amp;, const LayerPaintingInfo&amp;, OptionSet&lt;PaintLayerFlag&gt;);

 982 
 983     RenderLayer* transparentPaintingAncestor();
 984     void beginTransparencyLayers(GraphicsContext&amp;, const LayerPaintingInfo&amp;, const LayoutRect&amp; dirtyRect);
 985 
 986     RenderLayer* hitTestLayer(RenderLayer* rootLayer, RenderLayer* containerLayer, const HitTestRequest&amp;, HitTestResult&amp;,
 987         const LayoutRect&amp; hitTestRect, const HitTestLocation&amp;, bool appliedTransform,
 988         const HitTestingTransformState* = nullptr, double* zOffset = nullptr);
 989     RenderLayer* hitTestLayerByApplyingTransform(RenderLayer* rootLayer, RenderLayer* containerLayer, const HitTestRequest&amp;, HitTestResult&amp;,
 990         const LayoutRect&amp; hitTestRect, const HitTestLocation&amp;, const HitTestingTransformState* = nullptr, double* zOffset = nullptr,
 991         const LayoutSize&amp; translationOffset = LayoutSize());
 992     RenderLayer* hitTestList(LayerList, RenderLayer* rootLayer, const HitTestRequest&amp;, HitTestResult&amp;,
 993         const LayoutRect&amp; hitTestRect, const HitTestLocation&amp;,
 994         const HitTestingTransformState*, double* zOffsetForDescendants, double* zOffset,
 995         const HitTestingTransformState* unflattenedTransformState, bool depthSortDescendants);
 996 
 997     Ref&lt;HitTestingTransformState&gt; createLocalTransformState(RenderLayer* rootLayer, RenderLayer* containerLayer,
 998         const LayoutRect&amp; hitTestRect, const HitTestLocation&amp;,
 999         const HitTestingTransformState* containerTransformState,
1000         const LayoutSize&amp; translationOffset = LayoutSize()) const;
1001 
1002     bool hitTestContents(const HitTestRequest&amp;, HitTestResult&amp;, const LayoutRect&amp; layerBounds, const HitTestLocation&amp;, HitTestFilter) const;
1003     bool hitTestContentsForFragments(const LayerFragments&amp;, const HitTestRequest&amp;, HitTestResult&amp;, const HitTestLocation&amp;, HitTestFilter, bool&amp; insideClipRect) const;
1004     bool hitTestResizerInFragments(const LayerFragments&amp;, const HitTestLocation&amp;) const;
1005     RenderLayer* hitTestTransformedLayerInFragments(RenderLayer* rootLayer, RenderLayer* containerLayer, const HitTestRequest&amp;, HitTestResult&amp;,
1006         const LayoutRect&amp; hitTestRect, const HitTestLocation&amp;, const HitTestingTransformState* = nullptr, double* zOffset = nullptr);
1007 
1008     bool listBackgroundIsKnownToBeOpaqueInRect(const LayerList&amp;, const LayoutRect&amp;) const;
1009 
1010     void computeScrollDimensions();
1011     bool hasHorizontalOverflow() const;
1012     bool hasVerticalOverflow() const;
<span class="line-removed">1013     bool hasScrollableHorizontalOverflow() const;</span>
<span class="line-removed">1014     bool hasScrollableVerticalOverflow() const;</span>
1015 
1016     bool showsOverflowControls() const;
1017 
1018     bool shouldBeSelfPaintingLayer() const;
1019 
<span class="line-removed">1020     int scrollOffset(ScrollbarOrientation) const override;</span>
<span class="line-removed">1021 </span>
1022     // ScrollableArea interface
1023     void invalidateScrollbarRect(Scrollbar&amp;, const IntRect&amp;) override;
1024     void invalidateScrollCornerRect(const IntRect&amp;) override;
1025     bool isActive() const override;
1026     bool isScrollCornerVisible() const override;
1027     IntRect scrollCornerRect() const override;
1028     IntRect convertFromScrollbarToContainingView(const Scrollbar&amp;, const IntRect&amp;) const override;
1029     IntRect convertFromContainingViewToScrollbar(const Scrollbar&amp;, const IntRect&amp;) const override;
1030     IntPoint convertFromScrollbarToContainingView(const Scrollbar&amp;, const IntPoint&amp;) const override;
1031     IntPoint convertFromContainingViewToScrollbar(const Scrollbar&amp;, const IntPoint&amp;) const override;
<span class="line-removed">1032     int scrollSize(ScrollbarOrientation) const override;</span>
1033     void setScrollOffset(const ScrollOffset&amp;) override;

1034 
1035     IntRect visibleContentRectInternal(VisibleContentRectIncludesScrollbars, VisibleContentRectBehavior) const override;
1036     IntSize overhangAmount() const override;
1037     IntPoint lastKnownMousePosition() const override;
1038     bool isHandlingWheelEvent() const override;
1039     bool shouldSuspendScrollAnimations() const override;
1040     IntRect scrollableAreaBoundingBox(bool* isInsideFixed = nullptr) const override;
1041     bool isRubberBandInProgress() const override;
1042     bool forceUpdateScrollbarsOnMainThreadForPerformanceTesting() const override;
1043 #if ENABLE(CSS_SCROLL_SNAP)
1044     bool isScrollSnapInProgress() const override;
1045 #endif
1046     bool usesMockScrollAnimator() const override;
1047     void logMockScrollAnimatorMessage(const String&amp;) const override;
1048 
1049 #if ENABLE(IOS_TOUCH_EVENTS)
1050     void registerAsTouchEventListenerForScrolling();
1051     void unregisterAsTouchEventListenerForScrolling();
1052 #endif
1053 
1054     // Rectangle encompassing the scroll corner and resizer rect.
1055     LayoutRect scrollCornerAndResizerRect() const;
1056 
1057     // NOTE: This should only be called by the overridden setScrollOffset from ScrollableArea.
1058     void scrollTo(const ScrollPosition&amp;);
1059     void updateCompositingLayersAfterScroll();
1060 
1061     IntSize scrollbarOffset(const Scrollbar&amp;) const;
1062 
1063     void updateScrollableAreaSet(bool hasOverflow);
1064 
1065     bool allowsCurrentScroll() const;
1066 
1067     void dirtyAncestorChainVisibleDescendantStatus();
1068     void setAncestorChainHasVisibleDescendant();
1069 
1070     bool has3DTransformedDescendant() const { return m_has3DTransformedDescendant; }
<span class="line-removed">1071 </span>
<span class="line-removed">1072     bool hasTransformedAncestor() const { return m_hasTransformedAncestor; }</span>
1073     bool has3DTransformedAncestor() const { return m_has3DTransformedAncestor; }
1074 
1075     void dirty3DTransformedDescendantStatus();
1076     // Both updates the status, and returns true if descendants of this have 3d.
1077     bool update3DTransformedDescendantStatus();
1078 
1079     void createReflection();
1080     void removeReflection();
1081 
1082     RenderStyle createReflectionStyle();
1083     bool paintingInsideReflection() const { return m_paintingInsideReflection; }
1084     void setPaintingInsideReflection(bool b) { m_paintingInsideReflection = b; }
1085 
1086     void updateFiltersAfterStyleChange();
1087     void updateFilterPaintingStrategy();
1088 
1089 #if ENABLE(CSS_COMPOSITING)
1090     void updateAncestorChainHasBlendingDescendants();
1091     void dirtyAncestorChainHasBlendingDescendants();
1092 #endif
</pre>
<hr />
<pre>
1096 
1097     RenderLayer* enclosingTransformedAncestor() const;
1098 
1099     LayoutRect getRectToExpose(const LayoutRect&amp; visibleRect, const LayoutRect&amp; exposeRect, bool insideFixed, const ScrollAlignment&amp; alignX, const ScrollAlignment&amp; alignY) const;
1100 
1101     // Convert a point in absolute coords into layer coords, taking transforms into account
1102     LayoutPoint absoluteToContents(const LayoutPoint&amp;) const;
1103 
1104     void positionOverflowControls(const IntSize&amp;);
1105     void updateScrollCornerStyle();
1106     void clearScrollCorner();
1107     void updateResizerStyle();
1108     void clearResizer();
1109 
1110     void drawPlatformResizerImage(GraphicsContext&amp;, const LayoutRect&amp; resizerCornerRect);
1111 
1112     void updatePagination();
1113 
1114     void setHasCompositingDescendant(bool b)  { m_hasCompositingDescendant = b; }
1115 
<span class="line-removed">1116     enum class IndirectCompositingReason {</span>
<span class="line-removed">1117         None,</span>
<span class="line-removed">1118         Stacking,</span>
<span class="line-removed">1119         Overlap,</span>
<span class="line-removed">1120         BackgroundLayer,</span>
<span class="line-removed">1121         GraphicalEffect, // opacity, mask, filter, transform etc.</span>
<span class="line-removed">1122         Perspective,</span>
<span class="line-removed">1123         Preserve3D</span>
<span class="line-removed">1124     };</span>
<span class="line-removed">1125 </span>
1126     void setIndirectCompositingReason(IndirectCompositingReason reason) { m_indirectCompositingReason = static_cast&lt;unsigned&gt;(reason); }
<span class="line-removed">1127     IndirectCompositingReason indirectCompositingReason() const { return static_cast&lt;IndirectCompositingReason&gt;(m_indirectCompositingReason); }</span>
1128     bool mustCompositeForIndirectReasons() const { return m_indirectCompositingReason; }
1129 
<span class="line-removed">1130     friend class RenderLayerBacking;</span>
<span class="line-removed">1131     friend class RenderLayerCompositor;</span>
<span class="line-removed">1132     friend class RenderLayerModelObject;</span>
<span class="line-removed">1133 </span>
1134     LayoutUnit overflowTop() const;
1135     LayoutUnit overflowBottom() const;
1136     LayoutUnit overflowLeft() const;
1137     LayoutUnit overflowRight() const;
1138 
1139     IntRect rectForHorizontalScrollbar(const IntRect&amp; borderBoxRect) const;
1140     IntRect rectForVerticalScrollbar(const IntRect&amp; borderBoxRect) const;
1141 
1142     LayoutUnit verticalScrollbarStart(int minX, int maxX) const;
1143     LayoutUnit horizontalScrollbarStart(int minX) const;
1144 
1145     bool overflowControlsIntersectRect(const IntRect&amp; localRect) const;
1146 
1147     OptionSet&lt;Compositing&gt; m_compositingDirtyBits;
1148 
1149     const bool m_isRenderViewLayer : 1;
1150     const bool m_forcedStackingContext : 1;
1151 
1152     bool m_isNormalFlowOnly : 1;
<span class="line-modified">1153     bool m_isStackingContext : 1;</span>

1154 
1155     bool m_zOrderListsDirty : 1;
1156     bool m_normalFlowListDirty: 1;
1157     bool m_hadNegativeZOrderList : 1;
1158 
1159     // Keeps track of whether the layer is currently resizing, so events can cause resizing to start and stop.
1160     bool m_inResizeMode : 1;
1161 
1162     bool m_scrollDimensionsDirty : 1;
1163     bool m_isSelfPaintingLayer : 1;
1164 
1165     // If have no self-painting descendants, we don&#39;t have to walk our children during painting. This can lead to
1166     // significant savings, especially if the tree has lots of non-self-painting layers grouped together (e.g. table cells).
1167     bool m_hasSelfPaintingLayerDescendant : 1;
1168     bool m_hasSelfPaintingLayerDescendantDirty : 1;
1169 
1170     bool m_usedTransparency : 1; // Tracks whether we need to close a transparent layer, i.e., whether
1171                                  // we ended up painting this layer or any descendants (and therefore need to
1172                                  // blend).
1173     bool m_paintingInsideReflection : 1;  // A state bit tracking if we are painting inside a replica.
1174     bool m_inOverflowRelayout : 1;
1175     unsigned m_repaintStatus : 2; // RepaintStatus
1176 
1177     bool m_visibleContentStatusDirty : 1;
1178     bool m_hasVisibleContent : 1;
1179     bool m_visibleDescendantStatusDirty : 1;
1180     bool m_hasVisibleDescendant : 1;
1181     bool m_registeredScrollableArea : 1;
1182     bool m_isFixedIntersectingViewport : 1;

1183 
1184     bool m_3DTransformedDescendantStatusDirty : 1;
1185     bool m_has3DTransformedDescendant : 1;  // Set on a stacking context layer that has 3D descendants anywhere
1186                                             // in a preserves3D hierarchy. Hint to do 3D-aware hit testing.
1187     bool m_hasCompositingDescendant : 1; // In the z-order tree.
1188 



1189     bool m_hasTransformedAncestor : 1;
1190     bool m_has3DTransformedAncestor : 1;
1191 
1192     unsigned m_indirectCompositingReason : 3;
1193     unsigned m_viewportConstrainedNotCompositedReason : 2;
1194 
1195 #if PLATFORM(IOS_FAMILY)
1196 #if ENABLE(IOS_TOUCH_EVENTS)
1197     bool m_registeredAsTouchEventListenerForScrolling : 1;
1198 #endif
1199     bool m_adjustForIOSCaretWhenScrolling : 1;
1200 #endif
1201 
<span class="line-removed">1202     bool m_inUserScroll : 1;</span>
1203     bool m_requiresScrollPositionReconciliation : 1;
1204     bool m_containsDirtyOverlayScrollbars : 1;
1205     bool m_updatingMarqueePosition : 1;
1206 
1207 #if !ASSERT_DISABLED
1208     bool m_layerListMutationAllowed : 1;
1209 #endif
1210 
1211 #if ENABLE(CSS_COMPOSITING)
1212     unsigned m_blendMode : 5;
1213     bool m_hasNotIsolatedCompositedBlendingDescendants : 1;
1214     bool m_hasNotIsolatedBlendingDescendants : 1;
1215     bool m_hasNotIsolatedBlendingDescendantsStatusDirty : 1;
1216 #endif
1217 
1218     RenderLayerModelObject&amp; m_renderer;
1219 
1220     RenderLayer* m_parent { nullptr };
1221     RenderLayer* m_previous { nullptr };
1222     RenderLayer* m_next { nullptr };
1223     RenderLayer* m_first { nullptr };
1224     RenderLayer* m_last { nullptr };
1225 


1226     // For layers that establish stacking contexts, m_posZOrderList holds a sorted list of all the
1227     // descendant layers within the stacking context that have z-indices of 0 or greater
1228     // (auto will count as 0). m_negZOrderList holds descendants within our stacking context with negative
1229     // z-indices.
1230     std::unique_ptr&lt;Vector&lt;RenderLayer*&gt;&gt; m_posZOrderList;
1231     std::unique_ptr&lt;Vector&lt;RenderLayer*&gt;&gt; m_negZOrderList;
1232 
1233     // This list contains child layers that cannot create stacking contexts and appear in normal flow order.
1234     std::unique_ptr&lt;Vector&lt;RenderLayer*&gt;&gt; m_normalFlowList;
1235 
1236     // Our current relative position offset.
1237     LayoutSize m_offsetForInFlowPosition;
1238 
1239     // Our (x,y) coordinates are in our parent layer&#39;s coordinate space.
1240     LayoutPoint m_topLeft;
1241 
1242     // The layer&#39;s width/height
1243     IntSize m_layerSize;
1244 
1245     ScrollPosition m_scrollPosition;
</pre>
<hr />
<pre>
1318         , m_previousMutationAllowedState(layer.layerListMutationAllowed())
1319     {
1320         m_layer.setLayerListMutationAllowed(false);
1321     }
1322 
1323     ~LayerListMutationDetector()
1324     {
1325         m_layer.setLayerListMutationAllowed(m_previousMutationAllowedState);
1326     }
1327 
1328 private:
1329     RenderLayer&amp; m_layer;
1330     bool m_previousMutationAllowedState;
1331 };
1332 #endif
1333 
1334 void makeMatrixRenderable(TransformationMatrix&amp;, bool has3DRendering);
1335 
1336 bool compositedWithOwnBackingStore(const RenderLayer&amp;);
1337 

1338 WTF::TextStream&amp; operator&lt;&lt;(WTF::TextStream&amp;, const RenderLayer&amp;);


1339 
1340 } // namespace WebCore
1341 
1342 #if ENABLE(TREE_DEBUGGING)
1343 // Outside the WebCore namespace for ease of invocation from lldb.
1344 void showLayerTree(const WebCore::RenderLayer*);
1345 void showPaintOrderTree(const WebCore::RenderLayer*);
1346 void showLayerTree(const WebCore::RenderObject*);
1347 #endif
</pre>
</td>
<td>
<hr />
<pre>
  46 #include &quot;ClipRect.h&quot;
  47 #include &quot;GraphicsLayer.h&quot;
  48 #include &quot;LayerFragment.h&quot;
  49 #include &quot;PaintFrequencyTracker.h&quot;
  50 #include &quot;PaintInfo.h&quot;
  51 #include &quot;RenderBox.h&quot;
  52 #include &quot;RenderPtr.h&quot;
  53 #include &quot;ScrollableArea.h&quot;
  54 #include &lt;memory&gt;
  55 #include &lt;wtf/WeakPtr.h&gt;
  56 
  57 namespace WTF {
  58 class TextStream;
  59 }
  60 
  61 namespace WebCore {
  62 
  63 class CSSFilter;
  64 class ClipRects;
  65 class ClipRectsCache;
<span class="line-added">  66 class EventRegionContext;</span>
  67 class HitTestRequest;
  68 class HitTestResult;
  69 class HitTestingTransformState;
<span class="line-added">  70 class Region;</span>
  71 class RenderFragmentedFlow;
  72 class RenderGeometryMap;
  73 class RenderLayerBacking;
  74 class RenderLayerCompositor;
  75 class RenderLayerFilters;
  76 class RenderMarquee;
  77 class RenderReplica;
  78 class RenderScrollbarPart;
  79 class RenderStyle;
  80 class RenderView;
  81 class Scrollbar;
  82 class TransformationMatrix;
  83 
  84 enum BorderRadiusClippingRule { IncludeSelfForBorderRadius, DoNotIncludeSelfForBorderRadius };
  85 enum IncludeSelfOrNot { IncludeSelf, ExcludeSelf };
  86 
  87 enum RepaintStatus {
  88     NeedsNormalRepaint,
  89     NeedsFullRepaint,
  90     NeedsFullRepaintForPositionedMovementLayout
</pre>
<hr />
<pre>
 100 };
 101 
 102 enum ShouldRespectOverflowClip {
 103     IgnoreOverflowClip,
 104     RespectOverflowClip
 105 };
 106 
 107 enum ShouldApplyRootOffsetToFragments {
 108     ApplyRootOffsetToFragments,
 109     IgnoreRootOffsetForFragments
 110 };
 111 
 112 enum class RequestState {
 113     Unknown,
 114     DontCare,
 115     False,
 116     True,
 117     Undetermined
 118 };
 119 
<span class="line-added"> 120 enum class IndirectCompositingReason {</span>
<span class="line-added"> 121     None,</span>
<span class="line-added"> 122     Stacking,</span>
<span class="line-added"> 123     OverflowScrollPositioning,</span>
<span class="line-added"> 124     Overlap,</span>
<span class="line-added"> 125     BackgroundLayer,</span>
<span class="line-added"> 126     GraphicalEffect, // opacity, mask, filter, transform etc.</span>
<span class="line-added"> 127     Perspective,</span>
<span class="line-added"> 128     Preserve3D</span>
<span class="line-added"> 129 };</span>
<span class="line-added"> 130 </span>
 131 struct ScrollRectToVisibleOptions {
 132     SelectionRevealMode revealMode { SelectionRevealMode::Reveal };
 133     const ScrollAlignment&amp; alignX { ScrollAlignment::alignCenterIfNeeded };
 134     const ScrollAlignment&amp; alignY { ScrollAlignment::alignCenterIfNeeded };
 135     ShouldAllowCrossOriginScrolling shouldAllowCrossOriginScrolling { ShouldAllowCrossOriginScrolling::No };
 136 };
 137 
 138 class RenderLayer final : public ScrollableArea {
 139     WTF_MAKE_FAST_ALLOCATED;
 140 public:
 141     friend class RenderReplica;
 142     friend class RenderLayerFilters;
<span class="line-added"> 143     friend class RenderLayerBacking;</span>
<span class="line-added"> 144     friend class RenderLayerCompositor;</span>
 145 
 146     explicit RenderLayer(RenderLayerModelObject&amp;);
 147     virtual ~RenderLayer();
 148 
 149 #if PLATFORM(IOS_FAMILY)
 150     // Called before the renderer&#39;s widget (if any) has been nulled out.
 151     void willBeDestroyed();
 152 #endif
 153     String name() const;
 154 
 155     Page&amp; page() const { return renderer().page(); }
 156     RenderLayerModelObject&amp; renderer() const { return m_renderer; }
 157     RenderBox* renderBox() const { return is&lt;RenderBox&gt;(renderer()) ? &amp;downcast&lt;RenderBox&gt;(renderer()) : nullptr; }
 158 
 159     RenderLayer* parent() const { return m_parent; }
 160     RenderLayer* previousSibling() const { return m_previous; }
 161     RenderLayer* nextSibling() const { return m_next; }
 162     RenderLayer* firstChild() const { return m_first; }
 163     RenderLayer* lastChild() const { return m_last; }
 164     bool isDescendantOf(const RenderLayer&amp;) const;
 165 
 166     // This does an ancestor tree walk. Avoid it!
 167     const RenderLayer* root() const
 168     {
 169         const RenderLayer* curr = this;
 170         while (curr-&gt;parent())
 171             curr = curr-&gt;parent();
 172         return curr;
 173     }
 174 
 175     void addChild(RenderLayer&amp; newChild, RenderLayer* beforeChild = nullptr);
 176     void removeChild(RenderLayer&amp;);
 177 
 178     void insertOnlyThisLayer();
 179     void removeOnlyThisLayer();
 180 
 181     bool isNormalFlowOnly() const { return m_isNormalFlowOnly; }
<span class="line-modified"> 182 </span>
<span class="line-added"> 183     // isStackingContext is true for layers that we&#39;ve determined should be stacking contexts for painting.</span>
<span class="line-added"> 184     // Not all stacking contexts are CSS stacking contexts.</span>
<span class="line-added"> 185     bool isStackingContext() const { return isCSSStackingContext() || m_isOpportunisticStackingContext; }</span>
<span class="line-added"> 186 </span>
<span class="line-added"> 187     // isCSSStackingContext is true for layers that are stacking contexts from a CSS perspective.</span>
<span class="line-added"> 188     // isCSSStackingContext() =&gt; isStackingContext().</span>
<span class="line-added"> 189     // FIXME: m_forcedStackingContext should affect isStackingContext(), not isCSSStackingContext(), but doing so breaks media control mix-blend-mode.</span>
<span class="line-added"> 190     bool isCSSStackingContext() const { return m_isCSSStackingContext || m_forcedStackingContext; }</span>
 191 
 192     // Gets the enclosing stacking context for this layer, excluding this layer itself.
 193     RenderLayer* stackingContext() const;
 194 
 195     // Gets the enclosing stacking container for this layer, possibly the layer
 196     // itself, if it is a stacking container.
 197     RenderLayer* enclosingStackingContext() { return isStackingContext() ? this : stackingContext(); }
 198 
 199     RenderLayer* paintOrderParent() const;
 200 
 201     void dirtyNormalFlowList();
 202     void dirtyZOrderLists();
 203     void dirtyStackingContextZOrderLists();
 204 
 205     bool normalFlowListDirty() const { return m_normalFlowListDirty; }
 206     bool zOrderListsDirty() const { return m_zOrderListsDirty; }
 207 
 208 #if !ASSERT_DISABLED
 209     bool layerListMutationAllowed() const { return m_layerListMutationAllowed; }
 210     void setLayerListMutationAllowed(bool flag) { m_layerListMutationAllowed = flag; }
</pre>
<hr />
<pre>
 405     bool cannotBlitToWindow() const;
 406 
 407     bool isTransparent() const { return renderer().isTransparent() || renderer().hasMask(); }
 408 
 409     bool hasReflection() const { return renderer().hasReflection(); }
 410     bool isReflection() const { return renderer().isReplica(); }
 411     RenderReplica* reflection() const { return m_reflection.get(); }
 412     RenderLayer* reflectionLayer() const;
 413     bool isReflectionLayer(const RenderLayer&amp;) const;
 414 
 415     const LayoutPoint&amp; location() const { return m_topLeft; }
 416     void setLocation(const LayoutPoint&amp; p) { m_topLeft = p; }
 417 
 418     const IntSize&amp; size() const { return m_layerSize; }
 419     void setSize(const IntSize&amp; size) { m_layerSize = size; } // Only public for RenderTreeAsText.
 420 
 421     LayoutRect rect() const { return LayoutRect(location(), size()); }
 422 
 423     IntSize visibleSize() const override;
 424     IntSize contentsSize() const override;
<span class="line-added"> 425     IntSize reachableTotalContentsSize() const override;</span>
 426 
 427     int scrollWidth() const;
 428     int scrollHeight() const;
 429 
 430     void panScrollFromPoint(const IntPoint&amp;);
 431 
 432     // Scrolling methods for layers that can scroll their overflow.
 433     void scrollByRecursively(const IntSize&amp; delta, ScrollableArea** scrolledArea = nullptr);
 434 
<span class="line-modified"> 435     WEBCORE_EXPORT void scrollToOffset(const ScrollOffset&amp;, ScrollType = ScrollType::Programmatic, ScrollClamping = ScrollClamping::Clamped);</span>


 436 
<span class="line-modified"> 437     void scrollToXPosition(int x, ScrollType, ScrollClamping = ScrollClamping::Clamped);</span>
<span class="line-modified"> 438     void scrollToYPosition(int y, ScrollType, ScrollClamping = ScrollClamping::Clamped);</span>
<span class="line-added"> 439 </span>
<span class="line-added"> 440     // These are only used by marquee.</span>
<span class="line-added"> 441     void scrollToXOffset(int x) { scrollToOffset(ScrollOffset(x, scrollOffset().y()), ScrollType::Programmatic, ScrollClamping::Unclamped); }</span>
<span class="line-added"> 442     void scrollToYOffset(int y) { scrollToOffset(ScrollOffset(scrollOffset().x(), y), ScrollType::Programmatic, ScrollClamping::Unclamped); }</span>
 443 
 444     void setPostLayoutScrollPosition(Optional&lt;ScrollPosition&gt;);
 445     void applyPostLayoutScrollPositionIfNeeded();
 446 



 447     void availableContentSizeChanged(AvailableSizeChangeReason) override;
 448 
 449     // &quot;absoluteRect&quot; is in scaled document coordinates.
 450     void scrollRectToVisible(const LayoutRect&amp; absoluteRect, bool insideFixed, const ScrollRectToVisibleOptions&amp;);
 451 
 452     bool scrollsOverflow() const;
<span class="line-added"> 453     bool hasScrollableHorizontalOverflow() const;</span>
<span class="line-added"> 454     bool hasScrollableVerticalOverflow() const;</span>
 455     bool hasScrollbars() const { return m_hBar || m_vBar; }
 456     void setHasHorizontalScrollbar(bool);
 457     void setHasVerticalScrollbar(bool);
 458 
 459     Ref&lt;Scrollbar&gt; createScrollbar(ScrollbarOrientation);
 460     void destroyScrollbar(ScrollbarOrientation);
 461 
 462     bool hasHorizontalScrollbar() const { return horizontalScrollbar(); }
 463     bool hasVerticalScrollbar() const { return verticalScrollbar(); }
 464 
<span class="line-added"> 465     bool horizontalScrollbarHiddenByStyle() const override;</span>
<span class="line-added"> 466     bool verticalScrollbarHiddenByStyle() const override;</span>
<span class="line-added"> 467 </span>
 468     // ScrollableArea overrides
 469     ScrollPosition scrollPosition() const override { return m_scrollPosition; }
 470 
 471     Scrollbar* horizontalScrollbar() const override { return m_hBar.get(); }
 472     Scrollbar* verticalScrollbar() const override { return m_vBar.get(); }
 473     ScrollableArea* enclosingScrollableArea() const override;
<span class="line-added"> 474 </span>
 475     bool isScrollableOrRubberbandable() override;
 476     bool hasScrollableOrRubberbandableAncestor() override;
 477     bool useDarkAppearance() const final;
 478 #if ENABLE(CSS_SCROLL_SNAP)
 479     void updateSnapOffsets() override;
 480 #endif
 481 



 482     bool requiresScrollPositionReconciliation() const { return m_requiresScrollPositionReconciliation; }
 483     void setRequiresScrollPositionReconciliation(bool requiresReconciliation = true) { m_requiresScrollPositionReconciliation = requiresReconciliation; }
 484 
 485 #if PLATFORM(IOS_FAMILY)
 486 #if ENABLE(IOS_TOUCH_EVENTS)
 487     bool handleTouchEvent(const PlatformTouchEvent&amp;) override;
 488 #endif
 489 
 490     void didStartScroll() override;
 491     void didEndScroll() override;
 492     void didUpdateScroll() override;
 493 #endif
 494 
 495     // Returns true when the layer could do touch scrolling, but doesn&#39;t look at whether there is actually scrollable overflow.
 496     bool canUseCompositedScrolling() const;
 497     // Returns true when there is actually scrollable overflow (requires layout to be up-to-date).
<span class="line-modified"> 498     bool hasCompositedScrollableOverflow() const { return m_hasCompositedScrollableOverflow; }</span>
 499 
 500     int verticalScrollbarWidth(OverlayScrollbarSizeRelevancy = IgnoreOverlayScrollbarSize) const;
 501     int horizontalScrollbarHeight(OverlayScrollbarSizeRelevancy = IgnoreOverlayScrollbarSize) const;
 502 
 503     bool hasOverflowControls() const;
 504     bool isPointInResizeControl(const IntPoint&amp; absolutePoint) const;
 505     bool hitTestOverflowControls(HitTestResult&amp;, const IntPoint&amp; localPoint);
 506     IntSize offsetFromResizeCorner(const IntPoint&amp; absolutePoint) const;
 507 
 508     void paintOverflowControls(GraphicsContext&amp;, const IntPoint&amp;, const IntRect&amp; damageRect, bool paintingOverlayControls = false);
 509     void paintScrollCorner(GraphicsContext&amp;, const IntPoint&amp;, const IntRect&amp; damageRect);
 510     void paintResizer(GraphicsContext&amp;, const LayoutPoint&amp;, const LayoutRect&amp; damageRect);
 511 
 512     void updateScrollInfoAfterLayout();
 513 
 514     bool scroll(ScrollDirection, ScrollGranularity, float multiplier = 1);
 515     void autoscroll(const IntPoint&amp;);
 516 
 517     bool canResize() const;
 518     void resize(const PlatformMouseEvent&amp;, const LayoutSize&amp;);
 519     bool inResizeMode() const { return m_inResizeMode; }
 520     void setInResizeMode(bool b) { m_inResizeMode = b; }
 521 
 522     bool isRenderViewLayer() const { return m_isRenderViewLayer; }
 523     bool isForcedStackingContext() const { return m_forcedStackingContext; }
<span class="line-added"> 524     bool isOpportunisticStackingContext() const { return m_isOpportunisticStackingContext; }</span>
 525 
 526     RenderLayerCompositor&amp; compositor() const;
 527 
 528     // Notification from the renderer that its content changed (e.g. current frame of image changed).
 529     // Allows updates of layer content without repainting.
 530     void contentChanged(ContentChangeType);
 531 
 532     bool canRender3DTransforms() const;
 533 
<span class="line-modified"> 534     void updateLayerPositionsAfterStyleChange();</span>
<span class="line-modified"> 535     void updateLayerPositionsAfterLayout(bool isRelayoutingSubtree, bool didFullRepaint);</span>








 536 
 537     void updateLayerPositionsAfterOverflowScroll();
 538     void updateLayerPositionsAfterDocumentScroll();
 539 
 540     bool hasCompositedLayerInEnclosingPaginationChain() const;
 541     enum PaginationInclusionMode { ExcludeCompositedPaginatedLayers, IncludeCompositedPaginatedLayers };
 542     RenderLayer* enclosingPaginationLayer(PaginationInclusionMode mode) const
 543     {
 544         if (mode == ExcludeCompositedPaginatedLayers &amp;&amp; hasCompositedLayerInEnclosingPaginationChain())
 545             return nullptr;
 546         return m_enclosingPaginationLayer.get();
 547     }
 548 
 549     void updateTransform();
 550 
 551 #if ENABLE(CSS_COMPOSITING)
 552     void updateBlendMode();
<span class="line-added"> 553     void willRemoveChildWithBlendMode();</span>
 554 #endif
 555 
 556     const LayoutSize&amp; offsetForInFlowPosition() const { return m_offsetForInFlowPosition; }
 557 
 558     void clearClipRectsIncludingDescendants(ClipRectsType typeToClear = AllClipRectTypes);
 559     void clearClipRects(ClipRectsType typeToClear = AllClipRectTypes);
 560 
 561     void addBlockSelectionGapsBounds(const LayoutRect&amp;);
 562     void clearBlockSelectionGapsBounds();
 563     void repaintBlockSelectionGaps();
 564 
 565     // FIXME: We should ASSERT(!m_visibleContentStatusDirty) here, but see https://bugs.webkit.org/show_bug.cgi?id=71044
 566     // ditto for hasVisibleDescendant(), see https://bugs.webkit.org/show_bug.cgi?id=71277
 567     bool hasVisibleContent() const { return m_hasVisibleContent; }
 568     bool hasVisibleDescendant() const { return m_hasVisibleDescendant; }
 569 
 570     void setHasVisibleContent();
 571     void dirtyVisibleContentStatus();
 572 
 573     bool hasVisibleBoxDecorationsOrBackground() const;
 574     bool hasVisibleBoxDecorations() const;
 575 
<span class="line-added"> 576     bool behavesAsFixed() const { return m_behavesAsFixed; }</span>
<span class="line-added"> 577 </span>
 578     struct PaintedContentRequest {
 579         void makeStatesUndetermined()
 580         {
 581             if (hasPaintedContent == RequestState::Unknown)
 582                 hasPaintedContent = RequestState::Undetermined;
 583 
 584             if (hasSubpixelAntialiasedText == RequestState::Unknown)
 585                 hasSubpixelAntialiasedText = RequestState::Undetermined;
 586         }
 587 
 588         void setHasPaintedContent() { hasPaintedContent = RequestState::True; }
 589         void setHasSubpixelAntialiasedText() { hasSubpixelAntialiasedText = RequestState::True; }
 590 
 591         bool needToDeterminePaintedContentState() const { return hasPaintedContent == RequestState::Unknown; }
 592         bool needToDetermineSubpixelAntialiasedTextState() const { return hasSubpixelAntialiasedText == RequestState::Unknown; }
 593 
 594         bool probablyHasPaintedContent() const { return hasPaintedContent == RequestState::True || hasPaintedContent == RequestState::Undetermined; }
 595         bool probablyHasSubpixelAntialiasedText() const { return hasSubpixelAntialiasedText == RequestState::True || hasSubpixelAntialiasedText == RequestState::Undetermined; }
 596 
 597         bool isSatisfied() const { return hasPaintedContent != RequestState::Unknown &amp;&amp; hasSubpixelAntialiasedText != RequestState::Unknown; }
 598 
 599         RequestState hasPaintedContent { RequestState::Unknown };
 600         RequestState hasSubpixelAntialiasedText { RequestState::DontCare };
 601     };
 602 
 603     // Returns true if this layer has visible content (ignoring any child layers).
 604     bool isVisuallyNonEmpty(PaintedContentRequest* = nullptr) const;
 605     // True if this layer container renderers that paint.
 606     bool hasNonEmptyChildRenderers(PaintedContentRequest&amp;) const;
 607 
 608     // FIXME: We should ASSERT(!m_hasSelfPaintingLayerDescendantDirty); here but we hit the same bugs as visible content above.
 609     // Part of the issue is with subtree relayout: we don&#39;t check if our ancestors have some descendant flags dirty, missing some updates.
 610     bool hasSelfPaintingLayerDescendant() const { return m_hasSelfPaintingLayerDescendant; }
 611 
<span class="line-added"> 612     bool ancestorLayerIsInContainingBlockChain(const RenderLayer&amp; ancestor, const RenderLayer* checkLimit = nullptr) const;</span>
<span class="line-added"> 613 </span>
 614     // Gets the nearest enclosing positioned ancestor layer (also includes
 615     // the &lt;html&gt; layer and the root layer).
 616     RenderLayer* enclosingAncestorForPosition(PositionType) const;
 617 
 618     // Returns the nearest enclosing layer that is scrollable.
 619     RenderLayer* enclosingScrollableLayer() const;
 620 
 621     // The layer relative to which clipping rects for this layer are computed.
 622     RenderLayer* clippingRootForPainting() const;
 623 
 624     RenderLayer* enclosingOverflowClipLayer(IncludeSelfOrNot) const;
 625 
 626     // Enclosing compositing layer; if includeSelf is true, may return this.
 627     RenderLayer* enclosingCompositingLayer(IncludeSelfOrNot = IncludeSelf) const;
 628     RenderLayer* enclosingCompositingLayerForRepaint(IncludeSelfOrNot = IncludeSelf) const;
 629     // Ancestor compositing layer, excluding this.
 630     RenderLayer* ancestorCompositingLayer() const { return enclosingCompositingLayer(ExcludeSelf); }
 631 
 632     RenderLayer* enclosingFilterLayer(IncludeSelfOrNot = IncludeSelf) const;
 633     RenderLayer* enclosingFilterRepaintLayer() const;
 634     void setFilterBackendNeedsRepaintingInRect(const LayoutRect&amp;);
 635     bool hasAncestorWithFilterOutsets() const;
 636 
<span class="line-modified"> 637     bool canUseOffsetFromAncestor() const</span>
 638     {
<span class="line-modified"> 639         // FIXME: This really needs to know if there are transforms on this layer and any of the layers</span>
<span class="line-added"> 640         // between it and the ancestor in question.</span>
 641         return !renderer().hasTransform() &amp;&amp; !renderer().isSVGRoot();
 642     }
 643 
 644     // FIXME: adjustForColumns allows us to position compositing layers in columns correctly, but eventually they need to be split across columns too.
 645     enum ColumnOffsetAdjustment { DontAdjustForColumns, AdjustForColumns };
 646     void convertToPixelSnappedLayerCoords(const RenderLayer* ancestorLayer, IntPoint&amp; location, ColumnOffsetAdjustment adjustForColumns = DontAdjustForColumns) const;
 647     LayoutPoint convertToLayerCoords(const RenderLayer* ancestorLayer, const LayoutPoint&amp;, ColumnOffsetAdjustment adjustForColumns = DontAdjustForColumns) const;
 648     LayoutSize offsetFromAncestor(const RenderLayer*, ColumnOffsetAdjustment = DontAdjustForColumns) const;
 649 
 650     int zIndex() const { return renderer().style().zIndex(); }
 651 
 652     enum PaintLayerFlag {
 653         PaintLayerHaveTransparency                      = 1 &lt;&lt; 0,
 654         PaintLayerAppliedTransform                      = 1 &lt;&lt; 1,
 655         PaintLayerTemporaryClipRects                    = 1 &lt;&lt; 2,
 656         PaintLayerPaintingReflection                    = 1 &lt;&lt; 3,
 657         PaintLayerPaintingOverlayScrollbars             = 1 &lt;&lt; 4,
 658         PaintLayerPaintingCompositingBackgroundPhase    = 1 &lt;&lt; 5,
 659         PaintLayerPaintingCompositingForegroundPhase    = 1 &lt;&lt; 6,
 660         PaintLayerPaintingCompositingMaskPhase          = 1 &lt;&lt; 7,
 661         PaintLayerPaintingCompositingClipPathPhase      = 1 &lt;&lt; 8,
 662         PaintLayerPaintingCompositingScrollingPhase     = 1 &lt;&lt; 9,
 663         PaintLayerPaintingOverflowContents              = 1 &lt;&lt; 10,
 664         PaintLayerPaintingRootBackgroundOnly            = 1 &lt;&lt; 11,
 665         PaintLayerPaintingSkipRootBackground            = 1 &lt;&lt; 12,
 666         PaintLayerPaintingChildClippingMaskPhase        = 1 &lt;&lt; 13,
<span class="line-added"> 667         PaintLayerCollectingEventRegion                 = 1 &lt;&lt; 14,</span>
 668     };
<span class="line-modified"> 669     static constexpr OptionSet&lt;PaintLayerFlag&gt; paintLayerPaintingCompositingAllPhasesFlags() { return { PaintLayerPaintingCompositingBackgroundPhase, PaintLayerPaintingCompositingForegroundPhase }; }</span>
 670 
 671     enum class SecurityOriginPaintPolicy { AnyOrigin, AccessibleOriginOnly };
 672 
 673     // The two main functions that use the layer system.  The paint method
 674     // paints the layers that intersect the damage rect from back to
 675     // front.  The hitTest method looks for mouse events by walking
 676     // layers that intersect the point from front to back.
 677     void paint(GraphicsContext&amp;, const LayoutRect&amp; damageRect, const LayoutSize&amp; subpixelOffset = LayoutSize(), OptionSet&lt;PaintBehavior&gt; = PaintBehavior::Normal,
 678         RenderObject* subtreePaintRoot = nullptr, OptionSet&lt;PaintLayerFlag&gt; = { }, SecurityOriginPaintPolicy = SecurityOriginPaintPolicy::AnyOrigin);
 679     bool hitTest(const HitTestRequest&amp;, HitTestResult&amp;);
 680     bool hitTest(const HitTestRequest&amp;, const HitTestLocation&amp;, HitTestResult&amp;);
 681     void paintOverlayScrollbars(GraphicsContext&amp;, const LayoutRect&amp; damageRect, OptionSet&lt;PaintBehavior&gt;, RenderObject* subtreePaintRoot = nullptr);
 682 
 683     struct ClipRectsContext {
 684         ClipRectsContext(const RenderLayer* inRootLayer, ClipRectsType inClipRectsType, OverlayScrollbarSizeRelevancy inOverlayScrollbarSizeRelevancy = IgnoreOverlayScrollbarSize, ShouldRespectOverflowClip inRespectOverflowClip = RespectOverflowClip)
 685             : rootLayer(inRootLayer)
 686             , clipRectsType(inClipRectsType)
 687             , overlayScrollbarSizeRelevancy(inOverlayScrollbarSizeRelevancy)
 688             , respectOverflowClip(inRespectOverflowClip)
 689         { }
</pre>
<hr />
<pre>
 693         ShouldRespectOverflowClip respectOverflowClip;
 694     };
 695 
 696     // This method figures out our layerBounds in coordinates relative to
 697     // |rootLayer}.  It also computes our background and foreground clip rects
 698     // for painting/event handling.
 699     // Pass offsetFromRoot if known.
 700     void calculateRects(const ClipRectsContext&amp;, const LayoutRect&amp; paintDirtyRect, LayoutRect&amp; layerBounds,
 701         ClipRect&amp; backgroundRect, ClipRect&amp; foregroundRect, const LayoutSize&amp; offsetFromRoot) const;
 702 
 703     // Public just for RenderTreeAsText.
 704     void collectFragments(LayerFragments&amp;, const RenderLayer* rootLayer, const LayoutRect&amp; dirtyRect,
 705         PaginationInclusionMode,
 706         ClipRectsType, OverlayScrollbarSizeRelevancy inOverlayScrollbarSizeRelevancy, ShouldRespectOverflowClip, const LayoutSize&amp; offsetFromRoot,
 707         const LayoutRect* layerBoundingBox = nullptr, ShouldApplyRootOffsetToFragments = IgnoreRootOffsetForFragments);
 708 
 709     LayoutRect childrenClipRect() const; // Returns the foreground clip rect of the layer in the document&#39;s coordinate space.
 710     LayoutRect selfClipRect() const; // Returns the background clip rect of the layer in the document&#39;s coordinate space.
 711     LayoutRect localClipRect(bool&amp; clipExceedsBounds) const; // Returns the background clip rect of the layer in the local coordinate space.
 712 
<span class="line-added"> 713     bool clipCrossesPaintingBoundary() const;</span>
<span class="line-added"> 714 </span>
 715     // Pass offsetFromRoot if known.
 716     bool intersectsDamageRect(const LayoutRect&amp; layerBounds, const LayoutRect&amp; damageRect, const RenderLayer* rootLayer, const LayoutSize&amp; offsetFromRoot, const LayoutRect* cachedBoundingBox = nullptr) const;
 717 
 718     enum CalculateLayerBoundsFlag {
 719         IncludeSelfTransform                    = 1 &lt;&lt; 0,
 720         UseLocalClipRectIfPossible              = 1 &lt;&lt; 1,
 721         IncludeFilterOutsets                    = 1 &lt;&lt; 2,
 722         IncludePaintedFilterOutsets             = 1 &lt;&lt; 3,
 723         ExcludeHiddenDescendants                = 1 &lt;&lt; 4,
 724         DontConstrainForMask                    = 1 &lt;&lt; 5,
 725         IncludeCompositedDescendants            = 1 &lt;&lt; 6,
 726         UseFragmentBoxesExcludingCompositing    = 1 &lt;&lt; 7,
 727         UseFragmentBoxesIncludingCompositing    = 1 &lt;&lt; 8,
 728     };
 729     static constexpr OptionSet&lt;CalculateLayerBoundsFlag&gt; defaultCalculateLayerBoundsFlags() { return { IncludeSelfTransform, UseLocalClipRectIfPossible, IncludePaintedFilterOutsets, UseFragmentBoxesExcludingCompositing }; }
 730 
 731     // Bounding box relative to some ancestor layer. Pass offsetFromRoot if known.
 732     LayoutRect boundingBox(const RenderLayer* rootLayer, const LayoutSize&amp; offsetFromRoot = LayoutSize(), OptionSet&lt;CalculateLayerBoundsFlag&gt; = { }) const;
 733     // Bounding box in the coordinates of this layer.
 734     LayoutRect localBoundingBox(OptionSet&lt;CalculateLayerBoundsFlag&gt; = { }) const;
</pre>
<hr />
<pre>
 768     bool adjustForIOSCaretWhenScrolling() const { return m_adjustForIOSCaretWhenScrolling; }
 769     void setAdjustForIOSCaretWhenScrolling(bool adjustForIOSCaretWhenScrolling) { m_adjustForIOSCaretWhenScrolling = adjustForIOSCaretWhenScrolling; }
 770 #endif
 771 
 772     bool hasTransform() const { return renderer().hasTransform(); }
 773     // Note that this transform has the transform-origin baked in.
 774     TransformationMatrix* transform() const { return m_transform.get(); }
 775     // currentTransform computes a transform which takes accelerated animations into account. The
 776     // resulting transform has transform-origin baked in. If the layer does not have a transform,
 777     // returns the identity matrix.
 778     TransformationMatrix currentTransform(RenderStyle::ApplyTransformOrigin = RenderStyle::IncludeTransformOrigin) const;
 779     TransformationMatrix renderableTransform(OptionSet&lt;PaintBehavior&gt;) const;
 780 
 781     // Get the perspective transform, which is applied to transformed sublayers.
 782     // Returns true if the layer has a -webkit-perspective.
 783     // Note that this transform has the perspective-origin baked in.
 784     TransformationMatrix perspectiveTransform() const;
 785     FloatPoint perspectiveOrigin() const;
 786     bool preserves3D() const { return renderer().style().transformStyle3D() == TransformStyle3D::Preserve3D; }
 787     bool has3DTransform() const { return m_transform &amp;&amp; !m_transform-&gt;isAffine(); }
<span class="line-added"> 788     bool hasTransformedAncestor() const { return m_hasTransformedAncestor; }</span>
 789 
 790     void filterNeedsRepaint();
 791     bool hasFilter() const { return renderer().hasFilter(); }
 792     bool hasBackdropFilter() const
 793     {
 794 #if ENABLE(FILTERS_LEVEL_2)
 795         return renderer().hasBackdropFilter();
 796 #else
 797         return false;
 798 #endif
 799     }
 800 
 801 #if ENABLE(CSS_COMPOSITING)
 802     bool hasBlendMode() const { return renderer().hasBlendMode(); }
 803     BlendMode blendMode() const { return static_cast&lt;BlendMode&gt;(m_blendMode); }
 804 
<span class="line-modified"> 805     bool isolatesCompositedBlending() const { return m_hasNotIsolatedCompositedBlendingDescendants &amp;&amp; isCSSStackingContext(); }</span>
 806     bool hasNotIsolatedCompositedBlendingDescendants() const { return m_hasNotIsolatedCompositedBlendingDescendants; }
 807     void setHasNotIsolatedCompositedBlendingDescendants(bool hasNotIsolatedCompositedBlendingDescendants)
 808     {
 809         m_hasNotIsolatedCompositedBlendingDescendants = hasNotIsolatedCompositedBlendingDescendants;
 810     }
 811 
<span class="line-modified"> 812     bool isolatesBlending() const { return hasNotIsolatedBlendingDescendants() &amp;&amp; isCSSStackingContext(); }</span>
 813 
 814     // FIXME: We should ASSERT(!m_hasNotIsolatedBlendingDescendantsStatusDirty); here but we hit the same bugs as visible content above.
 815     bool hasNotIsolatedBlendingDescendants() const { return m_hasNotIsolatedBlendingDescendants; }
 816     bool hasNotIsolatedBlendingDescendantsStatusDirty() const { return m_hasNotIsolatedBlendingDescendantsStatusDirty; }
 817 #else
 818     bool hasBlendMode() const { return false; }
 819     bool isolatesCompositedBlending() const { return false; }
 820     bool isolatesBlending() const { return false; }
 821     bool hasNotIsolatedBlendingDescendantsStatusDirty() const { return false; }
 822 #endif
 823 
 824     bool isComposited() const { return m_backing != nullptr; }
 825     bool hasCompositingDescendant() const { return m_hasCompositingDescendant; }
 826     bool hasCompositedMask() const;
 827 
<span class="line-added"> 828     // If non-null, a non-ancestor composited layer that this layer paints into (it is sharing its backing store with this layer).</span>
<span class="line-added"> 829     RenderLayer* backingProviderLayer() const { return m_backingProviderLayer.get(); }</span>
<span class="line-added"> 830     void setBackingProviderLayer(RenderLayer*);</span>
<span class="line-added"> 831     void disconnectFromBackingProviderLayer();</span>
<span class="line-added"> 832 </span>
<span class="line-added"> 833     bool paintsIntoProvidedBacking() const { return !!m_backingProviderLayer; }</span>
<span class="line-added"> 834 </span>
 835     RenderLayerBacking* backing() const { return m_backing.get(); }
 836     RenderLayerBacking* ensureBacking();
 837     void clearBacking(bool layerBeingDestroyed = false);
 838 
 839     GraphicsLayer* layerForHorizontalScrollbar() const override;
 840     GraphicsLayer* layerForVerticalScrollbar() const override;
 841     GraphicsLayer* layerForScrollCorner() const override;
 842 
 843     bool usesCompositedScrolling() const override;
 844     bool usesAsyncScrolling() const override;
 845 
<span class="line-added"> 846     bool hasCompositedScrollingAncestor() const { return m_hasCompositedScrollingAncestor; }</span>
<span class="line-added"> 847     void setHasCompositedScrollingAncestor(bool hasCompositedScrollingAncestor) { m_hasCompositedScrollingAncestor = hasCompositedScrollingAncestor; }</span>
<span class="line-added"> 848 </span>
 849     bool paintsWithTransparency(OptionSet&lt;PaintBehavior&gt; paintBehavior) const
 850     {
 851         return (isTransparent() || hasBlendMode() || (isolatesBlending() &amp;&amp; !renderer().isDocumentElementRenderer())) &amp;&amp; ((paintBehavior &amp; PaintBehavior::FlattenCompositingLayers) || !isComposited());
 852     }
 853 
 854     bool paintsWithTransform(OptionSet&lt;PaintBehavior&gt;) const;
 855     bool shouldPaintMask(OptionSet&lt;PaintBehavior&gt;, OptionSet&lt;PaintLayerFlag&gt;) const;
 856     bool shouldApplyClipPath(OptionSet&lt;PaintBehavior&gt;, OptionSet&lt;PaintLayerFlag&gt;) const;
 857 
 858     // Returns true if background phase is painted opaque in the given rect.
 859     // The query rect is given in local coordinates.
 860     bool backgroundIsKnownToBeOpaqueInRect(const LayoutRect&amp;) const;
 861 
 862     bool scrollingMayRevealBackground() const;
 863 
 864     bool containsDirtyOverlayScrollbars() const { return m_containsDirtyOverlayScrollbars; }
 865     void setContainsDirtyOverlayScrollbars(bool dirtyScrollbars) { m_containsDirtyOverlayScrollbars = dirtyScrollbars; }
 866 
 867     bool paintsWithFilters() const;
 868     bool requiresFullLayerImageForFilters() const;
 869 
 870     Element* enclosingElement() const;
 871 
 872     enum ViewportConstrainedNotCompositedReason {
 873         NoNotCompositedReason,
 874         NotCompositedForBoundsOutOfView,
 875         NotCompositedForNonViewContainer,
 876         NotCompositedForNoVisibleContent,
 877     };
 878 
 879     void setViewportConstrainedNotCompositedReason(ViewportConstrainedNotCompositedReason reason) { m_viewportConstrainedNotCompositedReason = reason; }
 880     ViewportConstrainedNotCompositedReason viewportConstrainedNotCompositedReason() const { return static_cast&lt;ViewportConstrainedNotCompositedReason&gt;(m_viewportConstrainedNotCompositedReason); }
 881 
<span class="line-added"> 882     IndirectCompositingReason indirectCompositingReason() const { return static_cast&lt;IndirectCompositingReason&gt;(m_indirectCompositingReason); }</span>
<span class="line-added"> 883 </span>
 884     bool isRenderFragmentedFlow() const { return renderer().isRenderFragmentedFlow(); }
 885     bool isOutOfFlowRenderFragmentedFlow() const { return renderer().isOutOfFlowRenderFragmentedFlow(); }
 886     bool isInsideFragmentedFlow() const { return renderer().fragmentedFlowState() != RenderObject::NotInsideFragmentedFlow; }
 887     bool isDirtyRenderFragmentedFlow() const
 888     {
 889         ASSERT(isRenderFragmentedFlow());
 890         return zOrderListsDirty() || normalFlowListDirty();
 891     }
 892 
 893     RenderLayer* enclosingFragmentedFlowAncestor() const;
 894 
 895     bool shouldPlaceBlockDirectionScrollbarOnLeft() const final { return renderer().shouldPlaceBlockDirectionScrollbarOnLeft(); }
 896 
 897     void simulateFrequentPaint() { SinglePaintFrequencyTracking { m_paintFrequencyTracker }; }
 898     bool paintingFrequently() const { return m_paintFrequencyTracker.paintingFrequently(); }
 899 
<span class="line-added"> 900     WEBCORE_EXPORT bool isTransparentOrFullyClippedRespectingParentFrames() const;</span>
<span class="line-added"> 901 </span>
<span class="line-added"> 902     void invalidateEventRegion();</span>
<span class="line-added"> 903 </span>
 904 private:
 905 
 906     void setNextSibling(RenderLayer* next) { m_next = next; }
 907     void setPreviousSibling(RenderLayer* prev) { m_previous = prev; }
 908     void setParent(RenderLayer*);
 909     void setFirstChild(RenderLayer* first) { m_first = first; }
 910     void setLastChild(RenderLayer* last) { m_last = last; }
 911 
 912     void dirtyPaintOrderListsOnChildChange(RenderLayer&amp;);
 913 
 914     bool shouldBeNormalFlowOnly() const;
<span class="line-modified"> 915     bool shouldBeCSSStackingContext() const;</span>
 916 
 917     // Return true if changed.
 918     bool setIsNormalFlowOnly(bool);
<span class="line-modified"> 919 </span>
<span class="line-added"> 920     bool setIsOpportunisticStackingContext(bool);</span>
<span class="line-added"> 921     bool setIsCSSStackingContext(bool);</span>
<span class="line-added"> 922 </span>
<span class="line-added"> 923     void isStackingContextChanged();</span>
 924 
 925     bool isDirtyStackingContext() const { return m_zOrderListsDirty &amp;&amp; isStackingContext(); }
 926 
 927     void updateZOrderLists();
 928     void rebuildZOrderLists();
 929     void rebuildZOrderLists(std::unique_ptr&lt;Vector&lt;RenderLayer*&gt;&gt;&amp;, std::unique_ptr&lt;Vector&lt;RenderLayer*&gt;&gt;&amp;);
 930     void collectLayers(bool includeHiddenLayers, std::unique_ptr&lt;Vector&lt;RenderLayer*&gt;&gt;&amp;, std::unique_ptr&lt;Vector&lt;RenderLayer*&gt;&gt;&amp;);
 931     void clearZOrderLists();
 932 
 933     void updateNormalFlowList();
 934 
 935     struct LayerPaintingInfo {
 936         LayerPaintingInfo(RenderLayer* inRootLayer, const LayoutRect&amp; inDirtyRect, OptionSet&lt;PaintBehavior&gt; inPaintBehavior, const LayoutSize&amp; inSubpixelOffset, RenderObject* inSubtreePaintRoot = nullptr, OverlapTestRequestMap* inOverlapTestRequests = nullptr, bool inRequireSecurityOriginAccessForWidgets = false)
 937             : rootLayer(inRootLayer)
 938             , subtreePaintRoot(inSubtreePaintRoot)
 939             , paintDirtyRect(inDirtyRect)
 940             , subpixelOffset(inSubpixelOffset)
 941             , overlapTestRequests(inOverlapTestRequests)
 942             , paintBehavior(inPaintBehavior)
 943             , requireSecurityOriginAccessForWidgets(inRequireSecurityOriginAccessForWidgets)
 944         { }
 945 
 946         RenderLayer* rootLayer;
 947         RenderObject* subtreePaintRoot; // Only paint descendants of this object.
 948         LayoutRect paintDirtyRect; // Relative to rootLayer;
 949         LayoutSize subpixelOffset;
 950         OverlapTestRequestMap* overlapTestRequests; // May be null.
 951         OptionSet&lt;PaintBehavior&gt; paintBehavior;
 952         bool requireSecurityOriginAccessForWidgets;
 953         bool clipToDirtyRect { true };
<span class="line-added"> 954         EventRegionContext* eventRegionContext { nullptr };</span>
 955     };
 956 
 957     // Compute, cache and return clip rects computed with the given layer as the root.
 958     Ref&lt;ClipRects&gt; updateClipRects(const ClipRectsContext&amp;);
 959     // Compute and return the clip rects. If useCached is true, will used previously computed clip rects on ancestors
 960     // (rather than computing them all from scratch up the parent chain).
 961     void calculateClipRects(const ClipRectsContext&amp;, ClipRects&amp;) const;
 962     ClipRects* clipRects(const ClipRectsContext&amp;) const;
 963 
 964     void setAncestorChainHasSelfPaintingLayerDescendant();
 965     void dirtyAncestorChainHasSelfPaintingLayerDescendantStatus();
 966 
 967     void computeRepaintRects(const RenderLayerModelObject* repaintContainer, const RenderGeometryMap* = nullptr);
 968     void computeRepaintRectsIncludingDescendants();
 969     void clearRepaintRects();
 970 
 971     LayoutRect clipRectRelativeToAncestor(RenderLayer* ancestor, LayoutSize offsetFromAncestor, const LayoutRect&amp; constrainingRect) const;
 972 
 973     void clipToRect(GraphicsContext&amp;, const LayerPaintingInfo&amp;, const ClipRect&amp;, BorderRadiusClippingRule = IncludeSelfForBorderRadius);
 974     void restoreClip(GraphicsContext&amp;, const LayerPaintingInfo&amp;, const ClipRect&amp;);
 975 
 976     bool shouldRepaintAfterLayout() const;
 977 
 978     void updateSelfPaintingLayer();
 979 
 980     void updateScrollbarsAfterStyleChange(const RenderStyle* oldStyle);
 981     void updateScrollbarsAfterLayout();
 982 
<span class="line-added"> 983     enum UpdateLayerPositionsFlag {</span>
<span class="line-added"> 984         CheckForRepaint                     = 1 &lt;&lt; 0,</span>
<span class="line-added"> 985         NeedsFullRepaintInBacking           = 1 &lt;&lt; 1,</span>
<span class="line-added"> 986         ContainingClippingLayerChangedSize  = 1 &lt;&lt; 2,</span>
<span class="line-added"> 987         UpdatePagination                    = 1 &lt;&lt; 3,</span>
<span class="line-added"> 988         SeenFixedLayer                      = 1 &lt;&lt; 4,</span>
<span class="line-added"> 989         SeenTransformedLayer                = 1 &lt;&lt; 5,</span>
<span class="line-added"> 990         Seen3DTransformedLayer              = 1 &lt;&lt; 6,</span>
<span class="line-added"> 991         SeenCompositedScrollingLayer        = 1 &lt;&lt; 7,</span>
<span class="line-added"> 992     };</span>
<span class="line-added"> 993     static OptionSet&lt;UpdateLayerPositionsFlag&gt; flagsForUpdateLayerPositions(RenderLayer&amp; startingLayer);</span>
<span class="line-added"> 994 </span>
 995     // Returns true if the position changed.
<span class="line-modified"> 996     bool updateLayerPosition(OptionSet&lt;UpdateLayerPositionsFlag&gt;* = nullptr);</span>
 997 
<span class="line-modified"> 998     void updateLayerPositions(RenderGeometryMap*, OptionSet&lt;UpdateLayerPositionsFlag&gt;);</span>
 999 
1000     enum UpdateLayerPositionsAfterScrollFlag {
1001         IsOverflowScroll                        = 1 &lt;&lt; 0,
1002         HasSeenViewportConstrainedAncestor      = 1 &lt;&lt; 1,
1003         HasSeenAncestorWithOverflowClip         = 1 &lt;&lt; 2,
1004         HasChangedAncestor                      = 1 &lt;&lt; 3,
1005     };
1006     void updateLayerPositionsAfterScroll(RenderGeometryMap*, OptionSet&lt;UpdateLayerPositionsAfterScrollFlag&gt; = { });
1007 
1008     ScrollOffset clampScrollOffset(const ScrollOffset&amp;) const;
1009 
1010     RenderLayer* enclosingPaginationLayerInSubtree(const RenderLayer* rootLayer, PaginationInclusionMode) const;
1011 
1012     LayoutPoint renderBoxLocation() const { return is&lt;RenderBox&gt;(renderer()) ? downcast&lt;RenderBox&gt;(renderer()).location() : LayoutPoint(); }
1013 
1014     bool setupFontSubpixelQuantization(GraphicsContext&amp;, bool&amp; didQuantizeFonts);
1015 
1016     Path computeClipPath(const LayoutSize&amp; offsetFromRoot, LayoutRect&amp; rootRelativeBounds, WindRule&amp;) const;
1017 
1018     bool setupClipPath(GraphicsContext&amp;, const LayerPaintingInfo&amp;, const LayoutSize&amp; offsetFromRoot, LayoutRect&amp; rootRelativeBounds, bool&amp; rootRelativeBoundsComputed);
1019 
1020     void ensureLayerFilters();
1021     void clearLayerFilters();
1022 
1023     RenderLayerFilters* filtersForPainting(GraphicsContext&amp;, OptionSet&lt;PaintLayerFlag&gt;) const;
1024     GraphicsContext* setupFilters(GraphicsContext&amp; destinationContext, LayerPaintingInfo&amp;, OptionSet&lt;PaintLayerFlag&gt;, const LayoutSize&amp; offsetFromRoot, LayoutRect&amp; rootRelativeBounds, bool&amp; rootRelativeBoundsComputed);
1025     void applyFilters(GraphicsContext&amp; originalContext, const LayerPaintingInfo&amp;, const LayerFragments&amp;);
1026 
1027     void paintLayer(GraphicsContext&amp;, const LayerPaintingInfo&amp;, OptionSet&lt;PaintLayerFlag&gt;);
<span class="line-added">1028     void paintLayerWithEffects(GraphicsContext&amp;, const LayerPaintingInfo&amp;, OptionSet&lt;PaintLayerFlag&gt;);</span>
<span class="line-added">1029 </span>
1030     void paintLayerContentsAndReflection(GraphicsContext&amp;, const LayerPaintingInfo&amp;, OptionSet&lt;PaintLayerFlag&gt;);
1031     void paintLayerByApplyingTransform(GraphicsContext&amp;, const LayerPaintingInfo&amp;, OptionSet&lt;PaintLayerFlag&gt;, const LayoutSize&amp; translationOffset = LayoutSize());
1032     void paintLayerContents(GraphicsContext&amp;, const LayerPaintingInfo&amp;, OptionSet&lt;PaintLayerFlag&gt;);
1033     void paintList(LayerList, GraphicsContext&amp;, const LayerPaintingInfo&amp;, OptionSet&lt;PaintLayerFlag&gt;);
1034 
1035     void updatePaintingInfoForFragments(LayerFragments&amp;, const LayerPaintingInfo&amp;, OptionSet&lt;PaintLayerFlag&gt;, bool shouldPaintContent, const LayoutSize&amp; offsetFromRoot);
1036     void paintBackgroundForFragments(const LayerFragments&amp;, GraphicsContext&amp;, GraphicsContext&amp; transparencyLayerContext,
1037         const LayoutRect&amp; transparencyPaintDirtyRect, bool haveTransparency, const LayerPaintingInfo&amp;, OptionSet&lt;PaintBehavior&gt;, RenderObject* paintingRootForRenderer);
1038     void paintForegroundForFragments(const LayerFragments&amp;, GraphicsContext&amp;, GraphicsContext&amp; transparencyLayerContext,
1039         const LayoutRect&amp; transparencyPaintDirtyRect, bool haveTransparency, const LayerPaintingInfo&amp;, OptionSet&lt;PaintBehavior&gt;, RenderObject* paintingRootForRenderer);
1040     void paintForegroundForFragmentsWithPhase(PaintPhase, const LayerFragments&amp;, GraphicsContext&amp;, const LayerPaintingInfo&amp;, OptionSet&lt;PaintBehavior&gt;, RenderObject* paintingRootForRenderer);
1041     void paintOutlineForFragments(const LayerFragments&amp;, GraphicsContext&amp;, const LayerPaintingInfo&amp;, OptionSet&lt;PaintBehavior&gt;, RenderObject* paintingRootForRenderer);
1042     void paintOverflowControlsForFragments(const LayerFragments&amp;, GraphicsContext&amp;, const LayerPaintingInfo&amp;);
1043     void paintMaskForFragments(const LayerFragments&amp;, GraphicsContext&amp;, const LayerPaintingInfo&amp;, OptionSet&lt;PaintBehavior&gt;, RenderObject* paintingRootForRenderer);
1044     void paintChildClippingMaskForFragments(const LayerFragments&amp;, GraphicsContext&amp;, const LayerPaintingInfo&amp;, OptionSet&lt;PaintBehavior&gt;, RenderObject* paintingRootForRenderer);
1045     void paintTransformedLayerIntoFragments(GraphicsContext&amp;, const LayerPaintingInfo&amp;, OptionSet&lt;PaintLayerFlag&gt;);
<span class="line-added">1046     void collectEventRegionForFragments(const LayerFragments&amp;, GraphicsContext&amp;, const LayerPaintingInfo&amp;);</span>
1047 
1048     RenderLayer* transparentPaintingAncestor();
1049     void beginTransparencyLayers(GraphicsContext&amp;, const LayerPaintingInfo&amp;, const LayoutRect&amp; dirtyRect);
1050 
1051     RenderLayer* hitTestLayer(RenderLayer* rootLayer, RenderLayer* containerLayer, const HitTestRequest&amp;, HitTestResult&amp;,
1052         const LayoutRect&amp; hitTestRect, const HitTestLocation&amp;, bool appliedTransform,
1053         const HitTestingTransformState* = nullptr, double* zOffset = nullptr);
1054     RenderLayer* hitTestLayerByApplyingTransform(RenderLayer* rootLayer, RenderLayer* containerLayer, const HitTestRequest&amp;, HitTestResult&amp;,
1055         const LayoutRect&amp; hitTestRect, const HitTestLocation&amp;, const HitTestingTransformState* = nullptr, double* zOffset = nullptr,
1056         const LayoutSize&amp; translationOffset = LayoutSize());
1057     RenderLayer* hitTestList(LayerList, RenderLayer* rootLayer, const HitTestRequest&amp;, HitTestResult&amp;,
1058         const LayoutRect&amp; hitTestRect, const HitTestLocation&amp;,
1059         const HitTestingTransformState*, double* zOffsetForDescendants, double* zOffset,
1060         const HitTestingTransformState* unflattenedTransformState, bool depthSortDescendants);
1061 
1062     Ref&lt;HitTestingTransformState&gt; createLocalTransformState(RenderLayer* rootLayer, RenderLayer* containerLayer,
1063         const LayoutRect&amp; hitTestRect, const HitTestLocation&amp;,
1064         const HitTestingTransformState* containerTransformState,
1065         const LayoutSize&amp; translationOffset = LayoutSize()) const;
1066 
1067     bool hitTestContents(const HitTestRequest&amp;, HitTestResult&amp;, const LayoutRect&amp; layerBounds, const HitTestLocation&amp;, HitTestFilter) const;
1068     bool hitTestContentsForFragments(const LayerFragments&amp;, const HitTestRequest&amp;, HitTestResult&amp;, const HitTestLocation&amp;, HitTestFilter, bool&amp; insideClipRect) const;
1069     bool hitTestResizerInFragments(const LayerFragments&amp;, const HitTestLocation&amp;) const;
1070     RenderLayer* hitTestTransformedLayerInFragments(RenderLayer* rootLayer, RenderLayer* containerLayer, const HitTestRequest&amp;, HitTestResult&amp;,
1071         const LayoutRect&amp; hitTestRect, const HitTestLocation&amp;, const HitTestingTransformState* = nullptr, double* zOffset = nullptr);
1072 
1073     bool listBackgroundIsKnownToBeOpaqueInRect(const LayerList&amp;, const LayoutRect&amp;) const;
1074 
1075     void computeScrollDimensions();
1076     bool hasHorizontalOverflow() const;
1077     bool hasVerticalOverflow() const;


1078 
1079     bool showsOverflowControls() const;
1080 
1081     bool shouldBeSelfPaintingLayer() const;
1082 


1083     // ScrollableArea interface
1084     void invalidateScrollbarRect(Scrollbar&amp;, const IntRect&amp;) override;
1085     void invalidateScrollCornerRect(const IntRect&amp;) override;
1086     bool isActive() const override;
1087     bool isScrollCornerVisible() const override;
1088     IntRect scrollCornerRect() const override;
1089     IntRect convertFromScrollbarToContainingView(const Scrollbar&amp;, const IntRect&amp;) const override;
1090     IntRect convertFromContainingViewToScrollbar(const Scrollbar&amp;, const IntRect&amp;) const override;
1091     IntPoint convertFromScrollbarToContainingView(const Scrollbar&amp;, const IntPoint&amp;) const override;
1092     IntPoint convertFromContainingViewToScrollbar(const Scrollbar&amp;, const IntPoint&amp;) const override;

1093     void setScrollOffset(const ScrollOffset&amp;) override;
<span class="line-added">1094     ScrollingNodeID scrollingNodeID() const override;</span>
1095 
1096     IntRect visibleContentRectInternal(VisibleContentRectIncludesScrollbars, VisibleContentRectBehavior) const override;
1097     IntSize overhangAmount() const override;
1098     IntPoint lastKnownMousePosition() const override;
1099     bool isHandlingWheelEvent() const override;
1100     bool shouldSuspendScrollAnimations() const override;
1101     IntRect scrollableAreaBoundingBox(bool* isInsideFixed = nullptr) const override;
1102     bool isRubberBandInProgress() const override;
1103     bool forceUpdateScrollbarsOnMainThreadForPerformanceTesting() const override;
1104 #if ENABLE(CSS_SCROLL_SNAP)
1105     bool isScrollSnapInProgress() const override;
1106 #endif
1107     bool usesMockScrollAnimator() const override;
1108     void logMockScrollAnimatorMessage(const String&amp;) const override;
1109 
1110 #if ENABLE(IOS_TOUCH_EVENTS)
1111     void registerAsTouchEventListenerForScrolling();
1112     void unregisterAsTouchEventListenerForScrolling();
1113 #endif
1114 
1115     // Rectangle encompassing the scroll corner and resizer rect.
1116     LayoutRect scrollCornerAndResizerRect() const;
1117 
1118     // NOTE: This should only be called by the overridden setScrollOffset from ScrollableArea.
1119     void scrollTo(const ScrollPosition&amp;);
1120     void updateCompositingLayersAfterScroll();
1121 
1122     IntSize scrollbarOffset(const Scrollbar&amp;) const;
1123 
1124     void updateScrollableAreaSet(bool hasOverflow);
1125 
1126     bool allowsCurrentScroll() const;
1127 
1128     void dirtyAncestorChainVisibleDescendantStatus();
1129     void setAncestorChainHasVisibleDescendant();
1130 
1131     bool has3DTransformedDescendant() const { return m_has3DTransformedDescendant; }


1132     bool has3DTransformedAncestor() const { return m_has3DTransformedAncestor; }
1133 
1134     void dirty3DTransformedDescendantStatus();
1135     // Both updates the status, and returns true if descendants of this have 3d.
1136     bool update3DTransformedDescendantStatus();
1137 
1138     void createReflection();
1139     void removeReflection();
1140 
1141     RenderStyle createReflectionStyle();
1142     bool paintingInsideReflection() const { return m_paintingInsideReflection; }
1143     void setPaintingInsideReflection(bool b) { m_paintingInsideReflection = b; }
1144 
1145     void updateFiltersAfterStyleChange();
1146     void updateFilterPaintingStrategy();
1147 
1148 #if ENABLE(CSS_COMPOSITING)
1149     void updateAncestorChainHasBlendingDescendants();
1150     void dirtyAncestorChainHasBlendingDescendants();
1151 #endif
</pre>
<hr />
<pre>
1155 
1156     RenderLayer* enclosingTransformedAncestor() const;
1157 
1158     LayoutRect getRectToExpose(const LayoutRect&amp; visibleRect, const LayoutRect&amp; exposeRect, bool insideFixed, const ScrollAlignment&amp; alignX, const ScrollAlignment&amp; alignY) const;
1159 
1160     // Convert a point in absolute coords into layer coords, taking transforms into account
1161     LayoutPoint absoluteToContents(const LayoutPoint&amp;) const;
1162 
1163     void positionOverflowControls(const IntSize&amp;);
1164     void updateScrollCornerStyle();
1165     void clearScrollCorner();
1166     void updateResizerStyle();
1167     void clearResizer();
1168 
1169     void drawPlatformResizerImage(GraphicsContext&amp;, const LayoutRect&amp; resizerCornerRect);
1170 
1171     void updatePagination();
1172 
1173     void setHasCompositingDescendant(bool b)  { m_hasCompositingDescendant = b; }
1174 










1175     void setIndirectCompositingReason(IndirectCompositingReason reason) { m_indirectCompositingReason = static_cast&lt;unsigned&gt;(reason); }

1176     bool mustCompositeForIndirectReasons() const { return m_indirectCompositingReason; }
1177 




1178     LayoutUnit overflowTop() const;
1179     LayoutUnit overflowBottom() const;
1180     LayoutUnit overflowLeft() const;
1181     LayoutUnit overflowRight() const;
1182 
1183     IntRect rectForHorizontalScrollbar(const IntRect&amp; borderBoxRect) const;
1184     IntRect rectForVerticalScrollbar(const IntRect&amp; borderBoxRect) const;
1185 
1186     LayoutUnit verticalScrollbarStart(int minX, int maxX) const;
1187     LayoutUnit horizontalScrollbarStart(int minX) const;
1188 
1189     bool overflowControlsIntersectRect(const IntRect&amp; localRect) const;
1190 
1191     OptionSet&lt;Compositing&gt; m_compositingDirtyBits;
1192 
1193     const bool m_isRenderViewLayer : 1;
1194     const bool m_forcedStackingContext : 1;
1195 
1196     bool m_isNormalFlowOnly : 1;
<span class="line-modified">1197     bool m_isCSSStackingContext : 1;</span>
<span class="line-added">1198     bool m_isOpportunisticStackingContext : 1;</span>
1199 
1200     bool m_zOrderListsDirty : 1;
1201     bool m_normalFlowListDirty: 1;
1202     bool m_hadNegativeZOrderList : 1;
1203 
1204     // Keeps track of whether the layer is currently resizing, so events can cause resizing to start and stop.
1205     bool m_inResizeMode : 1;
1206 
1207     bool m_scrollDimensionsDirty : 1;
1208     bool m_isSelfPaintingLayer : 1;
1209 
1210     // If have no self-painting descendants, we don&#39;t have to walk our children during painting. This can lead to
1211     // significant savings, especially if the tree has lots of non-self-painting layers grouped together (e.g. table cells).
1212     bool m_hasSelfPaintingLayerDescendant : 1;
1213     bool m_hasSelfPaintingLayerDescendantDirty : 1;
1214 
1215     bool m_usedTransparency : 1; // Tracks whether we need to close a transparent layer, i.e., whether
1216                                  // we ended up painting this layer or any descendants (and therefore need to
1217                                  // blend).
1218     bool m_paintingInsideReflection : 1;  // A state bit tracking if we are painting inside a replica.
1219     bool m_inOverflowRelayout : 1;
1220     unsigned m_repaintStatus : 2; // RepaintStatus
1221 
1222     bool m_visibleContentStatusDirty : 1;
1223     bool m_hasVisibleContent : 1;
1224     bool m_visibleDescendantStatusDirty : 1;
1225     bool m_hasVisibleDescendant : 1;
1226     bool m_registeredScrollableArea : 1;
1227     bool m_isFixedIntersectingViewport : 1;
<span class="line-added">1228     bool m_behavesAsFixed : 1;</span>
1229 
1230     bool m_3DTransformedDescendantStatusDirty : 1;
1231     bool m_has3DTransformedDescendant : 1;  // Set on a stacking context layer that has 3D descendants anywhere
1232                                             // in a preserves3D hierarchy. Hint to do 3D-aware hit testing.
1233     bool m_hasCompositingDescendant : 1; // In the z-order tree.
1234 
<span class="line-added">1235     bool m_hasCompositedScrollingAncestor : 1; // In the layer-order tree.</span>
<span class="line-added">1236     bool m_hasCompositedScrollableOverflow : 1;</span>
<span class="line-added">1237 </span>
1238     bool m_hasTransformedAncestor : 1;
1239     bool m_has3DTransformedAncestor : 1;
1240 
1241     unsigned m_indirectCompositingReason : 3;
1242     unsigned m_viewportConstrainedNotCompositedReason : 2;
1243 
1244 #if PLATFORM(IOS_FAMILY)
1245 #if ENABLE(IOS_TOUCH_EVENTS)
1246     bool m_registeredAsTouchEventListenerForScrolling : 1;
1247 #endif
1248     bool m_adjustForIOSCaretWhenScrolling : 1;
1249 #endif
1250 

1251     bool m_requiresScrollPositionReconciliation : 1;
1252     bool m_containsDirtyOverlayScrollbars : 1;
1253     bool m_updatingMarqueePosition : 1;
1254 
1255 #if !ASSERT_DISABLED
1256     bool m_layerListMutationAllowed : 1;
1257 #endif
1258 
1259 #if ENABLE(CSS_COMPOSITING)
1260     unsigned m_blendMode : 5;
1261     bool m_hasNotIsolatedCompositedBlendingDescendants : 1;
1262     bool m_hasNotIsolatedBlendingDescendants : 1;
1263     bool m_hasNotIsolatedBlendingDescendantsStatusDirty : 1;
1264 #endif
1265 
1266     RenderLayerModelObject&amp; m_renderer;
1267 
1268     RenderLayer* m_parent { nullptr };
1269     RenderLayer* m_previous { nullptr };
1270     RenderLayer* m_next { nullptr };
1271     RenderLayer* m_first { nullptr };
1272     RenderLayer* m_last { nullptr };
1273 
<span class="line-added">1274     WeakPtr&lt;RenderLayer&gt; m_backingProviderLayer;</span>
<span class="line-added">1275 </span>
1276     // For layers that establish stacking contexts, m_posZOrderList holds a sorted list of all the
1277     // descendant layers within the stacking context that have z-indices of 0 or greater
1278     // (auto will count as 0). m_negZOrderList holds descendants within our stacking context with negative
1279     // z-indices.
1280     std::unique_ptr&lt;Vector&lt;RenderLayer*&gt;&gt; m_posZOrderList;
1281     std::unique_ptr&lt;Vector&lt;RenderLayer*&gt;&gt; m_negZOrderList;
1282 
1283     // This list contains child layers that cannot create stacking contexts and appear in normal flow order.
1284     std::unique_ptr&lt;Vector&lt;RenderLayer*&gt;&gt; m_normalFlowList;
1285 
1286     // Our current relative position offset.
1287     LayoutSize m_offsetForInFlowPosition;
1288 
1289     // Our (x,y) coordinates are in our parent layer&#39;s coordinate space.
1290     LayoutPoint m_topLeft;
1291 
1292     // The layer&#39;s width/height
1293     IntSize m_layerSize;
1294 
1295     ScrollPosition m_scrollPosition;
</pre>
<hr />
<pre>
1368         , m_previousMutationAllowedState(layer.layerListMutationAllowed())
1369     {
1370         m_layer.setLayerListMutationAllowed(false);
1371     }
1372 
1373     ~LayerListMutationDetector()
1374     {
1375         m_layer.setLayerListMutationAllowed(m_previousMutationAllowedState);
1376     }
1377 
1378 private:
1379     RenderLayer&amp; m_layer;
1380     bool m_previousMutationAllowedState;
1381 };
1382 #endif
1383 
1384 void makeMatrixRenderable(TransformationMatrix&amp;, bool has3DRendering);
1385 
1386 bool compositedWithOwnBackingStore(const RenderLayer&amp;);
1387 
<span class="line-added">1388 WTF::TextStream&amp; operator&lt;&lt;(WTF::TextStream&amp;, ClipRectsType);</span>
1389 WTF::TextStream&amp; operator&lt;&lt;(WTF::TextStream&amp;, const RenderLayer&amp;);
<span class="line-added">1390 WTF::TextStream&amp; operator&lt;&lt;(WTF::TextStream&amp;, const RenderLayer::ClipRectsContext&amp;);</span>
<span class="line-added">1391 WTF::TextStream&amp; operator&lt;&lt;(WTF::TextStream&amp;, IndirectCompositingReason);</span>
1392 
1393 } // namespace WebCore
1394 
1395 #if ENABLE(TREE_DEBUGGING)
1396 // Outside the WebCore namespace for ease of invocation from lldb.
1397 void showLayerTree(const WebCore::RenderLayer*);
1398 void showPaintOrderTree(const WebCore::RenderLayer*);
1399 void showLayerTree(const WebCore::RenderObject*);
1400 #endif
</pre>
</td>
</tr>
</table>
<center><a href="RenderLayer.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="RenderLayerBacking.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>