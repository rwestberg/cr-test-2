<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderLayer.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (C) 2006-2017 Apple Inc. All rights reserved.
   3  *
   4  * Portions are Copyright (C) 1998 Netscape Communications Corporation.
   5  *
   6  * Other contributors:
   7  *   Robert O&#39;Callahan &lt;roc+@cs.cmu.edu&gt;
   8  *   David Baron &lt;dbaron@fas.harvard.edu&gt;
   9  *   Christian Biesinger &lt;cbiesinger@web.de&gt;
  10  *   Randall Jesup &lt;rjesup@wgate.com&gt;
  11  *   Roland Mainz &lt;roland.mainz@informatik.med.uni-giessen.de&gt;
  12  *   Josh Soref &lt;timeless@mac.com&gt;
  13  *   Boris Zbarsky &lt;bzbarsky@mit.edu&gt;
  14  *
  15  * This library is free software; you can redistribute it and/or
  16  * modify it under the terms of the GNU Lesser General Public
  17  * License as published by the Free Software Foundation; either
  18  * version 2.1 of the License, or (at your option) any later version.
  19  *
  20  * This library is distributed in the hope that it will be useful,
  21  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  22  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  23  * Lesser General Public License for more details.
  24  *
  25  * You should have received a copy of the GNU Lesser General Public
  26  * License along with this library; if not, write to the Free Software
  27  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
  28  *
  29  * Alternatively, the contents of this file may be used under the terms
  30  * of either the Mozilla Public License Version 1.1, found at
  31  * http://www.mozilla.org/MPL/ (the &quot;MPL&quot;) or the GNU General Public
  32  * License Version 2.0, found at http://www.fsf.org/copyleft/gpl.html
  33  * (the &quot;GPL&quot;), in which case the provisions of the MPL or the GPL are
  34  * applicable instead of those above.  If you wish to allow use of your
  35  * version of this file only under the terms of one of those two
  36  * licenses (the MPL or the GPL) and not to allow others to use your
  37  * version of this file under the LGPL, indicate your decision by
  38  * deletingthe provisions above and replace them with the notice and
  39  * other provisions required by the MPL or the GPL, as the case may be.
  40  * If you do not delete the provisions above, a recipient may use your
  41  * version of this file under any of the LGPL, the MPL or the GPL.
  42  */
  43 
  44 #include &quot;config.h&quot;
  45 #include &quot;RenderLayer.h&quot;
  46 
  47 #include &quot;BoxShape.h&quot;
  48 #include &quot;CSSAnimationController.h&quot;
  49 #include &quot;CSSFilter.h&quot;
  50 #include &quot;CSSPropertyNames.h&quot;
  51 #include &quot;Chrome.h&quot;
  52 #include &quot;DebugPageOverlays.h&quot;
  53 #include &quot;DeprecatedGlobalSettings.h&quot;
  54 #include &quot;Document.h&quot;
  55 #include &quot;DocumentEventQueue.h&quot;
  56 #include &quot;DocumentMarkerController.h&quot;
  57 #include &quot;DocumentTimeline.h&quot;
  58 #include &quot;Element.h&quot;
  59 #include &quot;EventHandler.h&quot;
  60 #include &quot;FEColorMatrix.h&quot;
  61 #include &quot;FEMerge.h&quot;
  62 #include &quot;FloatConversion.h&quot;
  63 #include &quot;FloatPoint3D.h&quot;
  64 #include &quot;FloatRect.h&quot;
  65 #include &quot;FloatRoundedRect.h&quot;
  66 #include &quot;FocusController.h&quot;
  67 #include &quot;Frame.h&quot;
  68 #include &quot;FrameLoader.h&quot;
  69 #include &quot;FrameLoaderClient.h&quot;
  70 #include &quot;FrameSelection.h&quot;
  71 #include &quot;FrameTree.h&quot;
  72 #include &quot;FrameView.h&quot;
  73 #include &quot;Gradient.h&quot;
  74 #include &quot;GraphicsContext.h&quot;
  75 #include &quot;HTMLFormControlElement.h&quot;
  76 #include &quot;HTMLFrameElement.h&quot;
  77 #include &quot;HTMLFrameOwnerElement.h&quot;
  78 #include &quot;HTMLIFrameElement.h&quot;
  79 #include &quot;HTMLNames.h&quot;
  80 #include &quot;HTMLParserIdioms.h&quot;
  81 #include &quot;HitTestRequest.h&quot;
  82 #include &quot;HitTestResult.h&quot;
  83 #include &quot;HitTestingTransformState.h&quot;
  84 #include &quot;Logging.h&quot;
  85 #include &quot;OverflowEvent.h&quot;
  86 #include &quot;OverlapTestRequestClient.h&quot;
  87 #include &quot;Page.h&quot;
  88 #include &quot;PlatformMouseEvent.h&quot;
  89 #include &quot;RenderFlexibleBox.h&quot;
  90 #include &quot;RenderFragmentContainer.h&quot;
  91 #include &quot;RenderFragmentedFlow.h&quot;
  92 #include &quot;RenderGeometryMap.h&quot;
  93 #include &quot;RenderImage.h&quot;
  94 #include &quot;RenderInline.h&quot;
  95 #include &quot;RenderIterator.h&quot;
  96 #include &quot;RenderLayerBacking.h&quot;
  97 #include &quot;RenderLayerCompositor.h&quot;
  98 #include &quot;RenderLayerFilters.h&quot;
  99 #include &quot;RenderMarquee.h&quot;
 100 #include &quot;RenderMultiColumnFlow.h&quot;
 101 #include &quot;RenderReplica.h&quot;
 102 #include &quot;RenderSVGResourceClipper.h&quot;
 103 #include &quot;RenderSVGRoot.h&quot;
 104 #include &quot;RenderScrollbar.h&quot;
 105 #include &quot;RenderScrollbarPart.h&quot;
 106 #include &quot;RenderTableCell.h&quot;
 107 #include &quot;RenderTableRow.h&quot;
 108 #include &quot;RenderText.h&quot;
 109 #include &quot;RenderTheme.h&quot;
 110 #include &quot;RenderTreeAsText.h&quot;
 111 #include &quot;RenderView.h&quot;
 112 #include &quot;RuntimeEnabledFeatures.h&quot;
 113 #include &quot;SVGNames.h&quot;
 114 #include &quot;ScaleTransformOperation.h&quot;
 115 #include &quot;ScriptDisallowedScope.h&quot;
 116 #include &quot;ScrollAnimator.h&quot;
 117 #include &quot;Scrollbar.h&quot;
 118 #include &quot;ScrollbarTheme.h&quot;
 119 #include &quot;ScrollingCoordinator.h&quot;
 120 #include &quot;Settings.h&quot;
 121 #include &quot;ShadowRoot.h&quot;
 122 #include &quot;SourceGraphic.h&quot;
 123 #include &quot;StyleProperties.h&quot;
 124 #include &quot;StyleResolver.h&quot;
 125 #include &quot;TransformationMatrix.h&quot;
 126 #include &quot;TranslateTransformOperation.h&quot;
 127 #include &quot;WheelEventTestTrigger.h&quot;
 128 #include &lt;stdio.h&gt;
 129 #include &lt;wtf/MonotonicTime.h&gt;
 130 #include &lt;wtf/StdLibExtras.h&gt;
 131 #include &lt;wtf/text/CString.h&gt;
 132 #include &lt;wtf/text/TextStream.h&gt;
 133 
 134 #if ENABLE(CSS_SCROLL_SNAP)
 135 #include &quot;AxisScrollSnapOffsets.h&quot;
 136 #endif
 137 
 138 #define MIN_INTERSECT_FOR_REVEAL 32
 139 
 140 namespace WebCore {
 141 
 142 using namespace HTMLNames;
 143 
 144 class ClipRects : public RefCounted&lt;ClipRects&gt; {
 145     WTF_MAKE_FAST_ALLOCATED;
 146 public:
 147     static Ref&lt;ClipRects&gt; create()
 148     {
 149         return adoptRef(*new ClipRects);
 150     }
 151 
 152     static Ref&lt;ClipRects&gt; create(const ClipRects&amp; other)
 153     {
 154         return adoptRef(*new ClipRects(other));
 155     }
 156 
 157     void reset()
 158     {
 159         m_overflowClipRect.reset();
 160         m_fixedClipRect.reset();
 161         m_posClipRect.reset();
 162         m_fixed = false;
 163     }
 164 
 165     const ClipRect&amp; overflowClipRect() const { return m_overflowClipRect; }
 166     void setOverflowClipRect(const ClipRect&amp; clipRect) { m_overflowClipRect = clipRect; }
 167 
 168     const ClipRect&amp; fixedClipRect() const { return m_fixedClipRect; }
 169     void setFixedClipRect(const ClipRect&amp; clipRect) { m_fixedClipRect = clipRect; }
 170 
 171     const ClipRect&amp; posClipRect() const { return m_posClipRect; }
 172     void setPosClipRect(const ClipRect&amp; clipRect) { m_posClipRect = clipRect; }
 173 
 174     bool fixed() const { return m_fixed; }
 175     void setFixed(bool fixed) { m_fixed = fixed; }
 176 
 177     bool operator==(const ClipRects&amp; other) const
 178     {
 179         return m_overflowClipRect == other.overflowClipRect()
 180             &amp;&amp; m_fixedClipRect == other.fixedClipRect()
 181             &amp;&amp; m_posClipRect == other.posClipRect()
 182             &amp;&amp; m_fixed == other.fixed();
 183     }
 184 
 185     ClipRects&amp; operator=(const ClipRects&amp; other)
 186     {
 187         m_overflowClipRect = other.overflowClipRect();
 188         m_fixedClipRect = other.fixedClipRect();
 189         m_posClipRect = other.posClipRect();
 190         m_fixed = other.fixed();
 191         return *this;
 192     }
 193 
 194 private:
 195     ClipRects() = default;
 196 
 197     ClipRects(const LayoutRect&amp; clipRect)
 198         : m_overflowClipRect(clipRect)
 199         , m_fixedClipRect(clipRect)
 200         , m_posClipRect(clipRect)
 201     {
 202     }
 203 
 204     ClipRects(const ClipRects&amp; other)
 205         : RefCounted()
 206         , m_fixed(other.fixed())
 207         , m_overflowClipRect(other.overflowClipRect())
 208         , m_fixedClipRect(other.fixedClipRect())
 209         , m_posClipRect(other.posClipRect())
 210     {
 211     }
 212 
 213     bool m_fixed { false };
 214     ClipRect m_overflowClipRect;
 215     ClipRect m_fixedClipRect;
 216     ClipRect m_posClipRect;
 217 };
 218 
 219 class ClipRectsCache {
 220     WTF_MAKE_FAST_ALLOCATED;
 221 public:
 222     ClipRectsCache()
 223     {
 224 #ifndef NDEBUG
 225         for (int i = 0; i &lt; NumCachedClipRectsTypes; ++i) {
 226             m_clipRectsRoot[i] = 0;
 227             m_scrollbarRelevancy[i] = IgnoreOverlayScrollbarSize;
 228         }
 229 #endif
 230     }
 231 
 232     ClipRects* getClipRects(ClipRectsType clipRectsType, ShouldRespectOverflowClip respectOverflow) const
 233     {
 234         return m_clipRects[getIndex(clipRectsType, respectOverflow)].get();
 235     }
 236 
 237     void setClipRects(ClipRectsType clipRectsType, ShouldRespectOverflowClip respectOverflow, RefPtr&lt;ClipRects&gt;&amp;&amp; clipRects)
 238     {
 239         m_clipRects[getIndex(clipRectsType, respectOverflow)] = WTFMove(clipRects);
 240     }
 241 
 242 #ifndef NDEBUG
 243     const RenderLayer* m_clipRectsRoot[NumCachedClipRectsTypes];
 244     OverlayScrollbarSizeRelevancy m_scrollbarRelevancy[NumCachedClipRectsTypes];
 245 #endif
 246 
 247 private:
 248     unsigned getIndex(ClipRectsType clipRectsType, ShouldRespectOverflowClip respectOverflow) const
 249     {
 250         unsigned index = static_cast&lt;unsigned&gt;(clipRectsType);
 251         if (respectOverflow == RespectOverflowClip)
 252             index += static_cast&lt;unsigned&gt;(NumCachedClipRectsTypes);
 253         ASSERT_WITH_SECURITY_IMPLICATION(index &lt; NumCachedClipRectsTypes * 2);
 254         return index;
 255     }
 256 
 257     RefPtr&lt;ClipRects&gt; m_clipRects[NumCachedClipRectsTypes * 2];
 258 };
 259 
 260 void makeMatrixRenderable(TransformationMatrix&amp; matrix, bool has3DRendering)
 261 {
 262 #if !ENABLE(3D_TRANSFORMS)
 263     UNUSED_PARAM(has3DRendering);
 264     matrix.makeAffine();
 265 #else
 266     if (!has3DRendering)
 267         matrix.makeAffine();
 268 #endif
 269 }
 270 
 271 RenderLayer::RenderLayer(RenderLayerModelObject&amp; rendererLayerModelObject)
 272     : m_isRenderViewLayer(rendererLayerModelObject.isRenderView())
 273     , m_forcedStackingContext(rendererLayerModelObject.isMedia())
 274     , m_zOrderListsDirty(false)
 275     , m_normalFlowListDirty(true)
 276     , m_hadNegativeZOrderList(false)
 277     , m_inResizeMode(false)
 278     , m_scrollDimensionsDirty(true)
 279     , m_hasSelfPaintingLayerDescendant(false)
 280     , m_hasSelfPaintingLayerDescendantDirty(false)
 281     , m_usedTransparency(false)
 282     , m_paintingInsideReflection(false)
 283     , m_inOverflowRelayout(false)
 284     , m_repaintStatus(NeedsNormalRepaint)
 285     , m_visibleContentStatusDirty(true)
 286     , m_hasVisibleContent(false)
 287     , m_visibleDescendantStatusDirty(false)
 288     , m_hasVisibleDescendant(false)
 289     , m_registeredScrollableArea(false)
 290     , m_isFixedIntersectingViewport(false)
 291     , m_3DTransformedDescendantStatusDirty(true)
 292     , m_has3DTransformedDescendant(false)
 293     , m_hasCompositingDescendant(false)
 294     , m_hasTransformedAncestor(false)
 295     , m_has3DTransformedAncestor(false)
 296     , m_indirectCompositingReason(static_cast&lt;unsigned&gt;(IndirectCompositingReason::None))
 297     , m_viewportConstrainedNotCompositedReason(NoNotCompositedReason)
 298 #if PLATFORM(IOS_FAMILY)
 299 #if ENABLE(IOS_TOUCH_EVENTS)
 300     , m_registeredAsTouchEventListenerForScrolling(false)
 301 #endif
 302     , m_adjustForIOSCaretWhenScrolling(false)
 303 #endif
 304     , m_inUserScroll(false)
 305     , m_requiresScrollPositionReconciliation(false)
 306     , m_containsDirtyOverlayScrollbars(false)
 307     , m_updatingMarqueePosition(false)
 308 #if !ASSERT_DISABLED
 309     , m_layerListMutationAllowed(true)
 310 #endif
 311 #if ENABLE(CSS_COMPOSITING)
 312     , m_blendMode(static_cast&lt;unsigned&gt;(BlendMode::Normal))
 313     , m_hasNotIsolatedCompositedBlendingDescendants(false)
 314     , m_hasNotIsolatedBlendingDescendants(false)
 315     , m_hasNotIsolatedBlendingDescendantsStatusDirty(false)
 316 #endif
 317     , m_renderer(rendererLayerModelObject)
 318 {
 319     setIsNormalFlowOnly(shouldBeNormalFlowOnly());
 320     setIsStackingContext(shouldBeStackingContext());
 321 
 322     m_isSelfPaintingLayer = shouldBeSelfPaintingLayer();
 323 
 324     if (!renderer().firstChild()) {
 325         m_visibleContentStatusDirty = false;
 326         m_hasVisibleContent = renderer().style().visibility() == Visibility::Visible;
 327     }
 328 
 329     if (Element* element = renderer().element()) {
 330         // We save and restore only the scrollOffset as the other scroll values are recalculated.
 331         m_scrollPosition = element-&gt;savedLayerScrollPosition();
 332         if (!m_scrollPosition.isZero())
 333             scrollAnimator().setCurrentPosition(m_scrollPosition);
 334         element-&gt;setSavedLayerScrollPosition(IntPoint());
 335     }
 336 }
 337 
 338 RenderLayer::~RenderLayer()
 339 {
 340     if (inResizeMode())
 341         renderer().frame().eventHandler().resizeLayerDestroyed();
 342 
 343     ASSERT(m_registeredScrollableArea == renderer().view().frameView().containsScrollableArea(this));
 344 
 345     if (m_registeredScrollableArea)
 346         renderer().view().frameView().removeScrollableArea(this);
 347 
 348 #if ENABLE(IOS_TOUCH_EVENTS)
 349     unregisterAsTouchEventListenerForScrolling();
 350 #endif
 351     if (Element* element = renderer().element())
 352         element-&gt;setSavedLayerScrollPosition(m_scrollPosition);
 353 
 354     destroyScrollbar(HorizontalScrollbar);
 355     destroyScrollbar(VerticalScrollbar);
 356 
 357     if (auto* scrollingCoordinator = renderer().page().scrollingCoordinator())
 358         scrollingCoordinator-&gt;willDestroyScrollableArea(*this);
 359 
 360     if (m_reflection)
 361         removeReflection();
 362 
 363     clearScrollCorner();
 364     clearResizer();
 365 
 366     clearLayerFilters();
 367 
 368     // Child layers will be deleted by their corresponding render objects, so
 369     // we don&#39;t need to delete them ourselves.
 370 
 371     clearBacking(true);
 372 
 373     // Layer and all its children should be removed from the tree before destruction.
 374     RELEASE_ASSERT_WITH_SECURITY_IMPLICATION(renderer().renderTreeBeingDestroyed() || !parent());
 375     RELEASE_ASSERT_WITH_SECURITY_IMPLICATION(renderer().renderTreeBeingDestroyed() || !firstChild());
 376 }
 377 
 378 void RenderLayer::addChild(RenderLayer&amp; child, RenderLayer* beforeChild)
 379 {
 380     RenderLayer* prevSibling = beforeChild ? beforeChild-&gt;previousSibling() : lastChild();
 381     if (prevSibling) {
 382         child.setPreviousSibling(prevSibling);
 383         prevSibling-&gt;setNextSibling(&amp;child);
 384         ASSERT(prevSibling != &amp;child);
 385     } else
 386         setFirstChild(&amp;child);
 387 
 388     if (beforeChild) {
 389         beforeChild-&gt;setPreviousSibling(&amp;child);
 390         child.setNextSibling(beforeChild);
 391         ASSERT(beforeChild != &amp;child);
 392     } else
 393         setLastChild(&amp;child);
 394 
 395     child.setParent(this);
 396 
 397     dirtyPaintOrderListsOnChildChange(child);
 398 
 399     child.updateDescendantDependentFlags();
 400     if (child.m_hasVisibleContent || child.m_hasVisibleDescendant)
 401         setAncestorChainHasVisibleDescendant();
 402 
 403     if (child.isSelfPaintingLayer() || child.hasSelfPaintingLayerDescendant())
 404         setAncestorChainHasSelfPaintingLayerDescendant();
 405 
 406     if (compositor().hasContentCompositingLayers())
 407         setDescendantsNeedCompositingRequirementsTraversal();
 408 
 409     if (child.hasDescendantNeedingCompositingRequirementsTraversal() || child.needsCompositingRequirementsTraversal())
 410         child.setAncestorsHaveCompositingDirtyFlag(Compositing::HasDescendantNeedingRequirementsTraversal);
 411 
 412     if (child.hasDescendantNeedingUpdateBackingOrHierarchyTraversal() || child.needsUpdateBackingOrHierarchyTraversal())
 413         child.setAncestorsHaveCompositingDirtyFlag(Compositing::HasDescendantNeedingBackingOrHierarchyTraversal);
 414 
 415 #if ENABLE(CSS_COMPOSITING)
 416     if (child.hasBlendMode() || (child.hasNotIsolatedBlendingDescendants() &amp;&amp; !child.isolatesBlending()))
 417         updateAncestorChainHasBlendingDescendants(); // Why not just dirty?
 418 #endif
 419 
 420     compositor().layerWasAdded(*this, child);
 421 }
 422 
 423 void RenderLayer::removeChild(RenderLayer&amp; oldChild)
 424 {
 425     if (!renderer().renderTreeBeingDestroyed())
 426         compositor().layerWillBeRemoved(*this, oldChild);
 427 
 428     // remove the child
 429     if (oldChild.previousSibling())
 430         oldChild.previousSibling()-&gt;setNextSibling(oldChild.nextSibling());
 431     if (oldChild.nextSibling())
 432         oldChild.nextSibling()-&gt;setPreviousSibling(oldChild.previousSibling());
 433 
 434     if (m_first == &amp;oldChild)
 435         m_first = oldChild.nextSibling();
 436     if (m_last == &amp;oldChild)
 437         m_last = oldChild.previousSibling();
 438 
 439     dirtyPaintOrderListsOnChildChange(oldChild);
 440 
 441     oldChild.setPreviousSibling(nullptr);
 442     oldChild.setNextSibling(nullptr);
 443     oldChild.setParent(nullptr);
 444 
 445     oldChild.updateDescendantDependentFlags();
 446     if (oldChild.m_hasVisibleContent || oldChild.m_hasVisibleDescendant)
 447         dirtyAncestorChainVisibleDescendantStatus();
 448 
 449     if (oldChild.isSelfPaintingLayer() || oldChild.hasSelfPaintingLayerDescendant())
 450         dirtyAncestorChainHasSelfPaintingLayerDescendantStatus();
 451 
 452     if (compositor().hasContentCompositingLayers())
 453         setDescendantsNeedCompositingRequirementsTraversal();
 454 
 455 #if ENABLE(CSS_COMPOSITING)
 456     if (oldChild.hasBlendMode() || (oldChild.hasNotIsolatedBlendingDescendants() &amp;&amp; !oldChild.isolatesBlending()))
 457         dirtyAncestorChainHasBlendingDescendants();
 458 #endif
 459 }
 460 
 461 void RenderLayer::dirtyPaintOrderListsOnChildChange(RenderLayer&amp; child)
 462 {
 463     if (child.isNormalFlowOnly())
 464         dirtyNormalFlowList();
 465 
 466     if (!child.isNormalFlowOnly() || child.firstChild()) {
 467         // Dirty the z-order list in which we are contained. The stackingContext() can be null in the
 468         // case where we&#39;re building up generated content layers. This is ok, since the lists will start
 469         // off dirty in that case anyway.
 470         child.dirtyStackingContextZOrderLists();
 471     }
 472 }
 473 
 474 void RenderLayer::insertOnlyThisLayer()
 475 {
 476     if (!m_parent &amp;&amp; renderer().parent()) {
 477         // We need to connect ourselves when our renderer() has a parent.
 478         // Find our enclosingLayer and add ourselves.
 479         RenderLayer* parentLayer = renderer().parent()-&gt;enclosingLayer();
 480         ASSERT(parentLayer);
 481         RenderLayer* beforeChild = parentLayer-&gt;reflectionLayer() != this ? renderer().parent()-&gt;findNextLayer(parentLayer, &amp;renderer()) : nullptr;
 482         parentLayer-&gt;addChild(*this, beforeChild);
 483     }
 484 
 485     // Remove all descendant layers from the hierarchy and add them to the new position.
 486     for (auto&amp; child : childrenOfType&lt;RenderElement&gt;(renderer()))
 487         child.moveLayers(m_parent, this);
 488 
 489     // Clear out all the clip rects.
 490     clearClipRectsIncludingDescendants();
 491 }
 492 
 493 void RenderLayer::removeOnlyThisLayer()
 494 {
 495     if (!m_parent)
 496         return;
 497 
 498     // Mark that we are about to lose our layer. This makes render tree
 499     // walks ignore this layer while we&#39;re removing it.
 500     renderer().setHasLayer(false);
 501 
 502     compositor().layerWillBeRemoved(*m_parent, *this);
 503 
 504     // Dirty the clip rects.
 505     clearClipRectsIncludingDescendants();
 506 
 507     RenderLayer* nextSib = nextSibling();
 508 
 509     // Remove the child reflection layer before moving other child layers.
 510     // The reflection layer should not be moved to the parent.
 511     if (reflection())
 512         removeChild(*reflectionLayer());
 513 
 514     // Now walk our kids and reattach them to our parent.
 515     RenderLayer* current = m_first;
 516     while (current) {
 517         RenderLayer* next = current-&gt;nextSibling();
 518         removeChild(*current);
 519         m_parent-&gt;addChild(*current, nextSib);
 520         current-&gt;setRepaintStatus(NeedsFullRepaint);
 521         current = next;
 522     }
 523 
 524     // Remove us from the parent.
 525     m_parent-&gt;removeChild(*this);
 526     renderer().destroyLayer();
 527 }
 528 
 529 static bool canCreateStackingContext(const RenderLayer&amp; layer)
 530 {
 531     auto&amp; renderer = layer.renderer();
 532     return renderer.hasTransformRelatedProperty()
 533         || renderer.hasClipPath()
 534         || renderer.hasFilter()
 535         || renderer.hasMask()
 536         || renderer.hasBackdropFilter()
 537 #if ENABLE(CSS_COMPOSITING)
 538         || renderer.hasBlendMode()
 539 #endif
 540         || renderer.isTransparent()
 541         || renderer.isPositioned() // Note that this only creates stacking context in conjunction with explicit z-index.
 542         || renderer.hasReflection()
 543         || renderer.style().hasIsolation()
 544         || !renderer.style().hasAutoZIndex()
 545         || (renderer.style().willChange() &amp;&amp; renderer.style().willChange()-&gt;canCreateStackingContext());
 546 }
 547 
 548 bool RenderLayer::shouldBeNormalFlowOnly() const
 549 {
 550     if (canCreateStackingContext(*this))
 551         return false;
 552 
 553     return renderer().hasOverflowClip()
 554         || renderer().isCanvas()
 555         || renderer().isVideo()
 556         || renderer().isEmbeddedObject()
 557         || renderer().isRenderIFrame()
 558         || (renderer().isRenderImage() &amp;&amp; downcast&lt;RenderImage&gt;(renderer()).isEditableImage())
 559         || (renderer().style().specifiesColumns() &amp;&amp; !isRenderViewLayer())
 560         || renderer().isInFlowRenderFragmentedFlow();
 561 }
 562 
 563 bool RenderLayer::shouldBeStackingContext() const
 564 {
 565     return !renderer().style().hasAutoZIndex() || isRenderViewLayer() || isForcedStackingContext();
 566 }
 567 
 568 bool RenderLayer::setIsNormalFlowOnly(bool isNormalFlowOnly)
 569 {
 570     if (isNormalFlowOnly == m_isNormalFlowOnly)
 571         return false;
 572 
 573     m_isNormalFlowOnly = isNormalFlowOnly;
 574 
 575     if (auto* p = parent())
 576         p-&gt;dirtyNormalFlowList();
 577     dirtyStackingContextZOrderLists();
 578     return true;
 579 }
 580 
 581 bool RenderLayer::setIsStackingContext(bool isStackingContext)
 582 {
 583     if (isStackingContext == m_isStackingContext)
 584         return false;
 585 
 586     m_isStackingContext = isStackingContext;
 587 
 588     dirtyStackingContextZOrderLists();
 589     if (isStackingContext)
 590         dirtyZOrderLists();
 591     else
 592         clearZOrderLists();
 593 
 594     return true;
 595 }
 596 
 597 void RenderLayer::setParent(RenderLayer* parent)
 598 {
 599     if (parent == m_parent)
 600         return;
 601 
 602     if (m_parent &amp;&amp; !renderer().renderTreeBeingDestroyed())
 603         compositor().layerWillBeRemoved(*m_parent, *this);
 604 
 605     m_parent = parent;
 606 
 607     if (m_parent &amp;&amp; !renderer().renderTreeBeingDestroyed())
 608         compositor().layerWasAdded(*m_parent, *this);
 609 }
 610 
 611 RenderLayer* RenderLayer::stackingContext() const
 612 {
 613     auto* layer = parent();
 614     while (layer &amp;&amp; !layer-&gt;isStackingContext())
 615         layer = layer-&gt;parent();
 616 
 617     ASSERT(!layer || layer-&gt;isStackingContext());
 618     return layer;
 619 }
 620 
 621 void RenderLayer::dirtyZOrderLists()
 622 {
 623     ASSERT(layerListMutationAllowed());
 624     ASSERT(isStackingContext());
 625 
 626     if (m_posZOrderList)
 627         m_posZOrderList-&gt;clear();
 628     if (m_negZOrderList)
 629         m_negZOrderList-&gt;clear();
 630     m_zOrderListsDirty = true;
 631 
 632     // FIXME: Ideally, we&#39;d only dirty if the lists changed.
 633     if (hasCompositingDescendant())
 634         setNeedsCompositingPaintOrderChildrenUpdate();
 635 }
 636 
 637 void RenderLayer::dirtyStackingContextZOrderLists()
 638 {
 639     if (auto* sc = stackingContext())
 640         sc-&gt;dirtyZOrderLists();
 641 }
 642 
 643 void RenderLayer::dirtyNormalFlowList()
 644 {
 645     ASSERT(layerListMutationAllowed());
 646 
 647     if (m_normalFlowList)
 648         m_normalFlowList-&gt;clear();
 649     m_normalFlowListDirty = true;
 650 
 651     if (hasCompositingDescendant())
 652         setNeedsCompositingPaintOrderChildrenUpdate();
 653 }
 654 
 655 void RenderLayer::updateNormalFlowList()
 656 {
 657     if (!m_normalFlowListDirty)
 658         return;
 659 
 660     ASSERT(layerListMutationAllowed());
 661 
 662     for (RenderLayer* child = firstChild(); child; child = child-&gt;nextSibling()) {
 663         // Ignore non-overflow layers and reflections.
 664         if (child-&gt;isNormalFlowOnly() &amp;&amp; !isReflectionLayer(*child)) {
 665             if (!m_normalFlowList)
 666                 m_normalFlowList = std::make_unique&lt;Vector&lt;RenderLayer*&gt;&gt;();
 667             m_normalFlowList-&gt;append(child);
 668         }
 669     }
 670 
 671     m_normalFlowListDirty = false;
 672 }
 673 
 674 void RenderLayer::rebuildZOrderLists()
 675 {
 676     ASSERT(layerListMutationAllowed());
 677     ASSERT(isDirtyStackingContext());
 678     rebuildZOrderLists(m_posZOrderList, m_negZOrderList);
 679     m_zOrderListsDirty = false;
 680 
 681     bool hasNegativeZOrderList = m_negZOrderList &amp;&amp; m_negZOrderList-&gt;size();
 682     // Having negative z-order lists affect whether a compositing layer needs a foreground layer.
 683     // Ideally we&#39;d only trigger this when having z-order children changes, but we blow away the old z-order
 684     // lists on dirtying so we don&#39;t know the old state.
 685     if (hasNegativeZOrderList != m_hadNegativeZOrderList) {
 686         m_hadNegativeZOrderList = hasNegativeZOrderList;
 687         if (isComposited())
 688             setNeedsCompositingConfigurationUpdate();
 689     }
 690 }
 691 
 692 void RenderLayer::rebuildZOrderLists(std::unique_ptr&lt;Vector&lt;RenderLayer*&gt;&gt;&amp; posZOrderList, std::unique_ptr&lt;Vector&lt;RenderLayer*&gt;&gt;&amp; negZOrderList)
 693 {
 694     bool includeHiddenLayers = compositor().usesCompositing();
 695     for (RenderLayer* child = firstChild(); child; child = child-&gt;nextSibling()) {
 696         if (!isReflectionLayer(*child))
 697             child-&gt;collectLayers(includeHiddenLayers, posZOrderList, negZOrderList);
 698     }
 699 
 700     auto compareZIndex = [] (const RenderLayer* first, const RenderLayer* second) -&gt; bool {
 701         return first-&gt;zIndex() &lt; second-&gt;zIndex();
 702     };
 703 
 704     // Sort the two lists.
 705     if (posZOrderList)
 706         std::stable_sort(posZOrderList-&gt;begin(), posZOrderList-&gt;end(), compareZIndex);
 707 
 708     if (negZOrderList)
 709         std::stable_sort(negZOrderList-&gt;begin(), negZOrderList-&gt;end(), compareZIndex);
 710 }
 711 
 712 void RenderLayer::collectLayers(bool includeHiddenLayers, std::unique_ptr&lt;Vector&lt;RenderLayer*&gt;&gt;&amp; positiveZOrderList, std::unique_ptr&lt;Vector&lt;RenderLayer*&gt;&gt;&amp; negativeZOrderList)
 713 {
 714     updateDescendantDependentFlags();
 715 
 716     bool isStacking = isStackingContext();
 717     // Overflow layers are just painted by their enclosing layers, so they don&#39;t get put in zorder lists.
 718     bool includeHiddenLayer = includeHiddenLayers || (m_hasVisibleContent || (m_hasVisibleDescendant &amp;&amp; isStacking));
 719     if (includeHiddenLayer &amp;&amp; !isNormalFlowOnly()) {
 720         auto&amp; layerList = (zIndex() &gt;= 0) ? positiveZOrderList : negativeZOrderList;
 721         if (!layerList)
 722             layerList = std::make_unique&lt;Vector&lt;RenderLayer*&gt;&gt;();
 723         layerList-&gt;append(this);
 724     }
 725 
 726     // Recur into our children to collect more layers, but only if we don&#39;t establish
 727     // a stacking context/container.
 728     if ((includeHiddenLayers || m_hasVisibleDescendant) &amp;&amp; !isStacking) {
 729         for (RenderLayer* child = firstChild(); child; child = child-&gt;nextSibling()) {
 730             // Ignore reflections.
 731             if (!isReflectionLayer(*child))
 732                 child-&gt;collectLayers(includeHiddenLayers, positiveZOrderList, negativeZOrderList);
 733         }
 734     }
 735 }
 736 
 737 void RenderLayer::setAncestorsHaveCompositingDirtyFlag(Compositing flag)
 738 {
 739     for (auto* layer = paintOrderParent(); layer; layer = layer-&gt;paintOrderParent()) {
 740         if (layer-&gt;m_compositingDirtyBits.contains(flag))
 741             break;
 742         layer-&gt;m_compositingDirtyBits.add(flag);
 743     }
 744 }
 745 
 746 void RenderLayer::updateLayerListsIfNeeded()
 747 {
 748     updateZOrderLists();
 749     updateNormalFlowList();
 750 
 751     if (RenderLayer* reflectionLayer = this-&gt;reflectionLayer()) {
 752         reflectionLayer-&gt;updateZOrderLists();
 753         reflectionLayer-&gt;updateNormalFlowList();
 754     }
 755 }
 756 
 757 String RenderLayer::name() const
 758 {
 759     StringBuilder name;
 760 
 761     if (Element* element = renderer().element()) {
 762         name.append(&quot; &lt;&quot;);
 763         name.append(element-&gt;tagName().convertToLowercaseWithoutLocale());
 764         name.append(&#39;&gt;&#39;);
 765 
 766         if (element-&gt;hasID()) {
 767             name.appendLiteral(&quot; id=\&#39;&quot;);
 768             name.append(element-&gt;getIdAttribute());
 769             name.append(&#39;\&#39;&#39;);
 770         }
 771 
 772         if (element-&gt;hasClass()) {
 773             name.appendLiteral(&quot; class=\&#39;&quot;);
 774             size_t classNamesToDump = element-&gt;classNames().size();
 775             const size_t maxNumClassNames = 7;
 776             bool addEllipsis = false;
 777             if (classNamesToDump &gt; maxNumClassNames) {
 778                 classNamesToDump = maxNumClassNames;
 779                 addEllipsis = true;
 780             }
 781 
 782             for (size_t i = 0; i &lt; classNamesToDump; ++i) {
 783                 if (i &gt; 0)
 784                     name.append(&#39; &#39;);
 785                 name.append(element-&gt;classNames()[i]);
 786             }
 787             if (addEllipsis)
 788                 name.append(&quot;...&quot;);
 789             name.append(&#39;\&#39;&#39;);
 790         }
 791     } else
 792         name.append(renderer().renderName());
 793 
 794     if (isReflection())
 795         name.appendLiteral(&quot; (reflection)&quot;);
 796 
 797     return name.toString();
 798 }
 799 
 800 RenderLayerCompositor&amp; RenderLayer::compositor() const
 801 {
 802     return renderer().view().compositor();
 803 }
 804 
 805 void RenderLayer::contentChanged(ContentChangeType changeType)
 806 {
 807     if (changeType == CanvasChanged || changeType == VideoChanged || changeType == FullScreenChanged || (isComposited() &amp;&amp; changeType == ImageChanged)) {
 808         setNeedsPostLayoutCompositingUpdate();
 809         setNeedsCompositingConfigurationUpdate();
 810     }
 811 
 812     if (auto* backing = this-&gt;backing())
 813         backing-&gt;contentChanged(changeType);
 814 }
 815 
 816 bool RenderLayer::canRender3DTransforms() const
 817 {
 818     return compositor().canRender3DTransforms();
 819 }
 820 
 821 bool RenderLayer::paintsWithFilters() const
 822 {
 823     if (!renderer().hasFilter())
 824         return false;
 825 
 826     if (!isComposited())
 827         return true;
 828 
 829     return !m_backing-&gt;canCompositeFilters();
 830 }
 831 
 832 bool RenderLayer::requiresFullLayerImageForFilters() const
 833 {
 834     if (!paintsWithFilters())
 835         return false;
 836 
 837     return m_filters &amp;&amp; m_filters-&gt;hasFilterThatMovesPixels();
 838 }
 839 
 840 void RenderLayer::updateLayerPositionsAfterLayout(const RenderLayer* rootLayer, OptionSet&lt;UpdateLayerPositionsFlag&gt; flags)
 841 {
 842     LOG(Compositing, &quot;RenderLayer %p updateLayerPositionsAfterLayout&quot;, this);
 843     RenderGeometryMap geometryMap(UseTransforms);
 844     if (this != rootLayer)
 845         geometryMap.pushMappingsToAncestor(parent(), nullptr);
 846     updateLayerPositions(&amp;geometryMap, flags);
 847 }
 848 
 849 void RenderLayer::updateLayerPositions(RenderGeometryMap* geometryMap, OptionSet&lt;UpdateLayerPositionsFlag&gt; flags)
 850 {
 851     updateLayerPosition(); // For relpositioned layers or non-positioned layers,
 852                            // we need to keep in sync, since we may have shifted relative
 853                            // to our parent layer.
 854 
 855     applyPostLayoutScrollPositionIfNeeded();
 856 
 857     if (geometryMap)
 858         geometryMap-&gt;pushMappingsToAncestor(this, parent());
 859 
 860     // Clear our cached clip rect information.
 861     clearClipRects();
 862 
 863     if (hasOverflowControls()) {
 864         LayoutSize offsetFromRoot;
 865         if (geometryMap)
 866             offsetFromRoot = LayoutSize(toFloatSize(geometryMap-&gt;absolutePoint(FloatPoint())));
 867         else {
 868             // FIXME: It looks suspicious to call convertToLayerCoords here
 869             // as canUseConvertToLayerCoords may be true for an ancestor layer.
 870             offsetFromRoot = offsetFromAncestor(root());
 871         }
 872         positionOverflowControls(roundedIntSize(offsetFromRoot));
 873     }
 874 
 875     updateDescendantDependentFlags();
 876 
 877     if (flags &amp; UpdatePagination)
 878         updatePagination();
 879     else
 880         m_enclosingPaginationLayer = nullptr;
 881 
 882     if (m_hasVisibleContent) {
 883         // FIXME: Paint offset cache does not work with RenderLayers as there is not a 1-to-1
 884         // mapping between them and the RenderObjects. It would be neat to enable
 885         // LayoutState outside the layout() phase and use it here.
 886         ASSERT(!renderer().view().frameView().layoutContext().isPaintOffsetCacheEnabled());
 887 
 888         RenderLayerModelObject* repaintContainer = renderer().containerForRepaint();
 889 
 890         auto hadRepaintLayoutRects = renderer().hasRepaintLayoutRects();
 891         RepaintLayoutRects oldRects = hadRepaintLayoutRects ? renderer().repaintLayoutRects() : RepaintLayoutRects();
 892         computeRepaintRects(repaintContainer, geometryMap);
 893 
 894         auto hasRepaintLayoutRects = renderer().hasRepaintLayoutRects();
 895         RepaintLayoutRects newRects = hasRepaintLayoutRects ? renderer().repaintLayoutRects() : RepaintLayoutRects();
 896         // FIXME: Should ASSERT that value calculated for m_outlineBox using the cached offset is the same
 897         // as the value not using the cached offset, but we can&#39;t due to https://bugs.webkit.org/show_bug.cgi?id=37048
 898         if ((flags &amp; CheckForRepaint) &amp;&amp; hasRepaintLayoutRects) {
 899             if (!renderer().view().printing()) {
 900                 if (m_repaintStatus &amp; NeedsFullRepaint) {
 901                     if (hadRepaintLayoutRects)
 902                         renderer().repaintUsingContainer(repaintContainer, oldRects.m_repaintRect);
 903                     if (!hadRepaintLayoutRects || newRects.m_repaintRect != oldRects.m_repaintRect)
 904                         renderer().repaintUsingContainer(repaintContainer, newRects.m_repaintRect);
 905                 } else if (shouldRepaintAfterLayout()) {
 906                     // FIXME: We will convert this to just take the old and new RepaintLayoutRects once
 907                     // we change other callers to use RepaintLayoutRects.
 908                     renderer().repaintAfterLayoutIfNeeded(repaintContainer, oldRects.m_repaintRect, oldRects.m_outlineBox, &amp;newRects.m_repaintRect, &amp;newRects.m_outlineBox);
 909                 }
 910             }
 911         }
 912     } else
 913         clearRepaintRects();
 914 
 915     m_repaintStatus = NeedsNormalRepaint;
 916     m_hasTransformedAncestor = flags.contains(SeenTransformedLayer);
 917     m_has3DTransformedAncestor = flags.contains(Seen3DTransformedLayer);
 918 
 919     // Update the reflection&#39;s position and size.
 920     if (m_reflection)
 921         m_reflection-&gt;layout();
 922 
 923     if (renderer().isInFlowRenderFragmentedFlow()) {
 924         updatePagination();
 925         flags.add(UpdatePagination);
 926     }
 927 
 928     if (transform()) {
 929         flags.add(SeenTransformedLayer);
 930         if (!transform()-&gt;isAffine())
 931             flags.add(Seen3DTransformedLayer);
 932     }
 933 
 934     for (RenderLayer* child = firstChild(); child; child = child-&gt;nextSibling())
 935         child-&gt;updateLayerPositions(geometryMap, flags);
 936 
 937     // With all our children positioned, now update our marquee if we need to.
 938     if (m_marquee) {
 939         // FIXME: would like to use SetForScope&lt;&gt; but it doesn&#39;t work with bitfields.
 940         bool oldUpdatingMarqueePosition = m_updatingMarqueePosition;
 941         m_updatingMarqueePosition = true;
 942         m_marquee-&gt;updateMarqueePosition();
 943         m_updatingMarqueePosition = oldUpdatingMarqueePosition;
 944     }
 945 
 946     if (renderer().isOutOfFlowPositioned() &amp;&amp; renderer().style().position() == PositionType::Fixed &amp;&amp; renderer().settings().acceleratedCompositingForFixedPositionEnabled()) {
 947         bool intersectsViewport = compositor().fixedLayerIntersectsViewport(*this);
 948         if (intersectsViewport != m_isFixedIntersectingViewport) {
 949             m_isFixedIntersectingViewport = intersectsViewport;
 950             setNeedsPostLayoutCompositingUpdate();
 951         }
 952     }
 953 
 954     if (isComposited())
 955         backing()-&gt;updateAfterLayout(flags.contains(NeedsFullRepaintInBacking));
 956 
 957     if (geometryMap)
 958         geometryMap-&gt;popMappingsToAncestor(parent());
 959 
 960     renderer().document().markers().invalidateRectsForAllMarkers();
 961 }
 962 
 963 LayoutRect RenderLayer::repaintRectIncludingNonCompositingDescendants() const
 964 {
 965     LayoutRect repaintRect = renderer().repaintLayoutRects().m_repaintRect;
 966     for (RenderLayer* child = firstChild(); child; child = child-&gt;nextSibling()) {
 967         // Don&#39;t include repaint rects for composited child layers; they will paint themselves and have a different origin.
 968         if (child-&gt;isComposited())
 969             continue;
 970 
 971         repaintRect.uniteIfNonZero(child-&gt;repaintRectIncludingNonCompositingDescendants());
 972     }
 973     return repaintRect;
 974 }
 975 
 976 void RenderLayer::setAncestorChainHasSelfPaintingLayerDescendant()
 977 {
 978     for (RenderLayer* layer = this; layer; layer = layer-&gt;parent()) {
 979         if (!layer-&gt;m_hasSelfPaintingLayerDescendantDirty &amp;&amp; layer-&gt;hasSelfPaintingLayerDescendant())
 980             break;
 981 
 982         layer-&gt;m_hasSelfPaintingLayerDescendantDirty = false;
 983         layer-&gt;m_hasSelfPaintingLayerDescendant = true;
 984     }
 985 }
 986 
 987 void RenderLayer::dirtyAncestorChainHasSelfPaintingLayerDescendantStatus()
 988 {
 989     for (RenderLayer* layer = this; layer; layer = layer-&gt;parent()) {
 990         layer-&gt;m_hasSelfPaintingLayerDescendantDirty = true;
 991         // If we have reached a self-painting layer, we know our parent should have a self-painting descendant
 992         // in this case, there is no need to dirty our ancestors further.
 993         if (layer-&gt;isSelfPaintingLayer()) {
 994             ASSERT(!parent() || parent()-&gt;m_hasSelfPaintingLayerDescendantDirty || parent()-&gt;hasSelfPaintingLayerDescendant());
 995             break;
 996         }
 997     }
 998 }
 999 
1000 void RenderLayer::computeRepaintRects(const RenderLayerModelObject* repaintContainer, const RenderGeometryMap* geometryMap)
1001 {
1002     ASSERT(!m_visibleContentStatusDirty);
1003     renderer().computeRepaintLayoutRects(repaintContainer, geometryMap);
1004 }
1005 
1006 void RenderLayer::computeRepaintRectsIncludingDescendants()
1007 {
1008     // FIXME: computeRepaintRects() has to walk up the parent chain for every layer to compute the rects.
1009     // We should make this more efficient.
1010     // FIXME: it&#39;s wrong to call this when layout is not up-to-date, which we do.
1011     computeRepaintRects(renderer().containerForRepaint());
1012 
1013     for (RenderLayer* layer = firstChild(); layer; layer = layer-&gt;nextSibling())
1014         layer-&gt;computeRepaintRectsIncludingDescendants();
1015 }
1016 
1017 void RenderLayer::clearRepaintRects()
1018 {
1019     ASSERT(!m_visibleContentStatusDirty);
1020 
1021     renderer().clearRepaintLayoutRects();
1022 }
1023 
1024 void RenderLayer::updateLayerPositionsAfterDocumentScroll()
1025 {
1026     ASSERT(this == renderer().view().layer());
1027 
1028     LOG(Scrolling, &quot;RenderLayer::updateLayerPositionsAfterDocumentScroll&quot;);
1029 
1030     RenderGeometryMap geometryMap(UseTransforms);
1031     updateLayerPositionsAfterScroll(&amp;geometryMap);
1032 }
1033 
1034 void RenderLayer::updateLayerPositionsAfterOverflowScroll()
1035 {
1036     RenderGeometryMap geometryMap(UseTransforms);
1037     if (this != renderer().view().layer())
1038         geometryMap.pushMappingsToAncestor(parent(), nullptr);
1039 
1040     // FIXME: why is it OK to not check the ancestors of this layer in order to
1041     // initialize the HasSeenViewportConstrainedAncestor and HasSeenAncestorWithOverflowClip flags?
1042     updateLayerPositionsAfterScroll(&amp;geometryMap, IsOverflowScroll);
1043 }
1044 
1045 void RenderLayer::updateLayerPositionsAfterScroll(RenderGeometryMap* geometryMap, OptionSet&lt;UpdateLayerPositionsAfterScrollFlag&gt; flags)
1046 {
1047     // FIXME: This shouldn&#39;t be needed, but there are some corner cases where
1048     // these flags are still dirty. Update so that the check below is valid.
1049     updateDescendantDependentFlags();
1050 
1051     // If we have no visible content and no visible descendants, there is no point recomputing
1052     // our rectangles as they will be empty. If our visibility changes, we are expected to
1053     // recompute all our positions anyway.
1054     if (!m_hasVisibleDescendant &amp;&amp; !m_hasVisibleContent)
1055         return;
1056 
1057     bool positionChanged = updateLayerPosition();
1058     if (positionChanged)
1059         flags.add(HasChangedAncestor);
1060 
1061     if (flags.containsAny({ HasChangedAncestor, HasSeenViewportConstrainedAncestor, IsOverflowScroll }))
1062         clearClipRects();
1063 
1064     if (renderer().style().hasViewportConstrainedPosition())
1065         flags.add(HasSeenViewportConstrainedAncestor);
1066 
1067     if (renderer().hasOverflowClip())
1068         flags.add(HasSeenAncestorWithOverflowClip);
1069 
1070     bool shouldComputeRepaintRects = (flags.contains(HasSeenViewportConstrainedAncestor) || flags.containsAll({ IsOverflowScroll, HasSeenAncestorWithOverflowClip })) &amp;&amp; isSelfPaintingLayer();
1071     bool isVisuallyEmpty = !isVisuallyNonEmpty();
1072     bool shouldPushAndPopMappings = geometryMap &amp;&amp; ((shouldComputeRepaintRects &amp;&amp; !isVisuallyEmpty) || firstChild());
1073     if (shouldPushAndPopMappings)
1074         geometryMap-&gt;pushMappingsToAncestor(this, parent());
1075 
1076     if (shouldComputeRepaintRects) {
1077         // When scrolling, we don&#39;t compute repaint rects for visually non-empty layers.
1078         if (isVisuallyEmpty)
1079             clearRepaintRects();
1080         else // FIXME: We could track the repaint container as we walk down the tree.
1081             computeRepaintRects(renderer().containerForRepaint(), geometryMap);
1082     } else if (!renderer().view().frameView().platformWidget()) {
1083         // When ScrollView&#39;s m_paintsEntireContents flag flips due to layer backing changes, the repaint area transitions from
1084         // visual to layout overflow. When this happens the cached repaint rects become invalid and they need to be recomputed (see webkit.org/b/188121).
1085         // Check that our cached rects are correct.
1086         ASSERT(!renderer().hasRepaintLayoutRects() || renderer().repaintLayoutRects().m_repaintRect == renderer().clippedOverflowRectForRepaint(renderer().containerForRepaint()));
1087         ASSERT(!renderer().hasRepaintLayoutRects() || renderer().repaintLayoutRects().m_outlineBox == renderer().outlineBoundsForRepaint(renderer().containerForRepaint()));
1088     }
1089 
1090     for (RenderLayer* child = firstChild(); child; child = child-&gt;nextSibling())
1091         child-&gt;updateLayerPositionsAfterScroll(geometryMap, flags);
1092 
1093     // We don&#39;t update our reflection as scrolling is a translation which does not change the size()
1094     // of an object, thus RenderReplica will still repaint itself properly as the layer position was
1095     // updated above.
1096 
1097     if (m_marquee) {
1098         bool oldUpdatingMarqueePosition = m_updatingMarqueePosition;
1099         m_updatingMarqueePosition = true;
1100         m_marquee-&gt;updateMarqueePosition();
1101         m_updatingMarqueePosition = oldUpdatingMarqueePosition;
1102     }
1103 
1104     if (shouldPushAndPopMappings)
1105         geometryMap-&gt;popMappingsToAncestor(parent());
1106 
1107     renderer().document().markers().invalidateRectsForAllMarkers();
1108 }
1109 
1110 #if ENABLE(CSS_COMPOSITING)
1111 
1112 void RenderLayer::updateBlendMode()
1113 {
1114     bool hadBlendMode = static_cast&lt;BlendMode&gt;(m_blendMode) != BlendMode::Normal;
1115     if (parent() &amp;&amp; hadBlendMode != hasBlendMode()) {
1116         if (hasBlendMode())
1117             parent()-&gt;updateAncestorChainHasBlendingDescendants();
1118         else
1119             parent()-&gt;dirtyAncestorChainHasBlendingDescendants();
1120     }
1121 
1122     BlendMode newBlendMode = renderer().style().blendMode();
1123     if (newBlendMode != static_cast&lt;BlendMode&gt;(m_blendMode))
1124         m_blendMode = static_cast&lt;unsigned&gt;(newBlendMode);
1125 }
1126 
1127 void RenderLayer::updateAncestorChainHasBlendingDescendants()
1128 {
1129     for (auto* layer = this; layer; layer = layer-&gt;parent()) {
1130         if (!layer-&gt;hasNotIsolatedBlendingDescendantsStatusDirty() &amp;&amp; layer-&gt;hasNotIsolatedBlendingDescendants())
1131             break;
1132         layer-&gt;m_hasNotIsolatedBlendingDescendants = true;
1133         layer-&gt;m_hasNotIsolatedBlendingDescendantsStatusDirty = false;
1134 
1135         layer-&gt;updateSelfPaintingLayer();
1136 
1137         if (layer-&gt;isStackingContext())
1138             break;
1139     }
1140 }
1141 
1142 void RenderLayer::dirtyAncestorChainHasBlendingDescendants()
1143 {
1144     for (auto* layer = this; layer; layer = layer-&gt;parent()) {
1145         if (layer-&gt;hasNotIsolatedBlendingDescendantsStatusDirty())
1146             break;
1147 
1148         layer-&gt;m_hasNotIsolatedBlendingDescendantsStatusDirty = true;
1149 
1150         if (layer-&gt;isStackingContext())
1151             break;
1152     }
1153 }
1154 #endif
1155 
1156 void RenderLayer::updateTransform()
1157 {
1158     bool hasTransform = renderer().hasTransform();
1159     bool had3DTransform = has3DTransform();
1160 
1161     bool hadTransform = !!m_transform;
1162     if (hasTransform != hadTransform) {
1163         if (hasTransform)
1164             m_transform = std::make_unique&lt;TransformationMatrix&gt;();
1165         else
1166             m_transform = nullptr;
1167 
1168         // Layers with transforms act as clip rects roots, so clear the cached clip rects here.
1169         clearClipRectsIncludingDescendants();
1170     }
1171 
1172     if (hasTransform) {
1173         RenderBox* box = renderBox();
1174         ASSERT(box);
1175         m_transform-&gt;makeIdentity();
1176         box-&gt;style().applyTransform(*m_transform, snapRectToDevicePixels(box-&gt;borderBoxRect(), box-&gt;document().deviceScaleFactor()), RenderStyle::IncludeTransformOrigin);
1177         makeMatrixRenderable(*m_transform, canRender3DTransforms());
1178     }
1179 
1180     if (had3DTransform != has3DTransform()) {
1181         dirty3DTransformedDescendantStatus();
1182         // Having a 3D transform affects whether enclosing perspective and preserve-3d layers composite, so trigger an update.
1183         setNeedsPostLayoutCompositingUpdateOnAncestors();
1184     }
1185 }
1186 
1187 TransformationMatrix RenderLayer::currentTransform(RenderStyle::ApplyTransformOrigin applyOrigin) const
1188 {
1189     if (!m_transform)
1190         return TransformationMatrix();
1191 
1192     RenderBox* box = renderBox();
1193 
1194     if (RuntimeEnabledFeatures::sharedFeatures().webAnimationsCSSIntegrationEnabled()) {
1195         if (auto* timeline = renderer().documentTimeline()) {
1196             if (timeline-&gt;isRunningAcceleratedAnimationOnRenderer(renderer(), CSSPropertyTransform)) {
1197                 TransformationMatrix currTransform;
1198                 FloatRect pixelSnappedBorderRect = snapRectToDevicePixels(box-&gt;borderBoxRect(), box-&gt;document().deviceScaleFactor());
1199                 std::unique_ptr&lt;RenderStyle&gt; style = timeline-&gt;animatedStyleForRenderer(renderer());
1200                 style-&gt;applyTransform(currTransform, pixelSnappedBorderRect, applyOrigin);
1201                 makeMatrixRenderable(currTransform, canRender3DTransforms());
1202                 return currTransform;
1203             }
1204         }
1205     } else {
1206         if (renderer().animation().isRunningAcceleratedAnimationOnRenderer(renderer(), CSSPropertyTransform)) {
1207             TransformationMatrix currTransform;
1208             FloatRect pixelSnappedBorderRect = snapRectToDevicePixels(box-&gt;borderBoxRect(), box-&gt;document().deviceScaleFactor());
1209             std::unique_ptr&lt;RenderStyle&gt; style = renderer().animation().animatedStyleForRenderer(renderer());
1210             style-&gt;applyTransform(currTransform, pixelSnappedBorderRect, applyOrigin);
1211             makeMatrixRenderable(currTransform, canRender3DTransforms());
1212             return currTransform;
1213         }
1214     }
1215 
1216 
1217     // m_transform includes transform-origin, so we need to recompute the transform here.
1218     if (applyOrigin == RenderStyle::ExcludeTransformOrigin) {
1219         TransformationMatrix currTransform;
1220         FloatRect pixelSnappedBorderRect = snapRectToDevicePixels(box-&gt;borderBoxRect(), box-&gt;document().deviceScaleFactor());
1221         box-&gt;style().applyTransform(currTransform, pixelSnappedBorderRect, RenderStyle::ExcludeTransformOrigin);
1222         makeMatrixRenderable(currTransform, canRender3DTransforms());
1223         return currTransform;
1224     }
1225 
1226     return *m_transform;
1227 }
1228 
1229 TransformationMatrix RenderLayer::renderableTransform(OptionSet&lt;PaintBehavior&gt; paintBehavior) const
1230 {
1231     if (!m_transform)
1232         return TransformationMatrix();
1233 
1234     if (paintBehavior &amp; PaintBehavior::FlattenCompositingLayers) {
1235         TransformationMatrix matrix = *m_transform;
1236         makeMatrixRenderable(matrix, false /* flatten 3d */);
1237         return matrix;
1238     }
1239 
1240     return *m_transform;
1241 }
1242 
1243 RenderLayer* RenderLayer::enclosingOverflowClipLayer(IncludeSelfOrNot includeSelf) const
1244 {
1245     const RenderLayer* layer = (includeSelf == IncludeSelf) ? this : parent();
1246     while (layer) {
1247         if (layer-&gt;renderer().hasOverflowClip())
1248             return const_cast&lt;RenderLayer*&gt;(layer);
1249 
1250         layer = layer-&gt;parent();
1251     }
1252     return nullptr;
1253 }
1254 
1255 // FIXME: This is terrible. Bring back a cached bit for this someday. This crawl is going to slow down all
1256 // painting of content inside paginated layers.
1257 bool RenderLayer::hasCompositedLayerInEnclosingPaginationChain() const
1258 {
1259     // No enclosing layer means no compositing in the chain.
1260     if (!m_enclosingPaginationLayer)
1261         return false;
1262 
1263     // If the enclosing layer is composited, we don&#39;t have to check anything in between us and that
1264     // layer.
1265     if (m_enclosingPaginationLayer-&gt;isComposited())
1266         return true;
1267 
1268     // If we are the enclosing pagination layer, then we can&#39;t be composited or we&#39;d have passed the
1269     // previous check.
1270     if (m_enclosingPaginationLayer == this)
1271         return false;
1272 
1273     // The enclosing paginated layer is our ancestor and is not composited, so we have to check
1274     // intermediate layers between us and the enclosing pagination layer. Start with our own layer.
1275     if (isComposited())
1276         return true;
1277 
1278     // For normal flow layers, we can recur up the layer tree.
1279     if (isNormalFlowOnly())
1280         return parent()-&gt;hasCompositedLayerInEnclosingPaginationChain();
1281 
1282     // Otherwise we have to go up the containing block chain. Find the first enclosing
1283     // containing block layer ancestor, and check that.
1284     for (const auto* containingBlock = renderer().containingBlock(); containingBlock &amp;&amp; !is&lt;RenderView&gt;(*containingBlock); containingBlock = containingBlock-&gt;containingBlock()) {
1285         if (containingBlock-&gt;hasLayer())
1286             return containingBlock-&gt;layer()-&gt;hasCompositedLayerInEnclosingPaginationChain();
1287     }
1288     return false;
1289 }
1290 
1291 void RenderLayer::updatePagination()
1292 {
1293     m_enclosingPaginationLayer = nullptr;
1294 
1295     if (!parent())
1296         return;
1297 
1298     // Each layer that is inside a multicolumn flow thread has to be checked individually and
1299     // genuinely know if it is going to have to split itself up when painting only its contents (and not any other descendant
1300     // layers). We track an enclosingPaginationLayer instead of using a simple bit, since we want to be able to get back
1301     // to that layer easily.
1302     if (renderer().isInFlowRenderFragmentedFlow()) {
1303         m_enclosingPaginationLayer = makeWeakPtr(*this);
1304         return;
1305     }
1306 
1307     if (isNormalFlowOnly()) {
1308         // Content inside a transform is not considered to be paginated, since we simply
1309         // paint the transform multiple times in each column, so we don&#39;t have to use
1310         // fragments for the transformed content.
1311         if (parent()-&gt;hasTransform())
1312             m_enclosingPaginationLayer = nullptr;
1313         else
1314             m_enclosingPaginationLayer = makeWeakPtr(parent()-&gt;enclosingPaginationLayer(IncludeCompositedPaginatedLayers));
1315         return;
1316     }
1317 
1318     // For the new columns code, we want to walk up our containing block chain looking for an enclosing layer. Once
1319     // we find one, then we just check its pagination status.
1320     for (const auto* containingBlock = renderer().containingBlock(); containingBlock &amp;&amp; !is&lt;RenderView&gt;(*containingBlock); containingBlock = containingBlock-&gt;containingBlock()) {
1321         if (containingBlock-&gt;hasLayer()) {
1322             // Content inside a transform is not considered to be paginated, since we simply
1323             // paint the transform multiple times in each column, so we don&#39;t have to use
1324             // fragments for the transformed content.
1325             if (containingBlock-&gt;layer()-&gt;hasTransform())
1326                 m_enclosingPaginationLayer = nullptr;
1327             else
1328                 m_enclosingPaginationLayer = makeWeakPtr(containingBlock-&gt;layer()-&gt;enclosingPaginationLayer(IncludeCompositedPaginatedLayers));
1329             return;
1330         }
1331     }
1332 }
1333 
1334 void RenderLayer::setHasVisibleContent()
1335 {
1336     if (m_hasVisibleContent &amp;&amp; !m_visibleContentStatusDirty) {
1337         ASSERT(!parent() || parent()-&gt;hasVisibleDescendant());
1338         return;
1339     }
1340 
1341     m_visibleContentStatusDirty = false;
1342     m_hasVisibleContent = true;
1343     computeRepaintRects(renderer().containerForRepaint());
1344     if (!isNormalFlowOnly()) {
1345         // We don&#39;t collect invisible layers in z-order lists if we are not in compositing mode.
1346         // As we became visible, we need to dirty our stacking containers ancestors to be properly
1347         // collected. FIXME: When compositing, we could skip this dirtying phase.
1348         for (RenderLayer* sc = stackingContext(); sc; sc = sc-&gt;stackingContext()) {
1349             sc-&gt;dirtyZOrderLists();
1350             if (sc-&gt;hasVisibleContent())
1351                 break;
1352         }
1353     }
1354 
1355     if (parent())
1356         parent()-&gt;setAncestorChainHasVisibleDescendant();
1357 }
1358 
1359 void RenderLayer::dirtyVisibleContentStatus()
1360 {
1361     m_visibleContentStatusDirty = true;
1362     if (parent())
1363         parent()-&gt;dirtyAncestorChainVisibleDescendantStatus();
1364 }
1365 
1366 void RenderLayer::dirtyAncestorChainVisibleDescendantStatus()
1367 {
1368     for (RenderLayer* layer = this; layer; layer = layer-&gt;parent()) {
1369         if (layer-&gt;m_visibleDescendantStatusDirty)
1370             break;
1371 
1372         layer-&gt;m_visibleDescendantStatusDirty = true;
1373     }
1374 }
1375 
1376 void RenderLayer::setAncestorChainHasVisibleDescendant()
1377 {
1378     for (RenderLayer* layer = this; layer; layer = layer-&gt;parent()) {
1379         if (!layer-&gt;m_visibleDescendantStatusDirty &amp;&amp; layer-&gt;hasVisibleDescendant())
1380             break;
1381 
1382         layer-&gt;m_hasVisibleDescendant = true;
1383         layer-&gt;m_visibleDescendantStatusDirty = false;
1384     }
1385 }
1386 
1387 void RenderLayer::updateDescendantDependentFlags()
1388 {
1389     if (m_visibleDescendantStatusDirty || m_hasSelfPaintingLayerDescendantDirty || hasNotIsolatedBlendingDescendantsStatusDirty()) {
1390         bool hasVisibleDescendant = false;
1391         bool hasSelfPaintingLayerDescendant = false;
1392 #if ENABLE(CSS_COMPOSITING)
1393         bool hasNotIsolatedBlendingDescendants = false;
1394 #endif
1395 
1396         for (RenderLayer* child = firstChild(); child; child = child-&gt;nextSibling()) {
1397             child-&gt;updateDescendantDependentFlags();
1398 
1399             hasVisibleDescendant |= child-&gt;m_hasVisibleContent || child-&gt;m_hasVisibleDescendant;
1400             hasSelfPaintingLayerDescendant |= child-&gt;isSelfPaintingLayer() || child-&gt;hasSelfPaintingLayerDescendant();
1401 #if ENABLE(CSS_COMPOSITING)
1402             hasNotIsolatedBlendingDescendants |= child-&gt;hasBlendMode() || (child-&gt;hasNotIsolatedBlendingDescendants() &amp;&amp; !child-&gt;isolatesBlending());
1403 #endif
1404 
1405             bool allFlagsSet = hasVisibleDescendant &amp;&amp; hasSelfPaintingLayerDescendant;
1406 #if ENABLE(CSS_COMPOSITING)
1407             allFlagsSet &amp;= hasNotIsolatedBlendingDescendants;
1408 #endif
1409             if (allFlagsSet)
1410                 break;
1411         }
1412 
1413         m_hasVisibleDescendant = hasVisibleDescendant;
1414         m_visibleDescendantStatusDirty = false;
1415         m_hasSelfPaintingLayerDescendant = hasSelfPaintingLayerDescendant;
1416         m_hasSelfPaintingLayerDescendantDirty = false;
1417 
1418 #if ENABLE(CSS_COMPOSITING)
1419         m_hasNotIsolatedBlendingDescendants = hasNotIsolatedBlendingDescendants;
1420         if (m_hasNotIsolatedBlendingDescendantsStatusDirty) {
1421             m_hasNotIsolatedBlendingDescendantsStatusDirty = false;
1422             updateSelfPaintingLayer();
1423         }
1424 #endif
1425     }
1426 
1427     if (m_visibleContentStatusDirty) {
1428         if (renderer().style().visibility() == Visibility::Visible)
1429             m_hasVisibleContent = true;
1430         else {
1431             // layer may be hidden but still have some visible content, check for this
1432             m_hasVisibleContent = false;
1433             RenderObject* r = renderer().firstChild();
1434             while (r) {
1435                 if (r-&gt;style().visibility() == Visibility::Visible &amp;&amp; !r-&gt;hasLayer()) {
1436                     m_hasVisibleContent = true;
1437                     break;
1438                 }
1439                 RenderObject* child = nullptr;
1440                 if (!r-&gt;hasLayer() &amp;&amp; (child = r-&gt;firstChildSlow()))
1441                     r = child;
1442                 else if (r-&gt;nextSibling())
1443                     r = r-&gt;nextSibling();
1444                 else {
1445                     do {
1446                         r = r-&gt;parent();
1447                         if (r == &amp;renderer())
1448                             r = nullptr;
1449                     } while (r &amp;&amp; !r-&gt;nextSibling());
1450                     if (r)
1451                         r = r-&gt;nextSibling();
1452                 }
1453             }
1454         }
1455         m_visibleContentStatusDirty = false;
1456     }
1457 }
1458 
1459 void RenderLayer::dirty3DTransformedDescendantStatus()
1460 {
1461     RenderLayer* curr = stackingContext();
1462     if (curr)
1463         curr-&gt;m_3DTransformedDescendantStatusDirty = true;
1464 
1465     // This propagates up through preserve-3d hierarchies to the enclosing flattening layer.
1466     // Note that preserves3D() creates stacking context, so we can just run up the stacking containers.
1467     while (curr &amp;&amp; curr-&gt;preserves3D()) {
1468         curr-&gt;m_3DTransformedDescendantStatusDirty = true;
1469         curr = curr-&gt;stackingContext();
1470     }
1471 }
1472 
1473 // Return true if this layer or any preserve-3d descendants have 3d.
1474 bool RenderLayer::update3DTransformedDescendantStatus()
1475 {
1476     if (m_3DTransformedDescendantStatusDirty) {
1477         m_has3DTransformedDescendant = false;
1478 
1479         updateZOrderLists();
1480 
1481         // Transformed or preserve-3d descendants can only be in the z-order lists, not
1482         // in the normal flow list, so we only need to check those.
1483         for (auto* layer : positiveZOrderLayers())
1484             m_has3DTransformedDescendant |= layer-&gt;update3DTransformedDescendantStatus();
1485 
1486         // Now check our negative z-index children.
1487         for (auto* layer : negativeZOrderLayers())
1488             m_has3DTransformedDescendant |= layer-&gt;update3DTransformedDescendantStatus();
1489 
1490         m_3DTransformedDescendantStatusDirty = false;
1491     }
1492 
1493     // If we live in a 3d hierarchy, then the layer at the root of that hierarchy needs
1494     // the m_has3DTransformedDescendant set.
1495     if (preserves3D())
1496         return has3DTransform() || m_has3DTransformedDescendant;
1497 
1498     return has3DTransform();
1499 }
1500 
1501 bool RenderLayer::updateLayerPosition()
1502 {
1503     LayoutPoint localPoint;
1504     LayoutSize inlineBoundingBoxOffset; // We don&#39;t put this into the RenderLayer x/y for inlines, so we need to subtract it out when done.
1505     if (renderer().isInline() &amp;&amp; is&lt;RenderInline&gt;(renderer())) {
1506         auto&amp; inlineFlow = downcast&lt;RenderInline&gt;(renderer());
1507         IntRect lineBox = inlineFlow.linesBoundingBox();
1508         setSize(lineBox.size());
1509         inlineBoundingBoxOffset = toLayoutSize(lineBox.location());
1510         localPoint += inlineBoundingBoxOffset;
1511     } else if (RenderBox* box = renderBox()) {
1512         // FIXME: Is snapping the size really needed here for the RenderBox case?
1513         auto newSize = snappedIntRect(box-&gt;frameRect()).size();
1514         if (newSize != size()) {
1515             if (is&lt;RenderWidget&gt;(*box) &amp;&amp; downcast&lt;RenderWidget&gt;(*box).requiresAcceleratedCompositing()) {
1516                 // Trigger RenderLayerCompositor::requiresCompositingForFrame() which depends on the contentBoxRect size.
1517                 setNeedsPostLayoutCompositingUpdate();
1518             }
1519             setSize(newSize);
1520         }
1521 
1522         box-&gt;applyTopLeftLocationOffset(localPoint);
1523     }
1524 
1525     if (!renderer().isOutOfFlowPositioned()) {
1526         auto* ancestor = renderer().parent();
1527         // We must adjust our position by walking up the render tree looking for the
1528         // nearest enclosing object with a layer.
1529         while (ancestor &amp;&amp; !ancestor-&gt;hasLayer()) {
1530             if (is&lt;RenderBox&gt;(*ancestor) &amp;&amp; !is&lt;RenderTableRow&gt;(*ancestor)) {
1531                 // Rows and cells share the same coordinate space (that of the section).
1532                 // Omit them when computing our xpos/ypos.
1533                 localPoint += downcast&lt;RenderBox&gt;(*ancestor).topLeftLocationOffset();
1534             }
1535             ancestor = ancestor-&gt;parent();
1536         }
1537         if (is&lt;RenderTableRow&gt;(ancestor)) {
1538             // Put ourselves into the row coordinate space.
1539             localPoint -= downcast&lt;RenderTableRow&gt;(*ancestor).topLeftLocationOffset();
1540         }
1541     }
1542 
1543     // Subtract our parent&#39;s scroll offset.
1544     RenderLayer* positionedParent;
1545     if (renderer().isOutOfFlowPositioned() &amp;&amp; (positionedParent = enclosingAncestorForPosition(renderer().style().position()))) {
1546         // For positioned layers, we subtract out the enclosing positioned layer&#39;s scroll offset.
1547         if (positionedParent-&gt;renderer().hasOverflowClip())
1548             localPoint -= toLayoutSize(positionedParent-&gt;scrollPosition());
1549 
1550         if (renderer().isOutOfFlowPositioned() &amp;&amp; positionedParent-&gt;renderer().isInFlowPositioned() &amp;&amp; is&lt;RenderInline&gt;(positionedParent-&gt;renderer())) {
1551             LayoutSize offset = downcast&lt;RenderInline&gt;(positionedParent-&gt;renderer()).offsetForInFlowPositionedInline(&amp;downcast&lt;RenderBox&gt;(renderer()));
1552             localPoint += offset;
1553         }
1554     } else if (parent()) {
1555         if (parent()-&gt;renderer().hasOverflowClip())
1556             localPoint -= toLayoutSize(parent()-&gt;scrollPosition());
1557     }
1558 
1559     bool positionOrOffsetChanged = false;
1560     if (renderer().isInFlowPositioned()) {
1561         LayoutSize newOffset = downcast&lt;RenderBoxModelObject&gt;(renderer()).offsetForInFlowPosition();
1562         positionOrOffsetChanged = newOffset != m_offsetForInFlowPosition;
1563         m_offsetForInFlowPosition = newOffset;
1564         localPoint.move(m_offsetForInFlowPosition);
1565     } else {
1566         m_offsetForInFlowPosition = LayoutSize();
1567     }
1568 
1569     // FIXME: We&#39;d really like to just get rid of the concept of a layer rectangle and rely on the renderers.
1570     localPoint -= inlineBoundingBoxOffset;
1571 
1572     positionOrOffsetChanged |= location() != localPoint;
1573     setLocation(localPoint);
1574 
1575     if (positionOrOffsetChanged &amp;&amp; compositor().hasContentCompositingLayers()) {
1576         if (isComposited())
1577             setNeedsCompositingGeometryUpdate();
1578         // This layer&#39;s position can affect the location of a composited descendant (which may be a sibling in z-order),
1579         // so trigger a descendant walk from the paint-order parent.
1580         if (auto* paintParent = paintOrderParent())
1581             paintParent-&gt;setDescendantsNeedUpdateBackingAndHierarchyTraversal();
1582     }
1583 
1584     return positionOrOffsetChanged;
1585 }
1586 
1587 TransformationMatrix RenderLayer::perspectiveTransform() const
1588 {
1589     RenderBox* box = renderBox();
1590     if (!box)
1591         return TransformationMatrix();
1592 
1593     if (!box-&gt;hasTransformRelatedProperty())
1594         return TransformationMatrix();
1595 
1596     const RenderStyle&amp; style = box-&gt;style();
1597     if (!style.hasPerspective())
1598         return TransformationMatrix();
1599 
1600     // Maybe fetch the perspective from the backing?
1601     const FloatRect borderBox = snapRectToDevicePixels(box-&gt;borderBoxRect(), box-&gt;document().deviceScaleFactor());
1602     float perspectiveOriginX = floatValueForLength(style.perspectiveOriginX(), borderBox.width());
1603     float perspectiveOriginY = floatValueForLength(style.perspectiveOriginY(), borderBox.height());
1604 
1605     // A perspective origin of 0,0 makes the vanishing point in the center of the element.
1606     // We want it to be in the top-left, so subtract half the height and width.
1607     perspectiveOriginX -= borderBox.width() / 2.0f;
1608     perspectiveOriginY -= borderBox.height() / 2.0f;
1609 
1610     TransformationMatrix t;
1611     t.translate(perspectiveOriginX, perspectiveOriginY);
1612     t.applyPerspective(style.perspective());
1613     t.translate(-perspectiveOriginX, -perspectiveOriginY);
1614 
1615     return t;
1616 }
1617 
1618 FloatPoint RenderLayer::perspectiveOrigin() const
1619 {
1620     if (!renderer().hasTransformRelatedProperty())
1621         return FloatPoint();
1622 
1623     const LayoutRect borderBox = downcast&lt;RenderBox&gt;(renderer()).borderBoxRect();
1624     const RenderStyle&amp; style = renderer().style();
1625 
1626     return FloatPoint(floatValueForLength(style.perspectiveOriginX(), borderBox.width()),
1627                       floatValueForLength(style.perspectiveOriginY(), borderBox.height()));
1628 }
1629 
1630 static inline bool isContainerForPositioned(RenderLayer&amp; layer, PositionType position)
1631 {
1632     switch (position) {
1633     case PositionType::Fixed:
1634         return layer.renderer().canContainFixedPositionObjects();
1635 
1636     case PositionType::Absolute:
1637         return layer.renderer().canContainAbsolutelyPositionedObjects();
1638 
1639     default:
1640         ASSERT_NOT_REACHED();
1641         return false;
1642     }
1643 }
1644 
1645 RenderLayer* RenderLayer::enclosingAncestorForPosition(PositionType position) const
1646 {
1647     RenderLayer* curr = parent();
1648     while (curr &amp;&amp; !isContainerForPositioned(*curr, position))
1649         curr = curr-&gt;parent();
1650 
1651     return curr;
1652 }
1653 
1654 static RenderLayer* parentLayerCrossFrame(const RenderLayer&amp; layer)
1655 {
1656     if (layer.parent())
1657         return layer.parent();
1658 
1659     HTMLFrameOwnerElement* ownerElement = layer.renderer().document().ownerElement();
1660     if (!ownerElement)
1661         return nullptr;
1662 
1663     RenderElement* ownerRenderer = ownerElement-&gt;renderer();
1664     if (!ownerRenderer)
1665         return nullptr;
1666 
1667     return ownerRenderer-&gt;enclosingLayer();
1668 }
1669 
1670 RenderLayer* RenderLayer::enclosingScrollableLayer() const
1671 {
1672     for (RenderLayer* nextLayer = parentLayerCrossFrame(*this); nextLayer; nextLayer = parentLayerCrossFrame(*nextLayer)) {
1673         if (is&lt;RenderBox&gt;(nextLayer-&gt;renderer()) &amp;&amp; downcast&lt;RenderBox&gt;(nextLayer-&gt;renderer()).canBeScrolledAndHasScrollableArea())
1674             return nextLayer;
1675     }
1676 
1677     return nullptr;
1678 }
1679 
1680 IntRect RenderLayer::scrollableAreaBoundingBox(bool* isInsideFixed) const
1681 {
1682     return renderer().absoluteBoundingBoxRect(/* useTransforms */ true, isInsideFixed);
1683 }
1684 
1685 bool RenderLayer::isRubberBandInProgress() const
1686 {
1687 #if ENABLE(RUBBER_BANDING)
1688     if (!scrollsOverflow())
1689         return false;
1690 
1691     if (ScrollAnimator* scrollAnimator = existingScrollAnimator())
1692         return scrollAnimator-&gt;isRubberBandInProgress();
1693 #endif
1694 
1695     return false;
1696 }
1697 
1698 bool RenderLayer::forceUpdateScrollbarsOnMainThreadForPerformanceTesting() const
1699 {
1700     return renderer().settings().forceUpdateScrollbarsOnMainThreadForPerformanceTesting();
1701 }
1702 
1703 RenderLayer* RenderLayer::enclosingTransformedAncestor() const
1704 {
1705     RenderLayer* curr = parent();
1706     while (curr &amp;&amp; !curr-&gt;isRenderViewLayer() &amp;&amp; !curr-&gt;transform())
1707         curr = curr-&gt;parent();
1708 
1709     return curr;
1710 }
1711 
1712 inline bool RenderLayer::shouldRepaintAfterLayout() const
1713 {
1714     if (m_repaintStatus == NeedsNormalRepaint)
1715         return true;
1716 
1717     // Composited layers that were moved during a positioned movement only
1718     // layout, don&#39;t need to be repainted. They just need to be recomposited.
1719     ASSERT(m_repaintStatus == NeedsFullRepaintForPositionedMovementLayout);
1720     return !isComposited() || backing()-&gt;paintsIntoCompositedAncestor();
1721 }
1722 
1723 bool compositedWithOwnBackingStore(const RenderLayer&amp; layer)
1724 {
1725     return layer.isComposited() &amp;&amp; !layer.backing()-&gt;paintsIntoCompositedAncestor();
1726 }
1727 
1728 RenderLayer* RenderLayer::enclosingCompositingLayer(IncludeSelfOrNot includeSelf) const
1729 {
1730     if (includeSelf == IncludeSelf &amp;&amp; isComposited())
1731         return const_cast&lt;RenderLayer*&gt;(this);
1732 
1733     for (const RenderLayer* curr = paintOrderParent(); curr; curr = curr-&gt;paintOrderParent()) {
1734         if (curr-&gt;isComposited())
1735             return const_cast&lt;RenderLayer*&gt;(curr);
1736     }
1737 
1738     return nullptr;
1739 }
1740 
1741 RenderLayer* RenderLayer::enclosingCompositingLayerForRepaint(IncludeSelfOrNot includeSelf) const
1742 {
1743     if (includeSelf == IncludeSelf &amp;&amp; compositedWithOwnBackingStore(*this))
1744         return const_cast&lt;RenderLayer*&gt;(this);
1745 
1746     for (const RenderLayer* curr = paintOrderParent(); curr; curr = curr-&gt;paintOrderParent()) {
1747         if (compositedWithOwnBackingStore(*curr))
1748             return const_cast&lt;RenderLayer*&gt;(curr);
1749     }
1750 
1751     return nullptr;
1752 }
1753 
1754 RenderLayer* RenderLayer::enclosingFilterLayer(IncludeSelfOrNot includeSelf) const
1755 {
1756     const RenderLayer* curr = (includeSelf == IncludeSelf) ? this : parent();
1757     for (; curr; curr = curr-&gt;parent()) {
1758         if (curr-&gt;requiresFullLayerImageForFilters())
1759             return const_cast&lt;RenderLayer*&gt;(curr);
1760     }
1761 
1762     return nullptr;
1763 }
1764 
1765 RenderLayer* RenderLayer::enclosingFilterRepaintLayer() const
1766 {
1767     for (const RenderLayer* curr = this; curr; curr = curr-&gt;parent()) {
1768         if ((curr != this &amp;&amp; curr-&gt;requiresFullLayerImageForFilters()) || compositedWithOwnBackingStore(*curr) || curr-&gt;isRenderViewLayer())
1769             return const_cast&lt;RenderLayer*&gt;(curr);
1770     }
1771     return nullptr;
1772 }
1773 
1774 // FIXME: This neeeds a better name.
1775 void RenderLayer::setFilterBackendNeedsRepaintingInRect(const LayoutRect&amp; rect)
1776 {
1777     ASSERT(requiresFullLayerImageForFilters());
1778     ASSERT(m_filters);
1779 
1780     if (rect.isEmpty())
1781         return;
1782 
1783     LayoutRect rectForRepaint = rect;
1784     renderer().style().filterOutsets().expandRect(rectForRepaint);
1785 
1786     m_filters-&gt;expandDirtySourceRect(rectForRepaint);
1787 
1788     RenderLayer* parentLayer = enclosingFilterRepaintLayer();
1789     ASSERT(parentLayer);
1790     FloatQuad repaintQuad(rectForRepaint);
1791     LayoutRect parentLayerRect = renderer().localToContainerQuad(repaintQuad, &amp;parentLayer-&gt;renderer()).enclosingBoundingBox();
1792 
1793     if (parentLayer-&gt;isComposited()) {
1794         if (!parentLayer-&gt;backing()-&gt;paintsIntoWindow()) {
1795             parentLayer-&gt;setBackingNeedsRepaintInRect(parentLayerRect);
1796             return;
1797         }
1798         // If the painting goes to window, redirect the painting to the parent RenderView.
1799         parentLayer = renderer().view().layer();
1800         parentLayerRect = renderer().localToContainerQuad(repaintQuad, &amp;parentLayer-&gt;renderer()).enclosingBoundingBox();
1801     }
1802 
1803     if (parentLayer-&gt;paintsWithFilters()) {
1804         parentLayer-&gt;setFilterBackendNeedsRepaintingInRect(parentLayerRect);
1805         return;
1806     }
1807 
1808     if (parentLayer-&gt;isRenderViewLayer()) {
1809         downcast&lt;RenderView&gt;(parentLayer-&gt;renderer()).repaintViewRectangle(parentLayerRect);
1810         return;
1811     }
1812 
1813     ASSERT_NOT_REACHED();
1814 }
1815 
1816 bool RenderLayer::hasAncestorWithFilterOutsets() const
1817 {
1818     for (const RenderLayer* curr = this; curr; curr = curr-&gt;parent()) {
1819         if (curr-&gt;renderer().style().hasFilterOutsets())
1820             return true;
1821     }
1822     return false;
1823 }
1824 
1825 RenderLayer* RenderLayer::clippingRootForPainting() const
1826 {
1827     if (isComposited())
1828         return const_cast&lt;RenderLayer*&gt;(this);
1829 
1830     const RenderLayer* current = this;
1831     while (current) {
1832         if (current-&gt;isRenderViewLayer())
1833             return const_cast&lt;RenderLayer*&gt;(current);
1834 
1835         current = current-&gt;paintOrderParent();
1836         ASSERT(current);
1837         if (current-&gt;transform() || compositedWithOwnBackingStore(*current))
1838             return const_cast&lt;RenderLayer*&gt;(current);
1839     }
1840 
1841     ASSERT_NOT_REACHED();
1842     return nullptr;
1843 }
1844 
1845 LayoutPoint RenderLayer::absoluteToContents(const LayoutPoint&amp; absolutePoint) const
1846 {
1847     // We don&#39;t use convertToLayerCoords because it doesn&#39;t know about transforms
1848     return LayoutPoint(renderer().absoluteToLocal(absolutePoint, UseTransforms));
1849 }
1850 
1851 bool RenderLayer::cannotBlitToWindow() const
1852 {
1853     if (isTransparent() || hasReflection() || hasTransform())
1854         return true;
1855     if (!parent())
1856         return false;
1857     return parent()-&gt;cannotBlitToWindow();
1858 }
1859 
1860 RenderLayer* RenderLayer::transparentPaintingAncestor()
1861 {
1862     if (isComposited())
1863         return nullptr;
1864 
1865     for (RenderLayer* curr = parent(); curr; curr = curr-&gt;parent()) {
1866         if (curr-&gt;isComposited())
1867             return nullptr;
1868         if (curr-&gt;isTransparent())
1869             return curr;
1870     }
1871     return nullptr;
1872 }
1873 
1874 enum TransparencyClipBoxBehavior {
1875     PaintingTransparencyClipBox,
1876     HitTestingTransparencyClipBox
1877 };
1878 
1879 enum TransparencyClipBoxMode {
1880     DescendantsOfTransparencyClipBox,
1881     RootOfTransparencyClipBox
1882 };
1883 
1884 static LayoutRect transparencyClipBox(const RenderLayer&amp;, const RenderLayer* rootLayer, TransparencyClipBoxBehavior, TransparencyClipBoxMode, OptionSet&lt;PaintBehavior&gt; = { });
1885 
1886 static void expandClipRectForDescendantsAndReflection(LayoutRect&amp; clipRect, const RenderLayer&amp; layer, const RenderLayer* rootLayer,
1887     TransparencyClipBoxBehavior transparencyBehavior, OptionSet&lt;PaintBehavior&gt; paintBehavior)
1888 {
1889     // If we have a mask, then the clip is limited to the border box area (and there is
1890     // no need to examine child layers).
1891     if (!layer.renderer().hasMask()) {
1892         // Note: we don&#39;t have to walk z-order lists since transparent elements always establish
1893         // a stacking container. This means we can just walk the layer tree directly.
1894         for (RenderLayer* curr = layer.firstChild(); curr; curr = curr-&gt;nextSibling()) {
1895             if (!layer.isReflectionLayer(*curr))
1896                 clipRect.unite(transparencyClipBox(*curr, rootLayer, transparencyBehavior, DescendantsOfTransparencyClipBox, paintBehavior));
1897         }
1898     }
1899 
1900     // If we have a reflection, then we need to account for that when we push the clip.  Reflect our entire
1901     // current transparencyClipBox to catch all child layers.
1902     // FIXME: Accelerated compositing will eventually want to do something smart here to avoid incorporating this
1903     // size into the parent layer.
1904     if (layer.renderer().hasReflection()) {
1905         LayoutSize delta = layer.offsetFromAncestor(rootLayer);
1906         clipRect.move(-delta);
1907         clipRect.unite(layer.renderBox()-&gt;reflectedRect(clipRect));
1908         clipRect.move(delta);
1909     }
1910 }
1911 
1912 static LayoutRect transparencyClipBox(const RenderLayer&amp; layer, const RenderLayer* rootLayer, TransparencyClipBoxBehavior transparencyBehavior,
1913     TransparencyClipBoxMode transparencyMode, OptionSet&lt;PaintBehavior&gt; paintBehavior)
1914 {
1915     // FIXME: Although this function completely ignores CSS-imposed clipping, we did already intersect with the
1916     // paintDirtyRect, and that should cut down on the amount we have to paint.  Still it
1917     // would be better to respect clips.
1918 
1919     if (rootLayer != &amp;layer &amp;&amp; ((transparencyBehavior == PaintingTransparencyClipBox &amp;&amp; layer.paintsWithTransform(paintBehavior))
1920         || (transparencyBehavior == HitTestingTransparencyClipBox &amp;&amp; layer.hasTransform()))) {
1921         // The best we can do here is to use enclosed bounding boxes to establish a &quot;fuzzy&quot; enough clip to encompass
1922         // the transformed layer and all of its children.
1923         RenderLayer::PaginationInclusionMode mode = transparencyBehavior == HitTestingTransparencyClipBox ? RenderLayer::IncludeCompositedPaginatedLayers : RenderLayer::ExcludeCompositedPaginatedLayers;
1924         const RenderLayer* paginationLayer = transparencyMode == DescendantsOfTransparencyClipBox ? layer.enclosingPaginationLayer(mode) : nullptr;
1925         const RenderLayer* rootLayerForTransform = paginationLayer ? paginationLayer : rootLayer;
1926         LayoutSize delta = layer.offsetFromAncestor(rootLayerForTransform);
1927 
1928         TransformationMatrix transform;
1929         transform.translate(delta.width(), delta.height());
1930         transform.multiply(*layer.transform());
1931 
1932         // We don&#39;t use fragment boxes when collecting a transformed layer&#39;s bounding box, since it always
1933         // paints unfragmented.
1934         LayoutRect clipRect = layer.boundingBox(&amp;layer);
1935         expandClipRectForDescendantsAndReflection(clipRect, layer, &amp;layer, transparencyBehavior, paintBehavior);
1936         layer.renderer().style().filterOutsets().expandRect(clipRect);
1937         LayoutRect result = transform.mapRect(clipRect);
1938         if (!paginationLayer)
1939             return result;
1940 
1941         // We have to break up the transformed extent across our columns.
1942         // Split our box up into the actual fragment boxes that render in the columns/pages and unite those together to
1943         // get our true bounding box.
1944         auto&amp; enclosingFragmentedFlow = downcast&lt;RenderFragmentedFlow&gt;(paginationLayer-&gt;renderer());
1945         result = enclosingFragmentedFlow.fragmentsBoundingBox(result);
1946         result.move(paginationLayer-&gt;offsetFromAncestor(rootLayer));
1947         return result;
1948     }
1949 
1950     LayoutRect clipRect = layer.boundingBox(rootLayer, layer.offsetFromAncestor(rootLayer), transparencyBehavior == HitTestingTransparencyClipBox ? RenderLayer::UseFragmentBoxesIncludingCompositing : RenderLayer::UseFragmentBoxesExcludingCompositing);
1951     expandClipRectForDescendantsAndReflection(clipRect, layer, rootLayer, transparencyBehavior, paintBehavior);
1952     layer.renderer().style().filterOutsets().expandRect(clipRect);
1953 
1954     return clipRect;
1955 }
1956 
1957 static LayoutRect paintingExtent(const RenderLayer&amp; currentLayer, const RenderLayer* rootLayer, const LayoutRect&amp; paintDirtyRect, OptionSet&lt;PaintBehavior&gt; paintBehavior)
1958 {
1959     return intersection(transparencyClipBox(currentLayer, rootLayer, PaintingTransparencyClipBox, RootOfTransparencyClipBox, paintBehavior), paintDirtyRect);
1960 }
1961 
1962 void RenderLayer::beginTransparencyLayers(GraphicsContext&amp; context, const LayerPaintingInfo&amp; paintingInfo, const LayoutRect&amp; dirtyRect)
1963 {
1964     if (context.paintingDisabled() || (paintsWithTransparency(paintingInfo.paintBehavior) &amp;&amp; m_usedTransparency))
1965         return;
1966 
1967     RenderLayer* ancestor = transparentPaintingAncestor();
1968     if (ancestor)
1969         ancestor-&gt;beginTransparencyLayers(context, paintingInfo, dirtyRect);
1970 
1971     if (paintsWithTransparency(paintingInfo.paintBehavior)) {
1972         ASSERT(isStackingContext());
1973         m_usedTransparency = true;
1974         context.save();
1975         LayoutRect adjustedClipRect = paintingExtent(*this, paintingInfo.rootLayer, dirtyRect, paintingInfo.paintBehavior);
1976         adjustedClipRect.move(paintingInfo.subpixelOffset);
1977         FloatRect pixelSnappedClipRect = snapRectToDevicePixels(adjustedClipRect, renderer().document().deviceScaleFactor());
1978         context.clip(pixelSnappedClipRect);
1979 
1980 #if ENABLE(CSS_COMPOSITING)
1981         bool usesCompositeOperation = hasBlendMode() &amp;&amp; !(renderer().isSVGRoot() &amp;&amp; parent() &amp;&amp; parent()-&gt;isRenderViewLayer());
1982         if (usesCompositeOperation)
1983             context.setCompositeOperation(context.compositeOperation(), blendMode());
1984 #endif
1985 
1986         context.beginTransparencyLayer(renderer().opacity());
1987 
1988 #if ENABLE(CSS_COMPOSITING)
1989         if (usesCompositeOperation)
1990             context.setCompositeOperation(context.compositeOperation(), BlendMode::Normal);
1991 #endif
1992 
1993 #ifdef REVEAL_TRANSPARENCY_LAYERS
1994         context.setFillColor(Color(0.0f, 0.0f, 0.5f, 0.2f));
1995         context.fillRect(pixelSnappedClipRect);
1996 #endif
1997     }
1998 }
1999 
2000 #if PLATFORM(IOS_FAMILY)
2001 void RenderLayer::willBeDestroyed()
2002 {
2003     if (RenderLayerBacking* layerBacking = backing())
2004         layerBacking-&gt;layerWillBeDestroyed();
2005 }
2006 #endif
2007 
2008 bool RenderLayer::isDescendantOf(const RenderLayer&amp; layer) const
2009 {
2010     for (auto* ancestor = this; ancestor; ancestor = ancestor-&gt;parent()) {
2011         if (&amp;layer == ancestor)
2012             return true;
2013     }
2014     return false;
2015 }
2016 
2017 void RenderLayer::convertToPixelSnappedLayerCoords(const RenderLayer* ancestorLayer, IntPoint&amp; roundedLocation, ColumnOffsetAdjustment adjustForColumns) const
2018 {
2019     LayoutPoint location = convertToLayerCoords(ancestorLayer, roundedLocation, adjustForColumns);
2020     roundedLocation = roundedIntPoint(location);
2021 }
2022 
2023 // Returns the layer reached on the walk up towards the ancestor.
2024 static inline const RenderLayer* accumulateOffsetTowardsAncestor(const RenderLayer* layer, const RenderLayer* ancestorLayer, LayoutPoint&amp; location, RenderLayer::ColumnOffsetAdjustment adjustForColumns)
2025 {
2026     ASSERT(ancestorLayer != layer);
2027 
2028     const RenderLayerModelObject&amp; renderer = layer-&gt;renderer();
2029     auto position = renderer.style().position();
2030 
2031     // FIXME: Special casing RenderFragmentedFlow so much for fixed positioning here is not great.
2032     RenderFragmentedFlow* fixedFragmentedFlowContainer = position == PositionType::Fixed ? renderer.enclosingFragmentedFlow() : nullptr;
2033     if (fixedFragmentedFlowContainer &amp;&amp; !fixedFragmentedFlowContainer-&gt;isOutOfFlowPositioned())
2034         fixedFragmentedFlowContainer = nullptr;
2035 
2036     // FIXME: Positioning of out-of-flow(fixed, absolute) elements collected in a RenderFragmentedFlow
2037     // may need to be revisited in a future patch.
2038     // If the fixed renderer is inside a RenderFragmentedFlow, we should not compute location using localToAbsolute,
2039     // since localToAbsolute maps the coordinates from named flow to regions coordinates and regions can be
2040     // positioned in a completely different place in the viewport (RenderView).
2041     if (position == PositionType::Fixed &amp;&amp; !fixedFragmentedFlowContainer &amp;&amp; (!ancestorLayer || ancestorLayer == renderer.view().layer())) {
2042         // If the fixed layer&#39;s container is the root, just add in the offset of the view. We can obtain this by calling
2043         // localToAbsolute() on the RenderView.
2044         FloatPoint absPos = renderer.localToAbsolute(FloatPoint(), IsFixed);
2045         location += LayoutSize(absPos.x(), absPos.y());
2046         return ancestorLayer;
2047     }
2048 
2049     // For the fixed positioned elements inside a render flow thread, we should also skip the code path below
2050     // Otherwise, for the case of ancestorLayer == rootLayer and fixed positioned element child of a transformed
2051     // element in render flow thread, we will hit the fixed positioned container before hitting the ancestor layer.
2052     if (position == PositionType::Fixed &amp;&amp; !fixedFragmentedFlowContainer) {
2053         // For a fixed layers, we need to walk up to the root to see if there&#39;s a fixed position container
2054         // (e.g. a transformed layer). It&#39;s an error to call offsetFromAncestor() across a layer with a transform,
2055         // so we should always find the ancestor at or before we find the fixed position container.
2056         RenderLayer* fixedPositionContainerLayer = nullptr;
2057         bool foundAncestor = false;
2058         for (RenderLayer* currLayer = layer-&gt;parent(); currLayer; currLayer = currLayer-&gt;parent()) {
2059             if (currLayer == ancestorLayer)
2060                 foundAncestor = true;
2061 
2062             if (isContainerForPositioned(*currLayer, PositionType::Fixed)) {
2063                 fixedPositionContainerLayer = currLayer;
2064                 ASSERT_UNUSED(foundAncestor, foundAncestor);
2065                 break;
2066             }
2067         }
2068 
2069         ASSERT(fixedPositionContainerLayer); // We should have hit the RenderView&#39;s layer at least.
2070 
2071         if (fixedPositionContainerLayer != ancestorLayer) {
2072             LayoutSize fixedContainerCoords = layer-&gt;offsetFromAncestor(fixedPositionContainerLayer);
2073             LayoutSize ancestorCoords = ancestorLayer-&gt;offsetFromAncestor(fixedPositionContainerLayer);
2074             location += (fixedContainerCoords - ancestorCoords);
2075             return ancestorLayer;
2076         }
2077     }
2078 
2079     if (position == PositionType::Fixed &amp;&amp; fixedFragmentedFlowContainer) {
2080         ASSERT(ancestorLayer);
2081         if (ancestorLayer-&gt;isOutOfFlowRenderFragmentedFlow()) {
2082             location += toLayoutSize(layer-&gt;location());
2083             return ancestorLayer;
2084         }
2085 
2086         if (ancestorLayer == renderer.view().layer()) {
2087             // Add location in flow thread coordinates.
2088             location += toLayoutSize(layer-&gt;location());
2089 
2090             // Add flow thread offset in view coordinates since the view may be scrolled.
2091             FloatPoint absPos = renderer.view().localToAbsolute(FloatPoint(), IsFixed);
2092             location += LayoutSize(absPos.x(), absPos.y());
2093             return ancestorLayer;
2094         }
2095     }
2096 
2097     RenderLayer* parentLayer;
2098     if (position == PositionType::Absolute || position == PositionType::Fixed) {
2099         // Do what enclosingAncestorForPosition() does, but check for ancestorLayer along the way.
2100         parentLayer = layer-&gt;parent();
2101         bool foundAncestorFirst = false;
2102         while (parentLayer) {
2103             // RenderFragmentedFlow is a positioned container, child of RenderView, positioned at (0,0).
2104             // This implies that, for out-of-flow positioned elements inside a RenderFragmentedFlow,
2105             // we are bailing out before reaching root layer.
2106             if (isContainerForPositioned(*parentLayer, position))
2107                 break;
2108 
2109             if (parentLayer == ancestorLayer) {
2110                 foundAncestorFirst = true;
2111                 break;
2112             }
2113 
2114             parentLayer = parentLayer-&gt;parent();
2115         }
2116 
2117         // We should not reach RenderView layer past the RenderFragmentedFlow layer for any
2118         // children of the RenderFragmentedFlow.
2119         if (renderer.enclosingFragmentedFlow() &amp;&amp; !layer-&gt;isOutOfFlowRenderFragmentedFlow())
2120             ASSERT(parentLayer != renderer.view().layer());
2121 
2122         if (foundAncestorFirst) {
2123             // Found ancestorLayer before the abs. positioned container, so compute offset of both relative
2124             // to enclosingAncestorForPosition and subtract.
2125             RenderLayer* positionedAncestor = parentLayer-&gt;enclosingAncestorForPosition(position);
2126             LayoutSize thisCoords = layer-&gt;offsetFromAncestor(positionedAncestor);
2127             LayoutSize ancestorCoords = ancestorLayer-&gt;offsetFromAncestor(positionedAncestor);
2128             location += (thisCoords - ancestorCoords);
2129             return ancestorLayer;
2130         }
2131     } else
2132         parentLayer = layer-&gt;parent();
2133 
2134     if (!parentLayer)
2135         return nullptr;
2136 
2137     location += toLayoutSize(layer-&gt;location());
2138 
2139     if (adjustForColumns == RenderLayer::AdjustForColumns) {
2140         if (RenderLayer* parentLayer = layer-&gt;parent()) {
2141             if (is&lt;RenderMultiColumnFlow&gt;(parentLayer-&gt;renderer())) {
2142                 RenderFragmentContainer* fragment = downcast&lt;RenderMultiColumnFlow&gt;(parentLayer-&gt;renderer()).physicalTranslationFromFlowToFragment(location);
2143                 if (fragment)
2144                     location.moveBy(fragment-&gt;topLeftLocation() + -parentLayer-&gt;renderBox()-&gt;topLeftLocation());
2145             }
2146         }
2147     }
2148 
2149     return parentLayer;
2150 }
2151 
2152 LayoutPoint RenderLayer::convertToLayerCoords(const RenderLayer* ancestorLayer, const LayoutPoint&amp; location, ColumnOffsetAdjustment adjustForColumns) const
2153 {
2154     if (ancestorLayer == this)
2155         return location;
2156 
2157     const RenderLayer* currLayer = this;
2158     LayoutPoint locationInLayerCoords = location;
2159     while (currLayer &amp;&amp; currLayer != ancestorLayer)
2160         currLayer = accumulateOffsetTowardsAncestor(currLayer, ancestorLayer, locationInLayerCoords, adjustForColumns);
2161     return locationInLayerCoords;
2162 }
2163 
2164 LayoutSize RenderLayer::offsetFromAncestor(const RenderLayer* ancestorLayer, ColumnOffsetAdjustment adjustForColumns) const
2165 {
2166     return toLayoutSize(convertToLayerCoords(ancestorLayer, LayoutPoint(), adjustForColumns));
2167 }
2168 
2169 bool RenderLayer::canUseCompositedScrolling() const
2170 {
2171     if (renderer().settings().asyncOverflowScrollingEnabled())
2172         return scrollsOverflow();
2173 
2174 #if PLATFORM(IOS_FAMILY) &amp;&amp; ENABLE(ACCELERATED_OVERFLOW_SCROLLING)
2175     return scrollsOverflow() &amp;&amp; (renderer().style().useTouchOverflowScrolling() || renderer().settings().alwaysUseAcceleratedOverflowScroll());
2176 #else
2177     return false;
2178 #endif
2179 }
2180 
2181 bool RenderLayer::hasCompositedScrollableOverflow() const
2182 {
2183     return canUseCompositedScrolling() &amp;&amp; (hasScrollableHorizontalOverflow() || hasScrollableVerticalOverflow());
2184 }
2185 
2186 #if ENABLE(IOS_TOUCH_EVENTS)
2187 bool RenderLayer::handleTouchEvent(const PlatformTouchEvent&amp; touchEvent)
2188 {
2189     // If we have accelerated scrolling, let the scrolling be handled outside of WebKit.
2190     if (hasCompositedScrollableOverflow())
2191         return false;
2192 
2193     return ScrollableArea::handleTouchEvent(touchEvent);
2194 }
2195 
2196 void RenderLayer::registerAsTouchEventListenerForScrolling()
2197 {
2198     if (!renderer().element() || m_registeredAsTouchEventListenerForScrolling)
2199         return;
2200 
2201     renderer().document().addTouchEventHandler(*renderer().element());
2202     m_registeredAsTouchEventListenerForScrolling = true;
2203 }
2204 
2205 void RenderLayer::unregisterAsTouchEventListenerForScrolling()
2206 {
2207     if (!renderer().element() || !m_registeredAsTouchEventListenerForScrolling)
2208         return;
2209 
2210     renderer().document().removeTouchEventHandler(*renderer().element());
2211     m_registeredAsTouchEventListenerForScrolling = false;
2212 }
2213 #endif // ENABLE(IOS_TOUCH_EVENTS)
2214 
2215 // FIXME: this is only valid after we&#39;ve made layers.
2216 bool RenderLayer::usesCompositedScrolling() const
2217 {
2218     return isComposited() &amp;&amp; backing()-&gt;hasScrollingLayer();
2219 }
2220 
2221 // FIXME: this is only valid after we&#39;ve made layers.
2222 bool RenderLayer::usesAsyncScrolling() const
2223 {
2224     return compositor().useCoordinatedScrollingForLayer(*this);
2225 }
2226 
2227 static inline int adjustedScrollDelta(int beginningDelta)
2228 {
2229     // This implemention matches Firefox&#39;s.
2230     // http://mxr.mozilla.org/firefox/source/toolkit/content/widgets/browser.xml#856.
2231     const int speedReducer = 12;
2232 
2233     int adjustedDelta = beginningDelta / speedReducer;
2234     if (adjustedDelta &gt; 1)
2235         adjustedDelta = static_cast&lt;int&gt;(adjustedDelta * sqrt(static_cast&lt;double&gt;(adjustedDelta))) - 1;
2236     else if (adjustedDelta &lt; -1)
2237         adjustedDelta = static_cast&lt;int&gt;(adjustedDelta * sqrt(static_cast&lt;double&gt;(-adjustedDelta))) + 1;
2238 
2239     return adjustedDelta;
2240 }
2241 
2242 static inline IntSize adjustedScrollDelta(const IntSize&amp; delta)
2243 {
2244     return IntSize(adjustedScrollDelta(delta.width()), adjustedScrollDelta(delta.height()));
2245 }
2246 
2247 void RenderLayer::panScrollFromPoint(const IntPoint&amp; sourcePoint)
2248 {
2249     IntPoint lastKnownMousePosition = renderer().frame().eventHandler().lastKnownMousePosition();
2250 
2251     // We need to check if the last known mouse position is out of the window. When the mouse is out of the window, the position is incoherent
2252     static IntPoint previousMousePosition;
2253     if (lastKnownMousePosition.x() &lt; 0 || lastKnownMousePosition.y() &lt; 0)
2254         lastKnownMousePosition = previousMousePosition;
2255     else
2256         previousMousePosition = lastKnownMousePosition;
2257 
2258     IntSize delta = lastKnownMousePosition - sourcePoint;
2259 
2260     if (abs(delta.width()) &lt;= ScrollView::noPanScrollRadius) // at the center we let the space for the icon
2261         delta.setWidth(0);
2262     if (abs(delta.height()) &lt;= ScrollView::noPanScrollRadius)
2263         delta.setHeight(0);
2264 
2265     scrollByRecursively(adjustedScrollDelta(delta));
2266 }
2267 
2268 // FIXME: unify with the scrollRectToVisible() code below.
2269 void RenderLayer::scrollByRecursively(const IntSize&amp; delta, ScrollableArea** scrolledArea)
2270 {
2271     if (delta.isZero())
2272         return;
2273 
2274     bool restrictedByLineClamp = false;
2275     if (renderer().parent())
2276         restrictedByLineClamp = !renderer().parent()-&gt;style().lineClamp().isNone();
2277 
2278     if (renderer().hasOverflowClip() &amp;&amp; !restrictedByLineClamp) {
2279         ScrollOffset newScrollOffset = scrollOffset() + delta;
2280         scrollToOffset(newScrollOffset);
2281         if (scrolledArea)
2282             *scrolledArea = this;
2283 
2284         // If this layer can&#39;t do the scroll we ask the next layer up that can scroll to try
2285         IntSize remainingScrollOffset = newScrollOffset - scrollOffset();
2286         if (!remainingScrollOffset.isZero() &amp;&amp; renderer().parent()) {
2287             if (RenderLayer* scrollableLayer = enclosingScrollableLayer())
2288                 scrollableLayer-&gt;scrollByRecursively(remainingScrollOffset, scrolledArea);
2289 
2290             renderer().frame().eventHandler().updateAutoscrollRenderer();
2291         }
2292     } else {
2293         // If we are here, we were called on a renderer that can be programmatically scrolled, but doesn&#39;t
2294         // have an overflow clip. Which means that it is a document node that can be scrolled.
2295         renderer().view().frameView().scrollBy(delta);
2296         if (scrolledArea)
2297             *scrolledArea = &amp;renderer().view().frameView();
2298 
2299         // FIXME: If we didn&#39;t scroll the whole way, do we want to try looking at the frames ownerElement?
2300         // https://bugs.webkit.org/show_bug.cgi?id=28237
2301     }
2302 }
2303 
2304 void RenderLayer::setPostLayoutScrollPosition(Optional&lt;ScrollPosition&gt; position)
2305 {
2306     m_postLayoutScrollPosition = position;
2307 }
2308 
2309 void RenderLayer::applyPostLayoutScrollPositionIfNeeded()
2310 {
2311     if (!m_postLayoutScrollPosition)
2312         return;
2313 
2314     scrollToOffset(scrollOffsetFromPosition(m_postLayoutScrollPosition.value()));
2315     m_postLayoutScrollPosition = WTF::nullopt;
2316 }
2317 
2318 void RenderLayer::scrollToXPosition(int x, ScrollClamping clamping)
2319 {
2320     ScrollPosition position(x, m_scrollPosition.y());
2321     scrollToOffset(scrollOffsetFromPosition(position), clamping);
2322 }
2323 
2324 void RenderLayer::scrollToYPosition(int y, ScrollClamping clamping)
2325 {
2326     ScrollPosition position(m_scrollPosition.x(), y);
2327     scrollToOffset(scrollOffsetFromPosition(position), clamping);
2328 }
2329 
2330 ScrollOffset RenderLayer::clampScrollOffset(const ScrollOffset&amp; scrollOffset) const
2331 {
2332     return scrollOffset.constrainedBetween(IntPoint(), maximumScrollOffset());
2333 }
2334 
2335 void RenderLayer::scrollToOffset(const ScrollOffset&amp; scrollOffset, ScrollClamping clamping)
2336 {
2337     ScrollOffset newScrollOffset = clamping == ScrollClamping::Clamped ? clampScrollOffset(scrollOffset) : scrollOffset;
2338     if (newScrollOffset != this-&gt;scrollOffset())
2339         scrollToOffsetWithoutAnimation(newScrollOffset, clamping);
2340 }
2341 
2342 void RenderLayer::scrollTo(const ScrollPosition&amp; position)
2343 {
2344     RenderBox* box = renderBox();
2345     if (!box)
2346         return;
2347 
2348     LOG_WITH_STREAM(Scrolling, stream &lt;&lt; &quot;RenderLayer::scrollTo &quot; &lt;&lt; position &lt;&lt; &quot; from &quot; &lt;&lt; m_scrollPosition &lt;&lt; &quot; (in user scroll &quot; &lt;&lt; isInUserScroll() &lt;&lt; &quot;)&quot;);
2349 
2350     ScrollPosition newPosition = position;
2351     if (!box-&gt;isHTMLMarquee()) {
2352         // Ensure that the dimensions will be computed if they need to be (for overflow:hidden blocks).
2353         if (m_scrollDimensionsDirty)
2354             computeScrollDimensions();
2355 #if PLATFORM(IOS_FAMILY)
2356         if (adjustForIOSCaretWhenScrolling()) {
2357             // FIXME: It&#39;s not clear what this code is trying to do. Behavior seems reasonable with it removed.
2358             int maxOffset = scrollWidth() - roundToInt(box-&gt;clientWidth());
2359             ScrollOffset newOffset = scrollOffsetFromPosition(newPosition);
2360             int scrollXOffset = newOffset.x();
2361             if (scrollXOffset &gt; maxOffset - caretWidth) {
2362                 scrollXOffset += caretWidth;
2363                 if (scrollXOffset &lt;= caretWidth)
2364                     scrollXOffset = 0;
2365             } else if (scrollXOffset &lt; m_scrollPosition.x() - caretWidth)
2366                 scrollXOffset -= caretWidth;
2367 
2368             newOffset.setX(scrollXOffset);
2369             newPosition = scrollPositionFromOffset(newOffset);
2370         }
2371 #endif
2372     }
2373 
2374     if (m_scrollPosition == newPosition) {
2375         // FIXME: Nothing guarantees we get a scrollTo() with an unchanged position at the end of a user gesture.
2376         // The ScrollingCoordinator probably needs to message the main thread when a gesture ends.
2377         if (requiresScrollPositionReconciliation()) {
2378             setNeedsCompositingGeometryUpdate();
2379             updateCompositingLayersAfterScroll();
2380         }
2381         return;
2382     }
2383 
2384     m_scrollPosition = newPosition;
2385 
2386     RenderView&amp; view = renderer().view();
2387 
2388     // Update the positions of our child layers (if needed as only fixed layers should be impacted by a scroll).
2389     // We don&#39;t update compositing layers, because we need to do a deep update from the compositing ancestor.
2390     if (!view.frameView().layoutContext().isInRenderTreeLayout()) {
2391         // If we&#39;re in the middle of layout, we&#39;ll just update layers once layout has finished.
2392         updateLayerPositionsAfterOverflowScroll();
2393 
2394         view.frameView().scheduleUpdateWidgetPositions();
2395 
2396         if (!m_updatingMarqueePosition) {
2397             // Avoid updating compositing layers if, higher on the stack, we&#39;re already updating layer
2398             // positions. Updating layer positions requires a full walk of up-to-date RenderLayers, and
2399             // in this case we&#39;re still updating their positions; we&#39;ll update compositing layers later
2400             // when that completes.
2401             if (usesCompositedScrolling()) {
2402                 setNeedsCompositingGeometryUpdate();
2403                 setDescendantsNeedUpdateBackingAndHierarchyTraversal();
2404             }
2405 
2406             updateCompositingLayersAfterScroll();
2407         }
2408 
2409         // Update regions, scrolling may change the clip of a particular region.
2410         renderer().document().invalidateRenderingDependentRegions(Document::AnnotationsAction::Update);
2411         DebugPageOverlays::didLayout(renderer().frame());
2412     }
2413 
2414     Frame&amp; frame = renderer().frame();
2415     RenderLayerModelObject* repaintContainer = renderer().containerForRepaint();
2416     // The caret rect needs to be invalidated after scrolling
2417     frame.selection().setCaretRectNeedsUpdate();
2418 
2419     LayoutRect rectForRepaint = renderer().hasRepaintLayoutRects() ? renderer().repaintLayoutRects().m_repaintRect : renderer().clippedOverflowRectForRepaint(repaintContainer);
2420 
2421     FloatQuad quadForFakeMouseMoveEvent = FloatQuad(rectForRepaint);
2422     if (repaintContainer)
2423         quadForFakeMouseMoveEvent = repaintContainer-&gt;localToAbsoluteQuad(quadForFakeMouseMoveEvent);
2424     frame.eventHandler().dispatchFakeMouseMoveEventSoonInQuad(quadForFakeMouseMoveEvent);
2425 
2426     bool requiresRepaint = true;
2427     if (usesCompositedScrolling()) {
2428         setNeedsCompositingGeometryUpdate();
2429         setDescendantsNeedUpdateBackingAndHierarchyTraversal();
2430         requiresRepaint = false;
2431     }
2432 
2433     // Just schedule a full repaint of our object.
2434     if (requiresRepaint)
2435         renderer().repaintUsingContainer(repaintContainer, rectForRepaint);
2436 
2437     // Schedule the scroll and scroll-related DOM events.
2438     if (Element* element = renderer().element())
2439         element-&gt;document().eventQueue().enqueueOrDispatchScrollEvent(*element);
2440 
2441     if (scrollsOverflow())
2442         view.frameView().didChangeScrollOffset();
2443 
2444     view.frameView().viewportContentsChanged();
2445 }
2446 
2447 static inline bool frameElementAndViewPermitScroll(HTMLFrameElementBase* frameElementBase, FrameView&amp; frameView)
2448 {
2449     // If scrollbars aren&#39;t explicitly forbidden, permit scrolling.
2450     if (frameElementBase &amp;&amp; frameElementBase-&gt;scrollingMode() != ScrollbarAlwaysOff)
2451         return true;
2452 
2453     // If scrollbars are forbidden, user initiated scrolls should obviously be ignored.
2454     if (frameView.wasScrolledByUser())
2455         return false;
2456 
2457     // Forbid autoscrolls when scrollbars are off, but permits other programmatic scrolls,
2458     // like navigation to an anchor.
2459     return !frameView.frame().eventHandler().autoscrollInProgress();
2460 }
2461 
2462 bool RenderLayer::allowsCurrentScroll() const
2463 {
2464     if (!renderer().hasOverflowClip())
2465         return false;
2466 
2467     // Don&#39;t scroll to reveal an overflow layer that is restricted by the -webkit-line-clamp property.
2468     // FIXME: Is this still needed? It used to be relevant for Safari RSS.
2469     if (renderer().parent() &amp;&amp; !renderer().parent()-&gt;style().lineClamp().isNone())
2470         return false;
2471 
2472     RenderBox* box = renderBox();
2473     ASSERT(box); // Only boxes can have overflowClip set.
2474 
2475     if (renderer().frame().eventHandler().autoscrollInProgress()) {
2476         // The &quot;programmatically&quot; here is misleading; this asks whether the box has scrollable overflow,
2477         // or is a special case like a form control.
2478         return box-&gt;canBeProgramaticallyScrolled();
2479     }
2480 
2481     // Programmatic scrolls can scroll overflow:hidden.
2482     return box-&gt;hasHorizontalOverflow() || box-&gt;hasVerticalOverflow();
2483 }
2484 
2485 void RenderLayer::scrollRectToVisible(const LayoutRect&amp; absoluteRect, bool insideFixed, const ScrollRectToVisibleOptions&amp; options)
2486 {
2487     LOG_WITH_STREAM(Scrolling, stream &lt;&lt; &quot;Layer &quot; &lt;&lt; this &lt;&lt; &quot; scrollRectToVisible &quot; &lt;&lt; absoluteRect);
2488 
2489     RenderLayer* parentLayer = nullptr;
2490     LayoutRect newRect = absoluteRect;
2491 
2492     // We may end up propagating a scroll event. It is important that we suspend events until
2493     // the end of the function since they could delete the layer or the layer&#39;s renderer().
2494     FrameView&amp; frameView = renderer().view().frameView();
2495 
2496     if (renderer().parent())
2497         parentLayer = renderer().parent()-&gt;enclosingLayer();
2498 
2499     if (allowsCurrentScroll()) {
2500         // Don&#39;t scroll to reveal an overflow layer that is restricted by the -webkit-line-clamp property.
2501         // This will prevent us from revealing text hidden by the slider in Safari RSS.
2502         RenderBox* box = renderBox();
2503         ASSERT(box);
2504         LayoutRect localExposeRect(box-&gt;absoluteToLocalQuad(FloatQuad(FloatRect(absoluteRect))).boundingBox());
2505         LayoutRect layerBounds(0_lu, 0_lu, box-&gt;clientWidth(), box-&gt;clientHeight());
2506         LayoutRect revealRect = getRectToExpose(layerBounds, localExposeRect, insideFixed, options.alignX, options.alignY);
2507 
2508         ScrollOffset clampedScrollOffset = clampScrollOffset(scrollOffset() + toIntSize(roundedIntRect(revealRect).location()));
2509         if (clampedScrollOffset != scrollOffset()) {
2510             ScrollOffset oldScrollOffset = scrollOffset();
2511             scrollToOffset(clampedScrollOffset);
2512             IntSize scrollOffsetDifference = scrollOffset() - oldScrollOffset;
2513             localExposeRect.move(-scrollOffsetDifference);
2514             newRect = LayoutRect(box-&gt;localToAbsoluteQuad(FloatQuad(FloatRect(localExposeRect)), UseTransforms).boundingBox());
2515         }
2516     } else if (!parentLayer &amp;&amp; renderer().isRenderView()) {
2517         HTMLFrameOwnerElement* ownerElement = renderer().document().ownerElement();
2518 
2519         if (ownerElement &amp;&amp; ownerElement-&gt;renderer()) {
2520             HTMLFrameElementBase* frameElementBase = nullptr;
2521 
2522             if (is&lt;HTMLFrameElementBase&gt;(*ownerElement))
2523                 frameElementBase = downcast&lt;HTMLFrameElementBase&gt;(ownerElement);
2524 
2525             if (frameElementAndViewPermitScroll(frameElementBase, frameView)) {
2526                 // If this assertion fires we need to protect the ownerElement from being destroyed.
2527                 ScriptDisallowedScope::InMainThread scriptDisallowedScope;
2528 
2529                 LayoutRect viewRect = frameView.visibleContentRect(LegacyIOSDocumentVisibleRect);
2530                 LayoutRect exposeRect = getRectToExpose(viewRect, absoluteRect, insideFixed, options.alignX, options.alignY);
2531 
2532                 IntPoint scrollOffset(roundedIntPoint(exposeRect.location()));
2533                 // Adjust offsets if they&#39;re outside of the allowable range.
2534                 scrollOffset = scrollOffset.constrainedBetween(IntPoint(), IntPoint(frameView.contentsSize()));
2535                 frameView.setScrollPosition(scrollOffset);
2536 
2537                 if (options.shouldAllowCrossOriginScrolling == ShouldAllowCrossOriginScrolling::Yes || frameView.safeToPropagateScrollToParent()) {
2538                     parentLayer = ownerElement-&gt;renderer()-&gt;enclosingLayer();
2539                     // Convert the rect into the coordinate space of the parent frame&#39;s document.
2540                     newRect = frameView.contentsToContainingViewContents(enclosingIntRect(newRect));
2541                     insideFixed = false; // FIXME: ideally need to determine if this &lt;iframe&gt; is inside position:fixed.
2542                 } else
2543                     parentLayer = nullptr;
2544             }
2545         } else {
2546             if (options.revealMode == SelectionRevealMode::RevealUpToMainFrame &amp;&amp; frameView.frame().isMainFrame())
2547                 return;
2548 
2549 #if !PLATFORM(IOS_FAMILY)
2550             LayoutRect viewRect = frameView.visibleContentRect();
2551 #else
2552             LayoutRect viewRect = frameView.unobscuredContentRectExpandedByContentInsets();
2553 #endif
2554             // Move the target rect into &quot;scrollView contents&quot; coordinates.
2555             LayoutRect targetRect = absoluteRect;
2556             targetRect.move(0, frameView.headerHeight());
2557 
2558             LayoutRect revealRect = getRectToExpose(viewRect, targetRect, insideFixed, options.alignX, options.alignY);
2559 
2560             frameView.setScrollPosition(roundedIntPoint(revealRect.location()));
2561 
2562             // This is the outermost view of a web page, so after scrolling this view we
2563             // scroll its container by calling Page::scrollRectIntoView.
2564             // This only has an effect on the Mac platform in applications
2565             // that put web views into scrolling containers, such as Mac OS X Mail.
2566             // The canAutoscroll function in EventHandler also knows about this.
2567             page().chrome().scrollRectIntoView(snappedIntRect(absoluteRect));
2568         }
2569     }
2570 
2571     if (parentLayer)
2572         parentLayer-&gt;scrollRectToVisible(newRect, insideFixed, options);
2573 }
2574 
2575 void RenderLayer::updateCompositingLayersAfterScroll()
2576 {
2577     if (compositor().hasContentCompositingLayers()) {
2578         // Our stacking container is guaranteed to contain all of our descendants that may need
2579         // repositioning, so update compositing layers from there.
2580         if (RenderLayer* compositingAncestor = stackingContext()-&gt;enclosingCompositingLayer()) {
2581             if (usesCompositedScrolling())
2582                 compositor().updateCompositingLayers(CompositingUpdateType::OnCompositedScroll, compositingAncestor);
2583             else {
2584                 // FIXME: would be nice to only dirty layers whose positions were affected by scrolling.
2585                 compositingAncestor-&gt;setDescendantsNeedUpdateBackingAndHierarchyTraversal();
2586                 compositor().updateCompositingLayers(CompositingUpdateType::OnScroll, compositingAncestor);
2587             }
2588         }
2589     }
2590 }
2591 
2592 LayoutRect RenderLayer::getRectToExpose(const LayoutRect&amp; visibleRect, const LayoutRect&amp; exposeRect, bool insideFixed, const ScrollAlignment&amp; alignX, const ScrollAlignment&amp; alignY) const
2593 {
2594     FrameView&amp; frameView = renderer().view().frameView();
2595     if (renderer().isRenderView() &amp;&amp; insideFixed) {
2596         // If the element is inside position:fixed and we&#39;re not scaled, no amount of scrolling is going to move things around.
2597         if (frameView.frameScaleFactor() == 1)
2598             return visibleRect;
2599 
2600         if (renderer().settings().visualViewportEnabled()) {
2601             // exposeRect is in absolute coords, affected by page scale. Unscale it.
2602             LayoutRect unscaledExposeRect = exposeRect;
2603             unscaledExposeRect.scale(1 / frameView.frameScaleFactor());
2604             unscaledExposeRect.move(0, -frameView.headerHeight());
2605 
2606             // These are both in unscaled coordinates.
2607             LayoutRect layoutViewport = frameView.layoutViewportRect();
2608             LayoutRect visualViewport = frameView.visualViewportRect();
2609 
2610             // The rect to expose may be partially offscreen, which we can&#39;t do anything about with position:fixed.
2611             unscaledExposeRect.intersect(layoutViewport);
2612             // Make sure it&#39;s not larger than the visual viewport; if so, we&#39;ll just move to the top left.
2613             unscaledExposeRect.setSize(unscaledExposeRect.size().shrunkTo(visualViewport.size()));
2614 
2615             // Compute how much we have to move the visualViewport to reveal the part of the layoutViewport that contains exposeRect.
2616             LayoutRect requiredVisualViewport = getRectToExpose(visualViewport, unscaledExposeRect, false, alignX, alignY);
2617             // Scale it back up.
2618             requiredVisualViewport.scale(frameView.frameScaleFactor());
2619             requiredVisualViewport.move(0, frameView.headerHeight());
2620             return requiredVisualViewport;
2621         }
2622     }
2623 
2624     // Determine the appropriate X behavior.
2625     ScrollAlignment::Behavior scrollX;
2626     LayoutRect exposeRectX(exposeRect.x(), visibleRect.y(), exposeRect.width(), visibleRect.height());
2627     LayoutUnit intersectWidth = intersection(visibleRect, exposeRectX).width();
2628     if (intersectWidth == exposeRect.width() || intersectWidth &gt;= MIN_INTERSECT_FOR_REVEAL)
2629         // If the rectangle is fully visible, use the specified visible behavior.
2630         // If the rectangle is partially visible, but over a certain threshold,
2631         // then treat it as fully visible to avoid unnecessary horizontal scrolling
2632         scrollX = ScrollAlignment::getVisibleBehavior(alignX);
2633     else if (intersectWidth == visibleRect.width()) {
2634         // If the rect is bigger than the visible area, don&#39;t bother trying to center. Other alignments will work.
2635         scrollX = ScrollAlignment::getVisibleBehavior(alignX);
2636         if (scrollX == ScrollAlignment::Behavior::AlignCenter)
2637             scrollX = ScrollAlignment::Behavior::NoScroll;
2638     } else if (intersectWidth &gt; 0)
2639         // If the rectangle is partially visible, but not above the minimum threshold, use the specified partial behavior
2640         scrollX = ScrollAlignment::getPartialBehavior(alignX);
2641     else
2642         scrollX = ScrollAlignment::getHiddenBehavior(alignX);
2643     // If we&#39;re trying to align to the closest edge, and the exposeRect is further right
2644     // than the visibleRect, and not bigger than the visible area, then align with the right.
2645     if (scrollX == ScrollAlignment::Behavior::AlignToClosestEdge &amp;&amp; exposeRect.maxX() &gt; visibleRect.maxX() &amp;&amp; exposeRect.width() &lt; visibleRect.width())
2646         scrollX = ScrollAlignment::Behavior::AlignRight;
2647 
2648     // Given the X behavior, compute the X coordinate.
2649     LayoutUnit x;
2650     if (scrollX == ScrollAlignment::Behavior::NoScroll)
2651         x = visibleRect.x();
2652     else if (scrollX == ScrollAlignment::Behavior::AlignRight)
2653         x = exposeRect.maxX() - visibleRect.width();
2654     else if (scrollX == ScrollAlignment::Behavior::AlignCenter)
2655         x = exposeRect.x() + (exposeRect.width() - visibleRect.width()) / 2;
2656     else
2657         x = exposeRect.x();
2658 
2659     // Determine the appropriate Y behavior.
2660     ScrollAlignment::Behavior scrollY;
2661     LayoutRect exposeRectY(visibleRect.x(), exposeRect.y(), visibleRect.width(), exposeRect.height());
2662     LayoutUnit intersectHeight = intersection(visibleRect, exposeRectY).height();
2663     if (intersectHeight == exposeRect.height())
2664         // If the rectangle is fully visible, use the specified visible behavior.
2665         scrollY = ScrollAlignment::getVisibleBehavior(alignY);
2666     else if (intersectHeight == visibleRect.height()) {
2667         // If the rect is bigger than the visible area, don&#39;t bother trying to center. Other alignments will work.
2668         scrollY = ScrollAlignment::getVisibleBehavior(alignY);
2669         if (scrollY == ScrollAlignment::Behavior::AlignCenter)
2670             scrollY = ScrollAlignment::Behavior::NoScroll;
2671     } else if (intersectHeight &gt; 0)
2672         // If the rectangle is partially visible, use the specified partial behavior
2673         scrollY = ScrollAlignment::getPartialBehavior(alignY);
2674     else
2675         scrollY = ScrollAlignment::getHiddenBehavior(alignY);
2676     // If we&#39;re trying to align to the closest edge, and the exposeRect is further down
2677     // than the visibleRect, and not bigger than the visible area, then align with the bottom.
2678     if (scrollY == ScrollAlignment::Behavior::AlignToClosestEdge &amp;&amp; exposeRect.maxY() &gt; visibleRect.maxY() &amp;&amp; exposeRect.height() &lt; visibleRect.height())
2679         scrollY = ScrollAlignment::Behavior::AlignBottom;
2680 
2681     // Given the Y behavior, compute the Y coordinate.
2682     LayoutUnit y;
2683     if (scrollY == ScrollAlignment::Behavior::NoScroll)
2684         y = visibleRect.y();
2685     else if (scrollY == ScrollAlignment::Behavior::AlignBottom)
2686         y = exposeRect.maxY() - visibleRect.height();
2687     else if (scrollY == ScrollAlignment::Behavior::AlignCenter)
2688         y = exposeRect.y() + (exposeRect.height() - visibleRect.height()) / 2;
2689     else
2690         y = exposeRect.y();
2691 
2692     return LayoutRect(LayoutPoint(x, y), visibleRect.size());
2693 }
2694 
2695 void RenderLayer::autoscroll(const IntPoint&amp; positionInWindow)
2696 {
2697     IntPoint currentDocumentPosition = renderer().view().frameView().windowToContents(positionInWindow);
2698     scrollRectToVisible(LayoutRect(currentDocumentPosition, LayoutSize(1, 1)), false, { SelectionRevealMode::Reveal, ScrollAlignment::alignToEdgeIfNeeded, ScrollAlignment::alignToEdgeIfNeeded, ShouldAllowCrossOriginScrolling::Yes });
2699 }
2700 
2701 bool RenderLayer::canResize() const
2702 {
2703     // We need a special case for &lt;iframe&gt; because they never have
2704     // hasOverflowClip(). However, they do &quot;implicitly&quot; clip their contents, so
2705     // we want to allow resizing them also.
2706     return (renderer().hasOverflowClip() || renderer().isRenderIFrame()) &amp;&amp; renderer().style().resize() != Resize::None;
2707 }
2708 
2709 void RenderLayer::resize(const PlatformMouseEvent&amp; evt, const LayoutSize&amp; oldOffset)
2710 {
2711     // FIXME: This should be possible on generated content but is not right now.
2712     if (!inResizeMode() || !canResize() || !renderer().element())
2713         return;
2714 
2715     // FIXME: The only case where renderer-&gt;element()-&gt;renderer() != renderer is with continuations. Do they matter here?
2716     // If they do it would still be better to deal with them explicitly.
2717     Element* element = renderer().element();
2718     auto* renderer = downcast&lt;RenderBox&gt;(element-&gt;renderer());
2719 
2720     Document&amp; document = element-&gt;document();
2721     if (!document.frame()-&gt;eventHandler().mousePressed())
2722         return;
2723 
2724     float zoomFactor = renderer-&gt;style().effectiveZoom();
2725 
2726     LayoutSize newOffset = offsetFromResizeCorner(document.view()-&gt;windowToContents(evt.position()));
2727     newOffset.setWidth(newOffset.width() / zoomFactor);
2728     newOffset.setHeight(newOffset.height() / zoomFactor);
2729 
2730     LayoutSize currentSize = LayoutSize(renderer-&gt;width() / zoomFactor, renderer-&gt;height() / zoomFactor);
2731     LayoutSize minimumSize = element-&gt;minimumSizeForResizing().shrunkTo(currentSize);
2732     element-&gt;setMinimumSizeForResizing(minimumSize);
2733 
2734     LayoutSize adjustedOldOffset = LayoutSize(oldOffset.width() / zoomFactor, oldOffset.height() / zoomFactor);
2735     if (shouldPlaceBlockDirectionScrollbarOnLeft()) {
2736         newOffset.setWidth(-newOffset.width());
2737         adjustedOldOffset.setWidth(-adjustedOldOffset.width());
2738     }
2739 
2740     LayoutSize difference = (currentSize + newOffset - adjustedOldOffset).expandedTo(minimumSize) - currentSize;
2741 
2742     StyledElement* styledElement = downcast&lt;StyledElement&gt;(element);
2743     bool isBoxSizingBorder = renderer-&gt;style().boxSizing() == BoxSizing::BorderBox;
2744 
2745     Resize resize = renderer-&gt;style().resize();
2746     if (resize != Resize::Vertical &amp;&amp; difference.width()) {
2747         if (is&lt;HTMLFormControlElement&gt;(*element)) {
2748             // Make implicit margins from the theme explicit (see &lt;http://bugs.webkit.org/show_bug.cgi?id=9547&gt;).
2749             styledElement-&gt;setInlineStyleProperty(CSSPropertyMarginLeft, renderer-&gt;marginLeft() / zoomFactor, CSSPrimitiveValue::CSS_PX);
2750             styledElement-&gt;setInlineStyleProperty(CSSPropertyMarginRight, renderer-&gt;marginRight() / zoomFactor, CSSPrimitiveValue::CSS_PX);
2751         }
2752         LayoutUnit baseWidth = renderer-&gt;width() - (isBoxSizingBorder ? 0_lu : renderer-&gt;horizontalBorderAndPaddingExtent());
2753         baseWidth = baseWidth / zoomFactor;
2754         styledElement-&gt;setInlineStyleProperty(CSSPropertyWidth, roundToInt(baseWidth + difference.width()), CSSPrimitiveValue::CSS_PX);
2755     }
2756 
2757     if (resize != Resize::Horizontal &amp;&amp; difference.height()) {
2758         if (is&lt;HTMLFormControlElement&gt;(*element)) {
2759             // Make implicit margins from the theme explicit (see &lt;http://bugs.webkit.org/show_bug.cgi?id=9547&gt;).
2760             styledElement-&gt;setInlineStyleProperty(CSSPropertyMarginTop, renderer-&gt;marginTop() / zoomFactor, CSSPrimitiveValue::CSS_PX);
2761             styledElement-&gt;setInlineStyleProperty(CSSPropertyMarginBottom, renderer-&gt;marginBottom() / zoomFactor, CSSPrimitiveValue::CSS_PX);
2762         }
2763         LayoutUnit baseHeight = renderer-&gt;height() - (isBoxSizingBorder ? 0_lu : renderer-&gt;verticalBorderAndPaddingExtent());
2764         baseHeight = baseHeight / zoomFactor;
2765         styledElement-&gt;setInlineStyleProperty(CSSPropertyHeight, roundToInt(baseHeight + difference.height()), CSSPrimitiveValue::CSS_PX);
2766     }
2767 
2768     document.updateLayout();
2769 
2770     // FIXME (Radar 4118564): We should also autoscroll the window as necessary to keep the point under the cursor in view.
2771 }
2772 
2773 int RenderLayer::scrollSize(ScrollbarOrientation orientation) const
2774 {
2775     Scrollbar* scrollbar = ((orientation == HorizontalScrollbar) ? m_hBar : m_vBar).get();
2776     return scrollbar ? (scrollbar-&gt;totalSize() - scrollbar-&gt;visibleSize()) : 0;
2777 }
2778 
2779 void RenderLayer::setScrollOffset(const ScrollOffset&amp; offset)
2780 {
2781     scrollTo(scrollPositionFromOffset(offset));
2782 }
2783 
2784 int RenderLayer::scrollOffset(ScrollbarOrientation orientation) const
2785 {
2786     if (orientation == HorizontalScrollbar)
2787         return scrollOffset().x();
2788 
2789     if (orientation == VerticalScrollbar)
2790         return scrollOffset().y();
2791 
2792     return 0;
2793 }
2794 
2795 IntRect RenderLayer::visibleContentRectInternal(VisibleContentRectIncludesScrollbars scrollbarInclusion, VisibleContentRectBehavior) const
2796 {
2797     IntSize scrollbarSpace;
2798     if (showsOverflowControls() &amp;&amp; scrollbarInclusion == IncludeScrollbars)
2799         scrollbarSpace = scrollbarIntrusion();
2800 
2801     auto visibleSize = this-&gt;visibleSize();
2802     return { scrollPosition(), { std::max(0, visibleSize.width() - scrollbarSpace.width()), std::max(0, visibleSize.height() - scrollbarSpace.height()) } };
2803 }
2804 
2805 IntSize RenderLayer::overhangAmount() const
2806 {
2807 #if ENABLE(RUBBER_BANDING)
2808     if (!renderer().settings().rubberBandingForSubScrollableRegionsEnabled())
2809         return IntSize();
2810 
2811     IntSize stretch;
2812 
2813     // FIXME: use maximumScrollOffset(), or just move this to ScrollableArea.
2814     ScrollOffset scrollOffset = scrollOffsetFromPosition(scrollPosition());
2815     if (scrollOffset.y() &lt; 0)
2816         stretch.setHeight(scrollOffset.y());
2817     else if (scrollableContentsSize().height() &amp;&amp; scrollOffset.y() &gt; scrollableContentsSize().height() - visibleHeight())
2818         stretch.setHeight(scrollOffset.y() - (scrollableContentsSize().height() - visibleHeight()));
2819 
2820     if (scrollOffset.x() &lt; 0)
2821         stretch.setWidth(scrollOffset.x());
2822     else if (scrollableContentsSize().width() &amp;&amp; scrollOffset.x() &gt; scrollableContentsSize().width() - visibleWidth())
2823         stretch.setWidth(scrollOffset.x() - (scrollableContentsSize().width() - visibleWidth()));
2824 
2825     return stretch;
2826 #else
2827     return IntSize();
2828 #endif
2829 }
2830 
2831 bool RenderLayer::isActive() const
2832 {
2833     return page().focusController().isActive();
2834 }
2835 
2836 static int cornerStart(const RenderLayer&amp; layer, int minX, int maxX, int thickness)
2837 {
2838     if (layer.shouldPlaceBlockDirectionScrollbarOnLeft())
2839         return minX + layer.renderer().style().borderLeftWidth();
2840     return maxX - thickness - layer.renderer().style().borderRightWidth();
2841 }
2842 
2843 static LayoutRect cornerRect(const RenderLayer&amp; layer, const LayoutRect&amp; bounds)
2844 {
2845     int horizontalThickness;
2846     int verticalThickness;
2847     if (!layer.verticalScrollbar() &amp;&amp; !layer.horizontalScrollbar()) {
2848         // FIXME: This isn&#39;t right.  We need to know the thickness of custom scrollbars
2849         // even when they don&#39;t exist in order to set the resizer square size properly.
2850         horizontalThickness = ScrollbarTheme::theme().scrollbarThickness();
2851         verticalThickness = horizontalThickness;
2852     } else if (layer.verticalScrollbar() &amp;&amp; !layer.horizontalScrollbar()) {
2853         horizontalThickness = layer.verticalScrollbar()-&gt;width();
2854         verticalThickness = horizontalThickness;
2855     } else if (layer.horizontalScrollbar() &amp;&amp; !layer.verticalScrollbar()) {
2856         verticalThickness = layer.horizontalScrollbar()-&gt;height();
2857         horizontalThickness = verticalThickness;
2858     } else {
2859         horizontalThickness = layer.verticalScrollbar()-&gt;width();
2860         verticalThickness = layer.horizontalScrollbar()-&gt;height();
2861     }
2862     return LayoutRect(cornerStart(layer, bounds.x(), bounds.maxX(), horizontalThickness),
2863         bounds.maxY() - verticalThickness - layer.renderer().style().borderBottomWidth(),
2864         horizontalThickness, verticalThickness);
2865 }
2866 
2867 IntRect RenderLayer::scrollCornerRect() const
2868 {
2869     // We have a scrollbar corner when a non overlay scrollbar is visible and not filling the entire length of the box.
2870     // This happens when:
2871     // (a) A resizer is present and at least one non overlay scrollbar is present
2872     // (b) Both non overlay scrollbars are present.
2873     // Overlay scrollbars always fill the entire length of the box so we never have scroll corner in that case.
2874     bool hasHorizontalBar = m_hBar &amp;&amp; !m_hBar-&gt;isOverlayScrollbar();
2875     bool hasVerticalBar = m_vBar &amp;&amp; !m_vBar-&gt;isOverlayScrollbar();
2876     bool hasResizer = renderer().style().resize() != Resize::None;
2877     if ((hasHorizontalBar &amp;&amp; hasVerticalBar) || (hasResizer &amp;&amp; (hasHorizontalBar || hasVerticalBar)))
2878         return snappedIntRect(cornerRect(*this, renderBox()-&gt;borderBoxRect()));
2879     return IntRect();
2880 }
2881 
2882 static LayoutRect resizerCornerRect(const RenderLayer&amp; layer, const LayoutRect&amp; bounds)
2883 {
2884     ASSERT(layer.renderer().isBox());
2885     if (layer.renderer().style().resize() == Resize::None)
2886         return LayoutRect();
2887     return cornerRect(layer, bounds);
2888 }
2889 
2890 LayoutRect RenderLayer::scrollCornerAndResizerRect() const
2891 {
2892     RenderBox* box = renderBox();
2893     if (!box)
2894         return LayoutRect();
2895     LayoutRect scrollCornerAndResizer = scrollCornerRect();
2896     if (scrollCornerAndResizer.isEmpty())
2897         scrollCornerAndResizer = resizerCornerRect(*this, box-&gt;borderBoxRect());
2898     return scrollCornerAndResizer;
2899 }
2900 
2901 bool RenderLayer::isScrollCornerVisible() const
2902 {
2903     ASSERT(renderer().isBox());
2904     return !scrollCornerRect().isEmpty();
2905 }
2906 
2907 IntRect RenderLayer::convertFromScrollbarToContainingView(const Scrollbar&amp; scrollbar, const IntRect&amp; scrollbarRect) const
2908 {
2909     IntRect rect = scrollbarRect;
2910     rect.move(scrollbarOffset(scrollbar));
2911 
2912     return renderer().view().frameView().convertFromRendererToContainingView(&amp;renderer(), rect);
2913 }
2914 
2915 IntRect RenderLayer::convertFromContainingViewToScrollbar(const Scrollbar&amp; scrollbar, const IntRect&amp; parentRect) const
2916 {
2917     IntRect rect = renderer().view().frameView().convertFromContainingViewToRenderer(&amp;renderer(), parentRect);
2918     rect.move(-scrollbarOffset(scrollbar));
2919     return rect;
2920 }
2921 
2922 IntPoint RenderLayer::convertFromScrollbarToContainingView(const Scrollbar&amp; scrollbar, const IntPoint&amp; scrollbarPoint) const
2923 {
2924     IntPoint point = scrollbarPoint;
2925     point.move(scrollbarOffset(scrollbar));
2926     return renderer().view().frameView().convertFromRendererToContainingView(&amp;renderer(), point);
2927 }
2928 
2929 IntPoint RenderLayer::convertFromContainingViewToScrollbar(const Scrollbar&amp; scrollbar, const IntPoint&amp; parentPoint) const
2930 {
2931     IntPoint point = renderer().view().frameView().convertFromContainingViewToRenderer(&amp;renderer(), parentPoint);
2932     point.move(-scrollbarOffset(scrollbar));
2933     return point;
2934 }
2935 
2936 IntSize RenderLayer::visibleSize() const
2937 {
2938     RenderBox* box = renderBox();
2939     if (!box)
2940         return IntSize();
2941 
2942     return IntSize(roundToInt(box-&gt;clientWidth()), roundToInt(box-&gt;clientHeight()));
2943 }
2944 
2945 IntSize RenderLayer::contentsSize() const
2946 {
2947     return IntSize(scrollWidth(), scrollHeight());
2948 }
2949 
2950 IntSize RenderLayer::scrollableContentsSize() const
2951 {
2952     IntSize contentsSize = this-&gt;contentsSize();
2953 
2954     if (!hasScrollableHorizontalOverflow())
2955         contentsSize.setWidth(std::min(contentsSize.width(), visibleSize().width()));
2956 
2957     if (!hasScrollableVerticalOverflow())
2958         contentsSize.setHeight(std::min(contentsSize.height(), visibleSize().height()));
2959 
2960     return contentsSize;
2961 }
2962 
2963 void RenderLayer::availableContentSizeChanged(AvailableSizeChangeReason reason)
2964 {
2965     ScrollableArea::availableContentSizeChanged(reason);
2966 
2967     if (reason == AvailableSizeChangeReason::ScrollbarsChanged) {
2968         if (is&lt;RenderBlock&gt;(renderer()))
2969             downcast&lt;RenderBlock&gt;(renderer()).setShouldForceRelayoutChildren(true);
2970         renderer().setNeedsLayout();
2971     }
2972 }
2973 
2974 bool RenderLayer::shouldSuspendScrollAnimations() const
2975 {
2976     return renderer().view().frameView().shouldSuspendScrollAnimations();
2977 }
2978 
2979 #if PLATFORM(IOS_FAMILY)
2980 void RenderLayer::didStartScroll()
2981 {
2982     page().chrome().client().didStartOverflowScroll();
2983 }
2984 
2985 void RenderLayer::didEndScroll()
2986 {
2987     page().chrome().client().didEndOverflowScroll();
2988 }
2989 
2990 void RenderLayer::didUpdateScroll()
2991 {
2992     // Send this notification when we scroll, since this is how we keep selection updated.
2993     page().chrome().client().didLayout(ChromeClient::Scroll);
2994 }
2995 #endif
2996 
2997 IntPoint RenderLayer::lastKnownMousePosition() const
2998 {
2999     return renderer().frame().eventHandler().lastKnownMousePosition();
3000 }
3001 
3002 bool RenderLayer::isHandlingWheelEvent() const
3003 {
3004     return renderer().frame().eventHandler().isHandlingWheelEvent();
3005 }
3006 
3007 IntRect RenderLayer::rectForHorizontalScrollbar(const IntRect&amp; borderBoxRect) const
3008 {
3009     if (!m_hBar)
3010         return IntRect();
3011 
3012     const RenderBox* box = renderBox();
3013     const IntRect&amp; scrollCorner = scrollCornerRect();
3014 
3015     return IntRect(horizontalScrollbarStart(borderBoxRect.x()),
3016         borderBoxRect.maxY() - box-&gt;borderBottom() - m_hBar-&gt;height(),
3017         borderBoxRect.width() - (box-&gt;borderLeft() + box-&gt;borderRight()) - scrollCorner.width(),
3018         m_hBar-&gt;height());
3019 }
3020 
3021 IntRect RenderLayer::rectForVerticalScrollbar(const IntRect&amp; borderBoxRect) const
3022 {
3023     if (!m_vBar)
3024         return IntRect();
3025 
3026     const RenderBox* box = renderBox();
3027     const IntRect&amp; scrollCorner = scrollCornerRect();
3028 
3029     return IntRect(verticalScrollbarStart(borderBoxRect.x(), borderBoxRect.maxX()),
3030         borderBoxRect.y() + box-&gt;borderTop(),
3031         m_vBar-&gt;width(),
3032         borderBoxRect.height() - (box-&gt;borderTop() + box-&gt;borderBottom()) - scrollCorner.height());
3033 }
3034 
3035 LayoutUnit RenderLayer::verticalScrollbarStart(int minX, int maxX) const
3036 {
3037     const RenderBox* box = renderBox();
3038     if (shouldPlaceBlockDirectionScrollbarOnLeft())
3039         return minX + box-&gt;borderLeft();
3040     return maxX - box-&gt;borderRight() - m_vBar-&gt;width();
3041 }
3042 
3043 LayoutUnit RenderLayer::horizontalScrollbarStart(int minX) const
3044 {
3045     const RenderBox* box = renderBox();
3046     int x = minX + box-&gt;borderLeft();
3047     if (shouldPlaceBlockDirectionScrollbarOnLeft())
3048         x += m_vBar ? m_vBar-&gt;width() : roundToInt(resizerCornerRect(*this, box-&gt;borderBoxRect()).width());
3049     return x;
3050 }
3051 
3052 IntSize RenderLayer::scrollbarOffset(const Scrollbar&amp; scrollbar) const
3053 {
3054     RenderBox* box = renderBox();
3055 
3056     if (&amp;scrollbar == m_vBar.get())
3057         return IntSize(verticalScrollbarStart(0, box-&gt;width()), box-&gt;borderTop());
3058 
3059     if (&amp;scrollbar == m_hBar.get())
3060         return IntSize(horizontalScrollbarStart(0), box-&gt;height() - box-&gt;borderBottom() - scrollbar.height());
3061 
3062     ASSERT_NOT_REACHED();
3063     return IntSize();
3064 }
3065 
3066 void RenderLayer::invalidateScrollbarRect(Scrollbar&amp; scrollbar, const IntRect&amp; rect)
3067 {
3068     if (!showsOverflowControls())
3069         return;
3070 
3071     if (&amp;scrollbar == m_vBar.get()) {
3072         if (GraphicsLayer* layer = layerForVerticalScrollbar()) {
3073             layer-&gt;setNeedsDisplayInRect(rect);
3074             return;
3075         }
3076     } else {
3077         if (GraphicsLayer* layer = layerForHorizontalScrollbar()) {
3078             layer-&gt;setNeedsDisplayInRect(rect);
3079             return;
3080         }
3081     }
3082 
3083     IntRect scrollRect = rect;
3084     RenderBox* box = renderBox();
3085     ASSERT(box);
3086     // If we are not yet inserted into the tree, there is no need to repaint.
3087     if (!box-&gt;parent())
3088         return;
3089 
3090     if (&amp;scrollbar == m_vBar.get())
3091         scrollRect.move(verticalScrollbarStart(0, box-&gt;width()), box-&gt;borderTop());
3092     else
3093         scrollRect.move(horizontalScrollbarStart(0), box-&gt;height() - box-&gt;borderBottom() - scrollbar.height());
3094     LayoutRect repaintRect = scrollRect;
3095     renderBox()-&gt;flipForWritingMode(repaintRect);
3096     renderer().repaintRectangle(repaintRect);
3097 }
3098 
3099 void RenderLayer::invalidateScrollCornerRect(const IntRect&amp; rect)
3100 {
3101     if (!showsOverflowControls())
3102         return;
3103 
3104     if (GraphicsLayer* layer = layerForScrollCorner()) {
3105         layer-&gt;setNeedsDisplayInRect(rect);
3106         return;
3107     }
3108 
3109     if (m_scrollCorner)
3110         m_scrollCorner-&gt;repaintRectangle(rect);
3111     if (m_resizer)
3112         m_resizer-&gt;repaintRectangle(rect);
3113 }
3114 
3115 static inline RenderElement* rendererForScrollbar(RenderLayerModelObject&amp; renderer)
3116 {
3117     if (Element* element = renderer.element()) {
3118         if (ShadowRoot* shadowRoot = element-&gt;containingShadowRoot()) {
3119             if (shadowRoot-&gt;mode() == ShadowRootMode::UserAgent)
3120                 return shadowRoot-&gt;host()-&gt;renderer();
3121         }
3122     }
3123 
3124     return &amp;renderer;
3125 }
3126 
3127 Ref&lt;Scrollbar&gt; RenderLayer::createScrollbar(ScrollbarOrientation orientation)
3128 {
3129     RefPtr&lt;Scrollbar&gt; widget;
3130     ASSERT(rendererForScrollbar(renderer()));
3131     auto&amp; actualRenderer = *rendererForScrollbar(renderer());
3132     bool hasCustomScrollbarStyle = is&lt;RenderBox&gt;(actualRenderer) &amp;&amp; downcast&lt;RenderBox&gt;(actualRenderer).style().hasPseudoStyle(PseudoId::Scrollbar);
3133     if (hasCustomScrollbarStyle)
3134         widget = RenderScrollbar::createCustomScrollbar(*this, orientation, downcast&lt;RenderBox&gt;(actualRenderer).element());
3135     else {
3136         widget = Scrollbar::createNativeScrollbar(*this, orientation, RegularScrollbar);
3137         didAddScrollbar(widget.get(), orientation);
3138         if (page().expectsWheelEventTriggers())
3139             scrollAnimator().setWheelEventTestTrigger(page().testTrigger());
3140     }
3141     renderer().view().frameView().addChild(*widget);
3142     return widget.releaseNonNull();
3143 }
3144 
3145 void RenderLayer::destroyScrollbar(ScrollbarOrientation orientation)
3146 {
3147     RefPtr&lt;Scrollbar&gt;&amp; scrollbar = orientation == HorizontalScrollbar ? m_hBar : m_vBar;
3148     if (!scrollbar)
3149         return;
3150 
3151     if (!scrollbar-&gt;isCustomScrollbar())
3152         willRemoveScrollbar(scrollbar.get(), orientation);
3153 
3154     scrollbar-&gt;removeFromParent();
3155     scrollbar = nullptr;
3156 }
3157 
3158 bool RenderLayer::scrollsOverflow() const
3159 {
3160     if (!is&lt;RenderBox&gt;(renderer()))
3161         return false;
3162 
3163     return downcast&lt;RenderBox&gt;(renderer()).scrollsOverflow();
3164 }
3165 
3166 void RenderLayer::setHasHorizontalScrollbar(bool hasScrollbar)
3167 {
3168     if (hasScrollbar == hasHorizontalScrollbar())
3169         return;
3170 
3171     if (hasScrollbar) {
3172         m_hBar = createScrollbar(HorizontalScrollbar);
3173 #if ENABLE(RUBBER_BANDING)
3174         ScrollElasticity elasticity = scrollsOverflow() &amp;&amp; renderer().settings().rubberBandingForSubScrollableRegionsEnabled() ? ScrollElasticityAutomatic : ScrollElasticityNone;
3175         ScrollableArea::setHorizontalScrollElasticity(elasticity);
3176 #endif
3177     } else {
3178         destroyScrollbar(HorizontalScrollbar);
3179 #if ENABLE(RUBBER_BANDING)
3180         ScrollableArea::setHorizontalScrollElasticity(ScrollElasticityNone);
3181 #endif
3182     }
3183 
3184     // Destroying or creating one bar can cause our scrollbar corner to come and go.  We need to update the opposite scrollbar&#39;s style.
3185     if (m_hBar)
3186         m_hBar-&gt;styleChanged();
3187     if (m_vBar)
3188         m_vBar-&gt;styleChanged();
3189 
3190     renderer().document().invalidateScrollbarDependentRegions();
3191 }
3192 
3193 void RenderLayer::setHasVerticalScrollbar(bool hasScrollbar)
3194 {
3195     if (hasScrollbar == hasVerticalScrollbar())
3196         return;
3197 
3198     if (hasScrollbar) {
3199         m_vBar = createScrollbar(VerticalScrollbar);
3200 #if ENABLE(RUBBER_BANDING)
3201         ScrollElasticity elasticity = scrollsOverflow() &amp;&amp; renderer().settings().rubberBandingForSubScrollableRegionsEnabled() ? ScrollElasticityAutomatic : ScrollElasticityNone;
3202         ScrollableArea::setVerticalScrollElasticity(elasticity);
3203 #endif
3204     } else {
3205         destroyScrollbar(VerticalScrollbar);
3206 #if ENABLE(RUBBER_BANDING)
3207         ScrollableArea::setVerticalScrollElasticity(ScrollElasticityNone);
3208 #endif
3209     }
3210 
3211      // Destroying or creating one bar can cause our scrollbar corner to come and go.  We need to update the opposite scrollbar&#39;s style.
3212     if (m_hBar)
3213         m_hBar-&gt;styleChanged();
3214     if (m_vBar)
3215         m_vBar-&gt;styleChanged();
3216 
3217     renderer().document().invalidateScrollbarDependentRegions();
3218 }
3219 
3220 ScrollableArea* RenderLayer::enclosingScrollableArea() const
3221 {
3222     if (RenderLayer* scrollableLayer = enclosingScrollableLayer())
3223         return scrollableLayer;
3224 
3225     // FIXME: We should return the frame view here (or possibly an ancestor frame view,
3226     // if the frame view isn&#39;t scrollable.
3227     return nullptr;
3228 }
3229 
3230 bool RenderLayer::isScrollableOrRubberbandable()
3231 {
3232     return renderer().isScrollableOrRubberbandableBox();
3233 }
3234 
3235 bool RenderLayer::hasScrollableOrRubberbandableAncestor()
3236 {
3237     for (RenderLayer* nextLayer = parentLayerCrossFrame(*this); nextLayer; nextLayer = parentLayerCrossFrame(*nextLayer)) {
3238         if (nextLayer-&gt;isScrollableOrRubberbandable())
3239             return true;
3240     }
3241 
3242     return false;
3243 }
3244 
3245 bool RenderLayer::useDarkAppearance() const
3246 {
3247     return renderer().useDarkAppearance();
3248 }
3249 
3250 #if ENABLE(CSS_SCROLL_SNAP)
3251 void RenderLayer::updateSnapOffsets()
3252 {
3253     // FIXME: Extend support beyond HTMLElements.
3254     if (!is&lt;HTMLElement&gt;(enclosingElement()) || !enclosingElement()-&gt;renderBox())
3255         return;
3256 
3257     RenderBox* box = enclosingElement()-&gt;renderBox();
3258     updateSnapOffsetsForScrollableArea(*this, *downcast&lt;HTMLElement&gt;(enclosingElement()), *box, box-&gt;style());
3259 }
3260 
3261 bool RenderLayer::isScrollSnapInProgress() const
3262 {
3263     if (!scrollsOverflow())
3264         return false;
3265 
3266     if (ScrollAnimator* scrollAnimator = existingScrollAnimator())
3267         return scrollAnimator-&gt;isScrollSnapInProgress();
3268 
3269     return false;
3270 }
3271 #endif
3272 
3273 bool RenderLayer::usesMockScrollAnimator() const
3274 {
3275     return DeprecatedGlobalSettings::usesMockScrollAnimator();
3276 }
3277 
3278 void RenderLayer::logMockScrollAnimatorMessage(const String&amp; message) const
3279 {
3280     renderer().document().addConsoleMessage(MessageSource::Other, MessageLevel::Debug, &quot;RenderLayer: &quot; + message);
3281 }
3282 
3283 int RenderLayer::verticalScrollbarWidth(OverlayScrollbarSizeRelevancy relevancy) const
3284 {
3285     if (!m_vBar
3286         || !showsOverflowControls()
3287         || (m_vBar-&gt;isOverlayScrollbar() &amp;&amp; (relevancy == IgnoreOverlayScrollbarSize || !m_vBar-&gt;shouldParticipateInHitTesting())))
3288         return 0;
3289 
3290     return m_vBar-&gt;width();
3291 }
3292 
3293 int RenderLayer::horizontalScrollbarHeight(OverlayScrollbarSizeRelevancy relevancy) const
3294 {
3295     if (!m_hBar
3296         || !showsOverflowControls()
3297         || (m_hBar-&gt;isOverlayScrollbar() &amp;&amp; (relevancy == IgnoreOverlayScrollbarSize || !m_hBar-&gt;shouldParticipateInHitTesting())))
3298         return 0;
3299 
3300     return m_hBar-&gt;height();
3301 }
3302 
3303 IntSize RenderLayer::offsetFromResizeCorner(const IntPoint&amp; absolutePoint) const
3304 {
3305     // Currently the resize corner is either the bottom right corner or the bottom left corner.
3306     // FIXME: This assumes the location is 0, 0. Is this guaranteed to always be the case?
3307     IntSize elementSize = size();
3308     if (shouldPlaceBlockDirectionScrollbarOnLeft())
3309         elementSize.setWidth(0);
3310     IntPoint resizerPoint = IntPoint(elementSize);
3311     IntPoint localPoint = roundedIntPoint(absoluteToContents(absolutePoint));
3312     return localPoint - resizerPoint;
3313 }
3314 
3315 bool RenderLayer::hasOverflowControls() const
3316 {
3317     return m_hBar || m_vBar || m_scrollCorner || renderer().style().resize() != Resize::None;
3318 }
3319 
3320 void RenderLayer::positionOverflowControls(const IntSize&amp; offsetFromRoot)
3321 {
3322     if (!m_hBar &amp;&amp; !m_vBar &amp;&amp; !canResize())
3323         return;
3324 
3325     RenderBox* box = renderBox();
3326     if (!box)
3327         return;
3328 
3329     const IntRect borderBox = snappedIntRect(box-&gt;borderBoxRect());
3330     const IntRect&amp; scrollCorner = scrollCornerRect();
3331     IntRect absBounds(borderBox.location() + offsetFromRoot, borderBox.size());
3332     if (m_vBar) {
3333         IntRect vBarRect = rectForVerticalScrollbar(borderBox);
3334         vBarRect.move(offsetFromRoot);
3335         m_vBar-&gt;setFrameRect(vBarRect);
3336     }
3337 
3338     if (m_hBar) {
3339         IntRect hBarRect = rectForHorizontalScrollbar(borderBox);
3340         hBarRect.move(offsetFromRoot);
3341         m_hBar-&gt;setFrameRect(hBarRect);
3342     }
3343 
3344     if (m_scrollCorner)
3345         m_scrollCorner-&gt;setFrameRect(scrollCorner);
3346     if (m_resizer)
3347         m_resizer-&gt;setFrameRect(resizerCornerRect(*this, borderBox));
3348 
3349     if (isComposited())
3350         backing()-&gt;positionOverflowControlsLayers();
3351 }
3352 
3353 int RenderLayer::scrollWidth() const
3354 {
3355     ASSERT(renderBox());
3356     if (m_scrollDimensionsDirty)
3357         const_cast&lt;RenderLayer*&gt;(this)-&gt;computeScrollDimensions();
3358     // FIXME: This should use snappedIntSize() instead with absolute coordinates.
3359     return m_scrollSize.width();
3360 }
3361 
3362 int RenderLayer::scrollHeight() const
3363 {
3364     ASSERT(renderBox());
3365     if (m_scrollDimensionsDirty)
3366         const_cast&lt;RenderLayer*&gt;(this)-&gt;computeScrollDimensions();
3367     // FIXME: This should use snappedIntSize() instead with absolute coordinates.
3368     return m_scrollSize.height();
3369 }
3370 
3371 LayoutUnit RenderLayer::overflowTop() const
3372 {
3373     RenderBox* box = renderBox();
3374     LayoutRect overflowRect(box-&gt;layoutOverflowRect());
3375     box-&gt;flipForWritingMode(overflowRect);
3376     return overflowRect.y();
3377 }
3378 
3379 LayoutUnit RenderLayer::overflowBottom() const
3380 {
3381     RenderBox* box = renderBox();
3382     LayoutRect overflowRect(box-&gt;layoutOverflowRect());
3383     box-&gt;flipForWritingMode(overflowRect);
3384     return overflowRect.maxY();
3385 }
3386 
3387 LayoutUnit RenderLayer::overflowLeft() const
3388 {
3389     RenderBox* box = renderBox();
3390     LayoutRect overflowRect(box-&gt;layoutOverflowRect());
3391     box-&gt;flipForWritingMode(overflowRect);
3392     return overflowRect.x();
3393 }
3394 
3395 LayoutUnit RenderLayer::overflowRight() const
3396 {
3397     RenderBox* box = renderBox();
3398     LayoutRect overflowRect(box-&gt;layoutOverflowRect());
3399     box-&gt;flipForWritingMode(overflowRect);
3400     return overflowRect.maxX();
3401 }
3402 
3403 void RenderLayer::computeScrollDimensions()
3404 {
3405     RenderBox* box = renderBox();
3406     ASSERT(box);
3407 
3408     m_scrollDimensionsDirty = false;
3409 
3410     m_scrollSize.setWidth(roundToInt(overflowRight() - overflowLeft()));
3411     m_scrollSize.setHeight(roundToInt(overflowBottom() - overflowTop()));
3412 
3413     int scrollableLeftOverflow = roundToInt(overflowLeft() - box-&gt;borderLeft());
3414     if (shouldPlaceBlockDirectionScrollbarOnLeft())
3415         scrollableLeftOverflow -= verticalScrollbarWidth();
3416     int scrollableTopOverflow = roundToInt(overflowTop() - box-&gt;borderTop());
3417     setScrollOrigin(IntPoint(-scrollableLeftOverflow, -scrollableTopOverflow));
3418 }
3419 
3420 bool RenderLayer::hasScrollableHorizontalOverflow() const
3421 {
3422     return hasHorizontalOverflow() &amp;&amp; renderBox()-&gt;scrollsOverflowX();
3423 }
3424 
3425 bool RenderLayer::hasScrollableVerticalOverflow() const
3426 {
3427     return hasVerticalOverflow() &amp;&amp; renderBox()-&gt;scrollsOverflowY();
3428 }
3429 
3430 bool RenderLayer::hasHorizontalOverflow() const
3431 {
3432     ASSERT(!m_scrollDimensionsDirty);
3433 
3434     return scrollWidth() &gt; roundToInt(renderBox()-&gt;clientWidth());
3435 }
3436 
3437 bool RenderLayer::hasVerticalOverflow() const
3438 {
3439     ASSERT(!m_scrollDimensionsDirty);
3440 
3441     return scrollHeight() &gt; roundToInt(renderBox()-&gt;clientHeight());
3442 }
3443 
3444 static bool styleRequiresScrollbar(const RenderStyle&amp; style, ScrollbarOrientation axis)
3445 {
3446     Overflow overflow = axis == ScrollbarOrientation::HorizontalScrollbar ? style.overflowX() : style.overflowY();
3447     bool overflowScrollActsLikeAuto = overflow == Overflow::Scroll &amp;&amp; !style.hasPseudoStyle(PseudoId::Scrollbar) &amp;&amp; ScrollbarTheme::theme().usesOverlayScrollbars();
3448     return overflow == Overflow::Scroll &amp;&amp; !overflowScrollActsLikeAuto;
3449 }
3450 
3451 static bool styleDefinesAutomaticScrollbar(const RenderStyle&amp; style, ScrollbarOrientation axis)
3452 {
3453     Overflow overflow = axis == ScrollbarOrientation::HorizontalScrollbar ? style.overflowX() : style.overflowY();
3454     bool overflowScrollActsLikeAuto = overflow == Overflow::Scroll &amp;&amp; !style.hasPseudoStyle(PseudoId::Scrollbar) &amp;&amp; ScrollbarTheme::theme().usesOverlayScrollbars();
3455     return overflow == Overflow::Auto || overflowScrollActsLikeAuto;
3456 }
3457 
3458 void RenderLayer::updateScrollbarsAfterLayout()
3459 {
3460     RenderBox* box = renderBox();
3461     ASSERT(box);
3462 
3463     // List box parts handle the scrollbars by themselves so we have nothing to do.
3464     if (box-&gt;style().appearance() == ListboxPart)
3465         return;
3466 
3467     bool hasHorizontalOverflow = this-&gt;hasHorizontalOverflow();
3468     bool hasVerticalOverflow = this-&gt;hasVerticalOverflow();
3469 
3470     // If overflow requires a scrollbar, then we just need to enable or disable.
3471     if (m_hBar &amp;&amp; styleRequiresScrollbar(renderer().style(), HorizontalScrollbar))
3472         m_hBar-&gt;setEnabled(hasHorizontalOverflow);
3473     if (m_vBar &amp;&amp; styleRequiresScrollbar(renderer().style(), VerticalScrollbar))
3474         m_vBar-&gt;setEnabled(hasVerticalOverflow);
3475 
3476     // Scrollbars with auto behavior may need to lay out again if scrollbars got added or removed.
3477     bool autoHorizontalScrollBarChanged = box-&gt;hasHorizontalScrollbarWithAutoBehavior() &amp;&amp; (hasHorizontalScrollbar() != hasHorizontalOverflow);
3478     bool autoVerticalScrollBarChanged = box-&gt;hasVerticalScrollbarWithAutoBehavior() &amp;&amp; (hasVerticalScrollbar() != hasVerticalOverflow);
3479 
3480     if (autoHorizontalScrollBarChanged || autoVerticalScrollBarChanged) {
3481         if (box-&gt;hasHorizontalScrollbarWithAutoBehavior())
3482             setHasHorizontalScrollbar(hasHorizontalOverflow);
3483         if (box-&gt;hasVerticalScrollbarWithAutoBehavior())
3484             setHasVerticalScrollbar(hasVerticalOverflow);
3485 
3486         updateSelfPaintingLayer();
3487 
3488         renderer().document().invalidateScrollbarDependentRegions();
3489         renderer().repaint();
3490 
3491         if (renderer().style().overflowX() == Overflow::Auto || renderer().style().overflowY() == Overflow::Auto) {
3492             if (!m_inOverflowRelayout) {
3493                 m_inOverflowRelayout = true;
3494                 renderer().setNeedsLayout(MarkOnlyThis);
3495                 if (is&lt;RenderBlock&gt;(renderer())) {
3496                     RenderBlock&amp; block = downcast&lt;RenderBlock&gt;(renderer());
3497                     block.scrollbarsChanged(autoHorizontalScrollBarChanged, autoVerticalScrollBarChanged);
3498                     block.layoutBlock(true);
3499                 } else
3500                     renderer().layout();
3501                 m_inOverflowRelayout = false;
3502             }
3503         }
3504 
3505         RenderObject* parent = renderer().parent();
3506         if (parent &amp;&amp; parent-&gt;isFlexibleBox() &amp;&amp; renderer().isBox())
3507             downcast&lt;RenderFlexibleBox&gt;(parent)-&gt;clearCachedMainSizeForChild(*renderBox());
3508     }
3509 
3510     // Set up the range (and page step/line step).
3511     if (m_hBar) {
3512         int clientWidth = roundToInt(box-&gt;clientWidth());
3513         int pageStep = Scrollbar::pageStep(clientWidth);
3514         m_hBar-&gt;setSteps(Scrollbar::pixelsPerLineStep(), pageStep);
3515         m_hBar-&gt;setProportion(clientWidth, m_scrollSize.width());
3516     }
3517     if (m_vBar) {
3518         int clientHeight = roundToInt(box-&gt;clientHeight());
3519         int pageStep = Scrollbar::pageStep(clientHeight);
3520         m_vBar-&gt;setSteps(Scrollbar::pixelsPerLineStep(), pageStep);
3521         m_vBar-&gt;setProportion(clientHeight, m_scrollSize.height());
3522     }
3523 
3524     updateScrollableAreaSet(hasScrollableHorizontalOverflow() || hasScrollableVerticalOverflow());
3525 }
3526 
3527 // This is called from layout code (before updateLayerPositions).
3528 void RenderLayer::updateScrollInfoAfterLayout()
3529 {
3530     RenderBox* box = renderBox();
3531     if (!box)
3532         return;
3533 
3534     m_scrollDimensionsDirty = true;
3535     ScrollOffset originalScrollOffset = scrollOffset();
3536 
3537     computeScrollDimensions();
3538 
3539 #if ENABLE(CSS_SCROLL_SNAP)
3540     // FIXME: Ensure that offsets are also updated in case of programmatic style changes.
3541     // https://bugs.webkit.org/show_bug.cgi?id=135964
3542     updateSnapOffsets();
3543 #endif
3544 
3545     if (!box-&gt;isHTMLMarquee() &amp;&amp; !isRubberBandInProgress()) {
3546         // Layout may cause us to be at an invalid scroll position. In this case we need
3547         // to pull our scroll offsets back to the max (or push them up to the min).
3548         ScrollOffset clampedScrollOffset = clampScrollOffset(scrollOffset());
3549 #if PLATFORM(IOS_FAMILY)
3550         // FIXME: This looks wrong. The caret adjust mode should only be enabled on editing related entry points.
3551         // This code was added to fix an issue where the text insertion point would always be drawn on the right edge
3552         // of a text field whose content overflowed its bounds. See &lt;rdar://problem/15579797&gt; for more details.
3553         setAdjustForIOSCaretWhenScrolling(true);
3554 #endif
3555         if (clampedScrollOffset != scrollOffset())
3556             scrollToOffset(clampedScrollOffset);
3557 
3558 #if PLATFORM(IOS_FAMILY)
3559         setAdjustForIOSCaretWhenScrolling(false);
3560 #endif
3561     }
3562 
3563     updateScrollbarsAfterLayout();
3564 
3565     if (originalScrollOffset != scrollOffset())
3566         scrollToOffsetWithoutAnimation(IntPoint(scrollOffset()));
3567 
3568     if (isComposited()) {
3569         setNeedsCompositingGeometryUpdate();
3570         setNeedsCompositingConfigurationUpdate();
3571     }
3572 
3573 #if PLATFORM(IOS_FAMILY)
3574     if (canUseCompositedScrolling())
3575         setNeedsPostLayoutCompositingUpdate();
3576 #endif
3577 
3578     updateScrollSnapState();
3579 }
3580 
3581 bool RenderLayer::overflowControlsIntersectRect(const IntRect&amp; localRect) const
3582 {
3583     const IntRect borderBox = snappedIntRect(renderBox()-&gt;borderBoxRect());
3584 
3585     if (rectForHorizontalScrollbar(borderBox).intersects(localRect))
3586         return true;
3587 
3588     if (rectForVerticalScrollbar(borderBox).intersects(localRect))
3589         return true;
3590 
3591     if (scrollCornerRect().intersects(localRect))
3592         return true;
3593 
3594     if (resizerCornerRect(*this, borderBox).intersects(localRect))
3595         return true;
3596 
3597     return false;
3598 }
3599 
3600 bool RenderLayer::showsOverflowControls() const
3601 {
3602 #if PLATFORM(IOS_FAMILY)
3603     // On iOS, the scrollbars are made in the UI process.
3604     return !canUseCompositedScrolling();
3605 #endif
3606 
3607     return true;
3608 }
3609 
3610 void RenderLayer::paintOverflowControls(GraphicsContext&amp; context, const IntPoint&amp; paintOffset, const IntRect&amp; damageRect, bool paintingOverlayControls)
3611 {
3612     // Don&#39;t do anything if we have no overflow.
3613     if (!renderer().hasOverflowClip())
3614         return;
3615 
3616     if (!showsOverflowControls())
3617         return;
3618 
3619     // Overlay scrollbars paint in a second pass through the layer tree so that they will paint
3620     // on top of everything else. If this is the normal painting pass, paintingOverlayControls
3621     // will be false, and we should just tell the root layer that there are overlay scrollbars
3622     // that need to be painted. That will cause the second pass through the layer tree to run,
3623     // and we&#39;ll paint the scrollbars then. In the meantime, cache tx and ty so that the
3624     // second pass doesn&#39;t need to re-enter the RenderTree to get it right.
3625     if (hasOverlayScrollbars() &amp;&amp; !paintingOverlayControls) {
3626         m_cachedOverlayScrollbarOffset = paintOffset;
3627 
3628         // It&#39;s not necessary to do the second pass if the scrollbars paint into layers.
3629         if ((m_hBar &amp;&amp; layerForHorizontalScrollbar()) || (m_vBar &amp;&amp; layerForVerticalScrollbar()))
3630             return;
3631         IntRect localDamgeRect = damageRect;
3632         localDamgeRect.moveBy(-paintOffset);
3633         if (!overflowControlsIntersectRect(localDamgeRect))
3634             return;
3635 
3636         RenderLayer* paintingRoot = enclosingCompositingLayer();
3637         if (!paintingRoot)
3638             paintingRoot = renderer().view().layer();
3639 
3640         paintingRoot-&gt;setContainsDirtyOverlayScrollbars(true);
3641         return;
3642     }
3643 
3644     // This check is required to avoid painting custom CSS scrollbars twice.
3645     if (paintingOverlayControls &amp;&amp; !hasOverlayScrollbars())
3646         return;
3647 
3648     IntPoint adjustedPaintOffset = paintOffset;
3649     if (paintingOverlayControls)
3650         adjustedPaintOffset = m_cachedOverlayScrollbarOffset;
3651 
3652     // Move the scrollbar widgets if necessary.  We normally move and resize widgets during layout, but sometimes
3653     // widgets can move without layout occurring (most notably when you scroll a document that
3654     // contains fixed positioned elements).
3655     positionOverflowControls(toIntSize(adjustedPaintOffset));
3656 
3657     // Now that we&#39;re sure the scrollbars are in the right place, paint them.
3658     if (m_hBar &amp;&amp; !layerForHorizontalScrollbar())
3659         m_hBar-&gt;paint(context, damageRect);
3660     if (m_vBar &amp;&amp; !layerForVerticalScrollbar())
3661         m_vBar-&gt;paint(context, damageRect);
3662 
3663     if (layerForScrollCorner())
3664         return;
3665 
3666     // We fill our scroll corner with white if we have a scrollbar that doesn&#39;t run all the way up to the
3667     // edge of the box.
3668     paintScrollCorner(context, adjustedPaintOffset, damageRect);
3669 
3670     // Paint our resizer last, since it sits on top of the scroll corner.
3671     paintResizer(context, adjustedPaintOffset, damageRect);
3672 }
3673 
3674 void RenderLayer::paintScrollCorner(GraphicsContext&amp; context, const IntPoint&amp; paintOffset, const IntRect&amp; damageRect)
3675 {
3676     IntRect absRect = scrollCornerRect();
3677     absRect.moveBy(paintOffset);
3678     if (!absRect.intersects(damageRect))
3679         return;
3680 
3681     if (context.invalidatingControlTints()) {
3682         updateScrollCornerStyle();
3683         return;
3684     }
3685 
3686     if (m_scrollCorner) {
3687         m_scrollCorner-&gt;paintIntoRect(context, paintOffset, absRect);
3688         return;
3689     }
3690 
3691     // We don&#39;t want to paint a corner if we have overlay scrollbars, since we need
3692     // to see what is behind it.
3693     if (!hasOverlayScrollbars())
3694         ScrollbarTheme::theme().paintScrollCorner(context, absRect);
3695 }
3696 
3697 void RenderLayer::drawPlatformResizerImage(GraphicsContext&amp; context, const LayoutRect&amp; resizerCornerRect)
3698 {
3699     RefPtr&lt;Image&gt; resizeCornerImage;
3700     FloatSize cornerResizerSize;
3701     if (renderer().document().deviceScaleFactor() &gt;= 2) {
3702         static NeverDestroyed&lt;Image*&gt; resizeCornerImageHiRes(&amp;Image::loadPlatformResource(&quot;textAreaResizeCorner@2x&quot;).leakRef());
3703         resizeCornerImage = resizeCornerImageHiRes;
3704         cornerResizerSize = resizeCornerImage-&gt;size();
3705         cornerResizerSize.scale(0.5f);
3706     } else {
3707         static NeverDestroyed&lt;Image*&gt; resizeCornerImageLoRes(&amp;Image::loadPlatformResource(&quot;textAreaResizeCorner&quot;).leakRef());
3708         resizeCornerImage = resizeCornerImageLoRes;
3709         cornerResizerSize = resizeCornerImage-&gt;size();
3710     }
3711 
3712     if (shouldPlaceBlockDirectionScrollbarOnLeft()) {
3713         context.save();
3714         context.translate(resizerCornerRect.x() + cornerResizerSize.width(), resizerCornerRect.y() + resizerCornerRect.height() - cornerResizerSize.height());
3715         context.scale(FloatSize(-1.0, 1.0));
3716         if (resizeCornerImage)
3717             context.drawImage(*resizeCornerImage, FloatRect(FloatPoint(), cornerResizerSize));
3718         context.restore();
3719         return;
3720     }
3721 
3722     if (!resizeCornerImage)
3723         return;
3724     FloatRect imageRect = snapRectToDevicePixels(LayoutRect(resizerCornerRect.maxXMaxYCorner() - cornerResizerSize, cornerResizerSize), renderer().document().deviceScaleFactor());
3725     context.drawImage(*resizeCornerImage, imageRect);
3726 }
3727 
3728 void RenderLayer::paintResizer(GraphicsContext&amp; context, const LayoutPoint&amp; paintOffset, const LayoutRect&amp; damageRect)
3729 {
3730     if (renderer().style().resize() == Resize::None)
3731         return;
3732 
3733     RenderBox* box = renderBox();
3734     ASSERT(box);
3735 
3736     LayoutRect absRect = resizerCornerRect(*this, box-&gt;borderBoxRect());
3737     absRect.moveBy(paintOffset);
3738     if (!absRect.intersects(damageRect))
3739         return;
3740 
3741     if (context.invalidatingControlTints()) {
3742         updateResizerStyle();
3743         return;
3744     }
3745 
3746     if (m_resizer) {
3747         m_resizer-&gt;paintIntoRect(context, paintOffset, absRect);
3748         return;
3749     }
3750 
3751     drawPlatformResizerImage(context, absRect);
3752 
3753     // Draw a frame around the resizer (1px grey line) if there are any scrollbars present.
3754     // Clipping will exclude the right and bottom edges of this frame.
3755     if (!hasOverlayScrollbars() &amp;&amp; (m_vBar || m_hBar)) {
3756         GraphicsContextStateSaver stateSaver(context);
3757         context.clip(absRect);
3758         LayoutRect largerCorner = absRect;
3759         largerCorner.setSize(LayoutSize(largerCorner.width() + 1_lu, largerCorner.height() + 1_lu));
3760         context.setStrokeColor(Color(makeRGB(217, 217, 217)));
3761         context.setStrokeThickness(1.0f);
3762         context.setFillColor(Color::transparent);
3763         context.drawRect(snappedIntRect(largerCorner));
3764     }
3765 }
3766 
3767 bool RenderLayer::isPointInResizeControl(const IntPoint&amp; absolutePoint) const
3768 {
3769     if (!canResize())
3770         return false;
3771 
3772     RenderBox* box = renderBox();
3773     ASSERT(box);
3774 
3775     IntPoint localPoint = roundedIntPoint(absoluteToContents(absolutePoint));
3776 
3777     IntRect localBounds(IntPoint(), snappedIntRect(box-&gt;frameRect()).size());
3778     return resizerCornerRect(*this, localBounds).contains(localPoint);
3779 }
3780 
3781 bool RenderLayer::hitTestOverflowControls(HitTestResult&amp; result, const IntPoint&amp; localPoint)
3782 {
3783     if (!m_hBar &amp;&amp; !m_vBar &amp;&amp; !canResize())
3784         return false;
3785 
3786     RenderBox* box = renderBox();
3787     ASSERT(box);
3788 
3789     IntRect resizeControlRect;
3790     if (renderer().style().resize() != Resize::None) {
3791         resizeControlRect = snappedIntRect(resizerCornerRect(*this, box-&gt;borderBoxRect()));
3792         if (resizeControlRect.contains(localPoint))
3793             return true;
3794     }
3795 
3796     int resizeControlSize = std::max(resizeControlRect.height(), 0);
3797 
3798     // FIXME: We should hit test the m_scrollCorner and pass it back through the result.
3799 
3800     if (m_vBar &amp;&amp; m_vBar-&gt;shouldParticipateInHitTesting()) {
3801         LayoutRect vBarRect(verticalScrollbarStart(0, box-&gt;width()),
3802                             box-&gt;borderTop(),
3803                             m_vBar-&gt;width(),
3804                             box-&gt;height() - (box-&gt;borderTop() + box-&gt;borderBottom()) - (m_hBar ? m_hBar-&gt;height() : resizeControlSize));
3805         if (vBarRect.contains(localPoint)) {
3806             result.setScrollbar(m_vBar.get());
3807             return true;
3808         }
3809     }
3810 
3811     resizeControlSize = std::max(resizeControlRect.width(), 0);
3812     if (m_hBar &amp;&amp; m_hBar-&gt;shouldParticipateInHitTesting()) {
3813         LayoutRect hBarRect(horizontalScrollbarStart(0),
3814                             box-&gt;height() - box-&gt;borderBottom() - m_hBar-&gt;height(),
3815                             box-&gt;width() - (box-&gt;borderLeft() + box-&gt;borderRight()) - (m_vBar ? m_vBar-&gt;width() : resizeControlSize),
3816                             m_hBar-&gt;height());
3817         if (hBarRect.contains(localPoint)) {
3818             result.setScrollbar(m_hBar.get());
3819             return true;
3820         }
3821     }
3822 
3823     return false;
3824 }
3825 
3826 bool RenderLayer::scroll(ScrollDirection direction, ScrollGranularity granularity, float multiplier)
3827 {
3828     return ScrollableArea::scroll(direction, granularity, multiplier);
3829 }
3830 
3831 void RenderLayer::paint(GraphicsContext&amp; context, const LayoutRect&amp; damageRect, const LayoutSize&amp; subpixelOffset, OptionSet&lt;PaintBehavior&gt; paintBehavior, RenderObject* subtreePaintRoot, OptionSet&lt;PaintLayerFlag&gt; paintFlags, SecurityOriginPaintPolicy paintPolicy)
3832 {
3833     OverlapTestRequestMap overlapTestRequests;
3834 
3835     LayerPaintingInfo paintingInfo(this, enclosingIntRect(damageRect), paintBehavior, subpixelOffset, subtreePaintRoot, &amp;overlapTestRequests, paintPolicy == SecurityOriginPaintPolicy::AccessibleOriginOnly);
3836     paintLayer(context, paintingInfo, paintFlags);
3837 
3838     for (auto&amp; widget : overlapTestRequests.keys())
3839         widget-&gt;setOverlapTestResult(false);
3840 }
3841 
3842 void RenderLayer::paintOverlayScrollbars(GraphicsContext&amp; context, const LayoutRect&amp; damageRect, OptionSet&lt;PaintBehavior&gt; paintBehavior, RenderObject* subtreePaintRoot)
3843 {
3844     if (!m_containsDirtyOverlayScrollbars)
3845         return;
3846 
3847     LayerPaintingInfo paintingInfo(this, enclosingIntRect(damageRect), paintBehavior, LayoutSize(), subtreePaintRoot);
3848     paintLayer(context, paintingInfo, PaintLayerPaintingOverlayScrollbars);
3849 
3850     m_containsDirtyOverlayScrollbars = false;
3851 }
3852 
3853 static bool inContainingBlockChain(RenderLayer* startLayer, RenderLayer* endLayer)
3854 {
3855     if (startLayer == endLayer)
3856         return true;
3857     for (const auto* currentBlock = startLayer-&gt;renderer().containingBlock(); currentBlock &amp;&amp; !is&lt;RenderView&gt;(*currentBlock); currentBlock = currentBlock-&gt;containingBlock()) {
3858         if (currentBlock-&gt;layer() == endLayer)
3859             return true;
3860     }
3861 
3862     return false;
3863 }
3864 
3865 void RenderLayer::clipToRect(GraphicsContext&amp; context, const LayerPaintingInfo&amp; paintingInfo, const ClipRect&amp; clipRect, BorderRadiusClippingRule rule)
3866 {
3867     float deviceScaleFactor = renderer().document().deviceScaleFactor();
3868     bool needsClipping = !clipRect.isInfinite() &amp;&amp; clipRect.rect() != paintingInfo.paintDirtyRect;
3869     if (needsClipping || clipRect.affectedByRadius())
3870         context.save();
3871 
3872     if (needsClipping) {
3873         LayoutRect adjustedClipRect = clipRect.rect();
3874         adjustedClipRect.move(paintingInfo.subpixelOffset);
3875         context.clip(snapRectToDevicePixels(adjustedClipRect, deviceScaleFactor));
3876     }
3877 
3878     if (clipRect.affectedByRadius()) {
3879         // If the clip rect has been tainted by a border radius, then we have to walk up our layer chain applying the clips from
3880         // any layers with overflow. The condition for being able to apply these clips is that the overflow object be in our
3881         // containing block chain so we check that also.
3882         for (RenderLayer* layer = rule == IncludeSelfForBorderRadius ? this : parent(); layer; layer = layer-&gt;parent()) {
3883             if (layer-&gt;renderer().hasOverflowClip() &amp;&amp; layer-&gt;renderer().style().hasBorderRadius() &amp;&amp; inContainingBlockChain(this, layer)) {
3884                 LayoutRect adjustedClipRect = LayoutRect(toLayoutPoint(layer-&gt;offsetFromAncestor(paintingInfo.rootLayer, AdjustForColumns)), layer-&gt;size());
3885                 adjustedClipRect.move(paintingInfo.subpixelOffset);
3886                 FloatRoundedRect roundedRect = layer-&gt;renderer().style().getRoundedInnerBorderFor(adjustedClipRect).pixelSnappedRoundedRectForPainting(deviceScaleFactor);
3887                 if (roundedRect.intersectionIsRectangular(paintingInfo.paintDirtyRect))
3888                     context.clip(snapRectToDevicePixels(intersection(paintingInfo.paintDirtyRect, adjustedClipRect), deviceScaleFactor));
3889                 else
3890                     context.clipRoundedRect(roundedRect);
3891             }
3892 
3893             if (layer == paintingInfo.rootLayer)
3894                 break;
3895         }
3896     }
3897 }
3898 
3899 void RenderLayer::restoreClip(GraphicsContext&amp; context, const LayerPaintingInfo&amp; paintingInfo, const ClipRect&amp; clipRect)
3900 {
3901     if ((!clipRect.isInfinite() &amp;&amp; clipRect.rect() != paintingInfo.paintDirtyRect) || clipRect.affectedByRadius())
3902         context.restore();
3903 }
3904 
3905 static void performOverlapTests(OverlapTestRequestMap&amp; overlapTestRequests, const RenderLayer* rootLayer, const RenderLayer* layer)
3906 {
3907     Vector&lt;OverlapTestRequestClient*&gt; overlappedRequestClients;
3908     LayoutRect boundingBox = layer-&gt;boundingBox(rootLayer, layer-&gt;offsetFromAncestor(rootLayer));
3909     for (auto&amp; request : overlapTestRequests) {
3910         if (!boundingBox.intersects(request.value))
3911             continue;
3912 
3913         request.key-&gt;setOverlapTestResult(true);
3914         overlappedRequestClients.append(request.key);
3915     }
3916     for (auto* client : overlappedRequestClients)
3917         overlapTestRequests.remove(client);
3918 }
3919 
3920 static inline bool shouldDoSoftwarePaint(const RenderLayer* layer, bool paintingReflection)
3921 {
3922     return paintingReflection &amp;&amp; !layer-&gt;has3DTransform();
3923 }
3924 
3925 static inline bool shouldSuppressPaintingLayer(RenderLayer* layer)
3926 {
3927     if (layer-&gt;renderer().style().isNotFinal() &amp;&amp; !layer-&gt;isRenderViewLayer() &amp;&amp; !layer-&gt;renderer().isDocumentElementRenderer())
3928         return true;
3929 
3930     // Avoid painting all layers if the document is in a state where visual updates aren&#39;t allowed.
3931     // A full repaint will occur in Document::setVisualUpdatesAllowed(bool) if painting is suppressed here.
3932     if (!layer-&gt;renderer().document().visualUpdatesAllowed())
3933         return true;
3934 
3935     return false;
3936 }
3937 
3938 static inline bool paintForFixedRootBackground(const RenderLayer* layer, OptionSet&lt;RenderLayer::PaintLayerFlag&gt; paintFlags)
3939 {
3940     return layer-&gt;renderer().isDocumentElementRenderer() &amp;&amp; (paintFlags &amp; RenderLayer::PaintLayerPaintingRootBackgroundOnly);
3941 }
3942 
3943 void RenderLayer::paintLayer(GraphicsContext&amp; context, const LayerPaintingInfo&amp; paintingInfo, OptionSet&lt;PaintLayerFlag&gt; paintFlags)
3944 {
3945     if (isComposited()) {
3946         // The performingPaintInvalidation() painting pass goes through compositing layers,
3947         // but we need to ensure that we don&#39;t cache clip rects computed with the wrong root in this case.
3948         if (context.performingPaintInvalidation() || (paintingInfo.paintBehavior &amp; PaintBehavior::FlattenCompositingLayers))
3949             paintFlags.add(PaintLayerTemporaryClipRects);
3950         else if (!backing()-&gt;paintsIntoWindow()
3951             &amp;&amp; !backing()-&gt;paintsIntoCompositedAncestor()
3952             &amp;&amp; !shouldDoSoftwarePaint(this, paintFlags.contains(PaintLayerPaintingReflection))
3953             &amp;&amp; !paintForFixedRootBackground(this, paintFlags)) {
3954             // If this RenderLayer should paint into its backing, that will be done via RenderLayerBacking::paintIntoLayer().
3955             return;
3956         }
3957     } else if (viewportConstrainedNotCompositedReason() == NotCompositedForBoundsOutOfView) {
3958         // Don&#39;t paint out-of-view viewport constrained layers (when doing prepainting) because they will never be visible
3959         // unless their position or viewport size is changed.
3960         ASSERT(renderer().isFixedPositioned());
3961         return;
3962     }
3963 
3964     // Non self-painting leaf layers don&#39;t need to be painted as their renderer() should properly paint itself.
3965     if (!isSelfPaintingLayer() &amp;&amp; !hasSelfPaintingLayerDescendant())
3966         return;
3967 
3968     if (shouldSuppressPaintingLayer(this))
3969         return;
3970 
3971     // If this layer is totally invisible then there is nothing to paint.
3972     if (!renderer().opacity())
3973         return;
3974 
3975     if (paintsWithTransparency(paintingInfo.paintBehavior))
3976         paintFlags.add(PaintLayerHaveTransparency);
3977 
3978     // PaintLayerAppliedTransform is used in RenderReplica, to avoid applying the transform twice.
3979     if (paintsWithTransform(paintingInfo.paintBehavior) &amp;&amp; !(paintFlags &amp; PaintLayerAppliedTransform)) {
3980         TransformationMatrix layerTransform = renderableTransform(paintingInfo.paintBehavior);
3981         // If the transform can&#39;t be inverted, then don&#39;t paint anything.
3982         if (!layerTransform.isInvertible())
3983             return;
3984 
3985         // If we have a transparency layer enclosing us and we are the root of a transform, then we need to establish the transparency
3986         // layer from the parent now, assuming there is a parent
3987         if (paintFlags &amp; PaintLayerHaveTransparency) {
3988             if (parent())
3989                 parent()-&gt;beginTransparencyLayers(context, paintingInfo, paintingInfo.paintDirtyRect);
3990             else
3991                 beginTransparencyLayers(context, paintingInfo, paintingInfo.paintDirtyRect);
3992         }
3993 
3994         if (enclosingPaginationLayer(ExcludeCompositedPaginatedLayers)) {
3995             paintTransformedLayerIntoFragments(context, paintingInfo, paintFlags);
3996             return;
3997         }
3998 
3999         // Make sure the parent&#39;s clip rects have been calculated.
4000         ClipRect clipRect = paintingInfo.paintDirtyRect;
4001         if (parent()) {
4002             ClipRectsContext clipRectsContext(paintingInfo.rootLayer, (paintFlags &amp; PaintLayerTemporaryClipRects) ? TemporaryClipRects : PaintingClipRects,
4003                 IgnoreOverlayScrollbarSize, (paintFlags &amp; PaintLayerPaintingOverflowContents) ? IgnoreOverflowClip : RespectOverflowClip);
4004             clipRect = backgroundClipRect(clipRectsContext);
4005             clipRect.intersect(paintingInfo.paintDirtyRect);
4006 
4007             // Push the parent coordinate space&#39;s clip.
4008             parent()-&gt;clipToRect(context, paintingInfo, clipRect);
4009         }
4010 
4011         paintLayerByApplyingTransform(context, paintingInfo, paintFlags);
4012 
4013         // Restore the clip.
4014         if (parent())
4015             parent()-&gt;restoreClip(context, paintingInfo, clipRect);
4016 
4017         return;
4018     }
4019 
4020     paintLayerContentsAndReflection(context, paintingInfo, paintFlags);
4021 }
4022 
4023 void RenderLayer::paintLayerContentsAndReflection(GraphicsContext&amp; context, const LayerPaintingInfo&amp; paintingInfo, OptionSet&lt;PaintLayerFlag&gt; paintFlags)
4024 {
4025     ASSERT(isSelfPaintingLayer() || hasSelfPaintingLayerDescendant());
4026 
4027     auto localPaintFlags = paintFlags - PaintLayerAppliedTransform;
4028 
4029     // Paint the reflection first if we have one.
4030     if (m_reflection &amp;&amp; !m_paintingInsideReflection) {
4031         // Mark that we are now inside replica painting.
4032         m_paintingInsideReflection = true;
4033         reflectionLayer()-&gt;paintLayer(context, paintingInfo, localPaintFlags | PaintLayerPaintingReflection);
4034         m_paintingInsideReflection = false;
4035     }
4036 
4037     localPaintFlags.add(paintLayerPaintingCompositingAllPhasesFlags());
4038     paintLayerContents(context, paintingInfo, localPaintFlags);
4039 }
4040 
4041 bool RenderLayer::setupFontSubpixelQuantization(GraphicsContext&amp; context, bool&amp; didQuantizeFonts)
4042 {
4043     if (context.paintingDisabled())
4044         return false;
4045 
4046     bool scrollingOnMainThread = true;
4047 #if ENABLE(ASYNC_SCROLLING)
4048     if (ScrollingCoordinator* scrollingCoordinator = page().scrollingCoordinator())
4049         scrollingOnMainThread = scrollingCoordinator-&gt;shouldUpdateScrollLayerPositionSynchronously(renderer().view().frameView());
4050 #endif
4051 
4052     // FIXME: We shouldn&#39;t have to disable subpixel quantization for overflow clips or subframes once we scroll those
4053     // things on the scrolling thread.
4054     bool contentsScrollByPainting = (renderer().hasOverflowClip() &amp;&amp; !usesCompositedScrolling()) || (renderer().frame().ownerElement());
4055     bool isZooming = !page().chrome().client().hasStablePageScaleFactor();
4056     if (scrollingOnMainThread || contentsScrollByPainting || isZooming) {
4057         didQuantizeFonts = context.shouldSubpixelQuantizeFonts();
4058         context.setShouldSubpixelQuantizeFonts(false);
4059         return true;
4060     }
4061     return false;
4062 }
4063 
4064 static inline LayoutRect computeReferenceBox(const RenderObject&amp; renderer, const CSSBoxType&amp; boxType, const LayoutSize&amp; offsetFromRoot, const LayoutRect&amp; rootRelativeBounds)
4065 {
4066     // FIXME: Support different reference boxes for inline content.
4067     // https://bugs.webkit.org/show_bug.cgi?id=129047
4068     if (!renderer.isBox())
4069         return rootRelativeBounds;
4070 
4071     LayoutRect referenceBox;
4072     const auto&amp; box = downcast&lt;RenderBox&gt;(renderer);
4073     switch (boxType) {
4074     case CSSBoxType::ContentBox:
4075     case CSSBoxType::FillBox:
4076         referenceBox = box.contentBoxRect();
4077         referenceBox.move(offsetFromRoot);
4078         break;
4079     case CSSBoxType::PaddingBox:
4080         referenceBox = box.paddingBoxRect();
4081         referenceBox.move(offsetFromRoot);
4082         break;
4083     case CSSBoxType::MarginBox:
4084         referenceBox = box.marginBoxRect();
4085         referenceBox.move(offsetFromRoot);
4086         break;
4087     // stroke-box, view-box compute to border-box for HTML elements.
4088     case CSSBoxType::StrokeBox:
4089     case CSSBoxType::ViewBox:
4090     case CSSBoxType::BorderBox:
4091     case CSSBoxType::BoxMissing:
4092         referenceBox = box.borderBoxRect();
4093         referenceBox.move(offsetFromRoot);
4094         break;
4095     }
4096 
4097     return referenceBox;
4098 }
4099 
4100 Path RenderLayer::computeClipPath(const LayoutSize&amp; offsetFromRoot, LayoutRect&amp; rootRelativeBounds, WindRule&amp; windRule) const
4101 {
4102     const RenderStyle&amp; style = renderer().style();
4103     float deviceSaleFactor = renderer().document().deviceScaleFactor();
4104 
4105     if (is&lt;ShapeClipPathOperation&gt;(*style.clipPath())) {
4106         auto&amp; clipPath = downcast&lt;ShapeClipPathOperation&gt;(*style.clipPath());
4107         FloatRect referenceBox = snapRectToDevicePixels(computeReferenceBox(renderer(), clipPath.referenceBox(), offsetFromRoot, rootRelativeBounds), deviceSaleFactor);
4108 
4109         windRule = clipPath.windRule();
4110         return clipPath.pathForReferenceRect(referenceBox);
4111     }
4112 
4113     if (is&lt;BoxClipPathOperation&gt;(*style.clipPath()) &amp;&amp; is&lt;RenderBox&gt;(renderer())) {
4114 
4115         auto&amp; clipPath = downcast&lt;BoxClipPathOperation&gt;(*style.clipPath());
4116 
4117         FloatRoundedRect shapeRect = computeRoundedRectForBoxShape(clipPath.referenceBox(), downcast&lt;RenderBox&gt;(renderer())).pixelSnappedRoundedRectForPainting(deviceSaleFactor);
4118         shapeRect.move(offsetFromRoot);
4119 
4120         windRule = WindRule::NonZero;
4121         return clipPath.pathForReferenceRect(shapeRect);
4122     }
4123 
4124     return Path();
4125 }
4126 
4127 bool RenderLayer::setupClipPath(GraphicsContext&amp; context, const LayerPaintingInfo&amp; paintingInfo, const LayoutSize&amp; offsetFromRoot, LayoutRect&amp; rootRelativeBounds, bool&amp; rootRelativeBoundsComputed)
4128 {
4129     if (!renderer().hasClipPath() || context.paintingDisabled())
4130         return false;
4131 
4132     if (!rootRelativeBoundsComputed) {
4133         rootRelativeBounds = calculateLayerBounds(paintingInfo.rootLayer, offsetFromRoot, { });
4134         rootRelativeBoundsComputed = true;
4135     }
4136 
4137     // SVG elements get clipped in SVG code.
4138     if (is&lt;RenderSVGRoot&gt;(renderer()))
4139         return false;
4140 
4141     auto&amp; style = renderer().style();
4142     LayoutSize paintingOffsetFromRoot = LayoutSize(snapSizeToDevicePixel(offsetFromRoot + paintingInfo.subpixelOffset, LayoutPoint(), renderer().document().deviceScaleFactor()));
4143     ASSERT(style.clipPath());
4144     if (is&lt;ShapeClipPathOperation&gt;(*style.clipPath()) || (is&lt;BoxClipPathOperation&gt;(*style.clipPath()) &amp;&amp; is&lt;RenderBox&gt;(renderer()))) {
4145         WindRule windRule;
4146         Path path = computeClipPath(paintingOffsetFromRoot, rootRelativeBounds, windRule);
4147         context.save();
4148         context.clipPath(path, windRule);
4149         return true;
4150     }
4151 
4152     if (style.clipPath()-&gt;type() == ClipPathOperation::Reference) {
4153         ReferenceClipPathOperation* referenceClipPathOperation = static_cast&lt;ReferenceClipPathOperation*&gt;(style.clipPath());
4154         Element* element = renderer().document().getElementById(referenceClipPathOperation-&gt;fragment());
4155         if (element &amp;&amp; element-&gt;renderer() &amp;&amp; is&lt;RenderSVGResourceClipper&gt;(element-&gt;renderer())) {
4156             context.save();
4157             float deviceSaleFactor = renderer().document().deviceScaleFactor();
4158             FloatRect referenceBox = snapRectToDevicePixels(computeReferenceBox(renderer(), CSSBoxType::ContentBox, paintingOffsetFromRoot, rootRelativeBounds), deviceSaleFactor);
4159             FloatPoint offset {referenceBox.location()};
4160             context.translate(offset);
4161             FloatRect svgReferenceBox {FloatPoint(), referenceBox.size()};
4162             downcast&lt;RenderSVGResourceClipper&gt;(*element-&gt;renderer()).applyClippingToContext(renderer(), svgReferenceBox, paintingInfo.paintDirtyRect, context);
4163             context.translate(FloatPoint(-offset.x(), -offset.y()));
4164             return true;
4165         }
4166     }
4167 
4168     return false;
4169 }
4170 
4171 RenderLayerFilters* RenderLayer::filtersForPainting(GraphicsContext&amp; context, OptionSet&lt;PaintLayerFlag&gt; paintFlags) const
4172 {
4173     if (context.paintingDisabled())
4174         return nullptr;
4175 
4176     if (paintFlags &amp; PaintLayerPaintingOverlayScrollbars)
4177         return nullptr;
4178 
4179     if (!paintsWithFilters())
4180         return nullptr;
4181 
4182     if (m_filters &amp;&amp; m_filters-&gt;filter())
4183         return m_filters.get();
4184 
4185     return nullptr;
4186 }
4187 
4188 GraphicsContext* RenderLayer::setupFilters(GraphicsContext&amp; destinationContext, LayerPaintingInfo&amp; paintingInfo, OptionSet&lt;PaintLayerFlag&gt; paintFlags, const LayoutSize&amp; offsetFromRoot, LayoutRect&amp; rootRelativeBounds, bool&amp; rootRelativeBoundsComputed)
4189 {
4190     auto* paintingFilters = filtersForPainting(destinationContext, paintFlags);
4191     if (!paintingFilters)
4192         return nullptr;
4193 
4194     LayoutRect filterRepaintRect = paintingFilters-&gt;dirtySourceRect();
4195     filterRepaintRect.move(offsetFromRoot);
4196 
4197     if (!rootRelativeBoundsComputed) {
4198         rootRelativeBounds = calculateLayerBounds(paintingInfo.rootLayer, offsetFromRoot, { });
4199         rootRelativeBoundsComputed = true;
4200     }
4201 
4202     GraphicsContext* filterContext = paintingFilters-&gt;beginFilterEffect(destinationContext, enclosingIntRect(rootRelativeBounds), enclosingIntRect(paintingInfo.paintDirtyRect), enclosingIntRect(filterRepaintRect));
4203     if (!filterContext)
4204         return nullptr;
4205 
4206     paintingInfo.paintDirtyRect = paintingFilters-&gt;repaintRect();
4207 
4208     // If the filter needs the full source image, we need to avoid using the clip rectangles.
4209     // Otherwise, if for example this layer has overflow:hidden, a drop shadow will not compute correctly.
4210     // Note that we will still apply the clipping on the final rendering of the filter.
4211     paintingInfo.clipToDirtyRect = !paintingFilters-&gt;hasFilterThatMovesPixels();
4212 
4213     paintingInfo.requireSecurityOriginAccessForWidgets = paintingFilters-&gt;hasFilterThatShouldBeRestrictedBySecurityOrigin();
4214 
4215     return filterContext;
4216 }
4217 
4218 void RenderLayer::applyFilters(GraphicsContext&amp; originalContext, const LayerPaintingInfo&amp; paintingInfo, const LayerFragments&amp; layerFragments)
4219 {
4220     // FIXME: Handle more than one fragment.
4221     ClipRect backgroundRect = layerFragments.isEmpty() ? ClipRect() : layerFragments[0].backgroundRect;
4222     clipToRect(originalContext, paintingInfo, backgroundRect);
4223     m_filters-&gt;applyFilterEffect(originalContext);
4224     restoreClip(originalContext, paintingInfo, backgroundRect);
4225 }
4226 
4227 void RenderLayer::paintLayerContents(GraphicsContext&amp; context, const LayerPaintingInfo&amp; paintingInfo, OptionSet&lt;PaintLayerFlag&gt; paintFlags)
4228 {
4229     ASSERT(isSelfPaintingLayer() || hasSelfPaintingLayerDescendant());
4230 
4231     auto localPaintFlags = paintFlags - PaintLayerAppliedTransform;
4232     bool haveTransparency = localPaintFlags.contains(PaintLayerHaveTransparency);
4233     bool isSelfPaintingLayer = this-&gt;isSelfPaintingLayer();
4234     bool isPaintingOverlayScrollbars = paintFlags.contains(PaintLayerPaintingOverlayScrollbars);
4235     bool isPaintingScrollingContent = paintFlags.contains(PaintLayerPaintingCompositingScrollingPhase);
4236     bool isPaintingCompositedForeground = paintFlags.contains(PaintLayerPaintingCompositingForegroundPhase);
4237     bool isPaintingCompositedBackground = paintFlags.contains(PaintLayerPaintingCompositingBackgroundPhase);
4238     bool isPaintingOverflowContents = paintFlags.contains(PaintLayerPaintingOverflowContents);
4239     // Outline always needs to be painted even if we have no visible content. Also,
4240     // the outline is painted in the background phase during composited scrolling.
4241     // If it were painted in the foreground phase, it would move with the scrolled
4242     // content. When not composited scrolling, the outline is painted in the
4243     // foreground phase. Since scrolled contents are moved by repainting in this
4244     // case, the outline won&#39;t get &#39;dragged along&#39;.
4245     bool shouldPaintOutline = isSelfPaintingLayer &amp;&amp; !isPaintingOverlayScrollbars
4246         &amp;&amp; ((isPaintingScrollingContent &amp;&amp; isPaintingCompositedBackground)
4247         || (!isPaintingScrollingContent &amp;&amp; isPaintingCompositedForeground));
4248     bool shouldPaintContent = m_hasVisibleContent &amp;&amp; isSelfPaintingLayer &amp;&amp; !isPaintingOverlayScrollbars;
4249 
4250     if (localPaintFlags &amp; PaintLayerPaintingRootBackgroundOnly &amp;&amp; !renderer().isRenderView() &amp;&amp; !renderer().isDocumentElementRenderer())
4251         return;
4252 
4253     updateLayerListsIfNeeded();
4254 
4255     LayoutSize offsetFromRoot = offsetFromAncestor(paintingInfo.rootLayer);
4256     LayoutRect rootRelativeBounds;
4257     bool rootRelativeBoundsComputed = false;
4258 
4259     // FIXME: We shouldn&#39;t have to disable subpixel quantization for overflow clips or subframes once we scroll those
4260     // things on the scrolling thread.
4261     bool didQuantizeFonts = true;
4262     bool needToAdjustSubpixelQuantization = setupFontSubpixelQuantization(context, didQuantizeFonts);
4263 
4264     // Apply clip-path to context.
4265     LayoutSize columnAwareOffsetFromRoot = offsetFromRoot;
4266     if (renderer().enclosingFragmentedFlow() &amp;&amp; (renderer().hasClipPath() || filtersForPainting(context, paintFlags)))
4267         columnAwareOffsetFromRoot = toLayoutSize(convertToLayerCoords(paintingInfo.rootLayer, LayoutPoint(), AdjustForColumns));
4268 
4269     bool hasClipPath = false;
4270     if (shouldApplyClipPath(paintingInfo.paintBehavior, localPaintFlags))
4271         hasClipPath = setupClipPath(context, paintingInfo, columnAwareOffsetFromRoot, rootRelativeBounds, rootRelativeBoundsComputed);
4272 
4273     bool selectionAndBackgroundsOnly = paintingInfo.paintBehavior.contains(PaintBehavior::SelectionAndBackgroundsOnly);
4274     bool selectionOnly = paintingInfo.paintBehavior.contains(PaintBehavior::SelectionOnly);
4275 
4276     SinglePaintFrequencyTracking singlePaintFrequencyTracking(m_paintFrequencyTracker, shouldPaintContent);
4277 
4278     LayerFragments layerFragments;
4279     RenderObject* subtreePaintRootForRenderer = nullptr;
4280 
4281     { // Scope for filter-related state changes.
4282         LayerPaintingInfo localPaintingInfo(paintingInfo);
4283         GraphicsContext* filterContext = setupFilters(context, localPaintingInfo, paintFlags, columnAwareOffsetFromRoot, rootRelativeBounds, rootRelativeBoundsComputed);
4284         if (filterContext &amp;&amp; haveTransparency) {
4285             // If we have a filter and transparency, we have to eagerly start a transparency layer here, rather than risk a child layer lazily starts one with the wrong context.
4286             beginTransparencyLayers(context, localPaintingInfo, paintingInfo.paintDirtyRect);
4287         }
4288         GraphicsContext&amp; currentContext = filterContext ? *filterContext : context;
4289 
4290         // If this layer&#39;s renderer is a child of the subtreePaintRoot, we render unconditionally, which
4291         // is done by passing a nil subtreePaintRoot down to our renderer (as if no subtreePaintRoot was ever set).
4292         // Otherwise, our renderer tree may or may not contain the subtreePaintRoot root, so we pass that root along
4293         // so it will be tested against as we descend through the renderers.
4294         if (localPaintingInfo.subtreePaintRoot &amp;&amp; !renderer().isDescendantOf(localPaintingInfo.subtreePaintRoot))
4295             subtreePaintRootForRenderer = localPaintingInfo.subtreePaintRoot;
4296 
4297         if (localPaintingInfo.overlapTestRequests &amp;&amp; isSelfPaintingLayer)
4298             performOverlapTests(*localPaintingInfo.overlapTestRequests, localPaintingInfo.rootLayer, this);
4299 
4300         OptionSet&lt;PaintBehavior&gt; paintBehavior = PaintBehavior::Normal;
4301         if (localPaintFlags &amp; PaintLayerPaintingSkipRootBackground)
4302             paintBehavior.add(PaintBehavior::SkipRootBackground);
4303         else if (localPaintFlags &amp; PaintLayerPaintingRootBackgroundOnly)
4304             paintBehavior.add(PaintBehavior::RootBackgroundOnly);
4305 
4306         if (paintingInfo.paintBehavior &amp; PaintBehavior::FlattenCompositingLayers)
4307             paintBehavior.add(PaintBehavior::FlattenCompositingLayers);
4308 
4309         if (paintingInfo.paintBehavior &amp; PaintBehavior::Snapshotting)
4310             paintBehavior.add(PaintBehavior::Snapshotting);
4311 
4312         if ((paintingInfo.paintBehavior &amp; PaintBehavior::TileFirstPaint) &amp;&amp; isRenderViewLayer())
4313             paintBehavior.add(PaintBehavior::TileFirstPaint);
4314 
4315         if (paintingInfo.paintBehavior &amp; PaintBehavior::ExcludeSelection)
4316             paintBehavior.add(PaintBehavior::ExcludeSelection);
4317 
4318         LayoutRect paintDirtyRect = localPaintingInfo.paintDirtyRect;
4319         if (shouldPaintContent || shouldPaintOutline || isPaintingOverlayScrollbars) {
4320             // Collect the fragments. This will compute the clip rectangles and paint offsets for each layer fragment, as well as whether or not the content of each
4321             // fragment should paint. If the parent&#39;s filter dictates full repaint to ensure proper filter effect,
4322             // use the overflow clip as dirty rect, instead of no clipping. It maintains proper clipping for overflow::scroll.
4323             if (!localPaintingInfo.clipToDirtyRect &amp;&amp; renderer().hasOverflowClip()) {
4324                 // We can turn clipping back by requesting full repaint for the overflow area.
4325                 localPaintingInfo.clipToDirtyRect = true;
4326                 paintDirtyRect = clipRectRelativeToAncestor(localPaintingInfo.rootLayer, offsetFromRoot, LayoutRect::infiniteRect());
4327             }
4328             collectFragments(layerFragments, localPaintingInfo.rootLayer, paintDirtyRect, ExcludeCompositedPaginatedLayers,
4329                 (localPaintFlags &amp; PaintLayerTemporaryClipRects) ? TemporaryClipRects : PaintingClipRects, IgnoreOverlayScrollbarSize,
4330                 (isPaintingOverflowContents) ? IgnoreOverflowClip : RespectOverflowClip, offsetFromRoot);
4331             updatePaintingInfoForFragments(layerFragments, localPaintingInfo, localPaintFlags, shouldPaintContent, offsetFromRoot);
4332         }
4333 
4334         if (isPaintingCompositedBackground) {
4335             // Paint only the backgrounds for all of the fragments of the layer.
4336             if (shouldPaintContent &amp;&amp; !selectionOnly) {
4337                 paintBackgroundForFragments(layerFragments, currentContext, context, paintingInfo.paintDirtyRect, haveTransparency,
4338                     localPaintingInfo, paintBehavior, subtreePaintRootForRenderer);
4339             }
4340         }
4341 
4342         // Now walk the sorted list of children with negative z-indices.
4343         if ((isPaintingScrollingContent &amp;&amp; isPaintingOverflowContents) || (!isPaintingScrollingContent &amp;&amp; isPaintingCompositedBackground))
4344             paintList(negativeZOrderLayers(), currentContext, localPaintingInfo, localPaintFlags);
4345 
4346         if (isPaintingCompositedForeground) {
4347             if (shouldPaintContent) {
4348                 paintForegroundForFragments(layerFragments, currentContext, context, paintingInfo.paintDirtyRect, haveTransparency,
4349                     localPaintingInfo, paintBehavior, subtreePaintRootForRenderer);
4350             }
4351         }
4352 
4353         if (shouldPaintOutline)
4354             paintOutlineForFragments(layerFragments, currentContext, localPaintingInfo, paintBehavior, subtreePaintRootForRenderer);
4355 
4356         if (isPaintingCompositedForeground) {
4357             // Paint any child layers that have overflow.
4358             paintList(normalFlowLayers(), currentContext, localPaintingInfo, localPaintFlags);
4359 
4360             // Now walk the sorted list of children with positive z-indices.
4361             paintList(positiveZOrderLayers(), currentContext, localPaintingInfo, localPaintFlags);
4362         }
4363 
4364         if (isPaintingOverlayScrollbars &amp;&amp; hasScrollbars())
4365             paintOverflowControlsForFragments(layerFragments, currentContext, localPaintingInfo);
4366 
4367         if (filterContext) {
4368             // When we called collectFragments() last time, paintDirtyRect was reset to represent the filter bounds.
4369             // Now we need to compute the backgroundRect uncontaminated by filters, in order to clip the filtered result.
4370             // Note that we also use paintingInfo here, not localPaintingInfo which filters also contaminated.
4371             LayerFragments layerFragments;
4372             collectFragments(layerFragments, paintingInfo.rootLayer, paintingInfo.paintDirtyRect, ExcludeCompositedPaginatedLayers,
4373                 (localPaintFlags &amp; PaintLayerTemporaryClipRects) ? TemporaryClipRects : PaintingClipRects, IgnoreOverlayScrollbarSize,
4374                 (isPaintingOverflowContents) ? IgnoreOverflowClip : RespectOverflowClip, offsetFromRoot);
4375             updatePaintingInfoForFragments(layerFragments, paintingInfo, localPaintFlags, shouldPaintContent, offsetFromRoot);
4376 
4377             applyFilters(context, paintingInfo, layerFragments);
4378         }
4379     }
4380 
4381     if (shouldPaintContent &amp;&amp; !(selectionOnly || selectionAndBackgroundsOnly)) {
4382         OptionSet&lt;PaintBehavior&gt; paintBehavior = PaintBehavior::Normal;
4383         if (paintingInfo.paintBehavior &amp; PaintBehavior::FlattenCompositingLayers)
4384             paintBehavior.add(PaintBehavior::FlattenCompositingLayers);
4385 
4386         if (paintingInfo.paintBehavior &amp; PaintBehavior::Snapshotting)
4387             paintBehavior.add(PaintBehavior::Snapshotting);
4388 
4389         if (paintingInfo.paintBehavior &amp; PaintBehavior::TileFirstPaint)
4390             paintBehavior.add(PaintBehavior::TileFirstPaint);
4391 
4392         if (shouldPaintMask(paintingInfo.paintBehavior, localPaintFlags)) {
4393             // Paint the mask for the fragments.
4394             paintMaskForFragments(layerFragments, context, paintingInfo, paintBehavior, subtreePaintRootForRenderer);
4395         }
4396 
4397         if (!(paintFlags &amp; PaintLayerPaintingCompositingMaskPhase) &amp;&amp; (paintFlags &amp; PaintLayerPaintingCompositingClipPathPhase)) {
4398             // Re-use paintChildClippingMaskForFragments to paint black for the compositing clipping mask.
4399             paintChildClippingMaskForFragments(layerFragments, context, paintingInfo, paintBehavior, subtreePaintRootForRenderer);
4400         }
4401 
4402         if (localPaintFlags &amp; PaintLayerPaintingChildClippingMaskPhase) {
4403             // Paint the border radius mask for the fragments.
4404             paintChildClippingMaskForFragments(layerFragments, context, paintingInfo, paintBehavior, subtreePaintRootForRenderer);
4405         }
4406     }
4407 
4408     // End our transparency layer
4409     if (haveTransparency &amp;&amp; m_usedTransparency &amp;&amp; !m_paintingInsideReflection) {
4410         context.endTransparencyLayer();
4411         context.restore();
4412         m_usedTransparency = false;
4413     }
4414 
4415     // Re-set this to whatever it was before we painted the layer.
4416     if (needToAdjustSubpixelQuantization)
4417         context.setShouldSubpixelQuantizeFonts(didQuantizeFonts);
4418 
4419     if (hasClipPath)
4420         context.restore();
4421 }
4422 
4423 void RenderLayer::paintLayerByApplyingTransform(GraphicsContext&amp; context, const LayerPaintingInfo&amp; paintingInfo, OptionSet&lt;PaintLayerFlag&gt; paintFlags, const LayoutSize&amp; translationOffset)
4424 {
4425     // This involves subtracting out the position of the layer in our current coordinate space, but preserving
4426     // the accumulated error for sub-pixel layout.
4427     float deviceScaleFactor = renderer().document().deviceScaleFactor();
4428     LayoutSize offsetFromParent = offsetFromAncestor(paintingInfo.rootLayer);
4429     offsetFromParent += translationOffset;
4430     TransformationMatrix transform(renderableTransform(paintingInfo.paintBehavior));
4431     // Add the subpixel accumulation to the current layer&#39;s offset so that we can always snap the translateRight value to where the renderer() is supposed to be painting.
4432     LayoutSize offsetForThisLayer = offsetFromParent + paintingInfo.subpixelOffset;
4433     FloatSize devicePixelSnappedOffsetForThisLayer = toFloatSize(roundPointToDevicePixels(toLayoutPoint(offsetForThisLayer), deviceScaleFactor));
4434     // We handle accumulated subpixels through nested layers here. Since the context gets translated to device pixels,
4435     // all we need to do is add the delta to the accumulated pixels coming from ancestor layers.
4436     // Translate the graphics context to the snapping position to avoid off-device-pixel positing.
4437     transform.translateRight(devicePixelSnappedOffsetForThisLayer.width(), devicePixelSnappedOffsetForThisLayer.height());
4438     // Apply the transform.
4439     AffineTransform oldTransfrom = context.getCTM();
4440     context.concatCTM(transform.toAffineTransform());
4441 
4442     // Now do a paint with the root layer shifted to be us.
4443     LayoutSize adjustedSubpixelOffset = offsetForThisLayer - LayoutSize(devicePixelSnappedOffsetForThisLayer);
4444     LayerPaintingInfo transformedPaintingInfo(paintingInfo);
4445     transformedPaintingInfo.rootLayer = this;
4446     transformedPaintingInfo.paintDirtyRect = LayoutRect(encloseRectToDevicePixels(transform.inverse().valueOr(AffineTransform()).mapRect(paintingInfo.paintDirtyRect), deviceScaleFactor));
4447     transformedPaintingInfo.subpixelOffset = adjustedSubpixelOffset;
4448     paintLayerContentsAndReflection(context, transformedPaintingInfo, paintFlags);
4449     context.setCTM(oldTransfrom);
4450 }
4451 
4452 void RenderLayer::paintList(LayerList layerIterator, GraphicsContext&amp; context, const LayerPaintingInfo&amp; paintingInfo, OptionSet&lt;PaintLayerFlag&gt; paintFlags)
4453 {
4454     if (layerIterator.begin() == layerIterator.end())
4455         return;
4456 
4457     if (!hasSelfPaintingLayerDescendant())
4458         return;
4459 
4460 #if !ASSERT_DISABLED
4461     LayerListMutationDetector mutationChecker(*this);
4462 #endif
4463 
4464     for (auto* childLayer : layerIterator)
4465         childLayer-&gt;paintLayer(context, paintingInfo, paintFlags);
4466 }
4467 
4468 RenderLayer* RenderLayer::enclosingPaginationLayerInSubtree(const RenderLayer* rootLayer, PaginationInclusionMode mode) const
4469 {
4470     // If we don&#39;t have an enclosing layer, or if the root layer is the same as the enclosing layer,
4471     // then just return the enclosing pagination layer (it will be 0 in the former case and the rootLayer in the latter case).
4472     RenderLayer* paginationLayer = enclosingPaginationLayer(mode);
4473     if (!paginationLayer || rootLayer == paginationLayer)
4474         return paginationLayer;
4475 
4476     // Walk up the layer tree and see which layer we hit first. If it&#39;s the root, then the enclosing pagination
4477     // layer isn&#39;t in our subtree and we return nullptr. If we hit the enclosing pagination layer first, then
4478     // we can return it.
4479     for (const RenderLayer* layer = this; layer; layer = layer-&gt;parent()) {
4480         if (layer == rootLayer)
4481             return nullptr;
4482         if (layer == paginationLayer)
4483             return paginationLayer;
4484     }
4485 
4486     // This should never be reached, since an enclosing layer should always either be the rootLayer or be
4487     // our enclosing pagination layer.
4488     ASSERT_NOT_REACHED();
4489     return nullptr;
4490 }
4491 
4492 void RenderLayer::collectFragments(LayerFragments&amp; fragments, const RenderLayer* rootLayer, const LayoutRect&amp; dirtyRect, PaginationInclusionMode inclusionMode,
4493     ClipRectsType clipRectsType, OverlayScrollbarSizeRelevancy inOverlayScrollbarSizeRelevancy, ShouldRespectOverflowClip respectOverflowClip, const LayoutSize&amp; offsetFromRoot,
4494     const LayoutRect* layerBoundingBox, ShouldApplyRootOffsetToFragments applyRootOffsetToFragments)
4495 {
4496     RenderLayer* paginationLayer = enclosingPaginationLayerInSubtree(rootLayer, inclusionMode);
4497     if (!paginationLayer || hasTransform()) {
4498         // For unpaginated layers, there is only one fragment.
4499         LayerFragment fragment;
4500         ClipRectsContext clipRectsContext(rootLayer, clipRectsType, inOverlayScrollbarSizeRelevancy, respectOverflowClip);
4501         calculateRects(clipRectsContext, dirtyRect, fragment.layerBounds, fragment.backgroundRect, fragment.foregroundRect, offsetFromRoot);
4502         fragments.append(fragment);
4503         return;
4504     }
4505 
4506     // Compute our offset within the enclosing pagination layer.
4507     LayoutSize offsetWithinPaginatedLayer = offsetFromAncestor(paginationLayer);
4508 
4509     // Calculate clip rects relative to the enclosingPaginationLayer. The purpose of this call is to determine our bounds clipped to intermediate
4510     // layers between us and the pagination context. It&#39;s important to minimize the number of fragments we need to create and this helps with that.
4511     ClipRectsContext paginationClipRectsContext(paginationLayer, clipRectsType, inOverlayScrollbarSizeRelevancy, respectOverflowClip);
4512     LayoutRect layerBoundsInFragmentedFlow;
4513     ClipRect backgroundRectInFragmentedFlow;
4514     ClipRect foregroundRectInFragmentedFlow;
4515     calculateRects(paginationClipRectsContext, LayoutRect::infiniteRect(), layerBoundsInFragmentedFlow, backgroundRectInFragmentedFlow, foregroundRectInFragmentedFlow,
4516         offsetWithinPaginatedLayer);
4517 
4518     // Take our bounding box within the flow thread and clip it.
4519     LayoutRect layerBoundingBoxInFragmentedFlow = layerBoundingBox ? *layerBoundingBox : boundingBox(paginationLayer, offsetWithinPaginatedLayer);
4520     layerBoundingBoxInFragmentedFlow.intersect(backgroundRectInFragmentedFlow.rect());
4521 
4522     auto&amp; enclosingFragmentedFlow = downcast&lt;RenderFragmentedFlow&gt;(paginationLayer-&gt;renderer());
4523     RenderLayer* parentPaginationLayer = paginationLayer-&gt;parent()-&gt;enclosingPaginationLayerInSubtree(rootLayer, inclusionMode);
4524     LayerFragments ancestorFragments;
4525     if (parentPaginationLayer) {
4526         // Compute a bounding box accounting for fragments.
4527         LayoutRect layerFragmentBoundingBoxInParentPaginationLayer = enclosingFragmentedFlow.fragmentsBoundingBox(layerBoundingBoxInFragmentedFlow);
4528 
4529         // Convert to be in the ancestor pagination context&#39;s coordinate space.
4530         LayoutSize offsetWithinParentPaginatedLayer = paginationLayer-&gt;offsetFromAncestor(parentPaginationLayer);
4531         layerFragmentBoundingBoxInParentPaginationLayer.move(offsetWithinParentPaginatedLayer);
4532 
4533         // Now collect ancestor fragments.
4534         parentPaginationLayer-&gt;collectFragments(ancestorFragments, rootLayer, dirtyRect, inclusionMode, clipRectsType, inOverlayScrollbarSizeRelevancy, respectOverflowClip,
4535             offsetFromAncestor(rootLayer), &amp;layerFragmentBoundingBoxInParentPaginationLayer, ApplyRootOffsetToFragments);
4536 
4537         if (ancestorFragments.isEmpty())
4538             return;
4539 
4540         for (auto&amp; ancestorFragment : ancestorFragments) {
4541             // Shift the dirty rect into flow thread coordinates.
4542             LayoutRect dirtyRectInFragmentedFlow(dirtyRect);
4543             dirtyRectInFragmentedFlow.move(-offsetWithinParentPaginatedLayer - ancestorFragment.paginationOffset);
4544 
4545             size_t oldSize = fragments.size();
4546 
4547             // Tell the flow thread to collect the fragments. We pass enough information to create a minimal number of fragments based off the pages/columns
4548             // that intersect the actual dirtyRect as well as the pages/columns that intersect our layer&#39;s bounding box.
4549             enclosingFragmentedFlow.collectLayerFragments(fragments, layerBoundingBoxInFragmentedFlow, dirtyRectInFragmentedFlow);
4550 
4551             size_t newSize = fragments.size();
4552 
4553             if (oldSize == newSize)
4554                 continue;
4555 
4556             for (size_t i = oldSize; i &lt; newSize; ++i) {
4557                 LayerFragment&amp; fragment = fragments.at(i);
4558 
4559                 // Set our four rects with all clipping applied that was internal to the flow thread.
4560                 fragment.setRects(layerBoundsInFragmentedFlow, backgroundRectInFragmentedFlow, foregroundRectInFragmentedFlow, &amp;layerBoundingBoxInFragmentedFlow);
4561 
4562                 // Shift to the root-relative physical position used when painting the flow thread in this fragment.
4563                 fragment.moveBy(toLayoutPoint(ancestorFragment.paginationOffset + fragment.paginationOffset + offsetWithinParentPaginatedLayer));
4564 
4565                 // Intersect the fragment with our ancestor&#39;s background clip so that e.g., columns in an overflow:hidden block are
4566                 // properly clipped by the overflow.
4567                 fragment.intersect(ancestorFragment.paginationClip);
4568 
4569                 // Now intersect with our pagination clip. This will typically mean we&#39;re just intersecting the dirty rect with the column
4570                 // clip, so the column clip ends up being all we apply.
4571                 fragment.intersect(fragment.paginationClip);
4572 
4573                 if (applyRootOffsetToFragments == ApplyRootOffsetToFragments)
4574                     fragment.paginationOffset = fragment.paginationOffset + offsetWithinParentPaginatedLayer;
4575             }
4576         }
4577 
4578         return;
4579     }
4580 
4581     // Shift the dirty rect into flow thread coordinates.
4582     LayoutSize offsetOfPaginationLayerFromRoot = enclosingPaginationLayer(inclusionMode)-&gt;offsetFromAncestor(rootLayer);
4583     LayoutRect dirtyRectInFragmentedFlow(dirtyRect);
4584     dirtyRectInFragmentedFlow.move(-offsetOfPaginationLayerFromRoot);
4585 
4586     // Tell the flow thread to collect the fragments. We pass enough information to create a minimal number of fragments based off the pages/columns
4587     // that intersect the actual dirtyRect as well as the pages/columns that intersect our layer&#39;s bounding box.
4588     enclosingFragmentedFlow.collectLayerFragments(fragments, layerBoundingBoxInFragmentedFlow, dirtyRectInFragmentedFlow);
4589 
4590     if (fragments.isEmpty())
4591         return;
4592 
4593     // Get the parent clip rects of the pagination layer, since we need to intersect with that when painting column contents.
4594     ClipRect ancestorClipRect = dirtyRect;
4595     if (paginationLayer-&gt;parent()) {
4596         ClipRectsContext clipRectsContext(rootLayer, clipRectsType, inOverlayScrollbarSizeRelevancy, respectOverflowClip);
4597         ancestorClipRect = paginationLayer-&gt;backgroundClipRect(clipRectsContext);
4598         ancestorClipRect.intersect(dirtyRect);
4599     }
4600 
4601     for (auto&amp; fragment : fragments) {
4602         // Set our four rects with all clipping applied that was internal to the flow thread.
4603         fragment.setRects(layerBoundsInFragmentedFlow, backgroundRectInFragmentedFlow, foregroundRectInFragmentedFlow, &amp;layerBoundingBoxInFragmentedFlow);
4604 
4605         // Shift to the root-relative physical position used when painting the flow thread in this fragment.
4606         fragment.moveBy(toLayoutPoint(fragment.paginationOffset + offsetOfPaginationLayerFromRoot));
4607 
4608         // Intersect the fragment with our ancestor&#39;s background clip so that e.g., columns in an overflow:hidden block are
4609         // properly clipped by the overflow.
4610         fragment.intersect(ancestorClipRect);
4611 
4612         // Now intersect with our pagination clip. This will typically mean we&#39;re just intersecting the dirty rect with the column
4613         // clip, so the column clip ends up being all we apply.
4614         fragment.intersect(fragment.paginationClip);
4615 
4616         if (applyRootOffsetToFragments == ApplyRootOffsetToFragments)
4617             fragment.paginationOffset = fragment.paginationOffset + offsetOfPaginationLayerFromRoot;
4618     }
4619 }
4620 
4621 void RenderLayer::updatePaintingInfoForFragments(LayerFragments&amp; fragments, const LayerPaintingInfo&amp; localPaintingInfo, OptionSet&lt;PaintLayerFlag&gt; localPaintFlags,
4622     bool shouldPaintContent, const LayoutSize&amp; offsetFromRoot)
4623 {
4624     for (auto&amp; fragment : fragments) {
4625         fragment.shouldPaintContent = shouldPaintContent;
4626         if (this != localPaintingInfo.rootLayer || !(localPaintFlags &amp; PaintLayerPaintingOverflowContents)) {
4627             LayoutSize newOffsetFromRoot = offsetFromRoot + fragment.paginationOffset;
4628             fragment.shouldPaintContent &amp;= intersectsDamageRect(fragment.layerBounds, fragment.backgroundRect.rect(), localPaintingInfo.rootLayer, newOffsetFromRoot, fragment.hasBoundingBox ? &amp;fragment.boundingBox : 0);
4629         }
4630     }
4631 }
4632 
4633 void RenderLayer::paintTransformedLayerIntoFragments(GraphicsContext&amp; context, const LayerPaintingInfo&amp; paintingInfo, OptionSet&lt;PaintLayerFlag&gt; paintFlags)
4634 {
4635     LayerFragments enclosingPaginationFragments;
4636     LayoutSize offsetOfPaginationLayerFromRoot;
4637     RenderLayer* paginatedLayer = enclosingPaginationLayer(ExcludeCompositedPaginatedLayers);
4638     LayoutRect transformedExtent = transparencyClipBox(*this, paginatedLayer, PaintingTransparencyClipBox, RootOfTransparencyClipBox, paintingInfo.paintBehavior);
4639     paginatedLayer-&gt;collectFragments(enclosingPaginationFragments, paintingInfo.rootLayer, paintingInfo.paintDirtyRect, ExcludeCompositedPaginatedLayers,
4640         (paintFlags &amp; PaintLayerTemporaryClipRects) ? TemporaryClipRects : PaintingClipRects, IgnoreOverlayScrollbarSize,
4641         (paintFlags &amp; PaintLayerPaintingOverflowContents) ? IgnoreOverflowClip : RespectOverflowClip, offsetOfPaginationLayerFromRoot, &amp;transformedExtent);
4642 
4643     for (const auto&amp; fragment : enclosingPaginationFragments) {
4644         // Apply the page/column clip for this fragment, as well as any clips established by layers in between us and
4645         // the enclosing pagination layer.
4646         LayoutRect clipRect = fragment.backgroundRect.rect();
4647 
4648         // Now compute the clips within a given fragment
4649         if (parent() != paginatedLayer) {
4650             offsetOfPaginationLayerFromRoot = toLayoutSize(paginatedLayer-&gt;convertToLayerCoords(paintingInfo.rootLayer, toLayoutPoint(offsetOfPaginationLayerFromRoot)));
4651 
4652             ClipRectsContext clipRectsContext(paginatedLayer, (paintFlags &amp; PaintLayerTemporaryClipRects) ? TemporaryClipRects : PaintingClipRects,
4653                 IgnoreOverlayScrollbarSize, (paintFlags &amp; PaintLayerPaintingOverflowContents) ? IgnoreOverflowClip : RespectOverflowClip);
4654             LayoutRect parentClipRect = backgroundClipRect(clipRectsContext).rect();
4655             parentClipRect.move(fragment.paginationOffset + offsetOfPaginationLayerFromRoot);
4656             clipRect.intersect(parentClipRect);
4657         }
4658 
4659         parent()-&gt;clipToRect(context, paintingInfo, clipRect);
4660         paintLayerByApplyingTransform(context, paintingInfo, paintFlags, fragment.paginationOffset);
4661         parent()-&gt;restoreClip(context, paintingInfo, clipRect);
4662     }
4663 }
4664 
4665 void RenderLayer::paintBackgroundForFragments(const LayerFragments&amp; layerFragments, GraphicsContext&amp; context, GraphicsContext&amp; contextForTransparencyLayer,
4666     const LayoutRect&amp; transparencyPaintDirtyRect, bool haveTransparency, const LayerPaintingInfo&amp; localPaintingInfo, OptionSet&lt;PaintBehavior&gt; paintBehavior,
4667     RenderObject* subtreePaintRootForRenderer)
4668 {
4669     for (const auto&amp; fragment : layerFragments) {
4670         if (!fragment.shouldPaintContent)
4671             continue;
4672 
4673         // Begin transparency layers lazily now that we know we have to paint something.
4674         if (haveTransparency)
4675             beginTransparencyLayers(contextForTransparencyLayer, localPaintingInfo, transparencyPaintDirtyRect);
4676 
4677         if (localPaintingInfo.clipToDirtyRect) {
4678             // Paint our background first, before painting any child layers.
4679             // Establish the clip used to paint our background.
4680             clipToRect(context, localPaintingInfo, fragment.backgroundRect, DoNotIncludeSelfForBorderRadius); // Background painting will handle clipping to self.
4681         }
4682 
4683         // Paint the background.
4684         // FIXME: Eventually we will collect the region from the fragment itself instead of just from the paint info.
4685         PaintInfo paintInfo(context, fragment.backgroundRect.rect(), PaintPhase::BlockBackground, paintBehavior, subtreePaintRootForRenderer, nullptr, nullptr, &amp;localPaintingInfo.rootLayer-&gt;renderer(), this);
4686         renderer().paint(paintInfo, toLayoutPoint(fragment.layerBounds.location() - renderBoxLocation() + localPaintingInfo.subpixelOffset));
4687 
4688         if (localPaintingInfo.clipToDirtyRect)
4689             restoreClip(context, localPaintingInfo, fragment.backgroundRect);
4690     }
4691 }
4692 
4693 void RenderLayer::paintForegroundForFragments(const LayerFragments&amp; layerFragments, GraphicsContext&amp; context, GraphicsContext&amp; contextForTransparencyLayer,
4694     const LayoutRect&amp; transparencyPaintDirtyRect, bool haveTransparency, const LayerPaintingInfo&amp; localPaintingInfo, OptionSet&lt;PaintBehavior&gt; paintBehavior,
4695     RenderObject* subtreePaintRootForRenderer)
4696 {
4697     // Begin transparency if we have something to paint.
4698     if (haveTransparency) {
4699         for (const auto&amp; fragment : layerFragments) {
4700             if (fragment.shouldPaintContent &amp;&amp; !fragment.foregroundRect.isEmpty()) {
4701                 beginTransparencyLayers(contextForTransparencyLayer, localPaintingInfo, transparencyPaintDirtyRect);
4702                 break;
4703             }
4704         }
4705     }
4706 
4707     OptionSet&lt;PaintBehavior&gt; localPaintBehavior;
4708     if (localPaintingInfo.paintBehavior &amp; PaintBehavior::ForceBlackText)
4709         localPaintBehavior = PaintBehavior::ForceBlackText;
4710     else if (localPaintingInfo.paintBehavior &amp; PaintBehavior::ForceWhiteText)
4711         localPaintBehavior = PaintBehavior::ForceWhiteText;
4712     else
4713         localPaintBehavior = paintBehavior;
4714 
4715     if (localPaintingInfo.paintBehavior &amp; PaintBehavior::ExcludeSelection)
4716         localPaintBehavior.add(PaintBehavior::ExcludeSelection);
4717 
4718     if (localPaintingInfo.paintBehavior &amp; PaintBehavior::Snapshotting)
4719         localPaintBehavior.add(PaintBehavior::Snapshotting);
4720 
4721     if (localPaintingInfo.paintBehavior &amp; PaintBehavior::TileFirstPaint)
4722         localPaintBehavior.add(PaintBehavior::TileFirstPaint);
4723 
4724     // Optimize clipping for the single fragment case.
4725     bool shouldClip = localPaintingInfo.clipToDirtyRect &amp;&amp; layerFragments.size() == 1 &amp;&amp; layerFragments[0].shouldPaintContent &amp;&amp; !layerFragments[0].foregroundRect.isEmpty();
4726     ClipRect clippedRect;
4727     if (shouldClip) {
4728         clippedRect = layerFragments[0].foregroundRect;
4729         clipToRect(context, localPaintingInfo, clippedRect);
4730     }
4731 
4732     // We have to loop through every fragment multiple times, since we have to repaint in each specific phase in order for
4733     // interleaving of the fragments to work properly.
4734     bool selectionOnly = localPaintingInfo.paintBehavior.containsAny({ PaintBehavior::SelectionAndBackgroundsOnly, PaintBehavior::SelectionOnly });
4735     paintForegroundForFragmentsWithPhase(selectionOnly ? PaintPhase::Selection : PaintPhase::ChildBlockBackgrounds, layerFragments,
4736         context, localPaintingInfo, localPaintBehavior, subtreePaintRootForRenderer);
4737 
4738     if (!selectionOnly) {
4739         paintForegroundForFragmentsWithPhase(PaintPhase::Float, layerFragments, context, localPaintingInfo, localPaintBehavior, subtreePaintRootForRenderer);
4740         paintForegroundForFragmentsWithPhase(PaintPhase::Foreground, layerFragments, context, localPaintingInfo, localPaintBehavior, subtreePaintRootForRenderer);
4741         paintForegroundForFragmentsWithPhase(PaintPhase::ChildOutlines, layerFragments, context, localPaintingInfo, localPaintBehavior, subtreePaintRootForRenderer);
4742     }
4743 
4744     if (shouldClip)
4745         restoreClip(context, localPaintingInfo, clippedRect);
4746 }
4747 
4748 void RenderLayer::paintForegroundForFragmentsWithPhase(PaintPhase phase, const LayerFragments&amp; layerFragments, GraphicsContext&amp; context,
4749     const LayerPaintingInfo&amp; localPaintingInfo, OptionSet&lt;PaintBehavior&gt; paintBehavior, RenderObject* subtreePaintRootForRenderer)
4750 {
4751     bool shouldClip = localPaintingInfo.clipToDirtyRect &amp;&amp; layerFragments.size() &gt; 1;
4752 
4753     for (const auto&amp; fragment : layerFragments) {
4754         if (!fragment.shouldPaintContent || fragment.foregroundRect.isEmpty())
4755             continue;
4756 
4757         if (shouldClip)
4758             clipToRect(context, localPaintingInfo, fragment.foregroundRect);
4759 
4760         PaintInfo paintInfo(context, fragment.foregroundRect.rect(), phase, paintBehavior, subtreePaintRootForRenderer, nullptr, nullptr, &amp;localPaintingInfo.rootLayer-&gt;renderer(), this, localPaintingInfo.requireSecurityOriginAccessForWidgets);
4761         if (phase == PaintPhase::Foreground)
4762             paintInfo.overlapTestRequests = localPaintingInfo.overlapTestRequests;
4763         renderer().paint(paintInfo, toLayoutPoint(fragment.layerBounds.location() - renderBoxLocation() + localPaintingInfo.subpixelOffset));
4764 
4765         if (shouldClip)
4766             restoreClip(context, localPaintingInfo, fragment.foregroundRect);
4767     }
4768 }
4769 
4770 void RenderLayer::paintOutlineForFragments(const LayerFragments&amp; layerFragments, GraphicsContext&amp; context, const LayerPaintingInfo&amp; localPaintingInfo,
4771     OptionSet&lt;PaintBehavior&gt; paintBehavior, RenderObject* subtreePaintRootForRenderer)
4772 {
4773     for (const auto&amp; fragment : layerFragments) {
4774         if (fragment.backgroundRect.isEmpty())
4775             continue;
4776 
4777         // Paint our own outline
4778         PaintInfo paintInfo(context, fragment.backgroundRect.rect(), PaintPhase::SelfOutline, paintBehavior, subtreePaintRootForRenderer, nullptr, nullptr, &amp;localPaintingInfo.rootLayer-&gt;renderer(), this);
4779         clipToRect(context, localPaintingInfo, fragment.backgroundRect, DoNotIncludeSelfForBorderRadius);
4780         renderer().paint(paintInfo, toLayoutPoint(fragment.layerBounds.location() - renderBoxLocation() + localPaintingInfo.subpixelOffset));
4781         restoreClip(context, localPaintingInfo, fragment.backgroundRect);
4782     }
4783 }
4784 
4785 void RenderLayer::paintMaskForFragments(const LayerFragments&amp; layerFragments, GraphicsContext&amp; context, const LayerPaintingInfo&amp; localPaintingInfo,
4786     OptionSet&lt;PaintBehavior&gt; paintBehavior, RenderObject* subtreePaintRootForRenderer)
4787 {
4788     for (const auto&amp; fragment : layerFragments) {
4789         if (!fragment.shouldPaintContent)
4790             continue;
4791 
4792         if (localPaintingInfo.clipToDirtyRect)
4793             clipToRect(context, localPaintingInfo, fragment.backgroundRect, DoNotIncludeSelfForBorderRadius); // Mask painting will handle clipping to self.
4794 
4795         // Paint the mask.
4796         // FIXME: Eventually we will collect the region from the fragment itself instead of just from the paint info.
4797         PaintInfo paintInfo(context, fragment.backgroundRect.rect(), PaintPhase::Mask, paintBehavior, subtreePaintRootForRenderer, nullptr, nullptr, &amp;localPaintingInfo.rootLayer-&gt;renderer(), this);
4798         renderer().paint(paintInfo, toLayoutPoint(fragment.layerBounds.location() - renderBoxLocation() + localPaintingInfo.subpixelOffset));
4799 
4800         if (localPaintingInfo.clipToDirtyRect)
4801             restoreClip(context, localPaintingInfo, fragment.backgroundRect);
4802     }
4803 }
4804 
4805 void RenderLayer::paintChildClippingMaskForFragments(const LayerFragments&amp; layerFragments, GraphicsContext&amp; context, const LayerPaintingInfo&amp; localPaintingInfo, OptionSet&lt;PaintBehavior&gt; paintBehavior, RenderObject* subtreePaintRootForRenderer)
4806 {
4807     for (const auto&amp; fragment : layerFragments) {
4808         if (!fragment.shouldPaintContent)
4809             continue;
4810 
4811         if (localPaintingInfo.clipToDirtyRect)
4812             clipToRect(context, localPaintingInfo, fragment.foregroundRect, IncludeSelfForBorderRadius); // Child clipping mask painting will handle clipping to self.
4813 
4814         // Paint the clipped mask.
4815         PaintInfo paintInfo(context, fragment.backgroundRect.rect(), PaintPhase::ClippingMask, paintBehavior, subtreePaintRootForRenderer, nullptr, nullptr, &amp;localPaintingInfo.rootLayer-&gt;renderer(), this);
4816         renderer().paint(paintInfo, toLayoutPoint(fragment.layerBounds.location() - renderBoxLocation() + localPaintingInfo.subpixelOffset));
4817 
4818         if (localPaintingInfo.clipToDirtyRect)
4819             restoreClip(context, localPaintingInfo, fragment.foregroundRect);
4820     }
4821 }
4822 
4823 void RenderLayer::paintOverflowControlsForFragments(const LayerFragments&amp; layerFragments, GraphicsContext&amp; context, const LayerPaintingInfo&amp; localPaintingInfo)
4824 {
4825     for (const auto&amp; fragment : layerFragments) {
4826         if (fragment.backgroundRect.isEmpty())
4827             continue;
4828         clipToRect(context, localPaintingInfo, fragment.backgroundRect);
4829         paintOverflowControls(context, roundedIntPoint(toLayoutPoint(fragment.layerBounds.location() - renderBoxLocation() + localPaintingInfo.subpixelOffset)),
4830             snappedIntRect(fragment.backgroundRect.rect()), true);
4831         restoreClip(context, localPaintingInfo, fragment.backgroundRect);
4832     }
4833 }
4834 
4835 bool RenderLayer::hitTest(const HitTestRequest&amp; request, HitTestResult&amp; result)
4836 {
4837     return hitTest(request, result.hitTestLocation(), result);
4838 }
4839 
4840 bool RenderLayer::hitTest(const HitTestRequest&amp; request, const HitTestLocation&amp; hitTestLocation, HitTestResult&amp; result)
4841 {
4842     ASSERT(isSelfPaintingLayer() || hasSelfPaintingLayerDescendant());
4843     ASSERT(!renderer().view().needsLayout());
4844 
4845     ASSERT(!isRenderFragmentedFlow());
4846     LayoutRect hitTestArea = renderer().view().documentRect();
4847     if (!request.ignoreClipping()) {
4848         const auto&amp; settings = renderer().settings();
4849         if (settings.visualViewportEnabled() &amp;&amp; settings.clientCoordinatesRelativeToLayoutViewport()) {
4850             auto&amp; frameView = renderer().view().frameView();
4851             LayoutRect absoluteLayoutViewportRect = frameView.layoutViewportRect();
4852             auto scaleFactor = frameView.frame().frameScaleFactor();
4853             if (scaleFactor &gt; 1)
4854                 absoluteLayoutViewportRect.scale(scaleFactor);
4855             hitTestArea.intersect(absoluteLayoutViewportRect);
4856         } else
4857             hitTestArea.intersect(renderer().view().frameView().visibleContentRect(LegacyIOSDocumentVisibleRect));
4858     }
4859 
4860     RenderLayer* insideLayer = hitTestLayer(this, nullptr, request, result, hitTestArea, hitTestLocation, false);
4861     if (!insideLayer) {
4862         // We didn&#39;t hit any layer. If we are the root layer and the mouse is -- or just was -- down,
4863         // return ourselves. We do this so mouse events continue getting delivered after a drag has
4864         // exited the WebView, and so hit testing over a scrollbar hits the content document.
4865         if (!request.isChildFrameHitTest() &amp;&amp; (request.active() || request.release()) &amp;&amp; isRenderViewLayer()) {
4866             renderer().updateHitTestResult(result, downcast&lt;RenderView&gt;(renderer()).flipForWritingMode(hitTestLocation.point()));
4867             insideLayer = this;
4868         }
4869     }
4870 
4871     // Now determine if the result is inside an anchor - if the urlElement isn&#39;t already set.
4872     Node* node = result.innerNode();
4873     if (node &amp;&amp; !result.URLElement())
4874         result.setURLElement(node-&gt;enclosingLinkEventParentOrSelf());
4875 
4876     // Now return whether we were inside this layer (this will always be true for the root
4877     // layer).
4878     return insideLayer;
4879 }
4880 
4881 Element* RenderLayer::enclosingElement() const
4882 {
4883     for (RenderElement* r = &amp;renderer(); r; r = r-&gt;parent()) {
4884         if (Element* e = r-&gt;element())
4885             return e;
4886     }
4887     return nullptr;
4888 }
4889 
4890 RenderLayer* RenderLayer::enclosingFragmentedFlowAncestor() const
4891 {
4892     RenderLayer* curr = parent();
4893     for (; curr &amp;&amp; !curr-&gt;isRenderFragmentedFlow(); curr = curr-&gt;parent()) {
4894         if (curr-&gt;isStackingContext() &amp;&amp; curr-&gt;isComposited()) {
4895             // We only adjust the position of the first level of layers.
4896             return nullptr;
4897         }
4898     }
4899     return curr;
4900 }
4901 
4902 // Compute the z-offset of the point in the transformState.
4903 // This is effectively projecting a ray normal to the plane of ancestor, finding where that
4904 // ray intersects target, and computing the z delta between those two points.
4905 static double computeZOffset(const HitTestingTransformState&amp; transformState)
4906 {
4907     // We got an affine transform, so no z-offset
4908     if (transformState.m_accumulatedTransform.isAffine())
4909         return 0;
4910 
4911     // Flatten the point into the target plane
4912     FloatPoint targetPoint = transformState.mappedPoint();
4913 
4914     // Now map the point back through the transform, which computes Z.
4915     FloatPoint3D backmappedPoint = transformState.m_accumulatedTransform.mapPoint(FloatPoint3D(targetPoint));
4916     return backmappedPoint.z();
4917 }
4918 
4919 Ref&lt;HitTestingTransformState&gt; RenderLayer::createLocalTransformState(RenderLayer* rootLayer, RenderLayer* containerLayer,
4920                                         const LayoutRect&amp; hitTestRect, const HitTestLocation&amp; hitTestLocation,
4921                                         const HitTestingTransformState* containerTransformState,
4922                                         const LayoutSize&amp; translationOffset) const
4923 {
4924     RefPtr&lt;HitTestingTransformState&gt; transformState;
4925     LayoutSize offset;
4926     if (containerTransformState) {
4927         // If we&#39;re already computing transform state, then it&#39;s relative to the container (which we know is non-null).
4928         transformState = HitTestingTransformState::create(*containerTransformState);
4929         offset = offsetFromAncestor(containerLayer);
4930     } else {
4931         // If this is the first time we need to make transform state, then base it off of hitTestLocation,
4932         // which is relative to rootLayer.
4933         transformState = HitTestingTransformState::create(hitTestLocation.transformedPoint(), hitTestLocation.transformedRect(), FloatQuad(hitTestRect));
4934         offset = offsetFromAncestor(rootLayer);
4935     }
4936     offset += translationOffset;
4937 
4938     RenderObject* containerRenderer = containerLayer ? &amp;containerLayer-&gt;renderer() : nullptr;
4939     if (renderer().shouldUseTransformFromContainer(containerRenderer)) {
4940         TransformationMatrix containerTransform;
4941         renderer().getTransformFromContainer(containerRenderer, offset, containerTransform);
4942         transformState-&gt;applyTransform(containerTransform, HitTestingTransformState::AccumulateTransform);
4943     } else {
4944         transformState-&gt;translate(offset.width(), offset.height(), HitTestingTransformState::AccumulateTransform);
4945     }
4946 
4947     return transformState.releaseNonNull();
4948 }
4949 
4950 
4951 static bool isHitCandidate(const RenderLayer* hitLayer, bool canDepthSort, double* zOffset, const HitTestingTransformState* transformState)
4952 {
4953     if (!hitLayer)
4954         return false;
4955 
4956     // The hit layer is depth-sorting with other layers, so just say that it was hit.
4957     if (canDepthSort)
4958         return true;
4959 
4960     // We need to look at z-depth to decide if this layer was hit.
4961     if (zOffset) {
4962         ASSERT(transformState);
4963         // This is actually computing our z, but that&#39;s OK because the hitLayer is coplanar with us.
4964         double childZOffset = computeZOffset(*transformState);
4965         if (childZOffset &gt; *zOffset) {
4966             *zOffset = childZOffset;
4967             return true;
4968         }
4969         return false;
4970     }
4971 
4972     return true;
4973 }
4974 
4975 // hitTestLocation and hitTestRect are relative to rootLayer.
4976 // A &#39;flattening&#39; layer is one preserves3D() == false.
4977 // transformState.m_accumulatedTransform holds the transform from the containing flattening layer.
4978 // transformState.m_lastPlanarPoint is the hitTestLocation in the plane of the containing flattening layer.
4979 // transformState.m_lastPlanarQuad is the hitTestRect as a quad in the plane of the containing flattening layer.
4980 //
4981 // If zOffset is non-null (which indicates that the caller wants z offset information),
4982 //  *zOffset on return is the z offset of the hit point relative to the containing flattening layer.
4983 RenderLayer* RenderLayer::hitTestLayer(RenderLayer* rootLayer, RenderLayer* containerLayer, const HitTestRequest&amp; request, HitTestResult&amp; result,
4984                                        const LayoutRect&amp; hitTestRect, const HitTestLocation&amp; hitTestLocation, bool appliedTransform,
4985                                        const HitTestingTransformState* transformState, double* zOffset)
4986 {
4987     updateLayerListsIfNeeded();
4988 
4989     if (!isSelfPaintingLayer() &amp;&amp; !hasSelfPaintingLayerDescendant())
4990         return nullptr;
4991 
4992     // The natural thing would be to keep HitTestingTransformState on the stack, but it&#39;s big, so we heap-allocate.
4993 
4994     // Apply a transform if we have one.
4995     if (transform() &amp;&amp; !appliedTransform) {
4996         if (enclosingPaginationLayer(IncludeCompositedPaginatedLayers))
4997             return hitTestTransformedLayerInFragments(rootLayer, containerLayer, request, result, hitTestRect, hitTestLocation, transformState, zOffset);
4998 
4999         // Make sure the parent&#39;s clip rects have been calculated.
5000         if (parent()) {
5001             ClipRectsContext clipRectsContext(rootLayer, RootRelativeClipRects, IncludeOverlayScrollbarSize);
5002             ClipRect clipRect = backgroundClipRect(clipRectsContext);
5003             // Test the enclosing clip now.
5004             if (!clipRect.intersects(hitTestLocation))
5005                 return nullptr;
5006         }
5007 
5008         return hitTestLayerByApplyingTransform(rootLayer, containerLayer, request, result, hitTestRect, hitTestLocation, transformState, zOffset);
5009     }
5010 
5011     // Ensure our lists and 3d status are up-to-date.
5012     update3DTransformedDescendantStatus();
5013 
5014     RefPtr&lt;HitTestingTransformState&gt; localTransformState;
5015     if (appliedTransform) {
5016         // We computed the correct state in the caller (above code), so just reference it.
5017         ASSERT(transformState);
5018         localTransformState = const_cast&lt;HitTestingTransformState*&gt;(transformState);
5019     } else if (transformState || has3DTransformedDescendant() || preserves3D()) {
5020         // We need transform state for the first time, or to offset the container state, so create it here.
5021         localTransformState = createLocalTransformState(rootLayer, containerLayer, hitTestRect, hitTestLocation, transformState);
5022     }
5023 
5024     // Check for hit test on backface if backface-visibility is &#39;hidden&#39;
5025     if (localTransformState &amp;&amp; renderer().style().backfaceVisibility() == BackfaceVisibility::Hidden) {
5026         Optional&lt;TransformationMatrix&gt; invertedMatrix = localTransformState-&gt;m_accumulatedTransform.inverse();
5027         // If the z-vector of the matrix is negative, the back is facing towards the viewer.
5028         if (invertedMatrix &amp;&amp; invertedMatrix.value().m33() &lt; 0)
5029             return nullptr;
5030     }
5031 
5032     RefPtr&lt;HitTestingTransformState&gt; unflattenedTransformState = localTransformState;
5033     if (localTransformState &amp;&amp; !preserves3D()) {
5034         // Keep a copy of the pre-flattening state, for computing z-offsets for the container
5035         unflattenedTransformState = HitTestingTransformState::create(*localTransformState);
5036         // This layer is flattening, so flatten the state passed to descendants.
5037         localTransformState-&gt;flatten();
5038     }
5039 
5040     // The following are used for keeping track of the z-depth of the hit point of 3d-transformed
5041     // descendants.
5042     double localZOffset = -std::numeric_limits&lt;double&gt;::infinity();
5043     double* zOffsetForDescendantsPtr = nullptr;
5044     double* zOffsetForContentsPtr = nullptr;
5045 
5046     bool depthSortDescendants = false;
5047     if (preserves3D()) {
5048         depthSortDescendants = true;
5049         // Our layers can depth-test with our container, so share the z depth pointer with the container, if it passed one down.
5050         zOffsetForDescendantsPtr = zOffset ? zOffset : &amp;localZOffset;
5051         zOffsetForContentsPtr = zOffset ? zOffset : &amp;localZOffset;
5052     } else if (zOffset) {
5053         zOffsetForDescendantsPtr = nullptr;
5054         // Container needs us to give back a z offset for the hit layer.
5055         zOffsetForContentsPtr = zOffset;
5056     }
5057 
5058     // This variable tracks which layer the mouse ends up being inside.
5059     RenderLayer* candidateLayer = nullptr;
5060 #if !ASSERT_DISABLED
5061     LayerListMutationDetector mutationChecker(*this);
5062 #endif
5063 
5064     // Begin by walking our list of positive layers from highest z-index down to the lowest z-index.
5065     auto* hitLayer = hitTestList(positiveZOrderLayers(), rootLayer, request, result, hitTestRect, hitTestLocation,
5066                                         localTransformState.get(), zOffsetForDescendantsPtr, zOffset, unflattenedTransformState.get(), depthSortDescendants);
5067     if (hitLayer) {
5068         if (!depthSortDescendants)
5069             return hitLayer;
5070         candidateLayer = hitLayer;
5071     }
5072 
5073     // Now check our overflow objects.
5074     hitLayer = hitTestList(normalFlowLayers(), rootLayer, request, result, hitTestRect, hitTestLocation,
5075                            localTransformState.get(), zOffsetForDescendantsPtr, zOffset, unflattenedTransformState.get(), depthSortDescendants);
5076     if (hitLayer) {
5077         if (!depthSortDescendants)
5078             return hitLayer;
5079         candidateLayer = hitLayer;
5080     }
5081 
5082     // Collect the fragments. This will compute the clip rectangles for each layer fragment.
5083     LayerFragments layerFragments;
5084     collectFragments(layerFragments, rootLayer, hitTestRect, IncludeCompositedPaginatedLayers, RootRelativeClipRects, IncludeOverlayScrollbarSize, RespectOverflowClip,
5085         offsetFromAncestor(rootLayer));
5086 
5087     if (canResize() &amp;&amp; hitTestResizerInFragments(layerFragments, hitTestLocation)) {
5088         renderer().updateHitTestResult(result, hitTestLocation.point());
5089         return this;
5090     }
5091 
5092     // Next we want to see if the mouse pos is inside the child RenderObjects of the layer. Check
5093     // every fragment in reverse order.
5094     if (isSelfPaintingLayer()) {
5095         // Hit test with a temporary HitTestResult, because we only want to commit to &#39;result&#39; if we know we&#39;re frontmost.
5096         HitTestResult tempResult(result.hitTestLocation());
5097         bool insideFragmentForegroundRect = false;
5098         if (hitTestContentsForFragments(layerFragments, request, tempResult, hitTestLocation, HitTestDescendants, insideFragmentForegroundRect)
5099             &amp;&amp; isHitCandidate(this, false, zOffsetForContentsPtr, unflattenedTransformState.get())) {
5100             if (request.resultIsElementList())
5101                 result.append(tempResult, request);
5102             else
5103                 result = tempResult;
5104             if (!depthSortDescendants)
5105                 return this;
5106             // Foreground can depth-sort with descendant layers, so keep this as a candidate.
5107             candidateLayer = this;
5108         } else if (insideFragmentForegroundRect &amp;&amp; request.resultIsElementList())
5109             result.append(tempResult, request);
5110     }
5111 
5112     // Now check our negative z-index children.
5113     hitLayer = hitTestList(negativeZOrderLayers(), rootLayer, request, result, hitTestRect, hitTestLocation,
5114         localTransformState.get(), zOffsetForDescendantsPtr, zOffset, unflattenedTransformState.get(), depthSortDescendants);
5115     if (hitLayer) {
5116         if (!depthSortDescendants)
5117             return hitLayer;
5118         candidateLayer = hitLayer;
5119     }
5120 
5121     // If we found a layer, return. Child layers, and foreground always render in front of background.
5122     if (candidateLayer)
5123         return candidateLayer;
5124 
5125     if (isSelfPaintingLayer()) {
5126         HitTestResult tempResult(result.hitTestLocation());
5127         bool insideFragmentBackgroundRect = false;
5128         if (hitTestContentsForFragments(layerFragments, request, tempResult, hitTestLocation, HitTestSelf, insideFragmentBackgroundRect)
5129             &amp;&amp; isHitCandidate(this, false, zOffsetForContentsPtr, unflattenedTransformState.get())) {
5130             if (request.resultIsElementList())
5131                 result.append(tempResult, request);
5132             else
5133                 result = tempResult;
5134             return this;
5135         }
5136         if (insideFragmentBackgroundRect &amp;&amp; request.resultIsElementList())
5137             result.append(tempResult, request);
5138     }
5139 
5140     return nullptr;
5141 }
5142 
5143 bool RenderLayer::hitTestContentsForFragments(const LayerFragments&amp; layerFragments, const HitTestRequest&amp; request, HitTestResult&amp; result,
5144     const HitTestLocation&amp; hitTestLocation, HitTestFilter hitTestFilter, bool&amp; insideClipRect) const
5145 {
5146     if (layerFragments.isEmpty())
5147         return false;
5148 
5149     for (int i = layerFragments.size() - 1; i &gt;= 0; --i) {
5150         const LayerFragment&amp; fragment = layerFragments.at(i);
5151         if ((hitTestFilter == HitTestSelf &amp;&amp; !fragment.backgroundRect.intersects(hitTestLocation))
5152             || (hitTestFilter == HitTestDescendants &amp;&amp; !fragment.foregroundRect.intersects(hitTestLocation)))
5153             continue;
5154         insideClipRect = true;
5155         if (hitTestContents(request, result, fragment.layerBounds, hitTestLocation, hitTestFilter))
5156             return true;
5157     }
5158 
5159     return false;
5160 }
5161 
5162 bool RenderLayer::hitTestResizerInFragments(const LayerFragments&amp; layerFragments, const HitTestLocation&amp; hitTestLocation) const
5163 {
5164     if (layerFragments.isEmpty())
5165         return false;
5166 
5167     for (int i = layerFragments.size() - 1; i &gt;= 0; --i) {
5168         const LayerFragment&amp; fragment = layerFragments.at(i);
5169         if (fragment.backgroundRect.intersects(hitTestLocation) &amp;&amp; resizerCornerRect(*this, snappedIntRect(fragment.layerBounds)).contains(hitTestLocation.roundedPoint()))
5170             return true;
5171     }
5172 
5173     return false;
5174 }
5175 
5176 RenderLayer* RenderLayer::hitTestTransformedLayerInFragments(RenderLayer* rootLayer, RenderLayer* containerLayer, const HitTestRequest&amp; request, HitTestResult&amp; result,
5177     const LayoutRect&amp; hitTestRect, const HitTestLocation&amp; hitTestLocation, const HitTestingTransformState* transformState, double* zOffset)
5178 {
5179     LayerFragments enclosingPaginationFragments;
5180     LayoutSize offsetOfPaginationLayerFromRoot;
5181     RenderLayer* paginatedLayer = enclosingPaginationLayer(IncludeCompositedPaginatedLayers);
5182     LayoutRect transformedExtent = transparencyClipBox(*this, paginatedLayer, HitTestingTransparencyClipBox, RootOfTransparencyClipBox);
5183     paginatedLayer-&gt;collectFragments(enclosingPaginationFragments, rootLayer, hitTestRect, IncludeCompositedPaginatedLayers,
5184         RootRelativeClipRects, IncludeOverlayScrollbarSize, RespectOverflowClip, offsetOfPaginationLayerFromRoot, &amp;transformedExtent);
5185 
5186     for (int i = enclosingPaginationFragments.size() - 1; i &gt;= 0; --i) {
5187         const LayerFragment&amp; fragment = enclosingPaginationFragments.at(i);
5188 
5189         // Apply the page/column clip for this fragment, as well as any clips established by layers in between us and
5190         // the enclosing pagination layer.
5191         LayoutRect clipRect = fragment.backgroundRect.rect();
5192 
5193         // Now compute the clips within a given fragment
5194         if (parent() != paginatedLayer) {
5195             offsetOfPaginationLayerFromRoot = toLayoutSize(paginatedLayer-&gt;convertToLayerCoords(rootLayer, toLayoutPoint(offsetOfPaginationLayerFromRoot)));
5196 
5197             ClipRectsContext clipRectsContext(paginatedLayer, RootRelativeClipRects, IncludeOverlayScrollbarSize);
5198             LayoutRect parentClipRect = backgroundClipRect(clipRectsContext).rect();
5199             parentClipRect.move(fragment.paginationOffset + offsetOfPaginationLayerFromRoot);
5200             clipRect.intersect(parentClipRect);
5201         }
5202 
5203         if (!hitTestLocation.intersects(clipRect))
5204             continue;
5205 
5206         RenderLayer* hitLayer = hitTestLayerByApplyingTransform(rootLayer, containerLayer, request, result, hitTestRect, hitTestLocation,
5207             transformState, zOffset, fragment.paginationOffset);
5208         if (hitLayer)
5209             return hitLayer;
5210     }
5211 
5212     return nullptr;
5213 }
5214 
5215 RenderLayer* RenderLayer::hitTestLayerByApplyingTransform(RenderLayer* rootLayer, RenderLayer* containerLayer, const HitTestRequest&amp; request, HitTestResult&amp; result,
5216     const LayoutRect&amp; hitTestRect, const HitTestLocation&amp; hitTestLocation, const HitTestingTransformState* transformState, double* zOffset,
5217     const LayoutSize&amp; translationOffset)
5218 {
5219     // Create a transform state to accumulate this transform.
5220     Ref&lt;HitTestingTransformState&gt; newTransformState = createLocalTransformState(rootLayer, containerLayer, hitTestRect, hitTestLocation, transformState, translationOffset);
5221 
5222     // If the transform can&#39;t be inverted, then don&#39;t hit test this layer at all.
5223     if (!newTransformState-&gt;m_accumulatedTransform.isInvertible())
5224         return nullptr;
5225 
5226     // Compute the point and the hit test rect in the coords of this layer by using the values
5227     // from the transformState, which store the point and quad in the coords of the last flattened
5228     // layer, and the accumulated transform which lets up map through preserve-3d layers.
5229     //
5230     // We can&#39;t just map hitTestLocation and hitTestRect because they may have been flattened (losing z)
5231     // by our container.
5232     FloatPoint localPoint = newTransformState-&gt;mappedPoint();
5233     FloatQuad localPointQuad = newTransformState-&gt;mappedQuad();
5234     LayoutRect localHitTestRect = newTransformState-&gt;boundsOfMappedArea();
5235     HitTestLocation newHitTestLocation;
5236     if (hitTestLocation.isRectBasedTest())
5237         newHitTestLocation = HitTestLocation(localPoint, localPointQuad);
5238     else
5239         newHitTestLocation = HitTestLocation(localPoint);
5240 
5241     // Now do a hit test with the root layer shifted to be us.
5242     return hitTestLayer(this, containerLayer, request, result, localHitTestRect, newHitTestLocation, true, newTransformState.ptr(), zOffset);
5243 }
5244 
5245 bool RenderLayer::hitTestContents(const HitTestRequest&amp; request, HitTestResult&amp; result, const LayoutRect&amp; layerBounds, const HitTestLocation&amp; hitTestLocation, HitTestFilter hitTestFilter) const
5246 {
5247     ASSERT(isSelfPaintingLayer() || hasSelfPaintingLayerDescendant());
5248 
5249     if (!renderer().hitTest(request, result, hitTestLocation, toLayoutPoint(layerBounds.location() - renderBoxLocation()), hitTestFilter)) {
5250         // It&#39;s wrong to set innerNode, but then claim that you didn&#39;t hit anything, unless it is
5251         // a rect-based test.
5252         ASSERT(!result.innerNode() || (request.resultIsElementList() &amp;&amp; result.listBasedTestResult().size()));
5253         return false;
5254     }
5255 
5256     // For positioned generated content, we might still not have a
5257     // node by the time we get to the layer level, since none of
5258     // the content in the layer has an element. So just walk up
5259     // the tree.
5260     if (!result.innerNode() || !result.innerNonSharedNode()) {
5261         if (isOutOfFlowRenderFragmentedFlow()) {
5262             // The flowthread doesn&#39;t have an enclosing element, so when hitting the layer of the
5263             // flowthread (e.g. the descent area of the RootInlineBox for the image flowed alone
5264             // inside the flow thread) we&#39;re letting the hit testing continue so it will hit the region.
5265             return false;
5266         }
5267 
5268         Element* e = enclosingElement();
5269         if (!result.innerNode())
5270             result.setInnerNode(e);
5271         if (!result.innerNonSharedNode())
5272             result.setInnerNonSharedNode(e);
5273     }
5274 
5275     return true;
5276 }
5277 
5278 RenderLayer* RenderLayer::hitTestList(LayerList layerIterator, RenderLayer* rootLayer,
5279                                       const HitTestRequest&amp; request, HitTestResult&amp; result,
5280                                       const LayoutRect&amp; hitTestRect, const HitTestLocation&amp; hitTestLocation,
5281                                       const HitTestingTransformState* transformState,
5282                                       double* zOffsetForDescendants, double* zOffset,
5283                                       const HitTestingTransformState* unflattenedTransformState,
5284                                       bool depthSortDescendants)
5285 {
5286     if (layerIterator.begin() == layerIterator.end())
5287         return nullptr;
5288 
5289     if (!hasSelfPaintingLayerDescendant())
5290         return nullptr;
5291 
5292     RenderLayer* resultLayer = nullptr;
5293 
5294     for (auto iter = layerIterator.rbegin(); iter != layerIterator.rend(); ++iter) {
5295         auto* childLayer = *iter;
5296 
5297         HitTestResult tempResult(result.hitTestLocation());
5298         auto* hitLayer = childLayer-&gt;hitTestLayer(rootLayer, this, request, tempResult, hitTestRect, hitTestLocation, false, transformState, zOffsetForDescendants);
5299 
5300         // If it is a list-based test, we can safely append the temporary result since it might had hit
5301         // nodes but not necesserily had hitLayer set.
5302         ASSERT(!result.isRectBasedTest() || request.resultIsElementList());
5303         if (request.resultIsElementList())
5304             result.append(tempResult, request);
5305 
5306         if (isHitCandidate(hitLayer, depthSortDescendants, zOffset, unflattenedTransformState)) {
5307             resultLayer = hitLayer;
5308             if (!request.resultIsElementList())
5309                 result = tempResult;
5310             if (!depthSortDescendants)
5311                 break;
5312         }
5313     }
5314 
5315     return resultLayer;
5316 }
5317 
5318 Ref&lt;ClipRects&gt; RenderLayer::updateClipRects(const ClipRectsContext&amp; clipRectsContext)
5319 {
5320     ClipRectsType clipRectsType = clipRectsContext.clipRectsType;
5321     ASSERT(clipRectsType &lt; NumCachedClipRectsTypes);
5322     if (m_clipRectsCache) {
5323         if (auto* clipRects = m_clipRectsCache-&gt;getClipRects(clipRectsType, clipRectsContext.respectOverflowClip)) {
5324             ASSERT(clipRectsContext.rootLayer == m_clipRectsCache-&gt;m_clipRectsRoot[clipRectsType]);
5325             ASSERT(m_clipRectsCache-&gt;m_scrollbarRelevancy[clipRectsType] == clipRectsContext.overlayScrollbarSizeRelevancy);
5326 
5327 #ifdef CHECK_CACHED_CLIP_RECTS
5328             // This code is useful to check cached clip rects, but is too expensive to leave enabled in debug builds by default.
5329             ClipRectsContext tempContext(clipRectsContext);
5330             tempContext.clipRectsType = TemporaryClipRects;
5331             Ref&lt;ClipRects&gt; tempClipRects = ClipRects::create();
5332             calculateClipRects(tempContext, tempClipRects);
5333             ASSERT(tempClipRects.get() == *clipRects);
5334 #endif
5335             return *clipRects; // We have the correct cached value.
5336         }
5337     }
5338 
5339     if (!m_clipRectsCache)
5340         m_clipRectsCache = std::make_unique&lt;ClipRectsCache&gt;();
5341 #ifndef NDEBUG
5342     m_clipRectsCache-&gt;m_clipRectsRoot[clipRectsType] = clipRectsContext.rootLayer;
5343     m_clipRectsCache-&gt;m_scrollbarRelevancy[clipRectsType] = clipRectsContext.overlayScrollbarSizeRelevancy;
5344 #endif
5345 
5346     RefPtr&lt;ClipRects&gt; parentClipRects;
5347     // For transformed layers, the root layer was shifted to be us, so there is no need to
5348     // examine the parent. We want to cache clip rects with us as the root.
5349     if (auto* parentLayer = (clipRectsContext.rootLayer != this ? parent() : nullptr))
5350         parentClipRects = parentLayer-&gt;updateClipRects(clipRectsContext);
5351 
5352     auto clipRects = ClipRects::create();
5353     calculateClipRects(clipRectsContext, clipRects);
5354 
5355     if (parentClipRects &amp;&amp; *parentClipRects == clipRects) {
5356         m_clipRectsCache-&gt;setClipRects(clipRectsType, clipRectsContext.respectOverflowClip, parentClipRects.copyRef());
5357         return parentClipRects.releaseNonNull();
5358     }
5359     m_clipRectsCache-&gt;setClipRects(clipRectsType, clipRectsContext.respectOverflowClip, clipRects.copyRef());
5360     return clipRects;
5361 }
5362 
5363 ClipRects* RenderLayer::clipRects(const ClipRectsContext&amp; context) const
5364 {
5365     ASSERT(context.clipRectsType &lt; NumCachedClipRectsTypes);
5366     if (!m_clipRectsCache)
5367         return nullptr;
5368     return m_clipRectsCache-&gt;getClipRects(context.clipRectsType, context.respectOverflowClip);
5369 }
5370 
5371 void RenderLayer::calculateClipRects(const ClipRectsContext&amp; clipRectsContext, ClipRects&amp; clipRects) const
5372 {
5373     if (!parent()) {
5374         // The root layer&#39;s clip rect is always infinite.
5375         clipRects.reset();
5376         return;
5377     }
5378 
5379     ClipRectsType clipRectsType = clipRectsContext.clipRectsType;
5380     bool useCached = clipRectsType != TemporaryClipRects;
5381 
5382     // For transformed layers, the root layer was shifted to be us, so there is no need to
5383     // examine the parent. We want to cache clip rects with us as the root.
5384     RenderLayer* parentLayer = clipRectsContext.rootLayer != this ? parent() : nullptr;
5385 
5386     // Ensure that our parent&#39;s clip has been calculated so that we can examine the values.
5387     if (parentLayer) {
5388         if (useCached &amp;&amp; parentLayer-&gt;clipRects(clipRectsContext))
5389             clipRects = *parentLayer-&gt;clipRects(clipRectsContext);
5390         else {
5391             ClipRectsContext parentContext(clipRectsContext);
5392             parentContext.overlayScrollbarSizeRelevancy = IgnoreOverlayScrollbarSize; // FIXME: why?
5393             parentLayer-&gt;calculateClipRects(parentContext, clipRects);
5394         }
5395     } else
5396         clipRects.reset();
5397 
5398     // A fixed object is essentially the root of its containing block hierarchy, so when
5399     // we encounter such an object, we reset our clip rects to the fixedClipRect.
5400     if (renderer().isFixedPositioned()) {
5401         clipRects.setPosClipRect(clipRects.fixedClipRect());
5402         clipRects.setOverflowClipRect(clipRects.fixedClipRect());
5403         clipRects.setFixed(true);
5404     } else if (renderer().isInFlowPositioned())
5405         clipRects.setPosClipRect(clipRects.overflowClipRect());
5406     else if (renderer().isAbsolutelyPositioned())
5407         clipRects.setOverflowClipRect(clipRects.posClipRect());
5408 
5409     // Update the clip rects that will be passed to child layers.
5410 #if PLATFORM(IOS_FAMILY)
5411     if (renderer().hasClipOrOverflowClip() &amp;&amp; (clipRectsContext.respectOverflowClip == RespectOverflowClip || this != clipRectsContext.rootLayer)) {
5412 #else
5413     if ((renderer().hasOverflowClip() &amp;&amp; (clipRectsContext.respectOverflowClip == RespectOverflowClip || this != clipRectsContext.rootLayer)) || renderer().hasClip()) {
5414 #endif
5415         // This layer establishes a clip of some kind.
5416 
5417         // This offset cannot use convertToLayerCoords, because sometimes our rootLayer may be across
5418         // some transformed layer boundary, for example, in the RenderLayerCompositor overlapMap, where
5419         // clipRects are needed in view space.
5420         LayoutPoint offset(renderer().localToContainerPoint(FloatPoint(), &amp;clipRectsContext.rootLayer-&gt;renderer()));
5421         if (clipRects.fixed() &amp;&amp; &amp;clipRectsContext.rootLayer-&gt;renderer() == &amp;renderer().view())
5422             offset -= toLayoutSize(renderer().view().frameView().scrollPositionForFixedPosition());
5423 
5424         if (renderer().hasOverflowClip()) {
5425             ClipRect newOverflowClip = downcast&lt;RenderBox&gt;(renderer()).overflowClipRectForChildLayers(offset, nullptr, clipRectsContext.overlayScrollbarSizeRelevancy);
5426             newOverflowClip.setAffectedByRadius(renderer().style().hasBorderRadius());
5427             clipRects.setOverflowClipRect(intersection(newOverflowClip, clipRects.overflowClipRect()));
5428             if (renderer().isPositioned())
5429                 clipRects.setPosClipRect(intersection(newOverflowClip, clipRects.posClipRect()));
5430         }
5431         if (renderer().hasClip()) {
5432             LayoutRect newPosClip = downcast&lt;RenderBox&gt;(renderer()).clipRect(offset, nullptr);
5433             clipRects.setPosClipRect(intersection(newPosClip, clipRects.posClipRect()));
5434             clipRects.setOverflowClipRect(intersection(newPosClip, clipRects.overflowClipRect()));
5435             clipRects.setFixedClipRect(intersection(newPosClip, clipRects.fixedClipRect()));
5436         }
5437     }
5438 }
5439 
5440 Ref&lt;ClipRects&gt; RenderLayer::parentClipRects(const ClipRectsContext&amp; clipRectsContext) const
5441 {
5442     ASSERT(parent());
5443 
5444     if (clipRectsContext.clipRectsType == TemporaryClipRects) {
5445         auto parentClipRects = ClipRects::create();
5446         parent()-&gt;calculateClipRects(clipRectsContext, parentClipRects);
5447         return parentClipRects;
5448     }
5449 
5450     return parent()-&gt;updateClipRects(clipRectsContext);
5451 }
5452 
5453 static inline ClipRect backgroundClipRectForPosition(const ClipRects&amp; parentRects, PositionType position)
5454 {
5455     if (position == PositionType::Fixed)
5456         return parentRects.fixedClipRect();
5457 
5458     if (position == PositionType::Absolute)
5459         return parentRects.posClipRect();
5460 
5461     return parentRects.overflowClipRect();
5462 }
5463 
5464 ClipRect RenderLayer::backgroundClipRect(const ClipRectsContext&amp; clipRectsContext) const
5465 {
5466     ASSERT(parent());
5467     auto computeParentRects = [&amp;] {
5468         if (clipRectsContext.clipRectsType == TemporaryClipRects)
5469             return parentClipRects(clipRectsContext);
5470         // If we cross into a different composition/pagination context, then we can&#39;t rely on the cache since the root layer differs.
5471         bool crossesPaginationBoundary = parent()-&gt;enclosingPaginationLayer(IncludeCompositedPaginatedLayers) != enclosingPaginationLayer(IncludeCompositedPaginatedLayers);
5472         bool crossesCompositingBoundary = parent()-&gt;enclosingCompositingLayerForRepaint() != enclosingCompositingLayerForRepaint();
5473         if (!crossesPaginationBoundary &amp;&amp; !crossesCompositingBoundary)
5474             return parentClipRects(clipRectsContext);
5475 
5476         ClipRectsContext tempContext(clipRectsContext);
5477         tempContext.clipRectsType = TemporaryClipRects;
5478         return parentClipRects(tempContext);
5479     };
5480 
5481     auto parentRects = computeParentRects();
5482     ClipRect backgroundClipRect = backgroundClipRectForPosition(parentRects, renderer().style().position());
5483     RenderView&amp; view = renderer().view();
5484     // Note: infinite clipRects should not be scrolled here, otherwise they will accidentally no longer be considered infinite.
5485     if (parentRects-&gt;fixed() &amp;&amp; &amp;clipRectsContext.rootLayer-&gt;renderer() == &amp;view &amp;&amp; !backgroundClipRect.isInfinite())
5486         backgroundClipRect.moveBy(view.frameView().scrollPositionForFixedPosition());
5487     return backgroundClipRect;
5488 }
5489 
5490 void RenderLayer::calculateRects(const ClipRectsContext&amp; clipRectsContext, const LayoutRect&amp; paintDirtyRect, LayoutRect&amp; layerBounds,
5491     ClipRect&amp; backgroundRect, ClipRect&amp; foregroundRect, const LayoutSize&amp; offsetFromRoot) const
5492 {
5493     if (clipRectsContext.rootLayer != this &amp;&amp; parent()) {
5494         backgroundRect = backgroundClipRect(clipRectsContext);
5495         backgroundRect.intersect(paintDirtyRect);
5496     } else
5497         backgroundRect = paintDirtyRect;
5498 
5499     LayoutSize offsetFromRootLocal = offsetFromRoot;
5500 
5501     if (clipRectsContext.rootLayer-&gt;isOutOfFlowRenderFragmentedFlow()) {
5502         LayoutPoint absPos = LayoutPoint(renderer().view().localToAbsolute(FloatPoint(), IsFixed));
5503         offsetFromRootLocal += toLayoutSize(absPos);
5504     }
5505 
5506     layerBounds = LayoutRect(toLayoutPoint(offsetFromRootLocal), size());
5507 
5508     foregroundRect = backgroundRect;
5509 
5510     // Update the clip rects that will be passed to child layers.
5511     if (renderer().hasClipOrOverflowClip()) {
5512         // This layer establishes a clip of some kind.
5513         if (renderer().hasOverflowClip() &amp;&amp; (this != clipRectsContext.rootLayer || clipRectsContext.respectOverflowClip == RespectOverflowClip)) {
5514             foregroundRect.intersect(downcast&lt;RenderBox&gt;(renderer()).overflowClipRect(toLayoutPoint(offsetFromRootLocal), nullptr, clipRectsContext.overlayScrollbarSizeRelevancy));
5515             if (renderer().style().hasBorderRadius())
5516                 foregroundRect.setAffectedByRadius(true);
5517         }
5518 
5519         if (renderer().hasClip()) {
5520             // Clip applies to *us* as well, so update the damageRect.
5521             LayoutRect newPosClip = downcast&lt;RenderBox&gt;(renderer()).clipRect(toLayoutPoint(offsetFromRootLocal), nullptr);
5522             backgroundRect.intersect(newPosClip);
5523             foregroundRect.intersect(newPosClip);
5524         }
5525 
5526         // If we establish a clip at all, then make sure our background rect is intersected with our layer&#39;s bounds including our visual overflow,
5527         // since any visual overflow like box-shadow or border-outset is not clipped by overflow:auto/hidden.
5528         if (renderBox()-&gt;hasVisualOverflow()) {
5529             // FIXME: Does not do the right thing with CSS regions yet, since we don&#39;t yet factor in the
5530             // individual region boxes as overflow.
5531             LayoutRect layerBoundsWithVisualOverflow = renderBox()-&gt;visualOverflowRect();
5532             renderBox()-&gt;flipForWritingMode(layerBoundsWithVisualOverflow); // Layers are in physical coordinates, so the overflow has to be flipped.
5533             layerBoundsWithVisualOverflow.move(offsetFromRootLocal);
5534             if (this != clipRectsContext.rootLayer || clipRectsContext.respectOverflowClip == RespectOverflowClip)
5535                 backgroundRect.intersect(layerBoundsWithVisualOverflow);
5536         } else {
5537             // Shift the bounds to be for our region only.
5538             LayoutRect bounds = renderBox()-&gt;borderBoxRectInFragment(nullptr);
5539 
5540             bounds.move(offsetFromRootLocal);
5541             if (this != clipRectsContext.rootLayer || clipRectsContext.respectOverflowClip == RespectOverflowClip)
5542                 backgroundRect.intersect(bounds);
5543         }
5544     }
5545 }
5546 
5547 LayoutRect RenderLayer::childrenClipRect() const
5548 {
5549     // FIXME: border-radius not accounted for.
5550     // FIXME: Regions not accounted for.
5551     RenderLayer* clippingRootLayer = clippingRootForPainting();
5552     LayoutRect layerBounds;
5553     ClipRect backgroundRect;
5554     ClipRect foregroundRect;
5555     ClipRectsContext clipRectsContext(clippingRootLayer, TemporaryClipRects);
5556     // Need to use temporary clip rects, because the value of &#39;dontClipToOverflow&#39; may be different from the painting path (&lt;rdar://problem/11844909&gt;).
5557     calculateRects(clipRectsContext, LayoutRect::infiniteRect(), layerBounds, backgroundRect, foregroundRect, offsetFromAncestor(clipRectsContext.rootLayer));
5558     if (foregroundRect.rect().isInfinite())
5559         return renderer().view().unscaledDocumentRect();
5560 
5561     auto absoluteClippingRect = clippingRootLayer-&gt;renderer().localToAbsoluteQuad(FloatQuad(foregroundRect.rect())).enclosingBoundingBox();
5562     return intersection(absoluteClippingRect, renderer().view().unscaledDocumentRect());
5563 }
5564 
5565 LayoutRect RenderLayer::clipRectRelativeToAncestor(RenderLayer* ancestor, LayoutSize offsetFromAncestor, const LayoutRect&amp; constrainingRect) const
5566 {
5567     LayoutRect layerBounds;
5568     ClipRect backgroundRect;
5569     ClipRect foregroundRect;
5570     auto clipRectType = !m_enclosingPaginationLayer || m_enclosingPaginationLayer == ancestor ? PaintingClipRects : TemporaryClipRects;
5571     ClipRectsContext clipRectsContext(ancestor, clipRectType);
5572     calculateRects(clipRectsContext, constrainingRect, layerBounds, backgroundRect, foregroundRect, offsetFromAncestor);
5573     return backgroundRect.rect();
5574 }
5575 
5576 LayoutRect RenderLayer::selfClipRect() const
5577 {
5578     // FIXME: border-radius not accounted for.
5579     // FIXME: Regions not accounted for.
5580     RenderLayer* clippingRootLayer = clippingRootForPainting();
5581     LayoutRect clipRect = clipRectRelativeToAncestor(clippingRootLayer, offsetFromAncestor(clippingRootLayer), renderer().view().documentRect());
5582     return clippingRootLayer-&gt;renderer().localToAbsoluteQuad(FloatQuad(clipRect)).enclosingBoundingBox();
5583 }
5584 
5585 LayoutRect RenderLayer::localClipRect(bool&amp; clipExceedsBounds) const
5586 {
5587     clipExceedsBounds = false;
5588     // FIXME: border-radius not accounted for.
5589     // FIXME: Regions not accounted for.
5590     RenderLayer* clippingRootLayer = clippingRootForPainting();
5591     LayoutSize offsetFromRoot = offsetFromAncestor(clippingRootLayer);
5592     LayoutRect clipRect = clipRectRelativeToAncestor(clippingRootLayer, offsetFromRoot, LayoutRect::infiniteRect());
5593     if (clipRect.isInfinite())
5594         return clipRect;
5595 
5596     if (renderer().hasClip()) {
5597         // CSS clip may be larger than our border box.
5598         LayoutRect cssClipRect = downcast&lt;RenderBox&gt;(renderer()).clipRect(toLayoutPoint(offsetFromRoot), nullptr);
5599         clipExceedsBounds = !clipRect.contains(cssClipRect);
5600     }
5601 
5602     clipRect.move(-offsetFromRoot);
5603     return clipRect;
5604 }
5605 
5606 void RenderLayer::addBlockSelectionGapsBounds(const LayoutRect&amp; bounds)
5607 {
5608     m_blockSelectionGapsBounds.unite(enclosingIntRect(bounds));
5609 }
5610 
5611 void RenderLayer::clearBlockSelectionGapsBounds()
5612 {
5613     m_blockSelectionGapsBounds = IntRect();
5614     for (RenderLayer* child = firstChild(); child; child = child-&gt;nextSibling())
5615         child-&gt;clearBlockSelectionGapsBounds();
5616 }
5617 
5618 void RenderLayer::repaintBlockSelectionGaps()
5619 {
5620     for (RenderLayer* child = firstChild(); child; child = child-&gt;nextSibling())
5621         child-&gt;repaintBlockSelectionGaps();
5622 
5623     if (m_blockSelectionGapsBounds.isEmpty())
5624         return;
5625 
5626     LayoutRect rect = m_blockSelectionGapsBounds;
5627     rect.moveBy(-scrollPosition());
5628     if (renderer().hasOverflowClip() &amp;&amp; !usesCompositedScrolling())
5629         rect.intersect(downcast&lt;RenderBox&gt;(renderer()).overflowClipRect(LayoutPoint(), nullptr)); // FIXME: Regions not accounted for.
5630     if (renderer().hasClip())
5631         rect.intersect(downcast&lt;RenderBox&gt;(renderer()).clipRect(LayoutPoint(), nullptr)); // FIXME: Regions not accounted for.
5632     if (!rect.isEmpty())
5633         renderer().repaintRectangle(rect);
5634 }
5635 
5636 bool RenderLayer::intersectsDamageRect(const LayoutRect&amp; layerBounds, const LayoutRect&amp; damageRect, const RenderLayer* rootLayer, const LayoutSize&amp; offsetFromRoot, const LayoutRect* cachedBoundingBox) const
5637 {
5638     // Always examine the canvas and the root.
5639     // FIXME: Could eliminate the isDocumentElementRenderer() check if we fix background painting so that the RenderView
5640     // paints the root&#39;s background.
5641     if (isRenderViewLayer() || renderer().isDocumentElementRenderer())
5642         return true;
5643 
5644     if (damageRect.isInfinite())
5645         return true;
5646 
5647     if (damageRect.isEmpty())
5648         return false;
5649 
5650     // If we aren&#39;t an inline flow, and our layer bounds do intersect the damage rect, then we can return true.
5651     if (!renderer().isRenderInline() &amp;&amp; layerBounds.intersects(damageRect))
5652         return true;
5653 
5654     // Otherwise we need to compute the bounding box of this single layer and see if it intersects
5655     // the damage rect. It&#39;s possible the fragment computed the bounding box already, in which case we
5656     // can use the cached value.
5657     if (cachedBoundingBox)
5658         return cachedBoundingBox-&gt;intersects(damageRect);
5659 
5660     return boundingBox(rootLayer, offsetFromRoot).intersects(damageRect);
5661 }
5662 
5663 LayoutRect RenderLayer::localBoundingBox(OptionSet&lt;CalculateLayerBoundsFlag&gt; flags) const
5664 {
5665     // There are three special cases we need to consider.
5666     // (1) Inline Flows.  For inline flows we will create a bounding box that fully encompasses all of the lines occupied by the
5667     // inline.  In other words, if some &lt;span&gt; wraps to three lines, we&#39;ll create a bounding box that fully encloses the
5668     // line boxes of all three lines (including overflow on those lines).
5669     // (2) Left/Top Overflow.  The width/height of layers already includes right/bottom overflow.  However, in the case of left/top
5670     // overflow, we have to create a bounding box that will extend to include this overflow.
5671     // (3) Floats.  When a layer has overhanging floats that it paints, we need to make sure to include these overhanging floats
5672     // as part of our bounding box.  We do this because we are the responsible layer for both hit testing and painting those
5673     // floats.
5674     LayoutRect result;
5675     if (renderer().isInline() &amp;&amp; is&lt;RenderInline&gt;(renderer()))
5676         result = downcast&lt;RenderInline&gt;(renderer()).linesVisualOverflowBoundingBox();
5677     else if (is&lt;RenderTableRow&gt;(renderer())) {
5678         auto&amp; tableRow = downcast&lt;RenderTableRow&gt;(renderer());
5679         // Our bounding box is just the union of all of our cells&#39; border/overflow rects.
5680         for (RenderTableCell* cell = tableRow.firstCell(); cell; cell = cell-&gt;nextCell()) {
5681             LayoutRect bbox = cell-&gt;borderBoxRect();
5682             result.unite(bbox);
5683             LayoutRect overflowRect = tableRow.visualOverflowRect();
5684             if (bbox != overflowRect)
5685                 result.unite(overflowRect);
5686         }
5687     } else {
5688         RenderBox* box = renderBox();
5689         ASSERT(box);
5690         if (!(flags &amp; DontConstrainForMask) &amp;&amp; box-&gt;hasMask()) {
5691             result = box-&gt;maskClipRect(LayoutPoint());
5692             box-&gt;flipForWritingMode(result); // The mask clip rect is in physical coordinates, so we have to flip, since localBoundingBox is not.
5693         } else {
5694             LayoutRect bbox = box-&gt;borderBoxRect();
5695             result = bbox;
5696             LayoutRect overflowRect = box-&gt;visualOverflowRect();
5697             if (bbox != overflowRect)
5698                 result.unite(overflowRect);
5699         }
5700     }
5701     return result;
5702 }
5703 
5704 LayoutRect RenderLayer::boundingBox(const RenderLayer* ancestorLayer, const LayoutSize&amp; offsetFromRoot, OptionSet&lt;CalculateLayerBoundsFlag&gt; flags) const
5705 {
5706     LayoutRect result = localBoundingBox(flags);
5707     if (renderer().view().frameView().hasFlippedBlockRenderers()) {
5708         if (renderer().isBox())
5709             renderBox()-&gt;flipForWritingMode(result);
5710         else
5711             renderer().containingBlock()-&gt;flipForWritingMode(result);
5712     }
5713 
5714     PaginationInclusionMode inclusionMode = ExcludeCompositedPaginatedLayers;
5715     if (flags &amp; UseFragmentBoxesIncludingCompositing)
5716         inclusionMode = IncludeCompositedPaginatedLayers;
5717 
5718     const RenderLayer* paginationLayer = nullptr;
5719     if (flags.containsAny({ UseFragmentBoxesExcludingCompositing, UseFragmentBoxesIncludingCompositing }))
5720         paginationLayer = enclosingPaginationLayerInSubtree(ancestorLayer, inclusionMode);
5721 
5722     const RenderLayer* childLayer = this;
5723     bool isPaginated = paginationLayer;
5724     while (paginationLayer) {
5725         // Split our box up into the actual fragment boxes that render in the columns/pages and unite those together to
5726         // get our true bounding box.
5727         result.move(childLayer-&gt;offsetFromAncestor(paginationLayer));
5728 
5729         auto&amp; enclosingFragmentedFlow = downcast&lt;RenderFragmentedFlow&gt;(paginationLayer-&gt;renderer());
5730         result = enclosingFragmentedFlow.fragmentsBoundingBox(result);
5731 
5732         childLayer = paginationLayer;
5733         paginationLayer = paginationLayer-&gt;parent()-&gt;enclosingPaginationLayerInSubtree(ancestorLayer, inclusionMode);
5734     }
5735 
5736     if (isPaginated) {
5737         result.move(childLayer-&gt;offsetFromAncestor(ancestorLayer));
5738         return result;
5739     }
5740 
5741     result.move(offsetFromRoot);
5742     return result;
5743 }
5744 
5745 bool RenderLayer::getOverlapBoundsIncludingChildrenAccountingForTransformAnimations(LayoutRect&amp; bounds, OptionSet&lt;CalculateLayerBoundsFlag&gt; additionalFlags) const
5746 {
5747     // The animation will override the display transform, so don&#39;t include it.
5748     auto boundsFlags = additionalFlags | (defaultCalculateLayerBoundsFlags() - IncludeSelfTransform);
5749 
5750     bounds = calculateLayerBounds(this, LayoutSize(), boundsFlags);
5751 
5752     LayoutRect animatedBounds = bounds;
5753     if (RuntimeEnabledFeatures::sharedFeatures().webAnimationsCSSIntegrationEnabled()) {
5754         if (auto* timeline = renderer().documentTimeline()) {
5755             if (timeline-&gt;computeExtentOfAnimation(renderer(), animatedBounds)) {
5756                 bounds = animatedBounds;
5757                 return true;
5758             }
5759         }
5760     } else {
5761         if (renderer().animation().computeExtentOfAnimation(renderer(), animatedBounds)) {
5762             bounds = animatedBounds;
5763             return true;
5764         }
5765     }
5766 
5767     return false;
5768 }
5769 
5770 IntRect RenderLayer::absoluteBoundingBox() const
5771 {
5772     const RenderLayer* rootLayer = root();
5773     return snappedIntRect(boundingBox(rootLayer, offsetFromAncestor(rootLayer)));
5774 }
5775 
5776 FloatRect RenderLayer::absoluteBoundingBoxForPainting() const
5777 {
5778     const RenderLayer* rootLayer = root();
5779     return snapRectToDevicePixels(boundingBox(rootLayer, offsetFromAncestor(rootLayer)), renderer().document().deviceScaleFactor());
5780 }
5781 
5782 LayoutRect RenderLayer::overlapBounds() const
5783 {
5784     if (overlapBoundsIncludeChildren())
5785         return calculateLayerBounds(this, { }, defaultCalculateLayerBoundsFlags() | IncludeFilterOutsets);
5786 
5787     return localBoundingBox();
5788 }
5789 
5790 LayoutRect RenderLayer::calculateLayerBounds(const RenderLayer* ancestorLayer, const LayoutSize&amp; offsetFromRoot, OptionSet&lt;CalculateLayerBoundsFlag&gt; flags) const
5791 {
5792     if (!isSelfPaintingLayer())
5793         return LayoutRect();
5794 
5795     // FIXME: This could be improved to do a check like hasVisibleNonCompositingDescendantLayers() (bug 92580).
5796     if ((flags &amp; ExcludeHiddenDescendants) &amp;&amp; this != ancestorLayer &amp;&amp; !hasVisibleContent() &amp;&amp; !hasVisibleDescendant())
5797         return LayoutRect();
5798 
5799     if (isRenderViewLayer()) {
5800         // The root layer is always just the size of the document.
5801         return renderer().view().unscaledDocumentRect();
5802     }
5803 
5804     LayoutRect boundingBoxRect = localBoundingBox(flags);
5805     if (renderer().view().frameView().hasFlippedBlockRenderers()) {
5806         if (is&lt;RenderBox&gt;(renderer()))
5807             downcast&lt;RenderBox&gt;(renderer()).flipForWritingMode(boundingBoxRect);
5808         else
5809             renderer().containingBlock()-&gt;flipForWritingMode(boundingBoxRect);
5810     }
5811 
5812     if (renderer().isDocumentElementRenderer()) {
5813         // If the root layer becomes composited (e.g. because some descendant with negative z-index is composited),
5814         // then it has to be big enough to cover the viewport in order to display the background. This is akin
5815         // to the code in RenderBox::paintRootBoxFillLayers().
5816         const FrameView&amp; frameView = renderer().view().frameView();
5817         boundingBoxRect.setWidth(std::max(boundingBoxRect.width(), frameView.contentsWidth() - boundingBoxRect.x()));
5818         boundingBoxRect.setHeight(std::max(boundingBoxRect.height(), frameView.contentsHeight() - boundingBoxRect.y()));
5819     }
5820 
5821     LayoutRect unionBounds = boundingBoxRect;
5822 
5823     if (flags &amp; UseLocalClipRectIfPossible) {
5824         bool clipExceedsBounds = false;
5825         LayoutRect localClipRect = this-&gt;localClipRect(clipExceedsBounds);
5826         if (!localClipRect.isInfinite() &amp;&amp; !clipExceedsBounds) {
5827             if ((flags &amp; IncludeSelfTransform) &amp;&amp; paintsWithTransform(PaintBehavior::Normal))
5828                 localClipRect = transform()-&gt;mapRect(localClipRect);
5829 
5830             localClipRect.move(offsetFromAncestor(ancestorLayer));
5831             return localClipRect;
5832         }
5833     }
5834 
5835     // FIXME: should probably just pass &#39;flags&#39; down to descendants.
5836     auto descendantFlags = defaultCalculateLayerBoundsFlags() | (flags &amp; ExcludeHiddenDescendants) | (flags &amp; IncludeCompositedDescendants);
5837 
5838     const_cast&lt;RenderLayer*&gt;(this)-&gt;updateLayerListsIfNeeded();
5839 
5840     if (RenderLayer* reflection = reflectionLayer()) {
5841         if (!reflection-&gt;isComposited()) {
5842             LayoutRect childUnionBounds = reflection-&gt;calculateLayerBounds(this, reflection-&gt;offsetFromAncestor(this), descendantFlags);
5843             unionBounds.unite(childUnionBounds);
5844         }
5845     }
5846 
5847     ASSERT(isStackingContext() || !positiveZOrderLayers().size());
5848 
5849 #if !ASSERT_DISABLED
5850     LayerListMutationDetector mutationChecker(const_cast&lt;RenderLayer&amp;&gt;(*this));
5851 #endif
5852 
5853     auto computeLayersUnion = [this, &amp;unionBounds, flags, descendantFlags] (const RenderLayer&amp; childLayer) {
5854         if (!(flags &amp; IncludeCompositedDescendants) &amp;&amp; childLayer.isComposited())
5855             return;
5856         LayoutRect childBounds = childLayer.calculateLayerBounds(this, childLayer.offsetFromAncestor(this), descendantFlags);
5857         // Ignore child layer (and behave as if we had overflow: hidden) when it is positioned off the parent layer so much
5858         // that we hit the max LayoutUnit value.
5859         unionBounds.checkedUnite(childBounds);
5860     };
5861 
5862     for (auto* childLayer : negativeZOrderLayers())
5863         computeLayersUnion(*childLayer);
5864 
5865     for (auto* childLayer : positiveZOrderLayers())
5866         computeLayersUnion(*childLayer);
5867 
5868     for (auto* childLayer : normalFlowLayers())
5869         computeLayersUnion(*childLayer);
5870 
5871     if (flags.contains(IncludeFilterOutsets) || (flags.contains(IncludePaintedFilterOutsets) &amp;&amp; paintsWithFilters()))
5872         renderer().style().filterOutsets().expandRect(unionBounds);
5873 
5874     if ((flags &amp; IncludeSelfTransform) &amp;&amp; paintsWithTransform(PaintBehavior::Normal)) {
5875         TransformationMatrix* affineTrans = transform();
5876         boundingBoxRect = affineTrans-&gt;mapRect(boundingBoxRect);
5877         unionBounds = affineTrans-&gt;mapRect(unionBounds);
5878     }
5879     unionBounds.move(offsetFromRoot);
5880     return unionBounds;
5881 }
5882 
5883 void RenderLayer::clearClipRectsIncludingDescendants(ClipRectsType typeToClear)
5884 {
5885     // FIXME: it&#39;s not clear how this layer not having clip rects guarantees that no descendants have any.
5886     if (!m_clipRectsCache)
5887         return;
5888 
5889     clearClipRects(typeToClear);
5890 
5891     for (RenderLayer* l = firstChild(); l; l = l-&gt;nextSibling())
5892         l-&gt;clearClipRectsIncludingDescendants(typeToClear);
5893 }
5894 
5895 void RenderLayer::clearClipRects(ClipRectsType typeToClear)
5896 {
5897     if (typeToClear == AllClipRectTypes)
5898         m_clipRectsCache = nullptr;
5899     else {
5900         ASSERT(typeToClear &lt; NumCachedClipRectsTypes);
5901         m_clipRectsCache-&gt;setClipRects(typeToClear, RespectOverflowClip, nullptr);
5902         m_clipRectsCache-&gt;setClipRects(typeToClear, IgnoreOverflowClip, nullptr);
5903     }
5904 }
5905 
5906 RenderLayerBacking* RenderLayer::ensureBacking()
5907 {
5908     if (!m_backing) {
5909         m_backing = std::make_unique&lt;RenderLayerBacking&gt;(*this);
5910         compositor().layerBecameComposited(*this);
5911 
5912         updateFilterPaintingStrategy();
5913     }
5914     return m_backing.get();
5915 }
5916 
5917 void RenderLayer::clearBacking(bool layerBeingDestroyed)
5918 {
5919     if (!m_backing)
5920         return;
5921 
5922     if (!renderer().renderTreeBeingDestroyed())
5923         compositor().layerBecameNonComposited(*this);
5924 
5925     m_backing-&gt;willBeDestroyed();
5926     m_backing = nullptr;
5927 
5928     if (!layerBeingDestroyed)
5929         updateFilterPaintingStrategy();
5930 }
5931 
5932 bool RenderLayer::hasCompositedMask() const
5933 {
5934     return m_backing &amp;&amp; m_backing-&gt;hasMaskLayer();
5935 }
5936 
5937 GraphicsLayer* RenderLayer::layerForHorizontalScrollbar() const
5938 {
5939     return m_backing ? m_backing-&gt;layerForHorizontalScrollbar() : nullptr;
5940 }
5941 
5942 GraphicsLayer* RenderLayer::layerForVerticalScrollbar() const
5943 {
5944     return m_backing ? m_backing-&gt;layerForVerticalScrollbar() : nullptr;
5945 }
5946 
5947 GraphicsLayer* RenderLayer::layerForScrollCorner() const
5948 {
5949     return m_backing ? m_backing-&gt;layerForScrollCorner() : nullptr;
5950 }
5951 
5952 bool RenderLayer::paintsWithTransform(OptionSet&lt;PaintBehavior&gt; paintBehavior) const
5953 {
5954     bool paintsToWindow = !isComposited() || backing()-&gt;paintsIntoWindow();
5955     return transform() &amp;&amp; ((paintBehavior &amp; PaintBehavior::FlattenCompositingLayers) || paintsToWindow);
5956 }
5957 
5958 bool RenderLayer::shouldPaintMask(OptionSet&lt;PaintBehavior&gt; paintBehavior, OptionSet&lt;PaintLayerFlag&gt; paintFlags) const
5959 {
5960     if (!renderer().hasMask())
5961         return false;
5962 
5963     bool paintsToWindow = !isComposited() || backing()-&gt;paintsIntoWindow();
5964     if (paintsToWindow || (paintBehavior &amp; PaintBehavior::FlattenCompositingLayers))
5965         return true;
5966 
5967     return paintFlags.contains(PaintLayerPaintingCompositingMaskPhase);
5968 }
5969 
5970 bool RenderLayer::shouldApplyClipPath(OptionSet&lt;PaintBehavior&gt; paintBehavior, OptionSet&lt;PaintLayerFlag&gt; paintFlags) const
5971 {
5972     if (!renderer().hasClipPath())
5973         return false;
5974 
5975     bool paintsToWindow = !isComposited() || backing()-&gt;paintsIntoWindow();
5976     if (paintsToWindow || (paintBehavior &amp; PaintBehavior::FlattenCompositingLayers))
5977         return true;
5978 
5979     return paintFlags.contains(PaintLayerPaintingCompositingClipPathPhase);
5980 }
5981 
5982 bool RenderLayer::scrollingMayRevealBackground() const
5983 {
5984     return scrollsOverflow() || usesCompositedScrolling();
5985 }
5986 
5987 bool RenderLayer::backgroundIsKnownToBeOpaqueInRect(const LayoutRect&amp; localRect) const
5988 {
5989     if (!isSelfPaintingLayer() &amp;&amp; !hasSelfPaintingLayerDescendant())
5990         return false;
5991 
5992     if (paintsWithTransparency(PaintBehavior::Normal))
5993         return false;
5994 
5995     if (renderer().isDocumentElementRenderer()) {
5996         // Normally the document element doens&#39;t have a layer.  If it does have a layer, its background propagates to the RenderView
5997         // so this layer doesn&#39;t draw it.
5998         return false;
5999     }
6000 
6001     // We can&#39;t use hasVisibleContent(), because that will be true if our renderer is hidden, but some child
6002     // is visible and that child doesn&#39;t cover the entire rect.
6003     if (renderer().style().visibility() != Visibility::Visible)
6004         return false;
6005 
6006     if (paintsWithFilters() &amp;&amp; renderer().style().filter().hasFilterThatAffectsOpacity())
6007         return false;
6008 
6009     // FIXME: Handle simple transforms.
6010     if (paintsWithTransform(PaintBehavior::Normal))
6011         return false;
6012 
6013     // FIXME: Remove this check.
6014     // This function should not be called when layer-lists are dirty.
6015     // It is somehow getting triggered during style update.
6016     if (zOrderListsDirty() || normalFlowListDirty())
6017         return false;
6018 
6019     // Table painting is special; a table paints its sections.
6020     if (renderer().isTablePart())
6021         return false;
6022 
6023     // FIXME: We currently only check the immediate renderer,
6024     // which will miss many cases.
6025     if (renderer().backgroundIsKnownToBeOpaqueInRect(localRect))
6026         return true;
6027 
6028     // We can&#39;t consult child layers if we clip, since they might cover
6029     // parts of the rect that are clipped out.
6030     if (renderer().hasOverflowClip())
6031         return false;
6032 
6033     return listBackgroundIsKnownToBeOpaqueInRect(positiveZOrderLayers(), localRect)
6034         || listBackgroundIsKnownToBeOpaqueInRect(negativeZOrderLayers(), localRect)
6035         || listBackgroundIsKnownToBeOpaqueInRect(normalFlowLayers(), localRect);
6036 }
6037 
6038 bool RenderLayer::listBackgroundIsKnownToBeOpaqueInRect(const LayerList&amp; list, const LayoutRect&amp; localRect) const
6039 {
6040     if (list.begin() == list.end())
6041         return false;
6042 
6043     for (auto iter = list.rbegin(); iter != list.rend(); ++iter) {
6044         const auto* childLayer = *iter;
6045         if (childLayer-&gt;isComposited())
6046             continue;
6047 
6048         if (!childLayer-&gt;canUseConvertToLayerCoords())
6049             continue;
6050 
6051         LayoutRect childLocalRect(localRect);
6052         childLocalRect.move(-childLayer-&gt;offsetFromAncestor(this));
6053 
6054         if (childLayer-&gt;backgroundIsKnownToBeOpaqueInRect(childLocalRect))
6055             return true;
6056     }
6057     return false;
6058 }
6059 
6060 void RenderLayer::repaintIncludingDescendants()
6061 {
6062     renderer().repaint();
6063     for (RenderLayer* current = firstChild(); current; current = current-&gt;nextSibling())
6064         current-&gt;repaintIncludingDescendants();
6065 }
6066 
6067 void RenderLayer::setBackingNeedsRepaint(GraphicsLayer::ShouldClipToLayer shouldClip)
6068 {
6069     ASSERT(isComposited());
6070     if (backing()-&gt;paintsIntoWindow()) {
6071         // If we&#39;re trying to repaint the placeholder document layer, propagate the
6072         // repaint to the native view system.
6073         renderer().view().repaintViewRectangle(absoluteBoundingBox());
6074     } else
6075         backing()-&gt;setContentsNeedDisplay(shouldClip);
6076 }
6077 
6078 void RenderLayer::setBackingNeedsRepaintInRect(const LayoutRect&amp; r, GraphicsLayer::ShouldClipToLayer shouldClip)
6079 {
6080     // https://bugs.webkit.org/show_bug.cgi?id=61159 describes an unreproducible crash here,
6081     // so assert but check that the layer is composited.
6082     ASSERT(isComposited());
6083     if (!isComposited() || backing()-&gt;paintsIntoWindow()) {
6084         // If we&#39;re trying to repaint the placeholder document layer, propagate the
6085         // repaint to the native view system.
6086         LayoutRect absRect(r);
6087         absRect.move(offsetFromAncestor(root()));
6088 
6089         renderer().view().repaintViewRectangle(absRect);
6090     } else
6091         backing()-&gt;setContentsNeedDisplayInRect(r, shouldClip);
6092 }
6093 
6094 // Since we&#39;re only painting non-composited layers, we know that they all share the same repaintContainer.
6095 void RenderLayer::repaintIncludingNonCompositingDescendants(RenderLayerModelObject* repaintContainer)
6096 {
6097     renderer().repaintUsingContainer(repaintContainer, renderer().clippedOverflowRectForRepaint(repaintContainer));
6098 
6099     for (RenderLayer* curr = firstChild(); curr; curr = curr-&gt;nextSibling()) {
6100         if (!curr-&gt;isComposited())
6101             curr-&gt;repaintIncludingNonCompositingDescendants(repaintContainer);
6102     }
6103 }
6104 
6105 bool RenderLayer::shouldBeSelfPaintingLayer() const
6106 {
6107     if (!isNormalFlowOnly())
6108         return true;
6109 
6110     return hasOverlayScrollbars()
6111         || canUseCompositedScrolling()
6112         || renderer().isTableRow()
6113         || renderer().isCanvas()
6114         || renderer().isVideo()
6115         || renderer().isEmbeddedObject()
6116         || (renderer().isRenderImage() &amp;&amp; downcast&lt;RenderImage&gt;(renderer()).isEditableImage())
6117         || renderer().isRenderIFrame()
6118         || renderer().isInFlowRenderFragmentedFlow();
6119 }
6120 
6121 void RenderLayer::updateSelfPaintingLayer()
6122 {
6123     bool isSelfPaintingLayer = shouldBeSelfPaintingLayer();
6124     if (m_isSelfPaintingLayer == isSelfPaintingLayer)
6125         return;
6126 
6127     m_isSelfPaintingLayer = isSelfPaintingLayer;
6128     if (!parent())
6129         return;
6130     if (isSelfPaintingLayer)
6131         parent()-&gt;setAncestorChainHasSelfPaintingLayerDescendant();
6132     else
6133         parent()-&gt;dirtyAncestorChainHasSelfPaintingLayerDescendantStatus();
6134 }
6135 
6136 static bool hasVisibleBoxDecorationsOrBackground(const RenderElement&amp; renderer)
6137 {
6138     return renderer.hasVisibleBoxDecorations() || renderer.style().hasOutline();
6139 }
6140 
6141 static bool styleHasSmoothingTextMode(const RenderStyle&amp; style)
6142 {
6143     FontSmoothingMode smoothingMode = style.fontDescription().fontSmoothing();
6144     return smoothingMode == FontSmoothingMode::AutoSmoothing || smoothingMode == FontSmoothingMode::SubpixelAntialiased;
6145 }
6146 
6147 // Constrain the depth and breadth of the search for performance.
6148 static const unsigned maxRendererTraversalCount = 200;
6149 
6150 static void determineNonLayerDescendantsPaintedContent(const RenderElement&amp; renderer, unsigned&amp; renderersTraversed, RenderLayer::PaintedContentRequest&amp; request)
6151 {
6152     for (const auto&amp; child : childrenOfType&lt;RenderObject&gt;(renderer)) {
6153         if (++renderersTraversed &gt; maxRendererTraversalCount) {
6154             request.makeStatesUndetermined();
6155             return;
6156         }
6157 
6158         if (is&lt;RenderText&gt;(child)) {
6159             const auto&amp; renderText = downcast&lt;RenderText&gt;(child);
6160             if (renderText.linesBoundingBox().isEmpty())
6161                 continue;
6162 
6163             if (renderer.style().userSelect() != UserSelect::None)
6164                 request.setHasPaintedContent();
6165 
6166             if (!renderText.text().isAllSpecialCharacters&lt;isHTMLSpace&gt;()) {
6167                 request.setHasPaintedContent();
6168 
6169                 if (request.needToDetermineSubpixelAntialiasedTextState() &amp;&amp; styleHasSmoothingTextMode(child.style()))
6170                     request.setHasSubpixelAntialiasedText();
6171             }
6172 
6173             if (request.isSatisfied())
6174                 return;
6175         }
6176 
6177         if (!is&lt;RenderElement&gt;(child))
6178             continue;
6179 
6180         const RenderElement&amp; renderElementChild = downcast&lt;RenderElement&gt;(child);
6181 
6182         if (is&lt;RenderLayerModelObject&gt;(renderElementChild) &amp;&amp; downcast&lt;RenderLayerModelObject&gt;(renderElementChild).hasSelfPaintingLayer())
6183             continue;
6184 
6185         if (hasVisibleBoxDecorationsOrBackground(renderElementChild)) {
6186             request.setHasPaintedContent();
6187             if (request.isSatisfied())
6188                 return;
6189         }
6190 
6191         if (is&lt;RenderReplaced&gt;(renderElementChild)) {
6192             request.setHasPaintedContent();
6193 
6194             if (is&lt;RenderImage&gt;(renderElementChild) &amp;&amp; request.needToDetermineSubpixelAntialiasedTextState()) {
6195                 auto&amp; imageRenderer = downcast&lt;RenderImage&gt;(renderElementChild);
6196                 // May draw text if showing alt text, or image is an SVG image or PDF image.
6197                 if ((imageRenderer.isShowingAltText() || imageRenderer.hasNonBitmapImage()) &amp;&amp; styleHasSmoothingTextMode(child.style()))
6198                     request.setHasSubpixelAntialiasedText();
6199             }
6200 
6201             if (request.isSatisfied())
6202                 return;
6203         }
6204 
6205         determineNonLayerDescendantsPaintedContent(renderElementChild, renderersTraversed, request);
6206         if (request.isSatisfied())
6207             return;
6208     }
6209 }
6210 
6211 bool RenderLayer::hasNonEmptyChildRenderers(PaintedContentRequest&amp; request) const
6212 {
6213     unsigned renderersTraversed = 0;
6214     determineNonLayerDescendantsPaintedContent(renderer(), renderersTraversed, request);
6215     return request.probablyHasPaintedContent();
6216 }
6217 
6218 bool RenderLayer::hasVisibleBoxDecorationsOrBackground() const
6219 {
6220     return WebCore::hasVisibleBoxDecorationsOrBackground(renderer());
6221 }
6222 
6223 bool RenderLayer::hasVisibleBoxDecorations() const
6224 {
6225     if (!hasVisibleContent())
6226         return false;
6227 
6228     return hasVisibleBoxDecorationsOrBackground() || hasOverflowControls();
6229 }
6230 
6231 bool RenderLayer::isVisuallyNonEmpty(PaintedContentRequest* request) const
6232 {
6233     ASSERT(!m_visibleDescendantStatusDirty);
6234 
6235     if (!hasVisibleContent() || !renderer().style().opacity())
6236         return false;
6237 
6238     if (renderer().isRenderReplaced() || hasOverflowControls()) {
6239         if (!request)
6240             return true;
6241 
6242         request-&gt;setHasPaintedContent();
6243         if (request-&gt;isSatisfied())
6244             return true;
6245     }
6246 
6247     if (hasVisibleBoxDecorationsOrBackground()) {
6248         if (!request)
6249             return true;
6250 
6251         request-&gt;setHasPaintedContent();
6252         if (request-&gt;isSatisfied())
6253             return true;
6254     }
6255 
6256     PaintedContentRequest localRequest;
6257     if (!request)
6258         request = &amp;localRequest;
6259 
6260     return hasNonEmptyChildRenderers(*request);
6261 }
6262 
6263 void RenderLayer::updateScrollbarsAfterStyleChange(const RenderStyle* oldStyle)
6264 {
6265     // Overflow are a box concept.
6266     RenderBox* box = renderBox();
6267     if (!box)
6268         return;
6269 
6270     // List box parts handle the scrollbars by themselves so we have nothing to do.
6271     if (box-&gt;style().appearance() == ListboxPart)
6272         return;
6273 
6274     Overflow overflowX = box-&gt;style().overflowX();
6275     Overflow overflowY = box-&gt;style().overflowY();
6276 
6277     // To avoid doing a relayout in updateScrollbarsAfterLayout, we try to keep any automatic scrollbar that was already present.
6278     bool needsHorizontalScrollbar = box-&gt;hasOverflowClip() &amp;&amp; ((hasHorizontalScrollbar() &amp;&amp; styleDefinesAutomaticScrollbar(box-&gt;style(), HorizontalScrollbar)) || styleRequiresScrollbar(box-&gt;style(), HorizontalScrollbar));
6279     bool needsVerticalScrollbar = box-&gt;hasOverflowClip() &amp;&amp; ((hasVerticalScrollbar() &amp;&amp; styleDefinesAutomaticScrollbar(box-&gt;style(), VerticalScrollbar)) || styleRequiresScrollbar(box-&gt;style(), VerticalScrollbar));
6280     setHasHorizontalScrollbar(needsHorizontalScrollbar);
6281     setHasVerticalScrollbar(needsVerticalScrollbar);
6282 
6283     // With non-overlay overflow:scroll, scrollbars are always visible but may be disabled.
6284     // When switching to another value, we need to re-enable them (see bug 11985).
6285     if (m_hBar &amp;&amp; needsHorizontalScrollbar &amp;&amp; oldStyle &amp;&amp; oldStyle-&gt;overflowX() == Overflow::Scroll &amp;&amp; overflowX != Overflow::Scroll)
6286         m_hBar-&gt;setEnabled(true);
6287 
6288     if (m_vBar &amp;&amp; needsVerticalScrollbar &amp;&amp; oldStyle &amp;&amp; oldStyle-&gt;overflowY() == Overflow::Scroll &amp;&amp; overflowY != Overflow::Scroll)
6289         m_vBar-&gt;setEnabled(true);
6290 
6291     if (!m_scrollDimensionsDirty)
6292         updateScrollableAreaSet(hasScrollableHorizontalOverflow() || hasScrollableVerticalOverflow());
6293 }
6294 
6295 void RenderLayer::styleChanged(StyleDifference diff, const RenderStyle* oldStyle)
6296 {
6297     setIsNormalFlowOnly(shouldBeNormalFlowOnly());
6298 
6299     if (setIsStackingContext(shouldBeStackingContext())) {
6300 #if ENABLE(CSS_COMPOSITING)
6301         if (parent()) {
6302             if (isStackingContext()) {
6303                 if (!hasNotIsolatedBlendingDescendantsStatusDirty() &amp;&amp; hasNotIsolatedBlendingDescendants())
6304                     parent()-&gt;dirtyAncestorChainHasBlendingDescendants();
6305             } else {
6306                 if (hasNotIsolatedBlendingDescendantsStatusDirty())
6307                     parent()-&gt;dirtyAncestorChainHasBlendingDescendants();
6308                 else if (hasNotIsolatedBlendingDescendants())
6309                     parent()-&gt;updateAncestorChainHasBlendingDescendants();
6310             }
6311         }
6312 #endif
6313     }
6314 
6315     // FIXME: RenderLayer already handles visibility changes through our visiblity dirty bits. This logic could
6316     // likely be folded along with the rest.
6317     if (oldStyle) {
6318         if (oldStyle-&gt;zIndex() != renderer().style().zIndex() || oldStyle-&gt;visibility() != renderer().style().visibility()) {
6319             dirtyStackingContextZOrderLists();
6320             if (isStackingContext())
6321                 dirtyZOrderLists();
6322         }
6323     }
6324 
6325     if (renderer().isHTMLMarquee() &amp;&amp; renderer().style().marqueeBehavior() != MarqueeBehavior::None &amp;&amp; renderer().isBox()) {
6326         if (!m_marquee)
6327             m_marquee = std::make_unique&lt;RenderMarquee&gt;(this);
6328         m_marquee-&gt;updateMarqueeStyle();
6329     } else if (m_marquee)
6330         m_marquee = nullptr;
6331 
6332     updateScrollbarsAfterStyleChange(oldStyle);
6333     // Overlay scrollbars can make this layer self-painting so we need
6334     // to recompute the bit once scrollbars have been updated.
6335     updateSelfPaintingLayer();
6336 
6337     if (!hasReflection() &amp;&amp; m_reflection)
6338         removeReflection();
6339     else if (hasReflection()) {
6340         if (!m_reflection)
6341             createReflection();
6342         else
6343             m_reflection-&gt;setStyle(createReflectionStyle());
6344     }
6345 
6346     // FIXME: Need to detect a swap from custom to native scrollbars (and vice versa).
6347     if (m_hBar)
6348         m_hBar-&gt;styleChanged();
6349     if (m_vBar)
6350         m_vBar-&gt;styleChanged();
6351 
6352     updateScrollCornerStyle();
6353     updateResizerStyle();
6354 
6355     updateDescendantDependentFlags();
6356     updateTransform();
6357 #if ENABLE(CSS_COMPOSITING)
6358     updateBlendMode();
6359 #endif
6360     updateFiltersAfterStyleChange();
6361 
6362     compositor().layerStyleChanged(diff, *this, oldStyle);
6363 
6364     updateFilterPaintingStrategy();
6365 
6366 #if PLATFORM(IOS_FAMILY) &amp;&amp; ENABLE(TOUCH_EVENTS)
6367     if (diff == StyleDifference::RecompositeLayer || diff &gt;= StyleDifference::LayoutPositionedMovementOnly)
6368         renderer().document().invalidateRenderingDependentRegions();
6369 #else
6370     UNUSED_PARAM(diff);
6371 #endif
6372 }
6373 
6374 void RenderLayer::updateScrollableAreaSet(bool hasOverflow)
6375 {
6376     FrameView&amp; frameView = renderer().view().frameView();
6377 
6378     bool isVisibleToHitTest = renderer().visibleToHitTesting();
6379     if (HTMLFrameOwnerElement* owner = frameView.frame().ownerElement())
6380         isVisibleToHitTest &amp;= owner-&gt;renderer() &amp;&amp; owner-&gt;renderer()-&gt;visibleToHitTesting();
6381 
6382     bool isScrollable = hasOverflow &amp;&amp; isVisibleToHitTest;
6383     bool addedOrRemoved = false;
6384 
6385     ASSERT(m_registeredScrollableArea == frameView.containsScrollableArea(this));
6386 
6387     if (isScrollable) {
6388         if (!m_registeredScrollableArea) {
6389             addedOrRemoved = frameView.addScrollableArea(this);
6390             m_registeredScrollableArea = true;
6391         }
6392     } else if (m_registeredScrollableArea) {
6393         addedOrRemoved = frameView.removeScrollableArea(this);
6394         m_registeredScrollableArea = false;
6395     }
6396 
6397 #if ENABLE(IOS_TOUCH_EVENTS)
6398     if (addedOrRemoved) {
6399         if (isScrollable &amp;&amp; !canUseCompositedScrolling())
6400             registerAsTouchEventListenerForScrolling();
6401         else {
6402             // We only need the touch listener for unaccelerated overflow scrolling, so if we became
6403             // accelerated, remove ourselves as a touch event listener.
6404             unregisterAsTouchEventListenerForScrolling();
6405         }
6406     }
6407 #else
6408     UNUSED_VARIABLE(addedOrRemoved);
6409 #endif
6410 }
6411 
6412 void RenderLayer::updateScrollCornerStyle()
6413 {
6414     RenderElement* actualRenderer = rendererForScrollbar(renderer());
6415     auto corner = renderer().hasOverflowClip() ? actualRenderer-&gt;getUncachedPseudoStyle(PseudoStyleRequest(PseudoId::ScrollbarCorner), &amp;actualRenderer-&gt;style()) : nullptr;
6416 
6417     if (!corner) {
6418         clearScrollCorner();
6419         return;
6420     }
6421 
6422     if (!m_scrollCorner) {
6423         m_scrollCorner = createRenderer&lt;RenderScrollbarPart&gt;(renderer().document(), WTFMove(*corner));
6424         // FIXME: A renderer should be a child of its parent!
6425         m_scrollCorner-&gt;setParent(&amp;renderer());
6426         m_scrollCorner-&gt;initializeStyle();
6427     } else
6428         m_scrollCorner-&gt;setStyle(WTFMove(*corner));
6429 }
6430 
6431 void RenderLayer::clearScrollCorner()
6432 {
6433     if (!m_scrollCorner)
6434         return;
6435     m_scrollCorner-&gt;setParent(nullptr);
6436     m_scrollCorner = nullptr;
6437 }
6438 
6439 void RenderLayer::updateResizerStyle()
6440 {
6441     RenderElement* actualRenderer = rendererForScrollbar(renderer());
6442     auto resizer = renderer().hasOverflowClip() ? actualRenderer-&gt;getUncachedPseudoStyle(PseudoStyleRequest(PseudoId::Resizer), &amp;actualRenderer-&gt;style()) : nullptr;
6443 
6444     if (!resizer) {
6445         clearResizer();
6446         return;
6447     }
6448 
6449     if (!m_resizer) {
6450         m_resizer = createRenderer&lt;RenderScrollbarPart&gt;(renderer().document(), WTFMove(*resizer));
6451         // FIXME: A renderer should be a child of its parent!
6452         m_resizer-&gt;setParent(&amp;renderer());
6453         m_resizer-&gt;initializeStyle();
6454     } else
6455         m_resizer-&gt;setStyle(WTFMove(*resizer));
6456 }
6457 
6458 void RenderLayer::clearResizer()
6459 {
6460     if (!m_resizer)
6461         return;
6462     m_resizer-&gt;setParent(nullptr);
6463     m_resizer = nullptr;
6464 }
6465 
6466 RenderLayer* RenderLayer::reflectionLayer() const
6467 {
6468     return m_reflection ? m_reflection-&gt;layer() : nullptr;
6469 }
6470 
6471 bool RenderLayer::isReflectionLayer(const RenderLayer&amp; layer) const
6472 {
6473     return m_reflection ? &amp;layer == m_reflection-&gt;layer() : false;
6474 }
6475 
6476 void RenderLayer::createReflection()
6477 {
6478     ASSERT(!m_reflection);
6479     m_reflection = createRenderer&lt;RenderReplica&gt;(renderer().document(), createReflectionStyle());
6480     // FIXME: A renderer should be a child of its parent!
6481     m_reflection-&gt;setParent(&amp;renderer()); // We create a 1-way connection.
6482     m_reflection-&gt;initializeStyle();
6483 }
6484 
6485 void RenderLayer::removeReflection()
6486 {
6487     if (!m_reflection-&gt;renderTreeBeingDestroyed())
6488         m_reflection-&gt;removeLayers(this);
6489 
6490     m_reflection-&gt;setParent(nullptr);
6491     m_reflection = nullptr;
6492 }
6493 
6494 RenderStyle RenderLayer::createReflectionStyle()
6495 {
6496     auto newStyle = RenderStyle::create();
6497     newStyle.inheritFrom(renderer().style());
6498 
6499     // Map in our transform.
6500     TransformOperations transform;
6501     switch (renderer().style().boxReflect()-&gt;direction()) {
6502         case ReflectionBelow:
6503             transform.operations().append(TranslateTransformOperation::create(Length(0, Fixed), Length(100., Percent), TransformOperation::TRANSLATE));
6504             transform.operations().append(TranslateTransformOperation::create(Length(0, Fixed), renderer().style().boxReflect()-&gt;offset(), TransformOperation::TRANSLATE));
6505             transform.operations().append(ScaleTransformOperation::create(1.0, -1.0, ScaleTransformOperation::SCALE));
6506             break;
6507         case ReflectionAbove:
6508             transform.operations().append(ScaleTransformOperation::create(1.0, -1.0, ScaleTransformOperation::SCALE));
6509             transform.operations().append(TranslateTransformOperation::create(Length(0, Fixed), Length(100., Percent), TransformOperation::TRANSLATE));
6510             transform.operations().append(TranslateTransformOperation::create(Length(0, Fixed), renderer().style().boxReflect()-&gt;offset(), TransformOperation::TRANSLATE));
6511             break;
6512         case ReflectionRight:
6513             transform.operations().append(TranslateTransformOperation::create(Length(100., Percent), Length(0, Fixed), TransformOperation::TRANSLATE));
6514             transform.operations().append(TranslateTransformOperation::create(renderer().style().boxReflect()-&gt;offset(), Length(0, Fixed), TransformOperation::TRANSLATE));
6515             transform.operations().append(ScaleTransformOperation::create(-1.0, 1.0, ScaleTransformOperation::SCALE));
6516             break;
6517         case ReflectionLeft:
6518             transform.operations().append(ScaleTransformOperation::create(-1.0, 1.0, ScaleTransformOperation::SCALE));
6519             transform.operations().append(TranslateTransformOperation::create(Length(100., Percent), Length(0, Fixed), TransformOperation::TRANSLATE));
6520             transform.operations().append(TranslateTransformOperation::create(renderer().style().boxReflect()-&gt;offset(), Length(0, Fixed), TransformOperation::TRANSLATE));
6521             break;
6522     }
6523     newStyle.setTransform(transform);
6524 
6525     // Map in our mask.
6526     newStyle.setMaskBoxImage(renderer().style().boxReflect()-&gt;mask());
6527 
6528     // Style has transform and mask, so needs to be stacking context.
6529     newStyle.setZIndex(0);
6530 
6531     return newStyle;
6532 }
6533 
6534 void RenderLayer::ensureLayerFilters()
6535 {
6536     if (m_filters)
6537         return;
6538 
6539     m_filters = std::make_unique&lt;RenderLayerFilters&gt;(*this);
6540 }
6541 
6542 void RenderLayer::clearLayerFilters()
6543 {
6544     m_filters = nullptr;
6545 }
6546 
6547 void RenderLayer::updateFiltersAfterStyleChange()
6548 {
6549     if (!hasFilter()) {
6550         clearLayerFilters();
6551         return;
6552     }
6553 
6554     // Add the filter as a client to this renderer, unless we are a RenderLayer accommodating
6555     // an SVG. In that case it takes care of its own resource management for filters.
6556     if (renderer().style().filter().hasReferenceFilter() &amp;&amp; !renderer().isSVGRoot()) {
6557         ensureLayerFilters();
6558         m_filters-&gt;updateReferenceFilterClients(renderer().style().filter());
6559     } else if (m_filters)
6560         m_filters-&gt;removeReferenceFilterClients();
6561 }
6562 
6563 void RenderLayer::updateFilterPaintingStrategy()
6564 {
6565     // RenderLayerFilters is only used to render the filters in software mode,
6566     // so we always need to run updateFilterPaintingStrategy() after the composited
6567     // mode might have changed for this layer.
6568     if (!paintsWithFilters()) {
6569         // Don&#39;t delete the whole filter info here, because we might use it
6570         // for loading SVG reference filter files.
6571         if (m_filters)
6572             m_filters-&gt;setFilter(nullptr);
6573 
6574         // Early-return only if we *don&#39;t* have reference filters.
6575         // For reference filters, we still want the FilterEffect graph built
6576         // for us, even if we&#39;re composited.
6577         if (!renderer().style().filter().hasReferenceFilter())
6578             return;
6579     }
6580 
6581     ensureLayerFilters();
6582     m_filters-&gt;buildFilter(renderer(), page().deviceScaleFactor(), renderer().settings().acceleratedFiltersEnabled() ? Accelerated : Unaccelerated);
6583 }
6584 
6585 void RenderLayer::filterNeedsRepaint()
6586 {
6587     // We use the enclosing element so that we recalculate style for the ancestor of an anonymous object.
6588     if (Element* element = enclosingElement()) {
6589         // FIXME: This really shouldn&#39;t have to invalidate layer composition, but tests like css3/filters/effect-reference-delete.html fail if that doesn&#39;t happen.
6590         element-&gt;invalidateStyleAndLayerComposition();
6591     }
6592     renderer().repaint();
6593 }
6594 
6595 TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const RenderLayer&amp; layer)
6596 {
6597     ts &lt;&lt; &quot;RenderLayer &quot; &lt;&lt; &amp;layer &lt;&lt; &quot; &quot; &lt;&lt; layer.size();
6598     if (layer.transform())
6599         ts &lt;&lt; &quot; has transform&quot;;
6600     if (layer.hasFilter())
6601         ts &lt;&lt; &quot; has filter&quot;;
6602     if (layer.hasBackdropFilter())
6603         ts &lt;&lt; &quot; has backdrop filter&quot;;
6604     if (layer.hasBlendMode())
6605         ts &lt;&lt; &quot; has blend mode&quot;;
6606     if (layer.isolatesBlending())
6607         ts &lt;&lt; &quot; isolates blending&quot;;
6608     if (layer.isComposited())
6609         ts &lt;&lt; &quot; &quot; &lt;&lt; *layer.backing();
6610     return ts;
6611 }
6612 
6613 } // namespace WebCore
6614 
6615 #if ENABLE(TREE_DEBUGGING)
6616 
6617 void showLayerTree(const WebCore::RenderLayer* layer)
6618 {
6619     if (!layer)
6620         return;
6621 
6622     WTF::String output = externalRepresentation(&amp;layer-&gt;renderer().frame(), WebCore::RenderAsTextShowAllLayers | WebCore::RenderAsTextShowLayerNesting | WebCore::RenderAsTextShowCompositedLayers | WebCore::RenderAsTextShowAddresses | WebCore::RenderAsTextShowIDAndClass | WebCore::RenderAsTextDontUpdateLayout | WebCore::RenderAsTextShowLayoutState | WebCore::RenderAsTextShowOverflow | WebCore::RenderAsTextShowSVGGeometry | WebCore::RenderAsTextShowLayerFragments);
6623     fprintf(stderr, &quot;\n%s\n&quot;, output.utf8().data());
6624 }
6625 
6626 void showLayerTree(const WebCore::RenderObject* renderer)
6627 {
6628     if (!renderer)
6629         return;
6630     showLayerTree(renderer-&gt;enclosingLayer());
6631 }
6632 
6633 static void outputPaintOrderTreeLegend(TextStream&amp; stream)
6634 {
6635     stream.nextLine();
6636     stream &lt;&lt; &quot;(S)tacking Context, (N)ormal flow only, (O)verflow clip, (A)lpha (opacity or mask), has (B)lend mode, (I)solates blending, (T)ransform-ish, (F)ilter, Fi(X)ed position, (C)omposited, (c)omposited descendant\n&quot;
6637         &quot;Dirty (z)-lists, Dirty (n)ormal flow lists\n&quot;
6638         &quot;Traversal needs: requirements (t)raversal on descendants, (b)acking or hierarchy traversal on descendants, (r)equirements traversal on all descendants, requirements traversal on all (s)ubsequent layers, (h)ierarchy traversal on all descendants, update of paint (o)rder children\n&quot;
6639         &quot;Update needs:    post-(l)ayout requirements, (g)eometry, (k)ids geometry, (c)onfig, layer conne(x)ion, (s)crolling tree\n&quot;;
6640     stream.nextLine();
6641 }
6642 
6643 static void outputIdent(TextStream&amp; stream, unsigned depth)
6644 {
6645     unsigned i = 0;
6646     while (++i &lt;= depth * 2)
6647         stream &lt;&lt; &quot; &quot;;
6648 }
6649 
6650 static void outputPaintOrderTreeRecursive(TextStream&amp; stream, const WebCore::RenderLayer&amp; layer, const char* prefix, unsigned depth = 0)
6651 {
6652     stream &lt;&lt; (layer.isStackingContext() ? &quot;S&quot; : &quot;-&quot;);
6653     stream &lt;&lt; (layer.isNormalFlowOnly() ? &quot;N&quot; : &quot;-&quot;);
6654     stream &lt;&lt; (layer.renderer().hasOverflowClip() ? &quot;O&quot; : &quot;-&quot;);
6655     stream &lt;&lt; (layer.isTransparent() ? &quot;A&quot; : &quot;-&quot;);
6656     stream &lt;&lt; (layer.hasBlendMode() ? &quot;B&quot; : &quot;-&quot;);
6657     stream &lt;&lt; (layer.isolatesBlending() ? &quot;I&quot; : &quot;-&quot;);
6658     stream &lt;&lt; (layer.renderer().hasTransformRelatedProperty() ? &quot;T&quot; : &quot;-&quot;);
6659     stream &lt;&lt; (layer.hasFilter() ? &quot;F&quot; : &quot;-&quot;);
6660     stream &lt;&lt; (layer.renderer().isFixedPositioned() ? &quot;X&quot; : &quot;-&quot;);
6661     stream &lt;&lt; (layer.isComposited() ? &quot;C&quot; : &quot;-&quot;);
6662     stream &lt;&lt; (layer.hasCompositingDescendant() ? &quot;c&quot; : &quot;-&quot;);
6663 
6664     stream &lt;&lt; &quot; &quot;;
6665 
6666     stream &lt;&lt; (layer.zOrderListsDirty() ? &quot;z&quot; : &quot;-&quot;);
6667     stream &lt;&lt; (layer.normalFlowListDirty() ? &quot;n&quot; : &quot;-&quot;);
6668 
6669     stream &lt;&lt; &quot; &quot;;
6670 
6671     stream &lt;&lt; (layer.hasDescendantNeedingCompositingRequirementsTraversal() ? &quot;t&quot; : &quot;-&quot;);
6672     stream &lt;&lt; (layer.hasDescendantNeedingUpdateBackingOrHierarchyTraversal() ? &quot;b&quot; : &quot;-&quot;);
6673     stream &lt;&lt; (layer.descendantsNeedCompositingRequirementsTraversal() ? &quot;r&quot; : &quot;-&quot;);
6674     stream &lt;&lt; (layer.subsequentLayersNeedCompositingRequirementsTraversal() ? &quot;s&quot; : &quot;-&quot;);
6675     stream &lt;&lt; (layer.descendantsNeedUpdateBackingAndHierarchyTraversal() ? &quot;h&quot; : &quot;-&quot;);
6676     stream &lt;&lt; (layer.needsCompositingPaintOrderChildrenUpdate() ? &quot;o&quot; : &quot;-&quot;);
6677 
6678     stream &lt;&lt; &quot; &quot;;
6679 
6680     stream &lt;&lt; (layer.needsPostLayoutCompositingUpdate() ? &quot;l&quot; : &quot;-&quot;);
6681     stream &lt;&lt; (layer.needsCompositingGeometryUpdate() ? &quot;g&quot; : &quot;-&quot;);
6682     stream &lt;&lt; (layer.childrenNeedCompositingGeometryUpdate() ? &quot;k&quot; : &quot;-&quot;);
6683     stream &lt;&lt; (layer.needsCompositingConfigurationUpdate() ? &quot;c&quot; : &quot;-&quot;);
6684     stream &lt;&lt; (layer.needsCompositingLayerConnection() ? &quot;x&quot; : &quot;-&quot;);
6685     stream &lt;&lt; (layer.needsScrollingTreeUpdate() ? &quot;s&quot; : &quot;-&quot;);
6686 
6687     stream &lt;&lt; &quot; &quot;;
6688 
6689     outputIdent(stream, depth);
6690 
6691     stream &lt;&lt; prefix;
6692 
6693     auto layerRect = layer.rect();
6694 
6695     stream &lt;&lt; &amp;layer &lt;&lt; &quot; &quot; &lt;&lt; layerRect;
6696     if (layer.isComposited()) {
6697         auto&amp; backing = *layer.backing();
6698         stream &lt;&lt; &quot; (layerID &quot; &lt;&lt; backing.graphicsLayer()-&gt;primaryLayerID() &lt;&lt; &quot;)&quot;;
6699 
6700         auto scrollingNodeID = backing.scrollingNodeIDForRole(WebCore::ScrollCoordinationRole::Scrolling);
6701         auto frameHostingNodeID = backing.scrollingNodeIDForRole(WebCore::ScrollCoordinationRole::FrameHosting);
6702         auto viewportConstrainedNodeID = backing.scrollingNodeIDForRole(WebCore::ScrollCoordinationRole::ViewportConstrained);
6703 
6704         if (scrollingNodeID || frameHostingNodeID || viewportConstrainedNodeID) {
6705             stream &lt;&lt; &quot; {&quot;;
6706             bool first = true;
6707             if (scrollingNodeID) {
6708                 stream &lt;&lt; &quot;sc &quot; &lt;&lt; scrollingNodeID;
6709                 first = false;
6710             }
6711 
6712             if (frameHostingNodeID) {
6713                 if (!first)
6714                     stream &lt;&lt; &quot;, &quot;;
6715                 stream &lt;&lt; &quot;fh &quot; &lt;&lt; frameHostingNodeID;
6716                 first = false;
6717             }
6718 
6719             if (viewportConstrainedNodeID) {
6720                 if (!first)
6721                     stream &lt;&lt; &quot;, &quot;;
6722                 stream &lt;&lt; &quot;vc &quot; &lt;&lt; viewportConstrainedNodeID;
6723             }
6724 
6725             stream &lt;&lt; &quot;}&quot;;
6726         }
6727     }
6728     stream &lt;&lt; &quot; &quot; &lt;&lt; layer.name();
6729     stream.nextLine();
6730 
6731     const_cast&lt;WebCore::RenderLayer&amp;&gt;(layer).updateLayerListsIfNeeded();
6732 
6733     for (auto* child : layer.negativeZOrderLayers())
6734         outputPaintOrderTreeRecursive(stream, *child, &quot;- &quot;, depth + 1);
6735 
6736     for (auto* child : layer.normalFlowLayers())
6737         outputPaintOrderTreeRecursive(stream, *child, &quot;n &quot;, depth + 1);
6738 
6739     for (auto* child : layer.positiveZOrderLayers())
6740         outputPaintOrderTreeRecursive(stream, *child, &quot;+ &quot;, depth + 1);
6741 }
6742 
6743 void showPaintOrderTree(const WebCore::RenderLayer* layer)
6744 {
6745     TextStream stream;
6746     outputPaintOrderTreeLegend(stream);
6747     if (layer)
6748         outputPaintOrderTreeRecursive(stream, *layer, &quot;&quot;);
6749 
6750     WTFLogAlways(&quot;%s&quot;, stream.release().utf8().data());
6751 }
6752 
6753 #endif
    </pre>
  </body>
</html>