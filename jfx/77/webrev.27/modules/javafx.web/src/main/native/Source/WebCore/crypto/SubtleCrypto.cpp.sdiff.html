<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/crypto/SubtleCrypto.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="CommonCryptoUtilities.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="gcrypt/CryptoAlgorithmHMACGCrypt.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/crypto/SubtleCrypto.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (C) 2016 Apple Inc. All rights reserved.</span>
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  * 1. Redistributions of source code must retain the above copyright
   8  *    notice, this list of conditions and the following disclaimer.
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
  14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
  15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
  17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
</pre>
<hr />
<pre>
  78     GetKeyLength
  79 };
  80 
  81 static ExceptionOr&lt;std::unique_ptr&lt;CryptoAlgorithmParameters&gt;&gt; normalizeCryptoAlgorithmParameters(ExecState&amp;, WebCore::SubtleCrypto::AlgorithmIdentifier, Operations);
  82 
  83 static ExceptionOr&lt;CryptoAlgorithmIdentifier&gt; toHashIdentifier(ExecState&amp; state, SubtleCrypto::AlgorithmIdentifier algorithmIdentifier)
  84 {
  85     auto digestParams = normalizeCryptoAlgorithmParameters(state, algorithmIdentifier, Operations::Digest);
  86     if (digestParams.hasException())
  87         return digestParams.releaseException();
  88     return digestParams.returnValue()-&gt;identifier;
  89 }
  90 
  91 static ExceptionOr&lt;std::unique_ptr&lt;CryptoAlgorithmParameters&gt;&gt; normalizeCryptoAlgorithmParameters(ExecState&amp; state, SubtleCrypto::AlgorithmIdentifier algorithmIdentifier, Operations operation)
  92 {
  93     VM&amp; vm = state.vm();
  94     auto scope = DECLARE_THROW_SCOPE(vm);
  95 
  96     if (WTF::holds_alternative&lt;String&gt;(algorithmIdentifier)) {
  97         auto newParams = Strong&lt;JSObject&gt;(vm, constructEmptyObject(&amp;state));
<span class="line-modified">  98         newParams-&gt;putDirect(vm, Identifier::fromString(&amp;vm, &quot;name&quot;), jsString(&amp;state, WTF::get&lt;String&gt;(algorithmIdentifier)));</span>
  99 
 100         return normalizeCryptoAlgorithmParameters(state, newParams, operation);
 101     }
 102 
 103     auto&amp; value = WTF::get&lt;JSC::Strong&lt;JSC::JSObject&gt;&gt;(algorithmIdentifier);
 104 
 105     auto params = convertDictionary&lt;CryptoAlgorithmParameters&gt;(state, value.get());
 106     RETURN_IF_EXCEPTION(scope, Exception { ExistingExceptionError });
 107 
 108     auto identifier = CryptoAlgorithmRegistry::singleton().identifier(params.name);
 109     if (UNLIKELY(!identifier))
 110         return Exception { NotSupportedError };
 111 
 112     std::unique_ptr&lt;CryptoAlgorithmParameters&gt; result;
 113     switch (operation) {
 114     case Operations::Encrypt:
 115     case Operations::Decrypt:
 116         switch (*identifier) {
 117         case CryptoAlgorithmIdentifier::RSAES_PKCS1_v1_5:
<span class="line-modified"> 118             result = std::make_unique&lt;CryptoAlgorithmParameters&gt;(params);</span>
 119             break;
 120         case CryptoAlgorithmIdentifier::RSA_OAEP: {
 121             auto params = convertDictionary&lt;CryptoAlgorithmRsaOaepParams&gt;(state, value.get());
 122             RETURN_IF_EXCEPTION(scope, Exception { ExistingExceptionError });
<span class="line-modified"> 123             result = std::make_unique&lt;CryptoAlgorithmRsaOaepParams&gt;(params);</span>
 124             break;
 125         }
 126         case CryptoAlgorithmIdentifier::AES_CBC:
 127         case CryptoAlgorithmIdentifier::AES_CFB: {
 128             auto params = convertDictionary&lt;CryptoAlgorithmAesCbcCfbParams&gt;(state, value.get());
 129             RETURN_IF_EXCEPTION(scope, Exception { ExistingExceptionError });
<span class="line-modified"> 130             result = std::make_unique&lt;CryptoAlgorithmAesCbcCfbParams&gt;(params);</span>
 131             break;
 132         }
 133         case CryptoAlgorithmIdentifier::AES_CTR: {
 134             auto params = convertDictionary&lt;CryptoAlgorithmAesCtrParams&gt;(state, value.get());
 135             RETURN_IF_EXCEPTION(scope, Exception { ExistingExceptionError });
<span class="line-modified"> 136             result = std::make_unique&lt;CryptoAlgorithmAesCtrParams&gt;(params);</span>
 137             break;
 138         }
 139         case CryptoAlgorithmIdentifier::AES_GCM: {
 140             auto params = convertDictionary&lt;CryptoAlgorithmAesGcmParams&gt;(state, value.get());
 141             RETURN_IF_EXCEPTION(scope, Exception { ExistingExceptionError });
<span class="line-modified"> 142             result = std::make_unique&lt;CryptoAlgorithmAesGcmParams&gt;(params);</span>
 143             break;
 144         }
 145         default:
 146             return Exception { NotSupportedError };
 147         }
 148         break;
 149     case Operations::Sign:
 150     case Operations::Verify:
 151         switch (*identifier) {
 152         case CryptoAlgorithmIdentifier::RSASSA_PKCS1_v1_5:
 153         case CryptoAlgorithmIdentifier::HMAC:
<span class="line-modified"> 154             result = std::make_unique&lt;CryptoAlgorithmParameters&gt;(params);</span>
 155             break;
 156         case CryptoAlgorithmIdentifier::ECDSA: {
 157             auto params = convertDictionary&lt;CryptoAlgorithmEcdsaParams&gt;(state, value.get());
 158             RETURN_IF_EXCEPTION(scope, Exception { ExistingExceptionError });
 159             auto hashIdentifier = toHashIdentifier(state, params.hash);
 160             if (hashIdentifier.hasException())
 161                 return hashIdentifier.releaseException();
 162             params.hashIdentifier = hashIdentifier.releaseReturnValue();
<span class="line-modified"> 163             result = std::make_unique&lt;CryptoAlgorithmEcdsaParams&gt;(params);</span>
 164             break;
 165         }
 166         case CryptoAlgorithmIdentifier::RSA_PSS: {
 167             auto params = convertDictionary&lt;CryptoAlgorithmRsaPssParams&gt;(state, value.get());
 168             RETURN_IF_EXCEPTION(scope, Exception { ExistingExceptionError });
<span class="line-modified"> 169             result = std::make_unique&lt;CryptoAlgorithmRsaPssParams&gt;(params);</span>
 170             break;
 171         }
 172         default:
 173             return Exception { NotSupportedError };
 174         }
 175         break;
 176     case Operations::Digest:
 177         switch (*identifier) {
 178         case CryptoAlgorithmIdentifier::SHA_1:
 179         case CryptoAlgorithmIdentifier::SHA_224:
 180         case CryptoAlgorithmIdentifier::SHA_256:
 181         case CryptoAlgorithmIdentifier::SHA_384:
 182         case CryptoAlgorithmIdentifier::SHA_512:
<span class="line-modified"> 183             result = std::make_unique&lt;CryptoAlgorithmParameters&gt;(params);</span>
 184             break;
 185         default:
 186             return Exception { NotSupportedError };
 187         }
 188         break;
 189     case Operations::GenerateKey:
 190         switch (*identifier) {
 191         case CryptoAlgorithmIdentifier::RSAES_PKCS1_v1_5: {
 192             auto params = convertDictionary&lt;CryptoAlgorithmRsaKeyGenParams&gt;(state, value.get());
 193             RETURN_IF_EXCEPTION(scope, Exception { ExistingExceptionError });
<span class="line-modified"> 194             result = std::make_unique&lt;CryptoAlgorithmRsaKeyGenParams&gt;(params);</span>
 195             break;
 196         }
 197         case CryptoAlgorithmIdentifier::RSASSA_PKCS1_v1_5:
 198         case CryptoAlgorithmIdentifier::RSA_PSS:
 199         case CryptoAlgorithmIdentifier::RSA_OAEP: {
 200             auto params = convertDictionary&lt;CryptoAlgorithmRsaHashedKeyGenParams&gt;(state, value.get());
 201             RETURN_IF_EXCEPTION(scope, Exception { ExistingExceptionError });
 202             auto hashIdentifier = toHashIdentifier(state, params.hash);
 203             if (hashIdentifier.hasException())
 204                 return hashIdentifier.releaseException();
 205             params.hashIdentifier = hashIdentifier.releaseReturnValue();
<span class="line-modified"> 206             result = std::make_unique&lt;CryptoAlgorithmRsaHashedKeyGenParams&gt;(params);</span>
 207             break;
 208         }
 209         case CryptoAlgorithmIdentifier::AES_CTR:
 210         case CryptoAlgorithmIdentifier::AES_CBC:
 211         case CryptoAlgorithmIdentifier::AES_GCM:
 212         case CryptoAlgorithmIdentifier::AES_CFB:
 213         case CryptoAlgorithmIdentifier::AES_KW: {
 214             auto params = convertDictionary&lt;CryptoAlgorithmAesKeyParams&gt;(state, value.get());
 215             RETURN_IF_EXCEPTION(scope, Exception { ExistingExceptionError });
<span class="line-modified"> 216             result = std::make_unique&lt;CryptoAlgorithmAesKeyParams&gt;(params);</span>
 217             break;
 218         }
 219         case CryptoAlgorithmIdentifier::HMAC: {
 220             auto params = convertDictionary&lt;CryptoAlgorithmHmacKeyParams&gt;(state, value.get());
 221             RETURN_IF_EXCEPTION(scope, Exception { ExistingExceptionError });
 222             auto hashIdentifier = toHashIdentifier(state, params.hash);
 223             if (hashIdentifier.hasException())
 224                 return hashIdentifier.releaseException();
 225             params.hashIdentifier = hashIdentifier.releaseReturnValue();
<span class="line-modified"> 226             result = std::make_unique&lt;CryptoAlgorithmHmacKeyParams&gt;(params);</span>
 227             break;
 228         }
 229         case CryptoAlgorithmIdentifier::ECDSA:
 230         case CryptoAlgorithmIdentifier::ECDH: {
 231             auto params = convertDictionary&lt;CryptoAlgorithmEcKeyParams&gt;(state, value.get());
 232             RETURN_IF_EXCEPTION(scope, Exception { ExistingExceptionError });
<span class="line-modified"> 233             result = std::make_unique&lt;CryptoAlgorithmEcKeyParams&gt;(params);</span>
 234             break;
 235         }
 236         default:
 237             return Exception { NotSupportedError };
 238         }
 239         break;
 240     case Operations::DeriveBits:
 241         switch (*identifier) {
 242         case CryptoAlgorithmIdentifier::ECDH: {
 243             // Remove this hack once https://bugs.webkit.org/show_bug.cgi?id=169333 is fixed.
<span class="line-modified"> 244             JSValue nameValue = value.get()-&gt;get(&amp;state, Identifier::fromString(&amp;state, &quot;name&quot;));</span>
<span class="line-modified"> 245             JSValue publicValue = value.get()-&gt;get(&amp;state, Identifier::fromString(&amp;state, &quot;public&quot;));</span>
 246             JSObject* newValue = constructEmptyObject(&amp;state);
<span class="line-modified"> 247             newValue-&gt;putDirect(vm, Identifier::fromString(&amp;vm, &quot;name&quot;), nameValue);</span>
<span class="line-modified"> 248             newValue-&gt;putDirect(vm, Identifier::fromString(&amp;vm, &quot;publicKey&quot;), publicValue);</span>
 249 
 250             auto params = convertDictionary&lt;CryptoAlgorithmEcdhKeyDeriveParams&gt;(state, newValue);
 251             RETURN_IF_EXCEPTION(scope, Exception { ExistingExceptionError });
<span class="line-modified"> 252             result = std::make_unique&lt;CryptoAlgorithmEcdhKeyDeriveParams&gt;(params);</span>
 253             break;
 254         }
 255         case CryptoAlgorithmIdentifier::HKDF: {
 256             auto params = convertDictionary&lt;CryptoAlgorithmHkdfParams&gt;(state, value.get());
 257             RETURN_IF_EXCEPTION(scope, Exception { ExistingExceptionError });
 258             auto hashIdentifier = toHashIdentifier(state, params.hash);
 259             if (hashIdentifier.hasException())
 260                 return hashIdentifier.releaseException();
 261             params.hashIdentifier = hashIdentifier.releaseReturnValue();
<span class="line-modified"> 262             result = std::make_unique&lt;CryptoAlgorithmHkdfParams&gt;(params);</span>
 263             break;
 264         }
 265         case CryptoAlgorithmIdentifier::PBKDF2: {
 266             auto params = convertDictionary&lt;CryptoAlgorithmPbkdf2Params&gt;(state, value.get());
 267             RETURN_IF_EXCEPTION(scope, Exception { ExistingExceptionError });
 268             auto hashIdentifier = toHashIdentifier(state, params.hash);
 269             if (hashIdentifier.hasException())
 270                 return hashIdentifier.releaseException();
 271             params.hashIdentifier = hashIdentifier.releaseReturnValue();
<span class="line-modified"> 272             result = std::make_unique&lt;CryptoAlgorithmPbkdf2Params&gt;(params);</span>
 273             break;
 274         }
 275         default:
 276             return Exception { NotSupportedError };
 277         }
 278         break;
 279     case Operations::ImportKey:
 280         switch (*identifier) {
 281         case CryptoAlgorithmIdentifier::RSAES_PKCS1_v1_5:
<span class="line-modified"> 282             result = std::make_unique&lt;CryptoAlgorithmParameters&gt;(params);</span>
 283             break;
 284         case CryptoAlgorithmIdentifier::RSASSA_PKCS1_v1_5:
 285         case CryptoAlgorithmIdentifier::RSA_PSS:
 286         case CryptoAlgorithmIdentifier::RSA_OAEP: {
 287             auto params = convertDictionary&lt;CryptoAlgorithmRsaHashedImportParams&gt;(state, value.get());
 288             RETURN_IF_EXCEPTION(scope, Exception { ExistingExceptionError });
 289             auto hashIdentifier = toHashIdentifier(state, params.hash);
 290             if (hashIdentifier.hasException())
 291                 return hashIdentifier.releaseException();
 292             params.hashIdentifier = hashIdentifier.releaseReturnValue();
<span class="line-modified"> 293             result = std::make_unique&lt;CryptoAlgorithmRsaHashedImportParams&gt;(params);</span>
 294             break;
 295         }
 296         case CryptoAlgorithmIdentifier::AES_CTR:
 297         case CryptoAlgorithmIdentifier::AES_CBC:
 298         case CryptoAlgorithmIdentifier::AES_GCM:
 299         case CryptoAlgorithmIdentifier::AES_CFB:
 300         case CryptoAlgorithmIdentifier::AES_KW:
<span class="line-modified"> 301             result = std::make_unique&lt;CryptoAlgorithmParameters&gt;(params);</span>
 302             break;
 303         case CryptoAlgorithmIdentifier::HMAC: {
 304             auto params = convertDictionary&lt;CryptoAlgorithmHmacKeyParams&gt;(state, value.get());
 305             RETURN_IF_EXCEPTION(scope, Exception { ExistingExceptionError });
 306             auto hashIdentifier = toHashIdentifier(state, params.hash);
 307             if (hashIdentifier.hasException())
 308                 return hashIdentifier.releaseException();
 309             params.hashIdentifier = hashIdentifier.releaseReturnValue();
<span class="line-modified"> 310             result = std::make_unique&lt;CryptoAlgorithmHmacKeyParams&gt;(params);</span>
 311             break;
 312         }
 313         case CryptoAlgorithmIdentifier::ECDSA:
 314         case CryptoAlgorithmIdentifier::ECDH: {
 315             auto params = convertDictionary&lt;CryptoAlgorithmEcKeyParams&gt;(state, value.get());
 316             RETURN_IF_EXCEPTION(scope, Exception { ExistingExceptionError });
<span class="line-modified"> 317             result = std::make_unique&lt;CryptoAlgorithmEcKeyParams&gt;(params);</span>
 318             break;
 319         }
 320         case CryptoAlgorithmIdentifier::HKDF:
 321         case CryptoAlgorithmIdentifier::PBKDF2:
<span class="line-modified"> 322             result = std::make_unique&lt;CryptoAlgorithmParameters&gt;(params);</span>
 323             break;
 324         default:
 325             return Exception { NotSupportedError };
 326         }
 327         break;
 328     case Operations::WrapKey:
 329     case Operations::UnwrapKey:
 330         switch (*identifier) {
 331         case CryptoAlgorithmIdentifier::AES_KW:
<span class="line-modified"> 332             result = std::make_unique&lt;CryptoAlgorithmParameters&gt;(params);</span>
 333             break;
 334         default:
 335             return Exception { NotSupportedError };
 336         }
 337         break;
 338     case Operations::GetKeyLength:
 339         switch (*identifier) {
 340         case CryptoAlgorithmIdentifier::AES_CTR:
 341         case CryptoAlgorithmIdentifier::AES_CBC:
 342         case CryptoAlgorithmIdentifier::AES_GCM:
 343         case CryptoAlgorithmIdentifier::AES_CFB:
 344         case CryptoAlgorithmIdentifier::AES_KW: {
 345             auto params = convertDictionary&lt;CryptoAlgorithmAesKeyParams&gt;(state, value.get());
 346             RETURN_IF_EXCEPTION(scope, Exception { ExistingExceptionError });
<span class="line-modified"> 347             result = std::make_unique&lt;CryptoAlgorithmAesKeyParams&gt;(params);</span>
 348             break;
 349         }
 350         case CryptoAlgorithmIdentifier::HMAC: {
 351             auto params = convertDictionary&lt;CryptoAlgorithmHmacKeyParams&gt;(state, value.get());
 352             RETURN_IF_EXCEPTION(scope, Exception { ExistingExceptionError });
 353             auto hashIdentifier = toHashIdentifier(state, params.hash);
 354             if (hashIdentifier.hasException())
 355                 return hashIdentifier.releaseException();
 356             params.hashIdentifier = hashIdentifier.releaseReturnValue();
<span class="line-modified"> 357             result = std::make_unique&lt;CryptoAlgorithmHmacKeyParams&gt;(params);</span>
 358             break;
 359         }
 360         case CryptoAlgorithmIdentifier::HKDF:
 361         case CryptoAlgorithmIdentifier::PBKDF2:
<span class="line-modified"> 362             result = std::make_unique&lt;CryptoAlgorithmParameters&gt;(params);</span>
 363             break;
 364         default:
 365             return Exception { NotSupportedError };
 366         }
 367         break;
 368     }
 369 
 370     result-&gt;identifier = *identifier;
<span class="line-modified"> 371     return WTFMove(result);</span>
 372 }
 373 
 374 static CryptoKeyUsageBitmap toCryptoKeyUsageBitmap(CryptoKeyUsage usage)
 375 {
 376     switch (usage) {
 377     case CryptoKeyUsage::Encrypt:
 378         return CryptoKeyUsageEncrypt;
 379     case CryptoKeyUsage::Decrypt:
 380         return CryptoKeyUsageDecrypt;
 381     case CryptoKeyUsage::Sign:
 382         return CryptoKeyUsageSign;
 383     case CryptoKeyUsage::Verify:
 384         return CryptoKeyUsageVerify;
 385     case CryptoKeyUsage::DeriveKey:
 386         return CryptoKeyUsageDeriveKey;
 387     case CryptoKeyUsage::DeriveBits:
 388         return CryptoKeyUsageDeriveBits;
 389     case CryptoKeyUsage::WrapKey:
 390         return CryptoKeyUsageWrapKey;
 391     case CryptoKeyUsage::UnwrapKey:
</pre>
<hr />
<pre>
 503     case CryptoAlgorithmIdentifier::ECDH:
 504         return true;
 505     default:
 506         return false;
 507     }
 508 }
 509 
 510 RefPtr&lt;DeferredPromise&gt; getPromise(DeferredPromise* index, WeakPtr&lt;SubtleCrypto&gt; subtleCryptoWeakPointer)
 511 {
 512     if (subtleCryptoWeakPointer) {
 513         if (auto promise = subtleCryptoWeakPointer-&gt;m_pendingPromises.take(index))
 514             return WTFMove(promise.value());
 515     }
 516     return nullptr;
 517 }
 518 
 519 static std::unique_ptr&lt;CryptoAlgorithmParameters&gt; crossThreadCopyImportParams(const CryptoAlgorithmParameters&amp; importParams)
 520 {
 521     switch (importParams.parametersClass()) {
 522     case CryptoAlgorithmParameters::Class::None: {
<span class="line-modified"> 523         auto result = std::make_unique&lt;CryptoAlgorithmParameters&gt;();</span>
 524         result-&gt;identifier = importParams.identifier;
 525         return result;
 526     }
 527     case CryptoAlgorithmParameters::Class::EcKeyParams:
<span class="line-modified"> 528         return std::make_unique&lt;CryptoAlgorithmEcKeyParams&gt;(crossThreadCopy(downcast&lt;CryptoAlgorithmEcKeyParams&gt;(importParams)));</span>
 529     case CryptoAlgorithmParameters::Class::HmacKeyParams:
<span class="line-modified"> 530         return std::make_unique&lt;CryptoAlgorithmHmacKeyParams&gt;(crossThreadCopy(downcast&lt;CryptoAlgorithmHmacKeyParams&gt;(importParams)));</span>
 531     case CryptoAlgorithmParameters::Class::RsaHashedImportParams:
<span class="line-modified"> 532         return std::make_unique&lt;CryptoAlgorithmRsaHashedImportParams&gt;(crossThreadCopy(downcast&lt;CryptoAlgorithmRsaHashedImportParams&gt;(importParams)));</span>
 533     default:
 534         ASSERT_NOT_REACHED();
 535         return nullptr;
 536     }
 537 }
 538 
 539 // MARK: - Exposed functions.
 540 
 541 void SubtleCrypto::encrypt(JSC::ExecState&amp; state, AlgorithmIdentifier&amp;&amp; algorithmIdentifier, CryptoKey&amp; key, BufferSource&amp;&amp; dataBufferSource, Ref&lt;DeferredPromise&gt;&amp;&amp; promise)
 542 {
 543     auto paramsOrException = normalizeCryptoAlgorithmParameters(state, WTFMove(algorithmIdentifier), Operations::Encrypt);
 544     if (paramsOrException.hasException()) {
 545         promise-&gt;reject(paramsOrException.releaseException());
 546         return;
 547     }
 548     auto params = paramsOrException.releaseReturnValue();
 549 
 550     auto data = copyToVector(WTFMove(dataBufferSource));
 551 
 552     if (params-&gt;identifier != key.algorithmIdentifier()) {
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (C) 2016-2019 Apple Inc. All rights reserved.</span>
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  * 1. Redistributions of source code must retain the above copyright
   8  *    notice, this list of conditions and the following disclaimer.
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
  14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
  15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
  17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
</pre>
<hr />
<pre>
  78     GetKeyLength
  79 };
  80 
  81 static ExceptionOr&lt;std::unique_ptr&lt;CryptoAlgorithmParameters&gt;&gt; normalizeCryptoAlgorithmParameters(ExecState&amp;, WebCore::SubtleCrypto::AlgorithmIdentifier, Operations);
  82 
  83 static ExceptionOr&lt;CryptoAlgorithmIdentifier&gt; toHashIdentifier(ExecState&amp; state, SubtleCrypto::AlgorithmIdentifier algorithmIdentifier)
  84 {
  85     auto digestParams = normalizeCryptoAlgorithmParameters(state, algorithmIdentifier, Operations::Digest);
  86     if (digestParams.hasException())
  87         return digestParams.releaseException();
  88     return digestParams.returnValue()-&gt;identifier;
  89 }
  90 
  91 static ExceptionOr&lt;std::unique_ptr&lt;CryptoAlgorithmParameters&gt;&gt; normalizeCryptoAlgorithmParameters(ExecState&amp; state, SubtleCrypto::AlgorithmIdentifier algorithmIdentifier, Operations operation)
  92 {
  93     VM&amp; vm = state.vm();
  94     auto scope = DECLARE_THROW_SCOPE(vm);
  95 
  96     if (WTF::holds_alternative&lt;String&gt;(algorithmIdentifier)) {
  97         auto newParams = Strong&lt;JSObject&gt;(vm, constructEmptyObject(&amp;state));
<span class="line-modified">  98         newParams-&gt;putDirect(vm, Identifier::fromString(vm, &quot;name&quot;), jsString(vm, WTF::get&lt;String&gt;(algorithmIdentifier)));</span>
  99 
 100         return normalizeCryptoAlgorithmParameters(state, newParams, operation);
 101     }
 102 
 103     auto&amp; value = WTF::get&lt;JSC::Strong&lt;JSC::JSObject&gt;&gt;(algorithmIdentifier);
 104 
 105     auto params = convertDictionary&lt;CryptoAlgorithmParameters&gt;(state, value.get());
 106     RETURN_IF_EXCEPTION(scope, Exception { ExistingExceptionError });
 107 
 108     auto identifier = CryptoAlgorithmRegistry::singleton().identifier(params.name);
 109     if (UNLIKELY(!identifier))
 110         return Exception { NotSupportedError };
 111 
 112     std::unique_ptr&lt;CryptoAlgorithmParameters&gt; result;
 113     switch (operation) {
 114     case Operations::Encrypt:
 115     case Operations::Decrypt:
 116         switch (*identifier) {
 117         case CryptoAlgorithmIdentifier::RSAES_PKCS1_v1_5:
<span class="line-modified"> 118             result = makeUnique&lt;CryptoAlgorithmParameters&gt;(params);</span>
 119             break;
 120         case CryptoAlgorithmIdentifier::RSA_OAEP: {
 121             auto params = convertDictionary&lt;CryptoAlgorithmRsaOaepParams&gt;(state, value.get());
 122             RETURN_IF_EXCEPTION(scope, Exception { ExistingExceptionError });
<span class="line-modified"> 123             result = makeUnique&lt;CryptoAlgorithmRsaOaepParams&gt;(params);</span>
 124             break;
 125         }
 126         case CryptoAlgorithmIdentifier::AES_CBC:
 127         case CryptoAlgorithmIdentifier::AES_CFB: {
 128             auto params = convertDictionary&lt;CryptoAlgorithmAesCbcCfbParams&gt;(state, value.get());
 129             RETURN_IF_EXCEPTION(scope, Exception { ExistingExceptionError });
<span class="line-modified"> 130             result = makeUnique&lt;CryptoAlgorithmAesCbcCfbParams&gt;(params);</span>
 131             break;
 132         }
 133         case CryptoAlgorithmIdentifier::AES_CTR: {
 134             auto params = convertDictionary&lt;CryptoAlgorithmAesCtrParams&gt;(state, value.get());
 135             RETURN_IF_EXCEPTION(scope, Exception { ExistingExceptionError });
<span class="line-modified"> 136             result = makeUnique&lt;CryptoAlgorithmAesCtrParams&gt;(params);</span>
 137             break;
 138         }
 139         case CryptoAlgorithmIdentifier::AES_GCM: {
 140             auto params = convertDictionary&lt;CryptoAlgorithmAesGcmParams&gt;(state, value.get());
 141             RETURN_IF_EXCEPTION(scope, Exception { ExistingExceptionError });
<span class="line-modified"> 142             result = makeUnique&lt;CryptoAlgorithmAesGcmParams&gt;(params);</span>
 143             break;
 144         }
 145         default:
 146             return Exception { NotSupportedError };
 147         }
 148         break;
 149     case Operations::Sign:
 150     case Operations::Verify:
 151         switch (*identifier) {
 152         case CryptoAlgorithmIdentifier::RSASSA_PKCS1_v1_5:
 153         case CryptoAlgorithmIdentifier::HMAC:
<span class="line-modified"> 154             result = makeUnique&lt;CryptoAlgorithmParameters&gt;(params);</span>
 155             break;
 156         case CryptoAlgorithmIdentifier::ECDSA: {
 157             auto params = convertDictionary&lt;CryptoAlgorithmEcdsaParams&gt;(state, value.get());
 158             RETURN_IF_EXCEPTION(scope, Exception { ExistingExceptionError });
 159             auto hashIdentifier = toHashIdentifier(state, params.hash);
 160             if (hashIdentifier.hasException())
 161                 return hashIdentifier.releaseException();
 162             params.hashIdentifier = hashIdentifier.releaseReturnValue();
<span class="line-modified"> 163             result = makeUnique&lt;CryptoAlgorithmEcdsaParams&gt;(params);</span>
 164             break;
 165         }
 166         case CryptoAlgorithmIdentifier::RSA_PSS: {
 167             auto params = convertDictionary&lt;CryptoAlgorithmRsaPssParams&gt;(state, value.get());
 168             RETURN_IF_EXCEPTION(scope, Exception { ExistingExceptionError });
<span class="line-modified"> 169             result = makeUnique&lt;CryptoAlgorithmRsaPssParams&gt;(params);</span>
 170             break;
 171         }
 172         default:
 173             return Exception { NotSupportedError };
 174         }
 175         break;
 176     case Operations::Digest:
 177         switch (*identifier) {
 178         case CryptoAlgorithmIdentifier::SHA_1:
 179         case CryptoAlgorithmIdentifier::SHA_224:
 180         case CryptoAlgorithmIdentifier::SHA_256:
 181         case CryptoAlgorithmIdentifier::SHA_384:
 182         case CryptoAlgorithmIdentifier::SHA_512:
<span class="line-modified"> 183             result = makeUnique&lt;CryptoAlgorithmParameters&gt;(params);</span>
 184             break;
 185         default:
 186             return Exception { NotSupportedError };
 187         }
 188         break;
 189     case Operations::GenerateKey:
 190         switch (*identifier) {
 191         case CryptoAlgorithmIdentifier::RSAES_PKCS1_v1_5: {
 192             auto params = convertDictionary&lt;CryptoAlgorithmRsaKeyGenParams&gt;(state, value.get());
 193             RETURN_IF_EXCEPTION(scope, Exception { ExistingExceptionError });
<span class="line-modified"> 194             result = makeUnique&lt;CryptoAlgorithmRsaKeyGenParams&gt;(params);</span>
 195             break;
 196         }
 197         case CryptoAlgorithmIdentifier::RSASSA_PKCS1_v1_5:
 198         case CryptoAlgorithmIdentifier::RSA_PSS:
 199         case CryptoAlgorithmIdentifier::RSA_OAEP: {
 200             auto params = convertDictionary&lt;CryptoAlgorithmRsaHashedKeyGenParams&gt;(state, value.get());
 201             RETURN_IF_EXCEPTION(scope, Exception { ExistingExceptionError });
 202             auto hashIdentifier = toHashIdentifier(state, params.hash);
 203             if (hashIdentifier.hasException())
 204                 return hashIdentifier.releaseException();
 205             params.hashIdentifier = hashIdentifier.releaseReturnValue();
<span class="line-modified"> 206             result = makeUnique&lt;CryptoAlgorithmRsaHashedKeyGenParams&gt;(params);</span>
 207             break;
 208         }
 209         case CryptoAlgorithmIdentifier::AES_CTR:
 210         case CryptoAlgorithmIdentifier::AES_CBC:
 211         case CryptoAlgorithmIdentifier::AES_GCM:
 212         case CryptoAlgorithmIdentifier::AES_CFB:
 213         case CryptoAlgorithmIdentifier::AES_KW: {
 214             auto params = convertDictionary&lt;CryptoAlgorithmAesKeyParams&gt;(state, value.get());
 215             RETURN_IF_EXCEPTION(scope, Exception { ExistingExceptionError });
<span class="line-modified"> 216             result = makeUnique&lt;CryptoAlgorithmAesKeyParams&gt;(params);</span>
 217             break;
 218         }
 219         case CryptoAlgorithmIdentifier::HMAC: {
 220             auto params = convertDictionary&lt;CryptoAlgorithmHmacKeyParams&gt;(state, value.get());
 221             RETURN_IF_EXCEPTION(scope, Exception { ExistingExceptionError });
 222             auto hashIdentifier = toHashIdentifier(state, params.hash);
 223             if (hashIdentifier.hasException())
 224                 return hashIdentifier.releaseException();
 225             params.hashIdentifier = hashIdentifier.releaseReturnValue();
<span class="line-modified"> 226             result = makeUnique&lt;CryptoAlgorithmHmacKeyParams&gt;(params);</span>
 227             break;
 228         }
 229         case CryptoAlgorithmIdentifier::ECDSA:
 230         case CryptoAlgorithmIdentifier::ECDH: {
 231             auto params = convertDictionary&lt;CryptoAlgorithmEcKeyParams&gt;(state, value.get());
 232             RETURN_IF_EXCEPTION(scope, Exception { ExistingExceptionError });
<span class="line-modified"> 233             result = makeUnique&lt;CryptoAlgorithmEcKeyParams&gt;(params);</span>
 234             break;
 235         }
 236         default:
 237             return Exception { NotSupportedError };
 238         }
 239         break;
 240     case Operations::DeriveBits:
 241         switch (*identifier) {
 242         case CryptoAlgorithmIdentifier::ECDH: {
 243             // Remove this hack once https://bugs.webkit.org/show_bug.cgi?id=169333 is fixed.
<span class="line-modified"> 244             JSValue nameValue = value.get()-&gt;get(&amp;state, Identifier::fromString(vm, &quot;name&quot;));</span>
<span class="line-modified"> 245             JSValue publicValue = value.get()-&gt;get(&amp;state, Identifier::fromString(vm, &quot;public&quot;));</span>
 246             JSObject* newValue = constructEmptyObject(&amp;state);
<span class="line-modified"> 247             newValue-&gt;putDirect(vm, Identifier::fromString(vm, &quot;name&quot;), nameValue);</span>
<span class="line-modified"> 248             newValue-&gt;putDirect(vm, Identifier::fromString(vm, &quot;publicKey&quot;), publicValue);</span>
 249 
 250             auto params = convertDictionary&lt;CryptoAlgorithmEcdhKeyDeriveParams&gt;(state, newValue);
 251             RETURN_IF_EXCEPTION(scope, Exception { ExistingExceptionError });
<span class="line-modified"> 252             result = makeUnique&lt;CryptoAlgorithmEcdhKeyDeriveParams&gt;(params);</span>
 253             break;
 254         }
 255         case CryptoAlgorithmIdentifier::HKDF: {
 256             auto params = convertDictionary&lt;CryptoAlgorithmHkdfParams&gt;(state, value.get());
 257             RETURN_IF_EXCEPTION(scope, Exception { ExistingExceptionError });
 258             auto hashIdentifier = toHashIdentifier(state, params.hash);
 259             if (hashIdentifier.hasException())
 260                 return hashIdentifier.releaseException();
 261             params.hashIdentifier = hashIdentifier.releaseReturnValue();
<span class="line-modified"> 262             result = makeUnique&lt;CryptoAlgorithmHkdfParams&gt;(params);</span>
 263             break;
 264         }
 265         case CryptoAlgorithmIdentifier::PBKDF2: {
 266             auto params = convertDictionary&lt;CryptoAlgorithmPbkdf2Params&gt;(state, value.get());
 267             RETURN_IF_EXCEPTION(scope, Exception { ExistingExceptionError });
 268             auto hashIdentifier = toHashIdentifier(state, params.hash);
 269             if (hashIdentifier.hasException())
 270                 return hashIdentifier.releaseException();
 271             params.hashIdentifier = hashIdentifier.releaseReturnValue();
<span class="line-modified"> 272             result = makeUnique&lt;CryptoAlgorithmPbkdf2Params&gt;(params);</span>
 273             break;
 274         }
 275         default:
 276             return Exception { NotSupportedError };
 277         }
 278         break;
 279     case Operations::ImportKey:
 280         switch (*identifier) {
 281         case CryptoAlgorithmIdentifier::RSAES_PKCS1_v1_5:
<span class="line-modified"> 282             result = makeUnique&lt;CryptoAlgorithmParameters&gt;(params);</span>
 283             break;
 284         case CryptoAlgorithmIdentifier::RSASSA_PKCS1_v1_5:
 285         case CryptoAlgorithmIdentifier::RSA_PSS:
 286         case CryptoAlgorithmIdentifier::RSA_OAEP: {
 287             auto params = convertDictionary&lt;CryptoAlgorithmRsaHashedImportParams&gt;(state, value.get());
 288             RETURN_IF_EXCEPTION(scope, Exception { ExistingExceptionError });
 289             auto hashIdentifier = toHashIdentifier(state, params.hash);
 290             if (hashIdentifier.hasException())
 291                 return hashIdentifier.releaseException();
 292             params.hashIdentifier = hashIdentifier.releaseReturnValue();
<span class="line-modified"> 293             result = makeUnique&lt;CryptoAlgorithmRsaHashedImportParams&gt;(params);</span>
 294             break;
 295         }
 296         case CryptoAlgorithmIdentifier::AES_CTR:
 297         case CryptoAlgorithmIdentifier::AES_CBC:
 298         case CryptoAlgorithmIdentifier::AES_GCM:
 299         case CryptoAlgorithmIdentifier::AES_CFB:
 300         case CryptoAlgorithmIdentifier::AES_KW:
<span class="line-modified"> 301             result = makeUnique&lt;CryptoAlgorithmParameters&gt;(params);</span>
 302             break;
 303         case CryptoAlgorithmIdentifier::HMAC: {
 304             auto params = convertDictionary&lt;CryptoAlgorithmHmacKeyParams&gt;(state, value.get());
 305             RETURN_IF_EXCEPTION(scope, Exception { ExistingExceptionError });
 306             auto hashIdentifier = toHashIdentifier(state, params.hash);
 307             if (hashIdentifier.hasException())
 308                 return hashIdentifier.releaseException();
 309             params.hashIdentifier = hashIdentifier.releaseReturnValue();
<span class="line-modified"> 310             result = makeUnique&lt;CryptoAlgorithmHmacKeyParams&gt;(params);</span>
 311             break;
 312         }
 313         case CryptoAlgorithmIdentifier::ECDSA:
 314         case CryptoAlgorithmIdentifier::ECDH: {
 315             auto params = convertDictionary&lt;CryptoAlgorithmEcKeyParams&gt;(state, value.get());
 316             RETURN_IF_EXCEPTION(scope, Exception { ExistingExceptionError });
<span class="line-modified"> 317             result = makeUnique&lt;CryptoAlgorithmEcKeyParams&gt;(params);</span>
 318             break;
 319         }
 320         case CryptoAlgorithmIdentifier::HKDF:
 321         case CryptoAlgorithmIdentifier::PBKDF2:
<span class="line-modified"> 322             result = makeUnique&lt;CryptoAlgorithmParameters&gt;(params);</span>
 323             break;
 324         default:
 325             return Exception { NotSupportedError };
 326         }
 327         break;
 328     case Operations::WrapKey:
 329     case Operations::UnwrapKey:
 330         switch (*identifier) {
 331         case CryptoAlgorithmIdentifier::AES_KW:
<span class="line-modified"> 332             result = makeUnique&lt;CryptoAlgorithmParameters&gt;(params);</span>
 333             break;
 334         default:
 335             return Exception { NotSupportedError };
 336         }
 337         break;
 338     case Operations::GetKeyLength:
 339         switch (*identifier) {
 340         case CryptoAlgorithmIdentifier::AES_CTR:
 341         case CryptoAlgorithmIdentifier::AES_CBC:
 342         case CryptoAlgorithmIdentifier::AES_GCM:
 343         case CryptoAlgorithmIdentifier::AES_CFB:
 344         case CryptoAlgorithmIdentifier::AES_KW: {
 345             auto params = convertDictionary&lt;CryptoAlgorithmAesKeyParams&gt;(state, value.get());
 346             RETURN_IF_EXCEPTION(scope, Exception { ExistingExceptionError });
<span class="line-modified"> 347             result = makeUnique&lt;CryptoAlgorithmAesKeyParams&gt;(params);</span>
 348             break;
 349         }
 350         case CryptoAlgorithmIdentifier::HMAC: {
 351             auto params = convertDictionary&lt;CryptoAlgorithmHmacKeyParams&gt;(state, value.get());
 352             RETURN_IF_EXCEPTION(scope, Exception { ExistingExceptionError });
 353             auto hashIdentifier = toHashIdentifier(state, params.hash);
 354             if (hashIdentifier.hasException())
 355                 return hashIdentifier.releaseException();
 356             params.hashIdentifier = hashIdentifier.releaseReturnValue();
<span class="line-modified"> 357             result = makeUnique&lt;CryptoAlgorithmHmacKeyParams&gt;(params);</span>
 358             break;
 359         }
 360         case CryptoAlgorithmIdentifier::HKDF:
 361         case CryptoAlgorithmIdentifier::PBKDF2:
<span class="line-modified"> 362             result = makeUnique&lt;CryptoAlgorithmParameters&gt;(params);</span>
 363             break;
 364         default:
 365             return Exception { NotSupportedError };
 366         }
 367         break;
 368     }
 369 
 370     result-&gt;identifier = *identifier;
<span class="line-modified"> 371     return result;</span>
 372 }
 373 
 374 static CryptoKeyUsageBitmap toCryptoKeyUsageBitmap(CryptoKeyUsage usage)
 375 {
 376     switch (usage) {
 377     case CryptoKeyUsage::Encrypt:
 378         return CryptoKeyUsageEncrypt;
 379     case CryptoKeyUsage::Decrypt:
 380         return CryptoKeyUsageDecrypt;
 381     case CryptoKeyUsage::Sign:
 382         return CryptoKeyUsageSign;
 383     case CryptoKeyUsage::Verify:
 384         return CryptoKeyUsageVerify;
 385     case CryptoKeyUsage::DeriveKey:
 386         return CryptoKeyUsageDeriveKey;
 387     case CryptoKeyUsage::DeriveBits:
 388         return CryptoKeyUsageDeriveBits;
 389     case CryptoKeyUsage::WrapKey:
 390         return CryptoKeyUsageWrapKey;
 391     case CryptoKeyUsage::UnwrapKey:
</pre>
<hr />
<pre>
 503     case CryptoAlgorithmIdentifier::ECDH:
 504         return true;
 505     default:
 506         return false;
 507     }
 508 }
 509 
 510 RefPtr&lt;DeferredPromise&gt; getPromise(DeferredPromise* index, WeakPtr&lt;SubtleCrypto&gt; subtleCryptoWeakPointer)
 511 {
 512     if (subtleCryptoWeakPointer) {
 513         if (auto promise = subtleCryptoWeakPointer-&gt;m_pendingPromises.take(index))
 514             return WTFMove(promise.value());
 515     }
 516     return nullptr;
 517 }
 518 
 519 static std::unique_ptr&lt;CryptoAlgorithmParameters&gt; crossThreadCopyImportParams(const CryptoAlgorithmParameters&amp; importParams)
 520 {
 521     switch (importParams.parametersClass()) {
 522     case CryptoAlgorithmParameters::Class::None: {
<span class="line-modified"> 523         auto result = makeUnique&lt;CryptoAlgorithmParameters&gt;();</span>
 524         result-&gt;identifier = importParams.identifier;
 525         return result;
 526     }
 527     case CryptoAlgorithmParameters::Class::EcKeyParams:
<span class="line-modified"> 528         return makeUnique&lt;CryptoAlgorithmEcKeyParams&gt;(crossThreadCopy(downcast&lt;CryptoAlgorithmEcKeyParams&gt;(importParams)));</span>
 529     case CryptoAlgorithmParameters::Class::HmacKeyParams:
<span class="line-modified"> 530         return makeUnique&lt;CryptoAlgorithmHmacKeyParams&gt;(crossThreadCopy(downcast&lt;CryptoAlgorithmHmacKeyParams&gt;(importParams)));</span>
 531     case CryptoAlgorithmParameters::Class::RsaHashedImportParams:
<span class="line-modified"> 532         return makeUnique&lt;CryptoAlgorithmRsaHashedImportParams&gt;(crossThreadCopy(downcast&lt;CryptoAlgorithmRsaHashedImportParams&gt;(importParams)));</span>
 533     default:
 534         ASSERT_NOT_REACHED();
 535         return nullptr;
 536     }
 537 }
 538 
 539 // MARK: - Exposed functions.
 540 
 541 void SubtleCrypto::encrypt(JSC::ExecState&amp; state, AlgorithmIdentifier&amp;&amp; algorithmIdentifier, CryptoKey&amp; key, BufferSource&amp;&amp; dataBufferSource, Ref&lt;DeferredPromise&gt;&amp;&amp; promise)
 542 {
 543     auto paramsOrException = normalizeCryptoAlgorithmParameters(state, WTFMove(algorithmIdentifier), Operations::Encrypt);
 544     if (paramsOrException.hasException()) {
 545         promise-&gt;reject(paramsOrException.releaseException());
 546         return;
 547     }
 548     auto params = paramsOrException.releaseReturnValue();
 549 
 550     auto data = copyToVector(WTFMove(dataBufferSource));
 551 
 552     if (params-&gt;identifier != key.algorithmIdentifier()) {
</pre>
</td>
</tr>
</table>
<center><a href="CommonCryptoUtilities.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="gcrypt/CryptoAlgorithmHMACGCrypt.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>