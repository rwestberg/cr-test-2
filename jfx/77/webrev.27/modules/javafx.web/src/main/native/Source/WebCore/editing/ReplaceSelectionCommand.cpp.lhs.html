<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/editing/ReplaceSelectionCommand.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (C) 2005-2017 Apple Inc. All rights reserved.
   3  * Copyright (C) 2009, 2010, 2011 Google Inc. All rights reserved.
   4  *
   5  * Redistribution and use in source and binary forms, with or without
   6  * modification, are permitted provided that the following conditions
   7  * are met:
   8  * 1. Redistributions of source code must retain the above copyright
   9  *    notice, this list of conditions and the following disclaimer.
  10  * 2. Redistributions in binary form must reproduce the above copyright
  11  *    notice, this list of conditions and the following disclaimer in the
  12  *    documentation and/or other materials provided with the distribution.
  13  *
  14  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  15  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  16  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  17  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  18  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  19  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  20  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  21  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  22  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  23  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  24  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  25  */
  26 
  27 #include &quot;config.h&quot;
  28 #include &quot;ReplaceSelectionCommand.h&quot;
  29 
  30 #include &quot;AXObjectCache.h&quot;
  31 #include &quot;ApplyStyleCommand.h&quot;
  32 #include &quot;BeforeTextInsertedEvent.h&quot;
  33 #include &quot;BreakBlockquoteCommand.h&quot;
<a name="1" id="anc1"></a>
  34 #include &quot;CSSStyleDeclaration.h&quot;
  35 #include &quot;DOMWrapperWorld.h&quot;
  36 #include &quot;DataTransfer.h&quot;
  37 #include &quot;Document.h&quot;
  38 #include &quot;DocumentFragment.h&quot;
  39 #include &quot;Editing.h&quot;
<a name="2" id="anc2"></a>
  40 #include &quot;ElementIterator.h&quot;
  41 #include &quot;EventNames.h&quot;
  42 #include &quot;Frame.h&quot;
  43 #include &quot;FrameSelection.h&quot;
  44 #include &quot;HTMLBRElement.h&quot;
  45 #include &quot;HTMLBaseElement.h&quot;
<a name="3" id="anc3"></a>
  46 #include &quot;HTMLInputElement.h&quot;
  47 #include &quot;HTMLLIElement.h&quot;
  48 #include &quot;HTMLLinkElement.h&quot;
  49 #include &quot;HTMLMetaElement.h&quot;
  50 #include &quot;HTMLNames.h&quot;
  51 #include &quot;HTMLStyleElement.h&quot;
  52 #include &quot;HTMLTitleElement.h&quot;
  53 #include &quot;NodeList.h&quot;
  54 #include &quot;NodeRenderStyle.h&quot;
  55 #include &quot;RenderInline.h&quot;
  56 #include &quot;RenderText.h&quot;
<a name="4" id="anc4"></a>
  57 #include &quot;SimplifyMarkupCommand.h&quot;
  58 #include &quot;SmartReplace.h&quot;
  59 #include &quot;StyleProperties.h&quot;
  60 #include &quot;Text.h&quot;
  61 #include &quot;TextIterator.h&quot;
  62 #include &quot;VisibleUnits.h&quot;
  63 #include &quot;markup.h&quot;
  64 #include &lt;wtf/NeverDestroyed.h&gt;
  65 #include &lt;wtf/StdLibExtras.h&gt;
  66 
  67 namespace WebCore {
  68 
  69 using namespace HTMLNames;
  70 
  71 enum EFragmentType { EmptyFragment, SingleTextNodeFragment, TreeFragment };
  72 
<a name="5" id="anc5"></a><span class="line-removed">  73 static void removeHeadContents(ReplacementFragment&amp;);</span>
<span class="line-removed">  74 </span>
  75 // --- ReplacementFragment helper class
  76 
  77 class ReplacementFragment {
  78     WTF_MAKE_FAST_ALLOCATED;
  79     WTF_MAKE_NONCOPYABLE(ReplacementFragment);
  80 public:
<a name="6" id="anc6"></a><span class="line-modified">  81     ReplacementFragment(Document&amp;, DocumentFragment*, const VisibleSelection&amp;);</span>
  82 
  83     DocumentFragment* fragment() { return m_fragment.get(); }
  84 
  85     Node* firstChild() const;
  86     Node* lastChild() const;
  87 
  88     bool isEmpty() const;
  89 
  90     bool hasInterchangeNewlineAtStart() const { return m_hasInterchangeNewlineAtStart; }
  91     bool hasInterchangeNewlineAtEnd() const { return m_hasInterchangeNewlineAtEnd; }
  92 
  93     void removeNode(Node&amp;);
  94     void removeNodePreservingChildren(Node&amp;);
  95 
  96 private:
<a name="7" id="anc7"></a>
  97     Ref&lt;HTMLElement&gt; insertFragmentForTestRendering(Node* rootEditableNode);
  98     void removeUnrenderedNodes(Node*);
  99     void restoreAndRemoveTestRenderingNodesToFragment(StyledElement*);
 100     void removeInterchangeNodes(Node*);
 101 
 102     void insertNodeBefore(Node&amp;, Node&amp; refNode);
 103 
<a name="8" id="anc8"></a><span class="line-removed"> 104     Document&amp; document() { return *m_document; }</span>
<span class="line-removed"> 105 </span>
<span class="line-removed"> 106     RefPtr&lt;Document&gt; m_document;</span>
 107     RefPtr&lt;DocumentFragment&gt; m_fragment;
 108     bool m_hasInterchangeNewlineAtStart;
 109     bool m_hasInterchangeNewlineAtEnd;
 110 };
 111 
 112 static bool isInterchangeNewlineNode(const Node* node)
 113 {
 114     static NeverDestroyed&lt;String&gt; interchangeNewlineClassString(AppleInterchangeNewline);
 115     return is&lt;HTMLBRElement&gt;(node) &amp;&amp; downcast&lt;HTMLBRElement&gt;(*node).attributeWithoutSynchronization(classAttr) == interchangeNewlineClassString;
 116 }
 117 
 118 static bool isInterchangeConvertedSpaceSpan(const Node* node)
 119 {
 120     static NeverDestroyed&lt;String&gt; convertedSpaceSpanClassString(AppleConvertedSpace);
 121     return is&lt;HTMLElement&gt;(node) &amp;&amp; downcast&lt;HTMLElement&gt;(*node).attributeWithoutSynchronization(classAttr) == convertedSpaceSpanClassString;
 122 }
 123 
 124 static Position positionAvoidingPrecedingNodes(Position position)
 125 {
 126     ASSERT(position.isNotNull());
 127 
 128     // If we&#39;re already on a break, it&#39;s probably a placeholder and we shouldn&#39;t change our position.
 129     if (editingIgnoresContent(*position.deprecatedNode()))
 130         return position;
 131 
 132     // We also stop when changing block flow elements because even though the visual position is the
 133     // same.  E.g.,
 134     //   &lt;div&gt;foo^&lt;/div&gt;^
 135     // The two positions above are the same visual position, but we want to stay in the same block.
 136     auto* enclosingBlockNode = enclosingBlock(position.containerNode());
 137     for (Position nextPosition = position; nextPosition.containerNode() != enclosingBlockNode; position = nextPosition) {
 138         if (lineBreakExistsAtPosition(position))
 139             break;
 140 
 141         if (position.containerNode()-&gt;nonShadowBoundaryParentNode())
 142             nextPosition = positionInParentAfterNode(position.containerNode());
 143 
 144         if (nextPosition == position)
 145             break;
 146         if (enclosingBlock(nextPosition.containerNode()) != enclosingBlockNode)
 147             break;
 148         if (VisiblePosition(position) != VisiblePosition(nextPosition))
 149             break;
 150     }
 151     return position;
 152 }
 153 
<a name="9" id="anc9"></a><span class="line-modified"> 154 ReplacementFragment::ReplacementFragment(Document&amp; document, DocumentFragment* fragment, const VisibleSelection&amp; selection)</span>
<span class="line-modified"> 155     : m_document(&amp;document)</span>
<span class="line-removed"> 156     , m_fragment(fragment)</span>
 157     , m_hasInterchangeNewlineAtStart(false)
 158     , m_hasInterchangeNewlineAtEnd(false)
 159 {
 160     if (!m_fragment)
 161         return;
 162     if (!m_fragment-&gt;firstChild())
 163         return;
 164 
<a name="10" id="anc10"></a>

 165     RefPtr&lt;Element&gt; editableRoot = selection.rootEditableElement();
 166     ASSERT(editableRoot);
 167     if (!editableRoot)
 168         return;
 169 
 170     auto* shadowHost = editableRoot-&gt;shadowHost();
 171     if (!editableRoot-&gt;attributeEventListener(eventNames().webkitBeforeTextInsertedEvent, mainThreadNormalWorld())
 172         &amp;&amp; !(shadowHost &amp;&amp; shadowHost-&gt;renderer() &amp;&amp; shadowHost-&gt;renderer()-&gt;isTextControl())
 173         &amp;&amp; editableRoot-&gt;hasRichlyEditableStyle()) {
 174         removeInterchangeNodes(m_fragment.get());
 175         return;
 176     }
 177 
<a name="11" id="anc11"></a><span class="line-modified"> 178     RefPtr&lt;StyledElement&gt; holder = insertFragmentForTestRendering(editableRoot.get());</span>







 179     if (!holder) {
 180         removeInterchangeNodes(m_fragment.get());
 181         return;
 182     }
 183 
 184     RefPtr&lt;Range&gt; range = VisibleSelection::selectionFromContentsOfNode(holder.get()).toNormalizedRange();
 185     String text = plainText(range.get(), static_cast&lt;TextIteratorBehavior&gt;(TextIteratorEmitsOriginalText | TextIteratorIgnoresStyleVisibility));
 186 
 187     removeInterchangeNodes(holder.get());
 188     removeUnrenderedNodes(holder.get());
 189     restoreAndRemoveTestRenderingNodesToFragment(holder.get());
 190 
 191     // Give the root a chance to change the text.
 192     auto event = BeforeTextInsertedEvent::create(text);
 193     editableRoot-&gt;dispatchEvent(event);
 194     if (text != event-&gt;text() || !editableRoot-&gt;hasRichlyEditableStyle()) {
 195         restoreAndRemoveTestRenderingNodesToFragment(holder.get());
 196 
 197         RefPtr&lt;Range&gt; range = selection.toNormalizedRange();
 198         if (!range)
 199             return;
 200 
 201         m_fragment = createFragmentFromText(*range, event-&gt;text());
 202         if (!m_fragment-&gt;firstChild())
 203             return;
 204 
<a name="12" id="anc12"></a><span class="line-modified"> 205         holder = insertFragmentForTestRendering(editableRoot.get());</span>
 206         removeInterchangeNodes(holder.get());
 207         removeUnrenderedNodes(holder.get());
 208         restoreAndRemoveTestRenderingNodesToFragment(holder.get());
 209     }
 210 }
 211 
<a name="13" id="anc13"></a>






























 212 bool ReplacementFragment::isEmpty() const
 213 {
 214     return (!m_fragment || !m_fragment-&gt;firstChild()) &amp;&amp; !m_hasInterchangeNewlineAtStart &amp;&amp; !m_hasInterchangeNewlineAtEnd;
 215 }
 216 
 217 Node *ReplacementFragment::firstChild() const
 218 {
 219     return m_fragment ? m_fragment-&gt;firstChild() : 0;
 220 }
 221 
 222 Node *ReplacementFragment::lastChild() const
 223 {
 224     return m_fragment ? m_fragment-&gt;lastChild() : 0;
 225 }
 226 
 227 void ReplacementFragment::removeNodePreservingChildren(Node&amp; node)
 228 {
 229     Ref&lt;Node&gt; protectedNode = node;
 230     while (RefPtr&lt;Node&gt; n = node.firstChild()) {
 231         removeNode(*n);
 232         insertNodeBefore(*n, node);
 233     }
 234     removeNode(node);
 235 }
 236 
 237 void ReplacementFragment::removeNode(Node&amp; node)
 238 {
 239     ContainerNode* parent = node.nonShadowBoundaryParentNode();
 240     if (!parent)
 241         return;
 242 
 243     parent-&gt;removeChild(node);
 244 }
 245 
 246 void ReplacementFragment::insertNodeBefore(Node&amp; node, Node&amp; refNode)
 247 {
 248     ContainerNode* parent = refNode.nonShadowBoundaryParentNode();
 249     if (!parent)
 250         return;
 251 
 252     parent-&gt;insertBefore(node, &amp;refNode);
 253 }
 254 
<a name="14" id="anc14"></a><span class="line-modified"> 255 Ref&lt;HTMLElement&gt; ReplacementFragment::insertFragmentForTestRendering(Node* rootEditableElement)</span>
 256 {
<a name="15" id="anc15"></a><span class="line-modified"> 257     auto holder = createDefaultParagraphElement(document());</span>

 258 
 259     holder-&gt;appendChild(*m_fragment);
<a name="16" id="anc16"></a><span class="line-modified"> 260     rootEditableElement-&gt;appendChild(holder);</span>
<span class="line-modified"> 261     document().updateLayoutIgnorePendingStylesheets();</span>
 262 
 263     return holder;
 264 }
 265 
 266 void ReplacementFragment::restoreAndRemoveTestRenderingNodesToFragment(StyledElement* holder)
 267 {
 268     if (!holder)
 269         return;
 270 
 271     while (RefPtr&lt;Node&gt; node = holder-&gt;firstChild()) {
 272         holder-&gt;removeChild(*node);
 273         m_fragment-&gt;appendChild(*node);
 274     }
 275 
 276     removeNode(*holder);
 277 }
 278 
 279 void ReplacementFragment::removeUnrenderedNodes(Node* holder)
 280 {
 281     Vector&lt;Ref&lt;Node&gt;&gt; unrendered;
 282 
 283     for (Node* node = holder-&gt;firstChild(); node; node = NodeTraversal::next(*node, holder)) {
 284         if (!isNodeRendered(*node) &amp;&amp; !isTableStructureNode(node))
 285             unrendered.append(*node);
 286     }
 287 
 288     for (auto&amp; node : unrendered)
 289         removeNode(node);
 290 }
 291 
 292 void ReplacementFragment::removeInterchangeNodes(Node* container)
 293 {
 294     m_hasInterchangeNewlineAtStart = false;
 295     m_hasInterchangeNewlineAtEnd = false;
 296 
 297     // Interchange newlines at the &quot;start&quot; of the incoming fragment must be
 298     // either the first node in the fragment or the first leaf in the fragment.
 299     Node* node = container-&gt;firstChild();
 300     while (node) {
 301         if (isInterchangeNewlineNode(node)) {
 302             m_hasInterchangeNewlineAtStart = true;
 303             removeNode(*node);
 304             break;
 305         }
 306         node = node-&gt;firstChild();
 307     }
 308     if (!container-&gt;hasChildNodes())
 309         return;
 310     // Interchange newlines at the &quot;end&quot; of the incoming fragment must be
 311     // either the last node in the fragment or the last leaf in the fragment.
 312     node = container-&gt;lastChild();
 313     while (node) {
 314         if (isInterchangeNewlineNode(node)) {
 315             m_hasInterchangeNewlineAtEnd = true;
 316             removeNode(*node);
 317             break;
 318         }
 319         node = node-&gt;lastChild();
 320     }
 321 
 322     node = container-&gt;firstChild();
 323     while (node) {
 324         RefPtr&lt;Node&gt; next = NodeTraversal::next(*node);
 325         if (isInterchangeConvertedSpaceSpan(node)) {
 326             next = NodeTraversal::nextSkippingChildren(*node);
 327             removeNodePreservingChildren(*node);
 328         }
 329         node = next.get();
 330     }
 331 }
 332 
 333 inline void ReplaceSelectionCommand::InsertedNodes::respondToNodeInsertion(Node* node)
 334 {
 335     if (!node)
 336         return;
 337 
 338     if (!m_firstNodeInserted)
 339         m_firstNodeInserted = node;
 340 
 341     m_lastNodeInserted = node;
 342 }
 343 
 344 inline void ReplaceSelectionCommand::InsertedNodes::willRemoveNodePreservingChildren(Node* node)
 345 {
 346     if (m_firstNodeInserted == node)
 347         m_firstNodeInserted = NodeTraversal::next(*node);
 348     if (m_lastNodeInserted == node) {
 349         m_lastNodeInserted = node-&gt;lastChild() ? node-&gt;lastChild() : NodeTraversal::nextSkippingChildren(*node);
 350         if (!m_lastNodeInserted) {
 351             // If the last inserted node is at the end of the document and doesn&#39;t have any children, look backwards for the
 352             // previous node as the last inserted node, clamping to the first inserted node if needed to ensure that the
 353             // document position of the last inserted node is not behind the first inserted node.
 354             auto* previousNode = NodeTraversal::previousSkippingChildren(*node);
 355             ASSERT(previousNode);
 356             m_lastNodeInserted = m_firstNodeInserted-&gt;compareDocumentPosition(*previousNode) &amp; Node::DOCUMENT_POSITION_FOLLOWING ? previousNode : m_firstNodeInserted;
 357         }
 358     }
 359 }
 360 
 361 inline void ReplaceSelectionCommand::InsertedNodes::willRemoveNode(Node* node)
 362 {
 363     if (m_firstNodeInserted == node &amp;&amp; m_lastNodeInserted == node) {
 364         m_firstNodeInserted = nullptr;
 365         m_lastNodeInserted = nullptr;
 366     } else if (m_firstNodeInserted == node)
 367         m_firstNodeInserted = NodeTraversal::nextSkippingChildren(*m_firstNodeInserted);
 368     else if (m_lastNodeInserted == node)
 369         m_lastNodeInserted = NodeTraversal::previousSkippingChildren(*m_lastNodeInserted);
 370 }
 371 
 372 inline void ReplaceSelectionCommand::InsertedNodes::didReplaceNode(Node* node, Node* newNode)
 373 {
 374     if (m_firstNodeInserted == node)
 375         m_firstNodeInserted = newNode;
 376     if (m_lastNodeInserted == node)
 377         m_lastNodeInserted = newNode;
 378 }
 379 
 380 ReplaceSelectionCommand::ReplaceSelectionCommand(Document&amp; document, RefPtr&lt;DocumentFragment&gt;&amp;&amp; fragment, OptionSet&lt;CommandOption&gt; options, EditAction editAction)
 381     : CompositeEditCommand(document, editAction)
 382     , m_selectReplacement(options &amp; SelectReplacement)
 383     , m_smartReplace(options &amp; SmartReplace)
 384     , m_matchStyle(options &amp; MatchStyle)
 385     , m_documentFragment(fragment)
 386     , m_preventNesting(options &amp; PreventNesting)
 387     , m_movingParagraph(options &amp; MovingParagraph)
 388     , m_sanitizeFragment(options &amp; SanitizeFragment)
 389     , m_shouldMergeEnd(false)
 390     , m_ignoreMailBlockquote(options &amp; IgnoreMailBlockquote)
 391 {
 392 }
 393 
 394 static bool hasMatchingQuoteLevel(VisiblePosition endOfExistingContent, VisiblePosition endOfInsertedContent)
 395 {
 396     Position existing = endOfExistingContent.deepEquivalent();
 397     Position inserted = endOfInsertedContent.deepEquivalent();
 398     bool isInsideMailBlockquote = enclosingNodeOfType(inserted, isMailBlockquote, CanCrossEditingBoundary);
 399     return isInsideMailBlockquote &amp;&amp; (numEnclosingMailBlockquotes(existing) == numEnclosingMailBlockquotes(inserted));
 400 }
 401 
 402 bool ReplaceSelectionCommand::shouldMergeStart(bool selectionStartWasStartOfParagraph, bool fragmentHasInterchangeNewlineAtStart, bool selectionStartWasInsideMailBlockquote)
 403 {
 404     if (m_movingParagraph)
 405         return false;
 406 
 407     VisiblePosition startOfInsertedContent(positionAtStartOfInsertedContent());
 408     VisiblePosition prev = startOfInsertedContent.previous(CannotCrossEditingBoundary);
 409     if (prev.isNull())
 410         return false;
 411 
 412     // When we have matching quote levels, its ok to merge more frequently.
 413     // For a successful merge, we still need to make sure that the inserted content starts with the beginning of a paragraph.
 414     // And we should only merge here if the selection start was inside a mail blockquote.  This prevents against removing a
 415     // blockquote from newly pasted quoted content that was pasted into an unquoted position.  If that unquoted position happens
 416     // to be right after another blockquote, we don&#39;t want to merge and risk stripping a valid block (and newline) from the pasted content.
 417     if (isStartOfParagraph(startOfInsertedContent) &amp;&amp; selectionStartWasInsideMailBlockquote &amp;&amp; hasMatchingQuoteLevel(prev, positionAtEndOfInsertedContent()))
 418         return true;
 419 
 420     return !selectionStartWasStartOfParagraph
 421         &amp;&amp; !fragmentHasInterchangeNewlineAtStart
 422         &amp;&amp; isStartOfParagraph(startOfInsertedContent)
 423         &amp;&amp; !startOfInsertedContent.deepEquivalent().deprecatedNode()-&gt;hasTagName(brTag)
 424         &amp;&amp; shouldMerge(startOfInsertedContent, prev);
 425 }
 426 
 427 bool ReplaceSelectionCommand::shouldMergeEnd(bool selectionEndWasEndOfParagraph)
 428 {
 429     VisiblePosition endOfInsertedContent(positionAtEndOfInsertedContent());
 430     VisiblePosition next = endOfInsertedContent.next(CannotCrossEditingBoundary);
 431     if (next.isNull())
 432         return false;
 433 
 434     return !selectionEndWasEndOfParagraph
 435         &amp;&amp; isEndOfParagraph(endOfInsertedContent)
 436         &amp;&amp; !endOfInsertedContent.deepEquivalent().deprecatedNode()-&gt;hasTagName(brTag)
 437         &amp;&amp; shouldMerge(endOfInsertedContent, next);
 438 }
 439 
 440 static bool isMailPasteAsQuotationNode(const Node* node)
 441 {
 442     return node &amp;&amp; node-&gt;hasTagName(blockquoteTag) &amp;&amp; downcast&lt;Element&gt;(node)-&gt;attributeWithoutSynchronization(classAttr) == ApplePasteAsQuotation;
 443 }
 444 
 445 static bool isHeaderElement(const Node* a)
 446 {
 447     if (!a)
 448         return false;
 449 
 450     return a-&gt;hasTagName(h1Tag)
 451         || a-&gt;hasTagName(h2Tag)
 452         || a-&gt;hasTagName(h3Tag)
 453         || a-&gt;hasTagName(h4Tag)
 454         || a-&gt;hasTagName(h5Tag)
 455         || a-&gt;hasTagName(h6Tag);
 456 }
 457 
 458 static bool haveSameTagName(Node* a, Node* b)
 459 {
 460     return is&lt;Element&gt;(a) &amp;&amp; is&lt;Element&gt;(b) &amp;&amp; downcast&lt;Element&gt;(*a).tagName() == downcast&lt;Element&gt;(*b).tagName();
 461 }
 462 
 463 bool ReplaceSelectionCommand::shouldMerge(const VisiblePosition&amp; source, const VisiblePosition&amp; destination)
 464 {
 465     if (source.isNull() || destination.isNull())
 466         return false;
 467 
 468     auto* sourceNode = source.deepEquivalent().deprecatedNode();
 469     auto* destinationNode = destination.deepEquivalent().deprecatedNode();
 470     auto* sourceBlock = enclosingBlock(sourceNode);
 471     auto* destinationBlock = enclosingBlock(destinationNode);
 472     return !enclosingNodeOfType(source.deepEquivalent(), &amp;isMailPasteAsQuotationNode)
 473         &amp;&amp; sourceBlock
 474         &amp;&amp; (!sourceBlock-&gt;hasTagName(blockquoteTag) || isMailBlockquote(sourceBlock))
 475         &amp;&amp; enclosingListChild(sourceBlock) == enclosingListChild(destinationNode)
 476         &amp;&amp; enclosingTableCell(source.deepEquivalent()) == enclosingTableCell(destination.deepEquivalent())
 477         &amp;&amp; (!isHeaderElement(sourceBlock) || haveSameTagName(sourceBlock, destinationBlock))
 478         // Don&#39;t merge to or from a position before or after a block because it would
 479         // be a no-op and cause infinite recursion.
 480         &amp;&amp; !isBlock(sourceNode) &amp;&amp; !isBlock(destinationNode);
 481 }
 482 
 483 // Style rules that match just inserted elements could change their appearance, like
 484 // a div inserted into a document with div { display:inline; }.
 485 void ReplaceSelectionCommand::removeRedundantStylesAndKeepStyleSpanInline(InsertedNodes&amp; insertedNodes)
 486 {
 487     RefPtr&lt;Node&gt; pastEndNode = insertedNodes.pastLastLeaf();
 488     RefPtr&lt;Node&gt; next;
 489     for (RefPtr&lt;Node&gt; node = insertedNodes.firstNodeInserted(); node &amp;&amp; node != pastEndNode; node = next) {
 490         // FIXME: &lt;rdar://problem/5371536&gt; Style rules that match pasted content can change it&#39;s appearance
 491 
 492         next = NodeTraversal::next(*node);
 493         if (!is&lt;StyledElement&gt;(*node))
 494             continue;
 495 
 496         StyledElement* element = downcast&lt;StyledElement&gt;(node.get());
 497 
 498         const StyleProperties* inlineStyle = element-&gt;inlineStyle();
 499         auto newInlineStyle = EditingStyle::create(inlineStyle);
 500         if (inlineStyle) {
 501             if (is&lt;HTMLElement&gt;(*element)) {
 502                 Vector&lt;QualifiedName&gt; attributes;
 503                 HTMLElement&amp; htmlElement = downcast&lt;HTMLElement&gt;(*element);
 504 
 505                 if (newInlineStyle-&gt;conflictsWithImplicitStyleOfElement(htmlElement)) {
 506                     // e.g. &lt;b style=&quot;font-weight: normal;&quot;&gt; is converted to &lt;span style=&quot;font-weight: normal;&quot;&gt;
 507                     node = replaceElementWithSpanPreservingChildrenAndAttributes(htmlElement);
 508                     element = downcast&lt;StyledElement&gt;(node.get());
 509                     insertedNodes.didReplaceNode(&amp;htmlElement, node.get());
 510                 } else if (newInlineStyle-&gt;extractConflictingImplicitStyleOfAttributes(htmlElement, EditingStyle::PreserveWritingDirection, nullptr, attributes, EditingStyle::DoNotExtractMatchingStyle)) {
 511                     // e.g. &lt;font size=&quot;3&quot; style=&quot;font-size: 20px;&quot;&gt; is converted to &lt;font style=&quot;font-size: 20px;&quot;&gt;
 512                     for (auto&amp; attribute : attributes)
 513                         removeNodeAttribute(*element, attribute);
 514                 }
 515             }
 516 
 517             ContainerNode* context = element-&gt;parentNode();
 518 
 519             // If Mail wraps the fragment with a Paste as Quotation blockquote, or if you&#39;re pasting into a quoted region,
 520             // styles from blockquoteNode are allowed to override those from the source document, see &lt;rdar://problem/4930986&gt; and &lt;rdar://problem/5089327&gt;.
 521             Node* blockquoteNode = isMailPasteAsQuotationNode(context) ? context : enclosingNodeOfType(firstPositionInNode(context), isMailBlockquote, CanCrossEditingBoundary);
 522             if (blockquoteNode)
 523                 newInlineStyle-&gt;removeStyleFromRulesAndContext(*element, document().documentElement());
 524 
 525             newInlineStyle-&gt;removeStyleFromRulesAndContext(*element, context);
 526         }
 527 
 528         if (!inlineStyle || newInlineStyle-&gt;isEmpty()) {
 529             if (isStyleSpanOrSpanWithOnlyStyleAttribute(*element) || isEmptyFontTag(element, AllowNonEmptyStyleAttribute)) {
 530                 insertedNodes.willRemoveNodePreservingChildren(element);
 531                 removeNodePreservingChildren(*element);
 532                 continue;
 533             }
 534             removeNodeAttribute(*element, styleAttr);
 535         } else if (newInlineStyle-&gt;style()-&gt;propertyCount() != inlineStyle-&gt;propertyCount())
 536             setNodeAttribute(*element, styleAttr, newInlineStyle-&gt;style()-&gt;asText());
 537 
 538         // FIXME: Tolerate differences in id, class, and style attributes.
 539         if (element-&gt;parentNode() &amp;&amp; isNonTableCellHTMLBlockElement(element) &amp;&amp; areIdenticalElements(*element, *element-&gt;parentNode())
 540             &amp;&amp; VisiblePosition(firstPositionInNode(element-&gt;parentNode())) == VisiblePosition(firstPositionInNode(element))
 541             &amp;&amp; VisiblePosition(lastPositionInNode(element-&gt;parentNode())) == VisiblePosition(lastPositionInNode(element))) {
 542             insertedNodes.willRemoveNodePreservingChildren(element);
 543             removeNodePreservingChildren(*element);
 544             continue;
 545         }
 546 
 547         if (element-&gt;parentNode() &amp;&amp; element-&gt;parentNode()-&gt;hasRichlyEditableStyle())
 548             removeNodeAttribute(*element, contenteditableAttr);
 549 
 550         // WebKit used to not add display: inline and float: none on copy.
 551         // Keep this code around for backward compatibility
 552         if (isLegacyAppleStyleSpan(element)) {
 553             if (!element-&gt;firstChild()) {
 554                 insertedNodes.willRemoveNodePreservingChildren(element);
 555                 removeNodePreservingChildren(*element);
 556                 continue;
 557             }
 558             // There are other styles that style rules can give to style spans,
 559             // but these are the two important ones because they&#39;ll prevent
 560             // inserted content from appearing in the right paragraph.
 561             // FIXME: Hyatt is concerned that selectively using display:inline will give inconsistent
 562             // results. We already know one issue because td elements ignore their display property
 563             // in quirks mode (which Mail.app is always in). We should look for an alternative.
 564 
 565             // Mutate using the CSSOM wrapper so we get the same event behavior as a script.
 566             if (isBlock(element))
 567                 element-&gt;cssomStyle().setPropertyInternal(CSSPropertyDisplay, &quot;inline&quot;, false);
 568             if (element-&gt;renderer() &amp;&amp; element-&gt;renderer()-&gt;style().isFloating())
 569                 element-&gt;cssomStyle().setPropertyInternal(CSSPropertyFloat, &quot;none&quot;, false);
 570         }
 571     }
 572 }
 573 
<a name="17" id="anc17"></a><span class="line-modified"> 574 static bool isProhibitedParagraphChild(const AtomicString&amp; name)</span>
 575 {
 576     // https://dvcs.w3.org/hg/editing/raw-file/57abe6d3cb60/editing.html#prohibited-paragraph-child
 577     static const auto localNames = makeNeverDestroyed([] {
 578         static const HTMLQualifiedName* const tags[] = {
 579             &amp;addressTag.get(),
 580             &amp;articleTag.get(),
 581             &amp;asideTag.get(),
 582             &amp;blockquoteTag.get(),
 583             &amp;captionTag.get(),
 584             &amp;centerTag.get(),
 585             &amp;colTag.get(),
 586             &amp;colgroupTag.get(),
 587             &amp;ddTag.get(),
 588             &amp;detailsTag.get(),
 589             &amp;dirTag.get(),
 590             &amp;divTag.get(),
 591             &amp;dlTag.get(),
 592             &amp;dtTag.get(),
 593             &amp;fieldsetTag.get(),
 594             &amp;figcaptionTag.get(),
 595             &amp;figureTag.get(),
 596             &amp;footerTag.get(),
 597             &amp;formTag.get(),
 598             &amp;h1Tag.get(),
 599             &amp;h2Tag.get(),
 600             &amp;h3Tag.get(),
 601             &amp;h4Tag.get(),
 602             &amp;h5Tag.get(),
 603             &amp;h6Tag.get(),
 604             &amp;headerTag.get(),
 605             &amp;hgroupTag.get(),
 606             &amp;hrTag.get(),
 607             &amp;liTag.get(),
 608             &amp;listingTag.get(),
 609             &amp;mainTag.get(), // Missing in the specification.
 610             &amp;menuTag.get(),
 611             &amp;navTag.get(),
 612             &amp;olTag.get(),
 613             &amp;pTag.get(),
 614             &amp;plaintextTag.get(),
 615             &amp;preTag.get(),
 616             &amp;sectionTag.get(),
 617             &amp;summaryTag.get(),
 618             &amp;tableTag.get(),
 619             &amp;tbodyTag.get(),
 620             &amp;tdTag.get(),
 621             &amp;tfootTag.get(),
 622             &amp;thTag.get(),
 623             &amp;theadTag.get(),
 624             &amp;trTag.get(),
 625             &amp;ulTag.get(),
 626             &amp;xmpTag.get(),
 627         };
<a name="18" id="anc18"></a><span class="line-modified"> 628         HashSet&lt;AtomicString&gt; set;</span>
 629         for (auto&amp; tag : tags)
 630             set.add(tag-&gt;localName());
 631         return set;
 632     }());
 633     return localNames.get().contains(name);
 634 }
 635 
 636 void ReplaceSelectionCommand::makeInsertedContentRoundTrippableWithHTMLTreeBuilder(InsertedNodes&amp; insertedNodes)
 637 {
 638     RefPtr&lt;Node&gt; pastEndNode = insertedNodes.pastLastLeaf();
 639     RefPtr&lt;Node&gt; next;
 640     for (RefPtr&lt;Node&gt; node = insertedNodes.firstNodeInserted(); node &amp;&amp; node != pastEndNode; node = next) {
 641         next = NodeTraversal::next(*node);
 642 
 643         if (!is&lt;HTMLElement&gt;(*node))
 644             continue;
 645 
 646         if (isProhibitedParagraphChild(downcast&lt;HTMLElement&gt;(*node).localName())) {
 647             if (auto* paragraphElement = enclosingElementWithTag(positionInParentBeforeNode(node.get()), pTag)) {
 648                 auto* parent = paragraphElement-&gt;parentNode();
 649                 if (parent &amp;&amp; parent-&gt;hasEditableStyle())
 650                     moveNodeOutOfAncestor(*node, *paragraphElement, insertedNodes);
 651             }
 652         }
 653 
 654         if (isHeaderElement(node.get())) {
 655             if (auto* headerElement = highestEnclosingNodeOfType(positionInParentBeforeNode(node.get()), isHeaderElement)) {
 656                 if (headerElement-&gt;parentNode() &amp;&amp; headerElement-&gt;parentNode()-&gt;isContentRichlyEditable())
 657                     moveNodeOutOfAncestor(*node, *headerElement, insertedNodes);
 658                 else {
 659                     HTMLElement* newSpanElement = replaceElementWithSpanPreservingChildrenAndAttributes(downcast&lt;HTMLElement&gt;(*node));
 660                     insertedNodes.didReplaceNode(node.get(), newSpanElement);
 661                 }
 662             }
 663         }
 664     }
 665 }
 666 
<a name="19" id="anc19"></a>




 667 void ReplaceSelectionCommand::moveNodeOutOfAncestor(Node&amp; node, Node&amp; ancestor, InsertedNodes&amp; insertedNodes)
 668 {
 669     Ref&lt;Node&gt; protectedNode = node;
 670     Ref&lt;Node&gt; protectedAncestor = ancestor;
 671 
 672     VisiblePosition positionAtEndOfNode = lastPositionInOrAfterNode(&amp;node);
 673     VisiblePosition lastPositionInParagraph = lastPositionInNode(&amp;ancestor);
 674     if (positionAtEndOfNode == lastPositionInParagraph) {
 675         removeNode(node);
 676         if (ancestor.nextSibling())
 677             insertNodeBefore(WTFMove(protectedNode), *ancestor.nextSibling());
 678         else
 679             appendNode(WTFMove(protectedNode), *ancestor.parentNode());
 680     } else {
 681         RefPtr&lt;Node&gt; nodeToSplitTo = splitTreeToNode(node, ancestor, true);
 682         removeNode(node);
 683         insertNodeBefore(WTFMove(protectedNode), *nodeToSplitTo);
 684     }
<a name="20" id="anc20"></a><span class="line-modified"> 685     if (!ancestor.firstChild()) {</span>
















 686         insertedNodes.willRemoveNode(&amp;ancestor);
 687         removeNode(ancestor);
 688     }
 689 }
 690 
<a name="21" id="anc21"></a><span class="line-removed"> 691 static inline bool hasRenderedText(const Text&amp; text)</span>
<span class="line-removed"> 692 {</span>
<span class="line-removed"> 693     return text.renderer() &amp;&amp; text.renderer()-&gt;hasRenderedText();</span>
<span class="line-removed"> 694 }</span>
<span class="line-removed"> 695 </span>
 696 void ReplaceSelectionCommand::removeUnrenderedTextNodesAtEnds(InsertedNodes&amp; insertedNodes)
 697 {
 698     document().updateLayoutIgnorePendingStylesheets();
 699 
 700     Node* lastLeafInserted = insertedNodes.lastLeafInserted();
 701     if (is&lt;Text&gt;(lastLeafInserted) &amp;&amp; !hasRenderedText(downcast&lt;Text&gt;(*lastLeafInserted))
 702         &amp;&amp; !enclosingElementWithTag(firstPositionInOrBeforeNode(lastLeafInserted), selectTag)
 703         &amp;&amp; !enclosingElementWithTag(firstPositionInOrBeforeNode(lastLeafInserted), scriptTag)) {
 704         insertedNodes.willRemoveNode(lastLeafInserted);
 705         removeNode(*lastLeafInserted);
 706     }
 707 
 708     // We don&#39;t have to make sure that firstNodeInserted isn&#39;t inside a select or script element
 709     // because it is a top level node in the fragment and the user can&#39;t insert into those elements.
 710     Node* firstNodeInserted = insertedNodes.firstNodeInserted();
 711     if (is&lt;Text&gt;(firstNodeInserted) &amp;&amp; !hasRenderedText(downcast&lt;Text&gt;(*firstNodeInserted))) {
 712         insertedNodes.willRemoveNode(firstNodeInserted);
 713         removeNode(*firstNodeInserted);
 714     }
 715 }
 716 
 717 VisiblePosition ReplaceSelectionCommand::positionAtEndOfInsertedContent() const
 718 {
 719     // FIXME: Why is this hack here?  What&#39;s special about &lt;select&gt; tags?
 720     auto* enclosingSelect = enclosingElementWithTag(m_endOfInsertedContent, selectTag);
 721     return enclosingSelect ? lastPositionInOrAfterNode(enclosingSelect) : m_endOfInsertedContent;
 722 }
 723 
 724 VisiblePosition ReplaceSelectionCommand::positionAtStartOfInsertedContent() const
 725 {
 726     return m_startOfInsertedContent;
 727 }
 728 
<a name="22" id="anc22"></a><span class="line-removed"> 729 static void removeHeadContents(ReplacementFragment&amp; fragment)</span>
<span class="line-removed"> 730 {</span>
<span class="line-removed"> 731     if (fragment.isEmpty())</span>
<span class="line-removed"> 732         return;</span>
<span class="line-removed"> 733 </span>
<span class="line-removed"> 734     Vector&lt;Element*&gt; toRemove;</span>
<span class="line-removed"> 735 </span>
<span class="line-removed"> 736     auto it = descendantsOfType&lt;Element&gt;(*fragment.fragment()).begin();</span>
<span class="line-removed"> 737     auto end = descendantsOfType&lt;Element&gt;(*fragment.fragment()).end();</span>
<span class="line-removed"> 738     while (it != end) {</span>
<span class="line-removed"> 739         if (is&lt;HTMLBaseElement&gt;(*it) || is&lt;HTMLLinkElement&gt;(*it) || is&lt;HTMLMetaElement&gt;(*it) || is&lt;HTMLTitleElement&gt;(*it)</span>
<span class="line-removed"> 740             || (is&lt;HTMLStyleElement&gt;(*it) &amp;&amp; it-&gt;getAttribute(classAttr) != WebKitMSOListQuirksStyle)) {</span>
<span class="line-removed"> 741             toRemove.append(&amp;*it);</span>
<span class="line-removed"> 742             it.traverseNextSkippingChildren();</span>
<span class="line-removed"> 743             continue;</span>
<span class="line-removed"> 744         }</span>
<span class="line-removed"> 745         ++it;</span>
<span class="line-removed"> 746     }</span>
<span class="line-removed"> 747 </span>
<span class="line-removed"> 748     for (auto&amp; element : toRemove)</span>
<span class="line-removed"> 749         fragment.removeNode(*element);</span>
<span class="line-removed"> 750 }</span>
<span class="line-removed"> 751 </span>
 752 // Remove style spans before insertion if they are unnecessary.  It&#39;s faster because we&#39;ll
 753 // avoid doing a layout.
 754 static bool handleStyleSpansBeforeInsertion(ReplacementFragment&amp; fragment, const Position&amp; insertionPos)
 755 {
 756     Node* topNode = fragment.firstChild();
 757 
 758     // Handling the case where we are doing Paste as Quotation or pasting into quoted content is more complicated (see handleStyleSpans)
 759     // and doesn&#39;t receive the optimization.
 760     if (isMailPasteAsQuotationNode(topNode) || enclosingNodeOfType(firstPositionInOrBeforeNode(topNode), isMailBlockquote, CanCrossEditingBoundary))
 761         return false;
 762 
 763     // Either there are no style spans in the fragment or a WebKit client has added content to the fragment
 764     // before inserting it.  Look for and handle style spans after insertion.
 765     if (!isLegacyAppleStyleSpan(topNode))
 766         return false;
 767 
 768     Node* wrappingStyleSpan = topNode;
 769     auto styleAtInsertionPos = EditingStyle::create(insertionPos.parentAnchoredEquivalent());
 770     String styleText = styleAtInsertionPos-&gt;style()-&gt;asText();
 771 
 772     // FIXME: This string comparison is a naive way of comparing two styles.
 773     // We should be taking the diff and check that the diff is empty.
 774     if (styleText != downcast&lt;Element&gt;(*wrappingStyleSpan).getAttribute(styleAttr))
 775         return false;
 776 
 777     fragment.removeNodePreservingChildren(*wrappingStyleSpan);
 778     return true;
 779 }
 780 
 781 // At copy time, WebKit wraps copied content in a span that contains the source document&#39;s
 782 // default styles.  If the copied Range inherits any other styles from its ancestors, we put
 783 // those styles on a second span.
 784 // This function removes redundant styles from those spans, and removes the spans if all their
 785 // styles are redundant.
 786 // We should remove the Apple-style-span class when we&#39;re done, see &lt;rdar://problem/5685600&gt;.
 787 // We should remove styles from spans that are overridden by all of their children, either here
 788 // or at copy time.
 789 void ReplaceSelectionCommand::handleStyleSpans(InsertedNodes&amp; insertedNodes)
 790 {
 791     HTMLElement* wrappingStyleSpan = nullptr;
 792     // The style span that contains the source document&#39;s default style should be at
 793     // the top of the fragment, but Mail sometimes adds a wrapper (for Paste As Quotation),
 794     // so search for the top level style span instead of assuming it&#39;s at the top.
 795     for (Node* node = insertedNodes.firstNodeInserted(); node; node = NodeTraversal::next(*node)) {
 796         if (isLegacyAppleStyleSpan(node)) {
 797             wrappingStyleSpan = downcast&lt;HTMLElement&gt;(node);
 798             break;
 799         }
 800     }
 801 
 802     // There might not be any style spans if we&#39;re pasting from another application or if
 803     // we are here because of a document.execCommand(&quot;InsertHTML&quot;, ...) call.
 804     if (!wrappingStyleSpan)
 805         return;
 806 
 807     auto style = EditingStyle::create(wrappingStyleSpan-&gt;inlineStyle());
 808     ContainerNode* context = wrappingStyleSpan-&gt;parentNode();
 809 
 810     // If Mail wraps the fragment with a Paste as Quotation blockquote, or if you&#39;re pasting into a quoted region,
 811     // styles from blockquoteNode are allowed to override those from the source document, see &lt;rdar://problem/4930986&gt; and &lt;rdar://problem/5089327&gt;.
 812     Node* blockquoteNode = isMailPasteAsQuotationNode(context) ? context : enclosingNodeOfType(firstPositionInNode(context), isMailBlockquote, CanCrossEditingBoundary);
 813     if (blockquoteNode)
 814         context = document().documentElement();
 815 
 816     // This operation requires that only editing styles to be removed from sourceDocumentStyle.
 817     style-&gt;prepareToApplyAt(firstPositionInNode(context));
 818 
 819     // Remove block properties in the span&#39;s style. This prevents properties that probably have no effect
 820     // currently from affecting blocks later if the style is cloned for a new block element during a future
 821     // editing operation.
 822     // FIXME: They *can* have an effect currently if blocks beneath the style span aren&#39;t individually marked
 823     // with block styles by the editing engine used to style them.  WebKit doesn&#39;t do this, but others might.
 824     style-&gt;removeBlockProperties();
 825 
 826     if (style-&gt;isEmpty() || !wrappingStyleSpan-&gt;firstChild()) {
 827         insertedNodes.willRemoveNodePreservingChildren(wrappingStyleSpan);
 828         removeNodePreservingChildren(*wrappingStyleSpan);
 829     } else
 830         setNodeAttribute(*wrappingStyleSpan, styleAttr, style-&gt;style()-&gt;asText());
 831 }
 832 
 833 void ReplaceSelectionCommand::mergeEndIfNeeded()
 834 {
 835     if (!m_shouldMergeEnd)
 836         return;
 837 
 838     VisiblePosition startOfInsertedContent(positionAtStartOfInsertedContent());
 839     VisiblePosition endOfInsertedContent(positionAtEndOfInsertedContent());
 840 
 841     // Bail to avoid infinite recursion.
 842     if (m_movingParagraph) {
 843         ASSERT_NOT_REACHED();
 844         return;
 845     }
 846 
 847     // Merging two paragraphs will destroy the moved one&#39;s block styles.  Always move the end of inserted forward
 848     // to preserve the block style of the paragraph already in the document, unless the paragraph to move would
 849     // include the what was the start of the selection that was pasted into, so that we preserve that paragraph&#39;s
 850     // block styles.
 851     bool mergeForward = !(inSameParagraph(startOfInsertedContent, endOfInsertedContent) &amp;&amp; !isStartOfParagraph(startOfInsertedContent));
 852 
 853     VisiblePosition destination = mergeForward ? endOfInsertedContent.next() : endOfInsertedContent;
 854     VisiblePosition startOfParagraphToMove = mergeForward ? startOfParagraph(endOfInsertedContent) : endOfInsertedContent.next();
 855 
 856     // Merging forward could result in deleting the destination anchor node.
 857     // To avoid this, we add a placeholder node before the start of the paragraph.
 858     if (endOfParagraph(startOfParagraphToMove) == destination) {
 859         auto placeholder = HTMLBRElement::create(document());
 860         auto* placeholderPtr = placeholder.ptr();
 861         insertNodeBefore(WTFMove(placeholder), *startOfParagraphToMove.deepEquivalent().deprecatedNode());
 862         destination = VisiblePosition(positionBeforeNode(placeholderPtr));
 863     }
 864 
 865     moveParagraph(startOfParagraphToMove, endOfParagraph(startOfParagraphToMove), destination);
 866 
 867     // Merging forward will remove m_endOfInsertedContent from the document.
 868     if (mergeForward) {
 869         if (m_startOfInsertedContent.isOrphan())
 870             m_startOfInsertedContent = endingSelection().visibleStart().deepEquivalent();
 871          m_endOfInsertedContent = endingSelection().visibleEnd().deepEquivalent();
 872         // If we merged text nodes, m_endOfInsertedContent could be null. If this is the case, we use m_startOfInsertedContent.
 873         if (m_endOfInsertedContent.isNull())
 874             m_endOfInsertedContent = m_startOfInsertedContent;
 875     }
 876 }
 877 
 878 static Node* enclosingInline(Node* node)
 879 {
 880     while (ContainerNode* parent = node-&gt;parentNode()) {
 881         if (isBlockFlowElement(*parent) || parent-&gt;hasTagName(bodyTag))
 882             return node;
 883         // Stop if any previous sibling is a block.
 884         for (Node* sibling = node-&gt;previousSibling(); sibling; sibling = sibling-&gt;previousSibling()) {
 885             if (isBlockFlowElement(*sibling))
 886                 return node;
 887         }
 888         node = parent;
 889     }
 890     return node;
 891 }
 892 
 893 static bool isInlineNodeWithStyle(const Node* node)
 894 {
 895     // We don&#39;t want to skip over any block elements.
 896     if (isBlock(node))
 897         return false;
 898 
 899     if (!node-&gt;isHTMLElement())
 900         return false;
 901 
 902     // We can skip over elements whose class attribute is
 903     // one of our internal classes.
 904     const HTMLElement* element = static_cast&lt;const HTMLElement*&gt;(node);
<a name="23" id="anc23"></a><span class="line-modified"> 905     const AtomicString&amp; classAttributeValue = element-&gt;attributeWithoutSynchronization(classAttr);</span>
 906     if (classAttributeValue == AppleTabSpanClass
 907         || classAttributeValue == AppleConvertedSpace
 908         || classAttributeValue == ApplePasteAsQuotation)
 909         return true;
 910 
 911     return EditingStyle::elementIsStyledSpanOrHTMLEquivalent(*element);
 912 }
 913 
 914 inline Node* nodeToSplitToAvoidPastingIntoInlineNodesWithStyle(const Position&amp; insertionPos)
 915 {
 916     Node* containgBlock = enclosingBlock(insertionPos.containerNode());
 917     return highestEnclosingNodeOfType(insertionPos, isInlineNodeWithStyle, CannotCrossEditingBoundary, containgBlock);
 918 }
 919 
 920 bool ReplaceSelectionCommand::willApplyCommand()
 921 {
<a name="24" id="anc24"></a><span class="line-removed"> 922     ensureReplacementFragment();</span>
 923     m_documentFragmentPlainText = m_documentFragment-&gt;textContent();
 924     m_documentFragmentHTMLMarkup = serializeFragment(*m_documentFragment, SerializedNodes::SubtreeIncludingNode);
<a name="25" id="anc25"></a>
 925     return CompositeEditCommand::willApplyCommand();
 926 }
 927 
<a name="26" id="anc26"></a>











 928 void ReplaceSelectionCommand::doApply()
 929 {
 930     VisibleSelection selection = endingSelection();
 931     ASSERT(selection.isCaretOrRange());
 932     ASSERT(selection.start().deprecatedNode());
 933     if (selection.isNoneOrOrphaned() || !selection.start().deprecatedNode() || !selection.isContentEditable())
 934         return;
 935 
 936     // In plain text only regions, we create style-less fragments, so the inserted content will automatically
 937     // match the style of the surrounding area and so we can avoid unnecessary work below for m_matchStyle.
 938     if (!selection.isContentRichlyEditable())
 939         m_matchStyle = false;
 940 
 941     ReplacementFragment&amp; fragment = *ensureReplacementFragment();
 942     if (performTrivialReplace(fragment))
 943         return;
 944 
 945     // We can skip matching the style if the selection is plain text.
 946     if ((selection.start().deprecatedNode()-&gt;renderer() &amp;&amp; selection.start().deprecatedNode()-&gt;renderer()-&gt;style().userModify() == UserModify::ReadWritePlaintextOnly)
 947         &amp;&amp; (selection.end().deprecatedNode()-&gt;renderer() &amp;&amp; selection.end().deprecatedNode()-&gt;renderer()-&gt;style().userModify() == UserModify::ReadWritePlaintextOnly))
 948         m_matchStyle = false;
 949 
 950     if (m_matchStyle) {
 951         m_insertionStyle = EditingStyle::create(selection.start());
 952         m_insertionStyle-&gt;mergeTypingStyle(document());
 953     }
 954 
 955     VisiblePosition visibleStart = selection.visibleStart();
 956     VisiblePosition visibleEnd = selection.visibleEnd();
 957 
 958     bool selectionEndWasEndOfParagraph = isEndOfParagraph(visibleEnd);
 959     bool selectionStartWasStartOfParagraph = isStartOfParagraph(visibleStart);
 960 
 961     Node* startBlock = enclosingBlock(visibleStart.deepEquivalent().deprecatedNode());
 962 
 963     Position insertionPos = selection.start();
 964     bool shouldHandleMailBlockquote = enclosingNodeOfType(insertionPos, isMailBlockquote, CanCrossEditingBoundary) &amp;&amp; !m_ignoreMailBlockquote;
 965     bool selectionIsPlainText = !selection.isContentRichlyEditable();
 966     Element* currentRoot = selection.rootEditableElement();
 967 
 968     if ((selectionStartWasStartOfParagraph &amp;&amp; selectionEndWasEndOfParagraph &amp;&amp; !shouldHandleMailBlockquote)
 969         || startBlock == currentRoot || isListItem(startBlock) || selectionIsPlainText)
 970         m_preventNesting = false;
 971 
 972     if (selection.isRange()) {
 973         // When the end of the selection being pasted into is at the end of a paragraph, and that selection
 974         // spans multiple blocks, not merging may leave an empty line.
 975         // When the start of the selection being pasted into is at the start of a block, not merging
 976         // will leave hanging block(s).
 977         // Merge blocks if the start of the selection was in a Mail blockquote, since we handle
 978         // that case specially to prevent nesting.
 979         bool mergeBlocksAfterDelete = shouldHandleMailBlockquote || isEndOfParagraph(visibleEnd) || isStartOfBlock(visibleStart);
 980         // FIXME: We should only expand to include fully selected special elements if we are copying a
 981         // selection and pasting it on top of itself.
 982         // FIXME: capturing the content of this delete would allow a replace accessibility notification instead of a simple insert
 983         deleteSelection(false, mergeBlocksAfterDelete, true, false, true);
 984         visibleStart = endingSelection().visibleStart();
 985         if (fragment.hasInterchangeNewlineAtStart()) {
 986             if (isEndOfParagraph(visibleStart) &amp;&amp; !isStartOfParagraph(visibleStart)) {
 987                 if (!isEndOfEditableOrNonEditableContent(visibleStart))
 988                     setEndingSelection(visibleStart.next());
 989             } else
 990                 insertParagraphSeparator();
 991         }
 992         insertionPos = endingSelection().start();
 993     } else {
 994         ASSERT(selection.isCaret());
 995         if (fragment.hasInterchangeNewlineAtStart()) {
 996             VisiblePosition next = visibleStart.next(CannotCrossEditingBoundary);
 997             if (isEndOfParagraph(visibleStart) &amp;&amp; !isStartOfParagraph(visibleStart) &amp;&amp; next.isNotNull())
 998                 setEndingSelection(next);
 999             else  {
1000                 insertParagraphSeparator();
1001                 visibleStart = endingSelection().visibleStart();
1002             }
1003         }
1004         // We split the current paragraph in two to avoid nesting the blocks from the fragment inside the current block.
1005         // For example paste &lt;div&gt;foo&lt;/div&gt;&lt;div&gt;bar&lt;/div&gt;&lt;div&gt;baz&lt;/div&gt; into &lt;div&gt;x^x&lt;/div&gt;, where ^ is the caret.
1006         // As long as the  div styles are the same, visually you&#39;d expect: &lt;div&gt;xbar&lt;/div&gt;&lt;div&gt;bar&lt;/div&gt;&lt;div&gt;bazx&lt;/div&gt;,
1007         // not &lt;div&gt;xbar&lt;div&gt;bar&lt;/div&gt;&lt;div&gt;bazx&lt;/div&gt;&lt;/div&gt;.
1008         // Don&#39;t do this if the selection started in a Mail blockquote.
1009         if (m_preventNesting &amp;&amp; !shouldHandleMailBlockquote &amp;&amp; !isEndOfParagraph(visibleStart) &amp;&amp; !isStartOfParagraph(visibleStart)) {
1010             insertParagraphSeparator();
1011             setEndingSelection(endingSelection().visibleStart().previous());
1012         }
1013         insertionPos = endingSelection().start();
1014     }
1015 
1016     // We don&#39;t want any of the pasted content to end up nested in a Mail blockquote, so first break
1017     // out of any surrounding Mail blockquotes. Unless we&#39;re inserting in a table, in which case
1018     // breaking the blockquote will prevent the content from actually being inserted in the table.
1019     if (shouldHandleMailBlockquote &amp;&amp; m_preventNesting &amp;&amp; !(enclosingNodeOfType(insertionPos, &amp;isTableStructureNode))) {
1020         applyCommandToComposite(BreakBlockquoteCommand::create(document()));
1021         // This will leave a br between the split.
1022         Node* br = endingSelection().start().deprecatedNode();
1023         ASSERT(br-&gt;hasTagName(brTag));
1024         // Insert content between the two blockquotes, but remove the br (since it was just a placeholder).
1025         insertionPos = positionInParentBeforeNode(br);
1026         removeNode(*br);
1027     }
1028 
1029     // Inserting content could cause whitespace to collapse, e.g. inserting &lt;div&gt;foo&lt;/div&gt; into hello^ world.
1030     prepareWhitespaceAtPositionForSplit(insertionPos);
1031 
1032     // If the downstream node has been removed there&#39;s no point in continuing.
1033     if (!insertionPos.downstream().deprecatedNode())
1034       return;
1035 
1036     // NOTE: This would be an incorrect usage of downstream() if downstream() were changed to mean the last position after
1037     // p that maps to the same visible position as p (since in the case where a br is at the end of a block and collapsed
1038     // away, there are positions after the br which map to the same visible position as [br, 0]).
1039     RefPtr&lt;Node&gt; endBR = insertionPos.downstream().deprecatedNode()-&gt;hasTagName(brTag) ? insertionPos.downstream().deprecatedNode() : nullptr;
1040     VisiblePosition originalVisPosBeforeEndBR;
1041     if (endBR)
1042         originalVisPosBeforeEndBR = VisiblePosition(positionBeforeNode(endBR.get()), DOWNSTREAM).previous();
1043 
1044     RefPtr&lt;Node&gt; insertionBlock = enclosingBlock(insertionPos.deprecatedNode());
1045 
1046     // Adjust insertionPos to prevent nesting.
1047     // If the start was in a Mail blockquote, we will have already handled adjusting insertionPos above.
1048     if (m_preventNesting &amp;&amp; insertionBlock &amp;&amp; !isTableCell(insertionBlock.get()) &amp;&amp; !shouldHandleMailBlockquote) {
1049         ASSERT(insertionBlock != currentRoot);
1050         VisiblePosition visibleInsertionPos(insertionPos);
1051         if (isEndOfBlock(visibleInsertionPos) &amp;&amp; !(isStartOfBlock(visibleInsertionPos) &amp;&amp; fragment.hasInterchangeNewlineAtEnd()))
1052             insertionPos = positionInParentAfterNode(insertionBlock.get());
1053         else if (isStartOfBlock(visibleInsertionPos))
1054             insertionPos = positionInParentBeforeNode(insertionBlock.get());
1055     }
1056 
1057     // Paste at start or end of link goes outside of link.
1058     insertionPos = positionAvoidingSpecialElementBoundary(insertionPos);
1059 
1060     // FIXME: Can this wait until after the operation has been performed?  There doesn&#39;t seem to be
1061     // any work performed after this that queries or uses the typing style.
1062     frame().selection().clearTypingStyle();
1063 
1064     // We don&#39;t want the destination to end up inside nodes that weren&#39;t selected.  To avoid that, we move the
1065     // position forward without changing the visible position so we&#39;re still at the same visible location, but
1066     // outside of preceding tags.
1067     insertionPos = positionAvoidingPrecedingNodes(insertionPos);
1068 
1069     // Paste into run of tabs splits the tab span.
1070     insertionPos = positionOutsideTabSpan(insertionPos);
1071 
<a name="27" id="anc27"></a>

1072     bool handledStyleSpans = handleStyleSpansBeforeInsertion(fragment, insertionPos);
1073 
1074     // We&#39;re finished if there is nothing to add.
1075     if (fragment.isEmpty() || !fragment.firstChild())
1076         return;
1077 
1078     // If we are not trying to match the destination style we prefer a position
1079     // that is outside inline elements that provide style.
1080     // This way we can produce a less verbose markup.
1081     // We can skip this optimization for fragments not wrapped in one of
1082     // our style spans and for positions inside list items
1083     // since insertAsListItems already does the right thing.
1084     if (!m_matchStyle &amp;&amp; !enclosingList(insertionPos.containerNode())) {
1085         if (insertionPos.containerNode()-&gt;isTextNode() &amp;&amp; insertionPos.offsetInContainerNode() &amp;&amp; !insertionPos.atLastEditingPositionForNode()) {
1086             splitTextNode(*insertionPos.containerText(), insertionPos.offsetInContainerNode());
1087             insertionPos = firstPositionInNode(insertionPos.containerNode());
1088         }
1089 
1090         if (RefPtr&lt;Node&gt; nodeToSplitTo = nodeToSplitToAvoidPastingIntoInlineNodesWithStyle(insertionPos)) {
1091             if (insertionPos.containerNode() != nodeToSplitTo-&gt;parentNode()) {
1092                 Node* splitStart = insertionPos.computeNodeAfterPosition();
1093                 if (!splitStart)
1094                     splitStart = insertionPos.containerNode();
1095                 ASSERT(splitStart);
1096                 nodeToSplitTo = splitTreeToNode(*splitStart, *nodeToSplitTo-&gt;parentNode()).get();
1097                 insertionPos = positionInParentBeforeNode(nodeToSplitTo.get());
1098             }
1099         }
1100     }
1101 
1102     // FIXME: When pasting rich content we&#39;re often prevented from heading down the fast path by style spans.  Try
1103     // again here if they&#39;ve been removed.
1104 
1105     // 1) Insert the content.
1106     // 2) Remove redundant styles and style tags, this inner &lt;b&gt; for example: &lt;b&gt;foo &lt;b&gt;bar&lt;/b&gt; baz&lt;/b&gt;.
1107     // 3) Merge the start of the added content with the content before the position being pasted into.
1108     // 4) Do one of the following: a) expand the last br if the fragment ends with one and it collapsed,
1109     // b) merge the last paragraph of the incoming fragment with the paragraph that contained the
1110     // end of the selection that was pasted into, or c) handle an interchange newline at the end of the
1111     // incoming fragment.
1112     // 5) Add spaces for smart replace.
1113     // 6) Select the replacement if requested, and match style if requested.
1114 
1115     InsertedNodes insertedNodes;
1116     RefPtr&lt;Node&gt; refNode = fragment.firstChild();
1117     RefPtr&lt;Node&gt; node = refNode-&gt;nextSibling();
1118 
1119     if (refNode)
1120         fragment.removeNode(*refNode);
1121 
1122     Node* blockStart = enclosingBlock(insertionPos.deprecatedNode());
<a name="28" id="anc28"></a><span class="line-modified">1123     if ((isListHTMLElement(refNode.get()) || (isLegacyAppleStyleSpan(refNode.get()) &amp;&amp; isListHTMLElement(refNode-&gt;firstChild())))</span>
<span class="line-modified">1124         &amp;&amp; blockStart &amp;&amp; blockStart-&gt;renderer()-&gt;isListItem())</span>

1125         refNode = insertAsListItems(downcast&lt;HTMLElement&gt;(*refNode), blockStart, insertionPos, insertedNodes);
1126     else {
1127         insertNodeAt(*refNode, insertionPos);
1128         insertedNodes.respondToNodeInsertion(refNode.get());
1129     }
1130 
1131     // Mutation events (bug 22634) may have already removed the inserted content
1132     if (!refNode-&gt;isConnected())
1133         return;
1134 
1135     bool plainTextFragment = isPlainTextMarkup(refNode.get());
1136 
1137     while (node) {
1138         RefPtr&lt;Node&gt; next = node-&gt;nextSibling();
1139         fragment.removeNode(*node);
1140         insertNodeAfter(*node, *refNode);
1141         insertedNodes.respondToNodeInsertion(node.get());
1142 
1143         // Mutation events (bug 22634) may have already removed the inserted content
1144         if (!node-&gt;isConnected())
1145             return;
1146 
1147         refNode = node;
1148         if (node &amp;&amp; plainTextFragment)
1149             plainTextFragment = isPlainTextMarkup(node.get());
1150         node = next;
1151     }
1152 
1153     if (insertedNodes.isEmpty())
1154         return;
1155     removeUnrenderedTextNodesAtEnds(insertedNodes);
1156 
1157     if (!handledStyleSpans)
1158         handleStyleSpans(insertedNodes);
1159 
1160     // Mutation events (bug 20161) may have already removed the inserted content
1161     if (insertedNodes.isEmpty())
1162         return;
1163     if (!insertedNodes.firstNodeInserted()-&gt;isConnected())
1164         return;
1165 
1166     VisiblePosition startOfInsertedContent = firstPositionInOrBeforeNode(insertedNodes.firstNodeInserted());
1167 
1168     // We inserted before the insertionBlock to prevent nesting, and the content before the insertionBlock wasn&#39;t in its own block and
1169     // didn&#39;t have a br after it, so the inserted content ended up in the same paragraph.
1170     if (!startOfInsertedContent.isNull() &amp;&amp; insertionBlock &amp;&amp; insertionPos.deprecatedNode() == insertionBlock-&gt;parentNode() &amp;&amp; (unsigned)insertionPos.deprecatedEditingOffset() &lt; insertionBlock-&gt;computeNodeIndex() &amp;&amp; !isStartOfParagraph(startOfInsertedContent))
1171         insertNodeAt(HTMLBRElement::create(document()), startOfInsertedContent.deepEquivalent());
1172 
1173     if (endBR &amp;&amp; (plainTextFragment || shouldRemoveEndBR(endBR.get(), originalVisPosBeforeEndBR))) {
1174         RefPtr&lt;Node&gt; parent = endBR-&gt;parentNode();
1175         insertedNodes.willRemoveNode(endBR.get());
1176         removeNode(*endBR);
1177         if (Node* nodeToRemove = highestNodeToRemoveInPruning(parent.get())) {
1178             insertedNodes.willRemoveNode(nodeToRemove);
1179             removeNode(*nodeToRemove);
1180         }
1181     }
1182 
1183     makeInsertedContentRoundTrippableWithHTMLTreeBuilder(insertedNodes);
1184     if (insertedNodes.isEmpty())
1185         return;
1186 
1187     removeRedundantStylesAndKeepStyleSpanInline(insertedNodes);
1188     if (insertedNodes.isEmpty())
1189         return;
1190 
1191     if (m_sanitizeFragment)
1192         applyCommandToComposite(SimplifyMarkupCommand::create(document(), insertedNodes.firstNodeInserted(), insertedNodes.pastLastLeaf()));
1193 
1194     // Setup m_startOfInsertedContent and m_endOfInsertedContent. This should be the last two lines of code that access insertedNodes.
1195     m_startOfInsertedContent = firstPositionInOrBeforeNode(insertedNodes.firstNodeInserted());
1196     m_endOfInsertedContent = lastPositionInOrAfterNode(insertedNodes.lastLeafInserted());
1197 
1198     // Determine whether or not we should merge the end of inserted content with what&#39;s after it before we do
1199     // the start merge so that the start merge doesn&#39;t effect our decision.
1200     m_shouldMergeEnd = shouldMergeEnd(selectionEndWasEndOfParagraph);
1201 
1202     if (shouldMergeStart(selectionStartWasStartOfParagraph, fragment.hasInterchangeNewlineAtStart(), shouldHandleMailBlockquote)) {
1203         VisiblePosition startOfParagraphToMove = positionAtStartOfInsertedContent();
1204         VisiblePosition destination = startOfParagraphToMove.previous();
1205         // We need to handle the case where we need to merge the end
1206         // but our destination node is inside an inline that is the last in the block.
1207         // We insert a placeholder before the newly inserted content to avoid being merged into the inline.
1208         Node* destinationNode = destination.deepEquivalent().deprecatedNode();
1209         if (m_shouldMergeEnd &amp;&amp; destinationNode != enclosingInline(destinationNode) &amp;&amp; enclosingInline(destinationNode)-&gt;nextSibling())
1210             insertNodeBefore(HTMLBRElement::create(document()), *refNode);
1211 
1212         // Merging the first paragraph of inserted content with the content that came
1213         // before the selection that was pasted into would also move content after
1214         // the selection that was pasted into if: only one paragraph was being pasted,
1215         // and it was not wrapped in a block, the selection that was pasted into ended
1216         // at the end of a block and the next paragraph didn&#39;t start at the start of a block.
1217         // Insert a line break just after the inserted content to separate it from what
1218         // comes after and prevent that from happening.
1219         VisiblePosition endOfInsertedContent = positionAtEndOfInsertedContent();
1220         if (startOfParagraph(endOfInsertedContent) == startOfParagraphToMove) {
1221             insertNodeAt(HTMLBRElement::create(document()), endOfInsertedContent.deepEquivalent());
1222             // Mutation events (bug 22634) triggered by inserting the &lt;br&gt; might have removed the content we&#39;re about to move
1223             if (!startOfParagraphToMove.deepEquivalent().anchorNode()-&gt;isConnected())
1224                 return;
1225         }
1226 
1227         // FIXME: Maintain positions for the start and end of inserted content instead of keeping nodes.  The nodes are
1228         // only ever used to create positions where inserted content starts/ends.
1229         moveParagraph(startOfParagraphToMove, endOfParagraph(startOfParagraphToMove), destination);
1230         m_startOfInsertedContent = endingSelection().visibleStart().deepEquivalent().downstream();
1231         if (m_endOfInsertedContent.isOrphan())
1232             m_endOfInsertedContent = endingSelection().visibleEnd().deepEquivalent().upstream();
1233     }
1234 
1235     Position lastPositionToSelect;
1236     if (fragment.hasInterchangeNewlineAtEnd()) {
1237         VisiblePosition endOfInsertedContent = positionAtEndOfInsertedContent();
1238         VisiblePosition next = endOfInsertedContent.next(CannotCrossEditingBoundary);
1239 
1240         if (selectionEndWasEndOfParagraph || !isEndOfParagraph(endOfInsertedContent) || next.isNull()) {
1241             if (!isStartOfParagraph(endOfInsertedContent)) {
1242                 setEndingSelection(endOfInsertedContent);
1243                 Node* enclosingNode = enclosingBlock(endOfInsertedContent.deepEquivalent().deprecatedNode());
1244                 if (isListItem(enclosingNode)) {
1245                     auto newListItem = HTMLLIElement::create(document());
1246                     insertNodeAfter(newListItem.copyRef(), *enclosingNode);
1247                     setEndingSelection(VisiblePosition(firstPositionInNode(newListItem.ptr())));
1248                 } else {
1249                     // Use a default paragraph element (a plain div) for the empty paragraph, using the last paragraph
1250                     // block&#39;s style seems to annoy users.
1251                     insertParagraphSeparator(true, !shouldHandleMailBlockquote &amp;&amp; highestEnclosingNodeOfType(endOfInsertedContent.deepEquivalent(),
1252                         isMailBlockquote, CannotCrossEditingBoundary, insertedNodes.firstNodeInserted()-&gt;parentNode()));
1253                 }
1254 
1255                 // Select up to the paragraph separator that was added.
1256                 lastPositionToSelect = endingSelection().visibleStart().deepEquivalent();
1257                 updateNodesInserted(lastPositionToSelect.deprecatedNode());
1258             }
1259         } else {
1260             // Select up to the beginning of the next paragraph.
1261             lastPositionToSelect = next.deepEquivalent().downstream();
1262         }
1263 
1264     } else
1265         mergeEndIfNeeded();
1266 
1267     if (Node* mailBlockquote = enclosingNodeOfType(positionAtStartOfInsertedContent().deepEquivalent(), isMailPasteAsQuotationNode))
1268         removeNodeAttribute(downcast&lt;Element&gt;(*mailBlockquote), classAttr);
1269 
1270     if (shouldPerformSmartReplace())
1271         addSpacesForSmartReplace();
1272 
<a name="29" id="anc29"></a>


1273     // If we are dealing with a fragment created from plain text
1274     // no style matching is necessary.
1275     if (plainTextFragment)
1276         m_matchStyle = false;
1277 
1278     completeHTMLReplacement(lastPositionToSelect);
1279 }
1280 
1281 String ReplaceSelectionCommand::inputEventData() const
1282 {
1283     if (isEditingTextAreaOrTextInput())
1284         return m_documentFragment-&gt;textContent();
1285 
1286     return CompositeEditCommand::inputEventData();
1287 }
1288 
1289 RefPtr&lt;DataTransfer&gt; ReplaceSelectionCommand::inputEventDataTransfer() const
1290 {
1291     if (isEditingTextAreaOrTextInput())
1292         return CompositeEditCommand::inputEventDataTransfer();
1293 
<a name="30" id="anc30"></a><span class="line-modified">1294     return DataTransfer::createForInputEvent(m_documentFragmentPlainText, m_documentFragmentHTMLMarkup);</span>
1295 }
1296 
1297 bool ReplaceSelectionCommand::shouldRemoveEndBR(Node* endBR, const VisiblePosition&amp; originalVisPosBeforeEndBR)
1298 {
1299     if (!endBR || !endBR-&gt;isConnected())
1300         return false;
1301 
1302     VisiblePosition visiblePos(positionBeforeNode(endBR));
1303 
1304     // Don&#39;t remove the br if nothing was inserted.
1305     if (visiblePos.previous() == originalVisPosBeforeEndBR)
1306         return false;
1307 
1308     // Remove the br if it is collapsed away and so is unnecessary.
1309     if (!document().inNoQuirksMode() &amp;&amp; isEndOfBlock(visiblePos) &amp;&amp; !isStartOfParagraph(visiblePos))
1310         return true;
1311 
1312     // A br that was originally holding a line open should be displaced by inserted content or turned into a line break.
1313     // A br that was originally acting as a line break should still be acting as a line break, not as a placeholder.
1314     return isStartOfParagraph(visiblePos) &amp;&amp; isEndOfParagraph(visiblePos);
1315 }
1316 
1317 bool ReplaceSelectionCommand::shouldPerformSmartReplace() const
1318 {
1319     if (!m_smartReplace)
1320         return false;
1321 
1322     Element* textControl = enclosingTextFormControl(positionAtStartOfInsertedContent().deepEquivalent());
1323     if (is&lt;HTMLInputElement&gt;(textControl) &amp;&amp; downcast&lt;HTMLInputElement&gt;(*textControl).isPasswordField())
1324         return false; // Disable smart replace for password fields.
1325 
1326     return true;
1327 }
1328 
<a name="31" id="anc31"></a>










1329 static bool isCharacterSmartReplaceExemptConsideringNonBreakingSpace(UChar32 character, bool previousCharacter)
1330 {
1331     return isCharacterSmartReplaceExempt(character == noBreakSpace ? &#39; &#39; : character, previousCharacter);
1332 }
1333 
<a name="32" id="anc32"></a>







































1334 void ReplaceSelectionCommand::addSpacesForSmartReplace()
1335 {
1336     VisiblePosition startOfInsertedContent = positionAtStartOfInsertedContent();
1337     VisiblePosition endOfInsertedContent = positionAtEndOfInsertedContent();
1338 
1339     Position endUpstream = endOfInsertedContent.deepEquivalent().upstream();
1340     Node* endNode = endUpstream.computeNodeBeforePosition();
1341     int endOffset = is&lt;Text&gt;(endNode) ? downcast&lt;Text&gt;(*endNode).length() : 0;
1342     if (endUpstream.anchorType() == Position::PositionIsOffsetInAnchor) {
1343         endNode = endUpstream.containerNode();
1344         endOffset = endUpstream.offsetInContainerNode();
1345     }
1346 
1347     bool needsTrailingSpace = !isEndOfParagraph(endOfInsertedContent) &amp;&amp; !isStartOfParagraph(endOfInsertedContent) &amp;&amp; !isCharacterSmartReplaceExemptConsideringNonBreakingSpace(endOfInsertedContent.characterAfter(), false);
1348     if (needsTrailingSpace &amp;&amp; endNode) {
1349         bool collapseWhiteSpace = !endNode-&gt;renderer() || endNode-&gt;renderer()-&gt;style().collapseWhiteSpace();
1350         if (is&lt;Text&gt;(*endNode)) {
1351             insertTextIntoNode(downcast&lt;Text&gt;(*endNode), endOffset, collapseWhiteSpace ? nonBreakingSpaceString() : &quot; &quot;);
1352             if (m_endOfInsertedContent.containerNode() == endNode)
1353                 m_endOfInsertedContent.moveToOffset(m_endOfInsertedContent.offsetInContainerNode() + 1);
1354         } else {
1355             auto node = document().createEditingTextNode(collapseWhiteSpace ? nonBreakingSpaceString() : &quot; &quot;);
1356             insertNodeAfter(node.copyRef(), *endNode);
1357             updateNodesInserted(node.ptr());
1358         }
1359     }
1360 
1361     document().updateLayout();
1362 
1363     Position startDownstream = startOfInsertedContent.deepEquivalent().downstream();
1364     Node* startNode = startDownstream.computeNodeAfterPosition();
1365     unsigned startOffset = 0;
1366     if (startDownstream.anchorType() == Position::PositionIsOffsetInAnchor) {
1367         startNode = startDownstream.containerNode();
1368         startOffset = startDownstream.offsetInContainerNode();
1369     }
1370 
1371     bool needsLeadingSpace = !isStartOfParagraph(startOfInsertedContent) &amp;&amp; !isEndOfParagraph(startOfInsertedContent) &amp;&amp; !isCharacterSmartReplaceExemptConsideringNonBreakingSpace(startOfInsertedContent.previous().characterAfter(), true);
1372     if (needsLeadingSpace &amp;&amp; startNode) {
1373         bool collapseWhiteSpace = !startNode-&gt;renderer() || startNode-&gt;renderer()-&gt;style().collapseWhiteSpace();
1374         if (is&lt;Text&gt;(*startNode)) {
1375             insertTextIntoNode(downcast&lt;Text&gt;(*startNode), startOffset, collapseWhiteSpace ? nonBreakingSpaceString() : &quot; &quot;);
1376             if (m_endOfInsertedContent.containerNode() == startNode &amp;&amp; m_endOfInsertedContent.offsetInContainerNode())
1377                 m_endOfInsertedContent.moveToOffset(m_endOfInsertedContent.offsetInContainerNode() + 1);
1378         } else {
1379             auto node = document().createEditingTextNode(collapseWhiteSpace ? nonBreakingSpaceString() : &quot; &quot;);
1380             auto* nodePtr = node.ptr();
1381             // Don&#39;t updateNodesInserted. Doing so would set m_endOfInsertedContent to be the node containing the leading space,
1382             // but m_endOfInsertedContent is supposed to mark the end of pasted content.
1383             insertNodeBefore(WTFMove(node), *startNode);
1384             m_startOfInsertedContent = firstPositionInNode(nodePtr);
1385         }
1386     }
1387 }
1388 
1389 void ReplaceSelectionCommand::completeHTMLReplacement(const Position &amp;lastPositionToSelect)
1390 {
1391     Position start = positionAtStartOfInsertedContent().deepEquivalent();
1392     Position end = positionAtEndOfInsertedContent().deepEquivalent();
1393 
1394     // Mutation events may have deleted start or end
1395     if (start.isNotNull() &amp;&amp; !start.isOrphan() &amp;&amp; end.isNotNull() &amp;&amp; !end.isOrphan()) {
1396         // FIXME (11475): Remove this and require that the creator of the fragment to use nbsps.
1397         rebalanceWhitespaceAt(start);
1398         rebalanceWhitespaceAt(end);
1399 
1400         if (m_matchStyle) {
1401             ASSERT(m_insertionStyle);
1402             applyStyle(m_insertionStyle.get(), start, end);
1403         }
1404 
1405         if (lastPositionToSelect.isNotNull())
1406             end = lastPositionToSelect;
1407 
1408         mergeTextNodesAroundPosition(start, end);
1409         mergeTextNodesAroundPosition(end, start);
1410     } else if (lastPositionToSelect.isNotNull())
1411         start = end = lastPositionToSelect;
1412     else
1413         return;
1414 
1415     if (AXObjectCache::accessibilityEnabled() &amp;&amp; editingAction() == EditAction::Paste)
1416         m_visibleSelectionForInsertedText = VisibleSelection(start, end);
1417 
1418     if (m_selectReplacement)
1419         setEndingSelection(VisibleSelection(start, end, SEL_DEFAULT_AFFINITY, endingSelection().isDirectional()));
1420     else
1421         setEndingSelection(VisibleSelection(end, SEL_DEFAULT_AFFINITY, endingSelection().isDirectional()));
1422 }
1423 
1424 void ReplaceSelectionCommand::mergeTextNodesAroundPosition(Position&amp; position, Position&amp; positionOnlyToBeUpdated)
1425 {
1426     bool positionIsOffsetInAnchor = position.anchorType() == Position::PositionIsOffsetInAnchor;
1427     bool positionOnlyToBeUpdatedIsOffsetInAnchor = positionOnlyToBeUpdated.anchorType() == Position::PositionIsOffsetInAnchor;
1428     RefPtr&lt;Text&gt; text;
1429     if (positionIsOffsetInAnchor &amp;&amp; is&lt;Text&gt;(position.containerNode()))
1430         text = downcast&lt;Text&gt;(position.containerNode());
1431     else {
1432         Node* before = position.computeNodeBeforePosition();
1433         if (is&lt;Text&gt;(before))
1434             text = downcast&lt;Text&gt;(before);
1435         else {
1436             Node* after = position.computeNodeAfterPosition();
1437             if (is&lt;Text&gt;(after))
1438                 text = downcast&lt;Text&gt;(after);
1439         }
1440     }
1441     if (!text)
1442         return;
1443 
1444     if (is&lt;Text&gt;(text-&gt;previousSibling())) {
1445         Ref&lt;Text&gt; previous(downcast&lt;Text&gt;(*text-&gt;previousSibling()));
1446         insertTextIntoNode(*text, 0, previous-&gt;data());
1447 
1448         if (positionIsOffsetInAnchor)
1449             position.moveToOffset(previous-&gt;length() + position.offsetInContainerNode());
1450         else
1451             updatePositionForNodeRemoval(position, previous.get());
1452 
1453         if (positionOnlyToBeUpdatedIsOffsetInAnchor) {
1454             if (positionOnlyToBeUpdated.containerNode() == text)
1455                 positionOnlyToBeUpdated.moveToOffset(previous-&gt;length() + positionOnlyToBeUpdated.offsetInContainerNode());
1456             else if (positionOnlyToBeUpdated.containerNode() == previous.ptr())
1457                 positionOnlyToBeUpdated.moveToPosition(text.get(), positionOnlyToBeUpdated.offsetInContainerNode());
1458         } else
1459             updatePositionForNodeRemoval(positionOnlyToBeUpdated, previous.get());
1460 
1461         removeNode(previous);
1462     }
1463     if (is&lt;Text&gt;(text-&gt;nextSibling())) {
1464         Ref&lt;Text&gt; next(downcast&lt;Text&gt;(*text-&gt;nextSibling()));
1465         unsigned originalLength = text-&gt;length();
1466         insertTextIntoNode(*text, originalLength, next-&gt;data());
1467 
1468         if (!positionIsOffsetInAnchor)
1469             updatePositionForNodeRemoval(position, next.get());
1470 
1471         if (positionOnlyToBeUpdatedIsOffsetInAnchor &amp;&amp; positionOnlyToBeUpdated.containerNode() == next.ptr())
1472             positionOnlyToBeUpdated.moveToPosition(text.get(), originalLength + positionOnlyToBeUpdated.offsetInContainerNode());
1473         else
1474             updatePositionForNodeRemoval(positionOnlyToBeUpdated, next.get());
1475 
1476         removeNode(next);
1477     }
1478 }
1479 
1480 static HTMLElement* singleChildList(HTMLElement&amp; element)
1481 {
1482     if (!element.hasOneChild())
1483         return nullptr;
1484 
1485     auto&amp; child = *element.firstChild();
1486     return isListHTMLElement(&amp;child) ? &amp;downcast&lt;HTMLElement&gt;(child) : nullptr;
1487 }
1488 
1489 static HTMLElement&amp; deepestSingleChildList(HTMLElement&amp; topLevelList)
1490 {
1491     auto* list = &amp;topLevelList;
1492     while (auto* childList = singleChildList(*list))
1493         list = childList;
1494     return *list;
1495 }
1496 
1497 // If the user is inserting a list into an existing list, instead of nesting the list,
1498 // we put the list items into the existing list.
1499 Node* ReplaceSelectionCommand::insertAsListItems(HTMLElement&amp; passedListElement, Node* insertionBlock, const Position&amp; insertPos, InsertedNodes&amp; insertedNodes)
1500 {
1501     Ref&lt;HTMLElement&gt; listElement = deepestSingleChildList(passedListElement);
1502 
1503     bool isStart = isStartOfParagraph(insertPos);
1504     bool isEnd = isEndOfParagraph(insertPos);
1505     bool isMiddle = !isStart &amp;&amp; !isEnd;
1506     Node* lastNode = insertionBlock;
1507 
1508     // If we&#39;re in the middle of a list item, we should split it into two separate
1509     // list items and insert these nodes between them.
1510     if (isMiddle) {
1511         int textNodeOffset = insertPos.offsetInContainerNode();
1512         if (is&lt;Text&gt;(*insertPos.deprecatedNode()) &amp;&amp; textNodeOffset &gt; 0)
1513             splitTextNode(downcast&lt;Text&gt;(*insertPos.deprecatedNode()), textNodeOffset);
1514         splitTreeToNode(*insertPos.deprecatedNode(), *lastNode, true);
1515     }
1516 
1517     while (RefPtr&lt;Node&gt; listItem = listElement-&gt;firstChild()) {
1518         listElement-&gt;removeChild(*listItem);
1519         if (isStart || isMiddle) {
1520             insertNodeBefore(*listItem, *lastNode);
1521             insertedNodes.respondToNodeInsertion(listItem.get());
1522         } else if (isEnd) {
1523             insertNodeAfter(*listItem, *lastNode);
1524             insertedNodes.respondToNodeInsertion(listItem.get());
1525             lastNode = listItem.get();
1526         } else
1527             ASSERT_NOT_REACHED();
1528     }
1529     if ((isStart || isMiddle) &amp;&amp; lastNode-&gt;previousSibling())
1530         lastNode = lastNode-&gt;previousSibling();
1531     return lastNode;
1532 }
1533 
1534 void ReplaceSelectionCommand::updateNodesInserted(Node *node)
1535 {
1536     if (!node)
1537         return;
1538 
1539     if (m_startOfInsertedContent.isNull())
1540         m_startOfInsertedContent = firstPositionInOrBeforeNode(node);
1541 
1542     m_endOfInsertedContent = lastPositionInOrAfterNode(node-&gt;lastDescendant());
1543 }
1544 
1545 ReplacementFragment* ReplaceSelectionCommand::ensureReplacementFragment()
1546 {
<a name="33" id="anc33"></a><span class="line-modified">1547     if (!m_replacementFragment) {</span>
<span class="line-modified">1548         m_replacementFragment = std::make_unique&lt;ReplacementFragment&gt;(document(), m_documentFragment.get(), endingSelection());</span>
<span class="line-removed">1549         removeHeadContents(*m_replacementFragment);</span>
<span class="line-removed">1550     }</span>
<span class="line-removed">1551 </span>
1552     return m_replacementFragment.get();
1553 }
1554 
1555 // During simple pastes, where we&#39;re just pasting a text node into a run of text, we insert the text node
1556 // directly into the text node that holds the selection.  This is much faster than the generalized code in
1557 // ReplaceSelectionCommand, and works around &lt;https://bugs.webkit.org/show_bug.cgi?id=6148&gt; since we don&#39;t
1558 // split text nodes.
1559 bool ReplaceSelectionCommand::performTrivialReplace(const ReplacementFragment&amp; fragment)
1560 {
1561     if (!is&lt;Text&gt;(fragment.firstChild()) || fragment.firstChild() != fragment.lastChild())
1562         return false;
1563 
1564     // FIXME: Would be nice to handle smart replace in the fast path.
1565     if (m_smartReplace || fragment.hasInterchangeNewlineAtStart() || fragment.hasInterchangeNewlineAtEnd())
1566         return false;
1567 
1568     // e.g. when &quot;bar&quot; is inserted after &quot;foo&quot; in &lt;div&gt;&lt;u&gt;foo&lt;/u&gt;&lt;/div&gt;, &quot;bar&quot; should not be underlined.
1569     if (nodeToSplitToAvoidPastingIntoInlineNodesWithStyle(endingSelection().start()))
1570         return false;
1571 
1572     RefPtr&lt;Node&gt; nodeAfterInsertionPos = endingSelection().end().downstream().anchorNode();
1573     Text&amp; textNode = downcast&lt;Text&gt;(*fragment.firstChild());
1574     // Our fragment creation code handles tabs, spaces, and newlines, so we don&#39;t have to worry about those here.
1575 
1576     Position start = endingSelection().start();
1577     Position end = replaceSelectedTextInNode(textNode.data());
1578     if (end.isNull())
1579         return false;
1580 
1581     if (nodeAfterInsertionPos &amp;&amp; nodeAfterInsertionPos-&gt;parentNode() &amp;&amp; nodeAfterInsertionPos-&gt;hasTagName(brTag)
1582         &amp;&amp; shouldRemoveEndBR(nodeAfterInsertionPos.get(), positionBeforeNode(nodeAfterInsertionPos.get())))
1583         removeNodeAndPruneAncestors(*nodeAfterInsertionPos);
1584 
1585     VisibleSelection selectionAfterReplace(m_selectReplacement ? start : end, end);
1586 
1587     if (AXObjectCache::accessibilityEnabled() &amp;&amp; editingAction() == EditAction::Paste)
1588         m_visibleSelectionForInsertedText = VisibleSelection(start, end);
1589 
1590     setEndingSelection(selectionAfterReplace);
1591 
1592     return true;
1593 }
1594 
1595 } // namespace WebCore
<a name="34" id="anc34"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="34" type="hidden" />
</body>
</html>