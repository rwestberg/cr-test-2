<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.web/src/main/native/Source/WebCore/editing/TextIterator.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (C) 2004-2019 Apple Inc. All rights reserved.
   3  * Copyright (C) 2005 Alexey Proskuryakov.
   4  *
   5  * Redistribution and use in source and binary forms, with or without
   6  * modification, are permitted provided that the following conditions
   7  * are met:
   8  * 1. Redistributions of source code must retain the above copyright
   9  *    notice, this list of conditions and the following disclaimer.
  10  * 2. Redistributions in binary form must reproduce the above copyright
  11  *    notice, this list of conditions and the following disclaimer in the
  12  *    documentation and/or other materials provided with the distribution.
  13  *
  14  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  15  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  16  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  17  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR
  18  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  19  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  20  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  21  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  22  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  23  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  24  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  25  */
  26 
  27 #include &quot;config.h&quot;
  28 #include &quot;TextIterator.h&quot;
  29 
  30 #include &quot;ComposedTreeIterator.h&quot;
  31 #include &quot;Document.h&quot;
  32 #include &quot;Editing.h&quot;
  33 #include &quot;FontCascade.h&quot;
  34 #include &quot;Frame.h&quot;
  35 #include &quot;HTMLBodyElement.h&quot;
  36 #include &quot;HTMLElement.h&quot;
  37 #include &quot;HTMLFrameOwnerElement.h&quot;
  38 #include &quot;HTMLInputElement.h&quot;
  39 #include &quot;HTMLLegendElement.h&quot;
  40 #include &quot;HTMLMeterElement.h&quot;
  41 #include &quot;HTMLNames.h&quot;
  42 #include &quot;HTMLParagraphElement.h&quot;
  43 #include &quot;HTMLProgressElement.h&quot;
  44 #include &quot;HTMLSlotElement.h&quot;
  45 #include &quot;HTMLTextAreaElement.h&quot;
  46 #include &quot;HTMLTextFormControlElement.h&quot;
  47 #include &quot;InlineTextBox.h&quot;
  48 #include &quot;NodeTraversal.h&quot;
  49 #include &quot;RenderImage.h&quot;
  50 #include &quot;RenderIterator.h&quot;
  51 #include &quot;RenderTableCell.h&quot;
  52 #include &quot;RenderTableRow.h&quot;
  53 #include &quot;RenderTextControl.h&quot;
  54 #include &quot;RenderTextFragment.h&quot;
  55 #include &quot;ShadowRoot.h&quot;
  56 #include &quot;SimpleLineLayout.h&quot;
  57 #include &quot;SimpleLineLayoutFunctions.h&quot;
  58 #include &quot;SimpleLineLayoutResolver.h&quot;
  59 #include &quot;TextBoundaries.h&quot;
  60 #include &quot;TextControlInnerElements.h&quot;
  61 #include &quot;VisiblePosition.h&quot;
  62 #include &quot;VisibleUnits.h&quot;
  63 #include &lt;unicode/unorm2.h&gt;
  64 #include &lt;wtf/Function.h&gt;
  65 #include &lt;wtf/text/CString.h&gt;
  66 #include &lt;wtf/text/StringBuilder.h&gt;
  67 #include &lt;wtf/text/TextBreakIterator.h&gt;
  68 #include &lt;wtf/unicode/CharacterNames.h&gt;
  69 
  70 #if !UCONFIG_NO_COLLATION
  71 #include &lt;unicode/usearch.h&gt;
  72 #include &lt;wtf/text/TextBreakIteratorInternalICU.h&gt;
  73 #endif
  74 
  75 namespace WebCore {
  76 
  77 using namespace WTF::Unicode;
  78 using namespace HTMLNames;
  79 
  80 // Buffer that knows how to compare with a search target.
  81 // Keeps enough of the previous text to be able to search in the future, but no more.
  82 // Non-breaking spaces are always equal to normal spaces.
  83 // Case folding is also done if the CaseInsensitive option is specified.
  84 // Matches are further filtered if the AtWordStarts option is specified, although some
  85 // matches inside a word are permitted if TreatMedialCapitalAsWordStart is specified as well.
  86 class SearchBuffer {
  87     WTF_MAKE_NONCOPYABLE(SearchBuffer);
  88 public:
  89     SearchBuffer(const String&amp; target, FindOptions);
  90     ~SearchBuffer();
  91 
  92     // Returns number of characters appended; guaranteed to be in the range [1, length].
  93     size_t append(StringView);
  94     bool needsMoreContext() const;
  95     void prependContext(StringView);
  96     void reachedBreak();
  97 
  98     // Result is the size in characters of what was found.
  99     // And &lt;startOffset&gt; is the number of characters back to the start of what was found.
 100     size_t search(size_t&amp; startOffset);
 101     bool atBreak() const;
 102 
 103 #if !UCONFIG_NO_COLLATION
 104 
 105 private:
 106     bool isBadMatch(const UChar*, size_t length) const;
 107     bool isWordStartMatch(size_t start, size_t length) const;
 108     bool isWordEndMatch(size_t start, size_t length) const;
 109 
 110     const String m_target;
 111     const StringView::UpconvertedCharacters m_targetCharacters;
 112     FindOptions m_options;
 113 
 114     Vector&lt;UChar&gt; m_buffer;
 115     size_t m_overlap;
 116     size_t m_prefixLength;
 117     bool m_atBreak;
 118     bool m_needsMoreContext;
 119 
 120     const bool m_targetRequiresKanaWorkaround;
 121     Vector&lt;UChar&gt; m_normalizedTarget;
 122     mutable Vector&lt;UChar&gt; m_normalizedMatch;
 123 
 124 #else
 125 
 126 private:
 127     void append(UChar, bool isCharacterStart);
 128     size_t length() const;
 129 
 130     String m_target;
 131     FindOptions m_options;
 132 
 133     Vector&lt;UChar&gt; m_buffer;
 134     Vector&lt;bool&gt; m_isCharacterStartBuffer;
 135     bool m_isBufferFull;
 136     size_t m_cursor;
 137 
 138 #endif
 139 };
 140 
 141 // --------
 142 
 143 static const unsigned bitsInWord = sizeof(unsigned) * 8;
 144 static const unsigned bitInWordMask = bitsInWord - 1;
 145 
 146 BitStack::BitStack()
 147     : m_size(0)
 148 {
 149 }
 150 
 151 BitStack::~BitStack() = default;
 152 
 153 void BitStack::push(bool bit)
 154 {
 155     unsigned index = m_size / bitsInWord;
 156     unsigned shift = m_size &amp; bitInWordMask;
 157     if (!shift &amp;&amp; index == m_words.size()) {
 158         m_words.grow(index + 1);
 159         m_words[index] = 0;
 160     }
 161     unsigned&amp; word = m_words[index];
 162     unsigned mask = 1U &lt;&lt; shift;
 163     if (bit)
 164         word |= mask;
 165     else
 166         word &amp;= ~mask;
 167     ++m_size;
 168 }
 169 
 170 void BitStack::pop()
 171 {
 172     if (m_size)
 173         --m_size;
 174 }
 175 
 176 bool BitStack::top() const
 177 {
 178     if (!m_size)
 179         return false;
 180     unsigned shift = (m_size - 1) &amp; bitInWordMask;
 181     return m_words.last() &amp; (1U &lt;&lt; shift);
 182 }
 183 
 184 unsigned BitStack::size() const
 185 {
 186     return m_size;
 187 }
 188 
 189 // --------
 190 
 191 // This function is like Range::pastLastNode, except for the fact that it can climb up out of shadow trees.
 192 static Node* nextInPreOrderCrossingShadowBoundaries(Node&amp; rangeEndContainer, int rangeEndOffset)
 193 {
 194     if (rangeEndOffset &gt;= 0 &amp;&amp; !rangeEndContainer.isCharacterDataNode()) {
 195         if (Node* next = rangeEndContainer.traverseToChildAt(rangeEndOffset))
 196             return next;
 197     }
 198     for (Node* node = &amp;rangeEndContainer; node; node = node-&gt;parentOrShadowHostNode()) {
 199         if (Node* next = node-&gt;nextSibling())
 200             return next;
 201     }
 202     return nullptr;
 203 }
 204 
 205 static inline bool fullyClipsContents(Node&amp; node)
 206 {
 207     auto* renderer = node.renderer();
 208     if (!renderer) {
 209         if (!is&lt;Element&gt;(node))
 210             return false;
 211         return !downcast&lt;Element&gt;(node).hasDisplayContents();
 212     }
 213     if (!is&lt;RenderBox&gt;(*renderer))
 214         return false;
 215     auto&amp; box = downcast&lt;RenderBox&gt;(*renderer);
 216     if (!box.hasOverflowClip())
 217         return false;
 218 
 219     // Quirk to keep copy/paste in the CodeMirror editor version used in Jenkins working.
 220     if (is&lt;HTMLTextAreaElement&gt;(node))
 221         return box.size().isEmpty();
 222 
 223     return box.contentSize().isEmpty();
 224 }
 225 
 226 static inline bool ignoresContainerClip(Node&amp; node)
 227 {
 228     auto* renderer = node.renderer();
 229     if (!renderer || renderer-&gt;isTextOrLineBreak())
 230         return false;
 231     return renderer-&gt;style().hasOutOfFlowPosition();
 232 }
 233 
 234 static void pushFullyClippedState(BitStack&amp; stack, Node&amp; node)
 235 {
 236     // Push true if this node full clips its contents, or if a parent already has fully
 237     // clipped and this is not a node that ignores its container&#39;s clip.
 238     stack.push(fullyClipsContents(node) || (stack.top() &amp;&amp; !ignoresContainerClip(node)));
 239 }
 240 
 241 static void setUpFullyClippedStack(BitStack&amp; stack, Node&amp; node)
 242 {
 243     // Put the nodes in a vector so we can iterate in reverse order.
 244     // FIXME: This (and TextIterator in general) should use ComposedTreeIterator.
 245     Vector&lt;Node*, 100&gt; ancestry;
 246     for (Node* parent = node.parentOrShadowHostNode(); parent; parent = parent-&gt;parentOrShadowHostNode())
 247         ancestry.append(parent);
 248 
 249     // Call pushFullyClippedState on each node starting with the earliest ancestor.
 250     size_t size = ancestry.size();
 251     for (size_t i = 0; i &lt; size; ++i)
 252         pushFullyClippedState(stack, *ancestry[size - i - 1]);
 253     pushFullyClippedState(stack, node);
 254 }
 255 
 256 static bool isClippedByFrameAncestor(const Document&amp; document, TextIteratorBehavior behavior)
 257 {
 258     if (!(behavior &amp; TextIteratorClipsToFrameAncestors))
 259         return false;
 260 
 261     for (auto* owner = document.ownerElement(); owner; owner = owner-&gt;document().ownerElement()) {
 262         BitStack ownerClipStack;
 263         setUpFullyClippedStack(ownerClipStack, *owner);
 264         if (ownerClipStack.top())
 265             return true;
 266     }
 267     return false;
 268 }
 269 
 270 // FIXME: editingIgnoresContent and isRendererReplacedElement try to do the same job.
 271 // It&#39;s not good to have both of them.
 272 bool isRendererReplacedElement(RenderObject* renderer)
 273 {
 274     if (!renderer)
 275         return false;
 276 
 277     bool isAttachment = false;
 278 #if ENABLE(ATTACHMENT_ELEMENT)
 279     isAttachment = renderer-&gt;isAttachment();
 280 #endif
 281     if (renderer-&gt;isImage() || renderer-&gt;isWidget() || renderer-&gt;isMedia() || isAttachment)
 282         return true;
 283 
 284     if (is&lt;Element&gt;(renderer-&gt;node())) {
 285         Element&amp; element = downcast&lt;Element&gt;(*renderer-&gt;node());
 286         if (is&lt;HTMLFormControlElement&gt;(element) || is&lt;HTMLLegendElement&gt;(element) || is&lt;HTMLProgressElement&gt;(element) || element.hasTagName(meterTag))
 287             return true;
 288         if (equalLettersIgnoringASCIICase(element.attributeWithoutSynchronization(roleAttr), &quot;img&quot;))
 289             return true;
 290     }
 291 
 292     return false;
 293 }
 294 
 295 // --------
 296 
 297 inline void TextIteratorCopyableText::reset()
 298 {
 299     m_singleCharacter = 0;
 300     m_string = String();
 301     m_offset = 0;
 302     m_length = 0;
 303 }
 304 
 305 inline void TextIteratorCopyableText::set(String&amp;&amp; string)
 306 {
 307     m_singleCharacter = 0;
 308     m_string = WTFMove(string);
 309     m_offset = 0;
 310     m_length = m_string.length();
 311 }
 312 
 313 inline void TextIteratorCopyableText::set(String&amp;&amp; string, unsigned offset, unsigned length)
 314 {
 315     ASSERT(offset &lt; string.length());
 316     ASSERT(length);
 317     ASSERT(length &lt;= string.length() - offset);
 318 
 319     m_singleCharacter = 0;
 320     m_string = WTFMove(string);
 321     m_offset = offset;
 322     m_length = length;
 323 }
 324 
 325 inline void TextIteratorCopyableText::set(UChar singleCharacter)
 326 {
 327     m_singleCharacter = singleCharacter;
 328     m_string = String();
 329     m_offset = 0;
 330     m_length = 0;
 331 }
 332 
 333 void TextIteratorCopyableText::appendToStringBuilder(StringBuilder&amp; builder) const
 334 {
 335     if (m_singleCharacter)
 336         builder.append(m_singleCharacter);
 337     else
 338         builder.append(m_string, m_offset, m_length);
 339 }
 340 
 341 // --------
 342 
 343 
 344 TextIterator::TextIterator(Position start, Position end, TextIteratorBehavior behavior)
 345     : m_behavior(behavior)
 346 {
 347     if (start.isNull() || end.isNull())
 348         return;
 349     ASSERT(comparePositions(start, end) &lt;= 0);
 350 
 351     RELEASE_ASSERT(behavior &amp; TextIteratorTraversesFlatTree || start.treeScope() == end.treeScope());
 352 
 353     start.document()-&gt;updateLayoutIgnorePendingStylesheets();
 354 
 355     // FIXME: Use Position / PositionIterator instead to avoid offset computation.
 356     m_startContainer = start.containerNode();
 357     m_startOffset = start.computeOffsetInContainerNode();
 358 
 359     m_endContainer = end.containerNode();
 360     m_endOffset = end.computeOffsetInContainerNode();
 361 
 362     m_node = start.firstNode().get();
 363     if (!m_node)
 364         return;
 365 
 366     init();
 367 }
 368 
 369 TextIterator::TextIterator(const Range* range, TextIteratorBehavior behavior)
 370     : m_behavior(behavior)
 371 {
 372     if (!range)
 373         return;
 374 
 375     range-&gt;ownerDocument().updateLayoutIgnorePendingStylesheets();
 376 
 377     m_startContainer = &amp;range-&gt;startContainer();
 378 
 379     // Callers should be handing us well-formed ranges. If we discover that this isn&#39;t
 380     // the case, we could consider changing this assertion to an early return.
 381     ASSERT(range-&gt;boundaryPointsValid());
 382 
 383     m_startOffset = range-&gt;startOffset();
 384     m_endContainer = &amp;range-&gt;endContainer();
 385     m_endOffset = range-&gt;endOffset();
 386 
 387     m_node = range-&gt;firstNode();
 388     if (!m_node)
 389         return;
 390 
 391     init();
 392 }
 393 
 394 void TextIterator::init()
 395 {
 396     if (isClippedByFrameAncestor(m_node-&gt;document(), m_behavior))
 397         return;
 398 
 399     setUpFullyClippedStack(m_fullyClippedStack, *m_node);
 400 
 401     m_offset = m_node == m_startContainer ? m_startOffset : 0;
 402 
 403     m_pastEndNode = nextInPreOrderCrossingShadowBoundaries(*m_endContainer, m_endOffset);
 404 
 405     m_positionNode = m_node;
 406 
 407     advance();
 408 }
 409 
 410 TextIterator::~TextIterator() = default;
 411 
 412 // FIXME: Use ComposedTreeIterator instead. These functions are more expensive because they might do O(n) work.
 413 static inline Node* firstChild(TextIteratorBehavior options, Node&amp; node)
 414 {
 415     if (UNLIKELY(options &amp; TextIteratorTraversesFlatTree))
 416         return firstChildInComposedTreeIgnoringUserAgentShadow(node);
 417     return node.firstChild();
 418 }
 419 
 420 static inline Node* nextSibling(TextIteratorBehavior options, Node&amp; node)
 421 {
 422     if (UNLIKELY(options &amp; TextIteratorTraversesFlatTree))
 423         return nextSiblingInComposedTreeIgnoringUserAgentShadow(node);
 424     return node.nextSibling();
 425 }
 426 
 427 static inline Node* nextNode(TextIteratorBehavior options, Node&amp; node)
 428 {
 429     if (UNLIKELY(options &amp; TextIteratorTraversesFlatTree))
 430         return nextInComposedTreeIgnoringUserAgentShadow(node);
 431     return NodeTraversal::next(node);
 432 }
 433 
 434 static inline bool isDescendantOf(TextIteratorBehavior options, Node&amp; node, Node&amp; possibleAncestor)
 435 {
 436     if (UNLIKELY(options &amp; TextIteratorTraversesFlatTree))
 437         return node.isDescendantOrShadowDescendantOf(&amp;possibleAncestor);
 438     return node.isDescendantOf(&amp;possibleAncestor);
 439 }
 440 
 441 static inline Node* parentNodeOrShadowHost(TextIteratorBehavior options, Node&amp; node)
 442 {
 443     if (UNLIKELY(options &amp; TextIteratorTraversesFlatTree))
 444         return node.parentInComposedTree();
 445     return node.parentOrShadowHostNode();
 446 }
 447 
 448 static inline bool hasDisplayContents(Node&amp; node)
 449 {
 450     return is&lt;Element&gt;(node) &amp;&amp; downcast&lt;Element&gt;(node).hasDisplayContents();
 451 }
 452 
 453 void TextIterator::advance()
 454 {
 455     ASSERT(!atEnd());
 456 
 457     // reset the run information
 458     m_positionNode = nullptr;
 459     m_copyableText.reset();
 460     m_text = StringView();
 461 
 462     // handle remembered node that needed a newline after the text node&#39;s newline
 463     if (m_nodeForAdditionalNewline) {
 464         // Emit the extra newline, and position it *inside* m_node, after m_node&#39;s
 465         // contents, in case it&#39;s a block, in the same way that we position the first
 466         // newline. The range for the emitted newline should start where the line
 467         // break begins.
 468         // FIXME: It would be cleaner if we emitted two newlines during the last
 469         // iteration, instead of using m_needsAnotherNewline.
 470         emitCharacter(&#39;\n&#39;, *m_nodeForAdditionalNewline-&gt;parentNode(), m_nodeForAdditionalNewline, 1, 1);
 471         m_nodeForAdditionalNewline = nullptr;
 472         return;
 473     }
 474 
 475     if (!m_textBox &amp;&amp; m_remainingTextBox) {
 476         m_textBox = m_remainingTextBox;
 477         m_remainingTextBox = nullptr;
 478         m_firstLetterText = nullptr;
 479         m_offset = 0;
 480     }
 481     // handle remembered text box
 482     if (m_textBox) {
 483         handleTextBox();
 484         if (m_positionNode)
 485             return;
 486     }
 487 
 488     while (m_node &amp;&amp; m_node != m_pastEndNode) {
 489         // if the range ends at offset 0 of an element, represent the
 490         // position, but not the content, of that element e.g. if the
 491         // node is a blockflow element, emit a newline that
 492         // precedes the element
 493         if (m_node == m_endContainer &amp;&amp; !m_endOffset) {
 494             representNodeOffsetZero();
 495             m_node = nullptr;
 496             return;
 497         }
 498 
 499         auto* renderer = m_node-&gt;renderer();
 500         if (!m_handledNode) {
 501             if (!renderer) {
 502                 m_handledNode = true;
 503                 m_handledChildren = !hasDisplayContents(*m_node);
 504             } else {
 505                 // handle current node according to its type
 506                 if (renderer-&gt;isText() &amp;&amp; m_node-&gt;isTextNode())
 507                     m_handledNode = handleTextNode();
 508                 else if (isRendererReplacedElement(renderer))
 509                     m_handledNode = handleReplacedElement();
 510                 else
 511                     m_handledNode = handleNonTextNode();
 512                 if (m_positionNode)
 513                     return;
 514             }
 515         }
 516 
 517         // find a new current node to handle in depth-first manner,
 518         // calling exitNode() as we come back thru a parent node
 519         Node* next = m_handledChildren ? nullptr : firstChild(m_behavior, *m_node);
 520         m_offset = 0;
 521         if (!next) {
 522             next = nextSibling(m_behavior, *m_node);
 523             if (!next) {
 524                 bool pastEnd = nextNode(m_behavior, *m_node) == m_pastEndNode;
 525                 Node* parentNode = parentNodeOrShadowHost(m_behavior, *m_node);
 526                 while (!next &amp;&amp; parentNode) {
 527                     if ((pastEnd &amp;&amp; parentNode == m_endContainer) || isDescendantOf(m_behavior, *m_endContainer, *parentNode))
 528                         return;
 529                     bool haveRenderer = m_node-&gt;renderer();
 530                     Node* exitedNode = m_node;
 531                     m_node = parentNode;
 532                     m_fullyClippedStack.pop();
 533                     parentNode = parentNodeOrShadowHost(m_behavior, *m_node);
 534                     if (haveRenderer)
 535                         exitNode(exitedNode);
 536                     if (m_positionNode) {
 537                         m_handledNode = true;
 538                         m_handledChildren = true;
 539                         return;
 540                     }
 541                     next = nextSibling(m_behavior, *m_node);
 542                     if (next &amp;&amp; m_node-&gt;renderer())
 543                         exitNode(m_node);
 544                 }
 545             }
 546             m_fullyClippedStack.pop();
 547         }
 548 
 549         // set the new current node
 550         m_node = next;
 551         if (m_node)
 552             pushFullyClippedState(m_fullyClippedStack, *m_node);
 553         m_handledNode = false;
 554         m_handledChildren = false;
 555         m_handledFirstLetter = false;
 556         m_firstLetterText = nullptr;
 557 
 558         // how would this ever be?
 559         if (m_positionNode)
 560             return;
 561     }
 562 }
 563 
 564 static bool hasVisibleTextNode(RenderText&amp; renderer)
 565 {
 566     if (renderer.style().visibility() == Visibility::Visible)
 567         return true;
 568     if (is&lt;RenderTextFragment&gt;(renderer)) {
 569         if (auto firstLetter = downcast&lt;RenderTextFragment&gt;(renderer).firstLetter()) {
 570             if (firstLetter-&gt;style().visibility() == Visibility::Visible)
 571                 return true;
 572         }
 573     }
 574     return false;
 575 }
 576 
 577 static unsigned textNodeOffsetInFlow(const Text&amp; firstTextNodeInRange)
 578 {
 579     // Calculate the text offset for simple lines.
 580     RenderObject* renderer = firstTextNodeInRange.renderer();
 581     if (!renderer)
 582         return 0;
 583     unsigned textOffset = 0;
 584     for (renderer = renderer-&gt;previousSibling(); renderer; renderer = renderer-&gt;previousSibling()) {
 585         if (is&lt;RenderText&gt;(renderer))
 586             textOffset += downcast&lt;RenderText&gt;(renderer)-&gt;text().length();
 587     }
 588     return textOffset;
 589 }
 590 
 591 static bool isNewLineOrTabCharacter(UChar character)
 592 {
 593     return character == &#39;\n&#39; || character == &#39;\t&#39;;
 594 }
 595 
 596 bool TextIterator::handleTextNode()
 597 {
 598     Text&amp; textNode = downcast&lt;Text&gt;(*m_node);
 599 
 600     if (m_fullyClippedStack.top() &amp;&amp; !(m_behavior &amp; TextIteratorIgnoresStyleVisibility))
 601         return false;
 602 
 603     auto&amp; renderer = *textNode.renderer();
 604     m_lastTextNode = &amp;textNode;
 605     String rendererText = renderer.text();
 606 
 607     // handle pre-formatted text
 608     if (!renderer.style().collapseWhiteSpace()) {
 609         int runStart = m_offset;
 610         if (m_lastTextNodeEndedWithCollapsedSpace &amp;&amp; hasVisibleTextNode(renderer)) {
 611             emitCharacter(&#39; &#39;, textNode, nullptr, runStart, runStart);
 612             return false;
 613         }
 614         if (!m_handledFirstLetter &amp;&amp; is&lt;RenderTextFragment&gt;(renderer) &amp;&amp; !m_offset) {
 615             handleTextNodeFirstLetter(downcast&lt;RenderTextFragment&gt;(renderer));
 616             if (m_firstLetterText) {
 617                 String firstLetter = m_firstLetterText-&gt;text();
 618                 emitText(textNode, *m_firstLetterText, m_offset, m_offset + firstLetter.length());
 619                 m_firstLetterText = nullptr;
 620                 m_textBox = nullptr;
 621                 return false;
 622             }
 623         }
 624         if (renderer.style().visibility() != Visibility::Visible &amp;&amp; !(m_behavior &amp; TextIteratorIgnoresStyleVisibility))
 625             return false;
 626         int rendererTextLength = rendererText.length();
 627         int end = (&amp;textNode == m_endContainer) ? m_endOffset : INT_MAX;
 628         int runEnd = std::min(rendererTextLength, end);
 629 
 630         if (runStart &gt;= runEnd)
 631             return true;
 632 
 633         emitText(textNode, renderer, runStart, runEnd);
 634         return true;
 635     }
 636 
 637     if (const auto* layout = renderer.simpleLineLayout()) {
 638         if (renderer.style().visibility() != Visibility::Visible &amp;&amp; !(m_behavior &amp; TextIteratorIgnoresStyleVisibility))
 639             return true;
 640         ASSERT(renderer.parent());
 641         ASSERT(is&lt;RenderBlockFlow&gt;(*renderer.parent()));
 642         const auto&amp; blockFlow = downcast&lt;RenderBlockFlow&gt;(*renderer.parent());
 643         // Use the simple layout runs to iterate over the text content.
 644         bool isNewTextNode = m_previousSimpleTextNodeInFlow &amp;&amp; m_previousSimpleTextNodeInFlow != &amp;textNode;
 645         // Simple line layout run positions are all absolute to the parent flow.
 646         // Offsetting is required when multiple renderers are present.
 647         m_accumulatedSimpleTextLengthInFlow += isNewTextNode ? m_previousSimpleTextNodeInFlow-&gt;renderer()-&gt;text().length() : 0;
 648         m_previousSimpleTextNodeInFlow = &amp;textNode;
 649 
 650         unsigned endPosition = (m_node == m_endContainer) ? static_cast&lt;unsigned&gt;(m_endOffset) : rendererText.length();
 651         if (!m_flowRunResolverCache || &amp;m_flowRunResolverCache-&gt;flow() != &amp;blockFlow) {
 652             m_accumulatedSimpleTextLengthInFlow = m_flowRunResolverCache ? 0 : textNodeOffsetInFlow(textNode);
 653             m_flowRunResolverCache = std::make_unique&lt;SimpleLineLayout::RunResolver&gt;(blockFlow, *layout);
 654         }
 655         // Skip to m_offset position.
 656         auto range = m_flowRunResolverCache-&gt;rangeForRenderer(renderer);
 657         auto it = range.begin();
 658         auto end = range.end();
 659         auto startPosition = static_cast&lt;unsigned&gt;(m_offset) + m_accumulatedSimpleTextLengthInFlow;
 660         while (it != end &amp;&amp; (*it).end() &lt;= startPosition)
 661             ++it;
 662         if (m_nextRunNeedsWhitespace &amp;&amp; rendererText[m_offset - 1] == &#39;\n&#39;) {
 663             emitCharacter(&#39; &#39;, textNode, nullptr, m_offset, m_offset + 1);
 664             return it == end;
 665         }
 666         if (it == end) {
 667             // Collapsed trailing whitespace.
 668             m_offset = endPosition;
 669             m_lastTextNodeEndedWithCollapsedSpace = true;
 670             return true;
 671         }
 672         if (m_nextRunNeedsWhitespace) {
 673             emitCharacter(&#39; &#39;, textNode, nullptr, m_offset, m_offset + 1);
 674             return false;
 675         }
 676         // If the position we are looking for is to the left of the renderer&#39;s first run, it could mean that
 677         // the runs and the renderers are out of sync (e.g. we skipped a renderer in between).
 678         // Better bail out at this point.
 679         auto run = *it;
 680         if (run.start() &gt; startPosition) {
 681             ASSERT(m_flowRunResolverCache);
 682             if (&amp;(rendererForPosition(m_flowRunResolverCache-&gt;flowContents(), startPosition)) != &amp;renderer) {
 683                 ASSERT_NOT_REACHED();
 684                 return true;
 685             }
 686         }
 687         ASSERT(run.end() - run.start() &lt;= rendererText.length());
 688         // contentStart skips leading whitespace.
 689         unsigned contentStart = std::max&lt;unsigned&gt;(m_offset, run.start() - m_accumulatedSimpleTextLengthInFlow);
 690         unsigned contentEnd = std::min(endPosition, run.end() - m_accumulatedSimpleTextLengthInFlow);
 691         ASSERT_WITH_SECURITY_IMPLICATION(contentStart &lt;= contentEnd);
 692         // Check if whitespace adjustment is needed when crossing renderer boundary.
 693         if (isNewTextNode) {
 694             bool lastCharacterIsNotWhitespace = m_lastCharacter &amp;&amp; !renderer.style().isCollapsibleWhiteSpace(m_lastCharacter);
 695             bool addTrailingWhitespaceForPrevious = m_lastTextNodeEndedWithCollapsedSpace &amp;&amp; lastCharacterIsNotWhitespace;
 696             bool leadingWhitespaceIsNeededForCurrent = contentStart &gt; static_cast&lt;unsigned&gt;(m_offset) &amp;&amp; lastCharacterIsNotWhitespace;
 697             if (addTrailingWhitespaceForPrevious || leadingWhitespaceIsNeededForCurrent) {
 698                 emitCharacter(&#39; &#39;, textNode, nullptr, m_offset, m_offset + 1);
 699                 return false;
 700             }
 701         }
 702         // \n \t single whitespace characters need replacing so that the new line/tab characters don&#39;t show up.
 703         unsigned stopPosition = contentStart;
 704         while (stopPosition &lt; contentEnd &amp;&amp; !isNewLineOrTabCharacter(rendererText[stopPosition]))
 705             ++stopPosition;
 706         // Emit the text up to the new line/tab character.
 707         if (stopPosition &lt; contentEnd) {
 708             if (stopPosition == contentStart) {
 709                 emitCharacter(&#39; &#39;, textNode, nullptr, contentStart, contentStart + 1);
 710                 m_offset = contentStart + 1;
 711                 return false;
 712             }
 713             emitText(textNode, renderer, contentStart, stopPosition);
 714             m_offset = stopPosition + 1;
 715             m_nextRunNeedsWhitespace = true;
 716             return false;
 717         }
 718         emitText(textNode, renderer, contentStart, contentEnd);
 719         // When line ending with collapsed whitespace is present, we need to carry over one whitespace: foo(end of line)bar -&gt; foo bar (otherwise we would end up with foobar).
 720         m_nextRunNeedsWhitespace = run.isEndOfLine() &amp;&amp; contentEnd &lt; endPosition &amp;&amp; renderer.style().isCollapsibleWhiteSpace(rendererText[contentEnd]);
 721         m_offset = contentEnd;
 722         return static_cast&lt;unsigned&gt;(m_offset) == endPosition;
 723     }
 724 
 725     if (renderer.firstTextBox())
 726         m_textBox = renderer.firstTextBox();
 727 
 728     bool shouldHandleFirstLetter = !m_handledFirstLetter &amp;&amp; is&lt;RenderTextFragment&gt;(renderer) &amp;&amp; !m_offset;
 729     if (shouldHandleFirstLetter)
 730         handleTextNodeFirstLetter(downcast&lt;RenderTextFragment&gt;(renderer));
 731 
 732     if (!renderer.firstTextBox() &amp;&amp; rendererText.length() &amp;&amp; !shouldHandleFirstLetter) {
 733         if (renderer.style().visibility() != Visibility::Visible &amp;&amp; !(m_behavior &amp; TextIteratorIgnoresStyleVisibility))
 734             return false;
 735         m_lastTextNodeEndedWithCollapsedSpace = true; // entire block is collapsed space
 736         return true;
 737     }
 738 
 739     // Used when text boxes are out of order (Hebrew/Arabic w/ embeded LTR text)
 740     auto&amp; boxesRenderer = m_firstLetterText ? *m_firstLetterText : renderer;
 741     if (boxesRenderer.containsReversedText()) {
 742         m_sortedTextBoxes.clear();
 743         for (InlineTextBox* textBox = boxesRenderer.firstTextBox(); textBox; textBox = textBox-&gt;nextTextBox())
 744             m_sortedTextBoxes.append(textBox);
 745         std::sort(m_sortedTextBoxes.begin(), m_sortedTextBoxes.end(), InlineTextBox::compareByStart);
 746         m_sortedTextBoxesPosition = 0;
 747         m_textBox = m_sortedTextBoxes.isEmpty() ? nullptr : m_sortedTextBoxes[0];
 748     }
 749 
 750     handleTextBox();
 751     return true;
 752 }
 753 
 754 void TextIterator::handleTextBox()
 755 {
 756     Text&amp; textNode = downcast&lt;Text&gt;(*m_node);
 757 
 758     auto&amp; renderer = m_firstLetterText ? *m_firstLetterText : *textNode.renderer();
 759     if (renderer.style().visibility() != Visibility::Visible &amp;&amp; !(m_behavior &amp; TextIteratorIgnoresStyleVisibility)) {
 760         m_textBox = nullptr;
 761         return;
 762     }
 763     String rendererText = renderer.text();
 764     unsigned start = m_offset;
 765     unsigned end = (&amp;textNode == m_endContainer) ? static_cast&lt;unsigned&gt;(m_endOffset) : UINT_MAX;
 766     while (m_textBox) {
 767         unsigned textBoxStart = m_textBox-&gt;start();
 768         unsigned runStart = std::max(textBoxStart, start);
 769 
 770         // Check for collapsed space at the start of this run.
 771         InlineTextBox* firstTextBox = renderer.containsReversedText() ? (m_sortedTextBoxes.isEmpty() ? nullptr : m_sortedTextBoxes[0]) : renderer.firstTextBox();
 772         bool needSpace = m_lastTextNodeEndedWithCollapsedSpace || (m_textBox == firstTextBox &amp;&amp; textBoxStart == runStart &amp;&amp; runStart);
 773         if (needSpace &amp;&amp; !renderer.style().isCollapsibleWhiteSpace(m_lastCharacter) &amp;&amp; m_lastCharacter) {
 774             if (m_lastTextNode == &amp;textNode &amp;&amp; runStart &amp;&amp; rendererText[runStart - 1] == &#39; &#39;) {
 775                 unsigned spaceRunStart = runStart - 1;
 776                 while (spaceRunStart &amp;&amp; rendererText[spaceRunStart - 1] == &#39; &#39;)
 777                     --spaceRunStart;
 778                 emitText(textNode, renderer, spaceRunStart, spaceRunStart + 1);
 779             } else
 780                 emitCharacter(&#39; &#39;, textNode, nullptr, runStart, runStart);
 781             return;
 782         }
 783         unsigned textBoxEnd = textBoxStart + m_textBox-&gt;len();
 784         unsigned runEnd = std::min(textBoxEnd, end);
 785 
 786         // Determine what the next text box will be, but don&#39;t advance yet
 787         InlineTextBox* nextTextBox = nullptr;
 788         if (renderer.containsReversedText()) {
 789             if (m_sortedTextBoxesPosition + 1 &lt; m_sortedTextBoxes.size())
 790                 nextTextBox = m_sortedTextBoxes[m_sortedTextBoxesPosition + 1];
 791         } else
 792             nextTextBox = m_textBox-&gt;nextTextBox();
 793         ASSERT(!nextTextBox || &amp;nextTextBox-&gt;renderer() == &amp;renderer);
 794 
 795         if (runStart &lt; runEnd) {
 796             // Handle either a single newline character (which becomes a space),
 797             // or a run of characters that does not include a newline.
 798             // This effectively translates newlines to spaces without copying the text.
 799             if (rendererText[runStart] == &#39;\n&#39;) {
 800                 emitCharacter(&#39; &#39;, textNode, nullptr, runStart, runStart + 1);
 801                 m_offset = runStart + 1;
 802             } else {
 803                 size_t subrunEnd = rendererText.find(&#39;\n&#39;, runStart);
 804                 if (subrunEnd == notFound || subrunEnd &gt; runEnd) {
 805                     subrunEnd = runEnd;
 806                     bool lastSpaceCollapsedByNextNonTextBox = !nextTextBox &amp;&amp; (m_behavior &amp; TextIteratorBehavesAsIfNodesFollowing) &amp;&amp; rendererText.length() &gt; runEnd;
 807                     if (lastSpaceCollapsedByNextNonTextBox)
 808                         ++subrunEnd; // runEnd stopped before last space. Increment by one to restore the space.
 809                 }
 810                 m_offset = subrunEnd;
 811                 emitText(textNode, renderer, runStart, subrunEnd);
 812             }
 813 
 814             // If we are doing a subrun that doesn&#39;t go to the end of the text box,
 815             // come back again to finish handling this text box; don&#39;t advance to the next one.
 816             if (static_cast&lt;unsigned&gt;(m_positionEndOffset) &lt; textBoxEnd)
 817                 return;
 818 
 819             // Advance and return
 820             unsigned nextRunStart = nextTextBox ? nextTextBox-&gt;start() : rendererText.length();
 821             if (nextRunStart &gt; runEnd)
 822                 m_lastTextNodeEndedWithCollapsedSpace = true; // collapsed space between runs or at the end
 823             m_textBox = nextTextBox;
 824             if (renderer.containsReversedText())
 825                 ++m_sortedTextBoxesPosition;
 826             return;
 827         }
 828         // Advance and continue
 829         m_textBox = nextTextBox;
 830         if (renderer.containsReversedText())
 831             ++m_sortedTextBoxesPosition;
 832     }
 833     if (!m_textBox &amp;&amp; m_remainingTextBox) {
 834         m_textBox = m_remainingTextBox;
 835         m_remainingTextBox = nullptr;
 836         m_firstLetterText = nullptr;
 837         m_offset = 0;
 838         handleTextBox();
 839     }
 840 }
 841 
 842 static inline RenderText* firstRenderTextInFirstLetter(RenderBoxModelObject* firstLetter)
 843 {
 844     if (!firstLetter)
 845         return nullptr;
 846 
 847     // FIXME: Should this check descendent objects?
 848     return childrenOfType&lt;RenderText&gt;(*firstLetter).first();
 849 }
 850 
 851 void TextIterator::handleTextNodeFirstLetter(RenderTextFragment&amp; renderer)
 852 {
 853     if (auto* firstLetter = renderer.firstLetter()) {
 854         if (firstLetter-&gt;style().visibility() != Visibility::Visible &amp;&amp; !(m_behavior &amp; TextIteratorIgnoresStyleVisibility))
 855             return;
 856         if (auto* firstLetterText = firstRenderTextInFirstLetter(firstLetter)) {
 857             m_handledFirstLetter = true;
 858             m_remainingTextBox = m_textBox;
 859             m_textBox = firstLetterText-&gt;firstTextBox();
 860             m_sortedTextBoxes.clear();
 861             m_firstLetterText = firstLetterText;
 862         }
 863     }
 864     m_handledFirstLetter = true;
 865 }
 866 
 867 bool TextIterator::handleReplacedElement()
 868 {
 869     if (m_fullyClippedStack.top())
 870         return false;
 871 
 872     auto&amp; renderer = *m_node-&gt;renderer();
 873     if (renderer.style().visibility() != Visibility::Visible &amp;&amp; !(m_behavior &amp; TextIteratorIgnoresStyleVisibility))
 874         return false;
 875 
 876     if (m_lastTextNodeEndedWithCollapsedSpace) {
 877         emitCharacter(&#39; &#39;, *m_lastTextNode-&gt;parentNode(), m_lastTextNode, 1, 1);
 878         return false;
 879     }
 880 
 881     if ((m_behavior &amp; TextIteratorEntersTextControls) &amp;&amp; is&lt;RenderTextControl&gt;(renderer)) {
 882         if (auto innerTextElement = downcast&lt;RenderTextControl&gt;(renderer).textFormControlElement().innerTextElement()) {
 883             m_node = innerTextElement-&gt;containingShadowRoot();
 884             pushFullyClippedState(m_fullyClippedStack, *m_node);
 885             m_offset = 0;
 886             return false;
 887         }
 888     }
 889 
 890     m_hasEmitted = true;
 891 
 892     if ((m_behavior &amp; TextIteratorEmitsObjectReplacementCharacters) &amp;&amp; renderer.isReplaced()) {
 893         emitCharacter(objectReplacementCharacter, *m_node-&gt;parentNode(), m_node, 0, 1);
 894         // Don&#39;t process subtrees for embedded objects. If the text there is required,
 895         // it must be explicitly asked by specifying a range falling inside its boundaries.
 896         m_handledChildren = true;
 897         return true;
 898     }
 899 
 900     if (m_behavior &amp; TextIteratorEmitsCharactersBetweenAllVisiblePositions) {
 901         // We want replaced elements to behave like punctuation for boundary
 902         // finding, and to simply take up space for the selection preservation
 903         // code in moveParagraphs, so we use a comma.
 904         emitCharacter(&#39;,&#39;, *m_node-&gt;parentNode(), m_node, 0, 1);
 905         return true;
 906     }
 907 
 908     m_positionNode = m_node-&gt;parentNode();
 909     m_positionOffsetBaseNode = m_node;
 910     m_positionStartOffset = 0;
 911     m_positionEndOffset = 1;
 912 
 913     if ((m_behavior &amp; TextIteratorEmitsImageAltText) &amp;&amp; is&lt;RenderImage&gt;(renderer)) {
 914         String altText = downcast&lt;RenderImage&gt;(renderer).altText();
 915         if (unsigned length = altText.length()) {
 916             m_lastCharacter = altText[length - 1];
 917             m_copyableText.set(WTFMove(altText));
 918             m_text = m_copyableText.text();
 919             return true;
 920         }
 921     }
 922 
 923     m_copyableText.reset();
 924     m_text = StringView();
 925     m_lastCharacter = 0;
 926     return true;
 927 }
 928 
 929 static bool shouldEmitTabBeforeNode(Node&amp; node)
 930 {
 931     auto* renderer = node.renderer();
 932 
 933     // Table cells are delimited by tabs.
 934     if (!renderer || !isTableCell(&amp;node))
 935         return false;
 936 
 937     // Want a tab before every cell other than the first one.
 938     RenderTableCell&amp; cell = downcast&lt;RenderTableCell&gt;(*renderer);
 939     RenderTable* table = cell.table();
 940     return table &amp;&amp; (table-&gt;cellBefore(&amp;cell) || table-&gt;cellAbove(&amp;cell));
 941 }
 942 
 943 static bool shouldEmitNewlineForNode(Node* node, bool emitsOriginalText)
 944 {
 945     auto* renderer = node-&gt;renderer();
 946     if (!(renderer ? renderer-&gt;isBR() : node-&gt;hasTagName(brTag)))
 947         return false;
 948     return emitsOriginalText || !(node-&gt;isInShadowTree() &amp;&amp; is&lt;HTMLInputElement&gt;(*node-&gt;shadowHost()));
 949 }
 950 
 951 static bool hasHeaderTag(HTMLElement&amp; element)
 952 {
 953     return element.hasTagName(h1Tag)
 954         || element.hasTagName(h2Tag)
 955         || element.hasTagName(h3Tag)
 956         || element.hasTagName(h4Tag)
 957         || element.hasTagName(h5Tag)
 958         || element.hasTagName(h6Tag);
 959 }
 960 
 961 static bool shouldEmitNewlinesBeforeAndAfterNode(Node&amp; node)
 962 {
 963     // Block flow (versus inline flow) is represented by having
 964     // a newline both before and after the element.
 965     auto* renderer = node.renderer();
 966     if (!renderer) {
 967         if (!is&lt;HTMLElement&gt;(node))
 968             return false;
 969         auto&amp; element = downcast&lt;HTMLElement&gt;(node);
 970         return hasHeaderTag(element)
 971             || element.hasTagName(blockquoteTag)
 972             || element.hasTagName(ddTag)
 973             || element.hasTagName(divTag)
 974             || element.hasTagName(dlTag)
 975             || element.hasTagName(dtTag)
 976             || element.hasTagName(hrTag)
 977             || element.hasTagName(liTag)
 978             || element.hasTagName(listingTag)
 979             || element.hasTagName(olTag)
 980             || element.hasTagName(pTag)
 981             || element.hasTagName(preTag)
 982             || element.hasTagName(trTag)
 983             || element.hasTagName(ulTag);
 984     }
 985 
 986     // Need to make an exception for table cells, because they are blocks, but we
 987     // want them tab-delimited rather than having newlines before and after.
 988     if (isTableCell(&amp;node))
 989         return false;
 990 
 991     // Need to make an exception for table row elements, because they are neither
 992     // &quot;inline&quot; or &quot;RenderBlock&quot;, but we want newlines for them.
 993     if (is&lt;RenderTableRow&gt;(*renderer)) {
 994         RenderTable* table = downcast&lt;RenderTableRow&gt;(*renderer).table();
 995         if (table &amp;&amp; !table-&gt;isInline())
 996             return true;
 997     }
 998 
 999     return !renderer-&gt;isInline()
1000         &amp;&amp; is&lt;RenderBlock&gt;(*renderer)
1001         &amp;&amp; !renderer-&gt;isFloatingOrOutOfFlowPositioned()
1002         &amp;&amp; !renderer-&gt;isBody()
1003         &amp;&amp; !renderer-&gt;isRubyText();
1004 }
1005 
1006 static bool shouldEmitNewlineAfterNode(Node&amp; node, bool emitsCharactersBetweenAllVisiblePositions = false)
1007 {
1008     // FIXME: It should be better but slower to create a VisiblePosition here.
1009     if (!shouldEmitNewlinesBeforeAndAfterNode(node))
1010         return false;
1011 
1012     // Don&#39;t emit a new line at the end of the document unless we&#39;re matching the behavior of VisiblePosition.
1013     if (emitsCharactersBetweenAllVisiblePositions)
1014         return true;
1015     Node* subsequentNode = &amp;node;
1016     while ((subsequentNode = NodeTraversal::nextSkippingChildren(*subsequentNode))) {
1017         if (subsequentNode-&gt;renderer())
1018             return true;
1019     }
1020     return false;
1021 }
1022 
1023 static bool shouldEmitNewlineBeforeNode(Node&amp; node)
1024 {
1025     return shouldEmitNewlinesBeforeAndAfterNode(node);
1026 }
1027 
1028 static bool shouldEmitExtraNewlineForNode(Node&amp; node)
1029 {
1030     // When there is a significant collapsed bottom margin, emit an extra
1031     // newline for a more realistic result. We end up getting the right
1032     // result even without margin collapsing. For example: &lt;div&gt;&lt;p&gt;text&lt;/p&gt;&lt;/div&gt;
1033     // will work right even if both the &lt;div&gt; and the &lt;p&gt; have bottom margins.
1034 
1035     auto* renderer = node.renderer();
1036     if (!is&lt;RenderBox&gt;(renderer))
1037         return false;
1038 
1039     // NOTE: We only do this for a select set of nodes, and WinIE appears not to do this at all.
1040     if (!is&lt;HTMLElement&gt;(node))
1041         return false;
1042 
1043     HTMLElement&amp; element = downcast&lt;HTMLElement&gt;(node);
1044     if (!hasHeaderTag(element) &amp;&amp; !is&lt;HTMLParagraphElement&gt;(element))
1045         return false;
1046 
1047     auto&amp; renderBox = downcast&lt;RenderBox&gt;(*renderer);
1048     if (!renderBox.height())
1049         return false;
1050 
1051     int bottomMargin = renderBox.collapsedMarginAfter();
1052     int fontSize = renderBox.style().fontDescription().computedPixelSize();
1053     return bottomMargin * 2 &gt;= fontSize;
1054 }
1055 
1056 static int collapsedSpaceLength(RenderText&amp; renderer, int textEnd)
1057 {
1058     StringImpl&amp; text = renderer.text();
1059     unsigned length = text.length();
1060     for (unsigned i = textEnd; i &lt; length; ++i) {
1061         if (!renderer.style().isCollapsibleWhiteSpace(text[i]))
1062             return i - textEnd;
1063     }
1064     return length - textEnd;
1065 }
1066 
1067 static int maxOffsetIncludingCollapsedSpaces(Node&amp; node)
1068 {
1069     int offset = caretMaxOffset(node);
1070     if (auto* renderer = node.renderer()) {
1071         if (is&lt;RenderText&gt;(*renderer))
1072             offset += collapsedSpaceLength(downcast&lt;RenderText&gt;(*renderer), offset);
1073     }
1074     return offset;
1075 }
1076 
1077 // Whether or not we should emit a character as we enter m_node (if it&#39;s a container) or as we hit it (if it&#39;s atomic).
1078 bool TextIterator::shouldRepresentNodeOffsetZero()
1079 {
1080     if ((m_behavior &amp; TextIteratorEmitsCharactersBetweenAllVisiblePositions) &amp;&amp; m_node-&gt;renderer() &amp;&amp; m_node-&gt;renderer()-&gt;isTable())
1081         return true;
1082 
1083     // Leave element positioned flush with start of a paragraph
1084     // (e.g. do not insert tab before a table cell at the start of a paragraph)
1085     if (m_lastCharacter == &#39;\n&#39;)
1086         return false;
1087 
1088     // Otherwise, show the position if we have emitted any characters
1089     if (m_hasEmitted)
1090         return true;
1091 
1092     // We&#39;ve not emitted anything yet. Generally, there is no need for any positioning then.
1093     // The only exception is when the element is visually not in the same line as
1094     // the start of the range (e.g. the range starts at the end of the previous paragraph).
1095     // NOTE: Creating VisiblePositions and comparing them is relatively expensive, so we
1096     // make quicker checks to possibly avoid that. Another check that we could make is
1097     // is whether the inline vs block flow changed since the previous visible element.
1098     // I think we&#39;re already in a special enough case that that won&#39;t be needed, tho.
1099 
1100     // No character needed if this is the first node in the range.
1101     if (m_node == m_startContainer)
1102         return false;
1103 
1104     // If we are outside the start container&#39;s subtree, assume we need to emit.
1105     // FIXME: m_startContainer could be an inline block
1106     if (!m_node-&gt;isDescendantOf(m_startContainer))
1107         return true;
1108 
1109     // If we started as m_startContainer offset 0 and the current node is a descendant of
1110     // the start container, we already had enough context to correctly decide whether to
1111     // emit after a preceding block. We chose not to emit (m_hasEmitted is false),
1112     // so don&#39;t second guess that now.
1113     // NOTE: Is this really correct when m_node is not a leftmost descendant? Probably
1114     // immaterial since we likely would have already emitted something by now.
1115     if (m_startOffset == 0)
1116         return false;
1117 
1118     // If this node is unrendered or invisible the VisiblePosition checks below won&#39;t have much meaning.
1119     // Additionally, if the range we are iterating over contains huge sections of unrendered content,
1120     // we would create VisiblePositions on every call to this function without this check.
1121     if (!m_node-&gt;renderer() || m_node-&gt;renderer()-&gt;style().visibility() != Visibility::Visible
1122         || (is&lt;RenderBlockFlow&gt;(*m_node-&gt;renderer()) &amp;&amp; !downcast&lt;RenderBlockFlow&gt;(*m_node-&gt;renderer()).height() &amp;&amp; !is&lt;HTMLBodyElement&gt;(*m_node)))
1123         return false;
1124 
1125     // The startPos.isNotNull() check is needed because the start could be before the body,
1126     // and in that case we&#39;ll get null. We don&#39;t want to put in newlines at the start in that case.
1127     // The currPos.isNotNull() check is needed because positions in non-HTML content
1128     // (like SVG) do not have visible positions, and we don&#39;t want to emit for them either.
1129     VisiblePosition startPos = VisiblePosition(Position(m_startContainer, m_startOffset, Position::PositionIsOffsetInAnchor), DOWNSTREAM);
1130     VisiblePosition currPos = VisiblePosition(positionBeforeNode(m_node), DOWNSTREAM);
1131     return startPos.isNotNull() &amp;&amp; currPos.isNotNull() &amp;&amp; !inSameLine(startPos, currPos);
1132 }
1133 
1134 bool TextIterator::shouldEmitSpaceBeforeAndAfterNode(Node&amp; node)
1135 {
1136     return node.renderer() &amp;&amp; node.renderer()-&gt;isTable() &amp;&amp; (node.renderer()-&gt;isInline() || (m_behavior &amp; TextIteratorEmitsCharactersBetweenAllVisiblePositions));
1137 }
1138 
1139 void TextIterator::representNodeOffsetZero()
1140 {
1141     // Emit a character to show the positioning of m_node.
1142 
1143     // When we haven&#39;t been emitting any characters, shouldRepresentNodeOffsetZero() can
1144     // create VisiblePositions, which is expensive. So, we perform the inexpensive checks
1145     // on m_node to see if it necessitates emitting a character first and will early return
1146     // before encountering shouldRepresentNodeOffsetZero()s worse case behavior.
1147     if (shouldEmitTabBeforeNode(*m_node)) {
1148         if (shouldRepresentNodeOffsetZero())
1149             emitCharacter(&#39;\t&#39;, *m_node-&gt;parentNode(), m_node, 0, 0);
1150     } else if (shouldEmitNewlineBeforeNode(*m_node)) {
1151         if (shouldRepresentNodeOffsetZero())
1152             emitCharacter(&#39;\n&#39;, *m_node-&gt;parentNode(), m_node, 0, 0);
1153     } else if (shouldEmitSpaceBeforeAndAfterNode(*m_node)) {
1154         if (shouldRepresentNodeOffsetZero())
1155             emitCharacter(&#39; &#39;, *m_node-&gt;parentNode(), m_node, 0, 0);
1156     }
1157 }
1158 
1159 bool TextIterator::handleNonTextNode()
1160 {
1161     if (shouldEmitNewlineForNode(m_node, m_behavior &amp; TextIteratorEmitsOriginalText))
1162         emitCharacter(&#39;\n&#39;, *m_node-&gt;parentNode(), m_node, 0, 1);
1163     else if ((m_behavior &amp; TextIteratorEmitsCharactersBetweenAllVisiblePositions) &amp;&amp; m_node-&gt;renderer() &amp;&amp; m_node-&gt;renderer()-&gt;isHR())
1164         emitCharacter(&#39; &#39;, *m_node-&gt;parentNode(), m_node, 0, 1);
1165     else
1166         representNodeOffsetZero();
1167 
1168     return true;
1169 }
1170 
1171 void TextIterator::exitNode(Node* exitedNode)
1172 {
1173     // prevent emitting a newline when exiting a collapsed block at beginning of the range
1174     // FIXME: !m_hasEmitted does not necessarily mean there was a collapsed block... it could
1175     // have been an hr (e.g.). Also, a collapsed block could have height (e.g. a table) and
1176     // therefore look like a blank line.
1177     if (!m_hasEmitted)
1178         return;
1179 
1180     // Emit with a position *inside* m_node, after m_node&#39;s contents, in
1181     // case it is a block, because the run should start where the
1182     // emitted character is positioned visually.
1183     Node* baseNode = exitedNode;
1184     // FIXME: This shouldn&#39;t require the m_lastTextNode to be true, but we can&#39;t change that without making
1185     // the logic in _web_attributedStringFromRange match. We&#39;ll get that for free when we switch to use
1186     // TextIterator in _web_attributedStringFromRange.
1187     // See &lt;rdar://problem/5428427&gt; for an example of how this mismatch will cause problems.
1188     if (m_lastTextNode &amp;&amp; shouldEmitNewlineAfterNode(*m_node, m_behavior &amp; TextIteratorEmitsCharactersBetweenAllVisiblePositions)) {
1189         // use extra newline to represent margin bottom, as needed
1190         bool addNewline = shouldEmitExtraNewlineForNode(*m_node);
1191 
1192         // FIXME: We need to emit a &#39;\n&#39; as we leave an empty block(s) that
1193         // contain a VisiblePosition when doing selection preservation.
1194         if (m_lastCharacter != &#39;\n&#39;) {
1195             // insert a newline with a position following this block&#39;s contents.
1196             emitCharacter(&#39;\n&#39;, *baseNode-&gt;parentNode(), baseNode, 1, 1);
1197             // remember whether to later add a newline for the current node
1198             ASSERT(!m_nodeForAdditionalNewline);
1199             if (addNewline)
1200                 m_nodeForAdditionalNewline = baseNode;
1201         } else if (addNewline)
1202             // insert a newline with a position following this block&#39;s contents.
1203             emitCharacter(&#39;\n&#39;, *baseNode-&gt;parentNode(), baseNode, 1, 1);
1204     }
1205 
1206     // If nothing was emitted, see if we need to emit a space.
1207     if (!m_positionNode &amp;&amp; shouldEmitSpaceBeforeAndAfterNode(*m_node))
1208         emitCharacter(&#39; &#39;, *baseNode-&gt;parentNode(), baseNode, 1, 1);
1209 }
1210 
1211 void TextIterator::emitCharacter(UChar character, Node&amp; characterNode, Node* offsetBaseNode, int textStartOffset, int textEndOffset)
1212 {
1213     m_hasEmitted = true;
1214 
1215     // remember information with which to construct the TextIterator::range()
1216     m_positionNode = &amp;characterNode;
1217     m_positionOffsetBaseNode = offsetBaseNode;
1218     m_positionStartOffset = textStartOffset;
1219     m_positionEndOffset = textEndOffset;
1220 
1221     m_copyableText.set(character);
1222     m_text = m_copyableText.text();
1223     m_lastCharacter = character;
1224     m_lastTextNodeEndedWithCollapsedSpace = false;
1225     m_nextRunNeedsWhitespace = false;
1226 }
1227 
1228 void TextIterator::emitText(Text&amp; textNode, RenderText&amp; renderer, int textStartOffset, int textEndOffset)
1229 {
1230     ASSERT(textStartOffset &gt;= 0);
1231     ASSERT(textEndOffset &gt;= 0);
1232     ASSERT(textStartOffset &lt;= textEndOffset);
1233 
1234     // FIXME: This probably yields the wrong offsets when text-transform: lowercase turns a single character into two characters.
1235     String string = (m_behavior &amp; TextIteratorEmitsOriginalText) ? renderer.originalText()
1236         : ((m_behavior &amp; TextIteratorEmitsTextsWithoutTranscoding) ? renderer.textWithoutConvertingBackslashToYenSymbol() : renderer.text());
1237 
1238     ASSERT(string.length() &gt;= static_cast&lt;unsigned&gt;(textEndOffset));
1239 
1240     m_positionNode = &amp;textNode;
1241     m_positionOffsetBaseNode = nullptr;
1242     m_positionStartOffset = textStartOffset;
1243     m_positionEndOffset = textEndOffset;
1244 
1245     m_lastCharacter = string[textEndOffset - 1];
1246     m_copyableText.set(WTFMove(string), textStartOffset, textEndOffset - textStartOffset);
1247     m_text = m_copyableText.text();
1248 
1249     m_lastTextNodeEndedWithCollapsedSpace = false;
1250     m_nextRunNeedsWhitespace = false;
1251     m_hasEmitted = true;
1252 }
1253 
1254 Ref&lt;Range&gt; TextIterator::range() const
1255 {
1256     ASSERT(!atEnd());
1257 
1258     // use the current run information, if we have it
1259     if (m_positionOffsetBaseNode) {
1260         unsigned index = m_positionOffsetBaseNode-&gt;computeNodeIndex();
1261         m_positionStartOffset += index;
1262         m_positionEndOffset += index;
1263         m_positionOffsetBaseNode = nullptr;
1264     }
1265     return Range::create(m_positionNode-&gt;document(), m_positionNode, m_positionStartOffset, m_positionNode, m_positionEndOffset);
1266 }
1267 
1268 Node* TextIterator::node() const
1269 {
1270     Ref&lt;Range&gt; textRange = range();
1271 
1272     Node&amp; node = textRange-&gt;startContainer();
1273     if (node.isCharacterDataNode())
1274         return &amp;node;
1275 
1276     return node.traverseToChildAt(textRange-&gt;startOffset());
1277 }
1278 
1279 // --------
1280 
1281 SimplifiedBackwardsTextIterator::SimplifiedBackwardsTextIterator(const Range&amp; range)
1282 {
1283     range.ownerDocument().updateLayoutIgnorePendingStylesheets();
1284 
1285     Node* startNode = &amp;range.startContainer();
1286     Node* endNode = &amp;range.endContainer();
1287     int startOffset = range.startOffset();
1288     int endOffset = range.endOffset();
1289 
1290     if (!startNode-&gt;isCharacterDataNode()) {
1291         if (startOffset &gt;= 0 &amp;&amp; startOffset &lt; static_cast&lt;int&gt;(startNode-&gt;countChildNodes())) {
1292             startNode = startNode-&gt;traverseToChildAt(startOffset);
1293             startOffset = 0;
1294         }
1295     }
1296     if (!endNode-&gt;isCharacterDataNode()) {
1297         if (endOffset &gt; 0 &amp;&amp; endOffset &lt;= static_cast&lt;int&gt;(endNode-&gt;countChildNodes())) {
1298             endNode = endNode-&gt;traverseToChildAt(endOffset - 1);
1299             endOffset = lastOffsetInNode(endNode);
1300         }
1301     }
1302 
1303     m_node = endNode;
1304     setUpFullyClippedStack(m_fullyClippedStack, *m_node);
1305     m_offset = endOffset;
1306     m_handledNode = false;
1307     m_handledChildren = endOffset == 0;
1308 
1309     m_startContainer = startNode;
1310     m_startOffset = startOffset;
1311     m_endContainer = endNode;
1312     m_endOffset = endOffset;
1313 
1314     m_positionNode = endNode;
1315 
1316     m_lastTextNode = nullptr;
1317     m_lastCharacter = &#39;\n&#39;;
1318 
1319     m_havePassedStartContainer = false;
1320 
1321     advance();
1322 }
1323 
1324 void SimplifiedBackwardsTextIterator::advance()
1325 {
1326     ASSERT(!atEnd());
1327 
1328     m_positionNode = nullptr;
1329     m_copyableText.reset();
1330     m_text = StringView();
1331 
1332     while (m_node &amp;&amp; !m_havePassedStartContainer) {
1333         // Don&#39;t handle node if we start iterating at [node, 0].
1334         if (!m_handledNode &amp;&amp; !(m_node == m_endContainer &amp;&amp; !m_endOffset)) {
1335             auto* renderer = m_node-&gt;renderer();
1336             if (renderer &amp;&amp; renderer-&gt;isText() &amp;&amp; m_node-&gt;isTextNode()) {
1337                 if (renderer-&gt;style().visibility() == Visibility::Visible &amp;&amp; m_offset &gt; 0)
1338                     m_handledNode = handleTextNode();
1339             } else if (renderer &amp;&amp; (renderer-&gt;isImage() || renderer-&gt;isWidget())) {
1340                 if (renderer-&gt;style().visibility() == Visibility::Visible &amp;&amp; m_offset &gt; 0)
1341                     m_handledNode = handleReplacedElement();
1342             } else
1343                 m_handledNode = handleNonTextNode();
1344             if (m_positionNode)
1345                 return;
1346         }
1347 
1348         if (!m_handledChildren &amp;&amp; m_node-&gt;hasChildNodes()) {
1349             m_node = m_node-&gt;lastChild();
1350             pushFullyClippedState(m_fullyClippedStack, *m_node);
1351         } else {
1352             // Exit empty containers as we pass over them or containers
1353             // where [container, 0] is where we started iterating.
1354             if (!m_handledNode &amp;&amp; canHaveChildrenForEditing(*m_node) &amp;&amp; m_node-&gt;parentNode() &amp;&amp; (!m_node-&gt;lastChild() || (m_node == m_endContainer &amp;&amp; !m_endOffset))) {
1355                 exitNode();
1356                 if (m_positionNode) {
1357                     m_handledNode = true;
1358                     m_handledChildren = true;
1359                     return;
1360                 }
1361             }
1362 
1363             // Exit all other containers.
1364             while (!m_node-&gt;previousSibling()) {
1365                 if (!advanceRespectingRange(m_node-&gt;parentOrShadowHostNode()))
1366                     break;
1367                 m_fullyClippedStack.pop();
1368                 exitNode();
1369                 if (m_positionNode) {
1370                     m_handledNode = true;
1371                     m_handledChildren = true;
1372                     return;
1373                 }
1374             }
1375 
1376             m_fullyClippedStack.pop();
1377             if (advanceRespectingRange(m_node-&gt;previousSibling()))
1378                 pushFullyClippedState(m_fullyClippedStack, *m_node);
1379             else
1380                 m_node = nullptr;
1381         }
1382 
1383         // For the purpose of word boundary detection,
1384         // we should iterate all visible text and trailing (collapsed) whitespaces.
1385         m_offset = m_node ? maxOffsetIncludingCollapsedSpaces(*m_node) : 0;
1386         m_handledNode = false;
1387         m_handledChildren = false;
1388 
1389         if (m_positionNode)
1390             return;
1391     }
1392 }
1393 
1394 bool SimplifiedBackwardsTextIterator::handleTextNode()
1395 {
1396     Text&amp; textNode = downcast&lt;Text&gt;(*m_node);
1397 
1398     m_lastTextNode = &amp;textNode;
1399 
1400     int startOffset;
1401     int offsetInNode;
1402     RenderText* renderer = handleFirstLetter(startOffset, offsetInNode);
1403     if (!renderer)
1404         return true;
1405 
1406     String text = renderer-&gt;text();
1407     if (!renderer-&gt;hasRenderedText() &amp;&amp; text.length())
1408         return true;
1409 
1410     if (startOffset + offsetInNode == m_offset) {
1411         ASSERT(!m_shouldHandleFirstLetter);
1412         return true;
1413     }
1414 
1415     m_positionEndOffset = m_offset;
1416     m_offset = startOffset + offsetInNode;
1417     m_positionNode = m_node;
1418     m_positionStartOffset = m_offset;
1419 
1420     ASSERT(m_positionStartOffset &lt; m_positionEndOffset);
1421     ASSERT(m_positionStartOffset - offsetInNode &gt;= 0);
1422     ASSERT(m_positionEndOffset - offsetInNode &gt; 0);
1423     ASSERT(m_positionEndOffset - offsetInNode &lt;= static_cast&lt;int&gt;(text.length()));
1424 
1425     m_lastCharacter = text[m_positionEndOffset - offsetInNode - 1];
1426     m_copyableText.set(WTFMove(text), m_positionStartOffset - offsetInNode, m_positionEndOffset - m_positionStartOffset);
1427     m_text = m_copyableText.text();
1428 
1429     return !m_shouldHandleFirstLetter;
1430 }
1431 
1432 RenderText* SimplifiedBackwardsTextIterator::handleFirstLetter(int&amp; startOffset, int&amp; offsetInNode)
1433 {
1434     RenderText&amp; renderer = downcast&lt;RenderText&gt;(*m_node-&gt;renderer());
1435     startOffset = (m_node == m_startContainer) ? m_startOffset : 0;
1436 
1437     if (!is&lt;RenderTextFragment&gt;(renderer)) {
1438         offsetInNode = 0;
1439         return &amp;renderer;
1440     }
1441 
1442     RenderTextFragment&amp; fragment = downcast&lt;RenderTextFragment&gt;(renderer);
1443     int offsetAfterFirstLetter = fragment.start();
1444     if (startOffset &gt;= offsetAfterFirstLetter) {
1445         ASSERT(!m_shouldHandleFirstLetter);
1446         offsetInNode = offsetAfterFirstLetter;
1447         return &amp;renderer;
1448     }
1449 
1450     if (!m_shouldHandleFirstLetter &amp;&amp; startOffset + offsetAfterFirstLetter &lt; m_offset) {
1451         m_shouldHandleFirstLetter = true;
1452         offsetInNode = offsetAfterFirstLetter;
1453         return &amp;renderer;
1454     }
1455 
1456     m_shouldHandleFirstLetter = false;
1457     offsetInNode = 0;
1458     RenderText* firstLetterRenderer = firstRenderTextInFirstLetter(fragment.firstLetter());
1459 
1460     m_offset = firstLetterRenderer-&gt;caretMaxOffset();
1461     m_offset += collapsedSpaceLength(*firstLetterRenderer, m_offset);
1462 
1463     return firstLetterRenderer;
1464 }
1465 
1466 bool SimplifiedBackwardsTextIterator::handleReplacedElement()
1467 {
1468     unsigned index = m_node-&gt;computeNodeIndex();
1469     // We want replaced elements to behave like punctuation for boundary
1470     // finding, and to simply take up space for the selection preservation
1471     // code in moveParagraphs, so we use a comma. Unconditionally emit
1472     // here because this iterator is only used for boundary finding.
1473     emitCharacter(&#39;,&#39;, *m_node-&gt;parentNode(), index, index + 1);
1474     return true;
1475 }
1476 
1477 bool SimplifiedBackwardsTextIterator::handleNonTextNode()
1478 {
1479     // We can use a linefeed in place of a tab because this simple iterator is only used to
1480     // find boundaries, not actual content. A linefeed breaks words, sentences, and paragraphs.
1481     if (shouldEmitNewlineForNode(m_node, m_behavior &amp; TextIteratorEmitsOriginalText) || shouldEmitNewlineAfterNode(*m_node) || shouldEmitTabBeforeNode(*m_node)) {
1482         unsigned index = m_node-&gt;computeNodeIndex();
1483         // The start of this emitted range is wrong. Ensuring correctness would require
1484         // VisiblePositions and so would be slow. previousBoundary expects this.
1485         emitCharacter(&#39;\n&#39;, *m_node-&gt;parentNode(), index + 1, index + 1);
1486     }
1487     return true;
1488 }
1489 
1490 void SimplifiedBackwardsTextIterator::exitNode()
1491 {
1492     if (shouldEmitNewlineForNode(m_node, m_behavior &amp; TextIteratorEmitsOriginalText) || shouldEmitNewlineBeforeNode(*m_node) || shouldEmitTabBeforeNode(*m_node)) {
1493         // The start of this emitted range is wrong. Ensuring correctness would require
1494         // VisiblePositions and so would be slow. previousBoundary expects this.
1495         emitCharacter(&#39;\n&#39;, *m_node, 0, 0);
1496     }
1497 }
1498 
1499 void SimplifiedBackwardsTextIterator::emitCharacter(UChar c, Node&amp; node, int startOffset, int endOffset)
1500 {
1501     m_positionNode = &amp;node;
1502     m_positionStartOffset = startOffset;
1503     m_positionEndOffset = endOffset;
1504     m_copyableText.set(c);
1505     m_text = m_copyableText.text();
1506     m_lastCharacter = c;
1507 }
1508 
1509 bool SimplifiedBackwardsTextIterator::advanceRespectingRange(Node* next)
1510 {
1511     if (!next)
1512         return false;
1513     m_havePassedStartContainer |= m_node == m_startContainer;
1514     if (m_havePassedStartContainer)
1515         return false;
1516     m_node = next;
1517     return true;
1518 }
1519 
1520 Ref&lt;Range&gt; SimplifiedBackwardsTextIterator::range() const
1521 {
1522     ASSERT(!atEnd());
1523 
1524     return Range::create(m_positionNode-&gt;document(), m_positionNode, m_positionStartOffset, m_positionNode, m_positionEndOffset);
1525 }
1526 
1527 // --------
1528 
1529 CharacterIterator::CharacterIterator(const Range&amp; range, TextIteratorBehavior behavior)
1530     : m_underlyingIterator(&amp;range, behavior)
1531     , m_offset(0)
1532     , m_runOffset(0)
1533     , m_atBreak(true)
1534 {
1535     while (!atEnd() &amp;&amp; !m_underlyingIterator.text().length())
1536         m_underlyingIterator.advance();
1537 }
1538 
1539 Ref&lt;Range&gt; CharacterIterator::range() const
1540 {
1541     Ref&lt;Range&gt; range = m_underlyingIterator.range();
1542     if (!m_underlyingIterator.atEnd()) {
1543         if (m_underlyingIterator.text().length() &lt;= 1) {
1544             ASSERT(m_runOffset == 0);
1545         } else {
1546             Node&amp; node = range-&gt;startContainer();
1547             ASSERT(&amp;node == &amp;range-&gt;endContainer());
1548             int offset = range-&gt;startOffset() + m_runOffset;
1549             range-&gt;setStart(node, offset);
1550             range-&gt;setEnd(node, offset + 1);
1551         }
1552     }
1553     return range;
1554 }
1555 
1556 void CharacterIterator::advance(int count)
1557 {
1558     if (count &lt;= 0) {
1559         ASSERT(count == 0);
1560         return;
1561     }
1562 
1563     m_atBreak = false;
1564 
1565     // easy if there is enough left in the current m_underlyingIterator run
1566     int remaining = m_underlyingIterator.text().length() - m_runOffset;
1567     if (count &lt; remaining) {
1568         m_runOffset += count;
1569         m_offset += count;
1570         return;
1571     }
1572 
1573     // exhaust the current m_underlyingIterator run
1574     count -= remaining;
1575     m_offset += remaining;
1576 
1577     // move to a subsequent m_underlyingIterator run
1578     for (m_underlyingIterator.advance(); !atEnd(); m_underlyingIterator.advance()) {
1579         int runLength = m_underlyingIterator.text().length();
1580         if (!runLength)
1581             m_atBreak = true;
1582         else {
1583             // see whether this is m_underlyingIterator to use
1584             if (count &lt; runLength) {
1585                 m_runOffset = count;
1586                 m_offset += count;
1587                 return;
1588             }
1589 
1590             // exhaust this m_underlyingIterator run
1591             count -= runLength;
1592             m_offset += runLength;
1593         }
1594     }
1595 
1596     // ran to the end of the m_underlyingIterator... no more runs left
1597     m_atBreak = true;
1598     m_runOffset = 0;
1599 }
1600 
1601 static Ref&lt;Range&gt; characterSubrange(Document&amp; document, CharacterIterator&amp; it, int offset, int length)
1602 {
1603     it.advance(offset);
1604     if (it.atEnd())
1605         return Range::create(document);
1606 
1607     Ref&lt;Range&gt; start = it.range();
1608 
1609     if (length &gt; 1)
1610         it.advance(length - 1);
1611     if (it.atEnd())
1612         return Range::create(document);
1613 
1614     Ref&lt;Range&gt; end = it.range();
1615 
1616     return Range::create(document, &amp;start-&gt;startContainer(), start-&gt;startOffset(), &amp;end-&gt;endContainer(), end-&gt;endOffset());
1617 }
1618 
1619 BackwardsCharacterIterator::BackwardsCharacterIterator(const Range&amp; range)
1620     : m_underlyingIterator(range)
1621     , m_offset(0)
1622     , m_runOffset(0)
1623     , m_atBreak(true)
1624 {
1625     while (!atEnd() &amp;&amp; !m_underlyingIterator.text().length())
1626         m_underlyingIterator.advance();
1627 }
1628 
1629 Ref&lt;Range&gt; BackwardsCharacterIterator::range() const
1630 {
1631     Ref&lt;Range&gt; r = m_underlyingIterator.range();
1632     if (!m_underlyingIterator.atEnd()) {
1633         if (m_underlyingIterator.text().length() &lt;= 1)
1634             ASSERT(m_runOffset == 0);
1635         else {
1636             Node&amp; node = r-&gt;startContainer();
1637             ASSERT(&amp;node == &amp;r-&gt;endContainer());
1638             int offset = r-&gt;endOffset() - m_runOffset;
1639             r-&gt;setStart(node, offset - 1);
1640             r-&gt;setEnd(node, offset);
1641         }
1642     }
1643     return r;
1644 }
1645 
1646 void BackwardsCharacterIterator::advance(int count)
1647 {
1648     if (count &lt;= 0) {
1649         ASSERT(!count);
1650         return;
1651     }
1652 
1653     m_atBreak = false;
1654 
1655     int remaining = m_underlyingIterator.text().length() - m_runOffset;
1656     if (count &lt; remaining) {
1657         m_runOffset += count;
1658         m_offset += count;
1659         return;
1660     }
1661 
1662     count -= remaining;
1663     m_offset += remaining;
1664 
1665     for (m_underlyingIterator.advance(); !atEnd(); m_underlyingIterator.advance()) {
1666         int runLength = m_underlyingIterator.text().length();
1667         if (runLength == 0)
1668             m_atBreak = true;
1669         else {
1670             if (count &lt; runLength) {
1671                 m_runOffset = count;
1672                 m_offset += count;
1673                 return;
1674             }
1675 
1676             count -= runLength;
1677             m_offset += runLength;
1678         }
1679     }
1680 
1681     m_atBreak = true;
1682     m_runOffset = 0;
1683 }
1684 
1685 // --------
1686 
1687 WordAwareIterator::WordAwareIterator(const Range&amp; range)
1688     : m_underlyingIterator(&amp;range)
1689     , m_didLookAhead(true) // so we consider the first chunk from the text iterator
1690 {
1691     advance(); // get in position over the first chunk of text
1692 }
1693 
1694 // We&#39;re always in one of these modes:
1695 // - The current chunk in the text iterator is our current chunk
1696 //      (typically its a piece of whitespace, or text that ended with whitespace)
1697 // - The previous chunk in the text iterator is our current chunk
1698 //      (we looked ahead to the next chunk and found a word boundary)
1699 // - We built up our own chunk of text from many chunks from the text iterator
1700 
1701 // FIXME: Performance could be bad for huge spans next to each other that don&#39;t fall on word boundaries.
1702 
1703 void WordAwareIterator::advance()
1704 {
1705     m_previousText.reset();
1706     m_buffer.clear();
1707 
1708     // If last time we did a look-ahead, start with that looked-ahead chunk now
1709     if (!m_didLookAhead) {
1710         ASSERT(!m_underlyingIterator.atEnd());
1711         m_underlyingIterator.advance();
1712     }
1713     m_didLookAhead = false;
1714 
1715     // Go to next non-empty chunk
1716     while (!m_underlyingIterator.atEnd() &amp;&amp; !m_underlyingIterator.text().length())
1717         m_underlyingIterator.advance();
1718     if (m_underlyingIterator.atEnd())
1719         return;
1720 
1721     while (1) {
1722         // If this chunk ends in whitespace we can just use it as our chunk.
1723         if (isSpaceOrNewline(m_underlyingIterator.text()[m_underlyingIterator.text().length() - 1]))
1724             return;
1725 
1726         // If this is the first chunk that failed, save it in previousText before look ahead
1727         if (m_buffer.isEmpty())
1728             m_previousText = m_underlyingIterator.copyableText();
1729 
1730         // Look ahead to next chunk. If it is whitespace or a break, we can use the previous stuff
1731         m_underlyingIterator.advance();
1732         if (m_underlyingIterator.atEnd() || !m_underlyingIterator.text().length() || isSpaceOrNewline(m_underlyingIterator.text()[0])) {
1733             m_didLookAhead = true;
1734             return;
1735         }
1736 
1737         if (m_buffer.isEmpty()) {
1738             // Start gobbling chunks until we get to a suitable stopping point
1739             append(m_buffer, m_previousText.text());
1740             m_previousText.reset();
1741         }
1742         append(m_buffer, m_underlyingIterator.text());
1743     }
1744 }
1745 
1746 StringView WordAwareIterator::text() const
1747 {
1748     if (!m_buffer.isEmpty())
1749         return StringView(m_buffer.data(), m_buffer.size());
1750     if (m_previousText.text().length())
1751         return m_previousText.text();
1752     return m_underlyingIterator.text();
1753 }
1754 
1755 // --------
1756 
1757 static inline UChar foldQuoteMark(UChar c)
1758 {
1759     switch (c) {
1760         case hebrewPunctuationGershayim:
1761         case leftDoubleQuotationMark:
1762         case leftLowDoubleQuotationMark:
1763         case rightDoubleQuotationMark:
1764             return &#39;&quot;&#39;;
1765         case hebrewPunctuationGeresh:
1766         case leftSingleQuotationMark:
1767         case leftLowSingleQuotationMark:
1768         case rightSingleQuotationMark:
1769             return &#39;\&#39;&#39;;
1770         default:
1771             return c;
1772     }
1773 }
1774 
1775 // FIXME: We&#39;d like to tailor the searcher to fold quote marks for us instead
1776 // of doing it in a separate replacement pass here, but ICU doesn&#39;t offer a way
1777 // to add tailoring on top of the locale-specific tailoring as of this writing.
1778 static inline String foldQuoteMarks(String string)
1779 {
1780     string.replace(hebrewPunctuationGeresh, &#39;\&#39;&#39;);
1781     string.replace(hebrewPunctuationGershayim, &#39;&quot;&#39;);
1782     string.replace(leftDoubleQuotationMark, &#39;&quot;&#39;);
1783     string.replace(leftLowDoubleQuotationMark, &#39;&quot;&#39;);
1784     string.replace(leftSingleQuotationMark, &#39;\&#39;&#39;);
1785     string.replace(leftLowSingleQuotationMark, &#39;\&#39;&#39;);
1786     string.replace(rightDoubleQuotationMark, &#39;&quot;&#39;);
1787     string.replace(rightSingleQuotationMark, &#39;\&#39;&#39;);
1788 
1789     return string;
1790 }
1791 
1792 #if !UCONFIG_NO_COLLATION
1793 
1794 const size_t minimumSearchBufferSize = 8192;
1795 
1796 #ifndef NDEBUG
1797 static bool searcherInUse;
1798 #endif
1799 
1800 static UStringSearch* createSearcher()
1801 {
1802     // Provide a non-empty pattern and non-empty text so usearch_open will not fail,
1803     // but it doesn&#39;t matter exactly what it is, since we don&#39;t perform any searches
1804     // without setting both the pattern and the text.
1805     UErrorCode status = U_ZERO_ERROR;
1806     String searchCollatorName = makeString(currentSearchLocaleID(), &quot;@collation=search&quot;);
1807     UStringSearch* searcher = usearch_open(&amp;newlineCharacter, 1, &amp;newlineCharacter, 1, searchCollatorName.utf8().data(), 0, &amp;status);
1808     ASSERT(status == U_ZERO_ERROR || status == U_USING_FALLBACK_WARNING || status == U_USING_DEFAULT_WARNING);
1809     return searcher;
1810 }
1811 
1812 static UStringSearch* searcher()
1813 {
1814     static UStringSearch* searcher = createSearcher();
1815     return searcher;
1816 }
1817 
1818 static inline void lockSearcher()
1819 {
1820 #ifndef NDEBUG
1821     ASSERT(!searcherInUse);
1822     searcherInUse = true;
1823 #endif
1824 }
1825 
1826 static inline void unlockSearcher()
1827 {
1828 #ifndef NDEBUG
1829     ASSERT(searcherInUse);
1830     searcherInUse = false;
1831 #endif
1832 }
1833 
1834 // ICU&#39;s search ignores the distinction between small kana letters and ones
1835 // that are not small, and also characters that differ only in the voicing
1836 // marks when considering only primary collation strength differences.
1837 // This is not helpful for end users, since these differences make words
1838 // distinct, so for our purposes we need these to be considered.
1839 // The Unicode folks do not think the collation algorithm should be
1840 // changed. To work around this, we would like to tailor the ICU searcher,
1841 // but we can&#39;t get that to work yet. So instead, we check for cases where
1842 // these differences occur, and skip those matches.
1843 
1844 // We refer to the above technique as the &quot;kana workaround&quot;. The next few
1845 // functions are helper functinos for the kana workaround.
1846 
1847 static inline bool isKanaLetter(UChar character)
1848 {
1849     // Hiragana letters.
1850     if (character &gt;= 0x3041 &amp;&amp; character &lt;= 0x3096)
1851         return true;
1852 
1853     // Katakana letters.
1854     if (character &gt;= 0x30A1 &amp;&amp; character &lt;= 0x30FA)
1855         return true;
1856     if (character &gt;= 0x31F0 &amp;&amp; character &lt;= 0x31FF)
1857         return true;
1858 
1859     // Halfwidth katakana letters.
1860     if (character &gt;= 0xFF66 &amp;&amp; character &lt;= 0xFF9D &amp;&amp; character != 0xFF70)
1861         return true;
1862 
1863     return false;
1864 }
1865 
1866 static inline bool isSmallKanaLetter(UChar character)
1867 {
1868     ASSERT(isKanaLetter(character));
1869 
1870     switch (character) {
1871     case 0x3041: // HIRAGANA LETTER SMALL A
1872     case 0x3043: // HIRAGANA LETTER SMALL I
1873     case 0x3045: // HIRAGANA LETTER SMALL U
1874     case 0x3047: // HIRAGANA LETTER SMALL E
1875     case 0x3049: // HIRAGANA LETTER SMALL O
1876     case 0x3063: // HIRAGANA LETTER SMALL TU
1877     case 0x3083: // HIRAGANA LETTER SMALL YA
1878     case 0x3085: // HIRAGANA LETTER SMALL YU
1879     case 0x3087: // HIRAGANA LETTER SMALL YO
1880     case 0x308E: // HIRAGANA LETTER SMALL WA
1881     case 0x3095: // HIRAGANA LETTER SMALL KA
1882     case 0x3096: // HIRAGANA LETTER SMALL KE
1883     case 0x30A1: // KATAKANA LETTER SMALL A
1884     case 0x30A3: // KATAKANA LETTER SMALL I
1885     case 0x30A5: // KATAKANA LETTER SMALL U
1886     case 0x30A7: // KATAKANA LETTER SMALL E
1887     case 0x30A9: // KATAKANA LETTER SMALL O
1888     case 0x30C3: // KATAKANA LETTER SMALL TU
1889     case 0x30E3: // KATAKANA LETTER SMALL YA
1890     case 0x30E5: // KATAKANA LETTER SMALL YU
1891     case 0x30E7: // KATAKANA LETTER SMALL YO
1892     case 0x30EE: // KATAKANA LETTER SMALL WA
1893     case 0x30F5: // KATAKANA LETTER SMALL KA
1894     case 0x30F6: // KATAKANA LETTER SMALL KE
1895     case 0x31F0: // KATAKANA LETTER SMALL KU
1896     case 0x31F1: // KATAKANA LETTER SMALL SI
1897     case 0x31F2: // KATAKANA LETTER SMALL SU
1898     case 0x31F3: // KATAKANA LETTER SMALL TO
1899     case 0x31F4: // KATAKANA LETTER SMALL NU
1900     case 0x31F5: // KATAKANA LETTER SMALL HA
1901     case 0x31F6: // KATAKANA LETTER SMALL HI
1902     case 0x31F7: // KATAKANA LETTER SMALL HU
1903     case 0x31F8: // KATAKANA LETTER SMALL HE
1904     case 0x31F9: // KATAKANA LETTER SMALL HO
1905     case 0x31FA: // KATAKANA LETTER SMALL MU
1906     case 0x31FB: // KATAKANA LETTER SMALL RA
1907     case 0x31FC: // KATAKANA LETTER SMALL RI
1908     case 0x31FD: // KATAKANA LETTER SMALL RU
1909     case 0x31FE: // KATAKANA LETTER SMALL RE
1910     case 0x31FF: // KATAKANA LETTER SMALL RO
1911     case 0xFF67: // HALFWIDTH KATAKANA LETTER SMALL A
1912     case 0xFF68: // HALFWIDTH KATAKANA LETTER SMALL I
1913     case 0xFF69: // HALFWIDTH KATAKANA LETTER SMALL U
1914     case 0xFF6A: // HALFWIDTH KATAKANA LETTER SMALL E
1915     case 0xFF6B: // HALFWIDTH KATAKANA LETTER SMALL O
1916     case 0xFF6C: // HALFWIDTH KATAKANA LETTER SMALL YA
1917     case 0xFF6D: // HALFWIDTH KATAKANA LETTER SMALL YU
1918     case 0xFF6E: // HALFWIDTH KATAKANA LETTER SMALL YO
1919     case 0xFF6F: // HALFWIDTH KATAKANA LETTER SMALL TU
1920         return true;
1921     }
1922     return false;
1923 }
1924 
1925 enum VoicedSoundMarkType { NoVoicedSoundMark, VoicedSoundMark, SemiVoicedSoundMark };
1926 
1927 static inline VoicedSoundMarkType composedVoicedSoundMark(UChar character)
1928 {
1929     ASSERT(isKanaLetter(character));
1930 
1931     switch (character) {
1932     case 0x304C: // HIRAGANA LETTER GA
1933     case 0x304E: // HIRAGANA LETTER GI
1934     case 0x3050: // HIRAGANA LETTER GU
1935     case 0x3052: // HIRAGANA LETTER GE
1936     case 0x3054: // HIRAGANA LETTER GO
1937     case 0x3056: // HIRAGANA LETTER ZA
1938     case 0x3058: // HIRAGANA LETTER ZI
1939     case 0x305A: // HIRAGANA LETTER ZU
1940     case 0x305C: // HIRAGANA LETTER ZE
1941     case 0x305E: // HIRAGANA LETTER ZO
1942     case 0x3060: // HIRAGANA LETTER DA
1943     case 0x3062: // HIRAGANA LETTER DI
1944     case 0x3065: // HIRAGANA LETTER DU
1945     case 0x3067: // HIRAGANA LETTER DE
1946     case 0x3069: // HIRAGANA LETTER DO
1947     case 0x3070: // HIRAGANA LETTER BA
1948     case 0x3073: // HIRAGANA LETTER BI
1949     case 0x3076: // HIRAGANA LETTER BU
1950     case 0x3079: // HIRAGANA LETTER BE
1951     case 0x307C: // HIRAGANA LETTER BO
1952     case 0x3094: // HIRAGANA LETTER VU
1953     case 0x30AC: // KATAKANA LETTER GA
1954     case 0x30AE: // KATAKANA LETTER GI
1955     case 0x30B0: // KATAKANA LETTER GU
1956     case 0x30B2: // KATAKANA LETTER GE
1957     case 0x30B4: // KATAKANA LETTER GO
1958     case 0x30B6: // KATAKANA LETTER ZA
1959     case 0x30B8: // KATAKANA LETTER ZI
1960     case 0x30BA: // KATAKANA LETTER ZU
1961     case 0x30BC: // KATAKANA LETTER ZE
1962     case 0x30BE: // KATAKANA LETTER ZO
1963     case 0x30C0: // KATAKANA LETTER DA
1964     case 0x30C2: // KATAKANA LETTER DI
1965     case 0x30C5: // KATAKANA LETTER DU
1966     case 0x30C7: // KATAKANA LETTER DE
1967     case 0x30C9: // KATAKANA LETTER DO
1968     case 0x30D0: // KATAKANA LETTER BA
1969     case 0x30D3: // KATAKANA LETTER BI
1970     case 0x30D6: // KATAKANA LETTER BU
1971     case 0x30D9: // KATAKANA LETTER BE
1972     case 0x30DC: // KATAKANA LETTER BO
1973     case 0x30F4: // KATAKANA LETTER VU
1974     case 0x30F7: // KATAKANA LETTER VA
1975     case 0x30F8: // KATAKANA LETTER VI
1976     case 0x30F9: // KATAKANA LETTER VE
1977     case 0x30FA: // KATAKANA LETTER VO
1978         return VoicedSoundMark;
1979     case 0x3071: // HIRAGANA LETTER PA
1980     case 0x3074: // HIRAGANA LETTER PI
1981     case 0x3077: // HIRAGANA LETTER PU
1982     case 0x307A: // HIRAGANA LETTER PE
1983     case 0x307D: // HIRAGANA LETTER PO
1984     case 0x30D1: // KATAKANA LETTER PA
1985     case 0x30D4: // KATAKANA LETTER PI
1986     case 0x30D7: // KATAKANA LETTER PU
1987     case 0x30DA: // KATAKANA LETTER PE
1988     case 0x30DD: // KATAKANA LETTER PO
1989         return SemiVoicedSoundMark;
1990     }
1991     return NoVoicedSoundMark;
1992 }
1993 
1994 static inline bool isCombiningVoicedSoundMark(UChar character)
1995 {
1996     switch (character) {
1997     case 0x3099: // COMBINING KATAKANA-HIRAGANA VOICED SOUND MARK
1998     case 0x309A: // COMBINING KATAKANA-HIRAGANA SEMI-VOICED SOUND MARK
1999         return true;
2000     }
2001     return false;
2002 }
2003 
2004 static inline bool containsKanaLetters(const String&amp; pattern)
2005 {
2006     if (pattern.is8Bit())
2007         return false;
2008     const UChar* characters = pattern.characters16();
2009     unsigned length = pattern.length();
2010     for (unsigned i = 0; i &lt; length; ++i) {
2011         if (isKanaLetter(characters[i]))
2012             return true;
2013     }
2014     return false;
2015 }
2016 
2017 static void normalizeCharacters(const UChar* characters, unsigned length, Vector&lt;UChar&gt;&amp; buffer)
2018 {
2019     UErrorCode status = U_ZERO_ERROR;
2020     const UNormalizer2* normalizer = unorm2_getNFCInstance(&amp;status);
2021     ASSERT(U_SUCCESS(status));
2022 
2023     buffer.resize(length);
2024 
2025     auto normalizedLength = unorm2_normalize(normalizer, characters, length, buffer.data(), length, &amp;status);
2026     ASSERT(U_SUCCESS(status) || status == U_BUFFER_OVERFLOW_ERROR);
2027 
2028     buffer.resize(normalizedLength);
2029 
2030     if (U_SUCCESS(status))
2031         return;
2032 
2033     status = U_ZERO_ERROR;
2034     unorm2_normalize(normalizer, characters, length, buffer.data(), length, &amp;status);
2035     ASSERT(U_SUCCESS(status));
2036 }
2037 
2038 static bool isNonLatin1Separator(UChar32 character)
2039 {
2040     ASSERT_ARG(character, character &gt;= 256);
2041 
2042     return U_GET_GC_MASK(character) &amp; (U_GC_S_MASK | U_GC_P_MASK | U_GC_Z_MASK | U_GC_CF_MASK);
2043 }
2044 
2045 static inline bool isSeparator(UChar32 character)
2046 {
2047     static const bool latin1SeparatorTable[256] = {
2048         0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
2049         0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
2050         1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // space ! &quot; # $ % &amp; &#39; ( ) * + , - . /
2051         0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, //                         : ; &lt; = &gt; ?
2052         1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, //   @
2053         0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, //                         [ \ ] ^ _
2054         1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, //   `
2055         0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, //                           { | } ~
2056         0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
2057         0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
2058         0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1,
2059         1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1,
2060         0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
2061         0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0,
2062         0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
2063         0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0
2064     };
2065 
2066     if (character &lt; 256)
2067         return latin1SeparatorTable[character];
2068 
2069     return isNonLatin1Separator(character);
2070 }
2071 
2072 inline SearchBuffer::SearchBuffer(const String&amp; target, FindOptions options)
2073     : m_target(foldQuoteMarks(target))
2074     , m_targetCharacters(StringView(m_target).upconvertedCharacters())
2075     , m_options(options)
2076     , m_prefixLength(0)
2077     , m_atBreak(true)
2078     , m_needsMoreContext(options.contains(AtWordStarts))
2079     , m_targetRequiresKanaWorkaround(containsKanaLetters(m_target))
2080 {
2081     ASSERT(!m_target.isEmpty());
2082 
2083     size_t targetLength = m_target.length();
2084     m_buffer.reserveInitialCapacity(std::max(targetLength * 8, minimumSearchBufferSize));
2085     m_overlap = m_buffer.capacity() / 4;
2086 
2087     if (m_options.contains(AtWordStarts) &amp;&amp; targetLength) {
2088         UChar32 targetFirstCharacter;
2089         U16_GET(m_target, 0, 0u, targetLength, targetFirstCharacter);
2090         // Characters in the separator category never really occur at the beginning of a word,
2091         // so if the target begins with such a character, we just ignore the AtWordStart option.
2092         if (isSeparator(targetFirstCharacter)) {
2093             m_options.remove(AtWordStarts);
2094             m_needsMoreContext = false;
2095         }
2096     }
2097 
2098     // Grab the single global searcher.
2099     // If we ever have a reason to do more than once search buffer at once, we&#39;ll have
2100     // to move to multiple searchers.
2101     lockSearcher();
2102 
2103     UStringSearch* searcher = WebCore::searcher();
2104     UCollator* collator = usearch_getCollator(searcher);
2105 
2106     UCollationStrength strength;
2107     USearchAttributeValue comparator;
2108     if (m_options.contains(CaseInsensitive)) {
2109         // Without loss of generality, have &#39;e&#39; match {&#39;e&#39;, &#39;E&#39;, &#39;é&#39;, &#39;É&#39;} and &#39;é&#39; match {&#39;é&#39;, &#39;É&#39;}.
2110         strength = UCOL_SECONDARY;
2111         comparator = USEARCH_PATTERN_BASE_WEIGHT_IS_WILDCARD;
2112     } else {
2113         // Without loss of generality, have &#39;e&#39; match {&#39;e&#39;} and &#39;é&#39; match {&#39;é&#39;}.
2114         strength = UCOL_TERTIARY;
2115         comparator = USEARCH_STANDARD_ELEMENT_COMPARISON;
2116     }
2117     if (ucol_getStrength(collator) != strength) {
2118         ucol_setStrength(collator, strength);
2119         usearch_reset(searcher);
2120     }
2121 
2122     UErrorCode status = U_ZERO_ERROR;
2123     usearch_setAttribute(searcher, USEARCH_ELEMENT_COMPARISON, comparator, &amp;status);
2124     ASSERT(status == U_ZERO_ERROR);
2125 
2126     usearch_setPattern(searcher, m_targetCharacters, targetLength, &amp;status);
2127     ASSERT(status == U_ZERO_ERROR);
2128 
2129     // The kana workaround requires a normalized copy of the target string.
2130     if (m_targetRequiresKanaWorkaround)
2131         normalizeCharacters(m_targetCharacters, targetLength, m_normalizedTarget);
2132 }
2133 
2134 inline SearchBuffer::~SearchBuffer()
2135 {
2136     // Leave the static object pointing to a valid string.
2137     UErrorCode status = U_ZERO_ERROR;
2138     usearch_setPattern(WebCore::searcher(), &amp;newlineCharacter, 1, &amp;status);
2139     ASSERT(status == U_ZERO_ERROR);
2140     usearch_setText(WebCore::searcher(), &amp;newlineCharacter, 1, &amp;status);
2141     ASSERT(status == U_ZERO_ERROR);
2142 
2143     unlockSearcher();
2144 }
2145 
2146 inline size_t SearchBuffer::append(StringView text)
2147 {
2148     ASSERT(text.length());
2149 
2150     if (m_atBreak) {
2151         m_buffer.shrink(0);
2152         m_prefixLength = 0;
2153         m_atBreak = false;
2154     } else if (m_buffer.size() == m_buffer.capacity()) {
2155         memcpy(m_buffer.data(), m_buffer.data() + m_buffer.size() - m_overlap, m_overlap * sizeof(UChar));
2156         m_prefixLength -= std::min(m_prefixLength, m_buffer.size() - m_overlap);
2157         m_buffer.shrink(m_overlap);
2158     }
2159 
2160     size_t oldLength = m_buffer.size();
2161     size_t usableLength = std::min&lt;size_t&gt;(m_buffer.capacity() - oldLength, text.length());
2162     ASSERT(usableLength);
2163     m_buffer.grow(oldLength + usableLength);
2164     for (unsigned i = 0; i &lt; usableLength; ++i)
2165         m_buffer[oldLength + i] = foldQuoteMark(text[i]);
2166     return usableLength;
2167 }
2168 
2169 inline bool SearchBuffer::needsMoreContext() const
2170 {
2171     return m_needsMoreContext;
2172 }
2173 
2174 inline void SearchBuffer::prependContext(StringView text)
2175 {
2176     ASSERT(m_needsMoreContext);
2177     ASSERT(m_prefixLength == m_buffer.size());
2178 
2179     if (!text.length())
2180         return;
2181 
2182     m_atBreak = false;
2183 
2184     size_t wordBoundaryContextStart = text.length();
2185     if (wordBoundaryContextStart) {
2186         U16_BACK_1(text, 0, wordBoundaryContextStart);
2187         wordBoundaryContextStart = startOfLastWordBoundaryContext(text.substring(0, wordBoundaryContextStart));
2188     }
2189 
2190     size_t usableLength = std::min(m_buffer.capacity() - m_prefixLength, text.length() - wordBoundaryContextStart);
2191     WTF::append(m_buffer, text.substring(text.length() - usableLength, usableLength));
2192     m_prefixLength += usableLength;
2193 
2194     if (wordBoundaryContextStart || m_prefixLength == m_buffer.capacity())
2195         m_needsMoreContext = false;
2196 }
2197 
2198 inline bool SearchBuffer::atBreak() const
2199 {
2200     return m_atBreak;
2201 }
2202 
2203 inline void SearchBuffer::reachedBreak()
2204 {
2205     m_atBreak = true;
2206 }
2207 
2208 inline bool SearchBuffer::isBadMatch(const UChar* match, size_t matchLength) const
2209 {
2210     // This function implements the kana workaround. If usearch treats
2211     // it as a match, but we do not want to, then it&#39;s a &quot;bad match&quot;.
2212     if (!m_targetRequiresKanaWorkaround)
2213         return false;
2214 
2215     // Normalize into a match buffer. We reuse a single buffer rather than
2216     // creating a new one each time.
2217     normalizeCharacters(match, matchLength, m_normalizedMatch);
2218 
2219     const UChar* a = m_normalizedTarget.begin();
2220     const UChar* aEnd = m_normalizedTarget.end();
2221 
2222     const UChar* b = m_normalizedMatch.begin();
2223     const UChar* bEnd = m_normalizedMatch.end();
2224 
2225     while (true) {
2226         // Skip runs of non-kana-letter characters. This is necessary so we can
2227         // correctly handle strings where the target and match have different-length
2228         // runs of characters that match, while still double checking the correctness
2229         // of matches of kana letters with other kana letters.
2230         while (a != aEnd &amp;&amp; !isKanaLetter(*a))
2231             ++a;
2232         while (b != bEnd &amp;&amp; !isKanaLetter(*b))
2233             ++b;
2234 
2235         // If we reached the end of either the target or the match, we should have
2236         // reached the end of both; both should have the same number of kana letters.
2237         if (a == aEnd || b == bEnd) {
2238             ASSERT(a == aEnd);
2239             ASSERT(b == bEnd);
2240             return false;
2241         }
2242 
2243         // Check for differences in the kana letter character itself.
2244         if (isSmallKanaLetter(*a) != isSmallKanaLetter(*b))
2245             return true;
2246         if (composedVoicedSoundMark(*a) != composedVoicedSoundMark(*b))
2247             return true;
2248         ++a;
2249         ++b;
2250 
2251         // Check for differences in combining voiced sound marks found after the letter.
2252         while (1) {
2253             if (!(a != aEnd &amp;&amp; isCombiningVoicedSoundMark(*a))) {
2254                 if (b != bEnd &amp;&amp; isCombiningVoicedSoundMark(*b))
2255                     return true;
2256                 break;
2257             }
2258             if (!(b != bEnd &amp;&amp; isCombiningVoicedSoundMark(*b)))
2259                 return true;
2260             if (*a != *b)
2261                 return true;
2262             ++a;
2263             ++b;
2264         }
2265     }
2266 }
2267 
2268 inline bool SearchBuffer::isWordEndMatch(size_t start, size_t length) const
2269 {
2270     ASSERT(length);
2271     ASSERT(m_options.contains(AtWordEnds));
2272 
2273     int endWord;
2274     // Start searching at the end of matched search, so that multiple word matches succeed.
2275     findEndWordBoundary(StringView(m_buffer.data(), m_buffer.size()), start + length - 1, &amp;endWord);
2276     return static_cast&lt;size_t&gt;(endWord) == (start + length);
2277 }
2278 
2279 inline bool SearchBuffer::isWordStartMatch(size_t start, size_t length) const
2280 {
2281     ASSERT(m_options.contains(AtWordStarts));
2282 
2283     if (!start)
2284         return true;
2285 
2286     int size = m_buffer.size();
2287     int offset = start;
2288     UChar32 firstCharacter;
2289     U16_GET(m_buffer.data(), 0, offset, size, firstCharacter);
2290 
2291     if (m_options.contains(TreatMedialCapitalAsWordStart)) {
2292         UChar32 previousCharacter;
2293         U16_PREV(m_buffer.data(), 0, offset, previousCharacter);
2294 
2295         if (isSeparator(firstCharacter)) {
2296             // The start of a separator run is a word start (&quot;.org&quot; in &quot;webkit.org&quot;).
2297             if (!isSeparator(previousCharacter))
2298                 return true;
2299         } else if (isASCIIUpper(firstCharacter)) {
2300             // The start of an uppercase run is a word start (&quot;Kit&quot; in &quot;WebKit&quot;).
2301             if (!isASCIIUpper(previousCharacter))
2302                 return true;
2303             // The last character of an uppercase run followed by a non-separator, non-digit
2304             // is a word start (&quot;Request&quot; in &quot;XMLHTTPRequest&quot;).
2305             offset = start;
2306             U16_FWD_1(m_buffer.data(), offset, size);
2307             UChar32 nextCharacter = 0;
2308             if (offset &lt; size)
2309                 U16_GET(m_buffer.data(), 0, offset, size, nextCharacter);
2310             if (!isASCIIUpper(nextCharacter) &amp;&amp; !isASCIIDigit(nextCharacter) &amp;&amp; !isSeparator(nextCharacter))
2311                 return true;
2312         } else if (isASCIIDigit(firstCharacter)) {
2313             // The start of a digit run is a word start (&quot;2&quot; in &quot;WebKit2&quot;).
2314             if (!isASCIIDigit(previousCharacter))
2315                 return true;
2316         } else if (isSeparator(previousCharacter) || isASCIIDigit(previousCharacter)) {
2317             // The start of a non-separator, non-uppercase, non-digit run is a word start,
2318             // except after an uppercase. (&quot;org&quot; in &quot;webkit.org&quot;, but not &quot;ore&quot; in &quot;WebCore&quot;).
2319             return true;
2320         }
2321     }
2322 
2323     // Chinese and Japanese lack word boundary marks, and there is no clear agreement on what constitutes
2324     // a word, so treat the position before any CJK character as a word start.
2325     if (FontCascade::isCJKIdeographOrSymbol(firstCharacter))
2326         return true;
2327 
2328     size_t wordBreakSearchStart = start + length;
2329     while (wordBreakSearchStart &gt; start)
2330         wordBreakSearchStart = findNextWordFromIndex(StringView(m_buffer.data(), m_buffer.size()), wordBreakSearchStart, false /* backwards */);
2331     return wordBreakSearchStart == start;
2332 }
2333 
2334 inline size_t SearchBuffer::search(size_t&amp; start)
2335 {
2336     size_t size = m_buffer.size();
2337     if (m_atBreak) {
2338         if (!size)
2339             return 0;
2340     } else {
2341         if (size != m_buffer.capacity())
2342             return 0;
2343     }
2344 
2345     UStringSearch* searcher = WebCore::searcher();
2346 
2347     UErrorCode status = U_ZERO_ERROR;
2348     usearch_setText(searcher, m_buffer.data(), size, &amp;status);
2349     ASSERT(status == U_ZERO_ERROR);
2350 
2351     usearch_setOffset(searcher, m_prefixLength, &amp;status);
2352     ASSERT(status == U_ZERO_ERROR);
2353 
2354     int matchStart = usearch_next(searcher, &amp;status);
2355     ASSERT(status == U_ZERO_ERROR);
2356 
2357 nextMatch:
2358     if (!(matchStart &gt;= 0 &amp;&amp; static_cast&lt;size_t&gt;(matchStart) &lt; size)) {
2359         ASSERT(matchStart == USEARCH_DONE);
2360         return 0;
2361     }
2362 
2363     // Matches that start in the overlap area are only tentative.
2364     // The same match may appear later, matching more characters,
2365     // possibly including a combining character that&#39;s not yet in the buffer.
2366     if (!m_atBreak &amp;&amp; static_cast&lt;size_t&gt;(matchStart) &gt;= size - m_overlap) {
2367         size_t overlap = m_overlap;
2368         if (m_options.contains(AtWordStarts)) {
2369             // Ensure that there is sufficient context before matchStart the next time around for
2370             // determining if it is at a word boundary.
2371             unsigned wordBoundaryContextStart = matchStart;
2372             U16_BACK_1(m_buffer.data(), 0, wordBoundaryContextStart);
2373             wordBoundaryContextStart = startOfLastWordBoundaryContext(StringView(m_buffer.data(), wordBoundaryContextStart));
2374             overlap = std::min(size - 1, std::max(overlap, size - wordBoundaryContextStart));
2375         }
2376         memcpy(m_buffer.data(), m_buffer.data() + size - overlap, overlap * sizeof(UChar));
2377         m_prefixLength -= std::min(m_prefixLength, size - overlap);
2378         m_buffer.shrink(overlap);
2379         return 0;
2380     }
2381 
2382     size_t matchedLength = usearch_getMatchedLength(searcher);
2383     ASSERT_WITH_SECURITY_IMPLICATION(matchStart + matchedLength &lt;= size);
2384 
2385     // If this match is &quot;bad&quot;, move on to the next match.
2386     if (isBadMatch(m_buffer.data() + matchStart, matchedLength)
2387         || (m_options.contains(AtWordStarts) &amp;&amp; !isWordStartMatch(matchStart, matchedLength))
2388         || (m_options.contains(AtWordEnds) &amp;&amp; !isWordEndMatch(matchStart, matchedLength))) {
2389         matchStart = usearch_next(searcher, &amp;status);
2390         ASSERT(status == U_ZERO_ERROR);
2391         goto nextMatch;
2392     }
2393 
2394     size_t newSize = size - (matchStart + 1);
2395     memmove(m_buffer.data(), m_buffer.data() + matchStart + 1, newSize * sizeof(UChar));
2396     m_prefixLength -= std::min&lt;size_t&gt;(m_prefixLength, matchStart + 1);
2397     m_buffer.shrink(newSize);
2398 
2399     start = size - matchStart;
2400     return matchedLength;
2401 }
2402 
2403 #else
2404 
2405 inline SearchBuffer::SearchBuffer(const String&amp; target, FindOptions options)
2406     : m_target(options &amp; CaseInsensitive ? target.foldCase() : target)
2407     , m_options(options)
2408     , m_buffer(m_target.length())
2409     , m_isCharacterStartBuffer(m_target.length())
2410     , m_isBufferFull(false)
2411     , m_cursor(0)
2412 {
2413     ASSERT(!m_target.isEmpty());
2414     m_target.replace(noBreakSpace, &#39; &#39;);
2415     foldQuoteMarks(m_target);
2416 }
2417 
2418 inline SearchBuffer::~SearchBuffer() = default;
2419 
2420 inline void SearchBuffer::reachedBreak()
2421 {
2422     m_cursor = 0;
2423     m_isBufferFull = false;
2424 }
2425 
2426 inline bool SearchBuffer::atBreak() const
2427 {
2428     return !m_cursor &amp;&amp; !m_isBufferFull;
2429 }
2430 
2431 inline void SearchBuffer::append(UChar c, bool isStart)
2432 {
2433     m_buffer[m_cursor] = c == noBreakSpace ? &#39; &#39; : foldQuoteMark(c);
2434     m_isCharacterStartBuffer[m_cursor] = isStart;
2435     if (++m_cursor == m_target.length()) {
2436         m_cursor = 0;
2437         m_isBufferFull = true;
2438     }
2439 }
2440 
2441 inline size_t SearchBuffer::append(const UChar* characters, size_t length)
2442 {
2443     ASSERT(length);
2444     if (!(m_options &amp; CaseInsensitive)) {
2445         append(characters[0], true);
2446         return 1;
2447     }
2448     const int maxFoldedCharacters = 16; // sensible maximum is 3, this should be more than enough
2449     UChar foldedCharacters[maxFoldedCharacters];
2450     UErrorCode status = U_ZERO_ERROR;
2451     int numFoldedCharacters = u_strFoldCase(foldedCharacters, maxFoldedCharacters, characters, 1, U_FOLD_CASE_DEFAULT, &amp;status);
2452     ASSERT(U_SUCCESS(status));
2453     ASSERT(numFoldedCharacters);
2454     ASSERT(numFoldedCharacters &lt;= maxFoldedCharacters);
2455     if (U_SUCCESS(status) &amp;&amp; numFoldedCharacters) {
2456         numFoldedCharacters = std::min(numFoldedCharacters, maxFoldedCharacters);
2457         append(foldedCharacters[0], true);
2458         for (int i = 1; i &lt; numFoldedCharacters; ++i)
2459             append(foldedCharacters[i], false);
2460     }
2461     return 1;
2462 }
2463 
2464 inline bool SearchBuffer::needsMoreContext() const
2465 {
2466     return false;
2467 }
2468 
2469 void SearchBuffer::prependContext(const UChar*, size_t)
2470 {
2471     ASSERT_NOT_REACHED();
2472 }
2473 
2474 inline size_t SearchBuffer::search(size_t&amp; start)
2475 {
2476     if (!m_isBufferFull)
2477         return 0;
2478     if (!m_isCharacterStartBuffer[m_cursor])
2479         return 0;
2480 
2481     size_t tailSpace = m_target.length() - m_cursor;
2482     if (memcmp(&amp;m_buffer[m_cursor], m_target.characters(), tailSpace * sizeof(UChar)) != 0)
2483         return 0;
2484     if (memcmp(&amp;m_buffer[0], m_target.characters() + tailSpace, m_cursor * sizeof(UChar)) != 0)
2485         return 0;
2486 
2487     start = length();
2488 
2489     // Now that we&#39;ve found a match once, we don&#39;t want to find it again, because those
2490     // are the SearchBuffer semantics, allowing for a buffer where you append more than one
2491     // character at a time. To do this we take advantage of m_isCharacterStartBuffer, but if
2492     // we want to get rid of that in the future we could track this with a separate boolean
2493     // or even move the characters to the start of the buffer and set m_isBufferFull to false.
2494     m_isCharacterStartBuffer[m_cursor] = false;
2495 
2496     return start;
2497 }
2498 
2499 // Returns the number of characters that were appended to the buffer (what we are searching in).
2500 // That&#39;s not necessarily the same length as the passed-in target string, because case folding
2501 // can make two strings match even though they&#39;re not the same length.
2502 size_t SearchBuffer::length() const
2503 {
2504     size_t bufferSize = m_target.length();
2505     size_t length = 0;
2506     for (size_t i = 0; i &lt; bufferSize; ++i)
2507         length += m_isCharacterStartBuffer[i];
2508     return length;
2509 }
2510 
2511 #endif
2512 
2513 // --------
2514 
2515 int TextIterator::rangeLength(const Range* range, bool forSelectionPreservation)
2516 {
2517     unsigned length = 0;
2518     for (TextIterator it(range, forSelectionPreservation ? TextIteratorEmitsCharactersBetweenAllVisiblePositions : TextIteratorDefaultBehavior); !it.atEnd(); it.advance())
2519         length += it.text().length();
2520     return length;
2521 }
2522 
2523 Ref&lt;Range&gt; TextIterator::subrange(Range&amp; entireRange, int characterOffset, int characterCount)
2524 {
2525     CharacterIterator entireRangeIterator(entireRange);
2526     return characterSubrange(entireRange.ownerDocument(), entireRangeIterator, characterOffset, characterCount);
2527 }
2528 
2529 static inline bool isInsideReplacedElement(TextIterator&amp; iterator)
2530 {
2531     ASSERT(!iterator.atEnd());
2532     ASSERT(iterator.text().length() == 1);
2533     Node* node = iterator.node();
2534     return node &amp;&amp; isRendererReplacedElement(node-&gt;renderer());
2535 }
2536 
2537 RefPtr&lt;Range&gt; TextIterator::rangeFromLocationAndLength(ContainerNode* scope, int rangeLocation, int rangeLength, bool forSelectionPreservation)
2538 {
2539     Ref&lt;Range&gt; resultRange = scope-&gt;document().createRange();
2540 
2541     int docTextPosition = 0;
2542     int rangeEnd = rangeLocation + rangeLength;
2543     bool startRangeFound = false;
2544 
2545     Ref&lt;Range&gt; textRunRange = rangeOfContents(*scope);
2546 
2547     TextIterator it(textRunRange.ptr(), forSelectionPreservation ? TextIteratorEmitsCharactersBetweenAllVisiblePositions : TextIteratorDefaultBehavior);
2548 
2549     // FIXME: the atEnd() check shouldn&#39;t be necessary, workaround for &lt;http://bugs.webkit.org/show_bug.cgi?id=6289&gt;.
2550     if (!rangeLocation &amp;&amp; !rangeLength &amp;&amp; it.atEnd()) {
2551         resultRange-&gt;setStart(textRunRange-&gt;startContainer(), 0);
2552         resultRange-&gt;setEnd(textRunRange-&gt;startContainer(), 0);
2553         return WTFMove(resultRange);
2554     }
2555 
2556     for (; !it.atEnd(); it.advance()) {
2557         int length = it.text().length();
2558         textRunRange = it.range();
2559 
2560         bool foundStart = rangeLocation &gt;= docTextPosition &amp;&amp; rangeLocation &lt;= docTextPosition + length;
2561         bool foundEnd = rangeEnd &gt;= docTextPosition &amp;&amp; rangeEnd &lt;= docTextPosition + length;
2562 
2563         if (foundEnd) {
2564             // FIXME: This is a workaround for the fact that the end of a run is often at the wrong
2565             // position for emitted &#39;\n&#39;s or if the renderer of the current node is a replaced element.
2566             if (length == 1 &amp;&amp; (it.text()[0] == &#39;\n&#39; || isInsideReplacedElement(it))) {
2567                 it.advance();
2568                 if (!it.atEnd()) {
2569                     Ref&lt;Range&gt; range = it.range();
2570                     textRunRange-&gt;setEnd(range-&gt;startContainer(), range-&gt;startOffset());
2571                 } else {
2572                     Position runStart = textRunRange-&gt;startPosition();
2573                     Position runEnd = VisiblePosition(runStart).next().deepEquivalent();
2574                     if (runEnd.isNotNull())
2575                         textRunRange-&gt;setEnd(*runEnd.containerNode(), runEnd.computeOffsetInContainerNode());
2576                 }
2577             }
2578         }
2579 
2580         if (foundStart) {
2581             startRangeFound = true;
2582             if (textRunRange-&gt;startContainer().isTextNode()) {
2583                 int offset = rangeLocation - docTextPosition;
2584                 resultRange-&gt;setStart(textRunRange-&gt;startContainer(), offset + textRunRange-&gt;startOffset());
2585             } else {
2586                 if (rangeLocation == docTextPosition)
2587                     resultRange-&gt;setStart(textRunRange-&gt;startContainer(), textRunRange-&gt;startOffset());
2588                 else
2589                     resultRange-&gt;setStart(textRunRange-&gt;endContainer(), textRunRange-&gt;endOffset());
2590             }
2591         }
2592 
2593         if (foundEnd) {
2594             if (textRunRange-&gt;startContainer().isTextNode()) {
2595                 int offset = rangeEnd - docTextPosition;
2596                 resultRange-&gt;setEnd(textRunRange-&gt;startContainer(), offset + textRunRange-&gt;startOffset());
2597             } else {
2598                 if (rangeEnd == docTextPosition)
2599                     resultRange-&gt;setEnd(textRunRange-&gt;startContainer(), textRunRange-&gt;startOffset());
2600                 else
2601                     resultRange-&gt;setEnd(textRunRange-&gt;endContainer(), textRunRange-&gt;endOffset());
2602             }
2603             docTextPosition += length;
2604             break;
2605         }
2606 
2607         docTextPosition += length;
2608     }
2609 
2610     if (!startRangeFound)
2611         return nullptr;
2612 
2613     if (rangeLength &amp;&amp; rangeEnd &gt; docTextPosition) // rangeEnd is out of bounds
2614         resultRange-&gt;setEnd(textRunRange-&gt;endContainer(), textRunRange-&gt;endOffset());
2615 
2616     return WTFMove(resultRange);
2617 }
2618 
2619 bool TextIterator::getLocationAndLengthFromRange(Node* scope, const Range* range, size_t&amp; location, size_t&amp; length)
2620 {
2621     location = notFound;
2622     length = 0;
2623 
2624     // The critical assumption is that this only gets called with ranges that
2625     // concentrate on a given area containing the selection root. This is done
2626     // because of text fields and textareas. The DOM for those is not
2627     // directly in the document DOM, so ensure that the range does not cross a
2628     // boundary of one of those.
2629     if (&amp;range-&gt;startContainer() != scope &amp;&amp; !range-&gt;startContainer().isDescendantOf(scope))
2630         return false;
2631     if (&amp;range-&gt;endContainer() != scope &amp;&amp; !range-&gt;endContainer().isDescendantOf(scope))
2632         return false;
2633 
2634     Ref&lt;Range&gt; testRange = Range::create(scope-&gt;document(), scope, 0, &amp;range-&gt;startContainer(), range-&gt;startOffset());
2635     ASSERT(&amp;testRange-&gt;startContainer() == scope);
2636     location = TextIterator::rangeLength(testRange.ptr());
2637 
2638     testRange-&gt;setEnd(range-&gt;endContainer(), range-&gt;endOffset());
2639     ASSERT(&amp;testRange-&gt;startContainer() == scope);
2640     length = TextIterator::rangeLength(testRange.ptr()) - location;
2641     return true;
2642 }
2643 
2644 // --------
2645 
2646 bool hasAnyPlainText(const Range&amp; range, TextIteratorBehavior behavior)
2647 {
2648     for (TextIterator iterator { &amp;range, behavior }; !iterator.atEnd(); iterator.advance()) {
2649         if (!iterator.text().isEmpty())
2650             return true;
2651     }
2652     return false;
2653 }
2654 
2655 String plainText(Position start, Position end, TextIteratorBehavior defaultBehavior, bool isDisplayString)
2656 {
2657     // The initial buffer size can be critical for performance: https://bugs.webkit.org/show_bug.cgi?id=81192
2658     static const unsigned initialCapacity = 1 &lt;&lt; 15;
2659 
2660     if (!start.document())
2661         return { };
2662     auto document = makeRef(*start.document());
2663 
2664     unsigned bufferLength = 0;
2665     StringBuilder builder;
2666     builder.reserveCapacity(initialCapacity);
2667     TextIteratorBehavior behavior = defaultBehavior;
2668     if (!isDisplayString)
2669         behavior = static_cast&lt;TextIteratorBehavior&gt;(behavior | TextIteratorEmitsTextsWithoutTranscoding);
2670 
2671     for (TextIterator it(start, end, behavior); !it.atEnd(); it.advance()) {
2672         it.appendTextToStringBuilder(builder);
2673         bufferLength += it.text().length();
2674     }
2675 
2676     if (!bufferLength)
2677         return emptyString();
2678 
2679     String result = builder.toString();
2680 
2681     if (isDisplayString)
2682         document-&gt;displayStringModifiedByEncoding(result);
2683 
2684     return result;
2685 }
2686 
2687 String plainText(const Range* range, TextIteratorBehavior defaultBehavior, bool isDisplayString)
2688 {
2689     if (!range)
2690         return emptyString();
2691     return plainText(range-&gt;startPosition(), range-&gt;endPosition(), defaultBehavior, isDisplayString);
2692 }
2693 
2694 String plainTextReplacingNoBreakSpace(const Range* range, TextIteratorBehavior defaultBehavior, bool isDisplayString)
2695 {
2696     return plainText(range, defaultBehavior, isDisplayString).replace(noBreakSpace, &#39; &#39;);
2697 }
2698 
2699 static Ref&lt;Range&gt; collapsedToBoundary(const Range&amp; range, bool forward)
2700 {
2701     Ref&lt;Range&gt; result = range.cloneRange();
2702     result-&gt;collapse(!forward);
2703     return result;
2704 }
2705 
2706 static TextIteratorBehavior findIteratorOptions(FindOptions options)
2707 {
2708     TextIteratorBehavior iteratorOptions = TextIteratorEntersTextControls | TextIteratorClipsToFrameAncestors;
2709     if (!options.contains(DoNotTraverseFlatTree))
2710         iteratorOptions |= TextIteratorTraversesFlatTree;
2711     return iteratorOptions;
2712 }
2713 
2714 static void findPlainTextMatches(const Range&amp; range, const String&amp; target, FindOptions options, const WTF::Function&lt;bool(size_t, size_t)&gt;&amp; match)
2715 {
2716     SearchBuffer buffer(target, options);
2717     if (buffer.needsMoreContext()) {
2718         Ref&lt;Range&gt; beforeStartRange = range.ownerDocument().createRange();
2719         beforeStartRange-&gt;setEnd(range.startContainer(), range.startOffset());
2720         for (SimplifiedBackwardsTextIterator backwardsIterator(beforeStartRange.get()); !backwardsIterator.atEnd(); backwardsIterator.advance()) {
2721             buffer.prependContext(backwardsIterator.text());
2722             if (!buffer.needsMoreContext())
2723                 break;
2724         }
2725     }
2726 
2727     CharacterIterator findIterator(range, findIteratorOptions(options));
2728     while (!findIterator.atEnd()) {
2729         findIterator.advance(buffer.append(findIterator.text()));
2730         while (1) {
2731             size_t matchStartOffset;
2732             size_t newMatchLength = buffer.search(matchStartOffset);
2733             if (!newMatchLength) {
2734                 if (findIterator.atBreak() &amp;&amp; !buffer.atBreak()) {
2735                     buffer.reachedBreak();
2736                     continue;
2737                 }
2738                 break;
2739             }
2740             size_t lastCharacterInBufferOffset = findIterator.characterOffset();
2741             ASSERT(lastCharacterInBufferOffset &gt;= matchStartOffset);
2742             if (match(lastCharacterInBufferOffset - matchStartOffset, newMatchLength))
2743                 return;
2744         }
2745     }
2746 }
2747 
2748 static Ref&lt;Range&gt; rangeForMatch(const Range&amp; range, FindOptions options, size_t matchStart, size_t matchLength, bool searchForward)
2749 {
2750     if (!matchLength)
2751         return collapsedToBoundary(range, searchForward);
2752     CharacterIterator rangeComputeIterator(range, findIteratorOptions(options));
2753     return characterSubrange(range.ownerDocument(), rangeComputeIterator, matchStart, matchLength);
2754 }
2755 
2756 Ref&lt;Range&gt; findClosestPlainText(const Range&amp; range, const String&amp; target, FindOptions options, unsigned targetOffset)
2757 {
2758     size_t matchStart = 0;
2759     size_t matchLength = 0;
2760     size_t distance = std::numeric_limits&lt;size_t&gt;::max();
2761     auto match = [targetOffset, &amp;distance, &amp;matchStart, &amp;matchLength] (size_t start, size_t length) {
2762         size_t newDistance = std::min(abs(static_cast&lt;signed&gt;(start - targetOffset)), abs(static_cast&lt;signed&gt;(start + length - targetOffset)));
2763         if (newDistance &lt; distance) {
2764             matchStart = start;
2765             matchLength = length;
2766             distance = newDistance;
2767         }
2768         return false;
2769     };
2770 
2771     findPlainTextMatches(range, target, options, WTFMove(match));
2772     return rangeForMatch(range, options, matchStart, matchLength, !options.contains(Backwards));
2773 }
2774 
2775 Ref&lt;Range&gt; findPlainText(const Range&amp; range, const String&amp; target, FindOptions options)
2776 {
2777     bool searchForward = !options.contains(Backwards);
2778     size_t matchStart = 0;
2779     size_t matchLength = 0;
2780     auto match = [searchForward, &amp;matchStart, &amp;matchLength] (size_t start, size_t length) {
2781         matchStart = start;
2782         matchLength = length;
2783         // Look for the last match when searching backwards instead.
2784         return searchForward;
2785     };
2786 
2787     findPlainTextMatches(range, target, options, WTFMove(match));
2788     return rangeForMatch(range, options, matchStart, matchLength, searchForward);
2789 }
2790 
2791 bool findPlainText(const String&amp; document, const String&amp; target, FindOptions options)
2792 {
2793     SearchBuffer buffer { target, options };
2794     StringView remainingText { document };
2795     while (!remainingText.isEmpty()) {
2796         size_t charactersAppended = buffer.append(document);
2797         remainingText = remainingText.substring(charactersAppended);
2798         if (remainingText.isEmpty())
2799             buffer.reachedBreak();
2800         size_t matchStartOffset;
2801         if (buffer.search(matchStartOffset))
2802             return true;
2803     }
2804     return false;
2805 }
2806 
2807 }
    </pre>
  </body>
</html>