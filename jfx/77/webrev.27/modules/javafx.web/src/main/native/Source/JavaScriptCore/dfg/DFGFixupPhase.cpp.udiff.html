<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGFixupPhase.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="DFGDriver.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DFGFlowIndexing.h.udiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGFixupPhase.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -1,7 +1,7 @@</span>
  /*
<span class="udiff-line-modified-removed">-  * Copyright (C) 2012-2018 Apple Inc. All rights reserved.</span>
<span class="udiff-line-modified-added">+  * Copyright (C) 2012-2019 Apple Inc. All rights reserved.</span>
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions
   * are met:
   * 1. Redistributions of source code must retain the above copyright
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -73,43 +73,62 @@</span>
  
          return true;
      }
  
  private:
<span class="udiff-line-removed">-     void fixupArithDiv(Node* node, Edge&amp; leftChild, Edge&amp; rightChild)</span>
<span class="udiff-line-removed">-     {</span>
<span class="udiff-line-removed">-         if (m_graph.binaryArithShouldSpeculateInt32(node, FixupPass)) {</span>
<span class="udiff-line-removed">-             if (optimizeForX86() || optimizeForARM64() || optimizeForARMv7IDIVSupported()) {</span>
<span class="udiff-line-removed">-                 fixIntOrBooleanEdge(leftChild);</span>
<span class="udiff-line-removed">-                 fixIntOrBooleanEdge(rightChild);</span>
<span class="udiff-line-removed">-                 if (bytecodeCanTruncateInteger(node-&gt;arithNodeFlags()))</span>
<span class="udiff-line-removed">-                     node-&gt;setArithMode(Arith::Unchecked);</span>
<span class="udiff-line-removed">-                 else if (bytecodeCanIgnoreNegativeZero(node-&gt;arithNodeFlags()))</span>
<span class="udiff-line-removed">-                     node-&gt;setArithMode(Arith::CheckOverflow);</span>
<span class="udiff-line-removed">-                 else</span>
<span class="udiff-line-removed">-                     node-&gt;setArithMode(Arith::CheckOverflowAndNegativeZero);</span>
<span class="udiff-line-removed">-                 return;</span>
<span class="udiff-line-removed">-             }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-             // This will cause conversion nodes to be inserted later.</span>
<span class="udiff-line-removed">-             fixDoubleOrBooleanEdge(leftChild);</span>
<span class="udiff-line-removed">-             fixDoubleOrBooleanEdge(rightChild);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-             // We don&#39;t need to do ref&#39;ing on the children because we&#39;re stealing them from</span>
<span class="udiff-line-removed">-             // the original division.</span>
<span class="udiff-line-removed">-             Node* newDivision = m_insertionSet.insertNode(m_indexInBlock, SpecBytecodeDouble, *node);</span>
<span class="udiff-line-removed">-             newDivision-&gt;setResult(NodeResultDouble);</span>
  
<span class="udiff-line-modified-removed">-             node-&gt;setOp(DoubleAsInt32);</span>
<span class="udiff-line-modified-removed">-             node-&gt;children.initialize(Edge(newDivision, DoubleRepUse), Edge(), Edge());</span>
<span class="udiff-line-modified-removed">-             if (bytecodeCanIgnoreNegativeZero(node-&gt;arithNodeFlags()))</span>
<span class="udiff-line-modified-added">+     void fixupArithDivInt32(Node* node, Edge&amp; leftChild, Edge&amp; rightChild)</span>
<span class="udiff-line-modified-added">+     {</span>
<span class="udiff-line-modified-added">+         if (optimizeForX86() || optimizeForARM64() || optimizeForARMv7IDIVSupported()) {</span>
<span class="udiff-line-added">+             fixIntOrBooleanEdge(leftChild);</span>
<span class="udiff-line-added">+             fixIntOrBooleanEdge(rightChild);</span>
<span class="udiff-line-added">+             if (bytecodeCanTruncateInteger(node-&gt;arithNodeFlags()))</span>
<span class="udiff-line-added">+                 node-&gt;setArithMode(Arith::Unchecked);</span>
<span class="udiff-line-added">+             else if (bytecodeCanIgnoreNegativeZero(node-&gt;arithNodeFlags()))</span>
                  node-&gt;setArithMode(Arith::CheckOverflow);
              else
                  node-&gt;setArithMode(Arith::CheckOverflowAndNegativeZero);
              return;
          }
  
<span class="udiff-line-added">+         // This will cause conversion nodes to be inserted later.</span>
<span class="udiff-line-added">+         fixDoubleOrBooleanEdge(leftChild);</span>
<span class="udiff-line-added">+         fixDoubleOrBooleanEdge(rightChild);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         // We don&#39;t need to do ref&#39;ing on the children because we&#39;re stealing them from</span>
<span class="udiff-line-added">+         // the original division.</span>
<span class="udiff-line-added">+         Node* newDivision = m_insertionSet.insertNode(m_indexInBlock, SpecBytecodeDouble, *node);</span>
<span class="udiff-line-added">+         newDivision-&gt;setResult(NodeResultDouble);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         node-&gt;setOp(DoubleAsInt32);</span>
<span class="udiff-line-added">+         node-&gt;children.initialize(Edge(newDivision, DoubleRepUse), Edge(), Edge());</span>
<span class="udiff-line-added">+         if (bytecodeCanIgnoreNegativeZero(node-&gt;arithNodeFlags()))</span>
<span class="udiff-line-added">+             node-&gt;setArithMode(Arith::CheckOverflow);</span>
<span class="udiff-line-added">+         else</span>
<span class="udiff-line-added">+             node-&gt;setArithMode(Arith::CheckOverflowAndNegativeZero);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     void fixupArithPow(Node* node)</span>
<span class="udiff-line-added">+     {</span>
<span class="udiff-line-added">+         if (node-&gt;child2()-&gt;shouldSpeculateInt32OrBooleanForArithmetic()) {</span>
<span class="udiff-line-added">+             fixDoubleOrBooleanEdge(node-&gt;child1());</span>
<span class="udiff-line-added">+             fixIntOrBooleanEdge(node-&gt;child2());</span>
<span class="udiff-line-added">+             return;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         fixDoubleOrBooleanEdge(node-&gt;child1());</span>
<span class="udiff-line-added">+         fixDoubleOrBooleanEdge(node-&gt;child2());</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     void fixupArithDiv(Node* node, Edge&amp; leftChild, Edge&amp; rightChild)</span>
<span class="udiff-line-added">+     {</span>
<span class="udiff-line-added">+         if (m_graph.binaryArithShouldSpeculateInt32(node, FixupPass)) {</span>
<span class="udiff-line-added">+             fixupArithDivInt32(node, leftChild, rightChild);</span>
<span class="udiff-line-added">+             return;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
          fixDoubleOrBooleanEdge(leftChild);
          fixDoubleOrBooleanEdge(rightChild);
          node-&gt;setResult(NodeResultDouble);
      }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -124,11 +143,11 @@</span>
                  node-&gt;setArithMode(Arith::CheckOverflow);
              else
                  node-&gt;setArithMode(Arith::CheckOverflowAndNegativeZero);
              return;
          }
<span class="udiff-line-modified-removed">-         if (m_graph.binaryArithShouldSpeculateAnyInt(node, FixupPass)) {</span>
<span class="udiff-line-modified-added">+         if (m_graph.binaryArithShouldSpeculateInt52(node, FixupPass)) {</span>
              fixEdge&lt;Int52RepUse&gt;(leftChild);
              fixEdge&lt;Int52RepUse&gt;(rightChild);
              if (bytecodeCanIgnoreNegativeZero(node-&gt;arithNodeFlags()) || leftChild.node() == rightChild.node())
                  node-&gt;setArithMode(Arith::CheckOverflow);
              else
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -194,36 +213,40 @@</span>
              node-&gt;setResult(NodeResultDouble);
  
              break;
          }
  
<span class="udiff-line-added">+         case ValueBitLShift:</span>
          case ValueBitXor:
          case ValueBitOr:
          case ValueBitAnd: {
              if (Node::shouldSpeculateBigInt(node-&gt;child1().node(), node-&gt;child2().node())) {
                  fixEdge&lt;BigIntUse&gt;(node-&gt;child1());
                  fixEdge&lt;BigIntUse&gt;(node-&gt;child2());
<span class="udiff-line-added">+                 node-&gt;clearFlags(NodeMustGenerate);</span>
                  break;
              }
  
              if (Node::shouldSpeculateUntypedForBitOps(node-&gt;child1().node(), node-&gt;child2().node())) {
                  fixEdge&lt;UntypedUse&gt;(node-&gt;child1());
                  fixEdge&lt;UntypedUse&gt;(node-&gt;child2());
                  break;
              }
  
<span class="udiff-line-removed">-             // In such case, we need to fallback to ArithBitOp</span>
              switch (op) {
              case ValueBitXor:
                  node-&gt;setOp(ArithBitXor);
                  break;
              case ValueBitOr:
                  node-&gt;setOp(ArithBitOr);
                  break;
              case ValueBitAnd:
                  node-&gt;setOp(ArithBitAnd);
                  break;
<span class="udiff-line-added">+             case ValueBitLShift:</span>
<span class="udiff-line-added">+                 node-&gt;setOp(ArithBitLShift);</span>
<span class="udiff-line-added">+                 break;</span>
              default:
                  DFG_CRASH(m_graph, node, &quot;Unexpected node during ValueBit operation fixup&quot;);
                  break;
              }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -232,31 +255,44 @@</span>
              fixIntConvertingEdge(node-&gt;child1());
              fixIntConvertingEdge(node-&gt;child2());
              break;
          }
  
<span class="udiff-line-modified-removed">-         case ArithBitNot: {</span>
<span class="udiff-line-modified-removed">-             if (node-&gt;child1().node()-&gt;shouldSpeculateUntypedForBitOps()) {</span>
<span class="udiff-line-modified-removed">-                 fixEdge&lt;UntypedUse&gt;(node-&gt;child1());</span>
<span class="udiff-line-modified-removed">-                 break;</span>
<span class="udiff-line-modified-added">+         case ValueBitNot: {</span>
<span class="udiff-line-modified-added">+             Edge&amp; operandEdge = node-&gt;child1();</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+             if (operandEdge.node()-&gt;shouldSpeculateBigInt()) {</span>
<span class="udiff-line-added">+                 node-&gt;clearFlags(NodeMustGenerate);</span>
<span class="udiff-line-added">+                 fixEdge&lt;BigIntUse&gt;(operandEdge);</span>
<span class="udiff-line-added">+             } else if (operandEdge.node()-&gt;shouldSpeculateUntypedForBitOps())</span>
<span class="udiff-line-added">+                 fixEdge&lt;UntypedUse&gt;(operandEdge);</span>
<span class="udiff-line-added">+             else {</span>
<span class="udiff-line-added">+                 node-&gt;setOp(ArithBitNot);</span>
<span class="udiff-line-added">+                 node-&gt;setResult(NodeResultInt32);</span>
<span class="udiff-line-added">+                 node-&gt;clearFlags(NodeMustGenerate);</span>
<span class="udiff-line-added">+                 fixIntConvertingEdge(operandEdge);</span>
              }
<span class="udiff-line-added">+             break;</span>
<span class="udiff-line-added">+         }</span>
  
<span class="udiff-line-modified-removed">-             fixIntConvertingEdge(node-&gt;child1());</span>
<span class="udiff-line-modified-removed">-             node-&gt;clearFlags(NodeMustGenerate);</span>
<span class="udiff-line-modified-added">+         case ArithBitNot: {</span>
<span class="udiff-line-modified-added">+             Edge&amp; operandEdge = node-&gt;child1();</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             fixIntConvertingEdge(operandEdge);</span>
              break;
          }
  
<span class="udiff-line-added">+         case ArithBitLShift:</span>
          case ArithBitXor:
          case ArithBitOr:
          case ArithBitAnd: {
              fixIntConvertingEdge(node-&gt;child1());
              fixIntConvertingEdge(node-&gt;child2());
              break;
          }
  
          case BitRShift:
<span class="udiff-line-removed">-         case BitLShift:</span>
          case BitURShift: {
              if (Node::shouldSpeculateUntypedForBitOps(node-&gt;child1().node(), node-&gt;child2().node())) {
                  fixEdge&lt;UntypedUse&gt;(node-&gt;child1());
                  fixEdge&lt;UntypedUse&gt;(node-&gt;child2());
                  break;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -311,11 +347,11 @@</span>
                  node-&gt;setResult(NodeResultInt32);
                  node-&gt;clearFlags(NodeMustGenerate);
                  break;
              }
  
<span class="udiff-line-modified-removed">-             if (m_graph.unaryArithShouldSpeculateAnyInt(node, FixupPass)) {</span>
<span class="udiff-line-modified-added">+             if (m_graph.unaryArithShouldSpeculateInt52(node, FixupPass)) {</span>
                  node-&gt;setOp(ArithNegate);
                  fixEdge&lt;Int52RepUse&gt;(node-&gt;child1());
                  if (bytecodeCanIgnoreNegativeZero(node-&gt;arithNodeFlags()))
                      node-&gt;setArithMode(Arith::CheckOverflow);
                  else
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -435,11 +471,11 @@</span>
                      node-&gt;setArithMode(Arith::CheckOverflowAndNegativeZero);
                  node-&gt;setResult(NodeResultInt32);
                  node-&gt;clearFlags(NodeMustGenerate);
                  break;
              }
<span class="udiff-line-modified-removed">-             if (m_graph.unaryArithShouldSpeculateAnyInt(node, FixupPass)) {</span>
<span class="udiff-line-modified-added">+             if (m_graph.unaryArithShouldSpeculateInt52(node, FixupPass)) {</span>
                  fixEdge&lt;Int52RepUse&gt;(node-&gt;child1());
                  if (bytecodeCanIgnoreNegativeZero(node-&gt;arithNodeFlags()))
                      node-&gt;setArithMode(Arith::CheckOverflow);
                  else
                      node-&gt;setArithMode(Arith::CheckOverflowAndNegativeZero);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -459,10 +495,11 @@</span>
              Edge&amp; rightChild = node-&gt;child2();
  
              if (Node::shouldSpeculateBigInt(leftChild.node(), rightChild.node())) {
                  fixEdge&lt;BigIntUse&gt;(node-&gt;child1());
                  fixEdge&lt;BigIntUse&gt;(node-&gt;child2());
<span class="udiff-line-added">+                 node-&gt;clearFlags(NodeMustGenerate);</span>
                  break;
              }
  
              // There are cases where we can have BigInt + Int32 operands reaching ValueMul.
              // Imagine the scenario where ValueMul was never executed, but we can predict types
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -493,26 +530,33 @@</span>
  
              fixupArithMul(node, leftChild, rightChild);
              break;
          }
  
<span class="udiff-line-added">+         case ValueMod:</span>
          case ValueDiv: {
              Edge&amp; leftChild = node-&gt;child1();
              Edge&amp; rightChild = node-&gt;child2();
  
              if (Node::shouldSpeculateBigInt(leftChild.node(), rightChild.node())) {
                  fixEdge&lt;BigIntUse&gt;(leftChild);
                  fixEdge&lt;BigIntUse&gt;(rightChild);
<span class="udiff-line-added">+                 node-&gt;clearFlags(NodeMustGenerate);</span>
                  break;
              }
  
              if (Node::shouldSpeculateUntypedForArithmetic(leftChild.node(), rightChild.node())) {
                  fixEdge&lt;UntypedUse&gt;(leftChild);
                  fixEdge&lt;UntypedUse&gt;(rightChild);
                  break;
              }
<span class="udiff-line-modified-removed">-             node-&gt;setOp(ArithDiv);</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-added">+             if (op == ValueDiv)</span>
<span class="udiff-line-added">+                 node-&gt;setOp(ArithDiv);</span>
<span class="udiff-line-added">+             else</span>
<span class="udiff-line-added">+                 node-&gt;setOp(ArithMod);</span>
<span class="udiff-line-added">+ </span>
              node-&gt;setResult(NodeResultNumber);
              fixupArithDiv(node, leftChild, rightChild);
              break;
  
          }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -559,19 +603,34 @@</span>
                  fixEdge&lt;UntypedUse&gt;(node-&gt;child1());
              node-&gt;setResult(NodeResultDouble);
              break;
          }
  
<span class="udiff-line-modified-removed">-         case ArithPow: {</span>
<span class="udiff-line-modified-removed">-             if (node-&gt;child2()-&gt;shouldSpeculateInt32OrBooleanForArithmetic()) {</span>
<span class="udiff-line-modified-removed">-                 fixDoubleOrBooleanEdge(node-&gt;child1());</span>
<span class="udiff-line-modified-removed">-                 fixIntOrBooleanEdge(node-&gt;child2());</span>
<span class="udiff-line-modified-added">+         case ValuePow: {</span>
<span class="udiff-line-modified-added">+             if (Node::shouldSpeculateBigInt(node-&gt;child1().node(), node-&gt;child2().node())) {</span>
<span class="udiff-line-modified-added">+                 fixEdge&lt;BigIntUse&gt;(node-&gt;child1());</span>
<span class="udiff-line-modified-added">+                 fixEdge&lt;BigIntUse&gt;(node-&gt;child2());</span>
<span class="udiff-line-added">+                 node-&gt;clearFlags(NodeMustGenerate);</span>
                  break;
              }
  
<span class="udiff-line-modified-removed">-             fixDoubleOrBooleanEdge(node-&gt;child1());</span>
<span class="udiff-line-modified-removed">-             fixDoubleOrBooleanEdge(node-&gt;child2());</span>
<span class="udiff-line-modified-added">+             if (Node::shouldSpeculateUntypedForArithmetic(node-&gt;child1().node(), node-&gt;child2().node())) {</span>
<span class="udiff-line-modified-added">+                 fixEdge&lt;UntypedUse&gt;(node-&gt;child1());</span>
<span class="udiff-line-added">+                 fixEdge&lt;UntypedUse&gt;(node-&gt;child2());</span>
<span class="udiff-line-added">+                 break;</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             node-&gt;setOp(ArithPow);</span>
<span class="udiff-line-added">+             node-&gt;clearFlags(NodeMustGenerate);</span>
<span class="udiff-line-added">+             node-&gt;setResult(NodeResultDouble);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             fixupArithPow(node);</span>
<span class="udiff-line-added">+             break;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         case ArithPow: {</span>
<span class="udiff-line-added">+             fixupArithPow(node);</span>
              break;
          }
  
          case ArithRandom: {
              node-&gt;setResult(NodeResultDouble);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -666,12 +725,11 @@</span>
                  fixIntOrBooleanEdge(node-&gt;child1());
                  fixIntOrBooleanEdge(node-&gt;child2());
                  node-&gt;clearFlags(NodeMustGenerate);
                  break;
              }
<span class="udiff-line-modified-removed">-             if (enableInt52()</span>
<span class="udiff-line-removed">-                 &amp;&amp; Node::shouldSpeculateAnyInt(node-&gt;child1().node(), node-&gt;child2().node())) {</span>
<span class="udiff-line-modified-added">+             if (Node::shouldSpeculateInt52(node-&gt;child1().node(), node-&gt;child2().node())) {</span>
                  fixEdge&lt;Int52RepUse&gt;(node-&gt;child1());
                  fixEdge&lt;Int52RepUse&gt;(node-&gt;child2());
                  node-&gt;clearFlags(NodeMustGenerate);
                  break;
              }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -921,11 +979,11 @@</span>
                  break;
  
              case Array::Uint32Array:
                  if (node-&gt;shouldSpeculateInt32())
                      break;
<span class="udiff-line-modified-removed">-                 if (node-&gt;shouldSpeculateAnyInt() &amp;&amp; enableInt52())</span>
<span class="udiff-line-modified-added">+                 if (node-&gt;shouldSpeculateInt52())</span>
                      node-&gt;setResult(NodeResultInt52);
                  else
                      node-&gt;setResult(NodeResultDouble);
                  break;
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1000,11 +1058,11 @@</span>
              case Array::Uint32Array:
                  fixEdge&lt;KnownCellUse&gt;(child1);
                  fixEdge&lt;Int32Use&gt;(child2);
                  if (child3-&gt;shouldSpeculateInt32())
                      fixIntOrBooleanEdge(child3);
<span class="udiff-line-modified-removed">-                 else if (child3-&gt;shouldSpeculateAnyInt())</span>
<span class="udiff-line-modified-added">+                 else if (child3-&gt;shouldSpeculateInt52())</span>
                      fixEdge&lt;Int52RepUse&gt;(child3);
                  else
                      fixDoubleOrBooleanEdge(child3);
                  break;
              case Array::Float32Array:
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1045,11 +1103,11 @@</span>
                  Edge&amp; child = m_graph.child(node, 2 + i);
                  // NOTE: DFG is not smart enough to handle double-&gt;int conversions in atomics. So, we
                  // just call the function when that happens. But the FTL is totally cool with those
                  // conversions.
                  if (!child-&gt;shouldSpeculateInt32()
<span class="udiff-line-modified-removed">-                     &amp;&amp; !child-&gt;shouldSpeculateAnyInt()</span>
<span class="udiff-line-modified-added">+                     &amp;&amp; !child-&gt;shouldSpeculateInt52()</span>
                      &amp;&amp; !(child-&gt;shouldSpeculateNumberOrBoolean() &amp;&amp; m_graph.m_plan.isFTL()))
                      badNews = true;
              }
  
              if (badNews) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1066,11 +1124,11 @@</span>
  
              for (unsigned i = numExtraAtomicsArgs(node-&gt;op()); i--;) {
                  Edge&amp; child = m_graph.child(node, 2 + i);
                  if (child-&gt;shouldSpeculateInt32())
                      fixIntOrBooleanEdge(child);
<span class="udiff-line-modified-removed">-                 else if (child-&gt;shouldSpeculateAnyInt())</span>
<span class="udiff-line-modified-added">+                 else if (child-&gt;shouldSpeculateInt52())</span>
                      fixEdge&lt;Int52RepUse&gt;(child);
                  else {
                      RELEASE_ASSERT(child-&gt;shouldSpeculateNumberOrBoolean() &amp;&amp; m_graph.m_plan.isFTL());
                      fixDoubleOrBooleanEdge(child);
                  }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1080,11 +1138,11 @@</span>
              fixEdge&lt;CellUse&gt;(base);
              fixEdge&lt;Int32Use&gt;(index);
  
              if (node-&gt;arrayMode().type() == Array::Uint32Array) {
                  // NOTE: This means basically always doing Int52.
<span class="udiff-line-modified-removed">-                 if (node-&gt;shouldSpeculateAnyInt() &amp;&amp; enableInt52())</span>
<span class="udiff-line-modified-added">+                 if (node-&gt;shouldSpeculateInt52())</span>
                      node-&gt;setResult(NodeResultInt52);
                  else
                      node-&gt;setResult(NodeResultDouble);
              }
              break;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1134,25 +1192,22 @@</span>
              // and ArrayPush uses the edge as known typed edge. Therefore, ArrayPush do not need to perform type checks.
              for (unsigned i = 0; i &lt; elementCount; ++i) {
                  Edge&amp; element = m_graph.varArgChild(node, i + elementOffset);
                  switch (node-&gt;arrayMode().type()) {
                  case Array::Int32:
<span class="udiff-line-modified-removed">-                     insertCheck&lt;Int32Use&gt;(element.node());</span>
<span class="udiff-line-removed">-                     fixEdge&lt;KnownInt32Use&gt;(element);</span>
<span class="udiff-line-modified-added">+                     fixEdge&lt;Int32Use&gt;(element);</span>
                      break;
                  case Array::Double:
<span class="udiff-line-modified-removed">-                     insertCheck&lt;DoubleRepRealUse&gt;(element.node());</span>
<span class="udiff-line-removed">-                     fixEdge&lt;DoubleRepUse&gt;(element);</span>
<span class="udiff-line-modified-added">+                     fixEdge&lt;DoubleRepRealUse&gt;(element);</span>
                      break;
                  case Array::Contiguous:
                  case Array::ArrayStorage:
                      speculateForBarrier(element);
                      break;
                  default:
                      break;
                  }
<span class="udiff-line-removed">-                 ASSERT(shouldNotHaveTypeCheck(element.useKind()));</span>
              }
              break;
          }
  
          case ArrayPop: {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1507,11 +1562,11 @@</span>
                              insertCheck&lt;Int32Use&gt;(node-&gt;child1().node());
                              m_graph.convertToConstant(node, m_graph.freeze(globalObject-&gt;numberProtoToStringFunction()));
                              break;
                          }
  
<span class="udiff-line-modified-removed">-                         if (enableInt52() &amp;&amp; node-&gt;child1()-&gt;shouldSpeculateAnyInt()) {</span>
<span class="udiff-line-modified-added">+                         if (node-&gt;child1()-&gt;shouldSpeculateInt52()) {</span>
                              insertCheck&lt;Int52RepUse&gt;(node-&gt;child1().node());
                              m_graph.convertToConstant(node, m_graph.freeze(globalObject-&gt;numberProtoToStringFunction()));
                              break;
                          }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1853,41 +1908,41 @@</span>
                      m_graph.varArgChild(node, 1)-&gt;prediction(),
                      SpecNone));
  
              blessArrayOperation(m_graph.varArgChild(node, 0), m_graph.varArgChild(node, 1), m_graph.varArgChild(node, 2));
              fixEdge&lt;CellUse&gt;(m_graph.varArgChild(node, 0));
<span class="udiff-line-modified-removed">-             fixEdge&lt;KnownInt32Use&gt;(m_graph.varArgChild(node, 1));</span>
<span class="udiff-line-modified-added">+             fixEdge&lt;Int32Use&gt;(m_graph.varArgChild(node, 1));</span>
              break;
          }
          case GetDirectPname: {
              Edge&amp; base = m_graph.varArgChild(node, 0);
              Edge&amp; property = m_graph.varArgChild(node, 1);
              Edge&amp; index = m_graph.varArgChild(node, 2);
              Edge&amp; enumerator = m_graph.varArgChild(node, 3);
              fixEdge&lt;CellUse&gt;(base);
              fixEdge&lt;KnownCellUse&gt;(property);
<span class="udiff-line-modified-removed">-             fixEdge&lt;KnownInt32Use&gt;(index);</span>
<span class="udiff-line-modified-added">+             fixEdge&lt;Int32Use&gt;(index);</span>
              fixEdge&lt;KnownCellUse&gt;(enumerator);
              break;
          }
          case GetPropertyEnumerator: {
              if (node-&gt;child1()-&gt;shouldSpeculateCell())
                  fixEdge&lt;CellUse&gt;(node-&gt;child1());
              break;
          }
          case GetEnumeratorStructurePname: {
              fixEdge&lt;KnownCellUse&gt;(node-&gt;child1());
<span class="udiff-line-modified-removed">-             fixEdge&lt;KnownInt32Use&gt;(node-&gt;child2());</span>
<span class="udiff-line-modified-added">+             fixEdge&lt;Int32Use&gt;(node-&gt;child2());</span>
              break;
          }
          case GetEnumeratorGenericPname: {
              fixEdge&lt;KnownCellUse&gt;(node-&gt;child1());
<span class="udiff-line-modified-removed">-             fixEdge&lt;KnownInt32Use&gt;(node-&gt;child2());</span>
<span class="udiff-line-modified-added">+             fixEdge&lt;Int32Use&gt;(node-&gt;child2());</span>
              break;
          }
          case ToIndexString: {
<span class="udiff-line-modified-removed">-             fixEdge&lt;KnownInt32Use&gt;(node-&gt;child1());</span>
<span class="udiff-line-modified-added">+             fixEdge&lt;Int32Use&gt;(node-&gt;child1());</span>
              break;
          }
          case ProfileType: {
              // We want to insert type checks based on the instructionTypeSet of the TypeLocation, not the globalTypeSet.
              // Because the instructionTypeSet is contained in globalTypeSet, if we produce a type check for
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1975,11 +2030,11 @@</span>
              break;
          }
  
          case CreateRest: {
              watchHavingABadTime(node);
<span class="udiff-line-modified-removed">-             fixEdge&lt;KnownInt32Use&gt;(node-&gt;child1());</span>
<span class="udiff-line-modified-added">+             fixEdge&lt;Int32Use&gt;(node-&gt;child1());</span>
              break;
          }
  
          case ResolveScopeForHoistingFuncDeclInEval: {
              fixEdge&lt;KnownCellUse&gt;(node-&gt;child1());
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2139,11 +2194,11 @@</span>
              else if (propertyEdge-&gt;shouldSpeculateString())
                  fixEdge&lt;StringUse&gt;(propertyEdge);
              else
                  fixEdge&lt;UntypedUse&gt;(propertyEdge);
              fixEdge&lt;UntypedUse&gt;(m_graph.varArgChild(node, 2));
<span class="udiff-line-modified-removed">-             fixEdge&lt;KnownInt32Use&gt;(m_graph.varArgChild(node, 3));</span>
<span class="udiff-line-modified-added">+             fixEdge&lt;Int32Use&gt;(m_graph.varArgChild(node, 3));</span>
              break;
          }
  
          case StringValueOf: {
              fixupStringValueOf(node);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2168,11 +2223,11 @@</span>
          }
  
          case NumberToStringWithRadix: {
              if (node-&gt;child1()-&gt;shouldSpeculateInt32())
                  fixEdge&lt;Int32Use&gt;(node-&gt;child1());
<span class="udiff-line-modified-removed">-             else if (enableInt52() &amp;&amp; node-&gt;child1()-&gt;shouldSpeculateAnyInt())</span>
<span class="udiff-line-modified-added">+             else if (node-&gt;child1()-&gt;shouldSpeculateInt52())</span>
                  fixEdge&lt;Int52RepUse&gt;(node-&gt;child1());
              else
                  fixEdge&lt;DoubleRepUse&gt;(node-&gt;child1());
              fixEdge&lt;Int32Use&gt;(node-&gt;child2());
              break;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2189,11 +2244,11 @@</span>
                  fixEdge&lt;StringUse&gt;(propertyEdge);
              else
                  fixEdge&lt;UntypedUse&gt;(propertyEdge);
              fixEdge&lt;CellUse&gt;(m_graph.varArgChild(node, 2));
              fixEdge&lt;CellUse&gt;(m_graph.varArgChild(node, 3));
<span class="udiff-line-modified-removed">-             fixEdge&lt;KnownInt32Use&gt;(m_graph.varArgChild(node, 4));</span>
<span class="udiff-line-modified-added">+             fixEdge&lt;Int32Use&gt;(m_graph.varArgChild(node, 4));</span>
              break;
          }
  
          case CheckSubClass: {
              fixupCheckSubClass(node);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2313,11 +2368,12 @@</span>
              break;
          }
  
  #if !ASSERT_DISABLED
          // Have these no-op cases here to ensure that nobody forgets to add handlers for new opcodes.
<span class="udiff-line-modified-removed">-         case SetArgument:</span>
<span class="udiff-line-modified-added">+         case SetArgumentDefinitely:</span>
<span class="udiff-line-added">+         case SetArgumentMaybe:</span>
          case JSConstant:
          case LazyJSConstant:
          case DoubleConstant:
          case GetLocal:
          case GetCallee:
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2602,11 +2658,11 @@</span>
              if (node-&gt;child1()-&gt;shouldSpeculateInt32()) {
                  insertCheck&lt;Int32Use&gt;(node-&gt;child1().node());
                  m_graph.convertToConstant(node, m_graph.freeze(m_graph.globalObjectFor(node-&gt;origin.semantic)-&gt;numberPrototype()));
                  return;
              }
<span class="udiff-line-modified-removed">-             if (enableInt52() &amp;&amp; node-&gt;child1()-&gt;shouldSpeculateAnyInt()) {</span>
<span class="udiff-line-modified-added">+             if (node-&gt;child1()-&gt;shouldSpeculateInt52()) {</span>
                  insertCheck&lt;Int52RepUse&gt;(node-&gt;child1().node());
                  m_graph.convertToConstant(node, m_graph.freeze(m_graph.globalObjectFor(node-&gt;origin.semantic)-&gt;numberPrototype()));
                  return;
              }
              if (node-&gt;child1()-&gt;shouldSpeculateNumber()) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2643,13 +2699,13 @@</span>
          }
      }
  
      void fixupToThis(Node* node)
      {
<span class="udiff-line-modified-removed">-         ECMAMode ecmaMode = m_graph.executableFor(node-&gt;origin.semantic)-&gt;isStrictMode() ? StrictMode : NotStrictMode;</span>
<span class="udiff-line-modified-added">+         bool isStrictMode = m_graph.isStrictModeFor(node-&gt;origin.semantic);</span>
  
<span class="udiff-line-modified-removed">-         if (ecmaMode == StrictMode) {</span>
<span class="udiff-line-modified-added">+         if (isStrictMode) {</span>
              if (node-&gt;child1()-&gt;shouldSpeculateBoolean()) {
                  fixEdge&lt;BooleanUse&gt;(node-&gt;child1());
                  node-&gt;convertToIdentity();
                  return;
              }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2658,11 +2714,11 @@</span>
                  fixEdge&lt;Int32Use&gt;(node-&gt;child1());
                  node-&gt;convertToIdentity();
                  return;
              }
  
<span class="udiff-line-modified-removed">-             if (enableInt52() &amp;&amp; node-&gt;child1()-&gt;shouldSpeculateAnyInt()) {</span>
<span class="udiff-line-modified-added">+             if (node-&gt;child1()-&gt;shouldSpeculateInt52()) {</span>
                  fixEdge&lt;Int52RepUse&gt;(node-&gt;child1());
                  node-&gt;convertToIdentity();
                  node-&gt;setResult(NodeResultInt52);
                  return;
              }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2698,11 +2754,11 @@</span>
                  return;
              }
          }
  
          if (node-&gt;child1()-&gt;shouldSpeculateOther()) {
<span class="udiff-line-modified-removed">-             if (ecmaMode == StrictMode) {</span>
<span class="udiff-line-modified-added">+             if (isStrictMode) {</span>
                  fixEdge&lt;OtherUse&gt;(node-&gt;child1());
                  node-&gt;convertToIdentity();
                  return;
              }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2762,10 +2818,19 @@</span>
          }
      }
  
      void fixupToNumber(Node* node)
      {
<span class="udiff-line-added">+         // At first, attempt to fold Boolean or Int32 to Int32.</span>
<span class="udiff-line-added">+         if (node-&gt;child1()-&gt;shouldSpeculateInt32OrBoolean()) {</span>
<span class="udiff-line-added">+             if (isInt32Speculation(node-&gt;getHeapPrediction())) {</span>
<span class="udiff-line-added">+                 fixIntOrBooleanEdge(node-&gt;child1());</span>
<span class="udiff-line-added">+                 node-&gt;convertToIdentity();</span>
<span class="udiff-line-added">+                 return;</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
          // If the prediction of the child is Number, we attempt to convert ToNumber to Identity.
          if (node-&gt;child1()-&gt;shouldSpeculateNumber()) {
              if (isInt32Speculation(node-&gt;getHeapPrediction())) {
                  // If the both predictions of this node and the child is Int32, we just convert ToNumber to Identity, that&#39;s simple.
                  if (node-&gt;child1()-&gt;shouldSpeculateInt32()) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2892,11 +2957,11 @@</span>
              fixEdge&lt;Int32Use&gt;(node-&gt;child1());
              node-&gt;clearFlags(NodeMustGenerate);
              return;
          }
  
<span class="udiff-line-modified-removed">-         if (enableInt52() &amp;&amp; node-&gt;child1()-&gt;shouldSpeculateAnyInt()) {</span>
<span class="udiff-line-modified-added">+         if (node-&gt;child1()-&gt;shouldSpeculateInt52()) {</span>
              fixEdge&lt;Int52RepUse&gt;(node-&gt;child1());
              node-&gt;clearFlags(NodeMustGenerate);
              return;
          }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3213,11 +3278,11 @@</span>
              if (alwaysUnboxSimplePrimitives()
                  || isBooleanSpeculation(variable-&gt;prediction()))
                  m_profitabilityChanged |= variable-&gt;mergeIsProfitableToUnbox(true);
              break;
          case Int52RepUse:
<span class="udiff-line-modified-removed">-             if (isAnyIntSpeculation(variable-&gt;prediction()))</span>
<span class="udiff-line-modified-added">+             if (!isInt32Speculation(variable-&gt;prediction()) &amp;&amp; isInt32OrInt52Speculation(variable-&gt;prediction()))</span>
                  m_profitabilityChanged |= variable-&gt;mergeIsProfitableToUnbox(true);
              break;
          case CellUse:
          case KnownCellUse:
          case ObjectUse:
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3304,11 +3369,11 @@</span>
              fixIntOrBooleanEdge(edge);
              return;
          }
  
          UseKind useKind;
<span class="udiff-line-modified-removed">-         if (node-&gt;shouldSpeculateAnyInt())</span>
<span class="udiff-line-modified-added">+         if (node-&gt;shouldSpeculateInt52())</span>
              useKind = Int52RepUse;
          else if (node-&gt;shouldSpeculateNumber())
              useKind = DoubleRepUse;
          else
              useKind = NotCellUse;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3401,11 +3466,11 @@</span>
              else
                  node-&gt;setArithMode(Arith::CheckOverflow);
              return true;
          }
  
<span class="udiff-line-modified-removed">-         if (m_graph.addShouldSpeculateAnyInt(node)) {</span>
<span class="udiff-line-modified-added">+         if (m_graph.addShouldSpeculateInt52(node)) {</span>
              fixEdge&lt;Int52RepUse&gt;(node-&gt;child1());
              fixEdge&lt;Int52RepUse&gt;(node-&gt;child2());
              node-&gt;setArithMode(Arith::CheckOverflow);
              node-&gt;setResult(NodeResultInt52);
              return true;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3418,11 +3483,11 @@</span>
      {
          if (!isInt32Speculation(node-&gt;prediction()))
              return false;
          CodeBlock* profiledBlock = m_graph.baselineCodeBlockFor(node-&gt;origin.semantic);
          ArrayProfile* arrayProfile =
<span class="udiff-line-modified-removed">-             profiledBlock-&gt;getArrayProfile(node-&gt;origin.semantic.bytecodeIndex);</span>
<span class="udiff-line-modified-added">+             profiledBlock-&gt;getArrayProfile(node-&gt;origin.semantic.bytecodeIndex());</span>
          ArrayMode arrayMode = ArrayMode(Array::SelectUsingPredictions, Array::Read);
          if (arrayProfile) {
              ConcurrentJSLocker locker(profiledBlock-&gt;m_lock);
              arrayProfile-&gt;computeUpdatedPrediction(locker, profiledBlock);
              arrayMode = ArrayMode::fromObserved(locker, arrayProfile, Array::Read, false);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3720,12 +3785,11 @@</span>
              fixEdge&lt;Int32Use&gt;(node-&gt;child1());
              fixEdge&lt;Int32Use&gt;(node-&gt;child2());
              node-&gt;setOpAndDefaultFlags(CompareStrictEq);
              return;
          }
<span class="udiff-line-modified-removed">-         if (enableInt52()</span>
<span class="udiff-line-removed">-             &amp;&amp; Node::shouldSpeculateAnyInt(node-&gt;child1().node(), node-&gt;child2().node())) {</span>
<span class="udiff-line-modified-added">+         if (Node::shouldSpeculateInt52(node-&gt;child1().node(), node-&gt;child2().node())) {</span>
              fixEdge&lt;Int52RepUse&gt;(node-&gt;child1());
              fixEdge&lt;Int52RepUse&gt;(node-&gt;child2());
              node-&gt;setOpAndDefaultFlags(CompareStrictEq);
              return;
          }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3961,23 +4025,23 @@</span>
                              break;
  
                          ASSERT(indexForChecks != UINT_MAX);
                          if (edge-&gt;isAnyIntConstant()) {
                              result = m_insertionSet.insertNode(
<span class="udiff-line-modified-removed">-                                 indexForChecks, SpecAnyInt, Int52Constant, originForChecks,</span>
<span class="udiff-line-modified-added">+                                 indexForChecks, SpecInt52Any, Int52Constant, originForChecks,</span>
                                  OpInfo(edge-&gt;constant()));
                          } else if (edge-&gt;hasDoubleResult()) {
                              result = m_insertionSet.insertNode(
<span class="udiff-line-modified-removed">-                                 indexForChecks, SpecAnyInt, Int52Rep, originForChecks,</span>
<span class="udiff-line-modified-added">+                                 indexForChecks, SpecInt52Any, Int52Rep, originForChecks,</span>
                                  Edge(edge.node(), DoubleRepAnyIntUse));
                          } else if (edge-&gt;shouldSpeculateInt32ForArithmetic()) {
                              result = m_insertionSet.insertNode(
                                  indexForChecks, SpecInt32Only, Int52Rep, originForChecks,
                                  Edge(edge.node(), Int32Use));
                          } else {
                              result = m_insertionSet.insertNode(
<span class="udiff-line-modified-removed">-                                 indexForChecks, SpecAnyInt, Int52Rep, originForChecks,</span>
<span class="udiff-line-modified-added">+                                 indexForChecks, SpecInt52Any, Int52Rep, originForChecks,</span>
                                  Edge(edge.node(), AnyIntUse));
                          }
  
                          edge.setNode(result);
                          break;
</pre>
<center><a href="DFGDriver.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DFGFlowIndexing.h.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>