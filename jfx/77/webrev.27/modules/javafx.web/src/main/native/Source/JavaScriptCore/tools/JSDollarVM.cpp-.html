<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.web/src/main/native/Source/JavaScriptCore/tools/JSDollarVM.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (C) 2015-2018 Apple Inc. All rights reserved.
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  * 1. Redistributions of source code must retain the above copyright
   8  *    notice, this list of conditions and the following disclaimer.
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #include &quot;config.h&quot;
  27 #include &quot;JSDollarVM.h&quot;
  28 
  29 #include &quot;BuiltinExecutableCreator.h&quot;
  30 #include &quot;CodeBlock.h&quot;
  31 #include &quot;DOMAttributeGetterSetter.h&quot;
  32 #include &quot;DOMJITGetterSetter.h&quot;
  33 #include &quot;FrameTracers.h&quot;
  34 #include &quot;FunctionCodeBlock.h&quot;
  35 #include &quot;GetterSetter.h&quot;
  36 #include &quot;JSArray.h&quot;
  37 #include &quot;JSArrayBuffer.h&quot;
  38 #include &quot;JSCInlines.h&quot;
  39 #include &quot;JSFunction.h&quot;
  40 #include &quot;JSONObject.h&quot;
  41 #include &quot;JSProxy.h&quot;
  42 #include &quot;JSString.h&quot;
  43 #include &quot;ShadowChicken.h&quot;
  44 #include &quot;Snippet.h&quot;
  45 #include &quot;SnippetParams.h&quot;
  46 #include &quot;TypeProfiler.h&quot;
  47 #include &quot;TypeProfilerLog.h&quot;
  48 #include &quot;VMInspector.h&quot;
  49 #include &lt;wtf/Atomics.h&gt;
  50 #include &lt;wtf/DataLog.h&gt;
  51 #include &lt;wtf/ProcessID.h&gt;
  52 #include &lt;wtf/StringPrintStream.h&gt;
  53 
  54 #if ENABLE(WEBASSEMBLY)
  55 #include &quot;JSWebAssemblyHelpers.h&quot;
  56 #include &quot;WasmStreamingParser.h&quot;
  57 #endif
  58 
  59 using namespace JSC;
  60 
  61 namespace {
  62 
  63 class JSDollarVMCallFrame : public JSDestructibleObject {
  64     using Base = JSDestructibleObject;
  65 public:
  66     JSDollarVMCallFrame(VM&amp; vm, Structure* structure)
  67         : Base(vm, structure)
  68     { }
  69 
  70     static Structure* createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
  71     {
  72         return Structure::create(vm, globalObject, prototype, TypeInfo(ObjectType, StructureFlags), info());
  73     }
  74 
  75     static JSDollarVMCallFrame* create(ExecState* exec, unsigned requestedFrameIndex)
  76     {
  77         VM&amp; vm = exec-&gt;vm();
  78         JSGlobalObject* globalObject = exec-&gt;lexicalGlobalObject();
  79         Structure* structure = createStructure(vm, globalObject, jsNull());
  80         JSDollarVMCallFrame* frame = new (NotNull, allocateCell&lt;JSDollarVMCallFrame&gt;(vm.heap, sizeof(JSDollarVMCallFrame))) JSDollarVMCallFrame(vm, structure);
  81         frame-&gt;finishCreation(vm, exec, requestedFrameIndex);
  82         return frame;
  83     }
  84 
  85     void finishCreation(VM&amp; vm, CallFrame* frame, unsigned requestedFrameIndex)
  86     {
  87         Base::finishCreation(vm);
  88 
  89         auto addProperty = [&amp;] (VM&amp; vm, const char* name, JSValue value) {
  90             JSDollarVMCallFrame::addProperty(vm, name, value);
  91         };
  92 
  93         unsigned frameIndex = 0;
  94         bool isValid = false;
  95         frame-&gt;iterate([&amp;] (StackVisitor&amp; visitor) {
  96 
  97             if (frameIndex++ != requestedFrameIndex)
  98                 return StackVisitor::Continue;
  99 
 100             addProperty(vm, &quot;name&quot;, jsString(&amp;vm, visitor-&gt;functionName()));
 101 
 102             if (visitor-&gt;callee().isCell())
 103                 addProperty(vm, &quot;callee&quot;, visitor-&gt;callee().asCell());
 104 
 105             CodeBlock* codeBlock = visitor-&gt;codeBlock();
 106             if (codeBlock) {
 107                 addProperty(vm, &quot;codeBlock&quot;, codeBlock);
 108                 addProperty(vm, &quot;unlinkedCodeBlock&quot;, codeBlock-&gt;unlinkedCodeBlock());
 109                 addProperty(vm, &quot;executable&quot;, codeBlock-&gt;ownerExecutable());
 110             }
 111             isValid = true;
 112 
 113             return StackVisitor::Done;
 114         });
 115 
 116         addProperty(vm, &quot;valid&quot;, jsBoolean(isValid));
 117     }
 118 
 119     DECLARE_INFO;
 120 
 121 private:
 122     void addProperty(VM&amp; vm, const char* name, JSValue value)
 123     {
 124         Identifier identifier = Identifier::fromString(&amp;vm, name);
 125         putDirect(vm, identifier, value);
 126     }
 127 };
 128 
 129 const ClassInfo JSDollarVMCallFrame::s_info = { &quot;CallFrame&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSDollarVMCallFrame) };
 130 
 131 class ElementHandleOwner;
 132 class Root;
 133 
 134 class Element : public JSNonFinalObject {
 135 public:
 136     Element(VM&amp; vm, Structure* structure)
 137         : Base(vm, structure)
 138     {
 139     }
 140 
 141     typedef JSNonFinalObject Base;
 142 
 143     Root* root() const { return m_root.get(); }
 144     void setRoot(VM&amp; vm, Root* root) { m_root.set(vm, this, root); }
 145 
 146     static Element* create(VM&amp; vm, JSGlobalObject* globalObject, Root* root)
 147     {
 148         Structure* structure = createStructure(vm, globalObject, jsNull());
 149         Element* element = new (NotNull, allocateCell&lt;Element&gt;(vm.heap, sizeof(Element))) Element(vm, structure);
 150         element-&gt;finishCreation(vm, root);
 151         return element;
 152     }
 153 
 154     void finishCreation(VM&amp;, Root*);
 155 
 156     static void visitChildren(JSCell* cell, SlotVisitor&amp; visitor)
 157     {
 158         Element* thisObject = jsCast&lt;Element*&gt;(cell);
 159         ASSERT_GC_OBJECT_INHERITS(thisObject, info());
 160         Base::visitChildren(thisObject, visitor);
 161         visitor.append(thisObject-&gt;m_root);
 162     }
 163 
 164     static ElementHandleOwner* handleOwner();
 165 
 166     static Structure* createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
 167     {
 168         return Structure::create(vm, globalObject, prototype, TypeInfo(ObjectType, StructureFlags), info());
 169     }
 170 
 171     DECLARE_INFO;
 172 
 173 private:
 174     WriteBarrier&lt;Root&gt; m_root;
 175 };
 176 
 177 class ElementHandleOwner : public WeakHandleOwner {
 178 public:
 179     bool isReachableFromOpaqueRoots(Handle&lt;JSC::Unknown&gt; handle, void*, SlotVisitor&amp; visitor, const char** reason) override
 180     {
 181         if (UNLIKELY(reason))
 182             *reason = &quot;JSC::Element is opaque root&quot;;
 183         Element* element = jsCast&lt;Element*&gt;(handle.slot()-&gt;asCell());
 184         return visitor.containsOpaqueRoot(element-&gt;root());
 185     }
 186 };
 187 
 188 class Root : public JSDestructibleObject {
 189 public:
 190     Root(VM&amp; vm, Structure* structure)
 191         : Base(vm, structure)
 192     {
 193     }
 194 
 195     Element* element()
 196     {
 197         return m_element.get();
 198     }
 199 
 200     void setElement(Element* element)
 201     {
 202         Weak&lt;Element&gt; newElement(element, Element::handleOwner());
 203         m_element.swap(newElement);
 204     }
 205 
 206     static Root* create(VM&amp; vm, JSGlobalObject* globalObject)
 207     {
 208         Structure* structure = createStructure(vm, globalObject, jsNull());
 209         Root* root = new (NotNull, allocateCell&lt;Root&gt;(vm.heap, sizeof(Root))) Root(vm, structure);
 210         root-&gt;finishCreation(vm);
 211         return root;
 212     }
 213 
 214     typedef JSDestructibleObject Base;
 215 
 216     DECLARE_INFO;
 217 
 218     static Structure* createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
 219     {
 220         return Structure::create(vm, globalObject, prototype, TypeInfo(ObjectType, StructureFlags), info());
 221     }
 222 
 223     static void visitChildren(JSCell* thisObject, SlotVisitor&amp; visitor)
 224     {
 225         Base::visitChildren(thisObject, visitor);
 226         visitor.addOpaqueRoot(thisObject);
 227     }
 228 
 229 private:
 230     Weak&lt;Element&gt; m_element;
 231 };
 232 
 233 class SimpleObject : public JSNonFinalObject {
 234 public:
 235     SimpleObject(VM&amp; vm, Structure* structure)
 236         : Base(vm, structure)
 237     {
 238     }
 239 
 240     typedef JSNonFinalObject Base;
 241     static const bool needsDestruction = false;
 242 
 243     static SimpleObject* create(VM&amp; vm, JSGlobalObject* globalObject)
 244     {
 245         Structure* structure = createStructure(vm, globalObject, jsNull());
 246         SimpleObject* simpleObject = new (NotNull, allocateCell&lt;SimpleObject&gt;(vm.heap, sizeof(SimpleObject))) SimpleObject(vm, structure);
 247         simpleObject-&gt;finishCreation(vm);
 248         return simpleObject;
 249     }
 250 
 251     static void visitChildren(JSCell* cell, SlotVisitor&amp; visitor)
 252     {
 253         SimpleObject* thisObject = jsCast&lt;SimpleObject*&gt;(cell);
 254         ASSERT_GC_OBJECT_INHERITS(thisObject, info());
 255         Base::visitChildren(thisObject, visitor);
 256         visitor.append(thisObject-&gt;m_hiddenValue);
 257     }
 258 
 259     static Structure* createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
 260     {
 261         return Structure::create(vm, globalObject, prototype, TypeInfo(ObjectType, StructureFlags), info());
 262     }
 263 
 264     JSValue hiddenValue()
 265     {
 266         return m_hiddenValue.get();
 267     }
 268 
 269     void setHiddenValue(VM&amp; vm, JSValue value)
 270     {
 271         ASSERT(value.isCell());
 272         m_hiddenValue.set(vm, this, value);
 273     }
 274 
 275     DECLARE_INFO;
 276 
 277 private:
 278     WriteBarrier&lt;JSC::Unknown&gt; m_hiddenValue;
 279 };
 280 
 281 class ImpureGetter : public JSNonFinalObject {
 282 public:
 283     ImpureGetter(VM&amp; vm, Structure* structure)
 284         : Base(vm, structure)
 285     {
 286     }
 287 
 288     DECLARE_INFO;
 289     typedef JSNonFinalObject Base;
 290     static const unsigned StructureFlags = Base::StructureFlags | JSC::GetOwnPropertySlotIsImpure | JSC::OverridesGetOwnPropertySlot;
 291 
 292     static Structure* createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
 293     {
 294         return Structure::create(vm, globalObject, prototype, TypeInfo(ObjectType, StructureFlags), info());
 295     }
 296 
 297     static ImpureGetter* create(VM&amp; vm, Structure* structure, JSObject* delegate)
 298     {
 299         ImpureGetter* getter = new (NotNull, allocateCell&lt;ImpureGetter&gt;(vm.heap, sizeof(ImpureGetter))) ImpureGetter(vm, structure);
 300         getter-&gt;finishCreation(vm, delegate);
 301         return getter;
 302     }
 303 
 304     void finishCreation(VM&amp; vm, JSObject* delegate)
 305     {
 306         Base::finishCreation(vm);
 307         if (delegate)
 308             m_delegate.set(vm, this, delegate);
 309     }
 310 
 311     static bool getOwnPropertySlot(JSObject* object, ExecState* exec, PropertyName name, PropertySlot&amp; slot)
 312     {
 313         VM&amp; vm = exec-&gt;vm();
 314         auto scope = DECLARE_THROW_SCOPE(vm);
 315         ImpureGetter* thisObject = jsCast&lt;ImpureGetter*&gt;(object);
 316 
 317         if (thisObject-&gt;m_delegate) {
 318             if (thisObject-&gt;m_delegate-&gt;getPropertySlot(exec, name, slot))
 319                 return true;
 320             RETURN_IF_EXCEPTION(scope, false);
 321         }
 322 
 323         return Base::getOwnPropertySlot(object, exec, name, slot);
 324     }
 325 
 326     static void visitChildren(JSCell* cell, SlotVisitor&amp; visitor)
 327     {
 328         Base::visitChildren(cell, visitor);
 329         ImpureGetter* thisObject = jsCast&lt;ImpureGetter*&gt;(cell);
 330         visitor.append(thisObject-&gt;m_delegate);
 331     }
 332 
 333     void setDelegate(VM&amp; vm, JSObject* delegate)
 334     {
 335         m_delegate.set(vm, this, delegate);
 336     }
 337 
 338 private:
 339     WriteBarrier&lt;JSObject&gt; m_delegate;
 340 };
 341 
 342 class CustomGetter : public JSNonFinalObject {
 343 public:
 344     CustomGetter(VM&amp; vm, Structure* structure)
 345         : Base(vm, structure)
 346     {
 347     }
 348 
 349     DECLARE_INFO;
 350     typedef JSNonFinalObject Base;
 351     static const unsigned StructureFlags = Base::StructureFlags | JSC::OverridesGetOwnPropertySlot;
 352 
 353     static Structure* createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
 354     {
 355         return Structure::create(vm, globalObject, prototype, TypeInfo(ObjectType, StructureFlags), info());
 356     }
 357 
 358     static CustomGetter* create(VM&amp; vm, Structure* structure)
 359     {
 360         CustomGetter* getter = new (NotNull, allocateCell&lt;CustomGetter&gt;(vm.heap, sizeof(CustomGetter))) CustomGetter(vm, structure);
 361         getter-&gt;finishCreation(vm);
 362         return getter;
 363     }
 364 
 365     static bool getOwnPropertySlot(JSObject* object, ExecState* exec, PropertyName propertyName, PropertySlot&amp; slot)
 366     {
 367         CustomGetter* thisObject = jsCast&lt;CustomGetter*&gt;(object);
 368         if (propertyName == PropertyName(Identifier::fromString(exec, &quot;customGetter&quot;))) {
 369             slot.setCacheableCustom(thisObject, PropertyAttribute::DontDelete | PropertyAttribute::ReadOnly | PropertyAttribute::DontEnum, thisObject-&gt;customGetter);
 370             return true;
 371         }
 372 
 373         if (propertyName == PropertyName(Identifier::fromString(exec, &quot;customGetterAccessor&quot;))) {
 374             slot.setCacheableCustom(thisObject, PropertyAttribute::DontDelete | PropertyAttribute::ReadOnly | PropertyAttribute::DontEnum | PropertyAttribute::CustomAccessor, thisObject-&gt;customGetterAcessor);
 375             return true;
 376         }
 377 
 378         return JSObject::getOwnPropertySlot(thisObject, exec, propertyName, slot);
 379     }
 380 
 381 private:
 382     static EncodedJSValue customGetter(ExecState* exec, EncodedJSValue thisValue, PropertyName)
 383     {
 384         VM&amp; vm = exec-&gt;vm();
 385         auto scope = DECLARE_THROW_SCOPE(vm);
 386 
 387         CustomGetter* thisObject = jsDynamicCast&lt;CustomGetter*&gt;(vm, JSValue::decode(thisValue));
 388         if (!thisObject)
 389             return throwVMTypeError(exec, scope);
 390         bool shouldThrow = thisObject-&gt;get(exec, PropertyName(Identifier::fromString(exec, &quot;shouldThrow&quot;))).toBoolean(exec);
 391         RETURN_IF_EXCEPTION(scope, encodedJSValue());
 392         if (shouldThrow)
 393             return throwVMTypeError(exec, scope);
 394         return JSValue::encode(jsNumber(100));
 395     }
 396 
 397     static EncodedJSValue customGetterAcessor(ExecState* exec, EncodedJSValue thisValue, PropertyName)
 398     {
 399         VM&amp; vm = exec-&gt;vm();
 400         auto scope = DECLARE_THROW_SCOPE(vm);
 401 
 402         JSObject* thisObject = jsDynamicCast&lt;JSObject*&gt;(vm, JSValue::decode(thisValue));
 403         if (!thisObject)
 404             return throwVMTypeError(exec, scope);
 405         bool shouldThrow = thisObject-&gt;get(exec, PropertyName(Identifier::fromString(exec, &quot;shouldThrow&quot;))).toBoolean(exec);
 406         RETURN_IF_EXCEPTION(scope, encodedJSValue());
 407         if (shouldThrow)
 408             return throwVMTypeError(exec, scope);
 409         return JSValue::encode(jsNumber(100));
 410     }
 411 };
 412 
 413 class RuntimeArray : public JSArray {
 414 public:
 415     typedef JSArray Base;
 416     static const unsigned StructureFlags = Base::StructureFlags | OverridesGetOwnPropertySlot | InterceptsGetOwnPropertySlotByIndexEvenWhenLengthIsNotZero | OverridesGetPropertyNames;
 417 
 418     static RuntimeArray* create(ExecState* exec)
 419     {
 420         VM&amp; vm = exec-&gt;vm();
 421         JSGlobalObject* globalObject = exec-&gt;lexicalGlobalObject();
 422         Structure* structure = createStructure(vm, globalObject, createPrototype(vm, globalObject));
 423         RuntimeArray* runtimeArray = new (NotNull, allocateCell&lt;RuntimeArray&gt;(vm.heap)) RuntimeArray(exec, structure);
 424         runtimeArray-&gt;finishCreation(exec);
 425         vm.heap.addFinalizer(runtimeArray, destroy);
 426         return runtimeArray;
 427     }
 428 
 429     ~RuntimeArray() { }
 430 
 431     static void destroy(JSCell* cell)
 432     {
 433         static_cast&lt;RuntimeArray*&gt;(cell)-&gt;RuntimeArray::~RuntimeArray();
 434     }
 435 
 436     static const bool needsDestruction = false;
 437 
 438     static bool getOwnPropertySlot(JSObject* object, ExecState* exec, PropertyName propertyName, PropertySlot&amp; slot)
 439     {
 440         VM&amp; vm = exec-&gt;vm();
 441         RuntimeArray* thisObject = jsCast&lt;RuntimeArray*&gt;(object);
 442         if (propertyName == vm.propertyNames-&gt;length) {
 443             slot.setCacheableCustom(thisObject, PropertyAttribute::DontDelete | PropertyAttribute::ReadOnly | PropertyAttribute::DontEnum, thisObject-&gt;lengthGetter);
 444             return true;
 445         }
 446 
 447         Optional&lt;uint32_t&gt; index = parseIndex(propertyName);
 448         if (index &amp;&amp; index.value() &lt; thisObject-&gt;getLength()) {
 449             slot.setValue(thisObject, PropertyAttribute::DontDelete | PropertyAttribute::DontEnum, jsNumber(thisObject-&gt;m_vector[index.value()]));
 450             return true;
 451         }
 452 
 453         return JSObject::getOwnPropertySlot(thisObject, exec, propertyName, slot);
 454     }
 455 
 456     static bool getOwnPropertySlotByIndex(JSObject* object, ExecState* exec, unsigned index, PropertySlot&amp; slot)
 457     {
 458         RuntimeArray* thisObject = jsCast&lt;RuntimeArray*&gt;(object);
 459         if (index &lt; thisObject-&gt;getLength()) {
 460             slot.setValue(thisObject, PropertyAttribute::DontDelete | PropertyAttribute::DontEnum, jsNumber(thisObject-&gt;m_vector[index]));
 461             return true;
 462         }
 463 
 464         return JSObject::getOwnPropertySlotByIndex(thisObject, exec, index, slot);
 465     }
 466 
 467     static NO_RETURN_DUE_TO_CRASH bool put(JSCell*, ExecState*, PropertyName, JSValue, PutPropertySlot&amp;)
 468     {
 469         RELEASE_ASSERT_NOT_REACHED();
 470     }
 471 
 472     static NO_RETURN_DUE_TO_CRASH bool deleteProperty(JSCell*, ExecState*, PropertyName)
 473     {
 474         RELEASE_ASSERT_NOT_REACHED();
 475     }
 476 
 477     unsigned getLength() const { return m_vector.size(); }
 478 
 479     DECLARE_INFO;
 480 
 481     static ArrayPrototype* createPrototype(VM&amp;, JSGlobalObject* globalObject)
 482     {
 483         return globalObject-&gt;arrayPrototype();
 484     }
 485 
 486     static Structure* createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
 487     {
 488         return Structure::create(vm, globalObject, prototype, TypeInfo(DerivedArrayType, StructureFlags), info(), ArrayClass);
 489     }
 490 
 491 protected:
 492     void finishCreation(ExecState* exec)
 493     {
 494         VM&amp; vm = exec-&gt;vm();
 495         Base::finishCreation(vm);
 496         ASSERT(inherits(vm, info()));
 497 
 498         for (size_t i = 0; i &lt; exec-&gt;argumentCount(); i++)
 499             m_vector.append(exec-&gt;argument(i).toInt32(exec));
 500     }
 501 
 502 private:
 503     RuntimeArray(ExecState* exec, Structure* structure)
 504         : JSArray(exec-&gt;vm(), structure, 0)
 505     {
 506     }
 507 
 508     static EncodedJSValue lengthGetter(ExecState* exec, EncodedJSValue thisValue, PropertyName)
 509     {
 510         VM&amp; vm = exec-&gt;vm();
 511         auto scope = DECLARE_THROW_SCOPE(vm);
 512 
 513         RuntimeArray* thisObject = jsDynamicCast&lt;RuntimeArray*&gt;(vm, JSValue::decode(thisValue));
 514         if (!thisObject)
 515             return throwVMTypeError(exec, scope);
 516         return JSValue::encode(jsNumber(thisObject-&gt;getLength()));
 517     }
 518 
 519     Vector&lt;int&gt; m_vector;
 520 };
 521 
 522 class DOMJITNode : public JSNonFinalObject {
 523 public:
 524     DOMJITNode(VM&amp; vm, Structure* structure)
 525         : Base(vm, structure)
 526     {
 527     }
 528 
 529     DECLARE_INFO;
 530     typedef JSNonFinalObject Base;
 531     static const unsigned StructureFlags = Base::StructureFlags;
 532 
 533     static Structure* createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
 534     {
 535         return Structure::create(vm, globalObject, prototype, TypeInfo(JSC::JSType(LastJSCObjectType + 1), StructureFlags), info());
 536     }
 537 
 538 #if ENABLE(JIT)
 539     static Ref&lt;Snippet&gt; checkSubClassSnippet()
 540     {
 541         Ref&lt;Snippet&gt; snippet = Snippet::create();
 542         snippet-&gt;setGenerator([=](CCallHelpers&amp; jit, SnippetParams&amp; params) {
 543             CCallHelpers::JumpList failureCases;
 544             failureCases.append(jit.branchIfNotType(params[0].gpr(), JSC::JSType(LastJSCObjectType + 1)));
 545             return failureCases;
 546         });
 547         return snippet;
 548     }
 549 #endif
 550 
 551     static DOMJITNode* create(VM&amp; vm, Structure* structure)
 552     {
 553         DOMJITNode* getter = new (NotNull, allocateCell&lt;DOMJITNode&gt;(vm.heap, sizeof(DOMJITNode))) DOMJITNode(vm, structure);
 554         getter-&gt;finishCreation(vm);
 555         return getter;
 556     }
 557 
 558     int32_t value() const
 559     {
 560         return m_value;
 561     }
 562 
 563     static ptrdiff_t offsetOfValue() { return OBJECT_OFFSETOF(DOMJITNode, m_value); }
 564 
 565 private:
 566     int32_t m_value { 42 };
 567 };
 568 
 569 class DOMJITGetter : public DOMJITNode {
 570 public:
 571     DOMJITGetter(VM&amp; vm, Structure* structure)
 572         : Base(vm, structure)
 573     {
 574     }
 575 
 576     DECLARE_INFO;
 577     typedef DOMJITNode Base;
 578     static const unsigned StructureFlags = Base::StructureFlags;
 579 
 580     static Structure* createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
 581     {
 582         return Structure::create(vm, globalObject, prototype, TypeInfo(JSC::JSType(LastJSCObjectType + 1), StructureFlags), info());
 583     }
 584 
 585     static DOMJITGetter* create(VM&amp; vm, Structure* structure)
 586     {
 587         DOMJITGetter* getter = new (NotNull, allocateCell&lt;DOMJITGetter&gt;(vm.heap, sizeof(DOMJITGetter))) DOMJITGetter(vm, structure);
 588         getter-&gt;finishCreation(vm);
 589         return getter;
 590     }
 591 
 592     class DOMJITAttribute : public DOMJIT::GetterSetter {
 593     public:
 594         constexpr DOMJITAttribute()
 595             : DOMJIT::GetterSetter(
 596                 DOMJITGetter::customGetter,
 597 #if ENABLE(JIT)
 598                 &amp;callDOMGetter,
 599 #else
 600                 nullptr,
 601 #endif
 602                 SpecInt32Only)
 603         {
 604         }
 605 
 606 #if ENABLE(JIT)
 607         static EncodedJSValue JIT_OPERATION slowCall(ExecState* exec, void* pointer)
 608         {
 609             VM&amp; vm = exec-&gt;vm();
 610             NativeCallFrameTracer tracer(&amp;vm, exec);
 611             return JSValue::encode(jsNumber(static_cast&lt;DOMJITGetter*&gt;(pointer)-&gt;value()));
 612         }
 613 
 614         static Ref&lt;DOMJIT::CallDOMGetterSnippet&gt; callDOMGetter()
 615         {
 616             Ref&lt;DOMJIT::CallDOMGetterSnippet&gt; snippet = DOMJIT::CallDOMGetterSnippet::create();
 617             snippet-&gt;requireGlobalObject = false;
 618             snippet-&gt;setGenerator([=](CCallHelpers&amp; jit, SnippetParams&amp; params) {
 619                 JSValueRegs results = params[0].jsValueRegs();
 620                 GPRReg dom = params[1].gpr();
 621                 params.addSlowPathCall(jit.jump(), jit, slowCall, results, dom);
 622                 return CCallHelpers::JumpList();
 623 
 624             });
 625             return snippet;
 626         }
 627 #endif
 628     };
 629 
 630 private:
 631     void finishCreation(VM&amp;);
 632 
 633     static EncodedJSValue customGetter(ExecState* exec, EncodedJSValue thisValue, PropertyName)
 634     {
 635         VM&amp; vm = exec-&gt;vm();
 636         DOMJITNode* thisObject = jsDynamicCast&lt;DOMJITNode*&gt;(vm, JSValue::decode(thisValue));
 637         ASSERT(thisObject);
 638         return JSValue::encode(jsNumber(thisObject-&gt;value()));
 639     }
 640 };
 641 
 642 static const DOMJITGetter::DOMJITAttribute DOMJITGetterDOMJIT;
 643 
 644 void DOMJITGetter::finishCreation(VM&amp; vm)
 645 {
 646     Base::finishCreation(vm);
 647     const DOMJIT::GetterSetter* domJIT = &amp;DOMJITGetterDOMJIT;
 648     auto* customGetterSetter = DOMAttributeGetterSetter::create(vm, domJIT-&gt;getter(), nullptr, DOMAttributeAnnotation { DOMJITNode::info(), domJIT });
 649     putDirectCustomAccessor(vm, Identifier::fromString(&amp;vm, &quot;customGetter&quot;), customGetterSetter, PropertyAttribute::ReadOnly | PropertyAttribute::CustomAccessor);
 650 }
 651 
 652 class DOMJITGetterComplex : public DOMJITNode {
 653 public:
 654     DOMJITGetterComplex(VM&amp; vm, Structure* structure)
 655         : Base(vm, structure)
 656     {
 657     }
 658 
 659     DECLARE_INFO;
 660     typedef DOMJITNode Base;
 661     static const unsigned StructureFlags = Base::StructureFlags;
 662 
 663     static Structure* createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
 664     {
 665         return Structure::create(vm, globalObject, prototype, TypeInfo(JSC::JSType(LastJSCObjectType + 1), StructureFlags), info());
 666     }
 667 
 668     static DOMJITGetterComplex* create(VM&amp; vm, JSGlobalObject* globalObject, Structure* structure)
 669     {
 670         DOMJITGetterComplex* getter = new (NotNull, allocateCell&lt;DOMJITGetterComplex&gt;(vm.heap, sizeof(DOMJITGetterComplex))) DOMJITGetterComplex(vm, structure);
 671         getter-&gt;finishCreation(vm, globalObject);
 672         return getter;
 673     }
 674 
 675     class DOMJITAttribute : public DOMJIT::GetterSetter {
 676     public:
 677         constexpr DOMJITAttribute()
 678             : DOMJIT::GetterSetter(
 679                 DOMJITGetterComplex::customGetter,
 680 #if ENABLE(JIT)
 681                 &amp;callDOMGetter,
 682 #else
 683                 nullptr,
 684 #endif
 685                 SpecInt32Only)
 686         {
 687         }
 688 
 689 #if ENABLE(JIT)
 690         static EncodedJSValue JIT_OPERATION slowCall(ExecState* exec, void* pointer)
 691         {
 692             VM&amp; vm = exec-&gt;vm();
 693             NativeCallFrameTracer tracer(&amp;vm, exec);
 694             auto scope = DECLARE_THROW_SCOPE(vm);
 695             auto* object = static_cast&lt;DOMJITNode*&gt;(pointer);
 696             auto* domjitGetterComplex = jsDynamicCast&lt;DOMJITGetterComplex*&gt;(vm, object);
 697             if (domjitGetterComplex) {
 698                 if (domjitGetterComplex-&gt;m_enableException)
 699                     return JSValue::encode(throwException(exec, scope, createError(exec, &quot;DOMJITGetterComplex slow call exception&quot;_s)));
 700             }
 701             return JSValue::encode(jsNumber(object-&gt;value()));
 702         }
 703 
 704         static Ref&lt;DOMJIT::CallDOMGetterSnippet&gt; callDOMGetter()
 705         {
 706             Ref&lt;DOMJIT::CallDOMGetterSnippet&gt; snippet = DOMJIT::CallDOMGetterSnippet::create();
 707             static_assert(GPRInfo::numberOfRegisters &gt;= 4, &quot;Number of registers should be larger or equal to 4.&quot;);
 708             unsigned numGPScratchRegisters = GPRInfo::numberOfRegisters - 4;
 709             snippet-&gt;numGPScratchRegisters = numGPScratchRegisters;
 710             snippet-&gt;numFPScratchRegisters = 3;
 711             snippet-&gt;setGenerator([=](CCallHelpers&amp; jit, SnippetParams&amp; params) {
 712                 JSValueRegs results = params[0].jsValueRegs();
 713                 GPRReg domGPR = params[1].gpr();
 714                 for (unsigned i = 0; i &lt; numGPScratchRegisters; ++i)
 715                     jit.move(CCallHelpers::TrustedImm32(42), params.gpScratch(i));
 716 
 717                 params.addSlowPathCall(jit.jump(), jit, slowCall, results, domGPR);
 718                 return CCallHelpers::JumpList();
 719             });
 720             return snippet;
 721         }
 722 #endif
 723     };
 724 
 725 private:
 726     void finishCreation(VM&amp;, JSGlobalObject*);
 727 
 728     static EncodedJSValue JSC_HOST_CALL functionEnableException(ExecState* exec)
 729     {
 730         VM&amp; vm = exec-&gt;vm();
 731         auto* object = jsDynamicCast&lt;DOMJITGetterComplex*&gt;(vm, exec-&gt;thisValue());
 732         if (object)
 733             object-&gt;m_enableException = true;
 734         return JSValue::encode(jsUndefined());
 735     }
 736 
 737     static EncodedJSValue customGetter(ExecState* exec, EncodedJSValue thisValue, PropertyName)
 738     {
 739         VM&amp; vm = exec-&gt;vm();
 740         auto scope = DECLARE_THROW_SCOPE(vm);
 741 
 742         auto* thisObject = jsDynamicCast&lt;DOMJITGetterComplex*&gt;(vm, JSValue::decode(thisValue));
 743         ASSERT(thisObject);
 744         if (thisObject-&gt;m_enableException)
 745             return JSValue::encode(throwException(exec, scope, createError(exec, &quot;DOMJITGetterComplex slow call exception&quot;_s)));
 746         return JSValue::encode(jsNumber(thisObject-&gt;value()));
 747     }
 748 
 749     bool m_enableException { false };
 750 };
 751 
 752 static const DOMJITGetterComplex::DOMJITAttribute DOMJITGetterComplexDOMJIT;
 753 
 754 void DOMJITGetterComplex::finishCreation(VM&amp; vm, JSGlobalObject* globalObject)
 755 {
 756     Base::finishCreation(vm);
 757     const DOMJIT::GetterSetter* domJIT = &amp;DOMJITGetterComplexDOMJIT;
 758     auto* customGetterSetter = DOMAttributeGetterSetter::create(vm, domJIT-&gt;getter(), nullptr, DOMAttributeAnnotation { DOMJITGetterComplex::info(), domJIT });
 759     putDirectCustomAccessor(vm, Identifier::fromString(&amp;vm, &quot;customGetter&quot;), customGetterSetter, PropertyAttribute::ReadOnly | PropertyAttribute::CustomAccessor);
 760     putDirectNativeFunction(vm, globalObject, Identifier::fromString(&amp;vm, &quot;enableException&quot;), 0, functionEnableException, NoIntrinsic, 0);
 761 }
 762 
 763 class DOMJITFunctionObject : public DOMJITNode {
 764 public:
 765     DOMJITFunctionObject(VM&amp; vm, Structure* structure)
 766         : Base(vm, structure)
 767     {
 768     }
 769 
 770     DECLARE_INFO;
 771     typedef DOMJITNode Base;
 772     static const unsigned StructureFlags = Base::StructureFlags;
 773 
 774 
 775     static Structure* createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
 776     {
 777         return Structure::create(vm, globalObject, prototype, TypeInfo(JSC::JSType(LastJSCObjectType + 1), StructureFlags), info());
 778     }
 779 
 780     static DOMJITFunctionObject* create(VM&amp; vm, JSGlobalObject* globalObject, Structure* structure)
 781     {
 782         DOMJITFunctionObject* object = new (NotNull, allocateCell&lt;DOMJITFunctionObject&gt;(vm.heap, sizeof(DOMJITFunctionObject))) DOMJITFunctionObject(vm, structure);
 783         object-&gt;finishCreation(vm, globalObject);
 784         return object;
 785     }
 786 
 787     static EncodedJSValue JSC_HOST_CALL safeFunction(ExecState* exec)
 788     {
 789         VM&amp; vm = exec-&gt;vm();
 790         auto scope = DECLARE_THROW_SCOPE(vm);
 791 
 792         DOMJITNode* thisObject = jsDynamicCast&lt;DOMJITNode*&gt;(vm, exec-&gt;thisValue());
 793         if (!thisObject)
 794             return throwVMTypeError(exec, scope);
 795         return JSValue::encode(jsNumber(thisObject-&gt;value()));
 796     }
 797 
 798     static EncodedJSValue JIT_OPERATION unsafeFunction(ExecState* exec, DOMJITNode* node)
 799     {
 800         VM&amp; vm = exec-&gt;vm();
 801         NativeCallFrameTracer tracer(&amp;vm, exec);
 802         return JSValue::encode(jsNumber(node-&gt;value()));
 803     }
 804 
 805 #if ENABLE(JIT)
 806     static Ref&lt;Snippet&gt; checkSubClassSnippet()
 807     {
 808         Ref&lt;Snippet&gt; snippet = Snippet::create();
 809         snippet-&gt;numFPScratchRegisters = 1;
 810         snippet-&gt;setGenerator([=](CCallHelpers&amp; jit, SnippetParams&amp; params) {
 811             static const double value = 42.0;
 812             CCallHelpers::JumpList failureCases;
 813             // May use scratch registers.
 814             jit.loadDouble(CCallHelpers::TrustedImmPtr(&amp;value), params.fpScratch(0));
 815             failureCases.append(jit.branchIfNotType(params[0].gpr(), JSC::JSType(LastJSCObjectType + 1)));
 816             return failureCases;
 817         });
 818         return snippet;
 819     }
 820 #endif
 821 
 822 private:
 823     void finishCreation(VM&amp;, JSGlobalObject*);
 824 };
 825 
 826 static const DOMJIT::Signature DOMJITFunctionObjectSignature((uintptr_t)DOMJITFunctionObject::unsafeFunction, DOMJITFunctionObject::info(), DOMJIT::Effect::forRead(DOMJIT::HeapRange::top()), SpecInt32Only);
 827 
 828 void DOMJITFunctionObject::finishCreation(VM&amp; vm, JSGlobalObject* globalObject)
 829 {
 830     Base::finishCreation(vm);
 831     putDirectNativeFunction(vm, globalObject, Identifier::fromString(&amp;vm, &quot;func&quot;), 0, safeFunction, NoIntrinsic, &amp;DOMJITFunctionObjectSignature, static_cast&lt;unsigned&gt;(PropertyAttribute::ReadOnly));
 832 }
 833 
 834 class DOMJITCheckSubClassObject : public DOMJITNode {
 835 public:
 836     DOMJITCheckSubClassObject(VM&amp; vm, Structure* structure)
 837         : Base(vm, structure)
 838     {
 839     }
 840 
 841     DECLARE_INFO;
 842     typedef DOMJITNode Base;
 843     static const unsigned StructureFlags = Base::StructureFlags;
 844 
 845 
 846     static Structure* createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
 847     {
 848         return Structure::create(vm, globalObject, prototype, TypeInfo(JSC::JSType(LastJSCObjectType + 1), StructureFlags), info());
 849     }
 850 
 851     static DOMJITCheckSubClassObject* create(VM&amp; vm, JSGlobalObject* globalObject, Structure* structure)
 852     {
 853         DOMJITCheckSubClassObject* object = new (NotNull, allocateCell&lt;DOMJITCheckSubClassObject&gt;(vm.heap, sizeof(DOMJITCheckSubClassObject))) DOMJITCheckSubClassObject(vm, structure);
 854         object-&gt;finishCreation(vm, globalObject);
 855         return object;
 856     }
 857 
 858     static EncodedJSValue JSC_HOST_CALL safeFunction(ExecState* exec)
 859     {
 860         VM&amp; vm = exec-&gt;vm();
 861         auto scope = DECLARE_THROW_SCOPE(vm);
 862 
 863         auto* thisObject = jsDynamicCast&lt;DOMJITCheckSubClassObject*&gt;(vm, exec-&gt;thisValue());
 864         if (!thisObject)
 865             return throwVMTypeError(exec, scope);
 866         return JSValue::encode(jsNumber(thisObject-&gt;value()));
 867     }
 868 
 869     static EncodedJSValue JIT_OPERATION unsafeFunction(ExecState* exec, DOMJITNode* node)
 870     {
 871         VM&amp; vm = exec-&gt;vm();
 872         NativeCallFrameTracer tracer(&amp;vm, exec);
 873         return JSValue::encode(jsNumber(node-&gt;value()));
 874     }
 875 
 876 private:
 877     void finishCreation(VM&amp;, JSGlobalObject*);
 878 };
 879 
 880 static const DOMJIT::Signature DOMJITCheckSubClassObjectSignature((uintptr_t)DOMJITCheckSubClassObject::unsafeFunction, DOMJITCheckSubClassObject::info(), DOMJIT::Effect::forRead(DOMJIT::HeapRange::top()), SpecInt32Only);
 881 
 882 void DOMJITCheckSubClassObject::finishCreation(VM&amp; vm, JSGlobalObject* globalObject)
 883 {
 884     Base::finishCreation(vm);
 885     putDirectNativeFunction(vm, globalObject, Identifier::fromString(&amp;vm, &quot;func&quot;), 0, safeFunction, NoIntrinsic, &amp;DOMJITCheckSubClassObjectSignature, static_cast&lt;unsigned&gt;(PropertyAttribute::ReadOnly));
 886 }
 887 
 888 class DOMJITGetterBaseJSObject : public DOMJITNode {
 889 public:
 890     DOMJITGetterBaseJSObject(VM&amp; vm, Structure* structure)
 891         : Base(vm, structure)
 892     {
 893     }
 894 
 895     DECLARE_INFO;
 896     using Base = DOMJITNode;
 897     static const unsigned StructureFlags = Base::StructureFlags;
 898 
 899     static Structure* createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
 900     {
 901         return Structure::create(vm, globalObject, prototype, TypeInfo(JSC::JSType(LastJSCObjectType + 1), StructureFlags), info());
 902     }
 903 
 904     static DOMJITGetterBaseJSObject* create(VM&amp; vm, Structure* structure)
 905     {
 906         DOMJITGetterBaseJSObject* getter = new (NotNull, allocateCell&lt;DOMJITGetterBaseJSObject&gt;(vm.heap, sizeof(DOMJITGetterBaseJSObject))) DOMJITGetterBaseJSObject(vm, structure);
 907         getter-&gt;finishCreation(vm);
 908         return getter;
 909     }
 910 
 911     class DOMJITAttribute : public DOMJIT::GetterSetter {
 912     public:
 913         constexpr DOMJITAttribute()
 914             : DOMJIT::GetterSetter(
 915                 DOMJITGetterBaseJSObject::customGetter,
 916 #if ENABLE(JIT)
 917                 &amp;callDOMGetter,
 918 #else
 919                 nullptr,
 920 #endif
 921                 SpecBytecodeTop)
 922         {
 923         }
 924 
 925 #if ENABLE(JIT)
 926         static EncodedJSValue JIT_OPERATION slowCall(ExecState* exec, void* pointer)
 927         {
 928             VM&amp; vm = exec-&gt;vm();
 929             NativeCallFrameTracer tracer(&amp;vm, exec);
 930             JSObject* object = static_cast&lt;JSObject*&gt;(pointer);
 931             return JSValue::encode(object-&gt;getPrototypeDirect(vm));
 932         }
 933 
 934         static Ref&lt;DOMJIT::CallDOMGetterSnippet&gt; callDOMGetter()
 935         {
 936             Ref&lt;DOMJIT::CallDOMGetterSnippet&gt; snippet = DOMJIT::CallDOMGetterSnippet::create();
 937             snippet-&gt;requireGlobalObject = false;
 938             snippet-&gt;setGenerator([=](CCallHelpers&amp; jit, SnippetParams&amp; params) {
 939                 JSValueRegs results = params[0].jsValueRegs();
 940                 GPRReg dom = params[1].gpr();
 941                 params.addSlowPathCall(jit.jump(), jit, slowCall, results, dom);
 942                 return CCallHelpers::JumpList();
 943 
 944             });
 945             return snippet;
 946         }
 947 #endif
 948     };
 949 
 950 private:
 951     void finishCreation(VM&amp;);
 952 
 953     static EncodedJSValue customGetter(ExecState* exec, EncodedJSValue thisValue, PropertyName)
 954     {
 955         VM&amp; vm = exec-&gt;vm();
 956         JSObject* thisObject = jsDynamicCast&lt;JSObject*&gt;(vm, JSValue::decode(thisValue));
 957         RELEASE_ASSERT(thisObject);
 958         return JSValue::encode(thisObject-&gt;getPrototypeDirect(vm));
 959     }
 960 };
 961 
 962 static const DOMJITGetterBaseJSObject::DOMJITAttribute DOMJITGetterBaseJSObjectDOMJIT;
 963 
 964 void DOMJITGetterBaseJSObject::finishCreation(VM&amp; vm)
 965 {
 966     Base::finishCreation(vm);
 967     const DOMJIT::GetterSetter* domJIT = &amp;DOMJITGetterBaseJSObjectDOMJIT;
 968     auto* customGetterSetter = DOMAttributeGetterSetter::create(vm, domJIT-&gt;getter(), nullptr, DOMAttributeAnnotation { JSObject::info(), domJIT });
 969     putDirectCustomAccessor(vm, Identifier::fromString(&amp;vm, &quot;customGetter&quot;), customGetterSetter, PropertyAttribute::ReadOnly | PropertyAttribute::CustomAccessor);
 970 }
 971 
 972 class Message : public ThreadSafeRefCounted&lt;Message&gt; {
 973 public:
 974     Message(ArrayBufferContents&amp;&amp;, int32_t);
 975     ~Message();
 976 
 977     ArrayBufferContents&amp;&amp; releaseContents() { return WTFMove(m_contents); }
 978     int32_t index() const { return m_index; }
 979 
 980 private:
 981     ArrayBufferContents m_contents;
 982     int32_t m_index { 0 };
 983 };
 984 
 985 class JSTestCustomGetterSetter : public JSNonFinalObject {
 986 public:
 987     using Base = JSNonFinalObject;
 988     static const unsigned StructureFlags = Base::StructureFlags;
 989 
 990     JSTestCustomGetterSetter(VM&amp; vm, Structure* structure)
 991         : Base(vm, structure)
 992     { }
 993 
 994     static JSTestCustomGetterSetter* create(VM&amp; vm, JSGlobalObject*, Structure* structure)
 995     {
 996         JSTestCustomGetterSetter* result = new (NotNull, allocateCell&lt;JSTestCustomGetterSetter&gt;(vm.heap, sizeof(JSTestCustomGetterSetter))) JSTestCustomGetterSetter(vm, structure);
 997         result-&gt;finishCreation(vm);
 998         return result;
 999     }
1000 
1001     void finishCreation(VM&amp;);
1002 
1003     static Structure* createStructure(VM&amp; vm, JSGlobalObject* globalObject)
1004     {
1005         return Structure::create(vm, globalObject, globalObject-&gt;objectPrototype(), TypeInfo(ObjectType, StructureFlags), info());
1006     }
1007 
1008     DECLARE_INFO;
1009 };
1010 
1011 
1012 static EncodedJSValue customGetAccessor(ExecState*, EncodedJSValue thisValue, PropertyName)
1013 {
1014     // Passed |this|
1015     return thisValue;
1016 }
1017 
1018 static EncodedJSValue customGetValue(ExecState* exec, EncodedJSValue slotValue, PropertyName)
1019 {
1020     RELEASE_ASSERT(JSValue::decode(slotValue).inherits&lt;JSTestCustomGetterSetter&gt;(exec-&gt;vm()));
1021     // Passed property holder.
1022     return slotValue;
1023 }
1024 
1025 static bool customSetAccessor(ExecState* exec, EncodedJSValue thisObject, EncodedJSValue encodedValue)
1026 {
1027     VM&amp; vm = exec-&gt;vm();
1028 
1029     JSValue value = JSValue::decode(encodedValue);
1030     RELEASE_ASSERT(value.isObject());
1031     JSObject* object = asObject(value);
1032     PutPropertySlot slot(object);
1033     object-&gt;put(object, exec, Identifier::fromString(&amp;vm, &quot;result&quot;), JSValue::decode(thisObject), slot);
1034 
1035     return true;
1036 }
1037 
1038 static bool customSetValue(ExecState* exec, EncodedJSValue slotValue, EncodedJSValue encodedValue)
1039 {
1040     VM&amp; vm = exec-&gt;vm();
1041 
1042     RELEASE_ASSERT(JSValue::decode(slotValue).inherits&lt;JSTestCustomGetterSetter&gt;(exec-&gt;vm()));
1043 
1044     JSValue value = JSValue::decode(encodedValue);
1045     RELEASE_ASSERT(value.isObject());
1046     JSObject* object = asObject(value);
1047     PutPropertySlot slot(object);
1048     object-&gt;put(object, exec, Identifier::fromString(&amp;vm, &quot;result&quot;), JSValue::decode(slotValue), slot);
1049 
1050     return true;
1051 }
1052 
1053 void JSTestCustomGetterSetter::finishCreation(VM&amp; vm)
1054 {
1055     Base::finishCreation(vm);
1056 
1057     putDirectCustomAccessor(vm, Identifier::fromString(&amp;vm, &quot;customValue&quot;),
1058         CustomGetterSetter::create(vm, customGetValue, customSetValue), 0);
1059     putDirectCustomAccessor(vm, Identifier::fromString(&amp;vm, &quot;customAccessor&quot;),
1060         CustomGetterSetter::create(vm, customGetAccessor, customSetAccessor), static_cast&lt;unsigned&gt;(PropertyAttribute::CustomAccessor));
1061 }
1062 
1063 const ClassInfo Element::s_info = { &quot;Element&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(Element) };
1064 const ClassInfo Root::s_info = { &quot;Root&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(Root) };
1065 const ClassInfo SimpleObject::s_info = { &quot;SimpleObject&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(SimpleObject) };
1066 const ClassInfo ImpureGetter::s_info = { &quot;ImpureGetter&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(ImpureGetter) };
1067 const ClassInfo CustomGetter::s_info = { &quot;CustomGetter&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(CustomGetter) };
1068 const ClassInfo RuntimeArray::s_info = { &quot;RuntimeArray&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(RuntimeArray) };
1069 #if ENABLE(JIT)
1070 const ClassInfo DOMJITNode::s_info = { &quot;DOMJITNode&quot;, &amp;Base::s_info, nullptr, &amp;DOMJITNode::checkSubClassSnippet, CREATE_METHOD_TABLE(DOMJITNode) };
1071 #else
1072 const ClassInfo DOMJITNode::s_info = { &quot;DOMJITNode&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(DOMJITNode) };
1073 #endif
1074 const ClassInfo DOMJITGetter::s_info = { &quot;DOMJITGetter&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(DOMJITGetter) };
1075 const ClassInfo DOMJITGetterComplex::s_info = { &quot;DOMJITGetterComplex&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(DOMJITGetterComplex) };
1076 const ClassInfo DOMJITGetterBaseJSObject::s_info = { &quot;DOMJITGetterBaseJSObject&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(DOMJITGetterBaseJSObject) };
1077 #if ENABLE(JIT)
1078 const ClassInfo DOMJITFunctionObject::s_info = { &quot;DOMJITFunctionObject&quot;, &amp;Base::s_info, nullptr, &amp;DOMJITFunctionObject::checkSubClassSnippet, CREATE_METHOD_TABLE(DOMJITFunctionObject) };
1079 #else
1080 const ClassInfo DOMJITFunctionObject::s_info = { &quot;DOMJITFunctionObject&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(DOMJITFunctionObject) };
1081 #endif
1082 const ClassInfo DOMJITCheckSubClassObject::s_info = { &quot;DOMJITCheckSubClassObject&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(DOMJITCheckSubClassObject) };
1083 const ClassInfo JSTestCustomGetterSetter::s_info = { &quot;JSTestCustomGetterSetter&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSTestCustomGetterSetter) };
1084 
1085 ElementHandleOwner* Element::handleOwner()
1086 {
1087     static ElementHandleOwner* owner = 0;
1088     if (!owner)
1089         owner = new ElementHandleOwner();
1090     return owner;
1091 }
1092 
1093 void Element::finishCreation(VM&amp; vm, Root* root)
1094 {
1095     Base::finishCreation(vm);
1096     setRoot(vm, root);
1097     m_root-&gt;setElement(this);
1098 }
1099 
1100 #if ENABLE(WEBASSEMBLY)
1101 
1102 static EncodedJSValue JSC_HOST_CALL functionWasmStreamingParserAddBytes(ExecState*);
1103 static EncodedJSValue JSC_HOST_CALL functionWasmStreamingParserFinalize(ExecState*);
1104 
1105 class WasmStreamingParser : public JSDestructibleObject {
1106 public:
1107     WasmStreamingParser(VM&amp; vm, Structure* structure)
1108         : Base(vm, structure)
1109         , m_info(Wasm::ModuleInformation::create())
1110         , m_streamingParser(m_info.get())
1111     {
1112     }
1113 
1114     using Base = JSDestructibleObject;
1115 
1116     static WasmStreamingParser* create(VM&amp; vm, JSGlobalObject* globalObject)
1117     {
1118         Structure* structure = createStructure(vm, globalObject, jsNull());
1119         WasmStreamingParser* result = new (NotNull, allocateCell&lt;WasmStreamingParser&gt;(vm.heap, sizeof(WasmStreamingParser))) WasmStreamingParser(vm, structure);
1120         result-&gt;finishCreation(vm);
1121         return result;
1122     }
1123 
1124     static Structure* createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
1125     {
1126         return Structure::create(vm, globalObject, prototype, TypeInfo(ObjectType, StructureFlags), info());
1127     }
1128 
1129     Wasm::StreamingParser&amp; streamingParser() { return m_streamingParser; }
1130 
1131     void finishCreation(VM&amp; vm)
1132     {
1133         Base::finishCreation(vm);
1134 
1135         JSGlobalObject* globalObject = this-&gt;globalObject(vm);
1136         putDirectNativeFunction(vm, globalObject, Identifier::fromString(&amp;vm, &quot;addBytes&quot;), 0, functionWasmStreamingParserAddBytes, NoIntrinsic, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
1137         putDirectNativeFunction(vm, globalObject, Identifier::fromString(&amp;vm, &quot;finalize&quot;), 0, functionWasmStreamingParserFinalize, NoIntrinsic, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
1138     }
1139 
1140     DECLARE_INFO;
1141 
1142     Ref&lt;Wasm::ModuleInformation&gt; m_info;
1143     Wasm::StreamingParser m_streamingParser;
1144 };
1145 
1146 const ClassInfo WasmStreamingParser::s_info = { &quot;WasmStreamingParser&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(WasmStreamingParser) };
1147 
1148 EncodedJSValue JSC_HOST_CALL functionWasmStreamingParserAddBytes(ExecState* exec)
1149 {
1150     VM&amp; vm = exec-&gt;vm();
1151     auto scope = DECLARE_THROW_SCOPE(exec-&gt;vm());
1152     auto* thisObject = jsDynamicCast&lt;WasmStreamingParser*&gt;(vm, exec-&gt;thisValue());
1153     if (!thisObject)
1154         RELEASE_AND_RETURN(scope, JSValue::encode(jsBoolean(false)));
1155 
1156     auto data = getWasmBufferFromValue(exec, exec-&gt;argument(0));
1157     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1158     RELEASE_AND_RETURN(scope, JSValue::encode(jsNumber(static_cast&lt;int32_t&gt;(thisObject-&gt;streamingParser().addBytes(bitwise_cast&lt;const uint8_t*&gt;(data.first), data.second)))));
1159 }
1160 
1161 EncodedJSValue JSC_HOST_CALL functionWasmStreamingParserFinalize(ExecState* exec)
1162 {
1163     VM&amp; vm = exec-&gt;vm();
1164     auto* thisObject = jsDynamicCast&lt;WasmStreamingParser*&gt;(vm, exec-&gt;thisValue());
1165     if (!thisObject)
1166         return JSValue::encode(jsBoolean(false));
1167     return JSValue::encode(jsNumber(static_cast&lt;int32_t&gt;(thisObject-&gt;streamingParser().finalize())));
1168 }
1169 
1170 #endif
1171 
1172 } // namespace
1173 
1174 namespace JSC {
1175 
1176 const ClassInfo JSDollarVM::s_info = { &quot;DollarVM&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSDollarVM) };
1177 
1178 // Triggers a crash immediately.
1179 // Usage: $vm.crash()
1180 static NO_RETURN_DUE_TO_CRASH EncodedJSValue JSC_HOST_CALL functionCrash(ExecState*)
1181 {
1182     CRASH();
1183 }
1184 
1185 // Executes a breakpoint instruction if the first argument is truthy or is unset.
1186 // Usage: $vm.breakpoint(&lt;condition&gt;)
1187 static EncodedJSValue JSC_HOST_CALL functionBreakpoint(ExecState* exec)
1188 {
1189     // Nothing should throw here but we might as well double check...
1190     VM&amp; vm = exec-&gt;vm();
1191     auto scope = DECLARE_CATCH_SCOPE(vm);
1192     UNUSED_PARAM(scope);
1193     if (!exec-&gt;argumentCount() || exec-&gt;argument(0).toBoolean(exec))
1194         WTFBreakpointTrap();
1195 
1196     return encodedJSUndefined();
1197 }
1198 
1199 // Returns true if the current frame is a DFG frame.
1200 // Usage: isDFG = $vm.dfgTrue()
1201 static EncodedJSValue JSC_HOST_CALL functionDFGTrue(ExecState*)
1202 {
1203     return JSValue::encode(jsBoolean(false));
1204 }
1205 
1206 // Returns true if the current frame is a FTL frame.
1207 // Usage: isFTL = $vm.ftlTrue()
1208 static EncodedJSValue JSC_HOST_CALL functionFTLTrue(ExecState*)
1209 {
1210     return JSValue::encode(jsBoolean(false));
1211 }
1212 
1213 static EncodedJSValue JSC_HOST_CALL functionCpuMfence(ExecState*)
1214 {
1215 #if CPU(X86_64) &amp;&amp; !OS(WINDOWS)
1216     asm volatile(&quot;mfence&quot; ::: &quot;memory&quot;);
1217 #endif
1218     return JSValue::encode(jsUndefined());
1219 }
1220 
1221 static EncodedJSValue JSC_HOST_CALL functionCpuRdtsc(ExecState*)
1222 {
1223 #if CPU(X86_64) &amp;&amp; !OS(WINDOWS)
1224     unsigned high;
1225     unsigned low;
1226     asm volatile (&quot;rdtsc&quot; : &quot;=a&quot;(low), &quot;=d&quot;(high));
1227     return JSValue::encode(jsNumber(low));
1228 #else
1229     return JSValue::encode(jsNumber(0));
1230 #endif
1231 }
1232 
1233 static EncodedJSValue JSC_HOST_CALL functionCpuCpuid(ExecState*)
1234 {
1235 #if CPU(X86_64) &amp;&amp; !OS(WINDOWS)
1236     WTF::x86_cpuid();
1237 #endif
1238     return JSValue::encode(jsUndefined());
1239 }
1240 
1241 static EncodedJSValue JSC_HOST_CALL functionCpuPause(ExecState*)
1242 {
1243 #if CPU(X86_64) &amp;&amp; !OS(WINDOWS)
1244     asm volatile (&quot;pause&quot; ::: &quot;memory&quot;);
1245 #endif
1246     return JSValue::encode(jsUndefined());
1247 }
1248 
1249 // This takes either a JSArrayBuffer, JSArrayBufferView*, or any other object as its first
1250 // argument. The second argument is expected to be an integer.
1251 //
1252 // If the first argument is a JSArrayBuffer, it&#39;ll clflush on that buffer
1253 // plus the second argument as a byte offset. It&#39;ll also flush on the object
1254 // itself so its length, etc, aren&#39;t in the cache.
1255 //
1256 // If the first argument is not a JSArrayBuffer, we load the butterfly
1257 // and clflush at the address of the butterfly.
1258 static EncodedJSValue JSC_HOST_CALL functionCpuClflush(ExecState* exec)
1259 {
1260 #if CPU(X86_64) &amp;&amp; !OS(WINDOWS)
1261     VM&amp; vm = exec-&gt;vm();
1262 
1263     if (!exec-&gt;argument(1).isInt32())
1264         return JSValue::encode(jsBoolean(false));
1265 
1266     auto clflush = [] (void* ptr) {
1267         char* ptrToFlush = static_cast&lt;char*&gt;(ptr);
1268         asm volatile (&quot;clflush %0&quot; :: &quot;m&quot;(*ptrToFlush) : &quot;memory&quot;);
1269     };
1270 
1271     Vector&lt;void*&gt; toFlush;
1272 
1273     uint32_t offset = exec-&gt;argument(1).asUInt32();
1274 
1275     if (JSArrayBufferView* view = jsDynamicCast&lt;JSArrayBufferView*&gt;(vm, exec-&gt;argument(0)))
1276         toFlush.append(bitwise_cast&lt;char*&gt;(view-&gt;vector()) + offset);
1277     else if (JSObject* object = jsDynamicCast&lt;JSObject*&gt;(vm, exec-&gt;argument(0))) {
1278         switch (object-&gt;indexingType()) {
1279         case ALL_INT32_INDEXING_TYPES:
1280         case ALL_CONTIGUOUS_INDEXING_TYPES:
1281         case ALL_DOUBLE_INDEXING_TYPES:
1282             toFlush.append(bitwise_cast&lt;char*&gt;(object-&gt;butterfly()) + Butterfly::offsetOfVectorLength());
1283             toFlush.append(bitwise_cast&lt;char*&gt;(object-&gt;butterfly()) + Butterfly::offsetOfPublicLength());
1284         }
1285     }
1286 
1287     if (!toFlush.size())
1288         return JSValue::encode(jsBoolean(false));
1289 
1290     for (void* ptr : toFlush)
1291         clflush(ptr);
1292     return JSValue::encode(jsBoolean(true));
1293 #else
1294     UNUSED_PARAM(exec);
1295     return JSValue::encode(jsBoolean(false));
1296 #endif
1297 }
1298 
1299 class CallerFrameJITTypeFunctor {
1300 public:
1301     CallerFrameJITTypeFunctor()
1302         : m_currentFrame(0)
1303         , m_jitType(JITCode::None)
1304     {
1305     }
1306 
1307     StackVisitor::Status operator()(StackVisitor&amp; visitor) const
1308     {
1309         if (m_currentFrame++ &gt; 1) {
1310             m_jitType = visitor-&gt;codeBlock()-&gt;jitType();
1311             return StackVisitor::Done;
1312         }
1313         return StackVisitor::Continue;
1314     }
1315 
1316     JITCode::JITType jitType() { return m_jitType; }
1317 
1318 private:
1319     mutable unsigned m_currentFrame;
1320     mutable JITCode::JITType m_jitType;
1321 };
1322 
1323 static FunctionExecutable* getExecutableForFunction(JSValue theFunctionValue)
1324 {
1325     if (!theFunctionValue.isCell())
1326         return nullptr;
1327 
1328     VM&amp; vm = *theFunctionValue.asCell()-&gt;vm();
1329     JSFunction* theFunction = jsDynamicCast&lt;JSFunction*&gt;(vm, theFunctionValue);
1330     if (!theFunction)
1331         return nullptr;
1332 
1333     FunctionExecutable* executable = jsDynamicCast&lt;FunctionExecutable*&gt;(vm,
1334         theFunction-&gt;executable());
1335 
1336     return executable;
1337 }
1338 
1339 // Returns true if the current frame is a LLInt frame.
1340 // Usage: isLLInt = $vm.llintTrue()
1341 static EncodedJSValue JSC_HOST_CALL functionLLintTrue(ExecState* exec)
1342 {
1343     if (!exec)
1344         return JSValue::encode(jsUndefined());
1345     CallerFrameJITTypeFunctor functor;
1346     exec-&gt;iterate(functor);
1347     return JSValue::encode(jsBoolean(functor.jitType() == JITCode::InterpreterThunk));
1348 }
1349 
1350 // Returns true if the current frame is a baseline JIT frame.
1351 // Usage: isBaselineJIT = $vm.jitTrue()
1352 static EncodedJSValue JSC_HOST_CALL functionJITTrue(ExecState* exec)
1353 {
1354     if (!exec)
1355         return JSValue::encode(jsUndefined());
1356     CallerFrameJITTypeFunctor functor;
1357     exec-&gt;iterate(functor);
1358     return JSValue::encode(jsBoolean(functor.jitType() == JITCode::BaselineJIT));
1359 }
1360 
1361 // Set that the argument function should not be inlined.
1362 // Usage:
1363 // function f() { };
1364 // $vm.noInline(f);
1365 static EncodedJSValue JSC_HOST_CALL functionNoInline(ExecState* exec)
1366 {
1367     if (exec-&gt;argumentCount() &lt; 1)
1368         return JSValue::encode(jsUndefined());
1369 
1370     JSValue theFunctionValue = exec-&gt;uncheckedArgument(0);
1371 
1372     if (FunctionExecutable* executable = getExecutableForFunction(theFunctionValue))
1373         executable-&gt;setNeverInline(true);
1374 
1375     return JSValue::encode(jsUndefined());
1376 }
1377 
1378 // Runs a full GC synchronously.
1379 // Usage: $vm.gc()
1380 static EncodedJSValue JSC_HOST_CALL functionGC(ExecState* exec)
1381 {
1382     VMInspector::gc(exec);
1383     return JSValue::encode(jsUndefined());
1384 }
1385 
1386 // Runs the edenGC synchronously.
1387 // Usage: $vm.edenGC()
1388 static EncodedJSValue JSC_HOST_CALL functionEdenGC(ExecState* exec)
1389 {
1390     VMInspector::edenGC(exec);
1391     return JSValue::encode(jsUndefined());
1392 }
1393 
1394 // Gets a JSDollarVMCallFrame for a specified frame index.
1395 // Usage: var callFrame = $vm.callFrame(0) // frame 0 is the top frame.
1396 // Usage: var callFrame = $vm.callFrame() // implies frame 0 i.e. current frame.
1397 //
1398 // This gives you the ability to query the following:
1399 //    callFrame.valid; // false if we asked for a frame beyond the end of the stack, else true.
1400 //    callFrame.callee;
1401 //    callFrame.codeBlock;
1402 //    callFrame.unlinkedCodeBlock;
1403 //    callFrame.executable;
1404 //
1405 // Note: you cannot toString() a codeBlock, unlinkedCodeBlock, or executable because
1406 // there are internal objects and not a JS object. Hence, you cannot do string
1407 // concatenation with them.
1408 static EncodedJSValue JSC_HOST_CALL functionCallFrame(ExecState* exec)
1409 {
1410     unsigned frameNumber = 1;
1411     if (exec-&gt;argumentCount() &gt;= 1) {
1412         JSValue value = exec-&gt;uncheckedArgument(0);
1413         if (!value.isUInt32())
1414             return JSValue::encode(jsUndefined());
1415 
1416         // We need to inc the frame number because the caller would consider
1417         // its own frame as frame 0. Hence, we need discount the frame for this
1418         // function.
1419         frameNumber = value.asUInt32() + 1;
1420     }
1421 
1422     return JSValue::encode(JSDollarVMCallFrame::create(exec, frameNumber));
1423 }
1424 
1425 // Gets a token for the CodeBlock for a specified frame index.
1426 // Usage: codeBlockToken = $vm.codeBlockForFrame(0) // frame 0 is the top frame.
1427 // Usage: codeBlockToken = $vm.codeBlockForFrame() // implies frame 0 i.e. current frame.
1428 static EncodedJSValue JSC_HOST_CALL functionCodeBlockForFrame(ExecState* exec)
1429 {
1430     unsigned frameNumber = 1;
1431     if (exec-&gt;argumentCount() &gt;= 1) {
1432         JSValue value = exec-&gt;uncheckedArgument(0);
1433         if (!value.isUInt32())
1434             return JSValue::encode(jsUndefined());
1435 
1436         // We need to inc the frame number because the caller would consider
1437         // its own frame as frame 0. Hence, we need discount the frame for this
1438         // function.
1439         frameNumber = value.asUInt32() + 1;
1440     }
1441 
1442     CodeBlock* codeBlock = VMInspector::codeBlockForFrame(exec, frameNumber);
1443     if (codeBlock)
1444         return JSValue::encode(codeBlock);
1445     return JSValue::encode(jsUndefined());
1446 }
1447 
1448 static CodeBlock* codeBlockFromArg(ExecState* exec)
1449 {
1450     VM&amp; vm = exec-&gt;vm();
1451     if (exec-&gt;argumentCount() &lt; 1)
1452         return nullptr;
1453 
1454     JSValue value = exec-&gt;uncheckedArgument(0);
1455     CodeBlock* candidateCodeBlock = nullptr;
1456     if (value.isCell()) {
1457         JSFunction* func = jsDynamicCast&lt;JSFunction*&gt;(vm, value.asCell());
1458         if (func) {
1459             if (func-&gt;isHostFunction())
1460                 candidateCodeBlock = nullptr;
1461             else
1462                 candidateCodeBlock = func-&gt;jsExecutable()-&gt;eitherCodeBlock();
1463         } else
1464             candidateCodeBlock = static_cast&lt;CodeBlock*&gt;(value.asCell());
1465     }
1466 
1467     if (candidateCodeBlock &amp;&amp; VMInspector::isValidCodeBlock(exec, candidateCodeBlock))
1468         return candidateCodeBlock;
1469 
1470     if (candidateCodeBlock)
1471         dataLog(&quot;Invalid codeBlock: &quot;, RawPointer(candidateCodeBlock), &quot; &quot;, value, &quot;\n&quot;);
1472     else
1473         dataLog(&quot;Invalid codeBlock: &quot;, value, &quot;\n&quot;);
1474     return nullptr;
1475 }
1476 
1477 // Usage: $vm.print(&quot;codeblock = &quot;, $vm.codeBlockFor(functionObj))
1478 // Usage: $vm.print(&quot;codeblock = &quot;, $vm.codeBlockFor(codeBlockToken))
1479 // Note: you cannot toString() a codeBlock because it&#39;s an internal object and not
1480 // a JS object. Hence, you cannot do string concatenation with it.
1481 static EncodedJSValue JSC_HOST_CALL functionCodeBlockFor(ExecState* exec)
1482 {
1483     CodeBlock* codeBlock = codeBlockFromArg(exec);
1484     WTF::StringPrintStream stream;
1485     if (codeBlock) {
1486         stream.print(*codeBlock);
1487         return JSValue::encode(jsString(exec, stream.toString()));
1488     }
1489     return JSValue::encode(jsUndefined());
1490 }
1491 
1492 // Usage: $vm.dumpSourceFor(functionObj)
1493 // Usage: $vm.dumpSourceFor(codeBlockToken)
1494 static EncodedJSValue JSC_HOST_CALL functionDumpSourceFor(ExecState* exec)
1495 {
1496     CodeBlock* codeBlock = codeBlockFromArg(exec);
1497     if (codeBlock)
1498         codeBlock-&gt;dumpSource();
1499     return JSValue::encode(jsUndefined());
1500 }
1501 
1502 // Usage: $vm.dumpBytecodeFor(functionObj)
1503 // Usage: $vm.dumpBytecodeFor(codeBlock)
1504 static EncodedJSValue JSC_HOST_CALL functionDumpBytecodeFor(ExecState* exec)
1505 {
1506     CodeBlock* codeBlock = codeBlockFromArg(exec);
1507     if (codeBlock)
1508         codeBlock-&gt;dumpBytecode();
1509     return JSValue::encode(jsUndefined());
1510 }
1511 
1512 static EncodedJSValue doPrint(ExecState* exec, bool addLineFeed)
1513 {
1514     auto scope = DECLARE_THROW_SCOPE(exec-&gt;vm());
1515     for (unsigned i = 0; i &lt; exec-&gt;argumentCount(); ++i) {
1516         JSValue arg = exec-&gt;uncheckedArgument(i);
1517         if (arg.isCell()
1518             &amp;&amp; !arg.isObject()
1519             &amp;&amp; !arg.isString()
1520             &amp;&amp; !arg.isBigInt()) {
1521             dataLog(arg);
1522             continue;
1523         }
1524         String argStr = exec-&gt;uncheckedArgument(i).toWTFString(exec);
1525         RETURN_IF_EXCEPTION(scope, encodedJSValue());
1526         dataLog(argStr);
1527     }
1528     if (addLineFeed)
1529         dataLog(&quot;\n&quot;);
1530     return JSValue::encode(jsUndefined());
1531 }
1532 
1533 // Prints a series of comma separate strings without appending a newline.
1534 // Usage: $vm.dataLog(str1, str2, str3)
1535 static EncodedJSValue JSC_HOST_CALL functionDataLog(ExecState* exec)
1536 {
1537     const bool addLineFeed = false;
1538     return doPrint(exec, addLineFeed);
1539 }
1540 
1541 // Prints a series of comma separate strings and appends a newline.
1542 // Usage: $vm.print(str1, str2, str3)
1543 static EncodedJSValue JSC_HOST_CALL functionPrint(ExecState* exec)
1544 {
1545     const bool addLineFeed = true;
1546     return doPrint(exec, addLineFeed);
1547 }
1548 
1549 // Dumps the current CallFrame.
1550 // Usage: $vm.dumpCallFrame()
1551 static EncodedJSValue JSC_HOST_CALL functionDumpCallFrame(ExecState* exec)
1552 {
1553     // When the callers call this function, they are expecting to dump their
1554     // own frame. So skip 1 for this frame.
1555     VMInspector::dumpCallFrame(exec, 1);
1556     return JSValue::encode(jsUndefined());
1557 }
1558 
1559 // Dumps the JS stack.
1560 // Usage: $vm.printStack()
1561 static EncodedJSValue JSC_HOST_CALL functionDumpStack(ExecState* exec)
1562 {
1563     // When the callers call this function, they are expecting to dump the
1564     // stack starting their own frame. So skip 1 for this frame.
1565     VMInspector::dumpStack(exec, 1);
1566     return JSValue::encode(jsUndefined());
1567 }
1568 
1569 // Dumps the current CallFrame.
1570 // Usage: $vm.dumpRegisters(N) // dump the registers of the Nth CallFrame.
1571 // Usage: $vm.dumpRegisters() // dump the registers of the current CallFrame.
1572 // FIXME: Currently, this function dumps the physical frame. We should make
1573 // it dump the logical frame (i.e. be able to dump inlined frames as well).
1574 static EncodedJSValue JSC_HOST_CALL functionDumpRegisters(ExecState* exec)
1575 {
1576     unsigned requestedFrameIndex = 1;
1577     if (exec-&gt;argumentCount() &gt;= 1) {
1578         JSValue value = exec-&gt;uncheckedArgument(0);
1579         if (!value.isUInt32())
1580             return JSValue::encode(jsUndefined());
1581 
1582         // We need to inc the frame number because the caller would consider
1583         // its own frame as frame 0. Hence, we need discount the frame for this
1584         // function.
1585         requestedFrameIndex = value.asUInt32() + 1;
1586     }
1587 
1588     unsigned frameIndex = 0;
1589     exec-&gt;iterate([&amp;] (StackVisitor&amp; visitor) {
1590         if (frameIndex++ != requestedFrameIndex)
1591             return StackVisitor::Continue;
1592         VMInspector::dumpRegisters(visitor-&gt;callFrame());
1593         return StackVisitor::Done;
1594     });
1595 
1596     return encodedJSUndefined();
1597 }
1598 
1599 // Dumps the internal memory layout of a JSCell.
1600 // Usage: $vm.dumpCell(cell)
1601 static EncodedJSValue JSC_HOST_CALL functionDumpCell(ExecState* exec)
1602 {
1603     JSValue value = exec-&gt;argument(0);
1604     if (!value.isCell())
1605         return encodedJSUndefined();
1606 
1607     VMInspector::dumpCellMemory(value.asCell());
1608     return encodedJSUndefined();
1609 }
1610 
1611 // Gets the dataLog dump of the indexingMode of the passed value.
1612 // Usage: $vm.print(&quot;indexingMode = &quot; + $vm.indexingMode(jsValue))
1613 static EncodedJSValue JSC_HOST_CALL functionIndexingMode(ExecState* exec)
1614 {
1615     if (!exec-&gt;argument(0).isObject())
1616         return encodedJSUndefined();
1617 
1618     WTF::StringPrintStream stream;
1619     stream.print(IndexingTypeDump(exec-&gt;uncheckedArgument(0).getObject()-&gt;indexingMode()));
1620     return JSValue::encode(jsString(exec, stream.toString()));
1621 }
1622 
1623 static EncodedJSValue JSC_HOST_CALL functionInlineCapacity(ExecState* exec)
1624 {
1625     VM&amp; vm = exec-&gt;vm();
1626     if (auto* object = jsDynamicCast&lt;JSObject*&gt;(vm, exec-&gt;argument(0)))
1627         return JSValue::encode(jsNumber(object-&gt;structure(vm)-&gt;inlineCapacity()));
1628 
1629     return encodedJSUndefined();
1630 }
1631 
1632 // Gets the dataLog dump of a given JS value as a string.
1633 // Usage: $vm.print(&quot;value = &quot; + $vm.value(jsValue))
1634 static EncodedJSValue JSC_HOST_CALL functionValue(ExecState* exec)
1635 {
1636     WTF::StringPrintStream stream;
1637     for (unsigned i = 0; i &lt; exec-&gt;argumentCount(); ++i) {
1638         if (i)
1639             stream.print(&quot;, &quot;);
1640         stream.print(exec-&gt;uncheckedArgument(i));
1641     }
1642 
1643     return JSValue::encode(jsString(exec, stream.toString()));
1644 }
1645 
1646 // Gets the pid of the current process.
1647 // Usage: $vm.print(&quot;pid = &quot; + $vm.getpid())
1648 static EncodedJSValue JSC_HOST_CALL functionGetPID(ExecState*)
1649 {
1650     return JSValue::encode(jsNumber(getCurrentProcessID()));
1651 }
1652 
1653 // Make the globalObject have a bad time. Does nothing if the object is not a JSGlobalObject.
1654 // Usage: $vm.haveABadTime(globalObject)
1655 static EncodedJSValue JSC_HOST_CALL functionHaveABadTime(ExecState* exec)
1656 {
1657     VM&amp; vm = exec-&gt;vm();
1658     JSLockHolder lock(vm);
1659     JSValue objValue = exec-&gt;argument(0);
1660     if (!objValue.isObject())
1661         return JSValue::encode(jsBoolean(false));
1662 
1663     JSObject* obj = asObject(objValue.asCell());
1664     JSGlobalObject* globalObject = jsDynamicCast&lt;JSGlobalObject*&gt;(vm, obj);
1665     if (!globalObject)
1666         JSValue::encode(jsBoolean(false));
1667 
1668     globalObject-&gt;haveABadTime(vm);
1669     return JSValue::encode(jsBoolean(true));
1670 }
1671 
1672 // Checks if the object (or its global if the object is not a global) is having a bad time.
1673 // Usage: $vm.isHavingABadTime(obj)
1674 static EncodedJSValue JSC_HOST_CALL functionIsHavingABadTime(ExecState* exec)
1675 {
1676     VM&amp; vm = exec-&gt;vm();
1677     JSLockHolder lock(vm);
1678     JSValue objValue = exec-&gt;argument(0);
1679     if (!objValue.isObject())
1680         return JSValue::encode(jsUndefined());
1681 
1682     JSObject* obj = asObject(objValue.asCell());
1683     JSGlobalObject* globalObject = jsDynamicCast&lt;JSGlobalObject*&gt;(vm, obj);
1684     if (globalObject)
1685         JSValue::encode(jsBoolean(globalObject-&gt;isHavingABadTime()));
1686 
1687     globalObject = obj-&gt;globalObject();
1688     if (!globalObject)
1689         return JSValue::encode(jsUndefined());
1690 
1691     return JSValue::encode(jsBoolean(globalObject-&gt;isHavingABadTime()));
1692 }
1693 
1694 // Creates a new global object.
1695 // Usage: $vm.createGlobalObject()
1696 static EncodedJSValue JSC_HOST_CALL functionCreateGlobalObject(ExecState* exec)
1697 {
1698     VM&amp; vm = exec-&gt;vm();
1699     JSLockHolder lock(vm);
1700     JSGlobalObject* globalObject = JSGlobalObject::create(vm, JSGlobalObject::createStructure(vm, jsNull()));
1701     return JSValue::encode(globalObject);
1702 }
1703 
1704 static EncodedJSValue JSC_HOST_CALL functionCreateProxy(ExecState* exec)
1705 {
1706     VM&amp; vm = exec-&gt;vm();
1707     JSLockHolder lock(vm);
1708     JSValue target = exec-&gt;argument(0);
1709     if (!target.isObject())
1710         return JSValue::encode(jsUndefined());
1711     JSObject* jsTarget = asObject(target.asCell());
1712     Structure* structure = JSProxy::createStructure(vm, exec-&gt;lexicalGlobalObject(), jsTarget-&gt;getPrototypeDirect(vm), ImpureProxyType);
1713     JSProxy* proxy = JSProxy::create(vm, structure, jsTarget);
1714     return JSValue::encode(proxy);
1715 }
1716 
1717 static EncodedJSValue JSC_HOST_CALL functionCreateRuntimeArray(ExecState* exec)
1718 {
1719     JSLockHolder lock(exec);
1720     RuntimeArray* array = RuntimeArray::create(exec);
1721     return JSValue::encode(array);
1722 }
1723 
1724 static EncodedJSValue JSC_HOST_CALL functionCreateImpureGetter(ExecState* exec)
1725 {
1726     VM&amp; vm = exec-&gt;vm();
1727     JSLockHolder lock(vm);
1728     JSValue target = exec-&gt;argument(0);
1729     JSObject* delegate = nullptr;
1730     if (target.isObject())
1731         delegate = asObject(target.asCell());
1732     Structure* structure = ImpureGetter::createStructure(vm, exec-&gt;lexicalGlobalObject(), jsNull());
1733     ImpureGetter* result = ImpureGetter::create(vm, structure, delegate);
1734     return JSValue::encode(result);
1735 }
1736 
1737 static EncodedJSValue JSC_HOST_CALL functionCreateCustomGetterObject(ExecState* exec)
1738 {
1739     VM&amp; vm = exec-&gt;vm();
1740     JSLockHolder lock(vm);
1741     Structure* structure = CustomGetter::createStructure(vm, exec-&gt;lexicalGlobalObject(), jsNull());
1742     CustomGetter* result = CustomGetter::create(vm, structure);
1743     return JSValue::encode(result);
1744 }
1745 
1746 static EncodedJSValue JSC_HOST_CALL functionCreateDOMJITNodeObject(ExecState* exec)
1747 {
1748     VM&amp; vm = exec-&gt;vm();
1749     JSLockHolder lock(vm);
1750     Structure* structure = DOMJITNode::createStructure(vm, exec-&gt;lexicalGlobalObject(), DOMJITGetter::create(vm, DOMJITGetter::createStructure(vm, exec-&gt;lexicalGlobalObject(), jsNull())));
1751     DOMJITNode* result = DOMJITNode::create(vm, structure);
1752     return JSValue::encode(result);
1753 }
1754 
1755 static EncodedJSValue JSC_HOST_CALL functionCreateDOMJITGetterObject(ExecState* exec)
1756 {
1757     VM&amp; vm = exec-&gt;vm();
1758     JSLockHolder lock(vm);
1759     Structure* structure = DOMJITGetter::createStructure(vm, exec-&gt;lexicalGlobalObject(), jsNull());
1760     DOMJITGetter* result = DOMJITGetter::create(vm, structure);
1761     return JSValue::encode(result);
1762 }
1763 
1764 static EncodedJSValue JSC_HOST_CALL functionCreateDOMJITGetterComplexObject(ExecState* exec)
1765 {
1766     VM&amp; vm = exec-&gt;vm();
1767     JSLockHolder lock(vm);
1768     Structure* structure = DOMJITGetterComplex::createStructure(vm, exec-&gt;lexicalGlobalObject(), jsNull());
1769     DOMJITGetterComplex* result = DOMJITGetterComplex::create(vm, exec-&gt;lexicalGlobalObject(), structure);
1770     return JSValue::encode(result);
1771 }
1772 
1773 static EncodedJSValue JSC_HOST_CALL functionCreateDOMJITFunctionObject(ExecState* exec)
1774 {
1775     VM&amp; vm = exec-&gt;vm();
1776     JSLockHolder lock(vm);
1777     Structure* structure = DOMJITFunctionObject::createStructure(vm, exec-&gt;lexicalGlobalObject(), jsNull());
1778     DOMJITFunctionObject* result = DOMJITFunctionObject::create(vm, exec-&gt;lexicalGlobalObject(), structure);
1779     return JSValue::encode(result);
1780 }
1781 
1782 static EncodedJSValue JSC_HOST_CALL functionCreateDOMJITCheckSubClassObject(ExecState* exec)
1783 {
1784     VM&amp; vm = exec-&gt;vm();
1785     JSLockHolder lock(vm);
1786     Structure* structure = DOMJITCheckSubClassObject::createStructure(vm, exec-&gt;lexicalGlobalObject(), jsNull());
1787     DOMJITCheckSubClassObject* result = DOMJITCheckSubClassObject::create(vm, exec-&gt;lexicalGlobalObject(), structure);
1788     return JSValue::encode(result);
1789 }
1790 
1791 static EncodedJSValue JSC_HOST_CALL functionCreateDOMJITGetterBaseJSObject(ExecState* exec)
1792 {
1793     VM&amp; vm = exec-&gt;vm();
1794     JSLockHolder lock(vm);
1795     Structure* structure = DOMJITGetterBaseJSObject::createStructure(vm, exec-&gt;lexicalGlobalObject(), jsNull());
1796     DOMJITGetterBaseJSObject* result = DOMJITGetterBaseJSObject::create(vm, structure);
1797     return JSValue::encode(result);
1798 }
1799 
1800 #if ENABLE(WEBASSEMBLY)
1801 static EncodedJSValue JSC_HOST_CALL functionCreateWasmStreamingParser(ExecState* exec)
1802 {
1803     VM&amp; vm = exec-&gt;vm();
1804     JSLockHolder lock(vm);
1805     return JSValue::encode(WasmStreamingParser::create(vm, exec-&gt;lexicalGlobalObject()));
1806 }
1807 #endif
1808 
1809 static EncodedJSValue JSC_HOST_CALL functionSetImpureGetterDelegate(ExecState* exec)
1810 {
1811     VM&amp; vm = exec-&gt;vm();
1812     JSLockHolder lock(vm);
1813     auto scope = DECLARE_THROW_SCOPE(vm);
1814 
1815     JSValue base = exec-&gt;argument(0);
1816     if (!base.isObject())
1817         return JSValue::encode(jsUndefined());
1818     JSValue delegate = exec-&gt;argument(1);
1819     if (!delegate.isObject())
1820         return JSValue::encode(jsUndefined());
1821     ImpureGetter* impureGetter = jsDynamicCast&lt;ImpureGetter*&gt;(vm, asObject(base.asCell()));
1822     if (UNLIKELY(!impureGetter)) {
1823         throwTypeError(exec, scope, &quot;argument is not an ImpureGetter&quot;_s);
1824         return encodedJSValue();
1825     }
1826     impureGetter-&gt;setDelegate(vm, asObject(delegate.asCell()));
1827     return JSValue::encode(jsUndefined());
1828 }
1829 
1830 static EncodedJSValue JSC_HOST_CALL functionCreateBuiltin(ExecState* exec)
1831 {
1832     VM&amp; vm = exec-&gt;vm();
1833     auto scope = DECLARE_THROW_SCOPE(vm);
1834 
1835     if (exec-&gt;argumentCount() &lt; 1 || !exec-&gt;argument(0).isString())
1836         return JSValue::encode(jsUndefined());
1837 
1838     String functionText = asString(exec-&gt;argument(0))-&gt;value(exec);
1839     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1840 
1841     const SourceCode&amp; source = makeSource(functionText, { });
1842     JSFunction* func = JSFunction::create(vm, createBuiltinExecutable(vm, source, Identifier::fromString(&amp;vm, &quot;foo&quot;), ConstructorKind::None, ConstructAbility::CannotConstruct)-&gt;link(vm, source), exec-&gt;lexicalGlobalObject());
1843 
1844     return JSValue::encode(func);
1845 }
1846 
1847 static EncodedJSValue JSC_HOST_CALL functionGetPrivateProperty(ExecState* exec)
1848 {
1849     VM&amp; vm = exec-&gt;vm();
1850     auto scope = DECLARE_THROW_SCOPE(vm);
1851 
1852     if (exec-&gt;argumentCount() &lt; 2 || !exec-&gt;argument(1).isString())
1853         return encodedJSUndefined();
1854 
1855     String str = asString(exec-&gt;argument(1))-&gt;value(exec);
1856 
1857     SymbolImpl* symbol = vm.propertyNames-&gt;lookUpPrivateName(Identifier::fromString(exec, str));
1858     if (!symbol)
1859         return throwVMError(exec, scope, &quot;Unknown private name.&quot;);
1860 
1861     RELEASE_AND_RETURN(scope, JSValue::encode(exec-&gt;argument(0).get(exec, symbol)));
1862 }
1863 
1864 static EncodedJSValue JSC_HOST_CALL functionCreateRoot(ExecState* exec)
1865 {
1866     VM&amp; vm = exec-&gt;vm();
1867     JSLockHolder lock(vm);
1868     return JSValue::encode(Root::create(vm, exec-&gt;lexicalGlobalObject()));
1869 }
1870 
1871 static EncodedJSValue JSC_HOST_CALL functionCreateElement(ExecState* exec)
1872 {
1873     VM&amp; vm = exec-&gt;vm();
1874     JSLockHolder lock(vm);
1875     auto scope = DECLARE_THROW_SCOPE(vm);
1876 
1877     Root* root = jsDynamicCast&lt;Root*&gt;(vm, exec-&gt;argument(0));
1878     if (!root)
1879         return JSValue::encode(throwException(exec, scope, createError(exec, &quot;Cannot create Element without a Root.&quot;_s)));
1880     return JSValue::encode(Element::create(vm, exec-&gt;lexicalGlobalObject(), root));
1881 }
1882 
1883 static EncodedJSValue JSC_HOST_CALL functionGetElement(ExecState* exec)
1884 {
1885     VM&amp; vm = exec-&gt;vm();
1886     JSLockHolder lock(vm);
1887     Root* root = jsDynamicCast&lt;Root*&gt;(vm, exec-&gt;argument(0));
1888     if (!root)
1889         return JSValue::encode(jsUndefined());
1890     Element* result = root-&gt;element();
1891     return JSValue::encode(result ? result : jsUndefined());
1892 }
1893 
1894 static EncodedJSValue JSC_HOST_CALL functionCreateSimpleObject(ExecState* exec)
1895 {
1896     VM&amp; vm = exec-&gt;vm();
1897     JSLockHolder lock(vm);
1898     return JSValue::encode(SimpleObject::create(vm, exec-&gt;lexicalGlobalObject()));
1899 }
1900 
1901 static EncodedJSValue JSC_HOST_CALL functionGetHiddenValue(ExecState* exec)
1902 {
1903     VM&amp; vm = exec-&gt;vm();
1904     JSLockHolder lock(vm);
1905     auto scope = DECLARE_THROW_SCOPE(vm);
1906 
1907     SimpleObject* simpleObject = jsDynamicCast&lt;SimpleObject*&gt;(vm, exec-&gt;argument(0));
1908     if (UNLIKELY(!simpleObject)) {
1909         throwTypeError(exec, scope, &quot;Invalid use of getHiddenValue test function&quot;_s);
1910         return encodedJSValue();
1911     }
1912     return JSValue::encode(simpleObject-&gt;hiddenValue());
1913 }
1914 
1915 static EncodedJSValue JSC_HOST_CALL functionSetHiddenValue(ExecState* exec)
1916 {
1917     VM&amp; vm = exec-&gt;vm();
1918     JSLockHolder lock(vm);
1919     auto scope = DECLARE_THROW_SCOPE(vm);
1920 
1921     SimpleObject* simpleObject = jsDynamicCast&lt;SimpleObject*&gt;(vm, exec-&gt;argument(0));
1922     if (UNLIKELY(!simpleObject)) {
1923         throwTypeError(exec, scope, &quot;Invalid use of setHiddenValue test function&quot;_s);
1924         return encodedJSValue();
1925     }
1926     JSValue value = exec-&gt;argument(1);
1927     simpleObject-&gt;setHiddenValue(vm, value);
1928     return JSValue::encode(jsUndefined());
1929 }
1930 
1931 static EncodedJSValue JSC_HOST_CALL functionShadowChickenFunctionsOnStack(ExecState* exec)
1932 {
1933     VM&amp; vm = exec-&gt;vm();
1934     auto scope = DECLARE_THROW_SCOPE(vm);
1935     if (auto* shadowChicken = vm.shadowChicken()) {
1936         scope.release();
1937         return JSValue::encode(shadowChicken-&gt;functionsOnStack(exec));
1938     }
1939 
1940     JSArray* result = constructEmptyArray(exec, 0);
1941     RETURN_IF_EXCEPTION(scope, { });
1942     StackVisitor::visit(exec, &amp;vm, [&amp;] (StackVisitor&amp; visitor) -&gt; StackVisitor::Status {
1943         if (visitor-&gt;isInlinedFrame())
1944             return StackVisitor::Continue;
1945         if (visitor-&gt;isWasmFrame())
1946             return StackVisitor::Continue;
1947         result-&gt;push(exec, jsCast&lt;JSObject*&gt;(visitor-&gt;callee().asCell()));
1948         scope.releaseAssertNoException(); // This function is only called from tests.
1949         return StackVisitor::Continue;
1950     });
1951     RETURN_IF_EXCEPTION(scope, { });
1952     return JSValue::encode(result);
1953 }
1954 
1955 static EncodedJSValue JSC_HOST_CALL functionSetGlobalConstRedeclarationShouldNotThrow(ExecState* exec)
1956 {
1957     VM&amp; vm = exec-&gt;vm();
1958     vm.setGlobalConstRedeclarationShouldThrow(false);
1959     return JSValue::encode(jsUndefined());
1960 }
1961 
1962 static EncodedJSValue JSC_HOST_CALL functionFindTypeForExpression(ExecState* exec)
1963 {
1964     VM&amp; vm = exec-&gt;vm();
1965     RELEASE_ASSERT(vm.typeProfiler());
1966     vm.typeProfilerLog()-&gt;processLogEntries(vm, &quot;jsc Testing API: functionFindTypeForExpression&quot;_s);
1967 
1968     JSValue functionValue = exec-&gt;argument(0);
1969     RELEASE_ASSERT(functionValue.isFunction(vm));
1970     FunctionExecutable* executable = (jsDynamicCast&lt;JSFunction*&gt;(vm, functionValue.asCell()-&gt;getObject()))-&gt;jsExecutable();
1971 
1972     RELEASE_ASSERT(exec-&gt;argument(1).isString());
1973     String substring = asString(exec-&gt;argument(1))-&gt;value(exec);
1974     String sourceCodeText = executable-&gt;source().view().toString();
1975     unsigned offset = static_cast&lt;unsigned&gt;(sourceCodeText.find(substring) + executable-&gt;source().startOffset());
1976 
1977     String jsonString = vm.typeProfiler()-&gt;typeInformationForExpressionAtOffset(TypeProfilerSearchDescriptorNormal, offset, executable-&gt;sourceID(), vm);
1978     return JSValue::encode(JSONParse(exec, jsonString));
1979 }
1980 
1981 static EncodedJSValue JSC_HOST_CALL functionReturnTypeFor(ExecState* exec)
1982 {
1983     VM&amp; vm = exec-&gt;vm();
1984     RELEASE_ASSERT(vm.typeProfiler());
1985     vm.typeProfilerLog()-&gt;processLogEntries(vm, &quot;jsc Testing API: functionReturnTypeFor&quot;_s);
1986 
1987     JSValue functionValue = exec-&gt;argument(0);
1988     RELEASE_ASSERT(functionValue.isFunction(vm));
1989     FunctionExecutable* executable = (jsDynamicCast&lt;JSFunction*&gt;(vm, functionValue.asCell()-&gt;getObject()))-&gt;jsExecutable();
1990 
1991     unsigned offset = executable-&gt;typeProfilingStartOffset(vm);
1992     String jsonString = vm.typeProfiler()-&gt;typeInformationForExpressionAtOffset(TypeProfilerSearchDescriptorFunctionReturn, offset, executable-&gt;sourceID(), vm);
1993     return JSValue::encode(JSONParse(exec, jsonString));
1994 }
1995 
1996 static EncodedJSValue JSC_HOST_CALL functionFlattenDictionaryObject(ExecState* exec)
1997 {
1998     VM&amp; vm = exec-&gt;vm();
1999     JSValue value = exec-&gt;argument(0);
2000     RELEASE_ASSERT(value.isObject() &amp;&amp; value.getObject()-&gt;structure()-&gt;isDictionary());
2001     value.getObject()-&gt;flattenDictionaryObject(vm);
2002     return encodedJSUndefined();
2003 }
2004 
2005 static EncodedJSValue JSC_HOST_CALL functionDumpBasicBlockExecutionRanges(ExecState* exec)
2006 {
2007     VM&amp; vm = exec-&gt;vm();
2008     RELEASE_ASSERT(vm.controlFlowProfiler());
2009     vm.controlFlowProfiler()-&gt;dumpData();
2010     return JSValue::encode(jsUndefined());
2011 }
2012 
2013 static EncodedJSValue JSC_HOST_CALL functionHasBasicBlockExecuted(ExecState* exec)
2014 {
2015     VM&amp; vm = exec-&gt;vm();
2016     RELEASE_ASSERT(vm.controlFlowProfiler());
2017 
2018     JSValue functionValue = exec-&gt;argument(0);
2019     RELEASE_ASSERT(functionValue.isFunction(vm));
2020     FunctionExecutable* executable = (jsDynamicCast&lt;JSFunction*&gt;(vm, functionValue.asCell()-&gt;getObject()))-&gt;jsExecutable();
2021 
2022     RELEASE_ASSERT(exec-&gt;argument(1).isString());
2023     String substring = asString(exec-&gt;argument(1))-&gt;value(exec);
2024     String sourceCodeText = executable-&gt;source().view().toString();
2025     RELEASE_ASSERT(sourceCodeText.contains(substring));
2026     int offset = sourceCodeText.find(substring) + executable-&gt;source().startOffset();
2027 
2028     bool hasExecuted = vm.controlFlowProfiler()-&gt;hasBasicBlockAtTextOffsetBeenExecuted(offset, executable-&gt;sourceID(), vm);
2029     return JSValue::encode(jsBoolean(hasExecuted));
2030 }
2031 
2032 static EncodedJSValue JSC_HOST_CALL functionBasicBlockExecutionCount(ExecState* exec)
2033 {
2034     VM&amp; vm = exec-&gt;vm();
2035     RELEASE_ASSERT(vm.controlFlowProfiler());
2036 
2037     JSValue functionValue = exec-&gt;argument(0);
2038     RELEASE_ASSERT(functionValue.isFunction(vm));
2039     FunctionExecutable* executable = (jsDynamicCast&lt;JSFunction*&gt;(vm, functionValue.asCell()-&gt;getObject()))-&gt;jsExecutable();
2040 
2041     RELEASE_ASSERT(exec-&gt;argument(1).isString());
2042     String substring = asString(exec-&gt;argument(1))-&gt;value(exec);
2043     String sourceCodeText = executable-&gt;source().view().toString();
2044     RELEASE_ASSERT(sourceCodeText.contains(substring));
2045     int offset = sourceCodeText.find(substring) + executable-&gt;source().startOffset();
2046 
2047     size_t executionCount = vm.controlFlowProfiler()-&gt;basicBlockExecutionCountAtTextOffset(offset, executable-&gt;sourceID(), vm);
2048     return JSValue::encode(JSValue(executionCount));
2049 }
2050 
2051 static EncodedJSValue JSC_HOST_CALL functionEnableExceptionFuzz(ExecState*)
2052 {
2053     Options::useExceptionFuzz() = true;
2054     return JSValue::encode(jsUndefined());
2055 }
2056 
2057 static EncodedJSValue changeDebuggerModeWhenIdle(ExecState* exec, DebuggerMode mode)
2058 {
2059     bool newDebuggerMode = (mode == DebuggerOn);
2060     if (Options::forceDebuggerBytecodeGeneration() == newDebuggerMode)
2061         return JSValue::encode(jsUndefined());
2062 
2063     VM* vm = &amp;exec-&gt;vm();
2064     vm-&gt;whenIdle([=] () {
2065         Options::forceDebuggerBytecodeGeneration() = newDebuggerMode;
2066         vm-&gt;deleteAllCode(PreventCollectionAndDeleteAllCode);
2067         if (mode == DebuggerMode::DebuggerOn)
2068             vm-&gt;ensureShadowChicken();
2069     });
2070     return JSValue::encode(jsUndefined());
2071 }
2072 
2073 static EncodedJSValue JSC_HOST_CALL functionEnableDebuggerModeWhenIdle(ExecState* exec)
2074 {
2075     return changeDebuggerModeWhenIdle(exec, DebuggerOn);
2076 }
2077 
2078 static EncodedJSValue JSC_HOST_CALL functionDisableDebuggerModeWhenIdle(ExecState* exec)
2079 {
2080     return changeDebuggerModeWhenIdle(exec, DebuggerOff);
2081 }
2082 
2083 static EncodedJSValue JSC_HOST_CALL functionGlobalObjectCount(ExecState* exec)
2084 {
2085     return JSValue::encode(jsNumber(exec-&gt;vm().heap.globalObjectCount()));
2086 }
2087 
2088 static EncodedJSValue JSC_HOST_CALL functionGlobalObjectForObject(ExecState* exec)
2089 {
2090     JSValue value = exec-&gt;argument(0);
2091     RELEASE_ASSERT(value.isObject());
2092     JSGlobalObject* globalObject = jsCast&lt;JSObject*&gt;(value)-&gt;globalObject(exec-&gt;vm());
2093     RELEASE_ASSERT(globalObject);
2094     return JSValue::encode(globalObject);
2095 }
2096 
2097 static EncodedJSValue JSC_HOST_CALL functionGetGetterSetter(ExecState* exec)
2098 {
2099     JSValue value = exec-&gt;argument(0);
2100     if (!value.isObject())
2101         return JSValue::encode(jsUndefined());
2102 
2103     JSValue property = exec-&gt;argument(1);
2104     if (!property.isString())
2105         return JSValue::encode(jsUndefined());
2106 
2107     PropertySlot slot(value, PropertySlot::InternalMethodType::VMInquiry);
2108     value.getPropertySlot(exec, asString(property)-&gt;toIdentifier(exec), slot);
2109 
2110     JSValue result;
2111     if (slot.isCacheableGetter())
2112         result = slot.getterSetter();
2113     else
2114         result = jsNull();
2115 
2116     return JSValue::encode(result);
2117 }
2118 
2119 static EncodedJSValue JSC_HOST_CALL functionLoadGetterFromGetterSetter(ExecState* exec)
2120 {
2121     VM&amp; vm = exec-&gt;vm();
2122     auto scope = DECLARE_THROW_SCOPE(vm);
2123 
2124     GetterSetter* getterSetter = jsDynamicCast&lt;GetterSetter*&gt;(vm, exec-&gt;argument(0));
2125     if (UNLIKELY(!getterSetter)) {
2126         throwTypeError(exec, scope, &quot;Invalid use of loadGetterFromGetterSetter test function: argument is not a GetterSetter&quot;_s);
2127         return encodedJSValue();
2128     }
2129 
2130     JSObject* getter = getterSetter-&gt;getter();
2131     RELEASE_ASSERT(getter);
2132     return JSValue::encode(getter);
2133 }
2134 
2135 static EncodedJSValue JSC_HOST_CALL functionCreateCustomTestGetterSetter(ExecState* exec)
2136 {
2137     VM&amp; vm = exec-&gt;vm();
2138     JSGlobalObject* globalObject = exec-&gt;lexicalGlobalObject();
2139     return JSValue::encode(JSTestCustomGetterSetter::create(vm, globalObject, JSTestCustomGetterSetter::createStructure(vm, globalObject)));
2140 }
2141 
2142 static EncodedJSValue JSC_HOST_CALL functionDeltaBetweenButterflies(ExecState* exec)
2143 {
2144     VM&amp; vm = exec-&gt;vm();
2145     JSObject* a = jsDynamicCast&lt;JSObject*&gt;(vm, exec-&gt;argument(0));
2146     JSObject* b = jsDynamicCast&lt;JSObject*&gt;(vm, exec-&gt;argument(1));
2147     if (!a || !b)
2148         return JSValue::encode(jsNumber(PNaN));
2149 
2150     ptrdiff_t delta = bitwise_cast&lt;char*&gt;(a-&gt;butterfly()) - bitwise_cast&lt;char*&gt;(b-&gt;butterfly());
2151     if (delta &lt; 0)
2152         return JSValue::encode(jsNumber(PNaN));
2153     if (delta &gt; std::numeric_limits&lt;int32_t&gt;::max())
2154         return JSValue::encode(jsNumber(PNaN));
2155     return JSValue::encode(jsNumber(static_cast&lt;int32_t&gt;(delta)));
2156 }
2157 
2158 static EncodedJSValue JSC_HOST_CALL functionTotalGCTime(ExecState* exec)
2159 {
2160     VM&amp; vm = exec-&gt;vm();
2161     return JSValue::encode(jsNumber(vm.heap.totalGCTime().seconds()));
2162 }
2163 
2164 void JSDollarVM::finishCreation(VM&amp; vm)
2165 {
2166     Base::finishCreation(vm);
2167 
2168     JSGlobalObject* globalObject = this-&gt;globalObject(vm);
2169 
2170     auto addFunction = [&amp;] (VM&amp; vm, const char* name, NativeFunction function, unsigned arguments) {
2171         JSDollarVM::addFunction(vm, globalObject, name, function, arguments);
2172     };
2173     auto addConstructibleFunction = [&amp;] (VM&amp; vm, const char* name, NativeFunction function, unsigned arguments) {
2174         JSDollarVM::addConstructibleFunction(vm, globalObject, name, function, arguments);
2175     };
2176 
2177     addFunction(vm, &quot;abort&quot;, functionCrash, 0);
2178     addFunction(vm, &quot;crash&quot;, functionCrash, 0);
2179     addFunction(vm, &quot;breakpoint&quot;, functionBreakpoint, 0);
2180 
2181     putDirectNativeFunction(vm, globalObject, Identifier::fromString(&amp;vm, &quot;dfgTrue&quot;), 0, functionDFGTrue, DFGTrueIntrinsic, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
2182     putDirectNativeFunction(vm, globalObject, Identifier::fromString(&amp;vm, &quot;ftlTrue&quot;), 0, functionFTLTrue, FTLTrueIntrinsic, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
2183 
2184     putDirectNativeFunction(vm, globalObject, Identifier::fromString(&amp;vm, &quot;cpuMfence&quot;), 0, functionCpuMfence, CPUMfenceIntrinsic, 0);
2185     putDirectNativeFunction(vm, globalObject, Identifier::fromString(&amp;vm, &quot;cpuRdtsc&quot;), 0, functionCpuRdtsc, CPURdtscIntrinsic, 0);
2186     putDirectNativeFunction(vm, globalObject, Identifier::fromString(&amp;vm, &quot;cpuCpuid&quot;), 0, functionCpuCpuid, CPUCpuidIntrinsic, 0);
2187     putDirectNativeFunction(vm, globalObject, Identifier::fromString(&amp;vm, &quot;cpuPause&quot;), 0, functionCpuPause, CPUPauseIntrinsic, 0);
2188     addFunction(vm, &quot;cpuClflush&quot;, functionCpuClflush, 2);
2189 
2190     addFunction(vm, &quot;llintTrue&quot;, functionLLintTrue, 0);
2191     addFunction(vm, &quot;jitTrue&quot;, functionJITTrue, 0);
2192 
2193     addFunction(vm, &quot;noInline&quot;, functionNoInline, 1);
2194 
2195     addFunction(vm, &quot;gc&quot;, functionGC, 0);
2196     addFunction(vm, &quot;edenGC&quot;, functionEdenGC, 0);
2197 
2198     addFunction(vm, &quot;callFrame&quot;, functionCallFrame, 1);
2199     addFunction(vm, &quot;codeBlockFor&quot;, functionCodeBlockFor, 1);
2200     addFunction(vm, &quot;codeBlockForFrame&quot;, functionCodeBlockForFrame, 1);
2201     addFunction(vm, &quot;dumpSourceFor&quot;, functionDumpSourceFor, 1);
2202     addFunction(vm, &quot;dumpBytecodeFor&quot;, functionDumpBytecodeFor, 1);
2203 
2204     addFunction(vm, &quot;dataLog&quot;, functionDataLog, 1);
2205     addFunction(vm, &quot;print&quot;, functionPrint, 1);
2206     addFunction(vm, &quot;dumpCallFrame&quot;, functionDumpCallFrame, 0);
2207     addFunction(vm, &quot;dumpStack&quot;, functionDumpStack, 0);
2208     addFunction(vm, &quot;dumpRegisters&quot;, functionDumpRegisters, 1);
2209 
2210     addFunction(vm, &quot;dumpCell&quot;, functionDumpCell, 1);
2211 
2212     addFunction(vm, &quot;indexingMode&quot;, functionIndexingMode, 1);
2213     addFunction(vm, &quot;inlineCapacity&quot;, functionInlineCapacity, 1);
2214     addFunction(vm, &quot;value&quot;, functionValue, 1);
2215     addFunction(vm, &quot;getpid&quot;, functionGetPID, 0);
2216 
2217     addFunction(vm, &quot;haveABadTime&quot;, functionHaveABadTime, 1);
2218     addFunction(vm, &quot;isHavingABadTime&quot;, functionIsHavingABadTime, 1);
2219 
2220     addFunction(vm, &quot;createGlobalObject&quot;, functionCreateGlobalObject, 0);
2221     addFunction(vm, &quot;createProxy&quot;, functionCreateProxy, 1);
2222     addFunction(vm, &quot;createRuntimeArray&quot;, functionCreateRuntimeArray, 0);
2223 
2224     addFunction(vm, &quot;createImpureGetter&quot;, functionCreateImpureGetter, 1);
2225     addFunction(vm, &quot;createCustomGetterObject&quot;, functionCreateCustomGetterObject, 0);
2226     addFunction(vm, &quot;createDOMJITNodeObject&quot;, functionCreateDOMJITNodeObject, 0);
2227     addFunction(vm, &quot;createDOMJITGetterObject&quot;, functionCreateDOMJITGetterObject, 0);
2228     addFunction(vm, &quot;createDOMJITGetterComplexObject&quot;, functionCreateDOMJITGetterComplexObject, 0);
2229     addFunction(vm, &quot;createDOMJITFunctionObject&quot;, functionCreateDOMJITFunctionObject, 0);
2230     addFunction(vm, &quot;createDOMJITCheckSubClassObject&quot;, functionCreateDOMJITCheckSubClassObject, 0);
2231     addFunction(vm, &quot;createDOMJITGetterBaseJSObject&quot;, functionCreateDOMJITGetterBaseJSObject, 0);
2232     addFunction(vm, &quot;createBuiltin&quot;, functionCreateBuiltin, 2);
2233 #if ENABLE(WEBASSEMBLY)
2234     addFunction(vm, &quot;createWasmStreamingParser&quot;, functionCreateWasmStreamingParser, 0);
2235 #endif
2236     addFunction(vm, &quot;getPrivateProperty&quot;, functionGetPrivateProperty, 2);
2237     addFunction(vm, &quot;setImpureGetterDelegate&quot;, functionSetImpureGetterDelegate, 2);
2238 
2239     addConstructibleFunction(vm, &quot;Root&quot;, functionCreateRoot, 0);
2240     addConstructibleFunction(vm, &quot;Element&quot;, functionCreateElement, 1);
2241     addFunction(vm, &quot;getElement&quot;, functionGetElement, 1);
2242 
2243     addConstructibleFunction(vm, &quot;SimpleObject&quot;, functionCreateSimpleObject, 0);
2244     addFunction(vm, &quot;getHiddenValue&quot;, functionGetHiddenValue, 1);
2245     addFunction(vm, &quot;setHiddenValue&quot;, functionSetHiddenValue, 2);
2246 
2247     addFunction(vm, &quot;shadowChickenFunctionsOnStack&quot;, functionShadowChickenFunctionsOnStack, 0);
2248     addFunction(vm, &quot;setGlobalConstRedeclarationShouldNotThrow&quot;, functionSetGlobalConstRedeclarationShouldNotThrow, 0);
2249 
2250     addFunction(vm, &quot;findTypeForExpression&quot;, functionFindTypeForExpression, 2);
2251     addFunction(vm, &quot;returnTypeFor&quot;, functionReturnTypeFor, 1);
2252 
2253     addFunction(vm, &quot;flattenDictionaryObject&quot;, functionFlattenDictionaryObject, 1);
2254 
2255     addFunction(vm, &quot;dumpBasicBlockExecutionRanges&quot;, functionDumpBasicBlockExecutionRanges , 0);
2256     addFunction(vm, &quot;hasBasicBlockExecuted&quot;, functionHasBasicBlockExecuted, 2);
2257     addFunction(vm, &quot;basicBlockExecutionCount&quot;, functionBasicBlockExecutionCount, 2);
2258 
2259     addFunction(vm, &quot;enableExceptionFuzz&quot;, functionEnableExceptionFuzz, 0);
2260 
2261     addFunction(vm, &quot;enableDebuggerModeWhenIdle&quot;, functionEnableDebuggerModeWhenIdle, 0);
2262     addFunction(vm, &quot;disableDebuggerModeWhenIdle&quot;, functionDisableDebuggerModeWhenIdle, 0);
2263 
2264     addFunction(vm, &quot;globalObjectCount&quot;, functionGlobalObjectCount, 0);
2265     addFunction(vm, &quot;globalObjectForObject&quot;, functionGlobalObjectForObject, 1);
2266 
2267     addFunction(vm, &quot;getGetterSetter&quot;, functionGetGetterSetter, 2);
2268     addFunction(vm, &quot;loadGetterFromGetterSetter&quot;, functionLoadGetterFromGetterSetter, 1);
2269     addFunction(vm, &quot;createCustomTestGetterSetter&quot;, functionCreateCustomTestGetterSetter, 1);
2270 
2271     addFunction(vm, &quot;deltaBetweenButterflies&quot;, functionDeltaBetweenButterflies, 2);
2272 
2273     addFunction(vm, &quot;totalGCTime&quot;, functionTotalGCTime, 0);
2274 }
2275 
2276 void JSDollarVM::addFunction(VM&amp; vm, JSGlobalObject* globalObject, const char* name, NativeFunction function, unsigned arguments)
2277 {
2278     Identifier identifier = Identifier::fromString(&amp;vm, name);
2279     putDirect(vm, identifier, JSFunction::create(vm, globalObject, arguments, identifier.string(), function));
2280 }
2281 
2282 void JSDollarVM::addConstructibleFunction(VM&amp; vm, JSGlobalObject* globalObject, const char* name, NativeFunction function, unsigned arguments)
2283 {
2284     Identifier identifier = Identifier::fromString(&amp;vm, name);
2285     putDirect(vm, identifier, JSFunction::create(vm, globalObject, arguments, identifier.string(), function, NoIntrinsic, function));
2286 }
2287 
2288 } // namespace JSC
    </pre>
  </body>
</html>