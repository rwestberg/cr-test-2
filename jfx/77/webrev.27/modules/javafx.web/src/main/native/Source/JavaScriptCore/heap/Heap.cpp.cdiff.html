<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/heap/Heap.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="HandleSet.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Heap.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/heap/Heap.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 20,18 ***</span>
<span class="line-new-header">--- 20,20 ---</span>
  
  #include &quot;config.h&quot;
  #include &quot;Heap.h&quot;
  
  #include &quot;BlockDirectoryInlines.h&quot;
<span class="line-added">+ #include &quot;BuiltinExecutables.h&quot;</span>
  #include &quot;CodeBlock.h&quot;
  #include &quot;CodeBlockSetInlines.h&quot;
  #include &quot;CollectingScope.h&quot;
  #include &quot;ConservativeRoots.h&quot;
  #include &quot;DFGWorklistInlines.h&quot;
  #include &quot;EdenGCActivityCallback.h&quot;
  #include &quot;Exception.h&quot;
  #include &quot;FullGCActivityCallback.h&quot;
<span class="line-added">+ #include &quot;FunctionExecutableInlines.h&quot;</span>
  #include &quot;GCActivityCallback.h&quot;
  #include &quot;GCIncomingRefCountedSetInlines.h&quot;
  #include &quot;GCSegmentedArrayInlines.h&quot;
  #include &quot;GCTypeMap.h&quot;
  #include &quot;HasOwnPropertyCache.h&quot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 49,10 ***</span>
<span class="line-new-header">--- 51,11 ---</span>
  #include &quot;JSCInlines.h&quot;
  #include &quot;JSGlobalObject.h&quot;
  #include &quot;JSLock.h&quot;
  #include &quot;JSVirtualMachineInternal.h&quot;
  #include &quot;JSWeakMap.h&quot;
<span class="line-added">+ #include &quot;JSWeakObjectRef.h&quot;</span>
  #include &quot;JSWeakSet.h&quot;
  #include &quot;JSWebAssemblyCodeBlock.h&quot;
  #include &quot;MachineStackMarker.h&quot;
  #include &quot;MarkStackMergingConstraint.h&quot;
  #include &quot;MarkedSpaceInlines.h&quot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 64,10 ***</span>
<span class="line-new-header">--- 67,11 ---</span>
  #include &quot;StochasticSpaceTimeMutatorScheduler.h&quot;
  #include &quot;StopIfNecessaryTimer.h&quot;
  #include &quot;SubspaceInlines.h&quot;
  #include &quot;SuperSampler.h&quot;
  #include &quot;SweepingScope.h&quot;
<span class="line-added">+ #include &quot;SymbolTableInlines.h&quot;</span>
  #include &quot;SynchronousStopTheWorldMutatorScheduler.h&quot;
  #include &quot;TypeProfiler.h&quot;
  #include &quot;TypeProfilerLog.h&quot;
  #include &quot;UnlinkedCodeBlock.h&quot;
  #include &quot;VM.h&quot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 90,11 ***</span>
  
  #if USE(FOUNDATION)
  #include &lt;wtf/spi/cocoa/objcSPI.h&gt;
  #endif
  
<span class="line-modified">! #if USE(GLIB)</span>
  #include &quot;JSCGLibWrapperObject.h&quot;
  #endif
  
  namespace JSC {
  
<span class="line-new-header">--- 94,11 ---</span>
  
  #if USE(FOUNDATION)
  #include &lt;wtf/spi/cocoa/objcSPI.h&gt;
  #endif
  
<span class="line-modified">! #ifdef JSC_GLIB_API_ENABLED</span>
  #include &quot;JSCGLibWrapperObject.h&quot;
  #endif
  
  namespace JSC {
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 138,21 ***</span>
          return Options::mediumHeapGrowthFactor() * heapSize;
  #endif
      return Options::largeHeapGrowthFactor() * heapSize;
  }
  
<span class="line-modified">! bool isValidSharedInstanceThreadState(VM* vm)</span>
  {
<span class="line-modified">!     return vm-&gt;currentThreadIsHoldingAPILock();</span>
  }
  
<span class="line-modified">! bool isValidThreadState(VM* vm)</span>
  {
<span class="line-modified">!     if (vm-&gt;atomicStringTable() != WTF::Thread::current().atomicStringTable())</span>
          return false;
  
<span class="line-modified">!     if (vm-&gt;isSharedInstance() &amp;&amp; !isValidSharedInstanceThreadState(vm))</span>
          return false;
  
      return true;
  }
  
<span class="line-new-header">--- 142,21 ---</span>
          return Options::mediumHeapGrowthFactor() * heapSize;
  #endif
      return Options::largeHeapGrowthFactor() * heapSize;
  }
  
<span class="line-modified">! bool isValidSharedInstanceThreadState(VM&amp; vm)</span>
  {
<span class="line-modified">!     return vm.currentThreadIsHoldingAPILock();</span>
  }
  
<span class="line-modified">! bool isValidThreadState(VM&amp; vm)</span>
  {
<span class="line-modified">!     if (vm.atomStringTable() != Thread::current().atomStringTable())</span>
          return false;
  
<span class="line-modified">!     if (vm.isSharedInstance() &amp;&amp; !isValidSharedInstanceThreadState(vm))</span>
          return false;
  
      return true;
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 228,13 ***</span>
      const char* m_name;
  };
  
  } // anonymous namespace
  
<span class="line-modified">! class Heap::Thread : public AutomaticThread {</span>
  public:
<span class="line-modified">!     Thread(const AbstractLocker&amp; locker, Heap&amp; heap)</span>
          : AutomaticThread(locker, heap.m_threadLock, heap.m_threadCondition.copyRef())
          , m_heap(heap)
      {
      }
  
<span class="line-new-header">--- 232,13 ---</span>
      const char* m_name;
  };
  
  } // anonymous namespace
  
<span class="line-modified">! class Heap::HeapThread : public AutomaticThread {</span>
  public:
<span class="line-modified">!     HeapThread(const AbstractLocker&amp; locker, Heap&amp; heap)</span>
          : AutomaticThread(locker, heap.m_threadLock, heap.m_threadCondition.copyRef())
          , m_heap(heap)
      {
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 248,12 ***</span>
      {
          if (m_heap.m_threadShouldStop) {
              m_heap.notifyThreadStopping(locker);
              return PollResult::Stop;
          }
<span class="line-modified">!         if (m_heap.shouldCollectInCollectorThread(locker))</span>
              return PollResult::Work;
          return PollResult::Wait;
      }
  
      WorkResult work() override
      {
<span class="line-new-header">--- 252,15 ---</span>
      {
          if (m_heap.m_threadShouldStop) {
              m_heap.notifyThreadStopping(locker);
              return PollResult::Stop;
          }
<span class="line-modified">!         if (m_heap.shouldCollectInCollectorThread(locker)) {</span>
<span class="line-added">+             m_heap.m_collectorThreadIsRunning = true;</span>
              return PollResult::Work;
<span class="line-added">+         }</span>
<span class="line-added">+         m_heap.m_collectorThreadIsRunning = false;</span>
          return PollResult::Wait;
      }
  
      WorkResult work() override
      {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 261,74 ***</span>
          return WorkResult::Continue;
      }
  
      void threadDidStart() override
      {
<span class="line-modified">!         WTF::registerGCThread(GCThreadType::Main);</span>
      }
  
  private:
      Heap&amp; m_heap;
  };
  
<span class="line-modified">! Heap::Heap(VM* vm, HeapType heapType)</span>
      : m_heapType(heapType)
      , m_ramSize(Options::forceRAMSize() ? Options::forceRAMSize() : ramSize())
      , m_minBytesPerCycle(minHeapSize(m_heapType, m_ramSize))
      , m_maxEdenSize(m_minBytesPerCycle)
      , m_maxHeapSize(m_minBytesPerCycle)
      , m_objectSpace(this)
<span class="line-modified">!     , m_machineThreads(std::make_unique&lt;MachineThreads&gt;())</span>
<span class="line-modified">!     , m_collectorSlotVisitor(std::make_unique&lt;SlotVisitor&gt;(*this, &quot;C&quot;))</span>
<span class="line-modified">!     , m_mutatorSlotVisitor(std::make_unique&lt;SlotVisitor&gt;(*this, &quot;M&quot;))</span>
<span class="line-modified">!     , m_mutatorMarkStack(std::make_unique&lt;MarkStackArray&gt;())</span>
<span class="line-modified">!     , m_raceMarkStack(std::make_unique&lt;MarkStackArray&gt;())</span>
<span class="line-modified">!     , m_constraintSet(std::make_unique&lt;MarkingConstraintSet&gt;(*this))</span>
      , m_handleSet(vm)
<span class="line-modified">!     , m_codeBlocks(std::make_unique&lt;CodeBlockSet&gt;())</span>
<span class="line-modified">!     , m_jitStubRoutines(std::make_unique&lt;JITStubRoutineSet&gt;())</span>
      , m_vm(vm)
      // We seed with 10ms so that GCActivityCallback::didAllocate doesn&#39;t continuously
      // schedule the timer if we&#39;ve never done a collection.
      , m_fullActivityCallback(GCActivityCallback::tryCreateFullTimer(this))
      , m_edenActivityCallback(GCActivityCallback::tryCreateEdenTimer(this))
      , m_sweeper(adoptRef(*new IncrementalSweeper(this)))
      , m_stopIfNecessaryTimer(adoptRef(*new StopIfNecessaryTimer(vm)))
<span class="line-modified">!     , m_sharedCollectorMarkStack(std::make_unique&lt;MarkStackArray&gt;())</span>
<span class="line-modified">!     , m_sharedMutatorMarkStack(std::make_unique&lt;MarkStackArray&gt;())</span>
      , m_helperClient(&amp;heapHelperPool())
      , m_threadLock(Box&lt;Lock&gt;::create())
      , m_threadCondition(AutomaticThreadCondition::create())
  {
      m_worldState.store(0);
  
      if (Options::useConcurrentGC()) {
          if (Options::useStochasticMutatorScheduler())
<span class="line-modified">!             m_scheduler = std::make_unique&lt;StochasticSpaceTimeMutatorScheduler&gt;(*this);</span>
          else
<span class="line-modified">!             m_scheduler = std::make_unique&lt;SpaceTimeMutatorScheduler&gt;(*this);</span>
      } else {
          // We simulate turning off concurrent GC by making the scheduler say that the world
          // should always be stopped when the collector is running.
<span class="line-modified">!         m_scheduler = std::make_unique&lt;SynchronousStopTheWorldMutatorScheduler&gt;();</span>
      }
  
      if (Options::verifyHeap())
<span class="line-modified">!         m_verifier = std::make_unique&lt;HeapVerifier&gt;(this, Options::numberOfGCCyclesToRecordForVerification());</span>
  
      m_collectorSlotVisitor-&gt;optimizeForStoppedMutator();
  
      // When memory is critical, allow allocating 25% of the amount above the critical threshold before collecting.
      size_t memoryAboveCriticalThreshold = static_cast&lt;size_t&gt;(static_cast&lt;double&gt;(m_ramSize) * (1.0 - Options::criticalGCMemoryThreshold()));
      m_maxEdenSizeWhenCritical = memoryAboveCriticalThreshold / 4;
  
      LockHolder locker(*m_threadLock);
<span class="line-modified">!     m_thread = adoptRef(new Thread(locker, *this));</span>
  }
  
  Heap::~Heap()
  {
      forEachSlotVisitor(
          [&amp;] (SlotVisitor&amp; visitor) {
              visitor.clearMarkStacks();
          });
      m_mutatorMarkStack-&gt;clear();
<span class="line-new-header">--- 268,90 ---</span>
          return WorkResult::Continue;
      }
  
      void threadDidStart() override
      {
<span class="line-modified">!         Thread::registerGCThread(GCThreadType::Main);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     void threadIsStopping(const AbstractLocker&amp;) override</span>
<span class="line-added">+     {</span>
<span class="line-added">+         m_heap.m_collectorThreadIsRunning = false;</span>
      }
  
  private:
      Heap&amp; m_heap;
  };
  
<span class="line-modified">! Heap::Heap(VM&amp; vm, HeapType heapType)</span>
      : m_heapType(heapType)
      , m_ramSize(Options::forceRAMSize() ? Options::forceRAMSize() : ramSize())
      , m_minBytesPerCycle(minHeapSize(m_heapType, m_ramSize))
      , m_maxEdenSize(m_minBytesPerCycle)
      , m_maxHeapSize(m_minBytesPerCycle)
      , m_objectSpace(this)
<span class="line-modified">!     , m_machineThreads(makeUnique&lt;MachineThreads&gt;())</span>
<span class="line-modified">!     , m_collectorSlotVisitor(makeUnique&lt;SlotVisitor&gt;(*this, &quot;C&quot;))</span>
<span class="line-modified">!     , m_mutatorSlotVisitor(makeUnique&lt;SlotVisitor&gt;(*this, &quot;M&quot;))</span>
<span class="line-modified">!     , m_mutatorMarkStack(makeUnique&lt;MarkStackArray&gt;())</span>
<span class="line-modified">!     , m_raceMarkStack(makeUnique&lt;MarkStackArray&gt;())</span>
<span class="line-modified">!     , m_constraintSet(makeUnique&lt;MarkingConstraintSet&gt;(*this))</span>
      , m_handleSet(vm)
<span class="line-modified">!     , m_codeBlocks(makeUnique&lt;CodeBlockSet&gt;())</span>
<span class="line-modified">!     , m_jitStubRoutines(makeUnique&lt;JITStubRoutineSet&gt;())</span>
      , m_vm(vm)
      // We seed with 10ms so that GCActivityCallback::didAllocate doesn&#39;t continuously
      // schedule the timer if we&#39;ve never done a collection.
      , m_fullActivityCallback(GCActivityCallback::tryCreateFullTimer(this))
      , m_edenActivityCallback(GCActivityCallback::tryCreateEdenTimer(this))
      , m_sweeper(adoptRef(*new IncrementalSweeper(this)))
      , m_stopIfNecessaryTimer(adoptRef(*new StopIfNecessaryTimer(vm)))
<span class="line-modified">!     , m_sharedCollectorMarkStack(makeUnique&lt;MarkStackArray&gt;())</span>
<span class="line-modified">!     , m_sharedMutatorMarkStack(makeUnique&lt;MarkStackArray&gt;())</span>
      , m_helperClient(&amp;heapHelperPool())
      , m_threadLock(Box&lt;Lock&gt;::create())
      , m_threadCondition(AutomaticThreadCondition::create())
  {
      m_worldState.store(0);
  
<span class="line-added">+     for (unsigned i = 0, numberOfParallelThreads = heapHelperPool().numberOfThreads(); i &lt; numberOfParallelThreads; ++i) {</span>
<span class="line-added">+         std::unique_ptr&lt;SlotVisitor&gt; visitor = makeUnique&lt;SlotVisitor&gt;(*this, toCString(&quot;P&quot;, i + 1));</span>
<span class="line-added">+         if (Options::optimizeParallelSlotVisitorsForStoppedMutator())</span>
<span class="line-added">+             visitor-&gt;optimizeForStoppedMutator();</span>
<span class="line-added">+         m_availableParallelSlotVisitors.append(visitor.get());</span>
<span class="line-added">+         m_parallelSlotVisitors.append(WTFMove(visitor));</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      if (Options::useConcurrentGC()) {
          if (Options::useStochasticMutatorScheduler())
<span class="line-modified">!             m_scheduler = makeUnique&lt;StochasticSpaceTimeMutatorScheduler&gt;(*this);</span>
          else
<span class="line-modified">!             m_scheduler = makeUnique&lt;SpaceTimeMutatorScheduler&gt;(*this);</span>
      } else {
          // We simulate turning off concurrent GC by making the scheduler say that the world
          // should always be stopped when the collector is running.
<span class="line-modified">!         m_scheduler = makeUnique&lt;SynchronousStopTheWorldMutatorScheduler&gt;();</span>
      }
  
      if (Options::verifyHeap())
<span class="line-modified">!         m_verifier = makeUnique&lt;HeapVerifier&gt;(this, Options::numberOfGCCyclesToRecordForVerification());</span>
  
      m_collectorSlotVisitor-&gt;optimizeForStoppedMutator();
  
      // When memory is critical, allow allocating 25% of the amount above the critical threshold before collecting.
      size_t memoryAboveCriticalThreshold = static_cast&lt;size_t&gt;(static_cast&lt;double&gt;(m_ramSize) * (1.0 - Options::criticalGCMemoryThreshold()));
      m_maxEdenSizeWhenCritical = memoryAboveCriticalThreshold / 4;
  
      LockHolder locker(*m_threadLock);
<span class="line-modified">!     m_thread = adoptRef(new HeapThread(locker, *this));</span>
  }
  
  Heap::~Heap()
  {
<span class="line-added">+     // Scribble m_worldState to make it clear that the heap has already been destroyed if we crash in checkConn</span>
<span class="line-added">+     m_worldState.store(0xbadbeeffu);</span>
<span class="line-added">+ </span>
      forEachSlotVisitor(
          [&amp;] (SlotVisitor&amp; visitor) {
              visitor.clearMarkStacks();
          });
      m_mutatorMarkStack-&gt;clear();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 341,10 ***</span>
<span class="line-new-header">--- 364,34 ---</span>
  bool Heap::isPagedOut(MonotonicTime deadline)
  {
      return m_objectSpace.isPagedOut(deadline);
  }
  
<span class="line-added">+ void Heap::dumpHeapStatisticsAtVMDestruction()</span>
<span class="line-added">+ {</span>
<span class="line-added">+     unsigned counter = 0;</span>
<span class="line-added">+     m_objectSpace.forEachBlock([&amp;] (MarkedBlock::Handle* block) {</span>
<span class="line-added">+         unsigned live = 0;</span>
<span class="line-added">+         block-&gt;forEachCell([&amp;] (HeapCell* cell, HeapCell::Kind) {</span>
<span class="line-added">+             if (cell-&gt;isLive())</span>
<span class="line-added">+                 live++;</span>
<span class="line-added">+             return IterationStatus::Continue;</span>
<span class="line-added">+         });</span>
<span class="line-added">+         dataLogLn(&quot;[&quot;, counter++, &quot;] &quot;, block-&gt;cellSize(), &quot;, &quot;, live, &quot; / &quot;, block-&gt;cellsPerBlock(), &quot; &quot;, static_cast&lt;double&gt;(live) / block-&gt;cellsPerBlock() * 100, &quot;% &quot;, block-&gt;attributes(), &quot; &quot;, block-&gt;subspace()-&gt;name());</span>
<span class="line-added">+         block-&gt;forEachCell([&amp;] (HeapCell* heapCell, HeapCell::Kind kind) {</span>
<span class="line-added">+             if (heapCell-&gt;isLive() &amp;&amp; kind == HeapCell::Kind::JSCell) {</span>
<span class="line-added">+                 auto* cell = static_cast&lt;JSCell*&gt;(heapCell);</span>
<span class="line-added">+                 if (cell-&gt;isObject())</span>
<span class="line-added">+                     dataLogLn(&quot;    &quot;, JSValue((JSObject*)cell));</span>
<span class="line-added">+                 else</span>
<span class="line-added">+                     dataLogLn(&quot;    &quot;, *cell);</span>
<span class="line-added">+             }</span>
<span class="line-added">+             return IterationStatus::Continue;</span>
<span class="line-added">+         });</span>
<span class="line-added">+     });</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  // The VM is being destroyed and the collector will never run again.
  // Run all pending finalizers now because we won&#39;t get another chance.
  void Heap::lastChanceToFinalize()
  {
      MonotonicTime before;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 353,11 ***</span>
          dataLog(&quot;[GC&lt;&quot;, RawPointer(this), &quot;&gt;: shutdown &quot;);
      }
  
      m_isShuttingDown = true;
  
<span class="line-modified">!     RELEASE_ASSERT(!m_vm-&gt;entryScope);</span>
      RELEASE_ASSERT(m_mutatorState == MutatorState::Running);
  
      if (m_collectContinuouslyThread) {
          {
              LockHolder locker(m_collectContinuouslyLock);
<span class="line-new-header">--- 400,11 ---</span>
          dataLog(&quot;[GC&lt;&quot;, RawPointer(this), &quot;&gt;: shutdown &quot;);
      }
  
      m_isShuttingDown = true;
  
<span class="line-modified">!     RELEASE_ASSERT(!m_vm.entryScope);</span>
      RELEASE_ASSERT(m_mutatorState == MutatorState::Running);
  
      if (m_collectContinuouslyThread) {
          {
              LockHolder locker(m_collectContinuouslyLock);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 421,10 ***</span>
<span class="line-new-header">--- 468,13 ---</span>
          m_thread-&gt;join();
  
      if (Options::logGC())
          dataLog(&quot;5 &quot;);
  
<span class="line-added">+     if (UNLIKELY(Options::dumpHeapStatisticsAtVMDestruction()))</span>
<span class="line-added">+         dumpHeapStatisticsAtVMDestruction();</span>
<span class="line-added">+ </span>
      m_arrayBuffers.lastChanceToFinalize();
      m_objectSpace.stopAllocatingForGood();
      m_objectSpace.lastChanceToFinalize();
      releaseDelayedReleasedObjects();
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 436,21 ***</span>
          dataLog((MonotonicTime::now() - before).milliseconds(), &quot;ms]\n&quot;);
  }
  
  void Heap::releaseDelayedReleasedObjects()
  {
<span class="line-modified">! #if USE(FOUNDATION) || USE(GLIB)</span>
      // We need to guard against the case that releasing an object can create more objects due to the
      // release calling into JS. When those JS call(s) exit and all locks are being dropped we end up
      // back here and could try to recursively release objects. We guard that with a recursive entry
      // count. Only the initial call will release objects, recursive calls simple return and let the
      // the initial call to the function take care of any objects created during release time.
      // This also means that we need to loop until there are no objects in m_delayedReleaseObjects
      // and use a temp Vector for the actual releasing.
      if (!m_delayedReleaseRecursionCount++) {
          while (!m_delayedReleaseObjects.isEmpty()) {
<span class="line-modified">!             ASSERT(m_vm-&gt;currentThreadIsHoldingAPILock());</span>
  
              auto objectsToRelease = WTFMove(m_delayedReleaseObjects);
  
              {
                  // We need to drop locks before calling out to arbitrary code.
<span class="line-new-header">--- 486,21 ---</span>
          dataLog((MonotonicTime::now() - before).milliseconds(), &quot;ms]\n&quot;);
  }
  
  void Heap::releaseDelayedReleasedObjects()
  {
<span class="line-modified">! #if USE(FOUNDATION) || defined(JSC_GLIB_API_ENABLED)</span>
      // We need to guard against the case that releasing an object can create more objects due to the
      // release calling into JS. When those JS call(s) exit and all locks are being dropped we end up
      // back here and could try to recursively release objects. We guard that with a recursive entry
      // count. Only the initial call will release objects, recursive calls simple return and let the
      // the initial call to the function take care of any objects created during release time.
      // This also means that we need to loop until there are no objects in m_delayedReleaseObjects
      // and use a temp Vector for the actual releasing.
      if (!m_delayedReleaseRecursionCount++) {
          while (!m_delayedReleaseObjects.isEmpty()) {
<span class="line-modified">!             ASSERT(m_vm.currentThreadIsHoldingAPILock());</span>
  
              auto objectsToRelease = WTFMove(m_delayedReleaseObjects);
  
              {
                  // We need to drop locks before calling out to arbitrary code.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 519,22 ***</span>
  }
  
  void Heap::protect(JSValue k)
  {
      ASSERT(k);
<span class="line-modified">!     ASSERT(m_vm-&gt;currentThreadIsHoldingAPILock());</span>
  
      if (!k.isCell())
          return;
  
      m_protectedValues.add(k.asCell());
  }
  
  bool Heap::unprotect(JSValue k)
  {
      ASSERT(k);
<span class="line-modified">!     ASSERT(m_vm-&gt;currentThreadIsHoldingAPILock());</span>
  
      if (!k.isCell())
          return false;
  
      return m_protectedValues.remove(k.asCell());
<span class="line-new-header">--- 569,22 ---</span>
  }
  
  void Heap::protect(JSValue k)
  {
      ASSERT(k);
<span class="line-modified">!     ASSERT(m_vm.currentThreadIsHoldingAPILock());</span>
  
      if (!k.isCell())
          return;
  
      m_protectedValues.add(k.asCell());
  }
  
  bool Heap::unprotect(JSValue k)
  {
      ASSERT(k);
<span class="line-modified">!     ASSERT(m_vm.currentThreadIsHoldingAPILock());</span>
  
      if (!k.isCell())
          return false;
  
      return m_protectedValues.remove(k.asCell());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 551,33 ***</span>
  template&lt;typename CellType, typename CellSet&gt;
  void Heap::finalizeMarkedUnconditionalFinalizers(CellSet&amp; cellSet)
  {
      cellSet.forEachMarkedCell(
          [&amp;] (HeapCell* cell, HeapCell::Kind) {
<span class="line-modified">!             static_cast&lt;CellType*&gt;(cell)-&gt;finalizeUnconditionally(*vm());</span>
          });
  }
  
  void Heap::finalizeUnconditionalFinalizers()
  {
<span class="line-modified">!     if (vm()-&gt;m_inferredValueSpace)</span>
<span class="line-modified">!         finalizeMarkedUnconditionalFinalizers&lt;InferredValue&gt;(vm()-&gt;m_inferredValueSpace-&gt;space);</span>
<span class="line-modified">!     vm()-&gt;forEachCodeBlockSpace(</span>
          [&amp;] (auto&amp; space) {
              this-&gt;finalizeMarkedUnconditionalFinalizers&lt;CodeBlock&gt;(space.set);
          });
<span class="line-modified">!     finalizeMarkedUnconditionalFinalizers&lt;ExecutableToCodeBlockEdge&gt;(vm()-&gt;executableToCodeBlockEdgesWithFinalizers);</span>
<span class="line-modified">!     if (vm()-&gt;m_weakSetSpace)</span>
<span class="line-modified">!         finalizeMarkedUnconditionalFinalizers&lt;JSWeakSet&gt;(*vm()-&gt;m_weakSetSpace);</span>
<span class="line-modified">!     if (vm()-&gt;m_weakMapSpace)</span>
<span class="line-modified">!         finalizeMarkedUnconditionalFinalizers&lt;JSWeakMap&gt;(*vm()-&gt;m_weakMapSpace);</span>
<span class="line-modified">!     if (vm()-&gt;m_errorInstanceSpace)</span>
<span class="line-modified">!         finalizeMarkedUnconditionalFinalizers&lt;ErrorInstance&gt;(*vm()-&gt;m_errorInstanceSpace);</span>
  
  #if ENABLE(WEBASSEMBLY)
<span class="line-modified">!     if (vm()-&gt;m_webAssemblyCodeBlockSpace)</span>
<span class="line-modified">!         finalizeMarkedUnconditionalFinalizers&lt;JSWebAssemblyCodeBlock&gt;(*vm()-&gt;m_webAssemblyCodeBlockSpace);</span>
  #endif
  }
  
  void Heap::willStartIterating()
  {
<span class="line-new-header">--- 601,38 ---</span>
  template&lt;typename CellType, typename CellSet&gt;
  void Heap::finalizeMarkedUnconditionalFinalizers(CellSet&amp; cellSet)
  {
      cellSet.forEachMarkedCell(
          [&amp;] (HeapCell* cell, HeapCell::Kind) {
<span class="line-modified">!             static_cast&lt;CellType*&gt;(cell)-&gt;finalizeUnconditionally(vm());</span>
          });
  }
  
  void Heap::finalizeUnconditionalFinalizers()
  {
<span class="line-modified">!     vm().builtinExecutables()-&gt;finalizeUnconditionally();</span>
<span class="line-modified">!     finalizeMarkedUnconditionalFinalizers&lt;FunctionExecutable&gt;(vm().functionExecutableSpace.space);</span>
<span class="line-modified">!     finalizeMarkedUnconditionalFinalizers&lt;SymbolTable&gt;(vm().symbolTableSpace);</span>
<span class="line-added">+     vm().forEachCodeBlockSpace(</span>
          [&amp;] (auto&amp; space) {
              this-&gt;finalizeMarkedUnconditionalFinalizers&lt;CodeBlock&gt;(space.set);
          });
<span class="line-modified">!     finalizeMarkedUnconditionalFinalizers&lt;ExecutableToCodeBlockEdge&gt;(vm().executableToCodeBlockEdgesWithFinalizers);</span>
<span class="line-modified">!     finalizeMarkedUnconditionalFinalizers&lt;StructureRareData&gt;(vm().structureRareDataSpace);</span>
<span class="line-modified">!     finalizeMarkedUnconditionalFinalizers&lt;UnlinkedFunctionExecutable&gt;(vm().unlinkedFunctionExecutableSpace.set);</span>
<span class="line-modified">!     if (vm().m_weakSetSpace)</span>
<span class="line-modified">!         finalizeMarkedUnconditionalFinalizers&lt;JSWeakSet&gt;(*vm().m_weakSetSpace);</span>
<span class="line-modified">!     if (vm().m_weakMapSpace)</span>
<span class="line-modified">!         finalizeMarkedUnconditionalFinalizers&lt;JSWeakMap&gt;(*vm().m_weakMapSpace);</span>
<span class="line-added">+     if (vm().m_weakObjectRefSpace)</span>
<span class="line-added">+         finalizeMarkedUnconditionalFinalizers&lt;JSWeakObjectRef&gt;(*vm().m_weakObjectRefSpace);</span>
<span class="line-added">+     if (vm().m_errorInstanceSpace)</span>
<span class="line-added">+         finalizeMarkedUnconditionalFinalizers&lt;ErrorInstance&gt;(*vm().m_errorInstanceSpace);</span>
  
  #if ENABLE(WEBASSEMBLY)
<span class="line-modified">!     if (vm().m_webAssemblyCodeBlockSpace)</span>
<span class="line-modified">!         finalizeMarkedUnconditionalFinalizers&lt;JSWebAssemblyCodeBlock&gt;(*vm().m_webAssemblyCodeBlockSpace);</span>
  #endif
  }
  
  void Heap::willStartIterating()
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 592,21 ***</span>
  void Heap::completeAllJITPlans()
  {
      if (!VM::canUseJIT())
          return;
  #if ENABLE(JIT)
<span class="line-modified">!     JITWorklist::ensureGlobalWorklist().completeAllForVM(*m_vm);</span>
  #endif // ENABLE(JIT)
<span class="line-modified">!     DFG::completeAllPlansForVM(*m_vm);</span>
  }
  
  template&lt;typename Func&gt;
  void Heap::iterateExecutingAndCompilingCodeBlocks(const Func&amp; func)
  {
      m_codeBlocks-&gt;iterateCurrentlyExecuting(func);
      if (VM::canUseJIT())
<span class="line-modified">!         DFG::iterateCodeBlocksForGC(*m_vm, func);</span>
  }
  
  template&lt;typename Func&gt;
  void Heap::iterateExecutingAndCompilingCodeBlocksWithoutHoldingLocks(const Func&amp; func)
  {
<span class="line-new-header">--- 647,21 ---</span>
  void Heap::completeAllJITPlans()
  {
      if (!VM::canUseJIT())
          return;
  #if ENABLE(JIT)
<span class="line-modified">!     JITWorklist::ensureGlobalWorklist().completeAllForVM(m_vm);</span>
  #endif // ENABLE(JIT)
<span class="line-modified">!     DFG::completeAllPlansForVM(m_vm);</span>
  }
  
  template&lt;typename Func&gt;
  void Heap::iterateExecutingAndCompilingCodeBlocks(const Func&amp; func)
  {
      m_codeBlocks-&gt;iterateCurrentlyExecuting(func);
      if (VM::canUseJIT())
<span class="line-modified">!         DFG::iterateCodeBlocksForGC(m_vm, func);</span>
  }
  
  template&lt;typename Func&gt;
  void Heap::iterateExecutingAndCompilingCodeBlocksWithoutHoldingLocks(const Func&amp; func)
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 651,22 ***</span>
  }
  
  void Heap::gatherJSStackRoots(ConservativeRoots&amp; roots)
  {
  #if ENABLE(C_LOOP)
<span class="line-modified">!     m_vm-&gt;interpreter-&gt;cloopStack().gatherConservativeRoots(roots, *m_jitStubRoutines, *m_codeBlocks);</span>
  #else
      UNUSED_PARAM(roots);
  #endif
  }
  
  void Heap::gatherScratchBufferRoots(ConservativeRoots&amp; roots)
  {
  #if ENABLE(DFG_JIT)
      if (!VM::canUseJIT())
          return;
<span class="line-modified">!     m_vm-&gt;gatherScratchBufferRoots(roots);</span>
  #else
      UNUSED_PARAM(roots);
  #endif
  }
  
<span class="line-new-header">--- 706,22 ---</span>
  }
  
  void Heap::gatherJSStackRoots(ConservativeRoots&amp; roots)
  {
  #if ENABLE(C_LOOP)
<span class="line-modified">!     m_vm.interpreter-&gt;cloopStack().gatherConservativeRoots(roots, *m_jitStubRoutines, *m_codeBlocks);</span>
  #else
      UNUSED_PARAM(roots);
  #endif
  }
  
  void Heap::gatherScratchBufferRoots(ConservativeRoots&amp; roots)
  {
  #if ENABLE(DFG_JIT)
      if (!VM::canUseJIT())
          return;
<span class="line-modified">!     m_vm.gatherScratchBufferRoots(roots);</span>
  #else
      UNUSED_PARAM(roots);
  #endif
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 682,47 ***</span>
  {
  #if ENABLE(DFG_JIT)
      if (!VM::canUseJIT())
          return;
      for (unsigned i = DFG::numberOfWorklists(); i--;)
<span class="line-modified">!         DFG::existingWorklistForIndex(i).removeDeadPlans(*m_vm);</span>
  #endif
  }
  
<span class="line-modified">! bool Heap::isHeapSnapshotting() const</span>
  {
<span class="line-modified">!     HeapProfiler* heapProfiler = m_vm-&gt;heapProfiler();</span>
      if (UNLIKELY(heapProfiler))
<span class="line-modified">!         return heapProfiler-&gt;activeSnapshotBuilder();</span>
      return false;
  }
  
<span class="line-modified">! struct GatherHeapSnapshotData : MarkedBlock::CountFunctor {</span>
<span class="line-modified">!     GatherHeapSnapshotData(VM&amp; vm, HeapSnapshotBuilder&amp; builder)</span>
          : m_vm(vm)
<span class="line-modified">!         , m_builder(builder)</span>
      {
      }
  
      IterationStatus operator()(HeapCell* heapCell, HeapCell::Kind kind) const
      {
          if (isJSCellKind(kind)) {
              JSCell* cell = static_cast&lt;JSCell*&gt;(heapCell);
<span class="line-modified">!             cell-&gt;methodTable(m_vm)-&gt;heapSnapshot(cell, m_builder);</span>
          }
          return IterationStatus::Continue;
      }
  
      VM&amp; m_vm;
<span class="line-modified">!     HeapSnapshotBuilder&amp; m_builder;</span>
  };
  
<span class="line-modified">! void Heap::gatherExtraHeapSnapshotData(HeapProfiler&amp; heapProfiler)</span>
  {
<span class="line-modified">!     if (HeapSnapshotBuilder* builder = heapProfiler.activeSnapshotBuilder()) {</span>
          HeapIterationScope heapIterationScope(*this);
<span class="line-modified">!         GatherHeapSnapshotData functor(*m_vm, *builder);</span>
          m_objectSpace.forEachLiveCell(heapIterationScope, functor);
      }
  }
  
  struct RemoveDeadHeapSnapshotNodes : MarkedBlock::CountFunctor {
<span class="line-new-header">--- 737,47 ---</span>
  {
  #if ENABLE(DFG_JIT)
      if (!VM::canUseJIT())
          return;
      for (unsigned i = DFG::numberOfWorklists(); i--;)
<span class="line-modified">!         DFG::existingWorklistForIndex(i).removeDeadPlans(m_vm);</span>
  #endif
  }
  
<span class="line-modified">! bool Heap::isAnalyzingHeap() const</span>
  {
<span class="line-modified">!     HeapProfiler* heapProfiler = m_vm.heapProfiler();</span>
      if (UNLIKELY(heapProfiler))
<span class="line-modified">!         return heapProfiler-&gt;activeHeapAnalyzer();</span>
      return false;
  }
  
<span class="line-modified">! struct GatherExtraHeapData : MarkedBlock::CountFunctor {</span>
<span class="line-modified">!     GatherExtraHeapData(VM&amp; vm, HeapAnalyzer&amp; analyzer)</span>
          : m_vm(vm)
<span class="line-modified">!         , m_analyzer(analyzer)</span>
      {
      }
  
      IterationStatus operator()(HeapCell* heapCell, HeapCell::Kind kind) const
      {
          if (isJSCellKind(kind)) {
              JSCell* cell = static_cast&lt;JSCell*&gt;(heapCell);
<span class="line-modified">!             cell-&gt;methodTable(m_vm)-&gt;analyzeHeap(cell, m_analyzer);</span>
          }
          return IterationStatus::Continue;
      }
  
      VM&amp; m_vm;
<span class="line-modified">!     HeapAnalyzer&amp; m_analyzer;</span>
  };
  
<span class="line-modified">! void Heap::gatherExtraHeapData(HeapProfiler&amp; heapProfiler)</span>
  {
<span class="line-modified">!     if (auto* analyzer = heapProfiler.activeHeapAnalyzer()) {</span>
          HeapIterationScope heapIterationScope(*this);
<span class="line-modified">!         GatherExtraHeapData functor(m_vm, *analyzer);</span>
          m_objectSpace.forEachLiveCell(heapIterationScope, functor);
      }
  }
  
  struct RemoveDeadHeapSnapshotNodes : MarkedBlock::CountFunctor {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 842,38 ***</span>
      return result;
  }
  
  std::unique_ptr&lt;TypeCountSet&gt; Heap::protectedObjectTypeCounts()
  {
<span class="line-modified">!     std::unique_ptr&lt;TypeCountSet&gt; result = std::make_unique&lt;TypeCountSet&gt;();</span>
      forEachProtectedCell(
          [&amp;] (JSCell* cell) {
<span class="line-modified">!             recordType(*vm(), *result, cell);</span>
          });
      return result;
  }
  
  std::unique_ptr&lt;TypeCountSet&gt; Heap::objectTypeCounts()
  {
<span class="line-modified">!     std::unique_ptr&lt;TypeCountSet&gt; result = std::make_unique&lt;TypeCountSet&gt;();</span>
      HeapIterationScope iterationScope(*this);
      m_objectSpace.forEachLiveCell(
          iterationScope,
          [&amp;] (HeapCell* cell, HeapCell::Kind kind) -&gt; IterationStatus {
              if (isJSCellKind(kind))
<span class="line-modified">!                 recordType(*vm(), *result, static_cast&lt;JSCell*&gt;(cell));</span>
              return IterationStatus::Continue;
          });
      return result;
  }
  
  void Heap::deleteAllCodeBlocks(DeleteAllCodeEffort effort)
  {
      if (m_collectionScope &amp;&amp; effort == DeleteAllCodeIfNotCollecting)
          return;
  
<span class="line-modified">!     VM&amp; vm = *m_vm;</span>
      PreventCollectionScope preventCollectionScope(*this);
  
      // If JavaScript is running, it&#39;s not safe to delete all JavaScript code, since
      // we&#39;ll end up returning to deleted code.
      RELEASE_ASSERT(!vm.entryScope);
<span class="line-new-header">--- 897,38 ---</span>
      return result;
  }
  
  std::unique_ptr&lt;TypeCountSet&gt; Heap::protectedObjectTypeCounts()
  {
<span class="line-modified">!     std::unique_ptr&lt;TypeCountSet&gt; result = makeUnique&lt;TypeCountSet&gt;();</span>
      forEachProtectedCell(
          [&amp;] (JSCell* cell) {
<span class="line-modified">!             recordType(vm(), *result, cell);</span>
          });
      return result;
  }
  
  std::unique_ptr&lt;TypeCountSet&gt; Heap::objectTypeCounts()
  {
<span class="line-modified">!     std::unique_ptr&lt;TypeCountSet&gt; result = makeUnique&lt;TypeCountSet&gt;();</span>
      HeapIterationScope iterationScope(*this);
      m_objectSpace.forEachLiveCell(
          iterationScope,
          [&amp;] (HeapCell* cell, HeapCell::Kind kind) -&gt; IterationStatus {
              if (isJSCellKind(kind))
<span class="line-modified">!                 recordType(vm(), *result, static_cast&lt;JSCell*&gt;(cell));</span>
              return IterationStatus::Continue;
          });
      return result;
  }
  
  void Heap::deleteAllCodeBlocks(DeleteAllCodeEffort effort)
  {
      if (m_collectionScope &amp;&amp; effort == DeleteAllCodeIfNotCollecting)
          return;
  
<span class="line-modified">!     VM&amp; vm = m_vm;</span>
      PreventCollectionScope preventCollectionScope(*this);
  
      // If JavaScript is running, it&#39;s not safe to delete all JavaScript code, since
      // we&#39;ll end up returning to deleted code.
      RELEASE_ASSERT(!vm.entryScope);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 914,11 ***</span>
  void Heap::deleteAllUnlinkedCodeBlocks(DeleteAllCodeEffort effort)
  {
      if (m_collectionScope &amp;&amp; effort == DeleteAllCodeIfNotCollecting)
          return;
  
<span class="line-modified">!     VM&amp; vm = *m_vm;</span>
      PreventCollectionScope preventCollectionScope(*this);
  
      RELEASE_ASSERT(!m_collectionScope);
  
      HeapIterationScope heapIterationScope(*this);
<span class="line-new-header">--- 969,11 ---</span>
  void Heap::deleteAllUnlinkedCodeBlocks(DeleteAllCodeEffort effort)
  {
      if (m_collectionScope &amp;&amp; effort == DeleteAllCodeIfNotCollecting)
          return;
  
<span class="line-modified">!     VM&amp; vm = m_vm;</span>
      PreventCollectionScope preventCollectionScope(*this);
  
      RELEASE_ASSERT(!m_collectionScope);
  
      HeapIterationScope heapIterationScope(*this);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 929,12 ***</span>
          });
  }
  
  void Heap::deleteUnmarkedCompiledCode()
  {
<span class="line-modified">!     vm()-&gt;forEachScriptExecutableSpace([] (auto&amp; space) { space.space.sweep(); });</span>
<span class="line-modified">!     vm()-&gt;forEachCodeBlockSpace([] (auto&amp; space) { space.space.sweep(); }); // Sweeping must occur before deleting stubs, otherwise the stubs might still think they&#39;re alive as they get deleted.</span>
      m_jitStubRoutines-&gt;deleteUnmarkedJettisonedStubRoutines();
  }
  
  void Heap::addToRememberedSet(const JSCell* constCell)
  {
<span class="line-new-header">--- 984,12 ---</span>
          });
  }
  
  void Heap::deleteUnmarkedCompiledCode()
  {
<span class="line-modified">!     vm().forEachScriptExecutableSpace([] (auto&amp; space) { space.space.sweep(); });</span>
<span class="line-modified">!     vm().forEachCodeBlockSpace([] (auto&amp; space) { space.space.sweep(); }); // Sweeping must occur before deleting stubs, otherwise the stubs might still think they&#39;re alive as they get deleted.</span>
      m_jitStubRoutines-&gt;deleteUnmarkedJettisonedStubRoutines();
  }
  
  void Heap::addToRememberedSet(const JSCell* constCell)
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 979,11 ***</span>
              }
  
              return;
          }
      } else
<span class="line-modified">!         ASSERT(Heap::isMarked(cell));</span>
      // It could be that the object was *just* marked. This means that the collector may set the
      // state to DefinitelyGrey and then to PossiblyOldOrBlack at any time. It&#39;s OK for us to
      // race with the collector here. If we win then this is accurate because the object _will_
      // get scanned again. If we lose then someone else will barrier the object again. That would
      // be unfortunate but not the end of the world.
<span class="line-new-header">--- 1034,11 ---</span>
              }
  
              return;
          }
      } else
<span class="line-modified">!         ASSERT(isMarked(cell));</span>
      // It could be that the object was *just* marked. This means that the collector may set the
      // state to DefinitelyGrey and then to PossiblyOldOrBlack at any time. It&#39;s OK for us to
      // race with the collector here. If we win then this is accurate because the object _will_
      // get scanned again. If we lose then someone else will barrier the object again. That would
      // be unfortunate but not the end of the world.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1124,24 ***</span>
  void Heap::checkConn(GCConductor conn)
  {
      unsigned worldState = m_worldState.load();
      switch (conn) {
      case GCConductor::Mutator:
<span class="line-modified">!         RELEASE_ASSERT(worldState &amp; mutatorHasConnBit, worldState, asInt(m_lastPhase), asInt(m_currentPhase), asInt(m_nextPhase), vm()-&gt;id(), VM::numberOfIDs(), vm()-&gt;isEntered());</span>
          return;
      case GCConductor::Collector:
<span class="line-modified">!         RELEASE_ASSERT(!(worldState &amp; mutatorHasConnBit), worldState, asInt(m_lastPhase), asInt(m_currentPhase), asInt(m_nextPhase), vm()-&gt;id(), VM::numberOfIDs(), vm()-&gt;isEntered());</span>
          return;
      }
      RELEASE_ASSERT_NOT_REACHED();
  }
  
  auto Heap::runCurrentPhase(GCConductor conn, CurrentThreadState* currentThreadState) -&gt; RunCurrentPhaseResult
  {
      checkConn(conn);
      m_currentThreadState = currentThreadState;
<span class="line-modified">!     m_currentThread = &amp;WTF::Thread::current();</span>
  
      if (conn == GCConductor::Mutator)
          sanitizeStackForVM(vm());
  
      // If the collector transfers the conn to the mutator, it leaves us in between phases.
<span class="line-new-header">--- 1179,24 ---</span>
  void Heap::checkConn(GCConductor conn)
  {
      unsigned worldState = m_worldState.load();
      switch (conn) {
      case GCConductor::Mutator:
<span class="line-modified">!         RELEASE_ASSERT(worldState &amp; mutatorHasConnBit, worldState, asInt(m_lastPhase), asInt(m_currentPhase), asInt(m_nextPhase), vm().id(), VM::numberOfIDs(), vm().isEntered());</span>
          return;
      case GCConductor::Collector:
<span class="line-modified">!         RELEASE_ASSERT(!(worldState &amp; mutatorHasConnBit), worldState, asInt(m_lastPhase), asInt(m_currentPhase), asInt(m_nextPhase), vm().id(), VM::numberOfIDs(), vm().isEntered());</span>
          return;
      }
      RELEASE_ASSERT_NOT_REACHED();
  }
  
  auto Heap::runCurrentPhase(GCConductor conn, CurrentThreadState* currentThreadState) -&gt; RunCurrentPhaseResult
  {
      checkConn(conn);
      m_currentThreadState = currentThreadState;
<span class="line-modified">!     m_currentThread = &amp;Thread::current();</span>
  
      if (conn == GCConductor::Mutator)
          sanitizeStackForVM(vm());
  
      // If the collector transfers the conn to the mutator, it leaves us in between phases.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1251,26 ***</span>
      m_helperClient.setFunction(
          [this] () {
              SlotVisitor* slotVisitor;
              {
                  LockHolder locker(m_parallelSlotVisitorLock);
<span class="line-modified">!                 if (m_availableParallelSlotVisitors.isEmpty()) {</span>
<span class="line-removed">-                     std::unique_ptr&lt;SlotVisitor&gt; newVisitor = std::make_unique&lt;SlotVisitor&gt;(</span>
<span class="line-removed">-                         *this, toCString(&quot;P&quot;, m_parallelSlotVisitors.size() + 1));</span>
<span class="line-removed">- </span>
<span class="line-removed">-                     if (Options::optimizeParallelSlotVisitorsForStoppedMutator())</span>
<span class="line-removed">-                         newVisitor-&gt;optimizeForStoppedMutator();</span>
<span class="line-removed">- </span>
<span class="line-removed">-                     newVisitor-&gt;didStartMarking();</span>
<span class="line-removed">- </span>
<span class="line-removed">-                     slotVisitor = newVisitor.get();</span>
<span class="line-removed">-                     m_parallelSlotVisitors.append(WTFMove(newVisitor));</span>
<span class="line-removed">-                 } else</span>
                  slotVisitor = m_availableParallelSlotVisitors.takeLast();
              }
  
<span class="line-modified">!             WTF::registerGCThread(GCThreadType::Helper);</span>
  
              {
                  ParallelModeEnabler parallelModeEnabler(*slotVisitor);
                  slotVisitor-&gt;drainFromShared(SlotVisitor::SlaveDrain);
              }
<span class="line-new-header">--- 1306,15 ---</span>
      m_helperClient.setFunction(
          [this] () {
              SlotVisitor* slotVisitor;
              {
                  LockHolder locker(m_parallelSlotVisitorLock);
<span class="line-modified">!                 RELEASE_ASSERT_WITH_MESSAGE(!m_availableParallelSlotVisitors.isEmpty(), &quot;Parallel SlotVisitors are allocated apriori&quot;);</span>
                  slotVisitor = m_availableParallelSlotVisitors.takeLast();
              }
  
<span class="line-modified">!             Thread::registerGCThread(GCThreadType::Helper);</span>
  
              {
                  ParallelModeEnabler parallelModeEnabler(*slotVisitor);
                  slotVisitor-&gt;drainFromShared(SlotVisitor::SlaveDrain);
              }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1462,15 ***</span>
      if (UNLIKELY(m_verifier)) {
          m_verifier-&gt;gatherLiveCells(HeapVerifier::Phase::AfterMarking);
          m_verifier-&gt;verify(HeapVerifier::Phase::AfterMarking);
      }
  
<span class="line-modified">!     if (vm()-&gt;typeProfiler())</span>
<span class="line-modified">!         vm()-&gt;typeProfiler()-&gt;invalidateTypeSetCache();</span>
<span class="line-removed">- </span>
<span class="line-removed">-     if (ValueProfile* profile = vm()-&gt;noJITValueProfileSingleton.get())</span>
<span class="line-removed">-         *profile = ValueProfile(0);</span>
  
      reapWeakHandles();
      pruneStaleEntriesFromWeakGCMaps();
      sweepArrayBuffers();
      snapshotUnswept();
<span class="line-new-header">--- 1506,12 ---</span>
      if (UNLIKELY(m_verifier)) {
          m_verifier-&gt;gatherLiveCells(HeapVerifier::Phase::AfterMarking);
          m_verifier-&gt;verify(HeapVerifier::Phase::AfterMarking);
      }
  
<span class="line-modified">!     if (vm().typeProfiler())</span>
<span class="line-modified">!         vm().typeProfiler()-&gt;invalidateTypeSetCache(vm());</span>
  
      reapWeakHandles();
      pruneStaleEntriesFromWeakGCMaps();
      sweepArrayBuffers();
      snapshotUnswept();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1605,19 ***</span>
          });
  
  #if ENABLE(JIT)
      if (VM::canUseJIT()) {
          DeferGCForAWhile awhile(*this);
<span class="line-modified">!         if (JITWorklist::ensureGlobalWorklist().completeAllForVM(*m_vm)</span>
              &amp;&amp; conn == GCConductor::Collector)
              setGCDidJIT();
      }
  #endif // ENABLE(JIT)
      UNUSED_PARAM(conn);
  
<span class="line-modified">!     if (auto* shadowChicken = vm()-&gt;shadowChicken())</span>
<span class="line-modified">!         shadowChicken-&gt;update(*vm(), vm()-&gt;topCallFrame);</span>
  
      m_structureIDTable.flushOldTables();
      m_objectSpace.stopAllocating();
  
      m_stopTime = MonotonicTime::now();
<span class="line-new-header">--- 1646,19 ---</span>
          });
  
  #if ENABLE(JIT)
      if (VM::canUseJIT()) {
          DeferGCForAWhile awhile(*this);
<span class="line-modified">!         if (JITWorklist::ensureGlobalWorklist().completeAllForVM(m_vm)</span>
              &amp;&amp; conn == GCConductor::Collector)
              setGCDidJIT();
      }
  #endif // ENABLE(JIT)
      UNUSED_PARAM(conn);
  
<span class="line-modified">!     if (auto* shadowChicken = vm().shadowChicken())</span>
<span class="line-modified">!         shadowChicken-&gt;update(vm(), vm().topCallFrame);</span>
  
      m_structureIDTable.flushOldTables();
      m_objectSpace.stopAllocating();
  
      m_stopTime = MonotonicTime::now();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1666,11 ***</span>
              if (remove) {
                  slotVisitorsToUpdate[index--] = slotVisitorsToUpdate.last();
                  slotVisitorsToUpdate.takeLast();
              }
          }
<span class="line-modified">!         WTF::Thread::yield();</span>
      }
  
      for (SlotVisitor* slotVisitor : slotVisitorsToUpdate)
          slotVisitor-&gt;updateMutatorIsStopped();
  
<span class="line-new-header">--- 1707,11 ---</span>
              if (remove) {
                  slotVisitorsToUpdate[index--] = slotVisitorsToUpdate.last();
                  slotVisitorsToUpdate.takeLast();
              }
          }
<span class="line-modified">!         Thread::yield();</span>
      }
  
      for (SlotVisitor* slotVisitor : slotVisitorsToUpdate)
          slotVisitor-&gt;updateMutatorIsStopped();
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2054,17 ***</span>
          deleteUnmarkedCompiledCode();
          deleteSourceProviderCaches();
          sweepInFinalize();
      }
  
<span class="line-modified">!     if (HasOwnPropertyCache* cache = vm()-&gt;hasOwnPropertyCache())</span>
          cache-&gt;clear();
  
      immutableButterflyToStringCache.clear();
  
      for (const HeapFinalizerCallback&amp; callback : m_heapFinalizerCallbacks)
<span class="line-modified">!         callback.run(*vm());</span>
  
      if (shouldSweepSynchronously())
          sweepSynchronously();
  
      if (Options::logGC()) {
<span class="line-new-header">--- 2095,17 ---</span>
          deleteUnmarkedCompiledCode();
          deleteSourceProviderCaches();
          sweepInFinalize();
      }
  
<span class="line-modified">!     if (HasOwnPropertyCache* cache = vm().hasOwnPropertyCache())</span>
          cache-&gt;clear();
  
      immutableButterflyToStringCache.clear();
  
      for (const HeapFinalizerCallback&amp; callback : m_heapFinalizerCallbacks)
<span class="line-modified">!         callback.run(vm());</span>
  
      if (shouldSweepSynchronously())
          sweepSynchronously();
  
      if (Options::logGC()) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2075,19 ***</span>
  
  Heap::Ticket Heap::requestCollection(GCRequest request)
  {
      stopIfNecessary();
  
<span class="line-modified">!     ASSERT(vm()-&gt;currentThreadIsHoldingAPILock());</span>
<span class="line-modified">!     RELEASE_ASSERT(vm()-&gt;atomicStringTable() == WTF::Thread::current().atomicStringTable());</span>
  
      LockHolder locker(*m_threadLock);
      // We may be able to steal the conn. That only works if the collector is definitely not running
      // right now. This is an optimization that prevents the collector thread from ever starting in most
      // cases.
      ASSERT(m_lastServedTicket &lt;= m_lastGrantedTicket);
<span class="line-modified">!     if ((m_lastServedTicket == m_lastGrantedTicket) &amp;&amp; (m_currentPhase == CollectorPhase::NotRunning)) {</span>
          if (false)
              dataLog(&quot;Taking the conn.\n&quot;);
          m_worldState.exchangeOr(mutatorHasConnBit);
      }
  
<span class="line-new-header">--- 2116,19 ---</span>
  
  Heap::Ticket Heap::requestCollection(GCRequest request)
  {
      stopIfNecessary();
  
<span class="line-modified">!     ASSERT(vm().currentThreadIsHoldingAPILock());</span>
<span class="line-modified">!     RELEASE_ASSERT(vm().atomStringTable() == Thread::current().atomStringTable());</span>
  
      LockHolder locker(*m_threadLock);
      // We may be able to steal the conn. That only works if the collector is definitely not running
      // right now. This is an optimization that prevents the collector thread from ever starting in most
      // cases.
      ASSERT(m_lastServedTicket &lt;= m_lastGrantedTicket);
<span class="line-modified">!     if ((m_lastServedTicket == m_lastGrantedTicket) &amp;&amp; !m_collectorThreadIsRunning) {</span>
          if (false)
              dataLog(&quot;Taking the conn.\n&quot;);
          m_worldState.exchangeOr(mutatorHasConnBit);
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2107,11 ***</span>
  }
  
  void Heap::sweepInFinalize()
  {
      m_objectSpace.sweepLargeAllocations();
<span class="line-modified">!     vm()-&gt;eagerlySweptDestructibleObjectSpace.sweep();</span>
  }
  
  void Heap::suspendCompilerThreads()
  {
  #if ENABLE(DFG_JIT)
<span class="line-new-header">--- 2148,11 ---</span>
  }
  
  void Heap::sweepInFinalize()
  {
      m_objectSpace.sweepLargeAllocations();
<span class="line-modified">!     vm().eagerlySweptDestructibleObjectSpace.sweep();</span>
  }
  
  void Heap::suspendCompilerThreads()
  {
  #if ENABLE(DFG_JIT)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2184,11 ***</span>
          weakGCMap-&gt;pruneStaleEntries();
  }
  
  void Heap::sweepArrayBuffers()
  {
<span class="line-modified">!     m_arrayBuffers.sweep();</span>
  }
  
  void Heap::snapshotUnswept()
  {
      TimingScope timingScope(*this, &quot;Heap::snapshotUnswept&quot;);
<span class="line-new-header">--- 2225,11 ---</span>
          weakGCMap-&gt;pruneStaleEntries();
  }
  
  void Heap::sweepArrayBuffers()
  {
<span class="line-modified">!     m_arrayBuffers.sweep(vm());</span>
  }
  
  void Heap::snapshotUnswept()
  {
      TimingScope timingScope(*this, &quot;Heap::snapshotUnswept&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2196,11 ***</span>
  }
  
  void Heap::deleteSourceProviderCaches()
  {
      if (m_lastCollectionScope &amp;&amp; m_lastCollectionScope.value() == CollectionScope::Full)
<span class="line-modified">!         m_vm-&gt;clearSourceProviderCaches();</span>
  }
  
  void Heap::notifyIncrementalSweeper()
  {
      if (m_collectionScope &amp;&amp; m_collectionScope.value() == CollectionScope::Full) {
<span class="line-new-header">--- 2237,11 ---</span>
  }
  
  void Heap::deleteSourceProviderCaches()
  {
      if (m_lastCollectionScope &amp;&amp; m_lastCollectionScope.value() == CollectionScope::Full)
<span class="line-modified">!         m_vm.clearSourceProviderCaches();</span>
  }
  
  void Heap::notifyIncrementalSweeper()
  {
      if (m_collectionScope &amp;&amp; m_collectionScope.value() == CollectionScope::Full) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2316,12 ***</span>
  
  #if ENABLE(RESOURCE_USAGE)
      ASSERT(externalMemorySize() &lt;= extraMemorySize());
  #endif
  
<span class="line-modified">!     if (HeapProfiler* heapProfiler = m_vm-&gt;heapProfiler()) {</span>
<span class="line-modified">!         gatherExtraHeapSnapshotData(*heapProfiler);</span>
          removeDeadHeapSnapshotNodes(*heapProfiler);
      }
  
      if (UNLIKELY(m_verifier))
          m_verifier-&gt;endGC();
<span class="line-new-header">--- 2357,12 ---</span>
  
  #if ENABLE(RESOURCE_USAGE)
      ASSERT(externalMemorySize() &lt;= extraMemorySize());
  #endif
  
<span class="line-modified">!     if (HeapProfiler* heapProfiler = m_vm.heapProfiler()) {</span>
<span class="line-modified">!         gatherExtraHeapData(*heapProfiler);</span>
          removeDeadHeapSnapshotNodes(*heapProfiler);
      }
  
      if (UNLIKELY(m_verifier))
          m_verifier-&gt;endGC();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2519,11 ***</span>
      addToRememberedSet(from);
  }
  
  bool Heap::isCurrentThreadBusy()
  {
<span class="line-modified">!     return mayBeGCThread() || mutatorState() != MutatorState::Running;</span>
  }
  
  void Heap::reportExtraMemoryVisited(size_t size)
  {
      size_t* counter = &amp;m_extraMemorySize;
<span class="line-new-header">--- 2560,11 ---</span>
      addToRememberedSet(from);
  }
  
  bool Heap::isCurrentThreadBusy()
  {
<span class="line-modified">!     return Thread::mayBeGCThread() || mutatorState() != MutatorState::Running;</span>
  }
  
  void Heap::reportExtraMemoryVisited(size_t size)
  {
      size_t* counter = &amp;m_extraMemorySize;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2658,10 ***</span>
<span class="line-new-header">--- 2699,11 ---</span>
              if (shouldNotProduceWork)
                  return;
  
              TimingScope preConvergenceTimingScope(*this, &quot;Constraint: conservative scan&quot;);
              m_objectSpace.prepareForConservativeScan();
<span class="line-added">+             m_jitStubRoutines-&gt;prepareForConservativeScan();</span>
  
              {
                  ConservativeRoots conservativeRoots(*this);
                  SuperSamplerScope superSamplerScope(false);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2685,15 ***</span>
      m_constraintSet-&gt;add(
          &quot;Msr&quot;, &quot;Misc Small Roots&quot;,
          [this] (SlotVisitor&amp; slotVisitor) {
  
  #if JSC_OBJC_API_ENABLED
<span class="line-modified">!             scanExternalRememberedSet(*m_vm, slotVisitor);</span>
  #endif
<span class="line-modified">!             if (m_vm-&gt;smallStrings.needsToBeVisited(*m_collectionScope)) {</span>
                  SetRootMarkReasonScope rootScope(slotVisitor, SlotVisitor::RootMarkReason::StrongReferences);
<span class="line-modified">!                 m_vm-&gt;smallStrings.visitStrongReferences(slotVisitor);</span>
              }
  
              {
                  SetRootMarkReasonScope rootScope(slotVisitor, SlotVisitor::RootMarkReason::ProtectedValues);
                  for (auto&amp; pair : m_protectedValues)
<span class="line-new-header">--- 2727,15 ---</span>
      m_constraintSet-&gt;add(
          &quot;Msr&quot;, &quot;Misc Small Roots&quot;,
          [this] (SlotVisitor&amp; slotVisitor) {
  
  #if JSC_OBJC_API_ENABLED
<span class="line-modified">!             scanExternalRememberedSet(m_vm, slotVisitor);</span>
  #endif
<span class="line-modified">!             if (m_vm.smallStrings.needsToBeVisited(*m_collectionScope)) {</span>
                  SetRootMarkReasonScope rootScope(slotVisitor, SlotVisitor::RootMarkReason::StrongReferences);
<span class="line-modified">!                 m_vm.smallStrings.visitStrongReferences(slotVisitor);</span>
              }
  
              {
                  SetRootMarkReasonScope rootScope(slotVisitor, SlotVisitor::RootMarkReason::ProtectedValues);
                  for (auto&amp; pair : m_protectedValues)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2705,12 ***</span>
                  MarkedArgumentBuffer::markLists(slotVisitor, *m_markListSet);
              }
  
              {
                  SetRootMarkReasonScope rootScope(slotVisitor, SlotVisitor::RootMarkReason::VMExceptions);
<span class="line-modified">!                 slotVisitor.appendUnbarriered(m_vm-&gt;exception());</span>
<span class="line-modified">!                 slotVisitor.appendUnbarriered(m_vm-&gt;lastException());</span>
              }
          },
          ConstraintVolatility::GreyedByExecution);
  
      m_constraintSet-&gt;add(
<span class="line-new-header">--- 2747,12 ---</span>
                  MarkedArgumentBuffer::markLists(slotVisitor, *m_markListSet);
              }
  
              {
                  SetRootMarkReasonScope rootScope(slotVisitor, SlotVisitor::RootMarkReason::VMExceptions);
<span class="line-modified">!                 slotVisitor.appendUnbarriered(m_vm.exception());</span>
<span class="line-modified">!                 slotVisitor.appendUnbarriered(m_vm.lastException());</span>
              }
          },
          ConstraintVolatility::GreyedByExecution);
  
      m_constraintSet-&gt;add(
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2725,23 ***</span>
          &quot;D&quot;, &quot;Debugger&quot;,
          [this] (SlotVisitor&amp; slotVisitor) {
              SetRootMarkReasonScope rootScope(slotVisitor, SlotVisitor::RootMarkReason::Debugger);
  
  #if ENABLE(SAMPLING_PROFILER)
<span class="line-modified">!             if (SamplingProfiler* samplingProfiler = m_vm-&gt;samplingProfiler()) {</span>
                  LockHolder locker(samplingProfiler-&gt;getLock());
                  samplingProfiler-&gt;processUnverifiedStackTraces();
                  samplingProfiler-&gt;visit(slotVisitor);
                  if (Options::logGC() == GCLogging::Verbose)
                      dataLog(&quot;Sampling Profiler data:\n&quot;, slotVisitor);
              }
  #endif // ENABLE(SAMPLING_PROFILER)
  
<span class="line-modified">!             if (m_vm-&gt;typeProfiler())</span>
<span class="line-modified">!                 m_vm-&gt;typeProfilerLog()-&gt;visit(slotVisitor);</span>
  
<span class="line-modified">!             if (auto* shadowChicken = m_vm-&gt;shadowChicken())</span>
                  shadowChicken-&gt;visitChildren(slotVisitor);
          },
          ConstraintVolatility::GreyedByExecution);
  
      m_constraintSet-&gt;add(
<span class="line-new-header">--- 2767,23 ---</span>
          &quot;D&quot;, &quot;Debugger&quot;,
          [this] (SlotVisitor&amp; slotVisitor) {
              SetRootMarkReasonScope rootScope(slotVisitor, SlotVisitor::RootMarkReason::Debugger);
  
  #if ENABLE(SAMPLING_PROFILER)
<span class="line-modified">!             if (SamplingProfiler* samplingProfiler = m_vm.samplingProfiler()) {</span>
                  LockHolder locker(samplingProfiler-&gt;getLock());
                  samplingProfiler-&gt;processUnverifiedStackTraces();
                  samplingProfiler-&gt;visit(slotVisitor);
                  if (Options::logGC() == GCLogging::Verbose)
                      dataLog(&quot;Sampling Profiler data:\n&quot;, slotVisitor);
              }
  #endif // ENABLE(SAMPLING_PROFILER)
  
<span class="line-modified">!             if (m_vm.typeProfiler())</span>
<span class="line-modified">!                 m_vm.typeProfilerLog()-&gt;visit(slotVisitor);</span>
  
<span class="line-modified">!             if (auto* shadowChicken = m_vm.shadowChicken())</span>
                  shadowChicken-&gt;visitChildren(slotVisitor);
          },
          ConstraintVolatility::GreyedByExecution);
  
      m_constraintSet-&gt;add(
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2786,11 ***</span>
                      DFG::existingWorklistForIndex(i).visitWeakReferences(slotVisitor);
  
                  // FIXME: This is almost certainly unnecessary.
                  // https://bugs.webkit.org/show_bug.cgi?id=166829
                  DFG::iterateCodeBlocksForGC(
<span class="line-modified">!                     *m_vm,</span>
                      [&amp;] (CodeBlock* codeBlock) {
                          slotVisitor.appendUnbarriered(codeBlock);
                      });
  
                  if (Options::logGC() == GCLogging::Verbose)
<span class="line-new-header">--- 2828,11 ---</span>
                      DFG::existingWorklistForIndex(i).visitWeakReferences(slotVisitor);
  
                  // FIXME: This is almost certainly unnecessary.
                  // https://bugs.webkit.org/show_bug.cgi?id=166829
                  DFG::iterateCodeBlocksForGC(
<span class="line-modified">!                     m_vm,</span>
                      [&amp;] (CodeBlock* codeBlock) {
                          slotVisitor.appendUnbarriered(codeBlock);
                      });
  
                  if (Options::logGC() == GCLogging::Verbose)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2805,18 ***</span>
          [this] (SlotVisitor&amp; slotVisitor) {
              SetRootMarkReasonScope rootScope(slotVisitor, SlotVisitor::RootMarkReason::CodeBlocks);
              iterateExecutingAndCompilingCodeBlocksWithoutHoldingLocks(
                  [&amp;] (CodeBlock* codeBlock) {
                      // Visit the CodeBlock as a constraint only if it&#39;s black.
<span class="line-modified">!                     if (Heap::isMarked(codeBlock)</span>
                          &amp;&amp; codeBlock-&gt;cellState() == CellState::PossiblyBlack)
                          slotVisitor.visitAsConstraint(codeBlock);
                  });
          },
          ConstraintVolatility::SeldomGreyed);
  
<span class="line-modified">!     m_constraintSet-&gt;add(std::make_unique&lt;MarkStackMergingConstraint&gt;(*this));</span>
  }
  
  void Heap::addMarkingConstraint(std::unique_ptr&lt;MarkingConstraint&gt; constraint)
  {
      PreventCollectionScope preventCollectionScope(*this);
<span class="line-new-header">--- 2847,18 ---</span>
          [this] (SlotVisitor&amp; slotVisitor) {
              SetRootMarkReasonScope rootScope(slotVisitor, SlotVisitor::RootMarkReason::CodeBlocks);
              iterateExecutingAndCompilingCodeBlocksWithoutHoldingLocks(
                  [&amp;] (CodeBlock* codeBlock) {
                      // Visit the CodeBlock as a constraint only if it&#39;s black.
<span class="line-modified">!                     if (isMarked(codeBlock)</span>
                          &amp;&amp; codeBlock-&gt;cellState() == CellState::PossiblyBlack)
                          slotVisitor.visitAsConstraint(codeBlock);
                  });
          },
          ConstraintVolatility::SeldomGreyed);
  
<span class="line-modified">!     m_constraintSet-&gt;add(makeUnique&lt;MarkStackMergingConstraint&gt;(*this));</span>
  }
  
  void Heap::addMarkingConstraint(std::unique_ptr&lt;MarkingConstraint&gt; constraint)
  {
      PreventCollectionScope preventCollectionScope(*this);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2834,11 ***</span>
      addCoreConstraints();
  
      m_isSafeToCollect = true;
  
      if (Options::collectContinuously()) {
<span class="line-modified">!         m_collectContinuouslyThread = WTF::Thread::create(</span>
              &quot;JSC DEBUG Continuous GC&quot;,
              [this] () {
                  MonotonicTime initialTime = MonotonicTime::now();
                  Seconds period = Seconds::fromMilliseconds(Options::collectContinuouslyPeriodMS());
                  while (!m_shouldStopCollectingContinuously) {
<span class="line-new-header">--- 2876,11 ---</span>
      addCoreConstraints();
  
      m_isSafeToCollect = true;
  
      if (Options::collectContinuously()) {
<span class="line-modified">!         m_collectContinuouslyThread = Thread::create(</span>
              &quot;JSC DEBUG Continuous GC&quot;,
              [this] () {
                  MonotonicTime initialTime = MonotonicTime::now();
                  Seconds period = Seconds::fromMilliseconds(Options::collectContinuouslyPeriodMS());
                  while (!m_shouldStopCollectingContinuously) {
</pre>
<center><a href="HandleSet.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Heap.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>