<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/JavaScriptCore/parser/ASTBuilder.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (C) 2010-2019 Apple Inc. All rights reserved.
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  * 1. Redistributions of source code must retain the above copyright
   8  *    notice, this list of conditions and the following disclaimer.
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
  14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
  15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
  17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
  23  * THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #pragma once
  27 
  28 #include &quot;BuiltinNames.h&quot;
  29 #include &quot;BytecodeIntrinsicRegistry.h&quot;
  30 #include &quot;MathCommon.h&quot;
  31 #include &quot;NodeConstructors.h&quot;
  32 #include &quot;SyntaxChecker.h&quot;
  33 #include &quot;VariableEnvironment.h&quot;
  34 #include &lt;utility&gt;
  35 
  36 namespace JSC {
  37 
  38 class ASTBuilder {
  39     struct BinaryOpInfo {
  40         BinaryOpInfo() {}
  41         BinaryOpInfo(const JSTextPosition&amp; otherStart, const JSTextPosition&amp; otherDivot, const JSTextPosition&amp; otherEnd, bool rhsHasAssignment)
  42             : start(otherStart)
  43             , divot(otherDivot)
  44             , end(otherEnd)
  45             , hasAssignment(rhsHasAssignment)
  46         {
  47         }
  48         BinaryOpInfo(const BinaryOpInfo&amp; lhs, const BinaryOpInfo&amp; rhs)
  49             : start(lhs.start)
  50             , divot(rhs.start)
  51             , end(rhs.end)
  52             , hasAssignment(lhs.hasAssignment || rhs.hasAssignment)
  53         {
  54         }
  55         JSTextPosition start;
  56         JSTextPosition divot;
  57         JSTextPosition end;
  58         bool hasAssignment;
  59     };
  60 
  61 
  62     struct AssignmentInfo {
  63         AssignmentInfo() {}
  64         AssignmentInfo(ExpressionNode* node, const JSTextPosition&amp; start, const JSTextPosition&amp; divot, int initAssignments, Operator op)
  65             : m_node(node)
  66             , m_start(start)
  67             , m_divot(divot)
  68             , m_initAssignments(initAssignments)
  69             , m_op(op)
  70         {
  71             ASSERT(m_divot.offset &gt;= m_divot.lineStartOffset);
  72             ASSERT(m_start.offset &gt;= m_start.lineStartOffset);
  73         }
  74         ExpressionNode* m_node;
  75         JSTextPosition m_start;
  76         JSTextPosition m_divot;
  77         int m_initAssignments;
  78         Operator m_op;
  79     };
  80 public:
  81     ASTBuilder(VM&amp; vm, ParserArena&amp; parserArena, SourceCode* sourceCode)
  82         : m_vm(vm)
  83         , m_parserArena(parserArena)
  84         , m_sourceCode(sourceCode)
  85         , m_evalCount(0)
  86     {
  87     }
  88 
  89     struct BinaryExprContext {
  90         BinaryExprContext(ASTBuilder&amp;) {}
  91     };
  92     struct UnaryExprContext {
  93         UnaryExprContext(ASTBuilder&amp;) {}
  94     };
  95 
  96     typedef ExpressionNode* Expression;
  97     typedef JSC::SourceElements* SourceElements;
  98     typedef ArgumentsNode* Arguments;
  99     typedef CommaNode* Comma;
 100     typedef PropertyNode* Property;
 101     typedef PropertyListNode* PropertyList;
 102     typedef ElementNode* ElementList;
 103     typedef ArgumentListNode* ArgumentsList;
 104     typedef TemplateExpressionListNode* TemplateExpressionList;
 105     typedef TemplateStringNode* TemplateString;
 106     typedef TemplateStringListNode* TemplateStringList;
 107     typedef TemplateLiteralNode* TemplateLiteral;
 108     typedef FunctionParameters* FormalParameterList;
 109     typedef FunctionMetadataNode* FunctionBody;
 110     typedef ClassExprNode* ClassExpression;
 111     typedef ModuleNameNode* ModuleName;
 112     typedef ImportSpecifierNode* ImportSpecifier;
 113     typedef ImportSpecifierListNode* ImportSpecifierList;
 114     typedef ExportSpecifierNode* ExportSpecifier;
 115     typedef ExportSpecifierListNode* ExportSpecifierList;
 116     typedef StatementNode* Statement;
 117     typedef ClauseListNode* ClauseList;
 118     typedef CaseClauseNode* Clause;
 119     typedef std::pair&lt;ExpressionNode*, BinaryOpInfo&gt; BinaryOperand;
 120     typedef DestructuringPatternNode* DestructuringPattern;
 121     typedef ArrayPatternNode* ArrayPattern;
 122     typedef ObjectPatternNode* ObjectPattern;
 123     typedef BindingNode* BindingPattern;
 124     typedef AssignmentElementNode* AssignmentElement;
 125     static const bool CreatesAST = true;
 126     static const bool NeedsFreeVariableInfo = true;
 127     static const bool CanUseFunctionCache = true;
 128     static const int  DontBuildKeywords = 0;
 129     static const int  DontBuildStrings = 0;
 130 
 131     ExpressionNode* makeBinaryNode(const JSTokenLocation&amp;, int token, std::pair&lt;ExpressionNode*, BinaryOpInfo&gt;, std::pair&lt;ExpressionNode*, BinaryOpInfo&gt;);
 132     ExpressionNode* makeFunctionCallNode(const JSTokenLocation&amp;, ExpressionNode* func, bool previousBaseWasSuper, ArgumentsNode* args, const JSTextPosition&amp; divotStart, const JSTextPosition&amp; divot, const JSTextPosition&amp; divotEnd, size_t callOrApplyChildDepth, bool isOptionalCall);
 133 
 134     JSC::SourceElements* createSourceElements() { return new (m_parserArena) JSC::SourceElements(); }
 135 
 136     int features() const { return m_scope.m_features; }
 137     int numConstants() const { return m_scope.m_numConstants; }
 138 
 139     ExpressionNode* makeAssignNode(const JSTokenLocation&amp;, ExpressionNode* left, Operator, ExpressionNode* right, bool leftHasAssignments, bool rightHasAssignments, const JSTextPosition&amp; start, const JSTextPosition&amp; divot, const JSTextPosition&amp; end);
 140     ExpressionNode* makePrefixNode(const JSTokenLocation&amp;, ExpressionNode*, Operator, const JSTextPosition&amp; start, const JSTextPosition&amp; divot, const JSTextPosition&amp; end);
 141     ExpressionNode* makePostfixNode(const JSTokenLocation&amp;, ExpressionNode*, Operator, const JSTextPosition&amp; start, const JSTextPosition&amp; divot, const JSTextPosition&amp; end);
 142     ExpressionNode* makeTypeOfNode(const JSTokenLocation&amp;, ExpressionNode*);
 143     ExpressionNode* makeDeleteNode(const JSTokenLocation&amp;, ExpressionNode*, const JSTextPosition&amp; start, const JSTextPosition&amp; divot, const JSTextPosition&amp; end);
 144     ExpressionNode* makeNegateNode(const JSTokenLocation&amp;, ExpressionNode*);
 145     ExpressionNode* makeBitwiseNotNode(const JSTokenLocation&amp;, ExpressionNode*);
 146     ExpressionNode* makePowNode(const JSTokenLocation&amp;, ExpressionNode* left, ExpressionNode* right, bool rightHasAssignments);
 147     ExpressionNode* makeMultNode(const JSTokenLocation&amp;, ExpressionNode* left, ExpressionNode* right, bool rightHasAssignments);
 148     ExpressionNode* makeDivNode(const JSTokenLocation&amp;, ExpressionNode* left, ExpressionNode* right, bool rightHasAssignments);
 149     ExpressionNode* makeModNode(const JSTokenLocation&amp;, ExpressionNode* left, ExpressionNode* right, bool rightHasAssignments);
 150     ExpressionNode* makeAddNode(const JSTokenLocation&amp;, ExpressionNode* left, ExpressionNode* right, bool rightHasAssignments);
 151     ExpressionNode* makeSubNode(const JSTokenLocation&amp;, ExpressionNode* left, ExpressionNode* right, bool rightHasAssignments);
 152     ExpressionNode* makeBitXOrNode(const JSTokenLocation&amp;, ExpressionNode* left, ExpressionNode* right, bool rightHasAssignments);
 153     ExpressionNode* makeBitAndNode(const JSTokenLocation&amp;, ExpressionNode* left, ExpressionNode* right, bool rightHasAssignments);
 154     ExpressionNode* makeBitOrNode(const JSTokenLocation&amp;, ExpressionNode* left, ExpressionNode* right, bool rightHasAssignments);
 155     ExpressionNode* makeCoalesceNode(const JSTokenLocation&amp;, ExpressionNode* left, ExpressionNode* right);
 156     ExpressionNode* makeLeftShiftNode(const JSTokenLocation&amp;, ExpressionNode* left, ExpressionNode* right, bool rightHasAssignments);
 157     ExpressionNode* makeRightShiftNode(const JSTokenLocation&amp;, ExpressionNode* left, ExpressionNode* right, bool rightHasAssignments);
 158     ExpressionNode* makeURightShiftNode(const JSTokenLocation&amp;, ExpressionNode* left, ExpressionNode* right, bool rightHasAssignments);
 159 
 160     ExpressionNode* createLogicalNot(const JSTokenLocation&amp; location, ExpressionNode* expr)
 161     {
 162         if (expr-&gt;isNumber())
 163             return createBoolean(location, isZeroOrUnordered(static_cast&lt;NumberNode*&gt;(expr)-&gt;value()));
 164 
 165         return new (m_parserArena) LogicalNotNode(location, expr);
 166     }
 167     ExpressionNode* createUnaryPlus(const JSTokenLocation&amp; location, ExpressionNode* expr) { return new (m_parserArena) UnaryPlusNode(location, expr); }
 168     ExpressionNode* createVoid(const JSTokenLocation&amp; location, ExpressionNode* expr)
 169     {
 170         incConstants();
 171         return new (m_parserArena) VoidNode(location, expr);
 172     }
 173     ExpressionNode* createThisExpr(const JSTokenLocation&amp; location)
 174     {
 175         usesThis();
 176         return new (m_parserArena) ThisNode(location);
 177     }
 178     ExpressionNode* createSuperExpr(const JSTokenLocation&amp; location)
 179     {
 180         return new (m_parserArena) SuperNode(location);
 181     }
 182     ExpressionNode* createImportExpr(const JSTokenLocation&amp; location, ExpressionNode* expr, const JSTextPosition&amp; start, const JSTextPosition&amp; divot, const JSTextPosition&amp; end)
 183     {
 184         auto* node = new (m_parserArena) ImportNode(location, expr);
 185         setExceptionLocation(node, start, divot, end);
 186         return node;
 187     }
 188     ExpressionNode* createNewTargetExpr(const JSTokenLocation location)
 189     {
 190         usesNewTarget();
 191         return new (m_parserArena) NewTargetNode(location);
 192     }
 193     ExpressionNode* createImportMetaExpr(const JSTokenLocation&amp; location, ExpressionNode* expr) { return new (m_parserArena) ImportMetaNode(location, expr); }
 194     bool isMetaProperty(ExpressionNode* node) { return node-&gt;isMetaProperty(); }
 195     bool isNewTarget(ExpressionNode* node) { return node-&gt;isNewTarget(); }
 196     bool isImportMeta(ExpressionNode* node) { return node-&gt;isImportMeta(); }
 197     ExpressionNode* createResolve(const JSTokenLocation&amp; location, const Identifier&amp; ident, const JSTextPosition&amp; start, const JSTextPosition&amp; end)
 198     {
 199         if (m_vm.propertyNames-&gt;arguments == ident)
 200             usesArguments();
 201 
 202         if (ident.isSymbol()) {
 203             if (BytecodeIntrinsicNode::EmitterType emitter = m_vm.bytecodeIntrinsicRegistry().lookup(ident))
 204                 return new (m_parserArena) BytecodeIntrinsicNode(BytecodeIntrinsicNode::Type::Constant, location, emitter, ident, nullptr, start, start, end);
 205         }
 206 
 207         return new (m_parserArena) ResolveNode(location, ident, start);
 208     }
 209     ExpressionNode* createObjectLiteral(const JSTokenLocation&amp; location) { return new (m_parserArena) ObjectLiteralNode(location); }
 210     ExpressionNode* createObjectLiteral(const JSTokenLocation&amp; location, PropertyListNode* properties) { return new (m_parserArena) ObjectLiteralNode(location, properties); }
 211 
 212     ExpressionNode* createArray(const JSTokenLocation&amp; location, int elisions)
 213     {
 214         if (elisions)
 215             incConstants();
 216         return new (m_parserArena) ArrayNode(location, elisions);
 217     }
 218 
 219     ExpressionNode* createArray(const JSTokenLocation&amp; location, ElementNode* elems) { return new (m_parserArena) ArrayNode(location, elems); }
 220     ExpressionNode* createArray(const JSTokenLocation&amp; location, int elisions, ElementNode* elems)
 221     {
 222         if (elisions)
 223             incConstants();
 224         return new (m_parserArena) ArrayNode(location, elisions, elems);
 225     }
 226     ExpressionNode* createDoubleExpr(const JSTokenLocation&amp; location, double d)
 227     {
 228         incConstants();
 229         return new (m_parserArena) DoubleNode(location, d);
 230     }
 231     ExpressionNode* createIntegerExpr(const JSTokenLocation&amp; location, double d)
 232     {
 233         incConstants();
 234         return new (m_parserArena) IntegerNode(location, d);
 235     }
 236 
 237     ExpressionNode* createBigInt(const JSTokenLocation&amp; location, const Identifier* bigInt, uint8_t radix)
 238     {
 239         incConstants();
 240         return new (m_parserArena) BigIntNode(location, *bigInt, radix);
 241     }
 242 
 243     ExpressionNode* createString(const JSTokenLocation&amp; location, const Identifier* string)
 244     {
 245         ASSERT(string);
 246         incConstants();
 247         return new (m_parserArena) StringNode(location, *string);
 248     }
 249 
 250     ExpressionNode* createBoolean(const JSTokenLocation&amp; location, bool b)
 251     {
 252         incConstants();
 253         return new (m_parserArena) BooleanNode(location, b);
 254     }
 255 
 256     ExpressionNode* createNull(const JSTokenLocation&amp; location)
 257     {
 258         incConstants();
 259         return new (m_parserArena) NullNode(location);
 260     }
 261 
 262     ExpressionNode* createBracketAccess(const JSTokenLocation&amp; location, ExpressionNode* base, ExpressionNode* property, bool propertyHasAssignments, const JSTextPosition&amp; start, const JSTextPosition&amp; divot, const JSTextPosition&amp; end)
 263     {
 264         if (base-&gt;isSuperNode())
 265             usesSuperProperty();
 266 
 267         BracketAccessorNode* node = new (m_parserArena) BracketAccessorNode(location, base, property, propertyHasAssignments);
 268         setExceptionLocation(node, start, divot, end);
 269         return node;
 270     }
 271 
 272     ExpressionNode* createDotAccess(const JSTokenLocation&amp; location, ExpressionNode* base, const Identifier* property, const JSTextPosition&amp; start, const JSTextPosition&amp; divot, const JSTextPosition&amp; end)
 273     {
 274         if (base-&gt;isSuperNode())
 275             usesSuperProperty();
 276 
 277         DotAccessorNode* node = new (m_parserArena) DotAccessorNode(location, base, *property);
 278         setExceptionLocation(node, start, divot, end);
 279         return node;
 280     }
 281 
 282     ExpressionNode* createSpreadExpression(const JSTokenLocation&amp; location, ExpressionNode* expression, const JSTextPosition&amp; start, const JSTextPosition&amp; divot, const JSTextPosition&amp; end)
 283     {
 284         auto node = new (m_parserArena) SpreadExpressionNode(location, expression);
 285         setExceptionLocation(node, start, divot, end);
 286         return node;
 287     }
 288 
 289     ExpressionNode* createObjectSpreadExpression(const JSTokenLocation&amp; location, ExpressionNode* expression, const JSTextPosition&amp; start, const JSTextPosition&amp; divot, const JSTextPosition&amp; end)
 290     {
 291         auto node = new (m_parserArena) ObjectSpreadExpressionNode(location, expression);
 292         setExceptionLocation(node, start, divot, end);
 293         return node;
 294     }
 295 
 296     TemplateStringNode* createTemplateString(const JSTokenLocation&amp; location, const Identifier* cooked, const Identifier* raw)
 297     {
 298         return new (m_parserArena) TemplateStringNode(location, cooked, raw);
 299     }
 300 
 301     TemplateStringListNode* createTemplateStringList(TemplateStringNode* templateString)
 302     {
 303         return new (m_parserArena) TemplateStringListNode(templateString);
 304     }
 305 
 306     TemplateStringListNode* createTemplateStringList(TemplateStringListNode* templateStringList, TemplateStringNode* templateString)
 307     {
 308         return new (m_parserArena) TemplateStringListNode(templateStringList, templateString);
 309     }
 310 
 311     TemplateExpressionListNode* createTemplateExpressionList(ExpressionNode* expression)
 312     {
 313         return new (m_parserArena) TemplateExpressionListNode(expression);
 314     }
 315 
 316     TemplateExpressionListNode* createTemplateExpressionList(TemplateExpressionListNode* templateExpressionListNode, ExpressionNode* expression)
 317     {
 318         return new (m_parserArena) TemplateExpressionListNode(templateExpressionListNode, expression);
 319     }
 320 
 321     TemplateLiteralNode* createTemplateLiteral(const JSTokenLocation&amp; location, TemplateStringListNode* templateStringList)
 322     {
 323         return new (m_parserArena) TemplateLiteralNode(location, templateStringList);
 324     }
 325 
 326     TemplateLiteralNode* createTemplateLiteral(const JSTokenLocation&amp; location, TemplateStringListNode* templateStringList, TemplateExpressionListNode* templateExpressionList)
 327     {
 328         return new (m_parserArena) TemplateLiteralNode(location, templateStringList, templateExpressionList);
 329     }
 330 
 331     ExpressionNode* createTaggedTemplate(const JSTokenLocation&amp; location, ExpressionNode* base, TemplateLiteralNode* templateLiteral, const JSTextPosition&amp; start, const JSTextPosition&amp; divot, const JSTextPosition&amp; end)
 332     {
 333         auto node = new (m_parserArena) TaggedTemplateNode(location, base, templateLiteral);
 334         setExceptionLocation(node, start, divot, end);
 335         setEndOffset(node, end.offset);
 336         return node;
 337     }
 338 
 339     ExpressionNode* createRegExp(const JSTokenLocation&amp; location, const Identifier&amp; pattern, const Identifier&amp; flags, const JSTextPosition&amp; start)
 340     {
 341         if (Yarr::hasError(Yarr::checkSyntax(pattern.string(), flags.string())))
 342             return 0;
 343         RegExpNode* node = new (m_parserArena) RegExpNode(location, pattern, flags);
 344         int size = pattern.length() + 2; // + 2 for the two /&#39;s
 345         JSTextPosition end = start + size;
 346         setExceptionLocation(node, start, end, end);
 347         return node;
 348     }
 349 
 350     ExpressionNode* createNewExpr(const JSTokenLocation&amp; location, ExpressionNode* expr, ArgumentsNode* arguments, const JSTextPosition&amp; start, const JSTextPosition&amp; divot, const JSTextPosition&amp; end)
 351     {
 352         NewExprNode* node = new (m_parserArena) NewExprNode(location, expr, arguments);
 353         setExceptionLocation(node, start, divot, end);
 354         return node;
 355     }
 356 
 357     ExpressionNode* createNewExpr(const JSTokenLocation&amp; location, ExpressionNode* expr, const JSTextPosition&amp; start, const JSTextPosition&amp; end)
 358     {
 359         NewExprNode* node = new (m_parserArena) NewExprNode(location, expr);
 360         setExceptionLocation(node, start, end, end);
 361         return node;
 362     }
 363 
 364     ExpressionNode* createOptionalChain(const JSTokenLocation&amp; location, ExpressionNode* base, ExpressionNode* expr, bool isOutermost)
 365     {
 366         base-&gt;setIsOptionalChainBase();
 367         return new (m_parserArena) OptionalChainNode(location, expr, isOutermost);
 368     }
 369 
 370     ExpressionNode* createConditionalExpr(const JSTokenLocation&amp; location, ExpressionNode* condition, ExpressionNode* lhs, ExpressionNode* rhs)
 371     {
 372         return new (m_parserArena) ConditionalNode(location, condition, lhs, rhs);
 373     }
 374 
 375     ExpressionNode* createAssignResolve(const JSTokenLocation&amp; location, const Identifier&amp; ident, ExpressionNode* rhs, const JSTextPosition&amp; start, const JSTextPosition&amp; divot, const JSTextPosition&amp; end, AssignmentContext assignmentContext)
 376     {
 377         if (rhs-&gt;isBaseFuncExprNode()) {
 378             auto metadata = static_cast&lt;BaseFuncExprNode*&gt;(rhs)-&gt;metadata();
 379             metadata-&gt;setEcmaName(ident);
 380         } else if (rhs-&gt;isClassExprNode())
 381             static_cast&lt;ClassExprNode*&gt;(rhs)-&gt;setEcmaName(ident);
 382         AssignResolveNode* node = new (m_parserArena) AssignResolveNode(location, ident, rhs, assignmentContext);
 383         setExceptionLocation(node, start, divot, end);
 384         return node;
 385     }
 386 
 387     YieldExprNode* createYield(const JSTokenLocation&amp; location)
 388     {
 389         return new (m_parserArena) YieldExprNode(location, nullptr, /* delegate */ false);
 390     }
 391 
 392     YieldExprNode* createYield(const JSTokenLocation&amp; location, ExpressionNode* argument, bool delegate, const JSTextPosition&amp; start, const JSTextPosition&amp; divot, const JSTextPosition&amp; end)
 393     {
 394         YieldExprNode* node = new (m_parserArena) YieldExprNode(location, argument, delegate);
 395         setExceptionLocation(node, start, divot, end);
 396         return node;
 397     }
 398 
 399     AwaitExprNode* createAwait(const JSTokenLocation&amp; location, ExpressionNode* argument, const JSTextPosition&amp; start, const JSTextPosition&amp; divot, const JSTextPosition&amp; end)
 400     {
 401         ASSERT(argument);
 402         AwaitExprNode* node = new (m_parserArena) AwaitExprNode(location, argument);
 403         setExceptionLocation(node, start, divot, end);
 404         return node;
 405     }
 406 
 407     ClassExprNode* createClassExpr(const JSTokenLocation&amp; location, const ParserClassInfo&lt;ASTBuilder&gt;&amp; classInfo, VariableEnvironment&amp; classEnvironment, ExpressionNode* constructor,
 408         ExpressionNode* parentClass, PropertyListNode* classElements)
 409     {
 410         SourceCode source = m_sourceCode-&gt;subExpression(classInfo.startOffset, classInfo.endOffset, classInfo.startLine, classInfo.startColumn);
 411         return new (m_parserArena) ClassExprNode(location, *classInfo.className, source, classEnvironment, constructor, parentClass, classElements);
 412     }
 413 
 414     ExpressionNode* createFunctionExpr(const JSTokenLocation&amp; location, const ParserFunctionInfo&lt;ASTBuilder&gt;&amp; functionInfo)
 415     {
 416         FuncExprNode* result = new (m_parserArena) FuncExprNode(location, *functionInfo.name, functionInfo.body,
 417             m_sourceCode-&gt;subExpression(functionInfo.startOffset, functionInfo.endOffset, functionInfo.startLine, functionInfo.parametersStartColumn));
 418         functionInfo.body-&gt;setLoc(functionInfo.startLine, functionInfo.endLine, location.startOffset, location.lineStartOffset);
 419         return result;
 420     }
 421 
 422     ExpressionNode* createGeneratorFunctionBody(const JSTokenLocation&amp; location, const ParserFunctionInfo&lt;ASTBuilder&gt;&amp; functionInfo, const Identifier&amp; name)
 423     {
 424         FuncExprNode* result = static_cast&lt;FuncExprNode*&gt;(createFunctionExpr(location, functionInfo));
 425         if (!name.isNull())
 426             result-&gt;metadata()-&gt;setEcmaName(name);
 427         return result;
 428     }
 429 
 430     ExpressionNode* createAsyncFunctionBody(const JSTokenLocation&amp; location, const ParserFunctionInfo&lt;ASTBuilder&gt;&amp; functionInfo, SourceParseMode parseMode)
 431     {
 432         if (parseMode == SourceParseMode::AsyncArrowFunctionBodyMode) {
 433             SourceCode source = m_sourceCode-&gt;subExpression(functionInfo.startOffset, functionInfo.body-&gt;isArrowFunctionBodyExpression() ? functionInfo.endOffset - 1 : functionInfo.endOffset, functionInfo.startLine, functionInfo.parametersStartColumn);
 434             FuncExprNode* result = new (m_parserArena) FuncExprNode(location, *functionInfo.name, functionInfo.body, source);
 435             functionInfo.body-&gt;setLoc(functionInfo.startLine, functionInfo.endLine, location.startOffset, location.lineStartOffset);
 436             return result;
 437         }
 438         return createFunctionExpr(location, functionInfo);
 439     }
 440 
 441     ExpressionNode* createMethodDefinition(const JSTokenLocation&amp; location, const ParserFunctionInfo&lt;ASTBuilder&gt;&amp; functionInfo)
 442     {
 443         MethodDefinitionNode* result = new (m_parserArena) MethodDefinitionNode(location, *functionInfo.name, functionInfo.body,
 444             m_sourceCode-&gt;subExpression(functionInfo.startOffset, functionInfo.endOffset, functionInfo.startLine, functionInfo.parametersStartColumn));
 445         functionInfo.body-&gt;setLoc(functionInfo.startLine, functionInfo.endLine, location.startOffset, location.lineStartOffset);
 446         return result;
 447     }
 448 
 449     FunctionMetadataNode* createFunctionMetadata(
 450         const JSTokenLocation&amp; startLocation, const JSTokenLocation&amp; endLocation,
 451         unsigned startColumn, unsigned endColumn, int functionKeywordStart,
 452         int functionNameStart, int parametersStart, bool inStrictContext,
 453         ConstructorKind constructorKind, SuperBinding superBinding,
 454         unsigned parameterCount,
 455         SourceParseMode mode, bool isArrowFunctionBodyExpression)
 456     {
 457         return new (m_parserArena) FunctionMetadataNode(
 458             m_parserArena, startLocation, endLocation, startColumn, endColumn,
 459             functionKeywordStart, functionNameStart, parametersStart,
 460             inStrictContext, constructorKind, superBinding,
 461             parameterCount, mode, isArrowFunctionBodyExpression);
 462     }
 463 
 464     ExpressionNode* createArrowFunctionExpr(const JSTokenLocation&amp; location, const ParserFunctionInfo&lt;ASTBuilder&gt;&amp; functionInfo)
 465     {
 466         usesArrowFunction();
 467         SourceCode source = m_sourceCode-&gt;subExpression(functionInfo.startOffset, functionInfo.body-&gt;isArrowFunctionBodyExpression() ? functionInfo.endOffset - 1 : functionInfo.endOffset, functionInfo.startLine, functionInfo.parametersStartColumn);
 468         ArrowFuncExprNode* result = new (m_parserArena) ArrowFuncExprNode(location, *functionInfo.name, functionInfo.body, source);
 469         functionInfo.body-&gt;setLoc(functionInfo.startLine, functionInfo.endLine, location.startOffset, location.lineStartOffset);
 470         return result;
 471     }
 472 
 473     ArgumentsNode* createArguments() { return new (m_parserArena) ArgumentsNode(); }
 474     ArgumentsNode* createArguments(ArgumentListNode* args) { return new (m_parserArena) ArgumentsNode(args); }
 475     ArgumentListNode* createArgumentsList(const JSTokenLocation&amp; location, ExpressionNode* arg) { return new (m_parserArena) ArgumentListNode(location, arg); }
 476     ArgumentListNode* createArgumentsList(const JSTokenLocation&amp; location, ArgumentListNode* args, ExpressionNode* arg) { return new (m_parserArena) ArgumentListNode(location, args, arg); }
 477 
 478     NEVER_INLINE PropertyNode* createGetterOrSetterProperty(const JSTokenLocation&amp; location, PropertyNode::Type type, bool,
 479         const Identifier* name, const ParserFunctionInfo&lt;ASTBuilder&gt;&amp; functionInfo, ClassElementTag tag)
 480     {
 481         ASSERT(name);
 482         functionInfo.body-&gt;setLoc(functionInfo.startLine, functionInfo.endLine, location.startOffset, location.lineStartOffset);
 483         functionInfo.body-&gt;setEcmaName(*name);
 484         SourceCode source = m_sourceCode-&gt;subExpression(functionInfo.startOffset, functionInfo.endOffset, functionInfo.startLine, functionInfo.parametersStartColumn);
 485         MethodDefinitionNode* methodDef = new (m_parserArena) MethodDefinitionNode(location, m_vm.propertyNames-&gt;nullIdentifier, functionInfo.body, source);
 486         return new (m_parserArena) PropertyNode(*name, methodDef, type, PropertyNode::Unknown, SuperBinding::Needed, tag);
 487     }
 488 
 489     NEVER_INLINE PropertyNode* createGetterOrSetterProperty(const JSTokenLocation&amp; location, PropertyNode::Type type, bool,
 490         ExpressionNode* name, const ParserFunctionInfo&lt;ASTBuilder&gt;&amp; functionInfo, ClassElementTag tag)
 491     {
 492         ASSERT(name);
 493         functionInfo.body-&gt;setLoc(functionInfo.startLine, functionInfo.endLine, location.startOffset, location.lineStartOffset);
 494         SourceCode source = m_sourceCode-&gt;subExpression(functionInfo.startOffset, functionInfo.endOffset, functionInfo.startLine, functionInfo.parametersStartColumn);
 495         MethodDefinitionNode* methodDef = new (m_parserArena) MethodDefinitionNode(location, m_vm.propertyNames-&gt;nullIdentifier, functionInfo.body, source);
 496         return new (m_parserArena) PropertyNode(name, methodDef, type, PropertyNode::Unknown, SuperBinding::Needed, tag);
 497     }
 498 
 499     NEVER_INLINE PropertyNode* createGetterOrSetterProperty(VM&amp; vm, ParserArena&amp; parserArena, const JSTokenLocation&amp; location, PropertyNode::Type type, bool,
 500         double name, const ParserFunctionInfo&lt;ASTBuilder&gt;&amp; functionInfo, ClassElementTag tag)
 501     {
 502         functionInfo.body-&gt;setLoc(functionInfo.startLine, functionInfo.endLine, location.startOffset, location.lineStartOffset);
 503         const Identifier&amp; ident = parserArena.identifierArena().makeNumericIdentifier(vm, name);
 504         SourceCode source = m_sourceCode-&gt;subExpression(functionInfo.startOffset, functionInfo.endOffset, functionInfo.startLine, functionInfo.parametersStartColumn);
 505         MethodDefinitionNode* methodDef = new (m_parserArena) MethodDefinitionNode(location, vm.propertyNames-&gt;nullIdentifier, functionInfo.body, source);
 506         return new (m_parserArena) PropertyNode(ident, methodDef, type, PropertyNode::Unknown, SuperBinding::Needed, tag);
 507     }
 508 
 509     PropertyNode* createProperty(const Identifier* propertyName, ExpressionNode* node, PropertyNode::Type type, PropertyNode::PutType putType, bool, SuperBinding superBinding, InferName inferName, ClassElementTag tag)
 510     {
 511         if (inferName == InferName::Allowed) {
 512             if (node-&gt;isBaseFuncExprNode()) {
 513                 auto metadata = static_cast&lt;BaseFuncExprNode*&gt;(node)-&gt;metadata();
 514                 metadata-&gt;setEcmaName(*propertyName);
 515             } else if (node-&gt;isClassExprNode())
 516                 static_cast&lt;ClassExprNode*&gt;(node)-&gt;setEcmaName(*propertyName);
 517         }
 518         return new (m_parserArena) PropertyNode(*propertyName, node, type, putType, superBinding, tag);
 519     }
 520     PropertyNode* createProperty(ExpressionNode* node, PropertyNode::Type type, PropertyNode::PutType putType, bool, SuperBinding superBinding, ClassElementTag tag)
 521     {
 522         return new (m_parserArena) PropertyNode(node, type, putType, superBinding, tag);
 523     }
 524     PropertyNode* createProperty(VM&amp; vm, ParserArena&amp; parserArena, double propertyName, ExpressionNode* node, PropertyNode::Type type, PropertyNode::PutType putType, bool, SuperBinding superBinding, ClassElementTag tag)
 525     {
 526         return new (m_parserArena) PropertyNode(parserArena.identifierArena().makeNumericIdentifier(vm, propertyName), node, type, putType, superBinding, tag);
 527     }
 528     PropertyNode* createProperty(ExpressionNode* propertyName, ExpressionNode* node, PropertyNode::Type type, PropertyNode::PutType putType, bool, SuperBinding superBinding, ClassElementTag tag) { return new (m_parserArena) PropertyNode(propertyName, node, type, putType, superBinding, tag); }
 529     PropertyListNode* createPropertyList(const JSTokenLocation&amp; location, PropertyNode* property) { return new (m_parserArena) PropertyListNode(location, property); }
 530     PropertyListNode* createPropertyList(const JSTokenLocation&amp; location, PropertyNode* property, PropertyListNode* tail) { return new (m_parserArena) PropertyListNode(location, property, tail); }
 531 
 532     ElementNode* createElementList(int elisions, ExpressionNode* expr) { return new (m_parserArena) ElementNode(elisions, expr); }
 533     ElementNode* createElementList(ElementNode* elems, int elisions, ExpressionNode* expr) { return new (m_parserArena) ElementNode(elems, elisions, expr); }
 534     ElementNode* createElementList(ArgumentListNode* elems)
 535     {
 536         ElementNode* head = new (m_parserArena) ElementNode(0, elems-&gt;m_expr);
 537         ElementNode* tail = head;
 538         elems = elems-&gt;m_next;
 539         while (elems) {
 540             tail = new (m_parserArena) ElementNode(tail, 0, elems-&gt;m_expr);
 541             elems = elems-&gt;m_next;
 542         }
 543         return head;
 544     }
 545 
 546     FormalParameterList createFormalParameterList() { return new (m_parserArena) FunctionParameters(); }
 547     void appendParameter(FormalParameterList list, DestructuringPattern pattern, ExpressionNode* defaultValue)
 548     {
 549         list-&gt;append(pattern, defaultValue);
 550         tryInferNameInPattern(pattern, defaultValue);
 551     }
 552 
 553     CaseClauseNode* createClause(ExpressionNode* expr, JSC::SourceElements* statements) { return new (m_parserArena) CaseClauseNode(expr, statements); }
 554     ClauseListNode* createClauseList(CaseClauseNode* clause) { return new (m_parserArena) ClauseListNode(clause); }
 555     ClauseListNode* createClauseList(ClauseListNode* tail, CaseClauseNode* clause) { return new (m_parserArena) ClauseListNode(tail, clause); }
 556 
 557     StatementNode* createFuncDeclStatement(const JSTokenLocation&amp; location, const ParserFunctionInfo&lt;ASTBuilder&gt;&amp; functionInfo)
 558     {
 559         FuncDeclNode* decl = new (m_parserArena) FuncDeclNode(location, *functionInfo.name, functionInfo.body,
 560             m_sourceCode-&gt;subExpression(functionInfo.startOffset, functionInfo.endOffset, functionInfo.startLine, functionInfo.parametersStartColumn));
 561         if (*functionInfo.name == m_vm.propertyNames-&gt;arguments)
 562             usesArguments();
 563         functionInfo.body-&gt;setLoc(functionInfo.startLine, functionInfo.endLine, location.startOffset, location.lineStartOffset);
 564         return decl;
 565     }
 566 
 567     StatementNode* createClassDeclStatement(const JSTokenLocation&amp; location, ClassExprNode* classExpression,
 568         const JSTextPosition&amp; classStart, const JSTextPosition&amp; classEnd, unsigned startLine, unsigned endLine)
 569     {
 570         ExpressionNode* assign = createAssignResolve(location, classExpression-&gt;name(), classExpression, classStart, classStart + 1, classEnd, AssignmentContext::DeclarationStatement);
 571         ClassDeclNode* decl = new (m_parserArena) ClassDeclNode(location, assign);
 572         decl-&gt;setLoc(startLine, endLine, location.startOffset, location.lineStartOffset);
 573         return decl;
 574     }
 575 
 576     StatementNode* createBlockStatement(const JSTokenLocation&amp; location, JSC::SourceElements* elements, int startLine, int endLine, VariableEnvironment&amp; lexicalVariables, DeclarationStacks::FunctionStack&amp;&amp; functionStack)
 577     {
 578         BlockNode* block = new (m_parserArena) BlockNode(location, elements, lexicalVariables, WTFMove(functionStack));
 579         block-&gt;setLoc(startLine, endLine, location.startOffset, location.lineStartOffset);
 580         return block;
 581     }
 582 
 583     StatementNode* createExprStatement(const JSTokenLocation&amp; location, ExpressionNode* expr, const JSTextPosition&amp; start, int end)
 584     {
 585         ExprStatementNode* result = new (m_parserArena) ExprStatementNode(location, expr);
 586         result-&gt;setLoc(start.line, end, start.offset, start.lineStartOffset);
 587         return result;
 588     }
 589 
 590     StatementNode* createIfStatement(const JSTokenLocation&amp; location, ExpressionNode* condition, StatementNode* trueBlock, StatementNode* falseBlock, int start, int end)
 591     {
 592         IfElseNode* result = new (m_parserArena) IfElseNode(location, condition, trueBlock, falseBlock);
 593         result-&gt;setLoc(start, end, location.startOffset, location.lineStartOffset);
 594         return result;
 595     }
 596 
 597     StatementNode* createForLoop(const JSTokenLocation&amp; location, ExpressionNode* initializer, ExpressionNode* condition, ExpressionNode* iter, StatementNode* statements, int start, int end, VariableEnvironment&amp; lexicalVariables)
 598     {
 599         ForNode* result = new (m_parserArena) ForNode(location, initializer, condition, iter, statements, lexicalVariables);
 600         result-&gt;setLoc(start, end, location.startOffset, location.lineStartOffset);
 601         return result;
 602     }
 603 
 604     StatementNode* createForInLoop(const JSTokenLocation&amp; location, ExpressionNode* lhs, ExpressionNode* iter, StatementNode* statements, const JSTokenLocation&amp;, const JSTextPosition&amp; eStart, const JSTextPosition&amp; eDivot, const JSTextPosition&amp; eEnd, int start, int end, VariableEnvironment&amp; lexicalVariables)
 605     {
 606         ForInNode* result = new (m_parserArena) ForInNode(location, lhs, iter, statements, lexicalVariables);
 607         result-&gt;setLoc(start, end, location.startOffset, location.lineStartOffset);
 608         setExceptionLocation(result, eStart, eDivot, eEnd);
 609         return result;
 610     }
 611 
 612     StatementNode* createForInLoop(const JSTokenLocation&amp; location, DestructuringPatternNode* pattern, ExpressionNode* iter, StatementNode* statements, const JSTokenLocation&amp; declLocation, const JSTextPosition&amp; eStart, const JSTextPosition&amp; eDivot, const JSTextPosition&amp; eEnd, int start, int end, VariableEnvironment&amp; lexicalVariables)
 613     {
 614         auto lexpr = new (m_parserArena) DestructuringAssignmentNode(declLocation, pattern, nullptr);
 615         return createForInLoop(location, lexpr, iter, statements, declLocation, eStart, eDivot, eEnd, start, end, lexicalVariables);
 616     }
 617 
 618     StatementNode* createForOfLoop(bool isForAwait, const JSTokenLocation&amp; location, ExpressionNode* lhs, ExpressionNode* iter, StatementNode* statements, const JSTokenLocation&amp;, const JSTextPosition&amp; eStart, const JSTextPosition&amp; eDivot, const JSTextPosition&amp; eEnd, int start, int end, VariableEnvironment&amp; lexicalVariables)
 619     {
 620         ForOfNode* result = new (m_parserArena) ForOfNode(isForAwait, location, lhs, iter, statements, lexicalVariables);
 621         result-&gt;setLoc(start, end, location.startOffset, location.lineStartOffset);
 622         setExceptionLocation(result, eStart, eDivot, eEnd);
 623         return result;
 624     }
 625 
 626     StatementNode* createForOfLoop(bool isForAwait, const JSTokenLocation&amp; location, DestructuringPatternNode* pattern, ExpressionNode* iter, StatementNode* statements, const JSTokenLocation&amp; declLocation, const JSTextPosition&amp; eStart, const JSTextPosition&amp; eDivot, const JSTextPosition&amp; eEnd, int start, int end, VariableEnvironment&amp; lexicalVariables)
 627     {
 628         auto lexpr = new (m_parserArena) DestructuringAssignmentNode(declLocation, pattern, nullptr);
 629         return createForOfLoop(isForAwait, location, lexpr, iter, statements, declLocation, eStart, eDivot, eEnd, start, end, lexicalVariables);
 630     }
 631 
 632     bool isBindingNode(const DestructuringPattern&amp; pattern)
 633     {
 634         return pattern-&gt;isBindingNode();
 635     }
 636 
 637     bool isLocation(const Expression&amp; node)
 638     {
 639         return node-&gt;isLocation();
 640     }
 641 
 642     bool isAssignmentLocation(const Expression&amp; node)
 643     {
 644         return node-&gt;isAssignmentLocation();
 645     }
 646 
 647     bool isObjectLiteral(const Expression&amp; node)
 648     {
 649         return node-&gt;isObjectLiteral();
 650     }
 651 
 652     bool isArrayLiteral(const Expression&amp; node)
 653     {
 654         return node-&gt;isArrayLiteral();
 655     }
 656 
 657     bool isObjectOrArrayLiteral(const Expression&amp; node)
 658     {
 659         return isObjectLiteral(node) || isArrayLiteral(node);
 660     }
 661 
 662     bool isFunctionCall(const Expression&amp; node)
 663     {
 664         return node-&gt;isFunctionCall();
 665     }
 666 
 667     bool shouldSkipPauseLocation(StatementNode* statement) const
 668     {
 669         return !statement || statement-&gt;isLabel();
 670     }
 671 
 672     StatementNode* createEmptyStatement(const JSTokenLocation&amp; location) { return new (m_parserArena) EmptyStatementNode(location); }
 673 
 674     StatementNode* createDeclarationStatement(const JSTokenLocation&amp; location, ExpressionNode* expr, int start, int end)
 675     {
 676         StatementNode* result;
 677         result = new (m_parserArena) DeclarationStatement(location, expr);
 678         result-&gt;setLoc(start, end, location.startOffset, location.lineStartOffset);
 679         return result;
 680     }
 681 
 682     ExpressionNode* createEmptyVarExpression(const JSTokenLocation&amp; location, const Identifier&amp; identifier)
 683     {
 684         return new (m_parserArena) EmptyVarExpression(location, identifier);
 685     }
 686 
 687     ExpressionNode* createEmptyLetExpression(const JSTokenLocation&amp; location, const Identifier&amp; identifier)
 688     {
 689         return new (m_parserArena) EmptyLetExpression(location, identifier);
 690     }
 691 
 692     StatementNode* createReturnStatement(const JSTokenLocation&amp; location, ExpressionNode* expression, const JSTextPosition&amp; start, const JSTextPosition&amp; end)
 693     {
 694         ReturnNode* result = new (m_parserArena) ReturnNode(location, expression);
 695         setExceptionLocation(result, start, end, end);
 696         result-&gt;setLoc(start.line, end.line, start.offset, start.lineStartOffset);
 697         return result;
 698     }
 699 
 700     StatementNode* createBreakStatement(const JSTokenLocation&amp; location, const Identifier* ident, const JSTextPosition&amp; start, const JSTextPosition&amp; end)
 701     {
 702         BreakNode* result = new (m_parserArena) BreakNode(location, *ident);
 703         setExceptionLocation(result, start, end, end);
 704         result-&gt;setLoc(start.line, end.line, start.offset, start.lineStartOffset);
 705         return result;
 706     }
 707 
 708     StatementNode* createContinueStatement(const JSTokenLocation&amp; location, const Identifier* ident, const JSTextPosition&amp; start, const JSTextPosition&amp; end)
 709     {
 710         ContinueNode* result = new (m_parserArena) ContinueNode(location, *ident);
 711         setExceptionLocation(result, start, end, end);
 712         result-&gt;setLoc(start.line, end.line, start.offset, start.lineStartOffset);
 713         return result;
 714     }
 715 
 716     StatementNode* createTryStatement(const JSTokenLocation&amp; location, StatementNode* tryBlock, DestructuringPatternNode* catchPattern, StatementNode* catchBlock, StatementNode* finallyBlock, int startLine, int endLine, VariableEnvironment&amp; catchEnvironment)
 717     {
 718         TryNode* result = new (m_parserArena) TryNode(location, tryBlock, catchPattern, catchBlock, catchEnvironment, finallyBlock);
 719         result-&gt;setLoc(startLine, endLine, location.startOffset, location.lineStartOffset);
 720         return result;
 721     }
 722 
 723     StatementNode* createSwitchStatement(const JSTokenLocation&amp; location, ExpressionNode* expr, ClauseListNode* firstClauses, CaseClauseNode* defaultClause, ClauseListNode* secondClauses, int startLine, int endLine, VariableEnvironment&amp; lexicalVariables, DeclarationStacks::FunctionStack&amp;&amp; functionStack)
 724     {
 725         CaseBlockNode* cases = new (m_parserArena) CaseBlockNode(firstClauses, defaultClause, secondClauses);
 726         SwitchNode* result = new (m_parserArena) SwitchNode(location, expr, cases, lexicalVariables, WTFMove(functionStack));
 727         result-&gt;setLoc(startLine, endLine, location.startOffset, location.lineStartOffset);
 728         return result;
 729     }
 730 
 731     StatementNode* createWhileStatement(const JSTokenLocation&amp; location, ExpressionNode* expr, StatementNode* statement, int startLine, int endLine)
 732     {
 733         WhileNode* result = new (m_parserArena) WhileNode(location, expr, statement);
 734         result-&gt;setLoc(startLine, endLine, location.startOffset, location.lineStartOffset);
 735         return result;
 736     }
 737 
 738     StatementNode* createDoWhileStatement(const JSTokenLocation&amp; location, StatementNode* statement, ExpressionNode* expr, int startLine, int endLine)
 739     {
 740         DoWhileNode* result = new (m_parserArena) DoWhileNode(location, statement, expr);
 741         result-&gt;setLoc(startLine, endLine, location.startOffset, location.lineStartOffset);
 742         return result;
 743     }
 744 
 745     StatementNode* createLabelStatement(const JSTokenLocation&amp; location, const Identifier* ident, StatementNode* statement, const JSTextPosition&amp; start, const JSTextPosition&amp; end)
 746     {
 747         LabelNode* result = new (m_parserArena) LabelNode(location, *ident, statement);
 748         setExceptionLocation(result, start, end, end);
 749         return result;
 750     }
 751 
 752     StatementNode* createWithStatement(const JSTokenLocation&amp; location, ExpressionNode* expr, StatementNode* statement, unsigned start, const JSTextPosition&amp; end, unsigned startLine, unsigned endLine)
 753     {
 754         usesWith();
 755         WithNode* result = new (m_parserArena) WithNode(location, expr, statement, end, end - start);
 756         result-&gt;setLoc(startLine, endLine, location.startOffset, location.lineStartOffset);
 757         return result;
 758     }
 759 
 760     StatementNode* createThrowStatement(const JSTokenLocation&amp; location, ExpressionNode* expr, const JSTextPosition&amp; start, const JSTextPosition&amp; end)
 761     {
 762         ThrowNode* result = new (m_parserArena) ThrowNode(location, expr);
 763         result-&gt;setLoc(start.line, end.line, start.offset, start.lineStartOffset);
 764         setExceptionLocation(result, start, end, end);
 765         return result;
 766     }
 767 
 768     StatementNode* createDebugger(const JSTokenLocation&amp; location, int startLine, int endLine)
 769     {
 770         DebuggerStatementNode* result = new (m_parserArena) DebuggerStatementNode(location);
 771         result-&gt;setLoc(startLine, endLine, location.startOffset, location.lineStartOffset);
 772         return result;
 773     }
 774 
 775     ModuleNameNode* createModuleName(const JSTokenLocation&amp; location, const Identifier&amp; moduleName)
 776     {
 777         return new (m_parserArena) ModuleNameNode(location, moduleName);
 778     }
 779 
 780     ImportSpecifierNode* createImportSpecifier(const JSTokenLocation&amp; location, const Identifier&amp; importedName, const Identifier&amp; localName)
 781     {
 782         return new (m_parserArena) ImportSpecifierNode(location, importedName, localName);
 783     }
 784 
 785     ImportSpecifierListNode* createImportSpecifierList()
 786     {
 787         return new (m_parserArena) ImportSpecifierListNode();
 788     }
 789 
 790     void appendImportSpecifier(ImportSpecifierListNode* specifierList, ImportSpecifierNode* specifier)
 791     {
 792         specifierList-&gt;append(specifier);
 793     }
 794 
 795     StatementNode* createImportDeclaration(const JSTokenLocation&amp; location, ImportSpecifierListNode* importSpecifierList, ModuleNameNode* moduleName)
 796     {
 797         return new (m_parserArena) ImportDeclarationNode(location, importSpecifierList, moduleName);
 798     }
 799 
 800     StatementNode* createExportAllDeclaration(const JSTokenLocation&amp; location, ModuleNameNode* moduleName)
 801     {
 802         return new (m_parserArena) ExportAllDeclarationNode(location, moduleName);
 803     }
 804 
 805     StatementNode* createExportDefaultDeclaration(const JSTokenLocation&amp; location, StatementNode* declaration, const Identifier&amp; localName)
 806     {
 807         return new (m_parserArena) ExportDefaultDeclarationNode(location, declaration, localName);
 808     }
 809 
 810     StatementNode* createExportLocalDeclaration(const JSTokenLocation&amp; location, StatementNode* declaration)
 811     {
 812         return new (m_parserArena) ExportLocalDeclarationNode(location, declaration);
 813     }
 814 
 815     StatementNode* createExportNamedDeclaration(const JSTokenLocation&amp; location, ExportSpecifierListNode* exportSpecifierList, ModuleNameNode* moduleName)
 816     {
 817         return new (m_parserArena) ExportNamedDeclarationNode(location, exportSpecifierList, moduleName);
 818     }
 819 
 820     ExportSpecifierNode* createExportSpecifier(const JSTokenLocation&amp; location, const Identifier&amp; localName, const Identifier&amp; exportedName)
 821     {
 822         return new (m_parserArena) ExportSpecifierNode(location, localName, exportedName);
 823     }
 824 
 825     ExportSpecifierListNode* createExportSpecifierList()
 826     {
 827         return new (m_parserArena) ExportSpecifierListNode();
 828     }
 829 
 830     void appendExportSpecifier(ExportSpecifierListNode* specifierList, ExportSpecifierNode* specifier)
 831     {
 832         specifierList-&gt;append(specifier);
 833     }
 834 
 835     void appendStatement(JSC::SourceElements* elements, JSC::StatementNode* statement)
 836     {
 837         elements-&gt;append(statement);
 838     }
 839 
 840     CommaNode* createCommaExpr(const JSTokenLocation&amp; location, ExpressionNode* node)
 841     {
 842         return new (m_parserArena) CommaNode(location, node);
 843     }
 844 
 845     CommaNode* appendToCommaExpr(const JSTokenLocation&amp; location, ExpressionNode*, ExpressionNode* tail, ExpressionNode* next)
 846     {
 847         ASSERT(tail-&gt;isCommaNode());
 848         ASSERT(next);
 849         CommaNode* newTail = new (m_parserArena) CommaNode(location, next);
 850         static_cast&lt;CommaNode*&gt;(tail)-&gt;setNext(newTail);
 851         return newTail;
 852     }
 853 
 854     int evalCount() const { return m_evalCount; }
 855 
 856     void appendBinaryExpressionInfo(int&amp; operandStackDepth, ExpressionNode* current, const JSTextPosition&amp; exprStart, const JSTextPosition&amp; lhs, const JSTextPosition&amp; rhs, bool hasAssignments)
 857     {
 858         operandStackDepth++;
 859         m_binaryOperandStack.append(std::make_pair(current, BinaryOpInfo(exprStart, lhs, rhs, hasAssignments)));
 860     }
 861 
 862     // Logic to handle datastructures used during parsing of binary expressions
 863     void operatorStackPop(int&amp; operatorStackDepth)
 864     {
 865         operatorStackDepth--;
 866         m_binaryOperatorStack.removeLast();
 867     }
 868     bool operatorStackShouldReduce(int precedence)
 869     {
 870         // If the current precedence of the operator stack is the same to the one of the given operator,
 871         // it depends on the associative whether we reduce the stack.
 872         // If the operator is right associative, we should not reduce the stack right now.
 873         if (precedence == m_binaryOperatorStack.last().second)
 874             return !(m_binaryOperatorStack.last().first &amp; RightAssociativeBinaryOpTokenFlag);
 875         return precedence &lt; m_binaryOperatorStack.last().second;
 876     }
 877     const BinaryOperand&amp; getFromOperandStack(int i) { return m_binaryOperandStack[m_binaryOperandStack.size() + i]; }
 878     void shrinkOperandStackBy(int&amp; operandStackDepth, int amount)
 879     {
 880         operandStackDepth -= amount;
 881         ASSERT(operandStackDepth &gt;= 0);
 882         m_binaryOperandStack.shrink(m_binaryOperandStack.size() - amount);
 883     }
 884     void appendBinaryOperation(const JSTokenLocation&amp; location, int&amp; operandStackDepth, int&amp;, const BinaryOperand&amp; lhs, const BinaryOperand&amp; rhs)
 885     {
 886         operandStackDepth++;
 887         m_binaryOperandStack.append(std::make_pair(makeBinaryNode(location, m_binaryOperatorStack.last().first, lhs, rhs), BinaryOpInfo(lhs.second, rhs.second)));
 888     }
 889     void operatorStackAppend(int&amp; operatorStackDepth, int op, int precedence)
 890     {
 891         operatorStackDepth++;
 892         m_binaryOperatorStack.append(std::make_pair(op, precedence));
 893     }
 894     ExpressionNode* popOperandStack(int&amp;)
 895     {
 896         ExpressionNode* result = m_binaryOperandStack.last().first;
 897         m_binaryOperandStack.removeLast();
 898         return result;
 899     }
 900 
 901     void appendUnaryToken(int&amp; tokenStackDepth, int type, const JSTextPosition&amp; start)
 902     {
 903         tokenStackDepth++;
 904         m_unaryTokenStack.append(std::make_pair(type, start));
 905     }
 906 
 907     int unaryTokenStackLastType(int&amp;)
 908     {
 909         return m_unaryTokenStack.last().first;
 910     }
 911 
 912     const JSTextPosition&amp; unaryTokenStackLastStart(int&amp;)
 913     {
 914         return m_unaryTokenStack.last().second;
 915     }
 916 
 917     void unaryTokenStackRemoveLast(int&amp; tokenStackDepth)
 918     {
 919         tokenStackDepth--;
 920         m_unaryTokenStack.removeLast();
 921     }
 922 
 923     void assignmentStackAppend(int&amp; assignmentStackDepth, ExpressionNode* node, const JSTextPosition&amp; start, const JSTextPosition&amp; divot, int assignmentCount, Operator op)
 924     {
 925         assignmentStackDepth++;
 926         ASSERT(start.offset &gt;= start.lineStartOffset);
 927         ASSERT(divot.offset &gt;= divot.lineStartOffset);
 928         m_assignmentInfoStack.append(AssignmentInfo(node, start, divot, assignmentCount, op));
 929     }
 930 
 931     ExpressionNode* createAssignment(const JSTokenLocation&amp; location, int&amp; assignmentStackDepth, ExpressionNode* rhs, int initialAssignmentCount, int currentAssignmentCount, const JSTextPosition&amp; lastTokenEnd)
 932     {
 933         AssignmentInfo&amp; info = m_assignmentInfoStack.last();
 934         ExpressionNode* result = makeAssignNode(location, info.m_node, info.m_op, rhs, info.m_initAssignments != initialAssignmentCount, info.m_initAssignments != currentAssignmentCount, info.m_start, info.m_divot + 1, lastTokenEnd);
 935         m_assignmentInfoStack.removeLast();
 936         assignmentStackDepth--;
 937         return result;
 938     }
 939 
 940     const Identifier* getName(const Property&amp; property) const { return property-&gt;name(); }
 941     PropertyNode::Type getType(const Property&amp; property) const { return property-&gt;type(); }
 942 
 943     bool isResolve(ExpressionNode* expr) const { return expr-&gt;isResolveNode(); }
 944 
 945     ExpressionNode* createDestructuringAssignment(const JSTokenLocation&amp; location, DestructuringPattern pattern, ExpressionNode* initializer)
 946     {
 947         return new (m_parserArena) DestructuringAssignmentNode(location, pattern, initializer);
 948     }
 949 
 950     ArrayPattern createArrayPattern(const JSTokenLocation&amp;)
 951     {
 952         return new (m_parserArena) ArrayPatternNode();
 953     }
 954 
 955     void appendArrayPatternSkipEntry(ArrayPattern node, const JSTokenLocation&amp; location)
 956     {
 957         node-&gt;appendIndex(ArrayPatternNode::BindingType::Elision, location, 0, nullptr);
 958     }
 959 
 960     void appendArrayPatternEntry(ArrayPattern node, const JSTokenLocation&amp; location, DestructuringPattern pattern, ExpressionNode* defaultValue)
 961     {
 962         node-&gt;appendIndex(ArrayPatternNode::BindingType::Element, location, pattern, defaultValue);
 963         tryInferNameInPattern(pattern, defaultValue);
 964     }
 965 
 966     void appendArrayPatternRestEntry(ArrayPattern node, const JSTokenLocation&amp; location, DestructuringPattern pattern)
 967     {
 968         node-&gt;appendIndex(ArrayPatternNode::BindingType::RestElement, location, pattern, nullptr);
 969     }
 970 
 971     void finishArrayPattern(ArrayPattern node, const JSTextPosition&amp; divotStart, const JSTextPosition&amp; divot, const JSTextPosition&amp; divotEnd)
 972     {
 973         setExceptionLocation(node, divotStart, divot, divotEnd);
 974     }
 975 
 976     ObjectPattern createObjectPattern(const JSTokenLocation&amp;)
 977     {
 978         return new (m_parserArena) ObjectPatternNode();
 979     }
 980 
 981     void appendObjectPatternEntry(ObjectPattern node, const JSTokenLocation&amp; location, bool wasString, const Identifier&amp; identifier, DestructuringPattern pattern, ExpressionNode* defaultValue)
 982     {
 983         node-&gt;appendEntry(location, identifier, wasString, pattern, defaultValue, ObjectPatternNode::BindingType::Element);
 984         tryInferNameInPattern(pattern, defaultValue);
 985     }
 986 
 987     void appendObjectPatternEntry(VM&amp; vm, ObjectPattern node, const JSTokenLocation&amp; location, ExpressionNode* propertyExpression, DestructuringPattern pattern, ExpressionNode* defaultValue)
 988     {
 989         node-&gt;appendEntry(vm, location, propertyExpression, pattern, defaultValue, ObjectPatternNode::BindingType::Element);
 990         tryInferNameInPattern(pattern, defaultValue);
 991     }
 992 
 993     void appendObjectPatternRestEntry(VM&amp; vm, ObjectPattern node, const JSTokenLocation&amp; location, DestructuringPattern pattern)
 994     {
 995         node-&gt;appendEntry(vm, location, nullptr, pattern, nullptr, ObjectPatternNode::BindingType::RestElement);
 996     }
 997 
 998     void setContainsObjectRestElement(ObjectPattern node, bool containsRestElement)
 999     {
1000         node-&gt;setContainsRestElement(containsRestElement);
1001     }
1002 
1003     void setContainsComputedProperty(ObjectPattern node, bool containsComputedProperty)
1004     {
1005         node-&gt;setContainsComputedProperty(containsComputedProperty);
1006     }
1007 
1008     BindingPattern createBindingLocation(const JSTokenLocation&amp;, const Identifier&amp; boundProperty, const JSTextPosition&amp; start, const JSTextPosition&amp; end, AssignmentContext context)
1009     {
1010         return new (m_parserArena) BindingNode(boundProperty, start, end, context);
1011     }
1012 
1013     RestParameterNode* createRestParameter(DestructuringPatternNode* pattern, size_t numParametersToSkip)
1014     {
1015         return new (m_parserArena) RestParameterNode(pattern, numParametersToSkip);
1016     }
1017 
1018     AssignmentElement createAssignmentElement(const Expression&amp; assignmentTarget, const JSTextPosition&amp; start, const JSTextPosition&amp; end)
1019     {
1020         return new (m_parserArena) AssignmentElementNode(assignmentTarget, start, end);
1021     }
1022 
1023     void setEndOffset(Node* node, int offset)
1024     {
1025         node-&gt;setEndOffset(offset);
1026     }
1027 
1028     int endOffset(Node* node)
1029     {
1030         return node-&gt;endOffset();
1031     }
1032 
1033     void setStartOffset(CaseClauseNode* node, int offset)
1034     {
1035         node-&gt;setStartOffset(offset);
1036     }
1037 
1038     void setStartOffset(Node* node, int offset)
1039     {
1040         node-&gt;setStartOffset(offset);
1041     }
1042 
1043     JSTextPosition breakpointLocation(Node* node)
1044     {
1045         node-&gt;setNeedsDebugHook();
1046         return node-&gt;position();
1047     }
1048 
1049     void propagateArgumentsUse() { usesArguments(); }
1050 
1051 private:
1052     struct Scope {
1053         Scope()
1054             : m_features(0)
1055             , m_numConstants(0)
1056         {
1057         }
1058         int m_features;
1059         int m_numConstants;
1060     };
1061 
1062     static void setExceptionLocation(ThrowableExpressionData* node, const JSTextPosition&amp; divotStart, const JSTextPosition&amp; divot, const JSTextPosition&amp; divotEnd)
1063     {
1064         ASSERT(divot.offset &gt;= divot.lineStartOffset);
1065         node-&gt;setExceptionSourceCode(divot, divotStart, divotEnd);
1066     }
1067 
1068     void incConstants() { m_scope.m_numConstants++; }
1069     void usesThis() { m_scope.m_features |= ThisFeature; }
1070     void usesArrowFunction() { m_scope.m_features |= ArrowFunctionFeature; }
1071     void usesArguments() { m_scope.m_features |= ArgumentsFeature; }
1072     void usesWith() { m_scope.m_features |= WithFeature; }
1073     void usesSuperCall() { m_scope.m_features |= SuperCallFeature; }
1074     void usesSuperProperty() { m_scope.m_features |= SuperPropertyFeature; }
1075     void usesEval()
1076     {
1077         m_evalCount++;
1078         m_scope.m_features |= EvalFeature;
1079     }
1080     void usesNewTarget() { m_scope.m_features |= NewTargetFeature; }
1081     ExpressionNode* createIntegerLikeNumber(const JSTokenLocation&amp; location, double d)
1082     {
1083         return new (m_parserArena) IntegerNode(location, d);
1084     }
1085     ExpressionNode* createDoubleLikeNumber(const JSTokenLocation&amp; location, double d)
1086     {
1087         return new (m_parserArena) DoubleNode(location, d);
1088     }
1089     ExpressionNode* createBigIntWithSign(const JSTokenLocation&amp; location, const Identifier&amp; bigInt, uint8_t radix, bool sign)
1090     {
1091         return new (m_parserArena) BigIntNode(location, bigInt, radix, sign);
1092     }
1093     ExpressionNode* createNumberFromBinaryOperation(const JSTokenLocation&amp; location, double value, const NumberNode&amp; originalNodeA, const NumberNode&amp; originalNodeB)
1094     {
1095         if (originalNodeA.isIntegerNode() &amp;&amp; originalNodeB.isIntegerNode())
1096             return createIntegerLikeNumber(location, value);
1097         return createDoubleLikeNumber(location, value);
1098     }
1099     ExpressionNode* createNumberFromUnaryOperation(const JSTokenLocation&amp; location, double value, const NumberNode&amp; originalNode)
1100     {
1101         if (originalNode.isIntegerNode())
1102             return createIntegerLikeNumber(location, value);
1103         return createDoubleLikeNumber(location, value);
1104     }
1105     ExpressionNode* createBigIntFromUnaryOperation(const JSTokenLocation&amp; location, bool sign, const BigIntNode&amp; originalNode)
1106     {
1107         return createBigIntWithSign(location, originalNode.identifier(), originalNode.radix(), sign);
1108     }
1109 
1110     void tryInferNameInPattern(DestructuringPattern pattern, ExpressionNode* defaultValue)
1111     {
1112         if (!defaultValue)
1113             return;
1114 
1115         if (pattern-&gt;isBindingNode()) {
1116             const Identifier&amp; ident = static_cast&lt;BindingNode*&gt;(pattern)-&gt;boundProperty();
1117             tryInferNameInPatternWithIdentifier(ident, defaultValue);
1118         } else if (pattern-&gt;isAssignmentElementNode()) {
1119             const ExpressionNode* assignmentTarget = static_cast&lt;AssignmentElementNode*&gt;(pattern)-&gt;assignmentTarget();
1120             if (assignmentTarget-&gt;isResolveNode()) {
1121                 const Identifier&amp; ident = static_cast&lt;const ResolveNode*&gt;(assignmentTarget)-&gt;identifier();
1122                 tryInferNameInPatternWithIdentifier(ident, defaultValue);
1123             }
1124         }
1125     }
1126 
1127     void tryInferNameInPatternWithIdentifier(const Identifier&amp; ident, ExpressionNode* defaultValue)
1128     {
1129         if (defaultValue-&gt;isBaseFuncExprNode()) {
1130             auto metadata = static_cast&lt;BaseFuncExprNode*&gt;(defaultValue)-&gt;metadata();
1131             metadata-&gt;setEcmaName(ident);
1132         } else if (defaultValue-&gt;isClassExprNode())
1133             static_cast&lt;ClassExprNode*&gt;(defaultValue)-&gt;setEcmaName(ident);
1134     }
1135 
1136     VM&amp; m_vm;
1137     ParserArena&amp; m_parserArena;
1138     SourceCode* m_sourceCode;
1139     Scope m_scope;
1140     Vector&lt;BinaryOperand, 10, UnsafeVectorOverflow&gt; m_binaryOperandStack;
1141     Vector&lt;AssignmentInfo, 10, UnsafeVectorOverflow&gt; m_assignmentInfoStack;
1142     Vector&lt;std::pair&lt;int, int&gt;, 10, UnsafeVectorOverflow&gt; m_binaryOperatorStack;
1143     Vector&lt;std::pair&lt;int, JSTextPosition&gt;, 10, UnsafeVectorOverflow&gt; m_unaryTokenStack;
1144     int m_evalCount;
1145 };
1146 
1147 ExpressionNode* ASTBuilder::makeTypeOfNode(const JSTokenLocation&amp; location, ExpressionNode* expr)
1148 {
1149     if (expr-&gt;isResolveNode()) {
1150         ResolveNode* resolve = static_cast&lt;ResolveNode*&gt;(expr);
1151         return new (m_parserArena) TypeOfResolveNode(location, resolve-&gt;identifier());
1152     }
1153     return new (m_parserArena) TypeOfValueNode(location, expr);
1154 }
1155 
1156 ExpressionNode* ASTBuilder::makeDeleteNode(const JSTokenLocation&amp; location, ExpressionNode* expr, const JSTextPosition&amp; start, const JSTextPosition&amp; divot, const JSTextPosition&amp; end)
1157 {
1158     if (expr-&gt;isOptionalChain()) {
1159         OptionalChainNode* optionalChain = static_cast&lt;OptionalChainNode*&gt;(expr);
1160         if (optionalChain-&gt;expr()-&gt;isLocation()) {
1161             ASSERT(!optionalChain-&gt;expr()-&gt;isResolveNode());
1162             optionalChain-&gt;setExpr(makeDeleteNode(location, optionalChain-&gt;expr(), start, divot, end));
1163             return optionalChain;
1164         }
1165     }
1166 
1167     if (!expr-&gt;isLocation())
1168         return new (m_parserArena) DeleteValueNode(location, expr);
1169     if (expr-&gt;isResolveNode()) {
1170         ResolveNode* resolve = static_cast&lt;ResolveNode*&gt;(expr);
1171         return new (m_parserArena) DeleteResolveNode(location, resolve-&gt;identifier(), divot, start, end);
1172     }
1173     if (expr-&gt;isBracketAccessorNode()) {
1174         BracketAccessorNode* bracket = static_cast&lt;BracketAccessorNode*&gt;(expr);
1175         return new (m_parserArena) DeleteBracketNode(location, bracket-&gt;base(), bracket-&gt;subscript(), divot, start, end);
1176     }
1177     ASSERT(expr-&gt;isDotAccessorNode());
1178     DotAccessorNode* dot = static_cast&lt;DotAccessorNode*&gt;(expr);
1179     return new (m_parserArena) DeleteDotNode(location, dot-&gt;base(), dot-&gt;identifier(), divot, start, end);
1180 }
1181 
1182 ExpressionNode* ASTBuilder::makeNegateNode(const JSTokenLocation&amp; location, ExpressionNode* n)
1183 {
1184     if (n-&gt;isNumber()) {
1185         const NumberNode&amp; numberNode = static_cast&lt;const NumberNode&amp;&gt;(*n);
1186         return createNumberFromUnaryOperation(location, -numberNode.value(), numberNode);
1187     }
1188 
1189     if (n-&gt;isBigInt()) {
1190         const BigIntNode&amp; bigIntNode = static_cast&lt;const BigIntNode&amp;&gt;(*n);
1191         return createBigIntFromUnaryOperation(location, !bigIntNode.sign(), bigIntNode);
1192     }
1193 
1194     return new (m_parserArena) NegateNode(location, n);
1195 }
1196 
1197 ExpressionNode* ASTBuilder::makeBitwiseNotNode(const JSTokenLocation&amp; location, ExpressionNode* expr)
1198 {
1199     if (expr-&gt;isNumber())
1200         return createIntegerLikeNumber(location, ~toInt32(static_cast&lt;NumberNode*&gt;(expr)-&gt;value()));
1201     return new (m_parserArena) BitwiseNotNode(location, expr);
1202 }
1203 
1204 ExpressionNode* ASTBuilder::makePowNode(const JSTokenLocation&amp; location, ExpressionNode* expr1, ExpressionNode* expr2, bool rightHasAssignments)
1205 {
1206     auto* strippedExpr1 = expr1-&gt;stripUnaryPlus();
1207     auto* strippedExpr2 = expr2-&gt;stripUnaryPlus();
1208 
1209     if (strippedExpr1-&gt;isNumber() &amp;&amp; strippedExpr2-&gt;isNumber()) {
1210         const NumberNode&amp; numberExpr1 = static_cast&lt;NumberNode&amp;&gt;(*strippedExpr1);
1211         const NumberNode&amp; numberExpr2 = static_cast&lt;NumberNode&amp;&gt;(*strippedExpr2);
1212         return createNumberFromBinaryOperation(location, operationMathPow(numberExpr1.value(), numberExpr2.value()), numberExpr1, numberExpr2);
1213     }
1214 
1215     if (strippedExpr1-&gt;isNumber())
1216         expr1 = strippedExpr1;
1217     if (strippedExpr2-&gt;isNumber())
1218         expr2 = strippedExpr2;
1219 
1220     return new (m_parserArena) PowNode(location, expr1, expr2, rightHasAssignments);
1221 }
1222 
1223 ExpressionNode* ASTBuilder::makeMultNode(const JSTokenLocation&amp; location, ExpressionNode* expr1, ExpressionNode* expr2, bool rightHasAssignments)
1224 {
1225     // FIXME: Unary + change the evaluation order.
1226     // https://bugs.webkit.org/show_bug.cgi?id=159968
1227     expr1 = expr1-&gt;stripUnaryPlus();
1228     expr2 = expr2-&gt;stripUnaryPlus();
1229 
1230     if (expr1-&gt;isNumber() &amp;&amp; expr2-&gt;isNumber()) {
1231         const NumberNode&amp; numberExpr1 = static_cast&lt;NumberNode&amp;&gt;(*expr1);
1232         const NumberNode&amp; numberExpr2 = static_cast&lt;NumberNode&amp;&gt;(*expr2);
1233         return createNumberFromBinaryOperation(location, numberExpr1.value() * numberExpr2.value(), numberExpr1, numberExpr2);
1234     }
1235 
1236     if (expr1-&gt;isNumber() &amp;&amp; static_cast&lt;NumberNode*&gt;(expr1)-&gt;value() == 1)
1237         return new (m_parserArena) UnaryPlusNode(location, expr2);
1238 
1239     if (expr2-&gt;isNumber() &amp;&amp; static_cast&lt;NumberNode*&gt;(expr2)-&gt;value() == 1)
1240         return new (m_parserArena) UnaryPlusNode(location, expr1);
1241 
1242     return new (m_parserArena) MultNode(location, expr1, expr2, rightHasAssignments);
1243 }
1244 
1245 ExpressionNode* ASTBuilder::makeDivNode(const JSTokenLocation&amp; location, ExpressionNode* expr1, ExpressionNode* expr2, bool rightHasAssignments)
1246 {
1247     // FIXME: Unary + change the evaluation order.
1248     // https://bugs.webkit.org/show_bug.cgi?id=159968
1249     expr1 = expr1-&gt;stripUnaryPlus();
1250     expr2 = expr2-&gt;stripUnaryPlus();
1251 
1252     if (expr1-&gt;isNumber() &amp;&amp; expr2-&gt;isNumber()) {
1253         const NumberNode&amp; numberExpr1 = static_cast&lt;NumberNode&amp;&gt;(*expr1);
1254         const NumberNode&amp; numberExpr2 = static_cast&lt;NumberNode&amp;&gt;(*expr2);
1255         double result = numberExpr1.value() / numberExpr2.value();
1256         if (static_cast&lt;int64_t&gt;(result) == result)
1257             return createNumberFromBinaryOperation(location, result, numberExpr1, numberExpr2);
1258         return createDoubleLikeNumber(location, result);
1259     }
1260     return new (m_parserArena) DivNode(location, expr1, expr2, rightHasAssignments);
1261 }
1262 
1263 ExpressionNode* ASTBuilder::makeModNode(const JSTokenLocation&amp; location, ExpressionNode* expr1, ExpressionNode* expr2, bool rightHasAssignments)
1264 {
1265     // FIXME: Unary + change the evaluation order.
1266     // https://bugs.webkit.org/show_bug.cgi?id=159968
1267     expr1 = expr1-&gt;stripUnaryPlus();
1268     expr2 = expr2-&gt;stripUnaryPlus();
1269 
1270     if (expr1-&gt;isNumber() &amp;&amp; expr2-&gt;isNumber()) {
1271         const NumberNode&amp; numberExpr1 = static_cast&lt;NumberNode&amp;&gt;(*expr1);
1272         const NumberNode&amp; numberExpr2 = static_cast&lt;NumberNode&amp;&gt;(*expr2);
1273         return createIntegerLikeNumber(location, fmod(numberExpr1.value(), numberExpr2.value()));
1274     }
1275     return new (m_parserArena) ModNode(location, expr1, expr2, rightHasAssignments);
1276 }
1277 
1278 ExpressionNode* ASTBuilder::makeAddNode(const JSTokenLocation&amp; location, ExpressionNode* expr1, ExpressionNode* expr2, bool rightHasAssignments)
1279 {
1280 
1281     if (expr1-&gt;isNumber() &amp;&amp; expr2-&gt;isNumber()) {
1282         const NumberNode&amp; numberExpr1 = static_cast&lt;NumberNode&amp;&gt;(*expr1);
1283         const NumberNode&amp; numberExpr2 = static_cast&lt;NumberNode&amp;&gt;(*expr2);
1284         return createNumberFromBinaryOperation(location, numberExpr1.value() + numberExpr2.value(), numberExpr1, numberExpr2);
1285     }
1286     return new (m_parserArena) AddNode(location, expr1, expr2, rightHasAssignments);
1287 }
1288 
1289 ExpressionNode* ASTBuilder::makeSubNode(const JSTokenLocation&amp; location, ExpressionNode* expr1, ExpressionNode* expr2, bool rightHasAssignments)
1290 {
1291     // FIXME: Unary + change the evaluation order.
1292     // https://bugs.webkit.org/show_bug.cgi?id=159968
1293     expr1 = expr1-&gt;stripUnaryPlus();
1294     expr2 = expr2-&gt;stripUnaryPlus();
1295 
1296     if (expr1-&gt;isNumber() &amp;&amp; expr2-&gt;isNumber()) {
1297         const NumberNode&amp; numberExpr1 = static_cast&lt;NumberNode&amp;&gt;(*expr1);
1298         const NumberNode&amp; numberExpr2 = static_cast&lt;NumberNode&amp;&gt;(*expr2);
1299         return createNumberFromBinaryOperation(location, numberExpr1.value() - numberExpr2.value(), numberExpr1, numberExpr2);
1300     }
1301     return new (m_parserArena) SubNode(location, expr1, expr2, rightHasAssignments);
1302 }
1303 
1304 ExpressionNode* ASTBuilder::makeLeftShiftNode(const JSTokenLocation&amp; location, ExpressionNode* expr1, ExpressionNode* expr2, bool rightHasAssignments)
1305 {
1306     if (expr1-&gt;isNumber() &amp;&amp; expr2-&gt;isNumber()) {
1307         const NumberNode&amp; numberExpr1 = static_cast&lt;NumberNode&amp;&gt;(*expr1);
1308         const NumberNode&amp; numberExpr2 = static_cast&lt;NumberNode&amp;&gt;(*expr2);
1309         return createIntegerLikeNumber(location, toInt32(numberExpr1.value()) &lt;&lt; (toUInt32(numberExpr2.value()) &amp; 0x1f));
1310     }
1311     return new (m_parserArena) LeftShiftNode(location, expr1, expr2, rightHasAssignments);
1312 }
1313 
1314 ExpressionNode* ASTBuilder::makeRightShiftNode(const JSTokenLocation&amp; location, ExpressionNode* expr1, ExpressionNode* expr2, bool rightHasAssignments)
1315 {
1316     if (expr1-&gt;isNumber() &amp;&amp; expr2-&gt;isNumber()) {
1317         const NumberNode&amp; numberExpr1 = static_cast&lt;NumberNode&amp;&gt;(*expr1);
1318         const NumberNode&amp; numberExpr2 = static_cast&lt;NumberNode&amp;&gt;(*expr2);
1319         return createIntegerLikeNumber(location, toInt32(numberExpr1.value()) &gt;&gt; (toUInt32(numberExpr2.value()) &amp; 0x1f));
1320     }
1321     return new (m_parserArena) RightShiftNode(location, expr1, expr2, rightHasAssignments);
1322 }
1323 
1324 ExpressionNode* ASTBuilder::makeURightShiftNode(const JSTokenLocation&amp; location, ExpressionNode* expr1, ExpressionNode* expr2, bool rightHasAssignments)
1325 {
1326     if (expr1-&gt;isNumber() &amp;&amp; expr2-&gt;isNumber()) {
1327         const NumberNode&amp; numberExpr1 = static_cast&lt;NumberNode&amp;&gt;(*expr1);
1328         const NumberNode&amp; numberExpr2 = static_cast&lt;NumberNode&amp;&gt;(*expr2);
1329         return createIntegerLikeNumber(location, toUInt32(numberExpr1.value()) &gt;&gt; (toUInt32(numberExpr2.value()) &amp; 0x1f));
1330     }
1331     return new (m_parserArena) UnsignedRightShiftNode(location, expr1, expr2, rightHasAssignments);
1332 }
1333 
1334 ExpressionNode* ASTBuilder::makeBitOrNode(const JSTokenLocation&amp; location, ExpressionNode* expr1, ExpressionNode* expr2, bool rightHasAssignments)
1335 {
1336     if (expr1-&gt;isNumber() &amp;&amp; expr2-&gt;isNumber()) {
1337         const NumberNode&amp; numberExpr1 = static_cast&lt;NumberNode&amp;&gt;(*expr1);
1338         const NumberNode&amp; numberExpr2 = static_cast&lt;NumberNode&amp;&gt;(*expr2);
1339         return createIntegerLikeNumber(location, toInt32(numberExpr1.value()) | toInt32(numberExpr2.value()));
1340     }
1341     return new (m_parserArena) BitOrNode(location, expr1, expr2, rightHasAssignments);
1342 }
1343 
1344 ExpressionNode* ASTBuilder::makeBitAndNode(const JSTokenLocation&amp; location, ExpressionNode* expr1, ExpressionNode* expr2, bool rightHasAssignments)
1345 {
1346     if (expr1-&gt;isNumber() &amp;&amp; expr2-&gt;isNumber()) {
1347         const NumberNode&amp; numberExpr1 = static_cast&lt;NumberNode&amp;&gt;(*expr1);
1348         const NumberNode&amp; numberExpr2 = static_cast&lt;NumberNode&amp;&gt;(*expr2);
1349         return createIntegerLikeNumber(location, toInt32(numberExpr1.value()) &amp; toInt32(numberExpr2.value()));
1350     }
1351     return new (m_parserArena) BitAndNode(location, expr1, expr2, rightHasAssignments);
1352 }
1353 
1354 ExpressionNode* ASTBuilder::makeBitXOrNode(const JSTokenLocation&amp; location, ExpressionNode* expr1, ExpressionNode* expr2, bool rightHasAssignments)
1355 {
1356     if (expr1-&gt;isNumber() &amp;&amp; expr2-&gt;isNumber()) {
1357         const NumberNode&amp; numberExpr1 = static_cast&lt;NumberNode&amp;&gt;(*expr1);
1358         const NumberNode&amp; numberExpr2 = static_cast&lt;NumberNode&amp;&gt;(*expr2);
1359         return createIntegerLikeNumber(location, toInt32(numberExpr1.value()) ^ toInt32(numberExpr2.value()));
1360     }
1361     return new (m_parserArena) BitXOrNode(location, expr1, expr2, rightHasAssignments);
1362 }
1363 
1364 ExpressionNode* ASTBuilder::makeCoalesceNode(const JSTokenLocation&amp; location, ExpressionNode* expr1, ExpressionNode* expr2)
1365 {
1366     // Optimization for `x?.y ?? z`.
1367     if (expr1-&gt;isOptionalChain()) {
1368         OptionalChainNode* optionalChain = static_cast&lt;OptionalChainNode*&gt;(expr1);
1369         if (!optionalChain-&gt;expr()-&gt;isDeleteNode()) {
1370             constexpr bool hasAbsorbedOptionalChain = true;
1371             return new (m_parserArena) CoalesceNode(location, optionalChain-&gt;expr(), expr2, hasAbsorbedOptionalChain);
1372         }
1373     }
1374     constexpr bool hasAbsorbedOptionalChain = false;
1375     return new (m_parserArena) CoalesceNode(location, expr1, expr2, hasAbsorbedOptionalChain);
1376 }
1377 
1378 ExpressionNode* ASTBuilder::makeFunctionCallNode(const JSTokenLocation&amp; location, ExpressionNode* func, bool previousBaseWasSuper, ArgumentsNode* args, const JSTextPosition&amp; divotStart, const JSTextPosition&amp; divot, const JSTextPosition&amp; divotEnd, size_t callOrApplyChildDepth, bool isOptionalCall)
1379 {
1380     ASSERT(divot.offset &gt;= divot.lineStartOffset);
1381     if (func-&gt;isSuperNode())
1382         usesSuperCall();
1383 
1384     if (func-&gt;isBytecodeIntrinsicNode()) {
1385         ASSERT(!isOptionalCall);
1386         BytecodeIntrinsicNode* intrinsic = static_cast&lt;BytecodeIntrinsicNode*&gt;(func);
1387         if (intrinsic-&gt;type() == BytecodeIntrinsicNode::Type::Constant)
1388             return new (m_parserArena) BytecodeIntrinsicNode(BytecodeIntrinsicNode::Type::Function, location, intrinsic-&gt;emitter(), intrinsic-&gt;identifier(), args, divot, divotStart, divotEnd);
1389     }
1390 
1391     if (func-&gt;isOptionalChain()) {
1392         OptionalChainNode* optionalChain = static_cast&lt;OptionalChainNode*&gt;(func);
1393         if (optionalChain-&gt;expr()-&gt;isLocation()) {
1394             ASSERT(!optionalChain-&gt;expr()-&gt;isResolveNode());
1395             // We must take care to preserve our `this` value in cases like `a?.b?.()` and `(a?.b)()`, respectively.
1396             if (isOptionalCall)
1397                 return makeFunctionCallNode(location, optionalChain-&gt;expr(), previousBaseWasSuper, args, divotStart, divot, divotEnd, callOrApplyChildDepth, isOptionalCall);
1398             optionalChain-&gt;setExpr(makeFunctionCallNode(location, optionalChain-&gt;expr(), previousBaseWasSuper, args, divotStart, divot, divotEnd, callOrApplyChildDepth, isOptionalCall));
1399             return optionalChain;
1400         }
1401     }
1402 
1403     if (!func-&gt;isLocation())
1404         return new (m_parserArena) FunctionCallValueNode(location, func, args, divot, divotStart, divotEnd);
1405     if (func-&gt;isResolveNode()) {
1406         ResolveNode* resolve = static_cast&lt;ResolveNode*&gt;(func);
1407         const Identifier&amp; identifier = resolve-&gt;identifier();
1408         if (identifier == m_vm.propertyNames-&gt;eval) {
1409             usesEval();
1410             return new (m_parserArena) EvalFunctionCallNode(location, args, divot, divotStart, divotEnd);
1411         }
1412         return new (m_parserArena) FunctionCallResolveNode(location, identifier, args, divot, divotStart, divotEnd);
1413     }
1414     if (func-&gt;isBracketAccessorNode()) {
1415         BracketAccessorNode* bracket = static_cast&lt;BracketAccessorNode*&gt;(func);
1416         FunctionCallBracketNode* node = new (m_parserArena) FunctionCallBracketNode(location, bracket-&gt;base(), bracket-&gt;subscript(), bracket-&gt;subscriptHasAssignments(), args, divot, divotStart, divotEnd);
1417         node-&gt;setSubexpressionInfo(bracket-&gt;divot(), bracket-&gt;divotEnd().offset);
1418         return node;
1419     }
1420     ASSERT(func-&gt;isDotAccessorNode());
1421     DotAccessorNode* dot = static_cast&lt;DotAccessorNode*&gt;(func);
1422     FunctionCallDotNode* node = nullptr;
1423     if (!previousBaseWasSuper &amp;&amp; (dot-&gt;identifier() == m_vm.propertyNames-&gt;builtinNames().callPublicName() || dot-&gt;identifier() == m_vm.propertyNames-&gt;builtinNames().callPrivateName()))
1424         node = new (m_parserArena) CallFunctionCallDotNode(location, dot-&gt;base(), dot-&gt;identifier(), args, divot, divotStart, divotEnd, callOrApplyChildDepth);
1425     else if (!previousBaseWasSuper &amp;&amp; (dot-&gt;identifier() == m_vm.propertyNames-&gt;builtinNames().applyPublicName() || dot-&gt;identifier() == m_vm.propertyNames-&gt;builtinNames().applyPrivateName())) {
1426         // FIXME: This check is only needed because we haven&#39;t taught the bytecode generator to inline
1427         // Reflect.apply yet. See https://bugs.webkit.org/show_bug.cgi?id=190668.
1428         if (!dot-&gt;base()-&gt;isResolveNode() || static_cast&lt;ResolveNode*&gt;(dot-&gt;base())-&gt;identifier() != &quot;Reflect&quot;)
1429             node = new (m_parserArena) ApplyFunctionCallDotNode(location, dot-&gt;base(), dot-&gt;identifier(), args, divot, divotStart, divotEnd, callOrApplyChildDepth);
1430     }
1431     if (!node)
1432         node = new (m_parserArena) FunctionCallDotNode(location, dot-&gt;base(), dot-&gt;identifier(), args, divot, divotStart, divotEnd);
1433     node-&gt;setSubexpressionInfo(dot-&gt;divot(), dot-&gt;divotEnd().offset);
1434     return node;
1435 }
1436 
1437 ExpressionNode* ASTBuilder::makeBinaryNode(const JSTokenLocation&amp; location, int token, std::pair&lt;ExpressionNode*, BinaryOpInfo&gt; lhs, std::pair&lt;ExpressionNode*, BinaryOpInfo&gt; rhs)
1438 {
1439     switch (token) {
1440     case COALESCE:
1441         return makeCoalesceNode(location, lhs.first, rhs.first);
1442 
1443     case OR:
1444         return new (m_parserArena) LogicalOpNode(location, lhs.first, rhs.first, OpLogicalOr);
1445 
1446     case AND:
1447         return new (m_parserArena) LogicalOpNode(location, lhs.first, rhs.first, OpLogicalAnd);
1448 
1449     case BITOR:
1450         return makeBitOrNode(location, lhs.first, rhs.first, rhs.second.hasAssignment);
1451 
1452     case BITXOR:
1453         return makeBitXOrNode(location, lhs.first, rhs.first, rhs.second.hasAssignment);
1454 
1455     case BITAND:
1456         return makeBitAndNode(location, lhs.first, rhs.first, rhs.second.hasAssignment);
1457 
1458     case EQEQ:
1459         return new (m_parserArena) EqualNode(location, lhs.first, rhs.first, rhs.second.hasAssignment);
1460 
1461     case NE:
1462         return new (m_parserArena) NotEqualNode(location, lhs.first, rhs.first, rhs.second.hasAssignment);
1463 
1464     case STREQ:
1465         return new (m_parserArena) StrictEqualNode(location, lhs.first, rhs.first, rhs.second.hasAssignment);
1466 
1467     case STRNEQ:
1468         return new (m_parserArena) NotStrictEqualNode(location, lhs.first, rhs.first, rhs.second.hasAssignment);
1469 
1470     case LT:
1471         return new (m_parserArena) LessNode(location, lhs.first, rhs.first, rhs.second.hasAssignment);
1472 
1473     case GT:
1474         return new (m_parserArena) GreaterNode(location, lhs.first, rhs.first, rhs.second.hasAssignment);
1475 
1476     case LE:
1477         return new (m_parserArena) LessEqNode(location, lhs.first, rhs.first, rhs.second.hasAssignment);
1478 
1479     case GE:
1480         return new (m_parserArena) GreaterEqNode(location, lhs.first, rhs.first, rhs.second.hasAssignment);
1481 
1482     case INSTANCEOF: {
1483         InstanceOfNode* node = new (m_parserArena) InstanceOfNode(location, lhs.first, rhs.first, rhs.second.hasAssignment);
1484         setExceptionLocation(node, lhs.second.start, rhs.second.start, rhs.second.end);
1485         return node;
1486     }
1487 
1488     case INTOKEN: {
1489         InNode* node = new (m_parserArena) InNode(location, lhs.first, rhs.first, rhs.second.hasAssignment);
1490         setExceptionLocation(node, lhs.second.start, rhs.second.start, rhs.second.end);
1491         return node;
1492     }
1493 
1494     case LSHIFT:
1495         return makeLeftShiftNode(location, lhs.first, rhs.first, rhs.second.hasAssignment);
1496 
1497     case RSHIFT:
1498         return makeRightShiftNode(location, lhs.first, rhs.first, rhs.second.hasAssignment);
1499 
1500     case URSHIFT:
1501         return makeURightShiftNode(location, lhs.first, rhs.first, rhs.second.hasAssignment);
1502 
1503     case PLUS:
1504         return makeAddNode(location, lhs.first, rhs.first, rhs.second.hasAssignment);
1505 
1506     case MINUS:
1507         return makeSubNode(location, lhs.first, rhs.first, rhs.second.hasAssignment);
1508 
1509     case TIMES:
1510         return makeMultNode(location, lhs.first, rhs.first, rhs.second.hasAssignment);
1511 
1512     case DIVIDE:
1513         return makeDivNode(location, lhs.first, rhs.first, rhs.second.hasAssignment);
1514 
1515     case MOD:
1516         return makeModNode(location, lhs.first, rhs.first, rhs.second.hasAssignment);
1517 
1518     case POW:
1519         return makePowNode(location, lhs.first, rhs.first, rhs.second.hasAssignment);
1520     }
1521     CRASH();
1522     return 0;
1523 }
1524 
1525 ExpressionNode* ASTBuilder::makeAssignNode(const JSTokenLocation&amp; location, ExpressionNode* loc, Operator op, ExpressionNode* expr, bool locHasAssignments, bool exprHasAssignments, const JSTextPosition&amp; start, const JSTextPosition&amp; divot, const JSTextPosition&amp; end)
1526 {
1527     if (!loc-&gt;isLocation()) {
1528         ASSERT(loc-&gt;isFunctionCall());
1529         return new (m_parserArena) AssignErrorNode(location, divot, start, end);
1530     }
1531 
1532     if (loc-&gt;isResolveNode()) {
1533         ResolveNode* resolve = static_cast&lt;ResolveNode*&gt;(loc);
1534         if (op == OpEqual) {
1535             if (expr-&gt;isBaseFuncExprNode()) {
1536                 auto metadata = static_cast&lt;BaseFuncExprNode*&gt;(expr)-&gt;metadata();
1537                 metadata-&gt;setEcmaName(resolve-&gt;identifier());
1538             } else if (expr-&gt;isClassExprNode())
1539                 static_cast&lt;ClassExprNode*&gt;(expr)-&gt;setEcmaName(resolve-&gt;identifier());
1540             AssignResolveNode* node = new (m_parserArena) AssignResolveNode(location, resolve-&gt;identifier(), expr, AssignmentContext::AssignmentExpression);
1541             setExceptionLocation(node, start, divot, end);
1542             return node;
1543         }
1544         return new (m_parserArena) ReadModifyResolveNode(location, resolve-&gt;identifier(), op, expr, exprHasAssignments, divot, start, end);
1545     }
1546     if (loc-&gt;isBracketAccessorNode()) {
1547         BracketAccessorNode* bracket = static_cast&lt;BracketAccessorNode*&gt;(loc);
1548         if (op == OpEqual)
1549             return new (m_parserArena) AssignBracketNode(location, bracket-&gt;base(), bracket-&gt;subscript(), expr, locHasAssignments, exprHasAssignments, bracket-&gt;divot(), start, end);
1550         ReadModifyBracketNode* node = new (m_parserArena) ReadModifyBracketNode(location, bracket-&gt;base(), bracket-&gt;subscript(), op, expr, locHasAssignments, exprHasAssignments, divot, start, end);
1551         node-&gt;setSubexpressionInfo(bracket-&gt;divot(), bracket-&gt;divotEnd().offset);
1552         return node;
1553     }
1554     ASSERT(loc-&gt;isDotAccessorNode());
1555     DotAccessorNode* dot = static_cast&lt;DotAccessorNode*&gt;(loc);
1556     if (op == OpEqual)
1557         return new (m_parserArena) AssignDotNode(location, dot-&gt;base(), dot-&gt;identifier(), expr, exprHasAssignments, dot-&gt;divot(), start, end);
1558 
1559     ReadModifyDotNode* node = new (m_parserArena) ReadModifyDotNode(location, dot-&gt;base(), dot-&gt;identifier(), op, expr, exprHasAssignments, divot, start, end);
1560     node-&gt;setSubexpressionInfo(dot-&gt;divot(), dot-&gt;divotEnd().offset);
1561     return node;
1562 }
1563 
1564 ExpressionNode* ASTBuilder::makePrefixNode(const JSTokenLocation&amp; location, ExpressionNode* expr, Operator op, const JSTextPosition&amp; start, const JSTextPosition&amp; divot, const JSTextPosition&amp; end)
1565 {
1566     return new (m_parserArena) PrefixNode(location, expr, op, divot, start, end);
1567 }
1568 
1569 ExpressionNode* ASTBuilder::makePostfixNode(const JSTokenLocation&amp; location, ExpressionNode* expr, Operator op, const JSTextPosition&amp; start, const JSTextPosition&amp; divot, const JSTextPosition&amp; end)
1570 {
1571     return new (m_parserArena) PostfixNode(location, expr, op, divot, start, end);
1572 }
1573 
1574 }
    </pre>
  </body>
</html>