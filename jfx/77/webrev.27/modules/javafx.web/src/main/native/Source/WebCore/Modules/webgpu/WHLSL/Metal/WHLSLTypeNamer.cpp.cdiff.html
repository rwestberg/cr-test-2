<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/Modules/webgpu/WHLSL/Metal/WHLSLTypeNamer.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="WHLSLNativeTypeWriter.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="WHLSLTypeNamer.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/Modules/webgpu/WHLSL/Metal/WHLSLTypeNamer.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 29,10 ***</span>
<span class="line-new-header">--- 29,11 ---</span>
  #if ENABLE(WEBGPU)
  
  #include &quot;WHLSLAddressSpace.h&quot;
  #include &quot;WHLSLArrayReferenceType.h&quot;
  #include &quot;WHLSLArrayType.h&quot;
<span class="line-added">+ #include &quot;WHLSLCallExpression.h&quot;</span>
  #include &quot;WHLSLEnumerationDefinition.h&quot;
  #include &quot;WHLSLEnumerationMember.h&quot;
  #include &quot;WHLSLNativeTypeDeclaration.h&quot;
  #include &quot;WHLSLNativeTypeWriter.h&quot;
  #include &quot;WHLSLPointerType.h&quot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 40,10 ***</span>
<span class="line-new-header">--- 41,11 ---</span>
  #include &quot;WHLSLTypeDefinition.h&quot;
  #include &quot;WHLSLTypeReference.h&quot;
  #include &quot;WHLSLVisitor.h&quot;
  #include &lt;algorithm&gt;
  #include &lt;functional&gt;
<span class="line-added">+ #include &lt;wtf/FastMalloc.h&gt;</span>
  #include &lt;wtf/HashMap.h&gt;
  #include &lt;wtf/HashSet.h&gt;
  #include &lt;wtf/Optional.h&gt;
  #include &lt;wtf/UniqueRef.h&gt;
  #include &lt;wtf/Vector.h&gt;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 54,197 ***</span>
  
  namespace WHLSL {
  
  namespace Metal {
  
<span class="line-removed">- class BaseTypeNameNode {</span>
<span class="line-removed">- public:</span>
<span class="line-removed">-     BaseTypeNameNode(BaseTypeNameNode* parent, String&amp;&amp; mangledName)</span>
<span class="line-removed">-         : m_parent(parent)</span>
<span class="line-removed">-         , m_mangledName(mangledName)</span>
<span class="line-removed">-     {</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     virtual ~BaseTypeNameNode() = default;</span>
<span class="line-removed">-     virtual bool isArrayTypeNameNode() const { return false; }</span>
<span class="line-removed">-     virtual bool isArrayReferenceTypeNameNode() const { return false; }</span>
<span class="line-removed">-     virtual bool isPointerTypeNameNode() const { return false; }</span>
<span class="line-removed">-     virtual bool isReferenceTypeNameNode() const { return false; }</span>
<span class="line-removed">-     Vector&lt;UniqueRef&lt;BaseTypeNameNode&gt;&gt;&amp; children() { return m_children; }</span>
<span class="line-removed">-     void append(UniqueRef&lt;BaseTypeNameNode&gt;&amp;&amp; child)</span>
<span class="line-removed">-     {</span>
<span class="line-removed">-         m_children.append(WTFMove(child));</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     BaseTypeNameNode* parent() { return m_parent; }</span>
<span class="line-removed">-     const String&amp; mangledName() const { return m_mangledName; }</span>
<span class="line-removed">- </span>
<span class="line-removed">- private:</span>
<span class="line-removed">-     Vector&lt;UniqueRef&lt;BaseTypeNameNode&gt;&gt; m_children;</span>
<span class="line-removed">-     BaseTypeNameNode* m_parent;</span>
<span class="line-removed">-     String m_mangledName;</span>
<span class="line-removed">- };</span>
<span class="line-removed">- </span>
<span class="line-removed">- class ArrayTypeNameNode : public BaseTypeNameNode {</span>
<span class="line-removed">- public:</span>
<span class="line-removed">-     ArrayTypeNameNode(BaseTypeNameNode* parent, String&amp;&amp; mangledName, unsigned numElements)</span>
<span class="line-removed">-         : BaseTypeNameNode(parent, WTFMove(mangledName))</span>
<span class="line-removed">-         , m_numElements(numElements)</span>
<span class="line-removed">-     {</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     virtual ~ArrayTypeNameNode() = default;</span>
<span class="line-removed">-     bool isArrayTypeNameNode() const override { return true; }</span>
<span class="line-removed">-     unsigned numElements() const { return m_numElements; }</span>
<span class="line-removed">- </span>
<span class="line-removed">- private:</span>
<span class="line-removed">-     unsigned m_numElements;</span>
<span class="line-removed">- };</span>
<span class="line-removed">- </span>
<span class="line-removed">- class ArrayReferenceTypeNameNode : public BaseTypeNameNode {</span>
<span class="line-removed">- public:</span>
<span class="line-removed">-     ArrayReferenceTypeNameNode(BaseTypeNameNode* parent, String&amp;&amp; mangledName, AST::AddressSpace addressSpace)</span>
<span class="line-removed">-         : BaseTypeNameNode(parent, WTFMove(mangledName))</span>
<span class="line-removed">-         , m_addressSpace(addressSpace)</span>
<span class="line-removed">-     {</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     virtual ~ArrayReferenceTypeNameNode() = default;</span>
<span class="line-removed">-     bool isArrayReferenceTypeNameNode() const override { return true; }</span>
<span class="line-removed">-     AST::AddressSpace addressSpace() const { return m_addressSpace; }</span>
<span class="line-removed">- </span>
<span class="line-removed">- private:</span>
<span class="line-removed">-     AST::AddressSpace m_addressSpace;</span>
<span class="line-removed">- };</span>
<span class="line-removed">- </span>
<span class="line-removed">- class PointerTypeNameNode : public BaseTypeNameNode {</span>
<span class="line-removed">- public:</span>
<span class="line-removed">-     PointerTypeNameNode(BaseTypeNameNode* parent, String&amp;&amp; mangledName, AST::AddressSpace addressSpace)</span>
<span class="line-removed">-         : BaseTypeNameNode(parent, WTFMove(mangledName))</span>
<span class="line-removed">-         , m_addressSpace(addressSpace)</span>
<span class="line-removed">-     {</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     virtual ~PointerTypeNameNode() = default;</span>
<span class="line-removed">-     bool isPointerTypeNameNode() const override { return true; }</span>
<span class="line-removed">-     AST::AddressSpace addressSpace() const { return m_addressSpace; }</span>
<span class="line-removed">- </span>
<span class="line-removed">- private:</span>
<span class="line-removed">-     AST::AddressSpace m_addressSpace;</span>
<span class="line-removed">- };</span>
<span class="line-removed">- </span>
<span class="line-removed">- class ReferenceTypeNameNode : public BaseTypeNameNode {</span>
<span class="line-removed">- public:</span>
<span class="line-removed">-     ReferenceTypeNameNode(BaseTypeNameNode* parent, String&amp;&amp; mangledName, AST::NamedType&amp; namedType)</span>
<span class="line-removed">-         : BaseTypeNameNode(parent, WTFMove(mangledName))</span>
<span class="line-removed">-         , m_namedType(namedType)</span>
<span class="line-removed">-     {</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     virtual ~ReferenceTypeNameNode() = default;</span>
<span class="line-removed">-     bool isReferenceTypeNameNode() const override { return true; }</span>
<span class="line-removed">-     AST::NamedType&amp; namedType() { return m_namedType; }</span>
<span class="line-removed">- </span>
<span class="line-removed">- private:</span>
<span class="line-removed">-     AST::NamedType&amp; m_namedType;</span>
<span class="line-removed">- };</span>
<span class="line-removed">- </span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- #define SPECIALIZE_TYPE_TRAITS_WHLSL_BASE_TYPE_NAMED_NODE(ToValueTypeName, predicate) \</span>
<span class="line-removed">- SPECIALIZE_TYPE_TRAITS_BEGIN(WebCore::WHLSL::Metal::ToValueTypeName) \</span>
<span class="line-removed">-     static bool isType(const WebCore::WHLSL::Metal::BaseTypeNameNode&amp; type) { return type.predicate; } \</span>
<span class="line-removed">- SPECIALIZE_TYPE_TRAITS_END()</span>
<span class="line-removed">- </span>
<span class="line-removed">- SPECIALIZE_TYPE_TRAITS_WHLSL_BASE_TYPE_NAMED_NODE(ArrayTypeNameNode, isArrayTypeNameNode())</span>
<span class="line-removed">- </span>
<span class="line-removed">- SPECIALIZE_TYPE_TRAITS_WHLSL_BASE_TYPE_NAMED_NODE(ArrayReferenceTypeNameNode, isArrayReferenceTypeNameNode())</span>
<span class="line-removed">- </span>
<span class="line-removed">- SPECIALIZE_TYPE_TRAITS_WHLSL_BASE_TYPE_NAMED_NODE(PointerTypeNameNode, isPointerTypeNameNode())</span>
<span class="line-removed">- </span>
<span class="line-removed">- SPECIALIZE_TYPE_TRAITS_WHLSL_BASE_TYPE_NAMED_NODE(ReferenceTypeNameNode, isReferenceTypeNameNode())</span>
<span class="line-removed">- </span>
<span class="line-removed">- namespace WebCore {</span>
<span class="line-removed">- </span>
<span class="line-removed">- namespace WHLSL {</span>
<span class="line-removed">- </span>
<span class="line-removed">- namespace Metal {</span>
<span class="line-removed">- </span>
  TypeNamer::TypeNamer(Program&amp; program)
      : m_program(program)
  {
  }
  
  TypeNamer::~TypeNamer() = default;
  
  void TypeNamer::visit(AST::UnnamedType&amp; unnamedType)
  {
<span class="line-modified">!     insert(unnamedType, m_trie);</span>
  }
  
  void TypeNamer::visit(AST::EnumerationDefinition&amp; enumerationDefinition)
  {
<span class="line-modified">!     auto addResult = m_namedTypeMapping.add(&amp;enumerationDefinition, generateNextTypeName());</span>
<span class="line-modified">!     ASSERT_UNUSED(addResult, addResult.isNewEntry);</span>
      for (auto&amp; enumerationMember : enumerationDefinition.enumerationMembers()) {
          auto addResult = m_enumerationMemberMapping.add(&amp;static_cast&lt;AST::EnumerationMember&amp;&gt;(enumerationMember), generateNextEnumerationMemberName());
          ASSERT_UNUSED(addResult, addResult.isNewEntry);
      }
<span class="line-removed">-     Visitor::visit(enumerationDefinition);</span>
<span class="line-removed">- }</span>
  
<span class="line-modified">! void TypeNamer::visit(AST::NativeTypeDeclaration&amp;)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     // Native type declarations already have names, and are already declared in Metal.</span>
<span class="line-removed">- }</span>
  
<span class="line-modified">! static Vector&lt;UniqueRef&lt;BaseTypeNameNode&gt;&gt;::iterator findInVector(AST::UnnamedType&amp; unnamedType, Vector&lt;UniqueRef&lt;BaseTypeNameNode&gt;&gt;&amp; types)</span>
<span class="line-modified">! {</span>
<span class="line-modified">!     return std::find_if(types.begin(), types.end(), [&amp;](BaseTypeNameNode&amp; baseTypeNameNode) -&gt; bool {</span>
<span class="line-modified">!         if (is&lt;AST::TypeReference&gt;(unnamedType) &amp;&amp; is&lt;ReferenceTypeNameNode&gt;(baseTypeNameNode)) {</span>
<span class="line-removed">-             auto* resolvedType = downcast&lt;AST::TypeReference&gt;(unnamedType).resolvedType();</span>
<span class="line-removed">-             ASSERT(resolvedType);</span>
<span class="line-removed">-             return resolvedType == &amp;downcast&lt;ReferenceTypeNameNode&gt;(baseTypeNameNode).namedType();</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         if (is&lt;AST::PointerType&gt;(unnamedType) &amp;&amp; is&lt;PointerTypeNameNode&gt;(baseTypeNameNode))</span>
<span class="line-removed">-             return downcast&lt;AST::PointerType&gt;(unnamedType).addressSpace() == downcast&lt;PointerTypeNameNode&gt;(baseTypeNameNode).addressSpace();</span>
<span class="line-removed">-         if (is&lt;AST::ArrayReferenceType&gt;(unnamedType) &amp;&amp; is&lt;ArrayReferenceTypeNameNode&gt;(baseTypeNameNode))</span>
<span class="line-removed">-             return downcast&lt;AST::ArrayReferenceType&gt;(unnamedType).addressSpace() == downcast&lt;ArrayReferenceTypeNameNode&gt;(baseTypeNameNode).addressSpace();</span>
<span class="line-removed">-         if (is&lt;AST::ArrayType&gt;(unnamedType) &amp;&amp; is&lt;ArrayTypeNameNode&gt;(baseTypeNameNode))</span>
<span class="line-removed">-             return downcast&lt;AST::ArrayType&gt;(unnamedType).numElements() == downcast&lt;ArrayTypeNameNode&gt;(baseTypeNameNode).numElements();</span>
<span class="line-removed">-         return false;</span>
<span class="line-removed">-     });</span>
  }
  
<span class="line-modified">! static BaseTypeNameNode&amp; find(AST::UnnamedType&amp; unnamedType, Vector&lt;UniqueRef&lt;BaseTypeNameNode&gt;&gt;&amp; types)</span>
  {
<span class="line-modified">!     auto&amp; vectorToSearch = ([&amp;]() -&gt; Vector&lt;UniqueRef&lt;BaseTypeNameNode&gt;&gt;&amp; {</span>
<span class="line-modified">!         if (is&lt;AST::TypeReference&gt;(unnamedType))</span>
<span class="line-modified">!             return types;</span>
<span class="line-removed">-         if (is&lt;AST::PointerType&gt;(unnamedType))</span>
<span class="line-removed">-             return find(downcast&lt;AST::PointerType&gt;(unnamedType).elementType(), types).children();</span>
<span class="line-removed">-         if (is&lt;AST::ArrayReferenceType&gt;(unnamedType))</span>
<span class="line-removed">-             return find(downcast&lt;AST::ArrayReferenceType&gt;(unnamedType).elementType(), types).children();</span>
<span class="line-removed">-         ASSERT(is&lt;AST::ArrayType&gt;(unnamedType));</span>
<span class="line-removed">-         return find(downcast&lt;AST::ArrayType&gt;(unnamedType).type(), types).children();</span>
<span class="line-removed">-     })();</span>
<span class="line-removed">-     auto iterator = findInVector(unnamedType, vectorToSearch);</span>
<span class="line-removed">-     ASSERT(iterator != types.end());</span>
<span class="line-removed">-     return *iterator;</span>
  }
  
  void TypeNamer::visit(AST::StructureDefinition&amp; structureDefinition)
  {
      {
          auto addResult = m_namedTypeMapping.add(&amp;structureDefinition, generateNextTypeName());
          ASSERT_UNUSED(addResult, addResult.isNewEntry);
      }
      Visitor::visit(structureDefinition);
      {
<span class="line-modified">!         Vector&lt;std::reference_wrapper&lt;BaseTypeNameNode&gt;&gt; neighbors;</span>
          for (auto&amp; structureElement : structureDefinition.structureElements()) {
              auto addResult = m_structureElementMapping.add(&amp;structureElement, generateNextStructureElementName());
              ASSERT_UNUSED(addResult, addResult.isNewEntry);
<span class="line-modified">!             neighbors.append(find(structureElement.type(), m_trie));</span>
          }
          auto addResult = m_dependencyGraph.add(&amp;structureDefinition, WTFMove(neighbors));
          ASSERT_UNUSED(addResult, addResult.isNewEntry);
      }
  }
<span class="line-new-header">--- 56,62 ---</span>
  
  namespace WHLSL {
  
  namespace Metal {
  
  TypeNamer::TypeNamer(Program&amp; program)
      : m_program(program)
  {
  }
  
  TypeNamer::~TypeNamer() = default;
  
  void TypeNamer::visit(AST::UnnamedType&amp; unnamedType)
  {
<span class="line-modified">!     generateUniquedTypeName(unnamedType);</span>
  }
  
  void TypeNamer::visit(AST::EnumerationDefinition&amp; enumerationDefinition)
  {
<span class="line-modified">!     {</span>
<span class="line-modified">!         auto addResult = m_namedTypeMapping.add(&amp;enumerationDefinition, generateNextTypeName());</span>
<span class="line-added">+         ASSERT_UNUSED(addResult, addResult.isNewEntry);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      for (auto&amp; enumerationMember : enumerationDefinition.enumerationMembers()) {
          auto addResult = m_enumerationMemberMapping.add(&amp;static_cast&lt;AST::EnumerationMember&amp;&gt;(enumerationMember), generateNextEnumerationMemberName());
          ASSERT_UNUSED(addResult, addResult.isNewEntry);
      }
  
<span class="line-modified">!     Visitor::visit(enumerationDefinition);</span>
  
<span class="line-modified">!     {</span>
<span class="line-modified">!         auto addResult = m_dependencyGraph.add(&amp;enumerationDefinition, Vector&lt;std::reference_wrapper&lt;AST::UnnamedType&gt;&gt; { enumerationDefinition.type() });</span>
<span class="line-modified">!         ASSERT_UNUSED(addResult, addResult.isNewEntry);</span>
<span class="line-modified">!     }</span>
  }
  
<span class="line-modified">! void TypeNamer::visit(AST::NativeTypeDeclaration&amp; nativeTypeDeclaration)</span>
  {
<span class="line-modified">!     // Native type declarations already have names, and are already declared in Metal.</span>
<span class="line-modified">!     auto addResult = m_dependencyGraph.add(&amp;nativeTypeDeclaration, Vector&lt;std::reference_wrapper&lt;AST::UnnamedType&gt;&gt; { });</span>
<span class="line-modified">!     ASSERT_UNUSED(addResult, addResult.isNewEntry);</span>
  }
  
  void TypeNamer::visit(AST::StructureDefinition&amp; structureDefinition)
  {
      {
          auto addResult = m_namedTypeMapping.add(&amp;structureDefinition, generateNextTypeName());
          ASSERT_UNUSED(addResult, addResult.isNewEntry);
      }
      Visitor::visit(structureDefinition);
      {
<span class="line-modified">!         Vector&lt;std::reference_wrapper&lt;AST::UnnamedType&gt;&gt; neighbors;</span>
          for (auto&amp; structureElement : structureDefinition.structureElements()) {
              auto addResult = m_structureElementMapping.add(&amp;structureElement, generateNextStructureElementName());
              ASSERT_UNUSED(addResult, addResult.isNewEntry);
<span class="line-modified">!             neighbors.append(structureElement.type());</span>
          }
          auto addResult = m_dependencyGraph.add(&amp;structureDefinition, WTFMove(neighbors));
          ASSERT_UNUSED(addResult, addResult.isNewEntry);
      }
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 255,245 ***</span>
          auto addResult = m_namedTypeMapping.add(&amp;typeDefinition, generateNextTypeName());
          ASSERT_UNUSED(addResult, addResult.isNewEntry);
      }
      Visitor::visit(typeDefinition);
      {
<span class="line-modified">!         Vector&lt;std::reference_wrapper&lt;BaseTypeNameNode&gt;&gt; neighbors = { find(typeDefinition.type(), m_trie) };</span>
<span class="line-removed">-         auto addResult = m_dependencyGraph.add(&amp;typeDefinition, WTFMove(neighbors));</span>
          ASSERT_UNUSED(addResult, addResult.isNewEntry);
      }
  }
  
  String TypeNamer::mangledNameForType(AST::NativeTypeDeclaration&amp; nativeTypeDeclaration)
  {
      return writeNativeType(nativeTypeDeclaration);
  }
  
<span class="line-modified">! UniqueRef&lt;BaseTypeNameNode&gt; TypeNamer::createNameNode(AST::UnnamedType&amp; unnamedType, BaseTypeNameNode* parent)</span>
  {
<span class="line-modified">!     if (is&lt;AST::TypeReference&gt;(unnamedType)) {</span>
<span class="line-modified">!         auto&amp; typeReference = downcast&lt;AST::TypeReference&gt;(unnamedType);</span>
<span class="line-modified">!         ASSERT(typeReference.resolvedType());</span>
<span class="line-modified">!         return makeUniqueRef&lt;ReferenceTypeNameNode&gt;(parent, generateNextTypeName(), *typeReference.resolvedType());</span>
<span class="line-modified">!     }</span>
<span class="line-modified">!     if (is&lt;AST::PointerType&gt;(unnamedType)) {</span>
<span class="line-modified">!         auto&amp; pointerType = downcast&lt;AST::PointerType&gt;(unnamedType);</span>
<span class="line-modified">!         return makeUniqueRef&lt;PointerTypeNameNode&gt;(parent, generateNextTypeName(), pointerType.addressSpace());</span>
<span class="line-modified">!     }</span>
<span class="line-modified">!     if (is&lt;AST::ArrayReferenceType&gt;(unnamedType)) {</span>
<span class="line-modified">!         auto&amp; arrayReferenceType = downcast&lt;AST::ArrayReferenceType&gt;(unnamedType);</span>
<span class="line-removed">-         return makeUniqueRef&lt;ArrayReferenceTypeNameNode&gt;(parent, generateNextTypeName(), arrayReferenceType.addressSpace());</span>
      }
<span class="line-removed">-     ASSERT(is&lt;AST::ArrayType&gt;(unnamedType));</span>
<span class="line-removed">-     auto&amp; arrayType = downcast&lt;AST::ArrayType&gt;(unnamedType);</span>
<span class="line-removed">-     return makeUniqueRef&lt;ArrayTypeNameNode&gt;(parent, generateNextTypeName(), arrayType.numElements());</span>
  }
  
<span class="line-modified">! size_t TypeNamer::insert(AST::UnnamedType&amp; unnamedType, Vector&lt;UniqueRef&lt;BaseTypeNameNode&gt;&gt;&amp; types)</span>
  {
<span class="line-modified">!     Vector&lt;UniqueRef&lt;BaseTypeNameNode&gt;&gt;* vectorToInsertInto { nullptr };</span>
<span class="line-modified">!     BaseTypeNameNode* parent { nullptr };</span>
<span class="line-modified">!     if (is&lt;AST::TypeReference&gt;(unnamedType)) {</span>
<span class="line-removed">-         vectorToInsertInto = &amp;types;</span>
<span class="line-removed">-         parent = nullptr;</span>
<span class="line-removed">-     } else if (is&lt;AST::PointerType&gt;(unnamedType)) {</span>
<span class="line-removed">-         auto&amp; item = types[insert(downcast&lt;AST::PointerType&gt;(unnamedType).elementType(), types)];</span>
<span class="line-removed">-         vectorToInsertInto = &amp;item-&gt;children();</span>
<span class="line-removed">-         parent = &amp;item;</span>
<span class="line-removed">-     } else if (is&lt;AST::ArrayReferenceType&gt;(unnamedType)) {</span>
<span class="line-removed">-         auto&amp; item = types[insert(downcast&lt;AST::ArrayReferenceType&gt;(unnamedType).elementType(), types)];</span>
<span class="line-removed">-         vectorToInsertInto = &amp;item-&gt;children();</span>
<span class="line-removed">-         parent = &amp;item;</span>
<span class="line-removed">-     } else {</span>
<span class="line-removed">-         ASSERT(is&lt;AST::ArrayType&gt;(unnamedType));</span>
<span class="line-removed">-         auto&amp; item = types[insert(downcast&lt;AST::ArrayType&gt;(unnamedType).type(), types)];</span>
<span class="line-removed">-         vectorToInsertInto = &amp;item-&gt;children();</span>
<span class="line-removed">-         parent = &amp;item;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     ASSERT(vectorToInsertInto);</span>
  
<span class="line-modified">!     auto iterator = findInVector(unnamedType, *vectorToInsertInto);</span>
<span class="line-modified">!     if (iterator == vectorToInsertInto-&gt;end()) {</span>
<span class="line-modified">!         auto result = createNameNode(unnamedType, parent);</span>
<span class="line-removed">-         {</span>
<span class="line-removed">-             auto addResult = m_unnamedTypeMapping.add(&amp;unnamedType, &amp;result);</span>
<span class="line-removed">-             ASSERT_UNUSED(addResult, addResult.isNewEntry);</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         vectorToInsertInto-&gt;append(WTFMove(result));</span>
<span class="line-removed">-         return vectorToInsertInto-&gt;size() - 1;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     auto addResult = m_unnamedTypeMapping.add(&amp;unnamedType, &amp;*iterator);</span>
<span class="line-removed">-     ASSERT_UNUSED(addResult, addResult.isNewEntry);</span>
<span class="line-removed">-     return iterator - vectorToInsertInto-&gt;begin();</span>
  }
  
<span class="line-modified">! class MetalTypeDeclarationWriter : public Visitor {</span>
  public:
<span class="line-modified">!     MetalTypeDeclarationWriter(std::function&lt;String(AST::NamedType&amp;)&gt;&amp;&amp; mangledNameForNamedType, std::function&lt;String(AST::UnnamedType&amp;)&gt;&amp;&amp; mangledNameForUnnamedType, std::function&lt;String(AST::EnumerationMember&amp;)&gt;&amp;&amp; mangledNameForEnumerationMember)</span>
          : m_mangledNameForNamedType(WTFMove(mangledNameForNamedType))
<span class="line-modified">!         , m_mangledNameForUnnamedType(WTFMove(mangledNameForUnnamedType))</span>
<span class="line-removed">-         , m_mangledNameForEnumerationMember(WTFMove(mangledNameForEnumerationMember))</span>
      {
      }
  
<span class="line-removed">-     String toString() { return m_stringBuilder.toString(); }</span>
<span class="line-removed">- </span>
  private:
<span class="line-modified">!     void visit(AST::EnumerationDefinition&amp; enumerationDefinition)</span>
      {
<span class="line-modified">!         auto&amp; baseType = enumerationDefinition.type().unifyNode();</span>
<span class="line-removed">-         ASSERT(is&lt;AST::NamedType&gt;(baseType));</span>
<span class="line-removed">-         m_stringBuilder.append(makeString(&quot;enum class &quot;, m_mangledNameForNamedType(enumerationDefinition), &quot; : &quot;, m_mangledNameForNamedType(downcast&lt;AST::NamedType&gt;(baseType)), &quot; {\n&quot;));</span>
<span class="line-removed">-         for (auto&amp; enumerationMember : enumerationDefinition.enumerationMembers())</span>
<span class="line-removed">-             m_stringBuilder.append(makeString(&quot;    &quot;, m_mangledNameForEnumerationMember(enumerationMember), &quot;,\n&quot;));</span>
<span class="line-removed">-         m_stringBuilder.append(&quot;};\n&quot;);</span>
      }
  
<span class="line-modified">!     void visit(AST::StructureDefinition&amp; structureDefinition)</span>
<span class="line-modified">!     {</span>
<span class="line-removed">-         m_stringBuilder.append(makeString(&quot;struct &quot;, m_mangledNameForNamedType(structureDefinition), &quot;;\n&quot;));</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     std::function&lt;String(AST::NamedType&amp;)&gt; m_mangledNameForNamedType;</span>
<span class="line-removed">-     std::function&lt;String(AST::UnnamedType&amp;)&gt; m_mangledNameForUnnamedType;</span>
<span class="line-removed">-     std::function&lt;String(AST::EnumerationMember&amp;)&gt;&amp;&amp; m_mangledNameForEnumerationMember;</span>
<span class="line-removed">-     StringBuilder m_stringBuilder;</span>
  };
  
<span class="line-modified">! String TypeNamer::metalTypeDeclarations()</span>
  {
<span class="line-modified">!     MetalTypeDeclarationWriter metalTypeDeclarationWriter([&amp;](AST::NamedType&amp; namedType) -&gt; String {</span>
          return mangledNameForType(namedType);
<span class="line-removed">-     }, [&amp;](AST::UnnamedType&amp; unnamedType) -&gt; String {</span>
<span class="line-removed">-         return mangledNameForType(unnamedType);</span>
<span class="line-removed">-     }, [&amp;](AST::EnumerationMember&amp; enumerationMember) -&gt; String {</span>
<span class="line-removed">-         return mangledNameForEnumerationMember(enumerationMember);</span>
      });
      metalTypeDeclarationWriter.Visitor::visit(m_program);
<span class="line-removed">-     return metalTypeDeclarationWriter.toString();</span>
  }
  
<span class="line-modified">! static String toString(AST::AddressSpace addressSpace)</span>
  {
<span class="line-modified">!     switch (addressSpace) {</span>
<span class="line-modified">!     case AST::AddressSpace::Constant:</span>
<span class="line-modified">!         return &quot;constant&quot;_str;</span>
<span class="line-modified">!     case AST::AddressSpace::Device:</span>
<span class="line-modified">!         return &quot;device&quot;_str;</span>
<span class="line-modified">!     case AST::AddressSpace::Threadgroup:</span>
<span class="line-modified">!         return &quot;threadgroup&quot;_str;</span>
<span class="line-modified">!     default:</span>
<span class="line-modified">!         ASSERT(addressSpace == AST::AddressSpace::Thread);</span>
<span class="line-modified">!         return &quot;thread&quot;_str;</span>
      }
<span class="line-modified">! }</span>
  
<span class="line-modified">! void TypeNamer::emitUnnamedTypeDefinition(BaseTypeNameNode&amp; baseTypeNameNode, HashSet&lt;AST::NamedType*&gt;&amp; emittedNamedTypes, HashSet&lt;BaseTypeNameNode*&gt;&amp; emittedUnnamedTypes, StringBuilder&amp; stringBuilder)</span>
<span class="line-modified">! {</span>
<span class="line-modified">!     if (emittedUnnamedTypes.contains(&amp;baseTypeNameNode))</span>
<span class="line-modified">!         return;</span>
<span class="line-modified">!     if (baseTypeNameNode.parent())</span>
<span class="line-modified">!         emitUnnamedTypeDefinition(*baseTypeNameNode.parent(), emittedNamedTypes, emittedUnnamedTypes, stringBuilder);</span>
<span class="line-removed">-     if (is&lt;ReferenceTypeNameNode&gt;(baseTypeNameNode)) {</span>
<span class="line-removed">-         auto&amp; namedType = downcast&lt;ReferenceTypeNameNode&gt;(baseTypeNameNode).namedType();</span>
<span class="line-removed">-         emitNamedTypeDefinition(namedType, emittedNamedTypes, emittedUnnamedTypes, stringBuilder);</span>
<span class="line-removed">-         stringBuilder.append(makeString(&quot;typedef &quot;, mangledNameForType(namedType), &#39; &#39;, baseTypeNameNode.mangledName(), &quot;;\n&quot;));</span>
<span class="line-removed">-     } else if (is&lt;PointerTypeNameNode&gt;(baseTypeNameNode)) {</span>
<span class="line-removed">-         auto&amp; pointerType = downcast&lt;PointerTypeNameNode&gt;(baseTypeNameNode);</span>
<span class="line-removed">-         ASSERT(baseTypeNameNode.parent());</span>
<span class="line-removed">-         stringBuilder.append(makeString(&quot;typedef &quot;, toString(pointerType.addressSpace()), &quot; &quot;, pointerType.parent()-&gt;mangledName(), &quot;* &quot;, pointerType.mangledName(), &quot;;\n&quot;));</span>
<span class="line-removed">-     } else if (is&lt;ArrayReferenceTypeNameNode&gt;(baseTypeNameNode)) {</span>
<span class="line-removed">-         auto&amp; arrayReferenceType = downcast&lt;ArrayReferenceTypeNameNode&gt;(baseTypeNameNode);</span>
<span class="line-removed">-         ASSERT(baseTypeNameNode.parent());</span>
<span class="line-removed">-         stringBuilder.append(makeString(&quot;struct &quot;, arrayReferenceType.mangledName(), &quot;{ \n&quot;));</span>
<span class="line-removed">-         stringBuilder.append(makeString(&quot;    &quot;, toString(arrayReferenceType.addressSpace()), &quot; &quot;, arrayReferenceType.parent()-&gt;mangledName(), &quot;* pointer;\n&quot;));</span>
<span class="line-removed">-         stringBuilder.append(&quot;    unsigned length;\n&quot;);</span>
<span class="line-removed">-         stringBuilder.append(&quot;};\n&quot;);</span>
<span class="line-removed">-     } else {</span>
<span class="line-removed">-         ASSERT(is&lt;ArrayTypeNameNode&gt;(baseTypeNameNode));</span>
<span class="line-removed">-         auto&amp; arrayType = downcast&lt;ArrayTypeNameNode&gt;(baseTypeNameNode);</span>
<span class="line-removed">-         ASSERT(baseTypeNameNode.parent());</span>
<span class="line-removed">-         stringBuilder.append(makeString(&quot;typedef Array&lt;&quot;, arrayType.parent()-&gt;mangledName(), &quot;, &quot;, arrayType.numElements(), &quot;&gt; &quot;, arrayType.mangledName(), &quot;;\n&quot;));</span>
      }
<span class="line-modified">!     emittedUnnamedTypes.add(&amp;baseTypeNameNode);</span>
  }
  
<span class="line-modified">! void TypeNamer::emitNamedTypeDefinition(AST::NamedType&amp; namedType, HashSet&lt;AST::NamedType*&gt;&amp; emittedNamedTypes, HashSet&lt;BaseTypeNameNode*&gt;&amp; emittedUnnamedTypes, StringBuilder&amp; stringBuilder)</span>
  {
      if (emittedNamedTypes.contains(&amp;namedType))
          return;
<span class="line-modified">!     auto iterator = m_dependencyGraph.find(&amp;namedType);</span>
<span class="line-modified">!     ASSERT(iterator != m_dependencyGraph.end());</span>
<span class="line-modified">!     for (auto&amp; baseTypeNameNode : iterator-&gt;value)</span>
<span class="line-modified">!         emitUnnamedTypeDefinition(baseTypeNameNode, emittedNamedTypes, emittedUnnamedTypes, stringBuilder);</span>
<span class="line-modified">!     if (is&lt;AST::EnumerationDefinition&gt;(namedType)) {</span>
<span class="line-modified">!         // We already emitted this in the type declaration section. There&#39;s nothing to do.</span>
<span class="line-modified">!     } else if (is&lt;AST::NativeTypeDeclaration&gt;(namedType)) {</span>
          // Native types already have definitions. There&#39;s nothing to do.
<span class="line-modified">!     } else if (is&lt;AST::StructureDefinition&gt;(namedType)) {</span>
          auto&amp; structureDefinition = downcast&lt;AST::StructureDefinition&gt;(namedType);
<span class="line-modified">!         stringBuilder.append(makeString(&quot;struct &quot;, mangledNameForType(structureDefinition), &quot; {\n&quot;));</span>
          for (auto&amp; structureElement : structureDefinition.structureElements())
<span class="line-modified">!             stringBuilder.append(makeString(&quot;    &quot;, mangledNameForType(structureElement.type()), &#39; &#39;, mangledNameForStructureElement(structureElement), &quot;;\n&quot;));</span>
          stringBuilder.append(&quot;};\n&quot;);
<span class="line-modified">!     } else {</span>
<span class="line-modified">!         ASSERT(is&lt;AST::TypeDefinition&gt;(namedType));</span>
          auto&amp; typeDefinition = downcast&lt;AST::TypeDefinition&gt;(namedType);
<span class="line-modified">!         stringBuilder.append(makeString(&quot;typedef &quot;, mangledNameForType(typeDefinition.type()), &#39; &#39;, mangledNameForType(typeDefinition), &quot;;\n&quot;));</span>
      }
      emittedNamedTypes.add(&amp;namedType);
  }
  
<span class="line-modified">! String TypeNamer::metalTypeDefinitions()</span>
  {
      HashSet&lt;AST::NamedType*&gt; emittedNamedTypes;
<span class="line-modified">!     HashSet&lt;BaseTypeNameNode*&gt; emittedUnnamedTypes;</span>
<span class="line-modified">!     StringBuilder stringBuilder;</span>
<span class="line-modified">!     for (auto&amp; keyValuePair : m_dependencyGraph)</span>
<span class="line-modified">!         emitNamedTypeDefinition(*keyValuePair.key, emittedNamedTypes, emittedUnnamedTypes, stringBuilder);</span>
<span class="line-modified">!     for (auto&amp; baseTypeNameNode : m_trie)</span>
<span class="line-removed">-         emitUnnamedTypeDefinition(baseTypeNameNode, emittedNamedTypes, emittedUnnamedTypes, stringBuilder);</span>
<span class="line-removed">-     return stringBuilder.toString();</span>
  }
  
<span class="line-modified">! String TypeNamer::mangledNameForType(AST::UnnamedType&amp; unnamedType)</span>
  {
<span class="line-modified">!     return find(unnamedType, m_trie).mangledName();</span>
  }
  
<span class="line-modified">! String TypeNamer::mangledNameForType(AST::NamedType&amp; namedType)</span>
  {
      if (is&lt;AST::NativeTypeDeclaration&gt;(namedType))
          return mangledNameForType(downcast&lt;AST::NativeTypeDeclaration&gt;(namedType));
      auto iterator = m_namedTypeMapping.find(&amp;namedType);
      ASSERT(iterator != m_namedTypeMapping.end());
      return iterator-&gt;value;
  }
  
<span class="line-modified">! </span>
<span class="line-removed">- String TypeNamer::mangledNameForEnumerationMember(AST::EnumerationMember&amp; enumerationMember)</span>
  {
      auto iterator = m_enumerationMemberMapping.find(&amp;enumerationMember);
      ASSERT(iterator != m_enumerationMemberMapping.end());
      return iterator-&gt;value;
  }
  
<span class="line-modified">! String TypeNamer::mangledNameForStructureElement(AST::StructureElement&amp; structureElement)</span>
  {
      auto iterator = m_structureElementMapping.find(&amp;structureElement);
      ASSERT(iterator != m_structureElementMapping.end());
      return iterator-&gt;value;
  }
  
<span class="line-modified">! String TypeNamer::metalTypes()</span>
  {
      Visitor::visit(m_program);
<span class="line-modified">!     StringBuilder stringBuilder;</span>
<span class="line-modified">!     stringBuilder.append(metalTypeDeclarations());</span>
      stringBuilder.append(&#39;\n&#39;);
<span class="line-modified">!     stringBuilder.append(metalTypeDefinitions());</span>
<span class="line-removed">-     return stringBuilder.toString();</span>
  }
  
  } // namespace Metal
  
  } // namespace WHLSL
<span class="line-new-header">--- 122,238 ---</span>
          auto addResult = m_namedTypeMapping.add(&amp;typeDefinition, generateNextTypeName());
          ASSERT_UNUSED(addResult, addResult.isNewEntry);
      }
      Visitor::visit(typeDefinition);
      {
<span class="line-modified">!         auto addResult = m_dependencyGraph.add(&amp;typeDefinition, Vector&lt;std::reference_wrapper&lt;AST::UnnamedType&gt;&gt; { typeDefinition.type() });</span>
          ASSERT_UNUSED(addResult, addResult.isNewEntry);
      }
  }
  
<span class="line-added">+ void TypeNamer::visit(AST::Expression&amp; expression)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     generateUniquedTypeName(expression.resolvedType());</span>
<span class="line-added">+     Visitor::visit(expression);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void TypeNamer::visit(AST::CallExpression&amp; callExpression)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     for (auto&amp; argument : callExpression.arguments())</span>
<span class="line-added">+         checkErrorAndVisit(argument);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  String TypeNamer::mangledNameForType(AST::NativeTypeDeclaration&amp; nativeTypeDeclaration)
  {
      return writeNativeType(nativeTypeDeclaration);
  }
  
<span class="line-modified">! static AST::UnnamedType* parent(AST::UnnamedType&amp; unnamedType)</span>
  {
<span class="line-modified">!     switch (unnamedType.kind()) {</span>
<span class="line-modified">!     case AST::UnnamedType::Kind::TypeReference:</span>
<span class="line-modified">!         return nullptr;</span>
<span class="line-modified">!     case AST::UnnamedType::Kind::Pointer:</span>
<span class="line-modified">!         return &amp;downcast&lt;AST::PointerType&gt;(unnamedType).elementType();</span>
<span class="line-modified">!     case AST::UnnamedType::Kind::ArrayReference:</span>
<span class="line-modified">!         return &amp;downcast&lt;AST::ArrayReferenceType&gt;(unnamedType).elementType();</span>
<span class="line-modified">!     case AST::UnnamedType::Kind::Array:</span>
<span class="line-modified">!         return &amp;downcast&lt;AST::ArrayType&gt;(unnamedType).type();</span>
<span class="line-modified">!     default:</span>
<span class="line-modified">!         RELEASE_ASSERT_NOT_REACHED();</span>
      }
  }
  
<span class="line-modified">! void TypeNamer::generateUniquedTypeName(AST::UnnamedType&amp; unnamedType)</span>
  {
<span class="line-modified">!     auto* parentUnnamedType = parent(unnamedType);</span>
<span class="line-modified">!     if (parentUnnamedType)</span>
<span class="line-modified">!         generateUniquedTypeName(*parentUnnamedType);</span>
  
<span class="line-modified">!     m_unnamedTypeMapping.ensure(UnnamedTypeKey { unnamedType }, [&amp;] {</span>
<span class="line-modified">!         return generateNextTypeName();</span>
<span class="line-modified">!     });</span>
  }
  
<span class="line-modified">! class MetalTypeDeclarationWriter final : public Visitor {</span>
<span class="line-added">+     WTF_MAKE_FAST_ALLOCATED;</span>
  public:
<span class="line-modified">!     MetalTypeDeclarationWriter(StringBuilder&amp; stringBuilder, std::function&lt;MangledOrNativeTypeName(AST::NamedType&amp;)&gt;&amp;&amp; mangledNameForNamedType)</span>
          : m_mangledNameForNamedType(WTFMove(mangledNameForNamedType))
<span class="line-modified">!         , m_stringBuilder(stringBuilder)</span>
      {
      }
  
  private:
<span class="line-modified">!     void visit(AST::StructureDefinition&amp; structureDefinition) override</span>
      {
<span class="line-modified">!         m_stringBuilder.append(&quot;struct &quot;, m_mangledNameForNamedType(structureDefinition), &quot;;\n&quot;);</span>
      }
  
<span class="line-modified">!     std::function&lt;MangledOrNativeTypeName(AST::NamedType&amp;)&gt; m_mangledNameForNamedType;</span>
<span class="line-modified">!     StringBuilder&amp; m_stringBuilder;</span>
  };
  
<span class="line-modified">! void TypeNamer::emitMetalTypeDeclarations(StringBuilder&amp; stringBuilder)</span>
  {
<span class="line-modified">!     MetalTypeDeclarationWriter metalTypeDeclarationWriter(stringBuilder, [&amp;](AST::NamedType&amp; namedType) -&gt; MangledOrNativeTypeName {</span>
          return mangledNameForType(namedType);
      });
      metalTypeDeclarationWriter.Visitor::visit(m_program);
  }
  
<span class="line-modified">! void TypeNamer::emitUnnamedTypeDefinition(StringBuilder&amp; stringBuilder, AST::UnnamedType&amp; unnamedType, MangledTypeName mangledName, HashSet&lt;AST::NamedType*&gt;&amp; emittedNamedTypes, HashSet&lt;UnnamedTypeKey&gt;&amp; emittedUnnamedTypes)</span>
  {
<span class="line-modified">!     if (emittedUnnamedTypes.contains(UnnamedTypeKey { unnamedType }))</span>
<span class="line-modified">!         return;</span>
<span class="line-modified">! </span>
<span class="line-modified">!     switch (unnamedType.kind()) {</span>
<span class="line-modified">!     case AST::UnnamedType::Kind::TypeReference: {</span>
<span class="line-modified">!         auto&amp; typeReference = downcast&lt;AST::TypeReference&gt;(unnamedType);</span>
<span class="line-modified">! </span>
<span class="line-modified">!         auto&amp; parent = typeReference.resolvedType();</span>
<span class="line-modified">!         auto parentMangledName = mangledNameForType(typeReference.resolvedType());</span>
<span class="line-modified">!         auto iterator = m_dependencyGraph.find(&amp;parent);</span>
<span class="line-added">+         ASSERT(iterator != m_dependencyGraph.end());</span>
<span class="line-added">+         emitNamedTypeDefinition(stringBuilder, parent, iterator-&gt;value, emittedNamedTypes, emittedUnnamedTypes);</span>
<span class="line-added">+ </span>
<span class="line-added">+         stringBuilder.append(&quot;typedef &quot;, parentMangledName, &#39; &#39;, mangledName, &quot;;\n&quot;);</span>
<span class="line-added">+         break;</span>
      }
<span class="line-modified">!     case AST::UnnamedType::Kind::Pointer: {</span>
<span class="line-added">+         auto&amp; pointerType = downcast&lt;AST::PointerType&gt;(unnamedType);</span>
  
<span class="line-modified">!         auto&amp; parent = pointerType.elementType();</span>
<span class="line-modified">!         auto parentMangledName = mangledNameForType(parent);</span>
<span class="line-modified">!         emitUnnamedTypeDefinition(stringBuilder, parent, parentMangledName, emittedNamedTypes, emittedUnnamedTypes);</span>
<span class="line-modified">! </span>
<span class="line-modified">!         stringBuilder.append(&quot;typedef &quot;, toString(pointerType.addressSpace()), &#39; &#39;, parentMangledName, &quot;* &quot;, mangledName, &quot;;\n&quot;);</span>
<span class="line-modified">!         break;</span>
      }
<span class="line-modified">!     case AST::UnnamedType::Kind::ArrayReference: {</span>
<span class="line-added">+         auto&amp; arrayReferenceType = downcast&lt;AST::ArrayReferenceType&gt;(unnamedType);</span>
<span class="line-added">+ </span>
<span class="line-added">+         auto&amp; parent = arrayReferenceType.elementType();</span>
<span class="line-added">+         auto parentMangledName = mangledNameForType(parent);</span>
<span class="line-added">+         emitUnnamedTypeDefinition(stringBuilder, parent, parentMangledName, emittedNamedTypes, emittedUnnamedTypes);</span>
<span class="line-added">+ </span>
<span class="line-added">+         stringBuilder.append(</span>
<span class="line-added">+             &quot;struct &quot;, mangledName, &quot; {\n&quot;</span>
<span class="line-added">+             &quot;    &quot;, toString(arrayReferenceType.addressSpace()), &#39; &#39;, parentMangledName, &quot;* pointer;\n&quot;</span>
<span class="line-added">+             &quot;    uint32_t length;\n&quot;</span>
<span class="line-added">+             &quot;};\n&quot;</span>
<span class="line-added">+         );</span>
<span class="line-added">+         break;</span>
<span class="line-added">+     }</span>
<span class="line-added">+     case AST::UnnamedType::Kind::Array: {</span>
<span class="line-added">+         auto&amp; arrayType = downcast&lt;AST::ArrayType&gt;(unnamedType);</span>
<span class="line-added">+ </span>
<span class="line-added">+         auto&amp; parent = arrayType.type();</span>
<span class="line-added">+         auto parentMangledName = mangledNameForType(parent);</span>
<span class="line-added">+         emitUnnamedTypeDefinition(stringBuilder, parent, parentMangledName, emittedNamedTypes, emittedUnnamedTypes);</span>
<span class="line-added">+ </span>
<span class="line-added">+         stringBuilder.append(&quot;typedef array&lt;&quot;, parentMangledName, &quot;, &quot;, arrayType.numElements(), &quot;&gt; &quot;, mangledName, &quot;;\n&quot;);</span>
<span class="line-added">+         break;</span>
<span class="line-added">+     }</span>
<span class="line-added">+     default:</span>
<span class="line-added">+         RELEASE_ASSERT_NOT_REACHED();</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     emittedUnnamedTypes.add(UnnamedTypeKey { unnamedType });</span>
  }
  
<span class="line-modified">! void TypeNamer::emitNamedTypeDefinition(StringBuilder&amp; stringBuilder, AST::NamedType&amp; namedType, Vector&lt;std::reference_wrapper&lt;AST::UnnamedType&gt;&gt;&amp; neighbors, HashSet&lt;AST::NamedType*&gt;&amp; emittedNamedTypes, HashSet&lt;UnnamedTypeKey&gt;&amp; emittedUnnamedTypes)</span>
  {
      if (emittedNamedTypes.contains(&amp;namedType))
          return;
<span class="line-modified">! </span>
<span class="line-modified">!     for (auto&amp; unnameType : neighbors)</span>
<span class="line-modified">!         emitUnnamedTypeDefinition(stringBuilder, unnameType, mangledNameForType(unnameType), emittedNamedTypes, emittedUnnamedTypes);</span>
<span class="line-modified">! </span>
<span class="line-modified">!     switch (namedType.kind()) {</span>
<span class="line-modified">!     case AST::NamedType::Kind::EnumerationDefinition: {</span>
<span class="line-modified">!         auto&amp; enumerationDefinition = downcast&lt;AST::EnumerationDefinition&gt;(namedType);</span>
<span class="line-added">+         auto&amp; baseType = enumerationDefinition.type().unifyNode();</span>
<span class="line-added">+ </span>
<span class="line-added">+         stringBuilder.append(&quot;enum class &quot;, mangledNameForType(enumerationDefinition), &quot; : &quot;, mangledNameForType(downcast&lt;AST::NamedType&gt;(baseType)), &quot; {\n&quot;);</span>
<span class="line-added">+         for (auto&amp; enumerationMember : enumerationDefinition.enumerationMembers())</span>
<span class="line-added">+             stringBuilder.append(&quot;    &quot;, mangledNameForEnumerationMember(enumerationMember), &quot; = &quot;, enumerationMember.get().value(), &quot;,\n&quot;);</span>
<span class="line-added">+         stringBuilder.append(&quot;};\n&quot;);</span>
<span class="line-added">+         break;</span>
<span class="line-added">+     }</span>
<span class="line-added">+     case AST::NamedType::Kind::NativeTypeDeclaration: {</span>
          // Native types already have definitions. There&#39;s nothing to do.
<span class="line-modified">!         break;</span>
<span class="line-added">+     }</span>
<span class="line-added">+     case AST::NamedType::Kind::StructureDefinition: {</span>
          auto&amp; structureDefinition = downcast&lt;AST::StructureDefinition&gt;(namedType);
<span class="line-modified">! </span>
<span class="line-added">+         stringBuilder.append(&quot;struct &quot;, mangledNameForType(structureDefinition), &quot; {\n&quot;);</span>
          for (auto&amp; structureElement : structureDefinition.structureElements())
<span class="line-modified">!             stringBuilder.append(&quot;    &quot;, mangledNameForType(structureElement.type()), &#39; &#39;, mangledNameForStructureElement(structureElement), &quot;;\n&quot;);</span>
          stringBuilder.append(&quot;};\n&quot;);
<span class="line-modified">!         break;</span>
<span class="line-modified">!     }</span>
<span class="line-added">+     case AST::NamedType::Kind::TypeDefinition: {</span>
          auto&amp; typeDefinition = downcast&lt;AST::TypeDefinition&gt;(namedType);
<span class="line-modified">! </span>
<span class="line-added">+         stringBuilder.append(&quot;typedef &quot;, mangledNameForType(typeDefinition.type()), &#39; &#39;, mangledNameForType(typeDefinition), &quot;;\n&quot;);</span>
<span class="line-added">+         break;</span>
<span class="line-added">+     }</span>
<span class="line-added">+     default:</span>
<span class="line-added">+         RELEASE_ASSERT_NOT_REACHED();</span>
      }
<span class="line-added">+ </span>
      emittedNamedTypes.add(&amp;namedType);
  }
  
<span class="line-modified">! void TypeNamer::emitMetalTypeDefinitions(StringBuilder&amp; stringBuilder)</span>
  {
      HashSet&lt;AST::NamedType*&gt; emittedNamedTypes;
<span class="line-modified">!     HashSet&lt;UnnamedTypeKey&gt; emittedUnnamedTypes;</span>
<span class="line-modified">!     for (auto&amp; [namedType, neighbors] : m_dependencyGraph)</span>
<span class="line-modified">!         emitNamedTypeDefinition(stringBuilder, *namedType, neighbors, emittedNamedTypes, emittedUnnamedTypes);</span>
<span class="line-modified">!     for (auto&amp; [unnamedTypeKey, mangledName] : m_unnamedTypeMapping)</span>
<span class="line-modified">!         emitUnnamedTypeDefinition(stringBuilder, unnamedTypeKey.unnamedType(), mangledName, emittedNamedTypes, emittedUnnamedTypes);</span>
  }
  
<span class="line-modified">! MangledTypeName TypeNamer::mangledNameForType(AST::UnnamedType&amp; unnamedType)</span>
  {
<span class="line-modified">!     auto iterator = m_unnamedTypeMapping.find(UnnamedTypeKey { unnamedType });</span>
<span class="line-added">+     ASSERT(iterator != m_unnamedTypeMapping.end());</span>
<span class="line-added">+     return iterator-&gt;value;</span>
  }
  
<span class="line-modified">! MangledOrNativeTypeName TypeNamer::mangledNameForType(AST::NamedType&amp; namedType)</span>
  {
      if (is&lt;AST::NativeTypeDeclaration&gt;(namedType))
          return mangledNameForType(downcast&lt;AST::NativeTypeDeclaration&gt;(namedType));
      auto iterator = m_namedTypeMapping.find(&amp;namedType);
      ASSERT(iterator != m_namedTypeMapping.end());
      return iterator-&gt;value;
  }
  
<span class="line-modified">! MangledEnumerationMemberName TypeNamer::mangledNameForEnumerationMember(AST::EnumerationMember&amp; enumerationMember)</span>
  {
      auto iterator = m_enumerationMemberMapping.find(&amp;enumerationMember);
      ASSERT(iterator != m_enumerationMemberMapping.end());
      return iterator-&gt;value;
  }
  
<span class="line-modified">! MangledStructureElementName TypeNamer::mangledNameForStructureElement(AST::StructureElement&amp; structureElement)</span>
  {
      auto iterator = m_structureElementMapping.find(&amp;structureElement);
      ASSERT(iterator != m_structureElementMapping.end());
      return iterator-&gt;value;
  }
  
<span class="line-modified">! void TypeNamer::emitMetalTypes(StringBuilder&amp; stringBuilder)</span>
  {
      Visitor::visit(m_program);
<span class="line-modified">! </span>
<span class="line-modified">!     emitMetalTypeDeclarations(stringBuilder);</span>
      stringBuilder.append(&#39;\n&#39;);
<span class="line-modified">!     emitMetalTypeDefinitions(stringBuilder);</span>
  }
  
  } // namespace Metal
  
  } // namespace WHLSL
</pre>
<center><a href="WHLSLNativeTypeWriter.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="WHLSLTypeNamer.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>