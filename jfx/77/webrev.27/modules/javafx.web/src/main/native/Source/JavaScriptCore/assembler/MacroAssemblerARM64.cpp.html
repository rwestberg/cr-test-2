<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/JavaScriptCore/assembler/MacroAssemblerARM64.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2013-2019 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 
 28 #if ENABLE(ASSEMBLER) &amp;&amp; CPU(ARM64)
 29 #include &quot;MacroAssembler.h&quot;
 30 
 31 #include &quot;ProbeContext.h&quot;
 32 #include &lt;wtf/InlineASM.h&gt;
 33 
 34 #if OS(LINUX)
 35 #include &lt;asm/hwcap.h&gt;
 36 #include &lt;sys/auxv.h&gt;
 37 #endif
 38 
 39 namespace JSC {
 40 
 41 #if ENABLE(MASM_PROBE)
 42 
 43 extern &quot;C&quot; void ctiMasmProbeTrampoline();
 44 
 45 using namespace ARM64Registers;
 46 
 47 #if COMPILER(GCC_COMPATIBLE)
 48 
 49 // The following are offsets for Probe::State fields accessed
 50 // by the ctiMasmProbeTrampoline stub.
 51 #if CPU(ADDRESS64)
 52 #define PTR_SIZE 8
 53 #else
 54 #define PTR_SIZE 4
 55 #endif
 56 
 57 #define PROBE_PROBE_FUNCTION_OFFSET (0 * PTR_SIZE)
 58 #define PROBE_ARG_OFFSET (1 * PTR_SIZE)
 59 #define PROBE_INIT_STACK_FUNCTION_OFFSET (2 * PTR_SIZE)
 60 #define PROBE_INIT_STACK_ARG_OFFSET (3 * PTR_SIZE)
 61 
 62 #define PROBE_FIRST_GPREG_OFFSET (4 * PTR_SIZE)
 63 
 64 #define GPREG_SIZE 8
 65 #define PROBE_CPU_X0_OFFSET (PROBE_FIRST_GPREG_OFFSET + (0 * GPREG_SIZE))
 66 #define PROBE_CPU_X1_OFFSET (PROBE_FIRST_GPREG_OFFSET + (1 * GPREG_SIZE))
 67 #define PROBE_CPU_X2_OFFSET (PROBE_FIRST_GPREG_OFFSET + (2 * GPREG_SIZE))
 68 #define PROBE_CPU_X3_OFFSET (PROBE_FIRST_GPREG_OFFSET + (3 * GPREG_SIZE))
 69 #define PROBE_CPU_X4_OFFSET (PROBE_FIRST_GPREG_OFFSET + (4 * GPREG_SIZE))
 70 #define PROBE_CPU_X5_OFFSET (PROBE_FIRST_GPREG_OFFSET + (5 * GPREG_SIZE))
 71 #define PROBE_CPU_X6_OFFSET (PROBE_FIRST_GPREG_OFFSET + (6 * GPREG_SIZE))
 72 #define PROBE_CPU_X7_OFFSET (PROBE_FIRST_GPREG_OFFSET + (7 * GPREG_SIZE))
 73 #define PROBE_CPU_X8_OFFSET (PROBE_FIRST_GPREG_OFFSET + (8 * GPREG_SIZE))
 74 #define PROBE_CPU_X9_OFFSET (PROBE_FIRST_GPREG_OFFSET + (9 * GPREG_SIZE))
 75 #define PROBE_CPU_X10_OFFSET (PROBE_FIRST_GPREG_OFFSET + (10 * GPREG_SIZE))
 76 #define PROBE_CPU_X11_OFFSET (PROBE_FIRST_GPREG_OFFSET + (11 * GPREG_SIZE))
 77 #define PROBE_CPU_X12_OFFSET (PROBE_FIRST_GPREG_OFFSET + (12 * GPREG_SIZE))
 78 #define PROBE_CPU_X13_OFFSET (PROBE_FIRST_GPREG_OFFSET + (13 * GPREG_SIZE))
 79 #define PROBE_CPU_X14_OFFSET (PROBE_FIRST_GPREG_OFFSET + (14 * GPREG_SIZE))
 80 #define PROBE_CPU_X15_OFFSET (PROBE_FIRST_GPREG_OFFSET + (15 * GPREG_SIZE))
 81 #define PROBE_CPU_X16_OFFSET (PROBE_FIRST_GPREG_OFFSET + (16 * GPREG_SIZE))
 82 #define PROBE_CPU_X17_OFFSET (PROBE_FIRST_GPREG_OFFSET + (17 * GPREG_SIZE))
 83 #define PROBE_CPU_X18_OFFSET (PROBE_FIRST_GPREG_OFFSET + (18 * GPREG_SIZE))
 84 #define PROBE_CPU_X19_OFFSET (PROBE_FIRST_GPREG_OFFSET + (19 * GPREG_SIZE))
 85 #define PROBE_CPU_X20_OFFSET (PROBE_FIRST_GPREG_OFFSET + (20 * GPREG_SIZE))
 86 #define PROBE_CPU_X21_OFFSET (PROBE_FIRST_GPREG_OFFSET + (21 * GPREG_SIZE))
 87 #define PROBE_CPU_X22_OFFSET (PROBE_FIRST_GPREG_OFFSET + (22 * GPREG_SIZE))
 88 #define PROBE_CPU_X23_OFFSET (PROBE_FIRST_GPREG_OFFSET + (23 * GPREG_SIZE))
 89 #define PROBE_CPU_X24_OFFSET (PROBE_FIRST_GPREG_OFFSET + (24 * GPREG_SIZE))
 90 #define PROBE_CPU_X25_OFFSET (PROBE_FIRST_GPREG_OFFSET + (25 * GPREG_SIZE))
 91 #define PROBE_CPU_X26_OFFSET (PROBE_FIRST_GPREG_OFFSET + (26 * GPREG_SIZE))
 92 #define PROBE_CPU_X27_OFFSET (PROBE_FIRST_GPREG_OFFSET + (27 * GPREG_SIZE))
 93 #define PROBE_CPU_X28_OFFSET (PROBE_FIRST_GPREG_OFFSET + (28 * GPREG_SIZE))
 94 #define PROBE_CPU_FP_OFFSET (PROBE_FIRST_GPREG_OFFSET + (29 * GPREG_SIZE))
 95 #define PROBE_CPU_LR_OFFSET (PROBE_FIRST_GPREG_OFFSET + (30 * GPREG_SIZE))
 96 #define PROBE_CPU_SP_OFFSET (PROBE_FIRST_GPREG_OFFSET + (31 * GPREG_SIZE))
 97 
 98 #define PROBE_CPU_PC_OFFSET (PROBE_FIRST_GPREG_OFFSET + (32 * GPREG_SIZE))
 99 #define PROBE_CPU_NZCV_OFFSET (PROBE_FIRST_GPREG_OFFSET + (33 * GPREG_SIZE))
100 #define PROBE_CPU_FPSR_OFFSET (PROBE_FIRST_GPREG_OFFSET + (34 * GPREG_SIZE))
101 
102 #define PROBE_FIRST_FPREG_OFFSET (PROBE_FIRST_GPREG_OFFSET + (35 * GPREG_SIZE))
103 
104 #define FPREG_SIZE 8
105 #define PROBE_CPU_Q0_OFFSET (PROBE_FIRST_FPREG_OFFSET + (0 * FPREG_SIZE))
106 #define PROBE_CPU_Q1_OFFSET (PROBE_FIRST_FPREG_OFFSET + (1 * FPREG_SIZE))
107 #define PROBE_CPU_Q2_OFFSET (PROBE_FIRST_FPREG_OFFSET + (2 * FPREG_SIZE))
108 #define PROBE_CPU_Q3_OFFSET (PROBE_FIRST_FPREG_OFFSET + (3 * FPREG_SIZE))
109 #define PROBE_CPU_Q4_OFFSET (PROBE_FIRST_FPREG_OFFSET + (4 * FPREG_SIZE))
110 #define PROBE_CPU_Q5_OFFSET (PROBE_FIRST_FPREG_OFFSET + (5 * FPREG_SIZE))
111 #define PROBE_CPU_Q6_OFFSET (PROBE_FIRST_FPREG_OFFSET + (6 * FPREG_SIZE))
112 #define PROBE_CPU_Q7_OFFSET (PROBE_FIRST_FPREG_OFFSET + (7 * FPREG_SIZE))
113 #define PROBE_CPU_Q8_OFFSET (PROBE_FIRST_FPREG_OFFSET + (8 * FPREG_SIZE))
114 #define PROBE_CPU_Q9_OFFSET (PROBE_FIRST_FPREG_OFFSET + (9 * FPREG_SIZE))
115 #define PROBE_CPU_Q10_OFFSET (PROBE_FIRST_FPREG_OFFSET + (10 * FPREG_SIZE))
116 #define PROBE_CPU_Q11_OFFSET (PROBE_FIRST_FPREG_OFFSET + (11 * FPREG_SIZE))
117 #define PROBE_CPU_Q12_OFFSET (PROBE_FIRST_FPREG_OFFSET + (12 * FPREG_SIZE))
118 #define PROBE_CPU_Q13_OFFSET (PROBE_FIRST_FPREG_OFFSET + (13 * FPREG_SIZE))
119 #define PROBE_CPU_Q14_OFFSET (PROBE_FIRST_FPREG_OFFSET + (14 * FPREG_SIZE))
120 #define PROBE_CPU_Q15_OFFSET (PROBE_FIRST_FPREG_OFFSET + (15 * FPREG_SIZE))
121 #define PROBE_CPU_Q16_OFFSET (PROBE_FIRST_FPREG_OFFSET + (16 * FPREG_SIZE))
122 #define PROBE_CPU_Q17_OFFSET (PROBE_FIRST_FPREG_OFFSET + (17 * FPREG_SIZE))
123 #define PROBE_CPU_Q18_OFFSET (PROBE_FIRST_FPREG_OFFSET + (18 * FPREG_SIZE))
124 #define PROBE_CPU_Q19_OFFSET (PROBE_FIRST_FPREG_OFFSET + (19 * FPREG_SIZE))
125 #define PROBE_CPU_Q20_OFFSET (PROBE_FIRST_FPREG_OFFSET + (20 * FPREG_SIZE))
126 #define PROBE_CPU_Q21_OFFSET (PROBE_FIRST_FPREG_OFFSET + (21 * FPREG_SIZE))
127 #define PROBE_CPU_Q22_OFFSET (PROBE_FIRST_FPREG_OFFSET + (22 * FPREG_SIZE))
128 #define PROBE_CPU_Q23_OFFSET (PROBE_FIRST_FPREG_OFFSET + (23 * FPREG_SIZE))
129 #define PROBE_CPU_Q24_OFFSET (PROBE_FIRST_FPREG_OFFSET + (24 * FPREG_SIZE))
130 #define PROBE_CPU_Q25_OFFSET (PROBE_FIRST_FPREG_OFFSET + (25 * FPREG_SIZE))
131 #define PROBE_CPU_Q26_OFFSET (PROBE_FIRST_FPREG_OFFSET + (26 * FPREG_SIZE))
132 #define PROBE_CPU_Q27_OFFSET (PROBE_FIRST_FPREG_OFFSET + (27 * FPREG_SIZE))
133 #define PROBE_CPU_Q28_OFFSET (PROBE_FIRST_FPREG_OFFSET + (28 * FPREG_SIZE))
134 #define PROBE_CPU_Q29_OFFSET (PROBE_FIRST_FPREG_OFFSET + (29 * FPREG_SIZE))
135 #define PROBE_CPU_Q30_OFFSET (PROBE_FIRST_FPREG_OFFSET + (30 * FPREG_SIZE))
136 #define PROBE_CPU_Q31_OFFSET (PROBE_FIRST_FPREG_OFFSET + (31 * FPREG_SIZE))
137 #define PROBE_SIZE (PROBE_FIRST_FPREG_OFFSET + (32 * FPREG_SIZE))
138 
139 #define SAVED_PROBE_RETURN_PC_OFFSET        (PROBE_SIZE + (0 * GPREG_SIZE))
140 #define PROBE_SIZE_PLUS_EXTRAS              (PROBE_SIZE + (3 * GPREG_SIZE))
141 
142 // These ASSERTs remind you that if you change the layout of Probe::State,
143 // you need to change ctiMasmProbeTrampoline offsets above to match.
144 #define PROBE_OFFSETOF(x) offsetof(struct Probe::State, x)
145 static_assert(PROBE_OFFSETOF(probeFunction) == PROBE_PROBE_FUNCTION_OFFSET, &quot;Probe::State::probeFunction&#39;s offset matches ctiMasmProbeTrampoline&quot;);
146 static_assert(PROBE_OFFSETOF(arg) == PROBE_ARG_OFFSET, &quot;Probe::State::arg&#39;s offset matches ctiMasmProbeTrampoline&quot;);
147 static_assert(PROBE_OFFSETOF(initializeStackFunction) == PROBE_INIT_STACK_FUNCTION_OFFSET, &quot;Probe::State::initializeStackFunction&#39;s offset matches ctiMasmProbeTrampoline&quot;);
148 static_assert(PROBE_OFFSETOF(initializeStackArg) == PROBE_INIT_STACK_ARG_OFFSET, &quot;Probe::State::initializeStackArg&#39;s offset matches ctiMasmProbeTrampoline&quot;);
149 
150 static_assert(!(PROBE_CPU_X0_OFFSET &amp; 0x7), &quot;Probe::State::cpu.gprs[x0]&#39;s offset should be 8 byte aligned&quot;);
151 
152 static_assert(PROBE_OFFSETOF(cpu.gprs[ARM64Registers::x0]) == PROBE_CPU_X0_OFFSET, &quot;Probe::State::cpu.gprs[x0]&#39;s offset matches ctiMasmProbeTrampoline&quot;);
153 static_assert(PROBE_OFFSETOF(cpu.gprs[ARM64Registers::x1]) == PROBE_CPU_X1_OFFSET, &quot;Probe::State::cpu.gprs[x1]&#39;s offset matches ctiMasmProbeTrampoline&quot;);
154 static_assert(PROBE_OFFSETOF(cpu.gprs[ARM64Registers::x2]) == PROBE_CPU_X2_OFFSET, &quot;Probe::State::cpu.gprs[x2]&#39;s offset matches ctiMasmProbeTrampoline&quot;);
155 static_assert(PROBE_OFFSETOF(cpu.gprs[ARM64Registers::x3]) == PROBE_CPU_X3_OFFSET, &quot;Probe::State::cpu.gprs[x3]&#39;s offset matches ctiMasmProbeTrampoline&quot;);
156 static_assert(PROBE_OFFSETOF(cpu.gprs[ARM64Registers::x4]) == PROBE_CPU_X4_OFFSET, &quot;Probe::State::cpu.gprs[x4]&#39;s offset matches ctiMasmProbeTrampoline&quot;);
157 static_assert(PROBE_OFFSETOF(cpu.gprs[ARM64Registers::x5]) == PROBE_CPU_X5_OFFSET, &quot;Probe::State::cpu.gprs[x5]&#39;s offset matches ctiMasmProbeTrampoline&quot;);
158 static_assert(PROBE_OFFSETOF(cpu.gprs[ARM64Registers::x6]) == PROBE_CPU_X6_OFFSET, &quot;Probe::State::cpu.gprs[x6]&#39;s offset matches ctiMasmProbeTrampoline&quot;);
159 static_assert(PROBE_OFFSETOF(cpu.gprs[ARM64Registers::x7]) == PROBE_CPU_X7_OFFSET, &quot;Probe::State::cpu.gprs[x7]&#39;s offset matches ctiMasmProbeTrampoline&quot;);
160 static_assert(PROBE_OFFSETOF(cpu.gprs[ARM64Registers::x8]) == PROBE_CPU_X8_OFFSET, &quot;Probe::State::cpu.gprs[x8]&#39;s offset matches ctiMasmProbeTrampoline&quot;);
161 static_assert(PROBE_OFFSETOF(cpu.gprs[ARM64Registers::x9]) == PROBE_CPU_X9_OFFSET, &quot;Probe::State::cpu.gprs[x9]&#39;s offset matches ctiMasmProbeTrampoline&quot;);
162 static_assert(PROBE_OFFSETOF(cpu.gprs[ARM64Registers::x10]) == PROBE_CPU_X10_OFFSET, &quot;Probe::State::cpu.gprs[x10]&#39;s offset matches ctiMasmProbeTrampoline&quot;);
163 static_assert(PROBE_OFFSETOF(cpu.gprs[ARM64Registers::x11]) == PROBE_CPU_X11_OFFSET, &quot;Probe::State::cpu.gprs[x11]&#39;s offset matches ctiMasmProbeTrampoline&quot;);
164 static_assert(PROBE_OFFSETOF(cpu.gprs[ARM64Registers::x12]) == PROBE_CPU_X12_OFFSET, &quot;Probe::State::cpu.gprs[x12]&#39;s offset matches ctiMasmProbeTrampoline&quot;);
165 static_assert(PROBE_OFFSETOF(cpu.gprs[ARM64Registers::x13]) == PROBE_CPU_X13_OFFSET, &quot;Probe::State::cpu.gprs[x13]&#39;s offset matches ctiMasmProbeTrampoline&quot;);
166 static_assert(PROBE_OFFSETOF(cpu.gprs[ARM64Registers::x14]) == PROBE_CPU_X14_OFFSET, &quot;Probe::State::cpu.gprs[x14]&#39;s offset matches ctiMasmProbeTrampoline&quot;);
167 static_assert(PROBE_OFFSETOF(cpu.gprs[ARM64Registers::x15]) == PROBE_CPU_X15_OFFSET, &quot;Probe::State::cpu.gprs[x15]&#39;s offset matches ctiMasmProbeTrampoline&quot;);
168 
169 static_assert(PROBE_OFFSETOF(cpu.gprs[ARM64Registers::x16]) == PROBE_CPU_X16_OFFSET, &quot;Probe::State::cpu.gprs[x16]&#39;s offset matches ctiMasmProbeTrampoline&quot;);
170 static_assert(PROBE_OFFSETOF(cpu.gprs[ARM64Registers::x17]) == PROBE_CPU_X17_OFFSET, &quot;Probe::State::cpu.gprs[x17]&#39;s offset matches ctiMasmProbeTrampoline&quot;);
171 static_assert(PROBE_OFFSETOF(cpu.gprs[ARM64Registers::x18]) == PROBE_CPU_X18_OFFSET, &quot;Probe::State::cpu.gprs[x18]&#39;s offset matches ctiMasmProbeTrampoline&quot;);
172 static_assert(PROBE_OFFSETOF(cpu.gprs[ARM64Registers::x19]) == PROBE_CPU_X19_OFFSET, &quot;Probe::State::cpu.gprs[x19]&#39;s offset matches ctiMasmProbeTrampoline&quot;);
173 static_assert(PROBE_OFFSETOF(cpu.gprs[ARM64Registers::x20]) == PROBE_CPU_X20_OFFSET, &quot;Probe::State::cpu.gprs[x20]&#39;s offset matches ctiMasmProbeTrampoline&quot;);
174 static_assert(PROBE_OFFSETOF(cpu.gprs[ARM64Registers::x21]) == PROBE_CPU_X21_OFFSET, &quot;Probe::State::cpu.gprs[x21]&#39;s offset matches ctiMasmProbeTrampoline&quot;);
175 static_assert(PROBE_OFFSETOF(cpu.gprs[ARM64Registers::x22]) == PROBE_CPU_X22_OFFSET, &quot;Probe::State::cpu.gprs[x22]&#39;s offset matches ctiMasmProbeTrampoline&quot;);
176 static_assert(PROBE_OFFSETOF(cpu.gprs[ARM64Registers::x23]) == PROBE_CPU_X23_OFFSET, &quot;Probe::State::cpu.gprs[x23]&#39;s offset matches ctiMasmProbeTrampoline&quot;);
177 static_assert(PROBE_OFFSETOF(cpu.gprs[ARM64Registers::x24]) == PROBE_CPU_X24_OFFSET, &quot;Probe::State::cpu.gprs[x24]&#39;s offset matches ctiMasmProbeTrampoline&quot;);
178 static_assert(PROBE_OFFSETOF(cpu.gprs[ARM64Registers::x25]) == PROBE_CPU_X25_OFFSET, &quot;Probe::State::cpu.gprs[x25]&#39;s offset matches ctiMasmProbeTrampoline&quot;);
179 static_assert(PROBE_OFFSETOF(cpu.gprs[ARM64Registers::x26]) == PROBE_CPU_X26_OFFSET, &quot;Probe::State::cpu.gprs[x26]&#39;s offset matches ctiMasmProbeTrampoline&quot;);
180 static_assert(PROBE_OFFSETOF(cpu.gprs[ARM64Registers::x27]) == PROBE_CPU_X27_OFFSET, &quot;Probe::State::cpu.gprs[x27]&#39;s offset matches ctiMasmProbeTrampoline&quot;);
181 static_assert(PROBE_OFFSETOF(cpu.gprs[ARM64Registers::x28]) == PROBE_CPU_X28_OFFSET, &quot;Probe::State::cpu.gprs[x28]&#39;s offset matches ctiMasmProbeTrampoline&quot;);
182 static_assert(PROBE_OFFSETOF(cpu.gprs[ARM64Registers::fp]) == PROBE_CPU_FP_OFFSET, &quot;Probe::State::cpu.gprs[fp]&#39;s offset matches ctiMasmProbeTrampoline&quot;);
183 static_assert(PROBE_OFFSETOF(cpu.gprs[ARM64Registers::lr]) == PROBE_CPU_LR_OFFSET, &quot;Probe::State::cpu.gprs[lr]&#39;s offset matches ctiMasmProbeTrampoline&quot;);
184 static_assert(PROBE_OFFSETOF(cpu.gprs[ARM64Registers::sp]) == PROBE_CPU_SP_OFFSET, &quot;Probe::State::cpu.gprs[sp]&#39;s offset matches ctiMasmProbeTrampoline&quot;);
185 
186 static_assert(PROBE_OFFSETOF(cpu.sprs[ARM64Registers::pc]) == PROBE_CPU_PC_OFFSET, &quot;Probe::State::cpu.sprs[pc]&#39;s offset matches ctiMasmProbeTrampoline&quot;);
187 static_assert(PROBE_OFFSETOF(cpu.sprs[ARM64Registers::nzcv]) == PROBE_CPU_NZCV_OFFSET, &quot;Probe::State::cpu.sprs[nzcv]&#39;s offset matches ctiMasmProbeTrampoline&quot;);
188 static_assert(PROBE_OFFSETOF(cpu.sprs[ARM64Registers::fpsr]) == PROBE_CPU_FPSR_OFFSET, &quot;Probe::State::cpu.sprs[fpsr]&#39;s offset matches ctiMasmProbeTrampoline&quot;);
189 
190 static_assert(!(PROBE_CPU_Q0_OFFSET &amp; 0x7), &quot;Probe::State::cpu.fprs[q0]&#39;s offset should be 8 byte aligned&quot;);
191 
192 static_assert(PROBE_OFFSETOF(cpu.fprs[ARM64Registers::q0]) == PROBE_CPU_Q0_OFFSET, &quot;Probe::State::cpu.fprs[q0]&#39;s offset matches ctiMasmProbeTrampoline&quot;);
193 static_assert(PROBE_OFFSETOF(cpu.fprs[ARM64Registers::q1]) == PROBE_CPU_Q1_OFFSET, &quot;Probe::State::cpu.fprs[q1]&#39;s offset matches ctiMasmProbeTrampoline&quot;);
194 static_assert(PROBE_OFFSETOF(cpu.fprs[ARM64Registers::q2]) == PROBE_CPU_Q2_OFFSET, &quot;Probe::State::cpu.fprs[q2]&#39;s offset matches ctiMasmProbeTrampoline&quot;);
195 static_assert(PROBE_OFFSETOF(cpu.fprs[ARM64Registers::q3]) == PROBE_CPU_Q3_OFFSET, &quot;Probe::State::cpu.fprs[q3]&#39;s offset matches ctiMasmProbeTrampoline&quot;);
196 static_assert(PROBE_OFFSETOF(cpu.fprs[ARM64Registers::q4]) == PROBE_CPU_Q4_OFFSET, &quot;Probe::State::cpu.fprs[q4]&#39;s offset matches ctiMasmProbeTrampoline&quot;);
197 static_assert(PROBE_OFFSETOF(cpu.fprs[ARM64Registers::q5]) == PROBE_CPU_Q5_OFFSET, &quot;Probe::State::cpu.fprs[q5]&#39;s offset matches ctiMasmProbeTrampoline&quot;);
198 static_assert(PROBE_OFFSETOF(cpu.fprs[ARM64Registers::q6]) == PROBE_CPU_Q6_OFFSET, &quot;Probe::State::cpu.fprs[q6]&#39;s offset matches ctiMasmProbeTrampoline&quot;);
199 static_assert(PROBE_OFFSETOF(cpu.fprs[ARM64Registers::q7]) == PROBE_CPU_Q7_OFFSET, &quot;Probe::State::cpu.fprs[q7]&#39;s offset matches ctiMasmProbeTrampoline&quot;);
200 static_assert(PROBE_OFFSETOF(cpu.fprs[ARM64Registers::q8]) == PROBE_CPU_Q8_OFFSET, &quot;Probe::State::cpu.fprs[q8]&#39;s offset matches ctiMasmProbeTrampoline&quot;);
201 static_assert(PROBE_OFFSETOF(cpu.fprs[ARM64Registers::q9]) == PROBE_CPU_Q9_OFFSET, &quot;Probe::State::cpu.fprs[q9]&#39;s offset matches ctiMasmProbeTrampoline&quot;);
202 static_assert(PROBE_OFFSETOF(cpu.fprs[ARM64Registers::q10]) == PROBE_CPU_Q10_OFFSET, &quot;Probe::State::cpu.fprs[q10]&#39;s offset matches ctiMasmProbeTrampoline&quot;);
203 static_assert(PROBE_OFFSETOF(cpu.fprs[ARM64Registers::q11]) == PROBE_CPU_Q11_OFFSET, &quot;Probe::State::cpu.fprs[q11]&#39;s offset matches ctiMasmProbeTrampoline&quot;);
204 static_assert(PROBE_OFFSETOF(cpu.fprs[ARM64Registers::q12]) == PROBE_CPU_Q12_OFFSET, &quot;Probe::State::cpu.fprs[q12]&#39;s offset matches ctiMasmProbeTrampoline&quot;);
205 static_assert(PROBE_OFFSETOF(cpu.fprs[ARM64Registers::q13]) == PROBE_CPU_Q13_OFFSET, &quot;Probe::State::cpu.fprs[q13]&#39;s offset matches ctiMasmProbeTrampoline&quot;);
206 static_assert(PROBE_OFFSETOF(cpu.fprs[ARM64Registers::q14]) == PROBE_CPU_Q14_OFFSET, &quot;Probe::State::cpu.fprs[q14]&#39;s offset matches ctiMasmProbeTrampoline&quot;);
207 static_assert(PROBE_OFFSETOF(cpu.fprs[ARM64Registers::q15]) == PROBE_CPU_Q15_OFFSET, &quot;Probe::State::cpu.fprs[q15]&#39;s offset matches ctiMasmProbeTrampoline&quot;);
208 
209 static_assert(PROBE_OFFSETOF(cpu.fprs[ARM64Registers::q16]) == PROBE_CPU_Q16_OFFSET, &quot;Probe::State::cpu.fprs[q16]&#39;s offset matches ctiMasmProbeTrampoline&quot;);
210 static_assert(PROBE_OFFSETOF(cpu.fprs[ARM64Registers::q17]) == PROBE_CPU_Q17_OFFSET, &quot;Probe::State::cpu.fprs[q17]&#39;s offset matches ctiMasmProbeTrampoline&quot;);
211 static_assert(PROBE_OFFSETOF(cpu.fprs[ARM64Registers::q18]) == PROBE_CPU_Q18_OFFSET, &quot;Probe::State::cpu.fprs[q18]&#39;s offset matches ctiMasmProbeTrampoline&quot;);
212 static_assert(PROBE_OFFSETOF(cpu.fprs[ARM64Registers::q19]) == PROBE_CPU_Q19_OFFSET, &quot;Probe::State::cpu.fprs[q19]&#39;s offset matches ctiMasmProbeTrampoline&quot;);
213 static_assert(PROBE_OFFSETOF(cpu.fprs[ARM64Registers::q20]) == PROBE_CPU_Q20_OFFSET, &quot;Probe::State::cpu.fprs[q20]&#39;s offset matches ctiMasmProbeTrampoline&quot;);
214 static_assert(PROBE_OFFSETOF(cpu.fprs[ARM64Registers::q21]) == PROBE_CPU_Q21_OFFSET, &quot;Probe::State::cpu.fprs[q21]&#39;s offset matches ctiMasmProbeTrampoline&quot;);
215 static_assert(PROBE_OFFSETOF(cpu.fprs[ARM64Registers::q22]) == PROBE_CPU_Q22_OFFSET, &quot;Probe::State::cpu.fprs[q22]&#39;s offset matches ctiMasmProbeTrampoline&quot;);
216 static_assert(PROBE_OFFSETOF(cpu.fprs[ARM64Registers::q23]) == PROBE_CPU_Q23_OFFSET, &quot;Probe::State::cpu.fprs[q23]&#39;s offset matches ctiMasmProbeTrampoline&quot;);
217 static_assert(PROBE_OFFSETOF(cpu.fprs[ARM64Registers::q24]) == PROBE_CPU_Q24_OFFSET, &quot;Probe::State::cpu.fprs[q24]&#39;s offset matches ctiMasmProbeTrampoline&quot;);
218 static_assert(PROBE_OFFSETOF(cpu.fprs[ARM64Registers::q25]) == PROBE_CPU_Q25_OFFSET, &quot;Probe::State::cpu.fprs[q25]&#39;s offset matches ctiMasmProbeTrampoline&quot;);
219 static_assert(PROBE_OFFSETOF(cpu.fprs[ARM64Registers::q26]) == PROBE_CPU_Q26_OFFSET, &quot;Probe::State::cpu.fprs[q26]&#39;s offset matches ctiMasmProbeTrampoline&quot;);
220 static_assert(PROBE_OFFSETOF(cpu.fprs[ARM64Registers::q27]) == PROBE_CPU_Q27_OFFSET, &quot;Probe::State::cpu.fprs[q27]&#39;s offset matches ctiMasmProbeTrampoline&quot;);
221 static_assert(PROBE_OFFSETOF(cpu.fprs[ARM64Registers::q28]) == PROBE_CPU_Q28_OFFSET, &quot;Probe::State::cpu.fprs[q28]&#39;s offset matches ctiMasmProbeTrampoline&quot;);
222 static_assert(PROBE_OFFSETOF(cpu.fprs[ARM64Registers::q29]) == PROBE_CPU_Q29_OFFSET, &quot;Probe::State::cpu.fprs[q29]&#39;s offset matches ctiMasmProbeTrampoline&quot;);
223 static_assert(PROBE_OFFSETOF(cpu.fprs[ARM64Registers::q30]) == PROBE_CPU_Q30_OFFSET, &quot;Probe::State::cpu.fprs[q30]&#39;s offset matches ctiMasmProbeTrampoline&quot;);
224 static_assert(PROBE_OFFSETOF(cpu.fprs[ARM64Registers::q31]) == PROBE_CPU_Q31_OFFSET, &quot;Probe::State::cpu.fprs[q31]&#39;s offset matches ctiMasmProbeTrampoline&quot;);
225 
226 static_assert(sizeof(Probe::State) == PROBE_SIZE, &quot;Probe::State&#39;s size matches ctiMasmProbeTrampoline&quot;);
227 
228 // Conditions for using ldp and stp.
229 static_assert(PROBE_CPU_PC_OFFSET == PROBE_CPU_SP_OFFSET + GPREG_SIZE, &quot;PROBE_CPU_SP_OFFSET and PROBE_CPU_PC_OFFSET must be adjacent&quot;);
230 static_assert(!(PROBE_SIZE_PLUS_EXTRAS &amp; 0xf), &quot;PROBE_SIZE_PLUS_EXTRAS should be 16 byte aligned&quot;); // the Probe::State copying code relies on this.
231 
232 #undef PROBE_OFFSETOF
233 
234 #define FPR_OFFSET(fpr) (PROBE_CPU_##fpr##_OFFSET - PROBE_CPU_Q0_OFFSET)
235 
236 struct IncomingProbeRecord {
237     UCPURegister x24;
238     UCPURegister x25;
239     UCPURegister x26;
240     UCPURegister x27;
241     UCPURegister x28;
242     UCPURegister x30; // lr
243 };
244 
245 #define IN_X24_OFFSET (0 * GPREG_SIZE)
246 #define IN_X25_OFFSET (1 * GPREG_SIZE)
247 #define IN_X26_OFFSET (2 * GPREG_SIZE)
248 #define IN_X27_OFFSET (3 * GPREG_SIZE)
249 #define IN_X28_OFFSET (4 * GPREG_SIZE)
250 #define IN_X30_OFFSET (5 * GPREG_SIZE)
251 #define IN_SIZE       (6 * GPREG_SIZE)
252 
253 static_assert(IN_X24_OFFSET == offsetof(IncomingProbeRecord, x24), &quot;IN_X24_OFFSET is incorrect&quot;);
254 static_assert(IN_X25_OFFSET == offsetof(IncomingProbeRecord, x25), &quot;IN_X25_OFFSET is incorrect&quot;);
255 static_assert(IN_X26_OFFSET == offsetof(IncomingProbeRecord, x26), &quot;IN_X26_OFFSET is incorrect&quot;);
256 static_assert(IN_X27_OFFSET == offsetof(IncomingProbeRecord, x27), &quot;IN_X27_OFFSET is incorrect&quot;);
257 static_assert(IN_X28_OFFSET == offsetof(IncomingProbeRecord, x28), &quot;IN_X22_OFFSET is incorrect&quot;);
258 static_assert(IN_X30_OFFSET == offsetof(IncomingProbeRecord, x30), &quot;IN_X23_OFFSET is incorrect&quot;);
259 static_assert(IN_SIZE == sizeof(IncomingProbeRecord), &quot;IN_SIZE is incorrect&quot;);
260 static_assert(!(sizeof(IncomingProbeRecord) &amp; 0xf), &quot;IncomingProbeStack must be 16-byte aligned&quot;);
261 
262 struct OutgoingProbeRecord {
263     UCPURegister nzcv;
264     UCPURegister fpsr;
265     UCPURegister x27;
266     UCPURegister x28;
267     UCPURegister fp;
268     UCPURegister lr;
269 };
270 
271 #define OUT_NZCV_OFFSET (0 * GPREG_SIZE)
272 #define OUT_FPSR_OFFSET (1 * GPREG_SIZE)
273 #define OUT_X27_OFFSET  (2 * GPREG_SIZE)
274 #define OUT_X28_OFFSET  (3 * GPREG_SIZE)
275 #define OUT_FP_OFFSET   (4 * GPREG_SIZE)
276 #define OUT_LR_OFFSET   (5 * GPREG_SIZE)
277 #define OUT_SIZE        (6 * GPREG_SIZE)
278 
279 static_assert(OUT_NZCV_OFFSET == offsetof(OutgoingProbeRecord, nzcv), &quot;OUT_NZCV_OFFSET is incorrect&quot;);
280 static_assert(OUT_FPSR_OFFSET == offsetof(OutgoingProbeRecord, fpsr), &quot;OUT_FPSR_OFFSET is incorrect&quot;);
281 static_assert(OUT_X27_OFFSET == offsetof(OutgoingProbeRecord, x27), &quot;OUT_X27_OFFSET is incorrect&quot;);
282 static_assert(OUT_X28_OFFSET == offsetof(OutgoingProbeRecord, x28), &quot;OUT_X28_OFFSET is incorrect&quot;);
283 static_assert(OUT_FP_OFFSET == offsetof(OutgoingProbeRecord, fp), &quot;OUT_FP_OFFSET is incorrect&quot;);
284 static_assert(OUT_LR_OFFSET == offsetof(OutgoingProbeRecord, lr), &quot;OUT_LR_OFFSET is incorrect&quot;);
285 static_assert(OUT_SIZE == sizeof(OutgoingProbeRecord), &quot;OUT_SIZE is incorrect&quot;);
286 static_assert(!(sizeof(OutgoingProbeRecord) &amp; 0xf), &quot;OutgoingProbeStack must be 16-byte aligned&quot;);
287 
288 struct LRRestorationRecord {
289     UCPURegister lr;
290     UCPURegister unusedDummyToEnsureSizeIs16ByteAligned;
291 };
292 
293 #define LR_RESTORATION_LR_OFFSET (0 * GPREG_SIZE)
294 #define LR_RESTORATION_SIZE      (2 * GPREG_SIZE)
295 
296 static_assert(LR_RESTORATION_LR_OFFSET == offsetof(LRRestorationRecord, lr), &quot;LR_RESTORATION_LR_OFFSET is incorrect&quot;);
297 static_assert(LR_RESTORATION_SIZE == sizeof(LRRestorationRecord), &quot;LR_RESTORATION_SIZE is incorrect&quot;);
298 static_assert(!(sizeof(LRRestorationRecord) &amp; 0xf), &quot;LRRestorationRecord must be 16-byte aligned&quot;);
299 
300 // We use x29 and x30 instead of fp and lr because GCC&#39;s inline assembler does not recognize fp and lr.
301 // See https://bugs.webkit.org/show_bug.cgi?id=175512 for details.
302 asm (
303     &quot;.text&quot; &quot;\n&quot;
304     &quot;.balign 16&quot; &quot;\n&quot;
305     &quot;.globl &quot; SYMBOL_STRING(ctiMasmProbeTrampoline) &quot;\n&quot;
306     HIDE_SYMBOL(ctiMasmProbeTrampoline) &quot;\n&quot;
307     SYMBOL_STRING(ctiMasmProbeTrampoline) &quot;:&quot; &quot;\n&quot;
308 
309     // MacroAssemblerARM64::probe() has already generated code to store some values in an
310     // IncomingProbeRecord. sp points to the IncomingProbeRecord.
311     //
312     // Incoming register values:
313     //     x24: probe function
314     //     x25: probe arg
315     //     x26: scratch, was ctiMasmProbeTrampoline
316     //     x27: scratch
317     //     x28: Probe::executeProbe
318     //     x30: return address
319 
320     &quot;mov       x26, sp&quot; &quot;\n&quot;
321     &quot;mov       x27, sp&quot; &quot;\n&quot;
322 
323     &quot;sub       x27, x27, #&quot; STRINGIZE_VALUE_OF(PROBE_SIZE_PLUS_EXTRAS + OUT_SIZE) &quot;\n&quot;
324     &quot;bic       x27, x27, #0xf&quot; &quot;\n&quot; // The ARM EABI specifies that the stack needs to be 16 byte aligned.
325     &quot;mov       sp, x27&quot; &quot;\n&quot; // Set the sp to protect the Probe::State from interrupts before we initialize it.
326 
327     &quot;stp       x24, x25, [sp, #&quot; STRINGIZE_VALUE_OF(PROBE_PROBE_FUNCTION_OFFSET) &quot;]&quot; &quot;\n&quot; // Store the probe handler function and arg (preloaded into x24 and x25
328 
329     &quot;stp       x0, x1, [sp, #&quot; STRINGIZE_VALUE_OF(PROBE_CPU_X0_OFFSET) &quot;]&quot; &quot;\n&quot;
330     &quot;mrs       x0, nzcv&quot; &quot;\n&quot; // Preload nzcv.
331     &quot;stp       x2, x3, [sp, #&quot; STRINGIZE_VALUE_OF(PROBE_CPU_X2_OFFSET) &quot;]&quot; &quot;\n&quot;
332     &quot;stp       x4, x5, [sp, #&quot; STRINGIZE_VALUE_OF(PROBE_CPU_X4_OFFSET) &quot;]&quot; &quot;\n&quot;
333     &quot;mrs       x1, fpsr&quot; &quot;\n&quot; // Preload fpsr.
334     &quot;stp       x6, x7, [sp, #&quot; STRINGIZE_VALUE_OF(PROBE_CPU_X6_OFFSET) &quot;]&quot; &quot;\n&quot;
335     &quot;stp       x8, x9, [sp, #&quot; STRINGIZE_VALUE_OF(PROBE_CPU_X8_OFFSET) &quot;]&quot; &quot;\n&quot;
336 
337     &quot;ldp       x2, x3, [x26, #&quot; STRINGIZE_VALUE_OF(IN_X24_OFFSET) &quot;]&quot; &quot;\n&quot; // Preload saved x24 and x25.
338     &quot;ldp       x4, x5, [x26, #&quot; STRINGIZE_VALUE_OF(IN_X26_OFFSET) &quot;]&quot; &quot;\n&quot; // Preload saved x26 and x27.
339     &quot;ldp       x6, x7, [x26, #&quot; STRINGIZE_VALUE_OF(IN_X28_OFFSET) &quot;]&quot; &quot;\n&quot; // Preload saved x28 and lr.
340     &quot;add       x26, x26, #&quot; STRINGIZE_VALUE_OF(IN_SIZE) &quot;\n&quot; // Compute the sp before the probe.
341 
342     &quot;stp       x10, x11, [sp, #&quot; STRINGIZE_VALUE_OF(PROBE_CPU_X10_OFFSET) &quot;]&quot; &quot;\n&quot;
343     &quot;stp       x12, x13, [sp, #&quot; STRINGIZE_VALUE_OF(PROBE_CPU_X12_OFFSET) &quot;]&quot; &quot;\n&quot;
344     &quot;stp       x14, x15, [sp, #&quot; STRINGIZE_VALUE_OF(PROBE_CPU_X14_OFFSET) &quot;]&quot; &quot;\n&quot;
345     &quot;stp       x16, x17, [sp, #&quot; STRINGIZE_VALUE_OF(PROBE_CPU_X16_OFFSET) &quot;]&quot; &quot;\n&quot;
346     &quot;stp       x18, x19, [sp, #&quot; STRINGIZE_VALUE_OF(PROBE_CPU_X18_OFFSET) &quot;]&quot; &quot;\n&quot;
347     &quot;stp       x20, x21, [sp, #&quot; STRINGIZE_VALUE_OF(PROBE_CPU_X20_OFFSET) &quot;]&quot; &quot;\n&quot;
348     &quot;stp       x22, x23, [sp, #&quot; STRINGIZE_VALUE_OF(PROBE_CPU_X22_OFFSET) &quot;]&quot; &quot;\n&quot;
349     &quot;stp       x2, x3, [sp, #&quot; STRINGIZE_VALUE_OF(PROBE_CPU_X24_OFFSET) &quot;]&quot; &quot;\n&quot; // Store saved r24 and r25 (preloaded into x2 and x3 above).
350     &quot;stp       x4, x5, [sp, #&quot; STRINGIZE_VALUE_OF(PROBE_CPU_X26_OFFSET) &quot;]&quot; &quot;\n&quot; // Store saved r26 and r27 (preloaded into x4 and x5 above).
351     &quot;stp       x6, x29, [sp, #&quot; STRINGIZE_VALUE_OF(PROBE_CPU_X28_OFFSET) &quot;]&quot; &quot;\n&quot;
352     &quot;stp       x7, x26, [sp, #&quot; STRINGIZE_VALUE_OF(PROBE_CPU_LR_OFFSET) &quot;]&quot; &quot;\n&quot; // Save values lr and sp (original sp value computed into x26 above).
353 
354     &quot;str       x30, [sp, #&quot; STRINGIZE_VALUE_OF(SAVED_PROBE_RETURN_PC_OFFSET) &quot;]&quot; &quot;\n&quot; // Save a duplicate copy of return pc (in lr).
355 
356     &quot;add       x30, x30, #&quot; STRINGIZE_VALUE_OF(2 * GPREG_SIZE) &quot;\n&quot; // The PC after the probe is at 2 instructions past the return point.
357     &quot;str       x30, [sp, #&quot; STRINGIZE_VALUE_OF(PROBE_CPU_PC_OFFSET) &quot;]&quot; &quot;\n&quot;
358 
359     &quot;stp       x0, x1, [sp, #&quot; STRINGIZE_VALUE_OF(PROBE_CPU_NZCV_OFFSET) &quot;]&quot; &quot;\n&quot; // Store nzcv and fpsr (preloaded into x0 and x1 above).
360 
361     &quot;add       x9, sp, #&quot; STRINGIZE_VALUE_OF(PROBE_CPU_Q0_OFFSET) &quot;\n&quot;
362     &quot;stp       d0, d1, [x9, #&quot; STRINGIZE_VALUE_OF(FPR_OFFSET(Q0)) &quot;]&quot; &quot;\n&quot;
363     &quot;stp       d2, d3, [x9, #&quot; STRINGIZE_VALUE_OF(FPR_OFFSET(Q2)) &quot;]&quot; &quot;\n&quot;
364     &quot;stp       d4, d5, [x9, #&quot; STRINGIZE_VALUE_OF(FPR_OFFSET(Q4)) &quot;]&quot; &quot;\n&quot;
365     &quot;stp       d6, d7, [x9, #&quot; STRINGIZE_VALUE_OF(FPR_OFFSET(Q6)) &quot;]&quot; &quot;\n&quot;
366     &quot;stp       d8, d9, [x9, #&quot; STRINGIZE_VALUE_OF(FPR_OFFSET(Q8)) &quot;]&quot; &quot;\n&quot;
367     &quot;stp       d10, d11, [x9, #&quot; STRINGIZE_VALUE_OF(FPR_OFFSET(Q10)) &quot;]&quot; &quot;\n&quot;
368     &quot;stp       d12, d13, [x9, #&quot; STRINGIZE_VALUE_OF(FPR_OFFSET(Q12)) &quot;]&quot; &quot;\n&quot;
369     &quot;stp       d14, d15, [x9, #&quot; STRINGIZE_VALUE_OF(FPR_OFFSET(Q14)) &quot;]&quot; &quot;\n&quot;
370     &quot;stp       d16, d17, [x9, #&quot; STRINGIZE_VALUE_OF(FPR_OFFSET(Q16)) &quot;]&quot; &quot;\n&quot;
371     &quot;stp       d18, d19, [x9, #&quot; STRINGIZE_VALUE_OF(FPR_OFFSET(Q18)) &quot;]&quot; &quot;\n&quot;
372     &quot;stp       d20, d21, [x9, #&quot; STRINGIZE_VALUE_OF(FPR_OFFSET(Q20)) &quot;]&quot; &quot;\n&quot;
373     &quot;stp       d22, d23, [x9, #&quot; STRINGIZE_VALUE_OF(FPR_OFFSET(Q22)) &quot;]&quot; &quot;\n&quot;
374     &quot;stp       d24, d25, [x9, #&quot; STRINGIZE_VALUE_OF(FPR_OFFSET(Q24)) &quot;]&quot; &quot;\n&quot;
375     &quot;stp       d26, d27, [x9, #&quot; STRINGIZE_VALUE_OF(FPR_OFFSET(Q26)) &quot;]&quot; &quot;\n&quot;
376     &quot;stp       d28, d29, [x9, #&quot; STRINGIZE_VALUE_OF(FPR_OFFSET(Q28)) &quot;]&quot; &quot;\n&quot;
377     &quot;stp       d30, d31, [x9, #&quot; STRINGIZE_VALUE_OF(FPR_OFFSET(Q30)) &quot;]&quot; &quot;\n&quot;
378 
379     &quot;mov       x27, sp&quot; &quot;\n&quot; // Save the Probe::State* in a callee saved register.
380 
381     // Note: we haven&#39;t changed the value of fp. Hence, it is still pointing to the frame of
382     // the caller of the probe (which is what we want in order to play nice with debuggers e.g. lldb).
383     &quot;mov       x0, sp&quot; &quot;\n&quot; // Set the Probe::State* arg.
384 #if CPU(ARM64E)
385     &quot;blraaz    x28&quot; &quot;\n&quot; // Call the probe handler.
386 #else
387     &quot;blr       x28&quot; &quot;\n&quot; // Call the probe handler.
388 #endif
389 
390     // Make sure the Probe::State is entirely below the result stack pointer so
391     // that register values are still preserved when we call the initializeStack
392     // function.
393     &quot;ldr       x1, [x27, #&quot; STRINGIZE_VALUE_OF(PROBE_CPU_SP_OFFSET) &quot;]&quot; &quot;\n&quot; // Result sp.
394     &quot;add       x2, x27, #&quot; STRINGIZE_VALUE_OF(PROBE_SIZE_PLUS_EXTRAS + OUT_SIZE) &quot;\n&quot; // End of Probe::State + buffer.
395     &quot;cmp       x1, x2&quot; &quot;\n&quot;
396     &quot;bge     &quot; LOCAL_LABEL_STRING(ctiMasmProbeTrampolineProbeStateIsSafe) &quot;\n&quot;
397 
398     // Allocate a safe place on the stack below the result stack pointer to stash the Probe::State.
399     &quot;sub       x1, x1, #&quot; STRINGIZE_VALUE_OF(PROBE_SIZE_PLUS_EXTRAS + OUT_SIZE) &quot;\n&quot;
400     &quot;bic       x1, x1, #0xf&quot; &quot;\n&quot; // The ARM EABI specifies that the stack needs to be 16 byte aligned.
401     &quot;mov       sp, x1&quot; &quot;\n&quot; // Set the new sp to protect that memory from interrupts before we copy the Probe::State.
402 
403     // Copy the Probe::State to the safe place.
404     // Note: we have to copy from low address to higher address because we&#39;re moving the
405     // Probe::State to a lower address.
406     &quot;mov       x5, x27&quot; &quot;\n&quot;
407     &quot;mov       x6, x1&quot; &quot;\n&quot;
408     &quot;add       x7, x27, #&quot; STRINGIZE_VALUE_OF(PROBE_SIZE_PLUS_EXTRAS) &quot;\n&quot;
409 
410     LOCAL_LABEL_STRING(ctiMasmProbeTrampolineCopyLoop) &quot;:&quot; &quot;\n&quot;
411     &quot;ldp       x3, x4, [x5], #16&quot; &quot;\n&quot;
412     &quot;stp       x3, x4, [x6], #16&quot; &quot;\n&quot;
413     &quot;cmp       x5, x7&quot; &quot;\n&quot;
414     &quot;blt     &quot; LOCAL_LABEL_STRING(ctiMasmProbeTrampolineCopyLoop) &quot;\n&quot;
415 
416     &quot;mov       x27, x1&quot; &quot;\n&quot;
417 
418     // Call initializeStackFunction if present.
419     LOCAL_LABEL_STRING(ctiMasmProbeTrampolineProbeStateIsSafe) &quot;:&quot; &quot;\n&quot;
420     &quot;ldr       x2, [x27, #&quot; STRINGIZE_VALUE_OF(PROBE_INIT_STACK_FUNCTION_OFFSET) &quot;]&quot; &quot;\n&quot;
421     &quot;cbz       x2, &quot; LOCAL_LABEL_STRING(ctiMasmProbeTrampolineRestoreRegisters) &quot;\n&quot;
422 
423     &quot;mov       x0, x27&quot; &quot;\n&quot; // Set the Probe::State* arg.
424 #if CPU(ARM64E)
425     &quot;blraaz    x2&quot; &quot;\n&quot; // Call the initializeStackFunction (loaded into x2 above).
426 #else
427     &quot;blr       x2&quot; &quot;\n&quot; // Call the initializeStackFunction (loaded into x2 above).
428 #endif
429 
430     LOCAL_LABEL_STRING(ctiMasmProbeTrampolineRestoreRegisters) &quot;:&quot; &quot;\n&quot;
431 
432     &quot;mov       sp, x27&quot; &quot;\n&quot;
433 
434     // To enable probes to modify register state, we copy all registers
435     // out of the Probe::State before returning. That is except for x18.
436     // x18 is &quot;reserved for the platform. Conforming software should not make use of it.&quot;
437     // Hence, the JITs would not be using it, and the probe should also not be modifying it.
438     // See https://developer.apple.com/library/ios/documentation/Xcode/Conceptual/iPhoneOSABIReference/Articles/ARM64FunctionCallingConventions.html.
439 
440     &quot;add       x9, sp, #&quot; STRINGIZE_VALUE_OF(PROBE_CPU_Q0_OFFSET) &quot;\n&quot;
441     &quot;ldp       d0, d1, [x9, #&quot; STRINGIZE_VALUE_OF(FPR_OFFSET(Q0)) &quot;]&quot; &quot;\n&quot;
442     &quot;ldp       d2, d3, [x9, #&quot; STRINGIZE_VALUE_OF(FPR_OFFSET(Q2)) &quot;]&quot; &quot;\n&quot;
443     &quot;ldp       d4, d5, [x9, #&quot; STRINGIZE_VALUE_OF(FPR_OFFSET(Q4)) &quot;]&quot; &quot;\n&quot;
444     &quot;ldp       d6, d7, [x9, #&quot; STRINGIZE_VALUE_OF(FPR_OFFSET(Q6)) &quot;]&quot; &quot;\n&quot;
445     &quot;ldp       d8, d9, [x9, #&quot; STRINGIZE_VALUE_OF(FPR_OFFSET(Q8)) &quot;]&quot; &quot;\n&quot;
446     &quot;ldp       d10, d11, [x9, #&quot; STRINGIZE_VALUE_OF(FPR_OFFSET(Q10)) &quot;]&quot; &quot;\n&quot;
447     &quot;ldp       d12, d13, [x9, #&quot; STRINGIZE_VALUE_OF(FPR_OFFSET(Q12)) &quot;]&quot; &quot;\n&quot;
448     &quot;ldp       d14, d15, [x9, #&quot; STRINGIZE_VALUE_OF(FPR_OFFSET(Q14)) &quot;]&quot; &quot;\n&quot;
449     &quot;ldp       d16, d17, [x9, #&quot; STRINGIZE_VALUE_OF(FPR_OFFSET(Q16)) &quot;]&quot; &quot;\n&quot;
450     &quot;ldp       d18, d19, [x9, #&quot; STRINGIZE_VALUE_OF(FPR_OFFSET(Q18)) &quot;]&quot; &quot;\n&quot;
451     &quot;ldp       d20, d21, [x9, #&quot; STRINGIZE_VALUE_OF(FPR_OFFSET(Q20)) &quot;]&quot; &quot;\n&quot;
452     &quot;ldp       d22, d23, [x9, #&quot; STRINGIZE_VALUE_OF(FPR_OFFSET(Q22)) &quot;]&quot; &quot;\n&quot;
453     &quot;ldp       d24, d25, [x9, #&quot; STRINGIZE_VALUE_OF(FPR_OFFSET(Q24)) &quot;]&quot; &quot;\n&quot;
454     &quot;ldp       d26, d27, [x9, #&quot; STRINGIZE_VALUE_OF(FPR_OFFSET(Q26)) &quot;]&quot; &quot;\n&quot;
455     &quot;ldp       d28, d29, [x9, #&quot; STRINGIZE_VALUE_OF(FPR_OFFSET(Q28)) &quot;]&quot; &quot;\n&quot;
456     &quot;ldp       d30, d31, [x9, #&quot; STRINGIZE_VALUE_OF(FPR_OFFSET(Q30)) &quot;]&quot; &quot;\n&quot;
457 
458     &quot;ldp       x0, x1, [sp, #&quot; STRINGIZE_VALUE_OF(PROBE_CPU_X0_OFFSET) &quot;]&quot; &quot;\n&quot;
459     &quot;ldp       x2, x3, [sp, #&quot; STRINGIZE_VALUE_OF(PROBE_CPU_X2_OFFSET) &quot;]&quot; &quot;\n&quot;
460     &quot;ldp       x4, x5, [sp, #&quot; STRINGIZE_VALUE_OF(PROBE_CPU_X4_OFFSET) &quot;]&quot; &quot;\n&quot;
461     &quot;ldp       x6, x7, [sp, #&quot; STRINGIZE_VALUE_OF(PROBE_CPU_X6_OFFSET) &quot;]&quot; &quot;\n&quot;
462     &quot;ldp       x8, x9, [sp, #&quot; STRINGIZE_VALUE_OF(PROBE_CPU_X8_OFFSET) &quot;]&quot; &quot;\n&quot;
463     &quot;ldp       x10, x11, [sp, #&quot; STRINGIZE_VALUE_OF(PROBE_CPU_X10_OFFSET) &quot;]&quot; &quot;\n&quot;
464     &quot;ldp       x12, x13, [sp, #&quot; STRINGIZE_VALUE_OF(PROBE_CPU_X12_OFFSET) &quot;]&quot; &quot;\n&quot;
465     &quot;ldp       x14, x15, [sp, #&quot; STRINGIZE_VALUE_OF(PROBE_CPU_X14_OFFSET) &quot;]&quot; &quot;\n&quot;
466     &quot;ldp       x16, x17, [sp, #&quot; STRINGIZE_VALUE_OF(PROBE_CPU_X16_OFFSET) &quot;]&quot; &quot;\n&quot;
467     // x18 should not be modified by the probe. See comment above for details.
468     &quot;ldp       x19, x20, [sp, #&quot; STRINGIZE_VALUE_OF(PROBE_CPU_X19_OFFSET) &quot;]&quot; &quot;\n&quot;
469     &quot;ldp       x21, x22, [sp, #&quot; STRINGIZE_VALUE_OF(PROBE_CPU_X21_OFFSET) &quot;]&quot; &quot;\n&quot;
470     &quot;ldp       x23, x24, [sp, #&quot; STRINGIZE_VALUE_OF(PROBE_CPU_X23_OFFSET) &quot;]&quot; &quot;\n&quot;
471     &quot;ldp       x25, x26, [sp, #&quot; STRINGIZE_VALUE_OF(PROBE_CPU_X25_OFFSET) &quot;]&quot; &quot;\n&quot;
472 
473     // Remaining registers to restore are: fpsr, nzcv, x27, x28, fp, lr, sp, and pc.
474 
475     // The only way to set the pc on ARM64 (from user space) is via an indirect branch
476     // or a ret, which means we&#39;ll need a free register to do so. For our purposes, lr
477     // happens to be available in applications of the probe where we may want to
478     // continue executing at a different location (i.e. change the pc) after the probe
479     // returns. So, the ARM64 probe implementation will allow the probe handler to
480     // either modify lr or pc, but not both in the same probe invocation. The probe
481     // mechanism ensures that we never try to modify both lr and pc with a RELEASE_ASSERT
482     // in Probe::executeProbe().
483 
484     // Determine if the probe handler changed the pc.
485     &quot;ldr       x30, [sp, #&quot; STRINGIZE_VALUE_OF(PROBE_CPU_SP_OFFSET) &quot;]&quot; &quot;\n&quot; // preload the target sp.
486     &quot;ldr       x27, [sp, #&quot; STRINGIZE_VALUE_OF(SAVED_PROBE_RETURN_PC_OFFSET) &quot;]&quot; &quot;\n&quot;
487     &quot;ldr       x28, [sp, #&quot; STRINGIZE_VALUE_OF(PROBE_CPU_PC_OFFSET) &quot;]&quot; &quot;\n&quot;
488     &quot;add       x27, x27, #&quot; STRINGIZE_VALUE_OF(2 * GPREG_SIZE) &quot;\n&quot;
489     &quot;cmp       x27, x28&quot; &quot;\n&quot;
490     &quot;bne     &quot; LOCAL_LABEL_STRING(ctiMasmProbeTrampolineEnd) &quot;\n&quot;
491 
492      // We didn&#39;t change the PC. So, let&#39;s prepare for setting a potentially new lr value.
493 
494      // 1. Make room for the LRRestorationRecord. The probe site will pop this off later.
495     &quot;sub       x30, x30, #&quot; STRINGIZE_VALUE_OF(LR_RESTORATION_SIZE) &quot;\n&quot;
496      // 2. Store the lp value to restore at the probe return site.
497     &quot;ldr       x27, [sp, #&quot; STRINGIZE_VALUE_OF(PROBE_CPU_LR_OFFSET) &quot;]&quot; &quot;\n&quot;
498     &quot;str       x27, [x30, #&quot; STRINGIZE_VALUE_OF(LR_RESTORATION_LR_OFFSET) &quot;]&quot; &quot;\n&quot;
499      // 3. Force the return ramp to return to the probe return site.
500     &quot;ldr       x27, [sp, #&quot; STRINGIZE_VALUE_OF(SAVED_PROBE_RETURN_PC_OFFSET) &quot;]&quot; &quot;\n&quot;
501     &quot;str       x27, [sp, #&quot; STRINGIZE_VALUE_OF(PROBE_CPU_PC_OFFSET) &quot;]&quot; &quot;\n&quot;
502 
503     LOCAL_LABEL_STRING(ctiMasmProbeTrampolineEnd) &quot;:&quot; &quot;\n&quot;
504 
505     // Fill in the OutgoingProbeRecord.
506     &quot;sub       x30, x30, #&quot; STRINGIZE_VALUE_OF(OUT_SIZE) &quot;\n&quot;
507 
508     &quot;ldp       x27, x28, [sp, #&quot; STRINGIZE_VALUE_OF(PROBE_CPU_NZCV_OFFSET) &quot;]&quot; &quot;\n&quot;
509     &quot;stp       x27, x28, [x30, #&quot; STRINGIZE_VALUE_OF(OUT_NZCV_OFFSET) &quot;]&quot; &quot;\n&quot;
510     &quot;ldp       x27, x28, [sp, #&quot; STRINGIZE_VALUE_OF(PROBE_CPU_X27_OFFSET) &quot;]&quot; &quot;\n&quot;
511     &quot;stp       x27, x28, [x30, #&quot; STRINGIZE_VALUE_OF(OUT_X27_OFFSET) &quot;]&quot; &quot;\n&quot;
512     &quot;ldr       x27, [sp, #&quot; STRINGIZE_VALUE_OF(PROBE_CPU_FP_OFFSET) &quot;]&quot; &quot;\n&quot;
513     &quot;ldr       x28, [sp, #&quot; STRINGIZE_VALUE_OF(PROBE_CPU_PC_OFFSET) &quot;]&quot; &quot;\n&quot; // Set up the outgoing record so that we&#39;ll jump to the new PC.
514     &quot;stp       x27, x28, [x30, #&quot; STRINGIZE_VALUE_OF(OUT_FP_OFFSET) &quot;]&quot; &quot;\n&quot;
515     &quot;mov       sp, x30&quot; &quot;\n&quot;
516 
517     // Restore the remaining registers and pop the OutgoingProbeRecord.
518     &quot;ldp       x27, x28, [sp], #&quot; STRINGIZE_VALUE_OF(2 * GPREG_SIZE) &quot;\n&quot;
519     &quot;msr       nzcv, x27&quot; &quot;\n&quot;
520     &quot;msr       fpsr, x28&quot; &quot;\n&quot;
521     &quot;ldp       x27, x28, [sp], #&quot; STRINGIZE_VALUE_OF(2 * GPREG_SIZE) &quot;\n&quot;
522     &quot;ldp       x29, x30, [sp], #&quot; STRINGIZE_VALUE_OF(2 * GPREG_SIZE) &quot;\n&quot;
523     &quot;ret&quot; &quot;\n&quot;
524 );
525 #endif // COMPILER(GCC_COMPATIBLE)
526 
527 void MacroAssembler::probe(Probe::Function function, void* arg)
528 {
529     sub64(TrustedImm32(sizeof(IncomingProbeRecord)), sp);
530 
531     storePair64(x24, x25, sp, TrustedImm32(offsetof(IncomingProbeRecord, x24)));
532     storePair64(x26, x27, sp, TrustedImm32(offsetof(IncomingProbeRecord, x26)));
533     storePair64(x28, x30, sp, TrustedImm32(offsetof(IncomingProbeRecord, x28))); // Note: x30 is lr.
534     move(TrustedImmPtr(reinterpret_cast&lt;void*&gt;(ctiMasmProbeTrampoline)), x26);
535     move(TrustedImmPtr(reinterpret_cast&lt;void*&gt;(Probe::executeProbe)), x28);
536     move(TrustedImmPtr(reinterpret_cast&lt;void*&gt;(function)), x24);
537     move(TrustedImmPtr(arg), x25);
538     call(x26, CFunctionPtrTag);
539 
540     // ctiMasmProbeTrampoline should have restored every register except for lr and the sp.
541     load64(Address(sp, offsetof(LRRestorationRecord, lr)), lr);
542     add64(TrustedImm32(sizeof(LRRestorationRecord)), sp);
543 }
544 
545 #endif // ENABLE(MASM_PROBE)
546 
547 void MacroAssemblerARM64::collectCPUFeatures()
548 {
549 #if OS(LINUX)
550     static std::once_flag onceKey;
551     std::call_once(onceKey, [] {
552         // A register for describing ARM64 CPU features are only accessible in kernel mode.
553         // Thus, some kernel support is necessary to collect CPU features. In Linux, the
554         // kernel passes CPU feature flags in AT_HWCAP auxiliary vector which is passed
555         // when the process starts. While this may pose a bit conservative information
556         // (for example, the Linux kernel may add a flag for a feature after the feature
557         // is shipped and implemented in some CPUs. In that case, even if the CPU has
558         // that feature, the kernel does not tell it to users.), it is a stable approach.
559         // https://www.kernel.org/doc/Documentation/arm64/elf_hwcaps.txt
560         uint64_t hwcaps = getauxval(AT_HWCAP);
561 
562 #if !defined(HWCAP_JSCVT)
563 #define HWCAP_JSCVT (1 &lt;&lt; 13)
564 #endif
565 
566         s_jscvtCheckState = (hwcaps &amp; HWCAP_JSCVT) ? CPUIDCheckState::Set : CPUIDCheckState::Clear;
567     });
568 #elif HAVE(FJCVTZS_INSTRUCTION)
569     s_jscvtCheckState = CPUIDCheckState::Set;
570 #else
571     s_jscvtCheckState = CPUIDCheckState::Clear;
572 #endif
573 }
574 
575 MacroAssemblerARM64::CPUIDCheckState MacroAssemblerARM64::s_jscvtCheckState = CPUIDCheckState::NotChecked;
576 
577 } // namespace JSC
578 
579 #endif // ENABLE(ASSEMBLER) &amp;&amp; CPU(ARM64)
580 
    </pre>
  </body>
</html>