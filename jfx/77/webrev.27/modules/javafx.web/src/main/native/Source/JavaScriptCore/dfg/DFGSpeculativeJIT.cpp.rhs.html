<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGSpeculativeJIT.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>    1 /*
    2  * Copyright (C) 2011-2019 Apple Inc. All rights reserved.
    3  *
    4  * Redistribution and use in source and binary forms, with or without
    5  * modification, are permitted provided that the following conditions
    6  * are met:
    7  * 1. Redistributions of source code must retain the above copyright
    8  *    notice, this list of conditions and the following disclaimer.
    9  * 2. Redistributions in binary form must reproduce the above copyright
   10  *    notice, this list of conditions and the following disclaimer in the
   11  *    documentation and/or other materials provided with the distribution.
   12  *
   13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
   14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
   15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
   16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
   17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
   18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
   19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
   20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
   21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
   22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
   23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
   24  */
   25 
   26 #include &quot;config.h&quot;
   27 #include &quot;DFGSpeculativeJIT.h&quot;
   28 
   29 #if ENABLE(DFG_JIT)
   30 
   31 #include &quot;BinarySwitch.h&quot;
   32 #include &quot;DFGAbstractInterpreterInlines.h&quot;
   33 #include &quot;DFGArrayifySlowPathGenerator.h&quot;
   34 #include &quot;DFGCallArrayAllocatorSlowPathGenerator.h&quot;
   35 #include &quot;DFGCallCreateDirectArgumentsSlowPathGenerator.h&quot;
   36 #include &quot;DFGCapabilities.h&quot;
   37 #include &quot;DFGMayExit.h&quot;
   38 #include &quot;DFGOSRExitFuzz.h&quot;
   39 #include &quot;DFGSaneStringGetByValSlowPathGenerator.h&quot;
   40 #include &quot;DFGSlowPathGenerator.h&quot;
   41 #include &quot;DFGSnippetParams.h&quot;
   42 #include &quot;DirectArguments.h&quot;
<a name="1" id="anc1"></a><span class="line-added">   43 #include &quot;DisallowMacroScratchRegisterUsage.h&quot;</span>
   44 #include &quot;JITAddGenerator.h&quot;
   45 #include &quot;JITBitAndGenerator.h&quot;
   46 #include &quot;JITBitOrGenerator.h&quot;
   47 #include &quot;JITBitXorGenerator.h&quot;
   48 #include &quot;JITDivGenerator.h&quot;
   49 #include &quot;JITLeftShiftGenerator.h&quot;
   50 #include &quot;JITMulGenerator.h&quot;
   51 #include &quot;JITRightShiftGenerator.h&quot;
   52 #include &quot;JITSubGenerator.h&quot;
   53 #include &quot;JSAsyncFunction.h&quot;
   54 #include &quot;JSAsyncGeneratorFunction.h&quot;
   55 #include &quot;JSCInlines.h&quot;
   56 #include &quot;JSFixedArray.h&quot;
   57 #include &quot;JSGeneratorFunction.h&quot;
   58 #include &quot;JSImmutableButterfly.h&quot;
   59 #include &quot;JSLexicalEnvironment.h&quot;
   60 #include &quot;JSPropertyNameEnumerator.h&quot;
   61 #include &quot;LinkBuffer.h&quot;
   62 #include &quot;RegExpObject.h&quot;
   63 #include &quot;ScopedArguments.h&quot;
   64 #include &quot;ScratchRegisterAllocator.h&quot;
   65 #include &quot;SuperSampler.h&quot;
   66 #include &quot;TypeProfilerLog.h&quot;
   67 #include &quot;WeakMapImpl.h&quot;
   68 #include &lt;wtf/BitVector.h&gt;
   69 #include &lt;wtf/Box.h&gt;
   70 #include &lt;wtf/MathExtras.h&gt;
   71 
   72 namespace JSC { namespace DFG {
   73 
   74 SpeculativeJIT::SpeculativeJIT(JITCompiler&amp; jit)
<a name="2" id="anc2"></a><span class="line-modified">   75     : m_jit(jit)</span>

   76     , m_graph(m_jit.graph())
   77     , m_currentNode(0)
   78     , m_lastGeneratedNode(LastNodeType)
   79     , m_indexInBlock(0)
   80     , m_generationInfo(m_jit.graph().frameRegisterCount())
<a name="3" id="anc3"></a><span class="line-added">   81     , m_compileOkay(true)</span>
   82     , m_state(m_jit.graph())
   83     , m_interpreter(m_jit.graph(), m_state)
   84     , m_stream(&amp;jit.jitCode()-&gt;variableEventStream)
   85     , m_minifiedGraph(&amp;jit.jitCode()-&gt;minifiedDFG)
   86 {
   87 }
   88 
   89 SpeculativeJIT::~SpeculativeJIT()
   90 {
   91 }
   92 
   93 void SpeculativeJIT::emitAllocateRawObject(GPRReg resultGPR, RegisteredStructure structure, GPRReg storageGPR, unsigned numElements, unsigned vectorLength)
   94 {
   95     ASSERT(!isCopyOnWrite(structure-&gt;indexingMode()));
   96     IndexingType indexingType = structure-&gt;indexingType();
   97     bool hasIndexingHeader = hasIndexedProperties(indexingType);
   98 
   99     unsigned inlineCapacity = structure-&gt;inlineCapacity();
  100     unsigned outOfLineCapacity = structure-&gt;outOfLineCapacity();
  101 
  102     GPRTemporary scratch(this);
  103     GPRTemporary scratch2(this);
  104     GPRReg scratchGPR = scratch.gpr();
  105     GPRReg scratch2GPR = scratch2.gpr();
  106 
  107     ASSERT(vectorLength &gt;= numElements);
  108     vectorLength = Butterfly::optimalContiguousVectorLength(structure.get(), vectorLength);
  109 
  110     JITCompiler::JumpList slowCases;
  111 
  112     size_t size = 0;
  113     if (hasIndexingHeader)
  114         size += vectorLength * sizeof(JSValue) + sizeof(IndexingHeader);
  115     size += outOfLineCapacity * sizeof(JSValue);
  116 
  117     m_jit.move(TrustedImmPtr(nullptr), storageGPR);
  118 
<a name="4" id="anc4"></a><span class="line-added">  119     VM&amp; vm = this-&gt;vm();</span>
  120     if (size) {
<a name="5" id="anc5"></a><span class="line-modified">  121         if (Allocator allocator = vm.jsValueGigacageAuxiliarySpace.allocatorForNonVirtual(size, AllocatorForMode::AllocatorIfExists)) {</span>
  122             m_jit.emitAllocate(storageGPR, JITAllocator::constant(allocator), scratchGPR, scratch2GPR, slowCases);
  123 
  124             m_jit.addPtr(
  125                 TrustedImm32(outOfLineCapacity * sizeof(JSValue) + sizeof(IndexingHeader)),
  126                 storageGPR);
  127 
  128             if (hasIndexingHeader)
  129                 m_jit.store32(TrustedImm32(vectorLength), MacroAssembler::Address(storageGPR, Butterfly::offsetOfVectorLength()));
  130         } else
  131             slowCases.append(m_jit.jump());
  132     }
  133 
  134     size_t allocationSize = JSFinalObject::allocationSize(inlineCapacity);
<a name="6" id="anc6"></a><span class="line-modified">  135     Allocator allocator = allocatorForNonVirtualConcurrently&lt;JSFinalObject&gt;(vm, allocationSize, AllocatorForMode::AllocatorIfExists);</span>
  136     if (allocator) {
  137         emitAllocateJSObject(resultGPR, JITAllocator::constant(allocator), scratchGPR, TrustedImmPtr(structure), storageGPR, scratch2GPR, slowCases);
  138         m_jit.emitInitializeInlineStorage(resultGPR, structure-&gt;inlineCapacity());
  139     } else
  140         slowCases.append(m_jit.jump());
  141 
  142     // I want a slow path that also loads out the storage pointer, and that&#39;s
  143     // what this custom CallArrayAllocatorSlowPathGenerator gives me. It&#39;s a lot
  144     // of work for a very small piece of functionality. :-/
<a name="7" id="anc7"></a><span class="line-modified">  145     addSlowPathGenerator(makeUnique&lt;CallArrayAllocatorSlowPathGenerator&gt;(</span>
  146         slowCases, this, operationNewRawObject, resultGPR, storageGPR,
  147         structure, vectorLength));
  148 
  149     if (numElements &lt; vectorLength) {
  150 #if USE(JSVALUE64)
  151         if (hasDouble(structure-&gt;indexingType()))
  152             m_jit.move(TrustedImm64(bitwise_cast&lt;int64_t&gt;(PNaN)), scratchGPR);
  153         else
  154             m_jit.move(TrustedImm64(JSValue::encode(JSValue())), scratchGPR);
  155         for (unsigned i = numElements; i &lt; vectorLength; ++i)
  156             m_jit.store64(scratchGPR, MacroAssembler::Address(storageGPR, sizeof(double) * i));
  157 #else
  158         EncodedValueDescriptor value;
  159         if (hasDouble(structure-&gt;indexingType()))
  160             value.asInt64 = JSValue::encode(JSValue(JSValue::EncodeAsDouble, PNaN));
  161         else
  162             value.asInt64 = JSValue::encode(JSValue());
  163         for (unsigned i = numElements; i &lt; vectorLength; ++i) {
  164             m_jit.store32(TrustedImm32(value.asBits.tag), MacroAssembler::Address(storageGPR, sizeof(double) * i + OBJECT_OFFSETOF(JSValue, u.asBits.tag)));
  165             m_jit.store32(TrustedImm32(value.asBits.payload), MacroAssembler::Address(storageGPR, sizeof(double) * i + OBJECT_OFFSETOF(JSValue, u.asBits.payload)));
  166         }
  167 #endif
  168     }
  169 
  170     if (hasIndexingHeader)
  171         m_jit.store32(TrustedImm32(numElements), MacroAssembler::Address(storageGPR, Butterfly::offsetOfPublicLength()));
  172 
  173     m_jit.emitInitializeOutOfLineStorage(storageGPR, structure-&gt;outOfLineCapacity());
  174 
<a name="8" id="anc8"></a><span class="line-modified">  175     m_jit.mutatorFence(vm);</span>
  176 }
  177 
  178 void SpeculativeJIT::emitGetLength(InlineCallFrame* inlineCallFrame, GPRReg lengthGPR, bool includeThis)
  179 {
  180     if (inlineCallFrame &amp;&amp; !inlineCallFrame-&gt;isVarargs())
  181         m_jit.move(TrustedImm32(inlineCallFrame-&gt;argumentCountIncludingThis - !includeThis), lengthGPR);
  182     else {
  183         VirtualRegister argumentCountRegister = m_jit.argumentCount(inlineCallFrame);
  184         m_jit.load32(JITCompiler::payloadFor(argumentCountRegister), lengthGPR);
  185         if (!includeThis)
  186             m_jit.sub32(TrustedImm32(1), lengthGPR);
  187     }
  188 }
  189 
  190 void SpeculativeJIT::emitGetLength(CodeOrigin origin, GPRReg lengthGPR, bool includeThis)
  191 {
<a name="9" id="anc9"></a><span class="line-modified">  192     emitGetLength(origin.inlineCallFrame(), lengthGPR, includeThis);</span>
  193 }
  194 
  195 void SpeculativeJIT::emitGetCallee(CodeOrigin origin, GPRReg calleeGPR)
  196 {
<a name="10" id="anc10"></a><span class="line-modified">  197     auto* inlineCallFrame = origin.inlineCallFrame();</span>
<span class="line-modified">  198     if (inlineCallFrame) {</span>
<span class="line-added">  199         if (inlineCallFrame-&gt;isClosureCall) {</span>
  200             m_jit.loadPtr(
<a name="11" id="anc11"></a><span class="line-modified">  201                 JITCompiler::addressFor(inlineCallFrame-&gt;calleeRecovery.virtualRegister()),</span>
  202                 calleeGPR);
  203         } else {
  204             m_jit.move(
<a name="12" id="anc12"></a><span class="line-modified">  205                 TrustedImmPtr::weakPointer(m_jit.graph(), inlineCallFrame-&gt;calleeRecovery.constant().asCell()),</span>
  206                 calleeGPR);
  207         }
  208     } else
  209         m_jit.loadPtr(JITCompiler::addressFor(CallFrameSlot::callee), calleeGPR);
  210 }
  211 
  212 void SpeculativeJIT::emitGetArgumentStart(CodeOrigin origin, GPRReg startGPR)
  213 {
  214     m_jit.addPtr(
  215         TrustedImm32(
  216             JITCompiler::argumentsStart(origin).offset() * static_cast&lt;int&gt;(sizeof(Register))),
  217         GPRInfo::callFrameRegister, startGPR);
  218 }
  219 
  220 MacroAssembler::Jump SpeculativeJIT::emitOSRExitFuzzCheck()
  221 {
  222     if (!Options::useOSRExitFuzz()
  223         || !canUseOSRExitFuzzing(m_jit.graph().baselineCodeBlockFor(m_origin.semantic))
  224         || !doOSRExitFuzzing())
  225         return MacroAssembler::Jump();
  226 
  227     MacroAssembler::Jump result;
  228 
  229     m_jit.pushToSave(GPRInfo::regT0);
  230     m_jit.load32(&amp;g_numberOfOSRExitFuzzChecks, GPRInfo::regT0);
  231     m_jit.add32(TrustedImm32(1), GPRInfo::regT0);
  232     m_jit.store32(GPRInfo::regT0, &amp;g_numberOfOSRExitFuzzChecks);
  233     unsigned atOrAfter = Options::fireOSRExitFuzzAtOrAfter();
  234     unsigned at = Options::fireOSRExitFuzzAt();
  235     if (at || atOrAfter) {
  236         unsigned threshold;
  237         MacroAssembler::RelationalCondition condition;
  238         if (atOrAfter) {
  239             threshold = atOrAfter;
  240             condition = MacroAssembler::Below;
  241         } else {
  242             threshold = at;
  243             condition = MacroAssembler::NotEqual;
  244         }
  245         MacroAssembler::Jump ok = m_jit.branch32(
  246             condition, GPRInfo::regT0, MacroAssembler::TrustedImm32(threshold));
  247         m_jit.popToRestore(GPRInfo::regT0);
  248         result = m_jit.jump();
  249         ok.link(&amp;m_jit);
  250     }
  251     m_jit.popToRestore(GPRInfo::regT0);
  252 
  253     return result;
  254 }
  255 
  256 void SpeculativeJIT::speculationCheck(ExitKind kind, JSValueSource jsValueSource, Node* node, MacroAssembler::Jump jumpToFail)
  257 {
  258     if (!m_compileOkay)
  259         return;
  260     JITCompiler::Jump fuzzJump = emitOSRExitFuzzCheck();
  261     if (fuzzJump.isSet()) {
  262         JITCompiler::JumpList jumpsToFail;
  263         jumpsToFail.append(fuzzJump);
  264         jumpsToFail.append(jumpToFail);
  265         m_jit.appendExitInfo(jumpsToFail);
  266     } else
  267         m_jit.appendExitInfo(jumpToFail);
  268     m_jit.jitCode()-&gt;appendOSRExit(OSRExit(kind, jsValueSource, m_jit.graph().methodOfGettingAValueProfileFor(m_currentNode, node), this, m_stream-&gt;size()));
  269 }
  270 
  271 void SpeculativeJIT::speculationCheck(ExitKind kind, JSValueSource jsValueSource, Node* node, const MacroAssembler::JumpList&amp; jumpsToFail)
  272 {
  273     if (!m_compileOkay)
  274         return;
  275     JITCompiler::Jump fuzzJump = emitOSRExitFuzzCheck();
  276     if (fuzzJump.isSet()) {
  277         JITCompiler::JumpList myJumpsToFail;
  278         myJumpsToFail.append(jumpsToFail);
  279         myJumpsToFail.append(fuzzJump);
  280         m_jit.appendExitInfo(myJumpsToFail);
  281     } else
  282         m_jit.appendExitInfo(jumpsToFail);
  283     m_jit.jitCode()-&gt;appendOSRExit(OSRExit(kind, jsValueSource, m_jit.graph().methodOfGettingAValueProfileFor(m_currentNode, node), this, m_stream-&gt;size()));
  284 }
  285 
  286 OSRExitJumpPlaceholder SpeculativeJIT::speculationCheck(ExitKind kind, JSValueSource jsValueSource, Node* node)
  287 {
  288     if (!m_compileOkay)
  289         return OSRExitJumpPlaceholder();
  290     unsigned index = m_jit.jitCode()-&gt;osrExit.size();
  291     m_jit.appendExitInfo();
  292     m_jit.jitCode()-&gt;appendOSRExit(OSRExit(kind, jsValueSource, m_jit.graph().methodOfGettingAValueProfileFor(m_currentNode, node), this, m_stream-&gt;size()));
  293     return OSRExitJumpPlaceholder(index);
  294 }
  295 
  296 OSRExitJumpPlaceholder SpeculativeJIT::speculationCheck(ExitKind kind, JSValueSource jsValueSource, Edge nodeUse)
  297 {
  298     return speculationCheck(kind, jsValueSource, nodeUse.node());
  299 }
  300 
  301 void SpeculativeJIT::speculationCheck(ExitKind kind, JSValueSource jsValueSource, Edge nodeUse, MacroAssembler::Jump jumpToFail)
  302 {
  303     speculationCheck(kind, jsValueSource, nodeUse.node(), jumpToFail);
  304 }
  305 
  306 void SpeculativeJIT::speculationCheck(ExitKind kind, JSValueSource jsValueSource, Edge nodeUse, const MacroAssembler::JumpList&amp; jumpsToFail)
  307 {
  308     speculationCheck(kind, jsValueSource, nodeUse.node(), jumpsToFail);
  309 }
  310 
  311 void SpeculativeJIT::speculationCheck(ExitKind kind, JSValueSource jsValueSource, Node* node, MacroAssembler::Jump jumpToFail, const SpeculationRecovery&amp; recovery)
  312 {
  313     if (!m_compileOkay)
  314         return;
  315     unsigned recoveryIndex = m_jit.jitCode()-&gt;appendSpeculationRecovery(recovery);
  316     m_jit.appendExitInfo(jumpToFail);
  317     m_jit.jitCode()-&gt;appendOSRExit(OSRExit(kind, jsValueSource, m_jit.graph().methodOfGettingAValueProfileFor(m_currentNode, node), this, m_stream-&gt;size(), recoveryIndex));
  318 }
  319 
  320 void SpeculativeJIT::speculationCheck(ExitKind kind, JSValueSource jsValueSource, Edge nodeUse, MacroAssembler::Jump jumpToFail, const SpeculationRecovery&amp; recovery)
  321 {
  322     speculationCheck(kind, jsValueSource, nodeUse.node(), jumpToFail, recovery);
  323 }
  324 
  325 void SpeculativeJIT::emitInvalidationPoint(Node* node)
  326 {
  327     if (!m_compileOkay)
  328         return;
  329     OSRExitCompilationInfo&amp; info = m_jit.appendExitInfo(JITCompiler::JumpList());
  330     m_jit.jitCode()-&gt;appendOSRExit(OSRExit(
  331         UncountableInvalidation, JSValueSource(), MethodOfGettingAValueProfile(),
  332         this, m_stream-&gt;size()));
  333     info.m_replacementSource = m_jit.watchpointLabel();
  334     ASSERT(info.m_replacementSource.isSet());
  335     noResult(node);
  336 }
  337 
  338 void SpeculativeJIT::unreachable(Node* node)
  339 {
  340     m_compileOkay = false;
  341     m_jit.abortWithReason(DFGUnreachableNode, node-&gt;op());
  342 }
  343 
  344 void SpeculativeJIT::terminateSpeculativeExecution(ExitKind kind, JSValueRegs jsValueRegs, Node* node)
  345 {
  346     if (!m_compileOkay)
  347         return;
  348     speculationCheck(kind, jsValueRegs, node, m_jit.jump());
  349     m_compileOkay = false;
  350     if (verboseCompilationEnabled())
  351         dataLog(&quot;Bailing compilation.\n&quot;);
  352 }
  353 
  354 void SpeculativeJIT::terminateSpeculativeExecution(ExitKind kind, JSValueRegs jsValueRegs, Edge nodeUse)
  355 {
  356     terminateSpeculativeExecution(kind, jsValueRegs, nodeUse.node());
  357 }
  358 
  359 void SpeculativeJIT::typeCheck(JSValueSource source, Edge edge, SpeculatedType typesPassedThrough, MacroAssembler::Jump jumpToFail, ExitKind exitKind)
  360 {
  361     ASSERT(needsTypeCheck(edge, typesPassedThrough));
  362     m_interpreter.filter(edge, typesPassedThrough);
  363     speculationCheck(exitKind, source, edge.node(), jumpToFail);
  364 }
  365 
  366 RegisterSet SpeculativeJIT::usedRegisters()
  367 {
  368     RegisterSet result;
  369 
  370     for (unsigned i = GPRInfo::numberOfRegisters; i--;) {
  371         GPRReg gpr = GPRInfo::toRegister(i);
  372         if (m_gprs.isInUse(gpr))
  373             result.set(gpr);
  374     }
  375     for (unsigned i = FPRInfo::numberOfRegisters; i--;) {
  376         FPRReg fpr = FPRInfo::toRegister(i);
  377         if (m_fprs.isInUse(fpr))
  378             result.set(fpr);
  379     }
  380 
  381     // FIXME: This is overly conservative. We could subtract out those callee-saves that we
  382     // actually saved.
  383     // https://bugs.webkit.org/show_bug.cgi?id=185686
  384     result.merge(RegisterSet::stubUnavailableRegisters());
  385 
  386     return result;
  387 }
  388 
  389 void SpeculativeJIT::addSlowPathGenerator(std::unique_ptr&lt;SlowPathGenerator&gt; slowPathGenerator)
  390 {
  391     m_slowPathGenerators.append(WTFMove(slowPathGenerator));
  392 }
  393 
  394 void SpeculativeJIT::addSlowPathGeneratorLambda(Function&lt;void()&gt;&amp;&amp; lambda)
  395 {
  396     m_slowPathLambdas.append(SlowPathLambda{ WTFMove(lambda), m_currentNode, static_cast&lt;unsigned&gt;(m_stream-&gt;size()) });
  397 }
  398 
  399 void SpeculativeJIT::runSlowPathGenerators(PCToCodeOriginMapBuilder&amp; pcToCodeOriginMapBuilder)
  400 {
  401     for (auto&amp; slowPathGenerator : m_slowPathGenerators) {
  402         pcToCodeOriginMapBuilder.appendItem(m_jit.labelIgnoringWatchpoints(), slowPathGenerator-&gt;origin().semantic);
  403         slowPathGenerator-&gt;generate(this);
  404     }
  405     for (auto&amp; slowPathLambda : m_slowPathLambdas) {
  406         Node* currentNode = slowPathLambda.currentNode;
  407         m_currentNode = currentNode;
  408         m_outOfLineStreamIndex = slowPathLambda.streamIndex;
  409         pcToCodeOriginMapBuilder.appendItem(m_jit.labelIgnoringWatchpoints(), currentNode-&gt;origin.semantic);
  410         slowPathLambda.generator();
  411         m_outOfLineStreamIndex = WTF::nullopt;
  412     }
  413 }
  414 
  415 void SpeculativeJIT::clearGenerationInfo()
  416 {
  417     for (unsigned i = 0; i &lt; m_generationInfo.size(); ++i)
  418         m_generationInfo[i] = GenerationInfo();
  419     m_gprs = RegisterBank&lt;GPRInfo&gt;();
  420     m_fprs = RegisterBank&lt;FPRInfo&gt;();
  421 }
  422 
  423 SilentRegisterSavePlan SpeculativeJIT::silentSavePlanForGPR(VirtualRegister spillMe, GPRReg source)
  424 {
  425     GenerationInfo&amp; info = generationInfoFromVirtualRegister(spillMe);
  426     Node* node = info.node();
  427     DataFormat registerFormat = info.registerFormat();
  428     ASSERT(registerFormat != DataFormatNone);
  429     ASSERT(registerFormat != DataFormatDouble);
  430 
  431     SilentSpillAction spillAction;
  432     SilentFillAction fillAction;
  433 
  434     if (!info.needsSpill())
  435         spillAction = DoNothingForSpill;
  436     else {
  437 #if USE(JSVALUE64)
  438         ASSERT(info.gpr() == source);
  439         if (registerFormat == DataFormatInt32)
  440             spillAction = Store32Payload;
  441         else if (registerFormat == DataFormatCell || registerFormat == DataFormatStorage)
  442             spillAction = StorePtr;
  443         else if (registerFormat == DataFormatInt52 || registerFormat == DataFormatStrictInt52)
  444             spillAction = Store64;
  445         else {
  446             ASSERT(registerFormat &amp; DataFormatJS);
  447             spillAction = Store64;
  448         }
  449 #elif USE(JSVALUE32_64)
  450         if (registerFormat &amp; DataFormatJS) {
  451             ASSERT(info.tagGPR() == source || info.payloadGPR() == source);
  452             spillAction = source == info.tagGPR() ? Store32Tag : Store32Payload;
  453         } else {
  454             ASSERT(info.gpr() == source);
  455             spillAction = Store32Payload;
  456         }
  457 #endif
  458     }
  459 
  460     if (registerFormat == DataFormatInt32) {
  461         ASSERT(info.gpr() == source);
  462         ASSERT(isJSInt32(info.registerFormat()));
  463         if (node-&gt;hasConstant()) {
  464             ASSERT(node-&gt;isInt32Constant());
  465             fillAction = SetInt32Constant;
  466         } else
  467             fillAction = Load32Payload;
  468     } else if (registerFormat == DataFormatBoolean) {
  469 #if USE(JSVALUE64)
  470         RELEASE_ASSERT_NOT_REACHED();
  471 #if COMPILER_QUIRK(CONSIDERS_UNREACHABLE_CODE)
  472         fillAction = DoNothingForFill;
  473 #endif
  474 #elif USE(JSVALUE32_64)
  475         ASSERT(info.gpr() == source);
  476         if (node-&gt;hasConstant()) {
  477             ASSERT(node-&gt;isBooleanConstant());
  478             fillAction = SetBooleanConstant;
  479         } else
  480             fillAction = Load32Payload;
  481 #endif
  482     } else if (registerFormat == DataFormatCell) {
  483         ASSERT(info.gpr() == source);
  484         if (node-&gt;hasConstant()) {
  485             DFG_ASSERT(m_jit.graph(), m_currentNode, node-&gt;isCellConstant());
  486             node-&gt;asCell(); // To get the assertion.
  487             fillAction = SetCellConstant;
  488         } else {
  489 #if USE(JSVALUE64)
  490             fillAction = LoadPtr;
  491 #else
  492             fillAction = Load32Payload;
  493 #endif
  494         }
  495     } else if (registerFormat == DataFormatStorage) {
  496         ASSERT(info.gpr() == source);
  497         fillAction = LoadPtr;
  498     } else if (registerFormat == DataFormatInt52) {
  499         if (node-&gt;hasConstant())
  500             fillAction = SetInt52Constant;
  501         else if (info.spillFormat() == DataFormatInt52)
  502             fillAction = Load64;
  503         else if (info.spillFormat() == DataFormatStrictInt52)
  504             fillAction = Load64ShiftInt52Left;
  505         else if (info.spillFormat() == DataFormatNone)
  506             fillAction = Load64;
  507         else {
  508             RELEASE_ASSERT_NOT_REACHED();
  509 #if COMPILER_QUIRK(CONSIDERS_UNREACHABLE_CODE)
  510             fillAction = Load64; // Make GCC happy.
  511 #endif
  512         }
  513     } else if (registerFormat == DataFormatStrictInt52) {
  514         if (node-&gt;hasConstant())
  515             fillAction = SetStrictInt52Constant;
  516         else if (info.spillFormat() == DataFormatInt52)
  517             fillAction = Load64ShiftInt52Right;
  518         else if (info.spillFormat() == DataFormatStrictInt52)
  519             fillAction = Load64;
  520         else if (info.spillFormat() == DataFormatNone)
  521             fillAction = Load64;
  522         else {
  523             RELEASE_ASSERT_NOT_REACHED();
  524 #if COMPILER_QUIRK(CONSIDERS_UNREACHABLE_CODE)
  525             fillAction = Load64; // Make GCC happy.
  526 #endif
  527         }
  528     } else {
  529         ASSERT(registerFormat &amp; DataFormatJS);
  530 #if USE(JSVALUE64)
  531         ASSERT(info.gpr() == source);
  532         if (node-&gt;hasConstant()) {
  533             if (node-&gt;isCellConstant())
  534                 fillAction = SetTrustedJSConstant;
  535             else
  536                 fillAction = SetJSConstant;
  537         } else if (info.spillFormat() == DataFormatInt32) {
  538             ASSERT(registerFormat == DataFormatJSInt32);
  539             fillAction = Load32PayloadBoxInt;
  540         } else
  541             fillAction = Load64;
  542 #else
  543         ASSERT(info.tagGPR() == source || info.payloadGPR() == source);
  544         if (node-&gt;hasConstant())
  545             fillAction = info.tagGPR() == source ? SetJSConstantTag : SetJSConstantPayload;
  546         else if (info.payloadGPR() == source)
  547             fillAction = Load32Payload;
  548         else { // Fill the Tag
  549             switch (info.spillFormat()) {
  550             case DataFormatInt32:
  551                 ASSERT(registerFormat == DataFormatJSInt32);
  552                 fillAction = SetInt32Tag;
  553                 break;
  554             case DataFormatCell:
  555                 ASSERT(registerFormat == DataFormatJSCell);
  556                 fillAction = SetCellTag;
  557                 break;
  558             case DataFormatBoolean:
  559                 ASSERT(registerFormat == DataFormatJSBoolean);
  560                 fillAction = SetBooleanTag;
  561                 break;
  562             default:
  563                 fillAction = Load32Tag;
  564                 break;
  565             }
  566         }
  567 #endif
  568     }
  569 
  570     return SilentRegisterSavePlan(spillAction, fillAction, node, source);
  571 }
  572 
  573 SilentRegisterSavePlan SpeculativeJIT::silentSavePlanForFPR(VirtualRegister spillMe, FPRReg source)
  574 {
  575     GenerationInfo&amp; info = generationInfoFromVirtualRegister(spillMe);
  576     Node* node = info.node();
  577     ASSERT(info.registerFormat() == DataFormatDouble);
  578 
  579     SilentSpillAction spillAction;
  580     SilentFillAction fillAction;
  581 
  582     if (!info.needsSpill())
  583         spillAction = DoNothingForSpill;
  584     else {
  585         ASSERT(!node-&gt;hasConstant());
  586         ASSERT(info.spillFormat() == DataFormatNone);
  587         ASSERT(info.fpr() == source);
  588         spillAction = StoreDouble;
  589     }
  590 
  591 #if USE(JSVALUE64)
  592     if (node-&gt;hasConstant()) {
  593         node-&gt;asNumber(); // To get the assertion.
  594         fillAction = SetDoubleConstant;
  595     } else {
  596         ASSERT(info.spillFormat() == DataFormatNone || info.spillFormat() == DataFormatDouble);
  597         fillAction = LoadDouble;
  598     }
  599 #elif USE(JSVALUE32_64)
  600     ASSERT(info.registerFormat() == DataFormatDouble);
  601     if (node-&gt;hasConstant()) {
  602         node-&gt;asNumber(); // To get the assertion.
  603         fillAction = SetDoubleConstant;
  604     } else
  605         fillAction = LoadDouble;
  606 #endif
  607 
  608     return SilentRegisterSavePlan(spillAction, fillAction, node, source);
  609 }
  610 
  611 void SpeculativeJIT::silentSpill(const SilentRegisterSavePlan&amp; plan)
  612 {
  613     switch (plan.spillAction()) {
  614     case DoNothingForSpill:
  615         break;
  616     case Store32Tag:
  617         m_jit.store32(plan.gpr(), JITCompiler::tagFor(plan.node()-&gt;virtualRegister()));
  618         break;
  619     case Store32Payload:
  620         m_jit.store32(plan.gpr(), JITCompiler::payloadFor(plan.node()-&gt;virtualRegister()));
  621         break;
  622     case StorePtr:
  623         m_jit.storePtr(plan.gpr(), JITCompiler::addressFor(plan.node()-&gt;virtualRegister()));
  624         break;
  625 #if USE(JSVALUE64)
  626     case Store64:
  627         m_jit.store64(plan.gpr(), JITCompiler::addressFor(plan.node()-&gt;virtualRegister()));
  628         break;
  629 #endif
  630     case StoreDouble:
  631         m_jit.storeDouble(plan.fpr(), JITCompiler::addressFor(plan.node()-&gt;virtualRegister()));
  632         break;
  633     default:
  634         RELEASE_ASSERT_NOT_REACHED();
  635     }
  636 }
  637 
  638 void SpeculativeJIT::silentFill(const SilentRegisterSavePlan&amp; plan)
  639 {
  640     switch (plan.fillAction()) {
  641     case DoNothingForFill:
  642         break;
  643     case SetInt32Constant:
  644         m_jit.move(Imm32(plan.node()-&gt;asInt32()), plan.gpr());
  645         break;
  646 #if USE(JSVALUE64)
  647     case SetInt52Constant:
  648         m_jit.move(Imm64(plan.node()-&gt;asAnyInt() &lt;&lt; JSValue::int52ShiftAmount), plan.gpr());
  649         break;
  650     case SetStrictInt52Constant:
  651         m_jit.move(Imm64(plan.node()-&gt;asAnyInt()), plan.gpr());
  652         break;
  653 #endif // USE(JSVALUE64)
  654     case SetBooleanConstant:
  655         m_jit.move(TrustedImm32(plan.node()-&gt;asBoolean()), plan.gpr());
  656         break;
  657     case SetCellConstant:
  658         ASSERT(plan.node()-&gt;constant()-&gt;value().isCell());
  659         m_jit.move(TrustedImmPtr(plan.node()-&gt;constant()), plan.gpr());
  660         break;
  661 #if USE(JSVALUE64)
  662     case SetTrustedJSConstant:
  663         m_jit.move(valueOfJSConstantAsImm64(plan.node()).asTrustedImm64(), plan.gpr());
  664         break;
  665     case SetJSConstant:
  666         m_jit.move(valueOfJSConstantAsImm64(plan.node()), plan.gpr());
  667         break;
  668     case SetDoubleConstant:
  669         m_jit.moveDouble(Imm64(reinterpretDoubleToInt64(plan.node()-&gt;asNumber())), plan.fpr());
  670         break;
  671     case Load32PayloadBoxInt:
  672         m_jit.load32(JITCompiler::payloadFor(plan.node()-&gt;virtualRegister()), plan.gpr());
  673         m_jit.or64(GPRInfo::tagTypeNumberRegister, plan.gpr());
  674         break;
  675     case Load32PayloadConvertToInt52:
  676         m_jit.load32(JITCompiler::payloadFor(plan.node()-&gt;virtualRegister()), plan.gpr());
  677         m_jit.signExtend32ToPtr(plan.gpr(), plan.gpr());
  678         m_jit.lshift64(TrustedImm32(JSValue::int52ShiftAmount), plan.gpr());
  679         break;
  680     case Load32PayloadSignExtend:
  681         m_jit.load32(JITCompiler::payloadFor(plan.node()-&gt;virtualRegister()), plan.gpr());
  682         m_jit.signExtend32ToPtr(plan.gpr(), plan.gpr());
  683         break;
  684 #else
  685     case SetJSConstantTag:
  686         m_jit.move(Imm32(plan.node()-&gt;asJSValue().tag()), plan.gpr());
  687         break;
  688     case SetJSConstantPayload:
  689         m_jit.move(Imm32(plan.node()-&gt;asJSValue().payload()), plan.gpr());
  690         break;
  691     case SetInt32Tag:
  692         m_jit.move(TrustedImm32(JSValue::Int32Tag), plan.gpr());
  693         break;
  694     case SetCellTag:
  695         m_jit.move(TrustedImm32(JSValue::CellTag), plan.gpr());
  696         break;
  697     case SetBooleanTag:
  698         m_jit.move(TrustedImm32(JSValue::BooleanTag), plan.gpr());
  699         break;
  700     case SetDoubleConstant:
  701         m_jit.loadDouble(TrustedImmPtr(m_jit.addressOfDoubleConstant(plan.node())), plan.fpr());
  702         break;
  703 #endif
  704     case Load32Tag:
  705         m_jit.load32(JITCompiler::tagFor(plan.node()-&gt;virtualRegister()), plan.gpr());
  706         break;
  707     case Load32Payload:
  708         m_jit.load32(JITCompiler::payloadFor(plan.node()-&gt;virtualRegister()), plan.gpr());
  709         break;
  710     case LoadPtr:
  711         m_jit.loadPtr(JITCompiler::addressFor(plan.node()-&gt;virtualRegister()), plan.gpr());
  712         break;
  713 #if USE(JSVALUE64)
  714     case Load64:
  715         m_jit.load64(JITCompiler::addressFor(plan.node()-&gt;virtualRegister()), plan.gpr());
  716         break;
  717     case Load64ShiftInt52Right:
  718         m_jit.load64(JITCompiler::addressFor(plan.node()-&gt;virtualRegister()), plan.gpr());
  719         m_jit.rshift64(TrustedImm32(JSValue::int52ShiftAmount), plan.gpr());
  720         break;
  721     case Load64ShiftInt52Left:
  722         m_jit.load64(JITCompiler::addressFor(plan.node()-&gt;virtualRegister()), plan.gpr());
  723         m_jit.lshift64(TrustedImm32(JSValue::int52ShiftAmount), plan.gpr());
  724         break;
  725 #endif
  726     case LoadDouble:
  727         m_jit.loadDouble(JITCompiler::addressFor(plan.node()-&gt;virtualRegister()), plan.fpr());
  728         break;
  729     default:
  730         RELEASE_ASSERT_NOT_REACHED();
  731     }
  732 }
  733 
  734 JITCompiler::JumpList SpeculativeJIT::jumpSlowForUnwantedArrayMode(GPRReg tempGPR, ArrayMode arrayMode)
  735 {
  736     JITCompiler::JumpList result;
  737 
  738     IndexingType indexingModeMask = IsArray | IndexingShapeMask;
  739     if (arrayMode.action() == Array::Write)
  740         indexingModeMask |= CopyOnWrite;
  741 
  742     switch (arrayMode.type()) {
  743     case Array::Int32:
  744     case Array::Double:
  745     case Array::Contiguous:
  746     case Array::Undecided:
  747     case Array::ArrayStorage: {
  748         IndexingType shape = arrayMode.shapeMask();
  749         switch (arrayMode.arrayClass()) {
  750         case Array::OriginalArray:
  751         case Array::OriginalCopyOnWriteArray:
  752             RELEASE_ASSERT_NOT_REACHED();
  753             return result;
  754 
  755         case Array::Array:
  756             m_jit.and32(TrustedImm32(indexingModeMask), tempGPR);
  757             result.append(m_jit.branch32(
  758                 MacroAssembler::NotEqual, tempGPR, TrustedImm32(IsArray | shape)));
  759             return result;
  760 
  761         case Array::NonArray:
  762         case Array::OriginalNonArray:
  763             m_jit.and32(TrustedImm32(indexingModeMask), tempGPR);
  764             result.append(m_jit.branch32(
  765                 MacroAssembler::NotEqual, tempGPR, TrustedImm32(shape)));
  766             return result;
  767 
  768         case Array::PossiblyArray:
  769             m_jit.and32(TrustedImm32(indexingModeMask &amp; ~IsArray), tempGPR);
  770             result.append(m_jit.branch32(MacroAssembler::NotEqual, tempGPR, TrustedImm32(shape)));
  771             return result;
  772         }
  773 
  774         RELEASE_ASSERT_NOT_REACHED();
  775         return result;
  776     }
  777 
  778     case Array::SlowPutArrayStorage: {
  779         ASSERT(!arrayMode.isJSArrayWithOriginalStructure());
  780 
  781         switch (arrayMode.arrayClass()) {
  782         case Array::OriginalArray:
  783         case Array::OriginalCopyOnWriteArray:
  784             RELEASE_ASSERT_NOT_REACHED();
  785             return result;
  786 
  787         case Array::Array:
  788             result.append(
  789                 m_jit.branchTest32(
  790                     MacroAssembler::Zero, tempGPR, MacroAssembler::TrustedImm32(IsArray)));
  791             break;
  792 
  793         case Array::NonArray:
  794         case Array::OriginalNonArray:
  795             result.append(
  796                 m_jit.branchTest32(
  797                     MacroAssembler::NonZero, tempGPR, MacroAssembler::TrustedImm32(IsArray)));
  798             break;
  799 
  800         case Array::PossiblyArray:
  801             break;
  802         }
  803 
  804         m_jit.and32(TrustedImm32(IndexingShapeMask), tempGPR);
  805         m_jit.sub32(TrustedImm32(ArrayStorageShape), tempGPR);
  806         result.append(
  807             m_jit.branch32(
  808                 MacroAssembler::Above, tempGPR,
  809                 TrustedImm32(SlowPutArrayStorageShape - ArrayStorageShape)));
  810         return result;
  811     }
  812     default:
  813         CRASH();
  814         break;
  815     }
  816 
  817     return result;
  818 }
  819 
  820 void SpeculativeJIT::checkArray(Node* node)
  821 {
  822     ASSERT(node-&gt;arrayMode().isSpecific());
  823     ASSERT(!node-&gt;arrayMode().doesConversion());
  824 
  825     SpeculateCellOperand base(this, node-&gt;child1());
  826     GPRReg baseReg = base.gpr();
  827 
  828     if (node-&gt;arrayMode().alreadyChecked(m_jit.graph(), node, m_state.forNode(node-&gt;child1()))) {
  829         noResult(m_currentNode);
  830         return;
  831     }
  832 
  833     switch (node-&gt;arrayMode().type()) {
  834     case Array::AnyTypedArray:
  835     case Array::String:
  836         RELEASE_ASSERT_NOT_REACHED(); // Should have been a Phantom(String:)
  837         return;
  838     case Array::Int32:
  839     case Array::Double:
  840     case Array::Contiguous:
  841     case Array::Undecided:
  842     case Array::ArrayStorage:
  843     case Array::SlowPutArrayStorage: {
  844         GPRTemporary temp(this);
  845         GPRReg tempGPR = temp.gpr();
  846         m_jit.load8(MacroAssembler::Address(baseReg, JSCell::indexingTypeAndMiscOffset()), tempGPR);
  847         speculationCheck(
  848             BadIndexingType, JSValueSource::unboxedCell(baseReg), 0,
  849             jumpSlowForUnwantedArrayMode(tempGPR, node-&gt;arrayMode()));
  850 
  851         noResult(m_currentNode);
  852         return;
  853     }
  854     case Array::DirectArguments:
  855         speculateCellTypeWithoutTypeFiltering(node-&gt;child1(), baseReg, DirectArgumentsType);
  856         noResult(m_currentNode);
  857         return;
  858     case Array::ScopedArguments:
  859         speculateCellTypeWithoutTypeFiltering(node-&gt;child1(), baseReg, ScopedArgumentsType);
  860         noResult(m_currentNode);
  861         return;
  862     default:
  863         speculateCellTypeWithoutTypeFiltering(
  864             node-&gt;child1(), baseReg,
  865             typeForTypedArrayType(node-&gt;arrayMode().typedArrayType()));
  866         noResult(m_currentNode);
  867         return;
  868     }
  869 }
  870 
  871 void SpeculativeJIT::arrayify(Node* node, GPRReg baseReg, GPRReg propertyReg)
  872 {
  873     ASSERT(node-&gt;arrayMode().doesConversion());
  874 
  875     GPRTemporary temp(this);
  876     GPRTemporary structure;
  877     GPRReg tempGPR = temp.gpr();
  878     GPRReg structureGPR = InvalidGPRReg;
  879 
  880     if (node-&gt;op() != ArrayifyToStructure) {
  881         GPRTemporary realStructure(this);
  882         structure.adopt(realStructure);
  883         structureGPR = structure.gpr();
  884     }
  885 
  886     // We can skip all that comes next if we already have array storage.
  887     MacroAssembler::JumpList slowPath;
  888 
  889     if (node-&gt;op() == ArrayifyToStructure) {
  890         ASSERT(!isCopyOnWrite(node-&gt;structure()-&gt;indexingMode()));
  891         ASSERT((node-&gt;structure()-&gt;indexingType() &amp; IndexingShapeMask) == node-&gt;arrayMode().shapeMask());
  892         slowPath.append(m_jit.branchWeakStructure(
  893             JITCompiler::NotEqual,
  894             JITCompiler::Address(baseReg, JSCell::structureIDOffset()),
  895             node-&gt;structure()));
  896     } else {
  897         m_jit.load8(
  898             MacroAssembler::Address(baseReg, JSCell::indexingTypeAndMiscOffset()), tempGPR);
  899 
  900         slowPath.append(jumpSlowForUnwantedArrayMode(tempGPR, node-&gt;arrayMode()));
  901     }
  902 
<a name="13" id="anc13"></a><span class="line-modified">  903     addSlowPathGenerator(makeUnique&lt;ArrayifySlowPathGenerator&gt;(</span>
  904         slowPath, this, node, baseReg, propertyReg, tempGPR, structureGPR));
  905 
  906     noResult(m_currentNode);
  907 }
  908 
  909 void SpeculativeJIT::arrayify(Node* node)
  910 {
  911     ASSERT(node-&gt;arrayMode().isSpecific());
  912 
  913     SpeculateCellOperand base(this, node-&gt;child1());
  914 
  915     if (!node-&gt;child2()) {
  916         arrayify(node, base.gpr(), InvalidGPRReg);
  917         return;
  918     }
  919 
  920     SpeculateInt32Operand property(this, node-&gt;child2());
  921 
  922     arrayify(node, base.gpr(), property.gpr());
  923 }
  924 
  925 GPRReg SpeculativeJIT::fillStorage(Edge edge)
  926 {
  927     VirtualRegister virtualRegister = edge-&gt;virtualRegister();
  928     GenerationInfo&amp; info = generationInfoFromVirtualRegister(virtualRegister);
  929 
  930     switch (info.registerFormat()) {
  931     case DataFormatNone: {
  932         if (info.spillFormat() == DataFormatStorage) {
  933             GPRReg gpr = allocate();
  934             m_gprs.retain(gpr, virtualRegister, SpillOrderSpilled);
  935             m_jit.loadPtr(JITCompiler::addressFor(virtualRegister), gpr);
  936             info.fillStorage(*m_stream, gpr);
  937             return gpr;
  938         }
  939 
  940         // Must be a cell; fill it as a cell and then return the pointer.
  941         return fillSpeculateCell(edge);
  942     }
  943 
  944     case DataFormatStorage: {
  945         GPRReg gpr = info.gpr();
  946         m_gprs.lock(gpr);
  947         return gpr;
  948     }
  949 
  950     default:
  951         return fillSpeculateCell(edge);
  952     }
  953 }
  954 
  955 void SpeculativeJIT::useChildren(Node* node)
  956 {
  957     if (node-&gt;flags() &amp; NodeHasVarArgs) {
  958         for (unsigned childIdx = node-&gt;firstChild(); childIdx &lt; node-&gt;firstChild() + node-&gt;numChildren(); childIdx++) {
  959             if (!!m_jit.graph().m_varArgChildren[childIdx])
  960                 use(m_jit.graph().m_varArgChildren[childIdx]);
  961         }
  962     } else {
  963         Edge child1 = node-&gt;child1();
  964         if (!child1) {
  965             ASSERT(!node-&gt;child2() &amp;&amp; !node-&gt;child3());
  966             return;
  967         }
  968         use(child1);
  969 
  970         Edge child2 = node-&gt;child2();
  971         if (!child2) {
  972             ASSERT(!node-&gt;child3());
  973             return;
  974         }
  975         use(child2);
  976 
  977         Edge child3 = node-&gt;child3();
  978         if (!child3)
  979             return;
  980         use(child3);
  981     }
  982 }
  983 
  984 void SpeculativeJIT::compileGetById(Node* node, AccessType accessType)
  985 {
  986     ASSERT(accessType == AccessType::Get || accessType == AccessType::GetDirect || accessType == AccessType::TryGet);
  987 
  988     switch (node-&gt;child1().useKind()) {
  989     case CellUse: {
  990         SpeculateCellOperand base(this, node-&gt;child1());
  991         JSValueRegsTemporary result(this, Reuse, base);
  992 
  993         JSValueRegs baseRegs = JSValueRegs::payloadOnly(base.gpr());
  994         JSValueRegs resultRegs = result.regs();
  995 
  996         base.use();
  997 
  998         cachedGetById(node-&gt;origin.semantic, baseRegs, resultRegs, node-&gt;identifierNumber(), JITCompiler::Jump(), NeedToSpill, accessType);
  999 
 1000         jsValueResult(resultRegs, node, DataFormatJS, UseChildrenCalledExplicitly);
 1001         break;
 1002     }
 1003 
 1004     case UntypedUse: {
 1005         JSValueOperand base(this, node-&gt;child1());
 1006         JSValueRegsTemporary result(this, Reuse, base);
 1007 
 1008         JSValueRegs baseRegs = base.jsValueRegs();
 1009         JSValueRegs resultRegs = result.regs();
 1010 
 1011         base.use();
 1012 
 1013         JITCompiler::Jump notCell = m_jit.branchIfNotCell(baseRegs);
 1014 
 1015         cachedGetById(node-&gt;origin.semantic, baseRegs, resultRegs, node-&gt;identifierNumber(), notCell, NeedToSpill, accessType);
 1016 
 1017         jsValueResult(resultRegs, node, DataFormatJS, UseChildrenCalledExplicitly);
 1018         break;
 1019     }
 1020 
 1021     default:
 1022         DFG_CRASH(m_jit.graph(), node, &quot;Bad use kind&quot;);
 1023         break;
 1024     }
 1025 }
 1026 
 1027 void SpeculativeJIT::compileGetByIdFlush(Node* node, AccessType accessType)
 1028 {
 1029     switch (node-&gt;child1().useKind()) {
 1030     case CellUse: {
 1031         SpeculateCellOperand base(this, node-&gt;child1());
 1032         JSValueRegs baseRegs = JSValueRegs::payloadOnly(base.gpr());
 1033 
 1034         JSValueRegsFlushedCallResult result(this);
 1035         JSValueRegs resultRegs = result.regs();
 1036 
 1037         base.use();
 1038 
 1039         flushRegisters();
 1040 
 1041         cachedGetById(node-&gt;origin.semantic, baseRegs, resultRegs, node-&gt;identifierNumber(), JITCompiler::Jump(), DontSpill, accessType);
 1042 
 1043         jsValueResult(resultRegs, node, DataFormatJS, UseChildrenCalledExplicitly);
 1044         break;
 1045     }
 1046 
 1047     case UntypedUse: {
 1048         JSValueOperand base(this, node-&gt;child1());
 1049         JSValueRegs baseRegs = base.jsValueRegs();
 1050 
 1051         JSValueRegsFlushedCallResult result(this);
 1052         JSValueRegs resultRegs = result.regs();
 1053 
 1054         base.use();
 1055 
 1056         flushRegisters();
 1057 
 1058         JITCompiler::Jump notCell = m_jit.branchIfNotCell(baseRegs);
 1059 
 1060         cachedGetById(node-&gt;origin.semantic, baseRegs, resultRegs, node-&gt;identifierNumber(), notCell, DontSpill, accessType);
 1061 
 1062         jsValueResult(resultRegs, node, DataFormatJS, UseChildrenCalledExplicitly);
 1063         break;
 1064     }
 1065 
 1066     default:
 1067         DFG_CRASH(m_jit.graph(), node, &quot;Bad use kind&quot;);
 1068         break;
 1069     }
 1070 }
 1071 
 1072 void SpeculativeJIT::compileInById(Node* node)
 1073 {
 1074     SpeculateCellOperand base(this, node-&gt;child1());
 1075     JSValueRegsTemporary result(this, Reuse, base, PayloadWord);
 1076 
 1077     GPRReg baseGPR = base.gpr();
 1078     JSValueRegs resultRegs = result.regs();
 1079 
 1080     base.use();
 1081 
 1082     CodeOrigin codeOrigin = node-&gt;origin.semantic;
 1083     CallSiteIndex callSite = m_jit.recordCallSiteAndGenerateExceptionHandlingOSRExitIfNeeded(codeOrigin, m_stream-&gt;size());
 1084     RegisterSet usedRegisters = this-&gt;usedRegisters();
 1085     JITInByIdGenerator gen(
 1086         m_jit.codeBlock(), codeOrigin, callSite, usedRegisters, identifierUID(node-&gt;identifierNumber()),
 1087         JSValueRegs::payloadOnly(baseGPR), resultRegs);
 1088     gen.generateFastPath(m_jit);
 1089 
 1090     auto slowPath = slowPathCall(
 1091         gen.slowPathJump(), this, operationInByIdOptimize,
 1092         NeedToSpill, ExceptionCheckRequirement::CheckNeeded,
 1093         resultRegs, gen.stubInfo(), CCallHelpers::CellValue(baseGPR), identifierUID(node-&gt;identifierNumber()));
 1094 
 1095     m_jit.addInById(gen, slowPath.get());
 1096     addSlowPathGenerator(WTFMove(slowPath));
 1097 
 1098     blessedBooleanResult(resultRegs.payloadGPR(), node, UseChildrenCalledExplicitly);
 1099 }
 1100 
 1101 void SpeculativeJIT::compileInByVal(Node* node)
 1102 {
 1103     SpeculateCellOperand base(this, node-&gt;child1());
 1104     JSValueOperand key(this, node-&gt;child2());
 1105 
 1106     GPRReg baseGPR = base.gpr();
 1107     JSValueRegs regs = key.jsValueRegs();
 1108 
 1109     base.use();
 1110     key.use();
 1111 
 1112     flushRegisters();
 1113     JSValueRegsFlushedCallResult result(this);
 1114     JSValueRegs resultRegs = result.regs();
 1115     callOperation(operationInByVal, resultRegs, baseGPR, regs);
 1116     m_jit.exceptionCheck();
 1117     blessedBooleanResult(resultRegs.payloadGPR(), node, UseChildrenCalledExplicitly);
 1118 }
 1119 
 1120 void SpeculativeJIT::compileDeleteById(Node* node)
 1121 {
 1122     JSValueOperand value(this, node-&gt;child1());
 1123     GPRFlushedCallResult result(this);
 1124 
 1125     JSValueRegs valueRegs = value.jsValueRegs();
 1126     GPRReg resultGPR = result.gpr();
 1127 
 1128     value.use();
 1129 
 1130     flushRegisters();
 1131     callOperation(operationDeleteById, resultGPR, valueRegs, identifierUID(node-&gt;identifierNumber()));
 1132     m_jit.exceptionCheck();
 1133 
 1134     unblessedBooleanResult(resultGPR, node, UseChildrenCalledExplicitly);
 1135 }
 1136 
 1137 void SpeculativeJIT::compileDeleteByVal(Node* node)
 1138 {
 1139     JSValueOperand base(this, node-&gt;child1());
 1140     JSValueOperand key(this, node-&gt;child2());
 1141     GPRFlushedCallResult result(this);
 1142 
 1143     JSValueRegs baseRegs = base.jsValueRegs();
 1144     JSValueRegs keyRegs = key.jsValueRegs();
 1145     GPRReg resultGPR = result.gpr();
 1146 
 1147     base.use();
 1148     key.use();
 1149 
 1150     flushRegisters();
 1151     callOperation(operationDeleteByVal, resultGPR, baseRegs, keyRegs);
 1152     m_jit.exceptionCheck();
 1153 
 1154     unblessedBooleanResult(resultGPR, node, UseChildrenCalledExplicitly);
 1155 }
 1156 
 1157 void SpeculativeJIT::compilePushWithScope(Node* node)
 1158 {
 1159     SpeculateCellOperand currentScope(this, node-&gt;child1());
 1160     GPRReg currentScopeGPR = currentScope.gpr();
 1161 
 1162     GPRFlushedCallResult result(this);
 1163     GPRReg resultGPR = result.gpr();
 1164 
 1165     auto objectEdge = node-&gt;child2();
 1166     if (objectEdge.useKind() == ObjectUse) {
 1167         SpeculateCellOperand object(this, objectEdge);
 1168         GPRReg objectGPR = object.gpr();
 1169         speculateObject(objectEdge, objectGPR);
 1170 
 1171         flushRegisters();
 1172         callOperation(operationPushWithScopeObject, resultGPR, currentScopeGPR, objectGPR);
 1173         // No exception check here as we did not have to call toObject().
 1174     } else {
 1175         ASSERT(objectEdge.useKind() == UntypedUse);
 1176         JSValueOperand object(this, objectEdge);
 1177         JSValueRegs objectRegs = object.jsValueRegs();
 1178 
 1179         flushRegisters();
 1180         callOperation(operationPushWithScope, resultGPR, currentScopeGPR, objectRegs);
 1181         m_jit.exceptionCheck();
 1182     }
 1183 
 1184     cellResult(resultGPR, node);
 1185 }
 1186 
 1187 bool SpeculativeJIT::nonSpeculativeStrictEq(Node* node, bool invert)
 1188 {
 1189     unsigned branchIndexInBlock = detectPeepHoleBranch();
 1190     if (branchIndexInBlock != UINT_MAX) {
 1191         Node* branchNode = m_block-&gt;at(branchIndexInBlock);
 1192 
 1193         ASSERT(node-&gt;adjustedRefCount() == 1);
 1194 
 1195         nonSpeculativePeepholeStrictEq(node, branchNode, invert);
 1196 
 1197         m_indexInBlock = branchIndexInBlock;
 1198         m_currentNode = branchNode;
 1199 
 1200         return true;
 1201     }
 1202 
 1203     nonSpeculativeNonPeepholeStrictEq(node, invert);
 1204 
 1205     return false;
 1206 }
 1207 
 1208 static const char* dataFormatString(DataFormat format)
 1209 {
 1210     // These values correspond to the DataFormat enum.
 1211     const char* strings[] = {
 1212         &quot;[  ]&quot;,
 1213         &quot;[ i]&quot;,
 1214         &quot;[ d]&quot;,
 1215         &quot;[ c]&quot;,
 1216         &quot;Err!&quot;,
 1217         &quot;Err!&quot;,
 1218         &quot;Err!&quot;,
 1219         &quot;Err!&quot;,
 1220         &quot;[J ]&quot;,
 1221         &quot;[Ji]&quot;,
 1222         &quot;[Jd]&quot;,
 1223         &quot;[Jc]&quot;,
 1224         &quot;Err!&quot;,
 1225         &quot;Err!&quot;,
 1226         &quot;Err!&quot;,
 1227         &quot;Err!&quot;,
 1228     };
 1229     return strings[format];
 1230 }
 1231 
 1232 void SpeculativeJIT::dump(const char* label)
 1233 {
 1234     if (label)
 1235         dataLogF(&quot;&lt;%s&gt;\n&quot;, label);
 1236 
 1237     dataLogF(&quot;  gprs:\n&quot;);
 1238     m_gprs.dump();
 1239     dataLogF(&quot;  fprs:\n&quot;);
 1240     m_fprs.dump();
 1241     dataLogF(&quot;  VirtualRegisters:\n&quot;);
 1242     for (unsigned i = 0; i &lt; m_generationInfo.size(); ++i) {
 1243         GenerationInfo&amp; info = m_generationInfo[i];
 1244         if (info.alive())
 1245             dataLogF(&quot;    % 3d:%s%s&quot;, i, dataFormatString(info.registerFormat()), dataFormatString(info.spillFormat()));
 1246         else
 1247             dataLogF(&quot;    % 3d:[__][__]&quot;, i);
 1248         if (info.registerFormat() == DataFormatDouble)
 1249             dataLogF(&quot;:fpr%d\n&quot;, info.fpr());
 1250         else if (info.registerFormat() != DataFormatNone
 1251 #if USE(JSVALUE32_64)
 1252             &amp;&amp; !(info.registerFormat() &amp; DataFormatJS)
 1253 #endif
 1254             ) {
 1255             ASSERT(info.gpr() != InvalidGPRReg);
 1256             dataLogF(&quot;:%s\n&quot;, GPRInfo::debugName(info.gpr()));
 1257         } else
 1258             dataLogF(&quot;\n&quot;);
 1259     }
 1260     if (label)
 1261         dataLogF(&quot;&lt;/%s&gt;\n&quot;, label);
 1262 }
 1263 
 1264 GPRTemporary::GPRTemporary()
 1265     : m_jit(0)
 1266     , m_gpr(InvalidGPRReg)
 1267 {
 1268 }
 1269 
 1270 GPRTemporary::GPRTemporary(SpeculativeJIT* jit)
 1271     : m_jit(jit)
 1272     , m_gpr(InvalidGPRReg)
 1273 {
 1274     m_gpr = m_jit-&gt;allocate();
 1275 }
 1276 
 1277 GPRTemporary::GPRTemporary(SpeculativeJIT* jit, GPRReg specific)
 1278     : m_jit(jit)
 1279     , m_gpr(InvalidGPRReg)
 1280 {
 1281     m_gpr = m_jit-&gt;allocate(specific);
 1282 }
 1283 
 1284 #if USE(JSVALUE32_64)
 1285 GPRTemporary::GPRTemporary(
 1286     SpeculativeJIT* jit, ReuseTag, JSValueOperand&amp; op1, WhichValueWord which)
 1287     : m_jit(jit)
 1288     , m_gpr(InvalidGPRReg)
 1289 {
 1290     if (!op1.isDouble() &amp;&amp; m_jit-&gt;canReuse(op1.node()))
 1291         m_gpr = m_jit-&gt;reuse(op1.gpr(which));
 1292     else
 1293         m_gpr = m_jit-&gt;allocate();
 1294 }
 1295 #else // USE(JSVALUE32_64)
 1296 GPRTemporary::GPRTemporary(SpeculativeJIT* jit, ReuseTag, JSValueOperand&amp; op1, WhichValueWord)
 1297     : GPRTemporary(jit, Reuse, op1)
 1298 {
 1299 }
 1300 #endif
 1301 
 1302 JSValueRegsTemporary::JSValueRegsTemporary() { }
 1303 
 1304 JSValueRegsTemporary::JSValueRegsTemporary(SpeculativeJIT* jit)
 1305 #if USE(JSVALUE64)
 1306     : m_gpr(jit)
 1307 #else
 1308     : m_payloadGPR(jit)
 1309     , m_tagGPR(jit)
 1310 #endif
 1311 {
 1312 }
 1313 
 1314 #if USE(JSVALUE64)
 1315 template&lt;typename T&gt;
 1316 JSValueRegsTemporary::JSValueRegsTemporary(SpeculativeJIT* jit, ReuseTag, T&amp; operand, WhichValueWord)
 1317     : m_gpr(jit, Reuse, operand)
 1318 {
 1319 }
 1320 #else
 1321 template&lt;typename T&gt;
 1322 JSValueRegsTemporary::JSValueRegsTemporary(SpeculativeJIT* jit, ReuseTag, T&amp; operand, WhichValueWord resultWord)
 1323 {
 1324     if (resultWord == PayloadWord) {
 1325         m_payloadGPR = GPRTemporary(jit, Reuse, operand);
 1326         m_tagGPR = GPRTemporary(jit);
 1327     } else {
 1328         m_payloadGPR = GPRTemporary(jit);
 1329         m_tagGPR = GPRTemporary(jit, Reuse, operand);
 1330     }
 1331 }
 1332 #endif
 1333 
 1334 #if USE(JSVALUE64)
 1335 JSValueRegsTemporary::JSValueRegsTemporary(SpeculativeJIT* jit, ReuseTag, JSValueOperand&amp; operand)
 1336 {
 1337     m_gpr = GPRTemporary(jit, Reuse, operand);
 1338 }
 1339 #else
 1340 JSValueRegsTemporary::JSValueRegsTemporary(SpeculativeJIT* jit, ReuseTag, JSValueOperand&amp; operand)
 1341 {
 1342     if (jit-&gt;canReuse(operand.node())) {
 1343         m_payloadGPR = GPRTemporary(jit, Reuse, operand, PayloadWord);
 1344         m_tagGPR = GPRTemporary(jit, Reuse, operand, TagWord);
 1345     } else {
 1346         m_payloadGPR = GPRTemporary(jit);
 1347         m_tagGPR = GPRTemporary(jit);
 1348     }
 1349 }
 1350 #endif
 1351 
 1352 JSValueRegsTemporary::~JSValueRegsTemporary() { }
 1353 
 1354 JSValueRegs JSValueRegsTemporary::regs()
 1355 {
 1356 #if USE(JSVALUE64)
 1357     return JSValueRegs(m_gpr.gpr());
 1358 #else
 1359     return JSValueRegs(m_tagGPR.gpr(), m_payloadGPR.gpr());
 1360 #endif
 1361 }
 1362 
 1363 void GPRTemporary::adopt(GPRTemporary&amp; other)
 1364 {
 1365     ASSERT(!m_jit);
 1366     ASSERT(m_gpr == InvalidGPRReg);
 1367     ASSERT(other.m_jit);
 1368     ASSERT(other.m_gpr != InvalidGPRReg);
 1369     m_jit = other.m_jit;
 1370     m_gpr = other.m_gpr;
 1371     other.m_jit = 0;
 1372     other.m_gpr = InvalidGPRReg;
 1373 }
 1374 
 1375 FPRTemporary::FPRTemporary(FPRTemporary&amp;&amp; other)
 1376 {
 1377     ASSERT(other.m_jit);
 1378     ASSERT(other.m_fpr != InvalidFPRReg);
 1379     m_jit = other.m_jit;
 1380     m_fpr = other.m_fpr;
 1381 
 1382     other.m_jit = nullptr;
 1383 }
 1384 
 1385 FPRTemporary::FPRTemporary(SpeculativeJIT* jit)
 1386     : m_jit(jit)
 1387     , m_fpr(InvalidFPRReg)
 1388 {
 1389     m_fpr = m_jit-&gt;fprAllocate();
 1390 }
 1391 
 1392 FPRTemporary::FPRTemporary(SpeculativeJIT* jit, SpeculateDoubleOperand&amp; op1)
 1393     : m_jit(jit)
 1394     , m_fpr(InvalidFPRReg)
 1395 {
 1396     if (m_jit-&gt;canReuse(op1.node()))
 1397         m_fpr = m_jit-&gt;reuse(op1.fpr());
 1398     else
 1399         m_fpr = m_jit-&gt;fprAllocate();
 1400 }
 1401 
 1402 FPRTemporary::FPRTemporary(SpeculativeJIT* jit, SpeculateDoubleOperand&amp; op1, SpeculateDoubleOperand&amp; op2)
 1403     : m_jit(jit)
 1404     , m_fpr(InvalidFPRReg)
 1405 {
 1406     if (m_jit-&gt;canReuse(op1.node()))
 1407         m_fpr = m_jit-&gt;reuse(op1.fpr());
 1408     else if (m_jit-&gt;canReuse(op2.node()))
 1409         m_fpr = m_jit-&gt;reuse(op2.fpr());
 1410     else if (m_jit-&gt;canReuse(op1.node(), op2.node()) &amp;&amp; op1.fpr() == op2.fpr())
 1411         m_fpr = m_jit-&gt;reuse(op1.fpr());
 1412     else
 1413         m_fpr = m_jit-&gt;fprAllocate();
 1414 }
 1415 
 1416 #if USE(JSVALUE32_64)
 1417 FPRTemporary::FPRTemporary(SpeculativeJIT* jit, JSValueOperand&amp; op1)
 1418     : m_jit(jit)
 1419     , m_fpr(InvalidFPRReg)
 1420 {
 1421     if (op1.isDouble() &amp;&amp; m_jit-&gt;canReuse(op1.node()))
 1422         m_fpr = m_jit-&gt;reuse(op1.fpr());
 1423     else
 1424         m_fpr = m_jit-&gt;fprAllocate();
 1425 }
 1426 #endif
 1427 
 1428 void SpeculativeJIT::compilePeepHoleDoubleBranch(Node* node, Node* branchNode, JITCompiler::DoubleCondition condition)
 1429 {
 1430     BasicBlock* taken = branchNode-&gt;branchData()-&gt;taken.block;
 1431     BasicBlock* notTaken = branchNode-&gt;branchData()-&gt;notTaken.block;
 1432 
 1433     if (taken == nextBlock()) {
 1434         condition = MacroAssembler::invert(condition);
 1435         std::swap(taken, notTaken);
 1436     }
 1437 
 1438     SpeculateDoubleOperand op1(this, node-&gt;child1());
 1439     SpeculateDoubleOperand op2(this, node-&gt;child2());
 1440 
 1441     branchDouble(condition, op1.fpr(), op2.fpr(), taken);
 1442     jump(notTaken);
 1443 }
 1444 
 1445 void SpeculativeJIT::compilePeepHoleObjectEquality(Node* node, Node* branchNode)
 1446 {
 1447     BasicBlock* taken = branchNode-&gt;branchData()-&gt;taken.block;
 1448     BasicBlock* notTaken = branchNode-&gt;branchData()-&gt;notTaken.block;
 1449 
 1450     MacroAssembler::RelationalCondition condition = MacroAssembler::Equal;
 1451 
 1452     if (taken == nextBlock()) {
 1453         condition = MacroAssembler::NotEqual;
 1454         BasicBlock* tmp = taken;
 1455         taken = notTaken;
 1456         notTaken = tmp;
 1457     }
 1458 
 1459     SpeculateCellOperand op1(this, node-&gt;child1());
 1460     SpeculateCellOperand op2(this, node-&gt;child2());
 1461 
 1462     GPRReg op1GPR = op1.gpr();
 1463     GPRReg op2GPR = op2.gpr();
 1464 
 1465     if (masqueradesAsUndefinedWatchpointIsStillValid()) {
 1466         if (m_state.forNode(node-&gt;child1()).m_type &amp; ~SpecObject) {
 1467             speculationCheck(
 1468                 BadType, JSValueSource::unboxedCell(op1GPR), node-&gt;child1(), m_jit.branchIfNotObject(op1GPR));
 1469         }
 1470         if (m_state.forNode(node-&gt;child2()).m_type &amp; ~SpecObject) {
 1471             speculationCheck(
 1472                 BadType, JSValueSource::unboxedCell(op2GPR), node-&gt;child2(), m_jit.branchIfNotObject(op2GPR));
 1473         }
 1474     } else {
 1475         if (m_state.forNode(node-&gt;child1()).m_type &amp; ~SpecObject) {
 1476             speculationCheck(
 1477                 BadType, JSValueSource::unboxedCell(op1GPR), node-&gt;child1(),
 1478                 m_jit.branchIfNotObject(op1GPR));
 1479         }
 1480         speculationCheck(BadType, JSValueSource::unboxedCell(op1GPR), node-&gt;child1(),
 1481             m_jit.branchTest8(
 1482                 MacroAssembler::NonZero,
 1483                 MacroAssembler::Address(op1GPR, JSCell::typeInfoFlagsOffset()),
 1484                 MacroAssembler::TrustedImm32(MasqueradesAsUndefined)));
 1485 
 1486         if (m_state.forNode(node-&gt;child2()).m_type &amp; ~SpecObject) {
 1487             speculationCheck(
 1488                 BadType, JSValueSource::unboxedCell(op2GPR), node-&gt;child2(),
 1489                 m_jit.branchIfNotObject(op2GPR));
 1490         }
 1491         speculationCheck(BadType, JSValueSource::unboxedCell(op2GPR), node-&gt;child2(),
 1492             m_jit.branchTest8(
 1493                 MacroAssembler::NonZero,
 1494                 MacroAssembler::Address(op2GPR, JSCell::typeInfoFlagsOffset()),
 1495                 MacroAssembler::TrustedImm32(MasqueradesAsUndefined)));
 1496     }
 1497 
 1498     branchPtr(condition, op1GPR, op2GPR, taken);
 1499     jump(notTaken);
 1500 }
 1501 
 1502 void SpeculativeJIT::compilePeepHoleBooleanBranch(Node* node, Node* branchNode, JITCompiler::RelationalCondition condition)
 1503 {
 1504     BasicBlock* taken = branchNode-&gt;branchData()-&gt;taken.block;
 1505     BasicBlock* notTaken = branchNode-&gt;branchData()-&gt;notTaken.block;
 1506 
 1507     // The branch instruction will branch to the taken block.
 1508     // If taken is next, switch taken with notTaken &amp; invert the branch condition so we can fall through.
 1509     if (taken == nextBlock()) {
 1510         condition = JITCompiler::invert(condition);
 1511         BasicBlock* tmp = taken;
 1512         taken = notTaken;
 1513         notTaken = tmp;
 1514     }
 1515 
 1516     if (node-&gt;child1()-&gt;isInt32Constant()) {
 1517         int32_t imm = node-&gt;child1()-&gt;asInt32();
 1518         SpeculateBooleanOperand op2(this, node-&gt;child2());
 1519         branch32(condition, JITCompiler::Imm32(imm), op2.gpr(), taken);
 1520     } else if (node-&gt;child2()-&gt;isInt32Constant()) {
 1521         SpeculateBooleanOperand op1(this, node-&gt;child1());
 1522         int32_t imm = node-&gt;child2()-&gt;asInt32();
 1523         branch32(condition, op1.gpr(), JITCompiler::Imm32(imm), taken);
 1524     } else {
 1525         SpeculateBooleanOperand op1(this, node-&gt;child1());
 1526         SpeculateBooleanOperand op2(this, node-&gt;child2());
 1527         branch32(condition, op1.gpr(), op2.gpr(), taken);
 1528     }
 1529 
 1530     jump(notTaken);
 1531 }
 1532 
 1533 void SpeculativeJIT::compileStringSlice(Node* node)
 1534 {
 1535     SpeculateCellOperand string(this, node-&gt;child1());
 1536 
 1537     GPRReg stringGPR = string.gpr();
 1538 
 1539     speculateString(node-&gt;child1(), stringGPR);
 1540 
 1541     SpeculateInt32Operand start(this, node-&gt;child2());
 1542     GPRReg startGPR = start.gpr();
 1543 
 1544     Optional&lt;SpeculateInt32Operand&gt; end;
 1545     Optional&lt;GPRReg&gt; endGPR;
 1546     if (node-&gt;child3()) {
 1547         end.emplace(this, node-&gt;child3());
 1548         endGPR.emplace(end-&gt;gpr());
 1549     }
 1550 
 1551     GPRTemporary temp(this);
<a name="14" id="anc14"></a>




 1552     GPRTemporary temp2(this);
 1553     GPRTemporary startIndex(this);
 1554 
<a name="15" id="anc15"></a><span class="line-added"> 1555     GPRReg tempGPR = temp.gpr();</span>
 1556     GPRReg temp2GPR = temp2.gpr();
 1557     GPRReg startIndexGPR = startIndex.gpr();
<a name="16" id="anc16"></a><span class="line-added"> 1558 </span>
<span class="line-added"> 1559     m_jit.loadPtr(CCallHelpers::Address(stringGPR, JSString::offsetOfValue()), tempGPR);</span>
<span class="line-added"> 1560     auto isRope = m_jit.branchIfRopeStringImpl(tempGPR);</span>
 1561     {
 1562         m_jit.load32(MacroAssembler::Address(tempGPR, StringImpl::lengthMemoryOffset()), temp2GPR);
 1563 
 1564         emitPopulateSliceIndex(node-&gt;child2(), startGPR, temp2GPR, startIndexGPR);
 1565 
 1566         if (node-&gt;child3())
 1567             emitPopulateSliceIndex(node-&gt;child3(), endGPR.value(), temp2GPR, tempGPR);
 1568         else
 1569             m_jit.move(temp2GPR, tempGPR);
 1570     }
 1571 
 1572     CCallHelpers::JumpList doneCases;
 1573     CCallHelpers::JumpList slowCases;
 1574 
<a name="17" id="anc17"></a><span class="line-added"> 1575     VM&amp; vm = this-&gt;vm();</span>
 1576     auto nonEmptyCase = m_jit.branch32(MacroAssembler::Below, startIndexGPR, tempGPR);
<a name="18" id="anc18"></a><span class="line-modified"> 1577     m_jit.move(TrustedImmPtr::weakPointer(m_jit.graph(), jsEmptyString(vm)), tempGPR);</span>
 1578     doneCases.append(m_jit.jump());
 1579 
 1580     nonEmptyCase.link(&amp;m_jit);
 1581     m_jit.sub32(startIndexGPR, tempGPR); // the size of the sliced string.
 1582     slowCases.append(m_jit.branch32(MacroAssembler::NotEqual, tempGPR, TrustedImm32(1)));
 1583 
 1584     // Refill StringImpl* here.
 1585     m_jit.loadPtr(MacroAssembler::Address(stringGPR, JSString::offsetOfValue()), temp2GPR);
 1586     m_jit.loadPtr(MacroAssembler::Address(temp2GPR, StringImpl::dataOffset()), tempGPR);
 1587 
 1588     // Load the character into scratchReg
 1589     m_jit.zeroExtend32ToPtr(startIndexGPR, startIndexGPR);
 1590     auto is16Bit = m_jit.branchTest32(MacroAssembler::Zero, MacroAssembler::Address(temp2GPR, StringImpl::flagsOffset()), TrustedImm32(StringImpl::flagIs8Bit()));
 1591 
 1592     m_jit.load8(MacroAssembler::BaseIndex(tempGPR, startIndexGPR, MacroAssembler::TimesOne, 0), tempGPR);
 1593     auto cont8Bit = m_jit.jump();
 1594 
 1595     is16Bit.link(&amp;m_jit);
 1596     m_jit.load16(MacroAssembler::BaseIndex(tempGPR, startIndexGPR, MacroAssembler::TimesTwo, 0), tempGPR);
 1597 
 1598     auto bigCharacter = m_jit.branch32(MacroAssembler::Above, tempGPR, TrustedImm32(maxSingleCharacterString));
 1599 
 1600     // 8 bit string values don&#39;t need the isASCII check.
 1601     cont8Bit.link(&amp;m_jit);
 1602 
 1603     m_jit.lshift32(MacroAssembler::TrustedImm32(sizeof(void*) == 4 ? 2 : 3), tempGPR);
<a name="19" id="anc19"></a><span class="line-modified"> 1604     m_jit.addPtr(TrustedImmPtr(vm.smallStrings.singleCharacterStrings()), tempGPR);</span>
 1605     m_jit.loadPtr(tempGPR, tempGPR);
 1606 
 1607     addSlowPathGenerator(slowPathCall(bigCharacter, this, operationSingleCharacterString, tempGPR, tempGPR));
 1608 
 1609     addSlowPathGenerator(slowPathCall(slowCases, this, operationStringSubstr, tempGPR, stringGPR, startIndexGPR, tempGPR));
 1610 
 1611     if (endGPR)
 1612         addSlowPathGenerator(slowPathCall(isRope, this, operationStringSlice, tempGPR, stringGPR, startGPR, *endGPR));
 1613     else
 1614         addSlowPathGenerator(slowPathCall(isRope, this, operationStringSlice, tempGPR, stringGPR, startGPR, TrustedImm32(std::numeric_limits&lt;int32_t&gt;::max())));
 1615 
 1616     doneCases.link(&amp;m_jit);
 1617     cellResult(tempGPR, node);
 1618 }
 1619 
 1620 void SpeculativeJIT::compileToLowerCase(Node* node)
 1621 {
 1622     ASSERT(node-&gt;op() == ToLowerCase);
 1623     SpeculateCellOperand string(this, node-&gt;child1());
 1624     GPRTemporary temp(this);
 1625     GPRTemporary index(this);
 1626     GPRTemporary charReg(this);
 1627     GPRTemporary length(this);
 1628 
 1629     GPRReg stringGPR = string.gpr();
 1630     GPRReg tempGPR = temp.gpr();
 1631     GPRReg indexGPR = index.gpr();
 1632     GPRReg charGPR = charReg.gpr();
 1633     GPRReg lengthGPR = length.gpr();
 1634 
 1635     speculateString(node-&gt;child1(), stringGPR);
 1636 
 1637     CCallHelpers::JumpList slowPath;
 1638 
 1639     m_jit.move(TrustedImmPtr(nullptr), indexGPR);
 1640 
 1641     m_jit.loadPtr(MacroAssembler::Address(stringGPR, JSString::offsetOfValue()), tempGPR);
 1642     slowPath.append(m_jit.branchIfRopeStringImpl(tempGPR));
 1643     slowPath.append(m_jit.branchTest32(
 1644         MacroAssembler::Zero, MacroAssembler::Address(tempGPR, StringImpl::flagsOffset()),
 1645         MacroAssembler::TrustedImm32(StringImpl::flagIs8Bit())));
 1646     m_jit.load32(MacroAssembler::Address(tempGPR, StringImpl::lengthMemoryOffset()), lengthGPR);
 1647     m_jit.loadPtr(MacroAssembler::Address(tempGPR, StringImpl::dataOffset()), tempGPR);
 1648 
 1649     auto loopStart = m_jit.label();
 1650     auto loopDone = m_jit.branch32(CCallHelpers::AboveOrEqual, indexGPR, lengthGPR);
 1651     m_jit.load8(MacroAssembler::BaseIndex(tempGPR, indexGPR, MacroAssembler::TimesOne), charGPR);
 1652     slowPath.append(m_jit.branchTest32(CCallHelpers::NonZero, charGPR, TrustedImm32(~0x7F)));
 1653     m_jit.sub32(TrustedImm32(&#39;A&#39;), charGPR);
 1654     slowPath.append(m_jit.branch32(CCallHelpers::BelowOrEqual, charGPR, TrustedImm32(&#39;Z&#39; - &#39;A&#39;)));
 1655 
 1656     m_jit.add32(TrustedImm32(1), indexGPR);
 1657     m_jit.jump().linkTo(loopStart, &amp;m_jit);
 1658 
 1659     slowPath.link(&amp;m_jit);
 1660     silentSpillAllRegisters(lengthGPR);
 1661     callOperation(operationToLowerCase, lengthGPR, stringGPR, indexGPR);
 1662     silentFillAllRegisters();
 1663     m_jit.exceptionCheck();
 1664     auto done = m_jit.jump();
 1665 
 1666     loopDone.link(&amp;m_jit);
 1667     m_jit.move(stringGPR, lengthGPR);
 1668 
 1669     done.link(&amp;m_jit);
 1670     cellResult(lengthGPR, node);
 1671 }
 1672 
 1673 void SpeculativeJIT::compilePeepHoleInt32Branch(Node* node, Node* branchNode, JITCompiler::RelationalCondition condition)
 1674 {
 1675     BasicBlock* taken = branchNode-&gt;branchData()-&gt;taken.block;
 1676     BasicBlock* notTaken = branchNode-&gt;branchData()-&gt;notTaken.block;
 1677 
 1678     // The branch instruction will branch to the taken block.
 1679     // If taken is next, switch taken with notTaken &amp; invert the branch condition so we can fall through.
 1680     if (taken == nextBlock()) {
 1681         condition = JITCompiler::invert(condition);
 1682         BasicBlock* tmp = taken;
 1683         taken = notTaken;
 1684         notTaken = tmp;
 1685     }
 1686 
 1687     if (node-&gt;child1()-&gt;isInt32Constant()) {
 1688         int32_t imm = node-&gt;child1()-&gt;asInt32();
 1689         SpeculateInt32Operand op2(this, node-&gt;child2());
 1690         branch32(condition, JITCompiler::Imm32(imm), op2.gpr(), taken);
 1691     } else if (node-&gt;child2()-&gt;isInt32Constant()) {
 1692         SpeculateInt32Operand op1(this, node-&gt;child1());
 1693         int32_t imm = node-&gt;child2()-&gt;asInt32();
 1694         branch32(condition, op1.gpr(), JITCompiler::Imm32(imm), taken);
 1695     } else {
 1696         SpeculateInt32Operand op1(this, node-&gt;child1());
 1697         SpeculateInt32Operand op2(this, node-&gt;child2());
 1698         branch32(condition, op1.gpr(), op2.gpr(), taken);
 1699     }
 1700 
 1701     jump(notTaken);
 1702 }
 1703 
 1704 // Returns true if the compare is fused with a subsequent branch.
 1705 bool SpeculativeJIT::compilePeepHoleBranch(Node* node, MacroAssembler::RelationalCondition condition, MacroAssembler::DoubleCondition doubleCondition, S_JITOperation_EJJ operation)
 1706 {
 1707     // Fused compare &amp; branch.
 1708     unsigned branchIndexInBlock = detectPeepHoleBranch();
 1709     if (branchIndexInBlock != UINT_MAX) {
 1710         Node* branchNode = m_block-&gt;at(branchIndexInBlock);
 1711 
 1712         // detectPeepHoleBranch currently only permits the branch to be the very next node,
 1713         // so can be no intervening nodes to also reference the compare.
 1714         ASSERT(node-&gt;adjustedRefCount() == 1);
 1715 
 1716         if (node-&gt;isBinaryUseKind(Int32Use))
 1717             compilePeepHoleInt32Branch(node, branchNode, condition);
 1718 #if USE(JSVALUE64)
 1719         else if (node-&gt;isBinaryUseKind(Int52RepUse))
 1720             compilePeepHoleInt52Branch(node, branchNode, condition);
 1721 #endif // USE(JSVALUE64)
 1722         else if (node-&gt;isBinaryUseKind(StringUse) || node-&gt;isBinaryUseKind(StringIdentUse)) {
 1723             // Use non-peephole comparison, for now.
 1724             return false;
 1725         } else if (node-&gt;isBinaryUseKind(DoubleRepUse))
 1726             compilePeepHoleDoubleBranch(node, branchNode, doubleCondition);
 1727         else if (node-&gt;op() == CompareEq) {
 1728             if (node-&gt;isBinaryUseKind(BooleanUse))
 1729                 compilePeepHoleBooleanBranch(node, branchNode, condition);
 1730             else if (node-&gt;isBinaryUseKind(SymbolUse))
 1731                 compilePeepHoleSymbolEquality(node, branchNode);
 1732             else if (node-&gt;isBinaryUseKind(ObjectUse))
 1733                 compilePeepHoleObjectEquality(node, branchNode);
 1734             else if (node-&gt;isBinaryUseKind(ObjectUse, ObjectOrOtherUse))
 1735                 compilePeepHoleObjectToObjectOrOtherEquality(node-&gt;child1(), node-&gt;child2(), branchNode);
 1736             else if (node-&gt;isBinaryUseKind(ObjectOrOtherUse, ObjectUse))
 1737                 compilePeepHoleObjectToObjectOrOtherEquality(node-&gt;child2(), node-&gt;child1(), branchNode);
 1738             else if (!needsTypeCheck(node-&gt;child1(), SpecOther))
 1739                 nonSpeculativePeepholeBranchNullOrUndefined(node-&gt;child2(), branchNode);
 1740             else if (!needsTypeCheck(node-&gt;child2(), SpecOther))
 1741                 nonSpeculativePeepholeBranchNullOrUndefined(node-&gt;child1(), branchNode);
 1742             else {
 1743                 nonSpeculativePeepholeBranch(node, branchNode, condition, operation);
 1744                 return true;
 1745             }
 1746         } else {
 1747             nonSpeculativePeepholeBranch(node, branchNode, condition, operation);
 1748             return true;
 1749         }
 1750 
 1751         use(node-&gt;child1());
 1752         use(node-&gt;child2());
 1753         m_indexInBlock = branchIndexInBlock;
 1754         m_currentNode = branchNode;
 1755         return true;
 1756     }
 1757     return false;
 1758 }
 1759 
 1760 void SpeculativeJIT::noticeOSRBirth(Node* node)
 1761 {
 1762     if (!node-&gt;hasVirtualRegister())
 1763         return;
 1764 
 1765     VirtualRegister virtualRegister = node-&gt;virtualRegister();
 1766     GenerationInfo&amp; info = generationInfoFromVirtualRegister(virtualRegister);
 1767 
 1768     info.noticeOSRBirth(*m_stream, node, virtualRegister);
 1769 }
 1770 
 1771 void SpeculativeJIT::compileMovHint(Node* node)
 1772 {
 1773     ASSERT(node-&gt;containsMovHint() &amp;&amp; node-&gt;op() != ZombieHint);
 1774 
 1775     Node* child = node-&gt;child1().node();
 1776     noticeOSRBirth(child);
 1777 
 1778     m_stream-&gt;appendAndLog(VariableEvent::movHint(MinifiedID(child), node-&gt;unlinkedLocal()));
 1779 }
 1780 
 1781 void SpeculativeJIT::bail(AbortReason reason)
 1782 {
 1783     if (verboseCompilationEnabled())
 1784         dataLog(&quot;Bailing compilation.\n&quot;);
 1785     m_compileOkay = true;
 1786     m_jit.abortWithReason(reason, m_lastGeneratedNode);
 1787     clearGenerationInfo();
 1788 }
 1789 
 1790 void SpeculativeJIT::compileCurrentBlock()
 1791 {
 1792     ASSERT(m_compileOkay);
 1793 
 1794     if (!m_block)
 1795         return;
 1796 
 1797     ASSERT(m_block-&gt;isReachable);
 1798 
 1799     m_jit.blockHeads()[m_block-&gt;index] = m_jit.label();
 1800 
 1801     if (!m_block-&gt;intersectionOfCFAHasVisited) {
 1802         // Don&#39;t generate code for basic blocks that are unreachable according to CFA.
 1803         // But to be sure that nobody has generated a jump to this block, drop in a
 1804         // breakpoint here.
 1805         m_jit.abortWithReason(DFGUnreachableBasicBlock);
 1806         return;
 1807     }
 1808 
 1809     if (m_block-&gt;isCatchEntrypoint) {
 1810         m_jit.addPtr(CCallHelpers::TrustedImm32(-(m_jit.graph().frameRegisterCount() * sizeof(Register))), GPRInfo::callFrameRegister,  CCallHelpers::stackPointerRegister);
 1811         if (Options::zeroStackFrame())
 1812             m_jit.clearStackFrame(GPRInfo::callFrameRegister, CCallHelpers::stackPointerRegister, GPRInfo::regT0, m_jit.graph().frameRegisterCount() * sizeof(Register));
 1813         m_jit.emitSaveCalleeSaves();
 1814         m_jit.emitMaterializeTagCheckRegisters();
 1815         m_jit.emitPutToCallFrameHeader(m_jit.codeBlock(), CallFrameSlot::codeBlock);
 1816     }
 1817 
 1818     m_stream-&gt;appendAndLog(VariableEvent::reset());
 1819 
 1820     m_jit.jitAssertHasValidCallFrame();
 1821     m_jit.jitAssertTagsInPlace();
 1822     m_jit.jitAssertArgumentCountSane();
 1823 
 1824     m_state.reset();
 1825     m_state.beginBasicBlock(m_block);
 1826 
 1827     for (size_t i = m_block-&gt;variablesAtHead.size(); i--;) {
 1828         int operand = m_block-&gt;variablesAtHead.operandForIndex(i);
 1829         Node* node = m_block-&gt;variablesAtHead[i];
 1830         if (!node)
 1831             continue; // No need to record dead SetLocal&#39;s.
 1832 
 1833         VariableAccessData* variable = node-&gt;variableAccessData();
 1834         DataFormat format;
 1835         if (!node-&gt;refCount())
 1836             continue; // No need to record dead SetLocal&#39;s.
 1837         format = dataFormatFor(variable-&gt;flushFormat());
 1838         m_stream-&gt;appendAndLog(
 1839             VariableEvent::setLocal(
 1840                 VirtualRegister(operand),
 1841                 variable-&gt;machineLocal(),
 1842                 format));
 1843     }
 1844 
 1845     m_origin = NodeOrigin();
 1846 
 1847     for (m_indexInBlock = 0; m_indexInBlock &lt; m_block-&gt;size(); ++m_indexInBlock) {
 1848         m_currentNode = m_block-&gt;at(m_indexInBlock);
 1849 
 1850         // We may have hit a contradiction that the CFA was aware of but that the JIT
 1851         // didn&#39;t cause directly.
 1852         if (!m_state.isValid()) {
 1853             bail(DFGBailedAtTopOfBlock);
 1854             return;
 1855         }
 1856 
 1857         m_interpreter.startExecuting();
 1858         m_interpreter.executeKnownEdgeTypes(m_currentNode);
 1859         m_jit.setForNode(m_currentNode);
 1860         m_origin = m_currentNode-&gt;origin;
 1861         m_lastGeneratedNode = m_currentNode-&gt;op();
 1862 
 1863         ASSERT(m_currentNode-&gt;shouldGenerate());
 1864 
 1865         if (verboseCompilationEnabled()) {
 1866             dataLogF(
 1867                 &quot;SpeculativeJIT generating Node @%d (bc#%u) at JIT offset 0x%x&quot;,
 1868                 (int)m_currentNode-&gt;index(),
<a name="20" id="anc20"></a><span class="line-modified"> 1869                 m_currentNode-&gt;origin.semantic.bytecodeIndex(), m_jit.debugOffset());</span>
 1870             dataLog(&quot;\n&quot;);
 1871         }
 1872 
 1873         if (Options::validateDFGExceptionHandling() &amp;&amp; (mayExit(m_jit.graph(), m_currentNode) != DoesNotExit || m_currentNode-&gt;isTerminal()))
<a name="21" id="anc21"></a><span class="line-modified"> 1874             m_jit.jitReleaseAssertNoException(m_jit.vm());</span>
 1875 
 1876         m_jit.pcToCodeOriginMapBuilder().appendItem(m_jit.labelIgnoringWatchpoints(), m_origin.semantic);
 1877 
 1878         compile(m_currentNode);
 1879 
 1880         if (belongsInMinifiedGraph(m_currentNode-&gt;op()))
 1881             m_minifiedGraph-&gt;append(MinifiedNode::fromNode(m_currentNode));
 1882 
 1883 #if ENABLE(DFG_REGISTER_ALLOCATION_VALIDATION)
 1884         m_jit.clearRegisterAllocationOffsets();
 1885 #endif
 1886 
 1887         if (!m_compileOkay) {
 1888             bail(DFGBailedAtEndOfNode);
 1889             return;
 1890         }
 1891 
 1892         // Make sure that the abstract state is rematerialized for the next node.
 1893         m_interpreter.executeEffects(m_indexInBlock);
 1894     }
 1895 
 1896     // Perform the most basic verification that children have been used correctly.
 1897     if (!ASSERT_DISABLED) {
 1898         for (auto&amp; info : m_generationInfo)
 1899             RELEASE_ASSERT(!info.alive());
 1900     }
 1901 }
 1902 
 1903 // If we are making type predictions about our arguments then
 1904 // we need to check that they are correct on function entry.
 1905 void SpeculativeJIT::checkArgumentTypes()
 1906 {
 1907     ASSERT(!m_currentNode);
 1908     m_origin = NodeOrigin(CodeOrigin(0), CodeOrigin(0), true);
 1909 
 1910     auto&amp; arguments = m_jit.graph().m_rootToArguments.find(m_jit.graph().block(0))-&gt;value;
 1911     for (int i = 0; i &lt; m_jit.codeBlock()-&gt;numParameters(); ++i) {
 1912         Node* node = arguments[i];
 1913         if (!node) {
 1914             // The argument is dead. We don&#39;t do any checks for such arguments.
 1915             continue;
 1916         }
 1917 
<a name="22" id="anc22"></a><span class="line-modified"> 1918         ASSERT(node-&gt;op() == SetArgumentDefinitely);</span>
 1919         ASSERT(node-&gt;shouldGenerate());
 1920 
 1921         VariableAccessData* variableAccessData = node-&gt;variableAccessData();
 1922         FlushFormat format = variableAccessData-&gt;flushFormat();
 1923 
 1924         if (format == FlushedJSValue)
 1925             continue;
 1926 
 1927         VirtualRegister virtualRegister = variableAccessData-&gt;local();
 1928 
 1929         JSValueSource valueSource = JSValueSource(JITCompiler::addressFor(virtualRegister));
 1930 
 1931 #if USE(JSVALUE64)
 1932         switch (format) {
 1933         case FlushedInt32: {
 1934             speculationCheck(BadType, valueSource, node, m_jit.branch64(MacroAssembler::Below, JITCompiler::addressFor(virtualRegister), GPRInfo::tagTypeNumberRegister));
 1935             break;
 1936         }
 1937         case FlushedBoolean: {
 1938             GPRTemporary temp(this);
 1939             m_jit.load64(JITCompiler::addressFor(virtualRegister), temp.gpr());
 1940             m_jit.xor64(TrustedImm32(static_cast&lt;int32_t&gt;(ValueFalse)), temp.gpr());
 1941             speculationCheck(BadType, valueSource, node, m_jit.branchTest64(MacroAssembler::NonZero, temp.gpr(), TrustedImm32(static_cast&lt;int32_t&gt;(~1))));
 1942             break;
 1943         }
 1944         case FlushedCell: {
 1945             speculationCheck(BadType, valueSource, node, m_jit.branchTest64(MacroAssembler::NonZero, JITCompiler::addressFor(virtualRegister), GPRInfo::tagMaskRegister));
 1946             break;
 1947         }
 1948         default:
 1949             RELEASE_ASSERT_NOT_REACHED();
 1950             break;
 1951         }
 1952 #else
 1953         switch (format) {
 1954         case FlushedInt32: {
 1955             speculationCheck(BadType, valueSource, node, m_jit.branch32(MacroAssembler::NotEqual, JITCompiler::tagFor(virtualRegister), TrustedImm32(JSValue::Int32Tag)));
 1956             break;
 1957         }
 1958         case FlushedBoolean: {
 1959             speculationCheck(BadType, valueSource, node, m_jit.branch32(MacroAssembler::NotEqual, JITCompiler::tagFor(virtualRegister), TrustedImm32(JSValue::BooleanTag)));
 1960             break;
 1961         }
 1962         case FlushedCell: {
 1963             speculationCheck(BadType, valueSource, node, m_jit.branch32(MacroAssembler::NotEqual, JITCompiler::tagFor(virtualRegister), TrustedImm32(JSValue::CellTag)));
 1964             break;
 1965         }
 1966         default:
 1967             RELEASE_ASSERT_NOT_REACHED();
 1968             break;
 1969         }
 1970 #endif
 1971     }
 1972 
 1973     m_origin = NodeOrigin();
 1974 }
 1975 
 1976 bool SpeculativeJIT::compile()
 1977 {
 1978     checkArgumentTypes();
 1979 
 1980     ASSERT(!m_currentNode);
 1981     for (BlockIndex blockIndex = 0; blockIndex &lt; m_jit.graph().numBlocks(); ++blockIndex) {
 1982         m_jit.setForBlockIndex(blockIndex);
 1983         m_block = m_jit.graph().block(blockIndex);
 1984         compileCurrentBlock();
 1985     }
 1986     linkBranches();
 1987     return true;
 1988 }
 1989 
 1990 void SpeculativeJIT::createOSREntries()
 1991 {
 1992     for (BlockIndex blockIndex = 0; blockIndex &lt; m_jit.graph().numBlocks(); ++blockIndex) {
 1993         BasicBlock* block = m_jit.graph().block(blockIndex);
 1994         if (!block)
 1995             continue;
 1996         if (block-&gt;isOSRTarget || block-&gt;isCatchEntrypoint) {
 1997             // Currently we don&#39;t have OSR entry trampolines. We could add them
 1998             // here if need be.
 1999             m_osrEntryHeads.append(m_jit.blockHeads()[blockIndex]);
 2000         }
 2001     }
 2002 }
 2003 
 2004 void SpeculativeJIT::linkOSREntries(LinkBuffer&amp; linkBuffer)
 2005 {
 2006     unsigned osrEntryIndex = 0;
 2007     for (BlockIndex blockIndex = 0; blockIndex &lt; m_jit.graph().numBlocks(); ++blockIndex) {
 2008         BasicBlock* block = m_jit.graph().block(blockIndex);
 2009         if (!block)
 2010             continue;
 2011         if (!block-&gt;isOSRTarget &amp;&amp; !block-&gt;isCatchEntrypoint)
 2012             continue;
 2013         if (block-&gt;isCatchEntrypoint) {
 2014             auto&amp; argumentsVector = m_jit.graph().m_rootToArguments.find(block)-&gt;value;
 2015             Vector&lt;FlushFormat&gt; argumentFormats;
 2016             argumentFormats.reserveInitialCapacity(argumentsVector.size());
 2017             for (Node* setArgument : argumentsVector) {
 2018                 if (setArgument) {
 2019                     FlushFormat flushFormat = setArgument-&gt;variableAccessData()-&gt;flushFormat();
 2020                     ASSERT(flushFormat == FlushedInt32 || flushFormat == FlushedCell || flushFormat == FlushedBoolean || flushFormat == FlushedJSValue);
 2021                     argumentFormats.uncheckedAppend(flushFormat);
 2022                 } else
 2023                     argumentFormats.uncheckedAppend(DeadFlush);
 2024             }
 2025             m_jit.noticeCatchEntrypoint(*block, m_osrEntryHeads[osrEntryIndex++], linkBuffer, WTFMove(argumentFormats));
 2026         } else {
 2027             ASSERT(block-&gt;isOSRTarget);
 2028             m_jit.noticeOSREntry(*block, m_osrEntryHeads[osrEntryIndex++], linkBuffer);
 2029         }
 2030     }
 2031 
 2032     m_jit.jitCode()-&gt;finalizeOSREntrypoints();
 2033     m_jit.jitCode()-&gt;common.finalizeCatchEntrypoints();
 2034 
 2035     ASSERT(osrEntryIndex == m_osrEntryHeads.size());
 2036 
 2037     if (verboseCompilationEnabled()) {
 2038         DumpContext dumpContext;
 2039         dataLog(&quot;OSR Entries:\n&quot;);
 2040         for (OSREntryData&amp; entryData : m_jit.jitCode()-&gt;osrEntry)
 2041             dataLog(&quot;    &quot;, inContext(entryData, &amp;dumpContext), &quot;\n&quot;);
 2042         if (!dumpContext.isEmpty())
 2043             dumpContext.dump(WTF::dataFile());
 2044     }
 2045 }
 2046 
 2047 void SpeculativeJIT::compileCheckTraps(Node* node)
 2048 {
 2049     ASSERT(Options::usePollingTraps());
 2050     GPRTemporary unused(this);
 2051     GPRReg unusedGPR = unused.gpr();
 2052 
 2053     JITCompiler::Jump needTrapHandling = m_jit.branchTest8(JITCompiler::NonZero,
<a name="23" id="anc23"></a><span class="line-modified"> 2054         JITCompiler::AbsoluteAddress(m_jit.vm().needTrapHandlingAddress()));</span>
 2055 
 2056     addSlowPathGenerator(slowPathCall(needTrapHandling, this, operationHandleTraps, unusedGPR));
 2057     noResult(node);
 2058 }
 2059 
 2060 void SpeculativeJIT::compileDoublePutByVal(Node* node, SpeculateCellOperand&amp; base, SpeculateStrictInt32Operand&amp; property)
 2061 {
 2062     Edge child3 = m_jit.graph().varArgChild(node, 2);
 2063     Edge child4 = m_jit.graph().varArgChild(node, 3);
 2064 
 2065     ArrayMode arrayMode = node-&gt;arrayMode();
 2066 
 2067     GPRReg baseReg = base.gpr();
 2068     GPRReg propertyReg = property.gpr();
 2069 
 2070     SpeculateDoubleOperand value(this, child3);
 2071 
 2072     FPRReg valueReg = value.fpr();
 2073 
 2074     DFG_TYPE_CHECK(
 2075         JSValueRegs(), child3, SpecFullRealNumber,
 2076         m_jit.branchIfNaN(valueReg));
 2077 
 2078     if (!m_compileOkay)
 2079         return;
 2080 
 2081     StorageOperand storage(this, child4);
 2082     GPRReg storageReg = storage.gpr();
 2083 
 2084     if (node-&gt;op() == PutByValAlias) {
 2085         // Store the value to the array.
 2086         GPRReg propertyReg = property.gpr();
 2087         FPRReg valueReg = value.fpr();
 2088         m_jit.storeDouble(valueReg, MacroAssembler::BaseIndex(storageReg, propertyReg, MacroAssembler::TimesEight));
 2089 
 2090         noResult(m_currentNode);
 2091         return;
 2092     }
 2093 
 2094     GPRTemporary temporary;
 2095     GPRReg temporaryReg = temporaryRegisterForPutByVal(temporary, node);
 2096 
 2097     MacroAssembler::Jump slowCase;
 2098 
 2099     if (arrayMode.isInBounds()) {
 2100         speculationCheck(
 2101             OutOfBounds, JSValueRegs(), 0,
 2102             m_jit.branch32(MacroAssembler::AboveOrEqual, propertyReg, MacroAssembler::Address(storageReg, Butterfly::offsetOfPublicLength())));
 2103     } else {
 2104         MacroAssembler::Jump inBounds = m_jit.branch32(MacroAssembler::Below, propertyReg, MacroAssembler::Address(storageReg, Butterfly::offsetOfPublicLength()));
 2105 
 2106         slowCase = m_jit.branch32(MacroAssembler::AboveOrEqual, propertyReg, MacroAssembler::Address(storageReg, Butterfly::offsetOfVectorLength()));
 2107 
 2108         if (!arrayMode.isOutOfBounds())
 2109             speculationCheck(OutOfBounds, JSValueRegs(), 0, slowCase);
 2110 
 2111         m_jit.add32(TrustedImm32(1), propertyReg, temporaryReg);
 2112         m_jit.store32(temporaryReg, MacroAssembler::Address(storageReg, Butterfly::offsetOfPublicLength()));
 2113 
 2114         inBounds.link(&amp;m_jit);
 2115     }
 2116 
 2117     m_jit.storeDouble(valueReg, MacroAssembler::BaseIndex(storageReg, propertyReg, MacroAssembler::TimesEight));
 2118 
 2119     base.use();
 2120     property.use();
 2121     value.use();
 2122     storage.use();
 2123 
 2124     if (arrayMode.isOutOfBounds()) {
 2125         addSlowPathGenerator(
 2126             slowPathCall(
 2127                 slowCase, this,
<a name="24" id="anc24"></a><span class="line-modified"> 2128                 m_jit.isStrictModeFor(node-&gt;origin.semantic)</span>
 2129                     ? (node-&gt;op() == PutByValDirect ? operationPutDoubleByValDirectBeyondArrayBoundsStrict : operationPutDoubleByValBeyondArrayBoundsStrict)
 2130                     : (node-&gt;op() == PutByValDirect ? operationPutDoubleByValDirectBeyondArrayBoundsNonStrict : operationPutDoubleByValBeyondArrayBoundsNonStrict),
 2131                 NoResult, baseReg, propertyReg, valueReg));
 2132     }
 2133 
 2134     noResult(m_currentNode, UseChildrenCalledExplicitly);
 2135 }
 2136 
 2137 void SpeculativeJIT::compileGetCharCodeAt(Node* node)
 2138 {
 2139     SpeculateCellOperand string(this, node-&gt;child1());
 2140     SpeculateStrictInt32Operand index(this, node-&gt;child2());
 2141     StorageOperand storage(this, node-&gt;child3());
 2142 
 2143     GPRReg stringReg = string.gpr();
 2144     GPRReg indexReg = index.gpr();
 2145     GPRReg storageReg = storage.gpr();
 2146 
 2147     ASSERT(speculationChecked(m_state.forNode(node-&gt;child1()).m_type, SpecString));
 2148 
 2149     GPRTemporary scratch(this);
 2150     GPRReg scratchReg = scratch.gpr();
 2151 
 2152     m_jit.loadPtr(MacroAssembler::Address(stringReg, JSString::offsetOfValue()), scratchReg);
 2153 
 2154     // unsigned comparison so we can filter out negative indices and indices that are too large
 2155     speculationCheck(Uncountable, JSValueRegs(), 0, m_jit.branch32(MacroAssembler::AboveOrEqual, indexReg, CCallHelpers::Address(scratchReg, StringImpl::lengthMemoryOffset())));
 2156 
 2157     // Load the character into scratchReg
 2158     JITCompiler::Jump is16Bit = m_jit.branchTest32(MacroAssembler::Zero, MacroAssembler::Address(scratchReg, StringImpl::flagsOffset()), TrustedImm32(StringImpl::flagIs8Bit()));
 2159 
 2160     m_jit.load8(MacroAssembler::BaseIndex(storageReg, indexReg, MacroAssembler::TimesOne, 0), scratchReg);
 2161     JITCompiler::Jump cont8Bit = m_jit.jump();
 2162 
 2163     is16Bit.link(&amp;m_jit);
 2164 
 2165     m_jit.load16(MacroAssembler::BaseIndex(storageReg, indexReg, MacroAssembler::TimesTwo, 0), scratchReg);
 2166 
 2167     cont8Bit.link(&amp;m_jit);
 2168 
 2169     int32Result(scratchReg, m_currentNode);
 2170 }
 2171 
 2172 void SpeculativeJIT::compileGetByValOnString(Node* node)
 2173 {
 2174     SpeculateCellOperand base(this, m_graph.child(node, 0));
 2175     SpeculateStrictInt32Operand property(this, m_graph.child(node, 1));
 2176     StorageOperand storage(this, m_graph.child(node, 2));
 2177     GPRReg baseReg = base.gpr();
 2178     GPRReg propertyReg = property.gpr();
 2179     GPRReg storageReg = storage.gpr();
 2180 
 2181     GPRTemporary scratch(this);
 2182     GPRReg scratchReg = scratch.gpr();
 2183 #if USE(JSVALUE32_64)
 2184     GPRTemporary resultTag;
 2185     GPRReg resultTagReg = InvalidGPRReg;
 2186     if (node-&gt;arrayMode().isOutOfBounds()) {
 2187         GPRTemporary realResultTag(this);
 2188         resultTag.adopt(realResultTag);
 2189         resultTagReg = resultTag.gpr();
 2190     }
 2191 #endif
 2192 
 2193     ASSERT(ArrayMode(Array::String, Array::Read).alreadyChecked(m_jit.graph(), node, m_state.forNode(m_graph.child(node, 0))));
 2194 
 2195     // unsigned comparison so we can filter out negative indices and indices that are too large
 2196     m_jit.loadPtr(MacroAssembler::Address(baseReg, JSString::offsetOfValue()), scratchReg);
 2197     JITCompiler::Jump outOfBounds = m_jit.branch32(
 2198         MacroAssembler::AboveOrEqual, propertyReg,
 2199         MacroAssembler::Address(scratchReg, StringImpl::lengthMemoryOffset()));
 2200     if (node-&gt;arrayMode().isInBounds())
 2201         speculationCheck(OutOfBounds, JSValueRegs(), 0, outOfBounds);
 2202 
 2203     // Load the character into scratchReg
 2204     JITCompiler::Jump is16Bit = m_jit.branchTest32(MacroAssembler::Zero, MacroAssembler::Address(scratchReg, StringImpl::flagsOffset()), TrustedImm32(StringImpl::flagIs8Bit()));
 2205 
 2206     m_jit.load8(MacroAssembler::BaseIndex(storageReg, propertyReg, MacroAssembler::TimesOne, 0), scratchReg);
 2207     JITCompiler::Jump cont8Bit = m_jit.jump();
 2208 
 2209     is16Bit.link(&amp;m_jit);
 2210 
 2211     m_jit.load16(MacroAssembler::BaseIndex(storageReg, propertyReg, MacroAssembler::TimesTwo, 0), scratchReg);
 2212 
 2213     JITCompiler::Jump bigCharacter =
 2214         m_jit.branch32(MacroAssembler::Above, scratchReg, TrustedImm32(maxSingleCharacterString));
 2215 
 2216     // 8 bit string values don&#39;t need the isASCII check.
 2217     cont8Bit.link(&amp;m_jit);
 2218 
<a name="25" id="anc25"></a><span class="line-added"> 2219     VM&amp; vm = this-&gt;vm();</span>
 2220     m_jit.lshift32(MacroAssembler::TrustedImm32(sizeof(void*) == 4 ? 2 : 3), scratchReg);
<a name="26" id="anc26"></a><span class="line-modified"> 2221     m_jit.addPtr(TrustedImmPtr(vm.smallStrings.singleCharacterStrings()), scratchReg);</span>
 2222     m_jit.loadPtr(scratchReg, scratchReg);
 2223 
 2224     addSlowPathGenerator(
 2225         slowPathCall(
 2226             bigCharacter, this, operationSingleCharacterString, scratchReg, scratchReg));
 2227 
 2228     if (node-&gt;arrayMode().isOutOfBounds()) {
 2229 #if USE(JSVALUE32_64)
 2230         m_jit.move(TrustedImm32(JSValue::CellTag), resultTagReg);
 2231 #endif
 2232 
 2233         JSGlobalObject* globalObject = m_jit.globalObjectFor(node-&gt;origin.semantic);
<a name="27" id="anc27"></a><span class="line-modified"> 2234         Structure* stringPrototypeStructure = globalObject-&gt;stringPrototype()-&gt;structure(vm);</span>
<span class="line-added"> 2235         Structure* objectPrototypeStructure = globalObject-&gt;objectPrototype()-&gt;structure(vm);</span>
<span class="line-added"> 2236         WTF::loadLoadFence();</span>
<span class="line-added"> 2237 </span>
 2238         if (globalObject-&gt;stringPrototypeChainIsSane()) {
 2239             // FIXME: This could be captured using a Speculation mode that means &quot;out-of-bounds
 2240             // loads return a trivial value&quot;. Something like SaneChainOutOfBounds. This should
 2241             // speculate that we don&#39;t take negative out-of-bounds, or better yet, it should rely
 2242             // on a stringPrototypeChainIsSane() guaranteeing that the prototypes have no negative
 2243             // indexed properties either.
 2244             // https://bugs.webkit.org/show_bug.cgi?id=144668
<a name="28" id="anc28"></a><span class="line-modified"> 2245             m_jit.graph().registerAndWatchStructureTransition(stringPrototypeStructure);</span>
<span class="line-modified"> 2246             m_jit.graph().registerAndWatchStructureTransition(objectPrototypeStructure);</span>
<span class="line-modified"> 2247 </span>


 2248 #if USE(JSVALUE64)
<a name="29" id="anc29"></a><span class="line-modified"> 2249             addSlowPathGenerator(makeUnique&lt;SaneStringGetByValSlowPathGenerator&gt;(</span>
 2250                 outOfBounds, this, JSValueRegs(scratchReg), baseReg, propertyReg));
 2251 #else
<a name="30" id="anc30"></a><span class="line-modified"> 2252             addSlowPathGenerator(makeUnique&lt;SaneStringGetByValSlowPathGenerator&gt;(</span>
 2253                 outOfBounds, this, JSValueRegs(resultTagReg, scratchReg),
 2254                 baseReg, propertyReg));
 2255 #endif
 2256         } else {
 2257 #if USE(JSVALUE64)
 2258             addSlowPathGenerator(
 2259                 slowPathCall(
 2260                     outOfBounds, this, operationGetByValStringInt,
 2261                     scratchReg, baseReg, propertyReg));
 2262 #else
 2263             addSlowPathGenerator(
 2264                 slowPathCall(
 2265                     outOfBounds, this, operationGetByValStringInt,
 2266                     JSValueRegs(resultTagReg, scratchReg), baseReg, propertyReg));
 2267 #endif
 2268         }
 2269 
 2270 #if USE(JSVALUE64)
 2271         jsValueResult(scratchReg, m_currentNode);
 2272 #else
 2273         jsValueResult(resultTagReg, scratchReg, m_currentNode);
 2274 #endif
 2275     } else
 2276         cellResult(scratchReg, m_currentNode);
 2277 }
 2278 
 2279 void SpeculativeJIT::compileFromCharCode(Node* node)
 2280 {
 2281     Edge&amp; child = node-&gt;child1();
 2282     if (child.useKind() == UntypedUse) {
 2283         JSValueOperand opr(this, child);
 2284         JSValueRegs oprRegs = opr.jsValueRegs();
 2285 
 2286         flushRegisters();
 2287         JSValueRegsFlushedCallResult result(this);
 2288         JSValueRegs resultRegs = result.regs();
 2289         callOperation(operationStringFromCharCodeUntyped, resultRegs, oprRegs);
 2290         m_jit.exceptionCheck();
 2291 
 2292         jsValueResult(resultRegs, node);
 2293         return;
 2294     }
 2295 
 2296     SpeculateStrictInt32Operand property(this, child);
 2297     GPRReg propertyReg = property.gpr();
 2298     GPRTemporary smallStrings(this);
 2299     GPRTemporary scratch(this);
 2300     GPRReg scratchReg = scratch.gpr();
 2301     GPRReg smallStringsReg = smallStrings.gpr();
 2302 
 2303     JITCompiler::JumpList slowCases;
<a name="31" id="anc31"></a><span class="line-modified"> 2304     slowCases.append(m_jit.branch32(MacroAssembler::Above, propertyReg, TrustedImm32(maxSingleCharacterString)));</span>
<span class="line-modified"> 2305     m_jit.move(TrustedImmPtr(vm().smallStrings.singleCharacterStrings()), smallStringsReg);</span>
 2306     m_jit.loadPtr(MacroAssembler::BaseIndex(smallStringsReg, propertyReg, MacroAssembler::ScalePtr, 0), scratchReg);
 2307 
 2308     slowCases.append(m_jit.branchTest32(MacroAssembler::Zero, scratchReg));
 2309     addSlowPathGenerator(slowPathCall(slowCases, this, operationStringFromCharCode, scratchReg, propertyReg));
 2310     cellResult(scratchReg, m_currentNode);
 2311 }
 2312 
 2313 GeneratedOperandType SpeculativeJIT::checkGeneratedTypeForToInt32(Node* node)
 2314 {
 2315     VirtualRegister virtualRegister = node-&gt;virtualRegister();
 2316     GenerationInfo&amp; info = generationInfoFromVirtualRegister(virtualRegister);
 2317 
 2318     switch (info.registerFormat()) {
 2319     case DataFormatStorage:
 2320         RELEASE_ASSERT_NOT_REACHED();
 2321 
 2322     case DataFormatBoolean:
 2323     case DataFormatCell:
 2324         terminateSpeculativeExecution(Uncountable, JSValueRegs(), 0);
 2325         return GeneratedOperandTypeUnknown;
 2326 
 2327     case DataFormatNone:
 2328     case DataFormatJSCell:
 2329     case DataFormatJS:
 2330     case DataFormatJSBoolean:
 2331     case DataFormatJSDouble:
 2332         return GeneratedOperandJSValue;
 2333 
 2334     case DataFormatJSInt32:
 2335     case DataFormatInt32:
 2336         return GeneratedOperandInteger;
 2337 
 2338     default:
 2339         RELEASE_ASSERT_NOT_REACHED();
 2340         return GeneratedOperandTypeUnknown;
 2341     }
 2342 }
 2343 
 2344 void SpeculativeJIT::compileValueToInt32(Node* node)
 2345 {
 2346     switch (node-&gt;child1().useKind()) {
 2347 #if USE(JSVALUE64)
 2348     case Int52RepUse: {
 2349         SpeculateStrictInt52Operand op1(this, node-&gt;child1());
 2350         GPRTemporary result(this, Reuse, op1);
 2351         GPRReg op1GPR = op1.gpr();
 2352         GPRReg resultGPR = result.gpr();
 2353         m_jit.zeroExtend32ToPtr(op1GPR, resultGPR);
 2354         int32Result(resultGPR, node, DataFormatInt32);
 2355         return;
 2356     }
 2357 #endif // USE(JSVALUE64)
 2358 
 2359     case DoubleRepUse: {
 2360         GPRTemporary result(this);
 2361         SpeculateDoubleOperand op1(this, node-&gt;child1());
 2362         FPRReg fpr = op1.fpr();
 2363         GPRReg gpr = result.gpr();
 2364 #if CPU(ARM64)
 2365         if (MacroAssemblerARM64::supportsDoubleToInt32ConversionUsingJavaScriptSemantics())
 2366             m_jit.convertDoubleToInt32UsingJavaScriptSemantics(fpr, gpr);
 2367         else
 2368 #endif
 2369         {
 2370             JITCompiler::Jump notTruncatedToInteger = m_jit.branchTruncateDoubleToInt32(fpr, gpr, JITCompiler::BranchIfTruncateFailed);
 2371             addSlowPathGenerator(slowPathCall(notTruncatedToInteger, this,
 2372                 hasSensibleDoubleToInt() ? operationToInt32SensibleSlow : operationToInt32, NeedToSpill, ExceptionCheckRequirement::CheckNotNeeded, gpr, fpr));
 2373         }
 2374         int32Result(gpr, node);
 2375         return;
 2376     }
 2377 
 2378     case NumberUse:
 2379     case NotCellUse: {
 2380         switch (checkGeneratedTypeForToInt32(node-&gt;child1().node())) {
 2381         case GeneratedOperandInteger: {
 2382             SpeculateInt32Operand op1(this, node-&gt;child1(), ManualOperandSpeculation);
 2383             GPRTemporary result(this, Reuse, op1);
 2384             m_jit.move(op1.gpr(), result.gpr());
 2385             int32Result(result.gpr(), node, op1.format());
 2386             return;
 2387         }
 2388         case GeneratedOperandJSValue: {
 2389             GPRTemporary result(this);
 2390 #if USE(JSVALUE64)
 2391             JSValueOperand op1(this, node-&gt;child1(), ManualOperandSpeculation);
 2392 
 2393             GPRReg gpr = op1.gpr();
 2394             GPRReg resultGpr = result.gpr();
 2395             FPRTemporary tempFpr(this);
 2396             FPRReg fpr = tempFpr.fpr();
 2397 
 2398             JITCompiler::Jump isInteger = m_jit.branchIfInt32(gpr);
 2399             JITCompiler::JumpList converted;
 2400 
 2401             if (node-&gt;child1().useKind() == NumberUse) {
 2402                 DFG_TYPE_CHECK(
 2403                     JSValueRegs(gpr), node-&gt;child1(), SpecBytecodeNumber,
 2404                     m_jit.branchIfNotNumber(gpr));
 2405             } else {
 2406                 JITCompiler::Jump isNumber = m_jit.branchIfNumber(gpr);
 2407 
 2408                 DFG_TYPE_CHECK(
 2409                     JSValueRegs(gpr), node-&gt;child1(), ~SpecCellCheck, m_jit.branchIfCell(JSValueRegs(gpr)));
 2410 
 2411                 // It&#39;s not a cell: so true turns into 1 and all else turns into 0.
 2412                 m_jit.compare64(JITCompiler::Equal, gpr, TrustedImm32(ValueTrue), resultGpr);
 2413                 converted.append(m_jit.jump());
 2414 
 2415                 isNumber.link(&amp;m_jit);
 2416             }
 2417 
 2418             // First, if we get here we have a double encoded as a JSValue
 2419             unboxDouble(gpr, resultGpr, fpr);
 2420 #if CPU(ARM64)
 2421             if (MacroAssemblerARM64::supportsDoubleToInt32ConversionUsingJavaScriptSemantics())
 2422                 m_jit.convertDoubleToInt32UsingJavaScriptSemantics(fpr, resultGpr);
 2423             else
 2424 #endif
 2425             {
 2426                 silentSpillAllRegisters(resultGpr);
 2427                 callOperation(operationToInt32, resultGpr, fpr);
 2428                 silentFillAllRegisters();
 2429             }
 2430 
 2431             converted.append(m_jit.jump());
 2432 
 2433             isInteger.link(&amp;m_jit);
 2434             m_jit.zeroExtend32ToPtr(gpr, resultGpr);
 2435 
 2436             converted.link(&amp;m_jit);
 2437 #else
 2438             Node* childNode = node-&gt;child1().node();
 2439             VirtualRegister virtualRegister = childNode-&gt;virtualRegister();
 2440             GenerationInfo&amp; info = generationInfoFromVirtualRegister(virtualRegister);
 2441 
 2442             JSValueOperand op1(this, node-&gt;child1(), ManualOperandSpeculation);
 2443 
 2444             GPRReg payloadGPR = op1.payloadGPR();
 2445             GPRReg resultGpr = result.gpr();
 2446 
 2447             JITCompiler::JumpList converted;
 2448 
 2449             if (info.registerFormat() == DataFormatJSInt32)
 2450                 m_jit.move(payloadGPR, resultGpr);
 2451             else {
 2452                 GPRReg tagGPR = op1.tagGPR();
 2453                 FPRTemporary tempFpr(this);
 2454                 FPRReg fpr = tempFpr.fpr();
 2455                 FPRTemporary scratch(this);
 2456 
 2457                 JITCompiler::Jump isInteger = m_jit.branchIfInt32(tagGPR);
 2458 
 2459                 if (node-&gt;child1().useKind() == NumberUse) {
 2460                     DFG_TYPE_CHECK(
 2461                         op1.jsValueRegs(), node-&gt;child1(), SpecBytecodeNumber,
 2462                         m_jit.branch32(
 2463                             MacroAssembler::AboveOrEqual, tagGPR,
 2464                             TrustedImm32(JSValue::LowestTag)));
 2465                 } else {
 2466                     JITCompiler::Jump isNumber = m_jit.branch32(MacroAssembler::Below, tagGPR, TrustedImm32(JSValue::LowestTag));
 2467 
 2468                     DFG_TYPE_CHECK(
 2469                         op1.jsValueRegs(), node-&gt;child1(), ~SpecCell,
 2470                         m_jit.branchIfCell(op1.jsValueRegs()));
 2471 
 2472                     // It&#39;s not a cell: so true turns into 1 and all else turns into 0.
 2473                     JITCompiler::Jump isBoolean = m_jit.branchIfBoolean(tagGPR, InvalidGPRReg);
 2474                     m_jit.move(TrustedImm32(0), resultGpr);
 2475                     converted.append(m_jit.jump());
 2476 
 2477                     isBoolean.link(&amp;m_jit);
 2478                     m_jit.move(payloadGPR, resultGpr);
 2479                     converted.append(m_jit.jump());
 2480 
 2481                     isNumber.link(&amp;m_jit);
 2482                 }
 2483 
 2484                 unboxDouble(tagGPR, payloadGPR, fpr, scratch.fpr());
 2485 
 2486                 silentSpillAllRegisters(resultGpr);
 2487                 callOperation(operationToInt32, resultGpr, fpr);
 2488                 silentFillAllRegisters();
 2489 
 2490                 converted.append(m_jit.jump());
 2491 
 2492                 isInteger.link(&amp;m_jit);
 2493                 m_jit.move(payloadGPR, resultGpr);
 2494 
 2495                 converted.link(&amp;m_jit);
 2496             }
 2497 #endif
 2498             int32Result(resultGpr, node);
 2499             return;
 2500         }
 2501         case GeneratedOperandTypeUnknown:
 2502             RELEASE_ASSERT(!m_compileOkay);
 2503             return;
 2504         }
 2505         RELEASE_ASSERT_NOT_REACHED();
 2506         return;
 2507     }
 2508 
 2509     default:
 2510         ASSERT(!m_compileOkay);
 2511         return;
 2512     }
 2513 }
 2514 
 2515 void SpeculativeJIT::compileUInt32ToNumber(Node* node)
 2516 {
 2517     if (doesOverflow(node-&gt;arithMode())) {
 2518         if (enableInt52()) {
 2519             SpeculateInt32Operand op1(this, node-&gt;child1());
 2520             GPRTemporary result(this, Reuse, op1);
 2521             m_jit.zeroExtend32ToPtr(op1.gpr(), result.gpr());
 2522             strictInt52Result(result.gpr(), node);
 2523             return;
 2524         }
 2525         SpeculateInt32Operand op1(this, node-&gt;child1());
 2526         FPRTemporary result(this);
 2527 
 2528         GPRReg inputGPR = op1.gpr();
 2529         FPRReg outputFPR = result.fpr();
 2530 
 2531         m_jit.convertInt32ToDouble(inputGPR, outputFPR);
 2532 
 2533         JITCompiler::Jump positive = m_jit.branch32(MacroAssembler::GreaterThanOrEqual, inputGPR, TrustedImm32(0));
 2534         m_jit.addDouble(JITCompiler::AbsoluteAddress(&amp;AssemblyHelpers::twoToThe32), outputFPR);
 2535         positive.link(&amp;m_jit);
 2536 
 2537         doubleResult(outputFPR, node);
 2538         return;
 2539     }
 2540 
 2541     RELEASE_ASSERT(node-&gt;arithMode() == Arith::CheckOverflow);
 2542 
 2543     SpeculateInt32Operand op1(this, node-&gt;child1());
 2544     GPRTemporary result(this);
 2545 
 2546     m_jit.move(op1.gpr(), result.gpr());
 2547 
 2548     speculationCheck(Overflow, JSValueRegs(), 0, m_jit.branch32(MacroAssembler::LessThan, result.gpr(), TrustedImm32(0)));
 2549 
 2550     int32Result(result.gpr(), node, op1.format());
 2551 }
 2552 
 2553 void SpeculativeJIT::compileDoubleAsInt32(Node* node)
 2554 {
 2555     SpeculateDoubleOperand op1(this, node-&gt;child1());
 2556     FPRTemporary scratch(this);
 2557     GPRTemporary result(this);
 2558 
 2559     FPRReg valueFPR = op1.fpr();
 2560     FPRReg scratchFPR = scratch.fpr();
 2561     GPRReg resultGPR = result.gpr();
 2562 
 2563     JITCompiler::JumpList failureCases;
 2564     RELEASE_ASSERT(shouldCheckOverflow(node-&gt;arithMode()));
 2565     m_jit.branchConvertDoubleToInt32(
 2566         valueFPR, resultGPR, failureCases, scratchFPR,
 2567         shouldCheckNegativeZero(node-&gt;arithMode()));
 2568     speculationCheck(Overflow, JSValueRegs(), 0, failureCases);
 2569 
 2570     int32Result(resultGPR, node);
 2571 }
 2572 
 2573 void SpeculativeJIT::compileDoubleRep(Node* node)
 2574 {
 2575     switch (node-&gt;child1().useKind()) {
 2576     case RealNumberUse: {
 2577         JSValueOperand op1(this, node-&gt;child1(), ManualOperandSpeculation);
 2578         FPRTemporary result(this);
 2579 
 2580         JSValueRegs op1Regs = op1.jsValueRegs();
 2581         FPRReg resultFPR = result.fpr();
 2582 
 2583 #if USE(JSVALUE64)
 2584         GPRTemporary temp(this);
 2585         GPRReg tempGPR = temp.gpr();
 2586         m_jit.unboxDoubleWithoutAssertions(op1Regs.gpr(), tempGPR, resultFPR);
 2587 #else
 2588         FPRTemporary temp(this);
 2589         FPRReg tempFPR = temp.fpr();
 2590         unboxDouble(op1Regs.tagGPR(), op1Regs.payloadGPR(), resultFPR, tempFPR);
 2591 #endif
 2592 
 2593         JITCompiler::Jump done = m_jit.branchIfNotNaN(resultFPR);
 2594 
 2595         DFG_TYPE_CHECK(
 2596             op1Regs, node-&gt;child1(), SpecBytecodeRealNumber, m_jit.branchIfNotInt32(op1Regs));
 2597         m_jit.convertInt32ToDouble(op1Regs.payloadGPR(), resultFPR);
 2598 
 2599         done.link(&amp;m_jit);
 2600 
 2601         doubleResult(resultFPR, node);
 2602         return;
 2603     }
 2604 
 2605     case NotCellUse:
 2606     case NumberUse: {
 2607         SpeculatedType possibleTypes = m_state.forNode(node-&gt;child1()).m_type;
 2608         if (isInt32Speculation(possibleTypes)) {
 2609             SpeculateInt32Operand op1(this, node-&gt;child1(), ManualOperandSpeculation);
 2610             FPRTemporary result(this);
 2611             m_jit.convertInt32ToDouble(op1.gpr(), result.fpr());
 2612             doubleResult(result.fpr(), node);
 2613             return;
 2614         }
 2615 
 2616         JSValueOperand op1(this, node-&gt;child1(), ManualOperandSpeculation);
 2617         FPRTemporary result(this);
 2618 
 2619 #if USE(JSVALUE64)
 2620         GPRTemporary temp(this);
 2621 
 2622         GPRReg op1GPR = op1.gpr();
 2623         GPRReg tempGPR = temp.gpr();
 2624         FPRReg resultFPR = result.fpr();
 2625         JITCompiler::JumpList done;
 2626 
 2627         JITCompiler::Jump isInteger = m_jit.branchIfInt32(op1GPR);
 2628 
 2629         if (node-&gt;child1().useKind() == NotCellUse) {
 2630             JITCompiler::Jump isNumber = m_jit.branchIfNumber(op1GPR);
 2631             JITCompiler::Jump isUndefined = m_jit.branchIfUndefined(op1GPR);
 2632 
 2633             static const double zero = 0;
 2634             m_jit.loadDouble(TrustedImmPtr(&amp;zero), resultFPR);
 2635 
 2636             JITCompiler::Jump isNull = m_jit.branchIfNull(op1GPR);
 2637             done.append(isNull);
 2638 
 2639             DFG_TYPE_CHECK(JSValueRegs(op1GPR), node-&gt;child1(), ~SpecCellCheck,
 2640                 m_jit.branchTest64(JITCompiler::Zero, op1GPR, TrustedImm32(static_cast&lt;int32_t&gt;(TagBitBool))));
 2641 
 2642             JITCompiler::Jump isFalse = m_jit.branch64(JITCompiler::Equal, op1GPR, TrustedImm64(ValueFalse));
 2643             static const double one = 1;
 2644             m_jit.loadDouble(TrustedImmPtr(&amp;one), resultFPR);
 2645             done.append(m_jit.jump());
 2646             done.append(isFalse);
 2647 
 2648             isUndefined.link(&amp;m_jit);
 2649             static const double NaN = PNaN;
 2650             m_jit.loadDouble(TrustedImmPtr(&amp;NaN), resultFPR);
 2651             done.append(m_jit.jump());
 2652 
 2653             isNumber.link(&amp;m_jit);
 2654         } else if (needsTypeCheck(node-&gt;child1(), SpecBytecodeNumber)) {
 2655             typeCheck(
 2656                 JSValueRegs(op1GPR), node-&gt;child1(), SpecBytecodeNumber,
 2657                 m_jit.branchIfNotNumber(op1GPR));
 2658         }
 2659 
 2660         unboxDouble(op1GPR, tempGPR, resultFPR);
 2661         done.append(m_jit.jump());
 2662 
 2663         isInteger.link(&amp;m_jit);
 2664         m_jit.convertInt32ToDouble(op1GPR, resultFPR);
 2665         done.link(&amp;m_jit);
 2666 #else // USE(JSVALUE64) -&gt; this is the 32_64 case
 2667         FPRTemporary temp(this);
 2668 
 2669         GPRReg op1TagGPR = op1.tagGPR();
 2670         GPRReg op1PayloadGPR = op1.payloadGPR();
 2671         FPRReg tempFPR = temp.fpr();
 2672         FPRReg resultFPR = result.fpr();
 2673         JITCompiler::JumpList done;
 2674 
 2675         JITCompiler::Jump isInteger = m_jit.branchIfInt32(op1TagGPR);
 2676 
 2677         if (node-&gt;child1().useKind() == NotCellUse) {
 2678             JITCompiler::Jump isNumber = m_jit.branch32(JITCompiler::Below, op1TagGPR, JITCompiler::TrustedImm32(JSValue::LowestTag + 1));
 2679             JITCompiler::Jump isUndefined = m_jit.branchIfUndefined(op1TagGPR);
 2680 
 2681             static const double zero = 0;
 2682             m_jit.loadDouble(TrustedImmPtr(&amp;zero), resultFPR);
 2683 
 2684             JITCompiler::Jump isNull = m_jit.branchIfNull(op1TagGPR);
 2685             done.append(isNull);
 2686 
 2687             DFG_TYPE_CHECK(JSValueRegs(op1TagGPR, op1PayloadGPR), node-&gt;child1(), ~SpecCell, m_jit.branchIfNotBoolean(op1TagGPR, InvalidGPRReg));
 2688 
 2689             JITCompiler::Jump isFalse = m_jit.branchTest32(JITCompiler::Zero, op1PayloadGPR, TrustedImm32(1));
 2690             static const double one = 1;
 2691             m_jit.loadDouble(TrustedImmPtr(&amp;one), resultFPR);
 2692             done.append(m_jit.jump());
 2693             done.append(isFalse);
 2694 
 2695             isUndefined.link(&amp;m_jit);
 2696             static const double NaN = PNaN;
 2697             m_jit.loadDouble(TrustedImmPtr(&amp;NaN), resultFPR);
 2698             done.append(m_jit.jump());
 2699 
 2700             isNumber.link(&amp;m_jit);
 2701         } else if (needsTypeCheck(node-&gt;child1(), SpecBytecodeNumber)) {
 2702             // This check fails with Int32Tag, but it is OK since Int32 case is already excluded.
 2703             typeCheck(
 2704                 JSValueRegs(op1TagGPR, op1PayloadGPR), node-&gt;child1(), SpecBytecodeNumber,
 2705                 m_jit.branch32(MacroAssembler::AboveOrEqual, op1TagGPR, TrustedImm32(JSValue::LowestTag)));
 2706         }
 2707 
 2708         unboxDouble(op1TagGPR, op1PayloadGPR, resultFPR, tempFPR);
 2709         done.append(m_jit.jump());
 2710 
 2711         isInteger.link(&amp;m_jit);
 2712         m_jit.convertInt32ToDouble(op1PayloadGPR, resultFPR);
 2713         done.link(&amp;m_jit);
 2714 #endif // USE(JSVALUE64)
 2715 
 2716         doubleResult(resultFPR, node);
 2717         return;
 2718     }
 2719 
 2720 #if USE(JSVALUE64)
 2721     case Int52RepUse: {
 2722         SpeculateStrictInt52Operand value(this, node-&gt;child1());
 2723         FPRTemporary result(this);
 2724 
 2725         GPRReg valueGPR = value.gpr();
 2726         FPRReg resultFPR = result.fpr();
 2727 
 2728         m_jit.convertInt64ToDouble(valueGPR, resultFPR);
 2729 
 2730         doubleResult(resultFPR, node);
 2731         return;
 2732     }
 2733 #endif // USE(JSVALUE64)
 2734 
 2735     default:
 2736         RELEASE_ASSERT_NOT_REACHED();
 2737         return;
 2738     }
 2739 }
 2740 
 2741 void SpeculativeJIT::compileValueRep(Node* node)
 2742 {
 2743     switch (node-&gt;child1().useKind()) {
 2744     case DoubleRepUse: {
 2745         SpeculateDoubleOperand value(this, node-&gt;child1());
 2746         JSValueRegsTemporary result(this);
 2747 
 2748         FPRReg valueFPR = value.fpr();
 2749         JSValueRegs resultRegs = result.regs();
 2750 
 2751         // It&#39;s very tempting to in-place filter the value to indicate that it&#39;s not impure NaN
 2752         // anymore. Unfortunately, this would be unsound. If it&#39;s a GetLocal or if the value was
 2753         // subject to a prior SetLocal, filtering the value would imply that the corresponding
 2754         // local was purified.
 2755         if (needsTypeCheck(node-&gt;child1(), ~SpecDoubleImpureNaN))
 2756             m_jit.purifyNaN(valueFPR);
 2757 
 2758         boxDouble(valueFPR, resultRegs);
 2759 
 2760         jsValueResult(resultRegs, node);
 2761         return;
 2762     }
 2763 
 2764 #if USE(JSVALUE64)
 2765     case Int52RepUse: {
 2766         SpeculateStrictInt52Operand value(this, node-&gt;child1());
 2767         GPRTemporary result(this);
 2768 
 2769         GPRReg valueGPR = value.gpr();
 2770         GPRReg resultGPR = result.gpr();
 2771 
 2772         boxInt52(valueGPR, resultGPR, DataFormatStrictInt52);
 2773 
 2774         jsValueResult(resultGPR, node);
 2775         return;
 2776     }
 2777 #endif // USE(JSVALUE64)
 2778 
 2779     default:
 2780         RELEASE_ASSERT_NOT_REACHED();
 2781         return;
 2782     }
 2783 }
 2784 
 2785 static double clampDoubleToByte(double d)
 2786 {
 2787     d += 0.5;
 2788     if (!(d &gt; 0))
 2789         d = 0;
 2790     else if (d &gt; 255)
 2791         d = 255;
 2792     return d;
 2793 }
 2794 
 2795 static void compileClampIntegerToByte(JITCompiler&amp; jit, GPRReg result)
 2796 {
 2797     MacroAssembler::Jump inBounds = jit.branch32(MacroAssembler::BelowOrEqual, result, JITCompiler::TrustedImm32(0xff));
 2798     MacroAssembler::Jump tooBig = jit.branch32(MacroAssembler::GreaterThan, result, JITCompiler::TrustedImm32(0xff));
 2799     jit.xorPtr(result, result);
 2800     MacroAssembler::Jump clamped = jit.jump();
 2801     tooBig.link(&amp;jit);
 2802     jit.move(JITCompiler::TrustedImm32(255), result);
 2803     clamped.link(&amp;jit);
 2804     inBounds.link(&amp;jit);
 2805 }
 2806 
 2807 static void compileClampDoubleToByte(JITCompiler&amp; jit, GPRReg result, FPRReg source, FPRReg scratch)
 2808 {
 2809     // Unordered compare so we pick up NaN
 2810     static const double zero = 0;
 2811     static const double byteMax = 255;
 2812     static const double half = 0.5;
 2813     jit.loadDouble(JITCompiler::TrustedImmPtr(&amp;zero), scratch);
 2814     MacroAssembler::Jump tooSmall = jit.branchDouble(MacroAssembler::DoubleLessThanOrEqualOrUnordered, source, scratch);
 2815     jit.loadDouble(JITCompiler::TrustedImmPtr(&amp;byteMax), scratch);
 2816     MacroAssembler::Jump tooBig = jit.branchDouble(MacroAssembler::DoubleGreaterThan, source, scratch);
 2817 
 2818     jit.loadDouble(JITCompiler::TrustedImmPtr(&amp;half), scratch);
 2819     // FIXME: This should probably just use a floating point round!
 2820     // https://bugs.webkit.org/show_bug.cgi?id=72054
 2821     jit.addDouble(source, scratch);
 2822     jit.truncateDoubleToInt32(scratch, result);
 2823     MacroAssembler::Jump truncatedInt = jit.jump();
 2824 
 2825     tooSmall.link(&amp;jit);
 2826     jit.xorPtr(result, result);
 2827     MacroAssembler::Jump zeroed = jit.jump();
 2828 
 2829     tooBig.link(&amp;jit);
 2830     jit.move(JITCompiler::TrustedImm32(255), result);
 2831 
 2832     truncatedInt.link(&amp;jit);
 2833     zeroed.link(&amp;jit);
 2834 
 2835 }
 2836 
 2837 JITCompiler::Jump SpeculativeJIT::jumpForTypedArrayOutOfBounds(Node* node, GPRReg baseGPR, GPRReg indexGPR)
 2838 {
 2839     if (node-&gt;op() == PutByValAlias)
 2840         return JITCompiler::Jump();
 2841     JSArrayBufferView* view = m_jit.graph().tryGetFoldableView(
 2842         m_state.forNode(m_jit.graph().child(node, 0)).m_value, node-&gt;arrayMode());
 2843     if (view) {
 2844         uint32_t length = view-&gt;length();
 2845         Node* indexNode = m_jit.graph().child(node, 1).node();
 2846         if (indexNode-&gt;isInt32Constant() &amp;&amp; indexNode-&gt;asUInt32() &lt; length)
 2847             return JITCompiler::Jump();
 2848         return m_jit.branch32(
 2849             MacroAssembler::AboveOrEqual, indexGPR, MacroAssembler::Imm32(length));
 2850     }
 2851     return m_jit.branch32(
 2852         MacroAssembler::AboveOrEqual, indexGPR,
 2853         MacroAssembler::Address(baseGPR, JSArrayBufferView::offsetOfLength()));
 2854 }
 2855 
 2856 void SpeculativeJIT::emitTypedArrayBoundsCheck(Node* node, GPRReg baseGPR, GPRReg indexGPR)
 2857 {
 2858     JITCompiler::Jump jump = jumpForTypedArrayOutOfBounds(node, baseGPR, indexGPR);
 2859     if (!jump.isSet())
 2860         return;
 2861     speculationCheck(OutOfBounds, JSValueRegs(), 0, jump);
 2862 }
 2863 
 2864 JITCompiler::Jump SpeculativeJIT::jumpForTypedArrayIsNeuteredIfOutOfBounds(Node* node, GPRReg base, JITCompiler::Jump outOfBounds)
 2865 {
 2866     JITCompiler::Jump done;
 2867     if (outOfBounds.isSet()) {
 2868         done = m_jit.jump();
 2869         if (node-&gt;arrayMode().isInBounds())
 2870             speculationCheck(OutOfBounds, JSValueSource(), 0, outOfBounds);
 2871         else {
 2872             outOfBounds.link(&amp;m_jit);
 2873 
 2874             JITCompiler::Jump notWasteful = m_jit.branch32(
 2875                 MacroAssembler::NotEqual,
 2876                 MacroAssembler::Address(base, JSArrayBufferView::offsetOfMode()),
 2877                 TrustedImm32(WastefulTypedArray));
 2878 
<a name="32" id="anc32"></a><span class="line-modified"> 2879             JITCompiler::Jump hasNullVector;</span>
<span class="line-added"> 2880 #if CPU(ARM64E)</span>
<span class="line-added"> 2881             {</span>
<span class="line-added"> 2882                 GPRReg scratch = m_jit.scratchRegister();</span>
<span class="line-added"> 2883                 DisallowMacroScratchRegisterUsage disallowScratch(m_jit);</span>
<span class="line-added"> 2884 </span>
<span class="line-added"> 2885                 m_jit.loadPtr(MacroAssembler::Address(base, JSArrayBufferView::offsetOfVector()), scratch);</span>
<span class="line-added"> 2886                 m_jit.removeArrayPtrTag(scratch);</span>
<span class="line-added"> 2887                 hasNullVector = m_jit.branchTestPtr(MacroAssembler::Zero, scratch);</span>
<span class="line-added"> 2888             }</span>
<span class="line-added"> 2889 #else // CPU(ARM64E)</span>
<span class="line-added"> 2890             hasNullVector = m_jit.branchTestPtr(</span>
 2891                 MacroAssembler::Zero,
 2892                 MacroAssembler::Address(base, JSArrayBufferView::offsetOfVector()));
<a name="33" id="anc33"></a><span class="line-added"> 2893 #endif</span>
 2894             speculationCheck(Uncountable, JSValueSource(), node, hasNullVector);
 2895             notWasteful.link(&amp;m_jit);
 2896         }
 2897     }
 2898     return done;
 2899 }
 2900 
 2901 void SpeculativeJIT::loadFromIntTypedArray(GPRReg storageReg, GPRReg propertyReg, GPRReg resultReg, TypedArrayType type)
 2902 {
 2903     switch (elementSize(type)) {
 2904     case 1:
 2905         if (isSigned(type))
 2906             m_jit.load8SignedExtendTo32(MacroAssembler::BaseIndex(storageReg, propertyReg, MacroAssembler::TimesOne), resultReg);
 2907         else
 2908             m_jit.load8(MacroAssembler::BaseIndex(storageReg, propertyReg, MacroAssembler::TimesOne), resultReg);
 2909         break;
 2910     case 2:
 2911         if (isSigned(type))
 2912             m_jit.load16SignedExtendTo32(MacroAssembler::BaseIndex(storageReg, propertyReg, MacroAssembler::TimesTwo), resultReg);
 2913         else
 2914             m_jit.load16(MacroAssembler::BaseIndex(storageReg, propertyReg, MacroAssembler::TimesTwo), resultReg);
 2915         break;
 2916     case 4:
 2917         m_jit.load32(MacroAssembler::BaseIndex(storageReg, propertyReg, MacroAssembler::TimesFour), resultReg);
 2918         break;
 2919     default:
 2920         CRASH();
 2921     }
 2922 }
 2923 
 2924 void SpeculativeJIT::setIntTypedArrayLoadResult(Node* node, GPRReg resultReg, TypedArrayType type, bool canSpeculate)
 2925 {
 2926     if (elementSize(type) &lt; 4 || isSigned(type)) {
 2927         int32Result(resultReg, node);
 2928         return;
 2929     }
 2930 
 2931     ASSERT(elementSize(type) == 4 &amp;&amp; !isSigned(type));
 2932     if (node-&gt;shouldSpeculateInt32() &amp;&amp; canSpeculate) {
 2933         speculationCheck(Overflow, JSValueRegs(), 0, m_jit.branch32(MacroAssembler::LessThan, resultReg, TrustedImm32(0)));
 2934         int32Result(resultReg, node);
 2935         return;
 2936     }
 2937 
 2938 #if USE(JSVALUE64)
<a name="34" id="anc34"></a><span class="line-modified"> 2939     if (node-&gt;shouldSpeculateInt52()) {</span>
<span class="line-added"> 2940         ASSERT(enableInt52());</span>
 2941         m_jit.zeroExtend32ToPtr(resultReg, resultReg);
 2942         strictInt52Result(resultReg, node);
 2943         return;
 2944     }
 2945 #endif
 2946 
 2947     FPRTemporary fresult(this);
 2948     m_jit.convertInt32ToDouble(resultReg, fresult.fpr());
 2949     JITCompiler::Jump positive = m_jit.branch32(MacroAssembler::GreaterThanOrEqual, resultReg, TrustedImm32(0));
 2950     m_jit.addDouble(JITCompiler::AbsoluteAddress(&amp;AssemblyHelpers::twoToThe32), fresult.fpr());
 2951     positive.link(&amp;m_jit);
 2952     doubleResult(fresult.fpr(), node);
 2953 }
 2954 
 2955 void SpeculativeJIT::compileGetByValOnIntTypedArray(Node* node, TypedArrayType type)
 2956 {
 2957     ASSERT(isInt(type));
 2958 
 2959     SpeculateCellOperand base(this, m_graph.varArgChild(node, 0));
 2960     SpeculateStrictInt32Operand property(this, m_graph.varArgChild(node, 1));
 2961     StorageOperand storage(this, m_graph.varArgChild(node, 2));
 2962 
 2963     GPRReg baseReg = base.gpr();
 2964     GPRReg propertyReg = property.gpr();
 2965     GPRReg storageReg = storage.gpr();
 2966 
 2967     GPRTemporary result(this);
 2968     GPRReg resultReg = result.gpr();
 2969 
<a name="35" id="anc35"></a>

 2970     emitTypedArrayBoundsCheck(node, baseReg, propertyReg);
 2971     loadFromIntTypedArray(storageReg, propertyReg, resultReg, type);
 2972     bool canSpeculate = true;
 2973     setIntTypedArrayLoadResult(node, resultReg, type, canSpeculate);
 2974 }
 2975 
 2976 bool SpeculativeJIT::getIntTypedArrayStoreOperand(
 2977     GPRTemporary&amp; value,
 2978     GPRReg property,
 2979 #if USE(JSVALUE32_64)
 2980     GPRTemporary&amp; propertyTag,
 2981     GPRTemporary&amp; valueTag,
 2982 #endif
 2983     Edge valueUse, JITCompiler::JumpList&amp; slowPathCases, bool isClamped)
 2984 {
 2985     bool isAppropriateConstant = false;
 2986     if (valueUse-&gt;isConstant()) {
 2987         JSValue jsValue = valueUse-&gt;asJSValue();
 2988         SpeculatedType expectedType = typeFilterFor(valueUse.useKind());
 2989         SpeculatedType actualType = speculationFromValue(jsValue);
 2990         isAppropriateConstant = (expectedType | actualType) == expectedType;
 2991     }
 2992 
 2993     if (isAppropriateConstant) {
 2994         JSValue jsValue = valueUse-&gt;asJSValue();
 2995         if (!jsValue.isNumber()) {
 2996             terminateSpeculativeExecution(Uncountable, JSValueRegs(), 0);
 2997             return false;
 2998         }
 2999         double d = jsValue.asNumber();
 3000         if (isClamped)
 3001             d = clampDoubleToByte(d);
 3002         GPRTemporary scratch(this);
 3003         GPRReg scratchReg = scratch.gpr();
 3004         m_jit.move(Imm32(toInt32(d)), scratchReg);
 3005         value.adopt(scratch);
 3006     } else {
 3007         switch (valueUse.useKind()) {
 3008         case Int32Use: {
 3009             SpeculateInt32Operand valueOp(this, valueUse);
 3010             GPRTemporary scratch(this);
 3011             GPRReg scratchReg = scratch.gpr();
 3012             m_jit.move(valueOp.gpr(), scratchReg);
 3013             if (isClamped)
 3014                 compileClampIntegerToByte(m_jit, scratchReg);
 3015             value.adopt(scratch);
 3016             break;
 3017         }
 3018 
 3019 #if USE(JSVALUE64)
 3020         case Int52RepUse: {
 3021             SpeculateStrictInt52Operand valueOp(this, valueUse);
 3022             GPRTemporary scratch(this);
 3023             GPRReg scratchReg = scratch.gpr();
 3024             m_jit.move(valueOp.gpr(), scratchReg);
 3025             if (isClamped) {
 3026                 MacroAssembler::Jump inBounds = m_jit.branch64(
 3027                     MacroAssembler::BelowOrEqual, scratchReg, JITCompiler::TrustedImm64(0xff));
 3028                 MacroAssembler::Jump tooBig = m_jit.branch64(
 3029                     MacroAssembler::GreaterThan, scratchReg, JITCompiler::TrustedImm64(0xff));
 3030                 m_jit.move(TrustedImm32(0), scratchReg);
 3031                 MacroAssembler::Jump clamped = m_jit.jump();
 3032                 tooBig.link(&amp;m_jit);
 3033                 m_jit.move(JITCompiler::TrustedImm32(255), scratchReg);
 3034                 clamped.link(&amp;m_jit);
 3035                 inBounds.link(&amp;m_jit);
 3036             }
 3037             value.adopt(scratch);
 3038             break;
 3039         }
 3040 #endif // USE(JSVALUE64)
 3041 
 3042         case DoubleRepUse: {
 3043             RELEASE_ASSERT(!isAtomicsIntrinsic(m_currentNode-&gt;op()));
 3044             if (isClamped) {
 3045                 SpeculateDoubleOperand valueOp(this, valueUse);
 3046                 GPRTemporary result(this);
 3047                 FPRTemporary floatScratch(this);
 3048                 FPRReg fpr = valueOp.fpr();
 3049                 GPRReg gpr = result.gpr();
 3050                 compileClampDoubleToByte(m_jit, gpr, fpr, floatScratch.fpr());
 3051                 value.adopt(result);
 3052             } else {
 3053 #if USE(JSVALUE32_64)
 3054                 GPRTemporary realPropertyTag(this);
 3055                 propertyTag.adopt(realPropertyTag);
 3056                 GPRReg propertyTagGPR = propertyTag.gpr();
 3057 
 3058                 GPRTemporary realValueTag(this);
 3059                 valueTag.adopt(realValueTag);
 3060                 GPRReg valueTagGPR = valueTag.gpr();
 3061 #endif
 3062                 SpeculateDoubleOperand valueOp(this, valueUse);
 3063                 GPRTemporary result(this);
 3064                 FPRReg fpr = valueOp.fpr();
 3065                 GPRReg gpr = result.gpr();
 3066                 MacroAssembler::Jump notNaN = m_jit.branchIfNotNaN(fpr);
 3067                 m_jit.xorPtr(gpr, gpr);
 3068                 MacroAssembler::JumpList fixed(m_jit.jump());
 3069                 notNaN.link(&amp;m_jit);
 3070 
 3071                 fixed.append(m_jit.branchTruncateDoubleToInt32(
 3072                     fpr, gpr, MacroAssembler::BranchIfTruncateSuccessful));
 3073 
 3074 #if USE(JSVALUE64)
 3075                 m_jit.or64(GPRInfo::tagTypeNumberRegister, property);
 3076                 boxDouble(fpr, gpr);
 3077 #else
 3078                 UNUSED_PARAM(property);
 3079                 m_jit.move(TrustedImm32(JSValue::Int32Tag), propertyTagGPR);
 3080                 boxDouble(fpr, valueTagGPR, gpr);
 3081 #endif
 3082                 slowPathCases.append(m_jit.jump());
 3083 
 3084                 fixed.link(&amp;m_jit);
 3085                 value.adopt(result);
 3086             }
 3087             break;
 3088         }
 3089 
 3090         default:
 3091             RELEASE_ASSERT_NOT_REACHED();
 3092             break;
 3093         }
 3094     }
 3095     return true;
 3096 }
 3097 
 3098 void SpeculativeJIT::compilePutByValForIntTypedArray(GPRReg base, GPRReg property, Node* node, TypedArrayType type)
 3099 {
 3100     ASSERT(isInt(type));
 3101 
 3102     StorageOperand storage(this, m_jit.graph().varArgChild(node, 3));
 3103     GPRReg storageReg = storage.gpr();
 3104 
 3105     Edge valueUse = m_jit.graph().varArgChild(node, 2);
 3106 
 3107     GPRTemporary value;
 3108 #if USE(JSVALUE32_64)
 3109     GPRTemporary propertyTag;
 3110     GPRTemporary valueTag;
 3111 #endif
 3112 
 3113     JITCompiler::JumpList slowPathCases;
 3114 
 3115     bool result = getIntTypedArrayStoreOperand(
 3116         value, property,
 3117 #if USE(JSVALUE32_64)
 3118         propertyTag, valueTag,
 3119 #endif
 3120         valueUse, slowPathCases, isClamped(type));
 3121     if (!result) {
 3122         noResult(node);
 3123         return;
 3124     }
 3125 
 3126     GPRReg valueGPR = value.gpr();
 3127 #if USE(JSVALUE32_64)
 3128     GPRReg propertyTagGPR = propertyTag.gpr();
 3129     GPRReg valueTagGPR = valueTag.gpr();
 3130 #endif
 3131 
 3132     ASSERT_UNUSED(valueGPR, valueGPR != property);
 3133     ASSERT(valueGPR != base);
 3134     ASSERT(valueGPR != storageReg);
 3135     JITCompiler::Jump outOfBounds = jumpForTypedArrayOutOfBounds(node, base, property);
 3136 
 3137     switch (elementSize(type)) {
 3138     case 1:
 3139         m_jit.store8(value.gpr(), MacroAssembler::BaseIndex(storageReg, property, MacroAssembler::TimesOne));
 3140         break;
 3141     case 2:
 3142         m_jit.store16(value.gpr(), MacroAssembler::BaseIndex(storageReg, property, MacroAssembler::TimesTwo));
 3143         break;
 3144     case 4:
 3145         m_jit.store32(value.gpr(), MacroAssembler::BaseIndex(storageReg, property, MacroAssembler::TimesFour));
 3146         break;
 3147     default:
 3148         CRASH();
 3149     }
 3150 
 3151     JITCompiler::Jump done = jumpForTypedArrayIsNeuteredIfOutOfBounds(node, base, outOfBounds);
 3152     if (done.isSet())
 3153         done.link(&amp;m_jit);
 3154 
 3155     if (!slowPathCases.empty()) {
 3156 #if USE(JSVALUE64)
 3157         if (node-&gt;op() == PutByValDirect) {
 3158             addSlowPathGenerator(slowPathCall(
 3159                 slowPathCases, this,
 3160                 m_jit.isStrictModeFor(node-&gt;origin.semantic) ? operationPutByValDirectStrict : operationPutByValDirectNonStrict,
 3161                 NoResult, base, property, valueGPR));
 3162         } else {
 3163             addSlowPathGenerator(slowPathCall(
 3164                 slowPathCases, this,
 3165                 m_jit.isStrictModeFor(node-&gt;origin.semantic) ? operationPutByValStrict : operationPutByValNonStrict,
 3166                 NoResult, base, property, valueGPR));
 3167         }
 3168 #else // not USE(JSVALUE64)
 3169         if (node-&gt;op() == PutByValDirect) {
 3170             addSlowPathGenerator(slowPathCall(
 3171                 slowPathCases, this,
<a name="36" id="anc36"></a><span class="line-modified"> 3172                 m_jit.isStrictModeFor(node-&gt;origin.semantic) ? operationPutByValDirectCellStrict : operationPutByValDirectCellNonStrict,</span>
 3173                 NoResult, base, JSValueRegs(propertyTagGPR, property), JSValueRegs(valueTagGPR, valueGPR)));
 3174         } else {
 3175             addSlowPathGenerator(slowPathCall(
 3176                 slowPathCases, this,
<a name="37" id="anc37"></a><span class="line-modified"> 3177                 m_jit.isStrictModeFor(node-&gt;origin.semantic) ? operationPutByValCellStrict : operationPutByValCellNonStrict,</span>
 3178                 NoResult, base, JSValueRegs(propertyTagGPR, property), JSValueRegs(valueTagGPR, valueGPR)));
 3179         }
 3180 #endif
 3181     }
 3182 
 3183     noResult(node);
 3184 }
 3185 
 3186 void SpeculativeJIT::compileGetByValOnFloatTypedArray(Node* node, TypedArrayType type)
 3187 {
 3188     ASSERT(isFloat(type));
 3189 
 3190     SpeculateCellOperand base(this, m_graph.varArgChild(node, 0));
 3191     SpeculateStrictInt32Operand property(this, m_graph.varArgChild(node, 1));
 3192     StorageOperand storage(this, m_graph.varArgChild(node, 2));
 3193 
 3194     GPRReg baseReg = base.gpr();
 3195     GPRReg propertyReg = property.gpr();
 3196     GPRReg storageReg = storage.gpr();
 3197 
<a name="38" id="anc38"></a>

 3198     FPRTemporary result(this);
 3199     FPRReg resultReg = result.fpr();
 3200     emitTypedArrayBoundsCheck(node, baseReg, propertyReg);
 3201     switch (elementSize(type)) {
 3202     case 4:
 3203         m_jit.loadFloat(MacroAssembler::BaseIndex(storageReg, propertyReg, MacroAssembler::TimesFour), resultReg);
 3204         m_jit.convertFloatToDouble(resultReg, resultReg);
 3205         break;
 3206     case 8: {
 3207         m_jit.loadDouble(MacroAssembler::BaseIndex(storageReg, propertyReg, MacroAssembler::TimesEight), resultReg);
 3208         break;
 3209     }
 3210     default:
 3211         RELEASE_ASSERT_NOT_REACHED();
 3212     }
 3213 
 3214     doubleResult(resultReg, node);
 3215 }
 3216 
 3217 void SpeculativeJIT::compilePutByValForFloatTypedArray(GPRReg base, GPRReg property, Node* node, TypedArrayType type)
 3218 {
 3219     ASSERT(isFloat(type));
 3220 
 3221     StorageOperand storage(this, m_jit.graph().varArgChild(node, 3));
 3222     GPRReg storageReg = storage.gpr();
 3223 
 3224     Edge baseUse = m_jit.graph().varArgChild(node, 0);
 3225     Edge valueUse = m_jit.graph().varArgChild(node, 2);
 3226 
 3227     SpeculateDoubleOperand valueOp(this, valueUse);
 3228     FPRTemporary scratch(this);
 3229     FPRReg valueFPR = valueOp.fpr();
 3230     FPRReg scratchFPR = scratch.fpr();
 3231 
 3232     ASSERT_UNUSED(baseUse, node-&gt;arrayMode().alreadyChecked(m_jit.graph(), node, m_state.forNode(baseUse)));
 3233 
 3234     MacroAssembler::Jump outOfBounds = jumpForTypedArrayOutOfBounds(node, base, property);
 3235 
 3236     switch (elementSize(type)) {
 3237     case 4: {
 3238         m_jit.moveDouble(valueFPR, scratchFPR);
 3239         m_jit.convertDoubleToFloat(valueFPR, scratchFPR);
 3240         m_jit.storeFloat(scratchFPR, MacroAssembler::BaseIndex(storageReg, property, MacroAssembler::TimesFour));
 3241         break;
 3242     }
 3243     case 8:
 3244         m_jit.storeDouble(valueFPR, MacroAssembler::BaseIndex(storageReg, property, MacroAssembler::TimesEight));
 3245         break;
 3246     default:
 3247         RELEASE_ASSERT_NOT_REACHED();
 3248     }
 3249 
 3250     JITCompiler::Jump done = jumpForTypedArrayIsNeuteredIfOutOfBounds(node, base, outOfBounds);
 3251     if (done.isSet())
 3252         done.link(&amp;m_jit);
 3253     noResult(node);
 3254 }
 3255 
 3256 void SpeculativeJIT::compileGetByValForObjectWithString(Node* node)
 3257 {
 3258     SpeculateCellOperand arg1(this, m_graph.varArgChild(node, 0));
 3259     SpeculateCellOperand arg2(this, m_graph.varArgChild(node, 1));
 3260 
 3261     GPRReg arg1GPR = arg1.gpr();
 3262     GPRReg arg2GPR = arg2.gpr();
 3263 
 3264     speculateObject(m_graph.varArgChild(node, 0), arg1GPR);
 3265     speculateString(m_graph.varArgChild(node, 1), arg2GPR);
 3266 
 3267     flushRegisters();
 3268     JSValueRegsFlushedCallResult result(this);
 3269     JSValueRegs resultRegs = result.regs();
 3270     callOperation(operationGetByValObjectString, resultRegs, arg1GPR, arg2GPR);
 3271     m_jit.exceptionCheck();
 3272 
 3273     jsValueResult(resultRegs, node);
 3274 }
 3275 
 3276 void SpeculativeJIT::compileGetByValForObjectWithSymbol(Node* node)
 3277 {
 3278     SpeculateCellOperand arg1(this, m_graph.varArgChild(node, 0));
 3279     SpeculateCellOperand arg2(this, m_graph.varArgChild(node, 1));
 3280 
 3281     GPRReg arg1GPR = arg1.gpr();
 3282     GPRReg arg2GPR = arg2.gpr();
 3283 
 3284     speculateObject(m_graph.varArgChild(node, 0), arg1GPR);
 3285     speculateSymbol(m_graph.varArgChild(node, 1), arg2GPR);
 3286 
 3287     flushRegisters();
 3288     JSValueRegsFlushedCallResult result(this);
 3289     JSValueRegs resultRegs = result.regs();
 3290     callOperation(operationGetByValObjectSymbol, resultRegs, arg1GPR, arg2GPR);
 3291     m_jit.exceptionCheck();
 3292 
 3293     jsValueResult(resultRegs, node);
 3294 }
 3295 
 3296 void SpeculativeJIT::compilePutByValForCellWithString(Node* node, Edge&amp; child1, Edge&amp; child2, Edge&amp; child3)
 3297 {
 3298     SpeculateCellOperand arg1(this, child1);
 3299     SpeculateCellOperand arg2(this, child2);
 3300     JSValueOperand arg3(this, child3);
 3301 
 3302     GPRReg arg1GPR = arg1.gpr();
 3303     GPRReg arg2GPR = arg2.gpr();
 3304     JSValueRegs arg3Regs = arg3.jsValueRegs();
 3305 
 3306     speculateString(child2, arg2GPR);
 3307 
 3308     flushRegisters();
 3309     callOperation(m_jit.isStrictModeFor(node-&gt;origin.semantic) ? operationPutByValCellStringStrict : operationPutByValCellStringNonStrict, arg1GPR, arg2GPR, arg3Regs);
 3310     m_jit.exceptionCheck();
 3311 
 3312     noResult(node);
 3313 }
 3314 
 3315 void SpeculativeJIT::compilePutByValForCellWithSymbol(Node* node, Edge&amp; child1, Edge&amp; child2, Edge&amp; child3)
 3316 {
 3317     SpeculateCellOperand arg1(this, child1);
 3318     SpeculateCellOperand arg2(this, child2);
 3319     JSValueOperand arg3(this, child3);
 3320 
 3321     GPRReg arg1GPR = arg1.gpr();
 3322     GPRReg arg2GPR = arg2.gpr();
 3323     JSValueRegs arg3Regs = arg3.jsValueRegs();
 3324 
 3325     speculateSymbol(child2, arg2GPR);
 3326 
 3327     flushRegisters();
 3328     callOperation(m_jit.isStrictModeFor(node-&gt;origin.semantic) ? operationPutByValCellSymbolStrict : operationPutByValCellSymbolNonStrict, arg1GPR, arg2GPR, arg3Regs);
 3329     m_jit.exceptionCheck();
 3330 
 3331     noResult(node);
 3332 }
 3333 
 3334 void SpeculativeJIT::compileGetByValWithThis(Node* node)
 3335 {
 3336     JSValueOperand base(this, node-&gt;child1());
 3337     JSValueRegs baseRegs = base.jsValueRegs();
 3338     JSValueOperand thisValue(this, node-&gt;child2());
 3339     JSValueRegs thisValueRegs = thisValue.jsValueRegs();
 3340     JSValueOperand subscript(this, node-&gt;child3());
 3341     JSValueRegs subscriptRegs = subscript.jsValueRegs();
 3342 
 3343     flushRegisters();
 3344     JSValueRegsFlushedCallResult result(this);
 3345     JSValueRegs resultRegs = result.regs();
 3346     callOperation(operationGetByValWithThis, resultRegs, baseRegs, thisValueRegs, subscriptRegs);
 3347     m_jit.exceptionCheck();
 3348 
 3349     jsValueResult(resultRegs, node);
 3350 }
 3351 
 3352 void SpeculativeJIT::compileCheckTypeInfoFlags(Node* node)
 3353 {
 3354     SpeculateCellOperand base(this, node-&gt;child1());
 3355 
 3356     GPRReg baseGPR = base.gpr();
 3357 
 3358     // FIXME: This only works for checking if a single bit is set. If we want to check more
 3359     // than one bit at once, we&#39;ll need to fix this:
 3360     // https://bugs.webkit.org/show_bug.cgi?id=185705
 3361     speculationCheck(BadTypeInfoFlags, JSValueRegs(), 0, m_jit.branchTest8(MacroAssembler::Zero, MacroAssembler::Address(baseGPR, JSCell::typeInfoFlagsOffset()), MacroAssembler::TrustedImm32(node-&gt;typeInfoOperand())));
 3362 
 3363     noResult(node);
 3364 }
 3365 
 3366 void SpeculativeJIT::compileParseInt(Node* node)
 3367 {
 3368     RELEASE_ASSERT(node-&gt;child1().useKind() == UntypedUse || node-&gt;child1().useKind() == StringUse);
 3369     if (node-&gt;child2()) {
 3370         SpeculateInt32Operand radix(this, node-&gt;child2());
 3371         GPRReg radixGPR = radix.gpr();
 3372         if (node-&gt;child1().useKind() == UntypedUse) {
 3373             JSValueOperand value(this, node-&gt;child1());
 3374             JSValueRegs valueRegs = value.jsValueRegs();
 3375 
 3376             flushRegisters();
 3377             JSValueRegsFlushedCallResult result(this);
 3378             JSValueRegs resultRegs = result.regs();
 3379             callOperation(operationParseIntGeneric, resultRegs, valueRegs, radixGPR);
 3380             m_jit.exceptionCheck();
 3381             jsValueResult(resultRegs, node);
 3382             return;
 3383         }
 3384 
 3385         SpeculateCellOperand value(this, node-&gt;child1());
 3386         GPRReg valueGPR = value.gpr();
 3387         speculateString(node-&gt;child1(), valueGPR);
 3388 
 3389         flushRegisters();
 3390         JSValueRegsFlushedCallResult result(this);
 3391         JSValueRegs resultRegs = result.regs();
 3392         callOperation(operationParseIntString, resultRegs, valueGPR, radixGPR);
 3393         m_jit.exceptionCheck();
 3394         jsValueResult(resultRegs, node);
 3395         return;
 3396     }
 3397 
 3398     if (node-&gt;child1().useKind() == UntypedUse) {
 3399         JSValueOperand value(this, node-&gt;child1());
 3400         JSValueRegs valueRegs = value.jsValueRegs();
 3401 
 3402         flushRegisters();
 3403         JSValueRegsFlushedCallResult result(this);
 3404         JSValueRegs resultRegs = result.regs();
 3405         callOperation(operationParseIntNoRadixGeneric, resultRegs, valueRegs);
 3406         m_jit.exceptionCheck();
 3407         jsValueResult(resultRegs, node);
 3408         return;
 3409     }
 3410 
 3411     SpeculateCellOperand value(this, node-&gt;child1());
 3412     GPRReg valueGPR = value.gpr();
 3413     speculateString(node-&gt;child1(), valueGPR);
 3414 
 3415     flushRegisters();
 3416     JSValueRegsFlushedCallResult result(this);
 3417     JSValueRegs resultRegs = result.regs();
 3418     callOperation(operationParseIntStringNoRadix, resultRegs, valueGPR);
 3419     m_jit.exceptionCheck();
 3420     jsValueResult(resultRegs, node);
 3421 }
 3422 
 3423 void SpeculativeJIT::compileOverridesHasInstance(Node* node)
 3424 {
 3425     Node* hasInstanceValueNode = node-&gt;child2().node();
 3426     JSFunction* defaultHasInstanceFunction = jsCast&lt;JSFunction*&gt;(node-&gt;cellOperand()-&gt;value());
 3427 
 3428     MacroAssembler::JumpList notDefault;
 3429     SpeculateCellOperand base(this, node-&gt;child1());
 3430     JSValueOperand hasInstanceValue(this, node-&gt;child2());
 3431     GPRTemporary result(this);
 3432 
 3433     GPRReg baseGPR = base.gpr();
 3434     GPRReg resultGPR = result.gpr();
 3435 
 3436     // It would be great if constant folding handled automatically the case where we knew the hasInstance function
 3437     // was a constant. Unfortunately, the folding rule for OverridesHasInstance is in the strength reduction phase
 3438     // since it relies on OSR information. https://bugs.webkit.org/show_bug.cgi?id=154832
 3439     if (!hasInstanceValueNode-&gt;isCellConstant() || defaultHasInstanceFunction != hasInstanceValueNode-&gt;asCell()) {
 3440         JSValueRegs hasInstanceValueRegs = hasInstanceValue.jsValueRegs();
 3441 #if USE(JSVALUE64)
 3442         notDefault.append(m_jit.branchPtr(MacroAssembler::NotEqual, hasInstanceValueRegs.gpr(), TrustedImmPtr(node-&gt;cellOperand())));
 3443 #else
 3444         notDefault.append(m_jit.branchIfNotCell(hasInstanceValueRegs));
 3445         notDefault.append(m_jit.branchPtr(MacroAssembler::NotEqual, hasInstanceValueRegs.payloadGPR(), TrustedImmPtr(node-&gt;cellOperand())));
 3446 #endif
 3447     }
 3448 
 3449     // Check that base &#39;ImplementsDefaultHasInstance&#39;.
 3450     m_jit.test8(MacroAssembler::Zero, MacroAssembler::Address(baseGPR, JSCell::typeInfoFlagsOffset()), MacroAssembler::TrustedImm32(ImplementsDefaultHasInstance), resultGPR);
 3451     MacroAssembler::Jump done = m_jit.jump();
 3452 
 3453     if (!notDefault.empty()) {
 3454         notDefault.link(&amp;m_jit);
 3455         m_jit.move(TrustedImm32(1), resultGPR);
 3456     }
 3457 
 3458     done.link(&amp;m_jit);
 3459     unblessedBooleanResult(resultGPR, node);
 3460 }
 3461 
 3462 void SpeculativeJIT::compileInstanceOfForCells(Node* node, JSValueRegs valueRegs, JSValueRegs prototypeRegs, GPRReg resultGPR, GPRReg scratchGPR, GPRReg scratch2GPR, JITCompiler::Jump slowCase)
 3463 {
 3464     CallSiteIndex callSiteIndex = m_jit.addCallSite(node-&gt;origin.semantic);
 3465 
 3466     JITInstanceOfGenerator gen(
 3467         m_jit.codeBlock(), node-&gt;origin.semantic, callSiteIndex, usedRegisters(), resultGPR,
 3468         valueRegs.payloadGPR(), prototypeRegs.payloadGPR(), scratchGPR, scratch2GPR,
 3469         m_state.forNode(node-&gt;child2()).isType(SpecObject | ~SpecCell));
 3470     gen.generateFastPath(m_jit);
 3471 
 3472     JITCompiler::JumpList slowCases;
 3473     slowCases.append(slowCase);
 3474 
 3475     std::unique_ptr&lt;SlowPathGenerator&gt; slowPath = slowPathCall(
 3476         slowCases, this, operationInstanceOfOptimize, resultGPR, gen.stubInfo(), valueRegs,
 3477         prototypeRegs);
 3478 
 3479     m_jit.addInstanceOf(gen, slowPath.get());
 3480     addSlowPathGenerator(WTFMove(slowPath));
 3481 }
 3482 
 3483 void SpeculativeJIT::compileInstanceOf(Node* node)
 3484 {
 3485 #if USE(JSVALUE64)
 3486     if (node-&gt;child1().useKind() == CellUse
 3487         &amp;&amp; node-&gt;child2().useKind() == CellUse) {
 3488         SpeculateCellOperand value(this, node-&gt;child1());
 3489         SpeculateCellOperand prototype(this, node-&gt;child2());
 3490 
 3491         GPRTemporary result(this);
 3492         GPRTemporary scratch(this);
 3493         GPRTemporary scratch2(this);
 3494 
 3495         GPRReg valueGPR = value.gpr();
 3496         GPRReg prototypeGPR = prototype.gpr();
 3497         GPRReg resultGPR = result.gpr();
 3498         GPRReg scratchGPR = scratch.gpr();
 3499         GPRReg scratch2GPR = scratch2.gpr();
 3500 
 3501         compileInstanceOfForCells(node, JSValueRegs(valueGPR), JSValueRegs(prototypeGPR), resultGPR, scratchGPR, scratch2GPR);
 3502 
 3503         blessedBooleanResult(resultGPR, node);
 3504         return;
 3505     }
 3506 #endif
 3507 
 3508     DFG_ASSERT(m_jit.graph(), node, node-&gt;child1().useKind() == UntypedUse);
 3509     DFG_ASSERT(m_jit.graph(), node, node-&gt;child2().useKind() == UntypedUse);
 3510 
 3511     JSValueOperand value(this, node-&gt;child1());
 3512     JSValueOperand prototype(this, node-&gt;child2());
 3513 
 3514     GPRTemporary result(this);
 3515     GPRTemporary scratch(this);
 3516 
 3517     JSValueRegs valueRegs = value.jsValueRegs();
 3518     JSValueRegs prototypeRegs = prototype.jsValueRegs();
 3519 
 3520     GPRReg resultGPR = result.gpr();
 3521     GPRReg scratchGPR = scratch.gpr();
 3522 
 3523     JITCompiler::Jump isCell = m_jit.branchIfCell(valueRegs);
 3524     moveFalseTo(resultGPR);
 3525 
 3526     JITCompiler::Jump done = m_jit.jump();
 3527 
 3528     isCell.link(&amp;m_jit);
 3529 
 3530     JITCompiler::Jump slowCase = m_jit.branchIfNotCell(prototypeRegs);
 3531 
 3532     compileInstanceOfForCells(node, valueRegs, prototypeRegs, resultGPR, scratchGPR, InvalidGPRReg, slowCase);
 3533 
 3534     done.link(&amp;m_jit);
 3535     blessedBooleanResult(resultGPR, node);
 3536     return;
 3537 }
 3538 
<a name="39" id="anc39"></a><span class="line-modified"> 3539 void SpeculativeJIT::compileValueBitNot(Node* node)</span>
 3540 {
 3541     Edge&amp; child1 = node-&gt;child1();
 3542 
<a name="40" id="anc40"></a><span class="line-modified"> 3543     if (child1.useKind() == BigIntUse) {</span>
<span class="line-modified"> 3544         SpeculateCellOperand operand(this, child1);</span>
<span class="line-modified"> 3545         GPRReg operandGPR = operand.gpr();</span>
<span class="line-added"> 3546 </span>
<span class="line-added"> 3547         speculateBigInt(child1, operandGPR);</span>
 3548 
 3549         flushRegisters();
<a name="41" id="anc41"></a><span class="line-modified"> 3550         GPRFlushedCallResult result(this);</span>
<span class="line-modified"> 3551         GPRReg resultGPR = result.gpr();</span>
<span class="line-modified"> 3552 </span>
<span class="line-added"> 3553         callOperation(operationBitNotBigInt, resultGPR, operandGPR);</span>
 3554         m_jit.exceptionCheck();
<a name="42" id="anc42"></a><span class="line-added"> 3555         cellResult(resultGPR, node);</span>
 3556 
<a name="43" id="anc43"></a>
 3557         return;
 3558     }
 3559 
<a name="44" id="anc44"></a><span class="line-added"> 3560     JSValueOperand operand(this, child1);</span>
<span class="line-added"> 3561     JSValueRegs operandRegs = operand.jsValueRegs();</span>
<span class="line-added"> 3562 </span>
<span class="line-added"> 3563     flushRegisters();</span>
<span class="line-added"> 3564     JSValueRegsFlushedCallResult result(this);</span>
<span class="line-added"> 3565     JSValueRegs resultRegs = result.regs();</span>
<span class="line-added"> 3566     callOperation(operationValueBitNot, resultRegs, operandRegs);</span>
<span class="line-added"> 3567     m_jit.exceptionCheck();</span>
<span class="line-added"> 3568 </span>
<span class="line-added"> 3569     jsValueResult(resultRegs, node);</span>
<span class="line-added"> 3570 }</span>
<span class="line-added"> 3571 </span>
<span class="line-added"> 3572 void SpeculativeJIT::compileBitwiseNot(Node* node)</span>
<span class="line-added"> 3573 {</span>
<span class="line-added"> 3574     Edge&amp; child1 = node-&gt;child1();</span>
<span class="line-added"> 3575 </span>
 3576     SpeculateInt32Operand operand(this, child1);
 3577     GPRTemporary result(this);
 3578     GPRReg resultGPR = result.gpr();
 3579 
 3580     m_jit.move(operand.gpr(), resultGPR);
 3581 
 3582     m_jit.not32(resultGPR);
 3583 
 3584     int32Result(resultGPR, node);
 3585 }
 3586 
 3587 template&lt;typename SnippetGenerator, J_JITOperation_EJJ snippetSlowPathFunction&gt;
 3588 void SpeculativeJIT::emitUntypedBitOp(Node* node)
 3589 {
 3590     Edge&amp; leftChild = node-&gt;child1();
 3591     Edge&amp; rightChild = node-&gt;child2();
 3592 
 3593     if (isKnownNotNumber(leftChild.node()) || isKnownNotNumber(rightChild.node())) {
 3594         JSValueOperand left(this, leftChild);
 3595         JSValueOperand right(this, rightChild);
 3596         JSValueRegs leftRegs = left.jsValueRegs();
 3597         JSValueRegs rightRegs = right.jsValueRegs();
 3598 
 3599         flushRegisters();
 3600         JSValueRegsFlushedCallResult result(this);
 3601         JSValueRegs resultRegs = result.regs();
 3602         callOperation(snippetSlowPathFunction, resultRegs, leftRegs, rightRegs);
 3603         m_jit.exceptionCheck();
 3604 
 3605         jsValueResult(resultRegs, node);
 3606         return;
 3607     }
 3608 
 3609     Optional&lt;JSValueOperand&gt; left;
 3610     Optional&lt;JSValueOperand&gt; right;
 3611 
 3612     JSValueRegs leftRegs;
 3613     JSValueRegs rightRegs;
 3614 
 3615 #if USE(JSVALUE64)
 3616     GPRTemporary result(this);
 3617     JSValueRegs resultRegs = JSValueRegs(result.gpr());
 3618     GPRTemporary scratch(this);
 3619     GPRReg scratchGPR = scratch.gpr();
 3620 #else
 3621     GPRTemporary resultTag(this);
 3622     GPRTemporary resultPayload(this);
 3623     JSValueRegs resultRegs = JSValueRegs(resultPayload.gpr(), resultTag.gpr());
 3624     GPRReg scratchGPR = resultTag.gpr();
 3625 #endif
 3626 
 3627     SnippetOperand leftOperand;
 3628     SnippetOperand rightOperand;
 3629 
 3630     // The snippet generator does not support both operands being constant. If the left
 3631     // operand is already const, we&#39;ll ignore the right operand&#39;s constness.
 3632     if (leftChild-&gt;isInt32Constant())
 3633         leftOperand.setConstInt32(leftChild-&gt;asInt32());
 3634     else if (rightChild-&gt;isInt32Constant())
 3635         rightOperand.setConstInt32(rightChild-&gt;asInt32());
 3636 
 3637     RELEASE_ASSERT(!leftOperand.isConst() || !rightOperand.isConst());
 3638 
 3639     if (!leftOperand.isConst()) {
 3640         left.emplace(this, leftChild);
 3641         leftRegs = left-&gt;jsValueRegs();
 3642     }
 3643     if (!rightOperand.isConst()) {
 3644         right.emplace(this, rightChild);
 3645         rightRegs = right-&gt;jsValueRegs();
 3646     }
 3647 
 3648     SnippetGenerator gen(leftOperand, rightOperand, resultRegs, leftRegs, rightRegs, scratchGPR);
 3649     gen.generateFastPath(m_jit);
 3650 
 3651     ASSERT(gen.didEmitFastPath());
 3652     gen.endJumpList().append(m_jit.jump());
 3653 
 3654     gen.slowPathJumpList().link(&amp;m_jit);
 3655     silentSpillAllRegisters(resultRegs);
 3656 
 3657     if (leftOperand.isConst()) {
 3658         leftRegs = resultRegs;
 3659         m_jit.moveValue(leftChild-&gt;asJSValue(), leftRegs);
 3660     } else if (rightOperand.isConst()) {
 3661         rightRegs = resultRegs;
 3662         m_jit.moveValue(rightChild-&gt;asJSValue(), rightRegs);
 3663     }
 3664 
 3665     callOperation(snippetSlowPathFunction, resultRegs, leftRegs, rightRegs);
 3666 
 3667     silentFillAllRegisters();
 3668     m_jit.exceptionCheck();
 3669 
 3670     gen.endJumpList().link(&amp;m_jit);
 3671     jsValueResult(resultRegs, node);
 3672 }
 3673 
 3674 void SpeculativeJIT::compileValueBitwiseOp(Node* node)
 3675 {
 3676     NodeType op = node-&gt;op();
 3677     Edge&amp; leftChild = node-&gt;child1();
 3678     Edge&amp; rightChild = node-&gt;child2();
 3679 
 3680     if (leftChild.useKind() == UntypedUse || rightChild.useKind() == UntypedUse) {
 3681         switch (op) {
 3682         case ValueBitAnd:
 3683             emitUntypedBitOp&lt;JITBitAndGenerator, operationValueBitAnd&gt;(node);
 3684             return;
 3685         case ValueBitXor:
 3686             emitUntypedBitOp&lt;JITBitXorGenerator, operationValueBitXor&gt;(node);
 3687             return;
 3688         case ValueBitOr:
 3689             emitUntypedBitOp&lt;JITBitOrGenerator, operationValueBitOr&gt;(node);
 3690             return;
 3691         default:
 3692             RELEASE_ASSERT_NOT_REACHED();
 3693         }
 3694     }
 3695 
 3696     ASSERT(leftChild.useKind() == BigIntUse &amp;&amp; rightChild.useKind() == BigIntUse);
 3697 
 3698     SpeculateCellOperand left(this, node-&gt;child1());
 3699     SpeculateCellOperand right(this, node-&gt;child2());
 3700     GPRReg leftGPR = left.gpr();
 3701     GPRReg rightGPR = right.gpr();
 3702 
 3703     speculateBigInt(leftChild, leftGPR);
 3704     speculateBigInt(rightChild, rightGPR);
 3705 
 3706     flushRegisters();
 3707     GPRFlushedCallResult result(this);
 3708     GPRReg resultGPR = result.gpr();
 3709 
 3710     switch (op) {
 3711     case ValueBitAnd:
 3712         callOperation(operationBitAndBigInt, resultGPR, leftGPR, rightGPR);
 3713         break;
 3714     case ValueBitXor:
 3715         callOperation(operationBitXorBigInt, resultGPR, leftGPR, rightGPR);
 3716         break;
 3717     case ValueBitOr:
 3718         callOperation(operationBitOrBigInt, resultGPR, leftGPR, rightGPR);
 3719         break;
 3720     default:
 3721         RELEASE_ASSERT_NOT_REACHED();
 3722     }
 3723 
 3724     m_jit.exceptionCheck();
 3725     cellResult(resultGPR, node);
 3726 }
 3727 
 3728 void SpeculativeJIT::compileBitwiseOp(Node* node)
 3729 {
 3730     NodeType op = node-&gt;op();
 3731     Edge&amp; leftChild = node-&gt;child1();
 3732     Edge&amp; rightChild = node-&gt;child2();
 3733 
 3734     if (leftChild-&gt;isInt32Constant()) {
 3735         SpeculateInt32Operand op2(this, rightChild);
 3736         GPRTemporary result(this, Reuse, op2);
 3737 
 3738         bitOp(op, leftChild-&gt;asInt32(), op2.gpr(), result.gpr());
 3739 
 3740         int32Result(result.gpr(), node);
 3741         return;
 3742     }
 3743 
 3744     if (rightChild-&gt;isInt32Constant()) {
 3745         SpeculateInt32Operand op1(this, leftChild);
 3746         GPRTemporary result(this, Reuse, op1);
 3747 
 3748         bitOp(op, rightChild-&gt;asInt32(), op1.gpr(), result.gpr());
 3749 
 3750         int32Result(result.gpr(), node);
 3751         return;
 3752     }
 3753 
 3754     SpeculateInt32Operand op1(this, leftChild);
 3755     SpeculateInt32Operand op2(this, rightChild);
 3756     GPRTemporary result(this, Reuse, op1, op2);
 3757 
 3758     GPRReg reg1 = op1.gpr();
 3759     GPRReg reg2 = op2.gpr();
 3760     bitOp(op, reg1, reg2, result.gpr());
 3761 
 3762     int32Result(result.gpr(), node);
 3763 }
 3764 
 3765 void SpeculativeJIT::emitUntypedRightShiftBitOp(Node* node)
 3766 {
 3767     J_JITOperation_EJJ snippetSlowPathFunction = node-&gt;op() == BitRShift
 3768         ? operationValueBitRShift : operationValueBitURShift;
 3769     JITRightShiftGenerator::ShiftType shiftType = node-&gt;op() == BitRShift
 3770         ? JITRightShiftGenerator::SignedShift : JITRightShiftGenerator::UnsignedShift;
 3771 
 3772     Edge&amp; leftChild = node-&gt;child1();
 3773     Edge&amp; rightChild = node-&gt;child2();
 3774 
 3775     if (isKnownNotNumber(leftChild.node()) || isKnownNotNumber(rightChild.node())) {
 3776         JSValueOperand left(this, leftChild);
 3777         JSValueOperand right(this, rightChild);
 3778         JSValueRegs leftRegs = left.jsValueRegs();
 3779         JSValueRegs rightRegs = right.jsValueRegs();
 3780 
 3781         flushRegisters();
 3782         JSValueRegsFlushedCallResult result(this);
 3783         JSValueRegs resultRegs = result.regs();
 3784         callOperation(snippetSlowPathFunction, resultRegs, leftRegs, rightRegs);
 3785         m_jit.exceptionCheck();
 3786 
 3787         jsValueResult(resultRegs, node);
 3788         return;
 3789     }
 3790 
 3791     Optional&lt;JSValueOperand&gt; left;
 3792     Optional&lt;JSValueOperand&gt; right;
 3793 
 3794     JSValueRegs leftRegs;
 3795     JSValueRegs rightRegs;
 3796 
 3797     FPRTemporary leftNumber(this);
 3798     FPRReg leftFPR = leftNumber.fpr();
 3799 
 3800 #if USE(JSVALUE64)
 3801     GPRTemporary result(this);
 3802     JSValueRegs resultRegs = JSValueRegs(result.gpr());
 3803     GPRTemporary scratch(this);
 3804     GPRReg scratchGPR = scratch.gpr();
 3805     FPRReg scratchFPR = InvalidFPRReg;
 3806 #else
 3807     GPRTemporary resultTag(this);
 3808     GPRTemporary resultPayload(this);
 3809     JSValueRegs resultRegs = JSValueRegs(resultPayload.gpr(), resultTag.gpr());
 3810     GPRReg scratchGPR = resultTag.gpr();
 3811     FPRTemporary fprScratch(this);
 3812     FPRReg scratchFPR = fprScratch.fpr();
 3813 #endif
 3814 
 3815     SnippetOperand leftOperand;
 3816     SnippetOperand rightOperand;
 3817 
 3818     // The snippet generator does not support both operands being constant. If the left
 3819     // operand is already const, we&#39;ll ignore the right operand&#39;s constness.
 3820     if (leftChild-&gt;isInt32Constant())
 3821         leftOperand.setConstInt32(leftChild-&gt;asInt32());
 3822     else if (rightChild-&gt;isInt32Constant())
 3823         rightOperand.setConstInt32(rightChild-&gt;asInt32());
 3824 
 3825     RELEASE_ASSERT(!leftOperand.isConst() || !rightOperand.isConst());
 3826 
 3827     if (!leftOperand.isConst()) {
 3828         left.emplace(this, leftChild);
 3829         leftRegs = left-&gt;jsValueRegs();
 3830     }
 3831     if (!rightOperand.isConst()) {
 3832         right.emplace(this, rightChild);
 3833         rightRegs = right-&gt;jsValueRegs();
 3834     }
 3835 
 3836     JITRightShiftGenerator gen(leftOperand, rightOperand, resultRegs, leftRegs, rightRegs,
 3837         leftFPR, scratchGPR, scratchFPR, shiftType);
 3838     gen.generateFastPath(m_jit);
 3839 
 3840     ASSERT(gen.didEmitFastPath());
 3841     gen.endJumpList().append(m_jit.jump());
 3842 
 3843     gen.slowPathJumpList().link(&amp;m_jit);
 3844     silentSpillAllRegisters(resultRegs);
 3845 
 3846     if (leftOperand.isConst()) {
 3847         leftRegs = resultRegs;
 3848         m_jit.moveValue(leftChild-&gt;asJSValue(), leftRegs);
 3849     } else if (rightOperand.isConst()) {
 3850         rightRegs = resultRegs;
 3851         m_jit.moveValue(rightChild-&gt;asJSValue(), rightRegs);
 3852     }
 3853 
 3854     callOperation(snippetSlowPathFunction, resultRegs, leftRegs, rightRegs);
 3855 
 3856     silentFillAllRegisters();
 3857     m_jit.exceptionCheck();
 3858 
 3859     gen.endJumpList().link(&amp;m_jit);
 3860     jsValueResult(resultRegs, node);
 3861     return;
 3862 }
 3863 
<a name="45" id="anc45"></a><span class="line-added"> 3864 void SpeculativeJIT::compileValueLShiftOp(Node* node)</span>
<span class="line-added"> 3865 {</span>
<span class="line-added"> 3866     Edge&amp; leftChild = node-&gt;child1();</span>
<span class="line-added"> 3867     Edge&amp; rightChild = node-&gt;child2();</span>
<span class="line-added"> 3868 </span>
<span class="line-added"> 3869     if (node-&gt;binaryUseKind() == BigIntUse) {</span>
<span class="line-added"> 3870         SpeculateCellOperand left(this, leftChild);</span>
<span class="line-added"> 3871         SpeculateCellOperand right(this, rightChild);</span>
<span class="line-added"> 3872         GPRReg leftGPR = left.gpr();</span>
<span class="line-added"> 3873         GPRReg rightGPR = right.gpr();</span>
<span class="line-added"> 3874 </span>
<span class="line-added"> 3875         speculateBigInt(leftChild, leftGPR);</span>
<span class="line-added"> 3876         speculateBigInt(rightChild, rightGPR);</span>
<span class="line-added"> 3877 </span>
<span class="line-added"> 3878         flushRegisters();</span>
<span class="line-added"> 3879         GPRFlushedCallResult result(this);</span>
<span class="line-added"> 3880         GPRReg resultGPR = result.gpr();</span>
<span class="line-added"> 3881 </span>
<span class="line-added"> 3882         callOperation(operationBitLShiftBigInt, resultGPR, leftGPR, rightGPR);</span>
<span class="line-added"> 3883         m_jit.exceptionCheck();</span>
<span class="line-added"> 3884         cellResult(resultGPR, node);</span>
<span class="line-added"> 3885         return;</span>
<span class="line-added"> 3886     }</span>
<span class="line-added"> 3887 </span>
<span class="line-added"> 3888     ASSERT(leftChild.useKind() == UntypedUse &amp;&amp; rightChild.useKind() == UntypedUse);</span>
<span class="line-added"> 3889     emitUntypedBitOp&lt;JITLeftShiftGenerator, operationValueBitLShift&gt;(node);</span>
<span class="line-added"> 3890 }</span>
<span class="line-added"> 3891 </span>
 3892 void SpeculativeJIT::compileShiftOp(Node* node)
 3893 {
 3894     NodeType op = node-&gt;op();
 3895     Edge&amp; leftChild = node-&gt;child1();
 3896     Edge&amp; rightChild = node-&gt;child2();
 3897 
 3898     if (leftChild.useKind() == UntypedUse || rightChild.useKind() == UntypedUse) {
 3899         switch (op) {
<a name="46" id="anc46"></a>


 3900         case BitRShift:
 3901         case BitURShift:
 3902             emitUntypedRightShiftBitOp(node);
 3903             return;
 3904         default:
 3905             RELEASE_ASSERT_NOT_REACHED();
 3906         }
 3907     }
 3908 
 3909     if (rightChild-&gt;isInt32Constant()) {
 3910         SpeculateInt32Operand op1(this, leftChild);
 3911         GPRTemporary result(this, Reuse, op1);
 3912 
 3913         shiftOp(op, op1.gpr(), rightChild-&gt;asInt32() &amp; 0x1f, result.gpr());
 3914 
 3915         int32Result(result.gpr(), node);
 3916     } else {
 3917         // Do not allow shift amount to be used as the result, MacroAssembler does not permit this.
 3918         SpeculateInt32Operand op1(this, leftChild);
 3919         SpeculateInt32Operand op2(this, rightChild);
 3920         GPRTemporary result(this, Reuse, op1);
 3921 
 3922         GPRReg reg1 = op1.gpr();
 3923         GPRReg reg2 = op2.gpr();
 3924         shiftOp(op, reg1, reg2, result.gpr());
 3925 
 3926         int32Result(result.gpr(), node);
 3927     }
 3928 }
 3929 
 3930 void SpeculativeJIT::compileValueAdd(Node* node)
 3931 {
 3932     Edge&amp; leftChild = node-&gt;child1();
 3933     Edge&amp; rightChild = node-&gt;child2();
 3934 
 3935     if (node-&gt;isBinaryUseKind(BigIntUse)) {
 3936         SpeculateCellOperand left(this, node-&gt;child1());
 3937         SpeculateCellOperand right(this, node-&gt;child2());
 3938         GPRReg leftGPR = left.gpr();
 3939         GPRReg rightGPR = right.gpr();
 3940 
 3941         speculateBigInt(leftChild, leftGPR);
 3942         speculateBigInt(rightChild, rightGPR);
 3943 
 3944         flushRegisters();
 3945         GPRFlushedCallResult result(this);
 3946         GPRReg resultGPR = result.gpr();
 3947         callOperation(operationAddBigInt, resultGPR, leftGPR, rightGPR);
 3948         m_jit.exceptionCheck();
 3949 
 3950         cellResult(resultGPR, node);
 3951         return;
 3952     }
 3953 
 3954     if (isKnownNotNumber(leftChild.node()) || isKnownNotNumber(rightChild.node())) {
 3955         JSValueOperand left(this, leftChild);
 3956         JSValueOperand right(this, rightChild);
 3957         JSValueRegs leftRegs = left.jsValueRegs();
 3958         JSValueRegs rightRegs = right.jsValueRegs();
 3959 
 3960         flushRegisters();
 3961         JSValueRegsFlushedCallResult result(this);
 3962         JSValueRegs resultRegs = result.regs();
 3963         callOperation(operationValueAddNotNumber, resultRegs, leftRegs, rightRegs);
 3964         m_jit.exceptionCheck();
 3965 
 3966         jsValueResult(resultRegs, node);
 3967         return;
 3968     }
 3969 
 3970 #if USE(JSVALUE64)
 3971     bool needsScratchGPRReg = true;
 3972     bool needsScratchFPRReg = false;
 3973 #else
 3974     bool needsScratchGPRReg = true;
 3975     bool needsScratchFPRReg = true;
 3976 #endif
 3977 
 3978     CodeBlock* baselineCodeBlock = m_jit.graph().baselineCodeBlockFor(node-&gt;origin.semantic);
<a name="47" id="anc47"></a><span class="line-modified"> 3979     unsigned bytecodeIndex = node-&gt;origin.semantic.bytecodeIndex();</span>
<span class="line-modified"> 3980     ArithProfile* arithProfile = baselineCodeBlock-&gt;arithProfileForBytecodeOffset(bytecodeIndex);</span>
<span class="line-modified"> 3981     JITAddIC* addIC = m_jit.codeBlock()-&gt;addJITAddIC(arithProfile);</span>
 3982     auto repatchingFunction = operationValueAddOptimize;
 3983     auto nonRepatchingFunction = operationValueAdd;
 3984 
 3985     compileMathIC(node, addIC, needsScratchGPRReg, needsScratchFPRReg, repatchingFunction, nonRepatchingFunction);
 3986 }
 3987 
 3988 void SpeculativeJIT::compileValueSub(Node* node)
 3989 {
 3990     Edge&amp; leftChild = node-&gt;child1();
 3991     Edge&amp; rightChild = node-&gt;child2();
 3992 
 3993     if (node-&gt;binaryUseKind() == UntypedUse) {
 3994 #if USE(JSVALUE64)
 3995         bool needsScratchGPRReg = true;
 3996         bool needsScratchFPRReg = false;
 3997 #else
 3998         bool needsScratchGPRReg = true;
 3999         bool needsScratchFPRReg = true;
 4000 #endif
 4001 
 4002         CodeBlock* baselineCodeBlock = m_jit.graph().baselineCodeBlockFor(node-&gt;origin.semantic);
<a name="48" id="anc48"></a><span class="line-modified"> 4003         unsigned bytecodeIndex = node-&gt;origin.semantic.bytecodeIndex();</span>
<span class="line-modified"> 4004         ArithProfile* arithProfile = baselineCodeBlock-&gt;arithProfileForBytecodeOffset(bytecodeIndex);</span>
<span class="line-modified"> 4005         JITSubIC* subIC = m_jit.codeBlock()-&gt;addJITSubIC(arithProfile);</span>
 4006         auto repatchingFunction = operationValueSubOptimize;
 4007         auto nonRepatchingFunction = operationValueSub;
 4008 
 4009         compileMathIC(node, subIC, needsScratchGPRReg, needsScratchFPRReg, repatchingFunction, nonRepatchingFunction);
 4010         return;
 4011     }
 4012 
 4013     ASSERT(leftChild.useKind() == BigIntUse &amp;&amp; rightChild.useKind() == BigIntUse);
 4014 
 4015     SpeculateCellOperand left(this, node-&gt;child1());
 4016     SpeculateCellOperand right(this, node-&gt;child2());
 4017     GPRReg leftGPR = left.gpr();
 4018     GPRReg rightGPR = right.gpr();
 4019 
 4020     speculateBigInt(leftChild, leftGPR);
 4021     speculateBigInt(rightChild, rightGPR);
 4022 
 4023     flushRegisters();
 4024     GPRFlushedCallResult result(this);
 4025     GPRReg resultGPR = result.gpr();
 4026 
 4027     callOperation(operationSubBigInt, resultGPR, leftGPR, rightGPR);
 4028 
 4029     m_jit.exceptionCheck();
 4030     cellResult(resultGPR, node);
 4031 }
 4032 
 4033 template &lt;typename Generator, typename RepatchingFunction, typename NonRepatchingFunction&gt;
 4034 void SpeculativeJIT::compileMathIC(Node* node, JITBinaryMathIC&lt;Generator&gt;* mathIC, bool needsScratchGPRReg, bool needsScratchFPRReg, RepatchingFunction repatchingFunction, NonRepatchingFunction nonRepatchingFunction)
 4035 {
 4036     Edge&amp; leftChild = node-&gt;child1();
 4037     Edge&amp; rightChild = node-&gt;child2();
 4038 
 4039     Optional&lt;JSValueOperand&gt; left;
 4040     Optional&lt;JSValueOperand&gt; right;
 4041 
 4042     JSValueRegs leftRegs;
 4043     JSValueRegs rightRegs;
 4044 
 4045     FPRTemporary leftNumber(this);
 4046     FPRTemporary rightNumber(this);
 4047     FPRReg leftFPR = leftNumber.fpr();
 4048     FPRReg rightFPR = rightNumber.fpr();
 4049 
 4050     GPRReg scratchGPR = InvalidGPRReg;
 4051     FPRReg scratchFPR = InvalidFPRReg;
 4052 
 4053     Optional&lt;FPRTemporary&gt; fprScratch;
 4054     if (needsScratchFPRReg) {
 4055         fprScratch.emplace(this);
 4056         scratchFPR = fprScratch-&gt;fpr();
 4057     }
 4058 
 4059 #if USE(JSVALUE64)
 4060     Optional&lt;GPRTemporary&gt; gprScratch;
 4061     if (needsScratchGPRReg) {
 4062         gprScratch.emplace(this);
 4063         scratchGPR = gprScratch-&gt;gpr();
 4064     }
 4065     GPRTemporary result(this);
 4066     JSValueRegs resultRegs = JSValueRegs(result.gpr());
 4067 #else
 4068     GPRTemporary resultTag(this);
 4069     GPRTemporary resultPayload(this);
 4070     JSValueRegs resultRegs = JSValueRegs(resultPayload.gpr(), resultTag.gpr());
 4071     if (needsScratchGPRReg)
 4072         scratchGPR = resultRegs.tagGPR();
 4073 #endif
 4074 
 4075     SnippetOperand leftOperand(m_state.forNode(leftChild).resultType());
 4076     SnippetOperand rightOperand(m_state.forNode(rightChild).resultType());
 4077 
 4078     // The snippet generator does not support both operands being constant. If the left
 4079     // operand is already const, we&#39;ll ignore the right operand&#39;s constness.
 4080     if (leftChild-&gt;isInt32Constant())
 4081         leftOperand.setConstInt32(leftChild-&gt;asInt32());
 4082     else if (rightChild-&gt;isInt32Constant())
 4083         rightOperand.setConstInt32(rightChild-&gt;asInt32());
 4084 
 4085     ASSERT(!leftOperand.isConst() || !rightOperand.isConst());
 4086     ASSERT(!(Generator::isLeftOperandValidConstant(leftOperand) &amp;&amp; Generator::isRightOperandValidConstant(rightOperand)));
 4087 
 4088     if (!Generator::isLeftOperandValidConstant(leftOperand)) {
 4089         left.emplace(this, leftChild);
 4090         leftRegs = left-&gt;jsValueRegs();
 4091     }
 4092     if (!Generator::isRightOperandValidConstant(rightOperand)) {
 4093         right.emplace(this, rightChild);
 4094         rightRegs = right-&gt;jsValueRegs();
 4095     }
 4096 
 4097 #if ENABLE(MATH_IC_STATS)
 4098     auto inlineStart = m_jit.label();
 4099 #endif
 4100 
 4101     Box&lt;MathICGenerationState&gt; addICGenerationState = Box&lt;MathICGenerationState&gt;::create();
 4102     mathIC-&gt;m_generator = Generator(leftOperand, rightOperand, resultRegs, leftRegs, rightRegs, leftFPR, rightFPR, scratchGPR, scratchFPR);
 4103 
 4104     bool shouldEmitProfiling = false;
 4105     bool generatedInline = mathIC-&gt;generateInline(m_jit, *addICGenerationState, shouldEmitProfiling);
 4106     if (generatedInline) {
 4107         ASSERT(!addICGenerationState-&gt;slowPathJumps.empty());
 4108 
 4109         Vector&lt;SilentRegisterSavePlan&gt; savePlans;
 4110         silentSpillAllRegistersImpl(false, savePlans, resultRegs);
 4111 
 4112         auto done = m_jit.label();
 4113 
 4114         addSlowPathGeneratorLambda([=, savePlans = WTFMove(savePlans)] () {
 4115             addICGenerationState-&gt;slowPathJumps.link(&amp;m_jit);
 4116             addICGenerationState-&gt;slowPathStart = m_jit.label();
 4117 #if ENABLE(MATH_IC_STATS)
 4118             auto slowPathStart = m_jit.label();
 4119 #endif
 4120 
 4121             silentSpill(savePlans);
 4122 
 4123             auto innerLeftRegs = leftRegs;
 4124             auto innerRightRegs = rightRegs;
 4125             if (Generator::isLeftOperandValidConstant(leftOperand)) {
 4126                 innerLeftRegs = resultRegs;
 4127                 m_jit.moveValue(leftChild-&gt;asJSValue(), innerLeftRegs);
 4128             } else if (Generator::isRightOperandValidConstant(rightOperand)) {
 4129                 innerRightRegs = resultRegs;
 4130                 m_jit.moveValue(rightChild-&gt;asJSValue(), innerRightRegs);
 4131             }
 4132 
 4133             if (addICGenerationState-&gt;shouldSlowPathRepatch)
 4134                 addICGenerationState-&gt;slowPathCall = callOperation(bitwise_cast&lt;J_JITOperation_EJJMic&gt;(repatchingFunction), resultRegs, innerLeftRegs, innerRightRegs, TrustedImmPtr(mathIC));
 4135             else
 4136                 addICGenerationState-&gt;slowPathCall = callOperation(nonRepatchingFunction, resultRegs, innerLeftRegs, innerRightRegs);
 4137 
 4138             silentFill(savePlans);
 4139             m_jit.exceptionCheck();
 4140             m_jit.jump().linkTo(done, &amp;m_jit);
 4141 
 4142             m_jit.addLinkTask([=] (LinkBuffer&amp; linkBuffer) {
 4143                 mathIC-&gt;finalizeInlineCode(*addICGenerationState, linkBuffer);
 4144             });
 4145 
 4146 #if ENABLE(MATH_IC_STATS)
 4147             auto slowPathEnd = m_jit.label();
 4148             m_jit.addLinkTask([=] (LinkBuffer&amp; linkBuffer) {
 4149                 size_t size = static_cast&lt;char*&gt;(linkBuffer.locationOf(slowPathEnd).executableAddress()) - static_cast&lt;char*&gt;(linkBuffer.locationOf(slowPathStart).executableAddress());
 4150                 mathIC-&gt;m_generatedCodeSize += size;
 4151             });
 4152 #endif
 4153 
 4154         });
 4155     } else {
 4156         if (Generator::isLeftOperandValidConstant(leftOperand)) {
 4157             left.emplace(this, leftChild);
 4158             leftRegs = left-&gt;jsValueRegs();
 4159         } else if (Generator::isRightOperandValidConstant(rightOperand)) {
 4160             right.emplace(this, rightChild);
 4161             rightRegs = right-&gt;jsValueRegs();
 4162         }
 4163 
 4164         flushRegisters();
 4165         callOperation(nonRepatchingFunction, resultRegs, leftRegs, rightRegs);
 4166         m_jit.exceptionCheck();
 4167     }
 4168 
 4169 #if ENABLE(MATH_IC_STATS)
 4170     auto inlineEnd = m_jit.label();
 4171     m_jit.addLinkTask([=] (LinkBuffer&amp; linkBuffer) {
 4172         size_t size = static_cast&lt;char*&gt;(linkBuffer.locationOf(inlineEnd).executableAddress()) - static_cast&lt;char*&gt;(linkBuffer.locationOf(inlineStart).executableAddress());
 4173         mathIC-&gt;m_generatedCodeSize += size;
 4174     });
 4175 #endif
 4176 
 4177     jsValueResult(resultRegs, node);
 4178     return;
 4179 }
 4180 
 4181 void SpeculativeJIT::compileInstanceOfCustom(Node* node)
 4182 {
 4183     // We could do something smarter here but this case is currently super rare and unless
 4184     // Symbol.hasInstance becomes popular will likely remain that way.
 4185 
 4186     JSValueOperand value(this, node-&gt;child1());
 4187     SpeculateCellOperand constructor(this, node-&gt;child2());
 4188     JSValueOperand hasInstanceValue(this, node-&gt;child3());
 4189     GPRTemporary result(this);
 4190 
 4191     JSValueRegs valueRegs = value.jsValueRegs();
 4192     GPRReg constructorGPR = constructor.gpr();
 4193     JSValueRegs hasInstanceRegs = hasInstanceValue.jsValueRegs();
 4194     GPRReg resultGPR = result.gpr();
 4195 
 4196     MacroAssembler::Jump slowCase = m_jit.jump();
 4197 
 4198     addSlowPathGenerator(slowPathCall(slowCase, this, operationInstanceOfCustom, resultGPR, valueRegs, constructorGPR, hasInstanceRegs));
 4199 
 4200     unblessedBooleanResult(resultGPR, node);
 4201 }
 4202 
 4203 void SpeculativeJIT::compileIsCellWithType(Node* node)
 4204 {
 4205     switch (node-&gt;child1().useKind()) {
 4206     case UntypedUse: {
 4207         JSValueOperand value(this, node-&gt;child1());
 4208         GPRTemporary result(this, Reuse, value, PayloadWord);
 4209 
 4210         JSValueRegs valueRegs = value.jsValueRegs();
 4211         GPRReg resultGPR = result.gpr();
 4212 
 4213         JITCompiler::Jump isNotCell = m_jit.branchIfNotCell(valueRegs);
 4214 
 4215         m_jit.compare8(JITCompiler::Equal,
 4216             JITCompiler::Address(valueRegs.payloadGPR(), JSCell::typeInfoTypeOffset()),
 4217             TrustedImm32(node-&gt;queriedType()),
 4218             resultGPR);
 4219         blessBoolean(resultGPR);
 4220         JITCompiler::Jump done = m_jit.jump();
 4221 
 4222         isNotCell.link(&amp;m_jit);
 4223         moveFalseTo(resultGPR);
 4224 
 4225         done.link(&amp;m_jit);
 4226         blessedBooleanResult(resultGPR, node);
 4227         return;
 4228     }
 4229 
 4230     case CellUse: {
 4231         SpeculateCellOperand cell(this, node-&gt;child1());
 4232         GPRTemporary result(this, Reuse, cell);
 4233 
 4234         GPRReg cellGPR = cell.gpr();
 4235         GPRReg resultGPR = result.gpr();
 4236 
 4237         m_jit.compare8(JITCompiler::Equal,
 4238             JITCompiler::Address(cellGPR, JSCell::typeInfoTypeOffset()),
 4239             TrustedImm32(node-&gt;queriedType()),
 4240             resultGPR);
 4241         blessBoolean(resultGPR);
 4242         blessedBooleanResult(resultGPR, node);
 4243         return;
 4244     }
 4245 
 4246     default:
 4247         RELEASE_ASSERT_NOT_REACHED();
 4248         break;
 4249     }
 4250 }
 4251 
 4252 void SpeculativeJIT::compileIsTypedArrayView(Node* node)
 4253 {
 4254     JSValueOperand value(this, node-&gt;child1());
 4255     GPRTemporary result(this, Reuse, value, PayloadWord);
 4256 
 4257     JSValueRegs valueRegs = value.jsValueRegs();
 4258     GPRReg resultGPR = result.gpr();
 4259 
 4260     JITCompiler::Jump isNotCell = m_jit.branchIfNotCell(valueRegs);
 4261 
 4262     m_jit.load8(JITCompiler::Address(valueRegs.payloadGPR(), JSCell::typeInfoTypeOffset()), resultGPR);
 4263     m_jit.sub32(TrustedImm32(FirstTypedArrayType), resultGPR);
 4264     m_jit.compare32(JITCompiler::Below,
 4265         resultGPR,
 4266         TrustedImm32(NumberOfTypedArrayTypesExcludingDataView),
 4267         resultGPR);
 4268     blessBoolean(resultGPR);
 4269     JITCompiler::Jump done = m_jit.jump();
 4270 
 4271     isNotCell.link(&amp;m_jit);
 4272     moveFalseTo(resultGPR);
 4273 
 4274     done.link(&amp;m_jit);
 4275     blessedBooleanResult(resultGPR, node);
 4276 }
 4277 
 4278 void SpeculativeJIT::compileToObjectOrCallObjectConstructor(Node* node)
 4279 {
 4280     RELEASE_ASSERT(node-&gt;child1().useKind() == UntypedUse);
 4281 
 4282     JSValueOperand value(this, node-&gt;child1());
 4283     GPRTemporary result(this, Reuse, value, PayloadWord);
 4284 
 4285     JSValueRegs valueRegs = value.jsValueRegs();
 4286     GPRReg resultGPR = result.gpr();
 4287 
 4288     MacroAssembler::JumpList slowCases;
 4289     slowCases.append(m_jit.branchIfNotCell(valueRegs));
 4290     slowCases.append(m_jit.branchIfNotObject(valueRegs.payloadGPR()));
 4291     m_jit.move(valueRegs.payloadGPR(), resultGPR);
 4292 
 4293     if (node-&gt;op() == ToObject)
 4294         addSlowPathGenerator(slowPathCall(slowCases, this, operationToObject, resultGPR, m_jit.graph().globalObjectFor(node-&gt;origin.semantic), valueRegs, identifierUID(node-&gt;identifierNumber())));
 4295     else
 4296         addSlowPathGenerator(slowPathCall(slowCases, this, operationCallObjectConstructor, resultGPR, TrustedImmPtr(node-&gt;cellOperand()), valueRegs));
 4297 
 4298     cellResult(resultGPR, node);
 4299 }
 4300 
 4301 void SpeculativeJIT::compileArithAdd(Node* node)
 4302 {
 4303     switch (node-&gt;binaryUseKind()) {
 4304     case Int32Use: {
 4305         ASSERT(!shouldCheckNegativeZero(node-&gt;arithMode()));
 4306 
 4307         if (node-&gt;child2()-&gt;isInt32Constant()) {
 4308             SpeculateInt32Operand op1(this, node-&gt;child1());
 4309             GPRTemporary result(this, Reuse, op1);
 4310 
 4311             GPRReg gpr1 = op1.gpr();
 4312             int32_t imm2 = node-&gt;child2()-&gt;asInt32();
 4313             GPRReg gprResult = result.gpr();
 4314 
 4315             if (!shouldCheckOverflow(node-&gt;arithMode())) {
 4316                 m_jit.add32(Imm32(imm2), gpr1, gprResult);
 4317                 int32Result(gprResult, node);
 4318                 return;
 4319             }
 4320 
 4321             MacroAssembler::Jump check = m_jit.branchAdd32(MacroAssembler::Overflow, gpr1, Imm32(imm2), gprResult);
 4322             if (gpr1 == gprResult) {
 4323                 speculationCheck(Overflow, JSValueRegs(), 0, check,
 4324                     SpeculationRecovery(SpeculativeAddImmediate, gpr1, imm2));
 4325             } else
 4326                 speculationCheck(Overflow, JSValueRegs(), 0, check);
 4327 
 4328             int32Result(gprResult, node);
 4329             return;
 4330         }
 4331 
 4332         SpeculateInt32Operand op1(this, node-&gt;child1());
 4333         SpeculateInt32Operand op2(this, node-&gt;child2());
 4334         GPRTemporary result(this, Reuse, op1, op2);
 4335 
 4336         GPRReg gpr1 = op1.gpr();
 4337         GPRReg gpr2 = op2.gpr();
 4338         GPRReg gprResult = result.gpr();
 4339 
 4340         if (!shouldCheckOverflow(node-&gt;arithMode()))
 4341             m_jit.add32(gpr1, gpr2, gprResult);
 4342         else {
 4343             MacroAssembler::Jump check = m_jit.branchAdd32(MacroAssembler::Overflow, gpr1, gpr2, gprResult);
 4344 
<a name="49" id="anc49"></a><span class="line-modified"> 4345             if (gpr1 == gprResult &amp;&amp; gpr2 == gprResult)</span>
<span class="line-added"> 4346                 speculationCheck(Overflow, JSValueRegs(), 0, check, SpeculationRecovery(SpeculativeAddSelf, gprResult, gpr2));</span>
<span class="line-added"> 4347             else if (gpr1 == gprResult)</span>
 4348                 speculationCheck(Overflow, JSValueRegs(), 0, check, SpeculationRecovery(SpeculativeAdd, gprResult, gpr2));
 4349             else if (gpr2 == gprResult)
 4350                 speculationCheck(Overflow, JSValueRegs(), 0, check, SpeculationRecovery(SpeculativeAdd, gprResult, gpr1));
 4351             else
 4352                 speculationCheck(Overflow, JSValueRegs(), 0, check);
 4353         }
 4354 
 4355         int32Result(gprResult, node);
 4356         return;
 4357     }
 4358 
 4359 #if USE(JSVALUE64)
 4360     case Int52RepUse: {
 4361         ASSERT(shouldCheckOverflow(node-&gt;arithMode()));
 4362         ASSERT(!shouldCheckNegativeZero(node-&gt;arithMode()));
 4363 
 4364         // Will we need an overflow check? If we can prove that neither input can be
 4365         // Int52 then the overflow check will not be necessary.
<a name="50" id="anc50"></a><span class="line-modified"> 4366         if (!m_state.forNode(node-&gt;child1()).couldBeType(SpecNonInt32AsInt52)</span>
<span class="line-modified"> 4367             &amp;&amp; !m_state.forNode(node-&gt;child2()).couldBeType(SpecNonInt32AsInt52)) {</span>
 4368             SpeculateWhicheverInt52Operand op1(this, node-&gt;child1());
 4369             SpeculateWhicheverInt52Operand op2(this, node-&gt;child2(), op1);
 4370             GPRTemporary result(this, Reuse, op1);
 4371             m_jit.add64(op1.gpr(), op2.gpr(), result.gpr());
 4372             int52Result(result.gpr(), node, op1.format());
 4373             return;
 4374         }
 4375 
 4376         SpeculateInt52Operand op1(this, node-&gt;child1());
 4377         SpeculateInt52Operand op2(this, node-&gt;child2());
 4378         GPRTemporary result(this);
 4379         m_jit.move(op1.gpr(), result.gpr());
 4380         speculationCheck(
 4381             Int52Overflow, JSValueRegs(), 0,
 4382             m_jit.branchAdd64(MacroAssembler::Overflow, op2.gpr(), result.gpr()));
 4383         int52Result(result.gpr(), node);
 4384         return;
 4385     }
 4386 #endif // USE(JSVALUE64)
 4387 
 4388     case DoubleRepUse: {
 4389         SpeculateDoubleOperand op1(this, node-&gt;child1());
 4390         SpeculateDoubleOperand op2(this, node-&gt;child2());
 4391         FPRTemporary result(this, op1, op2);
 4392 
 4393         FPRReg reg1 = op1.fpr();
 4394         FPRReg reg2 = op2.fpr();
 4395         m_jit.addDouble(reg1, reg2, result.fpr());
 4396 
 4397         doubleResult(result.fpr(), node);
 4398         return;
 4399     }
 4400 
 4401     default:
 4402         RELEASE_ASSERT_NOT_REACHED();
 4403         break;
 4404     }
 4405 }
 4406 
 4407 void SpeculativeJIT::compileArithAbs(Node* node)
 4408 {
 4409     switch (node-&gt;child1().useKind()) {
 4410     case Int32Use: {
 4411         SpeculateStrictInt32Operand op1(this, node-&gt;child1());
 4412         GPRTemporary result(this, Reuse, op1);
 4413         GPRTemporary scratch(this);
 4414 
 4415         m_jit.move(op1.gpr(), result.gpr());
 4416         m_jit.rshift32(result.gpr(), MacroAssembler::TrustedImm32(31), scratch.gpr());
 4417         m_jit.add32(scratch.gpr(), result.gpr());
 4418         m_jit.xor32(scratch.gpr(), result.gpr());
 4419         if (shouldCheckOverflow(node-&gt;arithMode()))
 4420             speculationCheck(Overflow, JSValueRegs(), 0, m_jit.branchTest32(MacroAssembler::Signed, result.gpr()));
 4421         int32Result(result.gpr(), node);
 4422         break;
 4423     }
 4424 
 4425     case DoubleRepUse: {
 4426         SpeculateDoubleOperand op1(this, node-&gt;child1());
 4427         FPRTemporary result(this);
 4428 
 4429         m_jit.absDouble(op1.fpr(), result.fpr());
 4430         doubleResult(result.fpr(), node);
 4431         break;
 4432     }
 4433 
 4434     default: {
 4435         DFG_ASSERT(m_jit.graph(), node, node-&gt;child1().useKind() == UntypedUse, node-&gt;child1().useKind());
 4436         JSValueOperand op1(this, node-&gt;child1());
 4437         JSValueRegs op1Regs = op1.jsValueRegs();
 4438         flushRegisters();
 4439         FPRResult result(this);
 4440         callOperation(operationArithAbs, result.fpr(), op1Regs);
 4441         m_jit.exceptionCheck();
 4442         doubleResult(result.fpr(), node);
 4443         break;
 4444     }
 4445     }
 4446 }
 4447 
 4448 void SpeculativeJIT::compileArithClz32(Node* node)
 4449 {
 4450     if (node-&gt;child1().useKind() == Int32Use || node-&gt;child1().useKind() == KnownInt32Use) {
 4451         SpeculateInt32Operand value(this, node-&gt;child1());
 4452         GPRTemporary result(this, Reuse, value);
 4453         GPRReg valueReg = value.gpr();
 4454         GPRReg resultReg = result.gpr();
 4455         m_jit.countLeadingZeros32(valueReg, resultReg);
 4456         int32Result(resultReg, node);
 4457         return;
 4458     }
 4459     JSValueOperand op1(this, node-&gt;child1());
 4460     JSValueRegs op1Regs = op1.jsValueRegs();
 4461     GPRTemporary result(this);
 4462     GPRReg resultReg = result.gpr();
 4463     flushRegisters();
 4464     callOperation(operationArithClz32, resultReg, op1Regs);
 4465     m_jit.exceptionCheck();
 4466     int32Result(resultReg, node);
 4467 }
 4468 
 4469 void SpeculativeJIT::compileArithDoubleUnaryOp(Node* node, double (*doubleFunction)(double), double (*operation)(ExecState*, EncodedJSValue))
 4470 {
 4471     if (node-&gt;child1().useKind() == DoubleRepUse) {
 4472         SpeculateDoubleOperand op1(this, node-&gt;child1());
 4473         FPRReg op1FPR = op1.fpr();
 4474 
 4475         flushRegisters();
 4476 
 4477         FPRResult result(this);
 4478         callOperation(doubleFunction, result.fpr(), op1FPR);
 4479 
 4480         doubleResult(result.fpr(), node);
 4481         return;
 4482     }
 4483 
 4484     JSValueOperand op1(this, node-&gt;child1());
 4485     JSValueRegs op1Regs = op1.jsValueRegs();
 4486     flushRegisters();
 4487     FPRResult result(this);
 4488     callOperation(operation, result.fpr(), op1Regs);
 4489     m_jit.exceptionCheck();
 4490     doubleResult(result.fpr(), node);
 4491 }
 4492 
 4493 void SpeculativeJIT::compileArithSub(Node* node)
 4494 {
 4495     switch (node-&gt;binaryUseKind()) {
 4496     case Int32Use: {
 4497         ASSERT(!shouldCheckNegativeZero(node-&gt;arithMode()));
 4498 
 4499         if (node-&gt;child2()-&gt;isInt32Constant()) {
 4500             SpeculateInt32Operand op1(this, node-&gt;child1());
 4501             int32_t imm2 = node-&gt;child2()-&gt;asInt32();
 4502             GPRTemporary result(this);
 4503 
 4504             if (!shouldCheckOverflow(node-&gt;arithMode())) {
 4505                 m_jit.move(op1.gpr(), result.gpr());
 4506                 m_jit.sub32(Imm32(imm2), result.gpr());
 4507             } else {
 4508                 GPRTemporary scratch(this);
 4509                 speculationCheck(Overflow, JSValueRegs(), 0, m_jit.branchSub32(MacroAssembler::Overflow, op1.gpr(), Imm32(imm2), result.gpr(), scratch.gpr()));
 4510             }
 4511 
 4512             int32Result(result.gpr(), node);
 4513             return;
 4514         }
 4515 
 4516         if (node-&gt;child1()-&gt;isInt32Constant()) {
 4517             int32_t imm1 = node-&gt;child1()-&gt;asInt32();
 4518             SpeculateInt32Operand op2(this, node-&gt;child2());
 4519             GPRTemporary result(this);
 4520 
 4521             m_jit.move(Imm32(imm1), result.gpr());
 4522             if (!shouldCheckOverflow(node-&gt;arithMode()))
 4523                 m_jit.sub32(op2.gpr(), result.gpr());
 4524             else
 4525                 speculationCheck(Overflow, JSValueRegs(), 0, m_jit.branchSub32(MacroAssembler::Overflow, op2.gpr(), result.gpr()));
 4526 
 4527             int32Result(result.gpr(), node);
 4528             return;
 4529         }
 4530 
 4531         SpeculateInt32Operand op1(this, node-&gt;child1());
 4532         SpeculateInt32Operand op2(this, node-&gt;child2());
 4533         GPRTemporary result(this);
 4534 
 4535         if (!shouldCheckOverflow(node-&gt;arithMode())) {
 4536             m_jit.move(op1.gpr(), result.gpr());
 4537             m_jit.sub32(op2.gpr(), result.gpr());
 4538         } else
 4539             speculationCheck(Overflow, JSValueRegs(), 0, m_jit.branchSub32(MacroAssembler::Overflow, op1.gpr(), op2.gpr(), result.gpr()));
 4540 
 4541         int32Result(result.gpr(), node);
 4542         return;
 4543     }
 4544 
 4545 #if USE(JSVALUE64)
 4546     case Int52RepUse: {
 4547         ASSERT(shouldCheckOverflow(node-&gt;arithMode()));
 4548         ASSERT(!shouldCheckNegativeZero(node-&gt;arithMode()));
 4549 
 4550         // Will we need an overflow check? If we can prove that neither input can be
 4551         // Int52 then the overflow check will not be necessary.
<a name="51" id="anc51"></a><span class="line-modified"> 4552         if (!m_state.forNode(node-&gt;child1()).couldBeType(SpecNonInt32AsInt52)</span>
<span class="line-modified"> 4553             &amp;&amp; !m_state.forNode(node-&gt;child2()).couldBeType(SpecNonInt32AsInt52)) {</span>
 4554             SpeculateWhicheverInt52Operand op1(this, node-&gt;child1());
 4555             SpeculateWhicheverInt52Operand op2(this, node-&gt;child2(), op1);
 4556             GPRTemporary result(this, Reuse, op1);
 4557             m_jit.move(op1.gpr(), result.gpr());
 4558             m_jit.sub64(op2.gpr(), result.gpr());
 4559             int52Result(result.gpr(), node, op1.format());
 4560             return;
 4561         }
 4562 
 4563         SpeculateInt52Operand op1(this, node-&gt;child1());
 4564         SpeculateInt52Operand op2(this, node-&gt;child2());
 4565         GPRTemporary result(this);
 4566         m_jit.move(op1.gpr(), result.gpr());
 4567         speculationCheck(
 4568             Int52Overflow, JSValueRegs(), 0,
 4569             m_jit.branchSub64(MacroAssembler::Overflow, op2.gpr(), result.gpr()));
 4570         int52Result(result.gpr(), node);
 4571         return;
 4572     }
 4573 #endif // USE(JSVALUE64)
 4574 
 4575     case DoubleRepUse: {
 4576         SpeculateDoubleOperand op1(this, node-&gt;child1());
 4577         SpeculateDoubleOperand op2(this, node-&gt;child2());
 4578         FPRTemporary result(this, op1);
 4579 
 4580         FPRReg reg1 = op1.fpr();
 4581         FPRReg reg2 = op2.fpr();
 4582         m_jit.subDouble(reg1, reg2, result.fpr());
 4583 
 4584         doubleResult(result.fpr(), node);
 4585         return;
 4586     }
 4587 
 4588     default:
 4589         RELEASE_ASSERT_NOT_REACHED();
 4590         return;
 4591     }
 4592 }
 4593 
 4594 void SpeculativeJIT::compileValueNegate(Node* node)
 4595 {
 4596     CodeBlock* baselineCodeBlock = m_jit.graph().baselineCodeBlockFor(node-&gt;origin.semantic);
<a name="52" id="anc52"></a><span class="line-modified"> 4597     unsigned bytecodeIndex = node-&gt;origin.semantic.bytecodeIndex();</span>
<span class="line-modified"> 4598     ArithProfile* arithProfile = baselineCodeBlock-&gt;arithProfileForBytecodeOffset(bytecodeIndex);</span>
<span class="line-modified"> 4599     JITNegIC* negIC = m_jit.codeBlock()-&gt;addJITNegIC(arithProfile);</span>
 4600     auto repatchingFunction = operationArithNegateOptimize;
 4601     auto nonRepatchingFunction = operationArithNegate;
 4602     bool needsScratchGPRReg = true;
 4603     compileMathIC(node, negIC, needsScratchGPRReg, repatchingFunction, nonRepatchingFunction);
 4604 }
 4605 
 4606 void SpeculativeJIT::compileArithNegate(Node* node)
 4607 {
 4608     switch (node-&gt;child1().useKind()) {
 4609     case Int32Use: {
 4610         SpeculateInt32Operand op1(this, node-&gt;child1());
 4611         GPRTemporary result(this);
 4612 
 4613         m_jit.move(op1.gpr(), result.gpr());
 4614 
 4615         // Note: there is no notion of being not used as a number, but someone
 4616         // caring about negative zero.
 4617 
 4618         if (!shouldCheckOverflow(node-&gt;arithMode()))
 4619             m_jit.neg32(result.gpr());
 4620         else if (!shouldCheckNegativeZero(node-&gt;arithMode()))
 4621             speculationCheck(Overflow, JSValueRegs(), 0, m_jit.branchNeg32(MacroAssembler::Overflow, result.gpr()));
 4622         else {
 4623             speculationCheck(Overflow, JSValueRegs(), 0, m_jit.branchTest32(MacroAssembler::Zero, result.gpr(), TrustedImm32(0x7fffffff)));
 4624             m_jit.neg32(result.gpr());
 4625         }
 4626 
 4627         int32Result(result.gpr(), node);
 4628         return;
 4629     }
 4630 
 4631 #if USE(JSVALUE64)
 4632     case Int52RepUse: {
 4633         ASSERT(shouldCheckOverflow(node-&gt;arithMode()));
 4634 
<a name="53" id="anc53"></a><span class="line-modified"> 4635         if (!m_state.forNode(node-&gt;child1()).couldBeType(SpecNonInt32AsInt52)) {</span>
 4636             SpeculateWhicheverInt52Operand op1(this, node-&gt;child1());
 4637             GPRTemporary result(this);
 4638             GPRReg op1GPR = op1.gpr();
 4639             GPRReg resultGPR = result.gpr();
 4640             m_jit.move(op1GPR, resultGPR);
 4641             m_jit.neg64(resultGPR);
 4642             if (shouldCheckNegativeZero(node-&gt;arithMode())) {
 4643                 speculationCheck(
 4644                     NegativeZero, JSValueRegs(), 0,
 4645                     m_jit.branchTest64(MacroAssembler::Zero, resultGPR));
 4646             }
 4647             int52Result(resultGPR, node, op1.format());
 4648             return;
 4649         }
 4650 
 4651         SpeculateInt52Operand op1(this, node-&gt;child1());
 4652         GPRTemporary result(this);
 4653         GPRReg op1GPR = op1.gpr();
 4654         GPRReg resultGPR = result.gpr();
 4655         m_jit.move(op1GPR, resultGPR);
 4656         speculationCheck(
 4657             Int52Overflow, JSValueRegs(), 0,
 4658             m_jit.branchNeg64(MacroAssembler::Overflow, resultGPR));
 4659         if (shouldCheckNegativeZero(node-&gt;arithMode())) {
 4660             speculationCheck(
 4661                 NegativeZero, JSValueRegs(), 0,
 4662                 m_jit.branchTest64(MacroAssembler::Zero, resultGPR));
 4663         }
 4664         int52Result(resultGPR, node);
 4665         return;
 4666     }
 4667 #endif // USE(JSVALUE64)
 4668 
 4669     case DoubleRepUse: {
 4670         SpeculateDoubleOperand op1(this, node-&gt;child1());
 4671         FPRTemporary result(this);
 4672 
 4673         m_jit.negateDouble(op1.fpr(), result.fpr());
 4674 
 4675         doubleResult(result.fpr(), node);
 4676         return;
 4677     }
 4678 
 4679     default: {
 4680         RELEASE_ASSERT_NOT_REACHED();
 4681     }
 4682     }
 4683 }
 4684 
 4685 template &lt;typename Generator, typename RepatchingFunction, typename NonRepatchingFunction&gt;
 4686 void SpeculativeJIT::compileMathIC(Node* node, JITUnaryMathIC&lt;Generator&gt;* mathIC, bool needsScratchGPRReg, RepatchingFunction repatchingFunction, NonRepatchingFunction nonRepatchingFunction)
 4687 {
 4688     GPRReg scratchGPR = InvalidGPRReg;
 4689     Optional&lt;GPRTemporary&gt; gprScratch;
 4690     if (needsScratchGPRReg) {
 4691         gprScratch.emplace(this);
 4692         scratchGPR = gprScratch-&gt;gpr();
 4693     }
 4694     JSValueOperand childOperand(this, node-&gt;child1());
 4695     JSValueRegs childRegs = childOperand.jsValueRegs();
 4696 #if USE(JSVALUE64)
 4697     GPRTemporary result(this, Reuse, childOperand);
 4698     JSValueRegs resultRegs(result.gpr());
 4699 #else
 4700     GPRTemporary resultTag(this);
 4701     GPRTemporary resultPayload(this);
 4702     JSValueRegs resultRegs(resultPayload.gpr(), resultTag.gpr());
 4703 #endif
 4704 
 4705 #if ENABLE(MATH_IC_STATS)
 4706     auto inlineStart = m_jit.label();
 4707 #endif
 4708 
 4709     Box&lt;MathICGenerationState&gt; icGenerationState = Box&lt;MathICGenerationState&gt;::create();
 4710     mathIC-&gt;m_generator = Generator(resultRegs, childRegs, scratchGPR);
 4711 
 4712     bool shouldEmitProfiling = false;
 4713     bool generatedInline = mathIC-&gt;generateInline(m_jit, *icGenerationState, shouldEmitProfiling);
 4714     if (generatedInline) {
 4715         ASSERT(!icGenerationState-&gt;slowPathJumps.empty());
 4716 
 4717         Vector&lt;SilentRegisterSavePlan&gt; savePlans;
 4718         silentSpillAllRegistersImpl(false, savePlans, resultRegs);
 4719 
 4720         auto done = m_jit.label();
 4721 
 4722         addSlowPathGeneratorLambda([=, savePlans = WTFMove(savePlans)] () {
 4723             icGenerationState-&gt;slowPathJumps.link(&amp;m_jit);
 4724             icGenerationState-&gt;slowPathStart = m_jit.label();
 4725 #if ENABLE(MATH_IC_STATS)
 4726             auto slowPathStart = m_jit.label();
 4727 #endif
 4728 
 4729             silentSpill(savePlans);
 4730 
 4731             if (icGenerationState-&gt;shouldSlowPathRepatch)
 4732                 icGenerationState-&gt;slowPathCall = callOperation(bitwise_cast&lt;J_JITOperation_EJMic&gt;(repatchingFunction), resultRegs, childRegs, TrustedImmPtr(mathIC));
 4733             else
 4734                 icGenerationState-&gt;slowPathCall = callOperation(nonRepatchingFunction, resultRegs, childRegs);
 4735 
 4736             silentFill(savePlans);
 4737             m_jit.exceptionCheck();
 4738             m_jit.jump().linkTo(done, &amp;m_jit);
 4739 
 4740             m_jit.addLinkTask([=] (LinkBuffer&amp; linkBuffer) {
 4741                 mathIC-&gt;finalizeInlineCode(*icGenerationState, linkBuffer);
 4742             });
 4743 
 4744 #if ENABLE(MATH_IC_STATS)
 4745             auto slowPathEnd = m_jit.label();
 4746             m_jit.addLinkTask([=] (LinkBuffer&amp; linkBuffer) {
 4747                 size_t size = static_cast&lt;char*&gt;(linkBuffer.locationOf(slowPathEnd).executableAddress()) - static_cast&lt;char*&gt;(linkBuffer.locationOf(slowPathStart).executableAddress());
 4748                 mathIC-&gt;m_generatedCodeSize += size;
 4749             });
 4750 #endif
 4751 
 4752         });
 4753     } else {
 4754         flushRegisters();
 4755         callOperation(nonRepatchingFunction, resultRegs, childRegs);
 4756         m_jit.exceptionCheck();
 4757     }
 4758 
 4759 #if ENABLE(MATH_IC_STATS)
 4760     auto inlineEnd = m_jit.label();
 4761     m_jit.addLinkTask([=] (LinkBuffer&amp; linkBuffer) {
 4762         size_t size = static_cast&lt;char*&gt;(linkBuffer.locationOf(inlineEnd).executableAddress()) - static_cast&lt;char*&gt;(linkBuffer.locationOf(inlineStart).executableAddress());
 4763         mathIC-&gt;m_generatedCodeSize += size;
 4764     });
 4765 #endif
 4766 
 4767     jsValueResult(resultRegs, node);
 4768     return;
 4769 }
 4770 
 4771 void SpeculativeJIT::compileValueMul(Node* node)
 4772 {
 4773     Edge&amp; leftChild = node-&gt;child1();
 4774     Edge&amp; rightChild = node-&gt;child2();
 4775 
 4776     if (leftChild.useKind() == BigIntUse &amp;&amp; rightChild.useKind() == BigIntUse) {
 4777         SpeculateCellOperand left(this, leftChild);
 4778         SpeculateCellOperand right(this, rightChild);
 4779         GPRReg leftGPR = left.gpr();
 4780         GPRReg rightGPR = right.gpr();
 4781 
 4782         speculateBigInt(leftChild, leftGPR);
 4783         speculateBigInt(rightChild, rightGPR);
 4784 
 4785         flushRegisters();
 4786         GPRFlushedCallResult result(this);
 4787         GPRReg resultGPR = result.gpr();
 4788 
 4789         callOperation(operationMulBigInt, resultGPR, leftGPR, rightGPR);
 4790 
 4791         m_jit.exceptionCheck();
 4792         cellResult(resultGPR, node);
 4793         return;
 4794     }
 4795 
 4796     if (isKnownNotNumber(leftChild.node()) || isKnownNotNumber(rightChild.node())) {
 4797         JSValueOperand left(this, leftChild);
 4798         JSValueOperand right(this, rightChild);
 4799         JSValueRegs leftRegs = left.jsValueRegs();
 4800         JSValueRegs rightRegs = right.jsValueRegs();
 4801 
 4802         flushRegisters();
 4803         JSValueRegsFlushedCallResult result(this);
 4804         JSValueRegs resultRegs = result.regs();
 4805         callOperation(operationValueMul, resultRegs, leftRegs, rightRegs);
 4806         m_jit.exceptionCheck();
 4807 
 4808         jsValueResult(resultRegs, node);
 4809         return;
 4810     }
 4811 
 4812     bool needsScratchGPRReg = true;
 4813 #if USE(JSVALUE64)
 4814     bool needsScratchFPRReg = false;
 4815 #else
 4816     bool needsScratchFPRReg = true;
 4817 #endif
 4818 
 4819     CodeBlock* baselineCodeBlock = m_jit.graph().baselineCodeBlockFor(node-&gt;origin.semantic);
<a name="54" id="anc54"></a><span class="line-modified"> 4820     unsigned bytecodeIndex = node-&gt;origin.semantic.bytecodeIndex();</span>
<span class="line-modified"> 4821     ArithProfile* arithProfile = baselineCodeBlock-&gt;arithProfileForBytecodeOffset(bytecodeIndex);</span>
<span class="line-modified"> 4822     JITMulIC* mulIC = m_jit.codeBlock()-&gt;addJITMulIC(arithProfile);</span>
 4823     auto repatchingFunction = operationValueMulOptimize;
 4824     auto nonRepatchingFunction = operationValueMul;
 4825 
 4826     compileMathIC(node, mulIC, needsScratchGPRReg, needsScratchFPRReg, repatchingFunction, nonRepatchingFunction);
 4827 }
 4828 
 4829 void SpeculativeJIT::compileArithMul(Node* node)
 4830 {
 4831     switch (node-&gt;binaryUseKind()) {
 4832     case Int32Use: {
 4833         if (node-&gt;child2()-&gt;isInt32Constant()) {
 4834             SpeculateInt32Operand op1(this, node-&gt;child1());
 4835             GPRTemporary result(this);
 4836 
 4837             int32_t imm = node-&gt;child2()-&gt;asInt32();
 4838             GPRReg op1GPR = op1.gpr();
 4839             GPRReg resultGPR = result.gpr();
 4840 
 4841             if (!shouldCheckOverflow(node-&gt;arithMode()))
 4842                 m_jit.mul32(Imm32(imm), op1GPR, resultGPR);
 4843             else {
 4844                 speculationCheck(Overflow, JSValueRegs(), 0,
 4845                     m_jit.branchMul32(MacroAssembler::Overflow, op1GPR, Imm32(imm), resultGPR));
 4846             }
 4847 
 4848             // The only way to create negative zero with a constant is:
 4849             // -negative-op1 * 0.
 4850             // -zero-op1 * negative constant.
 4851             if (shouldCheckNegativeZero(node-&gt;arithMode())) {
 4852                 if (!imm)
 4853                     speculationCheck(NegativeZero, JSValueRegs(), 0, m_jit.branchTest32(MacroAssembler::Signed, op1GPR));
 4854                 else if (imm &lt; 0) {
 4855                     if (shouldCheckOverflow(node-&gt;arithMode()))
 4856                         speculationCheck(NegativeZero, JSValueRegs(), 0, m_jit.branchTest32(MacroAssembler::Zero, resultGPR));
 4857                     else
 4858                         speculationCheck(NegativeZero, JSValueRegs(), 0, m_jit.branchTest32(MacroAssembler::Zero, op1GPR));
 4859                 }
 4860             }
 4861 
 4862             int32Result(resultGPR, node);
 4863             return;
 4864         }
 4865         SpeculateInt32Operand op1(this, node-&gt;child1());
 4866         SpeculateInt32Operand op2(this, node-&gt;child2());
 4867         GPRTemporary result(this);
 4868 
 4869         GPRReg reg1 = op1.gpr();
 4870         GPRReg reg2 = op2.gpr();
 4871 
 4872         // We can perform truncated multiplications if we get to this point, because if the
 4873         // fixup phase could not prove that it would be safe, it would have turned us into
 4874         // a double multiplication.
 4875         if (!shouldCheckOverflow(node-&gt;arithMode()))
 4876             m_jit.mul32(reg1, reg2, result.gpr());
 4877         else {
 4878             speculationCheck(
 4879                 Overflow, JSValueRegs(), 0,
 4880                 m_jit.branchMul32(MacroAssembler::Overflow, reg1, reg2, result.gpr()));
 4881         }
 4882 
 4883         // Check for negative zero, if the users of this node care about such things.
 4884         if (shouldCheckNegativeZero(node-&gt;arithMode())) {
 4885             MacroAssembler::Jump resultNonZero = m_jit.branchTest32(MacroAssembler::NonZero, result.gpr());
 4886             speculationCheck(NegativeZero, JSValueRegs(), 0, m_jit.branchTest32(MacroAssembler::Signed, reg1));
 4887             speculationCheck(NegativeZero, JSValueRegs(), 0, m_jit.branchTest32(MacroAssembler::Signed, reg2));
 4888             resultNonZero.link(&amp;m_jit);
 4889         }
 4890 
 4891         int32Result(result.gpr(), node);
 4892         return;
 4893     }
 4894 
 4895 #if USE(JSVALUE64)
 4896     case Int52RepUse: {
 4897         ASSERT(shouldCheckOverflow(node-&gt;arithMode()));
 4898 
 4899         // This is super clever. We want to do an int52 multiplication and check the
 4900         // int52 overflow bit. There is no direct hardware support for this, but we do
 4901         // have the ability to do an int64 multiplication and check the int64 overflow
 4902         // bit. We leverage that. Consider that a, b are int52 numbers inside int64
 4903         // registers, with the high 12 bits being sign-extended. We can do:
 4904         //
 4905         //     (a * (b &lt;&lt; 12))
 4906         //
 4907         // This will give us a left-shifted int52 (value is in high 52 bits, low 16
 4908         // bits are zero) plus the int52 overflow bit. I.e. whether this 64-bit
 4909         // multiplication overflows is identical to whether the &#39;a * b&#39; 52-bit
 4910         // multiplication overflows.
 4911         //
 4912         // In our nomenclature, this is:
 4913         //
 4914         //     strictInt52(a) * int52(b) =&gt; int52
 4915         //
 4916         // That is &quot;strictInt52&quot; means unshifted and &quot;int52&quot; means left-shifted by 16
 4917         // bits.
 4918         //
 4919         // We don&#39;t care which of op1 or op2 serves as the left-shifted operand, so
 4920         // we just do whatever is more convenient for op1 and have op2 do the
 4921         // opposite. This ensures that we do at most one shift.
 4922 
 4923         SpeculateWhicheverInt52Operand op1(this, node-&gt;child1());
 4924         SpeculateWhicheverInt52Operand op2(this, node-&gt;child2(), OppositeShift, op1);
 4925         GPRTemporary result(this);
 4926 
 4927         GPRReg op1GPR = op1.gpr();
 4928         GPRReg op2GPR = op2.gpr();
 4929         GPRReg resultGPR = result.gpr();
 4930 
 4931         m_jit.move(op1GPR, resultGPR);
 4932         speculationCheck(
 4933             Int52Overflow, JSValueRegs(), 0,
 4934             m_jit.branchMul64(MacroAssembler::Overflow, op2GPR, resultGPR));
 4935 
 4936         if (shouldCheckNegativeZero(node-&gt;arithMode())) {
 4937             MacroAssembler::Jump resultNonZero = m_jit.branchTest64(
 4938                 MacroAssembler::NonZero, resultGPR);
 4939             speculationCheck(
 4940                 NegativeZero, JSValueRegs(), 0,
 4941                 m_jit.branch64(MacroAssembler::LessThan, op1GPR, TrustedImm32(0)));
 4942             speculationCheck(
 4943                 NegativeZero, JSValueRegs(), 0,
 4944                 m_jit.branch64(MacroAssembler::LessThan, op2GPR, TrustedImm32(0)));
 4945             resultNonZero.link(&amp;m_jit);
 4946         }
 4947 
 4948         int52Result(resultGPR, node);
 4949         return;
 4950     }
 4951 #endif // USE(JSVALUE64)
 4952 
 4953     case DoubleRepUse: {
 4954         SpeculateDoubleOperand op1(this, node-&gt;child1());
 4955         SpeculateDoubleOperand op2(this, node-&gt;child2());
 4956         FPRTemporary result(this, op1, op2);
 4957 
 4958         FPRReg reg1 = op1.fpr();
 4959         FPRReg reg2 = op2.fpr();
 4960 
 4961         m_jit.mulDouble(reg1, reg2, result.fpr());
 4962 
 4963         doubleResult(result.fpr(), node);
 4964         return;
 4965     }
 4966 
 4967     default:
 4968         RELEASE_ASSERT_NOT_REACHED();
 4969         return;
 4970     }
 4971 }
 4972 
 4973 void SpeculativeJIT::compileValueDiv(Node* node)
 4974 {
 4975     Edge&amp; leftChild = node-&gt;child1();
 4976     Edge&amp; rightChild = node-&gt;child2();
 4977 
 4978     if (leftChild.useKind() == BigIntUse &amp;&amp; rightChild.useKind() == BigIntUse) {
 4979         SpeculateCellOperand left(this, leftChild);
 4980         SpeculateCellOperand right(this, rightChild);
 4981         GPRReg leftGPR = left.gpr();
 4982         GPRReg rightGPR = right.gpr();
 4983 
 4984         speculateBigInt(leftChild, leftGPR);
 4985         speculateBigInt(rightChild, rightGPR);
 4986 
 4987         flushRegisters();
 4988         GPRFlushedCallResult result(this);
 4989         GPRReg resultGPR = result.gpr();
 4990 
 4991         callOperation(operationDivBigInt, resultGPR, leftGPR, rightGPR);
 4992 
 4993         m_jit.exceptionCheck();
 4994         cellResult(resultGPR, node);
 4995         return;
 4996     }
 4997 
 4998     if (isKnownNotNumber(leftChild.node()) || isKnownNotNumber(rightChild.node())) {
 4999         JSValueOperand left(this, leftChild);
 5000         JSValueOperand right(this, rightChild);
 5001         JSValueRegs leftRegs = left.jsValueRegs();
 5002         JSValueRegs rightRegs = right.jsValueRegs();
 5003 
 5004         flushRegisters();
 5005         JSValueRegsFlushedCallResult result(this);
 5006         JSValueRegs resultRegs = result.regs();
 5007         callOperation(operationValueDiv, resultRegs, leftRegs, rightRegs);
 5008         m_jit.exceptionCheck();
 5009 
 5010         jsValueResult(resultRegs, node);
 5011         return;
 5012     }
 5013 
 5014     Optional&lt;JSValueOperand&gt; left;
 5015     Optional&lt;JSValueOperand&gt; right;
 5016 
 5017     JSValueRegs leftRegs;
 5018     JSValueRegs rightRegs;
 5019 
 5020     FPRTemporary leftNumber(this);
 5021     FPRTemporary rightNumber(this);
 5022     FPRReg leftFPR = leftNumber.fpr();
 5023     FPRReg rightFPR = rightNumber.fpr();
 5024     FPRTemporary fprScratch(this);
 5025     FPRReg scratchFPR = fprScratch.fpr();
 5026 
 5027 #if USE(JSVALUE64)
 5028     GPRTemporary result(this);
 5029     JSValueRegs resultRegs = JSValueRegs(result.gpr());
 5030     GPRTemporary scratch(this);
 5031     GPRReg scratchGPR = scratch.gpr();
 5032 #else
 5033     GPRTemporary resultTag(this);
 5034     GPRTemporary resultPayload(this);
 5035     JSValueRegs resultRegs = JSValueRegs(resultPayload.gpr(), resultTag.gpr());
 5036     GPRReg scratchGPR = resultTag.gpr();
 5037 #endif
 5038 
 5039     SnippetOperand leftOperand(m_state.forNode(leftChild).resultType());
 5040     SnippetOperand rightOperand(m_state.forNode(rightChild).resultType());
 5041 
 5042     if (leftChild-&gt;isInt32Constant())
 5043         leftOperand.setConstInt32(leftChild-&gt;asInt32());
 5044 #if USE(JSVALUE64)
 5045     else if (leftChild-&gt;isDoubleConstant())
 5046         leftOperand.setConstDouble(leftChild-&gt;asNumber());
 5047 #endif
 5048 
 5049     if (leftOperand.isConst()) {
 5050         // The snippet generator only supports 1 argument as a constant.
 5051         // Ignore the rightChild&#39;s const-ness.
 5052     } else if (rightChild-&gt;isInt32Constant())
 5053         rightOperand.setConstInt32(rightChild-&gt;asInt32());
 5054 #if USE(JSVALUE64)
 5055     else if (rightChild-&gt;isDoubleConstant())
 5056         rightOperand.setConstDouble(rightChild-&gt;asNumber());
 5057 #endif
 5058 
 5059     RELEASE_ASSERT(!leftOperand.isConst() || !rightOperand.isConst());
 5060 
 5061     if (!leftOperand.isConst()) {
 5062         left.emplace(this, leftChild);
 5063         leftRegs = left-&gt;jsValueRegs();
 5064     }
 5065     if (!rightOperand.isConst()) {
 5066         right.emplace(this, rightChild);
 5067         rightRegs = right-&gt;jsValueRegs();
 5068     }
 5069 
 5070     JITDivGenerator gen(leftOperand, rightOperand, resultRegs, leftRegs, rightRegs,
 5071         leftFPR, rightFPR, scratchGPR, scratchFPR);
 5072     gen.generateFastPath(m_jit);
 5073 
 5074     ASSERT(gen.didEmitFastPath());
 5075     gen.endJumpList().append(m_jit.jump());
 5076 
 5077     gen.slowPathJumpList().link(&amp;m_jit);
 5078     silentSpillAllRegisters(resultRegs);
 5079 
 5080     if (leftOperand.isConst()) {
 5081         leftRegs = resultRegs;
 5082         m_jit.moveValue(leftChild-&gt;asJSValue(), leftRegs);
 5083     }
 5084     if (rightOperand.isConst()) {
 5085         rightRegs = resultRegs;
 5086         m_jit.moveValue(rightChild-&gt;asJSValue(), rightRegs);
 5087     }
 5088 
 5089     callOperation(operationValueDiv, resultRegs, leftRegs, rightRegs);
 5090 
 5091     silentFillAllRegisters();
 5092     m_jit.exceptionCheck();
 5093 
 5094     gen.endJumpList().link(&amp;m_jit);
 5095     jsValueResult(resultRegs, node);
 5096 }
 5097 
 5098 void SpeculativeJIT::compileArithDiv(Node* node)
 5099 {
 5100     switch (node-&gt;binaryUseKind()) {
 5101     case Int32Use: {
 5102 #if CPU(X86) || CPU(X86_64)
 5103         SpeculateInt32Operand op1(this, node-&gt;child1());
 5104         SpeculateInt32Operand op2(this, node-&gt;child2());
 5105         GPRTemporary eax(this, X86Registers::eax);
 5106         GPRTemporary edx(this, X86Registers::edx);
 5107         GPRReg op1GPR = op1.gpr();
 5108         GPRReg op2GPR = op2.gpr();
 5109 
 5110         GPRReg op2TempGPR;
 5111         GPRReg temp;
 5112         if (op2GPR == X86Registers::eax || op2GPR == X86Registers::edx) {
 5113             op2TempGPR = allocate();
 5114             temp = op2TempGPR;
 5115         } else {
 5116             op2TempGPR = InvalidGPRReg;
 5117             if (op1GPR == X86Registers::eax)
 5118                 temp = X86Registers::edx;
 5119             else
 5120                 temp = X86Registers::eax;
 5121         }
 5122 
 5123         ASSERT(temp != op1GPR);
 5124         ASSERT(temp != op2GPR);
 5125 
 5126         m_jit.add32(JITCompiler::TrustedImm32(1), op2GPR, temp);
 5127 
 5128         JITCompiler::Jump safeDenominator = m_jit.branch32(JITCompiler::Above, temp, JITCompiler::TrustedImm32(1));
 5129 
 5130         JITCompiler::JumpList done;
 5131         if (shouldCheckOverflow(node-&gt;arithMode())) {
 5132             speculationCheck(Overflow, JSValueRegs(), 0, m_jit.branchTest32(JITCompiler::Zero, op2GPR));
 5133             speculationCheck(Overflow, JSValueRegs(), 0, m_jit.branch32(JITCompiler::Equal, op1GPR, TrustedImm32(-2147483647-1)));
 5134         } else {
 5135             // This is the case where we convert the result to an int after we&#39;re done, and we
 5136             // already know that the denominator is either -1 or 0. So, if the denominator is
 5137             // zero, then the result should be zero. If the denominator is not zero (i.e. it&#39;s
 5138             // -1) and the numerator is -2^31 then the result should be -2^31. Otherwise we
 5139             // are happy to fall through to a normal division, since we&#39;re just dividing
 5140             // something by negative 1.
 5141 
 5142             JITCompiler::Jump notZero = m_jit.branchTest32(JITCompiler::NonZero, op2GPR);
 5143             m_jit.move(TrustedImm32(0), eax.gpr());
 5144             done.append(m_jit.jump());
 5145 
 5146             notZero.link(&amp;m_jit);
 5147             JITCompiler::Jump notNeg2ToThe31 =
 5148                 m_jit.branch32(JITCompiler::NotEqual, op1GPR, TrustedImm32(-2147483647-1));
 5149             m_jit.zeroExtend32ToPtr(op1GPR, eax.gpr());
 5150             done.append(m_jit.jump());
 5151 
 5152             notNeg2ToThe31.link(&amp;m_jit);
 5153         }
 5154 
 5155         safeDenominator.link(&amp;m_jit);
 5156 
 5157         // If the user cares about negative zero, then speculate that we&#39;re not about
 5158         // to produce negative zero.
 5159         if (shouldCheckNegativeZero(node-&gt;arithMode())) {
 5160             MacroAssembler::Jump numeratorNonZero = m_jit.branchTest32(MacroAssembler::NonZero, op1GPR);
 5161             speculationCheck(NegativeZero, JSValueRegs(), 0, m_jit.branch32(MacroAssembler::LessThan, op2GPR, TrustedImm32(0)));
 5162             numeratorNonZero.link(&amp;m_jit);
 5163         }
 5164 
 5165         if (op2TempGPR != InvalidGPRReg) {
 5166             m_jit.move(op2GPR, op2TempGPR);
 5167             op2GPR = op2TempGPR;
 5168         }
 5169 
 5170         m_jit.move(op1GPR, eax.gpr());
 5171         m_jit.x86ConvertToDoubleWord32();
 5172         m_jit.x86Div32(op2GPR);
 5173 
 5174         if (op2TempGPR != InvalidGPRReg)
 5175             unlock(op2TempGPR);
 5176 
 5177         // Check that there was no remainder. If there had been, then we&#39;d be obligated to
 5178         // produce a double result instead.
 5179         if (shouldCheckOverflow(node-&gt;arithMode()))
 5180             speculationCheck(Overflow, JSValueRegs(), 0, m_jit.branchTest32(JITCompiler::NonZero, edx.gpr()));
 5181 
 5182         done.link(&amp;m_jit);
 5183         int32Result(eax.gpr(), node);
 5184 #elif HAVE(ARM_IDIV_INSTRUCTIONS) || CPU(ARM64)
 5185         SpeculateInt32Operand op1(this, node-&gt;child1());
 5186         SpeculateInt32Operand op2(this, node-&gt;child2());
 5187         GPRReg op1GPR = op1.gpr();
 5188         GPRReg op2GPR = op2.gpr();
 5189         GPRTemporary quotient(this);
 5190         GPRTemporary multiplyAnswer(this);
 5191 
 5192         // If the user cares about negative zero, then speculate that we&#39;re not about
 5193         // to produce negative zero.
 5194         if (shouldCheckNegativeZero(node-&gt;arithMode())) {
 5195             MacroAssembler::Jump numeratorNonZero = m_jit.branchTest32(MacroAssembler::NonZero, op1GPR);
 5196             speculationCheck(NegativeZero, JSValueRegs(), 0, m_jit.branch32(MacroAssembler::LessThan, op2GPR, TrustedImm32(0)));
 5197             numeratorNonZero.link(&amp;m_jit);
 5198         }
 5199 
 5200         if (shouldCheckOverflow(node-&gt;arithMode()))
 5201             speculationCheck(Overflow, JSValueRegs(), nullptr, m_jit.branchTest32(MacroAssembler::Zero, op2GPR));
 5202 
 5203         m_jit.assembler().sdiv&lt;32&gt;(quotient.gpr(), op1GPR, op2GPR);
 5204 
 5205         // Check that there was no remainder. If there had been, then we&#39;d be obligated to
 5206         // produce a double result instead.
 5207         if (shouldCheckOverflow(node-&gt;arithMode())) {
 5208             speculationCheck(Overflow, JSValueRegs(), 0, m_jit.branchMul32(JITCompiler::Overflow, quotient.gpr(), op2GPR, multiplyAnswer.gpr()));
 5209             speculationCheck(Overflow, JSValueRegs(), 0, m_jit.branch32(JITCompiler::NotEqual, multiplyAnswer.gpr(), op1GPR));
 5210         }
 5211 
 5212         int32Result(quotient.gpr(), node);
 5213 #else
 5214         RELEASE_ASSERT_NOT_REACHED();
 5215 #endif
 5216         break;
 5217     }
 5218 
 5219     case DoubleRepUse: {
 5220         SpeculateDoubleOperand op1(this, node-&gt;child1());
 5221         SpeculateDoubleOperand op2(this, node-&gt;child2());
 5222         FPRTemporary result(this, op1);
 5223 
 5224         FPRReg reg1 = op1.fpr();
 5225         FPRReg reg2 = op2.fpr();
 5226         m_jit.divDouble(reg1, reg2, result.fpr());
 5227 
 5228         doubleResult(result.fpr(), node);
 5229         break;
 5230     }
 5231 
 5232     default:
 5233         RELEASE_ASSERT_NOT_REACHED();
 5234         break;
 5235     }
 5236 }
 5237 
 5238 void SpeculativeJIT::compileArithFRound(Node* node)
 5239 {
 5240     if (node-&gt;child1().useKind() == DoubleRepUse) {
 5241         SpeculateDoubleOperand op1(this, node-&gt;child1());
 5242         FPRTemporary result(this, op1);
 5243         m_jit.convertDoubleToFloat(op1.fpr(), result.fpr());
 5244         m_jit.convertFloatToDouble(result.fpr(), result.fpr());
 5245         doubleResult(result.fpr(), node);
 5246         return;
 5247     }
 5248 
 5249     JSValueOperand op1(this, node-&gt;child1());
 5250     JSValueRegs op1Regs = op1.jsValueRegs();
 5251     flushRegisters();
 5252     FPRResult result(this);
 5253     callOperation(operationArithFRound, result.fpr(), op1Regs);
 5254     m_jit.exceptionCheck();
 5255     doubleResult(result.fpr(), node);
 5256 }
 5257 
<a name="55" id="anc55"></a><span class="line-added"> 5258 void SpeculativeJIT::compileValueMod(Node* node)</span>
<span class="line-added"> 5259 {</span>
<span class="line-added"> 5260     Edge&amp; leftChild = node-&gt;child1();</span>
<span class="line-added"> 5261     Edge&amp; rightChild = node-&gt;child2();</span>
<span class="line-added"> 5262 </span>
<span class="line-added"> 5263     if (node-&gt;binaryUseKind() == BigIntUse) {</span>
<span class="line-added"> 5264         SpeculateCellOperand left(this, leftChild);</span>
<span class="line-added"> 5265         SpeculateCellOperand right(this, rightChild);</span>
<span class="line-added"> 5266         GPRReg leftGPR = left.gpr();</span>
<span class="line-added"> 5267         GPRReg rightGPR = right.gpr();</span>
<span class="line-added"> 5268 </span>
<span class="line-added"> 5269         speculateBigInt(leftChild, leftGPR);</span>
<span class="line-added"> 5270         speculateBigInt(rightChild, rightGPR);</span>
<span class="line-added"> 5271 </span>
<span class="line-added"> 5272         flushRegisters();</span>
<span class="line-added"> 5273         GPRFlushedCallResult result(this);</span>
<span class="line-added"> 5274         GPRReg resultGPR = result.gpr();</span>
<span class="line-added"> 5275 </span>
<span class="line-added"> 5276         callOperation(operationModBigInt, resultGPR, leftGPR, rightGPR);</span>
<span class="line-added"> 5277 </span>
<span class="line-added"> 5278         m_jit.exceptionCheck();</span>
<span class="line-added"> 5279         cellResult(resultGPR, node);</span>
<span class="line-added"> 5280         return;</span>
<span class="line-added"> 5281     }</span>
<span class="line-added"> 5282 </span>
<span class="line-added"> 5283     DFG_ASSERT(m_jit.graph(), node, node-&gt;binaryUseKind() == UntypedUse, node-&gt;binaryUseKind());</span>
<span class="line-added"> 5284     JSValueOperand op1(this, leftChild);</span>
<span class="line-added"> 5285     JSValueOperand op2(this, rightChild);</span>
<span class="line-added"> 5286     JSValueRegs op1Regs = op1.jsValueRegs();</span>
<span class="line-added"> 5287     JSValueRegs op2Regs = op2.jsValueRegs();</span>
<span class="line-added"> 5288     flushRegisters();</span>
<span class="line-added"> 5289     JSValueRegsFlushedCallResult result(this);</span>
<span class="line-added"> 5290     JSValueRegs resultRegs = result.regs();</span>
<span class="line-added"> 5291     callOperation(operationValueMod, resultRegs, op1Regs, op2Regs);</span>
<span class="line-added"> 5292     m_jit.exceptionCheck();</span>
<span class="line-added"> 5293     jsValueResult(resultRegs, node);</span>
<span class="line-added"> 5294 }</span>
<span class="line-added"> 5295 </span>
 5296 void SpeculativeJIT::compileArithMod(Node* node)
 5297 {
 5298     switch (node-&gt;binaryUseKind()) {
 5299     case Int32Use: {
 5300         // In the fast path, the dividend value could be the final result
 5301         // (in case of |dividend| &lt; |divisor|), so we speculate it as strict int32.
 5302         SpeculateStrictInt32Operand op1(this, node-&gt;child1());
 5303 
 5304         if (node-&gt;child2()-&gt;isInt32Constant()) {
 5305             int32_t divisor = node-&gt;child2()-&gt;asInt32();
 5306             if (divisor &gt; 1 &amp;&amp; hasOneBitSet(divisor)) {
 5307                 unsigned logarithm = WTF::fastLog2(static_cast&lt;uint32_t&gt;(divisor));
 5308                 GPRReg dividendGPR = op1.gpr();
 5309                 GPRTemporary result(this);
 5310                 GPRReg resultGPR = result.gpr();
 5311 
 5312                 // This is what LLVM generates. It&#39;s pretty crazy. Here&#39;s my
 5313                 // attempt at understanding it.
 5314 
 5315                 // First, compute either divisor - 1, or 0, depending on whether
 5316                 // the dividend is negative:
 5317                 //
 5318                 // If dividend &lt; 0:  resultGPR = divisor - 1
 5319                 // If dividend &gt;= 0: resultGPR = 0
 5320                 m_jit.move(dividendGPR, resultGPR);
 5321                 m_jit.rshift32(TrustedImm32(31), resultGPR);
 5322                 m_jit.urshift32(TrustedImm32(32 - logarithm), resultGPR);
 5323 
 5324                 // Add in the dividend, so that:
 5325                 //
 5326                 // If dividend &lt; 0:  resultGPR = dividend + divisor - 1
 5327                 // If dividend &gt;= 0: resultGPR = dividend
 5328                 m_jit.add32(dividendGPR, resultGPR);
 5329 
 5330                 // Mask so as to only get the *high* bits. This rounds down
 5331                 // (towards negative infinity) resultGPR to the nearest multiple
 5332                 // of divisor, so that:
 5333                 //
 5334                 // If dividend &lt; 0:  resultGPR = floor((dividend + divisor - 1) / divisor)
 5335                 // If dividend &gt;= 0: resultGPR = floor(dividend / divisor)
 5336                 //
 5337                 // Note that this can be simplified to:
 5338                 //
 5339                 // If dividend &lt; 0:  resultGPR = ceil(dividend / divisor)
 5340                 // If dividend &gt;= 0: resultGPR = floor(dividend / divisor)
 5341                 //
 5342                 // Note that if the dividend is negative, resultGPR will also be negative.
 5343                 // Regardless of the sign of dividend, resultGPR will be rounded towards
 5344                 // zero, because of how things are conditionalized.
 5345                 m_jit.and32(TrustedImm32(-divisor), resultGPR);
 5346 
 5347                 // Subtract resultGPR from dividendGPR, which yields the remainder:
 5348                 //
 5349                 // resultGPR = dividendGPR - resultGPR
 5350                 m_jit.neg32(resultGPR);
 5351                 m_jit.add32(dividendGPR, resultGPR);
 5352 
 5353                 if (shouldCheckNegativeZero(node-&gt;arithMode())) {
 5354                     // Check that we&#39;re not about to create negative zero.
 5355                     JITCompiler::Jump numeratorPositive = m_jit.branch32(JITCompiler::GreaterThanOrEqual, dividendGPR, TrustedImm32(0));
 5356                     speculationCheck(NegativeZero, JSValueRegs(), 0, m_jit.branchTest32(JITCompiler::Zero, resultGPR));
 5357                     numeratorPositive.link(&amp;m_jit);
 5358                 }
 5359 
 5360                 int32Result(resultGPR, node);
 5361                 return;
 5362             }
 5363         }
 5364 
 5365 #if CPU(X86) || CPU(X86_64)
 5366         if (node-&gt;child2()-&gt;isInt32Constant()) {
 5367             int32_t divisor = node-&gt;child2()-&gt;asInt32();
 5368             if (divisor &amp;&amp; divisor != -1) {
 5369                 GPRReg op1Gpr = op1.gpr();
 5370 
 5371                 GPRTemporary eax(this, X86Registers::eax);
 5372                 GPRTemporary edx(this, X86Registers::edx);
 5373                 GPRTemporary scratch(this);
 5374                 GPRReg scratchGPR = scratch.gpr();
 5375 
 5376                 GPRReg op1SaveGPR;
 5377                 if (op1Gpr == X86Registers::eax || op1Gpr == X86Registers::edx) {
 5378                     op1SaveGPR = allocate();
 5379                     ASSERT(op1Gpr != op1SaveGPR);
 5380                     m_jit.move(op1Gpr, op1SaveGPR);
 5381                 } else
 5382                     op1SaveGPR = op1Gpr;
 5383                 ASSERT(op1SaveGPR != X86Registers::eax);
 5384                 ASSERT(op1SaveGPR != X86Registers::edx);
 5385 
 5386                 m_jit.move(op1Gpr, eax.gpr());
 5387                 m_jit.move(TrustedImm32(divisor), scratchGPR);
 5388                 m_jit.x86ConvertToDoubleWord32();
 5389                 m_jit.x86Div32(scratchGPR);
 5390                 if (shouldCheckNegativeZero(node-&gt;arithMode())) {
 5391                     JITCompiler::Jump numeratorPositive = m_jit.branch32(JITCompiler::GreaterThanOrEqual, op1SaveGPR, TrustedImm32(0));
 5392                     speculationCheck(Overflow, JSValueRegs(), 0, m_jit.branchTest32(JITCompiler::Zero, edx.gpr()));
 5393                     numeratorPositive.link(&amp;m_jit);
 5394                 }
 5395 
 5396                 if (op1SaveGPR != op1Gpr)
 5397                     unlock(op1SaveGPR);
 5398 
 5399                 int32Result(edx.gpr(), node);
 5400                 return;
 5401             }
 5402         }
 5403 #endif
 5404 
 5405         SpeculateInt32Operand op2(this, node-&gt;child2());
 5406 #if CPU(X86) || CPU(X86_64)
 5407         GPRTemporary eax(this, X86Registers::eax);
 5408         GPRTemporary edx(this, X86Registers::edx);
 5409         GPRReg op1GPR = op1.gpr();
 5410         GPRReg op2GPR = op2.gpr();
 5411 
 5412         GPRReg op2TempGPR;
 5413         GPRReg temp;
 5414         GPRReg op1SaveGPR;
 5415 
 5416         if (op2GPR == X86Registers::eax || op2GPR == X86Registers::edx) {
 5417             op2TempGPR = allocate();
 5418             temp = op2TempGPR;
 5419         } else {
 5420             op2TempGPR = InvalidGPRReg;
 5421             if (op1GPR == X86Registers::eax)
 5422                 temp = X86Registers::edx;
 5423             else
 5424                 temp = X86Registers::eax;
 5425         }
 5426 
 5427         if (op1GPR == X86Registers::eax || op1GPR == X86Registers::edx) {
 5428             op1SaveGPR = allocate();
 5429             ASSERT(op1GPR != op1SaveGPR);
 5430             m_jit.move(op1GPR, op1SaveGPR);
 5431         } else
 5432             op1SaveGPR = op1GPR;
 5433 
 5434         ASSERT(temp != op1GPR);
 5435         ASSERT(temp != op2GPR);
 5436         ASSERT(op1SaveGPR != X86Registers::eax);
 5437         ASSERT(op1SaveGPR != X86Registers::edx);
 5438 
 5439         m_jit.add32(JITCompiler::TrustedImm32(1), op2GPR, temp);
 5440 
 5441         JITCompiler::Jump safeDenominator = m_jit.branch32(JITCompiler::Above, temp, JITCompiler::TrustedImm32(1));
 5442 
 5443         JITCompiler::JumpList done;
 5444 
 5445         // FIXME: -2^31 / -1 will actually yield negative zero, so we could have a
 5446         // separate case for that. But it probably doesn&#39;t matter so much.
 5447         if (shouldCheckOverflow(node-&gt;arithMode())) {
 5448             speculationCheck(Overflow, JSValueRegs(), 0, m_jit.branchTest32(JITCompiler::Zero, op2GPR));
 5449             speculationCheck(Overflow, JSValueRegs(), 0, m_jit.branch32(JITCompiler::Equal, op1GPR, TrustedImm32(-2147483647-1)));
 5450         } else {
 5451             // This is the case where we convert the result to an int after we&#39;re done, and we
 5452             // already know that the denominator is either -1 or 0. So, if the denominator is
 5453             // zero, then the result should be zero. If the denominator is not zero (i.e. it&#39;s
 5454             // -1) and the numerator is -2^31 then the result should be 0. Otherwise we are
 5455             // happy to fall through to a normal division, since we&#39;re just dividing something
 5456             // by negative 1.
 5457 
 5458             JITCompiler::Jump notZero = m_jit.branchTest32(JITCompiler::NonZero, op2GPR);
 5459             m_jit.move(TrustedImm32(0), edx.gpr());
 5460             done.append(m_jit.jump());
 5461 
 5462             notZero.link(&amp;m_jit);
 5463             JITCompiler::Jump notNeg2ToThe31 =
 5464                 m_jit.branch32(JITCompiler::NotEqual, op1GPR, TrustedImm32(-2147483647-1));
 5465             m_jit.move(TrustedImm32(0), edx.gpr());
 5466             done.append(m_jit.jump());
 5467 
 5468             notNeg2ToThe31.link(&amp;m_jit);
 5469         }
 5470 
 5471         safeDenominator.link(&amp;m_jit);
 5472 
 5473         if (op2TempGPR != InvalidGPRReg) {
 5474             m_jit.move(op2GPR, op2TempGPR);
 5475             op2GPR = op2TempGPR;
 5476         }
 5477 
 5478         m_jit.move(op1GPR, eax.gpr());
 5479         m_jit.x86ConvertToDoubleWord32();
 5480         m_jit.x86Div32(op2GPR);
 5481 
 5482         if (op2TempGPR != InvalidGPRReg)
 5483             unlock(op2TempGPR);
 5484 
 5485         // Check that we&#39;re not about to create negative zero.
 5486         if (shouldCheckNegativeZero(node-&gt;arithMode())) {
 5487             JITCompiler::Jump numeratorPositive = m_jit.branch32(JITCompiler::GreaterThanOrEqual, op1SaveGPR, TrustedImm32(0));
 5488             speculationCheck(Overflow, JSValueRegs(), 0, m_jit.branchTest32(JITCompiler::Zero, edx.gpr()));
 5489             numeratorPositive.link(&amp;m_jit);
 5490         }
 5491 
 5492         if (op1SaveGPR != op1GPR)
 5493             unlock(op1SaveGPR);
 5494 
 5495         done.link(&amp;m_jit);
 5496         int32Result(edx.gpr(), node);
 5497 
 5498 #elif HAVE(ARM_IDIV_INSTRUCTIONS) || CPU(ARM64)
 5499         GPRTemporary temp(this);
 5500         GPRTemporary quotientThenRemainder(this);
 5501         GPRTemporary multiplyAnswer(this);
 5502         GPRReg dividendGPR = op1.gpr();
 5503         GPRReg divisorGPR = op2.gpr();
 5504         GPRReg quotientThenRemainderGPR = quotientThenRemainder.gpr();
 5505         GPRReg multiplyAnswerGPR = multiplyAnswer.gpr();
 5506 
 5507         JITCompiler::JumpList done;
 5508 
 5509         if (shouldCheckOverflow(node-&gt;arithMode()))
 5510             speculationCheck(Overflow, JSValueRegs(), 0, m_jit.branchTest32(JITCompiler::Zero, divisorGPR));
 5511         else {
 5512             JITCompiler::Jump denominatorNotZero = m_jit.branchTest32(JITCompiler::NonZero, divisorGPR);
 5513             // We know that the low 32-bit of divisorGPR is 0, but we don&#39;t know if the high bits are.
 5514             // So, use TrustedImm32(0) on ARM instead because done expects the result to be in DataFormatInt32.
 5515             // Using an immediate 0 doesn&#39;t cost anything extra on ARM.
 5516             m_jit.move(TrustedImm32(0), quotientThenRemainderGPR);
 5517             done.append(m_jit.jump());
 5518             denominatorNotZero.link(&amp;m_jit);
 5519         }
 5520 
 5521         m_jit.assembler().sdiv&lt;32&gt;(quotientThenRemainderGPR, dividendGPR, divisorGPR);
 5522         // FIXME: It seems like there are cases where we don&#39;t need this? What if we have
 5523         // arithMode() == Arith::Unchecked?
 5524         // https://bugs.webkit.org/show_bug.cgi?id=126444
 5525         speculationCheck(Overflow, JSValueRegs(), 0, m_jit.branchMul32(JITCompiler::Overflow, quotientThenRemainderGPR, divisorGPR, multiplyAnswerGPR));
 5526 #if HAVE(ARM_IDIV_INSTRUCTIONS)
 5527         m_jit.assembler().sub(quotientThenRemainderGPR, dividendGPR, multiplyAnswerGPR);
 5528 #else
 5529         m_jit.assembler().sub&lt;32&gt;(quotientThenRemainderGPR, dividendGPR, multiplyAnswerGPR);
 5530 #endif
 5531 
 5532         // If the user cares about negative zero, then speculate that we&#39;re not about
 5533         // to produce negative zero.
 5534         if (shouldCheckNegativeZero(node-&gt;arithMode())) {
 5535             // Check that we&#39;re not about to create negative zero.
 5536             JITCompiler::Jump numeratorPositive = m_jit.branch32(JITCompiler::GreaterThanOrEqual, dividendGPR, TrustedImm32(0));
 5537             speculationCheck(Overflow, JSValueRegs(), 0, m_jit.branchTest32(JITCompiler::Zero, quotientThenRemainderGPR));
 5538             numeratorPositive.link(&amp;m_jit);
 5539         }
 5540 
 5541         done.link(&amp;m_jit);
 5542 
 5543         int32Result(quotientThenRemainderGPR, node);
 5544 #else // not architecture that can do integer division
 5545         RELEASE_ASSERT_NOT_REACHED();
 5546 #endif
 5547         return;
 5548     }
 5549 
 5550     case DoubleRepUse: {
 5551         SpeculateDoubleOperand op1(this, node-&gt;child1());
 5552         SpeculateDoubleOperand op2(this, node-&gt;child2());
 5553 
 5554         FPRReg op1FPR = op1.fpr();
 5555         FPRReg op2FPR = op2.fpr();
 5556 
 5557         flushRegisters();
 5558 
 5559         FPRResult result(this);
 5560 
 5561         using OperationType = D_JITOperation_DD;
 5562         callOperation&lt;OperationType&gt;(jsMod, result.fpr(), op1FPR, op2FPR);
 5563 
 5564         doubleResult(result.fpr(), node);
 5565         return;
 5566     }
 5567 
 5568     default:
 5569         RELEASE_ASSERT_NOT_REACHED();
 5570         return;
 5571     }
 5572 }
 5573 
 5574 void SpeculativeJIT::compileArithRounding(Node* node)
 5575 {
 5576     if (node-&gt;child1().useKind() == DoubleRepUse) {
 5577         SpeculateDoubleOperand value(this, node-&gt;child1());
 5578         FPRReg valueFPR = value.fpr();
 5579 
 5580         auto setResult = [&amp;] (FPRReg resultFPR) {
 5581             if (producesInteger(node-&gt;arithRoundingMode())) {
 5582                 GPRTemporary roundedResultAsInt32(this);
 5583                 FPRTemporary scratch(this);
 5584                 FPRReg scratchFPR = scratch.fpr();
 5585                 GPRReg resultGPR = roundedResultAsInt32.gpr();
 5586                 JITCompiler::JumpList failureCases;
 5587                 m_jit.branchConvertDoubleToInt32(resultFPR, resultGPR, failureCases, scratchFPR, shouldCheckNegativeZero(node-&gt;arithRoundingMode()));
 5588                 speculationCheck(Overflow, JSValueRegs(), node, failureCases);
 5589 
 5590                 int32Result(resultGPR, node);
 5591             } else
 5592                 doubleResult(resultFPR, node);
 5593         };
 5594 
 5595         if (m_jit.supportsFloatingPointRounding()) {
 5596             switch (node-&gt;op()) {
 5597             case ArithRound: {
 5598                 FPRTemporary result(this);
 5599                 FPRReg resultFPR = result.fpr();
 5600                 if (producesInteger(node-&gt;arithRoundingMode()) &amp;&amp; !shouldCheckNegativeZero(node-&gt;arithRoundingMode())) {
 5601                     static const double halfConstant = 0.5;
 5602                     m_jit.loadDouble(TrustedImmPtr(&amp;halfConstant), resultFPR);
 5603                     m_jit.addDouble(valueFPR, resultFPR);
 5604                     m_jit.floorDouble(resultFPR, resultFPR);
 5605                 } else {
 5606                     m_jit.ceilDouble(valueFPR, resultFPR);
 5607                     FPRTemporary realPart(this);
 5608                     FPRReg realPartFPR = realPart.fpr();
 5609                     m_jit.subDouble(resultFPR, valueFPR, realPartFPR);
 5610 
 5611                     FPRTemporary scratch(this);
 5612                     FPRReg scratchFPR = scratch.fpr();
 5613                     static const double halfConstant = 0.5;
 5614                     m_jit.loadDouble(TrustedImmPtr(&amp;halfConstant), scratchFPR);
 5615 
 5616                     JITCompiler::Jump shouldUseCeiled = m_jit.branchDouble(JITCompiler::DoubleLessThanOrEqual, realPartFPR, scratchFPR);
 5617                     static const double oneConstant = -1.0;
 5618                     m_jit.loadDouble(TrustedImmPtr(&amp;oneConstant), scratchFPR);
 5619                     m_jit.addDouble(scratchFPR, resultFPR);
 5620                     shouldUseCeiled.link(&amp;m_jit);
 5621                 }
 5622                 setResult(resultFPR);
 5623                 return;
 5624             }
 5625 
 5626             case ArithFloor: {
 5627                 FPRTemporary rounded(this);
 5628                 FPRReg resultFPR = rounded.fpr();
 5629                 m_jit.floorDouble(valueFPR, resultFPR);
 5630                 setResult(resultFPR);
 5631                 return;
 5632             }
 5633 
 5634             case ArithCeil: {
 5635                 FPRTemporary rounded(this);
 5636                 FPRReg resultFPR = rounded.fpr();
 5637                 m_jit.ceilDouble(valueFPR, resultFPR);
 5638                 setResult(resultFPR);
 5639                 return;
 5640             }
 5641 
 5642             case ArithTrunc: {
 5643                 FPRTemporary rounded(this);
 5644                 FPRReg resultFPR = rounded.fpr();
 5645                 m_jit.roundTowardZeroDouble(valueFPR, resultFPR);
 5646                 setResult(resultFPR);
 5647                 return;
 5648             }
 5649 
 5650             default:
 5651                 RELEASE_ASSERT_NOT_REACHED();
 5652             }
 5653         } else {
 5654             flushRegisters();
 5655             FPRResult roundedResultAsDouble(this);
 5656             FPRReg resultFPR = roundedResultAsDouble.fpr();
 5657             using OperationType = D_JITOperation_D;
 5658             if (node-&gt;op() == ArithRound)
 5659                 callOperation&lt;OperationType&gt;(jsRound, resultFPR, valueFPR);
 5660             else if (node-&gt;op() == ArithFloor)
 5661                 callOperation&lt;OperationType&gt;(floor, resultFPR, valueFPR);
 5662             else if (node-&gt;op() == ArithCeil)
 5663                 callOperation&lt;OperationType&gt;(ceil, resultFPR, valueFPR);
 5664             else {
 5665                 ASSERT(node-&gt;op() == ArithTrunc);
 5666                 callOperation&lt;OperationType&gt;(trunc, resultFPR, valueFPR);
 5667             }
 5668             setResult(resultFPR);
 5669         }
 5670         return;
 5671     }
 5672 
 5673     DFG_ASSERT(m_jit.graph(), node, node-&gt;child1().useKind() == UntypedUse, node-&gt;child1().useKind());
 5674 
 5675     JSValueOperand argument(this, node-&gt;child1());
 5676     JSValueRegs argumentRegs = argument.jsValueRegs();
 5677 
 5678     flushRegisters();
 5679     JSValueRegsFlushedCallResult result(this);
 5680     JSValueRegs resultRegs = result.regs();
 5681     J_JITOperation_EJ operation = nullptr;
 5682     if (node-&gt;op() == ArithRound)
 5683         operation = operationArithRound;
 5684     else if (node-&gt;op() == ArithFloor)
 5685         operation = operationArithFloor;
 5686     else if (node-&gt;op() == ArithCeil)
 5687         operation = operationArithCeil;
 5688     else {
 5689         ASSERT(node-&gt;op() == ArithTrunc);
 5690         operation = operationArithTrunc;
 5691     }
 5692     callOperation(operation, resultRegs, argumentRegs);
 5693     m_jit.exceptionCheck();
 5694     jsValueResult(resultRegs, node);
 5695 }
 5696 
 5697 void SpeculativeJIT::compileArithUnary(Node* node)
 5698 {
 5699     compileArithDoubleUnaryOp(node, arithUnaryFunction(node-&gt;arithUnaryType()), arithUnaryOperation(node-&gt;arithUnaryType()));
 5700 }
 5701 
 5702 void SpeculativeJIT::compileArithSqrt(Node* node)
 5703 {
 5704     if (node-&gt;child1().useKind() == DoubleRepUse) {
 5705         SpeculateDoubleOperand op1(this, node-&gt;child1());
 5706         FPRReg op1FPR = op1.fpr();
 5707 
 5708         if (!MacroAssembler::supportsFloatingPointSqrt() || !Options::useArchitectureSpecificOptimizations()) {
 5709             flushRegisters();
 5710             FPRResult result(this);
 5711             callOperation&lt;D_JITOperation_D&gt;(sqrt, result.fpr(), op1FPR);
 5712             doubleResult(result.fpr(), node);
 5713         } else {
 5714             FPRTemporary result(this, op1);
 5715             m_jit.sqrtDouble(op1.fpr(), result.fpr());
 5716             doubleResult(result.fpr(), node);
 5717         }
 5718         return;
 5719     }
 5720 
 5721     JSValueOperand op1(this, node-&gt;child1());
 5722     JSValueRegs op1Regs = op1.jsValueRegs();
 5723     flushRegisters();
 5724     FPRResult result(this);
 5725     callOperation(operationArithSqrt, result.fpr(), op1Regs);
 5726     m_jit.exceptionCheck();
 5727     doubleResult(result.fpr(), node);
 5728 }
 5729 
 5730 void SpeculativeJIT::compileArithMinMax(Node* node)
 5731 {
 5732     switch (node-&gt;binaryUseKind()) {
 5733     case Int32Use: {
 5734         SpeculateStrictInt32Operand op1(this, node-&gt;child1());
 5735         SpeculateStrictInt32Operand op2(this, node-&gt;child2());
 5736         GPRTemporary result(this, Reuse, op1);
 5737 
 5738         GPRReg op1GPR = op1.gpr();
 5739         GPRReg op2GPR = op2.gpr();
 5740         GPRReg resultGPR = result.gpr();
 5741 
 5742         MacroAssembler::Jump op1Less = m_jit.branch32(node-&gt;op() == ArithMin ? MacroAssembler::LessThan : MacroAssembler::GreaterThan, op1GPR, op2GPR);
 5743         m_jit.move(op2GPR, resultGPR);
 5744         if (op1GPR != resultGPR) {
 5745             MacroAssembler::Jump done = m_jit.jump();
 5746             op1Less.link(&amp;m_jit);
 5747             m_jit.move(op1GPR, resultGPR);
 5748             done.link(&amp;m_jit);
 5749         } else
 5750             op1Less.link(&amp;m_jit);
 5751 
 5752         int32Result(resultGPR, node);
 5753         break;
 5754     }
 5755 
 5756     case DoubleRepUse: {
 5757         SpeculateDoubleOperand op1(this, node-&gt;child1());
 5758         SpeculateDoubleOperand op2(this, node-&gt;child2());
 5759         FPRTemporary result(this, op1);
 5760 
 5761         FPRReg op1FPR = op1.fpr();
 5762         FPRReg op2FPR = op2.fpr();
 5763         FPRReg resultFPR = result.fpr();
 5764 
 5765         MacroAssembler::JumpList done;
 5766 
 5767         MacroAssembler::Jump op1Less = m_jit.branchDouble(node-&gt;op() == ArithMin ? MacroAssembler::DoubleLessThan : MacroAssembler::DoubleGreaterThan, op1FPR, op2FPR);
 5768 
 5769         // op2 is eather the lesser one or one of then is NaN
 5770         MacroAssembler::Jump op2Less = m_jit.branchDouble(node-&gt;op() == ArithMin ? MacroAssembler::DoubleGreaterThanOrEqual : MacroAssembler::DoubleLessThanOrEqual, op1FPR, op2FPR);
 5771 
 5772         // Unordered case. We don&#39;t know which of op1, op2 is NaN. Manufacture NaN by adding
 5773         // op1 + op2 and putting it into result.
 5774         m_jit.addDouble(op1FPR, op2FPR, resultFPR);
 5775         done.append(m_jit.jump());
 5776 
 5777         op2Less.link(&amp;m_jit);
 5778         m_jit.moveDouble(op2FPR, resultFPR);
 5779 
 5780         if (op1FPR != resultFPR) {
 5781             done.append(m_jit.jump());
 5782 
 5783             op1Less.link(&amp;m_jit);
 5784             m_jit.moveDouble(op1FPR, resultFPR);
 5785         } else
 5786             op1Less.link(&amp;m_jit);
 5787 
 5788         done.link(&amp;m_jit);
 5789 
 5790         doubleResult(resultFPR, node);
 5791         break;
 5792     }
 5793 
 5794     default:
 5795         DFG_CRASH(m_jit.graph(), node, &quot;Bad use kind&quot;);
 5796         break;
 5797     }
 5798 }
 5799 
 5800 // For small positive integers , it is worth doing a tiny inline loop to exponentiate the base.
 5801 // Every register is clobbered by this helper.
 5802 static MacroAssembler::Jump compileArithPowIntegerFastPath(JITCompiler&amp; assembler, FPRReg xOperand, GPRReg yOperand, FPRReg result)
 5803 {
 5804     MacroAssembler::JumpList skipFastPath;
 5805     skipFastPath.append(assembler.branch32(MacroAssembler::Above, yOperand, MacroAssembler::TrustedImm32(maxExponentForIntegerMathPow)));
 5806 
 5807     static const double oneConstant = 1.0;
 5808     assembler.loadDouble(MacroAssembler::TrustedImmPtr(&amp;oneConstant), result);
 5809 
 5810     MacroAssembler::Label startLoop(assembler.label());
 5811     MacroAssembler::Jump exponentIsEven = assembler.branchTest32(MacroAssembler::Zero, yOperand, MacroAssembler::TrustedImm32(1));
 5812     assembler.mulDouble(xOperand, result);
 5813     exponentIsEven.link(&amp;assembler);
 5814     assembler.mulDouble(xOperand, xOperand);
 5815     assembler.rshift32(MacroAssembler::TrustedImm32(1), yOperand);
 5816     assembler.branchTest32(MacroAssembler::NonZero, yOperand).linkTo(startLoop, &amp;assembler);
 5817 
 5818     MacroAssembler::Jump skipSlowPath = assembler.jump();
 5819     skipFastPath.link(&amp;assembler);
 5820 
 5821     return skipSlowPath;
 5822 }
 5823 
<a name="56" id="anc56"></a><span class="line-added"> 5824 void SpeculativeJIT::compileValuePow(Node* node)</span>
<span class="line-added"> 5825 {</span>
<span class="line-added"> 5826     Edge&amp; leftChild = node-&gt;child1();</span>
<span class="line-added"> 5827     Edge&amp; rightChild = node-&gt;child2();</span>
<span class="line-added"> 5828 </span>
<span class="line-added"> 5829     if (node-&gt;binaryUseKind() == BigIntUse) {</span>
<span class="line-added"> 5830         SpeculateCellOperand left(this, leftChild);</span>
<span class="line-added"> 5831         SpeculateCellOperand right(this, rightChild);</span>
<span class="line-added"> 5832         GPRReg leftGPR = left.gpr();</span>
<span class="line-added"> 5833         GPRReg rightGPR = right.gpr();</span>
<span class="line-added"> 5834 </span>
<span class="line-added"> 5835         speculateBigInt(leftChild, leftGPR);</span>
<span class="line-added"> 5836         speculateBigInt(rightChild, rightGPR);</span>
<span class="line-added"> 5837 </span>
<span class="line-added"> 5838         flushRegisters();</span>
<span class="line-added"> 5839         GPRFlushedCallResult result(this);</span>
<span class="line-added"> 5840         GPRReg resultGPR = result.gpr();</span>
<span class="line-added"> 5841 </span>
<span class="line-added"> 5842         callOperation(operationPowBigInt, resultGPR, leftGPR, rightGPR);</span>
<span class="line-added"> 5843 </span>
<span class="line-added"> 5844         m_jit.exceptionCheck();</span>
<span class="line-added"> 5845         cellResult(resultGPR, node);</span>
<span class="line-added"> 5846         return;</span>
<span class="line-added"> 5847     }</span>
<span class="line-added"> 5848 </span>
<span class="line-added"> 5849     DFG_ASSERT(m_jit.graph(), node, node-&gt;binaryUseKind() == UntypedUse, node-&gt;binaryUseKind());</span>
<span class="line-added"> 5850 </span>
<span class="line-added"> 5851     JSValueOperand left(this, leftChild);</span>
<span class="line-added"> 5852     JSValueOperand right(this, rightChild);</span>
<span class="line-added"> 5853     JSValueRegs leftRegs = left.jsValueRegs();</span>
<span class="line-added"> 5854     JSValueRegs rightRegs = right.jsValueRegs();</span>
<span class="line-added"> 5855 </span>
<span class="line-added"> 5856     flushRegisters();</span>
<span class="line-added"> 5857     JSValueRegsFlushedCallResult result(this);</span>
<span class="line-added"> 5858     JSValueRegs resultRegs = result.regs();</span>
<span class="line-added"> 5859     callOperation(operationValuePow, resultRegs, leftRegs, rightRegs);</span>
<span class="line-added"> 5860     m_jit.exceptionCheck();</span>
<span class="line-added"> 5861 </span>
<span class="line-added"> 5862     jsValueResult(resultRegs, node);</span>
<span class="line-added"> 5863 }</span>
<span class="line-added"> 5864 </span>
 5865 void SpeculativeJIT::compileArithPow(Node* node)
 5866 {
 5867     if (node-&gt;child2().useKind() == Int32Use) {
 5868         SpeculateDoubleOperand xOperand(this, node-&gt;child1());
 5869         SpeculateInt32Operand yOperand(this, node-&gt;child2());
 5870         FPRReg xOperandfpr = xOperand.fpr();
 5871         GPRReg yOperandGpr = yOperand.gpr();
 5872         FPRTemporary yOperandfpr(this);
 5873 
 5874         flushRegisters();
 5875 
 5876         FPRResult result(this);
 5877         FPRReg resultFpr = result.fpr();
 5878 
 5879         FPRTemporary xOperandCopy(this);
 5880         FPRReg xOperandCopyFpr = xOperandCopy.fpr();
 5881         m_jit.moveDouble(xOperandfpr, xOperandCopyFpr);
 5882 
 5883         GPRTemporary counter(this);
 5884         GPRReg counterGpr = counter.gpr();
 5885         m_jit.move(yOperandGpr, counterGpr);
 5886 
 5887         MacroAssembler::Jump skipFallback = compileArithPowIntegerFastPath(m_jit, xOperandCopyFpr, counterGpr, resultFpr);
 5888         m_jit.convertInt32ToDouble(yOperandGpr, yOperandfpr.fpr());
 5889         callOperation(operationMathPow, resultFpr, xOperandfpr, yOperandfpr.fpr());
 5890 
 5891         skipFallback.link(&amp;m_jit);
 5892         doubleResult(resultFpr, node);
 5893         return;
 5894     }
 5895 
 5896     if (node-&gt;child2()-&gt;isDoubleConstant()) {
 5897         double exponent = node-&gt;child2()-&gt;asNumber();
 5898         static const double infinityConstant = std::numeric_limits&lt;double&gt;::infinity();
 5899         static const double minusInfinityConstant = -std::numeric_limits&lt;double&gt;::infinity();
 5900         if (exponent == 0.5) {
 5901             SpeculateDoubleOperand xOperand(this, node-&gt;child1());
 5902             FPRTemporary result(this);
 5903             FPRReg xOperandFpr = xOperand.fpr();
 5904             FPRReg resultFpr = result.fpr();
 5905 
 5906             m_jit.moveZeroToDouble(resultFpr);
 5907             MacroAssembler::Jump xIsZeroOrNegativeZero = m_jit.branchDouble(MacroAssembler::DoubleEqual, xOperandFpr, resultFpr);
 5908 
 5909             m_jit.loadDouble(TrustedImmPtr(&amp;minusInfinityConstant), resultFpr);
 5910             MacroAssembler::Jump xIsMinusInfinity = m_jit.branchDouble(MacroAssembler::DoubleEqual, xOperandFpr, resultFpr);
 5911             m_jit.sqrtDouble(xOperandFpr, resultFpr);
 5912             MacroAssembler::Jump doneWithSqrt = m_jit.jump();
 5913 
 5914             xIsMinusInfinity.link(&amp;m_jit);
 5915             if (isX86())
 5916                 m_jit.loadDouble(TrustedImmPtr(&amp;infinityConstant), resultFpr);
 5917             else
 5918                 m_jit.absDouble(resultFpr, resultFpr);
 5919 
 5920             xIsZeroOrNegativeZero.link(&amp;m_jit);
 5921             doneWithSqrt.link(&amp;m_jit);
 5922             doubleResult(resultFpr, node);
 5923             return;
 5924         }
 5925         if (exponent == -0.5) {
 5926             SpeculateDoubleOperand xOperand(this, node-&gt;child1());
 5927             FPRTemporary scratch(this);
 5928             FPRTemporary result(this);
 5929             FPRReg xOperandFpr = xOperand.fpr();
 5930             FPRReg scratchFPR = scratch.fpr();
 5931             FPRReg resultFpr = result.fpr();
 5932 
 5933             m_jit.moveZeroToDouble(resultFpr);
 5934             MacroAssembler::Jump xIsZeroOrNegativeZero = m_jit.branchDouble(MacroAssembler::DoubleEqual, xOperandFpr, resultFpr);
 5935 
 5936             m_jit.loadDouble(TrustedImmPtr(&amp;minusInfinityConstant), resultFpr);
 5937             MacroAssembler::Jump xIsMinusInfinity = m_jit.branchDouble(MacroAssembler::DoubleEqual, xOperandFpr, resultFpr);
 5938 
 5939             static const double oneConstant = 1.;
 5940             m_jit.loadDouble(TrustedImmPtr(&amp;oneConstant), resultFpr);
 5941             m_jit.sqrtDouble(xOperandFpr, scratchFPR);
 5942             m_jit.divDouble(resultFpr, scratchFPR, resultFpr);
 5943             MacroAssembler::Jump doneWithSqrt = m_jit.jump();
 5944 
 5945             xIsZeroOrNegativeZero.link(&amp;m_jit);
 5946             m_jit.loadDouble(TrustedImmPtr(&amp;infinityConstant), resultFpr);
 5947             MacroAssembler::Jump doneWithBaseZero = m_jit.jump();
 5948 
 5949             xIsMinusInfinity.link(&amp;m_jit);
 5950             m_jit.moveZeroToDouble(resultFpr);
 5951 
 5952             doneWithBaseZero.link(&amp;m_jit);
 5953             doneWithSqrt.link(&amp;m_jit);
 5954             doubleResult(resultFpr, node);
 5955             return;
 5956         }
 5957     }
 5958 
 5959     SpeculateDoubleOperand xOperand(this, node-&gt;child1());
 5960     SpeculateDoubleOperand yOperand(this, node-&gt;child2());
 5961     FPRReg xOperandfpr = xOperand.fpr();
 5962     FPRReg yOperandfpr = yOperand.fpr();
 5963 
 5964     flushRegisters();
 5965 
 5966     FPRResult result(this);
 5967     FPRReg resultFpr = result.fpr();
 5968 
 5969     FPRTemporary xOperandCopy(this);
 5970     FPRReg xOperandCopyFpr = xOperandCopy.fpr();
 5971 
 5972     FPRTemporary scratch(this);
 5973     FPRReg scratchFpr = scratch.fpr();
 5974 
 5975     GPRTemporary yOperandInteger(this);
 5976     GPRReg yOperandIntegerGpr = yOperandInteger.gpr();
 5977     MacroAssembler::JumpList failedExponentConversionToInteger;
 5978     m_jit.branchConvertDoubleToInt32(yOperandfpr, yOperandIntegerGpr, failedExponentConversionToInteger, scratchFpr, false);
 5979 
 5980     m_jit.moveDouble(xOperandfpr, xOperandCopyFpr);
 5981     MacroAssembler::Jump skipFallback = compileArithPowIntegerFastPath(m_jit, xOperandCopyFpr, yOperandInteger.gpr(), resultFpr);
 5982     failedExponentConversionToInteger.link(&amp;m_jit);
 5983 
 5984     callOperation(operationMathPow, resultFpr, xOperandfpr, yOperandfpr);
 5985     skipFallback.link(&amp;m_jit);
 5986     doubleResult(resultFpr, node);
 5987 }
 5988 
 5989 // Returns true if the compare is fused with a subsequent branch.
 5990 bool SpeculativeJIT::compare(Node* node, MacroAssembler::RelationalCondition condition, MacroAssembler::DoubleCondition doubleCondition, S_JITOperation_EJJ operation)
 5991 {
 5992     if (compilePeepHoleBranch(node, condition, doubleCondition, operation))
 5993         return true;
 5994 
 5995     if (node-&gt;isBinaryUseKind(Int32Use)) {
 5996         compileInt32Compare(node, condition);
 5997         return false;
 5998     }
 5999 
 6000 #if USE(JSVALUE64)
 6001     if (node-&gt;isBinaryUseKind(Int52RepUse)) {
 6002         compileInt52Compare(node, condition);
 6003         return false;
 6004     }
 6005 #endif // USE(JSVALUE64)
 6006 
 6007     if (node-&gt;isBinaryUseKind(DoubleRepUse)) {
 6008         compileDoubleCompare(node, doubleCondition);
 6009         return false;
 6010     }
 6011 
 6012     if (node-&gt;isBinaryUseKind(StringUse)) {
 6013         if (node-&gt;op() == CompareEq)
 6014             compileStringEquality(node);
 6015         else
 6016             compileStringCompare(node, condition);
 6017         return false;
 6018     }
 6019 
 6020     if (node-&gt;isBinaryUseKind(StringIdentUse)) {
 6021         if (node-&gt;op() == CompareEq)
 6022             compileStringIdentEquality(node);
 6023         else
 6024             compileStringIdentCompare(node, condition);
 6025         return false;
 6026     }
 6027 
 6028     if (node-&gt;op() == CompareEq) {
 6029         if (node-&gt;isBinaryUseKind(BooleanUse)) {
 6030             compileBooleanCompare(node, condition);
 6031             return false;
 6032         }
 6033 
 6034         if (node-&gt;isBinaryUseKind(SymbolUse)) {
 6035             compileSymbolEquality(node);
 6036             return false;
 6037         }
 6038 
 6039         if (node-&gt;isBinaryUseKind(ObjectUse)) {
 6040             compileObjectEquality(node);
 6041             return false;
 6042         }
 6043 
 6044         if (node-&gt;isBinaryUseKind(ObjectUse, ObjectOrOtherUse)) {
 6045             compileObjectToObjectOrOtherEquality(node-&gt;child1(), node-&gt;child2());
 6046             return false;
 6047         }
 6048 
 6049         if (node-&gt;isBinaryUseKind(ObjectOrOtherUse, ObjectUse)) {
 6050             compileObjectToObjectOrOtherEquality(node-&gt;child2(), node-&gt;child1());
 6051             return false;
 6052         }
 6053 
 6054         if (!needsTypeCheck(node-&gt;child1(), SpecOther)) {
 6055             nonSpeculativeNonPeepholeCompareNullOrUndefined(node-&gt;child2());
 6056             return false;
 6057         }
 6058 
 6059         if (!needsTypeCheck(node-&gt;child2(), SpecOther)) {
 6060             nonSpeculativeNonPeepholeCompareNullOrUndefined(node-&gt;child1());
 6061             return false;
 6062         }
 6063     }
 6064 
 6065     nonSpeculativeNonPeepholeCompare(node, condition, operation);
 6066     return false;
 6067 }
 6068 
 6069 void SpeculativeJIT::compileCompareUnsigned(Node* node, MacroAssembler::RelationalCondition condition)
 6070 {
 6071     compileInt32Compare(node, condition);
 6072 }
 6073 
 6074 bool SpeculativeJIT::compileStrictEq(Node* node)
 6075 {
 6076     if (node-&gt;isBinaryUseKind(BooleanUse)) {
 6077         unsigned branchIndexInBlock = detectPeepHoleBranch();
 6078         if (branchIndexInBlock != UINT_MAX) {
 6079             Node* branchNode = m_block-&gt;at(branchIndexInBlock);
 6080             compilePeepHoleBooleanBranch(node, branchNode, MacroAssembler::Equal);
 6081             use(node-&gt;child1());
 6082             use(node-&gt;child2());
 6083             m_indexInBlock = branchIndexInBlock;
 6084             m_currentNode = branchNode;
 6085             return true;
 6086         }
 6087         compileBooleanCompare(node, MacroAssembler::Equal);
 6088         return false;
 6089     }
 6090 
 6091     if (node-&gt;isBinaryUseKind(Int32Use)) {
 6092         unsigned branchIndexInBlock = detectPeepHoleBranch();
 6093         if (branchIndexInBlock != UINT_MAX) {
 6094             Node* branchNode = m_block-&gt;at(branchIndexInBlock);
 6095             compilePeepHoleInt32Branch(node, branchNode, MacroAssembler::Equal);
 6096             use(node-&gt;child1());
 6097             use(node-&gt;child2());
 6098             m_indexInBlock = branchIndexInBlock;
 6099             m_currentNode = branchNode;
 6100             return true;
 6101         }
 6102         compileInt32Compare(node, MacroAssembler::Equal);
 6103         return false;
 6104     }
 6105 
 6106 #if USE(JSVALUE64)
 6107     if (node-&gt;isBinaryUseKind(Int52RepUse)) {
 6108         unsigned branchIndexInBlock = detectPeepHoleBranch();
 6109         if (branchIndexInBlock != UINT_MAX) {
 6110             Node* branchNode = m_block-&gt;at(branchIndexInBlock);
 6111             compilePeepHoleInt52Branch(node, branchNode, MacroAssembler::Equal);
 6112             use(node-&gt;child1());
 6113             use(node-&gt;child2());
 6114             m_indexInBlock = branchIndexInBlock;
 6115             m_currentNode = branchNode;
 6116             return true;
 6117         }
 6118         compileInt52Compare(node, MacroAssembler::Equal);
 6119         return false;
 6120     }
 6121 #endif // USE(JSVALUE64)
 6122 
 6123     if (node-&gt;isBinaryUseKind(DoubleRepUse)) {
 6124         unsigned branchIndexInBlock = detectPeepHoleBranch();
 6125         if (branchIndexInBlock != UINT_MAX) {
 6126             Node* branchNode = m_block-&gt;at(branchIndexInBlock);
 6127             compilePeepHoleDoubleBranch(node, branchNode, MacroAssembler::DoubleEqual);
 6128             use(node-&gt;child1());
 6129             use(node-&gt;child2());
 6130             m_indexInBlock = branchIndexInBlock;
 6131             m_currentNode = branchNode;
 6132             return true;
 6133         }
 6134         compileDoubleCompare(node, MacroAssembler::DoubleEqual);
 6135         return false;
 6136     }
 6137 
 6138     if (node-&gt;isBinaryUseKind(SymbolUse)) {
 6139         unsigned branchIndexInBlock = detectPeepHoleBranch();
 6140         if (branchIndexInBlock != UINT_MAX) {
 6141             Node* branchNode = m_block-&gt;at(branchIndexInBlock);
 6142             compilePeepHoleSymbolEquality(node, branchNode);
 6143             use(node-&gt;child1());
 6144             use(node-&gt;child2());
 6145             m_indexInBlock = branchIndexInBlock;
 6146             m_currentNode = branchNode;
 6147             return true;
 6148         }
 6149         compileSymbolEquality(node);
 6150         return false;
 6151     }
 6152 
 6153     if (node-&gt;isBinaryUseKind(BigIntUse)) {
 6154         compileBigIntEquality(node);
 6155         return false;
 6156     }
 6157 
 6158     if (node-&gt;isBinaryUseKind(SymbolUse, UntypedUse)) {
 6159         compileSymbolUntypedEquality(node, node-&gt;child1(), node-&gt;child2());
 6160         return false;
 6161     }
 6162 
 6163     if (node-&gt;isBinaryUseKind(UntypedUse, SymbolUse)) {
 6164         compileSymbolUntypedEquality(node, node-&gt;child2(), node-&gt;child1());
 6165         return false;
 6166     }
 6167 
 6168     if (node-&gt;isBinaryUseKind(StringUse)) {
 6169         compileStringEquality(node);
 6170         return false;
 6171     }
 6172 
 6173     if (node-&gt;isBinaryUseKind(StringIdentUse)) {
 6174         compileStringIdentEquality(node);
 6175         return false;
 6176     }
 6177 
 6178     if (node-&gt;isBinaryUseKind(ObjectUse, UntypedUse)) {
 6179         unsigned branchIndexInBlock = detectPeepHoleBranch();
 6180         if (branchIndexInBlock != UINT_MAX) {
 6181             Node* branchNode = m_block-&gt;at(branchIndexInBlock);
 6182             compilePeepHoleObjectStrictEquality(node-&gt;child1(), node-&gt;child2(), branchNode);
 6183             use(node-&gt;child1());
 6184             use(node-&gt;child2());
 6185             m_indexInBlock = branchIndexInBlock;
 6186             m_currentNode = branchNode;
 6187             return true;
 6188         }
 6189         compileObjectStrictEquality(node-&gt;child1(), node-&gt;child2());
 6190         return false;
 6191     }
 6192 
 6193     if (node-&gt;isBinaryUseKind(UntypedUse, ObjectUse)) {
 6194         unsigned branchIndexInBlock = detectPeepHoleBranch();
 6195         if (branchIndexInBlock != UINT_MAX) {
 6196             Node* branchNode = m_block-&gt;at(branchIndexInBlock);
 6197             compilePeepHoleObjectStrictEquality(node-&gt;child2(), node-&gt;child1(), branchNode);
 6198             use(node-&gt;child1());
 6199             use(node-&gt;child2());
 6200             m_indexInBlock = branchIndexInBlock;
 6201             m_currentNode = branchNode;
 6202             return true;
 6203         }
 6204         compileObjectStrictEquality(node-&gt;child2(), node-&gt;child1());
 6205         return false;
 6206     }
 6207 
 6208     if (node-&gt;isBinaryUseKind(ObjectUse)) {
 6209         unsigned branchIndexInBlock = detectPeepHoleBranch();
 6210         if (branchIndexInBlock != UINT_MAX) {
 6211             Node* branchNode = m_block-&gt;at(branchIndexInBlock);
 6212             compilePeepHoleObjectEquality(node, branchNode);
 6213             use(node-&gt;child1());
 6214             use(node-&gt;child2());
 6215             m_indexInBlock = branchIndexInBlock;
 6216             m_currentNode = branchNode;
 6217             return true;
 6218         }
 6219         compileObjectEquality(node);
 6220         return false;
 6221     }
 6222 
 6223     if (node-&gt;isBinaryUseKind(MiscUse, UntypedUse)
 6224         || node-&gt;isBinaryUseKind(UntypedUse, MiscUse)) {
 6225         compileMiscStrictEq(node);
 6226         return false;
 6227     }
 6228 
 6229     if (node-&gt;isBinaryUseKind(StringIdentUse, NotStringVarUse)) {
 6230         compileStringIdentToNotStringVarEquality(node, node-&gt;child1(), node-&gt;child2());
 6231         return false;
 6232     }
 6233 
 6234     if (node-&gt;isBinaryUseKind(NotStringVarUse, StringIdentUse)) {
 6235         compileStringIdentToNotStringVarEquality(node, node-&gt;child2(), node-&gt;child1());
 6236         return false;
 6237     }
 6238 
 6239     if (node-&gt;isBinaryUseKind(StringUse, UntypedUse)) {
 6240         compileStringToUntypedEquality(node, node-&gt;child1(), node-&gt;child2());
 6241         return false;
 6242     }
 6243 
 6244     if (node-&gt;isBinaryUseKind(UntypedUse, StringUse)) {
 6245         compileStringToUntypedEquality(node, node-&gt;child2(), node-&gt;child1());
 6246         return false;
 6247     }
 6248 
 6249     RELEASE_ASSERT(node-&gt;isBinaryUseKind(UntypedUse));
 6250     return nonSpeculativeStrictEq(node);
 6251 }
 6252 
 6253 void SpeculativeJIT::compileBooleanCompare(Node* node, MacroAssembler::RelationalCondition condition)
 6254 {
 6255     SpeculateBooleanOperand op1(this, node-&gt;child1());
 6256     SpeculateBooleanOperand op2(this, node-&gt;child2());
 6257     GPRTemporary result(this);
 6258 
 6259     m_jit.compare32(condition, op1.gpr(), op2.gpr(), result.gpr());
 6260 
 6261     unblessedBooleanResult(result.gpr(), node);
 6262 }
 6263 
 6264 void SpeculativeJIT::compileInt32Compare(Node* node, MacroAssembler::RelationalCondition condition)
 6265 {
 6266     if (node-&gt;child1()-&gt;isInt32Constant()) {
 6267         SpeculateInt32Operand op2(this, node-&gt;child2());
 6268         GPRTemporary result(this, Reuse, op2);
 6269         int32_t imm = node-&gt;child1()-&gt;asInt32();
 6270         m_jit.compare32(condition, JITCompiler::Imm32(imm), op2.gpr(), result.gpr());
 6271 
 6272         unblessedBooleanResult(result.gpr(), node);
 6273     } else if (node-&gt;child2()-&gt;isInt32Constant()) {
 6274         SpeculateInt32Operand op1(this, node-&gt;child1());
 6275         GPRTemporary result(this, Reuse, op1);
 6276         int32_t imm = node-&gt;child2()-&gt;asInt32();
 6277         m_jit.compare32(condition, op1.gpr(), JITCompiler::Imm32(imm), result.gpr());
 6278 
 6279         unblessedBooleanResult(result.gpr(), node);
 6280     } else {
 6281         SpeculateInt32Operand op1(this, node-&gt;child1());
 6282         SpeculateInt32Operand op2(this, node-&gt;child2());
 6283         GPRTemporary result(this, Reuse, op1, op2);
 6284         m_jit.compare32(condition, op1.gpr(), op2.gpr(), result.gpr());
 6285 
 6286         unblessedBooleanResult(result.gpr(), node);
 6287     }
 6288 }
 6289 
 6290 void SpeculativeJIT::compileDoubleCompare(Node* node, MacroAssembler::DoubleCondition condition)
 6291 {
 6292     SpeculateDoubleOperand op1(this, node-&gt;child1());
 6293     SpeculateDoubleOperand op2(this, node-&gt;child2());
 6294     GPRTemporary result(this);
 6295 
 6296     FPRReg op1FPR = op1.fpr();
 6297     FPRReg op2FPR = op2.fpr();
 6298     GPRReg resultGPR = result.gpr();
 6299 
 6300     m_jit.compareDouble(condition, op1FPR, op2FPR, resultGPR);
 6301 
 6302     unblessedBooleanResult(resultGPR, node);
 6303 }
 6304 
 6305 void SpeculativeJIT::compileObjectEquality(Node* node)
 6306 {
 6307     SpeculateCellOperand op1(this, node-&gt;child1());
 6308     SpeculateCellOperand op2(this, node-&gt;child2());
 6309     GPRTemporary result(this, Reuse, op1);
 6310 
 6311     GPRReg op1GPR = op1.gpr();
 6312     GPRReg op2GPR = op2.gpr();
 6313     GPRReg resultGPR = result.gpr();
 6314 
 6315     if (masqueradesAsUndefinedWatchpointIsStillValid()) {
 6316         DFG_TYPE_CHECK(
 6317             JSValueSource::unboxedCell(op1GPR), node-&gt;child1(), SpecObject, m_jit.branchIfNotObject(op1GPR));
 6318         DFG_TYPE_CHECK(
 6319             JSValueSource::unboxedCell(op2GPR), node-&gt;child2(), SpecObject, m_jit.branchIfNotObject(op2GPR));
 6320     } else {
 6321         DFG_TYPE_CHECK(
 6322             JSValueSource::unboxedCell(op1GPR), node-&gt;child1(), SpecObject, m_jit.branchIfNotObject(op1GPR));
 6323         speculationCheck(BadType, JSValueSource::unboxedCell(op1GPR), node-&gt;child1(),
 6324             m_jit.branchTest8(
 6325                 MacroAssembler::NonZero,
 6326                 MacroAssembler::Address(op1GPR, JSCell::typeInfoFlagsOffset()),
 6327                 MacroAssembler::TrustedImm32(MasqueradesAsUndefined)));
 6328 
 6329         DFG_TYPE_CHECK(
 6330             JSValueSource::unboxedCell(op2GPR), node-&gt;child2(), SpecObject, m_jit.branchIfNotObject(op2GPR));
 6331         speculationCheck(BadType, JSValueSource::unboxedCell(op2GPR), node-&gt;child2(),
 6332             m_jit.branchTest8(
 6333                 MacroAssembler::NonZero,
 6334                 MacroAssembler::Address(op2GPR, JSCell::typeInfoFlagsOffset()),
 6335                 MacroAssembler::TrustedImm32(MasqueradesAsUndefined)));
 6336     }
 6337 
 6338     m_jit.comparePtr(MacroAssembler::Equal, op1GPR, op2GPR, resultGPR);
 6339     unblessedBooleanResult(resultGPR, node);
 6340 }
 6341 
 6342 void SpeculativeJIT::compileSymbolEquality(Node* node)
 6343 {
 6344     SpeculateCellOperand left(this, node-&gt;child1());
 6345     SpeculateCellOperand right(this, node-&gt;child2());
 6346     GPRTemporary result(this, Reuse, left, right);
 6347 
 6348     GPRReg leftGPR = left.gpr();
 6349     GPRReg rightGPR = right.gpr();
 6350     GPRReg resultGPR = result.gpr();
 6351 
 6352     speculateSymbol(node-&gt;child1(), leftGPR);
 6353     speculateSymbol(node-&gt;child2(), rightGPR);
 6354 
 6355     m_jit.comparePtr(JITCompiler::Equal, leftGPR, rightGPR, resultGPR);
 6356     unblessedBooleanResult(resultGPR, node);
 6357 }
 6358 
 6359 void SpeculativeJIT::compilePeepHoleSymbolEquality(Node* node, Node* branchNode)
 6360 {
 6361     SpeculateCellOperand left(this, node-&gt;child1());
 6362     SpeculateCellOperand right(this, node-&gt;child2());
 6363 
 6364     GPRReg leftGPR = left.gpr();
 6365     GPRReg rightGPR = right.gpr();
 6366 
 6367     speculateSymbol(node-&gt;child1(), leftGPR);
 6368     speculateSymbol(node-&gt;child2(), rightGPR);
 6369 
 6370     BasicBlock* taken = branchNode-&gt;branchData()-&gt;taken.block;
 6371     BasicBlock* notTaken = branchNode-&gt;branchData()-&gt;notTaken.block;
 6372 
 6373     if (taken == nextBlock()) {
 6374         branchPtr(JITCompiler::NotEqual, leftGPR, rightGPR, notTaken);
 6375         jump(taken);
 6376     } else {
 6377         branchPtr(JITCompiler::Equal, leftGPR, rightGPR, taken);
 6378         jump(notTaken);
 6379     }
 6380 }
 6381 
 6382 void SpeculativeJIT::compileStringEquality(
 6383     Node* node, GPRReg leftGPR, GPRReg rightGPR, GPRReg lengthGPR, GPRReg leftTempGPR,
 6384     GPRReg rightTempGPR, GPRReg leftTemp2GPR, GPRReg rightTemp2GPR,
 6385     const JITCompiler::JumpList&amp; fastTrue, const JITCompiler::JumpList&amp; fastFalse)
 6386 {
 6387     JITCompiler::JumpList trueCase;
 6388     JITCompiler::JumpList falseCase;
 6389     JITCompiler::JumpList slowCase;
 6390 
 6391     trueCase.append(fastTrue);
 6392     falseCase.append(fastFalse);
 6393 
 6394     m_jit.loadPtr(MacroAssembler::Address(leftGPR, JSString::offsetOfValue()), leftTempGPR);
 6395     m_jit.loadPtr(MacroAssembler::Address(rightGPR, JSString::offsetOfValue()), rightTempGPR);
 6396 
 6397     slowCase.append(m_jit.branchIfRopeStringImpl(leftTempGPR));
 6398     slowCase.append(m_jit.branchIfRopeStringImpl(rightTempGPR));
 6399 
 6400     m_jit.load32(MacroAssembler::Address(leftTempGPR, StringImpl::lengthMemoryOffset()), lengthGPR);
 6401 
 6402     falseCase.append(m_jit.branch32(
 6403         MacroAssembler::NotEqual,
 6404         MacroAssembler::Address(rightTempGPR, StringImpl::lengthMemoryOffset()),
 6405         lengthGPR));
 6406 
 6407     trueCase.append(m_jit.branchTest32(MacroAssembler::Zero, lengthGPR));
 6408 
 6409     slowCase.append(m_jit.branchTest32(
 6410         MacroAssembler::Zero,
 6411         MacroAssembler::Address(leftTempGPR, StringImpl::flagsOffset()),
 6412         TrustedImm32(StringImpl::flagIs8Bit())));
 6413     slowCase.append(m_jit.branchTest32(
 6414         MacroAssembler::Zero,
 6415         MacroAssembler::Address(rightTempGPR, StringImpl::flagsOffset()),
 6416         TrustedImm32(StringImpl::flagIs8Bit())));
 6417 
 6418     m_jit.loadPtr(MacroAssembler::Address(leftTempGPR, StringImpl::dataOffset()), leftTempGPR);
 6419     m_jit.loadPtr(MacroAssembler::Address(rightTempGPR, StringImpl::dataOffset()), rightTempGPR);
 6420 
 6421     MacroAssembler::Label loop = m_jit.label();
 6422 
 6423     m_jit.sub32(TrustedImm32(1), lengthGPR);
 6424 
 6425     // This isn&#39;t going to generate the best code on x86. But that&#39;s OK, it&#39;s still better
 6426     // than not inlining.
 6427     m_jit.load8(MacroAssembler::BaseIndex(leftTempGPR, lengthGPR, MacroAssembler::TimesOne), leftTemp2GPR);
 6428     m_jit.load8(MacroAssembler::BaseIndex(rightTempGPR, lengthGPR, MacroAssembler::TimesOne), rightTemp2GPR);
 6429     falseCase.append(m_jit.branch32(MacroAssembler::NotEqual, leftTemp2GPR, rightTemp2GPR));
 6430 
 6431     m_jit.branchTest32(MacroAssembler::NonZero, lengthGPR).linkTo(loop, &amp;m_jit);
 6432 
 6433     trueCase.link(&amp;m_jit);
 6434     moveTrueTo(leftTempGPR);
 6435 
 6436     JITCompiler::Jump done = m_jit.jump();
 6437 
 6438     falseCase.link(&amp;m_jit);
 6439     moveFalseTo(leftTempGPR);
 6440 
 6441     done.link(&amp;m_jit);
 6442     addSlowPathGenerator(
 6443         slowPathCall(
 6444             slowCase, this, operationCompareStringEq, leftTempGPR, leftGPR, rightGPR));
 6445 
 6446     blessedBooleanResult(leftTempGPR, node);
 6447 }
 6448 
 6449 void SpeculativeJIT::compileStringEquality(Node* node)
 6450 {
 6451     SpeculateCellOperand left(this, node-&gt;child1());
 6452     SpeculateCellOperand right(this, node-&gt;child2());
 6453     GPRTemporary length(this);
 6454     GPRTemporary leftTemp(this);
 6455     GPRTemporary rightTemp(this);
 6456     GPRTemporary leftTemp2(this, Reuse, left);
 6457     GPRTemporary rightTemp2(this, Reuse, right);
 6458 
 6459     GPRReg leftGPR = left.gpr();
 6460     GPRReg rightGPR = right.gpr();
 6461     GPRReg lengthGPR = length.gpr();
 6462     GPRReg leftTempGPR = leftTemp.gpr();
 6463     GPRReg rightTempGPR = rightTemp.gpr();
 6464     GPRReg leftTemp2GPR = leftTemp2.gpr();
 6465     GPRReg rightTemp2GPR = rightTemp2.gpr();
 6466 
 6467     speculateString(node-&gt;child1(), leftGPR);
 6468 
 6469     // It&#39;s safe to branch around the type check below, since proving that the values are
 6470     // equal does indeed prove that the right value is a string.
 6471     JITCompiler::Jump fastTrue = m_jit.branchPtr(MacroAssembler::Equal, leftGPR, rightGPR);
 6472 
 6473     speculateString(node-&gt;child2(), rightGPR);
 6474 
 6475     compileStringEquality(
 6476         node, leftGPR, rightGPR, lengthGPR, leftTempGPR, rightTempGPR, leftTemp2GPR,
 6477         rightTemp2GPR, fastTrue, JITCompiler::Jump());
 6478 }
 6479 
 6480 void SpeculativeJIT::compileStringToUntypedEquality(Node* node, Edge stringEdge, Edge untypedEdge)
 6481 {
 6482     SpeculateCellOperand left(this, stringEdge);
 6483     JSValueOperand right(this, untypedEdge, ManualOperandSpeculation);
 6484     GPRTemporary length(this);
 6485     GPRTemporary leftTemp(this);
 6486     GPRTemporary rightTemp(this);
 6487     GPRTemporary leftTemp2(this, Reuse, left);
 6488     GPRTemporary rightTemp2(this);
 6489 
 6490     GPRReg leftGPR = left.gpr();
 6491     JSValueRegs rightRegs = right.jsValueRegs();
 6492     GPRReg lengthGPR = length.gpr();
 6493     GPRReg leftTempGPR = leftTemp.gpr();
 6494     GPRReg rightTempGPR = rightTemp.gpr();
 6495     GPRReg leftTemp2GPR = leftTemp2.gpr();
 6496     GPRReg rightTemp2GPR = rightTemp2.gpr();
 6497 
 6498     speculateString(stringEdge, leftGPR);
 6499 
 6500     JITCompiler::JumpList fastTrue;
 6501     JITCompiler::JumpList fastFalse;
 6502 
 6503     fastFalse.append(m_jit.branchIfNotCell(rightRegs));
 6504 
 6505     // It&#39;s safe to branch around the type check below, since proving that the values are
 6506     // equal does indeed prove that the right value is a string.
 6507     fastTrue.append(m_jit.branchPtr(
 6508         MacroAssembler::Equal, leftGPR, rightRegs.payloadGPR()));
 6509 
 6510     fastFalse.append(m_jit.branchIfNotString(rightRegs.payloadGPR()));
 6511 
 6512     compileStringEquality(
 6513         node, leftGPR, rightRegs.payloadGPR(), lengthGPR, leftTempGPR, rightTempGPR, leftTemp2GPR,
 6514         rightTemp2GPR, fastTrue, fastFalse);
 6515 }
 6516 
 6517 void SpeculativeJIT::compileStringIdentEquality(Node* node)
 6518 {
 6519     SpeculateCellOperand left(this, node-&gt;child1());
 6520     SpeculateCellOperand right(this, node-&gt;child2());
 6521     GPRTemporary leftTemp(this);
 6522     GPRTemporary rightTemp(this);
 6523 
 6524     GPRReg leftGPR = left.gpr();
 6525     GPRReg rightGPR = right.gpr();
 6526     GPRReg leftTempGPR = leftTemp.gpr();
 6527     GPRReg rightTempGPR = rightTemp.gpr();
 6528 
 6529     speculateString(node-&gt;child1(), leftGPR);
 6530     speculateString(node-&gt;child2(), rightGPR);
 6531 
 6532     speculateStringIdentAndLoadStorage(node-&gt;child1(), leftGPR, leftTempGPR);
 6533     speculateStringIdentAndLoadStorage(node-&gt;child2(), rightGPR, rightTempGPR);
 6534 
 6535     m_jit.comparePtr(MacroAssembler::Equal, leftTempGPR, rightTempGPR, leftTempGPR);
 6536 
 6537     unblessedBooleanResult(leftTempGPR, node);
 6538 }
 6539 
 6540 void SpeculativeJIT::compileStringIdentToNotStringVarEquality(
 6541     Node* node, Edge stringEdge, Edge notStringVarEdge)
 6542 {
 6543     SpeculateCellOperand left(this, stringEdge);
 6544     JSValueOperand right(this, notStringVarEdge, ManualOperandSpeculation);
 6545     GPRTemporary leftTemp(this);
 6546     GPRTemporary rightTemp(this);
 6547     GPRReg leftTempGPR = leftTemp.gpr();
 6548     GPRReg rightTempGPR = rightTemp.gpr();
 6549     GPRReg leftGPR = left.gpr();
 6550     JSValueRegs rightRegs = right.jsValueRegs();
 6551 
 6552     speculateString(stringEdge, leftGPR);
 6553     speculateStringIdentAndLoadStorage(stringEdge, leftGPR, leftTempGPR);
 6554 
 6555     moveFalseTo(rightTempGPR);
 6556     JITCompiler::JumpList notString;
 6557     notString.append(m_jit.branchIfNotCell(rightRegs));
 6558     notString.append(m_jit.branchIfNotString(rightRegs.payloadGPR()));
 6559 
 6560     speculateStringIdentAndLoadStorage(notStringVarEdge, rightRegs.payloadGPR(), rightTempGPR);
 6561 
 6562     m_jit.comparePtr(MacroAssembler::Equal, leftTempGPR, rightTempGPR, rightTempGPR);
 6563     notString.link(&amp;m_jit);
 6564 
 6565     unblessedBooleanResult(rightTempGPR, node);
 6566 }
 6567 
 6568 void SpeculativeJIT::compileStringCompare(Node* node, MacroAssembler::RelationalCondition condition)
 6569 {
 6570     SpeculateCellOperand left(this, node-&gt;child1());
 6571     SpeculateCellOperand right(this, node-&gt;child2());
 6572     GPRReg leftGPR = left.gpr();
 6573     GPRReg rightGPR = right.gpr();
 6574 
 6575     speculateString(node-&gt;child1(), leftGPR);
 6576     speculateString(node-&gt;child2(), rightGPR);
 6577 
 6578     C_JITOperation_B_EJssJss compareFunction = nullptr;
 6579     if (condition == MacroAssembler::LessThan)
 6580         compareFunction = operationCompareStringLess;
 6581     else if (condition == MacroAssembler::LessThanOrEqual)
 6582         compareFunction = operationCompareStringLessEq;
 6583     else if (condition == MacroAssembler::GreaterThan)
 6584         compareFunction = operationCompareStringGreater;
 6585     else if (condition == MacroAssembler::GreaterThanOrEqual)
 6586         compareFunction = operationCompareStringGreaterEq;
 6587     else
 6588         RELEASE_ASSERT_NOT_REACHED();
 6589 
 6590     GPRFlushedCallResult result(this);
 6591     GPRReg resultGPR = result.gpr();
 6592 
 6593     flushRegisters();
 6594     callOperation(compareFunction, resultGPR, leftGPR, rightGPR);
 6595     m_jit.exceptionCheck();
 6596 
 6597     unblessedBooleanResult(resultGPR, node);
 6598 }
 6599 
 6600 void SpeculativeJIT::compileStringIdentCompare(Node* node, MacroAssembler::RelationalCondition condition)
 6601 {
 6602     SpeculateCellOperand left(this, node-&gt;child1());
 6603     SpeculateCellOperand right(this, node-&gt;child2());
 6604     GPRFlushedCallResult result(this);
 6605     GPRTemporary leftTemp(this);
 6606     GPRTemporary rightTemp(this);
 6607 
 6608     GPRReg leftGPR = left.gpr();
 6609     GPRReg rightGPR = right.gpr();
 6610     GPRReg resultGPR = result.gpr();
 6611     GPRReg leftTempGPR = leftTemp.gpr();
 6612     GPRReg rightTempGPR = rightTemp.gpr();
 6613 
 6614     speculateString(node-&gt;child1(), leftGPR);
 6615     speculateString(node-&gt;child2(), rightGPR);
 6616 
 6617     C_JITOperation_TT compareFunction = nullptr;
 6618     if (condition == MacroAssembler::LessThan)
 6619         compareFunction = operationCompareStringImplLess;
 6620     else if (condition == MacroAssembler::LessThanOrEqual)
 6621         compareFunction = operationCompareStringImplLessEq;
 6622     else if (condition == MacroAssembler::GreaterThan)
 6623         compareFunction = operationCompareStringImplGreater;
 6624     else if (condition == MacroAssembler::GreaterThanOrEqual)
 6625         compareFunction = operationCompareStringImplGreaterEq;
 6626     else
 6627         RELEASE_ASSERT_NOT_REACHED();
 6628 
 6629     speculateStringIdentAndLoadStorage(node-&gt;child1(), leftGPR, leftTempGPR);
 6630     speculateStringIdentAndLoadStorage(node-&gt;child2(), rightGPR, rightTempGPR);
 6631 
 6632     flushRegisters();
 6633     callOperation(compareFunction, resultGPR, leftTempGPR, rightTempGPR);
 6634 
 6635     unblessedBooleanResult(resultGPR, node);
 6636 }
 6637 
 6638 void SpeculativeJIT::compileSameValue(Node* node)
 6639 {
 6640     if (node-&gt;isBinaryUseKind(DoubleRepUse)) {
 6641         SpeculateDoubleOperand arg1(this, node-&gt;child1());
 6642         SpeculateDoubleOperand arg2(this, node-&gt;child2());
 6643         GPRTemporary result(this);
 6644         GPRTemporary temp(this);
 6645         GPRTemporary temp2(this);
 6646 
 6647         FPRReg arg1FPR = arg1.fpr();
 6648         FPRReg arg2FPR = arg2.fpr();
 6649         GPRReg resultGPR = result.gpr();
 6650         GPRReg tempGPR = temp.gpr();
 6651         GPRReg temp2GPR = temp2.gpr();
 6652 
 6653 #if USE(JSVALUE64)
 6654         m_jit.moveDoubleTo64(arg1FPR, tempGPR);
 6655         m_jit.moveDoubleTo64(arg2FPR, temp2GPR);
 6656         auto trueCase = m_jit.branch64(CCallHelpers::Equal, tempGPR, temp2GPR);
 6657 #else
 6658         GPRTemporary temp3(this);
 6659         GPRReg temp3GPR = temp3.gpr();
 6660 
 6661         m_jit.moveDoubleToInts(arg1FPR, tempGPR, temp2GPR);
 6662         m_jit.moveDoubleToInts(arg2FPR, temp3GPR, resultGPR);
 6663         auto notEqual = m_jit.branch32(CCallHelpers::NotEqual, tempGPR, temp3GPR);
 6664         auto trueCase = m_jit.branch32(CCallHelpers::Equal, temp2GPR, resultGPR);
 6665         notEqual.link(&amp;m_jit);
 6666 #endif
 6667 
 6668         m_jit.compareDouble(CCallHelpers::DoubleNotEqualOrUnordered, arg1FPR, arg1FPR, tempGPR);
 6669         m_jit.compareDouble(CCallHelpers::DoubleNotEqualOrUnordered, arg2FPR, arg2FPR, temp2GPR);
 6670         m_jit.and32(tempGPR, temp2GPR, resultGPR);
 6671         auto done = m_jit.jump();
 6672 
 6673         trueCase.link(&amp;m_jit);
 6674         m_jit.move(CCallHelpers::TrustedImm32(1), resultGPR);
 6675         done.link(&amp;m_jit);
 6676 
 6677         unblessedBooleanResult(resultGPR, node);
 6678         return;
 6679     }
 6680 
 6681     ASSERT(node-&gt;isBinaryUseKind(UntypedUse));
 6682 
 6683     JSValueOperand arg1(this, node-&gt;child1());
 6684     JSValueOperand arg2(this, node-&gt;child2());
 6685     JSValueRegs arg1Regs = arg1.jsValueRegs();
 6686     JSValueRegs arg2Regs = arg2.jsValueRegs();
 6687 
 6688     arg1.use();
 6689     arg2.use();
 6690 
 6691     flushRegisters();
 6692 
 6693     GPRFlushedCallResult result(this);
 6694     GPRReg resultGPR = result.gpr();
 6695     callOperation(operationSameValue, resultGPR, arg1Regs, arg2Regs);
 6696     m_jit.exceptionCheck();
 6697 
 6698     unblessedBooleanResult(resultGPR, node, UseChildrenCalledExplicitly);
 6699 }
 6700 
 6701 void SpeculativeJIT::compileStringZeroLength(Node* node)
 6702 {
 6703     SpeculateCellOperand str(this, node-&gt;child1());
 6704     GPRReg strGPR = str.gpr();
 6705 
 6706     // Make sure that this is a string.
 6707     speculateString(node-&gt;child1(), strGPR);
 6708 
 6709     GPRTemporary eq(this);
 6710     GPRReg eqGPR = eq.gpr();
 6711 
<a name="57" id="anc57"></a><span class="line-modified"> 6712     m_jit.move(TrustedImmPtr::weakPointer(m_jit.graph(), jsEmptyString(vm())), eqGPR);</span>
 6713     m_jit.comparePtr(CCallHelpers::Equal, strGPR, eqGPR, eqGPR);
 6714     unblessedBooleanResult(eqGPR, node);
 6715 }
 6716 
 6717 void SpeculativeJIT::compileLogicalNotStringOrOther(Node* node)
 6718 {
 6719     JSValueOperand value(this, node-&gt;child1(), ManualOperandSpeculation);
 6720     GPRTemporary temp(this);
 6721     JSValueRegs valueRegs = value.jsValueRegs();
 6722     GPRReg tempGPR = temp.gpr();
 6723 
 6724     JITCompiler::Jump notCell = m_jit.branchIfNotCell(valueRegs);
 6725     GPRReg cellGPR = valueRegs.payloadGPR();
 6726     DFG_TYPE_CHECK(
 6727         valueRegs, node-&gt;child1(), (~SpecCellCheck) | SpecString, m_jit.branchIfNotString(cellGPR));
 6728 
<a name="58" id="anc58"></a><span class="line-modified"> 6729     m_jit.move(TrustedImmPtr::weakPointer(m_jit.graph(), jsEmptyString(vm())), tempGPR);</span>
 6730     m_jit.comparePtr(CCallHelpers::Equal, cellGPR, tempGPR, tempGPR);
 6731     auto done = m_jit.jump();
 6732 
 6733     notCell.link(&amp;m_jit);
 6734     DFG_TYPE_CHECK(
 6735         valueRegs, node-&gt;child1(), SpecCellCheck | SpecOther, m_jit.branchIfNotOther(valueRegs, tempGPR));
 6736     m_jit.move(TrustedImm32(1), tempGPR);
 6737 
 6738     done.link(&amp;m_jit);
 6739     unblessedBooleanResult(tempGPR, node);
 6740 
 6741 }
 6742 
 6743 void SpeculativeJIT::emitStringBranch(Edge nodeUse, BasicBlock* taken, BasicBlock* notTaken)
 6744 {
 6745     SpeculateCellOperand str(this, nodeUse);
 6746 
 6747     GPRReg strGPR = str.gpr();
 6748 
 6749     speculateString(nodeUse, strGPR);
 6750 
<a name="59" id="anc59"></a><span class="line-modified"> 6751     branchPtr(CCallHelpers::Equal, strGPR, TrustedImmPtr::weakPointer(m_jit.graph(), jsEmptyString(vm())), notTaken);</span>
 6752     jump(taken);
 6753 
 6754     noResult(m_currentNode);
 6755 }
 6756 
 6757 void SpeculativeJIT::emitStringOrOtherBranch(Edge nodeUse, BasicBlock* taken, BasicBlock* notTaken)
 6758 {
 6759     JSValueOperand value(this, nodeUse, ManualOperandSpeculation);
 6760     GPRTemporary temp(this);
 6761     JSValueRegs valueRegs = value.jsValueRegs();
 6762     GPRReg tempGPR = temp.gpr();
 6763 
 6764     JITCompiler::Jump notCell = m_jit.branchIfNotCell(valueRegs);
 6765     GPRReg cellGPR = valueRegs.payloadGPR();
 6766     DFG_TYPE_CHECK(valueRegs, nodeUse, (~SpecCellCheck) | SpecString, m_jit.branchIfNotString(cellGPR));
 6767 
<a name="60" id="anc60"></a><span class="line-modified"> 6768     branchPtr(CCallHelpers::Equal, cellGPR, TrustedImmPtr::weakPointer(m_jit.graph(), jsEmptyString(vm())), notTaken);</span>
 6769     jump(taken, ForceJump);
 6770 
 6771     notCell.link(&amp;m_jit);
 6772     DFG_TYPE_CHECK(
 6773         valueRegs, nodeUse, SpecCellCheck | SpecOther, m_jit.branchIfNotOther(valueRegs, tempGPR));
 6774     jump(notTaken);
 6775     noResult(m_currentNode);
 6776 }
 6777 
 6778 void SpeculativeJIT::compileConstantStoragePointer(Node* node)
 6779 {
 6780     GPRTemporary storage(this);
 6781     GPRReg storageGPR = storage.gpr();
 6782     m_jit.move(TrustedImmPtr(node-&gt;storagePointer()), storageGPR);
 6783     storageResult(storageGPR, node);
 6784 }
 6785 
<a name="61" id="anc61"></a><span class="line-modified"> 6786 void SpeculativeJIT::cageTypedArrayStorage(GPRReg baseReg, GPRReg storageReg)</span>
 6787 {
<a name="62" id="anc62"></a><span class="line-added"> 6788     auto untagArrayPtr = [&amp;]() {</span>
<span class="line-added"> 6789 #if CPU(ARM64E)</span>
<span class="line-added"> 6790         m_jit.untagArrayPtr(MacroAssembler::Address(baseReg, JSArrayBufferView::offsetOfLength()), storageReg);</span>
<span class="line-added"> 6791 #else</span>
<span class="line-added"> 6792         UNUSED_PARAM(baseReg);</span>
<span class="line-added"> 6793         UNUSED_PARAM(storageReg);</span>
<span class="line-added"> 6794 #endif</span>
<span class="line-added"> 6795     };</span>
<span class="line-added"> 6796 </span>
 6797 #if GIGACAGE_ENABLED
<a name="63" id="anc63"></a><span class="line-modified"> 6798     UNUSED_PARAM(baseReg);</span>
<span class="line-added"> 6799     if (!Gigacage::shouldBeEnabled()) {</span>
<span class="line-added"> 6800         untagArrayPtr();</span>
 6801         return;
<a name="64" id="anc64"></a><span class="line-added"> 6802     }</span>
 6803 
 6804     if (Gigacage::canPrimitiveGigacageBeDisabled()) {
<a name="65" id="anc65"></a><span class="line-modified"> 6805         VM&amp; vm = this-&gt;vm();</span>
<span class="line-modified"> 6806         if (vm.primitiveGigacageEnabled().isStillValid())</span>
<span class="line-modified"> 6807             m_jit.graph().watchpoints().addLazily(vm.primitiveGigacageEnabled());</span>
<span class="line-added"> 6808         else {</span>
<span class="line-added"> 6809             untagArrayPtr();</span>
 6810             return;
<a name="66" id="anc66"></a><span class="line-added"> 6811         }</span>
 6812     }
 6813 
<a name="67" id="anc67"></a><span class="line-modified"> 6814     m_jit.cageWithoutUntagging(Gigacage::Primitive, storageReg);</span>


 6815 #endif
<a name="68" id="anc68"></a><span class="line-added"> 6816     untagArrayPtr();</span>
 6817 }
 6818 
 6819 void SpeculativeJIT::compileGetIndexedPropertyStorage(Node* node)
 6820 {
 6821     SpeculateCellOperand base(this, node-&gt;child1());
 6822     GPRReg baseReg = base.gpr();
 6823 
 6824     GPRTemporary storage(this);
 6825     GPRReg storageReg = storage.gpr();
 6826 
 6827     switch (node-&gt;arrayMode().type()) {
 6828     case Array::String:
 6829         m_jit.loadPtr(MacroAssembler::Address(baseReg, JSString::offsetOfValue()), storageReg);
 6830 
 6831         addSlowPathGenerator(
 6832             slowPathCall(
 6833                 m_jit.branchIfRopeStringImpl(storageReg),
 6834                 this, operationResolveRope, storageReg, baseReg));
 6835 
 6836         m_jit.loadPtr(MacroAssembler::Address(storageReg, StringImpl::dataOffset()), storageReg);
 6837         break;
 6838 
<a name="69" id="anc69"></a><span class="line-modified"> 6839     default: {</span>
 6840         auto typedArrayType = node-&gt;arrayMode().typedArrayType();
 6841         ASSERT_UNUSED(typedArrayType, isTypedView(typedArrayType));
 6842 
 6843         m_jit.loadPtr(JITCompiler::Address(baseReg, JSArrayBufferView::offsetOfVector()), storageReg);
<a name="70" id="anc70"></a><span class="line-modified"> 6844         cageTypedArrayStorage(baseReg, storageReg);</span>
 6845         break;
 6846     }
<a name="71" id="anc71"></a><span class="line-added"> 6847     }</span>
 6848 
 6849     storageResult(storageReg, node);
 6850 }
 6851 
 6852 void SpeculativeJIT::compileGetTypedArrayByteOffset(Node* node)
 6853 {
 6854     SpeculateCellOperand base(this, node-&gt;child1());
 6855     GPRTemporary vector(this);
 6856     GPRTemporary data(this);
 6857 
 6858     GPRReg baseGPR = base.gpr();
 6859     GPRReg vectorGPR = vector.gpr();
 6860     GPRReg dataGPR = data.gpr();
 6861     ASSERT(baseGPR != vectorGPR);
 6862     ASSERT(baseGPR != dataGPR);
 6863     ASSERT(vectorGPR != dataGPR);
 6864 
 6865     GPRReg arrayBufferGPR = dataGPR;
 6866 
 6867     JITCompiler::Jump emptyByteOffset = m_jit.branch32(
 6868         MacroAssembler::NotEqual,
 6869         MacroAssembler::Address(baseGPR, JSArrayBufferView::offsetOfMode()),
 6870         TrustedImm32(WastefulTypedArray));
 6871 
 6872     m_jit.loadPtr(MacroAssembler::Address(baseGPR, JSArrayBufferView::offsetOfVector()), vectorGPR);
<a name="72" id="anc72"></a><span class="line-added"> 6873 </span>
<span class="line-added"> 6874     // FIXME: This should mask the PAC bits</span>
<span class="line-added"> 6875     // https://bugs.webkit.org/show_bug.cgi?id=197701</span>
 6876     JITCompiler::Jump nullVector = m_jit.branchTestPtr(JITCompiler::Zero, vectorGPR);
 6877 
 6878     m_jit.loadPtr(MacroAssembler::Address(baseGPR, JSObject::butterflyOffset()), dataGPR);
<a name="73" id="anc73"></a><span class="line-modified"> 6879     m_jit.cageWithoutUntagging(Gigacage::JSValue, dataGPR);</span>
 6880 
<a name="74" id="anc74"></a><span class="line-modified"> 6881     cageTypedArrayStorage(baseGPR, vectorGPR);</span>
 6882 
 6883     m_jit.loadPtr(MacroAssembler::Address(dataGPR, Butterfly::offsetOfArrayBuffer()), arrayBufferGPR);
 6884     // FIXME: This needs caging.
 6885     // https://bugs.webkit.org/show_bug.cgi?id=175515
 6886     m_jit.loadPtr(MacroAssembler::Address(arrayBufferGPR, ArrayBuffer::offsetOfData()), dataGPR);
<a name="75" id="anc75"></a><span class="line-added"> 6887 #if CPU(ARM64E)</span>
<span class="line-added"> 6888     m_jit.removeArrayPtrTag(dataGPR);</span>
<span class="line-added"> 6889 #endif</span>
<span class="line-added"> 6890 </span>
 6891     m_jit.subPtr(dataGPR, vectorGPR);
 6892 
 6893     JITCompiler::Jump done = m_jit.jump();
 6894 
 6895     emptyByteOffset.link(&amp;m_jit);
 6896     m_jit.move(TrustedImmPtr(nullptr), vectorGPR);
 6897 
 6898     done.link(&amp;m_jit);
 6899     nullVector.link(&amp;m_jit);
 6900 
 6901     int32Result(vectorGPR, node);
 6902 }
 6903 
 6904 void SpeculativeJIT::compileGetByValOnDirectArguments(Node* node)
 6905 {
 6906     SpeculateCellOperand base(this, m_graph.varArgChild(node, 0));
 6907     SpeculateStrictInt32Operand property(this, m_graph.varArgChild(node, 1));
 6908     JSValueRegsTemporary result(this);
 6909     GPRTemporary scratch(this);
 6910 
 6911     GPRReg baseReg = base.gpr();
 6912     GPRReg propertyReg = property.gpr();
 6913     JSValueRegs resultRegs = result.regs();
 6914     GPRReg scratchReg = scratch.gpr();
 6915 
 6916     if (!m_compileOkay)
 6917         return;
 6918 
 6919     ASSERT(ArrayMode(Array::DirectArguments, Array::Read).alreadyChecked(m_jit.graph(), node, m_state.forNode(m_graph.varArgChild(node, 0))));
 6920 
 6921     speculationCheck(
 6922         ExoticObjectMode, JSValueSource(), 0,
 6923         m_jit.branchTestPtr(
 6924             MacroAssembler::NonZero,
 6925             MacroAssembler::Address(baseReg, DirectArguments::offsetOfMappedArguments())));
 6926 
 6927     m_jit.load32(CCallHelpers::Address(baseReg, DirectArguments::offsetOfLength()), scratchReg);
 6928     auto isOutOfBounds = m_jit.branch32(CCallHelpers::AboveOrEqual, propertyReg, scratchReg);
 6929     if (node-&gt;arrayMode().isInBounds())
 6930         speculationCheck(OutOfBounds, JSValueSource(), 0, isOutOfBounds);
 6931 
 6932     m_jit.loadValue(
 6933         MacroAssembler::BaseIndex(
 6934             baseReg, propertyReg, MacroAssembler::TimesEight, DirectArguments::storageOffset()),
 6935         resultRegs);
 6936 
 6937     if (!node-&gt;arrayMode().isInBounds()) {
 6938         addSlowPathGenerator(
 6939             slowPathCall(
 6940                 isOutOfBounds, this, operationGetByValObjectInt,
 6941                 extractResult(resultRegs), baseReg, propertyReg));
 6942     }
 6943 
 6944     jsValueResult(resultRegs, node);
 6945 }
 6946 
 6947 void SpeculativeJIT::compileGetByValOnScopedArguments(Node* node)
 6948 {
 6949     SpeculateCellOperand base(this, m_graph.varArgChild(node, 0));
 6950     SpeculateStrictInt32Operand property(this, m_graph.varArgChild(node, 1));
 6951     JSValueRegsTemporary result(this);
 6952     GPRTemporary scratch(this);
 6953     GPRTemporary scratch2(this);
 6954     GPRTemporary indexMask(this);
 6955 
 6956     GPRReg baseReg = base.gpr();
 6957     GPRReg propertyReg = property.gpr();
 6958     JSValueRegs resultRegs = result.regs();
 6959     GPRReg scratchReg = scratch.gpr();
 6960     GPRReg scratch2Reg = scratch2.gpr();
 6961     GPRReg indexMaskReg = indexMask.gpr();
 6962 
 6963     if (!m_compileOkay)
 6964         return;
 6965 
 6966     ASSERT(ArrayMode(Array::ScopedArguments, Array::Read).alreadyChecked(m_jit.graph(), node, m_state.forNode(m_graph.varArgChild(node, 0))));
 6967 
 6968     m_jit.loadPtr(
 6969         MacroAssembler::Address(baseReg, ScopedArguments::offsetOfStorage()), resultRegs.payloadGPR());
 6970     m_jit.load32(
 6971         MacroAssembler::Address(resultRegs.payloadGPR(), ScopedArguments::offsetOfTotalLengthInStorage()),
 6972         scratchReg);
 6973 
 6974     speculationCheck(
 6975         ExoticObjectMode, JSValueSource(), nullptr,
 6976         m_jit.branch32(MacroAssembler::AboveOrEqual, propertyReg, scratchReg));
 6977 
 6978     m_jit.emitPreparePreciseIndexMask32(propertyReg, scratchReg, indexMaskReg);
 6979 
 6980     m_jit.loadPtr(MacroAssembler::Address(baseReg, ScopedArguments::offsetOfTable()), scratchReg);
 6981     m_jit.load32(
 6982         MacroAssembler::Address(scratchReg, ScopedArgumentsTable::offsetOfLength()), scratch2Reg);
 6983 
 6984     MacroAssembler::Jump overflowArgument = m_jit.branch32(
 6985         MacroAssembler::AboveOrEqual, propertyReg, scratch2Reg);
 6986 
 6987     m_jit.loadPtr(MacroAssembler::Address(baseReg, ScopedArguments::offsetOfScope()), scratch2Reg);
 6988 
 6989     m_jit.loadPtr(
 6990         MacroAssembler::Address(scratchReg, ScopedArgumentsTable::offsetOfArguments()),
 6991         scratchReg);
 6992     m_jit.load32(
 6993         MacroAssembler::BaseIndex(scratchReg, propertyReg, MacroAssembler::TimesFour),
 6994         scratchReg);
 6995 
 6996     speculationCheck(
 6997         ExoticObjectMode, JSValueSource(), nullptr,
 6998         m_jit.branch32(
 6999             MacroAssembler::Equal, scratchReg, TrustedImm32(ScopeOffset::invalidOffset)));
 7000 
 7001     m_jit.loadValue(
 7002         MacroAssembler::BaseIndex(
 7003             scratch2Reg, propertyReg, MacroAssembler::TimesEight,
 7004             JSLexicalEnvironment::offsetOfVariables()),
 7005         resultRegs);
 7006 
 7007     MacroAssembler::Jump done = m_jit.jump();
 7008     overflowArgument.link(&amp;m_jit);
 7009 
 7010     m_jit.sub32(propertyReg, scratch2Reg);
 7011     m_jit.neg32(scratch2Reg);
 7012 
 7013     m_jit.loadValue(
 7014         MacroAssembler::BaseIndex(
 7015             resultRegs.payloadGPR(), scratch2Reg, MacroAssembler::TimesEight),
 7016         resultRegs);
 7017     speculationCheck(ExoticObjectMode, JSValueSource(), nullptr, m_jit.branchIfEmpty(resultRegs));
 7018 
 7019     done.link(&amp;m_jit);
 7020 
 7021     m_jit.andPtr(indexMaskReg, resultRegs.payloadGPR());
 7022 
 7023     jsValueResult(resultRegs, node);
 7024 }
 7025 
 7026 void SpeculativeJIT::compileGetScope(Node* node)
 7027 {
 7028     SpeculateCellOperand function(this, node-&gt;child1());
 7029     GPRTemporary result(this, Reuse, function);
 7030     m_jit.loadPtr(JITCompiler::Address(function.gpr(), JSFunction::offsetOfScopeChain()), result.gpr());
 7031     cellResult(result.gpr(), node);
 7032 }
 7033 
 7034 void SpeculativeJIT::compileSkipScope(Node* node)
 7035 {
 7036     SpeculateCellOperand scope(this, node-&gt;child1());
 7037     GPRTemporary result(this, Reuse, scope);
 7038     m_jit.loadPtr(JITCompiler::Address(scope.gpr(), JSScope::offsetOfNext()), result.gpr());
 7039     cellResult(result.gpr(), node);
 7040 }
 7041 
 7042 void SpeculativeJIT::compileGetGlobalObject(Node* node)
 7043 {
 7044     SpeculateCellOperand object(this, node-&gt;child1());
 7045     GPRTemporary result(this);
 7046     GPRTemporary scratch(this);
<a name="76" id="anc76"></a><span class="line-modified"> 7047     m_jit.emitLoadStructure(vm(), object.gpr(), result.gpr(), scratch.gpr());</span>
 7048     m_jit.loadPtr(JITCompiler::Address(result.gpr(), Structure::globalObjectOffset()), result.gpr());
 7049     cellResult(result.gpr(), node);
 7050 }
 7051 
 7052 void SpeculativeJIT::compileGetGlobalThis(Node* node)
 7053 {
 7054     GPRTemporary result(this);
 7055     GPRReg resultGPR = result.gpr();
 7056     auto* globalObject = m_jit.graph().globalObjectFor(node-&gt;origin.semantic);
 7057     m_jit.loadPtr(globalObject-&gt;addressOfGlobalThis(), resultGPR);
 7058     cellResult(resultGPR, node);
 7059 }
 7060 
<a name="77" id="anc77"></a><span class="line-added"> 7061 bool SpeculativeJIT::canBeRope(Edge&amp; edge)</span>
<span class="line-added"> 7062 {</span>
<span class="line-added"> 7063     if (m_state.forNode(edge).isType(SpecStringIdent))</span>
<span class="line-added"> 7064         return false;</span>
<span class="line-added"> 7065     // If this value is LazyValue, it will be converted to JSString, and the result must be non-rope string.</span>
<span class="line-added"> 7066     String string = edge-&gt;tryGetString(m_graph);</span>
<span class="line-added"> 7067     if (!string.isNull())</span>
<span class="line-added"> 7068         return false;</span>
<span class="line-added"> 7069     return true;</span>
<span class="line-added"> 7070 }</span>
<span class="line-added"> 7071 </span>
 7072 void SpeculativeJIT::compileGetArrayLength(Node* node)
 7073 {
 7074     switch (node-&gt;arrayMode().type()) {
 7075     case Array::Undecided:
 7076     case Array::Int32:
 7077     case Array::Double:
 7078     case Array::Contiguous: {
 7079         StorageOperand storage(this, node-&gt;child2());
 7080         GPRTemporary result(this, Reuse, storage);
 7081         GPRReg storageReg = storage.gpr();
 7082         GPRReg resultReg = result.gpr();
 7083         m_jit.load32(MacroAssembler::Address(storageReg, Butterfly::offsetOfPublicLength()), resultReg);
 7084 
 7085         int32Result(resultReg, node);
 7086         break;
 7087     }
 7088     case Array::ArrayStorage:
 7089     case Array::SlowPutArrayStorage: {
 7090         StorageOperand storage(this, node-&gt;child2());
 7091         GPRTemporary result(this, Reuse, storage);
 7092         GPRReg storageReg = storage.gpr();
 7093         GPRReg resultReg = result.gpr();
 7094         m_jit.load32(MacroAssembler::Address(storageReg, Butterfly::offsetOfPublicLength()), resultReg);
 7095 
 7096         speculationCheck(Uncountable, JSValueRegs(), 0, m_jit.branch32(MacroAssembler::LessThan, resultReg, MacroAssembler::TrustedImm32(0)));
 7097 
 7098         int32Result(resultReg, node);
 7099         break;
 7100     }
 7101     case Array::String: {
 7102         SpeculateCellOperand base(this, node-&gt;child1());
 7103         GPRTemporary result(this, Reuse, base);
 7104         GPRTemporary temp(this);
 7105         GPRReg baseGPR = base.gpr();
 7106         GPRReg resultGPR = result.gpr();
 7107         GPRReg tempGPR = temp.gpr();
 7108 
<a name="78" id="anc78"></a><span class="line-added"> 7109         bool needsRopeCase = canBeRope(node-&gt;child1());</span>
<span class="line-added"> 7110 </span>
 7111         m_jit.loadPtr(MacroAssembler::Address(baseGPR, JSString::offsetOfValue()), tempGPR);
<a name="79" id="anc79"></a><span class="line-modified"> 7112         CCallHelpers::Jump isRope;</span>
<span class="line-added"> 7113         if (needsRopeCase)</span>
<span class="line-added"> 7114             isRope = m_jit.branchIfRopeStringImpl(tempGPR);</span>
 7115         m_jit.load32(MacroAssembler::Address(tempGPR, StringImpl::lengthMemoryOffset()), resultGPR);
<a name="80" id="anc80"></a><span class="line-modified"> 7116         if (needsRopeCase) {</span>
<span class="line-added"> 7117             auto done = m_jit.jump();</span>
 7118 
<a name="81" id="anc81"></a><span class="line-modified"> 7119             isRope.link(&amp;m_jit);</span>
<span class="line-modified"> 7120             m_jit.load32(CCallHelpers::Address(baseGPR, JSRopeString::offsetOfLength()), resultGPR);</span>
 7121 
<a name="82" id="anc82"></a><span class="line-modified"> 7122             done.link(&amp;m_jit);</span>
<span class="line-added"> 7123         }</span>
 7124         int32Result(resultGPR, node);
 7125         break;
 7126     }
 7127     case Array::DirectArguments: {
 7128         SpeculateCellOperand base(this, node-&gt;child1());
 7129         GPRTemporary result(this, Reuse, base);
 7130 
 7131         GPRReg baseReg = base.gpr();
 7132         GPRReg resultReg = result.gpr();
 7133 
 7134         if (!m_compileOkay)
 7135             return;
 7136 
 7137         ASSERT(ArrayMode(Array::DirectArguments, Array::Read).alreadyChecked(m_jit.graph(), node, m_state.forNode(node-&gt;child1())));
 7138 
 7139         speculationCheck(
 7140             ExoticObjectMode, JSValueSource(), 0,
 7141             m_jit.branchTestPtr(
 7142                 MacroAssembler::NonZero,
 7143                 MacroAssembler::Address(baseReg, DirectArguments::offsetOfMappedArguments())));
 7144 
 7145         m_jit.load32(
 7146             MacroAssembler::Address(baseReg, DirectArguments::offsetOfLength()), resultReg);
 7147 
 7148         int32Result(resultReg, node);
 7149         break;
 7150     }
 7151     case Array::ScopedArguments: {
 7152         SpeculateCellOperand base(this, node-&gt;child1());
 7153         GPRTemporary result(this);
 7154 
 7155         GPRReg baseReg = base.gpr();
 7156         GPRReg resultReg = result.gpr();
 7157 
 7158         if (!m_compileOkay)
 7159             return;
 7160 
 7161         ASSERT(ArrayMode(Array::ScopedArguments, Array::Read).alreadyChecked(m_jit.graph(), node, m_state.forNode(node-&gt;child1())));
 7162 
 7163         m_jit.loadPtr(
 7164             MacroAssembler::Address(baseReg, ScopedArguments::offsetOfStorage()), resultReg);
 7165 
 7166         speculationCheck(
 7167             ExoticObjectMode, JSValueSource(), 0,
 7168             m_jit.branchTest8(
 7169                 MacroAssembler::NonZero,
 7170                 MacroAssembler::Address(resultReg, ScopedArguments::offsetOfOverrodeThingsInStorage())));
 7171 
 7172         m_jit.load32(
 7173             MacroAssembler::Address(resultReg, ScopedArguments::offsetOfTotalLengthInStorage()), resultReg);
 7174 
 7175         int32Result(resultReg, node);
 7176         break;
 7177     }
 7178     default: {
 7179         ASSERT(node-&gt;arrayMode().isSomeTypedArrayView());
 7180         SpeculateCellOperand base(this, node-&gt;child1());
 7181         GPRTemporary result(this, Reuse, base);
 7182         GPRReg baseGPR = base.gpr();
 7183         GPRReg resultGPR = result.gpr();
 7184         m_jit.load32(MacroAssembler::Address(baseGPR, JSArrayBufferView::offsetOfLength()), resultGPR);
 7185         int32Result(resultGPR, node);
 7186         break;
 7187     } }
 7188 }
 7189 
 7190 void SpeculativeJIT::compileCheckStringIdent(Node* node)
 7191 {
 7192     SpeculateCellOperand string(this, node-&gt;child1());
 7193     GPRTemporary storage(this);
 7194 
 7195     GPRReg stringGPR = string.gpr();
 7196     GPRReg storageGPR = storage.gpr();
 7197 
 7198     speculateString(node-&gt;child1(), stringGPR);
 7199     speculateStringIdentAndLoadStorage(node-&gt;child1(), stringGPR, storageGPR);
 7200 
 7201     UniquedStringImpl* uid = node-&gt;uidOperand();
 7202     speculationCheck(
 7203         BadIdent, JSValueSource(), nullptr,
 7204         m_jit.branchPtr(JITCompiler::NotEqual, storageGPR, TrustedImmPtr(uid)));
 7205     noResult(node);
 7206 }
 7207 
 7208 template &lt;typename ClassType&gt;
 7209 void SpeculativeJIT::compileNewFunctionCommon(GPRReg resultGPR, RegisteredStructure structure, GPRReg scratch1GPR, GPRReg scratch2GPR, GPRReg scopeGPR, MacroAssembler::JumpList&amp; slowPath, size_t size, FunctionExecutable* executable)
 7210 {
 7211     auto butterfly = TrustedImmPtr(nullptr);
 7212     emitAllocateJSObjectWithKnownSize&lt;ClassType&gt;(resultGPR, TrustedImmPtr(structure), butterfly, scratch1GPR, scratch2GPR, slowPath, size);
 7213 
 7214     m_jit.storePtr(scopeGPR, JITCompiler::Address(resultGPR, JSFunction::offsetOfScopeChain()));
 7215     m_jit.storePtr(TrustedImmPtr::weakPointer(m_jit.graph(), executable), JITCompiler::Address(resultGPR, JSFunction::offsetOfExecutable()));
 7216     m_jit.storePtr(TrustedImmPtr(nullptr), JITCompiler::Address(resultGPR, JSFunction::offsetOfRareData()));
 7217 
<a name="83" id="anc83"></a><span class="line-modified"> 7218     if (executable-&gt;isAnonymousBuiltinFunction()) {</span>
<span class="line-added"> 7219         VM&amp; vm = this-&gt;vm();</span>
<span class="line-added"> 7220         m_jit.mutatorFence(vm);</span>
<span class="line-added"> 7221         GPRTemporary allocator(this);</span>
<span class="line-added"> 7222         Allocator allocatorValue = allocatorForNonVirtualConcurrently&lt;FunctionRareData&gt;(vm, sizeof(FunctionRareData), AllocatorForMode::AllocatorIfExists);</span>
<span class="line-added"> 7223         emitAllocateJSCell(scratch1GPR, JITAllocator::constant(allocatorValue), allocator.gpr(), TrustedImmPtr(m_jit.graph().registerStructure(vm.functionRareDataStructure.get())), scratch2GPR, slowPath);</span>
<span class="line-added"> 7224 </span>
<span class="line-added"> 7225         ptrdiff_t objectAllocationProfileOffset = FunctionRareData::offsetOfObjectAllocationProfile();</span>
<span class="line-added"> 7226         m_jit.storePtr(TrustedImmPtr(nullptr), JITCompiler::Address(scratch1GPR, objectAllocationProfileOffset + ObjectAllocationProfileWithPrototype::offsetOfAllocator()));</span>
<span class="line-added"> 7227         m_jit.storePtr(TrustedImmPtr(nullptr), JITCompiler::Address(scratch1GPR, objectAllocationProfileOffset + ObjectAllocationProfileWithPrototype::offsetOfStructure()));</span>
<span class="line-added"> 7228         m_jit.storePtr(TrustedImmPtr(nullptr), JITCompiler::Address(scratch1GPR, objectAllocationProfileOffset + ObjectAllocationProfileWithPrototype::offsetOfPrototype()));</span>
<span class="line-added"> 7229         m_jit.storePtr(TrustedImmPtr(0x1), JITCompiler::Address(scratch1GPR, FunctionRareData::offsetOfObjectAllocationProfileWatchpoint()));</span>
<span class="line-added"> 7230         m_jit.storePtr(TrustedImmPtr(nullptr), JITCompiler::Address(scratch1GPR, FunctionRareData::offsetOfInternalFunctionAllocationProfile() + InternalFunctionAllocationProfile::offsetOfStructure()));</span>
<span class="line-added"> 7231         m_jit.storePtr(TrustedImmPtr(nullptr), JITCompiler::Address(scratch1GPR, FunctionRareData::offsetOfBoundFunctionStructure()));</span>
<span class="line-added"> 7232         m_jit.storePtr(TrustedImmPtr(nullptr), JITCompiler::Address(scratch1GPR, FunctionRareData::offsetOfAllocationProfileClearingWatchpoint()));</span>
<span class="line-added"> 7233         m_jit.store8(TrustedImm32(0), JITCompiler::Address(scratch1GPR, FunctionRareData::offsetOfHasReifiedLength()));</span>
<span class="line-added"> 7234         m_jit.store8(TrustedImm32(1), JITCompiler::Address(scratch1GPR, FunctionRareData::offsetOfHasReifiedName()));</span>
<span class="line-added"> 7235         m_jit.mutatorFence(vm);</span>
<span class="line-added"> 7236         m_jit.storePtr(scratch1GPR, JITCompiler::Address(resultGPR, JSFunction::offsetOfRareData()));</span>
<span class="line-added"> 7237     } else</span>
<span class="line-added"> 7238         m_jit.mutatorFence(vm());</span>
<span class="line-added"> 7239 </span>
 7240 }
 7241 
 7242 void SpeculativeJIT::compileNewFunction(Node* node)
 7243 {
 7244     NodeType nodeType = node-&gt;op();
 7245     ASSERT(nodeType == NewFunction || nodeType == NewGeneratorFunction || nodeType == NewAsyncFunction || nodeType == NewAsyncGeneratorFunction);
 7246 
 7247     SpeculateCellOperand scope(this, node-&gt;child1());
 7248     GPRReg scopeGPR = scope.gpr();
 7249 
 7250     FunctionExecutable* executable = node-&gt;castOperand&lt;FunctionExecutable*&gt;();
 7251 
<a name="84" id="anc84"></a><span class="line-modified"> 7252     if (executable-&gt;singleton().isStillValid()) {</span>
 7253         GPRFlushedCallResult result(this);
 7254         GPRReg resultGPR = result.gpr();
 7255 
 7256         flushRegisters();
 7257 
 7258         if (nodeType == NewGeneratorFunction)
 7259             callOperation(operationNewGeneratorFunction, resultGPR, scopeGPR, executable);
 7260         else if (nodeType == NewAsyncFunction)
 7261             callOperation(operationNewAsyncFunction, resultGPR, scopeGPR, executable);
 7262         else if (nodeType == NewAsyncGeneratorFunction)
 7263             callOperation(operationNewAsyncGeneratorFunction, resultGPR, scopeGPR, executable);
 7264         else
 7265             callOperation(operationNewFunction, resultGPR, scopeGPR, executable);
 7266         m_jit.exceptionCheck();
 7267         cellResult(resultGPR, node);
 7268         return;
 7269     }
 7270 
 7271     RegisteredStructure structure = m_jit.graph().registerStructure(
 7272         [&amp;] () {
 7273             JSGlobalObject* globalObject = m_jit.graph().globalObjectFor(node-&gt;origin.semantic);
 7274             switch (nodeType) {
 7275             case NewGeneratorFunction:
 7276                 return globalObject-&gt;generatorFunctionStructure();
 7277             case NewAsyncFunction:
 7278                 return globalObject-&gt;asyncFunctionStructure();
 7279             case NewAsyncGeneratorFunction:
 7280                 return globalObject-&gt;asyncGeneratorFunctionStructure();
 7281             case NewFunction:
 7282                 return JSFunction::selectStructureForNewFuncExp(globalObject, node-&gt;castOperand&lt;FunctionExecutable*&gt;());
 7283             default:
 7284                 RELEASE_ASSERT_NOT_REACHED();
 7285             }
 7286         }());
 7287 
 7288     GPRTemporary result(this);
 7289     GPRTemporary scratch1(this);
 7290     GPRTemporary scratch2(this);
 7291 
 7292     GPRReg resultGPR = result.gpr();
 7293     GPRReg scratch1GPR = scratch1.gpr();
 7294     GPRReg scratch2GPR = scratch2.gpr();
 7295 
 7296     JITCompiler::JumpList slowPath;
 7297 
 7298     if (nodeType == NewFunction) {
 7299         compileNewFunctionCommon&lt;JSFunction&gt;(resultGPR, structure, scratch1GPR, scratch2GPR, scopeGPR, slowPath, JSFunction::allocationSize(0), executable);
 7300 
 7301         addSlowPathGenerator(slowPathCall(slowPath, this, operationNewFunctionWithInvalidatedReallocationWatchpoint, resultGPR, scopeGPR, executable));
 7302     }
 7303 
 7304     if (nodeType == NewGeneratorFunction) {
 7305         compileNewFunctionCommon&lt;JSGeneratorFunction&gt;(resultGPR, structure, scratch1GPR, scratch2GPR, scopeGPR, slowPath, JSGeneratorFunction::allocationSize(0), executable);
 7306 
 7307         addSlowPathGenerator(slowPathCall(slowPath, this, operationNewGeneratorFunctionWithInvalidatedReallocationWatchpoint, resultGPR, scopeGPR, executable));
 7308     }
 7309 
 7310     if (nodeType == NewAsyncFunction) {
 7311         compileNewFunctionCommon&lt;JSAsyncFunction&gt;(resultGPR, structure, scratch1GPR, scratch2GPR, scopeGPR, slowPath, JSAsyncFunction::allocationSize(0), executable);
 7312 
 7313         addSlowPathGenerator(slowPathCall(slowPath, this, operationNewAsyncFunctionWithInvalidatedReallocationWatchpoint, resultGPR, scopeGPR, executable));
 7314     }
 7315 
 7316     if (nodeType == NewAsyncGeneratorFunction) {
 7317         compileNewFunctionCommon&lt;JSAsyncGeneratorFunction&gt;(resultGPR, structure, scratch1GPR, scratch2GPR, scopeGPR, slowPath, JSAsyncGeneratorFunction::allocationSize(0), executable);
 7318 
 7319         addSlowPathGenerator(slowPathCall(slowPath, this, operationNewAsyncGeneratorFunctionWithInvalidatedReallocationWatchpoint, resultGPR, scopeGPR, executable));
 7320     }
 7321 
 7322     cellResult(resultGPR, node);
 7323 }
 7324 
 7325 void SpeculativeJIT::compileSetFunctionName(Node* node)
 7326 {
 7327     SpeculateCellOperand func(this, node-&gt;child1());
 7328     GPRReg funcGPR = func.gpr();
 7329     JSValueOperand nameValue(this, node-&gt;child2());
 7330     JSValueRegs nameValueRegs = nameValue.jsValueRegs();
 7331 
 7332     flushRegisters();
 7333     callOperation(operationSetFunctionName, funcGPR, nameValueRegs);
 7334     m_jit.exceptionCheck();
 7335 
 7336     noResult(node);
 7337 }
 7338 
 7339 void SpeculativeJIT::compileLoadVarargs(Node* node)
 7340 {
 7341     LoadVarargsData* data = node-&gt;loadVarargsData();
 7342 
 7343     JSValueRegs argumentsRegs;
 7344     {
 7345         JSValueOperand arguments(this, node-&gt;child1());
 7346         argumentsRegs = arguments.jsValueRegs();
 7347         flushRegisters();
 7348     }
 7349 
 7350     callOperation(operationSizeOfVarargs, GPRInfo::returnValueGPR, argumentsRegs, data-&gt;offset);
 7351     m_jit.exceptionCheck();
 7352 
 7353     lock(GPRInfo::returnValueGPR);
 7354     {
 7355         JSValueOperand arguments(this, node-&gt;child1());
 7356         argumentsRegs = arguments.jsValueRegs();
 7357         flushRegisters();
 7358     }
 7359     unlock(GPRInfo::returnValueGPR);
 7360 
 7361     // FIXME: There is a chance that we will call an effectful length property twice. This is safe
 7362     // from the standpoint of the VM&#39;s integrity, but it&#39;s subtly wrong from a spec compliance
 7363     // standpoint. The best solution would be one where we can exit *into* the op_call_varargs right
 7364     // past the sizing.
 7365     // https://bugs.webkit.org/show_bug.cgi?id=141448
 7366 
 7367     GPRReg argCountIncludingThisGPR =
 7368         JITCompiler::selectScratchGPR(GPRInfo::returnValueGPR, argumentsRegs);
 7369 
 7370     m_jit.add32(TrustedImm32(1), GPRInfo::returnValueGPR, argCountIncludingThisGPR);
 7371 
 7372     speculationCheck(
 7373         VarargsOverflow, JSValueSource(), Edge(), m_jit.branch32(
 7374             MacroAssembler::Above,
 7375             GPRInfo::returnValueGPR,
 7376             argCountIncludingThisGPR));
 7377 
 7378     speculationCheck(
 7379         VarargsOverflow, JSValueSource(), Edge(), m_jit.branch32(
 7380             MacroAssembler::Above,
 7381             argCountIncludingThisGPR,
 7382             TrustedImm32(data-&gt;limit)));
 7383 
 7384     m_jit.store32(argCountIncludingThisGPR, JITCompiler::payloadFor(data-&gt;machineCount));
 7385 
 7386     callOperation(operationLoadVarargs, data-&gt;machineStart.offset(), argumentsRegs, data-&gt;offset, GPRInfo::returnValueGPR, data-&gt;mandatoryMinimum);
 7387     m_jit.exceptionCheck();
 7388 
 7389     noResult(node);
 7390 }
 7391 
 7392 void SpeculativeJIT::compileForwardVarargs(Node* node)
 7393 {
 7394     LoadVarargsData* data = node-&gt;loadVarargsData();
 7395     InlineCallFrame* inlineCallFrame;
 7396     if (node-&gt;child1())
<a name="85" id="anc85"></a><span class="line-modified"> 7397         inlineCallFrame = node-&gt;child1()-&gt;origin.semantic.inlineCallFrame();</span>
 7398     else
<a name="86" id="anc86"></a><span class="line-modified"> 7399         inlineCallFrame = node-&gt;origin.semantic.inlineCallFrame();</span>
 7400 
 7401     GPRTemporary length(this);
 7402     JSValueRegsTemporary temp(this);
 7403     GPRReg lengthGPR = length.gpr();
 7404     JSValueRegs tempRegs = temp.regs();
 7405 
 7406     emitGetLength(inlineCallFrame, lengthGPR, /* includeThis = */ true);
 7407     if (data-&gt;offset)
 7408         m_jit.sub32(TrustedImm32(data-&gt;offset), lengthGPR);
 7409 
 7410     speculationCheck(
 7411         VarargsOverflow, JSValueSource(), Edge(), m_jit.branch32(
 7412             MacroAssembler::Above,
 7413             lengthGPR, TrustedImm32(data-&gt;limit)));
 7414 
 7415     m_jit.store32(lengthGPR, JITCompiler::payloadFor(data-&gt;machineCount));
 7416 
 7417     VirtualRegister sourceStart = JITCompiler::argumentsStart(inlineCallFrame) + data-&gt;offset;
 7418     VirtualRegister targetStart = data-&gt;machineStart;
 7419 
 7420     m_jit.sub32(TrustedImm32(1), lengthGPR);
 7421 
 7422     // First have a loop that fills in the undefined slots in case of an arity check failure.
 7423     m_jit.move(TrustedImm32(data-&gt;mandatoryMinimum), tempRegs.payloadGPR());
 7424     JITCompiler::Jump done = m_jit.branch32(JITCompiler::BelowOrEqual, tempRegs.payloadGPR(), lengthGPR);
 7425 
 7426     JITCompiler::Label loop = m_jit.label();
 7427     m_jit.sub32(TrustedImm32(1), tempRegs.payloadGPR());
 7428     m_jit.storeTrustedValue(
 7429         jsUndefined(),
 7430         JITCompiler::BaseIndex(
 7431             GPRInfo::callFrameRegister, tempRegs.payloadGPR(), JITCompiler::TimesEight,
 7432             targetStart.offset() * sizeof(EncodedJSValue)));
 7433     m_jit.branch32(JITCompiler::Above, tempRegs.payloadGPR(), lengthGPR).linkTo(loop, &amp;m_jit);
 7434     done.link(&amp;m_jit);
 7435 
 7436     // And then fill in the actual argument values.
 7437     done = m_jit.branchTest32(JITCompiler::Zero, lengthGPR);
 7438 
 7439     loop = m_jit.label();
 7440     m_jit.sub32(TrustedImm32(1), lengthGPR);
 7441     m_jit.loadValue(
 7442         JITCompiler::BaseIndex(
 7443             GPRInfo::callFrameRegister, lengthGPR, JITCompiler::TimesEight,
 7444             sourceStart.offset() * sizeof(EncodedJSValue)),
 7445         tempRegs);
 7446     m_jit.storeValue(
 7447         tempRegs,
 7448         JITCompiler::BaseIndex(
 7449             GPRInfo::callFrameRegister, lengthGPR, JITCompiler::TimesEight,
 7450             targetStart.offset() * sizeof(EncodedJSValue)));
 7451     m_jit.branchTest32(JITCompiler::NonZero, lengthGPR).linkTo(loop, &amp;m_jit);
 7452 
 7453     done.link(&amp;m_jit);
 7454 
 7455     noResult(node);
 7456 }
 7457 
 7458 void SpeculativeJIT::compileCreateActivation(Node* node)
 7459 {
 7460     SymbolTable* table = node-&gt;castOperand&lt;SymbolTable*&gt;();
 7461     RegisteredStructure structure = m_jit.graph().registerStructure(m_jit.graph().globalObjectFor(
 7462         node-&gt;origin.semantic)-&gt;activationStructure());
 7463 
 7464     SpeculateCellOperand scope(this, node-&gt;child1());
 7465     GPRReg scopeGPR = scope.gpr();
 7466     JSValue initializationValue = node-&gt;initializationValueForActivation();
 7467     ASSERT(initializationValue == jsUndefined() || initializationValue == jsTDZValue());
 7468 
<a name="87" id="anc87"></a><span class="line-modified"> 7469     if (table-&gt;singleton().isStillValid()) {</span>
 7470         GPRFlushedCallResult result(this);
 7471         GPRReg resultGPR = result.gpr();
 7472 
 7473 #if USE(JSVALUE32_64)
 7474         JSValueRegsTemporary initialization(this);
 7475         JSValueRegs initializationRegs = initialization.regs();
 7476         m_jit.moveTrustedValue(initializationValue, initializationRegs);
 7477 #endif
 7478 
 7479         flushRegisters();
 7480 
 7481 #if USE(JSVALUE64)
 7482         callOperation(operationCreateActivationDirect,
 7483             resultGPR, structure, scopeGPR, table, TrustedImm64(JSValue::encode(initializationValue)));
 7484 #else
 7485         callOperation(operationCreateActivationDirect,
 7486             resultGPR, structure, scopeGPR, table, initializationRegs);
 7487 #endif
 7488         m_jit.exceptionCheck();
 7489         cellResult(resultGPR, node);
 7490         return;
 7491     }
 7492 
 7493     GPRTemporary result(this);
 7494     GPRTemporary scratch1(this);
 7495     GPRTemporary scratch2(this);
 7496     GPRReg resultGPR = result.gpr();
 7497     GPRReg scratch1GPR = scratch1.gpr();
 7498     GPRReg scratch2GPR = scratch2.gpr();
 7499 
 7500 #if USE(JSVALUE32_64)
 7501     JSValueRegsTemporary initialization(this);
 7502     JSValueRegs initializationRegs = initialization.regs();
 7503     m_jit.moveTrustedValue(initializationValue, initializationRegs);
 7504 #endif
 7505 
 7506     JITCompiler::JumpList slowPath;
 7507     auto butterfly = TrustedImmPtr(nullptr);
 7508     emitAllocateJSObjectWithKnownSize&lt;JSLexicalEnvironment&gt;(
 7509         resultGPR, TrustedImmPtr(structure), butterfly, scratch1GPR, scratch2GPR,
 7510         slowPath, JSLexicalEnvironment::allocationSize(table));
 7511 
 7512     // Don&#39;t need a memory barriers since we just fast-created the activation, so the
 7513     // activation must be young.
 7514     m_jit.storePtr(scopeGPR, JITCompiler::Address(resultGPR, JSScope::offsetOfNext()));
 7515     m_jit.storePtr(
 7516         TrustedImmPtr(node-&gt;cellOperand()),
 7517         JITCompiler::Address(resultGPR, JSLexicalEnvironment::offsetOfSymbolTable()));
 7518 
 7519     // Must initialize all members to undefined or the TDZ empty value.
 7520     for (unsigned i = 0; i &lt; table-&gt;scopeSize(); ++i) {
 7521         m_jit.storeTrustedValue(
 7522             initializationValue,
 7523             JITCompiler::Address(
 7524                 resultGPR, JSLexicalEnvironment::offsetOfVariable(ScopeOffset(i))));
 7525     }
 7526 
<a name="88" id="anc88"></a><span class="line-modified"> 7527     m_jit.mutatorFence(vm());</span>
 7528 
 7529 #if USE(JSVALUE64)
 7530     addSlowPathGenerator(
 7531         slowPathCall(
 7532             slowPath, this, operationCreateActivationDirect, resultGPR, structure, scopeGPR, table, TrustedImm64(JSValue::encode(initializationValue))));
 7533 #else
 7534     addSlowPathGenerator(
 7535         slowPathCall(
 7536             slowPath, this, operationCreateActivationDirect, resultGPR, structure, scopeGPR, table, initializationRegs));
 7537 #endif
 7538 
 7539     cellResult(resultGPR, node);
 7540 }
 7541 
 7542 void SpeculativeJIT::compileCreateDirectArguments(Node* node)
 7543 {
 7544     // FIXME: A more effective way of dealing with the argument count and callee is to have
 7545     // them be explicit arguments to this node.
 7546     // https://bugs.webkit.org/show_bug.cgi?id=142207
 7547 
 7548     GPRTemporary result(this);
 7549     GPRTemporary scratch1(this);
 7550     GPRTemporary scratch2(this);
 7551     GPRTemporary length;
 7552     GPRReg resultGPR = result.gpr();
 7553     GPRReg scratch1GPR = scratch1.gpr();
 7554     GPRReg scratch2GPR = scratch2.gpr();
 7555     GPRReg lengthGPR = InvalidGPRReg;
 7556     JSValueRegs valueRegs = JSValueRegs::withTwoAvailableRegs(scratch1GPR, scratch2GPR);
 7557 
 7558     unsigned minCapacity = m_jit.graph().baselineCodeBlockFor(node-&gt;origin.semantic)-&gt;numParameters() - 1;
 7559 
 7560     unsigned knownLength;
 7561     bool lengthIsKnown; // if false, lengthGPR will have the length.
<a name="89" id="anc89"></a><span class="line-modified"> 7562     auto* inlineCallFrame = node-&gt;origin.semantic.inlineCallFrame();</span>
<span class="line-modified"> 7563     if (inlineCallFrame</span>
<span class="line-modified"> 7564         &amp;&amp; !inlineCallFrame-&gt;isVarargs()) {</span>
<span class="line-added"> 7565         knownLength = inlineCallFrame-&gt;argumentCountIncludingThis - 1;</span>
 7566         lengthIsKnown = true;
 7567     } else {
 7568         knownLength = UINT_MAX;
 7569         lengthIsKnown = false;
 7570 
 7571         GPRTemporary realLength(this);
 7572         length.adopt(realLength);
 7573         lengthGPR = length.gpr();
 7574 
 7575         VirtualRegister argumentCountRegister = m_jit.argumentCount(node-&gt;origin.semantic);
 7576         m_jit.load32(JITCompiler::payloadFor(argumentCountRegister), lengthGPR);
 7577         m_jit.sub32(TrustedImm32(1), lengthGPR);
 7578     }
 7579 
 7580     RegisteredStructure structure =
 7581         m_jit.graph().registerStructure(m_jit.graph().globalObjectFor(node-&gt;origin.semantic)-&gt;directArgumentsStructure());
 7582 
 7583     // Use a different strategy for allocating the object depending on whether we know its
 7584     // size statically.
 7585     JITCompiler::JumpList slowPath;
 7586     if (lengthIsKnown) {
 7587         auto butterfly = TrustedImmPtr(nullptr);
 7588         emitAllocateJSObjectWithKnownSize&lt;DirectArguments&gt;(
 7589             resultGPR, TrustedImmPtr(structure), butterfly, scratch1GPR, scratch2GPR,
 7590             slowPath, DirectArguments::allocationSize(std::max(knownLength, minCapacity)));
 7591 
 7592         m_jit.store32(
 7593             TrustedImm32(knownLength),
 7594             JITCompiler::Address(resultGPR, DirectArguments::offsetOfLength()));
 7595     } else {
 7596         JITCompiler::Jump tooFewArguments;
 7597         if (minCapacity) {
 7598             tooFewArguments =
 7599                 m_jit.branch32(JITCompiler::Below, lengthGPR, TrustedImm32(minCapacity));
 7600         }
 7601         m_jit.lshift32(lengthGPR, TrustedImm32(3), scratch1GPR);
 7602         m_jit.add32(TrustedImm32(DirectArguments::storageOffset()), scratch1GPR);
 7603         if (minCapacity) {
 7604             JITCompiler::Jump done = m_jit.jump();
 7605             tooFewArguments.link(&amp;m_jit);
 7606             m_jit.move(TrustedImm32(DirectArguments::allocationSize(minCapacity)), scratch1GPR);
 7607             done.link(&amp;m_jit);
 7608         }
 7609 
 7610         emitAllocateVariableSizedJSObject&lt;DirectArguments&gt;(
 7611             resultGPR, TrustedImmPtr(structure), scratch1GPR, scratch1GPR, scratch2GPR,
 7612             slowPath);
 7613 
 7614         m_jit.store32(
 7615             lengthGPR, JITCompiler::Address(resultGPR, DirectArguments::offsetOfLength()));
 7616     }
 7617 
 7618     m_jit.store32(
 7619         TrustedImm32(minCapacity),
 7620         JITCompiler::Address(resultGPR, DirectArguments::offsetOfMinCapacity()));
 7621 
 7622     m_jit.storePtr(
 7623         TrustedImmPtr(nullptr), JITCompiler::Address(resultGPR, DirectArguments::offsetOfMappedArguments()));
 7624 
 7625     m_jit.storePtr(
 7626         TrustedImmPtr(nullptr), JITCompiler::Address(resultGPR, DirectArguments::offsetOfModifiedArgumentsDescriptor()));
 7627 
 7628     if (lengthIsKnown) {
 7629         addSlowPathGenerator(
 7630             slowPathCall(
 7631                 slowPath, this, operationCreateDirectArguments, resultGPR, structure,
 7632                 knownLength, minCapacity));
 7633     } else {
<a name="90" id="anc90"></a><span class="line-modified"> 7634         auto generator = makeUnique&lt;CallCreateDirectArgumentsSlowPathGenerator&gt;(</span>
 7635             slowPath, this, resultGPR, structure, lengthGPR, minCapacity);
 7636         addSlowPathGenerator(WTFMove(generator));
 7637     }
 7638 
<a name="91" id="anc91"></a><span class="line-modified"> 7639     if (inlineCallFrame) {</span>
<span class="line-modified"> 7640         if (inlineCallFrame-&gt;isClosureCall) {</span>
 7641             m_jit.loadPtr(
 7642                 JITCompiler::addressFor(
<a name="92" id="anc92"></a><span class="line-modified"> 7643                     inlineCallFrame-&gt;calleeRecovery.virtualRegister()),</span>
 7644                 scratch1GPR);
 7645         } else {
 7646             m_jit.move(
 7647                 TrustedImmPtr::weakPointer(
<a name="93" id="anc93"></a><span class="line-modified"> 7648                     m_jit.graph(), inlineCallFrame-&gt;calleeRecovery.constant().asCell()),</span>
 7649                 scratch1GPR);
 7650         }
 7651     } else
 7652         m_jit.loadPtr(JITCompiler::addressFor(CallFrameSlot::callee), scratch1GPR);
 7653 
 7654     // Don&#39;t need a memory barriers since we just fast-created the activation, so the
 7655     // activation must be young.
 7656     m_jit.storePtr(
 7657         scratch1GPR, JITCompiler::Address(resultGPR, DirectArguments::offsetOfCallee()));
 7658 
 7659     VirtualRegister start = m_jit.argumentsStart(node-&gt;origin.semantic);
 7660     if (lengthIsKnown) {
 7661         for (unsigned i = 0; i &lt; std::max(knownLength, minCapacity); ++i) {
 7662             m_jit.loadValue(JITCompiler::addressFor(start + i), valueRegs);
 7663             m_jit.storeValue(
 7664                 valueRegs, JITCompiler::Address(resultGPR, DirectArguments::offsetOfSlot(i)));
 7665         }
 7666     } else {
 7667         JITCompiler::Jump done;
 7668         if (minCapacity) {
 7669             JITCompiler::Jump startLoop = m_jit.branch32(
 7670                 JITCompiler::AboveOrEqual, lengthGPR, TrustedImm32(minCapacity));
 7671             m_jit.move(TrustedImm32(minCapacity), lengthGPR);
 7672             startLoop.link(&amp;m_jit);
 7673         } else
 7674             done = m_jit.branchTest32(MacroAssembler::Zero, lengthGPR);
 7675         JITCompiler::Label loop = m_jit.label();
 7676         m_jit.sub32(TrustedImm32(1), lengthGPR);
 7677         m_jit.loadValue(
 7678             JITCompiler::BaseIndex(
 7679                 GPRInfo::callFrameRegister, lengthGPR, JITCompiler::TimesEight,
 7680                 start.offset() * static_cast&lt;int&gt;(sizeof(Register))),
 7681             valueRegs);
 7682         m_jit.storeValue(
 7683             valueRegs,
 7684             JITCompiler::BaseIndex(
 7685                 resultGPR, lengthGPR, JITCompiler::TimesEight,
 7686                 DirectArguments::storageOffset()));
 7687         m_jit.branchTest32(MacroAssembler::NonZero, lengthGPR).linkTo(loop, &amp;m_jit);
 7688         if (done.isSet())
 7689             done.link(&amp;m_jit);
 7690     }
 7691 
<a name="94" id="anc94"></a><span class="line-modified"> 7692     m_jit.mutatorFence(vm());</span>
 7693 
 7694     cellResult(resultGPR, node);
 7695 }
 7696 
 7697 void SpeculativeJIT::compileGetFromArguments(Node* node)
 7698 {
 7699     SpeculateCellOperand arguments(this, node-&gt;child1());
 7700     JSValueRegsTemporary result(this);
 7701 
 7702     GPRReg argumentsGPR = arguments.gpr();
 7703     JSValueRegs resultRegs = result.regs();
 7704 
 7705     m_jit.loadValue(JITCompiler::Address(argumentsGPR, DirectArguments::offsetOfSlot(node-&gt;capturedArgumentsOffset().offset())), resultRegs);
 7706     jsValueResult(resultRegs, node);
 7707 }
 7708 
 7709 void SpeculativeJIT::compilePutToArguments(Node* node)
 7710 {
 7711     SpeculateCellOperand arguments(this, node-&gt;child1());
 7712     JSValueOperand value(this, node-&gt;child2());
 7713 
 7714     GPRReg argumentsGPR = arguments.gpr();
 7715     JSValueRegs valueRegs = value.jsValueRegs();
 7716 
 7717     m_jit.storeValue(valueRegs, JITCompiler::Address(argumentsGPR, DirectArguments::offsetOfSlot(node-&gt;capturedArgumentsOffset().offset())));
 7718     noResult(node);
 7719 }
 7720 
 7721 void SpeculativeJIT::compileGetArgument(Node* node)
 7722 {
 7723     GPRTemporary argumentCount(this);
 7724     JSValueRegsTemporary result(this);
 7725     GPRReg argumentCountGPR = argumentCount.gpr();
 7726     JSValueRegs resultRegs = result.regs();
 7727     m_jit.load32(CCallHelpers::payloadFor(m_jit.argumentCount(node-&gt;origin.semantic)), argumentCountGPR);
 7728     auto argumentOutOfBounds = m_jit.branch32(CCallHelpers::LessThanOrEqual, argumentCountGPR, CCallHelpers::TrustedImm32(node-&gt;argumentIndex()));
 7729     m_jit.loadValue(CCallHelpers::addressFor(CCallHelpers::argumentsStart(node-&gt;origin.semantic) + node-&gt;argumentIndex() - 1), resultRegs);
 7730     auto done = m_jit.jump();
 7731 
 7732     argumentOutOfBounds.link(&amp;m_jit);
 7733     m_jit.moveValue(jsUndefined(), resultRegs);
 7734 
 7735     done.link(&amp;m_jit);
 7736     jsValueResult(resultRegs, node);
 7737 }
 7738 
 7739 void SpeculativeJIT::compileCreateScopedArguments(Node* node)
 7740 {
 7741     SpeculateCellOperand scope(this, node-&gt;child1());
 7742     GPRReg scopeGPR = scope.gpr();
 7743 
 7744     GPRFlushedCallResult result(this);
 7745     GPRReg resultGPR = result.gpr();
 7746     flushRegisters();
 7747 
 7748     // We set up the arguments ourselves, because we have the whole register file and we can
 7749     // set them up directly into the argument registers. This also means that we don&#39;t have to
 7750     // invent a four-argument-register shuffle.
 7751 
 7752     // Arguments: 0:exec, 1:structure, 2:start, 3:length, 4:callee, 5:scope
 7753 
 7754     // Do the scopeGPR first, since it might alias an argument register.
 7755     m_jit.setupArgument(5, [&amp;] (GPRReg destGPR) { m_jit.move(scopeGPR, destGPR); });
 7756 
 7757     // These other things could be done in any order.
 7758     m_jit.setupArgument(4, [&amp;] (GPRReg destGPR) { emitGetCallee(node-&gt;origin.semantic, destGPR); });
 7759     m_jit.setupArgument(3, [&amp;] (GPRReg destGPR) { emitGetLength(node-&gt;origin.semantic, destGPR); });
 7760     m_jit.setupArgument(2, [&amp;] (GPRReg destGPR) { emitGetArgumentStart(node-&gt;origin.semantic, destGPR); });
 7761     m_jit.setupArgument(
 7762         1, [&amp;] (GPRReg destGPR) {
 7763             m_jit.move(
 7764                 TrustedImmPtr::weakPointer(m_jit.graph(), m_jit.globalObjectFor(node-&gt;origin.semantic)-&gt;scopedArgumentsStructure()),
 7765                 destGPR);
 7766         });
 7767     m_jit.setupArgument(0, [&amp;] (GPRReg destGPR) { m_jit.move(GPRInfo::callFrameRegister, destGPR); });
 7768 
 7769     appendCallSetResult(operationCreateScopedArguments, resultGPR);
 7770     m_jit.exceptionCheck();
 7771 
 7772     cellResult(resultGPR, node);
 7773 }
 7774 
 7775 void SpeculativeJIT::compileCreateClonedArguments(Node* node)
 7776 {
 7777     GPRFlushedCallResult result(this);
 7778     GPRReg resultGPR = result.gpr();
 7779     flushRegisters();
 7780 
 7781     // We set up the arguments ourselves, because we have the whole register file and we can
 7782     // set them up directly into the argument registers.
 7783 
 7784     // Arguments: 0:exec, 1:structure, 2:start, 3:length, 4:callee
 7785     m_jit.setupArgument(4, [&amp;] (GPRReg destGPR) { emitGetCallee(node-&gt;origin.semantic, destGPR); });
 7786     m_jit.setupArgument(3, [&amp;] (GPRReg destGPR) { emitGetLength(node-&gt;origin.semantic, destGPR); });
 7787     m_jit.setupArgument(2, [&amp;] (GPRReg destGPR) { emitGetArgumentStart(node-&gt;origin.semantic, destGPR); });
 7788     m_jit.setupArgument(
 7789         1, [&amp;] (GPRReg destGPR) {
 7790             m_jit.move(
 7791                 TrustedImmPtr::weakPointer(
 7792                     m_jit.graph(), m_jit.globalObjectFor(node-&gt;origin.semantic)-&gt;clonedArgumentsStructure()),
 7793                 destGPR);
 7794         });
 7795     m_jit.setupArgument(0, [&amp;] (GPRReg destGPR) { m_jit.move(GPRInfo::callFrameRegister, destGPR); });
 7796 
 7797     appendCallSetResult(operationCreateClonedArguments, resultGPR);
 7798     m_jit.exceptionCheck();
 7799 
 7800     cellResult(resultGPR, node);
 7801 }
 7802 
 7803 void SpeculativeJIT::compileCreateRest(Node* node)
 7804 {
 7805     ASSERT(node-&gt;op() == CreateRest);
 7806 
 7807 #if !CPU(X86)
 7808     if (m_jit.graph().isWatchingHavingABadTimeWatchpoint(node)) {
 7809         SpeculateStrictInt32Operand arrayLength(this, node-&gt;child1());
 7810         GPRTemporary arrayResult(this);
 7811 
 7812         GPRReg arrayLengthGPR = arrayLength.gpr();
 7813         GPRReg arrayResultGPR = arrayResult.gpr();
 7814 
 7815         // We can tell compileAllocateNewArrayWithSize() that it does not need to check
 7816         // for large arrays and use ArrayStorage structure because arrayLength here will
 7817         // always be bounded by stack size. Realistically, we won&#39;t be able to push enough
 7818         // arguments to have arrayLength exceed MIN_ARRAY_STORAGE_CONSTRUCTION_LENGTH.
 7819         bool shouldAllowForArrayStorageStructureForLargeArrays = false;
 7820         ASSERT(m_jit.graph().globalObjectFor(node-&gt;origin.semantic)-&gt;restParameterStructure()-&gt;indexingMode() == ArrayWithContiguous || m_jit.graph().globalObjectFor(node-&gt;origin.semantic)-&gt;isHavingABadTime());
 7821         compileAllocateNewArrayWithSize(m_jit.graph().globalObjectFor(node-&gt;origin.semantic), arrayResultGPR, arrayLengthGPR, ArrayWithContiguous, shouldAllowForArrayStorageStructureForLargeArrays);
 7822 
 7823         GPRTemporary argumentsStart(this);
 7824         GPRReg argumentsStartGPR = argumentsStart.gpr();
 7825 
 7826         emitGetArgumentStart(node-&gt;origin.semantic, argumentsStartGPR);
 7827 
 7828         GPRTemporary butterfly(this);
 7829         GPRTemporary currentLength(this);
 7830         JSValueRegsTemporary value(this);
 7831 
 7832         JSValueRegs valueRegs = value.regs();
 7833         GPRReg currentLengthGPR = currentLength.gpr();
 7834         GPRReg butterflyGPR = butterfly.gpr();
 7835 
 7836         m_jit.loadPtr(MacroAssembler::Address(arrayResultGPR, JSObject::butterflyOffset()), butterflyGPR);
 7837 
 7838         CCallHelpers::Jump skipLoop = m_jit.branch32(MacroAssembler::Equal, arrayLengthGPR, TrustedImm32(0));
 7839         m_jit.zeroExtend32ToPtr(arrayLengthGPR, currentLengthGPR);
 7840         m_jit.addPtr(Imm32(sizeof(Register) * node-&gt;numberOfArgumentsToSkip()), argumentsStartGPR);
 7841 
 7842         auto loop = m_jit.label();
 7843         m_jit.sub32(TrustedImm32(1), currentLengthGPR);
 7844         m_jit.loadValue(JITCompiler::BaseIndex(argumentsStartGPR, currentLengthGPR, MacroAssembler::TimesEight), valueRegs);
 7845         m_jit.storeValue(valueRegs, MacroAssembler::BaseIndex(butterflyGPR, currentLengthGPR, MacroAssembler::TimesEight));
 7846         m_jit.branch32(MacroAssembler::NotEqual, currentLengthGPR, TrustedImm32(0)).linkTo(loop, &amp;m_jit);
 7847 
 7848         skipLoop.link(&amp;m_jit);
 7849         cellResult(arrayResultGPR, node);
 7850         return;
 7851     }
 7852 #endif // !CPU(X86)
 7853 
 7854     SpeculateStrictInt32Operand arrayLength(this, node-&gt;child1());
 7855     GPRTemporary argumentsStart(this);
 7856     GPRTemporary numberOfArgumentsToSkip(this);
 7857 
 7858     GPRReg arrayLengthGPR = arrayLength.gpr();
 7859     GPRReg argumentsStartGPR = argumentsStart.gpr();
 7860 
 7861     emitGetArgumentStart(node-&gt;origin.semantic, argumentsStartGPR);
 7862 
 7863     flushRegisters();
 7864 
 7865     GPRFlushedCallResult result(this);
 7866     GPRReg resultGPR = result.gpr();
 7867     callOperation(operationCreateRest, resultGPR, argumentsStartGPR, Imm32(node-&gt;numberOfArgumentsToSkip()), arrayLengthGPR);
 7868     m_jit.exceptionCheck();
 7869 
 7870     cellResult(resultGPR, node);
 7871 }
 7872 
 7873 void SpeculativeJIT::compileSpread(Node* node)
 7874 {
 7875     ASSERT(node-&gt;op() == Spread);
 7876 
 7877     SpeculateCellOperand operand(this, node-&gt;child1());
 7878     GPRReg argument = operand.gpr();
 7879 
 7880     if (node-&gt;child1().useKind() == ArrayUse)
 7881         speculateArray(node-&gt;child1(), argument);
 7882 
 7883     if (m_jit.graph().canDoFastSpread(node, m_state.forNode(node-&gt;child1()))) {
 7884 #if USE(JSVALUE64)
 7885         GPRTemporary result(this);
 7886         GPRTemporary scratch1(this);
 7887         GPRTemporary scratch2(this);
 7888         GPRTemporary length(this);
 7889         FPRTemporary doubleRegister(this);
 7890 
 7891         GPRReg resultGPR = result.gpr();
 7892         GPRReg scratch1GPR = scratch1.gpr();
 7893         GPRReg scratch2GPR = scratch2.gpr();
 7894         GPRReg lengthGPR = length.gpr();
 7895         FPRReg doubleFPR = doubleRegister.fpr();
 7896 
 7897         MacroAssembler::JumpList slowPath;
 7898 
 7899         m_jit.load8(MacroAssembler::Address(argument, JSCell::indexingTypeAndMiscOffset()), scratch1GPR);
 7900         m_jit.and32(TrustedImm32(IndexingShapeMask), scratch1GPR);
 7901         m_jit.sub32(TrustedImm32(Int32Shape), scratch1GPR);
 7902 
 7903         slowPath.append(m_jit.branch32(MacroAssembler::Above, scratch1GPR, TrustedImm32(ContiguousShape - Int32Shape)));
 7904 
 7905         m_jit.loadPtr(MacroAssembler::Address(argument, JSObject::butterflyOffset()), lengthGPR);
 7906         m_jit.load32(MacroAssembler::Address(lengthGPR, Butterfly::offsetOfPublicLength()), lengthGPR);
 7907         static_assert(sizeof(JSValue) == 8 &amp;&amp; 1 &lt;&lt; 3 == 8, &quot;This is strongly assumed in the code below.&quot;);
 7908         m_jit.move(lengthGPR, scratch1GPR);
 7909         m_jit.lshift32(TrustedImm32(3), scratch1GPR);
 7910         m_jit.add32(TrustedImm32(JSFixedArray::offsetOfData()), scratch1GPR);
 7911 
<a name="95" id="anc95"></a><span class="line-modified"> 7912         m_jit.emitAllocateVariableSizedCell&lt;JSFixedArray&gt;(vm(), resultGPR, TrustedImmPtr(m_jit.graph().registerStructure(m_jit.graph().m_vm.fixedArrayStructure.get())), scratch1GPR, scratch1GPR, scratch2GPR, slowPath);</span>
 7913         m_jit.store32(lengthGPR, MacroAssembler::Address(resultGPR, JSFixedArray::offsetOfSize()));
 7914 
 7915         m_jit.loadPtr(MacroAssembler::Address(argument, JSObject::butterflyOffset()), scratch1GPR);
 7916 
 7917         MacroAssembler::JumpList done;
 7918 
 7919         m_jit.load8(MacroAssembler::Address(argument, JSCell::indexingTypeAndMiscOffset()), scratch2GPR);
 7920         m_jit.and32(TrustedImm32(IndexingShapeMask), scratch2GPR);
 7921         auto isDoubleArray = m_jit.branch32(MacroAssembler::Equal, scratch2GPR, TrustedImm32(DoubleShape));
 7922 
 7923         {
 7924             done.append(m_jit.branchTest32(MacroAssembler::Zero, lengthGPR));
 7925             auto loopStart = m_jit.label();
 7926             m_jit.sub32(TrustedImm32(1), lengthGPR);
 7927             m_jit.load64(MacroAssembler::BaseIndex(scratch1GPR, lengthGPR, MacroAssembler::TimesEight), scratch2GPR);
 7928             auto notEmpty = m_jit.branchIfNotEmpty(scratch2GPR);
 7929             m_jit.move(TrustedImm64(JSValue::encode(jsUndefined())), scratch2GPR);
 7930             notEmpty.link(&amp;m_jit);
 7931             m_jit.store64(scratch2GPR, MacroAssembler::BaseIndex(resultGPR, lengthGPR, MacroAssembler::TimesEight, JSFixedArray::offsetOfData()));
 7932             m_jit.branchTest32(MacroAssembler::NonZero, lengthGPR).linkTo(loopStart, &amp;m_jit);
 7933             done.append(m_jit.jump());
 7934         }
 7935 
 7936         isDoubleArray.link(&amp;m_jit);
 7937         {
 7938             done.append(m_jit.branchTest32(MacroAssembler::Zero, lengthGPR));
 7939             auto loopStart = m_jit.label();
 7940             m_jit.sub32(TrustedImm32(1), lengthGPR);
 7941             m_jit.loadDouble(MacroAssembler::BaseIndex(scratch1GPR, lengthGPR, MacroAssembler::TimesEight), doubleFPR);
 7942             auto notEmpty = m_jit.branchIfNotNaN(doubleFPR);
 7943             m_jit.move(TrustedImm64(JSValue::encode(jsUndefined())), scratch2GPR);
 7944             auto doStore = m_jit.jump();
 7945             notEmpty.link(&amp;m_jit);
 7946             m_jit.boxDouble(doubleFPR, scratch2GPR);
 7947             doStore.link(&amp;m_jit);
 7948             m_jit.store64(scratch2GPR, MacroAssembler::BaseIndex(resultGPR, lengthGPR, MacroAssembler::TimesEight, JSFixedArray::offsetOfData()));
 7949             m_jit.branchTest32(MacroAssembler::NonZero, lengthGPR).linkTo(loopStart, &amp;m_jit);
 7950             done.append(m_jit.jump());
 7951         }
 7952 
<a name="96" id="anc96"></a><span class="line-modified"> 7953         m_jit.mutatorFence(vm());</span>
 7954 
 7955         slowPath.link(&amp;m_jit);
 7956         addSlowPathGenerator(slowPathCall(m_jit.jump(), this, operationSpreadFastArray, resultGPR, argument));
 7957 
 7958         done.link(&amp;m_jit);
 7959         cellResult(resultGPR, node);
 7960 #else
 7961         flushRegisters();
 7962 
 7963         GPRFlushedCallResult result(this);
 7964         GPRReg resultGPR = result.gpr();
 7965         callOperation(operationSpreadFastArray, resultGPR, argument);
 7966         m_jit.exceptionCheck();
 7967         cellResult(resultGPR, node);
 7968 #endif // USE(JSVALUE64)
 7969     } else {
 7970         flushRegisters();
 7971 
 7972         GPRFlushedCallResult result(this);
 7973         GPRReg resultGPR = result.gpr();
 7974         callOperation(operationSpreadGeneric, resultGPR, argument);
 7975         m_jit.exceptionCheck();
 7976         cellResult(resultGPR, node);
 7977     }
 7978 }
 7979 
 7980 void SpeculativeJIT::compileNewArray(Node* node)
 7981 {
 7982     JSGlobalObject* globalObject = m_jit.graph().globalObjectFor(node-&gt;origin.semantic);
 7983     if (!globalObject-&gt;isHavingABadTime() &amp;&amp; !hasAnyArrayStorage(node-&gt;indexingType())) {
 7984         RegisteredStructure structure = m_jit.graph().registerStructure(globalObject-&gt;arrayStructureForIndexingTypeDuringAllocation(node-&gt;indexingType()));
 7985         DFG_ASSERT(m_jit.graph(), node, structure-&gt;indexingType() == node-&gt;indexingType(), structure-&gt;indexingType(), node-&gt;indexingType());
 7986         ASSERT(
 7987             hasUndecided(structure-&gt;indexingType())
 7988             || hasInt32(structure-&gt;indexingType())
 7989             || hasDouble(structure-&gt;indexingType())
 7990             || hasContiguous(structure-&gt;indexingType()));
 7991 
 7992         unsigned numElements = node-&gt;numChildren();
 7993         unsigned vectorLengthHint = node-&gt;vectorLengthHint();
 7994         ASSERT(vectorLengthHint &gt;= numElements);
 7995 
 7996         GPRTemporary result(this);
 7997         GPRTemporary storage(this);
 7998 
 7999         GPRReg resultGPR = result.gpr();
 8000         GPRReg storageGPR = storage.gpr();
 8001 
 8002         emitAllocateRawObject(resultGPR, structure, storageGPR, numElements, vectorLengthHint);
 8003 
 8004         // At this point, one way or another, resultGPR and storageGPR have pointers to
 8005         // the JSArray and the Butterfly, respectively.
 8006 
 8007         ASSERT(!hasUndecided(structure-&gt;indexingType()) || !node-&gt;numChildren());
 8008 
 8009         for (unsigned operandIdx = 0; operandIdx &lt; node-&gt;numChildren(); ++operandIdx) {
 8010             Edge use = m_jit.graph().m_varArgChildren[node-&gt;firstChild() + operandIdx];
 8011             switch (node-&gt;indexingType()) {
 8012             case ALL_BLANK_INDEXING_TYPES:
 8013             case ALL_UNDECIDED_INDEXING_TYPES:
 8014                 CRASH();
 8015                 break;
 8016             case ALL_DOUBLE_INDEXING_TYPES: {
 8017                 SpeculateDoubleOperand operand(this, use);
 8018                 FPRReg opFPR = operand.fpr();
 8019                 DFG_TYPE_CHECK(
 8020                     JSValueRegs(), use, SpecDoubleReal,
 8021                     m_jit.branchIfNaN(opFPR));
 8022                 m_jit.storeDouble(opFPR, MacroAssembler::Address(storageGPR, sizeof(double) * operandIdx));
 8023                 break;
 8024             }
 8025             case ALL_INT32_INDEXING_TYPES:
 8026             case ALL_CONTIGUOUS_INDEXING_TYPES: {
 8027                 JSValueOperand operand(this, use, ManualOperandSpeculation);
 8028                 JSValueRegs operandRegs = operand.jsValueRegs();
 8029                 if (hasInt32(node-&gt;indexingType())) {
 8030                     DFG_TYPE_CHECK(
 8031                         operandRegs, use, SpecInt32Only,
 8032                         m_jit.branchIfNotInt32(operandRegs));
 8033                 }
 8034                 m_jit.storeValue(operandRegs, MacroAssembler::Address(storageGPR, sizeof(JSValue) * operandIdx));
 8035                 break;
 8036             }
 8037             default:
 8038                 CRASH();
 8039                 break;
 8040             }
 8041         }
 8042 
 8043         // Yuck, we should *really* have a way of also returning the storageGPR. But
 8044         // that&#39;s the least of what&#39;s wrong with this code. We really shouldn&#39;t be
 8045         // allocating the array after having computed - and probably spilled to the
 8046         // stack - all of the things that will go into the array. The solution to that
 8047         // bigger problem will also likely fix the redundancy in reloading the storage
 8048         // pointer that we currently have.
 8049 
 8050         cellResult(resultGPR, node);
 8051         return;
 8052     }
 8053 
 8054     if (!node-&gt;numChildren()) {
 8055         flushRegisters();
 8056         GPRFlushedCallResult result(this);
 8057         callOperation(operationNewEmptyArray, result.gpr(), m_jit.graph().registerStructure(globalObject-&gt;arrayStructureForIndexingTypeDuringAllocation(node-&gt;indexingType())));
 8058         m_jit.exceptionCheck();
 8059         cellResult(result.gpr(), node);
 8060         return;
 8061     }
 8062 
 8063     size_t scratchSize = sizeof(EncodedJSValue) * node-&gt;numChildren();
<a name="97" id="anc97"></a><span class="line-modified"> 8064     ScratchBuffer* scratchBuffer = vm().scratchBufferForSize(scratchSize);</span>
 8065     EncodedJSValue* buffer = scratchBuffer ? static_cast&lt;EncodedJSValue*&gt;(scratchBuffer-&gt;dataBuffer()) : nullptr;
 8066 
 8067     for (unsigned operandIdx = 0; operandIdx &lt; node-&gt;numChildren(); ++operandIdx) {
 8068         // Need to perform the speculations that this node promises to perform. If we&#39;re
 8069         // emitting code here and the indexing type is not array storage then there is
 8070         // probably something hilarious going on and we&#39;re already failing at all the
 8071         // things, but at least we&#39;re going to be sound.
 8072         Edge use = m_jit.graph().m_varArgChildren[node-&gt;firstChild() + operandIdx];
 8073         switch (node-&gt;indexingType()) {
 8074         case ALL_BLANK_INDEXING_TYPES:
 8075         case ALL_UNDECIDED_INDEXING_TYPES:
 8076             CRASH();
 8077             break;
 8078         case ALL_DOUBLE_INDEXING_TYPES: {
 8079             SpeculateDoubleOperand operand(this, use);
 8080             FPRReg opFPR = operand.fpr();
 8081             DFG_TYPE_CHECK(
 8082                 JSValueRegs(), use, SpecDoubleReal,
 8083                 m_jit.branchIfNaN(opFPR));
 8084 #if USE(JSVALUE64)
 8085             JSValueRegsTemporary scratch(this);
 8086             JSValueRegs scratchRegs = scratch.regs();
 8087             m_jit.boxDouble(opFPR, scratchRegs);
 8088             m_jit.storeValue(scratchRegs, buffer + operandIdx);
 8089 #else
 8090             m_jit.storeDouble(opFPR, TrustedImmPtr(buffer + operandIdx));
 8091 #endif
 8092             operand.use();
 8093             break;
 8094         }
 8095         case ALL_INT32_INDEXING_TYPES:
 8096         case ALL_CONTIGUOUS_INDEXING_TYPES:
 8097         case ALL_ARRAY_STORAGE_INDEXING_TYPES: {
 8098             JSValueOperand operand(this, use, ManualOperandSpeculation);
 8099             JSValueRegs operandRegs = operand.jsValueRegs();
 8100             if (hasInt32(node-&gt;indexingType())) {
 8101                 DFG_TYPE_CHECK(
 8102                     operandRegs, use, SpecInt32Only,
 8103                     m_jit.branchIfNotInt32(operandRegs));
 8104             }
 8105             m_jit.storeValue(operandRegs, buffer + operandIdx);
 8106             operand.use();
 8107             break;
 8108         }
 8109         default:
 8110             CRASH();
 8111             break;
 8112         }
 8113     }
 8114 
 8115     flushRegisters();
 8116 
 8117     if (scratchSize) {
 8118         GPRTemporary scratch(this);
 8119 
 8120         // Tell GC mark phase how much of the scratch buffer is active during call.
 8121         m_jit.move(TrustedImmPtr(scratchBuffer-&gt;addressOfActiveLength()), scratch.gpr());
 8122         m_jit.storePtr(TrustedImmPtr(scratchSize), scratch.gpr());
 8123     }
 8124 
 8125     GPRFlushedCallResult result(this);
 8126 
 8127     callOperation(
 8128         operationNewArray, result.gpr(), m_jit.graph().registerStructure(globalObject-&gt;arrayStructureForIndexingTypeDuringAllocation(node-&gt;indexingType())),
 8129         static_cast&lt;void*&gt;(buffer), size_t(node-&gt;numChildren()));
 8130     m_jit.exceptionCheck();
 8131 
 8132     if (scratchSize) {
 8133         GPRTemporary scratch(this);
 8134 
 8135         m_jit.move(TrustedImmPtr(scratchBuffer-&gt;addressOfActiveLength()), scratch.gpr());
 8136         m_jit.storePtr(TrustedImmPtr(nullptr), scratch.gpr());
 8137     }
 8138 
 8139     cellResult(result.gpr(), node, UseChildrenCalledExplicitly);
 8140 }
 8141 
 8142 void SpeculativeJIT::compileNewArrayWithSpread(Node* node)
 8143 {
 8144     ASSERT(node-&gt;op() == NewArrayWithSpread);
 8145 
 8146 #if USE(JSVALUE64)
 8147     if (m_jit.graph().isWatchingHavingABadTimeWatchpoint(node)) {
 8148         GPRTemporary result(this);
 8149         GPRReg resultGPR = result.gpr();
 8150 
 8151         BitVector* bitVector = node-&gt;bitVector();
 8152         {
 8153             unsigned startLength = 0;
 8154             for (unsigned i = 0; i &lt; node-&gt;numChildren(); ++i) {
 8155                 if (!bitVector-&gt;get(i))
 8156                     ++startLength;
 8157             }
 8158 
 8159             GPRTemporary length(this);
 8160             GPRReg lengthGPR = length.gpr();
 8161             m_jit.move(TrustedImm32(startLength), lengthGPR);
 8162 
 8163             for (unsigned i = 0; i &lt; node-&gt;numChildren(); ++i) {
 8164                 if (bitVector-&gt;get(i)) {
 8165                     Edge use = m_jit.graph().varArgChild(node, i);
 8166                     SpeculateCellOperand fixedArray(this, use);
 8167                     GPRReg fixedArrayGPR = fixedArray.gpr();
 8168                     speculationCheck(Overflow, JSValueRegs(), nullptr, m_jit.branchAdd32(MacroAssembler::Overflow, MacroAssembler::Address(fixedArrayGPR, JSFixedArray::offsetOfSize()), lengthGPR));
 8169                 }
 8170             }
 8171 
 8172             speculationCheck(Overflow, JSValueRegs(), nullptr, m_jit.branch32(MacroAssembler::AboveOrEqual, lengthGPR, TrustedImm32(MIN_ARRAY_STORAGE_CONSTRUCTION_LENGTH)));
 8173 
 8174             // We can tell compileAllocateNewArrayWithSize() that it does not need to
 8175             // check for large arrays and use ArrayStorage structure because we already
 8176             // ensured above that the spread array length will definitely fit in a
 8177             // non-ArrayStorage shaped array.
 8178             bool shouldAllowForArrayStorageStructureForLargeArrays = false;
 8179             ASSERT(m_jit.graph().globalObjectFor(node-&gt;origin.semantic)-&gt;restParameterStructure()-&gt;indexingType() == ArrayWithContiguous || m_jit.graph().globalObjectFor(node-&gt;origin.semantic)-&gt;isHavingABadTime());
 8180             compileAllocateNewArrayWithSize(m_jit.graph().globalObjectFor(node-&gt;origin.semantic), resultGPR, lengthGPR, ArrayWithContiguous, shouldAllowForArrayStorageStructureForLargeArrays);
 8181         }
 8182 
 8183         GPRTemporary index(this);
 8184         GPRReg indexGPR = index.gpr();
 8185 
 8186         GPRTemporary storage(this);
 8187         GPRReg storageGPR = storage.gpr();
 8188 
 8189         m_jit.move(TrustedImm32(0), indexGPR);
 8190         m_jit.loadPtr(MacroAssembler::Address(resultGPR, JSObject::butterflyOffset()), storageGPR);
 8191 
 8192         for (unsigned i = 0; i &lt; node-&gt;numChildren(); ++i) {
 8193             Edge use = m_jit.graph().varArgChild(node, i);
 8194             if (bitVector-&gt;get(i)) {
 8195                 SpeculateCellOperand fixedArray(this, use);
 8196                 GPRReg fixedArrayGPR = fixedArray.gpr();
 8197 
 8198                 GPRTemporary fixedIndex(this);
 8199                 GPRReg fixedIndexGPR = fixedIndex.gpr();
 8200 
 8201                 GPRTemporary item(this);
 8202                 GPRReg itemGPR = item.gpr();
 8203 
 8204                 GPRTemporary fixedLength(this);
 8205                 GPRReg fixedLengthGPR = fixedLength.gpr();
 8206 
 8207                 m_jit.load32(MacroAssembler::Address(fixedArrayGPR, JSFixedArray::offsetOfSize()), fixedLengthGPR);
 8208                 m_jit.move(TrustedImm32(0), fixedIndexGPR);
 8209                 auto done = m_jit.branchPtr(MacroAssembler::AboveOrEqual, fixedIndexGPR, fixedLengthGPR);
 8210                 auto loopStart = m_jit.label();
 8211                 m_jit.load64(
 8212                     MacroAssembler::BaseIndex(fixedArrayGPR, fixedIndexGPR, MacroAssembler::TimesEight, JSFixedArray::offsetOfData()),
 8213                     itemGPR);
 8214 
 8215                 m_jit.store64(itemGPR, MacroAssembler::BaseIndex(storageGPR, indexGPR, MacroAssembler::TimesEight));
 8216                 m_jit.addPtr(TrustedImm32(1), fixedIndexGPR);
 8217                 m_jit.addPtr(TrustedImm32(1), indexGPR);
 8218                 m_jit.branchPtr(MacroAssembler::Below, fixedIndexGPR, fixedLengthGPR).linkTo(loopStart, &amp;m_jit);
 8219 
 8220                 done.link(&amp;m_jit);
 8221             } else {
 8222                 JSValueOperand item(this, use);
 8223                 GPRReg itemGPR = item.gpr();
 8224                 m_jit.store64(itemGPR, MacroAssembler::BaseIndex(storageGPR, indexGPR, MacroAssembler::TimesEight));
 8225                 m_jit.addPtr(TrustedImm32(1), indexGPR);
 8226             }
 8227         }
 8228 
 8229         cellResult(resultGPR, node);
 8230         return;
 8231     }
 8232 #endif // USE(JSVALUE64)
 8233 
 8234     ASSERT(node-&gt;numChildren());
 8235     size_t scratchSize = sizeof(EncodedJSValue) * node-&gt;numChildren();
<a name="98" id="anc98"></a><span class="line-modified"> 8236     ScratchBuffer* scratchBuffer = vm().scratchBufferForSize(scratchSize);</span>
 8237     EncodedJSValue* buffer = static_cast&lt;EncodedJSValue*&gt;(scratchBuffer-&gt;dataBuffer());
 8238 
 8239     BitVector* bitVector = node-&gt;bitVector();
 8240     for (unsigned i = 0; i &lt; node-&gt;numChildren(); ++i) {
 8241         Edge use = m_jit.graph().m_varArgChildren[node-&gt;firstChild() + i];
 8242         if (bitVector-&gt;get(i)) {
 8243             SpeculateCellOperand fixedArray(this, use);
 8244             GPRReg arrayGPR = fixedArray.gpr();
 8245 #if USE(JSVALUE64)
 8246             m_jit.store64(arrayGPR, &amp;buffer[i]);
 8247 #else
 8248             char* pointer = static_cast&lt;char*&gt;(static_cast&lt;void*&gt;(&amp;buffer[i]));
 8249             m_jit.store32(arrayGPR, pointer + PayloadOffset);
 8250             m_jit.store32(TrustedImm32(JSValue::CellTag), pointer + TagOffset);
 8251 #endif
 8252         } else {
 8253             JSValueOperand input(this, use);
 8254             JSValueRegs inputRegs = input.jsValueRegs();
 8255             m_jit.storeValue(inputRegs, &amp;buffer[i]);
 8256         }
 8257     }
 8258 
 8259     {
 8260         GPRTemporary scratch(this);
 8261         m_jit.move(TrustedImmPtr(scratchBuffer-&gt;addressOfActiveLength()), scratch.gpr());
 8262         m_jit.storePtr(TrustedImmPtr(scratchSize), MacroAssembler::Address(scratch.gpr()));
 8263     }
 8264 
 8265     flushRegisters();
 8266 
 8267     GPRFlushedCallResult result(this);
 8268     GPRReg resultGPR = result.gpr();
 8269 
 8270     callOperation(operationNewArrayWithSpreadSlow, resultGPR, buffer, node-&gt;numChildren());
 8271     m_jit.exceptionCheck();
 8272     {
 8273         GPRTemporary scratch(this);
 8274         m_jit.move(TrustedImmPtr(scratchBuffer-&gt;addressOfActiveLength()), scratch.gpr());
 8275         m_jit.storePtr(TrustedImmPtr(nullptr), MacroAssembler::Address(scratch.gpr()));
 8276     }
 8277 
 8278     cellResult(resultGPR, node);
 8279 }
 8280 
 8281 void SpeculativeJIT::compileGetRestLength(Node* node)
 8282 {
 8283     ASSERT(node-&gt;op() == GetRestLength);
 8284 
 8285     GPRTemporary result(this);
 8286     GPRReg resultGPR = result.gpr();
 8287 
 8288     emitGetLength(node-&gt;origin.semantic, resultGPR);
 8289     CCallHelpers::Jump hasNonZeroLength = m_jit.branch32(MacroAssembler::Above, resultGPR, Imm32(node-&gt;numberOfArgumentsToSkip()));
 8290     m_jit.move(TrustedImm32(0), resultGPR);
 8291     CCallHelpers::Jump done = m_jit.jump();
 8292     hasNonZeroLength.link(&amp;m_jit);
 8293     if (node-&gt;numberOfArgumentsToSkip())
 8294         m_jit.sub32(TrustedImm32(node-&gt;numberOfArgumentsToSkip()), resultGPR);
 8295     done.link(&amp;m_jit);
 8296     int32Result(resultGPR, node);
 8297 }
 8298 
 8299 void SpeculativeJIT::emitPopulateSliceIndex(Edge&amp; target, Optional&lt;GPRReg&gt; indexGPR, GPRReg lengthGPR, GPRReg resultGPR)
 8300 {
 8301     if (target-&gt;isInt32Constant()) {
 8302         int32_t value = target-&gt;asInt32();
 8303         if (value == 0) {
 8304             m_jit.move(TrustedImm32(0), resultGPR);
 8305             return;
 8306         }
 8307 
 8308         MacroAssembler::JumpList done;
 8309         if (value &gt; 0) {
 8310             m_jit.move(TrustedImm32(value), resultGPR);
 8311             done.append(m_jit.branch32(MacroAssembler::BelowOrEqual, resultGPR, lengthGPR));
 8312             m_jit.move(lengthGPR, resultGPR);
 8313         } else {
 8314             ASSERT(value != 0);
 8315             m_jit.move(lengthGPR, resultGPR);
 8316             done.append(m_jit.branchAdd32(MacroAssembler::PositiveOrZero, TrustedImm32(value), resultGPR));
 8317             m_jit.move(TrustedImm32(0), resultGPR);
 8318         }
 8319         done.link(&amp;m_jit);
 8320         return;
 8321     }
 8322 
 8323     Optional&lt;SpeculateInt32Operand&gt; index;
 8324     if (!indexGPR) {
 8325         index.emplace(this, target);
 8326         indexGPR = index-&gt;gpr();
 8327     }
 8328     MacroAssembler::JumpList done;
 8329 
 8330     auto isPositive = m_jit.branch32(MacroAssembler::GreaterThanOrEqual, indexGPR.value(), TrustedImm32(0));
 8331     m_jit.move(lengthGPR, resultGPR);
 8332     done.append(m_jit.branchAdd32(MacroAssembler::PositiveOrZero, indexGPR.value(), resultGPR));
 8333     m_jit.move(TrustedImm32(0), resultGPR);
 8334     done.append(m_jit.jump());
 8335 
 8336     isPositive.link(&amp;m_jit);
 8337     m_jit.move(indexGPR.value(), resultGPR);
 8338     done.append(m_jit.branch32(MacroAssembler::BelowOrEqual, resultGPR, lengthGPR));
 8339     m_jit.move(lengthGPR, resultGPR);
 8340 
 8341     done.link(&amp;m_jit);
 8342 }
 8343 
 8344 void SpeculativeJIT::compileArraySlice(Node* node)
 8345 {
 8346     ASSERT(node-&gt;op() == ArraySlice);
 8347 
 8348     JSGlobalObject* globalObject = m_jit.graph().globalObjectFor(node-&gt;origin.semantic);
 8349 
 8350     GPRTemporary temp(this);
 8351     StorageOperand storage(this, m_jit.graph().varArgChild(node, node-&gt;numChildren() - 1));
 8352     GPRTemporary result(this);
 8353 
 8354     GPRReg storageGPR = storage.gpr();
 8355     GPRReg resultGPR = result.gpr();
 8356     GPRReg tempGPR = temp.gpr();
 8357 
 8358     if (node-&gt;numChildren() == 2)
 8359         m_jit.load32(MacroAssembler::Address(storageGPR, Butterfly::offsetOfPublicLength()), tempGPR);
 8360     else {
 8361         ASSERT(node-&gt;numChildren() == 3 || node-&gt;numChildren() == 4);
 8362         GPRTemporary tempLength(this);
 8363         GPRReg lengthGPR = tempLength.gpr();
 8364         m_jit.load32(MacroAssembler::Address(storageGPR, Butterfly::offsetOfPublicLength()), lengthGPR);
 8365 
 8366         if (node-&gt;numChildren() == 4)
 8367             emitPopulateSliceIndex(m_jit.graph().varArgChild(node, 2), WTF::nullopt, lengthGPR, tempGPR);
 8368         else
 8369             m_jit.move(lengthGPR, tempGPR);
 8370 
 8371         if (m_jit.graph().varArgChild(node, 1)-&gt;isInt32Constant() &amp;&amp; m_jit.graph().varArgChild(node, 1)-&gt;asInt32() == 0) {
 8372             // Do nothing for array.slice(0, end) or array.slice(0) cases.
 8373             // `tempGPR` already points to the size of a newly created array.
 8374         } else {
 8375             GPRTemporary tempStartIndex(this);
 8376             GPRReg startGPR = tempStartIndex.gpr();
 8377             emitPopulateSliceIndex(m_jit.graph().varArgChild(node, 1), WTF::nullopt, lengthGPR, startGPR);
 8378 
 8379             auto tooBig = m_jit.branch32(MacroAssembler::Above, startGPR, tempGPR);
 8380             m_jit.sub32(startGPR, tempGPR); // the size of the array we&#39;ll make.
 8381             auto done = m_jit.jump();
 8382 
 8383             tooBig.link(&amp;m_jit);
 8384             m_jit.move(TrustedImm32(0), tempGPR);
 8385             done.link(&amp;m_jit);
 8386         }
 8387     }
 8388 
 8389     GPRTemporary temp3(this);
 8390     GPRReg tempValue = temp3.gpr();
 8391 
 8392     {
 8393         // We need to keep the source array alive at least until after we&#39;re done
 8394         // with anything that can GC (e.g. allocating the result array below).
 8395         SpeculateCellOperand cell(this, m_jit.graph().varArgChild(node, 0));
 8396 
 8397         m_jit.load8(MacroAssembler::Address(cell.gpr(), JSCell::indexingTypeAndMiscOffset()), tempValue);
 8398         // We can ignore the writability of the cell since we won&#39;t write to the source.
 8399         m_jit.and32(TrustedImm32(AllWritableArrayTypesAndHistory), tempValue);
 8400 
 8401         JSValueRegsTemporary emptyValue(this);
 8402         JSValueRegs emptyValueRegs = emptyValue.regs();
 8403 
 8404         GPRTemporary storage(this);
 8405         GPRReg storageResultGPR = storage.gpr();
 8406 
 8407         GPRReg sizeGPR = tempGPR;
 8408 
 8409         CCallHelpers::JumpList done;
 8410 
 8411         auto emitMoveEmptyValue = [&amp;] (JSValue v) {
 8412             m_jit.moveValue(v, emptyValueRegs);
 8413         };
 8414 
 8415         auto isContiguous = m_jit.branch32(MacroAssembler::Equal, tempValue, TrustedImm32(ArrayWithContiguous));
 8416         auto isInt32 = m_jit.branch32(MacroAssembler::Equal, tempValue, TrustedImm32(ArrayWithInt32));
 8417         // When we emit an ArraySlice, we dominate the use of the array by a CheckStructure
 8418         // to ensure the incoming array is one to be one of the original array structures
 8419         // with one of the following indexing shapes: Int32, Contiguous, Double. Therefore,
 8420         // we&#39;re a double array here.
 8421         m_jit.move(TrustedImmPtr(m_jit.graph().registerStructure(globalObject-&gt;arrayStructureForIndexingTypeDuringAllocation(ArrayWithDouble))), tempValue);
 8422         emitMoveEmptyValue(jsNaN());
 8423         done.append(m_jit.jump());
 8424 
 8425         isContiguous.link(&amp;m_jit);
 8426         m_jit.move(TrustedImmPtr(m_jit.graph().registerStructure(globalObject-&gt;arrayStructureForIndexingTypeDuringAllocation(ArrayWithContiguous))), tempValue);
 8427         emitMoveEmptyValue(JSValue());
 8428         done.append(m_jit.jump());
 8429 
 8430         isInt32.link(&amp;m_jit);
 8431         m_jit.move(TrustedImmPtr(m_jit.graph().registerStructure(globalObject-&gt;arrayStructureForIndexingTypeDuringAllocation(ArrayWithInt32))), tempValue);
 8432         emitMoveEmptyValue(JSValue());
 8433 
 8434         done.link(&amp;m_jit);
 8435 
 8436         MacroAssembler::JumpList slowCases;
 8437         m_jit.move(TrustedImmPtr(nullptr), storageResultGPR);
 8438         // Enable the fast case on 64-bit platforms, where a sufficient amount of GP registers should be available.
 8439         // Other platforms could support the same approach with custom code, but that is not currently worth the extra code maintenance.
 8440         if (is64Bit()) {
 8441             GPRTemporary scratch(this);
 8442             GPRTemporary scratch2(this);
 8443             GPRReg scratchGPR = scratch.gpr();
 8444             GPRReg scratch2GPR = scratch2.gpr();
 8445 
 8446             emitAllocateButterfly(storageResultGPR, sizeGPR, scratchGPR, scratch2GPR, resultGPR, slowCases);
 8447             emitInitializeButterfly(storageResultGPR, sizeGPR, emptyValueRegs, scratchGPR);
 8448             emitAllocateJSObject&lt;JSArray&gt;(resultGPR, tempValue, storageResultGPR, scratchGPR, scratch2GPR, slowCases);
<a name="99" id="anc99"></a><span class="line-modified"> 8449             m_jit.mutatorFence(vm());</span>
 8450         } else {
 8451             slowCases.append(m_jit.jump());
 8452         }
 8453 
<a name="100" id="anc100"></a><span class="line-modified"> 8454         addSlowPathGenerator(makeUnique&lt;CallArrayAllocatorWithVariableStructureVariableSizeSlowPathGenerator&gt;(</span>
 8455             slowCases, this, operationNewArrayWithSize, resultGPR, tempValue, sizeGPR, storageResultGPR));
 8456     }
 8457 
 8458     GPRTemporary temp4(this);
 8459     GPRReg loadIndex = temp4.gpr();
 8460 
 8461     if (node-&gt;numChildren() == 2) {
 8462         m_jit.load32(MacroAssembler::Address(storageGPR, Butterfly::offsetOfPublicLength()), tempGPR);
 8463         m_jit.move(TrustedImm32(0), loadIndex);
 8464     } else {
 8465         m_jit.load32(MacroAssembler::Address(storageGPR, Butterfly::offsetOfPublicLength()), tempValue);
 8466         if (node-&gt;numChildren() == 4)
 8467             emitPopulateSliceIndex(m_jit.graph().varArgChild(node, 2), WTF::nullopt, tempValue, tempGPR);
 8468         else
 8469             m_jit.move(tempValue, tempGPR);
 8470         emitPopulateSliceIndex(m_jit.graph().varArgChild(node, 1), WTF::nullopt, tempValue, loadIndex);
 8471     }
 8472 
 8473     GPRTemporary temp5(this);
 8474     GPRReg storeIndex = temp5.gpr();
 8475     m_jit.move(TrustedImmPtr(nullptr), storeIndex);
 8476 
 8477     GPRTemporary temp2(this);
 8478     GPRReg resultButterfly = temp2.gpr();
 8479 
 8480     m_jit.loadPtr(MacroAssembler::Address(resultGPR, JSObject::butterflyOffset()), resultButterfly);
 8481     m_jit.zeroExtend32ToPtr(tempGPR, tempGPR);
 8482     m_jit.zeroExtend32ToPtr(loadIndex, loadIndex);
 8483     auto done = m_jit.branchPtr(MacroAssembler::AboveOrEqual, loadIndex, tempGPR);
 8484 
 8485     auto loop = m_jit.label();
 8486 #if USE(JSVALUE64)
 8487     m_jit.load64(
 8488         MacroAssembler::BaseIndex(storageGPR, loadIndex, MacroAssembler::TimesEight), tempValue);
 8489     m_jit.store64(
 8490         tempValue, MacroAssembler::BaseIndex(resultButterfly, storeIndex, MacroAssembler::TimesEight));
 8491 #else
 8492     m_jit.load32(
 8493         MacroAssembler::BaseIndex(storageGPR, loadIndex, MacroAssembler::TimesEight, PayloadOffset), tempValue);
 8494     m_jit.store32(
 8495         tempValue, MacroAssembler::BaseIndex(resultButterfly, storeIndex, MacroAssembler::TimesEight, PayloadOffset));
 8496     m_jit.load32(
 8497         MacroAssembler::BaseIndex(storageGPR, loadIndex, MacroAssembler::TimesEight, TagOffset), tempValue);
 8498     m_jit.store32(
 8499         tempValue, MacroAssembler::BaseIndex(resultButterfly, storeIndex, MacroAssembler::TimesEight, TagOffset));
 8500 #endif // USE(JSVALUE64)
 8501     m_jit.addPtr(TrustedImm32(1), loadIndex);
 8502     m_jit.addPtr(TrustedImm32(1), storeIndex);
 8503     m_jit.branchPtr(MacroAssembler::Below, loadIndex, tempGPR).linkTo(loop, &amp;m_jit);
 8504 
 8505     done.link(&amp;m_jit);
 8506     cellResult(resultGPR, node);
 8507 }
 8508 
 8509 void SpeculativeJIT::compileArrayIndexOf(Node* node)
 8510 {
 8511     ASSERT(node-&gt;op() == ArrayIndexOf);
 8512 
 8513     StorageOperand storage(this, m_jit.graph().varArgChild(node, node-&gt;numChildren() == 3 ? 2 : 3));
 8514     GPRTemporary index(this);
 8515     GPRTemporary tempLength(this);
 8516 
 8517     GPRReg storageGPR = storage.gpr();
 8518     GPRReg indexGPR = index.gpr();
 8519     GPRReg lengthGPR = tempLength.gpr();
 8520 
 8521     m_jit.load32(MacroAssembler::Address(storageGPR, Butterfly::offsetOfPublicLength()), lengthGPR);
 8522 
 8523     if (node-&gt;numChildren() == 4)
 8524         emitPopulateSliceIndex(m_jit.graph().varArgChild(node, 2), WTF::nullopt, lengthGPR, indexGPR);
 8525     else
 8526         m_jit.move(TrustedImm32(0), indexGPR);
 8527 
 8528     Edge&amp; searchElementEdge = m_jit.graph().varArgChild(node, 1);
 8529     switch (searchElementEdge.useKind()) {
 8530     case Int32Use:
 8531     case ObjectUse:
 8532     case SymbolUse:
 8533     case OtherUse: {
 8534         auto emitLoop = [&amp;] (auto emitCompare) {
 8535 #if ENABLE(DFG_REGISTER_ALLOCATION_VALIDATION)
 8536             m_jit.clearRegisterAllocationOffsets();
 8537 #endif
 8538 
 8539             m_jit.zeroExtend32ToPtr(lengthGPR, lengthGPR);
 8540             m_jit.zeroExtend32ToPtr(indexGPR, indexGPR);
 8541 
 8542             auto loop = m_jit.label();
 8543             auto notFound = m_jit.branch32(CCallHelpers::Equal, indexGPR, lengthGPR);
 8544 
 8545             auto found = emitCompare();
 8546 
 8547             m_jit.add32(TrustedImm32(1), indexGPR);
 8548             m_jit.jump().linkTo(loop, &amp;m_jit);
 8549 
 8550             notFound.link(&amp;m_jit);
 8551             m_jit.move(TrustedImm32(-1), indexGPR);
 8552             found.link(&amp;m_jit);
 8553             int32Result(indexGPR, node);
 8554         };
 8555 
 8556         if (searchElementEdge.useKind() == Int32Use) {
 8557             ASSERT(node-&gt;arrayMode().type() == Array::Int32);
 8558 #if USE(JSVALUE64)
 8559             JSValueOperand searchElement(this, searchElementEdge, ManualOperandSpeculation);
 8560             JSValueRegs searchElementRegs = searchElement.jsValueRegs();
 8561             speculateInt32(searchElementEdge, searchElementRegs);
 8562             GPRReg searchElementGPR = searchElementRegs.payloadGPR();
 8563 #else
 8564             SpeculateInt32Operand searchElement(this, searchElementEdge);
 8565             GPRReg searchElementGPR = searchElement.gpr();
 8566 
 8567             GPRTemporary temp(this);
 8568             GPRReg tempGPR = temp.gpr();
 8569 #endif
 8570             emitLoop([&amp;] () {
 8571 #if USE(JSVALUE64)
 8572                 auto found = m_jit.branch64(CCallHelpers::Equal, MacroAssembler::BaseIndex(storageGPR, indexGPR, MacroAssembler::TimesEight), searchElementGPR);
 8573 #else
 8574                 auto skip = m_jit.branch32(CCallHelpers::NotEqual, MacroAssembler::BaseIndex(storageGPR, indexGPR, MacroAssembler::TimesEight, TagOffset), TrustedImm32(JSValue::Int32Tag));
 8575                 m_jit.load32(MacroAssembler::BaseIndex(storageGPR, indexGPR, MacroAssembler::TimesEight, PayloadOffset), tempGPR);
 8576                 auto found = m_jit.branch32(CCallHelpers::Equal, tempGPR, searchElementGPR);
 8577                 skip.link(&amp;m_jit);
 8578 #endif
 8579                 return found;
 8580             });
 8581             return;
 8582         }
 8583 
 8584         if (searchElementEdge.useKind() == OtherUse) {
 8585             ASSERT(node-&gt;arrayMode().type() == Array::Contiguous);
 8586             JSValueOperand searchElement(this, searchElementEdge, ManualOperandSpeculation);
 8587             GPRTemporary temp(this);
 8588 
 8589             JSValueRegs searchElementRegs = searchElement.jsValueRegs();
 8590             GPRReg tempGPR = temp.gpr();
 8591             speculateOther(searchElementEdge, searchElementRegs, tempGPR);
 8592 
 8593             emitLoop([&amp;] () {
 8594 #if USE(JSVALUE64)
 8595                 auto found = m_jit.branch64(CCallHelpers::Equal, MacroAssembler::BaseIndex(storageGPR, indexGPR, MacroAssembler::TimesEight), searchElementRegs.payloadGPR());
 8596 #else
 8597                 m_jit.load32(MacroAssembler::BaseIndex(storageGPR, indexGPR, MacroAssembler::TimesEight, TagOffset), tempGPR);
 8598                 auto found = m_jit.branch32(CCallHelpers::Equal, tempGPR, searchElementRegs.tagGPR());
 8599 #endif
 8600                 return found;
 8601             });
 8602             return;
 8603         }
 8604 
 8605         ASSERT(node-&gt;arrayMode().type() == Array::Contiguous);
 8606         SpeculateCellOperand searchElement(this, searchElementEdge);
 8607         GPRReg searchElementGPR = searchElement.gpr();
 8608 
 8609         if (searchElementEdge.useKind() == ObjectUse)
 8610             speculateObject(searchElementEdge, searchElementGPR);
 8611         else {
 8612             ASSERT(searchElementEdge.useKind() == SymbolUse);
 8613             speculateSymbol(searchElementEdge, searchElementGPR);
 8614         }
 8615 
 8616 #if USE(JSVALUE32_64)
 8617         GPRTemporary temp(this);
 8618         GPRReg tempGPR = temp.gpr();
 8619 #endif
 8620 
 8621         emitLoop([&amp;] () {
 8622 #if USE(JSVALUE64)
 8623             auto found = m_jit.branch64(CCallHelpers::Equal, MacroAssembler::BaseIndex(storageGPR, indexGPR, MacroAssembler::TimesEight), searchElementGPR);
 8624 #else
 8625             auto skip = m_jit.branch32(CCallHelpers::NotEqual, MacroAssembler::BaseIndex(storageGPR, indexGPR, MacroAssembler::TimesEight, TagOffset), TrustedImm32(JSValue::CellTag));
 8626             m_jit.load32(MacroAssembler::BaseIndex(storageGPR, indexGPR, MacroAssembler::TimesEight, PayloadOffset), tempGPR);
 8627             auto found = m_jit.branch32(CCallHelpers::Equal, tempGPR, searchElementGPR);
 8628             skip.link(&amp;m_jit);
 8629 #endif
 8630             return found;
 8631         });
 8632         return;
 8633     }
 8634 
 8635     case DoubleRepUse: {
 8636         ASSERT(node-&gt;arrayMode().type() == Array::Double);
 8637         SpeculateDoubleOperand searchElement(this, searchElementEdge);
 8638         FPRTemporary tempDouble(this);
 8639 
 8640         FPRReg searchElementFPR = searchElement.fpr();
 8641         FPRReg tempFPR = tempDouble.fpr();
 8642 
 8643 #if ENABLE(DFG_REGISTER_ALLOCATION_VALIDATION)
 8644         m_jit.clearRegisterAllocationOffsets();
 8645 #endif
 8646 
 8647         m_jit.zeroExtend32ToPtr(lengthGPR, lengthGPR);
 8648         m_jit.zeroExtend32ToPtr(indexGPR, indexGPR);
 8649 
 8650         auto loop = m_jit.label();
 8651         auto notFound = m_jit.branch32(CCallHelpers::Equal, indexGPR, lengthGPR);
 8652         m_jit.loadDouble(MacroAssembler::BaseIndex(storageGPR, indexGPR, MacroAssembler::TimesEight), tempFPR);
 8653         auto found = m_jit.branchDouble(CCallHelpers::DoubleEqual, tempFPR, searchElementFPR);
 8654         m_jit.add32(TrustedImm32(1), indexGPR);
 8655         m_jit.jump().linkTo(loop, &amp;m_jit);
 8656 
 8657         notFound.link(&amp;m_jit);
 8658         m_jit.move(TrustedImm32(-1), indexGPR);
 8659         found.link(&amp;m_jit);
 8660         int32Result(indexGPR, node);
 8661         return;
 8662     }
 8663 
 8664     case StringUse: {
 8665         ASSERT(node-&gt;arrayMode().type() == Array::Contiguous);
 8666         SpeculateCellOperand searchElement(this, searchElementEdge);
 8667 
 8668         GPRReg searchElementGPR = searchElement.gpr();
 8669 
 8670         speculateString(searchElementEdge, searchElementGPR);
 8671 
 8672         flushRegisters();
 8673 
 8674         callOperation(operationArrayIndexOfString, lengthGPR, storageGPR, searchElementGPR, indexGPR);
 8675         m_jit.exceptionCheck();
 8676 
 8677         int32Result(lengthGPR, node);
 8678         return;
 8679     }
 8680 
 8681     case UntypedUse: {
 8682         JSValueOperand searchElement(this, searchElementEdge);
 8683 
 8684         JSValueRegs searchElementRegs = searchElement.jsValueRegs();
 8685 
 8686         flushRegisters();
 8687         switch (node-&gt;arrayMode().type()) {
 8688         case Array::Double:
 8689             callOperation(operationArrayIndexOfValueDouble, lengthGPR, storageGPR, searchElementRegs, indexGPR);
 8690             break;
 8691         case Array::Int32:
 8692         case Array::Contiguous:
 8693             callOperation(operationArrayIndexOfValueInt32OrContiguous, lengthGPR, storageGPR, searchElementRegs, indexGPR);
 8694             break;
 8695         default:
 8696             RELEASE_ASSERT_NOT_REACHED();
 8697             break;
 8698         }
 8699         m_jit.exceptionCheck();
 8700 
 8701         int32Result(lengthGPR, node);
 8702         return;
 8703     }
 8704 
 8705     default:
 8706         RELEASE_ASSERT_NOT_REACHED();
 8707         return;
 8708     }
 8709 }
 8710 
 8711 void SpeculativeJIT::compileArrayPush(Node* node)
 8712 {
 8713     ASSERT(node-&gt;arrayMode().isJSArray());
 8714 
 8715     Edge&amp; storageEdge = m_jit.graph().varArgChild(node, 0);
 8716     Edge&amp; arrayEdge = m_jit.graph().varArgChild(node, 1);
 8717 
 8718     SpeculateCellOperand base(this, arrayEdge);
 8719     GPRTemporary storageLength(this);
 8720 
 8721     GPRReg baseGPR = base.gpr();
 8722     GPRReg storageLengthGPR = storageLength.gpr();
 8723 
 8724     StorageOperand storage(this, storageEdge);
 8725     GPRReg storageGPR = storage.gpr();
 8726     unsigned elementOffset = 2;
 8727     unsigned elementCount = node-&gt;numChildren() - elementOffset;
 8728 
 8729 #if USE(JSVALUE32_64)
 8730     GPRTemporary tag(this);
 8731     GPRReg tagGPR = tag.gpr();
 8732     JSValueRegs resultRegs { tagGPR, storageLengthGPR };
 8733 #else
 8734     JSValueRegs resultRegs { storageLengthGPR };
 8735 #endif
 8736 
 8737     auto getStorageBufferAddress = [&amp;] (GPRReg storageGPR, GPRReg indexGPR, int32_t offset, GPRReg bufferGPR) {
 8738         static_assert(sizeof(JSValue) == 8 &amp;&amp; 1 &lt;&lt; 3 == 8, &quot;This is strongly assumed in the code below.&quot;);
 8739         m_jit.getEffectiveAddress(MacroAssembler::BaseIndex(storageGPR, indexGPR, MacroAssembler::TimesEight, offset), bufferGPR);
 8740     };
 8741 
 8742     switch (node-&gt;arrayMode().type()) {
 8743     case Array::Int32:
 8744     case Array::Contiguous: {
 8745         if (elementCount == 1) {
 8746             Edge&amp; element = m_jit.graph().varArgChild(node, elementOffset);
<a name="101" id="anc101"></a><span class="line-added"> 8747             if (node-&gt;arrayMode().type() == Array::Int32) {</span>
<span class="line-added"> 8748                 ASSERT(element.useKind() == Int32Use);</span>
<span class="line-added"> 8749                 speculateInt32(element);</span>
<span class="line-added"> 8750             }</span>
 8751             JSValueOperand value(this, element, ManualOperandSpeculation);
 8752             JSValueRegs valueRegs = value.jsValueRegs();
 8753 
<a name="102" id="anc102"></a>


 8754             m_jit.load32(MacroAssembler::Address(storageGPR, Butterfly::offsetOfPublicLength()), storageLengthGPR);
 8755             MacroAssembler::Jump slowPath = m_jit.branch32(MacroAssembler::AboveOrEqual, storageLengthGPR, MacroAssembler::Address(storageGPR, Butterfly::offsetOfVectorLength()));
 8756             m_jit.storeValue(valueRegs, MacroAssembler::BaseIndex(storageGPR, storageLengthGPR, MacroAssembler::TimesEight));
 8757             m_jit.add32(TrustedImm32(1), storageLengthGPR);
 8758             m_jit.store32(storageLengthGPR, MacroAssembler::Address(storageGPR, Butterfly::offsetOfPublicLength()));
 8759             m_jit.boxInt32(storageLengthGPR, resultRegs);
 8760 
 8761             addSlowPathGenerator(
 8762                 slowPathCall(slowPath, this, operationArrayPush, resultRegs, valueRegs, baseGPR));
 8763 
 8764             jsValueResult(resultRegs, node);
 8765             return;
 8766         }
 8767 
<a name="103" id="anc103"></a><span class="line-added"> 8768         if (node-&gt;arrayMode().type() == Array::Int32) {</span>
<span class="line-added"> 8769             for (unsigned elementIndex = 0; elementIndex &lt; elementCount; ++elementIndex) {</span>
<span class="line-added"> 8770                 Edge element = m_jit.graph().varArgChild(node, elementIndex + elementOffset);</span>
<span class="line-added"> 8771                 ASSERT(element.useKind() == Int32Use);</span>
<span class="line-added"> 8772                 speculateInt32(element);</span>
<span class="line-added"> 8773             }</span>
<span class="line-added"> 8774         }</span>
<span class="line-added"> 8775 </span>
 8776         GPRTemporary buffer(this);
 8777         GPRReg bufferGPR = buffer.gpr();
 8778 
 8779         m_jit.load32(MacroAssembler::Address(storageGPR, Butterfly::offsetOfPublicLength()), storageLengthGPR);
 8780         m_jit.move(storageLengthGPR, bufferGPR);
 8781         m_jit.add32(TrustedImm32(elementCount), bufferGPR);
 8782         MacroAssembler::Jump slowPath = m_jit.branch32(MacroAssembler::Above, bufferGPR, MacroAssembler::Address(storageGPR, Butterfly::offsetOfVectorLength()));
 8783 
 8784         m_jit.store32(bufferGPR, MacroAssembler::Address(storageGPR, Butterfly::offsetOfPublicLength()));
 8785         getStorageBufferAddress(storageGPR, storageLengthGPR, 0, bufferGPR);
 8786         m_jit.add32(TrustedImm32(elementCount), storageLengthGPR);
 8787         m_jit.boxInt32(storageLengthGPR, resultRegs);
 8788         auto storageDone = m_jit.jump();
 8789 
 8790         slowPath.link(&amp;m_jit);
 8791 
 8792         size_t scratchSize = sizeof(EncodedJSValue) * elementCount;
<a name="104" id="anc104"></a><span class="line-modified"> 8793         ScratchBuffer* scratchBuffer = vm().scratchBufferForSize(scratchSize);</span>
 8794         m_jit.move(TrustedImmPtr(static_cast&lt;EncodedJSValue*&gt;(scratchBuffer-&gt;dataBuffer())), bufferGPR);
 8795         m_jit.move(TrustedImmPtr(scratchBuffer-&gt;addressOfActiveLength()), storageLengthGPR);
 8796         m_jit.storePtr(TrustedImmPtr(scratchSize), MacroAssembler::Address(storageLengthGPR));
 8797 
 8798         storageDone.link(&amp;m_jit);
 8799         for (unsigned elementIndex = 0; elementIndex &lt; elementCount; ++elementIndex) {
 8800             Edge&amp; element = m_jit.graph().varArgChild(node, elementIndex + elementOffset);
<a name="105" id="anc105"></a><span class="line-modified"> 8801             JSValueOperand value(this, element, ManualOperandSpeculation); // We did type checks above.</span>
 8802             JSValueRegs valueRegs = value.jsValueRegs();
 8803 
<a name="106" id="anc106"></a>


 8804             m_jit.storeValue(valueRegs, MacroAssembler::Address(bufferGPR, sizeof(EncodedJSValue) * elementIndex));
 8805             value.use();
 8806         }
 8807 
 8808         MacroAssembler::Jump fastPath = m_jit.branchPtr(MacroAssembler::NotEqual, bufferGPR, TrustedImmPtr(static_cast&lt;EncodedJSValue*&gt;(scratchBuffer-&gt;dataBuffer())));
 8809 
 8810         addSlowPathGenerator(slowPathCall(m_jit.jump(), this, operationArrayPushMultiple, resultRegs, baseGPR, bufferGPR, TrustedImm32(elementCount)));
 8811 
 8812         m_jit.move(TrustedImmPtr(scratchBuffer-&gt;addressOfActiveLength()), bufferGPR);
 8813         m_jit.storePtr(TrustedImmPtr(nullptr), MacroAssembler::Address(bufferGPR));
 8814 
 8815         base.use();
 8816         storage.use();
 8817 
 8818         fastPath.link(&amp;m_jit);
 8819         jsValueResult(resultRegs, node, DataFormatJS, UseChildrenCalledExplicitly);
 8820         return;
 8821     }
 8822 
 8823     case Array::Double: {
 8824         if (elementCount == 1) {
 8825             Edge&amp; element = m_jit.graph().varArgChild(node, elementOffset);
<a name="107" id="anc107"></a><span class="line-added"> 8826             speculate(node, element);</span>
 8827             SpeculateDoubleOperand value(this, element);
 8828             FPRReg valueFPR = value.fpr();
 8829 
<a name="108" id="anc108"></a>

 8830             m_jit.load32(MacroAssembler::Address(storageGPR, Butterfly::offsetOfPublicLength()), storageLengthGPR);
 8831             MacroAssembler::Jump slowPath = m_jit.branch32(MacroAssembler::AboveOrEqual, storageLengthGPR, MacroAssembler::Address(storageGPR, Butterfly::offsetOfVectorLength()));
 8832             m_jit.storeDouble(valueFPR, MacroAssembler::BaseIndex(storageGPR, storageLengthGPR, MacroAssembler::TimesEight));
 8833             m_jit.add32(TrustedImm32(1), storageLengthGPR);
 8834             m_jit.store32(storageLengthGPR, MacroAssembler::Address(storageGPR, Butterfly::offsetOfPublicLength()));
 8835             m_jit.boxInt32(storageLengthGPR, resultRegs);
 8836 
 8837             addSlowPathGenerator(
 8838                 slowPathCall(slowPath, this, operationArrayPushDouble, resultRegs, valueFPR, baseGPR));
 8839 
 8840             jsValueResult(resultRegs, node);
 8841             return;
 8842         }
 8843 
<a name="109" id="anc109"></a><span class="line-added"> 8844         for (unsigned elementIndex = 0; elementIndex &lt; elementCount; ++elementIndex) {</span>
<span class="line-added"> 8845             Edge element = m_jit.graph().varArgChild(node, elementIndex + elementOffset);</span>
<span class="line-added"> 8846             ASSERT(element.useKind() == DoubleRepRealUse);</span>
<span class="line-added"> 8847             speculate(node, element);</span>
<span class="line-added"> 8848         }</span>
<span class="line-added"> 8849 </span>
 8850         GPRTemporary buffer(this);
 8851         GPRReg bufferGPR = buffer.gpr();
 8852 
 8853         m_jit.load32(MacroAssembler::Address(storageGPR, Butterfly::offsetOfPublicLength()), storageLengthGPR);
 8854         m_jit.move(storageLengthGPR, bufferGPR);
 8855         m_jit.add32(TrustedImm32(elementCount), bufferGPR);
 8856         MacroAssembler::Jump slowPath = m_jit.branch32(MacroAssembler::Above, bufferGPR, MacroAssembler::Address(storageGPR, Butterfly::offsetOfVectorLength()));
 8857 
 8858         m_jit.store32(bufferGPR, MacroAssembler::Address(storageGPR, Butterfly::offsetOfPublicLength()));
 8859         getStorageBufferAddress(storageGPR, storageLengthGPR, 0, bufferGPR);
 8860         m_jit.add32(TrustedImm32(elementCount), storageLengthGPR);
 8861         m_jit.boxInt32(storageLengthGPR, resultRegs);
 8862         auto storageDone = m_jit.jump();
 8863 
 8864         slowPath.link(&amp;m_jit);
 8865 
 8866         size_t scratchSize = sizeof(double) * elementCount;
<a name="110" id="anc110"></a><span class="line-modified"> 8867         ScratchBuffer* scratchBuffer = vm().scratchBufferForSize(scratchSize);</span>
 8868         m_jit.move(TrustedImmPtr(static_cast&lt;EncodedJSValue*&gt;(scratchBuffer-&gt;dataBuffer())), bufferGPR);
 8869         m_jit.move(TrustedImmPtr(scratchBuffer-&gt;addressOfActiveLength()), storageLengthGPR);
 8870         m_jit.storePtr(TrustedImmPtr(scratchSize), MacroAssembler::Address(storageLengthGPR));
 8871 
 8872         storageDone.link(&amp;m_jit);
 8873         for (unsigned elementIndex = 0; elementIndex &lt; elementCount; ++elementIndex) {
 8874             Edge&amp; element = m_jit.graph().varArgChild(node, elementIndex + elementOffset);
 8875             SpeculateDoubleOperand value(this, element);
 8876             FPRReg valueFPR = value.fpr();
 8877 
<a name="111" id="anc111"></a>

 8878             m_jit.storeDouble(valueFPR, MacroAssembler::Address(bufferGPR, sizeof(double) * elementIndex));
 8879             value.use();
 8880         }
 8881 
 8882         MacroAssembler::Jump fastPath = m_jit.branchPtr(MacroAssembler::NotEqual, bufferGPR, TrustedImmPtr(static_cast&lt;EncodedJSValue*&gt;(scratchBuffer-&gt;dataBuffer())));
 8883 
 8884         addSlowPathGenerator(slowPathCall(m_jit.jump(), this, operationArrayPushDoubleMultiple, resultRegs, baseGPR, bufferGPR, TrustedImm32(elementCount)));
 8885 
 8886         m_jit.move(TrustedImmPtr(scratchBuffer-&gt;addressOfActiveLength()), bufferGPR);
 8887         m_jit.storePtr(TrustedImmPtr(nullptr), MacroAssembler::Address(bufferGPR));
 8888 
 8889         base.use();
 8890         storage.use();
 8891 
 8892         fastPath.link(&amp;m_jit);
 8893         jsValueResult(resultRegs, node, DataFormatJS, UseChildrenCalledExplicitly);
 8894         return;
 8895     }
 8896 
 8897     case Array::ArrayStorage: {
 8898         // This ensures that the result of ArrayPush is Int32 in AI.
 8899         int32_t largestPositiveInt32Length = 0x7fffffff - elementCount;
 8900         if (elementCount == 1) {
 8901             Edge&amp; element = m_jit.graph().varArgChild(node, elementOffset);
 8902             JSValueOperand value(this, element);
 8903             JSValueRegs valueRegs = value.jsValueRegs();
 8904 
 8905             m_jit.load32(MacroAssembler::Address(storageGPR, ArrayStorage::lengthOffset()), storageLengthGPR);
 8906 
 8907             // Refuse to handle bizarre lengths.
 8908             speculationCheck(Uncountable, JSValueRegs(), 0, m_jit.branch32(MacroAssembler::Above, storageLengthGPR, TrustedImm32(largestPositiveInt32Length)));
 8909 
 8910             MacroAssembler::Jump slowPath = m_jit.branch32(MacroAssembler::AboveOrEqual, storageLengthGPR, MacroAssembler::Address(storageGPR, ArrayStorage::vectorLengthOffset()));
 8911 
 8912             m_jit.storeValue(valueRegs, MacroAssembler::BaseIndex(storageGPR, storageLengthGPR, MacroAssembler::TimesEight, ArrayStorage::vectorOffset()));
 8913 
 8914             m_jit.add32(TrustedImm32(1), storageLengthGPR);
 8915             m_jit.store32(storageLengthGPR, MacroAssembler::Address(storageGPR, ArrayStorage::lengthOffset()));
 8916             m_jit.add32(TrustedImm32(1), MacroAssembler::Address(storageGPR, OBJECT_OFFSETOF(ArrayStorage, m_numValuesInVector)));
 8917             m_jit.boxInt32(storageLengthGPR, resultRegs);
 8918 
 8919             addSlowPathGenerator(
 8920                 slowPathCall(slowPath, this, operationArrayPush, resultRegs, valueRegs, baseGPR));
 8921 
 8922             jsValueResult(resultRegs, node);
 8923             return;
 8924         }
 8925 
 8926         GPRTemporary buffer(this);
 8927         GPRReg bufferGPR = buffer.gpr();
 8928 
 8929         m_jit.load32(MacroAssembler::Address(storageGPR, ArrayStorage::lengthOffset()), storageLengthGPR);
 8930 
 8931         // Refuse to handle bizarre lengths.
 8932         speculationCheck(Uncountable, JSValueRegs(), 0, m_jit.branch32(MacroAssembler::Above, storageLengthGPR, TrustedImm32(largestPositiveInt32Length)));
 8933 
 8934         m_jit.move(storageLengthGPR, bufferGPR);
 8935         m_jit.add32(TrustedImm32(elementCount), bufferGPR);
 8936         MacroAssembler::Jump slowPath = m_jit.branch32(MacroAssembler::Above, bufferGPR, MacroAssembler::Address(storageGPR, ArrayStorage::vectorLengthOffset()));
 8937 
 8938         m_jit.store32(bufferGPR, MacroAssembler::Address(storageGPR, ArrayStorage::lengthOffset()));
 8939         getStorageBufferAddress(storageGPR, storageLengthGPR, ArrayStorage::vectorOffset(), bufferGPR);
 8940         m_jit.add32(TrustedImm32(elementCount), MacroAssembler::Address(storageGPR, OBJECT_OFFSETOF(ArrayStorage, m_numValuesInVector)));
 8941         m_jit.add32(TrustedImm32(elementCount), storageLengthGPR);
 8942         m_jit.boxInt32(storageLengthGPR, resultRegs);
 8943         auto storageDone = m_jit.jump();
 8944 
 8945         slowPath.link(&amp;m_jit);
 8946 
 8947         size_t scratchSize = sizeof(EncodedJSValue) * elementCount;
<a name="112" id="anc112"></a><span class="line-modified"> 8948         ScratchBuffer* scratchBuffer = vm().scratchBufferForSize(scratchSize);</span>
 8949         m_jit.move(TrustedImmPtr(static_cast&lt;EncodedJSValue*&gt;(scratchBuffer-&gt;dataBuffer())), bufferGPR);
 8950         m_jit.move(TrustedImmPtr(scratchBuffer-&gt;addressOfActiveLength()), storageLengthGPR);
 8951         m_jit.storePtr(TrustedImmPtr(scratchSize), MacroAssembler::Address(storageLengthGPR));
 8952 
 8953         storageDone.link(&amp;m_jit);
 8954         for (unsigned elementIndex = 0; elementIndex &lt; elementCount; ++elementIndex) {
 8955             Edge&amp; element = m_jit.graph().varArgChild(node, elementIndex + elementOffset);
 8956             JSValueOperand value(this, element);
 8957             JSValueRegs valueRegs = value.jsValueRegs();
 8958 
 8959             m_jit.storeValue(valueRegs, MacroAssembler::Address(bufferGPR, sizeof(EncodedJSValue) * elementIndex));
 8960             value.use();
 8961         }
 8962 
 8963         MacroAssembler::Jump fastPath = m_jit.branchPtr(MacroAssembler::NotEqual, bufferGPR, TrustedImmPtr(static_cast&lt;EncodedJSValue*&gt;(scratchBuffer-&gt;dataBuffer())));
 8964 
 8965         addSlowPathGenerator(
 8966             slowPathCall(m_jit.jump(), this, operationArrayPushMultiple, resultRegs, baseGPR, bufferGPR, TrustedImm32(elementCount)));
 8967 
 8968         m_jit.move(TrustedImmPtr(scratchBuffer-&gt;addressOfActiveLength()), bufferGPR);
 8969         m_jit.storePtr(TrustedImmPtr(nullptr), MacroAssembler::Address(bufferGPR));
 8970 
 8971         base.use();
 8972         storage.use();
 8973 
 8974         fastPath.link(&amp;m_jit);
 8975         jsValueResult(resultRegs, node, DataFormatJS, UseChildrenCalledExplicitly);
 8976         return;
 8977     }
 8978 
 8979     default:
 8980         RELEASE_ASSERT_NOT_REACHED();
 8981     }
 8982 }
 8983 
 8984 void SpeculativeJIT::compileNotifyWrite(Node* node)
 8985 {
 8986     WatchpointSet* set = node-&gt;watchpointSet();
 8987 
 8988     JITCompiler::Jump slowCase = m_jit.branch8(
 8989         JITCompiler::NotEqual,
 8990         JITCompiler::AbsoluteAddress(set-&gt;addressOfState()),
 8991         TrustedImm32(IsInvalidated));
 8992 
 8993     addSlowPathGenerator(
 8994         slowPathCall(slowCase, this, operationNotifyWrite, NeedToSpill, ExceptionCheckRequirement::CheckNotNeeded, NoResult, set));
 8995 
 8996     noResult(node);
 8997 }
 8998 
 8999 void SpeculativeJIT::compileIsObject(Node* node)
 9000 {
 9001     JSValueOperand value(this, node-&gt;child1());
 9002     GPRTemporary result(this, Reuse, value, TagWord);
 9003 
 9004     JSValueRegs valueRegs = value.jsValueRegs();
 9005     GPRReg resultGPR = result.gpr();
 9006 
 9007     JITCompiler::Jump isNotCell = m_jit.branchIfNotCell(valueRegs);
 9008 
 9009     m_jit.compare8(JITCompiler::AboveOrEqual,
 9010         JITCompiler::Address(valueRegs.payloadGPR(), JSCell::typeInfoTypeOffset()),
 9011         TrustedImm32(ObjectType),
 9012         resultGPR);
 9013     JITCompiler::Jump done = m_jit.jump();
 9014 
 9015     isNotCell.link(&amp;m_jit);
 9016     m_jit.move(TrustedImm32(0), resultGPR);
 9017 
 9018     done.link(&amp;m_jit);
 9019     unblessedBooleanResult(resultGPR, node);
 9020 }
 9021 
 9022 void SpeculativeJIT::compileIsObjectOrNull(Node* node)
 9023 {
 9024     JSGlobalObject* globalObject = m_jit.graph().globalObjectFor(node-&gt;origin.semantic);
 9025 
 9026     JSValueOperand value(this, node-&gt;child1());
 9027     JSValueRegs valueRegs = value.jsValueRegs();
 9028 
 9029     GPRTemporary result(this);
 9030     GPRReg resultGPR = result.gpr();
 9031 
 9032     JITCompiler::Jump isCell = m_jit.branchIfCell(valueRegs);
 9033 
 9034     JITCompiler::Jump isNull = m_jit.branchIfEqual(valueRegs, jsNull());
 9035     JITCompiler::Jump isNonNullNonCell = m_jit.jump();
 9036 
 9037     isCell.link(&amp;m_jit);
 9038     JITCompiler::Jump isFunction = m_jit.branchIfFunction(valueRegs.payloadGPR());
 9039     JITCompiler::Jump notObject = m_jit.branchIfNotObject(valueRegs.payloadGPR());
 9040 
 9041     JITCompiler::Jump slowPath = m_jit.branchTest8(
 9042         JITCompiler::NonZero,
 9043         JITCompiler::Address(valueRegs.payloadGPR(), JSCell::typeInfoFlagsOffset()),
 9044         TrustedImm32(MasqueradesAsUndefined | OverridesGetCallData));
 9045 
 9046     isNull.link(&amp;m_jit);
 9047     m_jit.move(TrustedImm32(1), resultGPR);
 9048     JITCompiler::Jump done = m_jit.jump();
 9049 
 9050     isNonNullNonCell.link(&amp;m_jit);
 9051     isFunction.link(&amp;m_jit);
 9052     notObject.link(&amp;m_jit);
 9053     m_jit.move(TrustedImm32(0), resultGPR);
 9054 
 9055     addSlowPathGenerator(
 9056         slowPathCall(
 9057             slowPath, this, operationObjectIsObject, resultGPR, globalObject,
 9058             valueRegs.payloadGPR()));
 9059 
 9060     done.link(&amp;m_jit);
 9061 
 9062     unblessedBooleanResult(resultGPR, node);
 9063 }
 9064 
 9065 void SpeculativeJIT::compileIsFunction(Node* node)
 9066 {
 9067     JSGlobalObject* globalObject = m_jit.graph().globalObjectFor(node-&gt;origin.semantic);
 9068 
 9069     JSValueOperand value(this, node-&gt;child1());
 9070     JSValueRegs valueRegs = value.jsValueRegs();
 9071 
 9072     GPRTemporary result(this);
 9073     GPRReg resultGPR = result.gpr();
 9074 
 9075     JITCompiler::Jump notCell = m_jit.branchIfNotCell(valueRegs);
 9076     JITCompiler::Jump isFunction = m_jit.branchIfFunction(valueRegs.payloadGPR());
 9077     JITCompiler::Jump notObject = m_jit.branchIfNotObject(valueRegs.payloadGPR());
 9078 
 9079     JITCompiler::Jump slowPath = m_jit.branchTest8(
 9080         JITCompiler::NonZero,
 9081         JITCompiler::Address(valueRegs.payloadGPR(), JSCell::typeInfoFlagsOffset()),
 9082         TrustedImm32(MasqueradesAsUndefined | OverridesGetCallData));
 9083 
 9084     notCell.link(&amp;m_jit);
 9085     notObject.link(&amp;m_jit);
 9086     m_jit.move(TrustedImm32(0), resultGPR);
 9087     JITCompiler::Jump done = m_jit.jump();
 9088 
 9089     isFunction.link(&amp;m_jit);
 9090     m_jit.move(TrustedImm32(1), resultGPR);
 9091 
 9092     addSlowPathGenerator(
 9093         slowPathCall(
 9094             slowPath, this, operationObjectIsFunction, resultGPR, globalObject,
 9095             valueRegs.payloadGPR()));
 9096 
 9097     done.link(&amp;m_jit);
 9098 
 9099     unblessedBooleanResult(resultGPR, node);
 9100 }
 9101 
 9102 void SpeculativeJIT::compileTypeOf(Node* node)
 9103 {
 9104     JSGlobalObject* globalObject = m_jit.graph().globalObjectFor(node-&gt;origin.semantic);
 9105 
 9106     JSValueOperand value(this, node-&gt;child1());
 9107     JSValueRegs valueRegs = value.jsValueRegs();
 9108 
 9109     GPRTemporary result(this);
 9110     GPRReg resultGPR = result.gpr();
 9111 
 9112     JITCompiler::JumpList done;
 9113     JITCompiler::Jump slowPath;
 9114     m_jit.emitTypeOf(
 9115         valueRegs, resultGPR,
 9116         [&amp;] (TypeofType type, bool fallsThrough) {
<a name="113" id="anc113"></a><span class="line-modified"> 9117             m_jit.move(TrustedImmPtr::weakPointer(m_jit.graph(), vm().smallStrings.typeString(type)), resultGPR);</span>
 9118             if (!fallsThrough)
 9119                 done.append(m_jit.jump());
 9120         },
 9121         [&amp;] (JITCompiler::Jump theSlowPath) {
 9122             slowPath = theSlowPath;
 9123         });
 9124     done.link(&amp;m_jit);
 9125 
 9126     addSlowPathGenerator(
 9127         slowPathCall(
 9128             slowPath, this, operationTypeOfObject, resultGPR, globalObject,
 9129             valueRegs.payloadGPR()));
 9130 
 9131     cellResult(resultGPR, node);
 9132 }
 9133 
 9134 void SpeculativeJIT::emitStructureCheck(Node* node, GPRReg cellGPR, GPRReg tempGPR)
 9135 {
 9136     ASSERT(node-&gt;structureSet().size());
 9137 
 9138     if (node-&gt;structureSet().size() == 1) {
 9139         speculationCheck(
 9140             BadCache, JSValueSource::unboxedCell(cellGPR), 0,
 9141             m_jit.branchWeakStructure(
 9142                 JITCompiler::NotEqual,
 9143                 JITCompiler::Address(cellGPR, JSCell::structureIDOffset()),
 9144                 node-&gt;structureSet()[0]));
 9145     } else {
 9146         std::unique_ptr&lt;GPRTemporary&gt; structure;
 9147         GPRReg structureGPR;
 9148 
 9149         if (tempGPR == InvalidGPRReg) {
<a name="114" id="anc114"></a><span class="line-modified"> 9150             structure = makeUnique&lt;GPRTemporary&gt;(this);</span>
 9151             structureGPR = structure-&gt;gpr();
 9152         } else
 9153             structureGPR = tempGPR;
 9154 
 9155         m_jit.load32(JITCompiler::Address(cellGPR, JSCell::structureIDOffset()), structureGPR);
 9156 
 9157         JITCompiler::JumpList done;
 9158 
 9159         for (size_t i = 0; i &lt; node-&gt;structureSet().size() - 1; ++i) {
 9160             done.append(
 9161                 m_jit.branchWeakStructure(JITCompiler::Equal, structureGPR, node-&gt;structureSet()[i]));
 9162         }
 9163 
 9164         speculationCheck(
 9165             BadCache, JSValueSource::unboxedCell(cellGPR), 0,
 9166             m_jit.branchWeakStructure(
 9167                 JITCompiler::NotEqual, structureGPR, node-&gt;structureSet().last()));
 9168 
 9169         done.link(&amp;m_jit);
 9170     }
 9171 }
 9172 
 9173 void SpeculativeJIT::compileCheckCell(Node* node)
 9174 {
 9175     SpeculateCellOperand cell(this, node-&gt;child1());
 9176     speculationCheck(BadCell, JSValueSource::unboxedCell(cell.gpr()), node-&gt;child1(), m_jit.branchWeakPtr(JITCompiler::NotEqual, cell.gpr(), node-&gt;cellOperand()-&gt;cell()));
 9177     noResult(node);
 9178 }
 9179 
 9180 void SpeculativeJIT::compileCheckNotEmpty(Node* node)
 9181 {
 9182     JSValueOperand operand(this, node-&gt;child1());
 9183     JSValueRegs regs = operand.jsValueRegs();
 9184     speculationCheck(TDZFailure, JSValueSource(), nullptr, m_jit.branchIfEmpty(regs));
 9185     noResult(node);
 9186 }
 9187 
 9188 void SpeculativeJIT::compileCheckStructure(Node* node)
 9189 {
 9190     switch (node-&gt;child1().useKind()) {
 9191     case CellUse:
 9192     case KnownCellUse: {
 9193         SpeculateCellOperand cell(this, node-&gt;child1());
 9194         emitStructureCheck(node, cell.gpr(), InvalidGPRReg);
 9195         noResult(node);
 9196         return;
 9197     }
 9198 
 9199     case CellOrOtherUse: {
 9200         JSValueOperand value(this, node-&gt;child1(), ManualOperandSpeculation);
 9201         GPRTemporary temp(this);
 9202 
 9203         JSValueRegs valueRegs = value.jsValueRegs();
 9204         GPRReg tempGPR = temp.gpr();
 9205 
 9206         JITCompiler::Jump cell = m_jit.branchIfCell(valueRegs);
 9207         DFG_TYPE_CHECK(
 9208             valueRegs, node-&gt;child1(), SpecCell | SpecOther,
 9209             m_jit.branchIfNotOther(valueRegs, tempGPR));
 9210         JITCompiler::Jump done = m_jit.jump();
 9211         cell.link(&amp;m_jit);
 9212         emitStructureCheck(node, valueRegs.payloadGPR(), tempGPR);
 9213         done.link(&amp;m_jit);
 9214         noResult(node);
 9215         return;
 9216     }
 9217 
 9218     default:
 9219         DFG_CRASH(m_jit.graph(), node, &quot;Bad use kind&quot;);
 9220         return;
 9221     }
 9222 }
 9223 
 9224 void SpeculativeJIT::compileAllocatePropertyStorage(Node* node)
 9225 {
 9226     ASSERT(!node-&gt;transition()-&gt;previous-&gt;outOfLineCapacity());
 9227     ASSERT(initialOutOfLineCapacity == node-&gt;transition()-&gt;next-&gt;outOfLineCapacity());
 9228 
 9229     size_t size = initialOutOfLineCapacity * sizeof(JSValue);
 9230 
<a name="115" id="anc115"></a><span class="line-modified"> 9231     Allocator allocator = vm().jsValueGigacageAuxiliarySpace.allocatorForNonVirtual(size, AllocatorForMode::AllocatorIfExists);</span>
 9232 
 9233     if (!allocator || node-&gt;transition()-&gt;previous-&gt;couldHaveIndexingHeader()) {
 9234         SpeculateCellOperand base(this, node-&gt;child1());
 9235 
 9236         GPRReg baseGPR = base.gpr();
 9237 
 9238         flushRegisters();
 9239 
 9240         GPRFlushedCallResult result(this);
 9241         callOperation(operationAllocateComplexPropertyStorageWithInitialCapacity, result.gpr(), baseGPR);
 9242         m_jit.exceptionCheck();
 9243 
 9244         storageResult(result.gpr(), node);
 9245         return;
 9246     }
 9247 
 9248     GPRTemporary scratch1(this);
 9249     GPRTemporary scratch2(this);
 9250     GPRTemporary scratch3(this);
 9251 
 9252     GPRReg scratchGPR1 = scratch1.gpr();
 9253     GPRReg scratchGPR2 = scratch2.gpr();
 9254     GPRReg scratchGPR3 = scratch3.gpr();
 9255 
 9256     JITCompiler::JumpList slowPath;
 9257     m_jit.emitAllocate(scratchGPR1, JITAllocator::constant(allocator), scratchGPR2, scratchGPR3, slowPath);
 9258     m_jit.addPtr(JITCompiler::TrustedImm32(size + sizeof(IndexingHeader)), scratchGPR1);
 9259 
 9260     addSlowPathGenerator(
 9261         slowPathCall(slowPath, this, operationAllocateSimplePropertyStorageWithInitialCapacity, scratchGPR1));
 9262 
 9263     for (ptrdiff_t offset = 0; offset &lt; static_cast&lt;ptrdiff_t&gt;(size); offset += sizeof(void*))
 9264         m_jit.storePtr(TrustedImmPtr(nullptr), JITCompiler::Address(scratchGPR1, -(offset + sizeof(JSValue) + sizeof(void*))));
 9265 
 9266     storageResult(scratchGPR1, node);
 9267 }
 9268 
 9269 void SpeculativeJIT::compileReallocatePropertyStorage(Node* node)
 9270 {
 9271     size_t oldSize = node-&gt;transition()-&gt;previous-&gt;outOfLineCapacity() * sizeof(JSValue);
 9272     size_t newSize = oldSize * outOfLineGrowthFactor;
 9273     ASSERT(newSize == node-&gt;transition()-&gt;next-&gt;outOfLineCapacity() * sizeof(JSValue));
 9274 
<a name="116" id="anc116"></a><span class="line-modified"> 9275     Allocator allocator = vm().jsValueGigacageAuxiliarySpace.allocatorForNonVirtual(newSize, AllocatorForMode::AllocatorIfExists);</span>
 9276 
 9277     if (!allocator || node-&gt;transition()-&gt;previous-&gt;couldHaveIndexingHeader()) {
 9278         SpeculateCellOperand base(this, node-&gt;child1());
 9279 
 9280         GPRReg baseGPR = base.gpr();
 9281 
 9282         flushRegisters();
 9283 
 9284         GPRFlushedCallResult result(this);
 9285         callOperation(operationAllocateComplexPropertyStorage, result.gpr(), baseGPR, newSize / sizeof(JSValue));
 9286         m_jit.exceptionCheck();
 9287 
 9288         storageResult(result.gpr(), node);
 9289         return;
 9290     }
 9291 
 9292     StorageOperand oldStorage(this, node-&gt;child2());
 9293     GPRTemporary scratch1(this);
 9294     GPRTemporary scratch2(this);
 9295     GPRTemporary scratch3(this);
 9296 
 9297     GPRReg oldStorageGPR = oldStorage.gpr();
 9298     GPRReg scratchGPR1 = scratch1.gpr();
 9299     GPRReg scratchGPR2 = scratch2.gpr();
 9300     GPRReg scratchGPR3 = scratch3.gpr();
 9301 
 9302     JITCompiler::JumpList slowPath;
 9303     m_jit.emitAllocate(scratchGPR1, JITAllocator::constant(allocator), scratchGPR2, scratchGPR3, slowPath);
 9304 
 9305     m_jit.addPtr(JITCompiler::TrustedImm32(newSize + sizeof(IndexingHeader)), scratchGPR1);
 9306 
 9307     addSlowPathGenerator(
 9308         slowPathCall(slowPath, this, operationAllocateSimplePropertyStorage, scratchGPR1, newSize / sizeof(JSValue)));
 9309 
 9310     for (ptrdiff_t offset = oldSize; offset &lt; static_cast&lt;ptrdiff_t&gt;(newSize); offset += sizeof(void*))
 9311         m_jit.storePtr(TrustedImmPtr(nullptr), JITCompiler::Address(scratchGPR1, -(offset + sizeof(JSValue) + sizeof(void*))));
 9312 
 9313     // We have scratchGPR1 = new storage, scratchGPR2 = scratch
 9314     for (ptrdiff_t offset = 0; offset &lt; static_cast&lt;ptrdiff_t&gt;(oldSize); offset += sizeof(void*)) {
 9315         m_jit.loadPtr(JITCompiler::Address(oldStorageGPR, -(offset + sizeof(JSValue) + sizeof(void*))), scratchGPR2);
 9316         m_jit.storePtr(scratchGPR2, JITCompiler::Address(scratchGPR1, -(offset + sizeof(JSValue) + sizeof(void*))));
 9317     }
 9318 
 9319     storageResult(scratchGPR1, node);
 9320 }
 9321 
 9322 void SpeculativeJIT::compileNukeStructureAndSetButterfly(Node* node)
 9323 {
 9324     SpeculateCellOperand base(this, node-&gt;child1());
 9325     StorageOperand storage(this, node-&gt;child2());
 9326 
 9327     GPRReg baseGPR = base.gpr();
 9328     GPRReg storageGPR = storage.gpr();
 9329 
<a name="117" id="anc117"></a><span class="line-modified"> 9330     m_jit.nukeStructureAndStoreButterfly(vm(), storageGPR, baseGPR);</span>
 9331 
 9332     noResult(node);
 9333 }
 9334 
 9335 void SpeculativeJIT::compileGetButterfly(Node* node)
 9336 {
 9337     SpeculateCellOperand base(this, node-&gt;child1());
 9338     GPRTemporary result(this, Reuse, base);
 9339 
 9340     GPRReg baseGPR = base.gpr();
 9341     GPRReg resultGPR = result.gpr();
 9342 
 9343     m_jit.loadPtr(JITCompiler::Address(baseGPR, JSObject::butterflyOffset()), resultGPR);
 9344 
 9345     storageResult(resultGPR, node);
 9346 }
 9347 
 9348 static void allocateTemporaryRegistersForSnippet(SpeculativeJIT* jit, Vector&lt;GPRTemporary&gt;&amp; gpHolders, Vector&lt;FPRTemporary&gt;&amp; fpHolders, Vector&lt;GPRReg&gt;&amp; gpScratch, Vector&lt;FPRReg&gt;&amp; fpScratch, Snippet&amp; snippet)
 9349 {
 9350     for (unsigned i = 0; i &lt; snippet.numGPScratchRegisters; ++i) {
 9351         GPRTemporary temporary(jit);
 9352         gpScratch.append(temporary.gpr());
 9353         gpHolders.append(WTFMove(temporary));
 9354     }
 9355 
 9356     for (unsigned i = 0; i &lt; snippet.numFPScratchRegisters; ++i) {
 9357         FPRTemporary temporary(jit);
 9358         fpScratch.append(temporary.fpr());
 9359         fpHolders.append(WTFMove(temporary));
 9360     }
 9361 }
 9362 
 9363 void SpeculativeJIT::compileCallDOM(Node* node)
 9364 {
 9365     const DOMJIT::Signature* signature = node-&gt;signature();
 9366 
 9367     // FIXME: We should have a way to call functions with the vector of registers.
 9368     // https://bugs.webkit.org/show_bug.cgi?id=163099
 9369     Vector&lt;Variant&lt;SpeculateCellOperand, SpeculateInt32Operand, SpeculateBooleanOperand&gt;, JSC_DOMJIT_SIGNATURE_MAX_ARGUMENTS_INCLUDING_THIS&gt; operands;
 9370     Vector&lt;GPRReg, JSC_DOMJIT_SIGNATURE_MAX_ARGUMENTS_INCLUDING_THIS&gt; regs;
 9371 
 9372     auto appendCell = [&amp;](Edge&amp; edge) {
 9373         SpeculateCellOperand operand(this, edge);
 9374         regs.append(operand.gpr());
 9375         operands.append(WTFMove(operand));
 9376     };
 9377 
 9378     auto appendString = [&amp;](Edge&amp; edge) {
 9379         SpeculateCellOperand operand(this, edge);
 9380         GPRReg gpr = operand.gpr();
 9381         regs.append(gpr);
 9382         speculateString(edge, gpr);
 9383         operands.append(WTFMove(operand));
 9384     };
 9385 
 9386     auto appendInt32 = [&amp;](Edge&amp; edge) {
 9387         SpeculateInt32Operand operand(this, edge);
 9388         regs.append(operand.gpr());
 9389         operands.append(WTFMove(operand));
 9390     };
 9391 
 9392     auto appendBoolean = [&amp;](Edge&amp; edge) {
 9393         SpeculateBooleanOperand operand(this, edge);
 9394         regs.append(operand.gpr());
 9395         operands.append(WTFMove(operand));
 9396     };
 9397 
 9398     unsigned index = 0;
 9399     m_jit.graph().doToChildren(node, [&amp;](Edge edge) {
 9400         if (!index)
 9401             appendCell(edge);
 9402         else {
 9403             switch (signature-&gt;arguments[index - 1]) {
 9404             case SpecString:
 9405                 appendString(edge);
 9406                 break;
 9407             case SpecInt32Only:
 9408                 appendInt32(edge);
 9409                 break;
 9410             case SpecBoolean:
 9411                 appendBoolean(edge);
 9412                 break;
 9413             default:
 9414                 RELEASE_ASSERT_NOT_REACHED();
 9415                 break;
 9416             }
 9417         }
 9418         ++index;
 9419     });
 9420 
 9421     JSValueRegsTemporary result(this);
 9422     JSValueRegs resultRegs = result.regs();
 9423 
 9424     flushRegisters();
<a name="118" id="anc118"></a><span class="line-modified"> 9425 </span>
<span class="line-added"> 9426     auto function = CFunctionPtr(signature-&gt;functionWithoutTypeCheck);</span>
 9427     unsigned argumentCountIncludingThis = signature-&gt;argumentCount + 1;
 9428     switch (argumentCountIncludingThis) {
 9429     case 1:
<a name="119" id="anc119"></a><span class="line-modified"> 9430         callOperation(reinterpret_cast&lt;J_JITOperation_EP&gt;(function.get()), extractResult(resultRegs), regs[0]);</span>
 9431         break;
 9432     case 2:
<a name="120" id="anc120"></a><span class="line-modified"> 9433         callOperation(reinterpret_cast&lt;J_JITOperation_EPP&gt;(function.get()), extractResult(resultRegs), regs[0], regs[1]);</span>
 9434         break;
 9435     case 3:
<a name="121" id="anc121"></a><span class="line-modified"> 9436         callOperation(reinterpret_cast&lt;J_JITOperation_EPPP&gt;(function.get()), extractResult(resultRegs), regs[0], regs[1], regs[2]);</span>
 9437         break;
 9438     default:
 9439         RELEASE_ASSERT_NOT_REACHED();
 9440         break;
 9441     }
 9442 
 9443     m_jit.exceptionCheck();
 9444     jsValueResult(resultRegs, node);
 9445 }
 9446 
 9447 void SpeculativeJIT::compileCallDOMGetter(Node* node)
 9448 {
 9449     DOMJIT::CallDOMGetterSnippet* snippet = node-&gt;callDOMGetterData()-&gt;snippet;
 9450     if (!snippet) {
 9451         FunctionPtr&lt;OperationPtrTag&gt; getter = node-&gt;callDOMGetterData()-&gt;customAccessorGetter;
 9452         SpeculateCellOperand base(this, node-&gt;child1());
 9453         JSValueRegsTemporary result(this);
 9454 
 9455         JSValueRegs resultRegs = result.regs();
 9456         GPRReg baseGPR = base.gpr();
 9457 
 9458         flushRegisters();
 9459         m_jit.setupArguments&lt;J_JITOperation_EJI&gt;(CCallHelpers::CellValue(baseGPR), identifierUID(node-&gt;callDOMGetterData()-&gt;identifierNumber));
<a name="122" id="anc122"></a><span class="line-modified"> 9460         m_jit.storePtr(GPRInfo::callFrameRegister, &amp;vm().topCallFrame);</span>
 9461         m_jit.emitStoreCodeOrigin(m_currentNode-&gt;origin.semantic);
 9462         m_jit.appendCall(getter.retagged&lt;CFunctionPtrTag&gt;());
 9463         m_jit.setupResults(resultRegs);
 9464 
 9465         m_jit.exceptionCheck();
 9466         jsValueResult(resultRegs, node);
 9467         return;
 9468     }
 9469 
 9470     Vector&lt;GPRReg&gt; gpScratch;
 9471     Vector&lt;FPRReg&gt; fpScratch;
 9472     Vector&lt;SnippetParams::Value&gt; regs;
 9473 
 9474     JSValueRegsTemporary result(this);
 9475     regs.append(result.regs());
 9476 
 9477     Edge&amp; baseEdge = node-&gt;child1();
 9478     SpeculateCellOperand base(this, baseEdge);
 9479     regs.append(SnippetParams::Value(base.gpr(), m_state.forNode(baseEdge).value()));
 9480 
 9481     Optional&lt;SpeculateCellOperand&gt; globalObject;
 9482     if (snippet-&gt;requireGlobalObject) {
 9483         Edge&amp; globalObjectEdge = node-&gt;child2();
 9484         globalObject.emplace(this, globalObjectEdge);
 9485         regs.append(SnippetParams::Value(globalObject-&gt;gpr(), m_state.forNode(globalObjectEdge).value()));
 9486     }
 9487 
 9488     Vector&lt;GPRTemporary&gt; gpTempraries;
 9489     Vector&lt;FPRTemporary&gt; fpTempraries;
 9490     allocateTemporaryRegistersForSnippet(this, gpTempraries, fpTempraries, gpScratch, fpScratch, *snippet);
 9491     SnippetParams params(this, WTFMove(regs), WTFMove(gpScratch), WTFMove(fpScratch));
 9492     snippet-&gt;generator()-&gt;run(m_jit, params);
 9493     jsValueResult(result.regs(), node);
 9494 }
 9495 
 9496 void SpeculativeJIT::compileCheckSubClass(Node* node)
 9497 {
 9498     const ClassInfo* classInfo = node-&gt;classInfo();
 9499     if (!classInfo-&gt;checkSubClassSnippet) {
 9500         SpeculateCellOperand base(this, node-&gt;child1());
 9501         GPRTemporary other(this);
 9502         GPRTemporary specified(this);
 9503 
 9504         GPRReg baseGPR = base.gpr();
 9505         GPRReg otherGPR = other.gpr();
 9506         GPRReg specifiedGPR = specified.gpr();
 9507 
<a name="123" id="anc123"></a><span class="line-modified"> 9508         m_jit.emitLoadStructure(vm(), baseGPR, otherGPR, specifiedGPR);</span>
 9509         m_jit.loadPtr(CCallHelpers::Address(otherGPR, Structure::classInfoOffset()), otherGPR);
 9510         m_jit.move(CCallHelpers::TrustedImmPtr(node-&gt;classInfo()), specifiedGPR);
 9511 
 9512         CCallHelpers::Label loop = m_jit.label();
 9513         auto done = m_jit.branchPtr(CCallHelpers::Equal, otherGPR, specifiedGPR);
 9514         m_jit.loadPtr(CCallHelpers::Address(otherGPR, ClassInfo::offsetOfParentClass()), otherGPR);
 9515         m_jit.branchTestPtr(CCallHelpers::NonZero, otherGPR).linkTo(loop, &amp;m_jit);
 9516         speculationCheck(BadType, JSValueSource::unboxedCell(baseGPR), node-&gt;child1(), m_jit.jump());
 9517         done.link(&amp;m_jit);
 9518         noResult(node);
 9519         return;
 9520     }
 9521 
 9522     Ref&lt;Snippet&gt; snippet = classInfo-&gt;checkSubClassSnippet();
 9523 
 9524     Vector&lt;GPRReg&gt; gpScratch;
 9525     Vector&lt;FPRReg&gt; fpScratch;
 9526     Vector&lt;SnippetParams::Value&gt; regs;
 9527 
 9528     SpeculateCellOperand base(this, node-&gt;child1());
 9529     GPRReg baseGPR = base.gpr();
 9530     regs.append(SnippetParams::Value(baseGPR, m_state.forNode(node-&gt;child1()).value()));
 9531 
 9532     Vector&lt;GPRTemporary&gt; gpTempraries;
 9533     Vector&lt;FPRTemporary&gt; fpTempraries;
 9534     allocateTemporaryRegistersForSnippet(this, gpTempraries, fpTempraries, gpScratch, fpScratch, snippet.get());
 9535 
 9536     SnippetParams params(this, WTFMove(regs), WTFMove(gpScratch), WTFMove(fpScratch));
 9537     CCallHelpers::JumpList failureCases = snippet-&gt;generator()-&gt;run(m_jit, params);
 9538     speculationCheck(BadType, JSValueSource::unboxedCell(baseGPR), node-&gt;child1(), failureCases);
 9539     noResult(node);
 9540 }
 9541 
 9542 GPRReg SpeculativeJIT::temporaryRegisterForPutByVal(GPRTemporary&amp; temporary, ArrayMode arrayMode)
 9543 {
 9544     if (!putByValWillNeedExtraRegister(arrayMode))
 9545         return InvalidGPRReg;
 9546 
 9547     GPRTemporary realTemporary(this);
 9548     temporary.adopt(realTemporary);
 9549     return temporary.gpr();
 9550 }
 9551 
 9552 void SpeculativeJIT::compileToStringOrCallStringConstructorOrStringValueOf(Node* node)
 9553 {
 9554     ASSERT(node-&gt;op() != StringValueOf || node-&gt;child1().useKind() == UntypedUse);
 9555     switch (node-&gt;child1().useKind()) {
 9556     case NotCellUse: {
 9557         JSValueOperand op1(this, node-&gt;child1(), ManualOperandSpeculation);
 9558         JSValueRegs op1Regs = op1.jsValueRegs();
 9559 
 9560         GPRFlushedCallResult result(this);
 9561         GPRReg resultGPR = result.gpr();
 9562 
 9563         speculateNotCell(node-&gt;child1(), op1Regs);
 9564 
 9565         flushRegisters();
 9566 
 9567         if (node-&gt;op() == ToString)
 9568             callOperation(operationToString, resultGPR, op1Regs);
 9569         else {
 9570             ASSERT(node-&gt;op() == CallStringConstructor);
 9571             callOperation(operationCallStringConstructor, resultGPR, op1Regs);
 9572         }
 9573         m_jit.exceptionCheck();
 9574         cellResult(resultGPR, node);
 9575         return;
 9576     }
 9577 
 9578     case UntypedUse: {
 9579         JSValueOperand op1(this, node-&gt;child1());
 9580         JSValueRegs op1Regs = op1.jsValueRegs();
 9581         GPRReg op1PayloadGPR = op1Regs.payloadGPR();
 9582 
 9583         GPRFlushedCallResult result(this);
 9584         GPRReg resultGPR = result.gpr();
 9585 
 9586         flushRegisters();
 9587 
 9588         JITCompiler::Jump done;
 9589         if (node-&gt;child1()-&gt;prediction() &amp; SpecString) {
 9590             JITCompiler::Jump slowPath1 = m_jit.branchIfNotCell(op1.jsValueRegs());
 9591             JITCompiler::Jump slowPath2 = m_jit.branchIfNotString(op1PayloadGPR);
 9592             m_jit.move(op1PayloadGPR, resultGPR);
 9593             done = m_jit.jump();
 9594             slowPath1.link(&amp;m_jit);
 9595             slowPath2.link(&amp;m_jit);
 9596         }
 9597         if (node-&gt;op() == ToString)
 9598             callOperation(operationToString, resultGPR, op1Regs);
 9599         else if (node-&gt;op() == StringValueOf)
 9600             callOperation(operationStringValueOf, resultGPR, op1Regs);
 9601         else {
 9602             ASSERT(node-&gt;op() == CallStringConstructor);
 9603             callOperation(operationCallStringConstructor, resultGPR, op1Regs);
 9604         }
 9605         m_jit.exceptionCheck();
 9606         if (done.isSet())
 9607             done.link(&amp;m_jit);
 9608         cellResult(resultGPR, node);
 9609         return;
 9610     }
 9611 
 9612     case Int32Use:
 9613     case Int52RepUse:
 9614     case DoubleRepUse:
 9615         compileNumberToStringWithValidRadixConstant(node, 10);
 9616         return;
 9617 
 9618     default:
 9619         break;
 9620     }
 9621 
 9622     SpeculateCellOperand op1(this, node-&gt;child1());
 9623     GPRReg op1GPR = op1.gpr();
 9624 
 9625     switch (node-&gt;child1().useKind()) {
 9626     case StringObjectUse: {
 9627         GPRTemporary result(this);
 9628         GPRReg resultGPR = result.gpr();
 9629 
 9630         speculateStringObject(node-&gt;child1(), op1GPR);
 9631 
 9632         m_jit.loadPtr(JITCompiler::Address(op1GPR, JSWrapperObject::internalValueCellOffset()), resultGPR);
 9633         cellResult(resultGPR, node);
 9634         break;
 9635     }
 9636 
 9637     case StringOrStringObjectUse: {
 9638         GPRTemporary result(this);
 9639         GPRReg resultGPR = result.gpr();
 9640 
 9641         m_jit.load8(JITCompiler::Address(op1GPR, JSCell::typeInfoTypeOffset()), resultGPR);
 9642         JITCompiler::Jump isString = m_jit.branch32(JITCompiler::Equal, resultGPR, TrustedImm32(StringType));
 9643 
 9644         speculationCheck(BadType, JSValueSource::unboxedCell(op1GPR), node-&gt;child1().node(), m_jit.branch32(JITCompiler::NotEqual, resultGPR, TrustedImm32(StringObjectType)));
 9645         m_jit.loadPtr(JITCompiler::Address(op1GPR, JSWrapperObject::internalValueCellOffset()), resultGPR);
 9646         JITCompiler::Jump done = m_jit.jump();
 9647 
 9648         isString.link(&amp;m_jit);
 9649         m_jit.move(op1GPR, resultGPR);
 9650         done.link(&amp;m_jit);
 9651 
 9652         m_interpreter.filter(node-&gt;child1(), SpecString | SpecStringObject);
 9653 
 9654         cellResult(resultGPR, node);
 9655         break;
 9656     }
 9657 
 9658     case CellUse: {
 9659         GPRFlushedCallResult result(this);
 9660         GPRReg resultGPR = result.gpr();
 9661 
 9662         // We flush registers instead of silent spill/fill because in this mode we
 9663         // believe that most likely the input is not a string, and we need to take
 9664         // slow path.
 9665         flushRegisters();
 9666         JITCompiler::Jump done;
 9667         if (node-&gt;child1()-&gt;prediction() &amp; SpecString) {
 9668             JITCompiler::Jump needCall = m_jit.branchIfNotString(op1GPR);
 9669             m_jit.move(op1GPR, resultGPR);
 9670             done = m_jit.jump();
 9671             needCall.link(&amp;m_jit);
 9672         }
 9673         if (node-&gt;op() == ToString)
 9674             callOperation(operationToStringOnCell, resultGPR, op1GPR);
 9675         else {
 9676             ASSERT(node-&gt;op() == CallStringConstructor);
 9677             callOperation(operationCallStringConstructorOnCell, resultGPR, op1GPR);
 9678         }
 9679         m_jit.exceptionCheck();
 9680         if (done.isSet())
 9681             done.link(&amp;m_jit);
 9682         cellResult(resultGPR, node);
 9683         break;
 9684     }
 9685 
 9686     default:
 9687         RELEASE_ASSERT_NOT_REACHED();
 9688     }
 9689 }
 9690 
 9691 void SpeculativeJIT::compileNumberToStringWithValidRadixConstant(Node* node)
 9692 {
 9693     compileNumberToStringWithValidRadixConstant(node, node-&gt;validRadixConstant());
 9694 }
 9695 
 9696 void SpeculativeJIT::compileNumberToStringWithValidRadixConstant(Node* node, int32_t radix)
 9697 {
 9698     auto callToString = [&amp;] (auto operation, GPRReg resultGPR, auto valueReg) {
 9699         flushRegisters();
 9700         callOperation(operation, resultGPR, valueReg, TrustedImm32(radix));
 9701         m_jit.exceptionCheck();
 9702         cellResult(resultGPR, node);
 9703     };
 9704 
 9705     switch (node-&gt;child1().useKind()) {
 9706     case Int32Use: {
 9707         SpeculateStrictInt32Operand value(this, node-&gt;child1());
 9708         GPRFlushedCallResult result(this);
 9709         callToString(operationInt32ToStringWithValidRadix, result.gpr(), value.gpr());
 9710         break;
 9711     }
 9712 
 9713 #if USE(JSVALUE64)
 9714     case Int52RepUse: {
 9715         SpeculateStrictInt52Operand value(this, node-&gt;child1());
 9716         GPRFlushedCallResult result(this);
 9717         callToString(operationInt52ToStringWithValidRadix, result.gpr(), value.gpr());
 9718         break;
 9719     }
 9720 #endif
 9721 
 9722     case DoubleRepUse: {
 9723         SpeculateDoubleOperand value(this, node-&gt;child1());
 9724         GPRFlushedCallResult result(this);
 9725         callToString(operationDoubleToStringWithValidRadix, result.gpr(), value.fpr());
 9726         break;
 9727     }
 9728 
 9729     default:
 9730         RELEASE_ASSERT_NOT_REACHED();
 9731     }
 9732 }
 9733 
 9734 void SpeculativeJIT::compileNumberToStringWithRadix(Node* node)
 9735 {
 9736     bool validRadixIsGuaranteed = false;
 9737     if (node-&gt;child2()-&gt;isInt32Constant()) {
 9738         int32_t radix = node-&gt;child2()-&gt;asInt32();
 9739         if (radix &gt;= 2 &amp;&amp; radix &lt;= 36)
 9740             validRadixIsGuaranteed = true;
 9741     }
 9742 
 9743     auto callToString = [&amp;] (auto operation, GPRReg resultGPR, auto valueReg, GPRReg radixGPR) {
 9744         flushRegisters();
 9745         callOperation(operation, resultGPR, valueReg, radixGPR);
 9746         m_jit.exceptionCheck();
 9747         cellResult(resultGPR, node);
 9748     };
 9749 
 9750     switch (node-&gt;child1().useKind()) {
 9751     case Int32Use: {
 9752         SpeculateStrictInt32Operand value(this, node-&gt;child1());
 9753         SpeculateStrictInt32Operand radix(this, node-&gt;child2());
 9754         GPRFlushedCallResult result(this);
 9755         callToString(validRadixIsGuaranteed ? operationInt32ToStringWithValidRadix : operationInt32ToString, result.gpr(), value.gpr(), radix.gpr());
 9756         break;
 9757     }
 9758 
 9759 #if USE(JSVALUE64)
 9760     case Int52RepUse: {
 9761         SpeculateStrictInt52Operand value(this, node-&gt;child1());
 9762         SpeculateStrictInt32Operand radix(this, node-&gt;child2());
 9763         GPRFlushedCallResult result(this);
 9764         callToString(validRadixIsGuaranteed ? operationInt52ToStringWithValidRadix : operationInt52ToString, result.gpr(), value.gpr(), radix.gpr());
 9765         break;
 9766     }
 9767 #endif
 9768 
 9769     case DoubleRepUse: {
 9770         SpeculateDoubleOperand value(this, node-&gt;child1());
 9771         SpeculateStrictInt32Operand radix(this, node-&gt;child2());
 9772         GPRFlushedCallResult result(this);
 9773         callToString(validRadixIsGuaranteed ? operationDoubleToStringWithValidRadix : operationDoubleToString, result.gpr(), value.fpr(), radix.gpr());
 9774         break;
 9775     }
 9776 
 9777     default:
 9778         RELEASE_ASSERT_NOT_REACHED();
 9779     }
 9780 }
 9781 
 9782 void SpeculativeJIT::compileNewStringObject(Node* node)
 9783 {
 9784     SpeculateCellOperand operand(this, node-&gt;child1());
 9785 
 9786     GPRTemporary result(this);
 9787     GPRTemporary scratch1(this);
 9788     GPRTemporary scratch2(this);
 9789 
 9790     GPRReg operandGPR = operand.gpr();
 9791     GPRReg resultGPR = result.gpr();
 9792     GPRReg scratch1GPR = scratch1.gpr();
 9793     GPRReg scratch2GPR = scratch2.gpr();
 9794 
 9795     JITCompiler::JumpList slowPath;
 9796 
 9797     auto butterfly = TrustedImmPtr(nullptr);
 9798     emitAllocateJSObject&lt;StringObject&gt;(
 9799         resultGPR, TrustedImmPtr(node-&gt;structure()), butterfly, scratch1GPR, scratch2GPR,
 9800         slowPath);
 9801 
 9802     m_jit.storePtr(
 9803         TrustedImmPtr(StringObject::info()),
 9804         JITCompiler::Address(resultGPR, JSDestructibleObject::classInfoOffset()));
 9805 #if USE(JSVALUE64)
 9806     m_jit.store64(
 9807         operandGPR, JITCompiler::Address(resultGPR, JSWrapperObject::internalValueOffset()));
 9808 #else
 9809     m_jit.store32(
 9810         TrustedImm32(JSValue::CellTag),
 9811         JITCompiler::Address(resultGPR, JSWrapperObject::internalValueOffset() + OBJECT_OFFSETOF(JSValue, u.asBits.tag)));
 9812     m_jit.store32(
 9813         operandGPR,
 9814         JITCompiler::Address(resultGPR, JSWrapperObject::internalValueOffset() + OBJECT_OFFSETOF(JSValue, u.asBits.payload)));
 9815 #endif
 9816 
<a name="124" id="anc124"></a><span class="line-modified"> 9817     m_jit.mutatorFence(vm());</span>
 9818 
 9819     addSlowPathGenerator(slowPathCall(
 9820         slowPath, this, operationNewStringObject, resultGPR, operandGPR, node-&gt;structure()));
 9821 
 9822     cellResult(resultGPR, node);
 9823 }
 9824 
 9825 void SpeculativeJIT::compileNewSymbol(Node* node)
 9826 {
 9827     if (!node-&gt;child1()) {
 9828         flushRegisters();
 9829         GPRFlushedCallResult result(this);
 9830         GPRReg resultGPR = result.gpr();
 9831         callOperation(operationNewSymbol, resultGPR);
 9832         m_jit.exceptionCheck();
 9833         cellResult(resultGPR, node);
 9834         return;
 9835     }
 9836 
 9837 
 9838     ASSERT(node-&gt;child1().useKind() == KnownStringUse);
 9839     SpeculateCellOperand operand(this, node-&gt;child1());
 9840 
 9841     GPRReg stringGPR = operand.gpr();
 9842 
 9843     flushRegisters();
 9844     GPRFlushedCallResult result(this);
 9845     GPRReg resultGPR = result.gpr();
 9846     callOperation(operationNewSymbolWithDescription, resultGPR, stringGPR);
 9847     m_jit.exceptionCheck();
 9848     cellResult(resultGPR, node);
 9849 }
 9850 
 9851 void SpeculativeJIT::compileNewTypedArrayWithSize(Node* node)
 9852 {
 9853     JSGlobalObject* globalObject = m_jit.graph().globalObjectFor(node-&gt;origin.semantic);
 9854     auto typedArrayType = node-&gt;typedArrayType();
 9855     RegisteredStructure structure = m_jit.graph().registerStructure(globalObject-&gt;typedArrayStructureConcurrently(typedArrayType));
 9856     RELEASE_ASSERT(structure.get());
 9857 
 9858     SpeculateInt32Operand size(this, node-&gt;child1());
 9859     GPRReg sizeGPR = size.gpr();
 9860 
 9861     GPRTemporary result(this);
 9862     GPRTemporary storage(this);
 9863     GPRTemporary scratch(this);
 9864     GPRTemporary scratch2(this);
 9865     GPRReg resultGPR = result.gpr();
 9866     GPRReg storageGPR = storage.gpr();
 9867     GPRReg scratchGPR = scratch.gpr();
 9868     GPRReg scratchGPR2 = scratch2.gpr();
 9869 
 9870     JITCompiler::JumpList slowCases;
 9871 
 9872     m_jit.move(TrustedImmPtr(nullptr), storageGPR);
 9873 
 9874     slowCases.append(m_jit.branch32(
 9875         MacroAssembler::Above, sizeGPR, TrustedImm32(JSArrayBufferView::fastSizeLimit)));
 9876 
 9877     m_jit.move(sizeGPR, scratchGPR);
 9878     m_jit.lshift32(TrustedImm32(logElementSize(typedArrayType)), scratchGPR);
 9879     if (elementSize(typedArrayType) &lt; 8) {
 9880         m_jit.add32(TrustedImm32(7), scratchGPR);
 9881         m_jit.and32(TrustedImm32(~7), scratchGPR);
 9882     }
 9883     m_jit.emitAllocateVariableSized(
<a name="125" id="anc125"></a><span class="line-modified"> 9884         storageGPR, vm().primitiveGigacageAuxiliarySpace, scratchGPR, scratchGPR,</span>
 9885         scratchGPR2, slowCases);
 9886 
 9887     MacroAssembler::Jump done = m_jit.branchTest32(MacroAssembler::Zero, sizeGPR);
 9888     m_jit.move(sizeGPR, scratchGPR);
 9889     if (elementSize(typedArrayType) != 4) {
 9890         if (elementSize(typedArrayType) &gt; 4)
 9891             m_jit.lshift32(TrustedImm32(logElementSize(typedArrayType) - 2), scratchGPR);
 9892         else {
 9893             if (elementSize(typedArrayType) &gt; 1)
 9894                 m_jit.lshift32(TrustedImm32(logElementSize(typedArrayType)), scratchGPR);
 9895             m_jit.add32(TrustedImm32(3), scratchGPR);
 9896             m_jit.urshift32(TrustedImm32(2), scratchGPR);
 9897         }
 9898     }
 9899     MacroAssembler::Label loop = m_jit.label();
 9900     m_jit.sub32(TrustedImm32(1), scratchGPR);
 9901     m_jit.store32(
 9902         TrustedImm32(0),
 9903         MacroAssembler::BaseIndex(storageGPR, scratchGPR, MacroAssembler::TimesFour));
 9904     m_jit.branchTest32(MacroAssembler::NonZero, scratchGPR).linkTo(loop, &amp;m_jit);
 9905     done.link(&amp;m_jit);
<a name="126" id="anc126"></a><span class="line-added"> 9906 #if CPU(ARM64E)</span>
<span class="line-added"> 9907     // sizeGPR is still boxed as a number and there is no 32-bit variant of the PAC instructions.</span>
<span class="line-added"> 9908     m_jit.zeroExtend32ToPtr(sizeGPR, scratchGPR);</span>
<span class="line-added"> 9909     m_jit.tagArrayPtr(scratchGPR, storageGPR);</span>
<span class="line-added"> 9910 #endif</span>
 9911 
 9912     auto butterfly = TrustedImmPtr(nullptr);
 9913     emitAllocateJSObject&lt;JSArrayBufferView&gt;(
 9914         resultGPR, TrustedImmPtr(structure), butterfly, scratchGPR, scratchGPR2,
 9915         slowCases);
 9916 
 9917     m_jit.storePtr(
 9918         storageGPR,
 9919         MacroAssembler::Address(resultGPR, JSArrayBufferView::offsetOfVector()));
 9920     m_jit.store32(
 9921         sizeGPR,
 9922         MacroAssembler::Address(resultGPR, JSArrayBufferView::offsetOfLength()));
 9923     m_jit.store32(
 9924         TrustedImm32(FastTypedArray),
 9925         MacroAssembler::Address(resultGPR, JSArrayBufferView::offsetOfMode()));
 9926 
<a name="127" id="anc127"></a><span class="line-modified"> 9927     m_jit.mutatorFence(vm());</span>
 9928 
 9929     addSlowPathGenerator(slowPathCall(
 9930         slowCases, this, operationNewTypedArrayWithSizeForType(typedArrayType),
 9931         resultGPR, structure, sizeGPR, storageGPR));
 9932 
 9933     cellResult(resultGPR, node);
 9934 }
 9935 
 9936 void SpeculativeJIT::compileNewRegexp(Node* node)
 9937 {
 9938     RegExp* regexp = node-&gt;castOperand&lt;RegExp*&gt;();
<a name="128" id="anc128"></a>
 9939 
 9940     GPRTemporary result(this);
 9941     GPRTemporary scratch1(this);
 9942     GPRTemporary scratch2(this);
 9943     JSValueOperand lastIndex(this, node-&gt;child1());
 9944 
 9945     GPRReg resultGPR = result.gpr();
 9946     GPRReg scratch1GPR = scratch1.gpr();
 9947     GPRReg scratch2GPR = scratch2.gpr();
 9948     JSValueRegs lastIndexRegs = lastIndex.jsValueRegs();
 9949 
 9950     JITCompiler::JumpList slowPath;
 9951 
 9952     auto structure = m_jit.graph().registerStructure(m_jit.graph().globalObjectFor(node-&gt;origin.semantic)-&gt;regExpStructure());
 9953     auto butterfly = TrustedImmPtr(nullptr);
 9954     emitAllocateJSObject&lt;RegExpObject&gt;(resultGPR, TrustedImmPtr(structure), butterfly, scratch1GPR, scratch2GPR, slowPath);
 9955 
 9956     m_jit.storePtr(
 9957         TrustedImmPtr(node-&gt;cellOperand()),
<a name="129" id="anc129"></a><span class="line-modified"> 9958         CCallHelpers::Address(resultGPR, RegExpObject::offsetOfRegExpAndLastIndexIsNotWritableFlag()));</span>
 9959     m_jit.storeValue(lastIndexRegs, CCallHelpers::Address(resultGPR, RegExpObject::offsetOfLastIndex()));
<a name="130" id="anc130"></a><span class="line-modified"> 9960     m_jit.mutatorFence(vm());</span>

 9961 
 9962     addSlowPathGenerator(slowPathCall(slowPath, this, operationNewRegexpWithLastIndex, resultGPR, regexp, lastIndexRegs));
 9963 
 9964     cellResult(resultGPR, node);
 9965 }
 9966 
 9967 void SpeculativeJIT::speculateCellTypeWithoutTypeFiltering(
 9968     Edge edge, GPRReg cellGPR, JSType jsType)
 9969 {
 9970     speculationCheck(
 9971         BadType, JSValueSource::unboxedCell(cellGPR), edge,
 9972         m_jit.branchIfNotType(cellGPR, jsType));
 9973 }
 9974 
 9975 void SpeculativeJIT::speculateCellType(
 9976     Edge edge, GPRReg cellGPR, SpeculatedType specType, JSType jsType)
 9977 {
 9978     DFG_TYPE_CHECK(
 9979         JSValueSource::unboxedCell(cellGPR), edge, specType,
 9980         m_jit.branchIfNotType(cellGPR, jsType));
 9981 }
 9982 
 9983 void SpeculativeJIT::speculateInt32(Edge edge)
 9984 {
 9985     if (!needsTypeCheck(edge, SpecInt32Only))
 9986         return;
 9987 
 9988     (SpeculateInt32Operand(this, edge)).gpr();
 9989 }
 9990 
 9991 void SpeculativeJIT::speculateNumber(Edge edge)
 9992 {
 9993     if (!needsTypeCheck(edge, SpecBytecodeNumber))
 9994         return;
 9995 
 9996     JSValueOperand value(this, edge, ManualOperandSpeculation);
 9997 #if USE(JSVALUE64)
 9998     GPRReg gpr = value.gpr();
 9999     typeCheck(
10000         JSValueRegs(gpr), edge, SpecBytecodeNumber,
10001         m_jit.branchIfNotNumber(gpr));
10002 #else
10003     IGNORE_WARNINGS_BEGIN(&quot;enum-compare&quot;)
10004     static_assert(JSValue::Int32Tag &gt;= JSValue::LowestTag, &quot;Int32Tag is included in &gt;= JSValue::LowestTag range.&quot;);
10005     IGNORE_WARNINGS_END
10006     GPRReg tagGPR = value.tagGPR();
10007     DFG_TYPE_CHECK(
10008         value.jsValueRegs(), edge, ~SpecInt32Only,
10009         m_jit.branchIfInt32(tagGPR));
10010     DFG_TYPE_CHECK(
10011         value.jsValueRegs(), edge, SpecBytecodeNumber,
10012         m_jit.branch32(MacroAssembler::AboveOrEqual, tagGPR, TrustedImm32(JSValue::LowestTag)));
10013 #endif
10014 }
10015 
10016 void SpeculativeJIT::speculateRealNumber(Edge edge)
10017 {
10018     if (!needsTypeCheck(edge, SpecBytecodeRealNumber))
10019         return;
10020 
10021     JSValueOperand op1(this, edge, ManualOperandSpeculation);
10022     FPRTemporary result(this);
10023 
10024     JSValueRegs op1Regs = op1.jsValueRegs();
10025     FPRReg resultFPR = result.fpr();
10026 
10027 #if USE(JSVALUE64)
10028     GPRTemporary temp(this);
10029     GPRReg tempGPR = temp.gpr();
10030     m_jit.unboxDoubleWithoutAssertions(op1Regs.gpr(), tempGPR, resultFPR);
10031 #else
10032     FPRTemporary temp(this);
10033     FPRReg tempFPR = temp.fpr();
10034     unboxDouble(op1Regs.tagGPR(), op1Regs.payloadGPR(), resultFPR, tempFPR);
10035 #endif
10036 
10037     JITCompiler::Jump done = m_jit.branchIfNotNaN(resultFPR);
10038 
10039     typeCheck(op1Regs, edge, SpecBytecodeRealNumber, m_jit.branchIfNotInt32(op1Regs));
10040 
10041     done.link(&amp;m_jit);
10042 }
10043 
10044 void SpeculativeJIT::speculateDoubleRepReal(Edge edge)
10045 {
10046     if (!needsTypeCheck(edge, SpecDoubleReal))
10047         return;
10048 
10049     SpeculateDoubleOperand operand(this, edge);
10050     FPRReg fpr = operand.fpr();
10051     typeCheck(
10052         JSValueRegs(), edge, SpecDoubleReal,
10053         m_jit.branchIfNaN(fpr));
10054 }
10055 
10056 void SpeculativeJIT::speculateBoolean(Edge edge)
10057 {
10058     if (!needsTypeCheck(edge, SpecBoolean))
10059         return;
10060 
10061     (SpeculateBooleanOperand(this, edge)).gpr();
10062 }
10063 
10064 void SpeculativeJIT::speculateCell(Edge edge)
10065 {
10066     if (!needsTypeCheck(edge, SpecCellCheck))
10067         return;
10068 
10069     (SpeculateCellOperand(this, edge)).gpr();
10070 }
10071 
10072 void SpeculativeJIT::speculateCellOrOther(Edge edge)
10073 {
10074     if (!needsTypeCheck(edge, SpecCellCheck | SpecOther))
10075         return;
10076 
10077     JSValueOperand operand(this, edge, ManualOperandSpeculation);
10078     GPRTemporary temp(this);
10079     GPRReg tempGPR = temp.gpr();
10080 
10081     MacroAssembler::Jump ok = m_jit.branchIfCell(operand.jsValueRegs());
10082     DFG_TYPE_CHECK(
10083         operand.jsValueRegs(), edge, SpecCellCheck | SpecOther,
10084         m_jit.branchIfNotOther(operand.jsValueRegs(), tempGPR));
10085     ok.link(&amp;m_jit);
10086 }
10087 
10088 void SpeculativeJIT::speculateObject(Edge edge, GPRReg cell)
10089 {
10090     DFG_TYPE_CHECK(JSValueSource::unboxedCell(cell), edge, SpecObject, m_jit.branchIfNotObject(cell));
10091 }
10092 
10093 void SpeculativeJIT::speculateObject(Edge edge)
10094 {
10095     if (!needsTypeCheck(edge, SpecObject))
10096         return;
10097 
10098     SpeculateCellOperand operand(this, edge);
10099     speculateObject(edge, operand.gpr());
10100 }
10101 
10102 void SpeculativeJIT::speculateFunction(Edge edge, GPRReg cell)
10103 {
10104     speculateCellType(edge, cell, SpecFunction, JSFunctionType);
10105 }
10106 
10107 void SpeculativeJIT::speculateFunction(Edge edge)
10108 {
10109     if (!needsTypeCheck(edge, SpecFunction))
10110         return;
10111 
10112     SpeculateCellOperand operand(this, edge);
10113     speculateFunction(edge, operand.gpr());
10114 }
10115 
10116 void SpeculativeJIT::speculateFinalObject(Edge edge, GPRReg cell)
10117 {
10118     speculateCellType(edge, cell, SpecFinalObject, FinalObjectType);
10119 }
10120 
10121 void SpeculativeJIT::speculateFinalObject(Edge edge)
10122 {
10123     if (!needsTypeCheck(edge, SpecFinalObject))
10124         return;
10125 
10126     SpeculateCellOperand operand(this, edge);
10127     speculateFinalObject(edge, operand.gpr());
10128 }
10129 
10130 void SpeculativeJIT::speculateRegExpObject(Edge edge, GPRReg cell)
10131 {
10132     speculateCellType(edge, cell, SpecRegExpObject, RegExpObjectType);
10133 }
10134 
10135 void SpeculativeJIT::speculateRegExpObject(Edge edge)
10136 {
10137     if (!needsTypeCheck(edge, SpecRegExpObject))
10138         return;
10139 
10140     SpeculateCellOperand operand(this, edge);
10141     speculateRegExpObject(edge, operand.gpr());
10142 }
10143 
10144 void SpeculativeJIT::speculateArray(Edge edge, GPRReg cell)
10145 {
10146     speculateCellType(edge, cell, SpecArray, ArrayType);
10147 }
10148 
10149 void SpeculativeJIT::speculateArray(Edge edge)
10150 {
10151     if (!needsTypeCheck(edge, SpecArray))
10152         return;
10153 
10154     SpeculateCellOperand operand(this, edge);
10155     speculateArray(edge, operand.gpr());
10156 }
10157 
10158 void SpeculativeJIT::speculateProxyObject(Edge edge, GPRReg cell)
10159 {
10160     speculateCellType(edge, cell, SpecProxyObject, ProxyObjectType);
10161 }
10162 
10163 void SpeculativeJIT::speculateProxyObject(Edge edge)
10164 {
10165     if (!needsTypeCheck(edge, SpecProxyObject))
10166         return;
10167 
10168     SpeculateCellOperand operand(this, edge);
10169     speculateProxyObject(edge, operand.gpr());
10170 }
10171 
10172 void SpeculativeJIT::speculateDerivedArray(Edge edge, GPRReg cell)
10173 {
10174     speculateCellType(edge, cell, SpecDerivedArray, DerivedArrayType);
10175 }
10176 
10177 void SpeculativeJIT::speculateDerivedArray(Edge edge)
10178 {
10179     if (!needsTypeCheck(edge, SpecDerivedArray))
10180         return;
10181 
10182     SpeculateCellOperand operand(this, edge);
10183     speculateDerivedArray(edge, operand.gpr());
10184 }
10185 
10186 void SpeculativeJIT::speculateMapObject(Edge edge, GPRReg cell)
10187 {
10188     speculateCellType(edge, cell, SpecMapObject, JSMapType);
10189 }
10190 
10191 void SpeculativeJIT::speculateMapObject(Edge edge)
10192 {
10193     if (!needsTypeCheck(edge, SpecMapObject))
10194         return;
10195 
10196     SpeculateCellOperand operand(this, edge);
10197     speculateMapObject(edge, operand.gpr());
10198 }
10199 
10200 void SpeculativeJIT::speculateSetObject(Edge edge, GPRReg cell)
10201 {
10202     speculateCellType(edge, cell, SpecSetObject, JSSetType);
10203 }
10204 
10205 void SpeculativeJIT::speculateSetObject(Edge edge)
10206 {
10207     if (!needsTypeCheck(edge, SpecSetObject))
10208         return;
10209 
10210     SpeculateCellOperand operand(this, edge);
10211     speculateSetObject(edge, operand.gpr());
10212 }
10213 
10214 void SpeculativeJIT::speculateWeakMapObject(Edge edge, GPRReg cell)
10215 {
10216     speculateCellType(edge, cell, SpecWeakMapObject, JSWeakMapType);
10217 }
10218 
10219 void SpeculativeJIT::speculateWeakMapObject(Edge edge)
10220 {
10221     if (!needsTypeCheck(edge, SpecWeakMapObject))
10222         return;
10223 
10224     SpeculateCellOperand operand(this, edge);
10225     speculateWeakMapObject(edge, operand.gpr());
10226 }
10227 
10228 void SpeculativeJIT::speculateWeakSetObject(Edge edge, GPRReg cell)
10229 {
10230     speculateCellType(edge, cell, SpecWeakSetObject, JSWeakSetType);
10231 }
10232 
10233 void SpeculativeJIT::speculateWeakSetObject(Edge edge)
10234 {
10235     if (!needsTypeCheck(edge, SpecWeakSetObject))
10236         return;
10237 
10238     SpeculateCellOperand operand(this, edge);
10239     speculateWeakSetObject(edge, operand.gpr());
10240 }
10241 
10242 void SpeculativeJIT::speculateDataViewObject(Edge edge, GPRReg cell)
10243 {
10244     speculateCellType(edge, cell, SpecDataViewObject, DataViewType);
10245 }
10246 
10247 void SpeculativeJIT::speculateDataViewObject(Edge edge)
10248 {
10249     if (!needsTypeCheck(edge, SpecDataViewObject))
10250         return;
10251 
10252     SpeculateCellOperand operand(this, edge);
10253     speculateDataViewObject(edge, operand.gpr());
10254 }
10255 
10256 void SpeculativeJIT::speculateObjectOrOther(Edge edge)
10257 {
10258     if (!needsTypeCheck(edge, SpecObject | SpecOther))
10259         return;
10260 
10261     JSValueOperand operand(this, edge, ManualOperandSpeculation);
10262     GPRTemporary temp(this);
10263     GPRReg tempGPR = temp.gpr();
10264     MacroAssembler::Jump notCell = m_jit.branchIfNotCell(operand.jsValueRegs());
10265     GPRReg gpr = operand.jsValueRegs().payloadGPR();
10266     DFG_TYPE_CHECK(
10267         operand.jsValueRegs(), edge, (~SpecCellCheck) | SpecObject, m_jit.branchIfNotObject(gpr));
10268     MacroAssembler::Jump done = m_jit.jump();
10269     notCell.link(&amp;m_jit);
10270     DFG_TYPE_CHECK(
10271         operand.jsValueRegs(), edge, SpecCellCheck | SpecOther,
10272         m_jit.branchIfNotOther(operand.jsValueRegs(), tempGPR));
10273     done.link(&amp;m_jit);
10274 }
10275 
10276 void SpeculativeJIT::speculateString(Edge edge, GPRReg cell)
10277 {
10278     DFG_TYPE_CHECK(
10279         JSValueSource::unboxedCell(cell), edge, SpecString | ~SpecCellCheck, m_jit.branchIfNotString(cell));
10280 }
10281 
10282 void SpeculativeJIT::speculateStringOrOther(Edge edge, JSValueRegs regs, GPRReg scratch)
10283 {
10284     JITCompiler::Jump notCell = m_jit.branchIfNotCell(regs);
10285     GPRReg cell = regs.payloadGPR();
10286     DFG_TYPE_CHECK(regs, edge, (~SpecCellCheck) | SpecString, m_jit.branchIfNotString(cell));
10287     JITCompiler::Jump done = m_jit.jump();
10288     notCell.link(&amp;m_jit);
10289     DFG_TYPE_CHECK(regs, edge, SpecCellCheck | SpecOther, m_jit.branchIfNotOther(regs, scratch));
10290     done.link(&amp;m_jit);
10291 }
10292 
10293 void SpeculativeJIT::speculateStringOrOther(Edge edge)
10294 {
10295     if (!needsTypeCheck(edge, SpecString | SpecOther))
10296         return;
10297 
10298     JSValueOperand operand(this, edge, ManualOperandSpeculation);
10299     GPRTemporary temp(this);
10300     JSValueRegs regs = operand.jsValueRegs();
10301     GPRReg tempGPR = temp.gpr();
10302     speculateStringOrOther(edge, regs, tempGPR);
10303 }
10304 
10305 void SpeculativeJIT::speculateStringIdentAndLoadStorage(Edge edge, GPRReg string, GPRReg storage)
10306 {
10307     m_jit.loadPtr(MacroAssembler::Address(string, JSString::offsetOfValue()), storage);
10308 
10309     if (!needsTypeCheck(edge, SpecStringIdent | ~SpecString))
10310         return;
10311 
10312     speculationCheck(
10313         BadType, JSValueSource::unboxedCell(string), edge,
10314         m_jit.branchIfRopeStringImpl(storage));
10315     speculationCheck(
10316         BadType, JSValueSource::unboxedCell(string), edge, m_jit.branchTest32(
10317             MacroAssembler::Zero,
10318             MacroAssembler::Address(storage, StringImpl::flagsOffset()),
<a name="131" id="anc131"></a><span class="line-modified">10319             MacroAssembler::TrustedImm32(StringImpl::flagIsAtom())));</span>
10320 
10321     m_interpreter.filter(edge, SpecStringIdent | ~SpecString);
10322 }
10323 
10324 void SpeculativeJIT::speculateStringIdent(Edge edge, GPRReg string)
10325 {
10326     if (!needsTypeCheck(edge, SpecStringIdent))
10327         return;
10328 
10329     GPRTemporary temp(this);
10330     speculateStringIdentAndLoadStorage(edge, string, temp.gpr());
10331 }
10332 
10333 void SpeculativeJIT::speculateStringIdent(Edge edge)
10334 {
10335     if (!needsTypeCheck(edge, SpecStringIdent))
10336         return;
10337 
10338     SpeculateCellOperand operand(this, edge);
10339     GPRReg gpr = operand.gpr();
10340     speculateString(edge, gpr);
10341     speculateStringIdent(edge, gpr);
10342 }
10343 
10344 void SpeculativeJIT::speculateString(Edge edge)
10345 {
10346     if (!needsTypeCheck(edge, SpecString))
10347         return;
10348 
10349     SpeculateCellOperand operand(this, edge);
10350     speculateString(edge, operand.gpr());
10351 }
10352 
10353 void SpeculativeJIT::speculateStringObject(Edge edge, GPRReg cellGPR)
10354 {
10355     DFG_TYPE_CHECK(JSValueSource::unboxedCell(cellGPR), edge, ~SpecCellCheck | SpecStringObject, m_jit.branchIfNotType(cellGPR, StringObjectType));
10356 }
10357 
10358 void SpeculativeJIT::speculateStringObject(Edge edge)
10359 {
10360     if (!needsTypeCheck(edge, SpecStringObject))
10361         return;
10362 
10363     SpeculateCellOperand operand(this, edge);
10364     GPRReg gpr = operand.gpr();
10365     speculateStringObject(edge, gpr);
10366 }
10367 
10368 void SpeculativeJIT::speculateStringOrStringObject(Edge edge)
10369 {
10370     if (!needsTypeCheck(edge, SpecString | SpecStringObject))
10371         return;
10372 
10373     SpeculateCellOperand operand(this, edge);
10374     GPRReg gpr = operand.gpr();
10375     if (!needsTypeCheck(edge, SpecString | SpecStringObject))
10376         return;
10377 
10378     GPRTemporary typeTemp(this);
10379     GPRReg typeGPR = typeTemp.gpr();
10380 
10381     m_jit.load8(JITCompiler::Address(gpr, JSCell::typeInfoTypeOffset()), typeGPR);
10382 
10383     JITCompiler::Jump isString = m_jit.branch32(JITCompiler::Equal, typeGPR, TrustedImm32(StringType));
10384     speculationCheck(BadType, JSValueSource::unboxedCell(gpr), edge.node(), m_jit.branch32(JITCompiler::NotEqual, typeGPR, TrustedImm32(StringObjectType)));
10385     isString.link(&amp;m_jit);
10386 
10387     m_interpreter.filter(edge, SpecString | SpecStringObject);
10388 }
10389 
10390 void SpeculativeJIT::speculateNotStringVar(Edge edge)
10391 {
10392     JSValueOperand operand(this, edge, ManualOperandSpeculation);
10393     GPRTemporary temp(this);
10394     GPRReg tempGPR = temp.gpr();
10395 
10396     JITCompiler::Jump notCell = m_jit.branchIfNotCell(operand.jsValueRegs());
10397     GPRReg cell = operand.jsValueRegs().payloadGPR();
10398 
10399     JITCompiler::Jump notString = m_jit.branchIfNotString(cell);
10400 
10401     speculateStringIdentAndLoadStorage(edge, cell, tempGPR);
10402 
10403     notString.link(&amp;m_jit);
10404     notCell.link(&amp;m_jit);
10405 }
10406 
10407 void SpeculativeJIT::speculateNotSymbol(Edge edge)
10408 {
10409     if (!needsTypeCheck(edge, ~SpecSymbol))
10410         return;
10411 
10412     JSValueOperand operand(this, edge, ManualOperandSpeculation);
10413     auto valueRegs = operand.jsValueRegs();
10414     GPRReg value = valueRegs.payloadGPR();
10415     JITCompiler::Jump notCell;
10416 
10417     bool needsCellCheck = needsTypeCheck(edge, SpecCell);
10418     if (needsCellCheck)
10419         notCell = m_jit.branchIfNotCell(valueRegs);
10420 
10421     speculationCheck(BadType, JSValueSource::unboxedCell(value), edge.node(), m_jit.branchIfSymbol(value));
10422 
10423     if (needsCellCheck)
10424         notCell.link(&amp;m_jit);
10425 
10426     m_interpreter.filter(edge, ~SpecSymbol);
10427 }
10428 
10429 void SpeculativeJIT::speculateSymbol(Edge edge, GPRReg cell)
10430 {
10431     DFG_TYPE_CHECK(JSValueSource::unboxedCell(cell), edge, ~SpecCellCheck | SpecSymbol, m_jit.branchIfNotSymbol(cell));
10432 }
10433 
10434 void SpeculativeJIT::speculateSymbol(Edge edge)
10435 {
10436     if (!needsTypeCheck(edge, SpecSymbol))
10437         return;
10438 
10439     SpeculateCellOperand operand(this, edge);
10440     speculateSymbol(edge, operand.gpr());
10441 }
10442 
10443 void SpeculativeJIT::speculateBigInt(Edge edge, GPRReg cell)
10444 {
10445     DFG_TYPE_CHECK(JSValueSource::unboxedCell(cell), edge, ~SpecCellCheck | SpecBigInt, m_jit.branchIfNotBigInt(cell));
10446 }
10447 
10448 void SpeculativeJIT::speculateBigInt(Edge edge)
10449 {
10450     if (!needsTypeCheck(edge, SpecBigInt))
10451         return;
10452 
10453     SpeculateCellOperand operand(this, edge);
10454     speculateBigInt(edge, operand.gpr());
10455 }
10456 
10457 void SpeculativeJIT::speculateNotCell(Edge edge, JSValueRegs regs)
10458 {
10459     DFG_TYPE_CHECK(regs, edge, ~SpecCellCheck, m_jit.branchIfCell(regs));
10460 }
10461 
10462 void SpeculativeJIT::speculateNotCell(Edge edge)
10463 {
10464     if (!needsTypeCheck(edge, ~SpecCellCheck))
10465         return;
10466 
10467     JSValueOperand operand(this, edge, ManualOperandSpeculation);
10468     speculateNotCell(edge, operand.jsValueRegs());
10469 }
10470 
10471 void SpeculativeJIT::speculateOther(Edge edge, JSValueRegs regs, GPRReg tempGPR)
10472 {
10473     DFG_TYPE_CHECK(regs, edge, SpecOther, m_jit.branchIfNotOther(regs, tempGPR));
10474 }
10475 
10476 void SpeculativeJIT::speculateOther(Edge edge, JSValueRegs regs)
10477 {
10478     if (!needsTypeCheck(edge, SpecOther))
10479         return;
10480 
10481     GPRTemporary temp(this);
10482     GPRReg tempGPR = temp.gpr();
10483     speculateOther(edge, regs, tempGPR);
10484 }
10485 
10486 void SpeculativeJIT::speculateOther(Edge edge)
10487 {
10488     if (!needsTypeCheck(edge, SpecOther))
10489         return;
10490 
10491     JSValueOperand operand(this, edge, ManualOperandSpeculation);
10492     speculateOther(edge, operand.jsValueRegs());
10493 }
10494 
10495 void SpeculativeJIT::speculateMisc(Edge edge, JSValueRegs regs)
10496 {
10497 #if USE(JSVALUE64)
10498     DFG_TYPE_CHECK(
10499         regs, edge, SpecMisc,
10500         m_jit.branch64(MacroAssembler::Above, regs.gpr(), MacroAssembler::TrustedImm64(TagBitTypeOther | TagBitBool | TagBitUndefined)));
10501 #else
10502     IGNORE_WARNINGS_BEGIN(&quot;enum-compare&quot;)
10503     static_assert(JSValue::Int32Tag &gt;= JSValue::UndefinedTag, &quot;Int32Tag is included in &gt;= JSValue::UndefinedTag range.&quot;);
10504     IGNORE_WARNINGS_END
10505     DFG_TYPE_CHECK(
10506         regs, edge, ~SpecInt32Only,
10507         m_jit.branchIfInt32(regs.tagGPR()));
10508     DFG_TYPE_CHECK(
10509         regs, edge, SpecMisc,
10510         m_jit.branch32(MacroAssembler::Below, regs.tagGPR(), MacroAssembler::TrustedImm32(JSValue::UndefinedTag)));
10511 #endif
10512 }
10513 
10514 void SpeculativeJIT::speculateMisc(Edge edge)
10515 {
10516     if (!needsTypeCheck(edge, SpecMisc))
10517         return;
10518 
10519     JSValueOperand operand(this, edge, ManualOperandSpeculation);
10520     speculateMisc(edge, operand.jsValueRegs());
10521 }
10522 
10523 void SpeculativeJIT::speculate(Node*, Edge edge)
10524 {
10525     switch (edge.useKind()) {
10526     case UntypedUse:
10527         break;
10528     case DoubleRepUse:
10529     case Int52RepUse:
10530     case KnownInt32Use:
10531     case KnownCellUse:
10532     case KnownStringUse:
10533     case KnownPrimitiveUse:
10534     case KnownOtherUse:
10535     case KnownBooleanUse:
10536         ASSERT(!m_interpreter.needsTypeCheck(edge));
10537         break;
10538     case Int32Use:
10539         speculateInt32(edge);
10540         break;
10541     case NumberUse:
10542         speculateNumber(edge);
10543         break;
10544     case RealNumberUse:
10545         speculateRealNumber(edge);
10546         break;
10547     case DoubleRepRealUse:
10548         speculateDoubleRepReal(edge);
10549         break;
10550 #if USE(JSVALUE64)
10551     case AnyIntUse:
10552         speculateAnyInt(edge);
10553         break;
10554     case DoubleRepAnyIntUse:
10555         speculateDoubleRepAnyInt(edge);
10556         break;
10557 #endif
10558     case BooleanUse:
10559         speculateBoolean(edge);
10560         break;
10561     case CellUse:
10562         speculateCell(edge);
10563         break;
10564     case CellOrOtherUse:
10565         speculateCellOrOther(edge);
10566         break;
10567     case ObjectUse:
10568         speculateObject(edge);
10569         break;
10570     case FunctionUse:
10571         speculateFunction(edge);
10572         break;
10573     case ArrayUse:
10574         speculateArray(edge);
10575         break;
10576     case FinalObjectUse:
10577         speculateFinalObject(edge);
10578         break;
10579     case RegExpObjectUse:
10580         speculateRegExpObject(edge);
10581         break;
10582     case ProxyObjectUse:
10583         speculateProxyObject(edge);
10584         break;
10585     case DerivedArrayUse:
10586         speculateDerivedArray(edge);
10587         break;
10588     case MapObjectUse:
10589         speculateMapObject(edge);
10590         break;
10591     case SetObjectUse:
10592         speculateSetObject(edge);
10593         break;
10594     case WeakMapObjectUse:
10595         speculateWeakMapObject(edge);
10596         break;
10597     case WeakSetObjectUse:
10598         speculateWeakSetObject(edge);
10599         break;
10600     case DataViewObjectUse:
10601         speculateDataViewObject(edge);
10602         break;
10603     case ObjectOrOtherUse:
10604         speculateObjectOrOther(edge);
10605         break;
10606     case StringIdentUse:
10607         speculateStringIdent(edge);
10608         break;
10609     case StringUse:
10610         speculateString(edge);
10611         break;
10612     case StringOrOtherUse:
10613         speculateStringOrOther(edge);
10614         break;
10615     case SymbolUse:
10616         speculateSymbol(edge);
10617         break;
10618     case BigIntUse:
10619         speculateBigInt(edge);
10620         break;
10621     case StringObjectUse:
10622         speculateStringObject(edge);
10623         break;
10624     case StringOrStringObjectUse:
10625         speculateStringOrStringObject(edge);
10626         break;
10627     case NotStringVarUse:
10628         speculateNotStringVar(edge);
10629         break;
10630     case NotSymbolUse:
10631         speculateNotSymbol(edge);
10632         break;
10633     case NotCellUse:
10634         speculateNotCell(edge);
10635         break;
10636     case OtherUse:
10637         speculateOther(edge);
10638         break;
10639     case MiscUse:
10640         speculateMisc(edge);
10641         break;
10642     default:
10643         RELEASE_ASSERT_NOT_REACHED();
10644         break;
10645     }
10646 }
10647 
10648 void SpeculativeJIT::emitSwitchIntJump(
10649     SwitchData* data, GPRReg value, GPRReg scratch)
10650 {
10651     SimpleJumpTable&amp; table = m_jit.codeBlock()-&gt;switchJumpTable(data-&gt;switchTableIndex);
10652     table.ensureCTITable();
10653     m_jit.sub32(Imm32(table.min), value);
10654     addBranch(
10655         m_jit.branch32(JITCompiler::AboveOrEqual, value, Imm32(table.ctiOffsets.size())),
10656         data-&gt;fallThrough.block);
10657     m_jit.move(TrustedImmPtr(table.ctiOffsets.begin()), scratch);
10658     m_jit.loadPtr(JITCompiler::BaseIndex(scratch, value, JITCompiler::timesPtr()), scratch);
10659 
<a name="132" id="anc132"></a><span class="line-modified">10660     m_jit.farJump(scratch, JSSwitchPtrTag);</span>
10661     data-&gt;didUseJumpTable = true;
10662 }
10663 
10664 void SpeculativeJIT::emitSwitchImm(Node* node, SwitchData* data)
10665 {
10666     switch (node-&gt;child1().useKind()) {
10667     case Int32Use: {
10668         SpeculateInt32Operand value(this, node-&gt;child1());
10669         GPRTemporary temp(this);
10670         emitSwitchIntJump(data, value.gpr(), temp.gpr());
10671         noResult(node);
10672         break;
10673     }
10674 
10675     case UntypedUse: {
10676         JSValueOperand value(this, node-&gt;child1());
10677         GPRTemporary temp(this);
10678         JSValueRegs valueRegs = value.jsValueRegs();
10679         GPRReg scratch = temp.gpr();
10680 
10681         value.use();
10682 
10683         auto notInt32 = m_jit.branchIfNotInt32(valueRegs);
10684         emitSwitchIntJump(data, valueRegs.payloadGPR(), scratch);
10685         notInt32.link(&amp;m_jit);
10686         addBranch(m_jit.branchIfNotNumber(valueRegs, scratch), data-&gt;fallThrough.block);
10687         silentSpillAllRegisters(scratch);
10688         callOperation(operationFindSwitchImmTargetForDouble, scratch, valueRegs, data-&gt;switchTableIndex);
10689         silentFillAllRegisters();
10690 
<a name="133" id="anc133"></a><span class="line-modified">10691         m_jit.farJump(scratch, JSSwitchPtrTag);</span>
10692         noResult(node, UseChildrenCalledExplicitly);
10693         break;
10694     }
10695 
10696     default:
10697         RELEASE_ASSERT_NOT_REACHED();
10698         break;
10699     }
10700 }
10701 
10702 void SpeculativeJIT::emitSwitchCharStringJump(
10703     SwitchData* data, GPRReg value, GPRReg scratch)
10704 {
10705     m_jit.loadPtr(MacroAssembler::Address(value, JSString::offsetOfValue()), scratch);
10706     auto isRope = m_jit.branchIfRopeStringImpl(scratch);
10707 
10708     addBranch(
10709         m_jit.branch32(
10710             MacroAssembler::NotEqual,
10711             MacroAssembler::Address(scratch, StringImpl::lengthMemoryOffset()),
10712             TrustedImm32(1)),
10713         data-&gt;fallThrough.block);
10714 
10715     addSlowPathGenerator(slowPathCall(isRope, this, operationResolveRope, scratch, value));
10716 
10717     m_jit.loadPtr(MacroAssembler::Address(scratch, StringImpl::dataOffset()), value);
10718 
10719     JITCompiler::Jump is8Bit = m_jit.branchTest32(
10720         MacroAssembler::NonZero,
10721         MacroAssembler::Address(scratch, StringImpl::flagsOffset()),
10722         TrustedImm32(StringImpl::flagIs8Bit()));
10723 
10724     m_jit.load16(MacroAssembler::Address(value), scratch);
10725 
10726     JITCompiler::Jump ready = m_jit.jump();
10727 
10728     is8Bit.link(&amp;m_jit);
10729     m_jit.load8(MacroAssembler::Address(value), scratch);
10730 
10731     ready.link(&amp;m_jit);
10732     emitSwitchIntJump(data, scratch, value);
10733 }
10734 
10735 void SpeculativeJIT::emitSwitchChar(Node* node, SwitchData* data)
10736 {
10737     switch (node-&gt;child1().useKind()) {
10738     case StringUse: {
10739         SpeculateCellOperand op1(this, node-&gt;child1());
10740         GPRTemporary temp(this);
10741 
10742         GPRReg op1GPR = op1.gpr();
10743         GPRReg tempGPR = temp.gpr();
10744 
10745         op1.use();
10746 
10747         speculateString(node-&gt;child1(), op1GPR);
10748         emitSwitchCharStringJump(data, op1GPR, tempGPR);
10749         noResult(node, UseChildrenCalledExplicitly);
10750         break;
10751     }
10752 
10753     case UntypedUse: {
10754         JSValueOperand op1(this, node-&gt;child1());
10755         GPRTemporary temp(this);
10756 
10757         JSValueRegs op1Regs = op1.jsValueRegs();
10758         GPRReg tempGPR = temp.gpr();
10759 
10760         op1.use();
10761 
10762         addBranch(m_jit.branchIfNotCell(op1Regs), data-&gt;fallThrough.block);
10763 
10764         addBranch(m_jit.branchIfNotString(op1Regs.payloadGPR()), data-&gt;fallThrough.block);
10765 
10766         emitSwitchCharStringJump(data, op1Regs.payloadGPR(), tempGPR);
10767         noResult(node, UseChildrenCalledExplicitly);
10768         break;
10769     }
10770 
10771     default:
10772         RELEASE_ASSERT_NOT_REACHED();
10773         break;
10774     }
10775 }
10776 
10777 namespace {
10778 
10779 struct CharacterCase {
10780     bool operator&lt;(const CharacterCase&amp; other) const
10781     {
10782         return character &lt; other.character;
10783     }
10784 
10785     LChar character;
10786     unsigned begin;
10787     unsigned end;
10788 };
10789 
10790 } // anonymous namespace
10791 
10792 void SpeculativeJIT::emitBinarySwitchStringRecurse(
10793     SwitchData* data, const Vector&lt;SpeculativeJIT::StringSwitchCase&gt;&amp; cases,
10794     unsigned numChecked, unsigned begin, unsigned end, GPRReg buffer, GPRReg length,
10795     GPRReg temp, unsigned alreadyCheckedLength, bool checkedExactLength)
10796 {
10797     static const bool verbose = false;
10798 
10799     if (verbose) {
10800         dataLog(&quot;We&#39;re down to the following cases, alreadyCheckedLength = &quot;, alreadyCheckedLength, &quot;:\n&quot;);
10801         for (unsigned i = begin; i &lt; end; ++i) {
10802             dataLog(&quot;    &quot;, cases[i].string, &quot;\n&quot;);
10803         }
10804     }
10805 
10806     if (begin == end) {
10807         jump(data-&gt;fallThrough.block, ForceJump);
10808         return;
10809     }
10810 
10811     unsigned minLength = cases[begin].string-&gt;length();
10812     unsigned commonChars = minLength;
10813     bool allLengthsEqual = true;
10814     for (unsigned i = begin + 1; i &lt; end; ++i) {
10815         unsigned myCommonChars = numChecked;
10816         for (unsigned j = numChecked;
10817             j &lt; std::min(cases[begin].string-&gt;length(), cases[i].string-&gt;length());
10818             ++j) {
10819             if (cases[begin].string-&gt;at(j) != cases[i].string-&gt;at(j)) {
10820                 if (verbose)
10821                     dataLog(&quot;string(&quot;, cases[i].string, &quot;)[&quot;, j, &quot;] != string(&quot;, cases[begin].string, &quot;)[&quot;, j, &quot;]\n&quot;);
10822                 break;
10823             }
10824             myCommonChars++;
10825         }
10826         commonChars = std::min(commonChars, myCommonChars);
10827         if (minLength != cases[i].string-&gt;length())
10828             allLengthsEqual = false;
10829         minLength = std::min(minLength, cases[i].string-&gt;length());
10830     }
10831 
10832     if (checkedExactLength) {
10833         RELEASE_ASSERT(alreadyCheckedLength == minLength);
10834         RELEASE_ASSERT(allLengthsEqual);
10835     }
10836 
10837     RELEASE_ASSERT(minLength &gt;= commonChars);
10838 
10839     if (verbose)
10840         dataLog(&quot;length = &quot;, minLength, &quot;, commonChars = &quot;, commonChars, &quot;, allLengthsEqual = &quot;, allLengthsEqual, &quot;\n&quot;);
10841 
10842     if (!allLengthsEqual &amp;&amp; alreadyCheckedLength &lt; minLength)
10843         branch32(MacroAssembler::Below, length, Imm32(minLength), data-&gt;fallThrough.block);
10844     if (allLengthsEqual &amp;&amp; (alreadyCheckedLength &lt; minLength || !checkedExactLength))
10845         branch32(MacroAssembler::NotEqual, length, Imm32(minLength), data-&gt;fallThrough.block);
10846 
10847     for (unsigned i = numChecked; i &lt; commonChars; ++i) {
10848         branch8(
10849             MacroAssembler::NotEqual, MacroAssembler::Address(buffer, i),
10850             TrustedImm32(cases[begin].string-&gt;at(i)), data-&gt;fallThrough.block);
10851     }
10852 
10853     if (minLength == commonChars) {
10854         // This is the case where one of the cases is a prefix of all of the other cases.
10855         // We&#39;ve already checked that the input string is a prefix of all of the cases,
10856         // so we just check length to jump to that case.
10857 
10858         if (!ASSERT_DISABLED) {
10859             ASSERT(cases[begin].string-&gt;length() == commonChars);
10860             for (unsigned i = begin + 1; i &lt; end; ++i)
10861                 ASSERT(cases[i].string-&gt;length() &gt; commonChars);
10862         }
10863 
10864         if (allLengthsEqual) {
10865             RELEASE_ASSERT(end == begin + 1);
10866             jump(cases[begin].target, ForceJump);
10867             return;
10868         }
10869 
10870         branch32(MacroAssembler::Equal, length, Imm32(commonChars), cases[begin].target);
10871 
10872         // We&#39;ve checked if the length is &gt;= minLength, and then we checked if the
10873         // length is == commonChars. We get to this point if it is &gt;= minLength but not
10874         // == commonChars. Hence we know that it now must be &gt; minLength, i.e., that
10875         // it&#39;s &gt;= minLength + 1.
10876         emitBinarySwitchStringRecurse(
10877             data, cases, commonChars, begin + 1, end, buffer, length, temp, minLength + 1, false);
10878         return;
10879     }
10880 
10881     // At this point we know that the string is longer than commonChars, and we&#39;ve only
10882     // verified commonChars. Use a binary switch on the next unchecked character, i.e.
10883     // string[commonChars].
10884 
10885     RELEASE_ASSERT(end &gt;= begin + 2);
10886 
10887     m_jit.load8(MacroAssembler::Address(buffer, commonChars), temp);
10888 
10889     Vector&lt;CharacterCase&gt; characterCases;
10890     CharacterCase currentCase;
10891     currentCase.character = cases[begin].string-&gt;at(commonChars);
10892     currentCase.begin = begin;
10893     currentCase.end = begin + 1;
10894     for (unsigned i = begin + 1; i &lt; end; ++i) {
10895         if (cases[i].string-&gt;at(commonChars) != currentCase.character) {
10896             if (verbose)
10897                 dataLog(&quot;string(&quot;, cases[i].string, &quot;)[&quot;, commonChars, &quot;] != string(&quot;, cases[begin].string, &quot;)[&quot;, commonChars, &quot;]\n&quot;);
10898             currentCase.end = i;
10899             characterCases.append(currentCase);
10900             currentCase.character = cases[i].string-&gt;at(commonChars);
10901             currentCase.begin = i;
10902             currentCase.end = i + 1;
10903         } else
10904             currentCase.end = i + 1;
10905     }
10906     characterCases.append(currentCase);
10907 
10908     Vector&lt;int64_t&gt; characterCaseValues;
10909     for (unsigned i = 0; i &lt; characterCases.size(); ++i)
10910         characterCaseValues.append(characterCases[i].character);
10911 
10912     BinarySwitch binarySwitch(temp, characterCaseValues, BinarySwitch::Int32);
10913     while (binarySwitch.advance(m_jit)) {
10914         const CharacterCase&amp; myCase = characterCases[binarySwitch.caseIndex()];
10915         emitBinarySwitchStringRecurse(
10916             data, cases, commonChars + 1, myCase.begin, myCase.end, buffer, length,
10917             temp, minLength, allLengthsEqual);
10918     }
10919 
10920     addBranch(binarySwitch.fallThrough(), data-&gt;fallThrough.block);
10921 }
10922 
10923 void SpeculativeJIT::emitSwitchStringOnString(SwitchData* data, GPRReg string)
10924 {
10925     data-&gt;didUseJumpTable = true;
10926 
10927     bool canDoBinarySwitch = true;
10928     unsigned totalLength = 0;
10929 
10930     for (unsigned i = data-&gt;cases.size(); i--;) {
10931         StringImpl* string = data-&gt;cases[i].value.stringImpl();
10932         if (!string-&gt;is8Bit()) {
10933             canDoBinarySwitch = false;
10934             break;
10935         }
10936         if (string-&gt;length() &gt; Options::maximumBinaryStringSwitchCaseLength()) {
10937             canDoBinarySwitch = false;
10938             break;
10939         }
10940         totalLength += string-&gt;length();
10941     }
10942 
10943     if (!canDoBinarySwitch || totalLength &gt; Options::maximumBinaryStringSwitchTotalLength()) {
10944         flushRegisters();
10945         callOperation(
10946             operationSwitchString, string, static_cast&lt;size_t&gt;(data-&gt;switchTableIndex), string);
10947         m_jit.exceptionCheck();
<a name="134" id="anc134"></a><span class="line-modified">10948         m_jit.farJump(string, JSSwitchPtrTag);</span>
10949         return;
10950     }
10951 
10952     GPRTemporary length(this);
10953     GPRTemporary temp(this);
10954 
10955     GPRReg lengthGPR = length.gpr();
10956     GPRReg tempGPR = temp.gpr();
10957 
10958     MacroAssembler::JumpList slowCases;
10959     m_jit.loadPtr(MacroAssembler::Address(string, JSString::offsetOfValue()), tempGPR);
10960     slowCases.append(m_jit.branchIfRopeStringImpl(tempGPR));
10961     m_jit.load32(MacroAssembler::Address(tempGPR, StringImpl::lengthMemoryOffset()), lengthGPR);
10962 
10963     slowCases.append(m_jit.branchTest32(
10964         MacroAssembler::Zero,
10965         MacroAssembler::Address(tempGPR, StringImpl::flagsOffset()),
10966         TrustedImm32(StringImpl::flagIs8Bit())));
10967 
10968     m_jit.loadPtr(MacroAssembler::Address(tempGPR, StringImpl::dataOffset()), string);
10969 
10970     Vector&lt;StringSwitchCase&gt; cases;
10971     for (unsigned i = 0; i &lt; data-&gt;cases.size(); ++i) {
10972         cases.append(
10973             StringSwitchCase(data-&gt;cases[i].value.stringImpl(), data-&gt;cases[i].target.block));
10974     }
10975 
10976     std::sort(cases.begin(), cases.end());
10977 
10978     emitBinarySwitchStringRecurse(
10979         data, cases, 0, 0, cases.size(), string, lengthGPR, tempGPR, 0, false);
10980 
10981     slowCases.link(&amp;m_jit);
10982     silentSpillAllRegisters(string);
10983     callOperation(operationSwitchString, string, static_cast&lt;size_t&gt;(data-&gt;switchTableIndex), string);
10984     silentFillAllRegisters();
10985     m_jit.exceptionCheck();
<a name="135" id="anc135"></a><span class="line-modified">10986     m_jit.farJump(string, JSSwitchPtrTag);</span>
10987 }
10988 
10989 void SpeculativeJIT::emitSwitchString(Node* node, SwitchData* data)
10990 {
10991     switch (node-&gt;child1().useKind()) {
10992     case StringIdentUse: {
10993         SpeculateCellOperand op1(this, node-&gt;child1());
10994         GPRTemporary temp(this);
10995 
10996         GPRReg op1GPR = op1.gpr();
10997         GPRReg tempGPR = temp.gpr();
10998 
10999         speculateString(node-&gt;child1(), op1GPR);
11000         speculateStringIdentAndLoadStorage(node-&gt;child1(), op1GPR, tempGPR);
11001 
11002         Vector&lt;int64_t&gt; identifierCaseValues;
11003         for (unsigned i = 0; i &lt; data-&gt;cases.size(); ++i) {
11004             identifierCaseValues.append(
11005                 static_cast&lt;int64_t&gt;(bitwise_cast&lt;intptr_t&gt;(data-&gt;cases[i].value.stringImpl())));
11006         }
11007 
11008         BinarySwitch binarySwitch(tempGPR, identifierCaseValues, BinarySwitch::IntPtr);
11009         while (binarySwitch.advance(m_jit))
11010             jump(data-&gt;cases[binarySwitch.caseIndex()].target.block, ForceJump);
11011         addBranch(binarySwitch.fallThrough(), data-&gt;fallThrough.block);
11012 
11013         noResult(node);
11014         break;
11015     }
11016 
11017     case StringUse: {
11018         SpeculateCellOperand op1(this, node-&gt;child1());
11019 
11020         GPRReg op1GPR = op1.gpr();
11021 
11022         op1.use();
11023 
11024         speculateString(node-&gt;child1(), op1GPR);
11025         emitSwitchStringOnString(data, op1GPR);
11026         noResult(node, UseChildrenCalledExplicitly);
11027         break;
11028     }
11029 
11030     case UntypedUse: {
11031         JSValueOperand op1(this, node-&gt;child1());
11032 
11033         JSValueRegs op1Regs = op1.jsValueRegs();
11034 
11035         op1.use();
11036 
11037         addBranch(m_jit.branchIfNotCell(op1Regs), data-&gt;fallThrough.block);
11038 
11039         addBranch(m_jit.branchIfNotString(op1Regs.payloadGPR()), data-&gt;fallThrough.block);
11040 
11041         emitSwitchStringOnString(data, op1Regs.payloadGPR());
11042         noResult(node, UseChildrenCalledExplicitly);
11043         break;
11044     }
11045 
11046     default:
11047         RELEASE_ASSERT_NOT_REACHED();
11048         break;
11049     }
11050 }
11051 
11052 void SpeculativeJIT::emitSwitch(Node* node)
11053 {
11054     SwitchData* data = node-&gt;switchData();
11055     switch (data-&gt;kind) {
11056     case SwitchImm: {
11057         emitSwitchImm(node, data);
11058         return;
11059     }
11060     case SwitchChar: {
11061         emitSwitchChar(node, data);
11062         return;
11063     }
11064     case SwitchString: {
11065         emitSwitchString(node, data);
11066         return;
11067     }
11068     case SwitchCell: {
11069         DFG_CRASH(m_jit.graph(), node, &quot;Bad switch kind&quot;);
11070         return;
11071     } }
11072     RELEASE_ASSERT_NOT_REACHED();
11073 }
11074 
11075 void SpeculativeJIT::addBranch(const MacroAssembler::JumpList&amp; jump, BasicBlock* destination)
11076 {
11077     for (unsigned i = jump.jumps().size(); i--;)
11078         addBranch(jump.jumps()[i], destination);
11079 }
11080 
11081 void SpeculativeJIT::linkBranches()
11082 {
11083     for (auto&amp; branch : m_branches)
11084         branch.jump.linkTo(m_jit.blockHeads()[branch.destination-&gt;index], &amp;m_jit);
11085 }
11086 
11087 void SpeculativeJIT::compileStoreBarrier(Node* node)
11088 {
11089     ASSERT(node-&gt;op() == StoreBarrier || node-&gt;op() == FencedStoreBarrier);
11090 
11091     bool isFenced = node-&gt;op() == FencedStoreBarrier;
11092 
11093     SpeculateCellOperand base(this, node-&gt;child1());
11094     GPRTemporary scratch1(this);
11095 
11096     GPRReg baseGPR = base.gpr();
11097     GPRReg scratch1GPR = scratch1.gpr();
11098 
11099     JITCompiler::JumpList ok;
11100 
11101     if (isFenced) {
<a name="136" id="anc136"></a><span class="line-modified">11102         ok.append(m_jit.barrierBranch(vm(), baseGPR, scratch1GPR));</span>
11103 
<a name="137" id="anc137"></a><span class="line-modified">11104         JITCompiler::Jump noFence = m_jit.jumpIfMutatorFenceNotNeeded(vm());</span>
11105         m_jit.memoryFence();
11106         ok.append(m_jit.barrierBranchWithoutFence(baseGPR));
11107         noFence.link(&amp;m_jit);
11108     } else
11109         ok.append(m_jit.barrierBranchWithoutFence(baseGPR));
11110 
11111     silentSpillAllRegisters(InvalidGPRReg);
11112     callOperation(operationWriteBarrierSlowPath, baseGPR);
11113     silentFillAllRegisters();
11114 
11115     ok.link(&amp;m_jit);
11116 
11117     noResult(node);
11118 }
11119 
11120 void SpeculativeJIT::compilePutAccessorById(Node* node)
11121 {
11122     SpeculateCellOperand base(this, node-&gt;child1());
11123     SpeculateCellOperand accessor(this, node-&gt;child2());
11124 
11125     GPRReg baseGPR = base.gpr();
11126     GPRReg accessorGPR = accessor.gpr();
11127 
11128     flushRegisters();
11129     callOperation(node-&gt;op() == PutGetterById ? operationPutGetterById : operationPutSetterById, NoResult, baseGPR, identifierUID(node-&gt;identifierNumber()), node-&gt;accessorAttributes(), accessorGPR);
11130     m_jit.exceptionCheck();
11131 
11132     noResult(node);
11133 }
11134 
11135 void SpeculativeJIT::compilePutGetterSetterById(Node* node)
11136 {
11137     SpeculateCellOperand base(this, node-&gt;child1());
11138     JSValueOperand getter(this, node-&gt;child2());
11139     JSValueOperand setter(this, node-&gt;child3());
11140 
11141 #if USE(JSVALUE64)
11142     GPRReg baseGPR = base.gpr();
11143     GPRReg getterGPR = getter.gpr();
11144     GPRReg setterGPR = setter.gpr();
11145 
11146     flushRegisters();
11147     callOperation(operationPutGetterSetter, NoResult, baseGPR, identifierUID(node-&gt;identifierNumber()), node-&gt;accessorAttributes(), getterGPR, setterGPR);
11148 #else
11149     // These JSValues may be JSUndefined OR JSFunction*.
11150     // At that time,
11151     // 1. If the JSValue is JSUndefined, its payload becomes nullptr.
11152     // 2. If the JSValue is JSFunction*, its payload becomes JSFunction*.
11153     // So extract payload and pass it to operationPutGetterSetter. This hack is used as the same way in baseline JIT.
11154     GPRReg baseGPR = base.gpr();
11155     JSValueRegs getterRegs = getter.jsValueRegs();
11156     JSValueRegs setterRegs = setter.jsValueRegs();
11157 
11158     flushRegisters();
11159     callOperation(operationPutGetterSetter, NoResult, baseGPR, identifierUID(node-&gt;identifierNumber()), node-&gt;accessorAttributes(), getterRegs.payloadGPR(), setterRegs.payloadGPR());
11160 #endif
11161     m_jit.exceptionCheck();
11162 
11163     noResult(node);
11164 }
11165 
11166 void SpeculativeJIT::compileResolveScope(Node* node)
11167 {
11168     SpeculateCellOperand scope(this, node-&gt;child1());
11169     GPRReg scopeGPR = scope.gpr();
11170     GPRFlushedCallResult result(this);
11171     GPRReg resultGPR = result.gpr();
11172     flushRegisters();
11173     callOperation(operationResolveScope, resultGPR, scopeGPR, identifierUID(node-&gt;identifierNumber()));
11174     m_jit.exceptionCheck();
11175     cellResult(resultGPR, node);
11176 }
11177 
11178 void SpeculativeJIT::compileResolveScopeForHoistingFuncDeclInEval(Node* node)
11179 {
11180     SpeculateCellOperand scope(this, node-&gt;child1());
11181     GPRReg scopeGPR = scope.gpr();
11182     flushRegisters();
11183     JSValueRegsFlushedCallResult result(this);
11184     JSValueRegs resultRegs = result.regs();
11185     callOperation(operationResolveScopeForHoistingFuncDeclInEval, resultRegs, scopeGPR, identifierUID(node-&gt;identifierNumber()));
11186     m_jit.exceptionCheck();
11187     jsValueResult(resultRegs, node);
11188 }
11189 
11190 void SpeculativeJIT::compileGetGlobalVariable(Node* node)
11191 {
11192     JSValueRegsTemporary result(this);
11193     JSValueRegs resultRegs = result.regs();
11194     m_jit.loadValue(node-&gt;variablePointer(), resultRegs);
11195     jsValueResult(resultRegs, node);
11196 }
11197 
11198 void SpeculativeJIT::compilePutGlobalVariable(Node* node)
11199 {
11200     JSValueOperand value(this, node-&gt;child2());
11201     JSValueRegs valueRegs = value.jsValueRegs();
11202     m_jit.storeValue(valueRegs, node-&gt;variablePointer());
11203     noResult(node);
11204 }
11205 
11206 void SpeculativeJIT::compileGetDynamicVar(Node* node)
11207 {
11208     SpeculateCellOperand scope(this, node-&gt;child1());
11209     GPRReg scopeGPR = scope.gpr();
11210     flushRegisters();
11211     JSValueRegsFlushedCallResult result(this);
11212     JSValueRegs resultRegs = result.regs();
11213     callOperation(operationGetDynamicVar, resultRegs, scopeGPR, identifierUID(node-&gt;identifierNumber()), node-&gt;getPutInfo());
11214     m_jit.exceptionCheck();
11215     jsValueResult(resultRegs, node);
11216 }
11217 
11218 void SpeculativeJIT::compilePutDynamicVar(Node* node)
11219 {
11220     SpeculateCellOperand scope(this, node-&gt;child1());
11221     JSValueOperand value(this, node-&gt;child2());
11222 
11223     GPRReg scopeGPR = scope.gpr();
11224     JSValueRegs valueRegs = value.jsValueRegs();
11225 
11226     flushRegisters();
<a name="138" id="anc138"></a><span class="line-modified">11227     callOperation(m_jit.isStrictModeFor(node-&gt;origin.semantic) ? operationPutDynamicVarStrict : operationPutDynamicVarNonStrict, NoResult, scopeGPR, valueRegs, identifierUID(node-&gt;identifierNumber()), node-&gt;getPutInfo());</span>
11228     m_jit.exceptionCheck();
11229     noResult(node);
11230 }
11231 
11232 void SpeculativeJIT::compileGetClosureVar(Node* node)
11233 {
11234     SpeculateCellOperand base(this, node-&gt;child1());
11235     JSValueRegsTemporary result(this);
11236 
11237     GPRReg baseGPR = base.gpr();
11238     JSValueRegs resultRegs = result.regs();
11239 
11240     m_jit.loadValue(JITCompiler::Address(baseGPR, JSLexicalEnvironment::offsetOfVariable(node-&gt;scopeOffset())), resultRegs);
11241     jsValueResult(resultRegs, node);
11242 }
11243 
11244 void SpeculativeJIT::compilePutClosureVar(Node* node)
11245 {
11246     SpeculateCellOperand base(this, node-&gt;child1());
11247     JSValueOperand value(this, node-&gt;child2());
11248 
11249     GPRReg baseGPR = base.gpr();
11250     JSValueRegs valueRegs = value.jsValueRegs();
11251 
11252     m_jit.storeValue(valueRegs, JITCompiler::Address(baseGPR, JSLexicalEnvironment::offsetOfVariable(node-&gt;scopeOffset())));
11253     noResult(node);
11254 }
11255 
11256 void SpeculativeJIT::compilePutAccessorByVal(Node* node)
11257 {
11258     SpeculateCellOperand base(this, node-&gt;child1());
11259     JSValueOperand subscript(this, node-&gt;child2());
11260     SpeculateCellOperand accessor(this, node-&gt;child3());
11261 
11262     auto operation = node-&gt;op() == PutGetterByVal ? operationPutGetterByVal : operationPutSetterByVal;
11263 
11264     GPRReg baseGPR = base.gpr();
11265     JSValueRegs subscriptRegs = subscript.jsValueRegs();
11266     GPRReg accessorGPR = accessor.gpr();
11267 
11268     flushRegisters();
11269     callOperation(operation, NoResult, baseGPR, subscriptRegs, node-&gt;accessorAttributes(), accessorGPR);
11270     m_jit.exceptionCheck();
11271 
11272     noResult(node);
11273 }
11274 
11275 void SpeculativeJIT::compileGetRegExpObjectLastIndex(Node* node)
11276 {
11277     SpeculateCellOperand regExp(this, node-&gt;child1());
11278     JSValueRegsTemporary result(this);
11279     GPRReg regExpGPR = regExp.gpr();
11280     JSValueRegs resultRegs = result.regs();
11281     speculateRegExpObject(node-&gt;child1(), regExpGPR);
11282     m_jit.loadValue(JITCompiler::Address(regExpGPR, RegExpObject::offsetOfLastIndex()), resultRegs);
11283     jsValueResult(resultRegs, node);
11284 }
11285 
11286 void SpeculativeJIT::compileSetRegExpObjectLastIndex(Node* node)
11287 {
11288     SpeculateCellOperand regExp(this, node-&gt;child1());
11289     JSValueOperand value(this, node-&gt;child2());
11290     GPRReg regExpGPR = regExp.gpr();
11291     JSValueRegs valueRegs = value.jsValueRegs();
11292 
11293     if (!node-&gt;ignoreLastIndexIsWritable()) {
11294         speculateRegExpObject(node-&gt;child1(), regExpGPR);
11295         speculationCheck(
11296             ExoticObjectMode, JSValueRegs(), nullptr,
<a name="139" id="anc139"></a><span class="line-modified">11297             m_jit.branchTestPtr(</span>
<span class="line-modified">11298                 JITCompiler::NonZero,</span>
<span class="line-modified">11299                 JITCompiler::Address(regExpGPR, RegExpObject::offsetOfRegExpAndLastIndexIsNotWritableFlag()),</span>
<span class="line-added">11300                 JITCompiler::TrustedImm32(RegExpObject::lastIndexIsNotWritableFlag)));</span>
11301     }
11302 
11303     m_jit.storeValue(valueRegs, JITCompiler::Address(regExpGPR, RegExpObject::offsetOfLastIndex()));
11304     noResult(node);
11305 }
11306 
11307 void SpeculativeJIT::compileRegExpExec(Node* node)
11308 {
11309     bool sample = false;
11310     if (sample)
11311         m_jit.incrementSuperSamplerCount();
11312 
11313     SpeculateCellOperand globalObject(this, node-&gt;child1());
11314     GPRReg globalObjectGPR = globalObject.gpr();
11315 
11316     if (node-&gt;child2().useKind() == RegExpObjectUse) {
11317         if (node-&gt;child3().useKind() == StringUse) {
11318             SpeculateCellOperand base(this, node-&gt;child2());
11319             SpeculateCellOperand argument(this, node-&gt;child3());
11320             GPRReg baseGPR = base.gpr();
11321             GPRReg argumentGPR = argument.gpr();
11322             speculateRegExpObject(node-&gt;child2(), baseGPR);
11323             speculateString(node-&gt;child3(), argumentGPR);
11324 
11325             flushRegisters();
11326             JSValueRegsFlushedCallResult result(this);
11327             JSValueRegs resultRegs = result.regs();
11328             callOperation(operationRegExpExecString, resultRegs, globalObjectGPR, baseGPR, argumentGPR);
11329             m_jit.exceptionCheck();
11330 
11331             jsValueResult(resultRegs, node);
11332 
11333             if (sample)
11334                 m_jit.decrementSuperSamplerCount();
11335             return;
11336         }
11337 
11338         SpeculateCellOperand base(this, node-&gt;child2());
11339         JSValueOperand argument(this, node-&gt;child3());
11340         GPRReg baseGPR = base.gpr();
11341         JSValueRegs argumentRegs = argument.jsValueRegs();
11342         speculateRegExpObject(node-&gt;child2(), baseGPR);
11343 
11344         flushRegisters();
11345         JSValueRegsFlushedCallResult result(this);
11346         JSValueRegs resultRegs = result.regs();
11347         callOperation(operationRegExpExec, resultRegs, globalObjectGPR, baseGPR, argumentRegs);
11348         m_jit.exceptionCheck();
11349 
11350         jsValueResult(resultRegs, node);
11351 
11352         if (sample)
11353             m_jit.decrementSuperSamplerCount();
11354         return;
11355     }
11356 
11357     JSValueOperand base(this, node-&gt;child2());
11358     JSValueOperand argument(this, node-&gt;child3());
11359     JSValueRegs baseRegs = base.jsValueRegs();
11360     JSValueRegs argumentRegs = argument.jsValueRegs();
11361 
11362     flushRegisters();
11363     JSValueRegsFlushedCallResult result(this);
11364     JSValueRegs resultRegs = result.regs();
11365     callOperation(operationRegExpExecGeneric, resultRegs, globalObjectGPR, baseRegs, argumentRegs);
11366     m_jit.exceptionCheck();
11367 
11368     jsValueResult(resultRegs, node);
11369 
11370     if (sample)
11371         m_jit.decrementSuperSamplerCount();
11372 }
11373 
11374 void SpeculativeJIT::compileRegExpTest(Node* node)
11375 {
11376     SpeculateCellOperand globalObject(this, node-&gt;child1());
11377     GPRReg globalObjectGPR = globalObject.gpr();
11378 
11379     if (node-&gt;child2().useKind() == RegExpObjectUse) {
11380         if (node-&gt;child3().useKind() == StringUse) {
11381             SpeculateCellOperand base(this, node-&gt;child2());
11382             SpeculateCellOperand argument(this, node-&gt;child3());
11383             GPRReg baseGPR = base.gpr();
11384             GPRReg argumentGPR = argument.gpr();
11385             speculateRegExpObject(node-&gt;child2(), baseGPR);
11386             speculateString(node-&gt;child3(), argumentGPR);
11387 
11388             flushRegisters();
11389             GPRFlushedCallResult result(this);
11390             callOperation(operationRegExpTestString, result.gpr(), globalObjectGPR, baseGPR, argumentGPR);
11391             m_jit.exceptionCheck();
11392 
11393             unblessedBooleanResult(result.gpr(), node);
11394             return;
11395         }
11396 
11397         SpeculateCellOperand base(this, node-&gt;child2());
11398         JSValueOperand argument(this, node-&gt;child3());
11399         GPRReg baseGPR = base.gpr();
11400         JSValueRegs argumentRegs = argument.jsValueRegs();
11401         speculateRegExpObject(node-&gt;child2(), baseGPR);
11402 
11403         flushRegisters();
11404         GPRFlushedCallResult result(this);
11405         callOperation(operationRegExpTest, result.gpr(), globalObjectGPR, baseGPR, argumentRegs);
11406         m_jit.exceptionCheck();
11407 
11408         unblessedBooleanResult(result.gpr(), node);
11409         return;
11410     }
11411 
11412     JSValueOperand base(this, node-&gt;child2());
11413     JSValueOperand argument(this, node-&gt;child3());
11414     JSValueRegs baseRegs = base.jsValueRegs();
11415     JSValueRegs argumentRegs = argument.jsValueRegs();
11416 
11417     flushRegisters();
11418     GPRFlushedCallResult result(this);
11419     callOperation(operationRegExpTestGeneric, result.gpr(), globalObjectGPR, baseRegs, argumentRegs);
11420     m_jit.exceptionCheck();
11421 
11422     unblessedBooleanResult(result.gpr(), node);
11423 }
11424 
11425 void SpeculativeJIT::compileStringReplace(Node* node)
11426 {
11427     ASSERT(node-&gt;op() == StringReplace || node-&gt;op() == StringReplaceRegExp);
11428     bool sample = false;
11429     if (sample)
11430         m_jit.incrementSuperSamplerCount();
11431 
11432     if (node-&gt;child1().useKind() == StringUse
11433         &amp;&amp; node-&gt;child2().useKind() == RegExpObjectUse
11434         &amp;&amp; node-&gt;child3().useKind() == StringUse) {
<a name="140" id="anc140"></a><span class="line-modified">11435         if (JSString* replace = node-&gt;child3()-&gt;dynamicCastConstant&lt;JSString*&gt;(vm())) {</span>
11436             if (!replace-&gt;length()) {
11437                 SpeculateCellOperand string(this, node-&gt;child1());
11438                 SpeculateCellOperand regExp(this, node-&gt;child2());
11439                 GPRReg stringGPR = string.gpr();
11440                 GPRReg regExpGPR = regExp.gpr();
11441                 speculateString(node-&gt;child1(), stringGPR);
11442                 speculateRegExpObject(node-&gt;child2(), regExpGPR);
11443 
11444                 flushRegisters();
11445                 GPRFlushedCallResult result(this);
11446                 callOperation(operationStringProtoFuncReplaceRegExpEmptyStr, result.gpr(), stringGPR, regExpGPR);
11447                 m_jit.exceptionCheck();
11448                 cellResult(result.gpr(), node);
11449                 if (sample)
11450                     m_jit.decrementSuperSamplerCount();
11451                 return;
11452             }
11453         }
11454 
11455         SpeculateCellOperand string(this, node-&gt;child1());
11456         SpeculateCellOperand regExp(this, node-&gt;child2());
11457         SpeculateCellOperand replace(this, node-&gt;child3());
11458         GPRReg stringGPR = string.gpr();
11459         GPRReg regExpGPR = regExp.gpr();
11460         GPRReg replaceGPR = replace.gpr();
11461         speculateString(node-&gt;child1(), stringGPR);
11462         speculateRegExpObject(node-&gt;child2(), regExpGPR);
11463         speculateString(node-&gt;child3(), replaceGPR);
11464 
11465         flushRegisters();
11466         GPRFlushedCallResult result(this);
11467         callOperation(operationStringProtoFuncReplaceRegExpString, result.gpr(), stringGPR, regExpGPR, replaceGPR);
11468         m_jit.exceptionCheck();
11469         cellResult(result.gpr(), node);
11470         if (sample)
11471             m_jit.decrementSuperSamplerCount();
11472         return;
11473     }
11474 
11475     // If we fixed up the edge of child2, we inserted a Check(@child2, String).
11476     OperandSpeculationMode child2SpeculationMode = AutomaticOperandSpeculation;
11477     if (node-&gt;child2().useKind() == StringUse)
11478         child2SpeculationMode = ManualOperandSpeculation;
11479 
11480     JSValueOperand string(this, node-&gt;child1());
11481     JSValueOperand search(this, node-&gt;child2(), child2SpeculationMode);
11482     JSValueOperand replace(this, node-&gt;child3());
11483     JSValueRegs stringRegs = string.jsValueRegs();
11484     JSValueRegs searchRegs = search.jsValueRegs();
11485     JSValueRegs replaceRegs = replace.jsValueRegs();
11486 
11487     flushRegisters();
11488     GPRFlushedCallResult result(this);
11489     callOperation(operationStringProtoFuncReplaceGeneric, result.gpr(), stringRegs, searchRegs, replaceRegs);
11490     m_jit.exceptionCheck();
11491     cellResult(result.gpr(), node);
11492     if (sample)
11493         m_jit.decrementSuperSamplerCount();
11494 }
11495 
11496 void SpeculativeJIT::compileRegExpExecNonGlobalOrSticky(Node* node)
11497 {
11498     SpeculateCellOperand globalObject(this, node-&gt;child1());
11499     SpeculateCellOperand argument(this, node-&gt;child2());
11500     GPRReg globalObjectGPR = globalObject.gpr();
11501     GPRReg argumentGPR = argument.gpr();
11502 
11503     speculateString(node-&gt;child2(), argumentGPR);
11504 
11505     flushRegisters();
11506     JSValueRegsFlushedCallResult result(this);
11507     JSValueRegs resultRegs = result.regs();
11508     callOperation(
11509         operationRegExpExecNonGlobalOrSticky, resultRegs,
11510         globalObjectGPR, TrustedImmPtr(node-&gt;cellOperand()), argumentGPR);
11511     m_jit.exceptionCheck();
11512 
11513     jsValueResult(resultRegs, node);
11514 }
11515 
11516 void SpeculativeJIT::compileRegExpMatchFastGlobal(Node* node)
11517 {
11518     SpeculateCellOperand globalObject(this, node-&gt;child1());
11519     SpeculateCellOperand argument(this, node-&gt;child2());
11520     GPRReg globalObjectGPR = globalObject.gpr();
11521     GPRReg argumentGPR = argument.gpr();
11522 
11523     speculateString(node-&gt;child2(), argumentGPR);
11524 
11525     flushRegisters();
11526     JSValueRegsFlushedCallResult result(this);
11527     JSValueRegs resultRegs = result.regs();
11528     callOperation(
11529         operationRegExpMatchFastGlobalString, resultRegs,
11530         globalObjectGPR, TrustedImmPtr(node-&gt;cellOperand()), argumentGPR);
11531     m_jit.exceptionCheck();
11532 
11533     jsValueResult(resultRegs, node);
11534 }
11535 
11536 void SpeculativeJIT::compileRegExpMatchFast(Node* node)
11537 {
11538     SpeculateCellOperand globalObject(this, node-&gt;child1());
11539     SpeculateCellOperand base(this, node-&gt;child2());
11540     SpeculateCellOperand argument(this, node-&gt;child3());
11541     GPRReg globalObjectGPR = globalObject.gpr();
11542     GPRReg baseGPR = base.gpr();
11543     GPRReg argumentGPR = argument.gpr();
11544     speculateRegExpObject(node-&gt;child2(), baseGPR);
11545     speculateString(node-&gt;child3(), argumentGPR);
11546 
11547     flushRegisters();
11548     JSValueRegsFlushedCallResult result(this);
11549     JSValueRegs resultRegs = result.regs();
11550     callOperation(
11551         operationRegExpMatchFastString, resultRegs,
11552         globalObjectGPR, baseGPR, argumentGPR);
11553     m_jit.exceptionCheck();
11554 
11555     jsValueResult(resultRegs, node);
11556 }
11557 
11558 void SpeculativeJIT::compileLazyJSConstant(Node* node)
11559 {
11560     JSValueRegsTemporary result(this);
11561     JSValueRegs resultRegs = result.regs();
11562     node-&gt;lazyJSValue().emit(m_jit, resultRegs);
11563     jsValueResult(resultRegs, node);
11564 }
11565 
11566 void SpeculativeJIT::compileMaterializeNewObject(Node* node)
11567 {
11568     RegisteredStructure structure = node-&gt;structureSet().at(0);
<a name="141" id="anc141"></a><span class="line-modified">11569     ASSERT(m_jit.graph().varArgChild(node, 0)-&gt;dynamicCastConstant&lt;Structure*&gt;(vm()) == structure.get());</span>
11570 
11571     ObjectMaterializationData&amp; data = node-&gt;objectMaterializationData();
11572 
11573     IndexingType indexingType = structure-&gt;indexingType();
11574     bool hasIndexingHeader = hasIndexedProperties(indexingType);
11575     int32_t publicLength = 0;
11576     int32_t vectorLength = 0;
11577 
11578     if (hasIndexingHeader) {
11579         for (unsigned i = data.m_properties.size(); i--;) {
11580             Edge edge = m_jit.graph().varArgChild(node, 1 + i);
11581             switch (data.m_properties[i].kind()) {
11582             case PublicLengthPLoc:
11583                 publicLength = edge-&gt;asInt32();
11584                 break;
11585             case VectorLengthPLoc:
11586                 vectorLength = edge-&gt;asInt32();
11587                 break;
11588             default:
11589                 break;
11590             }
11591         }
11592     }
11593 
11594     GPRTemporary result(this);
11595     GPRTemporary storage(this);
11596     GPRReg resultGPR = result.gpr();
11597     GPRReg storageGPR = storage.gpr();
11598 
11599     emitAllocateRawObject(resultGPR, structure, storageGPR, 0, vectorLength);
11600 
11601     m_jit.store32(
11602         JITCompiler::TrustedImm32(publicLength),
11603         JITCompiler::Address(storageGPR, Butterfly::offsetOfPublicLength()));
11604 
11605     for (unsigned i = data.m_properties.size(); i--;) {
11606         Edge edge = m_jit.graph().varArgChild(node, 1 + i);
11607         PromotedLocationDescriptor descriptor = data.m_properties[i];
11608         switch (descriptor.kind()) {
11609         case IndexedPropertyPLoc: {
11610             JSValueOperand value(this, edge);
11611             m_jit.storeValue(
11612                 value.jsValueRegs(),
11613                 JITCompiler::Address(storageGPR, sizeof(EncodedJSValue) * descriptor.info()));
11614             break;
11615         }
11616 
11617         case NamedPropertyPLoc: {
11618             StringImpl* uid = m_jit.graph().identifiers()[descriptor.info()];
11619             for (PropertyMapEntry entry : structure-&gt;getPropertiesConcurrently()) {
11620                 if (uid != entry.key)
11621                     continue;
11622 
11623                 JSValueOperand value(this, edge);
11624                 GPRReg baseGPR = isInlineOffset(entry.offset) ? resultGPR : storageGPR;
11625                 m_jit.storeValue(
11626                     value.jsValueRegs(),
11627                     JITCompiler::Address(baseGPR, offsetRelativeToBase(entry.offset)));
11628             }
11629             break;
11630         }
11631 
11632         default:
11633             break;
11634         }
11635     }
11636 
11637     cellResult(resultGPR, node);
11638 }
11639 
11640 void SpeculativeJIT::compileRecordRegExpCachedResult(Node* node)
11641 {
11642     Edge globalObjectEdge = m_jit.graph().varArgChild(node, 0);
11643     Edge regExpEdge = m_jit.graph().varArgChild(node, 1);
11644     Edge stringEdge = m_jit.graph().varArgChild(node, 2);
11645     Edge startEdge = m_jit.graph().varArgChild(node, 3);
11646     Edge endEdge = m_jit.graph().varArgChild(node, 4);
11647 
11648     SpeculateCellOperand globalObject(this, globalObjectEdge);
11649     SpeculateCellOperand regExp(this, regExpEdge);
11650     SpeculateCellOperand string(this, stringEdge);
11651     SpeculateInt32Operand start(this, startEdge);
11652     SpeculateInt32Operand end(this, endEdge);
11653 
11654     GPRReg globalObjectGPR = globalObject.gpr();
11655     GPRReg regExpGPR = regExp.gpr();
11656     GPRReg stringGPR = string.gpr();
11657     GPRReg startGPR = start.gpr();
11658     GPRReg endGPR = end.gpr();
11659 
11660     ptrdiff_t offset = JSGlobalObject::regExpGlobalDataOffset() + RegExpGlobalData::offsetOfCachedResult();
11661 
11662     m_jit.storePtr(
11663         regExpGPR,
11664         JITCompiler::Address(globalObjectGPR, offset + RegExpCachedResult::offsetOfLastRegExp()));
11665     m_jit.storePtr(
11666         stringGPR,
11667         JITCompiler::Address(globalObjectGPR, offset + RegExpCachedResult::offsetOfLastInput()));
11668     m_jit.store32(
11669         startGPR,
11670         JITCompiler::Address(
11671             globalObjectGPR,
11672             offset + RegExpCachedResult::offsetOfResult() + OBJECT_OFFSETOF(MatchResult, start)));
11673     m_jit.store32(
11674         endGPR,
11675         JITCompiler::Address(
11676             globalObjectGPR,
11677             offset + RegExpCachedResult::offsetOfResult() + OBJECT_OFFSETOF(MatchResult, end)));
11678     m_jit.store8(
11679         TrustedImm32(0),
11680         JITCompiler::Address(globalObjectGPR, offset + RegExpCachedResult::offsetOfReified()));
11681 
11682     noResult(node);
11683 }
11684 
11685 void SpeculativeJIT::compileDefineDataProperty(Node* node)
11686 {
11687 #if USE(JSVALUE64)
11688     static_assert(GPRInfo::numberOfRegisters &gt;= 5, &quot;We are assuming we have enough registers to make this call without incrementally setting up the arguments.&quot;);
11689 #else
11690     static_assert(GPRInfo::numberOfRegisters &gt;= 6, &quot;We are assuming we have enough registers to make this call without incrementally setting up the arguments.&quot;);
11691 #endif
11692 
11693     SpeculateCellOperand base(this, m_jit.graph().varArgChild(node, 0));
11694     GPRReg baseGPR = base.gpr();
11695 
11696     JSValueOperand value(this, m_jit.graph().varArgChild(node, 2));
11697     JSValueRegs valueRegs = value.jsValueRegs();
11698 
11699     SpeculateInt32Operand attributes(this, m_jit.graph().varArgChild(node, 3));
11700     GPRReg attributesGPR = attributes.gpr();
11701 
11702     Edge&amp; propertyEdge = m_jit.graph().varArgChild(node, 1);
11703     switch (propertyEdge.useKind()) {
11704     case StringUse: {
11705         SpeculateCellOperand property(this, propertyEdge);
11706         GPRReg propertyGPR = property.gpr();
11707         speculateString(propertyEdge, propertyGPR);
11708 
11709         useChildren(node);
11710 
11711         flushRegisters();
11712         callOperation(operationDefineDataPropertyString, NoResult, baseGPR, propertyGPR, valueRegs, attributesGPR);
11713         m_jit.exceptionCheck();
11714         break;
11715     }
11716     case StringIdentUse: {
11717         SpeculateCellOperand property(this, propertyEdge);
11718         GPRTemporary ident(this);
11719 
11720         GPRReg propertyGPR = property.gpr();
11721         GPRReg identGPR = ident.gpr();
11722 
11723         speculateString(propertyEdge, propertyGPR);
11724         speculateStringIdentAndLoadStorage(propertyEdge, propertyGPR, identGPR);
11725 
11726         useChildren(node);
11727 
11728         flushRegisters();
11729         callOperation(operationDefineDataPropertyStringIdent, NoResult, baseGPR, identGPR, valueRegs, attributesGPR);
11730         m_jit.exceptionCheck();
11731         break;
11732     }
11733     case SymbolUse: {
11734         SpeculateCellOperand property(this, propertyEdge);
11735         GPRReg propertyGPR = property.gpr();
11736         speculateSymbol(propertyEdge, propertyGPR);
11737 
11738         useChildren(node);
11739 
11740         flushRegisters();
11741         callOperation(operationDefineDataPropertySymbol, NoResult, baseGPR, propertyGPR, valueRegs, attributesGPR);
11742         m_jit.exceptionCheck();
11743         break;
11744     }
11745     case UntypedUse: {
11746         JSValueOperand property(this, propertyEdge);
11747         JSValueRegs propertyRegs = property.jsValueRegs();
11748 
11749         useChildren(node);
11750 
11751         flushRegisters();
11752         callOperation(operationDefineDataProperty, NoResult, baseGPR, propertyRegs, valueRegs, attributesGPR);
11753         m_jit.exceptionCheck();
11754         break;
11755     }
11756     default:
11757         RELEASE_ASSERT_NOT_REACHED();
11758     }
11759 
11760     noResult(node, UseChildrenCalledExplicitly);
11761 }
11762 
11763 void SpeculativeJIT::compileDefineAccessorProperty(Node* node)
11764 {
11765 #if USE(JSVALUE64)
11766     static_assert(GPRInfo::numberOfRegisters &gt;= 5, &quot;We are assuming we have enough registers to make this call without incrementally setting up the arguments.&quot;);
11767 #else
11768     static_assert(GPRInfo::numberOfRegisters &gt;= 6, &quot;We are assuming we have enough registers to make this call without incrementally setting up the arguments.&quot;);
11769 #endif
11770 
11771     SpeculateCellOperand base(this, m_jit.graph().varArgChild(node, 0));
11772     GPRReg baseGPR = base.gpr();
11773 
11774     SpeculateCellOperand getter(this, m_jit.graph().varArgChild(node, 2));
11775     GPRReg getterGPR = getter.gpr();
11776 
11777     SpeculateCellOperand setter(this, m_jit.graph().varArgChild(node, 3));
11778     GPRReg setterGPR = setter.gpr();
11779 
11780     SpeculateInt32Operand attributes(this, m_jit.graph().varArgChild(node, 4));
11781     GPRReg attributesGPR = attributes.gpr();
11782 
11783     Edge&amp; propertyEdge = m_jit.graph().varArgChild(node, 1);
11784     switch (propertyEdge.useKind()) {
11785     case StringUse: {
11786         SpeculateCellOperand property(this, propertyEdge);
11787         GPRReg propertyGPR = property.gpr();
11788         speculateString(propertyEdge, propertyGPR);
11789 
11790         useChildren(node);
11791 
11792         flushRegisters();
11793         callOperation(operationDefineAccessorPropertyString, NoResult, baseGPR, propertyGPR, getterGPR, setterGPR, attributesGPR);
11794         m_jit.exceptionCheck();
11795         break;
11796     }
11797     case StringIdentUse: {
11798         SpeculateCellOperand property(this, propertyEdge);
11799         GPRTemporary ident(this);
11800 
11801         GPRReg propertyGPR = property.gpr();
11802         GPRReg identGPR = ident.gpr();
11803 
11804         speculateString(propertyEdge, propertyGPR);
11805         speculateStringIdentAndLoadStorage(propertyEdge, propertyGPR, identGPR);
11806 
11807         useChildren(node);
11808 
11809         flushRegisters();
11810         callOperation(operationDefineAccessorPropertyStringIdent, NoResult, baseGPR, identGPR, getterGPR, setterGPR, attributesGPR);
11811         m_jit.exceptionCheck();
11812         break;
11813     }
11814     case SymbolUse: {
11815         SpeculateCellOperand property(this, propertyEdge);
11816         GPRReg propertyGPR = property.gpr();
11817         speculateSymbol(propertyEdge, propertyGPR);
11818 
11819         useChildren(node);
11820 
11821         flushRegisters();
11822         callOperation(operationDefineAccessorPropertySymbol, NoResult, baseGPR, propertyGPR, getterGPR, setterGPR, attributesGPR);
11823         m_jit.exceptionCheck();
11824         break;
11825     }
11826     case UntypedUse: {
11827         JSValueOperand property(this, propertyEdge);
11828         JSValueRegs propertyRegs = property.jsValueRegs();
11829 
11830         useChildren(node);
11831 
11832         flushRegisters();
11833         callOperation(operationDefineAccessorProperty, NoResult, baseGPR, propertyRegs, getterGPR, setterGPR, attributesGPR);
11834         m_jit.exceptionCheck();
11835         break;
11836     }
11837     default:
11838         RELEASE_ASSERT_NOT_REACHED();
11839     }
11840 
11841     noResult(node, UseChildrenCalledExplicitly);
11842 }
11843 
11844 void SpeculativeJIT::emitAllocateButterfly(GPRReg storageResultGPR, GPRReg sizeGPR, GPRReg scratch1, GPRReg scratch2, GPRReg scratch3, MacroAssembler::JumpList&amp; slowCases)
11845 {
11846     RELEASE_ASSERT(RegisterSet(storageResultGPR, sizeGPR, scratch1, scratch2, scratch3).numberOfSetGPRs() == 5);
11847     ASSERT((1 &lt;&lt; 3) == sizeof(JSValue));
11848     m_jit.zeroExtend32ToPtr(sizeGPR, scratch1);
11849     m_jit.lshift32(TrustedImm32(3), scratch1);
11850     m_jit.add32(TrustedImm32(sizeof(IndexingHeader)), scratch1, scratch2);
11851 #if !ASSERT_DISABLED
11852     MacroAssembler::Jump didNotOverflow = m_jit.branch32(MacroAssembler::AboveOrEqual, scratch2, sizeGPR);
11853     m_jit.abortWithReason(UncheckedOverflow);
11854     didNotOverflow.link(&amp;m_jit);
11855 #endif
11856     m_jit.emitAllocateVariableSized(
<a name="142" id="anc142"></a><span class="line-modified">11857         storageResultGPR, vm().jsValueGigacageAuxiliarySpace, scratch2, scratch1, scratch3, slowCases);</span>
11858     m_jit.addPtr(TrustedImm32(sizeof(IndexingHeader)), storageResultGPR);
11859 
11860     m_jit.store32(sizeGPR, MacroAssembler::Address(storageResultGPR, Butterfly::offsetOfPublicLength()));
11861     m_jit.store32(sizeGPR, MacroAssembler::Address(storageResultGPR, Butterfly::offsetOfVectorLength()));
11862 }
11863 
11864 void SpeculativeJIT::compileNormalizeMapKey(Node* node)
11865 {
11866     ASSERT(node-&gt;child1().useKind() == UntypedUse);
11867     JSValueOperand key(this, node-&gt;child1());
11868     JSValueRegsTemporary result(this, Reuse, key);
11869     GPRTemporary scratch(this);
11870     FPRTemporary doubleValue(this);
11871     FPRTemporary temp(this);
11872 
11873     JSValueRegs keyRegs = key.jsValueRegs();
11874     JSValueRegs resultRegs = result.regs();
11875     GPRReg scratchGPR = scratch.gpr();
11876     FPRReg doubleValueFPR = doubleValue.fpr();
11877     FPRReg tempFPR = temp.fpr();
11878 
11879     CCallHelpers::JumpList passThroughCases;
<a name="143" id="anc143"></a><span class="line-added">11880     CCallHelpers::JumpList doneCases;</span>
11881 
11882     passThroughCases.append(m_jit.branchIfNotNumber(keyRegs, scratchGPR));
11883     passThroughCases.append(m_jit.branchIfInt32(keyRegs));
11884 
11885 #if USE(JSVALUE64)
11886     m_jit.unboxDoubleWithoutAssertions(keyRegs.gpr(), scratchGPR, doubleValueFPR);
11887 #else
11888     unboxDouble(keyRegs.tagGPR(), keyRegs.payloadGPR(), doubleValueFPR, tempFPR);
11889 #endif
<a name="144" id="anc144"></a><span class="line-modified">11890     auto notNaN = m_jit.branchIfNotNaN(doubleValueFPR);</span>
<span class="line-added">11891     m_jit.moveTrustedValue(jsNaN(), resultRegs);</span>
<span class="line-added">11892     doneCases.append(m_jit.jump());</span>
11893 
<a name="145" id="anc145"></a><span class="line-added">11894     notNaN.link(&amp;m_jit);</span>
11895     m_jit.truncateDoubleToInt32(doubleValueFPR, scratchGPR);
11896     m_jit.convertInt32ToDouble(scratchGPR, tempFPR);
11897     passThroughCases.append(m_jit.branchDouble(JITCompiler::DoubleNotEqual, doubleValueFPR, tempFPR));
11898 
11899     m_jit.boxInt32(scratchGPR, resultRegs);
<a name="146" id="anc146"></a><span class="line-modified">11900     doneCases.append(m_jit.jump());</span>
11901 
11902     passThroughCases.link(&amp;m_jit);
11903     m_jit.moveValueRegs(keyRegs, resultRegs);
11904 
<a name="147" id="anc147"></a><span class="line-modified">11905     doneCases.link(&amp;m_jit);</span>
11906     jsValueResult(resultRegs, node);
11907 }
11908 
11909 void SpeculativeJIT::compileGetMapBucketHead(Node* node)
11910 {
11911     SpeculateCellOperand map(this, node-&gt;child1());
11912     GPRTemporary bucket(this);
11913 
11914     GPRReg mapGPR = map.gpr();
11915     GPRReg bucketGPR = bucket.gpr();
11916 
11917     if (node-&gt;child1().useKind() == MapObjectUse)
11918         speculateMapObject(node-&gt;child1(), mapGPR);
11919     else if (node-&gt;child1().useKind() == SetObjectUse)
11920         speculateSetObject(node-&gt;child1(), mapGPR);
11921     else
11922         RELEASE_ASSERT_NOT_REACHED();
11923 
11924     ASSERT(HashMapImpl&lt;HashMapBucket&lt;HashMapBucketDataKey&gt;&gt;::offsetOfHead() == HashMapImpl&lt;HashMapBucket&lt;HashMapBucketDataKeyValue&gt;&gt;::offsetOfHead());
11925     m_jit.loadPtr(MacroAssembler::Address(mapGPR, HashMapImpl&lt;HashMapBucket&lt;HashMapBucketDataKey&gt;&gt;::offsetOfHead()), bucketGPR);
11926     cellResult(bucketGPR, node);
11927 }
11928 
11929 void SpeculativeJIT::compileGetMapBucketNext(Node* node)
11930 {
11931     SpeculateCellOperand bucket(this, node-&gt;child1());
11932     GPRTemporary result(this);
11933 
11934     GPRReg bucketGPR = bucket.gpr();
11935     GPRReg resultGPR = result.gpr();
11936 
11937     ASSERT(HashMapBucket&lt;HashMapBucketDataKey&gt;::offsetOfNext() == HashMapBucket&lt;HashMapBucketDataKeyValue&gt;::offsetOfNext());
11938     ASSERT(HashMapBucket&lt;HashMapBucketDataKey&gt;::offsetOfKey() == HashMapBucket&lt;HashMapBucketDataKeyValue&gt;::offsetOfKey());
11939     m_jit.loadPtr(MacroAssembler::Address(bucketGPR, HashMapBucket&lt;HashMapBucketDataKeyValue&gt;::offsetOfNext()), resultGPR);
11940 
11941     MacroAssembler::Label loop = m_jit.label();
11942     auto notBucket = m_jit.branchTestPtr(MacroAssembler::Zero, resultGPR);
11943 #if USE(JSVALUE32_64)
11944     auto done = m_jit.branch32(MacroAssembler::NotEqual, MacroAssembler::Address(resultGPR, HashMapBucket&lt;HashMapBucketDataKeyValue&gt;::offsetOfKey() + TagOffset), TrustedImm32(JSValue::EmptyValueTag));
11945 #else
11946     auto done = m_jit.branchTest64(MacroAssembler::NonZero, MacroAssembler::Address(resultGPR, HashMapBucket&lt;HashMapBucketDataKeyValue&gt;::offsetOfKey()));
11947 #endif
11948     m_jit.loadPtr(MacroAssembler::Address(resultGPR, HashMapBucket&lt;HashMapBucketDataKeyValue&gt;::offsetOfNext()), resultGPR);
11949     m_jit.jump().linkTo(loop, &amp;m_jit);
11950 
11951     notBucket.link(&amp;m_jit);
11952     JSCell* sentinel = nullptr;
11953     if (node-&gt;bucketOwnerType() == BucketOwnerType::Map)
<a name="148" id="anc148"></a><span class="line-modified">11954         sentinel = vm().sentinelMapBucket();</span>
11955     else {
11956         ASSERT(node-&gt;bucketOwnerType() == BucketOwnerType::Set);
<a name="149" id="anc149"></a><span class="line-modified">11957         sentinel = vm().sentinelSetBucket();</span>
11958     }
11959     m_jit.move(TrustedImmPtr::weakPointer(m_jit.graph(), sentinel), resultGPR);
11960     done.link(&amp;m_jit);
11961 
11962     cellResult(resultGPR, node);
11963 }
11964 
11965 void SpeculativeJIT::compileLoadKeyFromMapBucket(Node* node)
11966 {
11967     SpeculateCellOperand bucket(this, node-&gt;child1());
11968     JSValueRegsTemporary result(this);
11969 
11970     GPRReg bucketGPR = bucket.gpr();
11971     JSValueRegs resultRegs = result.regs();
11972 
11973     m_jit.loadValue(MacroAssembler::Address(bucketGPR, HashMapBucket&lt;HashMapBucketDataKeyValue&gt;::offsetOfKey()), resultRegs);
11974     jsValueResult(resultRegs, node);
11975 }
11976 
11977 void SpeculativeJIT::compileLoadValueFromMapBucket(Node* node)
11978 {
11979     SpeculateCellOperand bucket(this, node-&gt;child1());
11980     JSValueRegsTemporary result(this);
11981 
11982     GPRReg bucketGPR = bucket.gpr();
11983     JSValueRegs resultRegs = result.regs();
11984 
11985     m_jit.loadValue(MacroAssembler::Address(bucketGPR, HashMapBucket&lt;HashMapBucketDataKeyValue&gt;::offsetOfValue()), resultRegs);
11986     jsValueResult(resultRegs, node);
11987 }
11988 
11989 void SpeculativeJIT::compileExtractValueFromWeakMapGet(Node* node)
11990 {
11991     JSValueOperand value(this, node-&gt;child1());
11992     JSValueRegsTemporary result(this, Reuse, value);
11993 
11994     JSValueRegs valueRegs = value.jsValueRegs();
11995     JSValueRegs resultRegs = result.regs();
11996 
11997 #if USE(JSVALUE64)
11998     m_jit.moveValueRegs(valueRegs, resultRegs);
11999     auto done = m_jit.branchTestPtr(CCallHelpers::NonZero, resultRegs.payloadGPR());
12000     m_jit.moveValue(jsUndefined(), resultRegs);
12001     done.link(&amp;m_jit);
12002 #else
12003     auto isEmpty = m_jit.branchIfEmpty(valueRegs.tagGPR());
12004     m_jit.moveValueRegs(valueRegs, resultRegs);
12005     auto done = m_jit.jump();
12006 
12007     isEmpty.link(&amp;m_jit);
12008     m_jit.moveValue(jsUndefined(), resultRegs);
12009 
12010     done.link(&amp;m_jit);
12011 #endif
12012 
12013     jsValueResult(resultRegs, node, DataFormatJS);
12014 }
12015 
12016 void SpeculativeJIT::compileThrow(Node* node)
12017 {
12018     JSValueOperand value(this, node-&gt;child1());
12019     JSValueRegs valueRegs = value.jsValueRegs();
12020     flushRegisters();
12021     callOperation(operationThrowDFG, valueRegs);
12022     m_jit.exceptionCheck();
12023     m_jit.breakpoint();
12024     noResult(node);
12025 }
12026 
12027 void SpeculativeJIT::compileThrowStaticError(Node* node)
12028 {
12029     SpeculateCellOperand message(this, node-&gt;child1());
12030     GPRReg messageGPR = message.gpr();
12031     speculateString(node-&gt;child1(), messageGPR);
12032     flushRegisters();
12033     callOperation(operationThrowStaticError, messageGPR, node-&gt;errorType());
12034     m_jit.exceptionCheck();
12035     m_jit.breakpoint();
12036     noResult(node);
12037 }
12038 
12039 void SpeculativeJIT::compileGetEnumerableLength(Node* node)
12040 {
12041     SpeculateCellOperand enumerator(this, node-&gt;child1());
12042     GPRFlushedCallResult result(this);
12043     GPRReg resultGPR = result.gpr();
12044 
12045     m_jit.load32(MacroAssembler::Address(enumerator.gpr(), JSPropertyNameEnumerator::indexedLengthOffset()), resultGPR);
12046     int32Result(resultGPR, node);
12047 }
12048 
12049 void SpeculativeJIT::compileHasGenericProperty(Node* node)
12050 {
12051     JSValueOperand base(this, node-&gt;child1());
12052     SpeculateCellOperand property(this, node-&gt;child2());
12053 
12054     JSValueRegs baseRegs = base.jsValueRegs();
12055     GPRReg propertyGPR = property.gpr();
12056 
12057     flushRegisters();
12058     JSValueRegsFlushedCallResult result(this);
12059     JSValueRegs resultRegs = result.regs();
12060     callOperation(operationHasGenericProperty, resultRegs, baseRegs, propertyGPR);
12061     m_jit.exceptionCheck();
12062     blessedBooleanResult(resultRegs.payloadGPR(), node);
12063 }
12064 
12065 void SpeculativeJIT::compileToIndexString(Node* node)
12066 {
12067     SpeculateInt32Operand index(this, node-&gt;child1());
12068     GPRReg indexGPR = index.gpr();
12069 
12070     flushRegisters();
12071     GPRFlushedCallResult result(this);
12072     GPRReg resultGPR = result.gpr();
12073     callOperation(operationToIndexString, resultGPR, indexGPR);
12074     m_jit.exceptionCheck();
12075     cellResult(resultGPR, node);
12076 }
12077 
12078 void SpeculativeJIT::compilePutByIdFlush(Node* node)
12079 {
12080     SpeculateCellOperand base(this, node-&gt;child1());
12081     JSValueOperand value(this, node-&gt;child2());
12082     GPRTemporary scratch(this);
12083 
12084     GPRReg baseGPR = base.gpr();
12085     JSValueRegs valueRegs = value.jsValueRegs();
12086     GPRReg scratchGPR = scratch.gpr();
12087     flushRegisters();
12088 
12089     cachedPutById(node-&gt;origin.semantic, baseGPR, valueRegs, scratchGPR, node-&gt;identifierNumber(), NotDirect, MacroAssembler::Jump(), DontSpill);
12090 
12091     noResult(node);
12092 }
12093 
12094 void SpeculativeJIT::compilePutById(Node* node)
12095 {
12096     SpeculateCellOperand base(this, node-&gt;child1());
12097     JSValueOperand value(this, node-&gt;child2());
12098     GPRTemporary scratch(this);
12099 
12100     GPRReg baseGPR = base.gpr();
12101     JSValueRegs valueRegs = value.jsValueRegs();
12102     GPRReg scratchGPR = scratch.gpr();
12103 
12104     cachedPutById(node-&gt;origin.semantic, baseGPR, valueRegs, scratchGPR, node-&gt;identifierNumber(), NotDirect);
12105 
12106     noResult(node);
12107 }
12108 
12109 void SpeculativeJIT::compilePutByIdDirect(Node* node)
12110 {
12111     SpeculateCellOperand base(this, node-&gt;child1());
12112     JSValueOperand value(this, node-&gt;child2());
12113     GPRTemporary scratch(this);
12114 
12115     GPRReg baseGPR = base.gpr();
12116     JSValueRegs valueRegs = value.jsValueRegs();
12117     GPRReg scratchGPR = scratch.gpr();
12118 
12119     cachedPutById(node-&gt;origin.semantic, baseGPR, valueRegs, scratchGPR, node-&gt;identifierNumber(), Direct);
12120 
12121     noResult(node);
12122 }
12123 
12124 void SpeculativeJIT::compilePutByIdWithThis(Node* node)
12125 {
12126     JSValueOperand base(this, node-&gt;child1());
12127     JSValueRegs baseRegs = base.jsValueRegs();
12128     JSValueOperand thisValue(this, node-&gt;child2());
12129     JSValueRegs thisRegs = thisValue.jsValueRegs();
12130     JSValueOperand value(this, node-&gt;child3());
12131     JSValueRegs valueRegs = value.jsValueRegs();
12132 
12133     flushRegisters();
12134     callOperation(m_jit.isStrictModeFor(node-&gt;origin.semantic) ? operationPutByIdWithThisStrict : operationPutByIdWithThis,
12135         NoResult, baseRegs, thisRegs, valueRegs, identifierUID(node-&gt;identifierNumber()));
12136     m_jit.exceptionCheck();
12137 
12138     noResult(node);
12139 }
12140 
12141 void SpeculativeJIT::compileGetByOffset(Node* node)
12142 {
12143     StorageOperand storage(this, node-&gt;child1());
12144     JSValueRegsTemporary result(this, Reuse, storage);
12145 
12146     GPRReg storageGPR = storage.gpr();
12147     JSValueRegs resultRegs = result.regs();
12148 
12149     StorageAccessData&amp; storageAccessData = node-&gt;storageAccessData();
12150 
12151     m_jit.loadValue(JITCompiler::Address(storageGPR, offsetRelativeToBase(storageAccessData.offset)), resultRegs);
12152 
12153     jsValueResult(resultRegs, node);
12154 }
12155 
12156 void SpeculativeJIT::compilePutByOffset(Node* node)
12157 {
12158     StorageOperand storage(this, node-&gt;child1());
12159     JSValueOperand value(this, node-&gt;child3());
12160 
12161     GPRReg storageGPR = storage.gpr();
12162     JSValueRegs valueRegs = value.jsValueRegs();
12163 
12164     speculate(node, node-&gt;child2());
12165 
12166     StorageAccessData&amp; storageAccessData = node-&gt;storageAccessData();
12167 
12168     m_jit.storeValue(valueRegs, JITCompiler::Address(storageGPR, offsetRelativeToBase(storageAccessData.offset)));
12169 
12170     noResult(node);
12171 }
12172 
12173 void SpeculativeJIT::compileMatchStructure(Node* node)
12174 {
12175     SpeculateCellOperand base(this, node-&gt;child1());
12176     GPRTemporary temp(this);
12177     GPRReg baseGPR = base.gpr();
12178     GPRReg tempGPR = temp.gpr();
12179 
12180     m_jit.load32(JITCompiler::Address(baseGPR, JSCell::structureIDOffset()), tempGPR);
12181 
12182     auto&amp; variants = node-&gt;matchStructureData().variants;
12183     Vector&lt;int64_t&gt; cases;
12184     for (MatchStructureVariant&amp; variant : variants)
12185         cases.append(bitwise_cast&lt;int32_t&gt;(variant.structure-&gt;id()));
12186 
12187     BinarySwitch binarySwitch(tempGPR, cases, BinarySwitch::Int32);
12188     JITCompiler::JumpList done;
12189     while (binarySwitch.advance(m_jit)) {
12190         m_jit.boxBooleanPayload(variants[binarySwitch.caseIndex()].result, tempGPR);
12191         done.append(m_jit.jump());
12192     }
12193     speculationCheck(BadCache, JSValueRegs(), node, binarySwitch.fallThrough());
12194 
12195     done.link(&amp;m_jit);
12196 
12197     blessedBooleanResult(tempGPR, node);
12198 }
12199 
12200 void SpeculativeJIT::compileHasStructureProperty(Node* node)
12201 {
12202     JSValueOperand base(this, node-&gt;child1());
12203     SpeculateCellOperand property(this, node-&gt;child2());
12204     SpeculateCellOperand enumerator(this, node-&gt;child3());
12205     JSValueRegsTemporary result(this);
12206 
12207     JSValueRegs baseRegs = base.jsValueRegs();
12208     GPRReg propertyGPR = property.gpr();
12209     JSValueRegs resultRegs = result.regs();
12210 
12211     CCallHelpers::JumpList wrongStructure;
12212 
12213     wrongStructure.append(m_jit.branchIfNotCell(baseRegs));
12214 
12215     m_jit.load32(MacroAssembler::Address(baseRegs.payloadGPR(), JSCell::structureIDOffset()), resultRegs.payloadGPR());
12216     wrongStructure.append(m_jit.branch32(MacroAssembler::NotEqual,
12217         resultRegs.payloadGPR(),
12218         MacroAssembler::Address(enumerator.gpr(), JSPropertyNameEnumerator::cachedStructureIDOffset())));
12219 
12220     moveTrueTo(resultRegs.payloadGPR());
12221     MacroAssembler::Jump done = m_jit.jump();
12222 
12223     done.link(&amp;m_jit);
12224 
12225     addSlowPathGenerator(slowPathCall(wrongStructure, this, operationHasGenericProperty, resultRegs, baseRegs, propertyGPR));
12226     blessedBooleanResult(resultRegs.payloadGPR(), node);
12227 }
12228 
12229 void SpeculativeJIT::compileGetPropertyEnumerator(Node* node)
12230 {
12231     if (node-&gt;child1().useKind() == CellUse) {
12232         SpeculateCellOperand base(this, node-&gt;child1());
12233         GPRReg baseGPR = base.gpr();
12234 
12235         flushRegisters();
12236         GPRFlushedCallResult result(this);
12237         GPRReg resultGPR = result.gpr();
12238         callOperation(operationGetPropertyEnumeratorCell, resultGPR, baseGPR);
12239         m_jit.exceptionCheck();
12240         cellResult(resultGPR, node);
12241         return;
12242     }
12243 
12244     JSValueOperand base(this, node-&gt;child1());
12245     JSValueRegs baseRegs = base.jsValueRegs();
12246 
12247     flushRegisters();
12248     GPRFlushedCallResult result(this);
12249     GPRReg resultGPR = result.gpr();
12250     callOperation(operationGetPropertyEnumerator, resultGPR, baseRegs);
12251     m_jit.exceptionCheck();
12252     cellResult(resultGPR, node);
12253 }
12254 
12255 void SpeculativeJIT::compileGetEnumeratorPname(Node* node)
12256 {
12257     ASSERT(node-&gt;op() == GetEnumeratorStructurePname || node-&gt;op() == GetEnumeratorGenericPname);
12258     SpeculateCellOperand enumerator(this, node-&gt;child1());
12259     SpeculateStrictInt32Operand index(this, node-&gt;child2());
12260     GPRTemporary scratch(this);
12261     JSValueRegsTemporary result(this);
12262 
12263     GPRReg enumeratorGPR = enumerator.gpr();
12264     GPRReg indexGPR = index.gpr();
12265     GPRReg scratchGPR = scratch.gpr();
12266     JSValueRegs resultRegs = result.regs();
12267 
12268     MacroAssembler::Jump inBounds = m_jit.branch32(MacroAssembler::Below, indexGPR,
12269         MacroAssembler::Address(enumeratorGPR, (node-&gt;op() == GetEnumeratorStructurePname)
12270             ? JSPropertyNameEnumerator::endStructurePropertyIndexOffset()
12271             : JSPropertyNameEnumerator::endGenericPropertyIndexOffset()));
12272 
12273     m_jit.moveValue(jsNull(), resultRegs);
12274 
12275     MacroAssembler::Jump done = m_jit.jump();
12276     inBounds.link(&amp;m_jit);
12277 
12278     m_jit.loadPtr(MacroAssembler::Address(enumeratorGPR, JSPropertyNameEnumerator::cachedPropertyNamesVectorOffset()), scratchGPR);
12279     m_jit.loadPtr(MacroAssembler::BaseIndex(scratchGPR, indexGPR, MacroAssembler::ScalePtr), resultRegs.payloadGPR());
12280 #if USE(JSVALUE32_64)
12281     m_jit.move(MacroAssembler::TrustedImm32(JSValue::CellTag), resultRegs.tagGPR());
12282 #endif
12283 
12284     done.link(&amp;m_jit);
12285     jsValueResult(resultRegs, node);
12286 }
12287 
12288 void SpeculativeJIT::compileGetExecutable(Node* node)
12289 {
12290     SpeculateCellOperand function(this, node-&gt;child1());
12291     GPRTemporary result(this, Reuse, function);
12292     GPRReg functionGPR = function.gpr();
12293     GPRReg resultGPR = result.gpr();
12294     speculateCellType(node-&gt;child1(), functionGPR, SpecFunction, JSFunctionType);
12295     m_jit.loadPtr(JITCompiler::Address(functionGPR, JSFunction::offsetOfExecutable()), resultGPR);
12296     cellResult(resultGPR, node);
12297 }
12298 
12299 void SpeculativeJIT::compileGetGetter(Node* node)
12300 {
12301     SpeculateCellOperand op1(this, node-&gt;child1());
12302     GPRTemporary result(this, Reuse, op1);
12303 
12304     GPRReg op1GPR = op1.gpr();
12305     GPRReg resultGPR = result.gpr();
12306 
12307     m_jit.loadPtr(JITCompiler::Address(op1GPR, GetterSetter::offsetOfGetter()), resultGPR);
12308 
12309     cellResult(resultGPR, node);
12310 }
12311 
12312 void SpeculativeJIT::compileGetSetter(Node* node)
12313 {
12314     SpeculateCellOperand op1(this, node-&gt;child1());
12315     GPRTemporary result(this, Reuse, op1);
12316 
12317     GPRReg op1GPR = op1.gpr();
12318     GPRReg resultGPR = result.gpr();
12319 
12320     m_jit.loadPtr(JITCompiler::Address(op1GPR, GetterSetter::offsetOfSetter()), resultGPR);
12321 
12322     cellResult(resultGPR, node);
12323 }
12324 
12325 void SpeculativeJIT::compileGetCallee(Node* node)
12326 {
12327     GPRTemporary result(this);
12328     m_jit.loadPtr(JITCompiler::payloadFor(CallFrameSlot::callee), result.gpr());
12329     cellResult(result.gpr(), node);
12330 }
12331 
12332 void SpeculativeJIT::compileSetCallee(Node* node)
12333 {
12334     SpeculateCellOperand callee(this, node-&gt;child1());
12335     m_jit.storeCell(callee.gpr(), JITCompiler::payloadFor(CallFrameSlot::callee));
12336     noResult(node);
12337 }
12338 
12339 void SpeculativeJIT::compileGetArgumentCountIncludingThis(Node* node)
12340 {
12341     GPRTemporary result(this);
12342     VirtualRegister argumentCountRegister;
12343     if (InlineCallFrame* inlineCallFrame = node-&gt;argumentsInlineCallFrame())
12344         argumentCountRegister = inlineCallFrame-&gt;argumentCountRegister;
12345     else
12346         argumentCountRegister = VirtualRegister(CallFrameSlot::argumentCount);
12347     m_jit.load32(JITCompiler::payloadFor(argumentCountRegister), result.gpr());
12348     int32Result(result.gpr(), node);
12349 }
12350 
12351 void SpeculativeJIT::compileSetArgumentCountIncludingThis(Node* node)
12352 {
12353     m_jit.store32(TrustedImm32(node-&gt;argumentCountIncludingThis()), JITCompiler::payloadFor(CallFrameSlot::argumentCount));
12354     noResult(node);
12355 }
12356 
12357 void SpeculativeJIT::compileStrCat(Node* node)
12358 {
12359     JSValueOperand op1(this, node-&gt;child1(), ManualOperandSpeculation);
12360     JSValueOperand op2(this, node-&gt;child2(), ManualOperandSpeculation);
12361     JSValueOperand op3(this, node-&gt;child3(), ManualOperandSpeculation);
12362 
12363     JSValueRegs op1Regs = op1.jsValueRegs();
12364     JSValueRegs op2Regs = op2.jsValueRegs();
12365     JSValueRegs op3Regs;
12366 
12367     if (node-&gt;child3())
12368         op3Regs = op3.jsValueRegs();
12369 
12370     flushRegisters();
12371 
12372     GPRFlushedCallResult result(this);
12373     if (node-&gt;child3())
12374         callOperation(operationStrCat3, result.gpr(), op1Regs, op2Regs, op3Regs);
12375     else
12376         callOperation(operationStrCat2, result.gpr(), op1Regs, op2Regs);
12377     m_jit.exceptionCheck();
12378 
12379     cellResult(result.gpr(), node);
12380 }
12381 
12382 void SpeculativeJIT::compileNewArrayBuffer(Node* node)
12383 {
12384     JSGlobalObject* globalObject = m_jit.graph().globalObjectFor(node-&gt;origin.semantic);
12385     auto* array = node-&gt;castOperand&lt;JSImmutableButterfly*&gt;();
12386 
12387     IndexingType indexingMode = node-&gt;indexingMode();
12388     RegisteredStructure structure = m_jit.graph().registerStructure(globalObject-&gt;arrayStructureForIndexingTypeDuringAllocation(indexingMode));
12389 
12390     if (!globalObject-&gt;isHavingABadTime() &amp;&amp; !hasAnyArrayStorage(indexingMode)) {
12391         GPRTemporary result(this);
12392         GPRTemporary scratch1(this);
12393         GPRTemporary scratch2(this);
12394 
12395         GPRReg resultGPR = result.gpr();
12396         GPRReg scratch1GPR = scratch1.gpr();
12397         GPRReg scratch2GPR = scratch2.gpr();
12398 
12399         MacroAssembler::JumpList slowCases;
12400 
12401         emitAllocateJSObject&lt;JSArray&gt;(resultGPR, TrustedImmPtr(structure), TrustedImmPtr(array-&gt;toButterfly()), scratch1GPR, scratch2GPR, slowCases);
12402 
12403         addSlowPathGenerator(slowPathCall(slowCases, this, operationNewArrayBuffer, result.gpr(), structure, array));
12404 
12405         DFG_ASSERT(m_jit.graph(), node, indexingMode &amp; IsArray, indexingMode);
12406         cellResult(resultGPR, node);
12407         return;
12408     }
12409 
12410     flushRegisters();
12411     GPRFlushedCallResult result(this);
12412 
12413     callOperation(operationNewArrayBuffer, result.gpr(), structure, TrustedImmPtr(node-&gt;cellOperand()));
12414     m_jit.exceptionCheck();
12415 
12416     cellResult(result.gpr(), node);
12417 }
12418 
12419 void SpeculativeJIT::compileNewArrayWithSize(Node* node)
12420 {
12421     JSGlobalObject* globalObject = m_jit.graph().globalObjectFor(node-&gt;origin.semantic);
12422     if (!globalObject-&gt;isHavingABadTime() &amp;&amp; !hasAnyArrayStorage(node-&gt;indexingType())) {
12423         SpeculateStrictInt32Operand size(this, node-&gt;child1());
12424         GPRTemporary result(this);
12425 
12426         GPRReg sizeGPR = size.gpr();
12427         GPRReg resultGPR = result.gpr();
12428 
12429         compileAllocateNewArrayWithSize(globalObject, resultGPR, sizeGPR, node-&gt;indexingType());
12430         cellResult(resultGPR, node);
12431         return;
12432     }
12433 
12434     SpeculateStrictInt32Operand size(this, node-&gt;child1());
12435     GPRReg sizeGPR = size.gpr();
12436     flushRegisters();
12437     GPRFlushedCallResult result(this);
12438     GPRReg resultGPR = result.gpr();
12439     GPRReg structureGPR = AssemblyHelpers::selectScratchGPR(sizeGPR);
12440     MacroAssembler::Jump bigLength = m_jit.branch32(MacroAssembler::AboveOrEqual, sizeGPR, TrustedImm32(MIN_ARRAY_STORAGE_CONSTRUCTION_LENGTH));
12441     m_jit.move(TrustedImmPtr(m_jit.graph().registerStructure(globalObject-&gt;arrayStructureForIndexingTypeDuringAllocation(node-&gt;indexingType()))), structureGPR);
12442     MacroAssembler::Jump done = m_jit.jump();
12443     bigLength.link(&amp;m_jit);
12444     m_jit.move(TrustedImmPtr(m_jit.graph().registerStructure(globalObject-&gt;arrayStructureForIndexingTypeDuringAllocation(ArrayWithArrayStorage))), structureGPR);
12445     done.link(&amp;m_jit);
12446     callOperation(operationNewArrayWithSize, resultGPR, structureGPR, sizeGPR, nullptr);
12447     m_jit.exceptionCheck();
12448     cellResult(resultGPR, node);
12449 }
12450 
12451 void SpeculativeJIT::compileNewTypedArray(Node* node)
12452 {
12453     switch (node-&gt;child1().useKind()) {
12454     case Int32Use:
12455         compileNewTypedArrayWithSize(node);
12456         break;
12457     case UntypedUse: {
12458         JSValueOperand argument(this, node-&gt;child1());
12459         JSValueRegs argumentRegs = argument.jsValueRegs();
12460 
12461         flushRegisters();
12462 
12463         GPRFlushedCallResult result(this);
12464         GPRReg resultGPR = result.gpr();
12465 
12466         JSGlobalObject* globalObject = m_jit.graph().globalObjectFor(node-&gt;origin.semantic);
12467         callOperation(
12468             operationNewTypedArrayWithOneArgumentForType(node-&gt;typedArrayType()),
12469             resultGPR, m_jit.graph().registerStructure(globalObject-&gt;typedArrayStructureConcurrently(node-&gt;typedArrayType())), argumentRegs);
12470         m_jit.exceptionCheck();
12471 
12472         cellResult(resultGPR, node);
12473         break;
12474     }
12475     default:
12476         RELEASE_ASSERT_NOT_REACHED();
12477         break;
12478     }
12479 }
12480 
12481 void SpeculativeJIT::compileToThis(Node* node)
12482 {
12483     ASSERT(node-&gt;child1().useKind() == UntypedUse);
12484     JSValueOperand thisValue(this, node-&gt;child1());
12485     JSValueRegsTemporary temp(this);
12486 
12487     JSValueRegs thisValueRegs = thisValue.jsValueRegs();
12488     JSValueRegs tempRegs = temp.regs();
12489 
12490     MacroAssembler::JumpList slowCases;
12491     slowCases.append(m_jit.branchIfNotCell(thisValueRegs));
12492     slowCases.append(
12493         m_jit.branchTest8(
12494             MacroAssembler::NonZero,
12495             MacroAssembler::Address(thisValueRegs.payloadGPR(), JSCell::typeInfoFlagsOffset()),
12496             MacroAssembler::TrustedImm32(OverridesToThis)));
12497     m_jit.moveValueRegs(thisValueRegs, tempRegs);
12498 
12499     J_JITOperation_EJ function;
<a name="150" id="anc150"></a><span class="line-modified">12500     if (m_jit.isStrictModeFor(node-&gt;origin.semantic))</span>
12501         function = operationToThisStrict;
12502     else
12503         function = operationToThis;
12504     addSlowPathGenerator(slowPathCall(slowCases, this, function, tempRegs, thisValueRegs));
12505 
12506     jsValueResult(tempRegs, node);
12507 }
12508 
12509 void SpeculativeJIT::compileObjectKeys(Node* node)
12510 {
12511     switch (node-&gt;child1().useKind()) {
12512     case ObjectUse: {
12513         if (m_graph.isWatchingHavingABadTimeWatchpoint(node)) {
12514             SpeculateCellOperand object(this, node-&gt;child1());
12515             GPRTemporary structure(this);
12516             GPRTemporary scratch(this);
12517             GPRTemporary scratch2(this);
12518             GPRTemporary scratch3(this);
12519             GPRTemporary result(this);
12520 
12521             GPRReg objectGPR = object.gpr();
12522             GPRReg structureGPR = structure.gpr();
12523             GPRReg scratchGPR = scratch.gpr();
12524             GPRReg scratch2GPR = scratch2.gpr();
12525             GPRReg scratch3GPR = scratch3.gpr();
12526             GPRReg resultGPR = result.gpr();
12527 
12528             speculateObject(node-&gt;child1(), objectGPR);
12529 
12530             CCallHelpers::JumpList slowCases;
<a name="151" id="anc151"></a><span class="line-modified">12531             m_jit.emitLoadStructure(vm(), objectGPR, structureGPR, scratchGPR);</span>
12532             m_jit.loadPtr(CCallHelpers::Address(structureGPR, Structure::previousOrRareDataOffset()), scratchGPR);
12533 
12534             slowCases.append(m_jit.branchTestPtr(CCallHelpers::Zero, scratchGPR));
<a name="152" id="anc152"></a><span class="line-modified">12535             slowCases.append(m_jit.branch32(CCallHelpers::Equal, CCallHelpers::Address(scratchGPR, JSCell::structureIDOffset()), TrustedImm32(bitwise_cast&lt;int32_t&gt;(vm().structureStructure-&gt;structureID()))));</span>
12536 
12537             m_jit.loadPtr(CCallHelpers::Address(scratchGPR, StructureRareData::offsetOfCachedOwnKeys()), scratchGPR);
12538 
12539             ASSERT(bitwise_cast&lt;uintptr_t&gt;(StructureRareData::cachedOwnKeysSentinel()) == 1);
12540             slowCases.append(m_jit.branchPtr(CCallHelpers::BelowOrEqual, scratchGPR, TrustedImmPtr(bitwise_cast&lt;void*&gt;(StructureRareData::cachedOwnKeysSentinel()))));
12541 
12542             MacroAssembler::JumpList slowButArrayBufferCases;
12543 
12544             JSGlobalObject* globalObject = m_jit.graph().globalObjectFor(node-&gt;origin.semantic);
12545             RegisteredStructure arrayStructure = m_jit.graph().registerStructure(globalObject-&gt;arrayStructureForIndexingTypeDuringAllocation(CopyOnWriteArrayWithContiguous));
12546 
12547             m_jit.move(scratchGPR, scratch3GPR);
12548             m_jit.addPtr(TrustedImmPtr(JSImmutableButterfly::offsetOfData()), scratchGPR);
12549 
12550             emitAllocateJSObject&lt;JSArray&gt;(resultGPR, TrustedImmPtr(arrayStructure), scratchGPR, structureGPR, scratch2GPR, slowButArrayBufferCases);
12551 
12552             addSlowPathGenerator(slowPathCall(slowButArrayBufferCases, this, operationNewArrayBuffer, resultGPR, arrayStructure, scratch3GPR));
12553 
12554             addSlowPathGenerator(slowPathCall(slowCases, this, operationObjectKeysObject, resultGPR, objectGPR));
12555 
12556             cellResult(resultGPR, node);
12557             break;
12558         }
12559 
12560         SpeculateCellOperand object(this, node-&gt;child1());
12561 
12562         GPRReg objectGPR = object.gpr();
12563 
12564         speculateObject(node-&gt;child1(), objectGPR);
12565 
12566         flushRegisters();
12567         GPRFlushedCallResult result(this);
12568         GPRReg resultGPR = result.gpr();
12569         callOperation(operationObjectKeysObject, resultGPR, objectGPR);
12570         m_jit.exceptionCheck();
12571 
12572         cellResult(resultGPR, node);
12573         break;
12574     }
12575 
12576     case UntypedUse: {
12577         JSValueOperand object(this, node-&gt;child1());
12578 
12579         JSValueRegs objectRegs = object.jsValueRegs();
12580 
12581         flushRegisters();
12582         GPRFlushedCallResult result(this);
12583         GPRReg resultGPR = result.gpr();
12584         callOperation(operationObjectKeys, resultGPR, objectRegs);
12585         m_jit.exceptionCheck();
12586 
12587         cellResult(resultGPR, node);
12588         break;
12589     }
12590 
12591     default:
12592         RELEASE_ASSERT_NOT_REACHED();
12593         break;
12594     }
12595 }
12596 
12597 void SpeculativeJIT::compileObjectCreate(Node* node)
12598 {
12599     switch (node-&gt;child1().useKind()) {
12600     case ObjectUse: {
12601         SpeculateCellOperand prototype(this, node-&gt;child1());
12602 
12603         GPRReg prototypeGPR = prototype.gpr();
12604 
12605         speculateObject(node-&gt;child1(), prototypeGPR);
12606 
12607         flushRegisters();
12608         GPRFlushedCallResult result(this);
12609         GPRReg resultGPR = result.gpr();
12610         callOperation(operationObjectCreateObject, resultGPR, prototypeGPR);
12611         m_jit.exceptionCheck();
12612 
12613         cellResult(resultGPR, node);
12614         break;
12615     }
12616 
12617     case UntypedUse: {
12618         JSValueOperand prototype(this, node-&gt;child1());
12619 
12620         JSValueRegs prototypeRegs = prototype.jsValueRegs();
12621 
12622         flushRegisters();
12623         GPRFlushedCallResult result(this);
12624         GPRReg resultGPR = result.gpr();
12625         callOperation(operationObjectCreate, resultGPR, prototypeRegs);
12626         m_jit.exceptionCheck();
12627 
12628         cellResult(resultGPR, node);
12629         break;
12630     }
12631 
12632     default:
12633         RELEASE_ASSERT_NOT_REACHED();
12634         break;
12635     }
12636 }
12637 
12638 void SpeculativeJIT::compileCreateThis(Node* node)
12639 {
12640     // Note that there is not so much profit to speculate here. The only things we
12641     // speculate on are (1) that it&#39;s a cell, since that eliminates cell checks
12642     // later if the proto is reused, and (2) if we have a FinalObject prediction
12643     // then we speculate because we want to get recompiled if it isn&#39;t (since
12644     // otherwise we&#39;d start taking slow path a lot).
12645 
12646     SpeculateCellOperand callee(this, node-&gt;child1());
12647     GPRTemporary result(this);
12648     GPRTemporary allocator(this);
12649     GPRTemporary structure(this);
12650     GPRTemporary scratch(this);
12651 
12652     GPRReg calleeGPR = callee.gpr();
12653     GPRReg resultGPR = result.gpr();
12654     GPRReg allocatorGPR = allocator.gpr();
12655     GPRReg structureGPR = structure.gpr();
12656     GPRReg scratchGPR = scratch.gpr();
12657     // Rare data is only used to access the allocator &amp; structure
12658     // We can avoid using an additional GPR this way
12659     GPRReg rareDataGPR = structureGPR;
12660     GPRReg inlineCapacityGPR = rareDataGPR;
12661 
12662     MacroAssembler::JumpList slowPath;
12663 
12664     slowPath.append(m_jit.branchIfNotFunction(calleeGPR));
12665     m_jit.loadPtr(JITCompiler::Address(calleeGPR, JSFunction::offsetOfRareData()), rareDataGPR);
12666     slowPath.append(m_jit.branchTestPtr(MacroAssembler::Zero, rareDataGPR));
<a name="153" id="anc153"></a><span class="line-modified">12667     m_jit.loadPtr(JITCompiler::Address(rareDataGPR, FunctionRareData::offsetOfObjectAllocationProfile() + ObjectAllocationProfileWithPrototype::offsetOfAllocator()), allocatorGPR);</span>
<span class="line-modified">12668     m_jit.loadPtr(JITCompiler::Address(rareDataGPR, FunctionRareData::offsetOfObjectAllocationProfile() + ObjectAllocationProfileWithPrototype::offsetOfStructure()), structureGPR);</span>
12669 
12670     auto butterfly = TrustedImmPtr(nullptr);
12671     emitAllocateJSObject(resultGPR, JITAllocator::variable(), allocatorGPR, structureGPR, butterfly, scratchGPR, slowPath);
12672 
<a name="154" id="anc154"></a><span class="line-modified">12673     m_jit.load8(JITCompiler::Address(structureGPR, Structure::inlineCapacityOffset()), inlineCapacityGPR);</span>

12674     m_jit.emitInitializeInlineStorage(resultGPR, inlineCapacityGPR);
<a name="155" id="anc155"></a><span class="line-modified">12675     m_jit.mutatorFence(vm());</span>
12676 
12677     addSlowPathGenerator(slowPathCall(slowPath, this, operationCreateThis, resultGPR, calleeGPR, node-&gt;inlineCapacity()));
12678 
12679     cellResult(resultGPR, node);
12680 }
12681 
12682 void SpeculativeJIT::compileNewObject(Node* node)
12683 {
12684     GPRTemporary result(this);
12685     GPRTemporary allocator(this);
12686     GPRTemporary scratch(this);
12687 
12688     GPRReg resultGPR = result.gpr();
12689     GPRReg allocatorGPR = allocator.gpr();
12690     GPRReg scratchGPR = scratch.gpr();
12691 
12692     MacroAssembler::JumpList slowPath;
12693 
12694     RegisteredStructure structure = node-&gt;structure();
12695     size_t allocationSize = JSFinalObject::allocationSize(structure-&gt;inlineCapacity());
<a name="156" id="anc156"></a><span class="line-modified">12696     Allocator allocatorValue = allocatorForNonVirtualConcurrently&lt;JSFinalObject&gt;(vm(), allocationSize, AllocatorForMode::AllocatorIfExists);</span>
12697     if (!allocatorValue)
12698         slowPath.append(m_jit.jump());
12699     else {
12700         auto butterfly = TrustedImmPtr(nullptr);
12701         emitAllocateJSObject(resultGPR, JITAllocator::constant(allocatorValue), allocatorGPR, TrustedImmPtr(structure), butterfly, scratchGPR, slowPath);
12702         m_jit.emitInitializeInlineStorage(resultGPR, structure-&gt;inlineCapacity());
<a name="157" id="anc157"></a><span class="line-modified">12703         m_jit.mutatorFence(vm());</span>
12704     }
12705 
12706     addSlowPathGenerator(slowPathCall(slowPath, this, operationNewObject, resultGPR, structure));
12707 
12708     cellResult(resultGPR, node);
12709 }
12710 
12711 void SpeculativeJIT::compileToPrimitive(Node* node)
12712 {
12713     DFG_ASSERT(m_jit.graph(), node, node-&gt;child1().useKind() == UntypedUse, node-&gt;child1().useKind());
12714     JSValueOperand argument(this, node-&gt;child1());
12715     JSValueRegsTemporary result(this, Reuse, argument);
12716 
12717     JSValueRegs argumentRegs = argument.jsValueRegs();
12718     JSValueRegs resultRegs = result.regs();
12719 
12720     argument.use();
12721 
12722     MacroAssembler::Jump alreadyPrimitive = m_jit.branchIfNotCell(argumentRegs);
12723     MacroAssembler::Jump notPrimitive = m_jit.branchIfObject(argumentRegs.payloadGPR());
12724 
12725     alreadyPrimitive.link(&amp;m_jit);
12726     m_jit.moveValueRegs(argumentRegs, resultRegs);
12727 
12728     addSlowPathGenerator(slowPathCall(notPrimitive, this, operationToPrimitive, resultRegs, argumentRegs));
12729 
12730     jsValueResult(resultRegs, node, DataFormatJS, UseChildrenCalledExplicitly);
12731 }
12732 
12733 void SpeculativeJIT::compileLogShadowChickenPrologue(Node* node)
12734 {
12735     flushRegisters();
12736     prepareForExternalCall();
12737     m_jit.emitStoreCodeOrigin(node-&gt;origin.semantic);
12738 
12739     GPRTemporary scratch1(this, GPRInfo::nonArgGPR0); // This must be a non-argument GPR.
12740     GPRReg scratch1Reg = scratch1.gpr();
12741     GPRTemporary scratch2(this);
12742     GPRReg scratch2Reg = scratch2.gpr();
12743     GPRTemporary shadowPacket(this);
12744     GPRReg shadowPacketReg = shadowPacket.gpr();
12745 
<a name="158" id="anc158"></a><span class="line-modified">12746     m_jit.ensureShadowChickenPacket(vm(), shadowPacketReg, scratch1Reg, scratch2Reg);</span>
12747 
12748     SpeculateCellOperand scope(this, node-&gt;child1());
12749     GPRReg scopeReg = scope.gpr();
12750 
12751     m_jit.logShadowChickenProloguePacket(shadowPacketReg, scratch1Reg, scopeReg);
12752     noResult(node);
12753 }
12754 
12755 void SpeculativeJIT::compileLogShadowChickenTail(Node* node)
12756 {
12757     flushRegisters();
12758     prepareForExternalCall();
12759     CallSiteIndex callSiteIndex = m_jit.emitStoreCodeOrigin(node-&gt;origin.semantic);
12760 
12761     GPRTemporary scratch1(this, GPRInfo::nonArgGPR0); // This must be a non-argument GPR.
12762     GPRReg scratch1Reg = scratch1.gpr();
12763     GPRTemporary scratch2(this);
12764     GPRReg scratch2Reg = scratch2.gpr();
12765     GPRTemporary shadowPacket(this);
12766     GPRReg shadowPacketReg = shadowPacket.gpr();
12767 
<a name="159" id="anc159"></a><span class="line-modified">12768     m_jit.ensureShadowChickenPacket(vm(), shadowPacketReg, scratch1Reg, scratch2Reg);</span>
12769 
12770     JSValueOperand thisValue(this, node-&gt;child1());
12771     JSValueRegs thisRegs = thisValue.jsValueRegs();
12772     SpeculateCellOperand scope(this, node-&gt;child2());
12773     GPRReg scopeReg = scope.gpr();
12774 
12775     m_jit.logShadowChickenTailPacket(shadowPacketReg, thisRegs, scopeReg, m_jit.codeBlock(), callSiteIndex);
12776     noResult(node);
12777 }
12778 
12779 void SpeculativeJIT::compileSetAdd(Node* node)
12780 {
12781     SpeculateCellOperand set(this, node-&gt;child1());
12782     JSValueOperand key(this, node-&gt;child2());
12783     SpeculateInt32Operand hash(this, node-&gt;child3());
12784 
12785     GPRReg setGPR = set.gpr();
12786     JSValueRegs keyRegs = key.jsValueRegs();
12787     GPRReg hashGPR = hash.gpr();
12788 
12789     speculateSetObject(node-&gt;child1(), setGPR);
12790 
12791     flushRegisters();
12792     GPRFlushedCallResult result(this);
12793     GPRReg resultGPR = result.gpr();
12794     callOperation(operationSetAdd, resultGPR, setGPR, keyRegs, hashGPR);
12795     m_jit.exceptionCheck();
12796     cellResult(resultGPR, node);
12797 }
12798 
12799 void SpeculativeJIT::compileMapSet(Node* node)
12800 {
12801     SpeculateCellOperand map(this, m_jit.graph().varArgChild(node, 0));
12802     JSValueOperand key(this, m_jit.graph().varArgChild(node, 1));
12803     JSValueOperand value(this, m_jit.graph().varArgChild(node, 2));
12804     SpeculateInt32Operand hash(this, m_jit.graph().varArgChild(node, 3));
12805 
12806     GPRReg mapGPR = map.gpr();
12807     JSValueRegs keyRegs = key.jsValueRegs();
12808     JSValueRegs valueRegs = value.jsValueRegs();
12809     GPRReg hashGPR = hash.gpr();
12810 
12811     speculateMapObject(m_jit.graph().varArgChild(node, 0), mapGPR);
12812 
12813     flushRegisters();
12814     GPRFlushedCallResult result(this);
12815     GPRReg resultGPR = result.gpr();
12816     callOperation(operationMapSet, resultGPR, mapGPR, keyRegs, valueRegs, hashGPR);
12817     m_jit.exceptionCheck();
12818     cellResult(resultGPR, node);
12819 }
12820 
12821 void SpeculativeJIT::compileWeakMapGet(Node* node)
12822 {
12823     GPRTemporary mask(this);
12824     GPRTemporary buffer(this);
12825     JSValueRegsTemporary result(this);
12826 
12827     GPRReg maskGPR = mask.gpr();
12828     GPRReg bufferGPR = buffer.gpr();
12829     JSValueRegs resultRegs = result.regs();
12830 
12831     GPRTemporary index;
12832     GPRReg indexGPR { InvalidGPRReg };
12833     {
12834         SpeculateInt32Operand hash(this, node-&gt;child3());
12835         GPRReg hashGPR = hash.gpr();
12836         index = GPRTemporary(this, Reuse, hash);
12837         indexGPR = index.gpr();
12838         m_jit.move(hashGPR, indexGPR);
12839     }
12840 
12841     {
12842         SpeculateCellOperand weakMap(this, node-&gt;child1());
12843         GPRReg weakMapGPR = weakMap.gpr();
12844         if (node-&gt;child1().useKind() == WeakMapObjectUse)
12845             speculateWeakMapObject(node-&gt;child1(), weakMapGPR);
12846         else
12847             speculateWeakSetObject(node-&gt;child1(), weakMapGPR);
12848 
12849         ASSERT(WeakMapImpl&lt;WeakMapBucket&lt;WeakMapBucketDataKey&gt;&gt;::offsetOfCapacity() == WeakMapImpl&lt;WeakMapBucket&lt;WeakMapBucketDataKeyValue&gt;&gt;::offsetOfCapacity());
12850         ASSERT(WeakMapImpl&lt;WeakMapBucket&lt;WeakMapBucketDataKey&gt;&gt;::offsetOfBuffer() == WeakMapImpl&lt;WeakMapBucket&lt;WeakMapBucketDataKeyValue&gt;&gt;::offsetOfBuffer());
12851         m_jit.load32(MacroAssembler::Address(weakMapGPR, WeakMapImpl&lt;WeakMapBucket&lt;WeakMapBucketDataKey&gt;&gt;::offsetOfCapacity()), maskGPR);
12852         m_jit.loadPtr(MacroAssembler::Address(weakMapGPR, WeakMapImpl&lt;WeakMapBucket&lt;WeakMapBucketDataKey&gt;&gt;::offsetOfBuffer()), bufferGPR);
12853     }
12854 
12855     SpeculateCellOperand key(this, node-&gt;child2());
12856     GPRReg keyGPR = key.gpr();
12857     speculateObject(node-&gt;child2(), keyGPR);
12858 
12859 #if USE(JSVALUE32_64)
12860     GPRReg bucketGPR = resultRegs.tagGPR();
12861 #else
12862     GPRTemporary bucket(this);
12863     GPRReg bucketGPR = bucket.gpr();
12864 #endif
12865 
12866     m_jit.sub32(TrustedImm32(1), maskGPR);
12867 
12868     MacroAssembler::Label loop = m_jit.label();
12869     m_jit.and32(maskGPR, indexGPR);
12870     if (node-&gt;child1().useKind() == WeakSetObjectUse) {
12871         static_assert(sizeof(WeakMapBucket&lt;WeakMapBucketDataKey&gt;) == sizeof(void*), &quot;&quot;);
12872         m_jit.zeroExtend32ToPtr(indexGPR, bucketGPR);
12873         m_jit.lshiftPtr(MacroAssembler::Imm32(sizeof(void*) == 4 ? 2 : 3), bucketGPR);
12874         m_jit.addPtr(bufferGPR, bucketGPR);
12875     } else {
12876         ASSERT(node-&gt;child1().useKind() == WeakMapObjectUse);
12877         static_assert(sizeof(WeakMapBucket&lt;WeakMapBucketDataKeyValue&gt;) == 16, &quot;&quot;);
12878         m_jit.zeroExtend32ToPtr(indexGPR, bucketGPR);
12879         m_jit.lshiftPtr(MacroAssembler::Imm32(4), bucketGPR);
12880         m_jit.addPtr(bufferGPR, bucketGPR);
12881     }
12882 
12883     m_jit.loadPtr(MacroAssembler::Address(bucketGPR, WeakMapBucket&lt;WeakMapBucketDataKeyValue&gt;::offsetOfKey()), resultRegs.payloadGPR());
12884 
12885     // They&#39;re definitely the same value, we found the bucket we were looking for!
12886     // The deleted key comparison is also done with this.
12887     auto found = m_jit.branchPtr(MacroAssembler::Equal, resultRegs.payloadGPR(), keyGPR);
12888 
12889     auto notPresentInTable = m_jit.branchTestPtr(MacroAssembler::Zero, resultRegs.payloadGPR());
12890 
12891     m_jit.add32(TrustedImm32(1), indexGPR);
12892     m_jit.jump().linkTo(loop, &amp;m_jit);
12893 
12894 #if USE(JSVALUE32_64)
12895     notPresentInTable.link(&amp;m_jit);
12896     m_jit.moveValue(JSValue(), resultRegs);
12897     auto notPresentInTableDone = m_jit.jump();
12898 
12899     found.link(&amp;m_jit);
12900     if (node-&gt;child1().useKind() == WeakSetObjectUse)
12901         m_jit.move(TrustedImm32(JSValue::CellTag), resultRegs.tagGPR());
12902     else
12903         m_jit.loadValue(MacroAssembler::Address(bucketGPR, WeakMapBucket&lt;WeakMapBucketDataKeyValue&gt;::offsetOfValue()), resultRegs);
12904 
12905     notPresentInTableDone.link(&amp;m_jit);
12906 #else
12907     notPresentInTable.link(&amp;m_jit);
12908     found.link(&amp;m_jit);
12909 
12910     // In 64bit environment, Empty bucket has JSEmpty value. Empty key is JSEmpty.
12911     // If empty bucket is found, we can use the same path used for the case of finding a bucket.
12912     if (node-&gt;child1().useKind() == WeakMapObjectUse)
12913         m_jit.loadValue(MacroAssembler::Address(bucketGPR, WeakMapBucket&lt;WeakMapBucketDataKeyValue&gt;::offsetOfValue()), resultRegs);
12914 #endif
12915 
12916     jsValueResult(resultRegs, node);
12917 }
12918 
12919 void SpeculativeJIT::compileWeakSetAdd(Node* node)
12920 {
12921     SpeculateCellOperand set(this, node-&gt;child1());
12922     SpeculateCellOperand key(this, node-&gt;child2());
12923     SpeculateInt32Operand hash(this, node-&gt;child3());
12924 
12925     GPRReg setGPR = set.gpr();
12926     GPRReg keyGPR = key.gpr();
12927     GPRReg hashGPR = hash.gpr();
12928 
12929     speculateWeakSetObject(node-&gt;child1(), setGPR);
12930     speculateObject(node-&gt;child2(), keyGPR);
12931 
12932     flushRegisters();
12933     callOperation(operationWeakSetAdd, setGPR, keyGPR, hashGPR);
12934     m_jit.exceptionCheck();
12935     noResult(node);
12936 }
12937 
12938 void SpeculativeJIT::compileWeakMapSet(Node* node)
12939 {
12940     SpeculateCellOperand map(this, m_jit.graph().varArgChild(node, 0));
12941     SpeculateCellOperand key(this, m_jit.graph().varArgChild(node, 1));
12942     JSValueOperand value(this, m_jit.graph().varArgChild(node, 2));
12943     SpeculateInt32Operand hash(this, m_jit.graph().varArgChild(node, 3));
12944 
12945     GPRReg mapGPR = map.gpr();
12946     GPRReg keyGPR = key.gpr();
12947     JSValueRegs valueRegs = value.jsValueRegs();
12948     GPRReg hashGPR = hash.gpr();
12949 
12950     speculateWeakMapObject(m_jit.graph().varArgChild(node, 0), mapGPR);
12951     speculateObject(m_jit.graph().varArgChild(node, 1), keyGPR);
12952 
12953     flushRegisters();
12954     callOperation(operationWeakMapSet, mapGPR, keyGPR, valueRegs, hashGPR);
12955     m_jit.exceptionCheck();
12956     noResult(node);
12957 }
12958 
12959 void SpeculativeJIT::compileGetPrototypeOf(Node* node)
12960 {
12961     switch (node-&gt;child1().useKind()) {
12962     case ArrayUse:
12963     case FunctionUse:
12964     case FinalObjectUse: {
12965         SpeculateCellOperand object(this, node-&gt;child1());
12966         GPRTemporary temp(this);
12967         GPRTemporary temp2(this);
12968 
12969         GPRReg objectGPR = object.gpr();
12970         GPRReg tempGPR = temp.gpr();
12971         GPRReg temp2GPR = temp2.gpr();
12972 
12973         switch (node-&gt;child1().useKind()) {
12974         case ArrayUse:
12975             speculateArray(node-&gt;child1(), objectGPR);
12976             break;
12977         case FunctionUse:
12978             speculateFunction(node-&gt;child1(), objectGPR);
12979             break;
12980         case FinalObjectUse:
12981             speculateFinalObject(node-&gt;child1(), objectGPR);
12982             break;
12983         default:
12984             RELEASE_ASSERT_NOT_REACHED();
12985             break;
12986         }
12987 
<a name="160" id="anc160"></a><span class="line-modified">12988         m_jit.emitLoadStructure(vm(), objectGPR, tempGPR, temp2GPR);</span>
12989 
12990         AbstractValue&amp; value = m_state.forNode(node-&gt;child1());
12991         if ((value.m_type &amp;&amp; !(value.m_type &amp; ~SpecObject)) &amp;&amp; value.m_structure.isFinite()) {
12992             bool hasPolyProto = false;
12993             bool hasMonoProto = false;
12994             value.m_structure.forEach([&amp;] (RegisteredStructure structure) {
12995                 if (structure-&gt;hasPolyProto())
12996                     hasPolyProto = true;
12997                 else
12998                     hasMonoProto = true;
12999             });
13000 
13001             if (hasMonoProto &amp;&amp; !hasPolyProto) {
13002 #if USE(JSVALUE64)
13003                 m_jit.load64(MacroAssembler::Address(tempGPR, Structure::prototypeOffset()), tempGPR);
13004                 jsValueResult(tempGPR, node);
13005 #else
13006                 m_jit.load32(MacroAssembler::Address(tempGPR, Structure::prototypeOffset() + TagOffset), temp2GPR);
13007                 m_jit.load32(MacroAssembler::Address(tempGPR, Structure::prototypeOffset() + PayloadOffset), tempGPR);
13008                 jsValueResult(temp2GPR, tempGPR, node);
13009 #endif
13010                 return;
13011             }
13012 
13013             if (hasPolyProto &amp;&amp; !hasMonoProto) {
13014 #if USE(JSVALUE64)
13015                 m_jit.load64(JITCompiler::Address(objectGPR, offsetRelativeToBase(knownPolyProtoOffset)), tempGPR);
13016                 jsValueResult(tempGPR, node);
13017 #else
13018                 m_jit.load32(JITCompiler::Address(objectGPR, offsetRelativeToBase(knownPolyProtoOffset) + TagOffset), temp2GPR);
13019                 m_jit.load32(JITCompiler::Address(objectGPR, offsetRelativeToBase(knownPolyProtoOffset) + PayloadOffset), tempGPR);
13020                 jsValueResult(temp2GPR, tempGPR, node);
13021 #endif
13022                 return;
13023             }
13024         }
13025 
13026 #if USE(JSVALUE64)
13027         m_jit.load64(MacroAssembler::Address(tempGPR, Structure::prototypeOffset()), tempGPR);
13028         auto hasMonoProto = m_jit.branchIfNotEmpty(tempGPR);
13029         m_jit.load64(JITCompiler::Address(objectGPR, offsetRelativeToBase(knownPolyProtoOffset)), tempGPR);
13030         hasMonoProto.link(&amp;m_jit);
13031         jsValueResult(tempGPR, node);
13032 #else
13033         m_jit.load32(MacroAssembler::Address(tempGPR, Structure::prototypeOffset() + TagOffset), temp2GPR);
13034         m_jit.load32(MacroAssembler::Address(tempGPR, Structure::prototypeOffset() + PayloadOffset), tempGPR);
13035         auto hasMonoProto = m_jit.branchIfNotEmpty(temp2GPR);
13036         m_jit.load32(JITCompiler::Address(objectGPR, offsetRelativeToBase(knownPolyProtoOffset) + TagOffset), temp2GPR);
13037         m_jit.load32(JITCompiler::Address(objectGPR, offsetRelativeToBase(knownPolyProtoOffset) + PayloadOffset), tempGPR);
13038         hasMonoProto.link(&amp;m_jit);
13039         jsValueResult(temp2GPR, tempGPR, node);
13040 #endif
13041         return;
13042     }
13043     case ObjectUse: {
13044         SpeculateCellOperand value(this, node-&gt;child1());
13045         JSValueRegsTemporary result(this);
13046 
13047         GPRReg valueGPR = value.gpr();
13048         JSValueRegs resultRegs = result.regs();
13049 
13050         speculateObject(node-&gt;child1(), valueGPR);
13051 
13052         flushRegisters();
13053         callOperation(operationGetPrototypeOfObject, resultRegs, valueGPR);
13054         m_jit.exceptionCheck();
13055         jsValueResult(resultRegs, node);
13056         return;
13057     }
13058     default: {
13059         JSValueOperand value(this, node-&gt;child1());
13060         JSValueRegsTemporary result(this);
13061 
13062         JSValueRegs valueRegs = value.jsValueRegs();
13063         JSValueRegs resultRegs = result.regs();
13064 
13065         flushRegisters();
13066         callOperation(operationGetPrototypeOf, resultRegs, valueRegs);
13067         m_jit.exceptionCheck();
13068         jsValueResult(resultRegs, node);
13069         return;
13070     }
13071     }
13072 }
13073 
13074 void SpeculativeJIT::compileIdentity(Node* node)
13075 {
13076     speculate(node, node-&gt;child1());
13077     switch (node-&gt;child1().useKind()) {
13078 #if USE(JSVALUE64)
13079     case DoubleRepAnyIntUse:
13080 #endif
13081     case DoubleRepUse:
13082     case DoubleRepRealUse: {
13083         SpeculateDoubleOperand op(this, node-&gt;child1());
13084         FPRTemporary scratch(this, op);
13085         m_jit.moveDouble(op.fpr(), scratch.fpr());
13086         doubleResult(scratch.fpr(), node);
13087         break;
13088     }
13089 #if USE(JSVALUE64)
13090     case Int52RepUse: {
13091         SpeculateInt52Operand op(this, node-&gt;child1());
13092         GPRTemporary result(this, Reuse, op);
13093         m_jit.move(op.gpr(), result.gpr());
13094         int52Result(result.gpr(), node);
13095         break;
13096     }
13097 #endif
13098     default: {
13099         JSValueOperand op(this, node-&gt;child1(), ManualOperandSpeculation);
13100         JSValueRegsTemporary result(this, Reuse, op);
13101         JSValueRegs opRegs = op.jsValueRegs();
13102         JSValueRegs resultRegs = result.regs();
13103         m_jit.moveValueRegs(opRegs, resultRegs);
13104         jsValueResult(resultRegs, node);
13105         break;
13106     }
13107     }
13108 }
13109 
13110 void SpeculativeJIT::compileMiscStrictEq(Node* node)
13111 {
13112     JSValueOperand op1(this, node-&gt;child1(), ManualOperandSpeculation);
13113     JSValueOperand op2(this, node-&gt;child2(), ManualOperandSpeculation);
13114     GPRTemporary result(this);
13115 
13116     if (node-&gt;child1().useKind() == MiscUse)
13117         speculateMisc(node-&gt;child1(), op1.jsValueRegs());
13118     if (node-&gt;child2().useKind() == MiscUse)
13119         speculateMisc(node-&gt;child2(), op2.jsValueRegs());
13120 
13121 #if USE(JSVALUE64)
13122     m_jit.compare64(JITCompiler::Equal, op1.gpr(), op2.gpr(), result.gpr());
13123 #else
13124     m_jit.move(TrustedImm32(0), result.gpr());
13125     JITCompiler::Jump notEqual = m_jit.branch32(JITCompiler::NotEqual, op1.tagGPR(), op2.tagGPR());
13126     m_jit.compare32(JITCompiler::Equal, op1.payloadGPR(), op2.payloadGPR(), result.gpr());
13127     notEqual.link(&amp;m_jit);
13128 #endif
13129     unblessedBooleanResult(result.gpr(), node);
13130 }
13131 
13132 void SpeculativeJIT::emitInitializeButterfly(GPRReg storageGPR, GPRReg sizeGPR, JSValueRegs emptyValueRegs, GPRReg scratchGPR)
13133 {
13134     m_jit.zeroExtend32ToPtr(sizeGPR, scratchGPR);
13135     MacroAssembler::Jump done = m_jit.branchTest32(MacroAssembler::Zero, scratchGPR);
13136     MacroAssembler::Label loop = m_jit.label();
13137     m_jit.sub32(TrustedImm32(1), scratchGPR);
13138     m_jit.storeValue(emptyValueRegs, MacroAssembler::BaseIndex(storageGPR, scratchGPR, MacroAssembler::TimesEight));
13139     m_jit.branchTest32(MacroAssembler::NonZero, scratchGPR).linkTo(loop, &amp;m_jit);
13140     done.link(&amp;m_jit);
13141 }
13142 
13143 void SpeculativeJIT::compileAllocateNewArrayWithSize(JSGlobalObject* globalObject, GPRReg resultGPR, GPRReg sizeGPR, IndexingType indexingType, bool shouldConvertLargeSizeToArrayStorage)
13144 {
13145     GPRTemporary storage(this);
13146     GPRTemporary scratch(this);
13147     GPRTemporary scratch2(this);
13148 
13149     GPRReg storageGPR = storage.gpr();
13150     GPRReg scratchGPR = scratch.gpr();
13151     GPRReg scratch2GPR = scratch2.gpr();
13152 
13153     m_jit.move(TrustedImmPtr(nullptr), storageGPR);
13154 
13155     MacroAssembler::JumpList slowCases;
13156     if (shouldConvertLargeSizeToArrayStorage)
13157         slowCases.append(m_jit.branch32(MacroAssembler::AboveOrEqual, sizeGPR, TrustedImm32(MIN_ARRAY_STORAGE_CONSTRUCTION_LENGTH)));
13158 #if !ASSERT_DISABLED
13159     else {
13160         MacroAssembler::Jump lengthIsWithinLimits;
13161         lengthIsWithinLimits = m_jit.branch32(MacroAssembler::Below, sizeGPR, TrustedImm32(MIN_ARRAY_STORAGE_CONSTRUCTION_LENGTH));
13162         m_jit.abortWithReason(UncheckedOverflow);
13163         lengthIsWithinLimits.link(&amp;m_jit);
13164     }
13165 #endif
13166 
13167     // We can use resultGPR as a scratch right now.
13168     emitAllocateButterfly(storageGPR, sizeGPR, scratchGPR, scratch2GPR, resultGPR, slowCases);
13169 
13170 #if USE(JSVALUE64)
13171     JSValueRegs emptyValueRegs(scratchGPR);
13172     if (hasDouble(indexingType))
13173         m_jit.move(TrustedImm64(bitwise_cast&lt;int64_t&gt;(PNaN)), emptyValueRegs.gpr());
13174     else
13175         m_jit.move(TrustedImm64(JSValue::encode(JSValue())), emptyValueRegs.gpr());
13176 #else
13177     JSValueRegs emptyValueRegs(scratchGPR, scratch2GPR);
13178     if (hasDouble(indexingType))
13179         m_jit.moveValue(JSValue(JSValue::EncodeAsDouble, PNaN), emptyValueRegs);
13180     else
13181         m_jit.moveValue(JSValue(), emptyValueRegs);
13182 #endif
13183     emitInitializeButterfly(storageGPR, sizeGPR, emptyValueRegs, resultGPR);
13184 
13185     RegisteredStructure structure = m_jit.graph().registerStructure(globalObject-&gt;arrayStructureForIndexingTypeDuringAllocation(indexingType));
13186 
13187     emitAllocateJSObject&lt;JSArray&gt;(resultGPR, TrustedImmPtr(structure), storageGPR, scratchGPR, scratch2GPR, slowCases);
13188 
<a name="161" id="anc161"></a><span class="line-modified">13189     m_jit.mutatorFence(vm());</span>
13190 
<a name="162" id="anc162"></a><span class="line-modified">13191     addSlowPathGenerator(makeUnique&lt;CallArrayAllocatorWithVariableSizeSlowPathGenerator&gt;(</span>
13192         slowCases, this, operationNewArrayWithSize, resultGPR,
13193         structure,
13194         shouldConvertLargeSizeToArrayStorage ? m_jit.graph().registerStructure(globalObject-&gt;arrayStructureForIndexingTypeDuringAllocation(ArrayWithArrayStorage)) : structure,
13195         sizeGPR, storageGPR));
13196 }
13197 
13198 void SpeculativeJIT::compileHasIndexedProperty(Node* node)
13199 {
13200     SpeculateCellOperand base(this, m_graph.varArgChild(node, 0));
13201     SpeculateStrictInt32Operand index(this, m_graph.varArgChild(node, 1));
13202     GPRTemporary result(this);
13203 
13204     GPRReg baseGPR = base.gpr();
13205     GPRReg indexGPR = index.gpr();
13206     GPRReg resultGPR = result.gpr();
13207 
13208     MacroAssembler::JumpList slowCases;
13209     ArrayMode mode = node-&gt;arrayMode();
13210     switch (mode.type()) {
13211     case Array::Int32:
13212     case Array::Contiguous: {
13213         ASSERT(!!m_graph.varArgChild(node, 2));
13214         StorageOperand storage(this, m_graph.varArgChild(node, 2));
13215         GPRTemporary scratch(this);
13216 
13217         GPRReg storageGPR = storage.gpr();
13218         GPRReg scratchGPR = scratch.gpr();
13219 
13220         MacroAssembler::Jump outOfBounds = m_jit.branch32(MacroAssembler::AboveOrEqual, indexGPR, MacroAssembler::Address(storageGPR, Butterfly::offsetOfPublicLength()));
13221         if (mode.isInBounds())
13222             speculationCheck(OutOfBounds, JSValueRegs(), nullptr, outOfBounds);
13223         else
13224             slowCases.append(outOfBounds);
13225 
13226 #if USE(JSVALUE64)
13227         m_jit.load64(MacroAssembler::BaseIndex(storageGPR, indexGPR, MacroAssembler::TimesEight), scratchGPR);
13228         slowCases.append(m_jit.branchIfEmpty(scratchGPR));
13229 #else
13230         m_jit.load32(MacroAssembler::BaseIndex(storageGPR, indexGPR, MacroAssembler::TimesEight, OBJECT_OFFSETOF(JSValue, u.asBits.tag)), scratchGPR);
13231         slowCases.append(m_jit.branchIfEmpty(scratchGPR));
13232 #endif
13233         m_jit.move(TrustedImm32(1), resultGPR);
13234         break;
13235     }
13236     case Array::Double: {
13237         ASSERT(!!m_graph.varArgChild(node, 2));
13238         StorageOperand storage(this, m_graph.varArgChild(node, 2));
13239         FPRTemporary scratch(this);
13240         FPRReg scratchFPR = scratch.fpr();
13241         GPRReg storageGPR = storage.gpr();
13242 
13243         MacroAssembler::Jump outOfBounds = m_jit.branch32(MacroAssembler::AboveOrEqual, indexGPR, MacroAssembler::Address(storageGPR, Butterfly::offsetOfPublicLength()));
13244         if (mode.isInBounds())
13245             speculationCheck(OutOfBounds, JSValueRegs(), nullptr, outOfBounds);
13246         else
13247             slowCases.append(outOfBounds);
13248 
13249         m_jit.loadDouble(MacroAssembler::BaseIndex(storageGPR, indexGPR, MacroAssembler::TimesEight), scratchFPR);
13250         slowCases.append(m_jit.branchIfNaN(scratchFPR));
13251         m_jit.move(TrustedImm32(1), resultGPR);
13252         break;
13253     }
13254     case Array::ArrayStorage: {
13255         ASSERT(!!m_graph.varArgChild(node, 2));
13256         StorageOperand storage(this, m_graph.varArgChild(node, 2));
13257         GPRTemporary scratch(this);
13258 
13259         GPRReg storageGPR = storage.gpr();
13260         GPRReg scratchGPR = scratch.gpr();
13261 
13262         MacroAssembler::Jump outOfBounds = m_jit.branch32(MacroAssembler::AboveOrEqual, indexGPR, MacroAssembler::Address(storageGPR, ArrayStorage::vectorLengthOffset()));
13263         if (mode.isInBounds())
13264             speculationCheck(OutOfBounds, JSValueRegs(), nullptr, outOfBounds);
13265         else
13266             slowCases.append(outOfBounds);
13267 
13268 #if USE(JSVALUE64)
13269         m_jit.load64(MacroAssembler::BaseIndex(storageGPR, indexGPR, MacroAssembler::TimesEight, ArrayStorage::vectorOffset()), scratchGPR);
13270         slowCases.append(m_jit.branchIfEmpty(scratchGPR));
13271 #else
13272         m_jit.load32(MacroAssembler::BaseIndex(storageGPR, indexGPR, MacroAssembler::TimesEight, ArrayStorage::vectorOffset() + OBJECT_OFFSETOF(JSValue, u.asBits.tag)), scratchGPR);
13273         slowCases.append(m_jit.branchIfEmpty(scratchGPR));
13274 #endif
13275         m_jit.move(TrustedImm32(1), resultGPR);
13276         break;
13277     }
13278     default: {
13279         slowCases.append(m_jit.jump());
13280         break;
13281     }
13282     }
13283 
13284     addSlowPathGenerator(slowPathCall(slowCases, this, operationHasIndexedPropertyByInt, resultGPR, baseGPR, indexGPR, static_cast&lt;int32_t&gt;(node-&gt;internalMethodType())));
13285 
13286     unblessedBooleanResult(resultGPR, node);
13287 }
13288 
13289 void SpeculativeJIT::compileGetDirectPname(Node* node)
13290 {
13291     Edge&amp; baseEdge = m_jit.graph().varArgChild(node, 0);
13292     Edge&amp; propertyEdge = m_jit.graph().varArgChild(node, 1);
<a name="163" id="anc163"></a><span class="line-added">13293     Edge&amp; indexEdge = m_jit.graph().varArgChild(node, 2);</span>
13294 
13295     SpeculateCellOperand base(this, baseEdge);
13296     SpeculateCellOperand property(this, propertyEdge);
13297     GPRReg baseGPR = base.gpr();
13298     GPRReg propertyGPR = property.gpr();
13299 
13300 #if CPU(X86)
13301     // Not enough registers on X86 for this code, so always use the slow path.
<a name="164" id="anc164"></a><span class="line-added">13302     speculate(node, indexEdge);</span>
13303     flushRegisters();
13304     JSValueRegsFlushedCallResult result(this);
13305     JSValueRegs resultRegs = result.regs();
13306     callOperation(operationGetByValCell, resultRegs, baseGPR, CCallHelpers::CellValue(propertyGPR));
13307     m_jit.exceptionCheck();
13308     jsValueResult(resultRegs, node);
13309 #else
<a name="165" id="anc165"></a>
13310     Edge&amp; enumeratorEdge = m_jit.graph().varArgChild(node, 3);
13311     SpeculateStrictInt32Operand index(this, indexEdge);
13312     SpeculateCellOperand enumerator(this, enumeratorEdge);
13313     GPRTemporary scratch(this);
13314     JSValueRegsTemporary result(this);
13315 
13316     GPRReg indexGPR = index.gpr();
13317     GPRReg enumeratorGPR = enumerator.gpr();
13318     GPRReg scratchGPR = scratch.gpr();
13319     JSValueRegs resultRegs = result.regs();
13320 
13321     MacroAssembler::JumpList slowPath;
13322 
13323     // Check the structure
13324     m_jit.load32(MacroAssembler::Address(baseGPR, JSCell::structureIDOffset()), scratchGPR);
13325     slowPath.append(
13326         m_jit.branch32(
13327             MacroAssembler::NotEqual,
13328             scratchGPR,
13329             MacroAssembler::Address(
13330                 enumeratorGPR, JSPropertyNameEnumerator::cachedStructureIDOffset())));
13331 
13332     // Compute the offset
13333     // If index is less than the enumerator&#39;s cached inline storage, then it&#39;s an inline access
13334     MacroAssembler::Jump outOfLineAccess = m_jit.branch32(MacroAssembler::AboveOrEqual,
13335         indexGPR, MacroAssembler::Address(enumeratorGPR, JSPropertyNameEnumerator::cachedInlineCapacityOffset()));
13336 
13337     m_jit.loadValue(MacroAssembler::BaseIndex(baseGPR, indexGPR, MacroAssembler::TimesEight, JSObject::offsetOfInlineStorage()), resultRegs);
13338 
13339     MacroAssembler::Jump done = m_jit.jump();
13340 
13341     // Otherwise it&#39;s out of line
13342     outOfLineAccess.link(&amp;m_jit);
13343     m_jit.loadPtr(MacroAssembler::Address(baseGPR, JSObject::butterflyOffset()), resultRegs.payloadGPR());
13344     m_jit.move(indexGPR, scratchGPR);
13345     m_jit.sub32(MacroAssembler::Address(enumeratorGPR, JSPropertyNameEnumerator::cachedInlineCapacityOffset()), scratchGPR);
13346     m_jit.neg32(scratchGPR);
13347     m_jit.signExtend32ToPtr(scratchGPR, scratchGPR);
13348     int32_t offsetOfFirstProperty = static_cast&lt;int32_t&gt;(offsetInButterfly(firstOutOfLineOffset)) * sizeof(EncodedJSValue);
13349     m_jit.loadValue(MacroAssembler::BaseIndex(resultRegs.payloadGPR(), scratchGPR, MacroAssembler::TimesEight, offsetOfFirstProperty), resultRegs);
13350 
13351     done.link(&amp;m_jit);
13352 
13353     addSlowPathGenerator(slowPathCall(slowPath, this, operationGetByValCell, resultRegs, baseGPR, CCallHelpers::CellValue(propertyGPR)));
13354 
13355     jsValueResult(resultRegs, node);
13356 #endif
13357 }
13358 
13359 void SpeculativeJIT::compileExtractCatchLocal(Node* node)
13360 {
13361     JSValueRegsTemporary result(this);
13362     JSValueRegs resultRegs = result.regs();
13363 
13364     JSValue* ptr = &amp;reinterpret_cast&lt;JSValue*&gt;(m_jit.jitCode()-&gt;common.catchOSREntryBuffer-&gt;dataBuffer())[node-&gt;catchOSREntryIndex()];
13365     m_jit.loadValue(ptr, resultRegs);
13366     jsValueResult(resultRegs, node);
13367 }
13368 
13369 void SpeculativeJIT::compileClearCatchLocals(Node* node)
13370 {
13371     ScratchBuffer* scratchBuffer = m_jit.jitCode()-&gt;common.catchOSREntryBuffer;
13372     ASSERT(scratchBuffer);
13373     GPRTemporary scratch(this);
13374     GPRReg scratchGPR = scratch.gpr();
13375     m_jit.move(TrustedImmPtr(scratchBuffer-&gt;addressOfActiveLength()), scratchGPR);
13376     m_jit.storePtr(TrustedImmPtr(nullptr), scratchGPR);
13377     noResult(node);
13378 }
13379 
13380 void SpeculativeJIT::compileProfileType(Node* node)
13381 {
13382     JSValueOperand value(this, node-&gt;child1());
13383     GPRTemporary scratch1(this);
13384     GPRTemporary scratch2(this);
13385     GPRTemporary scratch3(this);
13386 
13387     JSValueRegs valueRegs = value.jsValueRegs();
13388     GPRReg scratch1GPR = scratch1.gpr();
13389     GPRReg scratch2GPR = scratch2.gpr();
13390     GPRReg scratch3GPR = scratch3.gpr();
13391 
13392     MacroAssembler::JumpList jumpToEnd;
13393 
13394     jumpToEnd.append(m_jit.branchIfEmpty(valueRegs));
13395 
13396     TypeLocation* cachedTypeLocation = node-&gt;typeLocation();
13397     // Compile in a predictive type check, if possible, to see if we can skip writing to the log.
13398     // These typechecks are inlined to match those of the 64-bit JSValue type checks.
13399     if (cachedTypeLocation-&gt;m_lastSeenType == TypeUndefined)
13400         jumpToEnd.append(m_jit.branchIfUndefined(valueRegs));
13401     else if (cachedTypeLocation-&gt;m_lastSeenType == TypeNull)
13402         jumpToEnd.append(m_jit.branchIfNull(valueRegs));
13403     else if (cachedTypeLocation-&gt;m_lastSeenType == TypeBoolean)
13404         jumpToEnd.append(m_jit.branchIfBoolean(valueRegs, scratch1GPR));
13405     else if (cachedTypeLocation-&gt;m_lastSeenType == TypeAnyInt)
13406         jumpToEnd.append(m_jit.branchIfInt32(valueRegs));
13407     else if (cachedTypeLocation-&gt;m_lastSeenType == TypeNumber)
13408         jumpToEnd.append(m_jit.branchIfNumber(valueRegs, scratch1GPR));
13409     else if (cachedTypeLocation-&gt;m_lastSeenType == TypeString) {
13410         MacroAssembler::Jump isNotCell = m_jit.branchIfNotCell(valueRegs);
13411         jumpToEnd.append(m_jit.branchIfString(valueRegs.payloadGPR()));
13412         isNotCell.link(&amp;m_jit);
13413     }
13414 
13415     // Load the TypeProfilerLog into Scratch2.
<a name="166" id="anc166"></a><span class="line-modified">13416     TypeProfilerLog* cachedTypeProfilerLog = vm().typeProfilerLog();</span>
13417     m_jit.move(TrustedImmPtr(cachedTypeProfilerLog), scratch2GPR);
13418 
13419     // Load the next LogEntry into Scratch1.
13420     m_jit.loadPtr(MacroAssembler::Address(scratch2GPR, TypeProfilerLog::currentLogEntryOffset()), scratch1GPR);
13421 
13422     // Store the JSValue onto the log entry.
13423     m_jit.storeValue(valueRegs, MacroAssembler::Address(scratch1GPR, TypeProfilerLog::LogEntry::valueOffset()));
13424 
13425     // Store the structureID of the cell if valueRegs is a cell, otherwise, store 0 on the log entry.
13426     MacroAssembler::Jump isNotCell = m_jit.branchIfNotCell(valueRegs);
13427     m_jit.load32(MacroAssembler::Address(valueRegs.payloadGPR(), JSCell::structureIDOffset()), scratch3GPR);
13428     m_jit.store32(scratch3GPR, MacroAssembler::Address(scratch1GPR, TypeProfilerLog::LogEntry::structureIDOffset()));
13429     MacroAssembler::Jump skipIsCell = m_jit.jump();
13430     isNotCell.link(&amp;m_jit);
13431     m_jit.store32(TrustedImm32(0), MacroAssembler::Address(scratch1GPR, TypeProfilerLog::LogEntry::structureIDOffset()));
13432     skipIsCell.link(&amp;m_jit);
13433 
13434     // Store the typeLocation on the log entry.
13435     m_jit.move(TrustedImmPtr(cachedTypeLocation), scratch3GPR);
13436     m_jit.storePtr(scratch3GPR, MacroAssembler::Address(scratch1GPR, TypeProfilerLog::LogEntry::locationOffset()));
13437 
13438     // Increment the current log entry.
13439     m_jit.addPtr(TrustedImm32(sizeof(TypeProfilerLog::LogEntry)), scratch1GPR);
13440     m_jit.storePtr(scratch1GPR, MacroAssembler::Address(scratch2GPR, TypeProfilerLog::currentLogEntryOffset()));
13441     MacroAssembler::Jump clearLog = m_jit.branchPtr(MacroAssembler::Equal, scratch1GPR, TrustedImmPtr(cachedTypeProfilerLog-&gt;logEndPtr()));
13442     addSlowPathGenerator(
13443         slowPathCall(clearLog, this, operationProcessTypeProfilerLogDFG, NoResult));
13444 
13445     jumpToEnd.link(&amp;m_jit);
13446 
13447     noResult(node);
13448 }
13449 
13450 void SpeculativeJIT::cachedPutById(CodeOrigin codeOrigin, GPRReg baseGPR, JSValueRegs valueRegs, GPRReg scratchGPR, unsigned identifierNumber, PutKind putKind, JITCompiler::Jump slowPathTarget, SpillRegistersMode spillMode)
13451 {
13452     RegisterSet usedRegisters = this-&gt;usedRegisters();
13453     if (spillMode == DontSpill) {
13454         // We&#39;ve already flushed registers to the stack, we don&#39;t need to spill these.
13455         usedRegisters.set(baseGPR, false);
13456         usedRegisters.set(valueRegs, false);
13457     }
13458     CallSiteIndex callSite = m_jit.recordCallSiteAndGenerateExceptionHandlingOSRExitIfNeeded(codeOrigin, m_stream-&gt;size());
13459     JITPutByIdGenerator gen(
13460         m_jit.codeBlock(), codeOrigin, callSite, usedRegisters,
13461         JSValueRegs::payloadOnly(baseGPR), valueRegs,
13462         scratchGPR, m_jit.ecmaModeFor(codeOrigin), putKind);
13463 
13464     gen.generateFastPath(m_jit);
13465 
13466     JITCompiler::JumpList slowCases;
13467     if (slowPathTarget.isSet())
13468         slowCases.append(slowPathTarget);
13469     slowCases.append(gen.slowPathJump());
13470 
13471     auto slowPath = slowPathCall(
13472         slowCases, this, gen.slowPathFunction(), NoResult, gen.stubInfo(), valueRegs,
13473         CCallHelpers::CellValue(baseGPR), identifierUID(identifierNumber));
13474 
13475     m_jit.addPutById(gen, slowPath.get());
13476     addSlowPathGenerator(WTFMove(slowPath));
13477 }
13478 
13479 void SpeculativeJIT::nonSpeculativeNonPeepholeCompare(Node* node, MacroAssembler::RelationalCondition cond, S_JITOperation_EJJ helperFunction)
13480 {
13481     ASSERT(node-&gt;isBinaryUseKind(UntypedUse));
13482     JSValueOperand arg1(this, node-&gt;child1());
13483     JSValueOperand arg2(this, node-&gt;child2());
13484 
13485     JSValueRegs arg1Regs = arg1.jsValueRegs();
13486     JSValueRegs arg2Regs = arg2.jsValueRegs();
13487 
13488     JITCompiler::JumpList slowPath;
13489 
13490     if (isKnownNotInteger(node-&gt;child1().node()) || isKnownNotInteger(node-&gt;child2().node())) {
13491         GPRFlushedCallResult result(this);
13492         GPRReg resultGPR = result.gpr();
13493 
13494         arg1.use();
13495         arg2.use();
13496 
13497         flushRegisters();
13498         callOperation(helperFunction, resultGPR, arg1Regs, arg2Regs);
13499         m_jit.exceptionCheck();
13500 
13501         unblessedBooleanResult(resultGPR, node, UseChildrenCalledExplicitly);
13502         return;
13503     }
13504 
13505     GPRTemporary result(this, Reuse, arg1, TagWord);
13506     GPRReg resultGPR = result.gpr();
13507 
13508     arg1.use();
13509     arg2.use();
13510 
13511     if (!isKnownInteger(node-&gt;child1().node()))
13512         slowPath.append(m_jit.branchIfNotInt32(arg1Regs));
13513     if (!isKnownInteger(node-&gt;child2().node()))
13514         slowPath.append(m_jit.branchIfNotInt32(arg2Regs));
13515 
13516     m_jit.compare32(cond, arg1Regs.payloadGPR(), arg2Regs.payloadGPR(), resultGPR);
13517 
13518     if (!isKnownInteger(node-&gt;child1().node()) || !isKnownInteger(node-&gt;child2().node()))
13519         addSlowPathGenerator(slowPathCall(slowPath, this, helperFunction, resultGPR, arg1Regs, arg2Regs));
13520 
13521     unblessedBooleanResult(resultGPR, node, UseChildrenCalledExplicitly);
13522 }
13523 
13524 void SpeculativeJIT::nonSpeculativePeepholeBranch(Node* node, Node* branchNode, MacroAssembler::RelationalCondition cond, S_JITOperation_EJJ helperFunction)
13525 {
13526     BasicBlock* taken = branchNode-&gt;branchData()-&gt;taken.block;
13527     BasicBlock* notTaken = branchNode-&gt;branchData()-&gt;notTaken.block;
13528 
13529     JITCompiler::ResultCondition callResultCondition = JITCompiler::NonZero;
13530 
13531     // The branch instruction will branch to the taken block.
13532     // If taken is next, switch taken with notTaken &amp; invert the branch condition so we can fall through.
13533     if (taken == nextBlock()) {
13534         cond = JITCompiler::invert(cond);
13535         callResultCondition = JITCompiler::Zero;
13536         BasicBlock* tmp = taken;
13537         taken = notTaken;
13538         notTaken = tmp;
13539     }
13540 
13541     JSValueOperand arg1(this, node-&gt;child1());
13542     JSValueOperand arg2(this, node-&gt;child2());
13543     JSValueRegs arg1Regs = arg1.jsValueRegs();
13544     JSValueRegs arg2Regs = arg2.jsValueRegs();
13545 
13546     JITCompiler::JumpList slowPath;
13547 
13548     if (isKnownNotInteger(node-&gt;child1().node()) || isKnownNotInteger(node-&gt;child2().node())) {
13549         GPRFlushedCallResult result(this);
13550         GPRReg resultGPR = result.gpr();
13551 
13552         arg1.use();
13553         arg2.use();
13554 
13555         flushRegisters();
13556         callOperation(helperFunction, resultGPR, arg1Regs, arg2Regs);
13557         m_jit.exceptionCheck();
13558 
13559         branchTest32(callResultCondition, resultGPR, taken);
13560     } else {
13561         GPRTemporary result(this, Reuse, arg2, TagWord);
13562         GPRReg resultGPR = result.gpr();
13563 
13564         arg1.use();
13565         arg2.use();
13566 
13567         if (!isKnownInteger(node-&gt;child1().node()))
13568             slowPath.append(m_jit.branchIfNotInt32(arg1Regs));
13569         if (!isKnownInteger(node-&gt;child2().node()))
13570             slowPath.append(m_jit.branchIfNotInt32(arg2Regs));
13571 
13572         branch32(cond, arg1Regs.payloadGPR(), arg2Regs.payloadGPR(), taken);
13573 
13574         if (!isKnownInteger(node-&gt;child1().node()) || !isKnownInteger(node-&gt;child2().node())) {
13575             jump(notTaken, ForceJump);
13576 
13577             slowPath.link(&amp;m_jit);
13578 
13579             silentSpillAllRegisters(resultGPR);
13580             callOperation(helperFunction, resultGPR, arg1Regs, arg2Regs);
13581             silentFillAllRegisters();
13582             m_jit.exceptionCheck();
13583 
13584             branchTest32(callResultCondition, resultGPR, taken);
13585         }
13586     }
13587 
13588     jump(notTaken);
13589 
13590     m_indexInBlock = m_block-&gt;size() - 1;
13591     m_currentNode = branchNode;
13592 }
13593 
13594 void SpeculativeJIT::compileBigIntEquality(Node* node)
13595 {
13596     // FIXME: [ESNext][BigInt] Create specialized version of strict equals for BigIntUse
13597     // https://bugs.webkit.org/show_bug.cgi?id=182895
13598     SpeculateCellOperand left(this, node-&gt;child1());
13599     SpeculateCellOperand right(this, node-&gt;child2());
13600     GPRTemporary result(this, Reuse, left);
13601     GPRReg leftGPR = left.gpr();
13602     GPRReg rightGPR = right.gpr();
13603     GPRReg resultGPR = result.gpr();
13604 
13605     left.use();
13606     right.use();
13607 
13608     speculateBigInt(node-&gt;child1(), leftGPR);
13609     speculateBigInt(node-&gt;child2(), rightGPR);
13610 
13611     JITCompiler::Jump notEqualCase = m_jit.branchPtr(JITCompiler::NotEqual, leftGPR, rightGPR);
13612 
13613     m_jit.move(JITCompiler::TrustedImm32(1), resultGPR);
13614 
13615     JITCompiler::Jump done = m_jit.jump();
13616 
13617     notEqualCase.link(&amp;m_jit);
13618 
13619     silentSpillAllRegisters(resultGPR);
13620     callOperation(operationCompareStrictEqCell, resultGPR, leftGPR, rightGPR);
13621     silentFillAllRegisters();
13622 
13623     done.link(&amp;m_jit);
13624 
13625     unblessedBooleanResult(resultGPR, node, UseChildrenCalledExplicitly);
13626 }
13627 
13628 void SpeculativeJIT::compileMakeRope(Node* node)
13629 {
13630     ASSERT(node-&gt;child1().useKind() == KnownStringUse);
13631     ASSERT(node-&gt;child2().useKind() == KnownStringUse);
13632     ASSERT(!node-&gt;child3() || node-&gt;child3().useKind() == KnownStringUse);
13633 
13634     SpeculateCellOperand op1(this, node-&gt;child1());
13635     SpeculateCellOperand op2(this, node-&gt;child2());
13636     SpeculateCellOperand op3(this, node-&gt;child3());
13637     GPRReg opGPRs[3];
13638     unsigned numOpGPRs;
13639     opGPRs[0] = op1.gpr();
13640     opGPRs[1] = op2.gpr();
13641     if (node-&gt;child3()) {
13642         opGPRs[2] = op3.gpr();
13643         numOpGPRs = 3;
13644     } else {
13645         opGPRs[2] = InvalidGPRReg;
13646         numOpGPRs = 2;
13647     }
13648 
13649 #if CPU(ADDRESS64)
13650     Edge edges[3] = {
13651         node-&gt;child1(),
13652         node-&gt;child2(),
13653         node-&gt;child3()
13654     };
13655 
13656     GPRTemporary result(this);
13657     GPRTemporary allocator(this);
13658     GPRTemporary scratch(this);
13659     GPRTemporary scratch2(this);
13660     GPRReg resultGPR = result.gpr();
13661     GPRReg allocatorGPR = allocator.gpr();
13662     GPRReg scratchGPR = scratch.gpr();
13663     GPRReg scratch2GPR = scratch2.gpr();
13664 
13665     CCallHelpers::JumpList slowPath;
<a name="167" id="anc167"></a><span class="line-modified">13666     Allocator allocatorValue = allocatorForNonVirtualConcurrently&lt;JSRopeString&gt;(vm(), sizeof(JSRopeString), AllocatorForMode::AllocatorIfExists);</span>
<span class="line-modified">13667     emitAllocateJSCell(resultGPR, JITAllocator::constant(allocatorValue), allocatorGPR, TrustedImmPtr(m_jit.graph().registerStructure(vm().stringStructure.get())), scratchGPR, slowPath);</span>



13668 
<a name="168" id="anc168"></a><span class="line-modified">13669     // This puts nullptr for the first fiber. It makes visitChildren safe even if this JSRopeString is discarded due to the speculation failure in the following path.</span>
<span class="line-modified">13670     m_jit.storePtr(TrustedImmPtr(JSString::isRopeInPointer), CCallHelpers::Address(resultGPR, JSRopeString::offsetOfFiber0()));</span>












13671 
13672     {
<a name="169" id="anc169"></a><span class="line-modified">13673         if (JSString* string = edges[0]-&gt;dynamicCastConstant&lt;JSString*&gt;(vm())) {</span>
13674             m_jit.move(TrustedImm32(string-&gt;is8Bit() ? StringImpl::flagIs8Bit() : 0), scratchGPR);
13675             m_jit.move(TrustedImm32(string-&gt;length()), allocatorGPR);
13676         } else {
<a name="170" id="anc170"></a><span class="line-modified">13677             bool needsRopeCase = canBeRope(edges[0]);</span>
13678             m_jit.loadPtr(CCallHelpers::Address(opGPRs[0], JSString::offsetOfValue()), scratch2GPR);
13679             CCallHelpers::Jump isRope;
<a name="171" id="anc171"></a><span class="line-modified">13680             if (needsRopeCase)</span>
13681                 isRope = m_jit.branchIfRopeStringImpl(scratch2GPR);
13682 
13683             m_jit.load32(CCallHelpers::Address(scratch2GPR, StringImpl::flagsOffset()), scratchGPR);
13684             m_jit.load32(CCallHelpers::Address(scratch2GPR, StringImpl::lengthMemoryOffset()), allocatorGPR);
13685 
<a name="172" id="anc172"></a><span class="line-modified">13686             if (needsRopeCase) {</span>
13687                 auto done = m_jit.jump();
13688 
13689                 isRope.link(&amp;m_jit);
<a name="173" id="anc173"></a><span class="line-modified">13690                 m_jit.load32(CCallHelpers::Address(opGPRs[0], JSRopeString::offsetOfFlags()), scratchGPR);</span>
13691                 m_jit.load32(CCallHelpers::Address(opGPRs[0], JSRopeString::offsetOfLength()), allocatorGPR);
13692                 done.link(&amp;m_jit);
13693             }
13694         }
13695 
13696         if (!ASSERT_DISABLED) {
13697             CCallHelpers::Jump ok = m_jit.branch32(
13698                 CCallHelpers::GreaterThanOrEqual, allocatorGPR, TrustedImm32(0));
13699             m_jit.abortWithReason(DFGNegativeStringLength);
13700             ok.link(&amp;m_jit);
13701         }
13702     }
13703 
13704     for (unsigned i = 1; i &lt; numOpGPRs; ++i) {
<a name="174" id="anc174"></a><span class="line-modified">13705         if (JSString* string = edges[i]-&gt;dynamicCastConstant&lt;JSString*&gt;(vm())) {</span>
13706             m_jit.and32(TrustedImm32(string-&gt;is8Bit() ? StringImpl::flagIs8Bit() : 0), scratchGPR);
13707             speculationCheck(
13708                 Uncountable, JSValueSource(), nullptr,
13709                 m_jit.branchAdd32(
13710                     CCallHelpers::Overflow,
13711                     TrustedImm32(string-&gt;length()), allocatorGPR));
13712         } else {
<a name="175" id="anc175"></a><span class="line-modified">13713             bool needsRopeCase = canBeRope(edges[i]);</span>
13714             m_jit.loadPtr(CCallHelpers::Address(opGPRs[i], JSString::offsetOfValue()), scratch2GPR);
13715             CCallHelpers::Jump isRope;
<a name="176" id="anc176"></a><span class="line-modified">13716             if (needsRopeCase)</span>
13717                 isRope = m_jit.branchIfRopeStringImpl(scratch2GPR);
13718 
<a name="177" id="anc177"></a><span class="line-modified">13719             m_jit.and32(CCallHelpers::Address(scratch2GPR, StringImpl::flagsOffset()), scratchGPR);</span>
13720             speculationCheck(
13721                 Uncountable, JSValueSource(), nullptr,
13722                 m_jit.branchAdd32(
13723                     CCallHelpers::Overflow,
13724                     CCallHelpers::Address(scratch2GPR, StringImpl::lengthMemoryOffset()), allocatorGPR));
<a name="178" id="anc178"></a><span class="line-modified">13725             if (needsRopeCase) {</span>
13726                 auto done = m_jit.jump();
13727 
13728                 isRope.link(&amp;m_jit);
<a name="179" id="anc179"></a><span class="line-modified">13729                 m_jit.and32(CCallHelpers::Address(opGPRs[i], JSRopeString::offsetOfFlags()), scratchGPR);</span>
13730                 m_jit.load32(CCallHelpers::Address(opGPRs[i], JSRopeString::offsetOfLength()), scratch2GPR);
13731                 speculationCheck(
13732                     Uncountable, JSValueSource(), nullptr,
13733                     m_jit.branchAdd32(
13734                         CCallHelpers::Overflow, scratch2GPR, allocatorGPR));
13735                 done.link(&amp;m_jit);
13736             }
13737         }
13738     }
<a name="180" id="anc180"></a><span class="line-modified">13739 </span>
13740     if (!ASSERT_DISABLED) {
13741         CCallHelpers::Jump ok = m_jit.branch32(
13742             CCallHelpers::GreaterThanOrEqual, allocatorGPR, TrustedImm32(0));
13743         m_jit.abortWithReason(DFGNegativeStringLength);
13744         ok.link(&amp;m_jit);
13745     }
<a name="181" id="anc181"></a><span class="line-modified">13746 </span>
<span class="line-added">13747     static_assert(StringImpl::flagIs8Bit() == JSRopeString::is8BitInPointer, &quot;&quot;);</span>
<span class="line-added">13748     m_jit.and32(TrustedImm32(StringImpl::flagIs8Bit()), scratchGPR);</span>
<span class="line-added">13749     m_jit.orPtr(opGPRs[0], scratchGPR);</span>
<span class="line-added">13750     m_jit.orPtr(TrustedImmPtr(JSString::isRopeInPointer), scratchGPR);</span>
<span class="line-added">13751     m_jit.storePtr(scratchGPR, CCallHelpers::Address(resultGPR, JSRopeString::offsetOfFiber0()));</span>
<span class="line-added">13752 </span>
<span class="line-added">13753     m_jit.move(opGPRs[1], scratchGPR);</span>
<span class="line-added">13754     m_jit.lshiftPtr(TrustedImm32(32), scratchGPR);</span>
<span class="line-added">13755     m_jit.orPtr(allocatorGPR, scratchGPR);</span>
<span class="line-added">13756     m_jit.storePtr(scratchGPR, CCallHelpers::Address(resultGPR, JSRopeString::offsetOfFiber1()));</span>
<span class="line-added">13757 </span>
<span class="line-added">13758     if (numOpGPRs == 2) {</span>
<span class="line-added">13759         m_jit.move(opGPRs[1], scratchGPR);</span>
<span class="line-added">13760         m_jit.rshiftPtr(TrustedImm32(32), scratchGPR);</span>
<span class="line-added">13761         m_jit.storePtr(scratchGPR, CCallHelpers::Address(resultGPR, JSRopeString::offsetOfFiber2()));</span>
<span class="line-added">13762     } else {</span>
<span class="line-added">13763         m_jit.move(opGPRs[1], scratchGPR);</span>
<span class="line-added">13764         m_jit.rshiftPtr(TrustedImm32(32), scratchGPR);</span>
<span class="line-added">13765         m_jit.move(opGPRs[2], scratch2GPR);</span>
<span class="line-added">13766         m_jit.lshiftPtr(TrustedImm32(16), scratch2GPR);</span>
<span class="line-added">13767         m_jit.orPtr(scratch2GPR, scratchGPR);</span>
<span class="line-added">13768         m_jit.storePtr(scratchGPR, CCallHelpers::Address(resultGPR, JSRopeString::offsetOfFiber2()));</span>
<span class="line-added">13769     }</span>
<span class="line-added">13770 </span>
13771     auto isNonEmptyString = m_jit.branchTest32(CCallHelpers::NonZero, allocatorGPR);
13772 
<a name="182" id="anc182"></a><span class="line-modified">13773     m_jit.move(TrustedImmPtr::weakPointer(m_jit.graph(), jsEmptyString(m_jit.graph().m_vm)), resultGPR);</span>
13774 
13775     isNonEmptyString.link(&amp;m_jit);
<a name="183" id="anc183"></a><span class="line-modified">13776     m_jit.mutatorFence(vm());</span>
13777 
13778     switch (numOpGPRs) {
13779     case 2:
13780         addSlowPathGenerator(slowPathCall(
13781             slowPath, this, operationMakeRope2, resultGPR, opGPRs[0], opGPRs[1]));
13782         break;
13783     case 3:
13784         addSlowPathGenerator(slowPathCall(
13785             slowPath, this, operationMakeRope3, resultGPR, opGPRs[0], opGPRs[1], opGPRs[2]));
13786         break;
13787     default:
13788         RELEASE_ASSERT_NOT_REACHED();
13789         break;
13790     }
13791 
13792     cellResult(resultGPR, node);
13793 #else
13794     flushRegisters();
13795     GPRFlushedCallResult result(this);
13796     GPRReg resultGPR = result.gpr();
13797     switch (numOpGPRs) {
13798     case 2:
13799         callOperation(operationMakeRope2, resultGPR, opGPRs[0], opGPRs[1]);
13800         m_jit.exceptionCheck();
13801         break;
13802     case 3:
13803         callOperation(operationMakeRope3, resultGPR, opGPRs[0], opGPRs[1], opGPRs[2]);
13804         m_jit.exceptionCheck();
13805         break;
13806     default:
13807         RELEASE_ASSERT_NOT_REACHED();
13808         break;
13809     }
13810 
13811     cellResult(resultGPR, node);
13812 #endif
13813 }
13814 
13815 } } // namespace JSC::DFG
13816 
13817 #endif
<a name="184" id="anc184"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="184" type="hidden" />
</body>
</html>