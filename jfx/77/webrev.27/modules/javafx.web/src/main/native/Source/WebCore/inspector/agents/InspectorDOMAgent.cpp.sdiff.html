<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/inspector/agents/InspectorDOMAgent.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="InspectorCanvasAgent.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="InspectorDOMAgent.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/inspector/agents/InspectorDOMAgent.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (C) 2009-2017 Apple Inc. All rights reserved.</span>
   3  * Copyright (C) 2011 Google Inc. All rights reserved.
   4  * Copyright (C) 2009 Joseph Pecoraro
   5  *
   6  * Redistribution and use in source and binary forms, with or without
   7  * modification, are permitted provided that the following conditions
   8  * are met:
   9  *
  10  * 1.  Redistributions of source code must retain the above copyright
  11  *     notice, this list of conditions and the following disclaimer.
  12  * 2.  Redistributions in binary form must reproduce the above copyright
  13  *     notice, this list of conditions and the following disclaimer in the
  14  *     documentation and/or other materials provided with the distribution.
  15  * 3.  Neither the name of Apple Inc. (&quot;Apple&quot;) nor the names of
  16  *     its contributors may be used to endorse or promote products derived
  17  *     from this software without specific prior written permission.
  18  *
  19  * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS &quot;AS IS&quot; AND ANY
  20  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  21  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  22  * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
</pre>
<hr />
<pre>
  42 #include &quot;CSSStyleRule.h&quot;
  43 #include &quot;CSSStyleSheet.h&quot;
  44 #include &quot;CharacterData.h&quot;
  45 #include &quot;CommandLineAPIHost.h&quot;
  46 #include &quot;ContainerNode.h&quot;
  47 #include &quot;Cookie.h&quot;
  48 #include &quot;CookieJar.h&quot;
  49 #include &quot;DOMEditor.h&quot;
  50 #include &quot;DOMException.h&quot;
  51 #include &quot;DOMPatchSupport.h&quot;
  52 #include &quot;DOMWindow.h&quot;
  53 #include &quot;Document.h&quot;
  54 #include &quot;DocumentType.h&quot;
  55 #include &quot;Editing.h&quot;
  56 #include &quot;Element.h&quot;
  57 #include &quot;Event.h&quot;
  58 #include &quot;EventListener.h&quot;
  59 #include &quot;EventNames.h&quot;
  60 #include &quot;Frame.h&quot;
  61 #include &quot;FrameTree.h&quot;


  62 #include &quot;HTMLElement.h&quot;
  63 #include &quot;HTMLFrameOwnerElement.h&quot;
  64 #include &quot;HTMLMediaElement.h&quot;
  65 #include &quot;HTMLNames.h&quot;
  66 #include &quot;HTMLParserIdioms.h&quot;
  67 #include &quot;HTMLScriptElement.h&quot;
  68 #include &quot;HTMLStyleElement.h&quot;
  69 #include &quot;HTMLTemplateElement.h&quot;
  70 #include &quot;HTMLVideoElement.h&quot;
  71 #include &quot;HitTestResult.h&quot;

  72 #include &quot;InspectorClient.h&quot;
  73 #include &quot;InspectorController.h&quot;
  74 #include &quot;InspectorHistory.h&quot;
  75 #include &quot;InspectorNodeFinder.h&quot;
  76 #include &quot;InspectorOverlay.h&quot;
  77 #include &quot;InspectorPageAgent.h&quot;
  78 #include &quot;InstrumentingAgents.h&quot;
  79 #include &quot;IntRect.h&quot;
  80 #include &quot;JSDOMBindingSecurity.h&quot;
  81 #include &quot;JSEventListener.h&quot;
  82 #include &quot;JSNode.h&quot;
  83 #include &quot;MutationEvent.h&quot;
  84 #include &quot;Node.h&quot;
  85 #include &quot;NodeList.h&quot;
  86 #include &quot;Page.h&quot;
  87 #include &quot;Pasteboard.h&quot;
  88 #include &quot;PseudoElement.h&quot;
  89 #include &quot;RenderStyle.h&quot;
  90 #include &quot;RenderStyleConstants.h&quot;
  91 #include &quot;ScriptState.h&quot;
</pre>
<hr />
<pre>
 233     {
 234         return this == &amp;other;
 235     }
 236 
 237     void handleEvent(ScriptExecutionContext&amp;, Event&amp; event) final
 238     {
 239         if (!is&lt;Node&gt;(event.target()) || m_domAgent.m_dispatchedEvents.contains(&amp;event))
 240             return;
 241 
 242         auto* node = downcast&lt;Node&gt;(event.target());
 243         int nodeId = m_domAgent.pushNodePathToFrontend(node);
 244         if (!nodeId)
 245             return;
 246 
 247         m_domAgent.m_dispatchedEvents.add(&amp;event);
 248 
 249         RefPtr&lt;JSON::Object&gt; data = JSON::Object::create();
 250 
 251 #if ENABLE(FULLSCREEN_API)
 252         if (event.type() == eventNames().webkitfullscreenchangeEvent)
<span class="line-modified"> 253             data-&gt;setBoolean(&quot;enabled&quot;_s, !!node-&gt;document().webkitFullscreenElement());</span>
 254 #endif // ENABLE(FULLSCREEN_API)
 255 
 256         auto timestamp = m_domAgent.m_environment.executionStopwatch()-&gt;elapsedTime().seconds();
 257         m_domAgent.m_frontendDispatcher-&gt;didFireEvent(nodeId, event.type(), timestamp, data-&gt;size() ? WTFMove(data) : nullptr);
 258     }
 259 
 260 private:
 261     EventFiredCallback(InspectorDOMAgent&amp; domAgent)
 262         : EventListener(EventListener::CPPEventListenerType)
 263         , m_domAgent(domAgent)
 264     {
 265     }
 266 
 267     InspectorDOMAgent&amp; m_domAgent;
 268 };
 269 
 270 String InspectorDOMAgent::toErrorString(ExceptionCode ec)
 271 {
 272     return ec ? String(DOMException::name(ec)) : emptyString();
 273 }
 274 
 275 String InspectorDOMAgent::toErrorString(Exception&amp;&amp; exception)
 276 {
 277     return DOMException::name(exception.code());
 278 }
 279 
<span class="line-modified"> 280 InspectorDOMAgent::InspectorDOMAgent(WebAgentContext&amp; context, InspectorPageAgent* pageAgent, InspectorOverlay* overlay)</span>
 281     : InspectorAgentBase(&quot;DOM&quot;_s, context)
 282     , m_injectedScriptManager(context.injectedScriptManager)
<span class="line-modified"> 283     , m_frontendDispatcher(std::make_unique&lt;Inspector::DOMFrontendDispatcher&gt;(context.frontendRouter))</span>
 284     , m_backendDispatcher(Inspector::DOMBackendDispatcher::create(context.backendDispatcher, this))
<span class="line-modified"> 285     , m_pageAgent(pageAgent)</span>
 286     , m_overlay(overlay)
 287 #if ENABLE(VIDEO)
 288     , m_mediaMetricsTimer(*this, &amp;InspectorDOMAgent::mediaMetricsTimerFired)
 289 #endif
 290 {
 291 }
 292 
<span class="line-modified"> 293 InspectorDOMAgent::~InspectorDOMAgent()</span>
<span class="line-removed"> 294 {</span>
<span class="line-removed"> 295     reset();</span>
<span class="line-removed"> 296     ASSERT(!m_searchingForNode);</span>
<span class="line-removed"> 297 }</span>
 298 
 299 void InspectorDOMAgent::didCreateFrontendAndBackend(Inspector::FrontendRouter*, Inspector::BackendDispatcher*)
 300 {
<span class="line-modified"> 301     m_history = std::make_unique&lt;InspectorHistory&gt;();</span>
<span class="line-modified"> 302     m_domEditor = std::make_unique&lt;DOMEditor&gt;(*m_history);</span>
 303 
 304     m_instrumentingAgents.setInspectorDOMAgent(this);
<span class="line-modified"> 305     m_document = m_pageAgent-&gt;mainFrame().document();</span>
 306 
 307 #if ENABLE(VIDEO)
 308     if (m_document)
 309         addEventListenersToNode(*m_document);
 310 
 311     for (auto* mediaElement : HTMLMediaElement::allMediaElements())
 312         addEventListenersToNode(*mediaElement);
 313 #endif
<span class="line-removed"> 314 </span>
<span class="line-removed"> 315     if (m_nodeToFocus)</span>
<span class="line-removed"> 316         focusNode();</span>
 317 }
 318 
 319 void InspectorDOMAgent::willDestroyFrontendAndBackend(Inspector::DisconnectReason)
 320 {
 321     m_history.reset();
 322     m_domEditor.reset();

 323     m_mousedOverNode = nullptr;

 324 
<span class="line-modified"> 325     ErrorString unused;</span>
<span class="line-modified"> 326     setSearchingForNode(unused, false, nullptr);</span>
<span class="line-modified"> 327     hideHighlight(unused);</span>
 328 
 329     m_instrumentingAgents.setInspectorDOMAgent(nullptr);
 330     m_documentRequested = false;
 331     reset();
 332 }
 333 
 334 Vector&lt;Document*&gt; InspectorDOMAgent::documents()
 335 {
 336     Vector&lt;Document*&gt; result;
 337     for (Frame* frame = m_document-&gt;frame(); frame; frame = frame-&gt;tree().traverseNext()) {
 338         Document* document = frame-&gt;document();
 339         if (!document)
 340             continue;
 341         result.append(document);
 342     }
 343     return result;
 344 }
 345 
 346 void InspectorDOMAgent::reset()
 347 {
 348     if (m_history)
 349         m_history-&gt;reset();
 350     m_searchResults.clear();
 351     discardBindings();
 352     if (m_revalidateStyleAttrTask)
 353         m_revalidateStyleAttrTask-&gt;reset();
 354     m_document = nullptr;
 355 }
 356 
<span class="line-removed"> 357 void InspectorDOMAgent::setDOMListener(DOMListener* listener)</span>
<span class="line-removed"> 358 {</span>
<span class="line-removed"> 359     m_domListener = listener;</span>
<span class="line-removed"> 360 }</span>
<span class="line-removed"> 361 </span>
 362 void InspectorDOMAgent::setDocument(Document* document)
 363 {
 364     if (document == m_document.get())
 365         return;
 366 
 367     reset();
 368 
 369     m_document = document;
 370 
 371     if (!m_documentRequested)
 372         return;
 373 
 374     // Immediately communicate null document or document that has finished loading.
 375     if (!document || !document-&gt;parsing())
 376         m_frontendDispatcher-&gt;documentUpdated();
 377 }
 378 
 379 void InspectorDOMAgent::releaseDanglingNodes()
 380 {
 381     m_danglingNodeToIdMaps.clear();
</pre>
<hr />
<pre>
 401 
 402     m_idToNode.remove(id);
 403 
 404     if (node-&gt;isFrameOwnerElement()) {
 405         const HTMLFrameOwnerElement* frameOwner = static_cast&lt;const HTMLFrameOwnerElement*&gt;(node);
 406         if (Document* contentDocument = frameOwner-&gt;contentDocument())
 407             unbind(contentDocument, nodesMap);
 408     }
 409 
 410     if (is&lt;Element&gt;(*node)) {
 411         Element&amp; element = downcast&lt;Element&gt;(*node);
 412         if (ShadowRoot* root = element.shadowRoot())
 413             unbind(root, nodesMap);
 414         if (PseudoElement* beforeElement = element.beforePseudoElement())
 415             unbind(beforeElement, nodesMap);
 416         if (PseudoElement* afterElement = element.afterPseudoElement())
 417             unbind(afterElement, nodesMap);
 418     }
 419 
 420     nodesMap-&gt;remove(node);
<span class="line-modified"> 421     if (m_domListener)</span>
<span class="line-modified"> 422         m_domListener-&gt;didRemoveDOMNode(*node, id);</span>

 423 
 424     if (m_childrenRequested.remove(id)) {
 425         // FIXME: Would be better to do this iteratively rather than recursively.
 426         for (Node* child = innerFirstChild(node); child; child = innerNextSibling(child))
 427             unbind(child, nodesMap);
 428     }
 429 }
 430 
 431 Node* InspectorDOMAgent::assertNode(ErrorString&amp; errorString, int nodeId)
 432 {
 433     Node* node = nodeForId(nodeId);
 434     if (!node) {
<span class="line-modified"> 435         errorString = &quot;Could not find node with given id&quot;_s;</span>
 436         return nullptr;
 437     }
 438     return node;
 439 }
 440 
 441 Document* InspectorDOMAgent::assertDocument(ErrorString&amp; errorString, int nodeId)
 442 {
 443     Node* node = assertNode(errorString, nodeId);
 444     if (!node)
 445         return nullptr;
<span class="line-modified"> 446     if (!is&lt;Document&gt;(*node)) {</span>
<span class="line-modified"> 447         errorString = &quot;Document is not available&quot;_s;</span>
 448         return nullptr;
 449     }
 450     return downcast&lt;Document&gt;(node);
 451 }
 452 
 453 Element* InspectorDOMAgent::assertElement(ErrorString&amp; errorString, int nodeId)
 454 {
 455     Node* node = assertNode(errorString, nodeId);
 456     if (!node)
 457         return nullptr;
<span class="line-modified"> 458     if (!is&lt;Element&gt;(*node)) {</span>
<span class="line-modified"> 459         errorString = &quot;Node is not an Element&quot;_s;</span>
 460         return nullptr;
 461     }
 462     return downcast&lt;Element&gt;(node);
 463 }
 464 
 465 Node* InspectorDOMAgent::assertEditableNode(ErrorString&amp; errorString, int nodeId)
 466 {
 467     Node* node = assertNode(errorString, nodeId);
 468     if (!node)
 469         return nullptr;
 470     if (node-&gt;isInUserAgentShadowTree()) {
<span class="line-modified"> 471         errorString = &quot;Cannot edit nodes in user agent shadow trees&quot;_s;</span>
 472         return nullptr;
 473     }
 474     if (node-&gt;isPseudoElement()) {
<span class="line-modified"> 475         errorString = &quot;Cannot edit pseudo elements&quot;_s;</span>
 476         return nullptr;
 477     }
 478     return node;
 479 }
 480 
 481 Element* InspectorDOMAgent::assertEditableElement(ErrorString&amp; errorString, int nodeId)
 482 {
<span class="line-modified"> 483     Element* element = assertElement(errorString, nodeId);</span>
<span class="line-modified"> 484     if (!element)</span>
<span class="line-removed"> 485         return nullptr;</span>
<span class="line-removed"> 486     if (element-&gt;isInUserAgentShadowTree()) {</span>
<span class="line-removed"> 487         errorString = &quot;Cannot edit elements in user agent shadow trees&quot;_s;</span>
 488         return nullptr;
<span class="line-modified"> 489     }</span>
<span class="line-modified"> 490     if (element-&gt;isPseudoElement()) {</span>
<span class="line-removed"> 491         errorString = &quot;Cannot edit pseudo elements&quot;_s;</span>
 492         return nullptr;
 493     }
<span class="line-modified"> 494     return element;</span>
 495 }
 496 
 497 void InspectorDOMAgent::getDocument(ErrorString&amp; errorString, RefPtr&lt;Inspector::Protocol::DOM::Node&gt;&amp; root)
 498 {
 499     m_documentRequested = true;
 500 
 501     if (!m_document) {
<span class="line-modified"> 502         errorString = &quot;Document is not available&quot;_s;</span>
 503         return;
 504     }
 505 
 506     // Reset backend state.
 507     RefPtr&lt;Document&gt; document = m_document;
 508     reset();
 509     m_document = document;
 510 
 511     root = buildObjectForNode(m_document.get(), 2, &amp;m_documentNodeToIdMap);



 512 }
 513 
 514 void InspectorDOMAgent::pushChildNodesToFrontend(int nodeId, int depth)
 515 {
 516     Node* node = nodeForId(nodeId);
 517     if (!node || (node-&gt;nodeType() != Node::ELEMENT_NODE &amp;&amp; node-&gt;nodeType() != Node::DOCUMENT_NODE &amp;&amp; node-&gt;nodeType() != Node::DOCUMENT_FRAGMENT_NODE))
 518         return;
 519 
 520     NodeToIdMap* nodeMap = m_idToNodesMap.get(nodeId);
 521 
 522     if (m_childrenRequested.contains(nodeId)) {
 523         if (depth &lt;= 1)
 524             return;
 525 
 526         depth--;
 527 
 528         for (node = innerFirstChild(node); node; node = innerNextSibling(node)) {
 529             int childNodeId = nodeMap-&gt;get(node);
 530             ASSERT(childNodeId);
 531             pushChildNodesToFrontend(childNodeId, depth);
</pre>
<hr />
<pre>
 537     auto children = buildArrayForContainerChildren(node, depth, nodeMap);
 538     m_frontendDispatcher-&gt;setChildNodes(nodeId, WTFMove(children));
 539 }
 540 
 541 void InspectorDOMAgent::discardBindings()
 542 {
 543     m_documentNodeToIdMap.clear();
 544     m_idToNode.clear();
 545     m_dispatchedEvents.clear();
 546     m_eventListenerEntries.clear();
 547     releaseDanglingNodes();
 548     m_childrenRequested.clear();
 549 }
 550 
 551 int InspectorDOMAgent::pushNodeToFrontend(ErrorString&amp; errorString, int documentNodeId, Node* nodeToPush)
 552 {
 553     Document* document = assertDocument(errorString, documentNodeId);
 554     if (!document)
 555         return 0;
 556     if (&amp;nodeToPush-&gt;document() != document) {
<span class="line-modified"> 557         errorString = &quot;Node is not part of the document with given id&quot;_s;</span>
 558         return 0;
 559     }
 560 
 561     return pushNodePathToFrontend(nodeToPush);
 562 }
 563 
 564 Node* InspectorDOMAgent::nodeForId(int id)
 565 {
 566     if (!m_idToNode.isValidKey(id))
 567         return nullptr;
 568 
 569     return m_idToNode.get(id);
 570 }
 571 
 572 void InspectorDOMAgent::requestChildNodes(ErrorString&amp; errorString, int nodeId, const int* depth)
 573 {
 574     int sanitizedDepth;
 575 
 576     if (!depth)
 577         sanitizedDepth = 1;
 578     else if (*depth == -1)
 579         sanitizedDepth = INT_MAX;
 580     else if (*depth &gt; 0)
 581         sanitizedDepth = *depth;
 582     else {
<span class="line-modified"> 583         errorString = &quot;Please provide a positive integer as a depth or -1 for entire subtree&quot;_s;</span>
 584         return;
 585     }
 586 
 587     pushChildNodesToFrontend(nodeId, sanitizedDepth);
 588 }
 589 
 590 void InspectorDOMAgent::querySelector(ErrorString&amp; errorString, int nodeId, const String&amp; selectors, int* elementId)
 591 {
 592     *elementId = 0;
 593     Node* node = assertNode(errorString, nodeId);
 594     if (!node)
 595         return;
 596     if (!is&lt;ContainerNode&gt;(*node)) {
 597         assertElement(errorString, nodeId);
 598         return;
 599     }
 600 
 601     auto queryResult = downcast&lt;ContainerNode&gt;(*node).querySelector(selectors);
 602     if (queryResult.hasException()) {
<span class="line-modified"> 603         errorString = &quot;DOM Error while querying&quot;_s;</span>
 604         return;
 605     }
 606 
 607     if (auto* element = queryResult.releaseReturnValue())
 608         *elementId = pushNodePathToFrontend(element);
 609 }
 610 
 611 void InspectorDOMAgent::querySelectorAll(ErrorString&amp; errorString, int nodeId, const String&amp; selectors, RefPtr&lt;JSON::ArrayOf&lt;int&gt;&gt;&amp; result)
 612 {
 613     Node* node = assertNode(errorString, nodeId);
 614     if (!node)
 615         return;
 616     if (!is&lt;ContainerNode&gt;(*node)) {
 617         assertElement(errorString, nodeId);
 618         return;
 619     }
 620 
 621     auto queryResult = downcast&lt;ContainerNode&gt;(*node).querySelectorAll(selectors);
 622     if (queryResult.hasException()) {
<span class="line-modified"> 623         errorString = &quot;DOM Error while querying&quot;_s;</span>
 624         return;
 625     }
 626 
 627     auto nodes = queryResult.releaseReturnValue();
 628     result = JSON::ArrayOf&lt;int&gt;::create();
 629     for (unsigned i = 0; i &lt; nodes-&gt;length(); ++i)
 630         result-&gt;addItem(pushNodePathToFrontend(nodes-&gt;item(i)));
 631 }
 632 
 633 int InspectorDOMAgent::pushNodePathToFrontend(Node* nodeToPush)
 634 {
 635     ASSERT(nodeToPush);  // Invalid input
 636 
 637     if (!m_document)
 638         return 0;
 639     if (!m_documentNodeToIdMap.contains(m_document))
 640         return 0;
 641 
 642     // Return id in case the node is known.
 643     int result = m_documentNodeToIdMap.get(nodeToPush);
 644     if (result)
 645         return result;
 646 
 647     Node* node = nodeToPush;
 648     Vector&lt;Node*&gt; path;
 649     NodeToIdMap* danglingMap = 0;
 650 
 651     while (true) {
 652         Node* parent = innerParentNode(node);
 653         if (!parent) {
 654             // Node being pushed is detached -&gt; push subtree root.
<span class="line-modified"> 655             auto newMap = std::make_unique&lt;NodeToIdMap&gt;();</span>
 656             danglingMap = newMap.get();
 657             m_danglingNodeToIdMaps.append(newMap.release());
 658             auto children = JSON::ArrayOf&lt;Inspector::Protocol::DOM::Node&gt;::create();
 659             children-&gt;addItem(buildObjectForNode(node, 0, danglingMap));
 660             m_frontendDispatcher-&gt;setChildNodes(0, WTFMove(children));
 661             break;
 662         } else {
 663             path.append(parent);
 664             if (m_documentNodeToIdMap.get(parent))
 665                 break;
 666             else
 667                 node = parent;
 668         }
 669     }
 670 
 671     NodeToIdMap* map = danglingMap ? danglingMap : &amp;m_documentNodeToIdMap;
 672     for (int i = path.size() - 1; i &gt;= 0; --i) {
 673         int nodeId = map-&gt;get(path.at(i));
 674         ASSERT(nodeId);
 675         pushChildNodesToFrontend(nodeId);
</pre>
<hr />
<pre>
 689         return;
 690 
 691     m_domEditor-&gt;setAttribute(*element, name, value, errorString);
 692 }
 693 
 694 void InspectorDOMAgent::setAttributesAsText(ErrorString&amp; errorString, int elementId, const String&amp; text, const String* name)
 695 {
 696     Element* element = assertEditableElement(errorString, elementId);
 697     if (!element)
 698         return;
 699 
 700     auto parsedElement = createHTMLElement(element-&gt;document(), spanTag);
 701     auto result = parsedElement.get().setInnerHTML(&quot;&lt;span &quot; + text + &quot;&gt;&lt;/span&gt;&quot;);
 702     if (result.hasException()) {
 703         errorString = toErrorString(result.releaseException());
 704         return;
 705     }
 706 
 707     Node* child = parsedElement-&gt;firstChild();
 708     if (!child) {
<span class="line-modified"> 709         errorString = &quot;Could not parse value as attributes&quot;_s;</span>
 710         return;
 711     }
 712 
 713     Element* childElement = downcast&lt;Element&gt;(child);
 714     if (!childElement-&gt;hasAttributes() &amp;&amp; name) {
 715         m_domEditor-&gt;removeAttribute(*element, *name, errorString);
 716         return;
 717     }
 718 
 719     bool foundOriginalAttribute = false;
 720     for (const Attribute&amp; attribute : childElement-&gt;attributesIterator()) {
 721         // Add attribute pair
 722         foundOriginalAttribute = foundOriginalAttribute || (name &amp;&amp; attribute.name().toString() == *name);
 723         if (!m_domEditor-&gt;setAttribute(*element, attribute.name().toString(), attribute.value(), errorString))
 724             return;
 725     }
 726 
 727     if (!foundOriginalAttribute &amp;&amp; name &amp;&amp; !name-&gt;stripWhiteSpace().isEmpty())
 728         m_domEditor-&gt;removeAttribute(*element, *name, errorString);
 729 }
</pre>
<hr />
<pre>
 792     Node* node = assertNode(errorString, nodeId);
 793     if (!node)
 794         return;
 795 
 796     *outerHTML = serializeFragment(*node, SerializedNodes::SubtreeIncludingNode);
 797 }
 798 
 799 void InspectorDOMAgent::setOuterHTML(ErrorString&amp; errorString, int nodeId, const String&amp; outerHTML)
 800 {
 801     if (!nodeId) {
 802         DOMPatchSupport { *m_domEditor, *m_document }.patchDocument(outerHTML);
 803         return;
 804     }
 805 
 806     Node* node = assertEditableNode(errorString, nodeId);
 807     if (!node)
 808         return;
 809 
 810     Document&amp; document = node-&gt;document();
 811     if (!document.isHTMLDocument() &amp;&amp; !document.isXMLDocument()) {
<span class="line-modified"> 812         errorString = &quot;Not an HTML/XML document&quot;_s;</span>
 813         return;
 814     }
 815 
 816     Node* newNode = nullptr;
 817     if (!m_domEditor-&gt;setOuterHTML(*node, outerHTML, newNode, errorString))
 818         return;
 819 
 820     if (!newNode) {
 821         // The only child node has been deleted.
 822         return;
 823     }
 824 
 825     int newId = pushNodePathToFrontend(newNode);
 826 
 827     bool childrenRequested = m_childrenRequested.contains(nodeId);
 828     if (childrenRequested)
 829         pushChildNodesToFrontend(newId);
 830 }
 831 
 832 void InspectorDOMAgent::insertAdjacentHTML(ErrorString&amp; errorString, int nodeId, const String&amp; position, const String&amp; html)
 833 {
 834     Node* node = assertEditableNode(errorString, nodeId);
 835     if (!node)
 836         return;
 837 
 838     if (!is&lt;Element&gt;(node)) {
<span class="line-modified"> 839         errorString = &quot;Can only call insertAdjacentHTML on Elements.&quot;_s;</span>
 840         return;
 841     }
 842 
 843     m_domEditor-&gt;insertAdjacentHTML(downcast&lt;Element&gt;(*node), position, html, errorString);
 844 }
 845 
 846 void InspectorDOMAgent::setNodeValue(ErrorString&amp; errorString, int nodeId, const String&amp; value)
 847 {
 848     Node* node = assertEditableNode(errorString, nodeId);
 849     if (!node)
 850         return;
 851 
 852     if (!is&lt;Text&gt;(*node)) {
<span class="line-modified"> 853         errorString = &quot;Can only set value of text nodes&quot;_s;</span>
 854         return;
 855     }
 856 
 857     m_domEditor-&gt;replaceWholeText(downcast&lt;Text&gt;(*node), value, errorString);
 858 }
 859 
 860 void InspectorDOMAgent::getSupportedEventNames(ErrorString&amp;, RefPtr&lt;JSON::ArrayOf&lt;String&gt;&gt;&amp; eventNames)
 861 {
 862     eventNames = JSON::ArrayOf&lt;String&gt;::create();
 863 
 864 #define DOM_EVENT_NAMES_ADD(name) eventNames-&gt;addItem(#name);
 865     DOM_EVENT_NAMES_FOR_EACH(DOM_EVENT_NAMES_ADD)
 866 #undef DOM_EVENT_NAMES_ADD
 867 }
 868 
<span class="line-modified"> 869 void InspectorDOMAgent::getEventListenersForNode(ErrorString&amp; errorString, int nodeId, const String* objectGroup, RefPtr&lt;JSON::ArrayOf&lt;Inspector::Protocol::DOM::EventListener&gt;&gt;&amp; listenersArray)</span>










 870 {
 871     listenersArray = JSON::ArrayOf&lt;Inspector::Protocol::DOM::EventListener&gt;::create();
<span class="line-modified"> 872     Node* node = assertNode(errorString, nodeId);</span>

 873     if (!node)
 874         return;














 875     Vector&lt;EventListenerInfo&gt; eventInformation;
<span class="line-modified"> 876     getEventListeners(node, eventInformation, true);</span>











 877 
 878     auto addListener = [&amp;] (RegisteredEventListener&amp; listener, const EventListenerInfo&amp; info) {
 879         int identifier = 0;
 880         bool disabled = false;
 881         bool hasBreakpoint = false;
 882 
 883         for (auto&amp; inspectorEventListener : m_eventListenerEntries.values()) {
<span class="line-modified"> 884             if (inspectorEventListener.matches(*info.node, info.eventType, listener.callback(), listener.useCapture())) {</span>
 885                 identifier = inspectorEventListener.identifier;
 886                 disabled = inspectorEventListener.disabled;
 887                 hasBreakpoint = inspectorEventListener.hasBreakpoint;
 888                 break;
 889             }
 890         }
 891 
 892         if (!identifier) {
<span class="line-modified"> 893             InspectorEventListener inspectorEventListener(m_lastEventListenerId++, *info.node, info.eventType, listener.callback(), listener.useCapture());</span>
 894 
 895             identifier = inspectorEventListener.identifier;
 896             disabled = inspectorEventListener.disabled;
 897             hasBreakpoint = inspectorEventListener.hasBreakpoint;
 898 
 899             m_eventListenerEntries.add(identifier, inspectorEventListener);
 900         }
 901 
<span class="line-modified"> 902         listenersArray-&gt;addItem(buildObjectForEventListener(listener, identifier, info.eventType, info.node, objectGroup, disabled, hasBreakpoint));</span>
 903     };
 904 
 905     // Get Capturing Listeners (in this order)
 906     size_t eventInformationLength = eventInformation.size();
 907     for (auto&amp; info : eventInformation) {
<span class="line-modified"> 908         for (auto&amp; listener : info.eventListenerVector) {</span>
 909             if (listener-&gt;useCapture())
 910                 addListener(*listener, info);
 911         }
 912     }
 913 
 914     // Get Bubbling Listeners (reverse order)
 915     for (size_t i = eventInformationLength; i; --i) {
 916         const EventListenerInfo&amp; info = eventInformation[i - 1];
<span class="line-modified"> 917         for (auto&amp; listener : info.eventListenerVector) {</span>
 918             if (!listener-&gt;useCapture())
 919                 addListener(*listener, info);
 920         }
 921     }
<span class="line-removed"> 922 }</span>
<span class="line-removed"> 923 </span>
<span class="line-removed"> 924 void InspectorDOMAgent::getEventListeners(Node* node, Vector&lt;EventListenerInfo&gt;&amp; eventInformation, bool includeAncestors)</span>
<span class="line-removed"> 925 {</span>
<span class="line-removed"> 926     // The Node&#39;s Ancestors including self.</span>
<span class="line-removed"> 927     Vector&lt;Node*&gt; ancestors;</span>
<span class="line-removed"> 928     // Push this node as the firs element.</span>
<span class="line-removed"> 929     ancestors.append(node);</span>
<span class="line-removed"> 930     if (includeAncestors) {</span>
<span class="line-removed"> 931         for (ContainerNode* ancestor = node-&gt;parentOrShadowHostNode(); ancestor; ancestor = ancestor-&gt;parentOrShadowHostNode())</span>
<span class="line-removed"> 932             ancestors.append(ancestor);</span>
<span class="line-removed"> 933     }</span>
 934 
<span class="line-modified"> 935     // Nodes and their Listeners for the concerned event types (order is top to bottom)</span>
<span class="line-modified"> 936     for (size_t i = ancestors.size(); i; --i) {</span>
<span class="line-removed"> 937         Node* ancestor = ancestors[i - 1];</span>
<span class="line-removed"> 938         EventTargetData* d = ancestor-&gt;eventTargetData();</span>
<span class="line-removed"> 939         if (!d)</span>
<span class="line-removed"> 940             continue;</span>
<span class="line-removed"> 941         // Get the list of event types this Node is concerned with</span>
<span class="line-removed"> 942         for (auto&amp; type : d-&gt;eventListenerMap.eventTypes()) {</span>
<span class="line-removed"> 943             auto&amp; listeners = ancestor-&gt;eventListeners(type);</span>
<span class="line-removed"> 944             EventListenerVector filteredListeners;</span>
<span class="line-removed"> 945             filteredListeners.reserveInitialCapacity(listeners.size());</span>
<span class="line-removed"> 946             for (auto&amp; listener : listeners) {</span>
<span class="line-removed"> 947                 if (listener-&gt;callback().type() == EventListener::JSEventListenerType)</span>
<span class="line-removed"> 948                     filteredListeners.uncheckedAppend(listener);</span>
<span class="line-removed"> 949             }</span>
<span class="line-removed"> 950             if (!filteredListeners.isEmpty())</span>
<span class="line-removed"> 951                 eventInformation.append(EventListenerInfo(ancestor, type, WTFMove(filteredListeners)));</span>
<span class="line-removed"> 952         }</span>
<span class="line-removed"> 953     }</span>
 954 }
 955 
 956 void InspectorDOMAgent::setEventListenerDisabled(ErrorString&amp; errorString, int eventListenerId, bool disabled)
 957 {
 958     auto it = m_eventListenerEntries.find(eventListenerId);
 959     if (it == m_eventListenerEntries.end()) {
<span class="line-modified"> 960         errorString = &quot;No event listener for given identifier.&quot;_s;</span>
 961         return;
 962     }
 963 
 964     it-&gt;value.disabled = disabled;
 965 }
 966 
 967 void InspectorDOMAgent::setBreakpointForEventListener(ErrorString&amp; errorString, int eventListenerId)
 968 {
 969     auto it = m_eventListenerEntries.find(eventListenerId);
 970     if (it == m_eventListenerEntries.end()) {
<span class="line-modified"> 971         errorString = &quot;No event listener for given identifier.&quot;_s;</span>
 972         return;
 973     }
 974 
 975     it-&gt;value.hasBreakpoint = true;
 976 }
 977 
 978 void InspectorDOMAgent::removeBreakpointForEventListener(ErrorString&amp; errorString, int eventListenerId)
 979 {
 980     auto it = m_eventListenerEntries.find(eventListenerId);
 981     if (it == m_eventListenerEntries.end()) {
<span class="line-modified"> 982         errorString = &quot;No event listener for given identifier.&quot;_s;</span>
 983         return;
 984     }
 985 
 986     it-&gt;value.hasBreakpoint = false;
 987 }
 988 
 989 void InspectorDOMAgent::getAccessibilityPropertiesForNode(ErrorString&amp; errorString, int nodeId, RefPtr&lt;Inspector::Protocol::DOM::AccessibilityProperties&gt;&amp; axProperties)
 990 {
 991     Node* node = assertNode(errorString, nodeId);
 992     if (!node)
 993         return;
 994 
 995     axProperties = buildObjectForAccessibilityProperties(node);
 996 }
 997 
<span class="line-modified"> 998 void InspectorDOMAgent::performSearch(ErrorString&amp; errorString, const String&amp; whitespaceTrimmedQuery, const JSON::Array* nodeIds, String* searchId, int* resultCount)</span>
 999 {
1000     // FIXME: Search works with node granularity - number of matches within node is not calculated.
<span class="line-modified">1001     InspectorNodeFinder finder(whitespaceTrimmedQuery);</span>
1002 
1003     if (nodeIds) {
1004         for (auto&amp; nodeValue : *nodeIds) {
1005             if (!nodeValue) {
<span class="line-modified">1006                 errorString = &quot;Invalid nodeIds item.&quot;_s;</span>
1007                 return;
1008             }
1009             int nodeId = 0;
1010             if (!nodeValue-&gt;asInteger(nodeId)) {
<span class="line-modified">1011                 errorString = &quot;Invalid nodeIds item type. Expecting integer types.&quot;_s;</span>
1012                 return;
1013             }
1014             Node* node = assertNode(errorString, nodeId);
1015             if (!node) {
1016                 // assertNode should have filled the errorString for us.
1017                 ASSERT(errorString.length());
1018                 return;
1019             }
1020             finder.performSearch(node);
1021         }
1022     } else {
1023         // There&#39;s no need to iterate the frames tree because
1024         // the search helper will go inside the frame owner elements.
1025         finder.performSearch(m_document.get());
1026     }
1027 
1028     *searchId = IdentifiersFactory::createIdentifier();
1029 
1030     auto&amp; resultsVector = m_searchResults.add(*searchId, Vector&lt;RefPtr&lt;Node&gt;&gt;()).iterator-&gt;value;
1031     for (auto&amp; result : finder.results())
1032         resultsVector.append(result);
1033 
1034     *resultCount = resultsVector.size();
1035 }
1036 
1037 void InspectorDOMAgent::getSearchResults(ErrorString&amp; errorString, const String&amp; searchId, int fromIndex, int toIndex, RefPtr&lt;JSON::ArrayOf&lt;int&gt;&gt;&amp; nodeIds)
1038 {
1039     SearchResults::iterator it = m_searchResults.find(searchId);
1040     if (it == m_searchResults.end()) {
<span class="line-modified">1041         errorString = &quot;No search session with given id found&quot;_s;</span>
1042         return;
1043     }
1044 
1045     int size = it-&gt;value.size();
1046     if (fromIndex &lt; 0 || toIndex &gt; size || fromIndex &gt;= toIndex) {
<span class="line-modified">1047         errorString = &quot;Invalid search result range&quot;_s;</span>
1048         return;
1049     }
1050 
1051     nodeIds = JSON::ArrayOf&lt;int&gt;::create();
1052     for (int i = fromIndex; i &lt; toIndex; ++i)
1053         nodeIds-&gt;addItem(pushNodePathToFrontend((it-&gt;value)[i].get()));
1054 }
1055 
1056 void InspectorDOMAgent::discardSearchResults(ErrorString&amp;, const String&amp; searchId)
1057 {
1058     m_searchResults.remove(searchId);
1059 }
1060 
1061 bool InspectorDOMAgent::handleMousePress()
1062 {
1063     if (!m_searchingForNode)
1064         return false;
1065 
1066     if (Node* node = m_overlay-&gt;highlightedNode()) {
1067         inspect(node);
1068         return true;
1069     }
1070     return false;
1071 }
1072 
1073 bool InspectorDOMAgent::handleTouchEvent(Node&amp; node)
1074 {
1075     if (!m_searchingForNode)
1076         return false;
1077     if (m_inspectModeHighlightConfig) {
1078         m_overlay-&gt;highlightNode(&amp;node, *m_inspectModeHighlightConfig);
1079         inspect(&amp;node);
1080         return true;
1081     }
1082     return false;
1083 }
1084 
1085 void InspectorDOMAgent::inspect(Node* inspectedNode)
1086 {
<span class="line-modified">1087     ErrorString unused;</span>
1088     RefPtr&lt;Node&gt; node = inspectedNode;
<span class="line-modified">1089     setSearchingForNode(unused, false, nullptr);</span>
1090 
1091     if (node-&gt;nodeType() != Node::ELEMENT_NODE &amp;&amp; node-&gt;nodeType() != Node::DOCUMENT_NODE)
1092         node = node-&gt;parentNode();
1093     m_nodeToFocus = node;
1094 
1095     if (!m_nodeToFocus)
1096         return;
1097 
1098     focusNode();
1099 }
1100 
1101 void InspectorDOMAgent::focusNode()
1102 {
<span class="line-modified">1103     if (!m_frontendDispatcher)</span>
1104         return;
1105 
1106     ASSERT(m_nodeToFocus);
1107 
1108     RefPtr&lt;Node&gt; node = m_nodeToFocus.get();
1109     m_nodeToFocus = nullptr;
1110 
1111     Frame* frame = node-&gt;document().frame();
1112     if (!frame)
1113         return;
1114 
1115     JSC::ExecState* scriptState = mainWorldExecState(frame);
1116     InjectedScript injectedScript = m_injectedScriptManager.injectedScriptFor(scriptState);
1117     if (injectedScript.hasNoValue())
1118         return;
1119 
1120     injectedScript.inspectObject(nodeAsScriptValue(*scriptState, node.get()));
1121 }
1122 
1123 void InspectorDOMAgent::mouseDidMoveOverElement(const HitTestResult&amp; result, unsigned)
1124 {
1125     m_mousedOverNode = result.innerNode();
1126 
1127     if (!m_searchingForNode)
1128         return;
1129 
1130     highlightMousedOverNode();
1131 }
1132 
1133 void InspectorDOMAgent::highlightMousedOverNode()
1134 {
1135     Node* node = m_mousedOverNode.get();
1136     while (node &amp;&amp; node-&gt;nodeType() == Node::TEXT_NODE)
1137         node = node-&gt;parentNode();
1138     if (node &amp;&amp; m_inspectModeHighlightConfig)
1139         m_overlay-&gt;highlightNode(node, *m_inspectModeHighlightConfig);
1140 }
1141 
<span class="line-modified">1142 void InspectorDOMAgent::setSearchingForNode(ErrorString&amp; errorString, bool enabled, const JSON::Object* highlightInspectorObject)</span>
1143 {
1144     if (m_searchingForNode == enabled)
1145         return;
1146 
1147     m_searchingForNode = enabled;
1148 
<span class="line-modified">1149     if (enabled) {</span>


1150         m_inspectModeHighlightConfig = highlightConfigFromInspectorObject(errorString, highlightInspectorObject);
1151         if (!m_inspectModeHighlightConfig)
1152             return;
1153         highlightMousedOverNode();
1154     } else
1155         hideHighlight(errorString);
1156 
1157     m_overlay-&gt;didSetSearchingForNode(m_searchingForNode);
1158 
<span class="line-modified">1159     if (InspectorClient* client = m_pageAgent-&gt;page().inspectorController().inspectorClient())</span>
1160         client-&gt;elementSelectionChanged(m_searchingForNode);
1161 }
1162 
1163 std::unique_ptr&lt;HighlightConfig&gt; InspectorDOMAgent::highlightConfigFromInspectorObject(ErrorString&amp; errorString, const JSON::Object* highlightInspectorObject)
1164 {
1165     if (!highlightInspectorObject) {
1166         errorString = &quot;Internal error: highlight configuration parameter is missing&quot;_s;
1167         return nullptr;
1168     }
1169 
<span class="line-modified">1170     auto highlightConfig = std::make_unique&lt;HighlightConfig&gt;();</span>
1171     bool showInfo = false; // Default: false (do not show a tooltip).
1172     highlightInspectorObject-&gt;getBoolean(&quot;showInfo&quot;, showInfo);
1173     highlightConfig-&gt;showInfo = showInfo;
1174     highlightConfig-&gt;content = parseConfigColor(&quot;contentColor&quot;, highlightInspectorObject);
1175     highlightConfig-&gt;contentOutline = parseConfigColor(&quot;contentOutlineColor&quot;, highlightInspectorObject);
1176     highlightConfig-&gt;padding = parseConfigColor(&quot;paddingColor&quot;, highlightInspectorObject);
1177     highlightConfig-&gt;border = parseConfigColor(&quot;borderColor&quot;, highlightInspectorObject);
1178     highlightConfig-&gt;margin = parseConfigColor(&quot;marginColor&quot;, highlightInspectorObject);
1179     return highlightConfig;
1180 }
1181 
<span class="line-modified">1182 void InspectorDOMAgent::setInspectModeEnabled(ErrorString&amp; errorString, bool enabled, const JSON::Object* highlightConfig)</span>
1183 {
<span class="line-modified">1184     setSearchingForNode(errorString, enabled, highlightConfig ? highlightConfig : nullptr);</span>
1185 }
1186 
1187 void InspectorDOMAgent::highlightRect(ErrorString&amp;, int x, int y, int width, int height, const JSON::Object* color, const JSON::Object* outlineColor, const bool* usePageCoordinates)
1188 {
<span class="line-modified">1189     auto quad = std::make_unique&lt;FloatQuad&gt;(FloatRect(x, y, width, height));</span>
1190     innerHighlightQuad(WTFMove(quad), color, outlineColor, usePageCoordinates);
1191 }
1192 
1193 void InspectorDOMAgent::highlightQuad(ErrorString&amp; errorString, const JSON::Array&amp; quadArray, const JSON::Object* color, const JSON::Object* outlineColor, const bool* usePageCoordinates)
1194 {
<span class="line-modified">1195     auto quad = std::make_unique&lt;FloatQuad&gt;();</span>
1196     if (!parseQuad(quadArray, quad.get())) {
<span class="line-modified">1197         errorString = &quot;Invalid Quad format&quot;_s;</span>
1198         return;
1199     }
1200     innerHighlightQuad(WTFMove(quad), color, outlineColor, usePageCoordinates);
1201 }
1202 
1203 void InspectorDOMAgent::innerHighlightQuad(std::unique_ptr&lt;FloatQuad&gt; quad, const JSON::Object* color, const JSON::Object* outlineColor, const bool* usePageCoordinates)
1204 {
<span class="line-modified">1205     auto highlightConfig = std::make_unique&lt;HighlightConfig&gt;();</span>
1206     highlightConfig-&gt;content = parseColor(color);
1207     highlightConfig-&gt;contentOutline = parseColor(outlineColor);
1208     highlightConfig-&gt;usePageCoordinates = usePageCoordinates ? *usePageCoordinates : false;
1209     m_overlay-&gt;highlightQuad(WTFMove(quad), *highlightConfig);
1210 }
1211 
1212 void InspectorDOMAgent::highlightSelector(ErrorString&amp; errorString, const JSON::Object&amp; highlightInspectorObject, const String&amp; selectorString, const String* frameId)
1213 {
1214     RefPtr&lt;Document&gt; document;
1215 
1216     if (frameId) {
<span class="line-modified">1217         Frame* frame = m_pageAgent-&gt;frameForId(*frameId);</span>
<span class="line-modified">1218         if (!frame) {</span>
<span class="line-modified">1219             errorString = &quot;No frame for given id found&quot;_s;</span>
1220             return;
1221         }
1222 




1223         document = frame-&gt;document();
1224     } else
1225         document = m_document;
1226 
1227     if (!document) {
<span class="line-modified">1228         errorString = &quot;Document could not be found&quot;_s;</span>
1229         return;
1230     }
1231 
1232     auto queryResult = document-&gt;querySelectorAll(selectorString);
1233     // FIXME: &lt;https://webkit.org/b/146161&gt; Web Inspector: DOM.highlightSelector should work for &quot;a:visited&quot;
1234     if (queryResult.hasException()) {
<span class="line-modified">1235         errorString = &quot;DOM Error while querying&quot;_s;</span>
1236         return;
1237     }
1238 
1239     auto highlightConfig = highlightConfigFromInspectorObject(errorString, &amp;highlightInspectorObject);
1240     if (!highlightConfig)
1241         return;
1242 
1243     m_overlay-&gt;highlightNodeList(queryResult.releaseReturnValue(), *highlightConfig);
1244 }
1245 
1246 void InspectorDOMAgent::highlightNode(ErrorString&amp; errorString, const JSON::Object&amp; highlightInspectorObject, const int* nodeId, const String* objectId)
1247 {
1248     Node* node = nullptr;
1249     if (nodeId)
1250         node = assertNode(errorString, *nodeId);
1251     else if (objectId) {
1252         node = nodeForObjectId(*objectId);
1253         if (!node)
<span class="line-modified">1254             errorString = &quot;Node for given objectId not found&quot;_s;</span>
1255     } else
1256         errorString = &quot;Either nodeId or objectId must be specified&quot;_s;
1257 
1258     if (!node)
1259         return;
1260 
1261     std::unique_ptr&lt;HighlightConfig&gt; highlightConfig = highlightConfigFromInspectorObject(errorString, &amp;highlightInspectorObject);
1262     if (!highlightConfig)
1263         return;
1264 
1265     m_overlay-&gt;highlightNode(node, *highlightConfig);
1266 }
1267 
1268 void InspectorDOMAgent::highlightNodeList(ErrorString&amp; errorString, const JSON::Array&amp; nodeIds, const JSON::Object&amp; highlightInspectorObject)
1269 {
1270     Vector&lt;Ref&lt;Node&gt;&gt; nodes;
1271     for (auto&amp; nodeValue : nodeIds) {
1272         if (!nodeValue) {
<span class="line-modified">1273             errorString = &quot;Invalid nodeIds item.&quot;_s;</span>
1274             return;
1275         }
1276 
1277         int nodeId = 0;
1278         if (!nodeValue-&gt;asInteger(nodeId)) {
<span class="line-modified">1279             errorString = &quot;Invalid nodeIds item type. Expecting integer types.&quot;_s;</span>
1280             return;
1281         }
1282 
1283         // In the case that a node is removed in the time between when highlightNodeList is invoked
1284         // by the frontend and it is executed by the backend, we should still attempt to highlight
1285         // as many nodes as possible. As such, we should ignore any errors generated when attempting
1286         // to get a Node from a given nodeId.
1287         ErrorString ignored;
1288         Node* node = assertNode(ignored, nodeId);
1289         if (!node)
1290             continue;
1291 
1292         nodes.append(*node);
1293     }
1294 
1295     std::unique_ptr&lt;HighlightConfig&gt; highlightConfig = highlightConfigFromInspectorObject(errorString, &amp;highlightInspectorObject);
1296     if (!highlightConfig)
1297         return;
1298 
1299     m_overlay-&gt;highlightNodeList(StaticNodeList::create(WTFMove(nodes)), *highlightConfig);
1300 }
1301 
1302 void InspectorDOMAgent::highlightFrame(ErrorString&amp; errorString, const String&amp; frameId, const JSON::Object* color, const JSON::Object* outlineColor)
1303 {
<span class="line-modified">1304     Frame* frame = m_pageAgent-&gt;assertFrame(errorString, frameId);</span>






1305     if (!frame)
1306         return;
1307 
1308     if (frame-&gt;ownerElement()) {
<span class="line-modified">1309         auto highlightConfig = std::make_unique&lt;HighlightConfig&gt;();</span>
1310         highlightConfig-&gt;showInfo = true; // Always show tooltips for frames.
1311         highlightConfig-&gt;content = parseColor(color);
1312         highlightConfig-&gt;contentOutline = parseColor(outlineColor);
1313         m_overlay-&gt;highlightNode(frame-&gt;ownerElement(), *highlightConfig);
1314     }
1315 }
1316 
1317 void InspectorDOMAgent::hideHighlight(ErrorString&amp;)
1318 {
1319     m_overlay-&gt;hideHighlight();
1320 }
1321 
1322 void InspectorDOMAgent::moveTo(ErrorString&amp; errorString, int nodeId, int targetElementId, const int* anchorNodeId, int* newNodeId)
1323 {
1324     Node* node = assertEditableNode(errorString, nodeId);
1325     if (!node)
1326         return;
1327 
1328     Element* targetElement = assertEditableElement(errorString, targetElementId);
1329     if (!targetElement)
1330         return;
1331 
1332     Node* anchorNode = 0;
1333     if (anchorNodeId &amp;&amp; *anchorNodeId) {
1334         anchorNode = assertEditableNode(errorString, *anchorNodeId);
1335         if (!anchorNode)
1336             return;
1337         if (anchorNode-&gt;parentNode() != targetElement) {
<span class="line-modified">1338             errorString = &quot;Anchor node must be child of the target element&quot;_s;</span>
1339             return;
1340         }
1341     }
1342 
1343     if (!m_domEditor-&gt;insertBefore(*targetElement, *node, anchorNode, errorString))
1344         return;
1345 
1346     *newNodeId = pushNodePathToFrontend(node);
1347 }
1348 
1349 void InspectorDOMAgent::undo(ErrorString&amp; errorString)
1350 {
1351     auto result = m_history-&gt;undo();
1352     if (result.hasException())
1353         errorString = toErrorString(result.releaseException());
1354 }
1355 
1356 void InspectorDOMAgent::redo(ErrorString&amp; errorString)
1357 {
1358     auto result = m_history-&gt;redo();
1359     if (result.hasException())
1360         errorString = toErrorString(result.releaseException());
1361 }
1362 
1363 void InspectorDOMAgent::markUndoableState(ErrorString&amp;)
1364 {
1365     m_history-&gt;markUndoableState();
1366 }
1367 
1368 void InspectorDOMAgent::focus(ErrorString&amp; errorString, int nodeId)
1369 {
1370     Element* element = assertElement(errorString, nodeId);
1371     if (!element)
1372         return;
1373     if (!element-&gt;isFocusable()) {
<span class="line-modified">1374         errorString = &quot;Element is not focusable&quot;_s;</span>
1375         return;
1376     }
1377     element-&gt;focus();
1378 }
1379 
1380 void InspectorDOMAgent::setInspectedNode(ErrorString&amp; errorString, int nodeId)
1381 {
<span class="line-modified">1382     Node* node = nodeForId(nodeId);</span>
<span class="line-modified">1383     if (!node || node-&gt;isInUserAgentShadowTree()) {</span>
<span class="line-modified">1384         errorString = &quot;No node with given id found&quot;_s;</span>



1385         return;
1386     }
1387 
<span class="line-modified">1388     if (CommandLineAPIHost* commandLineAPIHost = static_cast&lt;WebInjectedScriptManager&amp;&gt;(m_injectedScriptManager).commandLineAPIHost())</span>
<span class="line-modified">1389         commandLineAPIHost-&gt;addInspectedObject(std::make_unique&lt;InspectableNode&gt;(node));</span>




1390 }
1391 
1392 void InspectorDOMAgent::resolveNode(ErrorString&amp; errorString, int nodeId, const String* objectGroup, RefPtr&lt;Inspector::Protocol::Runtime::RemoteObject&gt;&amp; result)
1393 {
1394     String objectGroupName = objectGroup ? *objectGroup : emptyString();
<span class="line-modified">1395     Node* node = nodeForId(nodeId);</span>
<span class="line-modified">1396     if (!node) {</span>
<span class="line-removed">1397         errorString = &quot;No node with given id found&quot;_s;</span>
1398         return;
<span class="line-removed">1399     }</span>
1400     RefPtr&lt;Inspector::Protocol::Runtime::RemoteObject&gt; object = resolveNode(node, objectGroupName);
1401     if (!object) {
<span class="line-modified">1402         errorString = &quot;Node with given id does not belong to the document&quot;_s;</span>
1403         return;
1404     }
1405     result = object;
1406 }
1407 
1408 void InspectorDOMAgent::getAttributes(ErrorString&amp; errorString, int nodeId, RefPtr&lt;JSON::ArrayOf&lt;String&gt;&gt;&amp; result)
1409 {
1410     Element* element = assertElement(errorString, nodeId);
1411     if (!element)
1412         return;
1413 
1414     result = buildArrayForElementAttributes(element);
1415 }
1416 
1417 void InspectorDOMAgent::requestNode(ErrorString&amp;, const String&amp; objectId, int* nodeId)
1418 {
1419     Node* node = nodeForObjectId(objectId);
1420     if (node)
1421         *nodeId = pushNodePathToFrontend(node);
1422     else
</pre>
<hr />
<pre>
1520         localName = node-&gt;localName();
1521         break;
1522     }
1523 
1524     auto value = Inspector::Protocol::DOM::Node::create()
1525         .setNodeId(id)
1526         .setNodeType(static_cast&lt;int&gt;(node-&gt;nodeType()))
1527         .setNodeName(nodeName)
1528         .setLocalName(localName)
1529         .setNodeValue(nodeValue)
1530         .release();
1531 
1532     if (node-&gt;isContainerNode()) {
1533         int nodeCount = innerChildNodeCount(node);
1534         value-&gt;setChildNodeCount(nodeCount);
1535         Ref&lt;JSON::ArrayOf&lt;Inspector::Protocol::DOM::Node&gt;&gt; children = buildArrayForContainerChildren(node, depth, nodesMap);
1536         if (children-&gt;length() &gt; 0)
1537             value-&gt;setChildren(WTFMove(children));
1538     }
1539 






1540     if (is&lt;Element&gt;(*node)) {
1541         Element&amp; element = downcast&lt;Element&gt;(*node);
1542         value-&gt;setAttributes(buildArrayForElementAttributes(&amp;element));
1543         if (is&lt;HTMLFrameOwnerElement&gt;(element)) {
<span class="line-modified">1544             HTMLFrameOwnerElement&amp; frameOwner = downcast&lt;HTMLFrameOwnerElement&gt;(element);</span>
<span class="line-removed">1545             Frame* frame = frameOwner.contentFrame();</span>
<span class="line-removed">1546             if (frame)</span>
<span class="line-removed">1547                 value-&gt;setFrameId(m_pageAgent-&gt;frameId(frame));</span>
<span class="line-removed">1548             Document* document = frameOwner.contentDocument();</span>
<span class="line-removed">1549             if (document)</span>
1550                 value-&gt;setContentDocument(buildObjectForNode(document, 0, nodesMap));
1551         }
1552 
1553         if (ShadowRoot* root = element.shadowRoot()) {
1554             auto shadowRoots = JSON::ArrayOf&lt;Inspector::Protocol::DOM::Node&gt;::create();
1555             shadowRoots-&gt;addItem(buildObjectForNode(root, 0, nodesMap));
1556             value-&gt;setShadowRoots(WTFMove(shadowRoots));
1557         }
1558 
1559         if (is&lt;HTMLTemplateElement&gt;(element))
1560             value-&gt;setTemplateContent(buildObjectForNode(&amp;downcast&lt;HTMLTemplateElement&gt;(element).content(), 0, nodesMap));
1561 
1562         if (is&lt;HTMLStyleElement&gt;(element) || (is&lt;HTMLScriptElement&gt;(element) &amp;&amp; !element.hasAttributeWithoutSynchronization(HTMLNames::srcAttr)))
1563             value-&gt;setContentSecurityPolicyHash(computeContentSecurityPolicySHA256Hash(element));
1564 
1565         auto state = customElementState(element);
1566         if (state != Inspector::Protocol::DOM::CustomElementState::Builtin)
1567             value-&gt;setCustomElementState(state);
1568 
1569         if (element.pseudoId() != PseudoId::None) {
1570             Inspector::Protocol::DOM::PseudoType pseudoType;
1571             if (pseudoElementType(element.pseudoId(), &amp;pseudoType))
1572                 value-&gt;setPseudoType(pseudoType);
1573         } else {
1574             if (auto pseudoElements = buildArrayForPseudoElements(element, nodesMap))
1575                 value-&gt;setPseudoElements(WTFMove(pseudoElements));
1576         }
<span class="line-removed">1577 </span>
1578     } else if (is&lt;Document&gt;(*node)) {
1579         Document&amp; document = downcast&lt;Document&gt;(*node);
<span class="line-modified">1580         value-&gt;setFrameId(m_pageAgent-&gt;frameId(document.frame()));</span>

1581         value-&gt;setDocumentURL(documentURLString(&amp;document));
1582         value-&gt;setBaseURL(documentBaseURLString(&amp;document));
1583         value-&gt;setXmlVersion(document.xmlVersion());
1584     } else if (is&lt;DocumentType&gt;(*node)) {
1585         DocumentType&amp; docType = downcast&lt;DocumentType&gt;(*node);
1586         value-&gt;setPublicId(docType.publicId());
1587         value-&gt;setSystemId(docType.systemId());
1588     } else if (is&lt;Attr&gt;(*node)) {
1589         Attr&amp; attribute = downcast&lt;Attr&gt;(*node);
1590         value-&gt;setName(attribute.name());
1591         value-&gt;setValue(attribute.value());
1592     } else if (is&lt;ShadowRoot&gt;(*node)) {
1593         ShadowRoot&amp; shadowRoot = downcast&lt;ShadowRoot&gt;(*node);
1594         value-&gt;setShadowRootType(shadowRootType(shadowRoot.mode()));
1595     }
1596 
1597     return value;
1598 }
1599 
1600 Ref&lt;JSON::ArrayOf&lt;String&gt;&gt; InspectorDOMAgent::buildArrayForElementAttributes(Element* element)
</pre>
<hr />
<pre>
1630 
1631     while (child) {
1632         children-&gt;addItem(buildObjectForNode(child, depth, nodesMap));
1633         child = innerNextSibling(child);
1634     }
1635     return children;
1636 }
1637 
1638 RefPtr&lt;JSON::ArrayOf&lt;Inspector::Protocol::DOM::Node&gt;&gt; InspectorDOMAgent::buildArrayForPseudoElements(const Element&amp; element, NodeToIdMap* nodesMap)
1639 {
1640     PseudoElement* beforeElement = element.beforePseudoElement();
1641     PseudoElement* afterElement = element.afterPseudoElement();
1642     if (!beforeElement &amp;&amp; !afterElement)
1643         return nullptr;
1644 
1645     auto pseudoElements = JSON::ArrayOf&lt;Inspector::Protocol::DOM::Node&gt;::create();
1646     if (beforeElement)
1647         pseudoElements-&gt;addItem(buildObjectForNode(beforeElement, 0, nodesMap));
1648     if (afterElement)
1649         pseudoElements-&gt;addItem(buildObjectForNode(afterElement, 0, nodesMap));
<span class="line-modified">1650     return WTFMove(pseudoElements);</span>
1651 }
1652 
<span class="line-modified">1653 Ref&lt;Inspector::Protocol::DOM::EventListener&gt; InspectorDOMAgent::buildObjectForEventListener(const RegisteredEventListener&amp; registeredEventListener, int identifier, const AtomicString&amp; eventType, Node* node, const String* objectGroupId, bool disabled, bool hasBreakpoint)</span>
1654 {
1655     Ref&lt;EventListener&gt; eventListener = registeredEventListener.callback();
1656 
<span class="line-removed">1657     JSC::ExecState* exec = nullptr;</span>
<span class="line-removed">1658     JSC::JSObject* handlerObject = nullptr;</span>
<span class="line-removed">1659     JSC::JSFunction* handlerFunction = nullptr;</span>
1660     String handlerName;
1661     int lineNumber = 0;
1662     int columnNumber = 0;
1663     String scriptID;
1664     if (is&lt;JSEventListener&gt;(eventListener.get())) {
1665         auto&amp; scriptListener = downcast&lt;JSEventListener&gt;(eventListener.get());
1666 










1667         JSC::JSLockHolder lock(scriptListener.isolatedWorld().vm());
1668 
<span class="line-modified">1669         exec = execStateFromNode(scriptListener.isolatedWorld(), &amp;node-&gt;document());</span>
<span class="line-modified">1670         handlerObject = scriptListener.jsFunction(node-&gt;document());</span>



1671         if (handlerObject &amp;&amp; exec) {
<span class="line-modified">1672             handlerFunction = JSC::jsDynamicCast&lt;JSC::JSFunction*&gt;(exec-&gt;vm(), handlerObject);</span>

1673 
1674             if (!handlerFunction) {
<span class="line-modified">1675                 auto scope = DECLARE_CATCH_SCOPE(exec-&gt;vm());</span>
1676 
1677                 // If the handler is not actually a function, see if it implements the EventListener interface and use that.
<span class="line-modified">1678                 auto handleEventValue = handlerObject-&gt;get(exec, JSC::Identifier::fromString(exec, &quot;handleEvent&quot;));</span>
1679 
1680                 if (UNLIKELY(scope.exception()))
1681                     scope.clearException();
1682 
1683                 if (handleEventValue)
<span class="line-modified">1684                     handlerFunction = JSC::jsDynamicCast&lt;JSC::JSFunction*&gt;(exec-&gt;vm(), handleEventValue);</span>
1685             }
1686 
1687             if (handlerFunction &amp;&amp; !handlerFunction-&gt;isHostOrBuiltinFunction()) {
1688                 // If the listener implements the EventListener interface, use the class name instead of
1689                 // &quot;handleEvent&quot;, unless it is a plain object.
1690                 if (handlerFunction != handlerObject)
1691                     handlerName = JSC::JSObject::calculatedClassName(handlerObject);
1692                 if (handlerName.isEmpty() || handlerName == &quot;Object&quot;_s)
<span class="line-modified">1693                     handlerName = handlerFunction-&gt;calculatedDisplayName(exec-&gt;vm());</span>
1694 
1695                 if (auto executable = handlerFunction-&gt;jsExecutable()) {
1696                     lineNumber = executable-&gt;firstLine() - 1;
1697                     columnNumber = executable-&gt;startColumn() - 1;
1698                     scriptID = executable-&gt;sourceID() == JSC::SourceProvider::nullID ? emptyString() : String::number(executable-&gt;sourceID());
1699                 }
1700             }
1701         }
1702     }
1703 
1704     auto value = Inspector::Protocol::DOM::EventListener::create()
1705         .setEventListenerId(identifier)
1706         .setType(eventType)
1707         .setUseCapture(registeredEventListener.useCapture())
1708         .setIsAttribute(eventListener-&gt;isAttribute())
<span class="line-removed">1709         .setNodeId(pushNodePathToFrontend(node))</span>
1710         .release();
<span class="line-modified">1711     if (objectGroupId &amp;&amp; handlerObject &amp;&amp; exec) {</span>
<span class="line-modified">1712         InjectedScript injectedScript = m_injectedScriptManager.injectedScriptFor(exec);</span>
<span class="line-modified">1713         if (!injectedScript.hasNoValue())</span>
<span class="line-modified">1714             value-&gt;setHandlerObject(injectedScript.wrapObject(handlerObject, *objectGroupId));</span>
<span class="line-removed">1715     }</span>
1716     if (!scriptID.isNull()) {
1717         auto location = Inspector::Protocol::Debugger::Location::create()
1718             .setScriptId(scriptID)
1719             .setLineNumber(lineNumber)
1720             .release();
1721         location-&gt;setColumnNumber(columnNumber);
1722         value-&gt;setLocation(WTFMove(location));
1723     }
1724     if (!handlerName.isEmpty())
1725         value-&gt;setHandlerName(handlerName);
1726     if (registeredEventListener.isPassive())
1727         value-&gt;setPassive(true);
1728     if (registeredEventListener.isOnce())
1729         value-&gt;setOnce(true);
1730     if (disabled)
1731         value-&gt;setDisabled(disabled);
1732     if (hasBreakpoint)
1733         value-&gt;setHasBreakpoint(hasBreakpoint);
1734     return value;
1735 }
</pre>
<hr />
<pre>
2033             value-&gt;setReadonly(readonly);
2034         if (supportsRequired)
2035             value-&gt;setRequired(required);
2036         if (selected)
2037             value-&gt;setSelected(selected);
2038         if (selectedChildNodeIds)
2039             value-&gt;setSelectedChildNodeIds(selectedChildNodeIds);
2040 
2041         // H1 -- H6 always have a headingLevel property that can be complimented by a hierarchicalLevel
2042         // property when aria-level is set on the element, in which case we want to remain calling
2043         // this value the &quot;Heading Level&quot; in the inspector.
2044         // Also, we do not want it to say Hierarchy Level: 0
2045         if (headingLevel)
2046             value-&gt;setHeadingLevel(level);
2047         else if (level)
2048             value-&gt;setHierarchyLevel(level);
2049         if (isPopupButton)
2050             value-&gt;setIsPopUpButton(isPopupButton);
2051     }
2052 
<span class="line-modified">2053     return WTFMove(value);</span>
2054 }
2055 
2056 static bool containsOnlyHTMLWhitespace(Node* node)
2057 {
2058     // FIXME: Respect ignoreWhitespace setting from inspector front end?
2059     return is&lt;Text&gt;(node) &amp;&amp; downcast&lt;Text&gt;(*node).data().isAllSpecialCharacters&lt;isHTMLSpace&gt;();
2060 }
2061 
2062 Node* InspectorDOMAgent::innerFirstChild(Node* node)
2063 {
2064     node = node-&gt;firstChild();
2065     while (containsOnlyHTMLWhitespace(node))
2066         node = node-&gt;nextSibling();
2067     return node;
2068 }
2069 
2070 Node* InspectorDOMAgent::innerNextSibling(Node* node)
2071 {
2072     do {
2073         node = node-&gt;nextSibling();
</pre>
<hr />
<pre>
2086 unsigned InspectorDOMAgent::innerChildNodeCount(Node* node)
2087 {
2088     unsigned count = 0;
2089     for (Node* child = innerFirstChild(node); child; child = innerNextSibling(child))
2090         ++count;
2091     return count;
2092 }
2093 
2094 Node* InspectorDOMAgent::innerParentNode(Node* node)
2095 {
2096     ASSERT(node);
2097     if (is&lt;Document&gt;(*node))
2098         return downcast&lt;Document&gt;(*node).ownerElement();
2099     if (is&lt;ShadowRoot&gt;(*node))
2100         return downcast&lt;ShadowRoot&gt;(*node).host();
2101     return node-&gt;parentNode();
2102 }
2103 
2104 void InspectorDOMAgent::didCommitLoad(Document* document)
2105 {









2106     RefPtr&lt;Element&gt; frameOwner = document-&gt;ownerElement();
2107     if (!frameOwner)
2108         return;
2109 
2110     int frameOwnerId = m_documentNodeToIdMap.get(frameOwner);
2111     if (!frameOwnerId)
2112         return;
2113 
2114     // Re-add frame owner element together with its new children.
2115     int parentId = m_documentNodeToIdMap.get(innerParentNode(frameOwner.get()));
2116     m_frontendDispatcher-&gt;childNodeRemoved(parentId, frameOwnerId);
2117     unbind(frameOwner.get(), &amp;m_documentNodeToIdMap);
2118 
2119     Ref&lt;Inspector::Protocol::DOM::Node&gt; value = buildObjectForNode(frameOwner.get(), 0, &amp;m_documentNodeToIdMap);
2120     Node* previousSibling = innerPreviousSibling(frameOwner.get());
2121     int prevId = previousSibling ? m_documentNodeToIdMap.get(previousSibling) : 0;
2122     m_frontendDispatcher-&gt;childNodeInserted(parentId, prevId, WTFMove(value));
2123 }
2124 
2125 int InspectorDOMAgent::identifierForNode(Node&amp; node)
2126 {
2127     return pushNodePathToFrontend(&amp;node);
2128 }
2129 
2130 void InspectorDOMAgent::addEventListenersToNode(Node&amp; node)
2131 {
2132 #if ENABLE(VIDEO)
2133     auto callback = EventFiredCallback::create(*this);
2134 
<span class="line-modified">2135     auto createEventListener = [&amp;] (const AtomicString&amp; eventName) {</span>
2136         node.addEventListener(eventName, callback.copyRef(), false);
2137     };
2138 
2139 #if ENABLE(FULLSCREEN_API)
2140     if (is&lt;Document&gt;(node) || is&lt;HTMLMediaElement&gt;(node))
2141         createEventListener(eventNames().webkitfullscreenchangeEvent);
2142 #endif // ENABLE(FULLSCREEN_API)
2143 
2144     if (is&lt;HTMLMediaElement&gt;(node)) {
2145         createEventListener(eventNames().abortEvent);
2146         createEventListener(eventNames().canplayEvent);
2147         createEventListener(eventNames().canplaythroughEvent);
2148         createEventListener(eventNames().emptiedEvent);
2149         createEventListener(eventNames().endedEvent);
2150         createEventListener(eventNames().loadeddataEvent);
2151         createEventListener(eventNames().loadedmetadataEvent);
2152         createEventListener(eventNames().loadstartEvent);
2153         createEventListener(eventNames().pauseEvent);
2154         createEventListener(eventNames().playEvent);
2155         createEventListener(eventNames().playingEvent);
</pre>
<hr />
<pre>
2201     if (containsOnlyHTMLWhitespace(&amp;node))
2202         return;
2203 
2204     ContainerNode* parent = node.parentNode();
2205 
2206     // If parent is not mapped yet -&gt; ignore the event.
2207     if (!m_documentNodeToIdMap.contains(parent))
2208         return;
2209 
2210     int parentId = m_documentNodeToIdMap.get(parent);
2211 
2212     if (!m_childrenRequested.contains(parentId)) {
2213         // No children are mapped yet -&gt; only notify on changes of hasChildren.
2214         if (innerChildNodeCount(parent) == 1)
2215             m_frontendDispatcher-&gt;childNodeCountUpdated(parentId, 0);
2216     } else
2217         m_frontendDispatcher-&gt;childNodeRemoved(parentId, m_documentNodeToIdMap.get(&amp;node));
2218     unbind(&amp;node, &amp;m_documentNodeToIdMap);
2219 }
2220 
<span class="line-modified">2221 void InspectorDOMAgent::willModifyDOMAttr(Element&amp;, const AtomicString&amp; oldValue, const AtomicString&amp; newValue)</span>
2222 {
2223     m_suppressAttributeModifiedEvent = (oldValue == newValue);
2224 }
2225 
<span class="line-modified">2226 void InspectorDOMAgent::didModifyDOMAttr(Element&amp; element, const AtomicString&amp; name, const AtomicString&amp; value)</span>
2227 {
2228     bool shouldSuppressEvent = m_suppressAttributeModifiedEvent;
2229     m_suppressAttributeModifiedEvent = false;
2230     if (shouldSuppressEvent)
2231         return;
2232 
2233     int id = boundNodeId(&amp;element);
<span class="line-removed">2234     // If node is not mapped yet -&gt; ignore the event.</span>
2235     if (!id)
2236         return;
2237 
<span class="line-modified">2238     if (m_domListener)</span>
<span class="line-modified">2239         m_domListener-&gt;didModifyDOMAttr(element);</span>
2240 
2241     m_frontendDispatcher-&gt;attributeModified(id, name, value);
2242 }
2243 
<span class="line-modified">2244 void InspectorDOMAgent::didRemoveDOMAttr(Element&amp; element, const AtomicString&amp; name)</span>
2245 {
2246     int id = boundNodeId(&amp;element);
<span class="line-removed">2247     // If node is not mapped yet -&gt; ignore the event.</span>
2248     if (!id)
2249         return;
2250 
<span class="line-modified">2251     if (m_domListener)</span>
<span class="line-modified">2252         m_domListener-&gt;didModifyDOMAttr(element);</span>
2253 
2254     m_frontendDispatcher-&gt;attributeRemoved(id, name);
2255 }
2256 
2257 void InspectorDOMAgent::styleAttributeInvalidated(const Vector&lt;Element*&gt;&amp; elements)
2258 {
2259     auto nodeIds = JSON::ArrayOf&lt;int&gt;::create();
2260     for (auto&amp; element : elements) {
2261         int id = boundNodeId(element);
<span class="line-removed">2262         // If node is not mapped yet -&gt; ignore the event.</span>
2263         if (!id)
2264             continue;
2265 
<span class="line-modified">2266         if (m_domListener)</span>
<span class="line-modified">2267             m_domListener-&gt;didModifyDOMAttr(*element);</span>

2268         nodeIds-&gt;addItem(id);
2269     }
2270     m_frontendDispatcher-&gt;inlineStyleInvalidated(WTFMove(nodeIds));
2271 }
2272 
2273 void InspectorDOMAgent::characterDataModified(CharacterData&amp; characterData)
2274 {
2275     int id = m_documentNodeToIdMap.get(&amp;characterData);
2276     if (!id) {
2277         // Push text node if it is being created.
2278         didInsertDOMNode(characterData);
2279         return;
2280     }
2281     m_frontendDispatcher-&gt;characterDataModified(id, characterData.data());
2282 }
2283 
<span class="line-modified">2284 void InspectorDOMAgent::didInvalidateStyleAttr(Node&amp; node)</span>
2285 {
<span class="line-modified">2286     int id = m_documentNodeToIdMap.get(&amp;node);</span>
<span class="line-removed">2287     // If node is not mapped yet -&gt; ignore the event.</span>
2288     if (!id)
2289         return;
2290 
2291     if (!m_revalidateStyleAttrTask)
<span class="line-modified">2292         m_revalidateStyleAttrTask = std::make_unique&lt;RevalidateStyleAttributeTask&gt;(this);</span>
<span class="line-modified">2293     m_revalidateStyleAttrTask-&gt;scheduleFor(downcast&lt;Element&gt;(&amp;node));</span>
2294 }
2295 
2296 void InspectorDOMAgent::didPushShadowRoot(Element&amp; host, ShadowRoot&amp; root)
2297 {
2298     int hostId = m_documentNodeToIdMap.get(&amp;host);
2299     if (hostId)
2300         m_frontendDispatcher-&gt;shadowRootPushed(hostId, buildObjectForNode(&amp;root, 0, &amp;m_documentNodeToIdMap));
2301 }
2302 
2303 void InspectorDOMAgent::willPopShadowRoot(Element&amp; host, ShadowRoot&amp; root)
2304 {
2305     int hostId = m_documentNodeToIdMap.get(&amp;host);
2306     int rootId = m_documentNodeToIdMap.get(&amp;root);
2307     if (hostId &amp;&amp; rootId)
2308         m_frontendDispatcher-&gt;shadowRootPopped(hostId, rootId);
2309 }
2310 
2311 void InspectorDOMAgent::didChangeCustomElementState(Element&amp; element)
2312 {
2313     int elementId = m_documentNodeToIdMap.get(&amp;element);
</pre>
<hr />
<pre>
2349 {
2350     int pseudoElementId = m_documentNodeToIdMap.get(&amp;pseudoElement);
2351     if (!pseudoElementId)
2352         return;
2353 
2354     // If a PseudoElement is bound, its parent element must have been bound.
2355     Element* parent = pseudoElement.hostElement();
2356     ASSERT(parent);
2357     int parentId = m_documentNodeToIdMap.get(parent);
2358     ASSERT(parentId);
2359 
2360     unbind(&amp;pseudoElement, &amp;m_documentNodeToIdMap);
2361     m_frontendDispatcher-&gt;pseudoElementRemoved(parentId, pseudoElementId);
2362 }
2363 
2364 void InspectorDOMAgent::didAddEventListener(EventTarget&amp; target)
2365 {
2366     if (!is&lt;Node&gt;(target))
2367         return;
2368 
<span class="line-modified">2369     int nodeId = boundNodeId(&amp;downcast&lt;Node&gt;(target));</span>




2370     if (!nodeId)
2371         return;
2372 





2373     m_frontendDispatcher-&gt;didAddEventListener(nodeId);
2374 }
2375 
<span class="line-modified">2376 void InspectorDOMAgent::willRemoveEventListener(EventTarget&amp; target, const AtomicString&amp; eventType, EventListener&amp; listener, bool capture)</span>
2377 {
2378     if (!is&lt;Node&gt;(target))
2379         return;

2380     auto&amp; node = downcast&lt;Node&gt;(target);


2381 
2382     int nodeId = boundNodeId(&amp;node);
2383     if (!nodeId)
2384         return;
2385 
2386     bool listenerExists = false;
2387     for (auto&amp; item : node.eventListeners(eventType)) {
2388         if (item-&gt;callback() == listener &amp;&amp; item-&gt;useCapture() == capture) {
2389             listenerExists = true;
2390             break;
2391         }
2392     }
2393 
2394     if (!listenerExists)
2395         return;
2396 
2397     m_eventListenerEntries.removeIf([&amp;] (auto&amp; entry) {
2398         return entry.value.matches(target, eventType, listener, capture);
2399     });
2400 





2401     m_frontendDispatcher-&gt;willRemoveEventListener(nodeId);
2402 }
2403 
<span class="line-modified">2404 bool InspectorDOMAgent::isEventListenerDisabled(EventTarget&amp; target, const AtomicString&amp; eventType, EventListener&amp; listener, bool capture)</span>
2405 {
2406     for (auto&amp; inspectorEventListener : m_eventListenerEntries.values()) {
2407         if (inspectorEventListener.matches(target, eventType, listener, capture))
2408             return inspectorEventListener.disabled;
2409     }
2410     return false;
2411 }
2412 
2413 void InspectorDOMAgent::eventDidResetAfterDispatch(const Event&amp; event)
2414 {
2415     m_dispatchedEvents.remove(&amp;event);
2416 }
2417 
<span class="line-modified">2418 bool InspectorDOMAgent::hasBreakpointForEventListener(EventTarget&amp; target, const AtomicString&amp; eventType, EventListener&amp; listener, bool capture)</span>
2419 {
2420     for (auto&amp; inspectorEventListener : m_eventListenerEntries.values()) {
2421         if (inspectorEventListener.matches(target, eventType, listener, capture))
2422             return inspectorEventListener.hasBreakpoint;
2423     }
2424     return false;
2425 }
2426 
<span class="line-modified">2427 int InspectorDOMAgent::idForEventListener(EventTarget&amp; target, const AtomicString&amp; eventType, EventListener&amp; listener, bool capture)</span>
2428 {
2429     for (auto&amp; inspectorEventListener : m_eventListenerEntries.values()) {
2430         if (inspectorEventListener.matches(target, eventType, listener, capture))
2431             return inspectorEventListener.identifier;
2432     }
2433     return 0;
2434 }
2435 
2436 #if ENABLE(VIDEO)
2437 void InspectorDOMAgent::mediaMetricsTimerFired()
2438 {
2439     // FIXME: remove metrics information for any media element when it&#39;s destroyed
2440 
2441     if (HTMLMediaElement::allMediaElements().isEmpty()) {
2442         if (m_mediaMetricsTimer.isActive())
2443             m_mediaMetricsTimer.stop();
2444         m_mediaMetrics.clear();
2445         return;
2446     }
2447 
2448     for (auto* mediaElement : HTMLMediaElement::allMediaElements()) {
2449         if (!is&lt;HTMLVideoElement&gt;(mediaElement) || !mediaElement-&gt;isPlaying())
2450             continue;
2451 
2452         auto videoPlaybackQuality = mediaElement-&gt;getVideoPlaybackQuality();
2453         unsigned displayCompositedVideoFrames = videoPlaybackQuality-&gt;displayCompositedVideoFrames();
2454 
2455         auto iterator = m_mediaMetrics.find(mediaElement);
2456         if (iterator == m_mediaMetrics.end()) {
2457             m_mediaMetrics.set(mediaElement, MediaMetrics(displayCompositedVideoFrames));
2458             continue;
2459         }
2460 
<span class="line-modified">2461         bool isLowPower = (displayCompositedVideoFrames - iterator-&gt;value.displayCompositedFrames) &gt; 0;</span>
<span class="line-modified">2462         if (iterator-&gt;value.isLowPower != isLowPower) {</span>
<span class="line-modified">2463             iterator-&gt;value.isLowPower = isLowPower;</span>
2464 
2465             int nodeId = pushNodePathToFrontend(mediaElement);
2466             if (nodeId) {
2467                 auto timestamp = m_environment.executionStopwatch()-&gt;elapsedTime().seconds();
<span class="line-modified">2468                 m_frontendDispatcher-&gt;videoLowPowerChanged(nodeId, timestamp, iterator-&gt;value.isLowPower);</span>
2469             }
2470         }
2471 
2472         iterator-&gt;value.displayCompositedFrames = displayCompositedVideoFrames;
2473     }
2474 
2475     m_mediaMetrics.removeIf([&amp;] (auto&amp; entry) {
2476         return !HTMLMediaElement::allMediaElements().contains(entry.key);
2477     });
2478 }
2479 #endif
2480 
2481 Node* InspectorDOMAgent::nodeForPath(const String&amp; path)
2482 {
2483     // The path is of form &quot;1,HTML,2,BODY,1,DIV&quot;
2484     if (!m_document)
2485         return nullptr;
2486 
2487     Node* node = m_document.get();
2488     Vector&lt;String&gt; pathTokens = path.split(&#39;,&#39;);
</pre>
<hr />
<pre>
2514             return nullptr;
2515         node = child;
2516     }
2517     return node;
2518 }
2519 
2520 Node* InspectorDOMAgent::nodeForObjectId(const String&amp; objectId)
2521 {
2522     InjectedScript injectedScript = m_injectedScriptManager.injectedScriptForObjectId(objectId);
2523     if (injectedScript.hasNoValue())
2524         return nullptr;
2525 
2526     return scriptValueAsNode(injectedScript.findObjectById(objectId));
2527 }
2528 
2529 void InspectorDOMAgent::pushNodeByPathToFrontend(ErrorString&amp; errorString, const String&amp; path, int* nodeId)
2530 {
2531     if (Node* node = nodeForPath(path))
2532         *nodeId = pushNodePathToFrontend(node);
2533     else
<span class="line-modified">2534         errorString = &quot;No node with given path found&quot;_s;</span>
2535 }
2536 
2537 RefPtr&lt;Inspector::Protocol::Runtime::RemoteObject&gt; InspectorDOMAgent::resolveNode(Node* node, const String&amp; objectGroup)
2538 {
<span class="line-modified">2539     auto* frame = node-&gt;document().frame();</span>



2540     if (!frame)
2541         return nullptr;
2542 
2543     auto&amp; state = *mainWorldExecState(frame);
2544     auto injectedScript = m_injectedScriptManager.injectedScriptFor(&amp;state);
2545     if (injectedScript.hasNoValue())
2546         return nullptr;
2547 
2548     return injectedScript.wrapObject(nodeAsScriptValue(state, node), objectGroup);
2549 }
2550 
2551 Node* InspectorDOMAgent::scriptValueAsNode(JSC::JSValue value)
2552 {
2553     if (!value || !value.isObject())
2554         return nullptr;
<span class="line-modified">2555     return JSNode::toWrapped(*value.getObject()-&gt;vm(), value.getObject());</span>
2556 }
2557 
2558 JSC::JSValue InspectorDOMAgent::nodeAsScriptValue(JSC::ExecState&amp; state, Node* node)
2559 {
2560     JSC::JSLockHolder lock(&amp;state);
2561     return toJS(&amp;state, deprecatedGlobalObjectForPrototype(&amp;state), BindingSecurity::checkSecurityForNode(state, node));
2562 }
2563 
2564 } // namespace WebCore
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (C) 2009-2019 Apple Inc. All rights reserved.</span>
   3  * Copyright (C) 2011 Google Inc. All rights reserved.
   4  * Copyright (C) 2009 Joseph Pecoraro
   5  *
   6  * Redistribution and use in source and binary forms, with or without
   7  * modification, are permitted provided that the following conditions
   8  * are met:
   9  *
  10  * 1.  Redistributions of source code must retain the above copyright
  11  *     notice, this list of conditions and the following disclaimer.
  12  * 2.  Redistributions in binary form must reproduce the above copyright
  13  *     notice, this list of conditions and the following disclaimer in the
  14  *     documentation and/or other materials provided with the distribution.
  15  * 3.  Neither the name of Apple Inc. (&quot;Apple&quot;) nor the names of
  16  *     its contributors may be used to endorse or promote products derived
  17  *     from this software without specific prior written permission.
  18  *
  19  * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS &quot;AS IS&quot; AND ANY
  20  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  21  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  22  * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
</pre>
<hr />
<pre>
  42 #include &quot;CSSStyleRule.h&quot;
  43 #include &quot;CSSStyleSheet.h&quot;
  44 #include &quot;CharacterData.h&quot;
  45 #include &quot;CommandLineAPIHost.h&quot;
  46 #include &quot;ContainerNode.h&quot;
  47 #include &quot;Cookie.h&quot;
  48 #include &quot;CookieJar.h&quot;
  49 #include &quot;DOMEditor.h&quot;
  50 #include &quot;DOMException.h&quot;
  51 #include &quot;DOMPatchSupport.h&quot;
  52 #include &quot;DOMWindow.h&quot;
  53 #include &quot;Document.h&quot;
  54 #include &quot;DocumentType.h&quot;
  55 #include &quot;Editing.h&quot;
  56 #include &quot;Element.h&quot;
  57 #include &quot;Event.h&quot;
  58 #include &quot;EventListener.h&quot;
  59 #include &quot;EventNames.h&quot;
  60 #include &quot;Frame.h&quot;
  61 #include &quot;FrameTree.h&quot;
<span class="line-added">  62 #include &quot;FrameView.h&quot;</span>
<span class="line-added">  63 #include &quot;FullscreenManager.h&quot;</span>
  64 #include &quot;HTMLElement.h&quot;
  65 #include &quot;HTMLFrameOwnerElement.h&quot;
  66 #include &quot;HTMLMediaElement.h&quot;
  67 #include &quot;HTMLNames.h&quot;
  68 #include &quot;HTMLParserIdioms.h&quot;
  69 #include &quot;HTMLScriptElement.h&quot;
  70 #include &quot;HTMLStyleElement.h&quot;
  71 #include &quot;HTMLTemplateElement.h&quot;
  72 #include &quot;HTMLVideoElement.h&quot;
  73 #include &quot;HitTestResult.h&quot;
<span class="line-added">  74 #include &quot;InspectorCSSAgent.h&quot;</span>
  75 #include &quot;InspectorClient.h&quot;
  76 #include &quot;InspectorController.h&quot;
  77 #include &quot;InspectorHistory.h&quot;
  78 #include &quot;InspectorNodeFinder.h&quot;
  79 #include &quot;InspectorOverlay.h&quot;
  80 #include &quot;InspectorPageAgent.h&quot;
  81 #include &quot;InstrumentingAgents.h&quot;
  82 #include &quot;IntRect.h&quot;
  83 #include &quot;JSDOMBindingSecurity.h&quot;
  84 #include &quot;JSEventListener.h&quot;
  85 #include &quot;JSNode.h&quot;
  86 #include &quot;MutationEvent.h&quot;
  87 #include &quot;Node.h&quot;
  88 #include &quot;NodeList.h&quot;
  89 #include &quot;Page.h&quot;
  90 #include &quot;Pasteboard.h&quot;
  91 #include &quot;PseudoElement.h&quot;
  92 #include &quot;RenderStyle.h&quot;
  93 #include &quot;RenderStyleConstants.h&quot;
  94 #include &quot;ScriptState.h&quot;
</pre>
<hr />
<pre>
 236     {
 237         return this == &amp;other;
 238     }
 239 
 240     void handleEvent(ScriptExecutionContext&amp;, Event&amp; event) final
 241     {
 242         if (!is&lt;Node&gt;(event.target()) || m_domAgent.m_dispatchedEvents.contains(&amp;event))
 243             return;
 244 
 245         auto* node = downcast&lt;Node&gt;(event.target());
 246         int nodeId = m_domAgent.pushNodePathToFrontend(node);
 247         if (!nodeId)
 248             return;
 249 
 250         m_domAgent.m_dispatchedEvents.add(&amp;event);
 251 
 252         RefPtr&lt;JSON::Object&gt; data = JSON::Object::create();
 253 
 254 #if ENABLE(FULLSCREEN_API)
 255         if (event.type() == eventNames().webkitfullscreenchangeEvent)
<span class="line-modified"> 256             data-&gt;setBoolean(&quot;enabled&quot;_s, !!node-&gt;document().fullscreenManager().fullscreenElement());</span>
 257 #endif // ENABLE(FULLSCREEN_API)
 258 
 259         auto timestamp = m_domAgent.m_environment.executionStopwatch()-&gt;elapsedTime().seconds();
 260         m_domAgent.m_frontendDispatcher-&gt;didFireEvent(nodeId, event.type(), timestamp, data-&gt;size() ? WTFMove(data) : nullptr);
 261     }
 262 
 263 private:
 264     EventFiredCallback(InspectorDOMAgent&amp; domAgent)
 265         : EventListener(EventListener::CPPEventListenerType)
 266         , m_domAgent(domAgent)
 267     {
 268     }
 269 
 270     InspectorDOMAgent&amp; m_domAgent;
 271 };
 272 
 273 String InspectorDOMAgent::toErrorString(ExceptionCode ec)
 274 {
 275     return ec ? String(DOMException::name(ec)) : emptyString();
 276 }
 277 
 278 String InspectorDOMAgent::toErrorString(Exception&amp;&amp; exception)
 279 {
 280     return DOMException::name(exception.code());
 281 }
 282 
<span class="line-modified"> 283 InspectorDOMAgent::InspectorDOMAgent(PageAgentContext&amp; context, InspectorOverlay* overlay)</span>
 284     : InspectorAgentBase(&quot;DOM&quot;_s, context)
 285     , m_injectedScriptManager(context.injectedScriptManager)
<span class="line-modified"> 286     , m_frontendDispatcher(makeUnique&lt;Inspector::DOMFrontendDispatcher&gt;(context.frontendRouter))</span>
 287     , m_backendDispatcher(Inspector::DOMBackendDispatcher::create(context.backendDispatcher, this))
<span class="line-modified"> 288     , m_inspectedPage(context.inspectedPage)</span>
 289     , m_overlay(overlay)
 290 #if ENABLE(VIDEO)
 291     , m_mediaMetricsTimer(*this, &amp;InspectorDOMAgent::mediaMetricsTimerFired)
 292 #endif
 293 {
 294 }
 295 
<span class="line-modified"> 296 InspectorDOMAgent::~InspectorDOMAgent() = default;</span>




 297 
 298 void InspectorDOMAgent::didCreateFrontendAndBackend(Inspector::FrontendRouter*, Inspector::BackendDispatcher*)
 299 {
<span class="line-modified"> 300     m_history = makeUnique&lt;InspectorHistory&gt;();</span>
<span class="line-modified"> 301     m_domEditor = makeUnique&lt;DOMEditor&gt;(*m_history);</span>
 302 
 303     m_instrumentingAgents.setInspectorDOMAgent(this);
<span class="line-modified"> 304     m_document = m_inspectedPage.mainFrame().document();</span>
 305 
 306 #if ENABLE(VIDEO)
 307     if (m_document)
 308         addEventListenersToNode(*m_document);
 309 
 310     for (auto* mediaElement : HTMLMediaElement::allMediaElements())
 311         addEventListenersToNode(*mediaElement);
 312 #endif



 313 }
 314 
 315 void InspectorDOMAgent::willDestroyFrontendAndBackend(Inspector::DisconnectReason)
 316 {
 317     m_history.reset();
 318     m_domEditor.reset();
<span class="line-added"> 319     m_nodeToFocus = nullptr;</span>
 320     m_mousedOverNode = nullptr;
<span class="line-added"> 321     m_inspectedNode = nullptr;</span>
 322 
<span class="line-modified"> 323     ErrorString ignored;</span>
<span class="line-modified"> 324     setSearchingForNode(ignored, false, nullptr, false);</span>
<span class="line-modified"> 325     hideHighlight(ignored);</span>
 326 
 327     m_instrumentingAgents.setInspectorDOMAgent(nullptr);
 328     m_documentRequested = false;
 329     reset();
 330 }
 331 
 332 Vector&lt;Document*&gt; InspectorDOMAgent::documents()
 333 {
 334     Vector&lt;Document*&gt; result;
 335     for (Frame* frame = m_document-&gt;frame(); frame; frame = frame-&gt;tree().traverseNext()) {
 336         Document* document = frame-&gt;document();
 337         if (!document)
 338             continue;
 339         result.append(document);
 340     }
 341     return result;
 342 }
 343 
 344 void InspectorDOMAgent::reset()
 345 {
 346     if (m_history)
 347         m_history-&gt;reset();
 348     m_searchResults.clear();
 349     discardBindings();
 350     if (m_revalidateStyleAttrTask)
 351         m_revalidateStyleAttrTask-&gt;reset();
 352     m_document = nullptr;
 353 }
 354 





 355 void InspectorDOMAgent::setDocument(Document* document)
 356 {
 357     if (document == m_document.get())
 358         return;
 359 
 360     reset();
 361 
 362     m_document = document;
 363 
 364     if (!m_documentRequested)
 365         return;
 366 
 367     // Immediately communicate null document or document that has finished loading.
 368     if (!document || !document-&gt;parsing())
 369         m_frontendDispatcher-&gt;documentUpdated();
 370 }
 371 
 372 void InspectorDOMAgent::releaseDanglingNodes()
 373 {
 374     m_danglingNodeToIdMaps.clear();
</pre>
<hr />
<pre>
 394 
 395     m_idToNode.remove(id);
 396 
 397     if (node-&gt;isFrameOwnerElement()) {
 398         const HTMLFrameOwnerElement* frameOwner = static_cast&lt;const HTMLFrameOwnerElement*&gt;(node);
 399         if (Document* contentDocument = frameOwner-&gt;contentDocument())
 400             unbind(contentDocument, nodesMap);
 401     }
 402 
 403     if (is&lt;Element&gt;(*node)) {
 404         Element&amp; element = downcast&lt;Element&gt;(*node);
 405         if (ShadowRoot* root = element.shadowRoot())
 406             unbind(root, nodesMap);
 407         if (PseudoElement* beforeElement = element.beforePseudoElement())
 408             unbind(beforeElement, nodesMap);
 409         if (PseudoElement* afterElement = element.afterPseudoElement())
 410             unbind(afterElement, nodesMap);
 411     }
 412 
 413     nodesMap-&gt;remove(node);
<span class="line-modified"> 414 </span>
<span class="line-modified"> 415     if (auto* cssAgent = m_instrumentingAgents.inspectorCSSAgent())</span>
<span class="line-added"> 416         cssAgent-&gt;didRemoveDOMNode(*node, id);</span>
 417 
 418     if (m_childrenRequested.remove(id)) {
 419         // FIXME: Would be better to do this iteratively rather than recursively.
 420         for (Node* child = innerFirstChild(node); child; child = innerNextSibling(child))
 421             unbind(child, nodesMap);
 422     }
 423 }
 424 
 425 Node* InspectorDOMAgent::assertNode(ErrorString&amp; errorString, int nodeId)
 426 {
 427     Node* node = nodeForId(nodeId);
 428     if (!node) {
<span class="line-modified"> 429         errorString = &quot;Missing node for given nodeId&quot;_s;</span>
 430         return nullptr;
 431     }
 432     return node;
 433 }
 434 
 435 Document* InspectorDOMAgent::assertDocument(ErrorString&amp; errorString, int nodeId)
 436 {
 437     Node* node = assertNode(errorString, nodeId);
 438     if (!node)
 439         return nullptr;
<span class="line-modified"> 440     if (!is&lt;Document&gt;(node)) {</span>
<span class="line-modified"> 441         errorString = &quot;Node for given nodeId is not a document&quot;_s;</span>
 442         return nullptr;
 443     }
 444     return downcast&lt;Document&gt;(node);
 445 }
 446 
 447 Element* InspectorDOMAgent::assertElement(ErrorString&amp; errorString, int nodeId)
 448 {
 449     Node* node = assertNode(errorString, nodeId);
 450     if (!node)
 451         return nullptr;
<span class="line-modified"> 452     if (!is&lt;Element&gt;(node)) {</span>
<span class="line-modified"> 453         errorString = &quot;Node for given nodeId is not an element&quot;_s;</span>
 454         return nullptr;
 455     }
 456     return downcast&lt;Element&gt;(node);
 457 }
 458 
 459 Node* InspectorDOMAgent::assertEditableNode(ErrorString&amp; errorString, int nodeId)
 460 {
 461     Node* node = assertNode(errorString, nodeId);
 462     if (!node)
 463         return nullptr;
 464     if (node-&gt;isInUserAgentShadowTree()) {
<span class="line-modified"> 465         errorString = &quot;Node for given nodeId is in a shadow tree&quot;_s;</span>
 466         return nullptr;
 467     }
 468     if (node-&gt;isPseudoElement()) {
<span class="line-modified"> 469         errorString = &quot;Node for given nodeId is a pseudo-element&quot;_s;</span>
 470         return nullptr;
 471     }
 472     return node;
 473 }
 474 
 475 Element* InspectorDOMAgent::assertEditableElement(ErrorString&amp; errorString, int nodeId)
 476 {
<span class="line-modified"> 477     Node* node = assertEditableNode(errorString, nodeId);</span>
<span class="line-modified"> 478     if (!node)</span>



 479         return nullptr;
<span class="line-modified"> 480     if (!is&lt;Element&gt;(node)) {</span>
<span class="line-modified"> 481         errorString = &quot;Node for given nodeId is not an element&quot;_s;</span>

 482         return nullptr;
 483     }
<span class="line-modified"> 484     return downcast&lt;Element&gt;(node);</span>
 485 }
 486 
 487 void InspectorDOMAgent::getDocument(ErrorString&amp; errorString, RefPtr&lt;Inspector::Protocol::DOM::Node&gt;&amp; root)
 488 {
 489     m_documentRequested = true;
 490 
 491     if (!m_document) {
<span class="line-modified"> 492         errorString = &quot;Internal error: missing document&quot;_s;</span>
 493         return;
 494     }
 495 
 496     // Reset backend state.
 497     RefPtr&lt;Document&gt; document = m_document;
 498     reset();
 499     m_document = document;
 500 
 501     root = buildObjectForNode(m_document.get(), 2, &amp;m_documentNodeToIdMap);
<span class="line-added"> 502 </span>
<span class="line-added"> 503     if (m_nodeToFocus)</span>
<span class="line-added"> 504         focusNode();</span>
 505 }
 506 
 507 void InspectorDOMAgent::pushChildNodesToFrontend(int nodeId, int depth)
 508 {
 509     Node* node = nodeForId(nodeId);
 510     if (!node || (node-&gt;nodeType() != Node::ELEMENT_NODE &amp;&amp; node-&gt;nodeType() != Node::DOCUMENT_NODE &amp;&amp; node-&gt;nodeType() != Node::DOCUMENT_FRAGMENT_NODE))
 511         return;
 512 
 513     NodeToIdMap* nodeMap = m_idToNodesMap.get(nodeId);
 514 
 515     if (m_childrenRequested.contains(nodeId)) {
 516         if (depth &lt;= 1)
 517             return;
 518 
 519         depth--;
 520 
 521         for (node = innerFirstChild(node); node; node = innerNextSibling(node)) {
 522             int childNodeId = nodeMap-&gt;get(node);
 523             ASSERT(childNodeId);
 524             pushChildNodesToFrontend(childNodeId, depth);
</pre>
<hr />
<pre>
 530     auto children = buildArrayForContainerChildren(node, depth, nodeMap);
 531     m_frontendDispatcher-&gt;setChildNodes(nodeId, WTFMove(children));
 532 }
 533 
 534 void InspectorDOMAgent::discardBindings()
 535 {
 536     m_documentNodeToIdMap.clear();
 537     m_idToNode.clear();
 538     m_dispatchedEvents.clear();
 539     m_eventListenerEntries.clear();
 540     releaseDanglingNodes();
 541     m_childrenRequested.clear();
 542 }
 543 
 544 int InspectorDOMAgent::pushNodeToFrontend(ErrorString&amp; errorString, int documentNodeId, Node* nodeToPush)
 545 {
 546     Document* document = assertDocument(errorString, documentNodeId);
 547     if (!document)
 548         return 0;
 549     if (&amp;nodeToPush-&gt;document() != document) {
<span class="line-modified"> 550         errorString = &quot;nodeToPush is not part of the document with given documentNodeId&quot;_s;</span>
 551         return 0;
 552     }
 553 
 554     return pushNodePathToFrontend(nodeToPush);
 555 }
 556 
 557 Node* InspectorDOMAgent::nodeForId(int id)
 558 {
 559     if (!m_idToNode.isValidKey(id))
 560         return nullptr;
 561 
 562     return m_idToNode.get(id);
 563 }
 564 
 565 void InspectorDOMAgent::requestChildNodes(ErrorString&amp; errorString, int nodeId, const int* depth)
 566 {
 567     int sanitizedDepth;
 568 
 569     if (!depth)
 570         sanitizedDepth = 1;
 571     else if (*depth == -1)
 572         sanitizedDepth = INT_MAX;
 573     else if (*depth &gt; 0)
 574         sanitizedDepth = *depth;
 575     else {
<span class="line-modified"> 576         errorString = &quot;Unexpected value below -1 for given depth&quot;_s;</span>
 577         return;
 578     }
 579 
 580     pushChildNodesToFrontend(nodeId, sanitizedDepth);
 581 }
 582 
 583 void InspectorDOMAgent::querySelector(ErrorString&amp; errorString, int nodeId, const String&amp; selectors, int* elementId)
 584 {
 585     *elementId = 0;
 586     Node* node = assertNode(errorString, nodeId);
 587     if (!node)
 588         return;
 589     if (!is&lt;ContainerNode&gt;(*node)) {
 590         assertElement(errorString, nodeId);
 591         return;
 592     }
 593 
 594     auto queryResult = downcast&lt;ContainerNode&gt;(*node).querySelector(selectors);
 595     if (queryResult.hasException()) {
<span class="line-modified"> 596         errorString = &quot;DOM Error while querying with given selectors&quot;_s;</span>
 597         return;
 598     }
 599 
 600     if (auto* element = queryResult.releaseReturnValue())
 601         *elementId = pushNodePathToFrontend(element);
 602 }
 603 
 604 void InspectorDOMAgent::querySelectorAll(ErrorString&amp; errorString, int nodeId, const String&amp; selectors, RefPtr&lt;JSON::ArrayOf&lt;int&gt;&gt;&amp; result)
 605 {
 606     Node* node = assertNode(errorString, nodeId);
 607     if (!node)
 608         return;
 609     if (!is&lt;ContainerNode&gt;(*node)) {
 610         assertElement(errorString, nodeId);
 611         return;
 612     }
 613 
 614     auto queryResult = downcast&lt;ContainerNode&gt;(*node).querySelectorAll(selectors);
 615     if (queryResult.hasException()) {
<span class="line-modified"> 616         errorString = &quot;DOM Error while querying with given selectors&quot;_s;</span>
 617         return;
 618     }
 619 
 620     auto nodes = queryResult.releaseReturnValue();
 621     result = JSON::ArrayOf&lt;int&gt;::create();
 622     for (unsigned i = 0; i &lt; nodes-&gt;length(); ++i)
 623         result-&gt;addItem(pushNodePathToFrontend(nodes-&gt;item(i)));
 624 }
 625 
 626 int InspectorDOMAgent::pushNodePathToFrontend(Node* nodeToPush)
 627 {
 628     ASSERT(nodeToPush);  // Invalid input
 629 
 630     if (!m_document)
 631         return 0;
 632     if (!m_documentNodeToIdMap.contains(m_document))
 633         return 0;
 634 
 635     // Return id in case the node is known.
 636     int result = m_documentNodeToIdMap.get(nodeToPush);
 637     if (result)
 638         return result;
 639 
 640     Node* node = nodeToPush;
 641     Vector&lt;Node*&gt; path;
 642     NodeToIdMap* danglingMap = 0;
 643 
 644     while (true) {
 645         Node* parent = innerParentNode(node);
 646         if (!parent) {
 647             // Node being pushed is detached -&gt; push subtree root.
<span class="line-modified"> 648             auto newMap = makeUnique&lt;NodeToIdMap&gt;();</span>
 649             danglingMap = newMap.get();
 650             m_danglingNodeToIdMaps.append(newMap.release());
 651             auto children = JSON::ArrayOf&lt;Inspector::Protocol::DOM::Node&gt;::create();
 652             children-&gt;addItem(buildObjectForNode(node, 0, danglingMap));
 653             m_frontendDispatcher-&gt;setChildNodes(0, WTFMove(children));
 654             break;
 655         } else {
 656             path.append(parent);
 657             if (m_documentNodeToIdMap.get(parent))
 658                 break;
 659             else
 660                 node = parent;
 661         }
 662     }
 663 
 664     NodeToIdMap* map = danglingMap ? danglingMap : &amp;m_documentNodeToIdMap;
 665     for (int i = path.size() - 1; i &gt;= 0; --i) {
 666         int nodeId = map-&gt;get(path.at(i));
 667         ASSERT(nodeId);
 668         pushChildNodesToFrontend(nodeId);
</pre>
<hr />
<pre>
 682         return;
 683 
 684     m_domEditor-&gt;setAttribute(*element, name, value, errorString);
 685 }
 686 
 687 void InspectorDOMAgent::setAttributesAsText(ErrorString&amp; errorString, int elementId, const String&amp; text, const String* name)
 688 {
 689     Element* element = assertEditableElement(errorString, elementId);
 690     if (!element)
 691         return;
 692 
 693     auto parsedElement = createHTMLElement(element-&gt;document(), spanTag);
 694     auto result = parsedElement.get().setInnerHTML(&quot;&lt;span &quot; + text + &quot;&gt;&lt;/span&gt;&quot;);
 695     if (result.hasException()) {
 696         errorString = toErrorString(result.releaseException());
 697         return;
 698     }
 699 
 700     Node* child = parsedElement-&gt;firstChild();
 701     if (!child) {
<span class="line-modified"> 702         errorString = &quot;Could not parse given text&quot;_s;</span>
 703         return;
 704     }
 705 
 706     Element* childElement = downcast&lt;Element&gt;(child);
 707     if (!childElement-&gt;hasAttributes() &amp;&amp; name) {
 708         m_domEditor-&gt;removeAttribute(*element, *name, errorString);
 709         return;
 710     }
 711 
 712     bool foundOriginalAttribute = false;
 713     for (const Attribute&amp; attribute : childElement-&gt;attributesIterator()) {
 714         // Add attribute pair
 715         foundOriginalAttribute = foundOriginalAttribute || (name &amp;&amp; attribute.name().toString() == *name);
 716         if (!m_domEditor-&gt;setAttribute(*element, attribute.name().toString(), attribute.value(), errorString))
 717             return;
 718     }
 719 
 720     if (!foundOriginalAttribute &amp;&amp; name &amp;&amp; !name-&gt;stripWhiteSpace().isEmpty())
 721         m_domEditor-&gt;removeAttribute(*element, *name, errorString);
 722 }
</pre>
<hr />
<pre>
 785     Node* node = assertNode(errorString, nodeId);
 786     if (!node)
 787         return;
 788 
 789     *outerHTML = serializeFragment(*node, SerializedNodes::SubtreeIncludingNode);
 790 }
 791 
 792 void InspectorDOMAgent::setOuterHTML(ErrorString&amp; errorString, int nodeId, const String&amp; outerHTML)
 793 {
 794     if (!nodeId) {
 795         DOMPatchSupport { *m_domEditor, *m_document }.patchDocument(outerHTML);
 796         return;
 797     }
 798 
 799     Node* node = assertEditableNode(errorString, nodeId);
 800     if (!node)
 801         return;
 802 
 803     Document&amp; document = node-&gt;document();
 804     if (!document.isHTMLDocument() &amp;&amp; !document.isXMLDocument()) {
<span class="line-modified"> 805         errorString = &quot;Document of node for given nodeId is not HTML/XML&quot;_s;</span>
 806         return;
 807     }
 808 
 809     Node* newNode = nullptr;
 810     if (!m_domEditor-&gt;setOuterHTML(*node, outerHTML, newNode, errorString))
 811         return;
 812 
 813     if (!newNode) {
 814         // The only child node has been deleted.
 815         return;
 816     }
 817 
 818     int newId = pushNodePathToFrontend(newNode);
 819 
 820     bool childrenRequested = m_childrenRequested.contains(nodeId);
 821     if (childrenRequested)
 822         pushChildNodesToFrontend(newId);
 823 }
 824 
 825 void InspectorDOMAgent::insertAdjacentHTML(ErrorString&amp; errorString, int nodeId, const String&amp; position, const String&amp; html)
 826 {
 827     Node* node = assertEditableNode(errorString, nodeId);
 828     if (!node)
 829         return;
 830 
 831     if (!is&lt;Element&gt;(node)) {
<span class="line-modified"> 832         errorString = &quot;Node for given nodeId is not an element&quot;_s;</span>
 833         return;
 834     }
 835 
 836     m_domEditor-&gt;insertAdjacentHTML(downcast&lt;Element&gt;(*node), position, html, errorString);
 837 }
 838 
 839 void InspectorDOMAgent::setNodeValue(ErrorString&amp; errorString, int nodeId, const String&amp; value)
 840 {
 841     Node* node = assertEditableNode(errorString, nodeId);
 842     if (!node)
 843         return;
 844 
 845     if (!is&lt;Text&gt;(*node)) {
<span class="line-modified"> 846         errorString = &quot;Node for given nodeId is not text&quot;_s;</span>
 847         return;
 848     }
 849 
 850     m_domEditor-&gt;replaceWholeText(downcast&lt;Text&gt;(*node), value, errorString);
 851 }
 852 
 853 void InspectorDOMAgent::getSupportedEventNames(ErrorString&amp;, RefPtr&lt;JSON::ArrayOf&lt;String&gt;&gt;&amp; eventNames)
 854 {
 855     eventNames = JSON::ArrayOf&lt;String&gt;::create();
 856 
 857 #define DOM_EVENT_NAMES_ADD(name) eventNames-&gt;addItem(#name);
 858     DOM_EVENT_NAMES_FOR_EACH(DOM_EVENT_NAMES_ADD)
 859 #undef DOM_EVENT_NAMES_ADD
 860 }
 861 
<span class="line-modified"> 862 void InspectorDOMAgent::getDataBindingsForNode(ErrorString&amp; errorString, int /* nodeId */, RefPtr&lt;JSON::ArrayOf&lt;Inspector::Protocol::DOM::DataBinding&gt;&gt;&amp; /* dataBindings */)</span>
<span class="line-added"> 863 {</span>
<span class="line-added"> 864     errorString = &quot;Not supported&quot;_s;</span>
<span class="line-added"> 865 }</span>
<span class="line-added"> 866 </span>
<span class="line-added"> 867 void InspectorDOMAgent::getAssociatedDataForNode(ErrorString&amp; errorString, int /* nodeId */, Optional&lt;String&gt;&amp; /* associatedData */)</span>
<span class="line-added"> 868 {</span>
<span class="line-added"> 869     errorString = &quot;Not supported&quot;_s;</span>
<span class="line-added"> 870 }</span>
<span class="line-added"> 871 </span>
<span class="line-added"> 872 void InspectorDOMAgent::getEventListenersForNode(ErrorString&amp; errorString, int nodeId, RefPtr&lt;JSON::ArrayOf&lt;Inspector::Protocol::DOM::EventListener&gt;&gt;&amp; listenersArray)</span>
 873 {
 874     listenersArray = JSON::ArrayOf&lt;Inspector::Protocol::DOM::EventListener&gt;::create();
<span class="line-modified"> 875 </span>
<span class="line-added"> 876     auto* node = assertNode(errorString, nodeId);</span>
 877     if (!node)
 878         return;
<span class="line-added"> 879 </span>
<span class="line-added"> 880     Vector&lt;RefPtr&lt;EventTarget&gt;&gt; ancestors;</span>
<span class="line-added"> 881     ancestors.append(node);</span>
<span class="line-added"> 882     for (auto* ancestor = node-&gt;parentOrShadowHostNode(); ancestor; ancestor = ancestor-&gt;parentOrShadowHostNode())</span>
<span class="line-added"> 883         ancestors.append(ancestor);</span>
<span class="line-added"> 884     if (auto* window = node-&gt;document().domWindow())</span>
<span class="line-added"> 885         ancestors.append(window);</span>
<span class="line-added"> 886 </span>
<span class="line-added"> 887     struct EventListenerInfo {</span>
<span class="line-added"> 888         RefPtr&lt;EventTarget&gt; eventTarget;</span>
<span class="line-added"> 889         const AtomString eventType;</span>
<span class="line-added"> 890         const EventListenerVector eventListeners;</span>
<span class="line-added"> 891     };</span>
<span class="line-added"> 892 </span>
 893     Vector&lt;EventListenerInfo&gt; eventInformation;
<span class="line-modified"> 894     for (size_t i = ancestors.size(); i; --i) {</span>
<span class="line-added"> 895         auto&amp; ancestor = ancestors[i - 1];</span>
<span class="line-added"> 896         for (auto&amp; eventType : ancestor-&gt;eventTypes()) {</span>
<span class="line-added"> 897             EventListenerVector filteredListeners;</span>
<span class="line-added"> 898             for (auto&amp; listener : ancestor-&gt;eventListeners(eventType)) {</span>
<span class="line-added"> 899                 if (listener-&gt;callback().type() == EventListener::JSEventListenerType)</span>
<span class="line-added"> 900                     filteredListeners.append(listener);</span>
<span class="line-added"> 901             }</span>
<span class="line-added"> 902             if (!filteredListeners.isEmpty())</span>
<span class="line-added"> 903                 eventInformation.append({ ancestor, eventType, WTFMove(filteredListeners) });</span>
<span class="line-added"> 904         }</span>
<span class="line-added"> 905     }</span>
 906 
 907     auto addListener = [&amp;] (RegisteredEventListener&amp; listener, const EventListenerInfo&amp; info) {
 908         int identifier = 0;
 909         bool disabled = false;
 910         bool hasBreakpoint = false;
 911 
 912         for (auto&amp; inspectorEventListener : m_eventListenerEntries.values()) {
<span class="line-modified"> 913             if (inspectorEventListener.matches(*info.eventTarget, info.eventType, listener.callback(), listener.useCapture())) {</span>
 914                 identifier = inspectorEventListener.identifier;
 915                 disabled = inspectorEventListener.disabled;
 916                 hasBreakpoint = inspectorEventListener.hasBreakpoint;
 917                 break;
 918             }
 919         }
 920 
 921         if (!identifier) {
<span class="line-modified"> 922             InspectorEventListener inspectorEventListener(m_lastEventListenerId++, *info.eventTarget, info.eventType, listener.callback(), listener.useCapture());</span>
 923 
 924             identifier = inspectorEventListener.identifier;
 925             disabled = inspectorEventListener.disabled;
 926             hasBreakpoint = inspectorEventListener.hasBreakpoint;
 927 
 928             m_eventListenerEntries.add(identifier, inspectorEventListener);
 929         }
 930 
<span class="line-modified"> 931         listenersArray-&gt;addItem(buildObjectForEventListener(listener, identifier, *info.eventTarget, info.eventType, disabled, hasBreakpoint));</span>
 932     };
 933 
 934     // Get Capturing Listeners (in this order)
 935     size_t eventInformationLength = eventInformation.size();
 936     for (auto&amp; info : eventInformation) {
<span class="line-modified"> 937         for (auto&amp; listener : info.eventListeners) {</span>
 938             if (listener-&gt;useCapture())
 939                 addListener(*listener, info);
 940         }
 941     }
 942 
 943     // Get Bubbling Listeners (reverse order)
 944     for (size_t i = eventInformationLength; i; --i) {
 945         const EventListenerInfo&amp; info = eventInformation[i - 1];
<span class="line-modified"> 946         for (auto&amp; listener : info.eventListeners) {</span>
 947             if (!listener-&gt;useCapture())
 948                 addListener(*listener, info);
 949         }
 950     }












 951 
<span class="line-modified"> 952     if (m_inspectedNode == node)</span>
<span class="line-modified"> 953         m_suppressEventListenerChangedEvent = false;</span>

















 954 }
 955 
 956 void InspectorDOMAgent::setEventListenerDisabled(ErrorString&amp; errorString, int eventListenerId, bool disabled)
 957 {
 958     auto it = m_eventListenerEntries.find(eventListenerId);
 959     if (it == m_eventListenerEntries.end()) {
<span class="line-modified"> 960         errorString = &quot;Missing event listener for given eventListenerId&quot;_s;</span>
 961         return;
 962     }
 963 
 964     it-&gt;value.disabled = disabled;
 965 }
 966 
 967 void InspectorDOMAgent::setBreakpointForEventListener(ErrorString&amp; errorString, int eventListenerId)
 968 {
 969     auto it = m_eventListenerEntries.find(eventListenerId);
 970     if (it == m_eventListenerEntries.end()) {
<span class="line-modified"> 971         errorString = &quot;Missing event listener for given eventListenerId&quot;_s;</span>
 972         return;
 973     }
 974 
 975     it-&gt;value.hasBreakpoint = true;
 976 }
 977 
 978 void InspectorDOMAgent::removeBreakpointForEventListener(ErrorString&amp; errorString, int eventListenerId)
 979 {
 980     auto it = m_eventListenerEntries.find(eventListenerId);
 981     if (it == m_eventListenerEntries.end()) {
<span class="line-modified"> 982         errorString = &quot;Missing event listener for given eventListenerId&quot;_s;</span>
 983         return;
 984     }
 985 
 986     it-&gt;value.hasBreakpoint = false;
 987 }
 988 
 989 void InspectorDOMAgent::getAccessibilityPropertiesForNode(ErrorString&amp; errorString, int nodeId, RefPtr&lt;Inspector::Protocol::DOM::AccessibilityProperties&gt;&amp; axProperties)
 990 {
 991     Node* node = assertNode(errorString, nodeId);
 992     if (!node)
 993         return;
 994 
 995     axProperties = buildObjectForAccessibilityProperties(node);
 996 }
 997 
<span class="line-modified"> 998 void InspectorDOMAgent::performSearch(ErrorString&amp; errorString, const String&amp; query, const JSON::Array* nodeIds, const bool* caseSensitive, String* searchId, int* resultCount)</span>
 999 {
1000     // FIXME: Search works with node granularity - number of matches within node is not calculated.
<span class="line-modified">1001     InspectorNodeFinder finder(query, caseSensitive &amp;&amp; *caseSensitive);</span>
1002 
1003     if (nodeIds) {
1004         for (auto&amp; nodeValue : *nodeIds) {
1005             if (!nodeValue) {
<span class="line-modified">1006                 errorString = &quot;Unexpected non-integer item in given nodeIds&quot;_s;</span>
1007                 return;
1008             }
1009             int nodeId = 0;
1010             if (!nodeValue-&gt;asInteger(nodeId)) {
<span class="line-modified">1011                 errorString = &quot;Unexpected non-integer item in given nodeIds&quot;_s;</span>
1012                 return;
1013             }
1014             Node* node = assertNode(errorString, nodeId);
1015             if (!node) {
1016                 // assertNode should have filled the errorString for us.
1017                 ASSERT(errorString.length());
1018                 return;
1019             }
1020             finder.performSearch(node);
1021         }
1022     } else {
1023         // There&#39;s no need to iterate the frames tree because
1024         // the search helper will go inside the frame owner elements.
1025         finder.performSearch(m_document.get());
1026     }
1027 
1028     *searchId = IdentifiersFactory::createIdentifier();
1029 
1030     auto&amp; resultsVector = m_searchResults.add(*searchId, Vector&lt;RefPtr&lt;Node&gt;&gt;()).iterator-&gt;value;
1031     for (auto&amp; result : finder.results())
1032         resultsVector.append(result);
1033 
1034     *resultCount = resultsVector.size();
1035 }
1036 
1037 void InspectorDOMAgent::getSearchResults(ErrorString&amp; errorString, const String&amp; searchId, int fromIndex, int toIndex, RefPtr&lt;JSON::ArrayOf&lt;int&gt;&gt;&amp; nodeIds)
1038 {
1039     SearchResults::iterator it = m_searchResults.find(searchId);
1040     if (it == m_searchResults.end()) {
<span class="line-modified">1041         errorString = &quot;Missing search result for given searchId&quot;_s;</span>
1042         return;
1043     }
1044 
1045     int size = it-&gt;value.size();
1046     if (fromIndex &lt; 0 || toIndex &gt; size || fromIndex &gt;= toIndex) {
<span class="line-modified">1047         errorString = &quot;Invalid search result range for given fromIndex and toIndex&quot;_s;</span>
1048         return;
1049     }
1050 
1051     nodeIds = JSON::ArrayOf&lt;int&gt;::create();
1052     for (int i = fromIndex; i &lt; toIndex; ++i)
1053         nodeIds-&gt;addItem(pushNodePathToFrontend((it-&gt;value)[i].get()));
1054 }
1055 
1056 void InspectorDOMAgent::discardSearchResults(ErrorString&amp;, const String&amp; searchId)
1057 {
1058     m_searchResults.remove(searchId);
1059 }
1060 
1061 bool InspectorDOMAgent::handleMousePress()
1062 {
1063     if (!m_searchingForNode)
1064         return false;
1065 
1066     if (Node* node = m_overlay-&gt;highlightedNode()) {
1067         inspect(node);
1068         return true;
1069     }
1070     return false;
1071 }
1072 
1073 bool InspectorDOMAgent::handleTouchEvent(Node&amp; node)
1074 {
1075     if (!m_searchingForNode)
1076         return false;
1077     if (m_inspectModeHighlightConfig) {
1078         m_overlay-&gt;highlightNode(&amp;node, *m_inspectModeHighlightConfig);
1079         inspect(&amp;node);
1080         return true;
1081     }
1082     return false;
1083 }
1084 
1085 void InspectorDOMAgent::inspect(Node* inspectedNode)
1086 {
<span class="line-modified">1087     ErrorString ignored;</span>
1088     RefPtr&lt;Node&gt; node = inspectedNode;
<span class="line-modified">1089     setSearchingForNode(ignored, false, nullptr, false);</span>
1090 
1091     if (node-&gt;nodeType() != Node::ELEMENT_NODE &amp;&amp; node-&gt;nodeType() != Node::DOCUMENT_NODE)
1092         node = node-&gt;parentNode();
1093     m_nodeToFocus = node;
1094 
1095     if (!m_nodeToFocus)
1096         return;
1097 
1098     focusNode();
1099 }
1100 
1101 void InspectorDOMAgent::focusNode()
1102 {
<span class="line-modified">1103     if (!m_documentRequested)</span>
1104         return;
1105 
1106     ASSERT(m_nodeToFocus);
1107 
1108     RefPtr&lt;Node&gt; node = m_nodeToFocus.get();
1109     m_nodeToFocus = nullptr;
1110 
1111     Frame* frame = node-&gt;document().frame();
1112     if (!frame)
1113         return;
1114 
1115     JSC::ExecState* scriptState = mainWorldExecState(frame);
1116     InjectedScript injectedScript = m_injectedScriptManager.injectedScriptFor(scriptState);
1117     if (injectedScript.hasNoValue())
1118         return;
1119 
1120     injectedScript.inspectObject(nodeAsScriptValue(*scriptState, node.get()));
1121 }
1122 
1123 void InspectorDOMAgent::mouseDidMoveOverElement(const HitTestResult&amp; result, unsigned)
1124 {
1125     m_mousedOverNode = result.innerNode();
1126 
1127     if (!m_searchingForNode)
1128         return;
1129 
1130     highlightMousedOverNode();
1131 }
1132 
1133 void InspectorDOMAgent::highlightMousedOverNode()
1134 {
1135     Node* node = m_mousedOverNode.get();
1136     while (node &amp;&amp; node-&gt;nodeType() == Node::TEXT_NODE)
1137         node = node-&gt;parentNode();
1138     if (node &amp;&amp; m_inspectModeHighlightConfig)
1139         m_overlay-&gt;highlightNode(node, *m_inspectModeHighlightConfig);
1140 }
1141 
<span class="line-modified">1142 void InspectorDOMAgent::setSearchingForNode(ErrorString&amp; errorString, bool enabled, const JSON::Object* highlightInspectorObject, bool showRulers)</span>
1143 {
1144     if (m_searchingForNode == enabled)
1145         return;
1146 
1147     m_searchingForNode = enabled;
1148 
<span class="line-modified">1149     m_overlay-&gt;setShowRulersDuringElementSelection(m_searchingForNode &amp;&amp; showRulers);</span>
<span class="line-added">1150 </span>
<span class="line-added">1151     if (m_searchingForNode) {</span>
1152         m_inspectModeHighlightConfig = highlightConfigFromInspectorObject(errorString, highlightInspectorObject);
1153         if (!m_inspectModeHighlightConfig)
1154             return;
1155         highlightMousedOverNode();
1156     } else
1157         hideHighlight(errorString);
1158 
1159     m_overlay-&gt;didSetSearchingForNode(m_searchingForNode);
1160 
<span class="line-modified">1161     if (InspectorClient* client = m_inspectedPage.inspectorController().inspectorClient())</span>
1162         client-&gt;elementSelectionChanged(m_searchingForNode);
1163 }
1164 
1165 std::unique_ptr&lt;HighlightConfig&gt; InspectorDOMAgent::highlightConfigFromInspectorObject(ErrorString&amp; errorString, const JSON::Object* highlightInspectorObject)
1166 {
1167     if (!highlightInspectorObject) {
1168         errorString = &quot;Internal error: highlight configuration parameter is missing&quot;_s;
1169         return nullptr;
1170     }
1171 
<span class="line-modified">1172     auto highlightConfig = makeUnique&lt;HighlightConfig&gt;();</span>
1173     bool showInfo = false; // Default: false (do not show a tooltip).
1174     highlightInspectorObject-&gt;getBoolean(&quot;showInfo&quot;, showInfo);
1175     highlightConfig-&gt;showInfo = showInfo;
1176     highlightConfig-&gt;content = parseConfigColor(&quot;contentColor&quot;, highlightInspectorObject);
1177     highlightConfig-&gt;contentOutline = parseConfigColor(&quot;contentOutlineColor&quot;, highlightInspectorObject);
1178     highlightConfig-&gt;padding = parseConfigColor(&quot;paddingColor&quot;, highlightInspectorObject);
1179     highlightConfig-&gt;border = parseConfigColor(&quot;borderColor&quot;, highlightInspectorObject);
1180     highlightConfig-&gt;margin = parseConfigColor(&quot;marginColor&quot;, highlightInspectorObject);
1181     return highlightConfig;
1182 }
1183 
<span class="line-modified">1184 void InspectorDOMAgent::setInspectModeEnabled(ErrorString&amp; errorString, bool enabled, const JSON::Object* highlightConfig, const bool* showRulers)</span>
1185 {
<span class="line-modified">1186     setSearchingForNode(errorString, enabled, highlightConfig ? highlightConfig : nullptr, showRulers &amp;&amp; *showRulers);</span>
1187 }
1188 
1189 void InspectorDOMAgent::highlightRect(ErrorString&amp;, int x, int y, int width, int height, const JSON::Object* color, const JSON::Object* outlineColor, const bool* usePageCoordinates)
1190 {
<span class="line-modified">1191     auto quad = makeUnique&lt;FloatQuad&gt;(FloatRect(x, y, width, height));</span>
1192     innerHighlightQuad(WTFMove(quad), color, outlineColor, usePageCoordinates);
1193 }
1194 
1195 void InspectorDOMAgent::highlightQuad(ErrorString&amp; errorString, const JSON::Array&amp; quadArray, const JSON::Object* color, const JSON::Object* outlineColor, const bool* usePageCoordinates)
1196 {
<span class="line-modified">1197     auto quad = makeUnique&lt;FloatQuad&gt;();</span>
1198     if (!parseQuad(quadArray, quad.get())) {
<span class="line-modified">1199         errorString = &quot;Unexpected invalid quadArray&quot;_s;</span>
1200         return;
1201     }
1202     innerHighlightQuad(WTFMove(quad), color, outlineColor, usePageCoordinates);
1203 }
1204 
1205 void InspectorDOMAgent::innerHighlightQuad(std::unique_ptr&lt;FloatQuad&gt; quad, const JSON::Object* color, const JSON::Object* outlineColor, const bool* usePageCoordinates)
1206 {
<span class="line-modified">1207     auto highlightConfig = makeUnique&lt;HighlightConfig&gt;();</span>
1208     highlightConfig-&gt;content = parseColor(color);
1209     highlightConfig-&gt;contentOutline = parseColor(outlineColor);
1210     highlightConfig-&gt;usePageCoordinates = usePageCoordinates ? *usePageCoordinates : false;
1211     m_overlay-&gt;highlightQuad(WTFMove(quad), *highlightConfig);
1212 }
1213 
1214 void InspectorDOMAgent::highlightSelector(ErrorString&amp; errorString, const JSON::Object&amp; highlightInspectorObject, const String&amp; selectorString, const String* frameId)
1215 {
1216     RefPtr&lt;Document&gt; document;
1217 
1218     if (frameId) {
<span class="line-modified">1219         auto* pageAgent = m_instrumentingAgents.inspectorPageAgent();</span>
<span class="line-modified">1220         if (!pageAgent) {</span>
<span class="line-modified">1221             errorString = &quot;Page domain must be enabled&quot;_s;</span>
1222             return;
1223         }
1224 
<span class="line-added">1225         auto* frame = pageAgent-&gt;assertFrame(errorString, *frameId);</span>
<span class="line-added">1226         if (!frame)</span>
<span class="line-added">1227             return;</span>
<span class="line-added">1228 </span>
1229         document = frame-&gt;document();
1230     } else
1231         document = m_document;
1232 
1233     if (!document) {
<span class="line-modified">1234         errorString = &quot;Missing document of frame for given frameId&quot;_s;</span>
1235         return;
1236     }
1237 
1238     auto queryResult = document-&gt;querySelectorAll(selectorString);
1239     // FIXME: &lt;https://webkit.org/b/146161&gt; Web Inspector: DOM.highlightSelector should work for &quot;a:visited&quot;
1240     if (queryResult.hasException()) {
<span class="line-modified">1241         errorString = &quot;DOM Error while querying with given selectorString&quot;_s;</span>
1242         return;
1243     }
1244 
1245     auto highlightConfig = highlightConfigFromInspectorObject(errorString, &amp;highlightInspectorObject);
1246     if (!highlightConfig)
1247         return;
1248 
1249     m_overlay-&gt;highlightNodeList(queryResult.releaseReturnValue(), *highlightConfig);
1250 }
1251 
1252 void InspectorDOMAgent::highlightNode(ErrorString&amp; errorString, const JSON::Object&amp; highlightInspectorObject, const int* nodeId, const String* objectId)
1253 {
1254     Node* node = nullptr;
1255     if (nodeId)
1256         node = assertNode(errorString, *nodeId);
1257     else if (objectId) {
1258         node = nodeForObjectId(*objectId);
1259         if (!node)
<span class="line-modified">1260             errorString = &quot;Missing node for given objectId&quot;_s;</span>
1261     } else
1262         errorString = &quot;Either nodeId or objectId must be specified&quot;_s;
1263 
1264     if (!node)
1265         return;
1266 
1267     std::unique_ptr&lt;HighlightConfig&gt; highlightConfig = highlightConfigFromInspectorObject(errorString, &amp;highlightInspectorObject);
1268     if (!highlightConfig)
1269         return;
1270 
1271     m_overlay-&gt;highlightNode(node, *highlightConfig);
1272 }
1273 
1274 void InspectorDOMAgent::highlightNodeList(ErrorString&amp; errorString, const JSON::Array&amp; nodeIds, const JSON::Object&amp; highlightInspectorObject)
1275 {
1276     Vector&lt;Ref&lt;Node&gt;&gt; nodes;
1277     for (auto&amp; nodeValue : nodeIds) {
1278         if (!nodeValue) {
<span class="line-modified">1279             errorString = &quot;Unexpected non-integer item in given nodeIds&quot;_s;</span>
1280             return;
1281         }
1282 
1283         int nodeId = 0;
1284         if (!nodeValue-&gt;asInteger(nodeId)) {
<span class="line-modified">1285             errorString = &quot;Unexpected non-integer item in given nodeIds&quot;_s;</span>
1286             return;
1287         }
1288 
1289         // In the case that a node is removed in the time between when highlightNodeList is invoked
1290         // by the frontend and it is executed by the backend, we should still attempt to highlight
1291         // as many nodes as possible. As such, we should ignore any errors generated when attempting
1292         // to get a Node from a given nodeId.
1293         ErrorString ignored;
1294         Node* node = assertNode(ignored, nodeId);
1295         if (!node)
1296             continue;
1297 
1298         nodes.append(*node);
1299     }
1300 
1301     std::unique_ptr&lt;HighlightConfig&gt; highlightConfig = highlightConfigFromInspectorObject(errorString, &amp;highlightInspectorObject);
1302     if (!highlightConfig)
1303         return;
1304 
1305     m_overlay-&gt;highlightNodeList(StaticNodeList::create(WTFMove(nodes)), *highlightConfig);
1306 }
1307 
1308 void InspectorDOMAgent::highlightFrame(ErrorString&amp; errorString, const String&amp; frameId, const JSON::Object* color, const JSON::Object* outlineColor)
1309 {
<span class="line-modified">1310     auto* pageAgent = m_instrumentingAgents.inspectorPageAgent();</span>
<span class="line-added">1311     if (!pageAgent) {</span>
<span class="line-added">1312         errorString = &quot;Page domain must be enabled&quot;_s;</span>
<span class="line-added">1313         return;</span>
<span class="line-added">1314     }</span>
<span class="line-added">1315 </span>
<span class="line-added">1316     auto* frame = pageAgent-&gt;assertFrame(errorString, frameId);</span>
1317     if (!frame)
1318         return;
1319 
1320     if (frame-&gt;ownerElement()) {
<span class="line-modified">1321         auto highlightConfig = makeUnique&lt;HighlightConfig&gt;();</span>
1322         highlightConfig-&gt;showInfo = true; // Always show tooltips for frames.
1323         highlightConfig-&gt;content = parseColor(color);
1324         highlightConfig-&gt;contentOutline = parseColor(outlineColor);
1325         m_overlay-&gt;highlightNode(frame-&gt;ownerElement(), *highlightConfig);
1326     }
1327 }
1328 
1329 void InspectorDOMAgent::hideHighlight(ErrorString&amp;)
1330 {
1331     m_overlay-&gt;hideHighlight();
1332 }
1333 
1334 void InspectorDOMAgent::moveTo(ErrorString&amp; errorString, int nodeId, int targetElementId, const int* anchorNodeId, int* newNodeId)
1335 {
1336     Node* node = assertEditableNode(errorString, nodeId);
1337     if (!node)
1338         return;
1339 
1340     Element* targetElement = assertEditableElement(errorString, targetElementId);
1341     if (!targetElement)
1342         return;
1343 
1344     Node* anchorNode = 0;
1345     if (anchorNodeId &amp;&amp; *anchorNodeId) {
1346         anchorNode = assertEditableNode(errorString, *anchorNodeId);
1347         if (!anchorNode)
1348             return;
1349         if (anchorNode-&gt;parentNode() != targetElement) {
<span class="line-modified">1350             errorString = &quot;Given anchorNodeId must be a child of given targetElementId&quot;_s;</span>
1351             return;
1352         }
1353     }
1354 
1355     if (!m_domEditor-&gt;insertBefore(*targetElement, *node, anchorNode, errorString))
1356         return;
1357 
1358     *newNodeId = pushNodePathToFrontend(node);
1359 }
1360 
1361 void InspectorDOMAgent::undo(ErrorString&amp; errorString)
1362 {
1363     auto result = m_history-&gt;undo();
1364     if (result.hasException())
1365         errorString = toErrorString(result.releaseException());
1366 }
1367 
1368 void InspectorDOMAgent::redo(ErrorString&amp; errorString)
1369 {
1370     auto result = m_history-&gt;redo();
1371     if (result.hasException())
1372         errorString = toErrorString(result.releaseException());
1373 }
1374 
1375 void InspectorDOMAgent::markUndoableState(ErrorString&amp;)
1376 {
1377     m_history-&gt;markUndoableState();
1378 }
1379 
1380 void InspectorDOMAgent::focus(ErrorString&amp; errorString, int nodeId)
1381 {
1382     Element* element = assertElement(errorString, nodeId);
1383     if (!element)
1384         return;
1385     if (!element-&gt;isFocusable()) {
<span class="line-modified">1386         errorString = &quot;Element for given nodeId is not focusable&quot;_s;</span>
1387         return;
1388     }
1389     element-&gt;focus();
1390 }
1391 
1392 void InspectorDOMAgent::setInspectedNode(ErrorString&amp; errorString, int nodeId)
1393 {
<span class="line-modified">1394     Node* node = assertNode(errorString, nodeId);</span>
<span class="line-modified">1395     if (!node)</span>
<span class="line-modified">1396         return;</span>
<span class="line-added">1397 </span>
<span class="line-added">1398     if (node-&gt;isInUserAgentShadowTree()) {</span>
<span class="line-added">1399         errorString = &quot;Node for given nodeId is in a shadow tree&quot;_s;</span>
1400         return;
1401     }
1402 
<span class="line-modified">1403     m_inspectedNode = node;</span>
<span class="line-modified">1404 </span>
<span class="line-added">1405     if (auto&amp; commandLineAPIHost = static_cast&lt;WebInjectedScriptManager&amp;&gt;(m_injectedScriptManager).commandLineAPIHost())</span>
<span class="line-added">1406         commandLineAPIHost-&gt;addInspectedObject(makeUnique&lt;InspectableNode&gt;(node));</span>
<span class="line-added">1407 </span>
<span class="line-added">1408     m_suppressEventListenerChangedEvent = false;</span>
1409 }
1410 
1411 void InspectorDOMAgent::resolveNode(ErrorString&amp; errorString, int nodeId, const String* objectGroup, RefPtr&lt;Inspector::Protocol::Runtime::RemoteObject&gt;&amp; result)
1412 {
1413     String objectGroupName = objectGroup ? *objectGroup : emptyString();
<span class="line-modified">1414     Node* node = assertNode(errorString, nodeId);</span>
<span class="line-modified">1415     if (!node)</span>

1416         return;

1417     RefPtr&lt;Inspector::Protocol::Runtime::RemoteObject&gt; object = resolveNode(node, objectGroupName);
1418     if (!object) {
<span class="line-modified">1419         errorString = &quot;Missing injected script for given nodeId&quot;_s;</span>
1420         return;
1421     }
1422     result = object;
1423 }
1424 
1425 void InspectorDOMAgent::getAttributes(ErrorString&amp; errorString, int nodeId, RefPtr&lt;JSON::ArrayOf&lt;String&gt;&gt;&amp; result)
1426 {
1427     Element* element = assertElement(errorString, nodeId);
1428     if (!element)
1429         return;
1430 
1431     result = buildArrayForElementAttributes(element);
1432 }
1433 
1434 void InspectorDOMAgent::requestNode(ErrorString&amp;, const String&amp; objectId, int* nodeId)
1435 {
1436     Node* node = nodeForObjectId(objectId);
1437     if (node)
1438         *nodeId = pushNodePathToFrontend(node);
1439     else
</pre>
<hr />
<pre>
1537         localName = node-&gt;localName();
1538         break;
1539     }
1540 
1541     auto value = Inspector::Protocol::DOM::Node::create()
1542         .setNodeId(id)
1543         .setNodeType(static_cast&lt;int&gt;(node-&gt;nodeType()))
1544         .setNodeName(nodeName)
1545         .setLocalName(localName)
1546         .setNodeValue(nodeValue)
1547         .release();
1548 
1549     if (node-&gt;isContainerNode()) {
1550         int nodeCount = innerChildNodeCount(node);
1551         value-&gt;setChildNodeCount(nodeCount);
1552         Ref&lt;JSON::ArrayOf&lt;Inspector::Protocol::DOM::Node&gt;&gt; children = buildArrayForContainerChildren(node, depth, nodesMap);
1553         if (children-&gt;length() &gt; 0)
1554             value-&gt;setChildren(WTFMove(children));
1555     }
1556 
<span class="line-added">1557     auto* pageAgent = m_instrumentingAgents.inspectorPageAgent();</span>
<span class="line-added">1558     if (pageAgent) {</span>
<span class="line-added">1559         if (auto* frameView = node-&gt;document().view())</span>
<span class="line-added">1560             value-&gt;setFrameId(pageAgent-&gt;frameId(&amp;frameView-&gt;frame()));</span>
<span class="line-added">1561     }</span>
<span class="line-added">1562 </span>
1563     if (is&lt;Element&gt;(*node)) {
1564         Element&amp; element = downcast&lt;Element&gt;(*node);
1565         value-&gt;setAttributes(buildArrayForElementAttributes(&amp;element));
1566         if (is&lt;HTMLFrameOwnerElement&gt;(element)) {
<span class="line-modified">1567             if (auto* document = downcast&lt;HTMLFrameOwnerElement&gt;(element).contentDocument())</span>





1568                 value-&gt;setContentDocument(buildObjectForNode(document, 0, nodesMap));
1569         }
1570 
1571         if (ShadowRoot* root = element.shadowRoot()) {
1572             auto shadowRoots = JSON::ArrayOf&lt;Inspector::Protocol::DOM::Node&gt;::create();
1573             shadowRoots-&gt;addItem(buildObjectForNode(root, 0, nodesMap));
1574             value-&gt;setShadowRoots(WTFMove(shadowRoots));
1575         }
1576 
1577         if (is&lt;HTMLTemplateElement&gt;(element))
1578             value-&gt;setTemplateContent(buildObjectForNode(&amp;downcast&lt;HTMLTemplateElement&gt;(element).content(), 0, nodesMap));
1579 
1580         if (is&lt;HTMLStyleElement&gt;(element) || (is&lt;HTMLScriptElement&gt;(element) &amp;&amp; !element.hasAttributeWithoutSynchronization(HTMLNames::srcAttr)))
1581             value-&gt;setContentSecurityPolicyHash(computeContentSecurityPolicySHA256Hash(element));
1582 
1583         auto state = customElementState(element);
1584         if (state != Inspector::Protocol::DOM::CustomElementState::Builtin)
1585             value-&gt;setCustomElementState(state);
1586 
1587         if (element.pseudoId() != PseudoId::None) {
1588             Inspector::Protocol::DOM::PseudoType pseudoType;
1589             if (pseudoElementType(element.pseudoId(), &amp;pseudoType))
1590                 value-&gt;setPseudoType(pseudoType);
1591         } else {
1592             if (auto pseudoElements = buildArrayForPseudoElements(element, nodesMap))
1593                 value-&gt;setPseudoElements(WTFMove(pseudoElements));
1594         }

1595     } else if (is&lt;Document&gt;(*node)) {
1596         Document&amp; document = downcast&lt;Document&gt;(*node);
<span class="line-modified">1597         if (pageAgent)</span>
<span class="line-added">1598             value-&gt;setFrameId(pageAgent-&gt;frameId(document.frame()));</span>
1599         value-&gt;setDocumentURL(documentURLString(&amp;document));
1600         value-&gt;setBaseURL(documentBaseURLString(&amp;document));
1601         value-&gt;setXmlVersion(document.xmlVersion());
1602     } else if (is&lt;DocumentType&gt;(*node)) {
1603         DocumentType&amp; docType = downcast&lt;DocumentType&gt;(*node);
1604         value-&gt;setPublicId(docType.publicId());
1605         value-&gt;setSystemId(docType.systemId());
1606     } else if (is&lt;Attr&gt;(*node)) {
1607         Attr&amp; attribute = downcast&lt;Attr&gt;(*node);
1608         value-&gt;setName(attribute.name());
1609         value-&gt;setValue(attribute.value());
1610     } else if (is&lt;ShadowRoot&gt;(*node)) {
1611         ShadowRoot&amp; shadowRoot = downcast&lt;ShadowRoot&gt;(*node);
1612         value-&gt;setShadowRootType(shadowRootType(shadowRoot.mode()));
1613     }
1614 
1615     return value;
1616 }
1617 
1618 Ref&lt;JSON::ArrayOf&lt;String&gt;&gt; InspectorDOMAgent::buildArrayForElementAttributes(Element* element)
</pre>
<hr />
<pre>
1648 
1649     while (child) {
1650         children-&gt;addItem(buildObjectForNode(child, depth, nodesMap));
1651         child = innerNextSibling(child);
1652     }
1653     return children;
1654 }
1655 
1656 RefPtr&lt;JSON::ArrayOf&lt;Inspector::Protocol::DOM::Node&gt;&gt; InspectorDOMAgent::buildArrayForPseudoElements(const Element&amp; element, NodeToIdMap* nodesMap)
1657 {
1658     PseudoElement* beforeElement = element.beforePseudoElement();
1659     PseudoElement* afterElement = element.afterPseudoElement();
1660     if (!beforeElement &amp;&amp; !afterElement)
1661         return nullptr;
1662 
1663     auto pseudoElements = JSON::ArrayOf&lt;Inspector::Protocol::DOM::Node&gt;::create();
1664     if (beforeElement)
1665         pseudoElements-&gt;addItem(buildObjectForNode(beforeElement, 0, nodesMap));
1666     if (afterElement)
1667         pseudoElements-&gt;addItem(buildObjectForNode(afterElement, 0, nodesMap));
<span class="line-modified">1668     return pseudoElements;</span>
1669 }
1670 
<span class="line-modified">1671 Ref&lt;Inspector::Protocol::DOM::EventListener&gt; InspectorDOMAgent::buildObjectForEventListener(const RegisteredEventListener&amp; registeredEventListener, int identifier, EventTarget&amp; eventTarget, const AtomString&amp; eventType, bool disabled, bool hasBreakpoint)</span>
1672 {
1673     Ref&lt;EventListener&gt; eventListener = registeredEventListener.callback();
1674 



1675     String handlerName;
1676     int lineNumber = 0;
1677     int columnNumber = 0;
1678     String scriptID;
1679     if (is&lt;JSEventListener&gt;(eventListener.get())) {
1680         auto&amp; scriptListener = downcast&lt;JSEventListener&gt;(eventListener.get());
1681 
<span class="line-added">1682         Document* document = nullptr;</span>
<span class="line-added">1683         if (auto* scriptExecutionContext = eventTarget.scriptExecutionContext()) {</span>
<span class="line-added">1684             if (is&lt;Document&gt;(scriptExecutionContext))</span>
<span class="line-added">1685                 document = downcast&lt;Document&gt;(scriptExecutionContext);</span>
<span class="line-added">1686         } else if (is&lt;Node&gt;(eventTarget))</span>
<span class="line-added">1687             document = &amp;downcast&lt;Node&gt;(eventTarget).document();</span>
<span class="line-added">1688 </span>
<span class="line-added">1689         JSC::JSObject* handlerObject = nullptr;</span>
<span class="line-added">1690         JSC::ExecState* exec = nullptr;</span>
<span class="line-added">1691 </span>
1692         JSC::JSLockHolder lock(scriptListener.isolatedWorld().vm());
1693 
<span class="line-modified">1694         if (document) {</span>
<span class="line-modified">1695             handlerObject = scriptListener.jsFunction(*document);</span>
<span class="line-added">1696             exec = execStateFromNode(scriptListener.isolatedWorld(), document);</span>
<span class="line-added">1697         }</span>
<span class="line-added">1698 </span>
1699         if (handlerObject &amp;&amp; exec) {
<span class="line-modified">1700             JSC::VM&amp; vm = exec-&gt;vm();</span>
<span class="line-added">1701             JSC::JSFunction* handlerFunction = JSC::jsDynamicCast&lt;JSC::JSFunction*&gt;(vm, handlerObject);</span>
1702 
1703             if (!handlerFunction) {
<span class="line-modified">1704                 auto scope = DECLARE_CATCH_SCOPE(vm);</span>
1705 
1706                 // If the handler is not actually a function, see if it implements the EventListener interface and use that.
<span class="line-modified">1707                 auto handleEventValue = handlerObject-&gt;get(exec, JSC::Identifier::fromString(vm, &quot;handleEvent&quot;));</span>
1708 
1709                 if (UNLIKELY(scope.exception()))
1710                     scope.clearException();
1711 
1712                 if (handleEventValue)
<span class="line-modified">1713                     handlerFunction = JSC::jsDynamicCast&lt;JSC::JSFunction*&gt;(vm, handleEventValue);</span>
1714             }
1715 
1716             if (handlerFunction &amp;&amp; !handlerFunction-&gt;isHostOrBuiltinFunction()) {
1717                 // If the listener implements the EventListener interface, use the class name instead of
1718                 // &quot;handleEvent&quot;, unless it is a plain object.
1719                 if (handlerFunction != handlerObject)
1720                     handlerName = JSC::JSObject::calculatedClassName(handlerObject);
1721                 if (handlerName.isEmpty() || handlerName == &quot;Object&quot;_s)
<span class="line-modified">1722                     handlerName = handlerFunction-&gt;calculatedDisplayName(vm);</span>
1723 
1724                 if (auto executable = handlerFunction-&gt;jsExecutable()) {
1725                     lineNumber = executable-&gt;firstLine() - 1;
1726                     columnNumber = executable-&gt;startColumn() - 1;
1727                     scriptID = executable-&gt;sourceID() == JSC::SourceProvider::nullID ? emptyString() : String::number(executable-&gt;sourceID());
1728                 }
1729             }
1730         }
1731     }
1732 
1733     auto value = Inspector::Protocol::DOM::EventListener::create()
1734         .setEventListenerId(identifier)
1735         .setType(eventType)
1736         .setUseCapture(registeredEventListener.useCapture())
1737         .setIsAttribute(eventListener-&gt;isAttribute())

1738         .release();
<span class="line-modified">1739     if (is&lt;Node&gt;(eventTarget))</span>
<span class="line-modified">1740         value-&gt;setNodeId(pushNodePathToFrontend(&amp;downcast&lt;Node&gt;(eventTarget)));</span>
<span class="line-modified">1741     else if (is&lt;DOMWindow&gt;(eventTarget))</span>
<span class="line-modified">1742         value-&gt;setOnWindow(true);</span>

1743     if (!scriptID.isNull()) {
1744         auto location = Inspector::Protocol::Debugger::Location::create()
1745             .setScriptId(scriptID)
1746             .setLineNumber(lineNumber)
1747             .release();
1748         location-&gt;setColumnNumber(columnNumber);
1749         value-&gt;setLocation(WTFMove(location));
1750     }
1751     if (!handlerName.isEmpty())
1752         value-&gt;setHandlerName(handlerName);
1753     if (registeredEventListener.isPassive())
1754         value-&gt;setPassive(true);
1755     if (registeredEventListener.isOnce())
1756         value-&gt;setOnce(true);
1757     if (disabled)
1758         value-&gt;setDisabled(disabled);
1759     if (hasBreakpoint)
1760         value-&gt;setHasBreakpoint(hasBreakpoint);
1761     return value;
1762 }
</pre>
<hr />
<pre>
2060             value-&gt;setReadonly(readonly);
2061         if (supportsRequired)
2062             value-&gt;setRequired(required);
2063         if (selected)
2064             value-&gt;setSelected(selected);
2065         if (selectedChildNodeIds)
2066             value-&gt;setSelectedChildNodeIds(selectedChildNodeIds);
2067 
2068         // H1 -- H6 always have a headingLevel property that can be complimented by a hierarchicalLevel
2069         // property when aria-level is set on the element, in which case we want to remain calling
2070         // this value the &quot;Heading Level&quot; in the inspector.
2071         // Also, we do not want it to say Hierarchy Level: 0
2072         if (headingLevel)
2073             value-&gt;setHeadingLevel(level);
2074         else if (level)
2075             value-&gt;setHierarchyLevel(level);
2076         if (isPopupButton)
2077             value-&gt;setIsPopUpButton(isPopupButton);
2078     }
2079 
<span class="line-modified">2080     return value;</span>
2081 }
2082 
2083 static bool containsOnlyHTMLWhitespace(Node* node)
2084 {
2085     // FIXME: Respect ignoreWhitespace setting from inspector front end?
2086     return is&lt;Text&gt;(node) &amp;&amp; downcast&lt;Text&gt;(*node).data().isAllSpecialCharacters&lt;isHTMLSpace&gt;();
2087 }
2088 
2089 Node* InspectorDOMAgent::innerFirstChild(Node* node)
2090 {
2091     node = node-&gt;firstChild();
2092     while (containsOnlyHTMLWhitespace(node))
2093         node = node-&gt;nextSibling();
2094     return node;
2095 }
2096 
2097 Node* InspectorDOMAgent::innerNextSibling(Node* node)
2098 {
2099     do {
2100         node = node-&gt;nextSibling();
</pre>
<hr />
<pre>
2113 unsigned InspectorDOMAgent::innerChildNodeCount(Node* node)
2114 {
2115     unsigned count = 0;
2116     for (Node* child = innerFirstChild(node); child; child = innerNextSibling(child))
2117         ++count;
2118     return count;
2119 }
2120 
2121 Node* InspectorDOMAgent::innerParentNode(Node* node)
2122 {
2123     ASSERT(node);
2124     if (is&lt;Document&gt;(*node))
2125         return downcast&lt;Document&gt;(*node).ownerElement();
2126     if (is&lt;ShadowRoot&gt;(*node))
2127         return downcast&lt;ShadowRoot&gt;(*node).host();
2128     return node-&gt;parentNode();
2129 }
2130 
2131 void InspectorDOMAgent::didCommitLoad(Document* document)
2132 {
<span class="line-added">2133     if (m_nodeToFocus &amp;&amp; &amp;m_nodeToFocus-&gt;document() == document)</span>
<span class="line-added">2134         m_nodeToFocus = nullptr;</span>
<span class="line-added">2135 </span>
<span class="line-added">2136     if (m_mousedOverNode &amp;&amp; &amp;m_mousedOverNode-&gt;document() == document)</span>
<span class="line-added">2137         m_mousedOverNode = nullptr;</span>
<span class="line-added">2138 </span>
<span class="line-added">2139     if (m_inspectedNode &amp;&amp; &amp;m_inspectedNode-&gt;document() == document)</span>
<span class="line-added">2140         m_inspectedNode = nullptr;</span>
<span class="line-added">2141 </span>
2142     RefPtr&lt;Element&gt; frameOwner = document-&gt;ownerElement();
2143     if (!frameOwner)
2144         return;
2145 
2146     int frameOwnerId = m_documentNodeToIdMap.get(frameOwner);
2147     if (!frameOwnerId)
2148         return;
2149 
2150     // Re-add frame owner element together with its new children.
2151     int parentId = m_documentNodeToIdMap.get(innerParentNode(frameOwner.get()));
2152     m_frontendDispatcher-&gt;childNodeRemoved(parentId, frameOwnerId);
2153     unbind(frameOwner.get(), &amp;m_documentNodeToIdMap);
2154 
2155     Ref&lt;Inspector::Protocol::DOM::Node&gt; value = buildObjectForNode(frameOwner.get(), 0, &amp;m_documentNodeToIdMap);
2156     Node* previousSibling = innerPreviousSibling(frameOwner.get());
2157     int prevId = previousSibling ? m_documentNodeToIdMap.get(previousSibling) : 0;
2158     m_frontendDispatcher-&gt;childNodeInserted(parentId, prevId, WTFMove(value));
2159 }
2160 
2161 int InspectorDOMAgent::identifierForNode(Node&amp; node)
2162 {
2163     return pushNodePathToFrontend(&amp;node);
2164 }
2165 
2166 void InspectorDOMAgent::addEventListenersToNode(Node&amp; node)
2167 {
2168 #if ENABLE(VIDEO)
2169     auto callback = EventFiredCallback::create(*this);
2170 
<span class="line-modified">2171     auto createEventListener = [&amp;] (const AtomString&amp; eventName) {</span>
2172         node.addEventListener(eventName, callback.copyRef(), false);
2173     };
2174 
2175 #if ENABLE(FULLSCREEN_API)
2176     if (is&lt;Document&gt;(node) || is&lt;HTMLMediaElement&gt;(node))
2177         createEventListener(eventNames().webkitfullscreenchangeEvent);
2178 #endif // ENABLE(FULLSCREEN_API)
2179 
2180     if (is&lt;HTMLMediaElement&gt;(node)) {
2181         createEventListener(eventNames().abortEvent);
2182         createEventListener(eventNames().canplayEvent);
2183         createEventListener(eventNames().canplaythroughEvent);
2184         createEventListener(eventNames().emptiedEvent);
2185         createEventListener(eventNames().endedEvent);
2186         createEventListener(eventNames().loadeddataEvent);
2187         createEventListener(eventNames().loadedmetadataEvent);
2188         createEventListener(eventNames().loadstartEvent);
2189         createEventListener(eventNames().pauseEvent);
2190         createEventListener(eventNames().playEvent);
2191         createEventListener(eventNames().playingEvent);
</pre>
<hr />
<pre>
2237     if (containsOnlyHTMLWhitespace(&amp;node))
2238         return;
2239 
2240     ContainerNode* parent = node.parentNode();
2241 
2242     // If parent is not mapped yet -&gt; ignore the event.
2243     if (!m_documentNodeToIdMap.contains(parent))
2244         return;
2245 
2246     int parentId = m_documentNodeToIdMap.get(parent);
2247 
2248     if (!m_childrenRequested.contains(parentId)) {
2249         // No children are mapped yet -&gt; only notify on changes of hasChildren.
2250         if (innerChildNodeCount(parent) == 1)
2251             m_frontendDispatcher-&gt;childNodeCountUpdated(parentId, 0);
2252     } else
2253         m_frontendDispatcher-&gt;childNodeRemoved(parentId, m_documentNodeToIdMap.get(&amp;node));
2254     unbind(&amp;node, &amp;m_documentNodeToIdMap);
2255 }
2256 
<span class="line-modified">2257 void InspectorDOMAgent::willModifyDOMAttr(Element&amp;, const AtomString&amp; oldValue, const AtomString&amp; newValue)</span>
2258 {
2259     m_suppressAttributeModifiedEvent = (oldValue == newValue);
2260 }
2261 
<span class="line-modified">2262 void InspectorDOMAgent::didModifyDOMAttr(Element&amp; element, const AtomString&amp; name, const AtomString&amp; value)</span>
2263 {
2264     bool shouldSuppressEvent = m_suppressAttributeModifiedEvent;
2265     m_suppressAttributeModifiedEvent = false;
2266     if (shouldSuppressEvent)
2267         return;
2268 
2269     int id = boundNodeId(&amp;element);

2270     if (!id)
2271         return;
2272 
<span class="line-modified">2273     if (auto* cssAgent = m_instrumentingAgents.inspectorCSSAgent())</span>
<span class="line-modified">2274         cssAgent-&gt;didModifyDOMAttr(element);</span>
2275 
2276     m_frontendDispatcher-&gt;attributeModified(id, name, value);
2277 }
2278 
<span class="line-modified">2279 void InspectorDOMAgent::didRemoveDOMAttr(Element&amp; element, const AtomString&amp; name)</span>
2280 {
2281     int id = boundNodeId(&amp;element);

2282     if (!id)
2283         return;
2284 
<span class="line-modified">2285     if (auto* cssAgent = m_instrumentingAgents.inspectorCSSAgent())</span>
<span class="line-modified">2286         cssAgent-&gt;didModifyDOMAttr(element);</span>
2287 
2288     m_frontendDispatcher-&gt;attributeRemoved(id, name);
2289 }
2290 
2291 void InspectorDOMAgent::styleAttributeInvalidated(const Vector&lt;Element*&gt;&amp; elements)
2292 {
2293     auto nodeIds = JSON::ArrayOf&lt;int&gt;::create();
2294     for (auto&amp; element : elements) {
2295         int id = boundNodeId(element);

2296         if (!id)
2297             continue;
2298 
<span class="line-modified">2299         if (auto* cssAgent = m_instrumentingAgents.inspectorCSSAgent())</span>
<span class="line-modified">2300             cssAgent-&gt;didModifyDOMAttr(*element);</span>
<span class="line-added">2301 </span>
2302         nodeIds-&gt;addItem(id);
2303     }
2304     m_frontendDispatcher-&gt;inlineStyleInvalidated(WTFMove(nodeIds));
2305 }
2306 
2307 void InspectorDOMAgent::characterDataModified(CharacterData&amp; characterData)
2308 {
2309     int id = m_documentNodeToIdMap.get(&amp;characterData);
2310     if (!id) {
2311         // Push text node if it is being created.
2312         didInsertDOMNode(characterData);
2313         return;
2314     }
2315     m_frontendDispatcher-&gt;characterDataModified(id, characterData.data());
2316 }
2317 
<span class="line-modified">2318 void InspectorDOMAgent::didInvalidateStyleAttr(Element&amp; element)</span>
2319 {
<span class="line-modified">2320     int id = m_documentNodeToIdMap.get(&amp;element);</span>

2321     if (!id)
2322         return;
2323 
2324     if (!m_revalidateStyleAttrTask)
<span class="line-modified">2325         m_revalidateStyleAttrTask = makeUnique&lt;RevalidateStyleAttributeTask&gt;(this);</span>
<span class="line-modified">2326     m_revalidateStyleAttrTask-&gt;scheduleFor(&amp;element);</span>
2327 }
2328 
2329 void InspectorDOMAgent::didPushShadowRoot(Element&amp; host, ShadowRoot&amp; root)
2330 {
2331     int hostId = m_documentNodeToIdMap.get(&amp;host);
2332     if (hostId)
2333         m_frontendDispatcher-&gt;shadowRootPushed(hostId, buildObjectForNode(&amp;root, 0, &amp;m_documentNodeToIdMap));
2334 }
2335 
2336 void InspectorDOMAgent::willPopShadowRoot(Element&amp; host, ShadowRoot&amp; root)
2337 {
2338     int hostId = m_documentNodeToIdMap.get(&amp;host);
2339     int rootId = m_documentNodeToIdMap.get(&amp;root);
2340     if (hostId &amp;&amp; rootId)
2341         m_frontendDispatcher-&gt;shadowRootPopped(hostId, rootId);
2342 }
2343 
2344 void InspectorDOMAgent::didChangeCustomElementState(Element&amp; element)
2345 {
2346     int elementId = m_documentNodeToIdMap.get(&amp;element);
</pre>
<hr />
<pre>
2382 {
2383     int pseudoElementId = m_documentNodeToIdMap.get(&amp;pseudoElement);
2384     if (!pseudoElementId)
2385         return;
2386 
2387     // If a PseudoElement is bound, its parent element must have been bound.
2388     Element* parent = pseudoElement.hostElement();
2389     ASSERT(parent);
2390     int parentId = m_documentNodeToIdMap.get(parent);
2391     ASSERT(parentId);
2392 
2393     unbind(&amp;pseudoElement, &amp;m_documentNodeToIdMap);
2394     m_frontendDispatcher-&gt;pseudoElementRemoved(parentId, pseudoElementId);
2395 }
2396 
2397 void InspectorDOMAgent::didAddEventListener(EventTarget&amp; target)
2398 {
2399     if (!is&lt;Node&gt;(target))
2400         return;
2401 
<span class="line-modified">2402     auto&amp; node = downcast&lt;Node&gt;(target);</span>
<span class="line-added">2403     if (!node.contains(m_inspectedNode.get()))</span>
<span class="line-added">2404         return;</span>
<span class="line-added">2405 </span>
<span class="line-added">2406     int nodeId = boundNodeId(&amp;node);</span>
2407     if (!nodeId)
2408         return;
2409 
<span class="line-added">2410     if (m_suppressEventListenerChangedEvent)</span>
<span class="line-added">2411         return;</span>
<span class="line-added">2412 </span>
<span class="line-added">2413     m_suppressEventListenerChangedEvent = true;</span>
<span class="line-added">2414 </span>
2415     m_frontendDispatcher-&gt;didAddEventListener(nodeId);
2416 }
2417 
<span class="line-modified">2418 void InspectorDOMAgent::willRemoveEventListener(EventTarget&amp; target, const AtomString&amp; eventType, EventListener&amp; listener, bool capture)</span>
2419 {
2420     if (!is&lt;Node&gt;(target))
2421         return;
<span class="line-added">2422 </span>
2423     auto&amp; node = downcast&lt;Node&gt;(target);
<span class="line-added">2424     if (!node.contains(m_inspectedNode.get()))</span>
<span class="line-added">2425         return;</span>
2426 
2427     int nodeId = boundNodeId(&amp;node);
2428     if (!nodeId)
2429         return;
2430 
2431     bool listenerExists = false;
2432     for (auto&amp; item : node.eventListeners(eventType)) {
2433         if (item-&gt;callback() == listener &amp;&amp; item-&gt;useCapture() == capture) {
2434             listenerExists = true;
2435             break;
2436         }
2437     }
2438 
2439     if (!listenerExists)
2440         return;
2441 
2442     m_eventListenerEntries.removeIf([&amp;] (auto&amp; entry) {
2443         return entry.value.matches(target, eventType, listener, capture);
2444     });
2445 
<span class="line-added">2446     if (m_suppressEventListenerChangedEvent)</span>
<span class="line-added">2447         return;</span>
<span class="line-added">2448 </span>
<span class="line-added">2449     m_suppressEventListenerChangedEvent = true;</span>
<span class="line-added">2450 </span>
2451     m_frontendDispatcher-&gt;willRemoveEventListener(nodeId);
2452 }
2453 
<span class="line-modified">2454 bool InspectorDOMAgent::isEventListenerDisabled(EventTarget&amp; target, const AtomString&amp; eventType, EventListener&amp; listener, bool capture)</span>
2455 {
2456     for (auto&amp; inspectorEventListener : m_eventListenerEntries.values()) {
2457         if (inspectorEventListener.matches(target, eventType, listener, capture))
2458             return inspectorEventListener.disabled;
2459     }
2460     return false;
2461 }
2462 
2463 void InspectorDOMAgent::eventDidResetAfterDispatch(const Event&amp; event)
2464 {
2465     m_dispatchedEvents.remove(&amp;event);
2466 }
2467 
<span class="line-modified">2468 bool InspectorDOMAgent::hasBreakpointForEventListener(EventTarget&amp; target, const AtomString&amp; eventType, EventListener&amp; listener, bool capture)</span>
2469 {
2470     for (auto&amp; inspectorEventListener : m_eventListenerEntries.values()) {
2471         if (inspectorEventListener.matches(target, eventType, listener, capture))
2472             return inspectorEventListener.hasBreakpoint;
2473     }
2474     return false;
2475 }
2476 
<span class="line-modified">2477 int InspectorDOMAgent::idForEventListener(EventTarget&amp; target, const AtomString&amp; eventType, EventListener&amp; listener, bool capture)</span>
2478 {
2479     for (auto&amp; inspectorEventListener : m_eventListenerEntries.values()) {
2480         if (inspectorEventListener.matches(target, eventType, listener, capture))
2481             return inspectorEventListener.identifier;
2482     }
2483     return 0;
2484 }
2485 
2486 #if ENABLE(VIDEO)
2487 void InspectorDOMAgent::mediaMetricsTimerFired()
2488 {
2489     // FIXME: remove metrics information for any media element when it&#39;s destroyed
2490 
2491     if (HTMLMediaElement::allMediaElements().isEmpty()) {
2492         if (m_mediaMetricsTimer.isActive())
2493             m_mediaMetricsTimer.stop();
2494         m_mediaMetrics.clear();
2495         return;
2496     }
2497 
2498     for (auto* mediaElement : HTMLMediaElement::allMediaElements()) {
2499         if (!is&lt;HTMLVideoElement&gt;(mediaElement) || !mediaElement-&gt;isPlaying())
2500             continue;
2501 
2502         auto videoPlaybackQuality = mediaElement-&gt;getVideoPlaybackQuality();
2503         unsigned displayCompositedVideoFrames = videoPlaybackQuality-&gt;displayCompositedVideoFrames();
2504 
2505         auto iterator = m_mediaMetrics.find(mediaElement);
2506         if (iterator == m_mediaMetrics.end()) {
2507             m_mediaMetrics.set(mediaElement, MediaMetrics(displayCompositedVideoFrames));
2508             continue;
2509         }
2510 
<span class="line-modified">2511         bool isPowerEfficient = (displayCompositedVideoFrames - iterator-&gt;value.displayCompositedFrames) &gt; 0;</span>
<span class="line-modified">2512         if (iterator-&gt;value.isPowerEfficient != isPowerEfficient) {</span>
<span class="line-modified">2513             iterator-&gt;value.isPowerEfficient = isPowerEfficient;</span>
2514 
2515             int nodeId = pushNodePathToFrontend(mediaElement);
2516             if (nodeId) {
2517                 auto timestamp = m_environment.executionStopwatch()-&gt;elapsedTime().seconds();
<span class="line-modified">2518                 m_frontendDispatcher-&gt;powerEfficientPlaybackStateChanged(nodeId, timestamp, iterator-&gt;value.isPowerEfficient);</span>
2519             }
2520         }
2521 
2522         iterator-&gt;value.displayCompositedFrames = displayCompositedVideoFrames;
2523     }
2524 
2525     m_mediaMetrics.removeIf([&amp;] (auto&amp; entry) {
2526         return !HTMLMediaElement::allMediaElements().contains(entry.key);
2527     });
2528 }
2529 #endif
2530 
2531 Node* InspectorDOMAgent::nodeForPath(const String&amp; path)
2532 {
2533     // The path is of form &quot;1,HTML,2,BODY,1,DIV&quot;
2534     if (!m_document)
2535         return nullptr;
2536 
2537     Node* node = m_document.get();
2538     Vector&lt;String&gt; pathTokens = path.split(&#39;,&#39;);
</pre>
<hr />
<pre>
2564             return nullptr;
2565         node = child;
2566     }
2567     return node;
2568 }
2569 
2570 Node* InspectorDOMAgent::nodeForObjectId(const String&amp; objectId)
2571 {
2572     InjectedScript injectedScript = m_injectedScriptManager.injectedScriptForObjectId(objectId);
2573     if (injectedScript.hasNoValue())
2574         return nullptr;
2575 
2576     return scriptValueAsNode(injectedScript.findObjectById(objectId));
2577 }
2578 
2579 void InspectorDOMAgent::pushNodeByPathToFrontend(ErrorString&amp; errorString, const String&amp; path, int* nodeId)
2580 {
2581     if (Node* node = nodeForPath(path))
2582         *nodeId = pushNodePathToFrontend(node);
2583     else
<span class="line-modified">2584         errorString = &quot;Missing node for given path&quot;_s;</span>
2585 }
2586 
2587 RefPtr&lt;Inspector::Protocol::Runtime::RemoteObject&gt; InspectorDOMAgent::resolveNode(Node* node, const String&amp; objectGroup)
2588 {
<span class="line-modified">2589     Document* document = &amp;node-&gt;document();</span>
<span class="line-added">2590     if (auto* templateHost = document-&gt;templateDocumentHost())</span>
<span class="line-added">2591         document = templateHost;</span>
<span class="line-added">2592     auto* frame =  document-&gt;frame();</span>
2593     if (!frame)
2594         return nullptr;
2595 
2596     auto&amp; state = *mainWorldExecState(frame);
2597     auto injectedScript = m_injectedScriptManager.injectedScriptFor(&amp;state);
2598     if (injectedScript.hasNoValue())
2599         return nullptr;
2600 
2601     return injectedScript.wrapObject(nodeAsScriptValue(state, node), objectGroup);
2602 }
2603 
2604 Node* InspectorDOMAgent::scriptValueAsNode(JSC::JSValue value)
2605 {
2606     if (!value || !value.isObject())
2607         return nullptr;
<span class="line-modified">2608     return JSNode::toWrapped(value.getObject()-&gt;vm(), value.getObject());</span>
2609 }
2610 
2611 JSC::JSValue InspectorDOMAgent::nodeAsScriptValue(JSC::ExecState&amp; state, Node* node)
2612 {
2613     JSC::JSLockHolder lock(&amp;state);
2614     return toJS(&amp;state, deprecatedGlobalObjectForPrototype(&amp;state), BindingSecurity::checkSecurityForNode(state, node));
2615 }
2616 
2617 } // namespace WebCore
</pre>
</td>
</tr>
</table>
<center><a href="InspectorCanvasAgent.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="InspectorDOMAgent.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>