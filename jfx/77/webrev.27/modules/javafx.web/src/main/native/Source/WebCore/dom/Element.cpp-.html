<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.web/src/main/native/Source/WebCore/dom/Element.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (C) 1999 Lars Knoll (knoll@kde.org)
   3  *           (C) 1999 Antti Koivisto (koivisto@kde.org)
   4  *           (C) 2001 Peter Kelly (pmk@post.com)
   5  *           (C) 2001 Dirk Mueller (mueller@kde.org)
   6  *           (C) 2007 David Smith (catfish.man@gmail.com)
   7  * Copyright (C) 2004-2017 Apple Inc. All rights reserved.
   8  *           (C) 2007 Eric Seidel (eric@webkit.org)
   9  *
  10  * This library is free software; you can redistribute it and/or
  11  * modify it under the terms of the GNU Library General Public
  12  * License as published by the Free Software Foundation; either
  13  * version 2 of the License, or (at your option) any later version.
  14  *
  15  * This library is distributed in the hope that it will be useful,
  16  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  17  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  18  * Library General Public License for more details.
  19  *
  20  * You should have received a copy of the GNU Library General Public License
  21  * along with this library; see the file COPYING.LIB.  If not, write to
  22  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  23  * Boston, MA 02110-1301, USA.
  24  */
  25 
  26 #include &quot;config.h&quot;
  27 #include &quot;Element.h&quot;
  28 
  29 #include &quot;AXObjectCache.h&quot;
  30 #include &quot;Attr.h&quot;
  31 #include &quot;AttributeChangeInvalidation.h&quot;
  32 #include &quot;CSSAnimationController.h&quot;
  33 #include &quot;CSSParser.h&quot;
  34 #include &quot;Chrome.h&quot;
  35 #include &quot;ChromeClient.h&quot;
  36 #include &quot;ClassChangeInvalidation.h&quot;
  37 #include &quot;ComposedTreeAncestorIterator.h&quot;
  38 #include &quot;ContainerNodeAlgorithms.h&quot;
  39 #include &quot;CustomElementReactionQueue.h&quot;
  40 #include &quot;CustomElementRegistry.h&quot;
  41 #include &quot;DOMRect.h&quot;
  42 #include &quot;DOMRectList.h&quot;
  43 #include &quot;DOMTokenList.h&quot;
  44 #include &quot;DOMWindow.h&quot;
  45 #include &quot;DocumentSharedObjectPool.h&quot;
  46 #include &quot;DocumentTimeline.h&quot;
  47 #include &quot;Editing.h&quot;
  48 #include &quot;ElementIterator.h&quot;
  49 #include &quot;ElementRareData.h&quot;
  50 #include &quot;EventDispatcher.h&quot;
  51 #include &quot;EventHandler.h&quot;
  52 #include &quot;EventNames.h&quot;
  53 #include &quot;FocusController.h&quot;
  54 #include &quot;FocusEvent.h&quot;
  55 #include &quot;Frame.h&quot;
  56 #include &quot;FrameSelection.h&quot;
  57 #include &quot;FrameView.h&quot;
  58 #include &quot;HTMLBodyElement.h&quot;
  59 #include &quot;HTMLCanvasElement.h&quot;
  60 #include &quot;HTMLCollection.h&quot;
  61 #include &quot;HTMLDocument.h&quot;
  62 #include &quot;HTMLHtmlElement.h&quot;
  63 #include &quot;HTMLLabelElement.h&quot;
  64 #include &quot;HTMLNameCollection.h&quot;
  65 #include &quot;HTMLObjectElement.h&quot;
  66 #include &quot;HTMLOptGroupElement.h&quot;
  67 #include &quot;HTMLOptionElement.h&quot;
  68 #include &quot;HTMLParserIdioms.h&quot;
  69 #include &quot;HTMLSelectElement.h&quot;
  70 #include &quot;HTMLTemplateElement.h&quot;
  71 #include &quot;IdChangeInvalidation.h&quot;
  72 #include &quot;IdTargetObserverRegistry.h&quot;
  73 #include &quot;InspectorInstrumentation.h&quot;
  74 #include &quot;JSLazyEventListener.h&quot;
  75 #include &quot;KeyboardEvent.h&quot;
  76 #include &quot;KeyframeEffect.h&quot;
  77 #include &quot;MutationObserverInterestGroup.h&quot;
  78 #include &quot;MutationRecord.h&quot;
  79 #include &quot;NodeRenderStyle.h&quot;
  80 #include &quot;PlatformWheelEvent.h&quot;
  81 #include &quot;PointerCaptureController.h&quot;
  82 #include &quot;PointerLockController.h&quot;
  83 #include &quot;RenderFragmentContainer.h&quot;
  84 #include &quot;RenderLayer.h&quot;
  85 #include &quot;RenderLayerBacking.h&quot;
  86 #include &quot;RenderLayerCompositor.h&quot;
  87 #include &quot;RenderListBox.h&quot;
  88 #include &quot;RenderTheme.h&quot;
  89 #include &quot;RenderTreeUpdater.h&quot;
  90 #include &quot;RenderView.h&quot;
  91 #include &quot;RenderWidget.h&quot;
  92 #include &quot;RuntimeEnabledFeatures.h&quot;
  93 #include &quot;SVGDocumentExtensions.h&quot;
  94 #include &quot;SVGElement.h&quot;
  95 #include &quot;SVGNames.h&quot;
  96 #include &quot;SVGSVGElement.h&quot;
  97 #include &quot;ScriptDisallowedScope.h&quot;
  98 #include &quot;ScrollIntoViewOptions.h&quot;
  99 #include &quot;ScrollLatchingState.h&quot;
 100 #include &quot;SelectorQuery.h&quot;
 101 #include &quot;Settings.h&quot;
 102 #include &quot;SimulatedClick.h&quot;
 103 #include &quot;SlotAssignment.h&quot;
 104 #include &quot;StyleProperties.h&quot;
 105 #include &quot;StyleResolver.h&quot;
 106 #include &quot;StyleScope.h&quot;
 107 #include &quot;StyleTreeResolver.h&quot;
 108 #include &quot;TextIterator.h&quot;
 109 #include &quot;TouchAction.h&quot;
 110 #include &quot;VoidCallback.h&quot;
 111 #include &quot;WebAnimation.h&quot;
 112 #include &quot;WheelEvent.h&quot;
 113 #include &quot;XLinkNames.h&quot;
 114 #include &quot;XMLNSNames.h&quot;
 115 #include &quot;XMLNames.h&quot;
 116 #include &quot;markup.h&quot;
 117 #include &lt;wtf/IsoMallocInlines.h&gt;
 118 #include &lt;wtf/NeverDestroyed.h&gt;
 119 #include &lt;wtf/text/CString.h&gt;
 120 
 121 namespace WebCore {
 122 
 123 WTF_MAKE_ISO_ALLOCATED_IMPL(Element);
 124 
 125 using namespace HTMLNames;
 126 using namespace XMLNames;
 127 
 128 static HashMap&lt;Element*, Vector&lt;RefPtr&lt;Attr&gt;&gt;&gt;&amp; attrNodeListMap()
 129 {
 130     static NeverDestroyed&lt;HashMap&lt;Element*, Vector&lt;RefPtr&lt;Attr&gt;&gt;&gt;&gt; map;
 131     return map;
 132 }
 133 
 134 static Vector&lt;RefPtr&lt;Attr&gt;&gt;* attrNodeListForElement(Element&amp; element)
 135 {
 136     if (!element.hasSyntheticAttrChildNodes())
 137         return nullptr;
 138     ASSERT(attrNodeListMap().contains(&amp;element));
 139     return &amp;attrNodeListMap().find(&amp;element)-&gt;value;
 140 }
 141 
 142 static Vector&lt;RefPtr&lt;Attr&gt;&gt;&amp; ensureAttrNodeListForElement(Element&amp; element)
 143 {
 144     if (element.hasSyntheticAttrChildNodes()) {
 145         ASSERT(attrNodeListMap().contains(&amp;element));
 146         return attrNodeListMap().find(&amp;element)-&gt;value;
 147     }
 148     ASSERT(!attrNodeListMap().contains(&amp;element));
 149     element.setHasSyntheticAttrChildNodes(true);
 150     return attrNodeListMap().add(&amp;element, Vector&lt;RefPtr&lt;Attr&gt;&gt;()).iterator-&gt;value;
 151 }
 152 
 153 static void removeAttrNodeListForElement(Element&amp; element)
 154 {
 155     ASSERT(element.hasSyntheticAttrChildNodes());
 156     ASSERT(attrNodeListMap().contains(&amp;element));
 157     attrNodeListMap().remove(&amp;element);
 158     element.setHasSyntheticAttrChildNodes(false);
 159 }
 160 
 161 static Attr* findAttrNodeInList(Vector&lt;RefPtr&lt;Attr&gt;&gt;&amp; attrNodeList, const QualifiedName&amp; name)
 162 {
 163     for (auto&amp; node : attrNodeList) {
 164         if (node-&gt;qualifiedName().matches(name))
 165             return node.get();
 166     }
 167     return nullptr;
 168 }
 169 
 170 static Attr* findAttrNodeInList(Vector&lt;RefPtr&lt;Attr&gt;&gt;&amp; attrNodeList, const AtomicString&amp; localName, bool shouldIgnoreAttributeCase)
 171 {
 172     const AtomicString&amp; caseAdjustedName = shouldIgnoreAttributeCase ? localName.convertToASCIILowercase() : localName;
 173     for (auto&amp; node : attrNodeList) {
 174         if (node-&gt;qualifiedName().localName() == caseAdjustedName)
 175             return node.get();
 176     }
 177     return nullptr;
 178 }
 179 
 180 Ref&lt;Element&gt; Element::create(const QualifiedName&amp; tagName, Document&amp; document)
 181 {
 182     return adoptRef(*new Element(tagName, document, CreateElement));
 183 }
 184 
 185 Element::Element(const QualifiedName&amp; tagName, Document&amp; document, ConstructionType type)
 186     : ContainerNode(document, type)
 187     , m_tagName(tagName)
 188 {
 189 }
 190 
 191 Element::~Element()
 192 {
 193     ASSERT(!beforePseudoElement());
 194     ASSERT(!afterPseudoElement());
 195 
 196 #if ENABLE(INTERSECTION_OBSERVER)
 197     disconnectFromIntersectionObservers();
 198 #endif
 199 
 200     removeShadowRoot();
 201 
 202     if (hasSyntheticAttrChildNodes())
 203         detachAllAttrNodesFromElement();
 204 
 205     if (hasPendingResources()) {
 206         document().accessSVGExtensions().removeElementFromPendingResources(*this);
 207         ASSERT(!hasPendingResources());
 208     }
 209 }
 210 
 211 inline ElementRareData* Element::elementRareData() const
 212 {
 213     ASSERT_WITH_SECURITY_IMPLICATION(hasRareData());
 214     return static_cast&lt;ElementRareData*&gt;(rareData());
 215 }
 216 
 217 inline ElementRareData&amp; Element::ensureElementRareData()
 218 {
 219     return static_cast&lt;ElementRareData&amp;&gt;(ensureRareData());
 220 }
 221 
 222 void Element::clearTabIndexExplicitlyIfNeeded()
 223 {
 224     if (hasRareData())
 225         elementRareData()-&gt;clearTabIndexExplicitly();
 226 }
 227 
 228 void Element::setTabIndexExplicitly(int tabIndex)
 229 {
 230     ensureElementRareData().setTabIndexExplicitly(tabIndex);
 231 }
 232 
 233 bool Element::tabIndexSetExplicitly() const
 234 {
 235     return hasRareData() &amp;&amp; elementRareData()-&gt;tabIndexSetExplicitly();
 236 }
 237 
 238 bool Element::supportsFocus() const
 239 {
 240     return tabIndexSetExplicitly();
 241 }
 242 
 243 RefPtr&lt;Element&gt; Element::focusDelegate()
 244 {
 245     return this;
 246 }
 247 
 248 int Element::tabIndex() const
 249 {
 250     return hasRareData() ? elementRareData()-&gt;tabIndex() : 0;
 251 }
 252 
 253 void Element::setTabIndex(int value)
 254 {
 255     setIntegralAttribute(tabindexAttr, value);
 256 }
 257 
 258 bool Element::isKeyboardFocusable(KeyboardEvent*) const
 259 {
 260     return isFocusable() &amp;&amp; tabIndex() &gt;= 0;
 261 }
 262 
 263 bool Element::isMouseFocusable() const
 264 {
 265     return isFocusable();
 266 }
 267 
 268 bool Element::shouldUseInputMethod()
 269 {
 270     return computeEditability(UserSelectAllIsAlwaysNonEditable, ShouldUpdateStyle::Update) != Editability::ReadOnly;
 271 }
 272 
 273 static bool isForceEvent(const PlatformMouseEvent&amp; platformEvent)
 274 {
 275     return platformEvent.type() == PlatformEvent::MouseForceChanged || platformEvent.type() == PlatformEvent::MouseForceDown || platformEvent.type() == PlatformEvent::MouseForceUp;
 276 }
 277 
 278 bool Element::dispatchMouseEvent(const PlatformMouseEvent&amp; platformEvent, const AtomicString&amp; eventType, int detail, Element* relatedTarget)
 279 {
 280     if (isDisabledFormControl())
 281         return false;
 282 
 283     if (isForceEvent(platformEvent) &amp;&amp; !document().hasListenerTypeForEventType(platformEvent.type()))
 284         return false;
 285 
 286     Ref&lt;MouseEvent&gt; mouseEvent = MouseEvent::create(eventType, document().windowProxy(), platformEvent, detail, relatedTarget);
 287 
 288     if (mouseEvent-&gt;type().isEmpty())
 289         return true; // Shouldn&#39;t happen.
 290 
 291     ASSERT(!mouseEvent-&gt;target() || mouseEvent-&gt;target() != relatedTarget);
 292     dispatchEvent(mouseEvent);
 293     bool didNotSwallowEvent = !mouseEvent-&gt;defaultPrevented() &amp;&amp; !mouseEvent-&gt;defaultHandled();
 294 
 295     if (mouseEvent-&gt;type() == eventNames().clickEvent &amp;&amp; mouseEvent-&gt;detail() == 2) {
 296         // Special case: If it&#39;s a double click event, we also send the dblclick event. This is not part
 297         // of the DOM specs, but is used for compatibility with the ondblclick=&quot;&quot; attribute. This is treated
 298         // as a separate event in other DOM-compliant browsers like Firefox, and so we do the same.
 299         // FIXME: Is it okay that mouseEvent may have been mutated by scripts via initMouseEvent in dispatchEvent above?
 300         Ref&lt;MouseEvent&gt; doubleClickEvent = MouseEvent::create(eventNames().dblclickEvent,
 301             mouseEvent-&gt;bubbles() ? Event::CanBubble::Yes : Event::CanBubble::No,
 302             mouseEvent-&gt;cancelable() ? Event::IsCancelable::Yes : Event::IsCancelable::No,
 303             Event::IsComposed::Yes,
 304             mouseEvent-&gt;view(), mouseEvent-&gt;detail(),
 305             mouseEvent-&gt;screenX(), mouseEvent-&gt;screenY(), mouseEvent-&gt;clientX(), mouseEvent-&gt;clientY(),
 306             mouseEvent-&gt;modifierKeys(), mouseEvent-&gt;button(), mouseEvent-&gt;buttons(), mouseEvent-&gt;syntheticClickType(), relatedTarget);
 307 
 308         if (mouseEvent-&gt;defaultHandled())
 309             doubleClickEvent-&gt;setDefaultHandled();
 310 
 311         dispatchEvent(doubleClickEvent);
 312         if (doubleClickEvent-&gt;defaultHandled() || doubleClickEvent-&gt;defaultPrevented())
 313             return false;
 314     }
 315     return didNotSwallowEvent;
 316 }
 317 
 318 bool Element::dispatchWheelEvent(const PlatformWheelEvent&amp; platformEvent)
 319 {
 320     auto event = WheelEvent::create(platformEvent, document().windowProxy());
 321 
 322     // Events with no deltas are important because they convey platform information about scroll gestures
 323     // and momentum beginning or ending. However, those events should not be sent to the DOM since some
 324     // websites will break. They need to be dispatched because dispatching them will call into the default
 325     // event handler, and our platform code will correctly handle the phase changes. Calling stopPropogation()
 326     // will prevent the event from being sent to the DOM, but will still call the default event handler.
 327     // FIXME: Move this logic into WheelEvent::create.
 328     if (!platformEvent.deltaX() &amp;&amp; !platformEvent.deltaY())
 329         event-&gt;stopPropagation();
 330 
 331     dispatchEvent(event);
 332     return !event-&gt;defaultPrevented() &amp;&amp; !event-&gt;defaultHandled();
 333 }
 334 
 335 bool Element::dispatchKeyEvent(const PlatformKeyboardEvent&amp; platformEvent)
 336 {
 337     auto event = KeyboardEvent::create(platformEvent, document().windowProxy());
 338 
 339     if (Frame* frame = document().frame()) {
 340         if (frame-&gt;eventHandler().accessibilityPreventsEventPropagation(event))
 341             event-&gt;stopPropagation();
 342     }
 343 
 344     dispatchEvent(event);
 345     return !event-&gt;defaultPrevented() &amp;&amp; !event-&gt;defaultHandled();
 346 }
 347 
 348 void Element::dispatchSimulatedClick(Event* underlyingEvent, SimulatedClickMouseEventOptions eventOptions, SimulatedClickVisualOptions visualOptions)
 349 {
 350     simulateClick(*this, underlyingEvent, eventOptions, visualOptions, SimulatedClickSource::UserAgent);
 351 }
 352 
 353 Ref&lt;Node&gt; Element::cloneNodeInternal(Document&amp; targetDocument, CloningOperation type)
 354 {
 355     switch (type) {
 356     case CloningOperation::OnlySelf:
 357     case CloningOperation::SelfWithTemplateContent:
 358         return cloneElementWithoutChildren(targetDocument);
 359     case CloningOperation::Everything:
 360         break;
 361     }
 362     return cloneElementWithChildren(targetDocument);
 363 }
 364 
 365 Ref&lt;Element&gt; Element::cloneElementWithChildren(Document&amp; targetDocument)
 366 {
 367     Ref&lt;Element&gt; clone = cloneElementWithoutChildren(targetDocument);
 368     cloneChildNodes(clone);
 369     return clone;
 370 }
 371 
 372 Ref&lt;Element&gt; Element::cloneElementWithoutChildren(Document&amp; targetDocument)
 373 {
 374     Ref&lt;Element&gt; clone = cloneElementWithoutAttributesAndChildren(targetDocument);
 375 
 376     // This will catch HTML elements in the wrong namespace that are not correctly copied.
 377     // This is a sanity check as HTML overloads some of the DOM methods.
 378     ASSERT(isHTMLElement() == clone-&gt;isHTMLElement());
 379 
 380     clone-&gt;cloneDataFromElement(*this);
 381     return clone;
 382 }
 383 
 384 Ref&lt;Element&gt; Element::cloneElementWithoutAttributesAndChildren(Document&amp; targetDocument)
 385 {
 386     return targetDocument.createElement(tagQName(), false);
 387 }
 388 
 389 Ref&lt;Attr&gt; Element::detachAttribute(unsigned index)
 390 {
 391     ASSERT(elementData());
 392 
 393     const Attribute&amp; attribute = elementData()-&gt;attributeAt(index);
 394 
 395     RefPtr&lt;Attr&gt; attrNode = attrIfExists(attribute.name());
 396     if (attrNode)
 397         detachAttrNodeFromElementWithValue(attrNode.get(), attribute.value());
 398     else
 399         attrNode = Attr::create(document(), attribute.name(), attribute.value());
 400 
 401     removeAttributeInternal(index, NotInSynchronizationOfLazyAttribute);
 402     return attrNode.releaseNonNull();
 403 }
 404 
 405 bool Element::removeAttribute(const QualifiedName&amp; name)
 406 {
 407     if (!elementData())
 408         return false;
 409 
 410     unsigned index = elementData()-&gt;findAttributeIndexByName(name);
 411     if (index == ElementData::attributeNotFound)
 412         return false;
 413 
 414     removeAttributeInternal(index, NotInSynchronizationOfLazyAttribute);
 415     return true;
 416 }
 417 
 418 void Element::setBooleanAttribute(const QualifiedName&amp; name, bool value)
 419 {
 420     if (value)
 421         setAttribute(name, emptyAtom());
 422     else
 423         removeAttribute(name);
 424 }
 425 
 426 NamedNodeMap&amp; Element::attributes() const
 427 {
 428     ElementRareData&amp; rareData = const_cast&lt;Element*&gt;(this)-&gt;ensureElementRareData();
 429     if (NamedNodeMap* attributeMap = rareData.attributeMap())
 430         return *attributeMap;
 431 
 432     rareData.setAttributeMap(std::make_unique&lt;NamedNodeMap&gt;(const_cast&lt;Element&amp;&gt;(*this)));
 433     return *rareData.attributeMap();
 434 }
 435 
 436 Node::NodeType Element::nodeType() const
 437 {
 438     return ELEMENT_NODE;
 439 }
 440 
 441 bool Element::hasAttribute(const QualifiedName&amp; name) const
 442 {
 443     return hasAttributeNS(name.namespaceURI(), name.localName());
 444 }
 445 
 446 void Element::synchronizeAllAttributes() const
 447 {
 448     if (!elementData())
 449         return;
 450     if (elementData()-&gt;styleAttributeIsDirty()) {
 451         ASSERT(isStyledElement());
 452         static_cast&lt;const StyledElement*&gt;(this)-&gt;synchronizeStyleAttributeInternal();
 453     }
 454 
 455     if (elementData()-&gt;animatedSVGAttributesAreDirty()) {
 456         ASSERT(isSVGElement());
 457         downcast&lt;SVGElement&gt;(*this).synchronizeAnimatedSVGAttribute(anyQName());
 458     }
 459 }
 460 
 461 ALWAYS_INLINE void Element::synchronizeAttribute(const QualifiedName&amp; name) const
 462 {
 463     if (!elementData())
 464         return;
 465     if (UNLIKELY(name == styleAttr &amp;&amp; elementData()-&gt;styleAttributeIsDirty())) {
 466         ASSERT_WITH_SECURITY_IMPLICATION(isStyledElement());
 467         static_cast&lt;const StyledElement*&gt;(this)-&gt;synchronizeStyleAttributeInternal();
 468         return;
 469     }
 470 
 471     if (UNLIKELY(elementData()-&gt;animatedSVGAttributesAreDirty())) {
 472         ASSERT(isSVGElement());
 473         downcast&lt;SVGElement&gt;(*this).synchronizeAnimatedSVGAttribute(name);
 474     }
 475 }
 476 
 477 static ALWAYS_INLINE bool isStyleAttribute(const Element&amp; element, const AtomicString&amp; attributeLocalName)
 478 {
 479     if (shouldIgnoreAttributeCase(element))
 480         return equalLettersIgnoringASCIICase(attributeLocalName, &quot;style&quot;);
 481     return attributeLocalName == styleAttr-&gt;localName();
 482 }
 483 
 484 ALWAYS_INLINE void Element::synchronizeAttribute(const AtomicString&amp; localName) const
 485 {
 486     // This version of synchronizeAttribute() is streamlined for the case where you don&#39;t have a full QualifiedName,
 487     // e.g when called from DOM API.
 488     if (!elementData())
 489         return;
 490     if (elementData()-&gt;styleAttributeIsDirty() &amp;&amp; isStyleAttribute(*this, localName)) {
 491         ASSERT_WITH_SECURITY_IMPLICATION(isStyledElement());
 492         static_cast&lt;const StyledElement*&gt;(this)-&gt;synchronizeStyleAttributeInternal();
 493         return;
 494     }
 495     if (elementData()-&gt;animatedSVGAttributesAreDirty()) {
 496         // We&#39;re not passing a namespace argument on purpose. SVGNames::*Attr are defined w/o namespaces as well.
 497         ASSERT_WITH_SECURITY_IMPLICATION(isSVGElement());
 498         downcast&lt;SVGElement&gt;(*this).synchronizeAnimatedSVGAttribute(QualifiedName(nullAtom(), localName, nullAtom()));
 499     }
 500 }
 501 
 502 const AtomicString&amp; Element::getAttribute(const QualifiedName&amp; name) const
 503 {
 504     if (!elementData())
 505         return nullAtom();
 506     synchronizeAttribute(name);
 507     if (const Attribute* attribute = findAttributeByName(name))
 508         return attribute-&gt;value();
 509     return nullAtom();
 510 }
 511 
 512 Vector&lt;String&gt; Element::getAttributeNames() const
 513 {
 514     Vector&lt;String&gt; attributesVector;
 515     if (!hasAttributes())
 516         return attributesVector;
 517 
 518     auto attributes = attributesIterator();
 519     attributesVector.reserveInitialCapacity(attributes.attributeCount());
 520     for (auto&amp; attribute : attributes)
 521         attributesVector.uncheckedAppend(attribute.name().toString());
 522     return attributesVector;
 523 }
 524 
 525 bool Element::isFocusable() const
 526 {
 527     if (!isConnected() || !supportsFocus())
 528         return false;
 529 
 530     if (!renderer()) {
 531         // If the node is in a display:none tree it might say it needs style recalc but
 532         // the whole document is actually up to date.
 533         ASSERT(!needsStyleRecalc() || !document().childNeedsStyleRecalc());
 534 
 535         // Elements in canvas fallback content are not rendered, but they are allowed to be
 536         // focusable as long as their canvas is displayed and visible.
 537         if (auto* canvas = ancestorsOfType&lt;HTMLCanvasElement&gt;(*this).first())
 538             return canvas-&gt;renderer() &amp;&amp; canvas-&gt;renderer()-&gt;style().visibility() == Visibility::Visible;
 539     }
 540 
 541     // FIXME: Even if we are not visible, we might have a child that is visible.
 542     // Hyatt wants to fix that some day with a &quot;has visible content&quot; flag or the like.
 543     if (!renderer() || renderer()-&gt;style().visibility() != Visibility::Visible)
 544         return false;
 545 
 546     return true;
 547 }
 548 
 549 bool Element::isUserActionElementInActiveChain() const
 550 {
 551     ASSERT(isUserActionElement());
 552     return document().userActionElements().isInActiveChain(*this);
 553 }
 554 
 555 bool Element::isUserActionElementActive() const
 556 {
 557     ASSERT(isUserActionElement());
 558     return document().userActionElements().isActive(*this);
 559 }
 560 
 561 bool Element::isUserActionElementFocused() const
 562 {
 563     ASSERT(isUserActionElement());
 564     return document().userActionElements().isFocused(*this);
 565 }
 566 
 567 bool Element::isUserActionElementHovered() const
 568 {
 569     ASSERT(isUserActionElement());
 570     return document().userActionElements().isHovered(*this);
 571 }
 572 
 573 void Element::setActive(bool flag, bool pause)
 574 {
 575     if (flag == active())
 576         return;
 577 
 578     document().userActionElements().setActive(*this, flag);
 579 
 580     auto* renderStyle = renderOrDisplayContentsStyle();
 581     bool reactsToPress = (renderStyle &amp;&amp; renderStyle-&gt;affectedByActive()) || styleAffectedByActive();
 582     if (reactsToPress)
 583         invalidateStyleForSubtree();
 584 
 585     if (!renderer())
 586         return;
 587 
 588     if (renderer()-&gt;style().hasAppearance() &amp;&amp; renderer()-&gt;theme().stateChanged(*renderer(), ControlStates::PressedState))
 589         reactsToPress = true;
 590 
 591     // The rest of this function implements a feature that only works if the
 592     // platform supports immediate invalidations on the ChromeClient, so bail if
 593     // that isn&#39;t supported.
 594     if (!document().page()-&gt;chrome().client().supportsImmediateInvalidation())
 595         return;
 596 
 597     if (reactsToPress &amp;&amp; pause) {
 598         // The delay here is subtle. It relies on an assumption, namely that the amount of time it takes
 599         // to repaint the &quot;down&quot; state of the control is about the same time as it would take to repaint the
 600         // &quot;up&quot; state. Once you assume this, you can just delay for 100ms - that time (assuming that after you
 601         // leave this method, it will be about that long before the flush of the up state happens again).
 602 #ifdef HAVE_FUNC_USLEEP
 603         MonotonicTime startTime = MonotonicTime::now();
 604 #endif
 605 
 606         document().updateStyleIfNeeded();
 607 
 608         // Do an immediate repaint.
 609         if (renderer())
 610             renderer()-&gt;repaint();
 611 
 612         // FIXME: Come up with a less ridiculous way of doing this.
 613 #ifdef HAVE_FUNC_USLEEP
 614         // Now pause for a small amount of time (1/10th of a second from before we repainted in the pressed state)
 615         Seconds remainingTime = 100_ms - (MonotonicTime::now() - startTime);
 616         if (remainingTime &gt; 0_s)
 617             usleep(static_cast&lt;useconds_t&gt;(remainingTime.microseconds()));
 618 #endif
 619     }
 620 }
 621 
 622 void Element::setFocus(bool flag)
 623 {
 624     if (flag == focused())
 625         return;
 626 
 627     document().userActionElements().setFocused(*this, flag);
 628     invalidateStyleForSubtree();
 629 
 630     for (Element* element = this; element; element = element-&gt;parentElementInComposedTree())
 631         element-&gt;setHasFocusWithin(flag);
 632 }
 633 
 634 void Element::setHovered(bool flag)
 635 {
 636     if (flag == hovered())
 637         return;
 638 
 639     document().userActionElements().setHovered(*this, flag);
 640 
 641     auto* style = renderOrDisplayContentsStyle();
 642     if (style &amp;&amp; (style-&gt;affectedByHover() || childrenAffectedByHover()))
 643         invalidateStyleForSubtree();
 644 
 645     if (!renderer()) {
 646         // When setting hover to false, the style needs to be recalc&#39;d even when
 647         // there&#39;s no renderer (imagine setting display:none in the :hover class,
 648         // if a nil renderer would prevent this element from recalculating its
 649         // style, it would never go back to its normal style and remain
 650         // stuck in its hovered style).
 651         if (!flag &amp;&amp; !style)
 652             invalidateStyleForSubtree();
 653 
 654         return;
 655     }
 656 
 657     if (style-&gt;hasAppearance())
 658         renderer()-&gt;theme().stateChanged(*renderer(), ControlStates::HoverState);
 659 }
 660 
 661 // FIXME(webkit.org/b/161611): Take into account orientation/direction.
 662 inline ScrollAlignment toScrollAlignment(Optional&lt;ScrollLogicalPosition&gt; position, bool isVertical)
 663 {
 664     switch (position.valueOr(isVertical ? ScrollLogicalPosition::Start : ScrollLogicalPosition::Nearest)) {
 665     case ScrollLogicalPosition::Start:
 666         return isVertical ? ScrollAlignment::alignTopAlways : ScrollAlignment::alignLeftAlways;
 667     case ScrollLogicalPosition::Center:
 668         return ScrollAlignment::alignCenterAlways;
 669     case ScrollLogicalPosition::End:
 670         return isVertical ? ScrollAlignment::alignBottomAlways : ScrollAlignment::alignRightAlways;
 671     case ScrollLogicalPosition::Nearest:
 672         return ScrollAlignment::alignToEdgeIfNeeded;
 673     default:
 674         ASSERT_NOT_REACHED();
 675         return ScrollAlignment::alignToEdgeIfNeeded;
 676     }
 677 }
 678 
 679 void Element::scrollIntoView(Optional&lt;Variant&lt;bool, ScrollIntoViewOptions&gt;&gt;&amp;&amp; arg)
 680 {
 681     document().updateLayoutIgnorePendingStylesheets();
 682 
 683     if (!renderer())
 684         return;
 685 
 686     bool insideFixed;
 687     LayoutRect absoluteBounds = renderer()-&gt;absoluteAnchorRect(&amp;insideFixed);
 688 
 689     // FIXME(webkit.org/b/188043): Support ScrollBehavior.
 690     ScrollIntoViewOptions options;
 691     if (arg) {
 692         auto value = arg.value();
 693         if (WTF::holds_alternative&lt;ScrollIntoViewOptions&gt;(value))
 694             options = WTF::get&lt;ScrollIntoViewOptions&gt;(value);
 695         else if (!WTF::get&lt;bool&gt;(value))
 696             options.blockPosition = ScrollLogicalPosition::End;
 697     }
 698 
 699     ScrollAlignment alignX = toScrollAlignment(options.inlinePosition, false);
 700     ScrollAlignment alignY = toScrollAlignment(options.blockPosition, true);
 701     renderer()-&gt;scrollRectToVisible(absoluteBounds, insideFixed, { SelectionRevealMode::Reveal, alignX, alignY, ShouldAllowCrossOriginScrolling::No });
 702 }
 703 
 704 void Element::scrollIntoView(bool alignToTop)
 705 {
 706     document().updateLayoutIgnorePendingStylesheets();
 707 
 708     if (!renderer())
 709         return;
 710 
 711     bool insideFixed;
 712     LayoutRect absoluteBounds = renderer()-&gt;absoluteAnchorRect(&amp;insideFixed);
 713     // Align to the top / bottom and to the closest edge.
 714     if (alignToTop)
 715         renderer()-&gt;scrollRectToVisible(absoluteBounds, insideFixed, { SelectionRevealMode::Reveal, ScrollAlignment::alignToEdgeIfNeeded, ScrollAlignment::alignTopAlways, ShouldAllowCrossOriginScrolling::No });
 716     else
 717         renderer()-&gt;scrollRectToVisible(absoluteBounds, insideFixed, { SelectionRevealMode::Reveal, ScrollAlignment::alignToEdgeIfNeeded, ScrollAlignment::alignBottomAlways, ShouldAllowCrossOriginScrolling::No });
 718 }
 719 
 720 void Element::scrollIntoViewIfNeeded(bool centerIfNeeded)
 721 {
 722     document().updateLayoutIgnorePendingStylesheets();
 723 
 724     if (!renderer())
 725         return;
 726 
 727     bool insideFixed;
 728     LayoutRect absoluteBounds = renderer()-&gt;absoluteAnchorRect(&amp;insideFixed);
 729     if (centerIfNeeded)
 730         renderer()-&gt;scrollRectToVisible(absoluteBounds, insideFixed, { SelectionRevealMode::Reveal, ScrollAlignment::alignCenterIfNeeded, ScrollAlignment::alignCenterIfNeeded, ShouldAllowCrossOriginScrolling::No });
 731     else
 732         renderer()-&gt;scrollRectToVisible(absoluteBounds, insideFixed, { SelectionRevealMode::Reveal, ScrollAlignment::alignToEdgeIfNeeded, ScrollAlignment::alignToEdgeIfNeeded, ShouldAllowCrossOriginScrolling::No });
 733 }
 734 
 735 void Element::scrollIntoViewIfNotVisible(bool centerIfNotVisible)
 736 {
 737     document().updateLayoutIgnorePendingStylesheets();
 738 
 739     if (!renderer())
 740         return;
 741 
 742     bool insideFixed;
 743     LayoutRect absoluteBounds = renderer()-&gt;absoluteAnchorRect(&amp;insideFixed);
 744     if (centerIfNotVisible)
 745         renderer()-&gt;scrollRectToVisible(absoluteBounds, insideFixed, { SelectionRevealMode::Reveal, ScrollAlignment::alignCenterIfNotVisible, ScrollAlignment::alignCenterIfNotVisible, ShouldAllowCrossOriginScrolling::No });
 746     else
 747         renderer()-&gt;scrollRectToVisible(absoluteBounds, insideFixed, { SelectionRevealMode::Reveal, ScrollAlignment::alignToEdgeIfNotVisible, ScrollAlignment::alignToEdgeIfNotVisible, ShouldAllowCrossOriginScrolling::No });
 748 }
 749 
 750 void Element::scrollBy(const ScrollToOptions&amp; options)
 751 {
 752     ScrollToOptions scrollToOptions = normalizeNonFiniteCoordinatesOrFallBackTo(options, 0, 0);
 753     scrollToOptions.left.value() += scrollLeft();
 754     scrollToOptions.top.value() += scrollTop();
 755     scrollTo(scrollToOptions);
 756 }
 757 
 758 void Element::scrollBy(double x, double y)
 759 {
 760     scrollBy({ x, y });
 761 }
 762 
 763 void Element::scrollTo(const ScrollToOptions&amp; options, ScrollClamping clamping)
 764 {
 765     if (!document().settings().CSSOMViewScrollingAPIEnabled()) {
 766         // If the element is the root element and document is in quirks mode, terminate these steps.
 767         // Note that WebKit always uses quirks mode document scrolling behavior. See Document::scrollingElement().
 768         if (this == document().documentElement())
 769             return;
 770     }
 771 
 772     document().updateLayoutIgnorePendingStylesheets();
 773 
 774     if (document().scrollingElement() == this) {
 775         // If the element is the scrolling element and is not potentially scrollable,
 776         // invoke scroll() on window with options as the only argument, and terminate these steps.
 777         // FIXME: Scrolling an independently scrollable body is broken: webkit.org/b/161612.
 778         auto window = makeRefPtr(document().domWindow());
 779         if (!window)
 780             return;
 781 
 782         window-&gt;scrollTo(options);
 783         return;
 784     }
 785 
 786     // If the element does not have any associated CSS layout box, the element has no associated scrolling box,
 787     // or the element has no overflow, terminate these steps.
 788     RenderBox* renderer = renderBox();
 789     if (!renderer || !renderer-&gt;hasOverflowClip())
 790         return;
 791 
 792     ScrollToOptions scrollToOptions = normalizeNonFiniteCoordinatesOrFallBackTo(options,
 793         adjustForAbsoluteZoom(renderer-&gt;scrollLeft(), *renderer),
 794         adjustForAbsoluteZoom(renderer-&gt;scrollTop(), *renderer)
 795     );
 796     renderer-&gt;setScrollLeft(clampToInteger(scrollToOptions.left.value() * renderer-&gt;style().effectiveZoom()), clamping);
 797     renderer-&gt;setScrollTop(clampToInteger(scrollToOptions.top.value() * renderer-&gt;style().effectiveZoom()), clamping);
 798 }
 799 
 800 void Element::scrollTo(double x, double y)
 801 {
 802     scrollTo({ x, y });
 803 }
 804 
 805 void Element::scrollByUnits(int units, ScrollGranularity granularity)
 806 {
 807     document().updateLayoutIgnorePendingStylesheets();
 808 
 809     auto* renderer = this-&gt;renderer();
 810     if (!renderer)
 811         return;
 812 
 813     if (!renderer-&gt;hasOverflowClip())
 814         return;
 815 
 816     ScrollDirection direction = ScrollDown;
 817     if (units &lt; 0) {
 818         direction = ScrollUp;
 819         units = -units;
 820     }
 821     Element* stopElement = this;
 822     downcast&lt;RenderBox&gt;(*renderer).scroll(direction, granularity, units, &amp;stopElement);
 823 }
 824 
 825 void Element::scrollByLines(int lines)
 826 {
 827     scrollByUnits(lines, ScrollByLine);
 828 }
 829 
 830 void Element::scrollByPages(int pages)
 831 {
 832     scrollByUnits(pages, ScrollByPage);
 833 }
 834 
 835 static double localZoomForRenderer(const RenderElement&amp; renderer)
 836 {
 837     // FIXME: This does the wrong thing if two opposing zooms are in effect and canceled each
 838     // other out, but the alternative is that we&#39;d have to crawl up the whole render tree every
 839     // time (or store an additional bit in the RenderStyle to indicate that a zoom was specified).
 840     double zoomFactor = 1;
 841     if (renderer.style().effectiveZoom() != 1) {
 842         // Need to find the nearest enclosing RenderElement that set up
 843         // a differing zoom, and then we divide our result by it to eliminate the zoom.
 844         const RenderElement* prev = &amp;renderer;
 845         for (RenderElement* curr = prev-&gt;parent(); curr; curr = curr-&gt;parent()) {
 846             if (curr-&gt;style().effectiveZoom() != prev-&gt;style().effectiveZoom()) {
 847                 zoomFactor = prev-&gt;style().zoom();
 848                 break;
 849             }
 850             prev = curr;
 851         }
 852         if (prev-&gt;isRenderView())
 853             zoomFactor = prev-&gt;style().zoom();
 854     }
 855     return zoomFactor;
 856 }
 857 
 858 static double adjustForLocalZoom(LayoutUnit value, const RenderElement&amp; renderer, double&amp; zoomFactor)
 859 {
 860     zoomFactor = localZoomForRenderer(renderer);
 861     if (zoomFactor == 1)
 862         return value.toDouble();
 863     return value.toDouble() / zoomFactor;
 864 }
 865 
 866 static int adjustContentsScrollPositionOrSizeForZoom(int value, const Frame&amp; frame)
 867 {
 868     double zoomFactor = frame.pageZoomFactor() * frame.frameScaleFactor();
 869     if (zoomFactor == 1)
 870         return value;
 871     // FIXME (webkit.org/b/189397): Why can&#39;t we just ceil/floor?
 872     // Needed because of truncation (rather than rounding) when scaling up.
 873     if (zoomFactor &gt; 1)
 874         value++;
 875     return static_cast&lt;int&gt;(value / zoomFactor);
 876 }
 877 
 878 enum LegacyCSSOMElementMetricsRoundingStrategy { Round, Floor };
 879 
 880 static bool subpixelMetricsEnabled(const Document&amp; document)
 881 {
 882     return document.settings().subpixelCSSOMElementMetricsEnabled();
 883 }
 884 
 885 static double convertToNonSubpixelValueIfNeeded(double value, const Document&amp; document, LegacyCSSOMElementMetricsRoundingStrategy roundStrategy = Round)
 886 {
 887     return subpixelMetricsEnabled(document) ? value : roundStrategy == Round ? round(value) : floor(value);
 888 }
 889 
 890 static double adjustOffsetForZoomAndSubpixelLayout(RenderBoxModelObject* renderer, const LayoutUnit&amp; offset)
 891 {
 892     LayoutUnit offsetLeft = subpixelMetricsEnabled(renderer-&gt;document()) ? offset : LayoutUnit(roundToInt(offset));
 893     double zoomFactor = 1;
 894     double offsetLeftAdjustedWithZoom = adjustForLocalZoom(offsetLeft, *renderer, zoomFactor);
 895     return convertToNonSubpixelValueIfNeeded(offsetLeftAdjustedWithZoom, renderer-&gt;document(), zoomFactor == 1 ? Floor : Round);
 896 }
 897 
 898 static HashSet&lt;TreeScope*&gt; collectAncestorTreeScopeAsHashSet(Node&amp; node)
 899 {
 900     HashSet&lt;TreeScope*&gt; ancestors;
 901     for (auto* currentScope = &amp;node.treeScope(); currentScope; currentScope = currentScope-&gt;parentTreeScope())
 902         ancestors.add(currentScope);
 903     return ancestors;
 904 }
 905 
 906 double Element::offsetLeftForBindings()
 907 {
 908     auto offset = offsetLeft();
 909 
 910     auto parent = makeRefPtr(offsetParent());
 911     if (!parent || !parent-&gt;isInShadowTree())
 912         return offset;
 913 
 914     ASSERT(&amp;parent-&gt;document() == &amp;document());
 915     if (&amp;parent-&gt;treeScope() == &amp;treeScope())
 916         return offset;
 917 
 918     auto ancestorTreeScopes = collectAncestorTreeScopeAsHashSet(*this);
 919     while (parent &amp;&amp; !ancestorTreeScopes.contains(&amp;parent-&gt;treeScope())) {
 920         offset += parent-&gt;offsetLeft();
 921         parent = parent-&gt;offsetParent();
 922     }
 923 
 924     return offset;
 925 }
 926 
 927 double Element::offsetLeft()
 928 {
 929     document().updateLayoutIgnorePendingStylesheets();
 930     if (RenderBoxModelObject* renderer = renderBoxModelObject())
 931         return adjustOffsetForZoomAndSubpixelLayout(renderer, renderer-&gt;offsetLeft());
 932     return 0;
 933 }
 934 
 935 double Element::offsetTopForBindings()
 936 {
 937     auto offset = offsetTop();
 938 
 939     auto parent = makeRefPtr(offsetParent());
 940     if (!parent || !parent-&gt;isInShadowTree())
 941         return offset;
 942 
 943     ASSERT(&amp;parent-&gt;document() == &amp;document());
 944     if (&amp;parent-&gt;treeScope() == &amp;treeScope())
 945         return offset;
 946 
 947     auto ancestorTreeScopes = collectAncestorTreeScopeAsHashSet(*this);
 948     while (parent &amp;&amp; !ancestorTreeScopes.contains(&amp;parent-&gt;treeScope())) {
 949         offset += parent-&gt;offsetTop();
 950         parent = parent-&gt;offsetParent();
 951     }
 952 
 953     return offset;
 954 }
 955 
 956 double Element::offsetTop()
 957 {
 958     document().updateLayoutIgnorePendingStylesheets();
 959     if (RenderBoxModelObject* renderer = renderBoxModelObject())
 960         return adjustOffsetForZoomAndSubpixelLayout(renderer, renderer-&gt;offsetTop());
 961     return 0;
 962 }
 963 
 964 double Element::offsetWidth()
 965 {
 966     document().updateLayoutIfDimensionsOutOfDate(*this, WidthDimensionsCheck);
 967     if (RenderBoxModelObject* renderer = renderBoxModelObject()) {
 968         LayoutUnit offsetWidth = subpixelMetricsEnabled(renderer-&gt;document()) ? renderer-&gt;offsetWidth() : LayoutUnit(roundToInt(renderer-&gt;offsetWidth()));
 969         return convertToNonSubpixelValueIfNeeded(adjustLayoutUnitForAbsoluteZoom(offsetWidth, *renderer).toDouble(), renderer-&gt;document());
 970     }
 971     return 0;
 972 }
 973 
 974 double Element::offsetHeight()
 975 {
 976     document().updateLayoutIfDimensionsOutOfDate(*this, HeightDimensionsCheck);
 977     if (RenderBoxModelObject* renderer = renderBoxModelObject()) {
 978         LayoutUnit offsetHeight = subpixelMetricsEnabled(renderer-&gt;document()) ? renderer-&gt;offsetHeight() : LayoutUnit(roundToInt(renderer-&gt;offsetHeight()));
 979         return convertToNonSubpixelValueIfNeeded(adjustLayoutUnitForAbsoluteZoom(offsetHeight, *renderer).toDouble(), renderer-&gt;document());
 980     }
 981     return 0;
 982 }
 983 
 984 Element* Element::offsetParentForBindings()
 985 {
 986     Element* element = offsetParent();
 987     if (!element || !element-&gt;isInShadowTree())
 988         return element;
 989     while (element &amp;&amp; !isDescendantOrShadowDescendantOf(&amp;element-&gt;rootNode()))
 990         element = element-&gt;offsetParent();
 991     return element;
 992 }
 993 
 994 Element* Element::offsetParent()
 995 {
 996     document().updateLayoutIgnorePendingStylesheets();
 997     auto renderer = this-&gt;renderer();
 998     if (!renderer)
 999         return nullptr;
1000     auto offsetParent = renderer-&gt;offsetParent();
1001     if (!offsetParent)
1002         return nullptr;
1003     return offsetParent-&gt;element();
1004 }
1005 
1006 double Element::clientLeft()
1007 {
1008     document().updateLayoutIgnorePendingStylesheets();
1009 
1010     if (auto* renderer = renderBox()) {
1011         LayoutUnit clientLeft = subpixelMetricsEnabled(renderer-&gt;document()) ? renderer-&gt;clientLeft() : LayoutUnit(roundToInt(renderer-&gt;clientLeft()));
1012         return convertToNonSubpixelValueIfNeeded(adjustLayoutUnitForAbsoluteZoom(clientLeft, *renderer).toDouble(), renderer-&gt;document());
1013     }
1014     return 0;
1015 }
1016 
1017 double Element::clientTop()
1018 {
1019     document().updateLayoutIgnorePendingStylesheets();
1020 
1021     if (auto* renderer = renderBox()) {
1022         LayoutUnit clientTop = subpixelMetricsEnabled(renderer-&gt;document()) ? renderer-&gt;clientTop() : LayoutUnit(roundToInt(renderer-&gt;clientTop()));
1023         return convertToNonSubpixelValueIfNeeded(adjustLayoutUnitForAbsoluteZoom(clientTop, *renderer).toDouble(), renderer-&gt;document());
1024     }
1025     return 0;
1026 }
1027 
1028 double Element::clientWidth()
1029 {
1030     document().updateLayoutIfDimensionsOutOfDate(*this, WidthDimensionsCheck);
1031 
1032     if (!document().hasLivingRenderTree())
1033         return 0;
1034 
1035     RenderView&amp; renderView = *document().renderView();
1036 
1037     // When in strict mode, clientWidth for the document element should return the width of the containing frame.
1038     // When in quirks mode, clientWidth for the body element should return the width of the containing frame.
1039     bool inQuirksMode = document().inQuirksMode();
1040     if ((!inQuirksMode &amp;&amp; document().documentElement() == this) || (inQuirksMode &amp;&amp; isHTMLElement() &amp;&amp; document().bodyOrFrameset() == this))
1041         return adjustForAbsoluteZoom(renderView.frameView().layoutWidth(), renderView);
1042 
1043     if (RenderBox* renderer = renderBox()) {
1044         LayoutUnit clientWidth = subpixelMetricsEnabled(renderer-&gt;document()) ? renderer-&gt;clientWidth() : LayoutUnit(roundToInt(renderer-&gt;clientWidth()));
1045         return convertToNonSubpixelValueIfNeeded(adjustLayoutUnitForAbsoluteZoom(clientWidth, *renderer).toDouble(), renderer-&gt;document());
1046     }
1047     return 0;
1048 }
1049 
1050 double Element::clientHeight()
1051 {
1052     document().updateLayoutIfDimensionsOutOfDate(*this, HeightDimensionsCheck);
1053     if (!document().hasLivingRenderTree())
1054         return 0;
1055 
1056     RenderView&amp; renderView = *document().renderView();
1057 
1058     // When in strict mode, clientHeight for the document element should return the height of the containing frame.
1059     // When in quirks mode, clientHeight for the body element should return the height of the containing frame.
1060     bool inQuirksMode = document().inQuirksMode();
1061     if ((!inQuirksMode &amp;&amp; document().documentElement() == this) || (inQuirksMode &amp;&amp; isHTMLElement() &amp;&amp; document().bodyOrFrameset() == this))
1062         return adjustForAbsoluteZoom(renderView.frameView().layoutHeight(), renderView);
1063 
1064     if (RenderBox* renderer = renderBox()) {
1065         LayoutUnit clientHeight = subpixelMetricsEnabled(renderer-&gt;document()) ? renderer-&gt;clientHeight() : LayoutUnit(roundToInt(renderer-&gt;clientHeight()));
1066         return convertToNonSubpixelValueIfNeeded(adjustLayoutUnitForAbsoluteZoom(clientHeight, *renderer).toDouble(), renderer-&gt;document());
1067     }
1068     return 0;
1069 }
1070 
1071 ALWAYS_INLINE Frame* Element::documentFrameWithNonNullView() const
1072 {
1073     auto* frame = document().frame();
1074     return frame &amp;&amp; frame-&gt;view() ? frame : nullptr;
1075 }
1076 
1077 int Element::scrollLeft()
1078 {
1079     document().updateLayoutIgnorePendingStylesheets();
1080 
1081     if (document().scrollingElement() == this) {
1082         if (auto* frame = documentFrameWithNonNullView())
1083             return adjustContentsScrollPositionOrSizeForZoom(frame-&gt;view()-&gt;contentsScrollPosition().x(), *frame);
1084         return 0;
1085     }
1086 
1087     if (auto* renderer = renderBox())
1088         return adjustForAbsoluteZoom(renderer-&gt;scrollLeft(), *renderer);
1089     return 0;
1090 }
1091 
1092 int Element::scrollTop()
1093 {
1094     document().updateLayoutIgnorePendingStylesheets();
1095 
1096     if (document().scrollingElement() == this) {
1097         if (auto* frame = documentFrameWithNonNullView())
1098             return adjustContentsScrollPositionOrSizeForZoom(frame-&gt;view()-&gt;contentsScrollPosition().y(), *frame);
1099         return 0;
1100     }
1101 
1102     if (RenderBox* renderer = renderBox())
1103         return adjustForAbsoluteZoom(renderer-&gt;scrollTop(), *renderer);
1104     return 0;
1105 }
1106 
1107 void Element::setScrollLeft(int newLeft)
1108 {
1109     document().updateLayoutIgnorePendingStylesheets();
1110 
1111     if (document().scrollingElement() == this) {
1112         if (auto* frame = documentFrameWithNonNullView())
1113             frame-&gt;view()-&gt;setScrollPosition(IntPoint(static_cast&lt;int&gt;(newLeft * frame-&gt;pageZoomFactor() * frame-&gt;frameScaleFactor()), frame-&gt;view()-&gt;scrollY()));
1114         return;
1115     }
1116 
1117     if (auto* renderer = renderBox()) {
1118         renderer-&gt;setScrollLeft(static_cast&lt;int&gt;(newLeft * renderer-&gt;style().effectiveZoom()));
1119         if (auto* scrollableArea = renderer-&gt;layer())
1120             scrollableArea-&gt;setScrolledProgrammatically(true);
1121     }
1122 }
1123 
1124 void Element::setScrollTop(int newTop)
1125 {
1126     document().updateLayoutIgnorePendingStylesheets();
1127 
1128     if (document().scrollingElement() == this) {
1129         if (auto* frame = documentFrameWithNonNullView())
1130             frame-&gt;view()-&gt;setScrollPosition(IntPoint(frame-&gt;view()-&gt;scrollX(), static_cast&lt;int&gt;(newTop * frame-&gt;pageZoomFactor() * frame-&gt;frameScaleFactor())));
1131         return;
1132     }
1133 
1134     if (auto* renderer = renderBox()) {
1135         renderer-&gt;setScrollTop(static_cast&lt;int&gt;(newTop * renderer-&gt;style().effectiveZoom()));
1136         if (auto* scrollableArea = renderer-&gt;layer())
1137             scrollableArea-&gt;setScrolledProgrammatically(true);
1138     }
1139 }
1140 
1141 int Element::scrollWidth()
1142 {
1143     document().updateLayoutIfDimensionsOutOfDate(*this, WidthDimensionsCheck);
1144 
1145     if (document().scrollingElement() == this) {
1146         // FIXME (webkit.org/b/182289): updateLayoutIfDimensionsOutOfDate seems to ignore zoom level change.
1147         document().updateLayoutIgnorePendingStylesheets();
1148         if (auto* frame = documentFrameWithNonNullView())
1149             return adjustContentsScrollPositionOrSizeForZoom(frame-&gt;view()-&gt;contentsWidth(), *frame);
1150         return 0;
1151     }
1152 
1153     if (auto* renderer = renderBox())
1154         return adjustForAbsoluteZoom(renderer-&gt;scrollWidth(), *renderer);
1155     return 0;
1156 }
1157 
1158 int Element::scrollHeight()
1159 {
1160     document().updateLayoutIfDimensionsOutOfDate(*this, HeightDimensionsCheck);
1161 
1162     if (document().scrollingElement() == this) {
1163         // FIXME (webkit.org/b/182289): updateLayoutIfDimensionsOutOfDate seems to ignore zoom level change.
1164         document().updateLayoutIgnorePendingStylesheets();
1165         if (auto* frame = documentFrameWithNonNullView())
1166             return adjustContentsScrollPositionOrSizeForZoom(frame-&gt;view()-&gt;contentsHeight(), *frame);
1167         return 0;
1168     }
1169 
1170     if (auto* renderer = renderBox())
1171         return adjustForAbsoluteZoom(renderer-&gt;scrollHeight(), *renderer);
1172     return 0;
1173 }
1174 
1175 IntRect Element::boundsInRootViewSpace()
1176 {
1177     document().updateLayoutIgnorePendingStylesheets();
1178 
1179     FrameView* view = document().view();
1180     if (!view)
1181         return IntRect();
1182 
1183     Vector&lt;FloatQuad&gt; quads;
1184 
1185     if (isSVGElement() &amp;&amp; renderer()) {
1186         // Get the bounding rectangle from the SVG model.
1187         SVGElement&amp; svgElement = downcast&lt;SVGElement&gt;(*this);
1188         FloatRect localRect;
1189         if (svgElement.getBoundingBox(localRect))
1190             quads.append(renderer()-&gt;localToAbsoluteQuad(localRect));
1191     } else {
1192         // Get the bounding rectangle from the box model.
1193         if (renderBoxModelObject())
1194             renderBoxModelObject()-&gt;absoluteQuads(quads);
1195     }
1196 
1197     if (quads.isEmpty())
1198         return IntRect();
1199 
1200     IntRect result = quads[0].enclosingBoundingBox();
1201     for (size_t i = 1; i &lt; quads.size(); ++i)
1202         result.unite(quads[i].enclosingBoundingBox());
1203 
1204     result = view-&gt;contentsToRootView(result);
1205     return result;
1206 }
1207 
1208 static bool layoutOverflowRectContainsAllDescendants(const RenderBox&amp; renderBox)
1209 {
1210     if (renderBox.isRenderView())
1211         return true;
1212 
1213     if (!renderBox.element())
1214         return false;
1215 
1216     // If there are any position:fixed inside of us, game over.
1217     if (auto* viewPositionedObjects = renderBox.view().positionedObjects()) {
1218         for (auto* positionedBox : *viewPositionedObjects) {
1219             if (positionedBox == &amp;renderBox)
1220                 continue;
1221             if (positionedBox-&gt;isFixedPositioned() &amp;&amp; renderBox.element()-&gt;contains(positionedBox-&gt;element()))
1222                 return false;
1223         }
1224     }
1225 
1226     if (renderBox.canContainAbsolutelyPositionedObjects()) {
1227         // Our layout overflow will include all descendant positioned elements.
1228         return true;
1229     }
1230 
1231     // This renderer may have positioned descendants whose containing block is some ancestor.
1232     if (auto* containingBlock = renderBox.containingBlockForAbsolutePosition()) {
1233         if (auto* positionedObjects = containingBlock-&gt;positionedObjects()) {
1234             for (auto* positionedBox : *positionedObjects) {
1235                 if (positionedBox == &amp;renderBox)
1236                     continue;
1237                 if (renderBox.element()-&gt;contains(positionedBox-&gt;element()))
1238                     return false;
1239             }
1240         }
1241     }
1242     return false;
1243 }
1244 
1245 LayoutRect Element::absoluteEventBounds(bool&amp; boundsIncludeAllDescendantElements, bool&amp; includesFixedPositionElements)
1246 {
1247     boundsIncludeAllDescendantElements = false;
1248     includesFixedPositionElements = false;
1249 
1250     if (!renderer())
1251         return LayoutRect();
1252 
1253     LayoutRect result;
1254     if (isSVGElement()) {
1255         // Get the bounding rectangle from the SVG model.
1256         SVGElement&amp; svgElement = downcast&lt;SVGElement&gt;(*this);
1257         FloatRect localRect;
1258         if (svgElement.getBoundingBox(localRect, SVGLocatable::DisallowStyleUpdate))
1259             result = LayoutRect(renderer()-&gt;localToAbsoluteQuad(localRect, UseTransforms, &amp;includesFixedPositionElements).boundingBox());
1260     } else {
1261         auto* renderer = this-&gt;renderer();
1262         if (is&lt;RenderBox&gt;(renderer)) {
1263             auto&amp; box = downcast&lt;RenderBox&gt;(*renderer);
1264 
1265             bool computedBounds = false;
1266 
1267             if (RenderFragmentedFlow* fragmentedFlow = box.enclosingFragmentedFlow()) {
1268                 bool wasFixed = false;
1269                 Vector&lt;FloatQuad&gt; quads;
1270                 FloatRect localRect(0, 0, box.width(), box.height());
1271                 if (fragmentedFlow-&gt;absoluteQuadsForBox(quads, &amp;wasFixed, &amp;box, localRect.y(), localRect.maxY())) {
1272                     FloatRect quadBounds = quads[0].boundingBox();
1273                     for (size_t i = 1; i &lt; quads.size(); ++i)
1274                         quadBounds.unite(quads[i].boundingBox());
1275 
1276                     result = LayoutRect(quadBounds);
1277                     computedBounds = true;
1278                 } else {
1279                     // Probably columns. Just return the bounds of the multicol block for now.
1280                     // FIXME: this doesn&#39;t handle nested columns.
1281                     RenderElement* multicolContainer = fragmentedFlow-&gt;parent();
1282                     if (multicolContainer &amp;&amp; is&lt;RenderBox&gt;(multicolContainer)) {
1283                         auto overflowRect = downcast&lt;RenderBox&gt;(*multicolContainer).layoutOverflowRect();
1284                         result = LayoutRect(multicolContainer-&gt;localToAbsoluteQuad(FloatRect(overflowRect), UseTransforms, &amp;includesFixedPositionElements).boundingBox());
1285                         computedBounds = true;
1286                     }
1287                 }
1288             }
1289 
1290             if (!computedBounds) {
1291                 LayoutRect overflowRect = box.layoutOverflowRect();
1292                 result = LayoutRect(box.localToAbsoluteQuad(FloatRect(overflowRect), UseTransforms, &amp;includesFixedPositionElements).boundingBox());
1293                 boundsIncludeAllDescendantElements = layoutOverflowRectContainsAllDescendants(box);
1294             }
1295         } else
1296             result = LayoutRect(renderer-&gt;absoluteBoundingBoxRect(true /* useTransforms */, &amp;includesFixedPositionElements));
1297     }
1298 
1299     return result;
1300 }
1301 
1302 LayoutRect Element::absoluteEventBoundsOfElementAndDescendants(bool&amp; includesFixedPositionElements)
1303 {
1304     bool boundsIncludeDescendants;
1305     LayoutRect result = absoluteEventBounds(boundsIncludeDescendants, includesFixedPositionElements);
1306     if (boundsIncludeDescendants)
1307         return result;
1308 
1309     for (auto&amp; child : childrenOfType&lt;Element&gt;(*this)) {
1310         bool includesFixedPosition = false;
1311         LayoutRect childBounds = child.absoluteEventBoundsOfElementAndDescendants(includesFixedPosition);
1312         includesFixedPositionElements |= includesFixedPosition;
1313         result.unite(childBounds);
1314     }
1315 
1316     return result;
1317 }
1318 
1319 LayoutRect Element::absoluteEventHandlerBounds(bool&amp; includesFixedPositionElements)
1320 {
1321     // This is not web-exposed, so don&#39;t call the FOUC-inducing updateLayoutIgnorePendingStylesheets().
1322     FrameView* frameView = document().view();
1323     if (!frameView)
1324         return LayoutRect();
1325 
1326     return absoluteEventBoundsOfElementAndDescendants(includesFixedPositionElements);
1327 }
1328 
1329 static Optional&lt;std::pair&lt;RenderObject*, LayoutRect&gt;&gt; listBoxElementBoundingBox(Element&amp; element)
1330 {
1331     HTMLSelectElement* selectElement;
1332     bool isGroup;
1333     if (is&lt;HTMLOptionElement&gt;(element)) {
1334         selectElement = downcast&lt;HTMLOptionElement&gt;(element).ownerSelectElement();
1335         isGroup = false;
1336     } else if (is&lt;HTMLOptGroupElement&gt;(element)) {
1337         selectElement = downcast&lt;HTMLOptGroupElement&gt;(element).ownerSelectElement();
1338         isGroup = true;
1339     } else
1340         return WTF::nullopt;
1341 
1342     if (!selectElement || !selectElement-&gt;renderer() || !is&lt;RenderListBox&gt;(selectElement-&gt;renderer()))
1343         return WTF::nullopt;
1344 
1345     auto&amp; renderer = downcast&lt;RenderListBox&gt;(*selectElement-&gt;renderer());
1346     Optional&lt;LayoutRect&gt; boundingBox;
1347     int optionIndex = 0;
1348     for (auto* item : selectElement-&gt;listItems()) {
1349         if (item == &amp;element) {
1350             LayoutPoint additionOffset;
1351             boundingBox = renderer.itemBoundingBoxRect(additionOffset, optionIndex);
1352             if (!isGroup)
1353                 break;
1354         } else if (isGroup &amp;&amp; boundingBox) {
1355             if (item-&gt;parentNode() != &amp;element)
1356                 break;
1357             LayoutPoint additionOffset;
1358             boundingBox-&gt;setHeight(boundingBox-&gt;height() + renderer.itemBoundingBoxRect(additionOffset, optionIndex).height());
1359         }
1360         ++optionIndex;
1361     }
1362 
1363     if (!boundingBox)
1364         return WTF::nullopt;
1365 
1366     return std::pair&lt;RenderObject*, LayoutRect&gt; { &amp;renderer, boundingBox.value() };
1367 }
1368 
1369 Ref&lt;DOMRectList&gt; Element::getClientRects()
1370 {
1371     document().updateLayoutIgnorePendingStylesheets();
1372 
1373     RenderObject* renderer = this-&gt;renderer();
1374     Vector&lt;FloatQuad&gt; quads;
1375 
1376     if (auto pair = listBoxElementBoundingBox(*this)) {
1377         renderer = pair.value().first;
1378         quads.append(renderer-&gt;localToAbsoluteQuad(FloatQuad { pair.value().second }));
1379     } else if (auto* renderBoxModelObject = this-&gt;renderBoxModelObject())
1380         renderBoxModelObject-&gt;absoluteQuads(quads);
1381 
1382     // FIXME: Handle SVG elements.
1383     // FIXME: Handle table/inline-table with a caption.
1384 
1385     if (quads.isEmpty())
1386         return DOMRectList::create();
1387 
1388     document().convertAbsoluteToClientQuads(quads, renderer-&gt;style());
1389     return DOMRectList::create(quads);
1390 }
1391 
1392 FloatRect Element::boundingClientRect()
1393 {
1394     document().updateLayoutIgnorePendingStylesheets();
1395 
1396     RenderObject* renderer = this-&gt;renderer();
1397     Vector&lt;FloatQuad&gt; quads;
1398     if (isSVGElement() &amp;&amp; renderer &amp;&amp; !renderer-&gt;isSVGRoot()) {
1399         // Get the bounding rectangle from the SVG model.
1400         SVGElement&amp; svgElement = downcast&lt;SVGElement&gt;(*this);
1401         FloatRect localRect;
1402         if (svgElement.getBoundingBox(localRect))
1403             quads.append(renderer-&gt;localToAbsoluteQuad(localRect));
1404     } else if (auto pair = listBoxElementBoundingBox(*this)) {
1405         renderer = pair.value().first;
1406         quads.append(renderer-&gt;localToAbsoluteQuad(FloatQuad { pair.value().second }));
1407     } else if (auto* renderBoxModelObject = this-&gt;renderBoxModelObject())
1408         renderBoxModelObject-&gt;absoluteQuads(quads);
1409 
1410     if (quads.isEmpty())
1411         return { };
1412 
1413     FloatRect result = quads[0].boundingBox();
1414     for (size_t i = 1; i &lt; quads.size(); ++i)
1415         result.unite(quads[i].boundingBox());
1416 
1417     document().convertAbsoluteToClientRect(result, renderer-&gt;style());
1418     return result;
1419 }
1420 
1421 Ref&lt;DOMRect&gt; Element::getBoundingClientRect()
1422 {
1423     return DOMRect::create(boundingClientRect());
1424 }
1425 
1426 // Note that this is not web-exposed, and does not use the same coordinate system as getBoundingClientRect() and friends.
1427 IntRect Element::clientRect() const
1428 {
1429     if (RenderObject* renderer = this-&gt;renderer())
1430         return document().view()-&gt;contentsToRootView(renderer-&gt;absoluteBoundingBoxRect());
1431     return IntRect();
1432 }
1433 
1434 IntRect Element::screenRect() const
1435 {
1436     if (RenderObject* renderer = this-&gt;renderer())
1437         return document().view()-&gt;contentsToScreen(renderer-&gt;absoluteBoundingBoxRect());
1438     return IntRect();
1439 }
1440 
1441 const AtomicString&amp; Element::getAttribute(const AtomicString&amp; qualifiedName) const
1442 {
1443     if (!elementData())
1444         return nullAtom();
1445     synchronizeAttribute(qualifiedName);
1446     if (const Attribute* attribute = elementData()-&gt;findAttributeByName(qualifiedName, shouldIgnoreAttributeCase(*this)))
1447         return attribute-&gt;value();
1448     return nullAtom();
1449 }
1450 
1451 const AtomicString&amp; Element::getAttributeNS(const AtomicString&amp; namespaceURI, const AtomicString&amp; localName) const
1452 {
1453     return getAttribute(QualifiedName(nullAtom(), localName, namespaceURI));
1454 }
1455 
1456 // https://dom.spec.whatwg.org/#dom-element-toggleattribute
1457 ExceptionOr&lt;bool&gt; Element::toggleAttribute(const AtomicString&amp; qualifiedName, Optional&lt;bool&gt; force)
1458 {
1459     if (!Document::isValidName(qualifiedName))
1460         return Exception { InvalidCharacterError };
1461 
1462     synchronizeAttribute(qualifiedName);
1463 
1464     auto caseAdjustedQualifiedName = shouldIgnoreAttributeCase(*this) ? qualifiedName.convertToASCIILowercase() : qualifiedName;
1465     unsigned index = elementData() ? elementData()-&gt;findAttributeIndexByName(caseAdjustedQualifiedName, false) : ElementData::attributeNotFound;
1466     if (index == ElementData::attributeNotFound) {
1467         if (!force || *force) {
1468             setAttributeInternal(index, QualifiedName { nullAtom(), caseAdjustedQualifiedName, nullAtom() }, emptyString(), NotInSynchronizationOfLazyAttribute);
1469             return true;
1470         }
1471         return false;
1472     }
1473 
1474     if (!force || !*force) {
1475         removeAttributeInternal(index, NotInSynchronizationOfLazyAttribute);
1476         return false;
1477     }
1478     return true;
1479 }
1480 
1481 ExceptionOr&lt;void&gt; Element::setAttribute(const AtomicString&amp; qualifiedName, const AtomicString&amp; value)
1482 {
1483     if (!Document::isValidName(qualifiedName))
1484         return Exception { InvalidCharacterError };
1485 
1486     synchronizeAttribute(qualifiedName);
1487     auto caseAdjustedQualifiedName = shouldIgnoreAttributeCase(*this) ? qualifiedName.convertToASCIILowercase() : qualifiedName;
1488     unsigned index = elementData() ? elementData()-&gt;findAttributeIndexByName(caseAdjustedQualifiedName, false) : ElementData::attributeNotFound;
1489     auto name = index != ElementData::attributeNotFound ? attributeAt(index).name() : QualifiedName { nullAtom(), caseAdjustedQualifiedName, nullAtom() };
1490     setAttributeInternal(index, name, value, NotInSynchronizationOfLazyAttribute);
1491 
1492     return { };
1493 }
1494 
1495 void Element::setAttribute(const QualifiedName&amp; name, const AtomicString&amp; value)
1496 {
1497     synchronizeAttribute(name);
1498     unsigned index = elementData() ? elementData()-&gt;findAttributeIndexByName(name) : ElementData::attributeNotFound;
1499     setAttributeInternal(index, name, value, NotInSynchronizationOfLazyAttribute);
1500 }
1501 
1502 void Element::setAttributeWithoutSynchronization(const QualifiedName&amp; name, const AtomicString&amp; value)
1503 {
1504     unsigned index = elementData() ? elementData()-&gt;findAttributeIndexByName(name) : ElementData::attributeNotFound;
1505     setAttributeInternal(index, name, value, NotInSynchronizationOfLazyAttribute);
1506 }
1507 
1508 void Element::setSynchronizedLazyAttribute(const QualifiedName&amp; name, const AtomicString&amp; value)
1509 {
1510     unsigned index = elementData() ? elementData()-&gt;findAttributeIndexByName(name) : ElementData::attributeNotFound;
1511     setAttributeInternal(index, name, value, InSynchronizationOfLazyAttribute);
1512 }
1513 
1514 inline void Element::setAttributeInternal(unsigned index, const QualifiedName&amp; name, const AtomicString&amp; newValue, SynchronizationOfLazyAttribute inSynchronizationOfLazyAttribute)
1515 {
1516     if (newValue.isNull()) {
1517         if (index != ElementData::attributeNotFound)
1518             removeAttributeInternal(index, inSynchronizationOfLazyAttribute);
1519         return;
1520     }
1521 
1522     if (index == ElementData::attributeNotFound) {
1523         addAttributeInternal(name, newValue, inSynchronizationOfLazyAttribute);
1524         return;
1525     }
1526 
1527     if (inSynchronizationOfLazyAttribute) {
1528         ensureUniqueElementData().attributeAt(index).setValue(newValue);
1529         return;
1530     }
1531 
1532     const Attribute&amp; attribute = attributeAt(index);
1533     QualifiedName attributeName = attribute.name();
1534     AtomicString oldValue = attribute.value();
1535 
1536     willModifyAttribute(attributeName, oldValue, newValue);
1537 
1538     if (newValue != oldValue) {
1539         Style::AttributeChangeInvalidation styleInvalidation(*this, name, oldValue, newValue);
1540         ensureUniqueElementData().attributeAt(index).setValue(newValue);
1541     }
1542 
1543     didModifyAttribute(attributeName, oldValue, newValue);
1544 }
1545 
1546 static inline AtomicString makeIdForStyleResolution(const AtomicString&amp; value, bool inQuirksMode)
1547 {
1548     if (inQuirksMode)
1549         return value.convertToASCIILowercase();
1550     return value;
1551 }
1552 
1553 void Element::attributeChanged(const QualifiedName&amp; name, const AtomicString&amp; oldValue, const AtomicString&amp; newValue, AttributeModificationReason)
1554 {
1555     bool valueIsSameAsBefore = oldValue == newValue;
1556 
1557     if (!valueIsSameAsBefore) {
1558         if (name == HTMLNames::accesskeyAttr)
1559             document().invalidateAccessKeyCache();
1560         else if (name == HTMLNames::classAttr)
1561             classAttributeChanged(newValue);
1562         else if (name == HTMLNames::idAttr) {
1563             AtomicString oldId = elementData()-&gt;idForStyleResolution();
1564             AtomicString newId = makeIdForStyleResolution(newValue, document().inQuirksMode());
1565             if (newId != oldId) {
1566                 Style::IdChangeInvalidation styleInvalidation(*this, oldId, newId);
1567                 elementData()-&gt;setIdForStyleResolution(newId);
1568             }
1569 
1570             if (!oldValue.isEmpty())
1571                 treeScope().idTargetObserverRegistry().notifyObservers(*oldValue.impl());
1572             if (!newValue.isEmpty())
1573                 treeScope().idTargetObserverRegistry().notifyObservers(*newValue.impl());
1574         } else if (name == HTMLNames::nameAttr)
1575             elementData()-&gt;setHasNameAttribute(!newValue.isNull());
1576         else if (name == HTMLNames::pseudoAttr) {
1577             if (needsStyleInvalidation() &amp;&amp; isInShadowTree())
1578                 invalidateStyleForSubtree();
1579         } else if (name == HTMLNames::slotAttr) {
1580             if (auto* parent = parentElement()) {
1581                 if (auto* shadowRoot = parent-&gt;shadowRoot())
1582                     shadowRoot-&gt;hostChildElementDidChangeSlotAttribute(*this, oldValue, newValue);
1583             }
1584         }
1585     }
1586 
1587     parseAttribute(name, newValue);
1588 
1589     document().incDOMTreeVersion();
1590 
1591     if (UNLIKELY(isDefinedCustomElement()))
1592         CustomElementReactionQueue::enqueueAttributeChangedCallbackIfNeeded(*this, name, oldValue, newValue);
1593 
1594     if (valueIsSameAsBefore)
1595         return;
1596 
1597     invalidateNodeListAndCollectionCachesInAncestorsForAttribute(name);
1598 
1599     if (AXObjectCache* cache = document().existingAXObjectCache())
1600         cache-&gt;deferAttributeChangeIfNeeded(name, this);
1601 }
1602 
1603 template &lt;typename CharacterType&gt;
1604 static inline bool classStringHasClassName(const CharacterType* characters, unsigned length)
1605 {
1606     ASSERT(length &gt; 0);
1607 
1608     unsigned i = 0;
1609     do {
1610         if (isNotHTMLSpace(characters[i]))
1611             break;
1612         ++i;
1613     } while (i &lt; length);
1614 
1615     return i &lt; length;
1616 }
1617 
1618 static inline bool classStringHasClassName(const AtomicString&amp; newClassString)
1619 {
1620     unsigned length = newClassString.length();
1621 
1622     if (!length)
1623         return false;
1624 
1625     if (newClassString.is8Bit())
1626         return classStringHasClassName(newClassString.characters8(), length);
1627     return classStringHasClassName(newClassString.characters16(), length);
1628 }
1629 
1630 void Element::classAttributeChanged(const AtomicString&amp; newClassString)
1631 {
1632     // Note: We&#39;ll need ElementData, but it doesn&#39;t have to be UniqueElementData.
1633     if (!elementData())
1634         ensureUniqueElementData();
1635 
1636     bool shouldFoldCase = document().inQuirksMode();
1637     bool newStringHasClasses = classStringHasClassName(newClassString);
1638 
1639     auto oldClassNames = elementData()-&gt;classNames();
1640     auto newClassNames = newStringHasClasses ? SpaceSplitString(newClassString, shouldFoldCase) : SpaceSplitString();
1641     {
1642         Style::ClassChangeInvalidation styleInvalidation(*this, oldClassNames, newClassNames);
1643         elementData()-&gt;setClassNames(newClassNames);
1644     }
1645 
1646     if (hasRareData()) {
1647         if (auto* classList = elementRareData()-&gt;classList())
1648             classList-&gt;associatedAttributeValueChanged(newClassString);
1649     }
1650 }
1651 
1652 URL Element::absoluteLinkURL() const
1653 {
1654     if (!isLink())
1655         return URL();
1656 
1657     AtomicString linkAttribute;
1658     if (hasTagName(SVGNames::aTag))
1659         linkAttribute = getAttribute(SVGNames::hrefAttr, XLinkNames::hrefAttr);
1660     else
1661         linkAttribute = getAttribute(HTMLNames::hrefAttr);
1662 
1663     if (linkAttribute.isEmpty())
1664         return URL();
1665 
1666     return document().completeURL(stripLeadingAndTrailingHTMLSpaces(linkAttribute));
1667 }
1668 
1669 #if ENABLE(TOUCH_EVENTS)
1670 bool Element::allowsDoubleTapGesture() const
1671 {
1672 #if ENABLE(POINTER_EVENTS)
1673     if (renderStyle() &amp;&amp; renderStyle()-&gt;touchActions() != TouchAction::Auto)
1674         return false;
1675 #endif
1676 
1677     Element* parent = parentElement();
1678     return !parent || parent-&gt;allowsDoubleTapGesture();
1679 }
1680 #endif
1681 
1682 StyleResolver&amp; Element::styleResolver()
1683 {
1684     if (auto* shadowRoot = containingShadowRoot())
1685         return shadowRoot-&gt;styleScope().resolver();
1686 
1687     return document().styleScope().resolver();
1688 }
1689 
1690 ElementStyle Element::resolveStyle(const RenderStyle* parentStyle)
1691 {
1692     return styleResolver().styleForElement(*this, parentStyle);
1693 }
1694 
1695 static void invalidateForSiblingCombinators(Element* sibling)
1696 {
1697     for (; sibling; sibling = sibling-&gt;nextElementSibling()) {
1698         if (sibling-&gt;styleIsAffectedByPreviousSibling())
1699             sibling-&gt;invalidateStyleInternal();
1700         if (sibling-&gt;descendantsAffectedByPreviousSibling()) {
1701             for (auto* siblingChild = sibling-&gt;firstElementChild(); siblingChild; siblingChild = siblingChild-&gt;nextElementSibling())
1702                 siblingChild-&gt;invalidateStyleForSubtreeInternal();
1703         }
1704         if (!sibling-&gt;affectsNextSiblingElementStyle())
1705             return;
1706     }
1707 }
1708 
1709 static void invalidateSiblingsIfNeeded(Element&amp; element)
1710 {
1711     if (!element.affectsNextSiblingElementStyle())
1712         return;
1713     auto* parent = element.parentElement();
1714     if (parent &amp;&amp; parent-&gt;styleValidity() &gt;= Style::Validity::SubtreeInvalid)
1715         return;
1716 
1717     invalidateForSiblingCombinators(element.nextElementSibling());
1718 }
1719 
1720 void Element::invalidateStyle()
1721 {
1722     Node::invalidateStyle(Style::Validity::ElementInvalid);
1723     invalidateSiblingsIfNeeded(*this);
1724 }
1725 
1726 void Element::invalidateStyleAndLayerComposition()
1727 {
1728     Node::invalidateStyle(Style::Validity::ElementInvalid, Style::InvalidationMode::RecompositeLayer);
1729     invalidateSiblingsIfNeeded(*this);
1730 }
1731 
1732 void Element::invalidateStyleForSubtree()
1733 {
1734     Node::invalidateStyle(Style::Validity::SubtreeInvalid);
1735     invalidateSiblingsIfNeeded(*this);
1736 }
1737 
1738 void Element::invalidateStyleAndRenderersForSubtree()
1739 {
1740     Node::invalidateStyle(Style::Validity::SubtreeAndRenderersInvalid);
1741     invalidateSiblingsIfNeeded(*this);
1742 }
1743 
1744 void Element::invalidateStyleInternal()
1745 {
1746     Node::invalidateStyle(Style::Validity::ElementInvalid);
1747 }
1748 
1749 void Element::invalidateStyleForSubtreeInternal()
1750 {
1751     Node::invalidateStyle(Style::Validity::SubtreeInvalid);
1752 }
1753 
1754 bool Element::hasDisplayContents() const
1755 {
1756     if (!hasRareData())
1757         return false;
1758 
1759     const RenderStyle* style = elementRareData()-&gt;computedStyle();
1760     return style &amp;&amp; style-&gt;display() == DisplayType::Contents;
1761 }
1762 
1763 void Element::storeDisplayContentsStyle(std::unique_ptr&lt;RenderStyle&gt; style)
1764 {
1765     ASSERT(style &amp;&amp; style-&gt;display() == DisplayType::Contents);
1766     ASSERT(!renderer() || isPseudoElement());
1767     ensureElementRareData().setComputedStyle(WTFMove(style));
1768 }
1769 
1770 // Returns true is the given attribute is an event handler.
1771 // We consider an event handler any attribute that begins with &quot;on&quot;.
1772 // It is a simple solution that has the advantage of not requiring any
1773 // code or configuration change if a new event handler is defined.
1774 
1775 bool Element::isEventHandlerAttribute(const Attribute&amp; attribute) const
1776 {
1777     return attribute.name().namespaceURI().isNull() &amp;&amp; attribute.name().localName().startsWith(&quot;on&quot;);
1778 }
1779 
1780 bool Element::isJavaScriptURLAttribute(const Attribute&amp; attribute) const
1781 {
1782     return isURLAttribute(attribute) &amp;&amp; WTF::protocolIsJavaScript(stripLeadingAndTrailingHTMLSpaces(attribute.value()));
1783 }
1784 
1785 void Element::stripScriptingAttributes(Vector&lt;Attribute&gt;&amp; attributeVector) const
1786 {
1787     attributeVector.removeAllMatching([this](auto&amp; attribute) -&gt; bool {
1788         return this-&gt;isEventHandlerAttribute(attribute)
1789             || this-&gt;isJavaScriptURLAttribute(attribute)
1790             || this-&gt;isHTMLContentAttribute(attribute);
1791     });
1792 }
1793 
1794 void Element::parserSetAttributes(const Vector&lt;Attribute&gt;&amp; attributeVector)
1795 {
1796     ASSERT(!isConnected());
1797     ASSERT(!parentNode());
1798     ASSERT(!m_elementData);
1799 
1800     if (!attributeVector.isEmpty()) {
1801         if (document().sharedObjectPool())
1802             m_elementData = document().sharedObjectPool()-&gt;cachedShareableElementDataWithAttributes(attributeVector);
1803         else
1804             m_elementData = ShareableElementData::createWithAttributes(attributeVector);
1805 
1806     }
1807 
1808     parserDidSetAttributes();
1809 
1810     // Use attributeVector instead of m_elementData because attributeChanged might modify m_elementData.
1811     for (const auto&amp; attribute : attributeVector)
1812         attributeChanged(attribute.name(), nullAtom(), attribute.value(), ModifiedDirectly);
1813 }
1814 
1815 void Element::parserDidSetAttributes()
1816 {
1817 }
1818 
1819 void Element::didMoveToNewDocument(Document&amp; oldDocument, Document&amp; newDocument)
1820 {
1821     ASSERT_WITH_SECURITY_IMPLICATION(&amp;document() == &amp;newDocument);
1822 
1823     if (oldDocument.inQuirksMode() != document().inQuirksMode()) {
1824         // ElementData::m_classNames or ElementData::m_idForStyleResolution need to be updated with the right case.
1825         if (hasID())
1826             attributeChanged(idAttr, nullAtom(), getIdAttribute());
1827         if (hasClass())
1828             attributeChanged(classAttr, nullAtom(), getAttribute(classAttr));
1829     }
1830 
1831     if (UNLIKELY(isDefinedCustomElement()))
1832         CustomElementReactionQueue::enqueueAdoptedCallbackIfNeeded(*this, oldDocument, newDocument);
1833 
1834 #if ENABLE(INTERSECTION_OBSERVER)
1835     if (auto* observerData = intersectionObserverData()) {
1836         for (const auto&amp; observer : observerData-&gt;observers) {
1837             if (observer-&gt;hasObservationTargets()) {
1838                 oldDocument.removeIntersectionObserver(*observer);
1839                 newDocument.addIntersectionObserver(*observer);
1840             }
1841         }
1842     }
1843 #endif
1844 }
1845 
1846 bool Element::hasAttributes() const
1847 {
1848     synchronizeAllAttributes();
1849     return elementData() &amp;&amp; elementData()-&gt;length();
1850 }
1851 
1852 bool Element::hasEquivalentAttributes(const Element&amp; other) const
1853 {
1854     synchronizeAllAttributes();
1855     other.synchronizeAllAttributes();
1856     if (elementData() == other.elementData())
1857         return true;
1858     if (elementData())
1859         return elementData()-&gt;isEquivalent(other.elementData());
1860     if (other.elementData())
1861         return other.elementData()-&gt;isEquivalent(elementData());
1862     return true;
1863 }
1864 
1865 String Element::nodeName() const
1866 {
1867     return m_tagName.toString();
1868 }
1869 
1870 String Element::nodeNamePreservingCase() const
1871 {
1872     return m_tagName.toString();
1873 }
1874 
1875 ExceptionOr&lt;void&gt; Element::setPrefix(const AtomicString&amp; prefix)
1876 {
1877     auto result = checkSetPrefix(prefix);
1878     if (result.hasException())
1879         return result.releaseException();
1880 
1881     m_tagName.setPrefix(prefix.isEmpty() ? nullAtom() : prefix);
1882     return { };
1883 }
1884 
1885 const AtomicString&amp; Element::imageSourceURL() const
1886 {
1887     return attributeWithoutSynchronization(srcAttr);
1888 }
1889 
1890 bool Element::rendererIsNeeded(const RenderStyle&amp; style)
1891 {
1892     return style.display() != DisplayType::None &amp;&amp; style.display() != DisplayType::Contents;
1893 }
1894 
1895 RenderPtr&lt;RenderElement&gt; Element::createElementRenderer(RenderStyle&amp;&amp; style, const RenderTreePosition&amp;)
1896 {
1897     return RenderElement::createFor(*this, WTFMove(style));
1898 }
1899 
1900 Node::InsertedIntoAncestorResult Element::insertedIntoAncestor(InsertionType insertionType, ContainerNode&amp; parentOfInsertedTree)
1901 {
1902     ContainerNode::insertedIntoAncestor(insertionType, parentOfInsertedTree);
1903 
1904 #if ENABLE(FULLSCREEN_API)
1905     if (containsFullScreenElement() &amp;&amp; parentElement() &amp;&amp; !parentElement()-&gt;containsFullScreenElement())
1906         setContainsFullScreenElementOnAncestorsCrossingFrameBoundaries(true);
1907 #endif
1908 
1909     if (parentNode() == &amp;parentOfInsertedTree) {
1910         if (auto* shadowRoot = parentNode()-&gt;shadowRoot())
1911             shadowRoot-&gt;hostChildElementDidChange(*this);
1912     }
1913 
1914     if (!parentOfInsertedTree.isInTreeScope())
1915         return InsertedIntoAncestorResult::Done;
1916 
1917     bool becomeConnected = insertionType.connectedToDocument;
1918     TreeScope* newScope = &amp;parentOfInsertedTree.treeScope();
1919     HTMLDocument* newDocument = becomeConnected &amp;&amp; is&lt;HTMLDocument&gt;(newScope-&gt;documentScope()) ? &amp;downcast&lt;HTMLDocument&gt;(newScope-&gt;documentScope()) : nullptr;
1920     if (!insertionType.treeScopeChanged)
1921         newScope = nullptr;
1922 
1923     const AtomicString&amp; idValue = getIdAttribute();
1924     if (!idValue.isNull()) {
1925         if (newScope)
1926             updateIdForTreeScope(*newScope, nullAtom(), idValue);
1927         if (newDocument)
1928             updateIdForDocument(*newDocument, nullAtom(), idValue, AlwaysUpdateHTMLDocumentNamedItemMaps);
1929     }
1930 
1931     const AtomicString&amp; nameValue = getNameAttribute();
1932     if (!nameValue.isNull()) {
1933         if (newScope)
1934             updateNameForTreeScope(*newScope, nullAtom(), nameValue);
1935         if (newDocument)
1936             updateNameForDocument(*newDocument, nullAtom(), nameValue);
1937     }
1938 
1939     if (newScope &amp;&amp; hasTagName(labelTag)) {
1940         if (newScope-&gt;shouldCacheLabelsByForAttribute())
1941             updateLabel(*newScope, nullAtom(), attributeWithoutSynchronization(forAttr));
1942     }
1943 
1944     if (becomeConnected) {
1945         if (UNLIKELY(isCustomElementUpgradeCandidate())) {
1946             ASSERT(isConnected());
1947             CustomElementReactionQueue::enqueueElementUpgradeIfDefined(*this);
1948         }
1949         if (UNLIKELY(isDefinedCustomElement()))
1950             CustomElementReactionQueue::enqueueConnectedCallbackIfNeeded(*this);
1951     }
1952 
1953     if (UNLIKELY(hasTagName(articleTag) &amp;&amp; newDocument))
1954         newDocument-&gt;registerArticleElement(*this);
1955 
1956     return InsertedIntoAncestorResult::Done;
1957 }
1958 
1959 void Element::removedFromAncestor(RemovalType removalType, ContainerNode&amp; oldParentOfRemovedTree)
1960 {
1961 #if ENABLE(FULLSCREEN_API)
1962     if (containsFullScreenElement())
1963         setContainsFullScreenElementOnAncestorsCrossingFrameBoundaries(false);
1964 #endif
1965 #if ENABLE(POINTER_LOCK)
1966     if (document().page())
1967         document().page()-&gt;pointerLockController().elementRemoved(*this);
1968 #endif
1969 
1970     setSavedLayerScrollPosition(ScrollPosition());
1971 
1972     if (oldParentOfRemovedTree.isInTreeScope()) {
1973         TreeScope* oldScope = &amp;oldParentOfRemovedTree.treeScope();
1974         Document* oldDocument = removalType.disconnectedFromDocument ? &amp;oldScope-&gt;documentScope() : nullptr;
1975         HTMLDocument* oldHTMLDocument = oldDocument &amp;&amp; is&lt;HTMLDocument&gt;(*oldDocument) ? &amp;downcast&lt;HTMLDocument&gt;(*oldDocument) : nullptr;
1976         if (!removalType.treeScopeChanged)
1977             oldScope = nullptr;
1978 
1979         const AtomicString&amp; idValue = getIdAttribute();
1980         if (!idValue.isNull()) {
1981             if (oldScope)
1982                 updateIdForTreeScope(*oldScope, idValue, nullAtom());
1983             if (oldHTMLDocument)
1984                 updateIdForDocument(*oldHTMLDocument, idValue, nullAtom(), AlwaysUpdateHTMLDocumentNamedItemMaps);
1985         }
1986 
1987         const AtomicString&amp; nameValue = getNameAttribute();
1988         if (!nameValue.isNull()) {
1989             if (oldScope)
1990                 updateNameForTreeScope(*oldScope, nameValue, nullAtom());
1991             if (oldHTMLDocument)
1992                 updateNameForDocument(*oldHTMLDocument, nameValue, nullAtom());
1993         }
1994 
1995         if (oldScope &amp;&amp; hasTagName(labelTag)) {
1996             if (oldScope-&gt;shouldCacheLabelsByForAttribute())
1997                 updateLabel(*oldScope, attributeWithoutSynchronization(forAttr), nullAtom());
1998         }
1999 
2000         if (oldDocument) {
2001             if (oldDocument-&gt;cssTarget() == this)
2002                 oldDocument-&gt;setCSSTarget(nullptr);
2003             if (UNLIKELY(hasTagName(articleTag)))
2004                 oldDocument-&gt;unregisterArticleElement(*this);
2005         }
2006 
2007         if (removalType.disconnectedFromDocument &amp;&amp; UNLIKELY(isDefinedCustomElement()))
2008             CustomElementReactionQueue::enqueueDisconnectedCallbackIfNeeded(*this);
2009     }
2010 
2011     if (!parentNode()) {
2012         if (auto* shadowRoot = oldParentOfRemovedTree.shadowRoot())
2013             shadowRoot-&gt;hostChildElementDidChange(*this);
2014     }
2015 
2016     clearBeforePseudoElement();
2017     clearAfterPseudoElement();
2018 
2019     ContainerNode::removedFromAncestor(removalType, oldParentOfRemovedTree);
2020 
2021     if (hasPendingResources())
2022         document().accessSVGExtensions().removeElementFromPendingResources(*this);
2023 
2024     RefPtr&lt;Frame&gt; frame = document().frame();
2025     if (auto* timeline = document().existingTimeline())
2026         timeline-&gt;elementWasRemoved(*this);
2027     if (frame)
2028         frame-&gt;animation().cancelAnimations(*this);
2029 
2030 #if PLATFORM(MAC)
2031     if (frame &amp;&amp; frame-&gt;page())
2032         frame-&gt;page()-&gt;removeLatchingStateForTarget(*this);
2033 #endif
2034 }
2035 
2036 ShadowRoot* Element::shadowRoot() const
2037 {
2038     return hasRareData() ? elementRareData()-&gt;shadowRoot() : nullptr;
2039 }
2040 
2041 void Element::addShadowRoot(Ref&lt;ShadowRoot&gt;&amp;&amp; newShadowRoot)
2042 {
2043     ASSERT(!newShadowRoot-&gt;hasChildNodes());
2044     ASSERT(!shadowRoot());
2045 
2046     ShadowRoot&amp; shadowRoot = newShadowRoot;
2047     {
2048         ScriptDisallowedScope::InMainThread scriptDisallowedScope;
2049         if (renderer())
2050             RenderTreeUpdater::tearDownRenderers(*this);
2051 
2052         ensureElementRareData().setShadowRoot(WTFMove(newShadowRoot));
2053 
2054         shadowRoot.setHost(this);
2055         shadowRoot.setParentTreeScope(treeScope());
2056 
2057 #if !ASSERT_DISABLED
2058         ASSERT(notifyChildNodeInserted(*this, shadowRoot).isEmpty());
2059 #else
2060         notifyChildNodeInserted(*this, shadowRoot);
2061 #endif
2062 
2063         invalidateStyleAndRenderersForSubtree();
2064     }
2065 
2066     if (shadowRoot.mode() == ShadowRootMode::UserAgent)
2067         didAddUserAgentShadowRoot(shadowRoot);
2068 
2069     InspectorInstrumentation::didPushShadowRoot(*this, shadowRoot);
2070 }
2071 
2072 void Element::removeShadowRoot()
2073 {
2074     RefPtr&lt;ShadowRoot&gt; oldRoot = shadowRoot();
2075     if (!oldRoot)
2076         return;
2077 
2078     InspectorInstrumentation::willPopShadowRoot(*this, *oldRoot);
2079     document().adjustFocusedNodeOnNodeRemoval(*oldRoot);
2080 
2081     ASSERT(!oldRoot-&gt;renderer());
2082 
2083     elementRareData()-&gt;clearShadowRoot();
2084 
2085     oldRoot-&gt;setHost(nullptr);
2086     oldRoot-&gt;setParentTreeScope(document());
2087 }
2088 
2089 static bool canAttachAuthorShadowRoot(const Element&amp; element)
2090 {
2091     static NeverDestroyed&lt;HashSet&lt;AtomicString&gt;&gt; tagNames = [] {
2092         static const HTMLQualifiedName* const tagList[] = {
2093             &amp;articleTag.get(),
2094             &amp;asideTag.get(),
2095             &amp;blockquoteTag.get(),
2096             &amp;bodyTag.get(),
2097             &amp;divTag.get(),
2098             &amp;footerTag.get(),
2099             &amp;h1Tag.get(),
2100             &amp;h2Tag.get(),
2101             &amp;h3Tag.get(),
2102             &amp;h4Tag.get(),
2103             &amp;h5Tag.get(),
2104             &amp;h6Tag.get(),
2105             &amp;headerTag.get(),
2106             &amp;navTag.get(),
2107             &amp;pTag.get(),
2108             &amp;sectionTag.get(),
2109             &amp;spanTag.get()
2110         };
2111         HashSet&lt;AtomicString&gt; set;
2112         for (auto&amp; name : tagList)
2113             set.add(name-&gt;localName());
2114         return set;
2115     }();
2116 
2117     if (!is&lt;HTMLElement&gt;(element))
2118         return false;
2119 
2120     const auto&amp; localName = element.localName();
2121     return tagNames.get().contains(localName) || Document::validateCustomElementName(localName) == CustomElementNameValidationStatus::Valid;
2122 }
2123 
2124 ExceptionOr&lt;ShadowRoot&amp;&gt; Element::attachShadow(const ShadowRootInit&amp; init)
2125 {
2126     if (!canAttachAuthorShadowRoot(*this))
2127         return Exception { NotSupportedError };
2128     if (shadowRoot())
2129         return Exception { InvalidStateError };
2130     if (init.mode == ShadowRootMode::UserAgent)
2131         return Exception { TypeError };
2132     auto shadow = ShadowRoot::create(document(), init.mode);
2133     auto&amp; result = shadow.get();
2134     addShadowRoot(WTFMove(shadow));
2135     return result;
2136 }
2137 
2138 ShadowRoot* Element::shadowRootForBindings(JSC::ExecState&amp; state) const
2139 {
2140     auto* shadow = shadowRoot();
2141     if (!shadow)
2142         return nullptr;
2143     if (shadow-&gt;mode() == ShadowRootMode::Open)
2144         return shadow;
2145     if (JSC::jsCast&lt;JSDOMGlobalObject*&gt;(state.lexicalGlobalObject())-&gt;world().shadowRootIsAlwaysOpen())
2146         return shadow;
2147     return nullptr;
2148 }
2149 
2150 RefPtr&lt;ShadowRoot&gt; Element::userAgentShadowRoot() const
2151 {
2152     ASSERT(!shadowRoot() || shadowRoot()-&gt;mode() == ShadowRootMode::UserAgent);
2153     return shadowRoot();
2154 }
2155 
2156 ShadowRoot&amp; Element::ensureUserAgentShadowRoot()
2157 {
2158     if (auto shadow = userAgentShadowRoot())
2159         return *shadow;
2160     auto newShadow = ShadowRoot::create(document(), ShadowRootMode::UserAgent);
2161     ShadowRoot&amp; shadow = newShadow;
2162     addShadowRoot(WTFMove(newShadow));
2163     return shadow;
2164 }
2165 
2166 void Element::setIsDefinedCustomElement(JSCustomElementInterface&amp; elementInterface)
2167 {
2168     clearFlag(IsEditingTextOrUndefinedCustomElementFlag);
2169     setFlag(IsCustomElement);
2170     auto&amp; data = ensureElementRareData();
2171     if (!data.customElementReactionQueue())
2172         data.setCustomElementReactionQueue(std::make_unique&lt;CustomElementReactionQueue&gt;(elementInterface));
2173     invalidateStyleForSubtree();
2174     InspectorInstrumentation::didChangeCustomElementState(*this);
2175 }
2176 
2177 void Element::setIsFailedCustomElement(JSCustomElementInterface&amp;)
2178 {
2179     ASSERT(isUndefinedCustomElement());
2180     ASSERT(getFlag(IsEditingTextOrUndefinedCustomElementFlag));
2181     clearFlag(IsCustomElement);
2182 
2183     if (hasRareData()) {
2184         // Clear the queue instead of deleting it since this function can be called inside CustomElementReactionQueue::invokeAll during upgrades.
2185         if (auto* queue = elementRareData()-&gt;customElementReactionQueue())
2186             queue-&gt;clear();
2187     }
2188     InspectorInstrumentation::didChangeCustomElementState(*this);
2189 }
2190 
2191 void Element::setIsCustomElementUpgradeCandidate()
2192 {
2193     ASSERT(!getFlag(IsCustomElement));
2194     setFlag(IsCustomElement);
2195     setFlag(IsEditingTextOrUndefinedCustomElementFlag);
2196     InspectorInstrumentation::didChangeCustomElementState(*this);
2197 }
2198 
2199 void Element::enqueueToUpgrade(JSCustomElementInterface&amp; elementInterface)
2200 {
2201     ASSERT(!isDefinedCustomElement() &amp;&amp; !isFailedCustomElement());
2202     setFlag(IsCustomElement);
2203     setFlag(IsEditingTextOrUndefinedCustomElementFlag);
2204     InspectorInstrumentation::didChangeCustomElementState(*this);
2205 
2206     auto&amp; data = ensureElementRareData();
2207     bool alreadyScheduledToUpgrade = data.customElementReactionQueue();
2208     if (!alreadyScheduledToUpgrade)
2209         data.setCustomElementReactionQueue(std::make_unique&lt;CustomElementReactionQueue&gt;(elementInterface));
2210     data.customElementReactionQueue()-&gt;enqueueElementUpgrade(*this, alreadyScheduledToUpgrade);
2211 }
2212 
2213 CustomElementReactionQueue* Element::reactionQueue() const
2214 {
2215     ASSERT(isDefinedCustomElement() || isCustomElementUpgradeCandidate());
2216     if (!hasRareData())
2217         return nullptr;
2218     return elementRareData()-&gt;customElementReactionQueue();
2219 }
2220 
2221 const AtomicString&amp; Element::shadowPseudoId() const
2222 {
2223     return pseudo();
2224 }
2225 
2226 bool Element::childTypeAllowed(NodeType type) const
2227 {
2228     switch (type) {
2229     case ELEMENT_NODE:
2230     case TEXT_NODE:
2231     case COMMENT_NODE:
2232     case PROCESSING_INSTRUCTION_NODE:
2233     case CDATA_SECTION_NODE:
2234         return true;
2235     default:
2236         break;
2237     }
2238     return false;
2239 }
2240 
2241 static void checkForEmptyStyleChange(Element&amp; element)
2242 {
2243     if (element.styleAffectedByEmpty()) {
2244         auto* style = element.renderStyle();
2245         if (!style || (!style-&gt;emptyState() || element.hasChildNodes()))
2246             element.invalidateStyleForSubtree();
2247     }
2248 }
2249 
2250 
2251 static void invalidateForForwardPositionalRules(Element&amp; parent, Element* elementAfterChange)
2252 {
2253     bool childrenAffected = parent.childrenAffectedByForwardPositionalRules();
2254     bool descendantsAffected = parent.descendantsAffectedByForwardPositionalRules();
2255 
2256     if (!childrenAffected &amp;&amp; !descendantsAffected)
2257         return;
2258 
2259     for (auto* sibling = elementAfterChange; sibling; sibling = sibling-&gt;nextElementSibling()) {
2260         if (childrenAffected)
2261             sibling-&gt;invalidateStyleInternal();
2262         if (descendantsAffected) {
2263             for (auto* siblingChild = sibling-&gt;firstElementChild(); siblingChild; siblingChild = siblingChild-&gt;nextElementSibling())
2264                 siblingChild-&gt;invalidateStyleForSubtreeInternal();
2265         }
2266     }
2267 }
2268 
2269 static void invalidateForBackwardPositionalRules(Element&amp; parent, Element* elementBeforeChange)
2270 {
2271     bool childrenAffected = parent.childrenAffectedByBackwardPositionalRules();
2272     bool descendantsAffected = parent.descendantsAffectedByBackwardPositionalRules();
2273 
2274     if (!childrenAffected &amp;&amp; !descendantsAffected)
2275         return;
2276 
2277     for (auto* sibling = elementBeforeChange; sibling; sibling = sibling-&gt;previousElementSibling()) {
2278         if (childrenAffected)
2279             sibling-&gt;invalidateStyleInternal();
2280         if (descendantsAffected) {
2281             for (auto* siblingChild = sibling-&gt;firstElementChild(); siblingChild; siblingChild = siblingChild-&gt;nextElementSibling())
2282                 siblingChild-&gt;invalidateStyleForSubtreeInternal();
2283         }
2284     }
2285 }
2286 
2287 enum SiblingCheckType { FinishedParsingChildren, SiblingElementRemoved, Other };
2288 
2289 static void checkForSiblingStyleChanges(Element&amp; parent, SiblingCheckType checkType, Element* elementBeforeChange, Element* elementAfterChange)
2290 {
2291     // :empty selector.
2292     checkForEmptyStyleChange(parent);
2293 
2294     if (parent.styleValidity() &gt;= Style::Validity::SubtreeInvalid)
2295         return;
2296 
2297     // :first-child.  In the parser callback case, we don&#39;t have to check anything, since we were right the first time.
2298     // In the DOM case, we only need to do something if |afterChange| is not 0.
2299     // |afterChange| is 0 in the parser case, so it works out that we&#39;ll skip this block.
2300     if (parent.childrenAffectedByFirstChildRules() &amp;&amp; elementAfterChange) {
2301         // Find our new first child.
2302         RefPtr&lt;Element&gt; newFirstElement = ElementTraversal::firstChild(parent);
2303         // Find the first element node following |afterChange|
2304 
2305         // This is the insert/append case.
2306         if (newFirstElement != elementAfterChange) {
2307             auto* style = elementAfterChange-&gt;renderStyle();
2308             if (!style || style-&gt;firstChildState())
2309                 elementAfterChange-&gt;invalidateStyleForSubtreeInternal();
2310         }
2311 
2312         // We also have to handle node removal.
2313         if (checkType == SiblingElementRemoved &amp;&amp; newFirstElement == elementAfterChange &amp;&amp; newFirstElement) {
2314             auto* style = newFirstElement-&gt;renderStyle();
2315             if (!style || !style-&gt;firstChildState())
2316                 newFirstElement-&gt;invalidateStyleForSubtreeInternal();
2317         }
2318     }
2319 
2320     // :last-child.  In the parser callback case, we don&#39;t have to check anything, since we were right the first time.
2321     // In the DOM case, we only need to do something if |afterChange| is not 0.
2322     if (parent.childrenAffectedByLastChildRules() &amp;&amp; elementBeforeChange) {
2323         // Find our new last child.
2324         RefPtr&lt;Element&gt; newLastElement = ElementTraversal::lastChild(parent);
2325 
2326         if (newLastElement != elementBeforeChange) {
2327             auto* style = elementBeforeChange-&gt;renderStyle();
2328             if (!style || style-&gt;lastChildState())
2329                 elementBeforeChange-&gt;invalidateStyleForSubtreeInternal();
2330         }
2331 
2332         // We also have to handle node removal.  The parser callback case is similar to node removal as well in that we need to change the last child
2333         // to match now.
2334         if ((checkType == SiblingElementRemoved || checkType == FinishedParsingChildren) &amp;&amp; newLastElement == elementBeforeChange &amp;&amp; newLastElement) {
2335             auto* style = newLastElement-&gt;renderStyle();
2336             if (!style || !style-&gt;lastChildState())
2337                 newLastElement-&gt;invalidateStyleForSubtreeInternal();
2338         }
2339     }
2340 
2341     invalidateForSiblingCombinators(elementAfterChange);
2342 
2343     invalidateForForwardPositionalRules(parent, elementAfterChange);
2344     invalidateForBackwardPositionalRules(parent, elementBeforeChange);
2345 }
2346 
2347 void Element::childrenChanged(const ChildChange&amp; change)
2348 {
2349     ContainerNode::childrenChanged(change);
2350     if (change.source == ChildChangeSource::Parser)
2351         checkForEmptyStyleChange(*this);
2352     else {
2353         SiblingCheckType checkType = change.type == ElementRemoved ? SiblingElementRemoved : Other;
2354         checkForSiblingStyleChanges(*this, checkType, change.previousSiblingElement, change.nextSiblingElement);
2355     }
2356 
2357     if (ShadowRoot* shadowRoot = this-&gt;shadowRoot()) {
2358         switch (change.type) {
2359         case ElementInserted:
2360         case ElementRemoved:
2361             // For elements, we notify shadowRoot in Element::insertedIntoAncestor and Element::removedFromAncestor.
2362             break;
2363         case AllChildrenRemoved:
2364         case AllChildrenReplaced:
2365             shadowRoot-&gt;didRemoveAllChildrenOfShadowHost();
2366             break;
2367         case TextInserted:
2368         case TextRemoved:
2369         case TextChanged:
2370             shadowRoot-&gt;didChangeDefaultSlot();
2371             break;
2372         case NonContentsChildInserted:
2373         case NonContentsChildRemoved:
2374             break;
2375         }
2376     }
2377 }
2378 
2379 void Element::setAttributeEventListener(const AtomicString&amp; eventType, const QualifiedName&amp; attributeName, const AtomicString&amp; attributeValue)
2380 {
2381     setAttributeEventListener(eventType, JSLazyEventListener::create(*this, attributeName, attributeValue), mainThreadNormalWorld());
2382 }
2383 
2384 void Element::removeAllEventListeners()
2385 {
2386     ContainerNode::removeAllEventListeners();
2387     if (ShadowRoot* shadowRoot = this-&gt;shadowRoot())
2388         shadowRoot-&gt;removeAllEventListeners();
2389 }
2390 
2391 void Element::beginParsingChildren()
2392 {
2393     clearIsParsingChildrenFinished();
2394 }
2395 
2396 void Element::finishParsingChildren()
2397 {
2398     ContainerNode::finishParsingChildren();
2399     setIsParsingChildrenFinished();
2400     checkForSiblingStyleChanges(*this, FinishedParsingChildren, ElementTraversal::lastChild(*this), nullptr);
2401 }
2402 
2403 #if ENABLE(TREE_DEBUGGING)
2404 void Element::formatForDebugger(char* buffer, unsigned length) const
2405 {
2406     StringBuilder result;
2407     String s;
2408 
2409     result.append(nodeName());
2410 
2411     s = getIdAttribute();
2412     if (s.length() &gt; 0) {
2413         if (result.length() &gt; 0)
2414             result.appendLiteral(&quot;; &quot;);
2415         result.appendLiteral(&quot;id=&quot;);
2416         result.append(s);
2417     }
2418 
2419     s = getAttribute(classAttr);
2420     if (s.length() &gt; 0) {
2421         if (result.length() &gt; 0)
2422             result.appendLiteral(&quot;; &quot;);
2423         result.appendLiteral(&quot;class=&quot;);
2424         result.append(s);
2425     }
2426 
2427     strncpy(buffer, result.toString().utf8().data(), length - 1);
2428 }
2429 #endif
2430 
2431 const Vector&lt;RefPtr&lt;Attr&gt;&gt;&amp; Element::attrNodeList()
2432 {
2433     ASSERT(hasSyntheticAttrChildNodes());
2434     return *attrNodeListForElement(*this);
2435 }
2436 
2437 void Element::attachAttributeNodeIfNeeded(Attr&amp; attrNode)
2438 {
2439     ASSERT(!attrNode.ownerElement() || attrNode.ownerElement() == this);
2440     if (attrNode.ownerElement() == this)
2441         return;
2442 
2443     ScriptDisallowedScope::InMainThread scriptDisallowedScope;
2444 
2445     attrNode.attachToElement(*this);
2446     ensureAttrNodeListForElement(*this).append(&amp;attrNode);
2447 }
2448 
2449 ExceptionOr&lt;RefPtr&lt;Attr&gt;&gt; Element::setAttributeNode(Attr&amp; attrNode)
2450 {
2451     RefPtr&lt;Attr&gt; oldAttrNode = attrIfExists(attrNode.localName(), shouldIgnoreAttributeCase(*this));
2452     if (oldAttrNode.get() == &amp;attrNode)
2453         return WTFMove(oldAttrNode);
2454 
2455     // InUseAttributeError: Raised if node is an Attr that is already an attribute of another Element object.
2456     // The DOM user must explicitly clone Attr nodes to re-use them in other elements.
2457     if (attrNode.ownerElement() &amp;&amp; attrNode.ownerElement() != this)
2458         return Exception { InUseAttributeError };
2459 
2460     {
2461         ScriptDisallowedScope::InMainThread scriptDisallowedScope;
2462         synchronizeAllAttributes();
2463     }
2464 
2465     auto&amp; elementData = ensureUniqueElementData();
2466 
2467     auto existingAttributeIndex = elementData.findAttributeIndexByName(attrNode.localName(), shouldIgnoreAttributeCase(*this));
2468 
2469     // Attr::value() will return its &#39;m_standaloneValue&#39; member any time its Element is set to nullptr. We need to cache this value
2470     // before making changes to attrNode&#39;s Element connections.
2471     auto attrNodeValue = attrNode.value();
2472 
2473     if (existingAttributeIndex == ElementData::attributeNotFound) {
2474         attachAttributeNodeIfNeeded(attrNode);
2475         setAttributeInternal(elementData.findAttributeIndexByName(attrNode.qualifiedName()), attrNode.qualifiedName(), attrNodeValue, NotInSynchronizationOfLazyAttribute);
2476     } else {
2477         const Attribute&amp; attribute = attributeAt(existingAttributeIndex);
2478         if (oldAttrNode)
2479             detachAttrNodeFromElementWithValue(oldAttrNode.get(), attribute.value());
2480         else
2481             oldAttrNode = Attr::create(document(), attrNode.qualifiedName(), attribute.value());
2482 
2483         attachAttributeNodeIfNeeded(attrNode);
2484 
2485         if (attribute.name().matches(attrNode.qualifiedName()))
2486             setAttributeInternal(existingAttributeIndex, attrNode.qualifiedName(), attrNodeValue, NotInSynchronizationOfLazyAttribute);
2487         else {
2488             removeAttributeInternal(existingAttributeIndex, NotInSynchronizationOfLazyAttribute);
2489             setAttributeInternal(ensureUniqueElementData().findAttributeIndexByName(attrNode.qualifiedName()), attrNode.qualifiedName(), attrNodeValue, NotInSynchronizationOfLazyAttribute);
2490         }
2491     }
2492 
2493     return WTFMove(oldAttrNode);
2494 }
2495 
2496 ExceptionOr&lt;RefPtr&lt;Attr&gt;&gt; Element::setAttributeNodeNS(Attr&amp; attrNode)
2497 {
2498     RefPtr&lt;Attr&gt; oldAttrNode = attrIfExists(attrNode.qualifiedName());
2499     if (oldAttrNode.get() == &amp;attrNode)
2500         return WTFMove(oldAttrNode);
2501 
2502     // InUseAttributeError: Raised if node is an Attr that is already an attribute of another Element object.
2503     // The DOM user must explicitly clone Attr nodes to re-use them in other elements.
2504     if (attrNode.ownerElement() &amp;&amp; attrNode.ownerElement() != this)
2505         return Exception { InUseAttributeError };
2506 
2507     // Attr::value() will return its &#39;m_standaloneValue&#39; member any time its Element is set to nullptr. We need to cache this value
2508     // before making changes to attrNode&#39;s Element connections.
2509     auto attrNodeValue = attrNode.value();
2510     unsigned index = 0;
2511     {
2512         ScriptDisallowedScope::InMainThread scriptDisallowedScope;
2513         synchronizeAllAttributes();
2514         auto&amp; elementData = ensureUniqueElementData();
2515 
2516         index = elementData.findAttributeIndexByName(attrNode.qualifiedName());
2517 
2518         if (index != ElementData::attributeNotFound) {
2519             if (oldAttrNode)
2520                 detachAttrNodeFromElementWithValue(oldAttrNode.get(), elementData.attributeAt(index).value());
2521             else
2522                 oldAttrNode = Attr::create(document(), attrNode.qualifiedName(), elementData.attributeAt(index).value());
2523         }
2524     }
2525 
2526     attachAttributeNodeIfNeeded(attrNode);
2527     setAttributeInternal(index, attrNode.qualifiedName(), attrNodeValue, NotInSynchronizationOfLazyAttribute);
2528 
2529     return WTFMove(oldAttrNode);
2530 }
2531 
2532 ExceptionOr&lt;Ref&lt;Attr&gt;&gt; Element::removeAttributeNode(Attr&amp; attr)
2533 {
2534     if (attr.ownerElement() != this)
2535         return Exception { NotFoundError };
2536 
2537     ASSERT(&amp;document() == &amp;attr.document());
2538 
2539     synchronizeAllAttributes();
2540 
2541     if (!m_elementData)
2542         return Exception { NotFoundError };
2543 
2544     auto existingAttributeIndex = m_elementData-&gt;findAttributeIndexByName(attr.qualifiedName());
2545     if (existingAttributeIndex == ElementData::attributeNotFound)
2546         return Exception { NotFoundError };
2547 
2548     Ref&lt;Attr&gt; oldAttrNode { attr };
2549 
2550     detachAttrNodeFromElementWithValue(&amp;attr, m_elementData-&gt;attributeAt(existingAttributeIndex).value());
2551     removeAttributeInternal(existingAttributeIndex, NotInSynchronizationOfLazyAttribute);
2552 
2553     return WTFMove(oldAttrNode);
2554 }
2555 
2556 ExceptionOr&lt;QualifiedName&gt; Element::parseAttributeName(const AtomicString&amp; namespaceURI, const AtomicString&amp; qualifiedName)
2557 {
2558     auto parseResult = Document::parseQualifiedName(namespaceURI, qualifiedName);
2559     if (parseResult.hasException())
2560         return parseResult.releaseException();
2561     QualifiedName parsedAttributeName { parseResult.releaseReturnValue() };
2562     if (!Document::hasValidNamespaceForAttributes(parsedAttributeName))
2563         return Exception { NamespaceError };
2564     return WTFMove(parsedAttributeName);
2565 }
2566 
2567 ExceptionOr&lt;void&gt; Element::setAttributeNS(const AtomicString&amp; namespaceURI, const AtomicString&amp; qualifiedName, const AtomicString&amp; value)
2568 {
2569     auto result = parseAttributeName(namespaceURI, qualifiedName);
2570     if (result.hasException())
2571         return result.releaseException();
2572     setAttribute(result.releaseReturnValue(), value);
2573     return { };
2574 }
2575 
2576 void Element::removeAttributeInternal(unsigned index, SynchronizationOfLazyAttribute inSynchronizationOfLazyAttribute)
2577 {
2578     ASSERT_WITH_SECURITY_IMPLICATION(index &lt; attributeCount());
2579 
2580     UniqueElementData&amp; elementData = ensureUniqueElementData();
2581 
2582     QualifiedName name = elementData.attributeAt(index).name();
2583     AtomicString valueBeingRemoved = elementData.attributeAt(index).value();
2584 
2585     if (RefPtr&lt;Attr&gt; attrNode = attrIfExists(name))
2586         detachAttrNodeFromElementWithValue(attrNode.get(), elementData.attributeAt(index).value());
2587 
2588     if (inSynchronizationOfLazyAttribute) {
2589         elementData.removeAttribute(index);
2590         return;
2591     }
2592 
2593     ASSERT(!valueBeingRemoved.isNull());
2594     willModifyAttribute(name, valueBeingRemoved, nullAtom());
2595     {
2596         Style::AttributeChangeInvalidation styleInvalidation(*this, name, valueBeingRemoved, nullAtom());
2597         elementData.removeAttribute(index);
2598     }
2599 
2600     didRemoveAttribute(name, valueBeingRemoved);
2601 }
2602 
2603 void Element::addAttributeInternal(const QualifiedName&amp; name, const AtomicString&amp; value, SynchronizationOfLazyAttribute inSynchronizationOfLazyAttribute)
2604 {
2605     if (inSynchronizationOfLazyAttribute) {
2606         ensureUniqueElementData().addAttribute(name, value);
2607         return;
2608     }
2609 
2610     willModifyAttribute(name, nullAtom(), value);
2611     {
2612         Style::AttributeChangeInvalidation styleInvalidation(*this, name, nullAtom(), value);
2613         ensureUniqueElementData().addAttribute(name, value);
2614     }
2615     didAddAttribute(name, value);
2616 }
2617 
2618 bool Element::removeAttribute(const AtomicString&amp; qualifiedName)
2619 {
2620     if (!elementData())
2621         return false;
2622 
2623     AtomicString caseAdjustedQualifiedName = shouldIgnoreAttributeCase(*this) ? qualifiedName.convertToASCIILowercase() : qualifiedName;
2624     unsigned index = elementData()-&gt;findAttributeIndexByName(caseAdjustedQualifiedName, false);
2625     if (index == ElementData::attributeNotFound) {
2626         if (UNLIKELY(caseAdjustedQualifiedName == styleAttr) &amp;&amp; elementData()-&gt;styleAttributeIsDirty() &amp;&amp; is&lt;StyledElement&gt;(*this))
2627             downcast&lt;StyledElement&gt;(*this).removeAllInlineStyleProperties();
2628         return false;
2629     }
2630 
2631     removeAttributeInternal(index, NotInSynchronizationOfLazyAttribute);
2632     return true;
2633 }
2634 
2635 bool Element::removeAttributeNS(const AtomicString&amp; namespaceURI, const AtomicString&amp; localName)
2636 {
2637     return removeAttribute(QualifiedName(nullAtom(), localName, namespaceURI));
2638 }
2639 
2640 RefPtr&lt;Attr&gt; Element::getAttributeNode(const AtomicString&amp; qualifiedName)
2641 {
2642     if (!elementData())
2643         return nullptr;
2644     synchronizeAttribute(qualifiedName);
2645     const Attribute* attribute = elementData()-&gt;findAttributeByName(qualifiedName, shouldIgnoreAttributeCase(*this));
2646     if (!attribute)
2647         return nullptr;
2648     return ensureAttr(attribute-&gt;name());
2649 }
2650 
2651 RefPtr&lt;Attr&gt; Element::getAttributeNodeNS(const AtomicString&amp; namespaceURI, const AtomicString&amp; localName)
2652 {
2653     if (!elementData())
2654         return 0;
2655     QualifiedName qName(nullAtom(), localName, namespaceURI);
2656     synchronizeAttribute(qName);
2657     const Attribute* attribute = elementData()-&gt;findAttributeByName(qName);
2658     if (!attribute)
2659         return 0;
2660     return ensureAttr(attribute-&gt;name());
2661 }
2662 
2663 bool Element::hasAttribute(const AtomicString&amp; qualifiedName) const
2664 {
2665     if (!elementData())
2666         return false;
2667     synchronizeAttribute(qualifiedName);
2668     return elementData()-&gt;findAttributeByName(qualifiedName, shouldIgnoreAttributeCase(*this));
2669 }
2670 
2671 bool Element::hasAttributeNS(const AtomicString&amp; namespaceURI, const AtomicString&amp; localName) const
2672 {
2673     if (!elementData())
2674         return false;
2675     QualifiedName qName(nullAtom(), localName, namespaceURI);
2676     synchronizeAttribute(qName);
2677     return elementData()-&gt;findAttributeByName(qName);
2678 }
2679 
2680 void Element::focus(bool restorePreviousSelection, FocusDirection direction)
2681 {
2682     if (!isConnected())
2683         return;
2684 
2685     if (document().focusedElement() == this) {
2686         if (document().page())
2687             document().page()-&gt;chrome().client().elementDidRefocus(*this);
2688 
2689         return;
2690     }
2691 
2692     // If the stylesheets have already been loaded we can reliably check isFocusable.
2693     // If not, we continue and set the focused node on the focus controller below so
2694     // that it can be updated soon after attach.
2695     if (document().haveStylesheetsLoaded()) {
2696         document().updateStyleIfNeeded();
2697         if (!isFocusable())
2698             return;
2699     }
2700 
2701     if (!supportsFocus())
2702         return;
2703 
2704     RefPtr&lt;Node&gt; protect;
2705     if (Page* page = document().page()) {
2706         // Focus and change event handlers can cause us to lose our last ref.
2707         // If a focus event handler changes the focus to a different node it
2708         // does not make sense to continue and update appearence.
2709         protect = this;
2710         if (!page-&gt;focusController().setFocusedElement(this, *document().frame(), direction))
2711             return;
2712     }
2713 
2714     SelectionRevealMode revealMode = SelectionRevealMode::Reveal;
2715 #if PLATFORM(IOS_FAMILY)
2716     // Focusing a form element triggers animation in UIKit to scroll to the right position.
2717     // Calling updateFocusAppearance() would generate an unnecessary call to ScrollView::setScrollPosition(),
2718     // which would jump us around during this animation. See &lt;rdar://problem/6699741&gt;.
2719     bool isFormControl = is&lt;HTMLFormControlElement&gt;(*this);
2720     if (isFormControl)
2721         revealMode = SelectionRevealMode::RevealUpToMainFrame;
2722 #endif
2723 
2724     auto target = focusAppearanceUpdateTarget();
2725     if (!target)
2726         return;
2727 
2728     target-&gt;updateFocusAppearance(restorePreviousSelection ? SelectionRestorationMode::Restore : SelectionRestorationMode::SetDefault, revealMode);
2729 }
2730 
2731 RefPtr&lt;Element&gt; Element::focusAppearanceUpdateTarget()
2732 {
2733     return this;
2734 }
2735 
2736 void Element::updateFocusAppearance(SelectionRestorationMode, SelectionRevealMode revealMode)
2737 {
2738     if (isRootEditableElement()) {
2739         // Keep frame alive in this method, since setSelection() may release the last reference to |frame|.
2740         RefPtr&lt;Frame&gt; frame = document().frame();
2741         if (!frame)
2742             return;
2743 
2744         // When focusing an editable element in an iframe, don&#39;t reset the selection if it already contains a selection.
2745         if (this == frame-&gt;selection().selection().rootEditableElement())
2746             return;
2747 
2748         // FIXME: We should restore the previous selection if there is one.
2749         VisibleSelection newSelection = VisibleSelection(firstPositionInOrBeforeNode(this), DOWNSTREAM);
2750 
2751         if (frame-&gt;selection().shouldChangeSelection(newSelection)) {
2752             frame-&gt;selection().setSelection(newSelection, FrameSelection::defaultSetSelectionOptions(), Element::defaultFocusTextStateChangeIntent());
2753             frame-&gt;selection().revealSelection(revealMode);
2754         }
2755     }
2756 
2757     if (RefPtr&lt;FrameView&gt; view = document().view())
2758         view-&gt;scheduleScrollToFocusedElement(revealMode);
2759 }
2760 
2761 void Element::blur()
2762 {
2763     if (treeScope().focusedElementInScope() == this) {
2764         if (Frame* frame = document().frame())
2765             frame-&gt;page()-&gt;focusController().setFocusedElement(nullptr, *frame);
2766         else
2767             document().setFocusedElement(nullptr);
2768     }
2769 }
2770 
2771 void Element::dispatchFocusInEvent(const AtomicString&amp; eventType, RefPtr&lt;Element&gt;&amp;&amp; oldFocusedElement)
2772 {
2773     ASSERT_WITH_SECURITY_IMPLICATION(ScriptDisallowedScope::InMainThread::isScriptAllowed());
2774     ASSERT(eventType == eventNames().focusinEvent || eventType == eventNames().DOMFocusInEvent);
2775     dispatchScopedEvent(FocusEvent::create(eventType, Event::CanBubble::Yes, Event::IsCancelable::No, document().windowProxy(), 0, WTFMove(oldFocusedElement)));
2776 }
2777 
2778 void Element::dispatchFocusOutEvent(const AtomicString&amp; eventType, RefPtr&lt;Element&gt;&amp;&amp; newFocusedElement)
2779 {
2780     ASSERT_WITH_SECURITY_IMPLICATION(ScriptDisallowedScope::InMainThread::isScriptAllowed());
2781     ASSERT(eventType == eventNames().focusoutEvent || eventType == eventNames().DOMFocusOutEvent);
2782     dispatchScopedEvent(FocusEvent::create(eventType, Event::CanBubble::Yes, Event::IsCancelable::No, document().windowProxy(), 0, WTFMove(newFocusedElement)));
2783 }
2784 
2785 void Element::dispatchFocusEvent(RefPtr&lt;Element&gt;&amp;&amp; oldFocusedElement, FocusDirection)
2786 {
2787     if (auto* page = document().page())
2788         page-&gt;chrome().client().elementDidFocus(*this);
2789     dispatchEvent(FocusEvent::create(eventNames().focusEvent, Event::CanBubble::No, Event::IsCancelable::No, document().windowProxy(), 0, WTFMove(oldFocusedElement)));
2790 }
2791 
2792 void Element::dispatchBlurEvent(RefPtr&lt;Element&gt;&amp;&amp; newFocusedElement)
2793 {
2794     if (auto* page = document().page())
2795         page-&gt;chrome().client().elementDidBlur(*this);
2796     dispatchEvent(FocusEvent::create(eventNames().blurEvent, Event::CanBubble::No, Event::IsCancelable::No, document().windowProxy(), 0, WTFMove(newFocusedElement)));
2797 }
2798 
2799 void Element::dispatchWebKitImageReadyEventForTesting()
2800 {
2801     if (document().settings().webkitImageReadyEventEnabled())
2802         dispatchEvent(Event::create(&quot;webkitImageFrameReady&quot;, Event::CanBubble::Yes, Event::IsCancelable::Yes));
2803 }
2804 
2805 bool Element::dispatchMouseForceWillBegin()
2806 {
2807 #if ENABLE(MOUSE_FORCE_EVENTS)
2808     if (!document().hasListenerType(Document::FORCEWILLBEGIN_LISTENER))
2809         return false;
2810 
2811     Frame* frame = document().frame();
2812     if (!frame)
2813         return false;
2814 
2815     PlatformMouseEvent platformMouseEvent { frame-&gt;eventHandler().lastKnownMousePosition(), frame-&gt;eventHandler().lastKnownMouseGlobalPosition(), NoButton, PlatformEvent::NoType, 1, false, false, false, false, WallTime::now(), ForceAtClick, NoTap };
2816     auto mouseForceWillBeginEvent = MouseEvent::create(eventNames().webkitmouseforcewillbeginEvent, document().windowProxy(), platformMouseEvent, 0, nullptr);
2817     mouseForceWillBeginEvent-&gt;setTarget(this);
2818     dispatchEvent(mouseForceWillBeginEvent);
2819 
2820     if (mouseForceWillBeginEvent-&gt;defaultHandled() || mouseForceWillBeginEvent-&gt;defaultPrevented())
2821         return true;
2822 #endif
2823 
2824     return false;
2825 }
2826 
2827 ExceptionOr&lt;void&gt; Element::mergeWithNextTextNode(Text&amp; node)
2828 {
2829     auto* next = node.nextSibling();
2830     if (!is&lt;Text&gt;(next))
2831         return { };
2832     Ref&lt;Text&gt; textNext { downcast&lt;Text&gt;(*next) };
2833     node.appendData(textNext-&gt;data());
2834     return textNext-&gt;remove();
2835 }
2836 
2837 String Element::innerHTML() const
2838 {
2839     return serializeFragment(*this, SerializedNodes::SubtreesOfChildren);
2840 }
2841 
2842 String Element::outerHTML() const
2843 {
2844     return serializeFragment(*this, SerializedNodes::SubtreeIncludingNode);
2845 }
2846 
2847 ExceptionOr&lt;void&gt; Element::setOuterHTML(const String&amp; html)
2848 {
2849     auto* parentElement = this-&gt;parentElement();
2850     if (!is&lt;HTMLElement&gt;(parentElement))
2851         return Exception { NoModificationAllowedError };
2852 
2853     Ref&lt;HTMLElement&gt; parent = downcast&lt;HTMLElement&gt;(*parentElement);
2854     RefPtr&lt;Node&gt; prev = previousSibling();
2855     RefPtr&lt;Node&gt; next = nextSibling();
2856 
2857     auto fragment = createFragmentForInnerOuterHTML(parent, html, AllowScriptingContent);
2858     if (fragment.hasException())
2859         return fragment.releaseException();
2860 
2861     auto replaceResult = parent-&gt;replaceChild(fragment.releaseReturnValue().get(), *this);
2862     if (replaceResult.hasException())
2863         return replaceResult.releaseException();
2864 
2865     RefPtr&lt;Node&gt; node = next ? next-&gt;previousSibling() : nullptr;
2866     if (is&lt;Text&gt;(node)) {
2867         auto result = mergeWithNextTextNode(downcast&lt;Text&gt;(*node));
2868         if (result.hasException())
2869             return result.releaseException();
2870     }
2871     if (is&lt;Text&gt;(prev)) {
2872         auto result = mergeWithNextTextNode(downcast&lt;Text&gt;(*prev));
2873         if (result.hasException())
2874             return result.releaseException();
2875     }
2876     return { };
2877 }
2878 
2879 
2880 ExceptionOr&lt;void&gt; Element::setInnerHTML(const String&amp; html)
2881 {
2882     auto fragment = createFragmentForInnerOuterHTML(*this, html, AllowScriptingContent);
2883     if (fragment.hasException())
2884         return fragment.releaseException();
2885 
2886     ContainerNode* container;
2887     if (!is&lt;HTMLTemplateElement&gt;(*this))
2888         container = this;
2889     else
2890         container = &amp;downcast&lt;HTMLTemplateElement&gt;(*this).content();
2891 
2892     return replaceChildrenWithFragment(*container, fragment.releaseReturnValue());
2893 }
2894 
2895 String Element::innerText()
2896 {
2897     // We need to update layout, since plainText uses line boxes in the render tree.
2898     document().updateLayoutIgnorePendingStylesheets();
2899 
2900     if (!renderer())
2901         return textContent(true);
2902 
2903     return plainText(rangeOfContents(*this).ptr());
2904 }
2905 
2906 String Element::outerText()
2907 {
2908     // Getting outerText is the same as getting innerText, only
2909     // setting is different. You would think this should get the plain
2910     // text for the outer range, but this is wrong, &lt;br&gt; for instance
2911     // would return different values for inner and outer text by such
2912     // a rule, but it doesn&#39;t in WinIE, and we want to match that.
2913     return innerText();
2914 }
2915 
2916 String Element::title() const
2917 {
2918     return String();
2919 }
2920 
2921 const AtomicString&amp; Element::pseudo() const
2922 {
2923     return attributeWithoutSynchronization(pseudoAttr);
2924 }
2925 
2926 void Element::setPseudo(const AtomicString&amp; value)
2927 {
2928     setAttributeWithoutSynchronization(pseudoAttr, value);
2929 }
2930 
2931 LayoutSize Element::minimumSizeForResizing() const
2932 {
2933     return hasRareData() ? elementRareData()-&gt;minimumSizeForResizing() : defaultMinimumSizeForResizing();
2934 }
2935 
2936 void Element::setMinimumSizeForResizing(const LayoutSize&amp; size)
2937 {
2938     if (!hasRareData() &amp;&amp; size == defaultMinimumSizeForResizing())
2939         return;
2940     ensureElementRareData().setMinimumSizeForResizing(size);
2941 }
2942 
2943 void Element::willBecomeFullscreenElement()
2944 {
2945     for (auto&amp; child : descendantsOfType&lt;Element&gt;(*this))
2946         child.ancestorWillEnterFullscreen();
2947 }
2948 
2949 static PseudoElement* beforeOrAfterPseudoElement(Element&amp; host, PseudoId pseudoElementSpecifier)
2950 {
2951     switch (pseudoElementSpecifier) {
2952     case PseudoId::Before:
2953         return host.beforePseudoElement();
2954     case PseudoId::After:
2955         return host.afterPseudoElement();
2956     default:
2957         return nullptr;
2958     }
2959 }
2960 
2961 const RenderStyle* Element::existingComputedStyle() const
2962 {
2963     if (hasRareData()) {
2964         if (auto* style = elementRareData()-&gt;computedStyle())
2965             return style;
2966     }
2967 
2968     return renderStyle();
2969 }
2970 
2971 const RenderStyle* Element::renderOrDisplayContentsStyle() const
2972 {
2973     if (auto* style = renderStyle())
2974         return style;
2975 
2976     if (!hasRareData())
2977         return nullptr;
2978     auto* style = elementRareData()-&gt;computedStyle();
2979     if (style &amp;&amp; style-&gt;display() == DisplayType::Contents)
2980         return style;
2981 
2982     return nullptr;
2983 }
2984 
2985 const RenderStyle&amp; Element::resolveComputedStyle()
2986 {
2987     ASSERT(isConnected());
2988     ASSERT(!existingComputedStyle());
2989 
2990     Deque&lt;RefPtr&lt;Element&gt;, 32&gt; elementsRequiringComputedStyle({ this });
2991     const RenderStyle* computedStyle = nullptr;
2992 
2993     // Collect ancestors until we find one that has style.
2994     auto composedAncestors = composedTreeAncestors(*this);
2995     for (auto&amp; ancestor : composedAncestors) {
2996         if (auto* existingStyle = ancestor.existingComputedStyle()) {
2997             computedStyle = existingStyle;
2998             break;
2999         }
3000         elementsRequiringComputedStyle.prepend(&amp;ancestor);
3001     }
3002 
3003     // Resolve and cache styles starting from the most distant ancestor.
3004     for (auto&amp; element : elementsRequiringComputedStyle) {
3005         auto style = document().styleForElementIgnoringPendingStylesheets(*element, computedStyle);
3006         computedStyle = style.get();
3007         ElementRareData&amp; rareData = element-&gt;ensureElementRareData();
3008         rareData.setComputedStyle(WTFMove(style));
3009     }
3010 
3011     return *computedStyle;
3012 }
3013 
3014 const RenderStyle&amp; Element::resolvePseudoElementStyle(PseudoId pseudoElementSpecifier)
3015 {
3016     ASSERT(!isPseudoElement());
3017 
3018     auto* parentStyle = existingComputedStyle();
3019     ASSERT(parentStyle);
3020     ASSERT(!parentStyle-&gt;getCachedPseudoStyle(pseudoElementSpecifier));
3021 
3022     auto style = document().styleForElementIgnoringPendingStylesheets(*this, parentStyle, pseudoElementSpecifier);
3023     if (!style) {
3024         style = RenderStyle::createPtr();
3025         style-&gt;inheritFrom(*parentStyle);
3026         style-&gt;setStyleType(pseudoElementSpecifier);
3027     }
3028 
3029     auto* computedStyle = style.get();
3030     const_cast&lt;RenderStyle*&gt;(parentStyle)-&gt;addCachedPseudoStyle(WTFMove(style));
3031     return *computedStyle;
3032 }
3033 
3034 const RenderStyle* Element::computedStyle(PseudoId pseudoElementSpecifier)
3035 {
3036     if (!isConnected())
3037         return nullptr;
3038 
3039     if (PseudoElement* pseudoElement = beforeOrAfterPseudoElement(*this, pseudoElementSpecifier))
3040         return pseudoElement-&gt;computedStyle();
3041 
3042     auto* style = existingComputedStyle();
3043     if (!style)
3044         style = &amp;resolveComputedStyle();
3045 
3046     if (pseudoElementSpecifier != PseudoId::None) {
3047         if (auto* cachedPseudoStyle = style-&gt;getCachedPseudoStyle(pseudoElementSpecifier))
3048             return cachedPseudoStyle;
3049         return &amp;resolvePseudoElementStyle(pseudoElementSpecifier);
3050     }
3051 
3052     return style;
3053 }
3054 
3055 bool Element::needsStyleInvalidation() const
3056 {
3057     if (!inRenderedDocument())
3058         return false;
3059     if (styleValidity() &gt;= Style::Validity::SubtreeInvalid)
3060         return false;
3061     if (document().hasPendingFullStyleRebuild())
3062         return false;
3063 
3064     return true;
3065 }
3066 
3067 void Element::setStyleAffectedByEmpty()
3068 {
3069     ensureElementRareData().setStyleAffectedByEmpty(true);
3070 }
3071 
3072 void Element::setStyleAffectedByFocusWithin()
3073 {
3074     ensureElementRareData().setStyleAffectedByFocusWithin(true);
3075 }
3076 
3077 void Element::setStyleAffectedByActive()
3078 {
3079     ensureElementRareData().setStyleAffectedByActive(true);
3080 }
3081 
3082 void Element::setChildrenAffectedByDrag()
3083 {
3084     ensureElementRareData().setChildrenAffectedByDrag(true);
3085 }
3086 
3087 void Element::setChildrenAffectedByForwardPositionalRules()
3088 {
3089     ensureElementRareData().setChildrenAffectedByForwardPositionalRules(true);
3090 }
3091 
3092 void Element::setDescendantsAffectedByForwardPositionalRules()
3093 {
3094     ensureElementRareData().setDescendantsAffectedByForwardPositionalRules(true);
3095 }
3096 
3097 void Element::setChildrenAffectedByBackwardPositionalRules()
3098 {
3099     ensureElementRareData().setChildrenAffectedByBackwardPositionalRules(true);
3100 }
3101 
3102 void Element::setDescendantsAffectedByBackwardPositionalRules()
3103 {
3104     ensureElementRareData().setDescendantsAffectedByBackwardPositionalRules(true);
3105 }
3106 
3107 void Element::setChildrenAffectedByPropertyBasedBackwardPositionalRules()
3108 {
3109     ensureElementRareData().setChildrenAffectedByPropertyBasedBackwardPositionalRules(true);
3110 }
3111 
3112 void Element::setChildIndex(unsigned index)
3113 {
3114     ElementRareData&amp; rareData = ensureElementRareData();
3115     rareData.setChildIndex(index);
3116 }
3117 
3118 bool Element::hasFlagsSetDuringStylingOfChildren() const
3119 {
3120     if (childrenAffectedByHover() || childrenAffectedByFirstChildRules() || childrenAffectedByLastChildRules())
3121         return true;
3122 
3123     if (!hasRareData())
3124         return false;
3125     return rareDataStyleAffectedByActive()
3126         || rareDataChildrenAffectedByDrag()
3127         || rareDataChildrenAffectedByForwardPositionalRules()
3128         || rareDataDescendantsAffectedByForwardPositionalRules()
3129         || rareDataChildrenAffectedByBackwardPositionalRules()
3130         || rareDataDescendantsAffectedByBackwardPositionalRules()
3131         || rareDataChildrenAffectedByPropertyBasedBackwardPositionalRules();
3132 }
3133 
3134 bool Element::rareDataStyleAffectedByEmpty() const
3135 {
3136     ASSERT(hasRareData());
3137     return elementRareData()-&gt;styleAffectedByEmpty();
3138 }
3139 
3140 bool Element::rareDataStyleAffectedByFocusWithin() const
3141 {
3142     ASSERT(hasRareData());
3143     return elementRareData()-&gt;styleAffectedByFocusWithin();
3144 }
3145 
3146 bool Element::rareDataStyleAffectedByActive() const
3147 {
3148     ASSERT(hasRareData());
3149     return elementRareData()-&gt;styleAffectedByActive();
3150 }
3151 
3152 bool Element::rareDataChildrenAffectedByDrag() const
3153 {
3154     ASSERT(hasRareData());
3155     return elementRareData()-&gt;childrenAffectedByDrag();
3156 }
3157 
3158 bool Element::rareDataChildrenAffectedByForwardPositionalRules() const
3159 {
3160     ASSERT(hasRareData());
3161     return elementRareData()-&gt;childrenAffectedByForwardPositionalRules();
3162 }
3163 
3164 bool Element::rareDataDescendantsAffectedByForwardPositionalRules() const
3165 {
3166     ASSERT(hasRareData());
3167     return elementRareData()-&gt;descendantsAffectedByForwardPositionalRules();
3168 }
3169 
3170 bool Element::rareDataChildrenAffectedByBackwardPositionalRules() const
3171 {
3172     ASSERT(hasRareData());
3173     return elementRareData()-&gt;childrenAffectedByBackwardPositionalRules();
3174 }
3175 
3176 bool Element::rareDataDescendantsAffectedByBackwardPositionalRules() const
3177 {
3178     ASSERT(hasRareData());
3179     return elementRareData()-&gt;descendantsAffectedByBackwardPositionalRules();
3180 }
3181 
3182 bool Element::rareDataChildrenAffectedByPropertyBasedBackwardPositionalRules() const
3183 {
3184     ASSERT(hasRareData());
3185     return elementRareData()-&gt;childrenAffectedByPropertyBasedBackwardPositionalRules();
3186 }
3187 
3188 unsigned Element::rareDataChildIndex() const
3189 {
3190     ASSERT(hasRareData());
3191     return elementRareData()-&gt;childIndex();
3192 }
3193 
3194 AtomicString Element::computeInheritedLanguage() const
3195 {
3196     if (const ElementData* elementData = this-&gt;elementData()) {
3197         if (const Attribute* attribute = elementData-&gt;findLanguageAttribute())
3198             return attribute-&gt;value();
3199     }
3200 
3201     // The language property is inherited, so we iterate over the parents to find the first language.
3202     const Node* currentNode = this;
3203     while ((currentNode = currentNode-&gt;parentNode())) {
3204         if (is&lt;Element&gt;(*currentNode)) {
3205             if (const ElementData* elementData = downcast&lt;Element&gt;(*currentNode).elementData()) {
3206                 if (const Attribute* attribute = elementData-&gt;findLanguageAttribute())
3207                     return attribute-&gt;value();
3208             }
3209         } else if (is&lt;Document&gt;(*currentNode)) {
3210             // checking the MIME content-language
3211             return downcast&lt;Document&gt;(*currentNode).contentLanguage();
3212         }
3213     }
3214 
3215     return nullAtom();
3216 }
3217 
3218 Locale&amp; Element::locale() const
3219 {
3220     return document().getCachedLocale(computeInheritedLanguage());
3221 }
3222 
3223 void Element::normalizeAttributes()
3224 {
3225     if (!hasAttributes())
3226         return;
3227 
3228     auto* attrNodeList = attrNodeListForElement(*this);
3229     if (!attrNodeList)
3230         return;
3231 
3232     // Copy the Attr Vector because Node::normalize() can fire synchronous JS
3233     // events (e.g. DOMSubtreeModified) and a JS listener could add / remove
3234     // attributes while we are iterating.
3235     auto copyOfAttrNodeList = *attrNodeList;
3236     for (auto&amp; attrNode : copyOfAttrNodeList)
3237         attrNode-&gt;normalize();
3238 }
3239 
3240 PseudoElement* Element::beforePseudoElement() const
3241 {
3242     return hasRareData() ? elementRareData()-&gt;beforePseudoElement() : nullptr;
3243 }
3244 
3245 PseudoElement* Element::afterPseudoElement() const
3246 {
3247     return hasRareData() ? elementRareData()-&gt;afterPseudoElement() : nullptr;
3248 }
3249 
3250 void Element::setBeforePseudoElement(Ref&lt;PseudoElement&gt;&amp;&amp; element)
3251 {
3252     ensureElementRareData().setBeforePseudoElement(WTFMove(element));
3253 }
3254 
3255 void Element::setAfterPseudoElement(Ref&lt;PseudoElement&gt;&amp;&amp; element)
3256 {
3257     ensureElementRareData().setAfterPseudoElement(WTFMove(element));
3258 }
3259 
3260 static void disconnectPseudoElement(PseudoElement* pseudoElement)
3261 {
3262     if (!pseudoElement)
3263         return;
3264     ASSERT(!pseudoElement-&gt;renderer());
3265     ASSERT(pseudoElement-&gt;hostElement());
3266     pseudoElement-&gt;clearHostElement();
3267 }
3268 
3269 void Element::clearBeforePseudoElement()
3270 {
3271     if (!hasRareData())
3272         return;
3273     disconnectPseudoElement(elementRareData()-&gt;beforePseudoElement());
3274     elementRareData()-&gt;setBeforePseudoElement(nullptr);
3275 }
3276 
3277 void Element::clearAfterPseudoElement()
3278 {
3279     if (!hasRareData())
3280         return;
3281     disconnectPseudoElement(elementRareData()-&gt;afterPseudoElement());
3282     elementRareData()-&gt;setAfterPseudoElement(nullptr);
3283 }
3284 
3285 bool Element::matchesValidPseudoClass() const
3286 {
3287     return false;
3288 }
3289 
3290 bool Element::matchesInvalidPseudoClass() const
3291 {
3292     return false;
3293 }
3294 
3295 bool Element::matchesReadWritePseudoClass() const
3296 {
3297     return false;
3298 }
3299 
3300 bool Element::matchesIndeterminatePseudoClass() const
3301 {
3302     return shouldAppearIndeterminate();
3303 }
3304 
3305 bool Element::matchesDefaultPseudoClass() const
3306 {
3307     return false;
3308 }
3309 
3310 ExceptionOr&lt;bool&gt; Element::matches(const String&amp; selector)
3311 {
3312     auto query = document().selectorQueryForString(selector);
3313     if (query.hasException())
3314         return query.releaseException();
3315     return query.releaseReturnValue().matches(*this);
3316 }
3317 
3318 ExceptionOr&lt;Element*&gt; Element::closest(const String&amp; selector)
3319 {
3320     auto query = document().selectorQueryForString(selector);
3321     if (query.hasException())
3322         return query.releaseException();
3323     return query.releaseReturnValue().closest(*this);
3324 }
3325 
3326 bool Element::shouldAppearIndeterminate() const
3327 {
3328     return false;
3329 }
3330 
3331 bool Element::mayCauseRepaintInsideViewport(const IntRect* visibleRect) const
3332 {
3333     return renderer() &amp;&amp; renderer()-&gt;mayCauseRepaintInsideViewport(visibleRect);
3334 }
3335 
3336 DOMTokenList&amp; Element::classList()
3337 {
3338     ElementRareData&amp; data = ensureElementRareData();
3339     if (!data.classList())
3340         data.setClassList(std::make_unique&lt;DOMTokenList&gt;(*this, HTMLNames::classAttr));
3341     return *data.classList();
3342 }
3343 
3344 DatasetDOMStringMap&amp; Element::dataset()
3345 {
3346     ElementRareData&amp; data = ensureElementRareData();
3347     if (!data.dataset())
3348         data.setDataset(std::make_unique&lt;DatasetDOMStringMap&gt;(*this));
3349     return *data.dataset();
3350 }
3351 
3352 URL Element::getURLAttribute(const QualifiedName&amp; name) const
3353 {
3354 #if !ASSERT_DISABLED
3355     if (elementData()) {
3356         if (const Attribute* attribute = findAttributeByName(name))
3357             ASSERT(isURLAttribute(*attribute));
3358     }
3359 #endif
3360     return document().completeURL(stripLeadingAndTrailingHTMLSpaces(getAttribute(name)));
3361 }
3362 
3363 URL Element::getNonEmptyURLAttribute(const QualifiedName&amp; name) const
3364 {
3365 #if !ASSERT_DISABLED
3366     if (elementData()) {
3367         if (const Attribute* attribute = findAttributeByName(name))
3368             ASSERT(isURLAttribute(*attribute));
3369     }
3370 #endif
3371     String value = stripLeadingAndTrailingHTMLSpaces(getAttribute(name));
3372     if (value.isEmpty())
3373         return URL();
3374     return document().completeURL(value);
3375 }
3376 
3377 int Element::getIntegralAttribute(const QualifiedName&amp; attributeName) const
3378 {
3379     return parseHTMLInteger(getAttribute(attributeName)).value_or(0);
3380 }
3381 
3382 void Element::setIntegralAttribute(const QualifiedName&amp; attributeName, int value)
3383 {
3384     setAttribute(attributeName, AtomicString::number(value));
3385 }
3386 
3387 unsigned Element::getUnsignedIntegralAttribute(const QualifiedName&amp; attributeName) const
3388 {
3389     return parseHTMLNonNegativeInteger(getAttribute(attributeName)).value_or(0);
3390 }
3391 
3392 void Element::setUnsignedIntegralAttribute(const QualifiedName&amp; attributeName, unsigned value)
3393 {
3394     setAttribute(attributeName, AtomicString::number(limitToOnlyHTMLNonNegative(value)));
3395 }
3396 
3397 bool Element::childShouldCreateRenderer(const Node&amp; child) const
3398 {
3399     // Only create renderers for SVG elements whose parents are SVG elements, or for proper &lt;svg xmlns=&quot;svgNS&quot;&gt; subdocuments.
3400     if (child.isSVGElement()) {
3401         ASSERT(!isSVGElement());
3402         const SVGElement&amp; childElement = downcast&lt;SVGElement&gt;(child);
3403         return is&lt;SVGSVGElement&gt;(childElement) &amp;&amp; childElement.isValid();
3404     }
3405     return true;
3406 }
3407 
3408 #if ENABLE(FULLSCREEN_API) || ENABLE(POINTER_EVENTS)
3409 static Element* parentCrossingFrameBoundaries(const Element* element)
3410 {
3411     ASSERT(element);
3412     if (auto* parent = element-&gt;parentElementInComposedTree())
3413         return parent;
3414     return element-&gt;document().ownerElement();
3415 }
3416 #endif
3417 
3418 #if ENABLE(FULLSCREEN_API)
3419 void Element::webkitRequestFullscreen()
3420 {
3421     document().requestFullScreenForElement(this, Document::EnforceIFrameAllowFullScreenRequirement);
3422 }
3423 
3424 bool Element::containsFullScreenElement() const
3425 {
3426     return hasRareData() &amp;&amp; elementRareData()-&gt;containsFullScreenElement();
3427 }
3428 
3429 void Element::setContainsFullScreenElement(bool flag)
3430 {
3431     ensureElementRareData().setContainsFullScreenElement(flag);
3432     invalidateStyleAndLayerComposition();
3433 }
3434 
3435 void Element::setContainsFullScreenElementOnAncestorsCrossingFrameBoundaries(bool flag)
3436 {
3437     Element* element = this;
3438     while ((element = parentCrossingFrameBoundaries(element)))
3439         element-&gt;setContainsFullScreenElement(flag);
3440 }
3441 #endif
3442 
3443 #if ENABLE(POINTER_EVENTS)
3444 ExceptionOr&lt;void&gt; Element::setPointerCapture(int32_t pointerId)
3445 {
3446     if (document().page())
3447         return document().page()-&gt;pointerCaptureController().setPointerCapture(this, pointerId);
3448     return { };
3449 }
3450 
3451 ExceptionOr&lt;void&gt; Element::releasePointerCapture(int32_t pointerId)
3452 {
3453     if (document().page())
3454         return document().page()-&gt;pointerCaptureController().releasePointerCapture(this, pointerId);
3455     return { };
3456 }
3457 
3458 bool Element::hasPointerCapture(int32_t pointerId)
3459 {
3460     if (document().page())
3461         return document().page()-&gt;pointerCaptureController().hasPointerCapture(this, pointerId);
3462     return false;
3463 }
3464 #endif
3465 
3466 #if ENABLE(POINTER_LOCK)
3467 void Element::requestPointerLock()
3468 {
3469     if (document().page())
3470         document().page()-&gt;pointerLockController().requestPointerLock(this);
3471 }
3472 #endif
3473 
3474 #if ENABLE(INTERSECTION_OBSERVER)
3475 void Element::disconnectFromIntersectionObservers()
3476 {
3477     auto* observerData = intersectionObserverData();
3478     if (!observerData)
3479         return;
3480 
3481     for (const auto&amp; registration : observerData-&gt;registrations)
3482         registration.observer-&gt;targetDestroyed(*this);
3483     observerData-&gt;registrations.clear();
3484 
3485     for (const auto&amp; observer : observerData-&gt;observers)
3486         observer-&gt;rootDestroyed();
3487     observerData-&gt;observers.clear();
3488 }
3489 
3490 IntersectionObserverData&amp; Element::ensureIntersectionObserverData()
3491 {
3492     auto&amp; rareData = ensureElementRareData();
3493     if (!rareData.intersectionObserverData())
3494         rareData.setIntersectionObserverData(std::make_unique&lt;IntersectionObserverData&gt;());
3495     return *rareData.intersectionObserverData();
3496 }
3497 
3498 IntersectionObserverData* Element::intersectionObserverData()
3499 {
3500     return hasRareData() ? elementRareData()-&gt;intersectionObserverData() : nullptr;
3501 }
3502 #endif
3503 
3504 SpellcheckAttributeState Element::spellcheckAttributeState() const
3505 {
3506     const AtomicString&amp; value = attributeWithoutSynchronization(HTMLNames::spellcheckAttr);
3507     if (value.isNull())
3508         return SpellcheckAttributeDefault;
3509     if (value.isEmpty() || equalLettersIgnoringASCIICase(value, &quot;true&quot;))
3510         return SpellcheckAttributeTrue;
3511     if (equalLettersIgnoringASCIICase(value, &quot;false&quot;))
3512         return SpellcheckAttributeFalse;
3513     return SpellcheckAttributeDefault;
3514 }
3515 
3516 bool Element::isSpellCheckingEnabled() const
3517 {
3518     for (const Element* element = this; element; element = element-&gt;parentOrShadowHostElement()) {
3519         switch (element-&gt;spellcheckAttributeState()) {
3520         case SpellcheckAttributeTrue:
3521             return true;
3522         case SpellcheckAttributeFalse:
3523             return false;
3524         case SpellcheckAttributeDefault:
3525             break;
3526         }
3527     }
3528 
3529     return true;
3530 }
3531 
3532 #ifndef NDEBUG
3533 bool Element::fastAttributeLookupAllowed(const QualifiedName&amp; name) const
3534 {
3535     if (name == HTMLNames::styleAttr)
3536         return false;
3537 
3538     if (isSVGElement())
3539         return !downcast&lt;SVGElement&gt;(*this).isAnimatableAttribute(name);
3540 
3541     return true;
3542 }
3543 #endif
3544 
3545 #if DUMP_NODE_STATISTICS
3546 bool Element::hasNamedNodeMap() const
3547 {
3548     return hasRareData() &amp;&amp; elementRareData()-&gt;attributeMap();
3549 }
3550 #endif
3551 
3552 inline void Element::updateName(const AtomicString&amp; oldName, const AtomicString&amp; newName)
3553 {
3554     if (!isInTreeScope())
3555         return;
3556 
3557     if (oldName == newName)
3558         return;
3559 
3560     updateNameForTreeScope(treeScope(), oldName, newName);
3561 
3562     if (!isConnected())
3563         return;
3564     if (!is&lt;HTMLDocument&gt;(document()))
3565         return;
3566     updateNameForDocument(downcast&lt;HTMLDocument&gt;(document()), oldName, newName);
3567 }
3568 
3569 void Element::updateNameForTreeScope(TreeScope&amp; scope, const AtomicString&amp; oldName, const AtomicString&amp; newName)
3570 {
3571     ASSERT(oldName != newName);
3572 
3573     if (!oldName.isEmpty())
3574         scope.removeElementByName(*oldName.impl(), *this);
3575     if (!newName.isEmpty())
3576         scope.addElementByName(*newName.impl(), *this);
3577 }
3578 
3579 void Element::updateNameForDocument(HTMLDocument&amp; document, const AtomicString&amp; oldName, const AtomicString&amp; newName)
3580 {
3581     ASSERT(oldName != newName);
3582 
3583     if (isInShadowTree())
3584         return;
3585 
3586     if (WindowNameCollection::elementMatchesIfNameAttributeMatch(*this)) {
3587         const AtomicString&amp; id = WindowNameCollection::elementMatchesIfIdAttributeMatch(*this) ? getIdAttribute() : nullAtom();
3588         if (!oldName.isEmpty() &amp;&amp; oldName != id)
3589             document.removeWindowNamedItem(*oldName.impl(), *this);
3590         if (!newName.isEmpty() &amp;&amp; newName != id)
3591             document.addWindowNamedItem(*newName.impl(), *this);
3592     }
3593 
3594     if (DocumentNameCollection::elementMatchesIfNameAttributeMatch(*this)) {
3595         const AtomicString&amp; id = DocumentNameCollection::elementMatchesIfIdAttributeMatch(*this) ? getIdAttribute() : nullAtom();
3596         if (!oldName.isEmpty() &amp;&amp; oldName != id)
3597             document.removeDocumentNamedItem(*oldName.impl(), *this);
3598         if (!newName.isEmpty() &amp;&amp; newName != id)
3599             document.addDocumentNamedItem(*newName.impl(), *this);
3600     }
3601 }
3602 
3603 inline void Element::updateId(const AtomicString&amp; oldId, const AtomicString&amp; newId, NotifyObservers notifyObservers)
3604 {
3605     if (!isInTreeScope())
3606         return;
3607 
3608     if (oldId == newId)
3609         return;
3610 
3611     updateIdForTreeScope(treeScope(), oldId, newId, notifyObservers);
3612 
3613     if (!isConnected())
3614         return;
3615     if (!is&lt;HTMLDocument&gt;(document()))
3616         return;
3617     updateIdForDocument(downcast&lt;HTMLDocument&gt;(document()), oldId, newId, UpdateHTMLDocumentNamedItemMapsOnlyIfDiffersFromNameAttribute);
3618 }
3619 
3620 void Element::updateIdForTreeScope(TreeScope&amp; scope, const AtomicString&amp; oldId, const AtomicString&amp; newId, NotifyObservers notifyObservers)
3621 {
3622     ASSERT(isInTreeScope());
3623     ASSERT(oldId != newId);
3624 
3625     if (!oldId.isEmpty())
3626         scope.removeElementById(*oldId.impl(), *this, notifyObservers == NotifyObservers::Yes);
3627     if (!newId.isEmpty())
3628         scope.addElementById(*newId.impl(), *this, notifyObservers == NotifyObservers::Yes);
3629 }
3630 
3631 void Element::updateIdForDocument(HTMLDocument&amp; document, const AtomicString&amp; oldId, const AtomicString&amp; newId, HTMLDocumentNamedItemMapsUpdatingCondition condition)
3632 {
3633     ASSERT(isConnected());
3634     ASSERT(oldId != newId);
3635 
3636     if (isInShadowTree())
3637         return;
3638 
3639     if (WindowNameCollection::elementMatchesIfIdAttributeMatch(*this)) {
3640         const AtomicString&amp; name = condition == UpdateHTMLDocumentNamedItemMapsOnlyIfDiffersFromNameAttribute &amp;&amp; WindowNameCollection::elementMatchesIfNameAttributeMatch(*this) ? getNameAttribute() : nullAtom();
3641         if (!oldId.isEmpty() &amp;&amp; oldId != name)
3642             document.removeWindowNamedItem(*oldId.impl(), *this);
3643         if (!newId.isEmpty() &amp;&amp; newId != name)
3644             document.addWindowNamedItem(*newId.impl(), *this);
3645     }
3646 
3647     if (DocumentNameCollection::elementMatchesIfIdAttributeMatch(*this)) {
3648         const AtomicString&amp; name = condition == UpdateHTMLDocumentNamedItemMapsOnlyIfDiffersFromNameAttribute &amp;&amp; DocumentNameCollection::elementMatchesIfNameAttributeMatch(*this) ? getNameAttribute() : nullAtom();
3649         if (!oldId.isEmpty() &amp;&amp; oldId != name)
3650             document.removeDocumentNamedItem(*oldId.impl(), *this);
3651         if (!newId.isEmpty() &amp;&amp; newId != name)
3652             document.addDocumentNamedItem(*newId.impl(), *this);
3653     }
3654 }
3655 
3656 void Element::updateLabel(TreeScope&amp; scope, const AtomicString&amp; oldForAttributeValue, const AtomicString&amp; newForAttributeValue)
3657 {
3658     ASSERT(hasTagName(labelTag));
3659 
3660     if (!isConnected())
3661         return;
3662 
3663     if (oldForAttributeValue == newForAttributeValue)
3664         return;
3665 
3666     if (!oldForAttributeValue.isEmpty())
3667         scope.removeLabel(*oldForAttributeValue.impl(), downcast&lt;HTMLLabelElement&gt;(*this));
3668     if (!newForAttributeValue.isEmpty())
3669         scope.addLabel(*newForAttributeValue.impl(), downcast&lt;HTMLLabelElement&gt;(*this));
3670 }
3671 
3672 void Element::willModifyAttribute(const QualifiedName&amp; name, const AtomicString&amp; oldValue, const AtomicString&amp; newValue)
3673 {
3674     if (name == HTMLNames::idAttr)
3675         updateId(oldValue, newValue, NotifyObservers::No); // Will notify observers after the attribute is actually changed.
3676     else if (name == HTMLNames::nameAttr)
3677         updateName(oldValue, newValue);
3678     else if (name == HTMLNames::forAttr &amp;&amp; hasTagName(labelTag)) {
3679         if (treeScope().shouldCacheLabelsByForAttribute())
3680             updateLabel(treeScope(), oldValue, newValue);
3681     }
3682 
3683     if (auto recipients = MutationObserverInterestGroup::createForAttributesMutation(*this, name))
3684         recipients-&gt;enqueueMutationRecord(MutationRecord::createAttributes(*this, name, oldValue));
3685 
3686     InspectorInstrumentation::willModifyDOMAttr(document(), *this, oldValue, newValue);
3687 }
3688 
3689 void Element::didAddAttribute(const QualifiedName&amp; name, const AtomicString&amp; value)
3690 {
3691     attributeChanged(name, nullAtom(), value);
3692     InspectorInstrumentation::didModifyDOMAttr(document(), *this, name.localName(), value);
3693     dispatchSubtreeModifiedEvent();
3694 }
3695 
3696 void Element::didModifyAttribute(const QualifiedName&amp; name, const AtomicString&amp; oldValue, const AtomicString&amp; newValue)
3697 {
3698     attributeChanged(name, oldValue, newValue);
3699     InspectorInstrumentation::didModifyDOMAttr(document(), *this, name.localName(), newValue);
3700     // Do not dispatch a DOMSubtreeModified event here; see bug 81141.
3701 }
3702 
3703 void Element::didRemoveAttribute(const QualifiedName&amp; name, const AtomicString&amp; oldValue)
3704 {
3705     attributeChanged(name, oldValue, nullAtom());
3706     InspectorInstrumentation::didRemoveDOMAttr(document(), *this, name.localName());
3707     dispatchSubtreeModifiedEvent();
3708 }
3709 
3710 IntPoint Element::savedLayerScrollPosition() const
3711 {
3712     return hasRareData() ? elementRareData()-&gt;savedLayerScrollPosition() : IntPoint();
3713 }
3714 
3715 void Element::setSavedLayerScrollPosition(const IntPoint&amp; position)
3716 {
3717     if (position.isZero() &amp;&amp; !hasRareData())
3718         return;
3719     ensureElementRareData().setSavedLayerScrollPosition(position);
3720 }
3721 
3722 RefPtr&lt;Attr&gt; Element::attrIfExists(const AtomicString&amp; localName, bool shouldIgnoreAttributeCase)
3723 {
3724     if (auto* attrNodeList = attrNodeListForElement(*this))
3725         return findAttrNodeInList(*attrNodeList, localName, shouldIgnoreAttributeCase);
3726     return nullptr;
3727 }
3728 
3729 RefPtr&lt;Attr&gt; Element::attrIfExists(const QualifiedName&amp; name)
3730 {
3731     if (auto* attrNodeList = attrNodeListForElement(*this))
3732         return findAttrNodeInList(*attrNodeList, name);
3733     return nullptr;
3734 }
3735 
3736 Ref&lt;Attr&gt; Element::ensureAttr(const QualifiedName&amp; name)
3737 {
3738     auto&amp; attrNodeList = ensureAttrNodeListForElement(*this);
3739     RefPtr&lt;Attr&gt; attrNode = findAttrNodeInList(attrNodeList, name);
3740     if (!attrNode) {
3741         attrNode = Attr::create(*this, name);
3742         attrNode-&gt;setTreeScopeRecursively(treeScope());
3743         attrNodeList.append(attrNode);
3744     }
3745     return attrNode.releaseNonNull();
3746 }
3747 
3748 void Element::detachAttrNodeFromElementWithValue(Attr* attrNode, const AtomicString&amp; value)
3749 {
3750     ASSERT(hasSyntheticAttrChildNodes());
3751     attrNode-&gt;detachFromElementWithValue(value);
3752 
3753     auto&amp; attrNodeList = *attrNodeListForElement(*this);
3754     bool found = attrNodeList.removeFirstMatching([attrNode](auto&amp; attribute) {
3755         return attribute-&gt;qualifiedName() == attrNode-&gt;qualifiedName();
3756     });
3757     ASSERT_UNUSED(found, found);
3758     if (attrNodeList.isEmpty())
3759         removeAttrNodeListForElement(*this);
3760 }
3761 
3762 void Element::detachAllAttrNodesFromElement()
3763 {
3764     auto* attrNodeList = attrNodeListForElement(*this);
3765     ASSERT(attrNodeList);
3766 
3767     for (const Attribute&amp; attribute : attributesIterator()) {
3768         if (RefPtr&lt;Attr&gt; attrNode = findAttrNodeInList(*attrNodeList, attribute.name()))
3769             attrNode-&gt;detachFromElementWithValue(attribute.value());
3770     }
3771 
3772     removeAttrNodeListForElement(*this);
3773 }
3774 
3775 void Element::resetComputedStyle()
3776 {
3777     if (!hasRareData() || !elementRareData()-&gt;computedStyle())
3778         return;
3779 
3780     auto reset = [](Element&amp; element) {
3781         if (!element.hasRareData() || !element.elementRareData()-&gt;computedStyle())
3782             return;
3783         if (element.hasCustomStyleResolveCallbacks())
3784             element.willResetComputedStyle();
3785         element.elementRareData()-&gt;resetComputedStyle();
3786     };
3787     reset(*this);
3788     for (auto&amp; child : descendantsOfType&lt;Element&gt;(*this))
3789         reset(child);
3790 }
3791 
3792 void Element::resetStyleRelations()
3793 {
3794     if (!hasRareData())
3795         return;
3796     elementRareData()-&gt;resetStyleRelations();
3797 }
3798 
3799 void Element::clearHoverAndActiveStatusBeforeDetachingRenderer()
3800 {
3801     if (!isUserActionElement())
3802         return;
3803     if (hovered())
3804         document().hoveredElementDidDetach(*this);
3805     if (isInActiveChain())
3806         document().elementInActiveChainDidDetach(*this);
3807     document().userActionElements().clearActiveAndHovered(*this);
3808 }
3809 
3810 void Element::willRecalcStyle(Style::Change)
3811 {
3812     ASSERT(hasCustomStyleResolveCallbacks());
3813 }
3814 
3815 void Element::didRecalcStyle(Style::Change)
3816 {
3817     ASSERT(hasCustomStyleResolveCallbacks());
3818 }
3819 
3820 void Element::willResetComputedStyle()
3821 {
3822     ASSERT(hasCustomStyleResolveCallbacks());
3823 }
3824 
3825 void Element::willAttachRenderers()
3826 {
3827     ASSERT(hasCustomStyleResolveCallbacks());
3828 }
3829 
3830 void Element::didAttachRenderers()
3831 {
3832     ASSERT(hasCustomStyleResolveCallbacks());
3833 }
3834 
3835 void Element::willDetachRenderers()
3836 {
3837     ASSERT(hasCustomStyleResolveCallbacks());
3838 }
3839 
3840 void Element::didDetachRenderers()
3841 {
3842     ASSERT(hasCustomStyleResolveCallbacks());
3843 }
3844 
3845 Optional&lt;ElementStyle&gt; Element::resolveCustomStyle(const RenderStyle&amp;, const RenderStyle*)
3846 {
3847     ASSERT(hasCustomStyleResolveCallbacks());
3848     return WTF::nullopt;
3849 }
3850 
3851 void Element::cloneAttributesFromElement(const Element&amp; other)
3852 {
3853     if (hasSyntheticAttrChildNodes())
3854         detachAllAttrNodesFromElement();
3855 
3856     other.synchronizeAllAttributes();
3857     if (!other.m_elementData) {
3858         m_elementData = nullptr;
3859         return;
3860     }
3861 
3862     // We can&#39;t update window and document&#39;s named item maps since the presence of image and object elements depend on other attributes and children.
3863     // Fortunately, those named item maps are only updated when this element is in the document, which should never be the case.
3864     ASSERT(!isConnected());
3865 
3866     const AtomicString&amp; oldID = getIdAttribute();
3867     const AtomicString&amp; newID = other.getIdAttribute();
3868 
3869     if (!oldID.isNull() || !newID.isNull())
3870         updateId(oldID, newID, NotifyObservers::No); // Will notify observers after the attribute is actually changed.
3871 
3872     const AtomicString&amp; oldName = getNameAttribute();
3873     const AtomicString&amp; newName = other.getNameAttribute();
3874 
3875     if (!oldName.isNull() || !newName.isNull())
3876         updateName(oldName, newName);
3877 
3878     // If &#39;other&#39; has a mutable ElementData, convert it to an immutable one so we can share it between both elements.
3879     // We can only do this if there is no CSSOM wrapper for other&#39;s inline style, and there are no presentation attributes.
3880     if (is&lt;UniqueElementData&gt;(*other.m_elementData)
3881         &amp;&amp; !other.m_elementData-&gt;presentationAttributeStyle()
3882         &amp;&amp; (!other.m_elementData-&gt;inlineStyle() || !other.m_elementData-&gt;inlineStyle()-&gt;hasCSSOMWrapper()))
3883         const_cast&lt;Element&amp;&gt;(other).m_elementData = downcast&lt;UniqueElementData&gt;(*other.m_elementData).makeShareableCopy();
3884 
3885     if (!other.m_elementData-&gt;isUnique())
3886         m_elementData = other.m_elementData;
3887     else
3888         m_elementData = other.m_elementData-&gt;makeUniqueCopy();
3889 
3890     for (const Attribute&amp; attribute : attributesIterator())
3891         attributeChanged(attribute.name(), nullAtom(), attribute.value(), ModifiedByCloning);
3892 }
3893 
3894 void Element::cloneDataFromElement(const Element&amp; other)
3895 {
3896     cloneAttributesFromElement(other);
3897     copyNonAttributePropertiesFromElement(other);
3898 }
3899 
3900 void Element::createUniqueElementData()
3901 {
3902     if (!m_elementData)
3903         m_elementData = UniqueElementData::create();
3904     else
3905         m_elementData = downcast&lt;ShareableElementData&gt;(*m_elementData).makeUniqueCopy();
3906 }
3907 
3908 bool Element::hasPendingResources() const
3909 {
3910     return hasRareData() &amp;&amp; elementRareData()-&gt;hasPendingResources();
3911 }
3912 
3913 void Element::setHasPendingResources()
3914 {
3915     ensureElementRareData().setHasPendingResources(true);
3916 }
3917 
3918 void Element::clearHasPendingResources()
3919 {
3920     if (!hasRareData())
3921         return;
3922     elementRareData()-&gt;setHasPendingResources(false);
3923 }
3924 
3925 bool Element::hasCSSAnimation() const
3926 {
3927     return hasRareData() &amp;&amp; elementRareData()-&gt;hasCSSAnimation();
3928 }
3929 
3930 void Element::setHasCSSAnimation()
3931 {
3932     ensureElementRareData().setHasCSSAnimation(true);
3933 }
3934 
3935 void Element::clearHasCSSAnimation()
3936 {
3937     if (!hasRareData())
3938         return;
3939     elementRareData()-&gt;setHasCSSAnimation(false);
3940 }
3941 
3942 bool Element::canContainRangeEndPoint() const
3943 {
3944     return !equalLettersIgnoringASCIICase(attributeWithoutSynchronization(roleAttr), &quot;img&quot;);
3945 }
3946 
3947 String Element::completeURLsInAttributeValue(const URL&amp; base, const Attribute&amp; attribute) const
3948 {
3949     return URL(base, attribute.value()).string();
3950 }
3951 
3952 ExceptionOr&lt;Node*&gt; Element::insertAdjacent(const String&amp; where, Ref&lt;Node&gt;&amp;&amp; newChild)
3953 {
3954     // In Internet Explorer if the element has no parent and where is &quot;beforeBegin&quot; or &quot;afterEnd&quot;,
3955     // a document fragment is created and the elements appended in the correct order. This document
3956     // fragment isn&#39;t returned anywhere.
3957     //
3958     // This is impossible for us to implement as the DOM tree does not allow for such structures,
3959     // Opera also appears to disallow such usage.
3960 
3961     if (equalLettersIgnoringASCIICase(where, &quot;beforebegin&quot;)) {
3962         auto* parent = this-&gt;parentNode();
3963         if (!parent)
3964             return nullptr;
3965         auto result = parent-&gt;insertBefore(newChild, this);
3966         if (result.hasException())
3967             return result.releaseException();
3968         return newChild.ptr();
3969     }
3970 
3971     if (equalLettersIgnoringASCIICase(where, &quot;afterbegin&quot;)) {
3972         auto result = insertBefore(newChild, firstChild());
3973         if (result.hasException())
3974             return result.releaseException();
3975         return newChild.ptr();
3976     }
3977 
3978     if (equalLettersIgnoringASCIICase(where, &quot;beforeend&quot;)) {
3979         auto result = appendChild(newChild);
3980         if (result.hasException())
3981             return result.releaseException();
3982         return newChild.ptr();
3983     }
3984 
3985     if (equalLettersIgnoringASCIICase(where, &quot;afterend&quot;)) {
3986         auto* parent = this-&gt;parentNode();
3987         if (!parent)
3988             return nullptr;
3989         auto result = parent-&gt;insertBefore(newChild, nextSibling());
3990         if (result.hasException())
3991             return result.releaseException();
3992         return newChild.ptr();
3993     }
3994 
3995     return Exception { SyntaxError };
3996 }
3997 
3998 ExceptionOr&lt;Element*&gt; Element::insertAdjacentElement(const String&amp; where, Element&amp; newChild)
3999 {
4000     auto result = insertAdjacent(where, newChild);
4001     if (result.hasException())
4002         return result.releaseException();
4003     return downcast&lt;Element&gt;(result.releaseReturnValue());
4004 }
4005 
4006 // Step 1 of https://w3c.github.io/DOM-Parsing/#dom-element-insertadjacenthtml.
4007 static ExceptionOr&lt;ContainerNode&amp;&gt; contextNodeForInsertion(const String&amp; where, Element&amp; element)
4008 {
4009     if (equalLettersIgnoringASCIICase(where, &quot;beforebegin&quot;) || equalLettersIgnoringASCIICase(where, &quot;afterend&quot;)) {
4010         auto* parent = element.parentNode();
4011         if (!parent || is&lt;Document&gt;(*parent))
4012             return Exception { NoModificationAllowedError };
4013         return *parent;
4014     }
4015     if (equalLettersIgnoringASCIICase(where, &quot;afterbegin&quot;) || equalLettersIgnoringASCIICase(where, &quot;beforeend&quot;))
4016         return element;
4017     return Exception { SyntaxError };
4018 }
4019 
4020 // Step 2 of https://w3c.github.io/DOM-Parsing/#dom-element-insertadjacenthtml.
4021 static ExceptionOr&lt;Ref&lt;Element&gt;&gt; contextElementForInsertion(const String&amp; where, Element&amp; element)
4022 {
4023     auto contextNodeResult = contextNodeForInsertion(where, element);
4024     if (contextNodeResult.hasException())
4025         return contextNodeResult.releaseException();
4026     auto&amp; contextNode = contextNodeResult.releaseReturnValue();
4027     if (!is&lt;Element&gt;(contextNode) || (contextNode.document().isHTMLDocument() &amp;&amp; is&lt;HTMLHtmlElement&gt;(contextNode)))
4028         return Ref&lt;Element&gt; { HTMLBodyElement::create(contextNode.document()) };
4029     return Ref&lt;Element&gt; { downcast&lt;Element&gt;(contextNode) };
4030 }
4031 
4032 // https://w3c.github.io/DOM-Parsing/#dom-element-insertadjacenthtml
4033 ExceptionOr&lt;void&gt; Element::insertAdjacentHTML(const String&amp; where, const String&amp; markup, NodeVector* addedNodes)
4034 {
4035     // Steps 1 and 2.
4036     auto contextElement = contextElementForInsertion(where, *this);
4037     if (contextElement.hasException())
4038         return contextElement.releaseException();
4039     // Step 3.
4040     auto fragment = createFragmentForInnerOuterHTML(contextElement.releaseReturnValue(), markup, AllowScriptingContent);
4041     if (fragment.hasException())
4042         return fragment.releaseException();
4043 
4044     if (UNLIKELY(addedNodes)) {
4045         // Must be called before insertAdjacent, as otherwise the children of fragment will be moved
4046         // to their new parent and will be harder to keep track of.
4047         *addedNodes = collectChildNodes(fragment.returnValue());
4048     }
4049 
4050     // Step 4.
4051     auto result = insertAdjacent(where, fragment.releaseReturnValue());
4052     if (result.hasException())
4053         return result.releaseException();
4054     return { };
4055 }
4056 
4057 ExceptionOr&lt;void&gt; Element::insertAdjacentHTML(const String&amp; where, const String&amp; markup)
4058 {
4059     return insertAdjacentHTML(where, markup, nullptr);
4060 }
4061 
4062 ExceptionOr&lt;void&gt; Element::insertAdjacentText(const String&amp; where, const String&amp; text)
4063 {
4064     auto result = insertAdjacent(where, document().createTextNode(text));
4065     if (result.hasException())
4066         return result.releaseException();
4067     return { };
4068 }
4069 
4070 Element* Element::findAnchorElementForLink(String&amp; outAnchorName)
4071 {
4072     if (!isLink())
4073         return nullptr;
4074 
4075     const AtomicString&amp; href = attributeWithoutSynchronization(HTMLNames::hrefAttr);
4076     if (href.isNull())
4077         return nullptr;
4078 
4079     Document&amp; document = this-&gt;document();
4080     URL url = document.completeURL(href);
4081     if (!url.isValid())
4082         return nullptr;
4083 
4084     if (url.hasFragmentIdentifier() &amp;&amp; equalIgnoringFragmentIdentifier(url, document.baseURL())) {
4085         outAnchorName = url.fragmentIdentifier();
4086         return document.findAnchor(outAnchorName);
4087     }
4088 
4089     return nullptr;
4090 }
4091 
4092 ExceptionOr&lt;Ref&lt;WebAnimation&gt;&gt; Element::animate(JSC::ExecState&amp; state, JSC::Strong&lt;JSC::JSObject&gt;&amp;&amp; keyframes, Optional&lt;Variant&lt;double, KeyframeAnimationOptions&gt;&gt;&amp;&amp; options)
4093 {
4094     String id = &quot;&quot;;
4095     Optional&lt;Variant&lt;double, KeyframeEffectOptions&gt;&gt; keyframeEffectOptions;
4096     if (options) {
4097         auto optionsValue = options.value();
4098         Variant&lt;double, KeyframeEffectOptions&gt; keyframeEffectOptionsVariant;
4099         if (WTF::holds_alternative&lt;double&gt;(optionsValue))
4100             keyframeEffectOptionsVariant = WTF::get&lt;double&gt;(optionsValue);
4101         else {
4102             auto keyframeEffectOptions = WTF::get&lt;KeyframeAnimationOptions&gt;(optionsValue);
4103             id = keyframeEffectOptions.id;
4104             keyframeEffectOptionsVariant = WTFMove(keyframeEffectOptions);
4105         }
4106         keyframeEffectOptions = keyframeEffectOptionsVariant;
4107     }
4108 
4109     auto keyframeEffectResult = KeyframeEffect::create(state, this, WTFMove(keyframes), WTFMove(keyframeEffectOptions));
4110     if (keyframeEffectResult.hasException())
4111         return keyframeEffectResult.releaseException();
4112 
4113     auto animation = WebAnimation::create(document(), &amp;keyframeEffectResult.returnValue().get());
4114     animation-&gt;setId(id);
4115 
4116     auto animationPlayResult = animation-&gt;play();
4117     if (animationPlayResult.hasException())
4118         return animationPlayResult.releaseException();
4119 
4120     return WTFMove(animation);
4121 }
4122 
4123 Vector&lt;RefPtr&lt;WebAnimation&gt;&gt; Element::getAnimations()
4124 {
4125     // FIXME: Filter and order the list as specified (webkit.org/b/179535).
4126 
4127     // For the list of animations to be current, we need to account for any pending CSS changes,
4128     // such as updates to CSS Animations and CSS Transitions.
4129     // FIXME: We might be able to use ComputedStyleExtractor which is more optimized.
4130     document().updateStyleIfNeeded();
4131 
4132     Vector&lt;RefPtr&lt;WebAnimation&gt;&gt; animations;
4133     if (auto timeline = document().existingTimeline()) {
4134         for (auto&amp; animation : timeline-&gt;animationsForElement(*this, AnimationTimeline::Ordering::Sorted)) {
4135             if (animation-&gt;isRelevant())
4136                 animations.append(animation);
4137         }
4138     }
4139     return animations;
4140 }
4141 
4142 #if ENABLE(CSS_TYPED_OM)
4143 StylePropertyMap* Element::attributeStyleMap()
4144 {
4145     if (!hasRareData())
4146         return nullptr;
4147     return elementRareData()-&gt;attributeStyleMap();
4148 }
4149 
4150 void Element::setAttributeStyleMap(Ref&lt;StylePropertyMap&gt;&amp;&amp; map)
4151 {
4152     ensureElementRareData().setAttributeStyleMap(WTFMove(map));
4153 }
4154 #endif
4155 
4156 #if ENABLE(POINTER_EVENTS)
4157 OptionSet&lt;TouchAction&gt; Element::computedTouchActions() const
4158 {
4159     OptionSet&lt;TouchAction&gt; computedTouchActions = TouchAction::Auto;
4160     for (auto* element = this; element; element = parentCrossingFrameBoundaries(element)) {
4161         auto* renderer = element-&gt;renderer();
4162         if (!renderer)
4163             continue;
4164 
4165         auto touchActions = renderer-&gt;style().touchActions();
4166 
4167         // Once we&#39;ve encountered touch-action: none, we know that this will be the computed value.
4168         if (touchActions == TouchAction::None)
4169             return touchActions;
4170 
4171         // If the computed touch-action so far was &quot;auto&quot;, we can just use the current element&#39;s touch-action.
4172         if (computedTouchActions == TouchAction::Auto) {
4173             computedTouchActions = touchActions;
4174             continue;
4175         }
4176 
4177         // If the current element has touch-action: auto or the same touch-action as the computed touch-action,
4178         // we need to keep going up the ancestry chain.
4179         if (touchActions == TouchAction::Auto || touchActions == computedTouchActions)
4180             continue;
4181 
4182         // Now, the element&#39;s touch-action and the computed touch-action are different and are neither &quot;auto&quot; nor &quot;none&quot;.
4183         if (computedTouchActions == TouchAction::Manipulation) {
4184             // If the computed touch-action is &quot;manipulation&quot;, we can take the current element&#39;s touch-action as the newly
4185             // computed touch-action.
4186             computedTouchActions = touchActions;
4187         } else if (touchActions == TouchAction::Manipulation) {
4188             // Otherwise, we have a restricted computed touch-action so far. If the current element&#39;s touch-action is &quot;manipulation&quot;
4189             // then we can just keep going and leave the computed touch-action untouched.
4190             continue;
4191         }
4192 
4193         // In any other case, we have competing restrictive touch-action values that can only yield &quot;none&quot;.
4194         return TouchAction::None;
4195     }
4196     return computedTouchActions;
4197 }
4198 
4199 #if ENABLE(ACCELERATED_OVERFLOW_SCROLLING)
4200 ScrollingNodeID Element::nearestScrollingNodeIDUsingTouchOverflowScrolling() const
4201 {
4202     if (!renderer())
4203         return 0;
4204 
4205     // We are not interested in the root, so check that we also have a valid parent.
4206     for (auto* layer = renderer()-&gt;enclosingLayer(); layer &amp;&amp; layer-&gt;parent(); layer = layer-&gt;parent()) {
4207         if (layer-&gt;isComposited()) {
4208             if (auto scrollingNodeID = layer-&gt;backing()-&gt;scrollingNodeIDForRole(ScrollCoordinationRole::Scrolling))
4209                 return scrollingNodeID;
4210         }
4211     }
4212 
4213     return 0;
4214 }
4215 #endif
4216 #endif
4217 
4218 } // namespace WebCore
    </pre>
  </body>
</html>