<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderBlockFlow.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="RenderBlock.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="RenderBlockFlow.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderBlockFlow.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   7  *
   8  * This library is free software; you can redistribute it and/or
   9  * modify it under the terms of the GNU Library General Public
  10  * License as published by the Free Software Foundation; either
  11  * version 2 of the License, or (at your option) any later version.
  12  *
  13  * This library is distributed in the hope that it will be useful,
  14  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  15  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  16  * Library General Public License for more details.
  17  *
  18  * You should have received a copy of the GNU Library General Public License
  19  * along with this library; see the file COPYING.LIB.  If not, write to
  20  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  21  * Boston, MA 02110-1301, USA.
  22  */
  23 
  24 #include &quot;config.h&quot;
  25 #include &quot;RenderBlockFlow.h&quot;
  26 

  27 #include &quot;Editor.h&quot;
  28 #include &quot;FloatingObjects.h&quot;
  29 #include &quot;Frame.h&quot;
  30 #include &quot;FrameSelection.h&quot;
  31 #include &quot;HTMLElement.h&quot;
  32 #include &quot;HTMLInputElement.h&quot;
  33 #include &quot;HTMLParserIdioms.h&quot;
  34 #include &quot;HTMLTextAreaElement.h&quot;
  35 #include &quot;HitTestLocation.h&quot;
  36 #include &quot;InlineTextBox.h&quot;
  37 #include &quot;LayoutRepainter.h&quot;
  38 #include &quot;Logging.h&quot;
  39 #include &quot;RenderCombineText.h&quot;
  40 #include &quot;RenderFlexibleBox.h&quot;
  41 #include &quot;RenderInline.h&quot;
  42 #include &quot;RenderIterator.h&quot;
  43 #include &quot;RenderLayer.h&quot;
  44 #include &quot;RenderLayoutState.h&quot;
  45 #include &quot;RenderLineBreak.h&quot;
  46 #include &quot;RenderListItem.h&quot;
</pre>
<hr />
<pre>
 134     if (!renderTreeBeingDestroyed()) {
 135         if (firstRootBox()) {
 136             // We can&#39;t wait for RenderBox::destroy to clear the selection,
 137             // because by then we will have nuked the line boxes.
 138             if (isSelectionBorder())
 139                 frame().selection().setNeedsSelectionUpdate();
 140 
 141             // If we are an anonymous block, then our line boxes might have children
 142             // that will outlast this block. In the non-anonymous block case those
 143             // children will be destroyed by the time we return from this function.
 144             if (isAnonymousBlock()) {
 145                 for (auto* box = firstRootBox(); box; box = box-&gt;nextRootBox()) {
 146                     while (auto childBox = box-&gt;firstChild())
 147                         childBox-&gt;removeFromParent();
 148                 }
 149             }
 150         } else if (parent())
 151             parent()-&gt;dirtyLinesFromChangedChild(*this);
 152     }
 153 
<span class="line-modified"> 154     m_lineBoxes.deleteLineBoxes();</span>

 155 
 156     blockWillBeDestroyed();
 157 
 158     // NOTE: This jumps down to RenderBox, bypassing RenderBlock since it would do duplicate work.
 159     RenderBox::willBeDestroyed();
 160 }
 161 





 162 RenderBlockFlow* RenderBlockFlow::previousSiblingWithOverhangingFloats(bool&amp; parentHasFloats) const
 163 {
 164     // Attempt to locate a previous sibling with overhanging floats. We skip any elements that are
 165     // out of flow (like floating/positioned elements), and we also skip over any objects that may have shifted
 166     // to avoid floats.
 167     parentHasFloats = false;
 168     for (RenderObject* sibling = previousSibling(); sibling; sibling = sibling-&gt;previousSibling()) {
 169         if (is&lt;RenderBlockFlow&gt;(*sibling)) {
 170             auto&amp; siblingBlock = downcast&lt;RenderBlockFlow&gt;(*sibling);
 171             if (!siblingBlock.avoidsFloats())
 172                 return &amp;siblingBlock;
 173         }
 174         if (sibling-&gt;isFloating())
 175             parentHasFloats = true;
 176     }
 177     return nullptr;
 178 }
 179 
 180 void RenderBlockFlow::rebuildFloatingObjectSetFromIntrudingFloats()
 181 {
</pre>
<hr />
<pre>
 371     if (style().columnGap().isNormal())
 372         return style().fontDescription().computedPixelSize(); // &quot;1em&quot; is recommended as the normal gap setting. Matches &lt;p&gt; margins.
 373     return valueForLength(style().columnGap().length(), availableLogicalWidth());
 374 }
 375 
 376 void RenderBlockFlow::computeColumnCountAndWidth()
 377 {
 378     // Calculate our column width and column count.
 379     // FIXME: Can overflow on fast/block/float/float-not-removed-from-next-sibling4.html, see https://bugs.webkit.org/show_bug.cgi?id=68744
 380     unsigned desiredColumnCount = 1;
 381     LayoutUnit desiredColumnWidth = contentLogicalWidth();
 382 
 383     // For now, we don&#39;t support multi-column layouts when printing, since we have to do a lot of work for proper pagination.
 384     if (document().paginated() || (style().hasAutoColumnCount() &amp;&amp; style().hasAutoColumnWidth()) || !style().hasInlineColumnAxis()) {
 385         setComputedColumnCountAndWidth(desiredColumnCount, desiredColumnWidth);
 386         return;
 387     }
 388 
 389     LayoutUnit availWidth = desiredColumnWidth;
 390     LayoutUnit colGap = columnGap();
<span class="line-modified"> 391     LayoutUnit colWidth = std::max&lt;LayoutUnit&gt;(1, style().columnWidth());</span>
 392     unsigned colCount = std::max&lt;unsigned&gt;(1, style().columnCount());
 393 
 394     if (style().hasAutoColumnWidth() &amp;&amp; !style().hasAutoColumnCount()) {
 395         desiredColumnCount = colCount;
 396         desiredColumnWidth = std::max&lt;LayoutUnit&gt;(0, (availWidth - ((desiredColumnCount - 1) * colGap)) / desiredColumnCount);
 397     } else if (!style().hasAutoColumnWidth() &amp;&amp; style().hasAutoColumnCount()) {
 398         desiredColumnCount = std::max&lt;unsigned&gt;(1, ((availWidth + colGap) / (colWidth + colGap)).toUnsigned());
 399         desiredColumnWidth = ((availWidth + colGap) / desiredColumnCount) - colGap;
 400     } else {
 401         desiredColumnCount = std::max&lt;unsigned&gt;(std::min(colCount, ((availWidth + colGap) / (colWidth + colGap)).toUnsigned()), 1);
 402         desiredColumnWidth = ((availWidth + colGap) / desiredColumnCount) - colGap;
 403     }
 404     setComputedColumnCountAndWidth(desiredColumnCount, desiredColumnWidth);
 405 }
 406 
 407 bool RenderBlockFlow::willCreateColumns(Optional&lt;unsigned&gt; desiredColumnCount) const
 408 {
 409     // The following types are not supposed to create multicol context.
 410     if (isFileUploadControl() || isTextControl() || isListBox())
 411         return false;
</pre>
<hr />
<pre>
 652         // Lay out the child.
 653         layoutBlockChild(child, marginInfo, previousFloatLogicalBottom, maxFloatLogicalBottom);
 654     }
 655 
 656     // Now do the handling of the bottom of the block, adding in our bottom border/padding and
 657     // determining the correct collapsed bottom margin information.
 658     handleAfterSideOfBlock(beforeEdge, afterEdge, marginInfo);
 659 }
 660 
 661 void RenderBlockFlow::layoutInlineChildren(bool relayoutChildren, LayoutUnit&amp; repaintLogicalTop, LayoutUnit&amp; repaintLogicalBottom)
 662 {
 663     if (lineLayoutPath() == UndeterminedPath)
 664         setLineLayoutPath(SimpleLineLayout::canUseFor(*this) ? SimpleLinesPath : LineBoxesPath);
 665 
 666     if (lineLayoutPath() == SimpleLinesPath) {
 667         layoutSimpleLines(relayoutChildren, repaintLogicalTop, repaintLogicalBottom);
 668         return;
 669     }
 670 
 671     m_simpleLineLayout = nullptr;
<span class="line-modified"> 672     layoutLineBoxes(relayoutChildren, repaintLogicalTop, repaintLogicalBottom);</span>




 673 }
 674 
 675 void RenderBlockFlow::layoutBlockChild(RenderBox&amp; child, MarginInfo&amp; marginInfo, LayoutUnit&amp; previousFloatLogicalBottom, LayoutUnit&amp; maxFloatLogicalBottom)
 676 {
 677     LayoutUnit oldPosMarginBefore = maxPositiveMarginBefore();
 678     LayoutUnit oldNegMarginBefore = maxNegativeMarginBefore();
 679 
 680     // The child is a normal flow object. Compute the margins we will use for collapsing now.
 681     child.computeAndSetBlockDirectionMargins(*this);
 682 
 683     // Try to guess our correct logical top position. In most cases this guess will
 684     // be correct. Only if we&#39;re wrong (when we compute the real logical top position)
 685     // will we have to potentially relayout.
 686     LayoutUnit estimateWithoutPagination;
 687     LayoutUnit logicalTopEstimate = estimateLogicalTopPosition(child, marginInfo, estimateWithoutPagination);
 688 
 689     // Cache our old rect so that we can dirty the proper repaint rects if the child moves.
 690     LayoutRect oldRect = child.frameRect();
 691     LayoutUnit oldLogicalTop = logicalTopForChild(child);
 692 
</pre>
<hr />
<pre>
 888     setLogicalHeight(logicalHeight() - marginOffset);
 889 }
 890 
 891 void RenderBlockFlow::updateStaticInlinePositionForChild(RenderBox&amp; child, LayoutUnit logicalTop, IndentTextOrNot shouldIndentText)
 892 {
 893     if (child.style().isOriginalDisplayInlineType())
 894         setStaticInlinePositionForChild(child, logicalTop, startAlignedOffsetForLine(logicalTop, shouldIndentText));
 895     else
 896         setStaticInlinePositionForChild(child, logicalTop, startOffsetForContent(logicalTop));
 897 }
 898 
 899 void RenderBlockFlow::setStaticInlinePositionForChild(RenderBox&amp; child, LayoutUnit blockOffset, LayoutUnit inlinePosition)
 900 {
 901     if (enclosingFragmentedFlow()) {
 902         // Shift the inline position to exclude the fragment offset.
 903         inlinePosition += startOffsetForContent() - startOffsetForContent(blockOffset);
 904     }
 905     child.layer()-&gt;setStaticInlinePosition(inlinePosition);
 906 }
 907 







































 908 RenderBlockFlow::MarginValues RenderBlockFlow::marginValuesForChild(RenderBox&amp; child) const
 909 {
 910     LayoutUnit childBeforePositive;
 911     LayoutUnit childBeforeNegative;
 912     LayoutUnit childAfterPositive;
 913     LayoutUnit childAfterNegative;
 914 
 915     LayoutUnit beforeMargin;
 916     LayoutUnit afterMargin;
 917 
 918     RenderBlockFlow* childRenderBlock = is&lt;RenderBlockFlow&gt;(child) ? &amp;downcast&lt;RenderBlockFlow&gt;(child) : nullptr;
 919 
 920     // If the child has the same directionality as we do, then we can just return its
 921     // margins in the same direction.
 922     if (!child.isWritingModeRoot()) {
 923         if (childRenderBlock) {
 924             childBeforePositive = childRenderBlock-&gt;maxPositiveMarginBefore();
 925             childBeforeNegative = childRenderBlock-&gt;maxNegativeMarginBefore();
 926             childAfterPositive = childRenderBlock-&gt;maxPositiveMarginAfter();
 927             childAfterNegative = childRenderBlock-&gt;maxNegativeMarginAfter();
</pre>
<hr />
<pre>
1952         return remainingHeight;
1953     }
1954 
1955     return fragmentedFlow-&gt;pageRemainingLogicalHeightForOffset(offset, pageBoundaryRule);
1956 }
1957 
1958 LayoutUnit RenderBlockFlow::logicalHeightForChildForFragmentation(const RenderBox&amp; child) const
1959 {
1960     return logicalHeightForChild(child);
1961 }
1962 
1963 void RenderBlockFlow::layoutLineGridBox()
1964 {
1965     if (style().lineGrid() == RenderStyle::initialLineGrid()) {
1966         setLineGridBox(0);
1967         return;
1968     }
1969 
1970     setLineGridBox(0);
1971 
<span class="line-modified">1972     auto lineGridBox = std::make_unique&lt;RootInlineBox&gt;(*this);</span>
1973     lineGridBox-&gt;setHasTextChildren(); // Needed to make the line ascent/descent actually be honored in quirks mode.
1974     lineGridBox-&gt;setConstructed();
1975     GlyphOverflowAndFallbackFontsMap textBoxDataMap;
1976     VerticalPositionCache verticalPositionCache;
1977     lineGridBox-&gt;alignBoxesInBlockDirection(logicalHeight(), textBoxDataMap, verticalPositionCache);
1978 
1979     setLineGridBox(WTFMove(lineGridBox));
1980 
1981     // FIXME: If any of the characteristics of the box change compared to the old one, then we need to do a deep dirtying
1982     // (similar to what happens when the page height changes). Ideally, though, we only do this if someone is actually snapping
1983     // to this grid.
1984 }
1985 
1986 bool RenderBlockFlow::containsFloat(RenderBox&amp; renderer) const
1987 {
1988     return m_floatingObjects &amp;&amp; m_floatingObjects-&gt;set().contains&lt;FloatingObjectHashTranslator&gt;(renderer);
1989 }
1990 
1991 void RenderBlockFlow::styleDidChange(StyleDifference diff, const RenderStyle* oldStyle)
1992 {
</pre>
<hr />
<pre>
2042 
2043     if (oldStyle) {
2044         auto oldPosition = oldStyle-&gt;position();
2045         auto newPosition = newStyle.position();
2046 
2047         if (parent() &amp;&amp; diff == StyleDifference::Layout &amp;&amp; oldPosition != newPosition) {
2048             if (containsFloats() &amp;&amp; !isFloating() &amp;&amp; !isOutOfFlowPositioned() &amp;&amp; newStyle.hasOutOfFlowPosition())
2049                 markAllDescendantsWithFloatsForLayout();
2050         }
2051     }
2052 
2053     RenderBlock::styleWillChange(diff, newStyle);
2054 }
2055 
2056 void RenderBlockFlow::deleteLines()
2057 {
2058     if (containsFloats())
2059         m_floatingObjects-&gt;clearLineBoxTreePointers();
2060 
2061     if (m_simpleLineLayout) {
<span class="line-modified">2062         ASSERT(!m_lineBoxes.firstLineBox());</span>
2063         m_simpleLineLayout = nullptr;
<span class="line-modified">2064     } else</span>
<span class="line-modified">2065         m_lineBoxes.deleteLineBoxTree();</span>
2066 
2067     RenderBlock::deleteLines();
2068 }
2069 
2070 void RenderBlockFlow::addFloatsToNewParent(RenderBlockFlow&amp; toBlockFlow) const
2071 {
2072     // When a portion of the render tree is being detached, anonymous blocks
2073     // will be combined as their children are deleted. In this process, the
2074     // anonymous block later in the tree is merged into the one preceeding it.
2075     // It can happen that the later block (this) contains floats that the
2076     // previous block (toBlockFlow) did not contain, and thus are not in the
2077     // floating objects list for toBlockFlow. This can result in toBlockFlow
2078     // containing floats that are not in it&#39;s floating objects list, but are in
2079     // the floating objects lists of siblings and parents. This can cause
2080     // problems when the float itself is deleted, since the deletion code
2081     // assumes that if a float is not in it&#39;s containing block&#39;s floating
2082     // objects list, it isn&#39;t in any floating objects list. In order to
2083     // preserve this condition (removing it has serious performance
2084     // implications), we need to copy the floating objects from the old block
2085     // (this) to the new block (toBlockFlow). The float&#39;s metrics will likely
</pre>
<hr />
<pre>
2193 }
2194 
2195 void RenderBlockFlow::clipOutFloatingObjects(RenderBlock&amp; rootBlock, const PaintInfo* paintInfo, const LayoutPoint&amp; rootBlockPhysicalPosition, const LayoutSize&amp; offsetFromRootBlock)
2196 {
2197     if (m_floatingObjects) {
2198         const FloatingObjectSet&amp; floatingObjectSet = m_floatingObjects-&gt;set();
2199         auto end = floatingObjectSet.end();
2200         for (auto it = floatingObjectSet.begin(); it != end; ++it) {
2201             const auto&amp; floatingObject = *it-&gt;get();
2202             LayoutRect floatBox(offsetFromRootBlock.width(), offsetFromRootBlock.height(), floatingObject.renderer().width(), floatingObject.renderer().height());
2203             floatBox.move(floatingObject.locationOffsetOfBorderBox());
2204             rootBlock.flipForWritingMode(floatBox);
2205             floatBox.move(rootBlockPhysicalPosition.x(), rootBlockPhysicalPosition.y());
2206             paintInfo-&gt;context().clipOut(snappedIntRect(floatBox));
2207         }
2208     }
2209 }
2210 
2211 void RenderBlockFlow::createFloatingObjects()
2212 {
<span class="line-modified">2213     m_floatingObjects = std::make_unique&lt;FloatingObjects&gt;(*this);</span>
2214 }
2215 
2216 void RenderBlockFlow::removeFloatingObjects()
2217 {
2218     if (!m_floatingObjects)
2219         return;
2220 
2221     markSiblingsWithFloatsForLayout();
2222 
2223     m_floatingObjects-&gt;clear();
2224 }
2225 
2226 FloatingObject* RenderBlockFlow::insertFloatingObject(RenderBox&amp; floatBox)
2227 {
2228     ASSERT(floatBox.isFloating());
2229 
2230     // Create the list of special objects if we don&#39;t aleady have one
2231     if (!m_floatingObjects)
2232         createFloatingObjects();
2233     else {
</pre>
<hr />
<pre>
2882         auto&amp; renderer = floatingObject.renderer();
2883         if (floatingObject.shouldPaint() &amp;&amp; !renderer.hasSelfPaintingLayer()) {
2884             LayoutPoint childPoint = flipFloatForWritingModeForChild(floatingObject, adjustedLocation + floatingObject.translationOffsetToAncestor());
2885             if (renderer.hitTest(request, result, locationInContainer, childPoint)) {
2886                 updateHitTestResult(result, locationInContainer.point() - toLayoutSize(childPoint));
2887                 return true;
2888             }
2889         }
2890     }
2891 
2892     return false;
2893 }
2894 
2895 bool RenderBlockFlow::hitTestInlineChildren(const HitTestRequest&amp; request, HitTestResult&amp; result, const HitTestLocation&amp; locationInContainer, const LayoutPoint&amp; accumulatedOffset, HitTestAction hitTestAction)
2896 {
2897     ASSERT(childrenInline());
2898 
2899     if (auto simpleLineLayout = this-&gt;simpleLineLayout())
2900         return SimpleLineLayout::hitTestFlow(*this, *simpleLineLayout, request, result, locationInContainer, accumulatedOffset, hitTestAction);
2901 
<span class="line-modified">2902     return m_lineBoxes.hitTest(this, request, result, locationInContainer, accumulatedOffset, hitTestAction);</span>











2903 }
2904 
2905 void RenderBlockFlow::adjustForBorderFit(LayoutUnit x, LayoutUnit&amp; left, LayoutUnit&amp; right) const
2906 {
2907     if (style().visibility() != Visibility::Visible)
2908         return;
2909 
2910     // We don&#39;t deal with relative positioning.  Our assumption is that you shrink to fit the lines without accounting
2911     // for either overflow or translations via relative positioning.
2912     if (childrenInline()) {
2913         const_cast&lt;RenderBlockFlow&amp;&gt;(*this).ensureLineBoxes();
2914 
2915         for (auto* box = firstRootBox(); box; box = box-&gt;nextRootBox()) {
2916             if (box-&gt;firstChild())
2917                 left = std::min(left, x + LayoutUnit(box-&gt;firstChild()-&gt;x()));
2918             if (box-&gt;lastChild())
2919                 right = std::max(right, x + LayoutUnit(ceilf(box-&gt;lastChild()-&gt;logicalRight())));
2920         }
2921     } else {
2922         for (RenderBox* obj = firstChildBox(); obj; obj = obj-&gt;nextSiblingBox()) {
</pre>
<hr />
<pre>
3079             lastLogicalTop = blockDirectionOffset(rootBlock, offsetFromRootBlock) + logicalHeight();
3080             lastLogicalLeft = logicalLeftSelectionOffset(rootBlock, logicalHeight(), cache);
3081             lastLogicalRight = logicalRightSelectionOffset(rootBlock, logicalHeight(), cache);
3082         }
3083         return result;
3084     }
3085 
3086     RootInlineBox* lastSelectedLine = 0;
3087     RootInlineBox* curr;
3088     for (curr = firstRootBox(); curr &amp;&amp; !curr-&gt;hasSelectedChildren(); curr = curr-&gt;nextRootBox()) { }
3089 
3090     // Now paint the gaps for the lines.
3091     for (; curr &amp;&amp; curr-&gt;hasSelectedChildren(); curr = curr-&gt;nextRootBox()) {
3092         LayoutUnit selTop =  curr-&gt;selectionTopAdjustedForPrecedingBlock();
3093         LayoutUnit selHeight = curr-&gt;selectionHeightAdjustedForPrecedingBlock();
3094 
3095         if (!containsStart &amp;&amp; !lastSelectedLine &amp;&amp;
3096             selectionState() != SelectionStart &amp;&amp; selectionState() != SelectionBoth &amp;&amp; !isRubyBase())
3097             result.uniteCenter(blockSelectionGap(rootBlock, rootBlockPhysicalPosition, offsetFromRootBlock, lastLogicalTop, lastLogicalLeft, lastLogicalRight, selTop, cache, paintInfo));
3098 
<span class="line-modified">3099         LayoutRect logicalRect(curr-&gt;logicalLeft(), selTop, curr-&gt;logicalWidth(), selTop + selHeight);</span>
3100         logicalRect.move(isHorizontalWritingMode() ? offsetFromRootBlock : offsetFromRootBlock.transposedSize());
3101         LayoutRect physicalRect = rootBlock.logicalRectToPhysicalRect(rootBlockPhysicalPosition, logicalRect);
3102         if (!paintInfo || (isHorizontalWritingMode() &amp;&amp; physicalRect.y() &lt; paintInfo-&gt;rect.maxY() &amp;&amp; physicalRect.maxY() &gt; paintInfo-&gt;rect.y())
3103             || (!isHorizontalWritingMode() &amp;&amp; physicalRect.x() &lt; paintInfo-&gt;rect.maxX() &amp;&amp; physicalRect.maxX() &gt; paintInfo-&gt;rect.x()))
3104             result.unite(curr-&gt;lineSelectionGap(rootBlock, rootBlockPhysicalPosition, offsetFromRootBlock, selTop, selHeight, cache, paintInfo));
3105 
3106         lastSelectedLine = curr;
3107     }
3108 
3109     if (containsStart &amp;&amp; !lastSelectedLine)
3110         // VisibleSelection must start just after our last line.
3111         lastSelectedLine = lastRootBox();
3112 
3113     if (lastSelectedLine &amp;&amp; selectionState() != SelectionEnd &amp;&amp; selectionState() != SelectionBoth) {
3114         // Update our lastY to be the bottom of the last selected line.
3115         lastLogicalTop = blockDirectionOffset(rootBlock, offsetFromRootBlock) + lastSelectedLine-&gt;selectionBottom();
3116         lastLogicalLeft = logicalLeftSelectionOffset(rootBlock, lastSelectedLine-&gt;selectionBottom(), cache);
3117         lastLogicalRight = logicalRightSelectionOffset(rootBlock, lastSelectedLine-&gt;selectionBottom(), cache);
3118     }
3119     return result;
</pre>
<hr />
<pre>
3395 
3396                 if (nextRootBoxWithChildren &amp;&amp; nextRootBoxWithChildren-&gt;isFirstAfterPageBreak() &amp;&amp; (pointInLogicalContents.y() &gt; nextRootBoxWithChildren-&gt;lineTopWithLeading()
3397                     || (!blocksAreFlipped &amp;&amp; pointInLogicalContents.y() == nextRootBoxWithChildren-&gt;lineTopWithLeading())))
3398                     continue;
3399             }
3400             closestBox = root-&gt;closestLeafChildForLogicalLeftPosition(pointInLogicalContents.x());
3401             if (closestBox)
3402                 break;
3403         }
3404     }
3405 
3406     bool moveCaretToBoundary = frame().editor().behavior().shouldMoveCaretToHorizontalBoundaryWhenPastTopOrBottom();
3407 
3408     if (!moveCaretToBoundary &amp;&amp; !closestBox &amp;&amp; lastRootBoxWithChildren) {
3409         // y coordinate is below last root line box, pretend we hit it
3410         closestBox = lastRootBoxWithChildren-&gt;closestLeafChildForLogicalLeftPosition(pointInLogicalContents.x());
3411     }
3412 
3413     if (closestBox) {
3414         if (moveCaretToBoundary) {
<span class="line-modified">3415             LayoutUnit firstRootBoxWithChildrenTop = std::min&lt;LayoutUnit&gt;(firstRootBoxWithChildren-&gt;selectionTop(), firstRootBoxWithChildren-&gt;logicalTop());</span>
3416             if (pointInLogicalContents.y() &lt; firstRootBoxWithChildrenTop
3417                 || (blocksAreFlipped &amp;&amp; pointInLogicalContents.y() == firstRootBoxWithChildrenTop)) {
3418                 InlineBox* box = firstRootBoxWithChildren-&gt;firstLeafChild();
3419                 if (box-&gt;isLineBreak()) {
3420                     if (InlineBox* newBox = box-&gt;nextLeafChildIgnoringLineBreak())
3421                         box = newBox;
3422                 }
3423                 // y coordinate is above first root line box, so return the start of the first
3424                 return VisiblePosition(positionForBox(box, true), DOWNSTREAM);
3425             }
3426         }
3427 
3428         // pass the box a top position that is inside it
3429         LayoutPoint point(pointInLogicalContents.x(), closestBox-&gt;root().blockDirectionPointInLine());
3430         if (!isHorizontalWritingMode())
3431             point = point.transposedPoint();
3432         if (closestBox-&gt;renderer().isReplaced())
3433             return positionForPointRespectingEditingBoundaries(*this, downcast&lt;RenderBox&gt;(closestBox-&gt;renderer()), point);
3434         return closestBox-&gt;renderer().positionForPoint(point, nullptr);
3435     }
</pre>
<hr />
<pre>
3448     return createVisiblePosition(0, DOWNSTREAM);
3449 }
3450 
3451 Position RenderBlockFlow::positionForPoint(const LayoutPoint&amp; point)
3452 {
3453     // FIXME: It supports single text child only (which is the majority of simple line layout supported content at this point).
3454     if (!simpleLineLayout() || firstChild() != lastChild() || !is&lt;RenderText&gt;(firstChild()))
3455         return positionForPoint(point, nullptr).deepEquivalent();
3456     return downcast&lt;RenderText&gt;(*firstChild()).positionForPoint(point);
3457 }
3458 
3459 VisiblePosition RenderBlockFlow::positionForPoint(const LayoutPoint&amp; point, const RenderFragmentContainer*)
3460 {
3461     return RenderBlock::positionForPoint(point, nullptr);
3462 }
3463 
3464 void RenderBlockFlow::addFocusRingRectsForInlineChildren(Vector&lt;LayoutRect&gt;&amp; rects, const LayoutPoint&amp; additionalOffset, const RenderLayerModelObject*)
3465 {
3466     ASSERT(childrenInline());
3467     for (RootInlineBox* curr = firstRootBox(); curr; curr = curr-&gt;nextRootBox()) {
<span class="line-modified">3468         LayoutUnit top = std::max&lt;LayoutUnit&gt;(curr-&gt;lineTop(), curr-&gt;top());</span>
<span class="line-modified">3469         LayoutUnit bottom = std::min&lt;LayoutUnit&gt;(curr-&gt;lineBottom(), curr-&gt;top() + curr-&gt;height());</span>
<span class="line-modified">3470         LayoutRect rect(additionalOffset.x() + curr-&gt;x(), additionalOffset.y() + top, curr-&gt;width(), bottom - top);</span>
3471         if (!rect.isEmpty())
3472             rects.append(rect);
3473     }
3474 }
3475 
3476 void RenderBlockFlow::paintInlineChildren(PaintInfo&amp; paintInfo, const LayoutPoint&amp; paintOffset)
3477 {
3478     ASSERT(childrenInline());
3479 
3480     if (auto simpleLineLayout = this-&gt;simpleLineLayout()) {
3481         SimpleLineLayout::paintFlow(*this, *simpleLineLayout, paintInfo, paintOffset);
3482         return;
3483     }
<span class="line-modified">3484     m_lineBoxes.paint(this, paintInfo, paintOffset);</span>


3485 }
3486 
3487 bool RenderBlockFlow::relayoutForPagination()
3488 {
3489     if (!multiColumnFlow() || !multiColumnFlow()-&gt;shouldRelayoutForPagination())
3490         return false;
3491 
3492     multiColumnFlow()-&gt;setNeedsHeightsRecalculation(false);
3493     multiColumnFlow()-&gt;setInBalancingPass(true); // Prevent re-entering this method (and recursion into layout).
3494 
3495     bool needsRelayout;
3496     bool neededRelayout = false;
3497     bool firstPass = true;
3498     do {
3499         // Column heights may change here because of balancing. We may have to do multiple layout
3500         // passes, depending on how the contents is fitted to the changed column heights. In most
3501         // cases, laying out again twice or even just once will suffice. Sometimes we need more
3502         // passes than that, though, but the number of retries should not exceed the number of
3503         // columns, unless we have a bug.
3504         needsRelayout = false;
</pre>
<hr />
<pre>
3519             multiColumnFlow()-&gt;setChildNeedsLayout(MarkOnlyThis);
3520             setChildNeedsLayout(MarkOnlyThis);
3521             layoutBlock(false);
3522         }
3523         firstPass = false;
3524     } while (needsRelayout);
3525 
3526     multiColumnFlow()-&gt;setInBalancingPass(false);
3527 
3528     return neededRelayout;
3529 }
3530 
3531 bool RenderBlockFlow::hasLines() const
3532 {
3533     if (!childrenInline())
3534         return false;
3535 
3536     if (auto simpleLineLayout = this-&gt;simpleLineLayout())
3537         return simpleLineLayout-&gt;lineCount();
3538 
<span class="line-modified">3539     return lineBoxes().firstLineBox();</span>
3540 }
3541 
3542 void RenderBlockFlow::invalidateLineLayoutPath()
3543 {
3544     switch (lineLayoutPath()) {
3545     case UndeterminedPath:
3546     case ForceLineBoxesPath:
3547         ASSERT(!m_simpleLineLayout);
3548         return;
3549     case LineBoxesPath:
3550         ASSERT(!m_simpleLineLayout);
3551         setLineLayoutPath(UndeterminedPath);
3552         return;
3553     case SimpleLinesPath:
3554         // The simple line layout may have become invalid.
3555         m_simpleLineLayout = nullptr;
3556         setLineLayoutPath(UndeterminedPath);
3557         if (needsLayout())
3558             return;
3559         // FIXME: We should just kick off a subtree layout here (if needed at all) see webkit.org/b/172947.
3560         setNeedsLayout();
3561         return;
3562     }
3563     ASSERT_NOT_REACHED();
3564 }
3565 
3566 void RenderBlockFlow::layoutSimpleLines(bool relayoutChildren, LayoutUnit&amp; repaintLogicalTop, LayoutUnit&amp; repaintLogicalBottom)
3567 {
3568     bool needsLayout = selfNeedsLayout() || relayoutChildren || !m_simpleLineLayout;
3569     if (needsLayout) {
3570         deleteLineBoxesBeforeSimpleLineLayout();
3571         m_simpleLineLayout = SimpleLineLayout::create(*this);
3572     }
3573     if (view().frameView().layoutContext().layoutState() &amp;&amp; view().frameView().layoutContext().layoutState()-&gt;isPaginated()) {
3574         m_simpleLineLayout-&gt;setIsPaginated();
3575         SimpleLineLayout::adjustLinePositionsForPagination(*m_simpleLineLayout, *this);
3576     }
3577     for (auto&amp; renderer : childrenOfType&lt;RenderObject&gt;(*this))
3578         renderer.clearNeedsLayout();
<span class="line-modified">3579     ASSERT(!m_lineBoxes.firstLineBox());</span>
3580     LayoutUnit lineLayoutHeight = SimpleLineLayout::computeFlowHeight(*this, *m_simpleLineLayout);
3581     LayoutUnit lineLayoutTop = borderAndPaddingBefore();
3582     repaintLogicalTop = lineLayoutTop;
3583     repaintLogicalBottom = needsLayout ? repaintLogicalTop + lineLayoutHeight + borderAndPaddingAfter() : repaintLogicalTop;
3584     setLogicalHeight(lineLayoutTop + lineLayoutHeight + borderAndPaddingAfter());
3585 }
3586 
3587 void RenderBlockFlow::deleteLineBoxesBeforeSimpleLineLayout()
3588 {
3589     ASSERT(lineLayoutPath() == SimpleLinesPath);
<span class="line-modified">3590     lineBoxes().deleteLineBoxes();</span>



3591     for (auto&amp; renderer : childrenOfType&lt;RenderObject&gt;(*this)) {
3592         if (is&lt;RenderText&gt;(renderer))
3593             downcast&lt;RenderText&gt;(renderer).deleteLineBoxesBeforeSimpleLineLayout();
3594         else if (is&lt;RenderLineBreak&gt;(renderer))
3595             downcast&lt;RenderLineBreak&gt;(renderer).deleteLineBoxesBeforeSimpleLineLayout();
3596         else
3597             ASSERT_NOT_REACHED();
3598     }


3599 }
3600 
3601 void RenderBlockFlow::ensureLineBoxes()
3602 {



3603     setLineLayoutPath(ForceLineBoxesPath);

3604     if (!m_simpleLineLayout)
3605         return;
3606 



3607     if (SimpleLineLayout::canUseForLineBoxTree(*this, *m_simpleLineLayout)) {
3608         SimpleLineLayout::generateLineBoxTree(*this, *m_simpleLineLayout);
3609         m_simpleLineLayout = nullptr;
3610         return;
3611     }
3612     bool isPaginated = m_simpleLineLayout-&gt;isPaginated();
3613     m_simpleLineLayout = nullptr;
3614 
3615 #if !ASSERT_DISABLED
3616     LayoutUnit oldHeight = logicalHeight();
3617 #endif
3618     bool didNeedLayout = needsLayout();
3619 
3620     bool relayoutChildren = false;
3621     LayoutUnit repaintLogicalTop;
3622     LayoutUnit repaintLogicalBottom;
3623     if (isPaginated) {
3624         PaginatedLayoutStateMaintainer state(*this);
<span class="line-modified">3625         layoutLineBoxes(relayoutChildren, repaintLogicalTop, repaintLogicalBottom);</span>
3626         // This matches relayoutToAvoidWidows.
3627         if (shouldBreakAtLineToAvoidWidow())
<span class="line-modified">3628             layoutLineBoxes(relayoutChildren, repaintLogicalTop, repaintLogicalBottom);</span>
3629         // FIXME: This is needed as long as simple and normal line layout produce different line breakings.
3630         repaint();
3631     } else
<span class="line-modified">3632         layoutLineBoxes(relayoutChildren, repaintLogicalTop, repaintLogicalBottom);</span>
3633 
3634     updateLogicalHeight();
3635     ASSERT(didNeedLayout || logicalHeight() == oldHeight);
3636 
3637     if (!didNeedLayout)
3638         clearNeedsLayout();
3639 }
3640 
3641 #if ENABLE(TREE_DEBUGGING)
3642 void RenderBlockFlow::outputLineTreeAndMark(WTF::TextStream&amp; stream, const InlineBox* markedBox, int depth) const
3643 {
3644     for (const RootInlineBox* root = firstRootBox(); root; root = root-&gt;nextRootBox())
3645         root-&gt;outputLineTreeAndMark(stream, markedBox, depth);
3646 
3647     if (auto simpleLineLayout = this-&gt;simpleLineLayout())
3648         SimpleLineLayout::outputLineLayoutForFlow(stream, *this, *simpleLineLayout, depth);
3649 }
3650 #endif
3651 
3652 RenderBlockFlow::RenderBlockFlowRareData&amp; RenderBlockFlow::ensureRareBlockFlowData()
3653 {
3654     if (hasRareBlockFlowData())
3655         return *m_rareBlockFlowData;
3656     materializeRareBlockFlowData();
3657     return *m_rareBlockFlowData;
3658 }
3659 
3660 void RenderBlockFlow::materializeRareBlockFlowData()
3661 {
3662     ASSERT(!hasRareBlockFlowData());
<span class="line-modified">3663     m_rareBlockFlowData = std::make_unique&lt;RenderBlockFlow::RenderBlockFlowRareData&gt;(*this);</span>
3664 }
3665 
3666 #if ENABLE(TEXT_AUTOSIZING)
3667 
3668 static inline bool isVisibleRenderText(const RenderObject&amp; renderer)
3669 {
3670     if (!is&lt;RenderText&gt;(renderer))
3671         return false;
3672 
3673     auto&amp; renderText = downcast&lt;RenderText&gt;(renderer);
3674     return !renderText.linesBoundingBox().isEmpty() &amp;&amp; !renderText.text().isAllSpecialCharacters&lt;isHTMLSpace&gt;();
3675 }
3676 
3677 static inline bool resizeTextPermitted(const RenderObject&amp; renderer)
3678 {
3679     // We disallow resizing for text input fields and textarea to address &lt;rdar://problem/5792987&gt; and &lt;rdar://problem/8021123&gt;
3680     for (auto* ancestor = renderer.parent(); ancestor; ancestor = ancestor-&gt;parent()) {
3681         // Get the first non-shadow HTMLElement and see if it&#39;s an input.
3682         if (is&lt;HTMLElement&gt;(ancestor-&gt;element()) &amp;&amp; !ancestor-&gt;element()-&gt;isInShadowTree()) {
3683             auto&amp; element = downcast&lt;HTMLElement&gt;(*ancestor-&gt;element());
</pre>
<hr />
<pre>
3759         if (!isVisibleRenderText(*descendant) || !resizeTextPermitted(*descendant)) {
3760             descendant = RenderObjectTraversal::next(*descendant, this);
3761             continue;
3762         }
3763 
3764         auto&amp; text = downcast&lt;RenderText&gt;(*descendant);
3765         auto&amp; oldStyle = text.style();
3766         auto&amp; fontDescription = oldStyle.fontDescription();
3767         float specifiedSize = fontDescription.specifiedSize();
3768         float scaledSize = roundf(specifiedSize * scale);
3769         if (scaledSize &gt; 0 &amp;&amp; scaledSize &lt; minFontSize) {
3770             // Record the width of the block and the line count the first time we resize text and use it from then on for text resizing.
3771             // This makes text resizing consistent even if the block&#39;s width or line count changes (which can be caused by text resizing itself 5159915).
3772             if (m_lineCountForTextAutosizing == NOT_SET)
3773                 m_lineCountForTextAutosizing = lineCount;
3774             if (m_widthForTextAutosizing == -1)
3775                 m_widthForTextAutosizing = actualWidth;
3776 
3777             float lineTextMultiplier = lineCount == ONE_LINE ? oneLineTextMultiplier(text, specifiedSize) : textMultiplier(text, specifiedSize);
3778             float candidateNewSize = roundf(std::min(minFontSize, specifiedSize * lineTextMultiplier));

3779             if (candidateNewSize &gt; specifiedSize &amp;&amp; candidateNewSize != fontDescription.computedSize() &amp;&amp; text.textNode() &amp;&amp; oldStyle.textSizeAdjust().isAuto())
3780                 document().textAutoSizing().addTextNode(*text.textNode(), candidateNewSize);
3781         }
3782 
3783         descendant = RenderObjectTraversal::nextSkippingChildren(text, this);
3784     }
3785 }
3786 
3787 #endif // ENABLE(TEXT_AUTOSIZING)
3788 
3789 void RenderBlockFlow::layoutExcludedChildren(bool relayoutChildren)
3790 {
3791     RenderBlock::layoutExcludedChildren(relayoutChildren);
3792 
3793     auto* fragmentedFlow = multiColumnFlow();
3794     if (!fragmentedFlow)
3795         return;
3796 
3797     fragmentedFlow-&gt;setIsExcludedFromNormalLayout(true);
3798 
</pre>
<hr />
<pre>
4172                         &amp;&amp; ((prevFloat-&gt;style().floating() == Float::Left &amp;&amp; (childStyle.clear() == Clear::Left || childStyle.clear() == Clear::Both))
4173                             || (prevFloat-&gt;style().floating() == Float::Right &amp;&amp; (childStyle.clear() == Clear::Right || childStyle.clear() == Clear::Both))));
4174                     prevFloat = child;
4175                 } else
4176                     clearPreviousFloat = false;
4177 
4178                 bool canBreakReplacedElement = !child-&gt;isImage() || allowImagesToBreak;
4179                 if (((canBreakReplacedElement &amp;&amp; (autoWrap || oldAutoWrap) &amp;&amp; (!isPrevChildInlineFlow || shouldBreakLineAfterText)) || clearPreviousFloat)) {
4180                     minLogicalWidth = preferredWidth(minLogicalWidth, inlineMin);
4181                     inlineMin = 0;
4182                 }
4183 
4184                 // If we&#39;re supposed to clear the previous float, then terminate maxwidth as well.
4185                 if (clearPreviousFloat) {
4186                     maxLogicalWidth = preferredWidth(maxLogicalWidth, inlineMax);
4187                     inlineMax = 0;
4188                 }
4189 
4190                 // Add in text-indent. This is added in only once.
4191                 if (!addedTextIndent &amp;&amp; !child-&gt;isFloating()) {
<span class="line-modified">4192                     LayoutUnit ceiledIndent = textIndent.ceilToFloat();</span>
4193                     childMin += ceiledIndent;
4194                     childMax += ceiledIndent;
4195 
4196                     if (childMin &lt; 0)
4197                         textIndent = LayoutUnit::fromFloatCeil(childMin);
4198                     else
4199                         addedTextIndent = true;
4200                 }
4201 
4202                 if (canHangPunctuationAtStart &amp;&amp; !addedStartPunctuationHang &amp;&amp; !child-&gt;isFloating())
4203                     addedStartPunctuationHang = true;
4204 
4205                 // Add our width to the max.
4206                 inlineMax += std::max&lt;float&gt;(0, childMax);
4207 
4208                 if ((!autoWrap || !canBreakReplacedElement || (isPrevChildInlineFlow &amp;&amp; !shouldBreakLineAfterText))) {
4209                     if (child-&gt;isFloating())
4210                         minLogicalWidth = preferredWidth(minLogicalWidth, childMin);
4211                     else
4212                         inlineMin += childMin;
</pre>
</td>
<td>
<hr />
<pre>
   7  *
   8  * This library is free software; you can redistribute it and/or
   9  * modify it under the terms of the GNU Library General Public
  10  * License as published by the Free Software Foundation; either
  11  * version 2 of the License, or (at your option) any later version.
  12  *
  13  * This library is distributed in the hope that it will be useful,
  14  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  15  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  16  * Library General Public License for more details.
  17  *
  18  * You should have received a copy of the GNU Library General Public License
  19  * along with this library; see the file COPYING.LIB.  If not, write to
  20  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  21  * Boston, MA 02110-1301, USA.
  22  */
  23 
  24 #include &quot;config.h&quot;
  25 #include &quot;RenderBlockFlow.h&quot;
  26 
<span class="line-added">  27 #include &quot;ComplexLineLayout.h&quot;</span>
  28 #include &quot;Editor.h&quot;
  29 #include &quot;FloatingObjects.h&quot;
  30 #include &quot;Frame.h&quot;
  31 #include &quot;FrameSelection.h&quot;
  32 #include &quot;HTMLElement.h&quot;
  33 #include &quot;HTMLInputElement.h&quot;
  34 #include &quot;HTMLParserIdioms.h&quot;
  35 #include &quot;HTMLTextAreaElement.h&quot;
  36 #include &quot;HitTestLocation.h&quot;
  37 #include &quot;InlineTextBox.h&quot;
  38 #include &quot;LayoutRepainter.h&quot;
  39 #include &quot;Logging.h&quot;
  40 #include &quot;RenderCombineText.h&quot;
  41 #include &quot;RenderFlexibleBox.h&quot;
  42 #include &quot;RenderInline.h&quot;
  43 #include &quot;RenderIterator.h&quot;
  44 #include &quot;RenderLayer.h&quot;
  45 #include &quot;RenderLayoutState.h&quot;
  46 #include &quot;RenderLineBreak.h&quot;
  47 #include &quot;RenderListItem.h&quot;
</pre>
<hr />
<pre>
 135     if (!renderTreeBeingDestroyed()) {
 136         if (firstRootBox()) {
 137             // We can&#39;t wait for RenderBox::destroy to clear the selection,
 138             // because by then we will have nuked the line boxes.
 139             if (isSelectionBorder())
 140                 frame().selection().setNeedsSelectionUpdate();
 141 
 142             // If we are an anonymous block, then our line boxes might have children
 143             // that will outlast this block. In the non-anonymous block case those
 144             // children will be destroyed by the time we return from this function.
 145             if (isAnonymousBlock()) {
 146                 for (auto* box = firstRootBox(); box; box = box-&gt;nextRootBox()) {
 147                     while (auto childBox = box-&gt;firstChild())
 148                         childBox-&gt;removeFromParent();
 149                 }
 150             }
 151         } else if (parent())
 152             parent()-&gt;dirtyLinesFromChangedChild(*this);
 153     }
 154 
<span class="line-modified"> 155     if (m_complexLineLayout)</span>
<span class="line-added"> 156         m_complexLineLayout-&gt;lineBoxes().deleteLineBoxes();</span>
 157 
 158     blockWillBeDestroyed();
 159 
 160     // NOTE: This jumps down to RenderBox, bypassing RenderBlock since it would do duplicate work.
 161     RenderBox::willBeDestroyed();
 162 }
 163 
<span class="line-added"> 164 RenderMultiColumnFlow* RenderBlockFlow::multiColumnFlowSlowCase() const</span>
<span class="line-added"> 165 {</span>
<span class="line-added"> 166     return rareBlockFlowData()-&gt;m_multiColumnFlow.get();</span>
<span class="line-added"> 167 }</span>
<span class="line-added"> 168 </span>
 169 RenderBlockFlow* RenderBlockFlow::previousSiblingWithOverhangingFloats(bool&amp; parentHasFloats) const
 170 {
 171     // Attempt to locate a previous sibling with overhanging floats. We skip any elements that are
 172     // out of flow (like floating/positioned elements), and we also skip over any objects that may have shifted
 173     // to avoid floats.
 174     parentHasFloats = false;
 175     for (RenderObject* sibling = previousSibling(); sibling; sibling = sibling-&gt;previousSibling()) {
 176         if (is&lt;RenderBlockFlow&gt;(*sibling)) {
 177             auto&amp; siblingBlock = downcast&lt;RenderBlockFlow&gt;(*sibling);
 178             if (!siblingBlock.avoidsFloats())
 179                 return &amp;siblingBlock;
 180         }
 181         if (sibling-&gt;isFloating())
 182             parentHasFloats = true;
 183     }
 184     return nullptr;
 185 }
 186 
 187 void RenderBlockFlow::rebuildFloatingObjectSetFromIntrudingFloats()
 188 {
</pre>
<hr />
<pre>
 378     if (style().columnGap().isNormal())
 379         return style().fontDescription().computedPixelSize(); // &quot;1em&quot; is recommended as the normal gap setting. Matches &lt;p&gt; margins.
 380     return valueForLength(style().columnGap().length(), availableLogicalWidth());
 381 }
 382 
 383 void RenderBlockFlow::computeColumnCountAndWidth()
 384 {
 385     // Calculate our column width and column count.
 386     // FIXME: Can overflow on fast/block/float/float-not-removed-from-next-sibling4.html, see https://bugs.webkit.org/show_bug.cgi?id=68744
 387     unsigned desiredColumnCount = 1;
 388     LayoutUnit desiredColumnWidth = contentLogicalWidth();
 389 
 390     // For now, we don&#39;t support multi-column layouts when printing, since we have to do a lot of work for proper pagination.
 391     if (document().paginated() || (style().hasAutoColumnCount() &amp;&amp; style().hasAutoColumnWidth()) || !style().hasInlineColumnAxis()) {
 392         setComputedColumnCountAndWidth(desiredColumnCount, desiredColumnWidth);
 393         return;
 394     }
 395 
 396     LayoutUnit availWidth = desiredColumnWidth;
 397     LayoutUnit colGap = columnGap();
<span class="line-modified"> 398     LayoutUnit colWidth = std::max(1_lu, LayoutUnit(style().columnWidth()));</span>
 399     unsigned colCount = std::max&lt;unsigned&gt;(1, style().columnCount());
 400 
 401     if (style().hasAutoColumnWidth() &amp;&amp; !style().hasAutoColumnCount()) {
 402         desiredColumnCount = colCount;
 403         desiredColumnWidth = std::max&lt;LayoutUnit&gt;(0, (availWidth - ((desiredColumnCount - 1) * colGap)) / desiredColumnCount);
 404     } else if (!style().hasAutoColumnWidth() &amp;&amp; style().hasAutoColumnCount()) {
 405         desiredColumnCount = std::max&lt;unsigned&gt;(1, ((availWidth + colGap) / (colWidth + colGap)).toUnsigned());
 406         desiredColumnWidth = ((availWidth + colGap) / desiredColumnCount) - colGap;
 407     } else {
 408         desiredColumnCount = std::max&lt;unsigned&gt;(std::min(colCount, ((availWidth + colGap) / (colWidth + colGap)).toUnsigned()), 1);
 409         desiredColumnWidth = ((availWidth + colGap) / desiredColumnCount) - colGap;
 410     }
 411     setComputedColumnCountAndWidth(desiredColumnCount, desiredColumnWidth);
 412 }
 413 
 414 bool RenderBlockFlow::willCreateColumns(Optional&lt;unsigned&gt; desiredColumnCount) const
 415 {
 416     // The following types are not supposed to create multicol context.
 417     if (isFileUploadControl() || isTextControl() || isListBox())
 418         return false;
</pre>
<hr />
<pre>
 659         // Lay out the child.
 660         layoutBlockChild(child, marginInfo, previousFloatLogicalBottom, maxFloatLogicalBottom);
 661     }
 662 
 663     // Now do the handling of the bottom of the block, adding in our bottom border/padding and
 664     // determining the correct collapsed bottom margin information.
 665     handleAfterSideOfBlock(beforeEdge, afterEdge, marginInfo);
 666 }
 667 
 668 void RenderBlockFlow::layoutInlineChildren(bool relayoutChildren, LayoutUnit&amp; repaintLogicalTop, LayoutUnit&amp; repaintLogicalBottom)
 669 {
 670     if (lineLayoutPath() == UndeterminedPath)
 671         setLineLayoutPath(SimpleLineLayout::canUseFor(*this) ? SimpleLinesPath : LineBoxesPath);
 672 
 673     if (lineLayoutPath() == SimpleLinesPath) {
 674         layoutSimpleLines(relayoutChildren, repaintLogicalTop, repaintLogicalBottom);
 675         return;
 676     }
 677 
 678     m_simpleLineLayout = nullptr;
<span class="line-modified"> 679 </span>
<span class="line-added"> 680     if (!m_complexLineLayout)</span>
<span class="line-added"> 681         m_complexLineLayout = makeUnique&lt;ComplexLineLayout&gt;(*this);</span>
<span class="line-added"> 682 </span>
<span class="line-added"> 683     m_complexLineLayout-&gt;layoutLineBoxes(relayoutChildren, repaintLogicalTop, repaintLogicalBottom);</span>
 684 }
 685 
 686 void RenderBlockFlow::layoutBlockChild(RenderBox&amp; child, MarginInfo&amp; marginInfo, LayoutUnit&amp; previousFloatLogicalBottom, LayoutUnit&amp; maxFloatLogicalBottom)
 687 {
 688     LayoutUnit oldPosMarginBefore = maxPositiveMarginBefore();
 689     LayoutUnit oldNegMarginBefore = maxNegativeMarginBefore();
 690 
 691     // The child is a normal flow object. Compute the margins we will use for collapsing now.
 692     child.computeAndSetBlockDirectionMargins(*this);
 693 
 694     // Try to guess our correct logical top position. In most cases this guess will
 695     // be correct. Only if we&#39;re wrong (when we compute the real logical top position)
 696     // will we have to potentially relayout.
 697     LayoutUnit estimateWithoutPagination;
 698     LayoutUnit logicalTopEstimate = estimateLogicalTopPosition(child, marginInfo, estimateWithoutPagination);
 699 
 700     // Cache our old rect so that we can dirty the proper repaint rects if the child moves.
 701     LayoutRect oldRect = child.frameRect();
 702     LayoutUnit oldLogicalTop = logicalTopForChild(child);
 703 
</pre>
<hr />
<pre>
 899     setLogicalHeight(logicalHeight() - marginOffset);
 900 }
 901 
 902 void RenderBlockFlow::updateStaticInlinePositionForChild(RenderBox&amp; child, LayoutUnit logicalTop, IndentTextOrNot shouldIndentText)
 903 {
 904     if (child.style().isOriginalDisplayInlineType())
 905         setStaticInlinePositionForChild(child, logicalTop, startAlignedOffsetForLine(logicalTop, shouldIndentText));
 906     else
 907         setStaticInlinePositionForChild(child, logicalTop, startOffsetForContent(logicalTop));
 908 }
 909 
 910 void RenderBlockFlow::setStaticInlinePositionForChild(RenderBox&amp; child, LayoutUnit blockOffset, LayoutUnit inlinePosition)
 911 {
 912     if (enclosingFragmentedFlow()) {
 913         // Shift the inline position to exclude the fragment offset.
 914         inlinePosition += startOffsetForContent() - startOffsetForContent(blockOffset);
 915     }
 916     child.layer()-&gt;setStaticInlinePosition(inlinePosition);
 917 }
 918 
<span class="line-added"> 919 LayoutUnit RenderBlockFlow::startAlignedOffsetForLine(LayoutUnit position, IndentTextOrNot shouldIndentText)</span>
<span class="line-added"> 920 {</span>
<span class="line-added"> 921     TextAlignMode textAlign = style().textAlign();</span>
<span class="line-added"> 922     bool shouldApplyIndentText = false;</span>
<span class="line-added"> 923     switch (textAlign) {</span>
<span class="line-added"> 924     case TextAlignMode::Left:</span>
<span class="line-added"> 925     case TextAlignMode::WebKitLeft:</span>
<span class="line-added"> 926         shouldApplyIndentText = style().isLeftToRightDirection();</span>
<span class="line-added"> 927         break;</span>
<span class="line-added"> 928     case TextAlignMode::Right:</span>
<span class="line-added"> 929     case TextAlignMode::WebKitRight:</span>
<span class="line-added"> 930         shouldApplyIndentText = !style().isLeftToRightDirection();</span>
<span class="line-added"> 931         break;</span>
<span class="line-added"> 932     case TextAlignMode::Start:</span>
<span class="line-added"> 933         shouldApplyIndentText = true;</span>
<span class="line-added"> 934         break;</span>
<span class="line-added"> 935     default:</span>
<span class="line-added"> 936         shouldApplyIndentText = false;</span>
<span class="line-added"> 937     }</span>
<span class="line-added"> 938     // &lt;rdar://problem/15427571&gt;</span>
<span class="line-added"> 939     // https://bugs.webkit.org/show_bug.cgi?id=124522</span>
<span class="line-added"> 940     // This quirk is for legacy content that doesn&#39;t work properly with the center positioning scheme</span>
<span class="line-added"> 941     // being honored (e.g., epubs).</span>
<span class="line-added"> 942     if (shouldApplyIndentText || settings().useLegacyTextAlignPositionedElementBehavior()) // FIXME: Handle TextAlignMode::End here</span>
<span class="line-added"> 943         return startOffsetForLine(position, shouldIndentText);</span>
<span class="line-added"> 944 </span>
<span class="line-added"> 945     // updateLogicalWidthForAlignment() handles the direction of the block so no need to consider it here</span>
<span class="line-added"> 946     float totalLogicalWidth = 0;</span>
<span class="line-added"> 947     float logicalLeft = logicalLeftOffsetForLine(logicalHeight(), DoNotIndentText);</span>
<span class="line-added"> 948     float availableLogicalWidth = logicalRightOffsetForLine(logicalHeight(), DoNotIndentText) - logicalLeft;</span>
<span class="line-added"> 949 </span>
<span class="line-added"> 950     ComplexLineLayout::updateLogicalWidthForAlignment(*this, textAlign, nullptr, nullptr, logicalLeft, totalLogicalWidth, availableLogicalWidth, 0);</span>
<span class="line-added"> 951 </span>
<span class="line-added"> 952     if (!style().isLeftToRightDirection())</span>
<span class="line-added"> 953         return LayoutUnit(logicalWidth() - logicalLeft);</span>
<span class="line-added"> 954 </span>
<span class="line-added"> 955     return LayoutUnit(logicalLeft);</span>
<span class="line-added"> 956 }</span>
<span class="line-added"> 957 </span>
 958 RenderBlockFlow::MarginValues RenderBlockFlow::marginValuesForChild(RenderBox&amp; child) const
 959 {
 960     LayoutUnit childBeforePositive;
 961     LayoutUnit childBeforeNegative;
 962     LayoutUnit childAfterPositive;
 963     LayoutUnit childAfterNegative;
 964 
 965     LayoutUnit beforeMargin;
 966     LayoutUnit afterMargin;
 967 
 968     RenderBlockFlow* childRenderBlock = is&lt;RenderBlockFlow&gt;(child) ? &amp;downcast&lt;RenderBlockFlow&gt;(child) : nullptr;
 969 
 970     // If the child has the same directionality as we do, then we can just return its
 971     // margins in the same direction.
 972     if (!child.isWritingModeRoot()) {
 973         if (childRenderBlock) {
 974             childBeforePositive = childRenderBlock-&gt;maxPositiveMarginBefore();
 975             childBeforeNegative = childRenderBlock-&gt;maxNegativeMarginBefore();
 976             childAfterPositive = childRenderBlock-&gt;maxPositiveMarginAfter();
 977             childAfterNegative = childRenderBlock-&gt;maxNegativeMarginAfter();
</pre>
<hr />
<pre>
2002         return remainingHeight;
2003     }
2004 
2005     return fragmentedFlow-&gt;pageRemainingLogicalHeightForOffset(offset, pageBoundaryRule);
2006 }
2007 
2008 LayoutUnit RenderBlockFlow::logicalHeightForChildForFragmentation(const RenderBox&amp; child) const
2009 {
2010     return logicalHeightForChild(child);
2011 }
2012 
2013 void RenderBlockFlow::layoutLineGridBox()
2014 {
2015     if (style().lineGrid() == RenderStyle::initialLineGrid()) {
2016         setLineGridBox(0);
2017         return;
2018     }
2019 
2020     setLineGridBox(0);
2021 
<span class="line-modified">2022     auto lineGridBox = makeUnique&lt;RootInlineBox&gt;(*this);</span>
2023     lineGridBox-&gt;setHasTextChildren(); // Needed to make the line ascent/descent actually be honored in quirks mode.
2024     lineGridBox-&gt;setConstructed();
2025     GlyphOverflowAndFallbackFontsMap textBoxDataMap;
2026     VerticalPositionCache verticalPositionCache;
2027     lineGridBox-&gt;alignBoxesInBlockDirection(logicalHeight(), textBoxDataMap, verticalPositionCache);
2028 
2029     setLineGridBox(WTFMove(lineGridBox));
2030 
2031     // FIXME: If any of the characteristics of the box change compared to the old one, then we need to do a deep dirtying
2032     // (similar to what happens when the page height changes). Ideally, though, we only do this if someone is actually snapping
2033     // to this grid.
2034 }
2035 
2036 bool RenderBlockFlow::containsFloat(RenderBox&amp; renderer) const
2037 {
2038     return m_floatingObjects &amp;&amp; m_floatingObjects-&gt;set().contains&lt;FloatingObjectHashTranslator&gt;(renderer);
2039 }
2040 
2041 void RenderBlockFlow::styleDidChange(StyleDifference diff, const RenderStyle* oldStyle)
2042 {
</pre>
<hr />
<pre>
2092 
2093     if (oldStyle) {
2094         auto oldPosition = oldStyle-&gt;position();
2095         auto newPosition = newStyle.position();
2096 
2097         if (parent() &amp;&amp; diff == StyleDifference::Layout &amp;&amp; oldPosition != newPosition) {
2098             if (containsFloats() &amp;&amp; !isFloating() &amp;&amp; !isOutOfFlowPositioned() &amp;&amp; newStyle.hasOutOfFlowPosition())
2099                 markAllDescendantsWithFloatsForLayout();
2100         }
2101     }
2102 
2103     RenderBlock::styleWillChange(diff, newStyle);
2104 }
2105 
2106 void RenderBlockFlow::deleteLines()
2107 {
2108     if (containsFloats())
2109         m_floatingObjects-&gt;clearLineBoxTreePointers();
2110 
2111     if (m_simpleLineLayout) {
<span class="line-modified">2112         ASSERT(!m_complexLineLayout);</span>
2113         m_simpleLineLayout = nullptr;
<span class="line-modified">2114     } else if (m_complexLineLayout)</span>
<span class="line-modified">2115         m_complexLineLayout-&gt;lineBoxes().deleteLineBoxTree();</span>
2116 
2117     RenderBlock::deleteLines();
2118 }
2119 
2120 void RenderBlockFlow::addFloatsToNewParent(RenderBlockFlow&amp; toBlockFlow) const
2121 {
2122     // When a portion of the render tree is being detached, anonymous blocks
2123     // will be combined as their children are deleted. In this process, the
2124     // anonymous block later in the tree is merged into the one preceeding it.
2125     // It can happen that the later block (this) contains floats that the
2126     // previous block (toBlockFlow) did not contain, and thus are not in the
2127     // floating objects list for toBlockFlow. This can result in toBlockFlow
2128     // containing floats that are not in it&#39;s floating objects list, but are in
2129     // the floating objects lists of siblings and parents. This can cause
2130     // problems when the float itself is deleted, since the deletion code
2131     // assumes that if a float is not in it&#39;s containing block&#39;s floating
2132     // objects list, it isn&#39;t in any floating objects list. In order to
2133     // preserve this condition (removing it has serious performance
2134     // implications), we need to copy the floating objects from the old block
2135     // (this) to the new block (toBlockFlow). The float&#39;s metrics will likely
</pre>
<hr />
<pre>
2243 }
2244 
2245 void RenderBlockFlow::clipOutFloatingObjects(RenderBlock&amp; rootBlock, const PaintInfo* paintInfo, const LayoutPoint&amp; rootBlockPhysicalPosition, const LayoutSize&amp; offsetFromRootBlock)
2246 {
2247     if (m_floatingObjects) {
2248         const FloatingObjectSet&amp; floatingObjectSet = m_floatingObjects-&gt;set();
2249         auto end = floatingObjectSet.end();
2250         for (auto it = floatingObjectSet.begin(); it != end; ++it) {
2251             const auto&amp; floatingObject = *it-&gt;get();
2252             LayoutRect floatBox(offsetFromRootBlock.width(), offsetFromRootBlock.height(), floatingObject.renderer().width(), floatingObject.renderer().height());
2253             floatBox.move(floatingObject.locationOffsetOfBorderBox());
2254             rootBlock.flipForWritingMode(floatBox);
2255             floatBox.move(rootBlockPhysicalPosition.x(), rootBlockPhysicalPosition.y());
2256             paintInfo-&gt;context().clipOut(snappedIntRect(floatBox));
2257         }
2258     }
2259 }
2260 
2261 void RenderBlockFlow::createFloatingObjects()
2262 {
<span class="line-modified">2263     m_floatingObjects = makeUnique&lt;FloatingObjects&gt;(*this);</span>
2264 }
2265 
2266 void RenderBlockFlow::removeFloatingObjects()
2267 {
2268     if (!m_floatingObjects)
2269         return;
2270 
2271     markSiblingsWithFloatsForLayout();
2272 
2273     m_floatingObjects-&gt;clear();
2274 }
2275 
2276 FloatingObject* RenderBlockFlow::insertFloatingObject(RenderBox&amp; floatBox)
2277 {
2278     ASSERT(floatBox.isFloating());
2279 
2280     // Create the list of special objects if we don&#39;t aleady have one
2281     if (!m_floatingObjects)
2282         createFloatingObjects();
2283     else {
</pre>
<hr />
<pre>
2932         auto&amp; renderer = floatingObject.renderer();
2933         if (floatingObject.shouldPaint() &amp;&amp; !renderer.hasSelfPaintingLayer()) {
2934             LayoutPoint childPoint = flipFloatForWritingModeForChild(floatingObject, adjustedLocation + floatingObject.translationOffsetToAncestor());
2935             if (renderer.hitTest(request, result, locationInContainer, childPoint)) {
2936                 updateHitTestResult(result, locationInContainer.point() - toLayoutSize(childPoint));
2937                 return true;
2938             }
2939         }
2940     }
2941 
2942     return false;
2943 }
2944 
2945 bool RenderBlockFlow::hitTestInlineChildren(const HitTestRequest&amp; request, HitTestResult&amp; result, const HitTestLocation&amp; locationInContainer, const LayoutPoint&amp; accumulatedOffset, HitTestAction hitTestAction)
2946 {
2947     ASSERT(childrenInline());
2948 
2949     if (auto simpleLineLayout = this-&gt;simpleLineLayout())
2950         return SimpleLineLayout::hitTestFlow(*this, *simpleLineLayout, request, result, locationInContainer, accumulatedOffset, hitTestAction);
2951 
<span class="line-modified">2952     return m_complexLineLayout &amp;&amp; m_complexLineLayout-&gt;lineBoxes().hitTest(this, request, result, locationInContainer, accumulatedOffset, hitTestAction);</span>
<span class="line-added">2953 }</span>
<span class="line-added">2954 </span>
<span class="line-added">2955 void RenderBlockFlow::addOverflowFromInlineChildren()</span>
<span class="line-added">2956 {</span>
<span class="line-added">2957     if (auto simpleLineLayout = this-&gt;simpleLineLayout()) {</span>
<span class="line-added">2958         ASSERT(!hasOverflowClip());</span>
<span class="line-added">2959         SimpleLineLayout::collectFlowOverflow(*this, *simpleLineLayout);</span>
<span class="line-added">2960         return;</span>
<span class="line-added">2961     }</span>
<span class="line-added">2962 </span>
<span class="line-added">2963     m_complexLineLayout-&gt;addOverflowFromInlineChildren();</span>
2964 }
2965 
2966 void RenderBlockFlow::adjustForBorderFit(LayoutUnit x, LayoutUnit&amp; left, LayoutUnit&amp; right) const
2967 {
2968     if (style().visibility() != Visibility::Visible)
2969         return;
2970 
2971     // We don&#39;t deal with relative positioning.  Our assumption is that you shrink to fit the lines without accounting
2972     // for either overflow or translations via relative positioning.
2973     if (childrenInline()) {
2974         const_cast&lt;RenderBlockFlow&amp;&gt;(*this).ensureLineBoxes();
2975 
2976         for (auto* box = firstRootBox(); box; box = box-&gt;nextRootBox()) {
2977             if (box-&gt;firstChild())
2978                 left = std::min(left, x + LayoutUnit(box-&gt;firstChild()-&gt;x()));
2979             if (box-&gt;lastChild())
2980                 right = std::max(right, x + LayoutUnit(ceilf(box-&gt;lastChild()-&gt;logicalRight())));
2981         }
2982     } else {
2983         for (RenderBox* obj = firstChildBox(); obj; obj = obj-&gt;nextSiblingBox()) {
</pre>
<hr />
<pre>
3140             lastLogicalTop = blockDirectionOffset(rootBlock, offsetFromRootBlock) + logicalHeight();
3141             lastLogicalLeft = logicalLeftSelectionOffset(rootBlock, logicalHeight(), cache);
3142             lastLogicalRight = logicalRightSelectionOffset(rootBlock, logicalHeight(), cache);
3143         }
3144         return result;
3145     }
3146 
3147     RootInlineBox* lastSelectedLine = 0;
3148     RootInlineBox* curr;
3149     for (curr = firstRootBox(); curr &amp;&amp; !curr-&gt;hasSelectedChildren(); curr = curr-&gt;nextRootBox()) { }
3150 
3151     // Now paint the gaps for the lines.
3152     for (; curr &amp;&amp; curr-&gt;hasSelectedChildren(); curr = curr-&gt;nextRootBox()) {
3153         LayoutUnit selTop =  curr-&gt;selectionTopAdjustedForPrecedingBlock();
3154         LayoutUnit selHeight = curr-&gt;selectionHeightAdjustedForPrecedingBlock();
3155 
3156         if (!containsStart &amp;&amp; !lastSelectedLine &amp;&amp;
3157             selectionState() != SelectionStart &amp;&amp; selectionState() != SelectionBoth &amp;&amp; !isRubyBase())
3158             result.uniteCenter(blockSelectionGap(rootBlock, rootBlockPhysicalPosition, offsetFromRootBlock, lastLogicalTop, lastLogicalLeft, lastLogicalRight, selTop, cache, paintInfo));
3159 
<span class="line-modified">3160         LayoutRect logicalRect { LayoutUnit(curr-&gt;logicalLeft()), selTop, LayoutUnit(curr-&gt;logicalWidth()), selTop + selHeight };</span>
3161         logicalRect.move(isHorizontalWritingMode() ? offsetFromRootBlock : offsetFromRootBlock.transposedSize());
3162         LayoutRect physicalRect = rootBlock.logicalRectToPhysicalRect(rootBlockPhysicalPosition, logicalRect);
3163         if (!paintInfo || (isHorizontalWritingMode() &amp;&amp; physicalRect.y() &lt; paintInfo-&gt;rect.maxY() &amp;&amp; physicalRect.maxY() &gt; paintInfo-&gt;rect.y())
3164             || (!isHorizontalWritingMode() &amp;&amp; physicalRect.x() &lt; paintInfo-&gt;rect.maxX() &amp;&amp; physicalRect.maxX() &gt; paintInfo-&gt;rect.x()))
3165             result.unite(curr-&gt;lineSelectionGap(rootBlock, rootBlockPhysicalPosition, offsetFromRootBlock, selTop, selHeight, cache, paintInfo));
3166 
3167         lastSelectedLine = curr;
3168     }
3169 
3170     if (containsStart &amp;&amp; !lastSelectedLine)
3171         // VisibleSelection must start just after our last line.
3172         lastSelectedLine = lastRootBox();
3173 
3174     if (lastSelectedLine &amp;&amp; selectionState() != SelectionEnd &amp;&amp; selectionState() != SelectionBoth) {
3175         // Update our lastY to be the bottom of the last selected line.
3176         lastLogicalTop = blockDirectionOffset(rootBlock, offsetFromRootBlock) + lastSelectedLine-&gt;selectionBottom();
3177         lastLogicalLeft = logicalLeftSelectionOffset(rootBlock, lastSelectedLine-&gt;selectionBottom(), cache);
3178         lastLogicalRight = logicalRightSelectionOffset(rootBlock, lastSelectedLine-&gt;selectionBottom(), cache);
3179     }
3180     return result;
</pre>
<hr />
<pre>
3456 
3457                 if (nextRootBoxWithChildren &amp;&amp; nextRootBoxWithChildren-&gt;isFirstAfterPageBreak() &amp;&amp; (pointInLogicalContents.y() &gt; nextRootBoxWithChildren-&gt;lineTopWithLeading()
3458                     || (!blocksAreFlipped &amp;&amp; pointInLogicalContents.y() == nextRootBoxWithChildren-&gt;lineTopWithLeading())))
3459                     continue;
3460             }
3461             closestBox = root-&gt;closestLeafChildForLogicalLeftPosition(pointInLogicalContents.x());
3462             if (closestBox)
3463                 break;
3464         }
3465     }
3466 
3467     bool moveCaretToBoundary = frame().editor().behavior().shouldMoveCaretToHorizontalBoundaryWhenPastTopOrBottom();
3468 
3469     if (!moveCaretToBoundary &amp;&amp; !closestBox &amp;&amp; lastRootBoxWithChildren) {
3470         // y coordinate is below last root line box, pretend we hit it
3471         closestBox = lastRootBoxWithChildren-&gt;closestLeafChildForLogicalLeftPosition(pointInLogicalContents.x());
3472     }
3473 
3474     if (closestBox) {
3475         if (moveCaretToBoundary) {
<span class="line-modified">3476             LayoutUnit firstRootBoxWithChildrenTop = std::min(firstRootBoxWithChildren-&gt;selectionTop(), LayoutUnit(firstRootBoxWithChildren-&gt;logicalTop()));</span>
3477             if (pointInLogicalContents.y() &lt; firstRootBoxWithChildrenTop
3478                 || (blocksAreFlipped &amp;&amp; pointInLogicalContents.y() == firstRootBoxWithChildrenTop)) {
3479                 InlineBox* box = firstRootBoxWithChildren-&gt;firstLeafChild();
3480                 if (box-&gt;isLineBreak()) {
3481                     if (InlineBox* newBox = box-&gt;nextLeafChildIgnoringLineBreak())
3482                         box = newBox;
3483                 }
3484                 // y coordinate is above first root line box, so return the start of the first
3485                 return VisiblePosition(positionForBox(box, true), DOWNSTREAM);
3486             }
3487         }
3488 
3489         // pass the box a top position that is inside it
3490         LayoutPoint point(pointInLogicalContents.x(), closestBox-&gt;root().blockDirectionPointInLine());
3491         if (!isHorizontalWritingMode())
3492             point = point.transposedPoint();
3493         if (closestBox-&gt;renderer().isReplaced())
3494             return positionForPointRespectingEditingBoundaries(*this, downcast&lt;RenderBox&gt;(closestBox-&gt;renderer()), point);
3495         return closestBox-&gt;renderer().positionForPoint(point, nullptr);
3496     }
</pre>
<hr />
<pre>
3509     return createVisiblePosition(0, DOWNSTREAM);
3510 }
3511 
3512 Position RenderBlockFlow::positionForPoint(const LayoutPoint&amp; point)
3513 {
3514     // FIXME: It supports single text child only (which is the majority of simple line layout supported content at this point).
3515     if (!simpleLineLayout() || firstChild() != lastChild() || !is&lt;RenderText&gt;(firstChild()))
3516         return positionForPoint(point, nullptr).deepEquivalent();
3517     return downcast&lt;RenderText&gt;(*firstChild()).positionForPoint(point);
3518 }
3519 
3520 VisiblePosition RenderBlockFlow::positionForPoint(const LayoutPoint&amp; point, const RenderFragmentContainer*)
3521 {
3522     return RenderBlock::positionForPoint(point, nullptr);
3523 }
3524 
3525 void RenderBlockFlow::addFocusRingRectsForInlineChildren(Vector&lt;LayoutRect&gt;&amp; rects, const LayoutPoint&amp; additionalOffset, const RenderLayerModelObject*)
3526 {
3527     ASSERT(childrenInline());
3528     for (RootInlineBox* curr = firstRootBox(); curr; curr = curr-&gt;nextRootBox()) {
<span class="line-modified">3529         LayoutUnit top = std::max(curr-&gt;lineTop(), LayoutUnit(curr-&gt;top()));</span>
<span class="line-modified">3530         LayoutUnit bottom = std::min(curr-&gt;lineBottom(), LayoutUnit(curr-&gt;top() + curr-&gt;height()));</span>
<span class="line-modified">3531         LayoutRect rect { LayoutUnit(additionalOffset.x() + curr-&gt;x()), additionalOffset.y() + top, LayoutUnit(curr-&gt;width()), bottom - top };</span>
3532         if (!rect.isEmpty())
3533             rects.append(rect);
3534     }
3535 }
3536 
3537 void RenderBlockFlow::paintInlineChildren(PaintInfo&amp; paintInfo, const LayoutPoint&amp; paintOffset)
3538 {
3539     ASSERT(childrenInline());
3540 
3541     if (auto simpleLineLayout = this-&gt;simpleLineLayout()) {
3542         SimpleLineLayout::paintFlow(*this, *simpleLineLayout, paintInfo, paintOffset);
3543         return;
3544     }
<span class="line-modified">3545 </span>
<span class="line-added">3546     if (m_complexLineLayout)</span>
<span class="line-added">3547         m_complexLineLayout-&gt;lineBoxes().paint(this, paintInfo, paintOffset);</span>
3548 }
3549 
3550 bool RenderBlockFlow::relayoutForPagination()
3551 {
3552     if (!multiColumnFlow() || !multiColumnFlow()-&gt;shouldRelayoutForPagination())
3553         return false;
3554 
3555     multiColumnFlow()-&gt;setNeedsHeightsRecalculation(false);
3556     multiColumnFlow()-&gt;setInBalancingPass(true); // Prevent re-entering this method (and recursion into layout).
3557 
3558     bool needsRelayout;
3559     bool neededRelayout = false;
3560     bool firstPass = true;
3561     do {
3562         // Column heights may change here because of balancing. We may have to do multiple layout
3563         // passes, depending on how the contents is fitted to the changed column heights. In most
3564         // cases, laying out again twice or even just once will suffice. Sometimes we need more
3565         // passes than that, though, but the number of retries should not exceed the number of
3566         // columns, unless we have a bug.
3567         needsRelayout = false;
</pre>
<hr />
<pre>
3582             multiColumnFlow()-&gt;setChildNeedsLayout(MarkOnlyThis);
3583             setChildNeedsLayout(MarkOnlyThis);
3584             layoutBlock(false);
3585         }
3586         firstPass = false;
3587     } while (needsRelayout);
3588 
3589     multiColumnFlow()-&gt;setInBalancingPass(false);
3590 
3591     return neededRelayout;
3592 }
3593 
3594 bool RenderBlockFlow::hasLines() const
3595 {
3596     if (!childrenInline())
3597         return false;
3598 
3599     if (auto simpleLineLayout = this-&gt;simpleLineLayout())
3600         return simpleLineLayout-&gt;lineCount();
3601 
<span class="line-modified">3602     return m_complexLineLayout &amp;&amp; m_complexLineLayout-&gt;lineBoxes().firstLineBox();</span>
3603 }
3604 
3605 void RenderBlockFlow::invalidateLineLayoutPath()
3606 {
3607     switch (lineLayoutPath()) {
3608     case UndeterminedPath:
3609     case ForceLineBoxesPath:
3610         ASSERT(!m_simpleLineLayout);
3611         return;
3612     case LineBoxesPath:
3613         ASSERT(!m_simpleLineLayout);
3614         setLineLayoutPath(UndeterminedPath);
3615         return;
3616     case SimpleLinesPath:
3617         // The simple line layout may have become invalid.
3618         m_simpleLineLayout = nullptr;
3619         setLineLayoutPath(UndeterminedPath);
3620         if (needsLayout())
3621             return;
3622         // FIXME: We should just kick off a subtree layout here (if needed at all) see webkit.org/b/172947.
3623         setNeedsLayout();
3624         return;
3625     }
3626     ASSERT_NOT_REACHED();
3627 }
3628 
3629 void RenderBlockFlow::layoutSimpleLines(bool relayoutChildren, LayoutUnit&amp; repaintLogicalTop, LayoutUnit&amp; repaintLogicalBottom)
3630 {
3631     bool needsLayout = selfNeedsLayout() || relayoutChildren || !m_simpleLineLayout;
3632     if (needsLayout) {
3633         deleteLineBoxesBeforeSimpleLineLayout();
3634         m_simpleLineLayout = SimpleLineLayout::create(*this);
3635     }
3636     if (view().frameView().layoutContext().layoutState() &amp;&amp; view().frameView().layoutContext().layoutState()-&gt;isPaginated()) {
3637         m_simpleLineLayout-&gt;setIsPaginated();
3638         SimpleLineLayout::adjustLinePositionsForPagination(*m_simpleLineLayout, *this);
3639     }
3640     for (auto&amp; renderer : childrenOfType&lt;RenderObject&gt;(*this))
3641         renderer.clearNeedsLayout();
<span class="line-modified">3642     ASSERT(!m_complexLineLayout);</span>
3643     LayoutUnit lineLayoutHeight = SimpleLineLayout::computeFlowHeight(*this, *m_simpleLineLayout);
3644     LayoutUnit lineLayoutTop = borderAndPaddingBefore();
3645     repaintLogicalTop = lineLayoutTop;
3646     repaintLogicalBottom = needsLayout ? repaintLogicalTop + lineLayoutHeight + borderAndPaddingAfter() : repaintLogicalTop;
3647     setLogicalHeight(lineLayoutTop + lineLayoutHeight + borderAndPaddingAfter());
3648 }
3649 
3650 void RenderBlockFlow::deleteLineBoxesBeforeSimpleLineLayout()
3651 {
3652     ASSERT(lineLayoutPath() == SimpleLinesPath);
<span class="line-modified">3653 </span>
<span class="line-added">3654     if (m_complexLineLayout)</span>
<span class="line-added">3655         m_complexLineLayout-&gt;lineBoxes().deleteLineBoxes();</span>
<span class="line-added">3656 </span>
3657     for (auto&amp; renderer : childrenOfType&lt;RenderObject&gt;(*this)) {
3658         if (is&lt;RenderText&gt;(renderer))
3659             downcast&lt;RenderText&gt;(renderer).deleteLineBoxesBeforeSimpleLineLayout();
3660         else if (is&lt;RenderLineBreak&gt;(renderer))
3661             downcast&lt;RenderLineBreak&gt;(renderer).deleteLineBoxesBeforeSimpleLineLayout();
3662         else
3663             ASSERT_NOT_REACHED();
3664     }
<span class="line-added">3665 </span>
<span class="line-added">3666     m_complexLineLayout = nullptr;</span>
3667 }
3668 
3669 void RenderBlockFlow::ensureLineBoxes()
3670 {
<span class="line-added">3671     if (!childrenInline())</span>
<span class="line-added">3672         return;</span>
<span class="line-added">3673 </span>
3674     setLineLayoutPath(ForceLineBoxesPath);
<span class="line-added">3675 </span>
3676     if (!m_simpleLineLayout)
3677         return;
3678 
<span class="line-added">3679     ASSERT(!m_complexLineLayout);</span>
<span class="line-added">3680     m_complexLineLayout = makeUnique&lt;ComplexLineLayout&gt;(*this);</span>
<span class="line-added">3681 </span>
3682     if (SimpleLineLayout::canUseForLineBoxTree(*this, *m_simpleLineLayout)) {
3683         SimpleLineLayout::generateLineBoxTree(*this, *m_simpleLineLayout);
3684         m_simpleLineLayout = nullptr;
3685         return;
3686     }
3687     bool isPaginated = m_simpleLineLayout-&gt;isPaginated();
3688     m_simpleLineLayout = nullptr;
3689 
3690 #if !ASSERT_DISABLED
3691     LayoutUnit oldHeight = logicalHeight();
3692 #endif
3693     bool didNeedLayout = needsLayout();
3694 
3695     bool relayoutChildren = false;
3696     LayoutUnit repaintLogicalTop;
3697     LayoutUnit repaintLogicalBottom;
3698     if (isPaginated) {
3699         PaginatedLayoutStateMaintainer state(*this);
<span class="line-modified">3700         m_complexLineLayout-&gt;layoutLineBoxes(relayoutChildren, repaintLogicalTop, repaintLogicalBottom);</span>
3701         // This matches relayoutToAvoidWidows.
3702         if (shouldBreakAtLineToAvoidWidow())
<span class="line-modified">3703             m_complexLineLayout-&gt;layoutLineBoxes(relayoutChildren, repaintLogicalTop, repaintLogicalBottom);</span>
3704         // FIXME: This is needed as long as simple and normal line layout produce different line breakings.
3705         repaint();
3706     } else
<span class="line-modified">3707         m_complexLineLayout-&gt;layoutLineBoxes(relayoutChildren, repaintLogicalTop, repaintLogicalBottom);</span>
3708 
3709     updateLogicalHeight();
3710     ASSERT(didNeedLayout || logicalHeight() == oldHeight);
3711 
3712     if (!didNeedLayout)
3713         clearNeedsLayout();
3714 }
3715 
3716 #if ENABLE(TREE_DEBUGGING)
3717 void RenderBlockFlow::outputLineTreeAndMark(WTF::TextStream&amp; stream, const InlineBox* markedBox, int depth) const
3718 {
3719     for (const RootInlineBox* root = firstRootBox(); root; root = root-&gt;nextRootBox())
3720         root-&gt;outputLineTreeAndMark(stream, markedBox, depth);
3721 
3722     if (auto simpleLineLayout = this-&gt;simpleLineLayout())
3723         SimpleLineLayout::outputLineLayoutForFlow(stream, *this, *simpleLineLayout, depth);
3724 }
3725 #endif
3726 
3727 RenderBlockFlow::RenderBlockFlowRareData&amp; RenderBlockFlow::ensureRareBlockFlowData()
3728 {
3729     if (hasRareBlockFlowData())
3730         return *m_rareBlockFlowData;
3731     materializeRareBlockFlowData();
3732     return *m_rareBlockFlowData;
3733 }
3734 
3735 void RenderBlockFlow::materializeRareBlockFlowData()
3736 {
3737     ASSERT(!hasRareBlockFlowData());
<span class="line-modified">3738     m_rareBlockFlowData = makeUnique&lt;RenderBlockFlow::RenderBlockFlowRareData&gt;(*this);</span>
3739 }
3740 
3741 #if ENABLE(TEXT_AUTOSIZING)
3742 
3743 static inline bool isVisibleRenderText(const RenderObject&amp; renderer)
3744 {
3745     if (!is&lt;RenderText&gt;(renderer))
3746         return false;
3747 
3748     auto&amp; renderText = downcast&lt;RenderText&gt;(renderer);
3749     return !renderText.linesBoundingBox().isEmpty() &amp;&amp; !renderText.text().isAllSpecialCharacters&lt;isHTMLSpace&gt;();
3750 }
3751 
3752 static inline bool resizeTextPermitted(const RenderObject&amp; renderer)
3753 {
3754     // We disallow resizing for text input fields and textarea to address &lt;rdar://problem/5792987&gt; and &lt;rdar://problem/8021123&gt;
3755     for (auto* ancestor = renderer.parent(); ancestor; ancestor = ancestor-&gt;parent()) {
3756         // Get the first non-shadow HTMLElement and see if it&#39;s an input.
3757         if (is&lt;HTMLElement&gt;(ancestor-&gt;element()) &amp;&amp; !ancestor-&gt;element()-&gt;isInShadowTree()) {
3758             auto&amp; element = downcast&lt;HTMLElement&gt;(*ancestor-&gt;element());
</pre>
<hr />
<pre>
3834         if (!isVisibleRenderText(*descendant) || !resizeTextPermitted(*descendant)) {
3835             descendant = RenderObjectTraversal::next(*descendant, this);
3836             continue;
3837         }
3838 
3839         auto&amp; text = downcast&lt;RenderText&gt;(*descendant);
3840         auto&amp; oldStyle = text.style();
3841         auto&amp; fontDescription = oldStyle.fontDescription();
3842         float specifiedSize = fontDescription.specifiedSize();
3843         float scaledSize = roundf(specifiedSize * scale);
3844         if (scaledSize &gt; 0 &amp;&amp; scaledSize &lt; minFontSize) {
3845             // Record the width of the block and the line count the first time we resize text and use it from then on for text resizing.
3846             // This makes text resizing consistent even if the block&#39;s width or line count changes (which can be caused by text resizing itself 5159915).
3847             if (m_lineCountForTextAutosizing == NOT_SET)
3848                 m_lineCountForTextAutosizing = lineCount;
3849             if (m_widthForTextAutosizing == -1)
3850                 m_widthForTextAutosizing = actualWidth;
3851 
3852             float lineTextMultiplier = lineCount == ONE_LINE ? oneLineTextMultiplier(text, specifiedSize) : textMultiplier(text, specifiedSize);
3853             float candidateNewSize = roundf(std::min(minFontSize, specifiedSize * lineTextMultiplier));
<span class="line-added">3854 </span>
3855             if (candidateNewSize &gt; specifiedSize &amp;&amp; candidateNewSize != fontDescription.computedSize() &amp;&amp; text.textNode() &amp;&amp; oldStyle.textSizeAdjust().isAuto())
3856                 document().textAutoSizing().addTextNode(*text.textNode(), candidateNewSize);
3857         }
3858 
3859         descendant = RenderObjectTraversal::nextSkippingChildren(text, this);
3860     }
3861 }
3862 
3863 #endif // ENABLE(TEXT_AUTOSIZING)
3864 
3865 void RenderBlockFlow::layoutExcludedChildren(bool relayoutChildren)
3866 {
3867     RenderBlock::layoutExcludedChildren(relayoutChildren);
3868 
3869     auto* fragmentedFlow = multiColumnFlow();
3870     if (!fragmentedFlow)
3871         return;
3872 
3873     fragmentedFlow-&gt;setIsExcludedFromNormalLayout(true);
3874 
</pre>
<hr />
<pre>
4248                         &amp;&amp; ((prevFloat-&gt;style().floating() == Float::Left &amp;&amp; (childStyle.clear() == Clear::Left || childStyle.clear() == Clear::Both))
4249                             || (prevFloat-&gt;style().floating() == Float::Right &amp;&amp; (childStyle.clear() == Clear::Right || childStyle.clear() == Clear::Both))));
4250                     prevFloat = child;
4251                 } else
4252                     clearPreviousFloat = false;
4253 
4254                 bool canBreakReplacedElement = !child-&gt;isImage() || allowImagesToBreak;
4255                 if (((canBreakReplacedElement &amp;&amp; (autoWrap || oldAutoWrap) &amp;&amp; (!isPrevChildInlineFlow || shouldBreakLineAfterText)) || clearPreviousFloat)) {
4256                     minLogicalWidth = preferredWidth(minLogicalWidth, inlineMin);
4257                     inlineMin = 0;
4258                 }
4259 
4260                 // If we&#39;re supposed to clear the previous float, then terminate maxwidth as well.
4261                 if (clearPreviousFloat) {
4262                     maxLogicalWidth = preferredWidth(maxLogicalWidth, inlineMax);
4263                     inlineMax = 0;
4264                 }
4265 
4266                 // Add in text-indent. This is added in only once.
4267                 if (!addedTextIndent &amp;&amp; !child-&gt;isFloating()) {
<span class="line-modified">4268                     LayoutUnit ceiledIndent { textIndent.ceilToFloat() };</span>
4269                     childMin += ceiledIndent;
4270                     childMax += ceiledIndent;
4271 
4272                     if (childMin &lt; 0)
4273                         textIndent = LayoutUnit::fromFloatCeil(childMin);
4274                     else
4275                         addedTextIndent = true;
4276                 }
4277 
4278                 if (canHangPunctuationAtStart &amp;&amp; !addedStartPunctuationHang &amp;&amp; !child-&gt;isFloating())
4279                     addedStartPunctuationHang = true;
4280 
4281                 // Add our width to the max.
4282                 inlineMax += std::max&lt;float&gt;(0, childMax);
4283 
4284                 if ((!autoWrap || !canBreakReplacedElement || (isPrevChildInlineFlow &amp;&amp; !shouldBreakLineAfterText))) {
4285                     if (child-&gt;isFloating())
4286                         minLogicalWidth = preferredWidth(minLogicalWidth, childMin);
4287                     else
4288                         inlineMin += childMin;
</pre>
</td>
</tr>
</table>
<center><a href="RenderBlock.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="RenderBlockFlow.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>