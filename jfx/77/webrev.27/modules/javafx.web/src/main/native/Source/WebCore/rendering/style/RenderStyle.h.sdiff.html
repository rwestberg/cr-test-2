<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/rendering/style/RenderStyle.h</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="RenderStyle.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="RenderStyleConstants.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/rendering/style/RenderStyle.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  60 #include &quot;StyleRareNonInheritedData.h&quot;
  61 #include &quot;StyleReflection.h&quot;
  62 #include &quot;StyleSurroundData.h&quot;
  63 #include &quot;StyleTransformData.h&quot;
  64 #include &quot;StyleVisualData.h&quot;
  65 #include &quot;TextFlags.h&quot;
  66 #include &quot;ThemeTypes.h&quot;
  67 #include &quot;TouchAction.h&quot;
  68 #include &quot;TransformOperations.h&quot;
  69 #include &quot;UnicodeBidi.h&quot;
  70 #include &lt;memory&gt;
  71 #include &lt;wtf/Forward.h&gt;
  72 #include &lt;wtf/NeverDestroyed.h&gt;
  73 #include &lt;wtf/OptionSet.h&gt;
  74 #include &lt;wtf/StdLibExtras.h&gt;
  75 #include &lt;wtf/Vector.h&gt;
  76 
  77 #include &quot;StyleGridData.h&quot;
  78 #include &quot;StyleGridItemData.h&quot;
  79 
<span class="line-removed">  80 #if ENABLE(DASHBOARD_SUPPORT)</span>
<span class="line-removed">  81 #include &quot;StyleDashboardRegion.h&quot;</span>
<span class="line-removed">  82 #endif</span>
<span class="line-removed">  83 </span>
  84 #if ENABLE(TEXT_AUTOSIZING)
  85 #include &quot;TextSizeAdjustment.h&quot;
  86 #endif
  87 
  88 #if ENABLE(DARK_MODE_CSS)
<span class="line-modified">  89 #include &quot;StyleSupportedColorSchemes.h&quot;</span>
  90 #endif
  91 
  92 #define SET_VAR(group, variable, value) do { \
  93         if (!compareEqual(group-&gt;variable, value)) \
  94             group.access().variable = value; \
  95     } while (0)
  96 
  97 #define SET_NESTED_VAR(group, parentVariable, variable, value) do { \
  98         if (!compareEqual(group-&gt;parentVariable-&gt;variable, value)) \
  99             group.access().parentVariable.access().variable = value; \
 100     } while (0)
 101 
 102 #define SET_BORDERVALUE_COLOR(group, variable, value) do { \
 103         if (!compareEqual(group-&gt;variable.color(), value)) \
 104             group.access().variable.setColor(value); \
 105     } while (0)
 106 
 107 namespace WebCore {
 108 
 109 class BorderData;
</pre>
<hr />
<pre>
 173     ContentPosition resolvedAlignContentPosition(const StyleContentAlignmentData&amp; normalValueBehavior) const;
 174     ContentDistribution resolvedAlignContentDistribution(const StyleContentAlignmentData&amp; normalValueBehavior) const;
 175     StyleSelfAlignmentData resolvedAlignItems(ItemPosition normalValueBehaviour) const;
 176     StyleSelfAlignmentData resolvedAlignSelf(const RenderStyle* parentStyle, ItemPosition normalValueBehaviour) const;
 177     StyleContentAlignmentData resolvedAlignContent(const StyleContentAlignmentData&amp; normalValueBehaviour) const;
 178     StyleSelfAlignmentData resolvedJustifyItems(ItemPosition normalValueBehaviour) const;
 179     StyleSelfAlignmentData resolvedJustifySelf(const RenderStyle* parentStyle, ItemPosition normalValueBehaviour) const;
 180     StyleContentAlignmentData resolvedJustifyContent(const StyleContentAlignmentData&amp; normalValueBehaviour) const;
 181 
 182     PseudoId styleType() const { return static_cast&lt;PseudoId&gt;(m_nonInheritedFlags.styleType); }
 183     void setStyleType(PseudoId styleType) { m_nonInheritedFlags.styleType = static_cast&lt;unsigned&gt;(styleType); }
 184 
 185     RenderStyle* getCachedPseudoStyle(PseudoId) const;
 186     RenderStyle* addCachedPseudoStyle(std::unique_ptr&lt;RenderStyle&gt;);
 187     void removeCachedPseudoStyle(PseudoId);
 188 
 189     const PseudoStyleCache* cachedPseudoStyles() const { return m_cachedPseudoStyles.get(); }
 190 
 191     const CustomPropertyValueMap&amp; inheritedCustomProperties() const { return m_rareInheritedData-&gt;customProperties-&gt;values; }
 192     const CustomPropertyValueMap&amp; nonInheritedCustomProperties() const { return m_rareNonInheritedData-&gt;customProperties-&gt;values; }
<span class="line-modified"> 193     const CSSCustomPropertyValue* getCustomProperty(const AtomicString&amp;) const;</span>
<span class="line-modified"> 194     void setInheritedCustomPropertyValue(const AtomicString&amp; name, Ref&lt;CSSCustomPropertyValue&gt;&amp;&amp; value) { return m_rareInheritedData.access().customProperties.access().setCustomPropertyValue(name, WTFMove(value)); }</span>
<span class="line-modified"> 195     void setNonInheritedCustomPropertyValue(const AtomicString&amp; name, Ref&lt;CSSCustomPropertyValue&gt;&amp;&amp; value) { return m_rareNonInheritedData.access().customProperties.access().setCustomPropertyValue(name, WTFMove(value)); }</span>
 196 
 197     void setHasViewportUnits(bool v = true) { m_nonInheritedFlags.hasViewportUnits = v; }
 198     bool hasViewportUnits() const { return m_nonInheritedFlags.hasViewportUnits; }
 199 
 200     bool affectedByHover() const { return m_nonInheritedFlags.affectedByHover; }
 201     bool affectedByActive() const { return m_nonInheritedFlags.affectedByActive; }
 202     bool affectedByDrag() const { return m_nonInheritedFlags.affectedByDrag; }
 203 
 204     void setAffectedByHover() { m_nonInheritedFlags.affectedByHover = true; }
 205     void setAffectedByActive() { m_nonInheritedFlags.affectedByActive = true; }
 206     void setAffectedByDrag() { m_nonInheritedFlags.affectedByDrag = true; }
 207 
 208     void setColumnStylesFromPaginationMode(const Pagination::Mode&amp;);
 209 
 210     bool isFloating() const { return static_cast&lt;Float&gt;(m_nonInheritedFlags.floating) != Float::No; }
 211     bool hasMargin() const { return !m_surroundData-&gt;margin.isZero(); }
 212     bool hasBorder() const { return m_surroundData-&gt;border.hasBorder(); }
 213     bool hasBorderFill() const { return m_surroundData-&gt;border.hasFill(); }
 214     bool hasVisibleBorderDecoration() const { return hasVisibleBorder() || hasBorderFill(); }
 215     bool hasVisibleBorder() const { return m_surroundData-&gt;border.hasVisibleBorder(); }
</pre>
<hr />
<pre>
 585     BoxSizing boxSizing() const { return m_boxData-&gt;boxSizing(); }
 586     const Length&amp; marqueeIncrement() const { return m_rareNonInheritedData-&gt;marquee-&gt;increment; }
 587     int marqueeSpeed() const { return m_rareNonInheritedData-&gt;marquee-&gt;speed; }
 588     int marqueeLoopCount() const { return m_rareNonInheritedData-&gt;marquee-&gt;loops; }
 589     MarqueeBehavior marqueeBehavior() const { return static_cast&lt;MarqueeBehavior&gt;(m_rareNonInheritedData-&gt;marquee-&gt;behavior); }
 590     MarqueeDirection marqueeDirection() const { return static_cast&lt;MarqueeDirection&gt;(m_rareNonInheritedData-&gt;marquee-&gt;direction); }
 591     UserModify userModify() const { return static_cast&lt;UserModify&gt;(m_rareInheritedData-&gt;userModify); }
 592     UserDrag userDrag() const { return static_cast&lt;UserDrag&gt;(m_rareNonInheritedData-&gt;userDrag); }
 593     UserSelect userSelect() const { return static_cast&lt;UserSelect&gt;(m_rareInheritedData-&gt;userSelect); }
 594     TextOverflow textOverflow() const { return static_cast&lt;TextOverflow&gt;(m_rareNonInheritedData-&gt;textOverflow); }
 595     MarginCollapse marginBeforeCollapse() const { return static_cast&lt;MarginCollapse&gt;(m_rareNonInheritedData-&gt;marginBeforeCollapse); }
 596     MarginCollapse marginAfterCollapse() const { return static_cast&lt;MarginCollapse&gt;(m_rareNonInheritedData-&gt;marginAfterCollapse); }
 597     WordBreak wordBreak() const { return static_cast&lt;WordBreak&gt;(m_rareInheritedData-&gt;wordBreak); }
 598     OverflowWrap overflowWrap() const { return static_cast&lt;OverflowWrap&gt;(m_rareInheritedData-&gt;overflowWrap); }
 599     NBSPMode nbspMode() const { return static_cast&lt;NBSPMode&gt;(m_rareInheritedData-&gt;nbspMode); }
 600     LineBreak lineBreak() const { return static_cast&lt;LineBreak&gt;(m_rareInheritedData-&gt;lineBreak); }
 601     Hyphens hyphens() const { return static_cast&lt;Hyphens&gt;(m_rareInheritedData-&gt;hyphens); }
 602     short hyphenationLimitBefore() const { return m_rareInheritedData-&gt;hyphenationLimitBefore; }
 603     short hyphenationLimitAfter() const { return m_rareInheritedData-&gt;hyphenationLimitAfter; }
 604     short hyphenationLimitLines() const { return m_rareInheritedData-&gt;hyphenationLimitLines; }
<span class="line-modified"> 605     const AtomicString&amp; hyphenationString() const { return m_rareInheritedData-&gt;hyphenationString; }</span>
<span class="line-modified"> 606     const AtomicString&amp; locale() const { return fontDescription().locale(); }</span>
 607     BorderFit borderFit() const { return static_cast&lt;BorderFit&gt;(m_rareNonInheritedData-&gt;borderFit); }
 608     Resize resize() const { return static_cast&lt;Resize&gt;(m_rareNonInheritedData-&gt;resize); }
 609     ColumnAxis columnAxis() const { return static_cast&lt;ColumnAxis&gt;(m_rareNonInheritedData-&gt;multiCol-&gt;axis); }
 610     bool hasInlineColumnAxis() const;
 611     ColumnProgression columnProgression() const { return static_cast&lt;ColumnProgression&gt;(m_rareNonInheritedData-&gt;multiCol-&gt;progression); }
 612     float columnWidth() const { return m_rareNonInheritedData-&gt;multiCol-&gt;width; }
 613     bool hasAutoColumnWidth() const { return m_rareNonInheritedData-&gt;multiCol-&gt;autoWidth; }
 614     unsigned short columnCount() const { return m_rareNonInheritedData-&gt;multiCol-&gt;count; }
 615     bool hasAutoColumnCount() const { return m_rareNonInheritedData-&gt;multiCol-&gt;autoCount; }
 616     bool specifiesColumns() const { return !hasAutoColumnCount() || !hasAutoColumnWidth() || !hasInlineColumnAxis(); }
 617     ColumnFill columnFill() const { return static_cast&lt;ColumnFill&gt;(m_rareNonInheritedData-&gt;multiCol-&gt;fill); }
 618     const GapLength&amp; columnGap() const { return m_rareNonInheritedData-&gt;columnGap; }
 619     const GapLength&amp; rowGap() const { return m_rareNonInheritedData-&gt;rowGap; }
 620     BorderStyle columnRuleStyle() const { return m_rareNonInheritedData-&gt;multiCol-&gt;rule.style(); }
 621     unsigned short columnRuleWidth() const { return m_rareNonInheritedData-&gt;multiCol-&gt;ruleWidth(); }
 622     bool columnRuleIsTransparent() const { return m_rareNonInheritedData-&gt;multiCol-&gt;rule.isTransparent(); }
 623     ColumnSpan columnSpan() const { return static_cast&lt;ColumnSpan&gt;(m_rareNonInheritedData-&gt;multiCol-&gt;columnSpan); }
 624 
 625     const TransformOperations&amp; transform() const { return m_rareNonInheritedData-&gt;transform-&gt;operations; }
 626     bool hasTransform() const { return !m_rareNonInheritedData-&gt;transform-&gt;operations.operations().isEmpty(); }
 627     const Length&amp; transformOriginX() const { return m_rareNonInheritedData-&gt;transform-&gt;x; }
 628     const Length&amp; transformOriginY() const { return m_rareNonInheritedData-&gt;transform-&gt;y; }
 629     float transformOriginZ() const { return m_rareNonInheritedData-&gt;transform-&gt;z; }
 630     TransformBox transformBox() const { return m_rareNonInheritedData-&gt;transform-&gt;transformBox; }
 631 
 632     TextEmphasisFill textEmphasisFill() const { return static_cast&lt;TextEmphasisFill&gt;(m_rareInheritedData-&gt;textEmphasisFill); }
 633     TextEmphasisMark textEmphasisMark() const;
<span class="line-modified"> 634     const AtomicString&amp; textEmphasisCustomMark() const { return m_rareInheritedData-&gt;textEmphasisCustomMark; }</span>
 635     OptionSet&lt;TextEmphasisPosition&gt; textEmphasisPosition() const { return OptionSet&lt;TextEmphasisPosition&gt;::fromRaw(m_rareInheritedData-&gt;textEmphasisPosition); }
<span class="line-modified"> 636     const AtomicString&amp; textEmphasisMarkString() const;</span>
 637 
 638     RubyPosition rubyPosition() const { return static_cast&lt;RubyPosition&gt;(m_rareInheritedData-&gt;rubyPosition); }
 639 
 640 #if ENABLE(DARK_MODE_CSS)
<span class="line-modified"> 641     StyleSupportedColorSchemes supportedColorSchemes() const { return m_rareInheritedData-&gt;supportedColorSchemes; }</span>
<span class="line-modified"> 642     void setHasExplicitlySetSupportedColorSchemes(bool v) { m_nonInheritedFlags.hasExplicitlySetSupportedColorSchemes = v; }</span>
<span class="line-modified"> 643     bool hasExplicitlySetSupportedColorSchemes() const { return m_nonInheritedFlags.hasExplicitlySetSupportedColorSchemes; };</span>
 644 #endif
 645 
 646     TextOrientation textOrientation() const { return static_cast&lt;TextOrientation&gt;(m_rareInheritedData-&gt;textOrientation); }
 647 
 648     ObjectFit objectFit() const { return static_cast&lt;ObjectFit&gt;(m_rareNonInheritedData-&gt;objectFit); }
 649     LengthPoint objectPosition() const { return m_rareNonInheritedData-&gt;objectPosition; }
 650 
 651     // Return true if any transform related property (currently transform, transformStyle3D or perspective)
 652     // indicates that we are transforming.
 653     bool hasTransformRelatedProperty() const { return hasTransform() || preserves3D() || hasPerspective(); }
 654 
 655     enum ApplyTransformOrigin { IncludeTransformOrigin, ExcludeTransformOrigin };
 656     void applyTransform(TransformationMatrix&amp;, const FloatRect&amp; boundingBox, ApplyTransformOrigin = IncludeTransformOrigin) const;
 657     void setPageScaleTransform(float);
 658 
 659     bool hasMask() const { return m_rareNonInheritedData-&gt;mask.hasImage() || m_rareNonInheritedData-&gt;maskBoxImage.hasImage(); }
 660 
 661     TextCombine textCombine() const { return static_cast&lt;TextCombine&gt;(m_rareNonInheritedData-&gt;textCombine); }
 662     bool hasTextCombine() const { return textCombine() != TextCombine::None; }
 663 
<span class="line-modified"> 664     unsigned tabSize() const { return m_rareInheritedData-&gt;tabSize; }</span>
 665 
 666     // End CSS3 Getters
 667 
<span class="line-modified"> 668     const AtomicString&amp; lineGrid() const { return m_rareInheritedData-&gt;lineGrid; }</span>
 669     LineSnap lineSnap() const { return static_cast&lt;LineSnap&gt;(m_rareInheritedData-&gt;lineSnap); }
 670     LineAlign lineAlign() const { return static_cast&lt;LineAlign&gt;(m_rareInheritedData-&gt;lineAlign); }
 671 
 672     PointerEvents pointerEvents() const { return static_cast&lt;PointerEvents&gt;(m_inheritedFlags.pointerEvents); }
 673     const AnimationList* animations() const { return m_rareNonInheritedData-&gt;animations.get(); }
 674     const AnimationList* transitions() const { return m_rareNonInheritedData-&gt;transitions.get(); }
 675 
 676     AnimationList* animations() { return m_rareNonInheritedData-&gt;animations.get(); }
 677     AnimationList* transitions() { return m_rareNonInheritedData-&gt;transitions.get(); }
 678 
 679     bool hasAnimationsOrTransitions() const { return hasAnimations() || hasTransitions(); }
 680 
 681     AnimationList&amp; ensureAnimations();
 682     AnimationList&amp; ensureTransitions();
 683 
 684     bool hasAnimations() const { return m_rareNonInheritedData-&gt;animations &amp;&amp; m_rareNonInheritedData-&gt;animations-&gt;size() &gt; 0; }
 685     bool hasTransitions() const { return m_rareNonInheritedData-&gt;transitions &amp;&amp; m_rareNonInheritedData-&gt;transitions-&gt;size() &gt; 0; }
 686 
 687     // Return the first found Animation (including &#39;all&#39; transitions).
 688     const Animation* transitionForProperty(CSSPropertyID) const;
 689 
 690     TransformStyle3D transformStyle3D() const { return static_cast&lt;TransformStyle3D&gt;(m_rareNonInheritedData-&gt;transformStyle3D); }
 691     bool preserves3D() const { return transformStyle3D() == TransformStyle3D::Preserve3D; }
 692 
 693     BackfaceVisibility backfaceVisibility() const { return static_cast&lt;BackfaceVisibility&gt;(m_rareNonInheritedData-&gt;backfaceVisibility); }
 694     float perspective() const { return m_rareNonInheritedData-&gt;perspective; }
 695     bool hasPerspective() const { return m_rareNonInheritedData-&gt;perspective &gt; 0; }
 696     const Length&amp; perspectiveOriginX() const { return m_rareNonInheritedData-&gt;perspectiveOriginX; }
 697     const Length&amp; perspectiveOriginY() const { return m_rareNonInheritedData-&gt;perspectiveOriginY; }
 698     const LengthSize&amp; pageSize() const { return m_rareNonInheritedData-&gt;pageSize; }
 699     PageSizeType pageSizeType() const { return static_cast&lt;PageSizeType&gt;(m_rareNonInheritedData-&gt;pageSizeType); }
 700 
 701     LineBoxContain lineBoxContain() const { return m_rareInheritedData-&gt;lineBoxContain; }
 702     const LineClampValue&amp; lineClamp() const { return m_rareNonInheritedData-&gt;lineClamp; }
 703     const IntSize&amp; initialLetter() const { return m_rareNonInheritedData-&gt;initialLetter; }
 704     int initialLetterDrop() const { return initialLetter().width(); }
 705     int initialLetterHeight() const { return initialLetter().height(); }
 706 
 707 #if ENABLE(POINTER_EVENTS)
 708     OptionSet&lt;TouchAction&gt; touchActions() const { return OptionSet&lt;TouchAction&gt;::fromRaw(m_rareNonInheritedData-&gt;touchActions); }


 709 #endif
 710 
 711 #if ENABLE(CSS_SCROLL_SNAP)
 712     // Scroll snap port style.
 713     const StyleScrollSnapPort&amp; scrollSnapPort() const;
 714     const ScrollSnapType&amp; scrollSnapType() const;
 715     const LengthBox&amp; scrollPadding() const;
 716     const Length&amp; scrollPaddingTop() const;
 717     const Length&amp; scrollPaddingBottom() const;
 718     const Length&amp; scrollPaddingLeft() const;
 719     const Length&amp; scrollPaddingRight() const;
 720 
 721     // Scroll snap area style.
 722     const StyleScrollSnapArea&amp; scrollSnapArea() const;
 723     const ScrollSnapAlign&amp; scrollSnapAlign() const;
 724     const LengthBox&amp; scrollSnapMargin() const;
 725     const Length&amp; scrollSnapMarginTop() const;
 726     const Length&amp; scrollSnapMarginBottom() const;
 727     const Length&amp; scrollSnapMarginLeft() const;
 728     const Length&amp; scrollSnapMarginRight() const;
 729 #endif
 730 
 731 #if ENABLE(TOUCH_EVENTS)
 732     Color tapHighlightColor() const { return m_rareInheritedData-&gt;tapHighlightColor; }
 733 #endif
 734 
 735 #if PLATFORM(IOS_FAMILY)
 736     bool touchCalloutEnabled() const { return m_rareInheritedData-&gt;touchCalloutEnabled; }
 737 #endif
 738 
<span class="line-modified"> 739 #if ENABLE(ACCELERATED_OVERFLOW_SCROLLING)</span>
 740     bool useTouchOverflowScrolling() const { return m_rareInheritedData-&gt;useTouchOverflowScrolling; }
 741 #endif
 742 
 743 #if ENABLE(TEXT_AUTOSIZING)
 744     TextSizeAdjustment textSizeAdjust() const { return m_rareInheritedData-&gt;textSizeAdjust; }


 745 #endif
 746 
 747     TextSecurity textSecurity() const { return static_cast&lt;TextSecurity&gt;(m_rareInheritedData-&gt;textSecurity); }
 748 
 749     WritingMode writingMode() const { return static_cast&lt;WritingMode&gt;(m_inheritedFlags.writingMode); }
 750     bool isHorizontalWritingMode() const { return WebCore::isHorizontalWritingMode(writingMode()); }
 751     bool isVerticalWritingMode() const { return WebCore::isVerticalWritingMode(writingMode()); }
 752     bool isFlippedLinesWritingMode() const { return WebCore::isFlippedLinesWritingMode(writingMode()); }
 753     bool isFlippedBlocksWritingMode() const { return WebCore::isFlippedWritingMode(writingMode()); }
 754 
<span class="line-modified"> 755     ImageOrientationEnum imageOrientation() const;</span>
 756 
 757     ImageRendering imageRendering() const { return static_cast&lt;ImageRendering&gt;(m_rareInheritedData-&gt;imageRendering); }
 758 
 759 #if ENABLE(CSS_IMAGE_RESOLUTION)
 760     ImageResolutionSource imageResolutionSource() const { return static_cast&lt;ImageResolutionSource&gt;(m_rareInheritedData-&gt;imageResolutionSource); }
 761     ImageResolutionSnap imageResolutionSnap() const { return static_cast&lt;ImageResolutionSnap&gt;(m_rareInheritedData-&gt;imageResolutionSnap); }
 762     float imageResolution() const { return m_rareInheritedData-&gt;imageResolution; }
 763 #endif
 764 
 765     OptionSet&lt;SpeakAs&gt; speakAs() const { return OptionSet&lt;SpeakAs&gt;::fromRaw(m_rareInheritedData-&gt;speakAs); }
 766 
 767     FilterOperations&amp; mutableFilter() { return m_rareNonInheritedData.access().filter.access().operations; }
 768     const FilterOperations&amp; filter() const { return m_rareNonInheritedData-&gt;filter-&gt;operations; }
 769     bool hasFilter() const { return !m_rareNonInheritedData-&gt;filter-&gt;operations.operations().isEmpty(); }
 770     bool hasReferenceFilterOnly() const;
 771 
 772     FilterOperations&amp; mutableAppleColorFilter() { return m_rareInheritedData.access().appleColorFilter.access().operations; }
 773     const FilterOperations&amp; appleColorFilter() const { return m_rareInheritedData-&gt;appleColorFilter-&gt;operations; }
 774     bool hasAppleColorFilter() const { return !m_rareInheritedData-&gt;appleColorFilter-&gt;operations.operations().isEmpty(); }
 775 
</pre>
<hr />
<pre>
 814     void setOriginalDisplay(DisplayType v) { m_nonInheritedFlags.originalDisplay = static_cast&lt;unsigned&gt;(v); }
 815     void setPosition(PositionType v) { m_nonInheritedFlags.position = static_cast&lt;unsigned&gt;(v); }
 816     void setFloating(Float v) { m_nonInheritedFlags.floating = static_cast&lt;unsigned&gt;(v); }
 817 
 818     void setLeft(Length&amp;&amp; length) { SET_VAR(m_surroundData, offset.left(), WTFMove(length)); }
 819     void setRight(Length&amp;&amp; length) { SET_VAR(m_surroundData, offset.right(), WTFMove(length)); }
 820     void setTop(Length&amp;&amp; length) { SET_VAR(m_surroundData, offset.top(), WTFMove(length)); }
 821     void setBottom(Length&amp;&amp; length) { SET_VAR(m_surroundData, offset.bottom(), WTFMove(length)); }
 822 
 823     void setWidth(Length&amp;&amp; length) { SET_VAR(m_boxData, m_width, WTFMove(length)); }
 824     void setHeight(Length&amp;&amp; length) { SET_VAR(m_boxData, m_height, WTFMove(length)); }
 825 
 826     void setLogicalWidth(Length&amp;&amp;);
 827     void setLogicalHeight(Length&amp;&amp;);
 828 
 829     void setMinWidth(Length&amp;&amp; length) { SET_VAR(m_boxData, m_minWidth, WTFMove(length)); }
 830     void setMaxWidth(Length&amp;&amp; length) { SET_VAR(m_boxData, m_maxWidth, WTFMove(length)); }
 831     void setMinHeight(Length&amp;&amp; length) { SET_VAR(m_boxData, m_minHeight, WTFMove(length)); }
 832     void setMaxHeight(Length&amp;&amp; length) { SET_VAR(m_boxData, m_maxHeight, WTFMove(length)); }
 833 
<span class="line-removed"> 834 #if ENABLE(DASHBOARD_SUPPORT)</span>
<span class="line-removed"> 835     const Vector&lt;StyleDashboardRegion&gt;&amp; dashboardRegions() const { return m_rareNonInheritedData-&gt;dashboardRegions; }</span>
<span class="line-removed"> 836     void setDashboardRegions(const Vector&lt;StyleDashboardRegion&gt;&amp; regions) { SET_VAR(m_rareNonInheritedData, dashboardRegions, regions); }</span>
<span class="line-removed"> 837     void setDashboardRegion(int type, const String&amp; label, Length&amp;&amp; top, Length&amp;&amp; right, Length&amp;&amp; bottom, Length&amp;&amp; left, bool append);</span>
<span class="line-removed"> 838 #endif</span>
<span class="line-removed"> 839 </span>
 840     void resetBorder() { resetBorderImage(); resetBorderTop(); resetBorderRight(); resetBorderBottom(); resetBorderLeft(); resetBorderRadius(); }
 841     void resetBorderTop() { SET_VAR(m_surroundData, border.m_top, BorderValue()); }
 842     void resetBorderRight() { SET_VAR(m_surroundData, border.m_right, BorderValue()); }
 843     void resetBorderBottom() { SET_VAR(m_surroundData, border.m_bottom, BorderValue()); }
 844     void resetBorderLeft() { SET_VAR(m_surroundData, border.m_left, BorderValue()); }
 845     void resetBorderImage() { SET_VAR(m_surroundData, border.m_image, NinePieceImage()); }
 846     void resetBorderRadius() { resetBorderTopLeftRadius(); resetBorderTopRightRadius(); resetBorderBottomLeftRadius(); resetBorderBottomRightRadius(); }
 847     void resetBorderTopLeftRadius() { SET_VAR(m_surroundData, border.m_topLeft, initialBorderRadius()); }
 848     void resetBorderTopRightRadius() { SET_VAR(m_surroundData, border.m_topRight, initialBorderRadius()); }
 849     void resetBorderBottomLeftRadius() { SET_VAR(m_surroundData, border.m_bottomLeft, initialBorderRadius()); }
 850     void resetBorderBottomRightRadius() { SET_VAR(m_surroundData, border.m_bottomRight, initialBorderRadius()); }
 851 
 852     void setBackgroundColor(const Color&amp; v) { SET_VAR(m_backgroundData, color, v); }
 853 
 854     void setBackgroundXPosition(Length&amp;&amp; length) { SET_VAR(m_backgroundData, background.m_xPosition, WTFMove(length)); }
 855     void setBackgroundYPosition(Length&amp;&amp; length) { SET_VAR(m_backgroundData, background.m_yPosition, WTFMove(length)); }
 856     void setBackgroundSize(FillSizeType b) { SET_VAR(m_backgroundData, background.m_sizeType, static_cast&lt;unsigned&gt;(b)); }
 857     void setBackgroundSizeLength(LengthSize&amp;&amp; size) { SET_VAR(m_backgroundData, background.m_sizeLength, WTFMove(size)); }
 858 
 859     void setBorderImage(const NinePieceImage&amp; b) { SET_VAR(m_surroundData, border.m_image, b); }
</pre>
<hr />
<pre>
 940     void setDirection(TextDirection v) { m_inheritedFlags.direction = static_cast&lt;unsigned&gt;(v); }
 941     void setHasExplicitlySetDirection(bool v) { m_nonInheritedFlags.hasExplicitlySetDirection = v; }
 942     void setLineHeight(Length&amp;&amp;);
 943     bool setZoom(float);
 944     void setZoomWithoutReturnValue(float f) { setZoom(f); }
 945     bool setEffectiveZoom(float);
 946     void setTextZoom(TextZoom v) { SET_VAR(m_rareInheritedData, textZoom, static_cast&lt;unsigned&gt;(v)); }
 947 
 948 #if ENABLE(CSS3_TEXT)
 949     void setTextIndentLine(TextIndentLine v) { SET_VAR(m_rareInheritedData, textIndentLine, v); }
 950     void setTextIndentType(TextIndentType v) { SET_VAR(m_rareInheritedData, textIndentType, v); }
 951     void setTextAlignLast(TextAlignLast v) { SET_VAR(m_rareInheritedData, textAlignLast, v); }
 952     void setTextJustify(TextJustify v) { SET_VAR(m_rareInheritedData, textJustify, v); }
 953 #endif
 954 
 955 #if ENABLE(TEXT_AUTOSIZING)
 956     void setSpecifiedLineHeight(Length&amp;&amp;);
 957 #endif
 958 
 959 #if ENABLE(CSS_IMAGE_ORIENTATION)
<span class="line-modified"> 960     void setImageOrientation(ImageOrientationEnum v) { SET_VAR(m_rareInheritedData, imageOrientation, static_cast&lt;int&gt;(v)); }</span>
 961 #endif
 962 
 963     void setImageRendering(ImageRendering v) { SET_VAR(m_rareInheritedData, imageRendering, static_cast&lt;unsigned&gt;(v)); }
 964 
 965 #if ENABLE(CSS_IMAGE_RESOLUTION)
 966     void setImageResolutionSource(ImageResolutionSource v) { SET_VAR(m_rareInheritedData, imageResolutionSource, v); }
 967     void setImageResolutionSnap(ImageResolutionSnap v) { SET_VAR(m_rareInheritedData, imageResolutionSnap, v); }
 968     void setImageResolution(float f) { SET_VAR(m_rareInheritedData, imageResolution, f); }
 969 #endif
 970 
 971     void setWhiteSpace(WhiteSpace v) { m_inheritedFlags.whiteSpace = static_cast&lt;unsigned&gt;(v); }
 972 
 973     void setWordSpacing(Length&amp;&amp;);
 974     void setLetterSpacing(float);
 975 
 976     void clearBackgroundLayers() { m_backgroundData.access().background = FillLayer(FillLayerType::Background); }
 977     void inheritBackgroundLayers(const FillLayer&amp; parent) { m_backgroundData.access().background = parent; }
 978 
 979     void adjustBackgroundLayers();
 980 
</pre>
<hr />
<pre>
1119 
1120     void setMarqueeIncrement(Length&amp;&amp; length) { SET_NESTED_VAR(m_rareNonInheritedData, marquee, increment, WTFMove(length)); }
1121     void setMarqueeSpeed(int f) { SET_NESTED_VAR(m_rareNonInheritedData, marquee, speed, f); }
1122     void setMarqueeDirection(MarqueeDirection d) { SET_NESTED_VAR(m_rareNonInheritedData, marquee, direction, static_cast&lt;unsigned&gt;(d)); }
1123     void setMarqueeBehavior(MarqueeBehavior b) { SET_NESTED_VAR(m_rareNonInheritedData, marquee, behavior, static_cast&lt;unsigned&gt;(b)); }
1124     void setMarqueeLoopCount(int i) { SET_NESTED_VAR(m_rareNonInheritedData, marquee, loops, i); }
1125     void setUserModify(UserModify u) { SET_VAR(m_rareInheritedData, userModify, static_cast&lt;unsigned&gt;(u)); }
1126     void setUserDrag(UserDrag d) { SET_VAR(m_rareNonInheritedData, userDrag, static_cast&lt;unsigned&gt;(d)); }
1127     void setUserSelect(UserSelect s) { SET_VAR(m_rareInheritedData, userSelect, static_cast&lt;unsigned&gt;(s)); }
1128     void setTextOverflow(TextOverflow overflow) { SET_VAR(m_rareNonInheritedData, textOverflow, static_cast&lt;unsigned&gt;(overflow)); }
1129     void setMarginBeforeCollapse(MarginCollapse c) { SET_VAR(m_rareNonInheritedData, marginBeforeCollapse, static_cast&lt;unsigned&gt;(c)); }
1130     void setMarginAfterCollapse(MarginCollapse c) { SET_VAR(m_rareNonInheritedData, marginAfterCollapse, static_cast&lt;unsigned&gt;(c)); }
1131     void setWordBreak(WordBreak b) { SET_VAR(m_rareInheritedData, wordBreak, static_cast&lt;unsigned&gt;(b)); }
1132     void setOverflowWrap(OverflowWrap b) { SET_VAR(m_rareInheritedData, overflowWrap, static_cast&lt;unsigned&gt;(b)); }
1133     void setNBSPMode(NBSPMode b) { SET_VAR(m_rareInheritedData, nbspMode, static_cast&lt;unsigned&gt;(b)); }
1134     void setLineBreak(LineBreak b) { SET_VAR(m_rareInheritedData, lineBreak, static_cast&lt;unsigned&gt;(b)); }
1135     void setHyphens(Hyphens h) { SET_VAR(m_rareInheritedData, hyphens, static_cast&lt;unsigned&gt;(h)); }
1136     void setHyphenationLimitBefore(short limit) { SET_VAR(m_rareInheritedData, hyphenationLimitBefore, limit); }
1137     void setHyphenationLimitAfter(short limit) { SET_VAR(m_rareInheritedData, hyphenationLimitAfter, limit); }
1138     void setHyphenationLimitLines(short limit) { SET_VAR(m_rareInheritedData, hyphenationLimitLines, limit); }
<span class="line-modified">1139     void setHyphenationString(const AtomicString&amp; h) { SET_VAR(m_rareInheritedData, hyphenationString, h); }</span>
1140     void setBorderFit(BorderFit b) { SET_VAR(m_rareNonInheritedData, borderFit, static_cast&lt;unsigned&gt;(b)); }
1141     void setResize(Resize r) { SET_VAR(m_rareNonInheritedData, resize, static_cast&lt;unsigned&gt;(r)); }
1142     void setColumnAxis(ColumnAxis axis) { SET_NESTED_VAR(m_rareNonInheritedData, multiCol, axis, static_cast&lt;unsigned&gt;(axis)); }
1143     void setColumnProgression(ColumnProgression progression) { SET_NESTED_VAR(m_rareNonInheritedData, multiCol, progression, static_cast&lt;unsigned&gt;(progression)); }
1144     void setColumnWidth(float f) { SET_NESTED_VAR(m_rareNonInheritedData, multiCol, autoWidth, false); SET_NESTED_VAR(m_rareNonInheritedData, multiCol, width, f); }
1145     void setHasAutoColumnWidth() { SET_NESTED_VAR(m_rareNonInheritedData, multiCol, autoWidth, true); SET_NESTED_VAR(m_rareNonInheritedData, multiCol, width, 0); }
1146     void setColumnCount(unsigned short c) { SET_NESTED_VAR(m_rareNonInheritedData, multiCol, autoCount, false); SET_NESTED_VAR(m_rareNonInheritedData, multiCol, count, c); }
1147     void setHasAutoColumnCount() { SET_NESTED_VAR(m_rareNonInheritedData, multiCol, autoCount, true); SET_NESTED_VAR(m_rareNonInheritedData, multiCol, count, 0); }
1148     void setColumnFill(ColumnFill columnFill) { SET_NESTED_VAR(m_rareNonInheritedData, multiCol, fill, static_cast&lt;unsigned&gt;(columnFill)); }
1149     void setColumnGap(GapLength&amp;&amp; gapLength) { SET_VAR(m_rareNonInheritedData, columnGap, WTFMove(gapLength)); }
1150     void setRowGap(GapLength&amp;&amp; gapLength) { SET_VAR(m_rareNonInheritedData, rowGap, WTFMove(gapLength)); }
1151     void setColumnRuleColor(const Color&amp; c) { SET_BORDERVALUE_COLOR(m_rareNonInheritedData.access().multiCol, rule, c); }
1152     void setColumnRuleStyle(BorderStyle b) { SET_NESTED_VAR(m_rareNonInheritedData, multiCol, rule.m_style, static_cast&lt;unsigned&gt;(b)); }
1153     void setColumnRuleWidth(unsigned short w) { SET_NESTED_VAR(m_rareNonInheritedData, multiCol, rule.m_width, w); }
1154     void resetColumnRule() { SET_NESTED_VAR(m_rareNonInheritedData, multiCol, rule, BorderValue()); }
1155     void setColumnSpan(ColumnSpan columnSpan) { SET_NESTED_VAR(m_rareNonInheritedData, multiCol, columnSpan, static_cast&lt;unsigned&gt;(columnSpan)); }
1156     void inheritColumnPropertiesFrom(const RenderStyle&amp; parent) { m_rareNonInheritedData.access().multiCol = parent.m_rareNonInheritedData-&gt;multiCol; }
1157 
1158     void setTransform(const TransformOperations&amp; ops) { SET_NESTED_VAR(m_rareNonInheritedData, transform, operations, ops); }
1159     void setTransformOriginX(Length&amp;&amp; length) { SET_NESTED_VAR(m_rareNonInheritedData, transform, x, WTFMove(length)); }
1160     void setTransformOriginY(Length&amp;&amp; length) { SET_NESTED_VAR(m_rareNonInheritedData, transform, y, WTFMove(length)); }
1161     void setTransformOriginZ(float f) { SET_NESTED_VAR(m_rareNonInheritedData, transform, z, f); }
1162     void setTransformBox(TransformBox box) { SET_NESTED_VAR(m_rareNonInheritedData, transform, transformBox, box); }
1163 
1164     void setSpeakAs(OptionSet&lt;SpeakAs&gt; s) { SET_VAR(m_rareInheritedData, speakAs, s.toRaw()); }
1165     void setTextCombine(TextCombine v) { SET_VAR(m_rareNonInheritedData, textCombine, static_cast&lt;unsigned&gt;(v)); }
1166     void setTextDecorationColor(const Color&amp; c) { SET_VAR(m_rareNonInheritedData, textDecorationColor, c); }
1167     void setTextEmphasisColor(const Color&amp; c) { SET_VAR(m_rareInheritedData, textEmphasisColor, c); }
1168     void setTextEmphasisFill(TextEmphasisFill fill) { SET_VAR(m_rareInheritedData, textEmphasisFill, static_cast&lt;unsigned&gt;(fill)); }
1169     void setTextEmphasisMark(TextEmphasisMark mark) { SET_VAR(m_rareInheritedData, textEmphasisMark, static_cast&lt;unsigned&gt;(mark)); }
<span class="line-modified">1170     void setTextEmphasisCustomMark(const AtomicString&amp; mark) { SET_VAR(m_rareInheritedData, textEmphasisCustomMark, mark); }</span>
1171     void setTextEmphasisPosition(OptionSet&lt;TextEmphasisPosition&gt; position) { SET_VAR(m_rareInheritedData, textEmphasisPosition, static_cast&lt;unsigned&gt;(position.toRaw())); }
1172     bool setTextOrientation(TextOrientation);
1173 
1174     void setObjectFit(ObjectFit fit) { SET_VAR(m_rareNonInheritedData, objectFit, static_cast&lt;unsigned&gt;(fit)); }
1175     void setObjectPosition(LengthPoint&amp;&amp; position) { SET_VAR(m_rareNonInheritedData, objectPosition, WTFMove(position)); }
1176 
1177     void setRubyPosition(RubyPosition position) { SET_VAR(m_rareInheritedData, rubyPosition, static_cast&lt;unsigned&gt;(position)); }
1178 
1179 #if ENABLE(DARK_MODE_CSS)
<span class="line-modified">1180     void setSupportedColorSchemes(StyleSupportedColorSchemes supported) { SET_VAR(m_rareInheritedData, supportedColorSchemes, supported); }</span>
1181 #endif
1182 
1183     void setFilter(const FilterOperations&amp; ops) { SET_NESTED_VAR(m_rareNonInheritedData, filter, operations, ops); }
1184     void setAppleColorFilter(const FilterOperations&amp; ops) { SET_NESTED_VAR(m_rareInheritedData, appleColorFilter, operations, ops); }
1185 
1186 #if ENABLE(FILTERS_LEVEL_2)
1187     void setBackdropFilter(const FilterOperations&amp; ops) { SET_NESTED_VAR(m_rareNonInheritedData, backdropFilter, operations, ops); }
1188 #endif
1189 
<span class="line-modified">1190     void setTabSize(unsigned size) { SET_VAR(m_rareInheritedData, tabSize, size); }</span>
1191 
1192     void setBreakBefore(BreakBetween breakBehavior) { SET_VAR(m_rareNonInheritedData, breakBefore, static_cast&lt;unsigned&gt;(breakBehavior)); }
1193     void setBreakAfter(BreakBetween breakBehavior) { SET_VAR(m_rareNonInheritedData, breakAfter, static_cast&lt;unsigned&gt;(breakBehavior)); }
1194     void setBreakInside(BreakInside breakBehavior) { SET_VAR(m_rareNonInheritedData, breakInside, static_cast&lt;unsigned&gt;(breakBehavior)); }
1195 
1196     void setHangingPunctuation(OptionSet&lt;HangingPunctuation&gt; punctuation) { SET_VAR(m_rareInheritedData, hangingPunctuation, punctuation.toRaw()); }
1197 
1198     // End CSS3 Setters
1199 
<span class="line-modified">1200     void setLineGrid(const AtomicString&amp; lineGrid) { SET_VAR(m_rareInheritedData, lineGrid, lineGrid); }</span>
1201     void setLineSnap(LineSnap lineSnap) { SET_VAR(m_rareInheritedData, lineSnap, static_cast&lt;unsigned&gt;(lineSnap)); }
1202     void setLineAlign(LineAlign lineAlign) { SET_VAR(m_rareInheritedData, lineAlign, static_cast&lt;unsigned&gt;(lineAlign)); }
1203 
1204     void setPointerEvents(PointerEvents p) { m_inheritedFlags.pointerEvents = static_cast&lt;unsigned&gt;(p); }
1205 
1206     void clearAnimations();
1207     void clearTransitions();
1208 
1209     void adjustAnimations();
1210     void adjustTransitions();
1211 
1212     void setTransformStyle3D(TransformStyle3D b) { SET_VAR(m_rareNonInheritedData, transformStyle3D, static_cast&lt;unsigned&gt;(b)); }
1213     void setBackfaceVisibility(BackfaceVisibility b) { SET_VAR(m_rareNonInheritedData, backfaceVisibility, static_cast&lt;unsigned&gt;(b)); }
1214     void setPerspective(float p) { SET_VAR(m_rareNonInheritedData, perspective, p); }
1215     void setPerspectiveOriginX(Length&amp;&amp; length) { SET_VAR(m_rareNonInheritedData, perspectiveOriginX, WTFMove(length)); }
1216     void setPerspectiveOriginY(Length&amp;&amp; length) { SET_VAR(m_rareNonInheritedData, perspectiveOriginY, WTFMove(length)); }
1217     void setPageSize(LengthSize size) { SET_VAR(m_rareNonInheritedData, pageSize, WTFMove(size)); }
1218     void setPageSizeType(PageSizeType t) { SET_VAR(m_rareNonInheritedData, pageSizeType, t); }
1219     void resetPageSizeType() { SET_VAR(m_rareNonInheritedData, pageSizeType, PAGE_SIZE_AUTO); }
1220 
1221     void setLineBoxContain(LineBoxContain c) { SET_VAR(m_rareInheritedData, lineBoxContain, c); }
1222     void setLineClamp(LineClampValue c) { SET_VAR(m_rareNonInheritedData, lineClamp, c); }
1223 
1224     void setInitialLetter(const IntSize&amp; size) { SET_VAR(m_rareNonInheritedData, initialLetter, size); }
1225 
1226 #if ENABLE(POINTER_EVENTS)
1227     void setTouchActions(OptionSet&lt;TouchAction&gt; touchActions) { SET_VAR(m_rareNonInheritedData, touchActions, touchActions.toRaw()); }

1228 #endif
1229 
1230 #if ENABLE(CSS_SCROLL_SNAP)
1231     void setScrollSnapType(const ScrollSnapType&amp;);
1232     void setScrollPaddingTop(Length&amp;&amp;);
1233     void setScrollPaddingBottom(Length&amp;&amp;);
1234     void setScrollPaddingLeft(Length&amp;&amp;);
1235     void setScrollPaddingRight(Length&amp;&amp;);
1236 
1237     void setScrollSnapAlign(const ScrollSnapAlign&amp;);
1238     void setScrollSnapMarginTop(Length&amp;&amp;);
1239     void setScrollSnapMarginBottom(Length&amp;&amp;);
1240     void setScrollSnapMarginLeft(Length&amp;&amp;);
1241     void setScrollSnapMarginRight(Length&amp;&amp;);
1242 #endif
1243 
1244 #if ENABLE(TOUCH_EVENTS)
1245     void setTapHighlightColor(const Color&amp; c) { SET_VAR(m_rareInheritedData, tapHighlightColor, c); }
1246 #endif
1247 
1248 #if PLATFORM(IOS_FAMILY)
1249     void setTouchCalloutEnabled(bool v) { SET_VAR(m_rareInheritedData, touchCalloutEnabled, v); }
1250 #endif
1251 
<span class="line-modified">1252 #if ENABLE(ACCELERATED_OVERFLOW_SCROLLING)</span>
1253     void setUseTouchOverflowScrolling(bool v) { SET_VAR(m_rareInheritedData, useTouchOverflowScrolling, v); }
1254 #endif
1255 
1256 #if ENABLE(TEXT_AUTOSIZING)
1257     void setTextSizeAdjust(TextSizeAdjustment adjustment) { SET_VAR(m_rareInheritedData, textSizeAdjust, adjustment); }

1258 #endif
1259 
1260     void setTextSecurity(TextSecurity security) { SET_VAR(m_rareInheritedData, textSecurity, static_cast&lt;unsigned&gt;(security)); }
1261 
1262 #if ENABLE(CSS_TRAILING_WORD)
1263     void setTrailingWord(TrailingWord) { }
1264 #endif
1265 
1266 #if ENABLE(APPLE_PAY)
1267     void setApplePayButtonStyle(ApplePayButtonStyle style) { SET_VAR(m_rareNonInheritedData, applePayButtonStyle, static_cast&lt;unsigned&gt;(style)); }
1268     void setApplePayButtonType(ApplePayButtonType type) { SET_VAR(m_rareNonInheritedData, applePayButtonType, static_cast&lt;unsigned&gt;(type)); }
1269 #endif
1270 
1271 #if ENABLE(CSS_PAINTING_API)
1272     void addCustomPaintWatchProperty(const String&amp; name);
1273 #endif
1274 
1275     // Support for paint-order, stroke-linecap, stroke-linejoin, and stroke-miterlimit from https://drafts.fxtf.org/paint/.
1276     void setPaintOrder(PaintOrder order) { SET_VAR(m_rareInheritedData, paintOrder, static_cast&lt;unsigned&gt;(order)); }
1277     PaintOrder paintOrder() const { return static_cast&lt;PaintOrder&gt;(m_rareInheritedData-&gt;paintOrder); }
</pre>
<hr />
<pre>
1382     void setContent(const String&amp;, bool add = false);
1383     void setContent(RefPtr&lt;StyleImage&gt;&amp;&amp;, bool add = false);
1384     void setContent(std::unique_ptr&lt;CounterContent&gt;, bool add = false);
1385     void setContent(QuoteType, bool add = false);
1386     void setContentAltText(const String&amp;);
1387     const String&amp; contentAltText() const;
1388     bool hasAttrContent() const { return m_rareNonInheritedData-&gt;hasAttrContent; }
1389     void setHasAttrContent();
1390 
1391     const CounterDirectiveMap* counterDirectives() const;
1392     CounterDirectiveMap&amp; accessCounterDirectives();
1393 
1394     QuotesData* quotes() const { return m_rareInheritedData-&gt;quotes.get(); }
1395     void setQuotes(RefPtr&lt;QuotesData&gt;&amp;&amp;);
1396 
1397     WillChangeData* willChange() const { return m_rareNonInheritedData-&gt;willChange.get(); }
1398     void setWillChange(RefPtr&lt;WillChangeData&gt;&amp;&amp;);
1399 
1400     bool willChangeCreatesStackingContext() const;
1401 
<span class="line-modified">1402     const AtomicString&amp; hyphenString() const;</span>
1403 
1404     bool inheritedNotEqual(const RenderStyle*) const;
1405     bool inheritedDataShared(const RenderStyle*) const;
1406 
1407 #if ENABLE(TEXT_AUTOSIZING)
1408     uint32_t hashForTextAutosizing() const;
1409     bool equalForTextAutosizing(const RenderStyle&amp;) const;
1410 #endif
1411 
1412     StyleDifference diff(const RenderStyle&amp;, OptionSet&lt;StyleDifferenceContextSensitiveProperty&gt;&amp; changedContextSensitiveProperties) const;
1413     bool diffRequiresLayerRepaint(const RenderStyle&amp;, bool isComposited) const;
1414 
1415     bool isDisplayInlineType() const { return isDisplayInlineType(display()); }
1416     bool isOriginalDisplayInlineType() const { return isDisplayInlineType(originalDisplay()); }
1417     bool isDisplayFlexibleOrGridBox() const { return isDisplayFlexibleOrGridBox(display()); }
1418     bool isDisplayRegionType() const;
1419 
1420     bool setWritingMode(WritingMode);
1421 
1422     bool hasExplicitlySetWritingMode() const { return m_nonInheritedFlags.hasExplicitlySetWritingMode; }
</pre>
<hr />
<pre>
1536     static int initialMarqueeLoopCount() { return -1; }
1537     static int initialMarqueeSpeed() { return 85; }
1538     static Length initialMarqueeIncrement() { return Length(6, Fixed); }
1539     static MarqueeBehavior initialMarqueeBehavior() { return MarqueeBehavior::Scroll; }
1540     static MarqueeDirection initialMarqueeDirection() { return MarqueeDirection::Auto; }
1541     static UserModify initialUserModify() { return UserModify::ReadOnly; }
1542     static UserDrag initialUserDrag() { return UserDrag::Auto; }
1543     static UserSelect initialUserSelect() { return UserSelect::Text; }
1544     static TextOverflow initialTextOverflow() { return TextOverflow::Clip; }
1545     static MarginCollapse initialMarginBeforeCollapse() { return MarginCollapse::Collapse; }
1546     static MarginCollapse initialMarginAfterCollapse() { return MarginCollapse::Collapse; }
1547     static WordBreak initialWordBreak() { return WordBreak::Normal; }
1548     static OverflowWrap initialOverflowWrap() { return OverflowWrap::Normal; }
1549     static NBSPMode initialNBSPMode() { return NBSPMode::Normal; }
1550     static LineBreak initialLineBreak() { return LineBreak::Auto; }
1551     static OptionSet&lt;SpeakAs&gt; initialSpeakAs() { return OptionSet&lt;SpeakAs&gt; { }; }
1552     static Hyphens initialHyphens() { return Hyphens::Manual; }
1553     static short initialHyphenationLimitBefore() { return -1; }
1554     static short initialHyphenationLimitAfter() { return -1; }
1555     static short initialHyphenationLimitLines() { return -1; }
<span class="line-modified">1556     static const AtomicString&amp; initialHyphenationString() { return nullAtom(); }</span>
1557     static BorderFit initialBorderFit() { return BorderFit::Border; }
1558     static Resize initialResize() { return Resize::None; }
1559     static ControlPart initialAppearance() { return NoControlPart; }
1560     static AspectRatioType initialAspectRatioType() { return AspectRatioType::Auto; }
1561     static float initialAspectRatioDenominator() { return 1; }
1562     static float initialAspectRatioNumerator() { return 1; }
1563     static Order initialRTLOrdering() { return Order::Logical; }
1564     static float initialTextStrokeWidth() { return 0; }
1565     static unsigned short initialColumnCount() { return 1; }
1566     static ColumnFill initialColumnFill() { return ColumnFill::Balance; }
1567     static ColumnSpan initialColumnSpan() { return ColumnSpan::None; }
1568     static GapLength initialColumnGap() { return GapLength(); }
1569     static GapLength initialRowGap() { return GapLength(); }
1570     static const TransformOperations&amp; initialTransform() { static NeverDestroyed&lt;TransformOperations&gt; ops; return ops; }
1571     static Length initialTransformOriginX() { return Length(50.0f, Percent); }
1572     static Length initialTransformOriginY() { return Length(50.0f, Percent); }
1573     static TransformBox initialTransformBox() { return TransformBox::BorderBox; }
1574     static PointerEvents initialPointerEvents() { return PointerEvents::Auto; }
1575     static float initialTransformOriginZ() { return 0; }
1576     static TransformStyle3D initialTransformStyle3D() { return TransformStyle3D::Flat; }
1577     static BackfaceVisibility initialBackfaceVisibility() { return BackfaceVisibility::Visible; }
1578     static float initialPerspective() { return 0; }
1579     static Length initialPerspectiveOriginX() { return Length(50.0f, Percent); }
1580     static Length initialPerspectiveOriginY() { return Length(50.0f, Percent); }
1581     static Color initialBackgroundColor() { return Color::transparent; }
1582     static Color initialTextEmphasisColor() { return Color(); }
1583     static TextEmphasisFill initialTextEmphasisFill() { return TextEmphasisFill::Filled; }
1584     static TextEmphasisMark initialTextEmphasisMark() { return TextEmphasisMark::None; }
<span class="line-modified">1585     static const AtomicString&amp; initialTextEmphasisCustomMark() { return nullAtom(); }</span>
1586     static OptionSet&lt;TextEmphasisPosition&gt; initialTextEmphasisPosition() { return { TextEmphasisPosition::Over, TextEmphasisPosition::Right }; }
1587     static RubyPosition initialRubyPosition() { return RubyPosition::Before; }
1588     static LineBoxContain initialLineBoxContain() { return LineBoxContainBlock | LineBoxContainInline | LineBoxContainReplaced; }
<span class="line-modified">1589     static ImageOrientationEnum initialImageOrientation() { return OriginTopLeft; }</span>
1590     static ImageRendering initialImageRendering() { return ImageRendering::Auto; }
1591     static ImageResolutionSource initialImageResolutionSource() { return ImageResolutionSource::Specified; }
1592     static ImageResolutionSnap initialImageResolutionSnap() { return ImageResolutionSnap::None; }
1593     static float initialImageResolution() { return 1; }
1594     static StyleImage* initialBorderImageSource() { return nullptr; }
1595     static StyleImage* initialMaskBoxImageSource() { return nullptr; }
1596     static PrintColorAdjust initialPrintColorAdjust() { return PrintColorAdjust::Economy; }
1597     static QuotesData* initialQuotes() { return nullptr; }
<span class="line-modified">1598     static const AtomicString&amp; initialContentAltText() { return emptyAtom(); }</span>
1599 
1600 #if ENABLE(DARK_MODE_CSS)
<span class="line-modified">1601     static StyleSupportedColorSchemes initialSupportedColorSchemes() { return { }; }</span>
1602 #endif
1603 
1604 #if ENABLE(CSS3_TEXT)
1605     static TextIndentLine initialTextIndentLine() { return TextIndentLine::FirstLine; }
1606     static TextIndentType initialTextIndentType() { return TextIndentType::Normal; }
1607     static TextAlignLast initialTextAlignLast() { return TextAlignLast::Auto; }
1608     static TextJustify initialTextJustify() { return TextJustify::Auto; }
1609 #endif
1610 
1611 #if ENABLE(CURSOR_VISIBILITY)
1612     static CursorVisibility initialCursorVisibility() { return CursorVisibility::Auto; }
1613 #endif
1614 
1615 #if ENABLE(TEXT_AUTOSIZING)
1616     static Length initialSpecifiedLineHeight() { return Length(-100.0f, Percent); }
1617     static TextSizeAdjustment initialTextSizeAdjust() { return TextSizeAdjustment(); }
1618 #endif
1619 
1620     static WillChangeData* initialWillChange() { return nullptr; }
1621 
</pre>
<hr />
<pre>
1650     static GridAutoFlow initialGridAutoFlow() { return AutoFlowRow; }
1651 
1652     static Vector&lt;GridTrackSize&gt; initialGridAutoColumns() { return { GridTrackSize(Length(Auto)) }; }
1653     static Vector&lt;GridTrackSize&gt; initialGridAutoRows() { return { GridTrackSize(Length(Auto)) }; }
1654 
1655     static NamedGridAreaMap initialNamedGridArea() { return NamedGridAreaMap(); }
1656     static size_t initialNamedGridAreaCount() { return 0; }
1657 
1658     static NamedGridLinesMap initialNamedGridColumnLines() { return NamedGridLinesMap(); }
1659     static NamedGridLinesMap initialNamedGridRowLines() { return NamedGridLinesMap(); }
1660 
1661     static OrderedNamedGridLinesMap initialOrderedNamedGridColumnLines() { return OrderedNamedGridLinesMap(); }
1662     static OrderedNamedGridLinesMap initialOrderedNamedGridRowLines() { return OrderedNamedGridLinesMap(); }
1663 
1664     // &#39;auto&#39; is the default.
1665     static GridPosition initialGridItemColumnStart() { return GridPosition(); }
1666     static GridPosition initialGridItemColumnEnd() { return GridPosition(); }
1667     static GridPosition initialGridItemRowStart() { return GridPosition(); }
1668     static GridPosition initialGridItemRowEnd() { return GridPosition(); }
1669 
<span class="line-modified">1670     static unsigned initialTabSize() { return 8; }</span>
1671 
<span class="line-modified">1672     static const AtomicString&amp; initialLineGrid() { return nullAtom(); }</span>
1673     static LineSnap initialLineSnap() { return LineSnap::None; }
1674     static LineAlign initialLineAlign() { return LineAlign::None; }
1675 
1676     static IntSize initialInitialLetter() { return IntSize(); }
1677     static LineClampValue initialLineClamp() { return LineClampValue(); }
1678     static TextSecurity initialTextSecurity() { return TextSecurity::None; }
1679 
1680 #if PLATFORM(IOS_FAMILY)
1681     static bool initialTouchCalloutEnabled() { return true; }
1682 #endif
1683 
1684 #if ENABLE(TOUCH_EVENTS)
1685     static Color initialTapHighlightColor();
1686 #endif
1687 
<span class="line-modified">1688 #if ENABLE(ACCELERATED_OVERFLOW_SCROLLING)</span>
1689     static bool initialUseTouchOverflowScrolling() { return false; }
1690 #endif
1691 
<span class="line-removed">1692 #if ENABLE(DASHBOARD_SUPPORT)</span>
<span class="line-removed">1693     static const Vector&lt;StyleDashboardRegion&gt;&amp; initialDashboardRegions();</span>
<span class="line-removed">1694     static const Vector&lt;StyleDashboardRegion&gt;&amp; noneDashboardRegions();</span>
<span class="line-removed">1695 #endif</span>
<span class="line-removed">1696 </span>
1697     static const FilterOperations&amp; initialFilter() { static NeverDestroyed&lt;FilterOperations&gt; ops; return ops; }
1698     static const FilterOperations&amp; initialAppleColorFilter() { static NeverDestroyed&lt;FilterOperations&gt; ops; return ops; }
1699 
1700 #if ENABLE(FILTERS_LEVEL_2)
1701     static const FilterOperations&amp; initialBackdropFilter() { static NeverDestroyed&lt;FilterOperations&gt; ops; return ops; }
1702 #endif
1703 
1704 #if ENABLE(CSS_COMPOSITING)
1705     static BlendMode initialBlendMode() { return BlendMode::Normal; }
1706     static Isolation initialIsolation() { return Isolation::Auto; }
1707 #endif
1708 
1709     // Indicates the style is likely to change due to a pending stylesheet load.
1710     bool isNotFinal() const { return m_rareNonInheritedData-&gt;isNotFinal; }
1711     void setIsNotFinal() { SET_VAR(m_rareNonInheritedData, isNotFinal, true); }
1712 
1713     void setVisitedLinkColor(const Color&amp;);
1714     void setVisitedLinkBackgroundColor(const Color&amp; v) { SET_VAR(m_rareNonInheritedData, visitedLinkBackgroundColor, v); }
1715     void setVisitedLinkBorderLeftColor(const Color&amp; v) { SET_VAR(m_rareNonInheritedData, visitedLinkBorderLeftColor, v); }
1716     void setVisitedLinkBorderRightColor(const Color&amp; v) { SET_VAR(m_rareNonInheritedData, visitedLinkBorderRightColor, v); }
</pre>
<hr />
<pre>
1773         bool hasAnyPublicPseudoStyles() const { return static_cast&lt;unsigned&gt;(PseudoId::PublicPseudoIdMask) &amp; pseudoBits; }
1774         bool hasPseudoStyle(PseudoId) const;
1775         void setHasPseudoStyle(PseudoId);
1776         void setHasPseudoStyles(PseudoIdSet);
1777 
1778         unsigned effectiveDisplay : 5; // DisplayType
1779         unsigned originalDisplay : 5; // DisplayType
1780         unsigned overflowX : 3; // Overflow
1781         unsigned overflowY : 3; // Overflow
1782         unsigned verticalAlign : 4; // VerticalAlign
1783         unsigned clear : 2; // Clear
1784         unsigned position : 3; // PositionType
1785         unsigned unicodeBidi : 3; // EUnicodeBidi
1786         unsigned floating : 2; // Float
1787         unsigned tableLayout : 1; // TableLayoutType
1788 
1789         unsigned hasExplicitlySetDirection : 1;
1790         unsigned hasExplicitlySetWritingMode : 1;
1791         unsigned hasExplicitlySetTextAlign : 1;
1792 #if ENABLE(DARK_MODE_CSS)
<span class="line-modified">1793         unsigned hasExplicitlySetSupportedColorSchemes : 1;</span>
1794 #endif
1795         unsigned hasViewportUnits : 1;
1796         unsigned hasExplicitlyInheritedProperties : 1; // Explicitly inherits a non-inherited property.
1797         unsigned isUnique : 1; // Style cannot be shared.
1798         unsigned emptyState : 1;
1799         unsigned firstChildState : 1;
1800         unsigned lastChildState : 1;
1801         unsigned affectedByHover : 1;
1802         unsigned affectedByActive : 1;
1803         unsigned affectedByDrag : 1;
1804         unsigned isLink : 1;
1805 
1806         unsigned styleType : 4; // PseudoId
1807         unsigned pseudoBits : (static_cast&lt;unsigned&gt;(PseudoId::FirstInternalPseudoId) - static_cast&lt;unsigned&gt;(PseudoId::FirstPublicPseudoId));
1808 
1809         // If you add more style bits here, you will also need to update RenderStyle::NonInheritedFlags::copyNonInheritedFrom().
1810     };
1811 
1812     struct InheritedFlags {
1813         bool operator==(const InheritedFlags&amp;) const;
</pre>
<hr />
<pre>
1825 #if ENABLE(CURSOR_VISIBILITY)
1826         unsigned cursorVisibility : 1; // CursorVisibility
1827 #endif
1828         unsigned direction : 1; // TextDirection
1829         unsigned whiteSpace : 3; // WhiteSpace
1830         // 35 bits
1831         unsigned borderCollapse : 1; // BorderCollapse
1832         unsigned boxDirection : 1; // BoxDirection
1833 
1834         // non CSS2 inherited
1835         unsigned rtlOrdering : 1; // Order
1836         unsigned printColorAdjust : PrintColorAdjustBits; // PrintColorAdjust
1837         unsigned pointerEvents : 4; // PointerEvents
1838         unsigned insideLink : 2; // InsideLink
1839         unsigned insideDefaultButton : 1;
1840         // 46 bits
1841 
1842         // CSS Text Layout Module Level 3: Vertical writing support
1843         unsigned writingMode : 2; // WritingMode
1844         // 48 bits





1845     };
1846 
1847     // This constructor is used to implement the replace operation.
1848     RenderStyle(RenderStyle&amp;, RenderStyle&amp;&amp;);
1849 
1850     DisplayType originalDisplay() const { return static_cast&lt;DisplayType&gt;(m_nonInheritedFlags.originalDisplay); }
1851 
1852     bool hasAutoLeftAndRight() const { return left().isAuto() &amp;&amp; right().isAuto(); }
1853     bool hasAutoTopAndBottom() const { return top().isAuto() &amp;&amp; bottom().isAuto(); }
1854 
1855     void setContent(std::unique_ptr&lt;ContentData&gt;, bool add);
1856 
1857     LayoutBoxExtent getShadowInsetExtent(const ShadowData*) const;
1858 
1859     static bool isDisplayReplacedType(DisplayType);
1860     static bool isDisplayInlineType(DisplayType);
1861     static bool isDisplayFlexibleBox(DisplayType);
1862     static bool isDisplayGridBox(DisplayType);
1863     static bool isDisplayFlexibleOrGridBox(DisplayType);
1864 
</pre>
<hr />
<pre>
1902 BorderStyle collapsedBorderStyle(BorderStyle);
1903 
1904 bool pseudoElementRendererIsNeeded(const RenderStyle*);
1905 
1906 inline bool RenderStyle::NonInheritedFlags::operator==(const NonInheritedFlags&amp; other) const
1907 {
1908     return effectiveDisplay == other.effectiveDisplay
1909         &amp;&amp; originalDisplay == other.originalDisplay
1910         &amp;&amp; overflowX == other.overflowX
1911         &amp;&amp; overflowY == other.overflowY
1912         &amp;&amp; verticalAlign == other.verticalAlign
1913         &amp;&amp; clear == other.clear
1914         &amp;&amp; position == other.position
1915         &amp;&amp; unicodeBidi == other.unicodeBidi
1916         &amp;&amp; floating == other.floating
1917         &amp;&amp; tableLayout == other.tableLayout
1918         &amp;&amp; hasExplicitlySetDirection == other.hasExplicitlySetDirection
1919         &amp;&amp; hasExplicitlySetWritingMode == other.hasExplicitlySetWritingMode
1920         &amp;&amp; hasExplicitlySetTextAlign == other.hasExplicitlySetTextAlign
1921 #if ENABLE(DARK_MODE_CSS)
<span class="line-modified">1922         &amp;&amp; hasExplicitlySetSupportedColorSchemes == other.hasExplicitlySetSupportedColorSchemes</span>
1923 #endif
1924         &amp;&amp; hasViewportUnits == other.hasViewportUnits
1925         &amp;&amp; hasExplicitlyInheritedProperties == other.hasExplicitlyInheritedProperties
1926         &amp;&amp; isUnique == other.isUnique
1927         &amp;&amp; emptyState == other.emptyState
1928         &amp;&amp; firstChildState == other.firstChildState
1929         &amp;&amp; lastChildState == other.lastChildState
1930         &amp;&amp; affectedByHover == other.affectedByHover
1931         &amp;&amp; affectedByActive == other.affectedByActive
1932         &amp;&amp; affectedByDrag == other.affectedByDrag
1933         &amp;&amp; isLink == other.isLink
1934         &amp;&amp; styleType == other.styleType
1935         &amp;&amp; pseudoBits == other.pseudoBits;
1936 }
1937 
1938 inline void RenderStyle::NonInheritedFlags::copyNonInheritedFrom(const NonInheritedFlags&amp; other)
1939 {
1940     // Only a subset is copied because NonInheritedFlags contains a bunch of stuff other than real style data.
1941     effectiveDisplay = other.effectiveDisplay;
1942     originalDisplay = other.originalDisplay;
</pre>
<hr />
<pre>
2005     if (zoomFactor == 1)
2006         return value;
2007     // Needed because computeLengthInt truncates (rather than rounds) when scaling up.
2008     if (zoomFactor &gt; 1) {
2009         if (value &lt; 0)
2010             value--;
2011         else
2012             value++;
2013     }
2014 
2015     return roundForImpreciseConversion&lt;int&gt;(value / zoomFactor);
2016 }
2017 
2018 inline float adjustFloatForAbsoluteZoom(float value, const RenderStyle&amp; style)
2019 {
2020     return value / style.effectiveZoom();
2021 }
2022 
2023 inline LayoutUnit adjustLayoutUnitForAbsoluteZoom(LayoutUnit value, const RenderStyle&amp; style)
2024 {
<span class="line-modified">2025     return value / style.effectiveZoom();</span>
2026 }
2027 
2028 inline BorderStyle collapsedBorderStyle(BorderStyle style)
2029 {
2030     if (style == BorderStyle::Outset)
2031         return BorderStyle::Groove;
2032     if (style == BorderStyle::Inset)
2033         return BorderStyle::Ridge;
2034     return style;
2035 }
2036 
<span class="line-modified">2037 inline const CSSCustomPropertyValue* RenderStyle::getCustomProperty(const AtomicString&amp; name) const</span>
2038 {
2039     for (auto* map : { &amp;nonInheritedCustomProperties(), &amp;inheritedCustomProperties() }) {
2040         if (auto* val = map-&gt;get(name))
2041             return val;
2042     }
2043     return nullptr;
2044 }
2045 
2046 inline bool RenderStyle::hasBackground() const
2047 {
2048     return visitedDependentColor(CSSPropertyBackgroundColor).isVisible() ||  hasBackgroundImage();
2049 }
2050 
2051 inline bool RenderStyle::autoWrap(WhiteSpace whiteSpace)
2052 {
2053     // Nowrap and pre don&#39;t automatically wrap.
2054     return whiteSpace != WhiteSpace::NoWrap &amp;&amp; whiteSpace != WhiteSpace::Pre;
2055 }
2056 
2057 inline bool RenderStyle::preserveNewline(WhiteSpace whiteSpace)
2058 {
2059     // Normal and nowrap do not preserve newlines.
2060     return whiteSpace != WhiteSpace::Normal &amp;&amp; whiteSpace != WhiteSpace::NoWrap;
2061 }
2062 
2063 inline bool RenderStyle::collapseWhiteSpace(WhiteSpace ws)
2064 {
2065     // Pre and prewrap do not collapse whitespace.
<span class="line-modified">2066     return ws != WhiteSpace::Pre &amp;&amp; ws != WhiteSpace::PreWrap;</span>
2067 }
2068 
2069 inline bool RenderStyle::isCollapsibleWhiteSpace(UChar character) const
2070 {
2071     switch (character) {
2072     case &#39; &#39;:
2073     case &#39;\t&#39;:
2074         return collapseWhiteSpace();
2075     case &#39;\n&#39;:
2076         return !preserveNewline();
2077     default:
2078         return false;
2079     }
2080 }
2081 
2082 inline bool RenderStyle::breakOnlyAfterWhiteSpace() const
2083 {
<span class="line-modified">2084     return whiteSpace() == WhiteSpace::PreWrap || lineBreak() == LineBreak::AfterWhiteSpace;</span>
2085 }
2086 
2087 inline bool RenderStyle::breakWords() const
2088 {
2089     return wordBreak() == WordBreak::BreakWord || overflowWrap() == OverflowWrap::Break;
2090 }
2091 
2092 inline bool RenderStyle::hasInlineColumnAxis() const
2093 {
2094     auto axis = columnAxis();
2095     return axis == ColumnAxis::Auto || isHorizontalWritingMode() == (axis == ColumnAxis::Horizontal);
2096 }
2097 
<span class="line-modified">2098 inline ImageOrientationEnum RenderStyle::imageOrientation() const</span>
2099 {
2100 #if ENABLE(CSS_IMAGE_ORIENTATION)
<span class="line-modified">2101     return static_cast&lt;ImageOrientationEnum&gt;(m_rareInheritedData-&gt;imageOrientation);</span>
2102 #else
<span class="line-modified">2103     return DefaultImageOrientation;</span>
2104 #endif
2105 }
2106 
2107 inline void RenderStyle::setLogicalWidth(Length&amp;&amp; logicalWidth)
2108 {
2109     if (isHorizontalWritingMode())
2110         setWidth(WTFMove(logicalWidth));
2111     else
2112         setHeight(WTFMove(logicalWidth));
2113 }
2114 
2115 inline void RenderStyle::setLogicalHeight(Length&amp;&amp; logicalHeight)
2116 {
2117     if (isHorizontalWritingMode())
2118         setHeight(WTFMove(logicalHeight));
2119     else
2120         setWidth(WTFMove(logicalHeight));
2121 }
2122 
2123 inline void RenderStyle::setBorderRadius(LengthSize&amp;&amp; size)
</pre>
</td>
<td>
<hr />
<pre>
  60 #include &quot;StyleRareNonInheritedData.h&quot;
  61 #include &quot;StyleReflection.h&quot;
  62 #include &quot;StyleSurroundData.h&quot;
  63 #include &quot;StyleTransformData.h&quot;
  64 #include &quot;StyleVisualData.h&quot;
  65 #include &quot;TextFlags.h&quot;
  66 #include &quot;ThemeTypes.h&quot;
  67 #include &quot;TouchAction.h&quot;
  68 #include &quot;TransformOperations.h&quot;
  69 #include &quot;UnicodeBidi.h&quot;
  70 #include &lt;memory&gt;
  71 #include &lt;wtf/Forward.h&gt;
  72 #include &lt;wtf/NeverDestroyed.h&gt;
  73 #include &lt;wtf/OptionSet.h&gt;
  74 #include &lt;wtf/StdLibExtras.h&gt;
  75 #include &lt;wtf/Vector.h&gt;
  76 
  77 #include &quot;StyleGridData.h&quot;
  78 #include &quot;StyleGridItemData.h&quot;
  79 




  80 #if ENABLE(TEXT_AUTOSIZING)
  81 #include &quot;TextSizeAdjustment.h&quot;
  82 #endif
  83 
  84 #if ENABLE(DARK_MODE_CSS)
<span class="line-modified">  85 #include &quot;StyleColorScheme.h&quot;</span>
  86 #endif
  87 
  88 #define SET_VAR(group, variable, value) do { \
  89         if (!compareEqual(group-&gt;variable, value)) \
  90             group.access().variable = value; \
  91     } while (0)
  92 
  93 #define SET_NESTED_VAR(group, parentVariable, variable, value) do { \
  94         if (!compareEqual(group-&gt;parentVariable-&gt;variable, value)) \
  95             group.access().parentVariable.access().variable = value; \
  96     } while (0)
  97 
  98 #define SET_BORDERVALUE_COLOR(group, variable, value) do { \
  99         if (!compareEqual(group-&gt;variable.color(), value)) \
 100             group.access().variable.setColor(value); \
 101     } while (0)
 102 
 103 namespace WebCore {
 104 
 105 class BorderData;
</pre>
<hr />
<pre>
 169     ContentPosition resolvedAlignContentPosition(const StyleContentAlignmentData&amp; normalValueBehavior) const;
 170     ContentDistribution resolvedAlignContentDistribution(const StyleContentAlignmentData&amp; normalValueBehavior) const;
 171     StyleSelfAlignmentData resolvedAlignItems(ItemPosition normalValueBehaviour) const;
 172     StyleSelfAlignmentData resolvedAlignSelf(const RenderStyle* parentStyle, ItemPosition normalValueBehaviour) const;
 173     StyleContentAlignmentData resolvedAlignContent(const StyleContentAlignmentData&amp; normalValueBehaviour) const;
 174     StyleSelfAlignmentData resolvedJustifyItems(ItemPosition normalValueBehaviour) const;
 175     StyleSelfAlignmentData resolvedJustifySelf(const RenderStyle* parentStyle, ItemPosition normalValueBehaviour) const;
 176     StyleContentAlignmentData resolvedJustifyContent(const StyleContentAlignmentData&amp; normalValueBehaviour) const;
 177 
 178     PseudoId styleType() const { return static_cast&lt;PseudoId&gt;(m_nonInheritedFlags.styleType); }
 179     void setStyleType(PseudoId styleType) { m_nonInheritedFlags.styleType = static_cast&lt;unsigned&gt;(styleType); }
 180 
 181     RenderStyle* getCachedPseudoStyle(PseudoId) const;
 182     RenderStyle* addCachedPseudoStyle(std::unique_ptr&lt;RenderStyle&gt;);
 183     void removeCachedPseudoStyle(PseudoId);
 184 
 185     const PseudoStyleCache* cachedPseudoStyles() const { return m_cachedPseudoStyles.get(); }
 186 
 187     const CustomPropertyValueMap&amp; inheritedCustomProperties() const { return m_rareInheritedData-&gt;customProperties-&gt;values; }
 188     const CustomPropertyValueMap&amp; nonInheritedCustomProperties() const { return m_rareNonInheritedData-&gt;customProperties-&gt;values; }
<span class="line-modified"> 189     const CSSCustomPropertyValue* getCustomProperty(const AtomString&amp;) const;</span>
<span class="line-modified"> 190     void setInheritedCustomPropertyValue(const AtomString&amp; name, Ref&lt;CSSCustomPropertyValue&gt;&amp;&amp; value) { return m_rareInheritedData.access().customProperties.access().setCustomPropertyValue(name, WTFMove(value)); }</span>
<span class="line-modified"> 191     void setNonInheritedCustomPropertyValue(const AtomString&amp; name, Ref&lt;CSSCustomPropertyValue&gt;&amp;&amp; value) { return m_rareNonInheritedData.access().customProperties.access().setCustomPropertyValue(name, WTFMove(value)); }</span>
 192 
 193     void setHasViewportUnits(bool v = true) { m_nonInheritedFlags.hasViewportUnits = v; }
 194     bool hasViewportUnits() const { return m_nonInheritedFlags.hasViewportUnits; }
 195 
 196     bool affectedByHover() const { return m_nonInheritedFlags.affectedByHover; }
 197     bool affectedByActive() const { return m_nonInheritedFlags.affectedByActive; }
 198     bool affectedByDrag() const { return m_nonInheritedFlags.affectedByDrag; }
 199 
 200     void setAffectedByHover() { m_nonInheritedFlags.affectedByHover = true; }
 201     void setAffectedByActive() { m_nonInheritedFlags.affectedByActive = true; }
 202     void setAffectedByDrag() { m_nonInheritedFlags.affectedByDrag = true; }
 203 
 204     void setColumnStylesFromPaginationMode(const Pagination::Mode&amp;);
 205 
 206     bool isFloating() const { return static_cast&lt;Float&gt;(m_nonInheritedFlags.floating) != Float::No; }
 207     bool hasMargin() const { return !m_surroundData-&gt;margin.isZero(); }
 208     bool hasBorder() const { return m_surroundData-&gt;border.hasBorder(); }
 209     bool hasBorderFill() const { return m_surroundData-&gt;border.hasFill(); }
 210     bool hasVisibleBorderDecoration() const { return hasVisibleBorder() || hasBorderFill(); }
 211     bool hasVisibleBorder() const { return m_surroundData-&gt;border.hasVisibleBorder(); }
</pre>
<hr />
<pre>
 581     BoxSizing boxSizing() const { return m_boxData-&gt;boxSizing(); }
 582     const Length&amp; marqueeIncrement() const { return m_rareNonInheritedData-&gt;marquee-&gt;increment; }
 583     int marqueeSpeed() const { return m_rareNonInheritedData-&gt;marquee-&gt;speed; }
 584     int marqueeLoopCount() const { return m_rareNonInheritedData-&gt;marquee-&gt;loops; }
 585     MarqueeBehavior marqueeBehavior() const { return static_cast&lt;MarqueeBehavior&gt;(m_rareNonInheritedData-&gt;marquee-&gt;behavior); }
 586     MarqueeDirection marqueeDirection() const { return static_cast&lt;MarqueeDirection&gt;(m_rareNonInheritedData-&gt;marquee-&gt;direction); }
 587     UserModify userModify() const { return static_cast&lt;UserModify&gt;(m_rareInheritedData-&gt;userModify); }
 588     UserDrag userDrag() const { return static_cast&lt;UserDrag&gt;(m_rareNonInheritedData-&gt;userDrag); }
 589     UserSelect userSelect() const { return static_cast&lt;UserSelect&gt;(m_rareInheritedData-&gt;userSelect); }
 590     TextOverflow textOverflow() const { return static_cast&lt;TextOverflow&gt;(m_rareNonInheritedData-&gt;textOverflow); }
 591     MarginCollapse marginBeforeCollapse() const { return static_cast&lt;MarginCollapse&gt;(m_rareNonInheritedData-&gt;marginBeforeCollapse); }
 592     MarginCollapse marginAfterCollapse() const { return static_cast&lt;MarginCollapse&gt;(m_rareNonInheritedData-&gt;marginAfterCollapse); }
 593     WordBreak wordBreak() const { return static_cast&lt;WordBreak&gt;(m_rareInheritedData-&gt;wordBreak); }
 594     OverflowWrap overflowWrap() const { return static_cast&lt;OverflowWrap&gt;(m_rareInheritedData-&gt;overflowWrap); }
 595     NBSPMode nbspMode() const { return static_cast&lt;NBSPMode&gt;(m_rareInheritedData-&gt;nbspMode); }
 596     LineBreak lineBreak() const { return static_cast&lt;LineBreak&gt;(m_rareInheritedData-&gt;lineBreak); }
 597     Hyphens hyphens() const { return static_cast&lt;Hyphens&gt;(m_rareInheritedData-&gt;hyphens); }
 598     short hyphenationLimitBefore() const { return m_rareInheritedData-&gt;hyphenationLimitBefore; }
 599     short hyphenationLimitAfter() const { return m_rareInheritedData-&gt;hyphenationLimitAfter; }
 600     short hyphenationLimitLines() const { return m_rareInheritedData-&gt;hyphenationLimitLines; }
<span class="line-modified"> 601     const AtomString&amp; hyphenationString() const { return m_rareInheritedData-&gt;hyphenationString; }</span>
<span class="line-modified"> 602     const AtomString&amp; locale() const { return fontDescription().locale(); }</span>
 603     BorderFit borderFit() const { return static_cast&lt;BorderFit&gt;(m_rareNonInheritedData-&gt;borderFit); }
 604     Resize resize() const { return static_cast&lt;Resize&gt;(m_rareNonInheritedData-&gt;resize); }
 605     ColumnAxis columnAxis() const { return static_cast&lt;ColumnAxis&gt;(m_rareNonInheritedData-&gt;multiCol-&gt;axis); }
 606     bool hasInlineColumnAxis() const;
 607     ColumnProgression columnProgression() const { return static_cast&lt;ColumnProgression&gt;(m_rareNonInheritedData-&gt;multiCol-&gt;progression); }
 608     float columnWidth() const { return m_rareNonInheritedData-&gt;multiCol-&gt;width; }
 609     bool hasAutoColumnWidth() const { return m_rareNonInheritedData-&gt;multiCol-&gt;autoWidth; }
 610     unsigned short columnCount() const { return m_rareNonInheritedData-&gt;multiCol-&gt;count; }
 611     bool hasAutoColumnCount() const { return m_rareNonInheritedData-&gt;multiCol-&gt;autoCount; }
 612     bool specifiesColumns() const { return !hasAutoColumnCount() || !hasAutoColumnWidth() || !hasInlineColumnAxis(); }
 613     ColumnFill columnFill() const { return static_cast&lt;ColumnFill&gt;(m_rareNonInheritedData-&gt;multiCol-&gt;fill); }
 614     const GapLength&amp; columnGap() const { return m_rareNonInheritedData-&gt;columnGap; }
 615     const GapLength&amp; rowGap() const { return m_rareNonInheritedData-&gt;rowGap; }
 616     BorderStyle columnRuleStyle() const { return m_rareNonInheritedData-&gt;multiCol-&gt;rule.style(); }
 617     unsigned short columnRuleWidth() const { return m_rareNonInheritedData-&gt;multiCol-&gt;ruleWidth(); }
 618     bool columnRuleIsTransparent() const { return m_rareNonInheritedData-&gt;multiCol-&gt;rule.isTransparent(); }
 619     ColumnSpan columnSpan() const { return static_cast&lt;ColumnSpan&gt;(m_rareNonInheritedData-&gt;multiCol-&gt;columnSpan); }
 620 
 621     const TransformOperations&amp; transform() const { return m_rareNonInheritedData-&gt;transform-&gt;operations; }
 622     bool hasTransform() const { return !m_rareNonInheritedData-&gt;transform-&gt;operations.operations().isEmpty(); }
 623     const Length&amp; transformOriginX() const { return m_rareNonInheritedData-&gt;transform-&gt;x; }
 624     const Length&amp; transformOriginY() const { return m_rareNonInheritedData-&gt;transform-&gt;y; }
 625     float transformOriginZ() const { return m_rareNonInheritedData-&gt;transform-&gt;z; }
 626     TransformBox transformBox() const { return m_rareNonInheritedData-&gt;transform-&gt;transformBox; }
 627 
 628     TextEmphasisFill textEmphasisFill() const { return static_cast&lt;TextEmphasisFill&gt;(m_rareInheritedData-&gt;textEmphasisFill); }
 629     TextEmphasisMark textEmphasisMark() const;
<span class="line-modified"> 630     const AtomString&amp; textEmphasisCustomMark() const { return m_rareInheritedData-&gt;textEmphasisCustomMark; }</span>
 631     OptionSet&lt;TextEmphasisPosition&gt; textEmphasisPosition() const { return OptionSet&lt;TextEmphasisPosition&gt;::fromRaw(m_rareInheritedData-&gt;textEmphasisPosition); }
<span class="line-modified"> 632     const AtomString&amp; textEmphasisMarkString() const;</span>
 633 
 634     RubyPosition rubyPosition() const { return static_cast&lt;RubyPosition&gt;(m_rareInheritedData-&gt;rubyPosition); }
 635 
 636 #if ENABLE(DARK_MODE_CSS)
<span class="line-modified"> 637     StyleColorScheme colorScheme() const { return m_rareInheritedData-&gt;colorScheme; }</span>
<span class="line-modified"> 638     void setHasExplicitlySetColorScheme(bool v) { m_nonInheritedFlags.hasExplicitlySetColorScheme = v; }</span>
<span class="line-modified"> 639     bool hasExplicitlySetColorScheme() const { return m_nonInheritedFlags.hasExplicitlySetColorScheme; };</span>
 640 #endif
 641 
 642     TextOrientation textOrientation() const { return static_cast&lt;TextOrientation&gt;(m_rareInheritedData-&gt;textOrientation); }
 643 
 644     ObjectFit objectFit() const { return static_cast&lt;ObjectFit&gt;(m_rareNonInheritedData-&gt;objectFit); }
 645     LengthPoint objectPosition() const { return m_rareNonInheritedData-&gt;objectPosition; }
 646 
 647     // Return true if any transform related property (currently transform, transformStyle3D or perspective)
 648     // indicates that we are transforming.
 649     bool hasTransformRelatedProperty() const { return hasTransform() || preserves3D() || hasPerspective(); }
 650 
 651     enum ApplyTransformOrigin { IncludeTransformOrigin, ExcludeTransformOrigin };
 652     void applyTransform(TransformationMatrix&amp;, const FloatRect&amp; boundingBox, ApplyTransformOrigin = IncludeTransformOrigin) const;
 653     void setPageScaleTransform(float);
 654 
 655     bool hasMask() const { return m_rareNonInheritedData-&gt;mask.hasImage() || m_rareNonInheritedData-&gt;maskBoxImage.hasImage(); }
 656 
 657     TextCombine textCombine() const { return static_cast&lt;TextCombine&gt;(m_rareNonInheritedData-&gt;textCombine); }
 658     bool hasTextCombine() const { return textCombine() != TextCombine::None; }
 659 
<span class="line-modified"> 660     const TabSize&amp; tabSize() const { return m_rareInheritedData-&gt;tabSize; }</span>
 661 
 662     // End CSS3 Getters
 663 
<span class="line-modified"> 664     const AtomString&amp; lineGrid() const { return m_rareInheritedData-&gt;lineGrid; }</span>
 665     LineSnap lineSnap() const { return static_cast&lt;LineSnap&gt;(m_rareInheritedData-&gt;lineSnap); }
 666     LineAlign lineAlign() const { return static_cast&lt;LineAlign&gt;(m_rareInheritedData-&gt;lineAlign); }
 667 
 668     PointerEvents pointerEvents() const { return static_cast&lt;PointerEvents&gt;(m_inheritedFlags.pointerEvents); }
 669     const AnimationList* animations() const { return m_rareNonInheritedData-&gt;animations.get(); }
 670     const AnimationList* transitions() const { return m_rareNonInheritedData-&gt;transitions.get(); }
 671 
 672     AnimationList* animations() { return m_rareNonInheritedData-&gt;animations.get(); }
 673     AnimationList* transitions() { return m_rareNonInheritedData-&gt;transitions.get(); }
 674 
 675     bool hasAnimationsOrTransitions() const { return hasAnimations() || hasTransitions(); }
 676 
 677     AnimationList&amp; ensureAnimations();
 678     AnimationList&amp; ensureTransitions();
 679 
 680     bool hasAnimations() const { return m_rareNonInheritedData-&gt;animations &amp;&amp; m_rareNonInheritedData-&gt;animations-&gt;size() &gt; 0; }
 681     bool hasTransitions() const { return m_rareNonInheritedData-&gt;transitions &amp;&amp; m_rareNonInheritedData-&gt;transitions-&gt;size() &gt; 0; }
 682 
 683     // Return the first found Animation (including &#39;all&#39; transitions).
 684     const Animation* transitionForProperty(CSSPropertyID) const;
 685 
 686     TransformStyle3D transformStyle3D() const { return static_cast&lt;TransformStyle3D&gt;(m_rareNonInheritedData-&gt;transformStyle3D); }
 687     bool preserves3D() const { return transformStyle3D() == TransformStyle3D::Preserve3D; }
 688 
 689     BackfaceVisibility backfaceVisibility() const { return static_cast&lt;BackfaceVisibility&gt;(m_rareNonInheritedData-&gt;backfaceVisibility); }
 690     float perspective() const { return m_rareNonInheritedData-&gt;perspective; }
 691     bool hasPerspective() const { return m_rareNonInheritedData-&gt;perspective &gt; 0; }
 692     const Length&amp; perspectiveOriginX() const { return m_rareNonInheritedData-&gt;perspectiveOriginX; }
 693     const Length&amp; perspectiveOriginY() const { return m_rareNonInheritedData-&gt;perspectiveOriginY; }
 694     const LengthSize&amp; pageSize() const { return m_rareNonInheritedData-&gt;pageSize; }
 695     PageSizeType pageSizeType() const { return static_cast&lt;PageSizeType&gt;(m_rareNonInheritedData-&gt;pageSizeType); }
 696 
 697     LineBoxContain lineBoxContain() const { return m_rareInheritedData-&gt;lineBoxContain; }
 698     const LineClampValue&amp; lineClamp() const { return m_rareNonInheritedData-&gt;lineClamp; }
 699     const IntSize&amp; initialLetter() const { return m_rareNonInheritedData-&gt;initialLetter; }
 700     int initialLetterDrop() const { return initialLetter().width(); }
 701     int initialLetterHeight() const { return initialLetter().height(); }
 702 
 703 #if ENABLE(POINTER_EVENTS)
 704     OptionSet&lt;TouchAction&gt; touchActions() const { return OptionSet&lt;TouchAction&gt;::fromRaw(m_rareNonInheritedData-&gt;touchActions); }
<span class="line-added"> 705     // &#39;touch-action&#39; behavior depends on values in ancestors. We use an additional inherited property to implement that.</span>
<span class="line-added"> 706     OptionSet&lt;TouchAction&gt; effectiveTouchActions() const { return OptionSet&lt;TouchAction&gt;::fromRaw(m_rareInheritedData-&gt;effectiveTouchActions); }</span>
 707 #endif
 708 
 709 #if ENABLE(CSS_SCROLL_SNAP)
 710     // Scroll snap port style.
 711     const StyleScrollSnapPort&amp; scrollSnapPort() const;
 712     const ScrollSnapType&amp; scrollSnapType() const;
 713     const LengthBox&amp; scrollPadding() const;
 714     const Length&amp; scrollPaddingTop() const;
 715     const Length&amp; scrollPaddingBottom() const;
 716     const Length&amp; scrollPaddingLeft() const;
 717     const Length&amp; scrollPaddingRight() const;
 718 
 719     // Scroll snap area style.
 720     const StyleScrollSnapArea&amp; scrollSnapArea() const;
 721     const ScrollSnapAlign&amp; scrollSnapAlign() const;
 722     const LengthBox&amp; scrollSnapMargin() const;
 723     const Length&amp; scrollSnapMarginTop() const;
 724     const Length&amp; scrollSnapMarginBottom() const;
 725     const Length&amp; scrollSnapMarginLeft() const;
 726     const Length&amp; scrollSnapMarginRight() const;
 727 #endif
 728 
 729 #if ENABLE(TOUCH_EVENTS)
 730     Color tapHighlightColor() const { return m_rareInheritedData-&gt;tapHighlightColor; }
 731 #endif
 732 
 733 #if PLATFORM(IOS_FAMILY)
 734     bool touchCalloutEnabled() const { return m_rareInheritedData-&gt;touchCalloutEnabled; }
 735 #endif
 736 
<span class="line-modified"> 737 #if ENABLE(OVERFLOW_SCROLLING_TOUCH)</span>
 738     bool useTouchOverflowScrolling() const { return m_rareInheritedData-&gt;useTouchOverflowScrolling; }
 739 #endif
 740 
 741 #if ENABLE(TEXT_AUTOSIZING)
 742     TextSizeAdjustment textSizeAdjust() const { return m_rareInheritedData-&gt;textSizeAdjust; }
<span class="line-added"> 743     AutosizeStatus autosizeStatus() const;</span>
<span class="line-added"> 744     bool isIdempotentTextAutosizingCandidate() const;</span>
 745 #endif
 746 
 747     TextSecurity textSecurity() const { return static_cast&lt;TextSecurity&gt;(m_rareInheritedData-&gt;textSecurity); }
 748 
 749     WritingMode writingMode() const { return static_cast&lt;WritingMode&gt;(m_inheritedFlags.writingMode); }
 750     bool isHorizontalWritingMode() const { return WebCore::isHorizontalWritingMode(writingMode()); }
 751     bool isVerticalWritingMode() const { return WebCore::isVerticalWritingMode(writingMode()); }
 752     bool isFlippedLinesWritingMode() const { return WebCore::isFlippedLinesWritingMode(writingMode()); }
 753     bool isFlippedBlocksWritingMode() const { return WebCore::isFlippedWritingMode(writingMode()); }
 754 
<span class="line-modified"> 755     ImageOrientation imageOrientation() const;</span>
 756 
 757     ImageRendering imageRendering() const { return static_cast&lt;ImageRendering&gt;(m_rareInheritedData-&gt;imageRendering); }
 758 
 759 #if ENABLE(CSS_IMAGE_RESOLUTION)
 760     ImageResolutionSource imageResolutionSource() const { return static_cast&lt;ImageResolutionSource&gt;(m_rareInheritedData-&gt;imageResolutionSource); }
 761     ImageResolutionSnap imageResolutionSnap() const { return static_cast&lt;ImageResolutionSnap&gt;(m_rareInheritedData-&gt;imageResolutionSnap); }
 762     float imageResolution() const { return m_rareInheritedData-&gt;imageResolution; }
 763 #endif
 764 
 765     OptionSet&lt;SpeakAs&gt; speakAs() const { return OptionSet&lt;SpeakAs&gt;::fromRaw(m_rareInheritedData-&gt;speakAs); }
 766 
 767     FilterOperations&amp; mutableFilter() { return m_rareNonInheritedData.access().filter.access().operations; }
 768     const FilterOperations&amp; filter() const { return m_rareNonInheritedData-&gt;filter-&gt;operations; }
 769     bool hasFilter() const { return !m_rareNonInheritedData-&gt;filter-&gt;operations.operations().isEmpty(); }
 770     bool hasReferenceFilterOnly() const;
 771 
 772     FilterOperations&amp; mutableAppleColorFilter() { return m_rareInheritedData.access().appleColorFilter.access().operations; }
 773     const FilterOperations&amp; appleColorFilter() const { return m_rareInheritedData-&gt;appleColorFilter-&gt;operations; }
 774     bool hasAppleColorFilter() const { return !m_rareInheritedData-&gt;appleColorFilter-&gt;operations.operations().isEmpty(); }
 775 
</pre>
<hr />
<pre>
 814     void setOriginalDisplay(DisplayType v) { m_nonInheritedFlags.originalDisplay = static_cast&lt;unsigned&gt;(v); }
 815     void setPosition(PositionType v) { m_nonInheritedFlags.position = static_cast&lt;unsigned&gt;(v); }
 816     void setFloating(Float v) { m_nonInheritedFlags.floating = static_cast&lt;unsigned&gt;(v); }
 817 
 818     void setLeft(Length&amp;&amp; length) { SET_VAR(m_surroundData, offset.left(), WTFMove(length)); }
 819     void setRight(Length&amp;&amp; length) { SET_VAR(m_surroundData, offset.right(), WTFMove(length)); }
 820     void setTop(Length&amp;&amp; length) { SET_VAR(m_surroundData, offset.top(), WTFMove(length)); }
 821     void setBottom(Length&amp;&amp; length) { SET_VAR(m_surroundData, offset.bottom(), WTFMove(length)); }
 822 
 823     void setWidth(Length&amp;&amp; length) { SET_VAR(m_boxData, m_width, WTFMove(length)); }
 824     void setHeight(Length&amp;&amp; length) { SET_VAR(m_boxData, m_height, WTFMove(length)); }
 825 
 826     void setLogicalWidth(Length&amp;&amp;);
 827     void setLogicalHeight(Length&amp;&amp;);
 828 
 829     void setMinWidth(Length&amp;&amp; length) { SET_VAR(m_boxData, m_minWidth, WTFMove(length)); }
 830     void setMaxWidth(Length&amp;&amp; length) { SET_VAR(m_boxData, m_maxWidth, WTFMove(length)); }
 831     void setMinHeight(Length&amp;&amp; length) { SET_VAR(m_boxData, m_minHeight, WTFMove(length)); }
 832     void setMaxHeight(Length&amp;&amp; length) { SET_VAR(m_boxData, m_maxHeight, WTFMove(length)); }
 833 






 834     void resetBorder() { resetBorderImage(); resetBorderTop(); resetBorderRight(); resetBorderBottom(); resetBorderLeft(); resetBorderRadius(); }
 835     void resetBorderTop() { SET_VAR(m_surroundData, border.m_top, BorderValue()); }
 836     void resetBorderRight() { SET_VAR(m_surroundData, border.m_right, BorderValue()); }
 837     void resetBorderBottom() { SET_VAR(m_surroundData, border.m_bottom, BorderValue()); }
 838     void resetBorderLeft() { SET_VAR(m_surroundData, border.m_left, BorderValue()); }
 839     void resetBorderImage() { SET_VAR(m_surroundData, border.m_image, NinePieceImage()); }
 840     void resetBorderRadius() { resetBorderTopLeftRadius(); resetBorderTopRightRadius(); resetBorderBottomLeftRadius(); resetBorderBottomRightRadius(); }
 841     void resetBorderTopLeftRadius() { SET_VAR(m_surroundData, border.m_topLeft, initialBorderRadius()); }
 842     void resetBorderTopRightRadius() { SET_VAR(m_surroundData, border.m_topRight, initialBorderRadius()); }
 843     void resetBorderBottomLeftRadius() { SET_VAR(m_surroundData, border.m_bottomLeft, initialBorderRadius()); }
 844     void resetBorderBottomRightRadius() { SET_VAR(m_surroundData, border.m_bottomRight, initialBorderRadius()); }
 845 
 846     void setBackgroundColor(const Color&amp; v) { SET_VAR(m_backgroundData, color, v); }
 847 
 848     void setBackgroundXPosition(Length&amp;&amp; length) { SET_VAR(m_backgroundData, background.m_xPosition, WTFMove(length)); }
 849     void setBackgroundYPosition(Length&amp;&amp; length) { SET_VAR(m_backgroundData, background.m_yPosition, WTFMove(length)); }
 850     void setBackgroundSize(FillSizeType b) { SET_VAR(m_backgroundData, background.m_sizeType, static_cast&lt;unsigned&gt;(b)); }
 851     void setBackgroundSizeLength(LengthSize&amp;&amp; size) { SET_VAR(m_backgroundData, background.m_sizeLength, WTFMove(size)); }
 852 
 853     void setBorderImage(const NinePieceImage&amp; b) { SET_VAR(m_surroundData, border.m_image, b); }
</pre>
<hr />
<pre>
 934     void setDirection(TextDirection v) { m_inheritedFlags.direction = static_cast&lt;unsigned&gt;(v); }
 935     void setHasExplicitlySetDirection(bool v) { m_nonInheritedFlags.hasExplicitlySetDirection = v; }
 936     void setLineHeight(Length&amp;&amp;);
 937     bool setZoom(float);
 938     void setZoomWithoutReturnValue(float f) { setZoom(f); }
 939     bool setEffectiveZoom(float);
 940     void setTextZoom(TextZoom v) { SET_VAR(m_rareInheritedData, textZoom, static_cast&lt;unsigned&gt;(v)); }
 941 
 942 #if ENABLE(CSS3_TEXT)
 943     void setTextIndentLine(TextIndentLine v) { SET_VAR(m_rareInheritedData, textIndentLine, v); }
 944     void setTextIndentType(TextIndentType v) { SET_VAR(m_rareInheritedData, textIndentType, v); }
 945     void setTextAlignLast(TextAlignLast v) { SET_VAR(m_rareInheritedData, textAlignLast, v); }
 946     void setTextJustify(TextJustify v) { SET_VAR(m_rareInheritedData, textJustify, v); }
 947 #endif
 948 
 949 #if ENABLE(TEXT_AUTOSIZING)
 950     void setSpecifiedLineHeight(Length&amp;&amp;);
 951 #endif
 952 
 953 #if ENABLE(CSS_IMAGE_ORIENTATION)
<span class="line-modified"> 954     void setImageOrientation(ImageOrientation v) { SET_VAR(m_rareInheritedData, imageOrientation, static_cast&lt;int&gt;(v)); }</span>
 955 #endif
 956 
 957     void setImageRendering(ImageRendering v) { SET_VAR(m_rareInheritedData, imageRendering, static_cast&lt;unsigned&gt;(v)); }
 958 
 959 #if ENABLE(CSS_IMAGE_RESOLUTION)
 960     void setImageResolutionSource(ImageResolutionSource v) { SET_VAR(m_rareInheritedData, imageResolutionSource, v); }
 961     void setImageResolutionSnap(ImageResolutionSnap v) { SET_VAR(m_rareInheritedData, imageResolutionSnap, v); }
 962     void setImageResolution(float f) { SET_VAR(m_rareInheritedData, imageResolution, f); }
 963 #endif
 964 
 965     void setWhiteSpace(WhiteSpace v) { m_inheritedFlags.whiteSpace = static_cast&lt;unsigned&gt;(v); }
 966 
 967     void setWordSpacing(Length&amp;&amp;);
 968     void setLetterSpacing(float);
 969 
 970     void clearBackgroundLayers() { m_backgroundData.access().background = FillLayer(FillLayerType::Background); }
 971     void inheritBackgroundLayers(const FillLayer&amp; parent) { m_backgroundData.access().background = parent; }
 972 
 973     void adjustBackgroundLayers();
 974 
</pre>
<hr />
<pre>
1113 
1114     void setMarqueeIncrement(Length&amp;&amp; length) { SET_NESTED_VAR(m_rareNonInheritedData, marquee, increment, WTFMove(length)); }
1115     void setMarqueeSpeed(int f) { SET_NESTED_VAR(m_rareNonInheritedData, marquee, speed, f); }
1116     void setMarqueeDirection(MarqueeDirection d) { SET_NESTED_VAR(m_rareNonInheritedData, marquee, direction, static_cast&lt;unsigned&gt;(d)); }
1117     void setMarqueeBehavior(MarqueeBehavior b) { SET_NESTED_VAR(m_rareNonInheritedData, marquee, behavior, static_cast&lt;unsigned&gt;(b)); }
1118     void setMarqueeLoopCount(int i) { SET_NESTED_VAR(m_rareNonInheritedData, marquee, loops, i); }
1119     void setUserModify(UserModify u) { SET_VAR(m_rareInheritedData, userModify, static_cast&lt;unsigned&gt;(u)); }
1120     void setUserDrag(UserDrag d) { SET_VAR(m_rareNonInheritedData, userDrag, static_cast&lt;unsigned&gt;(d)); }
1121     void setUserSelect(UserSelect s) { SET_VAR(m_rareInheritedData, userSelect, static_cast&lt;unsigned&gt;(s)); }
1122     void setTextOverflow(TextOverflow overflow) { SET_VAR(m_rareNonInheritedData, textOverflow, static_cast&lt;unsigned&gt;(overflow)); }
1123     void setMarginBeforeCollapse(MarginCollapse c) { SET_VAR(m_rareNonInheritedData, marginBeforeCollapse, static_cast&lt;unsigned&gt;(c)); }
1124     void setMarginAfterCollapse(MarginCollapse c) { SET_VAR(m_rareNonInheritedData, marginAfterCollapse, static_cast&lt;unsigned&gt;(c)); }
1125     void setWordBreak(WordBreak b) { SET_VAR(m_rareInheritedData, wordBreak, static_cast&lt;unsigned&gt;(b)); }
1126     void setOverflowWrap(OverflowWrap b) { SET_VAR(m_rareInheritedData, overflowWrap, static_cast&lt;unsigned&gt;(b)); }
1127     void setNBSPMode(NBSPMode b) { SET_VAR(m_rareInheritedData, nbspMode, static_cast&lt;unsigned&gt;(b)); }
1128     void setLineBreak(LineBreak b) { SET_VAR(m_rareInheritedData, lineBreak, static_cast&lt;unsigned&gt;(b)); }
1129     void setHyphens(Hyphens h) { SET_VAR(m_rareInheritedData, hyphens, static_cast&lt;unsigned&gt;(h)); }
1130     void setHyphenationLimitBefore(short limit) { SET_VAR(m_rareInheritedData, hyphenationLimitBefore, limit); }
1131     void setHyphenationLimitAfter(short limit) { SET_VAR(m_rareInheritedData, hyphenationLimitAfter, limit); }
1132     void setHyphenationLimitLines(short limit) { SET_VAR(m_rareInheritedData, hyphenationLimitLines, limit); }
<span class="line-modified">1133     void setHyphenationString(const AtomString&amp; h) { SET_VAR(m_rareInheritedData, hyphenationString, h); }</span>
1134     void setBorderFit(BorderFit b) { SET_VAR(m_rareNonInheritedData, borderFit, static_cast&lt;unsigned&gt;(b)); }
1135     void setResize(Resize r) { SET_VAR(m_rareNonInheritedData, resize, static_cast&lt;unsigned&gt;(r)); }
1136     void setColumnAxis(ColumnAxis axis) { SET_NESTED_VAR(m_rareNonInheritedData, multiCol, axis, static_cast&lt;unsigned&gt;(axis)); }
1137     void setColumnProgression(ColumnProgression progression) { SET_NESTED_VAR(m_rareNonInheritedData, multiCol, progression, static_cast&lt;unsigned&gt;(progression)); }
1138     void setColumnWidth(float f) { SET_NESTED_VAR(m_rareNonInheritedData, multiCol, autoWidth, false); SET_NESTED_VAR(m_rareNonInheritedData, multiCol, width, f); }
1139     void setHasAutoColumnWidth() { SET_NESTED_VAR(m_rareNonInheritedData, multiCol, autoWidth, true); SET_NESTED_VAR(m_rareNonInheritedData, multiCol, width, 0); }
1140     void setColumnCount(unsigned short c) { SET_NESTED_VAR(m_rareNonInheritedData, multiCol, autoCount, false); SET_NESTED_VAR(m_rareNonInheritedData, multiCol, count, c); }
1141     void setHasAutoColumnCount() { SET_NESTED_VAR(m_rareNonInheritedData, multiCol, autoCount, true); SET_NESTED_VAR(m_rareNonInheritedData, multiCol, count, 0); }
1142     void setColumnFill(ColumnFill columnFill) { SET_NESTED_VAR(m_rareNonInheritedData, multiCol, fill, static_cast&lt;unsigned&gt;(columnFill)); }
1143     void setColumnGap(GapLength&amp;&amp; gapLength) { SET_VAR(m_rareNonInheritedData, columnGap, WTFMove(gapLength)); }
1144     void setRowGap(GapLength&amp;&amp; gapLength) { SET_VAR(m_rareNonInheritedData, rowGap, WTFMove(gapLength)); }
1145     void setColumnRuleColor(const Color&amp; c) { SET_BORDERVALUE_COLOR(m_rareNonInheritedData.access().multiCol, rule, c); }
1146     void setColumnRuleStyle(BorderStyle b) { SET_NESTED_VAR(m_rareNonInheritedData, multiCol, rule.m_style, static_cast&lt;unsigned&gt;(b)); }
1147     void setColumnRuleWidth(unsigned short w) { SET_NESTED_VAR(m_rareNonInheritedData, multiCol, rule.m_width, w); }
1148     void resetColumnRule() { SET_NESTED_VAR(m_rareNonInheritedData, multiCol, rule, BorderValue()); }
1149     void setColumnSpan(ColumnSpan columnSpan) { SET_NESTED_VAR(m_rareNonInheritedData, multiCol, columnSpan, static_cast&lt;unsigned&gt;(columnSpan)); }
1150     void inheritColumnPropertiesFrom(const RenderStyle&amp; parent) { m_rareNonInheritedData.access().multiCol = parent.m_rareNonInheritedData-&gt;multiCol; }
1151 
1152     void setTransform(const TransformOperations&amp; ops) { SET_NESTED_VAR(m_rareNonInheritedData, transform, operations, ops); }
1153     void setTransformOriginX(Length&amp;&amp; length) { SET_NESTED_VAR(m_rareNonInheritedData, transform, x, WTFMove(length)); }
1154     void setTransformOriginY(Length&amp;&amp; length) { SET_NESTED_VAR(m_rareNonInheritedData, transform, y, WTFMove(length)); }
1155     void setTransformOriginZ(float f) { SET_NESTED_VAR(m_rareNonInheritedData, transform, z, f); }
1156     void setTransformBox(TransformBox box) { SET_NESTED_VAR(m_rareNonInheritedData, transform, transformBox, box); }
1157 
1158     void setSpeakAs(OptionSet&lt;SpeakAs&gt; s) { SET_VAR(m_rareInheritedData, speakAs, s.toRaw()); }
1159     void setTextCombine(TextCombine v) { SET_VAR(m_rareNonInheritedData, textCombine, static_cast&lt;unsigned&gt;(v)); }
1160     void setTextDecorationColor(const Color&amp; c) { SET_VAR(m_rareNonInheritedData, textDecorationColor, c); }
1161     void setTextEmphasisColor(const Color&amp; c) { SET_VAR(m_rareInheritedData, textEmphasisColor, c); }
1162     void setTextEmphasisFill(TextEmphasisFill fill) { SET_VAR(m_rareInheritedData, textEmphasisFill, static_cast&lt;unsigned&gt;(fill)); }
1163     void setTextEmphasisMark(TextEmphasisMark mark) { SET_VAR(m_rareInheritedData, textEmphasisMark, static_cast&lt;unsigned&gt;(mark)); }
<span class="line-modified">1164     void setTextEmphasisCustomMark(const AtomString&amp; mark) { SET_VAR(m_rareInheritedData, textEmphasisCustomMark, mark); }</span>
1165     void setTextEmphasisPosition(OptionSet&lt;TextEmphasisPosition&gt; position) { SET_VAR(m_rareInheritedData, textEmphasisPosition, static_cast&lt;unsigned&gt;(position.toRaw())); }
1166     bool setTextOrientation(TextOrientation);
1167 
1168     void setObjectFit(ObjectFit fit) { SET_VAR(m_rareNonInheritedData, objectFit, static_cast&lt;unsigned&gt;(fit)); }
1169     void setObjectPosition(LengthPoint&amp;&amp; position) { SET_VAR(m_rareNonInheritedData, objectPosition, WTFMove(position)); }
1170 
1171     void setRubyPosition(RubyPosition position) { SET_VAR(m_rareInheritedData, rubyPosition, static_cast&lt;unsigned&gt;(position)); }
1172 
1173 #if ENABLE(DARK_MODE_CSS)
<span class="line-modified">1174     void setColorScheme(StyleColorScheme supported) { SET_VAR(m_rareInheritedData, colorScheme, supported); }</span>
1175 #endif
1176 
1177     void setFilter(const FilterOperations&amp; ops) { SET_NESTED_VAR(m_rareNonInheritedData, filter, operations, ops); }
1178     void setAppleColorFilter(const FilterOperations&amp; ops) { SET_NESTED_VAR(m_rareInheritedData, appleColorFilter, operations, ops); }
1179 
1180 #if ENABLE(FILTERS_LEVEL_2)
1181     void setBackdropFilter(const FilterOperations&amp; ops) { SET_NESTED_VAR(m_rareNonInheritedData, backdropFilter, operations, ops); }
1182 #endif
1183 
<span class="line-modified">1184     void setTabSize(const TabSize&amp; size) { SET_VAR(m_rareInheritedData, tabSize, size); }</span>
1185 
1186     void setBreakBefore(BreakBetween breakBehavior) { SET_VAR(m_rareNonInheritedData, breakBefore, static_cast&lt;unsigned&gt;(breakBehavior)); }
1187     void setBreakAfter(BreakBetween breakBehavior) { SET_VAR(m_rareNonInheritedData, breakAfter, static_cast&lt;unsigned&gt;(breakBehavior)); }
1188     void setBreakInside(BreakInside breakBehavior) { SET_VAR(m_rareNonInheritedData, breakInside, static_cast&lt;unsigned&gt;(breakBehavior)); }
1189 
1190     void setHangingPunctuation(OptionSet&lt;HangingPunctuation&gt; punctuation) { SET_VAR(m_rareInheritedData, hangingPunctuation, punctuation.toRaw()); }
1191 
1192     // End CSS3 Setters
1193 
<span class="line-modified">1194     void setLineGrid(const AtomString&amp; lineGrid) { SET_VAR(m_rareInheritedData, lineGrid, lineGrid); }</span>
1195     void setLineSnap(LineSnap lineSnap) { SET_VAR(m_rareInheritedData, lineSnap, static_cast&lt;unsigned&gt;(lineSnap)); }
1196     void setLineAlign(LineAlign lineAlign) { SET_VAR(m_rareInheritedData, lineAlign, static_cast&lt;unsigned&gt;(lineAlign)); }
1197 
1198     void setPointerEvents(PointerEvents p) { m_inheritedFlags.pointerEvents = static_cast&lt;unsigned&gt;(p); }
1199 
1200     void clearAnimations();
1201     void clearTransitions();
1202 
1203     void adjustAnimations();
1204     void adjustTransitions();
1205 
1206     void setTransformStyle3D(TransformStyle3D b) { SET_VAR(m_rareNonInheritedData, transformStyle3D, static_cast&lt;unsigned&gt;(b)); }
1207     void setBackfaceVisibility(BackfaceVisibility b) { SET_VAR(m_rareNonInheritedData, backfaceVisibility, static_cast&lt;unsigned&gt;(b)); }
1208     void setPerspective(float p) { SET_VAR(m_rareNonInheritedData, perspective, p); }
1209     void setPerspectiveOriginX(Length&amp;&amp; length) { SET_VAR(m_rareNonInheritedData, perspectiveOriginX, WTFMove(length)); }
1210     void setPerspectiveOriginY(Length&amp;&amp; length) { SET_VAR(m_rareNonInheritedData, perspectiveOriginY, WTFMove(length)); }
1211     void setPageSize(LengthSize size) { SET_VAR(m_rareNonInheritedData, pageSize, WTFMove(size)); }
1212     void setPageSizeType(PageSizeType t) { SET_VAR(m_rareNonInheritedData, pageSizeType, t); }
1213     void resetPageSizeType() { SET_VAR(m_rareNonInheritedData, pageSizeType, PAGE_SIZE_AUTO); }
1214 
1215     void setLineBoxContain(LineBoxContain c) { SET_VAR(m_rareInheritedData, lineBoxContain, c); }
1216     void setLineClamp(LineClampValue c) { SET_VAR(m_rareNonInheritedData, lineClamp, c); }
1217 
1218     void setInitialLetter(const IntSize&amp; size) { SET_VAR(m_rareNonInheritedData, initialLetter, size); }
1219 
1220 #if ENABLE(POINTER_EVENTS)
1221     void setTouchActions(OptionSet&lt;TouchAction&gt; touchActions) { SET_VAR(m_rareNonInheritedData, touchActions, touchActions.toRaw()); }
<span class="line-added">1222     void setEffectiveTouchActions(OptionSet&lt;TouchAction&gt; touchActions) { SET_VAR(m_rareInheritedData, effectiveTouchActions, touchActions.toRaw()); }</span>
1223 #endif
1224 
1225 #if ENABLE(CSS_SCROLL_SNAP)
1226     void setScrollSnapType(const ScrollSnapType&amp;);
1227     void setScrollPaddingTop(Length&amp;&amp;);
1228     void setScrollPaddingBottom(Length&amp;&amp;);
1229     void setScrollPaddingLeft(Length&amp;&amp;);
1230     void setScrollPaddingRight(Length&amp;&amp;);
1231 
1232     void setScrollSnapAlign(const ScrollSnapAlign&amp;);
1233     void setScrollSnapMarginTop(Length&amp;&amp;);
1234     void setScrollSnapMarginBottom(Length&amp;&amp;);
1235     void setScrollSnapMarginLeft(Length&amp;&amp;);
1236     void setScrollSnapMarginRight(Length&amp;&amp;);
1237 #endif
1238 
1239 #if ENABLE(TOUCH_EVENTS)
1240     void setTapHighlightColor(const Color&amp; c) { SET_VAR(m_rareInheritedData, tapHighlightColor, c); }
1241 #endif
1242 
1243 #if PLATFORM(IOS_FAMILY)
1244     void setTouchCalloutEnabled(bool v) { SET_VAR(m_rareInheritedData, touchCalloutEnabled, v); }
1245 #endif
1246 
<span class="line-modified">1247 #if ENABLE(OVERFLOW_SCROLLING_TOUCH)</span>
1248     void setUseTouchOverflowScrolling(bool v) { SET_VAR(m_rareInheritedData, useTouchOverflowScrolling, v); }
1249 #endif
1250 
1251 #if ENABLE(TEXT_AUTOSIZING)
1252     void setTextSizeAdjust(TextSizeAdjustment adjustment) { SET_VAR(m_rareInheritedData, textSizeAdjust, adjustment); }
<span class="line-added">1253     void setAutosizeStatus(AutosizeStatus);</span>
1254 #endif
1255 
1256     void setTextSecurity(TextSecurity security) { SET_VAR(m_rareInheritedData, textSecurity, static_cast&lt;unsigned&gt;(security)); }
1257 
1258 #if ENABLE(CSS_TRAILING_WORD)
1259     void setTrailingWord(TrailingWord) { }
1260 #endif
1261 
1262 #if ENABLE(APPLE_PAY)
1263     void setApplePayButtonStyle(ApplePayButtonStyle style) { SET_VAR(m_rareNonInheritedData, applePayButtonStyle, static_cast&lt;unsigned&gt;(style)); }
1264     void setApplePayButtonType(ApplePayButtonType type) { SET_VAR(m_rareNonInheritedData, applePayButtonType, static_cast&lt;unsigned&gt;(type)); }
1265 #endif
1266 
1267 #if ENABLE(CSS_PAINTING_API)
1268     void addCustomPaintWatchProperty(const String&amp; name);
1269 #endif
1270 
1271     // Support for paint-order, stroke-linecap, stroke-linejoin, and stroke-miterlimit from https://drafts.fxtf.org/paint/.
1272     void setPaintOrder(PaintOrder order) { SET_VAR(m_rareInheritedData, paintOrder, static_cast&lt;unsigned&gt;(order)); }
1273     PaintOrder paintOrder() const { return static_cast&lt;PaintOrder&gt;(m_rareInheritedData-&gt;paintOrder); }
</pre>
<hr />
<pre>
1378     void setContent(const String&amp;, bool add = false);
1379     void setContent(RefPtr&lt;StyleImage&gt;&amp;&amp;, bool add = false);
1380     void setContent(std::unique_ptr&lt;CounterContent&gt;, bool add = false);
1381     void setContent(QuoteType, bool add = false);
1382     void setContentAltText(const String&amp;);
1383     const String&amp; contentAltText() const;
1384     bool hasAttrContent() const { return m_rareNonInheritedData-&gt;hasAttrContent; }
1385     void setHasAttrContent();
1386 
1387     const CounterDirectiveMap* counterDirectives() const;
1388     CounterDirectiveMap&amp; accessCounterDirectives();
1389 
1390     QuotesData* quotes() const { return m_rareInheritedData-&gt;quotes.get(); }
1391     void setQuotes(RefPtr&lt;QuotesData&gt;&amp;&amp;);
1392 
1393     WillChangeData* willChange() const { return m_rareNonInheritedData-&gt;willChange.get(); }
1394     void setWillChange(RefPtr&lt;WillChangeData&gt;&amp;&amp;);
1395 
1396     bool willChangeCreatesStackingContext() const;
1397 
<span class="line-modified">1398     const AtomString&amp; hyphenString() const;</span>
1399 
1400     bool inheritedNotEqual(const RenderStyle*) const;
1401     bool inheritedDataShared(const RenderStyle*) const;
1402 
1403 #if ENABLE(TEXT_AUTOSIZING)
1404     uint32_t hashForTextAutosizing() const;
1405     bool equalForTextAutosizing(const RenderStyle&amp;) const;
1406 #endif
1407 
1408     StyleDifference diff(const RenderStyle&amp;, OptionSet&lt;StyleDifferenceContextSensitiveProperty&gt;&amp; changedContextSensitiveProperties) const;
1409     bool diffRequiresLayerRepaint(const RenderStyle&amp;, bool isComposited) const;
1410 
1411     bool isDisplayInlineType() const { return isDisplayInlineType(display()); }
1412     bool isOriginalDisplayInlineType() const { return isDisplayInlineType(originalDisplay()); }
1413     bool isDisplayFlexibleOrGridBox() const { return isDisplayFlexibleOrGridBox(display()); }
1414     bool isDisplayRegionType() const;
1415 
1416     bool setWritingMode(WritingMode);
1417 
1418     bool hasExplicitlySetWritingMode() const { return m_nonInheritedFlags.hasExplicitlySetWritingMode; }
</pre>
<hr />
<pre>
1532     static int initialMarqueeLoopCount() { return -1; }
1533     static int initialMarqueeSpeed() { return 85; }
1534     static Length initialMarqueeIncrement() { return Length(6, Fixed); }
1535     static MarqueeBehavior initialMarqueeBehavior() { return MarqueeBehavior::Scroll; }
1536     static MarqueeDirection initialMarqueeDirection() { return MarqueeDirection::Auto; }
1537     static UserModify initialUserModify() { return UserModify::ReadOnly; }
1538     static UserDrag initialUserDrag() { return UserDrag::Auto; }
1539     static UserSelect initialUserSelect() { return UserSelect::Text; }
1540     static TextOverflow initialTextOverflow() { return TextOverflow::Clip; }
1541     static MarginCollapse initialMarginBeforeCollapse() { return MarginCollapse::Collapse; }
1542     static MarginCollapse initialMarginAfterCollapse() { return MarginCollapse::Collapse; }
1543     static WordBreak initialWordBreak() { return WordBreak::Normal; }
1544     static OverflowWrap initialOverflowWrap() { return OverflowWrap::Normal; }
1545     static NBSPMode initialNBSPMode() { return NBSPMode::Normal; }
1546     static LineBreak initialLineBreak() { return LineBreak::Auto; }
1547     static OptionSet&lt;SpeakAs&gt; initialSpeakAs() { return OptionSet&lt;SpeakAs&gt; { }; }
1548     static Hyphens initialHyphens() { return Hyphens::Manual; }
1549     static short initialHyphenationLimitBefore() { return -1; }
1550     static short initialHyphenationLimitAfter() { return -1; }
1551     static short initialHyphenationLimitLines() { return -1; }
<span class="line-modified">1552     static const AtomString&amp; initialHyphenationString() { return nullAtom(); }</span>
1553     static BorderFit initialBorderFit() { return BorderFit::Border; }
1554     static Resize initialResize() { return Resize::None; }
1555     static ControlPart initialAppearance() { return NoControlPart; }
1556     static AspectRatioType initialAspectRatioType() { return AspectRatioType::Auto; }
1557     static float initialAspectRatioDenominator() { return 1; }
1558     static float initialAspectRatioNumerator() { return 1; }
1559     static Order initialRTLOrdering() { return Order::Logical; }
1560     static float initialTextStrokeWidth() { return 0; }
1561     static unsigned short initialColumnCount() { return 1; }
1562     static ColumnFill initialColumnFill() { return ColumnFill::Balance; }
1563     static ColumnSpan initialColumnSpan() { return ColumnSpan::None; }
1564     static GapLength initialColumnGap() { return GapLength(); }
1565     static GapLength initialRowGap() { return GapLength(); }
1566     static const TransformOperations&amp; initialTransform() { static NeverDestroyed&lt;TransformOperations&gt; ops; return ops; }
1567     static Length initialTransformOriginX() { return Length(50.0f, Percent); }
1568     static Length initialTransformOriginY() { return Length(50.0f, Percent); }
1569     static TransformBox initialTransformBox() { return TransformBox::BorderBox; }
1570     static PointerEvents initialPointerEvents() { return PointerEvents::Auto; }
1571     static float initialTransformOriginZ() { return 0; }
1572     static TransformStyle3D initialTransformStyle3D() { return TransformStyle3D::Flat; }
1573     static BackfaceVisibility initialBackfaceVisibility() { return BackfaceVisibility::Visible; }
1574     static float initialPerspective() { return 0; }
1575     static Length initialPerspectiveOriginX() { return Length(50.0f, Percent); }
1576     static Length initialPerspectiveOriginY() { return Length(50.0f, Percent); }
1577     static Color initialBackgroundColor() { return Color::transparent; }
1578     static Color initialTextEmphasisColor() { return Color(); }
1579     static TextEmphasisFill initialTextEmphasisFill() { return TextEmphasisFill::Filled; }
1580     static TextEmphasisMark initialTextEmphasisMark() { return TextEmphasisMark::None; }
<span class="line-modified">1581     static const AtomString&amp; initialTextEmphasisCustomMark() { return nullAtom(); }</span>
1582     static OptionSet&lt;TextEmphasisPosition&gt; initialTextEmphasisPosition() { return { TextEmphasisPosition::Over, TextEmphasisPosition::Right }; }
1583     static RubyPosition initialRubyPosition() { return RubyPosition::Before; }
1584     static LineBoxContain initialLineBoxContain() { return LineBoxContainBlock | LineBoxContainInline | LineBoxContainReplaced; }
<span class="line-modified">1585     static ImageOrientation initialImageOrientation() { return ImageOrientation::None; }</span>
1586     static ImageRendering initialImageRendering() { return ImageRendering::Auto; }
1587     static ImageResolutionSource initialImageResolutionSource() { return ImageResolutionSource::Specified; }
1588     static ImageResolutionSnap initialImageResolutionSnap() { return ImageResolutionSnap::None; }
1589     static float initialImageResolution() { return 1; }
1590     static StyleImage* initialBorderImageSource() { return nullptr; }
1591     static StyleImage* initialMaskBoxImageSource() { return nullptr; }
1592     static PrintColorAdjust initialPrintColorAdjust() { return PrintColorAdjust::Economy; }
1593     static QuotesData* initialQuotes() { return nullptr; }
<span class="line-modified">1594     static const AtomString&amp; initialContentAltText() { return emptyAtom(); }</span>
1595 
1596 #if ENABLE(DARK_MODE_CSS)
<span class="line-modified">1597     static StyleColorScheme initialColorScheme() { return { }; }</span>
1598 #endif
1599 
1600 #if ENABLE(CSS3_TEXT)
1601     static TextIndentLine initialTextIndentLine() { return TextIndentLine::FirstLine; }
1602     static TextIndentType initialTextIndentType() { return TextIndentType::Normal; }
1603     static TextAlignLast initialTextAlignLast() { return TextAlignLast::Auto; }
1604     static TextJustify initialTextJustify() { return TextJustify::Auto; }
1605 #endif
1606 
1607 #if ENABLE(CURSOR_VISIBILITY)
1608     static CursorVisibility initialCursorVisibility() { return CursorVisibility::Auto; }
1609 #endif
1610 
1611 #if ENABLE(TEXT_AUTOSIZING)
1612     static Length initialSpecifiedLineHeight() { return Length(-100.0f, Percent); }
1613     static TextSizeAdjustment initialTextSizeAdjust() { return TextSizeAdjustment(); }
1614 #endif
1615 
1616     static WillChangeData* initialWillChange() { return nullptr; }
1617 
</pre>
<hr />
<pre>
1646     static GridAutoFlow initialGridAutoFlow() { return AutoFlowRow; }
1647 
1648     static Vector&lt;GridTrackSize&gt; initialGridAutoColumns() { return { GridTrackSize(Length(Auto)) }; }
1649     static Vector&lt;GridTrackSize&gt; initialGridAutoRows() { return { GridTrackSize(Length(Auto)) }; }
1650 
1651     static NamedGridAreaMap initialNamedGridArea() { return NamedGridAreaMap(); }
1652     static size_t initialNamedGridAreaCount() { return 0; }
1653 
1654     static NamedGridLinesMap initialNamedGridColumnLines() { return NamedGridLinesMap(); }
1655     static NamedGridLinesMap initialNamedGridRowLines() { return NamedGridLinesMap(); }
1656 
1657     static OrderedNamedGridLinesMap initialOrderedNamedGridColumnLines() { return OrderedNamedGridLinesMap(); }
1658     static OrderedNamedGridLinesMap initialOrderedNamedGridRowLines() { return OrderedNamedGridLinesMap(); }
1659 
1660     // &#39;auto&#39; is the default.
1661     static GridPosition initialGridItemColumnStart() { return GridPosition(); }
1662     static GridPosition initialGridItemColumnEnd() { return GridPosition(); }
1663     static GridPosition initialGridItemRowStart() { return GridPosition(); }
1664     static GridPosition initialGridItemRowEnd() { return GridPosition(); }
1665 
<span class="line-modified">1666     static TabSize initialTabSize() { return 8; }</span>
1667 
<span class="line-modified">1668     static const AtomString&amp; initialLineGrid() { return nullAtom(); }</span>
1669     static LineSnap initialLineSnap() { return LineSnap::None; }
1670     static LineAlign initialLineAlign() { return LineAlign::None; }
1671 
1672     static IntSize initialInitialLetter() { return IntSize(); }
1673     static LineClampValue initialLineClamp() { return LineClampValue(); }
1674     static TextSecurity initialTextSecurity() { return TextSecurity::None; }
1675 
1676 #if PLATFORM(IOS_FAMILY)
1677     static bool initialTouchCalloutEnabled() { return true; }
1678 #endif
1679 
1680 #if ENABLE(TOUCH_EVENTS)
1681     static Color initialTapHighlightColor();
1682 #endif
1683 
<span class="line-modified">1684 #if ENABLE(OVERFLOW_SCROLLING_TOUCH)</span>
1685     static bool initialUseTouchOverflowScrolling() { return false; }
1686 #endif
1687 





1688     static const FilterOperations&amp; initialFilter() { static NeverDestroyed&lt;FilterOperations&gt; ops; return ops; }
1689     static const FilterOperations&amp; initialAppleColorFilter() { static NeverDestroyed&lt;FilterOperations&gt; ops; return ops; }
1690 
1691 #if ENABLE(FILTERS_LEVEL_2)
1692     static const FilterOperations&amp; initialBackdropFilter() { static NeverDestroyed&lt;FilterOperations&gt; ops; return ops; }
1693 #endif
1694 
1695 #if ENABLE(CSS_COMPOSITING)
1696     static BlendMode initialBlendMode() { return BlendMode::Normal; }
1697     static Isolation initialIsolation() { return Isolation::Auto; }
1698 #endif
1699 
1700     // Indicates the style is likely to change due to a pending stylesheet load.
1701     bool isNotFinal() const { return m_rareNonInheritedData-&gt;isNotFinal; }
1702     void setIsNotFinal() { SET_VAR(m_rareNonInheritedData, isNotFinal, true); }
1703 
1704     void setVisitedLinkColor(const Color&amp;);
1705     void setVisitedLinkBackgroundColor(const Color&amp; v) { SET_VAR(m_rareNonInheritedData, visitedLinkBackgroundColor, v); }
1706     void setVisitedLinkBorderLeftColor(const Color&amp; v) { SET_VAR(m_rareNonInheritedData, visitedLinkBorderLeftColor, v); }
1707     void setVisitedLinkBorderRightColor(const Color&amp; v) { SET_VAR(m_rareNonInheritedData, visitedLinkBorderRightColor, v); }
</pre>
<hr />
<pre>
1764         bool hasAnyPublicPseudoStyles() const { return static_cast&lt;unsigned&gt;(PseudoId::PublicPseudoIdMask) &amp; pseudoBits; }
1765         bool hasPseudoStyle(PseudoId) const;
1766         void setHasPseudoStyle(PseudoId);
1767         void setHasPseudoStyles(PseudoIdSet);
1768 
1769         unsigned effectiveDisplay : 5; // DisplayType
1770         unsigned originalDisplay : 5; // DisplayType
1771         unsigned overflowX : 3; // Overflow
1772         unsigned overflowY : 3; // Overflow
1773         unsigned verticalAlign : 4; // VerticalAlign
1774         unsigned clear : 2; // Clear
1775         unsigned position : 3; // PositionType
1776         unsigned unicodeBidi : 3; // EUnicodeBidi
1777         unsigned floating : 2; // Float
1778         unsigned tableLayout : 1; // TableLayoutType
1779 
1780         unsigned hasExplicitlySetDirection : 1;
1781         unsigned hasExplicitlySetWritingMode : 1;
1782         unsigned hasExplicitlySetTextAlign : 1;
1783 #if ENABLE(DARK_MODE_CSS)
<span class="line-modified">1784         unsigned hasExplicitlySetColorScheme : 1;</span>
1785 #endif
1786         unsigned hasViewportUnits : 1;
1787         unsigned hasExplicitlyInheritedProperties : 1; // Explicitly inherits a non-inherited property.
1788         unsigned isUnique : 1; // Style cannot be shared.
1789         unsigned emptyState : 1;
1790         unsigned firstChildState : 1;
1791         unsigned lastChildState : 1;
1792         unsigned affectedByHover : 1;
1793         unsigned affectedByActive : 1;
1794         unsigned affectedByDrag : 1;
1795         unsigned isLink : 1;
1796 
1797         unsigned styleType : 4; // PseudoId
1798         unsigned pseudoBits : (static_cast&lt;unsigned&gt;(PseudoId::FirstInternalPseudoId) - static_cast&lt;unsigned&gt;(PseudoId::FirstPublicPseudoId));
1799 
1800         // If you add more style bits here, you will also need to update RenderStyle::NonInheritedFlags::copyNonInheritedFrom().
1801     };
1802 
1803     struct InheritedFlags {
1804         bool operator==(const InheritedFlags&amp;) const;
</pre>
<hr />
<pre>
1816 #if ENABLE(CURSOR_VISIBILITY)
1817         unsigned cursorVisibility : 1; // CursorVisibility
1818 #endif
1819         unsigned direction : 1; // TextDirection
1820         unsigned whiteSpace : 3; // WhiteSpace
1821         // 35 bits
1822         unsigned borderCollapse : 1; // BorderCollapse
1823         unsigned boxDirection : 1; // BoxDirection
1824 
1825         // non CSS2 inherited
1826         unsigned rtlOrdering : 1; // Order
1827         unsigned printColorAdjust : PrintColorAdjustBits; // PrintColorAdjust
1828         unsigned pointerEvents : 4; // PointerEvents
1829         unsigned insideLink : 2; // InsideLink
1830         unsigned insideDefaultButton : 1;
1831         // 46 bits
1832 
1833         // CSS Text Layout Module Level 3: Vertical writing support
1834         unsigned writingMode : 2; // WritingMode
1835         // 48 bits
<span class="line-added">1836 </span>
<span class="line-added">1837 #if ENABLE(TEXT_AUTOSIZING)</span>
<span class="line-added">1838         unsigned autosizeStatus : 5;</span>
<span class="line-added">1839 #endif</span>
<span class="line-added">1840         // 53 bits</span>
1841     };
1842 
1843     // This constructor is used to implement the replace operation.
1844     RenderStyle(RenderStyle&amp;, RenderStyle&amp;&amp;);
1845 
1846     DisplayType originalDisplay() const { return static_cast&lt;DisplayType&gt;(m_nonInheritedFlags.originalDisplay); }
1847 
1848     bool hasAutoLeftAndRight() const { return left().isAuto() &amp;&amp; right().isAuto(); }
1849     bool hasAutoTopAndBottom() const { return top().isAuto() &amp;&amp; bottom().isAuto(); }
1850 
1851     void setContent(std::unique_ptr&lt;ContentData&gt;, bool add);
1852 
1853     LayoutBoxExtent getShadowInsetExtent(const ShadowData*) const;
1854 
1855     static bool isDisplayReplacedType(DisplayType);
1856     static bool isDisplayInlineType(DisplayType);
1857     static bool isDisplayFlexibleBox(DisplayType);
1858     static bool isDisplayGridBox(DisplayType);
1859     static bool isDisplayFlexibleOrGridBox(DisplayType);
1860 
</pre>
<hr />
<pre>
1898 BorderStyle collapsedBorderStyle(BorderStyle);
1899 
1900 bool pseudoElementRendererIsNeeded(const RenderStyle*);
1901 
1902 inline bool RenderStyle::NonInheritedFlags::operator==(const NonInheritedFlags&amp; other) const
1903 {
1904     return effectiveDisplay == other.effectiveDisplay
1905         &amp;&amp; originalDisplay == other.originalDisplay
1906         &amp;&amp; overflowX == other.overflowX
1907         &amp;&amp; overflowY == other.overflowY
1908         &amp;&amp; verticalAlign == other.verticalAlign
1909         &amp;&amp; clear == other.clear
1910         &amp;&amp; position == other.position
1911         &amp;&amp; unicodeBidi == other.unicodeBidi
1912         &amp;&amp; floating == other.floating
1913         &amp;&amp; tableLayout == other.tableLayout
1914         &amp;&amp; hasExplicitlySetDirection == other.hasExplicitlySetDirection
1915         &amp;&amp; hasExplicitlySetWritingMode == other.hasExplicitlySetWritingMode
1916         &amp;&amp; hasExplicitlySetTextAlign == other.hasExplicitlySetTextAlign
1917 #if ENABLE(DARK_MODE_CSS)
<span class="line-modified">1918         &amp;&amp; hasExplicitlySetColorScheme == other.hasExplicitlySetColorScheme</span>
1919 #endif
1920         &amp;&amp; hasViewportUnits == other.hasViewportUnits
1921         &amp;&amp; hasExplicitlyInheritedProperties == other.hasExplicitlyInheritedProperties
1922         &amp;&amp; isUnique == other.isUnique
1923         &amp;&amp; emptyState == other.emptyState
1924         &amp;&amp; firstChildState == other.firstChildState
1925         &amp;&amp; lastChildState == other.lastChildState
1926         &amp;&amp; affectedByHover == other.affectedByHover
1927         &amp;&amp; affectedByActive == other.affectedByActive
1928         &amp;&amp; affectedByDrag == other.affectedByDrag
1929         &amp;&amp; isLink == other.isLink
1930         &amp;&amp; styleType == other.styleType
1931         &amp;&amp; pseudoBits == other.pseudoBits;
1932 }
1933 
1934 inline void RenderStyle::NonInheritedFlags::copyNonInheritedFrom(const NonInheritedFlags&amp; other)
1935 {
1936     // Only a subset is copied because NonInheritedFlags contains a bunch of stuff other than real style data.
1937     effectiveDisplay = other.effectiveDisplay;
1938     originalDisplay = other.originalDisplay;
</pre>
<hr />
<pre>
2001     if (zoomFactor == 1)
2002         return value;
2003     // Needed because computeLengthInt truncates (rather than rounds) when scaling up.
2004     if (zoomFactor &gt; 1) {
2005         if (value &lt; 0)
2006             value--;
2007         else
2008             value++;
2009     }
2010 
2011     return roundForImpreciseConversion&lt;int&gt;(value / zoomFactor);
2012 }
2013 
2014 inline float adjustFloatForAbsoluteZoom(float value, const RenderStyle&amp; style)
2015 {
2016     return value / style.effectiveZoom();
2017 }
2018 
2019 inline LayoutUnit adjustLayoutUnitForAbsoluteZoom(LayoutUnit value, const RenderStyle&amp; style)
2020 {
<span class="line-modified">2021     return LayoutUnit(value / style.effectiveZoom());</span>
2022 }
2023 
2024 inline BorderStyle collapsedBorderStyle(BorderStyle style)
2025 {
2026     if (style == BorderStyle::Outset)
2027         return BorderStyle::Groove;
2028     if (style == BorderStyle::Inset)
2029         return BorderStyle::Ridge;
2030     return style;
2031 }
2032 
<span class="line-modified">2033 inline const CSSCustomPropertyValue* RenderStyle::getCustomProperty(const AtomString&amp; name) const</span>
2034 {
2035     for (auto* map : { &amp;nonInheritedCustomProperties(), &amp;inheritedCustomProperties() }) {
2036         if (auto* val = map-&gt;get(name))
2037             return val;
2038     }
2039     return nullptr;
2040 }
2041 
2042 inline bool RenderStyle::hasBackground() const
2043 {
2044     return visitedDependentColor(CSSPropertyBackgroundColor).isVisible() ||  hasBackgroundImage();
2045 }
2046 
2047 inline bool RenderStyle::autoWrap(WhiteSpace whiteSpace)
2048 {
2049     // Nowrap and pre don&#39;t automatically wrap.
2050     return whiteSpace != WhiteSpace::NoWrap &amp;&amp; whiteSpace != WhiteSpace::Pre;
2051 }
2052 
2053 inline bool RenderStyle::preserveNewline(WhiteSpace whiteSpace)
2054 {
2055     // Normal and nowrap do not preserve newlines.
2056     return whiteSpace != WhiteSpace::Normal &amp;&amp; whiteSpace != WhiteSpace::NoWrap;
2057 }
2058 
2059 inline bool RenderStyle::collapseWhiteSpace(WhiteSpace ws)
2060 {
2061     // Pre and prewrap do not collapse whitespace.
<span class="line-modified">2062     return ws != WhiteSpace::Pre &amp;&amp; ws != WhiteSpace::PreWrap &amp;&amp; ws != WhiteSpace::BreakSpaces;</span>
2063 }
2064 
2065 inline bool RenderStyle::isCollapsibleWhiteSpace(UChar character) const
2066 {
2067     switch (character) {
2068     case &#39; &#39;:
2069     case &#39;\t&#39;:
2070         return collapseWhiteSpace();
2071     case &#39;\n&#39;:
2072         return !preserveNewline();
2073     default:
2074         return false;
2075     }
2076 }
2077 
2078 inline bool RenderStyle::breakOnlyAfterWhiteSpace() const
2079 {
<span class="line-modified">2080     return whiteSpace() == WhiteSpace::PreWrap || whiteSpace() == WhiteSpace::BreakSpaces || lineBreak() == LineBreak::AfterWhiteSpace;</span>
2081 }
2082 
2083 inline bool RenderStyle::breakWords() const
2084 {
2085     return wordBreak() == WordBreak::BreakWord || overflowWrap() == OverflowWrap::Break;
2086 }
2087 
2088 inline bool RenderStyle::hasInlineColumnAxis() const
2089 {
2090     auto axis = columnAxis();
2091     return axis == ColumnAxis::Auto || isHorizontalWritingMode() == (axis == ColumnAxis::Horizontal);
2092 }
2093 
<span class="line-modified">2094 inline ImageOrientation RenderStyle::imageOrientation() const</span>
2095 {
2096 #if ENABLE(CSS_IMAGE_ORIENTATION)
<span class="line-modified">2097     return ImageOrientation(m_rareInheritedData-&gt;imageOrientation);</span>
2098 #else
<span class="line-modified">2099     return ImageOrientation::None;</span>
2100 #endif
2101 }
2102 
2103 inline void RenderStyle::setLogicalWidth(Length&amp;&amp; logicalWidth)
2104 {
2105     if (isHorizontalWritingMode())
2106         setWidth(WTFMove(logicalWidth));
2107     else
2108         setHeight(WTFMove(logicalWidth));
2109 }
2110 
2111 inline void RenderStyle::setLogicalHeight(Length&amp;&amp; logicalHeight)
2112 {
2113     if (isHorizontalWritingMode())
2114         setHeight(WTFMove(logicalHeight));
2115     else
2116         setWidth(WTFMove(logicalHeight));
2117 }
2118 
2119 inline void RenderStyle::setBorderRadius(LengthSize&amp;&amp; size)
</pre>
</td>
</tr>
</table>
<center><a href="RenderStyle.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="RenderStyleConstants.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>