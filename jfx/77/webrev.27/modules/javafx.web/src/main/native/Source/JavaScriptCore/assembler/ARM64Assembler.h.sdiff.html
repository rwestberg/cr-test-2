<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/assembler/ARM64Assembler.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../SourcesWPE.txt.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ARMv7Assembler.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/assembler/ARM64Assembler.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (C) 2012-2018 Apple Inc. All rights reserved.</span>
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  * 1. Redistributions of source code must retain the above copyright
   8  *    notice, this list of conditions and the following disclaimer.
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #pragma once
  27 
  28 #if ENABLE(ASSEMBLER) &amp;&amp; CPU(ARM64)
  29 

  30 #include &quot;AssemblerBuffer.h&quot;
  31 #include &quot;AssemblerCommon.h&quot;
  32 #include &quot;CPU.h&quot;
  33 #include &quot;JSCPtrTag.h&quot;
  34 #include &lt;limits.h&gt;
  35 #include &lt;wtf/Assertions.h&gt;
  36 #include &lt;wtf/Vector.h&gt;
  37 #include &lt;stdint.h&gt;
  38 
  39 #if OS(FUCHSIA)
  40 #include &lt;zircon/syscalls.h&gt;
  41 #endif
  42 
  43 #define CHECK_DATASIZE_OF(datasize) ASSERT(datasize == 32 || datasize == 64)
  44 #define CHECK_MEMOPSIZE_OF(size) ASSERT(size == 8 || size == 16 || size == 32 || size == 64 || size == 128);
  45 #define DATASIZE_OF(datasize) ((datasize == 64) ? Datasize_64 : Datasize_32)
  46 #define MEMOPSIZE_OF(datasize) ((datasize == 8 || datasize == 128) ? MemOpSize_8_or_128 : (datasize == 16) ? MemOpSize_16 : (datasize == 32) ? MemOpSize_32 : MemOpSize_64)
  47 #define CHECK_DATASIZE() CHECK_DATASIZE_OF(datasize)
  48 #define CHECK_MEMOPSIZE() CHECK_MEMOPSIZE_OF(datasize)
  49 #define CHECK_VECTOR_DATASIZE() ASSERT(datasize == 64 || datasize == 128)
</pre>
<hr />
<pre>
 147 public:
 148     explicit PairPreIndex(int value)
 149         : m_value(value)
 150     {
 151         ASSERT(isInt&lt;11&gt;(value));
 152     }
 153 
 154     operator int() { return m_value; }
 155 
 156 private:
 157     int m_value;
 158 };
 159 
 160 typedef ARM64LogicalImmediate LogicalImmediate;
 161 
 162 inline uint16_t getHalfword(uint64_t value, int which)
 163 {
 164     return value &gt;&gt; (which &lt;&lt; 4);
 165 }
 166 
<span class="line-modified"> 167 namespace ARM64Registers {</span>
 168 
 169 typedef enum : int8_t {
<span class="line-modified"> 170     // Parameter/result registers.</span>
<span class="line-modified"> 171     x0,</span>
<span class="line-modified"> 172     x1,</span>
<span class="line-modified"> 173     x2,</span>
<span class="line-modified"> 174     x3,</span>
<span class="line-modified"> 175     x4,</span>
<span class="line-modified"> 176     x5,</span>
<span class="line-modified"> 177     x6,</span>
<span class="line-removed"> 178     x7,</span>
<span class="line-removed"> 179     // Indirect result location register.</span>
<span class="line-removed"> 180     x8,</span>
<span class="line-removed"> 181     // Temporary registers.</span>
<span class="line-removed"> 182     x9,</span>
<span class="line-removed"> 183     x10,</span>
<span class="line-removed"> 184     x11,</span>
<span class="line-removed"> 185     x12,</span>
<span class="line-removed"> 186     x13,</span>
<span class="line-removed"> 187     x14,</span>
<span class="line-removed"> 188     x15,</span>
<span class="line-removed"> 189     // Intra-procedure-call scratch registers (temporary).</span>
<span class="line-removed"> 190     x16,</span>
<span class="line-removed"> 191     x17,</span>
<span class="line-removed"> 192     // Platform Register (temporary).</span>
<span class="line-removed"> 193     x18,</span>
<span class="line-removed"> 194     // Callee-saved.</span>
<span class="line-removed"> 195     x19,</span>
<span class="line-removed"> 196     x20,</span>
<span class="line-removed"> 197     x21,</span>
<span class="line-removed"> 198     x22,</span>
<span class="line-removed"> 199     x23,</span>
<span class="line-removed"> 200     x24,</span>
<span class="line-removed"> 201     x25,</span>
<span class="line-removed"> 202     x26,</span>
<span class="line-removed"> 203     x27,</span>
<span class="line-removed"> 204     x28,</span>
<span class="line-removed"> 205     // Special.</span>
<span class="line-removed"> 206     fp,</span>
<span class="line-removed"> 207     lr,</span>
<span class="line-removed"> 208     sp,</span>
<span class="line-removed"> 209 </span>
<span class="line-removed"> 210     ip0 = x16,</span>
<span class="line-removed"> 211     ip1 = x17,</span>
<span class="line-removed"> 212     x29 = fp,</span>
<span class="line-removed"> 213     x30 = lr,</span>
<span class="line-removed"> 214     zr = 0x3f,</span>
 215     InvalidGPRReg = -1,
 216 } RegisterID;
 217 
 218 typedef enum : int8_t {
<span class="line-modified"> 219     pc,</span>
<span class="line-modified"> 220     nzcv,</span>
<span class="line-modified"> 221     fpsr</span>
 222 } SPRegisterID;
 223 
 224 // ARM64 always has 32 FPU registers 128-bits each. See http://llvm.org/devmtg/2012-11/Northover-AArch64.pdf
 225 // and Section 5.1.2 in http://infocenter.arm.com/help/topic/com.arm.doc.ihi0055b/IHI0055B_aapcs64.pdf.
 226 // However, we only use them for 64-bit doubles.
 227 typedef enum : int8_t {
<span class="line-modified"> 228     // Parameter/result registers.</span>
<span class="line-modified"> 229     q0,</span>
<span class="line-modified"> 230     q1,</span>
<span class="line-removed"> 231     q2,</span>
<span class="line-removed"> 232     q3,</span>
<span class="line-removed"> 233     q4,</span>
<span class="line-removed"> 234     q5,</span>
<span class="line-removed"> 235     q6,</span>
<span class="line-removed"> 236     q7,</span>
<span class="line-removed"> 237     // Callee-saved (up to 64-bits only!).</span>
<span class="line-removed"> 238     q8,</span>
<span class="line-removed"> 239     q9,</span>
<span class="line-removed"> 240     q10,</span>
<span class="line-removed"> 241     q11,</span>
<span class="line-removed"> 242     q12,</span>
<span class="line-removed"> 243     q13,</span>
<span class="line-removed"> 244     q14,</span>
<span class="line-removed"> 245     q15,</span>
<span class="line-removed"> 246     // Temporary registers.</span>
<span class="line-removed"> 247     q16,</span>
<span class="line-removed"> 248     q17,</span>
<span class="line-removed"> 249     q18,</span>
<span class="line-removed"> 250     q19,</span>
<span class="line-removed"> 251     q20,</span>
<span class="line-removed"> 252     q21,</span>
<span class="line-removed"> 253     q22,</span>
<span class="line-removed"> 254     q23,</span>
<span class="line-removed"> 255     q24,</span>
<span class="line-removed"> 256     q25,</span>
<span class="line-removed"> 257     q26,</span>
<span class="line-removed"> 258     q27,</span>
<span class="line-removed"> 259     q28,</span>
<span class="line-removed"> 260     q29,</span>
<span class="line-removed"> 261     q30,</span>
<span class="line-removed"> 262     q31,</span>
 263     InvalidFPRReg = -1,
 264 } FPRegisterID;
 265 
 266 static constexpr bool isSp(RegisterID reg) { return reg == sp; }
 267 static constexpr bool isZr(RegisterID reg) { return reg == zr; }
 268 
 269 } // namespace ARM64Registers
 270 
 271 class ARM64Assembler {
 272 public:
 273     static constexpr size_t instructionSize = sizeof(unsigned);
 274 
 275     typedef ARM64Registers::RegisterID RegisterID;
 276     typedef ARM64Registers::SPRegisterID SPRegisterID;
 277     typedef ARM64Registers::FPRegisterID FPRegisterID;
 278 
 279     static constexpr RegisterID firstRegister() { return ARM64Registers::x0; }
 280     static constexpr RegisterID lastRegister() { return ARM64Registers::sp; }
 281     static constexpr unsigned numberOfRegisters() { return lastRegister() - firstRegister() + 1; }
 282 
 283     static constexpr SPRegisterID firstSPRegister() { return ARM64Registers::pc; }
 284     static constexpr SPRegisterID lastSPRegister() { return ARM64Registers::fpsr; }
 285     static constexpr unsigned numberOfSPRegisters() { return lastSPRegister() - firstSPRegister() + 1; }
 286 
 287     static constexpr FPRegisterID firstFPRegister() { return ARM64Registers::q0; }
 288     static constexpr FPRegisterID lastFPRegister() { return ARM64Registers::q31; }
 289     static constexpr unsigned numberOfFPRegisters() { return lastFPRegister() - firstFPRegister() + 1; }
 290 
 291     static const char* gprName(RegisterID id)
 292     {
 293         ASSERT(id &gt;= firstRegister() &amp;&amp; id &lt;= lastRegister());
 294         static const char* const nameForRegister[numberOfRegisters()] = {
<span class="line-modified"> 295             &quot;r0&quot;, &quot;r1&quot;, &quot;r2&quot;, &quot;r3&quot;, &quot;r4&quot;, &quot;r5&quot;, &quot;r6&quot;, &quot;r7&quot;,</span>
<span class="line-modified"> 296             &quot;r8&quot;, &quot;r9&quot;, &quot;r10&quot;, &quot;r11&quot;, &quot;r12&quot;, &quot;r13&quot;, &quot;r14&quot;, &quot;r15&quot;,</span>
<span class="line-modified"> 297             &quot;r16&quot;, &quot;r17&quot;, &quot;r18&quot;, &quot;r19&quot;, &quot;r20&quot;, &quot;r21&quot;, &quot;r22&quot;, &quot;r23&quot;,</span>
<span class="line-removed"> 298             &quot;r24&quot;, &quot;r25&quot;, &quot;r26&quot;, &quot;r27&quot;, &quot;r28&quot;, &quot;fp&quot;, &quot;lr&quot;, &quot;sp&quot;</span>
 299         };
 300         return nameForRegister[id];
 301     }
 302 
 303     static const char* sprName(SPRegisterID id)
 304     {
 305         ASSERT(id &gt;= firstSPRegister() &amp;&amp; id &lt;= lastSPRegister());
 306         static const char* const nameForRegister[numberOfSPRegisters()] = {
<span class="line-modified"> 307             &quot;pc&quot;, &quot;nzcv&quot;, &quot;fpsr&quot;</span>


 308         };
 309         return nameForRegister[id];
 310     }
 311 
 312     static const char* fprName(FPRegisterID id)
 313     {
 314         ASSERT(id &gt;= firstFPRegister() &amp;&amp; id &lt;= lastFPRegister());
 315         static const char* const nameForRegister[numberOfFPRegisters()] = {
<span class="line-modified"> 316             &quot;q0&quot;, &quot;q1&quot;, &quot;q2&quot;, &quot;q3&quot;, &quot;q4&quot;, &quot;q5&quot;, &quot;q6&quot;, &quot;q7&quot;,</span>
<span class="line-modified"> 317             &quot;q8&quot;, &quot;q9&quot;, &quot;q10&quot;, &quot;q11&quot;, &quot;q12&quot;, &quot;q13&quot;, &quot;q14&quot;, &quot;q15&quot;,</span>
<span class="line-modified"> 318             &quot;q16&quot;, &quot;q17&quot;, &quot;q18&quot;, &quot;q19&quot;, &quot;q20&quot;, &quot;q21&quot;, &quot;q22&quot;, &quot;q23&quot;,</span>
<span class="line-removed"> 319             &quot;q24&quot;, &quot;q25&quot;, &quot;q26&quot;, &quot;q27&quot;, &quot;q28&quot;, &quot;q29&quot;, &quot;q30&quot;, &quot;q31&quot;</span>
 320         };
 321         return nameForRegister[id];
 322     }
 323 
 324 protected:
 325     static constexpr bool isSp(RegisterID reg) { return ARM64Registers::isSp(reg); }
 326     static constexpr bool isZr(RegisterID reg) { return ARM64Registers::isZr(reg); }
 327 
 328 public:
 329     ARM64Assembler()
 330         : m_indexOfLastWatchpoint(INT_MIN)
 331         , m_indexOfTailOfLastWatchpoint(INT_MIN)
 332     {
 333     }
 334 
 335     AssemblerBuffer&amp; buffer() { return m_buffer; }
 336 
 337     // (HS, LO, HI, LS) -&gt; (AE, B, A, BE)
 338     // (VS, VC) -&gt; (O, NO)
 339     typedef enum {
</pre>
<hr />
<pre>
2961         default:
2962             ASSERT_NOT_REACHED();
2963         }
2964 
2965         return LinkJumpNoCondition;
2966     }
2967 
2968     static JumpLinkType computeJumpType(LinkRecord&amp; record, const uint8_t* from, const uint8_t* to)
2969     {
2970         JumpLinkType linkType = computeJumpType(record.type(), from, to);
2971         record.setLinkType(linkType);
2972         return linkType;
2973     }
2974 
2975     Vector&lt;LinkRecord, 0, UnsafeVectorOverflow&gt;&amp; jumpsToLink()
2976     {
2977         std::sort(m_jumpsToLink.begin(), m_jumpsToLink.end(), linkRecordSourceComparator);
2978         return m_jumpsToLink;
2979     }
2980 



















2981     typedef void* (*CopyFunction)(void*, const void*, size_t);

2982 
2983     static void ALWAYS_INLINE link(LinkRecord&amp; record, uint8_t* from, const uint8_t* fromInstruction8, uint8_t* to, CopyFunction copy)
2984     {
2985         const int* fromInstruction = reinterpret_cast&lt;const int*&gt;(fromInstruction8);
2986         switch (record.linkType()) {
2987         case LinkJumpNoCondition:
2988             linkJumpOrCall&lt;false&gt;(reinterpret_cast&lt;int*&gt;(from), fromInstruction, to, copy);
2989             break;
2990         case LinkJumpConditionDirect:
2991             linkConditionalBranch&lt;true&gt;(record.condition(), reinterpret_cast&lt;int*&gt;(from), fromInstruction, to, copy);
2992             break;
2993         case LinkJumpCondition:
2994             linkConditionalBranch&lt;false&gt;(record.condition(), reinterpret_cast&lt;int*&gt;(from) - 1, fromInstruction - 1, to, copy);
2995             break;
2996         case LinkJumpCompareAndBranchDirect:
2997             linkCompareAndBranch&lt;true&gt;(record.condition(), record.is64Bit(), record.compareRegister(), reinterpret_cast&lt;int*&gt;(from), fromInstruction, to, copy);
2998             break;
2999         case LinkJumpCompareAndBranch:
3000             linkCompareAndBranch&lt;false&gt;(record.condition(), record.is64Bit(), record.compareRegister(), reinterpret_cast&lt;int*&gt;(from) - 1, fromInstruction - 1, to, copy);
3001             break;
</pre>
<hr />
<pre>
3028             &amp;&amp; hw == _hw
3029             &amp;&amp; rd == _rd;
3030     }
3031 
3032     static void linkPointer(int* address, void* valuePtr, bool flush = false)
3033     {
3034         Datasize sf;
3035         MoveWideOp opc;
3036         int hw;
3037         uint16_t imm16;
3038         RegisterID rd;
3039         bool expected = disassembleMoveWideImediate(address, sf, opc, hw, imm16, rd);
3040         ASSERT_UNUSED(expected, expected &amp;&amp; sf &amp;&amp; opc == MoveWideOp_Z &amp;&amp; !hw);
3041         ASSERT(checkMovk&lt;Datasize_64&gt;(address[1], 1, rd));
3042         ASSERT(checkMovk&lt;Datasize_64&gt;(address[2], 2, rd));
3043 
3044         setPointer(address, valuePtr, rd, flush);
3045     }
3046 
3047     template&lt;bool isCall&gt;
<span class="line-modified">3048     static void linkJumpOrCall(int* from, const int* fromInstruction, void* to, CopyFunction copy = performJITMemcpy)</span>
3049     {
3050         bool link;
3051         int imm26;
3052         bool isUnconditionalBranchImmediateOrNop = disassembleUnconditionalBranchImmediate(from, link, imm26) || disassembleNop(from);
3053 
3054         ASSERT_UNUSED(isUnconditionalBranchImmediateOrNop, isUnconditionalBranchImmediateOrNop);
3055         ASSERT_UNUSED(isCall, (link == isCall) || disassembleNop(from));
3056         ASSERT(!(reinterpret_cast&lt;intptr_t&gt;(from) &amp; 3));
3057         ASSERT(!(reinterpret_cast&lt;intptr_t&gt;(to) &amp; 3));
3058         assertIsNotTagged(to);
3059         assertIsNotTagged(fromInstruction);
3060         intptr_t offset = (reinterpret_cast&lt;intptr_t&gt;(to) - reinterpret_cast&lt;intptr_t&gt;(fromInstruction)) &gt;&gt; 2;
3061         ASSERT(static_cast&lt;int&gt;(offset) == offset);
3062 
3063         int insn = unconditionalBranchImmediate(isCall, static_cast&lt;int&gt;(offset));
3064         RELEASE_ASSERT(roundUpToMultipleOf&lt;instructionSize&gt;(from) == from);
3065         copy(from, &amp;insn, sizeof(int));
3066     }
3067 
3068     template&lt;bool isDirect&gt;
<span class="line-modified">3069     static void linkCompareAndBranch(Condition condition, bool is64Bit, RegisterID rt, int* from, const int* fromInstruction, void* to, CopyFunction copy = performJITMemcpy)</span>
3070     {
3071         ASSERT(!(reinterpret_cast&lt;intptr_t&gt;(from) &amp; 3));
3072         ASSERT(!(reinterpret_cast&lt;intptr_t&gt;(to) &amp; 3));
3073         intptr_t offset = (reinterpret_cast&lt;intptr_t&gt;(to) - reinterpret_cast&lt;intptr_t&gt;(fromInstruction)) &gt;&gt; 2;
3074         ASSERT(isInt&lt;26&gt;(offset));
3075 
3076         bool useDirect = isInt&lt;19&gt;(offset);
3077         ASSERT(!isDirect || useDirect);
3078 
3079         if (useDirect || isDirect) {
3080             int insn = compareAndBranchImmediate(is64Bit ? Datasize_64 : Datasize_32, condition == ConditionNE, static_cast&lt;int&gt;(offset), rt);
3081             RELEASE_ASSERT(roundUpToMultipleOf&lt;instructionSize&gt;(from) == from);
3082             copy(from, &amp;insn, sizeof(int));
3083             if (!isDirect) {
3084                 insn = nopPseudo();
3085                 RELEASE_ASSERT(roundUpToMultipleOf&lt;instructionSize&gt;(from + 1) == (from + 1));
3086                 copy(from + 1, &amp;insn, sizeof(int));
3087             }
3088         } else {
3089             int insn = compareAndBranchImmediate(is64Bit ? Datasize_64 : Datasize_32, invert(condition) == ConditionNE, 2, rt);
3090             RELEASE_ASSERT(roundUpToMultipleOf&lt;instructionSize&gt;(from) == from);
3091             copy(from, &amp;insn, sizeof(int));
3092             linkJumpOrCall&lt;false&gt;(from + 1, fromInstruction + 1, to, copy);
3093         }
3094     }
3095 
3096     template&lt;bool isDirect&gt;
<span class="line-modified">3097     static void linkConditionalBranch(Condition condition, int* from, const int* fromInstruction, void* to, CopyFunction copy = performJITMemcpy)</span>
3098     {
3099         ASSERT(!(reinterpret_cast&lt;intptr_t&gt;(from) &amp; 3));
3100         ASSERT(!(reinterpret_cast&lt;intptr_t&gt;(to) &amp; 3));
3101         intptr_t offset = (reinterpret_cast&lt;intptr_t&gt;(to) - reinterpret_cast&lt;intptr_t&gt;(fromInstruction)) &gt;&gt; 2;
3102         ASSERT(isInt&lt;26&gt;(offset));
3103 
3104         bool useDirect = isInt&lt;19&gt;(offset);
3105         ASSERT(!isDirect || useDirect);
3106 
3107         if (useDirect || isDirect) {
3108             int insn = conditionalBranchImmediate(static_cast&lt;int&gt;(offset), condition);
3109             RELEASE_ASSERT(roundUpToMultipleOf&lt;instructionSize&gt;(from) == from);
3110             copy(from, &amp;insn, sizeof(int));
3111             if (!isDirect) {
3112                 insn = nopPseudo();
3113                 RELEASE_ASSERT(roundUpToMultipleOf&lt;instructionSize&gt;(from + 1) == (from + 1));
3114                 copy(from + 1, &amp;insn, sizeof(int));
3115             }
3116         } else {
3117             int insn = conditionalBranchImmediate(2, invert(condition));
3118             RELEASE_ASSERT(roundUpToMultipleOf&lt;instructionSize&gt;(from) == from);
3119             copy(from, &amp;insn, sizeof(int));
3120             linkJumpOrCall&lt;false&gt;(from + 1, fromInstruction + 1, to, copy);
3121         }
3122     }
3123 
3124     template&lt;bool isDirect&gt;
<span class="line-modified">3125     static void linkTestAndBranch(Condition condition, unsigned bitNumber, RegisterID rt, int* from, const int* fromInstruction, void* to, CopyFunction copy = performJITMemcpy)</span>
3126     {
3127         ASSERT(!(reinterpret_cast&lt;intptr_t&gt;(from) &amp; 3));
3128         ASSERT(!(reinterpret_cast&lt;intptr_t&gt;(to) &amp; 3));
3129         intptr_t offset = (reinterpret_cast&lt;intptr_t&gt;(to) - reinterpret_cast&lt;intptr_t&gt;(fromInstruction)) &gt;&gt; 2;
3130         ASSERT(static_cast&lt;int&gt;(offset) == offset);
3131         ASSERT(isInt&lt;26&gt;(offset));
3132 
3133         bool useDirect = isInt&lt;14&gt;(offset);
3134         ASSERT(!isDirect || useDirect);
3135 
3136         if (useDirect || isDirect) {
3137             int insn = testAndBranchImmediate(condition == ConditionNE, static_cast&lt;int&gt;(bitNumber), static_cast&lt;int&gt;(offset), rt);
3138             RELEASE_ASSERT(roundUpToMultipleOf&lt;instructionSize&gt;(from) == from);
3139             copy(from, &amp;insn, sizeof(int));
3140             if (!isDirect) {
3141                 insn = nopPseudo();
3142                 RELEASE_ASSERT(roundUpToMultipleOf&lt;instructionSize&gt;(from + 1) == (from + 1));
3143                 copy(from + 1, &amp;insn, sizeof(int));
3144             }
3145         } else {
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (C) 2012-2019 Apple Inc. All rights reserved.</span>
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  * 1. Redistributions of source code must retain the above copyright
   8  *    notice, this list of conditions and the following disclaimer.
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #pragma once
  27 
  28 #if ENABLE(ASSEMBLER) &amp;&amp; CPU(ARM64)
  29 
<span class="line-added">  30 #include &quot;ARM64Registers.h&quot;</span>
  31 #include &quot;AssemblerBuffer.h&quot;
  32 #include &quot;AssemblerCommon.h&quot;
  33 #include &quot;CPU.h&quot;
  34 #include &quot;JSCPtrTag.h&quot;
  35 #include &lt;limits.h&gt;
  36 #include &lt;wtf/Assertions.h&gt;
  37 #include &lt;wtf/Vector.h&gt;
  38 #include &lt;stdint.h&gt;
  39 
  40 #if OS(FUCHSIA)
  41 #include &lt;zircon/syscalls.h&gt;
  42 #endif
  43 
  44 #define CHECK_DATASIZE_OF(datasize) ASSERT(datasize == 32 || datasize == 64)
  45 #define CHECK_MEMOPSIZE_OF(size) ASSERT(size == 8 || size == 16 || size == 32 || size == 64 || size == 128);
  46 #define DATASIZE_OF(datasize) ((datasize == 64) ? Datasize_64 : Datasize_32)
  47 #define MEMOPSIZE_OF(datasize) ((datasize == 8 || datasize == 128) ? MemOpSize_8_or_128 : (datasize == 16) ? MemOpSize_16 : (datasize == 32) ? MemOpSize_32 : MemOpSize_64)
  48 #define CHECK_DATASIZE() CHECK_DATASIZE_OF(datasize)
  49 #define CHECK_MEMOPSIZE() CHECK_MEMOPSIZE_OF(datasize)
  50 #define CHECK_VECTOR_DATASIZE() ASSERT(datasize == 64 || datasize == 128)
</pre>
<hr />
<pre>
 148 public:
 149     explicit PairPreIndex(int value)
 150         : m_value(value)
 151     {
 152         ASSERT(isInt&lt;11&gt;(value));
 153     }
 154 
 155     operator int() { return m_value; }
 156 
 157 private:
 158     int m_value;
 159 };
 160 
 161 typedef ARM64LogicalImmediate LogicalImmediate;
 162 
 163 inline uint16_t getHalfword(uint64_t value, int which)
 164 {
 165     return value &gt;&gt; (which &lt;&lt; 4);
 166 }
 167 
<span class="line-modified"> 168 namespace RegisterNames {</span>
 169 
 170 typedef enum : int8_t {
<span class="line-modified"> 171 #define REGISTER_ID(id, name, r, cs) id,</span>
<span class="line-modified"> 172     FOR_EACH_GP_REGISTER(REGISTER_ID)</span>
<span class="line-modified"> 173 #undef REGISTER_ID</span>
<span class="line-modified"> 174 </span>
<span class="line-modified"> 175 #define REGISTER_ALIAS(id, name, alias) id = alias,</span>
<span class="line-modified"> 176     FOR_EACH_REGISTER_ALIAS(REGISTER_ALIAS)</span>
<span class="line-modified"> 177 #undef REGISTER_ALIAS</span>
<span class="line-modified"> 178 </span>





































 179     InvalidGPRReg = -1,
 180 } RegisterID;
 181 
 182 typedef enum : int8_t {
<span class="line-modified"> 183 #define REGISTER_ID(id, name) id,</span>
<span class="line-modified"> 184     FOR_EACH_SP_REGISTER(REGISTER_ID)</span>
<span class="line-modified"> 185 #undef REGISTER_ID</span>
 186 } SPRegisterID;
 187 
 188 // ARM64 always has 32 FPU registers 128-bits each. See http://llvm.org/devmtg/2012-11/Northover-AArch64.pdf
 189 // and Section 5.1.2 in http://infocenter.arm.com/help/topic/com.arm.doc.ihi0055b/IHI0055B_aapcs64.pdf.
 190 // However, we only use them for 64-bit doubles.
 191 typedef enum : int8_t {
<span class="line-modified"> 192 #define REGISTER_ID(id, name, r, cs) id,</span>
<span class="line-modified"> 193     FOR_EACH_FP_REGISTER(REGISTER_ID)</span>
<span class="line-modified"> 194 #undef REGISTER_ID</span>
































 195     InvalidFPRReg = -1,
 196 } FPRegisterID;
 197 
 198 static constexpr bool isSp(RegisterID reg) { return reg == sp; }
 199 static constexpr bool isZr(RegisterID reg) { return reg == zr; }
 200 
 201 } // namespace ARM64Registers
 202 
 203 class ARM64Assembler {
 204 public:
 205     static constexpr size_t instructionSize = sizeof(unsigned);
 206 
 207     typedef ARM64Registers::RegisterID RegisterID;
 208     typedef ARM64Registers::SPRegisterID SPRegisterID;
 209     typedef ARM64Registers::FPRegisterID FPRegisterID;
 210 
 211     static constexpr RegisterID firstRegister() { return ARM64Registers::x0; }
 212     static constexpr RegisterID lastRegister() { return ARM64Registers::sp; }
 213     static constexpr unsigned numberOfRegisters() { return lastRegister() - firstRegister() + 1; }
 214 
 215     static constexpr SPRegisterID firstSPRegister() { return ARM64Registers::pc; }
 216     static constexpr SPRegisterID lastSPRegister() { return ARM64Registers::fpsr; }
 217     static constexpr unsigned numberOfSPRegisters() { return lastSPRegister() - firstSPRegister() + 1; }
 218 
 219     static constexpr FPRegisterID firstFPRegister() { return ARM64Registers::q0; }
 220     static constexpr FPRegisterID lastFPRegister() { return ARM64Registers::q31; }
 221     static constexpr unsigned numberOfFPRegisters() { return lastFPRegister() - firstFPRegister() + 1; }
 222 
 223     static const char* gprName(RegisterID id)
 224     {
 225         ASSERT(id &gt;= firstRegister() &amp;&amp; id &lt;= lastRegister());
 226         static const char* const nameForRegister[numberOfRegisters()] = {
<span class="line-modified"> 227 #define REGISTER_NAME(id, name, r, cs) name,</span>
<span class="line-modified"> 228         FOR_EACH_GP_REGISTER(REGISTER_NAME)</span>
<span class="line-modified"> 229 #undef REGISTER_NAME</span>

 230         };
 231         return nameForRegister[id];
 232     }
 233 
 234     static const char* sprName(SPRegisterID id)
 235     {
 236         ASSERT(id &gt;= firstSPRegister() &amp;&amp; id &lt;= lastSPRegister());
 237         static const char* const nameForRegister[numberOfSPRegisters()] = {
<span class="line-modified"> 238 #define REGISTER_NAME(id, name) name,</span>
<span class="line-added"> 239         FOR_EACH_SP_REGISTER(REGISTER_NAME)</span>
<span class="line-added"> 240 #undef REGISTER_NAME</span>
 241         };
 242         return nameForRegister[id];
 243     }
 244 
 245     static const char* fprName(FPRegisterID id)
 246     {
 247         ASSERT(id &gt;= firstFPRegister() &amp;&amp; id &lt;= lastFPRegister());
 248         static const char* const nameForRegister[numberOfFPRegisters()] = {
<span class="line-modified"> 249 #define REGISTER_NAME(id, name, r, cs) name,</span>
<span class="line-modified"> 250         FOR_EACH_FP_REGISTER(REGISTER_NAME)</span>
<span class="line-modified"> 251 #undef REGISTER_NAME</span>

 252         };
 253         return nameForRegister[id];
 254     }
 255 
 256 protected:
 257     static constexpr bool isSp(RegisterID reg) { return ARM64Registers::isSp(reg); }
 258     static constexpr bool isZr(RegisterID reg) { return ARM64Registers::isZr(reg); }
 259 
 260 public:
 261     ARM64Assembler()
 262         : m_indexOfLastWatchpoint(INT_MIN)
 263         , m_indexOfTailOfLastWatchpoint(INT_MIN)
 264     {
 265     }
 266 
 267     AssemblerBuffer&amp; buffer() { return m_buffer; }
 268 
 269     // (HS, LO, HI, LS) -&gt; (AE, B, A, BE)
 270     // (VS, VC) -&gt; (O, NO)
 271     typedef enum {
</pre>
<hr />
<pre>
2893         default:
2894             ASSERT_NOT_REACHED();
2895         }
2896 
2897         return LinkJumpNoCondition;
2898     }
2899 
2900     static JumpLinkType computeJumpType(LinkRecord&amp; record, const uint8_t* from, const uint8_t* to)
2901     {
2902         JumpLinkType linkType = computeJumpType(record.type(), from, to);
2903         record.setLinkType(linkType);
2904         return linkType;
2905     }
2906 
2907     Vector&lt;LinkRecord, 0, UnsafeVectorOverflow&gt;&amp; jumpsToLink()
2908     {
2909         std::sort(m_jumpsToLink.begin(), m_jumpsToLink.end(), linkRecordSourceComparator);
2910         return m_jumpsToLink;
2911     }
2912 
<span class="line-added">2913 #if CPU(ARM64E)</span>
<span class="line-added">2914     class CopyFunction {</span>
<span class="line-added">2915         typedef void* (*Func)(void*, const void*, size_t);</span>
<span class="line-added">2916     public:</span>
<span class="line-added">2917         CopyFunction(Func func)</span>
<span class="line-added">2918             : m_func(func)</span>
<span class="line-added">2919         {</span>
<span class="line-added">2920             assertIsNullOrTaggedWith(func, CopyFunctionPtrTag);</span>
<span class="line-added">2921         }</span>
<span class="line-added">2922 </span>
<span class="line-added">2923         void* operator()(void* dst, const void* src, size_t size)</span>
<span class="line-added">2924         {</span>
<span class="line-added">2925             return ptrauth_auth_function(m_func, ptrauth_key_process_dependent_code, CopyFunctionPtrTag)(dst, src, size);</span>
<span class="line-added">2926         }</span>
<span class="line-added">2927 </span>
<span class="line-added">2928     private:</span>
<span class="line-added">2929         Func m_func;</span>
<span class="line-added">2930     };</span>
<span class="line-added">2931 #else</span>
2932     typedef void* (*CopyFunction)(void*, const void*, size_t);
<span class="line-added">2933 #endif</span>
2934 
2935     static void ALWAYS_INLINE link(LinkRecord&amp; record, uint8_t* from, const uint8_t* fromInstruction8, uint8_t* to, CopyFunction copy)
2936     {
2937         const int* fromInstruction = reinterpret_cast&lt;const int*&gt;(fromInstruction8);
2938         switch (record.linkType()) {
2939         case LinkJumpNoCondition:
2940             linkJumpOrCall&lt;false&gt;(reinterpret_cast&lt;int*&gt;(from), fromInstruction, to, copy);
2941             break;
2942         case LinkJumpConditionDirect:
2943             linkConditionalBranch&lt;true&gt;(record.condition(), reinterpret_cast&lt;int*&gt;(from), fromInstruction, to, copy);
2944             break;
2945         case LinkJumpCondition:
2946             linkConditionalBranch&lt;false&gt;(record.condition(), reinterpret_cast&lt;int*&gt;(from) - 1, fromInstruction - 1, to, copy);
2947             break;
2948         case LinkJumpCompareAndBranchDirect:
2949             linkCompareAndBranch&lt;true&gt;(record.condition(), record.is64Bit(), record.compareRegister(), reinterpret_cast&lt;int*&gt;(from), fromInstruction, to, copy);
2950             break;
2951         case LinkJumpCompareAndBranch:
2952             linkCompareAndBranch&lt;false&gt;(record.condition(), record.is64Bit(), record.compareRegister(), reinterpret_cast&lt;int*&gt;(from) - 1, fromInstruction - 1, to, copy);
2953             break;
</pre>
<hr />
<pre>
2980             &amp;&amp; hw == _hw
2981             &amp;&amp; rd == _rd;
2982     }
2983 
2984     static void linkPointer(int* address, void* valuePtr, bool flush = false)
2985     {
2986         Datasize sf;
2987         MoveWideOp opc;
2988         int hw;
2989         uint16_t imm16;
2990         RegisterID rd;
2991         bool expected = disassembleMoveWideImediate(address, sf, opc, hw, imm16, rd);
2992         ASSERT_UNUSED(expected, expected &amp;&amp; sf &amp;&amp; opc == MoveWideOp_Z &amp;&amp; !hw);
2993         ASSERT(checkMovk&lt;Datasize_64&gt;(address[1], 1, rd));
2994         ASSERT(checkMovk&lt;Datasize_64&gt;(address[2], 2, rd));
2995 
2996         setPointer(address, valuePtr, rd, flush);
2997     }
2998 
2999     template&lt;bool isCall&gt;
<span class="line-modified">3000     static void linkJumpOrCall(int* from, const int* fromInstruction, void* to, CopyFunction copy = tagCFunctionPtr&lt;CopyFunctionPtrTag&gt;(performJITMemcpy))</span>
3001     {
3002         bool link;
3003         int imm26;
3004         bool isUnconditionalBranchImmediateOrNop = disassembleUnconditionalBranchImmediate(from, link, imm26) || disassembleNop(from);
3005 
3006         ASSERT_UNUSED(isUnconditionalBranchImmediateOrNop, isUnconditionalBranchImmediateOrNop);
3007         ASSERT_UNUSED(isCall, (link == isCall) || disassembleNop(from));
3008         ASSERT(!(reinterpret_cast&lt;intptr_t&gt;(from) &amp; 3));
3009         ASSERT(!(reinterpret_cast&lt;intptr_t&gt;(to) &amp; 3));
3010         assertIsNotTagged(to);
3011         assertIsNotTagged(fromInstruction);
3012         intptr_t offset = (reinterpret_cast&lt;intptr_t&gt;(to) - reinterpret_cast&lt;intptr_t&gt;(fromInstruction)) &gt;&gt; 2;
3013         ASSERT(static_cast&lt;int&gt;(offset) == offset);
3014 
3015         int insn = unconditionalBranchImmediate(isCall, static_cast&lt;int&gt;(offset));
3016         RELEASE_ASSERT(roundUpToMultipleOf&lt;instructionSize&gt;(from) == from);
3017         copy(from, &amp;insn, sizeof(int));
3018     }
3019 
3020     template&lt;bool isDirect&gt;
<span class="line-modified">3021     static void linkCompareAndBranch(Condition condition, bool is64Bit, RegisterID rt, int* from, const int* fromInstruction, void* to, CopyFunction copy = tagCFunctionPtr&lt;CopyFunctionPtrTag&gt;(performJITMemcpy))</span>
3022     {
3023         ASSERT(!(reinterpret_cast&lt;intptr_t&gt;(from) &amp; 3));
3024         ASSERT(!(reinterpret_cast&lt;intptr_t&gt;(to) &amp; 3));
3025         intptr_t offset = (reinterpret_cast&lt;intptr_t&gt;(to) - reinterpret_cast&lt;intptr_t&gt;(fromInstruction)) &gt;&gt; 2;
3026         ASSERT(isInt&lt;26&gt;(offset));
3027 
3028         bool useDirect = isInt&lt;19&gt;(offset);
3029         ASSERT(!isDirect || useDirect);
3030 
3031         if (useDirect || isDirect) {
3032             int insn = compareAndBranchImmediate(is64Bit ? Datasize_64 : Datasize_32, condition == ConditionNE, static_cast&lt;int&gt;(offset), rt);
3033             RELEASE_ASSERT(roundUpToMultipleOf&lt;instructionSize&gt;(from) == from);
3034             copy(from, &amp;insn, sizeof(int));
3035             if (!isDirect) {
3036                 insn = nopPseudo();
3037                 RELEASE_ASSERT(roundUpToMultipleOf&lt;instructionSize&gt;(from + 1) == (from + 1));
3038                 copy(from + 1, &amp;insn, sizeof(int));
3039             }
3040         } else {
3041             int insn = compareAndBranchImmediate(is64Bit ? Datasize_64 : Datasize_32, invert(condition) == ConditionNE, 2, rt);
3042             RELEASE_ASSERT(roundUpToMultipleOf&lt;instructionSize&gt;(from) == from);
3043             copy(from, &amp;insn, sizeof(int));
3044             linkJumpOrCall&lt;false&gt;(from + 1, fromInstruction + 1, to, copy);
3045         }
3046     }
3047 
3048     template&lt;bool isDirect&gt;
<span class="line-modified">3049     static void linkConditionalBranch(Condition condition, int* from, const int* fromInstruction, void* to, CopyFunction copy = tagCFunctionPtr&lt;CopyFunctionPtrTag&gt;(performJITMemcpy))</span>
3050     {
3051         ASSERT(!(reinterpret_cast&lt;intptr_t&gt;(from) &amp; 3));
3052         ASSERT(!(reinterpret_cast&lt;intptr_t&gt;(to) &amp; 3));
3053         intptr_t offset = (reinterpret_cast&lt;intptr_t&gt;(to) - reinterpret_cast&lt;intptr_t&gt;(fromInstruction)) &gt;&gt; 2;
3054         ASSERT(isInt&lt;26&gt;(offset));
3055 
3056         bool useDirect = isInt&lt;19&gt;(offset);
3057         ASSERT(!isDirect || useDirect);
3058 
3059         if (useDirect || isDirect) {
3060             int insn = conditionalBranchImmediate(static_cast&lt;int&gt;(offset), condition);
3061             RELEASE_ASSERT(roundUpToMultipleOf&lt;instructionSize&gt;(from) == from);
3062             copy(from, &amp;insn, sizeof(int));
3063             if (!isDirect) {
3064                 insn = nopPseudo();
3065                 RELEASE_ASSERT(roundUpToMultipleOf&lt;instructionSize&gt;(from + 1) == (from + 1));
3066                 copy(from + 1, &amp;insn, sizeof(int));
3067             }
3068         } else {
3069             int insn = conditionalBranchImmediate(2, invert(condition));
3070             RELEASE_ASSERT(roundUpToMultipleOf&lt;instructionSize&gt;(from) == from);
3071             copy(from, &amp;insn, sizeof(int));
3072             linkJumpOrCall&lt;false&gt;(from + 1, fromInstruction + 1, to, copy);
3073         }
3074     }
3075 
3076     template&lt;bool isDirect&gt;
<span class="line-modified">3077     static void linkTestAndBranch(Condition condition, unsigned bitNumber, RegisterID rt, int* from, const int* fromInstruction, void* to, CopyFunction copy = tagCFunctionPtr&lt;CopyFunctionPtrTag&gt;(performJITMemcpy))</span>
3078     {
3079         ASSERT(!(reinterpret_cast&lt;intptr_t&gt;(from) &amp; 3));
3080         ASSERT(!(reinterpret_cast&lt;intptr_t&gt;(to) &amp; 3));
3081         intptr_t offset = (reinterpret_cast&lt;intptr_t&gt;(to) - reinterpret_cast&lt;intptr_t&gt;(fromInstruction)) &gt;&gt; 2;
3082         ASSERT(static_cast&lt;int&gt;(offset) == offset);
3083         ASSERT(isInt&lt;26&gt;(offset));
3084 
3085         bool useDirect = isInt&lt;14&gt;(offset);
3086         ASSERT(!isDirect || useDirect);
3087 
3088         if (useDirect || isDirect) {
3089             int insn = testAndBranchImmediate(condition == ConditionNE, static_cast&lt;int&gt;(bitNumber), static_cast&lt;int&gt;(offset), rt);
3090             RELEASE_ASSERT(roundUpToMultipleOf&lt;instructionSize&gt;(from) == from);
3091             copy(from, &amp;insn, sizeof(int));
3092             if (!isDirect) {
3093                 insn = nopPseudo();
3094                 RELEASE_ASSERT(roundUpToMultipleOf&lt;instructionSize&gt;(from + 1) == (from + 1));
3095                 copy(from + 1, &amp;insn, sizeof(int));
3096             }
3097         } else {
</pre>
</td>
</tr>
</table>
<center><a href="../SourcesWPE.txt.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ARMv7Assembler.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>