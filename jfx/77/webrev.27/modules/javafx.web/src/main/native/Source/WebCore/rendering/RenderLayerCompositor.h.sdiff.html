<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderLayerCompositor.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="RenderLayerCompositor.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="RenderLayerFilters.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderLayerCompositor.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #include &quot;ChromeClient.h&quot;
 29 #include &quot;GraphicsLayerClient.h&quot;
 30 #include &quot;GraphicsLayerUpdater.h&quot;

 31 #include &quot;RenderLayer.h&quot;
 32 #include &lt;wtf/HashMap.h&gt;
 33 #include &lt;wtf/OptionSet.h&gt;
 34 
 35 namespace WebCore {
 36 
 37 class FixedPositionViewportConstraints;
 38 class GraphicsLayer;
 39 class GraphicsLayerUpdater;

 40 class RenderEmbeddedObject;
 41 class RenderVideo;
 42 class RenderWidget;
 43 class ScrollingCoordinator;
 44 class StickyPositionViewportConstraints;
 45 class TiledBacking;
 46 
 47 typedef unsigned LayerTreeFlags;
 48 
 49 enum class CompositingUpdateType {
 50     AfterStyleChange,
 51     AfterLayout,
 52     OnScroll,
 53     OnCompositedScroll
 54 };
 55 
 56 enum class CompositingReason {
 57     Transform3D                            = 1 &lt;&lt; 0,
 58     Video                                  = 1 &lt;&lt; 1,
 59     Canvas                                 = 1 &lt;&lt; 2,
 60     Plugin                                 = 1 &lt;&lt; 3,
 61     IFrame                                 = 1 &lt;&lt; 4,
 62     BackfaceVisibilityHidden               = 1 &lt;&lt; 5,
 63     ClipsCompositingDescendants            = 1 &lt;&lt; 6,
 64     Animation                              = 1 &lt;&lt; 7,
 65     Filters                                = 1 &lt;&lt; 8,
 66     PositionFixed                          = 1 &lt;&lt; 9,
 67     PositionSticky                         = 1 &lt;&lt; 10,
<span class="line-modified"> 68     OverflowScrollingTouch                 = 1 &lt;&lt; 11,</span>
 69     Stacking                               = 1 &lt;&lt; 12,
 70     Overlap                                = 1 &lt;&lt; 13,
<span class="line-modified"> 71     NegativeZIndexChildren                 = 1 &lt;&lt; 14,</span>
<span class="line-modified"> 72     TransformWithCompositedDescendants     = 1 &lt;&lt; 15,</span>
<span class="line-modified"> 73     OpacityWithCompositedDescendants       = 1 &lt;&lt; 16,</span>
<span class="line-modified"> 74     MaskWithCompositedDescendants          = 1 &lt;&lt; 17,</span>
<span class="line-modified"> 75     ReflectionWithCompositedDescendants    = 1 &lt;&lt; 18,</span>
<span class="line-modified"> 76     FilterWithCompositedDescendants        = 1 &lt;&lt; 19,</span>
<span class="line-modified"> 77     BlendingWithCompositedDescendants      = 1 &lt;&lt; 20,</span>
<span class="line-modified"> 78     Perspective                            = 1 &lt;&lt; 21,</span>
<span class="line-modified"> 79     Preserve3D                             = 1 &lt;&lt; 22,</span>
<span class="line-modified"> 80     WillChange                             = 1 &lt;&lt; 23,</span>
<span class="line-modified"> 81     Root                                   = 1 &lt;&lt; 24,</span>
<span class="line-modified"> 82     IsolatesCompositedBlendingDescendants  = 1 &lt;&lt; 25,</span>
<span class="line-modified"> 83     EmbeddedView                           = 1 &lt;&lt; 26,</span>

 84 };
 85 
 86 enum class ScrollCoordinationRole {
 87     ViewportConstrained = 1 &lt;&lt; 0,
 88     Scrolling           = 1 &lt;&lt; 1,
<span class="line-modified"> 89     FrameHosting        = 1 &lt;&lt; 2,</span>


 90 };
 91 











 92 #if PLATFORM(IOS_FAMILY)
 93 class LegacyWebKitScrollingLayerCoordinator {

 94 public:
 95     LegacyWebKitScrollingLayerCoordinator(ChromeClient&amp; chromeClient, bool coordinateViewportConstrainedLayers)
 96         : m_chromeClient(chromeClient)
 97         , m_coordinateViewportConstrainedLayers(coordinateViewportConstrainedLayers)
 98     {
 99     }
100 
101     void registerAllViewportConstrainedLayers(RenderLayerCompositor&amp;);
102     void unregisterAllViewportConstrainedLayers();
103 
104     void registerAllScrollingLayers();
<span class="line-removed">105     void registerScrollingLayersNeedingUpdate();</span>
106     void unregisterAllScrollingLayers();
107 
108     void addScrollingLayer(RenderLayer&amp;);
109     void removeScrollingLayer(RenderLayer&amp;, RenderLayerBacking&amp;);
110 
111     void addViewportConstrainedLayer(RenderLayer&amp;);
112     void removeViewportConstrainedLayer(RenderLayer&amp;);
113 
<span class="line-removed">114     void didChangePlatformLayerForLayer(RenderLayer&amp;);</span>
<span class="line-removed">115 </span>
116     void removeLayer(RenderLayer&amp;);
117 
118 private:
119     void updateScrollingLayer(RenderLayer&amp;);
120 
121     ChromeClient&amp; m_chromeClient;
122 
123     HashSet&lt;RenderLayer*&gt; m_scrollingLayers;
124     HashSet&lt;RenderLayer*&gt; m_viewportConstrainedLayers;
125 
<span class="line-removed">126     HashSet&lt;RenderLayer*&gt; m_scrollingLayersNeedingUpdate;</span>
127     const bool m_coordinateViewportConstrainedLayers;
128 };
129 #endif
130 
131 // RenderLayerCompositor manages the hierarchy of
132 // composited RenderLayers. It determines which RenderLayers
133 // become compositing, and creates and maintains a hierarchy of
134 // GraphicsLayers based on the RenderLayer painting order.
135 //
136 // There is one RenderLayerCompositor per RenderView.
137 
138 class RenderLayerCompositor final : public GraphicsLayerClient, public GraphicsLayerUpdaterClient {
139     WTF_MAKE_FAST_ALLOCATED;
140     friend class LegacyWebKitScrollingLayerCoordinator;
141 public:
142     explicit RenderLayerCompositor(RenderView&amp;);
143     virtual ~RenderLayerCompositor();
144 
145     // Return true if this RenderView is in &quot;compositing mode&quot; (i.e. has one or more
146     // composited RenderLayers)
</pre>
<hr />
<pre>
149     // the native view/window system.
150     void enableCompositingMode(bool enable = true);
151 
152     bool inForcedCompositingMode() const { return m_forceCompositingMode; }
153 
154     // True when some content element other than the root is composited.
155     bool hasContentCompositingLayers() const { return m_contentLayersCount; }
156 
157     // Returns true if the accelerated compositing is enabled
158     bool hasAcceleratedCompositing() const { return m_hasAcceleratedCompositing; }
159 
160     bool canRender3DTransforms() const;
161 
162     void willRecalcStyle();
163 
164     // Returns true if the composited layers were actually updated.
165     bool didRecalcStyleWithNoPendingLayout();
166 
167     // GraphicsLayers buffer state, which gets pushed to the underlying platform layers
168     // at specific times.
<span class="line-modified">169     void scheduleLayerFlush(bool canThrottle);</span>
170     void flushPendingLayerChanges(bool isFlushRoot = true);
171 
172     // Called when the GraphicsLayer for the given RenderLayer has flushed changes inside of flushPendingLayerChanges().
173     void didChangePlatformLayerForLayer(RenderLayer&amp;, const GraphicsLayer*);
174 
175     // Called when something outside WebKit affects the visible rect (e.g. delegated scrolling). Might schedule a layer flush.
176     void didChangeVisibleRect();
177 
178     // Rebuild the tree of compositing layers
179     bool updateCompositingLayers(CompositingUpdateType, RenderLayer* updateRoot = nullptr);
180     // This is only used when state changes and we do not exepect a style update or layout to happen soon (e.g. when
181     // we discover that an iframe is overlapped during painting).
182     void scheduleCompositingLayerUpdate();
183     // This is used to cancel any pending update timers when the document goes into page cache.
184     void cancelCompositingLayerUpdate();
185 
186     // Update the compositing state of the given layer. Returns true if that state changed.
187     enum CompositingChangeRepaint { CompositingChangeRepaintNow, CompositingChangeWillRepaintLater };
188     enum class LayoutUpToDate {
189         Yes, No
190     };
191 
192     struct RequiresCompositingData {
193         LayoutUpToDate layoutUpToDate { LayoutUpToDate::Yes };
194         RenderLayer::ViewportConstrainedNotCompositedReason nonCompositedForPositionReason { RenderLayer::NoNotCompositedReason };
195         bool reevaluateAfterLayout { false };
196     };
197 
198     bool updateLayerCompositingState(RenderLayer&amp;, RequiresCompositingData&amp;, CompositingChangeRepaint = CompositingChangeRepaintNow);
199 
200     // Whether layer&#39;s backing needs a graphics layer to do clipping by an ancestor (non-stacking-context parent with overflow).
<span class="line-modified">201     bool clippedByAncestor(RenderLayer&amp;) const;</span>







202     // Whether layer&#39;s backing needs a graphics layer to clip z-order children of the given layer.
<span class="line-modified">203     bool clipsCompositingDescendants(const RenderLayer&amp;) const;</span>
204 
205     // Whether the given layer needs an extra &#39;contents&#39; layer.
206     bool needsContentsCompositingLayer(const RenderLayer&amp;) const;
207 
208     bool fixedLayerIntersectsViewport(const RenderLayer&amp;) const;
209 
210     bool supportsFixedRootBackgroundCompositing() const;
211     bool needsFixedRootBackgroundLayer(const RenderLayer&amp;) const;
212     GraphicsLayer* fixedRootBackgroundLayer() const;
213 
214     void rootOrBodyStyleChanged(RenderElement&amp;, const RenderStyle* oldStyle);
215 
216     // Called after the view transparency, or the document or base background color change.
217     void rootBackgroundColorOrTransparencyChanged();
218 
219     // Repaint the appropriate layers when the given RenderLayer starts or stops being composited.
220     void repaintOnCompositingChange(RenderLayer&amp;);
221 
222     void repaintInCompositedAncestor(RenderLayer&amp;, const LayoutRect&amp;);
223 
</pre>
<hr />
<pre>
274     // Use by RenderVideo to ask if it should try to use accelerated compositing.
275     bool canAccelerateVideoRendering(RenderVideo&amp;) const;
276 #endif
277 
278     // Walk the tree looking for layers with 3d transforms. Useful in case you need
279     // to know if there is non-affine content, e.g. for drawing into an image.
280     bool has3DContent() const;
281 
282     static RenderLayerCompositor* frameContentsCompositor(RenderWidget&amp;);
283     // Return true if the layers changed.
284     bool parentFrameContentLayers(RenderWidget&amp;);
285 
286     // Update the geometry of the layers used for clipping and scrolling in frames.
287     void frameViewDidChangeLocation(const IntPoint&amp; contentsOffset);
288     void frameViewDidChangeSize();
289     void frameViewDidScroll();
290     void frameViewDidAddOrRemoveScrollbars();
291     void frameViewDidLayout();
292     void rootLayerConfigurationChanged();
293 


294     String layerTreeAsText(LayerTreeFlags);
295 
296     float deviceScaleFactor() const override;
297     float contentsScaleMultiplierForNewTiles(const GraphicsLayer*) const override;
298     float pageScaleFactor() const override;
299     float zoomedOutPageScaleFactor() const override;
300     void didChangePlatformLayerForLayer(const GraphicsLayer*) override { }
301     void notifyFlushBeforeDisplayRefresh(const GraphicsLayer*) override;
302 
303     void layerTiledBackingUsageChanged(const GraphicsLayer*, bool /*usingTiledBacking*/);
304 
305     bool acceleratedDrawingEnabled() const { return m_acceleratedDrawingEnabled; }
306     bool displayListDrawingEnabled() const { return m_displayListDrawingEnabled; }
307 
308     void deviceOrPageScaleFactorChanged();
309 
310     void windowScreenDidChange(PlatformDisplayID);
311 
312     GraphicsLayer* layerForHorizontalScrollbar() const { return m_layerForHorizontalScrollbar.get(); }
313     GraphicsLayer* layerForVerticalScrollbar() const { return m_layerForVerticalScrollbar.get(); }
314     GraphicsLayer* layerForScrollCorner() const { return m_layerForScrollCorner.get(); }
315 #if ENABLE(RUBBER_BANDING)
316     GraphicsLayer* layerForOverhangAreas() const { return m_layerForOverhangAreas.get(); }
317     GraphicsLayer* layerForContentShadow() const { return m_contentShadowLayer.get(); }
318 
319     GraphicsLayer* updateLayerForTopOverhangArea(bool wantsLayer);
320     GraphicsLayer* updateLayerForBottomOverhangArea(bool wantsLayer);
321     GraphicsLayer* updateLayerForHeader(bool wantsLayer);
322     GraphicsLayer* updateLayerForFooter(bool wantsLayer);
323 #endif
324 
325     // FIXME: make the coordinated/async terminology consistent.
326     bool isViewportConstrainedFixedOrStickyLayer(const RenderLayer&amp;) const;
327     bool useCoordinatedScrollingForLayer(const RenderLayer&amp;) const;

328     bool isLayerForIFrameWithScrollCoordinatedContents(const RenderLayer&amp;) const;
329 
330     ScrollableArea* scrollableAreaForScrollLayerID(ScrollingNodeID) const;
331 
332     void removeFromScrollCoordinatedLayers(RenderLayer&amp;);
333 
334     void willRemoveScrollingLayerWithBacking(RenderLayer&amp;, RenderLayerBacking&amp;);
335     void didAddScrollingLayer(RenderLayer&amp;);
336 
337     void resetTrackedRepaintRects();
338     void setTracksRepaints(bool tracksRepaints) { m_isTrackingRepaints = tracksRepaints; }
339 
340     bool viewHasTransparentBackground(Color* backgroundColor = nullptr) const;
341 
342     bool hasNonMainLayersWithTiledBacking() const { return m_layersWithTiledBackingCount; }
343 
344     OptionSet&lt;CompositingReason&gt; reasonsForCompositing(const RenderLayer&amp;) const;
345 
346     void setLayerFlushThrottlingEnabled(bool);
347     void disableLayerFlushThrottlingTemporarilyForInteraction();
348 
349     void didPaintBacking(RenderLayerBacking*);
350 
351     const Color&amp; rootExtendedBackgroundColor() const { return m_rootExtendedBackgroundColor; }
352 
353     void updateRootContentLayerClipping();
354 
355 #if ENABLE(CSS_SCROLL_SNAP)
356     void updateScrollSnapPropertiesWithFrameView(const FrameView&amp;) const;
357 #endif
358 
359     // For testing.
360     void startTrackingLayerFlushes() { m_layerFlushCount = 0; }
361     unsigned layerFlushCount() const { return m_layerFlushCount; }
362 
363     void startTrackingCompositingUpdates() { m_compositingUpdateCount = 0; }
364     unsigned compositingUpdateCount() const { return m_compositingUpdateCount; }
365 
366 private:
<span class="line-modified">367     class OverlapMap;</span>
368     struct CompositingState;
369     struct OverlapExtent;
370 
371     // Returns true if the policy changed.
372     bool updateCompositingPolicy();
373 
374     // GraphicsLayerClient implementation
375     void notifyFlushRequired(const GraphicsLayer*) override;
<span class="line-modified">376     void paintContents(const GraphicsLayer*, GraphicsContext&amp;, GraphicsLayerPaintingPhase, const FloatRect&amp;, GraphicsLayerPaintBehavior) override;</span>
377     void customPositionForVisibleRectComputation(const GraphicsLayer*, FloatPoint&amp;) const override;
378     bool isTrackingRepaints() const override { return m_isTrackingRepaints; }
379 
380     // GraphicsLayerUpdaterClient implementation
381     void flushLayersSoon(GraphicsLayerUpdater&amp;) override;
382 
383     // Copy the accelerated compositing related flags from Settings
384     void cacheAcceleratedCompositingFlags();
385     void cacheAcceleratedCompositingFlagsAfterLayout();
386 
387     // Whether the given RL needs a compositing layer.
388     bool needsToBeComposited(const RenderLayer&amp;, RequiresCompositingData&amp;) const;
389     // Whether the layer has an intrinsic need for compositing layer.
390     bool requiresCompositingLayer(const RenderLayer&amp;, RequiresCompositingData&amp;) const;
391     // Whether the layer could ever be composited.
392     bool canBeComposited(const RenderLayer&amp;) const;
393     bool needsCompositingUpdateForStyleChangeOnNonCompositedLayer(RenderLayer&amp;, const RenderStyle* oldStyle) const;
394 
395     // Make or destroy the backing for this layer; returns true if backing changed.
396     enum class BackingRequired { No, Yes, Unknown };
397     bool updateBacking(RenderLayer&amp;, RequiresCompositingData&amp;, CompositingChangeRepaint shouldRepaint, BackingRequired = BackingRequired::Unknown);
398 
399     void clearBackingForLayerIncludingDescendants(RenderLayer&amp;);
400 
401     // Repaint this and its child layers.
402     void recursiveRepaintLayer(RenderLayer&amp;);
403 
<span class="line-modified">404     void computeExtent(const OverlapMap&amp;, const RenderLayer&amp;, OverlapExtent&amp;) const;</span>
<span class="line-modified">405     void addToOverlapMap(OverlapMap&amp;, const RenderLayer&amp;, OverlapExtent&amp;);</span>
<span class="line-modified">406     void addToOverlapMapRecursive(OverlapMap&amp;, const RenderLayer&amp;, const RenderLayer* ancestorLayer = nullptr);</span>


407 
408     void updateCompositingLayersTimerFired();
409 
<span class="line-modified">410     void computeCompositingRequirements(RenderLayer* ancestorLayer, RenderLayer&amp;, OverlapMap&amp;, CompositingState&amp;, bool&amp; descendantHas3DTransform);</span>
<span class="line-modified">411     void traverseUnchangedSubtree(RenderLayer* ancestorLayer, RenderLayer&amp;, OverlapMap&amp;, CompositingState&amp;, bool&amp; descendantHas3DTransform);</span>
412 
413     enum class UpdateLevel {
414         AllDescendants          = 1 &lt;&lt; 0,
415         CompositedChildren      = 1 &lt;&lt; 1,
416     };
417     // Recurses down the tree, parenting descendant compositing layers and collecting an array of child layers for the current compositing layer.
418     void updateBackingAndHierarchy(RenderLayer&amp;, Vector&lt;Ref&lt;GraphicsLayer&gt;&gt;&amp; childGraphicsLayersOfEnclosingLayer, struct ScrollingTreeState&amp;, OptionSet&lt;UpdateLevel&gt; = { }, int depth = 0);
419 
420     bool layerHas3DContent(const RenderLayer&amp;) const;
421     bool isRunningTransformAnimation(RenderLayerModelObject&amp;) const;
422 
423     void appendDocumentOverlayLayers(Vector&lt;Ref&lt;GraphicsLayer&gt;&gt;&amp;);
424 
425     bool needsCompositingForContentOrOverlays() const;
426 
427     void ensureRootLayer();
428     void destroyRootLayer();
429 
430     void attachRootLayer(RootLayerAttachment);
431     void detachRootLayer();
</pre>
<hr />
<pre>
456 #if USE(REQUEST_ANIMATION_FRAME_DISPLAY_MONITOR)
457     RefPtr&lt;DisplayRefreshMonitor&gt; createDisplayRefreshMonitor(PlatformDisplayID) const override;
458 #endif
459 
460     // Non layout-dependent
461     bool requiresCompositingForAnimation(RenderLayerModelObject&amp;) const;
462     bool requiresCompositingForTransform(RenderLayerModelObject&amp;) const;
463     bool requiresCompositingForBackfaceVisibility(RenderLayerModelObject&amp;) const;
464     bool requiresCompositingForVideo(RenderLayerModelObject&amp;) const;
465     bool requiresCompositingForCanvas(RenderLayerModelObject&amp;) const;
466     bool requiresCompositingForFilters(RenderLayerModelObject&amp;) const;
467     bool requiresCompositingForWillChange(RenderLayerModelObject&amp;) const;
468 
469     // Layout-dependent
470     bool requiresCompositingForPlugin(RenderLayerModelObject&amp;, RequiresCompositingData&amp;) const;
471     bool requiresCompositingForFrame(RenderLayerModelObject&amp;, RequiresCompositingData&amp;) const;
472     bool requiresCompositingForScrollableFrame(RequiresCompositingData&amp;) const;
473     bool requiresCompositingForPosition(RenderLayerModelObject&amp;, const RenderLayer&amp;, RequiresCompositingData&amp;) const;
474     bool requiresCompositingForOverflowScrolling(const RenderLayer&amp;, RequiresCompositingData&amp;) const;
475     bool requiresCompositingForEditableImage(RenderLayerModelObject&amp;) const;
<span class="line-modified">476     bool requiresCompositingForIndirectReason(RenderLayerModelObject&amp;, bool hasCompositedDescendants, bool has3DTransformedDescendants, RenderLayer::IndirectCompositingReason&amp;) const;</span>


477 
478     static bool styleChangeMayAffectIndirectCompositingReasons(const RenderStyle&amp; oldStyle, const RenderStyle&amp; newStyle);
479 
480     enum class ScrollingNodeChangeFlags {
481         Layer           = 1 &lt;&lt; 0,
482         LayerGeometry   = 1 &lt;&lt; 1,
483     };
484 
485     ScrollingNodeID attachScrollingNode(RenderLayer&amp;, ScrollingNodeType, struct ScrollingTreeState&amp;);



486 
487     // Returns the ScrollingNodeID which acts as the parent for children.
<span class="line-modified">488     ScrollingNodeID updateScrollCoordinationForLayer(RenderLayer&amp;, struct ScrollingTreeState&amp;, OptionSet&lt;ScrollCoordinationRole&gt;, OptionSet&lt;ScrollingNodeChangeFlags&gt;);</span>
489 
490     // These return the ScrollingNodeID which acts as the parent for children.
491     ScrollingNodeID updateScrollingNodeForViewportConstrainedRole(RenderLayer&amp;, struct ScrollingTreeState&amp;, OptionSet&lt;ScrollingNodeChangeFlags&gt;);
492     ScrollingNodeID updateScrollingNodeForScrollingRole(RenderLayer&amp;, struct ScrollingTreeState&amp;, OptionSet&lt;ScrollingNodeChangeFlags&gt;);

493     ScrollingNodeID updateScrollingNodeForFrameHostingRole(RenderLayer&amp;, struct ScrollingTreeState&amp;, OptionSet&lt;ScrollingNodeChangeFlags&gt;);



494 
495     void detachScrollCoordinatedLayer(RenderLayer&amp;, OptionSet&lt;ScrollCoordinationRole&gt;);
496     void detachScrollCoordinatedLayerWithRole(RenderLayer&amp;, ScrollingCoordinator&amp;, ScrollCoordinationRole);
497 
498     FixedPositionViewportConstraints computeFixedViewportConstraints(RenderLayer&amp;) const;
499     StickyPositionViewportConstraints computeStickyViewportConstraints(RenderLayer&amp;) const;
500 
<span class="line-modified">501     void computeFrameScrollingGeometry(ScrollingCoordinator::ScrollingGeometry&amp;) const;</span>
<span class="line-modified">502     void computeFrameHostingGeometry(const RenderLayer&amp;, const RenderLayer* ancestorLayer, ScrollingCoordinator::ScrollingGeometry&amp;) const;</span>
<span class="line-modified">503     void computeOverflowScrollingGeometry(const RenderLayer&amp;, const RenderLayer* ancestorLayer, ScrollingCoordinator::ScrollingGeometry&amp;) const;</span>



504 
505     bool requiresScrollLayer(RootLayerAttachment) const;
506     bool requiresHorizontalScrollbarLayer() const;
507     bool requiresVerticalScrollbarLayer() const;
508     bool requiresScrollCornerLayer() const;
509 #if ENABLE(RUBBER_BANDING)
510     bool requiresOverhangAreasLayer() const;
511     bool requiresContentShadowLayer() const;
512 #endif
513 
514     // True if the FrameView uses a ScrollingCoordinator.
515     bool hasCoordinatedScrolling() const;
516 
517     // FIXME: make the coordinated/async terminology consistent.
518     bool isAsyncScrollableStickyLayer(const RenderLayer&amp;, const RenderLayer** enclosingAcceleratedOverflowLayer = nullptr) const;
519 
520     bool shouldCompositeOverflowControls() const;
521 
<span class="line-removed">522     void scheduleLayerFlushNow();</span>
523     bool isThrottlingLayerFlushes() const;
524     void startInitialLayerFlushTimerIfNeeded();
525     void startLayerFlushTimerIfNeeded();
526     void layerFlushTimerFired();
527 
528 #if !LOG_DISABLED
529     const char* logReasonsForCompositing(const RenderLayer&amp;);
530     void logLayerInfo(const RenderLayer&amp;, const char*, int depth);
531 #endif
532 
533     bool documentUsesTiledBacking() const;
534     bool isMainFrameCompositor() const;
535 
536 private:
537     RenderView&amp; m_renderView;
<span class="line-removed">538     RefPtr&lt;GraphicsLayer&gt; m_rootContentsLayer;</span>
539     Timer m_updateCompositingLayersTimer;
540 
541     ChromeClient::CompositingTriggerFlags m_compositingTriggers { static_cast&lt;ChromeClient::CompositingTriggerFlags&gt;(ChromeClient::AllTriggers) };
542     bool m_hasAcceleratedCompositing { true };
543 
544     CompositingPolicy m_compositingPolicy { CompositingPolicy::Normal };
545 
546     bool m_showDebugBorders { false };
547     bool m_showRepaintCounter { false };
548     bool m_acceleratedDrawingEnabled { false };
549     bool m_displayListDrawingEnabled { false };
550 
551     bool m_compositing { false };
552     bool m_flushingLayers { false };
553     bool m_shouldFlushOnReattach { false };
554     bool m_forceCompositingMode { false };
555     bool m_inPostLayoutUpdate { false }; // true when it&#39;s OK to trust layout information (e.g. layer sizes and positions)
556 
557     bool m_isTrackingRepaints { false }; // Used for testing.
558 
559     unsigned m_contentLayersCount { 0 };
560     unsigned m_layersWithTiledBackingCount { 0 };
561     unsigned m_layerFlushCount { 0 };
562     unsigned m_compositingUpdateCount { 0 };
563 
564     RootLayerAttachment m_rootLayerAttachment { RootLayerUnattached };
565 


566     // Enclosing clipping layer for iframe content
567     RefPtr&lt;GraphicsLayer&gt; m_clipLayer;
568     RefPtr&lt;GraphicsLayer&gt; m_scrollContainerLayer;
569     RefPtr&lt;GraphicsLayer&gt; m_scrolledContentsLayer;
570 
571     // Enclosing layer for overflow controls and the clipping layer
572     RefPtr&lt;GraphicsLayer&gt; m_overflowControlsHostLayer;
573 
574     // Layers for overflow controls
575     RefPtr&lt;GraphicsLayer&gt; m_layerForHorizontalScrollbar;
576     RefPtr&lt;GraphicsLayer&gt; m_layerForVerticalScrollbar;
577     RefPtr&lt;GraphicsLayer&gt; m_layerForScrollCorner;
578 #if ENABLE(RUBBER_BANDING)
579     RefPtr&lt;GraphicsLayer&gt; m_layerForOverhangAreas;
580     RefPtr&lt;GraphicsLayer&gt; m_contentShadowLayer;
581     RefPtr&lt;GraphicsLayer&gt; m_layerForTopOverhangArea;
582     RefPtr&lt;GraphicsLayer&gt; m_layerForBottomOverhangArea;
583     RefPtr&lt;GraphicsLayer&gt; m_layerForHeader;
584     RefPtr&lt;GraphicsLayer&gt; m_layerForFooter;
585 #endif
</pre>
</td>
<td>
<hr />
<pre>
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #include &quot;ChromeClient.h&quot;
 29 #include &quot;GraphicsLayerClient.h&quot;
 30 #include &quot;GraphicsLayerUpdater.h&quot;
<span class="line-added"> 31 #include &quot;LayerAncestorClippingStack.h&quot;</span>
 32 #include &quot;RenderLayer.h&quot;
 33 #include &lt;wtf/HashMap.h&gt;
 34 #include &lt;wtf/OptionSet.h&gt;
 35 
 36 namespace WebCore {
 37 
 38 class FixedPositionViewportConstraints;
 39 class GraphicsLayer;
 40 class GraphicsLayerUpdater;
<span class="line-added"> 41 class LayerOverlapMap;</span>
 42 class RenderEmbeddedObject;
 43 class RenderVideo;
 44 class RenderWidget;
 45 class ScrollingCoordinator;
 46 class StickyPositionViewportConstraints;
 47 class TiledBacking;
 48 
 49 typedef unsigned LayerTreeFlags;
 50 
 51 enum class CompositingUpdateType {
 52     AfterStyleChange,
 53     AfterLayout,
 54     OnScroll,
 55     OnCompositedScroll
 56 };
 57 
 58 enum class CompositingReason {
 59     Transform3D                            = 1 &lt;&lt; 0,
 60     Video                                  = 1 &lt;&lt; 1,
 61     Canvas                                 = 1 &lt;&lt; 2,
 62     Plugin                                 = 1 &lt;&lt; 3,
 63     IFrame                                 = 1 &lt;&lt; 4,
 64     BackfaceVisibilityHidden               = 1 &lt;&lt; 5,
 65     ClipsCompositingDescendants            = 1 &lt;&lt; 6,
 66     Animation                              = 1 &lt;&lt; 7,
 67     Filters                                = 1 &lt;&lt; 8,
 68     PositionFixed                          = 1 &lt;&lt; 9,
 69     PositionSticky                         = 1 &lt;&lt; 10,
<span class="line-modified"> 70     OverflowScrolling                      = 1 &lt;&lt; 11,</span>
 71     Stacking                               = 1 &lt;&lt; 12,
 72     Overlap                                = 1 &lt;&lt; 13,
<span class="line-modified"> 73     OverflowScrollPositioning              = 1 &lt;&lt; 14,</span>
<span class="line-modified"> 74     NegativeZIndexChildren                 = 1 &lt;&lt; 15,</span>
<span class="line-modified"> 75     TransformWithCompositedDescendants     = 1 &lt;&lt; 16,</span>
<span class="line-modified"> 76     OpacityWithCompositedDescendants       = 1 &lt;&lt; 17,</span>
<span class="line-modified"> 77     MaskWithCompositedDescendants          = 1 &lt;&lt; 18,</span>
<span class="line-modified"> 78     ReflectionWithCompositedDescendants    = 1 &lt;&lt; 19,</span>
<span class="line-modified"> 79     FilterWithCompositedDescendants        = 1 &lt;&lt; 20,</span>
<span class="line-modified"> 80     BlendingWithCompositedDescendants      = 1 &lt;&lt; 21,</span>
<span class="line-modified"> 81     Perspective                            = 1 &lt;&lt; 22,</span>
<span class="line-modified"> 82     Preserve3D                             = 1 &lt;&lt; 23,</span>
<span class="line-modified"> 83     WillChange                             = 1 &lt;&lt; 24,</span>
<span class="line-modified"> 84     Root                                   = 1 &lt;&lt; 25,</span>
<span class="line-modified"> 85     IsolatesCompositedBlendingDescendants  = 1 &lt;&lt; 26,</span>
<span class="line-added"> 86     EmbeddedView                           = 1 &lt;&lt; 27,</span>
 87 };
 88 
 89 enum class ScrollCoordinationRole {
 90     ViewportConstrained = 1 &lt;&lt; 0,
 91     Scrolling           = 1 &lt;&lt; 1,
<span class="line-modified"> 92     ScrollingProxy      = 1 &lt;&lt; 2,</span>
<span class="line-added"> 93     FrameHosting        = 1 &lt;&lt; 3,</span>
<span class="line-added"> 94     Positioning         = 1 &lt;&lt; 4,</span>
 95 };
 96 
<span class="line-added"> 97 static constexpr OptionSet&lt;ScrollCoordinationRole&gt; allScrollCoordinationRoles()</span>
<span class="line-added"> 98 {</span>
<span class="line-added"> 99     return {</span>
<span class="line-added">100         ScrollCoordinationRole::Scrolling,</span>
<span class="line-added">101         ScrollCoordinationRole::ScrollingProxy,</span>
<span class="line-added">102         ScrollCoordinationRole::ViewportConstrained,</span>
<span class="line-added">103         ScrollCoordinationRole::FrameHosting,</span>
<span class="line-added">104         ScrollCoordinationRole::Positioning</span>
<span class="line-added">105     };</span>
<span class="line-added">106 }</span>
<span class="line-added">107 </span>
108 #if PLATFORM(IOS_FAMILY)
109 class LegacyWebKitScrollingLayerCoordinator {
<span class="line-added">110     WTF_MAKE_FAST_ALLOCATED;</span>
111 public:
112     LegacyWebKitScrollingLayerCoordinator(ChromeClient&amp; chromeClient, bool coordinateViewportConstrainedLayers)
113         : m_chromeClient(chromeClient)
114         , m_coordinateViewportConstrainedLayers(coordinateViewportConstrainedLayers)
115     {
116     }
117 
118     void registerAllViewportConstrainedLayers(RenderLayerCompositor&amp;);
119     void unregisterAllViewportConstrainedLayers();
120 
121     void registerAllScrollingLayers();

122     void unregisterAllScrollingLayers();
123 
124     void addScrollingLayer(RenderLayer&amp;);
125     void removeScrollingLayer(RenderLayer&amp;, RenderLayerBacking&amp;);
126 
127     void addViewportConstrainedLayer(RenderLayer&amp;);
128     void removeViewportConstrainedLayer(RenderLayer&amp;);
129 


130     void removeLayer(RenderLayer&amp;);
131 
132 private:
133     void updateScrollingLayer(RenderLayer&amp;);
134 
135     ChromeClient&amp; m_chromeClient;
136 
137     HashSet&lt;RenderLayer*&gt; m_scrollingLayers;
138     HashSet&lt;RenderLayer*&gt; m_viewportConstrainedLayers;
139 

140     const bool m_coordinateViewportConstrainedLayers;
141 };
142 #endif
143 
144 // RenderLayerCompositor manages the hierarchy of
145 // composited RenderLayers. It determines which RenderLayers
146 // become compositing, and creates and maintains a hierarchy of
147 // GraphicsLayers based on the RenderLayer painting order.
148 //
149 // There is one RenderLayerCompositor per RenderView.
150 
151 class RenderLayerCompositor final : public GraphicsLayerClient, public GraphicsLayerUpdaterClient {
152     WTF_MAKE_FAST_ALLOCATED;
153     friend class LegacyWebKitScrollingLayerCoordinator;
154 public:
155     explicit RenderLayerCompositor(RenderView&amp;);
156     virtual ~RenderLayerCompositor();
157 
158     // Return true if this RenderView is in &quot;compositing mode&quot; (i.e. has one or more
159     // composited RenderLayers)
</pre>
<hr />
<pre>
162     // the native view/window system.
163     void enableCompositingMode(bool enable = true);
164 
165     bool inForcedCompositingMode() const { return m_forceCompositingMode; }
166 
167     // True when some content element other than the root is composited.
168     bool hasContentCompositingLayers() const { return m_contentLayersCount; }
169 
170     // Returns true if the accelerated compositing is enabled
171     bool hasAcceleratedCompositing() const { return m_hasAcceleratedCompositing; }
172 
173     bool canRender3DTransforms() const;
174 
175     void willRecalcStyle();
176 
177     // Returns true if the composited layers were actually updated.
178     bool didRecalcStyleWithNoPendingLayout();
179 
180     // GraphicsLayers buffer state, which gets pushed to the underlying platform layers
181     // at specific times.
<span class="line-modified">182     void scheduleLayerFlush(bool canThrottle = false);</span>
183     void flushPendingLayerChanges(bool isFlushRoot = true);
184 
185     // Called when the GraphicsLayer for the given RenderLayer has flushed changes inside of flushPendingLayerChanges().
186     void didChangePlatformLayerForLayer(RenderLayer&amp;, const GraphicsLayer*);
187 
188     // Called when something outside WebKit affects the visible rect (e.g. delegated scrolling). Might schedule a layer flush.
189     void didChangeVisibleRect();
190 
191     // Rebuild the tree of compositing layers
192     bool updateCompositingLayers(CompositingUpdateType, RenderLayer* updateRoot = nullptr);
193     // This is only used when state changes and we do not exepect a style update or layout to happen soon (e.g. when
194     // we discover that an iframe is overlapped during painting).
195     void scheduleCompositingLayerUpdate();
196     // This is used to cancel any pending update timers when the document goes into page cache.
197     void cancelCompositingLayerUpdate();
198 
199     // Update the compositing state of the given layer. Returns true if that state changed.
200     enum CompositingChangeRepaint { CompositingChangeRepaintNow, CompositingChangeWillRepaintLater };
201     enum class LayoutUpToDate {
202         Yes, No
203     };
204 
205     struct RequiresCompositingData {
206         LayoutUpToDate layoutUpToDate { LayoutUpToDate::Yes };
207         RenderLayer::ViewportConstrainedNotCompositedReason nonCompositedForPositionReason { RenderLayer::NoNotCompositedReason };
208         bool reevaluateAfterLayout { false };
209     };
210 
211     bool updateLayerCompositingState(RenderLayer&amp;, RequiresCompositingData&amp;, CompositingChangeRepaint = CompositingChangeRepaintNow);
212 
213     // Whether layer&#39;s backing needs a graphics layer to do clipping by an ancestor (non-stacking-context parent with overflow).
<span class="line-modified">214     bool clippedByAncestor(RenderLayer&amp;, const RenderLayer* compositingAncestor) const;</span>
<span class="line-added">215 </span>
<span class="line-added">216     bool updateAncestorClippingStack(const RenderLayer&amp;, const RenderLayer* compositingAncestor) const;</span>
<span class="line-added">217 </span>
<span class="line-added">218     // Returns the ScrollingNodeID for the containing async-scrollable layer that scrolls this renderer&#39;s border box.</span>
<span class="line-added">219     // May return 0 for position-fixed content.</span>
<span class="line-added">220     static ScrollingNodeID asyncScrollableContainerNodeID(const RenderObject&amp;);</span>
<span class="line-added">221 </span>
222     // Whether layer&#39;s backing needs a graphics layer to clip z-order children of the given layer.
<span class="line-modified">223     static bool clipsCompositingDescendants(const RenderLayer&amp;);</span>
224 
225     // Whether the given layer needs an extra &#39;contents&#39; layer.
226     bool needsContentsCompositingLayer(const RenderLayer&amp;) const;
227 
228     bool fixedLayerIntersectsViewport(const RenderLayer&amp;) const;
229 
230     bool supportsFixedRootBackgroundCompositing() const;
231     bool needsFixedRootBackgroundLayer(const RenderLayer&amp;) const;
232     GraphicsLayer* fixedRootBackgroundLayer() const;
233 
234     void rootOrBodyStyleChanged(RenderElement&amp;, const RenderStyle* oldStyle);
235 
236     // Called after the view transparency, or the document or base background color change.
237     void rootBackgroundColorOrTransparencyChanged();
238 
239     // Repaint the appropriate layers when the given RenderLayer starts or stops being composited.
240     void repaintOnCompositingChange(RenderLayer&amp;);
241 
242     void repaintInCompositedAncestor(RenderLayer&amp;, const LayoutRect&amp;);
243 
</pre>
<hr />
<pre>
294     // Use by RenderVideo to ask if it should try to use accelerated compositing.
295     bool canAccelerateVideoRendering(RenderVideo&amp;) const;
296 #endif
297 
298     // Walk the tree looking for layers with 3d transforms. Useful in case you need
299     // to know if there is non-affine content, e.g. for drawing into an image.
300     bool has3DContent() const;
301 
302     static RenderLayerCompositor* frameContentsCompositor(RenderWidget&amp;);
303     // Return true if the layers changed.
304     bool parentFrameContentLayers(RenderWidget&amp;);
305 
306     // Update the geometry of the layers used for clipping and scrolling in frames.
307     void frameViewDidChangeLocation(const IntPoint&amp; contentsOffset);
308     void frameViewDidChangeSize();
309     void frameViewDidScroll();
310     void frameViewDidAddOrRemoveScrollbars();
311     void frameViewDidLayout();
312     void rootLayerConfigurationChanged();
313 
<span class="line-added">314     void widgetDidChangeSize(RenderWidget&amp;);</span>
<span class="line-added">315 </span>
316     String layerTreeAsText(LayerTreeFlags);
317 
318     float deviceScaleFactor() const override;
319     float contentsScaleMultiplierForNewTiles(const GraphicsLayer*) const override;
320     float pageScaleFactor() const override;
321     float zoomedOutPageScaleFactor() const override;
322     void didChangePlatformLayerForLayer(const GraphicsLayer*) override { }
323     void notifyFlushBeforeDisplayRefresh(const GraphicsLayer*) override;
324 
325     void layerTiledBackingUsageChanged(const GraphicsLayer*, bool /*usingTiledBacking*/);
326 
327     bool acceleratedDrawingEnabled() const { return m_acceleratedDrawingEnabled; }
328     bool displayListDrawingEnabled() const { return m_displayListDrawingEnabled; }
329 
330     void deviceOrPageScaleFactorChanged();
331 
332     void windowScreenDidChange(PlatformDisplayID);
333 
334     GraphicsLayer* layerForHorizontalScrollbar() const { return m_layerForHorizontalScrollbar.get(); }
335     GraphicsLayer* layerForVerticalScrollbar() const { return m_layerForVerticalScrollbar.get(); }
336     GraphicsLayer* layerForScrollCorner() const { return m_layerForScrollCorner.get(); }
337 #if ENABLE(RUBBER_BANDING)
338     GraphicsLayer* layerForOverhangAreas() const { return m_layerForOverhangAreas.get(); }
339     GraphicsLayer* layerForContentShadow() const { return m_contentShadowLayer.get(); }
340 
341     GraphicsLayer* updateLayerForTopOverhangArea(bool wantsLayer);
342     GraphicsLayer* updateLayerForBottomOverhangArea(bool wantsLayer);
343     GraphicsLayer* updateLayerForHeader(bool wantsLayer);
344     GraphicsLayer* updateLayerForFooter(bool wantsLayer);
345 #endif
346 
347     // FIXME: make the coordinated/async terminology consistent.
348     bool isViewportConstrainedFixedOrStickyLayer(const RenderLayer&amp;) const;
349     bool useCoordinatedScrollingForLayer(const RenderLayer&amp;) const;
<span class="line-added">350     ScrollPositioningBehavior computeCoordinatedPositioningForLayer(const RenderLayer&amp;) const;</span>
351     bool isLayerForIFrameWithScrollCoordinatedContents(const RenderLayer&amp;) const;
352 
353     ScrollableArea* scrollableAreaForScrollLayerID(ScrollingNodeID) const;
354 
355     void removeFromScrollCoordinatedLayers(RenderLayer&amp;);
356 
357     void willRemoveScrollingLayerWithBacking(RenderLayer&amp;, RenderLayerBacking&amp;);
358     void didAddScrollingLayer(RenderLayer&amp;);
359 
360     void resetTrackedRepaintRects();
361     void setTracksRepaints(bool tracksRepaints) { m_isTrackingRepaints = tracksRepaints; }
362 
363     bool viewHasTransparentBackground(Color* backgroundColor = nullptr) const;
364 
365     bool hasNonMainLayersWithTiledBacking() const { return m_layersWithTiledBackingCount; }
366 
367     OptionSet&lt;CompositingReason&gt; reasonsForCompositing(const RenderLayer&amp;) const;
368 
369     void setLayerFlushThrottlingEnabled(bool);
370     void disableLayerFlushThrottlingTemporarilyForInteraction();
371 
372     void didPaintBacking(RenderLayerBacking*);
373 
374     const Color&amp; rootExtendedBackgroundColor() const { return m_rootExtendedBackgroundColor; }
375 
376     void updateRootContentLayerClipping();
377 
378 #if ENABLE(CSS_SCROLL_SNAP)
379     void updateScrollSnapPropertiesWithFrameView(const FrameView&amp;) const;
380 #endif
381 
382     // For testing.
383     void startTrackingLayerFlushes() { m_layerFlushCount = 0; }
384     unsigned layerFlushCount() const { return m_layerFlushCount; }
385 
386     void startTrackingCompositingUpdates() { m_compositingUpdateCount = 0; }
387     unsigned compositingUpdateCount() const { return m_compositingUpdateCount; }
388 
389 private:
<span class="line-modified">390     class BackingSharingState;</span>
391     struct CompositingState;
392     struct OverlapExtent;
393 
394     // Returns true if the policy changed.
395     bool updateCompositingPolicy();
396 
397     // GraphicsLayerClient implementation
398     void notifyFlushRequired(const GraphicsLayer*) override;
<span class="line-modified">399     void paintContents(const GraphicsLayer*, GraphicsContext&amp;, OptionSet&lt;GraphicsLayerPaintingPhase&gt;, const FloatRect&amp;, GraphicsLayerPaintBehavior) override;</span>
400     void customPositionForVisibleRectComputation(const GraphicsLayer*, FloatPoint&amp;) const override;
401     bool isTrackingRepaints() const override { return m_isTrackingRepaints; }
402 
403     // GraphicsLayerUpdaterClient implementation
404     void flushLayersSoon(GraphicsLayerUpdater&amp;) override;
405 
406     // Copy the accelerated compositing related flags from Settings
407     void cacheAcceleratedCompositingFlags();
408     void cacheAcceleratedCompositingFlagsAfterLayout();
409 
410     // Whether the given RL needs a compositing layer.
411     bool needsToBeComposited(const RenderLayer&amp;, RequiresCompositingData&amp;) const;
412     // Whether the layer has an intrinsic need for compositing layer.
413     bool requiresCompositingLayer(const RenderLayer&amp;, RequiresCompositingData&amp;) const;
414     // Whether the layer could ever be composited.
415     bool canBeComposited(const RenderLayer&amp;) const;
416     bool needsCompositingUpdateForStyleChangeOnNonCompositedLayer(RenderLayer&amp;, const RenderStyle* oldStyle) const;
417 
418     // Make or destroy the backing for this layer; returns true if backing changed.
419     enum class BackingRequired { No, Yes, Unknown };
420     bool updateBacking(RenderLayer&amp;, RequiresCompositingData&amp;, CompositingChangeRepaint shouldRepaint, BackingRequired = BackingRequired::Unknown);
421 
422     void clearBackingForLayerIncludingDescendants(RenderLayer&amp;);
423 
424     // Repaint this and its child layers.
425     void recursiveRepaintLayer(RenderLayer&amp;);
426 
<span class="line-modified">427     void computeExtent(const LayerOverlapMap&amp;, const RenderLayer&amp;, OverlapExtent&amp;) const;</span>
<span class="line-modified">428     void addToOverlapMap(LayerOverlapMap&amp;, const RenderLayer&amp;, OverlapExtent&amp;) const;</span>
<span class="line-modified">429     void addDescendantsToOverlapMapRecursive(LayerOverlapMap&amp;, const RenderLayer&amp;, const RenderLayer* ancestorLayer = nullptr) const;</span>
<span class="line-added">430     void updateOverlapMap(LayerOverlapMap&amp;, const RenderLayer&amp;, OverlapExtent&amp;, bool didPushContainer, bool addLayerToOverlap, bool addDescendantsToOverlap = false) const;</span>
<span class="line-added">431     bool layerOverlaps(const LayerOverlapMap&amp;, const RenderLayer&amp;, OverlapExtent&amp;) const;</span>
432 
433     void updateCompositingLayersTimerFired();
434 
<span class="line-modified">435     void computeCompositingRequirements(RenderLayer* ancestorLayer, RenderLayer&amp;, LayerOverlapMap&amp;, CompositingState&amp;, BackingSharingState&amp;, bool&amp; descendantHas3DTransform);</span>
<span class="line-modified">436     void traverseUnchangedSubtree(RenderLayer* ancestorLayer, RenderLayer&amp;, LayerOverlapMap&amp;, CompositingState&amp;, BackingSharingState&amp;, bool&amp; descendantHas3DTransform);</span>
437 
438     enum class UpdateLevel {
439         AllDescendants          = 1 &lt;&lt; 0,
440         CompositedChildren      = 1 &lt;&lt; 1,
441     };
442     // Recurses down the tree, parenting descendant compositing layers and collecting an array of child layers for the current compositing layer.
443     void updateBackingAndHierarchy(RenderLayer&amp;, Vector&lt;Ref&lt;GraphicsLayer&gt;&gt;&amp; childGraphicsLayersOfEnclosingLayer, struct ScrollingTreeState&amp;, OptionSet&lt;UpdateLevel&gt; = { }, int depth = 0);
444 
445     bool layerHas3DContent(const RenderLayer&amp;) const;
446     bool isRunningTransformAnimation(RenderLayerModelObject&amp;) const;
447 
448     void appendDocumentOverlayLayers(Vector&lt;Ref&lt;GraphicsLayer&gt;&gt;&amp;);
449 
450     bool needsCompositingForContentOrOverlays() const;
451 
452     void ensureRootLayer();
453     void destroyRootLayer();
454 
455     void attachRootLayer(RootLayerAttachment);
456     void detachRootLayer();
</pre>
<hr />
<pre>
481 #if USE(REQUEST_ANIMATION_FRAME_DISPLAY_MONITOR)
482     RefPtr&lt;DisplayRefreshMonitor&gt; createDisplayRefreshMonitor(PlatformDisplayID) const override;
483 #endif
484 
485     // Non layout-dependent
486     bool requiresCompositingForAnimation(RenderLayerModelObject&amp;) const;
487     bool requiresCompositingForTransform(RenderLayerModelObject&amp;) const;
488     bool requiresCompositingForBackfaceVisibility(RenderLayerModelObject&amp;) const;
489     bool requiresCompositingForVideo(RenderLayerModelObject&amp;) const;
490     bool requiresCompositingForCanvas(RenderLayerModelObject&amp;) const;
491     bool requiresCompositingForFilters(RenderLayerModelObject&amp;) const;
492     bool requiresCompositingForWillChange(RenderLayerModelObject&amp;) const;
493 
494     // Layout-dependent
495     bool requiresCompositingForPlugin(RenderLayerModelObject&amp;, RequiresCompositingData&amp;) const;
496     bool requiresCompositingForFrame(RenderLayerModelObject&amp;, RequiresCompositingData&amp;) const;
497     bool requiresCompositingForScrollableFrame(RequiresCompositingData&amp;) const;
498     bool requiresCompositingForPosition(RenderLayerModelObject&amp;, const RenderLayer&amp;, RequiresCompositingData&amp;) const;
499     bool requiresCompositingForOverflowScrolling(const RenderLayer&amp;, RequiresCompositingData&amp;) const;
500     bool requiresCompositingForEditableImage(RenderLayerModelObject&amp;) const;
<span class="line-modified">501     bool requiresCompositingForIndirectReason(const RenderLayer&amp;, bool hasCompositedDescendants, bool has3DTransformedDescendants, bool paintsIntoProvidedBacking, IndirectCompositingReason&amp;) const;</span>
<span class="line-added">502 </span>
<span class="line-added">503     static ScrollPositioningBehavior layerScrollBehahaviorRelativeToCompositedAncestor(const RenderLayer&amp;, const RenderLayer&amp; compositedAncestor);</span>
504 
505     static bool styleChangeMayAffectIndirectCompositingReasons(const RenderStyle&amp; oldStyle, const RenderStyle&amp; newStyle);
506 
507     enum class ScrollingNodeChangeFlags {
508         Layer           = 1 &lt;&lt; 0,
509         LayerGeometry   = 1 &lt;&lt; 1,
510     };
511 
512     ScrollingNodeID attachScrollingNode(RenderLayer&amp;, ScrollingNodeType, struct ScrollingTreeState&amp;);
<span class="line-added">513     ScrollingNodeID registerScrollingNodeID(ScrollingCoordinator&amp;, ScrollingNodeID, ScrollingNodeType, struct ScrollingTreeState&amp;);</span>
<span class="line-added">514 </span>
<span class="line-added">515     OptionSet&lt;ScrollCoordinationRole&gt; coordinatedScrollingRolesForLayer(const RenderLayer&amp;) const;</span>
516 
517     // Returns the ScrollingNodeID which acts as the parent for children.
<span class="line-modified">518     ScrollingNodeID updateScrollCoordinationForLayer(RenderLayer&amp;, struct ScrollingTreeState&amp;, OptionSet&lt;ScrollingNodeChangeFlags&gt;);</span>
519 
520     // These return the ScrollingNodeID which acts as the parent for children.
521     ScrollingNodeID updateScrollingNodeForViewportConstrainedRole(RenderLayer&amp;, struct ScrollingTreeState&amp;, OptionSet&lt;ScrollingNodeChangeFlags&gt;);
522     ScrollingNodeID updateScrollingNodeForScrollingRole(RenderLayer&amp;, struct ScrollingTreeState&amp;, OptionSet&lt;ScrollingNodeChangeFlags&gt;);
<span class="line-added">523     ScrollingNodeID updateScrollingNodeForScrollingProxyRole(RenderLayer&amp;, struct ScrollingTreeState&amp;, OptionSet&lt;ScrollingNodeChangeFlags&gt;);</span>
524     ScrollingNodeID updateScrollingNodeForFrameHostingRole(RenderLayer&amp;, struct ScrollingTreeState&amp;, OptionSet&lt;ScrollingNodeChangeFlags&gt;);
<span class="line-added">525     ScrollingNodeID updateScrollingNodeForPositioningRole(RenderLayer&amp;, struct ScrollingTreeState&amp;, OptionSet&lt;ScrollingNodeChangeFlags&gt;);</span>
<span class="line-added">526 </span>
<span class="line-added">527     void updateScrollingNodeLayers(ScrollingNodeID, RenderLayer&amp;, ScrollingCoordinator&amp;);</span>
528 
529     void detachScrollCoordinatedLayer(RenderLayer&amp;, OptionSet&lt;ScrollCoordinationRole&gt;);
530     void detachScrollCoordinatedLayerWithRole(RenderLayer&amp;, ScrollingCoordinator&amp;, ScrollCoordinationRole);
531 
532     FixedPositionViewportConstraints computeFixedViewportConstraints(RenderLayer&amp;) const;
533     StickyPositionViewportConstraints computeStickyViewportConstraints(RenderLayer&amp;) const;
534 
<span class="line-modified">535     LayoutRect rootParentRelativeScrollableRect() const;</span>
<span class="line-modified">536     LayoutRect parentRelativeScrollableRect(const RenderLayer&amp;, const RenderLayer* ancestorLayer) const;</span>
<span class="line-modified">537 </span>
<span class="line-added">538     // Returns list of layers and their clip rects required to clip the given layer, which include clips in the</span>
<span class="line-added">539     // containing block chain between the given layer and its composited ancestor.</span>
<span class="line-added">540     Vector&lt;CompositedClipData&gt; computeAncestorClippingStack(const RenderLayer&amp;, const RenderLayer* compositingAncestor) const;</span>
541 
542     bool requiresScrollLayer(RootLayerAttachment) const;
543     bool requiresHorizontalScrollbarLayer() const;
544     bool requiresVerticalScrollbarLayer() const;
545     bool requiresScrollCornerLayer() const;
546 #if ENABLE(RUBBER_BANDING)
547     bool requiresOverhangAreasLayer() const;
548     bool requiresContentShadowLayer() const;
549 #endif
550 
551     // True if the FrameView uses a ScrollingCoordinator.
552     bool hasCoordinatedScrolling() const;
553 
554     // FIXME: make the coordinated/async terminology consistent.
555     bool isAsyncScrollableStickyLayer(const RenderLayer&amp;, const RenderLayer** enclosingAcceleratedOverflowLayer = nullptr) const;
556 
557     bool shouldCompositeOverflowControls() const;
558 

559     bool isThrottlingLayerFlushes() const;
560     void startInitialLayerFlushTimerIfNeeded();
561     void startLayerFlushTimerIfNeeded();
562     void layerFlushTimerFired();
563 
564 #if !LOG_DISABLED
565     const char* logReasonsForCompositing(const RenderLayer&amp;);
566     void logLayerInfo(const RenderLayer&amp;, const char*, int depth);
567 #endif
568 
569     bool documentUsesTiledBacking() const;
570     bool isMainFrameCompositor() const;
571 
572 private:
573     RenderView&amp; m_renderView;

574     Timer m_updateCompositingLayersTimer;
575 
576     ChromeClient::CompositingTriggerFlags m_compositingTriggers { static_cast&lt;ChromeClient::CompositingTriggerFlags&gt;(ChromeClient::AllTriggers) };
577     bool m_hasAcceleratedCompositing { true };
578 
579     CompositingPolicy m_compositingPolicy { CompositingPolicy::Normal };
580 
581     bool m_showDebugBorders { false };
582     bool m_showRepaintCounter { false };
583     bool m_acceleratedDrawingEnabled { false };
584     bool m_displayListDrawingEnabled { false };
585 
586     bool m_compositing { false };
587     bool m_flushingLayers { false };
588     bool m_shouldFlushOnReattach { false };
589     bool m_forceCompositingMode { false };
590     bool m_inPostLayoutUpdate { false }; // true when it&#39;s OK to trust layout information (e.g. layer sizes and positions)
591 
592     bool m_isTrackingRepaints { false }; // Used for testing.
593 
594     unsigned m_contentLayersCount { 0 };
595     unsigned m_layersWithTiledBackingCount { 0 };
596     unsigned m_layerFlushCount { 0 };
597     unsigned m_compositingUpdateCount { 0 };
598 
599     RootLayerAttachment m_rootLayerAttachment { RootLayerUnattached };
600 
<span class="line-added">601     RefPtr&lt;GraphicsLayer&gt; m_rootContentsLayer;</span>
<span class="line-added">602 </span>
603     // Enclosing clipping layer for iframe content
604     RefPtr&lt;GraphicsLayer&gt; m_clipLayer;
605     RefPtr&lt;GraphicsLayer&gt; m_scrollContainerLayer;
606     RefPtr&lt;GraphicsLayer&gt; m_scrolledContentsLayer;
607 
608     // Enclosing layer for overflow controls and the clipping layer
609     RefPtr&lt;GraphicsLayer&gt; m_overflowControlsHostLayer;
610 
611     // Layers for overflow controls
612     RefPtr&lt;GraphicsLayer&gt; m_layerForHorizontalScrollbar;
613     RefPtr&lt;GraphicsLayer&gt; m_layerForVerticalScrollbar;
614     RefPtr&lt;GraphicsLayer&gt; m_layerForScrollCorner;
615 #if ENABLE(RUBBER_BANDING)
616     RefPtr&lt;GraphicsLayer&gt; m_layerForOverhangAreas;
617     RefPtr&lt;GraphicsLayer&gt; m_contentShadowLayer;
618     RefPtr&lt;GraphicsLayer&gt; m_layerForTopOverhangArea;
619     RefPtr&lt;GraphicsLayer&gt; m_layerForBottomOverhangArea;
620     RefPtr&lt;GraphicsLayer&gt; m_layerForHeader;
621     RefPtr&lt;GraphicsLayer&gt; m_layerForFooter;
622 #endif
</pre>
</td>
</tr>
</table>
<center><a href="RenderLayerCompositor.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="RenderLayerFilters.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>