<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.web/src/main/native/Source/WebCore/page/Frame.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (C) 1998, 1999 Torben Weis &lt;weis@kde.org&gt;
   3  *                     1999 Lars Knoll &lt;knoll@kde.org&gt;
   4  *                     1999 Antti Koivisto &lt;koivisto@kde.org&gt;
   5  *                     2000 Simon Hausmann &lt;hausmann@kde.org&gt;
   6  *                     2000 Stefan Schimanski &lt;1Stein@gmx.de&gt;
   7  *                     2001 George Staikos &lt;staikos@kde.org&gt;
   8  * Copyright (C) 2004-2016 Apple Inc. All rights reserved.
   9  * Copyright (C) 2005 Alexey Proskuryakov &lt;ap@nypop.com&gt;
  10  * Copyright (C) 2008 Nokia Corporation and/or its subsidiary(-ies)
  11  * Copyright (C) 2008 Eric Seidel &lt;eric@webkit.org&gt;
  12  * Copyright (C) 2008 Google Inc.
  13  *
  14  * This library is free software; you can redistribute it and/or
  15  * modify it under the terms of the GNU Library General Public
  16  * License as published by the Free Software Foundation; either
  17  * version 2 of the License, or (at your option) any later version.
  18  *
  19  * This library is distributed in the hope that it will be useful,
  20  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  21  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  22  * Library General Public License for more details.
  23  *
  24  * You should have received a copy of the GNU Library General Public License
  25  * along with this library; see the file COPYING.LIB.  If not, write to
  26  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  27  * Boston, MA 02110-1301, USA.
  28  */
  29 
  30 #include &quot;config.h&quot;
  31 #include &quot;Frame.h&quot;
  32 
  33 #include &quot;ApplyStyleCommand.h&quot;
  34 #include &quot;BackForwardController.h&quot;
  35 #include &quot;CSSAnimationController.h&quot;
  36 #include &quot;CSSComputedStyleDeclaration.h&quot;
  37 #include &quot;CSSPropertyNames.h&quot;
  38 #include &quot;CachedCSSStyleSheet.h&quot;
  39 #include &quot;CachedResourceLoader.h&quot;
  40 #include &quot;Chrome.h&quot;
  41 #include &quot;ChromeClient.h&quot;
  42 #include &quot;DOMWindow.h&quot;
  43 #include &quot;DocumentTimeline.h&quot;
  44 #include &quot;DocumentType.h&quot;
  45 #include &quot;Editing.h&quot;
  46 #include &quot;Editor.h&quot;
  47 #include &quot;EditorClient.h&quot;
  48 #include &quot;Event.h&quot;
  49 #include &quot;EventHandler.h&quot;
  50 #include &quot;EventNames.h&quot;
  51 #include &quot;FloatQuad.h&quot;
  52 #include &quot;FocusController.h&quot;
  53 #include &quot;FrameDestructionObserver.h&quot;
  54 #include &quot;FrameLoader.h&quot;
  55 #include &quot;FrameLoaderClient.h&quot;
  56 #include &quot;FrameSelection.h&quot;
  57 #include &quot;FrameView.h&quot;
  58 #include &quot;GraphicsContext.h&quot;
  59 #include &quot;GraphicsLayer.h&quot;
  60 #include &quot;HTMLFormControlElement.h&quot;
  61 #include &quot;HTMLFormElement.h&quot;
  62 #include &quot;HTMLFrameElementBase.h&quot;
  63 #include &quot;HTMLNames.h&quot;
  64 #include &quot;HTMLTableCellElement.h&quot;
  65 #include &quot;HTMLTableRowElement.h&quot;
  66 #include &quot;HitTestResult.h&quot;
  67 #include &quot;ImageBuffer.h&quot;
  68 #include &quot;InspectorInstrumentation.h&quot;
  69 #include &quot;JSWindowProxy.h&quot;
  70 #include &quot;Logging.h&quot;
  71 #include &quot;NavigationScheduler.h&quot;
  72 #include &quot;Navigator.h&quot;
  73 #include &quot;NodeList.h&quot;
  74 #include &quot;NodeTraversal.h&quot;
  75 #include &quot;Page.h&quot;
  76 #include &quot;PageCache.h&quot;
  77 #include &quot;ProcessWarming.h&quot;
  78 #include &quot;RenderLayerCompositor.h&quot;
  79 #include &quot;RenderTableCell.h&quot;
  80 #include &quot;RenderText.h&quot;
  81 #include &quot;RenderTextControl.h&quot;
  82 #include &quot;RenderTheme.h&quot;
  83 #include &quot;RenderView.h&quot;
  84 #include &quot;RenderWidget.h&quot;
  85 #include &quot;RuntimeEnabledFeatures.h&quot;
  86 #include &quot;SVGDocument.h&quot;
  87 #include &quot;SVGDocumentExtensions.h&quot;
  88 #include &quot;ScriptController.h&quot;
  89 #include &quot;ScriptSourceCode.h&quot;
  90 #include &quot;ScrollingCoordinator.h&quot;
  91 #include &quot;Settings.h&quot;
  92 #include &quot;StyleProperties.h&quot;
  93 #include &quot;StyleScope.h&quot;
  94 #include &quot;TextNodeTraversal.h&quot;
  95 #include &quot;TextResourceDecoder.h&quot;
  96 #include &quot;UserContentController.h&quot;
  97 #include &quot;UserContentURLPattern.h&quot;
  98 #include &quot;UserScript.h&quot;
  99 #include &quot;UserTypingGestureIndicator.h&quot;
 100 #include &quot;VisibleUnits.h&quot;
 101 #include &quot;markup.h&quot;
 102 #include &quot;npruntime_impl.h&quot;
 103 #include &quot;runtime_root.h&quot;
 104 #include &lt;JavaScriptCore/RegularExpression.h&gt;
 105 #include &lt;wtf/RefCountedLeakCounter.h&gt;
 106 #include &lt;wtf/StdLibExtras.h&gt;
 107 #include &lt;wtf/text/StringBuilder.h&gt;
 108 
 109 #if PLATFORM(IOS_FAMILY)
 110 #include &quot;WKContentObservation.h&quot;
 111 #endif
 112 
 113 namespace WebCore {
 114 
 115 using namespace HTMLNames;
 116 
 117 #if PLATFORM(IOS_FAMILY)
 118 static const Seconds scrollFrequency { 1000_s / 60. };
 119 #endif
 120 
 121 DEFINE_DEBUG_ONLY_GLOBAL(WTF::RefCountedLeakCounter, frameCounter, (&quot;Frame&quot;));
 122 
 123 static inline Frame* parentFromOwnerElement(HTMLFrameOwnerElement* ownerElement)
 124 {
 125     if (!ownerElement)
 126         return 0;
 127     return ownerElement-&gt;document().frame();
 128 }
 129 
 130 static inline float parentPageZoomFactor(Frame* frame)
 131 {
 132     Frame* parent = frame-&gt;tree().parent();
 133     if (!parent)
 134         return 1;
 135     return parent-&gt;pageZoomFactor();
 136 }
 137 
 138 static inline float parentTextZoomFactor(Frame* frame)
 139 {
 140     Frame* parent = frame-&gt;tree().parent();
 141     if (!parent)
 142         return 1;
 143     return parent-&gt;textZoomFactor();
 144 }
 145 
 146 Frame::Frame(Page&amp; page, HTMLFrameOwnerElement* ownerElement, FrameLoaderClient&amp; frameLoaderClient)
 147     : m_mainFrame(ownerElement ? page.mainFrame() : *this)
 148     , m_page(&amp;page)
 149     , m_settings(&amp;page.settings())
 150     , m_treeNode(*this, parentFromOwnerElement(ownerElement))
 151     , m_loader(makeUniqueRef&lt;FrameLoader&gt;(*this, frameLoaderClient))
 152     , m_navigationScheduler(makeUniqueRef&lt;NavigationScheduler&gt;(*this))
 153     , m_ownerElement(ownerElement)
 154     , m_script(makeUniqueRef&lt;ScriptController&gt;(*this))
 155     , m_editor(makeUniqueRef&lt;Editor&gt;(*this))
 156     , m_selection(makeUniqueRef&lt;FrameSelection&gt;(this))
 157     , m_animationController(makeUniqueRef&lt;CSSAnimationController&gt;(*this))
 158 #if PLATFORM(IOS_FAMILY)
 159     , m_overflowAutoScrollTimer(*this, &amp;Frame::overflowAutoScrollTimerFired)
 160     , m_selectionChangeCallbacksDisabled(false)
 161 #endif
 162     , m_pageZoomFactor(parentPageZoomFactor(this))
 163     , m_textZoomFactor(parentTextZoomFactor(this))
 164     , m_activeDOMObjectsAndAnimationsSuspendedCount(0)
 165     , m_eventHandler(makeUniqueRef&lt;EventHandler&gt;(*this))
 166 {
 167     ProcessWarming::initializeNames();
 168 
 169     if (ownerElement) {
 170         m_mainFrame.selfOnlyRef();
 171         page.incrementSubframeCount();
 172         ownerElement-&gt;setContentFrame(this);
 173     }
 174 
 175 #ifndef NDEBUG
 176     frameCounter.increment();
 177 #endif
 178 
 179     // Pause future ActiveDOMObjects if this frame is being created while the page is in a paused state.
 180     Frame* parent = parentFromOwnerElement(ownerElement);
 181     if (parent &amp;&amp; parent-&gt;activeDOMObjectsAndAnimationsSuspended())
 182         suspendActiveDOMObjectsAndAnimations();
 183 }
 184 
 185 void Frame::init()
 186 {
 187     m_loader-&gt;init();
 188 }
 189 
 190 Ref&lt;Frame&gt; Frame::create(Page* page, HTMLFrameOwnerElement* ownerElement, FrameLoaderClient* client)
 191 {
 192     ASSERT(page);
 193     ASSERT(client);
 194     return adoptRef(*new Frame(*page, ownerElement, *client));
 195 }
 196 
 197 Frame::~Frame()
 198 {
 199     setView(nullptr);
 200     loader().cancelAndClear();
 201 
 202     // FIXME: We should not be doing all this work inside the destructor
 203 
 204 #ifndef NDEBUG
 205     frameCounter.decrement();
 206 #endif
 207 
 208     disconnectOwnerElement();
 209 
 210     while (auto* destructionObserver = m_destructionObservers.takeAny())
 211         destructionObserver-&gt;frameDestroyed();
 212 
 213     if (!isMainFrame())
 214         m_mainFrame.selfOnlyDeref();
 215 }
 216 
 217 void Frame::addDestructionObserver(FrameDestructionObserver* observer)
 218 {
 219     m_destructionObservers.add(observer);
 220 }
 221 
 222 void Frame::removeDestructionObserver(FrameDestructionObserver* observer)
 223 {
 224     m_destructionObservers.remove(observer);
 225 }
 226 
 227 void Frame::setView(RefPtr&lt;FrameView&gt;&amp;&amp; view)
 228 {
 229     // We the custom scroll bars as early as possible to prevent m_doc-&gt;detach()
 230     // from messing with the view such that its scroll bars won&#39;t be torn down.
 231     // FIXME: We should revisit this.
 232     if (m_view)
 233         m_view-&gt;prepareForDetach();
 234 
 235     // Prepare for destruction now, so any unload event handlers get run and the DOMWindow is
 236     // notified. If we wait until the view is destroyed, then things won&#39;t be hooked up enough for
 237     // these calls to work.
 238     if (!view &amp;&amp; m_doc &amp;&amp; m_doc-&gt;pageCacheState() != Document::InPageCache)
 239         m_doc-&gt;prepareForDestruction();
 240 
 241     if (m_view)
 242         m_view-&gt;layoutContext().unscheduleLayout();
 243 
 244     m_eventHandler-&gt;clear();
 245 
 246     RELEASE_ASSERT(!m_doc || !m_doc-&gt;hasLivingRenderTree());
 247 
 248     m_view = WTFMove(view);
 249 
 250     // Only one form submission is allowed per view of a part.
 251     // Since this part may be getting reused as a result of being
 252     // pulled from the back/forward cache, reset this flag.
 253     loader().resetMultipleFormSubmissionProtection();
 254 }
 255 
 256 void Frame::setDocument(RefPtr&lt;Document&gt;&amp;&amp; newDocument)
 257 {
 258     ASSERT(!newDocument || newDocument-&gt;frame() == this);
 259 
 260     if (m_documentIsBeingReplaced)
 261         return;
 262 
 263     m_documentIsBeingReplaced = true;
 264 
 265     if (isMainFrame()) {
 266         if (m_page)
 267             m_page-&gt;didChangeMainDocument();
 268         m_loader-&gt;client().dispatchDidChangeMainDocument();
 269 
 270         // We want to generate the same unique names whenever a page is loaded to avoid making layout tests
 271         // flaky and for things like form state restoration to work. To achieve this, we reset our frame
 272         // identifier generator every time the page is navigated.
 273         tree().resetFrameIdentifiers();
 274     }
 275 
 276 #if ENABLE(ATTACHMENT_ELEMENT)
 277     if (m_doc) {
 278         for (auto&amp; attachment : m_doc-&gt;attachmentElementsByIdentifier().values())
 279             editor().didRemoveAttachmentElement(attachment);
 280     }
 281 #endif
 282 
 283     if (m_doc &amp;&amp; m_doc-&gt;pageCacheState() != Document::InPageCache)
 284         m_doc-&gt;prepareForDestruction();
 285 
 286     m_doc = newDocument.copyRef();
 287     ASSERT(!m_doc || m_doc-&gt;domWindow());
 288     ASSERT(!m_doc || m_doc-&gt;domWindow()-&gt;frame() == this);
 289 
 290     // Don&#39;t use m_doc because it can be overwritten and we want to guarantee
 291     // that the document is not destroyed during this function call.
 292     if (newDocument)
 293         newDocument-&gt;didBecomeCurrentDocumentInFrame();
 294 
 295 #if ENABLE(ATTACHMENT_ELEMENT)
 296     if (m_doc) {
 297         for (auto&amp; attachment : m_doc-&gt;attachmentElementsByIdentifier().values())
 298             editor().didInsertAttachmentElement(attachment);
 299     }
 300 #endif
 301 
 302     InspectorInstrumentation::frameDocumentUpdated(*this);
 303 
 304     m_documentIsBeingReplaced = false;
 305 }
 306 
 307 #if ENABLE(ORIENTATION_EVENTS)
 308 void Frame::orientationChanged()
 309 {
 310     Vector&lt;Ref&lt;Frame&gt;&gt; frames;
 311     for (Frame* frame = this; frame; frame = frame-&gt;tree().traverseNext())
 312         frames.append(*frame);
 313 
 314     auto newOrientation = orientation();
 315     for (auto&amp; frame : frames) {
 316         if (Document* document = frame-&gt;document())
 317             document-&gt;orientationChanged(newOrientation);
 318     }
 319 }
 320 
 321 int Frame::orientation() const
 322 {
 323     if (m_page)
 324         return m_page-&gt;chrome().client().deviceOrientation();
 325     return 0;
 326 }
 327 #endif // ENABLE(ORIENTATION_EVENTS)
 328 
 329 static JSC::Yarr::RegularExpression createRegExpForLabels(const Vector&lt;String&gt;&amp; labels)
 330 {
 331     // REVIEW- version of this call in FrameMac.mm caches based on the NSArray ptrs being
 332     // the same across calls.  We can&#39;t do that.
 333 
 334     static NeverDestroyed&lt;JSC::Yarr::RegularExpression&gt; wordRegExp(&quot;\\w&quot;);
 335     StringBuilder pattern;
 336     pattern.append(&#39;(&#39;);
 337     unsigned int numLabels = labels.size();
 338     unsigned int i;
 339     for (i = 0; i &lt; numLabels; i++) {
 340         String label = labels[i];
 341 
 342         bool startsWithWordChar = false;
 343         bool endsWithWordChar = false;
 344         if (label.length()) {
 345             startsWithWordChar = wordRegExp.get().match(label.substring(0, 1)) &gt;= 0;
 346             endsWithWordChar = wordRegExp.get().match(label.substring(label.length() - 1, 1)) &gt;= 0;
 347         }
 348 
 349         if (i)
 350             pattern.append(&#39;|&#39;);
 351         // Search for word boundaries only if label starts/ends with &quot;word characters&quot;.
 352         // If we always searched for word boundaries, this wouldn&#39;t work for languages
 353         // such as Japanese.
 354         if (startsWithWordChar)
 355             pattern.appendLiteral(&quot;\\b&quot;);
 356         pattern.append(label);
 357         if (endsWithWordChar)
 358             pattern.appendLiteral(&quot;\\b&quot;);
 359     }
 360     pattern.append(&#39;)&#39;);
 361     return JSC::Yarr::RegularExpression(pattern.toString(), JSC::Yarr::TextCaseInsensitive);
 362 }
 363 
 364 String Frame::searchForLabelsAboveCell(const JSC::Yarr::RegularExpression&amp; regExp, HTMLTableCellElement* cell, size_t* resultDistanceFromStartOfCell)
 365 {
 366     HTMLTableCellElement* aboveCell = cell-&gt;cellAbove();
 367     if (aboveCell) {
 368         // search within the above cell we found for a match
 369         size_t lengthSearched = 0;
 370         for (Text* textNode = TextNodeTraversal::firstWithin(*aboveCell); textNode; textNode = TextNodeTraversal::next(*textNode, aboveCell)) {
 371             if (!textNode-&gt;renderer() || textNode-&gt;renderer()-&gt;style().visibility() != Visibility::Visible)
 372                 continue;
 373             // For each text chunk, run the regexp
 374             String nodeString = textNode-&gt;data();
 375             int pos = regExp.searchRev(nodeString);
 376             if (pos &gt;= 0) {
 377                 if (resultDistanceFromStartOfCell)
 378                     *resultDistanceFromStartOfCell = lengthSearched;
 379                 return nodeString.substring(pos, regExp.matchedLength());
 380             }
 381             lengthSearched += nodeString.length();
 382         }
 383     }
 384 
 385     // Any reason in practice to search all cells in that are above cell?
 386     if (resultDistanceFromStartOfCell)
 387         *resultDistanceFromStartOfCell = notFound;
 388     return String();
 389 }
 390 
 391 // FIXME: This should take an Element&amp;.
 392 String Frame::searchForLabelsBeforeElement(const Vector&lt;String&gt;&amp; labels, Element* element, size_t* resultDistance, bool* resultIsInCellAbove)
 393 {
 394     ASSERT(element);
 395     JSC::Yarr::RegularExpression regExp = createRegExpForLabels(labels);
 396     // We stop searching after we&#39;ve seen this many chars
 397     const unsigned int charsSearchedThreshold = 500;
 398     // This is the absolute max we search.  We allow a little more slop than
 399     // charsSearchedThreshold, to make it more likely that we&#39;ll search whole nodes.
 400     const unsigned int maxCharsSearched = 600;
 401     // If the starting element is within a table, the cell that contains it
 402     HTMLTableCellElement* startingTableCell = nullptr;
 403     bool searchedCellAbove = false;
 404 
 405     if (resultDistance)
 406         *resultDistance = notFound;
 407     if (resultIsInCellAbove)
 408         *resultIsInCellAbove = false;
 409 
 410     // walk backwards in the node tree, until another element, or form, or end of tree
 411     int unsigned lengthSearched = 0;
 412     Node* n;
 413     for (n = NodeTraversal::previous(*element); n &amp;&amp; lengthSearched &lt; charsSearchedThreshold; n = NodeTraversal::previous(*n)) {
 414         // We hit another form element or the start of the form - bail out
 415         if (is&lt;HTMLFormElement&gt;(*n) || is&lt;HTMLFormControlElement&gt;(*n))
 416             break;
 417 
 418         if (n-&gt;hasTagName(tdTag) &amp;&amp; !startingTableCell)
 419             startingTableCell = downcast&lt;HTMLTableCellElement&gt;(n);
 420         else if (is&lt;HTMLTableRowElement&gt;(*n) &amp;&amp; startingTableCell) {
 421             String result = searchForLabelsAboveCell(regExp, startingTableCell, resultDistance);
 422             if (!result.isEmpty()) {
 423                 if (resultIsInCellAbove)
 424                     *resultIsInCellAbove = true;
 425                 return result;
 426             }
 427             searchedCellAbove = true;
 428         } else if (n-&gt;isTextNode() &amp;&amp; n-&gt;renderer() &amp;&amp; n-&gt;renderer()-&gt;style().visibility() == Visibility::Visible) {
 429             // For each text chunk, run the regexp
 430             String nodeString = n-&gt;nodeValue();
 431             // add 100 for slop, to make it more likely that we&#39;ll search whole nodes
 432             if (lengthSearched + nodeString.length() &gt; maxCharsSearched)
 433                 nodeString = nodeString.right(charsSearchedThreshold - lengthSearched);
 434             int pos = regExp.searchRev(nodeString);
 435             if (pos &gt;= 0) {
 436                 if (resultDistance)
 437                     *resultDistance = lengthSearched;
 438                 return nodeString.substring(pos, regExp.matchedLength());
 439             }
 440             lengthSearched += nodeString.length();
 441         }
 442     }
 443 
 444     // If we started in a cell, but bailed because we found the start of the form or the
 445     // previous element, we still might need to search the row above us for a label.
 446     if (startingTableCell &amp;&amp; !searchedCellAbove) {
 447         String result = searchForLabelsAboveCell(regExp, startingTableCell, resultDistance);
 448         if (!result.isEmpty()) {
 449             if (resultIsInCellAbove)
 450                 *resultIsInCellAbove = true;
 451             return result;
 452         }
 453     }
 454     return String();
 455 }
 456 
 457 static String matchLabelsAgainstString(const Vector&lt;String&gt;&amp; labels, const String&amp; stringToMatch)
 458 {
 459     if (stringToMatch.isEmpty())
 460         return String();
 461 
 462     String mutableStringToMatch = stringToMatch;
 463 
 464     // Make numbers and _&#39;s in field names behave like word boundaries, e.g., &quot;address2&quot;
 465     replace(mutableStringToMatch, JSC::Yarr::RegularExpression(&quot;\\d&quot;), &quot; &quot;);
 466     mutableStringToMatch.replace(&#39;_&#39;, &#39; &#39;);
 467 
 468     JSC::Yarr::RegularExpression regExp = createRegExpForLabels(labels);
 469     // Use the largest match we can find in the whole string
 470     int pos;
 471     int length;
 472     int bestPos = -1;
 473     int bestLength = -1;
 474     int start = 0;
 475     do {
 476         pos = regExp.match(mutableStringToMatch, start);
 477         if (pos != -1) {
 478             length = regExp.matchedLength();
 479             if (length &gt;= bestLength) {
 480                 bestPos = pos;
 481                 bestLength = length;
 482             }
 483             start = pos + 1;
 484         }
 485     } while (pos != -1);
 486 
 487     if (bestPos != -1)
 488         return mutableStringToMatch.substring(bestPos, bestLength);
 489     return String();
 490 }
 491 
 492 String Frame::matchLabelsAgainstElement(const Vector&lt;String&gt;&amp; labels, Element* element)
 493 {
 494     // Match against the name element, then against the id element if no match is found for the name element.
 495     // See 7538330 for one popular site that benefits from the id element check.
 496     // FIXME: This code is mirrored in FrameMac.mm. It would be nice to make the Mac code call the platform-agnostic
 497     // code, which would require converting the NSArray of NSStrings to a Vector of Strings somewhere along the way.
 498     String resultFromNameAttribute = matchLabelsAgainstString(labels, element-&gt;getNameAttribute());
 499     if (!resultFromNameAttribute.isEmpty())
 500         return resultFromNameAttribute;
 501 
 502     return matchLabelsAgainstString(labels, element-&gt;attributeWithoutSynchronization(idAttr));
 503 }
 504 
 505 #if PLATFORM(IOS_FAMILY)
 506 void Frame::scrollOverflowLayer(RenderLayer* layer, const IntRect&amp; visibleRect, const IntRect&amp; exposeRect)
 507 {
 508     if (!layer)
 509         return;
 510 
 511     RenderBox* box = layer-&gt;renderBox();
 512     if (!box)
 513         return;
 514 
 515     if (visibleRect.intersects(exposeRect))
 516         return;
 517 
 518     // FIXME: Why isn&#39;t this just calling RenderLayer::scrollRectToVisible()?
 519     ScrollOffset scrollOffset = layer-&gt;scrollOffset();
 520     int exposeLeft = exposeRect.x();
 521     int exposeRight = exposeLeft + exposeRect.width();
 522     int clientWidth = roundToInt(box-&gt;clientWidth());
 523     if (exposeLeft &lt;= 0)
 524         scrollOffset.setX(std::max(0, scrollOffset.x() + exposeLeft - clientWidth / 2));
 525     else if (exposeRight &gt;= clientWidth)
 526         scrollOffset.setX(std::min(box-&gt;scrollWidth() - clientWidth, scrollOffset.x() + clientWidth / 2));
 527 
 528     int exposeTop = exposeRect.y();
 529     int exposeBottom = exposeTop + exposeRect.height();
 530     int clientHeight = roundToInt(box-&gt;clientHeight());
 531     if (exposeTop &lt;= 0)
 532         scrollOffset.setY(std::max(0, scrollOffset.y() + exposeTop - clientHeight / 2));
 533     else if (exposeBottom &gt;= clientHeight)
 534         scrollOffset.setY(std::min(box-&gt;scrollHeight() - clientHeight, scrollOffset.y() + clientHeight / 2));
 535 
 536     layer-&gt;scrollToOffset(scrollOffset, ScrollClamping::Unclamped);
 537     selection().setCaretRectNeedsUpdate();
 538     selection().updateAppearance();
 539 }
 540 
 541 void Frame::overflowAutoScrollTimerFired()
 542 {
 543     if (!eventHandler().mousePressed() || checkOverflowScroll(PerformOverflowScroll) == OverflowScrollNone) {
 544         if (m_overflowAutoScrollTimer.isActive())
 545             m_overflowAutoScrollTimer.stop();
 546     }
 547 }
 548 
 549 void Frame::startOverflowAutoScroll(const IntPoint&amp; mousePosition)
 550 {
 551     m_overflowAutoScrollPos = mousePosition;
 552 
 553     if (m_overflowAutoScrollTimer.isActive())
 554         return;
 555 
 556     if (checkOverflowScroll(DoNotPerformOverflowScroll) == OverflowScrollNone)
 557         return;
 558 
 559     m_overflowAutoScrollTimer.startRepeating(scrollFrequency);
 560     m_overflowAutoScrollDelta = 3;
 561 }
 562 
 563 int Frame::checkOverflowScroll(OverflowScrollAction action)
 564 {
 565     Position extent = selection().selection().extent();
 566     if (extent.isNull())
 567         return OverflowScrollNone;
 568 
 569     RenderObject* renderer = extent.deprecatedNode()-&gt;renderer();
 570     if (!renderer)
 571         return OverflowScrollNone;
 572 
 573     FrameView* view = this-&gt;view();
 574     if (!view)
 575         return OverflowScrollNone;
 576 
 577     RenderBlock* containingBlock = renderer-&gt;containingBlock();
 578     if (!containingBlock || !containingBlock-&gt;hasOverflowClip())
 579         return OverflowScrollNone;
 580     RenderLayer* layer = containingBlock-&gt;layer();
 581     ASSERT(layer);
 582 
 583     IntRect visibleRect = IntRect(view-&gt;scrollX(), view-&gt;scrollY(), view-&gt;visibleWidth(), view-&gt;visibleHeight());
 584     IntPoint position = m_overflowAutoScrollPos;
 585     if (visibleRect.contains(position.x(), position.y()))
 586         return OverflowScrollNone;
 587 
 588     int scrollType = 0;
 589     int deltaX = 0;
 590     int deltaY = 0;
 591     IntPoint selectionPosition;
 592 
 593     // This constant will make the selection draw a little bit beyond the edge of the visible area.
 594     // This prevents a visual glitch, in that you can fail to select a portion of a character that
 595     // is being rendered right at the edge of the visible rectangle.
 596     // FIXME: This probably needs improvement, and may need to take the font size into account.
 597     static const int scrollBoundsAdjustment = 3;
 598 
 599     // FIXME: Make a small buffer at the end of a visible rectangle so that autoscrolling works
 600     // even if the visible extends to the limits of the screen.
 601     if (position.x() &lt; visibleRect.x()) {
 602         scrollType |= OverflowScrollLeft;
 603         if (action == PerformOverflowScroll) {
 604             deltaX -= static_cast&lt;int&gt;(m_overflowAutoScrollDelta);
 605             selectionPosition.setX(view-&gt;scrollX() - scrollBoundsAdjustment);
 606         }
 607     } else if (position.x() &gt; visibleRect.maxX()) {
 608         scrollType |= OverflowScrollRight;
 609         if (action == PerformOverflowScroll) {
 610             deltaX += static_cast&lt;int&gt;(m_overflowAutoScrollDelta);
 611             selectionPosition.setX(view-&gt;scrollX() + view-&gt;visibleWidth() + scrollBoundsAdjustment);
 612         }
 613     }
 614 
 615     if (position.y() &lt; visibleRect.y()) {
 616         scrollType |= OverflowScrollUp;
 617         if (action == PerformOverflowScroll) {
 618             deltaY -= static_cast&lt;int&gt;(m_overflowAutoScrollDelta);
 619             selectionPosition.setY(view-&gt;scrollY() - scrollBoundsAdjustment);
 620         }
 621     } else if (position.y() &gt; visibleRect.maxY()) {
 622         scrollType |= OverflowScrollDown;
 623         if (action == PerformOverflowScroll) {
 624             deltaY += static_cast&lt;int&gt;(m_overflowAutoScrollDelta);
 625             selectionPosition.setY(view-&gt;scrollY() + view-&gt;visibleHeight() + scrollBoundsAdjustment);
 626         }
 627     }
 628 
 629     Ref&lt;Frame&gt; protectedThis(*this);
 630 
 631     if (action == PerformOverflowScroll &amp;&amp; (deltaX || deltaY)) {
 632         layer-&gt;scrollToOffset(layer-&gt;scrollOffset() + IntSize(deltaX, deltaY), ScrollClamping::Unclamped);
 633 
 634         // Handle making selection.
 635         VisiblePosition visiblePosition(renderer-&gt;positionForPoint(selectionPosition, nullptr));
 636         if (visiblePosition.isNotNull()) {
 637             VisibleSelection visibleSelection = selection().selection();
 638             visibleSelection.setExtent(visiblePosition);
 639             if (selection().granularity() != CharacterGranularity)
 640                 visibleSelection.expandUsingGranularity(selection().granularity());
 641             if (selection().shouldChangeSelection(visibleSelection))
 642                 selection().setSelection(visibleSelection);
 643         }
 644 
 645         m_overflowAutoScrollDelta *= 1.02f; // Accelerate the scroll
 646     }
 647     return scrollType;
 648 }
 649 
 650 void Frame::setSelectionChangeCallbacksDisabled(bool selectionChangeCallbacksDisabled)
 651 {
 652     m_selectionChangeCallbacksDisabled = selectionChangeCallbacksDisabled;
 653 }
 654 
 655 bool Frame::selectionChangeCallbacksDisabled() const
 656 {
 657     return m_selectionChangeCallbacksDisabled;
 658 }
 659 #endif // PLATFORM(IOS_FAMILY)
 660 
 661 void Frame::setPrinting(bool printing, const FloatSize&amp; pageSize, const FloatSize&amp; originalPageSize, float maximumShrinkRatio, AdjustViewSizeOrNot shouldAdjustViewSize)
 662 {
 663     if (!view())
 664         return;
 665     // In setting printing, we should not validate resources already cached for the document.
 666     // See https://bugs.webkit.org/show_bug.cgi?id=43704
 667     ResourceCacheValidationSuppressor validationSuppressor(m_doc-&gt;cachedResourceLoader());
 668 
 669     m_doc-&gt;setPrinting(printing);
 670     auto&amp; frameView = *view();
 671     frameView.adjustMediaTypeForPrinting(printing);
 672 
 673     m_doc-&gt;styleScope().didChangeStyleSheetEnvironment();
 674     if (shouldUsePrintingLayout())
 675         frameView.forceLayoutForPagination(pageSize, originalPageSize, maximumShrinkRatio, shouldAdjustViewSize);
 676     else {
 677         frameView.forceLayout();
 678         if (shouldAdjustViewSize == AdjustViewSize)
 679             frameView.adjustViewSize();
 680     }
 681 
 682     // Subframes of the one we&#39;re printing don&#39;t lay out to the page size.
 683     for (RefPtr&lt;Frame&gt; child = tree().firstChild(); child; child = child-&gt;tree().nextSibling())
 684         child-&gt;setPrinting(printing, FloatSize(), FloatSize(), 0, shouldAdjustViewSize);
 685 }
 686 
 687 bool Frame::shouldUsePrintingLayout() const
 688 {
 689     // Only top frame being printed should be fit to page size.
 690     // Subframes should be constrained by parents only.
 691     return m_doc-&gt;printing() &amp;&amp; (!tree().parent() || !tree().parent()-&gt;m_doc-&gt;printing());
 692 }
 693 
 694 FloatSize Frame::resizePageRectsKeepingRatio(const FloatSize&amp; originalSize, const FloatSize&amp; expectedSize)
 695 {
 696     FloatSize resultSize;
 697     if (!contentRenderer())
 698         return FloatSize();
 699 
 700     if (contentRenderer()-&gt;style().isHorizontalWritingMode()) {
 701         ASSERT(fabs(originalSize.width()) &gt; std::numeric_limits&lt;float&gt;::epsilon());
 702         float ratio = originalSize.height() / originalSize.width();
 703         resultSize.setWidth(floorf(expectedSize.width()));
 704         resultSize.setHeight(floorf(resultSize.width() * ratio));
 705     } else {
 706         ASSERT(fabs(originalSize.height()) &gt; std::numeric_limits&lt;float&gt;::epsilon());
 707         float ratio = originalSize.width() / originalSize.height();
 708         resultSize.setHeight(floorf(expectedSize.height()));
 709         resultSize.setWidth(floorf(resultSize.height() * ratio));
 710     }
 711     return resultSize;
 712 }
 713 
 714 void Frame::injectUserScripts(UserScriptInjectionTime injectionTime)
 715 {
 716     if (!m_page)
 717         return;
 718 
 719     if (loader().stateMachine().creatingInitialEmptyDocument() &amp;&amp; !settings().shouldInjectUserScriptsInInitialEmptyDocument())
 720         return;
 721 
 722     m_page-&gt;userContentProvider().forEachUserScript([this, protectedThis = makeRef(*this), injectionTime](DOMWrapperWorld&amp; world, const UserScript&amp; script) {
 723         if (script.injectionTime() == injectionTime)
 724             injectUserScriptImmediately(world, script);
 725     });
 726 }
 727 
 728 void Frame::injectUserScriptImmediately(DOMWrapperWorld&amp; world, const UserScript&amp; script)
 729 {
 730     auto* document = this-&gt;document();
 731     if (!document)
 732         return;
 733     if (script.injectedFrames() == InjectInTopFrameOnly &amp;&amp; !isMainFrame())
 734         return;
 735     if (!UserContentURLPattern::matchesPatterns(document-&gt;url(), script.whitelist(), script.blacklist()))
 736         return;
 737 
 738     document-&gt;topDocument().setAsRunningUserScripts();
 739     loader().client().willInjectUserScript(world);
 740     m_script-&gt;evaluateInWorld(ScriptSourceCode(script.source(), URL(script.url())), world);
 741 }
 742 
 743 RenderView* Frame::contentRenderer() const
 744 {
 745     return document() ? document()-&gt;renderView() : nullptr;
 746 }
 747 
 748 RenderWidget* Frame::ownerRenderer() const
 749 {
 750     auto* ownerElement = m_ownerElement;
 751     if (!ownerElement)
 752         return nullptr;
 753     auto* object = ownerElement-&gt;renderer();
 754     // FIXME: If &lt;object&gt; is ever fixed to disassociate itself from frames
 755     // that it has started but canceled, then this can turn into an ASSERT
 756     // since m_ownerElement would be nullptr when the load is canceled.
 757     // https://bugs.webkit.org/show_bug.cgi?id=18585
 758     if (!is&lt;RenderWidget&gt;(object))
 759         return nullptr;
 760     return downcast&lt;RenderWidget&gt;(object);
 761 }
 762 
 763 Frame* Frame::frameForWidget(const Widget&amp; widget)
 764 {
 765     if (auto* renderer = RenderWidget::find(widget))
 766         return renderer-&gt;frameOwnerElement().document().frame();
 767 
 768     // Assume all widgets are either a FrameView or owned by a RenderWidget.
 769     // FIXME: That assumption is not right for scroll bars!
 770     return &amp;downcast&lt;FrameView&gt;(widget).frame();
 771 }
 772 
 773 void Frame::clearTimers(FrameView *view, Document *document)
 774 {
 775     if (view) {
 776         view-&gt;layoutContext().unscheduleLayout();
 777         if (RuntimeEnabledFeatures::sharedFeatures().webAnimationsCSSIntegrationEnabled()) {
 778             if (auto* timeline = document-&gt;existingTimeline())
 779                 timeline-&gt;suspendAnimations();
 780         } else
 781             view-&gt;frame().animation().suspendAnimationsForDocument(document);
 782         view-&gt;frame().eventHandler().stopAutoscrollTimer();
 783     }
 784 }
 785 
 786 void Frame::clearTimers()
 787 {
 788     clearTimers(m_view.get(), document());
 789 }
 790 
 791 void Frame::willDetachPage()
 792 {
 793     if (Frame* parent = tree().parent())
 794         parent-&gt;loader().checkLoadComplete();
 795 
 796     for (auto&amp; observer : m_destructionObservers)
 797         observer-&gt;willDetachPage();
 798 
 799     // FIXME: It&#39;s unclear as to why this is called more than once, but it is,
 800     // so page() could be NULL.
 801     if (page() &amp;&amp; page()-&gt;focusController().focusedFrame() == this)
 802         page()-&gt;focusController().setFocusedFrame(nullptr);
 803 
 804     if (page() &amp;&amp; page()-&gt;scrollingCoordinator() &amp;&amp; m_view)
 805         page()-&gt;scrollingCoordinator()-&gt;willDestroyScrollableArea(*m_view);
 806 
 807 #if PLATFORM(IOS_FAMILY)
 808     if (WebThreadCountOfObservedDOMTimers() &gt; 0 &amp;&amp; m_page) {
 809         LOG(ContentObservation, &quot;Frame::willDetachPage: remove registered timers.&quot;);
 810         m_page-&gt;chrome().client().clearContentChangeObservers(*this);
 811     }
 812 #endif
 813 
 814     script().clearScriptObjects();
 815     script().updatePlatformScriptObjects();
 816 
 817     // We promise that the Frame is always connected to a Page while the render tree is live.
 818     //
 819     // The render tree can be torn down in a few different ways, but the two important ones are:
 820     //
 821     // - When calling Frame::setView() with a null FrameView*. This is always done before calling
 822     //   Frame::willDetachPage (this function.) Hence the assertion below.
 823     //
 824     // - When adding a document to the page cache, the tree is torn down before instantiating
 825     //   the CachedPage+CachedFrame object tree.
 826     ASSERT(!document() || !document()-&gt;renderView());
 827 }
 828 
 829 void Frame::disconnectOwnerElement()
 830 {
 831     if (m_ownerElement) {
 832         m_ownerElement-&gt;clearContentFrame();
 833         if (m_page)
 834             m_page-&gt;decrementSubframeCount();
 835     }
 836     m_ownerElement = nullptr;
 837 
 838     if (auto* document = this-&gt;document())
 839         document-&gt;frameWasDisconnectedFromOwner();
 840 }
 841 
 842 String Frame::displayStringModifiedByEncoding(const String&amp; str) const
 843 {
 844     return document() ? document()-&gt;displayStringModifiedByEncoding(str) : str;
 845 }
 846 
 847 VisiblePosition Frame::visiblePositionForPoint(const IntPoint&amp; framePoint) const
 848 {
 849     HitTestResult result = eventHandler().hitTestResultAtPoint(framePoint, HitTestRequest::ReadOnly | HitTestRequest::Active);
 850     Node* node = result.innerNonSharedNode();
 851     if (!node)
 852         return VisiblePosition();
 853     auto renderer = node-&gt;renderer();
 854     if (!renderer)
 855         return VisiblePosition();
 856     VisiblePosition visiblePos = renderer-&gt;positionForPoint(result.localPoint(), nullptr);
 857     if (visiblePos.isNull())
 858         visiblePos = firstPositionInOrBeforeNode(node);
 859     return visiblePos;
 860 }
 861 
 862 Document* Frame::documentAtPoint(const IntPoint&amp; point)
 863 {
 864     if (!view())
 865         return nullptr;
 866 
 867     IntPoint pt = view()-&gt;windowToContents(point);
 868     HitTestResult result = HitTestResult(pt);
 869 
 870     if (contentRenderer())
 871         result = eventHandler().hitTestResultAtPoint(pt);
 872     return result.innerNode() ? &amp;result.innerNode()-&gt;document() : 0;
 873 }
 874 
 875 RefPtr&lt;Range&gt; Frame::rangeForPoint(const IntPoint&amp; framePoint)
 876 {
 877     VisiblePosition position = visiblePositionForPoint(framePoint);
 878     if (position.isNull())
 879         return nullptr;
 880 
 881     Position deepPosition = position.deepEquivalent();
 882     Text* containerText = deepPosition.containerText();
 883     if (!containerText || !containerText-&gt;renderer() || containerText-&gt;renderer()-&gt;style().userSelect() == UserSelect::None)
 884         return nullptr;
 885 
 886     VisiblePosition previous = position.previous();
 887     if (previous.isNotNull()) {
 888         RefPtr&lt;Range&gt; previousCharacterRange = makeRange(previous, position);
 889         LayoutRect rect = editor().firstRectForRange(previousCharacterRange.get());
 890         if (rect.contains(framePoint))
 891             return previousCharacterRange;
 892     }
 893 
 894     VisiblePosition next = position.next();
 895     if (RefPtr&lt;Range&gt; nextCharacterRange = makeRange(position, next)) {
 896         LayoutRect rect = editor().firstRectForRange(nextCharacterRange.get());
 897         if (rect.contains(framePoint))
 898             return nextCharacterRange;
 899     }
 900 
 901     return nullptr;
 902 }
 903 
 904 void Frame::createView(const IntSize&amp; viewportSize, const Optional&lt;Color&gt;&amp; backgroundColor,
 905     const IntSize&amp; fixedLayoutSize, const IntRect&amp; fixedVisibleContentRect,
 906     bool useFixedLayout, ScrollbarMode horizontalScrollbarMode, bool horizontalLock,
 907     ScrollbarMode verticalScrollbarMode, bool verticalLock)
 908 {
 909     ASSERT(m_page);
 910 
 911     bool isMainFrame = this-&gt;isMainFrame();
 912 
 913     if (isMainFrame &amp;&amp; view())
 914         view()-&gt;setParentVisible(false);
 915 
 916     setView(nullptr);
 917 
 918     RefPtr&lt;FrameView&gt; frameView;
 919     if (isMainFrame) {
 920         frameView = FrameView::create(*this, viewportSize);
 921         frameView-&gt;setFixedLayoutSize(fixedLayoutSize);
 922 #if USE(COORDINATED_GRAPHICS)
 923         frameView-&gt;setFixedVisibleContentRect(fixedVisibleContentRect);
 924 #else
 925         UNUSED_PARAM(fixedVisibleContentRect);
 926 #endif
 927         frameView-&gt;setUseFixedLayout(useFixedLayout);
 928     } else
 929         frameView = FrameView::create(*this);
 930 
 931     frameView-&gt;setScrollbarModes(horizontalScrollbarMode, verticalScrollbarMode, horizontalLock, verticalLock);
 932 
 933     setView(frameView.copyRef());
 934 
 935     frameView-&gt;updateBackgroundRecursively(backgroundColor);
 936 
 937     if (isMainFrame)
 938         frameView-&gt;setParentVisible(true);
 939 
 940     if (ownerRenderer())
 941         ownerRenderer()-&gt;setWidget(frameView);
 942 
 943     if (HTMLFrameOwnerElement* owner = ownerElement())
 944         view()-&gt;setCanHaveScrollbars(owner-&gt;scrollingMode() != ScrollbarAlwaysOff);
 945 }
 946 
 947 DOMWindow* Frame::window() const
 948 {
 949     return document() ? document()-&gt;domWindow() : nullptr;
 950 }
 951 
 952 AbstractDOMWindow* Frame::virtualWindow() const
 953 {
 954     return window();
 955 }
 956 
 957 String Frame::layerTreeAsText(LayerTreeFlags flags) const
 958 {
 959     document()-&gt;updateLayout();
 960 
 961     if (!contentRenderer())
 962         return String();
 963 
 964     return contentRenderer()-&gt;compositor().layerTreeAsText(flags);
 965 }
 966 
 967 String Frame::trackedRepaintRectsAsText() const
 968 {
 969     if (!m_view)
 970         return String();
 971     return m_view-&gt;trackedRepaintRectsAsText();
 972 }
 973 
 974 void Frame::setPageZoomFactor(float factor)
 975 {
 976     setPageAndTextZoomFactors(factor, m_textZoomFactor);
 977 }
 978 
 979 void Frame::setTextZoomFactor(float factor)
 980 {
 981     setPageAndTextZoomFactors(m_pageZoomFactor, factor);
 982 }
 983 
 984 void Frame::setPageAndTextZoomFactors(float pageZoomFactor, float textZoomFactor)
 985 {
 986     if (m_pageZoomFactor == pageZoomFactor &amp;&amp; m_textZoomFactor == textZoomFactor)
 987         return;
 988 
 989     Page* page = this-&gt;page();
 990     if (!page)
 991         return;
 992 
 993     Document* document = this-&gt;document();
 994     if (!document)
 995         return;
 996 
 997     m_editor-&gt;dismissCorrectionPanelAsIgnored();
 998 
 999     // Respect SVGs zoomAndPan=&quot;disabled&quot; property in standalone SVG documents.
1000     // FIXME: How to handle compound documents + zoomAndPan=&quot;disabled&quot;? Needs SVG WG clarification.
1001     if (is&lt;SVGDocument&gt;(*document) &amp;&amp; !downcast&lt;SVGDocument&gt;(*document).zoomAndPanEnabled())
1002         return;
1003 
1004     if (m_pageZoomFactor != pageZoomFactor) {
1005         if (FrameView* view = this-&gt;view()) {
1006             // Update the scroll position when doing a full page zoom, so the content stays in relatively the same position.
1007             LayoutPoint scrollPosition = view-&gt;scrollPosition();
1008             float percentDifference = (pageZoomFactor / m_pageZoomFactor);
1009             view-&gt;setScrollPosition(IntPoint(scrollPosition.x() * percentDifference, scrollPosition.y() * percentDifference));
1010         }
1011     }
1012 
1013     m_pageZoomFactor = pageZoomFactor;
1014     m_textZoomFactor = textZoomFactor;
1015 
1016     document-&gt;resolveStyle(Document::ResolveStyleType::Rebuild);
1017 
1018     for (RefPtr&lt;Frame&gt; child = tree().firstChild(); child; child = child-&gt;tree().nextSibling())
1019         child-&gt;setPageAndTextZoomFactors(m_pageZoomFactor, m_textZoomFactor);
1020 
1021     if (FrameView* view = this-&gt;view()) {
1022         if (document-&gt;renderView() &amp;&amp; document-&gt;renderView()-&gt;needsLayout() &amp;&amp; view-&gt;didFirstLayout())
1023             view-&gt;layoutContext().layout();
1024     }
1025 }
1026 
1027 float Frame::frameScaleFactor() const
1028 {
1029     Page* page = this-&gt;page();
1030 
1031     // Main frame is scaled with respect to he container but inner frames are not scaled with respect to the main frame.
1032     if (!page || &amp;page-&gt;mainFrame() != this || settings().delegatesPageScaling())
1033         return 1;
1034 
1035     return page-&gt;pageScaleFactor();
1036 }
1037 
1038 void Frame::suspendActiveDOMObjectsAndAnimations()
1039 {
1040     bool wasSuspended = activeDOMObjectsAndAnimationsSuspended();
1041 
1042     m_activeDOMObjectsAndAnimationsSuspendedCount++;
1043 
1044     if (wasSuspended)
1045         return;
1046 
1047     // FIXME: Suspend/resume calls will not match if the frame is navigated, and gets a new document.
1048     clearTimers(); // Suspends animations and pending relayouts.
1049     if (m_doc)
1050         m_doc-&gt;suspendScheduledTasks(ReasonForSuspension::PageWillBeSuspended);
1051 }
1052 
1053 void Frame::resumeActiveDOMObjectsAndAnimations()
1054 {
1055     if (!activeDOMObjectsAndAnimationsSuspended())
1056         return;
1057 
1058     m_activeDOMObjectsAndAnimationsSuspendedCount--;
1059 
1060     if (activeDOMObjectsAndAnimationsSuspended())
1061         return;
1062 
1063     if (!m_doc)
1064         return;
1065 
1066     // FIXME: Suspend/resume calls will not match if the frame is navigated, and gets a new document.
1067     m_doc-&gt;resumeScheduledTasks(ReasonForSuspension::PageWillBeSuspended);
1068 
1069     // Frame::clearTimers() suspended animations and pending relayouts.
1070     animation().resumeAnimationsForDocument(m_doc.get());
1071     if (m_view)
1072         m_view-&gt;layoutContext().scheduleLayout();
1073 }
1074 
1075 void Frame::deviceOrPageScaleFactorChanged()
1076 {
1077     for (RefPtr&lt;Frame&gt; child = tree().firstChild(); child; child = child-&gt;tree().nextSibling())
1078         child-&gt;deviceOrPageScaleFactorChanged();
1079 
1080     if (RenderView* root = contentRenderer())
1081         root-&gt;compositor().deviceOrPageScaleFactorChanged();
1082 }
1083 
1084 bool Frame::isURLAllowed(const URL&amp; url) const
1085 {
1086     // We allow one level of self-reference because some sites depend on that,
1087     // but we don&#39;t allow more than one.
1088     if (m_page-&gt;subframeCount() &gt;= Page::maxNumberOfFrames)
1089         return false;
1090     bool foundSelfReference = false;
1091     for (const Frame* frame = this; frame; frame = frame-&gt;tree().parent()) {
1092         if (equalIgnoringFragmentIdentifier(frame-&gt;document()-&gt;url(), url)) {
1093             if (foundSelfReference)
1094                 return false;
1095             foundSelfReference = true;
1096         }
1097     }
1098     return true;
1099 }
1100 
1101 bool Frame::isAlwaysOnLoggingAllowed() const
1102 {
1103     return page() &amp;&amp; page()-&gt;isAlwaysOnLoggingAllowed();
1104 }
1105 
1106 void Frame::dropChildren()
1107 {
1108     ASSERT(isMainFrame());
1109     while (Frame* child = tree().firstChild())
1110         tree().removeChild(*child);
1111 }
1112 
1113 void Frame::selfOnlyRef()
1114 {
1115     ASSERT(isMainFrame());
1116     if (m_selfOnlyRefCount++)
1117         return;
1118 
1119     ref();
1120 }
1121 
1122 void Frame::selfOnlyDeref()
1123 {
1124     ASSERT(isMainFrame());
1125     ASSERT(m_selfOnlyRefCount);
1126     if (--m_selfOnlyRefCount)
1127         return;
1128 
1129     if (hasOneRef())
1130         dropChildren();
1131 
1132     deref();
1133 }
1134 
1135 } // namespace WebCore
    </pre>
  </body>
</html>