<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/IntlObject.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2015 Andy VanWagoner (andy@vanwagoner.family)
  3  * Copyright (C) 2015 Sukolsak Sakshuwong (sukolsak@gmail.com)
<a name="1" id="anc1"></a><span class="line-modified">  4  * Copyright (C) 2016 Apple Inc. All rights reserved.</span>
  5  *
  6  * Redistribution and use in source and binary forms, with or without
  7  * modification, are permitted provided that the following conditions
  8  * are met:
  9  * 1. Redistributions of source code must retain the above copyright
 10  *    notice, this list of conditions and the following disclaimer.
 11  * 2. Redistributions in binary form must reproduce the above copyright
 12  *    notice, this list of conditions and the following disclaimer in the
 13  *    documentation and/or other materials provided with the distribution.
 14  *
 15  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 16  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 17  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 18  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 19  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 20  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 21  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 22  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 23  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 24  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 25  * THE POSSIBILITY OF SUCH DAMAGE.
 26  */
 27 
 28 #include &quot;config.h&quot;
 29 #include &quot;IntlObject.h&quot;
 30 
 31 #if ENABLE(INTL)
 32 
 33 #include &quot;Error.h&quot;
 34 #include &quot;FunctionPrototype.h&quot;
 35 #include &quot;IntlCanonicalizeLanguage.h&quot;
 36 #include &quot;IntlCollatorConstructor.h&quot;
 37 #include &quot;IntlCollatorPrototype.h&quot;
 38 #include &quot;IntlDateTimeFormatConstructor.h&quot;
 39 #include &quot;IntlDateTimeFormatPrototype.h&quot;
 40 #include &quot;IntlNumberFormatConstructor.h&quot;
 41 #include &quot;IntlNumberFormatPrototype.h&quot;
 42 #include &quot;IntlPluralRulesConstructor.h&quot;
 43 #include &quot;IntlPluralRulesPrototype.h&quot;
 44 #include &quot;JSCInlines.h&quot;
 45 #include &quot;JSCJSValueInlines.h&quot;
 46 #include &quot;Lookup.h&quot;
 47 #include &quot;ObjectPrototype.h&quot;
 48 #include &quot;Options.h&quot;
 49 #include &lt;unicode/uloc.h&gt;
 50 #include &lt;unicode/unumsys.h&gt;
 51 #include &lt;wtf/Assertions.h&gt;
 52 #include &lt;wtf/Language.h&gt;
 53 #include &lt;wtf/NeverDestroyed.h&gt;
 54 #include &lt;wtf/text/StringBuilder.h&gt;
 55 
 56 namespace JSC {
 57 
 58 STATIC_ASSERT_IS_TRIVIALLY_DESTRUCTIBLE(IntlObject);
 59 
 60 static EncodedJSValue JSC_HOST_CALL intlObjectFuncGetCanonicalLocales(ExecState*);
 61 
 62 static JSValue createCollatorConstructor(VM&amp; vm, JSObject* object)
 63 {
 64     IntlObject* intlObject = jsCast&lt;IntlObject*&gt;(object);
 65     JSGlobalObject* globalObject = intlObject-&gt;globalObject(vm);
 66     return IntlCollatorConstructor::create(vm, IntlCollatorConstructor::createStructure(vm, globalObject, globalObject-&gt;functionPrototype()), jsCast&lt;IntlCollatorPrototype*&gt;(globalObject-&gt;collatorStructure()-&gt;storedPrototypeObject()));
 67 }
 68 
 69 static JSValue createNumberFormatConstructor(VM&amp; vm, JSObject* object)
 70 {
 71     IntlObject* intlObject = jsCast&lt;IntlObject*&gt;(object);
 72     JSGlobalObject* globalObject = intlObject-&gt;globalObject(vm);
 73     return IntlNumberFormatConstructor::create(vm, IntlNumberFormatConstructor::createStructure(vm, globalObject, globalObject-&gt;functionPrototype()), jsCast&lt;IntlNumberFormatPrototype*&gt;(globalObject-&gt;numberFormatStructure()-&gt;storedPrototypeObject()));
 74 }
 75 
 76 static JSValue createDateTimeFormatConstructor(VM&amp; vm, JSObject* object)
 77 {
 78     IntlObject* intlObject = jsCast&lt;IntlObject*&gt;(object);
 79     JSGlobalObject* globalObject = intlObject-&gt;globalObject(vm);
 80     return IntlDateTimeFormatConstructor::create(vm, IntlDateTimeFormatConstructor::createStructure(vm, globalObject, globalObject-&gt;functionPrototype()), jsCast&lt;IntlDateTimeFormatPrototype*&gt;(globalObject-&gt;dateTimeFormatStructure()-&gt;storedPrototypeObject()));
 81 }
 82 
 83 static JSValue createPluralRulesConstructor(VM&amp; vm, JSObject* object)
 84 {
 85     IntlObject* intlObject = jsCast&lt;IntlObject*&gt;(object);
 86     JSGlobalObject* globalObject = intlObject-&gt;globalObject(vm);
 87     return IntlPluralRulesConstructor::create(vm, IntlPluralRulesConstructor::createStructure(vm, globalObject, globalObject-&gt;functionPrototype()), jsCast&lt;IntlPluralRulesPrototype*&gt;(globalObject-&gt;pluralRulesStructure()-&gt;storedPrototypeObject()));
 88 }
 89 
 90 }
 91 
 92 #include &quot;IntlObject.lut.h&quot;
 93 
 94 namespace JSC {
 95 
 96 /* Source for IntlObject.lut.h
 97 @begin intlObjectTable
 98   getCanonicalLocales   intlObjectFuncGetCanonicalLocales            DontEnum|Function 1
 99   Collator              createCollatorConstructor                    DontEnum|PropertyCallback
100   DateTimeFormat        createDateTimeFormatConstructor              DontEnum|PropertyCallback
101   NumberFormat          createNumberFormatConstructor                DontEnum|PropertyCallback
<a name="2" id="anc2"></a>
102 @end
103 */
104 
105 struct MatcherResult {
106     String locale;
107     String extension;
108     size_t extensionIndex { 0 };
109 };
110 
111 const ClassInfo IntlObject::s_info = { &quot;Object&quot;, &amp;Base::s_info, &amp;intlObjectTable, nullptr, CREATE_METHOD_TABLE(IntlObject) };
112 
113 IntlObject::IntlObject(VM&amp; vm, Structure* structure)
114     : JSNonFinalObject(vm, structure)
115 {
116 }
117 
118 IntlObject* IntlObject::create(VM&amp; vm, Structure* structure)
119 {
120     IntlObject* object = new (NotNull, allocateCell&lt;IntlObject&gt;(vm.heap)) IntlObject(vm, structure);
121     object-&gt;finishCreation(vm);
122     return object;
123 }
124 
<a name="3" id="anc3"></a><span class="line-removed">125 void IntlObject::finishCreation(VM&amp; vm)</span>
<span class="line-removed">126 {</span>
<span class="line-removed">127     Base::finishCreation(vm);</span>
<span class="line-removed">128     ASSERT(inherits(vm, info()));</span>
<span class="line-removed">129 </span>
<span class="line-removed">130     // Constructor Properties of the Intl Object</span>
<span class="line-removed">131     // https://tc39.github.io/ecma402/#sec-constructor-properties-of-the-intl-object</span>
<span class="line-removed">132     if (Options::useIntlPluralRules())</span>
<span class="line-removed">133         putDirectWithoutTransition(vm, vm.propertyNames-&gt;PluralRules, createPluralRulesConstructor(vm, this), static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));</span>
<span class="line-removed">134 }</span>
<span class="line-removed">135 </span>
136 Structure* IntlObject::createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
137 {
138     return Structure::create(vm, globalObject, prototype, TypeInfo(ObjectType, StructureFlags), info());
139 }
140 
141 String convertICULocaleToBCP47LanguageTag(const char* localeID)
142 {
143     UErrorCode status = U_ZERO_ERROR;
144     Vector&lt;char, 32&gt; buffer(32);
145     auto length = uloc_toLanguageTag(localeID, buffer.data(), buffer.size(), false, &amp;status);
146     if (status == U_BUFFER_OVERFLOW_ERROR) {
147         buffer.grow(length);
148         status = U_ZERO_ERROR;
149         uloc_toLanguageTag(localeID, buffer.data(), buffer.size(), false, &amp;status);
150     }
151     if (!U_FAILURE(status))
152         return String(buffer.data(), length);
153     return String();
154 }
155 
156 bool intlBooleanOption(ExecState&amp; state, JSValue options, PropertyName property, bool&amp; usesFallback)
157 {
158     // GetOption (options, property, type=&quot;boolean&quot;, values, fallback)
159     // https://tc39.github.io/ecma402/#sec-getoption
160 
161     VM&amp; vm = state.vm();
162     auto scope = DECLARE_THROW_SCOPE(vm);
163 
164     JSObject* opts = options.toObject(&amp;state);
165     RETURN_IF_EXCEPTION(scope, false);
166 
167     JSValue value = opts-&gt;get(&amp;state, property);
168     RETURN_IF_EXCEPTION(scope, false);
169 
170     if (!value.isUndefined()) {
171         bool booleanValue = value.toBoolean(&amp;state);
172         usesFallback = false;
173         return booleanValue;
174     }
175 
176     // Because fallback can be undefined, we let the caller handle it instead.
177     usesFallback = true;
178     return false;
179 }
180 
181 String intlStringOption(ExecState&amp; state, JSValue options, PropertyName property, std::initializer_list&lt;const char*&gt; values, const char* notFound, const char* fallback)
182 {
183     // GetOption (options, property, type=&quot;string&quot;, values, fallback)
184     // https://tc39.github.io/ecma402/#sec-getoption
185 
186     VM&amp; vm = state.vm();
187     auto scope = DECLARE_THROW_SCOPE(vm);
188 
189     JSObject* opts = options.toObject(&amp;state);
190     RETURN_IF_EXCEPTION(scope, String());
191 
192     JSValue value = opts-&gt;get(&amp;state, property);
193     RETURN_IF_EXCEPTION(scope, String());
194 
195     if (!value.isUndefined()) {
196         String stringValue = value.toWTFString(&amp;state);
197         RETURN_IF_EXCEPTION(scope, String());
198 
199         if (values.size() &amp;&amp; std::find(values.begin(), values.end(), stringValue) == values.end()) {
200             throwException(&amp;state, scope, createRangeError(&amp;state, notFound));
201             return { };
202         }
203         return stringValue;
204     }
205 
206     return fallback;
207 }
208 
209 unsigned intlNumberOption(ExecState&amp; state, JSValue options, PropertyName property, unsigned minimum, unsigned maximum, unsigned fallback)
210 {
211     // GetNumberOption (options, property, minimum, maximum, fallback)
212     // https://tc39.github.io/ecma402/#sec-getnumberoption
213 
214     VM&amp; vm = state.vm();
215     auto scope = DECLARE_THROW_SCOPE(vm);
216 
217     JSObject* opts = options.toObject(&amp;state);
218     RETURN_IF_EXCEPTION(scope, 0);
219 
220     JSValue value = opts-&gt;get(&amp;state, property);
221     RETURN_IF_EXCEPTION(scope, 0);
222 
223     RELEASE_AND_RETURN(scope, intlDefaultNumberOption(state, value, property, minimum, maximum, fallback));
224 }
225 
226 unsigned intlDefaultNumberOption(ExecState&amp; state, JSValue value, PropertyName property, unsigned minimum, unsigned maximum, unsigned fallback)
227 {
228     // DefaultNumberOption (value, minimum, maximum, fallback)
229     // https://tc39.github.io/ecma402/#sec-defaultnumberoption
230 
231     VM&amp; vm = state.vm();
232     auto scope = DECLARE_THROW_SCOPE(vm);
233 
234     if (!value.isUndefined()) {
235         double doubleValue = value.toNumber(&amp;state);
236         RETURN_IF_EXCEPTION(scope, 0);
237 
238         if (!(doubleValue &gt;= minimum &amp;&amp; doubleValue &lt;= maximum)) {
239             throwException(&amp;state, scope, createRangeError(&amp;state, *property.publicName() + &quot; is out of range&quot;));
240             return 0;
241         }
242         return static_cast&lt;unsigned&gt;(doubleValue);
243     }
244     return fallback;
245 }
246 
247 static String privateUseLangTag(const Vector&lt;String&gt;&amp; parts, size_t startIndex)
248 {
249     size_t numParts = parts.size();
250     size_t currentIndex = startIndex;
251 
252     // Check for privateuse.
253     // privateuse = &quot;x&quot; 1*(&quot;-&quot; (1*8alphanum))
254     StringBuilder privateuse;
255     while (currentIndex &lt; numParts) {
256         const String&amp; singleton = parts[currentIndex];
257         unsigned singletonLength = singleton.length();
258         bool isValid = (singletonLength == 1 &amp;&amp; (singleton == &quot;x&quot; || singleton == &quot;X&quot;));
259         if (!isValid)
260             break;
261 
262         if (currentIndex != startIndex)
263             privateuse.append(&#39;-&#39;);
264 
265         ++currentIndex;
266         unsigned numExtParts = 0;
267         privateuse.append(&#39;x&#39;);
268         while (currentIndex &lt; numParts) {
269             const String&amp; extPart = parts[currentIndex];
270             unsigned extPartLength = extPart.length();
271 
272             bool isValid = (extPartLength &gt;= 1 &amp;&amp; extPartLength &lt;= 8 &amp;&amp; extPart.isAllSpecialCharacters&lt;isASCIIAlphanumeric&gt;());
273             if (!isValid)
274                 break;
275 
276             ++currentIndex;
277             ++numExtParts;
278             privateuse.append(&#39;-&#39;);
279             privateuse.append(extPart.convertToASCIILowercase());
280         }
281 
282         // Requires at least one production.
283         if (!numExtParts)
284             return String();
285     }
286 
287     // Leftovers makes it invalid.
288     if (currentIndex &lt; numParts)
289         return String();
290 
291     return privateuse.toString();
292 }
293 
294 static String preferredLanguage(const String&amp; language)
295 {
296     auto preferred = intlPreferredLanguageTag(language);
297     if (!preferred.isNull())
298         return preferred;
299     return language;
300 }
301 
302 static String preferredRegion(const String&amp; region)
303 {
304     auto preferred = intlPreferredRegionTag(region);
305     if (!preferred.isNull())
306         return preferred;
307     return region;
308 
309 }
310 
311 static String canonicalLangTag(const Vector&lt;String&gt;&amp; parts)
312 {
313     ASSERT(!parts.isEmpty());
314 
315     // Follows the grammar at https://www.rfc-editor.org/rfc/bcp/bcp47.txt
316     // langtag = language [&quot;-&quot; script] [&quot;-&quot; region] *(&quot;-&quot; variant) *(&quot;-&quot; extension) [&quot;-&quot; privateuse]
317 
318     size_t numParts = parts.size();
319     // Check for language.
320     // language = 2*3ALPHA [&quot;-&quot; extlang] / 4ALPHA / 5*8ALPHA
321     size_t currentIndex = 0;
322     const String&amp; language = parts[currentIndex];
323     unsigned languageLength = language.length();
324     bool canHaveExtlang = languageLength &gt;= 2 &amp;&amp; languageLength &lt;= 3;
325     bool isValidLanguage = languageLength &gt;= 2 &amp;&amp; languageLength &lt;= 8 &amp;&amp; language.isAllSpecialCharacters&lt;isASCIIAlpha&gt;();
326     if (!isValidLanguage)
327         return String();
328 
329     ++currentIndex;
330     StringBuilder canonical;
331 
332     const String langtag = preferredLanguage(language.convertToASCIILowercase());
333     canonical.append(langtag);
334 
335     // Check for extlang.
336     // extlang = 3ALPHA *2(&quot;-&quot; 3ALPHA)
337     if (canHaveExtlang) {
338         for (unsigned times = 0; times &lt; 3 &amp;&amp; currentIndex &lt; numParts; ++times) {
339             const String&amp; extlang = parts[currentIndex];
340             unsigned extlangLength = extlang.length();
341             if (extlangLength == 3 &amp;&amp; extlang.isAllSpecialCharacters&lt;isASCIIAlpha&gt;()) {
342                 ++currentIndex;
343                 auto extlangLower = extlang.convertToASCIILowercase();
344                 if (!times &amp;&amp; intlPreferredExtlangTag(extlangLower) == langtag) {
345                     canonical.clear();
346                     canonical.append(extlangLower);
347                     continue;
348                 }
349                 canonical.append(&#39;-&#39;);
350                 canonical.append(extlangLower);
351             } else
352                 break;
353         }
354     }
355 
356     // Check for script.
357     // script = 4ALPHA
358     if (currentIndex &lt; numParts) {
359         const String&amp; script = parts[currentIndex];
360         unsigned scriptLength = script.length();
361         if (scriptLength == 4 &amp;&amp; script.isAllSpecialCharacters&lt;isASCIIAlpha&gt;()) {
362             ++currentIndex;
363             canonical.append(&#39;-&#39;);
364             canonical.append(toASCIIUpper(script[0]));
365             canonical.append(script.substring(1, 3).convertToASCIILowercase());
366         }
367     }
368 
369     // Check for region.
370     // region = 2ALPHA / 3DIGIT
371     if (currentIndex &lt; numParts) {
372         const String&amp; region = parts[currentIndex];
373         unsigned regionLength = region.length();
374         bool isValidRegion = (
375             (regionLength == 2 &amp;&amp; region.isAllSpecialCharacters&lt;isASCIIAlpha&gt;())
376             || (regionLength == 3 &amp;&amp; region.isAllSpecialCharacters&lt;isASCIIDigit&gt;())
377         );
378         if (isValidRegion) {
379             ++currentIndex;
380             canonical.append(&#39;-&#39;);
381             canonical.append(preferredRegion(region.convertToASCIIUppercase()));
382         }
383     }
384 
385     // Check for variant.
386     // variant = 5*8alphanum / (DIGIT 3alphanum)
387     HashSet&lt;String&gt; subtags;
388     while (currentIndex &lt; numParts) {
389         const String&amp; variant = parts[currentIndex];
390         unsigned variantLength = variant.length();
391         bool isValidVariant = (
392             (variantLength &gt;= 5 &amp;&amp; variantLength &lt;= 8 &amp;&amp; variant.isAllSpecialCharacters&lt;isASCIIAlphanumeric&gt;())
393             || (variantLength == 4 &amp;&amp; isASCIIDigit(variant[0]) &amp;&amp; variant.substring(1, 3).isAllSpecialCharacters&lt;isASCIIAlphanumeric&gt;())
394         );
395         if (!isValidVariant)
396             break;
397 
398         // Cannot include duplicate subtags (case insensitive).
399         String lowerVariant = variant.convertToASCIILowercase();
400         if (!subtags.add(lowerVariant).isNewEntry)
401             return String();
402 
403         ++currentIndex;
404 
405         // Reordering variant subtags is not required in the spec.
406         canonical.append(&#39;-&#39;);
407         canonical.append(lowerVariant);
408     }
409 
410     // Check for extension.
411     // extension = singleton 1*(&quot;-&quot; (2*8alphanum))
412     // singleton = alphanum except x or X
413     subtags.clear();
414     Vector&lt;String&gt; extensions;
415     while (currentIndex &lt; numParts) {
416         const String&amp; possibleSingleton = parts[currentIndex];
417         unsigned singletonLength = possibleSingleton.length();
418         bool isValidSingleton = (singletonLength == 1 &amp;&amp; possibleSingleton != &quot;x&quot; &amp;&amp; possibleSingleton != &quot;X&quot; &amp;&amp; isASCIIAlphanumeric(possibleSingleton[0]));
419         if (!isValidSingleton)
420             break;
421 
422         // Cannot include duplicate singleton (case insensitive).
423         String singleton = possibleSingleton.convertToASCIILowercase();
424         if (!subtags.add(singleton).isNewEntry)
425             return String();
426 
427         ++currentIndex;
428         int numExtParts = 0;
429         StringBuilder extension;
430         extension.append(singleton);
431         while (currentIndex &lt; numParts) {
432             const String&amp; extPart = parts[currentIndex];
433             unsigned extPartLength = extPart.length();
434 
435             bool isValid = (extPartLength &gt;= 2 &amp;&amp; extPartLength &lt;= 8 &amp;&amp; extPart.isAllSpecialCharacters&lt;isASCIIAlphanumeric&gt;());
436             if (!isValid)
437                 break;
438 
439             ++currentIndex;
440             ++numExtParts;
441             extension.append(&#39;-&#39;);
442             extension.append(extPart.convertToASCIILowercase());
443         }
444 
445         // Requires at least one production.
446         if (!numExtParts)
447             return String();
448 
449         extensions.append(extension.toString());
450     }
451 
452     // Add extensions to canonical sorted by singleton.
453     std::sort(
454         extensions.begin(),
455         extensions.end(),
456         [] (const String&amp; a, const String&amp; b) -&gt; bool {
457             return a[0] &lt; b[0];
458         }
459     );
460     size_t numExtenstions = extensions.size();
461     for (size_t i = 0; i &lt; numExtenstions; ++i) {
462         canonical.append(&#39;-&#39;);
463         canonical.append(extensions[i]);
464     }
465 
466     // Check for privateuse.
467     if (currentIndex &lt; numParts) {
468         String privateuse = privateUseLangTag(parts, currentIndex);
469         if (privateuse.isNull())
470             return String();
471         canonical.append(&#39;-&#39;);
472         canonical.append(privateuse);
473     }
474 
475     const String tag = canonical.toString();
476     const String preferred = intlRedundantLanguageTag(tag);
477     if (!preferred.isNull())
478         return preferred;
479     return tag;
480 }
481 
482 static String canonicalizeLanguageTag(const String&amp; locale)
483 {
484     // IsStructurallyValidLanguageTag (locale)
485     // CanonicalizeLanguageTag (locale)
486     // These are done one after another in CanonicalizeLocaleList, so they are combined here to reduce duplication.
487     // https://www.rfc-editor.org/rfc/bcp/bcp47.txt
488 
489     // Language-Tag = langtag / privateuse / grandfathered
490     String grandfather = intlGrandfatheredLanguageTag(locale.convertToASCIILowercase());
491     if (!grandfather.isNull())
492         return grandfather;
493 
494     Vector&lt;String&gt; parts = locale.splitAllowingEmptyEntries(&#39;-&#39;);
495     if (!parts.isEmpty()) {
496         String langtag = canonicalLangTag(parts);
497         if (!langtag.isNull())
498             return langtag;
499 
500         String privateuse = privateUseLangTag(parts, 0);
501         if (!privateuse.isNull())
502             return privateuse;
503     }
504 
505     return String();
506 }
507 
508 Vector&lt;String&gt; canonicalizeLocaleList(ExecState&amp; state, JSValue locales)
509 {
510     // CanonicalizeLocaleList (locales)
511     // https://tc39.github.io/ecma402/#sec-canonicalizelocalelist
512 
513     VM&amp; vm = state.vm();
514     auto scope = DECLARE_THROW_SCOPE(vm);
515 
516     JSGlobalObject* globalObject = state.jsCallee()-&gt;globalObject(vm);
517     Vector&lt;String&gt; seen;
518 
519     if (locales.isUndefined())
520         return seen;
521 
522     JSObject* localesObject;
523     if (locales.isString()) {
524         JSArray* localesArray = JSArray::tryCreate(vm, globalObject-&gt;arrayStructureForIndexingTypeDuringAllocation(ArrayWithContiguous));
525         if (!localesArray) {
526             throwOutOfMemoryError(&amp;state, scope);
527             RETURN_IF_EXCEPTION(scope, Vector&lt;String&gt;());
528         }
529         localesArray-&gt;push(&amp;state, locales);
530         RETURN_IF_EXCEPTION(scope, Vector&lt;String&gt;());
531 
532         localesObject = localesArray;
533     } else {
534         localesObject = locales.toObject(&amp;state);
535         RETURN_IF_EXCEPTION(scope, Vector&lt;String&gt;());
536     }
537 
538     // 6. Let len be ToLength(Get(O, &quot;length&quot;)).
539     JSValue lengthProperty = localesObject-&gt;get(&amp;state, vm.propertyNames-&gt;length);
540     RETURN_IF_EXCEPTION(scope, Vector&lt;String&gt;());
541 
542     double length = lengthProperty.toLength(&amp;state);
543     RETURN_IF_EXCEPTION(scope, Vector&lt;String&gt;());
544 
545     HashSet&lt;String&gt; seenSet;
546     for (double k = 0; k &lt; length; ++k) {
547         bool kPresent = localesObject-&gt;hasProperty(&amp;state, k);
548         RETURN_IF_EXCEPTION(scope, Vector&lt;String&gt;());
549 
550         if (kPresent) {
551             JSValue kValue = localesObject-&gt;get(&amp;state, k);
552             RETURN_IF_EXCEPTION(scope, Vector&lt;String&gt;());
553 
554             if (!kValue.isString() &amp;&amp; !kValue.isObject()) {
555                 throwTypeError(&amp;state, scope, &quot;locale value must be a string or object&quot;_s);
556                 return Vector&lt;String&gt;();
557             }
558 
559             JSString* tag = kValue.toString(&amp;state);
560             RETURN_IF_EXCEPTION(scope, Vector&lt;String&gt;());
561 
<a name="4" id="anc4"></a><span class="line-modified">562             String canonicalizedTag = canonicalizeLanguageTag(tag-&gt;value(&amp;state));</span>



563             if (canonicalizedTag.isNull()) {
<a name="5" id="anc5"></a><span class="line-modified">564                 throwException(&amp;state, scope, createRangeError(&amp;state, &quot;invalid language tag: &quot; + tag-&gt;value(&amp;state)));</span>
565                 return Vector&lt;String&gt;();
566             }
567 
568             if (seenSet.add(canonicalizedTag).isNewEntry)
569                 seen.append(canonicalizedTag);
570         }
571     }
572 
573     return seen;
574 }
575 
576 String bestAvailableLocale(const HashSet&lt;String&gt;&amp; availableLocales, const String&amp; locale)
577 {
578     // BestAvailableLocale (availableLocales, locale)
579     // https://tc39.github.io/ecma402/#sec-bestavailablelocale
580 
581     String candidate = locale;
582     while (!candidate.isEmpty()) {
583         if (availableLocales.contains(candidate))
584             return candidate;
585 
586         size_t pos = candidate.reverseFind(&#39;-&#39;);
587         if (pos == notFound)
588             return String();
589 
590         if (pos &gt;= 2 &amp;&amp; candidate[pos - 2] == &#39;-&#39;)
591             pos -= 2;
592 
593         candidate = candidate.substring(0, pos);
594     }
595 
596     return String();
597 }
598 
599 String defaultLocale(ExecState&amp; state)
600 {
601     // DefaultLocale ()
602     // https://tc39.github.io/ecma402/#sec-defaultlocale
603 
604     // WebCore&#39;s global objects will have their own ideas of how to determine the language. It may
605     // be determined by WebCore-specific logic like some WK settings. Usually this will return the
606     // same thing as userPreferredLanguages()[0].
607     VM&amp; vm = state.vm();
608     if (auto defaultLanguage = state.jsCallee()-&gt;globalObject(vm)-&gt;globalObjectMethodTable()-&gt;defaultLanguage) {
609         String locale = canonicalizeLanguageTag(defaultLanguage());
610         if (!locale.isEmpty())
611             return locale;
612     }
613 
614     Vector&lt;String&gt; languages = userPreferredLanguages();
615     for (const auto&amp; language : languages) {
616         String locale = canonicalizeLanguageTag(language);
617         if (!locale.isEmpty())
618             return locale;
619     }
620 
621     // If all else fails, ask ICU. It will probably say something bogus like en_us even if the user
622     // has configured some other language, but being wrong is better than crashing.
623     String locale = convertICULocaleToBCP47LanguageTag(uloc_getDefault());
624     if (!locale.isEmpty())
625         return locale;
626 
627     return &quot;en&quot;_s;
628 }
629 
630 String removeUnicodeLocaleExtension(const String&amp; locale)
631 {
632     Vector&lt;String&gt; parts = locale.split(&#39;-&#39;);
633     StringBuilder builder;
634     size_t partsSize = parts.size();
635     bool atPrivate = false;
636     if (partsSize &gt; 0)
637         builder.append(parts[0]);
638     for (size_t p = 1; p &lt; partsSize; ++p) {
639         if (parts[p] == &quot;x&quot;)
640             atPrivate = true;
641         if (!atPrivate &amp;&amp; parts[p] == &quot;u&quot; &amp;&amp; p + 1 &lt; partsSize) {
642             // Skip the u- and anything that follows until another singleton.
643             // While the next part is part of the unicode extension, skip it.
644             while (p + 1 &lt; partsSize &amp;&amp; parts[p + 1].length() &gt; 1)
645                 ++p;
646         } else {
647             builder.append(&#39;-&#39;);
648             builder.append(parts[p]);
649         }
650     }
651     return builder.toString();
652 }
653 
654 static MatcherResult lookupMatcher(ExecState&amp; state, const HashSet&lt;String&gt;&amp; availableLocales, const Vector&lt;String&gt;&amp; requestedLocales)
655 {
656     // LookupMatcher (availableLocales, requestedLocales)
657     // https://tc39.github.io/ecma402/#sec-lookupmatcher
658 
659     String locale;
660     String noExtensionsLocale;
661     String availableLocale;
662     for (size_t i = 0; i &lt; requestedLocales.size() &amp;&amp; availableLocale.isNull(); ++i) {
663         locale = requestedLocales[i];
664         noExtensionsLocale = removeUnicodeLocaleExtension(locale);
665         availableLocale = bestAvailableLocale(availableLocales, noExtensionsLocale);
666     }
667 
668     MatcherResult result;
669     if (!availableLocale.isEmpty()) {
670         result.locale = availableLocale;
671         if (locale != noExtensionsLocale) {
672             size_t extensionIndex = locale.find(&quot;-u-&quot;);
673             RELEASE_ASSERT(extensionIndex != notFound);
674 
675             size_t extensionLength = locale.length() - extensionIndex;
676             size_t end = extensionIndex + 3;
677             while (end &lt; locale.length()) {
678                 end = locale.find(&#39;-&#39;, end);
679                 if (end == notFound)
680                     break;
681                 if (end + 2 &lt; locale.length() &amp;&amp; locale[end + 2] == &#39;-&#39;) {
682                     extensionLength = end - extensionIndex;
683                     break;
684                 }
685                 end++;
686             }
687             result.extension = locale.substring(extensionIndex, extensionLength);
688             result.extensionIndex = extensionIndex;
689         }
690     } else
691         result.locale = defaultLocale(state);
692     return result;
693 }
694 
695 static MatcherResult bestFitMatcher(ExecState&amp; state, const HashSet&lt;String&gt;&amp; availableLocales, const Vector&lt;String&gt;&amp; requestedLocales)
696 {
697     // BestFitMatcher (availableLocales, requestedLocales)
698     // https://tc39.github.io/ecma402/#sec-bestfitmatcher
699 
700     // FIXME: Implement something better than lookup.
701     return lookupMatcher(state, availableLocales, requestedLocales);
702 }
703 
704 static void unicodeExtensionSubTags(const String&amp; extension, Vector&lt;String&gt;&amp; subtags)
705 {
706     // UnicodeExtensionSubtags (extension)
707     // https://tc39.github.io/ecma402/#sec-unicodeextensionsubtags
708 
709     auto extensionLength = extension.length();
710     if (extensionLength &lt; 3)
711         return;
712 
713     size_t subtagStart = 3; // Skip initial -u-.
714     size_t valueStart = 3;
715     bool isLeading = true;
716     for (size_t index = subtagStart; index &lt; extensionLength; ++index) {
717         if (extension[index] == &#39;-&#39;) {
718             if (index - subtagStart == 2) {
719                 // Tag is a key, first append prior key&#39;s value if there is one.
720                 if (subtagStart - valueStart &gt; 1)
721                     subtags.append(extension.substring(valueStart, subtagStart - valueStart - 1));
722                 subtags.append(extension.substring(subtagStart, index - subtagStart));
723                 valueStart = index + 1;
724                 isLeading = false;
725             } else if (isLeading) {
726                 // Leading subtags before first key.
727                 subtags.append(extension.substring(subtagStart, index - subtagStart));
728                 valueStart = index + 1;
729             }
730             subtagStart = index + 1;
731         }
732     }
733     if (extensionLength - subtagStart == 2) {
734         // Trailing an extension key, first append prior key&#39;s value if there is one.
735         if (subtagStart - valueStart &gt; 1)
736             subtags.append(extension.substring(valueStart, subtagStart - valueStart - 1));
737         valueStart = subtagStart;
738     }
739     // Append final key&#39;s value.
740     subtags.append(extension.substring(valueStart, extensionLength - valueStart));
741 }
742 
743 HashMap&lt;String, String&gt; resolveLocale(ExecState&amp; state, const HashSet&lt;String&gt;&amp; availableLocales, const Vector&lt;String&gt;&amp; requestedLocales, const HashMap&lt;String, String&gt;&amp; options, const char* const relevantExtensionKeys[], size_t relevantExtensionKeyCount, Vector&lt;String&gt; (*localeData)(const String&amp;, size_t))
744 {
745     // ResolveLocale (availableLocales, requestedLocales, options, relevantExtensionKeys, localeData)
746     // https://tc39.github.io/ecma402/#sec-resolvelocale
747 
748     const String&amp; matcher = options.get(&quot;localeMatcher&quot;_s);
749     MatcherResult matcherResult = (matcher == &quot;lookup&quot;)
750         ? lookupMatcher(state, availableLocales, requestedLocales)
751         : bestFitMatcher(state, availableLocales, requestedLocales);
752 
753     String foundLocale = matcherResult.locale;
754 
755     Vector&lt;String&gt; extensionSubtags;
756     if (!matcherResult.extension.isNull())
757         unicodeExtensionSubTags(matcherResult.extension, extensionSubtags);
758 
759     HashMap&lt;String, String&gt; result;
760     result.add(&quot;dataLocale&quot;_s, foundLocale);
761 
762     String supportedExtension = &quot;-u&quot;_s;
763     for (size_t keyIndex = 0; keyIndex &lt; relevantExtensionKeyCount; ++keyIndex) {
764         const char* key = relevantExtensionKeys[keyIndex];
765         Vector&lt;String&gt; keyLocaleData = localeData(foundLocale, keyIndex);
766         ASSERT(!keyLocaleData.isEmpty());
767 
768         String value = keyLocaleData[0];
769         String supportedExtensionAddition;
770 
771         if (!extensionSubtags.isEmpty()) {
772             size_t keyPos = extensionSubtags.find(key);
773             if (keyPos != notFound) {
774                 if (keyPos + 1 &lt; extensionSubtags.size() &amp;&amp; extensionSubtags[keyPos + 1].length() &gt; 2) {
775                     const String&amp; requestedValue = extensionSubtags[keyPos + 1];
776                     if (keyLocaleData.contains(requestedValue)) {
777                         value = requestedValue;
778                         supportedExtensionAddition = makeString(&#39;-&#39;, key, &#39;-&#39;, value);
779                     }
780                 } else if (keyLocaleData.contains(static_cast&lt;String&gt;(&quot;true&quot;_s))) {
781                     value = &quot;true&quot;_s;
782                 }
783             }
784         }
785 
786         HashMap&lt;String, String&gt;::const_iterator iterator = options.find(key);
787         if (iterator != options.end()) {
788             const String&amp; optionsValue = iterator-&gt;value;
789             // Undefined should not get added to the options, it won&#39;t displace the extension.
790             // Null will remove the extension.
791             if ((optionsValue.isNull() || keyLocaleData.contains(optionsValue)) &amp;&amp; optionsValue != value) {
792                 value = optionsValue;
793                 supportedExtensionAddition = String();
794             }
795         }
796         result.add(key, value);
797         supportedExtension.append(supportedExtensionAddition);
798     }
799 
800     if (supportedExtension.length() &gt; 2) {
801         String preExtension = foundLocale.substring(0, matcherResult.extensionIndex);
802         String postExtension = foundLocale.substring(matcherResult.extensionIndex);
803         foundLocale = preExtension + supportedExtension + postExtension;
804     }
805 
806     result.add(&quot;locale&quot;_s, foundLocale);
807     return result;
808 }
809 
810 static JSArray* lookupSupportedLocales(ExecState&amp; state, const HashSet&lt;String&gt;&amp; availableLocales, const Vector&lt;String&gt;&amp; requestedLocales)
811 {
812     // LookupSupportedLocales (availableLocales, requestedLocales)
813     // https://tc39.github.io/ecma402/#sec-lookupsupportedlocales
814 
815     VM&amp; vm = state.vm();
816     auto scope = DECLARE_THROW_SCOPE(vm);
817 
818     size_t len = requestedLocales.size();
819     JSGlobalObject* globalObject = state.jsCallee()-&gt;globalObject(vm);
820     JSArray* subset = JSArray::tryCreate(vm, globalObject-&gt;arrayStructureForIndexingTypeDuringAllocation(ArrayWithUndecided), 0);
821     if (!subset) {
822         throwOutOfMemoryError(&amp;state, scope);
823         return nullptr;
824     }
825 
826     unsigned index = 0;
827     for (size_t k = 0; k &lt; len; ++k) {
828         const String&amp; locale = requestedLocales[k];
829         String noExtensionsLocale = removeUnicodeLocaleExtension(locale);
830         String availableLocale = bestAvailableLocale(availableLocales, noExtensionsLocale);
831         if (!availableLocale.isNull()) {
<a name="6" id="anc6"></a><span class="line-modified">832             subset-&gt;putDirectIndex(&amp;state, index++, jsString(&amp;state, locale));</span>
833             RETURN_IF_EXCEPTION(scope, nullptr);
834         }
835     }
836 
837     return subset;
838 }
839 
840 static JSArray* bestFitSupportedLocales(ExecState&amp; state, const HashSet&lt;String&gt;&amp; availableLocales, const Vector&lt;String&gt;&amp; requestedLocales)
841 {
842     // BestFitSupportedLocales (availableLocales, requestedLocales)
843     // https://tc39.github.io/ecma402/#sec-bestfitsupportedlocales
844 
845     // FIXME: Implement something better than lookup.
846     return lookupSupportedLocales(state, availableLocales, requestedLocales);
847 }
848 
849 JSValue supportedLocales(ExecState&amp; state, const HashSet&lt;String&gt;&amp; availableLocales, const Vector&lt;String&gt;&amp; requestedLocales, JSValue options)
850 {
851     // SupportedLocales (availableLocales, requestedLocales, options)
852     // https://tc39.github.io/ecma402/#sec-supportedlocales
853 
854     VM&amp; vm = state.vm();
855     auto scope = DECLARE_THROW_SCOPE(vm);
856     String matcher;
857 
858     if (!options.isUndefined()) {
859         matcher = intlStringOption(state, options, vm.propertyNames-&gt;localeMatcher, { &quot;lookup&quot;, &quot;best fit&quot; }, &quot;localeMatcher must be either \&quot;lookup\&quot; or \&quot;best fit\&quot;&quot;, &quot;best fit&quot;);
860         RETURN_IF_EXCEPTION(scope, JSValue());
861     } else
862         matcher = &quot;best fit&quot;_s;
863 
864     JSArray* supportedLocales = (matcher == &quot;best fit&quot;)
865         ? bestFitSupportedLocales(state, availableLocales, requestedLocales)
866         : lookupSupportedLocales(state, availableLocales, requestedLocales);
867     RETURN_IF_EXCEPTION(scope, JSValue());
868 
<a name="7" id="anc7"></a><span class="line-modified">869     PropertyNameArray keys(&amp;vm, PropertyNameMode::Strings, PrivateSymbolMode::Exclude);</span>
870     supportedLocales-&gt;getOwnPropertyNames(supportedLocales, &amp;state, keys, EnumerationMode());
871     RETURN_IF_EXCEPTION(scope, JSValue());
872 
873     PropertyDescriptor desc;
874     desc.setConfigurable(false);
875     desc.setWritable(false);
876 
877     size_t len = keys.size();
878     for (size_t i = 0; i &lt; len; ++i) {
879         supportedLocales-&gt;defineOwnProperty(supportedLocales, &amp;state, keys[i], desc, true);
880         RETURN_IF_EXCEPTION(scope, JSValue());
881     }
882     supportedLocales-&gt;defineOwnProperty(supportedLocales, &amp;state, vm.propertyNames-&gt;length, desc, true);
883     RETURN_IF_EXCEPTION(scope, JSValue());
884 
885     return supportedLocales;
886 }
887 
888 Vector&lt;String&gt; numberingSystemsForLocale(const String&amp; locale)
889 {
890     static NeverDestroyed&lt;Vector&lt;String&gt;&gt; cachedNumberingSystems;
891     Vector&lt;String&gt;&amp; availableNumberingSystems = cachedNumberingSystems.get();
892 
893     if (UNLIKELY(availableNumberingSystems.isEmpty())) {
894         static Lock cachedNumberingSystemsMutex;
895         std::lock_guard&lt;Lock&gt; lock(cachedNumberingSystemsMutex);
896         if (availableNumberingSystems.isEmpty()) {
897             UErrorCode status = U_ZERO_ERROR;
898             UEnumeration* numberingSystemNames = unumsys_openAvailableNames(&amp;status);
899             ASSERT(U_SUCCESS(status));
900 
901             int32_t resultLength;
902             // Numbering system names are always ASCII, so use char[].
903             while (const char* result = uenum_next(numberingSystemNames, &amp;resultLength, &amp;status)) {
904                 ASSERT(U_SUCCESS(status));
905                 auto numsys = unumsys_openByName(result, &amp;status);
906                 ASSERT(U_SUCCESS(status));
907                 // Only support algorithmic if it is the default fot the locale, handled below.
908                 if (!unumsys_isAlgorithmic(numsys))
909                     availableNumberingSystems.append(String(result, resultLength));
910                 unumsys_close(numsys);
911             }
912             uenum_close(numberingSystemNames);
913         }
914     }
915 
916     UErrorCode status = U_ZERO_ERROR;
917     UNumberingSystem* defaultSystem = unumsys_open(locale.utf8().data(), &amp;status);
918     ASSERT(U_SUCCESS(status));
919     String defaultSystemName(unumsys_getName(defaultSystem));
920     unumsys_close(defaultSystem);
921 
922     Vector&lt;String&gt; numberingSystems({ defaultSystemName });
923     numberingSystems.appendVector(availableNumberingSystems);
924     return numberingSystems;
925 }
926 
927 EncodedJSValue JSC_HOST_CALL intlObjectFuncGetCanonicalLocales(ExecState* state)
928 {
929     // Intl.getCanonicalLocales(locales)
930     // https://tc39.github.io/ecma402/#sec-intl.getcanonicallocales
931 
932     VM&amp; vm = state-&gt;vm();
933     auto scope = DECLARE_THROW_SCOPE(vm);
934 
935     Vector&lt;String&gt; localeList = canonicalizeLocaleList(*state, state-&gt;argument(0));
936     RETURN_IF_EXCEPTION(scope, encodedJSValue());
937     auto length = localeList.size();
938 
939     JSGlobalObject* globalObject = state-&gt;jsCallee()-&gt;globalObject(vm);
940     JSArray* localeArray = JSArray::tryCreate(vm, globalObject-&gt;arrayStructureForIndexingTypeDuringAllocation(ArrayWithContiguous), length);
941     if (!localeArray) {
942         throwOutOfMemoryError(state, scope);
943         return encodedJSValue();
944     }
945 
946     for (size_t i = 0; i &lt; length; ++i) {
<a name="8" id="anc8"></a><span class="line-modified">947         localeArray-&gt;putDirectIndex(state, i, jsString(state, localeList[i]));</span>
948         RETURN_IF_EXCEPTION(scope, encodedJSValue());
949     }
950     return JSValue::encode(localeArray);
951 }
952 
953 } // namespace JSC
954 
955 #endif // ENABLE(INTL)
<a name="9" id="anc9"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="9" type="hidden" />
</body>
</html>