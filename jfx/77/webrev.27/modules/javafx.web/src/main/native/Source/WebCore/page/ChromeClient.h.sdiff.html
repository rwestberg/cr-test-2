<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/page/ChromeClient.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="Chrome.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ClientOrigin.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/page/ChromeClient.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  8  * License as published by the Free Software Foundation; either
  9  * version 2 of the License, or (at your option) any later version.
 10  *
 11  * This library is distributed in the hope that it will be useful,
 12  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 13  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 14  * Library General Public License for more details.
 15  *
 16  * You should have received a copy of the GNU Library General Public License
 17  * along with this library; see the file COPYING.LIB.  If not, write to
 18  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 19  * Boston, MA 02110-1301, USA.
 20  */
 21 
 22 #pragma once
 23 
 24 #include &quot;AXObjectCache.h&quot;
 25 #include &quot;AutoplayEvent.h&quot;
 26 #include &quot;Cursor.h&quot;
 27 #include &quot;DatabaseDetails.h&quot;

 28 #include &quot;DisabledAdaptations.h&quot;
 29 #include &quot;DisplayRefreshMonitor.h&quot;

 30 #include &quot;FocusDirection.h&quot;

 31 #include &quot;FrameLoader.h&quot;
 32 #include &quot;GraphicsContext.h&quot;
 33 #include &quot;GraphicsLayer.h&quot;
 34 #include &quot;HTMLMediaElementEnums.h&quot;
 35 #include &quot;HostWindow.h&quot;
 36 #include &quot;Icon.h&quot;
 37 #include &quot;InputMode.h&quot;
 38 #include &quot;LayerFlushThrottleState.h&quot;
 39 #include &quot;MediaProducer.h&quot;
 40 #include &quot;PopupMenu.h&quot;
 41 #include &quot;PopupMenuClient.h&quot;

 42 #include &quot;RenderEmbeddedObject.h&quot;
 43 #include &quot;ScrollTypes.h&quot;
 44 #include &quot;ScrollingCoordinator.h&quot;
 45 #include &quot;SearchPopupMenu.h&quot;
 46 #include &quot;WebCoreKeyboardUIMode.h&quot;
 47 #include &lt;JavaScriptCore/ConsoleTypes.h&gt;

 48 #include &lt;wtf/CompletionHandler.h&gt;
 49 #include &lt;wtf/Forward.h&gt;
 50 #include &lt;wtf/Seconds.h&gt;
 51 
 52 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
 53 #include &quot;MediaPlaybackTargetContext.h&quot;
 54 #endif
 55 
 56 #if PLATFORM(IOS_FAMILY)
 57 #include &quot;PlatformLayer.h&quot;

 58 #define NSResponder WAKResponder
 59 #ifndef __OBJC__
 60 class WAKResponder;
 61 #else
 62 @class WAKResponder;
 63 #endif
 64 #endif
 65 
 66 OBJC_CLASS NSResponder;
 67 
 68 namespace WebCore {
 69 
 70 class AccessibilityObject;
 71 class ColorChooser;
 72 class ColorChooserClient;
 73 class DataListSuggestionPicker;
 74 class DataListSuggestionsClient;
 75 class DateTimeChooser;
 76 class DateTimeChooserClient;
 77 class Element;
 78 class FileChooser;
 79 class FileIconLoader;
 80 class FloatRect;
 81 class Frame;
 82 class FrameLoadRequest;
 83 class Geolocation;
 84 class GraphicsLayer;
 85 class GraphicsLayerFactory;

 86 class HTMLInputElement;
 87 class HTMLMediaElement;
 88 class HTMLVideoElement;
 89 class HitTestResult;
 90 class IntRect;
 91 class MediaSessionMetadata;
 92 class NavigationAction;
 93 class Node;
 94 class Page;
 95 class PopupMenuClient;
 96 class SecurityOrigin;
 97 class ViewportConstraints;
 98 class Widget;
 99 
100 #if ENABLE(VIDEO) &amp;&amp; USE(GSTREAMER)
101 class MediaPlayerRequestInstallMissingPluginsCallback;
102 #endif
103 

104 struct DateTimeChooserParameters;
105 struct GraphicsDeviceAdapter;
106 struct ShareDataWithParsedURL;
107 struct ViewportArguments;
108 struct WindowFeatures;
109 
110 enum class RouteSharingPolicy : uint8_t;
111 
<span class="line-modified">112 class WEBCORE_EXPORT ChromeClient {</span>
113 public:
114     virtual void chromeDestroyed() = 0;
115 
116     virtual void setWindowRect(const FloatRect&amp;) = 0;
117     virtual FloatRect windowRect() = 0;
118 
119     virtual FloatRect pageRect() = 0;
120 
121     virtual void focus() = 0;
122     virtual void unfocus() = 0;
123 
124     virtual bool canTakeFocus(FocusDirection) = 0;
125     virtual void takeFocus(FocusDirection) = 0;
126 
127     virtual void focusedElementChanged(Element*) = 0;
128     virtual void focusedFrameChanged(Frame*) = 0;
129 
130     // The Frame pointer provides the ChromeClient with context about which
131     // Frame wants to create the new Page. Also, the newly created window
132     // should not be shown to the user until the ChromeClient of the newly
</pre>
<hr />
<pre>
157 
158     virtual bool canRunBeforeUnloadConfirmPanel() = 0;
159     virtual bool runBeforeUnloadConfirmPanel(const String&amp; message, Frame&amp;) = 0;
160 
161     virtual void closeWindowSoon() = 0;
162 
163     virtual void runJavaScriptAlert(Frame&amp;, const String&amp;) = 0;
164     virtual bool runJavaScriptConfirm(Frame&amp;, const String&amp;) = 0;
165     virtual bool runJavaScriptPrompt(Frame&amp;, const String&amp; message, const String&amp; defaultValue, String&amp; result) = 0;
166     virtual void setStatusbarText(const String&amp;) = 0;
167     virtual KeyboardUIMode keyboardUIMode() = 0;
168 
169     virtual bool supportsImmediateInvalidation() { return false; }
170     virtual void invalidateRootView(const IntRect&amp;) = 0;
171     virtual void invalidateContentsAndRootView(const IntRect&amp;) = 0;
172     virtual void invalidateContentsForSlowScroll(const IntRect&amp;) = 0;
173     virtual void scroll(const IntSize&amp;, const IntRect&amp;, const IntRect&amp;) = 0;
174 
175     virtual IntPoint screenToRootView(const IntPoint&amp;) const = 0;
176     virtual IntRect rootViewToScreen(const IntRect&amp;) const = 0;
<span class="line-removed">177 </span>
<span class="line-removed">178 #if PLATFORM(IOS_FAMILY)</span>
179     virtual IntPoint accessibilityScreenToRootView(const IntPoint&amp;) const = 0;
180     virtual IntRect rootViewToAccessibilityScreen(const IntRect&amp;) const = 0;
<span class="line-modified">181 #endif</span>

182 
183     virtual PlatformPageClient platformPageClient() const = 0;
184 
185 #if ENABLE(CURSOR_SUPPORT)
186     virtual void setCursor(const Cursor&amp;) = 0;
187     virtual void setCursorHiddenUntilMouseMoves(bool) = 0;
188 #endif
189 
190     virtual FloatSize screenSize() const { return const_cast&lt;ChromeClient&amp;&gt;(*this).windowRect().size(); }
191     virtual FloatSize availableScreenSize() const { return const_cast&lt;ChromeClient&amp;&gt;(*this).windowRect().size(); }
192     virtual FloatSize overrideScreenSize() const { return const_cast&lt;ChromeClient&amp;&gt;(*this).windowRect().size(); }
193 
194     virtual void dispatchDisabledAdaptationsDidChange(const OptionSet&lt;DisabledAdaptations&gt;&amp;) const { }
195     virtual void dispatchViewportPropertiesDidChange(const ViewportArguments&amp;) const { }
196 
197     virtual void contentsSizeChanged(Frame&amp;, const IntSize&amp;) const = 0;

198     virtual void scrollRectIntoView(const IntRect&amp;) const { }; // Currently only Mac has a non empty implementation.
199 
200     virtual bool shouldUnavailablePluginMessageBeButton(RenderEmbeddedObject::PluginUnavailabilityReason) const { return false; }
201     virtual void unavailablePluginButtonClicked(Element&amp;, RenderEmbeddedObject::PluginUnavailabilityReason) const { }
202     virtual void mouseDidMoveOverElement(const HitTestResult&amp;, unsigned modifierFlags) = 0;
203 
204     virtual void setToolTip(const String&amp;, TextDirection) = 0;
205 
206     virtual void print(Frame&amp;) = 0;
207 
208     virtual Color underlayColor() const { return Color(); }
209 
210     virtual void pageExtendedBackgroundColorDidChange(Color) const { }
211 
212     virtual void exceededDatabaseQuota(Frame&amp;, const String&amp; databaseName, DatabaseDetails) = 0;
213 
214     // Callback invoked when the application cache fails to save a cache object
215     // because storing it would grow the database file past its defined maximum
216     // size or past the amount of free space on the device.
217     // The chrome client would need to take some action such as evicting some
218     // old caches.
219     virtual void reachedMaxAppCacheSize(int64_t spaceNeeded) = 0;
220 
221     // Callback invoked when the application cache origin quota is reached. This
222     // means that the resources attempting to be cached via the manifest are
223     // more than allowed on this origin. This callback allows the chrome client
224     // to take action, such as prompting the user to ask to increase the quota
225     // for this origin. The totalSpaceNeeded parameter is the total amount of
226     // storage, in bytes, needed to store the new cache along with all of the
227     // other existing caches for the origin that would not be replaced by
228     // the new cache.
229     virtual void reachedApplicationCacheOriginQuota(SecurityOrigin&amp;, int64_t totalSpaceNeeded) = 0;
230 
<span class="line-removed">231 #if ENABLE(DASHBOARD_SUPPORT)</span>
<span class="line-removed">232     virtual void annotatedRegionsChanged();</span>
<span class="line-removed">233 #endif</span>
<span class="line-removed">234 </span>
<span class="line-removed">235     virtual bool shouldReplaceWithGeneratedFileForUpload(const String&amp; path, String&amp; generatedFilename);</span>
<span class="line-removed">236     virtual String generateReplacementFile(const String&amp; path);</span>
<span class="line-removed">237 </span>
238 #if ENABLE(IOS_TOUCH_EVENTS)
239     virtual void didPreventDefaultForEvent() = 0;
240 #endif
241 
242     virtual Seconds eventThrottlingDelay() { return 0_s; };
243 
244 #if PLATFORM(IOS_FAMILY)
245     virtual void didReceiveMobileDocType(bool) = 0;
246     virtual void setNeedsScrollNotifications(Frame&amp;, bool) = 0;
<span class="line-modified">247     virtual void observedContentChange(Frame&amp;) = 0;</span>
<span class="line-removed">248     virtual void clearContentChangeObservers(Frame&amp;) = 0;</span>
249     virtual void notifyRevealedSelectionByScrollingFrame(Frame&amp;) = 0;
250 
251     enum LayoutType { NormalLayout, Scroll };
252     virtual void didLayout(LayoutType = NormalLayout) = 0;
253     virtual void didStartOverflowScroll() = 0;
254     virtual void didEndOverflowScroll() = 0;
255 
256     // FIXME: Remove this functionality. This functionality was added to workaround an issue (&lt;rdar://problem/5973875&gt;)
257     // where the unconfirmed text in a text area would be removed when a person clicks in the text area before a
258     // suggestion is shown. We should fix this issue in &lt;rdar://problem/5975559&gt;.
259     virtual void suppressFormNotifications() = 0;
260     virtual void restoreFormNotifications() = 0;
261 
262     virtual void didFlushCompositingLayers() { }
263 
264     virtual bool fetchCustomFixedPositionLayoutRect(IntRect&amp;) { return false; }
265 
266     virtual void updateViewportConstrainedLayers(HashMap&lt;PlatformLayer*, std::unique_ptr&lt;ViewportConstraints&gt;&gt;&amp;, const HashMap&lt;PlatformLayer*, PlatformLayer*&gt;&amp;) { }
267 
268     virtual void addOrUpdateScrollingLayer(Node*, PlatformLayer* scrollingLayer, PlatformLayer* contentsLayer, const IntSize&amp; scrollSize, bool allowHorizontalScrollbar, bool allowVerticalScrollbar) = 0;
</pre>
<hr />
<pre>
298 
299     virtual bool shouldPaintEntireContents() const { return false; }
300     virtual bool hasStablePageScaleFactor() const { return true; }
301 
302     // Allows ports to customize the type of graphics layers created by this page.
303     virtual GraphicsLayerFactory* graphicsLayerFactory() const { return nullptr; }
304 
305 #if USE(REQUEST_ANIMATION_FRAME_DISPLAY_MONITOR)
306     virtual RefPtr&lt;DisplayRefreshMonitor&gt; createDisplayRefreshMonitor(PlatformDisplayID) const { return nullptr; }
307 #endif
308 
309     // Pass nullptr as the GraphicsLayer to detatch the root layer.
310     virtual void attachRootGraphicsLayer(Frame&amp;, GraphicsLayer*) = 0;
311     virtual void attachViewOverlayGraphicsLayer(GraphicsLayer*) = 0;
312     // Sets a flag to specify that the next time content is drawn to the window,
313     // the changes appear on the screen in synchrony with updates to GraphicsLayers.
314     virtual void setNeedsOneShotDrawingSynchronization() = 0;
315     // Sets a flag to specify that the view needs to be updated, so we need
316     // to do an eager layout before the drawing.
317     virtual void scheduleCompositingLayerFlush() = 0;

318     // Returns whether or not the client can render the composited layer,
319     // regardless of the settings.
320     virtual bool allowsAcceleratedCompositing() const { return true; }
321 
322     enum CompositingTrigger {
323         ThreeDTransformTrigger = 1 &lt;&lt; 0,
324         VideoTrigger = 1 &lt;&lt; 1,
325         PluginTrigger = 1 &lt;&lt; 2,
326         CanvasTrigger = 1 &lt;&lt; 3,
327         AnimationTrigger = 1 &lt;&lt; 4,
328         FilterTrigger = 1 &lt;&lt; 5,
329         ScrollableNonMainFrameTrigger = 1 &lt;&lt; 6,
330         AnimatedOpacityTrigger = 1 &lt;&lt; 7,
331         AllTriggers = 0xFFFFFFFF
332     };
333     typedef unsigned CompositingTriggerFlags;
334 
335     // Returns a bitfield indicating conditions that can trigger the compositor.
336     virtual CompositingTriggerFlags allowedCompositingTriggers() const { return static_cast&lt;CompositingTriggerFlags&gt;(AllTriggers); }
337 
</pre>
<hr />
<pre>
362 
363 #if ENABLE(FULLSCREEN_API)
364     virtual bool supportsFullScreenForElement(const Element&amp;, bool) { return false; }
365     virtual void enterFullScreenForElement(Element&amp;) { }
366     virtual void exitFullScreenForElement(Element*) { }
367     virtual void setRootFullScreenLayer(GraphicsLayer*) { }
368 #endif
369 
370 #if USE(COORDINATED_GRAPHICS)
371     virtual IntRect visibleRectForTiledBackingStore() const { return IntRect(); }
372 #endif
373 
374 #if PLATFORM(COCOA)
375     virtual NSResponder *firstResponder() { return nullptr; }
376     virtual void makeFirstResponder(NSResponder *) { }
377     // Focuses on the containing view associated with this page.
378     virtual void makeFirstResponder() { }
379     virtual void assistiveTechnologyMakeFirstResponder() { }
380 #endif
381 


382 #if PLATFORM(IOS_FAMILY)
383     // FIXME: Come up with a more descriptive name for this function and make it platform independent (if possible).
384     virtual bool isStopping() = 0;
385 #endif
386 
387     virtual void enableSuddenTermination() { }
388     virtual void disableSuddenTermination() { }
389 
<span class="line-modified">390     virtual void contentRuleListNotification(const URL&amp;, const HashSet&lt;std::pair&lt;String, String&gt;&gt;&amp;) { };</span>
391 
392 #if PLATFORM(WIN)
393     virtual void setLastSetCursorToCurrentCursor() = 0;
394     virtual void AXStartFrameLoad() = 0;
395     virtual void AXFinishFrameLoad() = 0;
396 #endif
397 
398     virtual bool selectItemWritingDirectionIsNatural() = 0;
399     virtual bool selectItemAlignmentFollowsMenuWritingDirection() = 0;
400     // Checks if there is an opened popup, called by RenderMenuList::showPopup().
401     virtual RefPtr&lt;PopupMenu&gt; createPopupMenu(PopupMenuClient&amp;) const = 0;
402     virtual RefPtr&lt;SearchPopupMenu&gt; createSearchPopupMenu(PopupMenuClient&amp;) const = 0;
403 
404     virtual void postAccessibilityNotification(AccessibilityObject&amp;, AXObjectCache::AXNotification) { }
405 
406     virtual void notifyScrollerThumbIsVisibleInRect(const IntRect&amp;) { }
407     virtual void recommendedScrollbarStyleDidChange(ScrollbarStyle) { }
408 
409     virtual Optional&lt;ScrollbarOverlayStyle&gt; preferredScrollbarOverlayStyle() { return WTF::nullopt; }
410 
411     virtual void wheelEventHandlersChanged(bool hasHandlers) = 0;
412 
413     virtual bool isSVGImageChromeClient() const { return false; }
414 
415 #if ENABLE(POINTER_LOCK)
416     virtual bool requestPointerLock() { return false; }
417     virtual void requestPointerUnlock() { }
418 #endif
419 
420     virtual FloatSize minimumWindowSize() const { return FloatSize(100, 100); };
421 
422     virtual bool isEmptyChromeClient() const { return false; }
423 
424     virtual String plugInStartLabelTitle(const String&amp; mimeType) const { UNUSED_PARAM(mimeType); return String(); }
425     virtual String plugInStartLabelSubtitle(const String&amp; mimeType) const { UNUSED_PARAM(mimeType); return String(); }
426     virtual String plugInExtraStyleSheet() const { return String(); }
427     virtual String plugInExtraScript() const { return String(); }
428 
<span class="line-modified">429     virtual void didAssociateFormControls(const Vector&lt;RefPtr&lt;Element&gt;&gt;&amp;) { };</span>
430     virtual bool shouldNotifyOnFormChanges() { return false; };
431 
432     virtual void didAddHeaderLayer(GraphicsLayer&amp;) { }
433     virtual void didAddFooterLayer(GraphicsLayer&amp;) { }
434 
435     virtual bool shouldUseTiledBackingForFrameView(const FrameView&amp;) const { return false; }
436 
437     virtual void isPlayingMediaDidChange(MediaProducer::MediaStateFlags, uint64_t) { }
438     virtual void handleAutoplayEvent(AutoplayEvent, OptionSet&lt;AutoplayEventFlags&gt;) { }
439 
440 #if ENABLE(MEDIA_SESSION)
441     virtual void hasMediaSessionWithActiveMediaElementsDidChange(bool) { }
442     virtual void mediaSessionMetadataDidChange(const MediaSessionMetadata&amp;) { }
443     virtual void focusedContentMediaElementDidChange(uint64_t) { }
444 #endif
445 
446 #if ENABLE(WEB_CRYPTO)
447     virtual bool wrapCryptoKey(const Vector&lt;uint8_t&gt;&amp;, Vector&lt;uint8_t&gt;&amp;) const { return false; }
448     virtual bool unwrapCryptoKey(const Vector&lt;uint8_t&gt;&amp;, Vector&lt;uint8_t&gt;&amp;) const { return false; }
449 #endif
</pre>
<hr />
<pre>
466 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
467     virtual void addPlaybackTargetPickerClient(uint64_t /*contextId*/) { }
468     virtual void removePlaybackTargetPickerClient(uint64_t /*contextId*/) { }
469     virtual void showPlaybackTargetPicker(uint64_t /*contextId*/, const IntPoint&amp;, bool /*isVideo*/) { }
470     virtual void playbackTargetPickerClientStateDidChange(uint64_t /*contextId*/, MediaProducer::MediaStateFlags) { }
471     virtual void setMockMediaPlaybackTargetPickerEnabled(bool)  { }
472     virtual void setMockMediaPlaybackTargetPickerState(const String&amp;, MediaPlaybackTargetContext::State) { }
473 #endif
474 
475     virtual void imageOrMediaDocumentSizeChanged(const IntSize&amp;) { }
476 
477 #if ENABLE(VIDEO) &amp;&amp; USE(GSTREAMER)
478     virtual void requestInstallMissingMediaPlugins(const String&amp; /*details*/, const String&amp; /*description*/, MediaPlayerRequestInstallMissingPluginsCallback&amp;) { }
479 #endif
480 
481     virtual void didInvalidateDocumentMarkerRects() { }
482 
483     virtual void reportProcessCPUTime(Seconds, ActivityStateForCPUSampling) { }
484     virtual RefPtr&lt;Icon&gt; createIconForFiles(const Vector&lt;String&gt;&amp; /* filenames */) = 0;
485 
<span class="line-modified">486     virtual void hasStorageAccess(String&amp;&amp; /*subFrameHost*/, String&amp;&amp; /*topFrameHost*/, uint64_t /*frameID*/, uint64_t /*pageID*/, WTF::CompletionHandler&lt;void (bool)&gt;&amp;&amp; callback) { callback(false); }</span>
<span class="line-modified">487     virtual void requestStorageAccess(String&amp;&amp; /*subFrameHost*/, String&amp;&amp; /*topFrameHost*/, uint64_t /*frameID*/, uint64_t /*pageID*/, WTF::CompletionHandler&lt;void (bool)&gt;&amp;&amp; callback) { callback(false); }</span>






488 
489     virtual void didInsertMenuElement(HTMLMenuElement&amp;) { }
490     virtual void didRemoveMenuElement(HTMLMenuElement&amp;) { }
491     virtual void didInsertMenuItemElement(HTMLMenuItemElement&amp;) { }
492     virtual void didRemoveMenuItemElement(HTMLMenuItemElement&amp;) { }
493 
494     virtual String signedPublicKeyAndChallengeString(unsigned, const String&amp;, const URL&amp;) const { return emptyString(); }
495 
496     virtual void associateEditableImageWithAttachment(GraphicsLayer::EmbeddedViewID, const String&amp;) { }
497     virtual void didCreateEditableImage(GraphicsLayer::EmbeddedViewID) { }
498     virtual void didDestroyEditableImage(GraphicsLayer::EmbeddedViewID) { }
499 





500 protected:
501     virtual ~ChromeClient() = default;
502 };
503 
504 } // namespace WebCore
</pre>
</td>
<td>
<hr />
<pre>
  8  * License as published by the Free Software Foundation; either
  9  * version 2 of the License, or (at your option) any later version.
 10  *
 11  * This library is distributed in the hope that it will be useful,
 12  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 13  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 14  * Library General Public License for more details.
 15  *
 16  * You should have received a copy of the GNU Library General Public License
 17  * along with this library; see the file COPYING.LIB.  If not, write to
 18  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 19  * Boston, MA 02110-1301, USA.
 20  */
 21 
 22 #pragma once
 23 
 24 #include &quot;AXObjectCache.h&quot;
 25 #include &quot;AutoplayEvent.h&quot;
 26 #include &quot;Cursor.h&quot;
 27 #include &quot;DatabaseDetails.h&quot;
<span class="line-added"> 28 #include &quot;DeviceOrientationOrMotionPermissionState.h&quot;</span>
 29 #include &quot;DisabledAdaptations.h&quot;
 30 #include &quot;DisplayRefreshMonitor.h&quot;
<span class="line-added"> 31 #include &quot;DocumentStorageAccess.h&quot;</span>
 32 #include &quot;FocusDirection.h&quot;
<span class="line-added"> 33 #include &quot;FrameIdentifier.h&quot;</span>
 34 #include &quot;FrameLoader.h&quot;
 35 #include &quot;GraphicsContext.h&quot;
 36 #include &quot;GraphicsLayer.h&quot;
 37 #include &quot;HTMLMediaElementEnums.h&quot;
 38 #include &quot;HostWindow.h&quot;
 39 #include &quot;Icon.h&quot;
 40 #include &quot;InputMode.h&quot;
 41 #include &quot;LayerFlushThrottleState.h&quot;
 42 #include &quot;MediaProducer.h&quot;
 43 #include &quot;PopupMenu.h&quot;
 44 #include &quot;PopupMenuClient.h&quot;
<span class="line-added"> 45 #include &quot;RegistrableDomain.h&quot;</span>
 46 #include &quot;RenderEmbeddedObject.h&quot;
 47 #include &quot;ScrollTypes.h&quot;
 48 #include &quot;ScrollingCoordinator.h&quot;
 49 #include &quot;SearchPopupMenu.h&quot;
 50 #include &quot;WebCoreKeyboardUIMode.h&quot;
 51 #include &lt;JavaScriptCore/ConsoleTypes.h&gt;
<span class="line-added"> 52 #include &lt;wtf/Assertions.h&gt;</span>
 53 #include &lt;wtf/CompletionHandler.h&gt;
 54 #include &lt;wtf/Forward.h&gt;
 55 #include &lt;wtf/Seconds.h&gt;
 56 
 57 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
 58 #include &quot;MediaPlaybackTargetContext.h&quot;
 59 #endif
 60 
 61 #if PLATFORM(IOS_FAMILY)
 62 #include &quot;PlatformLayer.h&quot;
<span class="line-added"> 63 #include &quot;WKContentObservation.h&quot;</span>
 64 #define NSResponder WAKResponder
 65 #ifndef __OBJC__
 66 class WAKResponder;
 67 #else
 68 @class WAKResponder;
 69 #endif
 70 #endif
 71 
 72 OBJC_CLASS NSResponder;
 73 
 74 namespace WebCore {
 75 
 76 class AccessibilityObject;
 77 class ColorChooser;
 78 class ColorChooserClient;
 79 class DataListSuggestionPicker;
 80 class DataListSuggestionsClient;
 81 class DateTimeChooser;
 82 class DateTimeChooserClient;
 83 class Element;
 84 class FileChooser;
 85 class FileIconLoader;
 86 class FloatRect;
 87 class Frame;
 88 class FrameLoadRequest;
 89 class Geolocation;
 90 class GraphicsLayer;
 91 class GraphicsLayerFactory;
<span class="line-added"> 92 class HTMLImageElement;</span>
 93 class HTMLInputElement;
 94 class HTMLMediaElement;
 95 class HTMLVideoElement;
 96 class HitTestResult;
 97 class IntRect;
 98 class MediaSessionMetadata;
 99 class NavigationAction;
100 class Node;
101 class Page;
102 class PopupMenuClient;
103 class SecurityOrigin;
104 class ViewportConstraints;
105 class Widget;
106 
107 #if ENABLE(VIDEO) &amp;&amp; USE(GSTREAMER)
108 class MediaPlayerRequestInstallMissingPluginsCallback;
109 #endif
110 
<span class="line-added">111 struct ContentRuleListResults;</span>
112 struct DateTimeChooserParameters;
113 struct GraphicsDeviceAdapter;
114 struct ShareDataWithParsedURL;
115 struct ViewportArguments;
116 struct WindowFeatures;
117 
118 enum class RouteSharingPolicy : uint8_t;
119 
<span class="line-modified">120 class ChromeClient {</span>
121 public:
122     virtual void chromeDestroyed() = 0;
123 
124     virtual void setWindowRect(const FloatRect&amp;) = 0;
125     virtual FloatRect windowRect() = 0;
126 
127     virtual FloatRect pageRect() = 0;
128 
129     virtual void focus() = 0;
130     virtual void unfocus() = 0;
131 
132     virtual bool canTakeFocus(FocusDirection) = 0;
133     virtual void takeFocus(FocusDirection) = 0;
134 
135     virtual void focusedElementChanged(Element*) = 0;
136     virtual void focusedFrameChanged(Frame*) = 0;
137 
138     // The Frame pointer provides the ChromeClient with context about which
139     // Frame wants to create the new Page. Also, the newly created window
140     // should not be shown to the user until the ChromeClient of the newly
</pre>
<hr />
<pre>
165 
166     virtual bool canRunBeforeUnloadConfirmPanel() = 0;
167     virtual bool runBeforeUnloadConfirmPanel(const String&amp; message, Frame&amp;) = 0;
168 
169     virtual void closeWindowSoon() = 0;
170 
171     virtual void runJavaScriptAlert(Frame&amp;, const String&amp;) = 0;
172     virtual bool runJavaScriptConfirm(Frame&amp;, const String&amp;) = 0;
173     virtual bool runJavaScriptPrompt(Frame&amp;, const String&amp; message, const String&amp; defaultValue, String&amp; result) = 0;
174     virtual void setStatusbarText(const String&amp;) = 0;
175     virtual KeyboardUIMode keyboardUIMode() = 0;
176 
177     virtual bool supportsImmediateInvalidation() { return false; }
178     virtual void invalidateRootView(const IntRect&amp;) = 0;
179     virtual void invalidateContentsAndRootView(const IntRect&amp;) = 0;
180     virtual void invalidateContentsForSlowScroll(const IntRect&amp;) = 0;
181     virtual void scroll(const IntSize&amp;, const IntRect&amp;, const IntRect&amp;) = 0;
182 
183     virtual IntPoint screenToRootView(const IntPoint&amp;) const = 0;
184     virtual IntRect rootViewToScreen(const IntRect&amp;) const = 0;


185     virtual IntPoint accessibilityScreenToRootView(const IntPoint&amp;) const = 0;
186     virtual IntRect rootViewToAccessibilityScreen(const IntRect&amp;) const = 0;
<span class="line-modified">187 </span>
<span class="line-added">188     virtual void didFinishLoadingImageForElement(HTMLImageElement&amp;) = 0;</span>
189 
190     virtual PlatformPageClient platformPageClient() const = 0;
191 
192 #if ENABLE(CURSOR_SUPPORT)
193     virtual void setCursor(const Cursor&amp;) = 0;
194     virtual void setCursorHiddenUntilMouseMoves(bool) = 0;
195 #endif
196 
197     virtual FloatSize screenSize() const { return const_cast&lt;ChromeClient&amp;&gt;(*this).windowRect().size(); }
198     virtual FloatSize availableScreenSize() const { return const_cast&lt;ChromeClient&amp;&gt;(*this).windowRect().size(); }
199     virtual FloatSize overrideScreenSize() const { return const_cast&lt;ChromeClient&amp;&gt;(*this).windowRect().size(); }
200 
201     virtual void dispatchDisabledAdaptationsDidChange(const OptionSet&lt;DisabledAdaptations&gt;&amp;) const { }
202     virtual void dispatchViewportPropertiesDidChange(const ViewportArguments&amp;) const { }
203 
204     virtual void contentsSizeChanged(Frame&amp;, const IntSize&amp;) const = 0;
<span class="line-added">205     virtual void intrinsicContentsSizeChanged(const IntSize&amp;) const = 0;</span>
206     virtual void scrollRectIntoView(const IntRect&amp;) const { }; // Currently only Mac has a non empty implementation.
207 
208     virtual bool shouldUnavailablePluginMessageBeButton(RenderEmbeddedObject::PluginUnavailabilityReason) const { return false; }
209     virtual void unavailablePluginButtonClicked(Element&amp;, RenderEmbeddedObject::PluginUnavailabilityReason) const { }
210     virtual void mouseDidMoveOverElement(const HitTestResult&amp;, unsigned modifierFlags) = 0;
211 
212     virtual void setToolTip(const String&amp;, TextDirection) = 0;
213 
214     virtual void print(Frame&amp;) = 0;
215 
216     virtual Color underlayColor() const { return Color(); }
217 
218     virtual void pageExtendedBackgroundColorDidChange(Color) const { }
219 
220     virtual void exceededDatabaseQuota(Frame&amp;, const String&amp; databaseName, DatabaseDetails) = 0;
221 
222     // Callback invoked when the application cache fails to save a cache object
223     // because storing it would grow the database file past its defined maximum
224     // size or past the amount of free space on the device.
225     // The chrome client would need to take some action such as evicting some
226     // old caches.
227     virtual void reachedMaxAppCacheSize(int64_t spaceNeeded) = 0;
228 
229     // Callback invoked when the application cache origin quota is reached. This
230     // means that the resources attempting to be cached via the manifest are
231     // more than allowed on this origin. This callback allows the chrome client
232     // to take action, such as prompting the user to ask to increase the quota
233     // for this origin. The totalSpaceNeeded parameter is the total amount of
234     // storage, in bytes, needed to store the new cache along with all of the
235     // other existing caches for the origin that would not be replaced by
236     // the new cache.
237     virtual void reachedApplicationCacheOriginQuota(SecurityOrigin&amp;, int64_t totalSpaceNeeded) = 0;
238 







239 #if ENABLE(IOS_TOUCH_EVENTS)
240     virtual void didPreventDefaultForEvent() = 0;
241 #endif
242 
243     virtual Seconds eventThrottlingDelay() { return 0_s; };
244 
245 #if PLATFORM(IOS_FAMILY)
246     virtual void didReceiveMobileDocType(bool) = 0;
247     virtual void setNeedsScrollNotifications(Frame&amp;, bool) = 0;
<span class="line-modified">248     virtual void didFinishContentChangeObserving(Frame&amp;, WKContentChange) = 0;</span>

249     virtual void notifyRevealedSelectionByScrollingFrame(Frame&amp;) = 0;
250 
251     enum LayoutType { NormalLayout, Scroll };
252     virtual void didLayout(LayoutType = NormalLayout) = 0;
253     virtual void didStartOverflowScroll() = 0;
254     virtual void didEndOverflowScroll() = 0;
255 
256     // FIXME: Remove this functionality. This functionality was added to workaround an issue (&lt;rdar://problem/5973875&gt;)
257     // where the unconfirmed text in a text area would be removed when a person clicks in the text area before a
258     // suggestion is shown. We should fix this issue in &lt;rdar://problem/5975559&gt;.
259     virtual void suppressFormNotifications() = 0;
260     virtual void restoreFormNotifications() = 0;
261 
262     virtual void didFlushCompositingLayers() { }
263 
264     virtual bool fetchCustomFixedPositionLayoutRect(IntRect&amp;) { return false; }
265 
266     virtual void updateViewportConstrainedLayers(HashMap&lt;PlatformLayer*, std::unique_ptr&lt;ViewportConstraints&gt;&gt;&amp;, const HashMap&lt;PlatformLayer*, PlatformLayer*&gt;&amp;) { }
267 
268     virtual void addOrUpdateScrollingLayer(Node*, PlatformLayer* scrollingLayer, PlatformLayer* contentsLayer, const IntSize&amp; scrollSize, bool allowHorizontalScrollbar, bool allowVerticalScrollbar) = 0;
</pre>
<hr />
<pre>
298 
299     virtual bool shouldPaintEntireContents() const { return false; }
300     virtual bool hasStablePageScaleFactor() const { return true; }
301 
302     // Allows ports to customize the type of graphics layers created by this page.
303     virtual GraphicsLayerFactory* graphicsLayerFactory() const { return nullptr; }
304 
305 #if USE(REQUEST_ANIMATION_FRAME_DISPLAY_MONITOR)
306     virtual RefPtr&lt;DisplayRefreshMonitor&gt; createDisplayRefreshMonitor(PlatformDisplayID) const { return nullptr; }
307 #endif
308 
309     // Pass nullptr as the GraphicsLayer to detatch the root layer.
310     virtual void attachRootGraphicsLayer(Frame&amp;, GraphicsLayer*) = 0;
311     virtual void attachViewOverlayGraphicsLayer(GraphicsLayer*) = 0;
312     // Sets a flag to specify that the next time content is drawn to the window,
313     // the changes appear on the screen in synchrony with updates to GraphicsLayers.
314     virtual void setNeedsOneShotDrawingSynchronization() = 0;
315     // Sets a flag to specify that the view needs to be updated, so we need
316     // to do an eager layout before the drawing.
317     virtual void scheduleCompositingLayerFlush() = 0;
<span class="line-added">318     virtual bool needsImmediateRenderingUpdate() const { return false; }</span>
319     // Returns whether or not the client can render the composited layer,
320     // regardless of the settings.
321     virtual bool allowsAcceleratedCompositing() const { return true; }
322 
323     enum CompositingTrigger {
324         ThreeDTransformTrigger = 1 &lt;&lt; 0,
325         VideoTrigger = 1 &lt;&lt; 1,
326         PluginTrigger = 1 &lt;&lt; 2,
327         CanvasTrigger = 1 &lt;&lt; 3,
328         AnimationTrigger = 1 &lt;&lt; 4,
329         FilterTrigger = 1 &lt;&lt; 5,
330         ScrollableNonMainFrameTrigger = 1 &lt;&lt; 6,
331         AnimatedOpacityTrigger = 1 &lt;&lt; 7,
332         AllTriggers = 0xFFFFFFFF
333     };
334     typedef unsigned CompositingTriggerFlags;
335 
336     // Returns a bitfield indicating conditions that can trigger the compositor.
337     virtual CompositingTriggerFlags allowedCompositingTriggers() const { return static_cast&lt;CompositingTriggerFlags&gt;(AllTriggers); }
338 
</pre>
<hr />
<pre>
363 
364 #if ENABLE(FULLSCREEN_API)
365     virtual bool supportsFullScreenForElement(const Element&amp;, bool) { return false; }
366     virtual void enterFullScreenForElement(Element&amp;) { }
367     virtual void exitFullScreenForElement(Element*) { }
368     virtual void setRootFullScreenLayer(GraphicsLayer*) { }
369 #endif
370 
371 #if USE(COORDINATED_GRAPHICS)
372     virtual IntRect visibleRectForTiledBackingStore() const { return IntRect(); }
373 #endif
374 
375 #if PLATFORM(COCOA)
376     virtual NSResponder *firstResponder() { return nullptr; }
377     virtual void makeFirstResponder(NSResponder *) { }
378     // Focuses on the containing view associated with this page.
379     virtual void makeFirstResponder() { }
380     virtual void assistiveTechnologyMakeFirstResponder() { }
381 #endif
382 
<span class="line-added">383     virtual bool testProcessIncomingSyncMessagesWhenWaitingForSyncReply() { return true; }</span>
<span class="line-added">384 </span>
385 #if PLATFORM(IOS_FAMILY)
386     // FIXME: Come up with a more descriptive name for this function and make it platform independent (if possible).
387     virtual bool isStopping() = 0;
388 #endif
389 
390     virtual void enableSuddenTermination() { }
391     virtual void disableSuddenTermination() { }
392 
<span class="line-modified">393     virtual void contentRuleListNotification(const URL&amp;, const ContentRuleListResults&amp;) { };</span>
394 
395 #if PLATFORM(WIN)
396     virtual void setLastSetCursorToCurrentCursor() = 0;
397     virtual void AXStartFrameLoad() = 0;
398     virtual void AXFinishFrameLoad() = 0;
399 #endif
400 
401     virtual bool selectItemWritingDirectionIsNatural() = 0;
402     virtual bool selectItemAlignmentFollowsMenuWritingDirection() = 0;
403     // Checks if there is an opened popup, called by RenderMenuList::showPopup().
404     virtual RefPtr&lt;PopupMenu&gt; createPopupMenu(PopupMenuClient&amp;) const = 0;
405     virtual RefPtr&lt;SearchPopupMenu&gt; createSearchPopupMenu(PopupMenuClient&amp;) const = 0;
406 
407     virtual void postAccessibilityNotification(AccessibilityObject&amp;, AXObjectCache::AXNotification) { }
408 
409     virtual void notifyScrollerThumbIsVisibleInRect(const IntRect&amp;) { }
410     virtual void recommendedScrollbarStyleDidChange(ScrollbarStyle) { }
411 
412     virtual Optional&lt;ScrollbarOverlayStyle&gt; preferredScrollbarOverlayStyle() { return WTF::nullopt; }
413 
414     virtual void wheelEventHandlersChanged(bool hasHandlers) = 0;
415 
416     virtual bool isSVGImageChromeClient() const { return false; }
417 
418 #if ENABLE(POINTER_LOCK)
419     virtual bool requestPointerLock() { return false; }
420     virtual void requestPointerUnlock() { }
421 #endif
422 
423     virtual FloatSize minimumWindowSize() const { return FloatSize(100, 100); };
424 
425     virtual bool isEmptyChromeClient() const { return false; }
426 
427     virtual String plugInStartLabelTitle(const String&amp; mimeType) const { UNUSED_PARAM(mimeType); return String(); }
428     virtual String plugInStartLabelSubtitle(const String&amp; mimeType) const { UNUSED_PARAM(mimeType); return String(); }
429     virtual String plugInExtraStyleSheet() const { return String(); }
430     virtual String plugInExtraScript() const { return String(); }
431 
<span class="line-modified">432     virtual void didAssociateFormControls(const Vector&lt;RefPtr&lt;Element&gt;&gt;&amp;, Frame&amp;) { };</span>
433     virtual bool shouldNotifyOnFormChanges() { return false; };
434 
435     virtual void didAddHeaderLayer(GraphicsLayer&amp;) { }
436     virtual void didAddFooterLayer(GraphicsLayer&amp;) { }
437 
438     virtual bool shouldUseTiledBackingForFrameView(const FrameView&amp;) const { return false; }
439 
440     virtual void isPlayingMediaDidChange(MediaProducer::MediaStateFlags, uint64_t) { }
441     virtual void handleAutoplayEvent(AutoplayEvent, OptionSet&lt;AutoplayEventFlags&gt;) { }
442 
443 #if ENABLE(MEDIA_SESSION)
444     virtual void hasMediaSessionWithActiveMediaElementsDidChange(bool) { }
445     virtual void mediaSessionMetadataDidChange(const MediaSessionMetadata&amp;) { }
446     virtual void focusedContentMediaElementDidChange(uint64_t) { }
447 #endif
448 
449 #if ENABLE(WEB_CRYPTO)
450     virtual bool wrapCryptoKey(const Vector&lt;uint8_t&gt;&amp;, Vector&lt;uint8_t&gt;&amp;) const { return false; }
451     virtual bool unwrapCryptoKey(const Vector&lt;uint8_t&gt;&amp;, Vector&lt;uint8_t&gt;&amp;) const { return false; }
452 #endif
</pre>
<hr />
<pre>
469 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
470     virtual void addPlaybackTargetPickerClient(uint64_t /*contextId*/) { }
471     virtual void removePlaybackTargetPickerClient(uint64_t /*contextId*/) { }
472     virtual void showPlaybackTargetPicker(uint64_t /*contextId*/, const IntPoint&amp;, bool /*isVideo*/) { }
473     virtual void playbackTargetPickerClientStateDidChange(uint64_t /*contextId*/, MediaProducer::MediaStateFlags) { }
474     virtual void setMockMediaPlaybackTargetPickerEnabled(bool)  { }
475     virtual void setMockMediaPlaybackTargetPickerState(const String&amp;, MediaPlaybackTargetContext::State) { }
476 #endif
477 
478     virtual void imageOrMediaDocumentSizeChanged(const IntSize&amp;) { }
479 
480 #if ENABLE(VIDEO) &amp;&amp; USE(GSTREAMER)
481     virtual void requestInstallMissingMediaPlugins(const String&amp; /*details*/, const String&amp; /*description*/, MediaPlayerRequestInstallMissingPluginsCallback&amp;) { }
482 #endif
483 
484     virtual void didInvalidateDocumentMarkerRects() { }
485 
486     virtual void reportProcessCPUTime(Seconds, ActivityStateForCPUSampling) { }
487     virtual RefPtr&lt;Icon&gt; createIconForFiles(const Vector&lt;String&gt;&amp; /* filenames */) = 0;
488 
<span class="line-modified">489 #if ENABLE(RESOURCE_LOAD_STATISTICS)</span>
<span class="line-modified">490     virtual void hasStorageAccess(RegistrableDomain&amp;&amp; /*subFrameDomain*/, RegistrableDomain&amp;&amp; /*topFrameDomain*/, FrameIdentifier, PageIdentifier, WTF::CompletionHandler&lt;void(bool)&gt;&amp;&amp; completionHandler) { completionHandler(false); }</span>
<span class="line-added">491     virtual void requestStorageAccess(RegistrableDomain&amp;&amp; /*subFrameDomain*/, RegistrableDomain&amp;&amp; /*topFrameDomain*/, FrameIdentifier, PageIdentifier, WTF::CompletionHandler&lt;void(StorageAccessWasGranted, StorageAccessPromptWasShown)&gt;&amp;&amp; completionHandler) { completionHandler(StorageAccessWasGranted::No, StorageAccessPromptWasShown::No); }</span>
<span class="line-added">492 #endif</span>
<span class="line-added">493 </span>
<span class="line-added">494 #if ENABLE(DEVICE_ORIENTATION)</span>
<span class="line-added">495     virtual void shouldAllowDeviceOrientationAndMotionAccess(Frame&amp;, bool /* mayPrompt */, WTF::CompletionHandler&lt;void(DeviceOrientationOrMotionPermissionState)&gt;&amp;&amp; callback) { callback(DeviceOrientationOrMotionPermissionState::Denied); }</span>
<span class="line-added">496 #endif</span>
497 
498     virtual void didInsertMenuElement(HTMLMenuElement&amp;) { }
499     virtual void didRemoveMenuElement(HTMLMenuElement&amp;) { }
500     virtual void didInsertMenuItemElement(HTMLMenuItemElement&amp;) { }
501     virtual void didRemoveMenuItemElement(HTMLMenuItemElement&amp;) { }
502 
503     virtual String signedPublicKeyAndChallengeString(unsigned, const String&amp;, const URL&amp;) const { return emptyString(); }
504 
505     virtual void associateEditableImageWithAttachment(GraphicsLayer::EmbeddedViewID, const String&amp;) { }
506     virtual void didCreateEditableImage(GraphicsLayer::EmbeddedViewID) { }
507     virtual void didDestroyEditableImage(GraphicsLayer::EmbeddedViewID) { }
508 
<span class="line-added">509     virtual void configureLoggingChannel(const String&amp;, WTFLogChannelState, WTFLogLevel) { }</span>
<span class="line-added">510 </span>
<span class="line-added">511     virtual bool userIsInteracting() const { return false; }</span>
<span class="line-added">512     virtual void setUserIsInteracting(bool) { }</span>
<span class="line-added">513 </span>
514 protected:
515     virtual ~ChromeClient() = default;
516 };
517 
518 } // namespace WebCore
</pre>
</td>
</tr>
</table>
<center><a href="Chrome.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ClientOrigin.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>