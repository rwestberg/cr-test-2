<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/page/scrolling/AsyncScrollingCoordinator.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../linux/ResourceUsageThreadLinux.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="AsyncScrollingCoordinator.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/page/scrolling/AsyncScrollingCoordinator.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 
 28 #if ENABLE(ASYNC_SCROLLING)
 29 #include &quot;AsyncScrollingCoordinator.h&quot;
 30 
 31 #include &quot;DebugPageOverlays.h&quot;
 32 #include &quot;Document.h&quot;
 33 #include &quot;EditorClient.h&quot;
 34 #include &quot;Frame.h&quot;
 35 #include &quot;FrameView.h&quot;
 36 #include &quot;GraphicsLayer.h&quot;
 37 #include &quot;Logging.h&quot;
 38 #include &quot;Page.h&quot;
 39 #include &quot;PerformanceLoggingClient.h&quot;


 40 #include &quot;ScrollAnimator.h&quot;
 41 #include &quot;ScrollingConstraints.h&quot;
 42 #include &quot;ScrollingStateFixedNode.h&quot;
 43 #include &quot;ScrollingStateFrameHostingNode.h&quot;
 44 #include &quot;ScrollingStateFrameScrollingNode.h&quot;

 45 #include &quot;ScrollingStateOverflowScrollingNode.h&quot;

 46 #include &quot;ScrollingStateStickyNode.h&quot;
 47 #include &quot;ScrollingStateTree.h&quot;
 48 #include &quot;Settings.h&quot;
 49 #include &quot;WheelEventTestTrigger.h&quot;
 50 #include &lt;wtf/ProcessID.h&gt;
 51 #include &lt;wtf/text/TextStream.h&gt;
 52 
 53 namespace WebCore {
 54 
 55 AsyncScrollingCoordinator::AsyncScrollingCoordinator(Page* page)
 56     : ScrollingCoordinator(page)
 57     , m_updateNodeScrollPositionTimer(*this, &amp;AsyncScrollingCoordinator::updateScrollPositionAfterAsyncScrollTimerFired)
<span class="line-modified"> 58     , m_scrollingStateTree(std::make_unique&lt;ScrollingStateTree&gt;(this))</span>
 59 {
 60 }
 61 
 62 AsyncScrollingCoordinator::~AsyncScrollingCoordinator() = default;
 63 
 64 void AsyncScrollingCoordinator::scrollingStateTreePropertiesChanged()
 65 {
 66     scheduleTreeStateCommit();
 67 }
 68 
 69 #if ENABLE(CSS_SCROLL_SNAP)
 70 static inline void setStateScrollingNodeSnapOffsetsAsFloat(ScrollingStateScrollingNode&amp; node, ScrollEventAxis axis, const Vector&lt;LayoutUnit&gt;* snapOffsets, const Vector&lt;ScrollOffsetRange&lt;LayoutUnit&gt;&gt;* snapOffsetRanges, float deviceScaleFactor)
 71 {
 72     // FIXME: Incorporate current page scale factor in snapping to device pixel. Perhaps we should just convert to float here and let UI process do the pixel snapping?
 73     Vector&lt;float&gt; snapOffsetsAsFloat;
 74     if (snapOffsets) {
 75         snapOffsetsAsFloat.reserveInitialCapacity(snapOffsets-&gt;size());
 76         for (auto&amp; offset : *snapOffsets)
 77             snapOffsetsAsFloat.uncheckedAppend(roundToDevicePixel(offset, deviceScaleFactor, false));
 78     }
</pre>
<hr />
<pre>
110     if (!m_eventTrackingRegionsDirty)
111         return;
112 
113     if (!m_scrollingStateTree-&gt;rootStateNode())
114         return;
115 
116     m_scrollingStateTree-&gt;rootStateNode()-&gt;setEventTrackingRegions(absoluteEventTrackingRegions());
117     m_eventTrackingRegionsDirty = false;
118 }
119 
120 void AsyncScrollingCoordinator::frameViewLayoutUpdated(FrameView&amp; frameView)
121 {
122     ASSERT(isMainThread());
123     ASSERT(m_page);
124 
125     // If there isn&#39;t a root node yet, don&#39;t do anything. We&#39;ll be called again after creating one.
126     if (!m_scrollingStateTree-&gt;rootStateNode())
127         return;
128 
129     setEventTrackingRegionsDirty();
<span class="line-removed">130     if (!coordinatesScrollingForFrameView(frameView))</span>
<span class="line-removed">131         return;</span>
132 
<span class="line-modified">133     auto* node = m_scrollingStateTree-&gt;stateNodeForID(frameView.scrollingNodeID());</span>
<span class="line-modified">134     if (!node || !is&lt;ScrollingStateFrameScrollingNode&gt;(*node))</span>
135         return;
136 
<span class="line-removed">137     auto&amp; frameScrollingNode = downcast&lt;ScrollingStateFrameScrollingNode&gt;(*node);</span>
<span class="line-removed">138 </span>
<span class="line-removed">139     auto* verticalScrollbar = frameView.verticalScrollbar();</span>
<span class="line-removed">140     auto* horizontalScrollbar = frameView.horizontalScrollbar();</span>
<span class="line-removed">141     frameScrollingNode.setScrollerImpsFromScrollbars(verticalScrollbar, horizontalScrollbar);</span>
<span class="line-removed">142 </span>
<span class="line-removed">143     frameScrollingNode.setFrameScaleFactor(frameView.frame().frameScaleFactor());</span>
<span class="line-removed">144     frameScrollingNode.setHeaderHeight(frameView.headerHeight());</span>
<span class="line-removed">145     frameScrollingNode.setFooterHeight(frameView.footerHeight());</span>
<span class="line-removed">146     frameScrollingNode.setTopContentInset(frameView.topContentInset());</span>
<span class="line-removed">147 </span>
<span class="line-removed">148     frameScrollingNode.setVisualViewportEnabled(visualViewportEnabled());</span>
<span class="line-removed">149     frameScrollingNode.setLayoutViewport(frameView.layoutViewportRect());</span>
<span class="line-removed">150     frameScrollingNode.setAsyncFrameOrOverflowScrollingEnabled(asyncFrameOrOverflowScrollingEnabled());</span>
<span class="line-removed">151 </span>
<span class="line-removed">152     frameScrollingNode.setMinLayoutViewportOrigin(frameView.minStableLayoutViewportOrigin());</span>
<span class="line-removed">153     frameScrollingNode.setMaxLayoutViewportOrigin(frameView.maxStableLayoutViewportOrigin());</span>
<span class="line-removed">154 </span>
<span class="line-removed">155     frameScrollingNode.setScrollOrigin(frameView.scrollOrigin());</span>
<span class="line-removed">156     frameScrollingNode.setScrollableAreaSize(frameView.visibleContentRect().size());</span>
<span class="line-removed">157     frameScrollingNode.setTotalContentsSize(frameView.totalContentsSize());</span>
<span class="line-removed">158     frameScrollingNode.setReachableContentsSize(frameView.totalContentsSize());</span>
<span class="line-removed">159     frameScrollingNode.setFixedElementsLayoutRelativeToFrame(frameView.fixedElementsLayoutRelativeToFrame());</span>
<span class="line-removed">160     frameScrollingNode.setScrollBehaviorForFixedElements(frameView.scrollBehaviorForFixedElements());</span>
<span class="line-removed">161 </span>
<span class="line-removed">162 #if ENABLE(CSS_SCROLL_SNAP)</span>
<span class="line-removed">163     frameView.updateSnapOffsets();</span>
<span class="line-removed">164     updateScrollSnapPropertiesWithFrameView(frameView);</span>
<span class="line-removed">165 #endif</span>
<span class="line-removed">166 </span>
<span class="line-removed">167 #if PLATFORM(COCOA)</span>
168     auto* page = frameView.frame().page();
169     if (page &amp;&amp; page-&gt;expectsWheelEventTriggers()) {
170         LOG(WheelEventTestTriggers, &quot;    AsyncScrollingCoordinator::frameViewLayoutUpdated: Expects wheel event test trigger=%d&quot;, page-&gt;expectsWheelEventTriggers());






171         frameScrollingNode.setExpectsWheelEventTestTrigger(page-&gt;expectsWheelEventTriggers());
172     }


173 #endif

174 
<span class="line-modified">175     ScrollableAreaParameters scrollParameters;</span>
<span class="line-modified">176     scrollParameters.horizontalScrollElasticity = frameView.horizontalScrollElasticity();</span>
<span class="line-modified">177     scrollParameters.verticalScrollElasticity = frameView.verticalScrollElasticity();</span>
<span class="line-modified">178     scrollParameters.hasEnabledHorizontalScrollbar = horizontalScrollbar &amp;&amp; horizontalScrollbar-&gt;enabled();</span>
<span class="line-modified">179     scrollParameters.hasEnabledVerticalScrollbar = verticalScrollbar &amp;&amp; verticalScrollbar-&gt;enabled();</span>
<span class="line-modified">180     scrollParameters.horizontalScrollbarMode = frameView.horizontalScrollbarMode();</span>
<span class="line-modified">181     scrollParameters.verticalScrollbarMode = frameView.verticalScrollbarMode();</span>
<span class="line-removed">182     scrollParameters.useDarkAppearanceForScrollbars = frameView.useDarkAppearanceForScrollbars();</span>
183 
<span class="line-modified">184     frameScrollingNode.setScrollableAreaParameters(scrollParameters);</span>












185 }
186 
187 void AsyncScrollingCoordinator::updateExpectsWheelEventTestTriggerWithFrameView(const FrameView&amp; frameView)
188 {
189     auto* page = frameView.frame().page();
190     if (!page)
191         return;
192 
193     auto* node = downcast&lt;ScrollingStateFrameScrollingNode&gt;(m_scrollingStateTree-&gt;stateNodeForID(frameView.scrollingNodeID()));
194     if (!node)
195         return;
196 
197     node-&gt;setExpectsWheelEventTestTrigger(page-&gt;expectsWheelEventTriggers());
198 }
199 
200 void AsyncScrollingCoordinator::frameViewEventTrackingRegionsChanged(FrameView&amp; frameView)
201 {
202     if (!m_scrollingStateTree-&gt;rootStateNode())
203         return;
204 
</pre>
<hr />
<pre>
222     // If the root layer does not have a ScrollingStateNode, then we should create one.
223     ensureRootStateNodeForFrameView(frameView);
224     ASSERT(m_scrollingStateTree-&gt;stateNodeForID(frameView.scrollingNodeID()));
225 
226     ScrollingCoordinator::frameViewRootLayerDidChange(frameView);
227 
228     auto* node = downcast&lt;ScrollingStateFrameScrollingNode&gt;(m_scrollingStateTree-&gt;stateNodeForID(frameView.scrollingNodeID()));
229     node-&gt;setScrollContainerLayer(scrollContainerLayerForFrameView(frameView));
230     node-&gt;setScrolledContentsLayer(scrolledContentsLayerForFrameView(frameView));
231     node-&gt;setRootContentsLayer(rootContentsLayerForFrameView(frameView));
232     node-&gt;setCounterScrollingLayer(counterScrollingLayerForFrameView(frameView));
233     node-&gt;setInsetClipLayer(insetClipLayerForFrameView(frameView));
234     node-&gt;setContentShadowLayer(contentShadowLayerForFrameView(frameView));
235     node-&gt;setHeaderLayer(headerLayerForFrameView(frameView));
236     node-&gt;setFooterLayer(footerLayerForFrameView(frameView));
237     node-&gt;setScrollBehaviorForFixedElements(frameView.scrollBehaviorForFixedElements());
238     node-&gt;setVerticalScrollbarLayer(frameView.layerForVerticalScrollbar());
239     node-&gt;setHorizontalScrollbarLayer(frameView.layerForHorizontalScrollbar());
240 }
241 
<span class="line-modified">242 bool AsyncScrollingCoordinator::requestScrollPositionUpdate(FrameView&amp; frameView, const IntPoint&amp; scrollPosition)</span>
243 {
244     ASSERT(isMainThread());
245     ASSERT(m_page);
246 
<span class="line-modified">247     if (!coordinatesScrollingForFrameView(frameView))</span>





248         return false;
249 
<span class="line-modified">250     bool isProgrammaticScroll = frameView.inProgrammaticScroll();</span>
<span class="line-modified">251     if (isProgrammaticScroll || frameView.frame().document()-&gt;pageCacheState() != Document::NotInPageCache)</span>
<span class="line-modified">252         updateScrollPositionAfterAsyncScroll(frameView.scrollingNodeID(), scrollPosition, WTF::nullopt, isProgrammaticScroll, ScrollingLayerPositionAction::Set);</span>




253 
254     // If this frame view&#39;s document is being put into the page cache, we don&#39;t want to update our
255     // main frame scroll position. Just let the FrameView think that we did.
<span class="line-modified">256     if (frameView.frame().document()-&gt;pageCacheState() != Document::NotInPageCache)</span>
257         return true;
258 
<span class="line-modified">259     auto* stateNode = downcast&lt;ScrollingStateScrollingNode&gt;(m_scrollingStateTree-&gt;stateNodeForID(frameView.scrollingNodeID()));</span>
260     if (!stateNode)
261         return false;
262 
<span class="line-modified">263     stateNode-&gt;setRequestedScrollPosition(scrollPosition, isProgrammaticScroll);</span>
264     return true;
265 }
266 
<span class="line-modified">267 void AsyncScrollingCoordinator::scheduleUpdateScrollPositionAfterAsyncScroll(ScrollingNodeID nodeID, const FloatPoint&amp; scrollPosition, const Optional&lt;FloatPoint&gt;&amp; layoutViewportOrigin, bool programmaticScroll, ScrollingLayerPositionAction scrollingLayerPositionAction)</span>
268 {
<span class="line-modified">269     ScheduledScrollUpdate scrollUpdate(nodeID, scrollPosition, layoutViewportOrigin, programmaticScroll, scrollingLayerPositionAction);</span>

270 
<span class="line-modified">271     // For programmatic scrolls, requestScrollPositionUpdate() has already called updateScrollPositionAfterAsyncScroll().</span>
<span class="line-modified">272     if (programmaticScroll)</span>
<span class="line-modified">273         return;</span>
274 
275     if (m_updateNodeScrollPositionTimer.isActive()) {
276         if (m_scheduledScrollUpdate.matchesUpdateType(scrollUpdate)) {
277             m_scheduledScrollUpdate.scrollPosition = scrollPosition;
278             m_scheduledScrollUpdate.layoutViewportOrigin = layoutViewportOrigin;
279             return;
280         }
281 
282         // If the parameters don&#39;t match what was previously scheduled, dispatch immediately.
283         m_updateNodeScrollPositionTimer.stop();
<span class="line-modified">284         updateScrollPositionAfterAsyncScroll(m_scheduledScrollUpdate.nodeID, m_scheduledScrollUpdate.scrollPosition, m_scheduledScrollUpdate.layoutViewportOrigin, m_scheduledScrollUpdate.isProgrammaticScroll, m_scheduledScrollUpdate.updateLayerPositionAction);</span>
<span class="line-modified">285         updateScrollPositionAfterAsyncScroll(nodeID, scrollPosition, layoutViewportOrigin, programmaticScroll, scrollingLayerPositionAction);</span>
286         return;
287     }
288 
289     m_scheduledScrollUpdate = scrollUpdate;
290     m_updateNodeScrollPositionTimer.startOneShot(0_s);
291 }
292 
293 void AsyncScrollingCoordinator::updateScrollPositionAfterAsyncScrollTimerFired()
294 {
<span class="line-modified">295     updateScrollPositionAfterAsyncScroll(m_scheduledScrollUpdate.nodeID, m_scheduledScrollUpdate.scrollPosition, m_scheduledScrollUpdate.layoutViewportOrigin, m_scheduledScrollUpdate.isProgrammaticScroll, m_scheduledScrollUpdate.updateLayerPositionAction);</span>
296 }
297 
298 FrameView* AsyncScrollingCoordinator::frameViewForScrollingNode(ScrollingNodeID scrollingNodeID) const
299 {
300     if (!m_scrollingStateTree-&gt;rootStateNode())
301         return nullptr;
302 
303     if (scrollingNodeID == m_scrollingStateTree-&gt;rootStateNode()-&gt;scrollingNodeID())
304         return m_page-&gt;mainFrame().view();
305 
306     auto* stateNode = m_scrollingStateTree-&gt;stateNodeForID(scrollingNodeID);
307     if (!stateNode)
308         return nullptr;
309 
310     // Find the enclosing frame scrolling node.
311     auto* parentNode = stateNode;
312     while (parentNode &amp;&amp; !parentNode-&gt;isFrameScrollingNode())
313         parentNode = parentNode-&gt;parent();
314 
315     if (!parentNode)
316         return nullptr;
317 
318     // Walk the frame tree to find the matching FrameView. This is not ideal, but avoids back pointers to FrameViews
319     // from ScrollingTreeStateNodes.
320     for (Frame* frame = &amp;m_page-&gt;mainFrame(); frame; frame = frame-&gt;tree().traverseNext()) {
321         if (auto* view = frame-&gt;view()) {
322             if (view-&gt;scrollingNodeID() == parentNode-&gt;scrollingNodeID())
323                 return view;
324         }
325     }
326 
327     return nullptr;
328 }
329 
<span class="line-modified">330 void AsyncScrollingCoordinator::updateScrollPositionAfterAsyncScroll(ScrollingNodeID scrollingNodeID, const FloatPoint&amp; scrollPosition, Optional&lt;FloatPoint&gt; layoutViewportOrigin, bool programmaticScroll, ScrollingLayerPositionAction scrollingLayerPositionAction)</span>
331 {
332     ASSERT(isMainThread());
333 
334     if (!m_page)
335         return;
336 
337     auto* frameViewPtr = frameViewForScrollingNode(scrollingNodeID);
338     if (!frameViewPtr)
339         return;
340 
341     LOG_WITH_STREAM(Scrolling, stream &lt;&lt; &quot;AsyncScrollingCoordinator::updateScrollPositionAfterAsyncScroll node &quot; &lt;&lt; scrollingNodeID &lt;&lt; &quot; scrollPosition &quot; &lt;&lt; scrollPosition &lt;&lt; &quot; action &quot; &lt;&lt; scrollingLayerPositionAction);
342 
343     auto&amp; frameView = *frameViewPtr;
344 
345     if (scrollingNodeID == frameView.scrollingNodeID()) {
<span class="line-modified">346         reconcileScrollingState(frameView, scrollPosition, layoutViewportOrigin, programmaticScroll, ViewportRectStability::Stable, scrollingLayerPositionAction);</span>
347 
348 #if PLATFORM(COCOA)
349         if (m_page-&gt;expectsWheelEventTriggers()) {
350             frameView.scrollAnimator().setWheelEventTestTrigger(m_page-&gt;testTrigger());
351             if (const auto&amp; trigger = m_page-&gt;testTrigger())
352                 trigger-&gt;removeTestDeferralForReason(reinterpret_cast&lt;WheelEventTestTrigger::ScrollableAreaIdentifier&gt;(scrollingNodeID), WheelEventTestTrigger::ScrollingThreadSyncNeeded);
353         }
354 #endif
355 
356         return;
357     }
358 
359     // Overflow-scroll area.
360     if (auto* scrollableArea = frameView.scrollableAreaForScrollLayerID(scrollingNodeID)) {
<span class="line-modified">361         scrollableArea-&gt;setIsUserScroll(scrollingLayerPositionAction == ScrollingLayerPositionAction::Sync);</span>
<span class="line-modified">362         scrollableArea-&gt;scrollToOffsetWithoutAnimation(scrollPosition);</span>
<span class="line-modified">363         scrollableArea-&gt;setIsUserScroll(false);</span>


364         if (scrollingLayerPositionAction == ScrollingLayerPositionAction::Set)
365             m_page-&gt;editorClient().overflowScrollPositionChanged();
366 
367 #if PLATFORM(COCOA)
368         if (m_page-&gt;expectsWheelEventTriggers()) {
369             frameView.scrollAnimator().setWheelEventTestTrigger(m_page-&gt;testTrigger());
370             if (const auto&amp; trigger = m_page-&gt;testTrigger())
371                 trigger-&gt;removeTestDeferralForReason(reinterpret_cast&lt;WheelEventTestTrigger::ScrollableAreaIdentifier&gt;(scrollingNodeID), WheelEventTestTrigger::ScrollingThreadSyncNeeded);
372         }
373 #endif
374     }
375 }
376 
<span class="line-modified">377 void AsyncScrollingCoordinator::reconcileScrollingState(FrameView&amp; frameView, const FloatPoint&amp; scrollPosition, const LayoutViewportOriginOrOverrideRect&amp; layoutViewportOriginOrOverrideRect, bool programmaticScroll, ViewportRectStability viewportRectStability, ScrollingLayerPositionAction scrollingLayerPositionAction)</span>
378 {
<span class="line-modified">379     bool oldProgrammaticScroll = frameView.inProgrammaticScroll();</span>
<span class="line-modified">380     frameView.setInProgrammaticScroll(programmaticScroll);</span>
381 
<span class="line-modified">382     LOG_WITH_STREAM(Scrolling, stream &lt;&lt; getCurrentProcessID() &lt;&lt; &quot; AsyncScrollingCoordinator &quot; &lt;&lt; this &lt;&lt; &quot; reconcileScrollingState scrollPosition &quot; &lt;&lt; scrollPosition &lt;&lt; &quot; programmaticScroll &quot; &lt;&lt; programmaticScroll &lt;&lt; &quot; stability &quot; &lt;&lt; viewportRectStability &lt;&lt; &quot; &quot; &lt;&lt; scrollingLayerPositionAction);</span>
383 
384     Optional&lt;FloatRect&gt; layoutViewportRect;
385 
386     WTF::switchOn(layoutViewportOriginOrOverrideRect,
387         [&amp;frameView](Optional&lt;FloatPoint&gt; origin) {
388             if (origin)
389                 frameView.setBaseLayoutViewportOrigin(LayoutPoint(origin.value()), FrameView::TriggerLayoutOrNot::No);
<span class="line-modified">390         }, [&amp;frameView, &amp;layoutViewportRect, viewportRectStability, visualViewportEnabled = visualViewportEnabled()](Optional&lt;FloatRect&gt; overrideRect) {</span>
391             if (!overrideRect)
392                 return;
393 
394             layoutViewportRect = overrideRect;
<span class="line-modified">395             if (visualViewportEnabled &amp;&amp; viewportRectStability != ViewportRectStability::ChangingObscuredInsetsInteractively)</span>
396                 frameView.setLayoutViewportOverrideRect(LayoutRect(overrideRect.value()), viewportRectStability == ViewportRectStability::Stable ? FrameView::TriggerLayoutOrNot::Yes : FrameView::TriggerLayoutOrNot::No);
<span class="line-removed">397 #if PLATFORM(IOS_FAMILY)</span>
<span class="line-removed">398             else if (viewportRectStability == ViewportRectStability::Stable)</span>
<span class="line-removed">399                 frameView.setCustomFixedPositionLayoutRect(enclosingIntRect(overrideRect.value()));</span>
<span class="line-removed">400 #endif</span>
401         }
402     );
403 
404     frameView.setConstrainsScrollingToContentEdge(false);
405     frameView.notifyScrollPositionChanged(roundedIntPoint(scrollPosition));
406     frameView.setConstrainsScrollingToContentEdge(true);
<span class="line-removed">407     frameView.setInProgrammaticScroll(oldProgrammaticScroll);</span>
408 
<span class="line-modified">409     if (!programmaticScroll &amp;&amp; scrollingLayerPositionAction != ScrollingLayerPositionAction::Set) {</span>


410         auto scrollingNodeID = frameView.scrollingNodeID();
411         if (viewportRectStability == ViewportRectStability::Stable)
412             reconcileViewportConstrainedLayerPositions(scrollingNodeID, frameView.rectForFixedPositionLayout(), scrollingLayerPositionAction);
413         else if (layoutViewportRect)
414             reconcileViewportConstrainedLayerPositions(scrollingNodeID, LayoutRect(layoutViewportRect.value()), scrollingLayerPositionAction);
415     }
416 
417     if (!scrolledContentsLayerForFrameView(frameView))
418         return;
419 
420     auto* counterScrollingLayer = counterScrollingLayerForFrameView(frameView);
421     auto* insetClipLayer = insetClipLayerForFrameView(frameView);
422     auto* contentShadowLayer = contentShadowLayerForFrameView(frameView);
423     auto* rootContentsLayer = rootContentsLayerForFrameView(frameView);
424     auto* headerLayer = headerLayerForFrameView(frameView);
425     auto* footerLayer = footerLayerForFrameView(frameView);
426 
427     ASSERT(frameView.scrollPosition() == roundedIntPoint(scrollPosition));
428     LayoutPoint scrollPositionForFixed = frameView.scrollPositionForFixedPosition();
429     float topContentInset = frameView.topContentInset();
430 
431     FloatPoint positionForInsetClipLayer;
432     if (insetClipLayer)
433         positionForInsetClipLayer = FloatPoint(insetClipLayer-&gt;position().x(), FrameView::yPositionForInsetClipLayer(scrollPosition, topContentInset));
434     FloatPoint positionForContentsLayer = frameView.positionForRootContentLayer();
435 
436     FloatPoint positionForHeaderLayer = FloatPoint(scrollPositionForFixed.x(), FrameView::yPositionForHeaderLayer(scrollPosition, topContentInset));
437     FloatPoint positionForFooterLayer = FloatPoint(scrollPositionForFixed.x(),
438         FrameView::yPositionForFooterLayer(scrollPosition, topContentInset, frameView.totalContentsSize().height(), frameView.footerHeight()));
439 
<span class="line-modified">440     if (programmaticScroll || scrollingLayerPositionAction == ScrollingLayerPositionAction::Set) {</span>
441         reconcileScrollPosition(frameView, ScrollingLayerPositionAction::Set);
442 
443         if (counterScrollingLayer)
444             counterScrollingLayer-&gt;setPosition(scrollPositionForFixed);
445         if (insetClipLayer)
446             insetClipLayer-&gt;setPosition(positionForInsetClipLayer);
447         if (contentShadowLayer)
448             contentShadowLayer-&gt;setPosition(positionForContentsLayer);
449         if (rootContentsLayer)
450             rootContentsLayer-&gt;setPosition(positionForContentsLayer);
451         if (headerLayer)
452             headerLayer-&gt;setPosition(positionForHeaderLayer);
453         if (footerLayer)
454             footerLayer-&gt;setPosition(positionForFooterLayer);
455     } else {
456         reconcileScrollPosition(frameView, ScrollingLayerPositionAction::Sync);
457 
458         if (counterScrollingLayer)
459             counterScrollingLayer-&gt;syncPosition(scrollPositionForFixed);
460         if (insetClipLayer)
</pre>
<hr />
<pre>
465             rootContentsLayer-&gt;syncPosition(positionForContentsLayer);
466         if (headerLayer)
467             headerLayer-&gt;syncPosition(positionForHeaderLayer);
468         if (footerLayer)
469             footerLayer-&gt;syncPosition(positionForFooterLayer);
470     }
471 }
472 
473 void AsyncScrollingCoordinator::reconcileScrollPosition(FrameView&amp; frameView, ScrollingLayerPositionAction scrollingLayerPositionAction)
474 {
475 #if PLATFORM(IOS_FAMILY)
476     // Doing all scrolling like this (UIScrollView style) would simplify code.
477     auto* scrollContainerLayer = scrollContainerLayerForFrameView(frameView);
478     if (!scrollContainerLayer)
479         return;
480     if (scrollingLayerPositionAction == ScrollingLayerPositionAction::Set)
481         scrollContainerLayer-&gt;setBoundsOrigin(frameView.scrollPosition());
482     else
483         scrollContainerLayer-&gt;syncBoundsOrigin(frameView.scrollPosition());
484 #else

485     auto* scrolledContentsLayer = scrolledContentsLayerForFrameView(frameView);
486     if (!scrolledContentsLayer)
487         return;
488     if (scrollingLayerPositionAction == ScrollingLayerPositionAction::Set)
489         scrolledContentsLayer-&gt;setPosition(-frameView.scrollPosition());
490     else
491         scrolledContentsLayer-&gt;syncPosition(-frameView.scrollPosition());
492 #endif
493 }
494 
495 void AsyncScrollingCoordinator::scrollableAreaScrollbarLayerDidChange(ScrollableArea&amp; scrollableArea, ScrollbarOrientation orientation)
496 {
497     ASSERT(isMainThread());
498     ASSERT(m_page);
499 
500     auto* node = m_scrollingStateTree-&gt;stateNodeForID(scrollableArea.scrollingNodeID());
<span class="line-modified">501     if (is&lt;ScrollingStateFrameScrollingNode&gt;(node)) {</span>
<span class="line-modified">502         auto&amp; scrollingNode = downcast&lt;ScrollingStateFrameScrollingNode&gt;(*node);</span>
503         if (orientation == VerticalScrollbar)
504             scrollingNode.setVerticalScrollbarLayer(scrollableArea.layerForVerticalScrollbar());
505         else
506             scrollingNode.setHorizontalScrollbarLayer(scrollableArea.layerForHorizontalScrollbar());
507     }
508 
<span class="line-modified">509     if (&amp;scrollableArea == m_page-&gt;mainFrame().view()) {</span>
<span class="line-modified">510         if (orientation == VerticalScrollbar)</span>
<span class="line-modified">511             scrollableArea.verticalScrollbarLayerDidChange();</span>
<span class="line-modified">512         else</span>
<span class="line-removed">513             scrollableArea.horizontalScrollbarLayerDidChange();</span>
<span class="line-removed">514     }</span>
515 }
516 
517 ScrollingNodeID AsyncScrollingCoordinator::createNode(ScrollingNodeType nodeType, ScrollingNodeID newNodeID)
518 {
519     LOG_WITH_STREAM(Scrolling, stream &lt;&lt; &quot;AsyncScrollingCoordinator::createNode &quot; &lt;&lt; nodeType &lt;&lt; &quot; node &quot; &lt;&lt; newNodeID);
520     return m_scrollingStateTree-&gt;createUnparentedNode(nodeType, newNodeID);
521 }
522 
523 ScrollingNodeID AsyncScrollingCoordinator::insertNode(ScrollingNodeType nodeType, ScrollingNodeID newNodeID, ScrollingNodeID parentID, size_t childIndex)
524 {
525     LOG_WITH_STREAM(Scrolling, stream &lt;&lt; &quot;AsyncScrollingCoordinator::insertNode &quot; &lt;&lt; nodeType &lt;&lt; &quot; node &quot; &lt;&lt; newNodeID &lt;&lt; &quot; parent &quot; &lt;&lt; parentID &lt;&lt; &quot; index &quot; &lt;&lt; childIndex);
526     return m_scrollingStateTree-&gt;insertNode(nodeType, newNodeID, parentID, childIndex);
527 }
528 
529 void AsyncScrollingCoordinator::unparentNode(ScrollingNodeID nodeID)
530 {
531     m_scrollingStateTree-&gt;unparentNode(nodeID);
532 }
533 
534 void AsyncScrollingCoordinator::unparentChildrenAndDestroyNode(ScrollingNodeID nodeID)
</pre>
<hr />
<pre>
558 Vector&lt;ScrollingNodeID&gt; AsyncScrollingCoordinator::childrenOfNode(ScrollingNodeID nodeID) const
559 {
560     auto* scrollingNode = m_scrollingStateTree-&gt;stateNodeForID(nodeID);
561     if (!scrollingNode)
562         return { };
563 
564     auto* children = scrollingNode-&gt;children();
565     if (!children || children-&gt;isEmpty())
566         return { };
567 
568     Vector&lt;ScrollingNodeID&gt; childNodeIDs;
569     childNodeIDs.reserveInitialCapacity(children-&gt;size());
570     for (const auto&amp; childNode : *children)
571         childNodeIDs.uncheckedAppend(childNode-&gt;scrollingNodeID());
572 
573     return childNodeIDs;
574 }
575 
576 void AsyncScrollingCoordinator::reconcileViewportConstrainedLayerPositions(ScrollingNodeID scrollingNodeID, const LayoutRect&amp; viewportRect, ScrollingLayerPositionAction action)
577 {
<span class="line-removed">578     auto* scrollingNode = m_scrollingStateTree-&gt;stateNodeForID(scrollingNodeID);</span>
<span class="line-removed">579     if (!scrollingNode)</span>
<span class="line-removed">580         return;</span>
<span class="line-removed">581 </span>
582     LOG_WITH_STREAM(Scrolling, stream &lt;&lt; getCurrentProcessID() &lt;&lt; &quot; AsyncScrollingCoordinator::reconcileViewportConstrainedLayerPositions for viewport rect &quot; &lt;&lt; viewportRect &lt;&lt; &quot; and node &quot; &lt;&lt; scrollingNodeID);
583 
<span class="line-modified">584     scrollingNode-&gt;reconcileLayerPositionForViewportRect(viewportRect, action);</span>
585 }
586 
587 void AsyncScrollingCoordinator::ensureRootStateNodeForFrameView(FrameView&amp; frameView)
588 {
589     ASSERT(frameView.scrollingNodeID());
590     if (m_scrollingStateTree-&gt;stateNodeForID(frameView.scrollingNodeID()))
591         return;
592 
593     // For non-main frames, it is only possible to arrive in this function from
594     // RenderLayerCompositor::updateBacking where the node has already been created.
595     ASSERT(frameView.frame().isMainFrame());
596     insertNode(ScrollingNodeType::MainFrame, frameView.scrollingNodeID(), 0, 0);
597 }
598 
599 void AsyncScrollingCoordinator::setNodeLayers(ScrollingNodeID nodeID, const NodeLayers&amp; nodeLayers)
600 {
601     auto* node = m_scrollingStateTree-&gt;stateNodeForID(nodeID);
602     ASSERT(node);
603     if (!node)
604         return;
605 
606     node-&gt;setLayer(nodeLayers.layer);
607 
608     if (is&lt;ScrollingStateScrollingNode&gt;(node)) {
609         auto&amp; scrollingNode = downcast&lt;ScrollingStateScrollingNode&gt;(*node);
610         scrollingNode.setScrollContainerLayer(nodeLayers.scrollContainerLayer);
611         scrollingNode.setScrolledContentsLayer(nodeLayers.scrolledContentsLayer);


612 
613         if (is&lt;ScrollingStateFrameScrollingNode&gt;(node)) {
614             auto&amp; frameScrollingNode = downcast&lt;ScrollingStateFrameScrollingNode&gt;(*node);
615             frameScrollingNode.setInsetClipLayer(nodeLayers.insetClipLayer);
616             frameScrollingNode.setCounterScrollingLayer(nodeLayers.counterScrollingLayer);
617             frameScrollingNode.setRootContentsLayer(nodeLayers.rootContentsLayer);
618         }
619     }
620 }
621 
<span class="line-modified">622 void AsyncScrollingCoordinator::setScrollingNodeGeometry(ScrollingNodeID nodeID, const ScrollingGeometry&amp; scrollingGeometry)</span>
623 {
624     auto* stateNode = m_scrollingStateTree-&gt;stateNodeForID(nodeID);
625     ASSERT(stateNode);
626     if (!stateNode)
627         return;
628 
<span class="line-modified">629     if (stateNode-&gt;nodeType() == ScrollingNodeType::FrameHosting) {</span>
630         auto&amp; frameHostingStateNode = downcast&lt;ScrollingStateFrameHostingNode&gt;(*stateNode);
<span class="line-modified">631         frameHostingStateNode.setParentRelativeScrollableRect(scrollingGeometry.parentRelativeScrollableRect);</span>
632         return;
633     }
634 

















































635     auto&amp; scrollingNode = downcast&lt;ScrollingStateScrollingNode&gt;(*stateNode);
636 
<span class="line-modified">637     scrollingNode.setParentRelativeScrollableRect(scrollingGeometry.parentRelativeScrollableRect);</span>
<span class="line-modified">638     scrollingNode.setScrollOrigin(scrollingGeometry.scrollOrigin);</span>
<span class="line-modified">639     scrollingNode.setScrollPosition(scrollingGeometry.scrollPosition);</span>
<span class="line-modified">640     scrollingNode.setTotalContentsSize(scrollingGeometry.contentSize);</span>
<span class="line-modified">641     scrollingNode.setReachableContentsSize(scrollingGeometry.reachableContentSize);</span>
<span class="line-modified">642     scrollingNode.setScrollableAreaSize(scrollingGeometry.scrollableAreaSize);</span>
















643 
644 #if ENABLE(CSS_SCROLL_SNAP)
<span class="line-modified">645     // updateScrollSnapPropertiesWithFrameView() sets these for frame scrolling nodes. FIXME: Why the difference?</span>
<span class="line-modified">646     if (is&lt;ScrollingStateOverflowScrollingNode&gt;(scrollingNode)) {</span>
<span class="line-modified">647         setStateScrollingNodeSnapOffsetsAsFloat(scrollingNode, ScrollEventAxis::Horizontal, &amp;scrollingGeometry.horizontalSnapOffsets, &amp;scrollingGeometry.horizontalSnapOffsetRanges, m_page-&gt;deviceScaleFactor());</span>
<span class="line-modified">648         setStateScrollingNodeSnapOffsetsAsFloat(scrollingNode, ScrollEventAxis::Vertical, &amp;scrollingGeometry.verticalSnapOffsets, &amp;scrollingGeometry.verticalSnapOffsetRanges, m_page-&gt;deviceScaleFactor());</span>
<span class="line-modified">649         scrollingNode.setCurrentHorizontalSnapPointIndex(scrollingGeometry.currentHorizontalSnapPointIndex);</span>
<span class="line-removed">650         scrollingNode.setCurrentVerticalSnapPointIndex(scrollingGeometry.currentVerticalSnapPointIndex);</span>
<span class="line-removed">651     }</span>
652 #endif
653 }
654 
<span class="line-modified">655 void AsyncScrollingCoordinator::setViewportConstraintedNodeGeometry(ScrollingNodeID nodeID, const ViewportConstraints&amp; constraints)</span>
656 {
657     auto* node = m_scrollingStateTree-&gt;stateNodeForID(nodeID);
658     if (!node)
659         return;
660 
661     switch (constraints.constraintType()) {
662     case ViewportConstraints::FixedPositionConstraint: {
663         auto&amp; fixedNode = downcast&lt;ScrollingStateFixedNode&gt;(*node);
664         fixedNode.updateConstraints((const FixedPositionViewportConstraints&amp;)constraints);
665         break;
666     }
667     case ViewportConstraints::StickyPositionConstraint: {
668         auto&amp; stickyNode = downcast&lt;ScrollingStateStickyNode&gt;(*node);
669         stickyNode.updateConstraints((const StickyPositionViewportConstraints&amp;)constraints);
670         break;
671     }
672     }
673 }
674 





























675 void AsyncScrollingCoordinator::setSynchronousScrollingReasons(FrameView&amp; frameView, SynchronousScrollingReasons reasons)
676 {
677     auto* scrollingStateNode = static_cast&lt;ScrollingStateFrameScrollingNode*&gt;(m_scrollingStateTree-&gt;stateNodeForID(frameView.scrollingNodeID()));
678     if (!scrollingStateNode)
679         return;
680 
681     // The FrameView&#39;s GraphicsLayer is likely to be out-of-synch with the PlatformLayer
682     // at this point. So we&#39;ll update it before we switch back to main thread scrolling
683     // in order to avoid layer positioning bugs.
684     if (reasons)
685         reconcileScrollPosition(frameView, ScrollingLayerPositionAction::Set);
686     scrollingStateNode-&gt;setSynchronousScrollingReasons(reasons);
687 }
688 
689 bool AsyncScrollingCoordinator::isRubberBandInProgress() const
690 {
691     return scrollingTree()-&gt;isRubberBandInProgress();
692 }
693 
694 void AsyncScrollingCoordinator::setScrollPinningBehavior(ScrollPinningBehavior pinning)
695 {
696     scrollingTree()-&gt;setScrollPinningBehavior(pinning);
697 }
698 
<span class="line-removed">699 bool AsyncScrollingCoordinator::visualViewportEnabled() const</span>
<span class="line-removed">700 {</span>
<span class="line-removed">701     return m_page-&gt;mainFrame().settings().visualViewportEnabled();</span>
<span class="line-removed">702 }</span>
<span class="line-removed">703 </span>
704 bool AsyncScrollingCoordinator::asyncFrameOrOverflowScrollingEnabled() const
705 {
706     auto&amp; settings = m_page-&gt;mainFrame().settings();
707     return settings.asyncFrameScrollingEnabled() || settings.asyncOverflowScrollingEnabled();
708 }
709 






















710 String AsyncScrollingCoordinator::scrollingStateTreeAsText(ScrollingStateTreeAsTextBehavior behavior) const
711 {
712     if (m_scrollingStateTree-&gt;rootStateNode()) {
713         if (m_eventTrackingRegionsDirty)
714             m_scrollingStateTree-&gt;rootStateNode()-&gt;setEventTrackingRegions(absoluteEventTrackingRegions());
715         return m_scrollingStateTree-&gt;rootStateNode()-&gt;scrollingStateTreeAsText(behavior);
716     }
717 
718     return String();
719 }
720 
721 #if PLATFORM(COCOA)
722 void AsyncScrollingCoordinator::setActiveScrollSnapIndices(ScrollingNodeID scrollingNodeID, unsigned horizontalIndex, unsigned verticalIndex)
723 {
724     ASSERT(isMainThread());
725 
726     if (!m_page)
727         return;
728 
729     auto* frameView = frameViewForScrollingNode(scrollingNodeID);
</pre>
</td>
<td>
<hr />
<pre>
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 
 28 #if ENABLE(ASYNC_SCROLLING)
 29 #include &quot;AsyncScrollingCoordinator.h&quot;
 30 
 31 #include &quot;DebugPageOverlays.h&quot;
 32 #include &quot;Document.h&quot;
 33 #include &quot;EditorClient.h&quot;
 34 #include &quot;Frame.h&quot;
 35 #include &quot;FrameView.h&quot;
 36 #include &quot;GraphicsLayer.h&quot;
 37 #include &quot;Logging.h&quot;
 38 #include &quot;Page.h&quot;
 39 #include &quot;PerformanceLoggingClient.h&quot;
<span class="line-added"> 40 #include &quot;RenderLayerCompositor.h&quot;</span>
<span class="line-added"> 41 #include &quot;RenderView.h&quot;</span>
 42 #include &quot;ScrollAnimator.h&quot;
 43 #include &quot;ScrollingConstraints.h&quot;
 44 #include &quot;ScrollingStateFixedNode.h&quot;
 45 #include &quot;ScrollingStateFrameHostingNode.h&quot;
 46 #include &quot;ScrollingStateFrameScrollingNode.h&quot;
<span class="line-added"> 47 #include &quot;ScrollingStateOverflowScrollProxyNode.h&quot;</span>
 48 #include &quot;ScrollingStateOverflowScrollingNode.h&quot;
<span class="line-added"> 49 #include &quot;ScrollingStatePositionedNode.h&quot;</span>
 50 #include &quot;ScrollingStateStickyNode.h&quot;
 51 #include &quot;ScrollingStateTree.h&quot;
 52 #include &quot;Settings.h&quot;
 53 #include &quot;WheelEventTestTrigger.h&quot;
 54 #include &lt;wtf/ProcessID.h&gt;
 55 #include &lt;wtf/text/TextStream.h&gt;
 56 
 57 namespace WebCore {
 58 
 59 AsyncScrollingCoordinator::AsyncScrollingCoordinator(Page* page)
 60     : ScrollingCoordinator(page)
 61     , m_updateNodeScrollPositionTimer(*this, &amp;AsyncScrollingCoordinator::updateScrollPositionAfterAsyncScrollTimerFired)
<span class="line-modified"> 62     , m_scrollingStateTree(makeUnique&lt;ScrollingStateTree&gt;(this))</span>
 63 {
 64 }
 65 
 66 AsyncScrollingCoordinator::~AsyncScrollingCoordinator() = default;
 67 
 68 void AsyncScrollingCoordinator::scrollingStateTreePropertiesChanged()
 69 {
 70     scheduleTreeStateCommit();
 71 }
 72 
 73 #if ENABLE(CSS_SCROLL_SNAP)
 74 static inline void setStateScrollingNodeSnapOffsetsAsFloat(ScrollingStateScrollingNode&amp; node, ScrollEventAxis axis, const Vector&lt;LayoutUnit&gt;* snapOffsets, const Vector&lt;ScrollOffsetRange&lt;LayoutUnit&gt;&gt;* snapOffsetRanges, float deviceScaleFactor)
 75 {
 76     // FIXME: Incorporate current page scale factor in snapping to device pixel. Perhaps we should just convert to float here and let UI process do the pixel snapping?
 77     Vector&lt;float&gt; snapOffsetsAsFloat;
 78     if (snapOffsets) {
 79         snapOffsetsAsFloat.reserveInitialCapacity(snapOffsets-&gt;size());
 80         for (auto&amp; offset : *snapOffsets)
 81             snapOffsetsAsFloat.uncheckedAppend(roundToDevicePixel(offset, deviceScaleFactor, false));
 82     }
</pre>
<hr />
<pre>
114     if (!m_eventTrackingRegionsDirty)
115         return;
116 
117     if (!m_scrollingStateTree-&gt;rootStateNode())
118         return;
119 
120     m_scrollingStateTree-&gt;rootStateNode()-&gt;setEventTrackingRegions(absoluteEventTrackingRegions());
121     m_eventTrackingRegionsDirty = false;
122 }
123 
124 void AsyncScrollingCoordinator::frameViewLayoutUpdated(FrameView&amp; frameView)
125 {
126     ASSERT(isMainThread());
127     ASSERT(m_page);
128 
129     // If there isn&#39;t a root node yet, don&#39;t do anything. We&#39;ll be called again after creating one.
130     if (!m_scrollingStateTree-&gt;rootStateNode())
131         return;
132 
133     setEventTrackingRegionsDirty();


134 
<span class="line-modified">135 #if PLATFORM(COCOA)</span>
<span class="line-modified">136     if (!coordinatesScrollingForFrameView(frameView))</span>
137         return;
138 































139     auto* page = frameView.frame().page();
140     if (page &amp;&amp; page-&gt;expectsWheelEventTriggers()) {
141         LOG(WheelEventTestTriggers, &quot;    AsyncScrollingCoordinator::frameViewLayoutUpdated: Expects wheel event test trigger=%d&quot;, page-&gt;expectsWheelEventTriggers());
<span class="line-added">142 </span>
<span class="line-added">143         auto* node = m_scrollingStateTree-&gt;stateNodeForID(frameView.scrollingNodeID());</span>
<span class="line-added">144         if (!is&lt;ScrollingStateFrameScrollingNode&gt;(node))</span>
<span class="line-added">145             return;</span>
<span class="line-added">146 </span>
<span class="line-added">147         auto&amp; frameScrollingNode = downcast&lt;ScrollingStateFrameScrollingNode&gt;(*node);</span>
148         frameScrollingNode.setExpectsWheelEventTestTrigger(page-&gt;expectsWheelEventTriggers());
149     }
<span class="line-added">150 #else</span>
<span class="line-added">151     UNUSED_PARAM(frameView);</span>
152 #endif
<span class="line-added">153 }</span>
154 
<span class="line-modified">155 void AsyncScrollingCoordinator::frameViewVisualViewportChanged(FrameView&amp; frameView)</span>
<span class="line-modified">156 {</span>
<span class="line-modified">157     ASSERT(isMainThread());</span>
<span class="line-modified">158     ASSERT(m_page);</span>
<span class="line-modified">159 </span>
<span class="line-modified">160     if (!coordinatesScrollingForFrameView(frameView))</span>
<span class="line-modified">161         return;</span>

162 
<span class="line-modified">163     // If the root layer does not have a ScrollingStateNode, then we should create one.</span>
<span class="line-added">164     auto* node = m_scrollingStateTree-&gt;stateNodeForID(frameView.scrollingNodeID());</span>
<span class="line-added">165     if (!node)</span>
<span class="line-added">166         return;</span>
<span class="line-added">167 </span>
<span class="line-added">168     auto&amp; frameScrollingNode = downcast&lt;ScrollingStateFrameScrollingNode&gt;(*node);</span>
<span class="line-added">169 </span>
<span class="line-added">170     auto visualViewportIsSmallerThanLayoutViewport = [](const FrameView&amp; frameView) {</span>
<span class="line-added">171         auto layoutViewport = frameView.layoutViewportRect();</span>
<span class="line-added">172         auto visualViewport = frameView.visualViewportRect();</span>
<span class="line-added">173         return visualViewport.width() &lt; layoutViewport.width() || visualViewport.height() &lt; layoutViewport.height();</span>
<span class="line-added">174     };</span>
<span class="line-added">175     frameScrollingNode.setVisualViewportIsSmallerThanLayoutViewport(visualViewportIsSmallerThanLayoutViewport(frameView));</span>
176 }
177 
178 void AsyncScrollingCoordinator::updateExpectsWheelEventTestTriggerWithFrameView(const FrameView&amp; frameView)
179 {
180     auto* page = frameView.frame().page();
181     if (!page)
182         return;
183 
184     auto* node = downcast&lt;ScrollingStateFrameScrollingNode&gt;(m_scrollingStateTree-&gt;stateNodeForID(frameView.scrollingNodeID()));
185     if (!node)
186         return;
187 
188     node-&gt;setExpectsWheelEventTestTrigger(page-&gt;expectsWheelEventTriggers());
189 }
190 
191 void AsyncScrollingCoordinator::frameViewEventTrackingRegionsChanged(FrameView&amp; frameView)
192 {
193     if (!m_scrollingStateTree-&gt;rootStateNode())
194         return;
195 
</pre>
<hr />
<pre>
213     // If the root layer does not have a ScrollingStateNode, then we should create one.
214     ensureRootStateNodeForFrameView(frameView);
215     ASSERT(m_scrollingStateTree-&gt;stateNodeForID(frameView.scrollingNodeID()));
216 
217     ScrollingCoordinator::frameViewRootLayerDidChange(frameView);
218 
219     auto* node = downcast&lt;ScrollingStateFrameScrollingNode&gt;(m_scrollingStateTree-&gt;stateNodeForID(frameView.scrollingNodeID()));
220     node-&gt;setScrollContainerLayer(scrollContainerLayerForFrameView(frameView));
221     node-&gt;setScrolledContentsLayer(scrolledContentsLayerForFrameView(frameView));
222     node-&gt;setRootContentsLayer(rootContentsLayerForFrameView(frameView));
223     node-&gt;setCounterScrollingLayer(counterScrollingLayerForFrameView(frameView));
224     node-&gt;setInsetClipLayer(insetClipLayerForFrameView(frameView));
225     node-&gt;setContentShadowLayer(contentShadowLayerForFrameView(frameView));
226     node-&gt;setHeaderLayer(headerLayerForFrameView(frameView));
227     node-&gt;setFooterLayer(footerLayerForFrameView(frameView));
228     node-&gt;setScrollBehaviorForFixedElements(frameView.scrollBehaviorForFixedElements());
229     node-&gt;setVerticalScrollbarLayer(frameView.layerForVerticalScrollbar());
230     node-&gt;setHorizontalScrollbarLayer(frameView.layerForHorizontalScrollbar());
231 }
232 
<span class="line-modified">233 bool AsyncScrollingCoordinator::requestScrollPositionUpdate(ScrollableArea&amp; scrollableArea, const IntPoint&amp; scrollPosition)</span>
234 {
235     ASSERT(isMainThread());
236     ASSERT(m_page);
237 
<span class="line-modified">238     auto scrollingNodeID = scrollableArea.scrollingNodeID();</span>
<span class="line-added">239     if (!scrollingNodeID)</span>
<span class="line-added">240         return false;</span>
<span class="line-added">241 </span>
<span class="line-added">242     auto* frameView = frameViewForScrollingNode(scrollingNodeID);</span>
<span class="line-added">243     if (!frameView)</span>
244         return false;
245 
<span class="line-modified">246     if (!coordinatesScrollingForFrameView(*frameView))</span>
<span class="line-modified">247         return false;</span>
<span class="line-modified">248 </span>
<span class="line-added">249     bool inPageCache = frameView-&gt;frame().document()-&gt;pageCacheState() != Document::NotInPageCache;</span>
<span class="line-added">250     bool inProgrammaticScroll = scrollableArea.currentScrollType() == ScrollType::Programmatic;</span>
<span class="line-added">251     if (inProgrammaticScroll || inPageCache)</span>
<span class="line-added">252         updateScrollPositionAfterAsyncScroll(scrollingNodeID, scrollPosition, { }, ScrollType::Programmatic, ScrollingLayerPositionAction::Set);</span>
253 
254     // If this frame view&#39;s document is being put into the page cache, we don&#39;t want to update our
255     // main frame scroll position. Just let the FrameView think that we did.
<span class="line-modified">256     if (inPageCache)</span>
257         return true;
258 
<span class="line-modified">259     auto* stateNode = downcast&lt;ScrollingStateScrollingNode&gt;(m_scrollingStateTree-&gt;stateNodeForID(scrollingNodeID));</span>
260     if (!stateNode)
261         return false;
262 
<span class="line-modified">263     stateNode-&gt;setRequestedScrollPosition(scrollPosition, inProgrammaticScroll);</span>
264     return true;
265 }
266 
<span class="line-modified">267 void AsyncScrollingCoordinator::applyScrollingTreeLayerPositions()</span>
268 {
<span class="line-modified">269     m_scrollingTree-&gt;applyLayerPositions();</span>
<span class="line-added">270 }</span>
271 
<span class="line-modified">272 void AsyncScrollingCoordinator::scheduleUpdateScrollPositionAfterAsyncScroll(ScrollingNodeID nodeID, const FloatPoint&amp; scrollPosition, const Optional&lt;FloatPoint&gt;&amp; layoutViewportOrigin, ScrollingLayerPositionAction scrollingLayerPositionAction)</span>
<span class="line-modified">273 {</span>
<span class="line-modified">274     ScheduledScrollUpdate scrollUpdate(nodeID, scrollPosition, layoutViewportOrigin, scrollingLayerPositionAction);</span>
275 
276     if (m_updateNodeScrollPositionTimer.isActive()) {
277         if (m_scheduledScrollUpdate.matchesUpdateType(scrollUpdate)) {
278             m_scheduledScrollUpdate.scrollPosition = scrollPosition;
279             m_scheduledScrollUpdate.layoutViewportOrigin = layoutViewportOrigin;
280             return;
281         }
282 
283         // If the parameters don&#39;t match what was previously scheduled, dispatch immediately.
284         m_updateNodeScrollPositionTimer.stop();
<span class="line-modified">285         updateScrollPositionAfterAsyncScroll(m_scheduledScrollUpdate.nodeID, m_scheduledScrollUpdate.scrollPosition, m_scheduledScrollUpdate.layoutViewportOrigin, ScrollType::User, m_scheduledScrollUpdate.updateLayerPositionAction);</span>
<span class="line-modified">286         updateScrollPositionAfterAsyncScroll(nodeID, scrollPosition, layoutViewportOrigin, ScrollType::User, scrollingLayerPositionAction);</span>
287         return;
288     }
289 
290     m_scheduledScrollUpdate = scrollUpdate;
291     m_updateNodeScrollPositionTimer.startOneShot(0_s);
292 }
293 
294 void AsyncScrollingCoordinator::updateScrollPositionAfterAsyncScrollTimerFired()
295 {
<span class="line-modified">296     updateScrollPositionAfterAsyncScroll(m_scheduledScrollUpdate.nodeID, m_scheduledScrollUpdate.scrollPosition, m_scheduledScrollUpdate.layoutViewportOrigin, ScrollType::User, m_scheduledScrollUpdate.updateLayerPositionAction);</span>
297 }
298 
299 FrameView* AsyncScrollingCoordinator::frameViewForScrollingNode(ScrollingNodeID scrollingNodeID) const
300 {
301     if (!m_scrollingStateTree-&gt;rootStateNode())
302         return nullptr;
303 
304     if (scrollingNodeID == m_scrollingStateTree-&gt;rootStateNode()-&gt;scrollingNodeID())
305         return m_page-&gt;mainFrame().view();
306 
307     auto* stateNode = m_scrollingStateTree-&gt;stateNodeForID(scrollingNodeID);
308     if (!stateNode)
309         return nullptr;
310 
311     // Find the enclosing frame scrolling node.
312     auto* parentNode = stateNode;
313     while (parentNode &amp;&amp; !parentNode-&gt;isFrameScrollingNode())
314         parentNode = parentNode-&gt;parent();
315 
316     if (!parentNode)
317         return nullptr;
318 
319     // Walk the frame tree to find the matching FrameView. This is not ideal, but avoids back pointers to FrameViews
320     // from ScrollingTreeStateNodes.
321     for (Frame* frame = &amp;m_page-&gt;mainFrame(); frame; frame = frame-&gt;tree().traverseNext()) {
322         if (auto* view = frame-&gt;view()) {
323             if (view-&gt;scrollingNodeID() == parentNode-&gt;scrollingNodeID())
324                 return view;
325         }
326     }
327 
328     return nullptr;
329 }
330 
<span class="line-modified">331 void AsyncScrollingCoordinator::updateScrollPositionAfterAsyncScroll(ScrollingNodeID scrollingNodeID, const FloatPoint&amp; scrollPosition, Optional&lt;FloatPoint&gt; layoutViewportOrigin, ScrollType scrollType, ScrollingLayerPositionAction scrollingLayerPositionAction)</span>
332 {
333     ASSERT(isMainThread());
334 
335     if (!m_page)
336         return;
337 
338     auto* frameViewPtr = frameViewForScrollingNode(scrollingNodeID);
339     if (!frameViewPtr)
340         return;
341 
342     LOG_WITH_STREAM(Scrolling, stream &lt;&lt; &quot;AsyncScrollingCoordinator::updateScrollPositionAfterAsyncScroll node &quot; &lt;&lt; scrollingNodeID &lt;&lt; &quot; scrollPosition &quot; &lt;&lt; scrollPosition &lt;&lt; &quot; action &quot; &lt;&lt; scrollingLayerPositionAction);
343 
344     auto&amp; frameView = *frameViewPtr;
345 
346     if (scrollingNodeID == frameView.scrollingNodeID()) {
<span class="line-modified">347         reconcileScrollingState(frameView, scrollPosition, layoutViewportOrigin, scrollType, ViewportRectStability::Stable, scrollingLayerPositionAction);</span>
348 
349 #if PLATFORM(COCOA)
350         if (m_page-&gt;expectsWheelEventTriggers()) {
351             frameView.scrollAnimator().setWheelEventTestTrigger(m_page-&gt;testTrigger());
352             if (const auto&amp; trigger = m_page-&gt;testTrigger())
353                 trigger-&gt;removeTestDeferralForReason(reinterpret_cast&lt;WheelEventTestTrigger::ScrollableAreaIdentifier&gt;(scrollingNodeID), WheelEventTestTrigger::ScrollingThreadSyncNeeded);
354         }
355 #endif
356 
357         return;
358     }
359 
360     // Overflow-scroll area.
361     if (auto* scrollableArea = frameView.scrollableAreaForScrollLayerID(scrollingNodeID)) {
<span class="line-modified">362         auto previousScrollType = scrollableArea-&gt;currentScrollType();</span>
<span class="line-modified">363         scrollableArea-&gt;setCurrentScrollType(scrollType);</span>
<span class="line-modified">364         scrollableArea-&gt;scrollToOffsetWithoutAnimation(ScrollableArea::scrollOffsetFromPosition(scrollPosition, toFloatSize(scrollableArea-&gt;scrollOrigin())));</span>
<span class="line-added">365         scrollableArea-&gt;setCurrentScrollType(previousScrollType);</span>
<span class="line-added">366 </span>
367         if (scrollingLayerPositionAction == ScrollingLayerPositionAction::Set)
368             m_page-&gt;editorClient().overflowScrollPositionChanged();
369 
370 #if PLATFORM(COCOA)
371         if (m_page-&gt;expectsWheelEventTriggers()) {
372             frameView.scrollAnimator().setWheelEventTestTrigger(m_page-&gt;testTrigger());
373             if (const auto&amp; trigger = m_page-&gt;testTrigger())
374                 trigger-&gt;removeTestDeferralForReason(reinterpret_cast&lt;WheelEventTestTrigger::ScrollableAreaIdentifier&gt;(scrollingNodeID), WheelEventTestTrigger::ScrollingThreadSyncNeeded);
375         }
376 #endif
377     }
378 }
379 
<span class="line-modified">380 void AsyncScrollingCoordinator::reconcileScrollingState(FrameView&amp; frameView, const FloatPoint&amp; scrollPosition, const LayoutViewportOriginOrOverrideRect&amp; layoutViewportOriginOrOverrideRect, ScrollType scrollType, ViewportRectStability viewportRectStability, ScrollingLayerPositionAction scrollingLayerPositionAction)</span>
381 {
<span class="line-modified">382     auto previousScrollType = frameView.currentScrollType();</span>
<span class="line-modified">383     frameView.setCurrentScrollType(scrollType);</span>
384 
<span class="line-modified">385     LOG_WITH_STREAM(Scrolling, stream &lt;&lt; getCurrentProcessID() &lt;&lt; &quot; AsyncScrollingCoordinator &quot; &lt;&lt; this &lt;&lt; &quot; reconcileScrollingState scrollPosition &quot; &lt;&lt; scrollPosition &lt;&lt; &quot; type &quot; &lt;&lt; scrollType &lt;&lt; &quot; stability &quot; &lt;&lt; viewportRectStability &lt;&lt; &quot; &quot; &lt;&lt; scrollingLayerPositionAction);</span>
386 
387     Optional&lt;FloatRect&gt; layoutViewportRect;
388 
389     WTF::switchOn(layoutViewportOriginOrOverrideRect,
390         [&amp;frameView](Optional&lt;FloatPoint&gt; origin) {
391             if (origin)
392                 frameView.setBaseLayoutViewportOrigin(LayoutPoint(origin.value()), FrameView::TriggerLayoutOrNot::No);
<span class="line-modified">393         }, [&amp;frameView, &amp;layoutViewportRect, viewportRectStability](Optional&lt;FloatRect&gt; overrideRect) {</span>
394             if (!overrideRect)
395                 return;
396 
397             layoutViewportRect = overrideRect;
<span class="line-modified">398             if (viewportRectStability != ViewportRectStability::ChangingObscuredInsetsInteractively)</span>
399                 frameView.setLayoutViewportOverrideRect(LayoutRect(overrideRect.value()), viewportRectStability == ViewportRectStability::Stable ? FrameView::TriggerLayoutOrNot::Yes : FrameView::TriggerLayoutOrNot::No);




400         }
401     );
402 
403     frameView.setConstrainsScrollingToContentEdge(false);
404     frameView.notifyScrollPositionChanged(roundedIntPoint(scrollPosition));
405     frameView.setConstrainsScrollingToContentEdge(true);

406 
<span class="line-modified">407     frameView.setCurrentScrollType(previousScrollType);</span>
<span class="line-added">408 </span>
<span class="line-added">409     if (scrollType == ScrollType::User &amp;&amp; scrollingLayerPositionAction != ScrollingLayerPositionAction::Set) {</span>
410         auto scrollingNodeID = frameView.scrollingNodeID();
411         if (viewportRectStability == ViewportRectStability::Stable)
412             reconcileViewportConstrainedLayerPositions(scrollingNodeID, frameView.rectForFixedPositionLayout(), scrollingLayerPositionAction);
413         else if (layoutViewportRect)
414             reconcileViewportConstrainedLayerPositions(scrollingNodeID, LayoutRect(layoutViewportRect.value()), scrollingLayerPositionAction);
415     }
416 
417     if (!scrolledContentsLayerForFrameView(frameView))
418         return;
419 
420     auto* counterScrollingLayer = counterScrollingLayerForFrameView(frameView);
421     auto* insetClipLayer = insetClipLayerForFrameView(frameView);
422     auto* contentShadowLayer = contentShadowLayerForFrameView(frameView);
423     auto* rootContentsLayer = rootContentsLayerForFrameView(frameView);
424     auto* headerLayer = headerLayerForFrameView(frameView);
425     auto* footerLayer = footerLayerForFrameView(frameView);
426 
427     ASSERT(frameView.scrollPosition() == roundedIntPoint(scrollPosition));
428     LayoutPoint scrollPositionForFixed = frameView.scrollPositionForFixedPosition();
429     float topContentInset = frameView.topContentInset();
430 
431     FloatPoint positionForInsetClipLayer;
432     if (insetClipLayer)
433         positionForInsetClipLayer = FloatPoint(insetClipLayer-&gt;position().x(), FrameView::yPositionForInsetClipLayer(scrollPosition, topContentInset));
434     FloatPoint positionForContentsLayer = frameView.positionForRootContentLayer();
435 
436     FloatPoint positionForHeaderLayer = FloatPoint(scrollPositionForFixed.x(), FrameView::yPositionForHeaderLayer(scrollPosition, topContentInset));
437     FloatPoint positionForFooterLayer = FloatPoint(scrollPositionForFixed.x(),
438         FrameView::yPositionForFooterLayer(scrollPosition, topContentInset, frameView.totalContentsSize().height(), frameView.footerHeight()));
439 
<span class="line-modified">440     if (scrollType == ScrollType::Programmatic || scrollingLayerPositionAction == ScrollingLayerPositionAction::Set) {</span>
441         reconcileScrollPosition(frameView, ScrollingLayerPositionAction::Set);
442 
443         if (counterScrollingLayer)
444             counterScrollingLayer-&gt;setPosition(scrollPositionForFixed);
445         if (insetClipLayer)
446             insetClipLayer-&gt;setPosition(positionForInsetClipLayer);
447         if (contentShadowLayer)
448             contentShadowLayer-&gt;setPosition(positionForContentsLayer);
449         if (rootContentsLayer)
450             rootContentsLayer-&gt;setPosition(positionForContentsLayer);
451         if (headerLayer)
452             headerLayer-&gt;setPosition(positionForHeaderLayer);
453         if (footerLayer)
454             footerLayer-&gt;setPosition(positionForFooterLayer);
455     } else {
456         reconcileScrollPosition(frameView, ScrollingLayerPositionAction::Sync);
457 
458         if (counterScrollingLayer)
459             counterScrollingLayer-&gt;syncPosition(scrollPositionForFixed);
460         if (insetClipLayer)
</pre>
<hr />
<pre>
465             rootContentsLayer-&gt;syncPosition(positionForContentsLayer);
466         if (headerLayer)
467             headerLayer-&gt;syncPosition(positionForHeaderLayer);
468         if (footerLayer)
469             footerLayer-&gt;syncPosition(positionForFooterLayer);
470     }
471 }
472 
473 void AsyncScrollingCoordinator::reconcileScrollPosition(FrameView&amp; frameView, ScrollingLayerPositionAction scrollingLayerPositionAction)
474 {
475 #if PLATFORM(IOS_FAMILY)
476     // Doing all scrolling like this (UIScrollView style) would simplify code.
477     auto* scrollContainerLayer = scrollContainerLayerForFrameView(frameView);
478     if (!scrollContainerLayer)
479         return;
480     if (scrollingLayerPositionAction == ScrollingLayerPositionAction::Set)
481         scrollContainerLayer-&gt;setBoundsOrigin(frameView.scrollPosition());
482     else
483         scrollContainerLayer-&gt;syncBoundsOrigin(frameView.scrollPosition());
484 #else
<span class="line-added">485     // This uses scrollPosition because the root content layer accounts for scrollOrigin (see FrameView::positionForRootContentLayer()).</span>
486     auto* scrolledContentsLayer = scrolledContentsLayerForFrameView(frameView);
487     if (!scrolledContentsLayer)
488         return;
489     if (scrollingLayerPositionAction == ScrollingLayerPositionAction::Set)
490         scrolledContentsLayer-&gt;setPosition(-frameView.scrollPosition());
491     else
492         scrolledContentsLayer-&gt;syncPosition(-frameView.scrollPosition());
493 #endif
494 }
495 
496 void AsyncScrollingCoordinator::scrollableAreaScrollbarLayerDidChange(ScrollableArea&amp; scrollableArea, ScrollbarOrientation orientation)
497 {
498     ASSERT(isMainThread());
499     ASSERT(m_page);
500 
501     auto* node = m_scrollingStateTree-&gt;stateNodeForID(scrollableArea.scrollingNodeID());
<span class="line-modified">502     if (is&lt;ScrollingStateScrollingNode&gt;(node)) {</span>
<span class="line-modified">503         auto&amp; scrollingNode = downcast&lt;ScrollingStateScrollingNode&gt;(*node);</span>
504         if (orientation == VerticalScrollbar)
505             scrollingNode.setVerticalScrollbarLayer(scrollableArea.layerForVerticalScrollbar());
506         else
507             scrollingNode.setHorizontalScrollbarLayer(scrollableArea.layerForHorizontalScrollbar());
508     }
509 
<span class="line-modified">510     if (orientation == VerticalScrollbar)</span>
<span class="line-modified">511         scrollableArea.verticalScrollbarLayerDidChange();</span>
<span class="line-modified">512     else</span>
<span class="line-modified">513         scrollableArea.horizontalScrollbarLayerDidChange();</span>


514 }
515 
516 ScrollingNodeID AsyncScrollingCoordinator::createNode(ScrollingNodeType nodeType, ScrollingNodeID newNodeID)
517 {
518     LOG_WITH_STREAM(Scrolling, stream &lt;&lt; &quot;AsyncScrollingCoordinator::createNode &quot; &lt;&lt; nodeType &lt;&lt; &quot; node &quot; &lt;&lt; newNodeID);
519     return m_scrollingStateTree-&gt;createUnparentedNode(nodeType, newNodeID);
520 }
521 
522 ScrollingNodeID AsyncScrollingCoordinator::insertNode(ScrollingNodeType nodeType, ScrollingNodeID newNodeID, ScrollingNodeID parentID, size_t childIndex)
523 {
524     LOG_WITH_STREAM(Scrolling, stream &lt;&lt; &quot;AsyncScrollingCoordinator::insertNode &quot; &lt;&lt; nodeType &lt;&lt; &quot; node &quot; &lt;&lt; newNodeID &lt;&lt; &quot; parent &quot; &lt;&lt; parentID &lt;&lt; &quot; index &quot; &lt;&lt; childIndex);
525     return m_scrollingStateTree-&gt;insertNode(nodeType, newNodeID, parentID, childIndex);
526 }
527 
528 void AsyncScrollingCoordinator::unparentNode(ScrollingNodeID nodeID)
529 {
530     m_scrollingStateTree-&gt;unparentNode(nodeID);
531 }
532 
533 void AsyncScrollingCoordinator::unparentChildrenAndDestroyNode(ScrollingNodeID nodeID)
</pre>
<hr />
<pre>
557 Vector&lt;ScrollingNodeID&gt; AsyncScrollingCoordinator::childrenOfNode(ScrollingNodeID nodeID) const
558 {
559     auto* scrollingNode = m_scrollingStateTree-&gt;stateNodeForID(nodeID);
560     if (!scrollingNode)
561         return { };
562 
563     auto* children = scrollingNode-&gt;children();
564     if (!children || children-&gt;isEmpty())
565         return { };
566 
567     Vector&lt;ScrollingNodeID&gt; childNodeIDs;
568     childNodeIDs.reserveInitialCapacity(children-&gt;size());
569     for (const auto&amp; childNode : *children)
570         childNodeIDs.uncheckedAppend(childNode-&gt;scrollingNodeID());
571 
572     return childNodeIDs;
573 }
574 
575 void AsyncScrollingCoordinator::reconcileViewportConstrainedLayerPositions(ScrollingNodeID scrollingNodeID, const LayoutRect&amp; viewportRect, ScrollingLayerPositionAction action)
576 {




577     LOG_WITH_STREAM(Scrolling, stream &lt;&lt; getCurrentProcessID() &lt;&lt; &quot; AsyncScrollingCoordinator::reconcileViewportConstrainedLayerPositions for viewport rect &quot; &lt;&lt; viewportRect &lt;&lt; &quot; and node &quot; &lt;&lt; scrollingNodeID);
578 
<span class="line-modified">579     m_scrollingStateTree-&gt;reconcileViewportConstrainedLayerPositions(scrollingNodeID, viewportRect, action);</span>
580 }
581 
582 void AsyncScrollingCoordinator::ensureRootStateNodeForFrameView(FrameView&amp; frameView)
583 {
584     ASSERT(frameView.scrollingNodeID());
585     if (m_scrollingStateTree-&gt;stateNodeForID(frameView.scrollingNodeID()))
586         return;
587 
588     // For non-main frames, it is only possible to arrive in this function from
589     // RenderLayerCompositor::updateBacking where the node has already been created.
590     ASSERT(frameView.frame().isMainFrame());
591     insertNode(ScrollingNodeType::MainFrame, frameView.scrollingNodeID(), 0, 0);
592 }
593 
594 void AsyncScrollingCoordinator::setNodeLayers(ScrollingNodeID nodeID, const NodeLayers&amp; nodeLayers)
595 {
596     auto* node = m_scrollingStateTree-&gt;stateNodeForID(nodeID);
597     ASSERT(node);
598     if (!node)
599         return;
600 
601     node-&gt;setLayer(nodeLayers.layer);
602 
603     if (is&lt;ScrollingStateScrollingNode&gt;(node)) {
604         auto&amp; scrollingNode = downcast&lt;ScrollingStateScrollingNode&gt;(*node);
605         scrollingNode.setScrollContainerLayer(nodeLayers.scrollContainerLayer);
606         scrollingNode.setScrolledContentsLayer(nodeLayers.scrolledContentsLayer);
<span class="line-added">607         scrollingNode.setHorizontalScrollbarLayer(nodeLayers.horizontalScrollbarLayer);</span>
<span class="line-added">608         scrollingNode.setVerticalScrollbarLayer(nodeLayers.verticalScrollbarLayer);</span>
609 
610         if (is&lt;ScrollingStateFrameScrollingNode&gt;(node)) {
611             auto&amp; frameScrollingNode = downcast&lt;ScrollingStateFrameScrollingNode&gt;(*node);
612             frameScrollingNode.setInsetClipLayer(nodeLayers.insetClipLayer);
613             frameScrollingNode.setCounterScrollingLayer(nodeLayers.counterScrollingLayer);
614             frameScrollingNode.setRootContentsLayer(nodeLayers.rootContentsLayer);
615         }
616     }
617 }
618 
<span class="line-modified">619 void AsyncScrollingCoordinator::setRectRelativeToParentNode(ScrollingNodeID nodeID, const LayoutRect&amp; parentRelativeScrollableRect)</span>
620 {
621     auto* stateNode = m_scrollingStateTree-&gt;stateNodeForID(nodeID);
622     ASSERT(stateNode);
623     if (!stateNode)
624         return;
625 
<span class="line-modified">626     if (is&lt;ScrollingStateFrameHostingNode&gt;(*stateNode)) {</span>
627         auto&amp; frameHostingStateNode = downcast&lt;ScrollingStateFrameHostingNode&gt;(*stateNode);
<span class="line-modified">628         frameHostingStateNode.setParentRelativeScrollableRect(parentRelativeScrollableRect);</span>
629         return;
630     }
631 
<span class="line-added">632     if (is&lt;ScrollingStateScrollingNode&gt;(stateNode)) {</span>
<span class="line-added">633         auto&amp; scrollingStateNode = downcast&lt;ScrollingStateScrollingNode&gt;(*stateNode);</span>
<span class="line-added">634         scrollingStateNode.setParentRelativeScrollableRect(parentRelativeScrollableRect);</span>
<span class="line-added">635     }</span>
<span class="line-added">636 }</span>
<span class="line-added">637 </span>
<span class="line-added">638 void AsyncScrollingCoordinator::setFrameScrollingNodeState(ScrollingNodeID nodeID, const FrameView&amp; frameView)</span>
<span class="line-added">639 {</span>
<span class="line-added">640     auto* stateNode = m_scrollingStateTree-&gt;stateNodeForID(nodeID);</span>
<span class="line-added">641     ASSERT(stateNode);</span>
<span class="line-added">642     if (!is&lt;ScrollingStateFrameScrollingNode&gt;(stateNode))</span>
<span class="line-added">643         return;</span>
<span class="line-added">644 </span>
<span class="line-added">645     auto&amp; frameScrollingNode = downcast&lt;ScrollingStateFrameScrollingNode&gt;(*stateNode);</span>
<span class="line-added">646 </span>
<span class="line-added">647     frameScrollingNode.setFrameScaleFactor(frameView.frame().frameScaleFactor());</span>
<span class="line-added">648     frameScrollingNode.setHeaderHeight(frameView.headerHeight());</span>
<span class="line-added">649     frameScrollingNode.setFooterHeight(frameView.footerHeight());</span>
<span class="line-added">650     frameScrollingNode.setTopContentInset(frameView.topContentInset());</span>
<span class="line-added">651     frameScrollingNode.setLayoutViewport(frameView.layoutViewportRect());</span>
<span class="line-added">652     frameScrollingNode.setAsyncFrameOrOverflowScrollingEnabled(asyncFrameOrOverflowScrollingEnabled());</span>
<span class="line-added">653 </span>
<span class="line-added">654     frameScrollingNode.setMinLayoutViewportOrigin(frameView.minStableLayoutViewportOrigin());</span>
<span class="line-added">655     frameScrollingNode.setMaxLayoutViewportOrigin(frameView.maxStableLayoutViewportOrigin());</span>
<span class="line-added">656 </span>
<span class="line-added">657     if (auto visualOverrideRect = frameView.visualViewportOverrideRect())</span>
<span class="line-added">658         frameScrollingNode.setOverrideVisualViewportSize(FloatSize(visualOverrideRect.value().size()));</span>
<span class="line-added">659     else</span>
<span class="line-added">660         frameScrollingNode.setOverrideVisualViewportSize(WTF::nullopt);</span>
<span class="line-added">661 </span>
<span class="line-added">662     frameScrollingNode.setFixedElementsLayoutRelativeToFrame(frameView.fixedElementsLayoutRelativeToFrame());</span>
<span class="line-added">663 </span>
<span class="line-added">664     auto visualViewportIsSmallerThanLayoutViewport = [](const FrameView&amp; frameView) {</span>
<span class="line-added">665         auto layoutViewport = frameView.layoutViewportRect();</span>
<span class="line-added">666         auto visualViewport = frameView.visualViewportRect();</span>
<span class="line-added">667         return visualViewport.width() &lt; layoutViewport.width() || visualViewport.height() &lt; layoutViewport.height();</span>
<span class="line-added">668     };</span>
<span class="line-added">669     frameScrollingNode.setVisualViewportIsSmallerThanLayoutViewport(visualViewportIsSmallerThanLayoutViewport(frameView));</span>
<span class="line-added">670 </span>
<span class="line-added">671     frameScrollingNode.setScrollBehaviorForFixedElements(frameView.scrollBehaviorForFixedElements());</span>
<span class="line-added">672 }</span>
<span class="line-added">673 </span>
<span class="line-added">674 void AsyncScrollingCoordinator::setScrollingNodeScrollableAreaGeometry(ScrollingNodeID nodeID, ScrollableArea&amp; scrollableArea)</span>
<span class="line-added">675 {</span>
<span class="line-added">676     auto* stateNode = m_scrollingStateTree-&gt;stateNodeForID(nodeID);</span>
<span class="line-added">677     ASSERT(stateNode);</span>
<span class="line-added">678     if (!stateNode)</span>
<span class="line-added">679         return;</span>
<span class="line-added">680 </span>
681     auto&amp; scrollingNode = downcast&lt;ScrollingStateScrollingNode&gt;(*stateNode);
682 
<span class="line-modified">683     auto* verticalScrollbar = scrollableArea.verticalScrollbar();</span>
<span class="line-modified">684     auto* horizontalScrollbar = scrollableArea.horizontalScrollbar();</span>
<span class="line-modified">685     scrollingNode.setScrollerImpsFromScrollbars(verticalScrollbar, horizontalScrollbar);</span>
<span class="line-modified">686 </span>
<span class="line-modified">687     scrollingNode.setScrollOrigin(scrollableArea.scrollOrigin());</span>
<span class="line-modified">688     scrollingNode.setScrollPosition(scrollableArea.scrollPosition());</span>
<span class="line-added">689     scrollingNode.setTotalContentsSize(scrollableArea.totalContentsSize());</span>
<span class="line-added">690     scrollingNode.setReachableContentsSize(scrollableArea.reachableTotalContentsSize());</span>
<span class="line-added">691     scrollingNode.setScrollableAreaSize(scrollableArea.visibleSize());</span>
<span class="line-added">692 </span>
<span class="line-added">693     ScrollableAreaParameters scrollParameters;</span>
<span class="line-added">694     scrollParameters.horizontalScrollElasticity = scrollableArea.horizontalScrollElasticity();</span>
<span class="line-added">695     scrollParameters.verticalScrollElasticity = scrollableArea.verticalScrollElasticity();</span>
<span class="line-added">696     scrollParameters.hasEnabledHorizontalScrollbar = horizontalScrollbar &amp;&amp; horizontalScrollbar-&gt;enabled();</span>
<span class="line-added">697     scrollParameters.hasEnabledVerticalScrollbar = verticalScrollbar &amp;&amp; verticalScrollbar-&gt;enabled();</span>
<span class="line-added">698     scrollParameters.horizontalScrollbarMode = scrollableArea.horizontalScrollbarMode();</span>
<span class="line-added">699     scrollParameters.verticalScrollbarMode = scrollableArea.verticalScrollbarMode();</span>
<span class="line-added">700     scrollParameters.horizontalScrollbarHiddenByStyle = scrollableArea.horizontalScrollbarHiddenByStyle();</span>
<span class="line-added">701     scrollParameters.verticalScrollbarHiddenByStyle = scrollableArea.verticalScrollbarHiddenByStyle();</span>
<span class="line-added">702     scrollParameters.useDarkAppearanceForScrollbars = scrollableArea.useDarkAppearanceForScrollbars();</span>
<span class="line-added">703 </span>
<span class="line-added">704     scrollingNode.setScrollableAreaParameters(scrollParameters);</span>
705 
706 #if ENABLE(CSS_SCROLL_SNAP)
<span class="line-modified">707     scrollableArea.updateSnapOffsets();</span>
<span class="line-modified">708     setStateScrollingNodeSnapOffsetsAsFloat(scrollingNode, ScrollEventAxis::Horizontal, scrollableArea.horizontalSnapOffsets(), scrollableArea.horizontalSnapOffsetRanges(), m_page-&gt;deviceScaleFactor());</span>
<span class="line-modified">709     setStateScrollingNodeSnapOffsetsAsFloat(scrollingNode, ScrollEventAxis::Vertical, scrollableArea.verticalSnapOffsets(), scrollableArea.verticalSnapOffsetRanges(), m_page-&gt;deviceScaleFactor());</span>
<span class="line-modified">710     scrollingNode.setCurrentHorizontalSnapPointIndex(scrollableArea.currentHorizontalSnapPointIndex());</span>
<span class="line-modified">711     scrollingNode.setCurrentVerticalSnapPointIndex(scrollableArea.currentVerticalSnapPointIndex());</span>


712 #endif
713 }
714 
<span class="line-modified">715 void AsyncScrollingCoordinator::setViewportConstraintedNodeConstraints(ScrollingNodeID nodeID, const ViewportConstraints&amp; constraints)</span>
716 {
717     auto* node = m_scrollingStateTree-&gt;stateNodeForID(nodeID);
718     if (!node)
719         return;
720 
721     switch (constraints.constraintType()) {
722     case ViewportConstraints::FixedPositionConstraint: {
723         auto&amp; fixedNode = downcast&lt;ScrollingStateFixedNode&gt;(*node);
724         fixedNode.updateConstraints((const FixedPositionViewportConstraints&amp;)constraints);
725         break;
726     }
727     case ViewportConstraints::StickyPositionConstraint: {
728         auto&amp; stickyNode = downcast&lt;ScrollingStateStickyNode&gt;(*node);
729         stickyNode.updateConstraints((const StickyPositionViewportConstraints&amp;)constraints);
730         break;
731     }
732     }
733 }
734 
<span class="line-added">735 void AsyncScrollingCoordinator::setPositionedNodeConstraints(ScrollingNodeID nodeID, const AbsolutePositionConstraints&amp; constraints)</span>
<span class="line-added">736 {</span>
<span class="line-added">737     auto* node = m_scrollingStateTree-&gt;stateNodeForID(nodeID);</span>
<span class="line-added">738     if (!node)</span>
<span class="line-added">739         return;</span>
<span class="line-added">740 </span>
<span class="line-added">741     ASSERT(is&lt;ScrollingStatePositionedNode&gt;(*node));</span>
<span class="line-added">742     if (auto* positionedNode = downcast&lt;ScrollingStatePositionedNode&gt;(node))</span>
<span class="line-added">743         positionedNode-&gt;updateConstraints(constraints);</span>
<span class="line-added">744 }</span>
<span class="line-added">745 </span>
<span class="line-added">746 void AsyncScrollingCoordinator::setRelatedOverflowScrollingNodes(ScrollingNodeID nodeID, Vector&lt;ScrollingNodeID&gt;&amp;&amp; relatedNodes)</span>
<span class="line-added">747 {</span>
<span class="line-added">748     auto* node = m_scrollingStateTree-&gt;stateNodeForID(nodeID);</span>
<span class="line-added">749     if (!node)</span>
<span class="line-added">750         return;</span>
<span class="line-added">751 </span>
<span class="line-added">752     if (is&lt;ScrollingStatePositionedNode&gt;(node))</span>
<span class="line-added">753         downcast&lt;ScrollingStatePositionedNode&gt;(node)-&gt;setRelatedOverflowScrollingNodes(WTFMove(relatedNodes));</span>
<span class="line-added">754     else if (is&lt;ScrollingStateOverflowScrollProxyNode&gt;(node)) {</span>
<span class="line-added">755         auto* overflowScrollProxyNode = downcast&lt;ScrollingStateOverflowScrollProxyNode&gt;(node);</span>
<span class="line-added">756         if (!relatedNodes.isEmpty())</span>
<span class="line-added">757             overflowScrollProxyNode-&gt;setOverflowScrollingNode(relatedNodes[0]);</span>
<span class="line-added">758         else</span>
<span class="line-added">759             overflowScrollProxyNode-&gt;setOverflowScrollingNode(0);</span>
<span class="line-added">760     } else</span>
<span class="line-added">761         ASSERT_NOT_REACHED();</span>
<span class="line-added">762 }</span>
<span class="line-added">763 </span>
764 void AsyncScrollingCoordinator::setSynchronousScrollingReasons(FrameView&amp; frameView, SynchronousScrollingReasons reasons)
765 {
766     auto* scrollingStateNode = static_cast&lt;ScrollingStateFrameScrollingNode*&gt;(m_scrollingStateTree-&gt;stateNodeForID(frameView.scrollingNodeID()));
767     if (!scrollingStateNode)
768         return;
769 
770     // The FrameView&#39;s GraphicsLayer is likely to be out-of-synch with the PlatformLayer
771     // at this point. So we&#39;ll update it before we switch back to main thread scrolling
772     // in order to avoid layer positioning bugs.
773     if (reasons)
774         reconcileScrollPosition(frameView, ScrollingLayerPositionAction::Set);
775     scrollingStateNode-&gt;setSynchronousScrollingReasons(reasons);
776 }
777 
778 bool AsyncScrollingCoordinator::isRubberBandInProgress() const
779 {
780     return scrollingTree()-&gt;isRubberBandInProgress();
781 }
782 
783 void AsyncScrollingCoordinator::setScrollPinningBehavior(ScrollPinningBehavior pinning)
784 {
785     scrollingTree()-&gt;setScrollPinningBehavior(pinning);
786 }
787 





788 bool AsyncScrollingCoordinator::asyncFrameOrOverflowScrollingEnabled() const
789 {
790     auto&amp; settings = m_page-&gt;mainFrame().settings();
791     return settings.asyncFrameScrollingEnabled() || settings.asyncOverflowScrollingEnabled();
792 }
793 
<span class="line-added">794 ScrollingNodeID AsyncScrollingCoordinator::scrollableContainerNodeID(const RenderObject&amp; renderer) const</span>
<span class="line-added">795 {</span>
<span class="line-added">796     if (auto overflowScrollingNodeID = renderer.view().compositor().asyncScrollableContainerNodeID(renderer))</span>
<span class="line-added">797         return overflowScrollingNodeID;</span>
<span class="line-added">798 </span>
<span class="line-added">799     // If we&#39;re in a scrollable frame, return that.</span>
<span class="line-added">800     auto* frameView = renderer.frame().view();</span>
<span class="line-added">801     if (!frameView)</span>
<span class="line-added">802         return 0;</span>
<span class="line-added">803 </span>
<span class="line-added">804     if (auto scrollingNodeID = frameView-&gt;scrollingNodeID())</span>
<span class="line-added">805         return scrollingNodeID;</span>
<span class="line-added">806 </span>
<span class="line-added">807     // Otherwise, look for a scrollable element in the containing frame.</span>
<span class="line-added">808     if (auto* ownerElement = renderer.document().ownerElement()) {</span>
<span class="line-added">809         if (auto* frameRenderer = ownerElement-&gt;renderer())</span>
<span class="line-added">810             return scrollableContainerNodeID(*frameRenderer);</span>
<span class="line-added">811     }</span>
<span class="line-added">812 </span>
<span class="line-added">813     return 0;</span>
<span class="line-added">814 }</span>
<span class="line-added">815 </span>
816 String AsyncScrollingCoordinator::scrollingStateTreeAsText(ScrollingStateTreeAsTextBehavior behavior) const
817 {
818     if (m_scrollingStateTree-&gt;rootStateNode()) {
819         if (m_eventTrackingRegionsDirty)
820             m_scrollingStateTree-&gt;rootStateNode()-&gt;setEventTrackingRegions(absoluteEventTrackingRegions());
821         return m_scrollingStateTree-&gt;rootStateNode()-&gt;scrollingStateTreeAsText(behavior);
822     }
823 
824     return String();
825 }
826 
827 #if PLATFORM(COCOA)
828 void AsyncScrollingCoordinator::setActiveScrollSnapIndices(ScrollingNodeID scrollingNodeID, unsigned horizontalIndex, unsigned verticalIndex)
829 {
830     ASSERT(isMainThread());
831 
832     if (!m_page)
833         return;
834 
835     auto* frameView = frameViewForScrollingNode(scrollingNodeID);
</pre>
</td>
</tr>
</table>
<center><a href="../linux/ResourceUsageThreadLinux.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="AsyncScrollingCoordinator.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>