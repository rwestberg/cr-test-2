<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.web/src/main/native/Source/WebCore/platform/ScrollView.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (C) 2006-2017 Apple Inc. All rights reserved.
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  * 1. Redistributions of source code must retain the above copyright
   8  *    notice, this list of conditions and the following disclaimer.
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #include &quot;config.h&quot;
  27 #include &quot;ScrollView.h&quot;
  28 
  29 #include &quot;GraphicsContext.h&quot;
  30 #include &quot;GraphicsLayer.h&quot;
  31 #include &quot;HostWindow.h&quot;
  32 #include &quot;Logging.h&quot;
  33 #include &quot;PlatformMouseEvent.h&quot;
  34 #include &quot;PlatformWheelEvent.h&quot;
  35 #include &quot;ScrollAnimator.h&quot;
  36 #include &quot;Scrollbar.h&quot;
  37 #include &quot;ScrollbarTheme.h&quot;
  38 #include &lt;wtf/StdLibExtras.h&gt;
  39 #include &lt;wtf/text/TextStream.h&gt;
  40 
  41 namespace WebCore {
  42 
  43 ScrollView::ScrollView() = default;
  44 
  45 ScrollView::~ScrollView() = default;
  46 
  47 void ScrollView::addChild(Widget&amp; child)
  48 {
  49     ASSERT(&amp;child != this);
  50     ASSERT(!child.parent());
  51     child.setParent(this);
  52     m_children.add(child);
  53     if (child.platformWidget())
  54         platformAddChild(&amp;child);
  55 }
  56 
  57 void ScrollView::removeChild(Widget&amp; child)
  58 {
  59     ASSERT(child.parent() == this);
  60     child.setParent(nullptr);
  61     m_children.remove(&amp;child);
  62     if (child.platformWidget())
  63         platformRemoveChild(&amp;child);
  64 }
  65 
  66 bool ScrollView::setHasHorizontalScrollbar(bool hasBar, bool* contentSizeAffected)
  67 {
  68     return setHasScrollbarInternal(m_horizontalScrollbar, HorizontalScrollbar, hasBar, contentSizeAffected);
  69 }
  70 
  71 bool ScrollView::setHasVerticalScrollbar(bool hasBar, bool* contentSizeAffected)
  72 {
  73     return setHasScrollbarInternal(m_verticalScrollbar, VerticalScrollbar, hasBar, contentSizeAffected);
  74 }
  75 
  76 bool ScrollView::setHasScrollbarInternal(RefPtr&lt;Scrollbar&gt;&amp; scrollbar, ScrollbarOrientation orientation, bool hasBar, bool* contentSizeAffected)
  77 {
  78     ASSERT(!hasBar || !avoidScrollbarCreation());
  79 
  80     if (hasBar &amp;&amp; !scrollbar) {
  81         scrollbar = createScrollbar(orientation);
  82         addChild(*scrollbar);
  83         didAddScrollbar(scrollbar.get(), orientation);
  84         scrollbar-&gt;styleChanged();
  85         if (contentSizeAffected)
  86             *contentSizeAffected = !scrollbar-&gt;isOverlayScrollbar();
  87         return true;
  88     }
  89 
  90     if (!hasBar &amp;&amp; scrollbar) {
  91         bool wasOverlayScrollbar = scrollbar-&gt;isOverlayScrollbar();
  92         willRemoveScrollbar(scrollbar.get(), orientation);
  93         removeChild(*scrollbar);
  94         scrollbar = nullptr;
  95         if (contentSizeAffected)
  96             *contentSizeAffected = !wasOverlayScrollbar;
  97         return true;
  98     }
  99 
 100     return false;
 101 }
 102 
 103 Ref&lt;Scrollbar&gt; ScrollView::createScrollbar(ScrollbarOrientation orientation)
 104 {
 105     return Scrollbar::createNativeScrollbar(*this, orientation, RegularScrollbar);
 106 }
 107 
 108 void ScrollView::setScrollbarModes(ScrollbarMode horizontalMode, ScrollbarMode verticalMode,
 109                                    bool horizontalLock, bool verticalLock)
 110 {
 111     bool needsUpdate = false;
 112 
 113     if (horizontalMode != horizontalScrollbarMode() &amp;&amp; !m_horizontalScrollbarLock) {
 114         m_horizontalScrollbarMode = horizontalMode;
 115         needsUpdate = true;
 116     }
 117 
 118     if (verticalMode != verticalScrollbarMode() &amp;&amp; !m_verticalScrollbarLock) {
 119         m_verticalScrollbarMode = verticalMode;
 120         needsUpdate = true;
 121     }
 122 
 123     if (horizontalLock)
 124         setHorizontalScrollbarLock();
 125 
 126     if (verticalLock)
 127         setVerticalScrollbarLock();
 128 
 129     if (!needsUpdate)
 130         return;
 131 
 132     if (platformWidget())
 133         platformSetScrollbarModes();
 134     else
 135         updateScrollbars(scrollPosition());
 136 }
 137 
 138 void ScrollView::scrollbarModes(ScrollbarMode&amp; horizontalMode, ScrollbarMode&amp; verticalMode) const
 139 {
 140     if (platformWidget()) {
 141         platformScrollbarModes(horizontalMode, verticalMode);
 142         return;
 143     }
 144     horizontalMode = m_horizontalScrollbarMode;
 145     verticalMode = m_verticalScrollbarMode;
 146 }
 147 
 148 void ScrollView::setCanHaveScrollbars(bool canScroll)
 149 {
 150     ScrollbarMode newHorizontalMode;
 151     ScrollbarMode newVerticalMode;
 152 
 153     scrollbarModes(newHorizontalMode, newVerticalMode);
 154 
 155     if (canScroll &amp;&amp; newVerticalMode == ScrollbarAlwaysOff)
 156         newVerticalMode = ScrollbarAuto;
 157     else if (!canScroll)
 158         newVerticalMode = ScrollbarAlwaysOff;
 159 
 160     if (canScroll &amp;&amp; newHorizontalMode == ScrollbarAlwaysOff)
 161         newHorizontalMode = ScrollbarAuto;
 162     else if (!canScroll)
 163         newHorizontalMode = ScrollbarAlwaysOff;
 164 
 165     setScrollbarModes(newHorizontalMode, newVerticalMode);
 166 }
 167 
 168 void ScrollView::setCanBlitOnScroll(bool b)
 169 {
 170     if (platformWidget()) {
 171         platformSetCanBlitOnScroll(b);
 172         return;
 173     }
 174 
 175     m_canBlitOnScroll = b;
 176 }
 177 
 178 bool ScrollView::canBlitOnScroll() const
 179 {
 180     if (platformWidget())
 181         return platformCanBlitOnScroll();
 182 
 183     return m_canBlitOnScroll;
 184 }
 185 
 186 void ScrollView::setPaintsEntireContents(bool paintsEntireContents)
 187 {
 188     m_paintsEntireContents = paintsEntireContents;
 189 }
 190 
 191 void ScrollView::setDelegatesScrolling(bool delegatesScrolling)
 192 {
 193     if (m_delegatesScrolling == delegatesScrolling)
 194         return;
 195 
 196     m_delegatesScrolling = delegatesScrolling;
 197     delegatesScrollingDidChange();
 198 }
 199 
 200 IntPoint ScrollView::contentsScrollPosition() const
 201 {
 202 #if PLATFORM(IOS_FAMILY)
 203     if (platformWidget())
 204         return actualScrollPosition();
 205 #endif
 206     return scrollPosition();
 207 }
 208 
 209 void ScrollView::setContentsScrollPosition(const IntPoint&amp; position)
 210 {
 211 #if PLATFORM(IOS_FAMILY)
 212     if (platformWidget())
 213         setActualScrollPosition(position);
 214 #endif
 215     setScrollPosition(position);
 216 }
 217 
 218 #if !PLATFORM(IOS_FAMILY)
 219 IntRect ScrollView::unobscuredContentRect(VisibleContentRectIncludesScrollbars scrollbarInclusion) const
 220 {
 221     return unobscuredContentRectInternal(scrollbarInclusion);
 222 }
 223 #endif
 224 
 225 IntRect ScrollView::unobscuredContentRectInternal(VisibleContentRectIncludesScrollbars scrollbarInclusion) const
 226 {
 227     FloatSize visibleContentSize = sizeForUnobscuredContent(scrollbarInclusion);
 228     visibleContentSize.scale(1 / visibleContentScaleFactor());
 229     return IntRect(m_scrollPosition, expandedIntSize(visibleContentSize));
 230 }
 231 
 232 IntSize ScrollView::sizeForVisibleContent(VisibleContentRectIncludesScrollbars scrollbarInclusion) const
 233 {
 234     if (platformWidget())
 235         return platformVisibleContentSizeIncludingObscuredArea(scrollbarInclusion == IncludeScrollbars);
 236 
 237 #if USE(COORDINATED_GRAPHICS)
 238     if (m_useFixedLayout &amp;&amp; !m_fixedVisibleContentRect.isEmpty())
 239         return m_fixedVisibleContentRect.size();
 240 #endif
 241 
 242     IntSize scrollbarSpace;
 243     if (scrollbarInclusion == ExcludeScrollbars)
 244         scrollbarSpace = scrollbarIntrusion();
 245 
 246     return IntSize(width() - scrollbarSpace.width(), height() - scrollbarSpace.height()).expandedTo(IntSize());
 247 }
 248 
 249 IntSize ScrollView::sizeForUnobscuredContent(VisibleContentRectIncludesScrollbars scrollbarInclusion) const
 250 {
 251     if (platformWidget())
 252         return platformVisibleContentSize(scrollbarInclusion == IncludeScrollbars);
 253 
 254     IntSize visibleContentSize = sizeForVisibleContent(scrollbarInclusion);
 255 
 256 #if USE(COORDINATED_GRAPHICS)
 257     if (m_useFixedLayout &amp;&amp; !m_fixedVisibleContentRect.isEmpty())
 258         return visibleContentSize;
 259 #endif
 260 
 261     visibleContentSize.setHeight(visibleContentSize.height() - topContentInset());
 262     return visibleContentSize;
 263 }
 264 
 265 IntRect ScrollView::visibleContentRectInternal(VisibleContentRectIncludesScrollbars scrollbarInclusion, VisibleContentRectBehavior visibleContentRectBehavior) const
 266 {
 267 #if PLATFORM(IOS_FAMILY)
 268     if (visibleContentRectBehavior == LegacyIOSDocumentViewRect) {
 269         if (platformWidget())
 270             return platformVisibleContentRect(scrollbarInclusion == IncludeScrollbars);
 271     }
 272 
 273     if (platformWidget())
 274         return unobscuredContentRect(scrollbarInclusion);
 275 #else
 276     UNUSED_PARAM(visibleContentRectBehavior);
 277 #endif
 278 
 279     if (platformWidget())
 280         return platformVisibleContentRect(scrollbarInclusion == IncludeScrollbars);
 281 
 282 #if USE(COORDINATED_GRAPHICS)
 283     if (m_useFixedLayout &amp;&amp; !m_fixedVisibleContentRect.isEmpty())
 284         return m_fixedVisibleContentRect;
 285 #endif
 286 
 287     return unobscuredContentRect(scrollbarInclusion);
 288 }
 289 
 290 IntSize ScrollView::layoutSize() const
 291 {
 292     return m_fixedLayoutSize.isEmpty() || !m_useFixedLayout ? sizeForUnobscuredContent() : m_fixedLayoutSize;
 293 }
 294 
 295 IntSize ScrollView::fixedLayoutSize() const
 296 {
 297     return m_fixedLayoutSize;
 298 }
 299 
 300 void ScrollView::setFixedLayoutSize(const IntSize&amp; newSize)
 301 {
 302     if (fixedLayoutSize() == newSize)
 303         return;
 304 
 305     LOG_WITH_STREAM(Layout, stream &lt;&lt; &quot;ScrollView &quot; &lt;&lt; this &lt;&lt; &quot; setFixedLayoutSize &quot; &lt;&lt; newSize);
 306     m_fixedLayoutSize = newSize;
 307     if (m_useFixedLayout)
 308         availableContentSizeChanged(AvailableSizeChangeReason::AreaSizeChanged);
 309 }
 310 
 311 bool ScrollView::useFixedLayout() const
 312 {
 313     return m_useFixedLayout;
 314 }
 315 
 316 void ScrollView::setUseFixedLayout(bool enable)
 317 {
 318     if (useFixedLayout() == enable)
 319         return;
 320     m_useFixedLayout = enable;
 321     if (!m_fixedLayoutSize.isEmpty())
 322         availableContentSizeChanged(AvailableSizeChangeReason::AreaSizeChanged);
 323 }
 324 
 325 void ScrollView::availableContentSizeChanged(AvailableSizeChangeReason reason)
 326 {
 327     ScrollableArea::availableContentSizeChanged(reason);
 328 
 329     if (platformWidget())
 330         return;
 331 
 332     if (reason != AvailableSizeChangeReason::ScrollbarsChanged)
 333         updateScrollbars(scrollPosition());
 334 }
 335 
 336 IntSize ScrollView::contentsSize() const
 337 {
 338     return m_contentsSize;
 339 }
 340 
 341 void ScrollView::setContentsSize(const IntSize&amp; newSize)
 342 {
 343     if (contentsSize() == newSize)
 344         return;
 345     m_contentsSize = newSize;
 346     if (platformWidget())
 347         platformSetContentsSize();
 348     else
 349         updateScrollbars(scrollPosition());
 350     updateOverhangAreas();
 351 }
 352 
 353 ScrollPosition ScrollView::maximumScrollPosition() const
 354 {
 355     ScrollPosition maximumPosition = ScrollableArea::maximumScrollPosition();
 356     // FIXME: can this be moved into the base class?
 357     maximumPosition.clampNegativeToZero();
 358     return maximumPosition;
 359 }
 360 
 361 ScrollPosition ScrollView::adjustScrollPositionWithinRange(const ScrollPosition&amp; scrollPoint) const
 362 {
 363     if (!constrainsScrollingToContentEdge() || m_allowsUnclampedScrollPosition)
 364         return scrollPoint;
 365 
 366     return scrollPoint.constrainedBetween(minimumScrollPosition(), maximumScrollPosition());
 367 }
 368 
 369 ScrollPosition ScrollView::documentScrollPositionRelativeToViewOrigin() const
 370 {
 371     return scrollPosition() - IntSize(
 372         shouldPlaceBlockDirectionScrollbarOnLeft() &amp;&amp; m_verticalScrollbar ? m_verticalScrollbar-&gt;occupiedWidth() : 0,
 373         headerHeight() + topContentInset(TopContentInsetType::WebCoreOrPlatformContentInset));
 374 }
 375 
 376 ScrollPosition ScrollView::documentScrollPositionRelativeToScrollableAreaOrigin() const
 377 {
 378     return scrollPosition() - IntSize(0, headerHeight());
 379 }
 380 
 381 int ScrollView::scrollSize(ScrollbarOrientation orientation) const
 382 {
 383     // If no scrollbars are present, it does not indicate content is not be scrollable.
 384     if (!m_horizontalScrollbar &amp;&amp; !m_verticalScrollbar &amp;&amp; !prohibitsScrolling()) {
 385         IntSize scrollSize = m_contentsSize - visibleContentRect(LegacyIOSDocumentVisibleRect).size();
 386         scrollSize.clampNegativeToZero();
 387         return orientation == HorizontalScrollbar ? scrollSize.width() : scrollSize.height();
 388     }
 389 
 390     Scrollbar* scrollbar = ((orientation == HorizontalScrollbar) ? m_horizontalScrollbar : m_verticalScrollbar).get();
 391     return scrollbar ? (scrollbar-&gt;totalSize() - scrollbar-&gt;visibleSize()) : 0;
 392 }
 393 
 394 void ScrollView::notifyPageThatContentAreaWillPaint() const
 395 {
 396 }
 397 
 398 void ScrollView::setScrollOffset(const ScrollOffset&amp; offset)
 399 {
 400     LOG_WITH_STREAM(Scrolling, stream &lt;&lt; &quot;\nScrollView::setScrollOffset &quot; &lt;&lt; offset &lt;&lt; &quot; constrains &quot; &lt;&lt; constrainsScrollingToContentEdge());
 401 
 402     IntPoint constrainedOffset = offset;
 403     if (constrainsScrollingToContentEdge())
 404         constrainedOffset = constrainedOffset.constrainedBetween(IntPoint(), maximumScrollOffset());
 405 
 406     scrollTo(scrollPositionFromOffset(constrainedOffset));
 407 }
 408 
 409 void ScrollView::scrollOffsetChangedViaPlatformWidget(const ScrollOffset&amp; oldOffset, const ScrollOffset&amp; newOffset)
 410 {
 411     // We should not attempt to actually modify (paint) platform widgets if the layout phase
 412     // is not complete. Instead, defer the scroll event until the layout finishes.
 413     if (shouldDeferScrollUpdateAfterContentSizeChange()) {
 414         // We only care about the most recent scroll position change request
 415         m_deferredScrollOffsets = std::make_pair(oldOffset, newOffset);
 416         return;
 417     }
 418 
 419     scrollOffsetChangedViaPlatformWidgetImpl(oldOffset, newOffset);
 420 }
 421 
 422 void ScrollView::handleDeferredScrollUpdateAfterContentSizeChange()
 423 {
 424     ASSERT(!shouldDeferScrollUpdateAfterContentSizeChange());
 425 
 426     if (!m_deferredScrollDelta &amp;&amp; !m_deferredScrollOffsets)
 427         return;
 428 
 429     ASSERT(static_cast&lt;bool&gt;(m_deferredScrollDelta) != static_cast&lt;bool&gt;(m_deferredScrollOffsets));
 430 
 431     if (m_deferredScrollDelta)
 432         completeUpdatesAfterScrollTo(m_deferredScrollDelta.value());
 433     else if (m_deferredScrollOffsets)
 434         scrollOffsetChangedViaPlatformWidgetImpl(m_deferredScrollOffsets.value().first, m_deferredScrollOffsets.value().second);
 435 
 436     m_deferredScrollDelta = WTF::nullopt;
 437     m_deferredScrollOffsets = WTF::nullopt;
 438 }
 439 
 440 void ScrollView::scrollTo(const ScrollPosition&amp; newPosition)
 441 {
 442     LOG_WITH_STREAM(Scrolling, stream &lt;&lt; &quot;ScrollView::scrollTo &quot; &lt;&lt; newPosition &lt;&lt; &quot; min: &quot; &lt;&lt; minimumScrollPosition() &lt;&lt; &quot; max: &quot; &lt;&lt; maximumScrollPosition());
 443 
 444     IntSize scrollDelta = newPosition - m_scrollPosition;
 445     if (scrollDelta.isZero())
 446         return;
 447 
 448     m_scrollPosition = newPosition;
 449 
 450     if (scrollbarsSuppressed())
 451         return;
 452 
 453 #if USE(COORDINATED_GRAPHICS)
 454     if (delegatesScrolling()) {
 455         requestScrollPositionUpdate(newPosition);
 456         return;
 457     }
 458 #endif
 459     // We should not attempt to actually modify layer contents if the layout phase
 460     // is not complete. Instead, defer the scroll event until the layout finishes.
 461     if (shouldDeferScrollUpdateAfterContentSizeChange()) {
 462         ASSERT(!m_deferredScrollDelta);
 463         m_deferredScrollDelta = scrollDelta;
 464         return;
 465     }
 466 
 467     completeUpdatesAfterScrollTo(scrollDelta);
 468 }
 469 
 470 void ScrollView::completeUpdatesAfterScrollTo(const IntSize&amp; scrollDelta)
 471 {
 472     updateLayerPositionsAfterScrolling();
 473     scrollContents(scrollDelta);
 474     updateCompositingLayersAfterScrolling();
 475 }
 476 
 477 int ScrollView::scrollOffset(ScrollbarOrientation orientation) const
 478 {
 479     ScrollOffset offset = scrollOffsetFromPosition(scrollPosition());
 480 
 481     if (orientation == HorizontalScrollbar)
 482         return offset.x();
 483 
 484     if (orientation == VerticalScrollbar)
 485         return offset.y();
 486 
 487     return 0;
 488 }
 489 
 490 void ScrollView::setScrollPosition(const ScrollPosition&amp; scrollPosition)
 491 {
 492     LOG_WITH_STREAM(Scrolling, stream &lt;&lt; &quot;ScrollView::setScrollPosition &quot; &lt;&lt; scrollPosition);
 493 
 494     if (prohibitsScrolling())
 495         return;
 496 
 497     if (platformWidget()) {
 498         platformSetScrollPosition(scrollPosition);
 499         return;
 500     }
 501 
 502     ScrollPosition newScrollPosition = !delegatesScrolling() ? adjustScrollPositionWithinRange(scrollPosition) : scrollPosition;
 503 
 504     if ((!delegatesScrolling() || !inProgrammaticScroll()) &amp;&amp; newScrollPosition == this-&gt;scrollPosition())
 505         return;
 506 
 507     if (requestScrollPositionUpdate(newScrollPosition))
 508         return;
 509 
 510     updateScrollbars(newScrollPosition);
 511 }
 512 
 513 bool ScrollView::scroll(ScrollDirection direction, ScrollGranularity granularity)
 514 {
 515     if (platformWidget())
 516         return platformScroll(direction, granularity);
 517 
 518     return ScrollableArea::scroll(direction, granularity);
 519 }
 520 
 521 bool ScrollView::logicalScroll(ScrollLogicalDirection direction, ScrollGranularity granularity)
 522 {
 523     return scroll(logicalToPhysical(direction, isVerticalDocument(), isFlippedDocument()), granularity);
 524 }
 525 
 526 IntSize ScrollView::overhangAmount() const
 527 {
 528     IntSize stretch;
 529 
 530     // FIXME: use maximumScrollOffset()
 531     ScrollOffset scrollOffset = scrollOffsetFromPosition(scrollPosition());
 532     if (scrollOffset.y() &lt; 0)
 533         stretch.setHeight(scrollOffset.y());
 534     else if (totalContentsSize().height() &amp;&amp; scrollOffset.y() &gt; totalContentsSize().height() - visibleHeight())
 535         stretch.setHeight(scrollOffset.y() - (totalContentsSize().height() - visibleHeight()));
 536 
 537     if (scrollOffset.x() &lt; 0)
 538         stretch.setWidth(scrollOffset.x());
 539     else if (contentsWidth() &amp;&amp; scrollOffset.x() &gt; contentsWidth() - visibleWidth())
 540         stretch.setWidth(scrollOffset.x() - (contentsWidth() - visibleWidth()));
 541 
 542     return stretch;
 543 }
 544 
 545 bool ScrollView::managesScrollbars() const
 546 {
 547 #if PLATFORM(IOS_FAMILY)
 548     return false;
 549 #else
 550     if (platformWidget())
 551         return false;
 552     if (delegatesScrolling())
 553         return false;
 554     return true;
 555 #endif
 556 }
 557 
 558 void ScrollView::updateScrollbars(const ScrollPosition&amp; desiredPosition)
 559 {
 560     LOG_WITH_STREAM(Scrolling, stream &lt;&lt; &quot;ScrollView::updateScrollbars &quot; &lt;&lt; desiredPosition);
 561 
 562     if (m_inUpdateScrollbars || prohibitsScrolling() || platformWidget())
 563         return;
 564 
 565     if (!managesScrollbars()) {
 566         if (scrollOriginChanged()) {
 567             ScrollableArea::scrollToOffsetWithoutAnimation(scrollOffsetFromPosition(desiredPosition));
 568             resetScrollOriginChanged();
 569         }
 570         return;
 571     }
 572 
 573     bool hasOverlayScrollbars = (!m_horizontalScrollbar || m_horizontalScrollbar-&gt;isOverlayScrollbar()) &amp;&amp; (!m_verticalScrollbar || m_verticalScrollbar-&gt;isOverlayScrollbar());
 574 
 575     // If we came in here with the view already needing a layout then do that first.
 576     // (This will be the common case, e.g., when the page changes due to window resizing for example).
 577     // This layout will not re-enter updateScrollbars and does not count towards our max layout pass total.
 578     if (!m_scrollbarsSuppressed &amp;&amp; !hasOverlayScrollbars) {
 579         m_inUpdateScrollbars = true;
 580         updateContentsSize();
 581         m_inUpdateScrollbars = false;
 582     }
 583 
 584     IntRect oldScrollCornerRect = scrollCornerRect();
 585 
 586     bool hasHorizontalScrollbar = m_horizontalScrollbar;
 587     bool hasVerticalScrollbar = m_verticalScrollbar;
 588 
 589     bool newHasHorizontalScrollbar = hasHorizontalScrollbar;
 590     bool newHasVerticalScrollbar = hasVerticalScrollbar;
 591 
 592     ScrollbarMode hScroll = m_horizontalScrollbarMode;
 593     ScrollbarMode vScroll = m_verticalScrollbarMode;
 594 
 595     if (hScroll != ScrollbarAuto)
 596         newHasHorizontalScrollbar = (hScroll == ScrollbarAlwaysOn);
 597     if (vScroll != ScrollbarAuto)
 598         newHasVerticalScrollbar = (vScroll == ScrollbarAlwaysOn);
 599 
 600     bool scrollbarAddedOrRemoved = false;
 601 
 602     if (m_scrollbarsSuppressed || (hScroll != ScrollbarAuto &amp;&amp; vScroll != ScrollbarAuto)) {
 603         if (hasHorizontalScrollbar != newHasHorizontalScrollbar &amp;&amp; (hasHorizontalScrollbar || !avoidScrollbarCreation())) {
 604             if (setHasHorizontalScrollbar(newHasHorizontalScrollbar))
 605                 scrollbarAddedOrRemoved = true;
 606         }
 607 
 608         if (hasVerticalScrollbar != newHasVerticalScrollbar &amp;&amp; (hasVerticalScrollbar || !avoidScrollbarCreation())) {
 609             if (setHasVerticalScrollbar(newHasVerticalScrollbar))
 610                 scrollbarAddedOrRemoved = true;
 611         }
 612     } else {
 613         bool sendContentResizedNotification = false;
 614 
 615         IntSize docSize = totalContentsSize();
 616         IntSize fullVisibleSize = unobscuredContentRectIncludingScrollbars().size();
 617 
 618         if (hScroll == ScrollbarAuto)
 619             newHasHorizontalScrollbar = docSize.width() &gt; visibleWidth();
 620         if (vScroll == ScrollbarAuto)
 621             newHasVerticalScrollbar = docSize.height() &gt; visibleHeight();
 622 
 623         bool needAnotherPass = false;
 624         if (!hasOverlayScrollbars) {
 625             // If we ever turn one scrollbar off, do not turn the other one on. Never ever
 626             // try to both gain/lose a scrollbar in the same pass.
 627             if (!m_updateScrollbarsPass &amp;&amp; docSize.width() &lt;= fullVisibleSize.width() &amp;&amp; docSize.height() &lt;= fullVisibleSize.height()) {
 628                 if (hScroll == ScrollbarAuto)
 629                     newHasHorizontalScrollbar = false;
 630                 if (vScroll == ScrollbarAuto)
 631                     newHasVerticalScrollbar = false;
 632             }
 633             if (!newHasHorizontalScrollbar &amp;&amp; hasHorizontalScrollbar &amp;&amp; vScroll != ScrollbarAlwaysOn &amp;&amp; !hasVerticalScrollbar) {
 634                 newHasVerticalScrollbar = false;
 635                 needAnotherPass = true;
 636             }
 637             if (!newHasVerticalScrollbar &amp;&amp; hasVerticalScrollbar &amp;&amp; hScroll != ScrollbarAlwaysOn &amp;&amp; !hasHorizontalScrollbar) {
 638                 newHasHorizontalScrollbar = false;
 639                 needAnotherPass = true;
 640             }
 641         }
 642 
 643         if (hasHorizontalScrollbar != newHasHorizontalScrollbar &amp;&amp; (hasHorizontalScrollbar || !avoidScrollbarCreation())) {
 644             if (scrollOrigin().y() &amp;&amp; !newHasHorizontalScrollbar)
 645                 ScrollableArea::setScrollOrigin(IntPoint(scrollOrigin().x(), scrollOrigin().y() - m_horizontalScrollbar-&gt;occupiedHeight()));
 646             if (m_horizontalScrollbar)
 647                 m_horizontalScrollbar-&gt;invalidate();
 648 
 649             bool changeAffectsContentSize = false;
 650             if (setHasHorizontalScrollbar(newHasHorizontalScrollbar, &amp;changeAffectsContentSize)) {
 651                 scrollbarAddedOrRemoved = true;
 652                 sendContentResizedNotification |= changeAffectsContentSize;
 653             }
 654         }
 655 
 656         if (hasVerticalScrollbar != newHasVerticalScrollbar &amp;&amp; (hasVerticalScrollbar || !avoidScrollbarCreation())) {
 657             if (scrollOrigin().x() &amp;&amp; !newHasVerticalScrollbar)
 658                 ScrollableArea::setScrollOrigin(IntPoint(scrollOrigin().x() - m_verticalScrollbar-&gt;occupiedWidth(), scrollOrigin().y()));
 659             if (m_verticalScrollbar)
 660                 m_verticalScrollbar-&gt;invalidate();
 661 
 662             bool changeAffectsContentSize = false;
 663             if (setHasVerticalScrollbar(newHasVerticalScrollbar, &amp;changeAffectsContentSize)) {
 664                 scrollbarAddedOrRemoved = true;
 665                 sendContentResizedNotification |= changeAffectsContentSize;
 666             }
 667         }
 668 
 669         const unsigned cMaxUpdateScrollbarsPass = 2;
 670         if ((sendContentResizedNotification || needAnotherPass) &amp;&amp; m_updateScrollbarsPass &lt; cMaxUpdateScrollbarsPass) {
 671             m_updateScrollbarsPass++;
 672             availableContentSizeChanged(AvailableSizeChangeReason::ScrollbarsChanged);
 673             updateContentsSize();
 674             IntSize newDocSize = totalContentsSize();
 675             if (newDocSize == docSize) {
 676                 // The layout with the new scroll state had no impact on
 677                 // the document&#39;s overall size, so updateScrollbars didn&#39;t get called.
 678                 // Recur manually.
 679                 updateScrollbars(desiredPosition);
 680             }
 681             m_updateScrollbarsPass--;
 682         }
 683     }
 684 
 685     if (scrollbarAddedOrRemoved)
 686         addedOrRemovedScrollbar();
 687 
 688     // Set up the range (and page step/line step), but only do this if we&#39;re not in a nested call (to avoid
 689     // doing it multiple times).
 690     if (m_updateScrollbarsPass)
 691         return;
 692 
 693     m_inUpdateScrollbars = true;
 694 
 695     if (m_horizontalScrollbar) {
 696         int clientWidth = visibleWidth();
 697         int pageStep = Scrollbar::pageStep(clientWidth);
 698         IntRect oldRect(m_horizontalScrollbar-&gt;frameRect());
 699         IntRect hBarRect(shouldPlaceBlockDirectionScrollbarOnLeft() &amp;&amp; m_verticalScrollbar ? m_verticalScrollbar-&gt;occupiedWidth() : 0,
 700             height() - m_horizontalScrollbar-&gt;height(),
 701             width() - (m_verticalScrollbar ? m_verticalScrollbar-&gt;occupiedWidth() : 0),
 702             m_horizontalScrollbar-&gt;height());
 703         m_horizontalScrollbar-&gt;setFrameRect(hBarRect);
 704         if (!m_scrollbarsSuppressed &amp;&amp; oldRect != m_horizontalScrollbar-&gt;frameRect())
 705             m_horizontalScrollbar-&gt;invalidate();
 706 
 707         if (m_scrollbarsSuppressed)
 708             m_horizontalScrollbar-&gt;setSuppressInvalidation(true);
 709         m_horizontalScrollbar-&gt;setEnabled(contentsWidth() &gt; clientWidth);
 710         m_horizontalScrollbar-&gt;setSteps(Scrollbar::pixelsPerLineStep(), pageStep);
 711         m_horizontalScrollbar-&gt;setProportion(clientWidth, contentsWidth());
 712         if (m_scrollbarsSuppressed)
 713             m_horizontalScrollbar-&gt;setSuppressInvalidation(false);
 714     }
 715 
 716     if (m_verticalScrollbar) {
 717         int clientHeight = visibleHeight();
 718         int pageStep = Scrollbar::pageStep(clientHeight);
 719         IntRect oldRect(m_verticalScrollbar-&gt;frameRect());
 720         IntRect vBarRect(shouldPlaceBlockDirectionScrollbarOnLeft() ? 0 : width() - m_verticalScrollbar-&gt;width(),
 721             topContentInset(),
 722             m_verticalScrollbar-&gt;width(),
 723             height() - topContentInset() - (m_horizontalScrollbar ? m_horizontalScrollbar-&gt;occupiedHeight() : 0));
 724         m_verticalScrollbar-&gt;setFrameRect(vBarRect);
 725         if (!m_scrollbarsSuppressed &amp;&amp; oldRect != m_verticalScrollbar-&gt;frameRect())
 726             m_verticalScrollbar-&gt;invalidate();
 727 
 728         if (m_scrollbarsSuppressed)
 729             m_verticalScrollbar-&gt;setSuppressInvalidation(true);
 730         m_verticalScrollbar-&gt;setEnabled(totalContentsSize().height() &gt; clientHeight);
 731         m_verticalScrollbar-&gt;setSteps(Scrollbar::pixelsPerLineStep(), pageStep);
 732         m_verticalScrollbar-&gt;setProportion(clientHeight, totalContentsSize().height());
 733         if (m_scrollbarsSuppressed)
 734             m_verticalScrollbar-&gt;setSuppressInvalidation(false);
 735     }
 736 
 737     if (hasHorizontalScrollbar != newHasHorizontalScrollbar || hasVerticalScrollbar != newHasVerticalScrollbar) {
 738         // FIXME: Is frameRectsChanged really necessary here? Have any frame rects changed?
 739         frameRectsChanged();
 740         positionScrollbarLayers();
 741         updateScrollCorner();
 742         if (!m_horizontalScrollbar &amp;&amp; !m_verticalScrollbar)
 743             invalidateScrollCornerRect(oldScrollCornerRect);
 744     }
 745 
 746     IntPoint adjustedScrollPosition = desiredPosition;
 747     if (!isRubberBandInProgress())
 748         adjustedScrollPosition = adjustScrollPositionWithinRange(adjustedScrollPosition);
 749 
 750     if (adjustedScrollPosition != scrollPosition() || scrollOriginChanged()) {
 751         ScrollableArea::scrollToOffsetWithoutAnimation(scrollOffsetFromPosition(adjustedScrollPosition));
 752         resetScrollOriginChanged();
 753     }
 754 
 755     // Make sure the scrollbar offsets are up to date.
 756     if (m_horizontalScrollbar)
 757         m_horizontalScrollbar-&gt;offsetDidChange();
 758     if (m_verticalScrollbar)
 759         m_verticalScrollbar-&gt;offsetDidChange();
 760 
 761     m_inUpdateScrollbars = false;
 762 }
 763 
 764 const int panIconSizeLength = 16;
 765 
 766 IntRect ScrollView::rectToCopyOnScroll() const
 767 {
 768     IntRect scrollViewRect = convertToRootView(IntRect(0, 0, visibleWidth(), visibleHeight()));
 769     if (hasOverlayScrollbars()) {
 770         int verticalScrollbarWidth = (verticalScrollbar() &amp;&amp; !hasLayerForVerticalScrollbar()) ? verticalScrollbar()-&gt;width() : 0;
 771         int horizontalScrollbarHeight = (horizontalScrollbar() &amp;&amp; !hasLayerForHorizontalScrollbar()) ? horizontalScrollbar()-&gt;height() : 0;
 772 
 773         scrollViewRect.setWidth(scrollViewRect.width() - verticalScrollbarWidth);
 774         scrollViewRect.setHeight(scrollViewRect.height() - horizontalScrollbarHeight);
 775     }
 776     return scrollViewRect;
 777 }
 778 
 779 void ScrollView::scrollContents(const IntSize&amp; scrollDelta)
 780 {
 781     HostWindow* window = hostWindow();
 782     if (!window)
 783         return;
 784 
 785     // Since scrolling is double buffered, we will be blitting the scroll view&#39;s intersection
 786     // with the clip rect every time to keep it smooth.
 787     IntRect clipRect = windowClipRect();
 788     IntRect scrollViewRect = rectToCopyOnScroll();
 789     IntRect updateRect = clipRect;
 790     updateRect.intersect(scrollViewRect);
 791 
 792     // Invalidate the root view (not the backing store).
 793     window-&gt;invalidateRootView(updateRect);
 794 
 795     if (m_drawPanScrollIcon) {
 796         // FIXME: the pan icon is broken when accelerated compositing is on, since it will draw under the compositing layers.
 797         // https://bugs.webkit.org/show_bug.cgi?id=47837
 798         int panIconDirtySquareSizeLength = 2 * (panIconSizeLength + std::max(abs(scrollDelta.width()), abs(scrollDelta.height()))); // We only want to repaint what&#39;s necessary
 799         IntPoint panIconDirtySquareLocation = IntPoint(m_panScrollIconPoint.x() - (panIconDirtySquareSizeLength / 2), m_panScrollIconPoint.y() - (panIconDirtySquareSizeLength / 2));
 800         IntRect panScrollIconDirtyRect = IntRect(panIconDirtySquareLocation, IntSize(panIconDirtySquareSizeLength, panIconDirtySquareSizeLength));
 801         panScrollIconDirtyRect.intersect(clipRect);
 802         window-&gt;invalidateContentsAndRootView(panScrollIconDirtyRect);
 803     }
 804 
 805     if (canBlitOnScroll()) { // The main frame can just blit the WebView window
 806         // FIXME: Find a way to scroll subframes with this faster path
 807         if (!scrollContentsFastPath(-scrollDelta, scrollViewRect, clipRect))
 808             scrollContentsSlowPath(updateRect);
 809     } else {
 810         // We need to repaint the entire backing store. Do it now before moving the windowed plugins.
 811         scrollContentsSlowPath(updateRect);
 812     }
 813 
 814     // Invalidate the overhang areas if they are visible.
 815     updateOverhangAreas();
 816 
 817     // This call will move children with native widgets (plugins) and invalidate them as well.
 818     frameRectsChanged();
 819 
 820     // Now blit the backingstore into the window which should be very fast.
 821     window-&gt;invalidateRootView(IntRect());
 822 }
 823 
 824 void ScrollView::scrollContentsSlowPath(const IntRect&amp; updateRect)
 825 {
 826     hostWindow()-&gt;invalidateContentsForSlowScroll(updateRect);
 827 }
 828 
 829 IntPoint ScrollView::viewToContents(const IntPoint&amp; point) const
 830 {
 831     if (delegatesScrolling())
 832         return point;
 833 
 834     return point + toIntSize(documentScrollPositionRelativeToViewOrigin());
 835 }
 836 
 837 IntPoint ScrollView::contentsToView(const IntPoint&amp; point) const
 838 {
 839     if (delegatesScrolling())
 840         return point;
 841 
 842     return point - toIntSize(documentScrollPositionRelativeToViewOrigin());
 843 }
 844 
 845 IntRect ScrollView::viewToContents(IntRect rect) const
 846 {
 847     if (delegatesScrolling())
 848         return rect;
 849 
 850     rect.moveBy(documentScrollPositionRelativeToViewOrigin());
 851     return rect;
 852 }
 853 
 854 FloatRect ScrollView::viewToContents(FloatRect rect) const
 855 {
 856     if (delegatesScrolling())
 857         return rect;
 858 
 859     rect.moveBy(documentScrollPositionRelativeToViewOrigin());
 860     return rect;
 861 }
 862 
 863 IntRect ScrollView::contentsToView(IntRect rect) const
 864 {
 865     if (delegatesScrolling())
 866         return rect;
 867 
 868     rect.moveBy(-documentScrollPositionRelativeToViewOrigin());
 869     return rect;
 870 }
 871 
 872 FloatRect ScrollView::contentsToView(FloatRect rect) const
 873 {
 874     if (delegatesScrolling())
 875         return rect;
 876 
 877     rect.moveBy(-documentScrollPositionRelativeToViewOrigin());
 878     return rect;
 879 }
 880 
 881 IntPoint ScrollView::contentsToContainingViewContents(const IntPoint&amp; point) const
 882 {
 883     if (const ScrollView* parentScrollView = parent()) {
 884         IntPoint pointInContainingView = convertToContainingView(contentsToView(point));
 885         return parentScrollView-&gt;viewToContents(pointInContainingView);
 886     }
 887 
 888     return contentsToView(point);
 889 }
 890 
 891 IntRect ScrollView::contentsToContainingViewContents(IntRect rect) const
 892 {
 893     if (const ScrollView* parentScrollView = parent()) {
 894         IntRect rectInContainingView = convertToContainingView(contentsToView(rect));
 895         return parentScrollView-&gt;viewToContents(rectInContainingView);
 896     }
 897 
 898     return contentsToView(rect);
 899 }
 900 
 901 IntPoint ScrollView::rootViewToContents(const IntPoint&amp; rootViewPoint) const
 902 {
 903     return viewToContents(convertFromRootView(rootViewPoint));
 904 }
 905 
 906 IntPoint ScrollView::contentsToRootView(const IntPoint&amp; contentsPoint) const
 907 {
 908     return convertToRootView(contentsToView(contentsPoint));
 909 }
 910 
 911 IntRect ScrollView::rootViewToContents(const IntRect&amp; rootViewRect) const
 912 {
 913     return viewToContents(convertFromRootView(rootViewRect));
 914 }
 915 
 916 FloatRect ScrollView::rootViewToContents(const FloatRect&amp; rootViewRect) const
 917 {
 918     return viewToContents(convertFromRootView(rootViewRect));
 919 }
 920 
 921 IntPoint ScrollView::rootViewToTotalContents(const IntPoint&amp; rootViewPoint) const
 922 {
 923     if (delegatesScrolling())
 924         return convertFromRootView(rootViewPoint);
 925 
 926     IntPoint viewPoint = convertFromRootView(rootViewPoint);
 927     // Like rootViewToContents(), but ignores headerHeight.
 928     return viewPoint + toIntSize(scrollPosition()) - IntSize(0, topContentInset(TopContentInsetType::WebCoreOrPlatformContentInset));
 929 }
 930 
 931 IntRect ScrollView::contentsToRootView(const IntRect&amp; contentsRect) const
 932 {
 933     return convertToRootView(contentsToView(contentsRect));
 934 }
 935 
 936 IntPoint ScrollView::windowToContents(const IntPoint&amp; windowPoint) const
 937 {
 938     return viewToContents(convertFromContainingWindow(windowPoint));
 939 }
 940 
 941 IntPoint ScrollView::contentsToWindow(const IntPoint&amp; contentsPoint) const
 942 {
 943     return convertToContainingWindow(contentsToView(contentsPoint));
 944 }
 945 
 946 IntRect ScrollView::windowToContents(const IntRect&amp; windowRect) const
 947 {
 948     return viewToContents(convertFromContainingWindow(windowRect));
 949 }
 950 
 951 IntRect ScrollView::contentsToWindow(const IntRect&amp; contentsRect) const
 952 {
 953     return convertToContainingWindow(contentsToView(contentsRect));
 954 }
 955 
 956 IntRect ScrollView::contentsToScreen(const IntRect&amp; rect) const
 957 {
 958     HostWindow* window = hostWindow();
 959     if (platformWidget())
 960         return platformContentsToScreen(rect);
 961     if (!window)
 962         return IntRect();
 963     return window-&gt;rootViewToScreen(contentsToRootView(rect));
 964 }
 965 
 966 IntPoint ScrollView::screenToContents(const IntPoint&amp; point) const
 967 {
 968     HostWindow* window = hostWindow();
 969     if (platformWidget())
 970         return platformScreenToContents(point);
 971     if (!window)
 972         return IntPoint();
 973     return rootViewToContents(window-&gt;screenToRootView(point));
 974 }
 975 
 976 void ScrollView::setScrollbarsSuppressed(bool suppressed, bool repaintOnUnsuppress)
 977 {
 978     if (suppressed == m_scrollbarsSuppressed)
 979         return;
 980 
 981     m_scrollbarsSuppressed = suppressed;
 982 
 983     if (platformWidget())
 984         platformSetScrollbarsSuppressed(repaintOnUnsuppress);
 985     else if (repaintOnUnsuppress &amp;&amp; !suppressed) {
 986         if (m_horizontalScrollbar)
 987             m_horizontalScrollbar-&gt;invalidate();
 988         if (m_verticalScrollbar)
 989             m_verticalScrollbar-&gt;invalidate();
 990 
 991         // Invalidate the scroll corner too on unsuppress.
 992         invalidateRect(scrollCornerRect());
 993     }
 994 }
 995 
 996 Scrollbar* ScrollView::scrollbarAtPoint(const IntPoint&amp; windowPoint)
 997 {
 998     if (platformWidget())
 999         return 0;
1000 
1001     // convertFromContainingWindow doesn&#39;t do what it sounds like it does. We need it here just to get this
1002     // point into the right coordinates if this is the ScrollView of a sub-frame.
1003     IntPoint convertedPoint = convertFromContainingWindow(windowPoint);
1004     if (m_horizontalScrollbar &amp;&amp; m_horizontalScrollbar-&gt;shouldParticipateInHitTesting() &amp;&amp; m_horizontalScrollbar-&gt;frameRect().contains(convertedPoint))
1005         return m_horizontalScrollbar.get();
1006     if (m_verticalScrollbar &amp;&amp; m_verticalScrollbar-&gt;shouldParticipateInHitTesting() &amp;&amp; m_verticalScrollbar-&gt;frameRect().contains(convertedPoint))
1007         return m_verticalScrollbar.get();
1008     return 0;
1009 }
1010 
1011 void ScrollView::setScrollbarOverlayStyle(ScrollbarOverlayStyle overlayStyle)
1012 {
1013     ScrollableArea::setScrollbarOverlayStyle(overlayStyle);
1014     platformSetScrollbarOverlayStyle(overlayStyle);
1015 }
1016 
1017 void ScrollView::setFrameRect(const IntRect&amp; newRect)
1018 {
1019     Ref&lt;ScrollView&gt; protectedThis(*this);
1020     IntRect oldRect = frameRect();
1021 
1022     if (newRect == oldRect)
1023         return;
1024 
1025     Widget::setFrameRect(newRect);
1026     frameRectsChanged();
1027 
1028     updateScrollbars(scrollPosition());
1029 
1030     if (!m_useFixedLayout &amp;&amp; oldRect.size() != newRect.size())
1031         availableContentSizeChanged(AvailableSizeChangeReason::AreaSizeChanged);
1032 }
1033 
1034 void ScrollView::frameRectsChanged()
1035 {
1036     if (platformWidget())
1037         return;
1038     for (auto&amp; child : m_children)
1039         child-&gt;frameRectsChanged();
1040 }
1041 
1042 void ScrollView::clipRectChanged()
1043 {
1044     for (auto&amp; child : m_children)
1045         child-&gt;clipRectChanged();
1046 }
1047 
1048 static void positionScrollbarLayer(GraphicsLayer* graphicsLayer, Scrollbar* scrollbar)
1049 {
1050     if (!graphicsLayer || !scrollbar)
1051         return;
1052 
1053     IntRect scrollbarRect = scrollbar-&gt;frameRect();
1054     graphicsLayer-&gt;setPosition(scrollbarRect.location());
1055 
1056     if (scrollbarRect.size() == graphicsLayer-&gt;size())
1057         return;
1058 
1059     graphicsLayer-&gt;setSize(scrollbarRect.size());
1060 
1061     if (graphicsLayer-&gt;usesContentsLayer()) {
1062         graphicsLayer-&gt;setContentsRect(IntRect(0, 0, scrollbarRect.width(), scrollbarRect.height()));
1063         return;
1064     }
1065 
1066     graphicsLayer-&gt;setDrawsContent(true);
1067     graphicsLayer-&gt;setNeedsDisplay();
1068 }
1069 
1070 static void positionScrollCornerLayer(GraphicsLayer* graphicsLayer, const IntRect&amp; cornerRect)
1071 {
1072     if (!graphicsLayer)
1073         return;
1074     graphicsLayer-&gt;setDrawsContent(!cornerRect.isEmpty());
1075     graphicsLayer-&gt;setPosition(cornerRect.location());
1076     if (cornerRect.size() != graphicsLayer-&gt;size())
1077         graphicsLayer-&gt;setNeedsDisplay();
1078     graphicsLayer-&gt;setSize(cornerRect.size());
1079 }
1080 
1081 void ScrollView::positionScrollbarLayers()
1082 {
1083     positionScrollbarLayer(layerForHorizontalScrollbar(), horizontalScrollbar());
1084     positionScrollbarLayer(layerForVerticalScrollbar(), verticalScrollbar());
1085     positionScrollCornerLayer(layerForScrollCorner(), scrollCornerRect());
1086 }
1087 
1088 void ScrollView::repaintContentRectangle(const IntRect&amp; rect)
1089 {
1090     IntRect paintRect = rect;
1091     if (!paintsEntireContents())
1092         paintRect.intersect(visibleContentRect(LegacyIOSDocumentVisibleRect));
1093     if (paintRect.isEmpty())
1094         return;
1095 
1096     if (platformWidget()) {
1097         notifyPageThatContentAreaWillPaint();
1098         platformRepaintContentRectangle(paintRect);
1099         return;
1100     }
1101 
1102     if (HostWindow* window = hostWindow())
1103         window-&gt;invalidateContentsAndRootView(contentsToWindow(paintRect));
1104 }
1105 
1106 IntRect ScrollView::scrollCornerRect() const
1107 {
1108     IntRect cornerRect;
1109 
1110     if (hasOverlayScrollbars())
1111         return cornerRect;
1112 
1113     int heightTrackedByScrollbar = height() - topContentInset();
1114 
1115     if (m_horizontalScrollbar &amp;&amp; width() - m_horizontalScrollbar-&gt;width() &gt; 0) {
1116         cornerRect.unite(IntRect(shouldPlaceBlockDirectionScrollbarOnLeft() ? 0 : m_horizontalScrollbar-&gt;width(),
1117             height() - m_horizontalScrollbar-&gt;height(),
1118             width() - m_horizontalScrollbar-&gt;width(),
1119             m_horizontalScrollbar-&gt;height()));
1120     }
1121 
1122     if (m_verticalScrollbar &amp;&amp; heightTrackedByScrollbar - m_verticalScrollbar-&gt;height() &gt; 0) {
1123         cornerRect.unite(IntRect(shouldPlaceBlockDirectionScrollbarOnLeft() ? 0 : width() - m_verticalScrollbar-&gt;width(),
1124             m_verticalScrollbar-&gt;height() + topContentInset(),
1125             m_verticalScrollbar-&gt;width(),
1126             heightTrackedByScrollbar - m_verticalScrollbar-&gt;height()));
1127     }
1128 
1129     return cornerRect;
1130 }
1131 
1132 bool ScrollView::isScrollCornerVisible() const
1133 {
1134     return !scrollCornerRect().isEmpty();
1135 }
1136 
1137 void ScrollView::scrollbarStyleChanged(ScrollbarStyle newStyle, bool forceUpdate)
1138 {
1139     ScrollableArea::scrollbarStyleChanged(newStyle, forceUpdate);
1140     if (!forceUpdate)
1141         return;
1142 
1143     updateScrollbars(scrollPosition());
1144     positionScrollbarLayers();
1145 }
1146 
1147 void ScrollView::paintScrollCorner(GraphicsContext&amp; context, const IntRect&amp; cornerRect)
1148 {
1149     ScrollbarTheme::theme().paintScrollCorner(context, cornerRect);
1150 }
1151 
1152 void ScrollView::paintScrollbar(GraphicsContext&amp; context, Scrollbar&amp; bar, const IntRect&amp; rect)
1153 {
1154     bar.paint(context, rect);
1155 }
1156 
1157 void ScrollView::invalidateScrollCornerRect(const IntRect&amp; rect)
1158 {
1159     invalidateRect(rect);
1160 }
1161 
1162 void ScrollView::paintScrollbars(GraphicsContext&amp; context, const IntRect&amp; rect)
1163 {
1164     if (m_horizontalScrollbar &amp;&amp; !layerForHorizontalScrollbar())
1165         paintScrollbar(context, *m_horizontalScrollbar.get(), rect);
1166     if (m_verticalScrollbar &amp;&amp; !layerForVerticalScrollbar())
1167         paintScrollbar(context, *m_verticalScrollbar.get(), rect);
1168 
1169     if (layerForScrollCorner())
1170         return;
1171 
1172     paintScrollCorner(context, scrollCornerRect());
1173 }
1174 
1175 void ScrollView::paintPanScrollIcon(GraphicsContext&amp; context)
1176 {
1177     static Image&amp; panScrollIcon = Image::loadPlatformResource(&quot;panIcon&quot;).leakRef();
1178     IntPoint iconGCPoint = m_panScrollIconPoint;
1179     if (parent())
1180         iconGCPoint = parent()-&gt;windowToContents(iconGCPoint);
1181     context.drawImage(panScrollIcon, iconGCPoint);
1182 }
1183 
1184 void ScrollView::paint(GraphicsContext&amp; context, const IntRect&amp; rect, SecurityOriginPaintPolicy securityOriginPaintPolicy)
1185 {
1186     if (platformWidget()) {
1187         Widget::paint(context, rect);
1188         return;
1189     }
1190 
1191     if (context.paintingDisabled() &amp;&amp; !context.performingPaintInvalidation())
1192         return;
1193 
1194     notifyPageThatContentAreaWillPaint();
1195 
1196     IntRect documentDirtyRect = rect;
1197     if (!paintsEntireContents()) {
1198         IntRect visibleAreaWithoutScrollbars(locationOfContents(), visibleContentRect(LegacyIOSDocumentVisibleRect).size());
1199         documentDirtyRect.intersect(visibleAreaWithoutScrollbars);
1200     }
1201 
1202     if (!documentDirtyRect.isEmpty()) {
1203         GraphicsContextStateSaver stateSaver(context);
1204 
1205         IntPoint locationOfContents = this-&gt;locationOfContents();
1206         context.translate(locationOfContents.x(), locationOfContents.y());
1207         documentDirtyRect.moveBy(-locationOfContents);
1208 
1209         if (!paintsEntireContents()) {
1210             context.translate(-scrollX(), -scrollY());
1211             documentDirtyRect.moveBy(scrollPosition());
1212 
1213             context.clip(visibleContentRect(LegacyIOSDocumentVisibleRect));
1214         }
1215 
1216         paintContents(context, documentDirtyRect, securityOriginPaintPolicy);
1217     }
1218 
1219 #if ENABLE(RUBBER_BANDING)
1220     if (!layerForOverhangAreas())
1221         calculateAndPaintOverhangAreas(context, rect);
1222 #else
1223     calculateAndPaintOverhangAreas(context, rect);
1224 #endif
1225 
1226     // Now paint the scrollbars.
1227     if (!m_scrollbarsSuppressed &amp;&amp; (m_horizontalScrollbar || m_verticalScrollbar)) {
1228         GraphicsContextStateSaver stateSaver(context);
1229         IntRect scrollViewDirtyRect = rect;
1230         IntRect visibleAreaWithScrollbars(location(), unobscuredContentRectIncludingScrollbars().size());
1231         scrollViewDirtyRect.intersect(visibleAreaWithScrollbars);
1232         context.translate(x(), y());
1233         scrollViewDirtyRect.moveBy(-location());
1234         context.clip(IntRect(IntPoint(), visibleAreaWithScrollbars.size()));
1235 
1236         paintScrollbars(context, scrollViewDirtyRect);
1237     }
1238 
1239     // Paint the panScroll Icon
1240     if (m_drawPanScrollIcon)
1241         paintPanScrollIcon(context);
1242 }
1243 
1244 void ScrollView::calculateOverhangAreasForPainting(IntRect&amp; horizontalOverhangRect, IntRect&amp; verticalOverhangRect)
1245 {
1246     IntSize scrollbarSpace = scrollbarIntrusion();
1247 
1248     // FIXME: use maximumScrollOffset().
1249     ScrollOffset scrollOffset = scrollOffsetFromPosition(scrollPosition());
1250     if (scrollOffset.y() &lt; 0) {
1251         horizontalOverhangRect = frameRect();
1252         horizontalOverhangRect.setHeight(-scrollOffset.y());
1253         horizontalOverhangRect.setWidth(horizontalOverhangRect.width() - scrollbarSpace.width());
1254     } else if (totalContentsSize().height() &amp;&amp; scrollOffset.y() &gt; totalContentsSize().height() - visibleHeight()) {
1255         int height = scrollOffset.y() - (totalContentsSize().height() - visibleHeight());
1256         horizontalOverhangRect = frameRect();
1257         horizontalOverhangRect.setY(frameRect().maxY() - height - scrollbarSpace.height());
1258         horizontalOverhangRect.setHeight(height);
1259         horizontalOverhangRect.setWidth(horizontalOverhangRect.width() - scrollbarSpace.width());
1260     }
1261 
1262     if (scrollOffset.x() &lt; 0) {
1263         verticalOverhangRect.setWidth(-scrollOffset.x());
1264         verticalOverhangRect.setHeight(frameRect().height() - horizontalOverhangRect.height() - scrollbarSpace.height());
1265         verticalOverhangRect.setX(frameRect().x());
1266         if (horizontalOverhangRect.y() == frameRect().y())
1267             verticalOverhangRect.setY(frameRect().y() + horizontalOverhangRect.height());
1268         else
1269             verticalOverhangRect.setY(frameRect().y());
1270     } else if (contentsWidth() &amp;&amp; scrollOffset.x() &gt; contentsWidth() - visibleWidth()) {
1271         int width = scrollOffset.x() - (contentsWidth() - visibleWidth());
1272         verticalOverhangRect.setWidth(width);
1273         verticalOverhangRect.setHeight(frameRect().height() - horizontalOverhangRect.height() - scrollbarSpace.height());
1274         verticalOverhangRect.setX(frameRect().maxX() - width - scrollbarSpace.width());
1275         if (horizontalOverhangRect.y() == frameRect().y())
1276             verticalOverhangRect.setY(frameRect().y() + horizontalOverhangRect.height());
1277         else
1278             verticalOverhangRect.setY(frameRect().y());
1279     }
1280 }
1281 
1282 void ScrollView::updateOverhangAreas()
1283 {
1284     HostWindow* window = hostWindow();
1285     if (!window)
1286         return;
1287 
1288     IntRect horizontalOverhangRect;
1289     IntRect verticalOverhangRect;
1290     calculateOverhangAreasForPainting(horizontalOverhangRect, verticalOverhangRect);
1291     if (!horizontalOverhangRect.isEmpty())
1292         window-&gt;invalidateContentsAndRootView(horizontalOverhangRect);
1293     if (!verticalOverhangRect.isEmpty())
1294         window-&gt;invalidateContentsAndRootView(verticalOverhangRect);
1295 }
1296 
1297 void ScrollView::paintOverhangAreas(GraphicsContext&amp; context, const IntRect&amp; horizontalOverhangRect, const IntRect&amp; verticalOverhangRect, const IntRect&amp; dirtyRect)
1298 {
1299     ScrollbarTheme::theme().paintOverhangAreas(*this, context, horizontalOverhangRect, verticalOverhangRect, dirtyRect);
1300 }
1301 
1302 void ScrollView::calculateAndPaintOverhangAreas(GraphicsContext&amp; context, const IntRect&amp; dirtyRect)
1303 {
1304     IntRect horizontalOverhangRect;
1305     IntRect verticalOverhangRect;
1306     calculateOverhangAreasForPainting(horizontalOverhangRect, verticalOverhangRect);
1307 
1308     if (dirtyRect.intersects(horizontalOverhangRect) || dirtyRect.intersects(verticalOverhangRect))
1309         paintOverhangAreas(context, horizontalOverhangRect, verticalOverhangRect, dirtyRect);
1310 }
1311 
1312 bool ScrollView::isPointInScrollbarCorner(const IntPoint&amp; windowPoint)
1313 {
1314     if (!scrollbarCornerPresent())
1315         return false;
1316 
1317     IntPoint viewPoint = convertFromContainingWindow(windowPoint);
1318 
1319     if (m_horizontalScrollbar) {
1320         int horizontalScrollbarYMin = m_horizontalScrollbar-&gt;frameRect().y();
1321         int horizontalScrollbarYMax = m_horizontalScrollbar-&gt;frameRect().y() + m_horizontalScrollbar-&gt;frameRect().height();
1322         int horizontalScrollbarXMin = m_horizontalScrollbar-&gt;frameRect().x() + m_horizontalScrollbar-&gt;frameRect().width();
1323 
1324         return viewPoint.y() &gt; horizontalScrollbarYMin &amp;&amp; viewPoint.y() &lt; horizontalScrollbarYMax &amp;&amp; viewPoint.x() &gt; horizontalScrollbarXMin;
1325     }
1326 
1327     int verticalScrollbarXMin = m_verticalScrollbar-&gt;frameRect().x();
1328     int verticalScrollbarXMax = m_verticalScrollbar-&gt;frameRect().x() + m_verticalScrollbar-&gt;frameRect().width();
1329     int verticalScrollbarYMin = m_verticalScrollbar-&gt;frameRect().y() + m_verticalScrollbar-&gt;frameRect().height();
1330 
1331     return viewPoint.x() &gt; verticalScrollbarXMin &amp;&amp; viewPoint.x() &lt; verticalScrollbarXMax &amp;&amp; viewPoint.y() &gt; verticalScrollbarYMin;
1332 }
1333 
1334 bool ScrollView::scrollbarCornerPresent() const
1335 {
1336     return (m_horizontalScrollbar &amp;&amp; width() - m_horizontalScrollbar-&gt;width() &gt; 0)
1337         || (m_verticalScrollbar &amp;&amp; height() - m_verticalScrollbar-&gt;height() &gt; 0);
1338 }
1339 
1340 IntRect ScrollView::convertFromScrollbarToContainingView(const Scrollbar&amp; scrollbar, const IntRect&amp; localRect) const
1341 {
1342     // Scrollbars won&#39;t be transformed within us
1343     IntRect newRect = localRect;
1344     newRect.moveBy(scrollbar.location());
1345     return newRect;
1346 }
1347 
1348 IntRect ScrollView::convertFromContainingViewToScrollbar(const Scrollbar&amp; scrollbar, const IntRect&amp; parentRect) const
1349 {
1350     IntRect newRect = parentRect;
1351     // Scrollbars won&#39;t be transformed within us
1352     newRect.moveBy(-scrollbar.location());
1353     return newRect;
1354 }
1355 
1356 // FIXME: test these on windows
1357 IntPoint ScrollView::convertFromScrollbarToContainingView(const Scrollbar&amp; scrollbar, const IntPoint&amp; localPoint) const
1358 {
1359     // Scrollbars won&#39;t be transformed within us
1360     IntPoint newPoint = localPoint;
1361     newPoint.moveBy(scrollbar.location());
1362     return newPoint;
1363 }
1364 
1365 IntPoint ScrollView::convertFromContainingViewToScrollbar(const Scrollbar&amp; scrollbar, const IntPoint&amp; parentPoint) const
1366 {
1367     IntPoint newPoint = parentPoint;
1368     // Scrollbars won&#39;t be transformed within us
1369     newPoint.moveBy(-scrollbar.location());
1370     return newPoint;
1371 }
1372 
1373 void ScrollView::setParentVisible(bool visible)
1374 {
1375     if (isParentVisible() == visible)
1376         return;
1377 
1378     Widget::setParentVisible(visible);
1379 
1380     if (!isSelfVisible())
1381         return;
1382 
1383     for (auto&amp; child : m_children)
1384         child-&gt;setParentVisible(visible);
1385 }
1386 
1387 void ScrollView::show()
1388 {
1389     if (!isSelfVisible()) {
1390         setSelfVisible(true);
1391         if (isParentVisible()) {
1392             for (auto&amp; child : m_children)
1393                 child-&gt;setParentVisible(true);
1394         }
1395     }
1396 
1397     Widget::show();
1398 }
1399 
1400 void ScrollView::hide()
1401 {
1402     if (isSelfVisible()) {
1403         if (isParentVisible()) {
1404             for (auto&amp; child : m_children)
1405                 child-&gt;setParentVisible(false);
1406         }
1407         setSelfVisible(false);
1408     }
1409 
1410     Widget::hide();
1411 }
1412 
1413 bool ScrollView::isOffscreen() const
1414 {
1415     if (platformWidget())
1416         return platformIsOffscreen();
1417 
1418     if (!isVisible())
1419         return true;
1420 
1421     // FIXME: Add a HostWindow::isOffscreen method here.  Since only Mac implements this method
1422     // currently, we can add the method when the other platforms decide to implement this concept.
1423     return false;
1424 }
1425 
1426 
1427 void ScrollView::addPanScrollIcon(const IntPoint&amp; iconPosition)
1428 {
1429     HostWindow* window = hostWindow();
1430     if (!window)
1431         return;
1432     m_drawPanScrollIcon = true;
1433     m_panScrollIconPoint = IntPoint(iconPosition.x() - panIconSizeLength / 2 , iconPosition.y() - panIconSizeLength / 2) ;
1434     window-&gt;invalidateContentsAndRootView(IntRect(m_panScrollIconPoint, IntSize(panIconSizeLength, panIconSizeLength)));
1435 }
1436 
1437 void ScrollView::removePanScrollIcon()
1438 {
1439     HostWindow* window = hostWindow();
1440     if (!window)
1441         return;
1442     m_drawPanScrollIcon = false;
1443     window-&gt;invalidateContentsAndRootView(IntRect(m_panScrollIconPoint, IntSize(panIconSizeLength, panIconSizeLength)));
1444 }
1445 
1446 void ScrollView::setScrollOrigin(const IntPoint&amp; origin, bool updatePositionAtAll, bool updatePositionSynchronously)
1447 {
1448     if (scrollOrigin() == origin)
1449         return;
1450 
1451     ScrollableArea::setScrollOrigin(origin);
1452 
1453     if (platformWidget()) {
1454         platformSetScrollOrigin(origin, updatePositionAtAll, updatePositionSynchronously);
1455         return;
1456     }
1457 
1458     // Update if the scroll origin changes, since our position will be different if the content size did not change.
1459     if (updatePositionAtAll &amp;&amp; updatePositionSynchronously)
1460         updateScrollbars(scrollPosition());
1461 }
1462 
1463 void ScrollView::styleDidChange()
1464 {
1465     if (m_horizontalScrollbar)
1466         m_horizontalScrollbar-&gt;styleChanged();
1467 
1468     if (m_verticalScrollbar)
1469         m_verticalScrollbar-&gt;styleChanged();
1470 }
1471 
1472 IntPoint ScrollView::locationOfContents() const
1473 {
1474     IntPoint result = location();
1475     if (shouldPlaceBlockDirectionScrollbarOnLeft() &amp;&amp; m_verticalScrollbar)
1476         result.move(m_verticalScrollbar-&gt;occupiedWidth(), 0);
1477     return result;
1478 }
1479 
1480 #if !PLATFORM(COCOA)
1481 
1482 void ScrollView::platformAddChild(Widget*)
1483 {
1484 }
1485 
1486 void ScrollView::platformRemoveChild(Widget*)
1487 {
1488 }
1489 
1490 #endif
1491 
1492 #if !PLATFORM(COCOA)
1493 
1494 void ScrollView::platformSetScrollbarsSuppressed(bool)
1495 {
1496 }
1497 
1498 void ScrollView::platformSetScrollOrigin(const IntPoint&amp;, bool, bool)
1499 {
1500 }
1501 
1502 void ScrollView::platformSetScrollbarOverlayStyle(ScrollbarOverlayStyle)
1503 {
1504 }
1505 
1506 #endif
1507 
1508 #if !PLATFORM(COCOA)
1509 
1510 void ScrollView::platformSetScrollbarModes()
1511 {
1512 }
1513 
1514 void ScrollView::platformScrollbarModes(ScrollbarMode&amp; horizontal, ScrollbarMode&amp; vertical) const
1515 {
1516     horizontal = ScrollbarAuto;
1517     vertical = ScrollbarAuto;
1518 }
1519 
1520 void ScrollView::platformSetCanBlitOnScroll(bool)
1521 {
1522 }
1523 
1524 bool ScrollView::platformCanBlitOnScroll() const
1525 {
1526     return false;
1527 }
1528 
1529 IntRect ScrollView::platformVisibleContentRect(bool) const
1530 {
1531     return IntRect();
1532 }
1533 
1534 float ScrollView::platformTopContentInset() const
1535 {
1536     return 0;
1537 }
1538 
1539 void ScrollView::platformSetTopContentInset(float)
1540 {
1541 }
1542 
1543 IntSize ScrollView::platformVisibleContentSize(bool) const
1544 {
1545     return IntSize();
1546 }
1547 
1548 IntRect ScrollView::platformVisibleContentRectIncludingObscuredArea(bool) const
1549 {
1550     return IntRect();
1551 }
1552 
1553 IntSize ScrollView::platformVisibleContentSizeIncludingObscuredArea(bool) const
1554 {
1555     return IntSize();
1556 }
1557 
1558 void ScrollView::platformSetContentsSize()
1559 {
1560 }
1561 
1562 IntRect ScrollView::platformContentsToScreen(const IntRect&amp; rect) const
1563 {
1564     return rect;
1565 }
1566 
1567 IntPoint ScrollView::platformScreenToContents(const IntPoint&amp; point) const
1568 {
1569     return point;
1570 }
1571 
1572 void ScrollView::platformSetScrollPosition(const IntPoint&amp;)
1573 {
1574 }
1575 
1576 bool ScrollView::platformScroll(ScrollDirection, ScrollGranularity)
1577 {
1578     return true;
1579 }
1580 
1581 void ScrollView::platformRepaintContentRectangle(const IntRect&amp;)
1582 {
1583 }
1584 
1585 bool ScrollView::platformIsOffscreen() const
1586 {
1587     return false;
1588 }
1589 
1590 #endif
1591 
1592 }
    </pre>
  </body>
</html>