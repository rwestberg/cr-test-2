<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderBox.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 1999 Lars Knoll (knoll@kde.org)
  3  *           (C) 1999 Antti Koivisto (koivisto@kde.org)
  4  * Copyright (C) 2003, 2006, 2007, 2015 Apple Inc. All rights reserved.
  5  *
  6  * This library is free software; you can redistribute it and/or
  7  * modify it under the terms of the GNU Library General Public
  8  * License as published by the Free Software Foundation; either
  9  * version 2 of the License, or (at your option) any later version.
 10  *
 11  * This library is distributed in the hope that it will be useful,
 12  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 13  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 14  * Library General Public License for more details.
 15  *
 16  * You should have received a copy of the GNU Library General Public License
 17  * along with this library; see the file COPYING.LIB.  If not, write to
 18  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 19  * Boston, MA 02110-1301, USA.
 20  *
 21  */
 22 
 23 #pragma once
 24 
 25 #include &quot;FrameView.h&quot;
 26 #include &quot;RenderBoxModelObject.h&quot;
 27 #include &quot;RenderOverflow.h&quot;
 28 #include &quot;ScrollTypes.h&quot;
 29 #include &quot;ShapeOutsideInfo.h&quot;
 30 
 31 namespace WebCore {
 32 
 33 class InlineElementBox;
 34 class RenderBlockFlow;
 35 class RenderBoxFragmentInfo;
 36 class RenderFragmentContainer;
 37 struct PaintInfo;
 38 
 39 enum SizeType { MainOrPreferredSize, MinSize, MaxSize };
 40 enum AvailableLogicalHeightType { ExcludeMarginBorderPadding, IncludeMarginBorderPadding };
 41 enum OverlayScrollbarSizeRelevancy { IgnoreOverlayScrollbarSize, IncludeOverlayScrollbarSize };
 42 
 43 enum ShouldComputePreferred { ComputeActual, ComputePreferred };
 44 
 45 class RenderBox : public RenderBoxModelObject {
 46     WTF_MAKE_ISO_ALLOCATED(RenderBox);
 47 public:
 48     virtual ~RenderBox();
 49 
 50     // hasAutoZIndex only returns true if the element is positioned or a flex-item since
 51     // position:static elements that are not flex-items get their z-index coerced to auto.
 52     bool requiresLayer() const override
 53     {
 54         return isDocumentElementRenderer() || isPositioned() || createsGroup() || hasClipPath() || hasOverflowClip()
 55             || hasTransformRelatedProperty() || hasHiddenBackface() || hasReflection() || style().specifiesColumns()
 56             || !style().hasAutoZIndex() || hasRunningAcceleratedAnimations();
 57     }
 58 
 59     bool backgroundIsKnownToBeOpaqueInRect(const LayoutRect&amp; localRect) const final;
 60 
 61     // Returns false for the body renderer if its background is propagated to the root.
 62     bool paintsOwnBackground() const;
 63 
 64     LayoutUnit x() const { return m_frameRect.x(); }
 65     LayoutUnit y() const { return m_frameRect.y(); }
 66     LayoutUnit width() const { return m_frameRect.width(); }
 67     LayoutUnit height() const { return m_frameRect.height(); }
 68 
 69     // These represent your location relative to your container as a physical offset.
 70     // In layout related methods you almost always want the logical location (e.g. x() and y()).
 71     LayoutUnit top() const { return topLeftLocation().y(); }
 72     LayoutUnit left() const { return topLeftLocation().x(); }
 73 
<a name="1" id="anc1"></a><span class="line-modified"> 74     template&lt;typename T&gt; void setX(T x) { m_frameRect.setX(x); }</span>
<span class="line-modified"> 75     template&lt;typename T&gt; void setY(T y) { m_frameRect.setY(y); }</span>
<span class="line-modified"> 76     template&lt;typename T&gt; void setWidth(T width) { m_frameRect.setWidth(width); }</span>
<span class="line-modified"> 77     template&lt;typename T&gt; void setHeight(T height) { m_frameRect.setHeight(height); }</span>
 78 
 79     LayoutUnit logicalLeft() const { return style().isHorizontalWritingMode() ? x() : y(); }
 80     LayoutUnit logicalRight() const { return logicalLeft() + logicalWidth(); }
 81     LayoutUnit logicalTop() const { return style().isHorizontalWritingMode() ? y() : x(); }
 82     LayoutUnit logicalBottom() const { return logicalTop() + logicalHeight(); }
 83     LayoutUnit logicalWidth() const { return style().isHorizontalWritingMode() ? width() : height(); }
 84     LayoutUnit logicalHeight() const { return style().isHorizontalWritingMode() ? height() : width(); }
 85 
 86     LayoutUnit constrainLogicalWidthInFragmentByMinMax(LayoutUnit, LayoutUnit, RenderBlock&amp;, RenderFragmentContainer* = nullptr) const;
 87     LayoutUnit constrainLogicalHeightByMinMax(LayoutUnit logicalHeight, Optional&lt;LayoutUnit&gt; intrinsicContentHeight) const;
 88     LayoutUnit constrainContentBoxLogicalHeightByMinMax(LayoutUnit logicalHeight, Optional&lt;LayoutUnit&gt; intrinsicContentHeight) const;
 89 
 90     void setLogicalLeft(LayoutUnit left)
 91     {
 92         if (style().isHorizontalWritingMode())
 93             setX(left);
 94         else
 95             setY(left);
 96     }
 97     void setLogicalTop(LayoutUnit top)
 98     {
 99         if (style().isHorizontalWritingMode())
100             setY(top);
101         else
102             setX(top);
103     }
104     void setLogicalLocation(const LayoutPoint&amp; location)
105     {
106         if (style().isHorizontalWritingMode())
107             setLocation(location);
108         else
109             setLocation(location.transposedPoint());
110     }
111     void setLogicalWidth(LayoutUnit size)
112     {
113         if (style().isHorizontalWritingMode())
114             setWidth(size);
115         else
116             setHeight(size);
117     }
118     void setLogicalHeight(LayoutUnit size)
119     {
120         if (style().isHorizontalWritingMode())
121             setHeight(size);
122         else
123             setWidth(size);
124     }
125     void setLogicalSize(const LayoutSize&amp; size)
126     {
127         if (style().isHorizontalWritingMode())
128             setSize(size);
129         else
130             setSize(size.transposedSize());
131     }
132 
133     LayoutPoint location() const { return m_frameRect.location(); }
134     LayoutSize locationOffset() const { return LayoutSize(x(), y()); }
135     LayoutSize size() const { return m_frameRect.size(); }
136 
137     void setLocation(const LayoutPoint&amp; location) { m_frameRect.setLocation(location); }
138 
139     void setSize(const LayoutSize&amp; size) { m_frameRect.setSize(size); }
140     void move(LayoutUnit dx, LayoutUnit dy) { m_frameRect.move(dx, dy); }
141 
142     LayoutRect frameRect() const { return m_frameRect; }
143     void setFrameRect(const LayoutRect&amp; rect) { m_frameRect = rect; }
144 
145     LayoutRect marginBoxRect() const
146     {
147         auto marginLeft = computedCSSPadding(style().marginLeft());
148         auto marginRight = computedCSSPadding(style().marginRight());
149         auto marginTop = computedCSSPadding(style().marginTop());
150         auto marginBottom = computedCSSPadding(style().marginBottom());
151         return LayoutRect(-marginLeft, -marginTop, size().width() + marginLeft + marginRight, size().height() + marginTop + marginBottom);
152     }
153     LayoutRect borderBoxRect() const { return LayoutRect(LayoutPoint(), size()); }
154     LayoutRect borderBoundingBox() const final { return borderBoxRect(); }
155 
156     WEBCORE_EXPORT RoundedRect::Radii borderRadii() const;
157 
158     // The content area of the box (excludes padding - and intrinsic padding for table cells, etc... - and border).
159     LayoutRect contentBoxRect() const;
160     LayoutPoint contentBoxLocation() const;
161 
162     // The content box in absolute coords. Ignores transforms.
163     IntRect absoluteContentBox() const;
164     // The content box converted to absolute coords (taking transforms into account).
165     WEBCORE_EXPORT FloatQuad absoluteContentQuad() const;
166 
167     // This returns the content area of the box (excluding padding and border). The only difference with contentBoxRect is that computedCSSContentBoxRect
168     // does include the intrinsic padding in the content box as this is what some callers expect (like getComputedStyle).
169     LayoutRect computedCSSContentBoxRect() const { return LayoutRect(borderLeft() + computedCSSPaddingLeft(), borderTop() + computedCSSPaddingTop(), paddingBoxWidth() - computedCSSPaddingLeft() - computedCSSPaddingRight(), paddingBoxHeight() - computedCSSPaddingTop() - computedCSSPaddingBottom()); }
170 
171     // Bounds of the outline box in absolute coords. Respects transforms
172     LayoutRect outlineBoundsForRepaint(const RenderLayerModelObject* /*repaintContainer*/, const RenderGeometryMap*) const final;
173     void addFocusRingRects(Vector&lt;LayoutRect&gt;&amp;, const LayoutPoint&amp; additionalOffset, const RenderLayerModelObject* paintContainer = nullptr) override;
174 
175     FloatRect repaintRectInLocalCoordinates() const override { return borderBoxRect(); }
176     FloatRect objectBoundingBox() const override { return borderBoxRect(); }
177 
178     // Note these functions are not equivalent of childrenOfType&lt;RenderBox&gt;
179     RenderBox* parentBox() const;
180     RenderBox* firstChildBox() const;
181     RenderBox* lastChildBox() const;
182     RenderBox* previousSiblingBox() const;
183     RenderBox* nextSiblingBox() const;
184 
185     // Visual and layout overflow are in the coordinate space of the box.  This means that they aren&#39;t purely physical directions.
186     // For horizontal-tb and vertical-lr they will match physical directions, but for horizontal-bt and vertical-rl, the top/bottom and left/right
187     // respectively are flipped when compared to their physical counterparts.  For example minX is on the left in vertical-lr,
188     // but it is on the right in vertical-rl.
189     WEBCORE_EXPORT LayoutRect flippedClientBoxRect() const;
190     LayoutRect layoutOverflowRect() const { return m_overflow ? m_overflow-&gt;layoutOverflowRect() : flippedClientBoxRect(); }
191     LayoutUnit logicalLeftLayoutOverflow() const { return style().isHorizontalWritingMode() ? layoutOverflowRect().x() : layoutOverflowRect().y(); }
192     LayoutUnit logicalRightLayoutOverflow() const { return style().isHorizontalWritingMode() ? layoutOverflowRect().maxX() : layoutOverflowRect().maxY(); }
193 
<a name="2" id="anc2"></a><span class="line-modified">194     LayoutRect visualOverflowRect() const { return m_overflow ? m_overflow-&gt;visualOverflowRect() : borderBoxRect(); }</span>
195     LayoutUnit logicalLeftVisualOverflow() const { return style().isHorizontalWritingMode() ? visualOverflowRect().x() : visualOverflowRect().y(); }
196     LayoutUnit logicalRightVisualOverflow() const { return style().isHorizontalWritingMode() ? visualOverflowRect().maxX() : visualOverflowRect().maxY(); }
197 
198     LayoutRect overflowRectForPaintRejection() const;
199 
200     void addLayoutOverflow(const LayoutRect&amp;);
201     void addVisualOverflow(const LayoutRect&amp;);
202     void clearOverflow();
203 
204     virtual bool isTopLayoutOverflowAllowed() const { return !style().isLeftToRightDirection() &amp;&amp; !isHorizontalWritingMode(); }
205     virtual bool isLeftLayoutOverflowAllowed() const { return !style().isLeftToRightDirection() &amp;&amp; isHorizontalWritingMode(); }
206 
207     void addVisualEffectOverflow();
208     LayoutRect applyVisualEffectOverflow(const LayoutRect&amp;) const;
209     void addOverflowFromChild(const RenderBox* child) { addOverflowFromChild(child, child-&gt;locationOffset()); }
210     void addOverflowFromChild(const RenderBox* child, const LayoutSize&amp; delta);
211 
212     void updateLayerTransform();
213 
214     LayoutSize contentSize() const { return { contentWidth(), contentHeight() }; }
215     LayoutUnit contentWidth() const { return paddingBoxWidth() - paddingLeft() - paddingRight(); }
216     LayoutUnit contentHeight() const { return paddingBoxHeight() - paddingTop() - paddingBottom(); }
217     LayoutUnit contentLogicalWidth() const { return style().isHorizontalWritingMode() ? contentWidth() : contentHeight(); }
218     LayoutUnit contentLogicalHeight() const { return style().isHorizontalWritingMode() ? contentHeight() : contentWidth(); }
219 
220     LayoutUnit paddingBoxWidth() const { return width() - borderLeft() - borderRight() - verticalScrollbarWidth(); }
221     LayoutUnit paddingBoxHeight() const { return height() - borderTop() - borderBottom() - horizontalScrollbarHeight(); }
<a name="3" id="anc3"></a><span class="line-modified">222     LayoutRect paddingBoxRect() const;</span>
223     LayoutRect paddingBoxRectIncludingScrollbar() const { return LayoutRect(borderLeft(), borderTop(), width() - borderLeft() - borderRight(), height() - borderTop() - borderBottom()); }
224 
225     // IE extensions. Used to calculate offsetWidth/Height.  Overridden by inlines (RenderFlow)
226     // to return the remaining width on a given line (and the height of a single line).
227     LayoutUnit offsetWidth() const override { return width(); }
228     LayoutUnit offsetHeight() const override { return height(); }
229 
230     // More IE extensions.  clientWidth and clientHeight represent the interior of an object
231     // excluding border and scrollbar.  clientLeft/Top are just the borderLeftWidth and borderTopWidth.
232     LayoutUnit clientLeft() const { return borderLeft(); }
233     LayoutUnit clientTop() const { return borderTop(); }
234     WEBCORE_EXPORT LayoutUnit clientWidth() const;
235     WEBCORE_EXPORT LayoutUnit clientHeight() const;
236     LayoutUnit clientLogicalWidth() const { return style().isHorizontalWritingMode() ? clientWidth() : clientHeight(); }
237     LayoutUnit clientLogicalHeight() const { return style().isHorizontalWritingMode() ? clientHeight() : clientWidth(); }
238     LayoutUnit clientLogicalBottom() const { return borderBefore() + clientLogicalHeight(); }
239     LayoutRect clientBoxRect() const { return LayoutRect(clientLeft(), clientTop(), clientWidth(), clientHeight()); }
240 
241     // scrollWidth/scrollHeight will be the same as clientWidth/clientHeight unless the
242     // object has overflow:hidden/scroll/auto specified and also has overflow.
243     // scrollLeft/Top return the current scroll position.  These methods are virtual so that objects like
244     // textareas can scroll shadow content (but pretend that they are the objects that are
245     // scrolling).
246     virtual int scrollLeft() const;
247     virtual int scrollTop() const;
248     virtual int scrollWidth() const;
249     virtual int scrollHeight() const;
<a name="4" id="anc4"></a><span class="line-modified">250     virtual void setScrollLeft(int, ScrollType, ScrollClamping = ScrollClamping::Clamped);</span>
<span class="line-modified">251     virtual void setScrollTop(int, ScrollType, ScrollClamping = ScrollClamping::Clamped);</span>
252 
253     LayoutUnit marginTop() const override { return m_marginBox.top(); }
254     LayoutUnit marginBottom() const override { return m_marginBox.bottom(); }
255     LayoutUnit marginLeft() const override { return m_marginBox.left(); }
256     LayoutUnit marginRight() const override { return m_marginBox.right(); }
257     void setMarginTop(LayoutUnit margin) { m_marginBox.setTop(margin); }
258     void setMarginBottom(LayoutUnit margin) { m_marginBox.setBottom(margin); }
259     void setMarginLeft(LayoutUnit margin) { m_marginBox.setLeft(margin); }
260     void setMarginRight(LayoutUnit margin) { m_marginBox.setRight(margin); }
261 
262     LayoutUnit marginLogicalLeft() const { return m_marginBox.start(style().writingMode()); }
263     LayoutUnit marginLogicalRight() const { return m_marginBox.end(style().writingMode()); }
264 
265     LayoutUnit marginBefore(const RenderStyle* overrideStyle = nullptr) const final { return m_marginBox.before((overrideStyle ? overrideStyle : &amp;style())-&gt;writingMode()); }
266     LayoutUnit marginAfter(const RenderStyle* overrideStyle = nullptr) const final { return m_marginBox.after((overrideStyle ? overrideStyle : &amp;style())-&gt;writingMode()); }
267     LayoutUnit marginStart(const RenderStyle* overrideStyle = nullptr) const final
268     {
269         const RenderStyle* styleToUse = overrideStyle ? overrideStyle : &amp;style();
270         return m_marginBox.start(styleToUse-&gt;writingMode(), styleToUse-&gt;direction());
271     }
272     LayoutUnit marginEnd(const RenderStyle* overrideStyle = nullptr) const final
273     {
274         const RenderStyle* styleToUse = overrideStyle ? overrideStyle : &amp;style();
275         return m_marginBox.end(styleToUse-&gt;writingMode(), styleToUse-&gt;direction());
276     }
277     void setMarginBefore(LayoutUnit value, const RenderStyle* overrideStyle = nullptr) { m_marginBox.setBefore(value, (overrideStyle ? overrideStyle : &amp;style())-&gt;writingMode()); }
278     void setMarginAfter(LayoutUnit value, const RenderStyle* overrideStyle = nullptr) { m_marginBox.setAfter(value, (overrideStyle ? overrideStyle : &amp;style())-&gt;writingMode()); }
279     void setMarginStart(LayoutUnit value, const RenderStyle* overrideStyle = nullptr)
280     {
281         const RenderStyle* styleToUse = overrideStyle ? overrideStyle : &amp;style();
282         m_marginBox.setStart(value, styleToUse-&gt;writingMode(), styleToUse-&gt;direction());
283     }
284     void setMarginEnd(LayoutUnit value, const RenderStyle* overrideStyle = nullptr)
285     {
286         const RenderStyle* styleToUse = overrideStyle ? overrideStyle : &amp;style();
287         m_marginBox.setEnd(value, styleToUse-&gt;writingMode(), styleToUse-&gt;direction());
288     }
289 
290     virtual bool isSelfCollapsingBlock() const { return false; }
291     virtual LayoutUnit collapsedMarginBefore() const { return marginBefore(); }
292     virtual LayoutUnit collapsedMarginAfter() const { return marginAfter(); }
293 
294     void absoluteRects(Vector&lt;IntRect&gt;&amp;, const LayoutPoint&amp; accumulatedOffset) const override;
295     void absoluteQuads(Vector&lt;FloatQuad&gt;&amp;, bool* wasFixed) const override;
296 
297     int reflectionOffset() const;
298     // Given a rect in the object&#39;s coordinate space, returns the corresponding rect in the reflection.
299     LayoutRect reflectedRect(const LayoutRect&amp;) const;
300 
301     void layout() override;
302     bool nodeAtPoint(const HitTestRequest&amp;, HitTestResult&amp;, const HitTestLocation&amp; locationInContainer, const LayoutPoint&amp; accumulatedOffset, HitTestAction) override;
303 
304     LayoutUnit minPreferredLogicalWidth() const override;
305     LayoutUnit maxPreferredLogicalWidth() const override;
306 
307     // FIXME: We should rename these back to overrideLogicalHeight/Width and have them store
308     // the border-box height/width like the regular height/width accessors on RenderBox.
309     // Right now, these are different than contentHeight/contentWidth because they still
310     // include the scrollbar height/width.
311     LayoutUnit overrideContentLogicalWidth() const;
312     LayoutUnit overrideContentLogicalHeight() const;
313     bool hasOverrideContentLogicalHeight() const;
314     bool hasOverrideContentLogicalWidth() const;
315     void setOverrideContentLogicalHeight(LayoutUnit);
316     void setOverrideContentLogicalWidth(LayoutUnit);
317     void clearOverrideContentSize();
318     void clearOverrideContentLogicalHeight();
319     void clearOverrideContentLogicalWidth();
320 
321     Optional&lt;LayoutUnit&gt; overrideContainingBlockContentWidth() const override;
322     Optional&lt;LayoutUnit&gt; overrideContainingBlockContentHeight() const override;
323     bool hasOverrideContainingBlockContentWidth() const override;
324     bool hasOverrideContainingBlockContentHeight() const override;
325     Optional&lt;LayoutUnit&gt; overrideContainingBlockContentLogicalWidth() const;
326     Optional&lt;LayoutUnit&gt; overrideContainingBlockContentLogicalHeight() const;
327     bool hasOverrideContainingBlockContentLogicalWidth() const;
328     bool hasOverrideContainingBlockContentLogicalHeight() const;
329     void setOverrideContainingBlockContentLogicalWidth(Optional&lt;LayoutUnit&gt;);
330     void setOverrideContainingBlockContentLogicalHeight(Optional&lt;LayoutUnit&gt;);
331     void clearOverrideContainingBlockContentSize();
332     void clearOverrideContainingBlockContentLogicalHeight();
333 
334     LayoutSize offsetFromContainer(RenderElement&amp;, const LayoutPoint&amp;, bool* offsetDependsOnPoint = nullptr) const override;
335 
336     LayoutUnit adjustBorderBoxLogicalWidthForBoxSizing(LayoutUnit width) const;
337     LayoutUnit adjustContentBoxLogicalWidthForBoxSizing(LayoutUnit width) const;
338 
<a name="5" id="anc5"></a><span class="line-added">339     template&lt;typename T&gt; LayoutUnit adjustBorderBoxLogicalWidthForBoxSizing(T width) const { return adjustBorderBoxLogicalWidthForBoxSizing(LayoutUnit(width)); }</span>
<span class="line-added">340     template&lt;typename T&gt; LayoutUnit adjustContentBoxLogicalWidthForBoxSizing(T width) const { return adjustContentBoxLogicalWidthForBoxSizing(LayoutUnit(width)); }</span>
<span class="line-added">341 </span>
342     // Overridden by fieldsets to subtract out the intrinsic border.
343     virtual LayoutUnit adjustBorderBoxLogicalHeightForBoxSizing(LayoutUnit height) const;
344     virtual LayoutUnit adjustContentBoxLogicalHeightForBoxSizing(Optional&lt;LayoutUnit&gt; height) const;
345 
346     struct ComputedMarginValues {
347         LayoutUnit m_before;
348         LayoutUnit m_after;
349         LayoutUnit m_start;
350         LayoutUnit m_end;
351     };
352     struct LogicalExtentComputedValues {
353         LayoutUnit m_extent;
354         LayoutUnit m_position;
355         ComputedMarginValues m_margins;
356     };
357     // Resolve auto margins in the inline direction of the containing block so that objects can be pushed to the start, middle or end
358     // of the containing block.
359     void computeInlineDirectionMargins(const RenderBlock&amp; containingBlock, LayoutUnit containerWidth, LayoutUnit childWidth, LayoutUnit&amp; marginStart, LayoutUnit&amp; marginEnd) const;
360 
361     // Used to resolve margins in the containing block&#39;s block-flow direction.
362     void computeBlockDirectionMargins(const RenderBlock&amp; containingBlock, LayoutUnit&amp; marginBefore, LayoutUnit&amp; marginAfter) const;
363     void computeAndSetBlockDirectionMargins(const RenderBlock&amp; containingBlock);
364 
365     enum RenderBoxFragmentInfoFlags { CacheRenderBoxFragmentInfo, DoNotCacheRenderBoxFragmentInfo };
366     LayoutRect borderBoxRectInFragment(RenderFragmentContainer*, RenderBoxFragmentInfoFlags = CacheRenderBoxFragmentInfo) const;
367     LayoutRect clientBoxRectInFragment(RenderFragmentContainer*) const;
368     RenderFragmentContainer* clampToStartAndEndFragments(RenderFragmentContainer*) const;
369     bool hasFragmentRangeInFragmentedFlow() const;
370     virtual LayoutUnit offsetFromLogicalTopOfFirstPage() const;
371 
372     void positionLineBox(InlineElementBox&amp;);
373 
374     virtual std::unique_ptr&lt;InlineElementBox&gt; createInlineBox();
375     void dirtyLineBoxes(bool fullLayout);
376 
377     // For inline replaced elements, this function returns the inline box that owns us.  Enables
378     // the replaced RenderObject to quickly determine what line it is contained on and to easily
379     // iterate over structures on the line.
380     InlineElementBox* inlineBoxWrapper() const { return m_inlineBoxWrapper; }
381     void setInlineBoxWrapper(InlineElementBox*);
382     void deleteLineBoxWrapper();
383 
384     LayoutRect clippedOverflowRectForRepaint(const RenderLayerModelObject* repaintContainer) const override;
385     Optional&lt;LayoutRect&gt; computeVisibleRectInContainer(const LayoutRect&amp;, const RenderLayerModelObject* container, VisibleRectContext) const
386 override;
387     void repaintDuringLayoutIfMoved(const LayoutRect&amp;);
388     virtual void repaintOverhangingFloats(bool paintAllDescendants);
389 
390     LayoutUnit containingBlockLogicalWidthForContent() const override;
391     LayoutUnit containingBlockLogicalHeightForContent(AvailableLogicalHeightType) const;
392     LayoutUnit containingBlockLogicalWidthForPositioned(const RenderBoxModelObject&amp; containingBlock, RenderFragmentContainer* = nullptr, bool checkForPerpendicularWritingMode = true) const;
393     LayoutUnit containingBlockLogicalHeightForPositioned(const RenderBoxModelObject&amp; containingBlock, bool checkForPerpendicularWritingMode = true) const;
394     LayoutUnit containingBlockLogicalWidthForContentInFragment(RenderFragmentContainer*) const;
395     LayoutUnit containingBlockAvailableLineWidthInFragment(RenderFragmentContainer*) const;
396     LayoutUnit perpendicularContainingBlockLogicalHeight() const;
397 
398     virtual void updateLogicalWidth();
399     virtual void updateLogicalHeight();
400     virtual LogicalExtentComputedValues computeLogicalHeight(LayoutUnit logicalHeight, LayoutUnit logicalTop) const;
401 
402     void cacheIntrinsicContentLogicalHeightForFlexItem(LayoutUnit) const;
403 
404     // This function will compute the logical border-box height, without laying
405     // out the box. This means that the result is only &quot;correct&quot; when the height
406     // is explicitly specified. This function exists so that intrinsic width
407     // calculations have a way to deal with children that have orthogonal writing modes.
408     // When there is no explicit height, this function assumes a content height of
409     // zero (and returns just border + padding).
410     LayoutUnit computeLogicalHeightWithoutLayout() const;
411 
412     RenderBoxFragmentInfo* renderBoxFragmentInfo(RenderFragmentContainer*, RenderBoxFragmentInfoFlags = CacheRenderBoxFragmentInfo) const;
413     void computeLogicalWidthInFragment(LogicalExtentComputedValues&amp;, RenderFragmentContainer* = nullptr) const;
414 
415     bool stretchesToViewport() const
416     {
417         return document().inQuirksMode() &amp;&amp; style().logicalHeight().isAuto() &amp;&amp; !isFloatingOrOutOfFlowPositioned() &amp;&amp; (isDocumentElementRenderer() || isBody()) &amp;&amp; !isInline();
418     }
419 
420     virtual LayoutSize intrinsicSize() const { return LayoutSize(); }
421     LayoutUnit intrinsicLogicalWidth() const { return style().isHorizontalWritingMode() ? intrinsicSize().width() : intrinsicSize().height(); }
422     LayoutUnit intrinsicLogicalHeight() const { return style().isHorizontalWritingMode() ? intrinsicSize().height() : intrinsicSize().width(); }
423 
424     // Whether or not the element shrinks to its intrinsic width (rather than filling the width
425     // of a containing block).  HTML4 buttons, &lt;select&gt;s, &lt;input&gt;s, legends, and floating/compact elements do this.
426     bool sizesLogicalWidthToFitContent(SizeType) const;
427 
428     bool hasStretchedLogicalWidth() const;
429     bool isStretchingColumnFlexItem() const;
430     bool columnFlexItemHasStretchAlignment() const;
431 
432     LayoutUnit shrinkLogicalWidthToAvoidFloats(LayoutUnit childMarginStart, LayoutUnit childMarginEnd, const RenderBlock&amp; cb, RenderFragmentContainer*) const;
433 
434     LayoutUnit computeLogicalWidthInFragmentUsing(SizeType, Length logicalWidth, LayoutUnit availableLogicalWidth, const RenderBlock&amp; containingBlock, RenderFragmentContainer*) const;
435     Optional&lt;LayoutUnit&gt; computeLogicalHeightUsing(SizeType, const Length&amp; height, Optional&lt;LayoutUnit&gt; intrinsicContentHeight) const;
436     Optional&lt;LayoutUnit&gt; computeContentLogicalHeight(SizeType, const Length&amp; height, Optional&lt;LayoutUnit&gt; intrinsicContentHeight) const;
437     Optional&lt;LayoutUnit&gt; computeContentAndScrollbarLogicalHeightUsing(SizeType, const Length&amp; height, Optional&lt;LayoutUnit&gt; intrinsicContentHeight) const;
438     LayoutUnit computeReplacedLogicalWidthUsing(SizeType, Length width) const;
439     LayoutUnit computeReplacedLogicalWidthRespectingMinMaxWidth(LayoutUnit logicalWidth, ShouldComputePreferred  = ComputeActual) const;
440     LayoutUnit computeReplacedLogicalHeightUsing(SizeType, Length height) const;
441     LayoutUnit computeReplacedLogicalHeightRespectingMinMaxHeight(LayoutUnit logicalHeight) const;
442 
<a name="6" id="anc6"></a><span class="line-added">443     template&lt;typename T&gt; LayoutUnit computeReplacedLogicalWidthRespectingMinMaxWidth(T logicalWidth, ShouldComputePreferred shouldComputePreferred = ComputeActual) const { return computeReplacedLogicalWidthRespectingMinMaxWidth(LayoutUnit(logicalWidth), shouldComputePreferred); }</span>
<span class="line-added">444     template&lt;typename T&gt; LayoutUnit computeReplacedLogicalHeightRespectingMinMaxHeight(T logicalHeight) const { return computeReplacedLogicalHeightRespectingMinMaxHeight(LayoutUnit(logicalHeight)); }</span>
<span class="line-added">445 </span>
446     virtual LayoutUnit computeReplacedLogicalWidth(ShouldComputePreferred  = ComputeActual) const;
447     virtual LayoutUnit computeReplacedLogicalHeight(Optional&lt;LayoutUnit&gt; estimatedUsedWidth = WTF::nullopt) const;
448 
449     Optional&lt;LayoutUnit&gt; computePercentageLogicalHeight(const Length&amp; height) const;
450 
451     virtual LayoutUnit availableLogicalWidth() const { return contentLogicalWidth(); }
452     virtual LayoutUnit availableLogicalHeight(AvailableLogicalHeightType) const;
453     LayoutUnit availableLogicalHeightUsing(const Length&amp;, AvailableLogicalHeightType) const;
454 
455     // There are a few cases where we need to refer specifically to the available physical width and available physical height.
456     // Relative positioning is one of those cases, since left/top offsets are physical.
457     LayoutUnit availableWidth() const { return style().isHorizontalWritingMode() ? availableLogicalWidth() : availableLogicalHeight(IncludeMarginBorderPadding); }
458     LayoutUnit availableHeight() const { return style().isHorizontalWritingMode() ? availableLogicalHeight(IncludeMarginBorderPadding) : availableLogicalWidth(); }
459 
460     WEBCORE_EXPORT virtual int verticalScrollbarWidth() const;
461     WEBCORE_EXPORT int horizontalScrollbarHeight() const;
462     int intrinsicScrollbarLogicalWidth() const;
463     int scrollbarLogicalWidth() const { return style().isHorizontalWritingMode() ? verticalScrollbarWidth() : horizontalScrollbarHeight(); }
464     int scrollbarLogicalHeight() const { return style().isHorizontalWritingMode() ? horizontalScrollbarHeight() : verticalScrollbarWidth(); }
465     virtual bool scroll(ScrollDirection, ScrollGranularity, float multiplier = 1, Element** stopElement = nullptr, RenderBox* startBox = nullptr, const IntPoint&amp; wheelEventAbsolutePoint = IntPoint());
466     virtual bool logicalScroll(ScrollLogicalDirection, ScrollGranularity, float multiplier = 1, Element** stopElement = nullptr);
467     WEBCORE_EXPORT bool canBeScrolledAndHasScrollableArea() const;
468     virtual bool canBeProgramaticallyScrolled() const;
469     virtual void autoscroll(const IntPoint&amp;);
470     bool canAutoscroll() const;
471     IntSize calculateAutoscrollDirection(const IntPoint&amp; windowPoint) const;
472     static RenderBox* findAutoscrollable(RenderObject*);
473     virtual void stopAutoscroll() { }
474     virtual void panScroll(const IntPoint&amp;);
475 
476     bool hasVerticalScrollbarWithAutoBehavior() const;
477     bool hasHorizontalScrollbarWithAutoBehavior() const;
478 
479     bool canUseOverlayScrollbars() const;
480 
481     bool scrollsOverflow() const { return scrollsOverflowX() || scrollsOverflowY(); }
482     bool scrollsOverflowX() const { return hasOverflowClip() &amp;&amp; (style().overflowX() == Overflow::Scroll || style().overflowX() == Overflow::Auto); }
483     bool scrollsOverflowY() const { return hasOverflowClip() &amp;&amp; (style().overflowY() == Overflow::Scroll || style().overflowY() == Overflow::Auto); }
484 
485     bool hasHorizontalOverflow() const { return scrollWidth() != roundToInt(paddingBoxWidth()); }
486     bool hasVerticalOverflow() const { return scrollHeight() != roundToInt(paddingBoxHeight()); }
487 
488     bool hasScrollableOverflowX() const { return scrollsOverflowX() &amp;&amp; hasHorizontalOverflow(); }
489     bool hasScrollableOverflowY() const { return scrollsOverflowY() &amp;&amp; hasVerticalOverflow(); }
490 
491     bool usesCompositedScrolling() const;
492 
493     bool percentageLogicalHeightIsResolvable() const;
494     bool hasUnsplittableScrollingOverflow() const;
495     bool isUnsplittableForPagination() const;
496 
497     bool shouldTreatChildAsReplacedInTableCells() const;
498 
499     LayoutRect localCaretRect(InlineBox*, unsigned caretOffset, LayoutUnit* extraWidthToEndOfLine = nullptr) override;
500 
501     virtual LayoutRect overflowClipRect(const LayoutPoint&amp; location, RenderFragmentContainer* = nullptr, OverlayScrollbarSizeRelevancy = IgnoreOverlayScrollbarSize, PaintPhase = PaintPhase::BlockBackground);
502     virtual LayoutRect overflowClipRectForChildLayers(const LayoutPoint&amp; location, RenderFragmentContainer* fragment, OverlayScrollbarSizeRelevancy relevancy) { return overflowClipRect(location, fragment, relevancy); }
503     LayoutRect clipRect(const LayoutPoint&amp; location, RenderFragmentContainer*);
504     virtual bool hasControlClip() const { return false; }
505     virtual LayoutRect controlClipRect(const LayoutPoint&amp;) const { return LayoutRect(); }
506     bool pushContentsClip(PaintInfo&amp;, const LayoutPoint&amp; accumulatedOffset);
507     void popContentsClip(PaintInfo&amp;, PaintPhase originalPhase, const LayoutPoint&amp; accumulatedOffset);
508 
509     virtual void paintObject(PaintInfo&amp;, const LayoutPoint&amp;) { ASSERT_NOT_REACHED(); }
510     virtual void paintBoxDecorations(PaintInfo&amp;, const LayoutPoint&amp;);
511     virtual void paintMask(PaintInfo&amp;, const LayoutPoint&amp;);
512     virtual void paintClippingMask(PaintInfo&amp;, const LayoutPoint&amp;);
513     void imageChanged(WrappedImagePtr, const IntRect* = nullptr) override;
514 
515     // Called when a positioned object moves but doesn&#39;t necessarily change size.  A simplified layout is attempted
516     // that just updates the object&#39;s position. If the size does change, the object remains dirty.
517     bool tryLayoutDoingPositionedMovementOnly()
518     {
519         LayoutUnit oldWidth = width();
520         updateLogicalWidth();
521         // If we shrink to fit our width may have changed, so we still need full layout.
522         if (oldWidth != width())
523             return false;
524         updateLogicalHeight();
525         return true;
526     }
527 
528     LayoutRect maskClipRect(const LayoutPoint&amp; paintOffset);
529 
530     VisiblePosition positionForPoint(const LayoutPoint&amp;, const RenderFragmentContainer*) override;
531 
532     void removeFloatingOrPositionedChildFromBlockLists();
533 
534     RenderLayer* enclosingFloatPaintingLayer() const;
535 
536     virtual Optional&lt;int&gt; firstLineBaseline() const { return Optional&lt;int&gt;(); }
537     virtual Optional&lt;int&gt; inlineBlockBaseline(LineDirectionMode) const { return Optional&lt;int&gt;(); } // Returns empty if we should skip this box when computing the baseline of an inline-block.
538 
539     bool shrinkToAvoidFloats() const;
540     virtual bool avoidsFloats() const;
541 
542     virtual void markForPaginationRelayoutIfNeeded() { }
543 
544     bool isWritingModeRoot() const { return !parent() || parent()-&gt;style().writingMode() != style().writingMode(); }
545 
546     bool isDeprecatedFlexItem() const { return !isInline() &amp;&amp; !isFloatingOrOutOfFlowPositioned() &amp;&amp; parent() &amp;&amp; parent()-&gt;isDeprecatedFlexibleBox(); }
547     bool isFlexItemIncludingDeprecated() const { return !isInline() &amp;&amp; !isFloatingOrOutOfFlowPositioned() &amp;&amp; parent() &amp;&amp; parent()-&gt;isFlexibleBoxIncludingDeprecated(); }
548 
549     LayoutUnit lineHeight(bool firstLine, LineDirectionMode, LinePositionMode = PositionOnContainingLine) const override;
550     int baselinePosition(FontBaseline, bool firstLine, LineDirectionMode, LinePositionMode = PositionOnContainingLine) const override;
551 
552     LayoutUnit offsetLeft() const override;
553     LayoutUnit offsetTop() const override;
554 
555     LayoutPoint flipForWritingModeForChild(const RenderBox* child, const LayoutPoint&amp;) const;
556     LayoutUnit flipForWritingMode(LayoutUnit position) const; // The offset is in the block direction (y for horizontal writing modes, x for vertical writing modes).
557     LayoutPoint flipForWritingMode(const LayoutPoint&amp;) const;
558     LayoutSize flipForWritingMode(const LayoutSize&amp;) const;
559     void flipForWritingMode(LayoutRect&amp;) const;
560     FloatPoint flipForWritingMode(const FloatPoint&amp;) const;
561     void flipForWritingMode(FloatRect&amp;) const;
562     // These represent your location relative to your container as a physical offset.
563     // In layout related methods you almost always want the logical location (e.g. x() and y()).
564     LayoutPoint topLeftLocation() const;
565     LayoutSize topLeftLocationOffset() const;
566     void applyTopLeftLocationOffset(LayoutPoint&amp; point) const
567     {
568         // This is inlined for speed, since it is used by updateLayerPosition() during scrolling.
569         if (!document().view()-&gt;hasFlippedBlockRenderers())
570             point.move(m_frameRect.x(), m_frameRect.y());
571         else
572             applyTopLeftLocationOffsetWithFlipping(point);
573     }
574 
575     LayoutRect logicalVisualOverflowRectForPropagation(const RenderStyle*) const;
576     LayoutRect visualOverflowRectForPropagation(const RenderStyle*) const;
577     LayoutRect logicalLayoutOverflowRectForPropagation(const RenderStyle*) const;
578     LayoutRect layoutOverflowRectForPropagation(const RenderStyle*) const;
579 
580     bool hasRenderOverflow() const { return m_overflow; }
581     bool hasVisualOverflow() const { return m_overflow &amp;&amp; !borderBoxRect().contains(m_overflow-&gt;visualOverflowRect()); }
582 
583     virtual bool needsPreferredWidthsRecalculation() const;
584     virtual void computeIntrinsicRatioInformation(FloatSize&amp; /* intrinsicSize */, double&amp; /* intrinsicRatio */) const { }
585 
586     ScrollPosition scrollPosition() const;
587     LayoutSize cachedSizeForOverflowClip() const;
588 
589     // Returns false if the rect has no intersection with the applied clip rect. When the context specifies edge-inclusive
590     // intersection, this return value allows distinguishing between no intersection and zero-area intersection.
591     bool applyCachedClipAndScrollPosition(LayoutRect&amp;, const RenderLayerModelObject* container, VisibleRectContext) const;
592 
593     virtual bool hasRelativeDimensions() const;
594     virtual bool hasRelativeLogicalHeight() const;
595     virtual bool hasRelativeLogicalWidth() const;
596 
597     bool hasHorizontalLayoutOverflow() const
598     {
599         if (!m_overflow)
600             return false;
601 
602         LayoutRect layoutOverflowRect = m_overflow-&gt;layoutOverflowRect();
603         flipForWritingMode(layoutOverflowRect);
604         return layoutOverflowRect.x() &lt; x() || layoutOverflowRect.maxX() &gt; x() + logicalWidth();
605     }
606 
607     bool hasVerticalLayoutOverflow() const
608     {
609         if (!m_overflow)
610             return false;
611 
612         LayoutRect layoutOverflowRect = m_overflow-&gt;layoutOverflowRect();
613         flipForWritingMode(layoutOverflowRect);
614         return layoutOverflowRect.y() &lt; y() || layoutOverflowRect.maxY() &gt; y() + logicalHeight();
615     }
616 
617     virtual RenderPtr&lt;RenderBox&gt; createAnonymousBoxWithSameTypeAs(const RenderBox&amp;) const
618     {
619         ASSERT_NOT_REACHED();
620         return nullptr;
621     }
622 
623     ShapeOutsideInfo* shapeOutsideInfo() const
624     {
625         return ShapeOutsideInfo::isEnabledFor(*this) ? ShapeOutsideInfo::info(*this) : nullptr;
626     }
627 
628     void markShapeOutsideDependentsForLayout()
629     {
630         if (isFloating())
631             removeFloatingOrPositionedChildFromBlockLists();
632     }
633 
634     // True if this box can have a range in an outside fragmentation context.
635     bool canHaveOutsideFragmentRange() const { return !isInFlowRenderFragmentedFlow(); }
636     virtual bool needsLayoutAfterFragmentRangeChange() const { return false; }
637 
638     const RenderBox* findEnclosingScrollableContainer() const;
639 
640     bool isGridItem() const { return parent() &amp;&amp; parent()-&gt;isRenderGrid() &amp;&amp; !isExcludedFromNormalLayout(); }
641     bool isFlexItem() const { return parent() &amp;&amp; parent()-&gt;isFlexibleBox() &amp;&amp; !isExcludedFromNormalLayout(); }
642 
643     virtual void adjustBorderBoxRectForPainting(LayoutRect&amp;) { };
644 
645 protected:
646     RenderBox(Element&amp;, RenderStyle&amp;&amp;, BaseTypeFlags);
647     RenderBox(Document&amp;, RenderStyle&amp;&amp;, BaseTypeFlags);
648 
649     void styleWillChange(StyleDifference, const RenderStyle&amp; newStyle) override;
650     void styleDidChange(StyleDifference, const RenderStyle* oldStyle) override;
651     void updateFromStyle() override;
652 
653     void willBeDestroyed() override;
654 
655     bool createsNewFormattingContext() const;
656 
657     virtual ItemPosition selfAlignmentNormalBehavior(const RenderBox* = nullptr) const { return ItemPosition::Stretch; }
658 
659     // Returns false if it could not cheaply compute the extent (e.g. fixed background), in which case the returned rect may be incorrect.
660     bool getBackgroundPaintedExtent(const LayoutPoint&amp; paintOffset, LayoutRect&amp;) const;
661     virtual bool foregroundIsKnownToBeOpaqueInRect(const LayoutRect&amp; localRect, unsigned maxDepthToTest) const;
662     bool computeBackgroundIsKnownToBeObscured(const LayoutPoint&amp; paintOffset) override;
663 
664     void paintBackground(const PaintInfo&amp;, const LayoutRect&amp;, BackgroundBleedAvoidance = BackgroundBleedNone);
665 
666     void paintFillLayer(const PaintInfo&amp;, const Color&amp;, const FillLayer&amp;, const LayoutRect&amp;, BackgroundBleedAvoidance, CompositeOperator, RenderElement* backgroundObject, BaseBackgroundColorUsage = BaseBackgroundColorUse);
667     void paintFillLayers(const PaintInfo&amp;, const Color&amp;, const FillLayer&amp;, const LayoutRect&amp;, BackgroundBleedAvoidance = BackgroundBleedNone, CompositeOperator = CompositeSourceOver, RenderElement* backgroundObject = nullptr);
668 
669     void paintMaskImages(const PaintInfo&amp;, const LayoutRect&amp;);
670 
671     BackgroundBleedAvoidance determineBackgroundBleedAvoidance(GraphicsContext&amp;) const;
672     bool backgroundHasOpaqueTopLayer() const;
673 
674     void computePositionedLogicalWidth(LogicalExtentComputedValues&amp;, RenderFragmentContainer* = nullptr) const;
675 
676     LayoutUnit computeIntrinsicLogicalWidthUsing(Length logicalWidthLength, LayoutUnit availableLogicalWidth, LayoutUnit borderAndPadding) const;
677     virtual Optional&lt;LayoutUnit&gt; computeIntrinsicLogicalContentHeightUsing(Length logicalHeightLength, Optional&lt;LayoutUnit&gt; intrinsicContentHeight, LayoutUnit borderAndPadding) const;
678 
679     virtual bool shouldComputeSizeAsReplaced() const { return isReplaced() &amp;&amp; !isInlineBlockOrInlineTable(); }
680 
681     void mapLocalToContainer(const RenderLayerModelObject* repaintContainer, TransformState&amp;, MapCoordinatesFlags, bool* wasFixed) const override;
682     const RenderObject* pushMappingToContainer(const RenderLayerModelObject*, RenderGeometryMap&amp;) const override;
683     void mapAbsoluteToLocalPoint(MapCoordinatesFlags, TransformState&amp;) const override;
684 
685     void paintRootBoxFillLayers(const PaintInfo&amp;);
686 
687     bool skipContainingBlockForPercentHeightCalculation(const RenderBox&amp; containingBlock, bool isPerpendicularWritingMode) const;
688 
689 private:
690     bool replacedMinMaxLogicalHeightComputesAsNone(SizeType) const;
691 
692     void updateShapeOutsideInfoAfterStyleChange(const RenderStyle&amp;, const RenderStyle* oldStyle);
693 
694     void updateGridPositionAfterStyleChange(const RenderStyle&amp;, const RenderStyle* oldStyle);
695 
696     bool scrollLayer(ScrollDirection, ScrollGranularity, float multiplier, Element** stopElement);
697 
698     bool fixedElementLaysOutRelativeToFrame(const FrameView&amp;) const;
699 
700     bool includeVerticalScrollbarSize() const;
701     bool includeHorizontalScrollbarSize() const;
702 
703     bool isScrollableOrRubberbandableBox() const override;
704 
705     // Returns true if we did a full repaint.
706     bool repaintLayerRectsForImage(WrappedImagePtr, const FillLayer&amp; layers, bool drawingBackground);
707 
708     void computePositionedLogicalHeight(LogicalExtentComputedValues&amp;) const;
709     void computePositionedLogicalWidthUsing(SizeType, Length logicalWidth, const RenderBoxModelObject&amp; containerBlock, TextDirection containerDirection,
710                                             LayoutUnit containerLogicalWidth, LayoutUnit bordersPlusPadding,
711                                             Length logicalLeft, Length logicalRight, Length marginLogicalLeft, Length marginLogicalRight,
712                                             LogicalExtentComputedValues&amp;) const;
713     void computePositionedLogicalHeightUsing(SizeType, Length logicalHeightLength, const RenderBoxModelObject&amp; containerBlock,
714                                              LayoutUnit containerLogicalHeight, LayoutUnit bordersPlusPadding, LayoutUnit logicalHeight,
715                                              Length logicalTop, Length logicalBottom, Length marginLogicalTop, Length marginLogicalBottom,
716                                              LogicalExtentComputedValues&amp;) const;
717 
718     void computePositionedLogicalHeightReplaced(LogicalExtentComputedValues&amp;) const;
719     void computePositionedLogicalWidthReplaced(LogicalExtentComputedValues&amp;) const;
720 
721     LayoutUnit fillAvailableMeasure(LayoutUnit availableLogicalWidth) const;
722     LayoutUnit fillAvailableMeasure(LayoutUnit availableLogicalWidth, LayoutUnit&amp; marginStart, LayoutUnit&amp; marginEnd) const;
723 
724     virtual void computeIntrinsicLogicalWidths(LayoutUnit&amp; minLogicalWidth, LayoutUnit&amp; maxLogicalWidth) const;
725 
726     // This function calculates the minimum and maximum preferred widths for an object.
727     // These values are used in shrink-to-fit layout systems.
728     // These include tables, positioned objects, floats and flexible boxes.
729     virtual void computePreferredLogicalWidths() { setPreferredLogicalWidthsDirty(false); }
730 
731     LayoutRect frameRectForStickyPositioning() const final { return frameRect(); }
732 
733     LayoutRect computeVisibleRectUsingPaintOffset(const LayoutRect&amp;) const;
734 
735     void applyTopLeftLocationOffsetWithFlipping(LayoutPoint&amp;) const;
736 
737 private:
738     // The width/height of the contents + borders + padding.  The x/y location is relative to our container (which is not always our parent).
739     LayoutRect m_frameRect;
740 
741 protected:
742     LayoutBoxExtent m_marginBox;
743 
744     // The preferred logical width of the element if it were to break its lines at every possible opportunity.
745     LayoutUnit m_minPreferredLogicalWidth;
746 
747     // The preferred logical width of the element if it never breaks any lines at all.
748     LayoutUnit m_maxPreferredLogicalWidth;
749 
750     // For inline replaced elements, the inline box that owns us.
751     InlineElementBox* m_inlineBoxWrapper { nullptr };
752 
753     // Our overflow information.
754     RefPtr&lt;RenderOverflow&gt; m_overflow;
755 
756 private:
757     // Used to store state between styleWillChange and styleDidChange
758     static bool s_hadOverflowClip;
759 };
760 
761 inline RenderBox* RenderBox::parentBox() const
762 {
763     if (is&lt;RenderBox&gt;(parent()))
764         return downcast&lt;RenderBox&gt;(parent());
765 
766     ASSERT(!parent());
767     return nullptr;
768 }
769 
770 inline RenderBox* RenderBox::firstChildBox() const
771 {
772     if (is&lt;RenderBox&gt;(firstChild()))
773         return downcast&lt;RenderBox&gt;(firstChild());
774 
775     ASSERT(!firstChild());
776     return nullptr;
777 }
778 
779 inline RenderBox* RenderBox::lastChildBox() const
780 {
781     if (is&lt;RenderBox&gt;(lastChild()))
782         return downcast&lt;RenderBox&gt;(lastChild());
783 
784     ASSERT(!lastChild());
785     return nullptr;
786 }
787 
788 inline RenderBox* RenderBox::previousSiblingBox() const
789 {
790     if (is&lt;RenderBox&gt;(previousSibling()))
791         return downcast&lt;RenderBox&gt;(previousSibling());
792 
793     ASSERT(!previousSibling());
794     return nullptr;
795 }
796 
797 inline RenderBox* RenderBox::nextSiblingBox() const
798 {
799     if (is&lt;RenderBox&gt;(nextSibling()))
800         return downcast&lt;RenderBox&gt;(nextSibling());
801 
802     ASSERT(!nextSibling());
803     return nullptr;
804 }
805 
806 inline void RenderBox::setInlineBoxWrapper(InlineElementBox* boxWrapper)
807 {
808     if (boxWrapper) {
809         ASSERT(!m_inlineBoxWrapper);
810         // m_inlineBoxWrapper should already be 0. Deleting it is a safeguard against security issues.
811         // Otherwise, there will two line box wrappers keeping the reference to this renderer, and
812         // only one will be notified when the renderer is getting destroyed. The second line box wrapper
813         // will keep a stale reference.
814         if (UNLIKELY(m_inlineBoxWrapper != nullptr))
815             deleteLineBoxWrapper();
816     }
817 
818     m_inlineBoxWrapper = boxWrapper;
819 }
820 
821 } // namespace WebCore
822 
823 SPECIALIZE_TYPE_TRAITS_RENDER_OBJECT(RenderBox, isBox())
<a name="7" id="anc7"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="7" type="hidden" />
</body>
</html>