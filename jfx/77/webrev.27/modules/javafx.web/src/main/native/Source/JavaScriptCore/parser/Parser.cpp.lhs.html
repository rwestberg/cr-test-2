<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/JavaScriptCore/parser/Parser.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  *  Copyright (C) 1999-2001 Harri Porten (porten@kde.org)
   3  *  Copyright (C) 2001 Peter Kelly (pmk@post.com)
   4  *  Copyright (C) 2003-2019 Apple Inc. All rights reserved.
   5  *
   6  *  This library is free software; you can redistribute it and/or
   7  *  modify it under the terms of the GNU Library General Public
   8  *  License as published by the Free Software Foundation; either
   9  *  version 2 of the License, or (at your option) any later version.
  10  *
  11  *  This library is distributed in the hope that it will be useful,
  12  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  13  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  14  *  Library General Public License for more details.
  15  *
  16  *  You should have received a copy of the GNU Library General Public License
  17  *  along with this library; see the file COPYING.LIB.  If not, write to
  18  *  the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  19  *  Boston, MA 02110-1301, USA.
  20  *
  21  */
  22 
  23 #include &quot;config.h&quot;
  24 #include &quot;Parser.h&quot;
  25 
  26 #include &quot;ASTBuilder.h&quot;
  27 #include &quot;BuiltinNames.h&quot;
  28 #include &quot;DebuggerParseData.h&quot;
  29 #include &quot;JSCInlines.h&quot;
  30 #include &quot;VM.h&quot;
  31 #include &lt;utility&gt;
  32 #include &lt;wtf/SetForScope.h&gt;
  33 #include &lt;wtf/StringPrintStream.h&gt;
  34 
  35 #define updateErrorMessage(shouldPrintToken, ...) do {\
  36     propagateError(); \
  37     logError(shouldPrintToken, __VA_ARGS__); \
  38 } while (0)
  39 
  40 #define propagateError() do { if (UNLIKELY(hasError())) return 0; } while (0)
  41 #define internalFailWithMessage(shouldPrintToken, ...) do { updateErrorMessage(shouldPrintToken, __VA_ARGS__); return 0; } while (0)
  42 #define handleErrorToken() do { if (m_token.m_type == EOFTOK || m_token.m_type &amp; ErrorTokenFlag) { failDueToUnexpectedToken(); } } while (0)
  43 #define failWithMessage(...) do { { handleErrorToken(); updateErrorMessage(true, __VA_ARGS__); } return 0; } while (0)
  44 #define failWithStackOverflow() do { updateErrorMessage(false, &quot;Stack exhausted&quot;); m_hasStackOverflow = true; return 0; } while (0)
  45 #define failIfFalse(cond, ...) do { if (!(cond)) { handleErrorToken(); internalFailWithMessage(true, __VA_ARGS__); } } while (0)
  46 #define failIfTrue(cond, ...) do { if (cond) { handleErrorToken(); internalFailWithMessage(true, __VA_ARGS__); } } while (0)
  47 #define failIfTrueIfStrict(cond, ...) do { if ((cond) &amp;&amp; strictMode()) internalFailWithMessage(false, __VA_ARGS__); } while (0)
  48 #define failIfFalseIfStrict(cond, ...) do { if ((!(cond)) &amp;&amp; strictMode()) internalFailWithMessage(false, __VA_ARGS__); } while (0)
  49 #define consumeOrFail(tokenType, ...) do { if (!consume(tokenType)) { handleErrorToken(); internalFailWithMessage(true, __VA_ARGS__); } } while (0)
  50 #define consumeOrFailWithFlags(tokenType, flags, ...) do { if (!consume(tokenType, flags)) { handleErrorToken(); internalFailWithMessage(true, __VA_ARGS__); } } while (0)
  51 #define matchOrFail(tokenType, ...) do { if (!match(tokenType)) { handleErrorToken(); internalFailWithMessage(true, __VA_ARGS__); } } while (0)
  52 #define failIfStackOverflow() do { if (UNLIKELY(!canRecurse())) failWithStackOverflow(); } while (0)
  53 #define semanticFail(...) do { internalFailWithMessage(false, __VA_ARGS__); } while (0)
  54 #define semanticFailIfTrue(cond, ...) do { if (UNLIKELY(cond)) internalFailWithMessage(false, __VA_ARGS__); } while (0)
  55 #define semanticFailIfFalse(cond, ...) do { if (UNLIKELY(!(cond))) internalFailWithMessage(false, __VA_ARGS__); } while (0)
  56 #define regexFail(failure) do { setErrorMessage(failure); return 0; } while (0)
  57 #define failDueToUnexpectedToken() do {\
  58         logError(true);\
  59     return 0;\
  60 } while (0)
  61 
  62 #define handleProductionOrFail(token, tokenString, operation, production) do {\
  63     consumeOrFail(token, &quot;Expected &#39;&quot;, tokenString, &quot;&#39; to &quot;, operation, &quot; a &quot;, production);\
  64 } while (0)
  65 
  66 #define handleProductionOrFail2(token, tokenString, operation, production) do {\
  67     consumeOrFail(token, &quot;Expected &#39;&quot;, tokenString, &quot;&#39; to &quot;, operation, &quot; an &quot;, production);\
  68 } while (0)
  69 
  70 #define semanticFailureDueToKeywordCheckingToken(token, ...) do { \
  71     if (strictMode() &amp;&amp; token.m_type == RESERVED_IF_STRICT) \
  72         semanticFail(&quot;Cannot use the reserved word &#39;&quot;, getToken(token), &quot;&#39; as a &quot;, __VA_ARGS__, &quot; in strict mode&quot;); \
  73     if (token.m_type == RESERVED || token.m_type == RESERVED_IF_STRICT) \
  74         semanticFail(&quot;Cannot use the reserved word &#39;&quot;, getToken(token), &quot;&#39; as a &quot;, __VA_ARGS__); \
  75     if (token.m_type &amp; KeywordTokenFlag) { \
  76         if (!isAnyContextualKeyword(token)) \
  77             semanticFail(&quot;Cannot use the keyword &#39;&quot;, getToken(token), &quot;&#39; as a &quot;, __VA_ARGS__); \
  78         if (isDisallowedIdentifierLet(token)) \
  79             semanticFail(&quot;Cannot use &#39;let&#39; as a &quot;, __VA_ARGS__, &quot; &quot;, disallowedIdentifierLetReason()); \
  80         if (isDisallowedIdentifierAwait(token)) \
  81             semanticFail(&quot;Cannot use &#39;await&#39; as a &quot;, __VA_ARGS__, &quot; &quot;, disallowedIdentifierAwaitReason()); \
  82         if (isDisallowedIdentifierYield(token)) \
  83             semanticFail(&quot;Cannot use &#39;yield&#39; as a &quot;, __VA_ARGS__, &quot; &quot;, disallowedIdentifierYieldReason()); \
  84     } \
  85 } while (0)
  86 
  87 #define semanticFailureDueToKeyword(...) semanticFailureDueToKeywordCheckingToken(m_token, __VA_ARGS__);
  88 
  89 namespace JSC {
  90 
<a name="1" id="anc1"></a>

  91 ALWAYS_INLINE static SourceParseMode getAsynFunctionBodyParseMode(SourceParseMode parseMode)
  92 {
  93     if (isAsyncGeneratorWrapperParseMode(parseMode))
  94         return SourceParseMode::AsyncGeneratorBodyMode;
  95 
  96     if (parseMode == SourceParseMode::AsyncArrowFunctionMode)
  97         return SourceParseMode::AsyncArrowFunctionBodyMode;
  98 
  99     return SourceParseMode::AsyncFunctionBodyMode;
 100 }
 101 
 102 template &lt;typename LexerType&gt;
 103 void Parser&lt;LexerType&gt;::logError(bool)
 104 {
 105     if (hasError())
 106         return;
 107     StringPrintStream stream;
 108     printUnexpectedTokenText(stream);
 109     setErrorMessage(stream.toStringWithLatin1Fallback());
 110 }
 111 
 112 template &lt;typename LexerType&gt; template &lt;typename... Args&gt;
 113 void Parser&lt;LexerType&gt;::logError(bool shouldPrintToken, Args&amp;&amp;... args)
 114 {
 115     if (hasError())
 116         return;
 117     StringPrintStream stream;
 118     if (shouldPrintToken) {
 119         printUnexpectedTokenText(stream);
 120         stream.print(&quot;. &quot;);
 121     }
 122     stream.print(std::forward&lt;Args&gt;(args)..., &quot;.&quot;);
 123     setErrorMessage(stream.toStringWithLatin1Fallback());
 124 }
 125 
 126 template &lt;typename LexerType&gt;
<a name="2" id="anc2"></a><span class="line-modified"> 127 Parser&lt;LexerType&gt;::Parser(VM* vm, const SourceCode&amp; source, JSParserBuiltinMode builtinMode, JSParserStrictMode strictMode, JSParserScriptMode scriptMode, SourceParseMode parseMode, SuperBinding superBinding, ConstructorKind defaultConstructorKind, DerivedContextType derivedContextType, bool isEvalContext, EvalContextType evalContextType, DebuggerParseData* debuggerParseData)</span>
 128     : m_vm(vm)
 129     , m_source(&amp;source)
 130     , m_hasStackOverflow(false)
 131     , m_allowsIn(true)
 132     , m_statementDepth(0)
 133     , m_sourceElements(0)
 134     , m_parsingBuiltin(builtinMode == JSParserBuiltinMode::Builtin)
 135     , m_scriptMode(scriptMode)
 136     , m_superBinding(superBinding)
 137     , m_defaultConstructorKind(defaultConstructorKind)
 138     , m_immediateParentAllowsFunctionDeclarationInStatement(false)
 139     , m_debuggerParseData(debuggerParseData)
 140 {
<a name="3" id="anc3"></a><span class="line-modified"> 141     m_lexer = std::make_unique&lt;LexerType&gt;(vm, builtinMode, scriptMode);</span>
 142     m_lexer-&gt;setCode(source, &amp;m_parserArena);
 143     m_token.m_location.line = source.firstLine().oneBasedInt();
 144     m_token.m_location.startOffset = source.startOffset();
 145     m_token.m_location.endOffset = source.startOffset();
 146     m_token.m_location.lineStartOffset = source.startOffset();
<a name="4" id="anc4"></a><span class="line-modified"> 147     m_functionCache = vm-&gt;addSourceProviderCache(source.provider());</span>
 148     m_expressionErrorClassifier = nullptr;
 149 
 150     ScopeRef scope = pushScope();
 151     scope-&gt;setSourceParseMode(parseMode);
 152     scope-&gt;setIsEvalContext(isEvalContext);
 153     if (isEvalContext)
 154         scope-&gt;setEvalContextType(evalContextType);
 155 
 156     if (derivedContextType == DerivedContextType::DerivedConstructorContext) {
 157         scope-&gt;setConstructorKind(ConstructorKind::Extends);
 158         scope-&gt;setExpectedSuperBinding(SuperBinding::Needed);
 159     }
 160 
 161     if (derivedContextType == DerivedContextType::DerivedMethodContext)
 162         scope-&gt;setExpectedSuperBinding(SuperBinding::Needed);
 163 
 164     if (strictMode == JSParserStrictMode::Strict)
 165         scope-&gt;setStrictMode();
 166 
 167     if (isModuleParseMode(parseMode))
 168         m_moduleScopeData = ModuleScopeData::create();
 169 
 170     if (isProgramOrModuleParseMode(parseMode))
 171         scope-&gt;setIsGlobalCodeScope();
 172 
 173     next();
 174 }
 175 
<a name="5" id="anc5"></a><span class="line-modified"> 176 class Scope::MaybeParseAsGeneratorForScope : public SetForScope&lt;bool&gt; {</span>
 177 public:
 178     MaybeParseAsGeneratorForScope(ScopeRef&amp; scope, bool shouldParseAsGenerator)
<a name="6" id="anc6"></a><span class="line-modified"> 179         : SetForScope&lt;bool&gt;(scope-&gt;m_isGenerator, shouldParseAsGenerator) { }</span>













 180 };
 181 
 182 struct DepthManager : private SetForScope&lt;int&gt; {
 183 public:
 184     DepthManager(int* depth)
 185         : SetForScope&lt;int&gt;(*depth, *depth)
 186     {
 187     }
 188 };
 189 
 190 template &lt;typename LexerType&gt;
 191 Parser&lt;LexerType&gt;::~Parser()
 192 {
 193 }
 194 
 195 template &lt;typename LexerType&gt;
 196 String Parser&lt;LexerType&gt;::parseInner(const Identifier&amp; calleeName, SourceParseMode parseMode, ParsingContext parsingContext, Optional&lt;int&gt; functionConstructorParametersEndPosition)
 197 {
 198     String parseError = String();
 199 
<a name="7" id="anc7"></a><span class="line-modified"> 200     ASTBuilder context(const_cast&lt;VM*&gt;(m_vm), m_parserArena, const_cast&lt;SourceCode*&gt;(m_source));</span>
 201     ScopeRef scope = currentScope();
 202     scope-&gt;setIsLexicalScope();
 203     SetForScope&lt;FunctionParsePhase&gt; functionParsePhasePoisoner(m_parserState.functionParsePhase, FunctionParsePhase::Body);
 204 
 205     bool isArrowFunctionBodyExpression = parseMode == SourceParseMode::AsyncArrowFunctionBodyMode &amp;&amp; !match(OPENBRACE);
 206     if (m_lexer-&gt;isReparsingFunction()) {
 207         ParserFunctionInfo&lt;ASTBuilder&gt; functionInfo;
 208         if (isGeneratorOrAsyncFunctionBodyParseMode(parseMode))
 209             m_parameters = createGeneratorParameters(context, functionInfo.parameterCount);
 210         else
 211             m_parameters = parseFunctionParameters(context, parseMode, functionInfo);
 212 
 213         if (SourceParseModeSet(SourceParseMode::ArrowFunctionMode, SourceParseMode::AsyncArrowFunctionMode).contains(parseMode) &amp;&amp; !hasError()) {
 214             // The only way we could have an error wile reparsing is if we run out of stack space.
 215             RELEASE_ASSERT(match(ARROWFUNCTION));
 216             next();
 217             isArrowFunctionBodyExpression = !match(OPENBRACE);
 218         }
 219     }
 220 
 221     if (!calleeName.isNull())
 222         scope-&gt;declareCallee(&amp;calleeName);
 223 
 224     if (m_lexer-&gt;isReparsingFunction())
 225         m_statementDepth--;
 226 
 227     SourceElements* sourceElements = nullptr;
 228     // The only way we can error this early is if we reparse a function and we run out of stack space.
 229     if (!hasError()) {
 230         if (isAsyncFunctionWrapperParseMode(parseMode))
 231             sourceElements = parseAsyncFunctionSourceElements(context, parseMode, isArrowFunctionBodyExpression, CheckForStrictMode);
 232         else if (isArrowFunctionBodyExpression)
 233             sourceElements = parseArrowFunctionSingleExpressionBodySourceElements(context);
 234         else if (isModuleParseMode(parseMode))
 235             sourceElements = parseModuleSourceElements(context, parseMode);
 236         else if (isGeneratorWrapperParseMode(parseMode))
 237             sourceElements = parseGeneratorFunctionSourceElements(context, calleeName, CheckForStrictMode);
 238         else if (isAsyncGeneratorWrapperParseMode(parseMode))
 239             sourceElements = parseAsyncGeneratorFunctionSourceElements(context, parseMode, isArrowFunctionBodyExpression, CheckForStrictMode);
 240         else if (parsingContext == ParsingContext::FunctionConstructor)
 241             sourceElements = parseSingleFunction(context, functionConstructorParametersEndPosition);
 242         else
 243             sourceElements = parseSourceElements(context, CheckForStrictMode);
 244     }
 245 
 246     bool validEnding = consume(EOFTOK);
 247     if (!sourceElements || !validEnding) {
 248         if (hasError())
 249             parseError = m_errorMessage;
 250         else
 251             parseError = &quot;Parser error&quot;_s;
 252     }
 253 
 254     IdentifierSet capturedVariables;
 255     UniquedStringImplPtrSet sloppyModeHoistedFunctions;
 256     scope-&gt;getSloppyModeHoistedFunctions(sloppyModeHoistedFunctions);
 257     scope-&gt;getCapturedVars(capturedVariables);
 258 
 259     VariableEnvironment&amp; varDeclarations = scope-&gt;declaredVariables();
 260     for (auto&amp; entry : capturedVariables)
 261         varDeclarations.markVariableAsCaptured(entry);
 262 
 263     if (isGeneratorWrapperParseMode(parseMode) || isAsyncFunctionOrAsyncGeneratorWrapperParseMode(parseMode)) {
<a name="8" id="anc8"></a><span class="line-modified"> 264         if (scope-&gt;usedVariablesContains(m_vm-&gt;propertyNames-&gt;arguments.impl()))</span>
 265             context.propagateArgumentsUse();
 266     }
 267 
 268     CodeFeatures features = context.features();
 269     if (scope-&gt;strictMode())
 270         features |= StrictModeFeature;
 271     if (scope-&gt;shadowsArguments())
 272         features |= ShadowsArgumentsFeature;
 273     if (m_seenTaggedTemplate)
 274         features |= NoEvalCacheFeature;
 275 
 276 #ifndef NDEBUG
 277     if (m_parsingBuiltin &amp;&amp; isProgramParseMode(parseMode)) {
 278         VariableEnvironment&amp; lexicalVariables = scope-&gt;lexicalVariables();
 279         const HashSet&lt;UniquedStringImpl*&gt;&amp; closedVariableCandidates = scope-&gt;closedVariableCandidates();
 280         for (UniquedStringImpl* candidate : closedVariableCandidates) {
 281             // FIXME: We allow async to leak because it appearing as a closed variable is a side effect of trying to parse async arrow functions.
<a name="9" id="anc9"></a><span class="line-modified"> 282             if (!lexicalVariables.contains(candidate) &amp;&amp; !varDeclarations.contains(candidate) &amp;&amp; !candidate-&gt;isSymbol() &amp;&amp; candidate != m_vm-&gt;propertyNames-&gt;async.impl()) {</span>
 283                 dataLog(&quot;Bad global capture in builtin: &#39;&quot;, candidate, &quot;&#39;\n&quot;);
 284                 dataLog(m_source-&gt;view());
 285                 CRASH();
 286             }
 287         }
 288     }
 289 #endif // NDEBUG
 290     didFinishParsing(sourceElements, scope-&gt;takeFunctionDeclarations(), varDeclarations, WTFMove(sloppyModeHoistedFunctions), features, context.numConstants());
 291 
 292     return parseError;
 293 }
 294 
 295 template &lt;typename LexerType&gt;
 296 void Parser&lt;LexerType&gt;::didFinishParsing(SourceElements* sourceElements, DeclarationStacks::FunctionStack&amp;&amp; funcStack,
 297     VariableEnvironment&amp; varDeclarations, UniquedStringImplPtrSet&amp;&amp; sloppyModeHoistedFunctions, CodeFeatures features, int numConstants)
 298 {
 299     m_sourceElements = sourceElements;
 300     m_funcDeclarations = WTFMove(funcStack);
 301     m_varDeclarations.swap(varDeclarations);
 302     m_features = features;
 303     m_sloppyModeHoistedFunctions = WTFMove(sloppyModeHoistedFunctions);
 304     m_numConstants = numConstants;
 305 }
 306 
 307 template &lt;typename LexerType&gt;
 308 bool Parser&lt;LexerType&gt;::isArrowFunctionParameters()
 309 {
 310     if (match(OPENPAREN)) {
 311         SavePoint saveArrowFunctionPoint = createSavePoint();
 312         next();
 313         bool isArrowFunction = false;
 314         if (match(CLOSEPAREN)) {
 315             next();
 316             isArrowFunction = match(ARROWFUNCTION);
 317         } else {
<a name="10" id="anc10"></a><span class="line-modified"> 318             SyntaxChecker syntaxChecker(const_cast&lt;VM*&gt;(m_vm), m_lexer.get());</span>
 319             // We make fake scope, otherwise parseFormalParameters will add variable to current scope that lead to errors
 320             AutoPopScopeRef fakeScope(this, pushScope());
 321             fakeScope-&gt;setSourceParseMode(SourceParseMode::ArrowFunctionMode);
 322 
 323             unsigned parametersCount = 0;
 324             bool isArrowFunctionParameterList = true;
 325             bool isMethod = false;
 326             isArrowFunction = parseFormalParameters(syntaxChecker, syntaxChecker.createFormalParameterList(), isArrowFunctionParameterList, isMethod, parametersCount) &amp;&amp; consume(CLOSEPAREN) &amp;&amp; match(ARROWFUNCTION);
 327             propagateError();
 328             popScope(fakeScope, syntaxChecker.NeedsFreeVariableInfo);
 329         }
 330         restoreSavePoint(saveArrowFunctionPoint);
 331         return isArrowFunction;
 332     }
 333 
 334     if (matchSpecIdentifier()) {
 335         SavePoint saveArrowFunctionPoint = createSavePoint();
 336         next();
 337         bool isArrowFunction = match(ARROWFUNCTION);
 338         restoreSavePoint(saveArrowFunctionPoint);
 339         return isArrowFunction;
 340     }
 341 
 342     return false;
 343 }
 344 
 345 template &lt;typename LexerType&gt;
 346 bool Parser&lt;LexerType&gt;::allowAutomaticSemicolon()
 347 {
 348     return match(CLOSEBRACE) || match(EOFTOK) || m_lexer-&gt;hasLineTerminatorBeforeToken();
 349 }
 350 
 351 template &lt;typename LexerType&gt;
 352 template &lt;class TreeBuilder&gt; TreeSourceElements Parser&lt;LexerType&gt;::parseSourceElements(TreeBuilder&amp; context, SourceElementsMode mode)
 353 {
 354     const unsigned lengthOfUseStrictLiteral = 12; // &quot;use strict&quot;.length
 355     TreeSourceElements sourceElements = context.createSourceElements();
 356     const Identifier* directive = 0;
 357     unsigned directiveLiteralLength = 0;
 358     auto savePoint = createSavePoint();
 359     bool shouldCheckForUseStrict = mode == CheckForStrictMode;
 360 
 361     while (TreeStatement statement = parseStatementListItem(context, directive, &amp;directiveLiteralLength)) {
 362         if (shouldCheckForUseStrict) {
 363             if (directive) {
 364                 // &quot;use strict&quot; must be the exact literal without escape sequences or line continuation.
<a name="11" id="anc11"></a><span class="line-modified"> 365                 if (directiveLiteralLength == lengthOfUseStrictLiteral &amp;&amp; m_vm-&gt;propertyNames-&gt;useStrictIdentifier == *directive) {</span>
 366                     setStrictMode();
 367                     shouldCheckForUseStrict = false; // We saw &quot;use strict&quot;, there is no need to keep checking for it.
 368                     if (!isValidStrictMode()) {
 369                         if (m_parserState.lastFunctionName) {
<a name="12" id="anc12"></a><span class="line-modified"> 370                             if (m_vm-&gt;propertyNames-&gt;arguments == *m_parserState.lastFunctionName)</span>
 371                                 semanticFail(&quot;Cannot name a function &#39;arguments&#39; in strict mode&quot;);
<a name="13" id="anc13"></a><span class="line-modified"> 372                             if (m_vm-&gt;propertyNames-&gt;eval == *m_parserState.lastFunctionName)</span>
 373                                 semanticFail(&quot;Cannot name a function &#39;eval&#39; in strict mode&quot;);
 374                         }
<a name="14" id="anc14"></a><span class="line-modified"> 375                         if (hasDeclaredVariable(m_vm-&gt;propertyNames-&gt;arguments))</span>
 376                             semanticFail(&quot;Cannot declare a variable named &#39;arguments&#39; in strict mode&quot;);
<a name="15" id="anc15"></a><span class="line-modified"> 377                         if (hasDeclaredVariable(m_vm-&gt;propertyNames-&gt;eval))</span>
 378                             semanticFail(&quot;Cannot declare a variable named &#39;eval&#39; in strict mode&quot;);
 379                         semanticFailIfTrue(currentScope()-&gt;hasNonSimpleParameterList(), &quot;&#39;use strict&#39; directive not allowed inside a function with a non-simple parameter list&quot;);
 380                         semanticFailIfFalse(isValidStrictMode(), &quot;Invalid parameters or function name in strict mode&quot;);
 381                     }
 382                     // Since strict mode is changed, restoring lexer state by calling next() may cause errors.
 383                     restoreSavePoint(savePoint);
 384                     propagateError();
 385                     continue;
 386                 }
 387 
 388                 // We saw a directive, but it wasn&#39;t &quot;use strict&quot;. We reset our state to
 389                 // see if the next statement we parse is also a directive.
 390                 directive = nullptr;
 391             } else {
 392                 // We saw a statement that wasn&#39;t in the form of a directive. The spec says that &quot;use strict&quot;
 393                 // is only allowed as the first statement, or after a sequence of directives before it, but
 394                 // not after non-directive statements.
 395                 shouldCheckForUseStrict = false;
 396             }
 397         }
 398         context.appendStatement(sourceElements, statement);
 399     }
 400 
 401     propagateError();
 402     return sourceElements;
 403 }
 404 
 405 template &lt;typename LexerType&gt;
 406 template &lt;class TreeBuilder&gt; TreeSourceElements Parser&lt;LexerType&gt;::parseModuleSourceElements(TreeBuilder&amp; context, SourceParseMode parseMode)
 407 {
 408     TreeSourceElements sourceElements = context.createSourceElements();
<a name="16" id="anc16"></a><span class="line-modified"> 409     SyntaxChecker syntaxChecker(const_cast&lt;VM*&gt;(m_vm), m_lexer.get());</span>
 410 
 411     while (true) {
 412         TreeStatement statement = 0;
 413         switch (m_token.m_type) {
 414         case EXPORT:
 415             statement = parseExportDeclaration(context);
 416             if (statement)
 417                 recordPauseLocation(context.breakpointLocation(statement));
 418             break;
 419 
 420         case IMPORT: {
 421             SavePoint savePoint = createSavePoint();
 422             next();
 423             bool isImportDeclaration = !match(OPENPAREN) &amp;&amp; !match(DOT);
 424             restoreSavePoint(savePoint);
 425             if (isImportDeclaration) {
 426                 statement = parseImportDeclaration(context);
 427                 if (statement)
 428                     recordPauseLocation(context.breakpointLocation(statement));
 429                 break;
 430             }
 431 
 432             // This is `import(&quot;...&quot;)` call or `import.meta` meta property case.
 433             FALLTHROUGH;
 434         }
 435 
 436         default: {
 437             const Identifier* directive = 0;
 438             unsigned directiveLiteralLength = 0;
 439             if (parseMode == SourceParseMode::ModuleAnalyzeMode) {
 440                 if (!parseStatementListItem(syntaxChecker, directive, &amp;directiveLiteralLength))
 441                     goto end;
 442                 continue;
 443             }
 444             statement = parseStatementListItem(context, directive, &amp;directiveLiteralLength);
 445             break;
 446         }
 447         }
 448 
 449         if (!statement)
 450             goto end;
 451         context.appendStatement(sourceElements, statement);
 452     }
 453 
 454 end:
 455     propagateError();
 456 
 457     for (const auto&amp; pair : m_moduleScopeData-&gt;exportedBindings()) {
 458         const auto&amp; uid = pair.key;
 459         if (currentScope()-&gt;hasDeclaredVariable(uid)) {
 460             currentScope()-&gt;declaredVariables().markVariableAsExported(uid);
 461             continue;
 462         }
 463 
 464         if (currentScope()-&gt;hasLexicallyDeclaredVariable(uid)) {
 465             currentScope()-&gt;lexicalVariables().markVariableAsExported(uid);
 466             continue;
 467         }
 468 
 469         semanticFail(&quot;Exported binding &#39;&quot;, uid.get(), &quot;&#39; needs to refer to a top-level declared variable&quot;);
 470     }
 471 
 472     return sourceElements;
 473 }
 474 
 475 template &lt;typename LexerType&gt;
 476 template &lt;class TreeBuilder&gt; TreeSourceElements Parser&lt;LexerType&gt;::parseGeneratorFunctionSourceElements(TreeBuilder&amp; context, const Identifier&amp; name, SourceElementsMode mode)
 477 {
 478     auto sourceElements = context.createSourceElements();
 479 
 480     unsigned functionKeywordStart = tokenStart();
 481     JSTokenLocation startLocation(tokenLocation());
 482     JSTextPosition start = tokenStartPosition();
 483     unsigned startColumn = tokenColumn();
 484     int functionNameStart = m_token.m_location.startOffset;
 485     int parametersStart = m_token.m_location.startOffset;
 486 
 487     ParserFunctionInfo&lt;TreeBuilder&gt; info;
<a name="17" id="anc17"></a><span class="line-modified"> 488     info.name = &amp;m_vm-&gt;propertyNames-&gt;nullIdentifier;</span>
 489     createGeneratorParameters(context, info.parameterCount);
 490     info.startOffset = parametersStart;
 491     info.startLine = tokenLine();
 492 
 493     {
 494         AutoPopScopeRef generatorBodyScope(this, pushScope());
 495         generatorBodyScope-&gt;setSourceParseMode(SourceParseMode::GeneratorBodyMode);
 496         generatorBodyScope-&gt;setConstructorKind(ConstructorKind::None);
 497         generatorBodyScope-&gt;setExpectedSuperBinding(m_superBinding);
 498 
<a name="18" id="anc18"></a><span class="line-modified"> 499         SyntaxChecker generatorFunctionContext(const_cast&lt;VM*&gt;(m_vm), m_lexer.get());</span>
 500         failIfFalse(parseSourceElements(generatorFunctionContext, mode), &quot;Cannot parse the body of a generator&quot;);
 501         popScope(generatorBodyScope, TreeBuilder::NeedsFreeVariableInfo);
 502     }
 503     info.body = context.createFunctionMetadata(startLocation, tokenLocation(), startColumn, tokenColumn(), functionKeywordStart, functionNameStart, parametersStart, strictMode(), ConstructorKind::None, m_superBinding, info.parameterCount, SourceParseMode::GeneratorBodyMode, false);
 504 
 505     info.endLine = tokenLine();
 506     info.endOffset = m_token.m_data.offset;
 507     info.parametersStartColumn = startColumn;
 508 
 509     auto functionExpr = context.createGeneratorFunctionBody(startLocation, info, name);
 510     auto statement = context.createExprStatement(startLocation, functionExpr, start, m_lastTokenEndPosition.line);
 511     context.appendStatement(sourceElements, statement);
 512 
 513     return sourceElements;
 514 }
 515 
 516 template &lt;typename LexerType&gt;
 517 template &lt;class TreeBuilder&gt; TreeSourceElements Parser&lt;LexerType&gt;::parseAsyncFunctionSourceElements(TreeBuilder&amp; context, SourceParseMode parseMode, bool isArrowFunctionBodyExpression, SourceElementsMode mode)
 518 {
 519     ASSERT(isAsyncFunctionOrAsyncGeneratorWrapperParseMode(parseMode));
 520     auto sourceElements = context.createSourceElements();
 521 
 522     unsigned functionKeywordStart = tokenStart();
 523     JSTokenLocation startLocation(tokenLocation());
 524     JSTextPosition start = tokenStartPosition();
 525     unsigned startColumn = tokenColumn();
 526     int functionNameStart = m_token.m_location.startOffset;
 527     int parametersStart = m_token.m_location.startOffset;
 528 
 529     ParserFunctionInfo&lt;TreeBuilder&gt; info;
<a name="19" id="anc19"></a><span class="line-modified"> 530     info.name = &amp;m_vm-&gt;propertyNames-&gt;nullIdentifier;</span>
 531     createGeneratorParameters(context, info.parameterCount);
 532     info.startOffset = parametersStart;
 533     info.startLine = tokenLine();
 534 
 535     SourceParseMode innerParseMode = getAsynFunctionBodyParseMode(parseMode);
 536 
 537     {
 538         AutoPopScopeRef asyncFunctionBodyScope(this, pushScope());
 539         asyncFunctionBodyScope-&gt;setSourceParseMode(innerParseMode);
<a name="20" id="anc20"></a><span class="line-modified"> 540         SyntaxChecker syntaxChecker(const_cast&lt;VM*&gt;(m_vm), m_lexer.get());</span>
 541         if (isArrowFunctionBodyExpression) {
 542             if (m_debuggerParseData)
 543                 failIfFalse(parseArrowFunctionSingleExpressionBodySourceElements(context), &quot;Cannot parse the body of async arrow function&quot;);
 544             else
 545                 failIfFalse(parseArrowFunctionSingleExpressionBodySourceElements(syntaxChecker), &quot;Cannot parse the body of async arrow function&quot;);
 546         } else {
 547             if (m_debuggerParseData)
 548                 failIfFalse(parseSourceElements(context, mode), &quot;Cannot parse the body of async function&quot;);
 549             else
 550                 failIfFalse(parseSourceElements(syntaxChecker, mode), &quot;Cannot parse the body of async function&quot;);
 551         }
 552         popScope(asyncFunctionBodyScope, TreeBuilder::NeedsFreeVariableInfo);
 553     }
 554     info.body = context.createFunctionMetadata(startLocation, tokenLocation(), startColumn, tokenColumn(), functionKeywordStart, functionNameStart, parametersStart, strictMode(), ConstructorKind::None, m_superBinding, info.parameterCount, innerParseMode, isArrowFunctionBodyExpression);
 555 
 556     info.endLine = tokenLine();
 557     info.endOffset = isArrowFunctionBodyExpression ? tokenLocation().endOffset : m_token.m_data.offset;
 558     info.parametersStartColumn = startColumn;
 559 
 560     auto functionExpr = context.createAsyncFunctionBody(startLocation, info, innerParseMode);
 561     auto statement = context.createExprStatement(startLocation, functionExpr, start, m_lastTokenEndPosition.line);
 562     context.appendStatement(sourceElements, statement);
 563 
 564     return sourceElements;
 565 }
 566 
 567 template &lt;typename LexerType&gt;
 568 template &lt;class TreeBuilder&gt; TreeSourceElements Parser&lt;LexerType&gt;::parseAsyncGeneratorFunctionSourceElements(TreeBuilder&amp; context, SourceParseMode parseMode, bool isArrowFunctionBodyExpression, SourceElementsMode mode)
 569 {
 570     ASSERT_UNUSED(parseMode, isAsyncGeneratorWrapperParseMode(parseMode));
 571     auto sourceElements = context.createSourceElements();
 572 
 573     unsigned functionKeywordStart = tokenStart();
 574     JSTokenLocation startLocation(tokenLocation());
 575     JSTextPosition start = tokenStartPosition();
 576     unsigned startColumn = tokenColumn();
 577     int functionNameStart = m_token.m_location.startOffset;
 578     int parametersStart = m_token.m_location.startOffset;
 579 
 580     ParserFunctionInfo&lt;TreeBuilder&gt; info;
<a name="21" id="anc21"></a><span class="line-modified"> 581     info.name = &amp;m_vm-&gt;propertyNames-&gt;nullIdentifier;</span>
 582     createGeneratorParameters(context, info.parameterCount);
 583     info.startOffset = parametersStart;
 584     info.startLine = tokenLine();
 585     SourceParseMode innerParseMode = SourceParseMode::AsyncGeneratorBodyMode;
 586     {
 587         AutoPopScopeRef asyncFunctionBodyScope(this, pushScope());
 588         asyncFunctionBodyScope-&gt;setSourceParseMode(innerParseMode);
<a name="22" id="anc22"></a><span class="line-modified"> 589         SyntaxChecker syntaxChecker(const_cast&lt;VM*&gt;(m_vm), m_lexer.get());</span>
 590         if (isArrowFunctionBodyExpression) {
 591             if (m_debuggerParseData)
 592                 failIfFalse(parseArrowFunctionSingleExpressionBodySourceElements(context), &quot;Cannot parse the body of async arrow function&quot;);
 593             else
 594                 failIfFalse(parseArrowFunctionSingleExpressionBodySourceElements(syntaxChecker), &quot;Cannot parse the body of async arrow function&quot;);
 595         } else {
 596             if (m_debuggerParseData)
 597                 failIfFalse(parseSourceElements(context, mode), &quot;Cannot parse the body of async function&quot;);
 598             else
 599                 failIfFalse(parseSourceElements(syntaxChecker, mode), &quot;Cannot parse the body of async function&quot;);
 600         }
 601         popScope(asyncFunctionBodyScope, TreeBuilder::NeedsFreeVariableInfo);
 602     }
 603     info.body = context.createFunctionMetadata(startLocation, tokenLocation(), startColumn, tokenColumn(), functionKeywordStart, functionNameStart, parametersStart, strictMode(), ConstructorKind::None, m_superBinding, info.parameterCount, innerParseMode, isArrowFunctionBodyExpression);
 604 
 605     info.endLine = tokenLine();
 606     info.endOffset = isArrowFunctionBodyExpression ? tokenLocation().endOffset : m_token.m_data.offset;
 607     info.parametersStartColumn = startColumn;
 608 
 609     auto functionExpr = context.createAsyncFunctionBody(startLocation, info, innerParseMode);
 610     auto statement = context.createExprStatement(startLocation, functionExpr, start, m_lastTokenEndPosition.line);
 611     context.appendStatement(sourceElements, statement);
 612 
 613     return sourceElements;
 614 }
 615 
 616 template &lt;typename LexerType&gt;
 617 template &lt;class TreeBuilder&gt; TreeSourceElements Parser&lt;LexerType&gt;::parseSingleFunction(TreeBuilder&amp; context, Optional&lt;int&gt; functionConstructorParametersEndPosition)
 618 {
 619     TreeSourceElements sourceElements = context.createSourceElements();
 620     TreeStatement statement = 0;
 621     switch (m_token.m_type) {
 622     case FUNCTION:
 623         statement = parseFunctionDeclaration(context, ExportType::NotExported, DeclarationDefaultContext::Standard, functionConstructorParametersEndPosition);
 624         break;
 625     case IDENT:
<a name="23" id="anc23"></a><span class="line-modified"> 626         if (*m_token.m_data.ident == m_vm-&gt;propertyNames-&gt;async &amp;&amp; !m_token.m_data.escaped) {</span>
 627             next();
 628             failIfFalse(match(FUNCTION) &amp;&amp; !m_lexer-&gt;hasLineTerminatorBeforeToken(), &quot;Cannot parse the async function&quot;);
 629             statement = parseAsyncFunctionDeclaration(context, ExportType::NotExported, DeclarationDefaultContext::Standard, functionConstructorParametersEndPosition);
 630             break;
 631         }
 632         FALLTHROUGH;
 633     default:
 634         failDueToUnexpectedToken();
 635         break;
 636     }
 637 
 638     if (statement) {
 639         context.setEndOffset(statement, m_lastTokenEndPosition.offset);
 640         context.appendStatement(sourceElements, statement);
 641     }
 642 
 643     propagateError();
 644     return sourceElements;
 645 }
 646 
 647 
 648 template &lt;typename LexerType&gt;
 649 template &lt;class TreeBuilder&gt; TreeStatement Parser&lt;LexerType&gt;::parseStatementListItem(TreeBuilder&amp; context, const Identifier*&amp; directive, unsigned* directiveLiteralLength)
 650 {
 651     // The grammar is documented here:
 652     // http://www.ecma-international.org/ecma-262/6.0/index.html#sec-statements
 653     DepthManager statementDepth(&amp;m_statementDepth);
 654     m_statementDepth++;
<a name="24" id="anc24"></a>
 655     TreeStatement result = 0;
 656     bool shouldSetEndOffset = true;
 657     bool shouldSetPauseLocation = false;
 658 
 659     switch (m_token.m_type) {
 660     case CONSTTOKEN:
 661         result = parseVariableDeclaration(context, DeclarationType::ConstDeclaration);
 662         shouldSetPauseLocation = true;
 663         break;
 664     case LET: {
 665         bool shouldParseVariableDeclaration = true;
 666         if (!strictMode()) {
 667             SavePoint savePoint = createSavePoint();
 668             next();
 669             // Intentionally use `isIdentifierOrAnyContextualKeyword(m_token)` and don&#39;t use `matchSpecIdentifier()`.
 670             // We would like to fall into parseVariableDeclaration path even if &quot;yield&quot; is not treated as an Identifier.
 671             // For example, under a generator context, matchSpecIdentifier() for &quot;yield&quot; returns `false`.
 672             // But we would like to enter parseVariableDeclaration and raise an error under the context of parseVariableDeclaration
 673             // to raise consistent errors between &quot;var&quot;, &quot;const&quot; and &quot;let&quot;.
 674             if (!isIdentifierOrAnyContextualKeyword(m_token) &amp;&amp; !match(OPENBRACE) &amp;&amp; !match(OPENBRACKET))
 675                 shouldParseVariableDeclaration = false;
 676             restoreSavePoint(savePoint);
 677         }
 678         if (shouldParseVariableDeclaration)
 679             result = parseVariableDeclaration(context, DeclarationType::LetDeclaration);
 680         else {
 681             bool allowFunctionDeclarationAsStatement = true;
 682             result = parseExpressionOrLabelStatement(context, allowFunctionDeclarationAsStatement);
 683         }
 684         shouldSetPauseLocation = !context.shouldSkipPauseLocation(result);
 685         break;
 686     }
 687     case CLASSTOKEN:
 688         result = parseClassDeclaration(context);
 689         break;
 690     case FUNCTION:
 691         result = parseFunctionDeclaration(context);
 692         break;
 693     case IDENT:
<a name="25" id="anc25"></a><span class="line-modified"> 694         if (UNLIKELY(*m_token.m_data.ident == m_vm-&gt;propertyNames-&gt;async &amp;&amp; !m_token.m_data.escaped)) {</span>
 695             // Eagerly parse as AsyncFunctionDeclaration. This is the uncommon case,
 696             // but could be mistakenly parsed as an AsyncFunctionExpression.
 697             SavePoint savePoint = createSavePoint();
 698             next();
 699             if (UNLIKELY(match(FUNCTION) &amp;&amp; !m_lexer-&gt;hasLineTerminatorBeforeToken())) {
 700                 result = parseAsyncFunctionDeclaration(context);
 701                 break;
 702             }
 703             restoreSavePoint(savePoint);
 704         }
 705         FALLTHROUGH;
 706     case AWAIT:
 707     case YIELD: {
 708         // This is a convenient place to notice labeled statements
 709         // (even though we also parse them as normal statements)
 710         // because we allow the following type of code in sloppy mode:
 711         // ``` function foo() { label: function bar() { } } ```
 712         bool allowFunctionDeclarationAsStatement = true;
 713         result = parseExpressionOrLabelStatement(context, allowFunctionDeclarationAsStatement);
 714         shouldSetPauseLocation = !context.shouldSkipPauseLocation(result);
 715         break;
 716     }
 717     default:
 718         m_statementDepth--; // parseStatement() increments the depth.
 719         result = parseStatement(context, directive, directiveLiteralLength);
 720         shouldSetEndOffset = false;
 721         break;
 722     }
 723 
 724     if (result) {
 725         if (shouldSetEndOffset)
 726             context.setEndOffset(result, m_lastTokenEndPosition.offset);
 727         if (shouldSetPauseLocation)
 728             recordPauseLocation(context.breakpointLocation(result));
 729     }
 730 
 731     return result;
 732 }
 733 
 734 template &lt;typename LexerType&gt;
 735 template &lt;class TreeBuilder&gt; TreeStatement Parser&lt;LexerType&gt;::parseVariableDeclaration(TreeBuilder&amp; context, DeclarationType declarationType, ExportType exportType)
 736 {
 737     ASSERT(match(VAR) || match(LET) || match(CONSTTOKEN));
 738     JSTokenLocation location(tokenLocation());
 739     int start = tokenLine();
 740     int end = 0;
 741     int scratch;
 742     TreeDestructuringPattern scratch1 = 0;
 743     TreeExpression scratch2 = 0;
 744     JSTextPosition scratch3;
 745     bool scratchBool;
 746     TreeExpression variableDecls = parseVariableDeclarationList(context, scratch, scratch1, scratch2, scratch3, scratch3, scratch3, VarDeclarationContext, declarationType, exportType, scratchBool);
 747     propagateError();
 748     failIfFalse(autoSemiColon(), &quot;Expected &#39;;&#39; after variable declaration&quot;);
 749 
 750     return context.createDeclarationStatement(location, variableDecls, start, end);
 751 }
 752 
 753 template &lt;typename LexerType&gt;
 754 template &lt;class TreeBuilder&gt; TreeStatement Parser&lt;LexerType&gt;::parseDoWhileStatement(TreeBuilder&amp; context)
 755 {
 756     ASSERT(match(DO));
 757     int startLine = tokenLine();
 758     next();
 759     const Identifier* unused = 0;
 760     startLoop();
 761     TreeStatement statement = parseStatement(context, unused);
 762     endLoop();
 763     failIfFalse(statement, &quot;Expected a statement following &#39;do&#39;&quot;);
 764     int endLine = tokenLine();
 765     JSTokenLocation location(tokenLocation());
 766     handleProductionOrFail(WHILE, &quot;while&quot;, &quot;end&quot;, &quot;do-while loop&quot;);
 767     handleProductionOrFail(OPENPAREN, &quot;(&quot;, &quot;start&quot;, &quot;do-while loop condition&quot;);
 768     semanticFailIfTrue(match(CLOSEPAREN), &quot;Must provide an expression as a do-while loop condition&quot;);
 769     TreeExpression expr = parseExpression(context);
 770     failIfFalse(expr, &quot;Unable to parse do-while loop condition&quot;);
 771     recordPauseLocation(context.breakpointLocation(expr));
 772     handleProductionOrFail(CLOSEPAREN, &quot;)&quot;, &quot;end&quot;, &quot;do-while loop condition&quot;);
 773     if (match(SEMICOLON))
 774         next(); // Always performs automatic semicolon insertion.
 775     return context.createDoWhileStatement(location, statement, expr, startLine, endLine);
 776 }
 777 
 778 template &lt;typename LexerType&gt;
 779 template &lt;class TreeBuilder&gt; TreeStatement Parser&lt;LexerType&gt;::parseWhileStatement(TreeBuilder&amp; context)
 780 {
 781     ASSERT(match(WHILE));
 782     JSTokenLocation location(tokenLocation());
 783     int startLine = tokenLine();
 784     next();
 785 
 786     handleProductionOrFail(OPENPAREN, &quot;(&quot;, &quot;start&quot;, &quot;while loop condition&quot;);
 787     semanticFailIfTrue(match(CLOSEPAREN), &quot;Must provide an expression as a while loop condition&quot;);
 788     TreeExpression expr = parseExpression(context);
 789     failIfFalse(expr, &quot;Unable to parse while loop condition&quot;);
 790     recordPauseLocation(context.breakpointLocation(expr));
 791     int endLine = tokenLine();
 792     handleProductionOrFail(CLOSEPAREN, &quot;)&quot;, &quot;end&quot;, &quot;while loop condition&quot;);
 793 
 794     const Identifier* unused = 0;
 795     startLoop();
 796     TreeStatement statement = parseStatement(context, unused);
 797     endLoop();
 798     failIfFalse(statement, &quot;Expected a statement as the body of a while loop&quot;);
 799     return context.createWhileStatement(location, expr, statement, startLine, endLine);
 800 }
 801 
 802 template &lt;typename LexerType&gt;
 803 template &lt;class TreeBuilder&gt; TreeExpression Parser&lt;LexerType&gt;::parseVariableDeclarationList(TreeBuilder&amp; context, int&amp; declarations, TreeDestructuringPattern&amp; lastPattern, TreeExpression&amp; lastInitializer, JSTextPosition&amp; identStart, JSTextPosition&amp; initStart, JSTextPosition&amp; initEnd, VarDeclarationListContext declarationListContext, DeclarationType declarationType, ExportType exportType, bool&amp; forLoopConstDoesNotHaveInitializer)
 804 {
 805     ASSERT(declarationType == DeclarationType::LetDeclaration || declarationType == DeclarationType::VarDeclaration || declarationType == DeclarationType::ConstDeclaration);
 806     TreeExpression head = 0;
 807     TreeExpression tail = 0;
 808     const Identifier* lastIdent;
 809     JSToken lastIdentToken;
 810     AssignmentContext assignmentContext = assignmentContextFromDeclarationType(declarationType);
 811     do {
 812         lastIdent = 0;
 813         lastPattern = TreeDestructuringPattern(0);
 814         JSTokenLocation location(tokenLocation());
 815         next();
 816         TreeExpression node = 0;
 817         declarations++;
 818         bool hasInitializer = false;
 819         if (matchSpecIdentifier()) {
 820             failIfTrue(match(LET) &amp;&amp; (declarationType == DeclarationType::LetDeclaration || declarationType == DeclarationType::ConstDeclaration),
 821                 &quot;Cannot use &#39;let&#39; as an identifier name for a LexicalDeclaration&quot;);
 822             semanticFailIfTrue(isDisallowedIdentifierAwait(m_token), &quot;Cannot use &#39;await&#39; as a &quot;, declarationTypeToVariableKind(declarationType), &quot; &quot;, disallowedIdentifierAwaitReason());
 823             JSTextPosition varStart = tokenStartPosition();
 824             JSTokenLocation varStartLocation(tokenLocation());
 825             identStart = varStart;
 826             const Identifier* name = m_token.m_data.ident;
 827             lastIdent = name;
 828             lastIdentToken = m_token;
 829             next();
 830             hasInitializer = match(EQUAL);
 831             DeclarationResultMask declarationResult = declareVariable(name, declarationType);
 832             if (declarationResult != DeclarationResult::Valid) {
 833                 failIfTrueIfStrict(declarationResult &amp; DeclarationResult::InvalidStrictMode, &quot;Cannot declare a variable named &quot;, name-&gt;impl(), &quot; in strict mode&quot;);
 834                 if (declarationResult &amp; DeclarationResult::InvalidDuplicateDeclaration) {
 835                     if (declarationType == DeclarationType::LetDeclaration)
 836                         internalFailWithMessage(false, &quot;Cannot declare a let variable twice: &#39;&quot;, name-&gt;impl(), &quot;&#39;&quot;);
 837                     if (declarationType == DeclarationType::ConstDeclaration)
 838                         internalFailWithMessage(false, &quot;Cannot declare a const variable twice: &#39;&quot;, name-&gt;impl(), &quot;&#39;&quot;);
 839                     ASSERT(declarationType == DeclarationType::VarDeclaration);
 840                     internalFailWithMessage(false, &quot;Cannot declare a var variable that shadows a let/const/class variable: &#39;&quot;, name-&gt;impl(), &quot;&#39;&quot;);
 841                 }
 842             }
 843             if (exportType == ExportType::Exported) {
 844                 semanticFailIfFalse(exportName(*name), &quot;Cannot export a duplicate name &#39;&quot;, name-&gt;impl(), &quot;&#39;&quot;);
 845                 m_moduleScopeData-&gt;exportBinding(*name);
 846             }
 847 
 848             if (hasInitializer) {
 849                 JSTextPosition varDivot = tokenStartPosition() + 1;
 850                 initStart = tokenStartPosition();
 851                 next(TreeBuilder::DontBuildStrings); // consume &#39;=&#39;
 852                 propagateError();
 853                 TreeExpression initializer = parseAssignmentExpression(context);
 854                 initEnd = lastTokenEndPosition();
 855                 lastInitializer = initializer;
 856                 failIfFalse(initializer, &quot;Expected expression as the intializer for the variable &#39;&quot;, name-&gt;impl(), &quot;&#39;&quot;);
 857 
 858                 node = context.createAssignResolve(location, *name, initializer, varStart, varDivot, lastTokenEndPosition(), assignmentContext);
 859             } else {
 860                 if (declarationListContext == ForLoopContext &amp;&amp; declarationType == DeclarationType::ConstDeclaration)
 861                     forLoopConstDoesNotHaveInitializer = true;
 862                 failIfTrue(declarationListContext != ForLoopContext &amp;&amp; declarationType == DeclarationType::ConstDeclaration, &quot;const declared variable &#39;&quot;, name-&gt;impl(), &quot;&#39;&quot;, &quot; must have an initializer&quot;);
 863                 if (declarationType == DeclarationType::VarDeclaration)
 864                     node = context.createEmptyVarExpression(varStartLocation, *name);
 865                 else
 866                     node = context.createEmptyLetExpression(varStartLocation, *name);
 867             }
 868         } else {
 869             lastIdent = 0;
 870             auto pattern = parseDestructuringPattern(context, destructuringKindFromDeclarationType(declarationType), exportType, nullptr, nullptr, assignmentContext);
 871             failIfFalse(pattern, &quot;Cannot parse this destructuring pattern&quot;);
 872             hasInitializer = match(EQUAL);
 873             failIfTrue(declarationListContext == VarDeclarationContext &amp;&amp; !hasInitializer, &quot;Expected an initializer in destructuring variable declaration&quot;);
 874             lastPattern = pattern;
 875             if (hasInitializer) {
 876                 next(TreeBuilder::DontBuildStrings); // consume &#39;=&#39;
 877                 TreeExpression rhs = parseAssignmentExpression(context);
 878                 propagateError();
 879                 ASSERT(rhs);
 880                 node = context.createDestructuringAssignment(location, pattern, rhs);
 881                 lastInitializer = rhs;
 882             }
 883         }
 884 
 885         if (node) {
 886             if (!head)
 887                 head = node;
 888             else if (!tail) {
 889                 head = context.createCommaExpr(location, head);
 890                 tail = context.appendToCommaExpr(location, head, head, node);
 891             } else
 892                 tail = context.appendToCommaExpr(location, head, tail, node);
 893         }
 894     } while (match(COMMA));
 895     if (lastIdent)
 896         lastPattern = context.createBindingLocation(lastIdentToken.m_location, *lastIdent, lastIdentToken.m_startPosition, lastIdentToken.m_endPosition, assignmentContext);
 897 
 898     return head;
 899 }
 900 
 901 template &lt;typename LexerType&gt;
 902 bool Parser&lt;LexerType&gt;::declareRestOrNormalParameter(const Identifier&amp; name, const Identifier** duplicateIdentifier)
 903 {
 904     DeclarationResultMask declarationResult = declareParameter(&amp;name);
 905     if ((declarationResult &amp; DeclarationResult::InvalidStrictMode) &amp;&amp; strictMode()) {
 906         semanticFailIfTrue(isEvalOrArguments(&amp;name), &quot;Cannot destructure to a parameter name &#39;&quot;, name.impl(), &quot;&#39; in strict mode&quot;);
 907         if (m_parserState.lastFunctionName &amp;&amp; name == *m_parserState.lastFunctionName)
 908             semanticFail(&quot;Cannot declare a parameter named &#39;&quot;, name.impl(), &quot;&#39; as it shadows the name of a strict mode function&quot;);
 909         semanticFailureDueToKeyword(&quot;parameter name&quot;);
 910         if (!m_lexer-&gt;isReparsingFunction() &amp;&amp; hasDeclaredParameter(name))
 911             semanticFail(&quot;Cannot declare a parameter named &#39;&quot;, name.impl(), &quot;&#39; in strict mode as it has already been declared&quot;);
 912         semanticFail(&quot;Cannot declare a parameter named &#39;&quot;, name.impl(), &quot;&#39; in strict mode&quot;);
 913     }
 914     if (declarationResult &amp; DeclarationResult::InvalidDuplicateDeclaration) {
 915         // It&#39;s not always an error to define a duplicate parameter.
 916         // It&#39;s only an error when there are default parameter values or destructuring parameters.
 917         // We note this value now so we can check it later.
 918         if (duplicateIdentifier)
 919             *duplicateIdentifier = &amp;name;
 920     }
 921 
 922     return true;
 923 }
 924 
 925 template &lt;typename LexerType&gt;
 926 template &lt;class TreeBuilder&gt; TreeDestructuringPattern Parser&lt;LexerType&gt;::createBindingPattern(TreeBuilder&amp; context, DestructuringKind kind, ExportType exportType, const Identifier&amp; name, JSToken token, AssignmentContext bindingContext, const Identifier** duplicateIdentifier)
 927 {
 928     ASSERT(!name.isNull());
 929 
<a name="26" id="anc26"></a><span class="line-modified"> 930     ASSERT(name.impl()-&gt;isAtomic() || name.impl()-&gt;isSymbol());</span>
 931 
 932     switch (kind) {
 933     case DestructuringKind::DestructureToVariables: {
 934         DeclarationResultMask declarationResult = declareVariable(&amp;name);
 935         failIfTrueIfStrict(declarationResult &amp; DeclarationResult::InvalidStrictMode, &quot;Cannot declare a variable named &#39;&quot;, name.impl(), &quot;&#39; in strict mode&quot;);
 936         if (declarationResult &amp; DeclarationResult::InvalidDuplicateDeclaration)
 937             internalFailWithMessage(false, &quot;Cannot declare a var variable that shadows a let/const/class variable: &#39;&quot;, name.impl(), &quot;&#39;&quot;);
 938         break;
 939     }
 940 
 941     case DestructuringKind::DestructureToLet:
 942     case DestructuringKind::DestructureToConst:
 943     case DestructuringKind::DestructureToCatchParameters: {
 944         DeclarationResultMask declarationResult = declareVariable(&amp;name, kind == DestructuringKind::DestructureToConst ? DeclarationType::ConstDeclaration : DeclarationType::LetDeclaration);
 945         if (declarationResult != DeclarationResult::Valid) {
 946             failIfTrueIfStrict(declarationResult &amp; DeclarationResult::InvalidStrictMode, &quot;Cannot destructure to a variable named &#39;&quot;, name.impl(), &quot;&#39; in strict mode&quot;);
 947             failIfTrue(declarationResult &amp; DeclarationResult::InvalidDuplicateDeclaration, &quot;Cannot declare a lexical variable twice: &#39;&quot;, name.impl(), &quot;&#39;&quot;);
 948         }
 949         break;
 950     }
 951 
 952     case DestructuringKind::DestructureToParameters: {
 953         declareRestOrNormalParameter(name, duplicateIdentifier);
 954         propagateError();
 955         break;
 956     }
 957 
 958     case DestructuringKind::DestructureToExpressions: {
 959         break;
 960     }
 961     }
 962 
 963     if (exportType == ExportType::Exported) {
 964         semanticFailIfFalse(exportName(name), &quot;Cannot export a duplicate name &#39;&quot;, name.impl(), &quot;&#39;&quot;);
 965         m_moduleScopeData-&gt;exportBinding(name);
 966     }
 967     return context.createBindingLocation(token.m_location, name, token.m_startPosition, token.m_endPosition, bindingContext);
 968 }
 969 
 970 template &lt;typename LexerType&gt;
 971 template &lt;class TreeBuilder&gt; NEVER_INLINE TreeDestructuringPattern Parser&lt;LexerType&gt;::createAssignmentElement(TreeBuilder&amp; context, TreeExpression&amp; assignmentTarget, const JSTextPosition&amp; startPosition, const JSTextPosition&amp; endPosition)
 972 {
 973     return context.createAssignmentElement(assignmentTarget, startPosition, endPosition);
 974 }
 975 
 976 template &lt;typename LexerType&gt;
 977 template &lt;class TreeBuilder&gt; TreeSourceElements Parser&lt;LexerType&gt;::parseArrowFunctionSingleExpressionBodySourceElements(TreeBuilder&amp; context)
 978 {
 979     ASSERT(!match(OPENBRACE));
 980 
 981     JSTokenLocation location(tokenLocation());
 982     JSTextPosition start = tokenStartPosition();
 983 
 984     failIfStackOverflow();
 985     TreeExpression expr = parseAssignmentExpression(context);
 986     failIfFalse(expr, &quot;Cannot parse the arrow function expression&quot;);
 987 
 988     context.setEndOffset(expr, m_lastTokenEndPosition.offset);
 989 
 990     JSTextPosition end = tokenEndPosition();
 991 
 992     TreeSourceElements sourceElements = context.createSourceElements();
 993     TreeStatement body = context.createReturnStatement(location, expr, start, end);
 994     context.setEndOffset(body, m_lastTokenEndPosition.offset);
 995     recordPauseLocation(context.breakpointLocation(body));
 996     context.appendStatement(sourceElements, body);
 997 
 998     return sourceElements;
 999 }
1000 
1001 template &lt;typename LexerType&gt;
1002 template &lt;class TreeBuilder&gt; TreeDestructuringPattern Parser&lt;LexerType&gt;::tryParseDestructuringPatternExpression(TreeBuilder&amp; context, AssignmentContext bindingContext)
1003 {
1004     return parseDestructuringPattern(context, DestructuringKind::DestructureToExpressions, ExportType::NotExported, nullptr, nullptr, bindingContext);
1005 }
1006 
1007 template &lt;typename LexerType&gt;
1008 template &lt;class TreeBuilder&gt; TreeDestructuringPattern Parser&lt;LexerType&gt;::parseBindingOrAssignmentElement(TreeBuilder&amp; context, DestructuringKind kind, ExportType exportType, const Identifier** duplicateIdentifier, bool* hasDestructuringPattern, AssignmentContext bindingContext, int depth)
1009 {
1010     if (kind == DestructuringKind::DestructureToExpressions)
1011         return parseAssignmentElement(context, kind, exportType, duplicateIdentifier, hasDestructuringPattern, bindingContext, depth);
1012     return parseDestructuringPattern(context, kind, exportType, duplicateIdentifier, hasDestructuringPattern, bindingContext, depth);
1013 }
1014 
1015 template &lt;typename LexerType&gt;
1016 template &lt;class TreeBuilder&gt; TreeDestructuringPattern Parser&lt;LexerType&gt;::parseObjectRestAssignmentElement(TreeBuilder&amp; context)
1017 {
1018     JSTextPosition startPosition = tokenStartPosition();
1019     auto element = parseMemberExpression(context);
1020 
1021     if (!element || !context.isAssignmentLocation(element)) {
1022         reclassifyExpressionError(ErrorIndicatesPattern, ErrorIndicatesNothing);
1023         semanticFail(&quot;Invalid destructuring assignment target&quot;);
1024     }
1025 
1026     if (strictMode() &amp;&amp; m_parserState.lastIdentifier &amp;&amp; context.isResolve(element)) {
<a name="27" id="anc27"></a><span class="line-modified">1027         bool isEvalOrArguments = m_vm-&gt;propertyNames-&gt;eval == *m_parserState.lastIdentifier || m_vm-&gt;propertyNames-&gt;arguments == *m_parserState.lastIdentifier;</span>
1028         if (isEvalOrArguments &amp;&amp; strictMode())
1029             reclassifyExpressionError(ErrorIndicatesPattern, ErrorIndicatesNothing);
1030         failIfTrueIfStrict(isEvalOrArguments, &quot;Cannot modify &#39;&quot;, m_parserState.lastIdentifier-&gt;impl(), &quot;&#39; in strict mode&quot;);
1031     }
1032 
1033     return createAssignmentElement(context, element, startPosition, lastTokenEndPosition());
1034 }
1035 
1036 template &lt;typename LexerType&gt;
1037 template &lt;class TreeBuilder&gt; TreeDestructuringPattern Parser&lt;LexerType&gt;::parseAssignmentElement(TreeBuilder&amp; context, DestructuringKind kind, ExportType exportType, const Identifier** duplicateIdentifier, bool* hasDestructuringPattern, AssignmentContext bindingContext, int depth)
1038 {
1039     TreeDestructuringPattern assignmentTarget = 0;
1040 
1041     if (match(OPENBRACE) || match(OPENBRACKET)) {
1042         SavePoint savePoint = createSavePoint();
1043         assignmentTarget = parseDestructuringPattern(context, kind, exportType, duplicateIdentifier, hasDestructuringPattern, bindingContext, depth);
1044         if (assignmentTarget &amp;&amp; !match(DOT) &amp;&amp; !match(OPENBRACKET) &amp;&amp; !match(OPENPAREN) &amp;&amp; !match(BACKQUOTE))
1045             return assignmentTarget;
1046         restoreSavePoint(savePoint);
1047     }
1048 
1049     JSTextPosition startPosition = tokenStartPosition();
1050     auto element = parseMemberExpression(context);
1051 
1052     semanticFailIfFalse(element &amp;&amp; context.isAssignmentLocation(element), &quot;Invalid destructuring assignment target&quot;);
1053 
1054     if (strictMode() &amp;&amp; m_parserState.lastIdentifier &amp;&amp; context.isResolve(element)) {
<a name="28" id="anc28"></a><span class="line-modified">1055         bool isEvalOrArguments = m_vm-&gt;propertyNames-&gt;eval == *m_parserState.lastIdentifier || m_vm-&gt;propertyNames-&gt;arguments == *m_parserState.lastIdentifier;</span>
1056         failIfTrueIfStrict(isEvalOrArguments, &quot;Cannot modify &#39;&quot;, m_parserState.lastIdentifier-&gt;impl(), &quot;&#39; in strict mode&quot;);
1057     }
1058 
1059     return createAssignmentElement(context, element, startPosition, lastTokenEndPosition());
1060 }
1061 
1062 static const char* destructuringKindToVariableKindName(DestructuringKind kind)
1063 {
1064     switch (kind) {
1065     case DestructuringKind::DestructureToLet:
1066     case DestructuringKind::DestructureToConst:
1067         return &quot;lexical variable name&quot;;
1068     case DestructuringKind::DestructureToVariables:
1069         return &quot;variable name&quot;;
1070     case DestructuringKind::DestructureToParameters:
1071         return &quot;parameter name&quot;;
1072     case DestructuringKind::DestructureToCatchParameters:
1073         return &quot;catch parameter name&quot;;
1074     case DestructuringKind::DestructureToExpressions:
1075         return &quot;expression name&quot;;
1076     }
1077     RELEASE_ASSERT_NOT_REACHED();
1078     return &quot;invalid&quot;;
1079 }
1080 
1081 template &lt;typename LexerType&gt;
1082 template &lt;class TreeBuilder&gt; TreeDestructuringPattern Parser&lt;LexerType&gt;::parseObjectRestElement(TreeBuilder&amp; context, DestructuringKind kind, ExportType exportType, const Identifier** duplicateIdentifier, AssignmentContext bindingContext)
1083 {
1084     ASSERT(kind != DestructuringKind::DestructureToExpressions);
1085     failIfStackOverflow();
1086     TreeDestructuringPattern pattern;
1087 
1088     if (!matchSpecIdentifier()) {
1089         semanticFailureDueToKeyword(destructuringKindToVariableKindName(kind));
1090         failWithMessage(&quot;Expected a binding element&quot;);
1091     }
1092     failIfTrue(match(LET) &amp;&amp; (kind == DestructuringKind::DestructureToLet || kind == DestructuringKind::DestructureToConst), &quot;Cannot use &#39;let&#39; as an identifier name for a LexicalDeclaration&quot;);
1093     semanticFailIfTrue(isDisallowedIdentifierAwait(m_token), &quot;Cannot use &#39;await&#39; as a &quot;, destructuringKindToVariableKindName(kind), &quot; &quot;, disallowedIdentifierAwaitReason());
1094     pattern = createBindingPattern(context, kind, exportType, *m_token.m_data.ident, m_token, bindingContext, duplicateIdentifier);
1095     next();
1096     return pattern;
1097 }
1098 
1099 template &lt;typename LexerType&gt;
1100 template &lt;class TreeBuilder&gt; TreeDestructuringPattern Parser&lt;LexerType&gt;::parseObjectRestBindingOrAssignmentElement(TreeBuilder&amp; context, DestructuringKind kind, ExportType exportType, const Identifier** duplicateIdentifier, AssignmentContext bindingContext)
1101 {
1102     if (kind == DestructuringKind::DestructureToExpressions)
1103         return parseObjectRestAssignmentElement(context);
1104     return parseObjectRestElement(context, kind, exportType, duplicateIdentifier, bindingContext);
1105 }
1106 
1107 template &lt;typename LexerType&gt;
1108 template &lt;class TreeBuilder&gt; TreeDestructuringPattern Parser&lt;LexerType&gt;::parseDestructuringPattern(TreeBuilder&amp; context, DestructuringKind kind, ExportType exportType, const Identifier** duplicateIdentifier, bool* hasDestructuringPattern, AssignmentContext bindingContext, int depth)
1109 {
1110     failIfStackOverflow();
1111     int nonLHSCount = m_parserState.nonLHSCount;
1112     TreeDestructuringPattern pattern;
1113     switch (m_token.m_type) {
1114     case OPENBRACKET: {
1115         JSTextPosition divotStart = tokenStartPosition();
1116         auto arrayPattern = context.createArrayPattern(m_token.m_location);
1117         next();
1118 
1119         if (hasDestructuringPattern)
1120             *hasDestructuringPattern = true;
1121 
1122         bool restElementWasFound = false;
1123 
1124         do {
1125             while (match(COMMA)) {
1126                 context.appendArrayPatternSkipEntry(arrayPattern, m_token.m_location);
1127                 next();
1128             }
1129             propagateError();
1130 
1131             if (match(CLOSEBRACKET))
1132                 break;
1133 
1134             if (UNLIKELY(match(DOTDOTDOT))) {
1135                 JSTokenLocation location = m_token.m_location;
1136                 next();
1137                 auto innerPattern = parseBindingOrAssignmentElement(context, kind, exportType, duplicateIdentifier, hasDestructuringPattern, bindingContext, depth + 1);
1138                 if (kind == DestructuringKind::DestructureToExpressions &amp;&amp; !innerPattern)
1139                     return 0;
1140                 failIfFalse(innerPattern, &quot;Cannot parse this destructuring pattern&quot;);
1141                 context.appendArrayPatternRestEntry(arrayPattern, location, innerPattern);
1142                 restElementWasFound = true;
1143                 break;
1144             }
1145 
1146             JSTokenLocation location = m_token.m_location;
1147             auto innerPattern = parseBindingOrAssignmentElement(context, kind, exportType, duplicateIdentifier, hasDestructuringPattern, bindingContext, depth + 1);
1148             if (kind == DestructuringKind::DestructureToExpressions &amp;&amp; !innerPattern)
1149                 return 0;
1150             failIfFalse(innerPattern, &quot;Cannot parse this destructuring pattern&quot;);
1151             TreeExpression defaultValue = parseDefaultValueForDestructuringPattern(context);
1152             propagateError();
1153             context.appendArrayPatternEntry(arrayPattern, location, innerPattern, defaultValue);
1154         } while (consume(COMMA));
1155 
1156         consumeOrFail(CLOSEBRACKET, restElementWasFound ? &quot;Expected a closing &#39;]&#39; following a rest element destructuring pattern&quot; : &quot;Expected either a closing &#39;]&#39; or a &#39;,&#39; following an element destructuring pattern&quot;);
1157         context.finishArrayPattern(arrayPattern, divotStart, divotStart, lastTokenEndPosition());
1158         pattern = arrayPattern;
1159         break;
1160     }
1161     case OPENBRACE: {
1162         auto objectPattern = context.createObjectPattern(m_token.m_location);
1163         next();
1164 
1165         if (hasDestructuringPattern)
1166             *hasDestructuringPattern = true;
1167 
1168         bool restElementWasFound = false;
1169 
1170         do {
1171             bool wasString = false;
1172 
1173             if (match(CLOSEBRACE))
1174                 break;
1175 
1176             if (match(DOTDOTDOT)) {
1177                 JSTokenLocation location = m_token.m_location;
1178                 next();
1179                 auto innerPattern = parseObjectRestBindingOrAssignmentElement(context, kind, exportType, duplicateIdentifier, bindingContext);
1180                 propagateError();
1181                 if (!innerPattern)
1182                     return 0;
<a name="29" id="anc29"></a><span class="line-modified">1183                 context.appendObjectPatternRestEntry(*m_vm, objectPattern, location, innerPattern);</span>
1184                 restElementWasFound = true;
1185                 context.setContainsObjectRestElement(objectPattern, restElementWasFound);
1186                 break;
1187             }
1188 
1189             const Identifier* propertyName = nullptr;
1190             TreeExpression propertyExpression = 0;
1191             TreeDestructuringPattern innerPattern = 0;
1192             JSTokenLocation location = m_token.m_location;
1193             if (matchSpecIdentifier()) {
1194                 failIfTrue(match(LET) &amp;&amp; (kind == DestructuringKind::DestructureToLet || kind == DestructuringKind::DestructureToConst), &quot;Cannot use &#39;let&#39; as an identifier name for a LexicalDeclaration&quot;);
1195                 propertyName = m_token.m_data.ident;
1196                 JSToken identifierToken = m_token;
1197                 next();
1198                 if (consume(COLON))
1199                     innerPattern = parseBindingOrAssignmentElement(context, kind, exportType, duplicateIdentifier, hasDestructuringPattern, bindingContext, depth + 1);
1200                 else {
1201                     if (kind == DestructuringKind::DestructureToExpressions) {
<a name="30" id="anc30"></a><span class="line-modified">1202                         bool isEvalOrArguments = m_vm-&gt;propertyNames-&gt;eval == *propertyName || m_vm-&gt;propertyNames-&gt;arguments == *propertyName;</span>
1203                         if (isEvalOrArguments &amp;&amp; strictMode())
1204                             reclassifyExpressionError(ErrorIndicatesPattern, ErrorIndicatesNothing);
1205                         failIfTrueIfStrict(isEvalOrArguments, &quot;Cannot modify &#39;&quot;, propertyName-&gt;impl(), &quot;&#39; in strict mode&quot;);
1206                     }
1207                     semanticFailIfTrue(isDisallowedIdentifierAwait(identifierToken), &quot;Cannot use &#39;await&#39; as a &quot;, destructuringKindToVariableKindName(kind), &quot; &quot;, disallowedIdentifierAwaitReason());
1208                     innerPattern = createBindingPattern(context, kind, exportType, *propertyName, identifierToken, bindingContext, duplicateIdentifier);
1209                 }
1210             } else {
1211                 JSTokenType tokenType = m_token.m_type;
1212                 switch (m_token.m_type) {
1213                 case DOUBLE:
1214                 case INTEGER:
<a name="31" id="anc31"></a><span class="line-modified">1215                     propertyName = &amp;m_parserArena.identifierArena().makeNumericIdentifier(const_cast&lt;VM*&gt;(m_vm), m_token.m_data.doubleValue);</span>
1216                     break;
1217                 case STRING:
1218                     propertyName = m_token.m_data.ident;
1219                     wasString = true;
1220                     break;
1221                 case OPENBRACKET:
1222                     next();
1223                     propertyExpression = parseAssignmentExpression(context);
1224                     failIfFalse(propertyExpression, &quot;Cannot parse computed property name&quot;);
1225                     matchOrFail(CLOSEBRACKET, &quot;Expected &#39;]&#39; to end end a computed property name&quot;);
1226                     break;
1227                 default:
1228                     if (m_token.m_type != RESERVED &amp;&amp; m_token.m_type != RESERVED_IF_STRICT &amp;&amp; !(m_token.m_type &amp; KeywordTokenFlag)) {
1229                         if (kind == DestructuringKind::DestructureToExpressions)
1230                             return 0;
1231                         failWithMessage(&quot;Expected a property name&quot;);
1232                     }
1233                     propertyName = m_token.m_data.ident;
1234                     break;
1235                 }
1236                 next();
1237                 if (!consume(COLON)) {
1238                     if (kind == DestructuringKind::DestructureToExpressions)
1239                         return 0;
1240                     semanticFailIfTrue(tokenType == RESERVED, &quot;Cannot use abbreviated destructuring syntax for reserved name &#39;&quot;, propertyName-&gt;impl(), &quot;&#39;&quot;);
1241                     semanticFailIfTrue(tokenType == RESERVED_IF_STRICT, &quot;Cannot use abbreviated destructuring syntax for reserved name &#39;&quot;, propertyName-&gt;impl(), &quot;&#39; in strict mode&quot;);
1242                     semanticFailIfTrue(tokenType &amp; KeywordTokenFlag, &quot;Cannot use abbreviated destructuring syntax for keyword &#39;&quot;, propertyName-&gt;impl(), &quot;&#39;&quot;);
1243 
1244                     failWithMessage(&quot;Expected a &#39;:&#39; prior to a named destructuring property&quot;);
1245                 }
1246                 innerPattern = parseBindingOrAssignmentElement(context, kind, exportType, duplicateIdentifier, hasDestructuringPattern, bindingContext, depth + 1);
1247             }
1248             if (kind == DestructuringKind::DestructureToExpressions &amp;&amp; !innerPattern)
1249                 return 0;
1250             failIfFalse(innerPattern, &quot;Cannot parse this destructuring pattern&quot;);
1251             TreeExpression defaultValue = parseDefaultValueForDestructuringPattern(context);
1252             propagateError();
1253             if (propertyExpression) {
<a name="32" id="anc32"></a><span class="line-modified">1254                 context.appendObjectPatternEntry(*m_vm, objectPattern, location, propertyExpression, innerPattern, defaultValue);</span>
1255                 context.setContainsComputedProperty(objectPattern, true);
1256             } else {
1257                 ASSERT(propertyName);
1258                 context.appendObjectPatternEntry(objectPattern, location, wasString, *propertyName, innerPattern, defaultValue);
1259             }
1260         } while (consume(COMMA));
1261 
1262         if (kind == DestructuringKind::DestructureToExpressions &amp;&amp; !match(CLOSEBRACE))
1263             return 0;
1264         consumeOrFail(CLOSEBRACE, restElementWasFound ? &quot;Expected a closing &#39;}&#39; following a rest element destructuring pattern&quot; : &quot;Expected either a closing &#39;}&#39; or an &#39;,&#39; after a property destructuring pattern&quot;);
1265         pattern = objectPattern;
1266         break;
1267     }
1268 
1269     default: {
1270         if (!matchSpecIdentifier()) {
1271             if (kind == DestructuringKind::DestructureToExpressions)
1272                 return 0;
1273             semanticFailureDueToKeyword(destructuringKindToVariableKindName(kind));
1274             failWithMessage(&quot;Expected a parameter pattern or a &#39;)&#39; in parameter list&quot;);
1275         }
1276         failIfTrue(match(LET) &amp;&amp; (kind == DestructuringKind::DestructureToLet || kind == DestructuringKind::DestructureToConst), &quot;Cannot use &#39;let&#39; as an identifier name for a LexicalDeclaration&quot;);
1277         semanticFailIfTrue(isDisallowedIdentifierAwait(m_token), &quot;Cannot use &#39;await&#39; as a &quot;, destructuringKindToVariableKindName(kind), &quot; &quot;, disallowedIdentifierAwaitReason());
1278         pattern = createBindingPattern(context, kind, exportType, *m_token.m_data.ident, m_token, bindingContext, duplicateIdentifier);
1279         next();
1280         break;
1281     }
1282     }
1283     m_parserState.nonLHSCount = nonLHSCount;
1284     return pattern;
1285 }
1286 
1287 template &lt;typename LexerType&gt;
1288 template &lt;class TreeBuilder&gt; TreeExpression Parser&lt;LexerType&gt;::parseDefaultValueForDestructuringPattern(TreeBuilder&amp; context)
1289 {
1290     if (!match(EQUAL))
1291         return 0;
1292 
1293     next(TreeBuilder::DontBuildStrings); // consume &#39;=&#39;
1294     return parseAssignmentExpression(context);
1295 }
1296 
1297 template &lt;typename LexerType&gt;
1298 template &lt;class TreeBuilder&gt; TreeStatement Parser&lt;LexerType&gt;::parseForStatement(TreeBuilder&amp; context)
1299 {
1300     ASSERT(match(FOR));
1301     JSTokenLocation location(tokenLocation());
1302     int startLine = tokenLine();
1303     bool isAwaitFor = false;
1304     next();
1305 
1306     DepthManager statementDepth(&amp;m_statementDepth);
1307     m_statementDepth++;
1308 
1309     if (match(AWAIT)) {
<a name="33" id="anc33"></a><span class="line-modified">1310         semanticFailIfFalse(currentScope()-&gt;isAsyncFunction(), &quot;for-await-of can&#39;t be used only in async function or async generator.&quot;);</span>
1311         isAwaitFor = true;
1312         next();
1313     }
1314 
1315     handleProductionOrFail(OPENPAREN, &quot;(&quot;, &quot;start&quot;, &quot;for-loop header&quot;);
1316     int nonLHSCount = m_parserState.nonLHSCount;
1317     int declarations = 0;
1318     JSTokenLocation declLocation(tokenLocation());
1319     JSTextPosition declsStart;
1320     JSTextPosition declsEnd;
1321     TreeExpression decls = 0;
1322     TreeDestructuringPattern pattern = 0;
1323     bool isVarDeclaraton = match(VAR);
1324     bool isLetDeclaration = match(LET);
1325     bool isConstDeclaration = match(CONSTTOKEN);
1326     bool forLoopConstDoesNotHaveInitializer = false;
1327 
1328     VariableEnvironment dummySet;
1329     VariableEnvironment* lexicalVariables = nullptr;
1330     AutoCleanupLexicalScope lexicalScope;
1331 
1332     auto gatherLexicalVariablesIfNecessary = [&amp;] {
1333         if (isLetDeclaration || isConstDeclaration) {
1334             ScopeRef scope = lexicalScope.scope();
1335             lexicalVariables = &amp;scope-&gt;finalizeLexicalEnvironment();
1336         } else
1337             lexicalVariables = &amp;dummySet;
1338     };
1339 
1340     auto popLexicalScopeIfNecessary = [&amp;] {
1341         if (isLetDeclaration || isConstDeclaration)
1342             popScope(lexicalScope, TreeBuilder::NeedsFreeVariableInfo);
1343     };
1344 
1345     if (isVarDeclaraton || isLetDeclaration || isConstDeclaration) {
1346         /*
1347          for (var/let/const IDENT in/of expression) statement
1348          for (var/let/const varDeclarationList; expressionOpt; expressionOpt)
1349          */
1350         if (isLetDeclaration || isConstDeclaration) {
1351             ScopeRef newScope = pushScope();
1352             newScope-&gt;setIsLexicalScope();
1353             newScope-&gt;preventVarDeclarations();
1354             lexicalScope.setIsValid(newScope, this);
1355         }
1356 
1357         TreeDestructuringPattern forInTarget = 0;
1358         TreeExpression forInInitializer = 0;
1359         m_allowsIn = false;
1360         JSTextPosition initStart;
1361         JSTextPosition initEnd;
1362         DeclarationType declarationType;
1363         if (isVarDeclaraton)
1364             declarationType = DeclarationType::VarDeclaration;
1365         else if (isLetDeclaration)
1366             declarationType = DeclarationType::LetDeclaration;
1367         else if (isConstDeclaration)
1368             declarationType = DeclarationType::ConstDeclaration;
1369         else
1370             RELEASE_ASSERT_NOT_REACHED();
1371         decls = parseVariableDeclarationList(context, declarations, forInTarget, forInInitializer, declsStart, initStart, initEnd, ForLoopContext, declarationType, ExportType::NotExported, forLoopConstDoesNotHaveInitializer);
1372         m_allowsIn = true;
1373         propagateError();
1374 
1375         // Remainder of a standard for loop is handled identically
1376         if (match(SEMICOLON))
1377             goto standardForLoop;
1378 
1379         failIfFalse(declarations == 1, &quot;can only declare a single variable in an enumeration&quot;);
1380 
1381         // Handle for-in with var declaration
1382         JSTextPosition inLocation = tokenStartPosition();
1383         bool isOfEnumeration = false;
1384         if (!match(INTOKEN)) {
<a name="34" id="anc34"></a><span class="line-modified">1385             failIfFalse(matchContextualKeyword(m_vm-&gt;propertyNames-&gt;of), &quot;Expected either &#39;in&#39; or &#39;of&#39; in enumeration syntax&quot;);</span>
1386             isOfEnumeration = true;
1387             next();
1388         } else {
1389             failIfFalse(!isAwaitFor, &quot;Expected &#39;of&#39; in for-await syntax&quot;);
1390             next();
1391         }
1392 
1393         bool hasAnyAssignments = !!forInInitializer;
1394         if (hasAnyAssignments) {
1395             if (isOfEnumeration)
1396                 internalFailWithMessage(false, &quot;Cannot assign to the loop variable inside a for-of loop header&quot;);
1397             if (strictMode() || (isLetDeclaration || isConstDeclaration) || !context.isBindingNode(forInTarget))
1398                 internalFailWithMessage(false, &quot;Cannot assign to the loop variable inside a for-in loop header&quot;);
1399         }
1400         TreeExpression expr = parseExpression(context);
1401         failIfFalse(expr, &quot;Expected expression to enumerate&quot;);
1402         recordPauseLocation(context.breakpointLocation(expr));
1403         JSTextPosition exprEnd = lastTokenEndPosition();
1404 
1405         int endLine = tokenLine();
1406 
1407         handleProductionOrFail(CLOSEPAREN, &quot;)&quot;, &quot;end&quot;, (isOfEnumeration ? &quot;for-of header&quot; : &quot;for-in header&quot;));
1408 
1409         const Identifier* unused = 0;
1410         startLoop();
1411         TreeStatement statement = parseStatement(context, unused);
1412         endLoop();
1413         failIfFalse(statement, &quot;Expected statement as body of for-&quot;, isOfEnumeration ? &quot;of&quot; : &quot;in&quot;, &quot; statement&quot;);
1414         gatherLexicalVariablesIfNecessary();
1415         TreeStatement result;
1416         if (isOfEnumeration)
1417             result = context.createForOfLoop(isAwaitFor, location, forInTarget, expr, statement, declLocation, declsStart, inLocation, exprEnd, startLine, endLine, *lexicalVariables);
1418         else {
1419             ASSERT(!isAwaitFor);
1420             if (isVarDeclaraton &amp;&amp; forInInitializer)
1421                 result = context.createForInLoop(location, decls, expr, statement, declLocation, declsStart, inLocation, exprEnd, startLine, endLine, *lexicalVariables);
1422             else
1423                 result = context.createForInLoop(location, forInTarget, expr, statement, declLocation, declsStart, inLocation, exprEnd, startLine, endLine, *lexicalVariables);
1424         }
1425         popLexicalScopeIfNecessary();
1426         return result;
1427     }
1428 
1429     if (!match(SEMICOLON)) {
1430         if (match(OPENBRACE) || match(OPENBRACKET)) {
1431             SavePoint savePoint = createSavePoint();
1432             declsStart = tokenStartPosition();
1433             pattern = tryParseDestructuringPatternExpression(context, AssignmentContext::DeclarationStatement);
1434             declsEnd = lastTokenEndPosition();
<a name="35" id="anc35"></a><span class="line-modified">1435             if (pattern &amp;&amp; (match(INTOKEN) || matchContextualKeyword(m_vm-&gt;propertyNames-&gt;of)))</span>
1436                 goto enumerationLoop;
1437             pattern = TreeDestructuringPattern(0);
1438             restoreSavePoint(savePoint);
1439         }
1440         m_allowsIn = false;
1441         declsStart = tokenStartPosition();
1442         decls = parseExpression(context);
1443         declsEnd = lastTokenEndPosition();
1444         m_allowsIn = true;
1445         failIfFalse(decls, &quot;Cannot parse for loop declarations&quot;);
1446         recordPauseLocation(context.breakpointLocation(decls));
1447     }
1448 
1449     if (match(SEMICOLON)) {
1450     standardForLoop:
1451         failIfFalse(!isAwaitFor, &quot;Unexpected a &#39;;&#39; in for-await-of header&quot;);
1452         // Standard for loop
1453         if (decls)
1454             recordPauseLocation(context.breakpointLocation(decls));
1455         next();
1456         TreeExpression condition = 0;
1457         failIfTrue(forLoopConstDoesNotHaveInitializer &amp;&amp; isConstDeclaration, &quot;const variables in for loops must have initializers&quot;);
1458 
1459         if (!match(SEMICOLON)) {
1460             condition = parseExpression(context);
1461             failIfFalse(condition, &quot;Cannot parse for loop condition expression&quot;);
1462             recordPauseLocation(context.breakpointLocation(condition));
1463         }
1464         consumeOrFail(SEMICOLON, &quot;Expected a &#39;;&#39; after the for loop condition expression&quot;);
1465 
1466         TreeExpression increment = 0;
1467         if (!match(CLOSEPAREN)) {
1468             increment = parseExpression(context);
1469             failIfFalse(increment, &quot;Cannot parse for loop iteration expression&quot;);
1470             recordPauseLocation(context.breakpointLocation(increment));
1471         }
1472         int endLine = tokenLine();
1473         handleProductionOrFail(CLOSEPAREN, &quot;)&quot;, &quot;end&quot;, &quot;for-loop header&quot;);
1474         const Identifier* unused = 0;
1475         startLoop();
1476         TreeStatement statement = parseStatement(context, unused);
1477         endLoop();
1478         failIfFalse(statement, &quot;Expected a statement as the body of a for loop&quot;);
1479         gatherLexicalVariablesIfNecessary();
1480         TreeStatement result = context.createForLoop(location, decls, condition, increment, statement, startLine, endLine, *lexicalVariables);
1481         popLexicalScopeIfNecessary();
1482         return result;
1483     }
1484 
1485     // For-in and For-of loop
1486 enumerationLoop:
1487     failIfFalse(nonLHSCount == m_parserState.nonLHSCount, &quot;Expected a reference on the left hand side of an enumeration statement&quot;);
1488     bool isOfEnumeration = false;
1489     if (!match(INTOKEN)) {
<a name="36" id="anc36"></a><span class="line-modified">1490         failIfFalse(matchContextualKeyword(m_vm-&gt;propertyNames-&gt;of), &quot;Expected either &#39;in&#39; or &#39;of&#39; in enumeration syntax&quot;);</span>
1491         isOfEnumeration = true;
1492         next();
1493     } else {
1494         failIfFalse(!isAwaitFor, &quot;Expected &#39;of&#39; in for-await syntax&quot;);
1495         next();
1496     }
1497 
1498     TreeExpression expr = parseExpression(context);
1499     failIfFalse(expr, &quot;Cannot parse subject for-&quot;, isOfEnumeration ? &quot;of&quot; : &quot;in&quot;, &quot; statement&quot;);
1500     recordPauseLocation(context.breakpointLocation(expr));
1501     JSTextPosition exprEnd = lastTokenEndPosition();
1502     int endLine = tokenLine();
1503 
1504     handleProductionOrFail(CLOSEPAREN, &quot;)&quot;, &quot;end&quot;, (isOfEnumeration ? &quot;for-of header&quot; : &quot;for-in header&quot;));
1505     const Identifier* unused = 0;
1506     startLoop();
1507     TreeStatement statement = parseStatement(context, unused);
1508     endLoop();
1509     failIfFalse(statement, &quot;Expected a statement as the body of a for-&quot;, isOfEnumeration ? &quot;of&quot; : &quot;in&quot;, &quot;loop&quot;);
1510     gatherLexicalVariablesIfNecessary();
1511     TreeStatement result;
1512     if (pattern) {
1513         ASSERT(!decls);
1514         if (isOfEnumeration)
1515             result = context.createForOfLoop(isAwaitFor, location, pattern, expr, statement, declLocation, declsStart, declsEnd, exprEnd, startLine, endLine, *lexicalVariables);
1516         else {
1517             ASSERT(!isAwaitFor);
1518             result = context.createForInLoop(location, pattern, expr, statement, declLocation, declsStart, declsEnd, exprEnd, startLine, endLine, *lexicalVariables);
1519         }
1520 
1521         popLexicalScopeIfNecessary();
1522         return result;
1523     }
1524     if (isOfEnumeration)
1525         result = context.createForOfLoop(isAwaitFor, location, decls, expr, statement, declLocation, declsStart, declsEnd, exprEnd, startLine, endLine, *lexicalVariables);
1526     else {
1527         ASSERT(!isAwaitFor);
1528         result = context.createForInLoop(location, decls, expr, statement, declLocation, declsStart, declsEnd, exprEnd, startLine, endLine, *lexicalVariables);
1529     }
1530     popLexicalScopeIfNecessary();
1531     return result;
1532 }
1533 
1534 template &lt;typename LexerType&gt;
1535 template &lt;class TreeBuilder&gt; TreeStatement Parser&lt;LexerType&gt;::parseBreakStatement(TreeBuilder&amp; context)
1536 {
1537     ASSERT(match(BREAK));
1538     JSTokenLocation location(tokenLocation());
1539     JSTextPosition start = tokenStartPosition();
1540     JSTextPosition end = tokenEndPosition();
1541     next();
1542 
1543     if (autoSemiColon()) {
1544         semanticFailIfFalse(breakIsValid(), &quot;&#39;break&#39; is only valid inside a switch or loop statement&quot;);
<a name="37" id="anc37"></a><span class="line-modified">1545         return context.createBreakStatement(location, &amp;m_vm-&gt;propertyNames-&gt;nullIdentifier, start, end);</span>
1546     }
1547     failIfFalse(matchSpecIdentifier(), &quot;Expected an identifier as the target for a break statement&quot;);
1548     const Identifier* ident = m_token.m_data.ident;
1549     semanticFailIfFalse(getLabel(ident), &quot;Cannot use the undeclared label &#39;&quot;, ident-&gt;impl(), &quot;&#39;&quot;);
1550     end = tokenEndPosition();
1551     next();
1552     failIfFalse(autoSemiColon(), &quot;Expected a &#39;;&#39; following a targeted break statement&quot;);
1553     return context.createBreakStatement(location, ident, start, end);
1554 }
1555 
1556 template &lt;typename LexerType&gt;
1557 template &lt;class TreeBuilder&gt; TreeStatement Parser&lt;LexerType&gt;::parseContinueStatement(TreeBuilder&amp; context)
1558 {
1559     ASSERT(match(CONTINUE));
1560     JSTokenLocation location(tokenLocation());
1561     JSTextPosition start = tokenStartPosition();
1562     JSTextPosition end = tokenEndPosition();
1563     next();
1564 
1565     if (autoSemiColon()) {
1566         semanticFailIfFalse(continueIsValid(), &quot;&#39;continue&#39; is only valid inside a loop statement&quot;);
<a name="38" id="anc38"></a><span class="line-modified">1567         return context.createContinueStatement(location, &amp;m_vm-&gt;propertyNames-&gt;nullIdentifier, start, end);</span>
1568     }
1569     failIfFalse(matchSpecIdentifier(), &quot;Expected an identifier as the target for a continue statement&quot;);
1570     const Identifier* ident = m_token.m_data.ident;
1571     ScopeLabelInfo* label = getLabel(ident);
1572     semanticFailIfFalse(label, &quot;Cannot use the undeclared label &#39;&quot;, ident-&gt;impl(), &quot;&#39;&quot;);
1573     semanticFailIfFalse(label-&gt;isLoop, &quot;Cannot continue to the label &#39;&quot;, ident-&gt;impl(), &quot;&#39; as it is not targeting a loop&quot;);
1574     end = tokenEndPosition();
1575     next();
1576     failIfFalse(autoSemiColon(), &quot;Expected a &#39;;&#39; following a targeted continue statement&quot;);
1577     return context.createContinueStatement(location, ident, start, end);
1578 }
1579 
1580 template &lt;typename LexerType&gt;
1581 template &lt;class TreeBuilder&gt; TreeStatement Parser&lt;LexerType&gt;::parseReturnStatement(TreeBuilder&amp; context)
1582 {
1583     ASSERT(match(RETURN));
1584     JSTokenLocation location(tokenLocation());
1585     semanticFailIfFalse(currentScope()-&gt;isFunction(), &quot;Return statements are only valid inside functions&quot;);
1586     JSTextPosition start = tokenStartPosition();
1587     JSTextPosition end = tokenEndPosition();
1588     next();
1589     // We do the auto semicolon check before attempting to parse expression
1590     // as we need to ensure the a line break after the return correctly terminates
1591     // the statement
1592     if (match(SEMICOLON))
1593         end = tokenEndPosition();
1594 
1595     if (autoSemiColon())
1596         return context.createReturnStatement(location, 0, start, end);
1597     TreeExpression expr = parseExpression(context);
1598     failIfFalse(expr, &quot;Cannot parse the return expression&quot;);
1599     end = lastTokenEndPosition();
1600     if (match(SEMICOLON))
1601         end  = tokenEndPosition();
1602     if (!autoSemiColon())
1603         failWithMessage(&quot;Expected a &#39;;&#39; following a return statement&quot;);
1604     return context.createReturnStatement(location, expr, start, end);
1605 }
1606 
1607 template &lt;typename LexerType&gt;
1608 template &lt;class TreeBuilder&gt; TreeStatement Parser&lt;LexerType&gt;::parseThrowStatement(TreeBuilder&amp; context)
1609 {
1610     ASSERT(match(THROW));
1611     JSTokenLocation location(tokenLocation());
1612     JSTextPosition start = tokenStartPosition();
1613     next();
1614     failIfTrue(match(SEMICOLON), &quot;Expected expression after &#39;throw&#39;&quot;);
1615     semanticFailIfTrue(autoSemiColon(), &quot;Cannot have a newline after &#39;throw&#39;&quot;);
1616 
1617     TreeExpression expr = parseExpression(context);
1618     failIfFalse(expr, &quot;Cannot parse expression for throw statement&quot;);
1619     JSTextPosition end = lastTokenEndPosition();
1620     failIfFalse(autoSemiColon(), &quot;Expected a &#39;;&#39; after a throw statement&quot;);
1621 
1622     return context.createThrowStatement(location, expr, start, end);
1623 }
1624 
1625 template &lt;typename LexerType&gt;
1626 template &lt;class TreeBuilder&gt; TreeStatement Parser&lt;LexerType&gt;::parseWithStatement(TreeBuilder&amp; context)
1627 {
1628     ASSERT(match(WITH));
1629     JSTokenLocation location(tokenLocation());
1630     semanticFailIfTrue(strictMode(), &quot;&#39;with&#39; statements are not valid in strict mode&quot;);
1631     currentScope()-&gt;setNeedsFullActivation();
1632     int startLine = tokenLine();
1633     next();
1634 
1635     handleProductionOrFail(OPENPAREN, &quot;(&quot;, &quot;start&quot;, &quot;subject of a &#39;with&#39; statement&quot;);
1636     int start = tokenStart();
1637     TreeExpression expr = parseExpression(context);
1638     failIfFalse(expr, &quot;Cannot parse &#39;with&#39; subject expression&quot;);
1639     recordPauseLocation(context.breakpointLocation(expr));
1640     JSTextPosition end = lastTokenEndPosition();
1641     int endLine = tokenLine();
1642     handleProductionOrFail(CLOSEPAREN, &quot;)&quot;, &quot;start&quot;, &quot;subject of a &#39;with&#39; statement&quot;);
1643     const Identifier* unused = 0;
1644     TreeStatement statement = parseStatement(context, unused);
1645     failIfFalse(statement, &quot;A &#39;with&#39; statement must have a body&quot;);
1646 
1647     return context.createWithStatement(location, expr, statement, start, end, startLine, endLine);
1648 }
1649 
1650 template &lt;typename LexerType&gt;
1651 template &lt;class TreeBuilder&gt; TreeStatement Parser&lt;LexerType&gt;::parseSwitchStatement(TreeBuilder&amp; context)
1652 {
1653     ASSERT(match(SWITCH));
1654     JSTokenLocation location(tokenLocation());
1655     int startLine = tokenLine();
1656     next();
1657     handleProductionOrFail(OPENPAREN, &quot;(&quot;, &quot;start&quot;, &quot;subject of a &#39;switch&#39;&quot;);
1658     TreeExpression expr = parseExpression(context);
1659     failIfFalse(expr, &quot;Cannot parse switch subject expression&quot;);
1660     recordPauseLocation(context.breakpointLocation(expr));
1661     int endLine = tokenLine();
1662 
1663     handleProductionOrFail(CLOSEPAREN, &quot;)&quot;, &quot;end&quot;, &quot;subject of a &#39;switch&#39;&quot;);
1664     handleProductionOrFail(OPENBRACE, &quot;{&quot;, &quot;start&quot;, &quot;body of a &#39;switch&#39;&quot;);
1665     AutoPopScopeRef lexicalScope(this, pushScope());
1666     lexicalScope-&gt;setIsLexicalScope();
1667     lexicalScope-&gt;preventVarDeclarations();
1668     startSwitch();
1669     TreeClauseList firstClauses = parseSwitchClauses(context);
1670     propagateError();
1671 
1672     TreeClause defaultClause = parseSwitchDefaultClause(context);
1673     propagateError();
1674 
1675     TreeClauseList secondClauses = parseSwitchClauses(context);
1676     propagateError();
1677     endSwitch();
1678     handleProductionOrFail(CLOSEBRACE, &quot;}&quot;, &quot;end&quot;, &quot;body of a &#39;switch&#39;&quot;);
1679 
1680     TreeStatement result = context.createSwitchStatement(location, expr, firstClauses, defaultClause, secondClauses, startLine, endLine, lexicalScope-&gt;finalizeLexicalEnvironment(), lexicalScope-&gt;takeFunctionDeclarations());
1681     popScope(lexicalScope, TreeBuilder::NeedsFreeVariableInfo);
1682     return result;
1683 }
1684 
1685 template &lt;typename LexerType&gt;
1686 template &lt;class TreeBuilder&gt; TreeClauseList Parser&lt;LexerType&gt;::parseSwitchClauses(TreeBuilder&amp; context)
1687 {
1688     if (!match(CASE))
1689         return 0;
1690     unsigned startOffset = tokenStart();
1691     next();
1692     TreeExpression condition = parseExpression(context);
1693     failIfFalse(condition, &quot;Cannot parse switch clause&quot;);
1694     consumeOrFail(COLON, &quot;Expected a &#39;:&#39; after switch clause expression&quot;);
1695     TreeSourceElements statements = parseSourceElements(context, DontCheckForStrictMode);
1696     failIfFalse(statements, &quot;Cannot parse the body of a switch clause&quot;);
1697     TreeClause clause = context.createClause(condition, statements);
1698     context.setStartOffset(clause, startOffset);
1699     TreeClauseList clauseList = context.createClauseList(clause);
1700     TreeClauseList tail = clauseList;
1701 
1702     while (match(CASE)) {
1703         startOffset = tokenStart();
1704         next();
1705         TreeExpression condition = parseExpression(context);
1706         failIfFalse(condition, &quot;Cannot parse switch case expression&quot;);
1707         consumeOrFail(COLON, &quot;Expected a &#39;:&#39; after switch clause expression&quot;);
1708         TreeSourceElements statements = parseSourceElements(context, DontCheckForStrictMode);
1709         failIfFalse(statements, &quot;Cannot parse the body of a switch clause&quot;);
1710         clause = context.createClause(condition, statements);
1711         context.setStartOffset(clause, startOffset);
1712         tail = context.createClauseList(tail, clause);
1713     }
1714     return clauseList;
1715 }
1716 
1717 template &lt;typename LexerType&gt;
1718 template &lt;class TreeBuilder&gt; TreeClause Parser&lt;LexerType&gt;::parseSwitchDefaultClause(TreeBuilder&amp; context)
1719 {
1720     if (!match(DEFAULT))
1721         return 0;
1722     unsigned startOffset = tokenStart();
1723     next();
1724     consumeOrFail(COLON, &quot;Expected a &#39;:&#39; after switch default clause&quot;);
1725     TreeSourceElements statements = parseSourceElements(context, DontCheckForStrictMode);
1726     failIfFalse(statements, &quot;Cannot parse the body of a switch default clause&quot;);
1727     TreeClause result = context.createClause(0, statements);
1728     context.setStartOffset(result, startOffset);
1729     return result;
1730 }
1731 
1732 template &lt;typename LexerType&gt;
1733 template &lt;class TreeBuilder&gt; TreeStatement Parser&lt;LexerType&gt;::parseTryStatement(TreeBuilder&amp; context)
1734 {
1735     ASSERT(match(TRY));
1736     JSTokenLocation location(tokenLocation());
1737     TreeStatement tryBlock = 0;
1738     TreeDestructuringPattern catchPattern = 0;
1739     TreeStatement catchBlock = 0;
1740     TreeStatement finallyBlock = 0;
1741     int firstLine = tokenLine();
1742     next();
1743     matchOrFail(OPENBRACE, &quot;Expected a block statement as body of a try statement&quot;);
1744 
1745     tryBlock = parseBlockStatement(context);
1746     failIfFalse(tryBlock, &quot;Cannot parse the body of try block&quot;);
1747     int lastLine = m_lastTokenEndPosition.line;
1748     VariableEnvironment catchEnvironment;
1749     if (match(CATCH)) {
1750         next();
1751 
1752         if (match(OPENBRACE)) {
1753             catchBlock = parseBlockStatement(context);
1754             failIfFalse(catchBlock, &quot;Unable to parse &#39;catch&#39; block&quot;);
1755         } else {
1756             handleProductionOrFail(OPENPAREN, &quot;(&quot;, &quot;start&quot;, &quot;&#39;catch&#39; target&quot;);
1757             AutoPopScopeRef catchScope(this, pushScope());
1758             catchScope-&gt;setIsLexicalScope();
1759             catchScope-&gt;preventVarDeclarations();
1760             const Identifier* ident = nullptr;
1761             if (matchSpecIdentifier()) {
1762                 catchScope-&gt;setIsSimpleCatchParameterScope();
1763                 ident = m_token.m_data.ident;
1764                 catchPattern = context.createBindingLocation(m_token.m_location, *ident, m_token.m_startPosition, m_token.m_endPosition, AssignmentContext::DeclarationStatement);
1765                 next();
1766                 failIfTrueIfStrict(catchScope-&gt;declareLexicalVariable(ident, false) &amp; DeclarationResult::InvalidStrictMode, &quot;Cannot declare a catch variable named &#39;&quot;, ident-&gt;impl(), &quot;&#39; in strict mode&quot;);
1767             } else {
1768                 catchPattern = parseDestructuringPattern(context, DestructuringKind::DestructureToCatchParameters, ExportType::NotExported);
1769                 failIfFalse(catchPattern, &quot;Cannot parse this destructuring pattern&quot;);
1770             }
1771             handleProductionOrFail(CLOSEPAREN, &quot;)&quot;, &quot;end&quot;, &quot;&#39;catch&#39; target&quot;);
1772             matchOrFail(OPENBRACE, &quot;Expected exception handler to be a block statement&quot;);
1773             catchBlock = parseBlockStatement(context);
1774             failIfFalse(catchBlock, &quot;Unable to parse &#39;catch&#39; block&quot;);
1775             catchEnvironment = catchScope-&gt;finalizeLexicalEnvironment();
1776             RELEASE_ASSERT(!ident || (catchEnvironment.size() == 1 &amp;&amp; catchEnvironment.contains(ident-&gt;impl())));
1777             popScope(catchScope, TreeBuilder::NeedsFreeVariableInfo);
1778         }
1779     }
1780 
1781     if (match(FINALLY)) {
1782         next();
1783         matchOrFail(OPENBRACE, &quot;Expected block statement for finally body&quot;);
1784         finallyBlock = parseBlockStatement(context);
1785         failIfFalse(finallyBlock, &quot;Cannot parse finally body&quot;);
1786     }
1787     failIfFalse(catchBlock || finallyBlock, &quot;Try statements must have at least a catch or finally block&quot;);
1788     return context.createTryStatement(location, tryBlock, catchPattern, catchBlock, finallyBlock, firstLine, lastLine, catchEnvironment);
1789 }
1790 
1791 template &lt;typename LexerType&gt;
1792 template &lt;class TreeBuilder&gt; TreeStatement Parser&lt;LexerType&gt;::parseDebuggerStatement(TreeBuilder&amp; context)
1793 {
1794     ASSERT(match(DEBUGGER));
1795     JSTokenLocation location(tokenLocation());
1796     int startLine = tokenLine();
1797     int endLine = startLine;
1798     next();
1799     if (match(SEMICOLON))
1800         startLine = tokenLine();
1801     failIfFalse(autoSemiColon(), &quot;Debugger keyword must be followed by a &#39;;&#39;&quot;);
1802     return context.createDebugger(location, startLine, endLine);
1803 }
1804 
1805 template &lt;typename LexerType&gt;
1806 template &lt;class TreeBuilder&gt; TreeStatement Parser&lt;LexerType&gt;::parseBlockStatement(TreeBuilder&amp; context)
1807 {
1808     ASSERT(match(OPENBRACE));
1809 
1810     // We should treat the first block statement of the function (the body of the function) as the lexical
1811     // scope of the function itself, and not the lexical scope of a &#39;block&#39; statement within the function.
1812     AutoCleanupLexicalScope lexicalScope;
1813     bool shouldPushLexicalScope = m_statementDepth &gt; 0;
1814     if (shouldPushLexicalScope) {
1815         ScopeRef newScope = pushScope();
1816         newScope-&gt;setIsLexicalScope();
1817         newScope-&gt;preventVarDeclarations();
1818         lexicalScope.setIsValid(newScope, this);
1819     }
1820     JSTokenLocation location(tokenLocation());
1821     int startOffset = m_token.m_data.offset;
1822     int start = tokenLine();
1823     VariableEnvironment emptyEnvironment;
1824     DeclarationStacks::FunctionStack emptyFunctionStack;
1825     next();
1826     if (match(CLOSEBRACE)) {
1827         int endOffset = m_token.m_data.offset;
1828         next();
1829         TreeStatement result = context.createBlockStatement(location, 0, start, m_lastTokenEndPosition.line, shouldPushLexicalScope ? currentScope()-&gt;finalizeLexicalEnvironment() : emptyEnvironment, shouldPushLexicalScope ? currentScope()-&gt;takeFunctionDeclarations() : WTFMove(emptyFunctionStack));
1830         context.setStartOffset(result, startOffset);
1831         context.setEndOffset(result, endOffset);
1832         if (shouldPushLexicalScope)
1833             popScope(lexicalScope, TreeBuilder::NeedsFreeVariableInfo);
1834         return result;
1835     }
1836     TreeSourceElements subtree = parseSourceElements(context, DontCheckForStrictMode);
1837     failIfFalse(subtree, &quot;Cannot parse the body of the block statement&quot;);
1838     matchOrFail(CLOSEBRACE, &quot;Expected a closing &#39;}&#39; at the end of a block statement&quot;);
1839     int endOffset = m_token.m_data.offset;
1840     next();
1841     TreeStatement result = context.createBlockStatement(location, subtree, start, m_lastTokenEndPosition.line, shouldPushLexicalScope ? currentScope()-&gt;finalizeLexicalEnvironment() : emptyEnvironment, shouldPushLexicalScope ? currentScope()-&gt;takeFunctionDeclarations() : WTFMove(emptyFunctionStack));
1842     context.setStartOffset(result, startOffset);
1843     context.setEndOffset(result, endOffset);
1844     if (shouldPushLexicalScope)
1845         popScope(lexicalScope, TreeBuilder::NeedsFreeVariableInfo);
1846 
1847     return result;
1848 }
1849 
1850 template &lt;typename LexerType&gt;
1851 template &lt;class TreeBuilder&gt; TreeStatement Parser&lt;LexerType&gt;::parseStatement(TreeBuilder&amp; context, const Identifier*&amp; directive, unsigned* directiveLiteralLength)
1852 {
1853     DepthManager statementDepth(&amp;m_statementDepth);
1854     m_statementDepth++;
1855     int nonTrivialExpressionCount = 0;
1856     failIfStackOverflow();
1857     TreeStatement result = 0;
1858     bool shouldSetEndOffset = true;
1859     bool shouldSetPauseLocation = false;
1860     bool parentAllowsFunctionDeclarationAsStatement = m_immediateParentAllowsFunctionDeclarationInStatement;
1861     m_immediateParentAllowsFunctionDeclarationInStatement = false;
1862 
1863     switch (m_token.m_type) {
1864     case OPENBRACE:
1865         result = parseBlockStatement(context);
1866         shouldSetEndOffset = false;
1867         break;
1868     case VAR:
1869         result = parseVariableDeclaration(context, DeclarationType::VarDeclaration);
1870         shouldSetPauseLocation = true;
1871         break;
1872     case FUNCTION: {
1873         const bool isAsync = false;
1874         result = parseFunctionDeclarationStatement(context, isAsync, parentAllowsFunctionDeclarationAsStatement);
1875         break;
1876     }
1877     case SEMICOLON: {
1878         JSTokenLocation location(tokenLocation());
1879         next();
1880         result = context.createEmptyStatement(location);
1881         shouldSetPauseLocation = true;
1882         break;
1883     }
1884     case IF:
1885         result = parseIfStatement(context);
1886         break;
1887     case DO:
1888         result = parseDoWhileStatement(context);
1889         break;
1890     case WHILE:
1891         result = parseWhileStatement(context);
1892         break;
1893     case FOR:
1894         result = parseForStatement(context);
1895         break;
1896     case CONTINUE:
1897         result = parseContinueStatement(context);
1898         shouldSetPauseLocation = true;
1899         break;
1900     case BREAK:
1901         result = parseBreakStatement(context);
1902         shouldSetPauseLocation = true;
1903         break;
1904     case RETURN:
1905         result = parseReturnStatement(context);
1906         shouldSetPauseLocation = true;
1907         break;
1908     case WITH:
1909         result = parseWithStatement(context);
1910         break;
1911     case SWITCH:
1912         result = parseSwitchStatement(context);
1913         break;
1914     case THROW:
1915         result = parseThrowStatement(context);
1916         shouldSetPauseLocation = true;
1917         break;
1918     case TRY:
1919         result = parseTryStatement(context);
1920         break;
1921     case DEBUGGER:
1922         result = parseDebuggerStatement(context);
1923         shouldSetPauseLocation = true;
1924         break;
1925     case EOFTOK:
1926     case CASE:
1927     case CLOSEBRACE:
1928     case DEFAULT:
1929         // These tokens imply the end of a set of source elements
1930         return 0;
1931     case LET: {
1932         if (!strictMode())
1933             goto identcase;
1934         goto defaultCase;
1935     }
1936     case IDENT:
<a name="39" id="anc39"></a><span class="line-modified">1937         if (UNLIKELY(*m_token.m_data.ident == m_vm-&gt;propertyNames-&gt;async &amp;&amp; !m_token.m_data.escaped)) {</span>
1938             if (maybeParseAsyncFunctionDeclarationStatement(context, result, parentAllowsFunctionDeclarationAsStatement))
1939                 break;
1940         }
1941         FALLTHROUGH;
1942     case AWAIT:
1943     case YIELD: {
1944         identcase:
1945         bool allowFunctionDeclarationAsStatement = false;
1946         result = parseExpressionOrLabelStatement(context, allowFunctionDeclarationAsStatement);
1947         shouldSetPauseLocation = !context.shouldSkipPauseLocation(result);
1948         break;
1949     }
1950     case STRING:
1951         directive = m_token.m_data.ident;
1952         if (directiveLiteralLength)
1953             *directiveLiteralLength = m_token.m_location.endOffset - m_token.m_location.startOffset;
1954         nonTrivialExpressionCount = m_parserState.nonTrivialExpressionCount;
1955         FALLTHROUGH;
1956     default:
1957         defaultCase:
1958         TreeStatement exprStatement = parseExpressionStatement(context);
1959         if (directive &amp;&amp; nonTrivialExpressionCount != m_parserState.nonTrivialExpressionCount)
1960             directive = nullptr;
1961         result = exprStatement;
1962         shouldSetPauseLocation = true;
1963         break;
1964     }
1965 
1966     if (result) {
1967         if (shouldSetEndOffset)
1968             context.setEndOffset(result, m_lastTokenEndPosition.offset);
1969         if (shouldSetPauseLocation)
1970             recordPauseLocation(context.breakpointLocation(result));
1971     }
1972 
1973     return result;
1974 }
1975 
1976 template &lt;typename LexerType&gt;
1977 template &lt;class TreeBuilder&gt; TreeStatement Parser&lt;LexerType&gt;::parseFunctionDeclarationStatement(TreeBuilder&amp; context, bool isAsync, bool parentAllowsFunctionDeclarationAsStatement)
1978 {
1979     semanticFailIfTrue(strictMode(), &quot;Function declarations are only allowed inside blocks or switch statements in strict mode&quot;);
1980     failIfFalse(parentAllowsFunctionDeclarationAsStatement, &quot;Function declarations are only allowed inside block statements or at the top level of a program&quot;);
1981     if (!currentScope()-&gt;isFunction() &amp;&amp; !closestParentOrdinaryFunctionNonLexicalScope()-&gt;isEvalContext()) {
1982         // We only implement annex B.3.3 if we&#39;re in function mode or eval mode. Otherwise, we fall back
1983         // to hoisting behavior.
1984         // FIXME: https://bugs.webkit.org/show_bug.cgi?id=155813
1985         DepthManager statementDepth(&amp;m_statementDepth);
1986         m_statementDepth = 1;
1987         if (isAsync)
1988             return parseAsyncFunctionDeclaration(context);
1989         return parseFunctionDeclaration(context);
1990     }
1991 
1992     // Any function declaration that isn&#39;t in a block is a syntax error unless it&#39;s
1993     // in an if/else statement. If it&#39;s in an if/else statement, we will magically
1994     // treat it as if the if/else statement is inside a block statement.
1995     // to the very top like a &quot;var&quot;. For example:
1996     // function a() {
1997     //     if (cond) function foo() { }
1998     // }
1999     // will be rewritten as:
2000     // function a() {
2001     //     if (cond) { function foo() { } }
2002     // }
2003     AutoPopScopeRef blockScope(this, pushScope());
2004     blockScope-&gt;setIsLexicalScope();
2005     blockScope-&gt;preventVarDeclarations();
2006     JSTokenLocation location(tokenLocation());
2007     int start = tokenLine();
2008 
2009     TreeStatement function = 0;
2010     if (!isAsync)
2011         function = parseFunctionDeclaration(context);
2012     else
2013         function = parseAsyncFunctionDeclaration(context);
2014     propagateError();
2015     failIfFalse(function, &quot;Expected valid function statement after &#39;function&#39; keyword&quot;);
2016     TreeSourceElements sourceElements = context.createSourceElements();
2017     context.appendStatement(sourceElements, function);
2018     TreeStatement result = context.createBlockStatement(location, sourceElements, start, m_lastTokenEndPosition.line, currentScope()-&gt;finalizeLexicalEnvironment(), currentScope()-&gt;takeFunctionDeclarations());
2019     popScope(blockScope, TreeBuilder::NeedsFreeVariableInfo);
2020     return result;
2021 }
2022 
2023 template &lt;typename LexerType&gt;
2024 template &lt;class TreeBuilder&gt; bool Parser&lt;LexerType&gt;::maybeParseAsyncFunctionDeclarationStatement(TreeBuilder&amp; context, TreeStatement&amp; result, bool parentAllowsFunctionDeclarationAsStatement)
2025 {
<a name="40" id="anc40"></a><span class="line-modified">2026     ASSERT(matchContextualKeyword(m_vm-&gt;propertyNames-&gt;async));</span>
2027     SavePoint savePoint = createSavePoint();
2028     next();
2029     if (match(FUNCTION) &amp;&amp; !m_lexer-&gt;hasLineTerminatorBeforeToken()) {
2030         const bool isAsync = true;
2031         result = parseFunctionDeclarationStatement(context, isAsync, parentAllowsFunctionDeclarationAsStatement);
2032         return true;
2033     }
2034     restoreSavePoint(savePoint);
2035     return false;
2036 }
2037 
2038 template &lt;typename LexerType&gt;
2039 template &lt;class TreeBuilder&gt; bool Parser&lt;LexerType&gt;::parseFormalParameters(TreeBuilder&amp; context, TreeFormalParameterList list, bool isArrowFunction, bool isMethod, unsigned&amp; parameterCount)
2040 {
2041 #define failIfDuplicateIfViolation() \
2042     if (duplicateParameter) {\
2043         semanticFailIfTrue(hasDefaultParameterValues, &quot;Duplicate parameter &#39;&quot;, duplicateParameter-&gt;impl(), &quot;&#39; not allowed in function with default parameter values&quot;);\
2044         semanticFailIfTrue(hasDestructuringPattern, &quot;Duplicate parameter &#39;&quot;, duplicateParameter-&gt;impl(), &quot;&#39; not allowed in function with destructuring parameters&quot;);\
2045         semanticFailIfTrue(isRestParameter, &quot;Duplicate parameter &#39;&quot;, duplicateParameter-&gt;impl(), &quot;&#39; not allowed in function with a rest parameter&quot;);\
2046         semanticFailIfTrue(isArrowFunction, &quot;Duplicate parameter &#39;&quot;, duplicateParameter-&gt;impl(), &quot;&#39; not allowed in an arrow function&quot;);\
2047         semanticFailIfTrue(isMethod, &quot;Duplicate parameter &#39;&quot;, duplicateParameter-&gt;impl(), &quot;&#39; not allowed in a method&quot;);\
2048     }
2049 
2050     bool hasDefaultParameterValues = false;
2051     bool hasDestructuringPattern = false;
2052     bool isRestParameter = false;
2053     const Identifier* duplicateParameter = nullptr;
2054     unsigned restParameterStart = 0;
2055     do {
2056         TreeDestructuringPattern parameter = 0;
2057         TreeExpression defaultValue = 0;
2058 
2059         if (UNLIKELY(match(CLOSEPAREN)))
2060             break;
2061 
2062         if (match(DOTDOTDOT)) {
2063             next();
2064             semanticFailIfTrue(!m_parserState.allowAwait &amp;&amp; match(AWAIT), &quot;Cannot use &#39;await&#39; as a parameter name in an async function&quot;);
2065             TreeDestructuringPattern destructuringPattern = parseDestructuringPattern(context, DestructuringKind::DestructureToParameters, ExportType::NotExported, &amp;duplicateParameter, &amp;hasDestructuringPattern);
2066             propagateError();
2067             parameter = context.createRestParameter(destructuringPattern, restParameterStart);
2068             failIfTrue(match(COMMA), &quot;Rest parameter should be the last parameter in a function declaration&quot;); // Let&#39;s have a good error message for this common case.
2069             isRestParameter = true;
2070         } else
2071             parameter = parseDestructuringPattern(context, DestructuringKind::DestructureToParameters, ExportType::NotExported, &amp;duplicateParameter, &amp;hasDestructuringPattern);
2072         failIfFalse(parameter, &quot;Cannot parse parameter pattern&quot;);
2073         if (!isRestParameter) {
2074             defaultValue = parseDefaultValueForDestructuringPattern(context);
2075             if (defaultValue)
2076                 hasDefaultParameterValues = true;
2077         }
2078         propagateError();
2079         failIfDuplicateIfViolation();
2080         if (isRestParameter || defaultValue || hasDestructuringPattern)
2081             currentScope()-&gt;setHasNonSimpleParameterList();
2082         context.appendParameter(list, parameter, defaultValue);
2083         if (!isRestParameter) {
2084             restParameterStart++;
2085             if (!hasDefaultParameterValues)
2086                 parameterCount++;
2087         }
2088     } while (!isRestParameter &amp;&amp; consume(COMMA));
2089 
2090     return true;
2091 #undef failIfDuplicateIfViolation
2092 }
2093 
2094 template &lt;typename LexerType&gt;
2095 template &lt;class TreeBuilder&gt; TreeFunctionBody Parser&lt;LexerType&gt;::parseFunctionBody(
2096     TreeBuilder&amp; context, SyntaxChecker&amp; syntaxChecker, const JSTokenLocation&amp; startLocation, int startColumn, int functionKeywordStart, int functionNameStart, int parametersStart,
2097     ConstructorKind constructorKind, SuperBinding superBinding, FunctionBodyType bodyType, unsigned parameterCount, SourceParseMode parseMode)
2098 {
2099     bool isArrowFunctionBodyExpression = bodyType == ArrowFunctionBodyExpression;
2100     if (!isArrowFunctionBodyExpression) {
2101         next();
2102         if (match(CLOSEBRACE)) {
2103             unsigned endColumn = tokenColumn();
2104             SuperBinding functionSuperBinding = adjustSuperBindingForBaseConstructor(constructorKind, superBinding, currentScope());
2105             return context.createFunctionMetadata(startLocation, tokenLocation(), startColumn, endColumn, functionKeywordStart, functionNameStart, parametersStart, strictMode(), constructorKind, functionSuperBinding, parameterCount, parseMode, isArrowFunctionBodyExpression);
2106         }
2107     }
2108 
2109     DepthManager statementDepth(&amp;m_statementDepth);
2110     m_statementDepth = 0;
2111     if (bodyType == ArrowFunctionBodyExpression) {
2112         if (m_debuggerParseData)
2113             failIfFalse(parseArrowFunctionSingleExpressionBodySourceElements(context), &quot;Cannot parse body of this arrow function&quot;);
2114         else
2115             failIfFalse(parseArrowFunctionSingleExpressionBodySourceElements(syntaxChecker), &quot;Cannot parse body of this arrow function&quot;);
2116     } else {
2117         if (m_debuggerParseData)
2118             failIfFalse(parseSourceElements(context, CheckForStrictMode), bodyType == StandardFunctionBodyBlock ? &quot;Cannot parse body of this function&quot; : &quot;Cannot parse body of this arrow function&quot;);
2119         else
2120             failIfFalse(parseSourceElements(syntaxChecker, CheckForStrictMode), bodyType == StandardFunctionBodyBlock ? &quot;Cannot parse body of this function&quot; : &quot;Cannot parse body of this arrow function&quot;);
2121     }
2122     unsigned endColumn = tokenColumn();
2123     SuperBinding functionSuperBinding = adjustSuperBindingForBaseConstructor(constructorKind, superBinding, currentScope());
2124     return context.createFunctionMetadata(startLocation, tokenLocation(), startColumn, endColumn, functionKeywordStart, functionNameStart, parametersStart, strictMode(), constructorKind, functionSuperBinding, parameterCount, parseMode, isArrowFunctionBodyExpression);
2125 }
2126 
2127 static const char* stringArticleForFunctionMode(SourceParseMode mode)
2128 {
2129     switch (mode) {
2130     case SourceParseMode::GetterMode:
2131     case SourceParseMode::SetterMode:
2132     case SourceParseMode::NormalFunctionMode:
2133     case SourceParseMode::MethodMode:
2134     case SourceParseMode::GeneratorBodyMode:
2135     case SourceParseMode::GeneratorWrapperFunctionMode:
2136     case SourceParseMode::GeneratorWrapperMethodMode:
2137         return &quot;a &quot;;
2138     case SourceParseMode::ArrowFunctionMode:
2139     case SourceParseMode::AsyncFunctionMode:
2140     case SourceParseMode::AsyncFunctionBodyMode:
2141     case SourceParseMode::AsyncMethodMode:
2142     case SourceParseMode::AsyncArrowFunctionBodyMode:
2143     case SourceParseMode::AsyncArrowFunctionMode:
2144     case SourceParseMode::AsyncGeneratorWrapperFunctionMode:
2145     case SourceParseMode::AsyncGeneratorBodyMode:
2146     case SourceParseMode::AsyncGeneratorWrapperMethodMode:
2147         return &quot;an &quot;;
2148     case SourceParseMode::ProgramMode:
2149     case SourceParseMode::ModuleAnalyzeMode:
2150     case SourceParseMode::ModuleEvaluateMode:
2151         RELEASE_ASSERT_NOT_REACHED();
2152         return &quot;&quot;;
2153     }
2154     RELEASE_ASSERT_NOT_REACHED();
2155     return nullptr;
2156 }
2157 
2158 static const char* stringForFunctionMode(SourceParseMode mode)
2159 {
2160     switch (mode) {
2161     case SourceParseMode::GetterMode:
2162         return &quot;getter&quot;;
2163     case SourceParseMode::SetterMode:
2164         return &quot;setter&quot;;
2165     case SourceParseMode::NormalFunctionMode:
2166         return &quot;function&quot;;
2167     case SourceParseMode::MethodMode:
2168         return &quot;method&quot;;
2169     case SourceParseMode::GeneratorBodyMode:
2170         return &quot;generator&quot;;
2171     case SourceParseMode::GeneratorWrapperFunctionMode:
2172     case SourceParseMode::GeneratorWrapperMethodMode:
2173         return &quot;generator function&quot;;
2174     case SourceParseMode::ArrowFunctionMode:
2175         return &quot;arrow function&quot;;
2176     case SourceParseMode::AsyncFunctionMode:
2177     case SourceParseMode::AsyncFunctionBodyMode:
2178         return &quot;async function&quot;;
2179     case SourceParseMode::AsyncMethodMode:
2180         return &quot;async method&quot;;
2181     case SourceParseMode::AsyncArrowFunctionBodyMode:
2182     case SourceParseMode::AsyncArrowFunctionMode:
2183         return &quot;async arrow function&quot;;
2184     case SourceParseMode::AsyncGeneratorWrapperFunctionMode:
2185     case SourceParseMode::AsyncGeneratorBodyMode:
2186         return &quot;async generator function&quot;;
2187     case SourceParseMode::AsyncGeneratorWrapperMethodMode:
2188         return &quot;async generator method&quot;;
2189     case SourceParseMode::ProgramMode:
2190     case SourceParseMode::ModuleAnalyzeMode:
2191     case SourceParseMode::ModuleEvaluateMode:
2192         RELEASE_ASSERT_NOT_REACHED();
2193         return &quot;&quot;;
2194     }
2195     RELEASE_ASSERT_NOT_REACHED();
2196     return nullptr;
2197 }
2198 
2199 template &lt;typename LexerType&gt; template &lt;class TreeBuilder, class FunctionInfoType&gt; typename TreeBuilder::FormalParameterList Parser&lt;LexerType&gt;::parseFunctionParameters(TreeBuilder&amp; context, SourceParseMode mode, FunctionInfoType&amp; functionInfo)
2200 {
2201     RELEASE_ASSERT(!(SourceParseModeSet(SourceParseMode::ProgramMode, SourceParseMode::ModuleAnalyzeMode, SourceParseMode::ModuleEvaluateMode).contains(mode)));
2202     TreeFormalParameterList parameterList = context.createFormalParameterList();
2203     SetForScope&lt;FunctionParsePhase&gt; functionParsePhasePoisoner(m_parserState.functionParsePhase, FunctionParsePhase::Parameters);
2204 
2205     if (UNLIKELY((SourceParseModeSet(SourceParseMode::ArrowFunctionMode, SourceParseMode::AsyncArrowFunctionMode).contains(mode)))) {
2206         if (!matchSpecIdentifier() &amp;&amp; !match(OPENPAREN)) {
2207             semanticFailureDueToKeyword(stringForFunctionMode(mode), &quot; name&quot;);
2208             failWithMessage(&quot;Expected an arrow function input parameter&quot;);
2209         } else {
2210             if (match(OPENPAREN)) {
2211                 next();
2212 
2213                 if (match(CLOSEPAREN)) {
2214                     functionInfo.parameterCount = 0;
2215                 } else {
2216                     bool isArrowFunction = true;
2217                     bool isMethod = false;
2218                     failIfFalse(parseFormalParameters(context, parameterList, isArrowFunction, isMethod, functionInfo.parameterCount), &quot;Cannot parse parameters for this &quot;, stringForFunctionMode(mode));
2219                 }
2220 
2221                 consumeOrFail(CLOSEPAREN, &quot;Expected a &#39;)&#39; or a &#39;,&#39; after a parameter declaration&quot;);
2222             } else {
2223                 functionInfo.parameterCount = 1;
2224                 auto parameter = parseDestructuringPattern(context, DestructuringKind::DestructureToParameters, ExportType::NotExported);
2225                 failIfFalse(parameter, &quot;Cannot parse parameter pattern&quot;);
2226                 context.appendParameter(parameterList, parameter, 0);
2227             }
2228         }
2229 
2230         return parameterList;
2231     }
2232 
2233     if (!consume(OPENPAREN)) {
2234         semanticFailureDueToKeyword(stringForFunctionMode(mode), &quot; name&quot;);
2235         failWithMessage(&quot;Expected an opening &#39;(&#39; before a &quot;, stringForFunctionMode(mode), &quot;&#39;s parameter list&quot;);
2236     }
2237 
2238     if (mode == SourceParseMode::GetterMode) {
2239         consumeOrFail(CLOSEPAREN, &quot;getter functions must have no parameters&quot;);
2240         functionInfo.parameterCount = 0;
2241     } else if (mode == SourceParseMode::SetterMode) {
2242         failIfTrue(match(CLOSEPAREN), &quot;setter functions must have one parameter&quot;);
2243         const Identifier* duplicateParameter = nullptr;
2244         bool hasDestructuringPattern = false;
2245         auto parameter = parseDestructuringPattern(context, DestructuringKind::DestructureToParameters, ExportType::NotExported, &amp;duplicateParameter, &amp;hasDestructuringPattern);
2246         failIfFalse(parameter, &quot;setter functions must have one parameter&quot;);
2247         auto defaultValue = parseDefaultValueForDestructuringPattern(context);
2248         propagateError();
2249         if (defaultValue || hasDestructuringPattern) {
2250             semanticFailIfTrue(duplicateParameter, &quot;Duplicate parameter &#39;&quot;, duplicateParameter-&gt;impl(), &quot;&#39; not allowed in function with non-simple parameter list&quot;);
2251             currentScope()-&gt;setHasNonSimpleParameterList();
2252         }
2253         context.appendParameter(parameterList, parameter, defaultValue);
2254         functionInfo.parameterCount = defaultValue ? 0 : 1;
2255         failIfTrue(match(COMMA), &quot;setter functions must have one parameter&quot;);
2256         consumeOrFail(CLOSEPAREN, &quot;Expected a &#39;)&#39; after a parameter declaration&quot;);
2257     } else {
2258         if (match(CLOSEPAREN)) {
2259             functionInfo.parameterCount = 0;
2260         } else {
2261             bool isArrowFunction = false;
2262             bool isMethod = isMethodParseMode(mode);
2263             failIfFalse(parseFormalParameters(context, parameterList, isArrowFunction, isMethod, functionInfo.parameterCount), &quot;Cannot parse parameters for this &quot;, stringForFunctionMode(mode));
2264         }
2265         consumeOrFail(CLOSEPAREN, &quot;Expected a &#39;)&#39; or a &#39;,&#39; after a parameter declaration&quot;);
2266     }
2267 
2268     return parameterList;
2269 }
2270 
2271 template &lt;typename LexerType&gt;
2272 template &lt;class TreeBuilder&gt; typename TreeBuilder::FormalParameterList Parser&lt;LexerType&gt;::createGeneratorParameters(TreeBuilder&amp; context, unsigned&amp; parameterCount)
2273 {
2274     auto parameters = context.createFormalParameterList();
2275 
2276     JSTokenLocation location(tokenLocation());
2277     JSTextPosition position = tokenStartPosition();
2278 
2279     auto addParameter = [&amp;](const Identifier&amp; name) {
2280         declareParameter(&amp;name);
2281         auto binding = context.createBindingLocation(location, name, position, position, AssignmentContext::DeclarationStatement);
2282         context.appendParameter(parameters, binding, 0);
2283         ++parameterCount;
2284     };
2285 
2286     // @generator
<a name="41" id="anc41"></a><span class="line-modified">2287     addParameter(m_vm-&gt;propertyNames-&gt;generatorPrivateName);</span>
2288     // @generatorState
<a name="42" id="anc42"></a><span class="line-modified">2289     addParameter(m_vm-&gt;propertyNames-&gt;generatorStatePrivateName);</span>
2290     // @generatorValue
<a name="43" id="anc43"></a><span class="line-modified">2291     addParameter(m_vm-&gt;propertyNames-&gt;generatorValuePrivateName);</span>
2292     // @generatorResumeMode
<a name="44" id="anc44"></a><span class="line-modified">2293     addParameter(m_vm-&gt;propertyNames-&gt;generatorResumeModePrivateName);</span>
2294     // @generatorFrame
<a name="45" id="anc45"></a><span class="line-modified">2295     addParameter(m_vm-&gt;propertyNames-&gt;generatorFramePrivateName);</span>
2296 
2297     return parameters;
2298 }
2299 
2300 template &lt;typename LexerType&gt;
2301 template &lt;class TreeBuilder&gt; bool Parser&lt;LexerType&gt;::parseFunctionInfo(TreeBuilder&amp; context, FunctionNameRequirements requirements, SourceParseMode mode, bool nameIsInContainingScope, ConstructorKind constructorKind, SuperBinding expectedSuperBinding, int functionKeywordStart, ParserFunctionInfo&lt;TreeBuilder&gt;&amp; functionInfo, FunctionDefinitionType functionDefinitionType, Optional&lt;int&gt; functionConstructorParametersEndPosition)
2302 {
2303     RELEASE_ASSERT(isFunctionParseMode(mode));
2304 
2305     ScopeRef parentScope = currentScope();
2306 
2307     bool isDisallowedAwaitFunctionName = isDisallowedIdentifierAwait(m_token);
2308     const char* isDisallowedAwaitFunctionNameReason = isDisallowedAwaitFunctionName ? disallowedIdentifierAwaitReason() : nullptr;
2309 
2310     AutoPopScopeRef functionScope(this, pushScope());
2311     functionScope-&gt;setSourceParseMode(mode);
2312     functionScope-&gt;setExpectedSuperBinding(expectedSuperBinding);
2313     functionScope-&gt;setConstructorKind(constructorKind);
2314     SetForScope&lt;FunctionParsePhase&gt; functionParsePhasePoisoner(m_parserState.functionParsePhase, FunctionParsePhase::Body);
2315     int functionNameStart = m_token.m_location.startOffset;
2316     const Identifier* lastFunctionName = m_parserState.lastFunctionName;
2317     m_parserState.lastFunctionName = nullptr;
2318     int parametersStart = -1;
2319     JSTokenLocation startLocation;
2320     int startColumn = -1;
2321     FunctionBodyType functionBodyType;
2322 
2323     auto loadCachedFunction = [&amp;] () -&gt; bool {
2324         if (UNLIKELY(!Options::useSourceProviderCache()))
2325             return false;
2326 
2327         if (UNLIKELY(m_debuggerParseData))
2328             return false;
2329 
2330         ASSERT(parametersStart != -1);
2331         ASSERT(startColumn != -1);
2332 
2333         // If we know about this function already, we can use the cached info and skip the parser to the end of the function.
2334         if (const SourceProviderCacheItem* cachedInfo = TreeBuilder::CanUseFunctionCache ? findCachedFunctionInfo(parametersStart) : 0) {
2335             // If we&#39;re in a strict context, the cached function info must say it was strict too.
2336             ASSERT(!strictMode() || cachedInfo-&gt;strictMode);
2337             JSTokenLocation endLocation;
2338 
2339             ConstructorKind constructorKind = static_cast&lt;ConstructorKind&gt;(cachedInfo-&gt;constructorKind);
2340             SuperBinding expectedSuperBinding = static_cast&lt;SuperBinding&gt;(cachedInfo-&gt;expectedSuperBinding);
2341 
2342             endLocation.line = cachedInfo-&gt;lastTokenLine;
2343             endLocation.startOffset = cachedInfo-&gt;lastTokenStartOffset;
2344             endLocation.lineStartOffset = cachedInfo-&gt;lastTokenLineStartOffset;
2345             ASSERT(endLocation.startOffset &gt;= endLocation.lineStartOffset);
2346 
2347             bool endColumnIsOnStartLine = endLocation.line == functionInfo.startLine;
2348             unsigned currentLineStartOffset = m_lexer-&gt;currentLineStartOffset();
2349             unsigned bodyEndColumn = endColumnIsOnStartLine ? endLocation.startOffset - currentLineStartOffset : endLocation.startOffset - endLocation.lineStartOffset;
2350 
2351             ASSERT(endLocation.startOffset &gt;= endLocation.lineStartOffset);
2352 
2353             FunctionBodyType functionBodyType;
2354             if (UNLIKELY(SourceParseModeSet(SourceParseMode::ArrowFunctionMode, SourceParseMode::AsyncArrowFunctionMode).contains(mode)))
2355                 functionBodyType = cachedInfo-&gt;isBodyArrowExpression ?  ArrowFunctionBodyExpression : ArrowFunctionBodyBlock;
2356             else
2357                 functionBodyType = StandardFunctionBodyBlock;
2358 
2359             SuperBinding functionSuperBinding = adjustSuperBindingForBaseConstructor(constructorKind, expectedSuperBinding, cachedInfo-&gt;needsSuperBinding, cachedInfo-&gt;usesEval, cachedInfo-&gt;innerArrowFunctionFeatures);
2360 
2361             functionInfo.body = context.createFunctionMetadata(
2362                 startLocation, endLocation, startColumn, bodyEndColumn,
2363                 functionKeywordStart, functionNameStart, parametersStart,
2364                 cachedInfo-&gt;strictMode, constructorKind, functionSuperBinding,
2365                 cachedInfo-&gt;parameterCount,
2366                 mode, functionBodyType == ArrowFunctionBodyExpression);
2367             functionInfo.endOffset = cachedInfo-&gt;endFunctionOffset;
2368             functionInfo.parameterCount = cachedInfo-&gt;parameterCount;
2369 
2370             functionScope-&gt;restoreFromSourceProviderCache(cachedInfo);
2371             popScope(functionScope, TreeBuilder::NeedsFreeVariableInfo);
2372 
2373             m_token = cachedInfo-&gt;endFunctionToken();
2374 
2375             if (endColumnIsOnStartLine)
2376                 m_token.m_location.lineStartOffset = currentLineStartOffset;
2377 
2378             m_lexer-&gt;setOffset(m_token.m_location.endOffset, m_token.m_location.lineStartOffset);
2379             m_lexer-&gt;setLineNumber(m_token.m_location.line);
2380 
2381             switch (functionBodyType) {
2382             case ArrowFunctionBodyExpression:
2383                 next();
2384                 context.setEndOffset(functionInfo.body, m_lexer-&gt;currentOffset());
2385                 break;
2386             case ArrowFunctionBodyBlock:
2387             case StandardFunctionBodyBlock:
2388                 context.setEndOffset(functionInfo.body, m_lexer-&gt;currentOffset());
2389                 next();
2390                 break;
2391             }
2392             functionInfo.endLine = m_lastTokenEndPosition.line;
2393             return true;
2394         }
2395 
2396         return false;
2397     };
2398 
<a name="46" id="anc46"></a><span class="line-modified">2399     SyntaxChecker syntaxChecker(const_cast&lt;VM*&gt;(m_vm), m_lexer.get());</span>
2400 
2401     if (UNLIKELY((SourceParseModeSet(SourceParseMode::ArrowFunctionMode, SourceParseMode::AsyncArrowFunctionMode).contains(mode)))) {
2402         startLocation = tokenLocation();
2403         functionInfo.startLine = tokenLine();
2404         startColumn = tokenColumn();
2405 
2406         parametersStart = m_token.m_location.startOffset;
2407         functionInfo.startOffset = parametersStart;
2408         functionInfo.parametersStartColumn = startColumn;
2409 
2410         if (loadCachedFunction())
2411             return true;
2412 
2413         {
2414             // Parse formal parameters with [+Yield] parameterization, in order to ban YieldExpressions
2415             // in ArrowFormalParameters, per ES6 #sec-arrow-function-definitions-static-semantics-early-errors.
2416             Scope::MaybeParseAsGeneratorForScope parseAsGenerator(functionScope, parentScope-&gt;isGenerator());
2417             SetForScope&lt;bool&gt; overrideAllowAwait(m_parserState.allowAwait, !isAsyncFunctionParseMode(mode));
2418             parseFunctionParameters(syntaxChecker, mode, functionInfo);
2419             propagateError();
2420         }
2421 
2422         matchOrFail(ARROWFUNCTION, &quot;Expected a &#39;=&gt;&#39; after arrow function parameter declaration&quot;);
2423 
2424         if (m_lexer-&gt;hasLineTerminatorBeforeToken())
2425             failDueToUnexpectedToken();
2426 
2427         ASSERT(constructorKind == ConstructorKind::None);
2428 
2429         // Check if arrow body start with {. If it true it mean that arrow function is Fat arrow function
2430         // and we need use common approach to parse function body
2431         next();
2432         functionBodyType = match(OPENBRACE) ? ArrowFunctionBodyBlock : ArrowFunctionBodyExpression;
2433     } else {
2434         // http://ecma-international.org/ecma-262/6.0/#sec-function-definitions
2435         // FunctionExpression :
2436         //     function BindingIdentifieropt ( FormalParameters ) { FunctionBody }
2437         //
2438         // FunctionDeclaration[Yield, Default] :
2439         //     function BindingIdentifier[?Yield] ( FormalParameters ) { FunctionBody }
2440         //     [+Default] function ( FormalParameters ) { FunctionBody }
2441         //
2442         // GeneratorDeclaration[Yield, Default] :
2443         //     function * BindingIdentifier[?Yield] ( FormalParameters[Yield] ) { GeneratorBody }
2444         //     [+Default] function * ( FormalParameters[Yield] ) { GeneratorBody }
2445         //
2446         // GeneratorExpression :
2447         //     function * BindingIdentifier[Yield]opt ( FormalParameters[Yield] ) { GeneratorBody }
2448         //
2449         // The name of FunctionExpression and AsyncFunctionExpression can accept &quot;yield&quot; even in the context of generator.
2450         bool upperScopeIsGenerator = false;
2451         if (!(functionDefinitionType == FunctionDefinitionType::Expression &amp;&amp; SourceParseModeSet(SourceParseMode::NormalFunctionMode, SourceParseMode::AsyncFunctionMode).contains(mode)))
2452             upperScopeIsGenerator = upperScope(1)-&gt;isGenerator();
2453 
2454         if (requirements != FunctionNameRequirements::Unnamed) {
2455             ASSERT_WITH_MESSAGE(!(requirements == FunctionNameRequirements::None &amp;&amp; !functionInfo.name), &quot;When specifying FunctionNameRequirements::None, we need to initialize functionInfo.name with the default value in the caller side.&quot;);
2456             if (matchSpecIdentifier(upperScopeIsGenerator)) {
2457                 functionInfo.name = m_token.m_data.ident;
2458                 m_parserState.lastFunctionName = functionInfo.name;
2459                 if (UNLIKELY(isDisallowedAwaitFunctionName))
2460                     semanticFailIfTrue(functionDefinitionType == FunctionDefinitionType::Declaration || isAsyncFunctionOrAsyncGeneratorWrapperParseMode(mode), &quot;Cannot declare function named &#39;await&#39; &quot;, isDisallowedAwaitFunctionNameReason);
2461                 else if (isAsyncFunctionOrAsyncGeneratorWrapperParseMode(mode) &amp;&amp; match(AWAIT) &amp;&amp; functionDefinitionType == FunctionDefinitionType::Expression)
2462                     semanticFail(&quot;Cannot declare &quot;, stringForFunctionMode(mode), &quot; named &#39;await&#39;&quot;);
2463                 else if (isGeneratorWrapperParseMode(mode) &amp;&amp; match(YIELD) &amp;&amp; functionDefinitionType == FunctionDefinitionType::Expression)
2464                     semanticFail(&quot;Cannot declare generator function named &#39;yield&#39;&quot;);
2465                 next();
2466                 if (!nameIsInContainingScope)
2467                     failIfTrueIfStrict(functionScope-&gt;declareCallee(functionInfo.name) &amp; DeclarationResult::InvalidStrictMode, &quot;&#39;&quot;, functionInfo.name-&gt;impl(), &quot;&#39; is not a valid &quot;, stringForFunctionMode(mode), &quot; name in strict mode&quot;);
2468             } else if (requirements == FunctionNameRequirements::Named) {
2469                 if (match(OPENPAREN)) {
2470                     semanticFailIfTrue(mode == SourceParseMode::NormalFunctionMode, &quot;Function statements must have a name&quot;);
2471                     semanticFailIfTrue(mode == SourceParseMode::AsyncFunctionMode, &quot;Async function statements must have a name&quot;);
2472                 }
2473                 semanticFailureDueToKeyword(stringForFunctionMode(mode), &quot; name&quot;);
2474                 failDueToUnexpectedToken();
2475                 return false;
2476             }
2477             ASSERT(functionInfo.name);
2478         }
2479 
2480         startLocation = tokenLocation();
2481         functionInfo.startLine = tokenLine();
2482         startColumn = tokenColumn();
2483         functionInfo.parametersStartColumn = startColumn;
2484 
2485         parametersStart = m_token.m_location.startOffset;
2486         functionInfo.startOffset = parametersStart;
2487 
2488         if (loadCachedFunction())
2489             return true;
2490         {
2491             SetForScope&lt;bool&gt; overrideAllowAwait(m_parserState.allowAwait, !isAsyncFunctionParseMode(mode));
2492             parseFunctionParameters(syntaxChecker, mode, functionInfo);
2493             propagateError();
2494         }
2495 
2496         matchOrFail(OPENBRACE, &quot;Expected an opening &#39;{&#39; at the start of a &quot;, stringForFunctionMode(mode), &quot; body&quot;);
2497 
2498         // If the code is invoked from function constructor, we need to ensure that parameters are only composed by the string offered as parameters.
2499         if (UNLIKELY(functionConstructorParametersEndPosition))
2500             semanticFailIfFalse(lastTokenEndPosition().offset == *functionConstructorParametersEndPosition, &quot;Parameters should match arguments offered as parameters in Function constructor&quot;);
2501 
2502         // BytecodeGenerator emits code to throw TypeError when a class constructor is &quot;call&quot;ed.
2503         // Set ConstructorKind to None for non-constructor methods of classes.
2504 
2505         if (m_defaultConstructorKind != ConstructorKind::None) {
2506             constructorKind = m_defaultConstructorKind;
2507             expectedSuperBinding = m_defaultConstructorKind == ConstructorKind::Extends ? SuperBinding::Needed : SuperBinding::NotNeeded;
2508         }
2509 
2510         functionBodyType = StandardFunctionBodyBlock;
2511     }
2512 
2513     functionScope-&gt;setConstructorKind(constructorKind);
2514     functionScope-&gt;setExpectedSuperBinding(expectedSuperBinding);
2515 
2516     m_parserState.lastFunctionName = lastFunctionName;
2517     ParserState oldState = internalSaveParserState();
2518 
2519     // FIXME: https://bugs.webkit.org/show_bug.cgi?id=156962
2520     // This loop collects the set of capture candidates that aren&#39;t
2521     // part of the set of this function&#39;s declared parameters. We will
2522     // figure out which parameters are captured for this function when
2523     // we actually generate code for it. For now, we just propagate to
2524     // our parent scopes which variables we might have closed over that
2525     // belong to them. This is necessary for correctness when using
2526     // the source provider cache because we can&#39;t close over a variable
2527     // that we don&#39;t claim to close over. The source provider cache must
2528     // know this information to properly cache this function.
2529     // This might work itself out nicer if we declared a different
2530     // Scope struct for the parameters (because they are indeed implemented
2531     // as their own scope).
2532     UniquedStringImplPtrSet nonLocalCapturesFromParameterExpressions;
2533     functionScope-&gt;forEachUsedVariable([&amp;] (UniquedStringImpl* impl) {
2534         if (!functionScope-&gt;hasDeclaredParameter(impl)) {
2535             nonLocalCapturesFromParameterExpressions.add(impl);
2536             if (TreeBuilder::NeedsFreeVariableInfo)
2537                 parentScope-&gt;addClosedVariableCandidateUnconditionally(impl);
2538         }
2539     });
2540 
2541     auto performParsingFunctionBody = [&amp;] {
2542         return parseFunctionBody(context, syntaxChecker, startLocation, startColumn, functionKeywordStart, functionNameStart, parametersStart, constructorKind, expectedSuperBinding, functionBodyType, functionInfo.parameterCount, mode);
2543     };
2544 
2545     if (isGeneratorOrAsyncFunctionWrapperParseMode(mode)) {
2546         AutoPopScopeRef generatorBodyScope(this, pushScope());
2547         SourceParseMode innerParseMode = SourceParseMode::GeneratorBodyMode;
2548         if (isAsyncFunctionOrAsyncGeneratorWrapperParseMode(mode))
2549             innerParseMode = getAsynFunctionBodyParseMode(mode);
2550 
2551         generatorBodyScope-&gt;setSourceParseMode(innerParseMode);
2552         generatorBodyScope-&gt;setConstructorKind(ConstructorKind::None);
2553         generatorBodyScope-&gt;setExpectedSuperBinding(expectedSuperBinding);
2554 
2555         // Disallow &#39;use strict&#39; directives in the implicit inner function if
2556         // needed.
2557         if (functionScope-&gt;hasNonSimpleParameterList())
2558             generatorBodyScope-&gt;setHasNonSimpleParameterList();
2559 
2560         functionInfo.body = performParsingFunctionBody();
2561 
2562         // When a generator has a &quot;use strict&quot; directive, a generator function wrapping it should be strict mode.
2563         if  (generatorBodyScope-&gt;strictMode())
2564             functionScope-&gt;setStrictMode();
2565 
2566         popScope(generatorBodyScope, TreeBuilder::NeedsFreeVariableInfo);
2567     } else
2568         functionInfo.body = performParsingFunctionBody();
2569 
2570     restoreParserState(oldState);
2571     failIfFalse(functionInfo.body, &quot;Cannot parse the body of this &quot;, stringForFunctionMode(mode));
2572     context.setEndOffset(functionInfo.body, m_lexer-&gt;currentOffset());
2573     if (functionScope-&gt;strictMode() &amp;&amp; requirements != FunctionNameRequirements::Unnamed) {
2574         ASSERT(functionInfo.name);
2575         RELEASE_ASSERT(SourceParseModeSet(SourceParseMode::NormalFunctionMode, SourceParseMode::MethodMode, SourceParseMode::ArrowFunctionMode, SourceParseMode::GeneratorBodyMode, SourceParseMode::GeneratorWrapperFunctionMode).contains(mode) || isAsyncFunctionOrAsyncGeneratorWrapperParseMode(mode));
<a name="47" id="anc47"></a><span class="line-modified">2576         semanticFailIfTrue(m_vm-&gt;propertyNames-&gt;arguments == *functionInfo.name, &quot;&#39;&quot;, functionInfo.name-&gt;impl(), &quot;&#39; is not a valid function name in strict mode&quot;);</span>
<span class="line-modified">2577         semanticFailIfTrue(m_vm-&gt;propertyNames-&gt;eval == *functionInfo.name, &quot;&#39;&quot;, functionInfo.name-&gt;impl(), &quot;&#39; is not a valid function name in strict mode&quot;);</span>
2578     }
2579 
2580     JSTokenLocation location = JSTokenLocation(m_token.m_location);
2581     functionInfo.endOffset = m_token.m_data.offset;
2582 
2583     if (functionBodyType == ArrowFunctionBodyExpression) {
2584         location = locationBeforeLastToken();
2585         functionInfo.endOffset = location.endOffset;
2586     } else {
2587         recordFunctionEntryLocation(JSTextPosition(startLocation.line, startLocation.startOffset, startLocation.lineStartOffset));
2588         recordFunctionLeaveLocation(JSTextPosition(location.line, location.startOffset, location.lineStartOffset));
2589     }
2590 
2591     // Cache the tokenizer state and the function scope the first time the function is parsed.
2592     // Any future reparsing can then skip the function.
2593     // For arrow function is 8 = x=&gt;x + 4 symbols;
2594     // For ordinary function is 16  = function(){} + 4 symbols
2595     const int minimumSourceLengthToCache = functionBodyType == StandardFunctionBodyBlock ? 16 : 8;
2596     std::unique_ptr&lt;SourceProviderCacheItem&gt; newInfo;
2597     int sourceLength = functionInfo.endOffset - functionInfo.startOffset;
2598     if (TreeBuilder::CanUseFunctionCache &amp;&amp; m_functionCache &amp;&amp; sourceLength &gt; minimumSourceLengthToCache) {
2599         SourceProviderCacheItemCreationParameters parameters;
2600         parameters.endFunctionOffset = functionInfo.endOffset;
2601         parameters.lastTokenLine = location.line;
2602         parameters.lastTokenStartOffset = location.startOffset;
2603         parameters.lastTokenEndOffset = location.endOffset;
2604         parameters.lastTokenLineStartOffset = location.lineStartOffset;
2605         parameters.parameterCount = functionInfo.parameterCount;
2606         parameters.constructorKind = constructorKind;
2607         parameters.expectedSuperBinding = expectedSuperBinding;
2608         if (functionBodyType == ArrowFunctionBodyExpression) {
2609             parameters.isBodyArrowExpression = true;
2610             parameters.tokenType = m_token.m_type;
2611         }
2612         functionScope-&gt;fillParametersForSourceProviderCache(parameters, nonLocalCapturesFromParameterExpressions);
2613         newInfo = SourceProviderCacheItem::create(parameters);
2614     }
2615 
2616     bool functionScopeWasStrictMode = functionScope-&gt;strictMode();
2617 
2618     popScope(functionScope, TreeBuilder::NeedsFreeVariableInfo);
2619 
2620     if (functionBodyType != ArrowFunctionBodyExpression) {
2621         matchOrFail(CLOSEBRACE, &quot;Expected a closing &#39;}&#39; after a &quot;, stringForFunctionMode(mode), &quot; body&quot;);
2622         next();
2623     } else {
2624         // We need to lex the last token again because the last token is lexed under the different context because of the following possibilities.
2625         // 1. which may have different strict mode.
2626         // 2. which may not build strings for tokens.
2627         // But (1) is not possible because we do not recognize the string literal in ArrowFunctionBodyExpression as directive and this is correct in terms of the spec (`value =&gt; &quot;use strict&quot;`).
2628         // So we only check TreeBuilder&#39;s type here.
2629         ASSERT_UNUSED(functionScopeWasStrictMode, functionScopeWasStrictMode == currentScope()-&gt;strictMode());
2630         if (!std::is_same&lt;TreeBuilder, SyntaxChecker&gt;::value)
2631             lexCurrentTokenAgainUnderCurrentContext();
2632     }
2633 
2634     if (newInfo)
2635         m_functionCache-&gt;add(functionInfo.startOffset, WTFMove(newInfo));
2636 
2637     functionInfo.endLine = m_lastTokenEndPosition.line;
2638     return true;
2639 }
2640 
2641 static NO_RETURN_DUE_TO_CRASH FunctionMetadataNode* getMetadata(ParserFunctionInfo&lt;SyntaxChecker&gt;&amp;) { RELEASE_ASSERT_NOT_REACHED(); }
2642 static FunctionMetadataNode* getMetadata(ParserFunctionInfo&lt;ASTBuilder&gt;&amp; info) { return info.body; }
2643 
2644 template &lt;typename LexerType&gt;
2645 template &lt;class TreeBuilder&gt; TreeStatement Parser&lt;LexerType&gt;::parseFunctionDeclaration(TreeBuilder&amp; context, ExportType exportType, DeclarationDefaultContext declarationDefaultContext, Optional&lt;int&gt; functionConstructorParametersEndPosition)
2646 {
2647     ASSERT(match(FUNCTION));
2648     JSTokenLocation location(tokenLocation());
2649     unsigned functionKeywordStart = tokenStart();
2650     next();
2651     SourceParseMode parseMode = SourceParseMode::NormalFunctionMode;
2652     if (consume(TIMES))
2653         parseMode = SourceParseMode::GeneratorWrapperFunctionMode;
2654 
2655     ParserFunctionInfo&lt;TreeBuilder&gt; functionInfo;
2656     FunctionNameRequirements requirements = FunctionNameRequirements::Named;
2657     if (declarationDefaultContext == DeclarationDefaultContext::ExportDefault) {
2658         // Under the &quot;export default&quot; context, function declaration does not require the function name.
2659         //
2660         //     ExportDeclaration:
2661         //         ...
2662         //         export default HoistableDeclaration[~Yield, +Default]
2663         //         ...
2664         //
2665         //     HoistableDeclaration[Yield, Default]:
2666         //         FunctionDeclaration[?Yield, ?Default]
2667         //         GeneratorDeclaration[?Yield, ?Default]
2668         //
2669         //     FunctionDeclaration[Yield, Default]:
2670         //         ...
2671         //         [+Default] function ( FormalParameters[~Yield] ) { FunctionBody[~Yield] }
2672         //
2673         //     GeneratorDeclaration[Yield, Default]:
2674         //         ...
2675         //         [+Default] function * ( FormalParameters[+Yield] ) { GeneratorBody }
2676         //
2677         // In this case, we use &quot;*default*&quot; as this function declaration&#39;s name.
2678         requirements = FunctionNameRequirements::None;
<a name="48" id="anc48"></a><span class="line-modified">2679         functionInfo.name = &amp;m_vm-&gt;propertyNames-&gt;starDefaultPrivateName;</span>
2680     }
2681 
2682     failIfFalse((parseFunctionInfo(context, requirements, parseMode, true, ConstructorKind::None, SuperBinding::NotNeeded, functionKeywordStart, functionInfo, FunctionDefinitionType::Declaration, functionConstructorParametersEndPosition)), &quot;Cannot parse this function&quot;);
2683     ASSERT(functionInfo.name);
2684 
2685     std::pair&lt;DeclarationResultMask, ScopeRef&gt; functionDeclaration = declareFunction(functionInfo.name);
2686     DeclarationResultMask declarationResult = functionDeclaration.first;
2687     failIfTrueIfStrict(declarationResult &amp; DeclarationResult::InvalidStrictMode, &quot;Cannot declare a function named &#39;&quot;, functionInfo.name-&gt;impl(), &quot;&#39; in strict mode&quot;);
2688     if (declarationResult &amp; DeclarationResult::InvalidDuplicateDeclaration)
2689         internalFailWithMessage(false, &quot;Cannot declare a function that shadows a let/const/class/function variable &#39;&quot;, functionInfo.name-&gt;impl(), &quot;&#39; in strict mode&quot;);
2690     if (exportType == ExportType::Exported) {
2691         ASSERT_WITH_MESSAGE(declarationDefaultContext != DeclarationDefaultContext::ExportDefault, &quot;Export default case will export the name and binding in the caller.&quot;);
2692         semanticFailIfFalse(exportName(*functionInfo.name), &quot;Cannot export a duplicate function name: &#39;&quot;, functionInfo.name-&gt;impl(), &quot;&#39;&quot;);
2693         m_moduleScopeData-&gt;exportBinding(*functionInfo.name);
2694     }
2695 
2696     TreeStatement result = context.createFuncDeclStatement(location, functionInfo);
2697     if (TreeBuilder::CreatesAST)
2698         functionDeclaration.second-&gt;appendFunction(getMetadata(functionInfo));
2699     return result;
2700 }
2701 
2702 template &lt;typename LexerType&gt;
2703 template &lt;class TreeBuilder&gt; TreeStatement Parser&lt;LexerType&gt;::parseAsyncFunctionDeclaration(TreeBuilder&amp; context, ExportType exportType, DeclarationDefaultContext declarationDefaultContext, Optional&lt;int&gt; functionConstructorParametersEndPosition)
2704 {
2705     ASSERT(match(FUNCTION));
2706     JSTokenLocation location(tokenLocation());
2707     unsigned functionKeywordStart = tokenStart();
2708     next();
2709     ParserFunctionInfo&lt;TreeBuilder&gt; functionInfo;
2710     SourceParseMode parseMode = SourceParseMode::AsyncFunctionMode;
2711     if (consume(TIMES))
2712         parseMode = SourceParseMode::AsyncGeneratorWrapperFunctionMode;
2713 
2714     FunctionNameRequirements requirements = FunctionNameRequirements::Named;
2715     if (declarationDefaultContext == DeclarationDefaultContext::ExportDefault) {
2716         // Under the &quot;export default&quot; context, function declaration does not require the function name.
2717         //
2718         //     ExportDeclaration:
2719         //         ...
2720         //         export default HoistableDeclaration[~Yield, +Default]
2721         //         ...
2722         //
2723         //     HoistableDeclaration[Yield, Default]:
2724         //         FunctionDeclaration[?Yield, ?Default]
2725         //         GeneratorDeclaration[?Yield, ?Default]
2726         //
2727         //     FunctionDeclaration[Yield, Default]:
2728         //         ...
2729         //         [+Default] function ( FormalParameters[~Yield] ) { FunctionBody[~Yield] }
2730         //
2731         //     GeneratorDeclaration[Yield, Default]:
2732         //         ...
2733         //         [+Default] function * ( FormalParameters[+Yield] ) { GeneratorBody }
2734         //
2735         // In this case, we use &quot;*default*&quot; as this function declaration&#39;s name.
2736         requirements = FunctionNameRequirements::None;
<a name="49" id="anc49"></a><span class="line-modified">2737         functionInfo.name = &amp;m_vm-&gt;propertyNames-&gt;starDefaultPrivateName;</span>
2738     }
2739 
2740     failIfFalse((parseFunctionInfo(context, requirements, parseMode, true, ConstructorKind::None, SuperBinding::NotNeeded, functionKeywordStart, functionInfo, FunctionDefinitionType::Declaration, functionConstructorParametersEndPosition)), &quot;Cannot parse this async function&quot;);
2741     failIfFalse(functionInfo.name, &quot;Async function statements must have a name&quot;);
2742 
2743     std::pair&lt;DeclarationResultMask, ScopeRef&gt; functionDeclaration = declareFunction(functionInfo.name);
2744     DeclarationResultMask declarationResult = functionDeclaration.first;
2745     failIfTrueIfStrict(declarationResult &amp; DeclarationResult::InvalidStrictMode, &quot;Cannot declare an async function named &#39;&quot;, functionInfo.name-&gt;impl(), &quot;&#39; in strict mode&quot;);
2746     if (declarationResult &amp; DeclarationResult::InvalidDuplicateDeclaration)
2747         internalFailWithMessage(false, &quot;Cannot declare an async function that shadows a let/const/class/function variable &#39;&quot;, functionInfo.name-&gt;impl(), &quot;&#39; in strict mode&quot;);
2748     if (exportType == ExportType::Exported) {
2749         semanticFailIfFalse(exportName(*functionInfo.name), &quot;Cannot export a duplicate function name: &#39;&quot;, functionInfo.name-&gt;impl(), &quot;&#39;&quot;);
2750         m_moduleScopeData-&gt;exportBinding(*functionInfo.name);
2751     }
2752 
2753     TreeStatement result = context.createFuncDeclStatement(location, functionInfo);
2754     if (TreeBuilder::CreatesAST)
2755         functionDeclaration.second-&gt;appendFunction(getMetadata(functionInfo));
2756     return result;
2757 }
2758 
2759 template &lt;typename LexerType&gt;
2760 template &lt;class TreeBuilder&gt; TreeStatement Parser&lt;LexerType&gt;::parseClassDeclaration(TreeBuilder&amp; context, ExportType exportType, DeclarationDefaultContext declarationDefaultContext)
2761 {
2762     ASSERT(match(CLASSTOKEN));
2763     JSTokenLocation location(tokenLocation());
2764     JSTextPosition classStart = tokenStartPosition();
2765     unsigned classStartLine = tokenLine();
2766 
2767     ParserClassInfo&lt;TreeBuilder&gt; info;
2768     FunctionNameRequirements requirements = FunctionNameRequirements::Named;
2769     if (declarationDefaultContext == DeclarationDefaultContext::ExportDefault) {
2770         // Under the &quot;export default&quot; context, class declaration does not require the class name.
2771         //
2772         //     ExportDeclaration:
2773         //         ...
2774         //         export default ClassDeclaration[~Yield, +Default]
2775         //         ...
2776         //
2777         //     ClassDeclaration[Yield, Default]:
2778         //         ...
2779         //         [+Default] class ClassTail[?Yield]
2780         //
2781         // In this case, we use &quot;*default*&quot; as this class declaration&#39;s name.
2782         requirements = FunctionNameRequirements::None;
<a name="50" id="anc50"></a><span class="line-modified">2783         info.className = &amp;m_vm-&gt;propertyNames-&gt;starDefaultPrivateName;</span>
2784     }
2785 
2786     TreeClassExpression classExpr = parseClass(context, requirements, info);
2787     failIfFalse(classExpr, &quot;Failed to parse class&quot;);
2788     ASSERT(info.className);
2789 
2790     DeclarationResultMask declarationResult = declareVariable(info.className, DeclarationType::LetDeclaration);
2791     if (declarationResult &amp; DeclarationResult::InvalidDuplicateDeclaration)
2792         internalFailWithMessage(false, &quot;Cannot declare a class twice: &#39;&quot;, info.className-&gt;impl(), &quot;&#39;&quot;);
2793     if (exportType == ExportType::Exported) {
2794         ASSERT_WITH_MESSAGE(declarationDefaultContext != DeclarationDefaultContext::ExportDefault, &quot;Export default case will export the name and binding in the caller.&quot;);
2795         semanticFailIfFalse(exportName(*info.className), &quot;Cannot export a duplicate class name: &#39;&quot;, info.className-&gt;impl(), &quot;&#39;&quot;);
2796         m_moduleScopeData-&gt;exportBinding(*info.className);
2797     }
2798 
2799     JSTextPosition classEnd = lastTokenEndPosition();
2800     unsigned classEndLine = tokenLine();
2801 
2802     return context.createClassDeclStatement(location, classExpr, classStart, classEnd, classStartLine, classEndLine);
2803 }
2804 
2805 template &lt;typename LexerType&gt;
2806 template &lt;class TreeBuilder&gt; TreeClassExpression Parser&lt;LexerType&gt;::parseClass(TreeBuilder&amp; context, FunctionNameRequirements requirements, ParserClassInfo&lt;TreeBuilder&gt;&amp; info)
2807 {
2808     ASSERT(match(CLASSTOKEN));
2809     JSTokenLocation location(tokenLocation());
2810     info.startLine = location.line;
2811     info.startColumn = tokenColumn();
2812     info.startOffset = location.startOffset;
2813     next();
2814 
2815     AutoPopScopeRef classScope(this, pushScope());
2816     classScope-&gt;setIsLexicalScope();
2817     classScope-&gt;preventVarDeclarations();
2818     classScope-&gt;setStrictMode();
2819 
2820     ASSERT_WITH_MESSAGE(requirements != FunctionNameRequirements::Unnamed, &quot;Currently, there is no caller that uses FunctionNameRequirements::Unnamed for class syntax.&quot;);
2821     ASSERT_WITH_MESSAGE(!(requirements == FunctionNameRequirements::None &amp;&amp; !info.className), &quot;When specifying FunctionNameRequirements::None, we need to initialize info.className with the default value in the caller side.&quot;);
2822     if (match(IDENT)) {
2823         info.className = m_token.m_data.ident;
2824         next();
2825         failIfTrue(classScope-&gt;declareLexicalVariable(info.className, true) &amp; DeclarationResult::InvalidStrictMode, &quot;&#39;&quot;, info.className-&gt;impl(), &quot;&#39; is not a valid class name&quot;);
2826     } else if (requirements == FunctionNameRequirements::Named) {
2827         if (match(OPENBRACE))
2828             semanticFail(&quot;Class statements must have a name&quot;);
2829         semanticFailureDueToKeyword(&quot;class name&quot;);
2830         failDueToUnexpectedToken();
2831     }
2832     ASSERT(info.className);
2833 
2834     TreeExpression parentClass = 0;
2835     if (consume(EXTENDS)) {
2836         parentClass = parseMemberExpression(context);
2837         failIfFalse(parentClass, &quot;Cannot parse the parent class name&quot;);
2838     }
2839     const ConstructorKind constructorKind = parentClass ? ConstructorKind::Extends : ConstructorKind::Base;
2840 
2841     consumeOrFail(OPENBRACE, &quot;Expected opening &#39;{&#39; at the start of a class body&quot;);
2842 
2843     TreeExpression constructor = 0;
2844     TreePropertyList classElements = 0;
2845     TreePropertyList classElementsTail = 0;
2846     while (!match(CLOSEBRACE)) {
2847         if (match(SEMICOLON)) {
2848             next();
2849             continue;
2850         }
2851 
2852         JSTokenLocation methodLocation(tokenLocation());
2853         unsigned methodStart = tokenStart();
2854 
2855         // For backwards compatibility, &quot;static&quot; is a non-reserved keyword in non-strict mode.
2856         ClassElementTag tag = ClassElementTag::Instance;
<a name="51" id="anc51"></a><span class="line-modified">2857         if (match(RESERVED_IF_STRICT) &amp;&amp; *m_token.m_data.ident == m_vm-&gt;propertyNames-&gt;staticKeyword) {</span>
2858             SavePoint savePoint = createSavePoint();
2859             next();
2860             if (match(OPENPAREN)) {
2861                 // Reparse &quot;static()&quot; as a method named &quot;static&quot;.
2862                 restoreSavePoint(savePoint);
2863             } else
2864                 tag = ClassElementTag::Static;
2865         }
2866 
2867         // FIXME: Figure out a way to share more code with parseProperty.
<a name="52" id="anc52"></a><span class="line-modified">2868         const CommonIdentifiers&amp; propertyNames = *m_vm-&gt;propertyNames;</span>
2869         const Identifier* ident = &amp;propertyNames.nullIdentifier;
2870         TreeExpression computedPropertyName = 0;
2871         bool isGetter = false;
2872         bool isSetter = false;
2873         SourceParseMode parseMode = SourceParseMode::MethodMode;
2874         if (consume(TIMES))
2875             parseMode = SourceParseMode::GeneratorWrapperMethodMode;
2876 
2877 parseMethod:
2878         switch (m_token.m_type) {
2879         namedKeyword:
2880         case STRING:
2881             ident = m_token.m_data.ident;
2882             ASSERT(ident);
2883             next();
2884             break;
2885         case IDENT:
<a name="53" id="anc53"></a><span class="line-modified">2886             if (UNLIKELY(*m_token.m_data.ident == m_vm-&gt;propertyNames-&gt;async &amp;&amp; !m_token.m_data.escaped)) {</span>
2887                 if (!isGeneratorMethodParseMode(parseMode) &amp;&amp; !isAsyncMethodParseMode(parseMode)) {
2888                     ident = m_token.m_data.ident;
2889                     next();
2890                     if (match(OPENPAREN) || match(COLON) || match(EQUAL) || m_lexer-&gt;hasLineTerminatorBeforeToken())
2891                         break;
2892                     if (UNLIKELY(consume(TIMES)))
2893                         parseMode = SourceParseMode::AsyncGeneratorWrapperMethodMode;
2894                     else
2895                         parseMode = SourceParseMode::AsyncMethodMode;
2896                     goto parseMethod;
2897                 }
2898             }
2899             FALLTHROUGH;
2900         case AWAIT:
2901             ident = m_token.m_data.ident;
2902             ASSERT(ident);
2903             next();
2904             if (parseMode == SourceParseMode::MethodMode &amp;&amp; (matchIdentifierOrKeyword() || match(STRING) || match(DOUBLE) || match(INTEGER) || match(OPENBRACKET))) {
2905                 isGetter = *ident == propertyNames.get;
2906                 isSetter = *ident == propertyNames.set;
2907             }
2908             break;
2909         case DOUBLE:
2910         case INTEGER:
<a name="54" id="anc54"></a><span class="line-modified">2911             ident = &amp;m_parserArena.identifierArena().makeNumericIdentifier(const_cast&lt;VM*&gt;(m_vm), m_token.m_data.doubleValue);</span>
2912             ASSERT(ident);
2913             next();
2914             break;
2915         case OPENBRACKET:
2916             next();
2917             computedPropertyName = parseAssignmentExpression(context);
2918             failIfFalse(computedPropertyName, &quot;Cannot parse computed property name&quot;);
2919             handleProductionOrFail(CLOSEBRACKET, &quot;]&quot;, &quot;end&quot;, &quot;computed property name&quot;);
2920             break;
2921         default:
2922             if (m_token.m_type &amp; KeywordTokenFlag)
2923                 goto namedKeyword;
2924             failDueToUnexpectedToken();
2925         }
2926 
2927         TreeProperty property;
2928         const bool alwaysStrictInsideClass = true;
2929         if (isGetter || isSetter) {
2930             property = parseGetterSetter(context, alwaysStrictInsideClass, isGetter ? PropertyNode::Getter : PropertyNode::Setter,
2931                 methodStart, ConstructorKind::None, tag);
2932             failIfFalse(property, &quot;Cannot parse this method&quot;);
2933         } else {
2934             ParserFunctionInfo&lt;TreeBuilder&gt; methodInfo;
2935             bool isConstructor = tag == ClassElementTag::Instance &amp;&amp; *ident == propertyNames.constructor;
2936             if (isAsyncMethodParseMode(parseMode) || isAsyncGeneratorMethodParseMode(parseMode) || isGeneratorMethodParseMode(parseMode)) {
2937                 isConstructor = false;
<a name="55" id="anc55"></a><span class="line-modified">2938                 semanticFailIfTrue(*ident == m_vm-&gt;propertyNames-&gt;prototype, &quot;Cannot declare &quot;, stringArticleForFunctionMode(parseMode), stringForFunctionMode(parseMode), &quot; named &#39;prototype&#39;&quot;);</span>
<span class="line-modified">2939                 semanticFailIfTrue(*ident == m_vm-&gt;propertyNames-&gt;constructor, &quot;Cannot declare &quot;, stringArticleForFunctionMode(parseMode), stringForFunctionMode(parseMode), &quot; named &#39;constructor&#39;&quot;);</span>
2940             }
2941 
2942             methodInfo.name = isConstructor ? info.className : ident;
2943             failIfFalse((parseFunctionInfo(context, FunctionNameRequirements::Unnamed, parseMode, false, isConstructor ? constructorKind : ConstructorKind::None, SuperBinding::Needed, methodStart, methodInfo, FunctionDefinitionType::Method)), &quot;Cannot parse this method&quot;);
2944 
2945             TreeExpression method = context.createMethodDefinition(methodLocation, methodInfo);
2946             if (isConstructor) {
2947                 semanticFailIfTrue(constructor, &quot;Cannot declare multiple constructors in a single class&quot;);
2948                 constructor = method;
2949                 continue;
2950             }
2951 
2952             // FIXME: Syntax error when super() is called
2953             semanticFailIfTrue(tag == ClassElementTag::Static &amp;&amp; methodInfo.name &amp;&amp; *methodInfo.name == propertyNames.prototype,
2954                 &quot;Cannot declare a static method named &#39;prototype&#39;&quot;);
2955 
2956             if (computedPropertyName) {
2957                 property = context.createProperty(computedPropertyName, method, static_cast&lt;PropertyNode::Type&gt;(PropertyNode::Constant | PropertyNode::Computed),
2958                     PropertyNode::Unknown, alwaysStrictInsideClass, SuperBinding::Needed, tag);
2959             } else {
2960                 property = context.createProperty(methodInfo.name, method, PropertyNode::Constant,
2961                     PropertyNode::Unknown, alwaysStrictInsideClass, SuperBinding::Needed, InferName::Allowed, tag);
2962             }
2963         }
2964 
2965         if (classElementsTail)
2966             classElementsTail = context.createPropertyList(methodLocation, property, classElementsTail);
2967         else
2968             classElements = classElementsTail = context.createPropertyList(methodLocation, property);
2969     }
2970 
2971     info.endOffset = tokenLocation().endOffset - 1;
2972     consumeOrFail(CLOSEBRACE, &quot;Expected a closing &#39;}&#39; after a class body&quot;);
2973 
2974     auto classExpression = context.createClassExpr(location, info, classScope-&gt;finalizeLexicalEnvironment(), constructor, parentClass, classElements);
2975     popScope(classScope, TreeBuilder::NeedsFreeVariableInfo);
2976     return classExpression;
2977 }
2978 
2979 struct LabelInfo {
2980     LabelInfo(const Identifier* ident, const JSTextPosition&amp; start, const JSTextPosition&amp; end)
2981     : m_ident(ident)
2982     , m_start(start)
2983     , m_end(end)
2984     {
2985     }
2986 
2987     const Identifier* m_ident;
2988     JSTextPosition m_start;
2989     JSTextPosition m_end;
2990 };
2991 
2992 template &lt;typename LexerType&gt;
2993 template &lt;class TreeBuilder&gt; TreeStatement Parser&lt;LexerType&gt;::parseExpressionOrLabelStatement(TreeBuilder&amp; context, bool allowFunctionDeclarationAsStatement)
2994 {
2995 
2996     /* Expression and Label statements are ambiguous at LL(1), so we have a
2997      * special case that looks for a colon as the next character in the input.
2998      */
2999     Vector&lt;LabelInfo&gt; labels;
3000     JSTokenLocation location;
3001     do {
3002         JSTextPosition start = tokenStartPosition();
3003         location = tokenLocation();
3004         if (!nextTokenIsColon()) {
3005             // If we hit this path we&#39;re making a expression statement, which
3006             // by definition can&#39;t make use of continue/break so we can just
3007             // ignore any labels we might have accumulated.
3008             TreeExpression expression = parseExpression(context);
3009             failIfFalse(expression, &quot;Cannot parse expression statement&quot;);
3010             if (!autoSemiColon())
3011                 failDueToUnexpectedToken();
3012             return context.createExprStatement(location, expression, start, m_lastTokenEndPosition.line);
3013         }
3014 
3015         semanticFailIfTrue(isDisallowedIdentifierAwait(m_token), &quot;Cannot use &#39;await&#39; as a label &quot;, disallowedIdentifierAwaitReason());
3016         semanticFailIfTrue(isDisallowedIdentifierYield(m_token), &quot;Cannot use &#39;yield&#39; as a label &quot;, disallowedIdentifierYieldReason());
3017 
3018         const Identifier* ident = m_token.m_data.ident;
3019         JSTextPosition end = tokenEndPosition();
3020         next();
3021         consumeOrFail(COLON, &quot;Labels must be followed by a &#39;:&#39;&quot;);
3022 
3023         // This is O(N^2) over the current list of consecutive labels, but I
3024         // have never seen more than one label in a row in the real world.
3025         for (size_t i = 0; i &lt; labels.size(); i++)
3026             failIfTrue(ident-&gt;impl() == labels[i].m_ident-&gt;impl(), &quot;Attempted to redeclare the label &#39;&quot;, ident-&gt;impl(), &quot;&#39;&quot;);
3027         failIfTrue(getLabel(ident), &quot;Cannot find scope for the label &#39;&quot;, ident-&gt;impl(), &quot;&#39;&quot;);
3028         labels.append(LabelInfo(ident, start, end));
3029     } while (matchSpecIdentifier());
3030     bool isLoop = false;
3031     switch (m_token.m_type) {
3032     case FOR:
3033     case WHILE:
3034     case DO:
3035         isLoop = true;
3036         break;
3037 
3038     default:
3039         break;
3040     }
3041     const Identifier* unused = 0;
3042     ScopeRef labelScope = currentScope();
3043     for (size_t i = 0; i &lt; labels.size(); i++)
3044         pushLabel(labels[i].m_ident, isLoop);
3045     m_immediateParentAllowsFunctionDeclarationInStatement = allowFunctionDeclarationAsStatement;
3046     TreeStatement statement = parseStatement(context, unused);
3047     for (size_t i = 0; i &lt; labels.size(); i++)
3048         popLabel(labelScope);
3049     failIfFalse(statement, &quot;Cannot parse statement&quot;);
3050     for (size_t i = 0; i &lt; labels.size(); i++) {
3051         const LabelInfo&amp; info = labels[labels.size() - i - 1];
3052         statement = context.createLabelStatement(location, info.m_ident, statement, info.m_start, info.m_end);
3053     }
3054     return statement;
3055 }
3056 
3057 template &lt;typename LexerType&gt;
3058 template &lt;class TreeBuilder&gt; TreeStatement Parser&lt;LexerType&gt;::parseExpressionStatement(TreeBuilder&amp; context)
3059 {
3060     switch (m_token.m_type) {
3061     // Consult: http://www.ecma-international.org/ecma-262/6.0/index.html#sec-expression-statement
3062     // The ES6 spec mandates that we should fail from FUNCTION token here. We handle this case
3063     // in parseStatement() which is the only caller of parseExpressionStatement().
3064     // We actually allow FUNCTION in situations where it should not be allowed unless we&#39;re in strict mode.
3065     case CLASSTOKEN:
3066         failWithMessage(&quot;&#39;class&#39; declaration is not directly within a block statement&quot;);
3067         break;
3068     default:
3069         // FIXME: when implementing &#39;let&#39; we should fail when we see the token sequence &quot;let [&quot;.
3070         // https://bugs.webkit.org/show_bug.cgi?id=142944
3071         break;
3072     }
3073     JSTextPosition start = tokenStartPosition();
3074     JSTokenLocation location(tokenLocation());
3075     TreeExpression expression = parseExpression(context);
3076     failIfFalse(expression, &quot;Cannot parse expression statement&quot;);
3077     failIfFalse(autoSemiColon(), &quot;Parse error&quot;);
3078     return context.createExprStatement(location, expression, start, m_lastTokenEndPosition.line);
3079 }
3080 
3081 template &lt;typename LexerType&gt;
3082 template &lt;class TreeBuilder&gt; TreeStatement Parser&lt;LexerType&gt;::parseIfStatement(TreeBuilder&amp; context)
3083 {
3084     ASSERT(match(IF));
3085     JSTokenLocation ifLocation(tokenLocation());
3086     int start = tokenLine();
3087     next();
3088     handleProductionOrFail2(OPENPAREN, &quot;(&quot;, &quot;start&quot;, &quot;&#39;if&#39; condition&quot;);
3089 
3090     TreeExpression condition = parseExpression(context);
<a name="56" id="anc56"></a><span class="line-modified">3091     failIfFalse(condition, &quot;Expected a expression as the condition for an if statement&quot;);</span>
3092     recordPauseLocation(context.breakpointLocation(condition));
3093     int end = tokenLine();
3094     handleProductionOrFail2(CLOSEPAREN, &quot;)&quot;, &quot;end&quot;, &quot;&#39;if&#39; condition&quot;);
3095 
3096     const Identifier* unused = 0;
3097     m_immediateParentAllowsFunctionDeclarationInStatement = true;
3098     TreeStatement trueBlock = parseStatement(context, unused);
3099     failIfFalse(trueBlock, &quot;Expected a statement as the body of an if block&quot;);
3100 
3101     if (!match(ELSE))
3102         return context.createIfStatement(ifLocation, condition, trueBlock, 0, start, end);
3103 
3104     Vector&lt;TreeExpression&gt; exprStack;
3105     Vector&lt;std::pair&lt;int, int&gt;&gt; posStack;
3106     Vector&lt;JSTokenLocation&gt; tokenLocationStack;
3107     Vector&lt;TreeStatement&gt; statementStack;
3108     bool trailingElse = false;
3109     do {
3110         JSTokenLocation tempLocation = tokenLocation();
3111         next();
3112         if (!match(IF)) {
3113             const Identifier* unused = 0;
3114             m_immediateParentAllowsFunctionDeclarationInStatement = true;
3115             TreeStatement block = parseStatement(context, unused);
3116             failIfFalse(block, &quot;Expected a statement as the body of an else block&quot;);
3117             statementStack.append(block);
3118             trailingElse = true;
3119             break;
3120         }
3121         int innerStart = tokenLine();
3122         next();
3123 
3124         handleProductionOrFail2(OPENPAREN, &quot;(&quot;, &quot;start&quot;, &quot;&#39;if&#39; condition&quot;);
3125 
3126         TreeExpression innerCondition = parseExpression(context);
<a name="57" id="anc57"></a><span class="line-modified">3127         failIfFalse(innerCondition, &quot;Expected a expression as the condition for an if statement&quot;);</span>
3128         recordPauseLocation(context.breakpointLocation(innerCondition));
3129         int innerEnd = tokenLine();
3130         handleProductionOrFail2(CLOSEPAREN, &quot;)&quot;, &quot;end&quot;, &quot;&#39;if&#39; condition&quot;);
3131         const Identifier* unused = 0;
3132         m_immediateParentAllowsFunctionDeclarationInStatement = true;
3133         TreeStatement innerTrueBlock = parseStatement(context, unused);
3134         failIfFalse(innerTrueBlock, &quot;Expected a statement as the body of an if block&quot;);
3135         tokenLocationStack.append(tempLocation);
3136         exprStack.append(innerCondition);
3137         posStack.append(std::make_pair(innerStart, innerEnd));
3138         statementStack.append(innerTrueBlock);
3139     } while (match(ELSE));
3140 
3141     if (!trailingElse) {
3142         TreeExpression condition = exprStack.last();
3143         exprStack.removeLast();
3144         TreeStatement trueBlock = statementStack.last();
3145         statementStack.removeLast();
3146         std::pair&lt;int, int&gt; pos = posStack.last();
3147         posStack.removeLast();
3148         JSTokenLocation elseLocation = tokenLocationStack.last();
3149         tokenLocationStack.removeLast();
3150         TreeStatement ifStatement = context.createIfStatement(elseLocation, condition, trueBlock, 0, pos.first, pos.second);
3151         context.setEndOffset(ifStatement, context.endOffset(trueBlock));
3152         statementStack.append(ifStatement);
3153     }
3154 
3155     while (!exprStack.isEmpty()) {
3156         TreeExpression condition = exprStack.last();
3157         exprStack.removeLast();
3158         TreeStatement falseBlock = statementStack.last();
3159         statementStack.removeLast();
3160         TreeStatement trueBlock = statementStack.last();
3161         statementStack.removeLast();
3162         std::pair&lt;int, int&gt; pos = posStack.last();
3163         posStack.removeLast();
3164         JSTokenLocation elseLocation = tokenLocationStack.last();
3165         tokenLocationStack.removeLast();
3166         TreeStatement ifStatement = context.createIfStatement(elseLocation, condition, trueBlock, falseBlock, pos.first, pos.second);
3167         context.setEndOffset(ifStatement, context.endOffset(falseBlock));
3168         statementStack.append(ifStatement);
3169     }
3170 
3171     return context.createIfStatement(ifLocation, condition, trueBlock, statementStack.last(), start, end);
3172 }
3173 
3174 template &lt;typename LexerType&gt;
3175 template &lt;class TreeBuilder&gt; typename TreeBuilder::ModuleName Parser&lt;LexerType&gt;::parseModuleName(TreeBuilder&amp; context)
3176 {
3177     // ModuleName (ModuleSpecifier in the spec) represents the module name imported by the script.
3178     // http://www.ecma-international.org/ecma-262/6.0/#sec-imports
3179     // http://www.ecma-international.org/ecma-262/6.0/#sec-exports
3180     JSTokenLocation specifierLocation(tokenLocation());
3181     failIfFalse(match(STRING), &quot;Imported modules names must be string literals&quot;);
3182     const Identifier* moduleName = m_token.m_data.ident;
3183     next();
3184     return context.createModuleName(specifierLocation, *moduleName);
3185 }
3186 
3187 template &lt;typename LexerType&gt;
3188 template &lt;class TreeBuilder&gt; typename TreeBuilder::ImportSpecifier Parser&lt;LexerType&gt;::parseImportClauseItem(TreeBuilder&amp; context, ImportSpecifierType specifierType)
3189 {
3190     // Produced node is the item of the ImportClause.
3191     // That is the ImportSpecifier, ImportedDefaultBinding or NameSpaceImport.
3192     // http://www.ecma-international.org/ecma-262/6.0/#sec-imports
3193     JSTokenLocation specifierLocation(tokenLocation());
3194     JSToken localNameToken;
3195     const Identifier* importedName = nullptr;
3196     const Identifier* localName = nullptr;
3197 
3198     switch (specifierType) {
3199     case ImportSpecifierType::NamespaceImport: {
3200         // NameSpaceImport :
3201         // * as ImportedBinding
3202         // e.g.
3203         //     * as namespace
3204         ASSERT(match(TIMES));
<a name="58" id="anc58"></a><span class="line-modified">3205         importedName = &amp;m_vm-&gt;propertyNames-&gt;timesIdentifier;</span>
3206         next();
3207 
<a name="59" id="anc59"></a><span class="line-modified">3208         failIfFalse(matchContextualKeyword(m_vm-&gt;propertyNames-&gt;as), &quot;Expected &#39;as&#39; before imported binding name&quot;);</span>
3209         next();
3210 
3211         failIfFalse(matchSpecIdentifier(), &quot;Expected a variable name for the import declaration&quot;);
3212         localNameToken = m_token;
3213         localName = m_token.m_data.ident;
3214         next();
3215         break;
3216     }
3217 
3218     case ImportSpecifierType::NamedImport: {
3219         // ImportSpecifier :
3220         // ImportedBinding
3221         // IdentifierName as ImportedBinding
3222         // e.g.
3223         //     A
3224         //     A as B
3225         ASSERT(matchIdentifierOrKeyword());
3226         localNameToken = m_token;
3227         localName = m_token.m_data.ident;
3228         importedName = localName;
3229         next();
3230 
<a name="60" id="anc60"></a><span class="line-modified">3231         if (matchContextualKeyword(m_vm-&gt;propertyNames-&gt;as)) {</span>
3232             next();
3233             failIfFalse(matchSpecIdentifier(), &quot;Expected a variable name for the import declaration&quot;);
3234             localNameToken = m_token;
3235             localName = m_token.m_data.ident;
3236             next();
3237         }
3238         break;
3239     }
3240 
3241     case ImportSpecifierType::DefaultImport: {
3242         // ImportedDefaultBinding :
3243         // ImportedBinding
3244         ASSERT(matchSpecIdentifier());
3245         localNameToken = m_token;
3246         localName = m_token.m_data.ident;
<a name="61" id="anc61"></a><span class="line-modified">3247         importedName = &amp;m_vm-&gt;propertyNames-&gt;defaultKeyword;</span>
3248         next();
3249         break;
3250     }
3251     }
3252 
3253     semanticFailIfTrue(localNameToken.m_type == AWAIT, &quot;Cannot use &#39;await&#39; as an imported binding name&quot;);
3254     semanticFailIfTrue(localNameToken.m_type &amp; KeywordTokenFlag, &quot;Cannot use keyword as imported binding name&quot;);
3255     DeclarationResultMask declarationResult = declareVariable(localName, DeclarationType::ConstDeclaration, (specifierType == ImportSpecifierType::NamespaceImport) ? DeclarationImportType::ImportedNamespace : DeclarationImportType::Imported);
3256     if (declarationResult != DeclarationResult::Valid) {
3257         failIfTrueIfStrict(declarationResult &amp; DeclarationResult::InvalidStrictMode, &quot;Cannot declare an imported binding named &quot;, localName-&gt;impl(), &quot; in strict mode&quot;);
3258         if (declarationResult &amp; DeclarationResult::InvalidDuplicateDeclaration)
3259             internalFailWithMessage(false, &quot;Cannot declare an imported binding name twice: &#39;&quot;, localName-&gt;impl(), &quot;&#39;&quot;);
3260     }
3261 
3262     return context.createImportSpecifier(specifierLocation, *importedName, *localName);
3263 }
3264 
3265 template &lt;typename LexerType&gt;
3266 template &lt;class TreeBuilder&gt; TreeStatement Parser&lt;LexerType&gt;::parseImportDeclaration(TreeBuilder&amp; context)
3267 {
3268     // http://www.ecma-international.org/ecma-262/6.0/#sec-imports
3269     ASSERT(match(IMPORT));
3270     JSTokenLocation importLocation(tokenLocation());
3271     next();
3272 
3273     auto specifierList = context.createImportSpecifierList();
3274 
3275     if (match(STRING)) {
3276         // import ModuleSpecifier ;
3277         auto moduleName = parseModuleName(context);
3278         failIfFalse(moduleName, &quot;Cannot parse the module name&quot;);
3279         failIfFalse(autoSemiColon(), &quot;Expected a &#39;;&#39; following a targeted import declaration&quot;);
3280         return context.createImportDeclaration(importLocation, specifierList, moduleName);
3281     }
3282 
3283     bool isFinishedParsingImport = false;
3284     if (matchSpecIdentifier()) {
3285         // ImportedDefaultBinding :
3286         // ImportedBinding
3287         auto specifier = parseImportClauseItem(context, ImportSpecifierType::DefaultImport);
3288         failIfFalse(specifier, &quot;Cannot parse the default import&quot;);
3289         context.appendImportSpecifier(specifierList, specifier);
3290         if (match(COMMA))
3291             next();
3292         else
3293             isFinishedParsingImport = true;
3294     }
3295 
3296     if (!isFinishedParsingImport) {
3297         if (match(TIMES)) {
3298             // import NameSpaceImport FromClause ;
3299             auto specifier = parseImportClauseItem(context, ImportSpecifierType::NamespaceImport);
3300             failIfFalse(specifier, &quot;Cannot parse the namespace import&quot;);
3301             context.appendImportSpecifier(specifierList, specifier);
3302         } else if (match(OPENBRACE)) {
3303             // NamedImports :
3304             // { }
3305             // { ImportsList }
3306             // { ImportsList , }
3307             next();
3308 
3309             while (!match(CLOSEBRACE)) {
3310                 failIfFalse(matchIdentifierOrKeyword(), &quot;Expected an imported name for the import declaration&quot;);
3311                 auto specifier = parseImportClauseItem(context, ImportSpecifierType::NamedImport);
3312                 failIfFalse(specifier, &quot;Cannot parse the named import&quot;);
3313                 context.appendImportSpecifier(specifierList, specifier);
3314                 if (!consume(COMMA))
3315                     break;
3316             }
3317             handleProductionOrFail2(CLOSEBRACE, &quot;}&quot;, &quot;end&quot;, &quot;import list&quot;);
3318         } else
3319             failWithMessage(&quot;Expected namespace import or import list&quot;);
3320     }
3321 
3322     // FromClause :
3323     // from ModuleSpecifier
3324 
<a name="62" id="anc62"></a><span class="line-modified">3325     failIfFalse(matchContextualKeyword(m_vm-&gt;propertyNames-&gt;from), &quot;Expected &#39;from&#39; before imported module name&quot;);</span>
3326     next();
3327 
3328     auto moduleName = parseModuleName(context);
3329     failIfFalse(moduleName, &quot;Cannot parse the module name&quot;);
3330     failIfFalse(autoSemiColon(), &quot;Expected a &#39;;&#39; following a targeted import declaration&quot;);
3331 
3332     return context.createImportDeclaration(importLocation, specifierList, moduleName);
3333 }
3334 
3335 template &lt;typename LexerType&gt;
3336 template &lt;class TreeBuilder&gt; typename TreeBuilder::ExportSpecifier Parser&lt;LexerType&gt;::parseExportSpecifier(TreeBuilder&amp; context, Vector&lt;std::pair&lt;const Identifier*, const Identifier*&gt;&gt;&amp; maybeExportedLocalNames, bool&amp; hasKeywordForLocalBindings)
3337 {
3338     // ExportSpecifier :
3339     // IdentifierName
3340     // IdentifierName as IdentifierName
3341     // http://www.ecma-international.org/ecma-262/6.0/#sec-exports
3342     ASSERT(matchIdentifierOrKeyword());
3343     JSTokenLocation specifierLocation(tokenLocation());
3344     if (m_token.m_type &amp; KeywordTokenFlag)
3345         hasKeywordForLocalBindings = true;
3346     const Identifier* localName = m_token.m_data.ident;
3347     const Identifier* exportedName = localName;
3348     next();
3349 
<a name="63" id="anc63"></a><span class="line-modified">3350     if (matchContextualKeyword(m_vm-&gt;propertyNames-&gt;as)) {</span>
3351         next();
3352         failIfFalse(matchIdentifierOrKeyword(), &quot;Expected an exported name for the export declaration&quot;);
3353         exportedName = m_token.m_data.ident;
3354         next();
3355     }
3356 
3357     semanticFailIfFalse(exportName(*exportedName), &quot;Cannot export a duplicate name &#39;&quot;, exportedName-&gt;impl(), &quot;&#39;&quot;);
3358     maybeExportedLocalNames.append(std::make_pair(localName, exportedName));
3359     return context.createExportSpecifier(specifierLocation, *localName, *exportedName);
3360 }
3361 
3362 template &lt;typename LexerType&gt;
3363 template &lt;class TreeBuilder&gt; TreeStatement Parser&lt;LexerType&gt;::parseExportDeclaration(TreeBuilder&amp; context)
3364 {
3365     // http://www.ecma-international.org/ecma-262/6.0/#sec-exports
3366     ASSERT(match(EXPORT));
3367     JSTokenLocation exportLocation(tokenLocation());
3368     next();
3369 
3370     switch (m_token.m_type) {
3371     case TIMES: {
3372         // export * FromClause ;
3373         next();
3374 
<a name="64" id="anc64"></a><span class="line-modified">3375         failIfFalse(matchContextualKeyword(m_vm-&gt;propertyNames-&gt;from), &quot;Expected &#39;from&#39; before exported module name&quot;);</span>
3376         next();
3377         auto moduleName = parseModuleName(context);
3378         failIfFalse(moduleName, &quot;Cannot parse the &#39;from&#39; clause&quot;);
3379         failIfFalse(autoSemiColon(), &quot;Expected a &#39;;&#39; following a targeted export declaration&quot;);
3380 
3381         return context.createExportAllDeclaration(exportLocation, moduleName);
3382     }
3383 
3384     case DEFAULT: {
3385         // export default HoistableDeclaration[Default]
3386         // export default ClassDeclaration[Default]
3387         // export default [lookahead not-in {function, class}] AssignmentExpression[In] ;
3388 
3389         next();
3390 
3391         TreeStatement result = 0;
3392         bool isFunctionOrClassDeclaration = false;
3393         const Identifier* localName = nullptr;
3394 
3395         bool startsWithFunction = match(FUNCTION);
3396         if (startsWithFunction || match(CLASSTOKEN)) {
3397             SavePoint savePoint = createSavePoint();
3398             isFunctionOrClassDeclaration = true;
3399             next();
3400 
3401             // ES6 Generators
3402             if (startsWithFunction &amp;&amp; match(TIMES))
3403                 next();
3404             if (match(IDENT))
3405                 localName = m_token.m_data.ident;
3406             restoreSavePoint(savePoint);
<a name="65" id="anc65"></a><span class="line-modified">3407         } else if (matchContextualKeyword(m_vm-&gt;propertyNames-&gt;async)) {</span>
3408             SavePoint savePoint = createSavePoint();
3409             next();
3410             if (match(FUNCTION) &amp;&amp; !m_lexer-&gt;hasLineTerminatorBeforeToken()) {
3411                 next();
3412                 if (match(IDENT))
3413                     localName = m_token.m_data.ident;
3414                 isFunctionOrClassDeclaration = true;
3415             }
3416             restoreSavePoint(savePoint);
3417         }
3418 
3419         if (!localName)
<a name="66" id="anc66"></a><span class="line-modified">3420             localName = &amp;m_vm-&gt;propertyNames-&gt;starDefaultPrivateName;</span>
3421 
3422         if (isFunctionOrClassDeclaration) {
3423             if (startsWithFunction) {
3424                 ASSERT(match(FUNCTION));
3425                 DepthManager statementDepth(&amp;m_statementDepth);
3426                 m_statementDepth = 1;
3427                 result = parseFunctionDeclaration(context, ExportType::NotExported, DeclarationDefaultContext::ExportDefault);
3428             } else if (match(CLASSTOKEN)) {
3429                 result = parseClassDeclaration(context, ExportType::NotExported, DeclarationDefaultContext::ExportDefault);
3430             } else {
<a name="67" id="anc67"></a><span class="line-modified">3431                 ASSERT(matchContextualKeyword(m_vm-&gt;propertyNames-&gt;async));</span>
3432                 next();
3433                 DepthManager statementDepth(&amp;m_statementDepth);
3434                 m_statementDepth = 1;
3435                 result = parseAsyncFunctionDeclaration(context, ExportType::NotExported, DeclarationDefaultContext::ExportDefault);
3436             }
3437         } else {
3438             // export default expr;
3439             //
3440             // It should be treated as the same to the following.
3441             //
3442             // const *default* = expr;
3443             // export { *default* as default }
3444             //
3445             // In the above example, *default* is the invisible variable to the users.
3446             // We use the private symbol to represent the name of this variable.
3447             JSTokenLocation location(tokenLocation());
3448             JSTextPosition start = tokenStartPosition();
3449             TreeExpression expression = parseAssignmentExpression(context);
3450             failIfFalse(expression, &quot;Cannot parse expression&quot;);
3451 
<a name="68" id="anc68"></a><span class="line-modified">3452             DeclarationResultMask declarationResult = declareVariable(&amp;m_vm-&gt;propertyNames-&gt;starDefaultPrivateName, DeclarationType::ConstDeclaration);</span>
3453             if (declarationResult &amp; DeclarationResult::InvalidDuplicateDeclaration)
3454                 internalFailWithMessage(false, &quot;Only one &#39;default&#39; export is allowed&quot;);
3455 
<a name="69" id="anc69"></a><span class="line-modified">3456             TreeExpression assignment = context.createAssignResolve(location, m_vm-&gt;propertyNames-&gt;starDefaultPrivateName, expression, start, start, tokenEndPosition(), AssignmentContext::ConstDeclarationStatement);</span>
3457             result = context.createExprStatement(location, assignment, start, tokenEndPosition());
3458             failIfFalse(autoSemiColon(), &quot;Expected a &#39;;&#39; following a targeted export declaration&quot;);
3459         }
3460         failIfFalse(result, &quot;Cannot parse the declaration&quot;);
3461 
<a name="70" id="anc70"></a><span class="line-modified">3462         semanticFailIfFalse(exportName(m_vm-&gt;propertyNames-&gt;defaultKeyword), &quot;Only one &#39;default&#39; export is allowed&quot;);</span>
<span class="line-modified">3463         m_moduleScopeData-&gt;exportBinding(*localName, m_vm-&gt;propertyNames-&gt;defaultKeyword);</span>
3464         return context.createExportDefaultDeclaration(exportLocation, result, *localName);
3465     }
3466 
3467     case OPENBRACE: {
3468         // export ExportClause FromClause ;
3469         // export ExportClause ;
3470         //
3471         // ExportClause :
3472         // { }
3473         // { ExportsList }
3474         // { ExportsList , }
3475         //
3476         // ExportsList :
3477         // ExportSpecifier
3478         // ExportsList , ExportSpecifier
3479 
3480         next();
3481 
3482         auto specifierList = context.createExportSpecifierList();
3483         Vector&lt;std::pair&lt;const Identifier*, const Identifier*&gt;&gt; maybeExportedLocalNames;
3484 
3485         bool hasKeywordForLocalBindings = false;
3486         while (!match(CLOSEBRACE)) {
3487             failIfFalse(matchIdentifierOrKeyword(), &quot;Expected a variable name for the export declaration&quot;);
3488             auto specifier = parseExportSpecifier(context, maybeExportedLocalNames, hasKeywordForLocalBindings);
3489             failIfFalse(specifier, &quot;Cannot parse the named export&quot;);
3490             context.appendExportSpecifier(specifierList, specifier);
3491             if (!consume(COMMA))
3492                 break;
3493         }
3494         handleProductionOrFail2(CLOSEBRACE, &quot;}&quot;, &quot;end&quot;, &quot;export list&quot;);
3495 
3496         typename TreeBuilder::ModuleName moduleName = 0;
<a name="71" id="anc71"></a><span class="line-modified">3497         if (matchContextualKeyword(m_vm-&gt;propertyNames-&gt;from)) {</span>
3498             next();
3499             moduleName = parseModuleName(context);
3500             failIfFalse(moduleName, &quot;Cannot parse the &#39;from&#39; clause&quot;);
3501         }
3502         failIfFalse(autoSemiColon(), &quot;Expected a &#39;;&#39; following a targeted export declaration&quot;);
3503 
3504         if (!moduleName) {
3505             semanticFailIfTrue(hasKeywordForLocalBindings, &quot;Cannot use keyword as exported variable name&quot;);
3506             // Since this export declaration does not have module specifier part, it exports the local bindings.
3507             // While the export declaration with module specifier does not have any effect on the current module&#39;s scope,
3508             // the export named declaration without module specifier references the local binding names.
3509             // For example,
3510             //   export { A, B, C as D } from &quot;mod&quot;
3511             // does not have effect on the current module&#39;s scope. But,
3512             //   export { A, B, C as D }
3513             // will reference the current module&#39;s bindings.
3514             for (const auto&amp; pair : maybeExportedLocalNames) {
3515                 const Identifier* localName = pair.first;
3516                 const Identifier* exportedName = pair.second;
3517                 m_moduleScopeData-&gt;exportBinding(*localName, *exportedName);
3518             }
3519         }
3520 
3521         return context.createExportNamedDeclaration(exportLocation, specifierList, moduleName);
3522     }
3523 
3524     default: {
3525         // export VariableStatement
3526         // export Declaration
3527         TreeStatement result = 0;
3528         switch (m_token.m_type) {
3529         case VAR:
3530             result = parseVariableDeclaration(context, DeclarationType::VarDeclaration, ExportType::Exported);
3531             break;
3532 
3533         case CONSTTOKEN:
3534             result = parseVariableDeclaration(context, DeclarationType::ConstDeclaration, ExportType::Exported);
3535             break;
3536 
3537         case LET:
3538             result = parseVariableDeclaration(context, DeclarationType::LetDeclaration, ExportType::Exported);
3539             break;
3540 
3541         case FUNCTION: {
3542             DepthManager statementDepth(&amp;m_statementDepth);
3543             m_statementDepth = 1;
3544             result = parseFunctionDeclaration(context, ExportType::Exported);
3545             break;
3546         }
3547 
3548         case CLASSTOKEN:
3549             result = parseClassDeclaration(context, ExportType::Exported);
3550             break;
3551 
3552         case IDENT:
<a name="72" id="anc72"></a><span class="line-modified">3553             if (*m_token.m_data.ident == m_vm-&gt;propertyNames-&gt;async &amp;&amp; !m_token.m_data.escaped) {</span>
3554                 next();
3555                 semanticFailIfFalse(match(FUNCTION) &amp;&amp; !m_lexer-&gt;hasLineTerminatorBeforeToken(), &quot;Expected &#39;function&#39; keyword following &#39;async&#39; keyword with no preceding line terminator&quot;);
3556                 DepthManager statementDepth(&amp;m_statementDepth);
3557                 m_statementDepth = 1;
3558                 result = parseAsyncFunctionDeclaration(context, ExportType::Exported);
3559                 break;
3560             }
3561             FALLTHROUGH;
3562         default:
3563             failWithMessage(&quot;Expected either a declaration or a variable statement&quot;);
3564             break;
3565         }
3566 
3567         failIfFalse(result, &quot;Cannot parse the declaration&quot;);
3568         return context.createExportLocalDeclaration(exportLocation, result);
3569     }
3570     }
3571 
3572     RELEASE_ASSERT_NOT_REACHED();
3573     return 0;
3574 }
3575 
3576 template &lt;typename LexerType&gt;
3577 template &lt;class TreeBuilder&gt; TreeExpression Parser&lt;LexerType&gt;::parseExpression(TreeBuilder&amp; context)
3578 {
3579     failIfStackOverflow();
3580     JSTokenLocation location(tokenLocation());
3581     TreeExpression node = parseAssignmentExpression(context);
3582     failIfFalse(node, &quot;Cannot parse expression&quot;);
3583     context.setEndOffset(node, m_lastTokenEndPosition.offset);
3584     if (!match(COMMA))
3585         return node;
3586     next();
3587     m_parserState.nonTrivialExpressionCount++;
3588     m_parserState.nonLHSCount++;
3589     TreeExpression right = parseAssignmentExpression(context);
3590     failIfFalse(right, &quot;Cannot parse expression in a comma expression&quot;);
3591     context.setEndOffset(right, m_lastTokenEndPosition.offset);
3592     typename TreeBuilder::Comma head = context.createCommaExpr(location, node);
3593     typename TreeBuilder::Comma tail = context.appendToCommaExpr(location, head, head, right);
3594     while (match(COMMA)) {
3595         next(TreeBuilder::DontBuildStrings);
3596         right = parseAssignmentExpression(context);
3597         failIfFalse(right, &quot;Cannot parse expression in a comma expression&quot;);
3598         context.setEndOffset(right, m_lastTokenEndPosition.offset);
3599         tail = context.appendToCommaExpr(location, head, tail, right);
3600     }
3601     context.setEndOffset(head, m_lastTokenEndPosition.offset);
3602     return head;
3603 }
3604 
3605 template &lt;typename LexerType&gt;
3606 template &lt;typename TreeBuilder&gt; TreeExpression Parser&lt;LexerType&gt;::parseAssignmentExpressionOrPropagateErrorClass(TreeBuilder&amp; context)
3607 {
3608     ExpressionErrorClassifier classifier(this);
3609     auto assignment = parseAssignmentExpression(context, classifier);
3610     if (!assignment)
3611         classifier.propagateExpressionErrorClass();
3612     return assignment;
3613 }
3614 
3615 template &lt;typename LexerType&gt;
3616 template &lt;typename TreeBuilder&gt; TreeExpression Parser&lt;LexerType&gt;::parseAssignmentExpression(TreeBuilder&amp; context)
3617 {
3618     ExpressionErrorClassifier classifier(this);
3619     return parseAssignmentExpression(context, classifier);
3620 }
3621 
3622 
3623 template &lt;typename LexerType&gt;
3624 template &lt;typename TreeBuilder&gt; NEVER_INLINE const char* Parser&lt;LexerType&gt;::metaPropertyName(TreeBuilder&amp; context, TreeExpression expr)
3625 {
3626     if (context.isNewTarget(expr))
3627         return &quot;new.target&quot;;
3628     if (context.isImportMeta(expr))
3629         return &quot;import.meta&quot;;
3630     RELEASE_ASSERT_NOT_REACHED();
3631     return &quot;error&quot;;
3632 }
3633 
<a name="73" id="anc73"></a>







3634 template &lt;typename LexerType&gt;
3635 template &lt;typename TreeBuilder&gt; TreeExpression Parser&lt;LexerType&gt;::parseAssignmentExpression(TreeBuilder&amp; context, ExpressionErrorClassifier&amp; classifier)
3636 {
3637     ASSERT(!hasError());
3638 
3639     failIfStackOverflow();
3640 
3641     if (match(YIELD) &amp;&amp; !isYIELDMaskedAsIDENT(currentScope()-&gt;isGenerator()))
3642         return parseYieldExpression(context);
3643 
3644     JSTextPosition start = tokenStartPosition();
3645     JSTokenLocation location(tokenLocation());
3646     int initialAssignmentCount = m_parserState.assignmentCount;
3647     int initialNonLHSCount = m_parserState.nonLHSCount;
3648     bool maybeAssignmentPattern = match(OPENBRACE) || match(OPENBRACKET);
3649     bool wasOpenParen = match(OPENPAREN);
3650     // Do not use matchSpecIdentifier() here since it is slower than isIdentifierOrKeyword.
3651     // Whether spec identifier is will be validated by isArrowFunctionParameters().
3652     bool wasIdentifierOrKeyword = isIdentifierOrKeyword(m_token);
3653     bool maybeValidArrowFunctionStart = wasOpenParen || wasIdentifierOrKeyword;
3654     SavePoint savePoint = createSavePoint();
3655     size_t usedVariablesSize = 0;
3656 
3657     if (wasOpenParen) {
3658         usedVariablesSize = currentScope()-&gt;currentUsedVariablesSize();
3659         currentScope()-&gt;pushUsedVariableSet();
3660     }
3661 
3662     TreeExpression lhs = parseConditionalExpression(context);
3663 
3664     if (maybeValidArrowFunctionStart &amp;&amp; !match(EOFTOK)) {
3665         bool isArrowFunctionToken = match(ARROWFUNCTION);
3666         if (!lhs || isArrowFunctionToken) {
3667             SavePointWithError errorRestorationSavePoint = createSavePointForError();
3668             restoreSavePoint(savePoint);
3669             bool isAsyncArrow = false;
3670             if (UNLIKELY(classifier.indicatesPossibleAsyncArrowFunction())) {
<a name="74" id="anc74"></a><span class="line-modified">3671                 if (matchContextualKeyword(m_vm-&gt;propertyNames-&gt;async)) {</span>
3672                     next();
3673                     isAsyncArrow = !m_lexer-&gt;hasLineTerminatorBeforeToken();
3674                 }
3675             }
3676             if (isArrowFunctionParameters()) {
3677                 if (wasOpenParen)
3678                     currentScope()-&gt;revertToPreviousUsedVariables(usedVariablesSize);
3679                 return parseArrowFunctionExpression(context, isAsyncArrow);
3680             }
3681             if (isArrowFunctionToken)
3682                 propagateError();
3683             restoreSavePointWithError(errorRestorationSavePoint);
3684             if (isArrowFunctionToken)
3685                 failDueToUnexpectedToken();
3686         }
3687     }
3688 
3689     if (!lhs &amp;&amp; (!maybeAssignmentPattern || !classifier.indicatesPossiblePattern()))
3690         propagateError();
3691 
3692     if (maybeAssignmentPattern &amp;&amp; (!lhs || (context.isObjectOrArrayLiteral(lhs) &amp;&amp; match(EQUAL)))) {
3693         SavePointWithError expressionErrorLocation = createSavePointForError();
3694         restoreSavePoint(savePoint);
3695         auto pattern = tryParseDestructuringPatternExpression(context, AssignmentContext::AssignmentExpression);
3696         if (classifier.indicatesPossiblePattern() &amp;&amp; (!pattern || !match(EQUAL))) {
3697             restoreSavePointWithError(expressionErrorLocation);
3698             return 0;
3699         }
3700         failIfFalse(pattern, &quot;Cannot parse assignment pattern&quot;);
3701         consumeOrFail(EQUAL, &quot;Expected &#39;=&#39; following assignment pattern&quot;);
3702         auto rhs = parseAssignmentExpression(context);
3703         if (!rhs)
3704             propagateError();
3705         return context.createDestructuringAssignment(location, pattern, rhs);
3706     }
3707 
3708     failIfFalse(lhs, &quot;Cannot parse expression&quot;);
3709     if (initialNonLHSCount != m_parserState.nonLHSCount) {
3710         if (m_token.m_type &gt;= EQUAL &amp;&amp; m_token.m_type &lt;= OREQUAL)
3711             semanticFail(&quot;Left hand side of operator &#39;&quot;, getToken(), &quot;&#39; must be a reference&quot;);
3712 
3713         return lhs;
3714     }
3715 
3716     int assignmentStack = 0;
3717     Operator op;
3718     bool hadAssignment = false;
3719     while (true) {
3720         switch (m_token.m_type) {
3721         case EQUAL: op = OpEqual; break;
3722         case PLUSEQUAL: op = OpPlusEq; break;
3723         case MINUSEQUAL: op = OpMinusEq; break;
3724         case MULTEQUAL: op = OpMultEq; break;
3725         case DIVEQUAL: op = OpDivEq; break;
3726         case LSHIFTEQUAL: op = OpLShift; break;
3727         case RSHIFTEQUAL: op = OpRShift; break;
3728         case URSHIFTEQUAL: op = OpURShift; break;
3729         case ANDEQUAL: op = OpAndEq; break;
3730         case XOREQUAL: op = OpXOrEq; break;
3731         case OREQUAL: op = OpOrEq; break;
3732         case MODEQUAL: op = OpModEq; break;
3733         case POWEQUAL: op = OpPowEq; break;
3734         default:
3735             goto end;
3736         }
3737         m_parserState.nonTrivialExpressionCount++;
3738         hadAssignment = true;
<a name="75" id="anc75"></a><span class="line-modified">3739         if (UNLIKELY(context.isMetaProperty(lhs)))</span>
<span class="line-modified">3740             internalFailWithMessage(false, metaPropertyName(context, lhs), &quot; can&#39;t be the left hand side of an assignment expression&quot;);</span>
3741         context.assignmentStackAppend(assignmentStack, lhs, start, tokenStartPosition(), m_parserState.assignmentCount, op);
3742         start = tokenStartPosition();
3743         m_parserState.assignmentCount++;
3744         next(TreeBuilder::DontBuildStrings);
3745         if (strictMode() &amp;&amp; m_parserState.lastIdentifier &amp;&amp; context.isResolve(lhs)) {
<a name="76" id="anc76"></a><span class="line-modified">3746             failIfTrueIfStrict(m_vm-&gt;propertyNames-&gt;eval == *m_parserState.lastIdentifier, &quot;Cannot modify &#39;eval&#39; in strict mode&quot;);</span>
<span class="line-modified">3747             failIfTrueIfStrict(m_vm-&gt;propertyNames-&gt;arguments == *m_parserState.lastIdentifier, &quot;Cannot modify &#39;arguments&#39; in strict mode&quot;);</span>
3748             m_parserState.lastIdentifier = 0;
3749         }
3750         lhs = parseAssignmentExpression(context);
3751         failIfFalse(lhs, &quot;Cannot parse the right hand side of an assignment expression&quot;);
3752         if (initialNonLHSCount != m_parserState.nonLHSCount) {
3753             if (m_token.m_type &gt;= EQUAL &amp;&amp; m_token.m_type &lt;= OREQUAL)
3754                 semanticFail(&quot;Left hand side of operator &#39;&quot;, getToken(), &quot;&#39; must be a reference&quot;);
3755             break;
3756         }
3757     }
3758 end:
3759     if (hadAssignment)
3760         m_parserState.nonLHSCount++;
3761 
3762     if (!TreeBuilder::CreatesAST)
3763         return lhs;
3764 
3765     while (assignmentStack)
3766         lhs = context.createAssignment(location, assignmentStack, lhs, initialAssignmentCount, m_parserState.assignmentCount, lastTokenEndPosition());
3767 
3768     return lhs;
3769 }
3770 
3771 template &lt;typename LexerType&gt;
3772 template &lt;class TreeBuilder&gt; TreeExpression Parser&lt;LexerType&gt;::parseYieldExpression(TreeBuilder&amp; context)
3773 {
3774     // YieldExpression[In] :
3775     //     yield
3776     //     yield [no LineTerminator here] AssignmentExpression[?In, Yield]
3777     //     yield [no LineTerminator here] * AssignmentExpression[?In, Yield]
3778 
3779     // http://ecma-international.org/ecma-262/6.0/#sec-generator-function-definitions
3780     failIfFalse(currentScope()-&gt;isGenerator() &amp;&amp; !currentScope()-&gt;isArrowFunctionBoundary(), &quot;Cannot use yield expression out of generator&quot;);
3781 
3782     // http://ecma-international.org/ecma-262/6.0/#sec-generator-function-definitions-static-semantics-early-errors
3783     failIfTrue(m_parserState.functionParsePhase == FunctionParsePhase::Parameters, &quot;Cannot use yield expression within parameters&quot;);
3784 
3785     JSTokenLocation location(tokenLocation());
3786     JSTextPosition divotStart = tokenStartPosition();
3787     ASSERT(match(YIELD));
3788     SavePoint savePoint = createSavePoint();
3789     next();
3790     if (m_lexer-&gt;hasLineTerminatorBeforeToken())
3791         return context.createYield(location);
3792 
3793     bool delegate = consume(TIMES);
3794     JSTextPosition argumentStart = tokenStartPosition();
3795     TreeExpression argument = parseAssignmentExpression(context);
3796     if (!argument) {
3797         restoreSavePoint(savePoint);
3798         next();
3799         return context.createYield(location);
3800     }
3801     return context.createYield(location, argument, delegate, divotStart, argumentStart, lastTokenEndPosition());
3802 }
3803 
3804 template &lt;typename LexerType&gt;
3805 template &lt;class TreeBuilder&gt; TreeExpression Parser&lt;LexerType&gt;::parseAwaitExpression(TreeBuilder&amp; context)
3806 {
3807     ASSERT(match(AWAIT));
3808     ASSERT(currentScope()-&gt;isAsyncFunction());
3809     failIfTrue(m_parserState.functionParsePhase == FunctionParsePhase::Parameters, &quot;Cannot use await expression within parameters&quot;);
3810     JSTokenLocation location(tokenLocation());
3811     JSTextPosition divotStart = tokenStartPosition();
3812     next();
3813     JSTextPosition argumentStart = tokenStartPosition();
3814     ExpressionErrorClassifier classifier(this);
3815     TreeExpression argument = parseUnaryExpression(context);
3816     failIfFalse(argument, &quot;Failed to parse await expression&quot;);
3817     return context.createAwait(location, argument, divotStart, argumentStart, lastTokenEndPosition());
3818 }
3819 
3820 template &lt;typename LexerType&gt;
3821 template &lt;class TreeBuilder&gt; TreeExpression Parser&lt;LexerType&gt;::parseConditionalExpression(TreeBuilder&amp; context)
3822 {
3823     JSTokenLocation location(tokenLocation());
3824     TreeExpression cond = parseBinaryExpression(context);
3825     failIfFalse(cond, &quot;Cannot parse expression&quot;);
3826     if (!match(QUESTION))
3827         return cond;
3828     m_parserState.nonTrivialExpressionCount++;
3829     m_parserState.nonLHSCount++;
3830     next(TreeBuilder::DontBuildStrings);
3831     TreeExpression lhs = parseAssignmentExpression(context);
3832     failIfFalse(lhs, &quot;Cannot parse left hand side of ternary operator&quot;);
3833     context.setEndOffset(lhs, m_lastTokenEndPosition.offset);
3834     consumeOrFailWithFlags(COLON, TreeBuilder::DontBuildStrings, &quot;Expected &#39;:&#39; in ternary operator&quot;);
3835 
3836     TreeExpression rhs = parseAssignmentExpression(context);
3837     failIfFalse(rhs, &quot;Cannot parse right hand side of ternary operator&quot;);
3838     context.setEndOffset(rhs, m_lastTokenEndPosition.offset);
3839     return context.createConditionalExpr(location, cond, lhs, rhs);
3840 }
3841 
3842 ALWAYS_INLINE static bool isUnaryOpExcludingUpdateOp(JSTokenType token)
3843 {
3844     if (isUpdateOp(token))
3845         return false;
3846     return isUnaryOp(token);
3847 }
3848 
3849 template &lt;typename LexerType&gt;
3850 int Parser&lt;LexerType&gt;::isBinaryOperator(JSTokenType token)
3851 {
3852     if (m_allowsIn)
3853         return token &amp; (BinaryOpTokenPrecedenceMask &lt;&lt; BinaryOpTokenAllowsInPrecedenceAdditionalShift);
3854     return token &amp; BinaryOpTokenPrecedenceMask;
3855 }
3856 
3857 template &lt;typename LexerType&gt;
3858 template &lt;class TreeBuilder&gt; TreeExpression Parser&lt;LexerType&gt;::parseBinaryExpression(TreeBuilder&amp; context)
3859 {
3860     int operandStackDepth = 0;
3861     int operatorStackDepth = 0;
3862     typename TreeBuilder::BinaryExprContext binaryExprContext(context);
3863     JSTokenLocation location(tokenLocation());
<a name="77" id="anc77"></a>


3864     while (true) {
3865         JSTextPosition exprStart = tokenStartPosition();
3866         int initialAssignments = m_parserState.assignmentCount;
3867         JSTokenType leadingTokenTypeForUnaryExpression = m_token.m_type;
3868         TreeExpression current = parseUnaryExpression(context);
3869         failIfFalse(current, &quot;Cannot parse expression&quot;);
3870 
3871         context.appendBinaryExpressionInfo(operandStackDepth, current, exprStart, lastTokenEndPosition(), lastTokenEndPosition(), initialAssignments != m_parserState.assignmentCount);
<a name="78" id="anc78"></a>


3872 
3873         // 12.6 https://tc39.github.io/ecma262/#sec-exp-operator
3874         // ExponentiationExpresion is described as follows.
3875         //
3876         //     ExponentiationExpression[Yield]:
3877         //         UnaryExpression[?Yield]
3878         //         UpdateExpression[?Yield] ** ExponentiationExpression[?Yield]
3879         //
3880         // As we can see, the left hand side of the ExponentiationExpression is UpdateExpression, not UnaryExpression.
3881         // So placing UnaryExpression not included in UpdateExpression here is a syntax error.
3882         // This is intentional. For example, if UnaryExpression is allowed, we can have the code like `-x**y`.
3883         // But this is confusing: `-(x**y)` OR `(-x)**y`, which interpretation is correct?
3884         // To avoid this problem, ECMA262 makes unparenthesized exponentiation expression as operand of unary operators an early error.
3885         // More rationale: https://mail.mozilla.org/pipermail/es-discuss/2015-September/044232.html
3886         //
3887         // Here, we guarantee that the left hand side of this expression is not unary expression by checking the leading operator of the parseUnaryExpression.
3888         // This check just works. Let&#39;s consider the example,
3889         //     y &lt;&gt; -x ** z
3890         //          ^
3891         //          Check this.
3892         // If the binary operator &lt;&gt; has higher precedence than one of &quot;**&quot;, this check does not work.
3893         // But it&#39;s OK for ** because the operator &quot;**&quot; has the highest operator precedence in the binary operators.
3894         failIfTrue(match(POW) &amp;&amp; isUnaryOpExcludingUpdateOp(leadingTokenTypeForUnaryExpression), &quot;Ambiguous unary expression in the left hand side of the exponentiation expression; parentheses must be used to disambiguate the expression&quot;);
3895 
<a name="79" id="anc79"></a><span class="line-modified">3896         int precedence = isBinaryOperator(m_token.m_type);</span>
<span class="line-modified">3897         if (!precedence)</span>
<span class="line-modified">3898             break;</span>





3899         m_parserState.nonTrivialExpressionCount++;
3900         m_parserState.nonLHSCount++;
3901         int operatorToken = m_token.m_type;
3902         next(TreeBuilder::DontBuildStrings);
3903 
3904         while (operatorStackDepth &amp;&amp; context.operatorStackShouldReduce(precedence)) {
3905             ASSERT(operandStackDepth &gt; 1);
3906 
3907             typename TreeBuilder::BinaryOperand rhs = context.getFromOperandStack(-1);
3908             typename TreeBuilder::BinaryOperand lhs = context.getFromOperandStack(-2);
3909             context.shrinkOperandStackBy(operandStackDepth, 2);
3910             context.appendBinaryOperation(location, operandStackDepth, operatorStackDepth, lhs, rhs);
3911             context.operatorStackPop(operatorStackDepth);
3912         }
3913         context.operatorStackAppend(operatorStackDepth, operatorToken, precedence);
3914     }
3915     while (operatorStackDepth) {
3916         ASSERT(operandStackDepth &gt; 1);
3917 
3918         typename TreeBuilder::BinaryOperand rhs = context.getFromOperandStack(-1);
3919         typename TreeBuilder::BinaryOperand lhs = context.getFromOperandStack(-2);
3920         context.shrinkOperandStackBy(operandStackDepth, 2);
3921         context.appendBinaryOperation(location, operandStackDepth, operatorStackDepth, lhs, rhs);
3922         context.operatorStackPop(operatorStackDepth);
3923     }
3924     return context.popOperandStack(operandStackDepth);
3925 }
3926 
3927 template &lt;typename LexerType&gt;
3928 template &lt;class TreeBuilder&gt; TreeProperty Parser&lt;LexerType&gt;::parseProperty(TreeBuilder&amp; context, bool complete)
3929 {
3930     SourceParseMode parseMode = SourceParseMode::MethodMode;
3931     bool wasIdent = false;
3932 
3933     if (consume(TIMES))
3934         parseMode = SourceParseMode::GeneratorWrapperMethodMode;
3935 
3936 parseProperty:
3937     switch (m_token.m_type) {
3938     case IDENT:
<a name="80" id="anc80"></a><span class="line-modified">3939         if (UNLIKELY(*m_token.m_data.ident == m_vm-&gt;propertyNames-&gt;async &amp;&amp; !m_token.m_data.escaped)) {</span>
3940             if (parseMode == SourceParseMode::MethodMode) {
3941                 SavePoint savePoint = createSavePoint();
3942                 next();
3943 
3944                 if (match(COLON) || match(OPENPAREN) || match(COMMA) || match(CLOSEBRACE)) {
3945                     restoreSavePoint(savePoint);
3946                     wasIdent = true;
3947                     goto namedProperty;
3948                 }
3949 
3950                 failIfTrue(m_lexer-&gt;hasLineTerminatorBeforeToken(), &quot;Expected a property name following keyword &#39;async&#39;&quot;);
3951                 if (UNLIKELY(consume(TIMES)))
3952                     parseMode = SourceParseMode::AsyncGeneratorWrapperMethodMode;
3953                 else
3954                     parseMode = SourceParseMode::AsyncMethodMode;
3955                 goto parseProperty;
3956             }
3957         }
3958         FALLTHROUGH;
3959     case YIELD:
3960     case AWAIT:
3961         wasIdent = true;
3962         FALLTHROUGH;
3963     case STRING: {
3964 namedProperty:
3965         const Identifier* ident = m_token.m_data.ident;
3966         unsigned getterOrSetterStartOffset = tokenStart();
3967         JSToken identToken = m_token;
3968 
<a name="81" id="anc81"></a><span class="line-modified">3969         if (complete || (wasIdent &amp;&amp; !isGeneratorMethodParseMode(parseMode)  &amp;&amp; (*ident == m_vm-&gt;propertyNames-&gt;get || *ident == m_vm-&gt;propertyNames-&gt;set)))</span>
3970             nextExpectIdentifier(LexerFlagsIgnoreReservedWords);
3971         else
3972             nextExpectIdentifier(LexerFlagsIgnoreReservedWords | TreeBuilder::DontBuildKeywords);
3973 
3974         if (!isGeneratorMethodParseMode(parseMode) &amp;&amp; !isAsyncMethodParseMode(parseMode) &amp;&amp; match(COLON)) {
3975             next();
3976             TreeExpression node = parseAssignmentExpressionOrPropagateErrorClass(context);
3977             failIfFalse(node, &quot;Cannot parse expression for property declaration&quot;);
3978             context.setEndOffset(node, m_lexer-&gt;currentOffset());
<a name="82" id="anc82"></a><span class="line-modified">3979             InferName inferName = ident &amp;&amp; *ident == m_vm-&gt;propertyNames-&gt;underscoreProto ? InferName::Disallowed : InferName::Allowed;</span>
3980             return context.createProperty(ident, node, PropertyNode::Constant, PropertyNode::Unknown, complete, SuperBinding::NotNeeded, inferName, ClassElementTag::No);
3981         }
3982 
3983         if (match(OPENPAREN)) {
3984             auto method = parsePropertyMethod(context, ident, parseMode);
3985             propagateError();
3986             return context.createProperty(ident, method, PropertyNode::Constant, PropertyNode::KnownDirect, complete, SuperBinding::Needed, InferName::Allowed, ClassElementTag::No);
3987         }
3988         failIfTrue(parseMode != SourceParseMode::MethodMode, &quot;Expected a parenthesis for argument list&quot;);
3989 
3990         failIfFalse(wasIdent, &quot;Expected an identifier as property name&quot;);
3991 
3992         if (match(COMMA) || match(CLOSEBRACE)) {
3993             semanticFailureDueToKeywordCheckingToken(identToken, &quot;shorthand property name&quot;);
3994             JSTextPosition start = tokenStartPosition();
3995             JSTokenLocation location(tokenLocation());
<a name="83" id="anc83"></a><span class="line-modified">3996             currentScope()-&gt;useVariable(ident, m_vm-&gt;propertyNames-&gt;eval == *ident);</span>
3997             if (currentScope()-&gt;isArrowFunction())
3998                 currentScope()-&gt;setInnerArrowFunctionUsesEval();
3999             TreeExpression node = context.createResolve(location, *ident, start, lastTokenEndPosition());
4000             return context.createProperty(ident, node, static_cast&lt;PropertyNode::Type&gt;(PropertyNode::Constant | PropertyNode::Shorthand), PropertyNode::KnownDirect, complete, SuperBinding::NotNeeded, InferName::Allowed, ClassElementTag::No);
4001         }
4002 
4003         if (match(EQUAL)) // CoverInitializedName is exclusive to BindingPattern and AssignmentPattern
4004             classifyExpressionError(ErrorIndicatesPattern);
4005 
4006         PropertyNode::Type type;
<a name="84" id="anc84"></a><span class="line-modified">4007         if (*ident == m_vm-&gt;propertyNames-&gt;get)</span>
4008             type = PropertyNode::Getter;
<a name="85" id="anc85"></a><span class="line-modified">4009         else if (*ident == m_vm-&gt;propertyNames-&gt;set)</span>
4010             type = PropertyNode::Setter;
4011         else
4012             failWithMessage(&quot;Expected a &#39;:&#39; following the property name &#39;&quot;, ident-&gt;impl(), &quot;&#39;&quot;);
4013         return parseGetterSetter(context, complete, type, getterOrSetterStartOffset, ConstructorKind::None, ClassElementTag::No);
4014     }
4015     case DOUBLE:
4016     case INTEGER: {
4017         double propertyName = m_token.m_data.doubleValue;
4018         next();
4019 
4020         if (match(OPENPAREN)) {
<a name="86" id="anc86"></a><span class="line-modified">4021             const Identifier&amp; ident = m_parserArena.identifierArena().makeNumericIdentifier(const_cast&lt;VM*&gt;(m_vm), propertyName);</span>
4022             auto method = parsePropertyMethod(context, &amp;ident, parseMode);
4023             propagateError();
4024             return context.createProperty(&amp;ident, method, PropertyNode::Constant, PropertyNode::Unknown, complete, SuperBinding::Needed, InferName::Allowed, ClassElementTag::No);
4025         }
4026         failIfTrue(parseMode != SourceParseMode::MethodMode, &quot;Expected a parenthesis for argument list&quot;);
4027 
4028         consumeOrFail(COLON, &quot;Expected &#39;:&#39; after property name&quot;);
4029         TreeExpression node = parseAssignmentExpression(context);
4030         failIfFalse(node, &quot;Cannot parse expression for property declaration&quot;);
4031         context.setEndOffset(node, m_lexer-&gt;currentOffset());
<a name="87" id="anc87"></a><span class="line-modified">4032         return context.createProperty(const_cast&lt;VM*&gt;(m_vm), m_parserArena, propertyName, node, PropertyNode::Constant, PropertyNode::Unknown, complete, SuperBinding::NotNeeded, ClassElementTag::No);</span>
4033     }
4034     case OPENBRACKET: {
4035         next();
4036         auto propertyName = parseAssignmentExpression(context);
4037         failIfFalse(propertyName, &quot;Cannot parse computed property name&quot;);
4038         handleProductionOrFail(CLOSEBRACKET, &quot;]&quot;, &quot;end&quot;, &quot;computed property name&quot;);
4039 
4040         if (match(OPENPAREN)) {
<a name="88" id="anc88"></a><span class="line-modified">4041             auto method = parsePropertyMethod(context, &amp;m_vm-&gt;propertyNames-&gt;nullIdentifier, parseMode);</span>
4042             propagateError();
4043             return context.createProperty(propertyName, method, static_cast&lt;PropertyNode::Type&gt;(PropertyNode::Constant | PropertyNode::Computed), PropertyNode::KnownDirect, complete, SuperBinding::Needed, ClassElementTag::No);
4044         }
4045         failIfTrue(parseMode != SourceParseMode::MethodMode, &quot;Expected a parenthesis for argument list&quot;);
4046 
4047         consumeOrFail(COLON, &quot;Expected &#39;:&#39; after property name&quot;);
4048         TreeExpression node = parseAssignmentExpression(context);
4049         failIfFalse(node, &quot;Cannot parse expression for property declaration&quot;);
4050         context.setEndOffset(node, m_lexer-&gt;currentOffset());
4051         return context.createProperty(propertyName, node, static_cast&lt;PropertyNode::Type&gt;(PropertyNode::Constant | PropertyNode::Computed), PropertyNode::Unknown, complete, SuperBinding::NotNeeded, ClassElementTag::No);
4052     }
4053     case DOTDOTDOT: {
4054         auto spreadLocation = m_token.m_location;
4055         auto start = m_token.m_startPosition;
4056         auto divot = m_token.m_endPosition;
4057         next();
4058         TreeExpression elem = parseAssignmentExpressionOrPropagateErrorClass(context);
4059         failIfFalse(elem, &quot;Cannot parse subject of a spread operation&quot;);
4060         auto node = context.createObjectSpreadExpression(spreadLocation, elem, start, divot, m_lastTokenEndPosition);
4061         return context.createProperty(node, PropertyNode::Spread, PropertyNode::Unknown, complete, SuperBinding::NotNeeded, ClassElementTag::No);
4062     }
4063     default:
4064         failIfFalse(m_token.m_type &amp; KeywordTokenFlag, &quot;Expected a property name&quot;);
4065         wasIdent = true; // Treat keyword token as an identifier
4066         goto namedProperty;
4067     }
4068 }
4069 
4070 template &lt;typename LexerType&gt;
4071 template &lt;class TreeBuilder&gt; TreeExpression Parser&lt;LexerType&gt;::parsePropertyMethod(TreeBuilder&amp; context, const Identifier* methodName, SourceParseMode parseMode)
4072 {
4073     ASSERT(isMethodParseMode(parseMode));
4074     JSTokenLocation methodLocation(tokenLocation());
4075     unsigned methodStart = tokenStart();
4076     ParserFunctionInfo&lt;TreeBuilder&gt; methodInfo;
4077     methodInfo.name = methodName;
4078     failIfFalse((parseFunctionInfo(context, FunctionNameRequirements::Unnamed, parseMode, false, ConstructorKind::None, SuperBinding::Needed, methodStart, methodInfo, FunctionDefinitionType::Method)), &quot;Cannot parse this method&quot;);
4079     return context.createMethodDefinition(methodLocation, methodInfo);
4080 }
4081 
4082 template &lt;typename LexerType&gt;
4083 template &lt;class TreeBuilder&gt; TreeProperty Parser&lt;LexerType&gt;::parseGetterSetter(TreeBuilder&amp; context, bool strict, PropertyNode::Type type, unsigned getterOrSetterStartOffset,
4084     ConstructorKind constructorKind, ClassElementTag tag)
4085 {
4086     const Identifier* stringPropertyName = 0;
4087     double numericPropertyName = 0;
4088     TreeExpression computedPropertyName = 0;
4089 
4090     JSTokenLocation location(tokenLocation());
4091 
4092     if (matchSpecIdentifier() || match(STRING) || m_token.m_type &amp; KeywordTokenFlag) {
4093         stringPropertyName = m_token.m_data.ident;
<a name="89" id="anc89"></a><span class="line-modified">4094         semanticFailIfTrue(tag == ClassElementTag::Static &amp;&amp; *stringPropertyName == m_vm-&gt;propertyNames-&gt;prototype,</span>
4095             &quot;Cannot declare a static method named &#39;prototype&#39;&quot;);
<a name="90" id="anc90"></a><span class="line-modified">4096         semanticFailIfTrue(tag == ClassElementTag::Instance &amp;&amp; *stringPropertyName == m_vm-&gt;propertyNames-&gt;constructor,</span>
4097             &quot;Cannot declare a getter or setter named &#39;constructor&#39;&quot;);
4098         next();
4099     } else if (match(DOUBLE) || match(INTEGER)) {
4100         numericPropertyName = m_token.m_data.doubleValue;
4101         next();
4102     } else if (match(OPENBRACKET)) {
4103         next();
4104         computedPropertyName = parseAssignmentExpression(context);
4105         failIfFalse(computedPropertyName, &quot;Cannot parse computed property name&quot;);
4106         handleProductionOrFail(CLOSEBRACKET, &quot;]&quot;, &quot;end&quot;, &quot;computed property name&quot;);
4107     } else
4108         failDueToUnexpectedToken();
4109 
4110     ParserFunctionInfo&lt;TreeBuilder&gt; info;
4111     if (type &amp; PropertyNode::Getter) {
4112         failIfFalse(match(OPENPAREN), &quot;Expected a parameter list for getter definition&quot;);
4113         failIfFalse((parseFunctionInfo(context, FunctionNameRequirements::Unnamed, SourceParseMode::GetterMode, false, constructorKind, SuperBinding::Needed, getterOrSetterStartOffset, info, FunctionDefinitionType::Method)), &quot;Cannot parse getter definition&quot;);
4114     } else {
4115         failIfFalse(match(OPENPAREN), &quot;Expected a parameter list for setter definition&quot;);
4116         failIfFalse((parseFunctionInfo(context, FunctionNameRequirements::Unnamed, SourceParseMode::SetterMode, false, constructorKind, SuperBinding::Needed, getterOrSetterStartOffset, info, FunctionDefinitionType::Method)), &quot;Cannot parse setter definition&quot;);
4117     }
4118 
4119     if (stringPropertyName)
4120         return context.createGetterOrSetterProperty(location, type, strict, stringPropertyName, info, tag);
4121 
4122     if (computedPropertyName)
4123         return context.createGetterOrSetterProperty(location, static_cast&lt;PropertyNode::Type&gt;(type | PropertyNode::Computed), strict, computedPropertyName, info, tag);
4124 
<a name="91" id="anc91"></a><span class="line-modified">4125     return context.createGetterOrSetterProperty(const_cast&lt;VM*&gt;(m_vm), m_parserArena, location, type, strict, numericPropertyName, info, tag);</span>
4126 }
4127 
4128 template &lt;typename LexerType&gt;
4129 template &lt;class TreeBuilder&gt; bool Parser&lt;LexerType&gt;::shouldCheckPropertyForUnderscoreProtoDuplicate(TreeBuilder&amp; context, const TreeProperty&amp; property)
4130 {
4131     if (!context.getName(property))
4132         return false;
4133 
4134     // A Constant property that is not a Computed or Shorthand Constant property.
4135     return context.getType(property) == PropertyNode::Constant;
4136 }
4137 
4138 template &lt;typename LexerType&gt;
4139 void Parser&lt;LexerType&gt;::recordPauseLocation(const JSTextPosition&amp; position)
4140 {
4141     if (LIKELY(!m_debuggerParseData))
4142         return;
4143 
4144     if (position.line &lt; 0)
4145         return;
4146 
4147     m_debuggerParseData-&gt;pausePositions.appendPause(position);
4148 }
4149 
4150 template &lt;typename LexerType&gt;
4151 void Parser&lt;LexerType&gt;::recordFunctionEntryLocation(const JSTextPosition&amp; position)
4152 {
4153     if (LIKELY(!m_debuggerParseData))
4154         return;
4155 
4156     m_debuggerParseData-&gt;pausePositions.appendEntry(position);
4157 }
4158 
4159 template &lt;typename LexerType&gt;
4160 void Parser&lt;LexerType&gt;::recordFunctionLeaveLocation(const JSTextPosition&amp; position)
4161 {
4162     if (LIKELY(!m_debuggerParseData))
4163         return;
4164 
4165     m_debuggerParseData-&gt;pausePositions.appendLeave(position);
4166 }
4167 
4168 template &lt;typename LexerType&gt;
4169 template &lt;class TreeBuilder&gt; TreeExpression Parser&lt;LexerType&gt;::parseObjectLiteral(TreeBuilder&amp; context)
4170 {
4171     SavePoint savePoint = createSavePoint();
4172     consumeOrFailWithFlags(OPENBRACE, TreeBuilder::DontBuildStrings, &quot;Expected opening &#39;{&#39; at the start of an object literal&quot;);
4173 
4174     int oldNonLHSCount = m_parserState.nonLHSCount;
4175 
4176     JSTokenLocation location(tokenLocation());
4177     if (match(CLOSEBRACE)) {
4178         next();
4179         return context.createObjectLiteral(location);
4180     }
4181 
4182     TreeProperty property = parseProperty(context, false);
4183     failIfFalse(property, &quot;Cannot parse object literal property&quot;);
4184 
4185     if (context.getType(property) &amp; (PropertyNode::Getter | PropertyNode::Setter)) {
4186         restoreSavePoint(savePoint);
4187         return parseStrictObjectLiteral(context);
4188     }
4189 
4190     bool seenUnderscoreProto = false;
4191     if (shouldCheckPropertyForUnderscoreProtoDuplicate(context, property))
<a name="92" id="anc92"></a><span class="line-modified">4192         seenUnderscoreProto = *context.getName(property) == m_vm-&gt;propertyNames-&gt;underscoreProto;</span>
4193 
4194     TreePropertyList propertyList = context.createPropertyList(location, property);
4195     TreePropertyList tail = propertyList;
4196     while (match(COMMA)) {
4197         next(TreeBuilder::DontBuildStrings);
4198         if (match(CLOSEBRACE))
4199             break;
4200         JSTokenLocation propertyLocation(tokenLocation());
4201         property = parseProperty(context, false);
4202         failIfFalse(property, &quot;Cannot parse object literal property&quot;);
4203         if (context.getType(property) &amp; (PropertyNode::Getter | PropertyNode::Setter)) {
4204             restoreSavePoint(savePoint);
4205             return parseStrictObjectLiteral(context);
4206         }
4207         if (shouldCheckPropertyForUnderscoreProtoDuplicate(context, property)) {
<a name="93" id="anc93"></a><span class="line-modified">4208             if (*context.getName(property) == m_vm-&gt;propertyNames-&gt;underscoreProto) {</span>
4209                 semanticFailIfTrue(seenUnderscoreProto, &quot;Attempted to redefine __proto__ property&quot;);
4210                 seenUnderscoreProto = true;
4211             }
4212         }
4213         tail = context.createPropertyList(propertyLocation, property, tail);
4214     }
4215 
4216     location = tokenLocation();
4217     handleProductionOrFail2(CLOSEBRACE, &quot;}&quot;, &quot;end&quot;, &quot;object literal&quot;);
4218 
4219     m_parserState.nonLHSCount = oldNonLHSCount;
4220 
4221     return context.createObjectLiteral(location, propertyList);
4222 }
4223 
4224 template &lt;typename LexerType&gt;
4225 template &lt;class TreeBuilder&gt; TreeExpression Parser&lt;LexerType&gt;::parseStrictObjectLiteral(TreeBuilder&amp; context)
4226 {
4227     consumeOrFail(OPENBRACE, &quot;Expected opening &#39;{&#39; at the start of an object literal&quot;);
4228 
4229     int oldNonLHSCount = m_parserState.nonLHSCount;
4230 
4231     JSTokenLocation location(tokenLocation());
4232     if (match(CLOSEBRACE)) {
4233         next();
4234         return context.createObjectLiteral(location);
4235     }
4236 
4237     TreeProperty property = parseProperty(context, true);
4238     failIfFalse(property, &quot;Cannot parse object literal property&quot;);
4239 
4240     bool seenUnderscoreProto = false;
4241     if (shouldCheckPropertyForUnderscoreProtoDuplicate(context, property))
<a name="94" id="anc94"></a><span class="line-modified">4242         seenUnderscoreProto = *context.getName(property) == m_vm-&gt;propertyNames-&gt;underscoreProto;</span>
4243 
4244     TreePropertyList propertyList = context.createPropertyList(location, property);
4245     TreePropertyList tail = propertyList;
4246     while (match(COMMA)) {
4247         next();
4248         if (match(CLOSEBRACE))
4249             break;
4250         JSTokenLocation propertyLocation(tokenLocation());
4251         property = parseProperty(context, true);
4252         failIfFalse(property, &quot;Cannot parse object literal property&quot;);
4253         if (shouldCheckPropertyForUnderscoreProtoDuplicate(context, property)) {
<a name="95" id="anc95"></a><span class="line-modified">4254             if (*context.getName(property) == m_vm-&gt;propertyNames-&gt;underscoreProto) {</span>
4255                 semanticFailIfTrue(seenUnderscoreProto, &quot;Attempted to redefine __proto__ property&quot;);
4256                 seenUnderscoreProto = true;
4257             }
4258         }
4259         tail = context.createPropertyList(propertyLocation, property, tail);
4260     }
4261 
4262     location = tokenLocation();
4263     handleProductionOrFail2(CLOSEBRACE, &quot;}&quot;, &quot;end&quot;, &quot;object literal&quot;);
4264 
4265     m_parserState.nonLHSCount = oldNonLHSCount;
4266 
4267     return context.createObjectLiteral(location, propertyList);
4268 }
4269 
4270 template &lt;typename LexerType&gt;
4271 template &lt;class TreeBuilder&gt; TreeExpression Parser&lt;LexerType&gt;::parseArrayLiteral(TreeBuilder&amp; context)
4272 {
4273     consumeOrFailWithFlags(OPENBRACKET, TreeBuilder::DontBuildStrings, &quot;Expected an opening &#39;[&#39; at the beginning of an array literal&quot;);
4274 
4275     int oldNonLHSCount = m_parserState.nonLHSCount;
4276 
4277     int elisions = 0;
4278     while (match(COMMA)) {
4279         next(TreeBuilder::DontBuildStrings);
4280         elisions++;
4281     }
4282     if (match(CLOSEBRACKET)) {
4283         JSTokenLocation location(tokenLocation());
4284         next(TreeBuilder::DontBuildStrings);
4285         return context.createArray(location, elisions);
4286     }
4287 
4288     TreeExpression elem;
4289     if (UNLIKELY(match(DOTDOTDOT))) {
4290         auto spreadLocation = m_token.m_location;
4291         auto start = m_token.m_startPosition;
4292         auto divot = m_token.m_endPosition;
4293         next();
4294         auto spreadExpr = parseAssignmentExpressionOrPropagateErrorClass(context);
4295         failIfFalse(spreadExpr, &quot;Cannot parse subject of a spread operation&quot;);
4296         elem = context.createSpreadExpression(spreadLocation, spreadExpr, start, divot, m_lastTokenEndPosition);
4297     } else
4298         elem = parseAssignmentExpressionOrPropagateErrorClass(context);
4299     failIfFalse(elem, &quot;Cannot parse array literal element&quot;);
4300     typename TreeBuilder::ElementList elementList = context.createElementList(elisions, elem);
4301     typename TreeBuilder::ElementList tail = elementList;
4302     elisions = 0;
4303     while (match(COMMA)) {
4304         next(TreeBuilder::DontBuildStrings);
4305         elisions = 0;
4306 
4307         while (match(COMMA)) {
4308             next();
4309             elisions++;
4310         }
4311 
4312         if (match(CLOSEBRACKET)) {
4313             JSTokenLocation location(tokenLocation());
4314             next(TreeBuilder::DontBuildStrings);
4315             return context.createArray(location, elisions, elementList);
4316         }
4317         if (UNLIKELY(match(DOTDOTDOT))) {
4318             auto spreadLocation = m_token.m_location;
4319             auto start = m_token.m_startPosition;
4320             auto divot = m_token.m_endPosition;
4321             next();
4322             TreeExpression elem = parseAssignmentExpressionOrPropagateErrorClass(context);
4323             failIfFalse(elem, &quot;Cannot parse subject of a spread operation&quot;);
4324             auto spread = context.createSpreadExpression(spreadLocation, elem, start, divot, m_lastTokenEndPosition);
4325             tail = context.createElementList(tail, elisions, spread);
4326             continue;
4327         }
4328         TreeExpression elem = parseAssignmentExpressionOrPropagateErrorClass(context);
4329         failIfFalse(elem, &quot;Cannot parse array literal element&quot;);
4330         tail = context.createElementList(tail, elisions, elem);
4331     }
4332 
4333     JSTokenLocation location(tokenLocation());
4334     if (!consume(CLOSEBRACKET)) {
4335         failIfFalse(match(DOTDOTDOT), &quot;Expected either a closing &#39;]&#39; or a &#39;,&#39; following an array element&quot;);
4336         semanticFail(&quot;The &#39;...&#39; operator should come before a target expression&quot;);
4337     }
4338 
4339     m_parserState.nonLHSCount = oldNonLHSCount;
4340 
4341     return context.createArray(location, elementList);
4342 }
4343 
4344 template &lt;typename LexerType&gt;
4345 template &lt;class TreeBuilder&gt; TreeClassExpression Parser&lt;LexerType&gt;::parseClassExpression(TreeBuilder&amp; context)
4346 {
4347     ASSERT(match(CLASSTOKEN));
4348     ParserClassInfo&lt;TreeBuilder&gt; info;
<a name="96" id="anc96"></a><span class="line-modified">4349     info.className = &amp;m_vm-&gt;propertyNames-&gt;nullIdentifier;</span>
4350     return parseClass(context, FunctionNameRequirements::None, info);
4351 }
4352 
4353 template &lt;typename LexerType&gt;
4354 template &lt;class TreeBuilder&gt; TreeExpression Parser&lt;LexerType&gt;::parseFunctionExpression(TreeBuilder&amp; context)
4355 {
4356     ASSERT(match(FUNCTION));
4357     JSTokenLocation location(tokenLocation());
4358     unsigned functionKeywordStart = tokenStart();
4359     next();
4360     ParserFunctionInfo&lt;TreeBuilder&gt; functionInfo;
<a name="97" id="anc97"></a><span class="line-modified">4361     functionInfo.name = &amp;m_vm-&gt;propertyNames-&gt;nullIdentifier;</span>
4362     SourceParseMode parseMode = SourceParseMode::NormalFunctionMode;
4363     if (consume(TIMES))
4364         parseMode = SourceParseMode::GeneratorWrapperFunctionMode;
4365     failIfFalse((parseFunctionInfo(context, FunctionNameRequirements::None, parseMode, false, ConstructorKind::None, SuperBinding::NotNeeded, functionKeywordStart, functionInfo, FunctionDefinitionType::Expression)), &quot;Cannot parse function expression&quot;);
4366     return context.createFunctionExpr(location, functionInfo);
4367 }
4368 
4369 template &lt;typename LexerType&gt;
4370 template &lt;class TreeBuilder&gt; TreeExpression Parser&lt;LexerType&gt;::parseAsyncFunctionExpression(TreeBuilder&amp; context)
4371 {
4372     ASSERT(match(FUNCTION));
4373     JSTokenLocation location(tokenLocation());
4374     unsigned functionKeywordStart = tokenStart();
4375     next();
4376     SourceParseMode parseMode = SourceParseMode::AsyncFunctionMode;
4377 
4378     if (consume(TIMES))
4379         parseMode = SourceParseMode::AsyncGeneratorWrapperFunctionMode;
4380 
4381     ParserFunctionInfo&lt;TreeBuilder&gt; functionInfo;
<a name="98" id="anc98"></a><span class="line-modified">4382     functionInfo.name = &amp;m_vm-&gt;propertyNames-&gt;nullIdentifier;</span>
4383     failIfFalse(parseFunctionInfo(context, FunctionNameRequirements::None, parseMode, false, ConstructorKind::None, SuperBinding::NotNeeded, functionKeywordStart, functionInfo, FunctionDefinitionType::Expression), parseMode == SourceParseMode::AsyncFunctionMode ? &quot;Cannot parse async function expression&quot; : &quot;Cannot parse async generator function expression&quot;);
4384     return context.createFunctionExpr(location, functionInfo);
4385 }
4386 
4387 template &lt;typename LexerType&gt;
4388 template &lt;class TreeBuilder&gt; typename TreeBuilder::TemplateString Parser&lt;LexerType&gt;::parseTemplateString(TreeBuilder&amp; context, bool isTemplateHead, typename LexerType::RawStringsBuildMode rawStringsBuildMode, bool&amp; elementIsTail)
4389 {
4390     if (isTemplateHead)
4391         ASSERT(match(BACKQUOTE));
4392     else
4393         matchOrFail(CLOSEBRACE, &quot;Expected a closing &#39;}&#39; following an expression in template literal&quot;);
4394 
4395     // Re-scan the token to recognize it as Template Element.
4396     m_token.m_type = m_lexer-&gt;scanTemplateString(&amp;m_token, rawStringsBuildMode);
4397     matchOrFail(TEMPLATE, &quot;Expected an template element&quot;);
4398     const Identifier* cooked = m_token.m_data.cooked;
4399     const Identifier* raw = m_token.m_data.raw;
4400     elementIsTail = m_token.m_data.isTail;
4401     JSTokenLocation location(tokenLocation());
4402     next();
4403     return context.createTemplateString(location, cooked, raw);
4404 }
4405 
4406 template &lt;typename LexerType&gt;
4407 template &lt;class TreeBuilder&gt; typename TreeBuilder::TemplateLiteral Parser&lt;LexerType&gt;::parseTemplateLiteral(TreeBuilder&amp; context, typename LexerType::RawStringsBuildMode rawStringsBuildMode)
4408 {
4409     ASSERT(match(BACKQUOTE));
4410     JSTokenLocation location(tokenLocation());
4411     bool elementIsTail = false;
4412 
4413     auto headTemplateString = parseTemplateString(context, true, rawStringsBuildMode, elementIsTail);
4414     failIfFalse(headTemplateString, &quot;Cannot parse head template element&quot;);
4415 
4416     typename TreeBuilder::TemplateStringList templateStringList = context.createTemplateStringList(headTemplateString);
4417     typename TreeBuilder::TemplateStringList templateStringTail = templateStringList;
4418 
4419     if (elementIsTail)
4420         return context.createTemplateLiteral(location, templateStringList);
4421 
4422     failIfTrue(match(CLOSEBRACE), &quot;Template literal expression cannot be empty&quot;);
4423     TreeExpression expression = parseExpression(context);
4424     failIfFalse(expression, &quot;Cannot parse expression in template literal&quot;);
4425 
4426     typename TreeBuilder::TemplateExpressionList templateExpressionList = context.createTemplateExpressionList(expression);
4427     typename TreeBuilder::TemplateExpressionList templateExpressionTail = templateExpressionList;
4428 
4429     auto templateString = parseTemplateString(context, false, rawStringsBuildMode, elementIsTail);
4430     failIfFalse(templateString, &quot;Cannot parse template element&quot;);
4431     templateStringTail = context.createTemplateStringList(templateStringTail, templateString);
4432 
4433     while (!elementIsTail) {
4434         failIfTrue(match(CLOSEBRACE), &quot;Template literal expression cannot be empty&quot;);
4435         TreeExpression expression = parseExpression(context);
4436         failIfFalse(expression, &quot;Cannot parse expression in template literal&quot;);
4437 
4438         templateExpressionTail = context.createTemplateExpressionList(templateExpressionTail, expression);
4439 
4440         auto templateString = parseTemplateString(context, false, rawStringsBuildMode, elementIsTail);
4441         failIfFalse(templateString, &quot;Cannot parse template element&quot;);
4442         templateStringTail = context.createTemplateStringList(templateStringTail, templateString);
4443     }
4444 
4445     return context.createTemplateLiteral(location, templateStringList, templateExpressionList);
4446 }
4447 
4448 template &lt;class LexerType&gt;
4449 template &lt;class TreeBuilder&gt; TreeExpression Parser&lt;LexerType&gt;::createResolveAndUseVariable(TreeBuilder&amp; context, const Identifier* ident, bool isEval, const JSTextPosition&amp; start, const JSTokenLocation&amp; location)
4450 {
4451     currentScope()-&gt;useVariable(ident, isEval);
4452     m_parserState.lastIdentifier = ident;
4453     return context.createResolve(location, *ident, start, lastTokenEndPosition());
4454 }
4455 
4456 template &lt;typename LexerType&gt;
4457 template &lt;class TreeBuilder&gt; TreeExpression Parser&lt;LexerType&gt;::parsePrimaryExpression(TreeBuilder&amp; context)
4458 {
4459     failIfStackOverflow();
4460     switch (m_token.m_type) {
4461     case FUNCTION:
4462         return parseFunctionExpression(context);
4463     case CLASSTOKEN:
4464         return parseClassExpression(context);
4465     case OPENBRACE:
4466         if (strictMode())
4467             return parseStrictObjectLiteral(context);
4468         return parseObjectLiteral(context);
4469     case OPENBRACKET:
4470         return parseArrayLiteral(context);
4471     case OPENPAREN: {
4472         next();
4473         int oldNonLHSCount = m_parserState.nonLHSCount;
4474         TreeExpression result = parseExpression(context);
4475         m_parserState.nonLHSCount = oldNonLHSCount;
4476         handleProductionOrFail(CLOSEPAREN, &quot;)&quot;, &quot;end&quot;, &quot;compound expression&quot;);
4477         return result;
4478     }
4479     case THISTOKEN: {
4480         JSTokenLocation location(tokenLocation());
4481         next();
4482         if (currentScope()-&gt;isArrowFunction())
4483             currentScope()-&gt;setInnerArrowFunctionUsesThis();
4484         return context.createThisExpr(location);
4485     }
4486     case AWAIT:
4487         if (m_parserState.functionParsePhase == FunctionParsePhase::Parameters)
4488             failIfFalse(m_parserState.allowAwait, &quot;Cannot use await expression within parameters&quot;);
4489         else if (currentFunctionScope()-&gt;isAsyncFunctionBoundary())
4490             return parseAwaitExpression(context);
4491 
4492         goto identifierExpression;
4493     case IDENT: {
<a name="99" id="anc99"></a><span class="line-modified">4494         if (UNLIKELY(*m_token.m_data.ident == m_vm-&gt;propertyNames-&gt;async &amp;&amp; !m_token.m_data.escaped)) {</span>
4495             JSTextPosition start = tokenStartPosition();
4496             const Identifier* ident = m_token.m_data.ident;
4497             JSTokenLocation location(tokenLocation());
4498             next();
4499             if (match(FUNCTION) &amp;&amp; !m_lexer-&gt;hasLineTerminatorBeforeToken())
4500                 return parseAsyncFunctionExpression(context);
4501 
4502             // Avoid using variable if it is an arrow function parameter
4503             if (UNLIKELY(match(ARROWFUNCTION)))
4504                 return 0;
4505 
4506             const bool isEval = false;
4507             return createResolveAndUseVariable(context, ident, isEval, start, location);
4508         }
4509     identifierExpression:
4510         JSTextPosition start = tokenStartPosition();
4511         const Identifier* ident = m_token.m_data.ident;
4512         JSTokenLocation location(tokenLocation());
4513         next();
4514 
4515         // Avoid using variable if it is an arrow function parameter
4516         if (UNLIKELY(match(ARROWFUNCTION)))
4517             return 0;
4518 
<a name="100" id="anc100"></a><span class="line-modified">4519         return createResolveAndUseVariable(context, ident, *ident == m_vm-&gt;propertyNames-&gt;eval, start, location);</span>
4520     }
4521     case BIGINT: {
4522         const Identifier* ident = m_token.m_data.bigIntString;
4523         uint8_t radix = m_token.m_data.radix;
4524         JSTokenLocation location(tokenLocation());
4525         next();
4526         return context.createBigInt(location, ident, radix);
4527     }
4528     case STRING: {
4529         const Identifier* ident = m_token.m_data.ident;
4530         JSTokenLocation location(tokenLocation());
4531         next();
4532         return context.createString(location, ident);
4533     }
4534     case DOUBLE: {
4535         double d = m_token.m_data.doubleValue;
4536         JSTokenLocation location(tokenLocation());
4537         next();
4538         return context.createDoubleExpr(location, d);
4539     }
4540     case INTEGER: {
4541         double d = m_token.m_data.doubleValue;
4542         JSTokenLocation location(tokenLocation());
4543         next();
4544         return context.createIntegerExpr(location, d);
4545     }
4546     case NULLTOKEN: {
4547         JSTokenLocation location(tokenLocation());
4548         next();
4549         return context.createNull(location);
4550     }
4551     case TRUETOKEN: {
4552         JSTokenLocation location(tokenLocation());
4553         next();
4554         return context.createBoolean(location, true);
4555     }
4556     case FALSETOKEN: {
4557         JSTokenLocation location(tokenLocation());
4558         next();
4559         return context.createBoolean(location, false);
4560     }
4561     case DIVEQUAL:
4562     case DIVIDE: {
4563         /* regexp */
4564         if (match(DIVEQUAL))
4565             m_token.m_type = m_lexer-&gt;scanRegExp(&amp;m_token, &#39;=&#39;);
4566         else
4567             m_token.m_type = m_lexer-&gt;scanRegExp(&amp;m_token);
4568         matchOrFail(REGEXP, &quot;Invalid regular expression&quot;);
4569 
4570         const Identifier* pattern = m_token.m_data.pattern;
4571         const Identifier* flags = m_token.m_data.flags;
4572         JSTextPosition start = tokenStartPosition();
4573         JSTokenLocation location(tokenLocation());
4574         next();
4575         TreeExpression re = context.createRegExp(location, *pattern, *flags, start);
4576         if (!re) {
4577             Yarr::ErrorCode errorCode = Yarr::checkSyntax(pattern-&gt;string(), flags-&gt;string());
4578             regexFail(Yarr::errorMessage(errorCode));
4579         }
4580         return re;
4581     }
4582     case BACKQUOTE:
4583         return parseTemplateLiteral(context, LexerType::RawStringsBuildMode::DontBuildRawStrings);
4584     case YIELD:
4585         if (!strictMode() &amp;&amp; !currentScope()-&gt;isGenerator())
4586             goto identifierExpression;
4587         failDueToUnexpectedToken();
4588     case LET:
4589         if (!strictMode())
4590             goto identifierExpression;
4591         FALLTHROUGH;
4592     default:
4593         failDueToUnexpectedToken();
4594     }
4595 }
4596 
4597 template &lt;typename LexerType&gt;
4598 template &lt;class TreeBuilder&gt; TreeArguments Parser&lt;LexerType&gt;::parseArguments(TreeBuilder&amp; context)
4599 {
4600     consumeOrFailWithFlags(OPENPAREN, TreeBuilder::DontBuildStrings, &quot;Expected opening &#39;(&#39; at start of argument list&quot;);
4601     JSTokenLocation location(tokenLocation());
4602     if (match(CLOSEPAREN)) {
4603         next(TreeBuilder::DontBuildStrings);
4604         return context.createArguments();
4605     }
4606     auto argumentsStart = m_token.m_startPosition;
4607     auto argumentsDivot = m_token.m_endPosition;
4608 
4609     ArgumentType argType = ArgumentType::Normal;
4610     TreeExpression firstArg = parseArgument(context, argType);
4611     failIfFalse(firstArg, &quot;Cannot parse function argument&quot;);
4612     semanticFailIfTrue(match(DOTDOTDOT), &quot;The &#39;...&#39; operator should come before the target expression&quot;);
4613 
4614     bool hasSpread = false;
4615     if (argType == ArgumentType::Spread)
4616         hasSpread = true;
4617     TreeArgumentsList argList = context.createArgumentsList(location, firstArg);
4618     TreeArgumentsList tail = argList;
4619 
4620     while (match(COMMA)) {
4621         JSTokenLocation argumentLocation(tokenLocation());
4622         next(TreeBuilder::DontBuildStrings);
4623 
4624         if (UNLIKELY(match(CLOSEPAREN)))
4625             break;
4626 
4627         TreeExpression arg = parseArgument(context, argType);
4628         propagateError();
4629         semanticFailIfTrue(match(DOTDOTDOT), &quot;The &#39;...&#39; operator should come before the target expression&quot;);
4630 
4631         if (argType == ArgumentType::Spread)
4632             hasSpread = true;
4633 
4634         tail = context.createArgumentsList(argumentLocation, tail, arg);
4635     }
4636 
4637     handleProductionOrFail2(CLOSEPAREN, &quot;)&quot;, &quot;end&quot;, &quot;argument list&quot;);
4638     if (hasSpread) {
4639         TreeExpression spreadArray = context.createSpreadExpression(location, context.createArray(location, context.createElementList(argList)), argumentsStart, argumentsDivot, m_lastTokenEndPosition);
4640         return context.createArguments(context.createArgumentsList(location, spreadArray));
4641     }
4642 
4643     return context.createArguments(argList);
4644 }
4645 
4646 template &lt;typename LexerType&gt;
4647 template &lt;class TreeBuilder&gt; TreeExpression Parser&lt;LexerType&gt;::parseArgument(TreeBuilder&amp; context, ArgumentType&amp; type)
4648 {
4649     if (UNLIKELY(match(DOTDOTDOT))) {
4650         JSTokenLocation spreadLocation(tokenLocation());
4651         auto start = m_token.m_startPosition;
4652         auto divot = m_token.m_endPosition;
4653         next();
4654         TreeExpression spreadExpr = parseAssignmentExpression(context);
4655         propagateError();
4656         auto end = m_lastTokenEndPosition;
4657         type = ArgumentType::Spread;
4658         return context.createSpreadExpression(spreadLocation, spreadExpr, start, divot, end);
4659     }
4660 
4661     type = ArgumentType::Normal;
4662     return parseAssignmentExpression(context);
4663 }
4664 
4665 template &lt;typename TreeBuilder, typename ParserType, typename = typename std::enable_if&lt;std::is_same&lt;TreeBuilder, ASTBuilder&gt;::value&gt;::type&gt;
4666 static inline void recordCallOrApplyDepth(ParserType* parser, VM&amp; vm, Optional&lt;typename ParserType::CallOrApplyDepthScope&gt;&amp; callOrApplyDepthScope, ExpressionNode* expression)
4667 {
4668     if (expression-&gt;isDotAccessorNode()) {
4669         DotAccessorNode* dot = static_cast&lt;DotAccessorNode*&gt;(expression);
4670         bool isCallOrApply = dot-&gt;identifier() == vm.propertyNames-&gt;builtinNames().callPublicName() || dot-&gt;identifier() == vm.propertyNames-&gt;builtinNames().applyPublicName();
4671         if (isCallOrApply)
4672             callOrApplyDepthScope.emplace(parser);
4673     }
4674 }
4675 
4676 template &lt;typename TreeBuilder, typename ParserType, typename = typename std::enable_if&lt;std::is_same&lt;TreeBuilder, SyntaxChecker&gt;::value&gt;::type&gt;
4677 static inline void recordCallOrApplyDepth(ParserType*, VM&amp;, Optional&lt;typename ParserType::CallOrApplyDepthScope&gt;&amp;, SyntaxChecker::Expression)
4678 {
4679 }
4680 
4681 template &lt;typename LexerType&gt;
4682 template &lt;class TreeBuilder&gt; TreeExpression Parser&lt;LexerType&gt;::parseMemberExpression(TreeBuilder&amp; context)
4683 {
4684     TreeExpression base = 0;
4685     JSTextPosition expressionStart = tokenStartPosition();
4686     int newCount = 0;
4687     JSTokenLocation startLocation = tokenLocation();
4688     JSTokenLocation lastNewTokenLocation;
4689     while (match(NEW)) {
4690         lastNewTokenLocation = tokenLocation();
4691         next();
4692         newCount++;
4693     }
4694     JSTokenLocation location = tokenLocation();
4695 
4696     bool baseIsSuper = match(SUPER);
4697     bool previousBaseWasSuper = false;
4698     bool baseIsImport = match(IMPORT);
4699     semanticFailIfTrue((baseIsSuper || baseIsImport) &amp;&amp; newCount, &quot;Cannot use new with &quot;, getToken());
4700 
4701     bool baseIsNewTarget = false;
4702     if (newCount &amp;&amp; match(DOT)) {
4703         next();
<a name="101" id="anc101"></a><span class="line-modified">4704         if (matchContextualKeyword(m_vm-&gt;propertyNames-&gt;target)) {</span>
4705             ScopeRef closestOrdinaryFunctionScope = closestParentOrdinaryFunctionNonLexicalScope();
4706             semanticFailIfFalse(currentScope()-&gt;isFunction() || closestOrdinaryFunctionScope-&gt;evalContextType() == EvalContextType::FunctionEvalContext, &quot;new.target is only valid inside functions&quot;);
4707             baseIsNewTarget = true;
4708             if (currentScope()-&gt;isArrowFunction()) {
4709                 semanticFailIfFalse(!closestOrdinaryFunctionScope-&gt;isGlobalCodeScope() || closestOrdinaryFunctionScope-&gt;evalContextType() == EvalContextType::FunctionEvalContext, &quot;new.target is not valid inside arrow functions in global code&quot;);
4710                 currentScope()-&gt;setInnerArrowFunctionUsesNewTarget();
4711             }
4712             ASSERT(lastNewTokenLocation.line);
4713             base = context.createNewTargetExpr(lastNewTokenLocation);
4714             newCount--;
4715             next();
4716         } else {
4717             failIfTrue(match(IDENT), &quot;\&quot;new.\&quot; can only followed with target&quot;);
4718             failDueToUnexpectedToken();
4719         }
4720     }
4721 
4722     bool baseIsAsyncKeyword = false;
4723 
4724     if (baseIsSuper) {
4725         ScopeRef closestOrdinaryFunctionScope = closestParentOrdinaryFunctionNonLexicalScope();
4726         semanticFailIfFalse(currentScope()-&gt;isFunction() || (closestOrdinaryFunctionScope-&gt;isEvalContext() &amp;&amp; closestOrdinaryFunctionScope-&gt;expectedSuperBinding() == SuperBinding::Needed), &quot;super is not valid in this context&quot;);
4727         base = context.createSuperExpr(location);
4728         next();
4729         ScopeRef functionScope = currentFunctionScope();
4730         if (!functionScope-&gt;setNeedsSuperBinding()) {
4731             // It unnecessary to check of using super during reparsing one more time. Also it can lead to syntax error
4732             // in case of arrow function because during reparsing we don&#39;t know whether we currently parse the arrow function
4733             // inside of the constructor or method.
4734             if (!m_lexer-&gt;isReparsingFunction()) {
4735                 SuperBinding functionSuperBinding = !functionScope-&gt;isArrowFunction() &amp;&amp; !closestOrdinaryFunctionScope-&gt;isEvalContext()
4736                     ? functionScope-&gt;expectedSuperBinding()
4737                     : closestOrdinaryFunctionScope-&gt;expectedSuperBinding();
4738                 semanticFailIfTrue(functionSuperBinding == SuperBinding::NotNeeded, &quot;super is not valid in this context&quot;);
4739             }
4740         }
4741     } else if (baseIsImport) {
4742         next();
4743         JSTextPosition expressionEnd = lastTokenEndPosition();
4744         if (consume(DOT)) {
<a name="102" id="anc102"></a><span class="line-modified">4745             if (matchContextualKeyword(m_vm-&gt;propertyNames-&gt;builtinNames().metaPublicName())) {</span>
4746                 semanticFailIfFalse(m_scriptMode == JSParserScriptMode::Module, &quot;import.meta is only valid inside modules&quot;);
<a name="103" id="anc103"></a><span class="line-modified">4747                 base = context.createImportMetaExpr(location, createResolveAndUseVariable(context, &amp;m_vm-&gt;propertyNames-&gt;metaPrivateName, false, expressionStart, location));</span>
4748                 next();
4749             } else {
4750                 failIfTrue(match(IDENT), &quot;\&quot;import.\&quot; can only followed with meta&quot;);
4751                 failDueToUnexpectedToken();
4752             }
4753         } else {
4754             consumeOrFail(OPENPAREN, &quot;import call expects exactly one argument&quot;);
4755             TreeExpression expr = parseAssignmentExpression(context);
4756             failIfFalse(expr, &quot;Cannot parse expression&quot;);
4757             consumeOrFail(CLOSEPAREN, &quot;import call expects exactly one argument&quot;);
4758             base = context.createImportExpr(location, expr, expressionStart, expressionEnd, lastTokenEndPosition());
4759         }
4760     } else if (!baseIsNewTarget) {
<a name="104" id="anc104"></a><span class="line-modified">4761         const bool isAsync = matchContextualKeyword(m_vm-&gt;propertyNames-&gt;async);</span>
4762 
4763         base = parsePrimaryExpression(context);
4764         failIfFalse(base, &quot;Cannot parse base expression&quot;);
4765         if (UNLIKELY(isAsync &amp;&amp; context.isResolve(base) &amp;&amp; !m_lexer-&gt;hasLineTerminatorBeforeToken())) {
4766             if (matchSpecIdentifier()) {
4767                 // AsyncArrowFunction
4768                 forceClassifyExpressionError(ErrorIndicatesAsyncArrowFunction);
4769                 failDueToUnexpectedToken();
4770             }
4771             baseIsAsyncKeyword = true;
4772         }
4773     }
4774 
4775     failIfFalse(base, &quot;Cannot parse base expression&quot;);
<a name="105" id="anc105"></a><span class="line-removed">4776     while (true) {</span>
<span class="line-removed">4777         location = tokenLocation();</span>
<span class="line-removed">4778         switch (m_token.m_type) {</span>
<span class="line-removed">4779         case OPENBRACKET: {</span>
<span class="line-removed">4780             m_parserState.nonTrivialExpressionCount++;</span>
<span class="line-removed">4781             JSTextPosition expressionEnd = lastTokenEndPosition();</span>
<span class="line-removed">4782             next();</span>
<span class="line-removed">4783             int nonLHSCount = m_parserState.nonLHSCount;</span>
<span class="line-removed">4784             int initialAssignments = m_parserState.assignmentCount;</span>
<span class="line-removed">4785             TreeExpression property = parseExpression(context);</span>
<span class="line-removed">4786             failIfFalse(property, &quot;Cannot parse subscript expression&quot;);</span>
<span class="line-removed">4787             base = context.createBracketAccess(startLocation, base, property, initialAssignments != m_parserState.assignmentCount, expressionStart, expressionEnd, tokenEndPosition());</span>
4788 
<a name="106" id="anc106"></a><span class="line-modified">4789             if (UNLIKELY(baseIsSuper &amp;&amp; currentScope()-&gt;isArrowFunction()))</span>
<span class="line-modified">4790                 currentFunctionScope()-&gt;setInnerArrowFunctionUsesSuperProperty();</span>








4791 
<a name="107" id="anc107"></a><span class="line-modified">4792             handleProductionOrFail(CLOSEBRACKET, &quot;]&quot;, &quot;end&quot;, &quot;subscript expression&quot;);</span>
<span class="line-modified">4793             m_parserState.nonLHSCount = nonLHSCount;</span>
<span class="line-modified">4794             break;</span>





4795         }
<a name="108" id="anc108"></a><span class="line-modified">4796         case OPENPAREN: {</span>
<span class="line-modified">4797             m_parserState.nonTrivialExpressionCount++;</span>
<span class="line-modified">4798             int nonLHSCount = m_parserState.nonLHSCount;</span>
<span class="line-modified">4799             if (newCount) {</span>
<span class="line-modified">4800                 newCount--;</span>
<span class="line-modified">4801                 JSTextPosition expressionEnd = lastTokenEndPosition();</span>
<span class="line-removed">4802                 TreeArguments arguments = parseArguments(context);</span>
<span class="line-removed">4803                 failIfFalse(arguments, &quot;Cannot parse call arguments&quot;);</span>
<span class="line-removed">4804                 base = context.createNewExpr(location, base, arguments, expressionStart, expressionEnd, lastTokenEndPosition());</span>
<span class="line-removed">4805             } else {</span>
<span class="line-removed">4806                 size_t usedVariablesSize = currentScope()-&gt;currentUsedVariablesSize();</span>
4807                 JSTextPosition expressionEnd = lastTokenEndPosition();
<a name="109" id="anc109"></a><span class="line-modified">4808                 Optional&lt;CallOrApplyDepthScope&gt; callOrApplyDepthScope;</span>
<span class="line-modified">4809                 recordCallOrApplyDepth&lt;TreeBuilder&gt;(this, *m_vm, callOrApplyDepthScope, base);</span>




4810 
<a name="110" id="anc110"></a><span class="line-modified">4811                 TreeArguments arguments = parseArguments(context);</span>

4812 
<a name="111" id="anc111"></a><span class="line-modified">4813                 if (baseIsAsyncKeyword &amp;&amp; (!arguments || match(ARROWFUNCTION))) {</span>
<span class="line-modified">4814                     currentScope()-&gt;revertToPreviousUsedVariables(usedVariablesSize);</span>
<span class="line-modified">4815                     forceClassifyExpressionError(ErrorIndicatesAsyncArrowFunction);</span>
<span class="line-modified">4816                     failDueToUnexpectedToken();</span>
<span class="line-modified">4817                 }</span>















4818 
<a name="112" id="anc112"></a><span class="line-modified">4819                 failIfFalse(arguments, &quot;Cannot parse call arguments&quot;);</span>
<span class="line-modified">4820                 if (baseIsSuper) {</span>
<span class="line-modified">4821                     ScopeRef functionScope = currentFunctionScope();</span>
<span class="line-modified">4822                     if (!functionScope-&gt;setHasDirectSuper()) {</span>
<span class="line-modified">4823                         // It unnecessary to check of using super during reparsing one more time. Also it can lead to syntax error</span>
<span class="line-modified">4824                         // in case of arrow function because during reparsing we don&#39;t know whether we currently parse the arrow function</span>
<span class="line-modified">4825                         // inside of the constructor or method.</span>
<span class="line-modified">4826                         if (!m_lexer-&gt;isReparsingFunction()) {</span>
<span class="line-modified">4827                             ScopeRef closestOrdinaryFunctionScope = closestParentOrdinaryFunctionNonLexicalScope();</span>
<span class="line-modified">4828                             ConstructorKind functionConstructorKind = !functionScope-&gt;isArrowFunction() &amp;&amp; !closestOrdinaryFunctionScope-&gt;isEvalContext()</span>
<span class="line-modified">4829                                 ? functionScope-&gt;constructorKind()</span>
<span class="line-modified">4830                                 : closestOrdinaryFunctionScope-&gt;constructorKind();</span>
<span class="line-modified">4831                             semanticFailIfTrue(functionConstructorKind == ConstructorKind::None, &quot;super is not valid in this context&quot;);</span>
<span class="line-modified">4832                             semanticFailIfTrue(functionConstructorKind != ConstructorKind::Extends, &quot;super is not valid in this context&quot;);</span>







4833                         }
<a name="113" id="anc113"></a>

4834                     }
<a name="114" id="anc114"></a><span class="line-modified">4835                     if (currentScope()-&gt;isArrowFunction())</span>
<span class="line-modified">4836                         functionScope-&gt;setInnerArrowFunctionUsesSuperCall();</span>





4837                 }
<a name="115" id="anc115"></a><span class="line-modified">4838                 base = context.makeFunctionCallNode(startLocation, base, previousBaseWasSuper, arguments, expressionStart,</span>
<span class="line-modified">4839                     expressionEnd, lastTokenEndPosition(), callOrApplyDepthScope ? callOrApplyDepthScope-&gt;distanceToInnermostChild() : 0);</span>
4840             }
<a name="116" id="anc116"></a><span class="line-modified">4841             m_parserState.nonLHSCount = nonLHSCount;</span>
<span class="line-modified">4842             break;</span>
<span class="line-modified">4843         }</span>
<span class="line-modified">4844         case DOT: {</span>
<span class="line-modified">4845             m_parserState.nonTrivialExpressionCount++;</span>
<span class="line-modified">4846             JSTextPosition expressionEnd = lastTokenEndPosition();</span>
<span class="line-modified">4847             nextExpectIdentifier(LexerFlagsIgnoreReservedWords | TreeBuilder::DontBuildKeywords);</span>
<span class="line-modified">4848             matchOrFail(IDENT, &quot;Expected a property name after &#39;.&#39;&quot;);</span>
<span class="line-modified">4849             base = context.createDotAccess(startLocation, base, m_token.m_data.ident, expressionStart, expressionEnd, tokenEndPosition());</span>
<span class="line-modified">4850             if (UNLIKELY(baseIsSuper &amp;&amp; currentScope()-&gt;isArrowFunction()))</span>
<span class="line-modified">4851                 currentFunctionScope()-&gt;setInnerArrowFunctionUsesSuperProperty();</span>
<span class="line-modified">4852             next();</span>
<span class="line-modified">4853             break;</span>
<span class="line-modified">4854         }</span>
<span class="line-modified">4855         case BACKQUOTE: {</span>
<span class="line-modified">4856             semanticFailIfTrue(baseIsSuper, &quot;Cannot use super as tag for tagged templates&quot;);</span>
<span class="line-modified">4857             JSTextPosition expressionEnd = lastTokenEndPosition();</span>
<span class="line-modified">4858             int nonLHSCount = m_parserState.nonLHSCount;</span>
<span class="line-modified">4859             typename TreeBuilder::TemplateLiteral templateLiteral = parseTemplateLiteral(context, LexerType::RawStringsBuildMode::BuildRawStrings);</span>
<span class="line-modified">4860             failIfFalse(templateLiteral, &quot;Cannot parse template literal&quot;);</span>
<span class="line-modified">4861             base = context.createTaggedTemplate(startLocation, base, templateLiteral, expressionStart, expressionEnd, lastTokenEndPosition());</span>
<span class="line-modified">4862             m_parserState.nonLHSCount = nonLHSCount;</span>
<span class="line-modified">4863             m_seenTaggedTemplate = true;</span>
<span class="line-modified">4864             break;</span>
<span class="line-modified">4865         }</span>
<span class="line-modified">4866         default:</span>
<span class="line-modified">4867             goto endMemberExpression;</span>


4868         }
<a name="117" id="anc117"></a><span class="line-modified">4869         previousBaseWasSuper = baseIsSuper;</span>
<span class="line-modified">4870         baseIsSuper = false;</span>
<span class="line-modified">4871     }</span>
<span class="line-modified">4872 endMemberExpression:</span>

4873     semanticFailIfTrue(baseIsSuper, &quot;super is not valid in this context&quot;);
4874     while (newCount--)
4875         base = context.createNewExpr(location, base, expressionStart, lastTokenEndPosition());
4876     return base;
4877 }
4878 
4879 template &lt;typename LexerType&gt;
4880 template &lt;class TreeBuilder&gt; TreeExpression Parser&lt;LexerType&gt;::parseArrowFunctionExpression(TreeBuilder&amp; context, bool isAsync)
4881 {
4882     JSTokenLocation location;
4883 
4884     unsigned functionKeywordStart = tokenStart();
4885     location = tokenLocation();
4886     ParserFunctionInfo&lt;TreeBuilder&gt; info;
<a name="118" id="anc118"></a><span class="line-modified">4887     info.name = &amp;m_vm-&gt;propertyNames-&gt;nullIdentifier;</span>
4888 
4889     SourceParseMode parseMode = isAsync ? SourceParseMode::AsyncArrowFunctionMode : SourceParseMode::ArrowFunctionMode;
4890     failIfFalse((parseFunctionInfo(context, FunctionNameRequirements::Unnamed, parseMode, true, ConstructorKind::None, SuperBinding::NotNeeded, functionKeywordStart, info, FunctionDefinitionType::Expression)), &quot;Cannot parse arrow function expression&quot;);
4891 
4892     return context.createArrowFunctionExpr(location, info);
4893 }
4894 
4895 static const char* operatorString(bool prefix, unsigned tok)
4896 {
4897     switch (tok) {
4898     case MINUSMINUS:
4899     case AUTOMINUSMINUS:
4900         return prefix ? &quot;prefix-decrement&quot; : &quot;decrement&quot;;
4901 
4902     case PLUSPLUS:
4903     case AUTOPLUSPLUS:
4904         return prefix ? &quot;prefix-increment&quot; : &quot;increment&quot;;
4905 
4906     case EXCLAMATION:
4907         return &quot;logical-not&quot;;
4908 
4909     case TILDE:
4910         return &quot;bitwise-not&quot;;
4911 
4912     case TYPEOF:
4913         return &quot;typeof&quot;;
4914 
4915     case VOIDTOKEN:
4916         return &quot;void&quot;;
4917 
4918     case DELETETOKEN:
4919         return &quot;delete&quot;;
4920     }
4921     RELEASE_ASSERT_NOT_REACHED();
4922     return &quot;error&quot;;
4923 }
4924 
4925 template &lt;typename LexerType&gt;
4926 template &lt;class TreeBuilder&gt; TreeExpression Parser&lt;LexerType&gt;::parseUnaryExpression(TreeBuilder&amp; context)
4927 {
4928     typename TreeBuilder::UnaryExprContext unaryExprContext(context);
4929     AllowInOverride allowInOverride(this);
4930     int tokenStackDepth = 0;
<a name="119" id="anc119"></a><span class="line-modified">4931     bool modifiesExpr = false;</span>
<span class="line-removed">4932     bool requiresLExpr = false;</span>
4933     unsigned lastOperator = 0;
4934 
4935     if (UNLIKELY(match(AWAIT) &amp;&amp; currentFunctionScope()-&gt;isAsyncFunctionBoundary()))
4936         return parseAwaitExpression(context);
4937 
4938     JSTokenLocation location(tokenLocation());
4939 
4940     while (isUnaryOp(m_token.m_type)) {
<a name="120" id="anc120"></a><span class="line-modified">4941         if (strictMode()) {</span>
<span class="line-modified">4942             switch (m_token.m_type) {</span>
<span class="line-modified">4943             case PLUSPLUS:</span>
<span class="line-modified">4944             case MINUSMINUS:</span>
<span class="line-modified">4945             case AUTOPLUSPLUS:</span>
<span class="line-modified">4946             case AUTOMINUSMINUS:</span>
<span class="line-modified">4947                 semanticFailIfTrue(requiresLExpr, &quot;The &quot;, operatorString(true, lastOperator), &quot; operator requires a reference expression&quot;);</span>
<span class="line-modified">4948                 modifiesExpr = true;</span>
<span class="line-modified">4949                 requiresLExpr = true;</span>
<span class="line-modified">4950                 break;</span>
<span class="line-modified">4951             default:</span>
<span class="line-removed">4952                 semanticFailIfTrue(requiresLExpr, &quot;The &quot;, operatorString(true, lastOperator), &quot; operator requires a reference expression&quot;);</span>
<span class="line-removed">4953                 break;</span>
<span class="line-removed">4954             }</span>
4955         }
4956         lastOperator = m_token.m_type;
4957         m_parserState.nonLHSCount++;
4958         context.appendUnaryToken(tokenStackDepth, m_token.m_type, tokenStartPosition());
4959         next();
4960         m_parserState.nonTrivialExpressionCount++;
4961     }
4962     JSTextPosition subExprStart = tokenStartPosition();
4963     ASSERT(subExprStart.offset &gt;= subExprStart.lineStartOffset);
4964     TreeExpression expr = parseMemberExpression(context);
4965     if (!expr) {
4966         if (lastOperator)
4967             failWithMessage(&quot;Cannot parse subexpression of &quot;, operatorString(true, lastOperator), &quot;operator&quot;);
4968         failWithMessage(&quot;Cannot parse member expression&quot;);
4969     }
<a name="121" id="anc121"></a><span class="line-modified">4970     if (UNLIKELY(isUpdateOp(static_cast&lt;JSTokenType&gt;(lastOperator)) &amp;&amp; context.isMetaProperty(expr)))</span>
<span class="line-modified">4971         internalFailWithMessage(false, metaPropertyName(context, expr), &quot; can&#39;t come after a prefix operator&quot;);</span>


4972     bool isEvalOrArguments = false;
4973     if (strictMode()) {
4974         if (context.isResolve(expr))
<a name="122" id="anc122"></a><span class="line-modified">4975             isEvalOrArguments = *m_parserState.lastIdentifier == m_vm-&gt;propertyNames-&gt;eval || *m_parserState.lastIdentifier == m_vm-&gt;propertyNames-&gt;arguments;</span>
4976     }
<a name="123" id="anc123"></a><span class="line-modified">4977     failIfTrueIfStrict(isEvalOrArguments &amp;&amp; modifiesExpr, &quot;Cannot modify &#39;&quot;, m_parserState.lastIdentifier-&gt;impl(), &quot;&#39; in strict mode&quot;);</span>
4978     switch (m_token.m_type) {
4979     case PLUSPLUS:
<a name="124" id="anc124"></a><span class="line-modified">4980         if (UNLIKELY(context.isMetaProperty(expr)))</span>
<span class="line-modified">4981             internalFailWithMessage(false, metaPropertyName(context, expr), &quot; can&#39;t come before a postfix operator&quot;);</span>
4982         m_parserState.nonTrivialExpressionCount++;
4983         m_parserState.nonLHSCount++;
4984         expr = context.makePostfixNode(location, expr, OpPlusPlus, subExprStart, lastTokenEndPosition(), tokenEndPosition());
4985         m_parserState.assignmentCount++;
4986         failIfTrueIfStrict(isEvalOrArguments, &quot;Cannot modify &#39;&quot;, m_parserState.lastIdentifier-&gt;impl(), &quot;&#39; in strict mode&quot;);
<a name="125" id="anc125"></a><span class="line-modified">4987         semanticFailIfTrue(requiresLExpr, &quot;The &quot;, operatorString(false, lastOperator), &quot; operator requires a reference expression&quot;);</span>
<span class="line-removed">4988         lastOperator = PLUSPLUS;</span>
4989         next();
4990         break;
4991     case MINUSMINUS:
<a name="126" id="anc126"></a><span class="line-modified">4992         if (UNLIKELY(context.isMetaProperty(expr)))</span>
<span class="line-modified">4993             internalFailWithMessage(false, metaPropertyName(context, expr), &quot; can&#39;t come before a postfix operator&quot;);</span>
4994         m_parserState.nonTrivialExpressionCount++;
4995         m_parserState.nonLHSCount++;
4996         expr = context.makePostfixNode(location, expr, OpMinusMinus, subExprStart, lastTokenEndPosition(), tokenEndPosition());
4997         m_parserState.assignmentCount++;
4998         failIfTrueIfStrict(isEvalOrArguments, &quot;&#39;&quot;, m_parserState.lastIdentifier-&gt;impl(), &quot;&#39; cannot be modified in strict mode&quot;);
<a name="127" id="anc127"></a><span class="line-modified">4999         semanticFailIfTrue(requiresLExpr, &quot;The &quot;, operatorString(false, lastOperator), &quot; operator requires a reference expression&quot;);</span>
<span class="line-removed">5000         lastOperator = PLUSPLUS;</span>
5001         next();
5002         break;
5003     default:
5004         break;
5005     }
5006 
5007     JSTextPosition end = lastTokenEndPosition();
<a name="128" id="anc128"></a><span class="line-removed">5008 </span>
<span class="line-removed">5009     if (!TreeBuilder::CreatesAST &amp;&amp; (!strictMode()))</span>
<span class="line-removed">5010         return expr;</span>
<span class="line-removed">5011 </span>
5012     while (tokenStackDepth) {
5013         switch (context.unaryTokenStackLastType(tokenStackDepth)) {
5014         case EXCLAMATION:
5015             expr = context.createLogicalNot(location, expr);
5016             break;
5017         case TILDE:
5018             expr = context.makeBitwiseNotNode(location, expr);
5019             break;
5020         case MINUS:
5021             expr = context.makeNegateNode(location, expr);
5022             break;
5023         case PLUS:
5024             expr = context.createUnaryPlus(location, expr);
5025             break;
5026         case PLUSPLUS:
5027         case AUTOPLUSPLUS:
5028             expr = context.makePrefixNode(location, expr, OpPlusPlus, context.unaryTokenStackLastStart(tokenStackDepth), subExprStart + 1, end);
5029             m_parserState.assignmentCount++;
5030             break;
5031         case MINUSMINUS:
5032         case AUTOMINUSMINUS:
5033             expr = context.makePrefixNode(location, expr, OpMinusMinus, context.unaryTokenStackLastStart(tokenStackDepth), subExprStart + 1, end);
5034             m_parserState.assignmentCount++;
5035             break;
5036         case TYPEOF:
5037             expr = context.makeTypeOfNode(location, expr);
5038             break;
5039         case VOIDTOKEN:
5040             expr = context.createVoid(location, expr);
5041             break;
5042         case DELETETOKEN:
5043             failIfTrueIfStrict(context.isResolve(expr), &quot;Cannot delete unqualified property &#39;&quot;, m_parserState.lastIdentifier-&gt;impl(), &quot;&#39; in strict mode&quot;);
5044             expr = context.makeDeleteNode(location, expr, context.unaryTokenStackLastStart(tokenStackDepth), end, end);
5045             break;
5046         default:
5047             // If we get here something has gone horribly horribly wrong
5048             CRASH();
5049         }
5050         subExprStart = context.unaryTokenStackLastStart(tokenStackDepth);
5051         context.unaryTokenStackRemoveLast(tokenStackDepth);
5052     }
5053     return expr;
5054 }
5055 
5056 template &lt;typename LexerType&gt; void Parser&lt;LexerType&gt;::printUnexpectedTokenText(WTF::PrintStream&amp; out)
5057 {
5058     switch (m_token.m_type) {
5059     case EOFTOK:
5060         out.print(&quot;Unexpected end of script&quot;);
5061         return;
5062     case UNTERMINATED_IDENTIFIER_ESCAPE_ERRORTOK:
5063     case UNTERMINATED_IDENTIFIER_UNICODE_ESCAPE_ERRORTOK:
5064         out.print(&quot;Incomplete unicode escape in identifier: &#39;&quot;, getToken(), &quot;&#39;&quot;);
5065         return;
5066     case UNTERMINATED_MULTILINE_COMMENT_ERRORTOK:
5067         out.print(&quot;Unterminated multiline comment&quot;);
5068         return;
5069     case UNTERMINATED_NUMERIC_LITERAL_ERRORTOK:
5070         out.print(&quot;Unterminated numeric literal &#39;&quot;, getToken(), &quot;&#39;&quot;);
5071         return;
5072     case UNTERMINATED_STRING_LITERAL_ERRORTOK:
5073         out.print(&quot;Unterminated string literal &#39;&quot;, getToken(), &quot;&#39;&quot;);
5074         return;
5075     case INVALID_IDENTIFIER_ESCAPE_ERRORTOK:
5076         out.print(&quot;Invalid escape in identifier: &#39;&quot;, getToken(), &quot;&#39;&quot;);
5077         return;
5078     case UNEXPECTED_ESCAPE_ERRORTOK:
5079         out.print(&quot;Unexpected escaped characters in keyword token: &#39;&quot;, getToken(), &quot;&#39;&quot;);
5080         return;
5081     case INVALID_IDENTIFIER_UNICODE_ESCAPE_ERRORTOK:
5082         out.print(&quot;Invalid unicode escape in identifier: &#39;&quot;, getToken(), &quot;&#39;&quot;);
5083         return;
5084     case INVALID_NUMERIC_LITERAL_ERRORTOK:
5085         out.print(&quot;Invalid numeric literal: &#39;&quot;, getToken(), &quot;&#39;&quot;);
5086         return;
5087     case UNTERMINATED_OCTAL_NUMBER_ERRORTOK:
5088         out.print(&quot;Invalid use of octal: &#39;&quot;, getToken(), &quot;&#39;&quot;);
5089         return;
5090     case INVALID_STRING_LITERAL_ERRORTOK:
5091         out.print(&quot;Invalid string literal: &#39;&quot;, getToken(), &quot;&#39;&quot;);
5092         return;
5093     case ERRORTOK:
5094         out.print(&quot;Unrecognized token &#39;&quot;, getToken(), &quot;&#39;&quot;);
5095         return;
5096     case STRING:
5097         out.print(&quot;Unexpected string literal &quot;, getToken());
5098         return;
5099     case INTEGER:
5100     case DOUBLE:
5101         out.print(&quot;Unexpected number &#39;&quot;, getToken(), &quot;&#39;&quot;);
5102         return;
5103 
5104     case RESERVED_IF_STRICT:
5105         out.print(&quot;Unexpected use of reserved word &#39;&quot;, getToken(), &quot;&#39; in strict mode&quot;);
5106         return;
5107 
5108     case RESERVED:
5109         out.print(&quot;Unexpected use of reserved word &#39;&quot;, getToken(), &quot;&#39;&quot;);
5110         return;
5111 
5112     case INVALID_PRIVATE_NAME_ERRORTOK:
5113         out.print(&quot;Invalid private name &#39;&quot;, getToken(), &quot;&#39;&quot;);
5114         return;
5115 
5116     case AWAIT:
5117     case IDENT:
5118         out.print(&quot;Unexpected identifier &#39;&quot;, getToken(), &quot;&#39;&quot;);
5119         return;
5120 
5121     default:
5122         break;
5123     }
5124 
5125     if (m_token.m_type &amp; KeywordTokenFlag) {
5126         out.print(&quot;Unexpected keyword &#39;&quot;, getToken(), &quot;&#39;&quot;);
5127         return;
5128     }
5129 
5130     out.print(&quot;Unexpected token &#39;&quot;, getToken(), &quot;&#39;&quot;);
5131 }
5132 
5133 // Instantiate the two flavors of Parser we need instead of putting most of this file in Parser.h
5134 template class Parser&lt;Lexer&lt;LChar&gt;&gt;;
5135 template class Parser&lt;Lexer&lt;UChar&gt;&gt;;
5136 
5137 } // namespace JSC
<a name="129" id="anc129"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="129" type="hidden" />
</body>
</html>