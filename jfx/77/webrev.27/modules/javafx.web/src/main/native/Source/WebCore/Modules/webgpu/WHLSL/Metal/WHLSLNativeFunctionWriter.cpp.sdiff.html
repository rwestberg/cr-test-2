<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/Modules/webgpu/WHLSL/Metal/WHLSLNativeFunctionWriter.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="WHLSLMetalCodeGenerator.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="WHLSLNativeFunctionWriter.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/Modules/webgpu/WHLSL/Metal/WHLSLNativeFunctionWriter.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;WHLSLNativeFunctionWriter.h&quot;
 28 
 29 #if ENABLE(WEBGPU)
 30 

 31 #include &quot;WHLSLAddressSpace.h&quot;




 32 #include &quot;WHLSLNamedType.h&quot;
 33 #include &quot;WHLSLNativeFunctionDeclaration.h&quot;
 34 #include &quot;WHLSLNativeTypeDeclaration.h&quot;
 35 #include &quot;WHLSLPointerType.h&quot;


 36 #include &quot;WHLSLTypeNamer.h&quot;
 37 #include &quot;WHLSLUnnamedType.h&quot;
 38 #include &quot;WHLSLVariableDeclaration.h&quot;
 39 #include &lt;wtf/text/StringBuilder.h&gt;
 40 
 41 namespace WebCore {
 42 
 43 namespace WHLSL {
 44 
 45 namespace Metal {
 46 
<span class="line-removed"> 47 static String getNativeName(AST::UnnamedType&amp; unnamedType, TypeNamer&amp; typeNamer)</span>
<span class="line-removed"> 48 {</span>
<span class="line-removed"> 49     ASSERT(is&lt;AST::NamedType&gt;(unnamedType.unifyNode()));</span>
<span class="line-removed"> 50     auto&amp; namedType = downcast&lt;AST::NamedType&gt;(unnamedType.unifyNode());</span>
<span class="line-removed"> 51     ASSERT(is&lt;AST::NativeTypeDeclaration&gt;(namedType));</span>
<span class="line-removed"> 52     auto&amp; nativeTypeDeclaration = downcast&lt;AST::NativeTypeDeclaration&gt;(namedType);</span>
<span class="line-removed"> 53     return typeNamer.mangledNameForType(nativeTypeDeclaration);</span>
<span class="line-removed"> 54 }</span>
<span class="line-removed"> 55 </span>
 56 static String mapFunctionName(String&amp; functionName)
 57 {
 58     if (functionName == &quot;ddx&quot;)
 59         return &quot;dfdx&quot;_str;
 60     if (functionName == &quot;ddy&quot;)
 61         return &quot;dfdy&quot;_str;
 62     if (functionName == &quot;asint&quot;)
 63         return &quot;as_type&lt;int32_t&gt;&quot;_str;
 64     if (functionName == &quot;asuint&quot;)
 65         return &quot;as_type&lt;uint32_t&gt;&quot;_str;
 66     if (functionName == &quot;asfloat&quot;)
 67         return &quot;as_type&lt;float&gt;&quot;_str;
 68     return functionName;
 69 }
 70 
<span class="line-removed"> 71 static String convertAddressSpace(AST::AddressSpace addressSpace)</span>
<span class="line-removed"> 72 {</span>
<span class="line-removed"> 73     switch (addressSpace) {</span>
<span class="line-removed"> 74     case AST::AddressSpace::Constant:</span>
<span class="line-removed"> 75         return &quot;constant&quot;_str;</span>
<span class="line-removed"> 76     case AST::AddressSpace::Device:</span>
<span class="line-removed"> 77         return &quot;device&quot;_str;</span>
<span class="line-removed"> 78     case AST::AddressSpace::Threadgroup:</span>
<span class="line-removed"> 79         return &quot;threadgroup&quot;_str;</span>
<span class="line-removed"> 80     default:</span>
<span class="line-removed"> 81         ASSERT(addressSpace == AST::AddressSpace::Thread);</span>
<span class="line-removed"> 82         return &quot;thread&quot;_str;</span>
<span class="line-removed"> 83     }</span>
<span class="line-removed"> 84 }</span>
<span class="line-removed"> 85 </span>
 86 static String atomicName(String input)
 87 {
 88     if (input == &quot;Add&quot;)
 89         return &quot;fetch_add&quot;_str;
 90     if (input == &quot;And&quot;)
 91         return &quot;fetch_and&quot;_str;
 92     if (input == &quot;Exchange&quot;)
 93         return &quot;exchange&quot;_str;
 94     if (input == &quot;Max&quot;)
 95         return &quot;fetch_max&quot;_str;
 96     if (input == &quot;Min&quot;)
 97         return &quot;fetch_min&quot;_str;
 98     if (input == &quot;Or&quot;)
 99         return &quot;fetch_or&quot;_str;
100     ASSERT(input == &quot;Xor&quot;);
101         return &quot;fetch_xor&quot;_str;
102 }
103 
<span class="line-modified">104 String writeNativeFunction(AST::NativeFunctionDeclaration&amp; nativeFunctionDeclaration, String&amp; outputFunctionName, TypeNamer&amp; typeNamer)</span>




































105 {
<span class="line-modified">106     StringBuilder stringBuilder;</span>











107     if (nativeFunctionDeclaration.isCast()) {
























































































108         ASSERT(nativeFunctionDeclaration.parameters().size() == 1);
<span class="line-modified">109         auto metalParameterName = getNativeName(*nativeFunctionDeclaration.parameters()[0].type(), typeNamer);</span>
<span class="line-modified">110         auto metalReturnName = getNativeName(nativeFunctionDeclaration.type(), typeNamer);</span>
<span class="line-modified">111         if (metalParameterName != &quot;atomic_int&quot;_str &amp;&amp; metalParameterName != &quot;atomic_uint&quot;_str) {</span>
<span class="line-modified">112             stringBuilder.append(makeString(metalReturnName, &#39; &#39;, outputFunctionName, &#39;(&#39;, metalParameterName, &quot;x) {\n&quot;));</span>
<span class="line-modified">113             stringBuilder.append(makeString(&quot;    return static_cast&lt;&quot;, metalReturnName, &quot;&gt;(x);\n&quot;));</span>
<span class="line-modified">114             stringBuilder.append(&quot;}\n&quot;);</span>
<span class="line-modified">115             return stringBuilder.toString();</span>
116         }
117 
<span class="line-modified">118         stringBuilder.append(makeString(metalReturnName, &#39; &#39;, outputFunctionName, &#39;(&#39;, metalParameterName, &quot;x) {\n&quot;));</span>
<span class="line-modified">119         stringBuilder.append(&quot;    return atomic_load_explicit(&amp;x, memory_order_relaxed);\n&quot;);</span>
<span class="line-modified">120         stringBuilder.append(&quot;}\n&quot;);</span>
<span class="line-modified">121         return stringBuilder.toString();</span>
122     }
123 
124     if (nativeFunctionDeclaration.name().startsWith(&quot;operator.&quot;_str)) {














125         if (nativeFunctionDeclaration.name().endsWith(&quot;=&quot;)) {
126             ASSERT(nativeFunctionDeclaration.parameters().size() == 2);
<span class="line-removed">127             auto metalParameter1Name = getNativeName(*nativeFunctionDeclaration.parameters()[0].type(), typeNamer);</span>
<span class="line-removed">128             auto metalParameter2Name = getNativeName(*nativeFunctionDeclaration.parameters()[1].type(), typeNamer);</span>
<span class="line-removed">129             auto metalReturnName = getNativeName(nativeFunctionDeclaration.type(), typeNamer);</span>
130             auto fieldName = nativeFunctionDeclaration.name().substring(&quot;operator.&quot;_str.length());
131             fieldName = fieldName.substring(0, fieldName.length() - 1);
<span class="line-modified">132             stringBuilder.append(makeString(metalReturnName, &#39; &#39;, outputFunctionName, &#39;(&#39;, metalParameter1Name, &quot;v, &quot;, metalParameter2Name, &quot; n) {\n&quot;));</span>
<span class="line-modified">133             stringBuilder.append(makeString(&quot;    v.&quot;, fieldName, &quot; = n;\n&quot;));</span>
<span class="line-modified">134             stringBuilder.append(makeString(&quot;    return v;\n&quot;));</span>
<span class="line-modified">135             stringBuilder.append(&quot;}\n&quot;);</span>
<span class="line-modified">136             return stringBuilder.toString();</span>



137         }
138 
139         ASSERT(nativeFunctionDeclaration.parameters().size() == 1);
<span class="line-modified">140         auto metalParameterName = getNativeName(*nativeFunctionDeclaration.parameters()[0].type(), typeNamer);</span>
<span class="line-modified">141         auto metalReturnName = getNativeName(nativeFunctionDeclaration.type(), typeNamer);</span>
<span class="line-modified">142         stringBuilder.append(makeString(metalReturnName, &#39; &#39;, outputFunctionName, &#39;(&#39;, metalParameterName, &quot;v) {\n&quot;));</span>
<span class="line-modified">143         stringBuilder.append(makeString(&quot;    return v.&quot;, nativeFunctionDeclaration.name().substring(&quot;operator.&quot;_str.length()), &quot;;\n&quot;));</span>
<span class="line-modified">144         stringBuilder.append(&quot;}\n&quot;);</span>
<span class="line-modified">145         return stringBuilder.toString();</span>








146 














147     }
148 

























149     if (nativeFunctionDeclaration.name() == &quot;operator[]&quot;) {
150         ASSERT(nativeFunctionDeclaration.parameters().size() == 2);
<span class="line-modified">151         auto metalParameter1Name = getNativeName(*nativeFunctionDeclaration.parameters()[0].type(), typeNamer);</span>
<span class="line-modified">152         auto metalParameter2Name = getNativeName(*nativeFunctionDeclaration.parameters()[1].type(), typeNamer);</span>
<span class="line-modified">153         auto metalReturnName = getNativeName(nativeFunctionDeclaration.type(), typeNamer);</span>
<span class="line-modified">154         stringBuilder.append(makeString(metalReturnName, &#39; &#39;, outputFunctionName, &#39;(&#39;, metalParameter1Name, &quot;m, &quot;, metalParameter2Name, &quot; i) {\n&quot;));</span>
<span class="line-modified">155         stringBuilder.append(makeString(&quot;    return m[i];\n&quot;));</span>
<span class="line-modified">156         stringBuilder.append(&quot;}\n&quot;);</span>
<span class="line-modified">157         return stringBuilder.toString();</span>












































158     }
159 
160     if (nativeFunctionDeclaration.name() == &quot;operator[]=&quot;) {
<span class="line-modified">161         ASSERT(nativeFunctionDeclaration.parameters().size() == 3);</span>
<span class="line-modified">162         auto metalParameter1Name = getNativeName(*nativeFunctionDeclaration.parameters()[0].type(), typeNamer);</span>
<span class="line-modified">163         auto metalParameter2Name = getNativeName(*nativeFunctionDeclaration.parameters()[1].type(), typeNamer);</span>
<span class="line-modified">164         auto metalParameter3Name = getNativeName(*nativeFunctionDeclaration.parameters()[2].type(), typeNamer);</span>
<span class="line-modified">165         auto metalReturnName = getNativeName(nativeFunctionDeclaration.type(), typeNamer);</span>
<span class="line-modified">166         stringBuilder.append(makeString(metalReturnName, &#39; &#39;, outputFunctionName, &#39;(&#39;, metalParameter1Name, &quot;m, &quot;, metalParameter2Name, &quot; i, &quot;, metalParameter3Name, &quot; v) {\n&quot;));</span>
<span class="line-modified">167         stringBuilder.append(makeString(&quot;    m[i] = v;\n&quot;));</span>
<span class="line-modified">168         stringBuilder.append(makeString(&quot;    return m;\n&quot;));</span>
<span class="line-modified">169         stringBuilder.append(&quot;}\n&quot;);</span>
<span class="line-modified">170         return stringBuilder.toString();</span>
















































171     }
172 
173     if (nativeFunctionDeclaration.isOperator()) {


174         if (nativeFunctionDeclaration.parameters().size() == 1) {
<span class="line-modified">175             auto operatorName = nativeFunctionDeclaration.name().substring(&quot;operator&quot;_str.length());</span>
<span class="line-modified">176             auto metalParameterName = getNativeName(*nativeFunctionDeclaration.parameters()[0].type(), typeNamer);</span>
<span class="line-modified">177             auto metalReturnName = getNativeName(nativeFunctionDeclaration.type(), typeNamer);</span>
<span class="line-modified">178             stringBuilder.append(makeString(metalReturnName, &#39; &#39;, outputFunctionName, &#39;(&#39;, metalParameterName, &quot;x) {\n&quot;));</span>
<span class="line-modified">179             stringBuilder.append(makeString(&quot;    return &quot;, operatorName, &quot;x;\n&quot;));</span>
<span class="line-modified">180             stringBuilder.append(&quot;}\n&quot;);</span>
<span class="line-modified">181             return stringBuilder.toString();</span>















182         }
183 
184         ASSERT(nativeFunctionDeclaration.parameters().size() == 2);
<span class="line-modified">185         auto operatorName = nativeFunctionDeclaration.name().substring(&quot;operator&quot;_str.length());</span>
<span class="line-modified">186         auto metalParameter1Name = getNativeName(*nativeFunctionDeclaration.parameters()[0].type(), typeNamer);</span>
<span class="line-modified">187         auto metalParameter2Name = getNativeName(*nativeFunctionDeclaration.parameters()[1].type(), typeNamer);</span>
<span class="line-modified">188         auto metalReturnName = getNativeName(nativeFunctionDeclaration.type(), typeNamer);</span>
<span class="line-modified">189         stringBuilder.append(makeString(metalReturnName, &#39; &#39;, outputFunctionName, &#39;(&#39;, metalParameter1Name, &quot;x, &quot;, metalParameter2Name, &quot; y) {\n&quot;));</span>
<span class="line-modified">190         stringBuilder.append(makeString(&quot;    return x &quot;, operatorName, &quot; y;\n&quot;));</span>
<span class="line-modified">191         stringBuilder.append(&quot;}\n&quot;);</span>
<span class="line-modified">192         return stringBuilder.toString();</span>









































193     }
194 
195     if (nativeFunctionDeclaration.name() == &quot;cos&quot;
196         || nativeFunctionDeclaration.name() == &quot;sin&quot;
197         || nativeFunctionDeclaration.name() == &quot;tan&quot;
198         || nativeFunctionDeclaration.name() == &quot;acos&quot;
199         || nativeFunctionDeclaration.name() == &quot;asin&quot;
200         || nativeFunctionDeclaration.name() == &quot;atan&quot;
201         || nativeFunctionDeclaration.name() == &quot;cosh&quot;
202         || nativeFunctionDeclaration.name() == &quot;sinh&quot;
203         || nativeFunctionDeclaration.name() == &quot;tanh&quot;
204         || nativeFunctionDeclaration.name() == &quot;ceil&quot;
205         || nativeFunctionDeclaration.name() == &quot;exp&quot;
206         || nativeFunctionDeclaration.name() == &quot;floor&quot;
207         || nativeFunctionDeclaration.name() == &quot;log&quot;
208         || nativeFunctionDeclaration.name() == &quot;round&quot;
209         || nativeFunctionDeclaration.name() == &quot;trunc&quot;
210         || nativeFunctionDeclaration.name() == &quot;ddx&quot;
211         || nativeFunctionDeclaration.name() == &quot;ddy&quot;
212         || nativeFunctionDeclaration.name() == &quot;isnormal&quot;
213         || nativeFunctionDeclaration.name() == &quot;isfinite&quot;
214         || nativeFunctionDeclaration.name() == &quot;isinf&quot;
215         || nativeFunctionDeclaration.name() == &quot;isnan&quot;
216         || nativeFunctionDeclaration.name() == &quot;asint&quot;
217         || nativeFunctionDeclaration.name() == &quot;asuint&quot;
<span class="line-modified">218         || nativeFunctionDeclaration.name() == &quot;asfloat&quot;) {</span>

219         ASSERT(nativeFunctionDeclaration.parameters().size() == 1);
<span class="line-modified">220         auto metalParameterName = getNativeName(*nativeFunctionDeclaration.parameters()[0].type(), typeNamer);</span>
<span class="line-modified">221         auto metalReturnName = getNativeName(nativeFunctionDeclaration.type(), typeNamer);</span>
<span class="line-modified">222         stringBuilder.append(makeString(metalReturnName, &#39; &#39;, outputFunctionName, &#39;(&#39;, metalParameterName, &quot;x) {\n&quot;));</span>
<span class="line-removed">223         stringBuilder.append(makeString(&quot;    return &quot;, mapFunctionName(nativeFunctionDeclaration.name()), &quot;(x);\n&quot;));</span>
<span class="line-removed">224         stringBuilder.append(&quot;}\n&quot;);</span>
<span class="line-removed">225         return stringBuilder.toString();</span>
226     }
227 
228     if (nativeFunctionDeclaration.name() == &quot;pow&quot; || nativeFunctionDeclaration.name() == &quot;atan2&quot;) {
229         ASSERT(nativeFunctionDeclaration.parameters().size() == 2);
<span class="line-modified">230         auto metalParameter1Name = getNativeName(*nativeFunctionDeclaration.parameters()[0].type(), typeNamer);</span>
<span class="line-modified">231         auto metalParameter2Name = getNativeName(*nativeFunctionDeclaration.parameters()[1].type(), typeNamer);</span>
<span class="line-modified">232         auto metalReturnName = getNativeName(nativeFunctionDeclaration.type(), typeNamer);</span>
<span class="line-removed">233         stringBuilder.append(makeString(metalReturnName, &#39; &#39;, outputFunctionName, &#39;(&#39;, metalParameter1Name, &quot;x, &quot;, metalParameter2Name, &quot; y) {\n&quot;));</span>
<span class="line-removed">234         stringBuilder.append(makeString(&quot;    return &quot;, nativeFunctionDeclaration.name(), &quot;(x, y);\n&quot;));</span>
<span class="line-removed">235         stringBuilder.append(&quot;}\n&quot;);</span>
<span class="line-removed">236         return stringBuilder.toString();</span>
237     }
238 
<span class="line-modified">239     if (nativeFunctionDeclaration.name() == &quot;f16tof32&quot; || nativeFunctionDeclaration.name() == &quot;f32tof16&quot;) {</span>
<span class="line-modified">240         // FIXME: Implement this</span>
<span class="line-modified">241         CRASH();</span>

















242     }
243 
244     if (nativeFunctionDeclaration.name() == &quot;AllMemoryBarrierWithGroupSync&quot;) {
245         ASSERT(!nativeFunctionDeclaration.parameters().size());
<span class="line-modified">246         stringBuilder.append(makeString(&quot;void &quot;, outputFunctionName, &quot;() {\n&quot;));</span>
<span class="line-modified">247         stringBuilder.append(&quot;    threadgroup_barrier(mem_flags::mem_device);\n&quot;);</span>
<span class="line-modified">248         stringBuilder.append(&quot;    threadgroup_barrier(mem_flags::mem_threadgroup);\n&quot;);</span>
<span class="line-modified">249         stringBuilder.append(&quot;    threadgroup_barrier(mem_flags::mem_texture);\n&quot;);</span>
<span class="line-modified">250         stringBuilder.append(&quot;}\n&quot;);</span>
<span class="line-removed">251         return stringBuilder.toString();</span>
252     }
253 
254     if (nativeFunctionDeclaration.name() == &quot;DeviceMemoryBarrierWithGroupSync&quot;) {
255         ASSERT(!nativeFunctionDeclaration.parameters().size());
<span class="line-modified">256         stringBuilder.append(makeString(&quot;void &quot;, outputFunctionName, &quot;() {\n&quot;));</span>
<span class="line-modified">257         stringBuilder.append(&quot;    threadgroup_barrier(mem_flags::mem_device);\n&quot;);</span>
<span class="line-modified">258         stringBuilder.append(&quot;}\n&quot;);</span>
<span class="line-removed">259         return stringBuilder.toString();</span>
260     }
261 
262     if (nativeFunctionDeclaration.name() == &quot;GroupMemoryBarrierWithGroupSync&quot;) {
263         ASSERT(!nativeFunctionDeclaration.parameters().size());
<span class="line-modified">264         stringBuilder.append(makeString(&quot;void &quot;, outputFunctionName, &quot;() {\n&quot;));</span>
<span class="line-modified">265         stringBuilder.append(&quot;    threadgroup_barrier(mem_flags::mem_threadgroup);\n&quot;);</span>
<span class="line-modified">266         stringBuilder.append(&quot;}\n&quot;);</span>
<span class="line-removed">267         return stringBuilder.toString();</span>
268     }
269 
270     if (nativeFunctionDeclaration.name().startsWith(&quot;Interlocked&quot;_str)) {
271         if (nativeFunctionDeclaration.name() == &quot;InterlockedCompareExchange&quot;) {
272             ASSERT(nativeFunctionDeclaration.parameters().size() == 4);
<span class="line-modified">273             ASSERT(is&lt;AST::PointerType&gt;(*nativeFunctionDeclaration.parameters()[0].type()));</span>
<span class="line-modified">274             auto&amp; firstArgumentPointer = downcast&lt;AST::PointerType&gt;(*nativeFunctionDeclaration.parameters()[0].type());</span>
<span class="line-modified">275             auto firstArgumentAddressSpace = firstArgumentPointer.addressSpace();</span>
<span class="line-modified">276             auto firstArgumentPointee = getNativeName(firstArgumentPointer.elementType(), typeNamer);</span>
<span class="line-removed">277             auto secondArgument = getNativeName(*nativeFunctionDeclaration.parameters()[1].type(), typeNamer);</span>
<span class="line-removed">278             auto thirdArgument = getNativeName(*nativeFunctionDeclaration.parameters()[2].type(), typeNamer);</span>
<span class="line-removed">279             ASSERT(is&lt;AST::PointerType&gt;(*nativeFunctionDeclaration.parameters()[3].type()));</span>
<span class="line-removed">280             auto&amp; fourthArgumentPointer = downcast&lt;AST::PointerType&gt;(*nativeFunctionDeclaration.parameters()[3].type());</span>
<span class="line-removed">281             auto fourthArgumentAddressSpace = fourthArgumentPointer.addressSpace();</span>
<span class="line-removed">282             auto fourthArgumentPointee = getNativeName(fourthArgumentPointer.elementType(), typeNamer);</span>
<span class="line-removed">283             stringBuilder.append(makeString(&quot;void &quot;, outputFunctionName, &#39;(&#39;, convertAddressSpace(firstArgumentAddressSpace), &#39; &#39;, firstArgumentPointee, &quot;* object, &quot;, secondArgument, &quot; compare, &quot;, thirdArgument, &quot; desired, &quot;, convertAddressSpace(fourthArgumentAddressSpace), &#39; &#39;, fourthArgumentPointee, &quot;* out) {\n&quot;));</span>
<span class="line-removed">284             stringBuilder.append(&quot;    atomic_compare_exchange_weak_explicit(object, &amp;compare, desired, memory_order_relaxed);\n&quot;);</span>
<span class="line-removed">285             stringBuilder.append(&quot;    *out = compare;\n&quot;);</span>
<span class="line-removed">286             stringBuilder.append(&quot;}\n&quot;);</span>
<span class="line-removed">287             return stringBuilder.toString();</span>
288         }
289 
290         ASSERT(nativeFunctionDeclaration.parameters().size() == 3);
<span class="line-removed">291         ASSERT(is&lt;AST::PointerType&gt;(*nativeFunctionDeclaration.parameters()[0].type()));</span>
<span class="line-removed">292         auto&amp; firstArgumentPointer = downcast&lt;AST::PointerType&gt;(*nativeFunctionDeclaration.parameters()[0].type());</span>
<span class="line-removed">293         auto firstArgumentAddressSpace = firstArgumentPointer.addressSpace();</span>
<span class="line-removed">294         auto firstArgumentPointee = getNativeName(firstArgumentPointer.elementType(), typeNamer);</span>
<span class="line-removed">295         auto secondArgument = getNativeName(*nativeFunctionDeclaration.parameters()[1].type(), typeNamer);</span>
<span class="line-removed">296         ASSERT(is&lt;AST::PointerType&gt;(*nativeFunctionDeclaration.parameters()[2].type()));</span>
<span class="line-removed">297         auto&amp; thirdArgumentPointer = downcast&lt;AST::PointerType&gt;(*nativeFunctionDeclaration.parameters()[2].type());</span>
<span class="line-removed">298         auto thirdArgumentAddressSpace = thirdArgumentPointer.addressSpace();</span>
<span class="line-removed">299         auto thirdArgumentPointee = getNativeName(thirdArgumentPointer.elementType(), typeNamer);</span>
300         auto name = atomicName(nativeFunctionDeclaration.name().substring(&quot;Interlocked&quot;_str.length()));
<span class="line-modified">301         stringBuilder.append(makeString(&quot;void &quot;, outputFunctionName, &#39;(&#39;, convertAddressSpace(firstArgumentAddressSpace), &#39; &#39;, firstArgumentPointee, &quot;* object, &quot;, secondArgument, &quot; operand, &quot;, convertAddressSpace(thirdArgumentAddressSpace), &#39; &#39;, thirdArgumentPointee, &quot;* out) {\n&quot;));</span>
<span class="line-modified">302         stringBuilder.append(makeString(&quot;    *out = atomic_fetch_&quot;, name, &quot;_explicit(object, operand, memory_order_relaxed);\n&quot;));</span>
<span class="line-modified">303         stringBuilder.append(&quot;}\n&quot;);</span>
<span class="line-removed">304         return stringBuilder.toString();</span>
305     }
306 
307     if (nativeFunctionDeclaration.name() == &quot;Sample&quot;) {
<span class="line-modified">308         // FIXME: Implement this.</span>
<span class="line-modified">309         CRASH();</span>






















310     }
311 
312     if (nativeFunctionDeclaration.name() == &quot;Load&quot;) {
<span class="line-modified">313         // FIXME: Implement this.</span>
<span class="line-modified">314         CRASH();</span>



















































































315     }
316 
317     if (nativeFunctionDeclaration.name() == &quot;GetDimensions&quot;) {
<span class="line-modified">318         // FIXME: Implement this.</span>
<span class="line-modified">319         CRASH();</span>






























































320     }
321 
322     if (nativeFunctionDeclaration.name() == &quot;SampleBias&quot;) {
<span class="line-modified">323         // FIXME: Implement this.</span>
<span class="line-modified">324         CRASH();</span>
325     }
326 
327     if (nativeFunctionDeclaration.name() == &quot;SampleGrad&quot;) {
<span class="line-modified">328         // FIXME: Implement this.</span>
<span class="line-modified">329         CRASH();</span>
330     }
331 
332     if (nativeFunctionDeclaration.name() == &quot;SampleLevel&quot;) {
<span class="line-modified">333         // FIXME: Implement this.</span>
<span class="line-modified">334         CRASH();</span>
335     }
336 
337     if (nativeFunctionDeclaration.name() == &quot;Gather&quot;) {
<span class="line-modified">338         // FIXME: Implement this.</span>
<span class="line-modified">339         CRASH();</span>
340     }
341 
342     if (nativeFunctionDeclaration.name() == &quot;GatherRed&quot;) {
<span class="line-modified">343         // FIXME: Implement this.</span>
<span class="line-modified">344         CRASH();</span>
345     }
346 
347     if (nativeFunctionDeclaration.name() == &quot;SampleCmp&quot;) {
<span class="line-modified">348         // FIXME: Implement this.</span>
<span class="line-modified">349         CRASH();</span>
350     }
351 
352     if (nativeFunctionDeclaration.name() == &quot;SampleCmpLevelZero&quot;) {
<span class="line-modified">353         // FIXME: Implement this.</span>
<span class="line-modified">354         CRASH();</span>
355     }
356 
357     if (nativeFunctionDeclaration.name() == &quot;Store&quot;) {
<span class="line-modified">358         // FIXME: Implement this.</span>
<span class="line-modified">359         CRASH();</span>


























































360     }
361 
362     if (nativeFunctionDeclaration.name() == &quot;GatherAlpha&quot;) {
<span class="line-modified">363         // FIXME: Implement this.</span>
<span class="line-modified">364         CRASH();</span>
365     }
366 
367     if (nativeFunctionDeclaration.name() == &quot;GatherBlue&quot;) {
<span class="line-modified">368         // FIXME: Implement this.</span>
<span class="line-modified">369         CRASH();</span>
370     }
371 
372     if (nativeFunctionDeclaration.name() == &quot;GatherCmp&quot;) {
<span class="line-modified">373         // FIXME: Implement this.</span>
<span class="line-modified">374         CRASH();</span>
375     }
376 
377     if (nativeFunctionDeclaration.name() == &quot;GatherCmpRed&quot;) {
<span class="line-modified">378         // FIXME: Implement this.</span>
<span class="line-modified">379         CRASH();</span>
380     }
381 
382     if (nativeFunctionDeclaration.name() == &quot;GatherGreen&quot;) {
<span class="line-modified">383         // FIXME: Implement this.</span>
<span class="line-modified">384         CRASH();</span>
385     }
386 
<span class="line-removed">387     // FIXME: Add all the functions that the compiler generated.</span>
<span class="line-removed">388 </span>
389     ASSERT_NOT_REACHED();
<span class="line-removed">390     return String();</span>
391 }
392 
393 } // namespace Metal
394 
395 } // namespace WHLSL
396 
397 } // namespace WebCore
398 
399 #endif
</pre>
</td>
<td>
<hr />
<pre>
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;WHLSLNativeFunctionWriter.h&quot;
 28 
 29 #if ENABLE(WEBGPU)
 30 
<span class="line-added"> 31 #include &quot;NotImplemented.h&quot;</span>
 32 #include &quot;WHLSLAddressSpace.h&quot;
<span class="line-added"> 33 #include &quot;WHLSLArrayType.h&quot;</span>
<span class="line-added"> 34 #include &quot;WHLSLEnumerationDefinition.h&quot;</span>
<span class="line-added"> 35 #include &quot;WHLSLInferTypes.h&quot;</span>
<span class="line-added"> 36 #include &quot;WHLSLIntrinsics.h&quot;</span>
 37 #include &quot;WHLSLNamedType.h&quot;
 38 #include &quot;WHLSLNativeFunctionDeclaration.h&quot;
 39 #include &quot;WHLSLNativeTypeDeclaration.h&quot;
 40 #include &quot;WHLSLPointerType.h&quot;
<span class="line-added"> 41 #include &quot;WHLSLStructureDefinition.h&quot;</span>
<span class="line-added"> 42 #include &quot;WHLSLTypeDefinition.h&quot;</span>
 43 #include &quot;WHLSLTypeNamer.h&quot;
 44 #include &quot;WHLSLUnnamedType.h&quot;
 45 #include &quot;WHLSLVariableDeclaration.h&quot;
 46 #include &lt;wtf/text/StringBuilder.h&gt;
 47 
 48 namespace WebCore {
 49 
 50 namespace WHLSL {
 51 
 52 namespace Metal {
 53 









 54 static String mapFunctionName(String&amp; functionName)
 55 {
 56     if (functionName == &quot;ddx&quot;)
 57         return &quot;dfdx&quot;_str;
 58     if (functionName == &quot;ddy&quot;)
 59         return &quot;dfdy&quot;_str;
 60     if (functionName == &quot;asint&quot;)
 61         return &quot;as_type&lt;int32_t&gt;&quot;_str;
 62     if (functionName == &quot;asuint&quot;)
 63         return &quot;as_type&lt;uint32_t&gt;&quot;_str;
 64     if (functionName == &quot;asfloat&quot;)
 65         return &quot;as_type&lt;float&gt;&quot;_str;
 66     return functionName;
 67 }
 68 















 69 static String atomicName(String input)
 70 {
 71     if (input == &quot;Add&quot;)
 72         return &quot;fetch_add&quot;_str;
 73     if (input == &quot;And&quot;)
 74         return &quot;fetch_and&quot;_str;
 75     if (input == &quot;Exchange&quot;)
 76         return &quot;exchange&quot;_str;
 77     if (input == &quot;Max&quot;)
 78         return &quot;fetch_max&quot;_str;
 79     if (input == &quot;Min&quot;)
 80         return &quot;fetch_min&quot;_str;
 81     if (input == &quot;Or&quot;)
 82         return &quot;fetch_or&quot;_str;
 83     ASSERT(input == &quot;Xor&quot;);
 84         return &quot;fetch_xor&quot;_str;
 85 }
 86 
<span class="line-modified"> 87 static int vectorLength(AST::NativeTypeDeclaration&amp; nativeTypeDeclaration)</span>
<span class="line-added"> 88 {</span>
<span class="line-added"> 89     int vectorLength = 1;</span>
<span class="line-added"> 90     if (!nativeTypeDeclaration.typeArguments().isEmpty()) {</span>
<span class="line-added"> 91         ASSERT(nativeTypeDeclaration.typeArguments().size() == 2);</span>
<span class="line-added"> 92         ASSERT(WTF::holds_alternative&lt;AST::ConstantExpression&gt;(nativeTypeDeclaration.typeArguments()[1]));</span>
<span class="line-added"> 93         vectorLength = WTF::get&lt;AST::ConstantExpression&gt;(nativeTypeDeclaration.typeArguments()[1]).integerLiteral().value();</span>
<span class="line-added"> 94     }</span>
<span class="line-added"> 95     return vectorLength;</span>
<span class="line-added"> 96 }</span>
<span class="line-added"> 97 </span>
<span class="line-added"> 98 static AST::NamedType&amp; vectorInnerType(AST::NativeTypeDeclaration&amp; nativeTypeDeclaration)</span>
<span class="line-added"> 99 {</span>
<span class="line-added">100     if (nativeTypeDeclaration.typeArguments().isEmpty())</span>
<span class="line-added">101         return nativeTypeDeclaration;</span>
<span class="line-added">102 </span>
<span class="line-added">103     ASSERT(nativeTypeDeclaration.typeArguments().size() == 2);</span>
<span class="line-added">104     ASSERT(WTF::holds_alternative&lt;Ref&lt;AST::TypeReference&gt;&gt;(nativeTypeDeclaration.typeArguments()[0]));</span>
<span class="line-added">105     return WTF::get&lt;Ref&lt;AST::TypeReference&gt;&gt;(nativeTypeDeclaration.typeArguments()[0])-&gt;resolvedType();</span>
<span class="line-added">106 }</span>
<span class="line-added">107 </span>
<span class="line-added">108 static const char* vectorSuffix(int vectorLength)</span>
<span class="line-added">109 {</span>
<span class="line-added">110     switch (vectorLength) {</span>
<span class="line-added">111     case 1:</span>
<span class="line-added">112         return &quot;&quot;;</span>
<span class="line-added">113     case 2:</span>
<span class="line-added">114         return &quot;2&quot;;</span>
<span class="line-added">115     case 3:</span>
<span class="line-added">116         return &quot;3&quot;;</span>
<span class="line-added">117     default:</span>
<span class="line-added">118         ASSERT(vectorLength == 4);</span>
<span class="line-added">119         return &quot;4&quot;;</span>
<span class="line-added">120     }</span>
<span class="line-added">121 }</span>
<span class="line-added">122 </span>
<span class="line-added">123 void inlineNativeFunction(StringBuilder&amp; stringBuilder, AST::NativeFunctionDeclaration&amp; nativeFunctionDeclaration, MangledVariableName returnName, const Vector&lt;MangledVariableName&gt;&amp; args, Intrinsics&amp; intrinsics, TypeNamer&amp; typeNamer, std::function&lt;MangledVariableName()&gt;&amp;&amp; generateNextVariableName, Indentation&lt;4&gt; indent)</span>
124 {
<span class="line-modified">125     auto asMatrixType = [&amp;] (AST::UnnamedType&amp; unnamedType) -&gt; AST::NativeTypeDeclaration* {</span>
<span class="line-added">126         auto&amp; realType = unnamedType.unifyNode();</span>
<span class="line-added">127         if (!realType.isNativeTypeDeclaration())</span>
<span class="line-added">128             return nullptr;</span>
<span class="line-added">129 </span>
<span class="line-added">130         auto&amp; maybeMatrixType = downcast&lt;AST::NativeTypeDeclaration&gt;(realType);</span>
<span class="line-added">131         if (maybeMatrixType.isMatrix())</span>
<span class="line-added">132             return &amp;maybeMatrixType;</span>
<span class="line-added">133 </span>
<span class="line-added">134         return nullptr;</span>
<span class="line-added">135     };</span>
<span class="line-added">136 </span>
137     if (nativeFunctionDeclaration.isCast()) {
<span class="line-added">138         auto&amp; returnType = nativeFunctionDeclaration.type();</span>
<span class="line-added">139         auto metalReturnTypeName = typeNamer.mangledNameForType(returnType);</span>
<span class="line-added">140 </span>
<span class="line-added">141         if (!nativeFunctionDeclaration.parameters().size()) {</span>
<span class="line-added">142             stringBuilder.append(indent, returnName, &quot; = { };\n&quot;);</span>
<span class="line-added">143             return;</span>
<span class="line-added">144         }</span>
<span class="line-added">145 </span>
<span class="line-added">146         if (nativeFunctionDeclaration.parameters().size() == 1) {</span>
<span class="line-added">147             auto&amp; parameterType = *nativeFunctionDeclaration.parameters()[0]-&gt;type();</span>
<span class="line-added">148             auto metalParameterTypeName = typeNamer.mangledNameForType(parameterType);</span>
<span class="line-added">149 </span>
<span class="line-added">150             auto isEnumerationDefinition = [] (auto&amp; type) {</span>
<span class="line-added">151                 return is&lt;AST::NamedType&gt;(type) &amp;&amp; is&lt;AST::EnumerationDefinition&gt;(downcast&lt;AST::NamedType&gt;(type));</span>
<span class="line-added">152             };</span>
<span class="line-added">153             auto&amp; unifiedReturnType = returnType.unifyNode();</span>
<span class="line-added">154             if (isEnumerationDefinition(unifiedReturnType) &amp;&amp; !isEnumerationDefinition(parameterType.unifyNode())) {</span>
<span class="line-added">155                 auto variableName = generateNextVariableName();</span>
<span class="line-added">156                 stringBuilder.append(indent, metalParameterTypeName, &#39; &#39;, variableName, &quot; = &quot;, args[0], &quot;;\n&quot;);</span>
<span class="line-added">157                 auto&amp; enumerationDefinition = downcast&lt;AST::EnumerationDefinition&gt;(downcast&lt;AST::NamedType&gt;(unifiedReturnType));</span>
<span class="line-added">158                 stringBuilder.append(indent, &quot;switch (&quot;, variableName, &quot;) {\n&quot;);</span>
<span class="line-added">159                 {</span>
<span class="line-added">160                     IndentationScope switchScope(indent);</span>
<span class="line-added">161                     bool hasZeroCase = false;</span>
<span class="line-added">162                     for (auto&amp; member : enumerationDefinition.enumerationMembers()) {</span>
<span class="line-added">163                         hasZeroCase |= !member.get().value();</span>
<span class="line-added">164                         stringBuilder.append(</span>
<span class="line-added">165                             indent, &quot;case &quot;, member.get().value(), &quot;:\n&quot;,</span>
<span class="line-added">166                             indent, &quot;    break;\n&quot;);</span>
<span class="line-added">167                     }</span>
<span class="line-added">168                     ASSERT_UNUSED(hasZeroCase, hasZeroCase);</span>
<span class="line-added">169                     stringBuilder.append(</span>
<span class="line-added">170                         indent, &quot;default:\n&quot;,</span>
<span class="line-added">171                         indent, &quot;    &quot;, variableName, &quot; = 0;\n&quot;,</span>
<span class="line-added">172                         indent, &quot;    break;\n&quot;,</span>
<span class="line-added">173                         indent, &quot;}\n&quot;);</span>
<span class="line-added">174                 }</span>
<span class="line-added">175                 stringBuilder.append(indent, returnName, &quot; = static_cast&lt;&quot;, metalReturnTypeName, &quot;&gt;(&quot;, variableName, &quot;);\n&quot;);</span>
<span class="line-added">176             } else</span>
<span class="line-added">177                 stringBuilder.append(indent, returnName, &quot; = static_cast&lt;&quot;, metalReturnTypeName, &quot;&gt;(&quot;, args[0], &quot;);\n&quot;);</span>
<span class="line-added">178 </span>
<span class="line-added">179             return;</span>
<span class="line-added">180         }</span>
<span class="line-added">181 </span>
<span class="line-added">182         if (auto* matrixType = asMatrixType(returnType)) {</span>
<span class="line-added">183             unsigned numRows = matrixType-&gt;numberOfMatrixRows();</span>
<span class="line-added">184             unsigned numColumns = matrixType-&gt;numberOfMatrixColumns();</span>
<span class="line-added">185             RELEASE_ASSERT(nativeFunctionDeclaration.parameters().size() == numRows || nativeFunctionDeclaration.parameters().size() == numRows * numColumns);</span>
<span class="line-added">186 </span>
<span class="line-added">187             auto variableName = generateNextVariableName();</span>
<span class="line-added">188 </span>
<span class="line-added">189             stringBuilder.append(indent, metalReturnTypeName, &#39; &#39;, variableName, &quot;;\n&quot;);</span>
<span class="line-added">190 </span>
<span class="line-added">191             // We need to abide by the memory layout we use for matrices here.</span>
<span class="line-added">192             if (nativeFunctionDeclaration.parameters().size() == numRows) {</span>
<span class="line-added">193                 // operator matrixMxN (vectorN, ..., vectorN)</span>
<span class="line-added">194                 for (unsigned i = 0; i &lt; numRows; ++i) {</span>
<span class="line-added">195                     for (unsigned j = 0; j &lt; numColumns; ++j)</span>
<span class="line-added">196                         stringBuilder.append(indent, variableName, &quot;[&quot;, j * numRows + i, &quot;] = &quot;, args[i], &quot;[&quot;, j, &quot;];\n&quot;);</span>
<span class="line-added">197                 }</span>
<span class="line-added">198             } else {</span>
<span class="line-added">199                 // operator matrixMxN (scalar, ..., scalar)</span>
<span class="line-added">200                 unsigned index = 0;</span>
<span class="line-added">201                 for (unsigned i = 0; i &lt; numRows; ++i) {</span>
<span class="line-added">202                     for (unsigned j = 0; j &lt; numColumns; ++j) {</span>
<span class="line-added">203                         stringBuilder.append(indent, variableName, &#39;[&#39;, j * numRows + i, &quot;] = &quot;, args[index], &quot;;\n&quot;);</span>
<span class="line-added">204                         ++index;</span>
<span class="line-added">205                     }</span>
<span class="line-added">206                 }</span>
<span class="line-added">207             }</span>
<span class="line-added">208 </span>
<span class="line-added">209             stringBuilder.append(indent, returnName, &quot; = &quot;, variableName, &quot;;\n&quot;);</span>
<span class="line-added">210             return;</span>
<span class="line-added">211         }</span>
<span class="line-added">212 </span>
<span class="line-added">213         stringBuilder.append(indent, returnName, &quot; = &quot;, metalReturnTypeName, &quot;(&quot;);</span>
<span class="line-added">214         for (unsigned i = 0; i &lt; nativeFunctionDeclaration.parameters().size(); ++i) {</span>
<span class="line-added">215             if (i &gt; 0)</span>
<span class="line-added">216                 stringBuilder.append(&quot;, &quot;);</span>
<span class="line-added">217             stringBuilder.append(args[i]);</span>
<span class="line-added">218         }</span>
<span class="line-added">219         stringBuilder.append(&quot;);\n&quot;);</span>
<span class="line-added">220         return;</span>
<span class="line-added">221     }</span>
<span class="line-added">222 </span>
<span class="line-added">223     // FIXME: https://bugs.webkit.org/show_bug.cgi?id=198077 Authors can make a struct field named &quot;length&quot; too. Autogenerated getters for those shouldn&#39;t take this codepath.</span>
<span class="line-added">224     if (nativeFunctionDeclaration.name() == &quot;operator.length&quot;) {</span>
<span class="line-added">225         ASSERT_UNUSED(intrinsics, matches(nativeFunctionDeclaration.type(), intrinsics.uintType()));</span>
226         ASSERT(nativeFunctionDeclaration.parameters().size() == 1);
<span class="line-modified">227         auto&amp; parameterType = nativeFunctionDeclaration.parameters()[0]-&gt;type()-&gt;unifyNode();</span>
<span class="line-modified">228         auto&amp; unnamedParameterType = downcast&lt;AST::UnnamedType&gt;(parameterType);</span>
<span class="line-modified">229         if (is&lt;AST::ArrayType&gt;(unnamedParameterType)) {</span>
<span class="line-modified">230             auto&amp; arrayParameterType = downcast&lt;AST::ArrayType&gt;(unnamedParameterType);</span>
<span class="line-modified">231             stringBuilder.append(</span>
<span class="line-modified">232                 indent, returnName, &quot; = &quot;, arrayParameterType.numElements(), &quot;;\n&quot;);</span>
<span class="line-modified">233             return;</span>
234         }
235 
<span class="line-modified">236         ASSERT(is&lt;AST::ArrayReferenceType&gt;(unnamedParameterType));</span>
<span class="line-modified">237         stringBuilder.append(</span>
<span class="line-modified">238             indent, returnName, &quot; = &quot;, args[0], &quot;.length;\n&quot;);</span>
<span class="line-modified">239         return;</span>
240     }
241 
242     if (nativeFunctionDeclaration.name().startsWith(&quot;operator.&quot;_str)) {
<span class="line-added">243         auto appendMangledFieldName = [&amp;] (const String&amp; fieldName) {</span>
<span class="line-added">244             auto&amp; unifyNode = nativeFunctionDeclaration.parameters()[0]-&gt;type()-&gt;unifyNode();</span>
<span class="line-added">245             auto&amp; namedType = downcast&lt;AST::NamedType&gt;(unifyNode);</span>
<span class="line-added">246             if (is&lt;AST::StructureDefinition&gt;(namedType)) {</span>
<span class="line-added">247                 auto&amp; structureDefinition = downcast&lt;AST::StructureDefinition&gt;(namedType);</span>
<span class="line-added">248                 auto* structureElement = structureDefinition.find(fieldName);</span>
<span class="line-added">249                 ASSERT(structureElement);</span>
<span class="line-added">250                 stringBuilder.append(typeNamer.mangledNameForStructureElement(*structureElement));</span>
<span class="line-added">251                 return;</span>
<span class="line-added">252             }</span>
<span class="line-added">253             ASSERT(is&lt;AST::NativeTypeDeclaration&gt;(namedType));</span>
<span class="line-added">254             stringBuilder.append(fieldName);</span>
<span class="line-added">255         };</span>
<span class="line-added">256 </span>
257         if (nativeFunctionDeclaration.name().endsWith(&quot;=&quot;)) {
258             ASSERT(nativeFunctionDeclaration.parameters().size() == 2);



259             auto fieldName = nativeFunctionDeclaration.name().substring(&quot;operator.&quot;_str.length());
260             fieldName = fieldName.substring(0, fieldName.length() - 1);
<span class="line-modified">261 </span>
<span class="line-modified">262             stringBuilder.append(</span>
<span class="line-modified">263                 indent, returnName, &quot; = &quot;, args[0], &quot;;\n&quot;,</span>
<span class="line-modified">264                 indent, returnName, &#39;.&#39;);</span>
<span class="line-modified">265             appendMangledFieldName(fieldName);</span>
<span class="line-added">266             stringBuilder.append(&quot; = &quot;, args[1], &quot;;\n&quot;);</span>
<span class="line-added">267 </span>
<span class="line-added">268             return;</span>
269         }
270 
271         ASSERT(nativeFunctionDeclaration.parameters().size() == 1);
<span class="line-modified">272         auto fieldName = nativeFunctionDeclaration.name().substring(&quot;operator.&quot;_str.length());</span>
<span class="line-modified">273         stringBuilder.append(</span>
<span class="line-modified">274             indent, returnName, &quot; = &quot;, args[0], &#39;.&#39;);</span>
<span class="line-modified">275         appendMangledFieldName(fieldName);</span>
<span class="line-modified">276         stringBuilder.append(&quot;;\n&quot;);</span>
<span class="line-modified">277         return;</span>
<span class="line-added">278     }</span>
<span class="line-added">279 </span>
<span class="line-added">280     if (nativeFunctionDeclaration.name().startsWith(&quot;operator&amp;.&quot;_str)) {</span>
<span class="line-added">281         ASSERT(nativeFunctionDeclaration.parameters().size() == 1);</span>
<span class="line-added">282         auto fieldName = nativeFunctionDeclaration.name().substring(&quot;operator&amp;.&quot;_str.length());</span>
<span class="line-added">283 </span>
<span class="line-added">284         stringBuilder.append(</span>
<span class="line-added">285             indent, returnName, &quot; = &quot;, args[0], &quot; ? &amp;(&quot;, args[0], &quot;-&gt;&quot;);</span>
286 
<span class="line-added">287         auto&amp; unnamedType = *nativeFunctionDeclaration.parameters()[0]-&gt;type();</span>
<span class="line-added">288         auto&amp; unifyNode = downcast&lt;AST::PointerType&gt;(unnamedType).elementType().unifyNode();</span>
<span class="line-added">289         auto&amp; namedType = downcast&lt;AST::NamedType&gt;(unifyNode);</span>
<span class="line-added">290         if (is&lt;AST::StructureDefinition&gt;(namedType)) {</span>
<span class="line-added">291             auto&amp; structureDefinition = downcast&lt;AST::StructureDefinition&gt;(namedType);</span>
<span class="line-added">292             auto* structureElement = structureDefinition.find(fieldName);</span>
<span class="line-added">293             ASSERT(structureElement);</span>
<span class="line-added">294             stringBuilder.append(typeNamer.mangledNameForStructureElement(*structureElement));</span>
<span class="line-added">295         } else</span>
<span class="line-added">296             stringBuilder.append(fieldName);</span>
<span class="line-added">297 </span>
<span class="line-added">298         stringBuilder.append(&quot;) : nullptr;\n&quot;);</span>
<span class="line-added">299 </span>
<span class="line-added">300         return;</span>
301     }
302 
<span class="line-added">303     if (nativeFunctionDeclaration.name() == &quot;operator&amp;[]&quot;) {</span>
<span class="line-added">304         ASSERT(nativeFunctionDeclaration.parameters().size() == 2);</span>
<span class="line-added">305         ASSERT(is&lt;AST::ArrayReferenceType&gt;(*nativeFunctionDeclaration.parameters()[0]-&gt;type()));</span>
<span class="line-added">306 </span>
<span class="line-added">307         stringBuilder.append(</span>
<span class="line-added">308             indent, returnName, &quot; = (&quot;, args[1], &quot; &lt; &quot;, args[0], &quot;.length) ? &quot;, &quot; &amp;(&quot;, args[0], &quot;.pointer[&quot;, args[1], &quot;]) : nullptr;\n&quot;);</span>
<span class="line-added">309 </span>
<span class="line-added">310         return;</span>
<span class="line-added">311     }</span>
<span class="line-added">312 </span>
<span class="line-added">313     auto vectorSize = [&amp;] () -&gt; unsigned {</span>
<span class="line-added">314         auto&amp; typeReference = downcast&lt;AST::TypeReference&gt;(*nativeFunctionDeclaration.parameters()[0]-&gt;type());</span>
<span class="line-added">315         auto&amp; vectorType = downcast&lt;AST::NativeTypeDeclaration&gt;(downcast&lt;AST::TypeReference&gt;(downcast&lt;AST::TypeDefinition&gt;(typeReference.resolvedType()).type()).resolvedType());</span>
<span class="line-added">316         ASSERT(vectorType.name() == &quot;vector&quot;);</span>
<span class="line-added">317         ASSERT(vectorType.typeArguments().size() == 2);</span>
<span class="line-added">318         return WTF::get&lt;AST::ConstantExpression&gt;(vectorType.typeArguments()[1]).integerLiteral().value();</span>
<span class="line-added">319     };</span>
<span class="line-added">320 </span>
<span class="line-added">321     auto getMatrixType = [&amp;] () -&gt; AST::NativeTypeDeclaration&amp; {</span>
<span class="line-added">322         auto&amp; typeReference = downcast&lt;AST::TypeReference&gt;(*nativeFunctionDeclaration.parameters()[0]-&gt;type());</span>
<span class="line-added">323         auto&amp; result = downcast&lt;AST::NativeTypeDeclaration&gt;(downcast&lt;AST::TypeReference&gt;(downcast&lt;AST::TypeDefinition&gt;(typeReference.resolvedType()).type()).resolvedType());</span>
<span class="line-added">324         ASSERT(result.isMatrix());</span>
<span class="line-added">325         return result;</span>
<span class="line-added">326     };</span>
<span class="line-added">327 </span>
328     if (nativeFunctionDeclaration.name() == &quot;operator[]&quot;) {
329         ASSERT(nativeFunctionDeclaration.parameters().size() == 2);
<span class="line-modified">330         auto&amp; typeReference = downcast&lt;AST::TypeReference&gt;(*nativeFunctionDeclaration.parameters()[0]-&gt;type());</span>
<span class="line-modified">331         size_t numTypeArguments = downcast&lt;AST::NativeTypeDeclaration&gt;(downcast&lt;AST::TypeReference&gt;(downcast&lt;AST::TypeDefinition&gt;(typeReference.resolvedType()).type()).resolvedType()).typeArguments().size();</span>
<span class="line-modified">332         if (numTypeArguments == 3) {</span>
<span class="line-modified">333             auto metalReturnName = typeNamer.mangledNameForType(nativeFunctionDeclaration.type());</span>
<span class="line-modified">334 </span>
<span class="line-modified">335             unsigned numberOfRows = getMatrixType().numberOfMatrixRows();</span>
<span class="line-modified">336             unsigned numberOfColumns = getMatrixType().numberOfMatrixColumns();</span>
<span class="line-added">337 </span>
<span class="line-added">338             stringBuilder.append(indent, &quot;do {\n&quot;);</span>
<span class="line-added">339             {</span>
<span class="line-added">340                 IndentationScope scope(indent);</span>
<span class="line-added">341 </span>
<span class="line-added">342                 stringBuilder.append(</span>
<span class="line-added">343                     indent, metalReturnName, &quot; result;\n&quot;,</span>
<span class="line-added">344                     indent, &quot;if (&quot;, args[1], &quot; &gt;= &quot;, numberOfRows, &quot;) {\n&quot;,</span>
<span class="line-added">345                     indent, &quot;    &quot;, returnName, &quot; = &quot;, metalReturnName, &quot;(0);\n&quot;,</span>
<span class="line-added">346                     indent, &quot;    break;\n&quot;,</span>
<span class="line-added">347                     indent, &quot;}\n&quot;,</span>
<span class="line-added">348                     indent, &quot;result[0] = &quot;, args[0], &#39;[&#39;, args[1], &quot;];\n&quot;,</span>
<span class="line-added">349                     indent, &quot;result[1] = &quot;, args[0], &#39;[&#39;, args[1], &quot; + &quot;, numberOfRows, &quot;];\n&quot;);</span>
<span class="line-added">350 </span>
<span class="line-added">351                 if (numberOfColumns &gt;= 3)</span>
<span class="line-added">352                     stringBuilder.append(indent, &quot;result[2] = &quot;, args[0], &#39;[&#39;, args[1], &quot; + &quot;, numberOfRows * 2, &quot;];\n&quot;);</span>
<span class="line-added">353                 if (numberOfColumns &gt;= 4)</span>
<span class="line-added">354                     stringBuilder.append(indent, &quot;result[3] = &quot;, args[0], &#39;[&#39;, args[1], &quot; + &quot;, numberOfRows * 3, &quot;];\n&quot;);</span>
<span class="line-added">355 </span>
<span class="line-added">356                 stringBuilder.append(indent, returnName, &quot; = result;\n&quot;);</span>
<span class="line-added">357             }</span>
<span class="line-added">358             stringBuilder.append(&quot;} while (0);\n&quot;);</span>
<span class="line-added">359         } else {</span>
<span class="line-added">360             RELEASE_ASSERT(numTypeArguments == 2);</span>
<span class="line-added">361             unsigned numElements = vectorSize();</span>
<span class="line-added">362 </span>
<span class="line-added">363             auto metalReturnName = typeNamer.mangledNameForType(nativeFunctionDeclaration.type());</span>
<span class="line-added">364 </span>
<span class="line-added">365             stringBuilder.append(indent, &quot;do {\n&quot;);</span>
<span class="line-added">366             {</span>
<span class="line-added">367                 IndentationScope scope(indent);</span>
<span class="line-added">368                 stringBuilder.append(</span>
<span class="line-added">369                     indent, metalReturnName, &quot; result;\n&quot;,</span>
<span class="line-added">370                     indent, &quot;if (&quot;, args[1], &quot; &gt;= &quot;, numElements, &quot;) {\n&quot;,</span>
<span class="line-added">371                     indent, &quot;    &quot;, returnName, &quot; = &quot;, metalReturnName, &quot;(0);\n&quot;,</span>
<span class="line-added">372                     indent, &quot;    break;\n&quot;,</span>
<span class="line-added">373                     indent, &quot;}\n&quot;,</span>
<span class="line-added">374                     indent, &quot;result = &quot;, args[0], &quot;[&quot;, args[1], &quot;];\n&quot;,</span>
<span class="line-added">375                     indent, returnName, &quot; = result;\n&quot;);</span>
<span class="line-added">376             }</span>
<span class="line-added">377             stringBuilder.append(indent, &quot;} while (0);\n&quot;);</span>
<span class="line-added">378         }</span>
<span class="line-added">379 </span>
<span class="line-added">380         return;</span>
381     }
382 
383     if (nativeFunctionDeclaration.name() == &quot;operator[]=&quot;) {
<span class="line-modified">384         auto&amp; typeReference = downcast&lt;AST::TypeReference&gt;(*nativeFunctionDeclaration.parameters()[0]-&gt;type());</span>
<span class="line-modified">385         size_t numTypeArguments = downcast&lt;AST::NativeTypeDeclaration&gt;(downcast&lt;AST::TypeReference&gt;(downcast&lt;AST::TypeDefinition&gt;(typeReference.resolvedType()).type()).resolvedType()).typeArguments().size();</span>
<span class="line-modified">386         if (numTypeArguments == 3) {</span>
<span class="line-modified">387             ASSERT(nativeFunctionDeclaration.parameters().size() == 3);</span>
<span class="line-modified">388             auto metalParameter2Name = typeNamer.mangledNameForType(*nativeFunctionDeclaration.parameters()[1]-&gt;type());</span>
<span class="line-modified">389             auto metalReturnName = typeNamer.mangledNameForType(nativeFunctionDeclaration.type());</span>
<span class="line-modified">390 </span>
<span class="line-modified">391             unsigned numberOfRows = getMatrixType().numberOfMatrixRows();</span>
<span class="line-modified">392             unsigned numberOfColumns = getMatrixType().numberOfMatrixColumns();</span>
<span class="line-modified">393 </span>
<span class="line-added">394             stringBuilder.append(indent, &quot;do {\n&quot;);</span>
<span class="line-added">395             {</span>
<span class="line-added">396                 IndentationScope scope(indent);</span>
<span class="line-added">397 </span>
<span class="line-added">398                 stringBuilder.append(</span>
<span class="line-added">399                     indent, metalReturnName, &quot; m = &quot;, args[0], &quot;;\n&quot;,</span>
<span class="line-added">400                     indent, metalParameter2Name, &quot; i = &quot;, args[1], &quot;;\n&quot;,</span>
<span class="line-added">401                     indent, &quot;if (i &gt;= &quot;, numberOfRows, &quot;) {\n&quot;,</span>
<span class="line-added">402                     indent, &quot;    &quot;, returnName, &quot; = m;\n&quot;,</span>
<span class="line-added">403                     indent, &quot;    break;\n&quot;,</span>
<span class="line-added">404                     indent, &quot;}\n&quot;,</span>
<span class="line-added">405                     indent, &quot;m[i] = &quot;, args[2], &quot;[0];\n&quot;,</span>
<span class="line-added">406                     indent, &quot;m[i + &quot;, numberOfRows, &quot;] = &quot;, args[2], &quot;[1];\n&quot;);</span>
<span class="line-added">407                 if (numberOfColumns &gt;= 3)</span>
<span class="line-added">408                     stringBuilder.append(indent, &quot;m[i + &quot;, numberOfRows * 2, &quot;] = &quot;, args[2], &quot;[2];\n&quot;);</span>
<span class="line-added">409                 if (numberOfColumns &gt;= 4)</span>
<span class="line-added">410                     stringBuilder.append(indent, &quot;m[i + &quot;, numberOfRows * 3, &quot;] = &quot;, args[2], &quot;[3];\n&quot;);</span>
<span class="line-added">411                 stringBuilder.append(indent, returnName, &quot; = m;\n&quot;);</span>
<span class="line-added">412             }</span>
<span class="line-added">413 </span>
<span class="line-added">414             stringBuilder.append(indent, &quot;} while(0);\n&quot;);</span>
<span class="line-added">415         } else {</span>
<span class="line-added">416             RELEASE_ASSERT(numTypeArguments == 2);</span>
<span class="line-added">417 </span>
<span class="line-added">418             ASSERT(nativeFunctionDeclaration.parameters().size() == 3);</span>
<span class="line-added">419             auto metalParameter2Name = typeNamer.mangledNameForType(*nativeFunctionDeclaration.parameters()[1]-&gt;type());</span>
<span class="line-added">420             auto metalReturnName = typeNamer.mangledNameForType(nativeFunctionDeclaration.type());</span>
<span class="line-added">421 </span>
<span class="line-added">422             unsigned numElements = vectorSize();</span>
<span class="line-added">423 </span>
<span class="line-added">424             stringBuilder.append(indent, &quot;do {\n&quot;);</span>
<span class="line-added">425             {</span>
<span class="line-added">426                 IndentationScope scope(indent);</span>
<span class="line-added">427 </span>
<span class="line-added">428                 stringBuilder.append(</span>
<span class="line-added">429                     indent, metalReturnName, &quot; v = &quot;, args[0], &quot;;\n&quot;,</span>
<span class="line-added">430                     indent, metalParameter2Name, &quot; i = &quot;, args[1], &quot;;\n&quot;,</span>
<span class="line-added">431                     indent, &quot;if (i &gt;= &quot;, numElements, &quot;) {\n&quot;,</span>
<span class="line-added">432                     indent, &quot;    &quot;, returnName, &quot; = v;\n&quot;,</span>
<span class="line-added">433                     indent, &quot;    break;\n&quot;,</span>
<span class="line-added">434                     indent, &quot;}\n&quot;,</span>
<span class="line-added">435                     indent, &quot;v[i] = &quot;, args[2], &quot;;\n&quot;,</span>
<span class="line-added">436                     indent, returnName, &quot; = v;\n&quot;);</span>
<span class="line-added">437             }</span>
<span class="line-added">438             stringBuilder.append(indent, &quot;} while(0);\n&quot;);</span>
<span class="line-added">439         }</span>
<span class="line-added">440 </span>
<span class="line-added">441         return;</span>
442     }
443 
444     if (nativeFunctionDeclaration.isOperator()) {
<span class="line-added">445         auto operatorName = nativeFunctionDeclaration.name().substring(&quot;operator&quot;_str.length());</span>
<span class="line-added">446         auto metalReturnType = typeNamer.mangledNameForType(nativeFunctionDeclaration.type());</span>
447         if (nativeFunctionDeclaration.parameters().size() == 1) {
<span class="line-modified">448             if (auto* matrixType = asMatrixType(nativeFunctionDeclaration.type())) {</span>
<span class="line-modified">449                 stringBuilder.append(indent, &quot;{\n&quot;);</span>
<span class="line-modified">450                 {</span>
<span class="line-modified">451                     IndentationScope scope(indent);</span>
<span class="line-modified">452                     stringBuilder.append(</span>
<span class="line-modified">453                         indent, metalReturnType, &quot; x = &quot;, args[0], &quot;;\n&quot;,</span>
<span class="line-modified">454                         indent, &quot;for (size_t i = 0; i &lt; x.size(); ++i)\n&quot;,</span>
<span class="line-added">455                         indent, &quot;    x[i] = &quot;, operatorName, &quot;x[i];\n&quot;,</span>
<span class="line-added">456                         indent, returnName, &quot; = x;\n&quot;);</span>
<span class="line-added">457                 }</span>
<span class="line-added">458                 stringBuilder.append(indent, &quot;}\n&quot;);</span>
<span class="line-added">459             } else {</span>
<span class="line-added">460                 stringBuilder.append(indent, &quot;{\n&quot;);</span>
<span class="line-added">461                 {</span>
<span class="line-added">462                     IndentationScope scope(indent);</span>
<span class="line-added">463                     stringBuilder.append(</span>
<span class="line-added">464                         indent, metalReturnType, &quot; x = &quot;, args[0], &quot;;\n&quot;,</span>
<span class="line-added">465                         indent, returnName, &quot; = &quot;, operatorName, &quot;x;\n&quot;);</span>
<span class="line-added">466                 }</span>
<span class="line-added">467                 stringBuilder.append(indent, &quot;}\n&quot;);</span>
<span class="line-added">468             }</span>
<span class="line-added">469             return;</span>
470         }
471 
472         ASSERT(nativeFunctionDeclaration.parameters().size() == 2);
<span class="line-modified">473         if (auto* leftMatrix = asMatrixType(*nativeFunctionDeclaration.parameters()[0]-&gt;type())) {</span>
<span class="line-modified">474             if (auto* rightMatrix = asMatrixType(*nativeFunctionDeclaration.parameters()[1]-&gt;type())) {</span>
<span class="line-modified">475                 // matrix &lt;op&gt; matrix</span>
<span class="line-modified">476                 stringBuilder.append(indent, &quot;{\n&quot;);</span>
<span class="line-modified">477                 {</span>
<span class="line-modified">478                     IndentationScope scope(indent);</span>
<span class="line-modified">479                     stringBuilder.append(</span>
<span class="line-modified">480                         indent, metalReturnType, &quot; x;\n&quot;,</span>
<span class="line-added">481                         indent, &quot;for (size_t i = 0; i &lt; x.size(); ++i)\n&quot;,</span>
<span class="line-added">482                         indent, &quot;    x[i] = &quot;, args[0], &quot;[i] &quot;, operatorName, &#39; &#39;, args[1], &quot;[i];\n&quot;,</span>
<span class="line-added">483                         indent, returnName, &quot; = x;\n&quot;);</span>
<span class="line-added">484                 }</span>
<span class="line-added">485                 stringBuilder.append(indent, &quot;}\n&quot;);</span>
<span class="line-added">486             } else {</span>
<span class="line-added">487                 // matrix &lt;op&gt; scalar</span>
<span class="line-added">488                 stringBuilder.append(indent, &quot;{\n&quot;);</span>
<span class="line-added">489                 {</span>
<span class="line-added">490                     IndentationScope scope(indent);</span>
<span class="line-added">491                     stringBuilder.append(</span>
<span class="line-added">492                         indent, metalReturnType, &quot; x;\n&quot;,</span>
<span class="line-added">493                         indent, &quot;for (size_t i = 0; i &lt; x.size(); ++i)\n&quot;,</span>
<span class="line-added">494                         indent, &quot;    x[i] = &quot;, args[0], &quot;[i] &quot;, operatorName, &#39; &#39;, args[1], &quot;;\n&quot;,</span>
<span class="line-added">495                         indent, returnName, &quot; = x;\n&quot;);</span>
<span class="line-added">496                 }</span>
<span class="line-added">497                 stringBuilder.append(indent, &quot;}\n&quot;);</span>
<span class="line-added">498             }</span>
<span class="line-added">499         } else if (auto* rightMatrix = asMatrixType(*nativeFunctionDeclaration.parameters()[1]-&gt;type())) {</span>
<span class="line-added">500             ASSERT(!asMatrixType(*nativeFunctionDeclaration.parameters()[0]-&gt;type()));</span>
<span class="line-added">501             // scalar &lt;op&gt; matrix</span>
<span class="line-added">502             stringBuilder.append(indent, &quot;{\n&quot;);</span>
<span class="line-added">503             {</span>
<span class="line-added">504                 IndentationScope scope(indent);</span>
<span class="line-added">505                 stringBuilder.append(</span>
<span class="line-added">506                     indent, metalReturnType, &quot; x;\n&quot;,</span>
<span class="line-added">507                     indent, &quot;for (size_t i = 0; i &lt; x.size(); ++i)\n&quot;,</span>
<span class="line-added">508                     indent, &quot;    x[i] = &quot;, args[0], &#39; &#39;, operatorName, &#39; &#39;, args[1], &quot;[i];\n&quot;,</span>
<span class="line-added">509                     indent, returnName, &quot; = x;\n&quot;);</span>
<span class="line-added">510             }</span>
<span class="line-added">511             stringBuilder.append(indent, &quot;}\n&quot;);</span>
<span class="line-added">512         } else {</span>
<span class="line-added">513             // scalar &lt;op&gt; scalar</span>
<span class="line-added">514             // vector &lt;op&gt; vector</span>
<span class="line-added">515             // vector &lt;op&gt; scalar</span>
<span class="line-added">516             // scalar &lt;op&gt; vector</span>
<span class="line-added">517             stringBuilder.append(</span>
<span class="line-added">518                 indent, returnName, &quot; = &quot;, args[0], &#39; &#39;, operatorName, &#39; &#39;, args[1], &quot;;\n&quot;);</span>
<span class="line-added">519         }</span>
<span class="line-added">520 </span>
<span class="line-added">521         return;</span>
522     }
523 
524     if (nativeFunctionDeclaration.name() == &quot;cos&quot;
525         || nativeFunctionDeclaration.name() == &quot;sin&quot;
526         || nativeFunctionDeclaration.name() == &quot;tan&quot;
527         || nativeFunctionDeclaration.name() == &quot;acos&quot;
528         || nativeFunctionDeclaration.name() == &quot;asin&quot;
529         || nativeFunctionDeclaration.name() == &quot;atan&quot;
530         || nativeFunctionDeclaration.name() == &quot;cosh&quot;
531         || nativeFunctionDeclaration.name() == &quot;sinh&quot;
532         || nativeFunctionDeclaration.name() == &quot;tanh&quot;
533         || nativeFunctionDeclaration.name() == &quot;ceil&quot;
534         || nativeFunctionDeclaration.name() == &quot;exp&quot;
535         || nativeFunctionDeclaration.name() == &quot;floor&quot;
536         || nativeFunctionDeclaration.name() == &quot;log&quot;
537         || nativeFunctionDeclaration.name() == &quot;round&quot;
538         || nativeFunctionDeclaration.name() == &quot;trunc&quot;
539         || nativeFunctionDeclaration.name() == &quot;ddx&quot;
540         || nativeFunctionDeclaration.name() == &quot;ddy&quot;
541         || nativeFunctionDeclaration.name() == &quot;isnormal&quot;
542         || nativeFunctionDeclaration.name() == &quot;isfinite&quot;
543         || nativeFunctionDeclaration.name() == &quot;isinf&quot;
544         || nativeFunctionDeclaration.name() == &quot;isnan&quot;
545         || nativeFunctionDeclaration.name() == &quot;asint&quot;
546         || nativeFunctionDeclaration.name() == &quot;asuint&quot;
<span class="line-modified">547         || nativeFunctionDeclaration.name() == &quot;asfloat&quot;</span>
<span class="line-added">548         || nativeFunctionDeclaration.name() == &quot;length&quot;) {</span>
549         ASSERT(nativeFunctionDeclaration.parameters().size() == 1);
<span class="line-modified">550         stringBuilder.append(</span>
<span class="line-modified">551             indent, returnName, &quot; = &quot;, mapFunctionName(nativeFunctionDeclaration.name()), &#39;(&#39;, args[0], &quot;);\n&quot;);</span>
<span class="line-modified">552         return;</span>



553     }
554 
555     if (nativeFunctionDeclaration.name() == &quot;pow&quot; || nativeFunctionDeclaration.name() == &quot;atan2&quot;) {
556         ASSERT(nativeFunctionDeclaration.parameters().size() == 2);
<span class="line-modified">557         stringBuilder.append(</span>
<span class="line-modified">558             indent, returnName, &quot; = &quot;, nativeFunctionDeclaration.name(), &quot;(&quot;, args[0], &quot;, &quot;, args[1], &quot;);\n&quot;);</span>
<span class="line-modified">559         return;</span>




560     }
561 
<span class="line-modified">562     if (nativeFunctionDeclaration.name() == &quot;clamp&quot;) {</span>
<span class="line-modified">563         ASSERT(nativeFunctionDeclaration.parameters().size() == 3);</span>
<span class="line-modified">564         if (asMatrixType(nativeFunctionDeclaration.type())) {</span>
<span class="line-added">565             auto metalReturnType = typeNamer.mangledNameForType(nativeFunctionDeclaration.type());</span>
<span class="line-added">566 </span>
<span class="line-added">567             stringBuilder.append(indent, &quot;{\n&quot;);</span>
<span class="line-added">568             {</span>
<span class="line-added">569                 IndentationScope scope(indent);</span>
<span class="line-added">570                 stringBuilder.append(</span>
<span class="line-added">571                     indent, metalReturnType, &quot; x;\n&quot;,</span>
<span class="line-added">572                     indent, &quot;for (size_t i = 0; i &lt; x.size(); ++i) \n&quot;,</span>
<span class="line-added">573                     indent, &quot;    x[i] = clamp(&quot;, args[0], &quot;[i], &quot;, args[1], &quot;[i], &quot;, args[2], &quot;[i]);&quot;,</span>
<span class="line-added">574                     indent, returnName, &quot; = x;\n&quot;);</span>
<span class="line-added">575             }</span>
<span class="line-added">576             stringBuilder.append(indent, &quot;}\n&quot;);</span>
<span class="line-added">577         } else {</span>
<span class="line-added">578             stringBuilder.append(</span>
<span class="line-added">579                 indent, returnName, &quot; = clamp(&quot;, args[0], &quot;, &quot;, args[1], &quot;, &quot;, args[2], &quot;);\n&quot;);</span>
<span class="line-added">580         }</span>
<span class="line-added">581         return;</span>
582     }
583 
584     if (nativeFunctionDeclaration.name() == &quot;AllMemoryBarrierWithGroupSync&quot;) {
585         ASSERT(!nativeFunctionDeclaration.parameters().size());
<span class="line-modified">586         stringBuilder.append(</span>
<span class="line-modified">587             indent, &quot;threadgroup_barrier(mem_flags::mem_device);\n&quot;,</span>
<span class="line-modified">588             indent, &quot;threadgroup_barrier(mem_flags::mem_threadgroup);\n&quot;,</span>
<span class="line-modified">589             indent, &quot;threadgroup_barrier(mem_flags::mem_texture);\n&quot;);</span>
<span class="line-modified">590         return;</span>

591     }
592 
593     if (nativeFunctionDeclaration.name() == &quot;DeviceMemoryBarrierWithGroupSync&quot;) {
594         ASSERT(!nativeFunctionDeclaration.parameters().size());
<span class="line-modified">595         stringBuilder.append(</span>
<span class="line-modified">596             indent, &quot;threadgroup_barrier(mem_flags::mem_device);\n&quot;);</span>
<span class="line-modified">597         return;</span>

598     }
599 
600     if (nativeFunctionDeclaration.name() == &quot;GroupMemoryBarrierWithGroupSync&quot;) {
601         ASSERT(!nativeFunctionDeclaration.parameters().size());
<span class="line-modified">602         stringBuilder.append(</span>
<span class="line-modified">603             indent, &quot;threadgroup_barrier(mem_flags::mem_threadgroup);\n&quot;);</span>
<span class="line-modified">604         return;</span>

605     }
606 
607     if (nativeFunctionDeclaration.name().startsWith(&quot;Interlocked&quot;_str)) {
608         if (nativeFunctionDeclaration.name() == &quot;InterlockedCompareExchange&quot;) {
609             ASSERT(nativeFunctionDeclaration.parameters().size() == 4);
<span class="line-modified">610             stringBuilder.append(</span>
<span class="line-modified">611                 indent, &quot;atomic_compare_exchange_weak_explicit(&quot;, args[0], &quot;, &amp;&quot;, args[1], &quot;, &quot;, args[2], &quot;, memory_order_relaxed, memory_order_relaxed);\n&quot;,</span>
<span class="line-modified">612                 indent, &#39;*&#39;, args[3], &quot; = &quot;, args[1], &quot;;\n&quot;);</span>
<span class="line-modified">613             return;</span>











614         }
615 
616         ASSERT(nativeFunctionDeclaration.parameters().size() == 3);









617         auto name = atomicName(nativeFunctionDeclaration.name().substring(&quot;Interlocked&quot;_str.length()));
<span class="line-modified">618         stringBuilder.append(</span>
<span class="line-modified">619             indent, &#39;*&#39;, args[2], &quot; = atomic_&quot;, name, &quot;_explicit(&quot;, args[0], &quot;, &quot;, args[1], &quot;, memory_order_relaxed);\n&quot;);</span>
<span class="line-modified">620         return;</span>

621     }
622 
623     if (nativeFunctionDeclaration.name() == &quot;Sample&quot;) {
<span class="line-modified">624         ASSERT(nativeFunctionDeclaration.parameters().size() == 3 || nativeFunctionDeclaration.parameters().size() == 4);</span>
<span class="line-modified">625 </span>
<span class="line-added">626         auto&amp; textureType = downcast&lt;AST::NativeTypeDeclaration&gt;(downcast&lt;AST::NamedType&gt;(nativeFunctionDeclaration.parameters()[0]-&gt;type()-&gt;unifyNode()));</span>
<span class="line-added">627         auto&amp; locationType = downcast&lt;AST::NativeTypeDeclaration&gt;(downcast&lt;AST::NamedType&gt;(nativeFunctionDeclaration.parameters()[2]-&gt;type()-&gt;unifyNode()));</span>
<span class="line-added">628         auto locationVectorLength = vectorLength(locationType);</span>
<span class="line-added">629         auto&amp; returnType = downcast&lt;AST::NativeTypeDeclaration&gt;(downcast&lt;AST::NamedType&gt;(nativeFunctionDeclaration.type().unifyNode()));</span>
<span class="line-added">630         auto returnVectorLength = vectorLength(returnType);</span>
<span class="line-added">631 </span>
<span class="line-added">632         stringBuilder.append(</span>
<span class="line-added">633             indent, returnName, &quot; = &quot;, args[0], &quot;.sample(&quot;, args[1], &quot;, &quot;);</span>
<span class="line-added">634 </span>
<span class="line-added">635         if (textureType.isTextureArray()) {</span>
<span class="line-added">636             ASSERT(locationVectorLength &gt; 1);</span>
<span class="line-added">637             stringBuilder.append(args[2], &#39;.&#39;, &quot;xyzw&quot;_str.substring(0, locationVectorLength - 1), &quot;, &quot;, args[2], &#39;.&#39;, &quot;xyzw&quot;_str.substring(locationVectorLength - 1, 1));</span>
<span class="line-added">638         } else</span>
<span class="line-added">639             stringBuilder.append(args[2]);</span>
<span class="line-added">640         if (nativeFunctionDeclaration.parameters().size() == 4)</span>
<span class="line-added">641             stringBuilder.append(&quot;, &quot;, args[3]);</span>
<span class="line-added">642         stringBuilder.append(&quot;)&quot;);</span>
<span class="line-added">643         if (!textureType.isDepthTexture())</span>
<span class="line-added">644             stringBuilder.append(&quot;.&quot;, &quot;xyzw&quot;_str.substring(0, returnVectorLength));</span>
<span class="line-added">645         stringBuilder.append(&quot;;\n&quot;);</span>
<span class="line-added">646 </span>
<span class="line-added">647         return;</span>
648     }
649 
650     if (nativeFunctionDeclaration.name() == &quot;Load&quot;) {
<span class="line-modified">651         ASSERT(nativeFunctionDeclaration.parameters().size() == 2);</span>
<span class="line-modified">652 </span>
<span class="line-added">653         auto&amp; textureType = downcast&lt;AST::NativeTypeDeclaration&gt;(downcast&lt;AST::NamedType&gt;(nativeFunctionDeclaration.parameters()[0]-&gt;type()-&gt;unifyNode()));</span>
<span class="line-added">654         auto&amp; locationType = downcast&lt;AST::NativeTypeDeclaration&gt;(downcast&lt;AST::NamedType&gt;(nativeFunctionDeclaration.parameters()[1]-&gt;type()-&gt;unifyNode()));</span>
<span class="line-added">655         auto locationVectorLength = vectorLength(locationType);</span>
<span class="line-added">656         auto&amp; returnType = downcast&lt;AST::NativeTypeDeclaration&gt;(downcast&lt;AST::NamedType&gt;(nativeFunctionDeclaration.type().unifyNode()));</span>
<span class="line-added">657         auto returnVectorLength = vectorLength(returnType);</span>
<span class="line-added">658 </span>
<span class="line-added">659         auto metalReturnName = typeNamer.mangledNameForType(returnType);</span>
<span class="line-added">660 </span>
<span class="line-added">661         stringBuilder.append(indent, &quot;do {\n&quot;);</span>
<span class="line-added">662         {</span>
<span class="line-added">663             IndentationScope scope(indent);</span>
<span class="line-added">664 </span>
<span class="line-added">665             if (textureType.isTextureArray()) {</span>
<span class="line-added">666                 ASSERT(locationVectorLength &gt; 1);</span>
<span class="line-added">667                 String dimensions[] = { &quot;width&quot;_str, &quot;height&quot;_str, &quot;depth&quot;_str };</span>
<span class="line-added">668                 for (int i = 0; i &lt; locationVectorLength - 1; ++i) {</span>
<span class="line-added">669                     auto suffix = &quot;xyzw&quot;_str.substring(i, 1);</span>
<span class="line-added">670                     stringBuilder.append(</span>
<span class="line-added">671                         indent, &quot;if (&quot;, args[1], &#39;.&#39;, suffix, &quot; &lt; 0 || static_cast&lt;uint32_t&gt;(&quot;, args[1], &#39;.&#39;, suffix, &quot;) &gt;= &quot;, args[0], &quot;.get_&quot;, dimensions[i], &quot;()) {\n&quot;,</span>
<span class="line-added">672                         indent, &quot;    &quot;, returnName, &quot; = &quot;, metalReturnName, &quot;(0);\n&quot;,</span>
<span class="line-added">673                         indent, &quot;    break;\n&quot;,</span>
<span class="line-added">674                         indent, &quot;}\n&quot;);</span>
<span class="line-added">675                 }</span>
<span class="line-added">676                 auto suffix = &quot;xyzw&quot;_str.substring(locationVectorLength - 1, 1);</span>
<span class="line-added">677                 stringBuilder.append(</span>
<span class="line-added">678                     indent, &quot;if (&quot;, args[1], &#39;.&#39;, suffix, &quot; &lt; 0 || static_cast&lt;uint32_t&gt;(&quot;, args[1], &#39;.&#39;, suffix, &quot;) &gt;= &quot;, args[0], &quot;.get_array_size()) {\n&quot;,</span>
<span class="line-added">679                     indent, &quot;    &quot;, returnName, &quot; = &quot;, metalReturnName, &quot;(0);\n&quot;,</span>
<span class="line-added">680                     indent, &quot;    break;\n&quot;,</span>
<span class="line-added">681                     indent, &quot;}\n&quot;);</span>
<span class="line-added">682             } else {</span>
<span class="line-added">683                 if (locationVectorLength == 1) {</span>
<span class="line-added">684                     stringBuilder.append(</span>
<span class="line-added">685                         indent, &quot;if (&quot;, args[1], &quot; &lt; 0 || static_cast&lt;uint32_t&gt;(&quot;, args[1], &quot;) &gt;= &quot;, args[0], &quot;.get_width()) {\n&quot;,</span>
<span class="line-added">686                         indent, &quot;    &quot;, returnName, &quot; = &quot;, metalReturnName, &quot;(0);\n&quot;,</span>
<span class="line-added">687                         indent, &quot;    break;\n&quot;,</span>
<span class="line-added">688                         indent, &quot;}\n&quot;);</span>
<span class="line-added">689                 } else {</span>
<span class="line-added">690                     stringBuilder.append(</span>
<span class="line-added">691                         indent, &quot;if (&quot;, args[1], &quot;.x &lt; 0 || static_cast&lt;uint32_t&gt;(&quot;, args[1], &quot;.x) &gt;= &quot;, args[0], &quot;.get_width()) {\n&quot;,</span>
<span class="line-added">692                         indent, &quot;    &quot;, returnName, &quot; = &quot;, metalReturnName, &quot;(0);\n&quot;,</span>
<span class="line-added">693                         indent, &quot;    break;\n&quot;,</span>
<span class="line-added">694                         indent, &quot;}\n&quot;,</span>
<span class="line-added">695                         indent, &quot;if (&quot;, args[1], &quot;.y &lt; 0 || static_cast&lt;uint32_t&gt;(&quot;, args[1], &quot;.y) &gt;= &quot;, args[0], &quot;.get_height()) {\n&quot;,</span>
<span class="line-added">696                         indent, &quot;    &quot;, returnName, &quot; = &quot;, metalReturnName, &quot;(0);\n&quot;,</span>
<span class="line-added">697                         indent, &quot;    break;\n&quot;,</span>
<span class="line-added">698                         indent, &quot;}\n&quot;);</span>
<span class="line-added">699                     if (locationVectorLength &gt;= 3) {</span>
<span class="line-added">700                         stringBuilder.append(</span>
<span class="line-added">701                             indent, &quot;if (&quot;, args[1], &quot;.z &lt; 0 || static_cast&lt;uint32_t&gt;(&quot;, args[1], &quot;.z) &gt;= &quot;, args[0], &quot;.get_depth()) {\n&quot;,</span>
<span class="line-added">702                             indent, &quot;    &quot;, returnName, &quot; = &quot;, metalReturnName, &quot;(0);\n&quot;,</span>
<span class="line-added">703                             indent, &quot;    break;\n&quot;,</span>
<span class="line-added">704                             indent, &quot;}\n&quot;);</span>
<span class="line-added">705                     }</span>
<span class="line-added">706                 }</span>
<span class="line-added">707             }</span>
<span class="line-added">708             stringBuilder.append(indent, returnName, &quot; = &quot;, args[0], &quot;.read(&quot;);</span>
<span class="line-added">709             if (textureType.isTextureArray()) {</span>
<span class="line-added">710                 ASSERT(locationVectorLength &gt; 1);</span>
<span class="line-added">711                 stringBuilder.append(&quot;uint&quot;, vectorSuffix(locationVectorLength - 1), &#39;(&#39;, args[1], &#39;.&#39;, &quot;xyzw&quot;_str.substring(0, locationVectorLength - 1), &quot;), uint(&quot;, args[1], &#39;.&#39;, &quot;xyzw&quot;_str.substring(locationVectorLength - 1, 1), &#39;)&#39;);</span>
<span class="line-added">712             } else</span>
<span class="line-added">713                 stringBuilder.append(&quot;uint&quot;, vectorSuffix(locationVectorLength), &#39;(&#39;, args[1], &#39;)&#39;);</span>
<span class="line-added">714             stringBuilder.append(&#39;)&#39;);</span>
<span class="line-added">715             if (!textureType.isDepthTexture())</span>
<span class="line-added">716                 stringBuilder.append(&#39;.&#39;, &quot;xyzw&quot;_str.substring(0, returnVectorLength));</span>
<span class="line-added">717             stringBuilder.append(&quot;;\n&quot;);</span>
<span class="line-added">718         }</span>
<span class="line-added">719         stringBuilder.append(indent, &quot;} while(0);\n&quot;);</span>
<span class="line-added">720 </span>
<span class="line-added">721         return;</span>
<span class="line-added">722     }</span>
<span class="line-added">723 </span>
<span class="line-added">724     if (nativeFunctionDeclaration.name() == &quot;load&quot;) {</span>
<span class="line-added">725         ASSERT(nativeFunctionDeclaration.parameters().size() == 1);</span>
<span class="line-added">726         stringBuilder.append(</span>
<span class="line-added">727             indent, returnName, &quot; = atomic_load_explicit(&quot;, args[0], &quot;, memory_order_relaxed);\n&quot;);</span>
<span class="line-added">728         return;</span>
<span class="line-added">729     }</span>
<span class="line-added">730 </span>
<span class="line-added">731     if (nativeFunctionDeclaration.name() == &quot;store&quot;) {</span>
<span class="line-added">732         ASSERT(nativeFunctionDeclaration.parameters().size() == 2);</span>
<span class="line-added">733         stringBuilder.append(</span>
<span class="line-added">734             indent, &quot;atomic_store_explicit(&quot;, args[0], &quot;, &quot;, args[1], &quot;, memory_order_relaxed);\n&quot;);</span>
<span class="line-added">735         return;</span>
736     }
737 
738     if (nativeFunctionDeclaration.name() == &quot;GetDimensions&quot;) {
<span class="line-modified">739         auto&amp; textureType = downcast&lt;AST::NativeTypeDeclaration&gt;(downcast&lt;AST::NamedType&gt;(nativeFunctionDeclaration.parameters()[0]-&gt;type()-&gt;unifyNode()));</span>
<span class="line-modified">740 </span>
<span class="line-added">741         size_t index = 1;</span>
<span class="line-added">742         bool hasMipLevel = !textureType.isWritableTexture() &amp;&amp; textureType.textureDimension() != 1;</span>
<span class="line-added">743         if (hasMipLevel)</span>
<span class="line-added">744             ++index;</span>
<span class="line-added">745         const MangledVariableName&amp; widthName = args[index];</span>
<span class="line-added">746         ++index;</span>
<span class="line-added">747         Optional&lt;MangledVariableName&gt; heightName;</span>
<span class="line-added">748         if (textureType.textureDimension() &gt;= 2) {</span>
<span class="line-added">749             heightName = args[index];</span>
<span class="line-added">750             ++index;</span>
<span class="line-added">751         }</span>
<span class="line-added">752         Optional&lt;MangledVariableName&gt; depthName;</span>
<span class="line-added">753         if (textureType.textureDimension() &gt;= 3) {</span>
<span class="line-added">754             depthName = args[index];</span>
<span class="line-added">755             ++index;</span>
<span class="line-added">756         }</span>
<span class="line-added">757         Optional&lt;MangledVariableName&gt; elementsName;</span>
<span class="line-added">758         if (textureType.isTextureArray()) {</span>
<span class="line-added">759             elementsName = args[index];</span>
<span class="line-added">760             ++index;</span>
<span class="line-added">761         }</span>
<span class="line-added">762         Optional&lt;MangledVariableName&gt; numberOfLevelsName;</span>
<span class="line-added">763         if (!textureType.isWritableTexture() &amp;&amp; textureType.textureDimension() != 1) {</span>
<span class="line-added">764             numberOfLevelsName = args[index];</span>
<span class="line-added">765             ++index;</span>
<span class="line-added">766         }</span>
<span class="line-added">767         ASSERT(index == nativeFunctionDeclaration.parameters().size());</span>
<span class="line-added">768 </span>
<span class="line-added">769         stringBuilder.append(</span>
<span class="line-added">770             indent, &quot;if (&quot;, widthName, &quot;)\n&quot;,</span>
<span class="line-added">771             indent, &quot;    *&quot;, widthName, &quot; = &quot;, args[0], &quot;.get_width(&quot;);</span>
<span class="line-added">772         if (hasMipLevel)</span>
<span class="line-added">773             stringBuilder.append(args[1]);</span>
<span class="line-added">774         stringBuilder.append(&quot;);\n&quot;);</span>
<span class="line-added">775 </span>
<span class="line-added">776         if (heightName) {</span>
<span class="line-added">777             stringBuilder.append(</span>
<span class="line-added">778                 indent, &quot;if (&quot;, *heightName, &quot;)\n&quot;,</span>
<span class="line-added">779                 indent, &quot;    *&quot;, *heightName, &quot; = &quot;, args[0], &quot;.get_height(&quot;);</span>
<span class="line-added">780             if (hasMipLevel)</span>
<span class="line-added">781                 stringBuilder.append(args[1]);</span>
<span class="line-added">782             stringBuilder.append(&quot;);\n&quot;);</span>
<span class="line-added">783         }</span>
<span class="line-added">784         if (depthName) {</span>
<span class="line-added">785             stringBuilder.append(</span>
<span class="line-added">786                 indent, &quot;if (&quot;, *depthName, &quot;)\n&quot;,</span>
<span class="line-added">787                 indent, &quot;    *&quot;, *depthName, &quot; = &quot;, args[0], &quot;.get_depth(&quot;);</span>
<span class="line-added">788             if (hasMipLevel)</span>
<span class="line-added">789                 stringBuilder.append(args[1]);</span>
<span class="line-added">790             stringBuilder.append(&quot;);\n&quot;);</span>
<span class="line-added">791         }</span>
<span class="line-added">792         if (elementsName) {</span>
<span class="line-added">793             stringBuilder.append(</span>
<span class="line-added">794                 indent, &quot;if (&quot;, *elementsName, &quot;)\n&quot;,</span>
<span class="line-added">795                 indent, &quot;    *&quot;, *elementsName, &quot; = &quot;, args[0], &quot;.get_array_size();\n&quot;);</span>
<span class="line-added">796         }</span>
<span class="line-added">797         if (numberOfLevelsName) {</span>
<span class="line-added">798             stringBuilder.append(</span>
<span class="line-added">799                 indent, &quot;if (&quot;, *numberOfLevelsName, &quot;)\n&quot;,</span>
<span class="line-added">800                 indent, &quot;    *&quot;, *numberOfLevelsName, &quot; = &quot;, args[0], &quot;.get_num_mip_levels();\n&quot;);</span>
<span class="line-added">801         }</span>
<span class="line-added">802         return;</span>
803     }
804 
805     if (nativeFunctionDeclaration.name() == &quot;SampleBias&quot;) {
<span class="line-modified">806         // FIXME: https://bugs.webkit.org/show_bug.cgi?id=195813 Implement this</span>
<span class="line-modified">807         notImplemented();</span>
808     }
809 
810     if (nativeFunctionDeclaration.name() == &quot;SampleGrad&quot;) {
<span class="line-modified">811         // FIXME: https://bugs.webkit.org/show_bug.cgi?id=195813 Implement this</span>
<span class="line-modified">812         notImplemented();</span>
813     }
814 
815     if (nativeFunctionDeclaration.name() == &quot;SampleLevel&quot;) {
<span class="line-modified">816         // FIXME: https://bugs.webkit.org/show_bug.cgi?id=195813 Implement this</span>
<span class="line-modified">817         notImplemented();</span>
818     }
819 
820     if (nativeFunctionDeclaration.name() == &quot;Gather&quot;) {
<span class="line-modified">821         // FIXME: https://bugs.webkit.org/show_bug.cgi?id=195813 Implement this</span>
<span class="line-modified">822         notImplemented();</span>
823     }
824 
825     if (nativeFunctionDeclaration.name() == &quot;GatherRed&quot;) {
<span class="line-modified">826         // FIXME: https://bugs.webkit.org/show_bug.cgi?id=195813 Implement this</span>
<span class="line-modified">827         notImplemented();</span>
828     }
829 
830     if (nativeFunctionDeclaration.name() == &quot;SampleCmp&quot;) {
<span class="line-modified">831         // FIXME: https://bugs.webkit.org/show_bug.cgi?id=195813 Implement this</span>
<span class="line-modified">832         notImplemented();</span>
833     }
834 
835     if (nativeFunctionDeclaration.name() == &quot;SampleCmpLevelZero&quot;) {
<span class="line-modified">836         // FIXME: https://bugs.webkit.org/show_bug.cgi?id=195813 Implement this</span>
<span class="line-modified">837         notImplemented();</span>
838     }
839 
840     if (nativeFunctionDeclaration.name() == &quot;Store&quot;) {
<span class="line-modified">841         ASSERT(nativeFunctionDeclaration.parameters().size() == 3);</span>
<span class="line-modified">842 </span>
<span class="line-added">843         auto&amp; textureType = downcast&lt;AST::NativeTypeDeclaration&gt;(downcast&lt;AST::NamedType&gt;(nativeFunctionDeclaration.parameters()[0]-&gt;type()-&gt;unifyNode()));</span>
<span class="line-added">844         auto&amp; itemType = downcast&lt;AST::NativeTypeDeclaration&gt;(downcast&lt;AST::NamedType&gt;(nativeFunctionDeclaration.parameters()[1]-&gt;type()-&gt;unifyNode()));</span>
<span class="line-added">845         auto&amp; itemVectorInnerType = vectorInnerType(itemType);</span>
<span class="line-added">846         auto itemVectorLength = vectorLength(itemType);</span>
<span class="line-added">847         auto&amp; locationType = downcast&lt;AST::NativeTypeDeclaration&gt;(downcast&lt;AST::NamedType&gt;(nativeFunctionDeclaration.parameters()[2]-&gt;type()-&gt;unifyNode()));</span>
<span class="line-added">848         auto locationVectorLength = vectorLength(locationType);</span>
<span class="line-added">849 </span>
<span class="line-added">850         auto metalInnerTypeName = typeNamer.mangledNameForType(itemVectorInnerType);</span>
<span class="line-added">851 </span>
<span class="line-added">852         stringBuilder.append(&quot;do {\n&quot;);</span>
<span class="line-added">853         {</span>
<span class="line-added">854             IndentationScope scope(indent);</span>
<span class="line-added">855 </span>
<span class="line-added">856             if (textureType.isTextureArray()) {</span>
<span class="line-added">857                 ASSERT(locationVectorLength &gt; 1);</span>
<span class="line-added">858                 String dimensions[] = { &quot;width&quot;_str, &quot;height&quot;_str, &quot;depth&quot;_str };</span>
<span class="line-added">859                 for (int i = 0; i &lt; locationVectorLength - 1; ++i) {</span>
<span class="line-added">860                     auto suffix = &quot;xyzw&quot;_str.substring(i, 1);</span>
<span class="line-added">861                     stringBuilder.append(</span>
<span class="line-added">862                         indent, &quot;if (&quot;, args[2], &quot;.&quot;, suffix, &quot; &gt;= &quot;, args[0], &quot;.get_&quot;, dimensions[i], &quot;())\n&quot;,</span>
<span class="line-added">863                         indent, &quot;    break;\n&quot;);</span>
<span class="line-added">864                 }</span>
<span class="line-added">865                 auto suffix = &quot;xyzw&quot;_str.substring(locationVectorLength - 1, 1);</span>
<span class="line-added">866                 stringBuilder.append(</span>
<span class="line-added">867                     indent, &quot;if (&quot;, args[2], &#39;.&#39;, suffix, &quot; &gt;= &quot;, args[0], &quot;.get_array_size())\n&quot;,</span>
<span class="line-added">868                     indent, &quot;    break;\n&quot;);</span>
<span class="line-added">869             } else {</span>
<span class="line-added">870                 if (locationVectorLength == 1) {</span>
<span class="line-added">871                     stringBuilder.append(</span>
<span class="line-added">872                         indent, &quot;if (&quot;, args[2], &quot; &gt;= &quot;, args[0], &quot;.get_width()) \n&quot;,</span>
<span class="line-added">873                         indent, &quot;    break;\n&quot;);</span>
<span class="line-added">874                 } else {</span>
<span class="line-added">875                     stringBuilder.append(</span>
<span class="line-added">876                         indent, &quot;if (&quot;, args[2], &quot;.x &gt;= &quot;, args[0], &quot;.get_width())\n&quot;,</span>
<span class="line-added">877                         indent, &quot;    break;\n&quot;,</span>
<span class="line-added">878                         indent, &quot;if (&quot;, args[2], &quot;.y &gt;= &quot;, args[0], &quot;.get_height())\n&quot;,</span>
<span class="line-added">879                         indent, &quot;    break;\n&quot;);</span>
<span class="line-added">880                     if (locationVectorLength &gt;= 3) {</span>
<span class="line-added">881                         stringBuilder.append(</span>
<span class="line-added">882                             indent, &quot;if (&quot;, args[2], &quot;.z &gt;= &quot;, args[0], &quot;.get_depth())\n&quot;,</span>
<span class="line-added">883                             indent, &quot;    break;\n&quot;);</span>
<span class="line-added">884                     }</span>
<span class="line-added">885                 }</span>
<span class="line-added">886             }</span>
<span class="line-added">887             stringBuilder.append(indent, args[0], &quot;.write(vec&lt;&quot;, metalInnerTypeName, &quot;, 4&gt;(&quot;, args[1]);</span>
<span class="line-added">888             for (int i = 0; i &lt; 4 - itemVectorLength; ++i)</span>
<span class="line-added">889                 stringBuilder.append(&quot;, 0&quot;);</span>
<span class="line-added">890             stringBuilder.append(&quot;), &quot;);</span>
<span class="line-added">891             if (textureType.isTextureArray()) {</span>
<span class="line-added">892                 ASSERT(locationVectorLength &gt; 1);</span>
<span class="line-added">893                 stringBuilder.append(&quot;uint&quot;, vectorSuffix(locationVectorLength - 1), &#39;(&#39;, args[2], &#39;.&#39;, &quot;xyzw&quot;_str.substring(0, locationVectorLength - 1), &quot;), uint(&quot;, args[2], &quot;.&quot;, &quot;xyzw&quot;_str.substring(locationVectorLength - 1, 1), &#39;)&#39;);</span>
<span class="line-added">894             } else</span>
<span class="line-added">895                 stringBuilder.append(&quot;uint&quot;, vectorSuffix(locationVectorLength), &#39;(&#39;, args[2], &#39;)&#39;);</span>
<span class="line-added">896             stringBuilder.append(&quot;);\n&quot;);</span>
<span class="line-added">897         }</span>
<span class="line-added">898         stringBuilder.append(indent, &quot;} while(0);\n&quot;);</span>
<span class="line-added">899 </span>
<span class="line-added">900         return;</span>
901     }
902 
903     if (nativeFunctionDeclaration.name() == &quot;GatherAlpha&quot;) {
<span class="line-modified">904         // FIXME: https://bugs.webkit.org/show_bug.cgi?id=195813 Implement this</span>
<span class="line-modified">905         notImplemented();</span>
906     }
907 
908     if (nativeFunctionDeclaration.name() == &quot;GatherBlue&quot;) {
<span class="line-modified">909         // FIXME: https://bugs.webkit.org/show_bug.cgi?id=195813 Implement this</span>
<span class="line-modified">910         notImplemented();</span>
911     }
912 
913     if (nativeFunctionDeclaration.name() == &quot;GatherCmp&quot;) {
<span class="line-modified">914         // FIXME: https://bugs.webkit.org/show_bug.cgi?id=195813 Implement this</span>
<span class="line-modified">915         notImplemented();</span>
916     }
917 
918     if (nativeFunctionDeclaration.name() == &quot;GatherCmpRed&quot;) {
<span class="line-modified">919         // FIXME: https://bugs.webkit.org/show_bug.cgi?id=195813 Implement this</span>
<span class="line-modified">920         notImplemented();</span>
921     }
922 
923     if (nativeFunctionDeclaration.name() == &quot;GatherGreen&quot;) {
<span class="line-modified">924         // FIXME: https://bugs.webkit.org/show_bug.cgi?id=195813 Implement this</span>
<span class="line-modified">925         notImplemented();</span>
926     }
927 


928     ASSERT_NOT_REACHED();

929 }
930 
931 } // namespace Metal
932 
933 } // namespace WHLSL
934 
935 } // namespace WebCore
936 
937 #endif
</pre>
</td>
</tr>
</table>
<center><a href="WHLSLMetalCodeGenerator.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="WHLSLNativeFunctionWriter.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>