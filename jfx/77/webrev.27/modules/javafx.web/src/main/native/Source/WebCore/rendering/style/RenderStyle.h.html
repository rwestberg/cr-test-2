<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/rendering/style/RenderStyle.h</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (C) 2000 Lars Knoll (knoll@kde.org)
   3  *           (C) 2000 Antti Koivisto (koivisto@kde.org)
   4  *           (C) 2000 Dirk Mueller (mueller@kde.org)
   5  * Copyright (C) 2003-2017 Apple Inc. All rights reserved.
   6  * Copyright (C) 2006 Graham Dennis (graham.dennis@gmail.com)
   7  *
   8  * This library is free software; you can redistribute it and/or
   9  * modify it under the terms of the GNU Library General Public
  10  * License as published by the Free Software Foundation; either
  11  * version 2 of the License, or (at your option) any later version.
  12  *
  13  * This library is distributed in the hope that it will be useful,
  14  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  15  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  16  * Library General Public License for more details.
  17  *
  18  * You should have received a copy of the GNU Library General Public License
  19  * along with this library; see the file COPYING.LIB.  If not, write to
  20  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  21  * Boston, MA 02110-1301, USA.
  22  *
  23  */
  24 
  25 #pragma once
  26 
  27 #include &quot;AnimationList.h&quot;
  28 #include &quot;BorderValue.h&quot;
  29 #include &quot;CSSLineBoxContainValue.h&quot;
  30 #include &quot;CSSPrimitiveValue.h&quot;
  31 #include &quot;CSSPropertyNames.h&quot;
  32 #include &quot;Color.h&quot;
  33 #include &quot;CounterDirectives.h&quot;
  34 #include &quot;DataRef.h&quot;
  35 #include &quot;FilterOperations.h&quot;
  36 #include &quot;FontCascadeDescription.h&quot;
  37 #include &quot;GapLength.h&quot;
  38 #include &quot;GraphicsTypes.h&quot;
  39 #include &quot;Length.h&quot;
  40 #include &quot;LengthBox.h&quot;
  41 #include &quot;LengthFunctions.h&quot;
  42 #include &quot;LengthPoint.h&quot;
  43 #include &quot;LengthSize.h&quot;
  44 #include &quot;LineClampValue.h&quot;
  45 #include &quot;NinePieceImage.h&quot;
  46 #include &quot;Pagination.h&quot;
  47 #include &quot;RenderStyleConstants.h&quot;
  48 #include &quot;RoundedRect.h&quot;
  49 #include &quot;SVGRenderStyle.h&quot;
  50 #include &quot;ShadowData.h&quot;
  51 #include &quot;ShapeValue.h&quot;
  52 #include &quot;StyleBackgroundData.h&quot;
  53 #include &quot;StyleBoxData.h&quot;
  54 #include &quot;StyleDeprecatedFlexibleBoxData.h&quot;
  55 #include &quot;StyleFilterData.h&quot;
  56 #include &quot;StyleFlexibleBoxData.h&quot;
  57 #include &quot;StyleMarqueeData.h&quot;
  58 #include &quot;StyleMultiColData.h&quot;
  59 #include &quot;StyleRareInheritedData.h&quot;
  60 #include &quot;StyleRareNonInheritedData.h&quot;
  61 #include &quot;StyleReflection.h&quot;
  62 #include &quot;StyleSurroundData.h&quot;
  63 #include &quot;StyleTransformData.h&quot;
  64 #include &quot;StyleVisualData.h&quot;
  65 #include &quot;TextFlags.h&quot;
  66 #include &quot;ThemeTypes.h&quot;
  67 #include &quot;TouchAction.h&quot;
  68 #include &quot;TransformOperations.h&quot;
  69 #include &quot;UnicodeBidi.h&quot;
  70 #include &lt;memory&gt;
  71 #include &lt;wtf/Forward.h&gt;
  72 #include &lt;wtf/NeverDestroyed.h&gt;
  73 #include &lt;wtf/OptionSet.h&gt;
  74 #include &lt;wtf/StdLibExtras.h&gt;
  75 #include &lt;wtf/Vector.h&gt;
  76 
  77 #include &quot;StyleGridData.h&quot;
  78 #include &quot;StyleGridItemData.h&quot;
  79 
  80 #if ENABLE(TEXT_AUTOSIZING)
  81 #include &quot;TextSizeAdjustment.h&quot;
  82 #endif
  83 
  84 #if ENABLE(DARK_MODE_CSS)
  85 #include &quot;StyleColorScheme.h&quot;
  86 #endif
  87 
  88 #define SET_VAR(group, variable, value) do { \
  89         if (!compareEqual(group-&gt;variable, value)) \
  90             group.access().variable = value; \
  91     } while (0)
  92 
  93 #define SET_NESTED_VAR(group, parentVariable, variable, value) do { \
  94         if (!compareEqual(group-&gt;parentVariable-&gt;variable, value)) \
  95             group.access().parentVariable.access().variable = value; \
  96     } while (0)
  97 
  98 #define SET_BORDERVALUE_COLOR(group, variable, value) do { \
  99         if (!compareEqual(group-&gt;variable.color(), value)) \
 100             group.access().variable.setColor(value); \
 101     } while (0)
 102 
 103 namespace WebCore {
 104 
 105 class BorderData;
 106 class ContentData;
 107 class CounterContent;
 108 class CursorList;
 109 class FontCascade;
 110 class FontMetrics;
 111 class IntRect;
 112 class Pair;
 113 class ShadowData;
 114 class StyleImage;
 115 class StyleInheritedData;
 116 class StyleResolver;
 117 class StyleScrollSnapArea;
 118 class StyleScrollSnapPort;
 119 class TransformationMatrix;
 120 
 121 struct ScrollSnapAlign;
 122 struct ScrollSnapType;
 123 
 124 using PseudoStyleCache = Vector&lt;std::unique_ptr&lt;RenderStyle&gt;, 4&gt;;
 125 
 126 template&lt;typename T, typename U&gt; inline bool compareEqual(const T&amp; t, const U&amp; u) { return t == static_cast&lt;const T&amp;&gt;(u); }
 127 
 128 class RenderStyle {
 129     WTF_MAKE_FAST_ALLOCATED;
 130 
 131 private:
 132     enum CloneTag { Clone };
 133     enum CreateDefaultStyleTag { CreateDefaultStyle };
 134 
 135 public:
 136     RenderStyle(RenderStyle&amp;&amp;);
 137     RenderStyle&amp; operator=(RenderStyle&amp;&amp;);
 138     ~RenderStyle();
 139 
 140     RenderStyle replace(RenderStyle&amp;&amp;) WARN_UNUSED_RETURN;
 141 
 142     explicit RenderStyle(CreateDefaultStyleTag);
 143     RenderStyle(const RenderStyle&amp;, CloneTag);
 144 
 145     static RenderStyle&amp; defaultStyle();
 146 
 147     static RenderStyle create();
 148     static std::unique_ptr&lt;RenderStyle&gt; createPtr();
 149 
 150     static RenderStyle clone(const RenderStyle&amp;);
 151     static std::unique_ptr&lt;RenderStyle&gt; clonePtr(const RenderStyle&amp;);
 152 
 153     static RenderStyle createAnonymousStyleWithDisplay(const RenderStyle&amp; parentStyle, DisplayType);
 154     static RenderStyle createStyleInheritingFromPseudoStyle(const RenderStyle&amp; pseudoStyle);
 155 
 156 #if !ASSERT_DISABLED || ENABLE(SECURITY_ASSERTIONS)
 157     bool deletionHasBegun() const { return m_deletionHasBegun; }
 158 #endif
 159 
 160     bool operator==(const RenderStyle&amp;) const;
 161     bool operator!=(const RenderStyle&amp; other) const { return !(*this == other); }
 162 
 163     void inheritFrom(const RenderStyle&amp; inheritParent);
 164     void copyNonInheritedFrom(const RenderStyle&amp;);
 165     void copyContentFrom(const RenderStyle&amp;);
 166 
 167     ContentPosition resolvedJustifyContentPosition(const StyleContentAlignmentData&amp; normalValueBehavior) const;
 168     ContentDistribution resolvedJustifyContentDistribution(const StyleContentAlignmentData&amp; normalValueBehavior) const;
 169     ContentPosition resolvedAlignContentPosition(const StyleContentAlignmentData&amp; normalValueBehavior) const;
 170     ContentDistribution resolvedAlignContentDistribution(const StyleContentAlignmentData&amp; normalValueBehavior) const;
 171     StyleSelfAlignmentData resolvedAlignItems(ItemPosition normalValueBehaviour) const;
 172     StyleSelfAlignmentData resolvedAlignSelf(const RenderStyle* parentStyle, ItemPosition normalValueBehaviour) const;
 173     StyleContentAlignmentData resolvedAlignContent(const StyleContentAlignmentData&amp; normalValueBehaviour) const;
 174     StyleSelfAlignmentData resolvedJustifyItems(ItemPosition normalValueBehaviour) const;
 175     StyleSelfAlignmentData resolvedJustifySelf(const RenderStyle* parentStyle, ItemPosition normalValueBehaviour) const;
 176     StyleContentAlignmentData resolvedJustifyContent(const StyleContentAlignmentData&amp; normalValueBehaviour) const;
 177 
 178     PseudoId styleType() const { return static_cast&lt;PseudoId&gt;(m_nonInheritedFlags.styleType); }
 179     void setStyleType(PseudoId styleType) { m_nonInheritedFlags.styleType = static_cast&lt;unsigned&gt;(styleType); }
 180 
 181     RenderStyle* getCachedPseudoStyle(PseudoId) const;
 182     RenderStyle* addCachedPseudoStyle(std::unique_ptr&lt;RenderStyle&gt;);
 183     void removeCachedPseudoStyle(PseudoId);
 184 
 185     const PseudoStyleCache* cachedPseudoStyles() const { return m_cachedPseudoStyles.get(); }
 186 
 187     const CustomPropertyValueMap&amp; inheritedCustomProperties() const { return m_rareInheritedData-&gt;customProperties-&gt;values; }
 188     const CustomPropertyValueMap&amp; nonInheritedCustomProperties() const { return m_rareNonInheritedData-&gt;customProperties-&gt;values; }
 189     const CSSCustomPropertyValue* getCustomProperty(const AtomString&amp;) const;
 190     void setInheritedCustomPropertyValue(const AtomString&amp; name, Ref&lt;CSSCustomPropertyValue&gt;&amp;&amp; value) { return m_rareInheritedData.access().customProperties.access().setCustomPropertyValue(name, WTFMove(value)); }
 191     void setNonInheritedCustomPropertyValue(const AtomString&amp; name, Ref&lt;CSSCustomPropertyValue&gt;&amp;&amp; value) { return m_rareNonInheritedData.access().customProperties.access().setCustomPropertyValue(name, WTFMove(value)); }
 192 
 193     void setHasViewportUnits(bool v = true) { m_nonInheritedFlags.hasViewportUnits = v; }
 194     bool hasViewportUnits() const { return m_nonInheritedFlags.hasViewportUnits; }
 195 
 196     bool affectedByHover() const { return m_nonInheritedFlags.affectedByHover; }
 197     bool affectedByActive() const { return m_nonInheritedFlags.affectedByActive; }
 198     bool affectedByDrag() const { return m_nonInheritedFlags.affectedByDrag; }
 199 
 200     void setAffectedByHover() { m_nonInheritedFlags.affectedByHover = true; }
 201     void setAffectedByActive() { m_nonInheritedFlags.affectedByActive = true; }
 202     void setAffectedByDrag() { m_nonInheritedFlags.affectedByDrag = true; }
 203 
 204     void setColumnStylesFromPaginationMode(const Pagination::Mode&amp;);
 205 
 206     bool isFloating() const { return static_cast&lt;Float&gt;(m_nonInheritedFlags.floating) != Float::No; }
 207     bool hasMargin() const { return !m_surroundData-&gt;margin.isZero(); }
 208     bool hasBorder() const { return m_surroundData-&gt;border.hasBorder(); }
 209     bool hasBorderFill() const { return m_surroundData-&gt;border.hasFill(); }
 210     bool hasVisibleBorderDecoration() const { return hasVisibleBorder() || hasBorderFill(); }
 211     bool hasVisibleBorder() const { return m_surroundData-&gt;border.hasVisibleBorder(); }
 212     bool hasPadding() const { return !m_surroundData-&gt;padding.isZero(); }
 213     bool hasOffset() const { return !m_surroundData-&gt;offset.isZero(); }
 214     bool hasMarginBeforeQuirk() const { return marginBefore().hasQuirk(); }
 215     bool hasMarginAfterQuirk() const { return marginAfter().hasQuirk(); }
 216 
 217     bool hasBackgroundImage() const { return m_backgroundData-&gt;background.hasImage(); }
 218     bool hasFixedBackgroundImage() const { return m_backgroundData-&gt;background.hasFixedImage(); }
 219 
 220     bool hasEntirelyFixedBackground() const;
 221 
 222     bool hasAppearance() const { return appearance() != NoControlPart; }
 223 
 224     bool hasBackground() const;
 225 
 226     LayoutBoxExtent imageOutsets(const NinePieceImage&amp;) const;
 227     bool hasBorderImageOutsets() const { return borderImage().hasImage() &amp;&amp; !borderImage().outset().isZero(); }
 228     LayoutBoxExtent borderImageOutsets() const { return imageOutsets(borderImage()); }
 229 
 230     LayoutBoxExtent maskBoxImageOutsets() const { return imageOutsets(maskBoxImage()); }
 231 
 232     bool hasFilterOutsets() const { return hasFilter() &amp;&amp; filter().hasOutsets(); }
 233     FilterOutsets filterOutsets() const { return hasFilter() ? filter().outsets() : FilterOutsets(); }
 234 
 235     Order rtlOrdering() const { return static_cast&lt;Order&gt;(m_inheritedFlags.rtlOrdering); }
 236     void setRTLOrdering(Order ordering) { m_inheritedFlags.rtlOrdering = static_cast&lt;unsigned&gt;(ordering); }
 237 
 238     bool isStyleAvailable() const;
 239 
 240     bool hasAnyPublicPseudoStyles() const;
 241     bool hasPseudoStyle(PseudoId) const;
 242     void setHasPseudoStyle(PseudoId);
 243     void setHasPseudoStyles(PseudoIdSet);
 244     bool hasUniquePseudoStyle() const;
 245 
 246     // attribute getter methods
 247 
 248     DisplayType display() const { return static_cast&lt;DisplayType&gt;(m_nonInheritedFlags.effectiveDisplay); }
 249 
 250     const Length&amp; left() const { return m_surroundData-&gt;offset.left(); }
 251     const Length&amp; right() const { return m_surroundData-&gt;offset.right(); }
 252     const Length&amp; top() const { return m_surroundData-&gt;offset.top(); }
 253     const Length&amp; bottom() const { return m_surroundData-&gt;offset.bottom(); }
 254 
 255     // Accessors for positioned object edges that take into account writing mode.
 256     const Length&amp; logicalLeft() const { return m_surroundData-&gt;offset.start(writingMode()); }
 257     const Length&amp; logicalRight() const { return m_surroundData-&gt;offset.end(writingMode()); }
 258     const Length&amp; logicalTop() const { return m_surroundData-&gt;offset.before(writingMode()); }
 259     const Length&amp; logicalBottom() const { return m_surroundData-&gt;offset.after(writingMode()); }
 260 
 261     // Whether or not a positioned element requires normal flow x/y to be computed  to determine its position.
 262     bool hasStaticInlinePosition(bool horizontal) const { return horizontal ? hasAutoLeftAndRight() : hasAutoTopAndBottom(); }
 263     bool hasStaticBlockPosition(bool horizontal) const { return horizontal ? hasAutoTopAndBottom() : hasAutoLeftAndRight(); }
 264 
 265     PositionType position() const { return static_cast&lt;PositionType&gt;(m_nonInheritedFlags.position); }
 266     bool hasOutOfFlowPosition() const { return position() == PositionType::Absolute || position() == PositionType::Fixed; }
 267     bool hasInFlowPosition() const { return position() == PositionType::Relative || position() == PositionType::Sticky; }
 268     bool hasViewportConstrainedPosition() const { return position() == PositionType::Fixed || position() == PositionType::Sticky; }
 269     Float floating() const { return static_cast&lt;Float&gt;(m_nonInheritedFlags.floating); }
 270 
 271     const Length&amp; width() const { return m_boxData-&gt;width(); }
 272     const Length&amp; height() const { return m_boxData-&gt;height(); }
 273     const Length&amp; minWidth() const { return m_boxData-&gt;minWidth(); }
 274     const Length&amp; maxWidth() const { return m_boxData-&gt;maxWidth(); }
 275     const Length&amp; minHeight() const { return m_boxData-&gt;minHeight(); }
 276     const Length&amp; maxHeight() const { return m_boxData-&gt;maxHeight(); }
 277 
 278     const Length&amp; logicalWidth() const { return isHorizontalWritingMode() ? width() : height(); }
 279     const Length&amp; logicalHeight() const { return isHorizontalWritingMode() ? height() : width(); }
 280     const Length&amp; logicalMinWidth() const { return isHorizontalWritingMode() ? minWidth() : minHeight(); }
 281     const Length&amp; logicalMaxWidth() const { return isHorizontalWritingMode() ? maxWidth() : maxHeight(); }
 282     const Length&amp; logicalMinHeight() const { return isHorizontalWritingMode() ? minHeight() : minWidth(); }
 283     const Length&amp; logicalMaxHeight() const { return isHorizontalWritingMode() ? maxHeight() : maxWidth(); }
 284 
 285     const BorderData&amp; border() const { return m_surroundData-&gt;border; }
 286     const BorderValue&amp; borderLeft() const { return m_surroundData-&gt;border.left(); }
 287     const BorderValue&amp; borderRight() const { return m_surroundData-&gt;border.right(); }
 288     const BorderValue&amp; borderTop() const { return m_surroundData-&gt;border.top(); }
 289     const BorderValue&amp; borderBottom() const { return m_surroundData-&gt;border.bottom(); }
 290 
 291     const BorderValue&amp; borderBefore() const;
 292     const BorderValue&amp; borderAfter() const;
 293     const BorderValue&amp; borderStart() const;
 294     const BorderValue&amp; borderEnd() const;
 295 
 296     const NinePieceImage&amp; borderImage() const { return m_surroundData-&gt;border.image(); }
 297     StyleImage* borderImageSource() const { return m_surroundData-&gt;border.image().image(); }
 298     const LengthBox&amp; borderImageSlices() const { return m_surroundData-&gt;border.image().imageSlices(); }
 299     const LengthBox&amp; borderImageWidth() const { return m_surroundData-&gt;border.image().borderSlices(); }
 300     const LengthBox&amp; borderImageOutset() const { return m_surroundData-&gt;border.image().outset(); }
 301 
 302     const LengthSize&amp; borderTopLeftRadius() const { return m_surroundData-&gt;border.topLeft(); }
 303     const LengthSize&amp; borderTopRightRadius() const { return m_surroundData-&gt;border.topRight(); }
 304     const LengthSize&amp; borderBottomLeftRadius() const { return m_surroundData-&gt;border.bottomLeft(); }
 305     const LengthSize&amp; borderBottomRightRadius() const { return m_surroundData-&gt;border.bottomRight(); }
 306     bool hasBorderRadius() const { return m_surroundData-&gt;border.hasBorderRadius(); }
 307 
 308     float borderLeftWidth() const { return m_surroundData-&gt;border.borderLeftWidth(); }
 309     BorderStyle borderLeftStyle() const { return m_surroundData-&gt;border.left().style(); }
 310     bool borderLeftIsTransparent() const { return m_surroundData-&gt;border.left().isTransparent(); }
 311     float borderRightWidth() const { return m_surroundData-&gt;border.borderRightWidth(); }
 312     BorderStyle borderRightStyle() const { return m_surroundData-&gt;border.right().style(); }
 313     bool borderRightIsTransparent() const { return m_surroundData-&gt;border.right().isTransparent(); }
 314     float borderTopWidth() const { return m_surroundData-&gt;border.borderTopWidth(); }
 315     BorderStyle borderTopStyle() const { return m_surroundData-&gt;border.top().style(); }
 316     bool borderTopIsTransparent() const { return m_surroundData-&gt;border.top().isTransparent(); }
 317     float borderBottomWidth() const { return m_surroundData-&gt;border.borderBottomWidth(); }
 318     BorderStyle borderBottomStyle() const { return m_surroundData-&gt;border.bottom().style(); }
 319     bool borderBottomIsTransparent() const { return m_surroundData-&gt;border.bottom().isTransparent(); }
 320     FloatBoxExtent borderWidth() const { return m_surroundData-&gt;border.borderWidth(); }
 321 
 322     float borderBeforeWidth() const;
 323     float borderAfterWidth() const;
 324     float borderStartWidth() const;
 325     float borderEndWidth() const;
 326 
 327     float outlineSize() const { return std::max&lt;float&gt;(0, outlineWidth() + outlineOffset()); }
 328     float outlineWidth() const;
 329     bool hasOutline() const { return outlineStyle() &gt; BorderStyle::Hidden &amp;&amp; outlineWidth() &gt; 0; }
 330     BorderStyle outlineStyle() const { return m_backgroundData-&gt;outline.style(); }
 331     OutlineIsAuto outlineStyleIsAuto() const { return static_cast&lt;OutlineIsAuto&gt;(m_backgroundData-&gt;outline.isAuto()); }
 332     bool hasOutlineInVisualOverflow() const { return hasOutline() &amp;&amp; outlineSize() &gt; 0; }
 333 
 334     Overflow overflowX() const { return static_cast&lt;Overflow&gt;(m_nonInheritedFlags.overflowX); }
 335     Overflow overflowY() const { return static_cast&lt;Overflow&gt;(m_nonInheritedFlags.overflowY); }
 336     Overflow overflowInlineDirection() const { return isHorizontalWritingMode() ? overflowX() : overflowY(); }
 337     Overflow overflowBlockDirection() const { return isHorizontalWritingMode() ? overflowY() : overflowX(); }
 338     bool isOverflowVisible() const { return overflowX() == Overflow::Visible || overflowY() == Overflow::Visible; }
 339 
 340     Visibility visibility() const { return static_cast&lt;Visibility&gt;(m_inheritedFlags.visibility); }
 341     VerticalAlign verticalAlign() const { return static_cast&lt;VerticalAlign&gt;(m_nonInheritedFlags.verticalAlign); }
 342     const Length&amp; verticalAlignLength() const { return m_boxData-&gt;verticalAlign(); }
 343 
 344     const Length&amp; clipLeft() const { return m_visualData-&gt;clip.left(); }
 345     const Length&amp; clipRight() const { return m_visualData-&gt;clip.right(); }
 346     const Length&amp; clipTop() const { return m_visualData-&gt;clip.top(); }
 347     const Length&amp; clipBottom() const { return m_visualData-&gt;clip.bottom(); }
 348     const LengthBox&amp; clip() const { return m_visualData-&gt;clip; }
 349     bool hasClip() const { return m_visualData-&gt;hasClip; }
 350 
 351     EUnicodeBidi unicodeBidi() const { return static_cast&lt;EUnicodeBidi&gt;(m_nonInheritedFlags.unicodeBidi); }
 352 
 353     Clear clear() const { return static_cast&lt;Clear&gt;(m_nonInheritedFlags.clear); }
 354     TableLayoutType tableLayout() const { return static_cast&lt;TableLayoutType&gt;(m_nonInheritedFlags.tableLayout); }
 355 
 356     WEBCORE_EXPORT const FontCascade&amp; fontCascade() const;
 357     WEBCORE_EXPORT const FontMetrics&amp; fontMetrics() const;
 358     WEBCORE_EXPORT const FontCascadeDescription&amp; fontDescription() const;
 359     float specifiedFontSize() const;
 360     float computedFontSize() const;
 361     unsigned computedFontPixelSize() const;
 362     std::pair&lt;FontOrientation, NonCJKGlyphOrientation&gt; fontAndGlyphOrientation();
 363 
 364 #if ENABLE(VARIATION_FONTS)
 365     FontVariationSettings fontVariationSettings() const { return fontDescription().variationSettings(); }
 366 #endif
 367     FontSelectionValue fontWeight() const { return fontDescription().weight(); }
 368     FontSelectionValue fontStretch() const { return fontDescription().stretch(); }
 369     Optional&lt;FontSelectionValue&gt; fontItalic() const { return fontDescription().italic(); }
 370 
 371     const Length&amp; textIndent() const { return m_rareInheritedData-&gt;indent; }
 372     TextAlignMode textAlign() const { return static_cast&lt;TextAlignMode&gt;(m_inheritedFlags.textAlign); }
 373     TextTransform textTransform() const { return static_cast&lt;TextTransform&gt;(m_inheritedFlags.textTransform); }
 374     OptionSet&lt;TextDecoration&gt; textDecorationsInEffect() const { return OptionSet&lt;TextDecoration&gt;::fromRaw(m_inheritedFlags.textDecorations); }
 375     OptionSet&lt;TextDecoration&gt; textDecoration() const { return OptionSet&lt;TextDecoration&gt;::fromRaw(m_visualData-&gt;textDecoration); }
 376     TextDecorationStyle textDecorationStyle() const { return static_cast&lt;TextDecorationStyle&gt;(m_rareNonInheritedData-&gt;textDecorationStyle); }
 377     OptionSet&lt;TextDecorationSkip&gt; textDecorationSkip() const { return OptionSet&lt;TextDecorationSkip&gt;::fromRaw(m_rareInheritedData-&gt;textDecorationSkip); }
 378     TextUnderlinePosition textUnderlinePosition() const { return static_cast&lt;TextUnderlinePosition&gt;(m_rareInheritedData-&gt;textUnderlinePosition); }
 379     TextUnderlineOffset textUnderlineOffset() const { return m_rareInheritedData-&gt;textUnderlineOffset; }
 380     TextDecorationThickness textDecorationThickness() const { return m_rareInheritedData-&gt;textDecorationThickness; }
 381 
 382 #if ENABLE(CSS3_TEXT)
 383     TextIndentLine textIndentLine() const { return static_cast&lt;TextIndentLine&gt;(m_rareInheritedData-&gt;textIndentLine); }
 384     TextIndentType textIndentType() const { return static_cast&lt;TextIndentType&gt;(m_rareInheritedData-&gt;textIndentType); }
 385     TextAlignLast textAlignLast() const { return static_cast&lt;TextAlignLast&gt;(m_rareInheritedData-&gt;textAlignLast); }
 386     TextJustify textJustify() const { return static_cast&lt;TextJustify&gt;(m_rareInheritedData-&gt;textJustify); }
 387 #endif
 388 
 389     const Length&amp; wordSpacing() const;
 390     float letterSpacing() const;
 391 
 392     float zoom() const { return m_visualData-&gt;zoom; }
 393     float effectiveZoom() const { return m_rareInheritedData-&gt;effectiveZoom; }
 394 
 395     TextZoom textZoom() const { return static_cast&lt;TextZoom&gt;(m_rareInheritedData-&gt;textZoom); }
 396 
 397     TextDirection direction() const { return static_cast&lt;TextDirection&gt;(m_inheritedFlags.direction); }
 398     bool isLeftToRightDirection() const { return direction() == TextDirection::LTR; }
 399     bool hasExplicitlySetDirection() const { return m_nonInheritedFlags.hasExplicitlySetDirection; }
 400 
 401     const Length&amp; specifiedLineHeight() const;
 402     WEBCORE_EXPORT const Length&amp; lineHeight() const;
 403     WEBCORE_EXPORT int computedLineHeight() const;
 404 
 405     WhiteSpace whiteSpace() const { return static_cast&lt;WhiteSpace&gt;(m_inheritedFlags.whiteSpace); }
 406     static bool autoWrap(WhiteSpace);
 407     bool autoWrap() const { return autoWrap(whiteSpace()); }
 408     static bool preserveNewline(WhiteSpace);
 409     bool preserveNewline() const { return preserveNewline(whiteSpace()); }
 410     static bool collapseWhiteSpace(WhiteSpace);
 411     bool collapseWhiteSpace() const { return collapseWhiteSpace(whiteSpace()); }
 412     bool isCollapsibleWhiteSpace(UChar) const;
 413     bool breakOnlyAfterWhiteSpace() const;
 414     bool breakWords() const;
 415 
 416     FillRepeat backgroundRepeatX() const { return static_cast&lt;FillRepeat&gt;(m_backgroundData-&gt;background.repeatX()); }
 417     FillRepeat backgroundRepeatY() const { return static_cast&lt;FillRepeat&gt;(m_backgroundData-&gt;background.repeatY()); }
 418     CompositeOperator backgroundComposite() const { return static_cast&lt;CompositeOperator&gt;(m_backgroundData-&gt;background.composite()); }
 419     FillAttachment backgroundAttachment() const { return static_cast&lt;FillAttachment&gt;(m_backgroundData-&gt;background.attachment()); }
 420     FillBox backgroundClip() const { return static_cast&lt;FillBox&gt;(m_backgroundData-&gt;background.clip()); }
 421     FillBox backgroundOrigin() const { return static_cast&lt;FillBox&gt;(m_backgroundData-&gt;background.origin()); }
 422     const Length&amp; backgroundXPosition() const { return m_backgroundData-&gt;background.xPosition(); }
 423     const Length&amp; backgroundYPosition() const { return m_backgroundData-&gt;background.yPosition(); }
 424     FillSizeType backgroundSizeType() const { return m_backgroundData-&gt;background.sizeType(); }
 425     const LengthSize&amp; backgroundSizeLength() const { return m_backgroundData-&gt;background.sizeLength(); }
 426     FillLayer&amp; ensureBackgroundLayers() { return m_backgroundData.access().background; }
 427     const FillLayer&amp; backgroundLayers() const { return m_backgroundData-&gt;background; }
 428 
 429     StyleImage* maskImage() const { return m_rareNonInheritedData-&gt;mask.image(); }
 430     FillRepeat maskRepeatX() const { return static_cast&lt;FillRepeat&gt;(m_rareNonInheritedData-&gt;mask.repeatX()); }
 431     FillRepeat maskRepeatY() const { return static_cast&lt;FillRepeat&gt;(m_rareNonInheritedData-&gt;mask.repeatY()); }
 432     CompositeOperator maskComposite() const { return static_cast&lt;CompositeOperator&gt;(m_rareNonInheritedData-&gt;mask.composite()); }
 433     FillBox maskClip() const { return static_cast&lt;FillBox&gt;(m_rareNonInheritedData-&gt;mask.clip()); }
 434     FillBox maskOrigin() const { return static_cast&lt;FillBox&gt;(m_rareNonInheritedData-&gt;mask.origin()); }
 435     const Length&amp; maskXPosition() const { return m_rareNonInheritedData-&gt;mask.xPosition(); }
 436     const Length&amp; maskYPosition() const { return m_rareNonInheritedData-&gt;mask.yPosition(); }
 437     FillSizeType maskSizeType() const { return m_rareNonInheritedData-&gt;mask.sizeType(); }
 438     const LengthSize&amp; maskSizeLength() const { return m_rareNonInheritedData-&gt;mask.sizeLength(); }
 439     FillLayer&amp; ensureMaskLayers() { return m_rareNonInheritedData.access().mask; }
 440     const FillLayer&amp; maskLayers() const { return m_rareNonInheritedData-&gt;mask; }
 441     const NinePieceImage&amp; maskBoxImage() const { return m_rareNonInheritedData-&gt;maskBoxImage; }
 442     StyleImage* maskBoxImageSource() const { return m_rareNonInheritedData-&gt;maskBoxImage.image(); }
 443 
 444     BorderCollapse borderCollapse() const { return static_cast&lt;BorderCollapse&gt;(m_inheritedFlags.borderCollapse); }
 445     float horizontalBorderSpacing() const;
 446     float verticalBorderSpacing() const;
 447     EmptyCell emptyCells() const { return static_cast&lt;EmptyCell&gt;(m_inheritedFlags.emptyCells); }
 448     CaptionSide captionSide() const { return static_cast&lt;CaptionSide&gt;(m_inheritedFlags.captionSide); }
 449 
 450     ListStyleType listStyleType() const { return static_cast&lt;ListStyleType&gt;(m_inheritedFlags.listStyleType); }
 451     StyleImage* listStyleImage() const;
 452     ListStylePosition listStylePosition() const { return static_cast&lt;ListStylePosition&gt;(m_inheritedFlags.listStylePosition); }
 453 
 454     const Length&amp; marginTop() const { return m_surroundData-&gt;margin.top(); }
 455     const Length&amp; marginBottom() const { return m_surroundData-&gt;margin.bottom(); }
 456     const Length&amp; marginLeft() const { return m_surroundData-&gt;margin.left(); }
 457     const Length&amp; marginRight() const { return m_surroundData-&gt;margin.right(); }
 458     const Length&amp; marginBefore() const { return m_surroundData-&gt;margin.before(writingMode()); }
 459     const Length&amp; marginAfter() const { return m_surroundData-&gt;margin.after(writingMode()); }
 460     const Length&amp; marginStart() const { return m_surroundData-&gt;margin.start(writingMode(), direction()); }
 461     const Length&amp; marginEnd() const { return m_surroundData-&gt;margin.end(writingMode(), direction()); }
 462     const Length&amp; marginStartUsing(const RenderStyle* otherStyle) const { return m_surroundData-&gt;margin.start(otherStyle-&gt;writingMode(), otherStyle-&gt;direction()); }
 463     const Length&amp; marginEndUsing(const RenderStyle* otherStyle) const { return m_surroundData-&gt;margin.end(otherStyle-&gt;writingMode(), otherStyle-&gt;direction()); }
 464     const Length&amp; marginBeforeUsing(const RenderStyle* otherStyle) const { return m_surroundData-&gt;margin.before(otherStyle-&gt;writingMode()); }
 465     const Length&amp; marginAfterUsing(const RenderStyle* otherStyle) const { return m_surroundData-&gt;margin.after(otherStyle-&gt;writingMode()); }
 466 
 467     const LengthBox&amp; paddingBox() const { return m_surroundData-&gt;padding; }
 468     const Length&amp; paddingTop() const { return m_surroundData-&gt;padding.top(); }
 469     const Length&amp; paddingBottom() const { return m_surroundData-&gt;padding.bottom(); }
 470     const Length&amp; paddingLeft() const { return m_surroundData-&gt;padding.left(); }
 471     const Length&amp; paddingRight() const { return m_surroundData-&gt;padding.right(); }
 472     const Length&amp; paddingBefore() const { return m_surroundData-&gt;padding.before(writingMode()); }
 473     const Length&amp; paddingAfter() const { return m_surroundData-&gt;padding.after(writingMode()); }
 474     const Length&amp; paddingStart() const { return m_surroundData-&gt;padding.start(writingMode(), direction()); }
 475     const Length&amp; paddingEnd() const { return m_surroundData-&gt;padding.end(writingMode(), direction()); }
 476 
 477     CursorType cursor() const { return static_cast&lt;CursorType&gt;(m_inheritedFlags.cursor); }
 478 
 479 #if ENABLE(CURSOR_VISIBILITY)
 480     CursorVisibility cursorVisibility() const { return static_cast&lt;CursorVisibility&gt;(m_inheritedFlags.cursorVisibility); }
 481 #endif
 482 
 483     CursorList* cursors() const { return m_rareInheritedData-&gt;cursorData.get(); }
 484 
 485     InsideLink insideLink() const { return static_cast&lt;InsideLink&gt;(m_inheritedFlags.insideLink); }
 486     bool isLink() const { return m_nonInheritedFlags.isLink; }
 487 
 488     bool insideDefaultButton() const { return m_inheritedFlags.insideDefaultButton; }
 489 
 490     short widows() const { return m_rareInheritedData-&gt;widows; }
 491     short orphans() const { return m_rareInheritedData-&gt;orphans; }
 492     bool hasAutoWidows() const { return m_rareInheritedData-&gt;hasAutoWidows; }
 493     bool hasAutoOrphans() const { return m_rareInheritedData-&gt;hasAutoOrphans; }
 494 
 495     BreakInside breakInside() const { return static_cast&lt;BreakInside&gt;(m_rareNonInheritedData-&gt;breakInside); }
 496     BreakBetween breakBefore() const { return static_cast&lt;BreakBetween&gt;(m_rareNonInheritedData-&gt;breakBefore); }
 497     BreakBetween breakAfter() const { return static_cast&lt;BreakBetween&gt;(m_rareNonInheritedData-&gt;breakAfter); }
 498 
 499     OptionSet&lt;HangingPunctuation&gt; hangingPunctuation() const { return OptionSet&lt;HangingPunctuation&gt;::fromRaw(m_rareInheritedData-&gt;hangingPunctuation); }
 500 
 501     float outlineOffset() const;
 502     const ShadowData* textShadow() const { return m_rareInheritedData-&gt;textShadow.get(); }
 503     void getTextShadowInlineDirectionExtent(LayoutUnit&amp; logicalLeft, LayoutUnit&amp; logicalRight) const { getShadowInlineDirectionExtent(textShadow(), logicalLeft, logicalRight); }
 504     void getTextShadowBlockDirectionExtent(LayoutUnit&amp; logicalTop, LayoutUnit&amp; logicalBottom) const { getShadowBlockDirectionExtent(textShadow(), logicalTop, logicalBottom); }
 505 
 506     float textStrokeWidth() const { return m_rareInheritedData-&gt;textStrokeWidth; }
 507     float opacity() const { return m_rareNonInheritedData-&gt;opacity; }
 508     ControlPart appearance() const { return static_cast&lt;ControlPart&gt;(m_rareNonInheritedData-&gt;appearance); }
 509     AspectRatioType aspectRatioType() const { return static_cast&lt;AspectRatioType&gt;(m_rareNonInheritedData-&gt;aspectRatioType); }
 510     float aspectRatioDenominator() const { return m_rareNonInheritedData-&gt;aspectRatioDenominator; }
 511     float aspectRatioNumerator() const { return m_rareNonInheritedData-&gt;aspectRatioNumerator; }
 512     BoxAlignment boxAlign() const { return static_cast&lt;BoxAlignment&gt;(m_rareNonInheritedData-&gt;deprecatedFlexibleBox-&gt;align); }
 513     BoxDirection boxDirection() const { return static_cast&lt;BoxDirection&gt;(m_inheritedFlags.boxDirection); }
 514     float boxFlex() const { return m_rareNonInheritedData-&gt;deprecatedFlexibleBox-&gt;flex; }
 515     unsigned boxFlexGroup() const { return m_rareNonInheritedData-&gt;deprecatedFlexibleBox-&gt;flexGroup; }
 516     BoxLines boxLines() const { return static_cast&lt;BoxLines&gt;(m_rareNonInheritedData-&gt;deprecatedFlexibleBox-&gt;lines); }
 517     unsigned boxOrdinalGroup() const { return m_rareNonInheritedData-&gt;deprecatedFlexibleBox-&gt;ordinalGroup; }
 518     BoxOrient boxOrient() const { return static_cast&lt;BoxOrient&gt;(m_rareNonInheritedData-&gt;deprecatedFlexibleBox-&gt;orient); }
 519     BoxPack boxPack() const { return static_cast&lt;BoxPack&gt;(m_rareNonInheritedData-&gt;deprecatedFlexibleBox-&gt;pack); }
 520 
 521     int order() const { return m_rareNonInheritedData-&gt;order; }
 522     float flexGrow() const { return m_rareNonInheritedData-&gt;flexibleBox-&gt;flexGrow; }
 523     float flexShrink() const { return m_rareNonInheritedData-&gt;flexibleBox-&gt;flexShrink; }
 524     const Length&amp; flexBasis() const { return m_rareNonInheritedData-&gt;flexibleBox-&gt;flexBasis; }
 525     const StyleContentAlignmentData&amp; alignContent() const { return m_rareNonInheritedData-&gt;alignContent; }
 526     const StyleSelfAlignmentData&amp; alignItems() const { return m_rareNonInheritedData-&gt;alignItems; }
 527     const StyleSelfAlignmentData&amp; alignSelf() const { return m_rareNonInheritedData-&gt;alignSelf; }
 528     FlexDirection flexDirection() const { return static_cast&lt;FlexDirection&gt;(m_rareNonInheritedData-&gt;flexibleBox-&gt;flexDirection); }
 529     bool isColumnFlexDirection() const { return flexDirection() == FlexDirection::Column || flexDirection() == FlexDirection::ColumnReverse; }
 530     bool isReverseFlexDirection() const { return flexDirection() == FlexDirection::RowReverse || flexDirection() == FlexDirection::ColumnReverse; }
 531     FlexWrap flexWrap() const { return static_cast&lt;FlexWrap&gt;(m_rareNonInheritedData-&gt;flexibleBox-&gt;flexWrap); }
 532     const StyleContentAlignmentData&amp; justifyContent() const { return m_rareNonInheritedData-&gt;justifyContent; }
 533     const StyleSelfAlignmentData&amp; justifyItems() const { return m_rareNonInheritedData-&gt;justifyItems; }
 534     const StyleSelfAlignmentData&amp; justifySelf() const { return m_rareNonInheritedData-&gt;justifySelf; }
 535 
 536     const Vector&lt;GridTrackSize&gt;&amp; gridColumns() const { return m_rareNonInheritedData-&gt;grid-&gt;gridColumns; }
 537     const Vector&lt;GridTrackSize&gt;&amp; gridRows() const { return m_rareNonInheritedData-&gt;grid-&gt;gridRows; }
 538     const Vector&lt;GridTrackSize&gt;&amp; gridAutoRepeatColumns() const { return m_rareNonInheritedData-&gt;grid-&gt;gridAutoRepeatColumns; }
 539     const Vector&lt;GridTrackSize&gt;&amp; gridAutoRepeatRows() const { return m_rareNonInheritedData-&gt;grid-&gt;gridAutoRepeatRows; }
 540     unsigned gridAutoRepeatColumnsInsertionPoint() const { return m_rareNonInheritedData-&gt;grid-&gt;autoRepeatColumnsInsertionPoint; }
 541     unsigned gridAutoRepeatRowsInsertionPoint() const { return m_rareNonInheritedData-&gt;grid-&gt;autoRepeatRowsInsertionPoint; }
 542     AutoRepeatType gridAutoRepeatColumnsType() const  { return m_rareNonInheritedData-&gt;grid-&gt;autoRepeatColumnsType; }
 543     AutoRepeatType gridAutoRepeatRowsType() const  { return m_rareNonInheritedData-&gt;grid-&gt;autoRepeatRowsType; }
 544     const NamedGridLinesMap&amp; namedGridColumnLines() const { return m_rareNonInheritedData-&gt;grid-&gt;namedGridColumnLines; }
 545     const NamedGridLinesMap&amp; namedGridRowLines() const { return m_rareNonInheritedData-&gt;grid-&gt;namedGridRowLines; }
 546     const OrderedNamedGridLinesMap&amp; orderedNamedGridColumnLines() const { return m_rareNonInheritedData-&gt;grid-&gt;orderedNamedGridColumnLines; }
 547     const OrderedNamedGridLinesMap&amp; orderedNamedGridRowLines() const { return m_rareNonInheritedData-&gt;grid-&gt;orderedNamedGridRowLines; }
 548     const NamedGridLinesMap&amp; autoRepeatNamedGridColumnLines() const { return m_rareNonInheritedData-&gt;grid-&gt;autoRepeatNamedGridColumnLines; }
 549     const NamedGridLinesMap&amp; autoRepeatNamedGridRowLines() const { return m_rareNonInheritedData-&gt;grid-&gt;autoRepeatNamedGridRowLines; }
 550     const OrderedNamedGridLinesMap&amp; autoRepeatOrderedNamedGridColumnLines() const { return m_rareNonInheritedData-&gt;grid-&gt;autoRepeatOrderedNamedGridColumnLines; }
 551     const OrderedNamedGridLinesMap&amp; autoRepeatOrderedNamedGridRowLines() const { return m_rareNonInheritedData-&gt;grid-&gt;autoRepeatOrderedNamedGridRowLines; }
 552     const NamedGridAreaMap&amp; namedGridArea() const { return m_rareNonInheritedData-&gt;grid-&gt;namedGridArea; }
 553     size_t namedGridAreaRowCount() const { return m_rareNonInheritedData-&gt;grid-&gt;namedGridAreaRowCount; }
 554     size_t namedGridAreaColumnCount() const { return m_rareNonInheritedData-&gt;grid-&gt;namedGridAreaColumnCount; }
 555     GridAutoFlow gridAutoFlow() const { return static_cast&lt;GridAutoFlow&gt;(m_rareNonInheritedData-&gt;grid-&gt;gridAutoFlow); }
 556     bool isGridAutoFlowDirectionRow() const { return (m_rareNonInheritedData-&gt;grid-&gt;gridAutoFlow &amp; InternalAutoFlowDirectionRow); }
 557     bool isGridAutoFlowDirectionColumn() const { return (m_rareNonInheritedData-&gt;grid-&gt;gridAutoFlow &amp; InternalAutoFlowDirectionColumn); }
 558     bool isGridAutoFlowAlgorithmSparse() const { return (m_rareNonInheritedData-&gt;grid-&gt;gridAutoFlow &amp; InternalAutoFlowAlgorithmSparse); }
 559     bool isGridAutoFlowAlgorithmDense() const { return (m_rareNonInheritedData-&gt;grid-&gt;gridAutoFlow &amp; InternalAutoFlowAlgorithmDense); }
 560     const Vector&lt;GridTrackSize&gt;&amp; gridAutoColumns() const { return m_rareNonInheritedData-&gt;grid-&gt;gridAutoColumns; }
 561     const Vector&lt;GridTrackSize&gt;&amp; gridAutoRows() const { return m_rareNonInheritedData-&gt;grid-&gt;gridAutoRows; }
 562 
 563     const GridPosition&amp; gridItemColumnStart() const { return m_rareNonInheritedData-&gt;gridItem-&gt;gridColumnStart; }
 564     const GridPosition&amp; gridItemColumnEnd() const { return m_rareNonInheritedData-&gt;gridItem-&gt;gridColumnEnd; }
 565     const GridPosition&amp; gridItemRowStart() const { return m_rareNonInheritedData-&gt;gridItem-&gt;gridRowStart; }
 566     const GridPosition&amp; gridItemRowEnd() const { return m_rareNonInheritedData-&gt;gridItem-&gt;gridRowEnd; }
 567 
 568     const ShadowData* boxShadow() const { return m_rareNonInheritedData-&gt;boxShadow.get(); }
 569     void getBoxShadowExtent(LayoutUnit&amp; top, LayoutUnit&amp; right, LayoutUnit&amp; bottom, LayoutUnit&amp; left) const { getShadowExtent(boxShadow(), top, right, bottom, left); }
 570     LayoutBoxExtent getBoxShadowInsetExtent() const { return getShadowInsetExtent(boxShadow()); }
 571     void getBoxShadowHorizontalExtent(LayoutUnit&amp; left, LayoutUnit&amp; right) const { getShadowHorizontalExtent(boxShadow(), left, right); }
 572     void getBoxShadowVerticalExtent(LayoutUnit&amp; top, LayoutUnit&amp; bottom) const { getShadowVerticalExtent(boxShadow(), top, bottom); }
 573     void getBoxShadowInlineDirectionExtent(LayoutUnit&amp; logicalLeft, LayoutUnit&amp; logicalRight) const { getShadowInlineDirectionExtent(boxShadow(), logicalLeft, logicalRight); }
 574     void getBoxShadowBlockDirectionExtent(LayoutUnit&amp; logicalTop, LayoutUnit&amp; logicalBottom) const { getShadowBlockDirectionExtent(boxShadow(), logicalTop, logicalBottom); }
 575 
 576 #if ENABLE(CSS_BOX_DECORATION_BREAK)
 577     BoxDecorationBreak boxDecorationBreak() const { return m_boxData-&gt;boxDecorationBreak(); }
 578 #endif
 579 
 580     StyleReflection* boxReflect() const { return m_rareNonInheritedData-&gt;boxReflect.get(); }
 581     BoxSizing boxSizing() const { return m_boxData-&gt;boxSizing(); }
 582     const Length&amp; marqueeIncrement() const { return m_rareNonInheritedData-&gt;marquee-&gt;increment; }
 583     int marqueeSpeed() const { return m_rareNonInheritedData-&gt;marquee-&gt;speed; }
 584     int marqueeLoopCount() const { return m_rareNonInheritedData-&gt;marquee-&gt;loops; }
 585     MarqueeBehavior marqueeBehavior() const { return static_cast&lt;MarqueeBehavior&gt;(m_rareNonInheritedData-&gt;marquee-&gt;behavior); }
 586     MarqueeDirection marqueeDirection() const { return static_cast&lt;MarqueeDirection&gt;(m_rareNonInheritedData-&gt;marquee-&gt;direction); }
 587     UserModify userModify() const { return static_cast&lt;UserModify&gt;(m_rareInheritedData-&gt;userModify); }
 588     UserDrag userDrag() const { return static_cast&lt;UserDrag&gt;(m_rareNonInheritedData-&gt;userDrag); }
 589     UserSelect userSelect() const { return static_cast&lt;UserSelect&gt;(m_rareInheritedData-&gt;userSelect); }
 590     TextOverflow textOverflow() const { return static_cast&lt;TextOverflow&gt;(m_rareNonInheritedData-&gt;textOverflow); }
 591     MarginCollapse marginBeforeCollapse() const { return static_cast&lt;MarginCollapse&gt;(m_rareNonInheritedData-&gt;marginBeforeCollapse); }
 592     MarginCollapse marginAfterCollapse() const { return static_cast&lt;MarginCollapse&gt;(m_rareNonInheritedData-&gt;marginAfterCollapse); }
 593     WordBreak wordBreak() const { return static_cast&lt;WordBreak&gt;(m_rareInheritedData-&gt;wordBreak); }
 594     OverflowWrap overflowWrap() const { return static_cast&lt;OverflowWrap&gt;(m_rareInheritedData-&gt;overflowWrap); }
 595     NBSPMode nbspMode() const { return static_cast&lt;NBSPMode&gt;(m_rareInheritedData-&gt;nbspMode); }
 596     LineBreak lineBreak() const { return static_cast&lt;LineBreak&gt;(m_rareInheritedData-&gt;lineBreak); }
 597     Hyphens hyphens() const { return static_cast&lt;Hyphens&gt;(m_rareInheritedData-&gt;hyphens); }
 598     short hyphenationLimitBefore() const { return m_rareInheritedData-&gt;hyphenationLimitBefore; }
 599     short hyphenationLimitAfter() const { return m_rareInheritedData-&gt;hyphenationLimitAfter; }
 600     short hyphenationLimitLines() const { return m_rareInheritedData-&gt;hyphenationLimitLines; }
 601     const AtomString&amp; hyphenationString() const { return m_rareInheritedData-&gt;hyphenationString; }
 602     const AtomString&amp; locale() const { return fontDescription().locale(); }
 603     BorderFit borderFit() const { return static_cast&lt;BorderFit&gt;(m_rareNonInheritedData-&gt;borderFit); }
 604     Resize resize() const { return static_cast&lt;Resize&gt;(m_rareNonInheritedData-&gt;resize); }
 605     ColumnAxis columnAxis() const { return static_cast&lt;ColumnAxis&gt;(m_rareNonInheritedData-&gt;multiCol-&gt;axis); }
 606     bool hasInlineColumnAxis() const;
 607     ColumnProgression columnProgression() const { return static_cast&lt;ColumnProgression&gt;(m_rareNonInheritedData-&gt;multiCol-&gt;progression); }
 608     float columnWidth() const { return m_rareNonInheritedData-&gt;multiCol-&gt;width; }
 609     bool hasAutoColumnWidth() const { return m_rareNonInheritedData-&gt;multiCol-&gt;autoWidth; }
 610     unsigned short columnCount() const { return m_rareNonInheritedData-&gt;multiCol-&gt;count; }
 611     bool hasAutoColumnCount() const { return m_rareNonInheritedData-&gt;multiCol-&gt;autoCount; }
 612     bool specifiesColumns() const { return !hasAutoColumnCount() || !hasAutoColumnWidth() || !hasInlineColumnAxis(); }
 613     ColumnFill columnFill() const { return static_cast&lt;ColumnFill&gt;(m_rareNonInheritedData-&gt;multiCol-&gt;fill); }
 614     const GapLength&amp; columnGap() const { return m_rareNonInheritedData-&gt;columnGap; }
 615     const GapLength&amp; rowGap() const { return m_rareNonInheritedData-&gt;rowGap; }
 616     BorderStyle columnRuleStyle() const { return m_rareNonInheritedData-&gt;multiCol-&gt;rule.style(); }
 617     unsigned short columnRuleWidth() const { return m_rareNonInheritedData-&gt;multiCol-&gt;ruleWidth(); }
 618     bool columnRuleIsTransparent() const { return m_rareNonInheritedData-&gt;multiCol-&gt;rule.isTransparent(); }
 619     ColumnSpan columnSpan() const { return static_cast&lt;ColumnSpan&gt;(m_rareNonInheritedData-&gt;multiCol-&gt;columnSpan); }
 620 
 621     const TransformOperations&amp; transform() const { return m_rareNonInheritedData-&gt;transform-&gt;operations; }
 622     bool hasTransform() const { return !m_rareNonInheritedData-&gt;transform-&gt;operations.operations().isEmpty(); }
 623     const Length&amp; transformOriginX() const { return m_rareNonInheritedData-&gt;transform-&gt;x; }
 624     const Length&amp; transformOriginY() const { return m_rareNonInheritedData-&gt;transform-&gt;y; }
 625     float transformOriginZ() const { return m_rareNonInheritedData-&gt;transform-&gt;z; }
 626     TransformBox transformBox() const { return m_rareNonInheritedData-&gt;transform-&gt;transformBox; }
 627 
 628     TextEmphasisFill textEmphasisFill() const { return static_cast&lt;TextEmphasisFill&gt;(m_rareInheritedData-&gt;textEmphasisFill); }
 629     TextEmphasisMark textEmphasisMark() const;
 630     const AtomString&amp; textEmphasisCustomMark() const { return m_rareInheritedData-&gt;textEmphasisCustomMark; }
 631     OptionSet&lt;TextEmphasisPosition&gt; textEmphasisPosition() const { return OptionSet&lt;TextEmphasisPosition&gt;::fromRaw(m_rareInheritedData-&gt;textEmphasisPosition); }
 632     const AtomString&amp; textEmphasisMarkString() const;
 633 
 634     RubyPosition rubyPosition() const { return static_cast&lt;RubyPosition&gt;(m_rareInheritedData-&gt;rubyPosition); }
 635 
 636 #if ENABLE(DARK_MODE_CSS)
 637     StyleColorScheme colorScheme() const { return m_rareInheritedData-&gt;colorScheme; }
 638     void setHasExplicitlySetColorScheme(bool v) { m_nonInheritedFlags.hasExplicitlySetColorScheme = v; }
 639     bool hasExplicitlySetColorScheme() const { return m_nonInheritedFlags.hasExplicitlySetColorScheme; };
 640 #endif
 641 
 642     TextOrientation textOrientation() const { return static_cast&lt;TextOrientation&gt;(m_rareInheritedData-&gt;textOrientation); }
 643 
 644     ObjectFit objectFit() const { return static_cast&lt;ObjectFit&gt;(m_rareNonInheritedData-&gt;objectFit); }
 645     LengthPoint objectPosition() const { return m_rareNonInheritedData-&gt;objectPosition; }
 646 
 647     // Return true if any transform related property (currently transform, transformStyle3D or perspective)
 648     // indicates that we are transforming.
 649     bool hasTransformRelatedProperty() const { return hasTransform() || preserves3D() || hasPerspective(); }
 650 
 651     enum ApplyTransformOrigin { IncludeTransformOrigin, ExcludeTransformOrigin };
 652     void applyTransform(TransformationMatrix&amp;, const FloatRect&amp; boundingBox, ApplyTransformOrigin = IncludeTransformOrigin) const;
 653     void setPageScaleTransform(float);
 654 
 655     bool hasMask() const { return m_rareNonInheritedData-&gt;mask.hasImage() || m_rareNonInheritedData-&gt;maskBoxImage.hasImage(); }
 656 
 657     TextCombine textCombine() const { return static_cast&lt;TextCombine&gt;(m_rareNonInheritedData-&gt;textCombine); }
 658     bool hasTextCombine() const { return textCombine() != TextCombine::None; }
 659 
 660     const TabSize&amp; tabSize() const { return m_rareInheritedData-&gt;tabSize; }
 661 
 662     // End CSS3 Getters
 663 
 664     const AtomString&amp; lineGrid() const { return m_rareInheritedData-&gt;lineGrid; }
 665     LineSnap lineSnap() const { return static_cast&lt;LineSnap&gt;(m_rareInheritedData-&gt;lineSnap); }
 666     LineAlign lineAlign() const { return static_cast&lt;LineAlign&gt;(m_rareInheritedData-&gt;lineAlign); }
 667 
 668     PointerEvents pointerEvents() const { return static_cast&lt;PointerEvents&gt;(m_inheritedFlags.pointerEvents); }
 669     const AnimationList* animations() const { return m_rareNonInheritedData-&gt;animations.get(); }
 670     const AnimationList* transitions() const { return m_rareNonInheritedData-&gt;transitions.get(); }
 671 
 672     AnimationList* animations() { return m_rareNonInheritedData-&gt;animations.get(); }
 673     AnimationList* transitions() { return m_rareNonInheritedData-&gt;transitions.get(); }
 674 
 675     bool hasAnimationsOrTransitions() const { return hasAnimations() || hasTransitions(); }
 676 
 677     AnimationList&amp; ensureAnimations();
 678     AnimationList&amp; ensureTransitions();
 679 
 680     bool hasAnimations() const { return m_rareNonInheritedData-&gt;animations &amp;&amp; m_rareNonInheritedData-&gt;animations-&gt;size() &gt; 0; }
 681     bool hasTransitions() const { return m_rareNonInheritedData-&gt;transitions &amp;&amp; m_rareNonInheritedData-&gt;transitions-&gt;size() &gt; 0; }
 682 
 683     // Return the first found Animation (including &#39;all&#39; transitions).
 684     const Animation* transitionForProperty(CSSPropertyID) const;
 685 
 686     TransformStyle3D transformStyle3D() const { return static_cast&lt;TransformStyle3D&gt;(m_rareNonInheritedData-&gt;transformStyle3D); }
 687     bool preserves3D() const { return transformStyle3D() == TransformStyle3D::Preserve3D; }
 688 
 689     BackfaceVisibility backfaceVisibility() const { return static_cast&lt;BackfaceVisibility&gt;(m_rareNonInheritedData-&gt;backfaceVisibility); }
 690     float perspective() const { return m_rareNonInheritedData-&gt;perspective; }
 691     bool hasPerspective() const { return m_rareNonInheritedData-&gt;perspective &gt; 0; }
 692     const Length&amp; perspectiveOriginX() const { return m_rareNonInheritedData-&gt;perspectiveOriginX; }
 693     const Length&amp; perspectiveOriginY() const { return m_rareNonInheritedData-&gt;perspectiveOriginY; }
 694     const LengthSize&amp; pageSize() const { return m_rareNonInheritedData-&gt;pageSize; }
 695     PageSizeType pageSizeType() const { return static_cast&lt;PageSizeType&gt;(m_rareNonInheritedData-&gt;pageSizeType); }
 696 
 697     LineBoxContain lineBoxContain() const { return m_rareInheritedData-&gt;lineBoxContain; }
 698     const LineClampValue&amp; lineClamp() const { return m_rareNonInheritedData-&gt;lineClamp; }
 699     const IntSize&amp; initialLetter() const { return m_rareNonInheritedData-&gt;initialLetter; }
 700     int initialLetterDrop() const { return initialLetter().width(); }
 701     int initialLetterHeight() const { return initialLetter().height(); }
 702 
 703 #if ENABLE(POINTER_EVENTS)
 704     OptionSet&lt;TouchAction&gt; touchActions() const { return OptionSet&lt;TouchAction&gt;::fromRaw(m_rareNonInheritedData-&gt;touchActions); }
 705     // &#39;touch-action&#39; behavior depends on values in ancestors. We use an additional inherited property to implement that.
 706     OptionSet&lt;TouchAction&gt; effectiveTouchActions() const { return OptionSet&lt;TouchAction&gt;::fromRaw(m_rareInheritedData-&gt;effectiveTouchActions); }
 707 #endif
 708 
 709 #if ENABLE(CSS_SCROLL_SNAP)
 710     // Scroll snap port style.
 711     const StyleScrollSnapPort&amp; scrollSnapPort() const;
 712     const ScrollSnapType&amp; scrollSnapType() const;
 713     const LengthBox&amp; scrollPadding() const;
 714     const Length&amp; scrollPaddingTop() const;
 715     const Length&amp; scrollPaddingBottom() const;
 716     const Length&amp; scrollPaddingLeft() const;
 717     const Length&amp; scrollPaddingRight() const;
 718 
 719     // Scroll snap area style.
 720     const StyleScrollSnapArea&amp; scrollSnapArea() const;
 721     const ScrollSnapAlign&amp; scrollSnapAlign() const;
 722     const LengthBox&amp; scrollSnapMargin() const;
 723     const Length&amp; scrollSnapMarginTop() const;
 724     const Length&amp; scrollSnapMarginBottom() const;
 725     const Length&amp; scrollSnapMarginLeft() const;
 726     const Length&amp; scrollSnapMarginRight() const;
 727 #endif
 728 
 729 #if ENABLE(TOUCH_EVENTS)
 730     Color tapHighlightColor() const { return m_rareInheritedData-&gt;tapHighlightColor; }
 731 #endif
 732 
 733 #if PLATFORM(IOS_FAMILY)
 734     bool touchCalloutEnabled() const { return m_rareInheritedData-&gt;touchCalloutEnabled; }
 735 #endif
 736 
 737 #if ENABLE(OVERFLOW_SCROLLING_TOUCH)
 738     bool useTouchOverflowScrolling() const { return m_rareInheritedData-&gt;useTouchOverflowScrolling; }
 739 #endif
 740 
 741 #if ENABLE(TEXT_AUTOSIZING)
 742     TextSizeAdjustment textSizeAdjust() const { return m_rareInheritedData-&gt;textSizeAdjust; }
 743     AutosizeStatus autosizeStatus() const;
 744     bool isIdempotentTextAutosizingCandidate() const;
 745 #endif
 746 
 747     TextSecurity textSecurity() const { return static_cast&lt;TextSecurity&gt;(m_rareInheritedData-&gt;textSecurity); }
 748 
 749     WritingMode writingMode() const { return static_cast&lt;WritingMode&gt;(m_inheritedFlags.writingMode); }
 750     bool isHorizontalWritingMode() const { return WebCore::isHorizontalWritingMode(writingMode()); }
 751     bool isVerticalWritingMode() const { return WebCore::isVerticalWritingMode(writingMode()); }
 752     bool isFlippedLinesWritingMode() const { return WebCore::isFlippedLinesWritingMode(writingMode()); }
 753     bool isFlippedBlocksWritingMode() const { return WebCore::isFlippedWritingMode(writingMode()); }
 754 
 755     ImageOrientation imageOrientation() const;
 756 
 757     ImageRendering imageRendering() const { return static_cast&lt;ImageRendering&gt;(m_rareInheritedData-&gt;imageRendering); }
 758 
 759 #if ENABLE(CSS_IMAGE_RESOLUTION)
 760     ImageResolutionSource imageResolutionSource() const { return static_cast&lt;ImageResolutionSource&gt;(m_rareInheritedData-&gt;imageResolutionSource); }
 761     ImageResolutionSnap imageResolutionSnap() const { return static_cast&lt;ImageResolutionSnap&gt;(m_rareInheritedData-&gt;imageResolutionSnap); }
 762     float imageResolution() const { return m_rareInheritedData-&gt;imageResolution; }
 763 #endif
 764 
 765     OptionSet&lt;SpeakAs&gt; speakAs() const { return OptionSet&lt;SpeakAs&gt;::fromRaw(m_rareInheritedData-&gt;speakAs); }
 766 
 767     FilterOperations&amp; mutableFilter() { return m_rareNonInheritedData.access().filter.access().operations; }
 768     const FilterOperations&amp; filter() const { return m_rareNonInheritedData-&gt;filter-&gt;operations; }
 769     bool hasFilter() const { return !m_rareNonInheritedData-&gt;filter-&gt;operations.operations().isEmpty(); }
 770     bool hasReferenceFilterOnly() const;
 771 
 772     FilterOperations&amp; mutableAppleColorFilter() { return m_rareInheritedData.access().appleColorFilter.access().operations; }
 773     const FilterOperations&amp; appleColorFilter() const { return m_rareInheritedData-&gt;appleColorFilter-&gt;operations; }
 774     bool hasAppleColorFilter() const { return !m_rareInheritedData-&gt;appleColorFilter-&gt;operations.operations().isEmpty(); }
 775 
 776 #if ENABLE(FILTERS_LEVEL_2)
 777     FilterOperations&amp; mutableBackdropFilter() { return m_rareNonInheritedData.access().backdropFilter.access().operations; }
 778     const FilterOperations&amp; backdropFilter() const { return m_rareNonInheritedData-&gt;backdropFilter-&gt;operations; }
 779     bool hasBackdropFilter() const { return !m_rareNonInheritedData-&gt;backdropFilter-&gt;operations.operations().isEmpty(); }
 780 #else
 781     bool hasBackdropFilter() const { return false; }
 782 #endif
 783 
 784 #if ENABLE(CSS_COMPOSITING)
 785     BlendMode blendMode() const { return static_cast&lt;BlendMode&gt;(m_rareNonInheritedData-&gt;effectiveBlendMode); }
 786     void setBlendMode(BlendMode mode) { SET_VAR(m_rareNonInheritedData, effectiveBlendMode, static_cast&lt;unsigned&gt;(mode)); }
 787     bool hasBlendMode() const { return static_cast&lt;BlendMode&gt;(m_rareNonInheritedData-&gt;effectiveBlendMode) != BlendMode::Normal; }
 788 
 789     Isolation isolation() const { return static_cast&lt;Isolation&gt;(m_rareNonInheritedData-&gt;isolation); }
 790     void setIsolation(Isolation isolation) { SET_VAR(m_rareNonInheritedData, isolation, static_cast&lt;unsigned&gt;(isolation)); }
 791     bool hasIsolation() const { return isolation() != Isolation::Auto; }
 792 #else
 793     BlendMode blendMode() const { return BlendMode::Normal; }
 794     bool hasBlendMode() const { return false; }
 795 
 796     Isolation isolation() const { return Isolation::Auto; }
 797     bool hasIsolation() const { return false; }
 798 #endif
 799 
 800     bool shouldPlaceBlockDirectionScrollbarOnLeft() const;
 801 
 802 #if ENABLE(CSS_TRAILING_WORD)
 803     TrailingWord trailingWord() const { return TrailingWord::Auto; }
 804 #endif
 805 
 806 #if ENABLE(APPLE_PAY)
 807     ApplePayButtonStyle applePayButtonStyle() const { return static_cast&lt;ApplePayButtonStyle&gt;(m_rareNonInheritedData-&gt;applePayButtonStyle); }
 808     ApplePayButtonType applePayButtonType() const { return static_cast&lt;ApplePayButtonType&gt;(m_rareNonInheritedData-&gt;applePayButtonType); }
 809 #endif
 810 
 811 // attribute setter methods
 812 
 813     void setDisplay(DisplayType v) { m_nonInheritedFlags.effectiveDisplay = static_cast&lt;unsigned&gt;(v); }
 814     void setOriginalDisplay(DisplayType v) { m_nonInheritedFlags.originalDisplay = static_cast&lt;unsigned&gt;(v); }
 815     void setPosition(PositionType v) { m_nonInheritedFlags.position = static_cast&lt;unsigned&gt;(v); }
 816     void setFloating(Float v) { m_nonInheritedFlags.floating = static_cast&lt;unsigned&gt;(v); }
 817 
 818     void setLeft(Length&amp;&amp; length) { SET_VAR(m_surroundData, offset.left(), WTFMove(length)); }
 819     void setRight(Length&amp;&amp; length) { SET_VAR(m_surroundData, offset.right(), WTFMove(length)); }
 820     void setTop(Length&amp;&amp; length) { SET_VAR(m_surroundData, offset.top(), WTFMove(length)); }
 821     void setBottom(Length&amp;&amp; length) { SET_VAR(m_surroundData, offset.bottom(), WTFMove(length)); }
 822 
 823     void setWidth(Length&amp;&amp; length) { SET_VAR(m_boxData, m_width, WTFMove(length)); }
 824     void setHeight(Length&amp;&amp; length) { SET_VAR(m_boxData, m_height, WTFMove(length)); }
 825 
 826     void setLogicalWidth(Length&amp;&amp;);
 827     void setLogicalHeight(Length&amp;&amp;);
 828 
 829     void setMinWidth(Length&amp;&amp; length) { SET_VAR(m_boxData, m_minWidth, WTFMove(length)); }
 830     void setMaxWidth(Length&amp;&amp; length) { SET_VAR(m_boxData, m_maxWidth, WTFMove(length)); }
 831     void setMinHeight(Length&amp;&amp; length) { SET_VAR(m_boxData, m_minHeight, WTFMove(length)); }
 832     void setMaxHeight(Length&amp;&amp; length) { SET_VAR(m_boxData, m_maxHeight, WTFMove(length)); }
 833 
 834     void resetBorder() { resetBorderImage(); resetBorderTop(); resetBorderRight(); resetBorderBottom(); resetBorderLeft(); resetBorderRadius(); }
 835     void resetBorderTop() { SET_VAR(m_surroundData, border.m_top, BorderValue()); }
 836     void resetBorderRight() { SET_VAR(m_surroundData, border.m_right, BorderValue()); }
 837     void resetBorderBottom() { SET_VAR(m_surroundData, border.m_bottom, BorderValue()); }
 838     void resetBorderLeft() { SET_VAR(m_surroundData, border.m_left, BorderValue()); }
 839     void resetBorderImage() { SET_VAR(m_surroundData, border.m_image, NinePieceImage()); }
 840     void resetBorderRadius() { resetBorderTopLeftRadius(); resetBorderTopRightRadius(); resetBorderBottomLeftRadius(); resetBorderBottomRightRadius(); }
 841     void resetBorderTopLeftRadius() { SET_VAR(m_surroundData, border.m_topLeft, initialBorderRadius()); }
 842     void resetBorderTopRightRadius() { SET_VAR(m_surroundData, border.m_topRight, initialBorderRadius()); }
 843     void resetBorderBottomLeftRadius() { SET_VAR(m_surroundData, border.m_bottomLeft, initialBorderRadius()); }
 844     void resetBorderBottomRightRadius() { SET_VAR(m_surroundData, border.m_bottomRight, initialBorderRadius()); }
 845 
 846     void setBackgroundColor(const Color&amp; v) { SET_VAR(m_backgroundData, color, v); }
 847 
 848     void setBackgroundXPosition(Length&amp;&amp; length) { SET_VAR(m_backgroundData, background.m_xPosition, WTFMove(length)); }
 849     void setBackgroundYPosition(Length&amp;&amp; length) { SET_VAR(m_backgroundData, background.m_yPosition, WTFMove(length)); }
 850     void setBackgroundSize(FillSizeType b) { SET_VAR(m_backgroundData, background.m_sizeType, static_cast&lt;unsigned&gt;(b)); }
 851     void setBackgroundSizeLength(LengthSize&amp;&amp; size) { SET_VAR(m_backgroundData, background.m_sizeLength, WTFMove(size)); }
 852 
 853     void setBorderImage(const NinePieceImage&amp; b) { SET_VAR(m_surroundData, border.m_image, b); }
 854     void setBorderImageSource(RefPtr&lt;StyleImage&gt;&amp;&amp;);
 855     void setBorderImageSlices(LengthBox&amp;&amp;);
 856     void setBorderImageWidth(LengthBox&amp;&amp;);
 857     void setBorderImageOutset(LengthBox&amp;&amp;);
 858 
 859     void setBorderTopLeftRadius(LengthSize&amp;&amp; size) { SET_VAR(m_surroundData, border.m_topLeft, WTFMove(size)); }
 860     void setBorderTopRightRadius(LengthSize&amp;&amp; size) { SET_VAR(m_surroundData, border.m_topRight, WTFMove(size)); }
 861     void setBorderBottomLeftRadius(LengthSize&amp;&amp; size) { SET_VAR(m_surroundData, border.m_bottomLeft, WTFMove(size)); }
 862     void setBorderBottomRightRadius(LengthSize&amp;&amp; size) { SET_VAR(m_surroundData, border.m_bottomRight, WTFMove(size)); }
 863 
 864     void setBorderRadius(LengthSize&amp;&amp;);
 865     void setBorderRadius(const IntSize&amp;);
 866 
 867     RoundedRect getRoundedBorderFor(const LayoutRect&amp; borderRect, bool includeLogicalLeftEdge = true, bool includeLogicalRightEdge = true) const;
 868     RoundedRect getRoundedInnerBorderFor(const LayoutRect&amp; borderRect, bool includeLogicalLeftEdge = true, bool includeLogicalRightEdge = true) const;
 869 
 870     RoundedRect getRoundedInnerBorderFor(const LayoutRect&amp; borderRect, LayoutUnit topWidth, LayoutUnit bottomWidth,
 871         LayoutUnit leftWidth, LayoutUnit rightWidth, bool includeLogicalLeftEdge = true, bool includeLogicalRightEdge = true) const;
 872 
 873     void setBorderLeftWidth(float v) { SET_VAR(m_surroundData, border.m_left.m_width, v); }
 874     void setBorderLeftStyle(BorderStyle v) { SET_VAR(m_surroundData, border.m_left.m_style, static_cast&lt;unsigned&gt;(v)); }
 875     void setBorderLeftColor(const Color&amp; v) { SET_BORDERVALUE_COLOR(m_surroundData, border.m_left, v); }
 876     void setBorderRightWidth(float v) { SET_VAR(m_surroundData, border.m_right.m_width, v); }
 877     void setBorderRightStyle(BorderStyle v) { SET_VAR(m_surroundData, border.m_right.m_style, static_cast&lt;unsigned&gt;(v)); }
 878     void setBorderRightColor(const Color&amp; v) { SET_BORDERVALUE_COLOR(m_surroundData, border.m_right, v); }
 879     void setBorderTopWidth(float v) { SET_VAR(m_surroundData, border.m_top.m_width, v); }
 880     void setBorderTopStyle(BorderStyle v) { SET_VAR(m_surroundData, border.m_top.m_style, static_cast&lt;unsigned&gt;(v)); }
 881     void setBorderTopColor(const Color&amp; v) { SET_BORDERVALUE_COLOR(m_surroundData, border.m_top, v); }
 882     void setBorderBottomWidth(float v) { SET_VAR(m_surroundData, border.m_bottom.m_width, v); }
 883     void setBorderBottomStyle(BorderStyle v) { SET_VAR(m_surroundData, border.m_bottom.m_style, static_cast&lt;unsigned&gt;(v)); }
 884     void setBorderBottomColor(const Color&amp; v) { SET_BORDERVALUE_COLOR(m_surroundData, border.m_bottom, v); }
 885 
 886     void setOutlineWidth(float v) { SET_VAR(m_backgroundData, outline.m_width, v); }
 887     void setOutlineStyleIsAuto(OutlineIsAuto isAuto) { SET_VAR(m_backgroundData, outline.m_isAuto, static_cast&lt;unsigned&gt;(isAuto)); }
 888     void setOutlineStyle(BorderStyle v) { SET_VAR(m_backgroundData, outline.m_style, static_cast&lt;unsigned&gt;(v)); }
 889     void setOutlineColor(const Color&amp; v) { SET_BORDERVALUE_COLOR(m_backgroundData, outline, v); }
 890 
 891     void setOverflowX(Overflow v) { m_nonInheritedFlags.overflowX =  static_cast&lt;unsigned&gt;(v); }
 892     void setOverflowY(Overflow v) { m_nonInheritedFlags.overflowY = static_cast&lt;unsigned&gt;(v); }
 893     void setVisibility(Visibility v) { m_inheritedFlags.visibility = static_cast&lt;unsigned&gt;(v); }
 894     void setVerticalAlign(VerticalAlign v) { m_nonInheritedFlags.verticalAlign = static_cast&lt;unsigned&gt;(v); }
 895     void setVerticalAlignLength(Length&amp;&amp; length) { setVerticalAlign(VerticalAlign::Length); SET_VAR(m_boxData, m_verticalAlign, WTFMove(length)); }
 896 
 897     void setHasClip(bool b = true) { SET_VAR(m_visualData, hasClip, b); }
 898     void setClipLeft(Length&amp;&amp; length) { SET_VAR(m_visualData, clip.left(), WTFMove(length)); }
 899     void setClipRight(Length&amp;&amp; length) { SET_VAR(m_visualData, clip.right(), WTFMove(length)); }
 900     void setClipTop(Length&amp;&amp; length) { SET_VAR(m_visualData, clip.top(), WTFMove(length)); }
 901     void setClipBottom(Length&amp;&amp; length) { SET_VAR(m_visualData, clip.bottom(), WTFMove(length)); }
 902     void setClip(Length&amp;&amp; top, Length&amp;&amp; right, Length&amp;&amp; bottom, Length&amp;&amp; left);
 903     void setClip(LengthBox&amp;&amp; box) { SET_VAR(m_visualData, clip, WTFMove(box)); }
 904 
 905     void setUnicodeBidi(EUnicodeBidi v) { m_nonInheritedFlags.unicodeBidi = v; }
 906 
 907     void setClear(Clear v) { m_nonInheritedFlags.clear = static_cast&lt;unsigned&gt;(v); }
 908     void setTableLayout(TableLayoutType v) { m_nonInheritedFlags.tableLayout = static_cast&lt;unsigned&gt;(v); }
 909 
 910     bool setFontDescription(FontCascadeDescription&amp;&amp;);
 911 
 912     // Only used for blending font sizes when animating, for MathML anonymous blocks, and for text autosizing.
 913     void setFontSize(float);
 914 
 915 #if ENABLE(VARIATION_FONTS)
 916     void setFontVariationSettings(FontVariationSettings);
 917 #endif
 918     void setFontWeight(FontSelectionValue);
 919     void setFontStretch(FontSelectionValue);
 920     void setFontItalic(Optional&lt;FontSelectionValue&gt;);
 921 
 922     void setColor(const Color&amp;);
 923     void setTextIndent(Length&amp;&amp; length) { SET_VAR(m_rareInheritedData, indent, WTFMove(length)); }
 924     void setTextAlign(TextAlignMode v) { m_inheritedFlags.textAlign = static_cast&lt;unsigned&gt;(v); }
 925     void setTextTransform(TextTransform v) { m_inheritedFlags.textTransform = static_cast&lt;unsigned&gt;(v); }
 926     void addToTextDecorationsInEffect(OptionSet&lt;TextDecoration&gt; v) { m_inheritedFlags.textDecorations |= static_cast&lt;unsigned&gt;(v.toRaw()); }
 927     void setTextDecorationsInEffect(OptionSet&lt;TextDecoration&gt; v) { m_inheritedFlags.textDecorations = v.toRaw(); }
 928     void setTextDecoration(OptionSet&lt;TextDecoration&gt; v) { SET_VAR(m_visualData, textDecoration, v.toRaw()); }
 929     void setTextDecorationStyle(TextDecorationStyle v) { SET_VAR(m_rareNonInheritedData, textDecorationStyle, static_cast&lt;unsigned&gt;(v)); }
 930     void setTextDecorationSkip(OptionSet&lt;TextDecorationSkip&gt; skip) { SET_VAR(m_rareInheritedData, textDecorationSkip, skip.toRaw()); }
 931     void setTextUnderlinePosition(TextUnderlinePosition position) { SET_VAR(m_rareInheritedData, textUnderlinePosition, static_cast&lt;unsigned&gt;(position)); }
 932     void setTextUnderlineOffset(TextUnderlineOffset textUnderlineOffset) { SET_VAR(m_rareInheritedData, textUnderlineOffset, textUnderlineOffset); }
 933     void setTextDecorationThickness(TextDecorationThickness textDecorationThickness) { SET_VAR(m_rareInheritedData, textDecorationThickness, textDecorationThickness); }
 934     void setDirection(TextDirection v) { m_inheritedFlags.direction = static_cast&lt;unsigned&gt;(v); }
 935     void setHasExplicitlySetDirection(bool v) { m_nonInheritedFlags.hasExplicitlySetDirection = v; }
 936     void setLineHeight(Length&amp;&amp;);
 937     bool setZoom(float);
 938     void setZoomWithoutReturnValue(float f) { setZoom(f); }
 939     bool setEffectiveZoom(float);
 940     void setTextZoom(TextZoom v) { SET_VAR(m_rareInheritedData, textZoom, static_cast&lt;unsigned&gt;(v)); }
 941 
 942 #if ENABLE(CSS3_TEXT)
 943     void setTextIndentLine(TextIndentLine v) { SET_VAR(m_rareInheritedData, textIndentLine, v); }
 944     void setTextIndentType(TextIndentType v) { SET_VAR(m_rareInheritedData, textIndentType, v); }
 945     void setTextAlignLast(TextAlignLast v) { SET_VAR(m_rareInheritedData, textAlignLast, v); }
 946     void setTextJustify(TextJustify v) { SET_VAR(m_rareInheritedData, textJustify, v); }
 947 #endif
 948 
 949 #if ENABLE(TEXT_AUTOSIZING)
 950     void setSpecifiedLineHeight(Length&amp;&amp;);
 951 #endif
 952 
 953 #if ENABLE(CSS_IMAGE_ORIENTATION)
 954     void setImageOrientation(ImageOrientation v) { SET_VAR(m_rareInheritedData, imageOrientation, static_cast&lt;int&gt;(v)); }
 955 #endif
 956 
 957     void setImageRendering(ImageRendering v) { SET_VAR(m_rareInheritedData, imageRendering, static_cast&lt;unsigned&gt;(v)); }
 958 
 959 #if ENABLE(CSS_IMAGE_RESOLUTION)
 960     void setImageResolutionSource(ImageResolutionSource v) { SET_VAR(m_rareInheritedData, imageResolutionSource, v); }
 961     void setImageResolutionSnap(ImageResolutionSnap v) { SET_VAR(m_rareInheritedData, imageResolutionSnap, v); }
 962     void setImageResolution(float f) { SET_VAR(m_rareInheritedData, imageResolution, f); }
 963 #endif
 964 
 965     void setWhiteSpace(WhiteSpace v) { m_inheritedFlags.whiteSpace = static_cast&lt;unsigned&gt;(v); }
 966 
 967     void setWordSpacing(Length&amp;&amp;);
 968     void setLetterSpacing(float);
 969 
 970     void clearBackgroundLayers() { m_backgroundData.access().background = FillLayer(FillLayerType::Background); }
 971     void inheritBackgroundLayers(const FillLayer&amp; parent) { m_backgroundData.access().background = parent; }
 972 
 973     void adjustBackgroundLayers();
 974 
 975     void clearMaskLayers() { m_rareNonInheritedData.access().mask = FillLayer(FillLayerType::Mask); }
 976     void inheritMaskLayers(const FillLayer&amp; parent) { m_rareNonInheritedData.access().mask = parent; }
 977 
 978     void adjustMaskLayers();
 979 
 980     void setMaskImage(RefPtr&lt;StyleImage&gt;&amp;&amp; v) { m_rareNonInheritedData.access().mask.setImage(WTFMove(v)); }
 981 
 982     void setMaskBoxImage(const NinePieceImage&amp; b) { SET_VAR(m_rareNonInheritedData, maskBoxImage, b); }
 983     void setMaskBoxImageSource(RefPtr&lt;StyleImage&gt;&amp;&amp; v) { m_rareNonInheritedData.access().maskBoxImage.setImage(WTFMove(v)); }
 984     void setMaskXPosition(Length&amp;&amp; length) { SET_VAR(m_rareNonInheritedData, mask.m_xPosition, WTFMove(length)); }
 985     void setMaskYPosition(Length&amp;&amp; length) { SET_VAR(m_rareNonInheritedData, mask.m_yPosition, WTFMove(length)); }
 986     void setMaskSize(LengthSize size) { SET_VAR(m_rareNonInheritedData, mask.m_sizeLength, WTFMove(size)); }
 987 
 988     void setBorderCollapse(BorderCollapse collapse) { m_inheritedFlags.borderCollapse = static_cast&lt;unsigned&gt;(collapse); }
 989     void setHorizontalBorderSpacing(float);
 990     void setVerticalBorderSpacing(float);
 991     void setEmptyCells(EmptyCell v) { m_inheritedFlags.emptyCells = static_cast&lt;unsigned&gt;(v); }
 992     void setCaptionSide(CaptionSide v) { m_inheritedFlags.captionSide = static_cast&lt;unsigned&gt;(v); }
 993 
 994     void setAspectRatioType(AspectRatioType aspectRatioType) { SET_VAR(m_rareNonInheritedData, aspectRatioType, static_cast&lt;unsigned&gt;(aspectRatioType)); }
 995     void setAspectRatioDenominator(float v) { SET_VAR(m_rareNonInheritedData, aspectRatioDenominator, v); }
 996     void setAspectRatioNumerator(float v) { SET_VAR(m_rareNonInheritedData, aspectRatioNumerator, v); }
 997 
 998     void setListStyleType(ListStyleType v) { m_inheritedFlags.listStyleType = static_cast&lt;unsigned&gt;(v); }
 999     void setListStyleImage(RefPtr&lt;StyleImage&gt;&amp;&amp;);
1000     void setListStylePosition(ListStylePosition v) { m_inheritedFlags.listStylePosition = static_cast&lt;unsigned&gt;(v); }
1001 
1002     void resetMargin() { SET_VAR(m_surroundData, margin, LengthBox(Fixed)); }
1003     void setMarginTop(Length&amp;&amp; length) { SET_VAR(m_surroundData, margin.top(), WTFMove(length)); }
1004     void setMarginBottom(Length&amp;&amp; length) { SET_VAR(m_surroundData, margin.bottom(), WTFMove(length)); }
1005     void setMarginLeft(Length&amp;&amp; length) { SET_VAR(m_surroundData, margin.left(), WTFMove(length)); }
1006     void setMarginRight(Length&amp;&amp; length) { SET_VAR(m_surroundData, margin.right(), WTFMove(length)); }
1007     void setMarginStart(Length&amp;&amp;);
1008     void setMarginEnd(Length&amp;&amp;);
1009 
1010     void resetPadding() { SET_VAR(m_surroundData, padding, LengthBox(Auto)); }
1011     void setPaddingBox(LengthBox&amp;&amp; box) { SET_VAR(m_surroundData, padding, WTFMove(box)); }
1012     void setPaddingTop(Length&amp;&amp; length) { SET_VAR(m_surroundData, padding.top(), WTFMove(length)); }
1013     void setPaddingBottom(Length&amp;&amp; length) { SET_VAR(m_surroundData, padding.bottom(), WTFMove(length)); }
1014     void setPaddingLeft(Length&amp;&amp; length) { SET_VAR(m_surroundData, padding.left(), WTFMove(length)); }
1015     void setPaddingRight(Length&amp;&amp; length) { SET_VAR(m_surroundData, padding.right(), WTFMove(length)); }
1016 
1017     void setCursor(CursorType c) { m_inheritedFlags.cursor = static_cast&lt;unsigned&gt;(c); }
1018     void addCursor(RefPtr&lt;StyleImage&gt;&amp;&amp;, const IntPoint&amp; hotSpot = IntPoint());
1019     void setCursorList(RefPtr&lt;CursorList&gt;&amp;&amp;);
1020     void clearCursorList();
1021 
1022 #if ENABLE(CURSOR_VISIBILITY)
1023     void setCursorVisibility(CursorVisibility c) { m_inheritedFlags.cursorVisibility = static_cast&lt;unsigned&gt;(c); }
1024 #endif
1025 
1026     void setInsideLink(InsideLink insideLink) { m_inheritedFlags.insideLink = static_cast&lt;unsigned&gt;(insideLink); }
1027     void setIsLink(bool v) { m_nonInheritedFlags.isLink = v; }
1028 
1029     void setInsideDefaultButton(bool insideDefaultButton) { m_inheritedFlags.insideDefaultButton = insideDefaultButton; }
1030 
1031     PrintColorAdjust printColorAdjust() const { return static_cast&lt;PrintColorAdjust&gt;(m_inheritedFlags.printColorAdjust); }
1032     void setPrintColorAdjust(PrintColorAdjust value) { m_inheritedFlags.printColorAdjust = static_cast&lt;unsigned&gt;(value); }
1033 
1034     bool hasAutoZIndex() const { return m_boxData-&gt;hasAutoZIndex(); }
1035     void setHasAutoZIndex() { SET_VAR(m_boxData, m_hasAutoZIndex, true); SET_VAR(m_boxData, m_zIndex, 0); }
1036     int zIndex() const { return m_boxData-&gt;zIndex(); }
1037     void setZIndex(int v) { SET_VAR(m_boxData, m_hasAutoZIndex, false); SET_VAR(m_boxData, m_zIndex, v); }
1038 
1039     void setHasAutoWidows() { SET_VAR(m_rareInheritedData, hasAutoWidows, true); SET_VAR(m_rareInheritedData, widows, initialWidows()); }
1040     void setWidows(short w) { SET_VAR(m_rareInheritedData, hasAutoWidows, false); SET_VAR(m_rareInheritedData, widows, w); }
1041 
1042     void setHasAutoOrphans() { SET_VAR(m_rareInheritedData, hasAutoOrphans, true); SET_VAR(m_rareInheritedData, orphans, initialOrphans()); }
1043     void setOrphans(short o) { SET_VAR(m_rareInheritedData, hasAutoOrphans, false); SET_VAR(m_rareInheritedData, orphans, o); }
1044 
1045     // CSS3 Setters
1046     void setOutlineOffset(float v) { SET_VAR(m_backgroundData, outline.m_offset, v); }
1047     void setTextShadow(std::unique_ptr&lt;ShadowData&gt;, bool add = false);
1048     void setTextStrokeColor(const Color&amp; c) { SET_VAR(m_rareInheritedData, textStrokeColor, c); }
1049     void setTextStrokeWidth(float w) { SET_VAR(m_rareInheritedData, textStrokeWidth, w); }
1050     void setTextFillColor(const Color&amp; c) { SET_VAR(m_rareInheritedData, textFillColor, c); }
1051     void setCaretColor(const Color&amp; c) { SET_VAR(m_rareInheritedData, caretColor, c); }
1052     void setOpacity(float f) { float v = clampTo&lt;float&gt;(f, 0.f, 1.f); SET_VAR(m_rareNonInheritedData, opacity, v); }
1053     void setAppearance(ControlPart a) { SET_VAR(m_rareNonInheritedData, appearance, a); }
1054     // For valid values of box-align see http://www.w3.org/TR/2009/WD-css3-flexbox-20090723/#alignment
1055     void setBoxAlign(BoxAlignment a) { SET_NESTED_VAR(m_rareNonInheritedData, deprecatedFlexibleBox, align, static_cast&lt;unsigned&gt;(a)); }
1056     void setBoxDirection(BoxDirection d) { m_inheritedFlags.boxDirection = static_cast&lt;unsigned&gt;(d); }
1057     void setBoxFlex(float f) { SET_NESTED_VAR(m_rareNonInheritedData, deprecatedFlexibleBox, flex, f); }
1058     void setBoxFlexGroup(unsigned group) { SET_NESTED_VAR(m_rareNonInheritedData, deprecatedFlexibleBox, flexGroup, group); }
1059     void setBoxLines(BoxLines lines) { SET_NESTED_VAR(m_rareNonInheritedData, deprecatedFlexibleBox, lines, static_cast&lt;unsigned&gt;(lines)); }
1060     void setBoxOrdinalGroup(unsigned group) { SET_NESTED_VAR(m_rareNonInheritedData, deprecatedFlexibleBox, ordinalGroup, group); }
1061     void setBoxOrient(BoxOrient o) { SET_NESTED_VAR(m_rareNonInheritedData, deprecatedFlexibleBox, orient, static_cast&lt;unsigned&gt;(o)); }
1062     void setBoxPack(BoxPack p) { SET_NESTED_VAR(m_rareNonInheritedData, deprecatedFlexibleBox, pack, static_cast&lt;unsigned&gt;(p)); }
1063     void setBoxShadow(std::unique_ptr&lt;ShadowData&gt;, bool add = false);
1064     void setBoxReflect(RefPtr&lt;StyleReflection&gt;&amp;&amp;);
1065     void setBoxSizing(BoxSizing s) { SET_VAR(m_boxData, m_boxSizing, static_cast&lt;unsigned&gt;(s)); }
1066     void setFlexGrow(float f) { SET_NESTED_VAR(m_rareNonInheritedData, flexibleBox, flexGrow, f); }
1067     void setFlexShrink(float f) { SET_NESTED_VAR(m_rareNonInheritedData, flexibleBox, flexShrink, f); }
1068     void setFlexBasis(Length&amp;&amp; length) { SET_NESTED_VAR(m_rareNonInheritedData, flexibleBox, flexBasis, WTFMove(length)); }
1069     void setOrder(int o) { SET_VAR(m_rareNonInheritedData, order, o); }
1070     void setAlignContent(const StyleContentAlignmentData&amp; data) { SET_VAR(m_rareNonInheritedData, alignContent, data); }
1071     void setAlignItems(const StyleSelfAlignmentData&amp; data) { SET_VAR(m_rareNonInheritedData, alignItems, data); }
1072     void setAlignItemsPosition(ItemPosition position) { m_rareNonInheritedData.access().alignItems.setPosition(position); }
1073     void setAlignSelf(const StyleSelfAlignmentData&amp; data) { SET_VAR(m_rareNonInheritedData, alignSelf, data); }
1074     void setAlignSelfPosition(ItemPosition position) { m_rareNonInheritedData.access().alignSelf.setPosition(position); }
1075     void setFlexDirection(FlexDirection direction) { SET_NESTED_VAR(m_rareNonInheritedData, flexibleBox, flexDirection, static_cast&lt;unsigned&gt;(direction)); }
1076     void setFlexWrap(FlexWrap w) { SET_NESTED_VAR(m_rareNonInheritedData, flexibleBox, flexWrap, static_cast&lt;unsigned&gt;(w)); }
1077     void setJustifyContent(const StyleContentAlignmentData&amp; data) { SET_VAR(m_rareNonInheritedData, justifyContent, data); }
1078     void setJustifyContentPosition(ContentPosition position) { m_rareNonInheritedData.access().justifyContent.setPosition(position); }
1079     void setJustifyItems(const StyleSelfAlignmentData&amp; data) { SET_VAR(m_rareNonInheritedData, justifyItems, data); }
1080     void setJustifySelf(const StyleSelfAlignmentData&amp; data) { SET_VAR(m_rareNonInheritedData, justifySelf, data); }
1081     void setJustifySelfPosition(ItemPosition position) { m_rareNonInheritedData.access().justifySelf.setPosition(position); }
1082 
1083 #if ENABLE(CSS_BOX_DECORATION_BREAK)
1084     void setBoxDecorationBreak(BoxDecorationBreak b) { SET_VAR(m_boxData, m_boxDecorationBreak, static_cast&lt;unsigned&gt;(b)); }
1085 #endif
1086 
1087     void setGridAutoColumns(const Vector&lt;GridTrackSize&gt;&amp; trackSizeList) { SET_NESTED_VAR(m_rareNonInheritedData, grid, gridAutoColumns, trackSizeList); }
1088     void setGridAutoRows(const Vector&lt;GridTrackSize&gt;&amp; trackSizeList) { SET_NESTED_VAR(m_rareNonInheritedData, grid, gridAutoRows, trackSizeList); }
1089     void setGridColumns(const Vector&lt;GridTrackSize&gt;&amp; lengths) { SET_NESTED_VAR(m_rareNonInheritedData, grid, gridColumns, lengths); }
1090     void setGridRows(const Vector&lt;GridTrackSize&gt;&amp; lengths) { SET_NESTED_VAR(m_rareNonInheritedData, grid, gridRows, lengths); }
1091     void setGridAutoRepeatColumns(const Vector&lt;GridTrackSize&gt;&amp; lengths) { SET_NESTED_VAR(m_rareNonInheritedData, grid, gridAutoRepeatColumns, lengths); }
1092     void setGridAutoRepeatRows(const Vector&lt;GridTrackSize&gt;&amp; lengths) { SET_NESTED_VAR(m_rareNonInheritedData, grid, gridAutoRepeatRows, lengths); }
1093     void setGridAutoRepeatColumnsInsertionPoint(const unsigned insertionPoint) { SET_NESTED_VAR(m_rareNonInheritedData, grid, autoRepeatColumnsInsertionPoint, insertionPoint); }
1094     void setGridAutoRepeatRowsInsertionPoint(const unsigned insertionPoint) { SET_NESTED_VAR(m_rareNonInheritedData, grid, autoRepeatRowsInsertionPoint, insertionPoint); }
1095     void setGridAutoRepeatColumnsType(const AutoRepeatType autoRepeatType) { SET_NESTED_VAR(m_rareNonInheritedData, grid, autoRepeatColumnsType, autoRepeatType); }
1096     void setGridAutoRepeatRowsType(const AutoRepeatType autoRepeatType) { SET_NESTED_VAR(m_rareNonInheritedData, grid, autoRepeatRowsType, autoRepeatType); }
1097     void setNamedGridColumnLines(const NamedGridLinesMap&amp; namedGridColumnLines) { SET_NESTED_VAR(m_rareNonInheritedData, grid, namedGridColumnLines, namedGridColumnLines); }
1098     void setNamedGridRowLines(const NamedGridLinesMap&amp; namedGridRowLines) { SET_NESTED_VAR(m_rareNonInheritedData, grid, namedGridRowLines, namedGridRowLines); }
1099     void setOrderedNamedGridColumnLines(const OrderedNamedGridLinesMap&amp; orderedNamedGridColumnLines) { SET_NESTED_VAR(m_rareNonInheritedData, grid, orderedNamedGridColumnLines, orderedNamedGridColumnLines); }
1100     void setOrderedNamedGridRowLines(const OrderedNamedGridLinesMap&amp; orderedNamedGridRowLines) { SET_NESTED_VAR(m_rareNonInheritedData, grid, orderedNamedGridRowLines, orderedNamedGridRowLines); }
1101     void setAutoRepeatNamedGridColumnLines(const NamedGridLinesMap&amp; namedGridColumnLines) { SET_NESTED_VAR(m_rareNonInheritedData, grid, autoRepeatNamedGridColumnLines, namedGridColumnLines); }
1102     void setAutoRepeatNamedGridRowLines(const NamedGridLinesMap&amp; namedGridRowLines) { SET_NESTED_VAR(m_rareNonInheritedData, grid, autoRepeatNamedGridRowLines, namedGridRowLines); }
1103     void setAutoRepeatOrderedNamedGridColumnLines(const OrderedNamedGridLinesMap&amp; orderedNamedGridColumnLines) { SET_NESTED_VAR(m_rareNonInheritedData, grid, autoRepeatOrderedNamedGridColumnLines, orderedNamedGridColumnLines); }
1104     void setAutoRepeatOrderedNamedGridRowLines(const OrderedNamedGridLinesMap&amp; orderedNamedGridRowLines) { SET_NESTED_VAR(m_rareNonInheritedData, grid, autoRepeatOrderedNamedGridRowLines, orderedNamedGridRowLines); }
1105     void setNamedGridArea(const NamedGridAreaMap&amp; namedGridArea) { SET_NESTED_VAR(m_rareNonInheritedData, grid, namedGridArea, namedGridArea); }
1106     void setNamedGridAreaRowCount(size_t rowCount) { SET_NESTED_VAR(m_rareNonInheritedData, grid, namedGridAreaRowCount, rowCount); }
1107     void setNamedGridAreaColumnCount(size_t columnCount) { SET_NESTED_VAR(m_rareNonInheritedData, grid, namedGridAreaColumnCount, columnCount); }
1108     void setGridAutoFlow(GridAutoFlow flow) { SET_NESTED_VAR(m_rareNonInheritedData, grid, gridAutoFlow, flow); }
1109     void setGridItemColumnStart(const GridPosition&amp; columnStartPosition) { SET_NESTED_VAR(m_rareNonInheritedData, gridItem, gridColumnStart, columnStartPosition); }
1110     void setGridItemColumnEnd(const GridPosition&amp; columnEndPosition) { SET_NESTED_VAR(m_rareNonInheritedData, gridItem, gridColumnEnd, columnEndPosition); }
1111     void setGridItemRowStart(const GridPosition&amp; rowStartPosition) { SET_NESTED_VAR(m_rareNonInheritedData, gridItem, gridRowStart, rowStartPosition); }
1112     void setGridItemRowEnd(const GridPosition&amp; rowEndPosition) { SET_NESTED_VAR(m_rareNonInheritedData, gridItem, gridRowEnd, rowEndPosition); }
1113 
1114     void setMarqueeIncrement(Length&amp;&amp; length) { SET_NESTED_VAR(m_rareNonInheritedData, marquee, increment, WTFMove(length)); }
1115     void setMarqueeSpeed(int f) { SET_NESTED_VAR(m_rareNonInheritedData, marquee, speed, f); }
1116     void setMarqueeDirection(MarqueeDirection d) { SET_NESTED_VAR(m_rareNonInheritedData, marquee, direction, static_cast&lt;unsigned&gt;(d)); }
1117     void setMarqueeBehavior(MarqueeBehavior b) { SET_NESTED_VAR(m_rareNonInheritedData, marquee, behavior, static_cast&lt;unsigned&gt;(b)); }
1118     void setMarqueeLoopCount(int i) { SET_NESTED_VAR(m_rareNonInheritedData, marquee, loops, i); }
1119     void setUserModify(UserModify u) { SET_VAR(m_rareInheritedData, userModify, static_cast&lt;unsigned&gt;(u)); }
1120     void setUserDrag(UserDrag d) { SET_VAR(m_rareNonInheritedData, userDrag, static_cast&lt;unsigned&gt;(d)); }
1121     void setUserSelect(UserSelect s) { SET_VAR(m_rareInheritedData, userSelect, static_cast&lt;unsigned&gt;(s)); }
1122     void setTextOverflow(TextOverflow overflow) { SET_VAR(m_rareNonInheritedData, textOverflow, static_cast&lt;unsigned&gt;(overflow)); }
1123     void setMarginBeforeCollapse(MarginCollapse c) { SET_VAR(m_rareNonInheritedData, marginBeforeCollapse, static_cast&lt;unsigned&gt;(c)); }
1124     void setMarginAfterCollapse(MarginCollapse c) { SET_VAR(m_rareNonInheritedData, marginAfterCollapse, static_cast&lt;unsigned&gt;(c)); }
1125     void setWordBreak(WordBreak b) { SET_VAR(m_rareInheritedData, wordBreak, static_cast&lt;unsigned&gt;(b)); }
1126     void setOverflowWrap(OverflowWrap b) { SET_VAR(m_rareInheritedData, overflowWrap, static_cast&lt;unsigned&gt;(b)); }
1127     void setNBSPMode(NBSPMode b) { SET_VAR(m_rareInheritedData, nbspMode, static_cast&lt;unsigned&gt;(b)); }
1128     void setLineBreak(LineBreak b) { SET_VAR(m_rareInheritedData, lineBreak, static_cast&lt;unsigned&gt;(b)); }
1129     void setHyphens(Hyphens h) { SET_VAR(m_rareInheritedData, hyphens, static_cast&lt;unsigned&gt;(h)); }
1130     void setHyphenationLimitBefore(short limit) { SET_VAR(m_rareInheritedData, hyphenationLimitBefore, limit); }
1131     void setHyphenationLimitAfter(short limit) { SET_VAR(m_rareInheritedData, hyphenationLimitAfter, limit); }
1132     void setHyphenationLimitLines(short limit) { SET_VAR(m_rareInheritedData, hyphenationLimitLines, limit); }
1133     void setHyphenationString(const AtomString&amp; h) { SET_VAR(m_rareInheritedData, hyphenationString, h); }
1134     void setBorderFit(BorderFit b) { SET_VAR(m_rareNonInheritedData, borderFit, static_cast&lt;unsigned&gt;(b)); }
1135     void setResize(Resize r) { SET_VAR(m_rareNonInheritedData, resize, static_cast&lt;unsigned&gt;(r)); }
1136     void setColumnAxis(ColumnAxis axis) { SET_NESTED_VAR(m_rareNonInheritedData, multiCol, axis, static_cast&lt;unsigned&gt;(axis)); }
1137     void setColumnProgression(ColumnProgression progression) { SET_NESTED_VAR(m_rareNonInheritedData, multiCol, progression, static_cast&lt;unsigned&gt;(progression)); }
1138     void setColumnWidth(float f) { SET_NESTED_VAR(m_rareNonInheritedData, multiCol, autoWidth, false); SET_NESTED_VAR(m_rareNonInheritedData, multiCol, width, f); }
1139     void setHasAutoColumnWidth() { SET_NESTED_VAR(m_rareNonInheritedData, multiCol, autoWidth, true); SET_NESTED_VAR(m_rareNonInheritedData, multiCol, width, 0); }
1140     void setColumnCount(unsigned short c) { SET_NESTED_VAR(m_rareNonInheritedData, multiCol, autoCount, false); SET_NESTED_VAR(m_rareNonInheritedData, multiCol, count, c); }
1141     void setHasAutoColumnCount() { SET_NESTED_VAR(m_rareNonInheritedData, multiCol, autoCount, true); SET_NESTED_VAR(m_rareNonInheritedData, multiCol, count, 0); }
1142     void setColumnFill(ColumnFill columnFill) { SET_NESTED_VAR(m_rareNonInheritedData, multiCol, fill, static_cast&lt;unsigned&gt;(columnFill)); }
1143     void setColumnGap(GapLength&amp;&amp; gapLength) { SET_VAR(m_rareNonInheritedData, columnGap, WTFMove(gapLength)); }
1144     void setRowGap(GapLength&amp;&amp; gapLength) { SET_VAR(m_rareNonInheritedData, rowGap, WTFMove(gapLength)); }
1145     void setColumnRuleColor(const Color&amp; c) { SET_BORDERVALUE_COLOR(m_rareNonInheritedData.access().multiCol, rule, c); }
1146     void setColumnRuleStyle(BorderStyle b) { SET_NESTED_VAR(m_rareNonInheritedData, multiCol, rule.m_style, static_cast&lt;unsigned&gt;(b)); }
1147     void setColumnRuleWidth(unsigned short w) { SET_NESTED_VAR(m_rareNonInheritedData, multiCol, rule.m_width, w); }
1148     void resetColumnRule() { SET_NESTED_VAR(m_rareNonInheritedData, multiCol, rule, BorderValue()); }
1149     void setColumnSpan(ColumnSpan columnSpan) { SET_NESTED_VAR(m_rareNonInheritedData, multiCol, columnSpan, static_cast&lt;unsigned&gt;(columnSpan)); }
1150     void inheritColumnPropertiesFrom(const RenderStyle&amp; parent) { m_rareNonInheritedData.access().multiCol = parent.m_rareNonInheritedData-&gt;multiCol; }
1151 
1152     void setTransform(const TransformOperations&amp; ops) { SET_NESTED_VAR(m_rareNonInheritedData, transform, operations, ops); }
1153     void setTransformOriginX(Length&amp;&amp; length) { SET_NESTED_VAR(m_rareNonInheritedData, transform, x, WTFMove(length)); }
1154     void setTransformOriginY(Length&amp;&amp; length) { SET_NESTED_VAR(m_rareNonInheritedData, transform, y, WTFMove(length)); }
1155     void setTransformOriginZ(float f) { SET_NESTED_VAR(m_rareNonInheritedData, transform, z, f); }
1156     void setTransformBox(TransformBox box) { SET_NESTED_VAR(m_rareNonInheritedData, transform, transformBox, box); }
1157 
1158     void setSpeakAs(OptionSet&lt;SpeakAs&gt; s) { SET_VAR(m_rareInheritedData, speakAs, s.toRaw()); }
1159     void setTextCombine(TextCombine v) { SET_VAR(m_rareNonInheritedData, textCombine, static_cast&lt;unsigned&gt;(v)); }
1160     void setTextDecorationColor(const Color&amp; c) { SET_VAR(m_rareNonInheritedData, textDecorationColor, c); }
1161     void setTextEmphasisColor(const Color&amp; c) { SET_VAR(m_rareInheritedData, textEmphasisColor, c); }
1162     void setTextEmphasisFill(TextEmphasisFill fill) { SET_VAR(m_rareInheritedData, textEmphasisFill, static_cast&lt;unsigned&gt;(fill)); }
1163     void setTextEmphasisMark(TextEmphasisMark mark) { SET_VAR(m_rareInheritedData, textEmphasisMark, static_cast&lt;unsigned&gt;(mark)); }
1164     void setTextEmphasisCustomMark(const AtomString&amp; mark) { SET_VAR(m_rareInheritedData, textEmphasisCustomMark, mark); }
1165     void setTextEmphasisPosition(OptionSet&lt;TextEmphasisPosition&gt; position) { SET_VAR(m_rareInheritedData, textEmphasisPosition, static_cast&lt;unsigned&gt;(position.toRaw())); }
1166     bool setTextOrientation(TextOrientation);
1167 
1168     void setObjectFit(ObjectFit fit) { SET_VAR(m_rareNonInheritedData, objectFit, static_cast&lt;unsigned&gt;(fit)); }
1169     void setObjectPosition(LengthPoint&amp;&amp; position) { SET_VAR(m_rareNonInheritedData, objectPosition, WTFMove(position)); }
1170 
1171     void setRubyPosition(RubyPosition position) { SET_VAR(m_rareInheritedData, rubyPosition, static_cast&lt;unsigned&gt;(position)); }
1172 
1173 #if ENABLE(DARK_MODE_CSS)
1174     void setColorScheme(StyleColorScheme supported) { SET_VAR(m_rareInheritedData, colorScheme, supported); }
1175 #endif
1176 
1177     void setFilter(const FilterOperations&amp; ops) { SET_NESTED_VAR(m_rareNonInheritedData, filter, operations, ops); }
1178     void setAppleColorFilter(const FilterOperations&amp; ops) { SET_NESTED_VAR(m_rareInheritedData, appleColorFilter, operations, ops); }
1179 
1180 #if ENABLE(FILTERS_LEVEL_2)
1181     void setBackdropFilter(const FilterOperations&amp; ops) { SET_NESTED_VAR(m_rareNonInheritedData, backdropFilter, operations, ops); }
1182 #endif
1183 
1184     void setTabSize(const TabSize&amp; size) { SET_VAR(m_rareInheritedData, tabSize, size); }
1185 
1186     void setBreakBefore(BreakBetween breakBehavior) { SET_VAR(m_rareNonInheritedData, breakBefore, static_cast&lt;unsigned&gt;(breakBehavior)); }
1187     void setBreakAfter(BreakBetween breakBehavior) { SET_VAR(m_rareNonInheritedData, breakAfter, static_cast&lt;unsigned&gt;(breakBehavior)); }
1188     void setBreakInside(BreakInside breakBehavior) { SET_VAR(m_rareNonInheritedData, breakInside, static_cast&lt;unsigned&gt;(breakBehavior)); }
1189 
1190     void setHangingPunctuation(OptionSet&lt;HangingPunctuation&gt; punctuation) { SET_VAR(m_rareInheritedData, hangingPunctuation, punctuation.toRaw()); }
1191 
1192     // End CSS3 Setters
1193 
1194     void setLineGrid(const AtomString&amp; lineGrid) { SET_VAR(m_rareInheritedData, lineGrid, lineGrid); }
1195     void setLineSnap(LineSnap lineSnap) { SET_VAR(m_rareInheritedData, lineSnap, static_cast&lt;unsigned&gt;(lineSnap)); }
1196     void setLineAlign(LineAlign lineAlign) { SET_VAR(m_rareInheritedData, lineAlign, static_cast&lt;unsigned&gt;(lineAlign)); }
1197 
1198     void setPointerEvents(PointerEvents p) { m_inheritedFlags.pointerEvents = static_cast&lt;unsigned&gt;(p); }
1199 
1200     void clearAnimations();
1201     void clearTransitions();
1202 
1203     void adjustAnimations();
1204     void adjustTransitions();
1205 
1206     void setTransformStyle3D(TransformStyle3D b) { SET_VAR(m_rareNonInheritedData, transformStyle3D, static_cast&lt;unsigned&gt;(b)); }
1207     void setBackfaceVisibility(BackfaceVisibility b) { SET_VAR(m_rareNonInheritedData, backfaceVisibility, static_cast&lt;unsigned&gt;(b)); }
1208     void setPerspective(float p) { SET_VAR(m_rareNonInheritedData, perspective, p); }
1209     void setPerspectiveOriginX(Length&amp;&amp; length) { SET_VAR(m_rareNonInheritedData, perspectiveOriginX, WTFMove(length)); }
1210     void setPerspectiveOriginY(Length&amp;&amp; length) { SET_VAR(m_rareNonInheritedData, perspectiveOriginY, WTFMove(length)); }
1211     void setPageSize(LengthSize size) { SET_VAR(m_rareNonInheritedData, pageSize, WTFMove(size)); }
1212     void setPageSizeType(PageSizeType t) { SET_VAR(m_rareNonInheritedData, pageSizeType, t); }
1213     void resetPageSizeType() { SET_VAR(m_rareNonInheritedData, pageSizeType, PAGE_SIZE_AUTO); }
1214 
1215     void setLineBoxContain(LineBoxContain c) { SET_VAR(m_rareInheritedData, lineBoxContain, c); }
1216     void setLineClamp(LineClampValue c) { SET_VAR(m_rareNonInheritedData, lineClamp, c); }
1217 
1218     void setInitialLetter(const IntSize&amp; size) { SET_VAR(m_rareNonInheritedData, initialLetter, size); }
1219 
1220 #if ENABLE(POINTER_EVENTS)
1221     void setTouchActions(OptionSet&lt;TouchAction&gt; touchActions) { SET_VAR(m_rareNonInheritedData, touchActions, touchActions.toRaw()); }
1222     void setEffectiveTouchActions(OptionSet&lt;TouchAction&gt; touchActions) { SET_VAR(m_rareInheritedData, effectiveTouchActions, touchActions.toRaw()); }
1223 #endif
1224 
1225 #if ENABLE(CSS_SCROLL_SNAP)
1226     void setScrollSnapType(const ScrollSnapType&amp;);
1227     void setScrollPaddingTop(Length&amp;&amp;);
1228     void setScrollPaddingBottom(Length&amp;&amp;);
1229     void setScrollPaddingLeft(Length&amp;&amp;);
1230     void setScrollPaddingRight(Length&amp;&amp;);
1231 
1232     void setScrollSnapAlign(const ScrollSnapAlign&amp;);
1233     void setScrollSnapMarginTop(Length&amp;&amp;);
1234     void setScrollSnapMarginBottom(Length&amp;&amp;);
1235     void setScrollSnapMarginLeft(Length&amp;&amp;);
1236     void setScrollSnapMarginRight(Length&amp;&amp;);
1237 #endif
1238 
1239 #if ENABLE(TOUCH_EVENTS)
1240     void setTapHighlightColor(const Color&amp; c) { SET_VAR(m_rareInheritedData, tapHighlightColor, c); }
1241 #endif
1242 
1243 #if PLATFORM(IOS_FAMILY)
1244     void setTouchCalloutEnabled(bool v) { SET_VAR(m_rareInheritedData, touchCalloutEnabled, v); }
1245 #endif
1246 
1247 #if ENABLE(OVERFLOW_SCROLLING_TOUCH)
1248     void setUseTouchOverflowScrolling(bool v) { SET_VAR(m_rareInheritedData, useTouchOverflowScrolling, v); }
1249 #endif
1250 
1251 #if ENABLE(TEXT_AUTOSIZING)
1252     void setTextSizeAdjust(TextSizeAdjustment adjustment) { SET_VAR(m_rareInheritedData, textSizeAdjust, adjustment); }
1253     void setAutosizeStatus(AutosizeStatus);
1254 #endif
1255 
1256     void setTextSecurity(TextSecurity security) { SET_VAR(m_rareInheritedData, textSecurity, static_cast&lt;unsigned&gt;(security)); }
1257 
1258 #if ENABLE(CSS_TRAILING_WORD)
1259     void setTrailingWord(TrailingWord) { }
1260 #endif
1261 
1262 #if ENABLE(APPLE_PAY)
1263     void setApplePayButtonStyle(ApplePayButtonStyle style) { SET_VAR(m_rareNonInheritedData, applePayButtonStyle, static_cast&lt;unsigned&gt;(style)); }
1264     void setApplePayButtonType(ApplePayButtonType type) { SET_VAR(m_rareNonInheritedData, applePayButtonType, static_cast&lt;unsigned&gt;(type)); }
1265 #endif
1266 
1267 #if ENABLE(CSS_PAINTING_API)
1268     void addCustomPaintWatchProperty(const String&amp; name);
1269 #endif
1270 
1271     // Support for paint-order, stroke-linecap, stroke-linejoin, and stroke-miterlimit from https://drafts.fxtf.org/paint/.
1272     void setPaintOrder(PaintOrder order) { SET_VAR(m_rareInheritedData, paintOrder, static_cast&lt;unsigned&gt;(order)); }
1273     PaintOrder paintOrder() const { return static_cast&lt;PaintOrder&gt;(m_rareInheritedData-&gt;paintOrder); }
1274     static PaintOrder initialPaintOrder() { return PaintOrder::Normal; }
1275     static Vector&lt;PaintType, 3&gt; paintTypesForPaintOrder(PaintOrder);
1276 
1277     void setCapStyle(LineCap val) { SET_VAR(m_rareInheritedData, capStyle, val); }
1278     LineCap capStyle() const { return static_cast&lt;LineCap&gt;(m_rareInheritedData-&gt;capStyle); }
1279     static LineCap initialCapStyle() { return ButtCap; }
1280 
1281     void setJoinStyle(LineJoin val) { SET_VAR(m_rareInheritedData, joinStyle, val); }
1282     LineJoin joinStyle() const { return static_cast&lt;LineJoin&gt;(m_rareInheritedData-&gt;joinStyle); }
1283     static LineJoin initialJoinStyle() { return MiterJoin; }
1284 
1285     const Length&amp; strokeWidth() const { return m_rareInheritedData-&gt;strokeWidth; }
1286     void setStrokeWidth(Length&amp;&amp; w) { SET_VAR(m_rareInheritedData, strokeWidth, WTFMove(w)); }
1287     bool hasVisibleStroke() const { return svgStyle().hasStroke() &amp;&amp; !strokeWidth().isZero(); }
1288     static Length initialStrokeWidth() { return initialOneLength(); }
1289 
1290     float computedStrokeWidth(const IntSize&amp; viewportSize) const;
1291     void setHasExplicitlySetStrokeWidth(bool v) { SET_VAR(m_rareInheritedData, hasSetStrokeWidth, static_cast&lt;unsigned&gt;(v)); }
1292     bool hasExplicitlySetStrokeWidth() const { return m_rareInheritedData-&gt;hasSetStrokeWidth; };
1293     bool hasPositiveStrokeWidth() const;
1294 
1295     Color strokeColor() const { return m_rareInheritedData-&gt;strokeColor; }
1296     void setStrokeColor(const Color&amp; v)  { SET_VAR(m_rareInheritedData, strokeColor, v); }
1297     void setVisitedLinkStrokeColor(const Color&amp; v) { SET_VAR(m_rareInheritedData, visitedLinkStrokeColor, v); }
1298     const Color&amp; visitedLinkStrokeColor() const { return m_rareInheritedData-&gt;visitedLinkStrokeColor; }
1299     void setHasExplicitlySetStrokeColor(bool v) { SET_VAR(m_rareInheritedData, hasSetStrokeColor, static_cast&lt;unsigned&gt;(v)); }
1300     bool hasExplicitlySetStrokeColor() const { return m_rareInheritedData-&gt;hasSetStrokeColor; };
1301     static Color initialStrokeColor() { return Color(Color::transparent); }
1302     Color computedStrokeColor() const;
1303 
1304     float strokeMiterLimit() const { return m_rareInheritedData-&gt;miterLimit; }
1305     void setStrokeMiterLimit(float f) { SET_VAR(m_rareInheritedData, miterLimit, f); }
1306     static float initialStrokeMiterLimit() { return defaultMiterLimit; }
1307 
1308 
1309     const SVGRenderStyle&amp; svgStyle() const { return m_svgStyle; }
1310     SVGRenderStyle&amp; accessSVGStyle() { return m_svgStyle.access(); }
1311 
1312     SVGPaintType fillPaintType() const { return svgStyle().fillPaintType(); }
1313     Color fillPaintColor() const { return svgStyle().fillPaintColor(); }
1314     void setFillPaintColor(const Color&amp; color) { accessSVGStyle().setFillPaint(SVGPaintType::RGBColor, color, emptyString()); }
1315     float fillOpacity() const { return svgStyle().fillOpacity(); }
1316     void setFillOpacity(float f) { accessSVGStyle().setFillOpacity(f); }
1317 
1318     SVGPaintType strokePaintType() const { return svgStyle().strokePaintType(); }
1319     Color strokePaintColor() const { return svgStyle().strokePaintColor(); }
1320     void setStrokePaintColor(const Color&amp; color) { accessSVGStyle().setStrokePaint(SVGPaintType::RGBColor, color, emptyString()); }
1321     float strokeOpacity() const { return svgStyle().strokeOpacity(); }
1322     void setStrokeOpacity(float f) { accessSVGStyle().setStrokeOpacity(f); }
1323     Vector&lt;SVGLengthValue&gt; strokeDashArray() const { return svgStyle().strokeDashArray(); }
1324     void setStrokeDashArray(Vector&lt;SVGLengthValue&gt; array) { accessSVGStyle().setStrokeDashArray(array); }
1325     const Length&amp; strokeDashOffset() const { return svgStyle().strokeDashOffset(); }
1326     void setStrokeDashOffset(Length&amp;&amp; d) { accessSVGStyle().setStrokeDashOffset(WTFMove(d)); }
1327 
1328     const Length&amp; cx() const { return svgStyle().cx(); }
1329     void setCx(Length&amp;&amp; cx) { accessSVGStyle().setCx(WTFMove(cx)); }
1330     const Length&amp; cy() const { return svgStyle().cy(); }
1331     void setCy(Length&amp;&amp; cy) { accessSVGStyle().setCy(WTFMove(cy)); }
1332     const Length&amp; r() const { return svgStyle().r(); }
1333     void setR(Length&amp;&amp; r) { accessSVGStyle().setR(WTFMove(r)); }
1334     const Length&amp; rx() const { return svgStyle().rx(); }
1335     void setRx(Length&amp;&amp; rx) { accessSVGStyle().setRx(WTFMove(rx)); }
1336     const Length&amp; ry() const { return svgStyle().ry(); }
1337     void setRy(Length&amp;&amp; ry) { accessSVGStyle().setRy(WTFMove(ry)); }
1338     const Length&amp; x() const { return svgStyle().x(); }
1339     void setX(Length&amp;&amp; x) { accessSVGStyle().setX(WTFMove(x)); }
1340     const Length&amp; y() const { return svgStyle().y(); }
1341     void setY(Length&amp;&amp; y) { accessSVGStyle().setY(WTFMove(y)); }
1342 
1343     float floodOpacity() const { return svgStyle().floodOpacity(); }
1344     void setFloodOpacity(float f) { accessSVGStyle().setFloodOpacity(f); }
1345 
1346     float stopOpacity() const { return svgStyle().stopOpacity(); }
1347     void setStopOpacity(float f) { accessSVGStyle().setStopOpacity(f); }
1348 
1349     void setStopColor(const Color&amp; c) { accessSVGStyle().setStopColor(c); }
1350     void setFloodColor(const Color&amp; c) { accessSVGStyle().setFloodColor(c); }
1351     void setLightingColor(const Color&amp; c) { accessSVGStyle().setLightingColor(c); }
1352 
1353     SVGLengthValue baselineShiftValue() const { return svgStyle().baselineShiftValue(); }
1354     void setBaselineShiftValue(SVGLengthValue s) { accessSVGStyle().setBaselineShiftValue(s); }
1355     SVGLengthValue kerning() const { return svgStyle().kerning(); }
1356     void setKerning(SVGLengthValue k) { accessSVGStyle().setKerning(k); }
1357 
1358     void setShapeOutside(RefPtr&lt;ShapeValue&gt;&amp;&amp;);
1359     ShapeValue* shapeOutside() const { return m_rareNonInheritedData-&gt;shapeOutside.get(); }
1360     static ShapeValue* initialShapeOutside() { return nullptr; }
1361 
1362     const Length&amp; shapeMargin() const { return m_rareNonInheritedData-&gt;shapeMargin; }
1363     void setShapeMargin(Length&amp;&amp; shapeMargin) { SET_VAR(m_rareNonInheritedData, shapeMargin, WTFMove(shapeMargin)); }
1364     static Length initialShapeMargin() { return Length(0, Fixed); }
1365 
1366     float shapeImageThreshold() const { return m_rareNonInheritedData-&gt;shapeImageThreshold; }
1367     void setShapeImageThreshold(float);
1368     static float initialShapeImageThreshold() { return 0; }
1369 
1370     void setClipPath(RefPtr&lt;ClipPathOperation&gt;&amp;&amp;);
1371     ClipPathOperation* clipPath() const { return m_rareNonInheritedData-&gt;clipPath.get(); }
1372     static ClipPathOperation* initialClipPath() { return nullptr; }
1373 
1374     bool hasContent() const { return contentData(); }
1375     const ContentData* contentData() const { return m_rareNonInheritedData-&gt;content.get(); }
1376     bool contentDataEquivalent(const RenderStyle* otherStyle) const { return const_cast&lt;RenderStyle*&gt;(this)-&gt;m_rareNonInheritedData-&gt;contentDataEquivalent(*const_cast&lt;RenderStyle*&gt;(otherStyle)-&gt;m_rareNonInheritedData); }
1377     void clearContent();
1378     void setContent(const String&amp;, bool add = false);
1379     void setContent(RefPtr&lt;StyleImage&gt;&amp;&amp;, bool add = false);
1380     void setContent(std::unique_ptr&lt;CounterContent&gt;, bool add = false);
1381     void setContent(QuoteType, bool add = false);
1382     void setContentAltText(const String&amp;);
1383     const String&amp; contentAltText() const;
1384     bool hasAttrContent() const { return m_rareNonInheritedData-&gt;hasAttrContent; }
1385     void setHasAttrContent();
1386 
1387     const CounterDirectiveMap* counterDirectives() const;
1388     CounterDirectiveMap&amp; accessCounterDirectives();
1389 
1390     QuotesData* quotes() const { return m_rareInheritedData-&gt;quotes.get(); }
1391     void setQuotes(RefPtr&lt;QuotesData&gt;&amp;&amp;);
1392 
1393     WillChangeData* willChange() const { return m_rareNonInheritedData-&gt;willChange.get(); }
1394     void setWillChange(RefPtr&lt;WillChangeData&gt;&amp;&amp;);
1395 
1396     bool willChangeCreatesStackingContext() const;
1397 
1398     const AtomString&amp; hyphenString() const;
1399 
1400     bool inheritedNotEqual(const RenderStyle*) const;
1401     bool inheritedDataShared(const RenderStyle*) const;
1402 
1403 #if ENABLE(TEXT_AUTOSIZING)
1404     uint32_t hashForTextAutosizing() const;
1405     bool equalForTextAutosizing(const RenderStyle&amp;) const;
1406 #endif
1407 
1408     StyleDifference diff(const RenderStyle&amp;, OptionSet&lt;StyleDifferenceContextSensitiveProperty&gt;&amp; changedContextSensitiveProperties) const;
1409     bool diffRequiresLayerRepaint(const RenderStyle&amp;, bool isComposited) const;
1410 
1411     bool isDisplayInlineType() const { return isDisplayInlineType(display()); }
1412     bool isOriginalDisplayInlineType() const { return isDisplayInlineType(originalDisplay()); }
1413     bool isDisplayFlexibleOrGridBox() const { return isDisplayFlexibleOrGridBox(display()); }
1414     bool isDisplayRegionType() const;
1415 
1416     bool setWritingMode(WritingMode);
1417 
1418     bool hasExplicitlySetWritingMode() const { return m_nonInheritedFlags.hasExplicitlySetWritingMode; }
1419     void setHasExplicitlySetWritingMode(bool v) { m_nonInheritedFlags.hasExplicitlySetWritingMode = v; }
1420 
1421     bool hasExplicitlySetTextAlign() const { return m_nonInheritedFlags.hasExplicitlySetTextAlign; }
1422     void setHasExplicitlySetTextAlign(bool v) { m_nonInheritedFlags.hasExplicitlySetTextAlign = v; }
1423 
1424     // A unique style is one that has matches something that makes it impossible to share.
1425     bool unique() const { return m_nonInheritedFlags.isUnique; }
1426     void setUnique() { m_nonInheritedFlags.isUnique = true; }
1427 
1428     bool emptyState() const { return m_nonInheritedFlags.emptyState; }
1429     void setEmptyState(bool v) { setUnique(); m_nonInheritedFlags.emptyState = v; }
1430     bool firstChildState() const { return m_nonInheritedFlags.firstChildState; }
1431     void setFirstChildState() { setUnique(); m_nonInheritedFlags.firstChildState = true; }
1432     bool lastChildState() const { return m_nonInheritedFlags.lastChildState; }
1433     void setLastChildState() { setUnique(); m_nonInheritedFlags.lastChildState = true; }
1434 
1435     WEBCORE_EXPORT Color visitedDependentColor(CSSPropertyID) const;
1436     WEBCORE_EXPORT Color visitedDependentColorWithColorFilter(CSSPropertyID) const;
1437 
1438     WEBCORE_EXPORT Color colorByApplyingColorFilter(const Color&amp;) const;
1439 
1440     bool backgroundColorEqualsToColorIgnoringVisited(const Color&amp; color) const { return color == backgroundColor(); }
1441 
1442     void setHasExplicitlyInheritedProperties() { m_nonInheritedFlags.hasExplicitlyInheritedProperties = true; }
1443     bool hasExplicitlyInheritedProperties() const { return m_nonInheritedFlags.hasExplicitlyInheritedProperties; }
1444 
1445     // Initial values for all the properties
1446     static Overflow initialOverflowX() { return Overflow::Visible; }
1447     static Overflow initialOverflowY() { return Overflow::Visible; }
1448     static Clear initialClear() { return Clear::None; }
1449     static DisplayType initialDisplay() { return DisplayType::Inline; }
1450     static EUnicodeBidi initialUnicodeBidi() { return UBNormal; }
1451     static PositionType initialPosition() { return PositionType::Static; }
1452     static VerticalAlign initialVerticalAlign() { return VerticalAlign::Baseline; }
1453     static Float initialFloating() { return Float::No; }
1454     static BreakBetween initialBreakBetween() { return BreakBetween::Auto; }
1455     static BreakInside initialBreakInside() { return BreakInside::Auto; }
1456     static OptionSet&lt;HangingPunctuation&gt; initialHangingPunctuation() { return OptionSet&lt;HangingPunctuation&gt; { }; }
1457     static TableLayoutType initialTableLayout() { return TableLayoutType::Auto; }
1458     static BorderCollapse initialBorderCollapse() { return BorderCollapse::Separate; }
1459     static BorderStyle initialBorderStyle() { return BorderStyle::None; }
1460     static OutlineIsAuto initialOutlineStyleIsAuto() { return OutlineIsAuto::Off; }
1461     static NinePieceImage initialNinePieceImage() { return NinePieceImage(); }
1462     static LengthSize initialBorderRadius() { return { { 0, Fixed }, { 0, Fixed } }; }
1463     static CaptionSide initialCaptionSide() { return CaptionSide::Top; }
1464     static ColumnAxis initialColumnAxis() { return ColumnAxis::Auto; }
1465     static ColumnProgression initialColumnProgression() { return ColumnProgression::Normal; }
1466     static TextDirection initialDirection() { return TextDirection::LTR; }
1467     static WritingMode initialWritingMode() { return TopToBottomWritingMode; }
1468     static TextCombine initialTextCombine() { return TextCombine::None; }
1469     static TextOrientation initialTextOrientation() { return TextOrientation::Mixed; }
1470     static ObjectFit initialObjectFit() { return ObjectFit::Fill; }
1471     static LengthPoint initialObjectPosition() { return LengthPoint(Length(50.0f, Percent), Length(50.0f, Percent)); }
1472     static EmptyCell initialEmptyCells() { return EmptyCell::Show; }
1473     static ListStylePosition initialListStylePosition() { return ListStylePosition::Outside; }
1474     static ListStyleType initialListStyleType() { return ListStyleType::Disc; }
1475     static TextTransform initialTextTransform() { return TextTransform::None; }
1476     static Visibility initialVisibility() { return Visibility::Visible; }
1477     static WhiteSpace initialWhiteSpace() { return WhiteSpace::Normal; }
1478     static float initialHorizontalBorderSpacing() { return 0; }
1479     static float initialVerticalBorderSpacing() { return 0; }
1480     static CursorType initialCursor() { return CursorType::Auto; }
1481     static Color initialColor() { return Color::black; }
1482     static StyleImage* initialListStyleImage() { return 0; }
1483     static float initialBorderWidth() { return 3; }
1484     static unsigned short initialColumnRuleWidth() { return 3; }
1485     static float initialOutlineWidth() { return 3; }
1486     static float initialLetterSpacing() { return 0; }
1487     static Length initialWordSpacing() { return Length(Fixed); }
1488     static Length initialSize() { return Length(); }
1489     static Length initialMinSize() { return Length(); }
1490     static Length initialMaxSize() { return Length(Undefined); }
1491     static Length initialOffset() { return Length(); }
1492     static Length initialMargin() { return Length(Fixed); }
1493     static Length initialPadding() { return Length(Fixed); }
1494     static Length initialTextIndent() { return Length(Fixed); }
1495     static Length initialZeroLength() { return Length(Fixed); }
1496     static Length initialOneLength() { return Length(1, Fixed); }
1497     static short initialWidows() { return 2; }
1498     static short initialOrphans() { return 2; }
1499     static Length initialLineHeight() { return Length(-100.0f, Percent); }
1500     static TextAlignMode initialTextAlign() { return TextAlignMode::Start; }
1501     static OptionSet&lt;TextDecoration&gt; initialTextDecoration() { return OptionSet&lt;TextDecoration&gt; { }; }
1502     static TextDecorationStyle initialTextDecorationStyle() { return TextDecorationStyle::Solid; }
1503     static OptionSet&lt;TextDecorationSkip&gt; initialTextDecorationSkip() { return TextDecorationSkip::Auto; }
1504     static TextUnderlinePosition initialTextUnderlinePosition() { return TextUnderlinePosition::Auto; }
1505     static TextUnderlineOffset initialTextUnderlineOffset() { return TextUnderlineOffset::createWithAuto(); }
1506     static TextDecorationThickness initialTextDecorationThickness() { return TextDecorationThickness::createWithAuto(); }
1507     static float initialZoom() { return 1.0f; }
1508     static TextZoom initialTextZoom() { return TextZoom::Normal; }
1509     static float initialOutlineOffset() { return 0; }
1510     static float initialOpacity() { return 1.0f; }
1511     static BoxAlignment initialBoxAlign() { return BoxAlignment::Stretch; }
1512     static BoxDecorationBreak initialBoxDecorationBreak() { return BoxDecorationBreak::Slice; }
1513     static BoxDirection initialBoxDirection() { return BoxDirection::Normal; }
1514     static BoxLines initialBoxLines() { return BoxLines::Single; }
1515     static BoxOrient initialBoxOrient() { return BoxOrient::Horizontal; }
1516     static BoxPack initialBoxPack() { return BoxPack::Start; }
1517     static float initialBoxFlex() { return 0.0f; }
1518     static unsigned initialBoxFlexGroup() { return 1; }
1519     static unsigned initialBoxOrdinalGroup() { return 1; }
1520     static BoxSizing initialBoxSizing() { return BoxSizing::ContentBox; }
1521     static StyleReflection* initialBoxReflect() { return 0; }
1522     static float initialFlexGrow() { return 0; }
1523     static float initialFlexShrink() { return 1; }
1524     static Length initialFlexBasis() { return Length(Auto); }
1525     static int initialOrder() { return 0; }
1526     static StyleSelfAlignmentData initialJustifyItems() { return StyleSelfAlignmentData(ItemPosition::Legacy, OverflowAlignment::Default); }
1527     static StyleSelfAlignmentData initialSelfAlignment() { return StyleSelfAlignmentData(ItemPosition::Auto, OverflowAlignment::Default); }
1528     static StyleSelfAlignmentData initialDefaultAlignment() { return StyleSelfAlignmentData(ItemPosition::Normal, OverflowAlignment::Default); }
1529     static StyleContentAlignmentData initialContentAlignment() { return StyleContentAlignmentData(ContentPosition::Normal, ContentDistribution::Default, OverflowAlignment::Default); }
1530     static FlexDirection initialFlexDirection() { return FlexDirection::Row; }
1531     static FlexWrap initialFlexWrap() { return FlexWrap::NoWrap; }
1532     static int initialMarqueeLoopCount() { return -1; }
1533     static int initialMarqueeSpeed() { return 85; }
1534     static Length initialMarqueeIncrement() { return Length(6, Fixed); }
1535     static MarqueeBehavior initialMarqueeBehavior() { return MarqueeBehavior::Scroll; }
1536     static MarqueeDirection initialMarqueeDirection() { return MarqueeDirection::Auto; }
1537     static UserModify initialUserModify() { return UserModify::ReadOnly; }
1538     static UserDrag initialUserDrag() { return UserDrag::Auto; }
1539     static UserSelect initialUserSelect() { return UserSelect::Text; }
1540     static TextOverflow initialTextOverflow() { return TextOverflow::Clip; }
1541     static MarginCollapse initialMarginBeforeCollapse() { return MarginCollapse::Collapse; }
1542     static MarginCollapse initialMarginAfterCollapse() { return MarginCollapse::Collapse; }
1543     static WordBreak initialWordBreak() { return WordBreak::Normal; }
1544     static OverflowWrap initialOverflowWrap() { return OverflowWrap::Normal; }
1545     static NBSPMode initialNBSPMode() { return NBSPMode::Normal; }
1546     static LineBreak initialLineBreak() { return LineBreak::Auto; }
1547     static OptionSet&lt;SpeakAs&gt; initialSpeakAs() { return OptionSet&lt;SpeakAs&gt; { }; }
1548     static Hyphens initialHyphens() { return Hyphens::Manual; }
1549     static short initialHyphenationLimitBefore() { return -1; }
1550     static short initialHyphenationLimitAfter() { return -1; }
1551     static short initialHyphenationLimitLines() { return -1; }
1552     static const AtomString&amp; initialHyphenationString() { return nullAtom(); }
1553     static BorderFit initialBorderFit() { return BorderFit::Border; }
1554     static Resize initialResize() { return Resize::None; }
1555     static ControlPart initialAppearance() { return NoControlPart; }
1556     static AspectRatioType initialAspectRatioType() { return AspectRatioType::Auto; }
1557     static float initialAspectRatioDenominator() { return 1; }
1558     static float initialAspectRatioNumerator() { return 1; }
1559     static Order initialRTLOrdering() { return Order::Logical; }
1560     static float initialTextStrokeWidth() { return 0; }
1561     static unsigned short initialColumnCount() { return 1; }
1562     static ColumnFill initialColumnFill() { return ColumnFill::Balance; }
1563     static ColumnSpan initialColumnSpan() { return ColumnSpan::None; }
1564     static GapLength initialColumnGap() { return GapLength(); }
1565     static GapLength initialRowGap() { return GapLength(); }
1566     static const TransformOperations&amp; initialTransform() { static NeverDestroyed&lt;TransformOperations&gt; ops; return ops; }
1567     static Length initialTransformOriginX() { return Length(50.0f, Percent); }
1568     static Length initialTransformOriginY() { return Length(50.0f, Percent); }
1569     static TransformBox initialTransformBox() { return TransformBox::BorderBox; }
1570     static PointerEvents initialPointerEvents() { return PointerEvents::Auto; }
1571     static float initialTransformOriginZ() { return 0; }
1572     static TransformStyle3D initialTransformStyle3D() { return TransformStyle3D::Flat; }
1573     static BackfaceVisibility initialBackfaceVisibility() { return BackfaceVisibility::Visible; }
1574     static float initialPerspective() { return 0; }
1575     static Length initialPerspectiveOriginX() { return Length(50.0f, Percent); }
1576     static Length initialPerspectiveOriginY() { return Length(50.0f, Percent); }
1577     static Color initialBackgroundColor() { return Color::transparent; }
1578     static Color initialTextEmphasisColor() { return Color(); }
1579     static TextEmphasisFill initialTextEmphasisFill() { return TextEmphasisFill::Filled; }
1580     static TextEmphasisMark initialTextEmphasisMark() { return TextEmphasisMark::None; }
1581     static const AtomString&amp; initialTextEmphasisCustomMark() { return nullAtom(); }
1582     static OptionSet&lt;TextEmphasisPosition&gt; initialTextEmphasisPosition() { return { TextEmphasisPosition::Over, TextEmphasisPosition::Right }; }
1583     static RubyPosition initialRubyPosition() { return RubyPosition::Before; }
1584     static LineBoxContain initialLineBoxContain() { return LineBoxContainBlock | LineBoxContainInline | LineBoxContainReplaced; }
1585     static ImageOrientation initialImageOrientation() { return ImageOrientation::None; }
1586     static ImageRendering initialImageRendering() { return ImageRendering::Auto; }
1587     static ImageResolutionSource initialImageResolutionSource() { return ImageResolutionSource::Specified; }
1588     static ImageResolutionSnap initialImageResolutionSnap() { return ImageResolutionSnap::None; }
1589     static float initialImageResolution() { return 1; }
1590     static StyleImage* initialBorderImageSource() { return nullptr; }
1591     static StyleImage* initialMaskBoxImageSource() { return nullptr; }
1592     static PrintColorAdjust initialPrintColorAdjust() { return PrintColorAdjust::Economy; }
1593     static QuotesData* initialQuotes() { return nullptr; }
1594     static const AtomString&amp; initialContentAltText() { return emptyAtom(); }
1595 
1596 #if ENABLE(DARK_MODE_CSS)
1597     static StyleColorScheme initialColorScheme() { return { }; }
1598 #endif
1599 
1600 #if ENABLE(CSS3_TEXT)
1601     static TextIndentLine initialTextIndentLine() { return TextIndentLine::FirstLine; }
1602     static TextIndentType initialTextIndentType() { return TextIndentType::Normal; }
1603     static TextAlignLast initialTextAlignLast() { return TextAlignLast::Auto; }
1604     static TextJustify initialTextJustify() { return TextJustify::Auto; }
1605 #endif
1606 
1607 #if ENABLE(CURSOR_VISIBILITY)
1608     static CursorVisibility initialCursorVisibility() { return CursorVisibility::Auto; }
1609 #endif
1610 
1611 #if ENABLE(TEXT_AUTOSIZING)
1612     static Length initialSpecifiedLineHeight() { return Length(-100.0f, Percent); }
1613     static TextSizeAdjustment initialTextSizeAdjust() { return TextSizeAdjustment(); }
1614 #endif
1615 
1616     static WillChangeData* initialWillChange() { return nullptr; }
1617 
1618 #if ENABLE(POINTER_EVENTS)
1619     static TouchAction initialTouchActions() { return TouchAction::Auto; }
1620 #endif
1621 
1622 #if ENABLE(CSS_SCROLL_SNAP)
1623     static ScrollSnapType initialScrollSnapType();
1624     static ScrollSnapAlign initialScrollSnapAlign();
1625     static Length initialScrollSnapMargin() { return Length(Fixed); }
1626     static Length initialScrollPadding() { return Length(Fixed); }
1627 #endif
1628 
1629 #if ENABLE(CSS_TRAILING_WORD)
1630     static TrailingWord initialTrailingWord() { return TrailingWord::Auto; }
1631 #endif
1632 
1633 #if ENABLE(APPLE_PAY)
1634     static ApplePayButtonStyle initialApplePayButtonStyle() { return ApplePayButtonStyle::Black; }
1635     static ApplePayButtonType initialApplePayButtonType() { return ApplePayButtonType::Plain; }
1636 #endif
1637 
1638     // The initial value is &#39;none&#39; for grid tracks.
1639     static Vector&lt;GridTrackSize&gt; initialGridColumns() { return Vector&lt;GridTrackSize&gt;(); }
1640     static Vector&lt;GridTrackSize&gt; initialGridRows() { return Vector&lt;GridTrackSize&gt;(); }
1641 
1642     static Vector&lt;GridTrackSize&gt; initialGridAutoRepeatTracks() { return Vector&lt;GridTrackSize&gt;(); }
1643     static unsigned initialGridAutoRepeatInsertionPoint() { return 0; }
1644     static AutoRepeatType initialGridAutoRepeatType() { return AutoRepeatType::None; }
1645 
1646     static GridAutoFlow initialGridAutoFlow() { return AutoFlowRow; }
1647 
1648     static Vector&lt;GridTrackSize&gt; initialGridAutoColumns() { return { GridTrackSize(Length(Auto)) }; }
1649     static Vector&lt;GridTrackSize&gt; initialGridAutoRows() { return { GridTrackSize(Length(Auto)) }; }
1650 
1651     static NamedGridAreaMap initialNamedGridArea() { return NamedGridAreaMap(); }
1652     static size_t initialNamedGridAreaCount() { return 0; }
1653 
1654     static NamedGridLinesMap initialNamedGridColumnLines() { return NamedGridLinesMap(); }
1655     static NamedGridLinesMap initialNamedGridRowLines() { return NamedGridLinesMap(); }
1656 
1657     static OrderedNamedGridLinesMap initialOrderedNamedGridColumnLines() { return OrderedNamedGridLinesMap(); }
1658     static OrderedNamedGridLinesMap initialOrderedNamedGridRowLines() { return OrderedNamedGridLinesMap(); }
1659 
1660     // &#39;auto&#39; is the default.
1661     static GridPosition initialGridItemColumnStart() { return GridPosition(); }
1662     static GridPosition initialGridItemColumnEnd() { return GridPosition(); }
1663     static GridPosition initialGridItemRowStart() { return GridPosition(); }
1664     static GridPosition initialGridItemRowEnd() { return GridPosition(); }
1665 
1666     static TabSize initialTabSize() { return 8; }
1667 
1668     static const AtomString&amp; initialLineGrid() { return nullAtom(); }
1669     static LineSnap initialLineSnap() { return LineSnap::None; }
1670     static LineAlign initialLineAlign() { return LineAlign::None; }
1671 
1672     static IntSize initialInitialLetter() { return IntSize(); }
1673     static LineClampValue initialLineClamp() { return LineClampValue(); }
1674     static TextSecurity initialTextSecurity() { return TextSecurity::None; }
1675 
1676 #if PLATFORM(IOS_FAMILY)
1677     static bool initialTouchCalloutEnabled() { return true; }
1678 #endif
1679 
1680 #if ENABLE(TOUCH_EVENTS)
1681     static Color initialTapHighlightColor();
1682 #endif
1683 
1684 #if ENABLE(OVERFLOW_SCROLLING_TOUCH)
1685     static bool initialUseTouchOverflowScrolling() { return false; }
1686 #endif
1687 
1688     static const FilterOperations&amp; initialFilter() { static NeverDestroyed&lt;FilterOperations&gt; ops; return ops; }
1689     static const FilterOperations&amp; initialAppleColorFilter() { static NeverDestroyed&lt;FilterOperations&gt; ops; return ops; }
1690 
1691 #if ENABLE(FILTERS_LEVEL_2)
1692     static const FilterOperations&amp; initialBackdropFilter() { static NeverDestroyed&lt;FilterOperations&gt; ops; return ops; }
1693 #endif
1694 
1695 #if ENABLE(CSS_COMPOSITING)
1696     static BlendMode initialBlendMode() { return BlendMode::Normal; }
1697     static Isolation initialIsolation() { return Isolation::Auto; }
1698 #endif
1699 
1700     // Indicates the style is likely to change due to a pending stylesheet load.
1701     bool isNotFinal() const { return m_rareNonInheritedData-&gt;isNotFinal; }
1702     void setIsNotFinal() { SET_VAR(m_rareNonInheritedData, isNotFinal, true); }
1703 
1704     void setVisitedLinkColor(const Color&amp;);
1705     void setVisitedLinkBackgroundColor(const Color&amp; v) { SET_VAR(m_rareNonInheritedData, visitedLinkBackgroundColor, v); }
1706     void setVisitedLinkBorderLeftColor(const Color&amp; v) { SET_VAR(m_rareNonInheritedData, visitedLinkBorderLeftColor, v); }
1707     void setVisitedLinkBorderRightColor(const Color&amp; v) { SET_VAR(m_rareNonInheritedData, visitedLinkBorderRightColor, v); }
1708     void setVisitedLinkBorderBottomColor(const Color&amp; v) { SET_VAR(m_rareNonInheritedData, visitedLinkBorderBottomColor, v); }
1709     void setVisitedLinkBorderTopColor(const Color&amp; v) { SET_VAR(m_rareNonInheritedData, visitedLinkBorderTopColor, v); }
1710     void setVisitedLinkOutlineColor(const Color&amp; v) { SET_VAR(m_rareNonInheritedData, visitedLinkOutlineColor, v); }
1711     void setVisitedLinkColumnRuleColor(const Color&amp; v) { SET_NESTED_VAR(m_rareNonInheritedData, multiCol, visitedLinkColumnRuleColor, v); }
1712     void setVisitedLinkTextDecorationColor(const Color&amp; v) { SET_VAR(m_rareNonInheritedData, visitedLinkTextDecorationColor, v); }
1713     void setVisitedLinkTextEmphasisColor(const Color&amp; v) { SET_VAR(m_rareInheritedData, visitedLinkTextEmphasisColor, v); }
1714     void setVisitedLinkTextFillColor(const Color&amp; v) { SET_VAR(m_rareInheritedData, visitedLinkTextFillColor, v); }
1715     void setVisitedLinkTextStrokeColor(const Color&amp; v) { SET_VAR(m_rareInheritedData, visitedLinkTextStrokeColor, v); }
1716     void setVisitedLinkCaretColor(const Color&amp; v) { SET_VAR(m_rareInheritedData, visitedLinkCaretColor, v); }
1717 
1718     void inheritUnicodeBidiFrom(const RenderStyle* parent) { m_nonInheritedFlags.unicodeBidi = parent-&gt;m_nonInheritedFlags.unicodeBidi; }
1719     void getShadowExtent(const ShadowData*, LayoutUnit&amp; top, LayoutUnit&amp; right, LayoutUnit&amp; bottom, LayoutUnit&amp; left) const;
1720     void getShadowHorizontalExtent(const ShadowData*, LayoutUnit&amp; left, LayoutUnit&amp; right) const;
1721     void getShadowVerticalExtent(const ShadowData*, LayoutUnit&amp; top, LayoutUnit&amp; bottom) const;
1722     void getShadowInlineDirectionExtent(const ShadowData*, LayoutUnit&amp; logicalLeft, LayoutUnit&amp; logicalRight) const;
1723     void getShadowBlockDirectionExtent(const ShadowData*, LayoutUnit&amp; logicalTop, LayoutUnit&amp; logicalBottom) const;
1724 
1725     static Color invalidColor() { return Color(); }
1726     const Color&amp; borderLeftColor() const { return m_surroundData-&gt;border.left().color(); }
1727     const Color&amp; borderRightColor() const { return m_surroundData-&gt;border.right().color(); }
1728     const Color&amp; borderTopColor() const { return m_surroundData-&gt;border.top().color(); }
1729     const Color&amp; borderBottomColor() const { return m_surroundData-&gt;border.bottom().color(); }
1730     const Color&amp; backgroundColor() const { return m_backgroundData-&gt;color; }
1731     const Color&amp; color() const;
1732     const Color&amp; columnRuleColor() const { return m_rareNonInheritedData-&gt;multiCol-&gt;rule.color(); }
1733     const Color&amp; outlineColor() const { return m_backgroundData-&gt;outline.color(); }
1734     const Color&amp; textEmphasisColor() const { return m_rareInheritedData-&gt;textEmphasisColor; }
1735     const Color&amp; textFillColor() const { return m_rareInheritedData-&gt;textFillColor; }
1736     const Color&amp; textStrokeColor() const { return m_rareInheritedData-&gt;textStrokeColor; }
1737     const Color&amp; caretColor() const { return m_rareInheritedData-&gt;caretColor; }
1738     const Color&amp; visitedLinkColor() const;
1739     const Color&amp; visitedLinkBackgroundColor() const { return m_rareNonInheritedData-&gt;visitedLinkBackgroundColor; }
1740     const Color&amp; visitedLinkBorderLeftColor() const { return m_rareNonInheritedData-&gt;visitedLinkBorderLeftColor; }
1741     const Color&amp; visitedLinkBorderRightColor() const { return m_rareNonInheritedData-&gt;visitedLinkBorderRightColor; }
1742     const Color&amp; visitedLinkBorderBottomColor() const { return m_rareNonInheritedData-&gt;visitedLinkBorderBottomColor; }
1743     const Color&amp; visitedLinkBorderTopColor() const { return m_rareNonInheritedData-&gt;visitedLinkBorderTopColor; }
1744     const Color&amp; visitedLinkOutlineColor() const { return m_rareNonInheritedData-&gt;visitedLinkOutlineColor; }
1745     const Color&amp; visitedLinkColumnRuleColor() const { return m_rareNonInheritedData-&gt;multiCol-&gt;visitedLinkColumnRuleColor; }
1746     const Color&amp; textDecorationColor() const { return m_rareNonInheritedData-&gt;textDecorationColor; }
1747     const Color&amp; visitedLinkTextDecorationColor() const { return m_rareNonInheritedData-&gt;visitedLinkTextDecorationColor; }
1748     const Color&amp; visitedLinkTextEmphasisColor() const { return m_rareInheritedData-&gt;visitedLinkTextEmphasisColor; }
1749     const Color&amp; visitedLinkTextFillColor() const { return m_rareInheritedData-&gt;visitedLinkTextFillColor; }
1750     const Color&amp; visitedLinkTextStrokeColor() const { return m_rareInheritedData-&gt;visitedLinkTextStrokeColor; }
1751     const Color&amp; visitedLinkCaretColor() const { return m_rareInheritedData-&gt;visitedLinkCaretColor; }
1752 
1753     const Color&amp; stopColor() const { return svgStyle().stopColor(); }
1754     const Color&amp; floodColor() const { return svgStyle().floodColor(); }
1755     const Color&amp; lightingColor() const { return svgStyle().lightingColor(); }
1756 
1757 private:
1758     struct NonInheritedFlags {
1759         bool operator==(const NonInheritedFlags&amp;) const;
1760         bool operator!=(const NonInheritedFlags&amp; other) const { return !(*this == other); }
1761 
1762         void copyNonInheritedFrom(const NonInheritedFlags&amp;);
1763 
1764         bool hasAnyPublicPseudoStyles() const { return static_cast&lt;unsigned&gt;(PseudoId::PublicPseudoIdMask) &amp; pseudoBits; }
1765         bool hasPseudoStyle(PseudoId) const;
1766         void setHasPseudoStyle(PseudoId);
1767         void setHasPseudoStyles(PseudoIdSet);
1768 
1769         unsigned effectiveDisplay : 5; // DisplayType
1770         unsigned originalDisplay : 5; // DisplayType
1771         unsigned overflowX : 3; // Overflow
1772         unsigned overflowY : 3; // Overflow
1773         unsigned verticalAlign : 4; // VerticalAlign
1774         unsigned clear : 2; // Clear
1775         unsigned position : 3; // PositionType
1776         unsigned unicodeBidi : 3; // EUnicodeBidi
1777         unsigned floating : 2; // Float
1778         unsigned tableLayout : 1; // TableLayoutType
1779 
1780         unsigned hasExplicitlySetDirection : 1;
1781         unsigned hasExplicitlySetWritingMode : 1;
1782         unsigned hasExplicitlySetTextAlign : 1;
1783 #if ENABLE(DARK_MODE_CSS)
1784         unsigned hasExplicitlySetColorScheme : 1;
1785 #endif
1786         unsigned hasViewportUnits : 1;
1787         unsigned hasExplicitlyInheritedProperties : 1; // Explicitly inherits a non-inherited property.
1788         unsigned isUnique : 1; // Style cannot be shared.
1789         unsigned emptyState : 1;
1790         unsigned firstChildState : 1;
1791         unsigned lastChildState : 1;
1792         unsigned affectedByHover : 1;
1793         unsigned affectedByActive : 1;
1794         unsigned affectedByDrag : 1;
1795         unsigned isLink : 1;
1796 
1797         unsigned styleType : 4; // PseudoId
1798         unsigned pseudoBits : (static_cast&lt;unsigned&gt;(PseudoId::FirstInternalPseudoId) - static_cast&lt;unsigned&gt;(PseudoId::FirstPublicPseudoId));
1799 
1800         // If you add more style bits here, you will also need to update RenderStyle::NonInheritedFlags::copyNonInheritedFrom().
1801     };
1802 
1803     struct InheritedFlags {
1804         bool operator==(const InheritedFlags&amp;) const;
1805         bool operator!=(const InheritedFlags&amp; other) const { return !(*this == other); }
1806 
1807         unsigned emptyCells : 1; // EmptyCell
1808         unsigned captionSide : 2; // CaptionSide
1809         unsigned listStyleType : 7; // ListStyleType
1810         unsigned listStylePosition : 1; // ListStylePosition
1811         unsigned visibility : 2; // Visibility
1812         unsigned textAlign : 4; // TextAlignMode
1813         unsigned textTransform : 2; // TextTransform
1814         unsigned textDecorations : TextDecorationBits;
1815         unsigned cursor : 6; // CursorType
1816 #if ENABLE(CURSOR_VISIBILITY)
1817         unsigned cursorVisibility : 1; // CursorVisibility
1818 #endif
1819         unsigned direction : 1; // TextDirection
1820         unsigned whiteSpace : 3; // WhiteSpace
1821         // 35 bits
1822         unsigned borderCollapse : 1; // BorderCollapse
1823         unsigned boxDirection : 1; // BoxDirection
1824 
1825         // non CSS2 inherited
1826         unsigned rtlOrdering : 1; // Order
1827         unsigned printColorAdjust : PrintColorAdjustBits; // PrintColorAdjust
1828         unsigned pointerEvents : 4; // PointerEvents
1829         unsigned insideLink : 2; // InsideLink
1830         unsigned insideDefaultButton : 1;
1831         // 46 bits
1832 
1833         // CSS Text Layout Module Level 3: Vertical writing support
1834         unsigned writingMode : 2; // WritingMode
1835         // 48 bits
1836 
1837 #if ENABLE(TEXT_AUTOSIZING)
1838         unsigned autosizeStatus : 5;
1839 #endif
1840         // 53 bits
1841     };
1842 
1843     // This constructor is used to implement the replace operation.
1844     RenderStyle(RenderStyle&amp;, RenderStyle&amp;&amp;);
1845 
1846     DisplayType originalDisplay() const { return static_cast&lt;DisplayType&gt;(m_nonInheritedFlags.originalDisplay); }
1847 
1848     bool hasAutoLeftAndRight() const { return left().isAuto() &amp;&amp; right().isAuto(); }
1849     bool hasAutoTopAndBottom() const { return top().isAuto() &amp;&amp; bottom().isAuto(); }
1850 
1851     void setContent(std::unique_ptr&lt;ContentData&gt;, bool add);
1852 
1853     LayoutBoxExtent getShadowInsetExtent(const ShadowData*) const;
1854 
1855     static bool isDisplayReplacedType(DisplayType);
1856     static bool isDisplayInlineType(DisplayType);
1857     static bool isDisplayFlexibleBox(DisplayType);
1858     static bool isDisplayGridBox(DisplayType);
1859     static bool isDisplayFlexibleOrGridBox(DisplayType);
1860 
1861     Color colorIncludingFallback(CSSPropertyID colorProperty, bool visitedLink) const;
1862 
1863     bool changeAffectsVisualOverflow(const RenderStyle&amp;) const;
1864     bool changeRequiresLayout(const RenderStyle&amp;, OptionSet&lt;StyleDifferenceContextSensitiveProperty&gt;&amp; changedContextSensitiveProperties) const;
1865     bool changeRequiresPositionedLayoutOnly(const RenderStyle&amp;, OptionSet&lt;StyleDifferenceContextSensitiveProperty&gt;&amp; changedContextSensitiveProperties) const;
1866     bool changeRequiresLayerRepaint(const RenderStyle&amp;, OptionSet&lt;StyleDifferenceContextSensitiveProperty&gt;&amp; changedContextSensitiveProperties) const;
1867     bool changeRequiresRepaint(const RenderStyle&amp;, OptionSet&lt;StyleDifferenceContextSensitiveProperty&gt;&amp; changedContextSensitiveProperties) const;
1868     bool changeRequiresRepaintIfTextOrBorderOrOutline(const RenderStyle&amp;, OptionSet&lt;StyleDifferenceContextSensitiveProperty&gt;&amp; changedContextSensitiveProperties) const;
1869     bool changeRequiresRecompositeLayer(const RenderStyle&amp;, OptionSet&lt;StyleDifferenceContextSensitiveProperty&gt;&amp; changedContextSensitiveProperties) const;
1870 
1871     // non-inherited attributes
1872     DataRef&lt;StyleBoxData&gt; m_boxData;
1873     DataRef&lt;StyleVisualData&gt; m_visualData;
1874     DataRef&lt;StyleBackgroundData&gt; m_backgroundData;
1875     DataRef&lt;StyleSurroundData&gt; m_surroundData;
1876     DataRef&lt;StyleRareNonInheritedData&gt; m_rareNonInheritedData;
1877     NonInheritedFlags m_nonInheritedFlags;
1878 
1879     // inherited attributes
1880     DataRef&lt;StyleRareInheritedData&gt; m_rareInheritedData;
1881     DataRef&lt;StyleInheritedData&gt; m_inheritedData;
1882     InheritedFlags m_inheritedFlags;
1883 
1884     // list of associated pseudo styles
1885     std::unique_ptr&lt;PseudoStyleCache&gt; m_cachedPseudoStyles;
1886 
1887     DataRef&lt;SVGRenderStyle&gt; m_svgStyle;
1888 
1889 #if !ASSERT_DISABLED || ENABLE(SECURITY_ASSERTIONS)
1890     bool m_deletionHasBegun { false };
1891 #endif
1892 };
1893 
1894 int adjustForAbsoluteZoom(int, const RenderStyle&amp;);
1895 float adjustFloatForAbsoluteZoom(float, const RenderStyle&amp;);
1896 LayoutUnit adjustLayoutUnitForAbsoluteZoom(LayoutUnit, const RenderStyle&amp;);
1897 
1898 BorderStyle collapsedBorderStyle(BorderStyle);
1899 
1900 bool pseudoElementRendererIsNeeded(const RenderStyle*);
1901 
1902 inline bool RenderStyle::NonInheritedFlags::operator==(const NonInheritedFlags&amp; other) const
1903 {
1904     return effectiveDisplay == other.effectiveDisplay
1905         &amp;&amp; originalDisplay == other.originalDisplay
1906         &amp;&amp; overflowX == other.overflowX
1907         &amp;&amp; overflowY == other.overflowY
1908         &amp;&amp; verticalAlign == other.verticalAlign
1909         &amp;&amp; clear == other.clear
1910         &amp;&amp; position == other.position
1911         &amp;&amp; unicodeBidi == other.unicodeBidi
1912         &amp;&amp; floating == other.floating
1913         &amp;&amp; tableLayout == other.tableLayout
1914         &amp;&amp; hasExplicitlySetDirection == other.hasExplicitlySetDirection
1915         &amp;&amp; hasExplicitlySetWritingMode == other.hasExplicitlySetWritingMode
1916         &amp;&amp; hasExplicitlySetTextAlign == other.hasExplicitlySetTextAlign
1917 #if ENABLE(DARK_MODE_CSS)
1918         &amp;&amp; hasExplicitlySetColorScheme == other.hasExplicitlySetColorScheme
1919 #endif
1920         &amp;&amp; hasViewportUnits == other.hasViewportUnits
1921         &amp;&amp; hasExplicitlyInheritedProperties == other.hasExplicitlyInheritedProperties
1922         &amp;&amp; isUnique == other.isUnique
1923         &amp;&amp; emptyState == other.emptyState
1924         &amp;&amp; firstChildState == other.firstChildState
1925         &amp;&amp; lastChildState == other.lastChildState
1926         &amp;&amp; affectedByHover == other.affectedByHover
1927         &amp;&amp; affectedByActive == other.affectedByActive
1928         &amp;&amp; affectedByDrag == other.affectedByDrag
1929         &amp;&amp; isLink == other.isLink
1930         &amp;&amp; styleType == other.styleType
1931         &amp;&amp; pseudoBits == other.pseudoBits;
1932 }
1933 
1934 inline void RenderStyle::NonInheritedFlags::copyNonInheritedFrom(const NonInheritedFlags&amp; other)
1935 {
1936     // Only a subset is copied because NonInheritedFlags contains a bunch of stuff other than real style data.
1937     effectiveDisplay = other.effectiveDisplay;
1938     originalDisplay = other.originalDisplay;
1939     overflowX = other.overflowX;
1940     overflowY = other.overflowY;
1941     verticalAlign = other.verticalAlign;
1942     clear = other.clear;
1943     position = other.position;
1944     unicodeBidi = other.unicodeBidi;
1945     floating = other.floating;
1946     tableLayout = other.tableLayout;
1947     hasViewportUnits = other.hasViewportUnits;
1948     hasExplicitlyInheritedProperties = other.hasExplicitlyInheritedProperties;
1949 }
1950 
1951 inline bool RenderStyle::NonInheritedFlags::hasPseudoStyle(PseudoId pseudo) const
1952 {
1953     ASSERT(pseudo &gt; PseudoId::None);
1954     ASSERT(pseudo &lt; PseudoId::FirstInternalPseudoId);
1955     return pseudoBits &amp; (1 &lt;&lt; (static_cast&lt;unsigned&gt;(pseudo) - 1 /* PseudoId::None */));
1956 }
1957 
1958 inline void RenderStyle::NonInheritedFlags::setHasPseudoStyle(PseudoId pseudo)
1959 {
1960     ASSERT(pseudo &gt; PseudoId::None);
1961     ASSERT(pseudo &lt; PseudoId::FirstInternalPseudoId);
1962     pseudoBits |= 1 &lt;&lt; (static_cast&lt;unsigned&gt;(pseudo) - 1 /* PseudoId::None */);
1963 }
1964 
1965 inline void RenderStyle::NonInheritedFlags::setHasPseudoStyles(PseudoIdSet pseudoIdSet)
1966 {
1967     ASSERT(pseudoIdSet);
1968     ASSERT((pseudoIdSet.data() &amp; static_cast&lt;unsigned&gt;(PseudoId::PublicPseudoIdMask)) == pseudoIdSet.data());
1969     pseudoBits |= pseudoIdSet.data() &gt;&gt; 1; // Shift down as we do not store a bit for PseudoId::None.
1970 }
1971 
1972 inline bool RenderStyle::InheritedFlags::operator==(const InheritedFlags&amp; other) const
1973 {
1974     return emptyCells == other.emptyCells
1975         &amp;&amp; captionSide == other.captionSide
1976         &amp;&amp; listStyleType == other.listStyleType
1977         &amp;&amp; listStylePosition == other.listStylePosition
1978         &amp;&amp; visibility == other.visibility
1979         &amp;&amp; textAlign == other.textAlign
1980         &amp;&amp; textTransform == other.textTransform
1981         &amp;&amp; textDecorations == other.textDecorations
1982         &amp;&amp; cursor == other.cursor
1983 #if ENABLE(CURSOR_VISIBILITY)
1984         &amp;&amp; cursorVisibility == other.cursorVisibility
1985 #endif
1986         &amp;&amp; direction == other.direction
1987         &amp;&amp; whiteSpace == other.whiteSpace
1988         &amp;&amp; borderCollapse == other.borderCollapse
1989         &amp;&amp; boxDirection == other.boxDirection
1990         &amp;&amp; rtlOrdering == other.rtlOrdering
1991         &amp;&amp; printColorAdjust == other.printColorAdjust
1992         &amp;&amp; pointerEvents == other.pointerEvents
1993         &amp;&amp; insideLink == other.insideLink
1994         &amp;&amp; insideDefaultButton == other.insideDefaultButton
1995         &amp;&amp; writingMode == other.writingMode;
1996 }
1997 
1998 inline int adjustForAbsoluteZoom(int value, const RenderStyle&amp; style)
1999 {
2000     double zoomFactor = style.effectiveZoom();
2001     if (zoomFactor == 1)
2002         return value;
2003     // Needed because computeLengthInt truncates (rather than rounds) when scaling up.
2004     if (zoomFactor &gt; 1) {
2005         if (value &lt; 0)
2006             value--;
2007         else
2008             value++;
2009     }
2010 
2011     return roundForImpreciseConversion&lt;int&gt;(value / zoomFactor);
2012 }
2013 
2014 inline float adjustFloatForAbsoluteZoom(float value, const RenderStyle&amp; style)
2015 {
2016     return value / style.effectiveZoom();
2017 }
2018 
2019 inline LayoutUnit adjustLayoutUnitForAbsoluteZoom(LayoutUnit value, const RenderStyle&amp; style)
2020 {
2021     return LayoutUnit(value / style.effectiveZoom());
2022 }
2023 
2024 inline BorderStyle collapsedBorderStyle(BorderStyle style)
2025 {
2026     if (style == BorderStyle::Outset)
2027         return BorderStyle::Groove;
2028     if (style == BorderStyle::Inset)
2029         return BorderStyle::Ridge;
2030     return style;
2031 }
2032 
2033 inline const CSSCustomPropertyValue* RenderStyle::getCustomProperty(const AtomString&amp; name) const
2034 {
2035     for (auto* map : { &amp;nonInheritedCustomProperties(), &amp;inheritedCustomProperties() }) {
2036         if (auto* val = map-&gt;get(name))
2037             return val;
2038     }
2039     return nullptr;
2040 }
2041 
2042 inline bool RenderStyle::hasBackground() const
2043 {
2044     return visitedDependentColor(CSSPropertyBackgroundColor).isVisible() ||  hasBackgroundImage();
2045 }
2046 
2047 inline bool RenderStyle::autoWrap(WhiteSpace whiteSpace)
2048 {
2049     // Nowrap and pre don&#39;t automatically wrap.
2050     return whiteSpace != WhiteSpace::NoWrap &amp;&amp; whiteSpace != WhiteSpace::Pre;
2051 }
2052 
2053 inline bool RenderStyle::preserveNewline(WhiteSpace whiteSpace)
2054 {
2055     // Normal and nowrap do not preserve newlines.
2056     return whiteSpace != WhiteSpace::Normal &amp;&amp; whiteSpace != WhiteSpace::NoWrap;
2057 }
2058 
2059 inline bool RenderStyle::collapseWhiteSpace(WhiteSpace ws)
2060 {
2061     // Pre and prewrap do not collapse whitespace.
2062     return ws != WhiteSpace::Pre &amp;&amp; ws != WhiteSpace::PreWrap &amp;&amp; ws != WhiteSpace::BreakSpaces;
2063 }
2064 
2065 inline bool RenderStyle::isCollapsibleWhiteSpace(UChar character) const
2066 {
2067     switch (character) {
2068     case &#39; &#39;:
2069     case &#39;\t&#39;:
2070         return collapseWhiteSpace();
2071     case &#39;\n&#39;:
2072         return !preserveNewline();
2073     default:
2074         return false;
2075     }
2076 }
2077 
2078 inline bool RenderStyle::breakOnlyAfterWhiteSpace() const
2079 {
2080     return whiteSpace() == WhiteSpace::PreWrap || whiteSpace() == WhiteSpace::BreakSpaces || lineBreak() == LineBreak::AfterWhiteSpace;
2081 }
2082 
2083 inline bool RenderStyle::breakWords() const
2084 {
2085     return wordBreak() == WordBreak::BreakWord || overflowWrap() == OverflowWrap::Break;
2086 }
2087 
2088 inline bool RenderStyle::hasInlineColumnAxis() const
2089 {
2090     auto axis = columnAxis();
2091     return axis == ColumnAxis::Auto || isHorizontalWritingMode() == (axis == ColumnAxis::Horizontal);
2092 }
2093 
2094 inline ImageOrientation RenderStyle::imageOrientation() const
2095 {
2096 #if ENABLE(CSS_IMAGE_ORIENTATION)
2097     return ImageOrientation(m_rareInheritedData-&gt;imageOrientation);
2098 #else
2099     return ImageOrientation::None;
2100 #endif
2101 }
2102 
2103 inline void RenderStyle::setLogicalWidth(Length&amp;&amp; logicalWidth)
2104 {
2105     if (isHorizontalWritingMode())
2106         setWidth(WTFMove(logicalWidth));
2107     else
2108         setHeight(WTFMove(logicalWidth));
2109 }
2110 
2111 inline void RenderStyle::setLogicalHeight(Length&amp;&amp; logicalHeight)
2112 {
2113     if (isHorizontalWritingMode())
2114         setHeight(WTFMove(logicalHeight));
2115     else
2116         setWidth(WTFMove(logicalHeight));
2117 }
2118 
2119 inline void RenderStyle::setBorderRadius(LengthSize&amp;&amp; size)
2120 {
2121     auto topLeft = size;
2122     setBorderTopLeftRadius(WTFMove(topLeft));
2123     auto topRight = size;
2124     setBorderTopRightRadius(WTFMove(topRight));
2125     auto bottomLeft = size;
2126     setBorderBottomLeftRadius(WTFMove(bottomLeft));
2127     setBorderBottomRightRadius(WTFMove(size));
2128 }
2129 
2130 inline void RenderStyle::setBorderRadius(const IntSize&amp; size)
2131 {
2132     setBorderRadius(LengthSize { { size.width(), Fixed }, { size.height(), Fixed } });
2133 }
2134 
2135 inline bool RenderStyle::setZoom(float zoomLevel)
2136 {
2137     setEffectiveZoom(effectiveZoom() * zoomLevel);
2138     if (compareEqual(m_visualData-&gt;zoom, zoomLevel))
2139         return false;
2140     m_visualData.access().zoom = zoomLevel;
2141     return true;
2142 }
2143 
2144 inline bool RenderStyle::setEffectiveZoom(float zoomLevel)
2145 {
2146     if (compareEqual(m_rareInheritedData-&gt;effectiveZoom, zoomLevel))
2147         return false;
2148     m_rareInheritedData.access().effectiveZoom = zoomLevel;
2149     return true;
2150 }
2151 
2152 inline bool RenderStyle::setTextOrientation(TextOrientation textOrientation)
2153 {
2154     if (compareEqual(static_cast&lt;TextOrientation&gt;(m_rareInheritedData-&gt;textOrientation), textOrientation))
2155         return false;
2156     m_rareInheritedData.access().textOrientation = static_cast&lt;unsigned&gt;(textOrientation);
2157     return true;
2158 }
2159 
2160 inline void RenderStyle::adjustBackgroundLayers()
2161 {
2162     if (backgroundLayers().next()) {
2163         ensureBackgroundLayers().cullEmptyLayers();
2164         ensureBackgroundLayers().fillUnsetProperties();
2165     }
2166 }
2167 
2168 inline void RenderStyle::adjustMaskLayers()
2169 {
2170     if (maskLayers().next()) {
2171         ensureMaskLayers().cullEmptyLayers();
2172         ensureMaskLayers().fillUnsetProperties();
2173     }
2174 }
2175 
2176 inline void RenderStyle::clearAnimations()
2177 {
2178     m_rareNonInheritedData.access().animations = nullptr;
2179 }
2180 
2181 inline void RenderStyle::clearTransitions()
2182 {
2183     m_rareNonInheritedData.access().transitions = nullptr;
2184 }
2185 
2186 inline void RenderStyle::setShapeOutside(RefPtr&lt;ShapeValue&gt;&amp;&amp; value)
2187 {
2188     if (m_rareNonInheritedData-&gt;shapeOutside == value)
2189         return;
2190     m_rareNonInheritedData.access().shapeOutside = WTFMove(value);
2191 }
2192 
2193 inline void RenderStyle::setShapeImageThreshold(float shapeImageThreshold)
2194 {
2195     float clampedShapeImageThreshold = clampTo&lt;float&gt;(shapeImageThreshold, 0.f, 1.f);
2196     SET_VAR(m_rareNonInheritedData, shapeImageThreshold, clampedShapeImageThreshold);
2197 }
2198 
2199 inline void RenderStyle::setClipPath(RefPtr&lt;ClipPathOperation&gt;&amp;&amp; operation)
2200 {
2201     if (m_rareNonInheritedData-&gt;clipPath != operation)
2202         m_rareNonInheritedData.access().clipPath = WTFMove(operation);
2203 }
2204 
2205 inline bool RenderStyle::willChangeCreatesStackingContext() const
2206 {
2207     return willChange() &amp;&amp; willChange()-&gt;canCreateStackingContext();
2208 }
2209 
2210 inline bool RenderStyle::isDisplayRegionType() const
2211 {
2212     return display() == DisplayType::Block || display() == DisplayType::InlineBlock
2213         || display() == DisplayType::TableCell || display() == DisplayType::TableCaption
2214         || display() == DisplayType::ListItem;
2215 }
2216 
2217 inline bool RenderStyle::setWritingMode(WritingMode v)
2218 {
2219     if (v == writingMode())
2220         return false;
2221     m_inheritedFlags.writingMode = v;
2222     return true;
2223 }
2224 
2225 inline void RenderStyle::getShadowInlineDirectionExtent(const ShadowData* shadow, LayoutUnit&amp; logicalLeft, LayoutUnit&amp; logicalRight) const
2226 {
2227     return isHorizontalWritingMode() ? getShadowHorizontalExtent(shadow, logicalLeft, logicalRight) : getShadowVerticalExtent(shadow, logicalLeft, logicalRight);
2228 }
2229 
2230 inline void RenderStyle::getShadowBlockDirectionExtent(const ShadowData* shadow, LayoutUnit&amp; logicalTop, LayoutUnit&amp; logicalBottom) const
2231 {
2232     return isHorizontalWritingMode() ? getShadowVerticalExtent(shadow, logicalTop, logicalBottom) : getShadowHorizontalExtent(shadow, logicalTop, logicalBottom);
2233 }
2234 
2235 inline bool RenderStyle::isDisplayReplacedType(DisplayType display)
2236 {
2237     return display == DisplayType::InlineBlock || display == DisplayType::InlineBox || display == DisplayType::InlineFlex
2238         || display == DisplayType::InlineGrid || display == DisplayType::InlineTable;
2239 }
2240 
2241 inline bool RenderStyle::isDisplayInlineType(DisplayType display)
2242 {
2243     return display == DisplayType::Inline || isDisplayReplacedType(display);
2244 }
2245 
2246 inline bool RenderStyle::isDisplayFlexibleBox(DisplayType display)
2247 {
2248     return display == DisplayType::Flex || display == DisplayType::InlineFlex;
2249 }
2250 
2251 inline bool RenderStyle::isDisplayGridBox(DisplayType display)
2252 {
2253     return display == DisplayType::Grid || display == DisplayType::InlineGrid;
2254 }
2255 
2256 inline bool RenderStyle::isDisplayFlexibleOrGridBox(DisplayType display)
2257 {
2258     return isDisplayFlexibleBox(display) || isDisplayGridBox(display);
2259 }
2260 
2261 inline bool RenderStyle::hasAnyPublicPseudoStyles() const
2262 {
2263     return m_nonInheritedFlags.hasAnyPublicPseudoStyles();
2264 }
2265 
2266 inline bool RenderStyle::hasPseudoStyle(PseudoId pseudo) const
2267 {
2268     return m_nonInheritedFlags.hasPseudoStyle(pseudo);
2269 }
2270 
2271 inline void RenderStyle::setHasPseudoStyle(PseudoId pseudo)
2272 {
2273     m_nonInheritedFlags.setHasPseudoStyle(pseudo);
2274 }
2275 
2276 inline void RenderStyle::setHasPseudoStyles(PseudoIdSet pseudoIdSet)
2277 {
2278     m_nonInheritedFlags.setHasPseudoStyles(pseudoIdSet);
2279 }
2280 
2281 inline void RenderStyle::setBoxReflect(RefPtr&lt;StyleReflection&gt;&amp;&amp; reflect)
2282 {
2283     SET_VAR(m_rareNonInheritedData, boxReflect, WTFMove(reflect));
2284 }
2285 
2286 inline bool pseudoElementRendererIsNeeded(const RenderStyle* style)
2287 {
2288     return style &amp;&amp; style-&gt;display() != DisplayType::None &amp;&amp; style-&gt;contentData();
2289 }
2290 
2291 } // namespace WebCore
    </pre>
  </body>
</html>