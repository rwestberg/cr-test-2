<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/CommonSlowPaths.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (C) 2011-2019 Apple Inc. All rights reserved.
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  * 1. Redistributions of source code must retain the above copyright
   8  *    notice, this list of conditions and the following disclaimer.
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #include &quot;config.h&quot;
  27 #include &quot;CommonSlowPaths.h&quot;
  28 
  29 #include &quot;ArithProfile.h&quot;
  30 #include &quot;ArrayConstructor.h&quot;
  31 #include &quot;BuiltinNames.h&quot;
  32 #include &quot;BytecodeStructs.h&quot;
  33 #include &quot;CallFrame.h&quot;
  34 #include &quot;ClonedArguments.h&quot;
  35 #include &quot;CodeProfiling.h&quot;
  36 #include &quot;DefinePropertyAttributes.h&quot;
  37 #include &quot;DirectArguments.h&quot;
  38 #include &quot;Error.h&quot;
  39 #include &quot;ErrorHandlingScope.h&quot;
  40 #include &quot;ExceptionFuzz.h&quot;
  41 #include &quot;FrameTracers.h&quot;
  42 #include &quot;GetterSetter.h&quot;
  43 #include &quot;HostCallReturnValue.h&quot;
  44 #include &quot;ICStats.h&quot;
  45 #include &quot;Interpreter.h&quot;
  46 #include &quot;IteratorOperations.h&quot;
  47 #include &quot;JIT.h&quot;
  48 #include &quot;JSArrayInlines.h&quot;
  49 #include &quot;JSCInlines.h&quot;
  50 #include &quot;JSCJSValue.h&quot;
  51 #include &quot;JSFixedArray.h&quot;
  52 #include &quot;JSGlobalObjectFunctions.h&quot;
  53 #include &quot;JSImmutableButterfly.h&quot;
  54 #include &quot;JSLexicalEnvironment.h&quot;
  55 #include &quot;JSPropertyNameEnumerator.h&quot;
  56 #include &quot;JSString.h&quot;
  57 #include &quot;JSWithScope.h&quot;
  58 #include &quot;LLIntCommon.h&quot;
  59 #include &quot;LLIntExceptions.h&quot;
  60 #include &quot;LowLevelInterpreter.h&quot;
  61 #include &quot;MathCommon.h&quot;
  62 #include &quot;ObjectConstructor.h&quot;
  63 #include &quot;OpcodeInlines.h&quot;
  64 #include &quot;ScopedArguments.h&quot;
  65 #include &quot;StructureRareDataInlines.h&quot;
  66 #include &quot;ThunkGenerators.h&quot;
  67 #include &quot;TypeProfilerLog.h&quot;
  68 #include &lt;wtf/StringPrintStream.h&gt;
  69 #include &lt;wtf/Variant.h&gt;
  70 
  71 namespace JSC {
  72 
  73 #define BEGIN_NO_SET_PC() \
  74     VM&amp; vm = exec-&gt;vm();      \
<a name="1" id="anc1"></a><span class="line-modified">  75     NativeCallFrameTracer tracer(&amp;vm, exec); \</span>
  76     auto throwScope = DECLARE_THROW_SCOPE(vm); \
  77     UNUSED_PARAM(throwScope)
  78 
  79 #ifndef NDEBUG
  80 #define SET_PC_FOR_STUBS() do { \
  81         exec-&gt;codeBlock()-&gt;bytecodeOffset(pc); \
  82         exec-&gt;setCurrentVPC(pc); \
  83     } while (false)
  84 #else
  85 #define SET_PC_FOR_STUBS() do { \
  86         exec-&gt;setCurrentVPC(pc); \
  87     } while (false)
  88 #endif
  89 
  90 #define RETURN_TO_THROW(exec, pc)   pc = LLInt::returnToThrow(exec)
  91 
  92 #define BEGIN()                           \
  93     BEGIN_NO_SET_PC();                    \
  94     SET_PC_FOR_STUBS()
  95 
  96 #define GET(operand) (exec-&gt;uncheckedR(operand.offset()))
  97 #define GET_C(operand) (exec-&gt;r(operand.offset()))
  98 
  99 #define RETURN_TWO(first, second) do {       \
 100         return encodeResult(first, second);        \
 101     } while (false)
 102 
 103 #define END_IMPL() RETURN_TWO(pc, exec)
 104 
 105 #define THROW(exceptionToThrow) do {                        \
 106         throwException(exec, throwScope, exceptionToThrow); \
 107         RETURN_TO_THROW(exec, pc);                          \
 108         END_IMPL();                                         \
 109     } while (false)
 110 
 111 #define CHECK_EXCEPTION() do {                    \
 112         doExceptionFuzzingIfEnabled(exec, throwScope, &quot;CommonSlowPaths&quot;, pc);   \
 113         if (UNLIKELY(throwScope.exception())) {   \
 114             RETURN_TO_THROW(exec, pc);            \
 115             END_IMPL();                           \
 116         }                                         \
 117     } while (false)
 118 
 119 #define END() do {                        \
 120         CHECK_EXCEPTION();                \
 121         END_IMPL();                       \
 122     } while (false)
 123 
 124 #define BRANCH(condition) do {                      \
 125         bool bCondition = (condition);                         \
 126         CHECK_EXCEPTION();                                  \
 127         if (bCondition)                                        \
 128             pc = bytecode.m_targetLabel \
 129                 ? reinterpret_cast&lt;const Instruction*&gt;(reinterpret_cast&lt;const uint8_t*&gt;(pc) + bytecode.m_targetLabel) \
 130                 : exec-&gt;codeBlock()-&gt;outOfLineJumpTarget(pc);                              \
 131         else                                                      \
 132             pc = reinterpret_cast&lt;const Instruction*&gt;(reinterpret_cast&lt;const uint8_t*&gt;(pc) + pc-&gt;size()); \
 133         END_IMPL();                                         \
 134     } while (false)
 135 
 136 #define RETURN_WITH_PROFILING_CUSTOM(result__, value__, profilingAction__) do { \
 137         JSValue returnValue__ = (value__);  \
 138         CHECK_EXCEPTION();                  \
 139         GET(result__) = returnValue__;              \
 140         profilingAction__;                  \
 141         END_IMPL();                         \
 142     } while (false)
 143 
 144 #define RETURN_WITH_PROFILING(value__, profilingAction__) RETURN_WITH_PROFILING_CUSTOM(bytecode.m_dst, value__, profilingAction__)
 145 
 146 #define RETURN(value) \
 147     RETURN_WITH_PROFILING(value, { })
 148 
 149 #define RETURN_PROFILED(value__) \
 150     RETURN_WITH_PROFILING(value__, PROFILE_VALUE(returnValue__))
 151 
 152 #define PROFILE_VALUE(value) do { \
 153         bytecode.metadata(exec).m_profile.m_buckets[0] = JSValue::encode(value); \
 154     } while (false)
 155 
 156 #define CALL_END_IMPL(exec, callTarget, callTargetTag) \
 157     RETURN_TWO(retagCodePtr((callTarget), callTargetTag, SlowPathPtrTag), (exec))
 158 
 159 #define CALL_CHECK_EXCEPTION(exec, pc) do {                          \
 160         ExecState* cceExec = (exec);                                 \
 161         Instruction* ccePC = (pc);                                   \
 162         if (UNLIKELY(throwScope.exception()))                        \
 163             CALL_END_IMPL(cceExec, LLInt::callToThrow(cceExec), ExceptionHandlerPtrTag); \
 164     } while (false)
 165 
 166 static void throwArityCheckStackOverflowError(ExecState* exec, ThrowScope&amp; scope)
 167 {
 168     JSObject* error = createStackOverflowError(exec);
 169     throwException(exec, scope, error);
 170 #if LLINT_TRACING
 171     if (UNLIKELY(Options::traceLLIntSlowPath()))
 172         dataLog(&quot;Throwing exception &quot;, JSValue(scope.exception()), &quot;.\n&quot;);
 173 #endif
 174 }
 175 
 176 SLOW_PATH_DECL(slow_path_call_arityCheck)
 177 {
 178     BEGIN();
 179     int slotsToAdd = CommonSlowPaths::arityCheckFor(exec, vm, CodeForCall);
 180     if (UNLIKELY(slotsToAdd &lt; 0)) {
 181         CodeBlock* codeBlock = CommonSlowPaths::codeBlockFromCallFrameCallee(exec, CodeForCall);
 182         exec-&gt;convertToStackOverflowFrame(vm, codeBlock);
<a name="2" id="anc2"></a><span class="line-modified"> 183         NativeCallFrameTracer tracer(&amp;vm, exec);</span>
 184         ErrorHandlingScope errorScope(vm);
 185         throwScope.release();
 186         throwArityCheckStackOverflowError(exec, throwScope);
 187         RETURN_TWO(bitwise_cast&lt;void*&gt;(static_cast&lt;uintptr_t&gt;(1)), exec);
 188     }
 189     RETURN_TWO(0, bitwise_cast&lt;void*&gt;(static_cast&lt;uintptr_t&gt;(slotsToAdd)));
 190 }
 191 
 192 SLOW_PATH_DECL(slow_path_construct_arityCheck)
 193 {
 194     BEGIN();
 195     int slotsToAdd = CommonSlowPaths::arityCheckFor(exec, vm, CodeForConstruct);
 196     if (UNLIKELY(slotsToAdd &lt; 0)) {
 197         CodeBlock* codeBlock = CommonSlowPaths::codeBlockFromCallFrameCallee(exec, CodeForConstruct);
 198         exec-&gt;convertToStackOverflowFrame(vm, codeBlock);
<a name="3" id="anc3"></a><span class="line-modified"> 199         NativeCallFrameTracer tracer(&amp;vm, exec);</span>
 200         ErrorHandlingScope errorScope(vm);
 201         throwArityCheckStackOverflowError(exec, throwScope);
 202         RETURN_TWO(bitwise_cast&lt;void*&gt;(static_cast&lt;uintptr_t&gt;(1)), exec);
 203     }
 204     RETURN_TWO(0, bitwise_cast&lt;void*&gt;(static_cast&lt;uintptr_t&gt;(slotsToAdd)));
 205 }
 206 
 207 SLOW_PATH_DECL(slow_path_create_direct_arguments)
 208 {
 209     BEGIN();
 210     auto bytecode = pc-&gt;as&lt;OpCreateDirectArguments&gt;();
 211     RETURN(DirectArguments::createByCopying(exec));
 212 }
 213 
 214 SLOW_PATH_DECL(slow_path_create_scoped_arguments)
 215 {
 216     BEGIN();
 217     auto bytecode = pc-&gt;as&lt;OpCreateScopedArguments&gt;();
 218     JSLexicalEnvironment* scope = jsCast&lt;JSLexicalEnvironment*&gt;(GET(bytecode.m_scope).jsValue());
 219     ScopedArgumentsTable* table = scope-&gt;symbolTable()-&gt;arguments();
 220     RETURN(ScopedArguments::createByCopying(exec, table, scope));
 221 }
 222 
 223 SLOW_PATH_DECL(slow_path_create_cloned_arguments)
 224 {
 225     BEGIN();
 226     auto bytecode = pc-&gt;as&lt;OpCreateClonedArguments&gt;();
 227     RETURN(ClonedArguments::createWithMachineFrame(exec, exec, ArgumentsMode::Cloned));
 228 }
 229 
 230 SLOW_PATH_DECL(slow_path_create_this)
 231 {
 232     BEGIN();
 233     auto bytecode = pc-&gt;as&lt;OpCreateThis&gt;();
 234     JSObject* result;
 235     JSObject* constructorAsObject = asObject(GET(bytecode.m_callee).jsValue());
 236     if (constructorAsObject-&gt;type() == JSFunctionType &amp;&amp; jsCast&lt;JSFunction*&gt;(constructorAsObject)-&gt;canUseAllocationProfile()) {
 237         JSFunction* constructor = jsCast&lt;JSFunction*&gt;(constructorAsObject);
 238         WriteBarrier&lt;JSCell&gt;&amp; cachedCallee = bytecode.metadata(exec).m_cachedCallee;
 239         if (!cachedCallee)
 240             cachedCallee.set(vm, exec-&gt;codeBlock(), constructor);
 241         else if (cachedCallee.unvalidatedGet() != JSCell::seenMultipleCalleeObjects() &amp;&amp; cachedCallee.get() != constructor)
 242             cachedCallee.setWithoutWriteBarrier(JSCell::seenMultipleCalleeObjects());
 243 
 244         size_t inlineCapacity = bytecode.m_inlineCapacity;
<a name="4" id="anc4"></a><span class="line-modified"> 245         ObjectAllocationProfile* allocationProfile = constructor-&gt;ensureRareDataAndAllocationProfile(exec, inlineCapacity)-&gt;objectAllocationProfile();</span>
 246         throwScope.releaseAssertNoException();
 247         Structure* structure = allocationProfile-&gt;structure();
 248         result = constructEmptyObject(exec, structure);
 249         if (structure-&gt;hasPolyProto()) {
 250             JSObject* prototype = allocationProfile-&gt;prototype();
 251             ASSERT(prototype == constructor-&gt;prototypeForConstruction(vm, exec));
 252             result-&gt;putDirect(vm, knownPolyProtoOffset, prototype);
 253             prototype-&gt;didBecomePrototype();
 254             ASSERT_WITH_MESSAGE(!hasIndexedProperties(result-&gt;indexingType()), &quot;We rely on JSFinalObject not starting out with an indexing type otherwise we would potentially need to convert to slow put storage&quot;);
 255         }
 256     } else {
 257         // http://ecma-international.org/ecma-262/6.0/#sec-ordinarycreatefromconstructor
 258         JSValue proto = constructorAsObject-&gt;get(exec, vm.propertyNames-&gt;prototype);
 259         CHECK_EXCEPTION();
 260         if (proto.isObject())
 261             result = constructEmptyObject(exec, asObject(proto));
 262         else
 263             result = constructEmptyObject(exec);
 264     }
 265     RETURN(result);
 266 }
 267 
 268 SLOW_PATH_DECL(slow_path_to_this)
 269 {
 270     BEGIN();
 271     auto bytecode = pc-&gt;as&lt;OpToThis&gt;();
 272     auto&amp; metadata = bytecode.metadata(exec);
 273     JSValue v1 = GET(bytecode.m_srcDst).jsValue();
 274     if (v1.isCell()) {
<a name="5" id="anc5"></a><span class="line-modified"> 275         Structure* myStructure = v1.asCell()-&gt;structure(vm);</span>
<span class="line-modified"> 276         Structure* otherStructure = metadata.m_cachedStructure.get();</span>
<span class="line-modified"> 277         if (myStructure != otherStructure) {</span>
<span class="line-modified"> 278             if (otherStructure)</span>
 279                 metadata.m_toThisStatus = ToThisConflicted;
<a name="6" id="anc6"></a><span class="line-modified"> 280             metadata.m_cachedStructure.set(vm, exec-&gt;codeBlock(), myStructure);</span>

 281         }
 282     } else {
 283         metadata.m_toThisStatus = ToThisConflicted;
<a name="7" id="anc7"></a><span class="line-modified"> 284         metadata.m_cachedStructure.clear();</span>
 285     }
 286     // Note: We only need to do this value profiling here on the slow path. The fast path
 287     // just returns the input to to_this if the structure check succeeds. If the structure
 288     // check succeeds, doing value profiling here is equivalent to doing it with a potentially
 289     // different object that still has the same structure on the fast path since it&#39;ll produce
 290     // the same SpeculatedType. Therefore, we don&#39;t need to worry about value profiling on the
 291     // fast path.
 292     auto value = v1.toThis(exec, exec-&gt;codeBlock()-&gt;isStrictMode() ? StrictMode : NotStrictMode);
 293     RETURN_WITH_PROFILING_CUSTOM(bytecode.m_srcDst, value, PROFILE_VALUE(value));
 294 }
 295 
 296 SLOW_PATH_DECL(slow_path_throw_tdz_error)
 297 {
 298     BEGIN();
 299     THROW(createTDZError(exec));
 300 }
 301 
 302 SLOW_PATH_DECL(slow_path_check_tdz)
 303 {
 304     BEGIN();
 305     THROW(createTDZError(exec));
 306 }
 307 
 308 SLOW_PATH_DECL(slow_path_throw_strict_mode_readonly_property_write_error)
 309 {
 310     BEGIN();
 311     THROW(createTypeError(exec, ReadonlyPropertyWriteError));
 312 }
 313 
 314 SLOW_PATH_DECL(slow_path_not)
 315 {
 316     BEGIN();
 317     auto bytecode = pc-&gt;as&lt;OpNot&gt;();
 318     RETURN(jsBoolean(!GET_C(bytecode.m_operand).jsValue().toBoolean(exec)));
 319 }
 320 
 321 SLOW_PATH_DECL(slow_path_eq)
 322 {
 323     BEGIN();
 324     auto bytecode = pc-&gt;as&lt;OpEq&gt;();
 325     RETURN(jsBoolean(JSValue::equal(exec, GET_C(bytecode.m_lhs).jsValue(), GET_C(bytecode.m_rhs).jsValue())));
 326 }
 327 
 328 SLOW_PATH_DECL(slow_path_neq)
 329 {
 330     BEGIN();
 331     auto bytecode = pc-&gt;as&lt;OpNeq&gt;();
 332     RETURN(jsBoolean(!JSValue::equal(exec, GET_C(bytecode.m_lhs).jsValue(), GET_C(bytecode.m_rhs).jsValue())));
 333 }
 334 
 335 SLOW_PATH_DECL(slow_path_stricteq)
 336 {
 337     BEGIN();
 338     auto bytecode = pc-&gt;as&lt;OpStricteq&gt;();
 339     RETURN(jsBoolean(JSValue::strictEqual(exec, GET_C(bytecode.m_lhs).jsValue(), GET_C(bytecode.m_rhs).jsValue())));
 340 }
 341 
 342 SLOW_PATH_DECL(slow_path_nstricteq)
 343 {
 344     BEGIN();
 345     auto bytecode = pc-&gt;as&lt;OpNstricteq&gt;();
 346     RETURN(jsBoolean(!JSValue::strictEqual(exec, GET_C(bytecode.m_lhs).jsValue(), GET_C(bytecode.m_rhs).jsValue())));
 347 }
 348 
 349 SLOW_PATH_DECL(slow_path_less)
 350 {
 351     BEGIN();
 352     auto bytecode = pc-&gt;as&lt;OpLess&gt;();
 353     RETURN(jsBoolean(jsLess&lt;true&gt;(exec, GET_C(bytecode.m_lhs).jsValue(), GET_C(bytecode.m_rhs).jsValue())));
 354 }
 355 
 356 SLOW_PATH_DECL(slow_path_lesseq)
 357 {
 358     BEGIN();
 359     auto bytecode = pc-&gt;as&lt;OpLesseq&gt;();
 360     RETURN(jsBoolean(jsLessEq&lt;true&gt;(exec, GET_C(bytecode.m_lhs).jsValue(), GET_C(bytecode.m_rhs).jsValue())));
 361 }
 362 
 363 SLOW_PATH_DECL(slow_path_greater)
 364 {
 365     BEGIN();
 366     auto bytecode = pc-&gt;as&lt;OpGreater&gt;();
 367     RETURN(jsBoolean(jsLess&lt;false&gt;(exec, GET_C(bytecode.m_rhs).jsValue(), GET_C(bytecode.m_lhs).jsValue())));
 368 }
 369 
 370 SLOW_PATH_DECL(slow_path_greatereq)
 371 {
 372     BEGIN();
 373     auto bytecode = pc-&gt;as&lt;OpGreatereq&gt;();
 374     RETURN(jsBoolean(jsLessEq&lt;false&gt;(exec, GET_C(bytecode.m_rhs).jsValue(), GET_C(bytecode.m_lhs).jsValue())));
 375 }
 376 
 377 SLOW_PATH_DECL(slow_path_inc)
 378 {
 379     BEGIN();
 380     auto bytecode = pc-&gt;as&lt;OpInc&gt;();
 381     RETURN_WITH_PROFILING_CUSTOM(bytecode.m_srcDst, jsNumber(GET(bytecode.m_srcDst).jsValue().toNumber(exec) + 1), { });
 382 }
 383 
 384 SLOW_PATH_DECL(slow_path_dec)
 385 {
 386     BEGIN();
 387     auto bytecode = pc-&gt;as&lt;OpDec&gt;();
 388     RETURN_WITH_PROFILING_CUSTOM(bytecode.m_srcDst, jsNumber(GET(bytecode.m_srcDst).jsValue().toNumber(exec) - 1), { });
 389 }
 390 
 391 SLOW_PATH_DECL(slow_path_to_string)
 392 {
 393     BEGIN();
 394     auto bytecode = pc-&gt;as&lt;OpToString&gt;();
 395     RETURN(GET_C(bytecode.m_operand).jsValue().toString(exec));
 396 }
 397 
 398 #if ENABLE(JIT)
 399 static void updateArithProfileForUnaryArithOp(OpNegate::Metadata&amp; metadata, JSValue result, JSValue operand)
 400 {
 401     ArithProfile&amp; profile = metadata.m_arithProfile;
 402     profile.observeLHS(operand);
 403     ASSERT(result.isNumber() || result.isBigInt());
 404     if (result.isNumber()) {
 405         if (!result.isInt32()) {
 406             if (operand.isInt32())
 407                 profile.setObservedInt32Overflow();
 408 
 409             double doubleVal = result.asNumber();
 410             if (!doubleVal &amp;&amp; std::signbit(doubleVal))
 411                 profile.setObservedNegZeroDouble();
 412             else {
 413                 profile.setObservedNonNegZeroDouble();
 414 
 415                 // The Int52 overflow check here intentionally omits 1ll &lt;&lt; 51 as a valid negative Int52 value.
 416                 // Therefore, we will get a false positive if the result is that value. This is intentionally
 417                 // done to simplify the checking algorithm.
 418                 static const int64_t int52OverflowPoint = (1ll &lt;&lt; 51);
 419                 int64_t int64Val = static_cast&lt;int64_t&gt;(std::abs(doubleVal));
 420                 if (int64Val &gt;= int52OverflowPoint)
 421                     profile.setObservedInt52Overflow();
 422             }
 423         }
 424     } else if (result.isBigInt())
 425         profile.setObservedBigInt();
 426     else
 427         profile.setObservedNonNumeric();
 428 }
 429 #else
 430 static void updateArithProfileForUnaryArithOp(OpNegate::Metadata&amp;, JSValue, JSValue) { }
 431 #endif
 432 
 433 SLOW_PATH_DECL(slow_path_negate)
 434 {
 435     BEGIN();
 436     auto bytecode = pc-&gt;as&lt;OpNegate&gt;();
 437     auto&amp; metadata = bytecode.metadata(exec);
 438     JSValue operand = GET_C(bytecode.m_operand).jsValue();
 439     JSValue primValue = operand.toPrimitive(exec, PreferNumber);
 440     CHECK_EXCEPTION();
 441 
 442     if (primValue.isBigInt()) {
 443         JSBigInt* result = JSBigInt::unaryMinus(vm, asBigInt(primValue));
 444         RETURN_WITH_PROFILING(result, {
 445             updateArithProfileForUnaryArithOp(metadata, result, operand);
 446         });
 447     }
 448 
 449     JSValue result = jsNumber(-primValue.toNumber(exec));
 450     CHECK_EXCEPTION();
 451     RETURN_WITH_PROFILING(result, {
 452         updateArithProfileForUnaryArithOp(metadata, result, operand);
 453     });
 454 }
 455 
 456 #if ENABLE(DFG_JIT)
 457 static void updateArithProfileForBinaryArithOp(ExecState* exec, const Instruction* pc, JSValue result, JSValue left, JSValue right)
 458 {
 459     CodeBlock* codeBlock = exec-&gt;codeBlock();
 460     ArithProfile&amp; profile = *codeBlock-&gt;arithProfileForPC(pc);
 461 
 462     if (result.isNumber()) {
 463         if (!result.isInt32()) {
 464             if (left.isInt32() &amp;&amp; right.isInt32())
 465                 profile.setObservedInt32Overflow();
 466 
 467             double doubleVal = result.asNumber();
 468             if (!doubleVal &amp;&amp; std::signbit(doubleVal))
 469                 profile.setObservedNegZeroDouble();
 470             else {
 471                 profile.setObservedNonNegZeroDouble();
 472 
 473                 // The Int52 overflow check here intentionally omits 1ll &lt;&lt; 51 as a valid negative Int52 value.
 474                 // Therefore, we will get a false positive if the result is that value. This is intentionally
 475                 // done to simplify the checking algorithm.
 476                 static const int64_t int52OverflowPoint = (1ll &lt;&lt; 51);
 477                 int64_t int64Val = static_cast&lt;int64_t&gt;(std::abs(doubleVal));
 478                 if (int64Val &gt;= int52OverflowPoint)
 479                     profile.setObservedInt52Overflow();
 480             }
 481         }
 482     } else if (result.isBigInt())
 483         profile.setObservedBigInt();
 484     else
 485         profile.setObservedNonNumeric();
 486 }
 487 #else
 488 static void updateArithProfileForBinaryArithOp(ExecState*, const Instruction*, JSValue, JSValue, JSValue) { }
 489 #endif
 490 
 491 SLOW_PATH_DECL(slow_path_to_number)
 492 {
 493     BEGIN();
 494     auto bytecode = pc-&gt;as&lt;OpToNumber&gt;();
 495     JSValue argument = GET_C(bytecode.m_operand).jsValue();
 496     JSValue result = jsNumber(argument.toNumber(exec));
 497     RETURN_PROFILED(result);
 498 }
 499 
 500 SLOW_PATH_DECL(slow_path_to_object)
 501 {
 502     BEGIN();
 503     auto bytecode = pc-&gt;as&lt;OpToObject&gt;();
 504     JSValue argument = GET_C(bytecode.m_operand).jsValue();
 505     if (UNLIKELY(argument.isUndefinedOrNull())) {
 506         const Identifier&amp; ident = exec-&gt;codeBlock()-&gt;identifier(bytecode.m_message);
 507         if (!ident.isEmpty())
 508             THROW(createTypeError(exec, ident.impl()));
 509     }
 510     JSObject* result = argument.toObject(exec);
 511     RETURN_PROFILED(result);
 512 }
 513 
 514 SLOW_PATH_DECL(slow_path_add)
 515 {
 516     BEGIN();
 517     auto bytecode = pc-&gt;as&lt;OpAdd&gt;();
 518     JSValue v1 = GET_C(bytecode.m_lhs).jsValue();
 519     JSValue v2 = GET_C(bytecode.m_rhs).jsValue();
 520 
 521     ArithProfile&amp; arithProfile = *exec-&gt;codeBlock()-&gt;arithProfileForPC(pc);
 522     arithProfile.observeLHSAndRHS(v1, v2);
 523 
 524     JSValue result = jsAdd(exec, v1, v2);
 525 
 526     RETURN_WITH_PROFILING(result, {
 527         updateArithProfileForBinaryArithOp(exec, pc, result, v1, v2);
 528     });
 529 }
 530 
 531 // The following arithmetic and bitwise operations need to be sure to run
 532 // toNumber() on their operands in order.  (A call to toNumber() is idempotent
 533 // if an exception is already set on the ExecState.)
 534 
 535 SLOW_PATH_DECL(slow_path_mul)
 536 {
 537     BEGIN();
 538     auto bytecode = pc-&gt;as&lt;OpMul&gt;();
 539     JSValue left = GET_C(bytecode.m_lhs).jsValue();
 540     JSValue right = GET_C(bytecode.m_rhs).jsValue();
 541     JSValue result = jsMul(exec, left, right);
 542     CHECK_EXCEPTION();
 543     RETURN_WITH_PROFILING(result, {
 544         updateArithProfileForBinaryArithOp(exec, pc, result, left, right);
 545     });
 546 }
 547 
 548 SLOW_PATH_DECL(slow_path_sub)
 549 {
 550     BEGIN();
 551     auto bytecode = pc-&gt;as&lt;OpSub&gt;();
 552     JSValue left = GET_C(bytecode.m_lhs).jsValue();
 553     JSValue right = GET_C(bytecode.m_rhs).jsValue();
 554     auto leftNumeric = left.toNumeric(exec);
 555     CHECK_EXCEPTION();
 556     auto rightNumeric = right.toNumeric(exec);
 557     CHECK_EXCEPTION();
 558 
 559     if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) || WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {
 560         if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) &amp;&amp; WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {
 561             JSBigInt* result = JSBigInt::sub(exec, WTF::get&lt;JSBigInt*&gt;(leftNumeric), WTF::get&lt;JSBigInt*&gt;(rightNumeric));
 562             CHECK_EXCEPTION();
 563             RETURN_WITH_PROFILING(result, {
 564                 updateArithProfileForBinaryArithOp(exec, pc, result, left, right);
 565             });
 566         }
 567 
 568         THROW(createTypeError(exec, &quot;Invalid mix of BigInt and other type in subtraction.&quot;));
 569     }
 570 
 571     JSValue result = jsNumber(WTF::get&lt;double&gt;(leftNumeric) - WTF::get&lt;double&gt;(rightNumeric));
 572     RETURN_WITH_PROFILING(result, {
 573         updateArithProfileForBinaryArithOp(exec, pc, result, left, right);
 574     });
 575 }
 576 
 577 SLOW_PATH_DECL(slow_path_div)
 578 {
 579     BEGIN();
 580     auto bytecode = pc-&gt;as&lt;OpDiv&gt;();
 581     JSValue left = GET_C(bytecode.m_lhs).jsValue();
 582     JSValue right = GET_C(bytecode.m_rhs).jsValue();
 583     auto leftNumeric = left.toNumeric(exec);
 584     CHECK_EXCEPTION();
 585     auto rightNumeric = right.toNumeric(exec);
 586     CHECK_EXCEPTION();
 587 
 588     if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) || WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {
 589         if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) &amp;&amp; WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {
 590             JSBigInt* result = JSBigInt::divide(exec, WTF::get&lt;JSBigInt*&gt;(leftNumeric), WTF::get&lt;JSBigInt*&gt;(rightNumeric));
 591             CHECK_EXCEPTION();
 592             RETURN_WITH_PROFILING(result, {
 593                 updateArithProfileForBinaryArithOp(exec, pc, result, left, right);
 594             });
 595         }
 596 
 597         THROW(createTypeError(exec, &quot;Invalid mix of BigInt and other type in division.&quot;));
 598     }
 599 
 600     double a = WTF::get&lt;double&gt;(leftNumeric);
 601     double b = WTF::get&lt;double&gt;(rightNumeric);
 602     JSValue result = jsNumber(a / b);
 603     RETURN_WITH_PROFILING(result, {
 604         updateArithProfileForBinaryArithOp(exec, pc, result, left, right);
 605     });
 606 }
 607 
 608 SLOW_PATH_DECL(slow_path_mod)
 609 {
 610     BEGIN();
 611     auto bytecode = pc-&gt;as&lt;OpMod&gt;();
 612     JSValue left = GET_C(bytecode.m_lhs).jsValue();
 613     JSValue right = GET_C(bytecode.m_rhs).jsValue();
 614     auto leftNumeric = left.toNumeric(exec);
 615     CHECK_EXCEPTION();
 616     auto rightNumeric = right.toNumeric(exec);
 617     CHECK_EXCEPTION();
 618 
 619     if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) || WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {
 620         if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) &amp;&amp; WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {
 621             JSBigInt* result = JSBigInt::remainder(exec, WTF::get&lt;JSBigInt*&gt;(leftNumeric), WTF::get&lt;JSBigInt*&gt;(rightNumeric));
 622             CHECK_EXCEPTION();
 623             RETURN(result);
 624         }
 625 
 626         THROW(createTypeError(exec, &quot;Invalid mix of BigInt and other type in remainder operation.&quot;));
 627     }
 628 
 629     double a = WTF::get&lt;double&gt;(leftNumeric);
 630     double b = WTF::get&lt;double&gt;(rightNumeric);
 631     RETURN(jsNumber(jsMod(a, b)));
 632 }
 633 
 634 SLOW_PATH_DECL(slow_path_pow)
 635 {
 636     BEGIN();
 637     auto bytecode = pc-&gt;as&lt;OpPow&gt;();
<a name="8" id="anc8"></a><span class="line-modified"> 638     double a = GET_C(bytecode.m_lhs).jsValue().toNumber(exec);</span>
<span class="line-modified"> 639     if (UNLIKELY(throwScope.exception()))</span>
<span class="line-modified"> 640         RETURN(JSValue());</span>
<span class="line-modified"> 641     double b = GET_C(bytecode.m_rhs).jsValue().toNumber(exec);</span>
<span class="line-modified"> 642     if (UNLIKELY(throwScope.exception()))</span>
<span class="line-modified"> 643         RETURN(JSValue());</span>














 644     RETURN(jsNumber(operationMathPow(a, b)));
 645 }
 646 
 647 SLOW_PATH_DECL(slow_path_lshift)
 648 {
 649     BEGIN();
 650     auto bytecode = pc-&gt;as&lt;OpLshift&gt;();
 651     JSValue left = GET_C(bytecode.m_lhs).jsValue();
 652     JSValue right = GET_C(bytecode.m_rhs).jsValue();
 653     auto leftNumeric = left.toBigIntOrInt32(exec);
 654     CHECK_EXCEPTION();
 655     auto rightNumeric = right.toBigIntOrInt32(exec);
 656     CHECK_EXCEPTION();
 657 
 658     if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) || WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {
 659         if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) &amp;&amp; WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {
 660             JSBigInt* result = JSBigInt::leftShift(exec, WTF::get&lt;JSBigInt*&gt;(leftNumeric), WTF::get&lt;JSBigInt*&gt;(rightNumeric));
 661             CHECK_EXCEPTION();
<a name="9" id="anc9"></a><span class="line-modified"> 662             RETURN(result);</span>
 663         }
 664 
 665         THROW(createTypeError(exec, &quot;Invalid mix of BigInt and other type in left shift operation.&quot;));
 666     }
 667 
<a name="10" id="anc10"></a><span class="line-modified"> 668     RETURN(jsNumber(WTF::get&lt;int32_t&gt;(leftNumeric) &lt;&lt; (WTF::get&lt;int32_t&gt;(rightNumeric) &amp; 31)));</span>
 669 }
 670 
 671 SLOW_PATH_DECL(slow_path_rshift)
 672 {
 673     BEGIN();
 674     auto bytecode = pc-&gt;as&lt;OpRshift&gt;();
 675     JSValue left = GET_C(bytecode.m_lhs).jsValue();
 676     JSValue right = GET_C(bytecode.m_rhs).jsValue();
 677     auto leftNumeric = left.toBigIntOrInt32(exec);
 678     CHECK_EXCEPTION();
 679     auto rightNumeric = right.toBigIntOrInt32(exec);
 680     CHECK_EXCEPTION();
 681 
 682     if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) || WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {
 683         if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) &amp;&amp; WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {
 684             JSBigInt* result = JSBigInt::signedRightShift(exec, WTF::get&lt;JSBigInt*&gt;(leftNumeric), WTF::get&lt;JSBigInt*&gt;(rightNumeric));
 685             CHECK_EXCEPTION();
 686             RETURN(result);
 687         }
 688 
 689         THROW(createTypeError(exec, &quot;Invalid mix of BigInt and other type in signed right shift operation.&quot;));
 690     }
 691 
 692     RETURN(jsNumber(WTF::get&lt;int32_t&gt;(leftNumeric) &gt;&gt; (WTF::get&lt;int32_t&gt;(rightNumeric) &amp; 31)));
 693 }
 694 
 695 SLOW_PATH_DECL(slow_path_urshift)
 696 {
 697     BEGIN();
 698     auto bytecode = pc-&gt;as&lt;OpUrshift&gt;();
 699     uint32_t a = GET_C(bytecode.m_lhs).jsValue().toUInt32(exec);
 700     if (UNLIKELY(throwScope.exception()))
 701         RETURN(JSValue());
 702     uint32_t b = GET_C(bytecode.m_rhs).jsValue().toUInt32(exec);
 703     RETURN(jsNumber(static_cast&lt;int32_t&gt;(a &gt;&gt; (b &amp; 31))));
 704 }
 705 
 706 SLOW_PATH_DECL(slow_path_unsigned)
 707 {
 708     BEGIN();
 709     auto bytecode = pc-&gt;as&lt;OpUnsigned&gt;();
 710     uint32_t a = GET_C(bytecode.m_operand).jsValue().toUInt32(exec);
 711     RETURN(jsNumber(a));
 712 }
 713 
 714 SLOW_PATH_DECL(slow_path_bitnot)
 715 {
 716     BEGIN();
 717     auto bytecode = pc-&gt;as&lt;OpBitnot&gt;();
<a name="11" id="anc11"></a><span class="line-modified"> 718     int32_t operand = GET_C(bytecode.m_operand).jsValue().toInt32(exec);</span>
 719     CHECK_EXCEPTION();
<a name="12" id="anc12"></a><span class="line-modified"> 720     RETURN_PROFILED(jsNumber(~operand));</span>







 721 }
 722 
 723 SLOW_PATH_DECL(slow_path_bitand)
 724 {
 725     BEGIN();
 726     auto bytecode = pc-&gt;as&lt;OpBitand&gt;();
 727     auto leftNumeric = GET_C(bytecode.m_lhs).jsValue().toBigIntOrInt32(exec);
 728     CHECK_EXCEPTION();
 729     auto rightNumeric = GET_C(bytecode.m_rhs).jsValue().toBigIntOrInt32(exec);
 730     CHECK_EXCEPTION();
 731     if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) || WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {
 732         if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) &amp;&amp; WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {
 733             JSBigInt* result = JSBigInt::bitwiseAnd(exec, WTF::get&lt;JSBigInt*&gt;(leftNumeric), WTF::get&lt;JSBigInt*&gt;(rightNumeric));
 734             CHECK_EXCEPTION();
 735             RETURN_PROFILED(result);
 736         }
 737 
 738         THROW(createTypeError(exec, &quot;Invalid mix of BigInt and other type in bitwise &#39;and&#39; operation.&quot;));
 739     }
 740 
 741     RETURN_PROFILED(jsNumber(WTF::get&lt;int32_t&gt;(leftNumeric) &amp; WTF::get&lt;int32_t&gt;(rightNumeric)));
 742 }
 743 
 744 SLOW_PATH_DECL(slow_path_bitor)
 745 {
 746     BEGIN();
 747     auto bytecode = pc-&gt;as&lt;OpBitor&gt;();
 748     auto leftNumeric = GET_C(bytecode.m_lhs).jsValue().toBigIntOrInt32(exec);
 749     CHECK_EXCEPTION();
 750     auto rightNumeric = GET_C(bytecode.m_rhs).jsValue().toBigIntOrInt32(exec);
 751     CHECK_EXCEPTION();
 752     if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) || WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {
 753         if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) &amp;&amp; WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {
 754             JSBigInt* result = JSBigInt::bitwiseOr(exec, WTF::get&lt;JSBigInt*&gt;(leftNumeric), WTF::get&lt;JSBigInt*&gt;(rightNumeric));
 755             CHECK_EXCEPTION();
 756             RETURN_PROFILED(result);
 757         }
 758 
 759         THROW(createTypeError(exec, &quot;Invalid mix of BigInt and other type in bitwise &#39;or&#39; operation.&quot;));
 760     }
 761 
 762     RETURN_PROFILED(jsNumber(WTF::get&lt;int32_t&gt;(leftNumeric) | WTF::get&lt;int32_t&gt;(rightNumeric)));
 763 }
 764 
 765 SLOW_PATH_DECL(slow_path_bitxor)
 766 {
 767     BEGIN();
 768     auto bytecode = pc-&gt;as&lt;OpBitxor&gt;();
 769     auto leftNumeric = GET_C(bytecode.m_lhs).jsValue().toBigIntOrInt32(exec);
 770     CHECK_EXCEPTION();
 771     auto rightNumeric = GET_C(bytecode.m_rhs).jsValue().toBigIntOrInt32(exec);
 772     CHECK_EXCEPTION();
 773     if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) || WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {
 774         if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) &amp;&amp; WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {
 775             JSBigInt* result = JSBigInt::bitwiseXor(exec, WTF::get&lt;JSBigInt*&gt;(leftNumeric), WTF::get&lt;JSBigInt*&gt;(rightNumeric));
 776             CHECK_EXCEPTION();
 777             RETURN_PROFILED(result);
 778         }
 779 
 780         THROW(createTypeError(exec, &quot;Invalid mix of BigInt and other type in bitwise &#39;xor&#39; operation.&quot;));
 781     }
 782 
 783     RETURN_PROFILED(jsNumber(WTF::get&lt;int32_t&gt;(leftNumeric) ^ WTF::get&lt;int32_t&gt;(rightNumeric)));
 784 }
 785 
 786 SLOW_PATH_DECL(slow_path_typeof)
 787 {
 788     BEGIN();
 789     auto bytecode = pc-&gt;as&lt;OpTypeof&gt;();
 790     RETURN(jsTypeStringForValue(exec, GET_C(bytecode.m_value).jsValue()));
 791 }
 792 
 793 SLOW_PATH_DECL(slow_path_is_object_or_null)
 794 {
 795     BEGIN();
 796     auto bytecode = pc-&gt;as&lt;OpIsObjectOrNull&gt;();
 797     RETURN(jsBoolean(jsIsObjectTypeOrNull(exec, GET_C(bytecode.m_operand).jsValue())));
 798 }
 799 
 800 SLOW_PATH_DECL(slow_path_is_function)
 801 {
 802     BEGIN();
 803     auto bytecode = pc-&gt;as&lt;OpIsFunction&gt;();
 804     RETURN(jsBoolean(GET_C(bytecode.m_operand).jsValue().isFunction(vm)));
 805 }
 806 
 807 SLOW_PATH_DECL(slow_path_in_by_val)
 808 {
 809     BEGIN();
 810     auto bytecode = pc-&gt;as&lt;OpInByVal&gt;();
 811     auto&amp; metadata = bytecode.metadata(exec);
 812     RETURN(jsBoolean(CommonSlowPaths::opInByVal(exec, GET_C(bytecode.m_base).jsValue(), GET_C(bytecode.m_property).jsValue(), &amp;metadata.m_arrayProfile)));
 813 }
 814 
 815 SLOW_PATH_DECL(slow_path_in_by_id)
 816 {
 817     BEGIN();
 818 
 819     auto bytecode = pc-&gt;as&lt;OpInById&gt;();
 820     JSValue baseValue = GET_C(bytecode.m_base).jsValue();
 821     if (!baseValue.isObject())
 822         THROW(createInvalidInParameterError(exec, baseValue));
 823 
 824     RETURN(jsBoolean(asObject(baseValue)-&gt;hasProperty(exec, exec-&gt;codeBlock()-&gt;identifier(bytecode.m_property))));
 825 }
 826 
 827 SLOW_PATH_DECL(slow_path_del_by_val)
 828 {
 829     BEGIN();
 830     auto bytecode = pc-&gt;as&lt;OpDelByVal&gt;();
 831     JSValue baseValue = GET_C(bytecode.m_base).jsValue();
 832     JSObject* baseObject = baseValue.toObject(exec);
 833     CHECK_EXCEPTION();
 834 
 835     JSValue subscript = GET_C(bytecode.m_property).jsValue();
 836 
 837     bool couldDelete;
 838 
 839     uint32_t i;
 840     if (subscript.getUInt32(i))
 841         couldDelete = baseObject-&gt;methodTable(vm)-&gt;deletePropertyByIndex(baseObject, exec, i);
 842     else {
 843         CHECK_EXCEPTION();
 844         auto property = subscript.toPropertyKey(exec);
 845         CHECK_EXCEPTION();
 846         couldDelete = baseObject-&gt;methodTable(vm)-&gt;deleteProperty(baseObject, exec, property);
 847     }
 848 
 849     if (!couldDelete &amp;&amp; exec-&gt;codeBlock()-&gt;isStrictMode())
 850         THROW(createTypeError(exec, UnableToDeletePropertyError));
 851 
 852     RETURN(jsBoolean(couldDelete));
 853 }
 854 
 855 SLOW_PATH_DECL(slow_path_strcat)
 856 {
 857     BEGIN();
 858     auto bytecode = pc-&gt;as&lt;OpStrcat&gt;();
 859     RETURN(jsStringFromRegisterArray(exec, &amp;GET(bytecode.m_src), bytecode.m_count));
 860 }
 861 
 862 SLOW_PATH_DECL(slow_path_to_primitive)
 863 {
 864     BEGIN();
 865     auto bytecode = pc-&gt;as&lt;OpToPrimitive&gt;();
 866     RETURN(GET_C(bytecode.m_src).jsValue().toPrimitive(exec));
 867 }
 868 
<a name="13" id="anc13"></a><span class="line-removed"> 869 SLOW_PATH_DECL(slow_path_enter)</span>
<span class="line-removed"> 870 {</span>
<span class="line-removed"> 871     BEGIN();</span>
<span class="line-removed"> 872     CodeBlock* codeBlock = exec-&gt;codeBlock();</span>
<span class="line-removed"> 873     Heap::heap(codeBlock)-&gt;writeBarrier(codeBlock);</span>
<span class="line-removed"> 874     END();</span>
<span class="line-removed"> 875 }</span>
<span class="line-removed"> 876 </span>
 877 SLOW_PATH_DECL(slow_path_get_enumerable_length)
 878 {
 879     BEGIN();
 880     auto bytecode = pc-&gt;as&lt;OpGetEnumerableLength&gt;();
 881     JSValue enumeratorValue = GET(bytecode.m_base).jsValue();
 882     if (enumeratorValue.isUndefinedOrNull())
 883         RETURN(jsNumber(0));
 884 
 885     JSPropertyNameEnumerator* enumerator = jsCast&lt;JSPropertyNameEnumerator*&gt;(enumeratorValue.asCell());
 886 
 887     RETURN(jsNumber(enumerator-&gt;indexedLength()));
 888 }
 889 
 890 SLOW_PATH_DECL(slow_path_has_indexed_property)
 891 {
 892     BEGIN();
 893     auto bytecode = pc-&gt;as&lt;OpHasIndexedProperty&gt;();
 894     auto&amp; metadata = bytecode.metadata(exec);
 895     JSObject* base = GET(bytecode.m_base).jsValue().toObject(exec);
 896     CHECK_EXCEPTION();
 897     JSValue property = GET(bytecode.m_property).jsValue();
 898     metadata.m_arrayProfile.observeStructure(base-&gt;structure(vm));
<a name="14" id="anc14"></a><span class="line-modified"> 899     ASSERT(property.isUInt32());</span>
<span class="line-modified"> 900     RETURN(jsBoolean(base-&gt;hasPropertyGeneric(exec, property.asUInt32(), PropertySlot::InternalMethodType::GetOwnProperty)));</span>
 901 }
 902 
 903 SLOW_PATH_DECL(slow_path_has_structure_property)
 904 {
 905     BEGIN();
 906     auto bytecode = pc-&gt;as&lt;OpHasStructureProperty&gt;();
 907     JSObject* base = GET(bytecode.m_base).jsValue().toObject(exec);
 908     CHECK_EXCEPTION();
 909     JSValue property = GET(bytecode.m_property).jsValue();
 910     ASSERT(property.isString());
 911     JSPropertyNameEnumerator* enumerator = jsCast&lt;JSPropertyNameEnumerator*&gt;(GET(bytecode.m_enumerator).jsValue().asCell());
 912     if (base-&gt;structure(vm)-&gt;id() == enumerator-&gt;cachedStructureID())
 913         RETURN(jsBoolean(true));
 914     JSString* string = asString(property);
 915     auto propertyName = string-&gt;toIdentifier(exec);
 916     CHECK_EXCEPTION();
 917     RETURN(jsBoolean(base-&gt;hasPropertyGeneric(exec, propertyName, PropertySlot::InternalMethodType::GetOwnProperty)));
 918 }
 919 
 920 SLOW_PATH_DECL(slow_path_has_generic_property)
 921 {
 922     BEGIN();
 923     auto bytecode = pc-&gt;as&lt;OpHasGenericProperty&gt;();
 924     JSObject* base = GET(bytecode.m_base).jsValue().toObject(exec);
 925     CHECK_EXCEPTION();
 926     JSValue property = GET(bytecode.m_property).jsValue();
 927     ASSERT(property.isString());
 928     JSString* string = asString(property);
 929     auto propertyName = string-&gt;toIdentifier(exec);
 930     CHECK_EXCEPTION();
 931     RETURN(jsBoolean(base-&gt;hasPropertyGeneric(exec, propertyName, PropertySlot::InternalMethodType::GetOwnProperty)));
 932 }
 933 
 934 SLOW_PATH_DECL(slow_path_get_direct_pname)
 935 {
 936     BEGIN();
 937     auto bytecode = pc-&gt;as&lt;OpGetDirectPname&gt;();
 938     JSValue baseValue = GET_C(bytecode.m_base).jsValue();
 939     JSValue property = GET(bytecode.m_property).jsValue();
 940     ASSERT(property.isString());
 941     JSString* string = asString(property);
 942     auto propertyName = string-&gt;toIdentifier(exec);
 943     CHECK_EXCEPTION();
 944     RETURN(baseValue.get(exec, propertyName));
 945 }
 946 
 947 SLOW_PATH_DECL(slow_path_get_property_enumerator)
 948 {
 949     BEGIN();
 950     auto bytecode = pc-&gt;as&lt;OpGetPropertyEnumerator&gt;();
 951     JSValue baseValue = GET(bytecode.m_base).jsValue();
 952     if (baseValue.isUndefinedOrNull())
<a name="15" id="anc15"></a><span class="line-modified"> 953         RETURN(JSPropertyNameEnumerator::create(vm));</span>
 954 
 955     JSObject* base = baseValue.toObject(exec);
 956     CHECK_EXCEPTION();
 957 
 958     RETURN(propertyNameEnumerator(exec, base));
 959 }
 960 
 961 SLOW_PATH_DECL(slow_path_enumerator_structure_pname)
 962 {
 963     BEGIN();
 964     auto bytecode = pc-&gt;as&lt;OpEnumeratorStructurePname&gt;();
 965     JSPropertyNameEnumerator* enumerator = jsCast&lt;JSPropertyNameEnumerator*&gt;(GET(bytecode.m_enumerator).jsValue().asCell());
 966     uint32_t index = GET(bytecode.m_index).jsValue().asUInt32();
 967 
 968     JSString* propertyName = nullptr;
 969     if (index &lt; enumerator-&gt;endStructurePropertyIndex())
 970         propertyName = enumerator-&gt;propertyNameAtIndex(index);
 971     RETURN(propertyName ? propertyName : jsNull());
 972 }
 973 
 974 SLOW_PATH_DECL(slow_path_enumerator_generic_pname)
 975 {
 976     BEGIN();
 977     auto bytecode = pc-&gt;as&lt;OpEnumeratorGenericPname&gt;();
 978     JSPropertyNameEnumerator* enumerator = jsCast&lt;JSPropertyNameEnumerator*&gt;(GET(bytecode.m_enumerator).jsValue().asCell());
 979     uint32_t index = GET(bytecode.m_index).jsValue().asUInt32();
 980 
 981     JSString* propertyName = nullptr;
 982     if (enumerator-&gt;endStructurePropertyIndex() &lt;= index &amp;&amp; index &lt; enumerator-&gt;endGenericPropertyIndex())
 983         propertyName = enumerator-&gt;propertyNameAtIndex(index);
 984     RETURN(propertyName ? propertyName : jsNull());
 985 }
 986 
 987 SLOW_PATH_DECL(slow_path_to_index_string)
 988 {
 989     BEGIN();
 990     auto bytecode = pc-&gt;as&lt;OpToIndexString&gt;();
<a name="16" id="anc16"></a><span class="line-modified"> 991     RETURN(jsString(exec, Identifier::from(exec, GET(bytecode.m_index).jsValue().asUInt32()).string()));</span>


 992 }
 993 
 994 SLOW_PATH_DECL(slow_path_profile_type_clear_log)
 995 {
 996     BEGIN();
 997     vm.typeProfilerLog()-&gt;processLogEntries(vm, &quot;LLInt log full.&quot;_s);
 998     END();
 999 }
1000 
1001 SLOW_PATH_DECL(slow_path_unreachable)
1002 {
1003     BEGIN();
1004     UNREACHABLE_FOR_PLATFORM();
1005     END();
1006 }
1007 
1008 SLOW_PATH_DECL(slow_path_create_lexical_environment)
1009 {
1010     BEGIN();
1011     auto bytecode = pc-&gt;as&lt;OpCreateLexicalEnvironment&gt;();
1012     int scopeReg = bytecode.m_scope.offset();
1013     JSScope* currentScope = exec-&gt;uncheckedR(scopeReg).Register::scope();
1014     SymbolTable* symbolTable = jsCast&lt;SymbolTable*&gt;(GET_C(bytecode.m_symbolTable).jsValue());
1015     JSValue initialValue = GET_C(bytecode.m_initialValue).jsValue();
1016     ASSERT(initialValue == jsUndefined() || initialValue == jsTDZValue());
1017     JSScope* newScope = JSLexicalEnvironment::create(vm, exec-&gt;lexicalGlobalObject(), currentScope, symbolTable, initialValue);
1018     RETURN(newScope);
1019 }
1020 
1021 SLOW_PATH_DECL(slow_path_push_with_scope)
1022 {
1023     BEGIN();
1024     auto bytecode = pc-&gt;as&lt;OpPushWithScope&gt;();
1025     JSObject* newScope = GET_C(bytecode.m_newScope).jsValue().toObject(exec);
1026     CHECK_EXCEPTION();
1027 
1028     int scopeReg = bytecode.m_currentScope.offset();
1029     JSScope* currentScope = exec-&gt;uncheckedR(scopeReg).Register::scope();
1030     RETURN(JSWithScope::create(vm, exec-&gt;lexicalGlobalObject(), currentScope, newScope));
1031 }
1032 
1033 SLOW_PATH_DECL(slow_path_resolve_scope_for_hoisting_func_decl_in_eval)
1034 {
1035     BEGIN();
1036     auto bytecode = pc-&gt;as&lt;OpResolveScopeForHoistingFuncDeclInEval&gt;();
1037     const Identifier&amp; ident = exec-&gt;codeBlock()-&gt;identifier(bytecode.m_property);
1038     JSScope* scope = exec-&gt;uncheckedR(bytecode.m_scope.offset()).Register::scope();
1039     JSValue resolvedScope = JSScope::resolveScopeForHoistingFuncDeclInEval(exec, scope, ident);
1040 
1041     CHECK_EXCEPTION();
1042 
1043     RETURN(resolvedScope);
1044 }
1045 
1046 SLOW_PATH_DECL(slow_path_resolve_scope)
1047 {
1048     BEGIN();
1049     auto bytecode = pc-&gt;as&lt;OpResolveScope&gt;();
1050     auto&amp; metadata = bytecode.metadata(exec);
<a name="17" id="anc17"></a><span class="line-modified">1051     const Identifier&amp; ident = exec-&gt;codeBlock()-&gt;identifier(bytecode.m_var);</span>

1052     JSScope* scope = exec-&gt;uncheckedR(bytecode.m_scope.offset()).Register::scope();
1053     JSObject* resolvedScope = JSScope::resolve(exec, scope, ident);
1054     // Proxy can throw an error here, e.g. Proxy in with statement&#39;s @unscopables.
1055     CHECK_EXCEPTION();
1056 
1057     ResolveType resolveType = metadata.m_resolveType;
1058 
1059     // ModuleVar does not keep the scope register value alive in DFG.
1060     ASSERT(resolveType != ModuleVar);
1061 
1062     switch (resolveType) {
1063     case GlobalProperty:
1064     case GlobalPropertyWithVarInjectionChecks:
1065     case UnresolvedProperty:
1066     case UnresolvedPropertyWithVarInjectionChecks: {
1067         if (resolvedScope-&gt;isGlobalObject()) {
1068             JSGlobalObject* globalObject = jsCast&lt;JSGlobalObject*&gt;(resolvedScope);
1069             bool hasProperty = globalObject-&gt;hasProperty(exec, ident);
1070             CHECK_EXCEPTION();
1071             if (hasProperty) {
<a name="18" id="anc18"></a><span class="line-modified">1072                 ConcurrentJSLocker locker(exec-&gt;codeBlock()-&gt;m_lock);</span>
1073                 metadata.m_resolveType = needsVarInjectionChecks(resolveType) ? GlobalPropertyWithVarInjectionChecks : GlobalProperty;
<a name="19" id="anc19"></a><span class="line-modified">1074                 metadata.m_globalObject = globalObject;</span>
1075                 metadata.m_globalLexicalBindingEpoch = globalObject-&gt;globalLexicalBindingEpoch();
1076             }
1077         } else if (resolvedScope-&gt;isGlobalLexicalEnvironment()) {
1078             JSGlobalLexicalEnvironment* globalLexicalEnvironment = jsCast&lt;JSGlobalLexicalEnvironment*&gt;(resolvedScope);
<a name="20" id="anc20"></a><span class="line-modified">1079             ConcurrentJSLocker locker(exec-&gt;codeBlock()-&gt;m_lock);</span>
1080             metadata.m_resolveType = needsVarInjectionChecks(resolveType) ? GlobalLexicalVarWithVarInjectionChecks : GlobalLexicalVar;
<a name="21" id="anc21"></a><span class="line-modified">1081             metadata.m_globalLexicalEnvironment = globalLexicalEnvironment;</span>
1082         }
1083         break;
1084     }
1085     default:
1086         break;
1087     }
1088 
1089     RETURN(resolvedScope);
1090 }
1091 
1092 SLOW_PATH_DECL(slow_path_create_rest)
1093 {
1094     BEGIN();
1095     auto bytecode = pc-&gt;as&lt;OpCreateRest&gt;();
1096     unsigned arraySize = GET_C(bytecode.m_arraySize).jsValue().asUInt32();
1097     JSGlobalObject* globalObject = exec-&gt;lexicalGlobalObject();
1098     Structure* structure = globalObject-&gt;restParameterStructure();
1099     unsigned numParamsToSkip = bytecode.m_numParametersToSkip;
1100     JSValue* argumentsToCopyRegion = exec-&gt;addressOfArgumentsStart() + numParamsToSkip;
1101     RETURN(constructArray(exec, structure, argumentsToCopyRegion, arraySize));
1102 }
1103 
1104 SLOW_PATH_DECL(slow_path_get_by_id_with_this)
1105 {
1106     BEGIN();
1107     auto bytecode = pc-&gt;as&lt;OpGetByIdWithThis&gt;();
1108     const Identifier&amp; ident = exec-&gt;codeBlock()-&gt;identifier(bytecode.m_property);
1109     JSValue baseValue = GET_C(bytecode.m_base).jsValue();
1110     JSValue thisVal = GET_C(bytecode.m_thisValue).jsValue();
1111     PropertySlot slot(thisVal, PropertySlot::PropertySlot::InternalMethodType::Get);
1112     JSValue result = baseValue.get(exec, ident, slot);
1113     RETURN_PROFILED(result);
1114 }
1115 
1116 SLOW_PATH_DECL(slow_path_get_by_val_with_this)
1117 {
1118     BEGIN();
1119 
1120     auto bytecode = pc-&gt;as&lt;OpGetByValWithThis&gt;();
1121     JSValue baseValue = GET_C(bytecode.m_base).jsValue();
1122     JSValue thisValue = GET_C(bytecode.m_thisValue).jsValue();
1123     JSValue subscript = GET_C(bytecode.m_property).jsValue();
1124 
1125     if (LIKELY(baseValue.isCell() &amp;&amp; subscript.isString())) {
1126         Structure&amp; structure = *baseValue.asCell()-&gt;structure(vm);
1127         if (JSCell::canUseFastGetOwnProperty(structure)) {
<a name="22" id="anc22"></a><span class="line-modified">1128             if (RefPtr&lt;AtomicStringImpl&gt; existingAtomicString = asString(subscript)-&gt;toExistingAtomicString(exec)) {</span>
<span class="line-modified">1129                 if (JSValue result = baseValue.asCell()-&gt;fastGetOwnProperty(vm, structure, existingAtomicString.get()))</span>


1130                     RETURN_PROFILED(result);
1131             }
1132         }
1133     }
1134 
1135     PropertySlot slot(thisValue, PropertySlot::PropertySlot::InternalMethodType::Get);
1136     if (subscript.isUInt32()) {
1137         uint32_t i = subscript.asUInt32();
1138         if (isJSString(baseValue) &amp;&amp; asString(baseValue)-&gt;canGetIndex(i))
1139             RETURN_PROFILED(asString(baseValue)-&gt;getIndex(exec, i));
1140 
1141         RETURN_PROFILED(baseValue.get(exec, i, slot));
1142     }
1143 
1144     baseValue.requireObjectCoercible(exec);
1145     CHECK_EXCEPTION();
1146     auto property = subscript.toPropertyKey(exec);
1147     CHECK_EXCEPTION();
1148     RETURN_PROFILED(baseValue.get(exec, property, slot));
1149 }
1150 
1151 SLOW_PATH_DECL(slow_path_put_by_id_with_this)
1152 {
1153     BEGIN();
1154     auto bytecode = pc-&gt;as&lt;OpPutByIdWithThis&gt;();
1155     CodeBlock* codeBlock = exec-&gt;codeBlock();
1156     const Identifier&amp; ident = codeBlock-&gt;identifier(bytecode.m_property);
1157     JSValue baseValue = GET_C(bytecode.m_base).jsValue();
1158     JSValue thisVal = GET_C(bytecode.m_thisValue).jsValue();
1159     JSValue putValue = GET_C(bytecode.m_value).jsValue();
1160     PutPropertySlot slot(thisVal, codeBlock-&gt;isStrictMode(), codeBlock-&gt;putByIdContext());
1161     baseValue.putInline(exec, ident, putValue, slot);
1162     END();
1163 }
1164 
1165 SLOW_PATH_DECL(slow_path_put_by_val_with_this)
1166 {
1167     BEGIN();
1168     auto bytecode = pc-&gt;as&lt;OpPutByValWithThis&gt;();
1169     JSValue baseValue = GET_C(bytecode.m_base).jsValue();
1170     JSValue thisValue = GET_C(bytecode.m_thisValue).jsValue();
1171     JSValue subscript = GET_C(bytecode.m_property).jsValue();
1172     JSValue value = GET_C(bytecode.m_value).jsValue();
1173 
1174     auto property = subscript.toPropertyKey(exec);
1175     CHECK_EXCEPTION();
1176     PutPropertySlot slot(thisValue, exec-&gt;codeBlock()-&gt;isStrictMode());
1177     baseValue.put(exec, property, value, slot);
1178     END();
1179 }
1180 
1181 SLOW_PATH_DECL(slow_path_define_data_property)
1182 {
1183     BEGIN();
1184     auto bytecode = pc-&gt;as&lt;OpDefineDataProperty&gt;();
1185     JSObject* base = asObject(GET_C(bytecode.m_base).jsValue());
1186     JSValue property = GET_C(bytecode.m_property).jsValue();
1187     JSValue value = GET_C(bytecode.m_value).jsValue();
1188     JSValue attributes = GET_C(bytecode.m_attributes).jsValue();
1189     ASSERT(attributes.isInt32());
1190 
1191     auto propertyName = property.toPropertyKey(exec);
1192     CHECK_EXCEPTION();
1193     PropertyDescriptor descriptor = toPropertyDescriptor(value, jsUndefined(), jsUndefined(), DefinePropertyAttributes(attributes.asInt32()));
1194     ASSERT((descriptor.attributes() &amp; PropertyAttribute::Accessor) || (!descriptor.isAccessorDescriptor()));
1195     base-&gt;methodTable(vm)-&gt;defineOwnProperty(base, exec, propertyName, descriptor, true);
1196     END();
1197 }
1198 
1199 SLOW_PATH_DECL(slow_path_define_accessor_property)
1200 {
1201     BEGIN();
1202     auto bytecode = pc-&gt;as&lt;OpDefineAccessorProperty&gt;();
1203     JSObject* base = asObject(GET_C(bytecode.m_base).jsValue());
1204     JSValue property = GET_C(bytecode.m_property).jsValue();
1205     JSValue getter = GET_C(bytecode.m_getter).jsValue();
1206     JSValue setter = GET_C(bytecode.m_setter).jsValue();
1207     JSValue attributes = GET_C(bytecode.m_attributes).jsValue();
1208     ASSERT(attributes.isInt32());
1209 
1210     auto propertyName = property.toPropertyKey(exec);
1211     CHECK_EXCEPTION();
1212     PropertyDescriptor descriptor = toPropertyDescriptor(jsUndefined(), getter, setter, DefinePropertyAttributes(attributes.asInt32()));
1213     ASSERT((descriptor.attributes() &amp; PropertyAttribute::Accessor) || (!descriptor.isAccessorDescriptor()));
1214     base-&gt;methodTable(vm)-&gt;defineOwnProperty(base, exec, propertyName, descriptor, true);
1215     END();
1216 }
1217 
1218 SLOW_PATH_DECL(slow_path_throw_static_error)
1219 {
1220     BEGIN();
1221     auto bytecode = pc-&gt;as&lt;OpThrowStaticError&gt;();
1222     JSValue errorMessageValue = GET_C(bytecode.m_message).jsValue();
1223     RELEASE_ASSERT(errorMessageValue.isString());
1224     String errorMessage = asString(errorMessageValue)-&gt;value(exec);
1225     ErrorType errorType = bytecode.m_errorType;
1226     THROW(createError(exec, errorType, errorMessage));
1227 }
1228 
1229 SLOW_PATH_DECL(slow_path_new_array_with_spread)
1230 {
1231     BEGIN();
1232     auto bytecode = pc-&gt;as&lt;OpNewArrayWithSpread&gt;();
1233     int numItems = bytecode.m_argc;
1234     ASSERT(numItems &gt;= 0);
1235     const BitVector&amp; bitVector = exec-&gt;codeBlock()-&gt;unlinkedCodeBlock()-&gt;bitVector(bytecode.m_bitVector);
1236 
1237     JSValue* values = bitwise_cast&lt;JSValue*&gt;(&amp;GET(bytecode.m_argv));
1238 
1239     Checked&lt;unsigned, RecordOverflow&gt; checkedArraySize = 0;
1240     for (int i = 0; i &lt; numItems; i++) {
1241         if (bitVector.get(i)) {
1242             JSValue value = values[-i];
1243             JSFixedArray* array = jsCast&lt;JSFixedArray*&gt;(value);
1244             checkedArraySize += array-&gt;size();
1245         } else
1246             checkedArraySize += 1;
1247     }
1248     if (UNLIKELY(checkedArraySize.hasOverflowed()))
1249         THROW(createOutOfMemoryError(exec));
1250 
1251     unsigned arraySize = checkedArraySize.unsafeGet();
1252     if (UNLIKELY(arraySize &gt;= MIN_ARRAY_STORAGE_CONSTRUCTION_LENGTH))
1253         THROW(createOutOfMemoryError(exec));
1254 
1255     JSGlobalObject* globalObject = exec-&gt;lexicalGlobalObject();
1256     Structure* structure = globalObject-&gt;arrayStructureForIndexingTypeDuringAllocation(ArrayWithContiguous);
1257 
1258     JSArray* result = JSArray::tryCreate(vm, structure, arraySize);
1259     if (UNLIKELY(!result))
1260         THROW(createOutOfMemoryError(exec));
1261     CHECK_EXCEPTION();
1262 
1263     unsigned index = 0;
1264     for (int i = 0; i &lt; numItems; i++) {
1265         JSValue value = values[-i];
1266         if (bitVector.get(i)) {
1267             // We are spreading.
1268             JSFixedArray* array = jsCast&lt;JSFixedArray*&gt;(value);
1269             for (unsigned i = 0; i &lt; array-&gt;size(); i++) {
1270                 RELEASE_ASSERT(array-&gt;get(i));
1271                 result-&gt;putDirectIndex(exec, index, array-&gt;get(i));
1272                 CHECK_EXCEPTION();
1273                 ++index;
1274             }
1275         } else {
1276             // We are not spreading.
1277             result-&gt;putDirectIndex(exec, index, value);
1278             CHECK_EXCEPTION();
1279             ++index;
1280         }
1281     }
1282 
1283     RETURN(result);
1284 }
1285 
1286 SLOW_PATH_DECL(slow_path_new_array_buffer)
1287 {
1288     BEGIN();
1289     auto bytecode = pc-&gt;as&lt;OpNewArrayBuffer&gt;();
1290     ASSERT(exec-&gt;codeBlock()-&gt;isConstantRegisterIndex(bytecode.m_immutableButterfly.offset()));
1291     JSImmutableButterfly* immutableButterfly = bitwise_cast&lt;JSImmutableButterfly*&gt;(GET_C(bytecode.m_immutableButterfly).jsValue().asCell());
1292     auto&amp; profile = bytecode.metadata(exec).m_arrayAllocationProfile;
1293 
1294     IndexingType indexingMode = profile.selectIndexingType();
1295     Structure* structure = exec-&gt;lexicalGlobalObject()-&gt;arrayStructureForIndexingTypeDuringAllocation(indexingMode);
1296     ASSERT(isCopyOnWrite(indexingMode));
1297     ASSERT(!structure-&gt;outOfLineCapacity());
1298 
1299     if (UNLIKELY(immutableButterfly-&gt;indexingMode() != indexingMode)) {
1300         auto* newButterfly = JSImmutableButterfly::create(vm, indexingMode, immutableButterfly-&gt;length());
1301         for (unsigned i = 0; i &lt; immutableButterfly-&gt;length(); ++i)
1302             newButterfly-&gt;setIndex(vm, i, immutableButterfly-&gt;get(i));
1303         immutableButterfly = newButterfly;
1304         CodeBlock* codeBlock = exec-&gt;codeBlock();
1305 
1306         // FIXME: This is kinda gross and only works because we can&#39;t inline new_array_bufffer in the baseline.
1307         // We also cannot allocate a new butterfly from compilation threads since it&#39;s invalid to allocate cells from
1308         // a compilation thread.
1309         WTF::storeStoreFence();
1310         codeBlock-&gt;constantRegister(bytecode.m_immutableButterfly.offset()).set(vm, codeBlock, immutableButterfly);
1311         WTF::storeStoreFence();
1312     }
1313 
1314     JSArray* result = CommonSlowPaths::allocateNewArrayBuffer(vm, structure, immutableButterfly);
1315     ASSERT(isCopyOnWrite(result-&gt;indexingMode()) || exec-&gt;lexicalGlobalObject()-&gt;isHavingABadTime());
1316     ArrayAllocationProfile::updateLastAllocationFor(&amp;profile, result);
1317     RETURN(result);
1318 }
1319 
1320 SLOW_PATH_DECL(slow_path_spread)
1321 {
1322     BEGIN();
1323 
1324     auto bytecode = pc-&gt;as&lt;OpSpread&gt;();
1325     JSValue iterable = GET_C(bytecode.m_argument).jsValue();
1326 
1327     if (iterable.isCell() &amp;&amp; isJSArray(iterable.asCell())) {
1328         JSArray* array = jsCast&lt;JSArray*&gt;(iterable);
1329         if (array-&gt;isIteratorProtocolFastAndNonObservable()) {
1330             // JSFixedArray::createFromArray does not consult the prototype chain,
1331             // so we must be sure that not consulting the prototype chain would
1332             // produce the same value during iteration.
1333             RETURN(JSFixedArray::createFromArray(exec, vm, array));
1334         }
1335     }
1336 
1337     JSGlobalObject* globalObject = exec-&gt;lexicalGlobalObject();
1338 
1339     JSArray* array;
1340     {
1341         JSFunction* iterationFunction = globalObject-&gt;iteratorProtocolFunction();
1342         CallData callData;
1343         CallType callType = JSC::getCallData(vm, iterationFunction, callData);
1344         ASSERT(callType != CallType::None);
1345 
1346         MarkedArgumentBuffer arguments;
1347         arguments.append(iterable);
1348         ASSERT(!arguments.hasOverflowed());
1349         JSValue arrayResult = call(exec, iterationFunction, callType, callData, jsNull(), arguments);
1350         CHECK_EXCEPTION();
1351         array = jsCast&lt;JSArray*&gt;(arrayResult);
1352     }
1353 
1354     RETURN(JSFixedArray::createFromArray(exec, vm, array));
1355 }
1356 
1357 } // namespace JSC
<a name="23" id="anc23"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="23" type="hidden" />
</body>
</html>