<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/html/HTMLImageElement.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="HTMLIFrameElement.idl.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="HTMLImageElement.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/html/HTMLImageElement.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 29 #include &quot;Chrome.h&quot;
 30 #include &quot;ChromeClient.h&quot;
 31 #include &quot;EditableImageReference.h&quot;
 32 #include &quot;Editor.h&quot;
 33 #include &quot;ElementIterator.h&quot;
 34 #include &quot;EventNames.h&quot;
 35 #include &quot;FrameView.h&quot;
 36 #include &quot;HTMLAnchorElement.h&quot;
 37 #include &quot;HTMLAttachmentElement.h&quot;
 38 #include &quot;HTMLDocument.h&quot;
 39 #include &quot;HTMLFormElement.h&quot;
 40 #include &quot;HTMLParserIdioms.h&quot;
 41 #include &quot;HTMLPictureElement.h&quot;
 42 #include &quot;HTMLMapElement.h&quot;
 43 #include &quot;HTMLSourceElement.h&quot;
 44 #include &quot;HTMLSrcsetParser.h&quot;
 45 #include &quot;Logging.h&quot;
 46 #include &quot;MIMETypeRegistry.h&quot;
 47 #include &quot;MediaList.h&quot;
 48 #include &quot;MediaQueryEvaluator.h&quot;

 49 #include &quot;NodeTraversal.h&quot;
 50 #include &quot;PlatformMouseEvent.h&quot;
 51 #include &quot;RenderImage.h&quot;
 52 #include &quot;RenderView.h&quot;
 53 #include &quot;RuntimeEnabledFeatures.h&quot;
 54 #include &quot;Settings.h&quot;
 55 #include &quot;ShadowRoot.h&quot;
 56 #include &quot;SizesAttributeParser.h&quot;
 57 #include &lt;wtf/IsoMallocInlines.h&gt;
 58 #include &lt;wtf/text/StringBuilder.h&gt;
 59 
 60 #if ENABLE(SERVICE_CONTROLS)
 61 #include &quot;ImageControlsRootElement.h&quot;
 62 #endif
 63 
 64 namespace WebCore {
 65 
 66 WTF_MAKE_ISO_ALLOCATED_IMPL(HTMLImageElement);
 67 
 68 using namespace HTMLNames;
 69 
<span class="line-removed"> 70 typedef HashMap&lt;const HTMLImageElement*, WeakPtr&lt;HTMLPictureElement&gt;&gt; PictureOwnerMap;</span>
<span class="line-removed"> 71 static PictureOwnerMap* gPictureOwnerMap = nullptr;</span>
<span class="line-removed"> 72 </span>
 73 HTMLImageElement::HTMLImageElement(const QualifiedName&amp; tagName, Document&amp; document, HTMLFormElement* form)
 74     : HTMLElement(tagName, document)
 75     , m_imageLoader(*this)
 76     , m_form(nullptr)
<span class="line-modified"> 77     , m_formSetByParser(form)</span>
 78     , m_compositeOperator(CompositeSourceOver)
 79     , m_imageDevicePixelRatio(1.0f)
<span class="line-removed"> 80 #if ENABLE(SERVICE_CONTROLS)</span>
 81     , m_experimentalImageMenuEnabled(false)
<span class="line-removed"> 82 #endif</span>
 83 {
 84     ASSERT(hasTagName(imgTag));
 85     setHasCustomStyleResolveCallbacks();
 86 }
 87 
 88 Ref&lt;HTMLImageElement&gt; HTMLImageElement::create(Document&amp; document)
 89 {
 90     return adoptRef(*new HTMLImageElement(imgTag, document));
 91 }
 92 
 93 Ref&lt;HTMLImageElement&gt; HTMLImageElement::create(const QualifiedName&amp; tagName, Document&amp; document, HTMLFormElement* form)
 94 {
 95     return adoptRef(*new HTMLImageElement(tagName, document, form));
 96 }
 97 
 98 HTMLImageElement::~HTMLImageElement()
 99 {
100     if (m_form)
101         m_form-&gt;removeImgElement(this);
102     setPictureElement(nullptr);
103 }
104 
105 Ref&lt;HTMLImageElement&gt; HTMLImageElement::createForJSConstructor(Document&amp; document, Optional&lt;unsigned&gt; width, Optional&lt;unsigned&gt; height)
106 {
107     auto image = adoptRef(*new HTMLImageElement(imgTag, document));
108     if (width)
109         image-&gt;setWidth(width.value());
110     if (height)
111         image-&gt;setHeight(height.value());
112     return image;
113 }
114 
115 bool HTMLImageElement::isPresentationAttribute(const QualifiedName&amp; name) const
116 {
117     if (name == widthAttr || name == heightAttr || name == borderAttr || name == vspaceAttr || name == hspaceAttr || name == valignAttr)
118         return true;
119     return HTMLElement::isPresentationAttribute(name);
120 }
121 
<span class="line-modified">122 void HTMLImageElement::collectStyleForPresentationAttribute(const QualifiedName&amp; name, const AtomicString&amp; value, MutableStyleProperties&amp; style)</span>
123 {
124     if (name == widthAttr)
125         addHTMLLengthToStyle(style, CSSPropertyWidth, value);
126     else if (name == heightAttr)
127         addHTMLLengthToStyle(style, CSSPropertyHeight, value);
128     else if (name == borderAttr)
129         applyBorderAttributeToStyle(value, style);
130     else if (name == vspaceAttr) {
131         addHTMLLengthToStyle(style, CSSPropertyMarginTop, value);
132         addHTMLLengthToStyle(style, CSSPropertyMarginBottom, value);
133     } else if (name == hspaceAttr) {
134         addHTMLLengthToStyle(style, CSSPropertyMarginLeft, value);
135         addHTMLLengthToStyle(style, CSSPropertyMarginRight, value);
136     } else if (name == alignAttr)
137         applyAlignmentAttributeToStyle(value, style);
138     else if (name == valignAttr)
139         addPropertyToPresentationAttributeStyle(style, CSSPropertyVerticalAlign, value);
140     else
141         HTMLElement::collectStyleForPresentationAttribute(name, value, style);
142 }
143 
<span class="line-modified">144 const AtomicString&amp; HTMLImageElement::imageSourceURL() const</span>
145 {
146     return m_bestFitImageURL.isEmpty() ? attributeWithoutSynchronization(srcAttr) : m_bestFitImageURL;
147 }
148 
149 void HTMLImageElement::setBestFitURLAndDPRFromImageCandidate(const ImageCandidate&amp; candidate)
150 {
<span class="line-modified">151     m_bestFitImageURL = candidate.string.toAtomicString();</span>
<span class="line-modified">152     m_currentSrc = AtomicString(document().completeURL(imageSourceURL()).string());</span>
153     if (candidate.density &gt;= 0)
154         m_imageDevicePixelRatio = 1 / candidate.density;
155     if (is&lt;RenderImage&gt;(renderer()))
156         downcast&lt;RenderImage&gt;(*renderer()).setImageDevicePixelRatio(m_imageDevicePixelRatio);
157 }
158 
159 ImageCandidate HTMLImageElement::bestFitSourceFromPictureElement()
160 {
161     auto picture = makeRefPtr(pictureElement());
162     if (!picture)
163         return { };
164 
165     picture-&gt;clearViewportDependentResults();
166     document().removeViewportDependentPicture(*picture);
167 
168     picture-&gt;clearAppearanceDependentResults();
169     document().removeAppearanceDependentPicture(*picture);
170 
171     for (RefPtr&lt;Node&gt; child = picture-&gt;firstChild(); child &amp;&amp; child != this; child = child-&gt;nextSibling()) {
172         if (!is&lt;HTMLSourceElement&gt;(*child))
</pre>
<hr />
<pre>
202         auto candidate = bestFitSourceForImageAttributes(document().deviceScaleFactor(), nullAtom(), srcset, sourceSize);
203         if (!candidate.isEmpty())
204             return candidate;
205     }
206     return { };
207 }
208 
209 void HTMLImageElement::selectImageSource()
210 {
211     // First look for the best fit source from our &lt;picture&gt; parent if we have one.
212     ImageCandidate candidate = bestFitSourceFromPictureElement();
213     if (candidate.isEmpty()) {
214         // If we don&#39;t have a &lt;picture&gt; or didn&#39;t find a source, then we use our own attributes.
215         auto sourceSize = SizesAttributeParser(attributeWithoutSynchronization(sizesAttr).string(), document()).length();
216         candidate = bestFitSourceForImageAttributes(document().deviceScaleFactor(), attributeWithoutSynchronization(srcAttr), attributeWithoutSynchronization(srcsetAttr), sourceSize);
217     }
218     setBestFitURLAndDPRFromImageCandidate(candidate);
219     m_imageLoader.updateFromElementIgnoringPreviousError();
220 }
221 
<span class="line-modified">222 void HTMLImageElement::parseAttribute(const QualifiedName&amp; name, const AtomicString&amp; value)</span>
223 {
224     if (name == altAttr) {
225         if (is&lt;RenderImage&gt;(renderer()))
226             downcast&lt;RenderImage&gt;(*renderer()).updateAltText();
227     } else if (name == srcAttr || name == srcsetAttr || name == sizesAttr)
228         selectImageSource();
229     else if (name == usemapAttr) {
230         if (isInTreeScope() &amp;&amp; !m_parsedUsemap.isNull())
231             treeScope().removeImageElementByUsemap(*m_parsedUsemap.impl(), *this);
232 
233         m_parsedUsemap = parseHTMLHashNameReference(value);
234 
235         if (isInTreeScope() &amp;&amp; !m_parsedUsemap.isNull())
236             treeScope().addImageElementByUsemap(*m_parsedUsemap.impl(), *this);
237     } else if (name == compositeAttr) {
238         // FIXME: images don&#39;t support blend modes in their compositing attribute.
239         BlendMode blendOp = BlendMode::Normal;
240         if (!parseCompositeAndBlendOperator(value, m_compositeOperator, blendOp))
241             m_compositeOperator = CompositeSourceOver;
242 #if ENABLE(SERVICE_CONTROLS)
243     } else if (name == webkitimagemenuAttr) {
244         m_experimentalImageMenuEnabled = !value.isNull();
245         updateImageControls();
246 #endif
247     } else if (name == x_apple_editable_imageAttr)
248         updateEditableImage();
249     else {
250         if (name == nameAttr) {
251             bool willHaveName = !value.isNull();
252             if (m_hadNameBeforeAttributeChanged != willHaveName &amp;&amp; isConnected() &amp;&amp; !isInShadowTree() &amp;&amp; is&lt;HTMLDocument&gt;(document())) {
253                 HTMLDocument&amp; document = downcast&lt;HTMLDocument&gt;(this-&gt;document());
<span class="line-modified">254                 const AtomicString&amp; id = getIdAttribute();</span>
255                 if (!id.isEmpty() &amp;&amp; id != getNameAttribute()) {
256                     if (willHaveName)
257                         document.addDocumentNamedItem(*id.impl(), *this);
258                     else
259                         document.removeDocumentNamedItem(*id.impl(), *this);
260                 }
261             }
262             m_hadNameBeforeAttributeChanged = willHaveName;
263         }
264         HTMLElement::parseAttribute(name, value);
265     }
266 }
267 
<span class="line-modified">268 const AtomicString&amp; HTMLImageElement::altText() const</span>
269 {
270     // lets figure out the alt text.. magic stuff
271     // http://www.w3.org/TR/1998/REC-html40-19980424/appendix/notes.html#altgen
272     // also heavily discussed by Hixie on bugzilla
<span class="line-modified">273     const AtomicString&amp; alt = attributeWithoutSynchronization(altAttr);</span>
274     if (!alt.isNull())
275         return alt;
276     // fall back to title attribute
277     return attributeWithoutSynchronization(titleAttr);
278 }
279 
280 RenderPtr&lt;RenderElement&gt; HTMLImageElement::createElementRenderer(RenderStyle&amp;&amp; style, const RenderTreePosition&amp;)
281 {
282     if (style.hasContent())
283         return RenderElement::createFor(*this, WTFMove(style));
284 
285     return createRenderer&lt;RenderImage&gt;(*this, WTFMove(style), nullptr, m_imageDevicePixelRatio);
286 }
287 
288 bool HTMLImageElement::canStartSelection() const
289 {
290     if (shadowRoot())
291         return HTMLElement::canStartSelection();
292 
293     return false;
294 }
295 
296 bool HTMLImageElement::supportsFocus() const
297 {
298     if (hasEditableImageAttribute())
299         return true;
300     return HTMLElement::supportsFocus();
301 }
302 
303 bool HTMLImageElement::isFocusable() const
304 {
305     if (hasEditableImageAttribute())
306         return true;
307     return HTMLElement::isFocusable();
308 }
309 





310 void HTMLImageElement::didAttachRenderers()
311 {
312     if (!is&lt;RenderImage&gt;(renderer()))
313         return;
314     if (m_imageLoader.hasPendingBeforeLoadEvent())
315         return;
316 
317 #if ENABLE(SERVICE_CONTROLS)
318     updateImageControls();
319 #endif
320 
321     auto&amp; renderImage = downcast&lt;RenderImage&gt;(*renderer());
322     RenderImageResource&amp; renderImageResource = renderImage.imageResource();
323     if (renderImageResource.cachedImage())
324         return;
325     renderImageResource.setCachedImage(m_imageLoader.image());
326 
327     // If we have no image at all because we have no src attribute, set
328     // image height and width for the alt text instead.
329     if (!m_imageLoader.image() &amp;&amp; !renderImageResource.cachedImage())
330         renderImage.setImageSizeForAltText();
331 }
332 
333 Node::InsertedIntoAncestorResult HTMLImageElement::insertedIntoAncestor(InsertionType insertionType, ContainerNode&amp; parentOfInsertedTree)
334 {
335     if (m_formSetByParser) {
<span class="line-modified">336         m_form = m_formSetByParser;</span>
<span class="line-removed">337         m_formSetByParser = nullptr;</span>
338         m_form-&gt;registerImgElement(this);
339     }
340 
341     if (m_form &amp;&amp; rootElement() != m_form-&gt;rootElement()) {
342         m_form-&gt;removeImgElement(this);
343         m_form = nullptr;
344     }
345 
346     if (!m_form) {
<span class="line-modified">347         m_form = HTMLFormElement::findClosestFormAncestor(*this);</span>
<span class="line-modified">348         if (m_form)</span>
<span class="line-modified">349             m_form-&gt;registerImgElement(this);</span>

350     }
351 
352     // Insert needs to complete first, before we start updating the loader. Loader dispatches events which could result
353     // in callbacks back to this node.
354     Node::InsertedIntoAncestorResult insertNotificationRequest = HTMLElement::insertedIntoAncestor(insertionType, parentOfInsertedTree);
355 
356     if (insertionType.connectedToDocument &amp;&amp; hasEditableImageAttribute())
357         insertNotificationRequest = InsertedIntoAncestorResult::NeedsPostInsertionCallback;
358 
359     if (insertionType.treeScopeChanged &amp;&amp; !m_parsedUsemap.isNull())
360         treeScope().addImageElementByUsemap(*m_parsedUsemap.impl(), *this);
361 
362     if (is&lt;HTMLPictureElement&gt;(parentNode())) {
363         setPictureElement(&amp;downcast&lt;HTMLPictureElement&gt;(*parentNode()));
364         selectImageSource();
365     }
366 
367     // If we have been inserted from a renderer-less document,
368     // our loader may have not fetched the image, so do it now.
369     if (insertionType.connectedToDocument &amp;&amp; !m_imageLoader.image())
</pre>
<hr />
<pre>
437 #endif
438 
439     if (shouldBeEditable == isCurrentlyEditable)
440         return;
441 
442     if (!hasEditableAttribute) {
443         m_editableImage = nullptr;
444         return;
445     }
446 
447     if (!m_editableImage)
448         m_editableImage = EditableImageReference::create(document());
449 
450 #if ENABLE(ATTACHMENT_ELEMENT)
451     m_editableImage-&gt;associateWithAttachment(attachmentElement()-&gt;uniqueIdentifier());
452 #endif
453 }
454 
455 HTMLPictureElement* HTMLImageElement::pictureElement() const
456 {
<span class="line-modified">457     if (!gPictureOwnerMap || !gPictureOwnerMap-&gt;contains(this))</span>
<span class="line-removed">458         return nullptr;</span>
<span class="line-removed">459     auto result = gPictureOwnerMap-&gt;get(this);</span>
<span class="line-removed">460     if (!result)</span>
<span class="line-removed">461         gPictureOwnerMap-&gt;remove(this);</span>
<span class="line-removed">462     return result.get();</span>
463 }
464 
465 void HTMLImageElement::setPictureElement(HTMLPictureElement* pictureElement)
466 {
<span class="line-modified">467     if (!pictureElement) {</span>
<span class="line-removed">468         if (gPictureOwnerMap)</span>
<span class="line-removed">469             gPictureOwnerMap-&gt;remove(this);</span>
<span class="line-removed">470         return;</span>
<span class="line-removed">471     }</span>
<span class="line-removed">472 </span>
<span class="line-removed">473     if (!gPictureOwnerMap)</span>
<span class="line-removed">474         gPictureOwnerMap = new PictureOwnerMap();</span>
<span class="line-removed">475     gPictureOwnerMap-&gt;add(this, makeWeakPtr(*pictureElement));</span>
476 }
477 
478 unsigned HTMLImageElement::width(bool ignorePendingStylesheets)
479 {
480     if (!renderer()) {
481         // check the attribute first for an explicit pixel value
482         auto optionalWidth = parseHTMLNonNegativeInteger(attributeWithoutSynchronization(widthAttr));
483         if (optionalWidth)
484             return optionalWidth.value();
485 
486         // if the image is available, use its width
487         if (m_imageLoader.image())
488             return m_imageLoader.image()-&gt;imageSizeForRenderer(renderer(), 1.0f).width().toUnsigned();
489     }
490 
491     if (ignorePendingStylesheets)
492         document().updateLayoutIgnorePendingStylesheets();
493     else
494         document().updateLayout();
495 
</pre>
<hr />
<pre>
550         || HTMLElement::isURLAttribute(attribute);
551 }
552 
553 bool HTMLImageElement::attributeContainsURL(const Attribute&amp; attribute) const
554 {
555     return attribute.name() == srcsetAttr
556         || HTMLElement::attributeContainsURL(attribute);
557 }
558 
559 String HTMLImageElement::completeURLsInAttributeValue(const URL&amp; base, const Attribute&amp; attribute) const
560 {
561     if (attribute.name() == srcsetAttr) {
562         Vector&lt;ImageCandidate&gt; imageCandidates = parseImageCandidatesFromSrcsetAttribute(StringView(attribute.value()));
563         StringBuilder result;
564         for (const auto&amp; candidate : imageCandidates) {
565             if (&amp;candidate != &amp;imageCandidates[0])
566                 result.appendLiteral(&quot;, &quot;);
567             result.append(URL(base, candidate.string.toString()).string());
568             if (candidate.density != UninitializedDescriptor) {
569                 result.append(&#39; &#39;);
<span class="line-modified">570                 result.appendNumber(candidate.density);</span>
571                 result.append(&#39;x&#39;);
572             }
573             if (candidate.resourceWidth != UninitializedDescriptor) {
574                 result.append(&#39; &#39;);
575                 result.appendNumber(candidate.resourceWidth);
576                 result.append(&#39;w&#39;);
577             }
578         }
579         return result.toString();
580     }
581     return HTMLElement::completeURLsInAttributeValue(base, attribute);
582 }
583 
<span class="line-modified">584 bool HTMLImageElement::matchesUsemap(const AtomicStringImpl&amp; name) const</span>
585 {
586     return m_parsedUsemap.impl() == &amp;name;
587 }
588 
589 HTMLMapElement* HTMLImageElement::associatedMapElement() const
590 {
591     return treeScope().getImageMap(m_parsedUsemap);
592 }
593 
<span class="line-modified">594 const AtomicString&amp; HTMLImageElement::alt() const</span>
595 {
596     return attributeWithoutSynchronization(altAttr);
597 }
598 
599 bool HTMLImageElement::draggable() const
600 {
601     // Image elements are draggable by default.
602     return !equalLettersIgnoringASCIICase(attributeWithoutSynchronization(draggableAttr), &quot;false&quot;);
603 }
604 
605 void HTMLImageElement::setHeight(unsigned value)
606 {
607     setUnsignedIntegralAttribute(heightAttr, value);
608 }
609 
610 URL HTMLImageElement::src() const
611 {
612     return document().completeURL(attributeWithoutSynchronization(srcAttr));
613 }
614 
</pre>
<hr />
<pre>
634 }
635 
636 int HTMLImageElement::y() const
637 {
638     document().updateLayoutIgnorePendingStylesheets();
639     auto renderer = this-&gt;renderer();
640     if (!renderer)
641         return 0;
642 
643     // FIXME: This doesn&#39;t work correctly with transforms.
644     return renderer-&gt;localToAbsolute().y();
645 }
646 
647 bool HTMLImageElement::complete() const
648 {
649     return m_imageLoader.imageComplete();
650 }
651 
652 DecodingMode HTMLImageElement::decodingMode() const
653 {
<span class="line-modified">654     const AtomicString&amp; decodingMode = attributeWithoutSynchronization(decodingAttr);</span>
655     if (equalLettersIgnoringASCIICase(decodingMode, &quot;sync&quot;))
656         return DecodingMode::Synchronous;
657     if (equalLettersIgnoringASCIICase(decodingMode, &quot;async&quot;))
658         return DecodingMode::Asynchronous;
659     return DecodingMode::Auto;
660 }
661 
662 void HTMLImageElement::decode(Ref&lt;DeferredPromise&gt;&amp;&amp; promise)
663 {
664     return m_imageLoader.decode(WTFMove(promise));
665 }
666 
667 void HTMLImageElement::addSubresourceAttributeURLs(ListHashSet&lt;URL&gt;&amp; urls) const
668 {
669     HTMLElement::addSubresourceAttributeURLs(urls);
670 
671     addSubresourceURL(urls, document().completeURL(imageSourceURL()));
672     // FIXME: What about when the usemap attribute begins with &quot;#&quot;?
673     addSubresourceURL(urls, document().completeURL(attributeWithoutSynchronization(usemapAttr)));
674 }
675 
676 void HTMLImageElement::didMoveToNewDocument(Document&amp; oldDocument, Document&amp; newDocument)
677 {
678     m_imageLoader.elementDidMoveToNewDocument();
679     HTMLElement::didMoveToNewDocument(oldDocument, newDocument);
680 }
681 
682 bool HTMLImageElement::isServerMap() const
683 {
684     if (!hasAttributeWithoutSynchronization(ismapAttr))
685         return false;
686 
<span class="line-modified">687     const AtomicString&amp; usemap = attributeWithoutSynchronization(usemapAttr);</span>
688 
689     // If the usemap attribute starts with &#39;#&#39;, it refers to a map element in the document.
690     if (usemap.string()[0] == &#39;#&#39;)
691         return false;
692 
693     return document().completeURL(stripLeadingAndTrailingHTMLSpaces(usemap)).isEmpty();
694 }
695 
<span class="line-modified">696 void HTMLImageElement::setCrossOrigin(const AtomicString&amp; value)</span>
697 {
698     setAttributeWithoutSynchronization(crossoriginAttr, value);
699 }
700 
701 String HTMLImageElement::crossOrigin() const
702 {
703     return parseCORSSettingsAttribute(attributeWithoutSynchronization(crossoriginAttr));
704 }
705 
706 #if ENABLE(ATTACHMENT_ELEMENT)
707 
708 void HTMLImageElement::setAttachmentElement(Ref&lt;HTMLAttachmentElement&gt;&amp;&amp; attachment)
709 {
710     if (auto existingAttachment = attachmentElement())
711         existingAttachment-&gt;remove();
712 
713     attachment-&gt;setInlineStyleProperty(CSSPropertyDisplay, CSSValueNone, true);
714     ensureUserAgentShadowRoot().appendChild(WTFMove(attachment));
715 }
716 
</pre>
<hr />
<pre>
789 }
790 
791 bool HTMLImageElement::hasImageControls() const
792 {
793     if (auto shadowRoot = userAgentShadowRoot()) {
794         RefPtr&lt;Node&gt; node = shadowRoot-&gt;firstChild();
795         ASSERT_WITH_SECURITY_IMPLICATION(!node || node-&gt;isImageControlsRootElement());
796         return node;
797     }
798 
799     return false;
800 }
801 
802 bool HTMLImageElement::childShouldCreateRenderer(const Node&amp; child) const
803 {
804     return hasShadowRootParent(child) &amp;&amp; HTMLElement::childShouldCreateRenderer(child);
805 }
806 #endif // ENABLE(SERVICE_CONTROLS)
807 
808 #if PLATFORM(IOS_FAMILY)
<span class="line-modified">809 // FIXME: This is a workaround for &lt;rdar://problem/7725158&gt;. We should find a better place for the touchCalloutEnabled() logic.</span>
810 bool HTMLImageElement::willRespondToMouseClickEvents()
811 {
812     auto renderer = this-&gt;renderer();
813     if (!renderer || renderer-&gt;style().touchCalloutEnabled())
814         return true;
815     return HTMLElement::willRespondToMouseClickEvents();
816 }
817 #endif
818 
819 #if USE(SYSTEM_PREVIEW)
820 bool HTMLImageElement::isSystemPreviewImage() const
821 {
822     if (!RuntimeEnabledFeatures::sharedFeatures().systemPreviewEnabled())
823         return false;
824 
825     const auto* parent = parentElement();
826     if (is&lt;HTMLAnchorElement&gt;(parent))
827         return downcast&lt;HTMLAnchorElement&gt;(parent)-&gt;isSystemPreviewLink();
828     if (is&lt;HTMLPictureElement&gt;(parent))
829         return downcast&lt;HTMLPictureElement&gt;(parent)-&gt;isSystemPreviewImage();
</pre>
</td>
<td>
<hr />
<pre>
 29 #include &quot;Chrome.h&quot;
 30 #include &quot;ChromeClient.h&quot;
 31 #include &quot;EditableImageReference.h&quot;
 32 #include &quot;Editor.h&quot;
 33 #include &quot;ElementIterator.h&quot;
 34 #include &quot;EventNames.h&quot;
 35 #include &quot;FrameView.h&quot;
 36 #include &quot;HTMLAnchorElement.h&quot;
 37 #include &quot;HTMLAttachmentElement.h&quot;
 38 #include &quot;HTMLDocument.h&quot;
 39 #include &quot;HTMLFormElement.h&quot;
 40 #include &quot;HTMLParserIdioms.h&quot;
 41 #include &quot;HTMLPictureElement.h&quot;
 42 #include &quot;HTMLMapElement.h&quot;
 43 #include &quot;HTMLSourceElement.h&quot;
 44 #include &quot;HTMLSrcsetParser.h&quot;
 45 #include &quot;Logging.h&quot;
 46 #include &quot;MIMETypeRegistry.h&quot;
 47 #include &quot;MediaList.h&quot;
 48 #include &quot;MediaQueryEvaluator.h&quot;
<span class="line-added"> 49 #include &quot;MouseEvent.h&quot;</span>
 50 #include &quot;NodeTraversal.h&quot;
 51 #include &quot;PlatformMouseEvent.h&quot;
 52 #include &quot;RenderImage.h&quot;
 53 #include &quot;RenderView.h&quot;
 54 #include &quot;RuntimeEnabledFeatures.h&quot;
 55 #include &quot;Settings.h&quot;
 56 #include &quot;ShadowRoot.h&quot;
 57 #include &quot;SizesAttributeParser.h&quot;
 58 #include &lt;wtf/IsoMallocInlines.h&gt;
 59 #include &lt;wtf/text/StringBuilder.h&gt;
 60 
 61 #if ENABLE(SERVICE_CONTROLS)
 62 #include &quot;ImageControlsRootElement.h&quot;
 63 #endif
 64 
 65 namespace WebCore {
 66 
 67 WTF_MAKE_ISO_ALLOCATED_IMPL(HTMLImageElement);
 68 
 69 using namespace HTMLNames;
 70 



 71 HTMLImageElement::HTMLImageElement(const QualifiedName&amp; tagName, Document&amp; document, HTMLFormElement* form)
 72     : HTMLElement(tagName, document)
 73     , m_imageLoader(*this)
 74     , m_form(nullptr)
<span class="line-modified"> 75     , m_formSetByParser(makeWeakPtr(form))</span>
 76     , m_compositeOperator(CompositeSourceOver)
 77     , m_imageDevicePixelRatio(1.0f)

 78     , m_experimentalImageMenuEnabled(false)

 79 {
 80     ASSERT(hasTagName(imgTag));
 81     setHasCustomStyleResolveCallbacks();
 82 }
 83 
 84 Ref&lt;HTMLImageElement&gt; HTMLImageElement::create(Document&amp; document)
 85 {
 86     return adoptRef(*new HTMLImageElement(imgTag, document));
 87 }
 88 
 89 Ref&lt;HTMLImageElement&gt; HTMLImageElement::create(const QualifiedName&amp; tagName, Document&amp; document, HTMLFormElement* form)
 90 {
 91     return adoptRef(*new HTMLImageElement(tagName, document, form));
 92 }
 93 
 94 HTMLImageElement::~HTMLImageElement()
 95 {
 96     if (m_form)
 97         m_form-&gt;removeImgElement(this);
 98     setPictureElement(nullptr);
 99 }
100 
101 Ref&lt;HTMLImageElement&gt; HTMLImageElement::createForJSConstructor(Document&amp; document, Optional&lt;unsigned&gt; width, Optional&lt;unsigned&gt; height)
102 {
103     auto image = adoptRef(*new HTMLImageElement(imgTag, document));
104     if (width)
105         image-&gt;setWidth(width.value());
106     if (height)
107         image-&gt;setHeight(height.value());
108     return image;
109 }
110 
111 bool HTMLImageElement::isPresentationAttribute(const QualifiedName&amp; name) const
112 {
113     if (name == widthAttr || name == heightAttr || name == borderAttr || name == vspaceAttr || name == hspaceAttr || name == valignAttr)
114         return true;
115     return HTMLElement::isPresentationAttribute(name);
116 }
117 
<span class="line-modified">118 void HTMLImageElement::collectStyleForPresentationAttribute(const QualifiedName&amp; name, const AtomString&amp; value, MutableStyleProperties&amp; style)</span>
119 {
120     if (name == widthAttr)
121         addHTMLLengthToStyle(style, CSSPropertyWidth, value);
122     else if (name == heightAttr)
123         addHTMLLengthToStyle(style, CSSPropertyHeight, value);
124     else if (name == borderAttr)
125         applyBorderAttributeToStyle(value, style);
126     else if (name == vspaceAttr) {
127         addHTMLLengthToStyle(style, CSSPropertyMarginTop, value);
128         addHTMLLengthToStyle(style, CSSPropertyMarginBottom, value);
129     } else if (name == hspaceAttr) {
130         addHTMLLengthToStyle(style, CSSPropertyMarginLeft, value);
131         addHTMLLengthToStyle(style, CSSPropertyMarginRight, value);
132     } else if (name == alignAttr)
133         applyAlignmentAttributeToStyle(value, style);
134     else if (name == valignAttr)
135         addPropertyToPresentationAttributeStyle(style, CSSPropertyVerticalAlign, value);
136     else
137         HTMLElement::collectStyleForPresentationAttribute(name, value, style);
138 }
139 
<span class="line-modified">140 const AtomString&amp; HTMLImageElement::imageSourceURL() const</span>
141 {
142     return m_bestFitImageURL.isEmpty() ? attributeWithoutSynchronization(srcAttr) : m_bestFitImageURL;
143 }
144 
145 void HTMLImageElement::setBestFitURLAndDPRFromImageCandidate(const ImageCandidate&amp; candidate)
146 {
<span class="line-modified">147     m_bestFitImageURL = candidate.string.toAtomString();</span>
<span class="line-modified">148     m_currentSrc = AtomString(document().completeURL(imageSourceURL()).string());</span>
149     if (candidate.density &gt;= 0)
150         m_imageDevicePixelRatio = 1 / candidate.density;
151     if (is&lt;RenderImage&gt;(renderer()))
152         downcast&lt;RenderImage&gt;(*renderer()).setImageDevicePixelRatio(m_imageDevicePixelRatio);
153 }
154 
155 ImageCandidate HTMLImageElement::bestFitSourceFromPictureElement()
156 {
157     auto picture = makeRefPtr(pictureElement());
158     if (!picture)
159         return { };
160 
161     picture-&gt;clearViewportDependentResults();
162     document().removeViewportDependentPicture(*picture);
163 
164     picture-&gt;clearAppearanceDependentResults();
165     document().removeAppearanceDependentPicture(*picture);
166 
167     for (RefPtr&lt;Node&gt; child = picture-&gt;firstChild(); child &amp;&amp; child != this; child = child-&gt;nextSibling()) {
168         if (!is&lt;HTMLSourceElement&gt;(*child))
</pre>
<hr />
<pre>
198         auto candidate = bestFitSourceForImageAttributes(document().deviceScaleFactor(), nullAtom(), srcset, sourceSize);
199         if (!candidate.isEmpty())
200             return candidate;
201     }
202     return { };
203 }
204 
205 void HTMLImageElement::selectImageSource()
206 {
207     // First look for the best fit source from our &lt;picture&gt; parent if we have one.
208     ImageCandidate candidate = bestFitSourceFromPictureElement();
209     if (candidate.isEmpty()) {
210         // If we don&#39;t have a &lt;picture&gt; or didn&#39;t find a source, then we use our own attributes.
211         auto sourceSize = SizesAttributeParser(attributeWithoutSynchronization(sizesAttr).string(), document()).length();
212         candidate = bestFitSourceForImageAttributes(document().deviceScaleFactor(), attributeWithoutSynchronization(srcAttr), attributeWithoutSynchronization(srcsetAttr), sourceSize);
213     }
214     setBestFitURLAndDPRFromImageCandidate(candidate);
215     m_imageLoader.updateFromElementIgnoringPreviousError();
216 }
217 
<span class="line-modified">218 void HTMLImageElement::parseAttribute(const QualifiedName&amp; name, const AtomString&amp; value)</span>
219 {
220     if (name == altAttr) {
221         if (is&lt;RenderImage&gt;(renderer()))
222             downcast&lt;RenderImage&gt;(*renderer()).updateAltText();
223     } else if (name == srcAttr || name == srcsetAttr || name == sizesAttr)
224         selectImageSource();
225     else if (name == usemapAttr) {
226         if (isInTreeScope() &amp;&amp; !m_parsedUsemap.isNull())
227             treeScope().removeImageElementByUsemap(*m_parsedUsemap.impl(), *this);
228 
229         m_parsedUsemap = parseHTMLHashNameReference(value);
230 
231         if (isInTreeScope() &amp;&amp; !m_parsedUsemap.isNull())
232             treeScope().addImageElementByUsemap(*m_parsedUsemap.impl(), *this);
233     } else if (name == compositeAttr) {
234         // FIXME: images don&#39;t support blend modes in their compositing attribute.
235         BlendMode blendOp = BlendMode::Normal;
236         if (!parseCompositeAndBlendOperator(value, m_compositeOperator, blendOp))
237             m_compositeOperator = CompositeSourceOver;
238 #if ENABLE(SERVICE_CONTROLS)
239     } else if (name == webkitimagemenuAttr) {
240         m_experimentalImageMenuEnabled = !value.isNull();
241         updateImageControls();
242 #endif
243     } else if (name == x_apple_editable_imageAttr)
244         updateEditableImage();
245     else {
246         if (name == nameAttr) {
247             bool willHaveName = !value.isNull();
248             if (m_hadNameBeforeAttributeChanged != willHaveName &amp;&amp; isConnected() &amp;&amp; !isInShadowTree() &amp;&amp; is&lt;HTMLDocument&gt;(document())) {
249                 HTMLDocument&amp; document = downcast&lt;HTMLDocument&gt;(this-&gt;document());
<span class="line-modified">250                 const AtomString&amp; id = getIdAttribute();</span>
251                 if (!id.isEmpty() &amp;&amp; id != getNameAttribute()) {
252                     if (willHaveName)
253                         document.addDocumentNamedItem(*id.impl(), *this);
254                     else
255                         document.removeDocumentNamedItem(*id.impl(), *this);
256                 }
257             }
258             m_hadNameBeforeAttributeChanged = willHaveName;
259         }
260         HTMLElement::parseAttribute(name, value);
261     }
262 }
263 
<span class="line-modified">264 const AtomString&amp; HTMLImageElement::altText() const</span>
265 {
266     // lets figure out the alt text.. magic stuff
267     // http://www.w3.org/TR/1998/REC-html40-19980424/appendix/notes.html#altgen
268     // also heavily discussed by Hixie on bugzilla
<span class="line-modified">269     const AtomString&amp; alt = attributeWithoutSynchronization(altAttr);</span>
270     if (!alt.isNull())
271         return alt;
272     // fall back to title attribute
273     return attributeWithoutSynchronization(titleAttr);
274 }
275 
276 RenderPtr&lt;RenderElement&gt; HTMLImageElement::createElementRenderer(RenderStyle&amp;&amp; style, const RenderTreePosition&amp;)
277 {
278     if (style.hasContent())
279         return RenderElement::createFor(*this, WTFMove(style));
280 
281     return createRenderer&lt;RenderImage&gt;(*this, WTFMove(style), nullptr, m_imageDevicePixelRatio);
282 }
283 
284 bool HTMLImageElement::canStartSelection() const
285 {
286     if (shadowRoot())
287         return HTMLElement::canStartSelection();
288 
289     return false;
290 }
291 
292 bool HTMLImageElement::supportsFocus() const
293 {
294     if (hasEditableImageAttribute())
295         return true;
296     return HTMLElement::supportsFocus();
297 }
298 
299 bool HTMLImageElement::isFocusable() const
300 {
301     if (hasEditableImageAttribute())
302         return true;
303     return HTMLElement::isFocusable();
304 }
305 
<span class="line-added">306 bool HTMLImageElement::isInteractiveContent() const</span>
<span class="line-added">307 {</span>
<span class="line-added">308     return hasAttributeWithoutSynchronization(usemapAttr);</span>
<span class="line-added">309 }</span>
<span class="line-added">310 </span>
311 void HTMLImageElement::didAttachRenderers()
312 {
313     if (!is&lt;RenderImage&gt;(renderer()))
314         return;
315     if (m_imageLoader.hasPendingBeforeLoadEvent())
316         return;
317 
318 #if ENABLE(SERVICE_CONTROLS)
319     updateImageControls();
320 #endif
321 
322     auto&amp; renderImage = downcast&lt;RenderImage&gt;(*renderer());
323     RenderImageResource&amp; renderImageResource = renderImage.imageResource();
324     if (renderImageResource.cachedImage())
325         return;
326     renderImageResource.setCachedImage(m_imageLoader.image());
327 
328     // If we have no image at all because we have no src attribute, set
329     // image height and width for the alt text instead.
330     if (!m_imageLoader.image() &amp;&amp; !renderImageResource.cachedImage())
331         renderImage.setImageSizeForAltText();
332 }
333 
334 Node::InsertedIntoAncestorResult HTMLImageElement::insertedIntoAncestor(InsertionType insertionType, ContainerNode&amp; parentOfInsertedTree)
335 {
336     if (m_formSetByParser) {
<span class="line-modified">337         m_form = WTFMove(m_formSetByParser);</span>

338         m_form-&gt;registerImgElement(this);
339     }
340 
341     if (m_form &amp;&amp; rootElement() != m_form-&gt;rootElement()) {
342         m_form-&gt;removeImgElement(this);
343         m_form = nullptr;
344     }
345 
346     if (!m_form) {
<span class="line-modified">347         if (auto* newForm = HTMLFormElement::findClosestFormAncestor(*this)) {</span>
<span class="line-modified">348             m_form = makeWeakPtr(newForm);</span>
<span class="line-modified">349             newForm-&gt;registerImgElement(this);</span>
<span class="line-added">350         }</span>
351     }
352 
353     // Insert needs to complete first, before we start updating the loader. Loader dispatches events which could result
354     // in callbacks back to this node.
355     Node::InsertedIntoAncestorResult insertNotificationRequest = HTMLElement::insertedIntoAncestor(insertionType, parentOfInsertedTree);
356 
357     if (insertionType.connectedToDocument &amp;&amp; hasEditableImageAttribute())
358         insertNotificationRequest = InsertedIntoAncestorResult::NeedsPostInsertionCallback;
359 
360     if (insertionType.treeScopeChanged &amp;&amp; !m_parsedUsemap.isNull())
361         treeScope().addImageElementByUsemap(*m_parsedUsemap.impl(), *this);
362 
363     if (is&lt;HTMLPictureElement&gt;(parentNode())) {
364         setPictureElement(&amp;downcast&lt;HTMLPictureElement&gt;(*parentNode()));
365         selectImageSource();
366     }
367 
368     // If we have been inserted from a renderer-less document,
369     // our loader may have not fetched the image, so do it now.
370     if (insertionType.connectedToDocument &amp;&amp; !m_imageLoader.image())
</pre>
<hr />
<pre>
438 #endif
439 
440     if (shouldBeEditable == isCurrentlyEditable)
441         return;
442 
443     if (!hasEditableAttribute) {
444         m_editableImage = nullptr;
445         return;
446     }
447 
448     if (!m_editableImage)
449         m_editableImage = EditableImageReference::create(document());
450 
451 #if ENABLE(ATTACHMENT_ELEMENT)
452     m_editableImage-&gt;associateWithAttachment(attachmentElement()-&gt;uniqueIdentifier());
453 #endif
454 }
455 
456 HTMLPictureElement* HTMLImageElement::pictureElement() const
457 {
<span class="line-modified">458     return m_pictureElement.get();</span>





459 }
460 
461 void HTMLImageElement::setPictureElement(HTMLPictureElement* pictureElement)
462 {
<span class="line-modified">463     m_pictureElement = makeWeakPtr(pictureElement);</span>








464 }
465 
466 unsigned HTMLImageElement::width(bool ignorePendingStylesheets)
467 {
468     if (!renderer()) {
469         // check the attribute first for an explicit pixel value
470         auto optionalWidth = parseHTMLNonNegativeInteger(attributeWithoutSynchronization(widthAttr));
471         if (optionalWidth)
472             return optionalWidth.value();
473 
474         // if the image is available, use its width
475         if (m_imageLoader.image())
476             return m_imageLoader.image()-&gt;imageSizeForRenderer(renderer(), 1.0f).width().toUnsigned();
477     }
478 
479     if (ignorePendingStylesheets)
480         document().updateLayoutIgnorePendingStylesheets();
481     else
482         document().updateLayout();
483 
</pre>
<hr />
<pre>
538         || HTMLElement::isURLAttribute(attribute);
539 }
540 
541 bool HTMLImageElement::attributeContainsURL(const Attribute&amp; attribute) const
542 {
543     return attribute.name() == srcsetAttr
544         || HTMLElement::attributeContainsURL(attribute);
545 }
546 
547 String HTMLImageElement::completeURLsInAttributeValue(const URL&amp; base, const Attribute&amp; attribute) const
548 {
549     if (attribute.name() == srcsetAttr) {
550         Vector&lt;ImageCandidate&gt; imageCandidates = parseImageCandidatesFromSrcsetAttribute(StringView(attribute.value()));
551         StringBuilder result;
552         for (const auto&amp; candidate : imageCandidates) {
553             if (&amp;candidate != &amp;imageCandidates[0])
554                 result.appendLiteral(&quot;, &quot;);
555             result.append(URL(base, candidate.string.toString()).string());
556             if (candidate.density != UninitializedDescriptor) {
557                 result.append(&#39; &#39;);
<span class="line-modified">558                 result.appendFixedPrecisionNumber(candidate.density);</span>
559                 result.append(&#39;x&#39;);
560             }
561             if (candidate.resourceWidth != UninitializedDescriptor) {
562                 result.append(&#39; &#39;);
563                 result.appendNumber(candidate.resourceWidth);
564                 result.append(&#39;w&#39;);
565             }
566         }
567         return result.toString();
568     }
569     return HTMLElement::completeURLsInAttributeValue(base, attribute);
570 }
571 
<span class="line-modified">572 bool HTMLImageElement::matchesUsemap(const AtomStringImpl&amp; name) const</span>
573 {
574     return m_parsedUsemap.impl() == &amp;name;
575 }
576 
577 HTMLMapElement* HTMLImageElement::associatedMapElement() const
578 {
579     return treeScope().getImageMap(m_parsedUsemap);
580 }
581 
<span class="line-modified">582 const AtomString&amp; HTMLImageElement::alt() const</span>
583 {
584     return attributeWithoutSynchronization(altAttr);
585 }
586 
587 bool HTMLImageElement::draggable() const
588 {
589     // Image elements are draggable by default.
590     return !equalLettersIgnoringASCIICase(attributeWithoutSynchronization(draggableAttr), &quot;false&quot;);
591 }
592 
593 void HTMLImageElement::setHeight(unsigned value)
594 {
595     setUnsignedIntegralAttribute(heightAttr, value);
596 }
597 
598 URL HTMLImageElement::src() const
599 {
600     return document().completeURL(attributeWithoutSynchronization(srcAttr));
601 }
602 
</pre>
<hr />
<pre>
622 }
623 
624 int HTMLImageElement::y() const
625 {
626     document().updateLayoutIgnorePendingStylesheets();
627     auto renderer = this-&gt;renderer();
628     if (!renderer)
629         return 0;
630 
631     // FIXME: This doesn&#39;t work correctly with transforms.
632     return renderer-&gt;localToAbsolute().y();
633 }
634 
635 bool HTMLImageElement::complete() const
636 {
637     return m_imageLoader.imageComplete();
638 }
639 
640 DecodingMode HTMLImageElement::decodingMode() const
641 {
<span class="line-modified">642     const AtomString&amp; decodingMode = attributeWithoutSynchronization(decodingAttr);</span>
643     if (equalLettersIgnoringASCIICase(decodingMode, &quot;sync&quot;))
644         return DecodingMode::Synchronous;
645     if (equalLettersIgnoringASCIICase(decodingMode, &quot;async&quot;))
646         return DecodingMode::Asynchronous;
647     return DecodingMode::Auto;
648 }
649 
650 void HTMLImageElement::decode(Ref&lt;DeferredPromise&gt;&amp;&amp; promise)
651 {
652     return m_imageLoader.decode(WTFMove(promise));
653 }
654 
655 void HTMLImageElement::addSubresourceAttributeURLs(ListHashSet&lt;URL&gt;&amp; urls) const
656 {
657     HTMLElement::addSubresourceAttributeURLs(urls);
658 
659     addSubresourceURL(urls, document().completeURL(imageSourceURL()));
660     // FIXME: What about when the usemap attribute begins with &quot;#&quot;?
661     addSubresourceURL(urls, document().completeURL(attributeWithoutSynchronization(usemapAttr)));
662 }
663 
664 void HTMLImageElement::didMoveToNewDocument(Document&amp; oldDocument, Document&amp; newDocument)
665 {
666     m_imageLoader.elementDidMoveToNewDocument();
667     HTMLElement::didMoveToNewDocument(oldDocument, newDocument);
668 }
669 
670 bool HTMLImageElement::isServerMap() const
671 {
672     if (!hasAttributeWithoutSynchronization(ismapAttr))
673         return false;
674 
<span class="line-modified">675     const AtomString&amp; usemap = attributeWithoutSynchronization(usemapAttr);</span>
676 
677     // If the usemap attribute starts with &#39;#&#39;, it refers to a map element in the document.
678     if (usemap.string()[0] == &#39;#&#39;)
679         return false;
680 
681     return document().completeURL(stripLeadingAndTrailingHTMLSpaces(usemap)).isEmpty();
682 }
683 
<span class="line-modified">684 void HTMLImageElement::setCrossOrigin(const AtomString&amp; value)</span>
685 {
686     setAttributeWithoutSynchronization(crossoriginAttr, value);
687 }
688 
689 String HTMLImageElement::crossOrigin() const
690 {
691     return parseCORSSettingsAttribute(attributeWithoutSynchronization(crossoriginAttr));
692 }
693 
694 #if ENABLE(ATTACHMENT_ELEMENT)
695 
696 void HTMLImageElement::setAttachmentElement(Ref&lt;HTMLAttachmentElement&gt;&amp;&amp; attachment)
697 {
698     if (auto existingAttachment = attachmentElement())
699         existingAttachment-&gt;remove();
700 
701     attachment-&gt;setInlineStyleProperty(CSSPropertyDisplay, CSSValueNone, true);
702     ensureUserAgentShadowRoot().appendChild(WTFMove(attachment));
703 }
704 
</pre>
<hr />
<pre>
777 }
778 
779 bool HTMLImageElement::hasImageControls() const
780 {
781     if (auto shadowRoot = userAgentShadowRoot()) {
782         RefPtr&lt;Node&gt; node = shadowRoot-&gt;firstChild();
783         ASSERT_WITH_SECURITY_IMPLICATION(!node || node-&gt;isImageControlsRootElement());
784         return node;
785     }
786 
787     return false;
788 }
789 
790 bool HTMLImageElement::childShouldCreateRenderer(const Node&amp; child) const
791 {
792     return hasShadowRootParent(child) &amp;&amp; HTMLElement::childShouldCreateRenderer(child);
793 }
794 #endif // ENABLE(SERVICE_CONTROLS)
795 
796 #if PLATFORM(IOS_FAMILY)
<span class="line-modified">797 // FIXME: We should find a better place for the touch callout logic. See rdar://problem/48937767.</span>
798 bool HTMLImageElement::willRespondToMouseClickEvents()
799 {
800     auto renderer = this-&gt;renderer();
801     if (!renderer || renderer-&gt;style().touchCalloutEnabled())
802         return true;
803     return HTMLElement::willRespondToMouseClickEvents();
804 }
805 #endif
806 
807 #if USE(SYSTEM_PREVIEW)
808 bool HTMLImageElement::isSystemPreviewImage() const
809 {
810     if (!RuntimeEnabledFeatures::sharedFeatures().systemPreviewEnabled())
811         return false;
812 
813     const auto* parent = parentElement();
814     if (is&lt;HTMLAnchorElement&gt;(parent))
815         return downcast&lt;HTMLAnchorElement&gt;(parent)-&gt;isSystemPreviewLink();
816     if (is&lt;HTMLPictureElement&gt;(parent))
817         return downcast&lt;HTMLPictureElement&gt;(parent)-&gt;isSystemPreviewImage();
</pre>
</td>
</tr>
</table>
<center><a href="HTMLIFrameElement.idl.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="HTMLImageElement.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>