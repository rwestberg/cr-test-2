<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/Modules/webgpu/WHLSL/Metal/WHLSLFunctionWriter.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="WHLSLEntryPointScaffolding.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="WHLSLFunctionWriter.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/Modules/webgpu/WHLSL/Metal/WHLSLFunctionWriter.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;WHLSLFunctionWriter.h&quot;
 28 
 29 #if ENABLE(WEBGPU)
 30 
<span class="line-modified"> 31 #include &quot;WHLSLArrayReferenceType.h&quot;</span>
<span class="line-modified"> 32 #include &quot;WHLSLArrayType.h&quot;</span>
<span class="line-removed"> 33 #include &quot;WHLSLAssignmentExpression.h&quot;</span>
<span class="line-removed"> 34 #include &quot;WHLSLBooleanLiteral.h&quot;</span>
<span class="line-removed"> 35 #include &quot;WHLSLBuiltInSemantic.h&quot;</span>
<span class="line-removed"> 36 #include &quot;WHLSLCallExpression.h&quot;</span>
<span class="line-removed"> 37 #include &quot;WHLSLCommaExpression.h&quot;</span>
<span class="line-removed"> 38 #include &quot;WHLSLDereferenceExpression.h&quot;</span>
<span class="line-removed"> 39 #include &quot;WHLSLDoWhileLoop.h&quot;</span>
<span class="line-removed"> 40 #include &quot;WHLSLEffectfulExpressionStatement.h&quot;</span>
 41 #include &quot;WHLSLEntryPointScaffolding.h&quot;
<span class="line-modified"> 42 #include &quot;WHLSLEntryPointType.h&quot;</span>
<span class="line-removed"> 43 #include &quot;WHLSLFloatLiteral.h&quot;</span>
<span class="line-removed"> 44 #include &quot;WHLSLForLoop.h&quot;</span>
<span class="line-removed"> 45 #include &quot;WHLSLFunctionDeclaration.h&quot;</span>
<span class="line-removed"> 46 #include &quot;WHLSLFunctionDefinition.h&quot;</span>
<span class="line-removed"> 47 #include &quot;WHLSLIfStatement.h&quot;</span>
<span class="line-removed"> 48 #include &quot;WHLSLIntegerLiteral.h&quot;</span>
<span class="line-removed"> 49 #include &quot;WHLSLLogicalExpression.h&quot;</span>
<span class="line-removed"> 50 #include &quot;WHLSLLogicalNotExpression.h&quot;</span>
<span class="line-removed"> 51 #include &quot;WHLSLMakeArrayReferenceExpression.h&quot;</span>
<span class="line-removed"> 52 #include &quot;WHLSLMakePointerExpression.h&quot;</span>
<span class="line-removed"> 53 #include &quot;WHLSLNativeFunctionDeclaration.h&quot;</span>
 54 #include &quot;WHLSLNativeFunctionWriter.h&quot;
<span class="line-removed"> 55 #include &quot;WHLSLNativeTypeDeclaration.h&quot;</span>
<span class="line-removed"> 56 #include &quot;WHLSLPointerType.h&quot;</span>
 57 #include &quot;WHLSLProgram.h&quot;
<span class="line-removed"> 58 #include &quot;WHLSLReturn.h&quot;</span>
<span class="line-removed"> 59 #include &quot;WHLSLSwitchCase.h&quot;</span>
<span class="line-removed"> 60 #include &quot;WHLSLSwitchStatement.h&quot;</span>
<span class="line-removed"> 61 #include &quot;WHLSLTernaryExpression.h&quot;</span>
 62 #include &quot;WHLSLTypeNamer.h&quot;
<span class="line-removed"> 63 #include &quot;WHLSLUnsignedIntegerLiteral.h&quot;</span>
<span class="line-removed"> 64 #include &quot;WHLSLVariableDeclaration.h&quot;</span>
<span class="line-removed"> 65 #include &quot;WHLSLVariableDeclarationsStatement.h&quot;</span>
<span class="line-removed"> 66 #include &quot;WHLSLVariableReference.h&quot;</span>
 67 #include &quot;WHLSLVisitor.h&quot;
<span class="line-removed"> 68 #include &quot;WHLSLWhileLoop.h&quot;</span>
 69 #include &lt;wtf/HashMap.h&gt;


 70 #include &lt;wtf/text/StringBuilder.h&gt;
 71 
 72 namespace WebCore {
 73 
 74 namespace WHLSL {
 75 
 76 namespace Metal {
 77 
<span class="line-modified"> 78 class FunctionDeclarationWriter : public Visitor {</span>
















 79 public:
<span class="line-modified"> 80     FunctionDeclarationWriter(TypeNamer&amp; typeNamer, HashMap&lt;AST::FunctionDeclaration*, String&gt;&amp; functionMapping)</span>
<span class="line-modified"> 81         : m_typeNamer(typeNamer)</span>


 82         , m_functionMapping(functionMapping)

 83     {
 84     }
 85 
<span class="line-modified"> 86     virtual ~FunctionDeclarationWriter() = default;</span>
 87 
<span class="line-modified"> 88     String toString() { return m_stringBuilder.toString(); }</span>
<span class="line-modified"> 89     void visit(AST::FunctionDeclaration&amp; functionDeclaration) override</span>
<span class="line-modified"> 90     {</span>
<span class="line-modified"> 91         if (functionDeclaration.entryPointType())</span>
<span class="line-modified"> 92             return;</span>







































 93 
<span class="line-modified"> 94         auto iterator = m_functionMapping.find(&amp;functionDeclaration);</span>
<span class="line-modified"> 95         ASSERT(iterator != m_functionMapping.end());</span>
<span class="line-modified"> 96         m_stringBuilder.append(makeString(m_typeNamer.mangledNameForType(functionDeclaration.type()), &#39; &#39;, iterator-&gt;value, &#39;(&#39;));</span>
<span class="line-modified"> 97         for (size_t i = 0; i &lt; functionDeclaration.parameters().size(); ++i) {</span>
<span class="line-modified"> 98             if (i)</span>
<span class="line-removed"> 99                 m_stringBuilder.append(&quot;, &quot;);</span>
<span class="line-removed">100             m_stringBuilder.append(m_typeNamer.mangledNameForType(*functionDeclaration.parameters()[i].type()));</span>
<span class="line-removed">101         }</span>
<span class="line-removed">102         m_stringBuilder.append(&quot;);\n&quot;);</span>
<span class="line-removed">103     }</span>
104 
<span class="line-modified">105 private:</span>
<span class="line-removed">106     TypeNamer&amp; m_typeNamer;</span>
<span class="line-removed">107     HashMap&lt;AST::FunctionDeclaration*, String&gt;&amp; m_functionMapping;</span>
<span class="line-removed">108     StringBuilder m_stringBuilder;</span>
<span class="line-removed">109 };</span>
110 
<span class="line-modified">111 class FunctionDefinitionWriter : public Visitor {</span>
<span class="line-modified">112 public:</span>
<span class="line-modified">113     FunctionDefinitionWriter(Intrinsics&amp; intrinsics, TypeNamer&amp; typeNamer, HashMap&lt;AST::FunctionDeclaration*, String&gt;&amp; functionMapping)</span>
<span class="line-modified">114         : m_intrinsics(intrinsics)</span>
<span class="line-modified">115         , m_typeNamer(typeNamer)</span>
<span class="line-modified">116         , m_functionMapping(functionMapping)</span>




















117     {

118     }
119 
<span class="line-modified">120     virtual ~FunctionDefinitionWriter() = default;</span>
<span class="line-modified">121 </span>
<span class="line-modified">122     String toString() { return m_stringBuilder.toString(); }</span>

123 
<span class="line-modified">124     void visit(AST::NativeFunctionDeclaration&amp; nativeFunctionDeclaration) override</span>
125     {
<span class="line-modified">126         auto iterator = m_functionMapping.find(&amp;nativeFunctionDeclaration);</span>
<span class="line-modified">127         ASSERT(iterator != m_functionMapping.end());</span>
<span class="line-modified">128         m_stringBuilder.append(writeNativeFunction(nativeFunctionDeclaration, iterator-&gt;value, m_typeNamer));</span>
129     }
130 
<span class="line-modified">131     void visit(AST::FunctionDefinition&amp; functionDefinition) override</span>
132     {
<span class="line-modified">133         auto iterator = m_functionMapping.find(&amp;functionDefinition);</span>
<span class="line-modified">134         ASSERT(iterator != m_functionMapping.end());</span>
<span class="line-modified">135         if (functionDefinition.entryPointType()) {</span>
<span class="line-modified">136             m_entryPointScaffolding = EntryPointScaffolding(functionDefinition, m_intrinsics);</span>
<span class="line-modified">137             m_stringBuilder.append(m_entryPointScaffolding-&gt;helperTypes());</span>
<span class="line-modified">138             m_stringBuilder.append(&#39;\n&#39;);</span>
<span class="line-modified">139             m_stringBuilder.append(makeString(m_entryPointScaffolding-&gt;signature(), &quot; {&quot;));</span>
<span class="line-modified">140             m_stringBuilder.append(m_entryPointScaffolding-&gt;unpack());</span>
<span class="line-modified">141             checkErrorAndVisit(functionDefinition.block());</span>
<span class="line-modified">142             ASSERT(m_stack.isEmpty());</span>
<span class="line-modified">143             m_stringBuilder.append(&quot;}\n&quot;);</span>
<span class="line-modified">144         } else {</span>
<span class="line-modified">145             m_entryPointScaffolding = WTF::nullopt;</span>
<span class="line-modified">146             m_stringBuilder.append(makeString(m_typeNamer.mangledNameForType(functionDefinition.type()), &#39; &#39;, iterator-&gt;value, &#39;(&#39;));</span>















































147             for (size_t i = 0; i &lt; functionDefinition.parameters().size(); ++i) {
<span class="line-modified">148                 auto&amp; parameter = functionDefinition.parameters()[i];</span>
<span class="line-removed">149                 if (i)</span>
<span class="line-removed">150                     m_stringBuilder.append(&quot;, &quot;);</span>
<span class="line-removed">151                 auto parameterName = generateNextVariableName();</span>
<span class="line-removed">152                 auto addResult = m_variableMapping.add(&amp;parameter, parameterName);</span>
153                 ASSERT_UNUSED(addResult, addResult.isNewEntry);
<span class="line-removed">154                 m_stringBuilder.append(makeString(m_typeNamer.mangledNameForType(*parameter.type()), &#39; &#39;, parameterName));</span>
155             }
<span class="line-removed">156             m_stringBuilder.append(&quot;) {\n&quot;);</span>
157             checkErrorAndVisit(functionDefinition.block());
158             ASSERT(m_stack.isEmpty());
<span class="line-removed">159             m_stringBuilder.append(&quot;}\n&quot;);</span>
160         }



















161     }

162 
<span class="line-modified">163 private:</span>
<span class="line-modified">164     void visit(AST::FunctionDeclaration&amp;) override</span>
<span class="line-modified">165     {</span>
<span class="line-modified">166         ASSERT_NOT_REACHED();</span>
<span class="line-removed">167     }</span>
168 
<span class="line-modified">169     void visit(AST::Statement&amp; statement) override</span>
<span class="line-modified">170     {</span>
<span class="line-modified">171         Visitor::visit(statement);</span>
<span class="line-modified">172     }</span>
173 
<span class="line-modified">174     void visit(AST::Block&amp; block) override</span>


175     {
<span class="line-modified">176         m_stringBuilder.append(&quot;{\n&quot;);</span>
177         for (auto&amp; statement : block.statements())
178             checkErrorAndVisit(statement);
<span class="line-removed">179         m_stringBuilder.append(&quot;}\n&quot;);</span>
180     }


181 
<span class="line-modified">182     void visit(AST::Break&amp;) override</span>
<span class="line-modified">183     {</span>
<span class="line-modified">184         m_stringBuilder.append(&quot;break;\n&quot;);</span>











185     }

186 
<span class="line-modified">187     void visit(AST::Continue&amp;) override</span>
<span class="line-modified">188     {</span>
<span class="line-modified">189         // FIXME: Figure out which loop we&#39;re in, and run the increment code</span>
<span class="line-modified">190         CRASH();</span>
<span class="line-modified">191     }</span>
192 
<span class="line-modified">193     void visit(AST::DoWhileLoop&amp; doWhileLoop) override</span>
<span class="line-modified">194     {</span>
<span class="line-modified">195         m_stringBuilder.append(&quot;do {\n&quot;);</span>
<span class="line-modified">196         checkErrorAndVisit(doWhileLoop.body());</span>
<span class="line-modified">197         checkErrorAndVisit(doWhileLoop.conditional());</span>
<span class="line-removed">198         m_stringBuilder.append(makeString(&quot;if (!&quot;, m_stack.takeLast(), &quot;) break;\n&quot;));</span>
<span class="line-removed">199         m_stringBuilder.append(makeString(&quot;} while(true);\n&quot;));</span>
<span class="line-removed">200     }</span>
201 
<span class="line-modified">202     void visit(AST::EffectfulExpressionStatement&amp; effectfulExpressionStatement) override</span>
<span class="line-modified">203     {</span>
<span class="line-modified">204         checkErrorAndVisit(effectfulExpressionStatement.effectfulExpression());</span>
<span class="line-modified">205         m_stack.takeLast(); // The statement is already effectful, so we don&#39;t need to do anything with the result.</span>
<span class="line-removed">206     }</span>
207 
<span class="line-modified">208     void visit(AST::Fallthrough&amp;) override</span>
<span class="line-modified">209     {</span>
<span class="line-modified">210         m_stringBuilder.append(&quot;[[clang::fallthrough]];\n&quot;); // FIXME: Make sure this is okay. Alternatively, we could do nothing and just return here instead.</span>
<span class="line-removed">211     }</span>
212 
<span class="line-modified">213     void visit(AST::ForLoop&amp; forLoop) override</span>



214     {
<span class="line-modified">215         WTF::visit(WTF::makeVisitor([&amp;](AST::VariableDeclarationsStatement&amp; variableDeclarationsStatement) {</span>
<span class="line-modified">216             checkErrorAndVisit(variableDeclarationsStatement);</span>
<span class="line-modified">217         }, [&amp;](UniqueRef&lt;AST::Expression&gt;&amp; expression) {</span>
<span class="line-modified">218             checkErrorAndVisit(expression);</span>
<span class="line-modified">219             m_stack.takeLast(); // We don&#39;t need to do anything with the result.</span>
<span class="line-modified">220         }), forLoop.initialization());</span>
<span class="line-modified">221 </span>
<span class="line-removed">222         m_stringBuilder.append(&quot;for ( ; ; ) {\n&quot;);</span>
<span class="line-removed">223         if (forLoop.condition()) {</span>
<span class="line-removed">224             checkErrorAndVisit(*forLoop.condition());</span>
<span class="line-removed">225             m_stringBuilder.append(makeString(&quot;if (!&quot;, m_stack.takeLast(), &quot;) break;\n&quot;));</span>
226         }
<span class="line-modified">227         checkErrorAndVisit(forLoop.body());</span>
<span class="line-modified">228         if (forLoop.increment()) {</span>
<span class="line-modified">229             checkErrorAndVisit(*forLoop.increment());</span>
<span class="line-modified">230             m_stack.takeLast();</span>















231         }
<span class="line-modified">232         m_stringBuilder.append(&quot;}\n&quot;);</span>




























233     }


234 
<span class="line-modified">235     void visit(AST::IfStatement&amp; ifStatement) override</span>



236     {
<span class="line-modified">237         checkErrorAndVisit(ifStatement.conditional());</span>
<span class="line-removed">238         m_stringBuilder.append(makeString(&quot;if (&quot;, m_stack.takeLast(), &quot;) {\n&quot;));</span>
239         checkErrorAndVisit(ifStatement.body());
<span class="line-modified">240         if (ifStatement.elseBody()) {</span>
<span class="line-modified">241             m_stringBuilder.append(&quot;} else {\n&quot;);</span>



242             checkErrorAndVisit(*ifStatement.elseBody());
243         }
<span class="line-removed">244         m_stringBuilder.append(&quot;}\n&quot;);</span>
245     }


246 
<span class="line-modified">247     void visit(AST::Return&amp; returnStatement) override</span>
<span class="line-modified">248     {</span>
<span class="line-modified">249         if (returnStatement.value()) {</span>
<span class="line-modified">250             checkErrorAndVisit(*returnStatement.value());</span>
<span class="line-modified">251             if (m_entryPointScaffolding) {</span>
<span class="line-modified">252                 auto variableName = generateNextVariableName();</span>
<span class="line-modified">253                 m_stringBuilder.append(m_entryPointScaffolding-&gt;pack(m_stack.takeLast(), variableName));</span>
<span class="line-modified">254                 m_stringBuilder.append(makeString(&quot;return &quot;, variableName, &quot;;\n&quot;));</span>
<span class="line-modified">255             } else</span>
<span class="line-removed">256                 m_stringBuilder.append(makeString(&quot;return &quot;, m_stack.takeLast(), &quot;;\n&quot;));</span>
257         } else
<span class="line-modified">258             m_stringBuilder.append(&quot;return;\n&quot;);</span>
<span class="line-modified">259     }</span>


260 
<span class="line-modified">261     void visit(AST::SwitchStatement&amp; switchStatement) override</span>
<span class="line-modified">262     {</span>
<span class="line-modified">263         checkErrorAndVisit(switchStatement.value());</span>
264 
<span class="line-modified">265         m_stringBuilder.append(makeString(&quot;switch (&quot;, m_stack.takeLast(), &quot;) {&quot;));</span>


266         for (auto&amp; switchCase : switchStatement.switchCases())
267             checkErrorAndVisit(switchCase);
<span class="line-removed">268         m_stringBuilder.append(&quot;}\n&quot;);</span>
269     }


270 
<span class="line-modified">271     void visit(AST::SwitchCase&amp; switchCase) override</span>
<span class="line-modified">272     {</span>
<span class="line-modified">273         if (switchCase.value())</span>
<span class="line-modified">274             m_stringBuilder.append(makeString(&quot;case &quot;, constantExpressionString(*switchCase.value()), &quot;:\n&quot;));</span>
<span class="line-modified">275         else</span>
<span class="line-modified">276             m_stringBuilder.append(&quot;default:\n&quot;);</span>
<span class="line-modified">277         checkErrorAndVisit(switchCase.block());</span>
<span class="line-modified">278         // FIXME: Figure out whether we need to break or fallthrough.</span>
<span class="line-modified">279         CRASH();</span>
<span class="line-modified">280     }</span>


281 
<span class="line-modified">282     void visit(AST::Trap&amp;) override</span>
<span class="line-modified">283     {</span>
<span class="line-modified">284         // FIXME: Implement this</span>
<span class="line-modified">285         CRASH();</span>
<span class="line-removed">286     }</span>
287 
<span class="line-modified">288     void visit(AST::VariableDeclarationsStatement&amp; variableDeclarationsStatement) override</span>
<span class="line-modified">289     {</span>
<span class="line-modified">290         Visitor::visit(variableDeclarationsStatement);</span>
<span class="line-modified">291     }</span>



292 
<span class="line-modified">293     void visit(AST::WhileLoop&amp; whileLoop) override</span>
<span class="line-modified">294     {</span>
<span class="line-modified">295         m_stringBuilder.append(makeString(&quot;while (true) {\n&quot;));</span>
<span class="line-modified">296         checkErrorAndVisit(whileLoop.conditional());</span>
<span class="line-modified">297         m_stringBuilder.append(makeString(&quot;if (!&quot;, m_stack.takeLast(), &quot;) break;\n&quot;));</span>
<span class="line-modified">298         checkErrorAndVisit(whileLoop.body());</span>
<span class="line-modified">299         m_stringBuilder.append(&quot;}\n&quot;);</span>
<span class="line-removed">300     }</span>
301 
<span class="line-modified">302     void visit(AST::IntegerLiteral&amp; integerLiteral) override</span>
<span class="line-modified">303     {</span>
<span class="line-modified">304         ASSERT(integerLiteral.resolvedType());</span>
<span class="line-modified">305         auto variableName = generateNextVariableName();</span>
<span class="line-modified">306         auto mangledTypeName = m_typeNamer.mangledNameForType(*integerLiteral.resolvedType());</span>
<span class="line-modified">307         m_stringBuilder.append(makeString(mangledTypeName, &#39; &#39;, variableName, &quot; = static_cast&lt;&quot;, mangledTypeName, &quot;&gt;(&quot;, integerLiteral.value(), &quot;);\n&quot;));</span>
<span class="line-modified">308         m_stack.append(variableName);</span>
<span class="line-removed">309     }</span>
310 
<span class="line-modified">311     void visit(AST::UnsignedIntegerLiteral&amp; unsignedIntegerLiteral) override</span>
<span class="line-modified">312     {</span>
<span class="line-modified">313         ASSERT(unsignedIntegerLiteral.resolvedType());</span>
<span class="line-modified">314         auto variableName = generateNextVariableName();</span>
<span class="line-modified">315         auto mangledTypeName = m_typeNamer.mangledNameForType(*unsignedIntegerLiteral.resolvedType());</span>
<span class="line-modified">316         m_stringBuilder.append(makeString(mangledTypeName, &#39; &#39;, variableName, &quot; = static_cast&lt;&quot;, mangledTypeName, &quot;&gt;(&quot;, unsignedIntegerLiteral.value(), &quot;);\n&quot;));</span>
<span class="line-modified">317         m_stack.append(variableName);</span>
<span class="line-modified">318     }</span>






319 
<span class="line-modified">320     void visit(AST::FloatLiteral&amp; floatLiteral) override</span>
<span class="line-modified">321     {</span>
<span class="line-modified">322         ASSERT(floatLiteral.resolvedType());</span>
<span class="line-modified">323         auto variableName = generateNextVariableName();</span>
<span class="line-modified">324         auto mangledTypeName = m_typeNamer.mangledNameForType(*floatLiteral.resolvedType());</span>
<span class="line-modified">325         m_stringBuilder.append(makeString(mangledTypeName, &#39; &#39;, variableName, &quot; = static_cast&lt;&quot;, mangledTypeName, &quot;&gt;(&quot;, floatLiteral.value(), &quot;);\n&quot;));</span>
<span class="line-modified">326         m_stack.append(variableName);</span>
<span class="line-removed">327     }</span>
328 
<span class="line-modified">329     void visit(AST::NullLiteral&amp; nullLiteral) override</span>
<span class="line-modified">330     {</span>
<span class="line-modified">331         ASSERT(nullLiteral.resolvedType());</span>
<span class="line-modified">332         auto&amp; unifyNode = nullLiteral.resolvedType()-&gt;unifyNode();</span>
<span class="line-modified">333         ASSERT(is&lt;AST::UnnamedType&gt;(unifyNode));</span>
<span class="line-modified">334         auto&amp; unnamedType = downcast&lt;AST::UnnamedType&gt;(unifyNode);</span>
<span class="line-modified">335         bool isArrayReferenceType = is&lt;AST::ArrayReferenceType&gt;(unnamedType);</span>
<span class="line-modified">336 </span>
<span class="line-modified">337         auto variableName = generateNextVariableName();</span>
<span class="line-removed">338         m_stringBuilder.append(makeString(m_typeNamer.mangledNameForType(*nullLiteral.resolvedType()), &#39; &#39;, variableName, &quot; = &quot;));</span>
<span class="line-removed">339         if (isArrayReferenceType)</span>
<span class="line-removed">340             m_stringBuilder.append(&quot;{ nullptr, 0 }&quot;);</span>
<span class="line-removed">341         else</span>
<span class="line-removed">342             m_stringBuilder.append(&quot;nullptr&quot;);</span>
<span class="line-removed">343         m_stringBuilder.append(&quot;;\n&quot;);</span>
<span class="line-removed">344         m_stack.append(variableName);</span>
<span class="line-removed">345     }</span>
346 
<span class="line-modified">347     void visit(AST::BooleanLiteral&amp; booleanLiteral) override</span>
<span class="line-modified">348     {</span>
<span class="line-modified">349         ASSERT(booleanLiteral.resolvedType());</span>
<span class="line-modified">350         auto variableName = generateNextVariableName();</span>
<span class="line-removed">351         auto mangledTypeName = m_typeNamer.mangledNameForType(*booleanLiteral.resolvedType());</span>
<span class="line-removed">352         m_stringBuilder.append(makeString(mangledTypeName, &#39; &#39;, variableName, &quot; = static_cast&lt;&quot;, mangledTypeName, &quot;&gt;(&quot;, booleanLiteral.value() ? &quot;true&quot; : &quot;false&quot;, &quot;);\n&quot;));</span>
<span class="line-removed">353         m_stack.append(variableName);</span>
<span class="line-removed">354     }</span>
355 
<span class="line-modified">356     void visit(AST::EnumerationMemberLiteral&amp; enumerationMemberLiteral) override</span>
<span class="line-modified">357     {</span>
<span class="line-modified">358         ASSERT(enumerationMemberLiteral.resolvedType());</span>
<span class="line-modified">359         ASSERT(enumerationMemberLiteral.enumerationDefinition());</span>
<span class="line-modified">360         ASSERT(enumerationMemberLiteral.enumerationDefinition());</span>
<span class="line-modified">361         auto variableName = generateNextVariableName();</span>
<span class="line-modified">362         auto mangledTypeName = m_typeNamer.mangledNameForType(*enumerationMemberLiteral.resolvedType());</span>
<span class="line-removed">363         m_stringBuilder.append(makeString(mangledTypeName, &#39; &#39;, variableName, &quot; = &quot;, mangledTypeName, &#39;.&#39;, m_typeNamer.mangledNameForEnumerationMember(*enumerationMemberLiteral.enumerationMember()), &quot;;\n&quot;));</span>
<span class="line-removed">364         m_stack.append(variableName);</span>
<span class="line-removed">365     }</span>
366 
<span class="line-modified">367     void visit(AST::Expression&amp; expression) override</span>
<span class="line-modified">368     {</span>
<span class="line-modified">369         Visitor::visit(expression);</span>
<span class="line-modified">370     }</span>
371 
<span class="line-modified">372     void visit(AST::DotExpression&amp;) override</span>
<span class="line-modified">373     {</span>
<span class="line-removed">374         // This should be lowered already.</span>
<span class="line-removed">375         ASSERT_NOT_REACHED();</span>
<span class="line-removed">376     }</span>
377 
<span class="line-modified">378     void visit(AST::IndexExpression&amp;) override</span>
<span class="line-removed">379     {</span>
<span class="line-removed">380         // This should be lowered already.</span>
<span class="line-removed">381         ASSERT_NOT_REACHED();</span>
<span class="line-removed">382     }</span>
383 
<span class="line-modified">384     void visit(AST::PropertyAccessExpression&amp;) override</span>
<span class="line-modified">385     {</span>
<span class="line-removed">386         ASSERT_NOT_REACHED();</span>
<span class="line-removed">387     }</span>
388 
<span class="line-modified">389     void visit(AST::VariableDeclaration&amp; variableDeclaration) override</span>
<span class="line-modified">390     {</span>
<span class="line-modified">391         ASSERT(variableDeclaration.type());</span>
<span class="line-modified">392         if (variableDeclaration.initializer())</span>
<span class="line-modified">393             checkErrorAndVisit(*variableDeclaration.initializer());</span>
<span class="line-modified">394         else {</span>
<span class="line-modified">395             // FIXME: Zero-fill the variable.</span>
<span class="line-modified">396             CRASH();</span>
<span class="line-modified">397         }</span>
<span class="line-modified">398         // FIXME: Implement qualifiers.</span>
<span class="line-modified">399         auto variableName = generateNextVariableName();</span>
<span class="line-modified">400         auto addResult = m_variableMapping.add(&amp;variableDeclaration, variableName);</span>
<span class="line-modified">401         ASSERT_UNUSED(addResult, addResult.isNewEntry);</span>
<span class="line-modified">402         m_stringBuilder.append(makeString(m_typeNamer.mangledNameForType(*variableDeclaration.type()), &#39; &#39;, variableName, &quot; = &quot;, m_stack.takeLast(), &quot;;\n&quot;));</span>
<span class="line-modified">403         m_stack.append(variableName);</span>














































404     }
405 
<span class="line-modified">406     void visit(AST::AssignmentExpression&amp; assignmentExpression) override</span>
<span class="line-modified">407     {</span>
<span class="line-modified">408         checkErrorAndVisit(assignmentExpression.left());</span>
<span class="line-modified">409         auto leftName = m_stack.takeLast();</span>
<span class="line-modified">410         checkErrorAndVisit(assignmentExpression.right());</span>
<span class="line-removed">411         auto rightName = m_stack.takeLast();</span>
<span class="line-removed">412         m_stringBuilder.append(makeString(leftName, &quot; = &quot;, rightName, &quot;;\n&quot;));</span>
413     }
414 
<span class="line-modified">415     void visit(AST::CallExpression&amp; callExpression) override</span>
<span class="line-modified">416     {</span>
<span class="line-modified">417         Vector&lt;String&gt; argumentNames;</span>
<span class="line-modified">418         for (auto&amp; argument : callExpression.arguments()) {</span>
<span class="line-modified">419             checkErrorAndVisit(argument);</span>
<span class="line-modified">420             argumentNames.append(m_stack.takeLast());</span>
<span class="line-modified">421         }</span>
<span class="line-modified">422         ASSERT(callExpression.resolvedType());</span>
<span class="line-modified">423         ASSERT(callExpression.function());</span>
<span class="line-modified">424         auto iterator = m_functionMapping.find(callExpression.function());</span>


425         ASSERT(iterator != m_functionMapping.end());
<span class="line-modified">426         auto variableName = generateNextVariableName();</span>
<span class="line-modified">427         m_stringBuilder.append(makeString(m_typeNamer.mangledNameForType(*callExpression.resolvedType()), &#39; &#39;, variableName, &quot; = &quot;, iterator-&gt;value, &#39;(&#39;));</span>

428         for (size_t i = 0; i &lt; argumentNames.size(); ++i) {
429             if (i)
430                 m_stringBuilder.append(&quot;, &quot;);
431             m_stringBuilder.append(argumentNames[i]);
432         }
433         m_stringBuilder.append(&quot;);\n&quot;);
<span class="line-removed">434         m_stack.append(variableName);</span>
435     }
436 
<span class="line-modified">437     void visit(AST::CommaExpression&amp; commaExpression) override</span>
<span class="line-modified">438     {</span>
<span class="line-removed">439         String result;</span>
<span class="line-removed">440         for (auto&amp; expression : commaExpression.list()) {</span>
<span class="line-removed">441             checkErrorAndVisit(expression);</span>
<span class="line-removed">442             result = m_stack.takeLast();</span>
<span class="line-removed">443         }</span>
<span class="line-removed">444         m_stack.append(result);</span>
<span class="line-removed">445     }</span>
446 
<span class="line-modified">447     void visit(AST::DereferenceExpression&amp; dereferenceExpression) override</span>
<span class="line-modified">448     {</span>
<span class="line-modified">449         checkErrorAndVisit(dereferenceExpression.pointer());</span>
<span class="line-modified">450         auto right = m_stack.takeLast();</span>
<span class="line-modified">451         ASSERT(dereferenceExpression.resolvedType());</span>
<span class="line-modified">452         auto variableName = generateNextVariableName();</span>
<span class="line-removed">453         m_stringBuilder.append(makeString(m_typeNamer.mangledNameForType(*dereferenceExpression.resolvedType()), &#39; &#39;, variableName, &quot; = *&quot;, right, &quot;;\n&quot;));</span>
<span class="line-removed">454         m_stack.append(variableName);</span>
455     }



456 
<span class="line-modified">457     void visit(AST::LogicalExpression&amp; logicalExpression) override</span>
<span class="line-modified">458     {</span>
<span class="line-modified">459         checkErrorAndVisit(logicalExpression.left());</span>
<span class="line-modified">460         auto left = m_stack.takeLast();</span>
<span class="line-modified">461         checkErrorAndVisit(logicalExpression.right());</span>
<span class="line-modified">462         auto right = m_stack.takeLast();</span>
<span class="line-modified">463         ASSERT(logicalExpression.resolvedType());</span>
<span class="line-modified">464         auto variableName = generateNextVariableName();</span>
<span class="line-modified">465         m_stringBuilder.append(makeString(m_typeNamer.mangledNameForType(*logicalExpression.resolvedType()), &#39; &#39;, variableName, &quot; = &quot;, left));</span>
<span class="line-modified">466         switch (logicalExpression.type()) {</span>
<span class="line-modified">467         case AST::LogicalExpression::Type::And:</span>
<span class="line-modified">468             m_stringBuilder.append(&quot; &amp;&amp; &quot;);</span>
<span class="line-modified">469             break;</span>
<span class="line-modified">470         default:</span>
<span class="line-modified">471             ASSERT(logicalExpression.type() == AST::LogicalExpression::Type::Or);</span>
<span class="line-modified">472             m_stringBuilder.append(&quot; || &quot;);</span>
<span class="line-modified">473             break;</span>






























































































































474         }
<span class="line-modified">475         m_stringBuilder.append(makeString(right, &quot;;\n&quot;));</span>
<span class="line-modified">476         m_stack.append(variableName);</span>
<span class="line-removed">477     }</span>
478 
<span class="line-modified">479     void visit(AST::LogicalNotExpression&amp; logicalNotExpression) override</span>




480     {
<span class="line-removed">481         checkErrorAndVisit(logicalNotExpression.operand());</span>
<span class="line-removed">482         auto operand = m_stack.takeLast();</span>
<span class="line-removed">483         ASSERT(logicalNotExpression.resolvedType());</span>
<span class="line-removed">484         auto variableName = generateNextVariableName();</span>
<span class="line-removed">485         m_stringBuilder.append(makeString(m_typeNamer.mangledNameForType(*logicalNotExpression.resolvedType()), &#39; &#39;, variableName, &quot; = !&quot;, operand, &quot;;\n&quot;));</span>
<span class="line-removed">486         m_stack.append(variableName);</span>
487     }
488 
<span class="line-modified">489     void visit(AST::MakeArrayReferenceExpression&amp; makeArrayReferenceExpression) override</span>
<span class="line-modified">490     {</span>
<span class="line-removed">491         checkErrorAndVisit(makeArrayReferenceExpression.lValue());</span>
<span class="line-removed">492         auto lValue = m_stack.takeLast();</span>
<span class="line-removed">493         ASSERT(makeArrayReferenceExpression.resolvedType());</span>
<span class="line-removed">494         auto variableName = generateNextVariableName();</span>
<span class="line-removed">495         auto mangledTypeName = m_typeNamer.mangledNameForType(*makeArrayReferenceExpression.resolvedType());</span>
<span class="line-removed">496         if (is&lt;AST::PointerType&gt;(*makeArrayReferenceExpression.resolvedType()))</span>
<span class="line-removed">497             m_stringBuilder.append(makeString(mangledTypeName, &#39; &#39;, variableName, &quot; = { &quot;, lValue, &quot;, 1 };\n&quot;));</span>
<span class="line-removed">498         else if (is&lt;AST::ArrayType&gt;(*makeArrayReferenceExpression.resolvedType())) {</span>
<span class="line-removed">499             auto&amp; arrayType = downcast&lt;AST::ArrayType&gt;(*makeArrayReferenceExpression.resolvedType());</span>
<span class="line-removed">500             m_stringBuilder.append(makeString(mangledTypeName, &#39; &#39;, variableName, &quot; = { &amp;(&quot;, lValue, &quot;[0]), &quot;, arrayType.numElements(), &quot; };\n&quot;));</span>
<span class="line-removed">501         } else</span>
<span class="line-removed">502             m_stringBuilder.append(makeString(mangledTypeName, &#39; &#39;, variableName, &quot; = { &amp;&quot;, lValue, &quot;, 1 };\n&quot;));</span>
<span class="line-removed">503         m_stack.append(variableName);</span>
<span class="line-removed">504     }</span>
505 
<span class="line-modified">506     void visit(AST::MakePointerExpression&amp; makePointerExpression) override</span>
<span class="line-modified">507     {</span>
<span class="line-modified">508         checkErrorAndVisit(makePointerExpression.lValue());</span>
<span class="line-modified">509         auto lValue = m_stack.takeLast();</span>
<span class="line-modified">510         ASSERT(makePointerExpression.resolvedType());</span>
<span class="line-modified">511         auto variableName = generateNextVariableName();</span>
<span class="line-modified">512         m_stringBuilder.append(makeString(m_typeNamer.mangledNameForType(*makePointerExpression.resolvedType()), &#39; &#39;, variableName, &quot; = &amp;&quot;, lValue, &quot;;\n&quot;));</span>
<span class="line-modified">513         m_stack.append(variableName);</span>
<span class="line-modified">514     }</span>





515 
<span class="line-modified">516     void visit(AST::ReadModifyWriteExpression&amp;) override</span>




517     {
<span class="line-removed">518         // This should be lowered already.</span>
<span class="line-removed">519         ASSERT_NOT_REACHED();</span>
520     }
521 
<span class="line-modified">522     void visit(AST::TernaryExpression&amp; ternaryExpression) override</span>
<span class="line-modified">523     {</span>
<span class="line-modified">524         checkErrorAndVisit(ternaryExpression.predicate());</span>
<span class="line-modified">525         auto check = m_stack.takeLast();</span>
<span class="line-modified">526 </span>
<span class="line-modified">527         ASSERT(ternaryExpression.resolvedType());</span>
<span class="line-modified">528         auto variableName = generateNextVariableName();</span>
<span class="line-modified">529         m_stringBuilder.append(makeString(m_typeNamer.mangledNameForType(*ternaryExpression.resolvedType()), &#39; &#39;, variableName, &quot;;\n&quot;));</span>
<span class="line-modified">530 </span>
<span class="line-modified">531         m_stringBuilder.append(makeString(&quot;if (&quot;, check, &quot;) {\n&quot;));</span>
<span class="line-modified">532         checkErrorAndVisit(ternaryExpression.bodyExpression());</span>
<span class="line-modified">533         m_stringBuilder.append(makeString(variableName, &quot; = &quot;, m_stack.takeLast(), &quot;;\n&quot;));</span>
<span class="line-modified">534         m_stringBuilder.append(&quot;} else {\n&quot;);</span>
<span class="line-modified">535         checkErrorAndVisit(ternaryExpression.elseExpression());</span>
<span class="line-modified">536         m_stringBuilder.append(makeString(variableName, &quot; = &quot;, m_stack.takeLast(), &quot;;\n&quot;));</span>
<span class="line-modified">537         m_stringBuilder.append(&quot;}\n&quot;);</span>
<span class="line-modified">538         m_stack.append(variableName);</span>






539     }
540 
<span class="line-modified">541     void visit(AST::VariableReference&amp; variableReference) override</span>
<span class="line-modified">542     {</span>
<span class="line-modified">543         ASSERT(variableReference.variable());</span>
<span class="line-modified">544         auto iterator = m_variableMapping.find(variableReference.variable());</span>
<span class="line-modified">545         ASSERT(iterator != m_variableMapping.end());</span>
<span class="line-modified">546         m_stack.append(iterator-&gt;value);</span>


547     }
548 
<span class="line-modified">549     String constantExpressionString(AST::ConstantExpression&amp; constantExpression)</span>





550     {
<span class="line-modified">551         String result;</span>
<span class="line-modified">552         constantExpression.visit(WTF::makeVisitor([&amp;](AST::IntegerLiteral&amp; integerLiteral) {</span>
<span class="line-modified">553             result = makeString(&quot;&quot;, integerLiteral.value());</span>
<span class="line-removed">554         }, [&amp;](AST::UnsignedIntegerLiteral&amp; unsignedIntegerLiteral) {</span>
<span class="line-removed">555             result = makeString(&quot;&quot;, unsignedIntegerLiteral.value());</span>
<span class="line-removed">556         }, [&amp;](AST::FloatLiteral&amp; floatLiteral) {</span>
<span class="line-removed">557             result = makeString(&quot;&quot;, floatLiteral.value());</span>
<span class="line-removed">558         }, [&amp;](AST::NullLiteral&amp;) {</span>
<span class="line-removed">559             result = &quot;nullptr&quot;_str;</span>
<span class="line-removed">560         }, [&amp;](AST::BooleanLiteral&amp; booleanLiteral) {</span>
<span class="line-removed">561             result = booleanLiteral.value() ? &quot;true&quot;_str : &quot;false&quot;_str;</span>
<span class="line-removed">562         }, [&amp;](AST::EnumerationMemberLiteral&amp; enumerationMemberLiteral) {</span>
<span class="line-removed">563             ASSERT(enumerationMemberLiteral.enumerationDefinition());</span>
<span class="line-removed">564             ASSERT(enumerationMemberLiteral.enumerationDefinition());</span>
<span class="line-removed">565             result = makeString(m_typeNamer.mangledNameForType(*enumerationMemberLiteral.enumerationDefinition()), &#39;.&#39;, m_typeNamer.mangledNameForEnumerationMember(*enumerationMemberLiteral.enumerationMember()));</span>
<span class="line-removed">566         }));</span>
<span class="line-removed">567         return result;</span>
568     }
569 
<span class="line-modified">570     String generateNextVariableName()</span>
571     {
<span class="line-modified">572         return makeString(&quot;variable&quot;, m_variableCount++);</span>




573     }
574 


575 private:
<span class="line-modified">576     Intrinsics&amp; m_intrinsics;</span>
<span class="line-removed">577     TypeNamer&amp; m_typeNamer;</span>
<span class="line-removed">578     HashMap&lt;AST::FunctionDeclaration*, String&gt;&amp; m_functionMapping;</span>
<span class="line-removed">579     HashMap&lt;AST::VariableDeclaration*, String&gt; m_variableMapping;</span>
<span class="line-removed">580     StringBuilder m_stringBuilder;</span>
<span class="line-removed">581     Vector&lt;String&gt; m_stack;</span>
<span class="line-removed">582     Optional&lt;EntryPointScaffolding&gt; m_entryPointScaffolding;</span>
<span class="line-removed">583     unsigned m_variableCount { 0 };</span>
584 };
585 
<span class="line-modified">586 String metalFunctions(Program&amp; program, TypeNamer&amp; typeNamer)</span>
587 {
<span class="line-modified">588     StringBuilder stringBuilder;</span>

589 
<span class="line-modified">590     unsigned numFunctions = 0;</span>
<span class="line-modified">591     HashMap&lt;AST::FunctionDeclaration*, String&gt; functionMapping;</span>
<span class="line-modified">592     for (auto&amp; nativeFunctionDeclaration : program.nativeFunctionDeclarations()) {</span>
<span class="line-modified">593         auto addResult = functionMapping.add(&amp;nativeFunctionDeclaration, makeString(&quot;function&quot;, numFunctions++));</span>
<span class="line-modified">594         ASSERT_UNUSED(addResult, addResult.isNewEntry);</span>
<span class="line-modified">595     }</span>





596     for (auto&amp; functionDefinition : program.functionDefinitions()) {
<span class="line-modified">597         auto addResult = functionMapping.add(&amp;functionDefinition, makeString(&quot;function&quot;, numFunctions++));</span>
<span class="line-modified">598         ASSERT_UNUSED(addResult, addResult.isNewEntry);</span>
599     }
600 
<span class="line-modified">601     {</span>
<span class="line-modified">602         FunctionDeclarationWriter functionDeclarationWriter(typeNamer, functionMapping);</span>
<span class="line-removed">603         for (auto&amp; nativeFunctionDeclaration : program.nativeFunctionDeclarations())</span>
<span class="line-removed">604             functionDeclarationWriter.visit(nativeFunctionDeclaration);</span>
<span class="line-removed">605         for (auto&amp; functionDefinition : program.functionDefinitions()) {</span>
<span class="line-removed">606             if (!functionDefinition-&gt;entryPointType())</span>
<span class="line-removed">607                 functionDeclarationWriter.visit(functionDefinition);</span>
<span class="line-removed">608         }</span>
<span class="line-removed">609         stringBuilder.append(functionDeclarationWriter.toString());</span>
<span class="line-removed">610     }</span>
611 
<span class="line-modified">612     stringBuilder.append(&#39;\n&#39;);</span>


613 
<span class="line-modified">614     {</span>
<span class="line-modified">615         FunctionDefinitionWriter functionDefinitionWriter(program.intrinsics(), typeNamer, functionMapping);</span>
<span class="line-modified">616         for (auto&amp; nativeFunctionDeclaration : program.nativeFunctionDeclarations())</span>
<span class="line-modified">617             functionDefinitionWriter.visit(nativeFunctionDeclaration);</span>
<span class="line-modified">618         for (auto&amp; functionDefinition : program.functionDefinitions())</span>





619             functionDefinitionWriter.visit(functionDefinition);
<span class="line-removed">620         stringBuilder.append(functionDefinitionWriter.toString());</span>
621     }
622 
<span class="line-modified">623     return stringBuilder.toString();</span>
624 }
625 
626 } // namespace Metal
627 
628 } // namespace WHLSL
629 
630 } // namespace WebCore
631 
632 #endif
</pre>
</td>
<td>
<hr />
<pre>
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;WHLSLFunctionWriter.h&quot;
 28 
 29 #if ENABLE(WEBGPU)
 30 
<span class="line-modified"> 31 #include &quot;NotImplemented.h&quot;</span>
<span class="line-modified"> 32 #include &quot;WHLSLAST.h&quot;</span>








 33 #include &quot;WHLSLEntryPointScaffolding.h&quot;
<span class="line-modified"> 34 #include &quot;WHLSLInferTypes.h&quot;</span>











 35 #include &quot;WHLSLNativeFunctionWriter.h&quot;


 36 #include &quot;WHLSLProgram.h&quot;




 37 #include &quot;WHLSLTypeNamer.h&quot;




 38 #include &quot;WHLSLVisitor.h&quot;

 39 #include &lt;wtf/HashMap.h&gt;
<span class="line-added"> 40 #include &lt;wtf/HashSet.h&gt;</span>
<span class="line-added"> 41 #include &lt;wtf/SetForScope.h&gt;</span>
 42 #include &lt;wtf/text/StringBuilder.h&gt;
 43 
 44 namespace WebCore {
 45 
 46 namespace WHLSL {
 47 
 48 namespace Metal {
 49 
<span class="line-modified"> 50 static void declareFunction(StringBuilder&amp; stringBuilder, AST::FunctionDeclaration&amp; functionDeclaration, TypeNamer&amp; typeNamer, HashMap&lt;AST::FunctionDeclaration*, MangledFunctionName&gt;&amp; functionMapping)</span>
<span class="line-added"> 51 {</span>
<span class="line-added"> 52     if (functionDeclaration.entryPointType())</span>
<span class="line-added"> 53         return;</span>
<span class="line-added"> 54 </span>
<span class="line-added"> 55     auto iterator = functionMapping.find(&amp;functionDeclaration);</span>
<span class="line-added"> 56     ASSERT(iterator != functionMapping.end());</span>
<span class="line-added"> 57     stringBuilder.append(typeNamer.mangledNameForType(functionDeclaration.type()), &#39; &#39;, iterator-&gt;value, &#39;(&#39;);</span>
<span class="line-added"> 58     for (size_t i = 0; i &lt; functionDeclaration.parameters().size(); ++i) {</span>
<span class="line-added"> 59         if (i)</span>
<span class="line-added"> 60             stringBuilder.append(&quot;, &quot;);</span>
<span class="line-added"> 61         stringBuilder.append(typeNamer.mangledNameForType(*functionDeclaration.parameters()[i]-&gt;type()));</span>
<span class="line-added"> 62     }</span>
<span class="line-added"> 63     stringBuilder.append(&quot;);\n&quot;);</span>
<span class="line-added"> 64 }</span>
<span class="line-added"> 65 </span>
<span class="line-added"> 66 class FunctionDefinitionWriter : public Visitor {</span>
 67 public:
<span class="line-modified"> 68     FunctionDefinitionWriter(StringBuilder&amp; stringBuilder, Intrinsics&amp; intrinsics, TypeNamer&amp; typeNamer, HashMap&lt;AST::FunctionDeclaration*, MangledFunctionName&gt;&amp; functionMapping, Layout&amp; layout)</span>
<span class="line-modified"> 69         : m_stringBuilder(stringBuilder)</span>
<span class="line-added"> 70         , m_intrinsics(intrinsics)</span>
<span class="line-added"> 71         , m_typeNamer(typeNamer)</span>
 72         , m_functionMapping(functionMapping)
<span class="line-added"> 73         , m_layout(layout)</span>
 74     {
 75     }
 76 
<span class="line-modified"> 77     virtual ~FunctionDefinitionWriter() = default;</span>
 78 
<span class="line-modified"> 79     void visit(AST::NativeFunctionDeclaration&amp;) override;</span>
<span class="line-modified"> 80     void visit(AST::FunctionDefinition&amp;) override;</span>
<span class="line-modified"> 81 </span>
<span class="line-modified"> 82 protected:</span>
<span class="line-modified"> 83     virtual std::unique_ptr&lt;EntryPointScaffolding&gt; createEntryPointScaffolding(AST::FunctionDefinition&amp;) = 0;</span>
<span class="line-added"> 84 </span>
<span class="line-added"> 85     void visit(AST::FunctionDeclaration&amp;) override;</span>
<span class="line-added"> 86     void visit(AST::Statement&amp;) override;</span>
<span class="line-added"> 87     void visit(AST::Block&amp;) override;</span>
<span class="line-added"> 88     void visit(AST::Break&amp;) override;</span>
<span class="line-added"> 89     void visit(AST::Continue&amp;) override;</span>
<span class="line-added"> 90     void visit(AST::DoWhileLoop&amp;) override;</span>
<span class="line-added"> 91     void visit(AST::EffectfulExpressionStatement&amp;) override;</span>
<span class="line-added"> 92     void visit(AST::Fallthrough&amp;) override;</span>
<span class="line-added"> 93     void visit(AST::ForLoop&amp;) override;</span>
<span class="line-added"> 94     void visit(AST::IfStatement&amp;) override;</span>
<span class="line-added"> 95     void visit(AST::Return&amp;) override;</span>
<span class="line-added"> 96     void visit(AST::SwitchStatement&amp;) override;</span>
<span class="line-added"> 97     void visit(AST::SwitchCase&amp;) override;</span>
<span class="line-added"> 98     void visit(AST::VariableDeclarationsStatement&amp;) override;</span>
<span class="line-added"> 99     void visit(AST::WhileLoop&amp;) override;</span>
<span class="line-added">100     void visit(AST::IntegerLiteral&amp;) override;</span>
<span class="line-added">101     void visit(AST::UnsignedIntegerLiteral&amp;) override;</span>
<span class="line-added">102     void visit(AST::FloatLiteral&amp;) override;</span>
<span class="line-added">103     void visit(AST::NullLiteral&amp;) override;</span>
<span class="line-added">104     void visit(AST::BooleanLiteral&amp;) override;</span>
<span class="line-added">105     void visit(AST::EnumerationMemberLiteral&amp;) override;</span>
<span class="line-added">106     void visit(AST::Expression&amp;) override;</span>
<span class="line-added">107     void visit(AST::DotExpression&amp;) override;</span>
<span class="line-added">108     void visit(AST::GlobalVariableReference&amp;) override;</span>
<span class="line-added">109     void visit(AST::IndexExpression&amp;) override;</span>
<span class="line-added">110     void visit(AST::PropertyAccessExpression&amp;) override;</span>
<span class="line-added">111     void visit(AST::VariableDeclaration&amp;) override;</span>
<span class="line-added">112     void visit(AST::AssignmentExpression&amp;) override;</span>
<span class="line-added">113     void visit(AST::CallExpression&amp;) override;</span>
<span class="line-added">114     void visit(AST::CommaExpression&amp;) override;</span>
<span class="line-added">115     void visit(AST::DereferenceExpression&amp;) override;</span>
<span class="line-added">116     void visit(AST::LogicalExpression&amp;) override;</span>
<span class="line-added">117     void visit(AST::LogicalNotExpression&amp;) override;</span>
<span class="line-added">118     void visit(AST::MakeArrayReferenceExpression&amp;) override;</span>
<span class="line-added">119     void visit(AST::MakePointerExpression&amp;) override;</span>
<span class="line-added">120     void visit(AST::ReadModifyWriteExpression&amp;) override;</span>
<span class="line-added">121     void visit(AST::TernaryExpression&amp;) override;</span>
<span class="line-added">122     void visit(AST::VariableReference&amp;) override;</span>
123 
<span class="line-modified">124     enum class LoopConditionLocation {</span>
<span class="line-modified">125         BeforeBody,</span>
<span class="line-modified">126         AfterBody</span>
<span class="line-modified">127     };</span>
<span class="line-modified">128     void emitLoop(LoopConditionLocation, AST::Expression* conditionExpression, AST::Expression* increment, AST::Statement&amp; body);</span>





129 
<span class="line-modified">130     void emitConstantExpressionString(AST::ConstantExpression&amp;);</span>




131 
<span class="line-modified">132     MangledVariableName generateNextVariableName() { return { m_variableCount++ }; }</span>
<span class="line-modified">133 </span>
<span class="line-modified">134     enum class Nullability : uint8_t {</span>
<span class="line-modified">135         NotNull,</span>
<span class="line-modified">136         CanBeNull</span>
<span class="line-modified">137     };</span>
<span class="line-added">138 </span>
<span class="line-added">139     struct StackItem {</span>
<span class="line-added">140         MangledVariableName value;</span>
<span class="line-added">141         MangledVariableName leftValue;</span>
<span class="line-added">142         Nullability valueNullability;</span>
<span class="line-added">143         Nullability leftValueNullability;</span>
<span class="line-added">144         std::function&lt;MangledVariableName()&gt; generateLeftValue;</span>
<span class="line-added">145     };</span>
<span class="line-added">146 </span>
<span class="line-added">147     struct StackValue {</span>
<span class="line-added">148         MangledVariableName value;</span>
<span class="line-added">149         Nullability nullability;</span>
<span class="line-added">150     };</span>
<span class="line-added">151 </span>
<span class="line-added">152     // This is the important data flow step where we can take the nullability of an lvalue</span>
<span class="line-added">153     // and transfer it into the nullability of an rvalue. This is conveyed in MakePointerExpression</span>
<span class="line-added">154     // and DereferenceExpression. MakePointerExpression will try to produce rvalues which are</span>
<span class="line-added">155     // non-null, and DereferenceExpression will take a non-null rvalue and try to produce</span>
<span class="line-added">156     // a non-null lvalue.</span>
<span class="line-added">157     void appendRightValueWithNullability(AST::Expression&amp;, MangledVariableName value, Nullability nullability)</span>
158     {
<span class="line-added">159         m_stack.append({ WTFMove(value), { }, nullability, Nullability::CanBeNull, { } });</span>
160     }
161 
<span class="line-modified">162     void appendRightValue(AST::Expression&amp; expression, MangledVariableName value)</span>
<span class="line-modified">163     {</span>
<span class="line-modified">164         appendRightValueWithNullability(expression, WTFMove(value), Nullability::CanBeNull);</span>
<span class="line-added">165     }</span>
166 
<span class="line-modified">167     void appendLeftValue(AST::Expression&amp; expression, MangledVariableName value, MangledVariableName leftValue, Nullability nullability, std::function&lt;MangledVariableName()&gt; generateLeftValue = { })</span>
168     {
<span class="line-modified">169         ASSERT_UNUSED(expression, expression.typeAnnotation().leftAddressSpace());</span>
<span class="line-modified">170         ASSERT(leftValue || generateLeftValue);</span>
<span class="line-modified">171         m_stack.append({ WTFMove(value), WTFMove(leftValue), Nullability::CanBeNull, nullability, WTFMove(generateLeftValue) });</span>
172     }
173 
<span class="line-modified">174     MangledVariableName takeLastValue()</span>
175     {
<span class="line-modified">176         return m_stack.takeLast().value;</span>
<span class="line-modified">177     }</span>
<span class="line-modified">178 </span>
<span class="line-modified">179     StackValue takeLastValueAndNullability()</span>
<span class="line-modified">180     {</span>
<span class="line-modified">181         auto last = m_stack.takeLast();</span>
<span class="line-modified">182         return { last.value, last.valueNullability };</span>
<span class="line-modified">183     }</span>
<span class="line-modified">184 </span>
<span class="line-modified">185     StackValue takeLastLeftValue()</span>
<span class="line-modified">186     {</span>
<span class="line-modified">187         auto last = m_stack.takeLast();</span>
<span class="line-modified">188         if (!last.leftValue)</span>
<span class="line-modified">189             last.leftValue = last.generateLeftValue();</span>
<span class="line-added">190         return { last.leftValue, last.leftValueNullability };</span>
<span class="line-added">191     }</span>
<span class="line-added">192 </span>
<span class="line-added">193     enum class BreakContext {</span>
<span class="line-added">194         Loop,</span>
<span class="line-added">195         Switch</span>
<span class="line-added">196     };</span>
<span class="line-added">197 </span>
<span class="line-added">198     Optional&lt;BreakContext&gt; m_currentBreakContext;</span>
<span class="line-added">199 </span>
<span class="line-added">200     StringBuilder&amp; m_stringBuilder;</span>
<span class="line-added">201     Intrinsics&amp; m_intrinsics;</span>
<span class="line-added">202     TypeNamer&amp; m_typeNamer;</span>
<span class="line-added">203     HashMap&lt;AST::FunctionDeclaration*, MangledFunctionName&gt;&amp; m_functionMapping;</span>
<span class="line-added">204     HashMap&lt;AST::VariableDeclaration*, MangledVariableName&gt; m_variableMapping;</span>
<span class="line-added">205 </span>
<span class="line-added">206     Vector&lt;StackItem&gt; m_stack;</span>
<span class="line-added">207     std::unique_ptr&lt;EntryPointScaffolding&gt; m_entryPointScaffolding;</span>
<span class="line-added">208     Layout&amp; m_layout;</span>
<span class="line-added">209     unsigned m_variableCount { 0 };</span>
<span class="line-added">210     Optional&lt;MangledVariableName&gt; m_breakOutOfCurrentLoopEarlyVariable;</span>
<span class="line-added">211     Indentation&lt;4&gt; m_indent { 0 };</span>
<span class="line-added">212 };</span>
<span class="line-added">213 </span>
<span class="line-added">214 void FunctionDefinitionWriter::visit(AST::NativeFunctionDeclaration&amp;)</span>
<span class="line-added">215 {</span>
<span class="line-added">216     // We inline native function calls.</span>
<span class="line-added">217 }</span>
<span class="line-added">218 </span>
<span class="line-added">219 void FunctionDefinitionWriter::visit(AST::FunctionDefinition&amp; functionDefinition)</span>
<span class="line-added">220 {</span>
<span class="line-added">221     auto iterator = m_functionMapping.find(&amp;functionDefinition);</span>
<span class="line-added">222     ASSERT(iterator != m_functionMapping.end());</span>
<span class="line-added">223     if (functionDefinition.entryPointType()) {</span>
<span class="line-added">224         auto entryPointScaffolding = createEntryPointScaffolding(functionDefinition);</span>
<span class="line-added">225         if (!entryPointScaffolding)</span>
<span class="line-added">226             return;</span>
<span class="line-added">227         m_entryPointScaffolding = WTFMove(entryPointScaffolding);</span>
<span class="line-added">228 </span>
<span class="line-added">229         m_entryPointScaffolding-&gt;emitHelperTypes(m_stringBuilder, m_indent);</span>
<span class="line-added">230         m_entryPointScaffolding-&gt;emitSignature(m_stringBuilder, iterator-&gt;value, m_indent);</span>
<span class="line-added">231         m_stringBuilder.append(m_indent, &quot;{\n&quot;);</span>
<span class="line-added">232         {</span>
<span class="line-added">233             IndentationScope scope(m_indent);</span>
<span class="line-added">234 </span>
<span class="line-added">235             m_entryPointScaffolding-&gt;emitUnpack(m_stringBuilder, m_indent);</span>
<span class="line-added">236 </span>
237             for (size_t i = 0; i &lt; functionDefinition.parameters().size(); ++i) {
<span class="line-modified">238                 auto addResult = m_variableMapping.add(&amp;functionDefinition.parameters()[i], m_entryPointScaffolding-&gt;parameterVariables()[i]);</span>




239                 ASSERT_UNUSED(addResult, addResult.isNewEntry);

240             }

241             checkErrorAndVisit(functionDefinition.block());
242             ASSERT(m_stack.isEmpty());

243         }
<span class="line-added">244         m_stringBuilder.append(&quot;}\n\n&quot;);</span>
<span class="line-added">245 </span>
<span class="line-added">246         m_entryPointScaffolding = nullptr;</span>
<span class="line-added">247     } else {</span>
<span class="line-added">248         ASSERT(m_entryPointScaffolding == nullptr);</span>
<span class="line-added">249         m_stringBuilder.append(m_indent, m_typeNamer.mangledNameForType(functionDefinition.type()), &#39; &#39;, iterator-&gt;value, &#39;(&#39;);</span>
<span class="line-added">250         for (size_t i = 0; i &lt; functionDefinition.parameters().size(); ++i) {</span>
<span class="line-added">251             auto&amp; parameter = functionDefinition.parameters()[i];</span>
<span class="line-added">252             if (i)</span>
<span class="line-added">253                 m_stringBuilder.append(&quot;, &quot;);</span>
<span class="line-added">254             auto parameterName = generateNextVariableName();</span>
<span class="line-added">255             auto addResult = m_variableMapping.add(&amp;parameter, parameterName);</span>
<span class="line-added">256             ASSERT_UNUSED(addResult, addResult.isNewEntry);</span>
<span class="line-added">257             m_stringBuilder.append(m_typeNamer.mangledNameForType(*parameter-&gt;type()), &#39; &#39;, parameterName);</span>
<span class="line-added">258         }</span>
<span class="line-added">259         m_stringBuilder.append(&quot;)\n&quot;);</span>
<span class="line-added">260         checkErrorAndVisit(functionDefinition.block());</span>
<span class="line-added">261         ASSERT(m_stack.isEmpty());</span>
<span class="line-added">262         m_stringBuilder.append(&#39;\n&#39;);</span>
263     }
<span class="line-added">264 }</span>
265 
<span class="line-modified">266 void FunctionDefinitionWriter::visit(AST::FunctionDeclaration&amp;)</span>
<span class="line-modified">267 {</span>
<span class="line-modified">268     ASSERT_NOT_REACHED();</span>
<span class="line-modified">269 }</span>

270 
<span class="line-modified">271 void FunctionDefinitionWriter::visit(AST::Statement&amp; statement)</span>
<span class="line-modified">272 {</span>
<span class="line-modified">273     Visitor::visit(statement);</span>
<span class="line-modified">274 }</span>
275 
<span class="line-modified">276 void FunctionDefinitionWriter::visit(AST::Block&amp; block)</span>
<span class="line-added">277 {</span>
<span class="line-added">278     m_stringBuilder.append(m_indent, &quot;{\n&quot;);</span>
279     {
<span class="line-modified">280         IndentationScope scope(m_indent);</span>
281         for (auto&amp; statement : block.statements())
282             checkErrorAndVisit(statement);

283     }
<span class="line-added">284     m_stringBuilder.append(m_indent, &quot;}\n&quot;);</span>
<span class="line-added">285 }</span>
286 
<span class="line-modified">287 void FunctionDefinitionWriter::visit(AST::Break&amp;)</span>
<span class="line-modified">288 {</span>
<span class="line-modified">289     ASSERT(m_currentBreakContext);</span>
<span class="line-added">290     switch (*m_currentBreakContext) {</span>
<span class="line-added">291     case BreakContext::Switch:</span>
<span class="line-added">292         m_stringBuilder.append(m_indent, &quot;break;\n&quot;);</span>
<span class="line-added">293         break;</span>
<span class="line-added">294     case BreakContext::Loop:</span>
<span class="line-added">295         ASSERT(m_breakOutOfCurrentLoopEarlyVariable);</span>
<span class="line-added">296         m_stringBuilder.append(</span>
<span class="line-added">297             m_indent, *m_breakOutOfCurrentLoopEarlyVariable, &quot; = true;\n&quot;,</span>
<span class="line-added">298             m_indent, &quot;break;\n&quot;</span>
<span class="line-added">299         );</span>
<span class="line-added">300         break;</span>
301     }
<span class="line-added">302 }</span>
303 
<span class="line-modified">304 void FunctionDefinitionWriter::visit(AST::Continue&amp;)</span>
<span class="line-modified">305 {</span>
<span class="line-modified">306     ASSERT(m_breakOutOfCurrentLoopEarlyVariable);</span>
<span class="line-modified">307     m_stringBuilder.append(m_indent, &quot;break;\n&quot;);</span>
<span class="line-modified">308 }</span>
309 
<span class="line-modified">310 void FunctionDefinitionWriter::visit(AST::EffectfulExpressionStatement&amp; effectfulExpressionStatement)</span>
<span class="line-modified">311 {</span>
<span class="line-modified">312     checkErrorAndVisit(effectfulExpressionStatement.effectfulExpression());</span>
<span class="line-modified">313     takeLastValue(); // The statement is already effectful, so we don&#39;t need to do anything with the result.</span>
<span class="line-modified">314 }</span>



315 
<span class="line-modified">316 void FunctionDefinitionWriter::visit(AST::Fallthrough&amp;)</span>
<span class="line-modified">317 {</span>
<span class="line-modified">318     m_stringBuilder.append(m_indent, &quot;[[clang::fallthrough]];\n&quot;); // FIXME: https://bugs.webkit.org/show_bug.cgi?id=195808 Make sure this is okay. Alternatively, we could do nothing and just return here instead.</span>
<span class="line-modified">319 }</span>

320 
<span class="line-modified">321 void FunctionDefinitionWriter::emitLoop(LoopConditionLocation loopConditionLocation, AST::Expression* conditionExpression, AST::Expression* increment, AST::Statement&amp; body)</span>
<span class="line-modified">322 {</span>
<span class="line-modified">323     SetForScope&lt;Optional&lt;MangledVariableName&gt;&gt; loopVariableScope(m_breakOutOfCurrentLoopEarlyVariable, generateNextVariableName());</span>

324 
<span class="line-modified">325     m_stringBuilder.append(</span>
<span class="line-added">326         m_indent, &quot;bool &quot;, *m_breakOutOfCurrentLoopEarlyVariable, &quot; = false;\n&quot;,</span>
<span class="line-added">327         m_indent, &quot;while (true) {\n&quot;</span>
<span class="line-added">328     );</span>
329     {
<span class="line-modified">330         IndentationScope whileScope(m_indent);</span>
<span class="line-modified">331 </span>
<span class="line-modified">332         if (loopConditionLocation == LoopConditionLocation::BeforeBody &amp;&amp; conditionExpression) {</span>
<span class="line-modified">333             checkErrorAndVisit(*conditionExpression);</span>
<span class="line-modified">334             m_stringBuilder.append(</span>
<span class="line-modified">335                 m_indent, &quot;if (!&quot;, takeLastValue(), &quot;)\n&quot;,</span>
<span class="line-modified">336                 m_indent, &quot;    break;\n&quot;);</span>




337         }
<span class="line-modified">338 </span>
<span class="line-modified">339         m_stringBuilder.append(m_indent, &quot;do {\n&quot;);</span>
<span class="line-modified">340         SetForScope&lt;Optional&lt;BreakContext&gt;&gt; breakContext(m_currentBreakContext, BreakContext::Loop);</span>
<span class="line-modified">341 </span>
<span class="line-added">342         {</span>
<span class="line-added">343             IndentationScope doScope(m_indent);</span>
<span class="line-added">344             checkErrorAndVisit(body);</span>
<span class="line-added">345         }</span>
<span class="line-added">346         m_stringBuilder.append(m_indent, &quot;} while(false); \n&quot;);</span>
<span class="line-added">347 </span>
<span class="line-added">348         m_stringBuilder.append(</span>
<span class="line-added">349             m_indent, &quot;if (&quot;, *m_breakOutOfCurrentLoopEarlyVariable, &quot;)\n&quot;,</span>
<span class="line-added">350             m_indent, &quot;    break;\n&quot;);</span>
<span class="line-added">351 </span>
<span class="line-added">352         if (increment) {</span>
<span class="line-added">353             checkErrorAndVisit(*increment);</span>
<span class="line-added">354             // Expression results get pushed to m_stack. We don&#39;t use the result</span>
<span class="line-added">355             // of increment, so we dispense of that now.</span>
<span class="line-added">356             takeLastValue();</span>
357         }
<span class="line-modified">358 </span>
<span class="line-added">359         if (loopConditionLocation == LoopConditionLocation::AfterBody &amp;&amp; conditionExpression) {</span>
<span class="line-added">360             checkErrorAndVisit(*conditionExpression);</span>
<span class="line-added">361             m_stringBuilder.append(</span>
<span class="line-added">362                 m_indent, &quot;if (!&quot;, takeLastValue(), &quot;)\n&quot;,</span>
<span class="line-added">363                 m_indent, &quot;    break;\n&quot;);</span>
<span class="line-added">364         }</span>
<span class="line-added">365     }</span>
<span class="line-added">366 </span>
<span class="line-added">367     m_stringBuilder.append(m_indent, &quot;} \n&quot;);</span>
<span class="line-added">368 }</span>
<span class="line-added">369 </span>
<span class="line-added">370 void FunctionDefinitionWriter::visit(AST::DoWhileLoop&amp; doWhileLoop)</span>
<span class="line-added">371 {</span>
<span class="line-added">372     emitLoop(LoopConditionLocation::AfterBody, &amp;doWhileLoop.conditional(), nullptr, doWhileLoop.body());</span>
<span class="line-added">373 }</span>
<span class="line-added">374 </span>
<span class="line-added">375 void FunctionDefinitionWriter::visit(AST::WhileLoop&amp; whileLoop)</span>
<span class="line-added">376 {</span>
<span class="line-added">377     emitLoop(LoopConditionLocation::BeforeBody, &amp;whileLoop.conditional(), nullptr, whileLoop.body());</span>
<span class="line-added">378 }</span>
<span class="line-added">379 </span>
<span class="line-added">380 void FunctionDefinitionWriter::visit(AST::ForLoop&amp; forLoop)</span>
<span class="line-added">381 {</span>
<span class="line-added">382     m_stringBuilder.append(m_indent, &quot;{\n&quot;);</span>
<span class="line-added">383     {</span>
<span class="line-added">384         IndentationScope scope(m_indent);</span>
<span class="line-added">385         checkErrorAndVisit(forLoop.initialization());</span>
<span class="line-added">386         emitLoop(LoopConditionLocation::BeforeBody, forLoop.condition(), forLoop.increment(), forLoop.body());</span>
387     }
<span class="line-added">388     m_stringBuilder.append(m_indent, &quot;}\n&quot;);</span>
<span class="line-added">389 }</span>
390 
<span class="line-modified">391 void FunctionDefinitionWriter::visit(AST::IfStatement&amp; ifStatement)</span>
<span class="line-added">392 {</span>
<span class="line-added">393     checkErrorAndVisit(ifStatement.conditional());</span>
<span class="line-added">394     m_stringBuilder.append(m_indent, &quot;if (&quot;, takeLastValue(), &quot;) {\n&quot;);</span>
395     {
<span class="line-modified">396         IndentationScope ifScope(m_indent);</span>

397         checkErrorAndVisit(ifStatement.body());
<span class="line-modified">398     }</span>
<span class="line-modified">399     if (ifStatement.elseBody()) {</span>
<span class="line-added">400         m_stringBuilder.append(m_indent, &quot;} else {\n&quot;);</span>
<span class="line-added">401         {</span>
<span class="line-added">402             IndentationScope elseScope(m_indent);</span>
403             checkErrorAndVisit(*ifStatement.elseBody());
404         }

405     }
<span class="line-added">406     m_stringBuilder.append(m_indent, &quot;}\n&quot;);</span>
<span class="line-added">407 }</span>
408 
<span class="line-modified">409 void FunctionDefinitionWriter::visit(AST::Return&amp; returnStatement)</span>
<span class="line-modified">410 {</span>
<span class="line-modified">411     if (returnStatement.value()) {</span>
<span class="line-modified">412         checkErrorAndVisit(*returnStatement.value());</span>
<span class="line-modified">413 </span>
<span class="line-modified">414         if (m_entryPointScaffolding) {</span>
<span class="line-modified">415             auto variableName = generateNextVariableName();</span>
<span class="line-modified">416             m_entryPointScaffolding-&gt;emitPack(m_stringBuilder, takeLastValue(), variableName, m_indent);</span>
<span class="line-modified">417             m_stringBuilder.append(m_indent, &quot;return &quot;, variableName, &quot;;\n&quot;);</span>

418         } else
<span class="line-modified">419             m_stringBuilder.append(m_indent, &quot;return &quot;, takeLastValue(), &quot;;\n&quot;);</span>
<span class="line-modified">420     } else</span>
<span class="line-added">421         m_stringBuilder.append(m_indent, &quot;return;\n&quot;);</span>
<span class="line-added">422 }</span>
423 
<span class="line-modified">424 void FunctionDefinitionWriter::visit(AST::SwitchStatement&amp; switchStatement)</span>
<span class="line-modified">425 {</span>
<span class="line-modified">426     checkErrorAndVisit(switchStatement.value());</span>
427 
<span class="line-modified">428     m_stringBuilder.append(m_indent, &quot;switch (&quot;, takeLastValue(), &quot;) {&quot;);</span>
<span class="line-added">429     {</span>
<span class="line-added">430         IndentationScope switchScope(m_indent);</span>
431         for (auto&amp; switchCase : switchStatement.switchCases())
432             checkErrorAndVisit(switchCase);

433     }
<span class="line-added">434     m_stringBuilder.append(m_indent, &quot;}\n&quot;);</span>
<span class="line-added">435 }</span>
436 
<span class="line-modified">437 void FunctionDefinitionWriter::visit(AST::SwitchCase&amp; switchCase)</span>
<span class="line-modified">438 {</span>
<span class="line-modified">439     if (switchCase.value()) {</span>
<span class="line-modified">440         m_stringBuilder.append(m_indent, &quot;case &quot;);</span>
<span class="line-modified">441         emitConstantExpressionString(*switchCase.value());</span>
<span class="line-modified">442         m_stringBuilder.append(&quot;:\n&quot;);</span>
<span class="line-modified">443     } else</span>
<span class="line-modified">444         m_stringBuilder.append(m_indent, &quot;default:\n&quot;);</span>
<span class="line-modified">445     SetForScope&lt;Optional&lt;BreakContext&gt;&gt; breakContext(m_currentBreakContext, BreakContext::Switch);</span>
<span class="line-modified">446     checkErrorAndVisit(switchCase.block());</span>
<span class="line-added">447     // FIXME: https://bugs.webkit.org/show_bug.cgi?id=195812 Figure out whether we need to break or fallthrough.</span>
<span class="line-added">448 }</span>
449 
<span class="line-modified">450 void FunctionDefinitionWriter::visit(AST::VariableDeclarationsStatement&amp; variableDeclarationsStatement)</span>
<span class="line-modified">451 {</span>
<span class="line-modified">452     Visitor::visit(variableDeclarationsStatement);</span>
<span class="line-modified">453 }</span>

454 
<span class="line-modified">455 void FunctionDefinitionWriter::visit(AST::IntegerLiteral&amp; integerLiteral)</span>
<span class="line-modified">456 {</span>
<span class="line-modified">457     auto variableName = generateNextVariableName();</span>
<span class="line-modified">458     auto mangledTypeName = m_typeNamer.mangledNameForType(integerLiteral.resolvedType());</span>
<span class="line-added">459     m_stringBuilder.append(m_indent, mangledTypeName, &#39; &#39;, variableName, &quot; = static_cast&lt;&quot;, mangledTypeName, &quot;&gt;(&quot;, integerLiteral.value(), &quot;);\n&quot;);</span>
<span class="line-added">460     appendRightValue(integerLiteral, variableName);</span>
<span class="line-added">461 }</span>
462 
<span class="line-modified">463 void FunctionDefinitionWriter::visit(AST::UnsignedIntegerLiteral&amp; unsignedIntegerLiteral)</span>
<span class="line-modified">464 {</span>
<span class="line-modified">465     auto variableName = generateNextVariableName();</span>
<span class="line-modified">466     auto mangledTypeName = m_typeNamer.mangledNameForType(unsignedIntegerLiteral.resolvedType());</span>
<span class="line-modified">467     m_stringBuilder.append(m_indent, mangledTypeName, &#39; &#39;, variableName, &quot; = static_cast&lt;&quot;, mangledTypeName, &quot;&gt;(&quot;, unsignedIntegerLiteral.value(), &quot;);\n&quot;);</span>
<span class="line-modified">468     appendRightValue(unsignedIntegerLiteral, variableName);</span>
<span class="line-modified">469 }</span>

470 
<span class="line-modified">471 void FunctionDefinitionWriter::visit(AST::FloatLiteral&amp; floatLiteral)</span>
<span class="line-modified">472 {</span>
<span class="line-modified">473     auto variableName = generateNextVariableName();</span>
<span class="line-modified">474     auto mangledTypeName = m_typeNamer.mangledNameForType(floatLiteral.resolvedType());</span>
<span class="line-modified">475     m_stringBuilder.append(m_indent, mangledTypeName, &#39; &#39;, variableName, &quot; = static_cast&lt;&quot;, mangledTypeName, &quot;&gt;(&quot;, floatLiteral.value(), &quot;);\n&quot;);</span>
<span class="line-modified">476     appendRightValue(floatLiteral, variableName);</span>
<span class="line-modified">477 }</span>

478 
<span class="line-modified">479 void FunctionDefinitionWriter::visit(AST::NullLiteral&amp; nullLiteral)</span>
<span class="line-modified">480 {</span>
<span class="line-modified">481     auto&amp; unifyNode = nullLiteral.resolvedType().unifyNode();</span>
<span class="line-modified">482     auto&amp; unnamedType = downcast&lt;AST::UnnamedType&gt;(unifyNode);</span>
<span class="line-modified">483     bool isArrayReferenceType = is&lt;AST::ArrayReferenceType&gt;(unnamedType);</span>
<span class="line-modified">484 </span>
<span class="line-modified">485     auto variableName = generateNextVariableName();</span>
<span class="line-modified">486     m_stringBuilder.append(m_indent, m_typeNamer.mangledNameForType(nullLiteral.resolvedType()), &#39; &#39;, variableName, &quot; = &quot;);</span>
<span class="line-added">487     if (isArrayReferenceType)</span>
<span class="line-added">488         m_stringBuilder.append(&quot;{ nullptr, 0 };\n&quot;);</span>
<span class="line-added">489     else</span>
<span class="line-added">490         m_stringBuilder.append(&quot;nullptr;\n&quot;);</span>
<span class="line-added">491     appendRightValue(nullLiteral, variableName);</span>
<span class="line-added">492 }</span>
493 
<span class="line-modified">494 void FunctionDefinitionWriter::visit(AST::BooleanLiteral&amp; booleanLiteral)</span>
<span class="line-modified">495 {</span>
<span class="line-modified">496     auto variableName = generateNextVariableName();</span>
<span class="line-modified">497     auto mangledTypeName = m_typeNamer.mangledNameForType(booleanLiteral.resolvedType());</span>
<span class="line-modified">498     m_stringBuilder.append(m_indent, mangledTypeName, &#39; &#39;, variableName, &quot; = static_cast&lt;&quot;, mangledTypeName, &quot;&gt;(&quot;, booleanLiteral.value() ? &quot;true&quot; : &quot;false&quot;, &quot;);\n&quot;);</span>
<span class="line-modified">499     appendRightValue(booleanLiteral, variableName);</span>
<span class="line-modified">500 }</span>

501 
<span class="line-modified">502 void FunctionDefinitionWriter::visit(AST::EnumerationMemberLiteral&amp; enumerationMemberLiteral)</span>
<span class="line-modified">503 {</span>
<span class="line-modified">504     ASSERT(enumerationMemberLiteral.enumerationDefinition());</span>
<span class="line-modified">505     ASSERT(enumerationMemberLiteral.enumerationDefinition());</span>
<span class="line-modified">506     auto variableName = generateNextVariableName();</span>
<span class="line-modified">507     auto mangledTypeName = m_typeNamer.mangledNameForType(enumerationMemberLiteral.resolvedType());</span>
<span class="line-modified">508     m_stringBuilder.append(m_indent, mangledTypeName, &#39; &#39;, variableName, &quot; = &quot;, mangledTypeName, &quot;::&quot;, m_typeNamer.mangledNameForEnumerationMember(*enumerationMemberLiteral.enumerationMember()), &quot;;\n&quot;);</span>
<span class="line-modified">509     appendRightValue(enumerationMemberLiteral, variableName);</span>
<span class="line-modified">510 }</span>








511 
<span class="line-modified">512 void FunctionDefinitionWriter::visit(AST::Expression&amp; expression)</span>
<span class="line-modified">513 {</span>
<span class="line-modified">514     Visitor::visit(expression);</span>
<span class="line-modified">515 }</span>




516 
<span class="line-modified">517 void FunctionDefinitionWriter::visit(AST::DotExpression&amp; dotExpression)</span>
<span class="line-modified">518 {</span>
<span class="line-modified">519     // This should be lowered already.</span>
<span class="line-modified">520     // FIXME: https://bugs.webkit.org/show_bug.cgi?id=195788 Replace this with ASSERT_NOT_REACHED().</span>
<span class="line-modified">521     notImplemented();</span>
<span class="line-modified">522     appendRightValue(dotExpression, generateNextVariableName());</span>
<span class="line-modified">523 }</span>



524 
<span class="line-modified">525 void FunctionDefinitionWriter::visit(AST::GlobalVariableReference&amp; globalVariableReference)</span>
<span class="line-modified">526 {</span>
<span class="line-modified">527     auto valueName = generateNextVariableName();</span>
<span class="line-modified">528     MangledTypeName mangledTypeName = m_typeNamer.mangledNameForType(globalVariableReference.resolvedType());</span>
529 
<span class="line-modified">530     checkErrorAndVisit(globalVariableReference.base());</span>
<span class="line-modified">531     MangledVariableName structVariable = takeLastValue();</span>



532 
<span class="line-modified">533     MangledStructureElementName mangledFieldName = m_typeNamer.mangledNameForStructureElement(globalVariableReference.structField());</span>




534 
<span class="line-modified">535     m_stringBuilder.append(</span>
<span class="line-modified">536         m_indent, mangledTypeName, &#39; &#39;, valueName, &quot; = &quot;, structVariable, &quot;-&gt;&quot;, mangledFieldName, &quot;;\n&quot;);</span>


537 
<span class="line-modified">538     appendLeftValue(globalVariableReference, valueName, { }, Nullability::NotNull,</span>
<span class="line-modified">539         [this, mangledTypeName, structVariable, mangledFieldName] {</span>
<span class="line-modified">540             auto pointerName = generateNextVariableName();</span>
<span class="line-modified">541             m_stringBuilder.append(</span>
<span class="line-modified">542                 m_indent, &quot;thread &quot;, mangledTypeName, &quot;* &quot;, pointerName, &quot; = &amp;&quot;, structVariable, &quot;-&gt;&quot;, mangledFieldName, &quot;;\n&quot;);</span>
<span class="line-modified">543             return pointerName;</span>
<span class="line-modified">544         });</span>
<span class="line-modified">545 }</span>
<span class="line-modified">546 </span>
<span class="line-modified">547 void FunctionDefinitionWriter::visit(AST::IndexExpression&amp; indexExpression)</span>
<span class="line-modified">548 {</span>
<span class="line-modified">549     // This should be lowered already.</span>
<span class="line-modified">550     // FIXME: https://bugs.webkit.org/show_bug.cgi?id=195788 Replace this with ASSERT_NOT_REACHED().</span>
<span class="line-modified">551     notImplemented();</span>
<span class="line-modified">552     appendRightValue(indexExpression, generateNextVariableName());</span>
<span class="line-added">553 }</span>
<span class="line-added">554 </span>
<span class="line-added">555 void FunctionDefinitionWriter::visit(AST::PropertyAccessExpression&amp; propertyAccessExpression)</span>
<span class="line-added">556 {</span>
<span class="line-added">557     // This should be lowered already.</span>
<span class="line-added">558     // FIXME: https://bugs.webkit.org/show_bug.cgi?id=195788 Replace this with ASSERT_NOT_REACHED().</span>
<span class="line-added">559     notImplemented();</span>
<span class="line-added">560     appendRightValue(propertyAccessExpression, generateNextVariableName());</span>
<span class="line-added">561 }</span>
<span class="line-added">562 </span>
<span class="line-added">563 void FunctionDefinitionWriter::visit(AST::VariableDeclaration&amp; variableDeclaration)</span>
<span class="line-added">564 {</span>
<span class="line-added">565     ASSERT(variableDeclaration.type());</span>
<span class="line-added">566     auto variableName = generateNextVariableName();</span>
<span class="line-added">567     auto addResult = m_variableMapping.add(&amp;variableDeclaration, variableName);</span>
<span class="line-added">568     ASSERT_UNUSED(addResult, addResult.isNewEntry);</span>
<span class="line-added">569     // FIXME: https://bugs.webkit.org/show_bug.cgi?id=198160 Implement qualifiers.</span>
<span class="line-added">570     if (variableDeclaration.initializer()) {</span>
<span class="line-added">571         checkErrorAndVisit(*variableDeclaration.initializer());</span>
<span class="line-added">572         m_stringBuilder.append(m_indent, m_typeNamer.mangledNameForType(*variableDeclaration.type()), &#39; &#39;, variableName, &quot; = &quot;, takeLastValue(), &quot;;\n&quot;);</span>
<span class="line-added">573     } else</span>
<span class="line-added">574         m_stringBuilder.append(m_indent, m_typeNamer.mangledNameForType(*variableDeclaration.type()), &#39; &#39;, variableName, &quot; = { };\n&quot;);</span>
<span class="line-added">575 }</span>
<span class="line-added">576 </span>
<span class="line-added">577 void FunctionDefinitionWriter::visit(AST::AssignmentExpression&amp; assignmentExpression)</span>
<span class="line-added">578 {</span>
<span class="line-added">579     checkErrorAndVisit(assignmentExpression.left());</span>
<span class="line-added">580     auto [pointerName, nullability] = takeLastLeftValue();</span>
<span class="line-added">581     checkErrorAndVisit(assignmentExpression.right());</span>
<span class="line-added">582     auto [rightName, rightNullability] = takeLastValueAndNullability();</span>
<span class="line-added">583 </span>
<span class="line-added">584     if (nullability == Nullability::CanBeNull)</span>
<span class="line-added">585         m_stringBuilder.append(</span>
<span class="line-added">586             m_indent, &quot;if (&quot;, pointerName, &quot;)\n&quot;,</span>
<span class="line-added">587             m_indent, &quot;    *&quot;, pointerName, &quot; = &quot;, rightName, &quot;;\n&quot;);</span>
<span class="line-added">588     else</span>
<span class="line-added">589         m_stringBuilder.append(m_indent, &quot;*&quot;, pointerName, &quot; = &quot;, rightName, &quot;;\n&quot;);</span>
<span class="line-added">590     appendRightValueWithNullability(assignmentExpression, rightName, rightNullability);</span>
<span class="line-added">591 }</span>
<span class="line-added">592 </span>
<span class="line-added">593 void FunctionDefinitionWriter::visit(AST::CallExpression&amp; callExpression)</span>
<span class="line-added">594 {</span>
<span class="line-added">595     Vector&lt;MangledVariableName&gt; argumentNames;</span>
<span class="line-added">596     for (auto&amp; argument : callExpression.arguments()) {</span>
<span class="line-added">597         checkErrorAndVisit(argument);</span>
<span class="line-added">598         argumentNames.append(takeLastValue());</span>
599     }
600 
<span class="line-modified">601     bool isVoid = matches(callExpression.resolvedType(), m_intrinsics.voidType());</span>
<span class="line-modified">602     MangledVariableName returnName;</span>
<span class="line-modified">603     if (!isVoid) {</span>
<span class="line-modified">604         returnName = generateNextVariableName();</span>
<span class="line-modified">605         m_stringBuilder.append(m_indent, m_typeNamer.mangledNameForType(callExpression.resolvedType()), &#39; &#39;, returnName, &quot;;\n&quot;);</span>


606     }
607 
<span class="line-modified">608     if (is&lt;AST::NativeFunctionDeclaration&gt;(callExpression.function())) {</span>
<span class="line-modified">609         auto generateNextVariableName = [this]() -&gt; MangledVariableName {</span>
<span class="line-modified">610             return this-&gt;generateNextVariableName();</span>
<span class="line-modified">611         };</span>
<span class="line-modified">612 </span>
<span class="line-modified">613         m_stringBuilder.append(&#39;\n&#39;);</span>
<span class="line-modified">614         inlineNativeFunction(m_stringBuilder, downcast&lt;AST::NativeFunctionDeclaration&gt;(callExpression.function()), returnName, argumentNames, m_intrinsics, m_typeNamer, WTFMove(generateNextVariableName), m_indent);</span>
<span class="line-modified">615         m_stringBuilder.append(&#39;\n&#39;);</span>
<span class="line-modified">616     } else {</span>
<span class="line-modified">617         m_stringBuilder.append(m_indent);</span>
<span class="line-added">618 </span>
<span class="line-added">619         auto iterator = m_functionMapping.find(&amp;callExpression.function());</span>
620         ASSERT(iterator != m_functionMapping.end());
<span class="line-modified">621         if (!isVoid)</span>
<span class="line-modified">622             m_stringBuilder.append(returnName, &quot; = &quot;);</span>
<span class="line-added">623         m_stringBuilder.append(iterator-&gt;value, &#39;(&#39;);</span>
624         for (size_t i = 0; i &lt; argumentNames.size(); ++i) {
625             if (i)
626                 m_stringBuilder.append(&quot;, &quot;);
627             m_stringBuilder.append(argumentNames[i]);
628         }
629         m_stringBuilder.append(&quot;);\n&quot;);

630     }
631 
<span class="line-modified">632     appendRightValue(callExpression, returnName);</span>
<span class="line-modified">633 }</span>







634 
<span class="line-modified">635 void FunctionDefinitionWriter::visit(AST::CommaExpression&amp; commaExpression)</span>
<span class="line-modified">636 {</span>
<span class="line-modified">637     Optional&lt;MangledVariableName&gt; result;</span>
<span class="line-modified">638     for (auto&amp; expression : commaExpression.list()) {</span>
<span class="line-modified">639         checkErrorAndVisit(expression);</span>
<span class="line-modified">640         result = takeLastValue();</span>


641     }
<span class="line-added">642     ASSERT(result);</span>
<span class="line-added">643     appendRightValue(commaExpression, *result);</span>
<span class="line-added">644 }</span>
645 
<span class="line-modified">646 void FunctionDefinitionWriter::visit(AST::DereferenceExpression&amp; dereferenceExpression)</span>
<span class="line-modified">647 {</span>
<span class="line-modified">648     checkErrorAndVisit(dereferenceExpression.pointer());</span>
<span class="line-modified">649     auto [inputPointer, nullability] = takeLastValueAndNullability();</span>
<span class="line-modified">650     auto resultValue = generateNextVariableName();</span>
<span class="line-modified">651     auto resultType = m_typeNamer.mangledNameForType(dereferenceExpression.resolvedType());</span>
<span class="line-modified">652 </span>
<span class="line-modified">653     if (nullability == Nullability::CanBeNull) {</span>
<span class="line-modified">654         m_stringBuilder.append(</span>
<span class="line-modified">655             m_indent, resultType , &#39; &#39;, resultValue, &quot; = &quot;, inputPointer, &quot; ? &quot;, &#39;*&#39;, inputPointer, &quot; : &quot;, resultType, &quot;{ };\n&quot;);</span>
<span class="line-modified">656     } else</span>
<span class="line-modified">657         m_stringBuilder.append(m_indent, resultValue, &quot; = *&quot;, inputPointer, &quot;;\n&quot;);</span>
<span class="line-modified">658 </span>
<span class="line-modified">659     appendLeftValue(dereferenceExpression, resultValue, inputPointer, nullability);</span>
<span class="line-modified">660 }</span>
<span class="line-modified">661 </span>
<span class="line-modified">662 void FunctionDefinitionWriter::visit(AST::LogicalExpression&amp; logicalExpression)</span>
<span class="line-added">663 {</span>
<span class="line-added">664     checkErrorAndVisit(logicalExpression.left());</span>
<span class="line-added">665     auto left = takeLastValue();</span>
<span class="line-added">666     checkErrorAndVisit(logicalExpression.right());</span>
<span class="line-added">667     auto right = takeLastValue();</span>
<span class="line-added">668     auto variableName = generateNextVariableName();</span>
<span class="line-added">669 </span>
<span class="line-added">670     m_stringBuilder.append(</span>
<span class="line-added">671         m_indent, m_typeNamer.mangledNameForType(logicalExpression.resolvedType()), &#39; &#39;, variableName, &quot; = &quot;, left);</span>
<span class="line-added">672     switch (logicalExpression.type()) {</span>
<span class="line-added">673     case AST::LogicalExpression::Type::And:</span>
<span class="line-added">674         m_stringBuilder.append(&quot; &amp;&amp; &quot;);</span>
<span class="line-added">675         break;</span>
<span class="line-added">676     default:</span>
<span class="line-added">677         ASSERT(logicalExpression.type() == AST::LogicalExpression::Type::Or);</span>
<span class="line-added">678         m_stringBuilder.append(&quot; || &quot;);</span>
<span class="line-added">679         break;</span>
<span class="line-added">680     }</span>
<span class="line-added">681     m_stringBuilder.append(right, &quot;;\n&quot;);</span>
<span class="line-added">682     appendRightValue(logicalExpression, variableName);</span>
<span class="line-added">683 }</span>
<span class="line-added">684 </span>
<span class="line-added">685 void FunctionDefinitionWriter::visit(AST::LogicalNotExpression&amp; logicalNotExpression)</span>
<span class="line-added">686 {</span>
<span class="line-added">687     checkErrorAndVisit(logicalNotExpression.operand());</span>
<span class="line-added">688     auto operand = takeLastValue();</span>
<span class="line-added">689     auto variableName = generateNextVariableName();</span>
<span class="line-added">690 </span>
<span class="line-added">691     m_stringBuilder.append(</span>
<span class="line-added">692         m_indent, m_typeNamer.mangledNameForType(logicalNotExpression.resolvedType()), &#39; &#39;, variableName, &quot; = !&quot;, operand, &quot;;\n&quot;);</span>
<span class="line-added">693     appendRightValue(logicalNotExpression, variableName);</span>
<span class="line-added">694 }</span>
<span class="line-added">695 </span>
<span class="line-added">696 void FunctionDefinitionWriter::visit(AST::MakeArrayReferenceExpression&amp; makeArrayReferenceExpression)</span>
<span class="line-added">697 {</span>
<span class="line-added">698     checkErrorAndVisit(makeArrayReferenceExpression.leftValue());</span>
<span class="line-added">699     // FIXME: This needs to be made to work. It probably should be using the last leftValue too.</span>
<span class="line-added">700     // https://bugs.webkit.org/show_bug.cgi?id=198838</span>
<span class="line-added">701     auto variableName = generateNextVariableName();</span>
<span class="line-added">702 </span>
<span class="line-added">703     auto mangledTypeName = m_typeNamer.mangledNameForType(makeArrayReferenceExpression.resolvedType());</span>
<span class="line-added">704     if (is&lt;AST::PointerType&gt;(makeArrayReferenceExpression.leftValue().resolvedType())) {</span>
<span class="line-added">705         auto ptrValue = takeLastValue();</span>
<span class="line-added">706         m_stringBuilder.append(</span>
<span class="line-added">707             m_indent, mangledTypeName, &#39; &#39;, variableName, &quot; = &quot;, ptrValue, &quot; ? &quot;, mangledTypeName, &quot;{ &quot;, ptrValue, &quot;, 1 } : &quot;, mangledTypeName, &quot;{ nullptr, 0 };\n&quot;);</span>
<span class="line-added">708     } else if (is&lt;AST::ArrayType&gt;(makeArrayReferenceExpression.leftValue().resolvedType())) {</span>
<span class="line-added">709         auto lValue = takeLastLeftValue().value;</span>
<span class="line-added">710         auto&amp; arrayType = downcast&lt;AST::ArrayType&gt;(makeArrayReferenceExpression.leftValue().resolvedType());</span>
<span class="line-added">711         m_stringBuilder.append(m_indent, mangledTypeName, &#39; &#39;, variableName, &quot; = { &quot;, lValue, &quot;-&gt;data(), &quot;, arrayType.numElements(), &quot; };\n&quot;);</span>
<span class="line-added">712     } else {</span>
<span class="line-added">713         auto lValue = takeLastLeftValue().value;</span>
<span class="line-added">714         m_stringBuilder.append(m_indent, mangledTypeName, &#39; &#39;, variableName, &quot; = { &quot;, lValue, &quot;, 1 };\n&quot;);</span>
<span class="line-added">715     }</span>
<span class="line-added">716     appendRightValue(makeArrayReferenceExpression, variableName);</span>
<span class="line-added">717 }</span>
<span class="line-added">718 </span>
<span class="line-added">719 void FunctionDefinitionWriter::visit(AST::MakePointerExpression&amp; makePointerExpression)</span>
<span class="line-added">720 {</span>
<span class="line-added">721     checkErrorAndVisit(makePointerExpression.leftValue());</span>
<span class="line-added">722     auto [pointer, nullability] = takeLastLeftValue();</span>
<span class="line-added">723     auto variableName = generateNextVariableName();</span>
<span class="line-added">724     m_stringBuilder.append(m_indent, m_typeNamer.mangledNameForType(makePointerExpression.resolvedType()), &#39; &#39;, variableName, &quot; = &quot;, pointer, &quot;;\n&quot;);</span>
<span class="line-added">725     appendRightValueWithNullability(makePointerExpression, variableName, nullability);</span>
<span class="line-added">726 }</span>
<span class="line-added">727 </span>
<span class="line-added">728 void FunctionDefinitionWriter::visit(AST::ReadModifyWriteExpression&amp;)</span>
<span class="line-added">729 {</span>
<span class="line-added">730     // This should be lowered already.</span>
<span class="line-added">731     ASSERT_NOT_REACHED();</span>
<span class="line-added">732 }</span>
<span class="line-added">733 </span>
<span class="line-added">734 void FunctionDefinitionWriter::visit(AST::TernaryExpression&amp; ternaryExpression)</span>
<span class="line-added">735 {</span>
<span class="line-added">736     checkErrorAndVisit(ternaryExpression.predicate());</span>
<span class="line-added">737     auto check = takeLastValue();</span>
<span class="line-added">738     checkErrorAndVisit(ternaryExpression.bodyExpression());</span>
<span class="line-added">739     auto body = takeLastValue();</span>
<span class="line-added">740     checkErrorAndVisit(ternaryExpression.elseExpression());</span>
<span class="line-added">741     auto elseBody = takeLastValue();</span>
<span class="line-added">742 </span>
<span class="line-added">743     auto variableName = generateNextVariableName();</span>
<span class="line-added">744     m_stringBuilder.append(m_indent, m_typeNamer.mangledNameForType(ternaryExpression.resolvedType()), &#39; &#39;, variableName, &quot; = &quot;, check, &quot; ? &quot;, body, &quot; : &quot;, elseBody, &quot;;\n&quot;);</span>
<span class="line-added">745     appendRightValue(ternaryExpression, variableName);</span>
<span class="line-added">746 }</span>
<span class="line-added">747 </span>
<span class="line-added">748 void FunctionDefinitionWriter::visit(AST::VariableReference&amp; variableReference)</span>
<span class="line-added">749 {</span>
<span class="line-added">750     ASSERT(variableReference.variable());</span>
<span class="line-added">751     auto iterator = m_variableMapping.find(variableReference.variable());</span>
<span class="line-added">752     ASSERT(iterator != m_variableMapping.end());</span>
<span class="line-added">753 </span>
<span class="line-added">754     MangledVariableName variableName = iterator-&gt;value;</span>
<span class="line-added">755 </span>
<span class="line-added">756     appendLeftValue(variableReference, variableName, { }, Nullability::NotNull,</span>
<span class="line-added">757         [this, &amp;variableReference, variableName] {</span>
<span class="line-added">758             auto pointerName = generateNextVariableName();</span>
<span class="line-added">759             m_stringBuilder.append(m_indent, &quot;thread &quot;, m_typeNamer.mangledNameForType(variableReference.resolvedType()), &quot;* &quot;, pointerName, &quot; = &amp;&quot;, variableName, &quot;;\n&quot;);</span>
<span class="line-added">760             return pointerName;</span>
<span class="line-added">761         });</span>
<span class="line-added">762 }</span>
<span class="line-added">763 </span>
<span class="line-added">764 void FunctionDefinitionWriter::emitConstantExpressionString(AST::ConstantExpression&amp; constantExpression)</span>
<span class="line-added">765 {</span>
<span class="line-added">766     constantExpression.visit(WTF::makeVisitor(</span>
<span class="line-added">767         [&amp;](AST::IntegerLiteral&amp; integerLiteral) {</span>
<span class="line-added">768             m_stringBuilder.append(integerLiteral.value());</span>
<span class="line-added">769         },</span>
<span class="line-added">770         [&amp;](AST::UnsignedIntegerLiteral&amp; unsignedIntegerLiteral) {</span>
<span class="line-added">771             m_stringBuilder.append(unsignedIntegerLiteral.value());</span>
<span class="line-added">772         },</span>
<span class="line-added">773         [&amp;](AST::FloatLiteral&amp; floatLiteral) {</span>
<span class="line-added">774             m_stringBuilder.append(floatLiteral.value());</span>
<span class="line-added">775         },</span>
<span class="line-added">776         [&amp;](AST::NullLiteral&amp;) {</span>
<span class="line-added">777             m_stringBuilder.append(&quot;nullptr&quot;);</span>
<span class="line-added">778         },</span>
<span class="line-added">779         [&amp;](AST::BooleanLiteral&amp; booleanLiteral) {</span>
<span class="line-added">780             if (booleanLiteral.value())</span>
<span class="line-added">781                 m_stringBuilder.append(&quot;true&quot;);</span>
<span class="line-added">782             else</span>
<span class="line-added">783                 m_stringBuilder.append(&quot;false&quot;);</span>
<span class="line-added">784         },</span>
<span class="line-added">785         [&amp;](AST::EnumerationMemberLiteral&amp; enumerationMemberLiteral) {</span>
<span class="line-added">786             ASSERT(enumerationMemberLiteral.enumerationDefinition());</span>
<span class="line-added">787             ASSERT(enumerationMemberLiteral.enumerationDefinition());</span>
<span class="line-added">788             m_stringBuilder.append(m_typeNamer.mangledNameForType(*enumerationMemberLiteral.enumerationDefinition()), &quot;::&quot;, m_typeNamer.mangledNameForEnumerationMember(*enumerationMemberLiteral.enumerationMember()));</span>
789         }
<span class="line-modified">790     ));</span>
<span class="line-modified">791 }</span>

792 
<span class="line-modified">793 class RenderFunctionDefinitionWriter final : public FunctionDefinitionWriter {</span>
<span class="line-added">794 public:</span>
<span class="line-added">795     RenderFunctionDefinitionWriter(StringBuilder&amp; stringBuilder, Intrinsics&amp; intrinsics, TypeNamer&amp; typeNamer, HashMap&lt;AST::FunctionDeclaration*, MangledFunctionName&gt;&amp; functionMapping, MatchedRenderSemantics&amp;&amp; matchedSemantics, Layout&amp; layout)</span>
<span class="line-added">796         : FunctionDefinitionWriter(stringBuilder, intrinsics, typeNamer, functionMapping, layout)</span>
<span class="line-added">797         , m_matchedSemantics(WTFMove(matchedSemantics))</span>
798     {






799     }
800 
<span class="line-modified">801 private:</span>
<span class="line-modified">802     std::unique_ptr&lt;EntryPointScaffolding&gt; createEntryPointScaffolding(AST::FunctionDefinition&amp;) override;</span>














803 
<span class="line-modified">804     MatchedRenderSemantics m_matchedSemantics;</span>
<span class="line-modified">805 };</span>
<span class="line-modified">806 </span>
<span class="line-modified">807 std::unique_ptr&lt;EntryPointScaffolding&gt; RenderFunctionDefinitionWriter::createEntryPointScaffolding(AST::FunctionDefinition&amp; functionDefinition)</span>
<span class="line-modified">808 {</span>
<span class="line-modified">809     auto generateNextVariableName = [this]() -&gt; MangledVariableName {</span>
<span class="line-modified">810         return this-&gt;generateNextVariableName();</span>
<span class="line-modified">811     };</span>
<span class="line-modified">812     if (&amp;functionDefinition == m_matchedSemantics.vertexShader)</span>
<span class="line-added">813         return makeUnique&lt;VertexEntryPointScaffolding&gt;(functionDefinition, m_intrinsics, m_typeNamer, m_matchedSemantics.vertexShaderEntryPointItems, m_matchedSemantics.vertexShaderResourceMap, m_layout, WTFMove(generateNextVariableName), m_matchedSemantics.matchedVertexAttributes);</span>
<span class="line-added">814     if (&amp;functionDefinition == m_matchedSemantics.fragmentShader)</span>
<span class="line-added">815         return makeUnique&lt;FragmentEntryPointScaffolding&gt;(functionDefinition, m_intrinsics, m_typeNamer, m_matchedSemantics.fragmentShaderEntryPointItems, m_matchedSemantics.fragmentShaderResourceMap, m_layout, WTFMove(generateNextVariableName), m_matchedSemantics.matchedColorAttachments);</span>
<span class="line-added">816     return nullptr;</span>
<span class="line-added">817 }</span>
818 
<span class="line-modified">819 class ComputeFunctionDefinitionWriter final : public FunctionDefinitionWriter {</span>
<span class="line-added">820 public:</span>
<span class="line-added">821     ComputeFunctionDefinitionWriter(StringBuilder&amp; stringBuilder, Intrinsics&amp; intrinsics, TypeNamer&amp; typeNamer, HashMap&lt;AST::FunctionDeclaration*, MangledFunctionName&gt;&amp; functionMapping, MatchedComputeSemantics&amp;&amp; matchedSemantics, Layout&amp; layout)</span>
<span class="line-added">822         : FunctionDefinitionWriter(stringBuilder, intrinsics, typeNamer, functionMapping, layout)</span>
<span class="line-added">823         , m_matchedSemantics(WTFMove(matchedSemantics))</span>
824     {


825     }
826 
<span class="line-modified">827 private:</span>
<span class="line-modified">828     std::unique_ptr&lt;EntryPointScaffolding&gt; createEntryPointScaffolding(AST::FunctionDefinition&amp;) override;</span>
<span class="line-modified">829 </span>
<span class="line-modified">830     MatchedComputeSemantics m_matchedSemantics;</span>
<span class="line-modified">831 };</span>
<span class="line-modified">832 </span>
<span class="line-modified">833 std::unique_ptr&lt;EntryPointScaffolding&gt; ComputeFunctionDefinitionWriter::createEntryPointScaffolding(AST::FunctionDefinition&amp; functionDefinition)</span>
<span class="line-modified">834 {</span>
<span class="line-modified">835     auto generateNextVariableName = [this]() -&gt; MangledVariableName {</span>
<span class="line-modified">836         return this-&gt;generateNextVariableName();</span>
<span class="line-modified">837     };</span>
<span class="line-modified">838     if (&amp;functionDefinition == m_matchedSemantics.shader)</span>
<span class="line-modified">839         return makeUnique&lt;ComputeEntryPointScaffolding&gt;(functionDefinition, m_intrinsics, m_typeNamer, m_matchedSemantics.entryPointItems, m_matchedSemantics.resourceMap, m_layout, WTFMove(generateNextVariableName));</span>
<span class="line-modified">840     return nullptr;</span>
<span class="line-modified">841 }</span>
<span class="line-modified">842 </span>
<span class="line-modified">843 static HashMap&lt;AST::FunctionDeclaration*, MangledFunctionName&gt; generateMetalFunctionsMapping(Program&amp; program)</span>
<span class="line-added">844 {</span>
<span class="line-added">845     unsigned numFunctions = 0;</span>
<span class="line-added">846     HashMap&lt;AST::FunctionDeclaration*, MangledFunctionName&gt; functionMapping;</span>
<span class="line-added">847     for (auto&amp; functionDefinition : program.functionDefinitions()) {</span>
<span class="line-added">848         auto addResult = functionMapping.add(&amp;functionDefinition, MangledFunctionName { numFunctions++ });</span>
<span class="line-added">849         ASSERT_UNUSED(addResult, addResult.isNewEntry);</span>
850     }
851 
<span class="line-modified">852     return functionMapping;</span>
<span class="line-modified">853 }</span>
<span class="line-modified">854 </span>
<span class="line-modified">855 static void emitSharedMetalFunctions(StringBuilder&amp; stringBuilder, Program&amp; program, TypeNamer&amp; typeNamer, const HashSet&lt;AST::FunctionDeclaration*&gt;&amp; reachableFunctions, HashMap&lt;AST::FunctionDeclaration*, MangledFunctionName&gt;&amp; functionMapping)</span>
<span class="line-modified">856 {</span>
<span class="line-modified">857     for (auto&amp; functionDefinition : program.functionDefinitions()) {</span>
<span class="line-added">858         if (!functionDefinition-&gt;entryPointType() &amp;&amp; reachableFunctions.contains(&amp;functionDefinition))</span>
<span class="line-added">859             declareFunction(stringBuilder, functionDefinition, typeNamer, functionMapping);</span>
860     }
861 
<span class="line-modified">862     stringBuilder.append(&#39;\n&#39;);</span>
<span class="line-added">863 }</span>
<span class="line-added">864 </span>
<span class="line-added">865 class ReachableFunctionsGatherer final : public Visitor {</span>
<span class="line-added">866 public:</span>
<span class="line-added">867     void visit(AST::FunctionDeclaration&amp; functionDeclaration) override</span>
868     {
<span class="line-modified">869         auto result = m_reachableFunctions.add(&amp;functionDeclaration);</span>
<span class="line-modified">870         if (result.isNewEntry)</span>
<span class="line-modified">871             Visitor::visit(functionDeclaration);</span>














872     }
873 
<span class="line-modified">874     void visit(AST::CallExpression&amp; callExpression) override</span>
875     {
<span class="line-modified">876         Visitor::visit(callExpression);</span>
<span class="line-added">877         if (is&lt;AST::FunctionDefinition&gt;(callExpression.function()))</span>
<span class="line-added">878             checkErrorAndVisit(downcast&lt;AST::FunctionDefinition&gt;(callExpression.function()));</span>
<span class="line-added">879         else</span>
<span class="line-added">880             checkErrorAndVisit(downcast&lt;AST::NativeFunctionDeclaration&gt;(callExpression.function()));</span>
881     }
882 
<span class="line-added">883     HashSet&lt;AST::FunctionDeclaration*&gt; takeReachableFunctions() { return WTFMove(m_reachableFunctions); }</span>
<span class="line-added">884 </span>
885 private:
<span class="line-modified">886     HashSet&lt;AST::FunctionDeclaration*&gt; m_reachableFunctions;</span>







887 };
888 
<span class="line-modified">889 RenderMetalFunctionEntryPoints emitMetalFunctions(StringBuilder&amp; stringBuilder, Program&amp; program, TypeNamer&amp; typeNamer, MatchedRenderSemantics&amp;&amp; matchedSemantics, Layout&amp; layout)</span>
890 {
<span class="line-modified">891     auto&amp; vertexShaderEntryPoint = *matchedSemantics.vertexShader;</span>
<span class="line-added">892     auto* fragmentShaderEntryPoint = matchedSemantics.fragmentShader;</span>
893 
<span class="line-modified">894     ReachableFunctionsGatherer reachableFunctionsGatherer;</span>
<span class="line-modified">895     reachableFunctionsGatherer.Visitor::visit(vertexShaderEntryPoint);</span>
<span class="line-modified">896     if (fragmentShaderEntryPoint)</span>
<span class="line-modified">897         reachableFunctionsGatherer.Visitor::visit(*fragmentShaderEntryPoint);</span>
<span class="line-modified">898     auto reachableFunctions = reachableFunctionsGatherer.takeReachableFunctions();</span>
<span class="line-modified">899 </span>
<span class="line-added">900     auto functionMapping = generateMetalFunctionsMapping(program);</span>
<span class="line-added">901 </span>
<span class="line-added">902     emitSharedMetalFunctions(stringBuilder, program, typeNamer, reachableFunctions, functionMapping);</span>
<span class="line-added">903 </span>
<span class="line-added">904     RenderFunctionDefinitionWriter functionDefinitionWriter(stringBuilder, program.intrinsics(), typeNamer, functionMapping, WTFMove(matchedSemantics), layout);</span>
905     for (auto&amp; functionDefinition : program.functionDefinitions()) {
<span class="line-modified">906         if (reachableFunctions.contains(&amp;functionDefinition))</span>
<span class="line-modified">907             functionDefinitionWriter.visit(functionDefinition);</span>
908     }
909 
<span class="line-modified">910     return { functionMapping.get(&amp;vertexShaderEntryPoint), fragmentShaderEntryPoint ? functionMapping.get(fragmentShaderEntryPoint) : MangledFunctionName { 0 } };</span>
<span class="line-modified">911 }</span>








912 
<span class="line-modified">913 ComputeMetalFunctionEntryPoints emitMetalFunctions(StringBuilder&amp; stringBuilder, Program&amp; program, TypeNamer&amp; typeNamer, MatchedComputeSemantics&amp;&amp; matchedSemantics, Layout&amp; layout)</span>
<span class="line-added">914 {</span>
<span class="line-added">915     auto&amp; entryPoint = *matchedSemantics.shader;</span>
916 
<span class="line-modified">917     ReachableFunctionsGatherer reachableFunctionsGatherer;</span>
<span class="line-modified">918     reachableFunctionsGatherer.Visitor::visit(entryPoint);</span>
<span class="line-modified">919     auto reachableFunctions = reachableFunctionsGatherer.takeReachableFunctions();</span>
<span class="line-modified">920 </span>
<span class="line-modified">921     auto functionMapping = generateMetalFunctionsMapping(program);</span>
<span class="line-added">922     emitSharedMetalFunctions(stringBuilder, program, typeNamer, reachableFunctions, functionMapping);</span>
<span class="line-added">923 </span>
<span class="line-added">924     ComputeFunctionDefinitionWriter functionDefinitionWriter(stringBuilder, program.intrinsics(), typeNamer, functionMapping, WTFMove(matchedSemantics), layout);</span>
<span class="line-added">925     for (auto&amp; functionDefinition : program.functionDefinitions()) {</span>
<span class="line-added">926         if (reachableFunctions.contains(&amp;functionDefinition))</span>
927             functionDefinitionWriter.visit(functionDefinition);

928     }
929 
<span class="line-modified">930     return { functionMapping.get(&amp;entryPoint) };</span>
931 }
932 
933 } // namespace Metal
934 
935 } // namespace WHLSL
936 
937 } // namespace WebCore
938 
939 #endif
</pre>
</td>
</tr>
</table>
<center><a href="WHLSLEntryPointScaffolding.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="WHLSLFunctionWriter.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>