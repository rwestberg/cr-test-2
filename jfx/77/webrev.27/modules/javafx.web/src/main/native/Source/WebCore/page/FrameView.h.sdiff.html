<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/page/FrameView.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="FrameView.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="FrameViewLayoutContext.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/page/FrameView.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
  2    Copyright (C) 1997 Martin Jones (mjones@kde.org)
  3              (C) 1998 Waldo Bastian (bastian@kde.org)
  4              (C) 1998, 1999 Torben Weis (weis@kde.org)
  5              (C) 1999 Lars Knoll (knoll@kde.org)
  6              (C) 1999 Antti Koivisto (koivisto@kde.org)
<span class="line-modified">  7    Copyright (C) 2004-2017 Apple Inc. All rights reserved.</span>
  8 
  9    This library is free software; you can redistribute it and/or
 10    modify it under the terms of the GNU Library General Public
 11    License as published by the Free Software Foundation; either
 12    version 2 of the License, or (at your option) any later version.
 13 
 14    This library is distributed in the hope that it will be useful,
 15    but WITHOUT ANY WARRANTY; without even the implied warranty of
 16    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 17    Library General Public License for more details.
 18 
 19    You should have received a copy of the GNU Library General Public License
 20    along with this library; see the file COPYING.LIB.  If not, write to
 21    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 22    Boston, MA 02110-1301, USA.
 23 */
 24 
 25 #pragma once
 26 
 27 #include &quot;AdjustViewSizeOrNot.h&quot;
</pre>
<hr />
<pre>
 78 
 79     WEBCORE_EXPORT static Ref&lt;FrameView&gt; create(Frame&amp;);
 80     static Ref&lt;FrameView&gt; create(Frame&amp;, const IntSize&amp; initialSize);
 81 
 82     virtual ~FrameView();
 83 
 84     HostWindow* hostWindow() const final;
 85 
 86     WEBCORE_EXPORT void invalidateRect(const IntRect&amp;) final;
 87     void setFrameRect(const IntRect&amp;) final;
 88 
 89     bool scheduleAnimation() final;
 90 
 91     Frame&amp; frame() const { return m_frame; }
 92 
 93     WEBCORE_EXPORT RenderView* renderView() const;
 94 
 95     int mapFromLayoutToCSSUnits(LayoutUnit) const;
 96     LayoutUnit mapFromCSSToLayoutUnits(int) const;
 97 
<span class="line-removed"> 98     LayoutUnit marginWidth() const { return m_margins.width(); } // -1 means default</span>
<span class="line-removed"> 99     LayoutUnit marginHeight() const { return m_margins.height(); } // -1 means default</span>
<span class="line-removed">100     void setMarginWidth(LayoutUnit);</span>
<span class="line-removed">101     void setMarginHeight(LayoutUnit);</span>
<span class="line-removed">102 </span>
103     WEBCORE_EXPORT void setCanHaveScrollbars(bool) final;
104     WEBCORE_EXPORT void updateCanHaveScrollbars();
105 
106     Ref&lt;Scrollbar&gt; createScrollbar(ScrollbarOrientation) final;
107 
108     bool avoidScrollbarCreation() const final;
109 
110     void setContentsSize(const IntSize&amp;) final;
111     void updateContentsSize() final;
112 
113     const FrameViewLayoutContext&amp; layoutContext() const { return m_layoutContext; }
114     FrameViewLayoutContext&amp; layoutContext() { return m_layoutContext; }
115 
116     WEBCORE_EXPORT bool didFirstLayout() const;
117     void queuePostLayoutCallback(WTF::Function&lt;void ()&gt;&amp;&amp;);
118 
119     WEBCORE_EXPORT bool needsLayout() const;
120     WEBCORE_EXPORT void setNeedsLayoutAfterViewConfigurationChange();
121 
122     void setNeedsCompositingConfigurationUpdate();
123     void setNeedsCompositingGeometryUpdate();
124 
125     void setViewportConstrainedObjectsNeedLayout();
126 
127     WEBCORE_EXPORT bool renderedCharactersExceed(unsigned threshold);
128 
129     void scheduleSelectionUpdate();
130 
131 #if PLATFORM(IOS_FAMILY)
132     bool useCustomFixedPositionLayoutRect() const;
133     IntRect customFixedPositionLayoutRect() const { return m_customFixedPositionLayoutRect; }
134     WEBCORE_EXPORT void setCustomFixedPositionLayoutRect(const IntRect&amp;);
135     bool updateFixedPositionLayoutRect();
136 
137     IntSize customSizeForResizeEvent() const { return m_customSizeForResizeEvent; }
138     WEBCORE_EXPORT void setCustomSizeForResizeEvent(IntSize);
139 
<span class="line-modified">140     WEBCORE_EXPORT void setScrollVelocity(double horizontalVelocity, double verticalVelocity, double scaleChangeRate, MonotonicTime timestamp);</span>
141 #else
142     bool useCustomFixedPositionLayoutRect() const { return false; }
143 #endif
144 
145     void willRecalcStyle();
146     bool updateCompositingLayersAfterStyleChange();
147     void updateCompositingLayersAfterLayout();
148 
149     // Called when changes to the GraphicsLayer hierarchy have to be synchronized with
150     // content rendered via the normal painting path.
151     void setNeedsOneShotDrawingSynchronization();
152 
153     WEBCORE_EXPORT GraphicsLayer* graphicsLayerForPlatformWidget(PlatformWidget);
154     WEBCORE_EXPORT void scheduleLayerFlushAllowingThrottling();
155 
<span class="line-modified">156     WEBCORE_EXPORT TiledBacking* tiledBacking() const final;</span>
157 
158     ScrollingNodeID scrollingNodeID() const override;
159     ScrollableArea* scrollableAreaForScrollLayerID(uint64_t) const;
160     bool usesAsyncScrolling() const final;
161 
162     WEBCORE_EXPORT void enterCompositingMode();
163     WEBCORE_EXPORT bool isEnclosedInCompositingLayer() const;
164 
165     // Only used with accelerated compositing, but outside the #ifdef to make linkage easier.
166     // Returns true if the flush was completed.
167     WEBCORE_EXPORT bool flushCompositingStateIncludingSubframes();
168 
169     // Returns true when a paint with the PaintBehavior::FlattenCompositingLayers flag set gives
170     // a faithful representation of the content.
171     WEBCORE_EXPORT bool isSoftwareRenderable() const;
172 
173     void setIsInWindow(bool);
174 
175     void resetScrollbars();
176     void resetScrollbarsAndClearContentsSize();
</pre>
<hr />
<pre>
243     ScrollPosition unscaledMinimumScrollPosition() const;
244     ScrollPosition unscaledMaximumScrollPosition() const;
245 
246     IntPoint unscaledScrollOrigin() const;
247 
248     WEBCORE_EXPORT LayoutPoint minStableLayoutViewportOrigin() const;
249     WEBCORE_EXPORT LayoutPoint maxStableLayoutViewportOrigin() const;
250 
251     enum class TriggerLayoutOrNot {
252         No,
253         Yes
254     };
255     // This origin can be overridden by setLayoutViewportOverrideRect.
256     void setBaseLayoutViewportOrigin(LayoutPoint, TriggerLayoutOrNot = TriggerLayoutOrNot::Yes);
257     // This size can be overridden by setLayoutViewportOverrideRect.
258     WEBCORE_EXPORT LayoutSize baseLayoutViewportSize() const;
259 
260     // If set, overrides the default &quot;m_layoutViewportOrigin, size of initial containing block&quot; rect.
261     // Used with delegated scrolling (i.e. iOS).
262     WEBCORE_EXPORT void setLayoutViewportOverrideRect(Optional&lt;LayoutRect&gt;, TriggerLayoutOrNot = TriggerLayoutOrNot::Yes);

263 
264     WEBCORE_EXPORT void setVisualViewportOverrideRect(Optional&lt;LayoutRect&gt;);

265 
266     // These are in document coordinates, unaffected by page scale (but affected by zooming).
267     WEBCORE_EXPORT LayoutRect layoutViewportRect() const;
268     WEBCORE_EXPORT LayoutRect visualViewportRect() const;
269 
270     static LayoutRect visibleDocumentRect(const FloatRect&amp; visibleContentRect, float headerHeight, float footerHeight, const FloatSize&amp; totalContentsSize, float pageScaleFactor);
271 
272     // This is different than visibleContentRect() in that it ignores negative (or overly positive)
273     // offsets from rubber-banding, and it takes zooming into account.
274     LayoutRect viewportConstrainedVisibleContentRect() const;
275 


276     LayoutRect rectForFixedPositionLayout() const;
277 
278     void viewportContentsChanged();
279     WEBCORE_EXPORT void resumeVisibleImageAnimationsIncludingSubframes();
280 
281     String mediaType() const;
282     WEBCORE_EXPORT void setMediaType(const String&amp;);
283     void adjustMediaTypeForPrinting(bool printing);
284 
285     void setCannotBlitToWindow();
286     void setIsOverlapped(bool);
287     void setContentIsOpaque(bool);
288 
289     void addSlowRepaintObject(RenderElement&amp;);
290     void removeSlowRepaintObject(RenderElement&amp;);
291     bool hasSlowRepaintObject(const RenderElement&amp; renderer) const { return m_slowRepaintObjects &amp;&amp; m_slowRepaintObjects-&gt;contains(&amp;renderer); }
292     bool hasSlowRepaintObjects() const { return m_slowRepaintObjects &amp;&amp; m_slowRepaintObjects-&gt;size(); }
293 
294     // Includes fixed- and sticky-position objects.
295     typedef HashSet&lt;RenderLayerModelObject*&gt; ViewportConstrainedObjectSet;
296     void addViewportConstrainedObject(RenderLayerModelObject*);
297     void removeViewportConstrainedObject(RenderLayerModelObject*);
298     const ViewportConstrainedObjectSet* viewportConstrainedObjects() const { return m_viewportConstrainedObjects.get(); }
299     bool hasViewportConstrainedObjects() const { return m_viewportConstrainedObjects &amp;&amp; m_viewportConstrainedObjects-&gt;size() &gt; 0; }
300 
301     float frameScaleFactor() const;
302 
303     // Functions for querying the current scrolled position, negating the effects of overhang
304     // and adjusting for page scale.
305     LayoutPoint scrollPositionForFixedPosition() const;
306 
307     // Static function can be called from another thread.
<span class="line-modified">308     static LayoutPoint scrollPositionForFixedPosition(const LayoutRect&amp; visibleContentRect, const LayoutSize&amp; totalContentsSize, const LayoutPoint&amp; scrollPosition, const LayoutPoint&amp; scrollOrigin, float frameScaleFactor, bool fixedElementsLayoutRelativeToFrame, ScrollBehaviorForFixedElements, int headerHeight, int footerHeight);</span>
309 
310     WEBCORE_EXPORT static LayoutSize expandedLayoutViewportSize(const LayoutSize&amp; baseLayoutViewportSize, const LayoutSize&amp; documentSize, double heightExpansionFactor);
311 
312     enum class LayoutViewportConstraint { ConstrainedToDocumentRect, Unconstrained };
313     WEBCORE_EXPORT static LayoutRect computeUpdatedLayoutViewportRect(const LayoutRect&amp; layoutViewport, const LayoutRect&amp; documentRect, const LayoutSize&amp; unobscuredContentSize, const LayoutRect&amp; unobscuredContentRect, const LayoutSize&amp; baseLayoutViewportSize, const LayoutPoint&amp; stableLayoutViewportOriginMin, const LayoutPoint&amp; stableLayoutViewportOriginMax, LayoutViewportConstraint);
314 
315     WEBCORE_EXPORT static LayoutPoint computeLayoutViewportOrigin(const LayoutRect&amp; visualViewport, const LayoutPoint&amp; stableLayoutViewportOriginMin, const LayoutPoint&amp; stableLayoutViewportOriginMax, const LayoutRect&amp; layoutViewport, ScrollBehaviorForFixedElements);
316 
317     // These layers are positioned differently when there is a topContentInset, a header, or a footer. These value need to be computed
318     // on both the main thread and the scrolling thread.
319     static float yPositionForInsetClipLayer(const FloatPoint&amp; scrollPosition, float topContentInset);
320     WEBCORE_EXPORT static FloatPoint positionForRootContentLayer(const FloatPoint&amp; scrollPosition, const FloatPoint&amp; scrollOrigin, float topContentInset, float headerHeight);
321     WEBCORE_EXPORT FloatPoint positionForRootContentLayer() const;
322 
323     static float yPositionForHeaderLayer(const FloatPoint&amp; scrollPosition, float topContentInset);
324     static float yPositionForFooterLayer(const FloatPoint&amp; scrollPosition, float topContentInset, float totalContentsHeight, float footerHeight);
325 
326 #if PLATFORM(IOS_FAMILY)
327     WEBCORE_EXPORT LayoutRect viewportConstrainedObjectsRect() const;
328     // Static function can be called from another thread.
329     WEBCORE_EXPORT static LayoutRect rectForViewportConstrainedObjects(const LayoutRect&amp; visibleContentRect, const LayoutSize&amp; totalContentsSize, float frameScaleFactor, bool fixedElementsLayoutRelativeToFrame, ScrollBehaviorForFixedElements);
330 #endif
331 
<span class="line-modified">332     IntRect unobscuredContentRectExpandedByContentInsets() const;</span>
333 
334     bool fixedElementsLayoutRelativeToFrame() const;
335 
336     WEBCORE_EXPORT void disableLayerFlushThrottlingTemporarilyForInteraction();
337     bool speculativeTilingEnabled() const { return m_speculativeTilingEnabled; }
338     void loadProgressingStatusChanged();
339 
340     WEBCORE_EXPORT void updateControlTints();
341 
342     WEBCORE_EXPORT bool wasScrolledByUser() const;
343     WEBCORE_EXPORT void setWasScrolledByUser(bool);
344 
345     bool safeToPropagateScrollToParent() const;
346 
347     void addEmbeddedObjectToUpdate(RenderEmbeddedObject&amp;);
348     void removeEmbeddedObjectToUpdate(RenderEmbeddedObject&amp;);
349 
350     WEBCORE_EXPORT void paintContents(GraphicsContext&amp;, const IntRect&amp; dirtyRect, SecurityOriginPaintPolicy = SecurityOriginPaintPolicy::AnyOrigin) final;
351 
352     struct PaintingState {
</pre>
<hr />
<pre>
382     void paintOverhangAreas(GraphicsContext&amp;, const IntRect&amp; horizontalOverhangArea, const IntRect&amp; verticalOverhangArea, const IntRect&amp; dirtyRect) final;
383     void paintScrollCorner(GraphicsContext&amp;, const IntRect&amp; cornerRect) final;
384     void paintScrollbar(GraphicsContext&amp;, Scrollbar&amp;, const IntRect&amp;) final;
385 
386     WEBCORE_EXPORT Color documentBackgroundColor() const;
387 
388     bool isInChildFrameWithFrameFlattening() const;
389 
390     void startDisallowingLayout() { layoutContext().startDisallowingLayout(); }
391     void endDisallowingLayout() { layoutContext().endDisallowingLayout(); }
392 
393     static MonotonicTime currentPaintTimeStamp() { return sCurrentPaintTimeStamp; } // returns 0 if not painting
394 
395     WEBCORE_EXPORT void updateLayoutAndStyleIfNeededRecursive();
396 
397     void incrementVisuallyNonEmptyCharacterCount(const String&amp;);
398     void incrementVisuallyNonEmptyPixelCount(const IntSize&amp;);
399     void updateIsVisuallyNonEmpty();
400     void updateSignificantRenderedTextMilestoneIfNeeded();
401     bool isVisuallyNonEmpty() const { return m_isVisuallyNonEmpty; }
<span class="line-modified">402     WEBCORE_EXPORT void enableAutoSizeMode(bool enable, const IntSize&amp; minSize, const IntSize&amp; maxSize);</span>


403     WEBCORE_EXPORT void setAutoSizeFixedMinimumHeight(int);

404     IntSize autoSizingIntrinsicContentSize() const { return m_autoSizeContentSize; }
405 
406     WEBCORE_EXPORT void forceLayout(bool allowSubtreeLayout = false);
407     WEBCORE_EXPORT void forceLayoutForPagination(const FloatSize&amp; pageSize, const FloatSize&amp; originalPageSize, float maximumShrinkFactor, AdjustViewSizeOrNot);
408 
409     // FIXME: This method is retained because of embedded WebViews in AppKit.  When a WebView is embedded inside
410     // some enclosing view with auto-pagination, no call happens to resize the view.  The new pagination model
411     // needs the view to resize as a result of the breaks, but that means that the enclosing view has to potentially
412     // resize around that view.  Auto-pagination uses the bounds of the actual view that&#39;s being printed to determine
413     // the edges of the print operation, so the resize is necessary if the enclosing view&#39;s bounds depend on the
414     // web document&#39;s bounds.
415     //
416     // This is already a problem if the view needs to be a different size because of printer fonts or because of print stylesheets.
417     // Mail/Dictionary work around this problem by using the _layoutForPrinting SPI
418     // to at least get print stylesheets and printer fonts into play, but since WebKit doesn&#39;t know about the page offset or
419     // page size, it can&#39;t actually paginate correctly during _layoutForPrinting.
420     //
421     // We can eventually move Mail to a newer SPI that would let them opt in to the layout-time pagination model,
422     // but that doesn&#39;t solve the general problem of how other AppKit views could opt in to the better model.
423     //
</pre>
<hr />
<pre>
457     //    Similar to client coordinates, but affected by page zoom (but not page scale).
458     //
459 
460     // Methods to convert points and rects between the coordinate space of the renderer, and this view.
461     WEBCORE_EXPORT IntRect convertFromRendererToContainingView(const RenderElement*, const IntRect&amp;) const;
462     WEBCORE_EXPORT IntRect convertFromContainingViewToRenderer(const RenderElement*, const IntRect&amp;) const;
463     WEBCORE_EXPORT FloatRect convertFromContainingViewToRenderer(const RenderElement*, const FloatRect&amp;) const;
464     WEBCORE_EXPORT IntPoint convertFromRendererToContainingView(const RenderElement*, const IntPoint&amp;) const;
465     WEBCORE_EXPORT IntPoint convertFromContainingViewToRenderer(const RenderElement*, const IntPoint&amp;) const;
466 
467     // Override ScrollView methods to do point conversion via renderers, in order to take transforms into account.
468     IntRect convertToContainingView(const IntRect&amp;) const final;
469     IntRect convertFromContainingView(const IntRect&amp;) const final;
470     FloatRect convertFromContainingView(const FloatRect&amp;) const final;
471     IntPoint convertToContainingView(const IntPoint&amp;) const final;
472     IntPoint convertFromContainingView(const IntPoint&amp;) const final;
473 
474     float documentToAbsoluteScaleFactor(Optional&lt;float&gt; effectiveZoom = WTF::nullopt) const;
475     float absoluteToDocumentScaleFactor(Optional&lt;float&gt; effectiveZoom = WTF::nullopt) const;
476 
<span class="line-modified">477     FloatRect absoluteToDocumentRect(FloatRect, Optional&lt;float&gt; effectiveZoom = WTF::nullopt) const;</span>
<span class="line-modified">478     FloatPoint absoluteToDocumentPoint(FloatPoint, Optional&lt;float&gt; effectiveZoom = WTF::nullopt) const;</span>
479 
480     FloatRect absoluteToClientRect(FloatRect, Optional&lt;float&gt; effectiveZoom = WTF::nullopt) const;
481 
482     FloatSize documentToClientOffset() const;
<span class="line-modified">483     FloatRect documentToClientRect(FloatRect) const;</span>
484     FloatPoint documentToClientPoint(FloatPoint) const;
485     WEBCORE_EXPORT FloatRect clientToDocumentRect(FloatRect) const;
486     WEBCORE_EXPORT FloatPoint clientToDocumentPoint(FloatPoint) const;
487 

488     FloatPoint layoutViewportToAbsolutePoint(FloatPoint) const;
489 



490     // Unlike client coordinates, layout viewport coordinates are affected by page zoom.
491     WEBCORE_EXPORT FloatRect clientToLayoutViewportRect(FloatRect) const;
492     WEBCORE_EXPORT FloatPoint clientToLayoutViewportPoint(FloatPoint) const;
493 
494     bool isFrameViewScrollCorner(const RenderScrollbarPart&amp; scrollCorner) const { return m_scrollCorner.get() == &amp;scrollCorner; }
495 
496     // isScrollable() takes an optional Scrollability parameter that allows the caller to define what they mean by &#39;scrollable.&#39;
497     // Most callers are interested in the default value, Scrollability::Scrollable, which means that there is actually content
498     // to scroll to, and a scrollbar that will allow you to access it. In some cases, callers want to know if the FrameView is allowed
499     // to rubber-band, which the main frame might be allowed to do even if there is no content to scroll to. In that case,
500     // callers use Scrollability::ScrollableOrRubberbandable.
501     enum class Scrollability { Scrollable, ScrollableOrRubberbandable };
502     WEBCORE_EXPORT bool isScrollable(Scrollability definitionOfScrollable = Scrollability::Scrollable);
503 
504     bool isScrollableOrRubberbandable() final;
505     bool hasScrollableOrRubberbandableAncestor() final;
506 
507     enum ScrollbarModesCalculationStrategy { RulesFromWebContentOnly, AnyRule };
508     void calculateScrollbarModesForLayout(ScrollbarMode&amp; hMode, ScrollbarMode&amp; vMode, ScrollbarModesCalculationStrategy = AnyRule);
509 
</pre>
<hr />
<pre>
538 
539     WEBCORE_EXPORT void addChild(Widget&amp;) final;
540     WEBCORE_EXPORT void removeChild(Widget&amp;) final;
541 
542     // This function exists for ports that need to handle wheel events manually.
543     // On Mac WebKit1 the underlying NSScrollView just does the scrolling, but on most other platforms
544     // we need this function in order to do the scroll ourselves.
545     bool wheelEvent(const PlatformWheelEvent&amp;);
546 
547     WEBCORE_EXPORT void setScrollingPerformanceLoggingEnabled(bool);
548 
549     // Page and FrameView both store a Pagination value. Page::pagination() is set only by API,
550     // and FrameView::pagination() is set only by CSS. Page::pagination() will affect all
551     // FrameViews in the page cache, but FrameView::pagination() only affects the current
552     // FrameView. FrameView::pagination() will return m_pagination if it has been set. Otherwise,
553     // it will return Page::pagination() since currently there are no callers that need to
554     // distinguish between the two.
555     const Pagination&amp; pagination() const;
556     void setPagination(const Pagination&amp;);
557 
<span class="line-removed">558     bool inProgrammaticScroll() const final { return m_inProgrammaticScroll; }</span>
<span class="line-removed">559     void setInProgrammaticScroll(bool programmaticScroll) { m_inProgrammaticScroll = programmaticScroll; }</span>
<span class="line-removed">560 </span>
561 #if ENABLE(CSS_DEVICE_ADAPTATION)
562     IntSize initialViewportSize() const { return m_initialViewportSize; }
563     void setInitialViewportSize(const IntSize&amp; size) { m_initialViewportSize = size; }
564 #endif
565 
566     bool isActive() const final;
567     bool forceUpdateScrollbarsOnMainThreadForPerformanceTesting() const final;
568 
569 #if ENABLE(RUBBER_BANDING)
570     WEBCORE_EXPORT GraphicsLayer* setWantsLayerForTopOverHangArea(bool) const;
571     WEBCORE_EXPORT GraphicsLayer* setWantsLayerForBottomOverHangArea(bool) const;
572 #endif
573 
574     // This function &quot;smears&quot; the &quot;position:fixed&quot; uninflatedBounds for scrolling, returning a rect that is the union of
575     // all possible locations of the given rect under page scrolling.
576     LayoutRect fixedScrollableAreaBoundsInflatedForScrolling(const LayoutRect&amp; uninflatedBounds) const;
577 
578     LayoutPoint scrollPositionRespectingCustomFixedPosition() const;
579 
580     WEBCORE_EXPORT int headerHeight() const final;
581     WEBCORE_EXPORT int footerHeight() const final;
582 
583     WEBCORE_EXPORT float topContentInset(TopContentInsetType = TopContentInsetType::WebCoreContentInset) const final;
584     void topContentInsetDidChange(float newTopContentInset);
585 
586     void topContentDirectionDidChange();
587 
588     WEBCORE_EXPORT void willStartLiveResize() final;
589     WEBCORE_EXPORT void willEndLiveResize() final;
590 
591     WEBCORE_EXPORT void availableContentSizeChanged(AvailableSizeChangeReason) final;
592 
593     void updateTiledBackingAdaptiveSizing();
594     TiledBacking::Scrollability computeScrollability() const;
595 
<span class="line-removed">596 #if PLATFORM(IOS_FAMILY)</span>
<span class="line-removed">597     WEBCORE_EXPORT void didUpdateViewportOverrideRects();</span>
<span class="line-removed">598 #endif</span>
<span class="line-removed">599 </span>
600     void addPaintPendingMilestones(OptionSet&lt;LayoutMilestone&gt;);
601     void firePaintRelatedMilestonesIfNeeded();
602     void fireLayoutRelatedMilestonesIfNeeded();
603     OptionSet&lt;LayoutMilestone&gt; milestonesPendingPaint() const { return m_milestonesPendingPaint; }
604 
605     bool visualUpdatesAllowedByClient() const { return m_visualUpdatesAllowedByClient; }
606     WEBCORE_EXPORT void setVisualUpdatesAllowedByClient(bool);
607 
608     WEBCORE_EXPORT void setScrollPinningBehavior(ScrollPinningBehavior);
609 
610     ScrollBehaviorForFixedElements scrollBehaviorForFixedElements() const;
611 
612     bool hasFlippedBlockRenderers() const { return m_hasFlippedBlockRenderers; }
613     void setHasFlippedBlockRenderers(bool b) { m_hasFlippedBlockRenderers = b; }
614 
615     void updateWidgetPositions();
616     void scheduleUpdateWidgetPositions();
617 
618     void didAddWidgetToRenderTree(Widget&amp;);
619     void willRemoveWidgetFromRenderTree(Widget&amp;);
</pre>
<hr />
<pre>
724     void delegatesScrollingDidChange() final;
725 
726     // ScrollableArea interface
727     void invalidateScrollbarRect(Scrollbar&amp;, const IntRect&amp;) final;
728     void scrollTo(const ScrollPosition&amp;) final;
729     void setVisibleScrollerThumbRect(const IntRect&amp;) final;
730     ScrollableArea* enclosingScrollableArea() const final;
731     IntRect scrollableAreaBoundingBox(bool* = nullptr) const final;
732     bool scrollAnimatorEnabled() const final;
733     GraphicsLayer* layerForScrollCorner() const final;
734 #if ENABLE(RUBBER_BANDING)
735     GraphicsLayer* layerForOverhangAreas() const final;
736 #endif
737     void contentsResized() final;
738 
739 #if PLATFORM(IOS_FAMILY)
740     void unobscuredContentSizeChanged() final;
741 #endif
742 
743 #if ENABLE(DARK_MODE_CSS)
<span class="line-modified">744     RenderObject* rendererForSupportedColorSchemes() const;</span>
745 #endif
746 
747     bool usesCompositedScrolling() const final;
748     bool usesMockScrollAnimator() const final;
749     void logMockScrollAnimatorMessage(const String&amp;) const final;
750 
751     // Override scrollbar notifications to update the AXObject cache.
752     void didAddScrollbar(Scrollbar*, ScrollbarOrientation) final;
753     void willRemoveScrollbar(Scrollbar*, ScrollbarOrientation) final;
754 
755     IntSize sizeForResizeEvent() const;
756     void sendResizeEventIfNeeded();
757 
758     void adjustScrollbarsForLayout(bool firstLayout);
759 
760     void handleDeferredScrollbarsUpdateAfterDirectionChange();
761 
762     void updateScrollableAreaSet();
763     void updateLayoutViewport();
764 
</pre>
<hr />
<pre>
773 
774     void updateWidgetPositionsTimerFired();
775 
776     void scrollToAnchor();
777     void scrollPositionChanged(const ScrollPosition&amp; oldPosition, const ScrollPosition&amp; newPosition);
778     void scrollableAreaSetChanged();
779     void sendScrollEvent();
780     void resetScrollAnchor();
781 
782     bool hasCustomScrollbars() const;
783 
784     void updateScrollCorner() final;
785 
786     FrameView* parentFrameView() const;
787 
788     bool frameFlatteningEnabled() const;
789     bool isFrameFlatteningValidForThisFrame() const;
790 
791     void markRootOrBodyRendererDirty() const;
792 
<span class="line-removed">793     bool qualifiesAsVisuallyNonEmpty() const;</span>
794     bool qualifiesAsSignificantRenderedText() const;
795     void updateHasReachedSignificantRenderedTextThreshold();
796 
797     bool isViewForDocumentInFrame() const;
798 
799     AXObjectCache* axObjectCache() const;
800     void notifyWidgetsInAllFrames(WidgetNotification);
801     void removeFromAXObjectCache();
802     void notifyWidgets(WidgetNotification);
803 
804     RenderElement* viewportRenderer() const;
805 
806     void willDoLayout(WeakPtr&lt;RenderElement&gt; layoutRoot);
807     void didLayout(WeakPtr&lt;RenderElement&gt; layoutRoot);
808 
809     struct OverrideViewportSize {
810         Optional&lt;int&gt; width;
811         Optional&lt;int&gt; height;
812 
813         bool operator==(const OverrideViewportSize&amp; rhs) const { return rhs.width == width &amp;&amp; rhs.height == height; }
</pre>
<hr />
<pre>
821 
822     HashSet&lt;Widget*&gt; m_widgetsInRenderTree;
823     std::unique_ptr&lt;ListHashSet&lt;RenderEmbeddedObject*&gt;&gt; m_embeddedObjectsToUpdate;
824     std::unique_ptr&lt;HashSet&lt;const RenderElement*&gt;&gt; m_slowRepaintObjects;
825 
826     RefPtr&lt;ContainerNode&gt; m_maintainScrollPositionAnchor;
827     RefPtr&lt;Node&gt; m_nodeToDraw;
828 
829     // Renderer to hold our custom scroll corner.
830     RenderPtr&lt;RenderScrollbarPart&gt; m_scrollCorner;
831 
832     Timer m_updateEmbeddedObjectsTimer;
833     Timer m_updateWidgetPositionsTimer;
834     Timer m_delayedScrollEventTimer;
835     Timer m_delayedScrollToFocusedElementTimer;
836     Timer m_speculativeTilingEnableTimer;
837 
838     MonotonicTime m_lastPaintTime;
839 
840     LayoutSize m_size;
<span class="line-removed">841     LayoutSize m_margins;</span>
842 
843     Color m_baseBackgroundColor { Color::white };
844     IntSize m_lastViewportSize;
845 
846     String m_mediaType { &quot;screen&quot;_s };
847     String m_mediaTypeWhenNotPrinting;
848 
849     Vector&lt;FloatRect&gt; m_trackedRepaintRects;
850 
851     IntRect* m_cachedWindowClipRect { nullptr };
852     Vector&lt;WTF::Function&lt;void ()&gt;&gt; m_postLayoutCallbackQueue;
853 
854     LayoutPoint m_layoutViewportOrigin;
855     Optional&lt;LayoutRect&gt; m_layoutViewportOverrideRect;
856     Optional&lt;LayoutRect&gt; m_visualViewportOverrideRect; // Used when the iOS keyboard is showing.
857 
858     Optional&lt;FloatRect&gt; m_viewExposedRect;
859 
860     OptionSet&lt;PaintBehavior&gt; m_paintBehavior;
861 
862     float m_lastZoomFactor { 1 };
863     unsigned m_visuallyNonEmptyCharacterCount { 0 };
864     unsigned m_visuallyNonEmptyPixelCount { 0 };
865     unsigned m_textRendererCountForVisuallyNonEmptyCharacters { 0 };
866     int m_headerHeight { 0 };
867     int m_footerHeight { 0 };
868 
869 #if PLATFORM(IOS_FAMILY)
870     bool m_useCustomFixedPositionLayoutRect { false };
871     bool m_useCustomSizeForResizeEvent { false };
872 
873     IntRect m_customFixedPositionLayoutRect;
874     IntSize m_customSizeForResizeEvent;
875 #endif
876 
877     Optional&lt;OverrideViewportSize&gt; m_overrideViewportSize;
878 
<span class="line-modified">879     // The lower bound on the size when autosizing.</span>
<span class="line-modified">880     IntSize m_minAutoSize;</span>
<span class="line-removed">881     // The upper bound on the size when autosizing.</span>
<span class="line-removed">882     IntSize m_maxAutoSize;</span>
883     // The fixed height to resize the view to after autosizing is complete.
884     int m_autoSizeFixedMinimumHeight { 0 };
885     // The intrinsic content size decided by autosizing.
886     IntSize m_autoSizeContentSize;
887 
888     std::unique_ptr&lt;ScrollableAreaSet&gt; m_scrollableAreas;
889     std::unique_ptr&lt;ViewportConstrainedObjectSet&gt; m_viewportConstrainedObjects;
890 
891     OptionSet&lt;LayoutMilestone&gt; m_milestonesPendingPaint;
892 
893     static const unsigned visualCharacterThreshold = 200;
894     static const unsigned visualPixelThreshold = 32 * 32;
895 
896 #if ENABLE(CSS_DEVICE_ADAPTATION)
897     // Size of viewport before any UA or author styles have overridden
898     // the viewport given by the window or viewing area of the UA.
899     IntSize m_initialViewportSize;
900 #endif
901 
902     Pagination m_pagination;
</pre>
<hr />
<pre>
906     ScrollPinningBehavior m_scrollPinningBehavior { DoNotPin };
907     SelectionRevealMode m_selectionRevealModeForFocusedElement { SelectionRevealMode::DoNotReveal };
908 
909     bool m_shouldUpdateWhileOffscreen { true };
910     bool m_overflowStatusDirty { true };
911     bool m_horizontalOverflow { false };
912     bool m_verticalOverflow { false };
913     bool m_canHaveScrollbars { true };
914     bool m_cannotBlitToWindow { false };
915     bool m_isOverlapped { false };
916     bool m_contentIsOpaque { false };
917     bool m_firstLayoutCallbackPending { false };
918 
919     bool m_isTransparent { false };
920 #if ENABLE(DARK_MODE_CSS)
921     bool m_usesDarkAppearance { false };
922 #endif
923 
924     bool m_isTrackingRepaints { false }; // Used for testing.
925     bool m_wasScrolledByUser { false };
<span class="line-removed">926     bool m_inProgrammaticScroll { false };</span>
927     bool m_shouldScrollToFocusedElement { false };
928 
929     bool m_isPainting { false };
930 
931     bool m_isVisuallyNonEmpty { false };
932 
933     bool m_renderedSignificantAmountOfText { false };
934     bool m_hasReachedSignificantRenderedTextThreshold { false };
935 
936     bool m_needsDeferredScrollbarsUpdate { false };
937     bool m_speculativeTilingEnabled { false };
938     bool m_visualUpdatesAllowedByClient { true };
939     bool m_hasFlippedBlockRenderers { false };
940     bool m_speculativeTilingDelayDisabledForTesting { false };
941 
942     // If true, automatically resize the frame view around its content.
943     bool m_shouldAutoSize { false };
944     bool m_inAutoSize { false };
945     // True if autosize has been run since m_shouldAutoSize was set.
946     bool m_didRunAutosize { false };
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
  2    Copyright (C) 1997 Martin Jones (mjones@kde.org)
  3              (C) 1998 Waldo Bastian (bastian@kde.org)
  4              (C) 1998, 1999 Torben Weis (weis@kde.org)
  5              (C) 1999 Lars Knoll (knoll@kde.org)
  6              (C) 1999 Antti Koivisto (koivisto@kde.org)
<span class="line-modified">  7    Copyright (C) 2004-2019 Apple Inc. All rights reserved.</span>
  8 
  9    This library is free software; you can redistribute it and/or
 10    modify it under the terms of the GNU Library General Public
 11    License as published by the Free Software Foundation; either
 12    version 2 of the License, or (at your option) any later version.
 13 
 14    This library is distributed in the hope that it will be useful,
 15    but WITHOUT ANY WARRANTY; without even the implied warranty of
 16    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 17    Library General Public License for more details.
 18 
 19    You should have received a copy of the GNU Library General Public License
 20    along with this library; see the file COPYING.LIB.  If not, write to
 21    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 22    Boston, MA 02110-1301, USA.
 23 */
 24 
 25 #pragma once
 26 
 27 #include &quot;AdjustViewSizeOrNot.h&quot;
</pre>
<hr />
<pre>
 78 
 79     WEBCORE_EXPORT static Ref&lt;FrameView&gt; create(Frame&amp;);
 80     static Ref&lt;FrameView&gt; create(Frame&amp;, const IntSize&amp; initialSize);
 81 
 82     virtual ~FrameView();
 83 
 84     HostWindow* hostWindow() const final;
 85 
 86     WEBCORE_EXPORT void invalidateRect(const IntRect&amp;) final;
 87     void setFrameRect(const IntRect&amp;) final;
 88 
 89     bool scheduleAnimation() final;
 90 
 91     Frame&amp; frame() const { return m_frame; }
 92 
 93     WEBCORE_EXPORT RenderView* renderView() const;
 94 
 95     int mapFromLayoutToCSSUnits(LayoutUnit) const;
 96     LayoutUnit mapFromCSSToLayoutUnits(int) const;
 97 





 98     WEBCORE_EXPORT void setCanHaveScrollbars(bool) final;
 99     WEBCORE_EXPORT void updateCanHaveScrollbars();
100 
101     Ref&lt;Scrollbar&gt; createScrollbar(ScrollbarOrientation) final;
102 
103     bool avoidScrollbarCreation() const final;
104 
105     void setContentsSize(const IntSize&amp;) final;
106     void updateContentsSize() final;
107 
108     const FrameViewLayoutContext&amp; layoutContext() const { return m_layoutContext; }
109     FrameViewLayoutContext&amp; layoutContext() { return m_layoutContext; }
110 
111     WEBCORE_EXPORT bool didFirstLayout() const;
112     void queuePostLayoutCallback(WTF::Function&lt;void ()&gt;&amp;&amp;);
113 
114     WEBCORE_EXPORT bool needsLayout() const;
115     WEBCORE_EXPORT void setNeedsLayoutAfterViewConfigurationChange();
116 
117     void setNeedsCompositingConfigurationUpdate();
118     void setNeedsCompositingGeometryUpdate();
119 
120     void setViewportConstrainedObjectsNeedLayout();
121 
122     WEBCORE_EXPORT bool renderedCharactersExceed(unsigned threshold);
123 
124     void scheduleSelectionUpdate();
125 
126 #if PLATFORM(IOS_FAMILY)
127     bool useCustomFixedPositionLayoutRect() const;
128     IntRect customFixedPositionLayoutRect() const { return m_customFixedPositionLayoutRect; }
129     WEBCORE_EXPORT void setCustomFixedPositionLayoutRect(const IntRect&amp;);
130     bool updateFixedPositionLayoutRect();
131 
132     IntSize customSizeForResizeEvent() const { return m_customSizeForResizeEvent; }
133     WEBCORE_EXPORT void setCustomSizeForResizeEvent(IntSize);
134 
<span class="line-modified">135     WEBCORE_EXPORT void setScrollVelocity(const VelocityData&amp;);</span>
136 #else
137     bool useCustomFixedPositionLayoutRect() const { return false; }
138 #endif
139 
140     void willRecalcStyle();
141     bool updateCompositingLayersAfterStyleChange();
142     void updateCompositingLayersAfterLayout();
143 
144     // Called when changes to the GraphicsLayer hierarchy have to be synchronized with
145     // content rendered via the normal painting path.
146     void setNeedsOneShotDrawingSynchronization();
147 
148     WEBCORE_EXPORT GraphicsLayer* graphicsLayerForPlatformWidget(PlatformWidget);
149     WEBCORE_EXPORT void scheduleLayerFlushAllowingThrottling();
150 
<span class="line-modified">151     WEBCORE_EXPORT TiledBacking* tiledBacking() const;</span>
152 
153     ScrollingNodeID scrollingNodeID() const override;
154     ScrollableArea* scrollableAreaForScrollLayerID(uint64_t) const;
155     bool usesAsyncScrolling() const final;
156 
157     WEBCORE_EXPORT void enterCompositingMode();
158     WEBCORE_EXPORT bool isEnclosedInCompositingLayer() const;
159 
160     // Only used with accelerated compositing, but outside the #ifdef to make linkage easier.
161     // Returns true if the flush was completed.
162     WEBCORE_EXPORT bool flushCompositingStateIncludingSubframes();
163 
164     // Returns true when a paint with the PaintBehavior::FlattenCompositingLayers flag set gives
165     // a faithful representation of the content.
166     WEBCORE_EXPORT bool isSoftwareRenderable() const;
167 
168     void setIsInWindow(bool);
169 
170     void resetScrollbars();
171     void resetScrollbarsAndClearContentsSize();
</pre>
<hr />
<pre>
238     ScrollPosition unscaledMinimumScrollPosition() const;
239     ScrollPosition unscaledMaximumScrollPosition() const;
240 
241     IntPoint unscaledScrollOrigin() const;
242 
243     WEBCORE_EXPORT LayoutPoint minStableLayoutViewportOrigin() const;
244     WEBCORE_EXPORT LayoutPoint maxStableLayoutViewportOrigin() const;
245 
246     enum class TriggerLayoutOrNot {
247         No,
248         Yes
249     };
250     // This origin can be overridden by setLayoutViewportOverrideRect.
251     void setBaseLayoutViewportOrigin(LayoutPoint, TriggerLayoutOrNot = TriggerLayoutOrNot::Yes);
252     // This size can be overridden by setLayoutViewportOverrideRect.
253     WEBCORE_EXPORT LayoutSize baseLayoutViewportSize() const;
254 
255     // If set, overrides the default &quot;m_layoutViewportOrigin, size of initial containing block&quot; rect.
256     // Used with delegated scrolling (i.e. iOS).
257     WEBCORE_EXPORT void setLayoutViewportOverrideRect(Optional&lt;LayoutRect&gt;, TriggerLayoutOrNot = TriggerLayoutOrNot::Yes);
<span class="line-added">258     Optional&lt;LayoutRect&gt; layoutViewportOverrideRect() const { return m_layoutViewportOverrideRect; }</span>
259 
260     WEBCORE_EXPORT void setVisualViewportOverrideRect(Optional&lt;LayoutRect&gt;);
<span class="line-added">261     Optional&lt;LayoutRect&gt; visualViewportOverrideRect() const { return m_visualViewportOverrideRect; }</span>
262 
263     // These are in document coordinates, unaffected by page scale (but affected by zooming).
264     WEBCORE_EXPORT LayoutRect layoutViewportRect() const;
265     WEBCORE_EXPORT LayoutRect visualViewportRect() const;
266 
267     static LayoutRect visibleDocumentRect(const FloatRect&amp; visibleContentRect, float headerHeight, float footerHeight, const FloatSize&amp; totalContentsSize, float pageScaleFactor);
268 
269     // This is different than visibleContentRect() in that it ignores negative (or overly positive)
270     // offsets from rubber-banding, and it takes zooming into account.
271     LayoutRect viewportConstrainedVisibleContentRect() const;
272 
<span class="line-added">273     WEBCORE_EXPORT void layoutOrVisualViewportChanged();</span>
<span class="line-added">274 </span>
275     LayoutRect rectForFixedPositionLayout() const;
276 
277     void viewportContentsChanged();
278     WEBCORE_EXPORT void resumeVisibleImageAnimationsIncludingSubframes();
279 
280     String mediaType() const;
281     WEBCORE_EXPORT void setMediaType(const String&amp;);
282     void adjustMediaTypeForPrinting(bool printing);
283 
284     void setCannotBlitToWindow();
285     void setIsOverlapped(bool);
286     void setContentIsOpaque(bool);
287 
288     void addSlowRepaintObject(RenderElement&amp;);
289     void removeSlowRepaintObject(RenderElement&amp;);
290     bool hasSlowRepaintObject(const RenderElement&amp; renderer) const { return m_slowRepaintObjects &amp;&amp; m_slowRepaintObjects-&gt;contains(&amp;renderer); }
291     bool hasSlowRepaintObjects() const { return m_slowRepaintObjects &amp;&amp; m_slowRepaintObjects-&gt;size(); }
292 
293     // Includes fixed- and sticky-position objects.
294     typedef HashSet&lt;RenderLayerModelObject*&gt; ViewportConstrainedObjectSet;
295     void addViewportConstrainedObject(RenderLayerModelObject*);
296     void removeViewportConstrainedObject(RenderLayerModelObject*);
297     const ViewportConstrainedObjectSet* viewportConstrainedObjects() const { return m_viewportConstrainedObjects.get(); }
298     bool hasViewportConstrainedObjects() const { return m_viewportConstrainedObjects &amp;&amp; m_viewportConstrainedObjects-&gt;size() &gt; 0; }
299 
300     float frameScaleFactor() const;
301 
302     // Functions for querying the current scrolled position, negating the effects of overhang
303     // and adjusting for page scale.
304     LayoutPoint scrollPositionForFixedPosition() const;
305 
306     // Static function can be called from another thread.
<span class="line-modified">307     WEBCORE_EXPORT static LayoutPoint scrollPositionForFixedPosition(const LayoutRect&amp; visibleContentRect, const LayoutSize&amp; totalContentsSize, const LayoutPoint&amp; scrollPosition, const LayoutPoint&amp; scrollOrigin, float frameScaleFactor, bool fixedElementsLayoutRelativeToFrame, ScrollBehaviorForFixedElements, int headerHeight, int footerHeight);</span>
308 
309     WEBCORE_EXPORT static LayoutSize expandedLayoutViewportSize(const LayoutSize&amp; baseLayoutViewportSize, const LayoutSize&amp; documentSize, double heightExpansionFactor);
310 
311     enum class LayoutViewportConstraint { ConstrainedToDocumentRect, Unconstrained };
312     WEBCORE_EXPORT static LayoutRect computeUpdatedLayoutViewportRect(const LayoutRect&amp; layoutViewport, const LayoutRect&amp; documentRect, const LayoutSize&amp; unobscuredContentSize, const LayoutRect&amp; unobscuredContentRect, const LayoutSize&amp; baseLayoutViewportSize, const LayoutPoint&amp; stableLayoutViewportOriginMin, const LayoutPoint&amp; stableLayoutViewportOriginMax, LayoutViewportConstraint);
313 
314     WEBCORE_EXPORT static LayoutPoint computeLayoutViewportOrigin(const LayoutRect&amp; visualViewport, const LayoutPoint&amp; stableLayoutViewportOriginMin, const LayoutPoint&amp; stableLayoutViewportOriginMax, const LayoutRect&amp; layoutViewport, ScrollBehaviorForFixedElements);
315 
316     // These layers are positioned differently when there is a topContentInset, a header, or a footer. These value need to be computed
317     // on both the main thread and the scrolling thread.
318     static float yPositionForInsetClipLayer(const FloatPoint&amp; scrollPosition, float topContentInset);
319     WEBCORE_EXPORT static FloatPoint positionForRootContentLayer(const FloatPoint&amp; scrollPosition, const FloatPoint&amp; scrollOrigin, float topContentInset, float headerHeight);
320     WEBCORE_EXPORT FloatPoint positionForRootContentLayer() const;
321 
322     static float yPositionForHeaderLayer(const FloatPoint&amp; scrollPosition, float topContentInset);
323     static float yPositionForFooterLayer(const FloatPoint&amp; scrollPosition, float topContentInset, float totalContentsHeight, float footerHeight);
324 
325 #if PLATFORM(IOS_FAMILY)
326     WEBCORE_EXPORT LayoutRect viewportConstrainedObjectsRect() const;
327     // Static function can be called from another thread.
328     WEBCORE_EXPORT static LayoutRect rectForViewportConstrainedObjects(const LayoutRect&amp; visibleContentRect, const LayoutSize&amp; totalContentsSize, float frameScaleFactor, bool fixedElementsLayoutRelativeToFrame, ScrollBehaviorForFixedElements);
329 #endif
330 
<span class="line-modified">331     IntRect viewRectExpandedByContentInsets() const;</span>
332 
333     bool fixedElementsLayoutRelativeToFrame() const;
334 
335     WEBCORE_EXPORT void disableLayerFlushThrottlingTemporarilyForInteraction();
336     bool speculativeTilingEnabled() const { return m_speculativeTilingEnabled; }
337     void loadProgressingStatusChanged();
338 
339     WEBCORE_EXPORT void updateControlTints();
340 
341     WEBCORE_EXPORT bool wasScrolledByUser() const;
342     WEBCORE_EXPORT void setWasScrolledByUser(bool);
343 
344     bool safeToPropagateScrollToParent() const;
345 
346     void addEmbeddedObjectToUpdate(RenderEmbeddedObject&amp;);
347     void removeEmbeddedObjectToUpdate(RenderEmbeddedObject&amp;);
348 
349     WEBCORE_EXPORT void paintContents(GraphicsContext&amp;, const IntRect&amp; dirtyRect, SecurityOriginPaintPolicy = SecurityOriginPaintPolicy::AnyOrigin) final;
350 
351     struct PaintingState {
</pre>
<hr />
<pre>
381     void paintOverhangAreas(GraphicsContext&amp;, const IntRect&amp; horizontalOverhangArea, const IntRect&amp; verticalOverhangArea, const IntRect&amp; dirtyRect) final;
382     void paintScrollCorner(GraphicsContext&amp;, const IntRect&amp; cornerRect) final;
383     void paintScrollbar(GraphicsContext&amp;, Scrollbar&amp;, const IntRect&amp;) final;
384 
385     WEBCORE_EXPORT Color documentBackgroundColor() const;
386 
387     bool isInChildFrameWithFrameFlattening() const;
388 
389     void startDisallowingLayout() { layoutContext().startDisallowingLayout(); }
390     void endDisallowingLayout() { layoutContext().endDisallowingLayout(); }
391 
392     static MonotonicTime currentPaintTimeStamp() { return sCurrentPaintTimeStamp; } // returns 0 if not painting
393 
394     WEBCORE_EXPORT void updateLayoutAndStyleIfNeededRecursive();
395 
396     void incrementVisuallyNonEmptyCharacterCount(const String&amp;);
397     void incrementVisuallyNonEmptyPixelCount(const IntSize&amp;);
398     void updateIsVisuallyNonEmpty();
399     void updateSignificantRenderedTextMilestoneIfNeeded();
400     bool isVisuallyNonEmpty() const { return m_isVisuallyNonEmpty; }
<span class="line-modified">401     WEBCORE_EXPORT bool qualifiesAsVisuallyNonEmpty() const;</span>
<span class="line-added">402 </span>
<span class="line-added">403     WEBCORE_EXPORT void enableAutoSizeMode(bool enable, const IntSize&amp; minSize);</span>
404     WEBCORE_EXPORT void setAutoSizeFixedMinimumHeight(int);
<span class="line-added">405     bool isAutoSizeEnabled() const { return m_shouldAutoSize; }</span>
406     IntSize autoSizingIntrinsicContentSize() const { return m_autoSizeContentSize; }
407 
408     WEBCORE_EXPORT void forceLayout(bool allowSubtreeLayout = false);
409     WEBCORE_EXPORT void forceLayoutForPagination(const FloatSize&amp; pageSize, const FloatSize&amp; originalPageSize, float maximumShrinkFactor, AdjustViewSizeOrNot);
410 
411     // FIXME: This method is retained because of embedded WebViews in AppKit.  When a WebView is embedded inside
412     // some enclosing view with auto-pagination, no call happens to resize the view.  The new pagination model
413     // needs the view to resize as a result of the breaks, but that means that the enclosing view has to potentially
414     // resize around that view.  Auto-pagination uses the bounds of the actual view that&#39;s being printed to determine
415     // the edges of the print operation, so the resize is necessary if the enclosing view&#39;s bounds depend on the
416     // web document&#39;s bounds.
417     //
418     // This is already a problem if the view needs to be a different size because of printer fonts or because of print stylesheets.
419     // Mail/Dictionary work around this problem by using the _layoutForPrinting SPI
420     // to at least get print stylesheets and printer fonts into play, but since WebKit doesn&#39;t know about the page offset or
421     // page size, it can&#39;t actually paginate correctly during _layoutForPrinting.
422     //
423     // We can eventually move Mail to a newer SPI that would let them opt in to the layout-time pagination model,
424     // but that doesn&#39;t solve the general problem of how other AppKit views could opt in to the better model.
425     //
</pre>
<hr />
<pre>
459     //    Similar to client coordinates, but affected by page zoom (but not page scale).
460     //
461 
462     // Methods to convert points and rects between the coordinate space of the renderer, and this view.
463     WEBCORE_EXPORT IntRect convertFromRendererToContainingView(const RenderElement*, const IntRect&amp;) const;
464     WEBCORE_EXPORT IntRect convertFromContainingViewToRenderer(const RenderElement*, const IntRect&amp;) const;
465     WEBCORE_EXPORT FloatRect convertFromContainingViewToRenderer(const RenderElement*, const FloatRect&amp;) const;
466     WEBCORE_EXPORT IntPoint convertFromRendererToContainingView(const RenderElement*, const IntPoint&amp;) const;
467     WEBCORE_EXPORT IntPoint convertFromContainingViewToRenderer(const RenderElement*, const IntPoint&amp;) const;
468 
469     // Override ScrollView methods to do point conversion via renderers, in order to take transforms into account.
470     IntRect convertToContainingView(const IntRect&amp;) const final;
471     IntRect convertFromContainingView(const IntRect&amp;) const final;
472     FloatRect convertFromContainingView(const FloatRect&amp;) const final;
473     IntPoint convertToContainingView(const IntPoint&amp;) const final;
474     IntPoint convertFromContainingView(const IntPoint&amp;) const final;
475 
476     float documentToAbsoluteScaleFactor(Optional&lt;float&gt; effectiveZoom = WTF::nullopt) const;
477     float absoluteToDocumentScaleFactor(Optional&lt;float&gt; effectiveZoom = WTF::nullopt) const;
478 
<span class="line-modified">479     WEBCORE_EXPORT FloatRect absoluteToDocumentRect(FloatRect, Optional&lt;float&gt; effectiveZoom = WTF::nullopt) const;</span>
<span class="line-modified">480     WEBCORE_EXPORT FloatPoint absoluteToDocumentPoint(FloatPoint, Optional&lt;float&gt; effectiveZoom = WTF::nullopt) const;</span>
481 
482     FloatRect absoluteToClientRect(FloatRect, Optional&lt;float&gt; effectiveZoom = WTF::nullopt) const;
483 
484     FloatSize documentToClientOffset() const;
<span class="line-modified">485     WEBCORE_EXPORT FloatRect documentToClientRect(FloatRect) const;</span>
486     FloatPoint documentToClientPoint(FloatPoint) const;
487     WEBCORE_EXPORT FloatRect clientToDocumentRect(FloatRect) const;
488     WEBCORE_EXPORT FloatPoint clientToDocumentPoint(FloatPoint) const;
489 
<span class="line-added">490     WEBCORE_EXPORT FloatPoint absoluteToLayoutViewportPoint(FloatPoint) const;</span>
491     FloatPoint layoutViewportToAbsolutePoint(FloatPoint) const;
492 
<span class="line-added">493     WEBCORE_EXPORT FloatRect absoluteToLayoutViewportRect(FloatRect) const;</span>
<span class="line-added">494     FloatRect layoutViewportToAbsoluteRect(FloatRect) const;</span>
<span class="line-added">495 </span>
496     // Unlike client coordinates, layout viewport coordinates are affected by page zoom.
497     WEBCORE_EXPORT FloatRect clientToLayoutViewportRect(FloatRect) const;
498     WEBCORE_EXPORT FloatPoint clientToLayoutViewportPoint(FloatPoint) const;
499 
500     bool isFrameViewScrollCorner(const RenderScrollbarPart&amp; scrollCorner) const { return m_scrollCorner.get() == &amp;scrollCorner; }
501 
502     // isScrollable() takes an optional Scrollability parameter that allows the caller to define what they mean by &#39;scrollable.&#39;
503     // Most callers are interested in the default value, Scrollability::Scrollable, which means that there is actually content
504     // to scroll to, and a scrollbar that will allow you to access it. In some cases, callers want to know if the FrameView is allowed
505     // to rubber-band, which the main frame might be allowed to do even if there is no content to scroll to. In that case,
506     // callers use Scrollability::ScrollableOrRubberbandable.
507     enum class Scrollability { Scrollable, ScrollableOrRubberbandable };
508     WEBCORE_EXPORT bool isScrollable(Scrollability definitionOfScrollable = Scrollability::Scrollable);
509 
510     bool isScrollableOrRubberbandable() final;
511     bool hasScrollableOrRubberbandableAncestor() final;
512 
513     enum ScrollbarModesCalculationStrategy { RulesFromWebContentOnly, AnyRule };
514     void calculateScrollbarModesForLayout(ScrollbarMode&amp; hMode, ScrollbarMode&amp; vMode, ScrollbarModesCalculationStrategy = AnyRule);
515 
</pre>
<hr />
<pre>
544 
545     WEBCORE_EXPORT void addChild(Widget&amp;) final;
546     WEBCORE_EXPORT void removeChild(Widget&amp;) final;
547 
548     // This function exists for ports that need to handle wheel events manually.
549     // On Mac WebKit1 the underlying NSScrollView just does the scrolling, but on most other platforms
550     // we need this function in order to do the scroll ourselves.
551     bool wheelEvent(const PlatformWheelEvent&amp;);
552 
553     WEBCORE_EXPORT void setScrollingPerformanceLoggingEnabled(bool);
554 
555     // Page and FrameView both store a Pagination value. Page::pagination() is set only by API,
556     // and FrameView::pagination() is set only by CSS. Page::pagination() will affect all
557     // FrameViews in the page cache, but FrameView::pagination() only affects the current
558     // FrameView. FrameView::pagination() will return m_pagination if it has been set. Otherwise,
559     // it will return Page::pagination() since currently there are no callers that need to
560     // distinguish between the two.
561     const Pagination&amp; pagination() const;
562     void setPagination(const Pagination&amp;);
563 



564 #if ENABLE(CSS_DEVICE_ADAPTATION)
565     IntSize initialViewportSize() const { return m_initialViewportSize; }
566     void setInitialViewportSize(const IntSize&amp; size) { m_initialViewportSize = size; }
567 #endif
568 
569     bool isActive() const final;
570     bool forceUpdateScrollbarsOnMainThreadForPerformanceTesting() const final;
571 
572 #if ENABLE(RUBBER_BANDING)
573     WEBCORE_EXPORT GraphicsLayer* setWantsLayerForTopOverHangArea(bool) const;
574     WEBCORE_EXPORT GraphicsLayer* setWantsLayerForBottomOverHangArea(bool) const;
575 #endif
576 
577     // This function &quot;smears&quot; the &quot;position:fixed&quot; uninflatedBounds for scrolling, returning a rect that is the union of
578     // all possible locations of the given rect under page scrolling.
579     LayoutRect fixedScrollableAreaBoundsInflatedForScrolling(const LayoutRect&amp; uninflatedBounds) const;
580 
581     LayoutPoint scrollPositionRespectingCustomFixedPosition() const;
582 
583     WEBCORE_EXPORT int headerHeight() const final;
584     WEBCORE_EXPORT int footerHeight() const final;
585 
586     WEBCORE_EXPORT float topContentInset(TopContentInsetType = TopContentInsetType::WebCoreContentInset) const final;
587     void topContentInsetDidChange(float newTopContentInset);
588 
589     void topContentDirectionDidChange();
590 
591     WEBCORE_EXPORT void willStartLiveResize() final;
592     WEBCORE_EXPORT void willEndLiveResize() final;
593 
594     WEBCORE_EXPORT void availableContentSizeChanged(AvailableSizeChangeReason) final;
595 
596     void updateTiledBackingAdaptiveSizing();
597     TiledBacking::Scrollability computeScrollability() const;
598 




599     void addPaintPendingMilestones(OptionSet&lt;LayoutMilestone&gt;);
600     void firePaintRelatedMilestonesIfNeeded();
601     void fireLayoutRelatedMilestonesIfNeeded();
602     OptionSet&lt;LayoutMilestone&gt; milestonesPendingPaint() const { return m_milestonesPendingPaint; }
603 
604     bool visualUpdatesAllowedByClient() const { return m_visualUpdatesAllowedByClient; }
605     WEBCORE_EXPORT void setVisualUpdatesAllowedByClient(bool);
606 
607     WEBCORE_EXPORT void setScrollPinningBehavior(ScrollPinningBehavior);
608 
609     ScrollBehaviorForFixedElements scrollBehaviorForFixedElements() const;
610 
611     bool hasFlippedBlockRenderers() const { return m_hasFlippedBlockRenderers; }
612     void setHasFlippedBlockRenderers(bool b) { m_hasFlippedBlockRenderers = b; }
613 
614     void updateWidgetPositions();
615     void scheduleUpdateWidgetPositions();
616 
617     void didAddWidgetToRenderTree(Widget&amp;);
618     void willRemoveWidgetFromRenderTree(Widget&amp;);
</pre>
<hr />
<pre>
723     void delegatesScrollingDidChange() final;
724 
725     // ScrollableArea interface
726     void invalidateScrollbarRect(Scrollbar&amp;, const IntRect&amp;) final;
727     void scrollTo(const ScrollPosition&amp;) final;
728     void setVisibleScrollerThumbRect(const IntRect&amp;) final;
729     ScrollableArea* enclosingScrollableArea() const final;
730     IntRect scrollableAreaBoundingBox(bool* = nullptr) const final;
731     bool scrollAnimatorEnabled() const final;
732     GraphicsLayer* layerForScrollCorner() const final;
733 #if ENABLE(RUBBER_BANDING)
734     GraphicsLayer* layerForOverhangAreas() const final;
735 #endif
736     void contentsResized() final;
737 
738 #if PLATFORM(IOS_FAMILY)
739     void unobscuredContentSizeChanged() final;
740 #endif
741 
742 #if ENABLE(DARK_MODE_CSS)
<span class="line-modified">743     RenderObject* rendererForColorScheme() const;</span>
744 #endif
745 
746     bool usesCompositedScrolling() const final;
747     bool usesMockScrollAnimator() const final;
748     void logMockScrollAnimatorMessage(const String&amp;) const final;
749 
750     // Override scrollbar notifications to update the AXObject cache.
751     void didAddScrollbar(Scrollbar*, ScrollbarOrientation) final;
752     void willRemoveScrollbar(Scrollbar*, ScrollbarOrientation) final;
753 
754     IntSize sizeForResizeEvent() const;
755     void sendResizeEventIfNeeded();
756 
757     void adjustScrollbarsForLayout(bool firstLayout);
758 
759     void handleDeferredScrollbarsUpdateAfterDirectionChange();
760 
761     void updateScrollableAreaSet();
762     void updateLayoutViewport();
763 
</pre>
<hr />
<pre>
772 
773     void updateWidgetPositionsTimerFired();
774 
775     void scrollToAnchor();
776     void scrollPositionChanged(const ScrollPosition&amp; oldPosition, const ScrollPosition&amp; newPosition);
777     void scrollableAreaSetChanged();
778     void sendScrollEvent();
779     void resetScrollAnchor();
780 
781     bool hasCustomScrollbars() const;
782 
783     void updateScrollCorner() final;
784 
785     FrameView* parentFrameView() const;
786 
787     bool frameFlatteningEnabled() const;
788     bool isFrameFlatteningValidForThisFrame() const;
789 
790     void markRootOrBodyRendererDirty() const;
791 

792     bool qualifiesAsSignificantRenderedText() const;
793     void updateHasReachedSignificantRenderedTextThreshold();
794 
795     bool isViewForDocumentInFrame() const;
796 
797     AXObjectCache* axObjectCache() const;
798     void notifyWidgetsInAllFrames(WidgetNotification);
799     void removeFromAXObjectCache();
800     void notifyWidgets(WidgetNotification);
801 
802     RenderElement* viewportRenderer() const;
803 
804     void willDoLayout(WeakPtr&lt;RenderElement&gt; layoutRoot);
805     void didLayout(WeakPtr&lt;RenderElement&gt; layoutRoot);
806 
807     struct OverrideViewportSize {
808         Optional&lt;int&gt; width;
809         Optional&lt;int&gt; height;
810 
811         bool operator==(const OverrideViewportSize&amp; rhs) const { return rhs.width == width &amp;&amp; rhs.height == height; }
</pre>
<hr />
<pre>
819 
820     HashSet&lt;Widget*&gt; m_widgetsInRenderTree;
821     std::unique_ptr&lt;ListHashSet&lt;RenderEmbeddedObject*&gt;&gt; m_embeddedObjectsToUpdate;
822     std::unique_ptr&lt;HashSet&lt;const RenderElement*&gt;&gt; m_slowRepaintObjects;
823 
824     RefPtr&lt;ContainerNode&gt; m_maintainScrollPositionAnchor;
825     RefPtr&lt;Node&gt; m_nodeToDraw;
826 
827     // Renderer to hold our custom scroll corner.
828     RenderPtr&lt;RenderScrollbarPart&gt; m_scrollCorner;
829 
830     Timer m_updateEmbeddedObjectsTimer;
831     Timer m_updateWidgetPositionsTimer;
832     Timer m_delayedScrollEventTimer;
833     Timer m_delayedScrollToFocusedElementTimer;
834     Timer m_speculativeTilingEnableTimer;
835 
836     MonotonicTime m_lastPaintTime;
837 
838     LayoutSize m_size;

839 
840     Color m_baseBackgroundColor { Color::white };
841     IntSize m_lastViewportSize;
842 
843     String m_mediaType { &quot;screen&quot;_s };
844     String m_mediaTypeWhenNotPrinting;
845 
846     Vector&lt;FloatRect&gt; m_trackedRepaintRects;
847 
848     IntRect* m_cachedWindowClipRect { nullptr };
849     Vector&lt;WTF::Function&lt;void ()&gt;&gt; m_postLayoutCallbackQueue;
850 
851     LayoutPoint m_layoutViewportOrigin;
852     Optional&lt;LayoutRect&gt; m_layoutViewportOverrideRect;
853     Optional&lt;LayoutRect&gt; m_visualViewportOverrideRect; // Used when the iOS keyboard is showing.
854 
855     Optional&lt;FloatRect&gt; m_viewExposedRect;
856 
857     OptionSet&lt;PaintBehavior&gt; m_paintBehavior;
858 
859     float m_lastZoomFactor { 1 };
860     unsigned m_visuallyNonEmptyCharacterCount { 0 };
861     unsigned m_visuallyNonEmptyPixelCount { 0 };
862     unsigned m_textRendererCountForVisuallyNonEmptyCharacters { 0 };
863     int m_headerHeight { 0 };
864     int m_footerHeight { 0 };
865 
866 #if PLATFORM(IOS_FAMILY)
867     bool m_useCustomFixedPositionLayoutRect { false };
868     bool m_useCustomSizeForResizeEvent { false };
869 
870     IntRect m_customFixedPositionLayoutRect;
871     IntSize m_customSizeForResizeEvent;
872 #endif
873 
874     Optional&lt;OverrideViewportSize&gt; m_overrideViewportSize;
875 
<span class="line-modified">876     // The view size when autosizing.</span>
<span class="line-modified">877     IntSize m_autoSizeConstraint;</span>


878     // The fixed height to resize the view to after autosizing is complete.
879     int m_autoSizeFixedMinimumHeight { 0 };
880     // The intrinsic content size decided by autosizing.
881     IntSize m_autoSizeContentSize;
882 
883     std::unique_ptr&lt;ScrollableAreaSet&gt; m_scrollableAreas;
884     std::unique_ptr&lt;ViewportConstrainedObjectSet&gt; m_viewportConstrainedObjects;
885 
886     OptionSet&lt;LayoutMilestone&gt; m_milestonesPendingPaint;
887 
888     static const unsigned visualCharacterThreshold = 200;
889     static const unsigned visualPixelThreshold = 32 * 32;
890 
891 #if ENABLE(CSS_DEVICE_ADAPTATION)
892     // Size of viewport before any UA or author styles have overridden
893     // the viewport given by the window or viewing area of the UA.
894     IntSize m_initialViewportSize;
895 #endif
896 
897     Pagination m_pagination;
</pre>
<hr />
<pre>
901     ScrollPinningBehavior m_scrollPinningBehavior { DoNotPin };
902     SelectionRevealMode m_selectionRevealModeForFocusedElement { SelectionRevealMode::DoNotReveal };
903 
904     bool m_shouldUpdateWhileOffscreen { true };
905     bool m_overflowStatusDirty { true };
906     bool m_horizontalOverflow { false };
907     bool m_verticalOverflow { false };
908     bool m_canHaveScrollbars { true };
909     bool m_cannotBlitToWindow { false };
910     bool m_isOverlapped { false };
911     bool m_contentIsOpaque { false };
912     bool m_firstLayoutCallbackPending { false };
913 
914     bool m_isTransparent { false };
915 #if ENABLE(DARK_MODE_CSS)
916     bool m_usesDarkAppearance { false };
917 #endif
918 
919     bool m_isTrackingRepaints { false }; // Used for testing.
920     bool m_wasScrolledByUser { false };

921     bool m_shouldScrollToFocusedElement { false };
922 
923     bool m_isPainting { false };
924 
925     bool m_isVisuallyNonEmpty { false };
926 
927     bool m_renderedSignificantAmountOfText { false };
928     bool m_hasReachedSignificantRenderedTextThreshold { false };
929 
930     bool m_needsDeferredScrollbarsUpdate { false };
931     bool m_speculativeTilingEnabled { false };
932     bool m_visualUpdatesAllowedByClient { true };
933     bool m_hasFlippedBlockRenderers { false };
934     bool m_speculativeTilingDelayDisabledForTesting { false };
935 
936     // If true, automatically resize the frame view around its content.
937     bool m_shouldAutoSize { false };
938     bool m_inAutoSize { false };
939     // True if autosize has been run since m_shouldAutoSize was set.
940     bool m_didRunAutosize { false };
</pre>
</td>
</tr>
</table>
<center><a href="FrameView.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="FrameViewLayoutContext.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>