<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGSpeculativeJIT64.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (C) 2011-2019 Apple Inc. All rights reserved.
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  * 1. Redistributions of source code must retain the above copyright
   8  *    notice, this list of conditions and the following disclaimer.
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #include &quot;config.h&quot;
  27 #include &quot;DFGSpeculativeJIT.h&quot;
  28 
  29 #if ENABLE(DFG_JIT)
  30 
  31 #include &quot;ArrayPrototype.h&quot;
  32 #include &quot;AtomicsObject.h&quot;
  33 #include &quot;CallFrameShuffler.h&quot;
  34 #include &quot;DFGAbstractInterpreterInlines.h&quot;
  35 #include &quot;DFGCallArrayAllocatorSlowPathGenerator.h&quot;
  36 #include &quot;DFGDoesGC.h&quot;
  37 #include &quot;DFGOperations.h&quot;
  38 #include &quot;DFGSlowPathGenerator.h&quot;
  39 #include &quot;DirectArguments.h&quot;
  40 #include &quot;GetterSetter.h&quot;
  41 #include &quot;HasOwnPropertyCache.h&quot;
  42 #include &quot;JSCInlines.h&quot;
  43 #include &quot;JSLexicalEnvironment.h&quot;
  44 #include &quot;JSMap.h&quot;
  45 #include &quot;JSPropertyNameEnumerator.h&quot;
  46 #include &quot;JSSet.h&quot;
  47 #include &quot;ObjectPrototype.h&quot;
  48 #include &quot;SetupVarargsFrame.h&quot;
  49 #include &quot;SpillRegistersMode.h&quot;
  50 #include &quot;StringPrototype.h&quot;
  51 #include &quot;SuperSampler.h&quot;
  52 #include &quot;Watchdog.h&quot;
  53 
  54 namespace JSC { namespace DFG {
  55 
  56 #if USE(JSVALUE64)
  57 
  58 void SpeculativeJIT::boxInt52(GPRReg sourceGPR, GPRReg targetGPR, DataFormat format)
  59 {
  60     GPRReg tempGPR;
  61     if (sourceGPR == targetGPR)
  62         tempGPR = allocate();
  63     else
  64         tempGPR = targetGPR;
  65 
  66     FPRReg fpr = fprAllocate();
  67 
  68     if (format == DataFormatInt52)
  69         m_jit.rshift64(TrustedImm32(JSValue::int52ShiftAmount), sourceGPR);
  70     else
  71         ASSERT(format == DataFormatStrictInt52);
  72 
  73     m_jit.boxInt52(sourceGPR, targetGPR, tempGPR, fpr);
  74 
  75     if (format == DataFormatInt52 &amp;&amp; sourceGPR != targetGPR)
  76         m_jit.lshift64(TrustedImm32(JSValue::int52ShiftAmount), sourceGPR);
  77 
  78     if (tempGPR != targetGPR)
  79         unlock(tempGPR);
  80 
  81     unlock(fpr);
  82 }
  83 
  84 GPRReg SpeculativeJIT::fillJSValue(Edge edge)
  85 {
  86     VirtualRegister virtualRegister = edge-&gt;virtualRegister();
  87     GenerationInfo&amp; info = generationInfoFromVirtualRegister(virtualRegister);
  88 
  89     switch (info.registerFormat()) {
  90     case DataFormatNone: {
  91         GPRReg gpr = allocate();
  92 
  93         if (edge-&gt;hasConstant()) {
  94             JSValue jsValue = edge-&gt;asJSValue();
  95             m_jit.move(MacroAssembler::TrustedImm64(JSValue::encode(jsValue)), gpr);
  96             info.fillJSValue(*m_stream, gpr, DataFormatJS);
  97             m_gprs.retain(gpr, virtualRegister, SpillOrderConstant);
  98         } else {
  99             DataFormat spillFormat = info.spillFormat();
 100             m_gprs.retain(gpr, virtualRegister, SpillOrderSpilled);
 101             switch (spillFormat) {
 102             case DataFormatInt32: {
 103                 m_jit.load32(JITCompiler::addressFor(virtualRegister), gpr);
 104                 m_jit.or64(GPRInfo::tagTypeNumberRegister, gpr);
 105                 spillFormat = DataFormatJSInt32;
 106                 break;
 107             }
 108 
 109             default:
 110                 m_jit.load64(JITCompiler::addressFor(virtualRegister), gpr);
 111                 DFG_ASSERT(m_jit.graph(), m_currentNode, spillFormat &amp; DataFormatJS, spillFormat);
 112                 break;
 113             }
 114             info.fillJSValue(*m_stream, gpr, spillFormat);
 115         }
 116         return gpr;
 117     }
 118 
 119     case DataFormatInt32: {
 120         GPRReg gpr = info.gpr();
 121         // If the register has already been locked we need to take a copy.
 122         // If not, we&#39;ll zero extend in place, so mark on the info that this is now type DataFormatInt32, not DataFormatJSInt32.
 123         if (m_gprs.isLocked(gpr)) {
 124             GPRReg result = allocate();
 125             m_jit.or64(GPRInfo::tagTypeNumberRegister, gpr, result);
 126             return result;
 127         }
 128         m_gprs.lock(gpr);
 129         m_jit.or64(GPRInfo::tagTypeNumberRegister, gpr);
 130         info.fillJSValue(*m_stream, gpr, DataFormatJSInt32);
 131         return gpr;
 132     }
 133 
 134     case DataFormatCell:
 135         // No retag required on JSVALUE64!
 136     case DataFormatJS:
 137     case DataFormatJSInt32:
 138     case DataFormatJSDouble:
 139     case DataFormatJSCell:
 140     case DataFormatJSBoolean: {
 141         GPRReg gpr = info.gpr();
 142         m_gprs.lock(gpr);
 143         return gpr;
 144     }
 145 
 146     case DataFormatBoolean:
 147     case DataFormatStorage:
 148     case DataFormatDouble:
 149     case DataFormatInt52:
 150         // this type currently never occurs
 151         DFG_CRASH(m_jit.graph(), m_currentNode, &quot;Bad data format&quot;);
 152 
 153     default:
 154         DFG_CRASH(m_jit.graph(), m_currentNode, &quot;Corrupt data format&quot;);
 155         return InvalidGPRReg;
 156     }
 157 }
 158 
 159 void SpeculativeJIT::cachedGetById(CodeOrigin origin, JSValueRegs base, JSValueRegs result, unsigned identifierNumber, JITCompiler::Jump slowPathTarget , SpillRegistersMode mode, AccessType type)
 160 {
 161     cachedGetById(origin, base.gpr(), result.gpr(), identifierNumber, slowPathTarget, mode, type);
 162 }
 163 
 164 void SpeculativeJIT::cachedGetById(CodeOrigin codeOrigin, GPRReg baseGPR, GPRReg resultGPR, unsigned identifierNumber, JITCompiler::Jump slowPathTarget, SpillRegistersMode spillMode, AccessType type)
 165 {
 166     CallSiteIndex callSite = m_jit.recordCallSiteAndGenerateExceptionHandlingOSRExitIfNeeded(codeOrigin, m_stream-&gt;size());
 167     RegisterSet usedRegisters = this-&gt;usedRegisters();
 168     if (spillMode == DontSpill) {
 169         // We&#39;ve already flushed registers to the stack, we don&#39;t need to spill these.
 170         usedRegisters.set(baseGPR, false);
 171         usedRegisters.set(resultGPR, false);
 172     }
 173     JITGetByIdGenerator gen(
 174         m_jit.codeBlock(), codeOrigin, callSite, usedRegisters, identifierUID(identifierNumber),
 175         JSValueRegs(baseGPR), JSValueRegs(resultGPR), type);
 176     gen.generateFastPath(m_jit);
 177 
 178     JITCompiler::JumpList slowCases;
 179     slowCases.append(slowPathTarget);
 180     slowCases.append(gen.slowPathJump());
 181 
 182     std::unique_ptr&lt;SlowPathGenerator&gt; slowPath = slowPathCall(
 183         slowCases, this, appropriateOptimizingGetByIdFunction(type),
 184         spillMode, ExceptionCheckRequirement::CheckNeeded,
 185         resultGPR, gen.stubInfo(), baseGPR, identifierUID(identifierNumber));
 186 
 187     m_jit.addGetById(gen, slowPath.get());
 188     addSlowPathGenerator(WTFMove(slowPath));
 189 }
 190 
 191 void SpeculativeJIT::cachedGetByIdWithThis(CodeOrigin codeOrigin, GPRReg baseGPR, GPRReg thisGPR, GPRReg resultGPR, unsigned identifierNumber, const JITCompiler::JumpList&amp; slowPathTarget)
 192 {
 193     CallSiteIndex callSite = m_jit.recordCallSiteAndGenerateExceptionHandlingOSRExitIfNeeded(codeOrigin, m_stream-&gt;size());
 194     RegisterSet usedRegisters = this-&gt;usedRegisters();
 195     // We&#39;ve already flushed registers to the stack, we don&#39;t need to spill these.
 196     usedRegisters.set(baseGPR, false);
 197     usedRegisters.set(thisGPR, false);
 198     usedRegisters.set(resultGPR, false);
 199 
 200     JITGetByIdWithThisGenerator gen(
 201         m_jit.codeBlock(), codeOrigin, callSite, usedRegisters, identifierUID(identifierNumber),
 202         JSValueRegs(resultGPR), JSValueRegs(baseGPR), JSValueRegs(thisGPR), AccessType::GetWithThis);
 203     gen.generateFastPath(m_jit);
 204 
 205     JITCompiler::JumpList slowCases;
 206     slowCases.append(slowPathTarget);
 207     slowCases.append(gen.slowPathJump());
 208 
 209     std::unique_ptr&lt;SlowPathGenerator&gt; slowPath = slowPathCall(
 210         slowCases, this, operationGetByIdWithThisOptimize,
 211         DontSpill, ExceptionCheckRequirement::CheckNeeded,
 212         resultGPR, gen.stubInfo(), baseGPR, thisGPR, identifierUID(identifierNumber));
 213 
 214     m_jit.addGetByIdWithThis(gen, slowPath.get());
 215     addSlowPathGenerator(WTFMove(slowPath));
 216 }
 217 
 218 void SpeculativeJIT::nonSpeculativeNonPeepholeCompareNullOrUndefined(Edge operand)
 219 {
 220     ASSERT_WITH_MESSAGE(!masqueradesAsUndefinedWatchpointIsStillValid() || !isKnownCell(operand.node()), &quot;The Compare should have been eliminated, it is known to be always false.&quot;);
 221 
 222     JSValueOperand arg(this, operand, ManualOperandSpeculation);
 223     GPRReg argGPR = arg.gpr();
 224 
 225     GPRTemporary result(this);
 226     GPRReg resultGPR = result.gpr();
 227 
 228     m_jit.move(TrustedImm32(0), resultGPR);
 229 
 230     JITCompiler::JumpList done;
 231     if (masqueradesAsUndefinedWatchpointIsStillValid()) {
 232         if (!isKnownNotCell(operand.node()))
 233             done.append(m_jit.branchIfCell(JSValueRegs(argGPR)));
 234     } else {
 235         GPRTemporary localGlobalObject(this);
 236         GPRTemporary remoteGlobalObject(this);
 237         GPRTemporary scratch(this);
 238 
 239         JITCompiler::Jump notCell;
 240         if (!isKnownCell(operand.node()))
 241             notCell = m_jit.branchIfNotCell(JSValueRegs(argGPR));
 242 
 243         JITCompiler::Jump isNotMasqueradesAsUndefined = m_jit.branchTest8(
 244             JITCompiler::Zero,
 245             JITCompiler::Address(argGPR, JSCell::typeInfoFlagsOffset()),
 246             JITCompiler::TrustedImm32(MasqueradesAsUndefined));
 247         done.append(isNotMasqueradesAsUndefined);
 248 
 249         GPRReg localGlobalObjectGPR = localGlobalObject.gpr();
 250         GPRReg remoteGlobalObjectGPR = remoteGlobalObject.gpr();
 251         m_jit.move(TrustedImmPtr::weakPointer(m_jit.graph(), m_jit.graph().globalObjectFor(m_currentNode-&gt;origin.semantic)), localGlobalObjectGPR);
 252         m_jit.emitLoadStructure(*m_jit.vm(), argGPR, resultGPR, scratch.gpr());
 253         m_jit.loadPtr(JITCompiler::Address(resultGPR, Structure::globalObjectOffset()), remoteGlobalObjectGPR);
 254         m_jit.comparePtr(JITCompiler::Equal, localGlobalObjectGPR, remoteGlobalObjectGPR, resultGPR);
 255         done.append(m_jit.jump());
 256         if (!isKnownCell(operand.node()))
 257             notCell.link(&amp;m_jit);
 258     }
 259 
 260     if (!isKnownNotOther(operand.node())) {
 261         m_jit.move(argGPR, resultGPR);
 262         m_jit.and64(JITCompiler::TrustedImm32(~TagBitUndefined), resultGPR);
 263         m_jit.compare64(JITCompiler::Equal, resultGPR, JITCompiler::TrustedImm32(ValueNull), resultGPR);
 264     }
 265 
 266     done.link(&amp;m_jit);
 267 
 268     m_jit.or32(TrustedImm32(ValueFalse), resultGPR);
 269     jsValueResult(resultGPR, m_currentNode, DataFormatJSBoolean);
 270 }
 271 
 272 void SpeculativeJIT::nonSpeculativePeepholeBranchNullOrUndefined(Edge operand, Node* branchNode)
 273 {
 274     BasicBlock* taken = branchNode-&gt;branchData()-&gt;taken.block;
 275     BasicBlock* notTaken = branchNode-&gt;branchData()-&gt;notTaken.block;
 276 
 277     JSValueOperand arg(this, operand, ManualOperandSpeculation);
 278     GPRReg argGPR = arg.gpr();
 279 
 280     GPRTemporary result(this, Reuse, arg);
 281     GPRReg resultGPR = result.gpr();
 282 
 283     // First, handle the case where &quot;operand&quot; is a cell.
 284     if (masqueradesAsUndefinedWatchpointIsStillValid()) {
 285         if (!isKnownNotCell(operand.node())) {
 286             JITCompiler::Jump isCell = m_jit.branchIfCell(JSValueRegs(argGPR));
 287             addBranch(isCell, notTaken);
 288         }
 289     } else {
 290         GPRTemporary localGlobalObject(this);
 291         GPRTemporary remoteGlobalObject(this);
 292         GPRTemporary scratch(this);
 293 
 294         JITCompiler::Jump notCell;
 295         if (!isKnownCell(operand.node()))
 296             notCell = m_jit.branchIfNotCell(JSValueRegs(argGPR));
 297 
 298         branchTest8(JITCompiler::Zero,
 299             JITCompiler::Address(argGPR, JSCell::typeInfoFlagsOffset()),
 300             JITCompiler::TrustedImm32(MasqueradesAsUndefined), notTaken);
 301 
 302         GPRReg localGlobalObjectGPR = localGlobalObject.gpr();
 303         GPRReg remoteGlobalObjectGPR = remoteGlobalObject.gpr();
 304         m_jit.move(TrustedImmPtr::weakPointer(m_jit.graph(), m_jit.graph().globalObjectFor(m_currentNode-&gt;origin.semantic)), localGlobalObjectGPR);
 305         m_jit.emitLoadStructure(*m_jit.vm(), argGPR, resultGPR, scratch.gpr());
 306         m_jit.loadPtr(JITCompiler::Address(resultGPR, Structure::globalObjectOffset()), remoteGlobalObjectGPR);
 307         branchPtr(JITCompiler::Equal, localGlobalObjectGPR, remoteGlobalObjectGPR, taken);
 308 
 309         if (!isKnownCell(operand.node())) {
 310             jump(notTaken, ForceJump);
 311             notCell.link(&amp;m_jit);
 312         }
 313     }
 314 
 315     if (isKnownNotOther(operand.node()))
 316         jump(notTaken);
 317     else {
 318         JITCompiler::RelationalCondition condition = JITCompiler::Equal;
 319         if (taken == nextBlock()) {
 320             condition = JITCompiler::NotEqual;
 321             std::swap(taken, notTaken);
 322         }
 323         m_jit.move(argGPR, resultGPR);
 324         m_jit.and64(JITCompiler::TrustedImm32(~TagBitUndefined), resultGPR);
 325         branch64(condition, resultGPR, JITCompiler::TrustedImm64(ValueNull), taken);
 326         jump(notTaken);
 327     }
 328 }
 329 
 330 void SpeculativeJIT::nonSpeculativePeepholeStrictEq(Node* node, Node* branchNode, bool invert)
 331 {
 332     BasicBlock* taken = branchNode-&gt;branchData()-&gt;taken.block;
 333     BasicBlock* notTaken = branchNode-&gt;branchData()-&gt;notTaken.block;
 334 
 335     // The branch instruction will branch to the taken block.
 336     // If taken is next, switch taken with notTaken &amp; invert the branch condition so we can fall through.
 337     if (taken == nextBlock()) {
 338         invert = !invert;
 339         BasicBlock* tmp = taken;
 340         taken = notTaken;
 341         notTaken = tmp;
 342     }
 343 
 344     JSValueOperand arg1(this, node-&gt;child1());
 345     JSValueOperand arg2(this, node-&gt;child2());
 346     GPRReg arg1GPR = arg1.gpr();
 347     GPRReg arg2GPR = arg2.gpr();
 348 
 349     GPRTemporary result(this);
 350     GPRReg resultGPR = result.gpr();
 351 
 352     arg1.use();
 353     arg2.use();
 354 
 355     if (isKnownCell(node-&gt;child1().node()) &amp;&amp; isKnownCell(node-&gt;child2().node())) {
 356         // see if we get lucky: if the arguments are cells and they reference the same
 357         // cell, then they must be strictly equal.
 358         branch64(JITCompiler::Equal, arg1GPR, arg2GPR, invert ? notTaken : taken);
 359 
 360         silentSpillAllRegisters(resultGPR);
 361         callOperation(operationCompareStrictEqCell, resultGPR, arg1GPR, arg2GPR);
 362         silentFillAllRegisters();
 363         m_jit.exceptionCheck();
 364 
 365         branchTest32(invert ? JITCompiler::Zero : JITCompiler::NonZero, resultGPR, taken);
 366     } else {
 367         m_jit.or64(arg1GPR, arg2GPR, resultGPR);
 368 
 369         JITCompiler::Jump twoCellsCase = m_jit.branchIfCell(resultGPR);
 370 
 371         JITCompiler::Jump leftOK = m_jit.branchIfInt32(arg1GPR);
 372         JITCompiler::Jump leftDouble = m_jit.branchIfNumber(arg1GPR);
 373         leftOK.link(&amp;m_jit);
 374         JITCompiler::Jump rightOK = m_jit.branchIfInt32(arg2GPR);
 375         JITCompiler::Jump rightDouble = m_jit.branchIfNumber(arg2GPR);
 376         rightOK.link(&amp;m_jit);
 377 
 378         branch64(invert ? JITCompiler::NotEqual : JITCompiler::Equal, arg1GPR, arg2GPR, taken);
 379         jump(notTaken, ForceJump);
 380 
 381         twoCellsCase.link(&amp;m_jit);
 382         branch64(JITCompiler::Equal, arg1GPR, arg2GPR, invert ? notTaken : taken);
 383 
 384         leftDouble.link(&amp;m_jit);
 385         rightDouble.link(&amp;m_jit);
 386 
 387         silentSpillAllRegisters(resultGPR);
 388         callOperation(operationCompareStrictEq, resultGPR, arg1GPR, arg2GPR);
 389         silentFillAllRegisters();
 390         m_jit.exceptionCheck();
 391 
 392         branchTest32(invert ? JITCompiler::Zero : JITCompiler::NonZero, resultGPR, taken);
 393     }
 394 
 395     jump(notTaken);
 396 }
 397 
 398 void SpeculativeJIT::nonSpeculativeNonPeepholeStrictEq(Node* node, bool invert)
 399 {
 400     JSValueOperand arg1(this, node-&gt;child1());
 401     JSValueOperand arg2(this, node-&gt;child2());
 402     JSValueRegs arg1Regs = arg1.jsValueRegs();
 403     JSValueRegs arg2Regs = arg2.jsValueRegs();
 404 
 405     GPRTemporary result(this);
 406     GPRReg resultGPR = result.gpr();
 407 
 408     arg1.use();
 409     arg2.use();
 410 
 411     if (isKnownCell(node-&gt;child1().node()) &amp;&amp; isKnownCell(node-&gt;child2().node())) {
 412         // see if we get lucky: if the arguments are cells and they reference the same
 413         // cell, then they must be strictly equal.
 414         // FIXME: this should flush registers instead of silent spill/fill.
 415         JITCompiler::Jump notEqualCase = m_jit.branch64(JITCompiler::NotEqual, arg1Regs.gpr(), arg2Regs.gpr());
 416 
 417         m_jit.move(JITCompiler::TrustedImm64(!invert), resultGPR);
 418 
 419         JITCompiler::Jump done = m_jit.jump();
 420 
 421         notEqualCase.link(&amp;m_jit);
 422 
 423         silentSpillAllRegisters(resultGPR);
 424         callOperation(operationCompareStrictEqCell, resultGPR, arg1Regs, arg2Regs);
 425         silentFillAllRegisters();
 426         m_jit.exceptionCheck();
 427 
 428         done.link(&amp;m_jit);
 429         unblessedBooleanResult(resultGPR, m_currentNode, UseChildrenCalledExplicitly);
 430         return;
 431     }
 432 
 433     m_jit.or64(arg1Regs.gpr(), arg2Regs.gpr(), resultGPR);
 434 
 435     JITCompiler::JumpList slowPathCases;
 436 
 437     JITCompiler::Jump twoCellsCase = m_jit.branchIfCell(resultGPR);
 438 
 439     JITCompiler::Jump leftOK = m_jit.branchIfInt32(arg1Regs);
 440     slowPathCases.append(m_jit.branchIfNumber(arg1Regs, InvalidGPRReg));
 441     leftOK.link(&amp;m_jit);
 442     JITCompiler::Jump rightOK = m_jit.branchIfInt32(arg2Regs);
 443     slowPathCases.append(m_jit.branchIfNumber(arg2Regs, InvalidGPRReg));
 444     rightOK.link(&amp;m_jit);
 445 
 446     m_jit.compare64(invert ? JITCompiler::NotEqual : JITCompiler::Equal, arg1Regs.gpr(), arg2Regs.gpr(), resultGPR);
 447 
 448     JITCompiler::Jump done = m_jit.jump();
 449 
 450     twoCellsCase.link(&amp;m_jit);
 451     slowPathCases.append(m_jit.branch64(JITCompiler::NotEqual, arg1Regs.gpr(), arg2Regs.gpr()));
 452 
 453     m_jit.move(JITCompiler::TrustedImm64(!invert), resultGPR);
 454 
 455     addSlowPathGenerator(slowPathCall(slowPathCases, this, operationCompareStrictEq, resultGPR, arg1Regs, arg2Regs));
 456 
 457     done.link(&amp;m_jit);
 458 
 459     unblessedBooleanResult(resultGPR, m_currentNode, UseChildrenCalledExplicitly);
 460 }
 461 
 462 void SpeculativeJIT::emitCall(Node* node)
 463 {
 464     CallLinkInfo::CallType callType;
 465     bool isVarargs = false;
 466     bool isForwardVarargs = false;
 467     bool isTail = false;
 468     bool isEmulatedTail = false;
 469     bool isDirect = false;
 470     switch (node-&gt;op()) {
 471     case Call:
 472     case CallEval:
 473         callType = CallLinkInfo::Call;
 474         break;
 475     case TailCall:
 476         callType = CallLinkInfo::TailCall;
 477         isTail = true;
 478         break;
 479     case TailCallInlinedCaller:
 480         callType = CallLinkInfo::Call;
 481         isEmulatedTail = true;
 482         break;
 483     case Construct:
 484         callType = CallLinkInfo::Construct;
 485         break;
 486     case CallVarargs:
 487         callType = CallLinkInfo::CallVarargs;
 488         isVarargs = true;
 489         break;
 490     case TailCallVarargs:
 491         callType = CallLinkInfo::TailCallVarargs;
 492         isVarargs = true;
 493         isTail = true;
 494         break;
 495     case TailCallVarargsInlinedCaller:
 496         callType = CallLinkInfo::CallVarargs;
 497         isVarargs = true;
 498         isEmulatedTail = true;
 499         break;
 500     case ConstructVarargs:
 501         callType = CallLinkInfo::ConstructVarargs;
 502         isVarargs = true;
 503         break;
 504     case CallForwardVarargs:
 505         callType = CallLinkInfo::CallVarargs;
 506         isForwardVarargs = true;
 507         break;
 508     case ConstructForwardVarargs:
 509         callType = CallLinkInfo::ConstructVarargs;
 510         isForwardVarargs = true;
 511         break;
 512     case TailCallForwardVarargs:
 513         callType = CallLinkInfo::TailCallVarargs;
 514         isTail = true;
 515         isForwardVarargs = true;
 516         break;
 517     case TailCallForwardVarargsInlinedCaller:
 518         callType = CallLinkInfo::CallVarargs;
 519         isEmulatedTail = true;
 520         isForwardVarargs = true;
 521         break;
 522     case DirectCall:
 523         callType = CallLinkInfo::DirectCall;
 524         isDirect = true;
 525         break;
 526     case DirectConstruct:
 527         callType = CallLinkInfo::DirectConstruct;
 528         isDirect = true;
 529         break;
 530     case DirectTailCall:
 531         callType = CallLinkInfo::DirectTailCall;
 532         isTail = true;
 533         isDirect = true;
 534         break;
 535     case DirectTailCallInlinedCaller:
 536         callType = CallLinkInfo::DirectCall;
 537         isEmulatedTail = true;
 538         isDirect = true;
 539         break;
 540     default:
 541         DFG_CRASH(m_jit.graph(), node, &quot;bad node type&quot;);
 542         break;
 543     }
 544 
 545     GPRReg calleeGPR = InvalidGPRReg;
 546     CallFrameShuffleData shuffleData;
 547 
 548     ExecutableBase* executable = nullptr;
 549     FunctionExecutable* functionExecutable = nullptr;
 550     if (isDirect) {
 551         executable = node-&gt;castOperand&lt;ExecutableBase*&gt;();
 552         functionExecutable = jsDynamicCast&lt;FunctionExecutable*&gt;(*m_jit.vm(), executable);
 553     }
 554 
 555     unsigned numPassedArgs = 0;
 556     unsigned numAllocatedArgs = 0;
 557 
 558     // Gotta load the arguments somehow. Varargs is trickier.
 559     if (isVarargs || isForwardVarargs) {
 560         RELEASE_ASSERT(!isDirect);
 561         CallVarargsData* data = node-&gt;callVarargsData();
 562 
 563         int numUsedStackSlots = m_jit.graph().m_nextMachineLocal;
 564 
 565         if (isForwardVarargs) {
 566             flushRegisters();
 567             if (node-&gt;child3())
 568                 use(node-&gt;child3());
 569 
 570             GPRReg scratchGPR1;
 571             GPRReg scratchGPR2;
 572             GPRReg scratchGPR3;
 573 
 574             scratchGPR1 = JITCompiler::selectScratchGPR();
 575             scratchGPR2 = JITCompiler::selectScratchGPR(scratchGPR1);
 576             scratchGPR3 = JITCompiler::selectScratchGPR(scratchGPR1, scratchGPR2);
 577 
 578             m_jit.move(TrustedImm32(numUsedStackSlots), scratchGPR2);
 579             JITCompiler::JumpList slowCase;
 580             InlineCallFrame* inlineCallFrame;
 581             if (node-&gt;child3())
 582                 inlineCallFrame = node-&gt;child3()-&gt;origin.semantic.inlineCallFrame;
 583             else
 584                 inlineCallFrame = node-&gt;origin.semantic.inlineCallFrame;
 585             // emitSetupVarargsFrameFastCase modifies the stack pointer if it succeeds.
 586             emitSetupVarargsFrameFastCase(*m_jit.vm(), m_jit, scratchGPR2, scratchGPR1, scratchGPR2, scratchGPR3, inlineCallFrame, data-&gt;firstVarArgOffset, slowCase);
 587             JITCompiler::Jump done = m_jit.jump();
 588             slowCase.link(&amp;m_jit);
 589             callOperation(operationThrowStackOverflowForVarargs);
 590             m_jit.exceptionCheck();
 591             m_jit.abortWithReason(DFGVarargsThrowingPathDidNotThrow);
 592             done.link(&amp;m_jit);
 593         } else {
 594             GPRReg argumentsGPR;
 595             GPRReg scratchGPR1;
 596             GPRReg scratchGPR2;
 597             GPRReg scratchGPR3;
 598 
 599             auto loadArgumentsGPR = [&amp;] (GPRReg reservedGPR) {
 600                 if (reservedGPR != InvalidGPRReg)
 601                     lock(reservedGPR);
 602                 JSValueOperand arguments(this, node-&gt;child3());
 603                 argumentsGPR = arguments.gpr();
 604                 if (reservedGPR != InvalidGPRReg)
 605                     unlock(reservedGPR);
 606                 flushRegisters();
 607 
 608                 scratchGPR1 = JITCompiler::selectScratchGPR(argumentsGPR, reservedGPR);
 609                 scratchGPR2 = JITCompiler::selectScratchGPR(argumentsGPR, scratchGPR1, reservedGPR);
 610                 scratchGPR3 = JITCompiler::selectScratchGPR(argumentsGPR, scratchGPR1, scratchGPR2, reservedGPR);
 611             };
 612 
 613             loadArgumentsGPR(InvalidGPRReg);
 614 
 615             DFG_ASSERT(m_jit.graph(), node, isFlushed());
 616 
 617             // Right now, arguments is in argumentsGPR and the register file is flushed.
 618             callOperation(operationSizeFrameForVarargs, GPRInfo::returnValueGPR, argumentsGPR, numUsedStackSlots, data-&gt;firstVarArgOffset);
 619             m_jit.exceptionCheck();
 620 
 621             // Now we have the argument count of the callee frame, but we&#39;ve lost the arguments operand.
 622             // Reconstruct the arguments operand while preserving the callee frame.
 623             loadArgumentsGPR(GPRInfo::returnValueGPR);
 624             m_jit.move(TrustedImm32(numUsedStackSlots), scratchGPR1);
 625             emitSetVarargsFrame(m_jit, GPRInfo::returnValueGPR, false, scratchGPR1, scratchGPR1);
 626             m_jit.addPtr(TrustedImm32(-(sizeof(CallerFrameAndPC) + WTF::roundUpToMultipleOf(stackAlignmentBytes(), 5 * sizeof(void*)))), scratchGPR1, JITCompiler::stackPointerRegister);
 627 
 628             callOperation(operationSetupVarargsFrame, GPRInfo::returnValueGPR, scratchGPR1, argumentsGPR, data-&gt;firstVarArgOffset, GPRInfo::returnValueGPR);
 629             m_jit.exceptionCheck();
 630             m_jit.addPtr(TrustedImm32(sizeof(CallerFrameAndPC)), GPRInfo::returnValueGPR, JITCompiler::stackPointerRegister);
 631         }
 632 
 633         DFG_ASSERT(m_jit.graph(), node, isFlushed());
 634 
 635         // We don&#39;t need the arguments array anymore.
 636         if (isVarargs)
 637             use(node-&gt;child3());
 638 
 639         // Now set up the &quot;this&quot; argument.
 640         JSValueOperand thisArgument(this, node-&gt;child2());
 641         GPRReg thisArgumentGPR = thisArgument.gpr();
 642         thisArgument.use();
 643 
 644         m_jit.store64(thisArgumentGPR, JITCompiler::calleeArgumentSlot(0));
 645     } else {
 646         // The call instruction&#39;s first child is the function; the subsequent children are the
 647         // arguments.
 648         numPassedArgs = node-&gt;numChildren() - 1;
 649         numAllocatedArgs = numPassedArgs;
 650 
 651         if (functionExecutable) {
 652             // Allocate more args if this would let us avoid arity checks. This is throttled by
 653             // CallLinkInfo&#39;s limit. It&#39;s probably good to throttle it - if the callee wants a
 654             // ginormous amount of argument space then it&#39;s better for them to do it so that when we
 655             // make calls to other things, we don&#39;t waste space.
 656             unsigned desiredNumAllocatedArgs = static_cast&lt;unsigned&gt;(functionExecutable-&gt;parameterCount()) + 1;
 657             if (desiredNumAllocatedArgs &lt;= Options::maximumDirectCallStackSize()) {
 658                 numAllocatedArgs = std::max(numAllocatedArgs, desiredNumAllocatedArgs);
 659 
 660                 // Whoever converts to DirectCall should do this adjustment. It&#39;s too late for us to
 661                 // do this adjustment now since we will have already emitted code that relied on the
 662                 // value of m_parameterSlots.
 663                 DFG_ASSERT(
 664                     m_jit.graph(), node,
 665                     Graph::parameterSlotsForArgCount(numAllocatedArgs)
 666                     &lt;= m_jit.graph().m_parameterSlots);
 667             }
 668         }
 669 
 670         if (isTail) {
 671             Edge calleeEdge = m_jit.graph().child(node, 0);
 672             JSValueOperand callee(this, calleeEdge);
 673             calleeGPR = callee.gpr();
 674             if (!isDirect)
 675                 callee.use();
 676 
 677             shuffleData.tagTypeNumber = GPRInfo::tagTypeNumberRegister;
 678             shuffleData.numLocals = m_jit.graph().frameRegisterCount();
 679             shuffleData.callee = ValueRecovery::inGPR(calleeGPR, DataFormatJS);
 680             shuffleData.args.resize(numAllocatedArgs);
 681             shuffleData.numPassedArgs = numPassedArgs;
 682 
 683             for (unsigned i = 0; i &lt; numPassedArgs; ++i) {
 684                 Edge argEdge = m_jit.graph().varArgChild(node, i + 1);
 685                 GenerationInfo&amp; info = generationInfo(argEdge.node());
 686                 if (!isDirect)
 687                     use(argEdge);
 688                 shuffleData.args[i] = info.recovery(argEdge-&gt;virtualRegister());
 689             }
 690 
 691             for (unsigned i = numPassedArgs; i &lt; numAllocatedArgs; ++i)
 692                 shuffleData.args[i] = ValueRecovery::constant(jsUndefined());
 693 
 694             shuffleData.setupCalleeSaveRegisters(m_jit.codeBlock());
 695         } else {
 696             m_jit.store32(MacroAssembler::TrustedImm32(numPassedArgs), JITCompiler::calleeFramePayloadSlot(CallFrameSlot::argumentCount));
 697 
 698             for (unsigned i = 0; i &lt; numPassedArgs; i++) {
 699                 Edge argEdge = m_jit.graph().m_varArgChildren[node-&gt;firstChild() + 1 + i];
 700                 JSValueOperand arg(this, argEdge);
 701                 GPRReg argGPR = arg.gpr();
 702                 use(argEdge);
 703 
 704                 m_jit.store64(argGPR, JITCompiler::calleeArgumentSlot(i));
 705             }
 706 
 707             for (unsigned i = numPassedArgs; i &lt; numAllocatedArgs; ++i)
 708                 m_jit.storeTrustedValue(jsUndefined(), JITCompiler::calleeArgumentSlot(i));
 709         }
 710     }
 711 
 712     if (!isTail || isVarargs || isForwardVarargs) {
 713         Edge calleeEdge = m_jit.graph().child(node, 0);
 714         JSValueOperand callee(this, calleeEdge);
 715         calleeGPR = callee.gpr();
 716         callee.use();
 717         m_jit.store64(calleeGPR, JITCompiler::calleeFrameSlot(CallFrameSlot::callee));
 718 
 719         flushRegisters();
 720     }
 721 
 722     CodeOrigin staticOrigin = node-&gt;origin.semantic;
 723     ASSERT(!isTail || !staticOrigin.inlineCallFrame || !staticOrigin.inlineCallFrame-&gt;getCallerSkippingTailCalls());
 724     ASSERT(!isEmulatedTail || (staticOrigin.inlineCallFrame &amp;&amp; staticOrigin.inlineCallFrame-&gt;getCallerSkippingTailCalls()));
 725     CodeOrigin dynamicOrigin =
 726         isEmulatedTail ? *staticOrigin.inlineCallFrame-&gt;getCallerSkippingTailCalls() : staticOrigin;
 727 
 728     CallSiteIndex callSite = m_jit.recordCallSiteAndGenerateExceptionHandlingOSRExitIfNeeded(dynamicOrigin, m_stream-&gt;size());
 729 
 730     auto setResultAndResetStack = [&amp;] () {
 731         GPRFlushedCallResult result(this);
 732         GPRReg resultGPR = result.gpr();
 733         m_jit.move(GPRInfo::returnValueGPR, resultGPR);
 734 
 735         jsValueResult(resultGPR, m_currentNode, DataFormatJS, UseChildrenCalledExplicitly);
 736 
 737         // After the calls are done, we need to reestablish our stack
 738         // pointer. We rely on this for varargs calls, calls with arity
 739         // mismatch (the callframe is slided) and tail calls.
 740         m_jit.addPtr(TrustedImm32(m_jit.graph().stackPointerOffset() * sizeof(Register)), GPRInfo::callFrameRegister, JITCompiler::stackPointerRegister);
 741     };
 742 
 743     CallLinkInfo* callLinkInfo = m_jit.codeBlock()-&gt;addCallLinkInfo();
 744     callLinkInfo-&gt;setUpCall(callType, m_currentNode-&gt;origin.semantic, calleeGPR);
 745 
 746     if (node-&gt;op() == CallEval) {
 747         // We want to call operationCallEval but we don&#39;t want to overwrite the parameter area in
 748         // which we have created a prototypical eval call frame. This means that we have to
 749         // subtract stack to make room for the call. Lucky for us, at this point we have the whole
 750         // register file to ourselves.
 751 
 752         m_jit.emitStoreCallSiteIndex(callSite);
 753         m_jit.addPtr(TrustedImm32(-static_cast&lt;ptrdiff_t&gt;(sizeof(CallerFrameAndPC))), JITCompiler::stackPointerRegister, GPRInfo::regT0);
 754         m_jit.storePtr(GPRInfo::callFrameRegister, JITCompiler::Address(GPRInfo::regT0, CallFrame::callerFrameOffset()));
 755 
 756         // Now we need to make room for:
 757         // - The caller frame and PC of a call to operationCallEval.
 758         // - Potentially two arguments on the stack.
 759         unsigned requiredBytes = sizeof(CallerFrameAndPC) + sizeof(ExecState*) * 2;
 760         requiredBytes = WTF::roundUpToMultipleOf(stackAlignmentBytes(), requiredBytes);
 761         m_jit.subPtr(TrustedImm32(requiredBytes), JITCompiler::stackPointerRegister);
 762         m_jit.setupArguments&lt;decltype(operationCallEval)&gt;(GPRInfo::regT0);
 763         prepareForExternalCall();
 764         m_jit.appendCall(operationCallEval);
 765         m_jit.exceptionCheck();
 766         JITCompiler::Jump done = m_jit.branchIfNotEmpty(GPRInfo::returnValueGPR);
 767 
 768         // This is the part where we meant to make a normal call. Oops.
 769         m_jit.addPtr(TrustedImm32(requiredBytes), JITCompiler::stackPointerRegister);
 770         m_jit.load64(JITCompiler::calleeFrameSlot(CallFrameSlot::callee), GPRInfo::regT0);
 771         m_jit.emitDumbVirtualCall(*m_jit.vm(), callLinkInfo);
 772 
 773         done.link(&amp;m_jit);
 774         setResultAndResetStack();
 775         return;
 776     }
 777 
 778     if (isDirect) {
 779         callLinkInfo-&gt;setExecutableDuringCompilation(executable);
 780         callLinkInfo-&gt;setMaxNumArguments(numAllocatedArgs);
 781 
 782         if (isTail) {
 783             RELEASE_ASSERT(node-&gt;op() == DirectTailCall);
 784 
 785             JITCompiler::PatchableJump patchableJump = m_jit.patchableJump();
 786             JITCompiler::Label mainPath = m_jit.label();
 787 
 788             m_jit.emitStoreCallSiteIndex(callSite);
 789 
 790             callLinkInfo-&gt;setFrameShuffleData(shuffleData);
 791             CallFrameShuffler(m_jit, shuffleData).prepareForTailCall();
 792 
 793             JITCompiler::Call call = m_jit.nearTailCall();
 794 
 795             JITCompiler::Label slowPath = m_jit.label();
 796             patchableJump.m_jump.linkTo(slowPath, &amp;m_jit);
 797 
 798             silentSpillAllRegisters(InvalidGPRReg);
 799             callOperation(operationLinkDirectCall, callLinkInfo, calleeGPR);
 800             silentFillAllRegisters();
 801             m_jit.exceptionCheck();
 802             m_jit.jump().linkTo(mainPath, &amp;m_jit);
 803 
 804             useChildren(node);
 805 
 806             m_jit.addJSDirectTailCall(patchableJump, call, slowPath, callLinkInfo);
 807             return;
 808         }
 809 
 810         JITCompiler::Label mainPath = m_jit.label();
 811 
 812         m_jit.emitStoreCallSiteIndex(callSite);
 813 
 814         JITCompiler::Call call = m_jit.nearCall();
 815         JITCompiler::Jump done = m_jit.jump();
 816 
 817         JITCompiler::Label slowPath = m_jit.label();
 818         if (isX86())
 819             m_jit.pop(JITCompiler::selectScratchGPR(calleeGPR));
 820 
 821         callOperation(operationLinkDirectCall, callLinkInfo, calleeGPR);
 822         m_jit.exceptionCheck();
 823         m_jit.jump().linkTo(mainPath, &amp;m_jit);
 824 
 825         done.link(&amp;m_jit);
 826 
 827         setResultAndResetStack();
 828 
 829         m_jit.addJSDirectCall(call, slowPath, callLinkInfo);
 830         return;
 831     }
 832 
 833     m_jit.emitStoreCallSiteIndex(callSite);
 834 
 835     JITCompiler::DataLabelPtr targetToCheck;
 836     JITCompiler::Jump slowPath = m_jit.branchPtrWithPatch(MacroAssembler::NotEqual, calleeGPR, targetToCheck, TrustedImmPtr(nullptr));
 837 
 838     if (isTail) {
 839         if (node-&gt;op() == TailCall) {
 840             callLinkInfo-&gt;setFrameShuffleData(shuffleData);
 841             CallFrameShuffler(m_jit, shuffleData).prepareForTailCall();
 842         } else {
 843             m_jit.emitRestoreCalleeSaves();
 844             m_jit.prepareForTailCallSlow();
 845         }
 846     }
 847 
 848     JITCompiler::Call fastCall = isTail ? m_jit.nearTailCall() : m_jit.nearCall();
 849 
 850     JITCompiler::Jump done = m_jit.jump();
 851 
 852     slowPath.link(&amp;m_jit);
 853 
 854     if (node-&gt;op() == TailCall) {
 855         CallFrameShuffler callFrameShuffler(m_jit, shuffleData);
 856         callFrameShuffler.setCalleeJSValueRegs(JSValueRegs(GPRInfo::regT0));
 857         callFrameShuffler.prepareForSlowPath();
 858     } else {
 859         m_jit.move(calleeGPR, GPRInfo::regT0); // Callee needs to be in regT0
 860 
 861         if (isTail)
 862             m_jit.emitRestoreCalleeSaves(); // This needs to happen after we moved calleeGPR to regT0
 863     }
 864 
 865     m_jit.move(TrustedImmPtr(callLinkInfo), GPRInfo::regT2); // Link info needs to be in regT2
 866     JITCompiler::Call slowCall = m_jit.nearCall();
 867 
 868     done.link(&amp;m_jit);
 869 
 870     if (isTail)
 871         m_jit.abortWithReason(JITDidReturnFromTailCall);
 872     else
 873         setResultAndResetStack();
 874 
 875     m_jit.addJSCall(fastCall, slowCall, targetToCheck, callLinkInfo);
 876 }
 877 
 878 // Clang should allow unreachable [[clang::fallthrough]] in template functions if any template expansion uses it
 879 // http://llvm.org/bugs/show_bug.cgi?id=18619
 880 IGNORE_WARNINGS_BEGIN(&quot;implicit-fallthrough&quot;)
 881 template&lt;bool strict&gt;
 882 GPRReg SpeculativeJIT::fillSpeculateInt32Internal(Edge edge, DataFormat&amp; returnFormat)
 883 {
 884     AbstractValue&amp; value = m_state.forNode(edge);
 885     SpeculatedType type = value.m_type;
 886     ASSERT(edge.useKind() != KnownInt32Use || !(value.m_type &amp; ~SpecInt32Only));
 887 
 888     m_interpreter.filter(value, SpecInt32Only);
 889     if (value.isClear()) {
 890         if (mayHaveTypeCheck(edge.useKind()))
 891             terminateSpeculativeExecution(Uncountable, JSValueRegs(), 0);
 892         returnFormat = DataFormatInt32;
 893         return allocate();
 894     }
 895 
 896     VirtualRegister virtualRegister = edge-&gt;virtualRegister();
 897     GenerationInfo&amp; info = generationInfoFromVirtualRegister(virtualRegister);
 898 
 899     switch (info.registerFormat()) {
 900     case DataFormatNone: {
 901         GPRReg gpr = allocate();
 902 
 903         if (edge-&gt;hasConstant()) {
 904             m_gprs.retain(gpr, virtualRegister, SpillOrderConstant);
 905             ASSERT(edge-&gt;isInt32Constant());
 906             m_jit.move(MacroAssembler::Imm32(edge-&gt;asInt32()), gpr);
 907             info.fillInt32(*m_stream, gpr);
 908             returnFormat = DataFormatInt32;
 909             return gpr;
 910         }
 911 
 912         DataFormat spillFormat = info.spillFormat();
 913 
 914         DFG_ASSERT(m_jit.graph(), m_currentNode, (spillFormat &amp; DataFormatJS) || spillFormat == DataFormatInt32, spillFormat);
 915 
 916         m_gprs.retain(gpr, virtualRegister, SpillOrderSpilled);
 917 
 918         if (spillFormat == DataFormatJSInt32 || spillFormat == DataFormatInt32) {
 919             // If we know this was spilled as an integer we can fill without checking.
 920             if (strict) {
 921                 m_jit.load32(JITCompiler::addressFor(virtualRegister), gpr);
 922                 info.fillInt32(*m_stream, gpr);
 923                 returnFormat = DataFormatInt32;
 924                 return gpr;
 925             }
 926             if (spillFormat == DataFormatInt32) {
 927                 m_jit.load32(JITCompiler::addressFor(virtualRegister), gpr);
 928                 info.fillInt32(*m_stream, gpr);
 929                 returnFormat = DataFormatInt32;
 930             } else {
 931                 m_jit.load64(JITCompiler::addressFor(virtualRegister), gpr);
 932                 info.fillJSValue(*m_stream, gpr, DataFormatJSInt32);
 933                 returnFormat = DataFormatJSInt32;
 934             }
 935             return gpr;
 936         }
 937         m_jit.load64(JITCompiler::addressFor(virtualRegister), gpr);
 938 
 939         // Fill as JSValue, and fall through.
 940         info.fillJSValue(*m_stream, gpr, DataFormatJSInt32);
 941         m_gprs.unlock(gpr);
 942         FALLTHROUGH;
 943     }
 944 
 945     case DataFormatJS: {
 946         DFG_ASSERT(m_jit.graph(), m_currentNode, !(type &amp; SpecInt52Only));
 947         // Check the value is an integer.
 948         GPRReg gpr = info.gpr();
 949         m_gprs.lock(gpr);
 950         if (type &amp; ~SpecInt32Only)
 951             speculationCheck(BadType, JSValueRegs(gpr), edge, m_jit.branchIfNotInt32(gpr));
 952         info.fillJSValue(*m_stream, gpr, DataFormatJSInt32);
 953         // If !strict we&#39;re done, return.
 954         if (!strict) {
 955             returnFormat = DataFormatJSInt32;
 956             return gpr;
 957         }
 958         // else fall through &amp; handle as DataFormatJSInt32.
 959         m_gprs.unlock(gpr);
 960         FALLTHROUGH;
 961     }
 962 
 963     case DataFormatJSInt32: {
 964         // In a strict fill we need to strip off the value tag.
 965         if (strict) {
 966             GPRReg gpr = info.gpr();
 967             GPRReg result;
 968             // If the register has already been locked we need to take a copy.
 969             // If not, we&#39;ll zero extend in place, so mark on the info that this is now type DataFormatInt32, not DataFormatJSInt32.
 970             if (m_gprs.isLocked(gpr))
 971                 result = allocate();
 972             else {
 973                 m_gprs.lock(gpr);
 974                 info.fillInt32(*m_stream, gpr);
 975                 result = gpr;
 976             }
 977             m_jit.zeroExtend32ToPtr(gpr, result);
 978             returnFormat = DataFormatInt32;
 979             return result;
 980         }
 981 
 982         GPRReg gpr = info.gpr();
 983         m_gprs.lock(gpr);
 984         returnFormat = DataFormatJSInt32;
 985         return gpr;
 986     }
 987 
 988     case DataFormatInt32: {
 989         GPRReg gpr = info.gpr();
 990         m_gprs.lock(gpr);
 991         returnFormat = DataFormatInt32;
 992         return gpr;
 993     }
 994 
 995     case DataFormatJSDouble:
 996     case DataFormatCell:
 997     case DataFormatBoolean:
 998     case DataFormatJSCell:
 999     case DataFormatJSBoolean:
1000     case DataFormatDouble:
1001     case DataFormatStorage:
1002     case DataFormatInt52:
1003     case DataFormatStrictInt52:
1004         DFG_CRASH(m_jit.graph(), m_currentNode, &quot;Bad data format&quot;);
1005 
1006     default:
1007         DFG_CRASH(m_jit.graph(), m_currentNode, &quot;Corrupt data format&quot;);
1008         return InvalidGPRReg;
1009     }
1010 }
1011 IGNORE_WARNINGS_END
1012 
1013 GPRReg SpeculativeJIT::fillSpeculateInt32(Edge edge, DataFormat&amp; returnFormat)
1014 {
1015     return fillSpeculateInt32Internal&lt;false&gt;(edge, returnFormat);
1016 }
1017 
1018 GPRReg SpeculativeJIT::fillSpeculateInt32Strict(Edge edge)
1019 {
1020     DataFormat mustBeDataFormatInt32;
1021     GPRReg result = fillSpeculateInt32Internal&lt;true&gt;(edge, mustBeDataFormatInt32);
1022     DFG_ASSERT(m_jit.graph(), m_currentNode, mustBeDataFormatInt32 == DataFormatInt32, mustBeDataFormatInt32);
1023     return result;
1024 }
1025 
1026 GPRReg SpeculativeJIT::fillSpeculateInt52(Edge edge, DataFormat desiredFormat)
1027 {
1028     ASSERT(desiredFormat == DataFormatInt52 || desiredFormat == DataFormatStrictInt52);
1029     AbstractValue&amp; value = m_state.forNode(edge);
1030 
1031     m_interpreter.filter(value, SpecAnyInt);
1032     if (value.isClear()) {
1033         if (mayHaveTypeCheck(edge.useKind()))
1034             terminateSpeculativeExecution(Uncountable, JSValueRegs(), 0);
1035         return allocate();
1036     }
1037 
1038     VirtualRegister virtualRegister = edge-&gt;virtualRegister();
1039     GenerationInfo&amp; info = generationInfoFromVirtualRegister(virtualRegister);
1040 
1041     switch (info.registerFormat()) {
1042     case DataFormatNone: {
1043         GPRReg gpr = allocate();
1044 
1045         if (edge-&gt;hasConstant()) {
1046             JSValue jsValue = edge-&gt;asJSValue();
1047             ASSERT(jsValue.isAnyInt());
1048             m_gprs.retain(gpr, virtualRegister, SpillOrderConstant);
1049             int64_t value = jsValue.asAnyInt();
1050             if (desiredFormat == DataFormatInt52)
1051                 value = value &lt;&lt; JSValue::int52ShiftAmount;
1052             m_jit.move(MacroAssembler::Imm64(value), gpr);
1053             info.fillGPR(*m_stream, gpr, desiredFormat);
1054             return gpr;
1055         }
1056 
1057         DataFormat spillFormat = info.spillFormat();
1058 
1059         DFG_ASSERT(m_jit.graph(), m_currentNode, spillFormat == DataFormatInt52 || spillFormat == DataFormatStrictInt52, spillFormat);
1060 
1061         m_gprs.retain(gpr, virtualRegister, SpillOrderSpilled);
1062 
1063         m_jit.load64(JITCompiler::addressFor(virtualRegister), gpr);
1064         if (desiredFormat == DataFormatStrictInt52) {
1065             if (spillFormat == DataFormatInt52)
1066                 m_jit.rshift64(TrustedImm32(JSValue::int52ShiftAmount), gpr);
1067             info.fillStrictInt52(*m_stream, gpr);
1068             return gpr;
1069         }
1070         if (spillFormat == DataFormatStrictInt52)
1071             m_jit.lshift64(TrustedImm32(JSValue::int52ShiftAmount), gpr);
1072         info.fillInt52(*m_stream, gpr);
1073         return gpr;
1074     }
1075 
1076     case DataFormatStrictInt52: {
1077         GPRReg gpr = info.gpr();
1078         bool wasLocked = m_gprs.isLocked(gpr);
1079         lock(gpr);
1080         if (desiredFormat == DataFormatStrictInt52)
1081             return gpr;
1082         if (wasLocked) {
1083             GPRReg result = allocate();
1084             m_jit.move(gpr, result);
1085             unlock(gpr);
1086             gpr = result;
1087         } else
1088             info.fillInt52(*m_stream, gpr);
1089         m_jit.lshift64(TrustedImm32(JSValue::int52ShiftAmount), gpr);
1090         return gpr;
1091     }
1092 
1093     case DataFormatInt52: {
1094         GPRReg gpr = info.gpr();
1095         bool wasLocked = m_gprs.isLocked(gpr);
1096         lock(gpr);
1097         if (desiredFormat == DataFormatInt52)
1098             return gpr;
1099         if (wasLocked) {
1100             GPRReg result = allocate();
1101             m_jit.move(gpr, result);
1102             unlock(gpr);
1103             gpr = result;
1104         } else
1105             info.fillStrictInt52(*m_stream, gpr);
1106         m_jit.rshift64(TrustedImm32(JSValue::int52ShiftAmount), gpr);
1107         return gpr;
1108     }
1109 
1110     default:
1111         DFG_CRASH(m_jit.graph(), m_currentNode, &quot;Bad data format&quot;);
1112         return InvalidGPRReg;
1113     }
1114 }
1115 
1116 FPRReg SpeculativeJIT::fillSpeculateDouble(Edge edge)
1117 {
1118     ASSERT(edge.useKind() == DoubleRepUse || edge.useKind() == DoubleRepRealUse || edge.useKind() == DoubleRepAnyIntUse);
1119     ASSERT(edge-&gt;hasDoubleResult());
1120     VirtualRegister virtualRegister = edge-&gt;virtualRegister();
1121     GenerationInfo&amp; info = generationInfoFromVirtualRegister(virtualRegister);
1122 
1123     if (info.registerFormat() == DataFormatNone) {
1124         if (edge-&gt;hasConstant()) {
1125             if (edge-&gt;isNumberConstant()) {
1126                 FPRReg fpr = fprAllocate();
1127                 int64_t doubleAsInt = reinterpretDoubleToInt64(edge-&gt;asNumber());
1128                 if (!doubleAsInt)
1129                     m_jit.moveZeroToDouble(fpr);
1130                 else {
1131                     GPRReg gpr = allocate();
1132                     m_jit.move(MacroAssembler::Imm64(doubleAsInt), gpr);
1133                     m_jit.move64ToDouble(gpr, fpr);
1134                     unlock(gpr);
1135                 }
1136 
1137                 m_fprs.retain(fpr, virtualRegister, SpillOrderDouble);
1138                 info.fillDouble(*m_stream, fpr);
1139                 return fpr;
1140             }
1141             if (mayHaveTypeCheck(edge.useKind()))
1142                 terminateSpeculativeExecution(Uncountable, JSValueRegs(), 0);
1143             return fprAllocate();
1144         }
1145 
1146         DataFormat spillFormat = info.spillFormat();
1147         if (spillFormat != DataFormatDouble) {
1148             DFG_CRASH(
1149                 m_jit.graph(), m_currentNode, toCString(
1150                     &quot;Expected &quot;, edge, &quot; to have double format but instead it is spilled as &quot;,
1151                     dataFormatToString(spillFormat)).data());
1152         }
1153         DFG_ASSERT(m_jit.graph(), m_currentNode, spillFormat == DataFormatDouble, spillFormat);
1154         FPRReg fpr = fprAllocate();
1155         m_jit.loadDouble(JITCompiler::addressFor(virtualRegister), fpr);
1156         m_fprs.retain(fpr, virtualRegister, SpillOrderDouble);
1157         info.fillDouble(*m_stream, fpr);
1158         return fpr;
1159     }
1160 
1161     DFG_ASSERT(m_jit.graph(), m_currentNode, info.registerFormat() == DataFormatDouble, info.registerFormat());
1162     FPRReg fpr = info.fpr();
1163     m_fprs.lock(fpr);
1164     return fpr;
1165 }
1166 
1167 GPRReg SpeculativeJIT::fillSpeculateCell(Edge edge)
1168 {
1169     AbstractValue&amp; value = m_state.forNode(edge);
1170     SpeculatedType type = value.m_type;
1171     ASSERT((edge.useKind() != KnownCellUse &amp;&amp; edge.useKind() != KnownStringUse) || !(value.m_type &amp; ~SpecCellCheck));
1172 
1173     m_interpreter.filter(value, SpecCellCheck);
1174     if (value.isClear()) {
1175         if (mayHaveTypeCheck(edge.useKind()))
1176             terminateSpeculativeExecution(Uncountable, JSValueRegs(), 0);
1177         return allocate();
1178     }
1179 
1180     VirtualRegister virtualRegister = edge-&gt;virtualRegister();
1181     GenerationInfo&amp; info = generationInfoFromVirtualRegister(virtualRegister);
1182 
1183     switch (info.registerFormat()) {
1184     case DataFormatNone: {
1185         GPRReg gpr = allocate();
1186 
1187         if (edge-&gt;hasConstant()) {
1188             JSValue jsValue = edge-&gt;asJSValue();
1189             m_gprs.retain(gpr, virtualRegister, SpillOrderConstant);
1190             m_jit.move(MacroAssembler::TrustedImm64(JSValue::encode(jsValue)), gpr);
1191             info.fillJSValue(*m_stream, gpr, DataFormatJSCell);
1192             return gpr;
1193         }
1194 
1195         m_gprs.retain(gpr, virtualRegister, SpillOrderSpilled);
1196         m_jit.load64(JITCompiler::addressFor(virtualRegister), gpr);
1197 
1198         info.fillJSValue(*m_stream, gpr, DataFormatJS);
1199         if (type &amp; ~SpecCellCheck)
1200             speculationCheck(BadType, JSValueRegs(gpr), edge, m_jit.branchIfNotCell(JSValueRegs(gpr)));
1201         info.fillJSValue(*m_stream, gpr, DataFormatJSCell);
1202         return gpr;
1203     }
1204 
1205     case DataFormatCell:
1206     case DataFormatJSCell: {
1207         GPRReg gpr = info.gpr();
1208         m_gprs.lock(gpr);
1209         if (!ASSERT_DISABLED) {
1210             MacroAssembler::Jump checkCell = m_jit.branchIfCell(JSValueRegs(gpr));
1211             m_jit.abortWithReason(DFGIsNotCell);
1212             checkCell.link(&amp;m_jit);
1213         }
1214         return gpr;
1215     }
1216 
1217     case DataFormatJS: {
1218         GPRReg gpr = info.gpr();
1219         m_gprs.lock(gpr);
1220         if (type &amp; ~SpecCellCheck)
1221             speculationCheck(BadType, JSValueRegs(gpr), edge, m_jit.branchIfNotCell(JSValueRegs(gpr)));
1222         info.fillJSValue(*m_stream, gpr, DataFormatJSCell);
1223         return gpr;
1224     }
1225 
1226     case DataFormatJSInt32:
1227     case DataFormatInt32:
1228     case DataFormatJSDouble:
1229     case DataFormatJSBoolean:
1230     case DataFormatBoolean:
1231     case DataFormatDouble:
1232     case DataFormatStorage:
1233     case DataFormatInt52:
1234     case DataFormatStrictInt52:
1235         DFG_CRASH(m_jit.graph(), m_currentNode, &quot;Bad data format&quot;);
1236 
1237     default:
1238         DFG_CRASH(m_jit.graph(), m_currentNode, &quot;Corrupt data format&quot;);
1239         return InvalidGPRReg;
1240     }
1241 }
1242 
1243 GPRReg SpeculativeJIT::fillSpeculateBoolean(Edge edge)
1244 {
1245     AbstractValue&amp; value = m_state.forNode(edge);
1246     SpeculatedType type = value.m_type;
1247     ASSERT(edge.useKind() != KnownBooleanUse || !(value.m_type &amp; ~SpecBoolean));
1248 
1249     m_interpreter.filter(value, SpecBoolean);
1250     if (value.isClear()) {
1251         if (mayHaveTypeCheck(edge.useKind()))
1252             terminateSpeculativeExecution(Uncountable, JSValueRegs(), 0);
1253         return allocate();
1254     }
1255 
1256     VirtualRegister virtualRegister = edge-&gt;virtualRegister();
1257     GenerationInfo&amp; info = generationInfoFromVirtualRegister(virtualRegister);
1258 
1259     switch (info.registerFormat()) {
1260     case DataFormatNone: {
1261         GPRReg gpr = allocate();
1262 
1263         if (edge-&gt;hasConstant()) {
1264             JSValue jsValue = edge-&gt;asJSValue();
1265             m_gprs.retain(gpr, virtualRegister, SpillOrderConstant);
1266             m_jit.move(MacroAssembler::TrustedImm64(JSValue::encode(jsValue)), gpr);
1267             info.fillJSValue(*m_stream, gpr, DataFormatJSBoolean);
1268             return gpr;
1269         }
1270         DFG_ASSERT(m_jit.graph(), m_currentNode, info.spillFormat() &amp; DataFormatJS, info.spillFormat());
1271         m_gprs.retain(gpr, virtualRegister, SpillOrderSpilled);
1272         m_jit.load64(JITCompiler::addressFor(virtualRegister), gpr);
1273 
1274         info.fillJSValue(*m_stream, gpr, DataFormatJS);
1275         if (type &amp; ~SpecBoolean) {
1276             m_jit.xor64(TrustedImm32(static_cast&lt;int32_t&gt;(ValueFalse)), gpr);
1277             speculationCheck(BadType, JSValueRegs(gpr), edge, m_jit.branchTest64(MacroAssembler::NonZero, gpr, TrustedImm32(static_cast&lt;int32_t&gt;(~1))), SpeculationRecovery(BooleanSpeculationCheck, gpr, InvalidGPRReg));
1278             m_jit.xor64(TrustedImm32(static_cast&lt;int32_t&gt;(ValueFalse)), gpr);
1279         }
1280         info.fillJSValue(*m_stream, gpr, DataFormatJSBoolean);
1281         return gpr;
1282     }
1283 
1284     case DataFormatBoolean:
1285     case DataFormatJSBoolean: {
1286         GPRReg gpr = info.gpr();
1287         m_gprs.lock(gpr);
1288         return gpr;
1289     }
1290 
1291     case DataFormatJS: {
1292         GPRReg gpr = info.gpr();
1293         m_gprs.lock(gpr);
1294         if (type &amp; ~SpecBoolean) {
1295             m_jit.xor64(TrustedImm32(static_cast&lt;int32_t&gt;(ValueFalse)), gpr);
1296             speculationCheck(BadType, JSValueRegs(gpr), edge, m_jit.branchTest64(MacroAssembler::NonZero, gpr, TrustedImm32(static_cast&lt;int32_t&gt;(~1))), SpeculationRecovery(BooleanSpeculationCheck, gpr, InvalidGPRReg));
1297             m_jit.xor64(TrustedImm32(static_cast&lt;int32_t&gt;(ValueFalse)), gpr);
1298         }
1299         info.fillJSValue(*m_stream, gpr, DataFormatJSBoolean);
1300         return gpr;
1301     }
1302 
1303     case DataFormatJSInt32:
1304     case DataFormatInt32:
1305     case DataFormatJSDouble:
1306     case DataFormatJSCell:
1307     case DataFormatCell:
1308     case DataFormatDouble:
1309     case DataFormatStorage:
1310     case DataFormatInt52:
1311     case DataFormatStrictInt52:
1312         DFG_CRASH(m_jit.graph(), m_currentNode, &quot;Bad data format&quot;);
1313 
1314     default:
1315         DFG_CRASH(m_jit.graph(), m_currentNode, &quot;Corrupt data format&quot;);
1316         return InvalidGPRReg;
1317     }
1318 }
1319 
1320 void SpeculativeJIT::compileObjectStrictEquality(Edge objectChild, Edge otherChild)
1321 {
1322     SpeculateCellOperand op1(this, objectChild);
1323     JSValueOperand op2(this, otherChild);
1324     GPRTemporary result(this);
1325 
1326     GPRReg op1GPR = op1.gpr();
1327     GPRReg op2GPR = op2.gpr();
1328     GPRReg resultGPR = result.gpr();
1329 
1330     DFG_TYPE_CHECK(JSValueSource::unboxedCell(op1GPR), objectChild, SpecObject, m_jit.branchIfNotObject(op1GPR));
1331 
1332     // At this point we know that we can perform a straight-forward equality comparison on pointer
1333     // values because we are doing strict equality.
1334     m_jit.compare64(MacroAssembler::Equal, op1GPR, op2GPR, resultGPR);
1335     m_jit.or32(TrustedImm32(ValueFalse), resultGPR);
1336     jsValueResult(resultGPR, m_currentNode, DataFormatJSBoolean);
1337 }
1338 
1339 void SpeculativeJIT::compilePeepHoleObjectStrictEquality(Edge objectChild, Edge otherChild, Node* branchNode)
1340 {
1341     BasicBlock* taken = branchNode-&gt;branchData()-&gt;taken.block;
1342     BasicBlock* notTaken = branchNode-&gt;branchData()-&gt;notTaken.block;
1343 
1344     SpeculateCellOperand op1(this, objectChild);
1345     JSValueOperand op2(this, otherChild);
1346 
1347     GPRReg op1GPR = op1.gpr();
1348     GPRReg op2GPR = op2.gpr();
1349 
1350     DFG_TYPE_CHECK(JSValueSource::unboxedCell(op1GPR), objectChild, SpecObject, m_jit.branchIfNotObject(op1GPR));
1351 
1352     if (taken == nextBlock()) {
1353         branchPtr(MacroAssembler::NotEqual, op1GPR, op2GPR, notTaken);
1354         jump(taken);
1355     } else {
1356         branchPtr(MacroAssembler::Equal, op1GPR, op2GPR, taken);
1357         jump(notTaken);
1358     }
1359 }
1360 
1361 void SpeculativeJIT::compileObjectToObjectOrOtherEquality(Edge leftChild, Edge rightChild)
1362 {
1363     SpeculateCellOperand op1(this, leftChild);
1364     JSValueOperand op2(this, rightChild, ManualOperandSpeculation);
1365     GPRTemporary result(this);
1366 
1367     GPRReg op1GPR = op1.gpr();
1368     GPRReg op2GPR = op2.gpr();
1369     GPRReg resultGPR = result.gpr();
1370 
1371     bool masqueradesAsUndefinedWatchpointValid =
1372         masqueradesAsUndefinedWatchpointIsStillValid();
1373 
1374     if (masqueradesAsUndefinedWatchpointValid) {
1375         DFG_TYPE_CHECK(
1376             JSValueSource::unboxedCell(op1GPR), leftChild, SpecObject, m_jit.branchIfNotObject(op1GPR));
1377     } else {
1378         DFG_TYPE_CHECK(
1379             JSValueSource::unboxedCell(op1GPR), leftChild, SpecObject, m_jit.branchIfNotObject(op1GPR));
1380         speculationCheck(BadType, JSValueSource::unboxedCell(op1GPR), leftChild,
1381             m_jit.branchTest8(
1382                 MacroAssembler::NonZero,
1383                 MacroAssembler::Address(op1GPR, JSCell::typeInfoFlagsOffset()),
1384                 MacroAssembler::TrustedImm32(MasqueradesAsUndefined)));
1385     }
1386 
1387     // It seems that most of the time when programs do a == b where b may be either null/undefined
1388     // or an object, b is usually an object. Balance the branches to make that case fast.
1389     MacroAssembler::Jump rightNotCell = m_jit.branchIfNotCell(JSValueRegs(op2GPR));
1390 
1391     // We know that within this branch, rightChild must be a cell.
1392     if (masqueradesAsUndefinedWatchpointValid) {
1393         DFG_TYPE_CHECK(
1394             JSValueRegs(op2GPR), rightChild, (~SpecCellCheck) | SpecObject, m_jit.branchIfNotObject(op2GPR));
1395     } else {
1396         DFG_TYPE_CHECK(
1397             JSValueRegs(op2GPR), rightChild, (~SpecCellCheck) | SpecObject, m_jit.branchIfNotObject(op2GPR));
1398         speculationCheck(BadType, JSValueRegs(op2GPR), rightChild,
1399             m_jit.branchTest8(
1400                 MacroAssembler::NonZero,
1401                 MacroAssembler::Address(op2GPR, JSCell::typeInfoFlagsOffset()),
1402                 MacroAssembler::TrustedImm32(MasqueradesAsUndefined)));
1403     }
1404 
1405     // At this point we know that we can perform a straight-forward equality comparison on pointer
1406     // values because both left and right are pointers to objects that have no special equality
1407     // protocols.
1408     m_jit.compare64(MacroAssembler::Equal, op1GPR, op2GPR, resultGPR);
1409     MacroAssembler::Jump done = m_jit.jump();
1410 
1411     rightNotCell.link(&amp;m_jit);
1412 
1413     // We know that within this branch, rightChild must not be a cell. Check if that is enough to
1414     // prove that it is either null or undefined.
1415     if (needsTypeCheck(rightChild, SpecCellCheck | SpecOther)) {
1416         m_jit.move(op2GPR, resultGPR);
1417         m_jit.and64(MacroAssembler::TrustedImm32(~TagBitUndefined), resultGPR);
1418 
1419         typeCheck(
1420             JSValueRegs(op2GPR), rightChild, SpecCellCheck | SpecOther,
1421             m_jit.branch64(
1422                 MacroAssembler::NotEqual, resultGPR,
1423                 MacroAssembler::TrustedImm64(ValueNull)));
1424     }
1425     m_jit.move(TrustedImm32(0), result.gpr());
1426 
1427     done.link(&amp;m_jit);
1428     m_jit.or32(TrustedImm32(ValueFalse), resultGPR);
1429     jsValueResult(resultGPR, m_currentNode, DataFormatJSBoolean);
1430 }
1431 
1432 void SpeculativeJIT::compilePeepHoleObjectToObjectOrOtherEquality(Edge leftChild, Edge rightChild, Node* branchNode)
1433 {
1434     BasicBlock* taken = branchNode-&gt;branchData()-&gt;taken.block;
1435     BasicBlock* notTaken = branchNode-&gt;branchData()-&gt;notTaken.block;
1436 
1437     SpeculateCellOperand op1(this, leftChild);
1438     JSValueOperand op2(this, rightChild, ManualOperandSpeculation);
1439     GPRTemporary result(this);
1440 
1441     GPRReg op1GPR = op1.gpr();
1442     GPRReg op2GPR = op2.gpr();
1443     GPRReg resultGPR = result.gpr();
1444 
1445     bool masqueradesAsUndefinedWatchpointValid =
1446         masqueradesAsUndefinedWatchpointIsStillValid();
1447 
1448     if (masqueradesAsUndefinedWatchpointValid) {
1449         DFG_TYPE_CHECK(
1450             JSValueSource::unboxedCell(op1GPR), leftChild, SpecObject, m_jit.branchIfNotObject(op1GPR));
1451     } else {
1452         DFG_TYPE_CHECK(
1453             JSValueSource::unboxedCell(op1GPR), leftChild, SpecObject, m_jit.branchIfNotObject(op1GPR));
1454         speculationCheck(BadType, JSValueSource::unboxedCell(op1GPR), leftChild,
1455             m_jit.branchTest8(
1456                 MacroAssembler::NonZero,
1457                 MacroAssembler::Address(op1GPR, JSCell::typeInfoFlagsOffset()),
1458                 MacroAssembler::TrustedImm32(MasqueradesAsUndefined)));
1459     }
1460 
1461     // It seems that most of the time when programs do a == b where b may be either null/undefined
1462     // or an object, b is usually an object. Balance the branches to make that case fast.
1463     MacroAssembler::Jump rightNotCell = m_jit.branchIfNotCell(JSValueRegs(op2GPR));
1464 
1465     // We know that within this branch, rightChild must be a cell.
1466     if (masqueradesAsUndefinedWatchpointValid) {
1467         DFG_TYPE_CHECK(
1468             JSValueRegs(op2GPR), rightChild, (~SpecCellCheck) | SpecObject, m_jit.branchIfNotObject(op2GPR));
1469     } else {
1470         DFG_TYPE_CHECK(
1471             JSValueRegs(op2GPR), rightChild, (~SpecCellCheck) | SpecObject, m_jit.branchIfNotObject(op2GPR));
1472         speculationCheck(BadType, JSValueRegs(op2GPR), rightChild,
1473             m_jit.branchTest8(
1474                 MacroAssembler::NonZero,
1475                 MacroAssembler::Address(op2GPR, JSCell::typeInfoFlagsOffset()),
1476                 MacroAssembler::TrustedImm32(MasqueradesAsUndefined)));
1477     }
1478 
1479     // At this point we know that we can perform a straight-forward equality comparison on pointer
1480     // values because both left and right are pointers to objects that have no special equality
1481     // protocols.
1482     branch64(MacroAssembler::Equal, op1GPR, op2GPR, taken);
1483 
1484     // We know that within this branch, rightChild must not be a cell. Check if that is enough to
1485     // prove that it is either null or undefined.
1486     if (!needsTypeCheck(rightChild, SpecCellCheck | SpecOther))
1487         rightNotCell.link(&amp;m_jit);
1488     else {
1489         jump(notTaken, ForceJump);
1490 
1491         rightNotCell.link(&amp;m_jit);
1492         m_jit.move(op2GPR, resultGPR);
1493         m_jit.and64(MacroAssembler::TrustedImm32(~TagBitUndefined), resultGPR);
1494 
1495         typeCheck(
1496             JSValueRegs(op2GPR), rightChild, SpecCellCheck | SpecOther, m_jit.branch64(
1497                 MacroAssembler::NotEqual, resultGPR,
1498                 MacroAssembler::TrustedImm64(ValueNull)));
1499     }
1500 
1501     jump(notTaken);
1502 }
1503 
1504 void SpeculativeJIT::compileSymbolUntypedEquality(Node* node, Edge symbolEdge, Edge untypedEdge)
1505 {
1506     SpeculateCellOperand symbol(this, symbolEdge);
1507     JSValueOperand untyped(this, untypedEdge);
1508     GPRTemporary result(this, Reuse, symbol, untyped);
1509 
1510     GPRReg symbolGPR = symbol.gpr();
1511     GPRReg untypedGPR = untyped.gpr();
1512     GPRReg resultGPR = result.gpr();
1513 
1514     speculateSymbol(symbolEdge, symbolGPR);
1515 
1516     // At this point we know that we can perform a straight-forward equality comparison on pointer
1517     // values because we are doing strict equality.
1518     m_jit.compare64(MacroAssembler::Equal, symbolGPR, untypedGPR, resultGPR);
1519     unblessedBooleanResult(resultGPR, node);
1520 }
1521 
1522 void SpeculativeJIT::compileInt52Compare(Node* node, MacroAssembler::RelationalCondition condition)
1523 {
1524     SpeculateWhicheverInt52Operand op1(this, node-&gt;child1());
1525     SpeculateWhicheverInt52Operand op2(this, node-&gt;child2(), op1);
1526     GPRTemporary result(this, Reuse, op1, op2);
1527 
1528     m_jit.compare64(condition, op1.gpr(), op2.gpr(), result.gpr());
1529 
1530     // If we add a DataFormatBool, we should use it here.
1531     m_jit.or32(TrustedImm32(ValueFalse), result.gpr());
1532     jsValueResult(result.gpr(), m_currentNode, DataFormatJSBoolean);
1533 }
1534 
1535 void SpeculativeJIT::compilePeepHoleInt52Branch(Node* node, Node* branchNode, JITCompiler::RelationalCondition condition)
1536 {
1537     BasicBlock* taken = branchNode-&gt;branchData()-&gt;taken.block;
1538     BasicBlock* notTaken = branchNode-&gt;branchData()-&gt;notTaken.block;
1539 
1540     // The branch instruction will branch to the taken block.
1541     // If taken is next, switch taken with notTaken &amp; invert the branch condition so we can fall through.
1542     if (taken == nextBlock()) {
1543         condition = JITCompiler::invert(condition);
1544         BasicBlock* tmp = taken;
1545         taken = notTaken;
1546         notTaken = tmp;
1547     }
1548 
1549     SpeculateWhicheverInt52Operand op1(this, node-&gt;child1());
1550     SpeculateWhicheverInt52Operand op2(this, node-&gt;child2(), op1);
1551 
1552     branch64(condition, op1.gpr(), op2.gpr(), taken);
1553     jump(notTaken);
1554 }
1555 
1556 void SpeculativeJIT::compileCompareEqPtr(Node* node)
1557 {
1558     JSValueOperand value(this, node-&gt;child1());
1559     GPRTemporary result(this);
1560     GPRReg valueGPR = value.gpr();
1561     GPRReg resultGPR = result.gpr();
1562 
1563     m_jit.move(TrustedImmPtr::weakPointer(m_jit.graph(), node-&gt;cellOperand()-&gt;cell()), resultGPR);
1564     m_jit.compare64(MacroAssembler::Equal, valueGPR, resultGPR, resultGPR);
1565     unblessedBooleanResult(resultGPR, node);
1566 }
1567 
1568 void SpeculativeJIT::compileObjectOrOtherLogicalNot(Edge nodeUse)
1569 {
1570     JSValueOperand value(this, nodeUse, ManualOperandSpeculation);
1571     GPRTemporary result(this);
1572     GPRReg valueGPR = value.gpr();
1573     GPRReg resultGPR = result.gpr();
1574     GPRTemporary structure;
1575     GPRReg structureGPR = InvalidGPRReg;
1576     GPRTemporary scratch;
1577     GPRReg scratchGPR = InvalidGPRReg;
1578 
1579     bool masqueradesAsUndefinedWatchpointValid =
1580         masqueradesAsUndefinedWatchpointIsStillValid();
1581 
1582     if (!masqueradesAsUndefinedWatchpointValid) {
1583         // The masquerades as undefined case will use the structure register, so allocate it here.
1584         // Do this at the top of the function to avoid branching around a register allocation.
1585         GPRTemporary realStructure(this);
1586         GPRTemporary realScratch(this);
1587         structure.adopt(realStructure);
1588         scratch.adopt(realScratch);
1589         structureGPR = structure.gpr();
1590         scratchGPR = scratch.gpr();
1591     }
1592 
1593     MacroAssembler::Jump notCell = m_jit.branchIfNotCell(JSValueRegs(valueGPR));
1594     if (masqueradesAsUndefinedWatchpointValid) {
1595         DFG_TYPE_CHECK(
1596             JSValueRegs(valueGPR), nodeUse, (~SpecCellCheck) | SpecObject, m_jit.branchIfNotObject(valueGPR));
1597     } else {
1598         DFG_TYPE_CHECK(
1599             JSValueRegs(valueGPR), nodeUse, (~SpecCellCheck) | SpecObject, m_jit.branchIfNotObject(valueGPR));
1600 
1601         MacroAssembler::Jump isNotMasqueradesAsUndefined =
1602             m_jit.branchTest8(
1603                 MacroAssembler::Zero,
1604                 MacroAssembler::Address(valueGPR, JSCell::typeInfoFlagsOffset()),
1605                 MacroAssembler::TrustedImm32(MasqueradesAsUndefined));
1606 
1607         m_jit.emitLoadStructure(*m_jit.vm(), valueGPR, structureGPR, scratchGPR);
1608         speculationCheck(BadType, JSValueRegs(valueGPR), nodeUse,
1609             m_jit.branchPtr(
1610                 MacroAssembler::Equal,
1611                 MacroAssembler::Address(structureGPR, Structure::globalObjectOffset()),
1612                 TrustedImmPtr::weakPointer(m_jit.graph(), m_jit.graph().globalObjectFor(m_currentNode-&gt;origin.semantic))));
1613 
1614         isNotMasqueradesAsUndefined.link(&amp;m_jit);
1615     }
1616     m_jit.move(TrustedImm32(ValueFalse), resultGPR);
1617     MacroAssembler::Jump done = m_jit.jump();
1618 
1619     notCell.link(&amp;m_jit);
1620 
1621     if (needsTypeCheck(nodeUse, SpecCellCheck | SpecOther)) {
1622         m_jit.move(valueGPR, resultGPR);
1623         m_jit.and64(MacroAssembler::TrustedImm32(~TagBitUndefined), resultGPR);
1624         typeCheck(
1625             JSValueRegs(valueGPR), nodeUse, SpecCellCheck | SpecOther, m_jit.branch64(
1626                 MacroAssembler::NotEqual,
1627                 resultGPR,
1628                 MacroAssembler::TrustedImm64(ValueNull)));
1629     }
1630     m_jit.move(TrustedImm32(ValueTrue), resultGPR);
1631 
1632     done.link(&amp;m_jit);
1633 
1634     jsValueResult(resultGPR, m_currentNode, DataFormatJSBoolean);
1635 }
1636 
1637 void SpeculativeJIT::compileLogicalNot(Node* node)
1638 {
1639     switch (node-&gt;child1().useKind()) {
1640     case ObjectOrOtherUse: {
1641         compileObjectOrOtherLogicalNot(node-&gt;child1());
1642         return;
1643     }
1644 
1645     case Int32Use: {
1646         SpeculateInt32Operand value(this, node-&gt;child1());
1647         GPRTemporary result(this, Reuse, value);
1648         m_jit.compare32(MacroAssembler::Equal, value.gpr(), MacroAssembler::TrustedImm32(0), result.gpr());
1649         m_jit.or32(TrustedImm32(ValueFalse), result.gpr());
1650         jsValueResult(result.gpr(), node, DataFormatJSBoolean);
1651         return;
1652     }
1653 
1654     case DoubleRepUse: {
1655         SpeculateDoubleOperand value(this, node-&gt;child1());
1656         FPRTemporary scratch(this);
1657         GPRTemporary result(this);
1658         m_jit.move(TrustedImm32(ValueFalse), result.gpr());
1659         MacroAssembler::Jump nonZero = m_jit.branchDoubleNonZero(value.fpr(), scratch.fpr());
1660         m_jit.xor32(TrustedImm32(true), result.gpr());
1661         nonZero.link(&amp;m_jit);
1662         jsValueResult(result.gpr(), node, DataFormatJSBoolean);
1663         return;
1664     }
1665 
1666     case BooleanUse:
1667     case KnownBooleanUse: {
1668         if (!needsTypeCheck(node-&gt;child1(), SpecBoolean)) {
1669             SpeculateBooleanOperand value(this, node-&gt;child1());
1670             GPRTemporary result(this, Reuse, value);
1671 
1672             m_jit.move(value.gpr(), result.gpr());
1673             m_jit.xor64(TrustedImm32(true), result.gpr());
1674 
1675             jsValueResult(result.gpr(), node, DataFormatJSBoolean);
1676             return;
1677         }
1678 
1679         JSValueOperand value(this, node-&gt;child1(), ManualOperandSpeculation);
1680         GPRTemporary result(this); // FIXME: We could reuse, but on speculation fail would need recovery to restore tag (akin to add).
1681 
1682         m_jit.move(value.gpr(), result.gpr());
1683         m_jit.xor64(TrustedImm32(static_cast&lt;int32_t&gt;(ValueFalse)), result.gpr());
1684         typeCheck(
1685             JSValueRegs(value.gpr()), node-&gt;child1(), SpecBoolean, m_jit.branchTest64(
1686                 JITCompiler::NonZero, result.gpr(), TrustedImm32(static_cast&lt;int32_t&gt;(~1))));
1687         m_jit.xor64(TrustedImm32(static_cast&lt;int32_t&gt;(ValueTrue)), result.gpr());
1688 
1689         // If we add a DataFormatBool, we should use it here.
1690         jsValueResult(result.gpr(), node, DataFormatJSBoolean);
1691         return;
1692     }
1693 
1694     case UntypedUse: {
1695         JSValueOperand arg1(this, node-&gt;child1());
1696         GPRTemporary result(this);
1697 
1698         GPRReg arg1GPR = arg1.gpr();
1699         GPRReg resultGPR = result.gpr();
1700 
1701         FPRTemporary valueFPR(this);
1702         FPRTemporary tempFPR(this);
1703 
1704         bool shouldCheckMasqueradesAsUndefined = !masqueradesAsUndefinedWatchpointIsStillValid();
1705         JSGlobalObject* globalObject = m_jit.graph().globalObjectFor(node-&gt;origin.semantic);
1706         Optional&lt;GPRTemporary&gt; scratch;
1707         GPRReg scratchGPR = InvalidGPRReg;
1708         if (shouldCheckMasqueradesAsUndefined) {
1709             scratch.emplace(this);
1710             scratchGPR = scratch-&gt;gpr();
1711         }
1712         bool negateResult = true;
1713         m_jit.emitConvertValueToBoolean(*m_jit.vm(), JSValueRegs(arg1GPR), resultGPR, scratchGPR, valueFPR.fpr(), tempFPR.fpr(), shouldCheckMasqueradesAsUndefined, globalObject, negateResult);
1714         m_jit.or32(TrustedImm32(ValueFalse), resultGPR);
1715         jsValueResult(resultGPR, node, DataFormatJSBoolean);
1716         return;
1717     }
1718     case StringUse:
1719         return compileStringZeroLength(node);
1720 
1721     case StringOrOtherUse:
1722         return compileLogicalNotStringOrOther(node);
1723 
1724     default:
1725         DFG_CRASH(m_jit.graph(), node, &quot;Bad use kind&quot;);
1726         break;
1727     }
1728 }
1729 
1730 void SpeculativeJIT::emitObjectOrOtherBranch(Edge nodeUse, BasicBlock* taken, BasicBlock* notTaken)
1731 {
1732     JSValueOperand value(this, nodeUse, ManualOperandSpeculation);
1733     GPRTemporary scratch(this);
1734     GPRTemporary structure;
1735     GPRReg valueGPR = value.gpr();
1736     GPRReg scratchGPR = scratch.gpr();
1737     GPRReg structureGPR = InvalidGPRReg;
1738 
1739     if (!masqueradesAsUndefinedWatchpointIsStillValid()) {
1740         GPRTemporary realStructure(this);
1741         structure.adopt(realStructure);
1742         structureGPR = structure.gpr();
1743     }
1744 
1745     MacroAssembler::Jump notCell = m_jit.branchIfNotCell(JSValueRegs(valueGPR));
1746     if (masqueradesAsUndefinedWatchpointIsStillValid()) {
1747         DFG_TYPE_CHECK(
1748             JSValueRegs(valueGPR), nodeUse, (~SpecCellCheck) | SpecObject, m_jit.branchIfNotObject(valueGPR));
1749     } else {
1750         DFG_TYPE_CHECK(
1751             JSValueRegs(valueGPR), nodeUse, (~SpecCellCheck) | SpecObject, m_jit.branchIfNotObject(valueGPR));
1752 
1753         JITCompiler::Jump isNotMasqueradesAsUndefined = m_jit.branchTest8(
1754             JITCompiler::Zero,
1755             MacroAssembler::Address(valueGPR, JSCell::typeInfoFlagsOffset()),
1756             TrustedImm32(MasqueradesAsUndefined));
1757 
1758         m_jit.emitLoadStructure(*m_jit.vm(), valueGPR, structureGPR, scratchGPR);
1759         speculationCheck(BadType, JSValueRegs(valueGPR), nodeUse,
1760             m_jit.branchPtr(
1761                 MacroAssembler::Equal,
1762                 MacroAssembler::Address(structureGPR, Structure::globalObjectOffset()),
1763                 TrustedImmPtr::weakPointer(m_jit.graph(), m_jit.graph().globalObjectFor(m_currentNode-&gt;origin.semantic))));
1764 
1765         isNotMasqueradesAsUndefined.link(&amp;m_jit);
1766     }
1767     jump(taken, ForceJump);
1768 
1769     notCell.link(&amp;m_jit);
1770 
1771     if (needsTypeCheck(nodeUse, SpecCellCheck | SpecOther)) {
1772         m_jit.move(valueGPR, scratchGPR);
1773         m_jit.and64(MacroAssembler::TrustedImm32(~TagBitUndefined), scratchGPR);
1774         typeCheck(
1775             JSValueRegs(valueGPR), nodeUse, SpecCellCheck | SpecOther, m_jit.branch64(
1776                 MacroAssembler::NotEqual, scratchGPR, MacroAssembler::TrustedImm64(ValueNull)));
1777     }
1778     jump(notTaken);
1779 
1780     noResult(m_currentNode);
1781 }
1782 
1783 void SpeculativeJIT::emitBranch(Node* node)
1784 {
1785     BasicBlock* taken = node-&gt;branchData()-&gt;taken.block;
1786     BasicBlock* notTaken = node-&gt;branchData()-&gt;notTaken.block;
1787 
1788     switch (node-&gt;child1().useKind()) {
1789     case ObjectOrOtherUse: {
1790         emitObjectOrOtherBranch(node-&gt;child1(), taken, notTaken);
1791         return;
1792     }
1793 
1794     case Int32Use:
1795     case DoubleRepUse: {
1796         if (node-&gt;child1().useKind() == Int32Use) {
1797             bool invert = false;
1798 
1799             if (taken == nextBlock()) {
1800                 invert = true;
1801                 BasicBlock* tmp = taken;
1802                 taken = notTaken;
1803                 notTaken = tmp;
1804             }
1805 
1806             SpeculateInt32Operand value(this, node-&gt;child1());
1807             branchTest32(invert ? MacroAssembler::Zero : MacroAssembler::NonZero, value.gpr(), taken);
1808         } else {
1809             SpeculateDoubleOperand value(this, node-&gt;child1());
1810             FPRTemporary scratch(this);
1811             branchDoubleNonZero(value.fpr(), scratch.fpr(), taken);
1812         }
1813 
1814         jump(notTaken);
1815 
1816         noResult(node);
1817         return;
1818     }
1819 
1820     case StringUse: {
1821         emitStringBranch(node-&gt;child1(), taken, notTaken);
1822         return;
1823     }
1824 
1825     case StringOrOtherUse: {
1826         emitStringOrOtherBranch(node-&gt;child1(), taken, notTaken);
1827         return;
1828     }
1829 
1830     case UntypedUse:
1831     case BooleanUse:
1832     case KnownBooleanUse: {
1833         JSValueOperand value(this, node-&gt;child1(), ManualOperandSpeculation);
1834         GPRReg valueGPR = value.gpr();
1835 
1836         if (node-&gt;child1().useKind() == BooleanUse || node-&gt;child1().useKind() == KnownBooleanUse) {
1837             if (!needsTypeCheck(node-&gt;child1(), SpecBoolean)) {
1838                 MacroAssembler::ResultCondition condition = MacroAssembler::NonZero;
1839 
1840                 if (taken == nextBlock()) {
1841                     condition = MacroAssembler::Zero;
1842                     BasicBlock* tmp = taken;
1843                     taken = notTaken;
1844                     notTaken = tmp;
1845                 }
1846 
1847                 branchTest32(condition, valueGPR, TrustedImm32(true), taken);
1848                 jump(notTaken);
1849             } else {
1850                 branch64(MacroAssembler::Equal, valueGPR, MacroAssembler::TrustedImm64(JSValue::encode(jsBoolean(false))), notTaken);
1851                 branch64(MacroAssembler::Equal, valueGPR, MacroAssembler::TrustedImm64(JSValue::encode(jsBoolean(true))), taken);
1852 
1853                 typeCheck(JSValueRegs(valueGPR), node-&gt;child1(), SpecBoolean, m_jit.jump());
1854             }
1855             value.use();
1856         } else {
1857             GPRTemporary result(this);
1858             FPRTemporary fprValue(this);
1859             FPRTemporary fprTemp(this);
1860             Optional&lt;GPRTemporary&gt; scratch;
1861 
1862             GPRReg scratchGPR = InvalidGPRReg;
1863             bool shouldCheckMasqueradesAsUndefined = !masqueradesAsUndefinedWatchpointIsStillValid();
1864             if (shouldCheckMasqueradesAsUndefined) {
1865                 scratch.emplace(this);
1866                 scratchGPR = scratch-&gt;gpr();
1867             }
1868 
1869             GPRReg resultGPR = result.gpr();
1870             FPRReg valueFPR = fprValue.fpr();
1871             FPRReg tempFPR = fprTemp.fpr();
1872 
1873             if (node-&gt;child1()-&gt;prediction() &amp; SpecInt32Only) {
1874                 branch64(MacroAssembler::Equal, valueGPR, MacroAssembler::TrustedImm64(JSValue::encode(jsNumber(0))), notTaken);
1875                 branch64(MacroAssembler::AboveOrEqual, valueGPR, GPRInfo::tagTypeNumberRegister, taken);
1876             }
1877 
1878             if (node-&gt;child1()-&gt;prediction() &amp; SpecBoolean) {
1879                 branch64(MacroAssembler::Equal, valueGPR, MacroAssembler::TrustedImm64(JSValue::encode(jsBoolean(false))), notTaken);
1880                 branch64(MacroAssembler::Equal, valueGPR, MacroAssembler::TrustedImm64(JSValue::encode(jsBoolean(true))), taken);
1881             }
1882 
1883             value.use();
1884 
1885             JSGlobalObject* globalObject = m_jit.graph().globalObjectFor(node-&gt;origin.semantic);
1886             auto truthy = m_jit.branchIfTruthy(*m_jit.vm(), JSValueRegs(valueGPR), resultGPR, scratchGPR, valueFPR, tempFPR, shouldCheckMasqueradesAsUndefined, globalObject);
1887             addBranch(truthy, taken);
1888             jump(notTaken);
1889         }
1890 
1891         noResult(node, UseChildrenCalledExplicitly);
1892         return;
1893     }
1894 
1895     default:
1896         DFG_CRASH(m_jit.graph(), m_currentNode, &quot;Bad use kind&quot;);
1897     }
1898 }
1899 
1900 void SpeculativeJIT::compile(Node* node)
1901 {
1902     NodeType op = node-&gt;op();
1903 
1904     if (validateDFGDoesGC) {
1905         bool expectDoesGC = doesGC(m_jit.graph(), node);
1906         m_jit.store8(TrustedImm32(expectDoesGC), m_jit.vm()-&gt;heap.addressOfExpectDoesGC());
1907     }
1908 
1909 #if ENABLE(DFG_REGISTER_ALLOCATION_VALIDATION)
1910     m_jit.clearRegisterAllocationOffsets();
1911 #endif
1912 
1913     switch (op) {
1914     case JSConstant:
1915     case DoubleConstant:
1916     case Int52Constant:
1917     case PhantomDirectArguments:
1918     case PhantomClonedArguments:
1919         initConstantInfo(node);
1920         break;
1921 
1922     case LazyJSConstant:
1923         compileLazyJSConstant(node);
1924         break;
1925 
1926     case Identity: {
1927         compileIdentity(node);
1928         break;
1929     }
1930 
1931     case GetLocal: {
1932         AbstractValue&amp; value = m_state.operand(node-&gt;local());
1933 
1934         // If the CFA is tracking this variable and it found that the variable
1935         // cannot have been assigned, then don&#39;t attempt to proceed.
1936         if (value.isClear()) {
1937             m_compileOkay = false;
1938             break;
1939         }
1940 
1941         switch (node-&gt;variableAccessData()-&gt;flushFormat()) {
1942         case FlushedDouble: {
1943             FPRTemporary result(this);
1944             m_jit.loadDouble(JITCompiler::addressFor(node-&gt;machineLocal()), result.fpr());
1945             VirtualRegister virtualRegister = node-&gt;virtualRegister();
1946             m_fprs.retain(result.fpr(), virtualRegister, SpillOrderDouble);
1947             generationInfoFromVirtualRegister(virtualRegister).initDouble(node, node-&gt;refCount(), result.fpr());
1948             break;
1949         }
1950 
1951         case FlushedInt32: {
1952             GPRTemporary result(this);
1953             m_jit.load32(JITCompiler::payloadFor(node-&gt;machineLocal()), result.gpr());
1954 
1955             // Like int32Result, but don&#39;t useChildren - our children are phi nodes,
1956             // and don&#39;t represent values within this dataflow with virtual registers.
1957             VirtualRegister virtualRegister = node-&gt;virtualRegister();
1958             m_gprs.retain(result.gpr(), virtualRegister, SpillOrderInteger);
1959             generationInfoFromVirtualRegister(virtualRegister).initInt32(node, node-&gt;refCount(), result.gpr());
1960             break;
1961         }
1962 
1963         case FlushedInt52: {
1964             GPRTemporary result(this);
1965             m_jit.load64(JITCompiler::addressFor(node-&gt;machineLocal()), result.gpr());
1966 
1967             VirtualRegister virtualRegister = node-&gt;virtualRegister();
1968             m_gprs.retain(result.gpr(), virtualRegister, SpillOrderJS);
1969             generationInfoFromVirtualRegister(virtualRegister).initInt52(node, node-&gt;refCount(), result.gpr());
1970             break;
1971         }
1972 
1973         default:
1974             GPRTemporary result(this);
1975             m_jit.load64(JITCompiler::addressFor(node-&gt;machineLocal()), result.gpr());
1976 
1977             // Like jsValueResult, but don&#39;t useChildren - our children are phi nodes,
1978             // and don&#39;t represent values within this dataflow with virtual registers.
1979             VirtualRegister virtualRegister = node-&gt;virtualRegister();
1980             m_gprs.retain(result.gpr(), virtualRegister, SpillOrderJS);
1981 
1982             DataFormat format;
1983             if (isCellSpeculation(value.m_type))
1984                 format = DataFormatJSCell;
1985             else if (isBooleanSpeculation(value.m_type))
1986                 format = DataFormatJSBoolean;
1987             else
1988                 format = DataFormatJS;
1989 
1990             generationInfoFromVirtualRegister(virtualRegister).initJSValue(node, node-&gt;refCount(), result.gpr(), format);
1991             break;
1992         }
1993         break;
1994     }
1995 
1996     case MovHint: {
1997         compileMovHint(m_currentNode);
1998         noResult(node);
1999         break;
2000     }
2001 
2002     case ZombieHint: {
2003         recordSetLocal(m_currentNode-&gt;unlinkedLocal(), VirtualRegister(), DataFormatDead);
2004         noResult(node);
2005         break;
2006     }
2007 
2008     case ExitOK: {
2009         noResult(node);
2010         break;
2011     }
2012 
2013     case SetLocal: {
2014         switch (node-&gt;variableAccessData()-&gt;flushFormat()) {
2015         case FlushedDouble: {
2016             SpeculateDoubleOperand value(this, node-&gt;child1());
2017             m_jit.storeDouble(value.fpr(), JITCompiler::addressFor(node-&gt;machineLocal()));
2018             noResult(node);
2019             // Indicate that it&#39;s no longer necessary to retrieve the value of
2020             // this bytecode variable from registers or other locations in the stack,
2021             // but that it is stored as a double.
2022             recordSetLocal(DataFormatDouble);
2023             break;
2024         }
2025 
2026         case FlushedInt32: {
2027             SpeculateInt32Operand value(this, node-&gt;child1());
2028             m_jit.store32(value.gpr(), JITCompiler::payloadFor(node-&gt;machineLocal()));
2029             noResult(node);
2030             recordSetLocal(DataFormatInt32);
2031             break;
2032         }
2033 
2034         case FlushedInt52: {
2035             SpeculateInt52Operand value(this, node-&gt;child1());
2036             m_jit.store64(value.gpr(), JITCompiler::addressFor(node-&gt;machineLocal()));
2037             noResult(node);
2038             recordSetLocal(DataFormatInt52);
2039             break;
2040         }
2041 
2042         case FlushedCell: {
2043             SpeculateCellOperand cell(this, node-&gt;child1());
2044             GPRReg cellGPR = cell.gpr();
2045             m_jit.store64(cellGPR, JITCompiler::addressFor(node-&gt;machineLocal()));
2046             noResult(node);
2047             recordSetLocal(DataFormatCell);
2048             break;
2049         }
2050 
2051         case FlushedBoolean: {
2052             SpeculateBooleanOperand boolean(this, node-&gt;child1());
2053             m_jit.store64(boolean.gpr(), JITCompiler::addressFor(node-&gt;machineLocal()));
2054             noResult(node);
2055             recordSetLocal(DataFormatBoolean);
2056             break;
2057         }
2058 
2059         case FlushedJSValue: {
2060             JSValueOperand value(this, node-&gt;child1());
2061             m_jit.store64(value.gpr(), JITCompiler::addressFor(node-&gt;machineLocal()));
2062             noResult(node);
2063             recordSetLocal(dataFormatFor(node-&gt;variableAccessData()-&gt;flushFormat()));
2064             break;
2065         }
2066 
2067         default:
2068             DFG_CRASH(m_jit.graph(), node, &quot;Bad flush format&quot;);
2069             break;
2070         }
2071 
2072         break;
2073     }
2074 
2075     case SetArgument:
2076         // This is a no-op; it just marks the fact that the argument is being used.
2077         // But it may be profitable to use this as a hook to run speculation checks
2078         // on arguments, thereby allowing us to trivially eliminate such checks if
2079         // the argument is not used.
2080         recordSetLocal(dataFormatFor(node-&gt;variableAccessData()-&gt;flushFormat()));
2081         break;
2082 
2083     case ArithBitNot:
2084         compileBitwiseNot(node);
2085         break;
2086 
2087     case ValueBitAnd:
2088     case ValueBitXor:
2089     case ValueBitOr:
2090         compileValueBitwiseOp(node);
2091         break;
2092 
2093     case ArithBitAnd:
2094     case ArithBitOr:
2095     case ArithBitXor:
2096         compileBitwiseOp(node);
2097         break;
2098 
2099     case BitRShift:
2100     case BitLShift:
2101     case BitURShift:
2102         compileShiftOp(node);
2103         break;
2104 
2105     case UInt32ToNumber: {
2106         compileUInt32ToNumber(node);
2107         break;
2108     }
2109 
2110     case DoubleAsInt32: {
2111         compileDoubleAsInt32(node);
2112         break;
2113     }
2114 
2115     case ValueToInt32: {
2116         compileValueToInt32(node);
2117         break;
2118     }
2119 
2120     case DoubleRep: {
2121         compileDoubleRep(node);
2122         break;
2123     }
2124 
2125     case ValueRep: {
2126         compileValueRep(node);
2127         break;
2128     }
2129 
2130     case Int52Rep: {
2131         switch (node-&gt;child1().useKind()) {
2132         case Int32Use: {
2133             SpeculateInt32Operand operand(this, node-&gt;child1());
2134             GPRTemporary result(this, Reuse, operand);
2135 
2136             m_jit.signExtend32ToPtr(operand.gpr(), result.gpr());
2137 
2138             strictInt52Result(result.gpr(), node);
2139             break;
2140         }
2141 
2142         case AnyIntUse: {
2143             GPRTemporary result(this);
2144             GPRReg resultGPR = result.gpr();
2145 
2146             convertAnyInt(node-&gt;child1(), resultGPR);
2147 
2148             strictInt52Result(resultGPR, node);
2149             break;
2150         }
2151 
2152         case DoubleRepAnyIntUse: {
2153             SpeculateDoubleOperand value(this, node-&gt;child1());
2154             FPRReg valueFPR = value.fpr();
2155 
2156             flushRegisters();
2157             GPRFlushedCallResult result(this);
2158             GPRReg resultGPR = result.gpr();
2159             callOperation(operationConvertDoubleToInt52, resultGPR, valueFPR);
2160 
2161             DFG_TYPE_CHECK_WITH_EXIT_KIND(Int52Overflow,
2162                 JSValueRegs(), node-&gt;child1(), SpecAnyIntAsDouble,
2163                 m_jit.branch64(
2164                     JITCompiler::Equal, resultGPR,
2165                     JITCompiler::TrustedImm64(JSValue::notInt52)));
2166 
2167             strictInt52Result(resultGPR, node);
2168             break;
2169         }
2170 
2171         default:
2172             DFG_CRASH(m_jit.graph(), node, &quot;Bad use kind&quot;);
2173         }
2174         break;
2175     }
2176 
2177     case ValueNegate:
2178         compileValueNegate(node);
2179         break;
2180 
2181     case ValueAdd:
2182         compileValueAdd(node);
2183         break;
2184 
2185     case ValueSub:
2186         compileValueSub(node);
2187         break;
2188 
2189     case StrCat: {
2190         compileStrCat(node);
2191         break;
2192     }
2193 
2194     case ArithAdd:
2195         compileArithAdd(node);
2196         break;
2197 
2198     case ArithClz32:
2199         compileArithClz32(node);
2200         break;
2201 
2202     case MakeRope:
2203         compileMakeRope(node);
2204         break;
2205 
2206     case ArithSub:
2207         compileArithSub(node);
2208         break;
2209 
2210     case ArithNegate:
2211         compileArithNegate(node);
2212         break;
2213 
2214     case ArithMul:
2215         compileArithMul(node);
2216         break;
2217 
2218     case ValueMul:
2219         compileValueMul(node);
2220         break;
2221 
2222     case ValueDiv: {
2223         compileValueDiv(node);
2224         break;
2225     }
2226 
2227     case ArithDiv: {
2228         compileArithDiv(node);
2229         break;
2230     }
2231 
2232     case ArithMod: {
2233         compileArithMod(node);
2234         break;
2235     }
2236 
2237     case ArithAbs:
2238         compileArithAbs(node);
2239         break;
2240 
2241     case ArithMin:
2242     case ArithMax: {
2243         compileArithMinMax(node);
2244         break;
2245     }
2246 
2247     case ArithPow:
2248         compileArithPow(node);
2249         break;
2250 
2251     case ArithSqrt:
2252         compileArithSqrt(node);
2253         break;
2254 
2255     case ArithFRound:
2256         compileArithFRound(node);
2257         break;
2258 
2259     case ArithRandom:
2260         compileArithRandom(node);
2261         break;
2262 
2263     case ArithRound:
2264     case ArithFloor:
2265     case ArithCeil:
2266     case ArithTrunc:
2267         compileArithRounding(node);
2268         break;
2269 
2270     case ArithUnary:
2271         compileArithUnary(node);
2272         break;
2273 
2274     case LogicalNot:
2275         compileLogicalNot(node);
2276         break;
2277 
2278     case CompareLess:
2279         if (compare(node, JITCompiler::LessThan, JITCompiler::DoubleLessThan, operationCompareLess))
2280             return;
2281         break;
2282 
2283     case CompareLessEq:
2284         if (compare(node, JITCompiler::LessThanOrEqual, JITCompiler::DoubleLessThanOrEqual, operationCompareLessEq))
2285             return;
2286         break;
2287 
2288     case CompareGreater:
2289         if (compare(node, JITCompiler::GreaterThan, JITCompiler::DoubleGreaterThan, operationCompareGreater))
2290             return;
2291         break;
2292 
2293     case CompareGreaterEq:
2294         if (compare(node, JITCompiler::GreaterThanOrEqual, JITCompiler::DoubleGreaterThanOrEqual, operationCompareGreaterEq))
2295             return;
2296         break;
2297 
2298     case CompareBelow:
2299         compileCompareUnsigned(node, JITCompiler::Below);
2300         break;
2301 
2302     case CompareBelowEq:
2303         compileCompareUnsigned(node, JITCompiler::BelowOrEqual);
2304         break;
2305 
2306     case CompareEq:
2307         if (compare(node, JITCompiler::Equal, JITCompiler::DoubleEqual, operationCompareEq))
2308             return;
2309         break;
2310 
2311     case CompareStrictEq:
2312         if (compileStrictEq(node))
2313             return;
2314         break;
2315 
2316     case CompareEqPtr:
2317         compileCompareEqPtr(node);
2318         break;
2319 
2320     case SameValue:
2321         compileSameValue(node);
2322         break;
2323 
2324     case StringCharCodeAt: {
2325         compileGetCharCodeAt(node);
2326         break;
2327     }
2328 
2329     case StringCharAt: {
2330         // Relies on StringCharAt node having same basic layout as GetByVal
2331         compileGetByValOnString(node);
2332         break;
2333     }
2334 
2335     case StringFromCharCode: {
2336         compileFromCharCode(node);
2337         break;
2338     }
2339 
2340     case CheckArray: {
2341         checkArray(node);
2342         break;
2343     }
2344 
2345     case Arrayify:
2346     case ArrayifyToStructure: {
2347         arrayify(node);
2348         break;
2349     }
2350 
2351     case GetByVal: {
2352         switch (node-&gt;arrayMode().type()) {
2353         case Array::AnyTypedArray:
2354         case Array::ForceExit:
2355         case Array::SelectUsingArguments:
2356         case Array::SelectUsingPredictions:
2357         case Array::Unprofiled:
2358             DFG_CRASH(m_jit.graph(), node, &quot;Bad array mode type&quot;);
2359             break;
2360         case Array::Undecided: {
2361             SpeculateStrictInt32Operand index(this, m_graph.varArgChild(node, 1));
2362             GPRTemporary result(this, Reuse, index);
2363             GPRReg indexGPR = index.gpr();
2364             GPRReg resultGPR = result.gpr();
2365 
2366             speculationCheck(OutOfBounds, JSValueRegs(), node,
2367                 m_jit.branch32(MacroAssembler::LessThan, indexGPR, MacroAssembler::TrustedImm32(0)));
2368 
2369             use(m_graph.varArgChild(node, 0));
2370             index.use();
2371 
2372             m_jit.move(MacroAssembler::TrustedImm64(ValueUndefined), resultGPR);
2373             jsValueResult(resultGPR, node, UseChildrenCalledExplicitly);
2374             break;
2375         }
2376         case Array::Generic: {
2377             if (m_graph.varArgChild(node, 0).useKind() == ObjectUse) {
2378                 if (m_graph.varArgChild(node, 1).useKind() == StringUse) {
2379                     compileGetByValForObjectWithString(node);
2380                     break;
2381                 }
2382 
2383                 if (m_graph.varArgChild(node, 1).useKind() == SymbolUse) {
2384                     compileGetByValForObjectWithSymbol(node);
2385                     break;
2386                 }
2387             }
2388             JSValueOperand base(this, m_graph.varArgChild(node, 0));
2389             JSValueOperand property(this, m_graph.varArgChild(node, 1));
2390             GPRReg baseGPR = base.gpr();
2391             GPRReg propertyGPR = property.gpr();
2392 
2393             flushRegisters();
2394             GPRFlushedCallResult result(this);
2395             callOperation(operationGetByVal, result.gpr(), baseGPR, propertyGPR);
2396             m_jit.exceptionCheck();
2397 
2398             jsValueResult(result.gpr(), node);
2399             break;
2400         }
2401         case Array::Int32:
2402         case Array::Contiguous: {
2403             if (node-&gt;arrayMode().isInBounds()) {
2404                 SpeculateStrictInt32Operand property(this, m_graph.varArgChild(node, 1));
2405                 StorageOperand storage(this, m_graph.varArgChild(node, 2));
2406 
2407                 GPRReg propertyReg = property.gpr();
2408                 GPRReg storageReg = storage.gpr();
2409 
2410                 if (!m_compileOkay)
2411                     return;
2412 
2413                 speculationCheck(OutOfBounds, JSValueRegs(), 0, m_jit.branch32(MacroAssembler::AboveOrEqual, propertyReg, MacroAssembler::Address(storageReg, Butterfly::offsetOfPublicLength())));
2414 
2415                 GPRTemporary result(this);
2416 
2417                 m_jit.load64(MacroAssembler::BaseIndex(storageReg, propertyReg, MacroAssembler::TimesEight), result.gpr());
2418                 if (node-&gt;arrayMode().isSaneChain()) {
2419                     ASSERT(node-&gt;arrayMode().type() == Array::Contiguous);
2420                     JITCompiler::Jump notHole = m_jit.branchIfNotEmpty(result.gpr());
2421                     m_jit.move(TrustedImm64(JSValue::encode(jsUndefined())), result.gpr());
2422                     notHole.link(&amp;m_jit);
2423                 } else {
2424                     speculationCheck(
2425                         LoadFromHole, JSValueRegs(), 0,
2426                         m_jit.branchIfEmpty(result.gpr()));
2427                 }
2428                 jsValueResult(result.gpr(), node, node-&gt;arrayMode().type() == Array::Int32 ? DataFormatJSInt32 : DataFormatJS);
2429                 break;
2430             }
2431 
2432             SpeculateCellOperand base(this, m_graph.varArgChild(node, 0));
2433             SpeculateStrictInt32Operand property(this, m_graph.varArgChild(node, 1));
2434             StorageOperand storage(this, m_graph.varArgChild(node, 2));
2435 
2436             GPRReg baseReg = base.gpr();
2437             GPRReg propertyReg = property.gpr();
2438             GPRReg storageReg = storage.gpr();
2439 
2440             if (!m_compileOkay)
2441                 return;
2442 
2443             GPRTemporary result(this);
2444             GPRReg resultReg = result.gpr();
2445 
2446             MacroAssembler::JumpList slowCases;
2447 
2448             slowCases.append(m_jit.branch32(MacroAssembler::AboveOrEqual, propertyReg, MacroAssembler::Address(storageReg, Butterfly::offsetOfPublicLength())));
2449 
2450             m_jit.load64(MacroAssembler::BaseIndex(storageReg, propertyReg, MacroAssembler::TimesEight), resultReg);
2451             slowCases.append(m_jit.branchIfEmpty(resultReg));
2452 
2453             addSlowPathGenerator(
2454                 slowPathCall(
2455                     slowCases, this, operationGetByValObjectInt,
2456                     result.gpr(), baseReg, propertyReg));
2457 
2458             jsValueResult(resultReg, node);
2459             break;
2460         }
2461 
2462         case Array::Double: {
2463             if (node-&gt;arrayMode().isInBounds()) {
2464                 SpeculateStrictInt32Operand property(this, m_graph.varArgChild(node, 1));
2465                 StorageOperand storage(this, m_graph.varArgChild(node, 2));
2466 
2467                 GPRReg propertyReg = property.gpr();
2468                 GPRReg storageReg = storage.gpr();
2469 
2470                 if (!m_compileOkay)
2471                     return;
2472 
2473                 FPRTemporary result(this);
2474                 FPRReg resultReg = result.fpr();
2475 
2476                 speculationCheck(OutOfBounds, JSValueRegs(), 0, m_jit.branch32(MacroAssembler::AboveOrEqual, propertyReg, MacroAssembler::Address(storageReg, Butterfly::offsetOfPublicLength())));
2477 
2478                 m_jit.loadDouble(MacroAssembler::BaseIndex(storageReg, propertyReg, MacroAssembler::TimesEight), resultReg);
2479                 if (!node-&gt;arrayMode().isSaneChain())
2480                     speculationCheck(LoadFromHole, JSValueRegs(), 0, m_jit.branchIfNaN(resultReg));
2481                 doubleResult(resultReg, node);
2482                 break;
2483             }
2484 
2485             SpeculateCellOperand base(this, m_graph.varArgChild(node, 0));
2486             SpeculateStrictInt32Operand property(this, m_graph.varArgChild(node, 1));
2487             StorageOperand storage(this, m_graph.varArgChild(node, 2));
2488 
2489             GPRReg baseReg = base.gpr();
2490             GPRReg propertyReg = property.gpr();
2491             GPRReg storageReg = storage.gpr();
2492 
2493             if (!m_compileOkay)
2494                 return;
2495 
2496             GPRTemporary result(this);
2497             FPRTemporary temp(this);
2498             GPRReg resultReg = result.gpr();
2499             FPRReg tempReg = temp.fpr();
2500 
2501             MacroAssembler::JumpList slowCases;
2502 
2503             slowCases.append(m_jit.branch32(MacroAssembler::AboveOrEqual, propertyReg, MacroAssembler::Address(storageReg, Butterfly::offsetOfPublicLength())));
2504 
2505             m_jit.loadDouble(MacroAssembler::BaseIndex(storageReg, propertyReg, MacroAssembler::TimesEight), tempReg);
2506             slowCases.append(m_jit.branchIfNaN(tempReg));
2507             boxDouble(tempReg, resultReg);
2508 
2509             addSlowPathGenerator(
2510                 slowPathCall(
2511                     slowCases, this, operationGetByValObjectInt,
2512                     result.gpr(), baseReg, propertyReg));
2513 
2514             jsValueResult(resultReg, node);
2515             break;
2516         }
2517 
2518         case Array::ArrayStorage:
2519         case Array::SlowPutArrayStorage: {
2520             if (node-&gt;arrayMode().isInBounds()) {
2521                 SpeculateStrictInt32Operand property(this, m_graph.varArgChild(node, 1));
2522                 StorageOperand storage(this, m_graph.varArgChild(node, 2));
2523 
2524                 GPRReg propertyReg = property.gpr();
2525                 GPRReg storageReg = storage.gpr();
2526 
2527                 if (!m_compileOkay)
2528                     return;
2529 
2530                 speculationCheck(OutOfBounds, JSValueRegs(), 0, m_jit.branch32(MacroAssembler::AboveOrEqual, propertyReg, MacroAssembler::Address(storageReg, ArrayStorage::vectorLengthOffset())));
2531 
2532                 GPRTemporary result(this);
2533                 m_jit.load64(MacroAssembler::BaseIndex(storageReg, propertyReg, MacroAssembler::TimesEight, ArrayStorage::vectorOffset()), result.gpr());
2534                 speculationCheck(LoadFromHole, JSValueRegs(), 0, m_jit.branchIfEmpty(result.gpr()));
2535 
2536                 jsValueResult(result.gpr(), node);
2537                 break;
2538             }
2539 
2540             SpeculateCellOperand base(this, m_graph.varArgChild(node, 0));
2541             SpeculateStrictInt32Operand property(this, m_graph.varArgChild(node, 1));
2542             StorageOperand storage(this, m_graph.varArgChild(node, 2));
2543 
2544             GPRReg baseReg = base.gpr();
2545             GPRReg propertyReg = property.gpr();
2546             GPRReg storageReg = storage.gpr();
2547 
2548             if (!m_compileOkay)
2549                 return;
2550 
2551             GPRTemporary result(this);
2552             GPRReg resultReg = result.gpr();
2553 
2554             MacroAssembler::JumpList slowCases;
2555 
2556             slowCases.append(m_jit.branch32(MacroAssembler::AboveOrEqual, propertyReg, MacroAssembler::Address(storageReg, ArrayStorage::vectorLengthOffset())));
2557 
2558             m_jit.load64(MacroAssembler::BaseIndex(storageReg, propertyReg, MacroAssembler::TimesEight, ArrayStorage::vectorOffset()), resultReg);
2559             slowCases.append(m_jit.branchIfEmpty(resultReg));
2560 
2561             addSlowPathGenerator(
2562                 slowPathCall(
2563                     slowCases, this, operationGetByValObjectInt,
2564                     result.gpr(), baseReg, propertyReg));
2565 
2566             jsValueResult(resultReg, node);
2567             break;
2568         }
2569         case Array::String:
2570             compileGetByValOnString(node);
2571             break;
2572         case Array::DirectArguments:
2573             compileGetByValOnDirectArguments(node);
2574             break;
2575         case Array::ScopedArguments:
2576             compileGetByValOnScopedArguments(node);
2577             break;
2578         case Array::Int8Array:
2579         case Array::Int16Array:
2580         case Array::Int32Array:
2581         case Array::Uint8Array:
2582         case Array::Uint8ClampedArray:
2583         case Array::Uint16Array:
2584         case Array::Uint32Array:
2585         case Array::Float32Array:
2586         case Array::Float64Array: {
2587             TypedArrayType type = node-&gt;arrayMode().typedArrayType();
2588             if (isInt(type))
2589                 compileGetByValOnIntTypedArray(node, type);
2590             else
2591                 compileGetByValOnFloatTypedArray(node, type);
2592         } }
2593         break;
2594     }
2595 
2596     case GetByValWithThis: {
2597         compileGetByValWithThis(node);
2598         break;
2599     }
2600 
2601     case PutByValDirect:
2602     case PutByVal:
2603     case PutByValAlias: {
2604         Edge child1 = m_jit.graph().varArgChild(node, 0);
2605         Edge child2 = m_jit.graph().varArgChild(node, 1);
2606         Edge child3 = m_jit.graph().varArgChild(node, 2);
2607         Edge child4 = m_jit.graph().varArgChild(node, 3);
2608 
2609         ArrayMode arrayMode = node-&gt;arrayMode().modeForPut();
2610         bool alreadyHandled = false;
2611 
2612         switch (arrayMode.type()) {
2613         case Array::SelectUsingPredictions:
2614         case Array::ForceExit:
2615             DFG_CRASH(m_jit.graph(), node, &quot;Bad array mode type&quot;);
2616             break;
2617         case Array::Generic: {
2618             DFG_ASSERT(m_jit.graph(), node, node-&gt;op() == PutByVal || node-&gt;op() == PutByValDirect, node-&gt;op());
2619 
2620             if (child1.useKind() == CellUse) {
2621                 if (child2.useKind() == StringUse) {
2622                     compilePutByValForCellWithString(node, child1, child2, child3);
2623                     alreadyHandled = true;
2624                     break;
2625                 }
2626 
2627                 if (child2.useKind() == SymbolUse) {
2628                     compilePutByValForCellWithSymbol(node, child1, child2, child3);
2629                     alreadyHandled = true;
2630                     break;
2631                 }
2632             }
2633 
2634             JSValueOperand arg1(this, child1);
2635             JSValueOperand arg2(this, child2);
2636             JSValueOperand arg3(this, child3);
2637             GPRReg arg1GPR = arg1.gpr();
2638             GPRReg arg2GPR = arg2.gpr();
2639             GPRReg arg3GPR = arg3.gpr();
2640             flushRegisters();
2641             if (node-&gt;op() == PutByValDirect)
2642                 callOperation(m_jit.isStrictModeFor(node-&gt;origin.semantic) ? operationPutByValDirectStrict : operationPutByValDirectNonStrict, arg1GPR, arg2GPR, arg3GPR);
2643             else
2644                 callOperation(m_jit.isStrictModeFor(node-&gt;origin.semantic) ? operationPutByValStrict : operationPutByValNonStrict, arg1GPR, arg2GPR, arg3GPR);
2645             m_jit.exceptionCheck();
2646 
2647             noResult(node);
2648             alreadyHandled = true;
2649             break;
2650         }
2651         default:
2652             break;
2653         }
2654 
2655         if (alreadyHandled)
2656             break;
2657 
2658         SpeculateCellOperand base(this, child1);
2659         SpeculateStrictInt32Operand property(this, child2);
2660 
2661         GPRReg baseReg = base.gpr();
2662         GPRReg propertyReg = property.gpr();
2663 
2664         switch (arrayMode.type()) {
2665         case Array::Int32:
2666         case Array::Contiguous: {
2667             JSValueOperand value(this, child3, ManualOperandSpeculation);
2668 
2669             GPRReg valueReg = value.gpr();
2670 
2671             if (!m_compileOkay)
2672                 return;
2673 
2674             if (arrayMode.type() == Array::Int32) {
2675                 DFG_TYPE_CHECK(
2676                     JSValueRegs(valueReg), child3, SpecInt32Only,
2677                     m_jit.branchIfNotInt32(valueReg));
2678             }
2679 
2680             StorageOperand storage(this, child4);
2681             GPRReg storageReg = storage.gpr();
2682 
2683             if (node-&gt;op() == PutByValAlias) {
2684                 // Store the value to the array.
2685                 GPRReg propertyReg = property.gpr();
2686                 GPRReg valueReg = value.gpr();
2687                 m_jit.store64(valueReg, MacroAssembler::BaseIndex(storageReg, propertyReg, MacroAssembler::TimesEight));
2688 
2689                 noResult(node);
2690                 break;
2691             }
2692 
2693             GPRTemporary temporary;
2694             GPRReg temporaryReg = temporaryRegisterForPutByVal(temporary, node);
2695 
2696             MacroAssembler::Jump slowCase;
2697 
2698             if (arrayMode.isInBounds()) {
2699                 speculationCheck(
2700                     OutOfBounds, JSValueRegs(), 0,
2701                     m_jit.branch32(MacroAssembler::AboveOrEqual, propertyReg, MacroAssembler::Address(storageReg, Butterfly::offsetOfPublicLength())));
2702             } else {
2703                 MacroAssembler::Jump inBounds = m_jit.branch32(MacroAssembler::Below, propertyReg, MacroAssembler::Address(storageReg, Butterfly::offsetOfPublicLength()));
2704 
2705                 slowCase = m_jit.branch32(MacroAssembler::AboveOrEqual, propertyReg, MacroAssembler::Address(storageReg, Butterfly::offsetOfVectorLength()));
2706 
2707                 if (!arrayMode.isOutOfBounds())
2708                     speculationCheck(OutOfBounds, JSValueRegs(), 0, slowCase);
2709 
2710                 m_jit.add32(TrustedImm32(1), propertyReg, temporaryReg);
2711                 m_jit.store32(temporaryReg, MacroAssembler::Address(storageReg, Butterfly::offsetOfPublicLength()));
2712 
2713                 inBounds.link(&amp;m_jit);
2714             }
2715 
2716             m_jit.store64(valueReg, MacroAssembler::BaseIndex(storageReg, propertyReg, MacroAssembler::TimesEight));
2717 
2718             base.use();
2719             property.use();
2720             value.use();
2721             storage.use();
2722 
2723             if (arrayMode.isOutOfBounds()) {
2724                 addSlowPathGenerator(slowPathCall(
2725                     slowCase, this,
2726                     m_jit.codeBlock()-&gt;isStrictMode()
2727                         ? (node-&gt;op() == PutByValDirect ? operationPutByValDirectBeyondArrayBoundsStrict : operationPutByValBeyondArrayBoundsStrict)
2728                         : (node-&gt;op() == PutByValDirect ? operationPutByValDirectBeyondArrayBoundsNonStrict : operationPutByValBeyondArrayBoundsNonStrict),
2729                     NoResult, baseReg, propertyReg, valueReg));
2730             }
2731 
2732             noResult(node, UseChildrenCalledExplicitly);
2733             break;
2734         }
2735 
2736         case Array::Double: {
2737             compileDoublePutByVal(node, base, property);
2738             break;
2739         }
2740 
2741         case Array::ArrayStorage:
2742         case Array::SlowPutArrayStorage: {
2743             JSValueOperand value(this, child3);
2744 
2745             GPRReg valueReg = value.gpr();
2746 
2747             if (!m_compileOkay)
2748                 return;
2749 
2750             StorageOperand storage(this, child4);
2751             GPRReg storageReg = storage.gpr();
2752 
2753             if (node-&gt;op() == PutByValAlias) {
2754                 // Store the value to the array.
2755                 GPRReg propertyReg = property.gpr();
2756                 GPRReg valueReg = value.gpr();
2757                 m_jit.store64(valueReg, MacroAssembler::BaseIndex(storageReg, propertyReg, MacroAssembler::TimesEight, ArrayStorage::vectorOffset()));
2758 
2759                 noResult(node);
2760                 break;
2761             }
2762 
2763             GPRTemporary temporary;
2764             GPRReg temporaryReg = temporaryRegisterForPutByVal(temporary, node);
2765 
2766             MacroAssembler::JumpList slowCases;
2767 
2768             MacroAssembler::Jump beyondArrayBounds = m_jit.branch32(MacroAssembler::AboveOrEqual, propertyReg, MacroAssembler::Address(storageReg, ArrayStorage::vectorLengthOffset()));
2769             if (!arrayMode.isOutOfBounds())
2770                 speculationCheck(OutOfBounds, JSValueRegs(), 0, beyondArrayBounds);
2771             else
2772                 slowCases.append(beyondArrayBounds);
2773 
2774             // Check if we&#39;re writing to a hole; if so increment m_numValuesInVector.
2775             if (arrayMode.isInBounds()) {
2776                 speculationCheck(
2777                     StoreToHole, JSValueRegs(), 0,
2778                     m_jit.branchTest64(MacroAssembler::Zero, MacroAssembler::BaseIndex(storageReg, propertyReg, MacroAssembler::TimesEight, ArrayStorage::vectorOffset())));
2779             } else {
2780                 MacroAssembler::Jump notHoleValue = m_jit.branchTest64(MacroAssembler::NonZero, MacroAssembler::BaseIndex(storageReg, propertyReg, MacroAssembler::TimesEight, ArrayStorage::vectorOffset()));
2781                 if (arrayMode.isSlowPut()) {
2782                     // This is sort of strange. If we wanted to optimize this code path, we would invert
2783                     // the above branch. But it&#39;s simply not worth it since this only happens if we&#39;re
2784                     // already having a bad time.
2785                     slowCases.append(m_jit.jump());
2786                 } else {
2787                     m_jit.add32(TrustedImm32(1), MacroAssembler::Address(storageReg, ArrayStorage::numValuesInVectorOffset()));
2788 
2789                     // If we&#39;re writing to a hole we might be growing the array;
2790                     MacroAssembler::Jump lengthDoesNotNeedUpdate = m_jit.branch32(MacroAssembler::Below, propertyReg, MacroAssembler::Address(storageReg, ArrayStorage::lengthOffset()));
2791                     m_jit.add32(TrustedImm32(1), propertyReg, temporaryReg);
2792                     m_jit.store32(temporaryReg, MacroAssembler::Address(storageReg, ArrayStorage::lengthOffset()));
2793 
2794                     lengthDoesNotNeedUpdate.link(&amp;m_jit);
2795                 }
2796                 notHoleValue.link(&amp;m_jit);
2797             }
2798 
2799             // Store the value to the array.
2800             m_jit.store64(valueReg, MacroAssembler::BaseIndex(storageReg, propertyReg, MacroAssembler::TimesEight, ArrayStorage::vectorOffset()));
2801 
2802             base.use();
2803             property.use();
2804             value.use();
2805             storage.use();
2806 
2807             if (!slowCases.empty()) {
2808                 addSlowPathGenerator(slowPathCall(
2809                     slowCases, this,
2810                     m_jit.codeBlock()-&gt;isStrictMode()
2811                         ? (node-&gt;op() == PutByValDirect ? operationPutByValDirectBeyondArrayBoundsStrict : operationPutByValBeyondArrayBoundsStrict)
2812                         : (node-&gt;op() == PutByValDirect ? operationPutByValDirectBeyondArrayBoundsNonStrict : operationPutByValBeyondArrayBoundsNonStrict),
2813                     NoResult, baseReg, propertyReg, valueReg));
2814             }
2815 
2816             noResult(node, UseChildrenCalledExplicitly);
2817             break;
2818         }
2819 
2820         case Array::Int8Array:
2821         case Array::Int16Array:
2822         case Array::Int32Array:
2823         case Array::Uint8Array:
2824         case Array::Uint8ClampedArray:
2825         case Array::Uint16Array:
2826         case Array::Uint32Array:
2827         case Array::Float32Array:
2828         case Array::Float64Array: {
2829             TypedArrayType type = arrayMode.typedArrayType();
2830             if (isInt(type))
2831                 compilePutByValForIntTypedArray(base.gpr(), property.gpr(), node, type);
2832             else
2833                 compilePutByValForFloatTypedArray(base.gpr(), property.gpr(), node, type);
2834             break;
2835         }
2836 
2837         case Array::AnyTypedArray:
2838         case Array::String:
2839         case Array::DirectArguments:
2840         case Array::ForceExit:
2841         case Array::Generic:
2842         case Array::ScopedArguments:
2843         case Array::SelectUsingArguments:
2844         case Array::SelectUsingPredictions:
2845         case Array::Undecided:
2846         case Array::Unprofiled:
2847             RELEASE_ASSERT_NOT_REACHED();
2848         }
2849         break;
2850     }
2851 
2852     case AtomicsAdd:
2853     case AtomicsAnd:
2854     case AtomicsCompareExchange:
2855     case AtomicsExchange:
2856     case AtomicsLoad:
2857     case AtomicsOr:
2858     case AtomicsStore:
2859     case AtomicsSub:
2860     case AtomicsXor: {
2861         unsigned numExtraArgs = numExtraAtomicsArgs(node-&gt;op());
2862         Edge baseEdge = m_jit.graph().child(node, 0);
2863         Edge indexEdge = m_jit.graph().child(node, 1);
2864         Edge argEdges[maxNumExtraAtomicsArgs];
2865         for (unsigned i = numExtraArgs; i--;)
2866             argEdges[i] = m_jit.graph().child(node, 2 + i);
2867         Edge storageEdge = m_jit.graph().child(node, 2 + numExtraArgs);
2868 
2869         GPRReg baseGPR;
2870         GPRReg indexGPR;
2871         GPRReg argGPRs[2];
2872         GPRReg resultGPR;
2873 
2874         auto callSlowPath = [&amp;] () {
2875             switch (node-&gt;op()) {
2876             case AtomicsAdd:
2877                 callOperation(operationAtomicsAdd, resultGPR, baseGPR, indexGPR, argGPRs[0]);
2878                 break;
2879             case AtomicsAnd:
2880                 callOperation(operationAtomicsAnd, resultGPR, baseGPR, indexGPR, argGPRs[0]);
2881                 break;
2882             case AtomicsCompareExchange:
2883                 callOperation(operationAtomicsCompareExchange, resultGPR, baseGPR, indexGPR, argGPRs[0], argGPRs[1]);
2884                 break;
2885             case AtomicsExchange:
2886                 callOperation(operationAtomicsExchange, resultGPR, baseGPR, indexGPR, argGPRs[0]);
2887                 break;
2888             case AtomicsLoad:
2889                 callOperation(operationAtomicsLoad, resultGPR, baseGPR, indexGPR);
2890                 break;
2891             case AtomicsOr:
2892                 callOperation(operationAtomicsOr, resultGPR, baseGPR, indexGPR, argGPRs[0]);
2893                 break;
2894             case AtomicsStore:
2895                 callOperation(operationAtomicsStore, resultGPR, baseGPR, indexGPR, argGPRs[0]);
2896                 break;
2897             case AtomicsSub:
2898                 callOperation(operationAtomicsSub, resultGPR, baseGPR, indexGPR, argGPRs[0]);
2899                 break;
2900             case AtomicsXor:
2901                 callOperation(operationAtomicsXor, resultGPR, baseGPR, indexGPR, argGPRs[0]);
2902                 break;
2903             default:
2904                 RELEASE_ASSERT_NOT_REACHED();
2905                 break;
2906             }
2907         };
2908 
2909         if (!storageEdge) {
2910             // We are in generic mode!
2911             JSValueOperand base(this, baseEdge);
2912             JSValueOperand index(this, indexEdge);
2913             Optional&lt;JSValueOperand&gt; args[2];
2914             baseGPR = base.gpr();
2915             indexGPR = index.gpr();
2916             for (unsigned i = numExtraArgs; i--;) {
2917                 args[i].emplace(this, argEdges[i]);
2918                 argGPRs[i] = args[i]-&gt;gpr();
2919             }
2920 
2921             flushRegisters();
2922             GPRFlushedCallResult result(this);
2923             resultGPR = result.gpr();
2924             callSlowPath();
2925             m_jit.exceptionCheck();
2926 
2927             jsValueResult(resultGPR, node);
2928             break;
2929         }
2930 
2931         TypedArrayType type = node-&gt;arrayMode().typedArrayType();
2932 
2933         SpeculateCellOperand base(this, baseEdge);
2934         SpeculateStrictInt32Operand index(this, indexEdge);
2935 
2936         baseGPR = base.gpr();
2937         indexGPR = index.gpr();
2938 
2939         emitTypedArrayBoundsCheck(node, baseGPR, indexGPR);
2940 
2941         GPRTemporary args[2];
2942 
2943         JITCompiler::JumpList slowPathCases;
2944 
2945         bool ok = true;
2946         for (unsigned i = numExtraArgs; i--;) {
2947             if (!getIntTypedArrayStoreOperand(args[i], indexGPR, argEdges[i], slowPathCases)) {
2948                 noResult(node);
2949                 ok = false;
2950             }
2951             argGPRs[i] = args[i].gpr();
2952         }
2953         if (!ok)
2954             break;
2955 
2956         StorageOperand storage(this, storageEdge);
2957         GPRTemporary oldValue(this);
2958         GPRTemporary result(this);
2959         GPRTemporary newValue(this);
2960         GPRReg storageGPR = storage.gpr();
2961         GPRReg oldValueGPR = oldValue.gpr();
2962         resultGPR = result.gpr();
2963         GPRReg newValueGPR = newValue.gpr();
2964 
2965         // FIXME: It shouldn&#39;t be necessary to nop-pad between register allocation and a jump label.
2966         // https://bugs.webkit.org/show_bug.cgi?id=170974
2967         m_jit.nop();
2968 
2969         JITCompiler::Label loop = m_jit.label();
2970 
2971         loadFromIntTypedArray(storageGPR, indexGPR, oldValueGPR, type);
2972         m_jit.move(oldValueGPR, newValueGPR);
2973         m_jit.move(oldValueGPR, resultGPR);
2974 
2975         switch (node-&gt;op()) {
2976         case AtomicsAdd:
2977             m_jit.add32(argGPRs[0], newValueGPR);
2978             break;
2979         case AtomicsAnd:
2980             m_jit.and32(argGPRs[0], newValueGPR);
2981             break;
2982         case AtomicsCompareExchange: {
2983             switch (elementSize(type)) {
2984             case 1:
2985                 if (isSigned(type))
2986                     m_jit.signExtend8To32(argGPRs[0], argGPRs[0]);
2987                 else
2988                     m_jit.and32(TrustedImm32(0xff), argGPRs[0]);
2989                 break;
2990             case 2:
2991                 if (isSigned(type))
2992                     m_jit.signExtend16To32(argGPRs[0], argGPRs[0]);
2993                 else
2994                     m_jit.and32(TrustedImm32(0xffff), argGPRs[0]);
2995                 break;
2996             case 4:
2997                 break;
2998             default:
2999                 RELEASE_ASSERT_NOT_REACHED();
3000                 break;
3001             }
3002             JITCompiler::Jump fail = m_jit.branch32(JITCompiler::NotEqual, oldValueGPR, argGPRs[0]);
3003             m_jit.move(argGPRs[1], newValueGPR);
3004             fail.link(&amp;m_jit);
3005             break;
3006         }
3007         case AtomicsExchange:
3008             m_jit.move(argGPRs[0], newValueGPR);
3009             break;
3010         case AtomicsLoad:
3011             break;
3012         case AtomicsOr:
3013             m_jit.or32(argGPRs[0], newValueGPR);
3014             break;
3015         case AtomicsStore:
3016             m_jit.move(argGPRs[0], newValueGPR);
3017             m_jit.move(argGPRs[0], resultGPR);
3018             break;
3019         case AtomicsSub:
3020             m_jit.sub32(argGPRs[0], newValueGPR);
3021             break;
3022         case AtomicsXor:
3023             m_jit.xor32(argGPRs[0], newValueGPR);
3024             break;
3025         default:
3026             RELEASE_ASSERT_NOT_REACHED();
3027             break;
3028         }
3029 
3030         JITCompiler::JumpList success;
3031         switch (elementSize(type)) {
3032         case 1:
3033             success = m_jit.branchAtomicWeakCAS8(JITCompiler::Success, oldValueGPR, newValueGPR, JITCompiler::BaseIndex(storageGPR, indexGPR, MacroAssembler::TimesOne));
3034             break;
3035         case 2:
3036             success = m_jit.branchAtomicWeakCAS16(JITCompiler::Success, oldValueGPR, newValueGPR, JITCompiler::BaseIndex(storageGPR, indexGPR, MacroAssembler::TimesTwo));
3037             break;
3038         case 4:
3039             success = m_jit.branchAtomicWeakCAS32(JITCompiler::Success, oldValueGPR, newValueGPR, JITCompiler::BaseIndex(storageGPR, indexGPR, MacroAssembler::TimesFour));
3040             break;
3041         default:
3042             RELEASE_ASSERT_NOT_REACHED();
3043             break;
3044         }
3045         m_jit.jump().linkTo(loop, &amp;m_jit);
3046 
3047         if (!slowPathCases.empty()) {
3048             slowPathCases.link(&amp;m_jit);
3049             silentSpillAllRegisters(resultGPR);
3050             // Since we spilled, we can do things to registers.
3051             m_jit.boxCell(baseGPR, JSValueRegs(baseGPR));
3052             m_jit.boxInt32(indexGPR, JSValueRegs(indexGPR));
3053             for (unsigned i = numExtraArgs; i--;)
3054                 m_jit.boxInt32(argGPRs[i], JSValueRegs(argGPRs[i]));
3055             callSlowPath();
3056             silentFillAllRegisters();
3057             m_jit.exceptionCheck();
3058         }
3059 
3060         success.link(&amp;m_jit);
3061         setIntTypedArrayLoadResult(node, resultGPR, type);
3062         break;
3063     }
3064 
3065     case AtomicsIsLockFree: {
3066         if (node-&gt;child1().useKind() != Int32Use) {
3067             JSValueOperand operand(this, node-&gt;child1());
3068             GPRReg operandGPR = operand.gpr();
3069             flushRegisters();
3070             GPRFlushedCallResult result(this);
3071             GPRReg resultGPR = result.gpr();
3072             callOperation(operationAtomicsIsLockFree, resultGPR, operandGPR);
3073             m_jit.exceptionCheck();
3074             jsValueResult(resultGPR, node);
3075             break;
3076         }
3077 
3078         SpeculateInt32Operand operand(this, node-&gt;child1());
3079         GPRTemporary result(this);
3080         GPRReg operandGPR = operand.gpr();
3081         GPRReg resultGPR = result.gpr();
3082         m_jit.move(TrustedImm32(ValueTrue), resultGPR);
3083         JITCompiler::JumpList done;
3084         done.append(m_jit.branch32(JITCompiler::Equal, operandGPR, TrustedImm32(4)));
3085         done.append(m_jit.branch32(JITCompiler::Equal, operandGPR, TrustedImm32(1)));
3086         done.append(m_jit.branch32(JITCompiler::Equal, operandGPR, TrustedImm32(2)));
3087         m_jit.move(TrustedImm32(ValueFalse), resultGPR);
3088         done.link(&amp;m_jit);
3089         jsValueResult(resultGPR, node);
3090         break;
3091     }
3092 
3093     case RegExpExec: {
3094         compileRegExpExec(node);
3095         break;
3096     }
3097 
3098     case RegExpExecNonGlobalOrSticky: {
3099         compileRegExpExecNonGlobalOrSticky(node);
3100         break;
3101     }
3102 
3103     case RegExpMatchFastGlobal: {
3104         compileRegExpMatchFastGlobal(node);
3105         break;
3106     }
3107 
3108     case RegExpTest: {
3109         compileRegExpTest(node);
3110         break;
3111     }
3112 
3113     case RegExpMatchFast: {
3114         compileRegExpMatchFast(node);
3115         break;
3116     }
3117 
3118     case StringReplace:
3119     case StringReplaceRegExp: {
3120         compileStringReplace(node);
3121         break;
3122     }
3123 
3124     case GetRegExpObjectLastIndex: {
3125         compileGetRegExpObjectLastIndex(node);
3126         break;
3127     }
3128 
3129     case SetRegExpObjectLastIndex: {
3130         compileSetRegExpObjectLastIndex(node);
3131         break;
3132     }
3133 
3134     case RecordRegExpCachedResult: {
3135         compileRecordRegExpCachedResult(node);
3136         break;
3137     }
3138 
3139     case ArrayPush: {
3140         compileArrayPush(node);
3141         break;
3142     }
3143 
3144     case ArraySlice: {
3145         compileArraySlice(node);
3146         break;
3147     }
3148 
3149     case ArrayIndexOf: {
3150         compileArrayIndexOf(node);
3151         break;
3152     }
3153 
3154     case ArrayPop: {
3155         ASSERT(node-&gt;arrayMode().isJSArray());
3156 
3157         SpeculateCellOperand base(this, node-&gt;child1());
3158         StorageOperand storage(this, node-&gt;child2());
3159         GPRTemporary value(this);
3160         GPRTemporary storageLength(this);
3161         FPRTemporary temp(this); // This is kind of lame, since we don&#39;t always need it. I&#39;m relying on the fact that we don&#39;t have FPR pressure, especially in code that uses pop().
3162 
3163         GPRReg baseGPR = base.gpr();
3164         GPRReg storageGPR = storage.gpr();
3165         GPRReg valueGPR = value.gpr();
3166         GPRReg storageLengthGPR = storageLength.gpr();
3167         FPRReg tempFPR = temp.fpr();
3168 
3169         switch (node-&gt;arrayMode().type()) {
3170         case Array::Int32:
3171         case Array::Double:
3172         case Array::Contiguous: {
3173             m_jit.load32(
3174                 MacroAssembler::Address(storageGPR, Butterfly::offsetOfPublicLength()), storageLengthGPR);
3175             MacroAssembler::Jump undefinedCase =
3176                 m_jit.branchTest32(MacroAssembler::Zero, storageLengthGPR);
3177             m_jit.sub32(TrustedImm32(1), storageLengthGPR);
3178             m_jit.store32(
3179                 storageLengthGPR, MacroAssembler::Address(storageGPR, Butterfly::offsetOfPublicLength()));
3180             MacroAssembler::Jump slowCase;
3181             if (node-&gt;arrayMode().type() == Array::Double) {
3182                 m_jit.loadDouble(
3183                     MacroAssembler::BaseIndex(storageGPR, storageLengthGPR, MacroAssembler::TimesEight),
3184                     tempFPR);
3185                 // FIXME: This would not have to be here if changing the publicLength also zeroed the values between the old
3186                 // length and the new length.
3187                 m_jit.store64(
3188                     MacroAssembler::TrustedImm64(bitwise_cast&lt;int64_t&gt;(PNaN)), MacroAssembler::BaseIndex(storageGPR, storageLengthGPR, MacroAssembler::TimesEight));
3189                 slowCase = m_jit.branchIfNaN(tempFPR);
3190                 boxDouble(tempFPR, valueGPR);
3191             } else {
3192                 m_jit.load64(
3193                     MacroAssembler::BaseIndex(storageGPR, storageLengthGPR, MacroAssembler::TimesEight),
3194                     valueGPR);
3195                 // FIXME: This would not have to be here if changing the publicLength also zeroed the values between the old
3196                 // length and the new length.
3197                 m_jit.store64(
3198                 MacroAssembler::TrustedImm64((int64_t)0), MacroAssembler::BaseIndex(storageGPR, storageLengthGPR, MacroAssembler::TimesEight));
3199                 slowCase = m_jit.branchIfEmpty(valueGPR);
3200             }
3201 
3202             addSlowPathGenerator(
3203                 slowPathMove(
3204                     undefinedCase, this,
3205                     MacroAssembler::TrustedImm64(JSValue::encode(jsUndefined())), valueGPR));
3206             addSlowPathGenerator(
3207                 slowPathCall(
3208                     slowCase, this, operationArrayPopAndRecoverLength, valueGPR, baseGPR));
3209 
3210             // We can&#39;t know for sure that the result is an int because of the slow paths. :-/
3211             jsValueResult(valueGPR, node);
3212             break;
3213         }
3214 
3215         case Array::ArrayStorage: {
3216             m_jit.load32(MacroAssembler::Address(storageGPR, ArrayStorage::lengthOffset()), storageLengthGPR);
3217 
3218             JITCompiler::Jump undefinedCase =
3219                 m_jit.branchTest32(MacroAssembler::Zero, storageLengthGPR);
3220 
3221             m_jit.sub32(TrustedImm32(1), storageLengthGPR);
3222 
3223             JITCompiler::JumpList slowCases;
3224             slowCases.append(m_jit.branch32(MacroAssembler::AboveOrEqual, storageLengthGPR, MacroAssembler::Address(storageGPR, ArrayStorage::vectorLengthOffset())));
3225 
3226             m_jit.load64(MacroAssembler::BaseIndex(storageGPR, storageLengthGPR, MacroAssembler::TimesEight, ArrayStorage::vectorOffset()), valueGPR);
3227             slowCases.append(m_jit.branchIfEmpty(valueGPR));
3228 
3229             m_jit.store32(storageLengthGPR, MacroAssembler::Address(storageGPR, ArrayStorage::lengthOffset()));
3230 
3231             m_jit.store64(MacroAssembler::TrustedImm64((int64_t)0), MacroAssembler::BaseIndex(storageGPR, storageLengthGPR, MacroAssembler::TimesEight,  ArrayStorage::vectorOffset()));
3232             m_jit.sub32(MacroAssembler::TrustedImm32(1), MacroAssembler::Address(storageGPR, OBJECT_OFFSETOF(ArrayStorage, m_numValuesInVector)));
3233 
3234             addSlowPathGenerator(
3235                 slowPathMove(
3236                     undefinedCase, this,
3237                     MacroAssembler::TrustedImm64(JSValue::encode(jsUndefined())), valueGPR));
3238 
3239             addSlowPathGenerator(
3240                 slowPathCall(
3241                     slowCases, this, operationArrayPop, valueGPR, baseGPR));
3242 
3243             jsValueResult(valueGPR, node);
3244             break;
3245         }
3246 
3247         default:
3248             CRASH();
3249             break;
3250         }
3251         break;
3252     }
3253 
3254     case DFG::Jump: {
3255         jump(node-&gt;targetBlock());
3256         noResult(node);
3257         break;
3258     }
3259 
3260     case Branch:
3261         emitBranch(node);
3262         break;
3263 
3264     case Switch:
3265         emitSwitch(node);
3266         break;
3267 
3268     case Return: {
3269         ASSERT(GPRInfo::callFrameRegister != GPRInfo::regT1);
3270         ASSERT(GPRInfo::regT1 != GPRInfo::returnValueGPR);
3271         ASSERT(GPRInfo::returnValueGPR != GPRInfo::callFrameRegister);
3272 
3273         // Return the result in returnValueGPR.
3274         JSValueOperand op1(this, node-&gt;child1());
3275         m_jit.move(op1.gpr(), GPRInfo::returnValueGPR);
3276 
3277         m_jit.emitRestoreCalleeSaves();
3278         m_jit.emitFunctionEpilogue();
3279         m_jit.ret();
3280 
3281         noResult(node);
3282         break;
3283     }
3284 
3285     case Throw: {
3286         compileThrow(node);
3287         break;
3288     }
3289 
3290     case ThrowStaticError: {
3291         compileThrowStaticError(node);
3292         break;
3293     }
3294 
3295     case BooleanToNumber: {
3296         switch (node-&gt;child1().useKind()) {
3297         case BooleanUse: {
3298             JSValueOperand value(this, node-&gt;child1(), ManualOperandSpeculation);
3299             GPRTemporary result(this); // FIXME: We could reuse, but on speculation fail would need recovery to restore tag (akin to add).
3300 
3301             m_jit.move(value.gpr(), result.gpr());
3302             m_jit.xor64(TrustedImm32(static_cast&lt;int32_t&gt;(ValueFalse)), result.gpr());
3303             DFG_TYPE_CHECK(
3304                 JSValueRegs(value.gpr()), node-&gt;child1(), SpecBoolean, m_jit.branchTest64(
3305                     JITCompiler::NonZero, result.gpr(), TrustedImm32(static_cast&lt;int32_t&gt;(~1))));
3306 
3307             int32Result(result.gpr(), node);
3308             break;
3309         }
3310 
3311         case UntypedUse: {
3312             JSValueOperand value(this, node-&gt;child1());
3313             GPRTemporary result(this);
3314 
3315             if (!m_interpreter.needsTypeCheck(node-&gt;child1(), SpecBoolInt32 | SpecBoolean)) {
3316                 m_jit.move(value.gpr(), result.gpr());
3317                 m_jit.and32(TrustedImm32(1), result.gpr());
3318                 int32Result(result.gpr(), node);
3319                 break;
3320             }
3321 
3322             m_jit.move(value.gpr(), result.gpr());
3323             m_jit.xor64(TrustedImm32(static_cast&lt;int32_t&gt;(ValueFalse)), result.gpr());
3324             JITCompiler::Jump isBoolean = m_jit.branchTest64(
3325                 JITCompiler::Zero, result.gpr(), TrustedImm32(static_cast&lt;int32_t&gt;(~1)));
3326             m_jit.move(value.gpr(), result.gpr());
3327             JITCompiler::Jump done = m_jit.jump();
3328             isBoolean.link(&amp;m_jit);
3329             m_jit.or64(GPRInfo::tagTypeNumberRegister, result.gpr());
3330             done.link(&amp;m_jit);
3331 
3332             jsValueResult(result.gpr(), node);
3333             break;
3334         }
3335 
3336         default:
3337             DFG_CRASH(m_jit.graph(), node, &quot;Bad use kind&quot;);
3338             break;
3339         }
3340         break;
3341     }
3342 
3343     case ToPrimitive: {
3344         compileToPrimitive(node);
3345         break;
3346     }
3347 
3348     case ToNumber: {
3349         JSValueOperand argument(this, node-&gt;child1());
3350         GPRTemporary result(this, Reuse, argument);
3351 
3352         GPRReg argumentGPR = argument.gpr();
3353         GPRReg resultGPR = result.gpr();
3354 
3355         argument.use();
3356 
3357         // We have several attempts to remove ToNumber. But ToNumber still exists.
3358         // It means that converting non-numbers to numbers by this ToNumber is not rare.
3359         // Instead of the slow path generator, we emit callOperation here.
3360         if (!(m_state.forNode(node-&gt;child1()).m_type &amp; SpecBytecodeNumber)) {
3361             flushRegisters();
3362             callOperation(operationToNumber, resultGPR, argumentGPR);
3363             m_jit.exceptionCheck();
3364         } else {
3365             MacroAssembler::Jump notNumber = m_jit.branchIfNotNumber(argumentGPR);
3366             m_jit.move(argumentGPR, resultGPR);
3367             MacroAssembler::Jump done = m_jit.jump();
3368 
3369             notNumber.link(&amp;m_jit);
3370             silentSpillAllRegisters(resultGPR);
3371             callOperation(operationToNumber, resultGPR, argumentGPR);
3372             silentFillAllRegisters();
3373             m_jit.exceptionCheck();
3374 
3375             done.link(&amp;m_jit);
3376         }
3377 
3378         jsValueResult(resultGPR, node, UseChildrenCalledExplicitly);
3379         break;
3380     }
3381 
3382     case ToString:
3383     case CallStringConstructor:
3384     case StringValueOf: {
3385         compileToStringOrCallStringConstructorOrStringValueOf(node);
3386         break;
3387     }
3388 
3389     case NewStringObject: {
3390         compileNewStringObject(node);
3391         break;
3392     }
3393 
3394     case NewSymbol: {
3395         compileNewSymbol(node);
3396         break;
3397     }
3398 
3399     case NewArray: {
3400         compileNewArray(node);
3401         break;
3402     }
3403 
3404     case NewArrayWithSpread: {
3405         compileNewArrayWithSpread(node);
3406         break;
3407     }
3408 
3409     case Spread: {
3410         compileSpread(node);
3411         break;
3412     }
3413 
3414     case NewArrayWithSize: {
3415         compileNewArrayWithSize(node);
3416         break;
3417     }
3418 
3419     case NewArrayBuffer: {
3420         compileNewArrayBuffer(node);
3421         break;
3422     }
3423 
3424     case NewTypedArray: {
3425         compileNewTypedArray(node);
3426         break;
3427     }
3428 
3429     case NewRegexp: {
3430         compileNewRegexp(node);
3431         break;
3432     }
3433 
3434     case ToObject:
3435     case CallObjectConstructor: {
3436         compileToObjectOrCallObjectConstructor(node);
3437         break;
3438     }
3439 
3440     case ToThis: {
3441         compileToThis(node);
3442         break;
3443     }
3444 
3445     case ObjectCreate: {
3446         compileObjectCreate(node);
3447         break;
3448     }
3449 
3450     case ObjectKeys: {
3451         compileObjectKeys(node);
3452         break;
3453     }
3454 
3455     case CreateThis: {
3456         compileCreateThis(node);
3457         break;
3458     }
3459 
3460     case NewObject: {
3461         compileNewObject(node);
3462         break;
3463     }
3464 
3465     case GetCallee: {
3466         compileGetCallee(node);
3467         break;
3468     }
3469 
3470     case SetCallee: {
3471         compileSetCallee(node);
3472         break;
3473     }
3474 
3475     case GetArgumentCountIncludingThis: {
3476         compileGetArgumentCountIncludingThis(node);
3477         break;
3478     }
3479 
3480     case SetArgumentCountIncludingThis:
3481         compileSetArgumentCountIncludingThis(node);
3482         break;
3483 
3484     case GetRestLength: {
3485         compileGetRestLength(node);
3486         break;
3487     }
3488 
3489     case GetScope:
3490         compileGetScope(node);
3491         break;
3492 
3493     case SkipScope:
3494         compileSkipScope(node);
3495         break;
3496 
3497     case GetGlobalObject:
3498         compileGetGlobalObject(node);
3499         break;
3500 
3501     case GetGlobalThis:
3502         compileGetGlobalThis(node);
3503         break;
3504 
3505     case GetClosureVar: {
3506         compileGetClosureVar(node);
3507         break;
3508     }
3509     case PutClosureVar: {
3510         compilePutClosureVar(node);
3511         break;
3512     }
3513 
3514     case TryGetById: {
3515         compileGetById(node, AccessType::TryGet);
3516         break;
3517     }
3518 
3519     case GetByIdDirect: {
3520         compileGetById(node, AccessType::GetDirect);
3521         break;
3522     }
3523 
3524     case GetByIdDirectFlush: {
3525         compileGetByIdFlush(node, AccessType::GetDirect);
3526         break;
3527     }
3528 
3529     case GetById: {
3530         compileGetById(node, AccessType::Get);
3531         break;
3532     }
3533 
3534     case GetByIdFlush: {
3535         compileGetByIdFlush(node, AccessType::Get);
3536         break;
3537     }
3538 
3539     case GetByIdWithThis: {
3540         if (node-&gt;child1().useKind() == CellUse &amp;&amp; node-&gt;child2().useKind() == CellUse) {
3541             SpeculateCellOperand base(this, node-&gt;child1());
3542             GPRReg baseGPR = base.gpr();
3543             SpeculateCellOperand thisValue(this, node-&gt;child2());
3544             GPRReg thisValueGPR = thisValue.gpr();
3545 
3546             GPRFlushedCallResult result(this);
3547             GPRReg resultGPR = result.gpr();
3548 
3549             flushRegisters();
3550 
3551             cachedGetByIdWithThis(node-&gt;origin.semantic, baseGPR, thisValueGPR, resultGPR, node-&gt;identifierNumber(), JITCompiler::JumpList());
3552 
3553             jsValueResult(resultGPR, node);
3554 
3555         } else {
3556             JSValueOperand base(this, node-&gt;child1());
3557             GPRReg baseGPR = base.gpr();
3558             JSValueOperand thisValue(this, node-&gt;child2());
3559             GPRReg thisValueGPR = thisValue.gpr();
3560 
3561             GPRFlushedCallResult result(this);
3562             GPRReg resultGPR = result.gpr();
3563 
3564             flushRegisters();
3565 
3566             JITCompiler::JumpList notCellList;
3567             notCellList.append(m_jit.branchIfNotCell(JSValueRegs(baseGPR)));
3568             notCellList.append(m_jit.branchIfNotCell(JSValueRegs(thisValueGPR)));
3569 
3570             cachedGetByIdWithThis(node-&gt;origin.semantic, baseGPR, thisValueGPR, resultGPR, node-&gt;identifierNumber(), notCellList);
3571 
3572             jsValueResult(resultGPR, node);
3573         }
3574 
3575         break;
3576     }
3577 
3578     case GetArrayLength:
3579         compileGetArrayLength(node);
3580         break;
3581 
3582     case DeleteById: {
3583         compileDeleteById(node);
3584         break;
3585     }
3586 
3587     case DeleteByVal: {
3588         compileDeleteByVal(node);
3589         break;
3590     }
3591 
3592     case CheckCell: {
3593         compileCheckCell(node);
3594         break;
3595     }
3596 
3597     case CheckNotEmpty: {
3598         compileCheckNotEmpty(node);
3599         break;
3600     }
3601 
3602     case AssertNotEmpty: {
3603         if (validationEnabled()) {
3604             JSValueOperand operand(this, node-&gt;child1());
3605             GPRReg input = operand.gpr();
3606             auto done = m_jit.branchIfNotEmpty(input);
3607             m_jit.breakpoint();
3608             done.link(&amp;m_jit);
3609         }
3610         noResult(node);
3611         break;
3612     }
3613 
3614     case CheckStringIdent:
3615         compileCheckStringIdent(node);
3616         break;
3617 
3618     case GetExecutable: {
3619         compileGetExecutable(node);
3620         break;
3621     }
3622 
3623     case CheckStructureOrEmpty: {
3624         SpeculateCellOperand cell(this, node-&gt;child1());
3625         GPRReg cellGPR = cell.gpr();
3626 
3627         GPRReg tempGPR = InvalidGPRReg;
3628         Optional&lt;GPRTemporary&gt; temp;
3629         if (node-&gt;structureSet().size() &gt; 1) {
3630             temp.emplace(this);
3631             tempGPR = temp-&gt;gpr();
3632         }
3633 
3634         MacroAssembler::Jump isEmpty;
3635         if (m_interpreter.forNode(node-&gt;child1()).m_type &amp; SpecEmpty)
3636             isEmpty = m_jit.branchIfEmpty(cellGPR);
3637 
3638         emitStructureCheck(node, cellGPR, tempGPR);
3639 
3640         if (isEmpty.isSet())
3641             isEmpty.link(&amp;m_jit);
3642 
3643         noResult(node);
3644         break;
3645     }
3646 
3647     case CheckStructure: {
3648         compileCheckStructure(node);
3649         break;
3650     }
3651 
3652     case PutStructure: {
3653         RegisteredStructure oldStructure = node-&gt;transition()-&gt;previous;
3654         RegisteredStructure newStructure = node-&gt;transition()-&gt;next;
3655 
3656         m_jit.jitCode()-&gt;common.notifyCompilingStructureTransition(m_jit.graph().m_plan, m_jit.codeBlock(), node);
3657 
3658         SpeculateCellOperand base(this, node-&gt;child1());
3659         GPRReg baseGPR = base.gpr();
3660 
3661         ASSERT_UNUSED(oldStructure, oldStructure-&gt;indexingMode() == newStructure-&gt;indexingMode());
3662         ASSERT(oldStructure-&gt;typeInfo().type() == newStructure-&gt;typeInfo().type());
3663         ASSERT(oldStructure-&gt;typeInfo().inlineTypeFlags() == newStructure-&gt;typeInfo().inlineTypeFlags());
3664         m_jit.store32(MacroAssembler::TrustedImm32(newStructure-&gt;id()), MacroAssembler::Address(baseGPR, JSCell::structureIDOffset()));
3665 
3666         noResult(node);
3667         break;
3668     }
3669 
3670     case AllocatePropertyStorage:
3671         compileAllocatePropertyStorage(node);
3672         break;
3673 
3674     case ReallocatePropertyStorage:
3675         compileReallocatePropertyStorage(node);
3676         break;
3677 
3678     case NukeStructureAndSetButterfly:
3679         compileNukeStructureAndSetButterfly(node);
3680         break;
3681 
3682     case GetButterfly:
3683         compileGetButterfly(node);
3684         break;
3685 
3686     case GetIndexedPropertyStorage: {
3687         compileGetIndexedPropertyStorage(node);
3688         break;
3689     }
3690 
3691     case ConstantStoragePointer: {
3692         compileConstantStoragePointer(node);
3693         break;
3694     }
3695 
3696     case GetTypedArrayByteOffset: {
3697         compileGetTypedArrayByteOffset(node);
3698         break;
3699     }
3700 
3701     case GetPrototypeOf: {
3702         compileGetPrototypeOf(node);
3703         break;
3704     }
3705 
3706     case GetByOffset:
3707     case GetGetterSetterByOffset: {
3708         compileGetByOffset(node);
3709         break;
3710     }
3711 
3712     case MatchStructure: {
3713         compileMatchStructure(node);
3714         break;
3715     }
3716 
3717     case GetGetter: {
3718         compileGetGetter(node);
3719         break;
3720     }
3721 
3722     case GetSetter: {
3723         compileGetSetter(node);
3724         break;
3725     }
3726 
3727     case PutByOffset: {
3728         compilePutByOffset(node);
3729         break;
3730     }
3731 
3732     case PutByIdFlush: {
3733         compilePutByIdFlush(node);
3734         break;
3735     }
3736 
3737     case PutById: {
3738         compilePutById(node);
3739         break;
3740     }
3741 
3742     case PutByIdWithThis: {
3743         compilePutByIdWithThis(node);
3744         break;
3745     }
3746 
3747     case PutByValWithThis: {
3748         JSValueOperand base(this, m_jit.graph().varArgChild(node, 0));
3749         GPRReg baseGPR = base.gpr();
3750         JSValueOperand thisValue(this, m_jit.graph().varArgChild(node, 1));
3751         GPRReg thisValueGPR = thisValue.gpr();
3752         JSValueOperand property(this, m_jit.graph().varArgChild(node, 2));
3753         GPRReg propertyGPR = property.gpr();
3754         JSValueOperand value(this, m_jit.graph().varArgChild(node, 3));
3755         GPRReg valueGPR = value.gpr();
3756 
3757         flushRegisters();
3758         callOperation(m_jit.isStrictModeFor(node-&gt;origin.semantic) ? operationPutByValWithThisStrict : operationPutByValWithThis, NoResult, baseGPR, thisValueGPR, propertyGPR, valueGPR);
3759         m_jit.exceptionCheck();
3760 
3761         noResult(node);
3762         break;
3763     }
3764 
3765     case PutByIdDirect: {
3766         compilePutByIdDirect(node);
3767         break;
3768     }
3769 
3770     case PutGetterById:
3771     case PutSetterById: {
3772         compilePutAccessorById(node);
3773         break;
3774     }
3775 
3776     case PutGetterSetterById: {
3777         compilePutGetterSetterById(node);
3778         break;
3779     }
3780 
3781     case PutGetterByVal:
3782     case PutSetterByVal: {
3783         compilePutAccessorByVal(node);
3784         break;
3785     }
3786 
3787     case DefineDataProperty: {
3788         compileDefineDataProperty(node);
3789         break;
3790     }
3791 
3792     case DefineAccessorProperty: {
3793         compileDefineAccessorProperty(node);
3794         break;
3795     }
3796 
3797     case GetGlobalLexicalVariable:
3798     case GetGlobalVar: {
3799         compileGetGlobalVariable(node);
3800         break;
3801     }
3802 
3803     case PutGlobalVariable: {
3804         compilePutGlobalVariable(node);
3805         break;
3806     }
3807 
3808     case PutDynamicVar: {
3809         compilePutDynamicVar(node);
3810         break;
3811     }
3812 
3813     case GetDynamicVar: {
3814         compileGetDynamicVar(node);
3815         break;
3816     }
3817 
3818     case ResolveScopeForHoistingFuncDeclInEval: {
3819         compileResolveScopeForHoistingFuncDeclInEval(node);
3820         break;
3821     }
3822 
3823     case ResolveScope: {
3824         compileResolveScope(node);
3825         break;
3826     }
3827 
3828     case NotifyWrite: {
3829         compileNotifyWrite(node);
3830         break;
3831     }
3832 
3833     case CheckTypeInfoFlags: {
3834         compileCheckTypeInfoFlags(node);
3835         break;
3836     }
3837 
3838     case ParseInt: {
3839         compileParseInt(node);
3840         break;
3841     }
3842 
3843     case OverridesHasInstance: {
3844         compileOverridesHasInstance(node);
3845         break;
3846     }
3847 
3848     case InstanceOf: {
3849         compileInstanceOf(node);
3850         break;
3851     }
3852 
3853     case InstanceOfCustom: {
3854         compileInstanceOfCustom(node);
3855         break;
3856     }
3857 
3858     case IsEmpty: {
3859         JSValueOperand value(this, node-&gt;child1());
3860         GPRTemporary result(this, Reuse, value);
3861 
3862         m_jit.comparePtr(JITCompiler::Equal, value.gpr(), TrustedImm32(JSValue::encode(JSValue())), result.gpr());
3863         m_jit.or32(TrustedImm32(ValueFalse), result.gpr());
3864 
3865         jsValueResult(result.gpr(), node, DataFormatJSBoolean);
3866         break;
3867     }
3868 
3869     case IsUndefined: {
3870         JSValueOperand value(this, node-&gt;child1());
3871         GPRTemporary result(this);
3872         GPRTemporary localGlobalObject(this);
3873         GPRTemporary remoteGlobalObject(this);
3874         GPRTemporary scratch(this);
3875 
3876         JITCompiler::Jump isCell = m_jit.branchIfCell(value.jsValueRegs());
3877 
3878         m_jit.compare64(JITCompiler::Equal, value.gpr(), TrustedImm32(ValueUndefined), result.gpr());
3879         JITCompiler::Jump done = m_jit.jump();
3880 
3881         isCell.link(&amp;m_jit);
3882         JITCompiler::Jump notMasqueradesAsUndefined;
3883         if (masqueradesAsUndefinedWatchpointIsStillValid()) {
3884             m_jit.move(TrustedImm32(0), result.gpr());
3885             notMasqueradesAsUndefined = m_jit.jump();
3886         } else {
3887             JITCompiler::Jump isMasqueradesAsUndefined = m_jit.branchTest8(
3888                 JITCompiler::NonZero,
3889                 JITCompiler::Address(value.gpr(), JSCell::typeInfoFlagsOffset()),
3890                 TrustedImm32(MasqueradesAsUndefined));
3891             m_jit.move(TrustedImm32(0), result.gpr());
3892             notMasqueradesAsUndefined = m_jit.jump();
3893 
3894             isMasqueradesAsUndefined.link(&amp;m_jit);
3895             GPRReg localGlobalObjectGPR = localGlobalObject.gpr();
3896             GPRReg remoteGlobalObjectGPR = remoteGlobalObject.gpr();
3897             m_jit.move(TrustedImmPtr::weakPointer(m_jit.graph(), m_jit.globalObjectFor(node-&gt;origin.semantic)), localGlobalObjectGPR);
3898             m_jit.emitLoadStructure(*m_jit.vm(), value.gpr(), result.gpr(), scratch.gpr());
3899             m_jit.loadPtr(JITCompiler::Address(result.gpr(), Structure::globalObjectOffset()), remoteGlobalObjectGPR);
3900             m_jit.comparePtr(JITCompiler::Equal, localGlobalObjectGPR, remoteGlobalObjectGPR, result.gpr());
3901         }
3902 
3903         notMasqueradesAsUndefined.link(&amp;m_jit);
3904         done.link(&amp;m_jit);
3905         m_jit.or32(TrustedImm32(ValueFalse), result.gpr());
3906         jsValueResult(result.gpr(), node, DataFormatJSBoolean);
3907         break;
3908     }
3909 
3910     case IsUndefinedOrNull: {
3911         JSValueOperand value(this, node-&gt;child1());
3912         GPRTemporary result(this, Reuse, value);
3913 
3914         GPRReg valueGPR = value.gpr();
3915         GPRReg resultGPR = result.gpr();
3916 
3917         m_jit.move(valueGPR, resultGPR);
3918         m_jit.and64(CCallHelpers::TrustedImm32(~TagBitUndefined), resultGPR);
3919         m_jit.compare64(CCallHelpers::Equal, resultGPR, CCallHelpers::TrustedImm32(ValueNull), resultGPR);
3920 
3921         unblessedBooleanResult(resultGPR, node);
3922         break;
3923     }
3924 
3925     case IsBoolean: {
3926         JSValueOperand value(this, node-&gt;child1());
3927         GPRTemporary result(this, Reuse, value);
3928 
3929         m_jit.move(value.gpr(), result.gpr());
3930         m_jit.xor64(JITCompiler::TrustedImm32(ValueFalse), result.gpr());
3931         m_jit.test64(JITCompiler::Zero, result.gpr(), JITCompiler::TrustedImm32(static_cast&lt;int32_t&gt;(~1)), result.gpr());
3932         m_jit.or32(TrustedImm32(ValueFalse), result.gpr());
3933         jsValueResult(result.gpr(), node, DataFormatJSBoolean);
3934         break;
3935     }
3936 
3937     case IsNumber: {
3938         JSValueOperand value(this, node-&gt;child1());
3939         GPRTemporary result(this, Reuse, value);
3940 
3941         m_jit.test64(JITCompiler::NonZero, value.gpr(), GPRInfo::tagTypeNumberRegister, result.gpr());
3942         m_jit.or32(TrustedImm32(ValueFalse), result.gpr());
3943         jsValueResult(result.gpr(), node, DataFormatJSBoolean);
3944         break;
3945     }
3946 
3947     case NumberIsInteger: {
3948         JSValueOperand value(this, node-&gt;child1());
3949         GPRTemporary result(this, Reuse, value);
3950 
3951         FPRTemporary temp1(this);
3952         FPRTemporary temp2(this);
3953 
3954         JSValueRegs valueRegs = JSValueRegs(value.gpr());
3955         GPRReg resultGPR = result.gpr();
3956 
3957         FPRReg tempFPR1 = temp1.fpr();
3958         FPRReg tempFPR2 = temp2.fpr();
3959 
3960         MacroAssembler::JumpList done;
3961 
3962         auto isInt32 = m_jit.branchIfInt32(valueRegs);
3963         auto notNumber = m_jit.branchIfNotDoubleKnownNotInt32(valueRegs);
3964 
3965         // We&#39;re a double here.
3966         m_jit.unboxDouble(valueRegs.gpr(), resultGPR, tempFPR1);
3967         m_jit.urshift64(TrustedImm32(52), resultGPR);
3968         m_jit.and32(TrustedImm32(0x7ff), resultGPR);
3969         auto notNanNorInfinity = m_jit.branch32(JITCompiler::NotEqual, TrustedImm32(0x7ff), resultGPR);
3970         m_jit.move(TrustedImm32(ValueFalse), resultGPR);
3971         done.append(m_jit.jump());
3972 
3973         notNanNorInfinity.link(&amp;m_jit);
3974         m_jit.roundTowardZeroDouble(tempFPR1, tempFPR2);
3975         m_jit.compareDouble(JITCompiler::DoubleEqual, tempFPR1, tempFPR2, resultGPR);
3976         m_jit.or32(TrustedImm32(ValueFalse), resultGPR);
3977         done.append(m_jit.jump());
3978 
3979         isInt32.link(&amp;m_jit);
3980         m_jit.move(TrustedImm32(ValueTrue), resultGPR);
3981         done.append(m_jit.jump());
3982 
3983         notNumber.link(&amp;m_jit);
3984         m_jit.move(TrustedImm32(ValueFalse), resultGPR);
3985 
3986         done.link(&amp;m_jit);
3987         jsValueResult(resultGPR, node, DataFormatJSBoolean);
3988         break;
3989     }
3990 
3991     case MapHash: {
3992         switch (node-&gt;child1().useKind()) {
3993         case BooleanUse:
3994         case Int32Use:
3995         case SymbolUse:
3996         case ObjectUse: {
3997             JSValueOperand input(this, node-&gt;child1(), ManualOperandSpeculation);
3998             GPRTemporary result(this, Reuse, input);
3999             GPRTemporary temp(this);
4000 
4001             GPRReg inputGPR = input.gpr();
4002             GPRReg resultGPR = result.gpr();
4003             GPRReg tempGPR = temp.gpr();
4004 
4005             speculate(node, node-&gt;child1());
4006 
4007             m_jit.move(inputGPR, resultGPR);
4008             m_jit.wangsInt64Hash(resultGPR, tempGPR);
4009             int32Result(resultGPR, node);
4010             break;
4011         }
4012         case CellUse:
4013         case StringUse: {
4014             SpeculateCellOperand input(this, node-&gt;child1());
4015             GPRTemporary result(this);
4016             Optional&lt;GPRTemporary&gt; temp;
4017 
4018             GPRReg tempGPR = InvalidGPRReg;
4019             if (node-&gt;child1().useKind() == CellUse) {
4020                 temp.emplace(this);
4021                 tempGPR = temp-&gt;gpr();
4022             }
4023 
4024             GPRReg inputGPR = input.gpr();
4025             GPRReg resultGPR = result.gpr();
4026 
4027             MacroAssembler::JumpList slowPath;
4028             MacroAssembler::JumpList done;
4029 
4030             if (node-&gt;child1().useKind() == StringUse)
4031                 speculateString(node-&gt;child1(), inputGPR);
4032             else {
4033                 auto isString = m_jit.branchIfString(inputGPR);
4034                 m_jit.move(inputGPR, resultGPR);
4035                 m_jit.wangsInt64Hash(resultGPR, tempGPR);
4036                 done.append(m_jit.jump());
4037                 isString.link(&amp;m_jit);
4038             }
4039 
4040             m_jit.loadPtr(MacroAssembler::Address(inputGPR, JSString::offsetOfValue()), resultGPR);
4041             slowPath.append(m_jit.branchIfRopeStringImpl(resultGPR));
4042             m_jit.load32(MacroAssembler::Address(resultGPR, StringImpl::flagsOffset()), resultGPR);
4043             m_jit.urshift32(MacroAssembler::TrustedImm32(StringImpl::s_flagCount), resultGPR);
4044             slowPath.append(m_jit.branchTest32(MacroAssembler::Zero, resultGPR));
4045             done.append(m_jit.jump());
4046 
4047             slowPath.link(&amp;m_jit);
4048             silentSpillAllRegisters(resultGPR);
4049             callOperation(operationMapHash, resultGPR, JSValueRegs(inputGPR));
4050             silentFillAllRegisters();
4051             m_jit.exceptionCheck();
4052 
4053             done.link(&amp;m_jit);
4054             int32Result(resultGPR, node);
4055             break;
4056         }
4057         default:
4058             RELEASE_ASSERT(node-&gt;child1().useKind() == UntypedUse);
4059             break;
4060         }
4061 
4062         if (node-&gt;child1().useKind() != UntypedUse)
4063             break;
4064 
4065         JSValueOperand input(this, node-&gt;child1());
4066         GPRTemporary temp(this);
4067         GPRTemporary result(this);
4068 
4069         GPRReg inputGPR = input.gpr();
4070         GPRReg resultGPR = result.gpr();
4071         GPRReg tempGPR = temp.gpr();
4072 
4073         MacroAssembler::JumpList straightHash;
4074         MacroAssembler::JumpList done;
4075         straightHash.append(m_jit.branchIfNotCell(inputGPR));
4076         MacroAssembler::JumpList slowPath;
4077         straightHash.append(m_jit.branchIfNotString(inputGPR));
4078         m_jit.loadPtr(MacroAssembler::Address(inputGPR, JSString::offsetOfValue()), resultGPR);
4079         slowPath.append(m_jit.branchIfRopeStringImpl(resultGPR));
4080         m_jit.load32(MacroAssembler::Address(resultGPR, StringImpl::flagsOffset()), resultGPR);
4081         m_jit.urshift32(MacroAssembler::TrustedImm32(StringImpl::s_flagCount), resultGPR);
4082         slowPath.append(m_jit.branchTest32(MacroAssembler::Zero, resultGPR));
4083         done.append(m_jit.jump());
4084 
4085         straightHash.link(&amp;m_jit);
4086         m_jit.move(inputGPR, resultGPR);
4087         m_jit.wangsInt64Hash(resultGPR, tempGPR);
4088         done.append(m_jit.jump());
4089 
4090         slowPath.link(&amp;m_jit);
4091         silentSpillAllRegisters(resultGPR);
4092         callOperation(operationMapHash, resultGPR, JSValueRegs(inputGPR));
4093         silentFillAllRegisters();
4094         m_jit.exceptionCheck();
4095 
4096         done.link(&amp;m_jit);
4097         int32Result(resultGPR, node);
4098         break;
4099     }
4100 
4101     case NormalizeMapKey: {
4102         compileNormalizeMapKey(node);
4103         break;
4104     }
4105 
4106     case GetMapBucket: {
4107         SpeculateCellOperand map(this, node-&gt;child1());
4108         JSValueOperand key(this, node-&gt;child2(), ManualOperandSpeculation);
4109         SpeculateInt32Operand hash(this, node-&gt;child3());
4110         GPRTemporary mask(this);
4111         GPRTemporary index(this);
4112         GPRTemporary buffer(this);
4113         GPRTemporary bucket(this);
4114         GPRTemporary result(this);
4115 
4116         GPRReg hashGPR = hash.gpr();
4117         GPRReg mapGPR = map.gpr();
4118         GPRReg maskGPR = mask.gpr();
4119         GPRReg indexGPR = index.gpr();
4120         GPRReg bufferGPR = buffer.gpr();
4121         GPRReg bucketGPR = bucket.gpr();
4122         GPRReg keyGPR = key.gpr();
4123         GPRReg resultGPR = result.gpr();
4124 
4125         if (node-&gt;child1().useKind() == MapObjectUse)
4126             speculateMapObject(node-&gt;child1(), mapGPR);
4127         else if (node-&gt;child1().useKind() == SetObjectUse)
4128             speculateSetObject(node-&gt;child1(), mapGPR);
4129         else
4130             RELEASE_ASSERT_NOT_REACHED();
4131 
4132         if (node-&gt;child2().useKind() != UntypedUse)
4133             speculate(node, node-&gt;child2());
4134 
4135         m_jit.load32(MacroAssembler::Address(mapGPR, HashMapImpl&lt;HashMapBucket&lt;HashMapBucketDataKey&gt;&gt;::offsetOfCapacity()), maskGPR);
4136         m_jit.loadPtr(MacroAssembler::Address(mapGPR, HashMapImpl&lt;HashMapBucket&lt;HashMapBucketDataKey&gt;&gt;::offsetOfBuffer()), bufferGPR);
4137         m_jit.sub32(TrustedImm32(1), maskGPR);
4138         m_jit.move(hashGPR, indexGPR);
4139 
4140         MacroAssembler::Label loop = m_jit.label();
4141         MacroAssembler::JumpList done;
4142         MacroAssembler::JumpList slowPathCases;
4143         MacroAssembler::JumpList loopAround;
4144 
4145         m_jit.and32(maskGPR, indexGPR);
4146         m_jit.loadPtr(MacroAssembler::BaseIndex(bufferGPR, indexGPR, MacroAssembler::TimesEight), bucketGPR);
4147         m_jit.move(bucketGPR, resultGPR);
4148         auto notPresentInTable = m_jit.branchPtr(MacroAssembler::Equal,
4149             bucketGPR, TrustedImmPtr(bitwise_cast&lt;size_t&gt;(HashMapImpl&lt;HashMapBucket&lt;HashMapBucketDataKey&gt;&gt;::emptyValue())));
4150         loopAround.append(m_jit.branchPtr(MacroAssembler::Equal,
4151             bucketGPR, TrustedImmPtr(bitwise_cast&lt;size_t&gt;(HashMapImpl&lt;HashMapBucket&lt;HashMapBucketDataKey&gt;&gt;::deletedValue()))));
4152 
4153         m_jit.load64(MacroAssembler::Address(bucketGPR, HashMapBucket&lt;HashMapBucketDataKey&gt;::offsetOfKey()), bucketGPR);
4154 
4155         // Perform Object.is()
4156         switch (node-&gt;child2().useKind()) {
4157         case BooleanUse:
4158         case Int32Use:
4159         case SymbolUse:
4160         case ObjectUse: {
4161             done.append(m_jit.branch64(MacroAssembler::Equal, bucketGPR, keyGPR)); // They&#39;re definitely the same value, we found the bucket we were looking for!
4162             // Otherwise, loop around.
4163             break;
4164         }
4165         case CellUse: {
4166             done.append(m_jit.branch64(MacroAssembler::Equal, bucketGPR, keyGPR));
4167             loopAround.append(m_jit.branchIfNotCell(JSValueRegs(bucketGPR)));
4168             loopAround.append(m_jit.branchIfNotString(bucketGPR));
4169             loopAround.append(m_jit.branchIfNotString(keyGPR));
4170             // They&#39;re both strings.
4171             slowPathCases.append(m_jit.jump());
4172             break;
4173         }
4174         case StringUse: {
4175             done.append(m_jit.branch64(MacroAssembler::Equal, bucketGPR, keyGPR)); // They&#39;re definitely the same value, we found the bucket we were looking for!
4176             loopAround.append(m_jit.branchIfNotCell(JSValueRegs(bucketGPR)));
4177             loopAround.append(m_jit.branchIfNotString(bucketGPR));
4178             slowPathCases.append(m_jit.jump());
4179             break;
4180         }
4181         case UntypedUse: {
4182             done.append(m_jit.branch64(MacroAssembler::Equal, bucketGPR, keyGPR)); // They&#39;re definitely the same value, we found the bucket we were looking for!
4183             // The input key and bucket&#39;s key are already normalized. So if 64-bit compare fails and one is not a cell, they&#39;re definitely not equal.
4184             loopAround.append(m_jit.branchIfNotCell(JSValueRegs(bucketGPR)));
4185             // first is a cell here.
4186             loopAround.append(m_jit.branchIfNotCell(JSValueRegs(keyGPR)));
4187             // Both are cells here.
4188             loopAround.append(m_jit.branchIfNotString(bucketGPR));
4189             // The first is a string here.
4190             slowPathCases.append(m_jit.branchIfString(keyGPR));
4191             // The first is a string, but the second is not, we continue to loop around.
4192             loopAround.append(m_jit.jump());
4193             break;
4194         }
4195         default:
4196             RELEASE_ASSERT_NOT_REACHED();
4197         }
4198 
4199 
4200         if (!loopAround.empty())
4201             loopAround.link(&amp;m_jit);
4202 
4203         m_jit.add32(TrustedImm32(1), indexGPR);
4204         m_jit.jump().linkTo(loop, &amp;m_jit);
4205 
4206         if (!slowPathCases.empty()) {
4207             slowPathCases.link(&amp;m_jit);
4208             silentSpillAllRegisters(indexGPR);
4209             if (node-&gt;child1().useKind() == MapObjectUse)
4210                 callOperation(operationJSMapFindBucket, resultGPR, mapGPR, keyGPR, hashGPR);
4211             else
4212                 callOperation(operationJSSetFindBucket, resultGPR, mapGPR, keyGPR, hashGPR);
4213             silentFillAllRegisters();
4214             m_jit.exceptionCheck();
4215             done.append(m_jit.jump());
4216         }
4217 
4218         notPresentInTable.link(&amp;m_jit);
4219         if (node-&gt;child1().useKind() == MapObjectUse)
4220             m_jit.move(TrustedImmPtr::weakPointer(m_jit.graph(), m_jit.vm()-&gt;sentinelMapBucket()), resultGPR);
4221         else
4222             m_jit.move(TrustedImmPtr::weakPointer(m_jit.graph(), m_jit.vm()-&gt;sentinelSetBucket()), resultGPR);
4223         done.link(&amp;m_jit);
4224         cellResult(resultGPR, node);
4225         break;
4226     }
4227 
4228     case GetMapBucketHead:
4229         compileGetMapBucketHead(node);
4230         break;
4231 
4232     case GetMapBucketNext:
4233         compileGetMapBucketNext(node);
4234         break;
4235 
4236     case LoadKeyFromMapBucket:
4237         compileLoadKeyFromMapBucket(node);
4238         break;
4239 
4240     case LoadValueFromMapBucket:
4241         compileLoadValueFromMapBucket(node);
4242         break;
4243 
4244     case ExtractValueFromWeakMapGet:
4245         compileExtractValueFromWeakMapGet(node);
4246         break;
4247 
4248     case SetAdd:
4249         compileSetAdd(node);
4250         break;
4251 
4252     case MapSet:
4253         compileMapSet(node);
4254         break;
4255 
4256     case WeakMapGet:
4257         compileWeakMapGet(node);
4258         break;
4259 
4260     case WeakSetAdd:
4261         compileWeakSetAdd(node);
4262         break;
4263 
4264     case WeakMapSet:
4265         compileWeakMapSet(node);
4266         break;
4267 
4268     case StringSlice: {
4269         compileStringSlice(node);
4270         break;
4271     }
4272 
4273     case ToLowerCase: {
4274         compileToLowerCase(node);
4275         break;
4276     }
4277 
4278     case NumberToStringWithRadix: {
4279         compileNumberToStringWithRadix(node);
4280         break;
4281     }
4282 
4283     case NumberToStringWithValidRadixConstant: {
4284         compileNumberToStringWithValidRadixConstant(node);
4285         break;
4286     }
4287 
4288     case IsObject: {
4289         compileIsObject(node);
4290         break;
4291     }
4292 
4293     case IsObjectOrNull: {
4294         compileIsObjectOrNull(node);
4295         break;
4296     }
4297 
4298     case IsFunction: {
4299         compileIsFunction(node);
4300         break;
4301     }
4302 
4303     case IsCellWithType: {
4304         compileIsCellWithType(node);
4305         break;
4306     }
4307 
4308     case IsTypedArrayView: {
4309         compileIsTypedArrayView(node);
4310         break;
4311     }
4312 
4313     case TypeOf: {
4314         compileTypeOf(node);
4315         break;
4316     }
4317 
4318     case Flush:
4319         break;
4320 
4321     case Call:
4322     case TailCall:
4323     case TailCallInlinedCaller:
4324     case Construct:
4325     case CallVarargs:
4326     case TailCallVarargs:
4327     case TailCallVarargsInlinedCaller:
4328     case CallForwardVarargs:
4329     case ConstructVarargs:
4330     case ConstructForwardVarargs:
4331     case TailCallForwardVarargs:
4332     case TailCallForwardVarargsInlinedCaller:
4333     case CallEval:
4334     case DirectCall:
4335     case DirectConstruct:
4336     case DirectTailCall:
4337     case DirectTailCallInlinedCaller:
4338         emitCall(node);
4339         break;
4340 
4341     case LoadVarargs: {
4342         compileLoadVarargs(node);
4343         break;
4344     }
4345 
4346     case ForwardVarargs: {
4347         compileForwardVarargs(node);
4348         break;
4349     }
4350 
4351     case CreateActivation: {
4352         compileCreateActivation(node);
4353         break;
4354     }
4355 
4356     case PushWithScope: {
4357         compilePushWithScope(node);
4358         break;
4359     }
4360 
4361     case CreateDirectArguments: {
4362         compileCreateDirectArguments(node);
4363         break;
4364     }
4365 
4366     case GetFromArguments: {
4367         compileGetFromArguments(node);
4368         break;
4369     }
4370 
4371     case PutToArguments: {
4372         compilePutToArguments(node);
4373         break;
4374     }
4375 
4376     case GetArgument: {
4377         compileGetArgument(node);
4378         break;
4379     }
4380 
4381     case CreateScopedArguments: {
4382         compileCreateScopedArguments(node);
4383         break;
4384     }
4385 
4386     case CreateClonedArguments: {
4387         compileCreateClonedArguments(node);
4388         break;
4389     }
4390     case CreateRest: {
4391         compileCreateRest(node);
4392         break;
4393     }
4394 
4395     case NewFunction:
4396     case NewGeneratorFunction:
4397     case NewAsyncGeneratorFunction:
4398     case NewAsyncFunction:
4399         compileNewFunction(node);
4400         break;
4401 
4402     case SetFunctionName:
4403         compileSetFunctionName(node);
4404         break;
4405 
4406     case InById:
4407         compileInById(node);
4408         break;
4409 
4410     case InByVal:
4411         compileInByVal(node);
4412         break;
4413 
4414     case HasOwnProperty: {
4415         SpeculateCellOperand object(this, node-&gt;child1());
4416         GPRTemporary uniquedStringImpl(this);
4417         GPRTemporary temp(this);
4418         GPRTemporary hash(this);
4419         GPRTemporary structureID(this);
4420         GPRTemporary result(this);
4421 
4422         Optional&lt;SpeculateCellOperand&gt; keyAsCell;
4423         Optional&lt;JSValueOperand&gt; keyAsValue;
4424         GPRReg keyGPR;
4425         if (node-&gt;child2().useKind() == UntypedUse) {
4426             keyAsValue.emplace(this, node-&gt;child2());
4427             keyGPR = keyAsValue-&gt;gpr();
4428         } else {
4429             ASSERT(node-&gt;child2().useKind() == StringUse || node-&gt;child2().useKind() == SymbolUse);
4430             keyAsCell.emplace(this, node-&gt;child2());
4431             keyGPR = keyAsCell-&gt;gpr();
4432         }
4433 
4434         GPRReg objectGPR = object.gpr();
4435         GPRReg implGPR = uniquedStringImpl.gpr();
4436         GPRReg tempGPR = temp.gpr();
4437         GPRReg hashGPR = hash.gpr();
4438         GPRReg structureIDGPR = structureID.gpr();
4439         GPRReg resultGPR = result.gpr();
4440 
4441         speculateObject(node-&gt;child1());
4442 
4443         MacroAssembler::JumpList slowPath;
4444         switch (node-&gt;child2().useKind()) {
4445         case SymbolUse: {
4446             speculateSymbol(node-&gt;child2(), keyGPR);
4447             m_jit.loadPtr(MacroAssembler::Address(keyGPR, Symbol::offsetOfSymbolImpl()), implGPR);
4448             break;
4449         }
4450         case StringUse: {
4451             speculateString(node-&gt;child2(), keyGPR);
4452             m_jit.loadPtr(MacroAssembler::Address(keyGPR, JSString::offsetOfValue()), implGPR);
4453             slowPath.append(m_jit.branchIfRopeStringImpl(implGPR));
4454             slowPath.append(m_jit.branchTest32(
4455                 MacroAssembler::Zero, MacroAssembler::Address(implGPR, StringImpl::flagsOffset()),
4456                 MacroAssembler::TrustedImm32(StringImpl::flagIsAtomic())));
4457             break;
4458         }
4459         case UntypedUse: {
4460             slowPath.append(m_jit.branchIfNotCell(JSValueRegs(keyGPR)));
4461             auto isNotString = m_jit.branchIfNotString(keyGPR);
4462             m_jit.loadPtr(MacroAssembler::Address(keyGPR, JSString::offsetOfValue()), implGPR);
4463             slowPath.append(m_jit.branchIfRopeStringImpl(implGPR));
4464             slowPath.append(m_jit.branchTest32(
4465                 MacroAssembler::Zero, MacroAssembler::Address(implGPR, StringImpl::flagsOffset()),
4466                 MacroAssembler::TrustedImm32(StringImpl::flagIsAtomic())));
4467             auto hasUniquedImpl = m_jit.jump();
4468 
4469             isNotString.link(&amp;m_jit);
4470             slowPath.append(m_jit.branchIfNotSymbol(keyGPR));
4471             m_jit.loadPtr(MacroAssembler::Address(keyGPR, Symbol::offsetOfSymbolImpl()), implGPR);
4472 
4473             hasUniquedImpl.link(&amp;m_jit);
4474             break;
4475         }
4476         default:
4477             RELEASE_ASSERT_NOT_REACHED();
4478         }
4479 
4480         // Note that we don&#39;t test if the hash is zero here. AtomicStringImpl&#39;s can&#39;t have a zero
4481         // hash, however, a SymbolImpl may. But, because this is a cache, we don&#39;t care. We only
4482         // ever load the result from the cache if the cache entry matches what we are querying for.
4483         // So we either get super lucky and use zero for the hash and somehow collide with the entity
4484         // we&#39;re looking for, or we realize we&#39;re comparing against another entity, and go to the
4485         // slow path anyways.
4486         m_jit.load32(MacroAssembler::Address(implGPR, UniquedStringImpl::flagsOffset()), hashGPR);
4487         m_jit.urshift32(MacroAssembler::TrustedImm32(StringImpl::s_flagCount), hashGPR);
4488         m_jit.load32(MacroAssembler::Address(objectGPR, JSCell::structureIDOffset()), structureIDGPR);
4489         m_jit.add32(structureIDGPR, hashGPR);
4490         m_jit.and32(TrustedImm32(HasOwnPropertyCache::mask), hashGPR);
4491         if (hasOneBitSet(sizeof(HasOwnPropertyCache::Entry))) // is a power of 2
4492             m_jit.lshift32(TrustedImm32(getLSBSet(sizeof(HasOwnPropertyCache::Entry))), hashGPR);
4493         else
4494             m_jit.mul32(TrustedImm32(sizeof(HasOwnPropertyCache::Entry)), hashGPR, hashGPR);
4495         ASSERT(m_jit.vm()-&gt;hasOwnPropertyCache());
4496         m_jit.move(TrustedImmPtr(m_jit.vm()-&gt;hasOwnPropertyCache()), tempGPR);
4497         slowPath.append(m_jit.branchPtr(MacroAssembler::NotEqual,
4498             MacroAssembler::BaseIndex(tempGPR, hashGPR, MacroAssembler::TimesOne, HasOwnPropertyCache::Entry::offsetOfImpl()), implGPR));
4499         m_jit.load8(MacroAssembler::BaseIndex(tempGPR, hashGPR, MacroAssembler::TimesOne, HasOwnPropertyCache::Entry::offsetOfResult()), resultGPR);
4500         m_jit.load32(MacroAssembler::BaseIndex(tempGPR, hashGPR, MacroAssembler::TimesOne, HasOwnPropertyCache::Entry::offsetOfStructureID()), tempGPR);
4501         slowPath.append(m_jit.branch32(MacroAssembler::NotEqual, tempGPR, structureIDGPR));
4502         auto done = m_jit.jump();
4503 
4504         slowPath.link(&amp;m_jit);
4505         silentSpillAllRegisters(resultGPR);
4506         callOperation(operationHasOwnProperty, resultGPR, objectGPR, keyGPR);
4507         silentFillAllRegisters();
4508         m_jit.exceptionCheck();
4509 
4510         done.link(&amp;m_jit);
4511         m_jit.or32(TrustedImm32(ValueFalse), resultGPR);
4512         jsValueResult(resultGPR, node, DataFormatJSBoolean);
4513         break;
4514     }
4515 
4516     case CountExecution:
4517         m_jit.add64(TrustedImm32(1), MacroAssembler::AbsoluteAddress(node-&gt;executionCounter()-&gt;address()));
4518         break;
4519 
4520     case SuperSamplerBegin:
4521         m_jit.add32(TrustedImm32(1), MacroAssembler::AbsoluteAddress(bitwise_cast&lt;void*&gt;(&amp;g_superSamplerCount)));
4522         break;
4523 
4524     case SuperSamplerEnd:
4525         m_jit.sub32(TrustedImm32(1), MacroAssembler::AbsoluteAddress(bitwise_cast&lt;void*&gt;(&amp;g_superSamplerCount)));
4526         break;
4527 
4528     case ForceOSRExit: {
4529         terminateSpeculativeExecution(InadequateCoverage, JSValueRegs(), 0);
4530         break;
4531     }
4532 
4533     case InvalidationPoint:
4534         emitInvalidationPoint(node);
4535         break;
4536 
4537     case CheckTraps:
4538         compileCheckTraps(node);
4539         break;
4540 
4541     case Phantom:
4542     case Check:
4543     case CheckVarargs:
4544         DFG_NODE_DO_TO_CHILDREN(m_jit.graph(), node, speculate);
4545         noResult(node);
4546         break;
4547 
4548     case PhantomLocal:
4549     case LoopHint:
4550         // This is a no-op.
4551         noResult(node);
4552         break;
4553 
4554     case Unreachable:
4555         unreachable(node);
4556         break;
4557 
4558     case StoreBarrier:
4559     case FencedStoreBarrier: {
4560         compileStoreBarrier(node);
4561         break;
4562     }
4563 
4564     case GetEnumerableLength: {
4565         compileGetEnumerableLength(node);
4566         break;
4567     }
4568     case HasGenericProperty: {
4569         compileHasGenericProperty(node);
4570         break;
4571     }
4572     case HasStructureProperty: {
4573         compileHasStructureProperty(node);
4574         break;
4575     }
4576     case HasIndexedProperty: {
4577         compileHasIndexedProperty(node);
4578         break;
4579     }
4580     case GetDirectPname: {
4581         compileGetDirectPname(node);
4582         break;
4583     }
4584     case GetPropertyEnumerator: {
4585         compileGetPropertyEnumerator(node);
4586         break;
4587     }
4588     case GetEnumeratorStructurePname:
4589     case GetEnumeratorGenericPname: {
4590         compileGetEnumeratorPname(node);
4591         break;
4592     }
4593     case ToIndexString: {
4594         compileToIndexString(node);
4595         break;
4596     }
4597     case ProfileType: {
4598         compileProfileType(node);
4599         break;
4600     }
4601     case ProfileControlFlow: {
4602         BasicBlockLocation* basicBlockLocation = node-&gt;basicBlockLocation();
4603         basicBlockLocation-&gt;emitExecuteCode(m_jit);
4604         noResult(node);
4605         break;
4606     }
4607 
4608     case LogShadowChickenPrologue: {
4609         compileLogShadowChickenPrologue(node);
4610         break;
4611     }
4612 
4613     case LogShadowChickenTail: {
4614         compileLogShadowChickenTail(node);
4615         break;
4616     }
4617 
4618     case MaterializeNewObject:
4619         compileMaterializeNewObject(node);
4620         break;
4621 
4622     case CallDOM:
4623         compileCallDOM(node);
4624         break;
4625 
4626     case CallDOMGetter:
4627         compileCallDOMGetter(node);
4628         break;
4629 
4630     case CheckSubClass:
4631         compileCheckSubClass(node);
4632         break;
4633 
4634     case ExtractCatchLocal: {
4635         compileExtractCatchLocal(node);
4636         break;
4637     }
4638 
4639     case ClearCatchLocals:
4640         compileClearCatchLocals(node);
4641         break;
4642 
4643     case DataViewGetFloat:
4644     case DataViewGetInt: {
4645         SpeculateCellOperand dataView(this, node-&gt;child1());
4646         GPRReg dataViewGPR = dataView.gpr();
4647         speculateDataViewObject(node-&gt;child1(), dataViewGPR);
4648 
4649         SpeculateInt32Operand index(this, node-&gt;child2());
4650         GPRReg indexGPR = index.gpr();
4651 
4652         GPRTemporary temp1(this);
4653         GPRReg t1 = temp1.gpr();
4654         GPRTemporary temp2(this);
4655         GPRReg t2 = temp2.gpr();
4656 
4657         Optional&lt;SpeculateBooleanOperand&gt; isLittleEndianOperand;
4658         if (node-&gt;child3())
4659             isLittleEndianOperand.emplace(this, node-&gt;child3());
4660         GPRReg isLittleEndianGPR = isLittleEndianOperand ? isLittleEndianOperand-&gt;gpr() : InvalidGPRReg;
4661 
4662         DataViewData data = node-&gt;dataViewData();
4663 
4664         m_jit.zeroExtend32ToPtr(indexGPR, t2);
4665         if (data.byteSize &gt; 1)
4666             m_jit.add64(TrustedImm32(data.byteSize - 1), t2);
4667         m_jit.load32(MacroAssembler::Address(dataViewGPR, JSArrayBufferView::offsetOfLength()), t1);
4668         speculationCheck(OutOfBounds, JSValueRegs(), node,
4669             m_jit.branch64(MacroAssembler::AboveOrEqual, t2, t1));
4670 
4671         m_jit.loadPtr(JITCompiler::Address(dataViewGPR, JSArrayBufferView::offsetOfVector()), t2);
4672         cageTypedArrayStorage(t2);
4673 
4674         m_jit.zeroExtend32ToPtr(indexGPR, t1);
4675         auto baseIndex = JITCompiler::BaseIndex(t2, t1, MacroAssembler::TimesOne);
4676 
4677         if (node-&gt;op() == DataViewGetInt) {
4678             switch (data.byteSize) {
4679             case 1:
4680                 if (data.isSigned)
4681                     m_jit.load8SignedExtendTo32(baseIndex, t2);
4682                 else
4683                     m_jit.load8(baseIndex, t2);
4684                 int32Result(t2, node);
4685                 break;
4686             case 2: {
4687                 auto emitLittleEndianLoad = [&amp;] {
4688                     if (data.isSigned)
4689                         m_jit.load16SignedExtendTo32(baseIndex, t2);
4690                     else
4691                         m_jit.load16(baseIndex, t2);
4692                 };
4693                 auto emitBigEndianLoad = [&amp;] {
4694                     m_jit.load16(baseIndex, t2);
4695                     m_jit.byteSwap16(t2);
4696                     if (data.isSigned)
4697                         m_jit.signExtend16To32(t2, t2);
4698                 };
4699 
4700                 if (data.isLittleEndian == FalseTriState)
4701                     emitBigEndianLoad();
4702                 else if (data.isLittleEndian == TrueTriState)
4703                     emitLittleEndianLoad();
4704                 else {
4705                     RELEASE_ASSERT(isLittleEndianGPR != InvalidGPRReg);
4706                     auto isBigEndian = m_jit.branchTest32(MacroAssembler::Zero, isLittleEndianGPR, TrustedImm32(1));
4707                     emitLittleEndianLoad();
4708                     auto done = m_jit.jump();
4709                     isBigEndian.link(&amp;m_jit);
4710                     emitBigEndianLoad();
4711                     done.link(&amp;m_jit);
4712                 }
4713                 int32Result(t2, node);
4714                 break;
4715             }
4716             case 4: {
4717                 m_jit.load32(baseIndex, t2);
4718 
4719                 if (data.isLittleEndian == FalseTriState)
4720                     m_jit.byteSwap32(t2);
4721                 else if (data.isLittleEndian == MixedTriState) {
4722                     RELEASE_ASSERT(isLittleEndianGPR != InvalidGPRReg);
4723                     auto isLittleEndian = m_jit.branchTest32(MacroAssembler::NonZero, isLittleEndianGPR, TrustedImm32(1));
4724                     m_jit.byteSwap32(t2);
4725                     isLittleEndian.link(&amp;m_jit);
4726                 }
4727 
4728                 if (data.isSigned)
4729                     int32Result(t2, node);
4730                 else
4731                     strictInt52Result(t2, node);
4732                 break;
4733             }
4734             default:
4735                 RELEASE_ASSERT_NOT_REACHED();
4736             }
4737         } else {
4738             FPRTemporary result(this);
4739             FPRReg resultFPR = result.fpr();
4740 
4741             switch (data.byteSize) {
4742             case 4: {
4743                 auto emitLittleEndianCode = [&amp;] {
4744                     m_jit.loadFloat(baseIndex, resultFPR);
4745                     m_jit.convertFloatToDouble(resultFPR, resultFPR);
4746                 };
4747 
4748                 auto emitBigEndianCode = [&amp;] {
4749                     m_jit.load32(baseIndex, t2);
4750                     m_jit.byteSwap32(t2);
4751                     m_jit.move32ToFloat(t2, resultFPR);
4752                     m_jit.convertFloatToDouble(resultFPR, resultFPR);
4753                 };
4754 
4755                 if (data.isLittleEndian == TrueTriState)
4756                     emitLittleEndianCode();
4757                 else if (data.isLittleEndian == FalseTriState)
4758                     emitBigEndianCode();
4759                 else {
4760                     RELEASE_ASSERT(isLittleEndianGPR != InvalidGPRReg);
4761                     auto isBigEndian = m_jit.branchTest32(MacroAssembler::Zero, isLittleEndianGPR, TrustedImm32(1));
4762                     emitLittleEndianCode();
4763                     auto done = m_jit.jump();
4764                     isBigEndian.link(&amp;m_jit);
4765                     emitBigEndianCode();
4766                     done.link(&amp;m_jit);
4767                 }
4768 
4769                 break;
4770             }
4771             case 8: {
4772                 auto emitLittleEndianCode = [&amp;] {
4773                     m_jit.loadDouble(baseIndex, resultFPR);
4774                 };
4775 
4776                 auto emitBigEndianCode = [&amp;] {
4777                     m_jit.load64(baseIndex, t2);
4778                     m_jit.byteSwap64(t2);
4779                     m_jit.move64ToDouble(t2, resultFPR);
4780                 };
4781 
4782                 if (data.isLittleEndian == TrueTriState)
4783                     emitLittleEndianCode();
4784                 else if (data.isLittleEndian == FalseTriState)
4785                     emitBigEndianCode();
4786                 else {
4787                     RELEASE_ASSERT(isLittleEndianGPR != InvalidGPRReg);
4788                     auto isBigEndian = m_jit.branchTest32(MacroAssembler::Zero, isLittleEndianGPR, TrustedImm32(1));
4789                     emitLittleEndianCode();
4790                     auto done = m_jit.jump();
4791                     isBigEndian.link(&amp;m_jit);
4792                     emitBigEndianCode();
4793                     done.link(&amp;m_jit);
4794                 }
4795 
4796                 break;
4797             }
4798             default:
4799                 RELEASE_ASSERT_NOT_REACHED();
4800             }
4801 
4802             doubleResult(resultFPR, node);
4803         }
4804 
4805         break;
4806     }
4807 
4808     case DataViewSet: {
4809         SpeculateCellOperand dataView(this, m_graph.varArgChild(node, 0));
4810         GPRReg dataViewGPR = dataView.gpr();
4811         speculateDataViewObject(m_graph.varArgChild(node, 0), dataViewGPR);
4812 
4813         SpeculateInt32Operand index(this, m_graph.varArgChild(node, 1));
4814         GPRReg indexGPR = index.gpr();
4815 
4816         Optional&lt;SpeculateStrictInt52Operand&gt; int52Value;
4817         Optional&lt;SpeculateDoubleOperand&gt; doubleValue;
4818         Optional&lt;SpeculateInt32Operand&gt; int32Value;
4819         Optional&lt;FPRTemporary&gt; fprTemporary;
4820         GPRReg valueGPR = InvalidGPRReg;
4821         FPRReg valueFPR = InvalidFPRReg;
4822         FPRReg tempFPR = InvalidFPRReg;
4823 
4824         DataViewData data = node-&gt;dataViewData();
4825 
4826         Edge&amp; valueEdge = m_graph.varArgChild(node, 2);
4827         switch (valueEdge.useKind()) {
4828         case Int32Use:
4829             int32Value.emplace(this, valueEdge);
4830             valueGPR = int32Value-&gt;gpr();
4831             break;
4832         case DoubleRepUse:
4833             doubleValue.emplace(this, valueEdge);
4834             valueFPR = doubleValue-&gt;fpr();
4835             if (data.byteSize == 4) {
4836                 fprTemporary.emplace(this);
4837                 tempFPR = fprTemporary-&gt;fpr();
4838             }
4839             break;
4840         case Int52RepUse:
4841             int52Value.emplace(this, valueEdge);
4842             valueGPR = int52Value-&gt;gpr();
4843             break;
4844         default:
4845             RELEASE_ASSERT_NOT_REACHED();
4846         }
4847 
4848         GPRTemporary temp1(this);
4849         GPRReg t1 = temp1.gpr();
4850         GPRTemporary temp2(this);
4851         GPRReg t2 = temp2.gpr();
4852         GPRTemporary temp3(this);
4853         GPRReg t3 = temp3.gpr();
4854 
4855         Optional&lt;SpeculateBooleanOperand&gt; isLittleEndianOperand;
4856         if (m_graph.varArgChild(node, 3))
4857             isLittleEndianOperand.emplace(this, m_graph.varArgChild(node, 3));
4858         GPRReg isLittleEndianGPR = isLittleEndianOperand ? isLittleEndianOperand-&gt;gpr() : InvalidGPRReg;
4859 
4860         m_jit.zeroExtend32ToPtr(indexGPR, t2);
4861         if (data.byteSize &gt; 1)
4862             m_jit.add64(TrustedImm32(data.byteSize - 1), t2);
4863         m_jit.load32(MacroAssembler::Address(dataViewGPR, JSArrayBufferView::offsetOfLength()), t1);
4864         speculationCheck(OutOfBounds, JSValueRegs(), node,
4865             m_jit.branch64(MacroAssembler::AboveOrEqual, t2, t1));
4866 
4867         m_jit.loadPtr(JITCompiler::Address(dataViewGPR, JSArrayBufferView::offsetOfVector()), t2);
4868         cageTypedArrayStorage(t2);
4869 
4870         m_jit.zeroExtend32ToPtr(indexGPR, t1);
4871         auto baseIndex = JITCompiler::BaseIndex(t2, t1, MacroAssembler::TimesOne);
4872 
4873         if (data.isFloatingPoint) {
4874             RELEASE_ASSERT(valueFPR != InvalidFPRReg);
4875             if (data.byteSize == 4) {
4876                 RELEASE_ASSERT(tempFPR != InvalidFPRReg);
4877                 m_jit.convertDoubleToFloat(valueFPR, tempFPR);
4878 
4879                 auto emitLittleEndianCode = [&amp;] {
4880                     m_jit.storeFloat(tempFPR, baseIndex);
4881                 };
4882 
4883                 auto emitBigEndianCode = [&amp;] {
4884                     m_jit.moveFloatTo32(tempFPR, t3);
4885                     m_jit.byteSwap32(t3);
4886                     m_jit.store32(t3, baseIndex);
4887                 };
4888 
4889                 if (data.isLittleEndian == FalseTriState)
4890                     emitBigEndianCode();
4891                 else if (data.isLittleEndian == TrueTriState)
4892                     emitLittleEndianCode();
4893                 else {
4894                     RELEASE_ASSERT(isLittleEndianGPR != InvalidGPRReg);
4895                     auto isBigEndian = m_jit.branchTest32(MacroAssembler::Zero, isLittleEndianGPR, TrustedImm32(1));
4896                     emitLittleEndianCode();
4897                     auto done = m_jit.jump();
4898                     isBigEndian.link(&amp;m_jit);
4899                     emitBigEndianCode();
4900                     done.link(&amp;m_jit);
4901                 }
4902             } else {
4903                 RELEASE_ASSERT(data.byteSize == 8);
4904                 RELEASE_ASSERT(valueFPR != InvalidFPRReg);
4905 
4906                 auto emitLittleEndianCode = [&amp;] {
4907                     m_jit.storeDouble(valueFPR, baseIndex);
4908                 };
4909                 auto emitBigEndianCode = [&amp;] {
4910                     m_jit.moveDoubleTo64(valueFPR, t3);
4911                     m_jit.byteSwap64(t3);
4912                     m_jit.store64(t3, baseIndex);
4913                 };
4914 
4915                 if (data.isLittleEndian == FalseTriState)
4916                     emitBigEndianCode();
4917                 else if (data.isLittleEndian == TrueTriState)
4918                     emitLittleEndianCode();
4919                 else {
4920                     RELEASE_ASSERT(isLittleEndianGPR != InvalidGPRReg);
4921                     auto isBigEndian = m_jit.branchTest32(MacroAssembler::Zero, isLittleEndianGPR, TrustedImm32(1));
4922                     emitLittleEndianCode();
4923                     auto done = m_jit.jump();
4924                     isBigEndian.link(&amp;m_jit);
4925                     emitBigEndianCode();
4926                     done.link(&amp;m_jit);
4927                 }
4928             }
4929         } else {
4930             switch (data.byteSize) {
4931             case 1:
4932                 RELEASE_ASSERT(valueEdge.useKind() == Int32Use);
4933                 RELEASE_ASSERT(valueGPR != InvalidGPRReg);
4934                 m_jit.store8(valueGPR, baseIndex);
4935                 break;
4936             case 2: {
4937                 RELEASE_ASSERT(valueEdge.useKind() == Int32Use);
4938                 RELEASE_ASSERT(valueGPR != InvalidGPRReg);
4939 
4940                 auto emitLittleEndianCode = [&amp;] {
4941                     m_jit.store16(valueGPR, baseIndex);
4942                 };
4943                 auto emitBigEndianCode = [&amp;] {
4944                     m_jit.move(valueGPR, t3);
4945                     m_jit.byteSwap16(t3);
4946                     m_jit.store16(t3, baseIndex);
4947                 };
4948 
4949                 if (data.isLittleEndian == FalseTriState)
4950                     emitBigEndianCode();
4951                 else if (data.isLittleEndian == TrueTriState)
4952                     emitLittleEndianCode();
4953                 else {
4954                     RELEASE_ASSERT(isLittleEndianGPR != InvalidGPRReg);
4955                     auto isBigEndian = m_jit.branchTest32(MacroAssembler::Zero, isLittleEndianGPR, TrustedImm32(1));
4956                     emitLittleEndianCode();
4957                     auto done = m_jit.jump();
4958                     isBigEndian.link(&amp;m_jit);
4959                     emitBigEndianCode();
4960                     done.link(&amp;m_jit);
4961                 }
4962                 break;
4963             }
4964             case 4: {
4965                 RELEASE_ASSERT(valueEdge.useKind() == Int32Use || valueEdge.useKind() == Int52RepUse);
4966 
4967                 auto emitLittleEndianCode = [&amp;] {
4968                     m_jit.store32(valueGPR, baseIndex);
4969                 };
4970 
4971                 auto emitBigEndianCode = [&amp;] {
4972                     m_jit.zeroExtend32ToPtr(valueGPR, t3);
4973                     m_jit.byteSwap32(t3);
4974                     m_jit.store32(t3, baseIndex);
4975                 };
4976 
4977                 if (data.isLittleEndian == FalseTriState)
4978                     emitBigEndianCode();
4979                 else if (data.isLittleEndian == TrueTriState)
4980                     emitLittleEndianCode();
4981                 else {
4982                     RELEASE_ASSERT(isLittleEndianGPR != InvalidGPRReg);
4983                     auto isBigEndian = m_jit.branchTest32(MacroAssembler::Zero, isLittleEndianGPR, TrustedImm32(1));
4984                     emitLittleEndianCode();
4985                     auto done = m_jit.jump();
4986                     isBigEndian.link(&amp;m_jit);
4987                     emitBigEndianCode();
4988                     done.link(&amp;m_jit);
4989                 }
4990 
4991                 break;
4992             }
4993             default:
4994                 RELEASE_ASSERT_NOT_REACHED();
4995             }
4996         }
4997 
4998         noResult(node);
4999         break;
5000     }
5001 
5002 #if ENABLE(FTL_JIT)
5003     case CheckTierUpInLoop: {
5004         MacroAssembler::Jump callTierUp = m_jit.branchAdd32(
5005             MacroAssembler::PositiveOrZero,
5006             TrustedImm32(Options::ftlTierUpCounterIncrementForLoop()),
5007             MacroAssembler::AbsoluteAddress(&amp;m_jit.jitCode()-&gt;tierUpCounter.m_counter));
5008 
5009         MacroAssembler::Label toNextOperation = m_jit.label();
5010 
5011         Vector&lt;SilentRegisterSavePlan&gt; savePlans;
5012         silentSpillAllRegistersImpl(false, savePlans, InvalidGPRReg);
5013         unsigned bytecodeIndex = node-&gt;origin.semantic.bytecodeIndex;
5014 
5015         addSlowPathGeneratorLambda([=]() {
5016             callTierUp.link(&amp;m_jit);
5017 
5018             silentSpill(savePlans);
5019             callOperation(triggerTierUpNowInLoop, TrustedImm32(bytecodeIndex));
5020             silentFill(savePlans);
5021 
5022             m_jit.jump().linkTo(toNextOperation, &amp;m_jit);
5023         });
5024         break;
5025     }
5026 
5027     case CheckTierUpAtReturn: {
5028         MacroAssembler::Jump done = m_jit.branchAdd32(
5029             MacroAssembler::Signed,
5030             TrustedImm32(Options::ftlTierUpCounterIncrementForReturn()),
5031             MacroAssembler::AbsoluteAddress(&amp;m_jit.jitCode()-&gt;tierUpCounter.m_counter));
5032 
5033         silentSpillAllRegisters(InvalidGPRReg);
5034         callOperation(triggerTierUpNow);
5035         silentFillAllRegisters();
5036 
5037         done.link(&amp;m_jit);
5038         break;
5039     }
5040 
5041     case CheckTierUpAndOSREnter: {
5042         ASSERT(!node-&gt;origin.semantic.inlineCallFrame);
5043 
5044         GPRTemporary temp(this);
5045         GPRReg tempGPR = temp.gpr();
5046 
5047         unsigned bytecodeIndex = node-&gt;origin.semantic.bytecodeIndex;
5048         auto triggerIterator = m_jit.jitCode()-&gt;tierUpEntryTriggers.find(bytecodeIndex);
5049         DFG_ASSERT(m_jit.graph(), node, triggerIterator != m_jit.jitCode()-&gt;tierUpEntryTriggers.end());
5050         JITCode::TriggerReason* forceEntryTrigger = &amp;(m_jit.jitCode()-&gt;tierUpEntryTriggers.find(bytecodeIndex)-&gt;value);
5051         static_assert(!static_cast&lt;uint8_t&gt;(JITCode::TriggerReason::DontTrigger), &quot;the JIT code assumes non-zero means &#39;enter&#39;&quot;);
5052         static_assert(sizeof(JITCode::TriggerReason) == 1, &quot;branchTest8 assumes this size&quot;);
5053 
5054         MacroAssembler::Jump forceOSREntry = m_jit.branchTest8(MacroAssembler::NonZero, MacroAssembler::AbsoluteAddress(forceEntryTrigger));
5055         MacroAssembler::Jump overflowedCounter = m_jit.branchAdd32(
5056             MacroAssembler::PositiveOrZero,
5057             TrustedImm32(Options::ftlTierUpCounterIncrementForLoop()),
5058             MacroAssembler::AbsoluteAddress(&amp;m_jit.jitCode()-&gt;tierUpCounter.m_counter));
5059         MacroAssembler::Label toNextOperation = m_jit.label();
5060 
5061         Vector&lt;SilentRegisterSavePlan&gt; savePlans;
5062         silentSpillAllRegistersImpl(false, savePlans, tempGPR);
5063 
5064         unsigned streamIndex = m_stream-&gt;size();
5065         m_jit.jitCode()-&gt;bytecodeIndexToStreamIndex.add(bytecodeIndex, streamIndex);
5066 
5067         addSlowPathGeneratorLambda([=]() {
5068             forceOSREntry.link(&amp;m_jit);
5069             overflowedCounter.link(&amp;m_jit);
5070 
5071             silentSpill(savePlans);
5072             callOperation(triggerOSREntryNow, tempGPR, TrustedImm32(bytecodeIndex));
5073 
5074             if (savePlans.isEmpty())
5075                 m_jit.branchTestPtr(MacroAssembler::Zero, tempGPR).linkTo(toNextOperation, &amp;m_jit);
5076             else {
5077                 MacroAssembler::Jump osrEnter = m_jit.branchTestPtr(MacroAssembler::NonZero, tempGPR);
5078                 silentFill(savePlans);
5079                 m_jit.jump().linkTo(toNextOperation, &amp;m_jit);
5080                 osrEnter.link(&amp;m_jit);
5081             }
5082             m_jit.emitRestoreCalleeSaves();
5083             m_jit.jump(tempGPR, GPRInfo::callFrameRegister);
5084         });
5085         break;
5086     }
5087 
5088 #else // ENABLE(FTL_JIT)
5089     case CheckTierUpInLoop:
5090     case CheckTierUpAtReturn:
5091     case CheckTierUpAndOSREnter:
5092         DFG_CRASH(m_jit.graph(), node, &quot;Unexpected tier-up node&quot;);
5093         break;
5094 #endif // ENABLE(FTL_JIT)
5095 
5096     case FilterCallLinkStatus:
5097     case FilterGetByIdStatus:
5098     case FilterPutByIdStatus:
5099     case FilterInByIdStatus:
5100         m_interpreter.filterICStatus(node);
5101         noResult(node);
5102         break;
5103 
5104     case LastNodeType:
5105     case EntrySwitch:
5106     case InitializeEntrypointArguments:
5107     case Phi:
5108     case Upsilon:
5109     case ExtractOSREntryLocal:
5110     case CheckInBounds:
5111     case ArithIMul:
5112     case MultiGetByOffset:
5113     case MultiPutByOffset:
5114     case FiatInt52:
5115     case CheckBadCell:
5116     case BottomValue:
5117     case PhantomNewObject:
5118     case PhantomNewFunction:
5119     case PhantomNewGeneratorFunction:
5120     case PhantomNewAsyncFunction:
5121     case PhantomNewAsyncGeneratorFunction:
5122     case PhantomCreateActivation:
5123     case PhantomNewRegexp:
5124     case GetMyArgumentByVal:
5125     case GetMyArgumentByValOutOfBounds:
5126     case GetVectorLength:
5127     case PutHint:
5128     case CheckStructureImmediate:
5129     case MaterializeCreateActivation:
5130     case PutStack:
5131     case KillStack:
5132     case GetStack:
5133     case PhantomCreateRest:
5134     case PhantomSpread:
5135     case PhantomNewArrayWithSpread:
5136     case PhantomNewArrayBuffer:
5137     case IdentityWithProfile:
5138     case CPUIntrinsic:
5139         DFG_CRASH(m_jit.graph(), node, &quot;Unexpected node&quot;);
5140         break;
5141     }
5142 
5143     if (!m_compileOkay)
5144         return;
5145 
5146     if (node-&gt;hasResult() &amp;&amp; node-&gt;mustGenerate())
5147         use(node);
5148 }
5149 
5150 void SpeculativeJIT::moveTrueTo(GPRReg gpr)
5151 {
5152     m_jit.move(TrustedImm32(ValueTrue), gpr);
5153 }
5154 
5155 void SpeculativeJIT::moveFalseTo(GPRReg gpr)
5156 {
5157     m_jit.move(TrustedImm32(ValueFalse), gpr);
5158 }
5159 
5160 void SpeculativeJIT::blessBoolean(GPRReg gpr)
5161 {
5162     m_jit.or32(TrustedImm32(ValueFalse), gpr);
5163 }
5164 
5165 void SpeculativeJIT::convertAnyInt(Edge valueEdge, GPRReg resultGPR)
5166 {
5167     JSValueOperand value(this, valueEdge, ManualOperandSpeculation);
5168     GPRReg valueGPR = value.gpr();
5169 
5170     JITCompiler::Jump notInt32 = m_jit.branchIfNotInt32(valueGPR);
5171 
5172     m_jit.signExtend32ToPtr(valueGPR, resultGPR);
5173     JITCompiler::Jump done = m_jit.jump();
5174 
5175     notInt32.link(&amp;m_jit);
5176     silentSpillAllRegisters(resultGPR);
5177     callOperation(operationConvertBoxedDoubleToInt52, resultGPR, valueGPR);
5178     silentFillAllRegisters();
5179 
5180     DFG_TYPE_CHECK(
5181         JSValueRegs(valueGPR), valueEdge, SpecInt32Only | SpecAnyIntAsDouble,
5182         m_jit.branch64(
5183             JITCompiler::Equal, resultGPR,
5184             JITCompiler::TrustedImm64(JSValue::notInt52)));
5185     done.link(&amp;m_jit);
5186 }
5187 
5188 void SpeculativeJIT::speculateAnyInt(Edge edge)
5189 {
5190     if (!needsTypeCheck(edge, SpecInt32Only | SpecAnyIntAsDouble))
5191         return;
5192 
5193     GPRTemporary temp(this);
5194     convertAnyInt(edge, temp.gpr());
5195 }
5196 
5197 void SpeculativeJIT::speculateInt32(Edge edge, JSValueRegs regs)
5198 {
5199     DFG_TYPE_CHECK(regs, edge, SpecInt32Only, m_jit.branchIfNotInt32(regs));
5200 }
5201 
5202 void SpeculativeJIT::speculateDoubleRepAnyInt(Edge edge)
5203 {
5204     if (!needsTypeCheck(edge, SpecAnyIntAsDouble))
5205         return;
5206 
5207     SpeculateDoubleOperand value(this, edge);
5208     FPRReg valueFPR = value.fpr();
5209 
5210     flushRegisters();
5211     GPRFlushedCallResult result(this);
5212     GPRReg resultGPR = result.gpr();
5213     callOperation(operationConvertDoubleToInt52, resultGPR, valueFPR);
5214 
5215     DFG_TYPE_CHECK(
5216         JSValueRegs(), edge, SpecAnyIntAsDouble,
5217         m_jit.branch64(
5218             JITCompiler::Equal, resultGPR,
5219             JITCompiler::TrustedImm64(JSValue::notInt52)));
5220 }
5221 
5222 void SpeculativeJIT::compileArithRandom(Node* node)
5223 {
5224     JSGlobalObject* globalObject = m_jit.graph().globalObjectFor(node-&gt;origin.semantic);
5225     GPRTemporary temp1(this);
5226     GPRTemporary temp2(this);
5227     GPRTemporary temp3(this);
5228     FPRTemporary result(this);
5229     m_jit.emitRandomThunk(globalObject, temp1.gpr(), temp2.gpr(), temp3.gpr(), result.fpr());
5230     doubleResult(result.fpr(), node);
5231 }
5232 
5233 #endif
5234 
5235 } } // namespace JSC::DFG
5236 
5237 #endif
    </pre>
  </body>
</html>