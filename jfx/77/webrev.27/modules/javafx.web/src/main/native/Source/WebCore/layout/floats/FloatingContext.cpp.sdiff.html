<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/layout/floats/FloatingContext.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="FloatBox.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="FloatingContext.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/layout/floats/FloatingContext.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;FloatingContext.h&quot;
 28 
 29 #if ENABLE(LAYOUT_FORMATTING_CONTEXT)
 30 
 31 #include &quot;DisplayBox.h&quot;
 32 #include &quot;FloatAvoider.h&quot;
 33 #include &quot;FloatBox.h&quot;

 34 #include &quot;LayoutBox.h&quot;
 35 #include &quot;LayoutContainer.h&quot;
 36 #include &quot;LayoutState.h&quot;
 37 #include &lt;wtf/IsoMallocInlines.h&gt;
 38 
 39 namespace WebCore {
 40 namespace Layout {
 41 
 42 WTF_MAKE_ISO_ALLOCATED_IMPL(FloatingContext);
 43 
 44 // Finding the top/left position for a new floating(F)
 45 //  ____  ____  _____               _______
 46 // |    || L2 ||     | &lt;-----1----&gt;|       |
 47 // |    ||____||  L3 |             |   R1  |
 48 // | L1 |      |_____|             |       |
 49 // |____| &lt;-------------2---------&gt;|       |
 50 //                                 |       |
 51 //                                 |_______|
 52 //
 53 // 1. Compute the initial vertical position for (F) -&gt; (1)
 54 // 2. Find the corresponding floating pair (L3-R1)
 55 // 3. Align (F) horizontally with (L3-R1) depending whether (F) is left/right positioned
 56 // 4. Intersect (F) with (L3-R1)
 57 // 5. If (F) does not fit, find the next floating pair (L1-R1)
 58 // 6. Repeat until either (F) fits/no more floats.
 59 // Note that all coordinates are in the coordinate system of the formatting root.
 60 // The formatting root here is always the one that establishes the floating context (see inherited floating context).
 61 // (It simply means that the float box&#39;s formatting root is not necessarily the same as the FormattingContext&#39;s root.)
 62 
 63 class Iterator;
 64 
<span class="line-modified"> 65 class FloatingPair {</span>
 66 public:
<span class="line-modified"> 67     bool isEmpty() const { return !m_leftIndex &amp;&amp; !m_rightIndex; }</span>







 68     const FloatingState::FloatItem* left() const;
 69     const FloatingState::FloatItem* right() const;
<span class="line-modified"> 70     bool intersects(const Display::Box::Rect&amp;) const;</span>
 71     PositionInContextRoot verticalConstraint() const { return m_verticalPosition; }
 72     FloatAvoider::HorizontalConstraints horizontalConstraints() const;
 73     PositionInContextRoot bottom() const;
<span class="line-modified"> 74     bool operator==(const FloatingPair&amp;) const;</span>

 75 
 76 private:
 77     friend class Iterator;
<span class="line-modified"> 78     FloatingPair(const FloatingState::FloatList&amp;);</span>
 79 
 80     const FloatingState::FloatList&amp; m_floats;
<span class="line-modified"> 81 </span>
<span class="line-removed"> 82     Optional&lt;unsigned&gt; m_leftIndex;</span>
<span class="line-removed"> 83     Optional&lt;unsigned&gt; m_rightIndex;</span>
 84     PositionInContextRoot m_verticalPosition;
 85 };
 86 
 87 class Iterator {
 88 public:
 89     Iterator(const FloatingState::FloatList&amp;, Optional&lt;PositionInContextRoot&gt; verticalPosition);
 90 
<span class="line-modified"> 91     const FloatingPair&amp; operator*() const { return m_current; }</span>
 92     Iterator&amp; operator++();
 93     bool operator==(const Iterator&amp;) const;
 94     bool operator!=(const Iterator&amp;) const;
 95 
 96 private:
 97     void set(PositionInContextRoot verticalPosition);
 98 
 99     const FloatingState::FloatList&amp; m_floats;
<span class="line-modified">100     FloatingPair m_current;</span>
101 };
102 
<span class="line-modified">103 static Iterator begin(const FloatingState&amp; floatingState, PositionInContextRoot initialVerticalPosition)</span>
104 {
105     // Start with the inner-most floating pair for the initial vertical position.
<span class="line-modified">106     return Iterator(floatingState.floats(), initialVerticalPosition);</span>
107 }
108 
<span class="line-modified">109 static Iterator end(const FloatingState&amp; floatingState)</span>
110 {
<span class="line-modified">111     return Iterator(floatingState.floats(), WTF::nullopt);</span>
112 }
113 
114 #ifndef NDEBUG
115 static bool areFloatsHorizontallySorted(const FloatingState&amp; floatingState)
116 {
117     auto&amp; floats = floatingState.floats();
118     auto rightEdgeOfLeftFloats = LayoutUnit::min();
119     auto leftEdgeOfRightFloats = LayoutUnit::max();
120     WTF::Optional&lt;LayoutUnit&gt; leftBottom;
121     WTF::Optional&lt;LayoutUnit&gt; rightBottom;
122 
123     for (auto&amp; floatItem : floats) {
124         if (floatItem.isLeftPositioned()) {
125             auto rightEdge = floatItem.rectWithMargin().right();
126             if (rightEdge &lt; rightEdgeOfLeftFloats) {
127                 if (leftBottom &amp;&amp; floatItem.rectWithMargin().top() &lt; *leftBottom)
128                     return false;
129             }
130             leftBottom = floatItem.rectWithMargin().bottom();
131             rightEdgeOfLeftFloats = rightEdge;
</pre>
<hr />
<pre>
155 
156     if (m_floatingState.isEmpty()) {
157         auto&amp; displayBox = layoutState().displayBoxForLayoutBox(layoutBox);
158 
159         auto alignWithContainingBlock = [&amp;]() -&gt; Position {
160             // If there is no floating to align with, push the box to the left/right edge of its containing block&#39;s content box.
161             auto&amp; containingBlockDisplayBox = layoutState().displayBoxForLayoutBox(*layoutBox.containingBlock());
162 
163             if (layoutBox.isLeftFloatingPositioned())
164                 return Position { containingBlockDisplayBox.contentBoxLeft() + displayBox.marginStart() };
165 
166             return Position { containingBlockDisplayBox.contentBoxRight() - displayBox.marginEnd() - displayBox.width() };
167         };
168 
169         // No float box on the context yet -&gt; align it with the containing block&#39;s left/right edge.
170         return { alignWithContainingBlock(), displayBox.top() };
171     }
172 
173     // Find the top most position where the float box fits.
174     FloatBox floatBox = { layoutBox, m_floatingState, layoutState() };
<span class="line-modified">175     floatingPosition(floatBox);</span>
176     return floatBox.rectInContainingBlock().topLeft();
177 }
178 
<span class="line-modified">179 Optional&lt;Point&gt; FloatingContext::positionForFloatAvoiding(const Box&amp; layoutBox) const</span>
180 {
181     ASSERT(layoutBox.establishesBlockFormattingContext());
182     ASSERT(!layoutBox.isFloatingPositioned());
183     ASSERT(!layoutBox.hasFloatClear());
184     ASSERT(areFloatsHorizontallySorted(m_floatingState));
185 
186     if (m_floatingState.isEmpty())
187         return { };
188 
189     FloatAvoider floatAvoider = { layoutBox, m_floatingState, layoutState() };
<span class="line-modified">190     floatingPosition(floatAvoider);</span>
191     return { floatAvoider.rectInContainingBlock().topLeft() };
192 }
193 
194 FloatingContext::ClearancePosition FloatingContext::verticalPositionWithClearance(const Box&amp; layoutBox) const
195 {
196     ASSERT(layoutBox.hasFloatClear());
197     ASSERT(layoutBox.isBlockLevelBox());
198     ASSERT(areFloatsHorizontallySorted(m_floatingState));
199 
200     if (m_floatingState.isEmpty())
201         return { };
202 
203     auto bottom = [&amp;](Optional&lt;PositionInContextRoot&gt; floatBottom) -&gt; ClearancePosition {
204         // &#39;bottom&#39; is in the formatting root&#39;s coordinate system.
205         if (!floatBottom)
206             return { };
207 
208         // 9.5.2 Controlling flow next to floats: the &#39;clear&#39; property
209         // Then the amount of clearance is set to the greater of:
210         //
</pre>
<hr />
<pre>
242         auto containingBlockRootRelativeTop = FormattingContext::mapTopToAncestor(layoutState, *layoutBox.containingBlock(), downcast&lt;Container&gt;(m_floatingState.root()));
243         return { Position { rootRelativeTop - containingBlockRootRelativeTop }, clearance };
244     };
245 
246     auto clear = layoutBox.style().clear();
247     auto&amp; formattingContextRoot = layoutBox.formattingContextRoot();
248 
249     if (clear == Clear::Left)
250         return bottom(m_floatingState.leftBottom(formattingContextRoot));
251 
252     if (clear == Clear::Right)
253         return bottom(m_floatingState.rightBottom(formattingContextRoot));
254 
255     if (clear == Clear::Both)
256         return bottom(m_floatingState.bottom(formattingContextRoot));
257 
258     ASSERT_NOT_REACHED();
259     return { };
260 }
261 
<span class="line-modified">262 void FloatingContext::floatingPosition(FloatAvoider&amp; floatAvoider) const</span>
263 {
<span class="line-removed">264     // Ensure the float avoider starts with no constraints.</span>
<span class="line-removed">265     floatAvoider.resetPosition();</span>
<span class="line-removed">266 </span>
267     Optional&lt;PositionInContextRoot&gt; bottomMost;
<span class="line-modified">268     auto end = Layout::end(m_floatingState);</span>
<span class="line-modified">269     for (auto iterator = begin(m_floatingState, { floatAvoider.rect().top() }); iterator != end; ++iterator) {</span>

270         ASSERT(!(*iterator).isEmpty());
<span class="line-modified">271         auto floats = *iterator;</span>

272 
273         // Move the box horizontally so that it either
274         // 1. aligns with the current floating pair
275         // 2. or with the containing block&#39;s content box if there&#39;s no float to align with at this vertical position.
<span class="line-modified">276         floatAvoider.setHorizontalConstraints(floats.horizontalConstraints());</span>
<span class="line-modified">277         floatAvoider.setVerticalConstraint(floats.verticalConstraint());</span>
278 
279         // Ensure that the float avoider
<span class="line-modified">280         // 1. does not overflow its containing block with the current horiztonal constraints</span>

281         // 2. avoids floats on both sides.
<span class="line-modified">282         if (!floatAvoider.overflowsContainingBlock() &amp;&amp; !floats.intersects(floatAvoider.rect()))</span>
<span class="line-modified">283             return;</span>
284 
<span class="line-modified">285         bottomMost = floats.bottom();</span>
286         // Move to the next floating pair.
287     }
288 
289     // The candidate box is already below of all the floats.
290     if (!bottomMost)
<span class="line-modified">291         return;</span>
292 
293     // Passed all the floats and still does not fit? Push it below the last float.
294     floatAvoider.setVerticalConstraint(*bottomMost);
295     floatAvoider.setHorizontalConstraints({ });














































296 }
297 
<span class="line-modified">298 FloatingPair::FloatingPair(const FloatingState::FloatList&amp; floats)</span>
299     : m_floats(floats)
300 {
301 }
302 
<span class="line-modified">303 const FloatingState::FloatItem* FloatingPair::left() const</span>
304 {
<span class="line-modified">305     if (!m_leftIndex)</span>
306         return nullptr;
307 
<span class="line-modified">308     ASSERT(m_floats[*m_leftIndex].isLeftPositioned());</span>
<span class="line-modified">309     return &amp;m_floats[*m_leftIndex];</span>
310 }
311 
<span class="line-modified">312 const FloatingState::FloatItem* FloatingPair::right() const</span>
313 {
<span class="line-modified">314     if (!m_rightIndex)</span>
315         return nullptr;
316 
<span class="line-modified">317     ASSERT(!m_floats[*m_rightIndex].isLeftPositioned());</span>
<span class="line-modified">318     return &amp;m_floats[*m_rightIndex];</span>
319 }
320 
<span class="line-modified">321 bool FloatingPair::intersects(const Display::Box::Rect&amp; candidateRect) const</span>
322 {
<span class="line-modified">323     auto intersects = [&amp;](const FloatingState::FloatItem* floating, Float floatingType) {</span>
<span class="line-modified">324         if (!floating)</span>
<span class="line-removed">325             return false;</span>
<span class="line-removed">326 </span>
<span class="line-removed">327         auto marginRect = floating-&gt;rectWithMargin();</span>
<span class="line-removed">328         // Before intersecting, check if the candidate position is too far to the left/right.</span>
<span class="line-removed">329         // The new float&#39;s containing block could push the candidate position beyond the current float horizontally.</span>
<span class="line-removed">330         if ((floatingType == Float::Left &amp;&amp; candidateRect.left() &lt; marginRect.right())</span>
<span class="line-removed">331             || (floatingType == Float::Right &amp;&amp; candidateRect.right() &gt; marginRect.left()))</span>
<span class="line-removed">332             return true;</span>
<span class="line-removed">333         return marginRect.intersects(candidateRect);</span>
334     };
335 
<span class="line-modified">336     if (!m_leftIndex &amp;&amp; !m_rightIndex) {</span>
<span class="line-modified">337         ASSERT_NOT_REACHED();</span>
<span class="line-removed">338         return false;</span>
<span class="line-removed">339     }</span>
<span class="line-removed">340 </span>
<span class="line-removed">341     if (intersects(left(), Float::Left))</span>
<span class="line-removed">342         return true;</span>
<span class="line-removed">343 </span>
<span class="line-removed">344     if (intersects(right(), Float::Right))</span>
<span class="line-removed">345         return true;</span>
<span class="line-removed">346 </span>
<span class="line-removed">347     return false;</span>
348 }
349 
<span class="line-modified">350 bool FloatingPair::operator ==(const FloatingPair&amp; other) const</span>
351 {
<span class="line-modified">352     return m_leftIndex == other.m_leftIndex &amp;&amp; m_rightIndex == other.m_rightIndex;</span>
353 }
354 
<span class="line-modified">355 FloatAvoider::HorizontalConstraints FloatingPair::horizontalConstraints() const</span>
356 {
357     Optional&lt;PositionInContextRoot&gt; leftEdge;
358     Optional&lt;PositionInContextRoot&gt; rightEdge;
359 
360     if (left())
361         leftEdge = PositionInContextRoot { left()-&gt;rectWithMargin().right() };
362 
363     if (right())
364         rightEdge = PositionInContextRoot { right()-&gt;rectWithMargin().left() };
365 
366     return { leftEdge, rightEdge };
367 }
368 
<span class="line-modified">369 PositionInContextRoot FloatingPair::bottom() const</span>
370 {
371     auto* left = this-&gt;left();
372     auto* right = this-&gt;right();
373     ASSERT(left || right);
374 
375     auto leftBottom = left ? Optional&lt;PositionInContextRoot&gt;(PositionInContextRoot { left-&gt;rectWithMargin().bottom() }) : WTF::nullopt;
376     auto rightBottom = right ? Optional&lt;PositionInContextRoot&gt;(PositionInContextRoot { right-&gt;rectWithMargin().bottom() }) : WTF::nullopt;
377 
378     if (leftBottom &amp;&amp; rightBottom)
379         return std::max(*leftBottom, *rightBottom);
380 
381     if (leftBottom)
382         return *leftBottom;
383 
384     return *rightBottom;
385 }
386 
387 Iterator::Iterator(const FloatingState::FloatList&amp; floats, Optional&lt;PositionInContextRoot&gt; verticalPosition)
388     : m_floats(floats)
389     , m_current(floats)
</pre>
<hr />
<pre>
432                 return index;
433         }
434 
435         ASSERT_NOT_REACHED();
436         return { };
437     };
438 
439     // 1. Take the current floating from left and right and check which one&#39;s bottom edge is positioned higher (they could be on the same vertical position too).
440     // The current floats from left and right are considered the inner-most pair for the current vertical position.
441     // 2. Move away from inner-most pair by picking one of the previous floats in the list(#1)
442     // Ensure that the new floating&#39;s bottom edge is positioned lower than the current one -which essentially means skipping in-between floats that are positioned higher).
443     // 3. Reset the vertical position and align it with the new left-right pair. These floats are now the inner-most boxes for the current vertical position.
444     // As the result we have more horizontal space on the current vertical position.
445     auto leftBottom = m_current.left() ? Optional&lt;PositionInContextRoot&gt;(m_current.left()-&gt;bottom()) : WTF::nullopt;
446     auto rightBottom = m_current.right() ? Optional&lt;PositionInContextRoot&gt;(m_current.right()-&gt;bottom()) : WTF::nullopt;
447 
448     auto updateLeft = (leftBottom == rightBottom) || (!rightBottom || (leftBottom &amp;&amp; leftBottom &lt; rightBottom));
449     auto updateRight = (leftBottom == rightBottom) || (!leftBottom || (rightBottom &amp;&amp; leftBottom &gt; rightBottom));
450 
451     if (updateLeft) {
<span class="line-modified">452         ASSERT(m_current.m_leftIndex);</span>
453         m_current.m_verticalPosition = *leftBottom;
<span class="line-modified">454         m_current.m_leftIndex = findPreviousFloatingWithLowerBottom(Float::Left, *m_current.m_leftIndex);</span>
455     }
456 
457     if (updateRight) {
<span class="line-modified">458         ASSERT(m_current.m_rightIndex);</span>
459         m_current.m_verticalPosition = *rightBottom;
<span class="line-modified">460         m_current.m_rightIndex = findPreviousFloatingWithLowerBottom(Float::Right, *m_current.m_rightIndex);</span>
461     }
462 
463     return *this;
464 }
465 
466 void Iterator::set(PositionInContextRoot verticalPosition)
467 {
468     // Move the iterator to the initial vertical position by starting at the inner-most floating pair (last floats on left/right).
469     // 1. Check if the inner-most pair covers the vertical position.
470     // 2. Move outwards from the inner-most pair until the vertical postion intersects.
<span class="line-removed">471     // (Note that verticalPosition has already been adjusted with the top of the last float.)</span>
<span class="line-removed">472 </span>
473     m_current.m_verticalPosition = verticalPosition;
474     // No floats at all?
475     if (m_floats.isEmpty()) {
476         ASSERT_NOT_REACHED();
<span class="line-modified">477 </span>
<span class="line-removed">478         m_current.m_leftIndex = { };</span>
<span class="line-removed">479         m_current.m_rightIndex = { };</span>
480         return;
481     }
482 
483     auto findFloatingBelow = [&amp;](Float floatingType) -&gt; Optional&lt;unsigned&gt; {
484 
485         ASSERT(!m_floats.isEmpty());
486 
<span class="line-modified">487         auto index = floatingType == Float::Left ? m_current.m_leftIndex : m_current.m_rightIndex;</span>
488         // Start from the end if we don&#39;t have current yet.
489         index = index.valueOr(m_floats.size());
490         while (true) {
491             index = previousFloatingIndex(floatingType, m_floats, *index);
492             if (!index)
493                 return { };
494 
<span class="line-removed">495             auto bottom = m_floats[*index].rectWithMargin().bottom();</span>
496             // Is this floating intrusive on this position?
<span class="line-modified">497             if (bottom &gt; verticalPosition)</span>

498                 return index;
499         }
500 
501         return { };
502     };
503 
<span class="line-modified">504     m_current.m_leftIndex = findFloatingBelow(Float::Left);</span>
<span class="line-modified">505     m_current.m_rightIndex = findFloatingBelow(Float::Right);</span>
506 
<span class="line-modified">507     ASSERT(!m_current.m_leftIndex || (*m_current.m_leftIndex &lt; m_floats.size() &amp;&amp; m_floats[*m_current.m_leftIndex].isLeftPositioned()));</span>
<span class="line-modified">508     ASSERT(!m_current.m_rightIndex || (*m_current.m_rightIndex &lt; m_floats.size() &amp;&amp; !m_floats[*m_current.m_rightIndex].isLeftPositioned()));</span>
509 }
510 
511 bool Iterator::operator==(const Iterator&amp; other) const
512 {
513     return m_current == other.m_current;
514 }
515 
516 bool Iterator::operator!=(const Iterator&amp; other) const
517 {
518     return !(*this == other);
519 }
520 
521 }
522 }
523 #endif
</pre>
</td>
<td>
<hr />
<pre>
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;FloatingContext.h&quot;
 28 
 29 #if ENABLE(LAYOUT_FORMATTING_CONTEXT)
 30 
 31 #include &quot;DisplayBox.h&quot;
 32 #include &quot;FloatAvoider.h&quot;
 33 #include &quot;FloatBox.h&quot;
<span class="line-added"> 34 #include &quot;FormattingContext.h&quot;</span>
 35 #include &quot;LayoutBox.h&quot;
 36 #include &quot;LayoutContainer.h&quot;
 37 #include &quot;LayoutState.h&quot;
 38 #include &lt;wtf/IsoMallocInlines.h&gt;
 39 
 40 namespace WebCore {
 41 namespace Layout {
 42 
 43 WTF_MAKE_ISO_ALLOCATED_IMPL(FloatingContext);
 44 
 45 // Finding the top/left position for a new floating(F)
 46 //  ____  ____  _____               _______
 47 // |    || L2 ||     | &lt;-----1----&gt;|       |
 48 // |    ||____||  L3 |             |   R1  |
 49 // | L1 |      |_____|             |       |
 50 // |____| &lt;-------------2---------&gt;|       |
 51 //                                 |       |
 52 //                                 |_______|
 53 //
 54 // 1. Compute the initial vertical position for (F) -&gt; (1)
 55 // 2. Find the corresponding floating pair (L3-R1)
 56 // 3. Align (F) horizontally with (L3-R1) depending whether (F) is left/right positioned
 57 // 4. Intersect (F) with (L3-R1)
 58 // 5. If (F) does not fit, find the next floating pair (L1-R1)
 59 // 6. Repeat until either (F) fits/no more floats.
 60 // Note that all coordinates are in the coordinate system of the formatting root.
 61 // The formatting root here is always the one that establishes the floating context (see inherited floating context).
 62 // (It simply means that the float box&#39;s formatting root is not necessarily the same as the FormattingContext&#39;s root.)
 63 
 64 class Iterator;
 65 
<span class="line-modified"> 66 class FloatPair {</span>
 67 public:
<span class="line-modified"> 68     struct LeftRightIndex {</span>
<span class="line-added"> 69         bool isEmpty() const { return !left &amp;&amp; !right;}</span>
<span class="line-added"> 70 </span>
<span class="line-added"> 71         Optional&lt;unsigned&gt; left;</span>
<span class="line-added"> 72         Optional&lt;unsigned&gt; right;</span>
<span class="line-added"> 73     };</span>
<span class="line-added"> 74 </span>
<span class="line-added"> 75     bool isEmpty() const { return m_floatPair.isEmpty(); }</span>
 76     const FloatingState::FloatItem* left() const;
 77     const FloatingState::FloatItem* right() const;
<span class="line-modified"> 78     bool intersects(const Display::Rect&amp;) const;</span>
 79     PositionInContextRoot verticalConstraint() const { return m_verticalPosition; }
 80     FloatAvoider::HorizontalConstraints horizontalConstraints() const;
 81     PositionInContextRoot bottom() const;
<span class="line-modified"> 82     LeftRightIndex operator*() const { return m_floatPair; };</span>
<span class="line-added"> 83     bool operator==(const FloatPair&amp;) const;</span>
 84 
 85 private:
 86     friend class Iterator;
<span class="line-modified"> 87     FloatPair(const FloatingState::FloatList&amp;);</span>
 88 
 89     const FloatingState::FloatList&amp; m_floats;
<span class="line-modified"> 90     LeftRightIndex m_floatPair;</span>


 91     PositionInContextRoot m_verticalPosition;
 92 };
 93 
 94 class Iterator {
 95 public:
 96     Iterator(const FloatingState::FloatList&amp;, Optional&lt;PositionInContextRoot&gt; verticalPosition);
 97 
<span class="line-modified"> 98     const FloatPair&amp; operator*() const { return m_current; }</span>
 99     Iterator&amp; operator++();
100     bool operator==(const Iterator&amp;) const;
101     bool operator!=(const Iterator&amp;) const;
102 
103 private:
104     void set(PositionInContextRoot verticalPosition);
105 
106     const FloatingState::FloatList&amp; m_floats;
<span class="line-modified">107     FloatPair m_current;</span>
108 };
109 
<span class="line-modified">110 static Iterator begin(const FloatingState::FloatList&amp; floats, PositionInContextRoot initialVerticalPosition)</span>
111 {
112     // Start with the inner-most floating pair for the initial vertical position.
<span class="line-modified">113     return Iterator(floats, initialVerticalPosition);</span>
114 }
115 
<span class="line-modified">116 static Iterator end(const FloatingState::FloatList&amp; floats)</span>
117 {
<span class="line-modified">118     return Iterator(floats, { });</span>
119 }
120 
121 #ifndef NDEBUG
122 static bool areFloatsHorizontallySorted(const FloatingState&amp; floatingState)
123 {
124     auto&amp; floats = floatingState.floats();
125     auto rightEdgeOfLeftFloats = LayoutUnit::min();
126     auto leftEdgeOfRightFloats = LayoutUnit::max();
127     WTF::Optional&lt;LayoutUnit&gt; leftBottom;
128     WTF::Optional&lt;LayoutUnit&gt; rightBottom;
129 
130     for (auto&amp; floatItem : floats) {
131         if (floatItem.isLeftPositioned()) {
132             auto rightEdge = floatItem.rectWithMargin().right();
133             if (rightEdge &lt; rightEdgeOfLeftFloats) {
134                 if (leftBottom &amp;&amp; floatItem.rectWithMargin().top() &lt; *leftBottom)
135                     return false;
136             }
137             leftBottom = floatItem.rectWithMargin().bottom();
138             rightEdgeOfLeftFloats = rightEdge;
</pre>
<hr />
<pre>
162 
163     if (m_floatingState.isEmpty()) {
164         auto&amp; displayBox = layoutState().displayBoxForLayoutBox(layoutBox);
165 
166         auto alignWithContainingBlock = [&amp;]() -&gt; Position {
167             // If there is no floating to align with, push the box to the left/right edge of its containing block&#39;s content box.
168             auto&amp; containingBlockDisplayBox = layoutState().displayBoxForLayoutBox(*layoutBox.containingBlock());
169 
170             if (layoutBox.isLeftFloatingPositioned())
171                 return Position { containingBlockDisplayBox.contentBoxLeft() + displayBox.marginStart() };
172 
173             return Position { containingBlockDisplayBox.contentBoxRight() - displayBox.marginEnd() - displayBox.width() };
174         };
175 
176         // No float box on the context yet -&gt; align it with the containing block&#39;s left/right edge.
177         return { alignWithContainingBlock(), displayBox.top() };
178     }
179 
180     // Find the top most position where the float box fits.
181     FloatBox floatBox = { layoutBox, m_floatingState, layoutState() };
<span class="line-modified">182     findPositionForFloatBox(floatBox);</span>
183     return floatBox.rectInContainingBlock().topLeft();
184 }
185 
<span class="line-modified">186 Optional&lt;Point&gt; FloatingContext::positionForFormattingContextRoot(const Box&amp; layoutBox) const</span>
187 {
188     ASSERT(layoutBox.establishesBlockFormattingContext());
189     ASSERT(!layoutBox.isFloatingPositioned());
190     ASSERT(!layoutBox.hasFloatClear());
191     ASSERT(areFloatsHorizontallySorted(m_floatingState));
192 
193     if (m_floatingState.isEmpty())
194         return { };
195 
196     FloatAvoider floatAvoider = { layoutBox, m_floatingState, layoutState() };
<span class="line-modified">197     findPositionForFormattingContextRoot(floatAvoider);</span>
198     return { floatAvoider.rectInContainingBlock().topLeft() };
199 }
200 
201 FloatingContext::ClearancePosition FloatingContext::verticalPositionWithClearance(const Box&amp; layoutBox) const
202 {
203     ASSERT(layoutBox.hasFloatClear());
204     ASSERT(layoutBox.isBlockLevelBox());
205     ASSERT(areFloatsHorizontallySorted(m_floatingState));
206 
207     if (m_floatingState.isEmpty())
208         return { };
209 
210     auto bottom = [&amp;](Optional&lt;PositionInContextRoot&gt; floatBottom) -&gt; ClearancePosition {
211         // &#39;bottom&#39; is in the formatting root&#39;s coordinate system.
212         if (!floatBottom)
213             return { };
214 
215         // 9.5.2 Controlling flow next to floats: the &#39;clear&#39; property
216         // Then the amount of clearance is set to the greater of:
217         //
</pre>
<hr />
<pre>
249         auto containingBlockRootRelativeTop = FormattingContext::mapTopToAncestor(layoutState, *layoutBox.containingBlock(), downcast&lt;Container&gt;(m_floatingState.root()));
250         return { Position { rootRelativeTop - containingBlockRootRelativeTop }, clearance };
251     };
252 
253     auto clear = layoutBox.style().clear();
254     auto&amp; formattingContextRoot = layoutBox.formattingContextRoot();
255 
256     if (clear == Clear::Left)
257         return bottom(m_floatingState.leftBottom(formattingContextRoot));
258 
259     if (clear == Clear::Right)
260         return bottom(m_floatingState.rightBottom(formattingContextRoot));
261 
262     if (clear == Clear::Both)
263         return bottom(m_floatingState.bottom(formattingContextRoot));
264 
265     ASSERT_NOT_REACHED();
266     return { };
267 }
268 
<span class="line-modified">269 static FloatPair::LeftRightIndex findAvailablePosition(FloatAvoider&amp; floatAvoider, const FloatingState::FloatList&amp; floats)</span>
270 {



271     Optional&lt;PositionInContextRoot&gt; bottomMost;
<span class="line-modified">272     Optional&lt;FloatPair::LeftRightIndex&gt; innerMostLeftAndRight;</span>
<span class="line-modified">273     auto end = Layout::end(floats);</span>
<span class="line-added">274     for (auto iterator = begin(floats, { floatAvoider.rect().top() }); iterator != end; ++iterator) {</span>
275         ASSERT(!(*iterator).isEmpty());
<span class="line-modified">276         auto leftRightFloatPair = *iterator;</span>
<span class="line-added">277         innerMostLeftAndRight = innerMostLeftAndRight.valueOr(*leftRightFloatPair);</span>
278 
279         // Move the box horizontally so that it either
280         // 1. aligns with the current floating pair
281         // 2. or with the containing block&#39;s content box if there&#39;s no float to align with at this vertical position.
<span class="line-modified">282         floatAvoider.setHorizontalConstraints(leftRightFloatPair.horizontalConstraints());</span>
<span class="line-modified">283         floatAvoider.setVerticalConstraint(leftRightFloatPair.verticalConstraint());</span>
284 
285         // Ensure that the float avoider
<span class="line-modified">286         // 1. does not &quot;overflow&quot; its containing block with the current horiztonal constraints. It simply means that the float avoider&#39;s</span>
<span class="line-added">287         // containing block could push the candidate position beyond the current float horizontally (too far to the left/right)</span>
288         // 2. avoids floats on both sides.
<span class="line-modified">289         if (!floatAvoider.overflowsContainingBlock() &amp;&amp; !leftRightFloatPair.intersects(floatAvoider.rect()))</span>
<span class="line-modified">290             return *innerMostLeftAndRight;</span>
291 
<span class="line-modified">292         bottomMost = leftRightFloatPair.bottom();</span>
293         // Move to the next floating pair.
294     }
295 
296     // The candidate box is already below of all the floats.
297     if (!bottomMost)
<span class="line-modified">298         return { };</span>
299 
300     // Passed all the floats and still does not fit? Push it below the last float.
301     floatAvoider.setVerticalConstraint(*bottomMost);
302     floatAvoider.setHorizontalConstraints({ });
<span class="line-added">303     ASSERT(innerMostLeftAndRight);</span>
<span class="line-added">304     return *innerMostLeftAndRight;</span>
<span class="line-added">305 }</span>
<span class="line-added">306 </span>
<span class="line-added">307 void FloatingContext::findPositionForFloatBox(FloatBox&amp; floatBox) const</span>
<span class="line-added">308 {</span>
<span class="line-added">309     findAvailablePosition(floatBox, m_floatingState.floats());</span>
<span class="line-added">310 }</span>
<span class="line-added">311 </span>
<span class="line-added">312 void FloatingContext::findPositionForFormattingContextRoot(FloatAvoider&amp; floatAvoider) const</span>
<span class="line-added">313 {</span>
<span class="line-added">314     // A non-floating formatting root&#39;s initial vertical position is its static position.</span>
<span class="line-added">315     // It means that such boxes can end up vertically placed in-between existing floats (which is</span>
<span class="line-added">316     // never the case for floats, since they cannot be placed above existing floats).</span>
<span class="line-added">317     //  ____  ____</span>
<span class="line-added">318     // |    || F1 |</span>
<span class="line-added">319     // | L1 | ----</span>
<span class="line-added">320     // |    |  ________</span>
<span class="line-added">321     //  ----  |   R1   |</span>
<span class="line-added">322     //         --------</span>
<span class="line-added">323     // Document order: 1. float: left (L1) 2. float: right (R1) 3. formatting root (F1)</span>
<span class="line-added">324     //</span>
<span class="line-added">325     // 1. Probe for available placement at initial position (note it runs a backward probing algorithm at a specific vertical position)</span>
<span class="line-added">326     // 2. Check if there&#39;s any intersecing float below (forward seaching)</span>
<span class="line-added">327     // 3. Align the box with the intersected float and probe for placement again (#1).</span>
<span class="line-added">328     auto&amp; floats = m_floatingState.floats();</span>
<span class="line-added">329     while (true) {</span>
<span class="line-added">330         auto innerMostLeftAndRight = findAvailablePosition(floatAvoider, floats);</span>
<span class="line-added">331         if (innerMostLeftAndRight.isEmpty())</span>
<span class="line-added">332             return;</span>
<span class="line-added">333 </span>
<span class="line-added">334         auto overlappingFloatBox = [&amp;floats](auto startFloatIndex, auto floatAvoiderRect) -&gt; const FloatingState::FloatItem* {</span>
<span class="line-added">335             for (auto i = startFloatIndex; i &lt; floats.size(); ++i) {</span>
<span class="line-added">336                 auto&amp; floatBox = floats[i];</span>
<span class="line-added">337                 if (floatBox.rectWithMargin().intersects(floatAvoiderRect))</span>
<span class="line-added">338                     return &amp;floatBox;</span>
<span class="line-added">339             }</span>
<span class="line-added">340             return nullptr;</span>
<span class="line-added">341         };</span>
<span class="line-added">342 </span>
<span class="line-added">343         auto startIndex = std::max(innerMostLeftAndRight.left.valueOr(0), innerMostLeftAndRight.right.valueOr(0)) + 1;</span>
<span class="line-added">344         auto* intersectedFloatBox = overlappingFloatBox(startIndex, floatAvoider.rect());</span>
<span class="line-added">345         if (!intersectedFloatBox)</span>
<span class="line-added">346             return;</span>
<span class="line-added">347         floatAvoider.setVerticalConstraint({ intersectedFloatBox-&gt;rectWithMargin().top() });</span>
<span class="line-added">348     }</span>
349 }
350 
<span class="line-modified">351 FloatPair::FloatPair(const FloatingState::FloatList&amp; floats)</span>
352     : m_floats(floats)
353 {
354 }
355 
<span class="line-modified">356 const FloatingState::FloatItem* FloatPair::left() const</span>
357 {
<span class="line-modified">358     if (!m_floatPair.left)</span>
359         return nullptr;
360 
<span class="line-modified">361     ASSERT(m_floats[*m_floatPair.left].isLeftPositioned());</span>
<span class="line-modified">362     return &amp;m_floats[*m_floatPair.left];</span>
363 }
364 
<span class="line-modified">365 const FloatingState::FloatItem* FloatPair::right() const</span>
366 {
<span class="line-modified">367     if (!m_floatPair.right)</span>
368         return nullptr;
369 
<span class="line-modified">370     ASSERT(!m_floats[*m_floatPair.right].isLeftPositioned());</span>
<span class="line-modified">371     return &amp;m_floats[*m_floatPair.right];</span>
372 }
373 
<span class="line-modified">374 bool FloatPair::intersects(const Display::Rect&amp; floatAvoiderRect) const</span>
375 {
<span class="line-modified">376     auto intersects = [&amp;](auto* floating) {</span>
<span class="line-modified">377         return floating &amp;&amp; floating-&gt;rectWithMargin().intersects(floatAvoiderRect);</span>









378     };
379 
<span class="line-modified">380     ASSERT(!m_floatPair.isEmpty());</span>
<span class="line-modified">381     return intersects(left()) || intersects(right());</span>










382 }
383 
<span class="line-modified">384 bool FloatPair::operator ==(const FloatPair&amp; other) const</span>
385 {
<span class="line-modified">386     return m_floatPair.left == other.m_floatPair.left &amp;&amp; m_floatPair.right == other.m_floatPair.right;</span>
387 }
388 
<span class="line-modified">389 FloatAvoider::HorizontalConstraints FloatPair::horizontalConstraints() const</span>
390 {
391     Optional&lt;PositionInContextRoot&gt; leftEdge;
392     Optional&lt;PositionInContextRoot&gt; rightEdge;
393 
394     if (left())
395         leftEdge = PositionInContextRoot { left()-&gt;rectWithMargin().right() };
396 
397     if (right())
398         rightEdge = PositionInContextRoot { right()-&gt;rectWithMargin().left() };
399 
400     return { leftEdge, rightEdge };
401 }
402 
<span class="line-modified">403 PositionInContextRoot FloatPair::bottom() const</span>
404 {
405     auto* left = this-&gt;left();
406     auto* right = this-&gt;right();
407     ASSERT(left || right);
408 
409     auto leftBottom = left ? Optional&lt;PositionInContextRoot&gt;(PositionInContextRoot { left-&gt;rectWithMargin().bottom() }) : WTF::nullopt;
410     auto rightBottom = right ? Optional&lt;PositionInContextRoot&gt;(PositionInContextRoot { right-&gt;rectWithMargin().bottom() }) : WTF::nullopt;
411 
412     if (leftBottom &amp;&amp; rightBottom)
413         return std::max(*leftBottom, *rightBottom);
414 
415     if (leftBottom)
416         return *leftBottom;
417 
418     return *rightBottom;
419 }
420 
421 Iterator::Iterator(const FloatingState::FloatList&amp; floats, Optional&lt;PositionInContextRoot&gt; verticalPosition)
422     : m_floats(floats)
423     , m_current(floats)
</pre>
<hr />
<pre>
466                 return index;
467         }
468 
469         ASSERT_NOT_REACHED();
470         return { };
471     };
472 
473     // 1. Take the current floating from left and right and check which one&#39;s bottom edge is positioned higher (they could be on the same vertical position too).
474     // The current floats from left and right are considered the inner-most pair for the current vertical position.
475     // 2. Move away from inner-most pair by picking one of the previous floats in the list(#1)
476     // Ensure that the new floating&#39;s bottom edge is positioned lower than the current one -which essentially means skipping in-between floats that are positioned higher).
477     // 3. Reset the vertical position and align it with the new left-right pair. These floats are now the inner-most boxes for the current vertical position.
478     // As the result we have more horizontal space on the current vertical position.
479     auto leftBottom = m_current.left() ? Optional&lt;PositionInContextRoot&gt;(m_current.left()-&gt;bottom()) : WTF::nullopt;
480     auto rightBottom = m_current.right() ? Optional&lt;PositionInContextRoot&gt;(m_current.right()-&gt;bottom()) : WTF::nullopt;
481 
482     auto updateLeft = (leftBottom == rightBottom) || (!rightBottom || (leftBottom &amp;&amp; leftBottom &lt; rightBottom));
483     auto updateRight = (leftBottom == rightBottom) || (!leftBottom || (rightBottom &amp;&amp; leftBottom &gt; rightBottom));
484 
485     if (updateLeft) {
<span class="line-modified">486         ASSERT(m_current.m_floatPair.left);</span>
487         m_current.m_verticalPosition = *leftBottom;
<span class="line-modified">488         m_current.m_floatPair.left = findPreviousFloatingWithLowerBottom(Float::Left, *m_current.m_floatPair.left);</span>
489     }
490 
491     if (updateRight) {
<span class="line-modified">492         ASSERT(m_current.m_floatPair.right);</span>
493         m_current.m_verticalPosition = *rightBottom;
<span class="line-modified">494         m_current.m_floatPair.right = findPreviousFloatingWithLowerBottom(Float::Right, *m_current.m_floatPair.right);</span>
495     }
496 
497     return *this;
498 }
499 
500 void Iterator::set(PositionInContextRoot verticalPosition)
501 {
502     // Move the iterator to the initial vertical position by starting at the inner-most floating pair (last floats on left/right).
503     // 1. Check if the inner-most pair covers the vertical position.
504     // 2. Move outwards from the inner-most pair until the vertical postion intersects.


505     m_current.m_verticalPosition = verticalPosition;
506     // No floats at all?
507     if (m_floats.isEmpty()) {
508         ASSERT_NOT_REACHED();
<span class="line-modified">509         m_current.m_floatPair = { };</span>


510         return;
511     }
512 
513     auto findFloatingBelow = [&amp;](Float floatingType) -&gt; Optional&lt;unsigned&gt; {
514 
515         ASSERT(!m_floats.isEmpty());
516 
<span class="line-modified">517         auto index = floatingType == Float::Left ? m_current.m_floatPair.left : m_current.m_floatPair.right;</span>
518         // Start from the end if we don&#39;t have current yet.
519         index = index.valueOr(m_floats.size());
520         while (true) {
521             index = previousFloatingIndex(floatingType, m_floats, *index);
522             if (!index)
523                 return { };
524 

525             // Is this floating intrusive on this position?
<span class="line-modified">526             auto rect = m_floats[*index].rectWithMargin();</span>
<span class="line-added">527             if (rect.top() &lt;= verticalPosition &amp;&amp; rect.bottom() &gt; verticalPosition)</span>
528                 return index;
529         }
530 
531         return { };
532     };
533 
<span class="line-modified">534     m_current.m_floatPair.left = findFloatingBelow(Float::Left);</span>
<span class="line-modified">535     m_current.m_floatPair.right = findFloatingBelow(Float::Right);</span>
536 
<span class="line-modified">537     ASSERT(!m_current.m_floatPair.left || (*m_current.m_floatPair.left &lt; m_floats.size() &amp;&amp; m_floats[*m_current.m_floatPair.left].isLeftPositioned()));</span>
<span class="line-modified">538     ASSERT(!m_current.m_floatPair.right || (*m_current.m_floatPair.right &lt; m_floats.size() &amp;&amp; !m_floats[*m_current.m_floatPair.right].isLeftPositioned()));</span>
539 }
540 
541 bool Iterator::operator==(const Iterator&amp; other) const
542 {
543     return m_current == other.m_current;
544 }
545 
546 bool Iterator::operator!=(const Iterator&amp; other) const
547 {
548     return !(*this == other);
549 }
550 
551 }
552 }
553 #endif
</pre>
</td>
</tr>
</table>
<center><a href="FloatBox.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="FloatingContext.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>