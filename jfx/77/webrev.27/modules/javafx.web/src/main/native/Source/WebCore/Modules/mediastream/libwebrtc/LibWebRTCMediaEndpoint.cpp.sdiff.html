<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/Modules/mediastream/libwebrtc/LibWebRTCMediaEndpoint.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="LibWebRTCDataChannelHandler.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="LibWebRTCMediaEndpoint.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/Modules/mediastream/libwebrtc/LibWebRTCMediaEndpoint.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 30 #include &quot;EventNames.h&quot;
 31 #include &quot;JSRTCStatsReport.h&quot;
 32 #include &quot;LibWebRTCDataChannelHandler.h&quot;
 33 #include &quot;LibWebRTCPeerConnectionBackend.h&quot;
 34 #include &quot;LibWebRTCProvider.h&quot;
 35 #include &quot;LibWebRTCRtpReceiverBackend.h&quot;
 36 #include &quot;LibWebRTCRtpSenderBackend.h&quot;
 37 #include &quot;LibWebRTCRtpTransceiverBackend.h&quot;
 38 #include &quot;LibWebRTCStatsCollector.h&quot;
 39 #include &quot;LibWebRTCUtils.h&quot;
 40 #include &quot;Logging.h&quot;
 41 #include &quot;NotImplemented.h&quot;
 42 #include &quot;Performance.h&quot;
 43 #include &quot;PlatformStrategies.h&quot;
 44 #include &quot;RTCDataChannel.h&quot;
 45 #include &quot;RTCDataChannelEvent.h&quot;
 46 #include &quot;RTCOfferOptions.h&quot;
 47 #include &quot;RTCPeerConnection.h&quot;
 48 #include &quot;RTCSessionDescription.h&quot;
 49 #include &quot;RTCStatsReport.h&quot;
<span class="line-removed"> 50 #include &quot;RTCTrackEvent.h&quot;</span>
 51 #include &quot;RealtimeIncomingAudioSource.h&quot;
 52 #include &quot;RealtimeIncomingVideoSource.h&quot;
 53 #include &quot;RealtimeOutgoingAudioSource.h&quot;
 54 #include &quot;RealtimeOutgoingVideoSource.h&quot;
 55 #include &quot;RuntimeEnabledFeatures.h&quot;
 56 #include &lt;webrtc/rtc_base/physicalsocketserver.h&gt;
 57 #include &lt;webrtc/p2p/base/basicpacketsocketfactory.h&gt;
 58 #include &lt;webrtc/p2p/client/basicportallocator.h&gt;
 59 #include &lt;webrtc/pc/peerconnectionfactory.h&gt;
 60 #include &lt;webrtc/system_wrappers/include/field_trial.h&gt;
 61 #include &lt;wtf/MainThread.h&gt;
 62 
 63 namespace WebCore {
 64 
 65 LibWebRTCMediaEndpoint::LibWebRTCMediaEndpoint(LibWebRTCPeerConnectionBackend&amp; peerConnection, LibWebRTCProvider&amp; client)
 66     : m_peerConnectionBackend(peerConnection)
 67     , m_peerConnectionFactory(*client.factory())
 68     , m_createSessionDescriptionObserver(*this)
 69     , m_setLocalSessionDescriptionObserver(*this)
 70     , m_setRemoteSessionDescriptionObserver(*this)
 71     , m_statsLogTimer(*this, &amp;LibWebRTCMediaEndpoint::gatherStatsForLogging)
 72 #if !RELEASE_LOG_DISABLED
 73     , m_logger(peerConnection.logger())
 74     , m_logIdentifier(peerConnection.logIdentifier())
 75 #endif
 76 {
 77     ASSERT(isMainThread());
 78     ASSERT(client.factory());
 79 
 80     if (RuntimeEnabledFeatures::sharedFeatures().webRTCH264SimulcastEnabled())
 81         webrtc::field_trial::InitFieldTrialsFromString(&quot;WebRTC-H264Simulcast/Enabled/&quot;);
 82 }
 83 
 84 bool LibWebRTCMediaEndpoint::setConfiguration(LibWebRTCProvider&amp; client, webrtc::PeerConnectionInterface::RTCConfiguration&amp;&amp; configuration)
 85 {
 86     if (RuntimeEnabledFeatures::sharedFeatures().webRTCUnifiedPlanEnabled())
 87         configuration.sdp_semantics = webrtc::SdpSemantics::kUnifiedPlan;
 88 
 89     if (!m_backend) {
<span class="line-modified"> 90         m_backend = client.createPeerConnection(*this, WTFMove(configuration));</span>




 91         return !!m_backend;
 92     }
 93     auto oldConfiguration = m_backend-&gt;GetConfiguration();
 94     configuration.certificates = oldConfiguration.certificates;
 95     return m_backend-&gt;SetConfiguration(WTFMove(configuration));
 96 }
 97 
 98 static inline const char* sessionDescriptionType(RTCSdpType sdpType)
 99 {
100     switch (sdpType) {
101     case RTCSdpType::Offer:
102         return &quot;offer&quot;;
103     case RTCSdpType::Pranswer:
104         return &quot;pranswer&quot;;
105     case RTCSdpType::Answer:
106         return &quot;answer&quot;;
107     case RTCSdpType::Rollback:
108         return &quot;rollback&quot;;
109     }
110 
</pre>
<hr />
<pre>
202 }
203 
204 bool LibWebRTCMediaEndpoint::addTrack(LibWebRTCRtpSenderBackend&amp; sender, MediaStreamTrack&amp; track, const Vector&lt;String&gt;&amp; mediaStreamIds)
205 {
206     ASSERT(m_backend);
207 
208     if (!RuntimeEnabledFeatures::sharedFeatures().webRTCUnifiedPlanEnabled()) {
209         String mediaStreamId = mediaStreamIds.isEmpty() ? createCanonicalUUIDString() : mediaStreamIds[0];
210         m_localStreams.ensure(mediaStreamId, [&amp;] {
211             auto mediaStream = m_peerConnectionFactory.CreateLocalMediaStream(mediaStreamId.utf8().data());
212             m_backend-&gt;AddStream(mediaStream);
213             return mediaStream;
214         });
215     }
216 
217     LibWebRTCRtpSenderBackend::Source source;
218     rtc::scoped_refptr&lt;webrtc::MediaStreamTrackInterface&gt; rtcTrack;
219     switch (track.privateTrack().type()) {
220     case RealtimeMediaSource::Type::Audio: {
221         auto audioSource = RealtimeOutgoingAudioSource::create(track.privateTrack());
<span class="line-removed">222 #if !RELEASE_LOG_DISABLED</span>
<span class="line-removed">223         audioSource-&gt;setLogger(m_logger.copyRef());</span>
<span class="line-removed">224 #endif</span>
225         rtcTrack = m_peerConnectionFactory.CreateAudioTrack(track.id().utf8().data(), audioSource.ptr());
226         source = WTFMove(audioSource);
227         break;
228     }
229     case RealtimeMediaSource::Type::Video: {
230         auto videoSource = RealtimeOutgoingVideoSource::create(track.privateTrack());
<span class="line-removed">231 #if !RELEASE_LOG_DISABLED</span>
<span class="line-removed">232         videoSource-&gt;setLogger(m_logger.copyRef());</span>
<span class="line-removed">233 #endif</span>
234         rtcTrack = m_peerConnectionFactory.CreateVideoTrack(track.id().utf8().data(), videoSource.ptr());
235         source = WTFMove(videoSource);
236         break;
237     }
238     case RealtimeMediaSource::Type::None:
239         ASSERT_NOT_REACHED();
240         return false;
241     }
242 
243     sender.setSource(WTFMove(source));
244     if (auto rtpSender = sender.rtcSender()) {
245         rtpSender-&gt;SetTrack(rtcTrack.get());
246         return true;
247     }
248 
249     std::vector&lt;std::string&gt; ids;
250     for (auto&amp; id : mediaStreamIds)
251         ids.push_back(id.utf8().data());
252 
253     auto newRTPSender = m_backend-&gt;AddTrack(rtcTrack.get(), WTFMove(ids));
</pre>
<hr />
<pre>
273     rtcOptions.ice_restart = options.iceRestart;
274     rtcOptions.voice_activity_detection = options.voiceActivityDetection;
275 
276     if (!RuntimeEnabledFeatures::sharedFeatures().webRTCUnifiedPlanEnabled()) {
277         if (m_peerConnectionBackend.shouldOfferAllowToReceive(&quot;audio&quot;_s))
278             rtcOptions.offer_to_receive_audio = webrtc::PeerConnectionInterface::RTCOfferAnswerOptions::kOfferToReceiveMediaTrue;
279         if (m_peerConnectionBackend.shouldOfferAllowToReceive(&quot;video&quot;_s))
280             rtcOptions.offer_to_receive_video = webrtc::PeerConnectionInterface::RTCOfferAnswerOptions::kOfferToReceiveMediaTrue;
281     }
282     m_backend-&gt;CreateOffer(&amp;m_createSessionDescriptionObserver, rtcOptions);
283 }
284 
285 void LibWebRTCMediaEndpoint::doCreateAnswer()
286 {
287     ASSERT(m_backend);
288 
289     m_isInitiator = false;
290     m_backend-&gt;CreateAnswer(&amp;m_createSessionDescriptionObserver, { });
291 }
292 
<span class="line-modified">293 void LibWebRTCMediaEndpoint::getStats(Ref&lt;DeferredPromise&gt;&amp;&amp; promise, WTF::Function&lt;void(rtc::scoped_refptr&lt;LibWebRTCStatsCollector&gt;&amp;&amp;)&gt;&amp;&amp; getStatsFunction)</span>
294 {
<span class="line-modified">295     auto collector = LibWebRTCStatsCollector::create([promise = WTFMove(promise), protectedThis = makeRef(*this)]() mutable -&gt; RefPtr&lt;RTCStatsReport&gt; {</span>
296         ASSERT(isMainThread());
297         if (protectedThis-&gt;isStopped())
298             return nullptr;
299 
300         auto report = RTCStatsReport::create();
301 
302         promise-&gt;resolve&lt;IDLInterface&lt;RTCStatsReport&gt;&gt;(report.copyRef());
303 
304         // The promise resolution might fail in which case no backing map will be created.
305         if (!report-&gt;backingMap())
306             return nullptr;
<span class="line-modified">307         return WTFMove(report);</span>
<span class="line-removed">308     });</span>
<span class="line-removed">309     LibWebRTCProvider::callOnWebRTCSignalingThread([getStatsFunction = WTFMove(getStatsFunction), collector = WTFMove(collector)]() mutable {</span>
<span class="line-removed">310         getStatsFunction(WTFMove(collector));</span>
311     });
312 }
313 
314 void LibWebRTCMediaEndpoint::getStats(Ref&lt;DeferredPromise&gt;&amp;&amp; promise)
315 {
<span class="line-modified">316     getStats(WTFMove(promise), [this](auto&amp;&amp; collector) {</span>
<span class="line-modified">317         if (m_backend)</span>
<span class="line-removed">318             m_backend-&gt;GetStats(WTFMove(collector));</span>
<span class="line-removed">319     });</span>
320 }
321 
322 void LibWebRTCMediaEndpoint::getStats(webrtc::RtpReceiverInterface&amp; receiver, Ref&lt;DeferredPromise&gt;&amp;&amp; promise)
323 {
<span class="line-modified">324     getStats(WTFMove(promise), [this, receiver = rtc::scoped_refptr&lt;webrtc::RtpReceiverInterface&gt;(&amp;receiver)](auto&amp;&amp; collector) mutable {</span>
<span class="line-modified">325         if (m_backend)</span>
<span class="line-removed">326             m_backend-&gt;GetStats(WTFMove(receiver), WTFMove(collector));</span>
<span class="line-removed">327     });</span>
328 }
329 
330 void LibWebRTCMediaEndpoint::getStats(webrtc::RtpSenderInterface&amp; sender, Ref&lt;DeferredPromise&gt;&amp;&amp; promise)
331 {
<span class="line-modified">332     getStats(WTFMove(promise), [this, sender = rtc::scoped_refptr&lt;webrtc::RtpSenderInterface&gt;(&amp;sender)](auto&amp;&amp; collector)  mutable {</span>
<span class="line-modified">333         if (m_backend)</span>
<span class="line-removed">334             m_backend-&gt;GetStats(WTFMove(sender), WTFMove(collector));</span>
<span class="line-removed">335     });</span>
336 }
337 
338 static RTCSignalingState signalingState(webrtc::PeerConnectionInterface::SignalingState state)
339 {
340     switch (state) {
341     case webrtc::PeerConnectionInterface::kStable:
342         return RTCSignalingState::Stable;
343     case webrtc::PeerConnectionInterface::kHaveLocalOffer:
344         return RTCSignalingState::HaveLocalOffer;
345     case webrtc::PeerConnectionInterface::kHaveLocalPrAnswer:
346         return RTCSignalingState::HaveLocalPranswer;
347     case webrtc::PeerConnectionInterface::kHaveRemoteOffer:
348         return RTCSignalingState::HaveRemoteOffer;
349     case webrtc::PeerConnectionInterface::kHaveRemotePrAnswer:
350         return RTCSignalingState::HaveRemotePranswer;
351     case webrtc::PeerConnectionInterface::kClosed:
352         return RTCSignalingState::Stable;
353     }
354 
355     ASSERT_NOT_REACHED();
356     return RTCSignalingState::Stable;
357 }
358 
359 void LibWebRTCMediaEndpoint::OnSignalingChange(webrtc::PeerConnectionInterface::SignalingState rtcState)
360 {
361     auto state = signalingState(rtcState);
362     callOnMainThread([protectedThis = makeRef(*this), state] {
363         if (protectedThis-&gt;isStopped())
364             return;
365         protectedThis-&gt;m_peerConnectionBackend.updateSignalingState(state);
366     });
367 }
368 
369 MediaStream&amp; LibWebRTCMediaEndpoint::mediaStreamFromRTCStream(webrtc::MediaStreamInterface&amp; rtcStream)
370 {
371     auto label = fromStdString(rtcStream.id());
372     auto mediaStream = m_remoteStreamsById.ensure(label, [label, this]() mutable {
<span class="line-modified">373         return MediaStream::create(*m_peerConnectionBackend.connection().scriptExecutionContext(), MediaStreamPrivate::create({ }, WTFMove(label)));</span>

374     });
375     return *mediaStream.iterator-&gt;value;
376 }
377 
378 void LibWebRTCMediaEndpoint::addRemoteStream(webrtc::MediaStreamInterface&amp;)
379 {
380 }
381 
382 void LibWebRTCMediaEndpoint::addRemoteTrack(rtc::scoped_refptr&lt;webrtc::RtpReceiverInterface&gt;&amp;&amp; rtcReceiver, const std::vector&lt;rtc::scoped_refptr&lt;webrtc::MediaStreamInterface&gt;&gt;&amp; rtcStreams)
383 {
384     ASSERT(rtcReceiver);
385     RefPtr&lt;RTCRtpReceiver&gt; receiver;
386     RefPtr&lt;RealtimeMediaSource&gt; remoteSource;
387 
388     auto* rtcTrack = rtcReceiver-&gt;track().get();
389 
390     switch (rtcReceiver-&gt;media_type()) {
391     case cricket::MEDIA_TYPE_DATA:
392         return;
393     case cricket::MEDIA_TYPE_AUDIO: {
394         rtc::scoped_refptr&lt;webrtc::AudioTrackInterface&gt; audioTrack = static_cast&lt;webrtc::AudioTrackInterface*&gt;(rtcTrack);
395         auto audioReceiver = m_peerConnectionBackend.audioReceiver(fromStdString(rtcTrack-&gt;id()));
396 
397         receiver = WTFMove(audioReceiver.receiver);
398         audioReceiver.source-&gt;setSourceTrack(WTFMove(audioTrack));
399         break;
400     }
401     case cricket::MEDIA_TYPE_VIDEO: {
402         rtc::scoped_refptr&lt;webrtc::VideoTrackInterface&gt; videoTrack = static_cast&lt;webrtc::VideoTrackInterface*&gt;(rtcTrack);
403         auto videoReceiver = m_peerConnectionBackend.videoReceiver(fromStdString(rtcTrack-&gt;id()));
404 
405         receiver = WTFMove(videoReceiver.receiver);
406         videoReceiver.source-&gt;setSourceTrack(WTFMove(videoTrack));
407         break;
408     }
409     }
410 
<span class="line-modified">411     receiver-&gt;setBackend(std::make_unique&lt;LibWebRTCRtpReceiverBackend&gt;(WTFMove(rtcReceiver)));</span>
412     auto&amp; track = receiver-&gt;track();
<span class="line-modified">413     fireTrackEvent(receiver.releaseNonNull(), track, rtcStreams, nullptr);</span>
414 }
415 
<span class="line-modified">416 void LibWebRTCMediaEndpoint::fireTrackEvent(Ref&lt;RTCRtpReceiver&gt;&amp;&amp; receiver, MediaStreamTrack&amp; track, const std::vector&lt;rtc::scoped_refptr&lt;webrtc::MediaStreamInterface&gt;&gt;&amp; rtcStreams, RefPtr&lt;RTCRtpTransceiver&gt;&amp;&amp; transceiver)</span>
417 {
418     Vector&lt;RefPtr&lt;MediaStream&gt;&gt; streams;
419     for (auto&amp; rtcStream : rtcStreams) {
420         auto&amp; mediaStream = mediaStreamFromRTCStream(*rtcStream.get());
421         streams.append(&amp;mediaStream);
422         mediaStream.addTrackFromPlatform(track);
423     }
424     auto streamIds = WTF::map(streams, [](auto&amp; stream) -&gt; String {
425         return stream-&gt;id();
426     });
427     m_remoteStreamsFromRemoteTrack.add(&amp;track, WTFMove(streamIds));
428 
<span class="line-modified">429     m_peerConnectionBackend.connection().fireEvent(RTCTrackEvent::create(eventNames().trackEvent,</span>
<span class="line-removed">430         Event::CanBubble::No, Event::IsCancelable::No, WTFMove(receiver), &amp;track, WTFMove(streams), WTFMove(transceiver)));</span>
<span class="line-removed">431 </span>
<span class="line-removed">432     // FIXME: As per spec, we should set muted to &#39;false&#39; when starting to receive the content from network.</span>
<span class="line-removed">433     track.source().setMuted(false);</span>
434 }
435 
436 static inline void setExistingReceiverSourceTrack(RealtimeMediaSource&amp; existingSource, webrtc::RtpReceiverInterface&amp; rtcReceiver)
437 {
438     switch (rtcReceiver.media_type()) {
439     case cricket::MEDIA_TYPE_AUDIO: {
440         ASSERT(existingSource.type() == RealtimeMediaSource::Type::Audio);
441         rtc::scoped_refptr&lt;webrtc::AudioTrackInterface&gt; audioTrack = static_cast&lt;webrtc::AudioTrackInterface*&gt;(rtcReceiver.track().get());
442         downcast&lt;RealtimeIncomingAudioSource&gt;(existingSource).setSourceTrack(WTFMove(audioTrack));
443         return;
444     }
445     case cricket::MEDIA_TYPE_VIDEO: {
446         ASSERT(existingSource.type() == RealtimeMediaSource::Type::Video);
447         rtc::scoped_refptr&lt;webrtc::VideoTrackInterface&gt; videoTrack = static_cast&lt;webrtc::VideoTrackInterface*&gt;(rtcReceiver.track().get());
448         downcast&lt;RealtimeIncomingVideoSource&gt;(existingSource).setSourceTrack(WTFMove(videoTrack));
449         return;
450     }
451     case cricket::MEDIA_TYPE_DATA:
452         ASSERT_NOT_REACHED();
453         return;
454     }
455 }
456 
457 RefPtr&lt;RealtimeMediaSource&gt; LibWebRTCMediaEndpoint::sourceFromNewReceiver(webrtc::RtpReceiverInterface&amp; rtcReceiver)
458 {
459     auto rtcTrack = rtcReceiver.track();
460     switch (rtcReceiver.media_type()) {
461     case cricket::MEDIA_TYPE_DATA:
462         return nullptr;
463     case cricket::MEDIA_TYPE_AUDIO: {
464         rtc::scoped_refptr&lt;webrtc::AudioTrackInterface&gt; audioTrack = static_cast&lt;webrtc::AudioTrackInterface*&gt;(rtcTrack.get());
<span class="line-modified">465         auto audioSource = RealtimeIncomingAudioSource::create(WTFMove(audioTrack), fromStdString(rtcTrack-&gt;id()));</span>
<span class="line-removed">466 #if !RELEASE_LOG_DISABLED</span>
<span class="line-removed">467         audioSource-&gt;setLogger(m_logger.copyRef());</span>
<span class="line-removed">468 #endif</span>
<span class="line-removed">469         return audioSource;</span>
470     }
471     case cricket::MEDIA_TYPE_VIDEO: {
472         rtc::scoped_refptr&lt;webrtc::VideoTrackInterface&gt; videoTrack = static_cast&lt;webrtc::VideoTrackInterface*&gt;(rtcTrack.get());
<span class="line-modified">473         auto videoSource =  RealtimeIncomingVideoSource::create(WTFMove(videoTrack), fromStdString(rtcTrack-&gt;id()));</span>
<span class="line-removed">474 #if !RELEASE_LOG_DISABLED</span>
<span class="line-removed">475         videoSource-&gt;setLogger(m_logger.copyRef());</span>
<span class="line-removed">476 #endif</span>
<span class="line-removed">477         return videoSource;</span>
478     }
479     }
480 
481     RELEASE_ASSERT_NOT_REACHED();
482 }
483 
484 void LibWebRTCMediaEndpoint::collectTransceivers()
485 {
486     if (!m_backend)
487         return;
488 
489     if (!RuntimeEnabledFeatures::sharedFeatures().webRTCUnifiedPlanEnabled())
490         return;
491 
492     for (auto&amp; rtcTransceiver : m_backend-&gt;GetTransceivers()) {
493         auto* existingTransceiver = m_peerConnectionBackend.existingTransceiver([&amp;](auto&amp; transceiverBackend) {
494             return rtcTransceiver.get() == transceiverBackend.rtcTransceiver();
495         });
496         if (existingTransceiver)
497             continue;
498 
499         auto rtcReceiver = rtcTransceiver-&gt;receiver();
500         auto source = sourceFromNewReceiver(*rtcReceiver);
501         if (!source)
502             return;
503 
<span class="line-modified">504         m_peerConnectionBackend.newRemoteTransceiver(std::make_unique&lt;LibWebRTCRtpTransceiverBackend&gt;(WTFMove(rtcTransceiver)), source.releaseNonNull());</span>
505     }
506 }
507 
508 void LibWebRTCMediaEndpoint::newTransceiver(rtc::scoped_refptr&lt;webrtc::RtpTransceiverInterface&gt;&amp;&amp; rtcTransceiver)
509 {
510     auto* transceiver = m_peerConnectionBackend.existingTransceiver([&amp;](auto&amp; transceiverBackend) {
511         return rtcTransceiver.get() == transceiverBackend.rtcTransceiver();
512     });
513     if (transceiver) {
514         auto rtcReceiver = rtcTransceiver-&gt;receiver();
515         setExistingReceiverSourceTrack(transceiver-&gt;receiver().track().source(), *rtcReceiver);
<span class="line-modified">516         fireTrackEvent(makeRef(transceiver-&gt;receiver()), transceiver-&gt;receiver().track(), rtcReceiver-&gt;streams(), makeRef(*transceiver));</span>
517         return;
518     }
519 
520     auto rtcReceiver = rtcTransceiver-&gt;receiver();
521     auto source = sourceFromNewReceiver(*rtcReceiver);
522     if (!source)
523         return;
524 
<span class="line-modified">525     auto&amp; newTransceiver = m_peerConnectionBackend.newRemoteTransceiver(std::make_unique&lt;LibWebRTCRtpTransceiverBackend&gt;(WTFMove(rtcTransceiver)), source.releaseNonNull());</span>
526 
<span class="line-modified">527     fireTrackEvent(makeRef(newTransceiver.receiver()), newTransceiver.receiver().track(), rtcReceiver-&gt;streams(), makeRef(newTransceiver));</span>
528 }
529 
530 void LibWebRTCMediaEndpoint::removeRemoteTrack(rtc::scoped_refptr&lt;webrtc::RtpReceiverInterface&gt;&amp;&amp; receiver)
531 {
532     // FIXME: Support plan B code path.
533     if (!RuntimeEnabledFeatures::sharedFeatures().webRTCUnifiedPlanEnabled())
534         return;
535 
536     auto* transceiver = m_peerConnectionBackend.existingTransceiver([&amp;receiver](auto&amp; transceiverBackend) {
537         auto* rtcTransceiver = transceiverBackend.rtcTransceiver();
538         return rtcTransceiver &amp;&amp; receiver.get() == rtcTransceiver-&gt;receiver().get();
539     });
540     if (!transceiver)
541         return;
542 
543     auto&amp; track = transceiver-&gt;receiver().track();
544 
545     for (auto&amp; id : m_remoteStreamsFromRemoteTrack.get(&amp;track)) {
546         if (auto stream = m_remoteStreamsById.get(id))
547             stream-&gt;privateStream().removeTrack(track.privateTrack(), MediaStreamPrivate::NotifyClientOption::Notify);
548     }
549 
550     track.source().setMuted(true);
551 }
552 
553 template&lt;typename T&gt;
554 Optional&lt;LibWebRTCMediaEndpoint::Backends&gt; LibWebRTCMediaEndpoint::createTransceiverBackends(T&amp;&amp; trackOrKind, const RTCRtpTransceiverInit&amp; init, LibWebRTCRtpSenderBackend::Source&amp;&amp; source)
555 {
556     auto result = m_backend-&gt;AddTransceiver(WTFMove(trackOrKind), fromRtpTransceiverInit(init));
557     if (!result.ok())
558         return WTF::nullopt;
559 
<span class="line-modified">560     auto transceiver = std::make_unique&lt;LibWebRTCRtpTransceiverBackend&gt;(result.MoveValue());</span>
561     return LibWebRTCMediaEndpoint::Backends { transceiver-&gt;createSenderBackend(m_peerConnectionBackend, WTFMove(source)), transceiver-&gt;createReceiverBackend(), WTFMove(transceiver) };
562 }
563 
564 Optional&lt;LibWebRTCMediaEndpoint::Backends&gt; LibWebRTCMediaEndpoint::addTransceiver(const String&amp; trackKind, const RTCRtpTransceiverInit&amp; init)
565 {
566     auto type = trackKind == &quot;audio&quot; ? cricket::MediaType::MEDIA_TYPE_AUDIO : cricket::MediaType::MEDIA_TYPE_VIDEO;
567     return createTransceiverBackends(type, init, nullptr);
568 }
569 
570 std::pair&lt;LibWebRTCRtpSenderBackend::Source, rtc::scoped_refptr&lt;webrtc::MediaStreamTrackInterface&gt;&gt; LibWebRTCMediaEndpoint::createSourceAndRTCTrack(MediaStreamTrack&amp; track)
571 {
572     LibWebRTCRtpSenderBackend::Source source;
573     rtc::scoped_refptr&lt;webrtc::MediaStreamTrackInterface&gt; rtcTrack;
574     switch (track.privateTrack().type()) {
575     case RealtimeMediaSource::Type::None:
576         ASSERT_NOT_REACHED();
577         break;
578     case RealtimeMediaSource::Type::Audio: {
579         auto audioSource = RealtimeOutgoingAudioSource::create(track.privateTrack());
580         rtcTrack = m_peerConnectionFactory.CreateAudioTrack(track.id().utf8().data(), audioSource.ptr());
</pre>
<hr />
<pre>
591     return std::make_pair(WTFMove(source), WTFMove(rtcTrack));
592 }
593 
594 Optional&lt;LibWebRTCMediaEndpoint::Backends&gt; LibWebRTCMediaEndpoint::addTransceiver(MediaStreamTrack&amp; track, const RTCRtpTransceiverInit&amp; init)
595 {
596     auto sourceAndTrack = createSourceAndRTCTrack(track);
597     return createTransceiverBackends(WTFMove(sourceAndTrack.second), init, WTFMove(sourceAndTrack.first));
598 }
599 
600 void LibWebRTCMediaEndpoint::setSenderSourceFromTrack(LibWebRTCRtpSenderBackend&amp; sender, MediaStreamTrack&amp; track)
601 {
602     auto sourceAndTrack = createSourceAndRTCTrack(track);
603     sender.setSource(WTFMove(sourceAndTrack.first));
604     sender.rtcSender()-&gt;SetTrack(WTFMove(sourceAndTrack.second));
605 }
606 
607 std::unique_ptr&lt;LibWebRTCRtpTransceiverBackend&gt; LibWebRTCMediaEndpoint::transceiverBackendFromSender(LibWebRTCRtpSenderBackend&amp; backend)
608 {
609     for (auto&amp; transceiver : m_backend-&gt;GetTransceivers()) {
610         if (transceiver-&gt;sender().get() == backend.rtcSender())
<span class="line-modified">611             return std::make_unique&lt;LibWebRTCRtpTransceiverBackend&gt;(rtc::scoped_refptr&lt;webrtc::RtpTransceiverInterface&gt;(transceiver));</span>
612     }
613     return nullptr;
614 }
615 
616 
617 void LibWebRTCMediaEndpoint::removeRemoteStream(webrtc::MediaStreamInterface&amp; rtcStream)
618 {
619     bool removed = m_remoteStreamsById.remove(fromStdString(rtcStream.id()));
620     ASSERT_UNUSED(removed, removed);
621 }
622 
623 void LibWebRTCMediaEndpoint::OnAddStream(rtc::scoped_refptr&lt;webrtc::MediaStreamInterface&gt; stream)
624 {
625     callOnMainThread([protectedThis = makeRef(*this), stream = WTFMove(stream)] {
626         if (protectedThis-&gt;isStopped())
627             return;
628         ASSERT(stream);
629         protectedThis-&gt;addRemoteStream(*stream.get());
630     });
631 }
</pre>
<hr />
<pre>
660     callOnMainThread([protectedThis = makeRef(*this), transceiver = WTFMove(transceiver)]() mutable {
661         if (protectedThis-&gt;isStopped())
662             return;
663         protectedThis-&gt;newTransceiver(WTFMove(transceiver));
664     });
665 }
666 
667 void LibWebRTCMediaEndpoint::OnRemoveTrack(rtc::scoped_refptr&lt;webrtc::RtpReceiverInterface&gt; receiver)
668 {
669     callOnMainThread([protectedThis = makeRef(*this), receiver = WTFMove(receiver)]() mutable {
670         if (protectedThis-&gt;isStopped())
671             return;
672         protectedThis-&gt;removeRemoteTrack(WTFMove(receiver));
673     });
674 }
675 
676 std::unique_ptr&lt;RTCDataChannelHandler&gt; LibWebRTCMediaEndpoint::createDataChannel(const String&amp; label, const RTCDataChannelInit&amp; options)
677 {
678     auto init = LibWebRTCDataChannelHandler::fromRTCDataChannelInit(options);
679     auto channel = m_backend-&gt;CreateDataChannel(label.utf8().data(), &amp;init);
<span class="line-modified">680     return channel ? std::make_unique&lt;LibWebRTCDataChannelHandler&gt;(WTFMove(channel)) : nullptr;</span>
681 }
682 
683 void LibWebRTCMediaEndpoint::OnDataChannel(rtc::scoped_refptr&lt;webrtc::DataChannelInterface&gt; dataChannel)
684 {
685     callOnMainThread([protectedThis = makeRef(*this), dataChannel = WTFMove(dataChannel)]() mutable {
686         if (protectedThis-&gt;isStopped())
687             return;
688         auto&amp; connection = protectedThis-&gt;m_peerConnectionBackend.connection();
689         connection.fireEvent(LibWebRTCDataChannelHandler::channelEvent(*connection.scriptExecutionContext(), WTFMove(dataChannel)));
690     });
691 }
692 
693 void LibWebRTCMediaEndpoint::stop()
694 {
695     if (!m_backend)
696         return;
697 
698     stopLoggingStats();
699 
700     m_backend-&gt;Close();
</pre>
<hr />
<pre>
829 void LibWebRTCMediaEndpoint::setRemoteSessionDescriptionSucceeded()
830 {
831     callOnMainThread([protectedThis = makeRef(*this)] {
832         if (protectedThis-&gt;isStopped())
833             return;
834         protectedThis-&gt;m_peerConnectionBackend.setRemoteDescriptionSucceeded();
835     });
836 }
837 
838 void LibWebRTCMediaEndpoint::setRemoteSessionDescriptionFailed(ExceptionCode errorCode, const char* errorMessage)
839 {
840     callOnMainThread([protectedThis = makeRef(*this), errorCode, errorMessage = String(errorMessage)] () mutable {
841         if (protectedThis-&gt;isStopped())
842             return;
843         protectedThis-&gt;m_peerConnectionBackend.setRemoteDescriptionFailed(Exception { errorCode, WTFMove(errorMessage) });
844     });
845 }
846 
847 void LibWebRTCMediaEndpoint::gatherStatsForLogging()
848 {
<span class="line-modified">849     LibWebRTCProvider::callOnWebRTCSignalingThread([protectedThis = makeRef(*this)] {</span>
<span class="line-removed">850         if (protectedThis-&gt;m_backend)</span>
<span class="line-removed">851             protectedThis-&gt;m_backend-&gt;GetStats(protectedThis.ptr());</span>
<span class="line-removed">852     });</span>
853 }
854 
855 class RTCStatsLogger {
856 public:
857     explicit RTCStatsLogger(const webrtc::RTCStats&amp; stats)
858         : m_stats(stats)
859     {
860     }
861 
862     String toJSONString() const { return String(m_stats.ToJson().c_str()); }
863 
864 private:
865     const webrtc::RTCStats&amp; m_stats;
866 };
867 
868 void LibWebRTCMediaEndpoint::OnStatsDelivered(const rtc::scoped_refptr&lt;const webrtc::RTCStatsReport&gt;&amp; report)
869 {
870 #if !RELEASE_LOG_DISABLED
871     int64_t timestamp = report-&gt;timestamp_us();
872     if (!m_statsFirstDeliveredTimestamp)
873         m_statsFirstDeliveredTimestamp = timestamp;
874 
875     callOnMainThread([protectedThis = makeRef(*this), this, timestamp, report] {
<span class="line-modified">876         if (m_statsLogTimer.repeatInterval() != statsLogInterval(timestamp)) {</span>
877             m_statsLogTimer.stop();
878             m_statsLogTimer.startRepeating(statsLogInterval(timestamp));
879         }
880 
881         for (auto iterator = report-&gt;begin(); iterator != report-&gt;end(); ++iterator) {
<span class="line-modified">882             if (logger().willLog(logChannel(), WTFLogLevelDebug)) {</span>
883                 // Stats are very verbose, let&#39;s only display them in inspector console in verbose mode.
884                 logger().debug(LogWebRTC,
885                     Logger::LogSiteIdentifier(&quot;LibWebRTCMediaEndpoint&quot;, &quot;OnStatsDelivered&quot;, logIdentifier()),
886                     RTCStatsLogger { *iterator });
887             } else {
888                 logger().logAlways(LogWebRTCStats,
889                     Logger::LogSiteIdentifier(&quot;LibWebRTCMediaEndpoint&quot;, &quot;OnStatsDelivered&quot;, logIdentifier()),
890                     RTCStatsLogger { *iterator });
891             }
892         }
893     });
894 #else
895     UNUSED_PARAM(report);
896 #endif
897 }
898 
899 void LibWebRTCMediaEndpoint::startLoggingStats()
900 {
901 #if !RELEASE_LOG_DISABLED
902     if (m_statsLogTimer.isActive())
903         m_statsLogTimer.stop();
904     m_statsLogTimer.startRepeating(statsLogInterval(0));
905 #endif
906 }
907 
908 void LibWebRTCMediaEndpoint::stopLoggingStats()
909 {
910     m_statsLogTimer.stop();
911 }
912 
913 #if !RELEASE_LOG_DISABLED
914 WTFLogChannel&amp; LibWebRTCMediaEndpoint::logChannel() const
915 {
916     return LogWebRTC;
917 }
918 
919 Seconds LibWebRTCMediaEndpoint::statsLogInterval(int64_t reportTimestamp) const
920 {
<span class="line-modified">921     if (logger().willLog(logChannel(), WTFLogLevelInfo))</span>
922         return 2_s;
923 
924     if (reportTimestamp - m_statsFirstDeliveredTimestamp &gt; 15000000)
925         return 10_s;
926 
927     return 4_s;
928 }
929 #endif
930 
931 } // namespace WebCore
932 
933 namespace WTF {
934 
935 template&lt;typename Type&gt;
936 struct LogArgument;
937 
938 template &lt;&gt;
939 struct LogArgument&lt;WebCore::RTCStatsLogger&gt; {
940     static String toString(const WebCore::RTCStatsLogger&amp; logger)
941     {
</pre>
</td>
<td>
<hr />
<pre>
 30 #include &quot;EventNames.h&quot;
 31 #include &quot;JSRTCStatsReport.h&quot;
 32 #include &quot;LibWebRTCDataChannelHandler.h&quot;
 33 #include &quot;LibWebRTCPeerConnectionBackend.h&quot;
 34 #include &quot;LibWebRTCProvider.h&quot;
 35 #include &quot;LibWebRTCRtpReceiverBackend.h&quot;
 36 #include &quot;LibWebRTCRtpSenderBackend.h&quot;
 37 #include &quot;LibWebRTCRtpTransceiverBackend.h&quot;
 38 #include &quot;LibWebRTCStatsCollector.h&quot;
 39 #include &quot;LibWebRTCUtils.h&quot;
 40 #include &quot;Logging.h&quot;
 41 #include &quot;NotImplemented.h&quot;
 42 #include &quot;Performance.h&quot;
 43 #include &quot;PlatformStrategies.h&quot;
 44 #include &quot;RTCDataChannel.h&quot;
 45 #include &quot;RTCDataChannelEvent.h&quot;
 46 #include &quot;RTCOfferOptions.h&quot;
 47 #include &quot;RTCPeerConnection.h&quot;
 48 #include &quot;RTCSessionDescription.h&quot;
 49 #include &quot;RTCStatsReport.h&quot;

 50 #include &quot;RealtimeIncomingAudioSource.h&quot;
 51 #include &quot;RealtimeIncomingVideoSource.h&quot;
 52 #include &quot;RealtimeOutgoingAudioSource.h&quot;
 53 #include &quot;RealtimeOutgoingVideoSource.h&quot;
 54 #include &quot;RuntimeEnabledFeatures.h&quot;
 55 #include &lt;webrtc/rtc_base/physicalsocketserver.h&gt;
 56 #include &lt;webrtc/p2p/base/basicpacketsocketfactory.h&gt;
 57 #include &lt;webrtc/p2p/client/basicportallocator.h&gt;
 58 #include &lt;webrtc/pc/peerconnectionfactory.h&gt;
 59 #include &lt;webrtc/system_wrappers/include/field_trial.h&gt;
 60 #include &lt;wtf/MainThread.h&gt;
 61 
 62 namespace WebCore {
 63 
 64 LibWebRTCMediaEndpoint::LibWebRTCMediaEndpoint(LibWebRTCPeerConnectionBackend&amp; peerConnection, LibWebRTCProvider&amp; client)
 65     : m_peerConnectionBackend(peerConnection)
 66     , m_peerConnectionFactory(*client.factory())
 67     , m_createSessionDescriptionObserver(*this)
 68     , m_setLocalSessionDescriptionObserver(*this)
 69     , m_setRemoteSessionDescriptionObserver(*this)
 70     , m_statsLogTimer(*this, &amp;LibWebRTCMediaEndpoint::gatherStatsForLogging)
 71 #if !RELEASE_LOG_DISABLED
 72     , m_logger(peerConnection.logger())
 73     , m_logIdentifier(peerConnection.logIdentifier())
 74 #endif
 75 {
 76     ASSERT(isMainThread());
 77     ASSERT(client.factory());
 78 
 79     if (RuntimeEnabledFeatures::sharedFeatures().webRTCH264SimulcastEnabled())
 80         webrtc::field_trial::InitFieldTrialsFromString(&quot;WebRTC-H264Simulcast/Enabled/&quot;);
 81 }
 82 
 83 bool LibWebRTCMediaEndpoint::setConfiguration(LibWebRTCProvider&amp; client, webrtc::PeerConnectionInterface::RTCConfiguration&amp;&amp; configuration)
 84 {
 85     if (RuntimeEnabledFeatures::sharedFeatures().webRTCUnifiedPlanEnabled())
 86         configuration.sdp_semantics = webrtc::SdpSemantics::kUnifiedPlan;
 87 
 88     if (!m_backend) {
<span class="line-modified"> 89         if (!m_rtcSocketFactory) {</span>
<span class="line-added"> 90             auto&amp; document = downcast&lt;Document&gt;(*m_peerConnectionBackend.connection().scriptExecutionContext());</span>
<span class="line-added"> 91             m_rtcSocketFactory = client.createSocketFactory(document.sessionID(), document.userAgent(document.url()));</span>
<span class="line-added"> 92         }</span>
<span class="line-added"> 93         m_backend = client.createPeerConnection(*this, m_rtcSocketFactory.get(), WTFMove(configuration));</span>
 94         return !!m_backend;
 95     }
 96     auto oldConfiguration = m_backend-&gt;GetConfiguration();
 97     configuration.certificates = oldConfiguration.certificates;
 98     return m_backend-&gt;SetConfiguration(WTFMove(configuration));
 99 }
100 
101 static inline const char* sessionDescriptionType(RTCSdpType sdpType)
102 {
103     switch (sdpType) {
104     case RTCSdpType::Offer:
105         return &quot;offer&quot;;
106     case RTCSdpType::Pranswer:
107         return &quot;pranswer&quot;;
108     case RTCSdpType::Answer:
109         return &quot;answer&quot;;
110     case RTCSdpType::Rollback:
111         return &quot;rollback&quot;;
112     }
113 
</pre>
<hr />
<pre>
205 }
206 
207 bool LibWebRTCMediaEndpoint::addTrack(LibWebRTCRtpSenderBackend&amp; sender, MediaStreamTrack&amp; track, const Vector&lt;String&gt;&amp; mediaStreamIds)
208 {
209     ASSERT(m_backend);
210 
211     if (!RuntimeEnabledFeatures::sharedFeatures().webRTCUnifiedPlanEnabled()) {
212         String mediaStreamId = mediaStreamIds.isEmpty() ? createCanonicalUUIDString() : mediaStreamIds[0];
213         m_localStreams.ensure(mediaStreamId, [&amp;] {
214             auto mediaStream = m_peerConnectionFactory.CreateLocalMediaStream(mediaStreamId.utf8().data());
215             m_backend-&gt;AddStream(mediaStream);
216             return mediaStream;
217         });
218     }
219 
220     LibWebRTCRtpSenderBackend::Source source;
221     rtc::scoped_refptr&lt;webrtc::MediaStreamTrackInterface&gt; rtcTrack;
222     switch (track.privateTrack().type()) {
223     case RealtimeMediaSource::Type::Audio: {
224         auto audioSource = RealtimeOutgoingAudioSource::create(track.privateTrack());



225         rtcTrack = m_peerConnectionFactory.CreateAudioTrack(track.id().utf8().data(), audioSource.ptr());
226         source = WTFMove(audioSource);
227         break;
228     }
229     case RealtimeMediaSource::Type::Video: {
230         auto videoSource = RealtimeOutgoingVideoSource::create(track.privateTrack());



231         rtcTrack = m_peerConnectionFactory.CreateVideoTrack(track.id().utf8().data(), videoSource.ptr());
232         source = WTFMove(videoSource);
233         break;
234     }
235     case RealtimeMediaSource::Type::None:
236         ASSERT_NOT_REACHED();
237         return false;
238     }
239 
240     sender.setSource(WTFMove(source));
241     if (auto rtpSender = sender.rtcSender()) {
242         rtpSender-&gt;SetTrack(rtcTrack.get());
243         return true;
244     }
245 
246     std::vector&lt;std::string&gt; ids;
247     for (auto&amp; id : mediaStreamIds)
248         ids.push_back(id.utf8().data());
249 
250     auto newRTPSender = m_backend-&gt;AddTrack(rtcTrack.get(), WTFMove(ids));
</pre>
<hr />
<pre>
270     rtcOptions.ice_restart = options.iceRestart;
271     rtcOptions.voice_activity_detection = options.voiceActivityDetection;
272 
273     if (!RuntimeEnabledFeatures::sharedFeatures().webRTCUnifiedPlanEnabled()) {
274         if (m_peerConnectionBackend.shouldOfferAllowToReceive(&quot;audio&quot;_s))
275             rtcOptions.offer_to_receive_audio = webrtc::PeerConnectionInterface::RTCOfferAnswerOptions::kOfferToReceiveMediaTrue;
276         if (m_peerConnectionBackend.shouldOfferAllowToReceive(&quot;video&quot;_s))
277             rtcOptions.offer_to_receive_video = webrtc::PeerConnectionInterface::RTCOfferAnswerOptions::kOfferToReceiveMediaTrue;
278     }
279     m_backend-&gt;CreateOffer(&amp;m_createSessionDescriptionObserver, rtcOptions);
280 }
281 
282 void LibWebRTCMediaEndpoint::doCreateAnswer()
283 {
284     ASSERT(m_backend);
285 
286     m_isInitiator = false;
287     m_backend-&gt;CreateAnswer(&amp;m_createSessionDescriptionObserver, { });
288 }
289 
<span class="line-modified">290 rtc::scoped_refptr&lt;LibWebRTCStatsCollector&gt; LibWebRTCMediaEndpoint::createStatsCollector(Ref&lt;DeferredPromise&gt;&amp;&amp; promise)</span>
291 {
<span class="line-modified">292     return LibWebRTCStatsCollector::create([promise = WTFMove(promise), protectedThis = makeRef(*this)]() mutable -&gt; RefPtr&lt;RTCStatsReport&gt; {</span>
293         ASSERT(isMainThread());
294         if (protectedThis-&gt;isStopped())
295             return nullptr;
296 
297         auto report = RTCStatsReport::create();
298 
299         promise-&gt;resolve&lt;IDLInterface&lt;RTCStatsReport&gt;&gt;(report.copyRef());
300 
301         // The promise resolution might fail in which case no backing map will be created.
302         if (!report-&gt;backingMap())
303             return nullptr;
<span class="line-modified">304         return report;</span>



305     });
306 }
307 
308 void LibWebRTCMediaEndpoint::getStats(Ref&lt;DeferredPromise&gt;&amp;&amp; promise)
309 {
<span class="line-modified">310     if (m_backend)</span>
<span class="line-modified">311         m_backend-&gt;GetStats(createStatsCollector(WTFMove(promise)));</span>


312 }
313 
314 void LibWebRTCMediaEndpoint::getStats(webrtc::RtpReceiverInterface&amp; receiver, Ref&lt;DeferredPromise&gt;&amp;&amp; promise)
315 {
<span class="line-modified">316     if (m_backend)</span>
<span class="line-modified">317         m_backend-&gt;GetStats(rtc::scoped_refptr&lt;webrtc::RtpReceiverInterface&gt;(&amp;receiver), createStatsCollector(WTFMove(promise)));</span>


318 }
319 
320 void LibWebRTCMediaEndpoint::getStats(webrtc::RtpSenderInterface&amp; sender, Ref&lt;DeferredPromise&gt;&amp;&amp; promise)
321 {
<span class="line-modified">322     if (m_backend)</span>
<span class="line-modified">323         m_backend-&gt;GetStats(rtc::scoped_refptr&lt;webrtc::RtpSenderInterface&gt;(&amp;sender), createStatsCollector(WTFMove(promise)));</span>


324 }
325 
326 static RTCSignalingState signalingState(webrtc::PeerConnectionInterface::SignalingState state)
327 {
328     switch (state) {
329     case webrtc::PeerConnectionInterface::kStable:
330         return RTCSignalingState::Stable;
331     case webrtc::PeerConnectionInterface::kHaveLocalOffer:
332         return RTCSignalingState::HaveLocalOffer;
333     case webrtc::PeerConnectionInterface::kHaveLocalPrAnswer:
334         return RTCSignalingState::HaveLocalPranswer;
335     case webrtc::PeerConnectionInterface::kHaveRemoteOffer:
336         return RTCSignalingState::HaveRemoteOffer;
337     case webrtc::PeerConnectionInterface::kHaveRemotePrAnswer:
338         return RTCSignalingState::HaveRemotePranswer;
339     case webrtc::PeerConnectionInterface::kClosed:
340         return RTCSignalingState::Stable;
341     }
342 
343     ASSERT_NOT_REACHED();
344     return RTCSignalingState::Stable;
345 }
346 
347 void LibWebRTCMediaEndpoint::OnSignalingChange(webrtc::PeerConnectionInterface::SignalingState rtcState)
348 {
349     auto state = signalingState(rtcState);
350     callOnMainThread([protectedThis = makeRef(*this), state] {
351         if (protectedThis-&gt;isStopped())
352             return;
353         protectedThis-&gt;m_peerConnectionBackend.updateSignalingState(state);
354     });
355 }
356 
357 MediaStream&amp; LibWebRTCMediaEndpoint::mediaStreamFromRTCStream(webrtc::MediaStreamInterface&amp; rtcStream)
358 {
359     auto label = fromStdString(rtcStream.id());
360     auto mediaStream = m_remoteStreamsById.ensure(label, [label, this]() mutable {
<span class="line-modified">361         auto&amp; document = downcast&lt;Document&gt;(*m_peerConnectionBackend.connection().scriptExecutionContext());</span>
<span class="line-added">362         return MediaStream::create(document, MediaStreamPrivate::create(document.logger(), { }, WTFMove(label)));</span>
363     });
364     return *mediaStream.iterator-&gt;value;
365 }
366 
367 void LibWebRTCMediaEndpoint::addRemoteStream(webrtc::MediaStreamInterface&amp;)
368 {
369 }
370 
371 void LibWebRTCMediaEndpoint::addRemoteTrack(rtc::scoped_refptr&lt;webrtc::RtpReceiverInterface&gt;&amp;&amp; rtcReceiver, const std::vector&lt;rtc::scoped_refptr&lt;webrtc::MediaStreamInterface&gt;&gt;&amp; rtcStreams)
372 {
373     ASSERT(rtcReceiver);
374     RefPtr&lt;RTCRtpReceiver&gt; receiver;
375     RefPtr&lt;RealtimeMediaSource&gt; remoteSource;
376 
377     auto* rtcTrack = rtcReceiver-&gt;track().get();
378 
379     switch (rtcReceiver-&gt;media_type()) {
380     case cricket::MEDIA_TYPE_DATA:
381         return;
382     case cricket::MEDIA_TYPE_AUDIO: {
383         rtc::scoped_refptr&lt;webrtc::AudioTrackInterface&gt; audioTrack = static_cast&lt;webrtc::AudioTrackInterface*&gt;(rtcTrack);
384         auto audioReceiver = m_peerConnectionBackend.audioReceiver(fromStdString(rtcTrack-&gt;id()));
385 
386         receiver = WTFMove(audioReceiver.receiver);
387         audioReceiver.source-&gt;setSourceTrack(WTFMove(audioTrack));
388         break;
389     }
390     case cricket::MEDIA_TYPE_VIDEO: {
391         rtc::scoped_refptr&lt;webrtc::VideoTrackInterface&gt; videoTrack = static_cast&lt;webrtc::VideoTrackInterface*&gt;(rtcTrack);
392         auto videoReceiver = m_peerConnectionBackend.videoReceiver(fromStdString(rtcTrack-&gt;id()));
393 
394         receiver = WTFMove(videoReceiver.receiver);
395         videoReceiver.source-&gt;setSourceTrack(WTFMove(videoTrack));
396         break;
397     }
398     }
399 
<span class="line-modified">400     receiver-&gt;setBackend(makeUnique&lt;LibWebRTCRtpReceiverBackend&gt;(WTFMove(rtcReceiver)));</span>
401     auto&amp; track = receiver-&gt;track();
<span class="line-modified">402     addPendingTrackEvent(receiver.releaseNonNull(), track, rtcStreams, nullptr);</span>
403 }
404 
<span class="line-modified">405 void LibWebRTCMediaEndpoint::addPendingTrackEvent(Ref&lt;RTCRtpReceiver&gt;&amp;&amp; receiver, MediaStreamTrack&amp; track, const std::vector&lt;rtc::scoped_refptr&lt;webrtc::MediaStreamInterface&gt;&gt;&amp; rtcStreams, RefPtr&lt;RTCRtpTransceiver&gt;&amp;&amp; transceiver)</span>
406 {
407     Vector&lt;RefPtr&lt;MediaStream&gt;&gt; streams;
408     for (auto&amp; rtcStream : rtcStreams) {
409         auto&amp; mediaStream = mediaStreamFromRTCStream(*rtcStream.get());
410         streams.append(&amp;mediaStream);
411         mediaStream.addTrackFromPlatform(track);
412     }
413     auto streamIds = WTF::map(streams, [](auto&amp; stream) -&gt; String {
414         return stream-&gt;id();
415     });
416     m_remoteStreamsFromRemoteTrack.add(&amp;track, WTFMove(streamIds));
417 
<span class="line-modified">418     m_peerConnectionBackend.addPendingTrackEvent({ WTFMove(receiver), makeRef(track), WTFMove(streams), WTFMove(transceiver) });</span>




419 }
420 
421 static inline void setExistingReceiverSourceTrack(RealtimeMediaSource&amp; existingSource, webrtc::RtpReceiverInterface&amp; rtcReceiver)
422 {
423     switch (rtcReceiver.media_type()) {
424     case cricket::MEDIA_TYPE_AUDIO: {
425         ASSERT(existingSource.type() == RealtimeMediaSource::Type::Audio);
426         rtc::scoped_refptr&lt;webrtc::AudioTrackInterface&gt; audioTrack = static_cast&lt;webrtc::AudioTrackInterface*&gt;(rtcReceiver.track().get());
427         downcast&lt;RealtimeIncomingAudioSource&gt;(existingSource).setSourceTrack(WTFMove(audioTrack));
428         return;
429     }
430     case cricket::MEDIA_TYPE_VIDEO: {
431         ASSERT(existingSource.type() == RealtimeMediaSource::Type::Video);
432         rtc::scoped_refptr&lt;webrtc::VideoTrackInterface&gt; videoTrack = static_cast&lt;webrtc::VideoTrackInterface*&gt;(rtcReceiver.track().get());
433         downcast&lt;RealtimeIncomingVideoSource&gt;(existingSource).setSourceTrack(WTFMove(videoTrack));
434         return;
435     }
436     case cricket::MEDIA_TYPE_DATA:
437         ASSERT_NOT_REACHED();
438         return;
439     }
440 }
441 
442 RefPtr&lt;RealtimeMediaSource&gt; LibWebRTCMediaEndpoint::sourceFromNewReceiver(webrtc::RtpReceiverInterface&amp; rtcReceiver)
443 {
444     auto rtcTrack = rtcReceiver.track();
445     switch (rtcReceiver.media_type()) {
446     case cricket::MEDIA_TYPE_DATA:
447         return nullptr;
448     case cricket::MEDIA_TYPE_AUDIO: {
449         rtc::scoped_refptr&lt;webrtc::AudioTrackInterface&gt; audioTrack = static_cast&lt;webrtc::AudioTrackInterface*&gt;(rtcTrack.get());
<span class="line-modified">450         return RealtimeIncomingAudioSource::create(WTFMove(audioTrack), fromStdString(rtcTrack-&gt;id()));</span>




451     }
452     case cricket::MEDIA_TYPE_VIDEO: {
453         rtc::scoped_refptr&lt;webrtc::VideoTrackInterface&gt; videoTrack = static_cast&lt;webrtc::VideoTrackInterface*&gt;(rtcTrack.get());
<span class="line-modified">454         return RealtimeIncomingVideoSource::create(WTFMove(videoTrack), fromStdString(rtcTrack-&gt;id()));</span>




455     }
456     }
457 
458     RELEASE_ASSERT_NOT_REACHED();
459 }
460 
461 void LibWebRTCMediaEndpoint::collectTransceivers()
462 {
463     if (!m_backend)
464         return;
465 
466     if (!RuntimeEnabledFeatures::sharedFeatures().webRTCUnifiedPlanEnabled())
467         return;
468 
469     for (auto&amp; rtcTransceiver : m_backend-&gt;GetTransceivers()) {
470         auto* existingTransceiver = m_peerConnectionBackend.existingTransceiver([&amp;](auto&amp; transceiverBackend) {
471             return rtcTransceiver.get() == transceiverBackend.rtcTransceiver();
472         });
473         if (existingTransceiver)
474             continue;
475 
476         auto rtcReceiver = rtcTransceiver-&gt;receiver();
477         auto source = sourceFromNewReceiver(*rtcReceiver);
478         if (!source)
479             return;
480 
<span class="line-modified">481         m_peerConnectionBackend.newRemoteTransceiver(makeUnique&lt;LibWebRTCRtpTransceiverBackend&gt;(WTFMove(rtcTransceiver)), source.releaseNonNull());</span>
482     }
483 }
484 
485 void LibWebRTCMediaEndpoint::newTransceiver(rtc::scoped_refptr&lt;webrtc::RtpTransceiverInterface&gt;&amp;&amp; rtcTransceiver)
486 {
487     auto* transceiver = m_peerConnectionBackend.existingTransceiver([&amp;](auto&amp; transceiverBackend) {
488         return rtcTransceiver.get() == transceiverBackend.rtcTransceiver();
489     });
490     if (transceiver) {
491         auto rtcReceiver = rtcTransceiver-&gt;receiver();
492         setExistingReceiverSourceTrack(transceiver-&gt;receiver().track().source(), *rtcReceiver);
<span class="line-modified">493         addPendingTrackEvent(makeRef(transceiver-&gt;receiver()), transceiver-&gt;receiver().track(), rtcReceiver-&gt;streams(), makeRef(*transceiver));</span>
494         return;
495     }
496 
497     auto rtcReceiver = rtcTransceiver-&gt;receiver();
498     auto source = sourceFromNewReceiver(*rtcReceiver);
499     if (!source)
500         return;
501 
<span class="line-modified">502     auto&amp; newTransceiver = m_peerConnectionBackend.newRemoteTransceiver(makeUnique&lt;LibWebRTCRtpTransceiverBackend&gt;(WTFMove(rtcTransceiver)), source.releaseNonNull());</span>
503 
<span class="line-modified">504     addPendingTrackEvent(makeRef(newTransceiver.receiver()), newTransceiver.receiver().track(), rtcReceiver-&gt;streams(), makeRef(newTransceiver));</span>
505 }
506 
507 void LibWebRTCMediaEndpoint::removeRemoteTrack(rtc::scoped_refptr&lt;webrtc::RtpReceiverInterface&gt;&amp;&amp; receiver)
508 {
509     // FIXME: Support plan B code path.
510     if (!RuntimeEnabledFeatures::sharedFeatures().webRTCUnifiedPlanEnabled())
511         return;
512 
513     auto* transceiver = m_peerConnectionBackend.existingTransceiver([&amp;receiver](auto&amp; transceiverBackend) {
514         auto* rtcTransceiver = transceiverBackend.rtcTransceiver();
515         return rtcTransceiver &amp;&amp; receiver.get() == rtcTransceiver-&gt;receiver().get();
516     });
517     if (!transceiver)
518         return;
519 
520     auto&amp; track = transceiver-&gt;receiver().track();
521 
522     for (auto&amp; id : m_remoteStreamsFromRemoteTrack.get(&amp;track)) {
523         if (auto stream = m_remoteStreamsById.get(id))
524             stream-&gt;privateStream().removeTrack(track.privateTrack(), MediaStreamPrivate::NotifyClientOption::Notify);
525     }
526 
527     track.source().setMuted(true);
528 }
529 
530 template&lt;typename T&gt;
531 Optional&lt;LibWebRTCMediaEndpoint::Backends&gt; LibWebRTCMediaEndpoint::createTransceiverBackends(T&amp;&amp; trackOrKind, const RTCRtpTransceiverInit&amp; init, LibWebRTCRtpSenderBackend::Source&amp;&amp; source)
532 {
533     auto result = m_backend-&gt;AddTransceiver(WTFMove(trackOrKind), fromRtpTransceiverInit(init));
534     if (!result.ok())
535         return WTF::nullopt;
536 
<span class="line-modified">537     auto transceiver = makeUnique&lt;LibWebRTCRtpTransceiverBackend&gt;(result.MoveValue());</span>
538     return LibWebRTCMediaEndpoint::Backends { transceiver-&gt;createSenderBackend(m_peerConnectionBackend, WTFMove(source)), transceiver-&gt;createReceiverBackend(), WTFMove(transceiver) };
539 }
540 
541 Optional&lt;LibWebRTCMediaEndpoint::Backends&gt; LibWebRTCMediaEndpoint::addTransceiver(const String&amp; trackKind, const RTCRtpTransceiverInit&amp; init)
542 {
543     auto type = trackKind == &quot;audio&quot; ? cricket::MediaType::MEDIA_TYPE_AUDIO : cricket::MediaType::MEDIA_TYPE_VIDEO;
544     return createTransceiverBackends(type, init, nullptr);
545 }
546 
547 std::pair&lt;LibWebRTCRtpSenderBackend::Source, rtc::scoped_refptr&lt;webrtc::MediaStreamTrackInterface&gt;&gt; LibWebRTCMediaEndpoint::createSourceAndRTCTrack(MediaStreamTrack&amp; track)
548 {
549     LibWebRTCRtpSenderBackend::Source source;
550     rtc::scoped_refptr&lt;webrtc::MediaStreamTrackInterface&gt; rtcTrack;
551     switch (track.privateTrack().type()) {
552     case RealtimeMediaSource::Type::None:
553         ASSERT_NOT_REACHED();
554         break;
555     case RealtimeMediaSource::Type::Audio: {
556         auto audioSource = RealtimeOutgoingAudioSource::create(track.privateTrack());
557         rtcTrack = m_peerConnectionFactory.CreateAudioTrack(track.id().utf8().data(), audioSource.ptr());
</pre>
<hr />
<pre>
568     return std::make_pair(WTFMove(source), WTFMove(rtcTrack));
569 }
570 
571 Optional&lt;LibWebRTCMediaEndpoint::Backends&gt; LibWebRTCMediaEndpoint::addTransceiver(MediaStreamTrack&amp; track, const RTCRtpTransceiverInit&amp; init)
572 {
573     auto sourceAndTrack = createSourceAndRTCTrack(track);
574     return createTransceiverBackends(WTFMove(sourceAndTrack.second), init, WTFMove(sourceAndTrack.first));
575 }
576 
577 void LibWebRTCMediaEndpoint::setSenderSourceFromTrack(LibWebRTCRtpSenderBackend&amp; sender, MediaStreamTrack&amp; track)
578 {
579     auto sourceAndTrack = createSourceAndRTCTrack(track);
580     sender.setSource(WTFMove(sourceAndTrack.first));
581     sender.rtcSender()-&gt;SetTrack(WTFMove(sourceAndTrack.second));
582 }
583 
584 std::unique_ptr&lt;LibWebRTCRtpTransceiverBackend&gt; LibWebRTCMediaEndpoint::transceiverBackendFromSender(LibWebRTCRtpSenderBackend&amp; backend)
585 {
586     for (auto&amp; transceiver : m_backend-&gt;GetTransceivers()) {
587         if (transceiver-&gt;sender().get() == backend.rtcSender())
<span class="line-modified">588             return makeUnique&lt;LibWebRTCRtpTransceiverBackend&gt;(rtc::scoped_refptr&lt;webrtc::RtpTransceiverInterface&gt;(transceiver));</span>
589     }
590     return nullptr;
591 }
592 
593 
594 void LibWebRTCMediaEndpoint::removeRemoteStream(webrtc::MediaStreamInterface&amp; rtcStream)
595 {
596     bool removed = m_remoteStreamsById.remove(fromStdString(rtcStream.id()));
597     ASSERT_UNUSED(removed, removed);
598 }
599 
600 void LibWebRTCMediaEndpoint::OnAddStream(rtc::scoped_refptr&lt;webrtc::MediaStreamInterface&gt; stream)
601 {
602     callOnMainThread([protectedThis = makeRef(*this), stream = WTFMove(stream)] {
603         if (protectedThis-&gt;isStopped())
604             return;
605         ASSERT(stream);
606         protectedThis-&gt;addRemoteStream(*stream.get());
607     });
608 }
</pre>
<hr />
<pre>
637     callOnMainThread([protectedThis = makeRef(*this), transceiver = WTFMove(transceiver)]() mutable {
638         if (protectedThis-&gt;isStopped())
639             return;
640         protectedThis-&gt;newTransceiver(WTFMove(transceiver));
641     });
642 }
643 
644 void LibWebRTCMediaEndpoint::OnRemoveTrack(rtc::scoped_refptr&lt;webrtc::RtpReceiverInterface&gt; receiver)
645 {
646     callOnMainThread([protectedThis = makeRef(*this), receiver = WTFMove(receiver)]() mutable {
647         if (protectedThis-&gt;isStopped())
648             return;
649         protectedThis-&gt;removeRemoteTrack(WTFMove(receiver));
650     });
651 }
652 
653 std::unique_ptr&lt;RTCDataChannelHandler&gt; LibWebRTCMediaEndpoint::createDataChannel(const String&amp; label, const RTCDataChannelInit&amp; options)
654 {
655     auto init = LibWebRTCDataChannelHandler::fromRTCDataChannelInit(options);
656     auto channel = m_backend-&gt;CreateDataChannel(label.utf8().data(), &amp;init);
<span class="line-modified">657     return channel ? makeUnique&lt;LibWebRTCDataChannelHandler&gt;(WTFMove(channel)) : nullptr;</span>
658 }
659 
660 void LibWebRTCMediaEndpoint::OnDataChannel(rtc::scoped_refptr&lt;webrtc::DataChannelInterface&gt; dataChannel)
661 {
662     callOnMainThread([protectedThis = makeRef(*this), dataChannel = WTFMove(dataChannel)]() mutable {
663         if (protectedThis-&gt;isStopped())
664             return;
665         auto&amp; connection = protectedThis-&gt;m_peerConnectionBackend.connection();
666         connection.fireEvent(LibWebRTCDataChannelHandler::channelEvent(*connection.scriptExecutionContext(), WTFMove(dataChannel)));
667     });
668 }
669 
670 void LibWebRTCMediaEndpoint::stop()
671 {
672     if (!m_backend)
673         return;
674 
675     stopLoggingStats();
676 
677     m_backend-&gt;Close();
</pre>
<hr />
<pre>
806 void LibWebRTCMediaEndpoint::setRemoteSessionDescriptionSucceeded()
807 {
808     callOnMainThread([protectedThis = makeRef(*this)] {
809         if (protectedThis-&gt;isStopped())
810             return;
811         protectedThis-&gt;m_peerConnectionBackend.setRemoteDescriptionSucceeded();
812     });
813 }
814 
815 void LibWebRTCMediaEndpoint::setRemoteSessionDescriptionFailed(ExceptionCode errorCode, const char* errorMessage)
816 {
817     callOnMainThread([protectedThis = makeRef(*this), errorCode, errorMessage = String(errorMessage)] () mutable {
818         if (protectedThis-&gt;isStopped())
819             return;
820         protectedThis-&gt;m_peerConnectionBackend.setRemoteDescriptionFailed(Exception { errorCode, WTFMove(errorMessage) });
821     });
822 }
823 
824 void LibWebRTCMediaEndpoint::gatherStatsForLogging()
825 {
<span class="line-modified">826     m_backend-&gt;GetStats(this);</span>



827 }
828 
829 class RTCStatsLogger {
830 public:
831     explicit RTCStatsLogger(const webrtc::RTCStats&amp; stats)
832         : m_stats(stats)
833     {
834     }
835 
836     String toJSONString() const { return String(m_stats.ToJson().c_str()); }
837 
838 private:
839     const webrtc::RTCStats&amp; m_stats;
840 };
841 
842 void LibWebRTCMediaEndpoint::OnStatsDelivered(const rtc::scoped_refptr&lt;const webrtc::RTCStatsReport&gt;&amp; report)
843 {
844 #if !RELEASE_LOG_DISABLED
845     int64_t timestamp = report-&gt;timestamp_us();
846     if (!m_statsFirstDeliveredTimestamp)
847         m_statsFirstDeliveredTimestamp = timestamp;
848 
849     callOnMainThread([protectedThis = makeRef(*this), this, timestamp, report] {
<span class="line-modified">850         if (m_backend &amp;&amp; m_statsLogTimer.repeatInterval() != statsLogInterval(timestamp)) {</span>
851             m_statsLogTimer.stop();
852             m_statsLogTimer.startRepeating(statsLogInterval(timestamp));
853         }
854 
855         for (auto iterator = report-&gt;begin(); iterator != report-&gt;end(); ++iterator) {
<span class="line-modified">856             if (logger().willLog(logChannel(), WTFLogLevel::Debug)) {</span>
857                 // Stats are very verbose, let&#39;s only display them in inspector console in verbose mode.
858                 logger().debug(LogWebRTC,
859                     Logger::LogSiteIdentifier(&quot;LibWebRTCMediaEndpoint&quot;, &quot;OnStatsDelivered&quot;, logIdentifier()),
860                     RTCStatsLogger { *iterator });
861             } else {
862                 logger().logAlways(LogWebRTCStats,
863                     Logger::LogSiteIdentifier(&quot;LibWebRTCMediaEndpoint&quot;, &quot;OnStatsDelivered&quot;, logIdentifier()),
864                     RTCStatsLogger { *iterator });
865             }
866         }
867     });
868 #else
869     UNUSED_PARAM(report);
870 #endif
871 }
872 
873 void LibWebRTCMediaEndpoint::startLoggingStats()
874 {
875 #if !RELEASE_LOG_DISABLED
876     if (m_statsLogTimer.isActive())
877         m_statsLogTimer.stop();
878     m_statsLogTimer.startRepeating(statsLogInterval(0));
879 #endif
880 }
881 
882 void LibWebRTCMediaEndpoint::stopLoggingStats()
883 {
884     m_statsLogTimer.stop();
885 }
886 
887 #if !RELEASE_LOG_DISABLED
888 WTFLogChannel&amp; LibWebRTCMediaEndpoint::logChannel() const
889 {
890     return LogWebRTC;
891 }
892 
893 Seconds LibWebRTCMediaEndpoint::statsLogInterval(int64_t reportTimestamp) const
894 {
<span class="line-modified">895     if (logger().willLog(logChannel(), WTFLogLevel::Info))</span>
896         return 2_s;
897 
898     if (reportTimestamp - m_statsFirstDeliveredTimestamp &gt; 15000000)
899         return 10_s;
900 
901     return 4_s;
902 }
903 #endif
904 
905 } // namespace WebCore
906 
907 namespace WTF {
908 
909 template&lt;typename Type&gt;
910 struct LogArgument;
911 
912 template &lt;&gt;
913 struct LogArgument&lt;WebCore::RTCStatsLogger&gt; {
914     static String toString(const WebCore::RTCStatsLogger&amp; logger)
915     {
</pre>
</td>
</tr>
</table>
<center><a href="LibWebRTCDataChannelHandler.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="LibWebRTCMediaEndpoint.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>