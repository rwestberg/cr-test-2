<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/GraphicsContext.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (C) 2003, 2004, 2005, 2006, 2009, 2013 Apple Inc. All rights reserved.
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  * 1. Redistributions of source code must retain the above copyright
   8  *    notice, this list of conditions and the following disclaimer.
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
  14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
  15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
  17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
  23  * THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #include &quot;config.h&quot;
  27 #include &quot;GraphicsContext.h&quot;
  28 
  29 #include &quot;BidiResolver.h&quot;
  30 #include &quot;BitmapImage.h&quot;
  31 #include &quot;FloatRoundedRect.h&quot;
  32 #include &quot;Gradient.h&quot;
  33 #include &quot;GraphicsContextImpl.h&quot;
  34 #include &quot;ImageBuffer.h&quot;
  35 #include &quot;IntRect.h&quot;
  36 #include &quot;RoundedRect.h&quot;
  37 #include &quot;TextRun.h&quot;
  38 #include &lt;wtf/text/TextStream.h&gt;
  39 
  40 namespace WebCore {
  41 
  42 class TextRunIterator {
  43 public:
  44     TextRunIterator()
  45         : m_textRun(0)
  46         , m_offset(0)
  47     {
  48     }
  49 
  50     TextRunIterator(const TextRun* textRun, unsigned offset)
  51         : m_textRun(textRun)
  52         , m_offset(offset)
  53     {
  54     }
  55 
<a name="1" id="anc1"></a><span class="line-removed">  56     TextRunIterator(const TextRunIterator&amp; other)</span>
<span class="line-removed">  57         : m_textRun(other.m_textRun)</span>
<span class="line-removed">  58         , m_offset(other.m_offset)</span>
<span class="line-removed">  59     {</span>
<span class="line-removed">  60     }</span>
<span class="line-removed">  61 </span>
  62     unsigned offset() const { return m_offset; }
  63     void increment() { m_offset++; }
  64     bool atEnd() const { return !m_textRun || m_offset &gt;= m_textRun-&gt;length(); }
  65     UChar current() const { return (*m_textRun)[m_offset]; }
  66     UCharDirection direction() const { return atEnd() ? U_OTHER_NEUTRAL : u_charDirection(current()); }
  67 
  68     bool operator==(const TextRunIterator&amp; other)
  69     {
  70         return m_offset == other.m_offset &amp;&amp; m_textRun == other.m_textRun;
  71     }
  72 
  73     bool operator!=(const TextRunIterator&amp; other) { return !operator==(other); }
  74 
  75 private:
  76     const TextRun* m_textRun;
  77     unsigned m_offset;
  78 };
  79 
  80 #define CHECK_FOR_CHANGED_PROPERTY(flag, property) \
  81     if ((m_changeFlags &amp; GraphicsContextState::flag) &amp;&amp; (m_state.property != state.property)) \
  82         changeFlags |= GraphicsContextState::flag;
  83 
  84 GraphicsContextState::StateChangeFlags GraphicsContextStateChange::changesFromState(const GraphicsContextState&amp; state) const
  85 {
  86     GraphicsContextState::StateChangeFlags changeFlags = GraphicsContextState::NoChange;
  87 
  88     CHECK_FOR_CHANGED_PROPERTY(StrokeGradientChange, strokeGradient);
  89     CHECK_FOR_CHANGED_PROPERTY(StrokePatternChange, strokePattern);
  90     CHECK_FOR_CHANGED_PROPERTY(FillGradientChange, fillGradient);
  91     CHECK_FOR_CHANGED_PROPERTY(FillPatternChange, fillPattern);
  92 
  93     if ((m_changeFlags &amp; GraphicsContextState::ShadowChange)
  94         &amp;&amp; (m_state.shadowOffset != state.shadowOffset
  95             || m_state.shadowBlur != state.shadowBlur
  96             || m_state.shadowColor != state.shadowColor))
  97         changeFlags |= GraphicsContextState::ShadowChange;
  98 
  99     CHECK_FOR_CHANGED_PROPERTY(StrokeThicknessChange, strokeThickness);
 100     CHECK_FOR_CHANGED_PROPERTY(TextDrawingModeChange, textDrawingMode);
 101     CHECK_FOR_CHANGED_PROPERTY(StrokeColorChange, strokeColor);
 102     CHECK_FOR_CHANGED_PROPERTY(FillColorChange, fillColor);
 103     CHECK_FOR_CHANGED_PROPERTY(StrokeStyleChange, strokeStyle);
 104     CHECK_FOR_CHANGED_PROPERTY(FillRuleChange, fillRule);
 105     CHECK_FOR_CHANGED_PROPERTY(AlphaChange, alpha);
 106 
 107     if ((m_changeFlags &amp; (GraphicsContextState::CompositeOperationChange | GraphicsContextState::BlendModeChange))
 108         &amp;&amp; (m_state.compositeOperator != state.compositeOperator || m_state.blendMode != state.blendMode))
 109         changeFlags |= (GraphicsContextState::CompositeOperationChange | GraphicsContextState::BlendModeChange);
 110 
 111     CHECK_FOR_CHANGED_PROPERTY(ShouldAntialiasChange, shouldAntialias);
 112     CHECK_FOR_CHANGED_PROPERTY(ShouldSmoothFontsChange, shouldSmoothFonts);
 113     CHECK_FOR_CHANGED_PROPERTY(ShouldSubpixelQuantizeFontsChange, shouldSubpixelQuantizeFonts);
 114     CHECK_FOR_CHANGED_PROPERTY(ShadowsIgnoreTransformsChange, shadowsIgnoreTransforms);
 115     CHECK_FOR_CHANGED_PROPERTY(DrawLuminanceMaskChange, drawLuminanceMask);
 116     CHECK_FOR_CHANGED_PROPERTY(ImageInterpolationQualityChange, imageInterpolationQuality);
 117 
<a name="2" id="anc2"></a>



 118     return changeFlags;
 119 }
 120 
 121 void GraphicsContextStateChange::accumulate(const GraphicsContextState&amp; state, GraphicsContextState::StateChangeFlags flags)
 122 {
 123     // FIXME: This code should move to GraphicsContextState.
 124     if (flags &amp; GraphicsContextState::StrokeGradientChange)
 125         m_state.strokeGradient = state.strokeGradient;
 126 
 127     if (flags &amp; GraphicsContextState::StrokePatternChange)
 128         m_state.strokePattern = state.strokePattern;
 129 
 130     if (flags &amp; GraphicsContextState::FillGradientChange)
 131         m_state.fillGradient = state.fillGradient;
 132 
 133     if (flags &amp; GraphicsContextState::FillPatternChange)
 134         m_state.fillPattern = state.fillPattern;
 135 
 136     if (flags &amp; GraphicsContextState::ShadowChange) {
 137         // FIXME: Deal with state.shadowsUseLegacyRadius.
 138         m_state.shadowOffset = state.shadowOffset;
 139         m_state.shadowBlur = state.shadowBlur;
 140         m_state.shadowColor = state.shadowColor;
 141     }
 142 
 143     if (flags &amp; GraphicsContextState::StrokeThicknessChange)
 144         m_state.strokeThickness = state.strokeThickness;
 145 
 146     if (flags &amp; GraphicsContextState::TextDrawingModeChange)
 147         m_state.textDrawingMode = state.textDrawingMode;
 148 
 149     if (flags &amp; GraphicsContextState::StrokeColorChange)
 150         m_state.strokeColor = state.strokeColor;
 151 
 152     if (flags &amp; GraphicsContextState::FillColorChange)
 153         m_state.fillColor = state.fillColor;
 154 
 155     if (flags &amp; GraphicsContextState::StrokeStyleChange)
 156         m_state.strokeStyle = state.strokeStyle;
 157 
 158     if (flags &amp; GraphicsContextState::FillRuleChange)
 159         m_state.fillRule = state.fillRule;
 160 
 161     if (flags &amp; GraphicsContextState::AlphaChange)
 162         m_state.alpha = state.alpha;
 163 
 164     if (flags &amp; (GraphicsContextState::CompositeOperationChange | GraphicsContextState::BlendModeChange)) {
 165         m_state.compositeOperator = state.compositeOperator;
 166         m_state.blendMode = state.blendMode;
 167     }
 168 
 169     if (flags &amp; GraphicsContextState::ShouldAntialiasChange)
 170         m_state.shouldAntialias = state.shouldAntialias;
 171 
 172     if (flags &amp; GraphicsContextState::ShouldSmoothFontsChange)
 173         m_state.shouldSmoothFonts = state.shouldSmoothFonts;
 174 
 175     if (flags &amp; GraphicsContextState::ShouldSubpixelQuantizeFontsChange)
 176         m_state.shouldSubpixelQuantizeFonts = state.shouldSubpixelQuantizeFonts;
 177 
 178     if (flags &amp; GraphicsContextState::ShadowsIgnoreTransformsChange)
 179         m_state.shadowsIgnoreTransforms = state.shadowsIgnoreTransforms;
 180 
 181     if (flags &amp; GraphicsContextState::DrawLuminanceMaskChange)
 182         m_state.drawLuminanceMask = state.drawLuminanceMask;
 183 
 184     if (flags &amp; GraphicsContextState::ImageInterpolationQualityChange)
 185         m_state.imageInterpolationQuality = state.imageInterpolationQuality;
 186 
<a name="3" id="anc3"></a>




 187     m_changeFlags |= flags;
 188 }
 189 
 190 void GraphicsContextStateChange::apply(GraphicsContext&amp; context) const
 191 {
 192     if (m_changeFlags &amp; GraphicsContextState::StrokeGradientChange)
 193         context.setStrokeGradient(*m_state.strokeGradient);
 194 
 195     if (m_changeFlags &amp; GraphicsContextState::StrokePatternChange)
 196         context.setStrokePattern(*m_state.strokePattern);
 197 
 198     if (m_changeFlags &amp; GraphicsContextState::FillGradientChange)
 199         context.setFillGradient(*m_state.fillGradient);
 200 
 201     if (m_changeFlags &amp; GraphicsContextState::FillPatternChange)
 202         context.setFillPattern(*m_state.fillPattern);
 203 
 204     if (m_changeFlags &amp; GraphicsContextState::ShadowChange) {
 205 #if USE(CG)
 206         if (m_state.shadowsUseLegacyRadius)
 207             context.setLegacyShadow(m_state.shadowOffset, m_state.shadowBlur, m_state.shadowColor);
 208         else
 209 #endif
 210             context.setShadow(m_state.shadowOffset, m_state.shadowBlur, m_state.shadowColor);
 211     }
 212 
 213     if (m_changeFlags &amp; GraphicsContextState::StrokeThicknessChange)
 214         context.setStrokeThickness(m_state.strokeThickness);
 215 
 216     if (m_changeFlags &amp; GraphicsContextState::TextDrawingModeChange)
 217         context.setTextDrawingMode(m_state.textDrawingMode);
 218 
 219     if (m_changeFlags &amp; GraphicsContextState::StrokeColorChange)
 220         context.setStrokeColor(m_state.strokeColor);
 221 
 222     if (m_changeFlags &amp; GraphicsContextState::FillColorChange)
 223         context.setFillColor(m_state.fillColor);
 224 
 225     if (m_changeFlags &amp; GraphicsContextState::StrokeStyleChange)
 226         context.setStrokeStyle(m_state.strokeStyle);
 227 
 228     if (m_changeFlags &amp; GraphicsContextState::FillRuleChange)
 229         context.setFillRule(m_state.fillRule);
 230 
 231     if (m_changeFlags &amp; GraphicsContextState::AlphaChange)
 232         context.setAlpha(m_state.alpha);
 233 
 234     if (m_changeFlags &amp; (GraphicsContextState::CompositeOperationChange | GraphicsContextState::BlendModeChange))
 235         context.setCompositeOperation(m_state.compositeOperator, m_state.blendMode);
 236 
 237     if (m_changeFlags &amp; GraphicsContextState::ShouldAntialiasChange)
 238         context.setShouldAntialias(m_state.shouldAntialias);
 239 
 240     if (m_changeFlags &amp; GraphicsContextState::ShouldSmoothFontsChange)
 241         context.setShouldSmoothFonts(m_state.shouldSmoothFonts);
 242 
 243     if (m_changeFlags &amp; GraphicsContextState::ShouldSubpixelQuantizeFontsChange)
 244         context.setShouldSubpixelQuantizeFonts(m_state.shouldSubpixelQuantizeFonts);
 245 
 246     if (m_changeFlags &amp; GraphicsContextState::ShadowsIgnoreTransformsChange)
 247         context.setShadowsIgnoreTransforms(m_state.shadowsIgnoreTransforms);
 248 
 249     if (m_changeFlags &amp; GraphicsContextState::DrawLuminanceMaskChange)
 250         context.setDrawLuminanceMask(m_state.drawLuminanceMask);
 251 
 252     if (m_changeFlags &amp; GraphicsContextState::ImageInterpolationQualityChange)
 253         context.setImageInterpolationQuality(m_state.imageInterpolationQuality);
<a name="4" id="anc4"></a>




 254 }
 255 
 256 void GraphicsContextStateChange::dump(TextStream&amp; ts) const
 257 {
 258     ts.dumpProperty(&quot;change-flags&quot;, m_changeFlags);
 259 
 260     if (m_changeFlags &amp; GraphicsContextState::StrokeGradientChange)
 261         ts.dumpProperty(&quot;stroke-gradient&quot;, m_state.strokeGradient.get());
 262 
 263     if (m_changeFlags &amp; GraphicsContextState::StrokePatternChange)
 264         ts.dumpProperty(&quot;stroke-pattern&quot;, m_state.strokePattern.get());
 265 
 266     if (m_changeFlags &amp; GraphicsContextState::FillGradientChange)
 267         ts.dumpProperty(&quot;fill-gradient&quot;, m_state.fillGradient.get());
 268 
 269     if (m_changeFlags &amp; GraphicsContextState::FillPatternChange)
 270         ts.dumpProperty(&quot;fill-pattern&quot;, m_state.fillPattern.get());
 271 
 272     if (m_changeFlags &amp; GraphicsContextState::ShadowChange) {
 273         ts.dumpProperty(&quot;shadow-blur&quot;, m_state.shadowBlur);
 274         ts.dumpProperty(&quot;shadow-offset&quot;, m_state.shadowOffset);
 275 #if USE(CG)
 276         ts.dumpProperty(&quot;shadows-use-legacy-radius&quot;, m_state.shadowsUseLegacyRadius);
 277 #endif
 278     }
 279 
 280     if (m_changeFlags &amp; GraphicsContextState::StrokeThicknessChange)
 281         ts.dumpProperty(&quot;stroke-thickness&quot;, m_state.strokeThickness);
 282 
 283     if (m_changeFlags &amp; GraphicsContextState::TextDrawingModeChange)
 284         ts.dumpProperty(&quot;text-drawing-mode&quot;, m_state.textDrawingMode);
 285 
 286     if (m_changeFlags &amp; GraphicsContextState::StrokeColorChange)
 287         ts.dumpProperty(&quot;stroke-color&quot;, m_state.strokeColor);
 288 
 289     if (m_changeFlags &amp; GraphicsContextState::FillColorChange)
 290         ts.dumpProperty(&quot;fill-color&quot;, m_state.fillColor);
 291 
 292     if (m_changeFlags &amp; GraphicsContextState::StrokeStyleChange)
 293         ts.dumpProperty(&quot;stroke-style&quot;, m_state.strokeStyle);
 294 
 295     if (m_changeFlags &amp; GraphicsContextState::FillRuleChange)
 296         ts.dumpProperty(&quot;fill-rule&quot;, m_state.fillRule);
 297 
 298     if (m_changeFlags &amp; GraphicsContextState::AlphaChange)
 299         ts.dumpProperty(&quot;alpha&quot;, m_state.alpha);
 300 
 301     if (m_changeFlags &amp; GraphicsContextState::CompositeOperationChange)
 302         ts.dumpProperty(&quot;composite-operator&quot;, m_state.compositeOperator);
 303 
 304     if (m_changeFlags &amp; GraphicsContextState::BlendModeChange)
 305         ts.dumpProperty(&quot;blend-mode&quot;, m_state.blendMode);
 306 
 307     if (m_changeFlags &amp; GraphicsContextState::ShouldAntialiasChange)
 308         ts.dumpProperty(&quot;should-antialias&quot;, m_state.shouldAntialias);
 309 
 310     if (m_changeFlags &amp; GraphicsContextState::ShouldSmoothFontsChange)
 311         ts.dumpProperty(&quot;should-smooth-fonts&quot;, m_state.shouldSmoothFonts);
 312 
 313     if (m_changeFlags &amp; GraphicsContextState::ShouldSubpixelQuantizeFontsChange)
 314         ts.dumpProperty(&quot;should-subpixel-quantize-fonts&quot;, m_state.shouldSubpixelQuantizeFonts);
 315 
 316     if (m_changeFlags &amp; GraphicsContextState::ShadowsIgnoreTransformsChange)
 317         ts.dumpProperty(&quot;shadows-ignore-transforms&quot;, m_state.shadowsIgnoreTransforms);
 318 
 319     if (m_changeFlags &amp; GraphicsContextState::DrawLuminanceMaskChange)
 320         ts.dumpProperty(&quot;draw-luminance-mask&quot;, m_state.drawLuminanceMask);
<a name="5" id="anc5"></a>




 321 }
 322 
 323 TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const GraphicsContextStateChange&amp; stateChange)
 324 {
 325     stateChange.dump(ts);
 326     return ts;
 327 }
 328 
 329 GraphicsContext::GraphicsContext(PaintInvalidationReasons paintInvalidationReasons)
 330     : m_paintInvalidationReasons(paintInvalidationReasons)
 331 {
 332 }
 333 
 334 GraphicsContext::GraphicsContext(PlatformGraphicsContext* platformGraphicsContext)
 335 {
 336     platformInit(platformGraphicsContext);
 337 }
 338 
 339 GraphicsContext::GraphicsContext(const GraphicsContextImplFactory&amp; factoryFunction)
 340     : m_impl(factoryFunction(*this))
 341 {
 342 }
 343 
 344 GraphicsContext::~GraphicsContext()
 345 {
 346     ASSERT(m_stack.isEmpty());
 347     ASSERT(!m_transparencyCount);
 348     platformDestroy();
 349 }
 350 
 351 bool GraphicsContext::hasPlatformContext() const
 352 {
 353     if (m_impl)
 354         return m_impl-&gt;hasPlatformContext();
 355     return !!m_data;
 356 }
 357 
 358 void GraphicsContext::save()
 359 {
 360     if (paintingDisabled())
 361         return;
 362 
 363     m_stack.append(m_state);
 364 
 365     if (m_impl) {
 366         m_impl-&gt;save();
 367         return;
 368     }
 369 
 370     savePlatformState();
 371 }
 372 
 373 void GraphicsContext::restore()
 374 {
 375     if (paintingDisabled())
 376         return;
 377 
 378     if (m_stack.isEmpty()) {
 379         LOG_ERROR(&quot;ERROR void GraphicsContext::restore() stack is empty&quot;);
 380         return;
 381     }
 382 
 383     m_state = m_stack.last();
 384     m_stack.removeLast();
 385 
 386     // Make sure we deallocate the state stack buffer when it goes empty.
 387     // Canvas elements will immediately save() again, but that goes into inline capacity.
 388     if (m_stack.isEmpty())
 389         m_stack.clear();
 390 
 391     if (m_impl) {
 392         m_impl-&gt;restore();
 393         return;
 394     }
 395 
 396     restorePlatformState();
 397 }
 398 
 399 void GraphicsContext::drawRaisedEllipse(const FloatRect&amp; rect, const Color&amp; ellipseColor, const Color&amp; shadowColor)
 400 {
 401     if (paintingDisabled())
 402         return;
 403 
 404     save();
 405 
 406     setStrokeColor(shadowColor);
 407     setFillColor(shadowColor);
 408 
 409     drawEllipse(FloatRect(rect.x(), rect.y() + 1, rect.width(), rect.height()));
 410 
 411     setStrokeColor(ellipseColor);
 412     setFillColor(ellipseColor);
 413 
 414     drawEllipse(rect);
 415 
 416     restore();
 417 }
 418 
 419 void GraphicsContext::setStrokeThickness(float thickness)
 420 {
 421     m_state.strokeThickness = thickness;
 422     if (m_impl) {
 423         m_impl-&gt;updateState(m_state, GraphicsContextState::StrokeThicknessChange);
 424         return;
 425     }
 426 
 427     setPlatformStrokeThickness(thickness);
 428 }
 429 
 430 void GraphicsContext::setStrokeStyle(StrokeStyle style)
 431 {
 432     m_state.strokeStyle = style;
 433     if (m_impl) {
 434         m_impl-&gt;updateState(m_state, GraphicsContextState::StrokeStyleChange);
 435         return;
 436     }
 437     setPlatformStrokeStyle(style);
 438 }
 439 
 440 void GraphicsContext::setStrokeColor(const Color&amp; color)
 441 {
 442     m_state.strokeColor = color;
 443     m_state.strokeGradient = nullptr;
 444     m_state.strokePattern = nullptr;
 445     if (m_impl) {
 446         m_impl-&gt;updateState(m_state, GraphicsContextState::StrokeColorChange);
 447         return;
 448     }
 449     setPlatformStrokeColor(color);
 450 }
 451 
 452 void GraphicsContext::setShadow(const FloatSize&amp; offset, float blur, const Color&amp; color)
 453 {
 454     m_state.shadowOffset = offset;
 455     m_state.shadowBlur = blur;
 456     m_state.shadowColor = color;
 457 #if USE(CG)
 458     m_state.shadowsUseLegacyRadius = false;
 459 #endif
 460     if (m_impl) {
 461         m_impl-&gt;updateState(m_state, GraphicsContextState::ShadowChange);
 462         return;
 463     }
 464     setPlatformShadow(offset, blur, color);
 465 }
 466 
 467 void GraphicsContext::setLegacyShadow(const FloatSize&amp; offset, float blur, const Color&amp; color)
 468 {
 469     m_state.shadowOffset = offset;
 470     m_state.shadowBlur = blur;
 471     m_state.shadowColor = color;
 472 #if USE(CG)
 473     m_state.shadowsUseLegacyRadius = true;
 474 #endif
 475     if (m_impl) {
 476         m_impl-&gt;updateState(m_state, GraphicsContextState::ShadowChange);
 477         return;
 478     }
 479     setPlatformShadow(offset, blur, color);
 480 }
 481 
 482 void GraphicsContext::clearShadow()
 483 {
 484     m_state.shadowOffset = FloatSize();
 485     m_state.shadowBlur = 0;
 486     m_state.shadowColor = Color();
 487 #if USE(CG)
 488     m_state.shadowsUseLegacyRadius = false;
 489 #endif
 490 
 491     if (m_impl) {
 492         m_impl-&gt;clearShadow();
 493         return;
 494     }
 495     clearPlatformShadow();
 496 }
 497 
 498 bool GraphicsContext::getShadow(FloatSize&amp; offset, float&amp; blur, Color&amp; color) const
 499 {
 500     offset = m_state.shadowOffset;
 501     blur = m_state.shadowBlur;
 502     color = m_state.shadowColor;
 503 
 504     return hasShadow();
 505 }
 506 
 507 void GraphicsContext::setFillColor(const Color&amp; color)
 508 {
 509     m_state.fillColor = color;
 510     m_state.fillGradient = nullptr;
 511     m_state.fillPattern = nullptr;
 512 
 513     if (m_impl) {
 514         m_impl-&gt;updateState(m_state, GraphicsContextState::FillColorChange);
 515         return;
 516     }
 517 
 518     setPlatformFillColor(color);
 519 }
 520 
 521 void GraphicsContext::setShadowsIgnoreTransforms(bool shadowsIgnoreTransforms)
 522 {
 523     m_state.shadowsIgnoreTransforms = shadowsIgnoreTransforms;
 524     if (m_impl)
 525         m_impl-&gt;updateState(m_state, GraphicsContextState::ShadowsIgnoreTransformsChange);
 526 }
 527 
 528 void GraphicsContext::setShouldAntialias(bool shouldAntialias)
 529 {
 530     m_state.shouldAntialias = shouldAntialias;
 531 
 532     if (m_impl) {
 533         m_impl-&gt;updateState(m_state, GraphicsContextState::ShouldAntialiasChange);
 534         return;
 535     }
 536 
 537     setPlatformShouldAntialias(shouldAntialias);
 538 }
 539 
 540 void GraphicsContext::setShouldSmoothFonts(bool shouldSmoothFonts)
 541 {
 542     m_state.shouldSmoothFonts = shouldSmoothFonts;
 543 
 544     if (m_impl) {
 545         m_impl-&gt;updateState(m_state, GraphicsContextState::ShouldSmoothFontsChange);
 546         return;
 547     }
 548 
 549     setPlatformShouldSmoothFonts(shouldSmoothFonts);
 550 }
 551 
 552 void GraphicsContext::setShouldSubpixelQuantizeFonts(bool shouldSubpixelQuantizeFonts)
 553 {
 554     m_state.shouldSubpixelQuantizeFonts = shouldSubpixelQuantizeFonts;
 555     if (m_impl)
 556         m_impl-&gt;updateState(m_state, GraphicsContextState::ShouldSubpixelQuantizeFontsChange);
 557 }
 558 
 559 void GraphicsContext::setImageInterpolationQuality(InterpolationQuality imageInterpolationQuality)
 560 {
 561     m_state.imageInterpolationQuality = imageInterpolationQuality;
 562 
 563     if (paintingDisabled())
 564         return;
 565 
 566     if (m_impl) {
 567         m_impl-&gt;updateState(m_state, GraphicsContextState::ImageInterpolationQualityChange);
 568         return;
 569     }
 570 
 571     setPlatformImageInterpolationQuality(imageInterpolationQuality);
 572 }
 573 
 574 void GraphicsContext::setStrokePattern(Ref&lt;Pattern&gt;&amp;&amp; pattern)
 575 {
 576     m_state.strokeGradient = nullptr;
 577     m_state.strokePattern = WTFMove(pattern);
 578     if (m_impl)
 579         m_impl-&gt;updateState(m_state, GraphicsContextState::StrokePatternChange);
 580 }
 581 
 582 void GraphicsContext::setFillPattern(Ref&lt;Pattern&gt;&amp;&amp; pattern)
 583 {
 584     m_state.fillGradient = nullptr;
 585     m_state.fillPattern = WTFMove(pattern);
 586     if (m_impl)
 587         m_impl-&gt;updateState(m_state, GraphicsContextState::FillPatternChange);
 588 }
 589 
 590 void GraphicsContext::setStrokeGradient(Ref&lt;Gradient&gt;&amp;&amp; gradient)
 591 {
 592     m_state.strokeGradient = WTFMove(gradient);
 593     m_state.strokePattern = nullptr;
 594     if (m_impl)
 595         m_impl-&gt;updateState(m_state, GraphicsContextState::StrokeGradientChange);
 596 }
 597 
 598 void GraphicsContext::setFillRule(WindRule fillRule)
 599 {
 600     m_state.fillRule = fillRule;
 601     if (m_impl)
 602         m_impl-&gt;updateState(m_state, GraphicsContextState::FillRuleChange);
 603 }
 604 
 605 void GraphicsContext::setFillGradient(Ref&lt;Gradient&gt;&amp;&amp; gradient)
 606 {
 607     m_state.fillGradient = WTFMove(gradient);
 608     m_state.fillPattern = nullptr;
 609     if (m_impl)
 610         m_impl-&gt;updateState(m_state, GraphicsContextState::FillGradientChange); // FIXME: also fill pattern?
 611 }
 612 
 613 void GraphicsContext::beginTransparencyLayer(float opacity)
 614 {
 615     if (m_impl) {
 616         m_impl-&gt;beginTransparencyLayer(opacity);
 617         return;
 618     }
 619     beginPlatformTransparencyLayer(opacity);
 620     ++m_transparencyCount;
 621 }
 622 
 623 void GraphicsContext::endTransparencyLayer()
 624 {
 625     if (m_impl) {
 626         m_impl-&gt;endTransparencyLayer();
 627         return;
 628     }
 629     endPlatformTransparencyLayer();
 630     ASSERT(m_transparencyCount &gt; 0);
 631     --m_transparencyCount;
 632 }
 633 
 634 float GraphicsContext::drawText(const FontCascade&amp; font, const TextRun&amp; run, const FloatPoint&amp; point, unsigned from, Optional&lt;unsigned&gt; to)
 635 {
 636     if (paintingDisabled())
 637         return 0;
 638 
 639     // Display list recording for text content is done at glyphs level. See GraphicsContext::drawGlyphs.
 640     return font.drawText(*this, run, point, from, to);
 641 }
 642 
 643 void GraphicsContext::drawGlyphs(const Font&amp; font, const GlyphBuffer&amp; buffer, unsigned from, unsigned numGlyphs, const FloatPoint&amp; point, FontSmoothingMode fontSmoothingMode)
 644 {
 645     if (paintingDisabled())
 646         return;
 647 
 648     if (m_impl) {
 649         m_impl-&gt;drawGlyphs(font, buffer, from, numGlyphs, point, fontSmoothingMode);
 650         return;
 651     }
 652 
 653     FontCascade::drawGlyphs(*this, font, buffer, from, numGlyphs, point, fontSmoothingMode);
 654 }
 655 
<a name="6" id="anc6"></a><span class="line-modified"> 656 void GraphicsContext::drawEmphasisMarks(const FontCascade&amp; font, const TextRun&amp; run, const AtomicString&amp; mark, const FloatPoint&amp; point, unsigned from, Optional&lt;unsigned&gt; to)</span>
 657 {
 658     if (paintingDisabled())
 659         return;
 660 
 661     font.drawEmphasisMarks(*this, run, mark, point, from, to);
 662 }
 663 
 664 void GraphicsContext::drawBidiText(const FontCascade&amp; font, const TextRun&amp; run, const FloatPoint&amp; point, FontCascade::CustomFontNotReadyAction customFontNotReadyAction)
 665 {
 666     if (paintingDisabled())
 667         return;
 668 
 669     BidiResolver&lt;TextRunIterator, BidiCharacterRun&gt; bidiResolver;
 670     bidiResolver.setStatus(BidiStatus(run.direction(), run.directionalOverride()));
 671     bidiResolver.setPositionIgnoringNestedIsolates(TextRunIterator(&amp;run, 0));
 672 
 673     // FIXME: This ownership should be reversed. We should pass BidiRunList
 674     // to BidiResolver in createBidiRunsForLine.
 675     BidiRunList&lt;BidiCharacterRun&gt;&amp; bidiRuns = bidiResolver.runs();
 676     bidiResolver.createBidiRunsForLine(TextRunIterator(&amp;run, run.length()));
 677 
 678     if (!bidiRuns.runCount())
 679         return;
 680 
 681     FloatPoint currPoint = point;
 682     BidiCharacterRun* bidiRun = bidiRuns.firstRun();
 683     while (bidiRun) {
 684         TextRun subrun = run.subRun(bidiRun-&gt;start(), bidiRun-&gt;stop() - bidiRun-&gt;start());
 685         bool isRTL = bidiRun-&gt;level() % 2;
 686         subrun.setDirection(isRTL ? TextDirection::RTL : TextDirection::LTR);
 687         subrun.setDirectionalOverride(bidiRun-&gt;dirOverride(false));
 688 
 689         float width = font.drawText(*this, subrun, currPoint, 0, WTF::nullopt, customFontNotReadyAction);
 690         currPoint.move(width, 0);
 691 
 692         bidiRun = bidiRun-&gt;next();
 693     }
 694 
 695     bidiRuns.clear();
 696 }
 697 
 698 ImageDrawResult GraphicsContext::drawImage(Image&amp; image, const FloatPoint&amp; destination, const ImagePaintingOptions&amp; imagePaintingOptions)
 699 {
 700     return drawImage(image, FloatRect(destination, image.size()), FloatRect(FloatPoint(), image.size()), imagePaintingOptions);
 701 }
 702 
 703 ImageDrawResult GraphicsContext::drawImage(Image&amp; image, const FloatRect&amp; destination, const ImagePaintingOptions&amp; imagePaintingOptions)
 704 {
<a name="7" id="anc7"></a><span class="line-removed"> 705 #if PLATFORM(IOS_FAMILY)</span>
<span class="line-removed"> 706     FloatRect srcRect(FloatPoint(), image.originalSize());</span>
<span class="line-removed"> 707 #else</span>
 708     FloatRect srcRect(FloatPoint(), image.size());
<a name="8" id="anc8"></a><span class="line-removed"> 709 #endif</span>
<span class="line-removed"> 710 </span>
 711     return drawImage(image, destination, srcRect, imagePaintingOptions);
 712 }
 713 
<a name="9" id="anc9"></a><span class="line-modified"> 714 ImageDrawResult GraphicsContext::drawImage(Image&amp; image, const FloatRect&amp; destination, const FloatRect&amp; source, const ImagePaintingOptions&amp; imagePaintingOptions)</span>
 715 {
 716     if (paintingDisabled())
 717         return ImageDrawResult::DidNothing;
 718 
 719     if (m_impl)
<a name="10" id="anc10"></a><span class="line-modified"> 720         return m_impl-&gt;drawImage(image, destination, source, imagePaintingOptions);</span>
 721 
<a name="11" id="anc11"></a><span class="line-modified"> 722     InterpolationQualityMaintainer interpolationQualityForThisScope(*this, imagePaintingOptions.m_interpolationQuality);</span>
<span class="line-modified"> 723     return image.draw(*this, destination, source, imagePaintingOptions.m_compositeOperator, imagePaintingOptions.m_blendMode, imagePaintingOptions.m_decodingMode, imagePaintingOptions.m_orientationDescription);</span>
 724 }
 725 
<a name="12" id="anc12"></a><span class="line-modified"> 726 ImageDrawResult GraphicsContext::drawTiledImage(Image&amp; image, const FloatRect&amp; destination, const FloatPoint&amp; source, const FloatSize&amp; tileSize, const FloatSize&amp; spacing, const ImagePaintingOptions&amp; imagePaintingOptions)</span>
 727 {
 728     if (paintingDisabled())
 729         return ImageDrawResult::DidNothing;
 730 
 731     if (m_impl)
<a name="13" id="anc13"></a><span class="line-modified"> 732         return m_impl-&gt;drawTiledImage(image, destination, source, tileSize, spacing, imagePaintingOptions);</span>
 733 
<a name="14" id="anc14"></a><span class="line-modified"> 734     InterpolationQualityMaintainer interpolationQualityForThisScope(*this, imagePaintingOptions.m_interpolationQuality);</span>
<span class="line-modified"> 735     return image.drawTiled(*this, destination, source, tileSize, spacing, imagePaintingOptions.m_compositeOperator, imagePaintingOptions.m_blendMode, imagePaintingOptions.m_decodingMode);</span>
 736 }
 737 
 738 ImageDrawResult GraphicsContext::drawTiledImage(Image&amp; image, const FloatRect&amp; destination, const FloatRect&amp; source, const FloatSize&amp; tileScaleFactor,
<a name="15" id="anc15"></a><span class="line-modified"> 739     Image::TileRule hRule, Image::TileRule vRule, const ImagePaintingOptions&amp; imagePaintingOptions)</span>
 740 {
 741     if (paintingDisabled())
 742         return ImageDrawResult::DidNothing;
 743 
 744     if (m_impl)
<a name="16" id="anc16"></a><span class="line-modified"> 745         return m_impl-&gt;drawTiledImage(image, destination, source, tileScaleFactor, hRule, vRule, imagePaintingOptions);</span>
 746 
 747     if (hRule == Image::StretchTile &amp;&amp; vRule == Image::StretchTile) {
 748         // Just do a scale.
<a name="17" id="anc17"></a><span class="line-modified"> 749         return drawImage(image, destination, source, imagePaintingOptions);</span>
 750     }
 751 
<a name="18" id="anc18"></a><span class="line-modified"> 752     InterpolationQualityMaintainer interpolationQualityForThisScope(*this, imagePaintingOptions.m_interpolationQuality);</span>
<span class="line-modified"> 753     return image.drawTiled(*this, destination, source, tileScaleFactor, hRule, vRule, imagePaintingOptions.m_compositeOperator);</span>
 754 }
 755 
 756 void GraphicsContext::drawImageBuffer(ImageBuffer&amp; image, const FloatPoint&amp; destination, const ImagePaintingOptions&amp; imagePaintingOptions)
 757 {
 758     drawImageBuffer(image, FloatRect(destination, image.logicalSize()), FloatRect(FloatPoint(), image.logicalSize()), imagePaintingOptions);
 759 }
 760 
 761 void GraphicsContext::drawImageBuffer(ImageBuffer&amp; image, const FloatRect&amp; destination, const ImagePaintingOptions&amp; imagePaintingOptions)
 762 {
 763     drawImageBuffer(image, destination, FloatRect(FloatPoint(), FloatSize(image.logicalSize())), imagePaintingOptions);
 764 }
 765 
<a name="19" id="anc19"></a><span class="line-modified"> 766 void GraphicsContext::drawImageBuffer(ImageBuffer&amp; image, const FloatRect&amp; destination, const FloatRect&amp; source, const ImagePaintingOptions&amp; imagePaintingOptions)</span>
 767 {
 768     if (paintingDisabled())
 769         return;
 770 
<a name="20" id="anc20"></a><span class="line-modified"> 771     InterpolationQualityMaintainer interpolationQualityForThisScope(*this, imagePaintingOptions.m_interpolationQuality);</span>
<span class="line-modified"> 772     image.draw(*this, destination, source, imagePaintingOptions.m_compositeOperator, imagePaintingOptions.m_blendMode);</span>
 773 }
 774 
 775 void GraphicsContext::drawConsumingImageBuffer(std::unique_ptr&lt;ImageBuffer&gt; image, const FloatPoint&amp; destination, const ImagePaintingOptions&amp; imagePaintingOptions)
 776 {
 777     if (!image)
 778         return;
 779     IntSize imageLogicalSize = image-&gt;logicalSize();
 780     drawConsumingImageBuffer(WTFMove(image), FloatRect(destination, imageLogicalSize), FloatRect(FloatPoint(), imageLogicalSize), imagePaintingOptions);
 781 }
 782 
 783 void GraphicsContext::drawConsumingImageBuffer(std::unique_ptr&lt;ImageBuffer&gt; image, const FloatRect&amp; destination, const ImagePaintingOptions&amp; imagePaintingOptions)
 784 {
 785     if (!image)
 786         return;
 787     IntSize imageLogicalSize = image-&gt;logicalSize();
 788     drawConsumingImageBuffer(WTFMove(image), destination, FloatRect(FloatPoint(), FloatSize(imageLogicalSize)), imagePaintingOptions);
 789 }
 790 
<a name="21" id="anc21"></a><span class="line-modified"> 791 void GraphicsContext::drawConsumingImageBuffer(std::unique_ptr&lt;ImageBuffer&gt; image, const FloatRect&amp; destination, const FloatRect&amp; source, const ImagePaintingOptions&amp; imagePaintingOptions)</span>
 792 {
 793     if (paintingDisabled() || !image)
 794         return;
 795 
<a name="22" id="anc22"></a><span class="line-modified"> 796     InterpolationQualityMaintainer interpolationQualityForThisScope(*this, imagePaintingOptions.m_interpolationQuality);</span>
<span class="line-modified"> 797     ImageBuffer::drawConsuming(WTFMove(image), *this, destination, source, imagePaintingOptions.m_compositeOperator, imagePaintingOptions.m_blendMode);</span>
 798 }
 799 
 800 void GraphicsContext::clipRoundedRect(const FloatRoundedRect&amp; rect)
 801 {
 802     if (paintingDisabled())
 803         return;
 804 
 805     Path path;
 806     path.addRoundedRect(rect);
 807     clipPath(path);
 808 }
 809 
 810 void GraphicsContext::clipOutRoundedRect(const FloatRoundedRect&amp; rect)
 811 {
 812     if (paintingDisabled())
 813         return;
 814 
 815     if (!rect.isRounded()) {
 816         clipOut(rect.rect());
 817         return;
 818     }
 819 
 820     Path path;
 821     path.addRoundedRect(rect);
 822     clipOut(path);
 823 }
 824 
 825 #if !USE(CG) &amp;&amp; !USE(DIRECT2D) &amp;&amp; !USE(CAIRO) &amp;&amp; !PLATFORM(JAVA)
 826 IntRect GraphicsContext::clipBounds() const
 827 {
 828     ASSERT_NOT_REACHED();
 829     return IntRect();
 830 }
 831 #endif
 832 
 833 void GraphicsContext::setTextDrawingMode(TextDrawingModeFlags mode)
 834 {
 835     m_state.textDrawingMode = mode;
 836     if (paintingDisabled())
 837         return;
 838 
 839     if (m_impl) {
 840         m_impl-&gt;updateState(m_state, GraphicsContextState::TextDrawingModeChange);
 841         return;
 842     }
 843     setPlatformTextDrawingMode(mode);
 844 }
 845 
 846 void GraphicsContext::fillRect(const FloatRect&amp; rect, Gradient&amp; gradient)
 847 {
 848     if (paintingDisabled())
 849         return;
 850 
 851     if (m_impl) {
 852         m_impl-&gt;fillRect(rect, gradient);
 853         return;
 854     }
 855 
 856     gradient.fill(*this, rect);
 857 }
 858 
 859 void GraphicsContext::fillRect(const FloatRect&amp; rect, const Color&amp; color, CompositeOperator op, BlendMode blendMode)
 860 {
 861     if (paintingDisabled())
 862         return;
 863 
 864     if (m_impl) {
 865         m_impl-&gt;fillRect(rect, color, op, blendMode);
 866         return;
 867     }
 868 
 869     CompositeOperator previousOperator = compositeOperation();
 870     setCompositeOperation(op, blendMode);
 871     fillRect(rect, color);
 872     setCompositeOperation(previousOperator);
 873 }
 874 
 875 #if !PLATFORM(JAVA) // FIXME-java: recheck
 876 void GraphicsContext::fillRoundedRect(const FloatRoundedRect&amp; rect, const Color&amp; color, BlendMode blendMode)
 877 {
 878     if (paintingDisabled())
 879         return;
 880 
 881     if (m_impl) {
 882         m_impl-&gt;fillRoundedRect(rect, color, blendMode);
 883         return;
 884     }
 885 
 886     if (rect.isRounded()) {
 887         setCompositeOperation(compositeOperation(), blendMode);
 888         platformFillRoundedRect(rect, color);
 889         setCompositeOperation(compositeOperation());
 890     } else
 891         fillRect(rect.rect(), color, compositeOperation(), blendMode);
 892 }
 893 #endif
 894 
 895 #if !USE(CG) &amp;&amp; !USE(DIRECT2D) &amp;&amp; !USE(CAIRO) &amp;&amp; !PLATFORM(JAVA)
 896 void GraphicsContext::fillRectWithRoundedHole(const IntRect&amp; rect, const FloatRoundedRect&amp; roundedHoleRect, const Color&amp; color)
 897 {
 898     if (paintingDisabled())
 899         return;
 900 
 901     Path path;
 902     path.addRect(rect);
 903 
 904     if (!roundedHoleRect.radii().isZero())
 905         path.addRoundedRect(roundedHoleRect);
 906     else
 907         path.addRect(roundedHoleRect.rect());
 908 
 909     WindRule oldFillRule = fillRule();
 910     Color oldFillColor = fillColor();
 911 
 912     setFillRule(WindRule::EvenOdd);
 913     setFillColor(color);
 914 
 915     fillPath(path);
 916 
 917     setFillRule(oldFillRule);
 918     setFillColor(oldFillColor);
 919 }
 920 #endif
 921 
 922 void GraphicsContext::setAlpha(float alpha)
 923 {
 924     m_state.alpha = alpha;
 925     if (m_impl) {
 926         m_impl-&gt;updateState(m_state, GraphicsContextState::AlphaChange);
 927         return;
 928     }
 929     setPlatformAlpha(alpha);
 930 }
 931 
 932 void GraphicsContext::setCompositeOperation(CompositeOperator compositeOperation, BlendMode blendMode)
 933 {
 934     m_state.compositeOperator = compositeOperation;
 935     m_state.blendMode = blendMode;
 936     if (m_impl) {
 937         m_impl-&gt;updateState(m_state, GraphicsContextState::CompositeOperationChange);
 938         return;
 939     }
 940     setPlatformCompositeOperation(compositeOperation, blendMode);
 941 }
 942 
 943 void GraphicsContext::setDrawLuminanceMask(bool drawLuminanceMask)
 944 {
 945     m_state.drawLuminanceMask = drawLuminanceMask;
 946     if (m_impl)
 947         m_impl-&gt;updateState(m_state, GraphicsContextState::DrawLuminanceMaskChange);
 948 }
 949 
<a name="23" id="anc23"></a>








 950 #if !USE(CG) &amp;&amp; !USE(DIRECT2D) &amp;&amp; !PLATFORM(JAVA)
 951 // Implement this if you want to go push the drawing mode into your native context immediately.
 952 void GraphicsContext::setPlatformTextDrawingMode(TextDrawingModeFlags)
 953 {
 954 }
 955 #endif
 956 
 957 #if !USE(CAIRO) &amp;&amp; !USE(DIRECT2D) &amp;&amp; !PLATFORM(JAVA)
 958 void GraphicsContext::setPlatformStrokeStyle(StrokeStyle)
 959 {
 960 }
 961 #endif
 962 
 963 #if !USE(CG) &amp;&amp; !USE(DIRECT2D)
 964 void GraphicsContext::setPlatformShouldSmoothFonts(bool)
 965 {
 966 }
 967 #endif
 968 
 969 #if !USE(CG) &amp;&amp; !USE(DIRECT2D) &amp;&amp; !USE(CAIRO)
 970 bool GraphicsContext::isAcceleratedContext() const
 971 {
 972     return false;
 973 }
 974 #endif
 975 
 976 void GraphicsContext::adjustLineToPixelBoundaries(FloatPoint&amp; p1, FloatPoint&amp; p2, float strokeWidth, StrokeStyle penStyle)
 977 {
 978     // For odd widths, we add in 0.5 to the appropriate x/y so that the float arithmetic
 979     // works out.  For example, with a border width of 3, WebKit will pass us (y1+y2)/2, e.g.,
 980     // (50+53)/2 = 103/2 = 51 when we want 51.5.  It is always true that an even width gave
 981     // us a perfect position, but an odd width gave us a position that is off by exactly 0.5.
 982     if (penStyle == DottedStroke || penStyle == DashedStroke) {
 983         if (p1.x() == p2.x()) {
 984             p1.setY(p1.y() + strokeWidth);
 985             p2.setY(p2.y() - strokeWidth);
 986         } else {
 987             p1.setX(p1.x() + strokeWidth);
 988             p2.setX(p2.x() - strokeWidth);
 989         }
 990     }
 991 
 992     if (static_cast&lt;int&gt;(strokeWidth) % 2) { //odd
 993         if (p1.x() == p2.x()) {
 994             // We&#39;re a vertical line.  Adjust our x.
 995             p1.setX(p1.x() + 0.5f);
 996             p2.setX(p2.x() + 0.5f);
 997         } else {
 998             // We&#39;re a horizontal line. Adjust our y.
 999             p1.setY(p1.y() + 0.5f);
1000             p2.setY(p2.y() + 0.5f);
1001         }
1002     }
1003 }
1004 
1005 #if !USE(CG) &amp;&amp; !USE(DIRECT2D)
1006 void GraphicsContext::platformApplyDeviceScaleFactor(float)
1007 {
1008 }
1009 #endif
1010 
1011 void GraphicsContext::applyDeviceScaleFactor(float deviceScaleFactor)
1012 {
1013     scale(deviceScaleFactor);
1014 
1015     if (m_impl) {
1016         m_impl-&gt;applyDeviceScaleFactor(deviceScaleFactor);
1017         return;
1018     }
1019 
1020     platformApplyDeviceScaleFactor(deviceScaleFactor);
1021 }
1022 
1023 FloatSize GraphicsContext::scaleFactor() const
1024 {
1025     AffineTransform transform = getCTM(GraphicsContext::DefinitelyIncludeDeviceScale);
1026     return FloatSize(transform.xScale(), transform.yScale());
1027 }
1028 
1029 FloatSize GraphicsContext::scaleFactorForDrawing(const FloatRect&amp; destRect, const FloatRect&amp; srcRect) const
1030 {
1031     AffineTransform transform = getCTM(GraphicsContext::DefinitelyIncludeDeviceScale);
1032     auto transformedDestRect = transform.mapRect(destRect);
1033     return transformedDestRect.size() / srcRect.size();
1034 }
1035 
1036 void GraphicsContext::fillEllipse(const FloatRect&amp; ellipse)
1037 {
1038     if (m_impl) {
1039         m_impl-&gt;fillEllipse(ellipse);
1040         return;
1041     }
1042 
1043     platformFillEllipse(ellipse);
1044 }
1045 
1046 void GraphicsContext::strokeEllipse(const FloatRect&amp; ellipse)
1047 {
1048     if (m_impl) {
1049         m_impl-&gt;strokeEllipse(ellipse);
1050         return;
1051     }
1052 
1053     platformStrokeEllipse(ellipse);
1054 }
1055 
1056 void GraphicsContext::fillEllipseAsPath(const FloatRect&amp; ellipse)
1057 {
1058     Path path;
1059     path.addEllipse(ellipse);
1060     fillPath(path);
1061 }
1062 
1063 void GraphicsContext::strokeEllipseAsPath(const FloatRect&amp; ellipse)
1064 {
1065     Path path;
1066     path.addEllipse(ellipse);
1067     strokePath(path);
1068 }
1069 
1070 #if !USE(CG) &amp;&amp; !USE(DIRECT2D)
1071 void GraphicsContext::platformFillEllipse(const FloatRect&amp; ellipse)
1072 {
1073     if (paintingDisabled())
1074         return;
1075 
1076     fillEllipseAsPath(ellipse);
1077 }
1078 
1079 void GraphicsContext::platformStrokeEllipse(const FloatRect&amp; ellipse)
1080 {
1081     if (paintingDisabled())
1082         return;
1083 
1084     strokeEllipseAsPath(ellipse);
1085 }
1086 #endif
1087 
1088 FloatRect GraphicsContext::computeUnderlineBoundsForText(const FloatRect&amp; rect, bool printing)
1089 {
1090     Color dummyColor;
1091     return computeLineBoundsAndAntialiasingModeForText(rect, printing, dummyColor);
1092 }
1093 
1094 FloatRect GraphicsContext::computeLineBoundsAndAntialiasingModeForText(const FloatRect&amp; rect, bool printing, Color&amp; color)
1095 {
1096     FloatPoint origin = rect.location();
1097     float thickness = std::max(rect.height(), 0.5f);
1098     if (printing)
1099         return FloatRect(origin, FloatSize(rect.width(), thickness));
1100 
1101     AffineTransform transform = getCTM(GraphicsContext::DefinitelyIncludeDeviceScale);
1102     // Just compute scale in x dimension, assuming x and y scales are equal.
1103     float scale = transform.b() ? sqrtf(transform.a() * transform.a() + transform.b() * transform.b()) : transform.a();
1104     if (scale &lt; 1.0) {
1105         // This code always draws a line that is at least one-pixel line high,
1106         // which tends to visually overwhelm text at small scales. To counter this
1107         // effect, an alpha is applied to the underline color when text is at small scales.
1108         static const float minimumUnderlineAlpha = 0.4f;
1109         float shade = scale &gt; minimumUnderlineAlpha ? scale : minimumUnderlineAlpha;
1110         color = color.colorWithAlphaMultipliedBy(shade);
1111     }
1112 
1113     FloatPoint devicePoint = transform.mapPoint(rect.location());
1114     // Visual overflow might occur here due to integral roundf/ceilf. visualOverflowForDecorations adjusts the overflow value for underline decoration.
1115     FloatPoint deviceOrigin = FloatPoint(roundf(devicePoint.x()), ceilf(devicePoint.y()));
1116     if (auto inverse = transform.inverse())
1117         origin = inverse.value().mapPoint(deviceOrigin);
1118     return FloatRect(origin, FloatSize(rect.width(), thickness));
1119 }
1120 
1121 void GraphicsContext::applyState(const GraphicsContextState&amp; state)
1122 {
1123     setPlatformShadow(state.shadowOffset, state.shadowBlur, state.shadowColor);
1124     setPlatformStrokeThickness(state.strokeThickness);
1125     setPlatformTextDrawingMode(state.textDrawingMode);
1126     setPlatformStrokeColor(state.strokeColor);
1127     setPlatformFillColor(state.fillColor);
1128     setPlatformStrokeStyle(state.strokeStyle);
1129     setPlatformAlpha(state.alpha);
1130     setPlatformCompositeOperation(state.compositeOperator, state.blendMode);
1131     setPlatformShouldAntialias(state.shouldAntialias);
1132     setPlatformShouldSmoothFonts(state.shouldSmoothFonts);
1133 }
1134 
1135 float GraphicsContext::dashedLineCornerWidthForStrokeWidth(float strokeWidth) const
1136 {
1137     float thickness = strokeThickness();
1138     return strokeStyle() == DottedStroke ? thickness : std::min(2.0f * thickness, std::max(thickness, strokeWidth / 3.0f));
1139 }
1140 
1141 float GraphicsContext::dashedLinePatternWidthForStrokeWidth(float strokeWidth) const
1142 {
1143     float thickness = strokeThickness();
1144     return strokeStyle() == DottedStroke ? thickness : std::min(3.0f * thickness, std::max(thickness, strokeWidth / 3.0f));
1145 }
1146 
1147 float GraphicsContext::dashedLinePatternOffsetForPatternAndStrokeWidth(float patternWidth, float strokeWidth) const
1148 {
1149     // Pattern starts with full fill and ends with the empty fill.
1150     // 1. Let&#39;s start with the empty phase after the corner.
1151     // 2. Check if we&#39;ve got odd or even number of patterns and whether they fully cover the line.
1152     // 3. In case of even number of patterns and/or remainder, move the pattern start position
1153     // so that the pattern is balanced between the corners.
1154     float patternOffset = patternWidth;
1155     int numberOfSegments = std::floor(strokeWidth / patternWidth);
1156     bool oddNumberOfSegments = numberOfSegments % 2;
1157     float remainder = strokeWidth - (numberOfSegments * patternWidth);
1158     if (oddNumberOfSegments &amp;&amp; remainder)
1159         patternOffset -= remainder / 2.0f;
1160     else if (!oddNumberOfSegments) {
1161         if (remainder)
1162             patternOffset += patternOffset - (patternWidth + remainder) / 2.0f;
1163         else
1164             patternOffset += patternWidth / 2.0f;
1165     }
1166 
1167     return patternOffset;
1168 }
1169 
1170 Vector&lt;FloatPoint&gt; GraphicsContext::centerLineAndCutOffCorners(bool isVerticalLine, float cornerWidth, FloatPoint point1, FloatPoint point2) const
1171 {
1172     // Center line and cut off corners for pattern painting.
1173     if (isVerticalLine) {
1174         float centerOffset = (point2.x() - point1.x()) / 2.0f;
1175         point1.move(centerOffset, cornerWidth);
1176         point2.move(-centerOffset, -cornerWidth);
1177     } else {
1178         float centerOffset = (point2.y() - point1.y()) / 2.0f;
1179         point1.move(cornerWidth, centerOffset);
1180         point2.move(-cornerWidth, -centerOffset);
1181     }
1182 
1183     return { point1, point2 };
1184 }
1185 
1186 #if !USE(CG)
1187 bool GraphicsContext::supportsInternalLinks() const
1188 {
1189     return false;
1190 }
1191 
1192 void GraphicsContext::setDestinationForRect(const String&amp;, const FloatRect&amp;)
1193 {
1194 }
1195 
1196 void GraphicsContext::addDestinationAtPoint(const String&amp;, const FloatPoint&amp;)
1197 {
1198 }
1199 #endif
1200 
1201 }
<a name="24" id="anc24"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="24" type="hidden" />
</body>
</html>