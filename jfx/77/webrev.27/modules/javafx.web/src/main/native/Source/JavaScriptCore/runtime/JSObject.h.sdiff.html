<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSObject.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="JSObject.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="JSObjectInlines.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSObject.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
   2  *  Copyright (C) 1999-2001 Harri Porten (porten@kde.org)
   3  *  Copyright (C) 2001 Peter Kelly (pmk@post.com)
<span class="line-modified">   4  *  Copyright (C) 2003-2018 Apple Inc. All rights reserved.</span>
   5  *
   6  *  This library is free software; you can redistribute it and/or
   7  *  modify it under the terms of the GNU Library General Public
   8  *  License as published by the Free Software Foundation; either
   9  *  version 2 of the License, or (at your option) any later version.
  10  *
  11  *  This library is distributed in the hope that it will be useful,
  12  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  13  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  14  *  Library General Public License for more details.
  15  *
  16  *  You should have received a copy of the GNU Library General Public License
  17  *  along with this library; see the file COPYING.LIB.  If not, write to
  18  *  the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  19  *  Boston, MA 02110-1301, USA.
  20  *
  21  */
  22 
  23 #pragma once
  24 
</pre>
<hr />
<pre>
  41 #include &quot;PutPropertySlot.h&quot;
  42 #include &quot;Structure.h&quot;
  43 #include &quot;StructureTransitionTable.h&quot;
  44 #include &quot;VM.h&quot;
  45 #include &quot;JSString.h&quot;
  46 #include &quot;SparseArrayValueMap.h&quot;
  47 #include &lt;wtf/StdLibExtras.h&gt;
  48 
  49 namespace JSC {
  50 namespace DOMJIT {
  51 class Signature;
  52 }
  53 
  54 inline JSCell* getJSFunction(JSValue value)
  55 {
  56     if (value.isCell() &amp;&amp; (value.asCell()-&gt;type() == JSFunctionType))
  57         return value.asCell();
  58     return 0;
  59 }
  60 

  61 class GetterSetter;
  62 class InternalFunction;
  63 class JSFunction;
  64 class LLIntOffsetsExtractor;
  65 class MarkedBlock;
  66 class PropertyDescriptor;
  67 class PropertyNameArray;
  68 class Structure;
  69 class ThrowScope;
  70 struct HashTable;
  71 struct HashTableValue;
  72 
<span class="line-modified">  73 JS_EXPORT_PRIVATE JSObject* throwTypeError(ExecState*, ThrowScope&amp;, const String&amp;);</span>
  74 extern JS_EXPORT_PRIVATE const ASCIILiteral NonExtensibleObjectPropertyDefineError;
  75 extern JS_EXPORT_PRIVATE const ASCIILiteral ReadonlyPropertyWriteError;
  76 extern JS_EXPORT_PRIVATE const ASCIILiteral ReadonlyPropertyChangeError;
  77 extern JS_EXPORT_PRIVATE const ASCIILiteral UnableToDeletePropertyError;
  78 extern JS_EXPORT_PRIVATE const ASCIILiteral UnconfigurablePropertyChangeAccessMechanismError;
  79 extern JS_EXPORT_PRIVATE const ASCIILiteral UnconfigurablePropertyChangeConfigurabilityError;
  80 extern JS_EXPORT_PRIVATE const ASCIILiteral UnconfigurablePropertyChangeEnumerabilityError;
  81 extern JS_EXPORT_PRIVATE const ASCIILiteral UnconfigurablePropertyChangeWritabilityError;
  82 
  83 COMPILE_ASSERT(PropertyAttribute::None &lt; FirstInternalAttribute, None_is_below_FirstInternalAttribute);
  84 COMPILE_ASSERT(PropertyAttribute::ReadOnly &lt; FirstInternalAttribute, ReadOnly_is_below_FirstInternalAttribute);
  85 COMPILE_ASSERT(PropertyAttribute::DontEnum &lt; FirstInternalAttribute, DontEnum_is_below_FirstInternalAttribute);
  86 COMPILE_ASSERT(PropertyAttribute::DontDelete &lt; FirstInternalAttribute, DontDelete_is_below_FirstInternalAttribute);
  87 COMPILE_ASSERT(PropertyAttribute::Accessor &lt; FirstInternalAttribute, Accessor_is_below_FirstInternalAttribute);
  88 
  89 class JSFinalObject;
  90 
  91 class JSObject : public JSCell {
  92     friend class BatchedTransitionOptimizer;
  93     friend class JIT;
  94     friend class JSCell;
  95     friend class JSFinalObject;
  96     friend class MarkedBlock;
  97     JS_EXPORT_PRIVATE friend bool setUpStaticFunctionSlot(VM&amp;, const HashTableValue*, JSObject*, PropertyName, PropertySlot&amp;);
  98 
  99     enum PutMode {
 100         PutModePut,
 101         PutModeDefineOwnProperty,
 102     };
 103 
 104 public:
 105     typedef JSCell Base;
 106 
 107     // This is a super dangerous method for JITs. Sometimes the JITs will want to create either a
 108     // JSFinalObject or a JSArray. This is the method that will do that.
 109     static JSObject* createRawObject(ExecState* exec, Structure* structure, Butterfly* = nullptr);
 110 
 111     JS_EXPORT_PRIVATE static size_t estimatedSize(JSCell*, VM&amp;);
 112     JS_EXPORT_PRIVATE static void visitChildren(JSCell*, SlotVisitor&amp;);
<span class="line-modified"> 113     JS_EXPORT_PRIVATE static void heapSnapshot(JSCell*, HeapSnapshotBuilder&amp;);</span>
 114 
 115     JS_EXPORT_PRIVATE static String className(const JSObject*, VM&amp;);
 116     JS_EXPORT_PRIVATE static String calculatedClassName(JSObject*);
 117 
 118     // This function is what Object.prototype.toString() will use to get the name of
 119     // an object when using Symbol.toStringTag fails. For the most part there is no
 120     // difference between this and className(). The main use case is for new JS language
 121     // objects to set the default tag to &quot;Object&quot;.
 122     JS_EXPORT_PRIVATE static String toStringName(const JSObject*, ExecState*);
 123 
 124     // This is the fully virtual [[GetPrototypeOf]] internal function defined
 125     // in the ECMAScript 6 specification. Use this when doing a [[GetPrototypeOf]]
 126     // operation as dictated in the specification.
 127     JSValue getPrototype(VM&amp;, ExecState*);
 128     JS_EXPORT_PRIVATE static JSValue getPrototype(JSObject*, ExecState*);
 129     // This gets the prototype directly off of the structure. This does not do
 130     // dynamic dispatch on the getPrototype method table method. It is not valid
 131     // to use this when performing a [[GetPrototypeOf]] operation in the specification.
 132     // It is valid to use though when you know that you want to directly get it
 133     // without consulting the method table. This is akin to getting the [[Prototype]]
</pre>
<hr />
<pre>
 150     // This is the fully virtual [[SetPrototypeOf]] internal function defined
 151     // in the ECMAScript 6 specification. Use this when doing a [[SetPrototypeOf]]
 152     // operation as dictated in the specification.
 153     bool setPrototype(VM&amp;, ExecState*, JSValue prototype, bool shouldThrowIfCantSet = false);
 154     JS_EXPORT_PRIVATE static bool setPrototype(JSObject*, ExecState*, JSValue prototype, bool shouldThrowIfCantSet);
 155 
 156     inline bool mayInterceptIndexedAccesses(VM&amp;);
 157 
 158     JSValue get(ExecState*, PropertyName) const;
 159     JSValue get(ExecState*, unsigned propertyName) const;
 160 
 161     template&lt;bool checkNullStructure = false&gt;
 162     bool getPropertySlot(ExecState*, PropertyName, PropertySlot&amp;);
 163     bool getPropertySlot(ExecState*, unsigned propertyName, PropertySlot&amp;);
 164     template&lt;typename CallbackWhenNoException&gt; typename std::result_of&lt;CallbackWhenNoException(bool, PropertySlot&amp;)&gt;::type getPropertySlot(ExecState*, PropertyName, CallbackWhenNoException) const;
 165     template&lt;typename CallbackWhenNoException&gt; typename std::result_of&lt;CallbackWhenNoException(bool, PropertySlot&amp;)&gt;::type getPropertySlot(ExecState*, PropertyName, PropertySlot&amp;, CallbackWhenNoException) const;
 166 
 167     static bool getOwnPropertySlot(JSObject*, ExecState*, PropertyName, PropertySlot&amp;);
 168     JS_EXPORT_PRIVATE static bool getOwnPropertySlotByIndex(JSObject*, ExecState*, unsigned propertyName, PropertySlot&amp;);
 169     bool getOwnPropertySlotInline(ExecState*, PropertyName, PropertySlot&amp;);

 170 
 171     // The key difference between this and getOwnPropertySlot is that getOwnPropertySlot
 172     // currently returns incorrect results for the DOM window (with non-own properties)
 173     // being returned. Once this is fixed we should migrate code &amp; remove this method.
 174     JS_EXPORT_PRIVATE bool getOwnPropertyDescriptor(ExecState*, PropertyName, PropertyDescriptor&amp;);
 175 
 176     unsigned getArrayLength() const
 177     {
 178         if (!hasIndexedProperties(indexingType()))
 179             return 0;
 180         return m_butterfly-&gt;publicLength();
 181     }
 182 
 183     unsigned getVectorLength()
 184     {
 185         if (!hasIndexedProperties(indexingType()))
 186             return 0;
 187         return m_butterfly-&gt;vectorLength();
 188     }
 189 
 190     static bool putInlineForJSObject(JSCell*, ExecState*, PropertyName, JSValue, PutPropertySlot&amp;);
 191 
 192     JS_EXPORT_PRIVATE static bool put(JSCell*, ExecState*, PropertyName, JSValue, PutPropertySlot&amp;);
 193     // putByIndex assumes that the receiver is this JSCell object.
 194     JS_EXPORT_PRIVATE static bool putByIndex(JSCell*, ExecState*, unsigned propertyName, JSValue, bool shouldThrow);
 195 
 196     // This performs the ECMAScript Set() operation.
 197     ALWAYS_INLINE bool putByIndexInline(ExecState* exec, unsigned propertyName, JSValue value, bool shouldThrow)
 198     {
<span class="line-modified"> 199         if (canSetIndexQuickly(propertyName)) {</span>
<span class="line-modified"> 200             setIndexQuickly(exec-&gt;vm(), propertyName, value);</span>

 201             return true;
 202         }
<span class="line-modified"> 203         return methodTable(exec-&gt;vm())-&gt;putByIndex(this, exec, propertyName, value, shouldThrow);</span>
 204     }
 205 
 206     // This is similar to the putDirect* methods:
 207     //  - the prototype chain is not consulted
 208     //  - accessors are not called.
 209     //  - it will ignore extensibility and read-only properties if PutDirectIndexLikePutDirect is passed as the mode (the default).
 210     // This method creates a property with attributes writable, enumerable and configurable all set to true if attributes is zero,
 211     // otherwise, it creates a property with the provided attributes. Semantically, this is performing defineOwnProperty.
 212     bool putDirectIndex(ExecState* exec, unsigned propertyName, JSValue value, unsigned attributes, PutDirectIndexMode mode)
 213     {
 214         ASSERT(!value.isCustomGetterSetter());
 215         auto canSetIndexQuicklyForPutDirect = [&amp;] () -&gt; bool {
 216             switch (indexingMode()) {
 217             case ALL_BLANK_INDEXING_TYPES:
 218             case ALL_UNDECIDED_INDEXING_TYPES:
 219                 return false;
 220             case ALL_WRITABLE_INT32_INDEXING_TYPES:
 221             case ALL_WRITABLE_DOUBLE_INDEXING_TYPES:
 222             case ALL_WRITABLE_CONTIGUOUS_INDEXING_TYPES:
 223             case ALL_ARRAY_STORAGE_INDEXING_TYPES:
</pre>
<hr />
<pre>
 238     }
 239     // This is semantically equivalent to performing defineOwnProperty(propertyName, {configurable:true, writable:true, enumerable:true, value:value}).
 240     bool putDirectIndex(ExecState* exec, unsigned propertyName, JSValue value)
 241     {
 242         return putDirectIndex(exec, propertyName, value, 0, PutDirectIndexLikePutDirect);
 243     }
 244 
 245     // A generally non-throwing version of putDirect and putDirectIndex.
 246     // However, it&#39;s only guaranteed to not throw based on what the receiver is.
 247     // For example, if the receiver is a ProxyObject, this is not guaranteed, since
 248     // it may call into arbitrary JS code. It&#39;s the responsibility of the user of
 249     // this API to ensure that the receiver object is a well known type if they
 250     // want to ensure that this won&#39;t throw an exception.
 251     JS_EXPORT_PRIVATE bool putDirectMayBeIndex(ExecState*, PropertyName, JSValue);
 252 
 253     bool hasIndexingHeader(VM&amp; vm) const
 254     {
 255         return structure(vm)-&gt;hasIndexingHeader(this);
 256     }
 257 
<span class="line-modified"> 258     bool canGetIndexQuickly(unsigned i)</span>



 259     {
<span class="line-modified"> 260         Butterfly* butterfly = this-&gt;butterfly();</span>
 261         switch (indexingType()) {
 262         case ALL_BLANK_INDEXING_TYPES:

 263         case ALL_UNDECIDED_INDEXING_TYPES:
 264             return false;
 265         case ALL_INT32_INDEXING_TYPES:
 266         case ALL_CONTIGUOUS_INDEXING_TYPES:
 267             return i &lt; butterfly-&gt;vectorLength() &amp;&amp; butterfly-&gt;contiguous().at(this, i);
 268         case ALL_DOUBLE_INDEXING_TYPES: {
 269             if (i &gt;= butterfly-&gt;vectorLength())
 270                 return false;
 271             double value = butterfly-&gt;contiguousDouble().at(this, i);
 272             if (value != value)
 273                 return false;
 274             return true;
 275         }
 276         case ALL_ARRAY_STORAGE_INDEXING_TYPES:
 277             return i &lt; butterfly-&gt;arrayStorage()-&gt;vectorLength() &amp;&amp; butterfly-&gt;arrayStorage()-&gt;m_vector[i];
 278         default:
 279             RELEASE_ASSERT_NOT_REACHED();
 280             return false;
 281         }
 282     }
 283 
<span class="line-modified"> 284     JSValue getIndexQuickly(unsigned i)</span>
 285     {
<span class="line-modified"> 286         Butterfly* butterfly = this-&gt;butterfly();</span>
 287         switch (indexingType()) {
 288         case ALL_INT32_INDEXING_TYPES:
 289             return jsNumber(butterfly-&gt;contiguous().at(this, i).get().asInt32());
 290         case ALL_CONTIGUOUS_INDEXING_TYPES:
 291             return butterfly-&gt;contiguous().at(this, i).get();
 292         case ALL_DOUBLE_INDEXING_TYPES:
 293             return JSValue(JSValue::EncodeAsDouble, butterfly-&gt;contiguousDouble().at(this, i));
 294         case ALL_ARRAY_STORAGE_INDEXING_TYPES:
 295             return butterfly-&gt;arrayStorage()-&gt;m_vector[i].get();


 296         default:
 297             RELEASE_ASSERT_NOT_REACHED();
 298             return JSValue();
 299         }
 300     }
 301 
 302     JSValue tryGetIndexQuickly(unsigned i) const
 303     {
<span class="line-modified"> 304         Butterfly* butterfly = const_cast&lt;JSObject*&gt;(this)-&gt;butterfly();</span>
 305         switch (indexingType()) {
 306         case ALL_BLANK_INDEXING_TYPES:



 307         case ALL_UNDECIDED_INDEXING_TYPES:
 308             break;
 309         case ALL_INT32_INDEXING_TYPES:
 310             if (i &lt; butterfly-&gt;publicLength()) {
 311                 JSValue result = butterfly-&gt;contiguous().at(this, i).get();
 312                 ASSERT(result.isInt32() || !result);
 313                 return result;
 314             }
 315             break;
 316         case ALL_CONTIGUOUS_INDEXING_TYPES:
 317             if (i &lt; butterfly-&gt;publicLength())
 318                 return butterfly-&gt;contiguous().at(this, i).get();
 319             break;
 320         case ALL_DOUBLE_INDEXING_TYPES: {
 321             if (i &gt;= butterfly-&gt;publicLength())
 322                 break;
 323             double result = butterfly-&gt;contiguousDouble().at(this, i);
 324             if (result != result)
 325                 break;
 326             return JSValue(JSValue::EncodeAsDouble, result);
</pre>
<hr />
<pre>
 336         return JSValue();
 337     }
 338 
 339     JSValue getDirectIndex(ExecState* exec, unsigned i)
 340     {
 341         if (JSValue result = tryGetIndexQuickly(i))
 342             return result;
 343         PropertySlot slot(this, PropertySlot::InternalMethodType::Get);
 344         if (methodTable(exec-&gt;vm())-&gt;getOwnPropertySlotByIndex(this, exec, i, slot))
 345             return slot.getValue(exec, i);
 346         return JSValue();
 347     }
 348 
 349     JSValue getIndex(ExecState* exec, unsigned i) const
 350     {
 351         if (JSValue result = tryGetIndexQuickly(i))
 352             return result;
 353         return get(exec, i);
 354     }
 355 
<span class="line-modified"> 356     bool canSetIndexQuickly(unsigned i)</span>



 357     {
 358         Butterfly* butterfly = this-&gt;butterfly();
 359         switch (indexingMode()) {
 360         case ALL_BLANK_INDEXING_TYPES:

 361         case ALL_UNDECIDED_INDEXING_TYPES:
 362             return false;
 363         case ALL_WRITABLE_INT32_INDEXING_TYPES:
 364         case ALL_WRITABLE_DOUBLE_INDEXING_TYPES:
 365         case ALL_WRITABLE_CONTIGUOUS_INDEXING_TYPES:
 366         case NonArrayWithArrayStorage:
 367         case ArrayWithArrayStorage:
 368             return i &lt; butterfly-&gt;vectorLength();
 369         case NonArrayWithSlowPutArrayStorage:
 370         case ArrayWithSlowPutArrayStorage:
 371             return i &lt; butterfly-&gt;arrayStorage()-&gt;vectorLength()
 372                 &amp;&amp; !!butterfly-&gt;arrayStorage()-&gt;m_vector[i];
 373         default:
 374             if (isCopyOnWrite(indexingMode()))
 375                 return false;
 376             RELEASE_ASSERT_NOT_REACHED();
 377             return false;
 378         }
 379     }
 380 
</pre>
<hr />
<pre>
 409                 convertDoubleToContiguousWhilePerformingSetIndex(vm, i, v);
 410                 return;
 411             }
 412             butterfly-&gt;contiguousDouble().at(this, i) = value;
 413             if (i &gt;= butterfly-&gt;publicLength())
 414                 butterfly-&gt;setPublicLength(i + 1);
 415             break;
 416         }
 417         case ALL_ARRAY_STORAGE_INDEXING_TYPES: {
 418             ArrayStorage* storage = butterfly-&gt;arrayStorage();
 419             WriteBarrier&lt;Unknown&gt;&amp; x = storage-&gt;m_vector[i];
 420             JSValue old = x.get();
 421             x.set(vm, this, v);
 422             if (!old) {
 423                 ++storage-&gt;m_numValuesInVector;
 424                 if (i &gt;= storage-&gt;length())
 425                     storage-&gt;setLength(i + 1);
 426             }
 427             break;
 428         }



 429         default:
 430             RELEASE_ASSERT_NOT_REACHED();
 431         }
 432     }
 433 
 434     void initializeIndex(ObjectInitializationScope&amp; scope, unsigned i, JSValue v)
 435     {
 436         initializeIndex(scope, i, v, indexingType());
 437     }
 438 
 439     // NOTE: Clients of this method may call it more than once for any index, and this is supposed
 440     // to work.
 441     ALWAYS_INLINE void initializeIndex(ObjectInitializationScope&amp; scope, unsigned i, JSValue v, IndexingType indexingType)
 442     {
 443         VM&amp; vm = scope.vm();
 444         Butterfly* butterfly = m_butterfly.get();
 445         switch (indexingType) {
 446         case ALL_UNDECIDED_INDEXING_TYPES: {
 447             setIndexQuicklyToUndecided(vm, i, v);
 448             break;
</pre>
<hr />
<pre>
 565             return false;
 566         case ALL_ARRAY_STORAGE_INDEXING_TYPES:
 567             return m_butterfly-&gt;arrayStorage()-&gt;inSparseMode();
 568         default:
 569             RELEASE_ASSERT_NOT_REACHED();
 570             return false;
 571         }
 572     }
 573 
 574     void enterDictionaryIndexingMode(VM&amp;);
 575 
 576     // putDirect is effectively an unchecked vesion of &#39;defineOwnProperty&#39;:
 577     //  - the prototype chain is not consulted
 578     //  - accessors are not called.
 579     //  - attributes will be respected (after the call the property will exist with the given attributes)
 580     //  - the property name is assumed to not be an index.
 581     bool putDirect(VM&amp;, PropertyName, JSValue, unsigned attributes = 0);
 582     bool putDirect(VM&amp;, PropertyName, JSValue, PutPropertySlot&amp;);
 583     void putDirectWithoutTransition(VM&amp;, PropertyName, JSValue, unsigned attributes = 0);
 584     bool putDirectNonIndexAccessor(VM&amp;, PropertyName, GetterSetter*, unsigned attributes);

 585     bool putDirectAccessor(ExecState*, PropertyName, GetterSetter*, unsigned attributes);
 586     JS_EXPORT_PRIVATE bool putDirectCustomAccessor(VM&amp;, PropertyName, JSValue, unsigned attributes);
 587 
 588     bool putGetter(ExecState*, PropertyName, JSValue, unsigned attributes);
 589     bool putSetter(ExecState*, PropertyName, JSValue, unsigned attributes);
 590 
 591     JS_EXPORT_PRIVATE bool hasProperty(ExecState*, PropertyName) const;
 592     JS_EXPORT_PRIVATE bool hasProperty(ExecState*, unsigned propertyName) const;
 593     bool hasPropertyGeneric(ExecState*, PropertyName, PropertySlot::InternalMethodType) const;
 594     bool hasPropertyGeneric(ExecState*, unsigned propertyName, PropertySlot::InternalMethodType) const;
 595     bool hasOwnProperty(ExecState*, PropertyName, PropertySlot&amp;) const;
 596     bool hasOwnProperty(ExecState*, PropertyName) const;
 597     bool hasOwnProperty(ExecState*, unsigned) const;
 598 
 599     JS_EXPORT_PRIVATE static bool deleteProperty(JSCell*, ExecState*, PropertyName);
 600     JS_EXPORT_PRIVATE static bool deletePropertyByIndex(JSCell*, ExecState*, unsigned propertyName);
 601 
 602     JS_EXPORT_PRIVATE static JSValue defaultValue(const JSObject*, ExecState*, PreferredPrimitiveType);
 603     JSValue ordinaryToPrimitive(ExecState*, PreferredPrimitiveType) const;
 604 
</pre>
<hr />
<pre>
 699     bool hasCustomProperties(VM&amp; vm) { return structure(vm)-&gt;didTransition(); }
 700     bool hasGetterSetterProperties(VM&amp; vm) { return structure(vm)-&gt;hasGetterSetterProperties(); }
 701     bool hasCustomGetterSetterProperties(VM&amp; vm) { return structure(vm)-&gt;hasCustomGetterSetterProperties(); }
 702 
 703     // putOwnDataProperty has &#39;put&#39; like semantics, however this method:
 704     //  - assumes the object contains no own getter/setter properties.
 705     //  - provides no special handling for __proto__
 706     //  - does not walk the prototype chain (to check for accessors or non-writable properties).
 707     // This is used by JSLexicalEnvironment.
 708     bool putOwnDataProperty(VM&amp;, PropertyName, JSValue, PutPropertySlot&amp;);
 709     bool putOwnDataPropertyMayBeIndex(ExecState*, PropertyName, JSValue, PutPropertySlot&amp;);
 710 
 711     // Fast access to known property offsets.
 712     ALWAYS_INLINE JSValue getDirect(PropertyOffset offset) const { return locationForOffset(offset)-&gt;get(); }
 713     JSValue getDirectConcurrently(Structure* expectedStructure, PropertyOffset) const;
 714     void putDirect(VM&amp; vm, PropertyOffset offset, JSValue value) { locationForOffset(offset)-&gt;set(vm, this, value); }
 715     void putDirectWithoutBarrier(PropertyOffset offset, JSValue value) { locationForOffset(offset)-&gt;setWithoutWriteBarrier(value); }
 716     void putDirectUndefined(PropertyOffset offset) { locationForOffset(offset)-&gt;setUndefined(); }
 717 
 718     JS_EXPORT_PRIVATE bool putDirectNativeIntrinsicGetter(VM&amp;, JSGlobalObject*, Identifier, NativeFunction, Intrinsic, unsigned attributes);

 719     JS_EXPORT_PRIVATE bool putDirectNativeFunction(VM&amp;, JSGlobalObject*, const PropertyName&amp;, unsigned functionLength, NativeFunction, Intrinsic, unsigned attributes);
 720     JS_EXPORT_PRIVATE bool putDirectNativeFunction(VM&amp;, JSGlobalObject*, const PropertyName&amp;, unsigned functionLength, NativeFunction, Intrinsic, const DOMJIT::Signature*, unsigned attributes);
 721     JS_EXPORT_PRIVATE void putDirectNativeFunctionWithoutTransition(VM&amp;, JSGlobalObject*, const PropertyName&amp;, unsigned functionLength, NativeFunction, Intrinsic, unsigned attributes);
 722 
 723     JS_EXPORT_PRIVATE JSFunction* putDirectBuiltinFunction(VM&amp;, JSGlobalObject*, const PropertyName&amp;, FunctionExecutable*, unsigned attributes);
 724     JSFunction* putDirectBuiltinFunctionWithoutTransition(VM&amp;, JSGlobalObject*, const PropertyName&amp;, FunctionExecutable*, unsigned attributes);
 725 
 726     JS_EXPORT_PRIVATE static bool defineOwnProperty(JSObject*, ExecState*, PropertyName, const PropertyDescriptor&amp;, bool shouldThrow);
 727 
 728     bool isEnvironment() const;
 729     bool isGlobalObject() const;
 730     bool isJSLexicalEnvironment() const;
 731     bool isGlobalLexicalEnvironment() const;
 732     bool isStrictEvalActivation() const;
 733     bool isWithScope() const;
 734 
 735     bool isErrorInstance() const;
 736 
 737     JS_EXPORT_PRIVATE void seal(VM&amp;);
 738     JS_EXPORT_PRIVATE void freeze(VM&amp;);
 739     JS_EXPORT_PRIVATE static bool preventExtensions(JSObject*, ExecState*);
 740     JS_EXPORT_PRIVATE static bool isExtensible(JSObject*, ExecState*);
 741     bool isSealed(VM&amp; vm) { return structure(vm)-&gt;isSealed(vm); }
 742     bool isFrozen(VM&amp; vm) { return structure(vm)-&gt;isFrozen(vm); }
 743 
<span class="line-modified"> 744     bool anyObjectInChainMayInterceptIndexedAccesses(VM&amp;) const;</span>
 745     JS_EXPORT_PRIVATE bool prototypeChainMayInterceptStoreTo(VM&amp;, PropertyName);
 746     bool needsSlowPutIndexing(VM&amp;) const;
 747 
 748 private:
 749     NonPropertyTransition suggestedArrayStorageTransition(VM&amp;) const;
 750 public:
 751     // You should only call isStructureExtensible() when:
 752     // - Performing this check in a way that isn&#39;t described in the specification
 753     //   as calling the virtual [[IsExtensible]] trap.
 754     // - When you&#39;re guaranteed that object-&gt;methodTable(vm)-&gt;isExtensible isn&#39;t
 755     //   overridden.
 756     ALWAYS_INLINE bool isStructureExtensible(VM&amp; vm) { return structure(vm)-&gt;isStructureExtensible(); }
 757     // You should call this when performing [[IsExtensible]] trap in a place
 758     // that is described in the specification. This performs the fully virtual
 759     // [[IsExtensible]] trap.
 760     bool isExtensible(ExecState*);
 761     bool indexingShouldBeSparse(VM&amp; vm)
 762     {
 763         return !isStructureExtensible(vm)
 764             || structure(vm)-&gt;typeInfo().interceptsGetOwnPropertySlotByIndexEvenWhenLengthIsNotZero();
</pre>
<hr />
<pre>
1384     if (structure-&gt;isUncacheableDictionary())
1385         slot.setCustom(this, attributes, customGetterSetter-&gt;getter());
1386     else
1387         slot.setCacheableCustom(this, attributes, customGetterSetter-&gt;getter());
1388 }
1389 
1390 // It may seem crazy to inline a function this large, especially a virtual function,
1391 // but it makes a big difference to property lookup that derived classes can inline their
1392 // base class call to this.
1393 ALWAYS_INLINE bool JSObject::getOwnPropertySlot(JSObject* object, ExecState* exec, PropertyName propertyName, PropertySlot&amp; slot)
1394 {
1395     VM&amp; vm = exec-&gt;vm();
1396     Structure* structure = object-&gt;structure(vm);
1397     if (object-&gt;getOwnNonIndexPropertySlot(vm, structure, propertyName, slot))
1398         return true;
1399     if (Optional&lt;uint32_t&gt; index = parseIndex(propertyName))
1400         return getOwnPropertySlotByIndex(object, exec, index.value(), slot);
1401     return false;
1402 }
1403 




1404 // It may seem crazy to inline a function this large but it makes a big difference
1405 // since this is function very hot in variable lookup
1406 template&lt;bool checkNullStructure&gt;
1407 ALWAYS_INLINE bool JSObject::getPropertySlot(ExecState* exec, PropertyName propertyName, PropertySlot&amp; slot)
1408 {
1409     VM&amp; vm = exec-&gt;vm();
1410     auto&amp; structureIDTable = vm.heap.structureIDTable();
1411     JSObject* object = this;
1412     while (true) {
1413         if (UNLIKELY(TypeInfo::overridesGetOwnPropertySlot(object-&gt;inlineTypeFlags()))) {
1414             // If propertyName is an index then we may have missed it (as this loop is using
1415             // getOwnNonIndexPropertySlot), so we cannot safely call the overridden getOwnPropertySlot
1416             // (lest we return a property from a prototype that is shadowed). Check now for an index,
1417             // if so we need to start afresh from this object.
1418             if (Optional&lt;uint32_t&gt; index = parseIndex(propertyName))
1419                 return getPropertySlot(exec, index.value(), slot);
1420             // Safe to continue searching from current position; call getNonIndexPropertySlot to avoid
1421             // parsing the int again.
1422             return object-&gt;getNonIndexPropertySlot(exec, propertyName, slot);
1423         }
</pre>
<hr />
<pre>
1508 }
1509 
1510 ALWAYS_INLINE JSObject* Register::object() const
1511 {
1512     return asObject(jsValue());
1513 }
1514 
1515 ALWAYS_INLINE Register&amp; Register::operator=(JSObject* object)
1516 {
1517     u.value = JSValue::encode(JSValue(object));
1518     return *this;
1519 }
1520 
1521 inline size_t offsetInButterfly(PropertyOffset offset)
1522 {
1523     return offsetInOutOfLineStorage(offset) + Butterfly::indexOfPropertyStorage();
1524 }
1525 
1526 inline size_t JSObject::butterflyPreCapacity()
1527 {
<span class="line-modified">1528     VM&amp; vm = *this-&gt;vm();</span>
1529     if (UNLIKELY(hasIndexingHeader(vm)))
1530         return butterfly()-&gt;indexingHeader()-&gt;preCapacity(structure(vm));
1531     return 0;
1532 }
1533 
1534 inline size_t JSObject::butterflyTotalSize()
1535 {
<span class="line-modified">1536     VM&amp; vm = *this-&gt;vm();</span>
1537     Structure* structure = this-&gt;structure(vm);
1538     Butterfly* butterfly = this-&gt;butterfly();
1539     size_t preCapacity;
1540     size_t indexingPayloadSizeInBytes;
1541     bool hasIndexingHeader = this-&gt;hasIndexingHeader(vm);
1542 
1543     if (UNLIKELY(hasIndexingHeader)) {
1544         preCapacity = butterfly-&gt;indexingHeader()-&gt;preCapacity(structure);
1545         indexingPayloadSizeInBytes = butterfly-&gt;indexingHeader()-&gt;indexingPayloadSizeInBytes(structure);
1546     } else {
1547         preCapacity = 0;
1548         indexingPayloadSizeInBytes = 0;
1549     }
1550 
1551     return Butterfly::totalSize(preCapacity, structure-&gt;outOfLineCapacity(), hasIndexingHeader, indexingPayloadSizeInBytes);
1552 }
1553 
1554 inline int indexRelativeToBase(PropertyOffset offset)
1555 {
1556     if (isOutOfLineOffset(offset))
</pre>
<hr />
<pre>
1565         return offsetInOutOfLineStorage(offset) * sizeof(EncodedJSValue) + Butterfly::offsetOfPropertyStorage();
1566     return JSObject::offsetOfInlineStorage() + offsetInInlineStorage(offset) * sizeof(EncodedJSValue);
1567 }
1568 
1569 // Returns the maximum offset (away from zero) a load instruction will encode.
1570 inline size_t maxOffsetRelativeToBase(PropertyOffset offset)
1571 {
1572     ptrdiff_t addressOffset = offsetRelativeToBase(offset);
1573 #if USE(JSVALUE32_64)
1574     if (addressOffset &gt;= 0)
1575         return static_cast&lt;size_t&gt;(addressOffset) + OBJECT_OFFSETOF(EncodedValueDescriptor, asBits.tag);
1576 #endif
1577     return static_cast&lt;size_t&gt;(addressOffset);
1578 }
1579 
1580 COMPILE_ASSERT(!(sizeof(JSObject) % sizeof(WriteBarrierBase&lt;Unknown&gt;)), JSObject_inline_storage_has_correct_alignment);
1581 
1582 template&lt;unsigned charactersCount&gt;
1583 ALWAYS_INLINE Identifier makeIdentifier(VM&amp; vm, const char (&amp;characters)[charactersCount])
1584 {
<span class="line-modified">1585     return Identifier::fromString(&amp;vm, characters);</span>
1586 }
1587 
1588 ALWAYS_INLINE Identifier makeIdentifier(VM&amp; vm, const char* name)
1589 {
<span class="line-modified">1590     return Identifier::fromString(&amp;vm, name);</span>
1591 }
1592 
1593 ALWAYS_INLINE Identifier makeIdentifier(VM&amp;, const Identifier&amp; name)
1594 {
1595     return name;
1596 }
1597 
1598 bool validateAndApplyPropertyDescriptor(ExecState*, JSObject*, PropertyName, bool isExtensible,
1599     const PropertyDescriptor&amp; descriptor, bool isCurrentDefined, const PropertyDescriptor&amp; current, bool throwException);
1600 
1601 JS_EXPORT_PRIVATE NEVER_INLINE bool ordinarySetSlow(ExecState*, JSObject*, PropertyName, JSValue, JSValue receiver, bool shouldThrow);
1602 
1603 // Helper for defining native functions, if you&#39;re not using a static hash table.
1604 // Use this macro from within finishCreation() methods in prototypes. This assumes
1605 // you&#39;ve defined variables called exec, globalObject, and vm, and they
1606 // have the expected meanings.
1607 #define JSC_NATIVE_INTRINSIC_FUNCTION(jsName, cppName, attributes, length, intrinsic) \
1608     putDirectNativeFunction(\
1609         vm, globalObject, makeIdentifier(vm, (jsName)), (length), cppName, \
1610         (intrinsic), (attributes))
</pre>
<hr />
<pre>
1621 
1622 #define JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION(jsName, cppName, attributes, length) \
1623     JSC_NATIVE_INTRINSIC_FUNCTION_WITHOUT_TRANSITION(jsName, cppName, (attributes), (length), NoIntrinsic)
1624 
1625 // Identical helpers but for builtins. Note that currently, we don&#39;t support builtins that are
1626 // also intrinsics, but we probably will do that eventually.
1627 #define JSC_BUILTIN_FUNCTION(jsName, generatorName, attributes) \
1628     putDirectBuiltinFunction(\
1629         vm, globalObject, makeIdentifier(vm, (jsName)), (generatorName)(vm), (attributes))
1630 
1631 #define JSC_BUILTIN_FUNCTION_WITHOUT_TRANSITION(jsName, generatorName, attributes) \
1632     putDirectBuiltinFunctionWithoutTransition(\
1633         vm, globalObject, makeIdentifier(vm, (jsName)), (generatorName)(vm), (attributes))
1634 
1635 // Helper for defining native getters on properties.
1636 #define JSC_NATIVE_INTRINSIC_GETTER(jsName, cppName, attributes, intrinsic)  \
1637     putDirectNativeIntrinsicGetter(\
1638         vm, globalObject, makeIdentifier(vm, (jsName)), (cppName), \
1639         (intrinsic), ((attributes) | PropertyAttribute::Accessor))
1640 





1641 #define JSC_NATIVE_GETTER(jsName, cppName, attributes) \
1642     JSC_NATIVE_INTRINSIC_GETTER((jsName), (cppName), (attributes), NoIntrinsic)
1643 



1644 } // namespace JSC
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
   2  *  Copyright (C) 1999-2001 Harri Porten (porten@kde.org)
   3  *  Copyright (C) 2001 Peter Kelly (pmk@post.com)
<span class="line-modified">   4  *  Copyright (C) 2003-2019 Apple Inc. All rights reserved.</span>
   5  *
   6  *  This library is free software; you can redistribute it and/or
   7  *  modify it under the terms of the GNU Library General Public
   8  *  License as published by the Free Software Foundation; either
   9  *  version 2 of the License, or (at your option) any later version.
  10  *
  11  *  This library is distributed in the hope that it will be useful,
  12  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  13  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  14  *  Library General Public License for more details.
  15  *
  16  *  You should have received a copy of the GNU Library General Public License
  17  *  along with this library; see the file COPYING.LIB.  If not, write to
  18  *  the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  19  *  Boston, MA 02110-1301, USA.
  20  *
  21  */
  22 
  23 #pragma once
  24 
</pre>
<hr />
<pre>
  41 #include &quot;PutPropertySlot.h&quot;
  42 #include &quot;Structure.h&quot;
  43 #include &quot;StructureTransitionTable.h&quot;
  44 #include &quot;VM.h&quot;
  45 #include &quot;JSString.h&quot;
  46 #include &quot;SparseArrayValueMap.h&quot;
  47 #include &lt;wtf/StdLibExtras.h&gt;
  48 
  49 namespace JSC {
  50 namespace DOMJIT {
  51 class Signature;
  52 }
  53 
  54 inline JSCell* getJSFunction(JSValue value)
  55 {
  56     if (value.isCell() &amp;&amp; (value.asCell()-&gt;type() == JSFunctionType))
  57         return value.asCell();
  58     return 0;
  59 }
  60 
<span class="line-added">  61 class Exception;</span>
  62 class GetterSetter;
  63 class InternalFunction;
  64 class JSFunction;
  65 class LLIntOffsetsExtractor;
  66 class MarkedBlock;
  67 class PropertyDescriptor;
  68 class PropertyNameArray;
  69 class Structure;
  70 class ThrowScope;
  71 struct HashTable;
  72 struct HashTableValue;
  73 
<span class="line-modified">  74 JS_EXPORT_PRIVATE Exception* throwTypeError(ExecState*, ThrowScope&amp;, const String&amp;);</span>
  75 extern JS_EXPORT_PRIVATE const ASCIILiteral NonExtensibleObjectPropertyDefineError;
  76 extern JS_EXPORT_PRIVATE const ASCIILiteral ReadonlyPropertyWriteError;
  77 extern JS_EXPORT_PRIVATE const ASCIILiteral ReadonlyPropertyChangeError;
  78 extern JS_EXPORT_PRIVATE const ASCIILiteral UnableToDeletePropertyError;
  79 extern JS_EXPORT_PRIVATE const ASCIILiteral UnconfigurablePropertyChangeAccessMechanismError;
  80 extern JS_EXPORT_PRIVATE const ASCIILiteral UnconfigurablePropertyChangeConfigurabilityError;
  81 extern JS_EXPORT_PRIVATE const ASCIILiteral UnconfigurablePropertyChangeEnumerabilityError;
  82 extern JS_EXPORT_PRIVATE const ASCIILiteral UnconfigurablePropertyChangeWritabilityError;
  83 
  84 COMPILE_ASSERT(PropertyAttribute::None &lt; FirstInternalAttribute, None_is_below_FirstInternalAttribute);
  85 COMPILE_ASSERT(PropertyAttribute::ReadOnly &lt; FirstInternalAttribute, ReadOnly_is_below_FirstInternalAttribute);
  86 COMPILE_ASSERT(PropertyAttribute::DontEnum &lt; FirstInternalAttribute, DontEnum_is_below_FirstInternalAttribute);
  87 COMPILE_ASSERT(PropertyAttribute::DontDelete &lt; FirstInternalAttribute, DontDelete_is_below_FirstInternalAttribute);
  88 COMPILE_ASSERT(PropertyAttribute::Accessor &lt; FirstInternalAttribute, Accessor_is_below_FirstInternalAttribute);
  89 
  90 class JSFinalObject;
  91 
  92 class JSObject : public JSCell {
  93     friend class BatchedTransitionOptimizer;
  94     friend class JIT;
  95     friend class JSCell;
  96     friend class JSFinalObject;
  97     friend class MarkedBlock;
  98     JS_EXPORT_PRIVATE friend bool setUpStaticFunctionSlot(VM&amp;, const HashTableValue*, JSObject*, PropertyName, PropertySlot&amp;);
  99 
 100     enum PutMode {
 101         PutModePut,
 102         PutModeDefineOwnProperty,
 103     };
 104 
 105 public:
 106     typedef JSCell Base;
 107 
 108     // This is a super dangerous method for JITs. Sometimes the JITs will want to create either a
 109     // JSFinalObject or a JSArray. This is the method that will do that.
 110     static JSObject* createRawObject(ExecState* exec, Structure* structure, Butterfly* = nullptr);
 111 
 112     JS_EXPORT_PRIVATE static size_t estimatedSize(JSCell*, VM&amp;);
 113     JS_EXPORT_PRIVATE static void visitChildren(JSCell*, SlotVisitor&amp;);
<span class="line-modified"> 114     JS_EXPORT_PRIVATE static void analyzeHeap(JSCell*, HeapAnalyzer&amp;);</span>
 115 
 116     JS_EXPORT_PRIVATE static String className(const JSObject*, VM&amp;);
 117     JS_EXPORT_PRIVATE static String calculatedClassName(JSObject*);
 118 
 119     // This function is what Object.prototype.toString() will use to get the name of
 120     // an object when using Symbol.toStringTag fails. For the most part there is no
 121     // difference between this and className(). The main use case is for new JS language
 122     // objects to set the default tag to &quot;Object&quot;.
 123     JS_EXPORT_PRIVATE static String toStringName(const JSObject*, ExecState*);
 124 
 125     // This is the fully virtual [[GetPrototypeOf]] internal function defined
 126     // in the ECMAScript 6 specification. Use this when doing a [[GetPrototypeOf]]
 127     // operation as dictated in the specification.
 128     JSValue getPrototype(VM&amp;, ExecState*);
 129     JS_EXPORT_PRIVATE static JSValue getPrototype(JSObject*, ExecState*);
 130     // This gets the prototype directly off of the structure. This does not do
 131     // dynamic dispatch on the getPrototype method table method. It is not valid
 132     // to use this when performing a [[GetPrototypeOf]] operation in the specification.
 133     // It is valid to use though when you know that you want to directly get it
 134     // without consulting the method table. This is akin to getting the [[Prototype]]
</pre>
<hr />
<pre>
 151     // This is the fully virtual [[SetPrototypeOf]] internal function defined
 152     // in the ECMAScript 6 specification. Use this when doing a [[SetPrototypeOf]]
 153     // operation as dictated in the specification.
 154     bool setPrototype(VM&amp;, ExecState*, JSValue prototype, bool shouldThrowIfCantSet = false);
 155     JS_EXPORT_PRIVATE static bool setPrototype(JSObject*, ExecState*, JSValue prototype, bool shouldThrowIfCantSet);
 156 
 157     inline bool mayInterceptIndexedAccesses(VM&amp;);
 158 
 159     JSValue get(ExecState*, PropertyName) const;
 160     JSValue get(ExecState*, unsigned propertyName) const;
 161 
 162     template&lt;bool checkNullStructure = false&gt;
 163     bool getPropertySlot(ExecState*, PropertyName, PropertySlot&amp;);
 164     bool getPropertySlot(ExecState*, unsigned propertyName, PropertySlot&amp;);
 165     template&lt;typename CallbackWhenNoException&gt; typename std::result_of&lt;CallbackWhenNoException(bool, PropertySlot&amp;)&gt;::type getPropertySlot(ExecState*, PropertyName, CallbackWhenNoException) const;
 166     template&lt;typename CallbackWhenNoException&gt; typename std::result_of&lt;CallbackWhenNoException(bool, PropertySlot&amp;)&gt;::type getPropertySlot(ExecState*, PropertyName, PropertySlot&amp;, CallbackWhenNoException) const;
 167 
 168     static bool getOwnPropertySlot(JSObject*, ExecState*, PropertyName, PropertySlot&amp;);
 169     JS_EXPORT_PRIVATE static bool getOwnPropertySlotByIndex(JSObject*, ExecState*, unsigned propertyName, PropertySlot&amp;);
 170     bool getOwnPropertySlotInline(ExecState*, PropertyName, PropertySlot&amp;);
<span class="line-added"> 171     static void doPutPropertySecurityCheck(JSObject*, ExecState*, PropertyName, PutPropertySlot&amp;);</span>
 172 
 173     // The key difference between this and getOwnPropertySlot is that getOwnPropertySlot
 174     // currently returns incorrect results for the DOM window (with non-own properties)
 175     // being returned. Once this is fixed we should migrate code &amp; remove this method.
 176     JS_EXPORT_PRIVATE bool getOwnPropertyDescriptor(ExecState*, PropertyName, PropertyDescriptor&amp;);
 177 
 178     unsigned getArrayLength() const
 179     {
 180         if (!hasIndexedProperties(indexingType()))
 181             return 0;
 182         return m_butterfly-&gt;publicLength();
 183     }
 184 
 185     unsigned getVectorLength()
 186     {
 187         if (!hasIndexedProperties(indexingType()))
 188             return 0;
 189         return m_butterfly-&gt;vectorLength();
 190     }
 191 
 192     static bool putInlineForJSObject(JSCell*, ExecState*, PropertyName, JSValue, PutPropertySlot&amp;);
 193 
 194     JS_EXPORT_PRIVATE static bool put(JSCell*, ExecState*, PropertyName, JSValue, PutPropertySlot&amp;);
 195     // putByIndex assumes that the receiver is this JSCell object.
 196     JS_EXPORT_PRIVATE static bool putByIndex(JSCell*, ExecState*, unsigned propertyName, JSValue, bool shouldThrow);
 197 
 198     // This performs the ECMAScript Set() operation.
 199     ALWAYS_INLINE bool putByIndexInline(ExecState* exec, unsigned propertyName, JSValue value, bool shouldThrow)
 200     {
<span class="line-modified"> 201         VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified"> 202         if (canSetIndexQuickly(propertyName, value)) {</span>
<span class="line-added"> 203             setIndexQuickly(vm, propertyName, value);</span>
 204             return true;
 205         }
<span class="line-modified"> 206         return methodTable(vm)-&gt;putByIndex(this, exec, propertyName, value, shouldThrow);</span>
 207     }
 208 
 209     // This is similar to the putDirect* methods:
 210     //  - the prototype chain is not consulted
 211     //  - accessors are not called.
 212     //  - it will ignore extensibility and read-only properties if PutDirectIndexLikePutDirect is passed as the mode (the default).
 213     // This method creates a property with attributes writable, enumerable and configurable all set to true if attributes is zero,
 214     // otherwise, it creates a property with the provided attributes. Semantically, this is performing defineOwnProperty.
 215     bool putDirectIndex(ExecState* exec, unsigned propertyName, JSValue value, unsigned attributes, PutDirectIndexMode mode)
 216     {
 217         ASSERT(!value.isCustomGetterSetter());
 218         auto canSetIndexQuicklyForPutDirect = [&amp;] () -&gt; bool {
 219             switch (indexingMode()) {
 220             case ALL_BLANK_INDEXING_TYPES:
 221             case ALL_UNDECIDED_INDEXING_TYPES:
 222                 return false;
 223             case ALL_WRITABLE_INT32_INDEXING_TYPES:
 224             case ALL_WRITABLE_DOUBLE_INDEXING_TYPES:
 225             case ALL_WRITABLE_CONTIGUOUS_INDEXING_TYPES:
 226             case ALL_ARRAY_STORAGE_INDEXING_TYPES:
</pre>
<hr />
<pre>
 241     }
 242     // This is semantically equivalent to performing defineOwnProperty(propertyName, {configurable:true, writable:true, enumerable:true, value:value}).
 243     bool putDirectIndex(ExecState* exec, unsigned propertyName, JSValue value)
 244     {
 245         return putDirectIndex(exec, propertyName, value, 0, PutDirectIndexLikePutDirect);
 246     }
 247 
 248     // A generally non-throwing version of putDirect and putDirectIndex.
 249     // However, it&#39;s only guaranteed to not throw based on what the receiver is.
 250     // For example, if the receiver is a ProxyObject, this is not guaranteed, since
 251     // it may call into arbitrary JS code. It&#39;s the responsibility of the user of
 252     // this API to ensure that the receiver object is a well known type if they
 253     // want to ensure that this won&#39;t throw an exception.
 254     JS_EXPORT_PRIVATE bool putDirectMayBeIndex(ExecState*, PropertyName, JSValue);
 255 
 256     bool hasIndexingHeader(VM&amp; vm) const
 257     {
 258         return structure(vm)-&gt;hasIndexingHeader(this);
 259     }
 260 
<span class="line-modified"> 261     bool canGetIndexQuicklyForTypedArray(unsigned) const;</span>
<span class="line-added"> 262     JSValue getIndexQuicklyForTypedArray(unsigned) const;</span>
<span class="line-added"> 263 </span>
<span class="line-added"> 264     bool canGetIndexQuickly(unsigned i) const</span>
 265     {
<span class="line-modified"> 266         const Butterfly* butterfly = this-&gt;butterfly();</span>
 267         switch (indexingType()) {
 268         case ALL_BLANK_INDEXING_TYPES:
<span class="line-added"> 269             return canGetIndexQuicklyForTypedArray(i);</span>
 270         case ALL_UNDECIDED_INDEXING_TYPES:
 271             return false;
 272         case ALL_INT32_INDEXING_TYPES:
 273         case ALL_CONTIGUOUS_INDEXING_TYPES:
 274             return i &lt; butterfly-&gt;vectorLength() &amp;&amp; butterfly-&gt;contiguous().at(this, i);
 275         case ALL_DOUBLE_INDEXING_TYPES: {
 276             if (i &gt;= butterfly-&gt;vectorLength())
 277                 return false;
 278             double value = butterfly-&gt;contiguousDouble().at(this, i);
 279             if (value != value)
 280                 return false;
 281             return true;
 282         }
 283         case ALL_ARRAY_STORAGE_INDEXING_TYPES:
 284             return i &lt; butterfly-&gt;arrayStorage()-&gt;vectorLength() &amp;&amp; butterfly-&gt;arrayStorage()-&gt;m_vector[i];
 285         default:
 286             RELEASE_ASSERT_NOT_REACHED();
 287             return false;
 288         }
 289     }
 290 
<span class="line-modified"> 291     JSValue getIndexQuickly(unsigned i) const</span>
 292     {
<span class="line-modified"> 293         const Butterfly* butterfly = this-&gt;butterfly();</span>
 294         switch (indexingType()) {
 295         case ALL_INT32_INDEXING_TYPES:
 296             return jsNumber(butterfly-&gt;contiguous().at(this, i).get().asInt32());
 297         case ALL_CONTIGUOUS_INDEXING_TYPES:
 298             return butterfly-&gt;contiguous().at(this, i).get();
 299         case ALL_DOUBLE_INDEXING_TYPES:
 300             return JSValue(JSValue::EncodeAsDouble, butterfly-&gt;contiguousDouble().at(this, i));
 301         case ALL_ARRAY_STORAGE_INDEXING_TYPES:
 302             return butterfly-&gt;arrayStorage()-&gt;m_vector[i].get();
<span class="line-added"> 303         case ALL_BLANK_INDEXING_TYPES:</span>
<span class="line-added"> 304             return getIndexQuicklyForTypedArray(i);</span>
 305         default:
 306             RELEASE_ASSERT_NOT_REACHED();
 307             return JSValue();
 308         }
 309     }
 310 
 311     JSValue tryGetIndexQuickly(unsigned i) const
 312     {
<span class="line-modified"> 313         const Butterfly* butterfly = this-&gt;butterfly();</span>
 314         switch (indexingType()) {
 315         case ALL_BLANK_INDEXING_TYPES:
<span class="line-added"> 316             if (canGetIndexQuicklyForTypedArray(i))</span>
<span class="line-added"> 317                 return getIndexQuicklyForTypedArray(i);</span>
<span class="line-added"> 318             break;</span>
 319         case ALL_UNDECIDED_INDEXING_TYPES:
 320             break;
 321         case ALL_INT32_INDEXING_TYPES:
 322             if (i &lt; butterfly-&gt;publicLength()) {
 323                 JSValue result = butterfly-&gt;contiguous().at(this, i).get();
 324                 ASSERT(result.isInt32() || !result);
 325                 return result;
 326             }
 327             break;
 328         case ALL_CONTIGUOUS_INDEXING_TYPES:
 329             if (i &lt; butterfly-&gt;publicLength())
 330                 return butterfly-&gt;contiguous().at(this, i).get();
 331             break;
 332         case ALL_DOUBLE_INDEXING_TYPES: {
 333             if (i &gt;= butterfly-&gt;publicLength())
 334                 break;
 335             double result = butterfly-&gt;contiguousDouble().at(this, i);
 336             if (result != result)
 337                 break;
 338             return JSValue(JSValue::EncodeAsDouble, result);
</pre>
<hr />
<pre>
 348         return JSValue();
 349     }
 350 
 351     JSValue getDirectIndex(ExecState* exec, unsigned i)
 352     {
 353         if (JSValue result = tryGetIndexQuickly(i))
 354             return result;
 355         PropertySlot slot(this, PropertySlot::InternalMethodType::Get);
 356         if (methodTable(exec-&gt;vm())-&gt;getOwnPropertySlotByIndex(this, exec, i, slot))
 357             return slot.getValue(exec, i);
 358         return JSValue();
 359     }
 360 
 361     JSValue getIndex(ExecState* exec, unsigned i) const
 362     {
 363         if (JSValue result = tryGetIndexQuickly(i))
 364             return result;
 365         return get(exec, i);
 366     }
 367 
<span class="line-modified"> 368     bool canSetIndexQuicklyForTypedArray(unsigned, JSValue) const;</span>
<span class="line-added"> 369     void setIndexQuicklyForTypedArray(unsigned, JSValue);</span>
<span class="line-added"> 370 </span>
<span class="line-added"> 371     bool canSetIndexQuickly(unsigned i, JSValue value)</span>
 372     {
 373         Butterfly* butterfly = this-&gt;butterfly();
 374         switch (indexingMode()) {
 375         case ALL_BLANK_INDEXING_TYPES:
<span class="line-added"> 376             return canSetIndexQuicklyForTypedArray(i, value);</span>
 377         case ALL_UNDECIDED_INDEXING_TYPES:
 378             return false;
 379         case ALL_WRITABLE_INT32_INDEXING_TYPES:
 380         case ALL_WRITABLE_DOUBLE_INDEXING_TYPES:
 381         case ALL_WRITABLE_CONTIGUOUS_INDEXING_TYPES:
 382         case NonArrayWithArrayStorage:
 383         case ArrayWithArrayStorage:
 384             return i &lt; butterfly-&gt;vectorLength();
 385         case NonArrayWithSlowPutArrayStorage:
 386         case ArrayWithSlowPutArrayStorage:
 387             return i &lt; butterfly-&gt;arrayStorage()-&gt;vectorLength()
 388                 &amp;&amp; !!butterfly-&gt;arrayStorage()-&gt;m_vector[i];
 389         default:
 390             if (isCopyOnWrite(indexingMode()))
 391                 return false;
 392             RELEASE_ASSERT_NOT_REACHED();
 393             return false;
 394         }
 395     }
 396 
</pre>
<hr />
<pre>
 425                 convertDoubleToContiguousWhilePerformingSetIndex(vm, i, v);
 426                 return;
 427             }
 428             butterfly-&gt;contiguousDouble().at(this, i) = value;
 429             if (i &gt;= butterfly-&gt;publicLength())
 430                 butterfly-&gt;setPublicLength(i + 1);
 431             break;
 432         }
 433         case ALL_ARRAY_STORAGE_INDEXING_TYPES: {
 434             ArrayStorage* storage = butterfly-&gt;arrayStorage();
 435             WriteBarrier&lt;Unknown&gt;&amp; x = storage-&gt;m_vector[i];
 436             JSValue old = x.get();
 437             x.set(vm, this, v);
 438             if (!old) {
 439                 ++storage-&gt;m_numValuesInVector;
 440                 if (i &gt;= storage-&gt;length())
 441                     storage-&gt;setLength(i + 1);
 442             }
 443             break;
 444         }
<span class="line-added"> 445         case ALL_BLANK_INDEXING_TYPES:</span>
<span class="line-added"> 446             setIndexQuicklyForTypedArray(i, v);</span>
<span class="line-added"> 447             break;</span>
 448         default:
 449             RELEASE_ASSERT_NOT_REACHED();
 450         }
 451     }
 452 
 453     void initializeIndex(ObjectInitializationScope&amp; scope, unsigned i, JSValue v)
 454     {
 455         initializeIndex(scope, i, v, indexingType());
 456     }
 457 
 458     // NOTE: Clients of this method may call it more than once for any index, and this is supposed
 459     // to work.
 460     ALWAYS_INLINE void initializeIndex(ObjectInitializationScope&amp; scope, unsigned i, JSValue v, IndexingType indexingType)
 461     {
 462         VM&amp; vm = scope.vm();
 463         Butterfly* butterfly = m_butterfly.get();
 464         switch (indexingType) {
 465         case ALL_UNDECIDED_INDEXING_TYPES: {
 466             setIndexQuicklyToUndecided(vm, i, v);
 467             break;
</pre>
<hr />
<pre>
 584             return false;
 585         case ALL_ARRAY_STORAGE_INDEXING_TYPES:
 586             return m_butterfly-&gt;arrayStorage()-&gt;inSparseMode();
 587         default:
 588             RELEASE_ASSERT_NOT_REACHED();
 589             return false;
 590         }
 591     }
 592 
 593     void enterDictionaryIndexingMode(VM&amp;);
 594 
 595     // putDirect is effectively an unchecked vesion of &#39;defineOwnProperty&#39;:
 596     //  - the prototype chain is not consulted
 597     //  - accessors are not called.
 598     //  - attributes will be respected (after the call the property will exist with the given attributes)
 599     //  - the property name is assumed to not be an index.
 600     bool putDirect(VM&amp;, PropertyName, JSValue, unsigned attributes = 0);
 601     bool putDirect(VM&amp;, PropertyName, JSValue, PutPropertySlot&amp;);
 602     void putDirectWithoutTransition(VM&amp;, PropertyName, JSValue, unsigned attributes = 0);
 603     bool putDirectNonIndexAccessor(VM&amp;, PropertyName, GetterSetter*, unsigned attributes);
<span class="line-added"> 604     void putDirectNonIndexAccessorWithoutTransition(VM&amp;, PropertyName, GetterSetter*, unsigned attributes);</span>
 605     bool putDirectAccessor(ExecState*, PropertyName, GetterSetter*, unsigned attributes);
 606     JS_EXPORT_PRIVATE bool putDirectCustomAccessor(VM&amp;, PropertyName, JSValue, unsigned attributes);
 607 
 608     bool putGetter(ExecState*, PropertyName, JSValue, unsigned attributes);
 609     bool putSetter(ExecState*, PropertyName, JSValue, unsigned attributes);
 610 
 611     JS_EXPORT_PRIVATE bool hasProperty(ExecState*, PropertyName) const;
 612     JS_EXPORT_PRIVATE bool hasProperty(ExecState*, unsigned propertyName) const;
 613     bool hasPropertyGeneric(ExecState*, PropertyName, PropertySlot::InternalMethodType) const;
 614     bool hasPropertyGeneric(ExecState*, unsigned propertyName, PropertySlot::InternalMethodType) const;
 615     bool hasOwnProperty(ExecState*, PropertyName, PropertySlot&amp;) const;
 616     bool hasOwnProperty(ExecState*, PropertyName) const;
 617     bool hasOwnProperty(ExecState*, unsigned) const;
 618 
 619     JS_EXPORT_PRIVATE static bool deleteProperty(JSCell*, ExecState*, PropertyName);
 620     JS_EXPORT_PRIVATE static bool deletePropertyByIndex(JSCell*, ExecState*, unsigned propertyName);
 621 
 622     JS_EXPORT_PRIVATE static JSValue defaultValue(const JSObject*, ExecState*, PreferredPrimitiveType);
 623     JSValue ordinaryToPrimitive(ExecState*, PreferredPrimitiveType) const;
 624 
</pre>
<hr />
<pre>
 719     bool hasCustomProperties(VM&amp; vm) { return structure(vm)-&gt;didTransition(); }
 720     bool hasGetterSetterProperties(VM&amp; vm) { return structure(vm)-&gt;hasGetterSetterProperties(); }
 721     bool hasCustomGetterSetterProperties(VM&amp; vm) { return structure(vm)-&gt;hasCustomGetterSetterProperties(); }
 722 
 723     // putOwnDataProperty has &#39;put&#39; like semantics, however this method:
 724     //  - assumes the object contains no own getter/setter properties.
 725     //  - provides no special handling for __proto__
 726     //  - does not walk the prototype chain (to check for accessors or non-writable properties).
 727     // This is used by JSLexicalEnvironment.
 728     bool putOwnDataProperty(VM&amp;, PropertyName, JSValue, PutPropertySlot&amp;);
 729     bool putOwnDataPropertyMayBeIndex(ExecState*, PropertyName, JSValue, PutPropertySlot&amp;);
 730 
 731     // Fast access to known property offsets.
 732     ALWAYS_INLINE JSValue getDirect(PropertyOffset offset) const { return locationForOffset(offset)-&gt;get(); }
 733     JSValue getDirectConcurrently(Structure* expectedStructure, PropertyOffset) const;
 734     void putDirect(VM&amp; vm, PropertyOffset offset, JSValue value) { locationForOffset(offset)-&gt;set(vm, this, value); }
 735     void putDirectWithoutBarrier(PropertyOffset offset, JSValue value) { locationForOffset(offset)-&gt;setWithoutWriteBarrier(value); }
 736     void putDirectUndefined(PropertyOffset offset) { locationForOffset(offset)-&gt;setUndefined(); }
 737 
 738     JS_EXPORT_PRIVATE bool putDirectNativeIntrinsicGetter(VM&amp;, JSGlobalObject*, Identifier, NativeFunction, Intrinsic, unsigned attributes);
<span class="line-added"> 739     JS_EXPORT_PRIVATE void putDirectNativeIntrinsicGetterWithoutTransition(VM&amp;, JSGlobalObject*, Identifier, NativeFunction, Intrinsic, unsigned attributes);</span>
 740     JS_EXPORT_PRIVATE bool putDirectNativeFunction(VM&amp;, JSGlobalObject*, const PropertyName&amp;, unsigned functionLength, NativeFunction, Intrinsic, unsigned attributes);
 741     JS_EXPORT_PRIVATE bool putDirectNativeFunction(VM&amp;, JSGlobalObject*, const PropertyName&amp;, unsigned functionLength, NativeFunction, Intrinsic, const DOMJIT::Signature*, unsigned attributes);
 742     JS_EXPORT_PRIVATE void putDirectNativeFunctionWithoutTransition(VM&amp;, JSGlobalObject*, const PropertyName&amp;, unsigned functionLength, NativeFunction, Intrinsic, unsigned attributes);
 743 
 744     JS_EXPORT_PRIVATE JSFunction* putDirectBuiltinFunction(VM&amp;, JSGlobalObject*, const PropertyName&amp;, FunctionExecutable*, unsigned attributes);
 745     JSFunction* putDirectBuiltinFunctionWithoutTransition(VM&amp;, JSGlobalObject*, const PropertyName&amp;, FunctionExecutable*, unsigned attributes);
 746 
 747     JS_EXPORT_PRIVATE static bool defineOwnProperty(JSObject*, ExecState*, PropertyName, const PropertyDescriptor&amp;, bool shouldThrow);
 748 
 749     bool isEnvironment() const;
 750     bool isGlobalObject() const;
 751     bool isJSLexicalEnvironment() const;
 752     bool isGlobalLexicalEnvironment() const;
 753     bool isStrictEvalActivation() const;
 754     bool isWithScope() const;
 755 
 756     bool isErrorInstance() const;
 757 
 758     JS_EXPORT_PRIVATE void seal(VM&amp;);
 759     JS_EXPORT_PRIVATE void freeze(VM&amp;);
 760     JS_EXPORT_PRIVATE static bool preventExtensions(JSObject*, ExecState*);
 761     JS_EXPORT_PRIVATE static bool isExtensible(JSObject*, ExecState*);
 762     bool isSealed(VM&amp; vm) { return structure(vm)-&gt;isSealed(vm); }
 763     bool isFrozen(VM&amp; vm) { return structure(vm)-&gt;isFrozen(vm); }
 764 
<span class="line-modified"> 765     JS_EXPORT_PRIVATE bool anyObjectInChainMayInterceptIndexedAccesses(VM&amp;) const;</span>
 766     JS_EXPORT_PRIVATE bool prototypeChainMayInterceptStoreTo(VM&amp;, PropertyName);
 767     bool needsSlowPutIndexing(VM&amp;) const;
 768 
 769 private:
 770     NonPropertyTransition suggestedArrayStorageTransition(VM&amp;) const;
 771 public:
 772     // You should only call isStructureExtensible() when:
 773     // - Performing this check in a way that isn&#39;t described in the specification
 774     //   as calling the virtual [[IsExtensible]] trap.
 775     // - When you&#39;re guaranteed that object-&gt;methodTable(vm)-&gt;isExtensible isn&#39;t
 776     //   overridden.
 777     ALWAYS_INLINE bool isStructureExtensible(VM&amp; vm) { return structure(vm)-&gt;isStructureExtensible(); }
 778     // You should call this when performing [[IsExtensible]] trap in a place
 779     // that is described in the specification. This performs the fully virtual
 780     // [[IsExtensible]] trap.
 781     bool isExtensible(ExecState*);
 782     bool indexingShouldBeSparse(VM&amp; vm)
 783     {
 784         return !isStructureExtensible(vm)
 785             || structure(vm)-&gt;typeInfo().interceptsGetOwnPropertySlotByIndexEvenWhenLengthIsNotZero();
</pre>
<hr />
<pre>
1405     if (structure-&gt;isUncacheableDictionary())
1406         slot.setCustom(this, attributes, customGetterSetter-&gt;getter());
1407     else
1408         slot.setCacheableCustom(this, attributes, customGetterSetter-&gt;getter());
1409 }
1410 
1411 // It may seem crazy to inline a function this large, especially a virtual function,
1412 // but it makes a big difference to property lookup that derived classes can inline their
1413 // base class call to this.
1414 ALWAYS_INLINE bool JSObject::getOwnPropertySlot(JSObject* object, ExecState* exec, PropertyName propertyName, PropertySlot&amp; slot)
1415 {
1416     VM&amp; vm = exec-&gt;vm();
1417     Structure* structure = object-&gt;structure(vm);
1418     if (object-&gt;getOwnNonIndexPropertySlot(vm, structure, propertyName, slot))
1419         return true;
1420     if (Optional&lt;uint32_t&gt; index = parseIndex(propertyName))
1421         return getOwnPropertySlotByIndex(object, exec, index.value(), slot);
1422     return false;
1423 }
1424 
<span class="line-added">1425 ALWAYS_INLINE void JSObject::doPutPropertySecurityCheck(JSObject*, ExecState*, PropertyName, PutPropertySlot&amp;)</span>
<span class="line-added">1426 {</span>
<span class="line-added">1427 }</span>
<span class="line-added">1428 </span>
1429 // It may seem crazy to inline a function this large but it makes a big difference
1430 // since this is function very hot in variable lookup
1431 template&lt;bool checkNullStructure&gt;
1432 ALWAYS_INLINE bool JSObject::getPropertySlot(ExecState* exec, PropertyName propertyName, PropertySlot&amp; slot)
1433 {
1434     VM&amp; vm = exec-&gt;vm();
1435     auto&amp; structureIDTable = vm.heap.structureIDTable();
1436     JSObject* object = this;
1437     while (true) {
1438         if (UNLIKELY(TypeInfo::overridesGetOwnPropertySlot(object-&gt;inlineTypeFlags()))) {
1439             // If propertyName is an index then we may have missed it (as this loop is using
1440             // getOwnNonIndexPropertySlot), so we cannot safely call the overridden getOwnPropertySlot
1441             // (lest we return a property from a prototype that is shadowed). Check now for an index,
1442             // if so we need to start afresh from this object.
1443             if (Optional&lt;uint32_t&gt; index = parseIndex(propertyName))
1444                 return getPropertySlot(exec, index.value(), slot);
1445             // Safe to continue searching from current position; call getNonIndexPropertySlot to avoid
1446             // parsing the int again.
1447             return object-&gt;getNonIndexPropertySlot(exec, propertyName, slot);
1448         }
</pre>
<hr />
<pre>
1533 }
1534 
1535 ALWAYS_INLINE JSObject* Register::object() const
1536 {
1537     return asObject(jsValue());
1538 }
1539 
1540 ALWAYS_INLINE Register&amp; Register::operator=(JSObject* object)
1541 {
1542     u.value = JSValue::encode(JSValue(object));
1543     return *this;
1544 }
1545 
1546 inline size_t offsetInButterfly(PropertyOffset offset)
1547 {
1548     return offsetInOutOfLineStorage(offset) + Butterfly::indexOfPropertyStorage();
1549 }
1550 
1551 inline size_t JSObject::butterflyPreCapacity()
1552 {
<span class="line-modified">1553     VM&amp; vm = this-&gt;vm();</span>
1554     if (UNLIKELY(hasIndexingHeader(vm)))
1555         return butterfly()-&gt;indexingHeader()-&gt;preCapacity(structure(vm));
1556     return 0;
1557 }
1558 
1559 inline size_t JSObject::butterflyTotalSize()
1560 {
<span class="line-modified">1561     VM&amp; vm = this-&gt;vm();</span>
1562     Structure* structure = this-&gt;structure(vm);
1563     Butterfly* butterfly = this-&gt;butterfly();
1564     size_t preCapacity;
1565     size_t indexingPayloadSizeInBytes;
1566     bool hasIndexingHeader = this-&gt;hasIndexingHeader(vm);
1567 
1568     if (UNLIKELY(hasIndexingHeader)) {
1569         preCapacity = butterfly-&gt;indexingHeader()-&gt;preCapacity(structure);
1570         indexingPayloadSizeInBytes = butterfly-&gt;indexingHeader()-&gt;indexingPayloadSizeInBytes(structure);
1571     } else {
1572         preCapacity = 0;
1573         indexingPayloadSizeInBytes = 0;
1574     }
1575 
1576     return Butterfly::totalSize(preCapacity, structure-&gt;outOfLineCapacity(), hasIndexingHeader, indexingPayloadSizeInBytes);
1577 }
1578 
1579 inline int indexRelativeToBase(PropertyOffset offset)
1580 {
1581     if (isOutOfLineOffset(offset))
</pre>
<hr />
<pre>
1590         return offsetInOutOfLineStorage(offset) * sizeof(EncodedJSValue) + Butterfly::offsetOfPropertyStorage();
1591     return JSObject::offsetOfInlineStorage() + offsetInInlineStorage(offset) * sizeof(EncodedJSValue);
1592 }
1593 
1594 // Returns the maximum offset (away from zero) a load instruction will encode.
1595 inline size_t maxOffsetRelativeToBase(PropertyOffset offset)
1596 {
1597     ptrdiff_t addressOffset = offsetRelativeToBase(offset);
1598 #if USE(JSVALUE32_64)
1599     if (addressOffset &gt;= 0)
1600         return static_cast&lt;size_t&gt;(addressOffset) + OBJECT_OFFSETOF(EncodedValueDescriptor, asBits.tag);
1601 #endif
1602     return static_cast&lt;size_t&gt;(addressOffset);
1603 }
1604 
1605 COMPILE_ASSERT(!(sizeof(JSObject) % sizeof(WriteBarrierBase&lt;Unknown&gt;)), JSObject_inline_storage_has_correct_alignment);
1606 
1607 template&lt;unsigned charactersCount&gt;
1608 ALWAYS_INLINE Identifier makeIdentifier(VM&amp; vm, const char (&amp;characters)[charactersCount])
1609 {
<span class="line-modified">1610     return Identifier::fromString(vm, characters);</span>
1611 }
1612 
1613 ALWAYS_INLINE Identifier makeIdentifier(VM&amp; vm, const char* name)
1614 {
<span class="line-modified">1615     return Identifier::fromString(vm, name);</span>
1616 }
1617 
1618 ALWAYS_INLINE Identifier makeIdentifier(VM&amp;, const Identifier&amp; name)
1619 {
1620     return name;
1621 }
1622 
1623 bool validateAndApplyPropertyDescriptor(ExecState*, JSObject*, PropertyName, bool isExtensible,
1624     const PropertyDescriptor&amp; descriptor, bool isCurrentDefined, const PropertyDescriptor&amp; current, bool throwException);
1625 
1626 JS_EXPORT_PRIVATE NEVER_INLINE bool ordinarySetSlow(ExecState*, JSObject*, PropertyName, JSValue, JSValue receiver, bool shouldThrow);
1627 
1628 // Helper for defining native functions, if you&#39;re not using a static hash table.
1629 // Use this macro from within finishCreation() methods in prototypes. This assumes
1630 // you&#39;ve defined variables called exec, globalObject, and vm, and they
1631 // have the expected meanings.
1632 #define JSC_NATIVE_INTRINSIC_FUNCTION(jsName, cppName, attributes, length, intrinsic) \
1633     putDirectNativeFunction(\
1634         vm, globalObject, makeIdentifier(vm, (jsName)), (length), cppName, \
1635         (intrinsic), (attributes))
</pre>
<hr />
<pre>
1646 
1647 #define JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION(jsName, cppName, attributes, length) \
1648     JSC_NATIVE_INTRINSIC_FUNCTION_WITHOUT_TRANSITION(jsName, cppName, (attributes), (length), NoIntrinsic)
1649 
1650 // Identical helpers but for builtins. Note that currently, we don&#39;t support builtins that are
1651 // also intrinsics, but we probably will do that eventually.
1652 #define JSC_BUILTIN_FUNCTION(jsName, generatorName, attributes) \
1653     putDirectBuiltinFunction(\
1654         vm, globalObject, makeIdentifier(vm, (jsName)), (generatorName)(vm), (attributes))
1655 
1656 #define JSC_BUILTIN_FUNCTION_WITHOUT_TRANSITION(jsName, generatorName, attributes) \
1657     putDirectBuiltinFunctionWithoutTransition(\
1658         vm, globalObject, makeIdentifier(vm, (jsName)), (generatorName)(vm), (attributes))
1659 
1660 // Helper for defining native getters on properties.
1661 #define JSC_NATIVE_INTRINSIC_GETTER(jsName, cppName, attributes, intrinsic)  \
1662     putDirectNativeIntrinsicGetter(\
1663         vm, globalObject, makeIdentifier(vm, (jsName)), (cppName), \
1664         (intrinsic), ((attributes) | PropertyAttribute::Accessor))
1665 
<span class="line-added">1666 #define JSC_NATIVE_INTRINSIC_GETTER_WITHOUT_TRANSITION(jsName, cppName, attributes, intrinsic)  \</span>
<span class="line-added">1667     putDirectNativeIntrinsicGetterWithoutTransition(\</span>
<span class="line-added">1668         vm, globalObject, makeIdentifier(vm, (jsName)), (cppName), \</span>
<span class="line-added">1669         (intrinsic), ((attributes) | PropertyAttribute::Accessor))</span>
<span class="line-added">1670 </span>
1671 #define JSC_NATIVE_GETTER(jsName, cppName, attributes) \
1672     JSC_NATIVE_INTRINSIC_GETTER((jsName), (cppName), (attributes), NoIntrinsic)
1673 
<span class="line-added">1674 #define JSC_NATIVE_GETTER_WITHOUT_TRANSITION(jsName, cppName, attributes) \</span>
<span class="line-added">1675     JSC_NATIVE_INTRINSIC_GETTER_WITHOUT_TRANSITION((jsName), (cppName), (attributes), NoIntrinsic)</span>
<span class="line-added">1676 </span>
1677 } // namespace JSC
</pre>
</td>
</tr>
</table>
<center><a href="JSObject.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="JSObjectInlines.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>