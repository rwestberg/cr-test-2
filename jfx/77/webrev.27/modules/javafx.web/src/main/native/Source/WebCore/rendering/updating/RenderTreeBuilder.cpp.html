<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/rendering/updating/RenderTreeBuilder.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2017 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;RenderTreeBuilder.h&quot;
 28 
 29 #include &quot;AXObjectCache.h&quot;
 30 #include &quot;Frame.h&quot;
 31 #include &quot;FrameSelection.h&quot;
 32 #include &quot;RenderButton.h&quot;
 33 #include &quot;RenderCounter.h&quot;
 34 #include &quot;RenderElement.h&quot;
 35 #include &quot;RenderFullScreen.h&quot;
 36 #include &quot;RenderGrid.h&quot;
 37 #include &quot;RenderLineBreak.h&quot;
 38 #include &quot;RenderMathMLFenced.h&quot;
 39 #include &quot;RenderMenuList.h&quot;
 40 #include &quot;RenderMultiColumnFlow.h&quot;
 41 #include &quot;RenderRuby.h&quot;
 42 #include &quot;RenderRubyBase.h&quot;
 43 #include &quot;RenderRubyRun.h&quot;
 44 #include &quot;RenderSVGContainer.h&quot;
 45 #include &quot;RenderSVGInline.h&quot;
 46 #include &quot;RenderSVGRoot.h&quot;
 47 #include &quot;RenderSVGText.h&quot;
 48 #include &quot;RenderTable.h&quot;
 49 #include &quot;RenderTableRow.h&quot;
 50 #include &quot;RenderTableSection.h&quot;
 51 #include &quot;RenderText.h&quot;
 52 #include &quot;RenderTextFragment.h&quot;
 53 #include &quot;RenderTreeBuilderBlock.h&quot;
 54 #include &quot;RenderTreeBuilderBlockFlow.h&quot;
 55 #include &quot;RenderTreeBuilderContinuation.h&quot;
 56 #include &quot;RenderTreeBuilderFirstLetter.h&quot;
 57 #include &quot;RenderTreeBuilderFormControls.h&quot;
 58 #include &quot;RenderTreeBuilderFullScreen.h&quot;
 59 #include &quot;RenderTreeBuilderInline.h&quot;
 60 #include &quot;RenderTreeBuilderList.h&quot;
 61 #include &quot;RenderTreeBuilderMathML.h&quot;
 62 #include &quot;RenderTreeBuilderMultiColumn.h&quot;
 63 #include &quot;RenderTreeBuilderRuby.h&quot;
 64 #include &quot;RenderTreeBuilderSVG.h&quot;
 65 #include &quot;RenderTreeBuilderTable.h&quot;
 66 
 67 namespace WebCore {
 68 
 69 RenderTreeBuilder* RenderTreeBuilder::s_current;
 70 
 71 static void markBoxForRelayoutAfterSplit(RenderBox&amp; box)
 72 {
 73     // FIXME: The table code should handle that automatically. If not,
 74     // we should fix it and remove the table part checks.
 75     if (is&lt;RenderTable&gt;(box)) {
 76         // Because we may have added some sections with already computed column structures, we need to
 77         // sync the table structure with them now. This avoids crashes when adding new cells to the table.
 78         downcast&lt;RenderTable&gt;(box).forceSectionsRecalc();
 79     } else if (is&lt;RenderTableSection&gt;(box))
 80         downcast&lt;RenderTableSection&gt;(box).setNeedsCellRecalc();
 81 
 82     box.setNeedsLayoutAndPrefWidthsRecalc();
 83 }
 84 
 85 static void getInlineRun(RenderObject* start, RenderObject* boundary, RenderObject*&amp; inlineRunStart, RenderObject*&amp; inlineRunEnd)
 86 {
 87     // Beginning at |start| we find the largest contiguous run of inlines that
 88     // we can. We denote the run with start and end points, |inlineRunStart|
 89     // and |inlineRunEnd|. Note that these two values may be the same if
 90     // we encounter only one inline.
 91     //
 92     // We skip any non-inlines we encounter as long as we haven&#39;t found any
 93     // inlines yet.
 94     //
 95     // |boundary| indicates a non-inclusive boundary point. Regardless of whether |boundary|
 96     // is inline or not, we will not include it in a run with inlines before it. It&#39;s as though we encountered
 97     // a non-inline.
 98 
 99     // Start by skipping as many non-inlines as we can.
100     auto* curr = start;
101     bool sawInline;
102     do {
103         while (curr &amp;&amp; !(curr-&gt;isInline() || curr-&gt;isFloatingOrOutOfFlowPositioned()))
104             curr = curr-&gt;nextSibling();
105 
106         inlineRunStart = inlineRunEnd = curr;
107 
108         if (!curr)
109             return; // No more inline children to be found.
110 
111         sawInline = curr-&gt;isInline();
112 
113         curr = curr-&gt;nextSibling();
114         while (curr &amp;&amp; (curr-&gt;isInline() || curr-&gt;isFloatingOrOutOfFlowPositioned()) &amp;&amp; (curr != boundary)) {
115             inlineRunEnd = curr;
116             if (curr-&gt;isInline())
117                 sawInline = true;
118             curr = curr-&gt;nextSibling();
119         }
120     } while (!sawInline);
121 }
122 
123 RenderTreeBuilder::RenderTreeBuilder(RenderView&amp; view)
124     : m_view(view)
125     , m_firstLetterBuilder(makeUnique&lt;FirstLetter&gt;(*this))
126     , m_listBuilder(makeUnique&lt;List&gt;(*this))
127     , m_multiColumnBuilder(makeUnique&lt;MultiColumn&gt;(*this))
128     , m_tableBuilder(makeUnique&lt;Table&gt;(*this))
129     , m_rubyBuilder(makeUnique&lt;Ruby&gt;(*this))
130     , m_formControlsBuilder(makeUnique&lt;FormControls&gt;(*this))
131     , m_blockBuilder(makeUnique&lt;Block&gt;(*this))
132     , m_blockFlowBuilder(makeUnique&lt;BlockFlow&gt;(*this))
133     , m_inlineBuilder(makeUnique&lt;Inline&gt;(*this))
134     , m_svgBuilder(makeUnique&lt;SVG&gt;(*this))
135 #if ENABLE(MATHML)
136     , m_mathMLBuilder(makeUnique&lt;MathML&gt;(*this))
137 #endif
138     , m_continuationBuilder(makeUnique&lt;Continuation&gt;(*this))
139 #if ENABLE(FULLSCREEN_API)
140     , m_fullScreenBuilder(makeUnique&lt;FullScreen&gt;(*this))
141 #endif
142 {
143     RELEASE_ASSERT(!s_current || &amp;m_view != &amp;s_current-&gt;m_view);
144     m_previous = s_current;
145     s_current = this;
146 }
147 
148 RenderTreeBuilder::~RenderTreeBuilder()
149 {
150     s_current = m_previous;
151 }
152 
153 void RenderTreeBuilder::destroy(RenderObject&amp; renderer)
154 {
155     ASSERT(renderer.parent());
156     auto toDestroy = detach(*renderer.parent(), renderer);
157 
158 #if ENABLE(FULLSCREEN_API)
159     if (is&lt;RenderFullScreen&gt;(renderer))
160         fullScreenBuilder().cleanupOnDestroy(downcast&lt;RenderFullScreen&gt;(renderer));
161 #endif
162 
163     if (is&lt;RenderTextFragment&gt;(renderer))
164         firstLetterBuilder().cleanupOnDestroy(downcast&lt;RenderTextFragment&gt;(renderer));
165 
166     if (is&lt;RenderBoxModelObject&gt;(renderer))
167         continuationBuilder().cleanupOnDestroy(downcast&lt;RenderBoxModelObject&gt;(renderer));
168 
169     // We need to detach the subtree first so that the descendants don&#39;t have
170     // access to previous/next sublings at detach().
171     // FIXME: webkit.org/b/182909.
172     if (!is&lt;RenderElement&gt;(toDestroy.get()))
173         return;
174 
175     auto&amp; childToDestroy = downcast&lt;RenderElement&gt;(*toDestroy.get());
176     while (childToDestroy.firstChild()) {
177         auto&amp; firstChild = *childToDestroy.firstChild();
178         if (auto* node = firstChild.node())
179             node-&gt;setRenderer(nullptr);
180         destroy(firstChild);
181     }
182 }
183 
184 void RenderTreeBuilder::attach(RenderElement&amp; parent, RenderPtr&lt;RenderObject&gt; child, RenderObject* beforeChild)
185 {
186     auto insertRecursiveIfNeeded = [&amp;](RenderElement&amp; parentCandidate) {
187         if (&amp;parent == &amp;parentCandidate) {
188             attachToRenderElement(parent, WTFMove(child), beforeChild);
189             return;
190         }
191         attach(parentCandidate, WTFMove(child), beforeChild);
192     };
193 
194     ASSERT(&amp;parent.view() == &amp;m_view);
195 
196     if (is&lt;RenderText&gt;(beforeChild)) {
197         if (auto* wrapperInline = downcast&lt;RenderText&gt;(*beforeChild).inlineWrapperForDisplayContents())
198             beforeChild = wrapperInline;
199     }
200 
201     if (is&lt;RenderTableRow&gt;(parent)) {
202         auto&amp; parentCandidate = tableBuilder().findOrCreateParentForChild(downcast&lt;RenderTableRow&gt;(parent), *child, beforeChild);
203         if (&amp;parentCandidate == &amp;parent) {
204             tableBuilder().attach(downcast&lt;RenderTableRow&gt;(parentCandidate), WTFMove(child), beforeChild);
205             return;
206         }
207         insertRecursiveIfNeeded(parentCandidate);
208         return;
209     }
210 
211     if (is&lt;RenderTableSection&gt;(parent)) {
212         auto&amp; parentCandidate = tableBuilder().findOrCreateParentForChild(downcast&lt;RenderTableSection&gt;(parent), *child, beforeChild);
213         if (&amp;parent == &amp;parentCandidate) {
214             tableBuilder().attach(downcast&lt;RenderTableSection&gt;(parent), WTFMove(child), beforeChild);
215             return;
216         }
217         insertRecursiveIfNeeded(parentCandidate);
218         return;
219     }
220 
221     if (is&lt;RenderTable&gt;(parent)) {
222         auto&amp; parentCandidate = tableBuilder().findOrCreateParentForChild(downcast&lt;RenderTable&gt;(parent), *child, beforeChild);
223         if (&amp;parentCandidate == &amp;parent) {
224             tableBuilder().attach(downcast&lt;RenderTable&gt;(parentCandidate), WTFMove(child), beforeChild);
225             return;
226         }
227         insertRecursiveIfNeeded(parentCandidate);
228         return;
229     }
230 
231     if (is&lt;RenderRubyAsBlock&gt;(parent)) {
232         insertRecursiveIfNeeded(rubyBuilder().findOrCreateParentForChild(downcast&lt;RenderRubyAsBlock&gt;(parent), *child, beforeChild));
233         return;
234     }
235 
236     if (is&lt;RenderRubyAsInline&gt;(parent)) {
237         insertRecursiveIfNeeded(rubyBuilder().findOrCreateParentForChild(downcast&lt;RenderRubyAsInline&gt;(parent), *child, beforeChild));
238         return;
239     }
240 
241     if (is&lt;RenderRubyRun&gt;(parent)) {
242         rubyBuilder().attach(downcast&lt;RenderRubyRun&gt;(parent), WTFMove(child), beforeChild);
243         return;
244     }
245 
246     if (is&lt;RenderButton&gt;(parent)) {
247         formControlsBuilder().attach(downcast&lt;RenderButton&gt;(parent), WTFMove(child), beforeChild);
248         return;
249     }
250 
251     if (is&lt;RenderMenuList&gt;(parent)) {
252         formControlsBuilder().attach(downcast&lt;RenderMenuList&gt;(parent), WTFMove(child), beforeChild);
253         return;
254     }
255 
256     if (is&lt;RenderSVGContainer&gt;(parent)) {
257         svgBuilder().attach(downcast&lt;RenderSVGContainer&gt;(parent), WTFMove(child), beforeChild);
258         return;
259     }
260 
261     if (is&lt;RenderSVGInline&gt;(parent)) {
262         svgBuilder().attach(downcast&lt;RenderSVGInline&gt;(parent), WTFMove(child), beforeChild);
263         return;
264     }
265 
266     if (is&lt;RenderSVGRoot&gt;(parent)) {
267         svgBuilder().attach(downcast&lt;RenderSVGRoot&gt;(parent), WTFMove(child), beforeChild);
268         return;
269     }
270 
271     if (is&lt;RenderSVGText&gt;(parent)) {
272         svgBuilder().attach(downcast&lt;RenderSVGText&gt;(parent), WTFMove(child), beforeChild);
273         return;
274     }
275 
276 #if ENABLE(MATHML)
277     if (is&lt;RenderMathMLFenced&gt;(parent)) {
278         mathMLBuilder().attach(downcast&lt;RenderMathMLFenced&gt;(parent), WTFMove(child), beforeChild);
279         return;
280     }
281 #endif
282 
283     if (is&lt;RenderGrid&gt;(parent)) {
284         attachToRenderGrid(downcast&lt;RenderGrid&gt;(parent), WTFMove(child), beforeChild);
285         return;
286     }
287 
288     if (is&lt;RenderBlockFlow&gt;(parent)) {
289         blockFlowBuilder().attach(downcast&lt;RenderBlockFlow&gt;(parent), WTFMove(child), beforeChild);
290         return;
291     }
292 
293     if (is&lt;RenderBlock&gt;(parent)) {
294         blockBuilder().attach(downcast&lt;RenderBlock&gt;(parent), WTFMove(child), beforeChild);
295         return;
296     }
297 
298     if (is&lt;RenderInline&gt;(parent)) {
299         inlineBuilder().attach(downcast&lt;RenderInline&gt;(parent), WTFMove(child), beforeChild);
300         return;
301     }
302 
303     attachToRenderElement(parent, WTFMove(child), beforeChild);
304 }
305 
306 void RenderTreeBuilder::attachIgnoringContinuation(RenderElement&amp; parent, RenderPtr&lt;RenderObject&gt; child, RenderObject* beforeChild)
307 {
308     if (is&lt;RenderInline&gt;(parent)) {
309         inlineBuilder().attachIgnoringContinuation(downcast&lt;RenderInline&gt;(parent), WTFMove(child), beforeChild);
310         return;
311     }
312 
313     if (is&lt;RenderBlock&gt;(parent)) {
314         blockBuilder().attachIgnoringContinuation(downcast&lt;RenderBlock&gt;(parent), WTFMove(child), beforeChild);
315         return;
316     }
317 
318     attach(parent, WTFMove(child), beforeChild);
319 }
320 
321 RenderPtr&lt;RenderObject&gt; RenderTreeBuilder::detach(RenderElement&amp; parent, RenderObject&amp; child, CanCollapseAnonymousBlock canCollapseAnonymousBlock)
322 {
323     if (is&lt;RenderRubyAsInline&gt;(parent))
324         return rubyBuilder().detach(downcast&lt;RenderRubyAsInline&gt;(parent), child);
325 
326     if (is&lt;RenderRubyAsBlock&gt;(parent))
327         return rubyBuilder().detach(downcast&lt;RenderRubyAsBlock&gt;(parent), child);
328 
329     if (is&lt;RenderRubyRun&gt;(parent))
330         return rubyBuilder().detach(downcast&lt;RenderRubyRun&gt;(parent), child);
331 
332     if (is&lt;RenderMenuList&gt;(parent))
333         return formControlsBuilder().detach(downcast&lt;RenderMenuList&gt;(parent), child);
334 
335     if (is&lt;RenderButton&gt;(parent))
336         return formControlsBuilder().detach(downcast&lt;RenderButton&gt;(parent), child);
337 
338     if (is&lt;RenderGrid&gt;(parent))
339         return detachFromRenderGrid(downcast&lt;RenderGrid&gt;(parent), child);
340 
341     if (is&lt;RenderSVGText&gt;(parent))
342         return svgBuilder().detach(downcast&lt;RenderSVGText&gt;(parent), child);
343 
344     if (is&lt;RenderSVGInline&gt;(parent))
345         return svgBuilder().detach(downcast&lt;RenderSVGInline&gt;(parent), child);
346 
347     if (is&lt;RenderSVGContainer&gt;(parent))
348         return svgBuilder().detach(downcast&lt;RenderSVGContainer&gt;(parent), child);
349 
350     if (is&lt;RenderSVGRoot&gt;(parent))
351         return svgBuilder().detach(downcast&lt;RenderSVGRoot&gt;(parent), child);
352 
353     if (is&lt;RenderBlockFlow&gt;(parent))
354         return blockBuilder().detach(downcast&lt;RenderBlockFlow&gt;(parent), child, canCollapseAnonymousBlock);
355 
356     if (is&lt;RenderBlock&gt;(parent))
357         return blockBuilder().detach(downcast&lt;RenderBlock&gt;(parent), child, canCollapseAnonymousBlock);
358 
359     return detachFromRenderElement(parent, child);
360 }
361 
362 void RenderTreeBuilder::attach(RenderTreePosition&amp; position, RenderPtr&lt;RenderObject&gt; child)
363 {
364     attach(position.parent(), WTFMove(child), position.nextSibling());
365 }
366 
367 #if ENABLE(FULLSCREEN_API)
368 void RenderTreeBuilder::createPlaceholderForFullScreen(RenderFullScreen&amp; renderer, std::unique_ptr&lt;RenderStyle&gt; style, const LayoutRect&amp; frameRect)
369 {
370     fullScreenBuilder().createPlaceholder(renderer, WTFMove(style), frameRect);
371 }
372 #endif
373 
374 void RenderTreeBuilder::attachToRenderElement(RenderElement&amp; parent, RenderPtr&lt;RenderObject&gt; child, RenderObject* beforeChild)
375 {
376     if (tableBuilder().childRequiresTable(parent, *child)) {
377         RenderTable* table;
378         RenderObject* afterChild = beforeChild ? beforeChild-&gt;previousSibling() : parent.lastChild();
379         if (afterChild &amp;&amp; afterChild-&gt;isAnonymous() &amp;&amp; is&lt;RenderTable&gt;(*afterChild) &amp;&amp; !afterChild-&gt;isBeforeContent())
380             table = downcast&lt;RenderTable&gt;(afterChild);
381         else {
382             auto newTable = RenderTable::createAnonymousWithParentRenderer(parent);
383             table = newTable.get();
384             attach(parent, WTFMove(newTable), beforeChild);
385         }
386 
387         attach(*table, WTFMove(child));
388         return;
389     }
390     auto&amp; newChild = *child.get();
391     attachToRenderElementInternal(parent, WTFMove(child), beforeChild);
392     parent.didAttachChild(newChild, beforeChild);
393 }
394 
395 void RenderTreeBuilder::attachToRenderElementInternal(RenderElement&amp; parent, RenderPtr&lt;RenderObject&gt; child, RenderObject* beforeChild)
396 {
397     RELEASE_ASSERT_WITH_MESSAGE(!parent.view().frameView().layoutContext().layoutState(), &quot;Layout must not mutate render tree&quot;);
398     ASSERT(parent.canHaveChildren() || parent.canHaveGeneratedChildren());
399     ASSERT(!child-&gt;parent());
400     ASSERT(!parent.isRenderBlockFlow() || (!child-&gt;isTableSection() &amp;&amp; !child-&gt;isTableRow() &amp;&amp; !child-&gt;isTableCell()));
401 
402     while (beforeChild &amp;&amp; beforeChild-&gt;parent() &amp;&amp; beforeChild-&gt;parent() != &amp;parent)
403         beforeChild = beforeChild-&gt;parent();
404 
405     ASSERT(!beforeChild || beforeChild-&gt;parent() == &amp;parent);
406     ASSERT(!is&lt;RenderText&gt;(beforeChild) || !downcast&lt;RenderText&gt;(*beforeChild).inlineWrapperForDisplayContents());
407 
408     // Take the ownership.
409     auto* newChild = parent.attachRendererInternal(WTFMove(child), beforeChild);
410 
411     newChild-&gt;initializeFragmentedFlowStateOnInsertion();
412     if (!parent.renderTreeBeingDestroyed()) {
413         newChild-&gt;insertedIntoTree();
414 
415         auto* fragmentedFlow = newChild-&gt;enclosingFragmentedFlow();
416         if (is&lt;RenderMultiColumnFlow&gt;(fragmentedFlow))
417             multiColumnBuilder().multiColumnDescendantInserted(downcast&lt;RenderMultiColumnFlow&gt;(*fragmentedFlow), *newChild);
418 
419         if (is&lt;RenderElement&gt;(*newChild))
420             RenderCounter::rendererSubtreeAttached(downcast&lt;RenderElement&gt;(*newChild));
421     }
422 
423     newChild-&gt;setNeedsLayoutAndPrefWidthsRecalc();
424     parent.setPreferredLogicalWidthsDirty(true);
425     if (!parent.normalChildNeedsLayout())
426         parent.setChildNeedsLayout(); // We may supply the static position for an absolute positioned child.
427 
428     if (AXObjectCache* cache = parent.document().axObjectCache())
429         cache-&gt;childrenChanged(&amp;parent, newChild);
430     if (is&lt;RenderBlockFlow&gt;(parent))
431         downcast&lt;RenderBlockFlow&gt;(parent).invalidateLineLayoutPath();
432     if (parent.hasOutlineAutoAncestor() || parent.outlineStyleForRepaint().outlineStyleIsAuto() == OutlineIsAuto::On)
433         newChild-&gt;setHasOutlineAutoAncestor();
434 }
435 
436 void RenderTreeBuilder::move(RenderBoxModelObject&amp; from, RenderBoxModelObject&amp; to, RenderObject&amp; child, RenderObject* beforeChild, NormalizeAfterInsertion normalizeAfterInsertion)
437 {
438     // We assume that callers have cleared their positioned objects list for child moves so the
439     // positioned renderer maps don&#39;t become stale. It would be too slow to do the map lookup on each call.
440     ASSERT(normalizeAfterInsertion == NormalizeAfterInsertion::No || !is&lt;RenderBlock&gt;(from) || !downcast&lt;RenderBlock&gt;(from).hasPositionedObjects());
441 
442     ASSERT(&amp;from == child.parent());
443     ASSERT(!beforeChild || &amp;to == beforeChild-&gt;parent());
444     if (normalizeAfterInsertion == NormalizeAfterInsertion::Yes &amp;&amp; (to.isRenderBlock() || to.isRenderInline())) {
445         // Takes care of adding the new child correctly if toBlock and fromBlock
446         // have different kind of children (block vs inline).
447         auto childToMove = detachFromRenderElement(from, child);
448         attach(to, WTFMove(childToMove), beforeChild);
449     } else {
450         auto childToMove = detachFromRenderElement(from, child);
451         attachToRenderElementInternal(to, WTFMove(childToMove), beforeChild);
452     }
453 }
454 
455 void RenderTreeBuilder::move(RenderBoxModelObject&amp; from, RenderBoxModelObject&amp; to, RenderObject&amp; child, NormalizeAfterInsertion normalizeAfterInsertion)
456 {
457     move(from, to, child, nullptr, normalizeAfterInsertion);
458 }
459 
460 void RenderTreeBuilder::moveAllChildren(RenderBoxModelObject&amp; from, RenderBoxModelObject&amp; to, NormalizeAfterInsertion normalizeAfterInsertion)
461 {
462     moveAllChildren(from, to, nullptr, normalizeAfterInsertion);
463 }
464 
465 void RenderTreeBuilder::moveAllChildren(RenderBoxModelObject&amp; from, RenderBoxModelObject&amp; to, RenderObject* beforeChild, NormalizeAfterInsertion normalizeAfterInsertion)
466 {
467     moveChildren(from, to, from.firstChild(), nullptr, beforeChild, normalizeAfterInsertion);
468 }
469 
470 void RenderTreeBuilder::moveChildren(RenderBoxModelObject&amp; from, RenderBoxModelObject&amp; to, RenderObject* startChild, RenderObject* endChild, NormalizeAfterInsertion normalizeAfterInsertion)
471 {
472     moveChildren(from, to, startChild, endChild, nullptr, normalizeAfterInsertion);
473 }
474 
475 void RenderTreeBuilder::moveChildren(RenderBoxModelObject&amp; from, RenderBoxModelObject&amp; to, RenderObject* startChild, RenderObject* endChild, RenderObject* beforeChild, NormalizeAfterInsertion normalizeAfterInsertion)
476 {
477     // This condition is rarely hit since this function is usually called on
478     // anonymous blocks which can no longer carry positioned objects (see r120761)
479     // or when fullRemoveInsert is false.
480     if (normalizeAfterInsertion == NormalizeAfterInsertion::Yes &amp;&amp; is&lt;RenderBlock&gt;(from)) {
481         downcast&lt;RenderBlock&gt;(from).removePositionedObjects(nullptr);
482         if (is&lt;RenderBlockFlow&gt;(from))
483             downcast&lt;RenderBlockFlow&gt;(from).removeFloatingObjects();
484     }
485 
486     ASSERT(!beforeChild || &amp;to == beforeChild-&gt;parent());
487     for (RenderObject* child = startChild; child &amp;&amp; child != endChild; ) {
488         // Save our next sibling as moveChildTo will clear it.
489         RenderObject* nextSibling = child-&gt;nextSibling();
490 
491         // FIXME: This logic here fails to detect the first letter in certain cases
492         // and skips a valid sibling renderer (see webkit.org/b/163737).
493         // Check to make sure we&#39;re not saving the firstLetter as the nextSibling.
494         // When the |child| object will be moved, its firstLetter will be recreated,
495         // so saving it now in nextSibling would leave us with a stale object.
496         if (is&lt;RenderTextFragment&gt;(*child) &amp;&amp; is&lt;RenderText&gt;(nextSibling)) {
497             RenderObject* firstLetterObj = nullptr;
498             if (RenderBlock* block = downcast&lt;RenderTextFragment&gt;(*child).blockForAccompanyingFirstLetter()) {
499                 RenderElement* firstLetterContainer = nullptr;
500                 block-&gt;getFirstLetter(firstLetterObj, firstLetterContainer, child);
501             }
502 
503             // This is the first letter, skip it.
504             if (firstLetterObj == nextSibling)
505                 nextSibling = nextSibling-&gt;nextSibling();
506         }
507 
508         move(from, to, *child, beforeChild, normalizeAfterInsertion);
509         child = nextSibling;
510     }
511 }
512 
513 void RenderTreeBuilder::moveAllChildrenIncludingFloats(RenderBlock&amp; from, RenderBlock&amp; to, RenderTreeBuilder::NormalizeAfterInsertion normalizeAfterInsertion)
514 {
515     if (is&lt;RenderBlockFlow&gt;(from)) {
516         blockFlowBuilder().moveAllChildrenIncludingFloats(downcast&lt;RenderBlockFlow&gt;(from), to, normalizeAfterInsertion);
517         return;
518     }
519     moveAllChildren(from, to, normalizeAfterInsertion);
520 }
521 
522 void RenderTreeBuilder::normalizeTreeAfterStyleChange(RenderElement&amp; renderer, RenderStyle&amp; oldStyle)
523 {
524     if (!renderer.parent())
525         return;
526 
527     auto&amp; parent = *renderer.parent();
528 
529     bool wasFloating = oldStyle.isFloating();
530     bool wasOufOfFlowPositioned = oldStyle.hasOutOfFlowPosition();
531     bool isFloating = renderer.style().isFloating();
532     bool isOutOfFlowPositioned = renderer.style().hasOutOfFlowPosition();
533     bool startsAffectingParent = false;
534     bool noLongerAffectsParent = false;
535 
536     if (is&lt;RenderBlock&gt;(parent))
537         noLongerAffectsParent = (!wasFloating &amp;&amp; isFloating) || (!wasOufOfFlowPositioned &amp;&amp; isOutOfFlowPositioned);
538 
539     if (is&lt;RenderBlockFlow&gt;(parent) || is&lt;RenderInline&gt;(parent)) {
540         startsAffectingParent = (wasFloating || wasOufOfFlowPositioned) &amp;&amp; !isFloating &amp;&amp; !isOutOfFlowPositioned;
541         ASSERT(!startsAffectingParent || !noLongerAffectsParent);
542     }
543 
544     if (startsAffectingParent) {
545         // We have gone from not affecting the inline status of the parent flow to suddenly
546         // having an impact. See if there is a mismatch between the parent flow&#39;s
547         // childrenInline() state and our state.
548         // FIXME(186894): startsAffectingParent has clearly nothing to do with resetting the inline state.
549         if (!is&lt;RenderSVGInline&gt;(renderer))
550             renderer.setInline(renderer.style().isDisplayInlineType());
551         if (renderer.isInline() != renderer.parent()-&gt;childrenInline())
552             childFlowStateChangesAndAffectsParentBlock(renderer);
553         return;
554     }
555 
556     if (noLongerAffectsParent) {
557         childFlowStateChangesAndNoLongerAffectsParentBlock(renderer);
558 
559         if (is&lt;RenderBlockFlow&gt;(renderer)) {
560             // Fresh floats need to be reparented if they actually belong to the previous anonymous block.
561             // It copies the logic of RenderBlock::addChildIgnoringContinuation
562             if (isFloating &amp;&amp; renderer.previousSibling() &amp;&amp; renderer.previousSibling()-&gt;isAnonymousBlock())
563                 move(downcast&lt;RenderBoxModelObject&gt;(parent), downcast&lt;RenderBoxModelObject&gt;(*renderer.previousSibling()), renderer, RenderTreeBuilder::NormalizeAfterInsertion::No);
564         }
565     }
566 }
567 
568 void RenderTreeBuilder::makeChildrenNonInline(RenderBlock&amp; parent, RenderObject* insertionPoint)
569 {
570     // makeChildrenNonInline takes a block whose children are *all* inline and it
571     // makes sure that inline children are coalesced under anonymous
572     // blocks. If |insertionPoint| is defined, then it represents the insertion point for
573     // the new block child that is causing us to have to wrap all the inlines. This
574     // means that we cannot coalesce inlines before |insertionPoint| with inlines following
575     // |insertionPoint|, because the new child is going to be inserted in between the inlines,
576     // splitting them.
577     ASSERT(parent.isInlineBlockOrInlineTable() || !parent.isInline());
578     ASSERT(!insertionPoint || insertionPoint-&gt;parent() == &amp;parent);
579 
580     parent.setChildrenInline(false);
581 
582     auto* child = parent.firstChild();
583     if (!child)
584         return;
585 
586     parent.deleteLines();
587 
588     while (child) {
589         RenderObject* inlineRunStart = nullptr;
590         RenderObject* inlineRunEnd = nullptr;
591         getInlineRun(child, insertionPoint, inlineRunStart, inlineRunEnd);
592 
593         if (!inlineRunStart)
594             break;
595 
596         child = inlineRunEnd-&gt;nextSibling();
597 
598         auto newBlock = parent.createAnonymousBlock();
599         auto&amp; block = *newBlock;
600         attachToRenderElementInternal(parent, WTFMove(newBlock), inlineRunStart);
601         moveChildren(parent, block, inlineRunStart, child, RenderTreeBuilder::NormalizeAfterInsertion::No);
602     }
603 #ifndef NDEBUG
604     for (RenderObject* c = parent.firstChild(); c; c = c-&gt;nextSibling())
605         ASSERT(!c-&gt;isInline());
606 #endif
607     parent.repaint();
608 }
609 
610 RenderObject* RenderTreeBuilder::splitAnonymousBoxesAroundChild(RenderBox&amp; parent, RenderObject&amp; originalBeforeChild)
611 {
612     // Adjust beforeChild if it is a column spanner and has been moved out of its original position.
613     auto* beforeChild = RenderTreeBuilder::MultiColumn::adjustBeforeChildForMultiColumnSpannerIfNeeded(originalBeforeChild);
614     bool didSplitParentAnonymousBoxes = false;
615 
616     while (beforeChild-&gt;parent() != &amp;parent) {
617         auto&amp; boxToSplit = downcast&lt;RenderBox&gt;(*beforeChild-&gt;parent());
618         if (boxToSplit.firstChild() != beforeChild &amp;&amp; boxToSplit.isAnonymous()) {
619             didSplitParentAnonymousBoxes = true;
620 
621             // We have to split the parent box into two boxes and move children
622             // from |beforeChild| to end into the new post box.
623             auto newPostBox = boxToSplit.createAnonymousBoxWithSameTypeAs(parent);
624             auto&amp; postBox = *newPostBox;
625             postBox.setChildrenInline(boxToSplit.childrenInline());
626             RenderBox* parentBox = downcast&lt;RenderBox&gt;(boxToSplit.parent());
627             // We need to invalidate the |parentBox| before inserting the new node
628             // so that the table repainting logic knows the structure is dirty.
629             // See for example RenderTableCell:clippedOverflowRectForRepaint.
630             markBoxForRelayoutAfterSplit(*parentBox);
631             attachToRenderElementInternal(*parentBox, WTFMove(newPostBox), boxToSplit.nextSibling());
632             moveChildren(boxToSplit, postBox, beforeChild, nullptr, RenderTreeBuilder::NormalizeAfterInsertion::Yes);
633 
634             markBoxForRelayoutAfterSplit(boxToSplit);
635             markBoxForRelayoutAfterSplit(postBox);
636 
637             beforeChild = &amp;postBox;
638         } else
639             beforeChild = &amp;boxToSplit;
640     }
641 
642     if (didSplitParentAnonymousBoxes)
643         markBoxForRelayoutAfterSplit(parent);
644 
645     ASSERT(beforeChild-&gt;parent() == &amp;parent);
646     return beforeChild;
647 }
648 
649 void RenderTreeBuilder::childFlowStateChangesAndAffectsParentBlock(RenderElement&amp; child)
650 {
651     auto* parent = child.parent();
652     if (!child.isInline()) {
653         if (is&lt;RenderBlock&gt;(parent))
654             blockBuilder().childBecameNonInline(downcast&lt;RenderBlock&gt;(*parent), child);
655         else if (is&lt;RenderInline&gt;(*parent))
656             inlineBuilder().childBecameNonInline(downcast&lt;RenderInline&gt;(*parent), child);
657 
658         // childBecameNonInline might have re-parented us.
659         if (auto* newParent = child.parent()) {
660             // We need to re-run the grid items placement if it had gained a new item.
661             if (newParent != parent &amp;&amp; is&lt;RenderGrid&gt;(*newParent))
662                 downcast&lt;RenderGrid&gt;(*newParent).dirtyGrid();
663         }
664     } else {
665         // An anonymous block must be made to wrap this inline.
666         auto newBlock = downcast&lt;RenderBlock&gt;(*parent).createAnonymousBlock();
667         auto&amp; block = *newBlock;
668         attachToRenderElementInternal(*parent, WTFMove(newBlock), &amp;child);
669         auto thisToMove = detachFromRenderElement(*parent, child);
670         attachToRenderElementInternal(block, WTFMove(thisToMove));
671     }
672 }
673 
674 void RenderTreeBuilder::removeAnonymousWrappersForInlineChildrenIfNeeded(RenderElement&amp; parent)
675 {
676     if (!is&lt;RenderBlock&gt;(parent))
677         return;
678     auto&amp; blockParent = downcast&lt;RenderBlock&gt;(parent);
679     if (!blockParent.canDropAnonymousBlockChild())
680         return;
681 
682     // We have changed to floated or out-of-flow positioning so maybe all our parent&#39;s
683     // children can be inline now. Bail if there are any block children left on the line,
684     // otherwise we can proceed to stripping solitary anonymous wrappers from the inlines.
685     // FIXME: We should also handle split inlines here - we exclude them at the moment by returning
686     // if we find a continuation.
687     Optional&lt;bool&gt; shouldAllChildrenBeInline;
688     for (auto* current = blockParent.firstChild(); current; current = current-&gt;nextSibling()) {
689         if (current-&gt;style().isFloating() || current-&gt;style().hasOutOfFlowPosition())
690             continue;
691         if (!current-&gt;isAnonymousBlock() || downcast&lt;RenderBlock&gt;(*current).isContinuation())
692             return;
693         // Anonymous block not in continuation. Check if it holds a set of inline or block children and try not to mix them.
694         auto* firstChild = current-&gt;firstChildSlow();
695         if (!firstChild)
696             continue;
697         auto isInlineLevelBox = firstChild-&gt;isInline();
698         if (!shouldAllChildrenBeInline.hasValue()) {
699             shouldAllChildrenBeInline = isInlineLevelBox;
700             continue;
701         }
702         // Mixing inline and block level boxes?
703         if (*shouldAllChildrenBeInline != isInlineLevelBox)
704             return;
705     }
706 
707     RenderObject* next = nullptr;
708     for (auto* current = blockParent.firstChild(); current; current = next) {
709         next = current-&gt;nextSibling();
710         if (current-&gt;isAnonymousBlock())
711             blockBuilder().dropAnonymousBoxChild(blockParent, downcast&lt;RenderBlock&gt;(*current));
712     }
713 }
714 
715 void RenderTreeBuilder::childFlowStateChangesAndNoLongerAffectsParentBlock(RenderElement&amp; child)
716 {
717     ASSERT(child.parent());
718     removeAnonymousWrappersForInlineChildrenIfNeeded(*child.parent());
719 }
720 
721 static bool isAnonymousAndSafeToDelete(RenderElement&amp; element)
722 {
723     if (!element.isAnonymous())
724         return false;
725     if (element.isRenderView() || element.isRenderFragmentedFlow())
726         return false;
727     return true;
728 }
729 
730 static RenderObject&amp; findDestroyRootIncludingAnonymous(RenderObject&amp; renderer)
731 {
732     auto* destroyRoot = &amp;renderer;
733     while (true) {
734         auto&amp; destroyRootParent = *destroyRoot-&gt;parent();
735         if (!isAnonymousAndSafeToDelete(destroyRootParent))
736             break;
737         bool destroyingOnlyChild = destroyRootParent.firstChild() == destroyRoot &amp;&amp; destroyRootParent.lastChild() == destroyRoot;
738         if (!destroyingOnlyChild)
739             break;
740         destroyRoot = &amp;destroyRootParent;
741     }
742     return *destroyRoot;
743 }
744 
745 void RenderTreeBuilder::destroyAndCleanUpAnonymousWrappers(RenderObject&amp; child)
746 {
747     // If the tree is destroyed, there is no need for a clean-up phase.
748     if (child.renderTreeBeingDestroyed()) {
749         destroy(child);
750         return;
751     }
752 
753     // Remove intruding floats from sibling blocks before detaching.
754     if (is&lt;RenderBox&gt;(child) &amp;&amp; child.isFloatingOrOutOfFlowPositioned())
755         downcast&lt;RenderBox&gt;(child).removeFloatingOrPositionedChildFromBlockLists();
756     auto&amp; destroyRoot = findDestroyRootIncludingAnonymous(child);
757     if (is&lt;RenderTableRow&gt;(destroyRoot))
758         tableBuilder().collapseAndDestroyAnonymousSiblingRows(downcast&lt;RenderTableRow&gt;(destroyRoot));
759 
760     // FIXME: Do not try to collapse/cleanup the anonymous wrappers inside destroy (see webkit.org/b/186746).
761     auto destroyRootParent = makeWeakPtr(*destroyRoot.parent());
762     destroy(destroyRoot);
763     if (!destroyRootParent)
764         return;
765     removeAnonymousWrappersForInlineChildrenIfNeeded(*destroyRootParent);
766 
767     // Anonymous parent might have become empty, try to delete it too.
768     if (isAnonymousAndSafeToDelete(*destroyRootParent) &amp;&amp; !destroyRootParent-&gt;firstChild())
769         destroyAndCleanUpAnonymousWrappers(*destroyRootParent);
770     // WARNING: child is deleted here.
771 }
772 
773 void RenderTreeBuilder::updateAfterDescendants(RenderElement&amp; renderer)
774 {
775     if (is&lt;RenderBlock&gt;(renderer))
776         firstLetterBuilder().updateAfterDescendants(downcast&lt;RenderBlock&gt;(renderer));
777     if (is&lt;RenderListItem&gt;(renderer))
778         listBuilder().updateItemMarker(downcast&lt;RenderListItem&gt;(renderer));
779     if (is&lt;RenderBlockFlow&gt;(renderer))
780         multiColumnBuilder().updateAfterDescendants(downcast&lt;RenderBlockFlow&gt;(renderer));
781 }
782 
783 RenderPtr&lt;RenderObject&gt; RenderTreeBuilder::detachFromRenderGrid(RenderGrid&amp; parent, RenderObject&amp; child)
784 {
785     auto takenChild = blockBuilder().detach(parent, child);
786     // Positioned grid items do not take up space or otherwise participate in the layout of the grid,
787     // for that reason we don&#39;t need to mark the grid as dirty when they are removed.
788     if (child.isOutOfFlowPositioned())
789         return takenChild;
790 
791     // The grid needs to be recomputed as it might contain auto-placed items that will change their position.
792     parent.dirtyGrid();
793     return takenChild;
794 }
795 
796 RenderPtr&lt;RenderObject&gt; RenderTreeBuilder::detachFromRenderElement(RenderElement&amp; parent, RenderObject&amp; child)
797 {
798     RELEASE_ASSERT_WITH_MESSAGE(!parent.view().frameView().layoutContext().layoutState(), &quot;Layout must not mutate render tree&quot;);
799 
800     ASSERT(parent.canHaveChildren() || parent.canHaveGeneratedChildren());
801     ASSERT(child.parent() == &amp;parent);
802 
803     if (child.isFloatingOrOutOfFlowPositioned())
804         downcast&lt;RenderBox&gt;(child).removeFloatingOrPositionedChildFromBlockLists();
805 
806     // So that we&#39;ll get the appropriate dirty bit set (either that a normal flow child got yanked or
807     // that a positioned child got yanked). We also repaint, so that the area exposed when the child
808     // disappears gets repainted properly.
809     if (!parent.renderTreeBeingDestroyed() &amp;&amp; child.everHadLayout()) {
810         child.setNeedsLayoutAndPrefWidthsRecalc();
811         // We only repaint |child| if we have a RenderLayer as its visual overflow may not be tracked by its parent.
812         if (child.isBody())
813             parent.view().repaintRootContents();
814         else
815             child.repaint();
816     }
817 
818     // If we have a line box wrapper, delete it.
819     if (is&lt;RenderBox&gt;(child))
820         downcast&lt;RenderBox&gt;(child).deleteLineBoxWrapper();
821     else if (is&lt;RenderLineBreak&gt;(child))
822         downcast&lt;RenderLineBreak&gt;(child).deleteInlineBoxWrapper();
823 
824     if (!parent.renderTreeBeingDestroyed() &amp;&amp; is&lt;RenderFlexibleBox&gt;(parent) &amp;&amp; !child.isFloatingOrOutOfFlowPositioned() &amp;&amp; child.isBox())
825         downcast&lt;RenderFlexibleBox&gt;(parent).clearCachedChildIntrinsicContentLogicalHeight(downcast&lt;RenderBox&gt;(child));
826 
827     // If child is the start or end of the selection, then clear the selection to
828     // avoid problems of invalid pointers.
829     if (!parent.renderTreeBeingDestroyed() &amp;&amp; child.isSelectionBorder())
830         parent.frame().selection().setNeedsSelectionUpdate();
831 
832     if (!parent.renderTreeBeingDestroyed())
833         child.willBeRemovedFromTree();
834 
835     child.resetFragmentedFlowStateOnRemoval();
836 
837     // WARNING: There should be no code running between willBeRemovedFromTree() and the actual removal below.
838     // This is needed to avoid race conditions where willBeRemovedFromTree() would dirty the tree&#39;s structure
839     // and the code running here would force an untimely rebuilding, leaving |child| dangling.
840     auto childToTake = parent.detachRendererInternal(child);
841 
842     // rendererRemovedFromTree() walks the whole subtree. We can improve performance
843     // by skipping this step when destroying the entire tree.
844     if (!parent.renderTreeBeingDestroyed() &amp;&amp; is&lt;RenderElement&gt;(*childToTake))
845         RenderCounter::rendererRemovedFromTree(downcast&lt;RenderElement&gt;(*childToTake));
846 
847     if (!parent.renderTreeBeingDestroyed()) {
848         if (AXObjectCache* cache = parent.document().existingAXObjectCache())
849             cache-&gt;childrenChanged(&amp;parent);
850     }
851 
852     return childToTake;
853 }
854 
855 void RenderTreeBuilder::attachToRenderGrid(RenderGrid&amp; parent, RenderPtr&lt;RenderObject&gt; child, RenderObject* beforeChild)
856 {
857     auto&amp; newChild = *child;
858     blockBuilder().attach(parent, WTFMove(child), beforeChild);
859 
860     // Positioned grid items do not take up space or otherwise participate in the layout of the grid,
861     // for that reason we don&#39;t need to mark the grid as dirty when they are added.
862     if (newChild.isOutOfFlowPositioned())
863         return;
864 
865     // The grid needs to be recomputed as it might contain auto-placed items that
866     // will change their position.
867     parent.dirtyGrid();
868 }
869 
870 }
    </pre>
  </body>
</html>