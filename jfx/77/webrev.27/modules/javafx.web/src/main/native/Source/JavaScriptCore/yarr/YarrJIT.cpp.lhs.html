<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/JavaScriptCore/yarr/YarrJIT.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (C) 2009-2018 Apple Inc. All rights reserved.
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  * 1. Redistributions of source code must retain the above copyright
   8  *    notice, this list of conditions and the following disclaimer.
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #include &quot;config.h&quot;
  27 #include &quot;YarrJIT.h&quot;
  28 
  29 #include &lt;wtf/ASCIICType.h&gt;
  30 #include &quot;LinkBuffer.h&quot;
  31 #include &quot;Options.h&quot;
  32 #include &quot;VM.h&quot;
  33 #include &quot;Yarr.h&quot;
  34 #include &quot;YarrCanonicalize.h&quot;
  35 #include &quot;YarrDisassembler.h&quot;
  36 
  37 #if ENABLE(YARR_JIT)
  38 
  39 namespace JSC { namespace Yarr {
  40 
  41 template&lt;YarrJITCompileMode compileMode&gt;
  42 class YarrGenerator : public YarrJITInfo, private MacroAssembler {
  43 
  44 #if CPU(ARM_THUMB2)
  45     static const RegisterID input = ARMRegisters::r0;
  46     static const RegisterID index = ARMRegisters::r1;
  47     static const RegisterID length = ARMRegisters::r2;
  48     static const RegisterID output = ARMRegisters::r3;
  49 
  50     static const RegisterID regT0 = ARMRegisters::r4;
  51     static const RegisterID regT1 = ARMRegisters::r5;
  52     static const RegisterID initialStart = ARMRegisters::r8;
  53 
  54     static const RegisterID returnRegister = ARMRegisters::r0;
  55     static const RegisterID returnRegister2 = ARMRegisters::r1;
  56 
  57 #define HAVE_INITIAL_START_REG
  58 #elif CPU(ARM64)
  59     // Argument registers
  60     static const RegisterID input = ARM64Registers::x0;
  61     static const RegisterID index = ARM64Registers::x1;
  62     static const RegisterID length = ARM64Registers::x2;
  63     static const RegisterID output = ARM64Registers::x3;
  64     static const RegisterID freelistRegister = ARM64Registers::x4;
  65     static const RegisterID freelistSizeRegister = ARM64Registers::x5;
  66 
  67     // Scratch registers
  68     static const RegisterID regT0 = ARM64Registers::x6;
  69     static const RegisterID regT1 = ARM64Registers::x7;
  70     static const RegisterID regT2 = ARM64Registers::x8;
  71     static const RegisterID remainingMatchCount = ARM64Registers::x9;
  72     static const RegisterID regUnicodeInputAndTrail = ARM64Registers::x10;
  73     static const RegisterID initialStart = ARM64Registers::x11;
  74     static const RegisterID supplementaryPlanesBase = ARM64Registers::x12;
<a name="1" id="anc1"></a><span class="line-modified">  75     static const RegisterID surrogateTagMask = ARM64Registers::x13;</span>
<span class="line-modified">  76     static const RegisterID leadingSurrogateTag = ARM64Registers::x14;</span>
<span class="line-modified">  77     static const RegisterID trailingSurrogateTag = ARM64Registers::x15;</span>
  78 
  79     static const RegisterID returnRegister = ARM64Registers::x0;
  80     static const RegisterID returnRegister2 = ARM64Registers::x1;
  81 
<a name="2" id="anc2"></a>
  82 #define HAVE_INITIAL_START_REG
  83 #define JIT_UNICODE_EXPRESSIONS
  84 #elif CPU(MIPS)
  85     static const RegisterID input = MIPSRegisters::a0;
  86     static const RegisterID index = MIPSRegisters::a1;
  87     static const RegisterID length = MIPSRegisters::a2;
  88     static const RegisterID output = MIPSRegisters::a3;
  89 
  90     static const RegisterID regT0 = MIPSRegisters::t4;
  91     static const RegisterID regT1 = MIPSRegisters::t5;
  92     static const RegisterID initialStart = MIPSRegisters::t6;
  93 
  94     static const RegisterID returnRegister = MIPSRegisters::v0;
  95     static const RegisterID returnRegister2 = MIPSRegisters::v1;
  96 
  97 #define HAVE_INITIAL_START_REG
  98 #elif CPU(X86)
  99     static const RegisterID input = X86Registers::eax;
 100     static const RegisterID index = X86Registers::edx;
 101     static const RegisterID length = X86Registers::ecx;
 102     static const RegisterID output = X86Registers::edi;
 103 
 104     static const RegisterID regT0 = X86Registers::ebx;
 105     static const RegisterID regT1 = X86Registers::esi;
 106 
 107     static const RegisterID returnRegister = X86Registers::eax;
 108     static const RegisterID returnRegister2 = X86Registers::edx;
 109 #elif CPU(X86_64)
 110 #if !OS(WINDOWS)
 111     // Argument registers
 112     static const RegisterID input = X86Registers::edi;
 113     static const RegisterID index = X86Registers::esi;
 114     static const RegisterID length = X86Registers::edx;
 115     static const RegisterID output = X86Registers::ecx;
 116     static const RegisterID freelistRegister = X86Registers::r8;
 117     static const RegisterID freelistSizeRegister = X86Registers::r9; // Only used during initialization.
 118 #else
 119     // If the return value doesn&#39;t fit in 64bits, its destination is pointed by rcx and the parameters are shifted.
 120     // http://msdn.microsoft.com/en-us/library/7572ztz4.aspx
 121     COMPILE_ASSERT(sizeof(MatchResult) &gt; sizeof(void*), MatchResult_does_not_fit_in_64bits);
 122     static const RegisterID input = X86Registers::edx;
 123     static const RegisterID index = X86Registers::r8;
 124     static const RegisterID length = X86Registers::r9;
 125     static const RegisterID output = X86Registers::r10;
 126 #endif
 127 
 128     // Scratch registers
 129     static const RegisterID regT0 = X86Registers::eax;
 130 #if !OS(WINDOWS)
 131     static const RegisterID regT1 = X86Registers::r9;
 132     static const RegisterID regT2 = X86Registers::r10;
 133 #else
 134     static const RegisterID regT1 = X86Registers::ecx;
 135     static const RegisterID regT2 = X86Registers::edi;
 136 #endif
 137 
 138     static const RegisterID initialStart = X86Registers::ebx;
 139 #if !OS(WINDOWS)
 140     static const RegisterID remainingMatchCount = X86Registers::r12;
 141 #else
 142     static const RegisterID remainingMatchCount = X86Registers::esi;
 143 #endif
 144     static const RegisterID regUnicodeInputAndTrail = X86Registers::r13;
 145     static const RegisterID leadingSurrogateTag = X86Registers::r14;
<a name="3" id="anc3"></a><span class="line-modified"> 146     static const RegisterID trailingSurrogateTag = X86Registers::r15;</span>
 147 
 148     static const RegisterID returnRegister = X86Registers::eax;
 149     static const RegisterID returnRegister2 = X86Registers::edx;
 150 
 151     const TrustedImm32 supplementaryPlanesBase = TrustedImm32(0x10000);
<a name="4" id="anc4"></a>
 152     const TrustedImm32 surrogateTagMask = TrustedImm32(0xfffffc00);
 153 #define HAVE_INITIAL_START_REG
 154 #define JIT_UNICODE_EXPRESSIONS
 155 #endif
 156 
 157 #if ENABLE(YARR_JIT_ALL_PARENS_EXPRESSIONS)
 158     struct ParenContextSizes {
 159         size_t m_numSubpatterns;
 160         size_t m_frameSlots;
 161 
 162         ParenContextSizes(size_t numSubpatterns, size_t frameSlots)
 163             : m_numSubpatterns(numSubpatterns)
 164             , m_frameSlots(frameSlots)
 165         {
 166         }
 167 
 168         size_t numSubpatterns() { return m_numSubpatterns; }
 169 
 170         size_t frameSlots() { return m_frameSlots; }
 171     };
 172 
 173     struct ParenContext {
 174         struct ParenContext* next;
 175         uint32_t begin;
 176         uint32_t matchAmount;
 177         uintptr_t returnAddress;
 178         struct Subpatterns {
 179             unsigned start;
 180             unsigned end;
 181         } subpatterns[0];
 182         uintptr_t frameSlots[0];
 183 
 184         static size_t sizeFor(ParenContextSizes&amp; parenContextSizes)
 185         {
 186             return sizeof(ParenContext) + sizeof(Subpatterns) * parenContextSizes.numSubpatterns() + sizeof(uintptr_t) * parenContextSizes.frameSlots();
 187         }
 188 
 189         static ptrdiff_t nextOffset()
 190         {
 191             return offsetof(ParenContext, next);
 192         }
 193 
 194         static ptrdiff_t beginOffset()
 195         {
 196             return offsetof(ParenContext, begin);
 197         }
 198 
 199         static ptrdiff_t matchAmountOffset()
 200         {
 201             return offsetof(ParenContext, matchAmount);
 202         }
 203 
 204         static ptrdiff_t returnAddressOffset()
 205         {
 206             return offsetof(ParenContext, returnAddress);
 207         }
 208 
 209         static ptrdiff_t subpatternOffset(size_t subpattern)
 210         {
 211             return offsetof(ParenContext, subpatterns) + (subpattern - 1) * sizeof(Subpatterns);
 212         }
 213 
 214         static ptrdiff_t savedFrameOffset(ParenContextSizes&amp; parenContextSizes)
 215         {
 216             return offsetof(ParenContext, subpatterns) + (parenContextSizes.numSubpatterns()) * sizeof(Subpatterns);
 217         }
 218     };
 219 
 220     void initParenContextFreeList()
 221     {
 222         RegisterID parenContextPointer = regT0;
 223         RegisterID nextParenContextPointer = regT2;
 224 
 225         size_t parenContextSize = ParenContext::sizeFor(m_parenContextSizes);
 226 
 227         parenContextSize = WTF::roundUpToMultipleOf&lt;sizeof(uintptr_t)&gt;(parenContextSize);
 228 
<a name="5" id="anc5"></a><span class="line-modified"> 229         // Check that the paren context is a reasonable size.</span>
<span class="line-modified"> 230         if (parenContextSize &gt; INT16_MAX)</span>
<span class="line-modified"> 231             m_abortExecution.append(jump());</span>

 232 
 233         Jump emptyFreeList = branchTestPtr(Zero, freelistRegister);
 234         move(freelistRegister, parenContextPointer);
 235         addPtr(TrustedImm32(parenContextSize), freelistRegister, nextParenContextPointer);
 236         addPtr(freelistRegister, freelistSizeRegister);
 237         subPtr(TrustedImm32(parenContextSize), freelistSizeRegister);
 238 
 239         Label loopTop(this);
 240         Jump initDone = branchPtr(Above, nextParenContextPointer, freelistSizeRegister);
 241         storePtr(nextParenContextPointer, Address(parenContextPointer, ParenContext::nextOffset()));
 242         move(nextParenContextPointer, parenContextPointer);
 243         addPtr(TrustedImm32(parenContextSize), parenContextPointer, nextParenContextPointer);
 244         jump(loopTop);
 245 
 246         initDone.link(this);
 247         storePtr(TrustedImmPtr(nullptr), Address(parenContextPointer, ParenContext::nextOffset()));
 248         emptyFreeList.link(this);
 249     }
 250 
 251     void allocateParenContext(RegisterID result)
 252     {
 253         m_abortExecution.append(branchTestPtr(Zero, freelistRegister));
 254         sub32(TrustedImm32(1), remainingMatchCount);
 255         m_hitMatchLimit.append(branchTestPtr(Zero, remainingMatchCount));
 256         move(freelistRegister, result);
 257         loadPtr(Address(freelistRegister, ParenContext::nextOffset()), freelistRegister);
 258     }
 259 
 260     void freeParenContext(RegisterID headPtrRegister, RegisterID newHeadPtrRegister)
 261     {
 262         loadPtr(Address(headPtrRegister, ParenContext::nextOffset()), newHeadPtrRegister);
 263         storePtr(freelistRegister, Address(headPtrRegister, ParenContext::nextOffset()));
 264         move(headPtrRegister, freelistRegister);
 265     }
 266 
 267     void saveParenContext(RegisterID parenContextReg, RegisterID tempReg, unsigned firstSubpattern, unsigned lastSubpattern, unsigned subpatternBaseFrameLocation)
 268     {
 269         store32(index, Address(parenContextReg, ParenContext::beginOffset()));
 270         loadFromFrame(subpatternBaseFrameLocation + BackTrackInfoParentheses::matchAmountIndex(), tempReg);
 271         store32(tempReg, Address(parenContextReg, ParenContext::matchAmountOffset()));
 272         loadFromFrame(subpatternBaseFrameLocation + BackTrackInfoParentheses::returnAddressIndex(), tempReg);
 273         storePtr(tempReg, Address(parenContextReg, ParenContext::returnAddressOffset()));
 274         if (compileMode == IncludeSubpatterns) {
 275             for (unsigned subpattern = firstSubpattern; subpattern &lt;= lastSubpattern; subpattern++) {
 276                 loadPtr(Address(output, (subpattern &lt;&lt; 1) * sizeof(unsigned)), tempReg);
 277                 storePtr(tempReg, Address(parenContextReg, ParenContext::subpatternOffset(subpattern)));
 278                 clearSubpatternStart(subpattern);
 279             }
 280         }
 281         subpatternBaseFrameLocation += YarrStackSpaceForBackTrackInfoParentheses;
 282         for (unsigned frameLocation = subpatternBaseFrameLocation; frameLocation &lt; m_parenContextSizes.frameSlots(); frameLocation++) {
 283             loadFromFrame(frameLocation, tempReg);
 284             storePtr(tempReg, Address(parenContextReg, ParenContext::savedFrameOffset(m_parenContextSizes) + frameLocation * sizeof(uintptr_t)));
 285         }
 286     }
 287 
 288     void restoreParenContext(RegisterID parenContextReg, RegisterID tempReg, unsigned firstSubpattern, unsigned lastSubpattern, unsigned subpatternBaseFrameLocation)
 289     {
 290         load32(Address(parenContextReg, ParenContext::beginOffset()), index);
 291         storeToFrame(index, subpatternBaseFrameLocation + BackTrackInfoParentheses::beginIndex());
 292         load32(Address(parenContextReg, ParenContext::matchAmountOffset()), tempReg);
 293         storeToFrame(tempReg, subpatternBaseFrameLocation + BackTrackInfoParentheses::matchAmountIndex());
 294         loadPtr(Address(parenContextReg, ParenContext::returnAddressOffset()), tempReg);
 295         storeToFrame(tempReg, subpatternBaseFrameLocation + BackTrackInfoParentheses::returnAddressIndex());
 296         if (compileMode == IncludeSubpatterns) {
 297             for (unsigned subpattern = firstSubpattern; subpattern &lt;= lastSubpattern; subpattern++) {
 298                 loadPtr(Address(parenContextReg, ParenContext::subpatternOffset(subpattern)), tempReg);
 299                 storePtr(tempReg, Address(output, (subpattern &lt;&lt; 1) * sizeof(unsigned)));
 300             }
 301         }
 302         subpatternBaseFrameLocation += YarrStackSpaceForBackTrackInfoParentheses;
 303         for (unsigned frameLocation = subpatternBaseFrameLocation; frameLocation &lt; m_parenContextSizes.frameSlots(); frameLocation++) {
 304             loadPtr(Address(parenContextReg, ParenContext::savedFrameOffset(m_parenContextSizes) + frameLocation * sizeof(uintptr_t)), tempReg);
 305             storeToFrame(tempReg, frameLocation);
 306         }
 307     }
 308 #endif
 309 
 310     void optimizeAlternative(PatternAlternative* alternative)
 311     {
 312         if (!alternative-&gt;m_terms.size())
 313             return;
 314 
 315         for (unsigned i = 0; i &lt; alternative-&gt;m_terms.size() - 1; ++i) {
 316             PatternTerm&amp; term = alternative-&gt;m_terms[i];
 317             PatternTerm&amp; nextTerm = alternative-&gt;m_terms[i + 1];
 318 
 319             // We can move BMP only character classes after fixed character terms.
 320             if ((term.type == PatternTerm::TypeCharacterClass)
 321                 &amp;&amp; (term.quantityType == QuantifierFixedCount)
<a name="6" id="anc6"></a><span class="line-modified"> 322                 &amp;&amp; (!m_decodeSurrogatePairs || (!term.characterClass-&gt;m_hasNonBMPCharacters &amp;&amp; !term.m_invert))</span>
 323                 &amp;&amp; (nextTerm.type == PatternTerm::TypePatternCharacter)
 324                 &amp;&amp; (nextTerm.quantityType == QuantifierFixedCount)) {
 325                 PatternTerm termCopy = term;
 326                 alternative-&gt;m_terms[i] = nextTerm;
 327                 alternative-&gt;m_terms[i + 1] = termCopy;
 328             }
 329         }
 330     }
 331 
 332     void matchCharacterClassRange(RegisterID character, JumpList&amp; failures, JumpList&amp; matchDest, const CharacterRange* ranges, unsigned count, unsigned* matchIndex, const UChar32* matches, unsigned matchCount)
 333     {
 334         do {
 335             // pick which range we&#39;re going to generate
 336             int which = count &gt;&gt; 1;
 337             char lo = ranges[which].begin;
 338             char hi = ranges[which].end;
 339 
 340             // check if there are any ranges or matches below lo.  If not, just jl to failure -
 341             // if there is anything else to check, check that first, if it falls through jmp to failure.
 342             if ((*matchIndex &lt; matchCount) &amp;&amp; (matches[*matchIndex] &lt; lo)) {
 343                 Jump loOrAbove = branch32(GreaterThanOrEqual, character, Imm32((unsigned short)lo));
 344 
 345                 // generate code for all ranges before this one
 346                 if (which)
 347                     matchCharacterClassRange(character, failures, matchDest, ranges, which, matchIndex, matches, matchCount);
 348 
 349                 while ((*matchIndex &lt; matchCount) &amp;&amp; (matches[*matchIndex] &lt; lo)) {
 350                     matchDest.append(branch32(Equal, character, Imm32((unsigned short)matches[*matchIndex])));
 351                     ++*matchIndex;
 352                 }
 353                 failures.append(jump());
 354 
 355                 loOrAbove.link(this);
 356             } else if (which) {
 357                 Jump loOrAbove = branch32(GreaterThanOrEqual, character, Imm32((unsigned short)lo));
 358 
 359                 matchCharacterClassRange(character, failures, matchDest, ranges, which, matchIndex, matches, matchCount);
 360                 failures.append(jump());
 361 
 362                 loOrAbove.link(this);
 363             } else
 364                 failures.append(branch32(LessThan, character, Imm32((unsigned short)lo)));
 365 
 366             while ((*matchIndex &lt; matchCount) &amp;&amp; (matches[*matchIndex] &lt;= hi))
 367                 ++*matchIndex;
 368 
 369             matchDest.append(branch32(LessThanOrEqual, character, Imm32((unsigned short)hi)));
 370             // fall through to here, the value is above hi.
 371 
 372             // shuffle along &amp; loop around if there are any more matches to handle.
 373             unsigned next = which + 1;
 374             ranges += next;
 375             count -= next;
 376         } while (count);
 377     }
 378 
 379     void matchCharacterClass(RegisterID character, JumpList&amp; matchDest, const CharacterClass* charClass)
 380     {
 381         if (charClass-&gt;m_table &amp;&amp; !m_decodeSurrogatePairs) {
 382             ExtendedAddress tableEntry(character, reinterpret_cast&lt;intptr_t&gt;(charClass-&gt;m_table));
 383             matchDest.append(branchTest8(charClass-&gt;m_tableInverted ? Zero : NonZero, tableEntry));
 384             return;
 385         }
<a name="7" id="anc7"></a>
 386         JumpList unicodeFail;
 387         if (charClass-&gt;m_matchesUnicode.size() || charClass-&gt;m_rangesUnicode.size()) {
 388             JumpList isAscii;
 389             if (charClass-&gt;m_matches.size() || charClass-&gt;m_ranges.size())
 390                 isAscii.append(branch32(LessThanOrEqual, character, TrustedImm32(0x7f)));
 391 
 392             if (charClass-&gt;m_matchesUnicode.size()) {
 393                 for (unsigned i = 0; i &lt; charClass-&gt;m_matchesUnicode.size(); ++i) {
 394                     UChar32 ch = charClass-&gt;m_matchesUnicode[i];
 395                     matchDest.append(branch32(Equal, character, Imm32(ch)));
 396                 }
 397             }
 398 
 399             if (charClass-&gt;m_rangesUnicode.size()) {
 400                 for (unsigned i = 0; i &lt; charClass-&gt;m_rangesUnicode.size(); ++i) {
 401                     UChar32 lo = charClass-&gt;m_rangesUnicode[i].begin;
 402                     UChar32 hi = charClass-&gt;m_rangesUnicode[i].end;
 403 
 404                     Jump below = branch32(LessThan, character, Imm32(lo));
 405                     matchDest.append(branch32(LessThanOrEqual, character, Imm32(hi)));
 406                     below.link(this);
 407                 }
 408             }
 409 
 410             if (charClass-&gt;m_matches.size() || charClass-&gt;m_ranges.size())
 411                 unicodeFail = jump();
 412             isAscii.link(this);
 413         }
 414 
 415         if (charClass-&gt;m_ranges.size()) {
 416             unsigned matchIndex = 0;
 417             JumpList failures;
 418             matchCharacterClassRange(character, failures, matchDest, charClass-&gt;m_ranges.begin(), charClass-&gt;m_ranges.size(), &amp;matchIndex, charClass-&gt;m_matches.begin(), charClass-&gt;m_matches.size());
 419             while (matchIndex &lt; charClass-&gt;m_matches.size())
 420                 matchDest.append(branch32(Equal, character, Imm32((unsigned short)charClass-&gt;m_matches[matchIndex++])));
 421 
 422             failures.link(this);
 423         } else if (charClass-&gt;m_matches.size()) {
 424             // optimization: gather &#39;a&#39;,&#39;A&#39; etc back together, can mask &amp; test once.
 425             Vector&lt;char&gt; matchesAZaz;
 426 
 427             for (unsigned i = 0; i &lt; charClass-&gt;m_matches.size(); ++i) {
 428                 char ch = charClass-&gt;m_matches[i];
 429                 if (m_pattern.ignoreCase()) {
 430                     if (isASCIILower(ch)) {
 431                         matchesAZaz.append(ch);
 432                         continue;
 433                     }
 434                     if (isASCIIUpper(ch))
 435                         continue;
 436                 }
 437                 matchDest.append(branch32(Equal, character, Imm32((unsigned short)ch)));
 438             }
 439 
 440             if (unsigned countAZaz = matchesAZaz.size()) {
 441                 or32(TrustedImm32(32), character);
 442                 for (unsigned i = 0; i &lt; countAZaz; ++i)
 443                     matchDest.append(branch32(Equal, character, TrustedImm32(matchesAZaz[i])));
 444             }
 445         }
 446 
 447         if (charClass-&gt;m_matchesUnicode.size() || charClass-&gt;m_rangesUnicode.size())
 448             unicodeFail.link(this);
 449     }
 450 
<a name="8" id="anc8"></a>
















 451     // Jumps if input not available; will have (incorrectly) incremented already!
 452     Jump jumpIfNoAvailableInput(unsigned countToCheck = 0)
 453     {
 454         if (countToCheck)
 455             add32(Imm32(countToCheck), index);
 456         return branch32(Above, index, length);
 457     }
 458 
 459     Jump jumpIfAvailableInput(unsigned countToCheck)
 460     {
 461         add32(Imm32(countToCheck), index);
 462         return branch32(BelowOrEqual, index, length);
 463     }
 464 
 465     Jump checkNotEnoughInput(RegisterID additionalAmount)
 466     {
 467         add32(index, additionalAmount);
 468         return branch32(Above, additionalAmount, length);
 469     }
 470 
 471     Jump checkInput()
 472     {
 473         return branch32(BelowOrEqual, index, length);
 474     }
 475 
 476     Jump atEndOfInput()
 477     {
 478         return branch32(Equal, index, length);
 479     }
 480 
 481     Jump notAtEndOfInput()
 482     {
 483         return branch32(NotEqual, index, length);
 484     }
 485 
 486     BaseIndex negativeOffsetIndexedAddress(Checked&lt;unsigned&gt; negativeCharacterOffset, RegisterID tempReg, RegisterID indexReg = index)
 487     {
 488         RegisterID base = input;
 489 
 490         // BaseIndex() addressing can take a int32_t offset. Given that we can have a regular
 491         // expression that has unsigned character offsets, BaseIndex&#39;s signed offset is insufficient
 492         // for addressing in extreme cases where we might underflow. Therefore we check to see if
 493         // negativeCharacterOffset will underflow directly or after converting for 16 bit characters.
 494         // If so, we do our own address calculating by adjusting the base, using the result register
 495         // as a temp address register.
 496         unsigned maximumNegativeOffsetForCharacterSize = m_charSize == Char8 ? 0x7fffffff : 0x3fffffff;
 497         unsigned offsetAdjustAmount = 0x40000000;
 498         if (negativeCharacterOffset.unsafeGet() &gt; maximumNegativeOffsetForCharacterSize) {
 499             base = tempReg;
 500             move(input, base);
 501             while (negativeCharacterOffset.unsafeGet() &gt; maximumNegativeOffsetForCharacterSize) {
 502                 subPtr(TrustedImm32(offsetAdjustAmount), base);
 503                 if (m_charSize != Char8)
 504                     subPtr(TrustedImm32(offsetAdjustAmount), base);
 505                 negativeCharacterOffset -= offsetAdjustAmount;
 506             }
 507         }
 508 
 509         Checked&lt;int32_t&gt; characterOffset(-static_cast&lt;int32_t&gt;(negativeCharacterOffset.unsafeGet()));
 510 
 511         if (m_charSize == Char8)
 512             return BaseIndex(input, indexReg, TimesOne, (characterOffset * static_cast&lt;int32_t&gt;(sizeof(char))).unsafeGet());
 513 
 514         return BaseIndex(input, indexReg, TimesTwo, (characterOffset * static_cast&lt;int32_t&gt;(sizeof(UChar))).unsafeGet());
 515     }
 516 
 517 #ifdef JIT_UNICODE_EXPRESSIONS
 518     void tryReadUnicodeCharImpl(RegisterID resultReg)
 519     {
 520         ASSERT(m_charSize == Char16);
 521 
 522         JumpList notUnicode;
<a name="9" id="anc9"></a>
 523         load16Unaligned(regUnicodeInputAndTrail, resultReg);
 524         and32(surrogateTagMask, resultReg, regT2);
 525         notUnicode.append(branch32(NotEqual, regT2, leadingSurrogateTag));
 526         addPtr(TrustedImm32(2), regUnicodeInputAndTrail);
<a name="10" id="anc10"></a><span class="line-modified"> 527         getEffectiveAddress(BaseIndex(input, length, TimesTwo), regT2);</span>
<span class="line-removed"> 528         notUnicode.append(branch32(AboveOrEqual, regUnicodeInputAndTrail, regT2));</span>
 529         load16Unaligned(Address(regUnicodeInputAndTrail), regUnicodeInputAndTrail);
 530         and32(surrogateTagMask, regUnicodeInputAndTrail, regT2);
 531         notUnicode.append(branch32(NotEqual, regT2, trailingSurrogateTag));
 532         sub32(leadingSurrogateTag, resultReg);
 533         sub32(trailingSurrogateTag, regUnicodeInputAndTrail);
 534         lshift32(TrustedImm32(10), resultReg);
 535         or32(regUnicodeInputAndTrail, resultReg);
 536         add32(supplementaryPlanesBase, resultReg);
 537         notUnicode.link(this);
 538     }
 539 
 540     void tryReadUnicodeChar(BaseIndex address, RegisterID resultReg)
 541     {
 542         ASSERT(m_charSize == Char16);
 543 
 544         getEffectiveAddress(address, regUnicodeInputAndTrail);
 545 
 546         if (resultReg == regT0)
 547             m_tryReadUnicodeCharacterCalls.append(nearCall());
 548         else
 549             tryReadUnicodeCharImpl(resultReg);
 550     }
 551 #endif
 552 
 553     void readCharacterDontDecodeSurrogates(Checked&lt;unsigned&gt; negativeCharacterOffset, RegisterID resultReg, RegisterID indexReg = index)
 554     {
 555         BaseIndex address = negativeOffsetIndexedAddress(negativeCharacterOffset, resultReg, indexReg);
 556 
 557         if (m_charSize == Char8)
 558             load8(address, resultReg);
 559         else
 560             load16Unaligned(address, resultReg);
 561     }
 562 
 563     void readCharacter(Checked&lt;unsigned&gt; negativeCharacterOffset, RegisterID resultReg, RegisterID indexReg = index)
 564     {
 565         BaseIndex address = negativeOffsetIndexedAddress(negativeCharacterOffset, resultReg, indexReg);
 566 
 567         if (m_charSize == Char8)
 568             load8(address, resultReg);
 569 #ifdef JIT_UNICODE_EXPRESSIONS
 570         else if (m_decodeSurrogatePairs)
 571             tryReadUnicodeChar(address, resultReg);
 572 #endif
 573         else
 574             load16Unaligned(address, resultReg);
 575     }
 576 
 577     Jump jumpIfCharNotEquals(UChar32 ch, Checked&lt;unsigned&gt; negativeCharacterOffset, RegisterID character)
 578     {
 579         readCharacter(negativeCharacterOffset, character);
 580 
 581         // For case-insesitive compares, non-ascii characters that have different
 582         // upper &amp; lower case representations are converted to a character class.
 583         ASSERT(!m_pattern.ignoreCase() || isASCIIAlpha(ch) || isCanonicallyUnique(ch, m_canonicalMode));
 584         if (m_pattern.ignoreCase() &amp;&amp; isASCIIAlpha(ch)) {
 585             or32(TrustedImm32(0x20), character);
 586             ch |= 0x20;
 587         }
 588 
 589         return branch32(NotEqual, character, Imm32(ch));
 590     }
 591 
 592     void storeToFrame(RegisterID reg, unsigned frameLocation)
 593     {
 594         poke(reg, frameLocation);
 595     }
 596 
 597     void storeToFrame(TrustedImm32 imm, unsigned frameLocation)
 598     {
 599         poke(imm, frameLocation);
 600     }
 601 
 602 #if CPU(ARM64) || CPU(X86_64)
 603     void storeToFrame(TrustedImmPtr imm, unsigned frameLocation)
 604     {
 605         poke(imm, frameLocation);
 606     }
 607 #endif
 608 
 609     DataLabelPtr storeToFrameWithPatch(unsigned frameLocation)
 610     {
 611         return storePtrWithPatch(TrustedImmPtr(nullptr), Address(stackPointerRegister, frameLocation * sizeof(void*)));
 612     }
 613 
 614     void loadFromFrame(unsigned frameLocation, RegisterID reg)
 615     {
 616         peek(reg, frameLocation);
 617     }
 618 
 619     void loadFromFrameAndJump(unsigned frameLocation)
 620     {
<a name="11" id="anc11"></a><span class="line-modified"> 621         jump(Address(stackPointerRegister, frameLocation * sizeof(void*)), YarrBacktrackPtrTag);</span>
 622     }
 623 
 624     unsigned alignCallFrameSizeInBytes(unsigned callFrameSize)
 625     {
 626         if (!callFrameSize)
 627             return 0;
 628 
 629         callFrameSize *= sizeof(void*);
 630         if (callFrameSize / sizeof(void*) != m_pattern.m_body-&gt;m_callFrameSize)
 631             CRASH();
 632         callFrameSize = (callFrameSize + 0x3f) &amp; ~0x3f;
 633         return callFrameSize;
 634     }
 635     void initCallFrame()
 636     {
 637         unsigned callFrameSizeInBytes = alignCallFrameSizeInBytes(m_pattern.m_body-&gt;m_callFrameSize);
 638         if (callFrameSizeInBytes) {
 639 #if CPU(X86_64) || CPU(ARM64)
 640             if (Options::zeroStackFrame()) {
 641                 // We need to start from the stack pointer, because we could have spilled callee saves
 642                 move(stackPointerRegister, regT0);
 643                 subPtr(Imm32(callFrameSizeInBytes), stackPointerRegister);
 644                 if (callFrameSizeInBytes &lt;= 128) {
 645                     for (unsigned offset = 0; offset &lt; callFrameSizeInBytes; offset += sizeof(intptr_t))
 646                         storePtr(TrustedImm32(0), Address(regT0, -8 - offset));
 647                 } else {
 648                     Label zeroLoop = label();
 649                     subPtr(TrustedImm32(sizeof(intptr_t) * 2), regT0);
 650 #if CPU(ARM64)
 651                     storePair64(ARM64Registers::zr, ARM64Registers::zr, regT0);
 652 #else
 653                     storePtr(TrustedImm32(0), Address(regT0));
 654                     storePtr(TrustedImm32(0), Address(regT0, sizeof(intptr_t)));
 655 #endif
 656                     branchPtr(NotEqual, regT0, stackPointerRegister).linkTo(zeroLoop, this);
 657                 }
 658             } else
 659 #endif
 660                 subPtr(Imm32(callFrameSizeInBytes), stackPointerRegister);
 661 
 662         }
 663     }
 664     void removeCallFrame()
 665     {
 666         unsigned callFrameSizeInBytes = alignCallFrameSizeInBytes(m_pattern.m_body-&gt;m_callFrameSize);
 667         if (callFrameSizeInBytes)
 668             addPtr(Imm32(callFrameSizeInBytes), stackPointerRegister);
 669     }
 670 
 671     void generateFailReturn()
 672     {
 673         move(TrustedImmPtr((void*)WTF::notFound), returnRegister);
 674         move(TrustedImm32(0), returnRegister2);
 675         generateReturn();
 676     }
 677 
 678     void generateJITFailReturn()
 679     {
 680         if (m_abortExecution.empty() &amp;&amp; m_hitMatchLimit.empty())
 681             return;
 682 
 683         JumpList finishExiting;
 684         if (!m_abortExecution.empty()) {
 685             m_abortExecution.link(this);
 686             move(TrustedImmPtr((void*)static_cast&lt;size_t&gt;(-2)), returnRegister);
 687             finishExiting.append(jump());
 688         }
 689 
 690         if (!m_hitMatchLimit.empty()) {
 691             m_hitMatchLimit.link(this);
 692             move(TrustedImmPtr((void*)static_cast&lt;size_t&gt;(-1)), returnRegister);
 693         }
 694 
 695         finishExiting.link(this);
 696         removeCallFrame();
 697         move(TrustedImm32(0), returnRegister2);
 698         generateReturn();
 699     }
 700 
 701     // Used to record subpatterns, should only be called if compileMode is IncludeSubpatterns.
 702     void setSubpatternStart(RegisterID reg, unsigned subpattern)
 703     {
 704         ASSERT(subpattern);
 705         // FIXME: should be able to ASSERT(compileMode == IncludeSubpatterns), but then this function is conditionally NORETURN. :-(
 706         store32(reg, Address(output, (subpattern &lt;&lt; 1) * sizeof(int)));
 707     }
 708     void setSubpatternEnd(RegisterID reg, unsigned subpattern)
 709     {
 710         ASSERT(subpattern);
 711         // FIXME: should be able to ASSERT(compileMode == IncludeSubpatterns), but then this function is conditionally NORETURN. :-(
 712         store32(reg, Address(output, ((subpattern &lt;&lt; 1) + 1) * sizeof(int)));
 713     }
 714     void clearSubpatternStart(unsigned subpattern)
 715     {
 716         ASSERT(subpattern);
 717         // FIXME: should be able to ASSERT(compileMode == IncludeSubpatterns), but then this function is conditionally NORETURN. :-(
 718         store32(TrustedImm32(-1), Address(output, (subpattern &lt;&lt; 1) * sizeof(int)));
 719     }
 720 
 721     void clearMatches(unsigned subpattern, unsigned lastSubpattern)
 722     {
 723         for (; subpattern &lt;= lastSubpattern; subpattern++)
 724             clearSubpatternStart(subpattern);
 725     }
 726 
 727     // We use one of three different strategies to track the start of the current match,
 728     // while matching.
 729     // 1) If the pattern has a fixed size, do nothing! - we calculate the value lazily
 730     //    at the end of matching. This is irrespective of compileMode, and in this case
 731     //    these methods should never be called.
 732     // 2) If we&#39;re compiling IncludeSubpatterns, &#39;output&#39; contains a pointer to an output
 733     //    vector, store the match start in the output vector.
 734     // 3) If we&#39;re compiling MatchOnly, &#39;output&#39; is unused, store the match start directly
 735     //    in this register.
 736     void setMatchStart(RegisterID reg)
 737     {
 738         ASSERT(!m_pattern.m_body-&gt;m_hasFixedSize);
 739         if (compileMode == IncludeSubpatterns)
 740             store32(reg, output);
 741         else
 742             move(reg, output);
 743     }
 744     void getMatchStart(RegisterID reg)
 745     {
 746         ASSERT(!m_pattern.m_body-&gt;m_hasFixedSize);
 747         if (compileMode == IncludeSubpatterns)
 748             load32(output, reg);
 749         else
 750             move(output, reg);
 751     }
 752 
<a name="12" id="anc12"></a><span class="line-modified"> 753     enum YarrOpCode {</span>
 754         // These nodes wrap body alternatives - those in the main disjunction,
 755         // rather than subpatterns or assertions. These are chained together in
 756         // a doubly linked list, with a &#39;begin&#39; node for the first alternative,
 757         // a &#39;next&#39; node for each subsequent alternative, and an &#39;end&#39; node at
 758         // the end. In the case of repeating alternatives, the &#39;end&#39; node also
 759         // has a reference back to &#39;begin&#39;.
 760         OpBodyAlternativeBegin,
 761         OpBodyAlternativeNext,
 762         OpBodyAlternativeEnd,
 763         // Similar to the body alternatives, but used for subpatterns with two
 764         // or more alternatives.
 765         OpNestedAlternativeBegin,
 766         OpNestedAlternativeNext,
 767         OpNestedAlternativeEnd,
 768         // Used for alternatives in subpatterns where there is only a single
 769         // alternative (backtracking is easier in these cases), or for alternatives
 770         // which never need to be backtracked (those in parenthetical assertions,
 771         // terminal subpatterns).
 772         OpSimpleNestedAlternativeBegin,
 773         OpSimpleNestedAlternativeNext,
 774         OpSimpleNestedAlternativeEnd,
 775         // Used to wrap &#39;Once&#39; subpattern matches (quantityMaxCount == 1).
 776         OpParenthesesSubpatternOnceBegin,
 777         OpParenthesesSubpatternOnceEnd,
 778         // Used to wrap &#39;Terminal&#39; subpattern matches (at the end of the regexp).
 779         OpParenthesesSubpatternTerminalBegin,
 780         OpParenthesesSubpatternTerminalEnd,
 781         // Used to wrap generic captured matches
 782         OpParenthesesSubpatternBegin,
 783         OpParenthesesSubpatternEnd,
 784         // Used to wrap parenthetical assertions.
 785         OpParentheticalAssertionBegin,
 786         OpParentheticalAssertionEnd,
 787         // Wraps all simple terms (pattern characters, character classes).
 788         OpTerm,
 789         // Where an expression contains only &#39;once through&#39; body alternatives
 790         // and no repeating ones, this op is used to return match failure.
 791         OpMatchFailed
 792     };
 793 
 794     // This structure is used to hold the compiled opcode information,
 795     // including reference back to the original PatternTerm/PatternAlternatives,
 796     // and JIT compilation data structures.
 797     struct YarrOp {
 798         explicit YarrOp(PatternTerm* term)
<a name="13" id="anc13"></a><span class="line-modified"> 799             : m_op(OpTerm)</span>
<span class="line-modified"> 800             , m_term(term)</span>
 801             , m_isDeadCode(false)
 802         {
 803         }
 804 
 805         explicit YarrOp(YarrOpCode op)
 806             : m_op(op)
 807             , m_isDeadCode(false)
 808         {
 809         }
 810 
<a name="14" id="anc14"></a><span class="line-removed"> 811         // The operation, as a YarrOpCode, and also a reference to the PatternTerm.</span>
<span class="line-removed"> 812         YarrOpCode m_op;</span>
<span class="line-removed"> 813         PatternTerm* m_term;</span>
<span class="line-removed"> 814 </span>
 815         // For alternatives, this holds the PatternAlternative and doubly linked
 816         // references to this alternative&#39;s siblings. In the case of the
 817         // OpBodyAlternativeEnd node at the end of a section of repeating nodes,
 818         // m_nextOp will reference the OpBodyAlternativeBegin node of the first
 819         // repeating alternative.
 820         PatternAlternative* m_alternative;
 821         size_t m_previousOp;
 822         size_t m_nextOp;
 823 
<a name="15" id="anc15"></a>



 824         // Used to record a set of Jumps out of the generated code, typically
 825         // used for jumps out to backtracking code, and a single reentry back
 826         // into the code for a node (likely where a backtrack will trigger
 827         // rematching).
 828         Label m_reentry;
 829         JumpList m_jumps;
 830 
 831         // Used for backtracking when the prior alternative did not consume any
 832         // characters but matched.
 833         Jump m_zeroLengthMatch;
 834 
 835         // This flag is used to null out the second pattern character, when
 836         // two are fused to match a pair together.
 837         bool m_isDeadCode;
 838 
 839         // Currently used in the case of some of the more complex management of
 840         // &#39;m_checkedOffset&#39;, to cache the offset used in this alternative, to avoid
 841         // recalculating it.
 842         Checked&lt;unsigned&gt; m_checkAdjust;
 843 
 844         // Used by OpNestedAlternativeNext/End to hold the pointer to the
 845         // value that will be pushed into the pattern&#39;s frame to return to,
 846         // upon backtracking back into the disjunction.
 847         DataLabelPtr m_returnAddress;
 848     };
 849 
 850     // BacktrackingState
 851     // This class encapsulates information about the state of code generation
 852     // whilst generating the code for backtracking, when a term fails to match.
 853     // Upon entry to code generation of the backtracking code for a given node,
 854     // the Backtracking state will hold references to all control flow sources
 855     // that are outputs in need of further backtracking from the prior node
 856     // generated (which is the subsequent operation in the regular expression,
 857     // and in the m_ops Vector, since we generated backtracking backwards).
 858     // These references to control flow take the form of:
 859     //  - A jump list of jumps, to be linked to code that will backtrack them
 860     //    further.
 861     //  - A set of DataLabelPtr values, to be populated with values to be
 862     //    treated effectively as return addresses backtracking into complex
 863     //    subpatterns.
 864     //  - A flag indicating that the current sequence of generated code up to
 865     //    this point requires backtracking.
 866     class BacktrackingState {
 867     public:
 868         BacktrackingState()
 869             : m_pendingFallthrough(false)
 870         {
 871         }
 872 
 873         // Add a jump or jumps, a return address, or set the flag indicating
 874         // that the current &#39;fallthrough&#39; control flow requires backtracking.
 875         void append(const Jump&amp; jump)
 876         {
 877             m_laterFailures.append(jump);
 878         }
 879         void append(JumpList&amp; jumpList)
 880         {
 881             m_laterFailures.append(jumpList);
 882         }
 883         void append(const DataLabelPtr&amp; returnAddress)
 884         {
 885             m_pendingReturns.append(returnAddress);
 886         }
 887         void fallthrough()
 888         {
 889             ASSERT(!m_pendingFallthrough);
 890             m_pendingFallthrough = true;
 891         }
 892 
 893         // These methods clear the backtracking state, either linking to the
 894         // current location, a provided label, or copying the backtracking out
 895         // to a JumpList. All actions may require code generation to take place,
 896         // and as such are passed a pointer to the assembler.
 897         void link(MacroAssembler* assembler)
 898         {
 899             if (m_pendingReturns.size()) {
 900                 Label here(assembler);
 901                 for (unsigned i = 0; i &lt; m_pendingReturns.size(); ++i)
 902                     m_backtrackRecords.append(ReturnAddressRecord(m_pendingReturns[i], here));
 903                 m_pendingReturns.clear();
 904             }
 905             m_laterFailures.link(assembler);
 906             m_laterFailures.clear();
 907             m_pendingFallthrough = false;
 908         }
 909         void linkTo(Label label, MacroAssembler* assembler)
 910         {
 911             if (m_pendingReturns.size()) {
 912                 for (unsigned i = 0; i &lt; m_pendingReturns.size(); ++i)
 913                     m_backtrackRecords.append(ReturnAddressRecord(m_pendingReturns[i], label));
 914                 m_pendingReturns.clear();
 915             }
 916             if (m_pendingFallthrough)
 917                 assembler-&gt;jump(label);
 918             m_laterFailures.linkTo(label, assembler);
 919             m_laterFailures.clear();
 920             m_pendingFallthrough = false;
 921         }
 922         void takeBacktracksToJumpList(JumpList&amp; jumpList, MacroAssembler* assembler)
 923         {
 924             if (m_pendingReturns.size()) {
 925                 Label here(assembler);
 926                 for (unsigned i = 0; i &lt; m_pendingReturns.size(); ++i)
 927                     m_backtrackRecords.append(ReturnAddressRecord(m_pendingReturns[i], here));
 928                 m_pendingReturns.clear();
 929                 m_pendingFallthrough = true;
 930             }
 931             if (m_pendingFallthrough)
 932                 jumpList.append(assembler-&gt;jump());
 933             jumpList.append(m_laterFailures);
 934             m_laterFailures.clear();
 935             m_pendingFallthrough = false;
 936         }
 937 
 938         bool isEmpty()
 939         {
 940             return m_laterFailures.empty() &amp;&amp; m_pendingReturns.isEmpty() &amp;&amp; !m_pendingFallthrough;
 941         }
 942 
 943         // Called at the end of code generation to link all return addresses.
 944         void linkDataLabels(LinkBuffer&amp; linkBuffer)
 945         {
 946             ASSERT(isEmpty());
 947             for (unsigned i = 0; i &lt; m_backtrackRecords.size(); ++i)
 948                 linkBuffer.patch(m_backtrackRecords[i].m_dataLabel, linkBuffer.locationOf&lt;YarrBacktrackPtrTag&gt;(m_backtrackRecords[i].m_backtrackLocation));
 949         }
 950 
 951     private:
 952         struct ReturnAddressRecord {
 953             ReturnAddressRecord(DataLabelPtr dataLabel, Label backtrackLocation)
 954                 : m_dataLabel(dataLabel)
 955                 , m_backtrackLocation(backtrackLocation)
 956             {
 957             }
 958 
 959             DataLabelPtr m_dataLabel;
 960             Label m_backtrackLocation;
 961         };
 962 
 963         JumpList m_laterFailures;
 964         bool m_pendingFallthrough;
 965         Vector&lt;DataLabelPtr, 4&gt; m_pendingReturns;
 966         Vector&lt;ReturnAddressRecord, 4&gt; m_backtrackRecords;
 967     };
 968 
 969     // Generation methods:
 970     // ===================
 971 
 972     // This method provides a default implementation of backtracking common
 973     // to many terms; terms commonly jump out of the forwards  matching path
 974     // on any failed conditions, and add these jumps to the m_jumps list. If
 975     // no special handling is required we can often just backtrack to m_jumps.
 976     void backtrackTermDefault(size_t opIndex)
 977     {
 978         YarrOp&amp; op = m_ops[opIndex];
 979         m_backtrackingState.append(op.m_jumps);
 980     }
 981 
 982     void generateAssertionBOL(size_t opIndex)
 983     {
 984         YarrOp&amp; op = m_ops[opIndex];
 985         PatternTerm* term = op.m_term;
 986 
 987         if (m_pattern.multiline()) {
 988             const RegisterID character = regT0;
 989 
 990             JumpList matchDest;
 991             if (!term-&gt;inputPosition)
 992                 matchDest.append(branch32(Equal, index, Imm32(m_checkedOffset.unsafeGet())));
 993 
 994             readCharacter(m_checkedOffset - term-&gt;inputPosition + 1, character);
 995             matchCharacterClass(character, matchDest, m_pattern.newlineCharacterClass());
 996             op.m_jumps.append(jump());
 997 
 998             matchDest.link(this);
 999         } else {
1000             // Erk, really should poison out these alternatives early. :-/
1001             if (term-&gt;inputPosition)
1002                 op.m_jumps.append(jump());
1003             else
1004                 op.m_jumps.append(branch32(NotEqual, index, Imm32(m_checkedOffset.unsafeGet())));
1005         }
1006     }
1007     void backtrackAssertionBOL(size_t opIndex)
1008     {
1009         backtrackTermDefault(opIndex);
1010     }
1011 
1012     void generateAssertionEOL(size_t opIndex)
1013     {
1014         YarrOp&amp; op = m_ops[opIndex];
1015         PatternTerm* term = op.m_term;
1016 
1017         if (m_pattern.multiline()) {
1018             const RegisterID character = regT0;
1019 
1020             JumpList matchDest;
1021             if (term-&gt;inputPosition == m_checkedOffset.unsafeGet())
1022                 matchDest.append(atEndOfInput());
1023 
1024             readCharacter(m_checkedOffset - term-&gt;inputPosition, character);
1025             matchCharacterClass(character, matchDest, m_pattern.newlineCharacterClass());
1026             op.m_jumps.append(jump());
1027 
1028             matchDest.link(this);
1029         } else {
1030             if (term-&gt;inputPosition == m_checkedOffset.unsafeGet())
1031                 op.m_jumps.append(notAtEndOfInput());
1032             // Erk, really should poison out these alternatives early. :-/
1033             else
1034                 op.m_jumps.append(jump());
1035         }
1036     }
1037     void backtrackAssertionEOL(size_t opIndex)
1038     {
1039         backtrackTermDefault(opIndex);
1040     }
1041 
1042     // Also falls though on nextIsNotWordChar.
1043     void matchAssertionWordchar(size_t opIndex, JumpList&amp; nextIsWordChar, JumpList&amp; nextIsNotWordChar)
1044     {
1045         YarrOp&amp; op = m_ops[opIndex];
1046         PatternTerm* term = op.m_term;
1047 
1048         const RegisterID character = regT0;
1049 
1050         if (term-&gt;inputPosition == m_checkedOffset.unsafeGet())
1051             nextIsNotWordChar.append(atEndOfInput());
1052 
1053         readCharacter(m_checkedOffset - term-&gt;inputPosition, character);
1054 
1055         CharacterClass* wordcharCharacterClass;
1056 
1057         if (m_unicodeIgnoreCase)
1058             wordcharCharacterClass = m_pattern.wordUnicodeIgnoreCaseCharCharacterClass();
1059         else
1060             wordcharCharacterClass = m_pattern.wordcharCharacterClass();
1061 
1062         matchCharacterClass(character, nextIsWordChar, wordcharCharacterClass);
1063     }
1064 
1065     void generateAssertionWordBoundary(size_t opIndex)
1066     {
1067         YarrOp&amp; op = m_ops[opIndex];
1068         PatternTerm* term = op.m_term;
1069 
1070         const RegisterID character = regT0;
1071 
1072         Jump atBegin;
1073         JumpList matchDest;
1074         if (!term-&gt;inputPosition)
1075             atBegin = branch32(Equal, index, Imm32(m_checkedOffset.unsafeGet()));
1076         readCharacter(m_checkedOffset - term-&gt;inputPosition + 1, character);
1077 
1078         CharacterClass* wordcharCharacterClass;
1079 
1080         if (m_unicodeIgnoreCase)
1081             wordcharCharacterClass = m_pattern.wordUnicodeIgnoreCaseCharCharacterClass();
1082         else
1083             wordcharCharacterClass = m_pattern.wordcharCharacterClass();
1084 
1085         matchCharacterClass(character, matchDest, wordcharCharacterClass);
1086         if (!term-&gt;inputPosition)
1087             atBegin.link(this);
1088 
1089         // We fall through to here if the last character was not a wordchar.
1090         JumpList nonWordCharThenWordChar;
1091         JumpList nonWordCharThenNonWordChar;
1092         if (term-&gt;invert()) {
1093             matchAssertionWordchar(opIndex, nonWordCharThenNonWordChar, nonWordCharThenWordChar);
1094             nonWordCharThenWordChar.append(jump());
1095         } else {
1096             matchAssertionWordchar(opIndex, nonWordCharThenWordChar, nonWordCharThenNonWordChar);
1097             nonWordCharThenNonWordChar.append(jump());
1098         }
1099         op.m_jumps.append(nonWordCharThenNonWordChar);
1100 
1101         // We jump here if the last character was a wordchar.
1102         matchDest.link(this);
1103         JumpList wordCharThenWordChar;
1104         JumpList wordCharThenNonWordChar;
1105         if (term-&gt;invert()) {
1106             matchAssertionWordchar(opIndex, wordCharThenNonWordChar, wordCharThenWordChar);
1107             wordCharThenWordChar.append(jump());
1108         } else {
1109             matchAssertionWordchar(opIndex, wordCharThenWordChar, wordCharThenNonWordChar);
1110             // This can fall-though!
1111         }
1112 
1113         op.m_jumps.append(wordCharThenWordChar);
1114 
1115         nonWordCharThenWordChar.link(this);
1116         wordCharThenNonWordChar.link(this);
1117     }
1118     void backtrackAssertionWordBoundary(size_t opIndex)
1119     {
1120         backtrackTermDefault(opIndex);
1121     }
1122 
1123 #if ENABLE(YARR_JIT_BACKREFERENCES)
1124     void matchBackreference(size_t opIndex, JumpList&amp; characterMatchFails, RegisterID character, RegisterID patternIndex, RegisterID patternCharacter)
1125     {
1126         YarrOp&amp; op = m_ops[opIndex];
1127         PatternTerm* term = op.m_term;
1128         unsigned subpatternId = term-&gt;backReferenceSubpatternId;
1129 
1130         Label loop(this);
1131 
1132         readCharacterDontDecodeSurrogates(0, patternCharacter, patternIndex);
1133         readCharacterDontDecodeSurrogates(m_checkedOffset - term-&gt;inputPosition, character);
1134 
1135         if (!m_pattern.ignoreCase())
1136             characterMatchFails.append(branch32(NotEqual, character, patternCharacter));
1137         else {
1138             Jump charactersMatch = branch32(Equal, character, patternCharacter);
1139             ExtendedAddress characterTableEntry(character, reinterpret_cast&lt;intptr_t&gt;(&amp;canonicalTableLChar));
1140             load16(characterTableEntry, character);
1141             ExtendedAddress patternTableEntry(patternCharacter, reinterpret_cast&lt;intptr_t&gt;(&amp;canonicalTableLChar));
1142             load16(patternTableEntry, patternCharacter);
1143             characterMatchFails.append(branch32(NotEqual, character, patternCharacter));
1144             charactersMatch.link(this);
1145         }
1146 
1147 
1148         add32(TrustedImm32(1), index);
1149         add32(TrustedImm32(1), patternIndex);
1150 
1151         branch32(NotEqual, patternIndex, Address(output, ((subpatternId &lt;&lt; 1) + 1) * sizeof(int))).linkTo(loop, this);
1152     }
1153 
1154     void generateBackReference(size_t opIndex)
1155     {
1156         YarrOp&amp; op = m_ops[opIndex];
1157         PatternTerm* term = op.m_term;
1158 
1159         if (m_pattern.ignoreCase() &amp;&amp; m_charSize != Char8) {
1160             m_failureReason = JITFailureReason::BackReference;
1161             return;
1162         }
1163 
1164         unsigned subpatternId = term-&gt;backReferenceSubpatternId;
1165         unsigned parenthesesFrameLocation = term-&gt;frameLocation;
1166 
1167         const RegisterID characterOrTemp = regT0;
1168         const RegisterID patternIndex = regT1;
1169         const RegisterID patternTemp = regT2;
1170 
1171         storeToFrame(index, parenthesesFrameLocation + BackTrackInfoBackReference::beginIndex());
1172         if (term-&gt;quantityType != QuantifierFixedCount || term-&gt;quantityMaxCount != 1)
1173             storeToFrame(TrustedImm32(0), parenthesesFrameLocation + BackTrackInfoBackReference::matchAmountIndex());
1174 
1175         JumpList matches;
1176 
1177         if (term-&gt;quantityType != QuantifierNonGreedy) {
1178             load32(Address(output, (subpatternId &lt;&lt; 1) * sizeof(int)), patternIndex);
1179             load32(Address(output, ((subpatternId &lt;&lt; 1) + 1) * sizeof(int)), patternTemp);
1180 
1181             // An empty match is successful without consuming characters
1182             if (term-&gt;quantityType != QuantifierFixedCount || term-&gt;quantityMaxCount != 1) {
1183                 matches.append(branch32(Equal, TrustedImm32(-1), patternIndex));
1184                 matches.append(branch32(Equal, patternIndex, patternTemp));
1185             } else {
1186                 Jump zeroLengthMatch = branch32(Equal, TrustedImm32(-1), patternIndex);
1187                 Jump tryNonZeroMatch = branch32(NotEqual, patternIndex, patternTemp);
1188                 zeroLengthMatch.link(this);
1189                 storeToFrame(TrustedImm32(1), parenthesesFrameLocation + BackTrackInfoBackReference::matchAmountIndex());
1190                 matches.append(jump());
1191                 tryNonZeroMatch.link(this);
1192             }
1193         }
1194 
1195         switch (term-&gt;quantityType) {
1196         case QuantifierFixedCount: {
1197             Label outerLoop(this);
1198 
1199             // PatternTemp should contain pattern end index at this point
1200             sub32(patternIndex, patternTemp);
1201             op.m_jumps.append(checkNotEnoughInput(patternTemp));
1202 
1203             matchBackreference(opIndex, op.m_jumps, characterOrTemp, patternIndex, patternTemp);
1204 
1205             if (term-&gt;quantityMaxCount != 1) {
1206                 loadFromFrame(parenthesesFrameLocation + BackTrackInfoBackReference::matchAmountIndex(), characterOrTemp);
1207                 add32(TrustedImm32(1), characterOrTemp);
1208                 storeToFrame(characterOrTemp, parenthesesFrameLocation + BackTrackInfoBackReference::matchAmountIndex());
1209                 matches.append(branch32(Equal, Imm32(term-&gt;quantityMaxCount.unsafeGet()), characterOrTemp));
1210                 load32(Address(output, (subpatternId &lt;&lt; 1) * sizeof(int)), patternIndex);
1211                 load32(Address(output, ((subpatternId &lt;&lt; 1) + 1) * sizeof(int)), patternTemp);
1212                 jump(outerLoop);
1213             }
1214             matches.link(this);
1215             break;
1216         }
1217 
1218         case QuantifierGreedy: {
1219             JumpList incompleteMatches;
1220 
1221             Label outerLoop(this);
1222 
1223             // PatternTemp should contain pattern end index at this point
1224             sub32(patternIndex, patternTemp);
1225             matches.append(checkNotEnoughInput(patternTemp));
1226 
1227             matchBackreference(opIndex, incompleteMatches, characterOrTemp, patternIndex, patternTemp);
1228 
1229             loadFromFrame(parenthesesFrameLocation + BackTrackInfoBackReference::matchAmountIndex(), characterOrTemp);
1230             add32(TrustedImm32(1), characterOrTemp);
1231             storeToFrame(characterOrTemp, parenthesesFrameLocation + BackTrackInfoBackReference::matchAmountIndex());
1232             if (term-&gt;quantityMaxCount != quantifyInfinite)
1233                 matches.append(branch32(Equal, Imm32(term-&gt;quantityMaxCount.unsafeGet()), characterOrTemp));
1234             load32(Address(output, (subpatternId &lt;&lt; 1) * sizeof(int)), patternIndex);
1235             load32(Address(output, ((subpatternId &lt;&lt; 1) + 1) * sizeof(int)), patternTemp);
1236 
1237             // Store current index in frame for restoring after a partial match
1238             storeToFrame(index, parenthesesFrameLocation + BackTrackInfoBackReference::beginIndex());
1239             jump(outerLoop);
1240 
1241             incompleteMatches.link(this);
1242             loadFromFrame(parenthesesFrameLocation + BackTrackInfoBackReference::beginIndex(), index);
1243 
1244             matches.link(this);
1245             op.m_reentry = label();
1246             break;
1247         }
1248 
1249         case QuantifierNonGreedy: {
1250             JumpList incompleteMatches;
1251 
1252             matches.append(jump());
1253 
1254             op.m_reentry = label();
1255 
1256             load32(Address(output, (subpatternId &lt;&lt; 1) * sizeof(int)), patternIndex);
1257             load32(Address(output, ((subpatternId &lt;&lt; 1) + 1) * sizeof(int)), patternTemp);
1258 
1259             // An empty match is successful without consuming characters
1260             Jump zeroLengthMatch = branch32(Equal, TrustedImm32(-1), patternIndex);
1261             Jump tryNonZeroMatch = branch32(NotEqual, patternIndex, patternTemp);
1262             zeroLengthMatch.link(this);
1263             storeToFrame(TrustedImm32(1), parenthesesFrameLocation + BackTrackInfoBackReference::matchAmountIndex());
1264             matches.append(jump());
1265             tryNonZeroMatch.link(this);
1266 
1267             // Check if we have input remaining to match
1268             sub32(patternIndex, patternTemp);
1269             matches.append(checkNotEnoughInput(patternTemp));
1270 
1271             storeToFrame(index, parenthesesFrameLocation + BackTrackInfoBackReference::beginIndex());
1272 
1273             matchBackreference(opIndex, incompleteMatches, characterOrTemp, patternIndex, patternTemp);
1274 
1275             matches.append(jump());
1276 
1277             incompleteMatches.link(this);
1278             loadFromFrame(parenthesesFrameLocation + BackTrackInfoBackReference::beginIndex(), index);
1279 
1280             matches.link(this);
1281             break;
1282         }
1283         }
1284     }
1285     void backtrackBackReference(size_t opIndex)
1286     {
1287         YarrOp&amp; op = m_ops[opIndex];
1288         PatternTerm* term = op.m_term;
1289 
1290         unsigned subpatternId = term-&gt;backReferenceSubpatternId;
1291 
1292         m_backtrackingState.link(this);
1293         op.m_jumps.link(this);
1294 
1295         JumpList failures;
1296 
1297         unsigned parenthesesFrameLocation = term-&gt;frameLocation;
1298         switch (term-&gt;quantityType) {
1299         case QuantifierFixedCount:
1300             loadFromFrame(parenthesesFrameLocation + BackTrackInfoBackReference::beginIndex(), index);
1301             break;
1302 
1303         case QuantifierGreedy: {
1304             const RegisterID matchAmount = regT0;
1305             const RegisterID patternStartIndex = regT1;
1306             const RegisterID patternEndIndexOrLen = regT2;
1307 
1308             loadFromFrame(parenthesesFrameLocation + BackTrackInfoBackReference::matchAmountIndex(), matchAmount);
1309             failures.append(branchTest32(Zero, matchAmount));
1310 
1311             load32(Address(output, (subpatternId &lt;&lt; 1) * sizeof(int)), patternStartIndex);
1312             load32(Address(output, ((subpatternId &lt;&lt; 1) + 1) * sizeof(int)), patternEndIndexOrLen);
1313             sub32(patternStartIndex, patternEndIndexOrLen);
1314             sub32(patternEndIndexOrLen, index);
1315 
1316             sub32(TrustedImm32(1), matchAmount);
1317             storeToFrame(matchAmount, parenthesesFrameLocation + BackTrackInfoBackReference::matchAmountIndex());
1318             jump(op.m_reentry);
1319             break;
1320         }
1321 
1322         case QuantifierNonGreedy: {
1323             const RegisterID matchAmount = regT0;
1324 
1325             failures.append(atEndOfInput());
1326             loadFromFrame(parenthesesFrameLocation + BackTrackInfoBackReference::matchAmountIndex(), matchAmount);
1327             if (term-&gt;quantityMaxCount != quantifyInfinite)
1328                 failures.append(branch32(AboveOrEqual, Imm32(term-&gt;quantityMaxCount.unsafeGet()), matchAmount));
1329             add32(TrustedImm32(1), matchAmount);
1330             storeToFrame(matchAmount, parenthesesFrameLocation + BackTrackInfoBackReference::matchAmountIndex());
1331             jump(op.m_reentry);
1332             break;
1333         }
1334         }
1335         failures.link(this);
1336         m_backtrackingState.fallthrough();
1337     }
1338 #endif
1339 
1340     void generatePatternCharacterOnce(size_t opIndex)
1341     {
1342         YarrOp&amp; op = m_ops[opIndex];
1343 
1344         if (op.m_isDeadCode)
1345             return;
1346 
1347         // m_ops always ends with a OpBodyAlternativeEnd or OpMatchFailed
1348         // node, so there must always be at least one more node.
1349         ASSERT(opIndex + 1 &lt; m_ops.size());
1350         YarrOp* nextOp = &amp;m_ops[opIndex + 1];
1351 
1352         PatternTerm* term = op.m_term;
1353         UChar32 ch = term-&gt;patternCharacter;
1354 
<a name="16" id="anc16"></a><span class="line-modified">1355         if ((ch &gt; 0xff) &amp;&amp; (m_charSize == Char8)) {</span>
1356             // Have a 16 bit pattern character and an 8 bit string - short circuit
1357             op.m_jumps.append(jump());
1358             return;
1359         }
1360 
1361         const RegisterID character = regT0;
1362 #if CPU(X86_64) || CPU(ARM64)
1363         unsigned maxCharactersAtOnce = m_charSize == Char8 ? 8 : 4;
1364 #else
1365         unsigned maxCharactersAtOnce = m_charSize == Char8 ? 4 : 2;
1366 #endif
1367         uint64_t ignoreCaseMask = 0;
1368 #if CPU(BIG_ENDIAN)
1369         uint64_t allCharacters = ch &lt;&lt; (m_charSize == Char8 ? 24 : 16);
1370 #else
1371         uint64_t allCharacters = ch;
1372 #endif
1373         unsigned numberCharacters;
1374         unsigned startTermPosition = term-&gt;inputPosition;
1375 
1376         // For case-insesitive compares, non-ascii characters that have different
1377         // upper &amp; lower case representations are converted to a character class.
1378         ASSERT(!m_pattern.ignoreCase() || isASCIIAlpha(ch) || isCanonicallyUnique(ch, m_canonicalMode));
1379 
1380         if (m_pattern.ignoreCase() &amp;&amp; isASCIIAlpha(ch)) {
1381 #if CPU(BIG_ENDIAN)
1382             ignoreCaseMask |= 32 &lt;&lt; (m_charSize == Char8 ? 24 : 16);
1383 #else
1384             ignoreCaseMask |= 32;
1385 #endif
1386         }
1387 
1388         for (numberCharacters = 1; numberCharacters &lt; maxCharactersAtOnce &amp;&amp; nextOp-&gt;m_op == OpTerm; ++numberCharacters, nextOp = &amp;m_ops[opIndex + numberCharacters]) {
1389             PatternTerm* nextTerm = nextOp-&gt;m_term;
1390 
1391             // YarrJIT handles decoded surrogate pair as one character if unicode flag is enabled.
1392             // Note that the numberCharacters become 1 while the width of the pattern character becomes 32bit in this case.
1393             if (nextTerm-&gt;type != PatternTerm::TypePatternCharacter
1394                 || nextTerm-&gt;quantityType != QuantifierFixedCount
1395                 || nextTerm-&gt;quantityMaxCount != 1
1396                 || nextTerm-&gt;inputPosition != (startTermPosition + numberCharacters)
1397                 || (U16_LENGTH(nextTerm-&gt;patternCharacter) != 1 &amp;&amp; m_decodeSurrogatePairs))
1398                 break;
1399 
1400             nextOp-&gt;m_isDeadCode = true;
1401 
1402 #if CPU(BIG_ENDIAN)
1403             int shiftAmount = (m_charSize == Char8 ? 24 : 16) - ((m_charSize == Char8 ? 8 : 16) * numberCharacters);
1404 #else
1405             int shiftAmount = (m_charSize == Char8 ? 8 : 16) * numberCharacters;
1406 #endif
1407 
1408             UChar32 currentCharacter = nextTerm-&gt;patternCharacter;
1409 
<a name="17" id="anc17"></a><span class="line-modified">1410             if ((currentCharacter &gt; 0xff) &amp;&amp; (m_charSize == Char8)) {</span>
1411                 // Have a 16 bit pattern character and an 8 bit string - short circuit
1412                 op.m_jumps.append(jump());
1413                 return;
1414             }
1415 
1416             // For case-insesitive compares, non-ascii characters that have different
1417             // upper &amp; lower case representations are converted to a character class.
1418             ASSERT(!m_pattern.ignoreCase() || isASCIIAlpha(currentCharacter) || isCanonicallyUnique(currentCharacter, m_canonicalMode));
1419 
1420             allCharacters |= (static_cast&lt;uint64_t&gt;(currentCharacter) &lt;&lt; shiftAmount);
1421 
1422             if ((m_pattern.ignoreCase()) &amp;&amp; (isASCIIAlpha(currentCharacter)))
1423                 ignoreCaseMask |= 32ULL &lt;&lt; shiftAmount;
1424         }
1425 
1426         if (m_decodeSurrogatePairs)
1427             op.m_jumps.append(jumpIfNoAvailableInput());
1428 
1429         if (m_charSize == Char8) {
1430             auto check1 = [&amp;] (Checked&lt;unsigned&gt; offset, UChar32 characters) {
1431                 op.m_jumps.append(jumpIfCharNotEquals(characters, offset, character));
1432             };
1433 
1434             auto check2 = [&amp;] (Checked&lt;unsigned&gt; offset, uint16_t characters, uint16_t mask) {
1435                 load16Unaligned(negativeOffsetIndexedAddress(offset, character), character);
1436                 if (mask)
1437                     or32(Imm32(mask), character);
1438                 op.m_jumps.append(branch32(NotEqual, character, Imm32(characters | mask)));
1439             };
1440 
1441             auto check4 = [&amp;] (Checked&lt;unsigned&gt; offset, unsigned characters, unsigned mask) {
1442                 if (mask) {
1443                     load32WithUnalignedHalfWords(negativeOffsetIndexedAddress(offset, character), character);
1444                     if (mask)
1445                         or32(Imm32(mask), character);
1446                     op.m_jumps.append(branch32(NotEqual, character, Imm32(characters | mask)));
1447                     return;
1448                 }
1449                 op.m_jumps.append(branch32WithUnalignedHalfWords(NotEqual, negativeOffsetIndexedAddress(offset, character), TrustedImm32(characters)));
1450             };
1451 
1452 #if CPU(X86_64) || CPU(ARM64)
1453             auto check8 = [&amp;] (Checked&lt;unsigned&gt; offset, uint64_t characters, uint64_t mask) {
1454                 load64(negativeOffsetIndexedAddress(offset, character), character);
1455                 if (mask)
1456                     or64(TrustedImm64(mask), character);
1457                 op.m_jumps.append(branch64(NotEqual, character, TrustedImm64(characters | mask)));
1458             };
1459 #endif
1460 
1461             switch (numberCharacters) {
1462             case 1:
1463                 // Use 32bit width of allCharacters since Yarr counts surrogate pairs as one character with unicode flag.
1464                 check1(m_checkedOffset - startTermPosition, allCharacters &amp; 0xffffffff);
1465                 return;
1466             case 2: {
1467                 check2(m_checkedOffset - startTermPosition, allCharacters &amp; 0xffff, ignoreCaseMask &amp; 0xffff);
1468                 return;
1469             }
1470             case 3: {
1471                 check2(m_checkedOffset - startTermPosition, allCharacters &amp; 0xffff, ignoreCaseMask &amp; 0xffff);
1472                 check1(m_checkedOffset - startTermPosition - 2, (allCharacters &gt;&gt; 16) &amp; 0xff);
1473                 return;
1474             }
1475             case 4: {
1476                 check4(m_checkedOffset - startTermPosition, allCharacters &amp; 0xffffffff, ignoreCaseMask &amp; 0xffffffff);
1477                 return;
1478             }
1479 #if CPU(X86_64) || CPU(ARM64)
1480             case 5: {
1481                 check4(m_checkedOffset - startTermPosition, allCharacters &amp; 0xffffffff, ignoreCaseMask &amp; 0xffffffff);
1482                 check1(m_checkedOffset - startTermPosition - 4, (allCharacters &gt;&gt; 32) &amp; 0xff);
1483                 return;
1484             }
1485             case 6: {
1486                 check4(m_checkedOffset - startTermPosition, allCharacters &amp; 0xffffffff, ignoreCaseMask &amp; 0xffffffff);
1487                 check2(m_checkedOffset - startTermPosition - 4, (allCharacters &gt;&gt; 32) &amp; 0xffff, (ignoreCaseMask &gt;&gt; 32) &amp; 0xffff);
1488                 return;
1489             }
1490             case 7: {
1491                 check4(m_checkedOffset - startTermPosition, allCharacters &amp; 0xffffffff, ignoreCaseMask &amp; 0xffffffff);
1492                 check2(m_checkedOffset - startTermPosition - 4, (allCharacters &gt;&gt; 32) &amp; 0xffff, (ignoreCaseMask &gt;&gt; 32) &amp; 0xffff);
1493                 check1(m_checkedOffset - startTermPosition - 6, (allCharacters &gt;&gt; 48) &amp; 0xff);
1494                 return;
1495             }
1496             case 8: {
1497                 check8(m_checkedOffset - startTermPosition, allCharacters, ignoreCaseMask);
1498                 return;
1499             }
1500 #endif
1501             }
1502         } else {
1503             auto check1 = [&amp;] (Checked&lt;unsigned&gt; offset, UChar32 characters) {
1504                 op.m_jumps.append(jumpIfCharNotEquals(characters, offset, character));
1505             };
1506 
1507             auto check2 = [&amp;] (Checked&lt;unsigned&gt; offset, unsigned characters, unsigned mask) {
1508                 if (mask) {
1509                     load32WithUnalignedHalfWords(negativeOffsetIndexedAddress(offset, character), character);
1510                     if (mask)
1511                         or32(Imm32(mask), character);
1512                     op.m_jumps.append(branch32(NotEqual, character, Imm32(characters | mask)));
1513                     return;
1514                 }
1515                 op.m_jumps.append(branch32WithUnalignedHalfWords(NotEqual, negativeOffsetIndexedAddress(offset, character), TrustedImm32(characters)));
1516             };
1517 
1518 #if CPU(X86_64) || CPU(ARM64)
1519             auto check4 = [&amp;] (Checked&lt;unsigned&gt; offset, uint64_t characters, uint64_t mask) {
1520                 load64(negativeOffsetIndexedAddress(offset, character), character);
1521                 if (mask)
1522                     or64(TrustedImm64(mask), character);
1523                 op.m_jumps.append(branch64(NotEqual, character, TrustedImm64(characters | mask)));
1524             };
1525 #endif
1526 
1527             switch (numberCharacters) {
1528             case 1:
1529                 // Use 32bit width of allCharacters since Yarr counts surrogate pairs as one character with unicode flag.
1530                 check1(m_checkedOffset - startTermPosition, allCharacters &amp; 0xffffffff);
1531                 return;
1532             case 2:
1533                 check2(m_checkedOffset - startTermPosition, allCharacters &amp; 0xffffffff, ignoreCaseMask &amp; 0xffffffff);
1534                 return;
1535 #if CPU(X86_64) || CPU(ARM64)
1536             case 3:
1537                 check2(m_checkedOffset - startTermPosition, allCharacters &amp; 0xffffffff, ignoreCaseMask &amp; 0xffffffff);
1538                 check1(m_checkedOffset - startTermPosition - 2, (allCharacters &gt;&gt; 32) &amp; 0xffff);
1539                 return;
1540             case 4:
1541                 check4(m_checkedOffset - startTermPosition, allCharacters, ignoreCaseMask);
1542                 return;
1543 #endif
1544             }
1545         }
1546     }
1547     void backtrackPatternCharacterOnce(size_t opIndex)
1548     {
1549         backtrackTermDefault(opIndex);
1550     }
1551 
1552     void generatePatternCharacterFixed(size_t opIndex)
1553     {
1554         YarrOp&amp; op = m_ops[opIndex];
1555         PatternTerm* term = op.m_term;
1556         UChar32 ch = term-&gt;patternCharacter;
1557 
1558         const RegisterID character = regT0;
1559         const RegisterID countRegister = regT1;
1560 
1561         if (m_decodeSurrogatePairs)
1562             op.m_jumps.append(jumpIfNoAvailableInput());
1563 
1564         move(index, countRegister);
1565         Checked&lt;unsigned&gt; scaledMaxCount = term-&gt;quantityMaxCount;
1566         scaledMaxCount *= U_IS_BMP(ch) ? 1 : 2;
1567         sub32(Imm32(scaledMaxCount.unsafeGet()), countRegister);
1568 
1569         Label loop(this);
1570         readCharacter(m_checkedOffset - term-&gt;inputPosition - scaledMaxCount, character, countRegister);
1571         // For case-insesitive compares, non-ascii characters that have different
1572         // upper &amp; lower case representations are converted to a character class.
1573         ASSERT(!m_pattern.ignoreCase() || isASCIIAlpha(ch) || isCanonicallyUnique(ch, m_canonicalMode));
1574         if (m_pattern.ignoreCase() &amp;&amp; isASCIIAlpha(ch)) {
1575             or32(TrustedImm32(0x20), character);
1576             ch |= 0x20;
1577         }
1578 
1579         op.m_jumps.append(branch32(NotEqual, character, Imm32(ch)));
1580 #ifdef JIT_UNICODE_EXPRESSIONS
1581         if (m_decodeSurrogatePairs &amp;&amp; !U_IS_BMP(ch))
1582             add32(TrustedImm32(2), countRegister);
1583         else
1584 #endif
1585             add32(TrustedImm32(1), countRegister);
1586         branch32(NotEqual, countRegister, index).linkTo(loop, this);
1587     }
1588     void backtrackPatternCharacterFixed(size_t opIndex)
1589     {
1590         backtrackTermDefault(opIndex);
1591     }
1592 
1593     void generatePatternCharacterGreedy(size_t opIndex)
1594     {
1595         YarrOp&amp; op = m_ops[opIndex];
1596         PatternTerm* term = op.m_term;
1597         UChar32 ch = term-&gt;patternCharacter;
1598 
1599         const RegisterID character = regT0;
1600         const RegisterID countRegister = regT1;
1601 
1602         move(TrustedImm32(0), countRegister);
1603 
1604         // Unless have a 16 bit pattern character and an 8 bit string - short circuit
<a name="18" id="anc18"></a><span class="line-modified">1605         if (!((ch &gt; 0xff) &amp;&amp; (m_charSize == Char8))) {</span>
1606             JumpList failures;
1607             Label loop(this);
1608             failures.append(atEndOfInput());
1609             failures.append(jumpIfCharNotEquals(ch, m_checkedOffset - term-&gt;inputPosition, character));
1610 
1611             add32(TrustedImm32(1), index);
1612 #ifdef JIT_UNICODE_EXPRESSIONS
1613             if (m_decodeSurrogatePairs &amp;&amp; !U_IS_BMP(ch)) {
1614                 Jump surrogatePairOk = notAtEndOfInput();
1615                 sub32(TrustedImm32(1), index);
1616                 failures.append(jump());
1617                 surrogatePairOk.link(this);
1618                 add32(TrustedImm32(1), index);
1619             }
1620 #endif
1621             add32(TrustedImm32(1), countRegister);
1622 
1623             if (term-&gt;quantityMaxCount == quantifyInfinite)
1624                 jump(loop);
1625             else
1626                 branch32(NotEqual, countRegister, Imm32(term-&gt;quantityMaxCount.unsafeGet())).linkTo(loop, this);
1627 
1628             failures.link(this);
1629         }
1630         op.m_reentry = label();
1631 
1632         storeToFrame(countRegister, term-&gt;frameLocation + BackTrackInfoPatternCharacter::matchAmountIndex());
1633     }
1634     void backtrackPatternCharacterGreedy(size_t opIndex)
1635     {
1636         YarrOp&amp; op = m_ops[opIndex];
1637         PatternTerm* term = op.m_term;
1638 
1639         const RegisterID countRegister = regT1;
1640 
1641         m_backtrackingState.link(this);
1642 
1643         loadFromFrame(term-&gt;frameLocation + BackTrackInfoPatternCharacter::matchAmountIndex(), countRegister);
1644         m_backtrackingState.append(branchTest32(Zero, countRegister));
1645         sub32(TrustedImm32(1), countRegister);
1646         if (!m_decodeSurrogatePairs || U_IS_BMP(term-&gt;patternCharacter))
1647             sub32(TrustedImm32(1), index);
1648         else
1649             sub32(TrustedImm32(2), index);
1650         jump(op.m_reentry);
1651     }
1652 
1653     void generatePatternCharacterNonGreedy(size_t opIndex)
1654     {
1655         YarrOp&amp; op = m_ops[opIndex];
1656         PatternTerm* term = op.m_term;
1657 
1658         const RegisterID countRegister = regT1;
1659 
1660         move(TrustedImm32(0), countRegister);
1661         op.m_reentry = label();
1662         storeToFrame(countRegister, term-&gt;frameLocation + BackTrackInfoPatternCharacter::matchAmountIndex());
1663     }
1664     void backtrackPatternCharacterNonGreedy(size_t opIndex)
1665     {
1666         YarrOp&amp; op = m_ops[opIndex];
1667         PatternTerm* term = op.m_term;
1668         UChar32 ch = term-&gt;patternCharacter;
1669 
1670         const RegisterID character = regT0;
1671         const RegisterID countRegister = regT1;
1672 
1673         m_backtrackingState.link(this);
1674 
1675         loadFromFrame(term-&gt;frameLocation + BackTrackInfoPatternCharacter::matchAmountIndex(), countRegister);
1676 
1677         // Unless have a 16 bit pattern character and an 8 bit string - short circuit
<a name="19" id="anc19"></a><span class="line-modified">1678         if (!((ch &gt; 0xff) &amp;&amp; (m_charSize == Char8))) {</span>
1679             JumpList nonGreedyFailures;
1680             nonGreedyFailures.append(atEndOfInput());
1681             if (term-&gt;quantityMaxCount != quantifyInfinite)
1682                 nonGreedyFailures.append(branch32(Equal, countRegister, Imm32(term-&gt;quantityMaxCount.unsafeGet())));
1683             nonGreedyFailures.append(jumpIfCharNotEquals(ch, m_checkedOffset - term-&gt;inputPosition, character));
1684 
1685             add32(TrustedImm32(1), index);
1686 #ifdef JIT_UNICODE_EXPRESSIONS
1687             if (m_decodeSurrogatePairs &amp;&amp; !U_IS_BMP(ch)) {
1688                 Jump surrogatePairOk = notAtEndOfInput();
1689                 sub32(TrustedImm32(1), index);
1690                 nonGreedyFailures.append(jump());
1691                 surrogatePairOk.link(this);
1692                 add32(TrustedImm32(1), index);
1693             }
1694 #endif
1695             add32(TrustedImm32(1), countRegister);
1696 
1697             jump(op.m_reentry);
1698             nonGreedyFailures.link(this);
1699         }
1700 
1701         if (m_decodeSurrogatePairs &amp;&amp; !U_IS_BMP(ch)) {
1702             // subtract countRegister*2 for non-BMP characters
1703             lshift32(TrustedImm32(1), countRegister);
1704         }
1705 
1706         sub32(countRegister, index);
1707         m_backtrackingState.fallthrough();
1708     }
1709 
1710     void generateCharacterClassOnce(size_t opIndex)
1711     {
1712         YarrOp&amp; op = m_ops[opIndex];
1713         PatternTerm* term = op.m_term;
1714 
1715         const RegisterID character = regT0;
1716 
1717         if (m_decodeSurrogatePairs) {
1718             op.m_jumps.append(jumpIfNoAvailableInput());
1719             storeToFrame(index, term-&gt;frameLocation + BackTrackInfoCharacterClass::beginIndex());
1720         }
1721 
1722         JumpList matchDest;
1723         readCharacter(m_checkedOffset - term-&gt;inputPosition, character);
1724         // If we are matching the &quot;any character&quot; builtin class we only need to read the
1725         // character and don&#39;t need to match as it will always succeed.
1726         if (term-&gt;invert() || !term-&gt;characterClass-&gt;m_anyCharacter) {
1727             matchCharacterClass(character, matchDest, term-&gt;characterClass);
1728 
1729             if (term-&gt;invert())
1730                 op.m_jumps.append(matchDest);
1731             else {
1732                 op.m_jumps.append(jump());
1733                 matchDest.link(this);
1734             }
1735         }
1736 #ifdef JIT_UNICODE_EXPRESSIONS
<a name="20" id="anc20"></a><span class="line-modified">1737         if (m_decodeSurrogatePairs) {</span>
1738             Jump isBMPChar = branch32(LessThan, character, supplementaryPlanesBase);
<a name="21" id="anc21"></a>
1739             add32(TrustedImm32(1), index);
1740             isBMPChar.link(this);
1741         }
1742 #endif
1743     }
1744     void backtrackCharacterClassOnce(size_t opIndex)
1745     {
1746 #ifdef JIT_UNICODE_EXPRESSIONS
1747         if (m_decodeSurrogatePairs) {
1748             YarrOp&amp; op = m_ops[opIndex];
1749             PatternTerm* term = op.m_term;
1750 
1751             m_backtrackingState.link(this);
1752             loadFromFrame(term-&gt;frameLocation + BackTrackInfoCharacterClass::beginIndex(), index);
1753             m_backtrackingState.fallthrough();
1754         }
1755 #endif
1756         backtrackTermDefault(opIndex);
1757     }
1758 
1759     void generateCharacterClassFixed(size_t opIndex)
1760     {
1761         YarrOp&amp; op = m_ops[opIndex];
1762         PatternTerm* term = op.m_term;
1763 
1764         const RegisterID character = regT0;
1765         const RegisterID countRegister = regT1;
1766 
1767         if (m_decodeSurrogatePairs)
1768             op.m_jumps.append(jumpIfNoAvailableInput());
1769 
1770         move(index, countRegister);
<a name="22" id="anc22"></a><span class="line-modified">1771         sub32(Imm32(term-&gt;quantityMaxCount.unsafeGet()), countRegister);</span>







1772 
1773         Label loop(this);
1774         JumpList matchDest;
<a name="23" id="anc23"></a><span class="line-modified">1775         readCharacter(m_checkedOffset - term-&gt;inputPosition - term-&gt;quantityMaxCount, character, countRegister);</span>
1776         // If we are matching the &quot;any character&quot; builtin class we only need to read the
1777         // character and don&#39;t need to match as it will always succeed.
1778         if (term-&gt;invert() || !term-&gt;characterClass-&gt;m_anyCharacter) {
1779             matchCharacterClass(character, matchDest, term-&gt;characterClass);
1780 
1781             if (term-&gt;invert())
1782                 op.m_jumps.append(matchDest);
1783             else {
1784                 op.m_jumps.append(jump());
1785                 matchDest.link(this);
1786             }
1787         }
1788 
<a name="24" id="anc24"></a><span class="line-removed">1789         add32(TrustedImm32(1), countRegister);</span>
1790 #ifdef JIT_UNICODE_EXPRESSIONS
1791         if (m_decodeSurrogatePairs) {
<a name="25" id="anc25"></a><span class="line-modified">1792             Jump isBMPChar = branch32(LessThan, character, supplementaryPlanesBase);</span>
<span class="line-modified">1793             op.m_jumps.append(atEndOfInput());</span>
<span class="line-modified">1794             add32(TrustedImm32(1), countRegister);</span>
<span class="line-modified">1795             add32(TrustedImm32(1), index);</span>
<span class="line-modified">1796             isBMPChar.link(this);</span>
<span class="line-modified">1797         }</span>





1798 #endif
<a name="26" id="anc26"></a>
1799         branch32(NotEqual, countRegister, index).linkTo(loop, this);
1800     }
1801     void backtrackCharacterClassFixed(size_t opIndex)
1802     {
1803         backtrackTermDefault(opIndex);
1804     }
1805 
1806     void generateCharacterClassGreedy(size_t opIndex)
1807     {
1808         YarrOp&amp; op = m_ops[opIndex];
1809         PatternTerm* term = op.m_term;
1810 
1811         const RegisterID character = regT0;
1812         const RegisterID countRegister = regT1;
1813 
<a name="27" id="anc27"></a><span class="line-modified">1814         if (m_decodeSurrogatePairs)</span>
1815             storeToFrame(index, term-&gt;frameLocation + BackTrackInfoCharacterClass::beginIndex());
1816         move(TrustedImm32(0), countRegister);
1817 
1818         JumpList failures;
<a name="28" id="anc28"></a>
1819         Label loop(this);
<a name="29" id="anc29"></a><span class="line-modified">1820         failures.append(atEndOfInput());</span>






1821 
1822         if (term-&gt;invert()) {
1823             readCharacter(m_checkedOffset - term-&gt;inputPosition, character);
1824             matchCharacterClass(character, failures, term-&gt;characterClass);
1825         } else {
1826             JumpList matchDest;
1827             readCharacter(m_checkedOffset - term-&gt;inputPosition, character);
<a name="30" id="anc30"></a><span class="line-modified">1828             // If we are matching the &quot;any character&quot; builtin class we only need to read the</span>
<span class="line-modified">1829             // character and don&#39;t need to match as it will always succeed.</span>
1830             if (!term-&gt;characterClass-&gt;m_anyCharacter) {
1831                 matchCharacterClass(character, matchDest, term-&gt;characterClass);
1832                 failures.append(jump());
1833             }
1834             matchDest.link(this);
1835         }
1836 
<a name="31" id="anc31"></a><span class="line-removed">1837         add32(TrustedImm32(1), index);</span>
1838 #ifdef JIT_UNICODE_EXPRESSIONS
<a name="32" id="anc32"></a><span class="line-modified">1839         if (m_decodeSurrogatePairs) {</span>
<span class="line-modified">1840             failures.append(atEndOfInput());</span>
<span class="line-modified">1841             Jump isBMPChar = branch32(LessThan, character, supplementaryPlanesBase);</span>
<span class="line-removed">1842             add32(TrustedImm32(1), index);</span>
<span class="line-removed">1843             isBMPChar.link(this);</span>
<span class="line-removed">1844         }</span>
1845 #endif
<a name="33" id="anc33"></a>
1846         add32(TrustedImm32(1), countRegister);
1847 
1848         if (term-&gt;quantityMaxCount != quantifyInfinite) {
1849             branch32(NotEqual, countRegister, Imm32(term-&gt;quantityMaxCount.unsafeGet())).linkTo(loop, this);
1850             failures.append(jump());
1851         } else
1852             jump(loop);
1853 
<a name="34" id="anc34"></a>




1854         failures.link(this);
1855         op.m_reentry = label();
1856 
1857         storeToFrame(countRegister, term-&gt;frameLocation + BackTrackInfoCharacterClass::matchAmountIndex());
1858     }
1859     void backtrackCharacterClassGreedy(size_t opIndex)
1860     {
1861         YarrOp&amp; op = m_ops[opIndex];
1862         PatternTerm* term = op.m_term;
1863 
1864         const RegisterID countRegister = regT1;
1865 
1866         m_backtrackingState.link(this);
1867 
1868         loadFromFrame(term-&gt;frameLocation + BackTrackInfoCharacterClass::matchAmountIndex(), countRegister);
1869         m_backtrackingState.append(branchTest32(Zero, countRegister));
1870         sub32(TrustedImm32(1), countRegister);
<a name="35" id="anc35"></a>

1871         if (!m_decodeSurrogatePairs)
1872             sub32(TrustedImm32(1), index);
<a name="36" id="anc36"></a>

1873         else {
<a name="37" id="anc37"></a>
1874             const RegisterID character = regT0;
1875 
1876             loadFromFrame(term-&gt;frameLocation + BackTrackInfoCharacterClass::beginIndex(), index);
<a name="38" id="anc38"></a><span class="line-removed">1877             // Rematch one less</span>
<span class="line-removed">1878             storeToFrame(countRegister, term-&gt;frameLocation + BackTrackInfoCharacterClass::matchAmountIndex());</span>
1879 
1880             Label rematchLoop(this);
<a name="39" id="anc39"></a>

1881             readCharacter(m_checkedOffset - term-&gt;inputPosition, character);
1882 
1883             sub32(TrustedImm32(1), countRegister);
1884             add32(TrustedImm32(1), index);
1885 
1886 #ifdef JIT_UNICODE_EXPRESSIONS
1887             Jump isBMPChar = branch32(LessThan, character, supplementaryPlanesBase);
1888             add32(TrustedImm32(1), index);
1889             isBMPChar.link(this);
1890 #endif
1891 
<a name="40" id="anc40"></a><span class="line-modified">1892             branchTest32(Zero, countRegister).linkTo(rematchLoop, this);</span>

1893 
1894             loadFromFrame(term-&gt;frameLocation + BackTrackInfoCharacterClass::matchAmountIndex(), countRegister);
1895         }
1896         jump(op.m_reentry);
1897     }
1898 
1899     void generateCharacterClassNonGreedy(size_t opIndex)
1900     {
1901         YarrOp&amp; op = m_ops[opIndex];
1902         PatternTerm* term = op.m_term;
1903 
1904         const RegisterID countRegister = regT1;
1905 
1906         move(TrustedImm32(0), countRegister);
1907         op.m_reentry = label();
<a name="41" id="anc41"></a><span class="line-modified">1908         if (m_decodeSurrogatePairs)</span>
<span class="line-modified">1909             storeToFrame(index, term-&gt;frameLocation + BackTrackInfoCharacterClass::beginIndex());</span>






1910         storeToFrame(countRegister, term-&gt;frameLocation + BackTrackInfoCharacterClass::matchAmountIndex());
1911     }
1912 
1913     void backtrackCharacterClassNonGreedy(size_t opIndex)
1914     {
1915         YarrOp&amp; op = m_ops[opIndex];
1916         PatternTerm* term = op.m_term;
1917 
1918         const RegisterID character = regT0;
1919         const RegisterID countRegister = regT1;
1920 
1921         JumpList nonGreedyFailures;
<a name="42" id="anc42"></a>
1922 
1923         m_backtrackingState.link(this);
1924 
<a name="43" id="anc43"></a><span class="line-modified">1925         if (m_decodeSurrogatePairs)</span>
<span class="line-modified">1926             loadFromFrame(term-&gt;frameLocation + BackTrackInfoCharacterClass::beginIndex(), index);</span>





1927         loadFromFrame(term-&gt;frameLocation + BackTrackInfoCharacterClass::matchAmountIndex(), countRegister);
1928 
1929         nonGreedyFailures.append(atEndOfInput());
1930         nonGreedyFailures.append(branch32(Equal, countRegister, Imm32(term-&gt;quantityMaxCount.unsafeGet())));
1931 
1932         JumpList matchDest;
1933         readCharacter(m_checkedOffset - term-&gt;inputPosition, character);
<a name="44" id="anc44"></a><span class="line-modified">1934         // If we are matching the &quot;any character&quot; builtin class we only need to read the</span>
<span class="line-modified">1935         // character and don&#39;t need to match as it will always succeed.</span>
1936         if (term-&gt;invert() || !term-&gt;characterClass-&gt;m_anyCharacter) {
1937             matchCharacterClass(character, matchDest, term-&gt;characterClass);
1938 
1939             if (term-&gt;invert())
1940                 nonGreedyFailures.append(matchDest);
1941             else {
1942                 nonGreedyFailures.append(jump());
1943                 matchDest.link(this);
1944             }
1945         }
1946 
<a name="45" id="anc45"></a><span class="line-removed">1947         add32(TrustedImm32(1), index);</span>
1948 #ifdef JIT_UNICODE_EXPRESSIONS
<a name="46" id="anc46"></a><span class="line-modified">1949         if (m_decodeSurrogatePairs) {</span>
<span class="line-modified">1950             nonGreedyFailures.append(atEndOfInput());</span>
<span class="line-modified">1951             Jump isBMPChar = branch32(LessThan, character, supplementaryPlanesBase);</span>
<span class="line-removed">1952             add32(TrustedImm32(1), index);</span>
<span class="line-removed">1953             isBMPChar.link(this);</span>
<span class="line-removed">1954         }</span>
1955 #endif
<a name="47" id="anc47"></a>
1956         add32(TrustedImm32(1), countRegister);
1957 
1958         jump(op.m_reentry);
1959 
<a name="48" id="anc48"></a>



1960         nonGreedyFailures.link(this);
1961         sub32(countRegister, index);
1962         m_backtrackingState.fallthrough();
1963     }
1964 
1965     void generateDotStarEnclosure(size_t opIndex)
1966     {
1967         YarrOp&amp; op = m_ops[opIndex];
1968         PatternTerm* term = op.m_term;
1969 
1970         const RegisterID character = regT0;
1971         const RegisterID matchPos = regT1;
1972 #ifndef HAVE_INITIAL_START_REG
1973         const RegisterID initialStart = character;
1974 #endif
1975 
1976         JumpList foundBeginningNewLine;
1977         JumpList saveStartIndex;
1978         JumpList foundEndingNewLine;
1979 
1980         if (m_pattern.dotAll()) {
1981             move(TrustedImm32(0), matchPos);
1982             setMatchStart(matchPos);
1983             move(length, index);
1984             return;
1985         }
1986 
1987         ASSERT(!m_pattern.m_body-&gt;m_hasFixedSize);
1988         getMatchStart(matchPos);
1989 
1990 #ifndef HAVE_INITIAL_START_REG
1991         loadFromFrame(m_pattern.m_initialStartValueFrameLocation, initialStart);
1992 #endif
1993         saveStartIndex.append(branch32(BelowOrEqual, matchPos, initialStart));
1994         Label findBOLLoop(this);
1995         sub32(TrustedImm32(1), matchPos);
1996         if (m_charSize == Char8)
1997             load8(BaseIndex(input, matchPos, TimesOne, 0), character);
1998         else
1999             load16(BaseIndex(input, matchPos, TimesTwo, 0), character);
2000         matchCharacterClass(character, foundBeginningNewLine, m_pattern.newlineCharacterClass());
2001 
2002 #ifndef HAVE_INITIAL_START_REG
2003         loadFromFrame(m_pattern.m_initialStartValueFrameLocation, initialStart);
2004 #endif
2005         branch32(Above, matchPos, initialStart).linkTo(findBOLLoop, this);
2006         saveStartIndex.append(jump());
2007 
2008         foundBeginningNewLine.link(this);
2009         add32(TrustedImm32(1), matchPos); // Advance past newline
2010         saveStartIndex.link(this);
2011 
2012         if (!m_pattern.multiline() &amp;&amp; term-&gt;anchors.bolAnchor)
2013             op.m_jumps.append(branchTest32(NonZero, matchPos));
2014 
2015         ASSERT(!m_pattern.m_body-&gt;m_hasFixedSize);
2016         setMatchStart(matchPos);
2017 
2018         move(index, matchPos);
2019 
2020         Label findEOLLoop(this);
2021         foundEndingNewLine.append(branch32(Equal, matchPos, length));
2022         if (m_charSize == Char8)
2023             load8(BaseIndex(input, matchPos, TimesOne, 0), character);
2024         else
2025             load16(BaseIndex(input, matchPos, TimesTwo, 0), character);
2026         matchCharacterClass(character, foundEndingNewLine, m_pattern.newlineCharacterClass());
2027         add32(TrustedImm32(1), matchPos);
2028         jump(findEOLLoop);
2029 
2030         foundEndingNewLine.link(this);
2031 
2032         if (!m_pattern.multiline() &amp;&amp; term-&gt;anchors.eolAnchor)
2033             op.m_jumps.append(branch32(NotEqual, matchPos, length));
2034 
2035         move(matchPos, index);
2036     }
2037 
2038     void backtrackDotStarEnclosure(size_t opIndex)
2039     {
2040         backtrackTermDefault(opIndex);
2041     }
2042 
2043     // Code generation/backtracking for simple terms
2044     // (pattern characters, character classes, and assertions).
2045     // These methods farm out work to the set of functions above.
2046     void generateTerm(size_t opIndex)
2047     {
2048         YarrOp&amp; op = m_ops[opIndex];
2049         PatternTerm* term = op.m_term;
2050 
2051         switch (term-&gt;type) {
2052         case PatternTerm::TypePatternCharacter:
2053             switch (term-&gt;quantityType) {
2054             case QuantifierFixedCount:
2055                 if (term-&gt;quantityMaxCount == 1)
2056                     generatePatternCharacterOnce(opIndex);
2057                 else
2058                     generatePatternCharacterFixed(opIndex);
2059                 break;
2060             case QuantifierGreedy:
2061                 generatePatternCharacterGreedy(opIndex);
2062                 break;
2063             case QuantifierNonGreedy:
2064                 generatePatternCharacterNonGreedy(opIndex);
2065                 break;
2066             }
2067             break;
2068 
2069         case PatternTerm::TypeCharacterClass:
2070             switch (term-&gt;quantityType) {
2071             case QuantifierFixedCount:
2072                 if (term-&gt;quantityMaxCount == 1)
2073                     generateCharacterClassOnce(opIndex);
2074                 else
2075                     generateCharacterClassFixed(opIndex);
2076                 break;
2077             case QuantifierGreedy:
2078                 generateCharacterClassGreedy(opIndex);
2079                 break;
2080             case QuantifierNonGreedy:
2081                 generateCharacterClassNonGreedy(opIndex);
2082                 break;
2083             }
2084             break;
2085 
2086         case PatternTerm::TypeAssertionBOL:
2087             generateAssertionBOL(opIndex);
2088             break;
2089 
2090         case PatternTerm::TypeAssertionEOL:
2091             generateAssertionEOL(opIndex);
2092             break;
2093 
2094         case PatternTerm::TypeAssertionWordBoundary:
2095             generateAssertionWordBoundary(opIndex);
2096             break;
2097 
2098         case PatternTerm::TypeForwardReference:
2099             m_failureReason = JITFailureReason::ForwardReference;
2100             break;
2101 
2102         case PatternTerm::TypeParenthesesSubpattern:
2103         case PatternTerm::TypeParentheticalAssertion:
2104             RELEASE_ASSERT_NOT_REACHED();
2105 
2106         case PatternTerm::TypeBackReference:
2107 #if ENABLE(YARR_JIT_BACKREFERENCES)
2108             generateBackReference(opIndex);
2109 #else
2110             m_failureReason = JITFailureReason::BackReference;
2111 #endif
2112             break;
2113         case PatternTerm::TypeDotStarEnclosure:
2114             generateDotStarEnclosure(opIndex);
2115             break;
2116         }
2117     }
2118     void backtrackTerm(size_t opIndex)
2119     {
2120         YarrOp&amp; op = m_ops[opIndex];
2121         PatternTerm* term = op.m_term;
2122 
2123         switch (term-&gt;type) {
2124         case PatternTerm::TypePatternCharacter:
2125             switch (term-&gt;quantityType) {
2126             case QuantifierFixedCount:
2127                 if (term-&gt;quantityMaxCount == 1)
2128                     backtrackPatternCharacterOnce(opIndex);
2129                 else
2130                     backtrackPatternCharacterFixed(opIndex);
2131                 break;
2132             case QuantifierGreedy:
2133                 backtrackPatternCharacterGreedy(opIndex);
2134                 break;
2135             case QuantifierNonGreedy:
2136                 backtrackPatternCharacterNonGreedy(opIndex);
2137                 break;
2138             }
2139             break;
2140 
2141         case PatternTerm::TypeCharacterClass:
2142             switch (term-&gt;quantityType) {
2143             case QuantifierFixedCount:
2144                 if (term-&gt;quantityMaxCount == 1)
2145                     backtrackCharacterClassOnce(opIndex);
2146                 else
2147                     backtrackCharacterClassFixed(opIndex);
2148                 break;
2149             case QuantifierGreedy:
2150                 backtrackCharacterClassGreedy(opIndex);
2151                 break;
2152             case QuantifierNonGreedy:
2153                 backtrackCharacterClassNonGreedy(opIndex);
2154                 break;
2155             }
2156             break;
2157 
2158         case PatternTerm::TypeAssertionBOL:
2159             backtrackAssertionBOL(opIndex);
2160             break;
2161 
2162         case PatternTerm::TypeAssertionEOL:
2163             backtrackAssertionEOL(opIndex);
2164             break;
2165 
2166         case PatternTerm::TypeAssertionWordBoundary:
2167             backtrackAssertionWordBoundary(opIndex);
2168             break;
2169 
2170         case PatternTerm::TypeForwardReference:
2171             m_failureReason = JITFailureReason::ForwardReference;
2172             break;
2173 
2174         case PatternTerm::TypeParenthesesSubpattern:
2175         case PatternTerm::TypeParentheticalAssertion:
2176             RELEASE_ASSERT_NOT_REACHED();
2177 
2178         case PatternTerm::TypeBackReference:
2179 #if ENABLE(YARR_JIT_BACKREFERENCES)
2180             backtrackBackReference(opIndex);
2181 #else
2182             m_failureReason = JITFailureReason::BackReference;
2183 #endif
2184             break;
2185 
2186         case PatternTerm::TypeDotStarEnclosure:
2187             backtrackDotStarEnclosure(opIndex);
2188             break;
2189         }
2190     }
2191 
2192     void generate()
2193     {
2194         // Forwards generate the matching code.
2195         ASSERT(m_ops.size());
2196         size_t opIndex = 0;
2197 
2198         do {
2199             if (m_disassembler)
2200                 m_disassembler-&gt;setForGenerate(opIndex, label());
2201 
2202             YarrOp&amp; op = m_ops[opIndex];
2203             switch (op.m_op) {
2204 
2205             case OpTerm:
2206                 generateTerm(opIndex);
2207                 break;
2208 
2209             // OpBodyAlternativeBegin/Next/End
2210             //
2211             // These nodes wrap the set of alternatives in the body of the regular expression.
2212             // There may be either one or two chains of OpBodyAlternative nodes, one representing
2213             // the &#39;once through&#39; sequence of alternatives (if any exist), and one representing
2214             // the repeating alternatives (again, if any exist).
2215             //
2216             // Upon normal entry to the Begin alternative, we will check that input is available.
2217             // Reentry to the Begin alternative will take place after the check has taken place,
2218             // and will assume that the input position has already been progressed as appropriate.
2219             //
2220             // Entry to subsequent Next/End alternatives occurs when the prior alternative has
2221             // successfully completed a match - return a success state from JIT code.
2222             //
2223             // Next alternatives allow for reentry optimized to suit backtracking from its
2224             // preceding alternative. It expects the input position to still be set to a position
2225             // appropriate to its predecessor, and it will only perform an input check if the
2226             // predecessor had a minimum size less than its own.
2227             //
2228             // In the case &#39;once through&#39; expressions, the End node will also have a reentry
2229             // point to jump to when the last alternative fails. Again, this expects the input
2230             // position to still reflect that expected by the prior alternative.
2231             case OpBodyAlternativeBegin: {
2232                 PatternAlternative* alternative = op.m_alternative;
2233 
2234                 // Upon entry at the head of the set of alternatives, check if input is available
2235                 // to run the first alternative. (This progresses the input position).
2236                 op.m_jumps.append(jumpIfNoAvailableInput(alternative-&gt;m_minimumSize));
2237                 // We will reenter after the check, and assume the input position to have been
2238                 // set as appropriate to this alternative.
2239                 op.m_reentry = label();
2240 
2241                 m_checkedOffset += alternative-&gt;m_minimumSize;
2242                 break;
2243             }
2244             case OpBodyAlternativeNext:
2245             case OpBodyAlternativeEnd: {
2246                 PatternAlternative* priorAlternative = m_ops[op.m_previousOp].m_alternative;
2247                 PatternAlternative* alternative = op.m_alternative;
2248 
2249                 // If we get here, the prior alternative matched - return success.
2250 
2251                 // Adjust the stack pointer to remove the pattern&#39;s frame.
2252                 removeCallFrame();
2253 
2254                 // Load appropriate values into the return register and the first output
2255                 // slot, and return. In the case of pattern with a fixed size, we will
2256                 // not have yet set the value in the first
2257                 ASSERT(index != returnRegister);
2258                 if (m_pattern.m_body-&gt;m_hasFixedSize) {
2259                     move(index, returnRegister);
2260                     if (priorAlternative-&gt;m_minimumSize)
2261                         sub32(Imm32(priorAlternative-&gt;m_minimumSize), returnRegister);
2262                     if (compileMode == IncludeSubpatterns)
2263                         store32(returnRegister, output);
2264                 } else
2265                     getMatchStart(returnRegister);
2266                 if (compileMode == IncludeSubpatterns)
2267                     store32(index, Address(output, 4));
2268                 move(index, returnRegister2);
2269 
2270                 generateReturn();
2271 
2272                 // This is the divide between the tail of the prior alternative, above, and
2273                 // the head of the subsequent alternative, below.
2274 
2275                 if (op.m_op == OpBodyAlternativeNext) {
2276                     // This is the reentry point for the Next alternative. We expect any code
2277                     // that jumps here to do so with the input position matching that of the
2278                     // PRIOR alteranative, and we will only check input availability if we
2279                     // need to progress it forwards.
2280                     op.m_reentry = label();
2281                     if (alternative-&gt;m_minimumSize &gt; priorAlternative-&gt;m_minimumSize) {
2282                         add32(Imm32(alternative-&gt;m_minimumSize - priorAlternative-&gt;m_minimumSize), index);
2283                         op.m_jumps.append(jumpIfNoAvailableInput());
2284                     } else if (priorAlternative-&gt;m_minimumSize &gt; alternative-&gt;m_minimumSize)
2285                         sub32(Imm32(priorAlternative-&gt;m_minimumSize - alternative-&gt;m_minimumSize), index);
2286                 } else if (op.m_nextOp == notFound) {
2287                     // This is the reentry point for the End of &#39;once through&#39; alternatives,
2288                     // jumped to when the last alternative fails to match.
2289                     op.m_reentry = label();
2290                     sub32(Imm32(priorAlternative-&gt;m_minimumSize), index);
2291                 }
2292 
2293                 if (op.m_op == OpBodyAlternativeNext)
2294                     m_checkedOffset += alternative-&gt;m_minimumSize;
2295                 m_checkedOffset -= priorAlternative-&gt;m_minimumSize;
2296                 break;
2297             }
2298 
2299             // OpSimpleNestedAlternativeBegin/Next/End
2300             // OpNestedAlternativeBegin/Next/End
2301             //
2302             // These nodes are used to handle sets of alternatives that are nested within
2303             // subpatterns and parenthetical assertions. The &#39;simple&#39; forms are used where
2304             // we do not need to be able to backtrack back into any alternative other than
2305             // the last, the normal forms allow backtracking into any alternative.
2306             //
2307             // Each Begin/Next node is responsible for planting an input check to ensure
2308             // sufficient input is available on entry. Next nodes additionally need to
2309             // jump to the end - Next nodes use the End node&#39;s m_jumps list to hold this
2310             // set of jumps.
2311             //
2312             // In the non-simple forms, successful alternative matches must store a
2313             // &#39;return address&#39; using a DataLabelPtr, used to store the address to jump
2314             // to when backtracking, to get to the code for the appropriate alternative.
2315             case OpSimpleNestedAlternativeBegin:
2316             case OpNestedAlternativeBegin: {
2317                 PatternTerm* term = op.m_term;
2318                 PatternAlternative* alternative = op.m_alternative;
2319                 PatternDisjunction* disjunction = term-&gt;parentheses.disjunction;
2320 
2321                 // Calculate how much input we need to check for, and if non-zero check.
2322                 op.m_checkAdjust = Checked&lt;unsigned&gt;(alternative-&gt;m_minimumSize);
2323                 if ((term-&gt;quantityType == QuantifierFixedCount) &amp;&amp; (term-&gt;type != PatternTerm::TypeParentheticalAssertion))
2324                     op.m_checkAdjust -= disjunction-&gt;m_minimumSize;
2325                 if (op.m_checkAdjust)
2326                     op.m_jumps.append(jumpIfNoAvailableInput(op.m_checkAdjust.unsafeGet()));
2327 
2328                 m_checkedOffset += op.m_checkAdjust;
2329                 break;
2330             }
2331             case OpSimpleNestedAlternativeNext:
2332             case OpNestedAlternativeNext: {
2333                 PatternTerm* term = op.m_term;
2334                 PatternAlternative* alternative = op.m_alternative;
2335                 PatternDisjunction* disjunction = term-&gt;parentheses.disjunction;
2336 
2337                 // In the non-simple case, store a &#39;return address&#39; so we can backtrack correctly.
2338                 if (op.m_op == OpNestedAlternativeNext) {
2339                     unsigned parenthesesFrameLocation = term-&gt;frameLocation;
2340                     op.m_returnAddress = storeToFrameWithPatch(parenthesesFrameLocation + BackTrackInfoParentheses::returnAddressIndex());
2341                 }
2342 
2343                 if (term-&gt;quantityType != QuantifierFixedCount &amp;&amp; !m_ops[op.m_previousOp].m_alternative-&gt;m_minimumSize) {
2344                     // If the previous alternative matched without consuming characters then
2345                     // backtrack to try to match while consumming some input.
2346                     op.m_zeroLengthMatch = branch32(Equal, index, Address(stackPointerRegister, term-&gt;frameLocation * sizeof(void*)));
2347                 }
2348 
2349                 // If we reach here then the last alternative has matched - jump to the
2350                 // End node, to skip over any further alternatives.
2351                 //
2352                 // FIXME: this is logically O(N^2) (though N can be expected to be very
2353                 // small). We could avoid this either by adding an extra jump to the JIT
2354                 // data structures, or by making backtracking code that jumps to Next
2355                 // alternatives are responsible for checking that input is available (if
2356                 // we didn&#39;t need to plant the input checks, then m_jumps would be free).
2357                 YarrOp* endOp = &amp;m_ops[op.m_nextOp];
2358                 while (endOp-&gt;m_nextOp != notFound) {
2359                     ASSERT(endOp-&gt;m_op == OpSimpleNestedAlternativeNext || endOp-&gt;m_op == OpNestedAlternativeNext);
2360                     endOp = &amp;m_ops[endOp-&gt;m_nextOp];
2361                 }
2362                 ASSERT(endOp-&gt;m_op == OpSimpleNestedAlternativeEnd || endOp-&gt;m_op == OpNestedAlternativeEnd);
2363                 endOp-&gt;m_jumps.append(jump());
2364 
2365                 // This is the entry point for the next alternative.
2366                 op.m_reentry = label();
2367 
2368                 // Calculate how much input we need to check for, and if non-zero check.
2369                 op.m_checkAdjust = alternative-&gt;m_minimumSize;
2370                 if ((term-&gt;quantityType == QuantifierFixedCount) &amp;&amp; (term-&gt;type != PatternTerm::TypeParentheticalAssertion))
2371                     op.m_checkAdjust -= disjunction-&gt;m_minimumSize;
2372                 if (op.m_checkAdjust)
2373                     op.m_jumps.append(jumpIfNoAvailableInput(op.m_checkAdjust.unsafeGet()));
2374 
2375                 YarrOp&amp; lastOp = m_ops[op.m_previousOp];
2376                 m_checkedOffset -= lastOp.m_checkAdjust;
2377                 m_checkedOffset += op.m_checkAdjust;
2378                 break;
2379             }
2380             case OpSimpleNestedAlternativeEnd:
2381             case OpNestedAlternativeEnd: {
2382                 PatternTerm* term = op.m_term;
2383 
2384                 // In the non-simple case, store a &#39;return address&#39; so we can backtrack correctly.
2385                 if (op.m_op == OpNestedAlternativeEnd) {
2386                     unsigned parenthesesFrameLocation = term-&gt;frameLocation;
2387                     op.m_returnAddress = storeToFrameWithPatch(parenthesesFrameLocation + BackTrackInfoParentheses::returnAddressIndex());
2388                 }
2389 
2390                 if (term-&gt;quantityType != QuantifierFixedCount &amp;&amp; !m_ops[op.m_previousOp].m_alternative-&gt;m_minimumSize) {
2391                     // If the previous alternative matched without consuming characters then
2392                     // backtrack to try to match while consumming some input.
2393                     op.m_zeroLengthMatch = branch32(Equal, index, Address(stackPointerRegister, term-&gt;frameLocation * sizeof(void*)));
2394                 }
2395 
2396                 // If this set of alternatives contains more than one alternative,
2397                 // then the Next nodes will have planted jumps to the End, and added
2398                 // them to this node&#39;s m_jumps list.
2399                 op.m_jumps.link(this);
2400                 op.m_jumps.clear();
2401 
2402                 YarrOp&amp; lastOp = m_ops[op.m_previousOp];
2403                 m_checkedOffset -= lastOp.m_checkAdjust;
2404                 break;
2405             }
2406 
2407             // OpParenthesesSubpatternOnceBegin/End
2408             //
2409             // These nodes support (optionally) capturing subpatterns, that have a
2410             // quantity count of 1 (this covers fixed once, and ?/?? quantifiers).
2411             case OpParenthesesSubpatternOnceBegin: {
2412                 PatternTerm* term = op.m_term;
2413                 unsigned parenthesesFrameLocation = term-&gt;frameLocation;
2414                 const RegisterID indexTemporary = regT0;
2415                 ASSERT(term-&gt;quantityMaxCount == 1);
2416 
2417                 // Upon entry to a Greedy quantified set of parenthese store the index.
2418                 // We&#39;ll use this for two purposes:
2419                 //  - To indicate which iteration we are on of mathing the remainder of
2420                 //    the expression after the parentheses - the first, including the
2421                 //    match within the parentheses, or the second having skipped over them.
2422                 //  - To check for empty matches, which must be rejected.
2423                 //
2424                 // At the head of a NonGreedy set of parentheses we&#39;ll immediately set the
2425                 // value on the stack to -1 (indicating a match skipping the subpattern),
2426                 // and plant a jump to the end. We&#39;ll also plant a label to backtrack to
2427                 // to reenter the subpattern later, with a store to set up index on the
2428                 // second iteration.
2429                 //
2430                 // FIXME: for capturing parens, could use the index in the capture array?
2431                 if (term-&gt;quantityType == QuantifierGreedy)
2432                     storeToFrame(index, parenthesesFrameLocation + BackTrackInfoParenthesesOnce::beginIndex());
2433                 else if (term-&gt;quantityType == QuantifierNonGreedy) {
2434                     storeToFrame(TrustedImm32(-1), parenthesesFrameLocation + BackTrackInfoParenthesesOnce::beginIndex());
2435                     op.m_jumps.append(jump());
2436                     op.m_reentry = label();
2437                     storeToFrame(index, parenthesesFrameLocation + BackTrackInfoParenthesesOnce::beginIndex());
2438                 }
2439 
2440                 // If the parenthese are capturing, store the starting index value to the
2441                 // captures array, offsetting as necessary.
2442                 //
2443                 // FIXME: could avoid offsetting this value in JIT code, apply
2444                 // offsets only afterwards, at the point the results array is
2445                 // being accessed.
2446                 if (term-&gt;capture() &amp;&amp; compileMode == IncludeSubpatterns) {
2447                     unsigned inputOffset = (m_checkedOffset - term-&gt;inputPosition).unsafeGet();
2448                     if (term-&gt;quantityType == QuantifierFixedCount)
2449                         inputOffset += term-&gt;parentheses.disjunction-&gt;m_minimumSize;
2450                     if (inputOffset) {
2451                         move(index, indexTemporary);
2452                         sub32(Imm32(inputOffset), indexTemporary);
2453                         setSubpatternStart(indexTemporary, term-&gt;parentheses.subpatternId);
2454                     } else
2455                         setSubpatternStart(index, term-&gt;parentheses.subpatternId);
2456                 }
2457                 break;
2458             }
2459             case OpParenthesesSubpatternOnceEnd: {
2460                 PatternTerm* term = op.m_term;
2461                 const RegisterID indexTemporary = regT0;
2462                 ASSERT(term-&gt;quantityMaxCount == 1);
2463 
<a name="49" id="anc49"></a><span class="line-modified">2464                 // Runtime ASSERT to make sure that the nested alternative handled the</span>
<span class="line-modified">2465                 // &quot;no input consumed&quot; check.</span>
<span class="line-modified">2466                 if (!ASSERT_DISABLED &amp;&amp; term-&gt;quantityType != QuantifierFixedCount &amp;&amp; !term-&gt;parentheses.disjunction-&gt;m_minimumSize) {</span>
<span class="line-modified">2467                     Jump pastBreakpoint;</span>
<span class="line-modified">2468                     pastBreakpoint = branch32(NotEqual, index, Address(stackPointerRegister, term-&gt;frameLocation * sizeof(void*)));</span>
<span class="line-removed">2469                     abortWithReason(YARRNoInputConsumed);</span>
<span class="line-removed">2470                     pastBreakpoint.link(this);</span>
<span class="line-removed">2471                 }</span>
2472 
2473                 // If the parenthese are capturing, store the ending index value to the
2474                 // captures array, offsetting as necessary.
2475                 //
2476                 // FIXME: could avoid offsetting this value in JIT code, apply
2477                 // offsets only afterwards, at the point the results array is
2478                 // being accessed.
2479                 if (term-&gt;capture() &amp;&amp; compileMode == IncludeSubpatterns) {
2480                     unsigned inputOffset = (m_checkedOffset - term-&gt;inputPosition).unsafeGet();
2481                     if (inputOffset) {
2482                         move(index, indexTemporary);
2483                         sub32(Imm32(inputOffset), indexTemporary);
2484                         setSubpatternEnd(indexTemporary, term-&gt;parentheses.subpatternId);
2485                     } else
2486                         setSubpatternEnd(index, term-&gt;parentheses.subpatternId);
2487                 }
2488 
2489                 // If the parentheses are quantified Greedy then add a label to jump back
2490                 // to if we get a failed match from after the parentheses. For NonGreedy
2491                 // parentheses, link the jump from before the subpattern to here.
2492                 if (term-&gt;quantityType == QuantifierGreedy)
2493                     op.m_reentry = label();
2494                 else if (term-&gt;quantityType == QuantifierNonGreedy) {
2495                     YarrOp&amp; beginOp = m_ops[op.m_previousOp];
2496                     beginOp.m_jumps.link(this);
2497                 }
2498                 break;
2499             }
2500 
2501             // OpParenthesesSubpatternTerminalBegin/End
2502             case OpParenthesesSubpatternTerminalBegin: {
2503                 PatternTerm* term = op.m_term;
2504                 ASSERT(term-&gt;quantityType == QuantifierGreedy);
2505                 ASSERT(term-&gt;quantityMaxCount == quantifyInfinite);
2506                 ASSERT(!term-&gt;capture());
2507 
2508                 // Upon entry set a label to loop back to.
2509                 op.m_reentry = label();
2510 
2511                 // Store the start index of the current match; we need to reject zero
2512                 // length matches.
2513                 storeToFrame(index, term-&gt;frameLocation + BackTrackInfoParenthesesTerminal::beginIndex());
2514                 break;
2515             }
2516             case OpParenthesesSubpatternTerminalEnd: {
2517                 YarrOp&amp; beginOp = m_ops[op.m_previousOp];
<a name="50" id="anc50"></a><span class="line-modified">2518                 if (!ASSERT_DISABLED) {</span>
<span class="line-modified">2519                     PatternTerm* term = op.m_term;</span>
<span class="line-modified">2520 </span>
<span class="line-modified">2521                     // Runtime ASSERT to make sure that the nested alternative handled the</span>
<span class="line-modified">2522                     // &quot;no input consumed&quot; check.</span>
<span class="line-modified">2523                     Jump pastBreakpoint;</span>
<span class="line-modified">2524                     pastBreakpoint = branch32(NotEqual, index, Address(stackPointerRegister, term-&gt;frameLocation * sizeof(void*)));</span>
<span class="line-removed">2525                     abortWithReason(YARRNoInputConsumed);</span>
<span class="line-removed">2526                     pastBreakpoint.link(this);</span>
<span class="line-removed">2527                 }</span>
2528 
2529                 // We know that the match is non-zero, we can accept it and
2530                 // loop back up to the head of the subpattern.
2531                 jump(beginOp.m_reentry);
2532 
2533                 // This is the entry point to jump to when we stop matching - we will
2534                 // do so once the subpattern cannot match any more.
2535                 op.m_reentry = label();
2536                 break;
2537             }
2538 
2539             // OpParenthesesSubpatternBegin/End
2540             //
2541             // These nodes support generic subpatterns.
2542             case OpParenthesesSubpatternBegin: {
2543 #if ENABLE(YARR_JIT_ALL_PARENS_EXPRESSIONS)
2544                 PatternTerm* term = op.m_term;
2545                 unsigned parenthesesFrameLocation = term-&gt;frameLocation;
2546 
2547                 // Upon entry to a Greedy quantified set of parenthese store the index.
2548                 // We&#39;ll use this for two purposes:
2549                 //  - To indicate which iteration we are on of mathing the remainder of
2550                 //    the expression after the parentheses - the first, including the
2551                 //    match within the parentheses, or the second having skipped over them.
2552                 //  - To check for empty matches, which must be rejected.
2553                 //
2554                 // At the head of a NonGreedy set of parentheses we&#39;ll immediately set &#39;begin&#39;
2555                 // in the backtrack info to -1 (indicating a match skipping the subpattern),
2556                 // and plant a jump to the end. We&#39;ll also plant a label to backtrack to
2557                 // to reenter the subpattern later, with a store to set &#39;begin&#39; to current index
2558                 // on the second iteration.
2559                 //
2560                 // FIXME: for capturing parens, could use the index in the capture array?
2561                 if (term-&gt;quantityType == QuantifierGreedy || term-&gt;quantityType == QuantifierNonGreedy) {
2562                     storeToFrame(TrustedImm32(0), parenthesesFrameLocation + BackTrackInfoParentheses::matchAmountIndex());
2563                     storeToFrame(TrustedImmPtr(nullptr), parenthesesFrameLocation + BackTrackInfoParentheses::parenContextHeadIndex());
2564 
2565                     if (term-&gt;quantityType == QuantifierNonGreedy) {
2566                         storeToFrame(TrustedImm32(-1), parenthesesFrameLocation + BackTrackInfoParentheses::beginIndex());
2567                         op.m_jumps.append(jump());
2568                     }
2569 
2570                     op.m_reentry = label();
2571                     RegisterID currParenContextReg = regT0;
2572                     RegisterID newParenContextReg = regT1;
2573 
2574                     loadFromFrame(parenthesesFrameLocation + BackTrackInfoParentheses::parenContextHeadIndex(), currParenContextReg);
2575                     allocateParenContext(newParenContextReg);
2576                     storePtr(currParenContextReg, newParenContextReg);
2577                     storeToFrame(newParenContextReg, parenthesesFrameLocation + BackTrackInfoParentheses::parenContextHeadIndex());
2578                     saveParenContext(newParenContextReg, regT2, term-&gt;parentheses.subpatternId, term-&gt;parentheses.lastSubpatternId, parenthesesFrameLocation);
2579                     storeToFrame(index, parenthesesFrameLocation + BackTrackInfoParentheses::beginIndex());
2580                 }
2581 
2582                 // If the parenthese are capturing, store the starting index value to the
2583                 // captures array, offsetting as necessary.
2584                 //
2585                 // FIXME: could avoid offsetting this value in JIT code, apply
2586                 // offsets only afterwards, at the point the results array is
2587                 // being accessed.
2588                 if (term-&gt;capture() &amp;&amp; compileMode == IncludeSubpatterns) {
2589                     const RegisterID indexTemporary = regT0;
2590                     unsigned inputOffset = (m_checkedOffset - term-&gt;inputPosition).unsafeGet();
2591                     if (term-&gt;quantityType == QuantifierFixedCount)
2592                         inputOffset += term-&gt;parentheses.disjunction-&gt;m_minimumSize;
2593                     if (inputOffset) {
2594                         move(index, indexTemporary);
2595                         sub32(Imm32(inputOffset), indexTemporary);
2596                         setSubpatternStart(indexTemporary, term-&gt;parentheses.subpatternId);
2597                     } else
2598                         setSubpatternStart(index, term-&gt;parentheses.subpatternId);
2599                 }
2600 #else // !YARR_JIT_ALL_PARENS_EXPRESSIONS
2601                 RELEASE_ASSERT_NOT_REACHED();
2602 #endif
2603                 break;
2604             }
2605             case OpParenthesesSubpatternEnd: {
2606 #if ENABLE(YARR_JIT_ALL_PARENS_EXPRESSIONS)
2607                 PatternTerm* term = op.m_term;
2608                 unsigned parenthesesFrameLocation = term-&gt;frameLocation;
2609 
<a name="51" id="anc51"></a><span class="line-modified">2610                 // Runtime ASSERT to make sure that the nested alternative handled the</span>
<span class="line-modified">2611                 // &quot;no input consumed&quot; check.</span>
<span class="line-modified">2612                 if (!ASSERT_DISABLED &amp;&amp; term-&gt;quantityType != QuantifierFixedCount &amp;&amp; !term-&gt;parentheses.disjunction-&gt;m_minimumSize) {</span>
<span class="line-modified">2613                     Jump pastBreakpoint;</span>
<span class="line-modified">2614                     pastBreakpoint = branch32(NotEqual, index, Address(stackPointerRegister, parenthesesFrameLocation * sizeof(void*)));</span>
<span class="line-removed">2615                     abortWithReason(YARRNoInputConsumed);</span>
<span class="line-removed">2616                     pastBreakpoint.link(this);</span>
<span class="line-removed">2617                 }</span>
2618 
2619                 const RegisterID countTemporary = regT1;
2620 
2621                 YarrOp&amp; beginOp = m_ops[op.m_previousOp];
2622                 loadFromFrame(parenthesesFrameLocation + BackTrackInfoParentheses::matchAmountIndex(), countTemporary);
2623                 add32(TrustedImm32(1), countTemporary);
2624                 storeToFrame(countTemporary, parenthesesFrameLocation + BackTrackInfoParentheses::matchAmountIndex());
2625 
2626                 // If the parenthese are capturing, store the ending index value to the
2627                 // captures array, offsetting as necessary.
2628                 //
2629                 // FIXME: could avoid offsetting this value in JIT code, apply
2630                 // offsets only afterwards, at the point the results array is
2631                 // being accessed.
2632                 if (term-&gt;capture() &amp;&amp; compileMode == IncludeSubpatterns) {
2633                     const RegisterID indexTemporary = regT0;
2634 
2635                     unsigned inputOffset = (m_checkedOffset - term-&gt;inputPosition).unsafeGet();
2636                     if (inputOffset) {
2637                         move(index, indexTemporary);
2638                         sub32(Imm32(inputOffset), indexTemporary);
2639                         setSubpatternEnd(indexTemporary, term-&gt;parentheses.subpatternId);
2640                     } else
2641                         setSubpatternEnd(index, term-&gt;parentheses.subpatternId);
2642                 }
2643 
2644                 // If the parentheses are quantified Greedy then add a label to jump back
2645                 // to if we get a failed match from after the parentheses. For NonGreedy
2646                 // parentheses, link the jump from before the subpattern to here.
2647                 if (term-&gt;quantityType == QuantifierGreedy) {
2648                     if (term-&gt;quantityMaxCount != quantifyInfinite)
2649                         branch32(Below, countTemporary, Imm32(term-&gt;quantityMaxCount.unsafeGet())).linkTo(beginOp.m_reentry, this);
2650                     else
2651                         jump(beginOp.m_reentry);
2652 
2653                     op.m_reentry = label();
2654                 } else if (term-&gt;quantityType == QuantifierNonGreedy) {
2655                     YarrOp&amp; beginOp = m_ops[op.m_previousOp];
2656                     beginOp.m_jumps.link(this);
2657                     op.m_reentry = label();
2658                 }
2659 #else // !YARR_JIT_ALL_PARENS_EXPRESSIONS
2660                 RELEASE_ASSERT_NOT_REACHED();
2661 #endif
2662                 break;
2663             }
2664 
2665             // OpParentheticalAssertionBegin/End
2666             case OpParentheticalAssertionBegin: {
2667                 PatternTerm* term = op.m_term;
2668 
2669                 // Store the current index - assertions should not update index, so
2670                 // we will need to restore it upon a successful match.
2671                 unsigned parenthesesFrameLocation = term-&gt;frameLocation;
2672                 storeToFrame(index, parenthesesFrameLocation + BackTrackInfoParentheticalAssertion::beginIndex());
2673 
2674                 // Check
2675                 op.m_checkAdjust = m_checkedOffset - term-&gt;inputPosition;
2676                 if (op.m_checkAdjust)
2677                     sub32(Imm32(op.m_checkAdjust.unsafeGet()), index);
2678 
2679                 m_checkedOffset -= op.m_checkAdjust;
2680                 break;
2681             }
2682             case OpParentheticalAssertionEnd: {
2683                 PatternTerm* term = op.m_term;
2684 
2685                 // Restore the input index value.
2686                 unsigned parenthesesFrameLocation = term-&gt;frameLocation;
2687                 loadFromFrame(parenthesesFrameLocation + BackTrackInfoParentheticalAssertion::beginIndex(), index);
2688 
2689                 // If inverted, a successful match of the assertion must be treated
2690                 // as a failure, so jump to backtracking.
2691                 if (term-&gt;invert()) {
2692                     op.m_jumps.append(jump());
2693                     op.m_reentry = label();
2694                 }
2695 
2696                 YarrOp&amp; lastOp = m_ops[op.m_previousOp];
2697                 m_checkedOffset += lastOp.m_checkAdjust;
2698                 break;
2699             }
2700 
2701             case OpMatchFailed:
2702                 removeCallFrame();
2703                 generateFailReturn();
2704                 break;
2705             }
2706 
2707             ++opIndex;
2708         } while (opIndex &lt; m_ops.size());
2709     }
2710 
2711     void backtrack()
2712     {
2713         // Backwards generate the backtracking code.
2714         size_t opIndex = m_ops.size();
2715         ASSERT(opIndex);
2716 
2717         do {
2718             --opIndex;
2719 
2720             if (m_disassembler)
2721                 m_disassembler-&gt;setForBacktrack(opIndex, label());
2722 
2723             YarrOp&amp; op = m_ops[opIndex];
2724             switch (op.m_op) {
2725 
2726             case OpTerm:
2727                 backtrackTerm(opIndex);
2728                 break;
2729 
2730             // OpBodyAlternativeBegin/Next/End
2731             //
2732             // For each Begin/Next node representing an alternative, we need to decide what to do
2733             // in two circumstances:
2734             //  - If we backtrack back into this node, from within the alternative.
2735             //  - If the input check at the head of the alternative fails (if this exists).
2736             //
2737             // We treat these two cases differently since in the former case we have slightly
2738             // more information - since we are backtracking out of a prior alternative we know
2739             // that at least enough input was available to run it. For example, given the regular
2740             // expression /a|b/, if we backtrack out of the first alternative (a failed pattern
2741             // character match of &#39;a&#39;), then we need not perform an additional input availability
2742             // check before running the second alternative.
2743             //
2744             // Backtracking required differs for the last alternative, which in the case of the
2745             // repeating set of alternatives must loop. The code generated for the last alternative
2746             // will also be used to handle all input check failures from any prior alternatives -
2747             // these require similar functionality, in seeking the next available alternative for
2748             // which there is sufficient input.
2749             //
2750             // Since backtracking of all other alternatives simply requires us to link backtracks
2751             // to the reentry point for the subsequent alternative, we will only be generating any
2752             // code when backtracking the last alternative.
2753             case OpBodyAlternativeBegin:
2754             case OpBodyAlternativeNext: {
2755                 PatternAlternative* alternative = op.m_alternative;
2756 
2757                 if (op.m_op == OpBodyAlternativeNext) {
2758                     PatternAlternative* priorAlternative = m_ops[op.m_previousOp].m_alternative;
2759                     m_checkedOffset += priorAlternative-&gt;m_minimumSize;
2760                 }
2761                 m_checkedOffset -= alternative-&gt;m_minimumSize;
2762 
2763                 // Is this the last alternative? If not, then if we backtrack to this point we just
2764                 // need to jump to try to match the next alternative.
2765                 if (m_ops[op.m_nextOp].m_op != OpBodyAlternativeEnd) {
2766                     m_backtrackingState.linkTo(m_ops[op.m_nextOp].m_reentry, this);
2767                     break;
2768                 }
2769                 YarrOp&amp; endOp = m_ops[op.m_nextOp];
2770 
2771                 YarrOp* beginOp = &amp;op;
2772                 while (beginOp-&gt;m_op != OpBodyAlternativeBegin) {
2773                     ASSERT(beginOp-&gt;m_op == OpBodyAlternativeNext);
2774                     beginOp = &amp;m_ops[beginOp-&gt;m_previousOp];
2775                 }
2776 
2777                 bool onceThrough = endOp.m_nextOp == notFound;
2778 
2779                 JumpList lastStickyAlternativeFailures;
2780 
2781                 // First, generate code to handle cases where we backtrack out of an attempted match
2782                 // of the last alternative. If this is a &#39;once through&#39; set of alternatives then we
2783                 // have nothing to do - link this straight through to the End.
2784                 if (onceThrough)
2785                     m_backtrackingState.linkTo(endOp.m_reentry, this);
2786                 else {
2787                     // If we don&#39;t need to move the input poistion, and the pattern has a fixed size
2788                     // (in which case we omit the store of the start index until the pattern has matched)
2789                     // then we can just link the backtrack out of the last alternative straight to the
2790                     // head of the first alternative.
2791                     if (m_pattern.m_body-&gt;m_hasFixedSize
2792                         &amp;&amp; (alternative-&gt;m_minimumSize &gt; beginOp-&gt;m_alternative-&gt;m_minimumSize)
2793                         &amp;&amp; (alternative-&gt;m_minimumSize - beginOp-&gt;m_alternative-&gt;m_minimumSize == 1))
2794                         m_backtrackingState.linkTo(beginOp-&gt;m_reentry, this);
2795                     else if (m_pattern.sticky() &amp;&amp; m_ops[op.m_nextOp].m_op == OpBodyAlternativeEnd) {
2796                         // It is a sticky pattern and the last alternative failed, jump to the end.
2797                         m_backtrackingState.takeBacktracksToJumpList(lastStickyAlternativeFailures, this);
2798                     } else {
2799                         // We need to generate a trampoline of code to execute before looping back
2800                         // around to the first alternative.
2801                         m_backtrackingState.link(this);
2802 
2803                         // No need to advance and retry for a sticky pattern.
2804                         if (!m_pattern.sticky()) {
2805                             // If the pattern size is not fixed, then store the start index for use if we match.
2806                             if (!m_pattern.m_body-&gt;m_hasFixedSize) {
2807                                 if (alternative-&gt;m_minimumSize == 1)
2808                                     setMatchStart(index);
2809                                 else {
2810                                     move(index, regT0);
2811                                     if (alternative-&gt;m_minimumSize)
2812                                         sub32(Imm32(alternative-&gt;m_minimumSize - 1), regT0);
2813                                     else
2814                                         add32(TrustedImm32(1), regT0);
2815                                     setMatchStart(regT0);
2816                                 }
2817                             }
2818 
2819                             // Generate code to loop. Check whether the last alternative is longer than the
2820                             // first (e.g. /a|xy/ or /a|xyz/).
2821                             if (alternative-&gt;m_minimumSize &gt; beginOp-&gt;m_alternative-&gt;m_minimumSize) {
2822                                 // We want to loop, and increment input position. If the delta is 1, it is
2823                                 // already correctly incremented, if more than one then decrement as appropriate.
2824                                 unsigned delta = alternative-&gt;m_minimumSize - beginOp-&gt;m_alternative-&gt;m_minimumSize;
2825                                 ASSERT(delta);
2826                                 if (delta != 1)
2827                                     sub32(Imm32(delta - 1), index);
2828                                 jump(beginOp-&gt;m_reentry);
2829                             } else {
2830                                 // If the first alternative has minimum size 0xFFFFFFFFu, then there cannot
2831                                 // be sufficent input available to handle this, so just fall through.
2832                                 unsigned delta = beginOp-&gt;m_alternative-&gt;m_minimumSize - alternative-&gt;m_minimumSize;
2833                                 if (delta != 0xFFFFFFFFu) {
2834                                     // We need to check input because we are incrementing the input.
2835                                     add32(Imm32(delta + 1), index);
2836                                     checkInput().linkTo(beginOp-&gt;m_reentry, this);
2837                                 }
2838                             }
2839                         }
2840                     }
2841                 }
2842 
2843                 // We can reach this point in the code in two ways:
2844                 //  - Fallthrough from the code above (a repeating alternative backtracked out of its
2845                 //    last alternative, and did not have sufficent input to run the first).
2846                 //  - We will loop back up to the following label when a repeating alternative loops,
2847                 //    following a failed input check.
2848                 //
2849                 // Either way, we have just failed the input check for the first alternative.
2850                 Label firstInputCheckFailed(this);
2851 
2852                 // Generate code to handle input check failures from alternatives except the last.
2853                 // prevOp is the alternative we&#39;re handling a bail out from (initially Begin), and
2854                 // nextOp is the alternative we will be attempting to reenter into.
2855                 //
2856                 // We will link input check failures from the forwards matching path back to the code
2857                 // that can handle them.
2858                 YarrOp* prevOp = beginOp;
2859                 YarrOp* nextOp = &amp;m_ops[beginOp-&gt;m_nextOp];
2860                 while (nextOp-&gt;m_op != OpBodyAlternativeEnd) {
2861                     prevOp-&gt;m_jumps.link(this);
2862 
2863                     // We only get here if an input check fails, it is only worth checking again
2864                     // if the next alternative has a minimum size less than the last.
2865                     if (prevOp-&gt;m_alternative-&gt;m_minimumSize &gt; nextOp-&gt;m_alternative-&gt;m_minimumSize) {
2866                         // FIXME: if we added an extra label to YarrOp, we could avoid needing to
2867                         // subtract delta back out, and reduce this code. Should performance test
2868                         // the benefit of this.
2869                         unsigned delta = prevOp-&gt;m_alternative-&gt;m_minimumSize - nextOp-&gt;m_alternative-&gt;m_minimumSize;
2870                         sub32(Imm32(delta), index);
2871                         Jump fail = jumpIfNoAvailableInput();
2872                         add32(Imm32(delta), index);
2873                         jump(nextOp-&gt;m_reentry);
2874                         fail.link(this);
2875                     } else if (prevOp-&gt;m_alternative-&gt;m_minimumSize &lt; nextOp-&gt;m_alternative-&gt;m_minimumSize)
2876                         add32(Imm32(nextOp-&gt;m_alternative-&gt;m_minimumSize - prevOp-&gt;m_alternative-&gt;m_minimumSize), index);
2877                     prevOp = nextOp;
2878                     nextOp = &amp;m_ops[nextOp-&gt;m_nextOp];
2879                 }
2880 
2881                 // We fall through to here if there is insufficient input to run the last alternative.
2882 
2883                 // If there is insufficient input to run the last alternative, then for &#39;once through&#39;
2884                 // alternatives we are done - just jump back up into the forwards matching path at the End.
2885                 if (onceThrough) {
2886                     op.m_jumps.linkTo(endOp.m_reentry, this);
2887                     jump(endOp.m_reentry);
2888                     break;
2889                 }
2890 
2891                 // For repeating alternatives, link any input check failure from the last alternative to
2892                 // this point.
2893                 op.m_jumps.link(this);
2894 
2895                 bool needsToUpdateMatchStart = !m_pattern.m_body-&gt;m_hasFixedSize;
2896 
2897                 // Check for cases where input position is already incremented by 1 for the last
2898                 // alternative (this is particularly useful where the minimum size of the body
2899                 // disjunction is 0, e.g. /a*|b/).
2900                 if (needsToUpdateMatchStart &amp;&amp; alternative-&gt;m_minimumSize == 1) {
2901                     // index is already incremented by 1, so just store it now!
2902                     setMatchStart(index);
2903                     needsToUpdateMatchStart = false;
2904                 }
2905 
2906                 if (!m_pattern.sticky()) {
2907                     // Check whether there is sufficient input to loop. Increment the input position by
2908                     // one, and check. Also add in the minimum disjunction size before checking - there
2909                     // is no point in looping if we&#39;re just going to fail all the input checks around
2910                     // the next iteration.
2911                     ASSERT(alternative-&gt;m_minimumSize &gt;= m_pattern.m_body-&gt;m_minimumSize);
2912                     if (alternative-&gt;m_minimumSize == m_pattern.m_body-&gt;m_minimumSize) {
2913                         // If the last alternative had the same minimum size as the disjunction,
2914                         // just simply increment input pos by 1, no adjustment based on minimum size.
2915                         add32(TrustedImm32(1), index);
2916                     } else {
2917                         // If the minumum for the last alternative was one greater than than that
2918                         // for the disjunction, we&#39;re already progressed by 1, nothing to do!
2919                         unsigned delta = (alternative-&gt;m_minimumSize - m_pattern.m_body-&gt;m_minimumSize) - 1;
2920                         if (delta)
2921                             sub32(Imm32(delta), index);
2922                     }
2923                     Jump matchFailed = jumpIfNoAvailableInput();
2924 
2925                     if (needsToUpdateMatchStart) {
2926                         if (!m_pattern.m_body-&gt;m_minimumSize)
2927                             setMatchStart(index);
2928                         else {
2929                             move(index, regT0);
2930                             sub32(Imm32(m_pattern.m_body-&gt;m_minimumSize), regT0);
2931                             setMatchStart(regT0);
2932                         }
2933                     }
2934 
2935                     // Calculate how much more input the first alternative requires than the minimum
2936                     // for the body as a whole. If no more is needed then we dont need an additional
2937                     // input check here - jump straight back up to the start of the first alternative.
2938                     if (beginOp-&gt;m_alternative-&gt;m_minimumSize == m_pattern.m_body-&gt;m_minimumSize)
2939                         jump(beginOp-&gt;m_reentry);
2940                     else {
2941                         if (beginOp-&gt;m_alternative-&gt;m_minimumSize &gt; m_pattern.m_body-&gt;m_minimumSize)
2942                             add32(Imm32(beginOp-&gt;m_alternative-&gt;m_minimumSize - m_pattern.m_body-&gt;m_minimumSize), index);
2943                         else
2944                             sub32(Imm32(m_pattern.m_body-&gt;m_minimumSize - beginOp-&gt;m_alternative-&gt;m_minimumSize), index);
2945                         checkInput().linkTo(beginOp-&gt;m_reentry, this);
2946                         jump(firstInputCheckFailed);
2947                     }
2948 
2949                     // We jump to here if we iterate to the point that there is insufficient input to
2950                     // run any matches, and need to return a failure state from JIT code.
2951                     matchFailed.link(this);
2952                 }
2953 
2954                 lastStickyAlternativeFailures.link(this);
2955                 removeCallFrame();
2956                 generateFailReturn();
2957                 break;
2958             }
2959             case OpBodyAlternativeEnd: {
2960                 // We should never backtrack back into a body disjunction.
2961                 ASSERT(m_backtrackingState.isEmpty());
2962 
2963                 PatternAlternative* priorAlternative = m_ops[op.m_previousOp].m_alternative;
2964                 m_checkedOffset += priorAlternative-&gt;m_minimumSize;
2965                 break;
2966             }
2967 
2968             // OpSimpleNestedAlternativeBegin/Next/End
2969             // OpNestedAlternativeBegin/Next/End
2970             //
2971             // Generate code for when we backtrack back out of an alternative into
2972             // a Begin or Next node, or when the entry input count check fails. If
2973             // there are more alternatives we need to jump to the next alternative,
2974             // if not we backtrack back out of the current set of parentheses.
2975             //
2976             // In the case of non-simple nested assertions we need to also link the
2977             // &#39;return address&#39; appropriately to backtrack back out into the correct
2978             // alternative.
2979             case OpSimpleNestedAlternativeBegin:
2980             case OpSimpleNestedAlternativeNext:
2981             case OpNestedAlternativeBegin:
2982             case OpNestedAlternativeNext: {
2983                 YarrOp&amp; nextOp = m_ops[op.m_nextOp];
2984                 bool isBegin = op.m_previousOp == notFound;
2985                 bool isLastAlternative = nextOp.m_nextOp == notFound;
2986                 ASSERT(isBegin == (op.m_op == OpSimpleNestedAlternativeBegin || op.m_op == OpNestedAlternativeBegin));
2987                 ASSERT(isLastAlternative == (nextOp.m_op == OpSimpleNestedAlternativeEnd || nextOp.m_op == OpNestedAlternativeEnd));
2988 
2989                 // Treat an input check failure the same as a failed match.
2990                 m_backtrackingState.append(op.m_jumps);
2991 
2992                 // Set the backtracks to jump to the appropriate place. We may need
2993                 // to link the backtracks in one of three different way depending on
2994                 // the type of alternative we are dealing with:
2995                 //  - A single alternative, with no simplings.
2996                 //  - The last alternative of a set of two or more.
2997                 //  - An alternative other than the last of a set of two or more.
2998                 //
2999                 // In the case of a single alternative on its own, we don&#39;t need to
3000                 // jump anywhere - if the alternative fails to match we can just
3001                 // continue to backtrack out of the parentheses without jumping.
3002                 //
3003                 // In the case of the last alternative in a set of more than one, we
3004                 // need to jump to return back out to the beginning. We&#39;ll do so by
3005                 // adding a jump to the End node&#39;s m_jumps list, and linking this
3006                 // when we come to generate the Begin node. For alternatives other
3007                 // than the last, we need to jump to the next alternative.
3008                 //
3009                 // If the alternative had adjusted the input position we must link
3010                 // backtracking to here, correct, and then jump on. If not we can
3011                 // link the backtracks directly to their destination.
3012                 if (op.m_checkAdjust) {
3013                     // Handle the cases where we need to link the backtracks here.
3014                     m_backtrackingState.link(this);
3015                     sub32(Imm32(op.m_checkAdjust.unsafeGet()), index);
3016                     if (!isLastAlternative) {
3017                         // An alternative that is not the last should jump to its successor.
3018                         jump(nextOp.m_reentry);
3019                     } else if (!isBegin) {
3020                         // The last of more than one alternatives must jump back to the beginning.
3021                         nextOp.m_jumps.append(jump());
3022                     } else {
3023                         // A single alternative on its own can fall through.
3024                         m_backtrackingState.fallthrough();
3025                     }
3026                 } else {
3027                     // Handle the cases where we can link the backtracks directly to their destinations.
3028                     if (!isLastAlternative) {
3029                         // An alternative that is not the last should jump to its successor.
3030                         m_backtrackingState.linkTo(nextOp.m_reentry, this);
3031                     } else if (!isBegin) {
3032                         // The last of more than one alternatives must jump back to the beginning.
3033                         m_backtrackingState.takeBacktracksToJumpList(nextOp.m_jumps, this);
3034                     }
3035                     // In the case of a single alternative on its own do nothing - it can fall through.
3036                 }
3037 
3038                 // If there is a backtrack jump from a zero length match link it here.
3039                 if (op.m_zeroLengthMatch.isSet())
3040                     m_backtrackingState.append(op.m_zeroLengthMatch);
3041 
3042                 // At this point we&#39;ve handled the backtracking back into this node.
3043                 // Now link any backtracks that need to jump to here.
3044 
3045                 // For non-simple alternatives, link the alternative&#39;s &#39;return address&#39;
3046                 // so that we backtrack back out into the previous alternative.
3047                 if (op.m_op == OpNestedAlternativeNext)
3048                     m_backtrackingState.append(op.m_returnAddress);
3049 
3050                 // If there is more than one alternative, then the last alternative will
3051                 // have planted a jump to be linked to the end. This jump was added to the
3052                 // End node&#39;s m_jumps list. If we are back at the beginning, link it here.
3053                 if (isBegin) {
3054                     YarrOp* endOp = &amp;m_ops[op.m_nextOp];
3055                     while (endOp-&gt;m_nextOp != notFound) {
3056                         ASSERT(endOp-&gt;m_op == OpSimpleNestedAlternativeNext || endOp-&gt;m_op == OpNestedAlternativeNext);
3057                         endOp = &amp;m_ops[endOp-&gt;m_nextOp];
3058                     }
3059                     ASSERT(endOp-&gt;m_op == OpSimpleNestedAlternativeEnd || endOp-&gt;m_op == OpNestedAlternativeEnd);
3060                     m_backtrackingState.append(endOp-&gt;m_jumps);
3061                 }
3062 
3063                 if (!isBegin) {
3064                     YarrOp&amp; lastOp = m_ops[op.m_previousOp];
3065                     m_checkedOffset += lastOp.m_checkAdjust;
3066                 }
3067                 m_checkedOffset -= op.m_checkAdjust;
3068                 break;
3069             }
3070             case OpSimpleNestedAlternativeEnd:
3071             case OpNestedAlternativeEnd: {
3072                 PatternTerm* term = op.m_term;
3073 
3074                 // If there is a backtrack jump from a zero length match link it here.
3075                 if (op.m_zeroLengthMatch.isSet())
3076                     m_backtrackingState.append(op.m_zeroLengthMatch);
3077 
3078                 // If we backtrack into the end of a simple subpattern do nothing;
3079                 // just continue through into the last alternative. If we backtrack
3080                 // into the end of a non-simple set of alterntives we need to jump
3081                 // to the backtracking return address set up during generation.
3082                 if (op.m_op == OpNestedAlternativeEnd) {
3083                     m_backtrackingState.link(this);
3084 
3085                     // Plant a jump to the return address.
3086                     unsigned parenthesesFrameLocation = term-&gt;frameLocation;
3087                     loadFromFrameAndJump(parenthesesFrameLocation + BackTrackInfoParentheses::returnAddressIndex());
3088 
3089                     // Link the DataLabelPtr associated with the end of the last
3090                     // alternative to this point.
3091                     m_backtrackingState.append(op.m_returnAddress);
3092                 }
3093 
3094                 YarrOp&amp; lastOp = m_ops[op.m_previousOp];
3095                 m_checkedOffset += lastOp.m_checkAdjust;
3096                 break;
3097             }
3098 
3099             // OpParenthesesSubpatternOnceBegin/End
3100             //
3101             // When we are backtracking back out of a capturing subpattern we need
3102             // to clear the start index in the matches output array, to record that
3103             // this subpattern has not been captured.
3104             //
3105             // When backtracking back out of a Greedy quantified subpattern we need
3106             // to catch this, and try running the remainder of the alternative after
3107             // the subpattern again, skipping the parentheses.
3108             //
3109             // Upon backtracking back into a quantified set of parentheses we need to
3110             // check whether we were currently skipping the subpattern. If not, we
3111             // can backtrack into them, if we were we need to either backtrack back
3112             // out of the start of the parentheses, or jump back to the forwards
3113             // matching start, depending of whether the match is Greedy or NonGreedy.
3114             case OpParenthesesSubpatternOnceBegin: {
3115                 PatternTerm* term = op.m_term;
3116                 ASSERT(term-&gt;quantityMaxCount == 1);
3117 
3118                 // We only need to backtrack to this point if capturing or greedy.
3119                 if ((term-&gt;capture() &amp;&amp; compileMode == IncludeSubpatterns) || term-&gt;quantityType == QuantifierGreedy) {
3120                     m_backtrackingState.link(this);
3121 
3122                     // If capturing, clear the capture (we only need to reset start).
3123                     if (term-&gt;capture() &amp;&amp; compileMode == IncludeSubpatterns)
3124                         clearSubpatternStart(term-&gt;parentheses.subpatternId);
3125 
3126                     // If Greedy, jump to the end.
3127                     if (term-&gt;quantityType == QuantifierGreedy) {
3128                         // Clear the flag in the stackframe indicating we ran through the subpattern.
3129                         unsigned parenthesesFrameLocation = term-&gt;frameLocation;
3130                         storeToFrame(TrustedImm32(-1), parenthesesFrameLocation + BackTrackInfoParenthesesOnce::beginIndex());
3131                         // Jump to after the parentheses, skipping the subpattern.
3132                         jump(m_ops[op.m_nextOp].m_reentry);
3133                         // A backtrack from after the parentheses, when skipping the subpattern,
3134                         // will jump back to here.
3135                         op.m_jumps.link(this);
3136                     }
3137 
3138                     m_backtrackingState.fallthrough();
3139                 }
3140                 break;
3141             }
3142             case OpParenthesesSubpatternOnceEnd: {
3143                 PatternTerm* term = op.m_term;
3144 
3145                 if (term-&gt;quantityType != QuantifierFixedCount) {
3146                     m_backtrackingState.link(this);
3147 
3148                     // Check whether we should backtrack back into the parentheses, or if we
3149                     // are currently in a state where we had skipped over the subpattern
3150                     // (in which case the flag value on the stack will be -1).
3151                     unsigned parenthesesFrameLocation = term-&gt;frameLocation;
3152                     Jump hadSkipped = branch32(Equal, Address(stackPointerRegister, (parenthesesFrameLocation + BackTrackInfoParenthesesOnce::beginIndex()) * sizeof(void*)), TrustedImm32(-1));
3153 
3154                     if (term-&gt;quantityType == QuantifierGreedy) {
3155                         // For Greedy parentheses, we skip after having already tried going
3156                         // through the subpattern, so if we get here we&#39;re done.
3157                         YarrOp&amp; beginOp = m_ops[op.m_previousOp];
3158                         beginOp.m_jumps.append(hadSkipped);
3159                     } else {
3160                         // For NonGreedy parentheses, we try skipping the subpattern first,
3161                         // so if we get here we need to try running through the subpattern
3162                         // next. Jump back to the start of the parentheses in the forwards
3163                         // matching path.
3164                         ASSERT(term-&gt;quantityType == QuantifierNonGreedy);
3165                         YarrOp&amp; beginOp = m_ops[op.m_previousOp];
3166                         hadSkipped.linkTo(beginOp.m_reentry, this);
3167                     }
3168 
3169                     m_backtrackingState.fallthrough();
3170                 }
3171 
3172                 m_backtrackingState.append(op.m_jumps);
3173                 break;
3174             }
3175 
3176             // OpParenthesesSubpatternTerminalBegin/End
3177             //
3178             // Terminal subpatterns will always match - there is nothing after them to
3179             // force a backtrack, and they have a minimum count of 0, and as such will
3180             // always produce an acceptable result.
3181             case OpParenthesesSubpatternTerminalBegin: {
3182                 // We will backtrack to this point once the subpattern cannot match any
3183                 // more. Since no match is accepted as a successful match (we are Greedy
3184                 // quantified with a minimum of zero) jump back to the forwards matching
3185                 // path at the end.
3186                 YarrOp&amp; endOp = m_ops[op.m_nextOp];
3187                 m_backtrackingState.linkTo(endOp.m_reentry, this);
3188                 break;
3189             }
3190             case OpParenthesesSubpatternTerminalEnd:
3191                 // We should never be backtracking to here (hence the &#39;terminal&#39; in the name).
3192                 ASSERT(m_backtrackingState.isEmpty());
3193                 m_backtrackingState.append(op.m_jumps);
3194                 break;
3195 
3196             // OpParenthesesSubpatternBegin/End
3197             //
3198             // When we are backtracking back out of a capturing subpattern we need
3199             // to clear the start index in the matches output array, to record that
3200             // this subpattern has not been captured.
3201             //
3202             // When backtracking back out of a Greedy quantified subpattern we need
3203             // to catch this, and try running the remainder of the alternative after
3204             // the subpattern again, skipping the parentheses.
3205             //
3206             // Upon backtracking back into a quantified set of parentheses we need to
3207             // check whether we were currently skipping the subpattern. If not, we
3208             // can backtrack into them, if we were we need to either backtrack back
3209             // out of the start of the parentheses, or jump back to the forwards
3210             // matching start, depending of whether the match is Greedy or NonGreedy.
3211             case OpParenthesesSubpatternBegin: {
3212 #if ENABLE(YARR_JIT_ALL_PARENS_EXPRESSIONS)
3213                 PatternTerm* term = op.m_term;
3214                 unsigned parenthesesFrameLocation = term-&gt;frameLocation;
3215 
3216                 if (term-&gt;quantityType != QuantifierFixedCount) {
3217                     m_backtrackingState.link(this);
3218 
3219                     RegisterID currParenContextReg = regT0;
3220                     RegisterID newParenContextReg = regT1;
3221 
3222                     loadFromFrame(parenthesesFrameLocation + BackTrackInfoParentheses::parenContextHeadIndex(), currParenContextReg);
3223 
3224                     restoreParenContext(currParenContextReg, regT2, term-&gt;parentheses.subpatternId, term-&gt;parentheses.lastSubpatternId, parenthesesFrameLocation);
3225 
3226                     freeParenContext(currParenContextReg, newParenContextReg);
3227                     storeToFrame(newParenContextReg, parenthesesFrameLocation + BackTrackInfoParentheses::parenContextHeadIndex());
3228 
3229                     const RegisterID countTemporary = regT0;
3230                     loadFromFrame(parenthesesFrameLocation + BackTrackInfoParentheses::matchAmountIndex(), countTemporary);
3231                     Jump zeroLengthMatch = branchTest32(Zero, countTemporary);
3232 
3233                     sub32(TrustedImm32(1), countTemporary);
3234                     storeToFrame(countTemporary, parenthesesFrameLocation + BackTrackInfoParentheses::matchAmountIndex());
3235 
3236                     jump(m_ops[op.m_nextOp].m_reentry);
3237 
3238                     zeroLengthMatch.link(this);
3239 
3240                     // Clear the flag in the stackframe indicating we didn&#39;t run through the subpattern.
3241                     storeToFrame(TrustedImm32(-1), parenthesesFrameLocation + BackTrackInfoParentheses::beginIndex());
3242 
3243                     if (term-&gt;quantityType == QuantifierGreedy)
3244                         jump(m_ops[op.m_nextOp].m_reentry);
3245 
3246                     // If Greedy, jump to the end.
3247                     if (term-&gt;quantityType == QuantifierGreedy) {
3248                         // A backtrack from after the parentheses, when skipping the subpattern,
3249                         // will jump back to here.
3250                         op.m_jumps.link(this);
3251                     }
3252 
3253                     m_backtrackingState.fallthrough();
3254                 }
3255 #else // !YARR_JIT_ALL_PARENS_EXPRESSIONS
3256                 RELEASE_ASSERT_NOT_REACHED();
3257 #endif
3258                 break;
3259             }
3260             case OpParenthesesSubpatternEnd: {
3261 #if ENABLE(YARR_JIT_ALL_PARENS_EXPRESSIONS)
3262                 PatternTerm* term = op.m_term;
3263 
3264                 if (term-&gt;quantityType != QuantifierFixedCount) {
3265                     m_backtrackingState.link(this);
3266 
3267                     unsigned parenthesesFrameLocation = term-&gt;frameLocation;
3268 
3269                     if (term-&gt;quantityType == QuantifierGreedy) {
3270                         // Check whether we should backtrack back into the parentheses, or if we
3271                         // are currently in a state where we had skipped over the subpattern
3272                         // (in which case the flag value on the stack will be -1).
3273                         Jump hadSkipped = branch32(Equal, Address(stackPointerRegister, (parenthesesFrameLocation  + BackTrackInfoParentheses::beginIndex()) * sizeof(void*)), TrustedImm32(-1));
3274 
3275                         // For Greedy parentheses, we skip after having already tried going
3276                         // through the subpattern, so if we get here we&#39;re done.
3277                         YarrOp&amp; beginOp = m_ops[op.m_previousOp];
3278                         beginOp.m_jumps.append(hadSkipped);
3279                     } else {
3280                         // For NonGreedy parentheses, we try skipping the subpattern first,
3281                         // so if we get here we need to try running through the subpattern
3282                         // next. Jump back to the start of the parentheses in the forwards
3283                         // matching path.
3284                         ASSERT(term-&gt;quantityType == QuantifierNonGreedy);
3285 
3286                         const RegisterID beginTemporary = regT0;
3287                         const RegisterID countTemporary = regT1;
3288 
3289                         YarrOp&amp; beginOp = m_ops[op.m_previousOp];
3290 
3291                         loadFromFrame(parenthesesFrameLocation + BackTrackInfoParentheses::beginIndex(), beginTemporary);
3292                         branch32(Equal, beginTemporary, TrustedImm32(-1)).linkTo(beginOp.m_reentry, this);
3293 
3294                         JumpList exceededMatchLimit;
3295 
3296                         if (term-&gt;quantityMaxCount != quantifyInfinite) {
3297                             loadFromFrame(parenthesesFrameLocation + BackTrackInfoParentheses::matchAmountIndex(), countTemporary);
3298                             exceededMatchLimit.append(branch32(AboveOrEqual, countTemporary, Imm32(term-&gt;quantityMaxCount.unsafeGet())));
3299                         }
3300 
3301                         branch32(Above, index, beginTemporary).linkTo(beginOp.m_reentry, this);
3302 
3303                         exceededMatchLimit.link(this);
3304                     }
3305 
3306                     m_backtrackingState.fallthrough();
3307                 }
3308 
3309                 m_backtrackingState.append(op.m_jumps);
3310 #else // !YARR_JIT_ALL_PARENS_EXPRESSIONS
3311                 RELEASE_ASSERT_NOT_REACHED();
3312 #endif
3313                 break;
3314             }
3315 
3316             // OpParentheticalAssertionBegin/End
3317             case OpParentheticalAssertionBegin: {
3318                 PatternTerm* term = op.m_term;
3319                 YarrOp&amp; endOp = m_ops[op.m_nextOp];
3320 
3321                 // We need to handle the backtracks upon backtracking back out
3322                 // of a parenthetical assertion if either we need to correct
3323                 // the input index, or the assertion was inverted.
3324                 if (op.m_checkAdjust || term-&gt;invert()) {
3325                      m_backtrackingState.link(this);
3326 
3327                     if (op.m_checkAdjust)
3328                         add32(Imm32(op.m_checkAdjust.unsafeGet()), index);
3329 
3330                     // In an inverted assertion failure to match the subpattern
3331                     // is treated as a successful match - jump to the end of the
3332                     // subpattern. We already have adjusted the input position
3333                     // back to that before the assertion, which is correct.
3334                     if (term-&gt;invert())
3335                         jump(endOp.m_reentry);
3336 
3337                     m_backtrackingState.fallthrough();
3338                 }
3339 
3340                 // The End node&#39;s jump list will contain any backtracks into
3341                 // the end of the assertion. Also, if inverted, we will have
3342                 // added the failure caused by a successful match to this.
3343                 m_backtrackingState.append(endOp.m_jumps);
3344 
3345                 m_checkedOffset += op.m_checkAdjust;
3346                 break;
3347             }
3348             case OpParentheticalAssertionEnd: {
3349                 // FIXME: We should really be clearing any nested subpattern
3350                 // matches on bailing out from after the pattern. Firefox has
3351                 // this bug too (presumably because they use YARR!)
3352 
3353                 // Never backtrack into an assertion; later failures bail to before the begin.
3354                 m_backtrackingState.takeBacktracksToJumpList(op.m_jumps, this);
3355 
3356                 YarrOp&amp; lastOp = m_ops[op.m_previousOp];
3357                 m_checkedOffset -= lastOp.m_checkAdjust;
3358                 break;
3359             }
3360 
3361             case OpMatchFailed:
3362                 break;
3363             }
3364 
3365         } while (opIndex);
3366     }
3367 
3368     // Compilation methods:
3369     // ====================
3370 
3371     // opCompileParenthesesSubpattern
3372     // Emits ops for a subpattern (set of parentheses). These consist
3373     // of a set of alternatives wrapped in an outer set of nodes for
3374     // the parentheses.
3375     // Supported types of parentheses are &#39;Once&#39; (quantityMaxCount == 1),
3376     // &#39;Terminal&#39; (non-capturing parentheses quantified as greedy
3377     // and infinite), and 0 based greedy / non-greedy quantified parentheses.
3378     // Alternatives will use the &#39;Simple&#39; set of ops if either the
3379     // subpattern is terminal (in which case we will never need to
3380     // backtrack), or if the subpattern only contains one alternative.
3381     void opCompileParenthesesSubpattern(PatternTerm* term)
3382     {
3383         YarrOpCode parenthesesBeginOpCode;
3384         YarrOpCode parenthesesEndOpCode;
3385         YarrOpCode alternativeBeginOpCode = OpSimpleNestedAlternativeBegin;
3386         YarrOpCode alternativeNextOpCode = OpSimpleNestedAlternativeNext;
3387         YarrOpCode alternativeEndOpCode = OpSimpleNestedAlternativeEnd;
3388 
<a name="52" id="anc52"></a>




3389         // We can currently only compile quantity 1 subpatterns that are
3390         // not copies. We generate a copy in the case of a range quantifier,
3391         // e.g. /(?:x){3,9}/, or /(?:x)+/ (These are effectively expanded to
3392         // /(?:x){3,3}(?:x){0,6}/ and /(?:x)(?:x)*/ repectively). The problem
3393         // comes where the subpattern is capturing, in which case we would
3394         // need to restore the capture from the first subpattern upon a
3395         // failure in the second.
3396         if (term-&gt;quantityMinCount &amp;&amp; term-&gt;quantityMinCount != term-&gt;quantityMaxCount) {
3397             m_failureReason = JITFailureReason::VariableCountedParenthesisWithNonZeroMinimum;
3398             return;
3399         }
3400 
3401         if (term-&gt;quantityMaxCount == 1 &amp;&amp; !term-&gt;parentheses.isCopy) {
3402             // Select the &#39;Once&#39; nodes.
3403             parenthesesBeginOpCode = OpParenthesesSubpatternOnceBegin;
3404             parenthesesEndOpCode = OpParenthesesSubpatternOnceEnd;
3405 
3406             // If there is more than one alternative we cannot use the &#39;simple&#39; nodes.
3407             if (term-&gt;parentheses.disjunction-&gt;m_alternatives.size() != 1) {
3408                 alternativeBeginOpCode = OpNestedAlternativeBegin;
3409                 alternativeNextOpCode = OpNestedAlternativeNext;
3410                 alternativeEndOpCode = OpNestedAlternativeEnd;
3411             }
3412         } else if (term-&gt;parentheses.isTerminal) {
3413             // Select the &#39;Terminal&#39; nodes.
3414             parenthesesBeginOpCode = OpParenthesesSubpatternTerminalBegin;
3415             parenthesesEndOpCode = OpParenthesesSubpatternTerminalEnd;
3416         } else {
3417 #if ENABLE(YARR_JIT_ALL_PARENS_EXPRESSIONS)
3418             // We only handle generic parenthesis with non-fixed counts.
3419             if (term-&gt;quantityType == QuantifierFixedCount) {
3420                 // This subpattern is not supported by the JIT.
3421                 m_failureReason = JITFailureReason::FixedCountParenthesizedSubpattern;
3422                 return;
3423             }
3424 
3425             m_containsNestedSubpatterns = true;
3426 
3427             // Select the &#39;Generic&#39; nodes.
3428             parenthesesBeginOpCode = OpParenthesesSubpatternBegin;
3429             parenthesesEndOpCode = OpParenthesesSubpatternEnd;
3430 
3431             // If there is more than one alternative we cannot use the &#39;simple&#39; nodes.
3432             if (term-&gt;parentheses.disjunction-&gt;m_alternatives.size() != 1) {
3433                 alternativeBeginOpCode = OpNestedAlternativeBegin;
3434                 alternativeNextOpCode = OpNestedAlternativeNext;
3435                 alternativeEndOpCode = OpNestedAlternativeEnd;
3436             }
3437 #else
3438             // This subpattern is not supported by the JIT.
3439             m_failureReason = JITFailureReason::ParenthesizedSubpattern;
3440             return;
3441 #endif
3442         }
3443 
3444         size_t parenBegin = m_ops.size();
3445         m_ops.append(parenthesesBeginOpCode);
3446 
3447         m_ops.append(alternativeBeginOpCode);
3448         m_ops.last().m_previousOp = notFound;
3449         m_ops.last().m_term = term;
3450         Vector&lt;std::unique_ptr&lt;PatternAlternative&gt;&gt;&amp; alternatives = term-&gt;parentheses.disjunction-&gt;m_alternatives;
3451         for (unsigned i = 0; i &lt; alternatives.size(); ++i) {
3452             size_t lastOpIndex = m_ops.size() - 1;
3453 
3454             PatternAlternative* nestedAlternative = alternatives[i].get();
3455             opCompileAlternative(nestedAlternative);
3456 
3457             size_t thisOpIndex = m_ops.size();
3458             m_ops.append(YarrOp(alternativeNextOpCode));
3459 
3460             YarrOp&amp; lastOp = m_ops[lastOpIndex];
3461             YarrOp&amp; thisOp = m_ops[thisOpIndex];
3462 
3463             lastOp.m_alternative = nestedAlternative;
3464             lastOp.m_nextOp = thisOpIndex;
3465             thisOp.m_previousOp = lastOpIndex;
3466             thisOp.m_term = term;
3467         }
3468         YarrOp&amp; lastOp = m_ops.last();
3469         ASSERT(lastOp.m_op == alternativeNextOpCode);
3470         lastOp.m_op = alternativeEndOpCode;
3471         lastOp.m_alternative = 0;
3472         lastOp.m_nextOp = notFound;
3473 
3474         size_t parenEnd = m_ops.size();
3475         m_ops.append(parenthesesEndOpCode);
3476 
3477         m_ops[parenBegin].m_term = term;
3478         m_ops[parenBegin].m_previousOp = notFound;
3479         m_ops[parenBegin].m_nextOp = parenEnd;
3480         m_ops[parenEnd].m_term = term;
3481         m_ops[parenEnd].m_previousOp = parenBegin;
3482         m_ops[parenEnd].m_nextOp = notFound;
3483     }
3484 
3485     // opCompileParentheticalAssertion
3486     // Emits ops for a parenthetical assertion. These consist of an
3487     // OpSimpleNestedAlternativeBegin/Next/End set of nodes wrapping
3488     // the alternatives, with these wrapped by an outer pair of
3489     // OpParentheticalAssertionBegin/End nodes.
3490     // We can always use the OpSimpleNestedAlternative nodes in the
3491     // case of parenthetical assertions since these only ever match
3492     // once, and will never backtrack back into the assertion.
3493     void opCompileParentheticalAssertion(PatternTerm* term)
3494     {
<a name="53" id="anc53"></a>




3495         size_t parenBegin = m_ops.size();
3496         m_ops.append(OpParentheticalAssertionBegin);
3497 
3498         m_ops.append(OpSimpleNestedAlternativeBegin);
3499         m_ops.last().m_previousOp = notFound;
3500         m_ops.last().m_term = term;
3501         Vector&lt;std::unique_ptr&lt;PatternAlternative&gt;&gt;&amp; alternatives =  term-&gt;parentheses.disjunction-&gt;m_alternatives;
3502         for (unsigned i = 0; i &lt; alternatives.size(); ++i) {
3503             size_t lastOpIndex = m_ops.size() - 1;
3504 
3505             PatternAlternative* nestedAlternative = alternatives[i].get();
3506             opCompileAlternative(nestedAlternative);
3507 
3508             size_t thisOpIndex = m_ops.size();
3509             m_ops.append(YarrOp(OpSimpleNestedAlternativeNext));
3510 
3511             YarrOp&amp; lastOp = m_ops[lastOpIndex];
3512             YarrOp&amp; thisOp = m_ops[thisOpIndex];
3513 
3514             lastOp.m_alternative = nestedAlternative;
3515             lastOp.m_nextOp = thisOpIndex;
3516             thisOp.m_previousOp = lastOpIndex;
3517             thisOp.m_term = term;
3518         }
3519         YarrOp&amp; lastOp = m_ops.last();
3520         ASSERT(lastOp.m_op == OpSimpleNestedAlternativeNext);
3521         lastOp.m_op = OpSimpleNestedAlternativeEnd;
3522         lastOp.m_alternative = 0;
3523         lastOp.m_nextOp = notFound;
3524 
3525         size_t parenEnd = m_ops.size();
3526         m_ops.append(OpParentheticalAssertionEnd);
3527 
3528         m_ops[parenBegin].m_term = term;
3529         m_ops[parenBegin].m_previousOp = notFound;
3530         m_ops[parenBegin].m_nextOp = parenEnd;
3531         m_ops[parenEnd].m_term = term;
3532         m_ops[parenEnd].m_previousOp = parenBegin;
3533         m_ops[parenEnd].m_nextOp = notFound;
3534     }
3535 
3536     // opCompileAlternative
3537     // Called to emit nodes for all terms in an alternative.
3538     void opCompileAlternative(PatternAlternative* alternative)
3539     {
3540         optimizeAlternative(alternative);
3541 
3542         for (unsigned i = 0; i &lt; alternative-&gt;m_terms.size(); ++i) {
3543             PatternTerm* term = &amp;alternative-&gt;m_terms[i];
3544 
3545             switch (term-&gt;type) {
3546             case PatternTerm::TypeParenthesesSubpattern:
3547                 opCompileParenthesesSubpattern(term);
3548                 break;
3549 
3550             case PatternTerm::TypeParentheticalAssertion:
3551                 opCompileParentheticalAssertion(term);
3552                 break;
3553 
3554             default:
3555                 m_ops.append(term);
3556             }
3557         }
3558     }
3559 
3560     // opCompileBody
3561     // This method compiles the body disjunction of the regular expression.
3562     // The body consists of two sets of alternatives - zero or more &#39;once
3563     // through&#39; (BOL anchored) alternatives, followed by zero or more
3564     // repeated alternatives.
3565     // For each of these two sets of alteratives, if not empty they will be
3566     // wrapped in a set of OpBodyAlternativeBegin/Next/End nodes (with the
3567     // &#39;begin&#39; node referencing the first alternative, and &#39;next&#39; nodes
3568     // referencing any further alternatives. The begin/next/end nodes are
3569     // linked together in a doubly linked list. In the case of repeating
3570     // alternatives, the end node is also linked back to the beginning.
3571     // If no repeating alternatives exist, then a OpMatchFailed node exists
3572     // to return the failing result.
3573     void opCompileBody(PatternDisjunction* disjunction)
3574     {
<a name="54" id="anc54"></a>




3575         Vector&lt;std::unique_ptr&lt;PatternAlternative&gt;&gt;&amp; alternatives = disjunction-&gt;m_alternatives;
3576         size_t currentAlternativeIndex = 0;
3577 
3578         // Emit the &#39;once through&#39; alternatives.
3579         if (alternatives.size() &amp;&amp; alternatives[0]-&gt;onceThrough()) {
3580             m_ops.append(YarrOp(OpBodyAlternativeBegin));
3581             m_ops.last().m_previousOp = notFound;
3582 
3583             do {
3584                 size_t lastOpIndex = m_ops.size() - 1;
3585                 PatternAlternative* alternative = alternatives[currentAlternativeIndex].get();
3586                 opCompileAlternative(alternative);
3587 
3588                 size_t thisOpIndex = m_ops.size();
3589                 m_ops.append(YarrOp(OpBodyAlternativeNext));
3590 
3591                 YarrOp&amp; lastOp = m_ops[lastOpIndex];
3592                 YarrOp&amp; thisOp = m_ops[thisOpIndex];
3593 
3594                 lastOp.m_alternative = alternative;
3595                 lastOp.m_nextOp = thisOpIndex;
3596                 thisOp.m_previousOp = lastOpIndex;
3597 
3598                 ++currentAlternativeIndex;
3599             } while (currentAlternativeIndex &lt; alternatives.size() &amp;&amp; alternatives[currentAlternativeIndex]-&gt;onceThrough());
3600 
3601             YarrOp&amp; lastOp = m_ops.last();
3602 
3603             ASSERT(lastOp.m_op == OpBodyAlternativeNext);
3604             lastOp.m_op = OpBodyAlternativeEnd;
3605             lastOp.m_alternative = 0;
3606             lastOp.m_nextOp = notFound;
3607         }
3608 
3609         if (currentAlternativeIndex == alternatives.size()) {
3610             m_ops.append(YarrOp(OpMatchFailed));
3611             return;
3612         }
3613 
3614         // Emit the repeated alternatives.
3615         size_t repeatLoop = m_ops.size();
3616         m_ops.append(YarrOp(OpBodyAlternativeBegin));
3617         m_ops.last().m_previousOp = notFound;
3618         do {
3619             size_t lastOpIndex = m_ops.size() - 1;
3620             PatternAlternative* alternative = alternatives[currentAlternativeIndex].get();
3621             ASSERT(!alternative-&gt;onceThrough());
3622             opCompileAlternative(alternative);
3623 
3624             size_t thisOpIndex = m_ops.size();
3625             m_ops.append(YarrOp(OpBodyAlternativeNext));
3626 
3627             YarrOp&amp; lastOp = m_ops[lastOpIndex];
3628             YarrOp&amp; thisOp = m_ops[thisOpIndex];
3629 
3630             lastOp.m_alternative = alternative;
3631             lastOp.m_nextOp = thisOpIndex;
3632             thisOp.m_previousOp = lastOpIndex;
3633 
3634             ++currentAlternativeIndex;
3635         } while (currentAlternativeIndex &lt; alternatives.size());
3636         YarrOp&amp; lastOp = m_ops.last();
3637         ASSERT(lastOp.m_op == OpBodyAlternativeNext);
3638         lastOp.m_op = OpBodyAlternativeEnd;
3639         lastOp.m_alternative = 0;
3640         lastOp.m_nextOp = repeatLoop;
3641     }
3642 
3643     void generateTryReadUnicodeCharacterHelper()
3644     {
3645 #ifdef JIT_UNICODE_EXPRESSIONS
3646         if (m_tryReadUnicodeCharacterCalls.isEmpty())
3647             return;
3648 
3649         ASSERT(m_decodeSurrogatePairs);
3650 
3651         m_tryReadUnicodeCharacterEntry = label();
3652 
3653         tagReturnAddress();
3654 
3655         tryReadUnicodeCharImpl(regT0);
3656 
3657         ret();
3658 #endif
3659     }
3660 
3661     void generateEnter()
3662     {
3663 #if CPU(X86_64)
3664         push(X86Registers::ebp);
3665         move(stackPointerRegister, X86Registers::ebp);
3666 
3667         if (m_pattern.m_saveInitialStartValue)
3668             push(X86Registers::ebx);
3669 
3670 #if OS(WINDOWS)
3671         push(X86Registers::edi);
3672 #endif
3673 #if ENABLE(YARR_JIT_ALL_PARENS_EXPRESSIONS)
3674         if (m_containsNestedSubpatterns) {
3675 #if OS(WINDOWS)
3676             push(X86Registers::esi);
3677 #endif
3678             push(X86Registers::r12);
3679         }
3680 #endif
3681 
3682         if (m_decodeSurrogatePairs) {
3683             push(X86Registers::r13);
3684             push(X86Registers::r14);
3685             push(X86Registers::r15);
3686 
3687             move(TrustedImm32(0xd800), leadingSurrogateTag);
<a name="55" id="anc55"></a><span class="line-removed">3688             move(TrustedImm32(0xdc00), trailingSurrogateTag);</span>
3689         }
3690         // The ABI doesn&#39;t guarantee the upper bits are zero on unsigned arguments, so clear them ourselves.
3691         zeroExtend32ToPtr(index, index);
3692         zeroExtend32ToPtr(length, length);
3693 #if OS(WINDOWS)
3694         if (compileMode == IncludeSubpatterns)
3695             loadPtr(Address(X86Registers::ebp, 6 * sizeof(void*)), output);
3696         // rcx is the pointer to the allocated space for result in x64 Windows.
3697         push(X86Registers::ecx);
3698 #endif
3699 #elif CPU(X86)
3700         push(X86Registers::ebp);
3701         move(stackPointerRegister, X86Registers::ebp);
3702         // TODO: do we need spill registers to fill the output pointer if there are no sub captures?
3703         push(X86Registers::ebx);
3704         push(X86Registers::edi);
3705         push(X86Registers::esi);
3706         // load output into edi (2 = saved ebp + return address).
3707     #if COMPILER(MSVC)
3708         loadPtr(Address(X86Registers::ebp, 2 * sizeof(void*)), input);
3709         loadPtr(Address(X86Registers::ebp, 3 * sizeof(void*)), index);
3710         loadPtr(Address(X86Registers::ebp, 4 * sizeof(void*)), length);
3711         if (compileMode == IncludeSubpatterns)
3712             loadPtr(Address(X86Registers::ebp, 5 * sizeof(void*)), output);
3713     #else
3714         if (compileMode == IncludeSubpatterns)
3715             loadPtr(Address(X86Registers::ebp, 2 * sizeof(void*)), output);
3716     #endif
3717 #elif CPU(ARM64)
3718         tagReturnAddress();
3719         if (m_decodeSurrogatePairs) {
3720             pushPair(framePointerRegister, linkRegister);
3721             move(TrustedImm32(0x10000), supplementaryPlanesBase);
<a name="56" id="anc56"></a><span class="line-removed">3722             move(TrustedImm32(0xfffffc00), surrogateTagMask);</span>
3723             move(TrustedImm32(0xd800), leadingSurrogateTag);
3724             move(TrustedImm32(0xdc00), trailingSurrogateTag);
3725         }
3726 
3727         // The ABI doesn&#39;t guarantee the upper bits are zero on unsigned arguments, so clear them ourselves.
3728         zeroExtend32ToPtr(index, index);
3729         zeroExtend32ToPtr(length, length);
3730 #elif CPU(ARM_THUMB2)
3731         push(ARMRegisters::r4);
3732         push(ARMRegisters::r5);
3733         push(ARMRegisters::r6);
3734         push(ARMRegisters::r8);
3735 #elif CPU(MIPS)
3736         // Do nothing.
3737 #endif
3738 
3739         store8(TrustedImm32(1), &amp;m_vm-&gt;isExecutingInRegExpJIT);
3740     }
3741 
3742     void generateReturn()
3743     {
3744         store8(TrustedImm32(0), &amp;m_vm-&gt;isExecutingInRegExpJIT);
3745 
3746 #if CPU(X86_64)
3747 #if OS(WINDOWS)
3748         // Store the return value in the allocated space pointed by rcx.
3749         pop(X86Registers::ecx);
3750         store64(returnRegister, Address(X86Registers::ecx));
3751         store64(returnRegister2, Address(X86Registers::ecx, sizeof(void*)));
3752         move(X86Registers::ecx, returnRegister);
3753 #endif
3754         if (m_decodeSurrogatePairs) {
3755             pop(X86Registers::r15);
3756             pop(X86Registers::r14);
3757             pop(X86Registers::r13);
3758         }
3759 
3760 #if ENABLE(YARR_JIT_ALL_PARENS_EXPRESSIONS)
3761         if (m_containsNestedSubpatterns) {
3762             pop(X86Registers::r12);
3763 #if OS(WINDOWS)
3764             pop(X86Registers::esi);
3765 #endif
3766         }
3767 #endif
3768 #if OS(WINDOWS)
3769         pop(X86Registers::edi);
3770 #endif
3771 
3772         if (m_pattern.m_saveInitialStartValue)
3773             pop(X86Registers::ebx);
3774         pop(X86Registers::ebp);
3775 #elif CPU(X86)
3776         pop(X86Registers::esi);
3777         pop(X86Registers::edi);
3778         pop(X86Registers::ebx);
3779         pop(X86Registers::ebp);
3780 #elif CPU(ARM64)
3781         if (m_decodeSurrogatePairs)
3782             popPair(framePointerRegister, linkRegister);
3783 #elif CPU(ARM_THUMB2)
3784         pop(ARMRegisters::r8);
3785         pop(ARMRegisters::r6);
3786         pop(ARMRegisters::r5);
3787         pop(ARMRegisters::r4);
3788 #elif CPU(MIPS)
3789         // Do nothing
3790 #endif
3791         ret();
3792     }
3793 
3794 public:
3795     YarrGenerator(VM* vm, YarrPattern&amp; pattern, String&amp; patternString, YarrCodeBlock&amp; codeBlock, YarrCharSize charSize)
3796         : m_vm(vm)
3797         , m_pattern(pattern)
3798         , m_patternString(patternString)
3799         , m_codeBlock(codeBlock)
3800         , m_charSize(charSize)
3801         , m_decodeSurrogatePairs(m_charSize == Char16 &amp;&amp; m_pattern.unicode())
3802         , m_unicodeIgnoreCase(m_pattern.unicode() &amp;&amp; m_pattern.ignoreCase())
<a name="57" id="anc57"></a>
3803         , m_canonicalMode(m_pattern.unicode() ? CanonicalMode::Unicode : CanonicalMode::UCS2)
3804 #if ENABLE(YARR_JIT_ALL_PARENS_EXPRESSIONS)
3805         , m_containsNestedSubpatterns(false)
3806         , m_parenContextSizes(compileMode == IncludeSubpatterns ? m_pattern.m_numSubpatterns : 0, m_pattern.m_body-&gt;m_callFrameSize)
3807 #endif
3808     {
3809     }
3810 
3811     void compile()
3812     {
3813         YarrCodeBlock&amp; codeBlock = m_codeBlock;
3814 
3815 #ifndef JIT_UNICODE_EXPRESSIONS
3816         if (m_decodeSurrogatePairs) {
3817             codeBlock.setFallBackWithFailureReason(JITFailureReason::DecodeSurrogatePair);
3818             return;
3819         }
3820 #endif
3821 
3822         if (m_pattern.m_containsBackreferences
3823 #if ENABLE(YARR_JIT_BACKREFERENCES)
3824             &amp;&amp; (compileMode == MatchOnly || (m_pattern.ignoreCase() &amp;&amp; m_charSize != Char8))
3825 #endif
3826             ) {
3827                 codeBlock.setFallBackWithFailureReason(JITFailureReason::BackReference);
3828                 return;
3829         }
3830 
3831         // We need to compile before generating code since we set flags based on compilation that
3832         // are used during generation.
3833         opCompileBody(m_pattern.m_body);
3834 
3835         if (m_failureReason) {
3836             codeBlock.setFallBackWithFailureReason(*m_failureReason);
3837             return;
3838         }
3839 
3840         if (UNLIKELY(Options::dumpDisassembly() || Options::dumpRegExpDisassembly()))
<a name="58" id="anc58"></a><span class="line-modified">3841             m_disassembler = std::make_unique&lt;YarrDisassembler&gt;(this);</span>
3842 
3843         if (m_disassembler)
3844             m_disassembler-&gt;setStartOfCode(label());
3845 
3846 #if ENABLE(YARR_JIT_ALL_PARENS_EXPRESSIONS)
3847         if (m_containsNestedSubpatterns)
3848             codeBlock.setUsesPatternContextBuffer();
3849 #endif
3850 
3851         generateEnter();
3852 
3853         Jump hasInput = checkInput();
3854         generateFailReturn();
3855         hasInput.link(this);
3856 
<a name="59" id="anc59"></a>




3857 #if ENABLE(YARR_JIT_ALL_PARENS_EXPRESSIONS)
3858         if (m_containsNestedSubpatterns)
3859             move(TrustedImm32(matchLimit), remainingMatchCount);
3860 #endif
3861 
3862         if (compileMode == IncludeSubpatterns) {
3863             for (unsigned i = 0; i &lt; m_pattern.m_numSubpatterns + 1; ++i)
3864                 store32(TrustedImm32(-1), Address(output, (i &lt;&lt; 1) * sizeof(int)));
3865         }
3866 
3867         if (!m_pattern.m_body-&gt;m_hasFixedSize)
3868             setMatchStart(index);
3869 
3870         initCallFrame();
3871 
3872 #if ENABLE(YARR_JIT_ALL_PARENS_EXPRESSIONS)
<a name="60" id="anc60"></a><span class="line-modified">3873         if (m_containsNestedSubpatterns)</span>
3874             initParenContextFreeList();
<a name="61" id="anc61"></a>




3875 #endif
3876 
3877         if (m_pattern.m_saveInitialStartValue) {
3878 #ifdef HAVE_INITIAL_START_REG
3879             move(index, initialStart);
3880 #else
3881             storeToFrame(index, m_pattern.m_initialStartValueFrameLocation);
3882 #endif
3883         }
3884 
3885         generate();
3886         if (m_disassembler)
3887             m_disassembler-&gt;setEndOfGenerate(label());
3888         backtrack();
3889         if (m_disassembler)
3890             m_disassembler-&gt;setEndOfBacktrack(label());
3891 
3892         generateTryReadUnicodeCharacterHelper();
3893 
3894         generateJITFailReturn();
3895 
3896         if (m_disassembler)
3897             m_disassembler-&gt;setEndOfCode(label());
3898 
3899         LinkBuffer linkBuffer(*this, REGEXP_CODE_ID, JITCompilationCanFail);
3900         if (linkBuffer.didFailToAllocate()) {
3901             codeBlock.setFallBackWithFailureReason(JITFailureReason::ExecutableMemoryAllocationFailure);
3902             return;
3903         }
3904 
3905         if (!m_tryReadUnicodeCharacterCalls.isEmpty()) {
3906             CodeLocationLabel&lt;NoPtrTag&gt; tryReadUnicodeCharacterHelper = linkBuffer.locationOf&lt;NoPtrTag&gt;(m_tryReadUnicodeCharacterEntry);
3907 
3908             for (auto call : m_tryReadUnicodeCharacterCalls)
3909                 linkBuffer.link(call, tryReadUnicodeCharacterHelper);
3910         }
3911 
3912         m_backtrackingState.linkDataLabels(linkBuffer);
3913 
3914         if (m_disassembler)
3915             m_disassembler-&gt;dump(linkBuffer);
3916 
3917         if (compileMode == MatchOnly) {
3918             if (m_charSize == Char8)
3919                 codeBlock.set8BitCodeMatchOnly(FINALIZE_REGEXP_CODE(linkBuffer, YarrMatchOnly8BitPtrTag, &quot;Match-only 8-bit regular expression&quot;));
3920             else
3921                 codeBlock.set16BitCodeMatchOnly(FINALIZE_REGEXP_CODE(linkBuffer, YarrMatchOnly16BitPtrTag, &quot;Match-only 16-bit regular expression&quot;));
3922         } else {
3923             if (m_charSize == Char8)
3924                 codeBlock.set8BitCode(FINALIZE_REGEXP_CODE(linkBuffer, Yarr8BitPtrTag, &quot;8-bit regular expression&quot;));
3925             else
3926                 codeBlock.set16BitCode(FINALIZE_REGEXP_CODE(linkBuffer, Yarr16BitPtrTag, &quot;16-bit regular expression&quot;));
3927         }
3928         if (m_failureReason)
3929             codeBlock.setFallBackWithFailureReason(*m_failureReason);
3930     }
3931 
3932     const char* variant() override
3933     {
3934         if (compileMode == MatchOnly) {
3935             if (m_charSize == Char8)
3936                 return &quot;Match-only 8-bit regular expression&quot;;
3937 
3938             return &quot;Match-only 16-bit regular expression&quot;;
3939         }
3940 
3941         if (m_charSize == Char8)
3942             return &quot;8-bit regular expression&quot;;
3943 
3944         return &quot;16-bit regular expression&quot;;
3945     }
3946 
3947     unsigned opCount() override
3948     {
3949         return m_ops.size();
3950     }
3951 
3952     void dumpPatternString(PrintStream&amp; out) override
3953     {
3954         m_pattern.dumpPatternString(out, m_patternString);
3955     }
3956 
3957     int dumpFor(PrintStream&amp; out, unsigned opIndex) override
3958     {
3959         if (opIndex &gt;= opCount())
3960             return 0;
3961 
3962         out.printf(&quot;%4d:&quot;, opIndex);
3963 
3964         YarrOp&amp; op = m_ops[opIndex];
3965         PatternTerm* term = op.m_term;
3966         switch (op.m_op) {
3967         case OpTerm: {
3968             out.print(&quot;OpTerm &quot;);
3969             switch (term-&gt;type) {
3970             case PatternTerm::TypeAssertionBOL:
3971                 out.print(&quot;Assert BOL&quot;);
3972                 break;
3973 
3974             case PatternTerm::TypeAssertionEOL:
3975                 out.print(&quot;Assert EOL&quot;);
3976                 break;
3977 
3978             case PatternTerm::TypeBackReference:
3979                 out.printf(&quot;BackReference pattern #%u&quot;, term-&gt;backReferenceSubpatternId);
3980                 term-&gt;dumpQuantifier(out);
3981                 break;
3982 
3983             case PatternTerm::TypePatternCharacter:
3984                 out.print(&quot;TypePatternCharacter &quot;);
3985                 dumpUChar32(out, term-&gt;patternCharacter);
3986                 if (m_pattern.ignoreCase())
3987                     out.print(&quot; ignore case&quot;);
3988 
3989                 term-&gt;dumpQuantifier(out);
3990                 break;
3991 
3992             case PatternTerm::TypeCharacterClass:
3993                 out.print(&quot;TypePatternCharacterClass &quot;);
3994                 if (term-&gt;invert())
3995                     out.print(&quot;not &quot;);
3996                 dumpCharacterClass(out, &amp;m_pattern, term-&gt;characterClass);
3997                 term-&gt;dumpQuantifier(out);
3998                 break;
3999 
4000             case PatternTerm::TypeAssertionWordBoundary:
4001                 out.printf(&quot;%sword boundary&quot;, term-&gt;invert() ? &quot;non-&quot; : &quot;&quot;);
4002                 break;
4003 
4004             case PatternTerm::TypeDotStarEnclosure:
4005                 out.print(&quot;.* enclosure&quot;);
4006                 break;
4007 
4008             case PatternTerm::TypeForwardReference:
4009                 out.print(&quot;TypeForwardReference &lt;not handled&gt;&quot;);
4010                 break;
4011 
4012             case PatternTerm::TypeParenthesesSubpattern:
4013             case PatternTerm::TypeParentheticalAssertion:
4014                 RELEASE_ASSERT_NOT_REACHED();
4015                 break;
4016             }
4017 
4018             if (op.m_isDeadCode)
4019                 out.print(&quot; already handled&quot;);
4020             out.print(&quot;\n&quot;);
4021             return(0);
4022         }
4023 
4024         case OpBodyAlternativeBegin:
4025             out.printf(&quot;OpBodyAlternativeBegin minimum size %u\n&quot;, op.m_alternative-&gt;m_minimumSize);
4026             return(0);
4027 
4028         case OpBodyAlternativeNext:
4029             out.printf(&quot;OpBodyAlternativeNext minimum size %u\n&quot;, op.m_alternative-&gt;m_minimumSize);
4030             return(0);
4031 
4032         case OpBodyAlternativeEnd:
4033             out.print(&quot;OpBodyAlternativeEnd\n&quot;);
4034             return(0);
4035 
4036         case OpSimpleNestedAlternativeBegin:
4037             out.printf(&quot;OpSimpleNestedAlternativeBegin minimum size %u\n&quot;, op.m_alternative-&gt;m_minimumSize);
4038             return(1);
4039 
4040         case OpNestedAlternativeBegin:
4041             out.printf(&quot;OpNestedAlternativeBegin minimum size %u\n&quot;, op.m_alternative-&gt;m_minimumSize);
4042             return(1);
4043 
4044         case OpSimpleNestedAlternativeNext:
4045             out.printf(&quot;OpSimpleNestedAlternativeNext minimum size %u\n&quot;, op.m_alternative-&gt;m_minimumSize);
4046             return(0);
4047 
4048         case OpNestedAlternativeNext:
4049             out.printf(&quot;OpNestedAlternativeNext minimum size %u\n&quot;, op.m_alternative-&gt;m_minimumSize);
4050             return(0);
4051 
4052         case OpSimpleNestedAlternativeEnd:
4053             out.print(&quot;OpSimpleNestedAlternativeEnd&quot;);
4054             term-&gt;dumpQuantifier(out);
4055             out.print(&quot;\n&quot;);
4056             return(-1);
4057 
4058         case OpNestedAlternativeEnd:
4059             out.print(&quot;OpNestedAlternativeEnd&quot;);
4060             term-&gt;dumpQuantifier(out);
4061             out.print(&quot;\n&quot;);
4062             return(-1);
4063 
4064         case OpParenthesesSubpatternOnceBegin:
4065             out.print(&quot;OpParenthesesSubpatternOnceBegin &quot;);
4066             if (term-&gt;capture())
4067                 out.printf(&quot;capturing pattern #%u&quot;, term-&gt;parentheses.subpatternId);
4068             else
4069                 out.print(&quot;non-capturing&quot;);
4070             term-&gt;dumpQuantifier(out);
4071             out.print(&quot;\n&quot;);
4072             return(0);
4073 
4074         case OpParenthesesSubpatternOnceEnd:
4075             out.print(&quot;OpParenthesesSubpatternOnceEnd &quot;);
4076             if (term-&gt;capture())
4077                 out.printf(&quot;capturing pattern #%u&quot;, term-&gt;parentheses.subpatternId);
4078             else
4079                 out.print(&quot;non-capturing&quot;);
4080             term-&gt;dumpQuantifier(out);
4081             out.print(&quot;\n&quot;);
4082             return(0);
4083 
4084         case OpParenthesesSubpatternTerminalBegin:
4085             out.print(&quot;OpParenthesesSubpatternTerminalBegin &quot;);
4086             if (term-&gt;capture())
4087                 out.printf(&quot;capturing pattern #%u\n&quot;, term-&gt;parentheses.subpatternId);
4088             else
4089                 out.print(&quot;non-capturing\n&quot;);
4090             return(0);
4091 
4092         case OpParenthesesSubpatternTerminalEnd:
4093             out.print(&quot;OpParenthesesSubpatternTerminalEnd &quot;);
4094             if (term-&gt;capture())
4095                 out.printf(&quot;capturing pattern #%u\n&quot;, term-&gt;parentheses.subpatternId);
4096             else
4097                 out.print(&quot;non-capturing\n&quot;);
4098             return(0);
4099 
4100         case OpParenthesesSubpatternBegin:
4101             out.print(&quot;OpParenthesesSubpatternBegin &quot;);
4102             if (term-&gt;capture())
4103                 out.printf(&quot;capturing pattern #%u&quot;, term-&gt;parentheses.subpatternId);
4104             else
4105                 out.print(&quot;non-capturing&quot;);
4106             term-&gt;dumpQuantifier(out);
4107             out.print(&quot;\n&quot;);
4108             return(0);
4109 
4110         case OpParenthesesSubpatternEnd:
4111             out.print(&quot;OpParenthesesSubpatternEnd &quot;);
4112             if (term-&gt;capture())
4113                 out.printf(&quot;capturing pattern #%u&quot;, term-&gt;parentheses.subpatternId);
4114             else
4115                 out.print(&quot;non-capturing&quot;);
4116             term-&gt;dumpQuantifier(out);
4117             out.print(&quot;\n&quot;);
4118             return(0);
4119 
4120         case OpParentheticalAssertionBegin:
4121             out.printf(&quot;OpParentheticalAssertionBegin%s\n&quot;, term-&gt;invert() ? &quot; inverted&quot; : &quot;&quot;);
4122             return(0);
4123 
4124         case OpParentheticalAssertionEnd:
4125             out.printf(&quot;OpParentheticalAssertionEnd%s\n&quot;, term-&gt;invert() ? &quot; inverted&quot; : &quot;&quot;);
4126             return(0);
4127 
4128         case OpMatchFailed:
4129             out.print(&quot;OpMatchFailed\n&quot;);
4130             return(0);
4131         }
4132 
4133         return(0);
4134     }
4135 
4136 private:
4137     VM* m_vm;
4138 
4139     YarrPattern&amp; m_pattern;
4140     String&amp; m_patternString;
4141 
4142     YarrCodeBlock&amp; m_codeBlock;
4143     YarrCharSize m_charSize;
4144 
4145     // Used to detect regular expression constructs that are not currently
4146     // supported in the JIT; fall back to the interpreter when this is detected.
4147     Optional&lt;JITFailureReason&gt; m_failureReason;
4148 
4149     bool m_decodeSurrogatePairs;
4150     bool m_unicodeIgnoreCase;
<a name="62" id="anc62"></a>
4151     CanonicalMode m_canonicalMode;
4152 #if ENABLE(YARR_JIT_ALL_PARENS_EXPRESSIONS)
4153     bool m_containsNestedSubpatterns;
4154     ParenContextSizes m_parenContextSizes;
4155 #endif
4156     JumpList m_abortExecution;
4157     JumpList m_hitMatchLimit;
4158     Vector&lt;Call&gt; m_tryReadUnicodeCharacterCalls;
4159     Label m_tryReadUnicodeCharacterEntry;
4160 
4161     // The regular expression expressed as a linear sequence of operations.
4162     Vector&lt;YarrOp, 128&gt; m_ops;
4163 
4164     // This records the current input offset being applied due to the current
4165     // set of alternatives we are nested within. E.g. when matching the
4166     // character &#39;b&#39; within the regular expression /abc/, we will know that
4167     // the minimum size for the alternative is 3, checked upon entry to the
4168     // alternative, and that &#39;b&#39; is at offset 1 from the start, and as such
4169     // when matching &#39;b&#39; we need to apply an offset of -2 to the load.
4170     //
4171     // FIXME: This should go away. Rather than tracking this value throughout
4172     // code generation, we should gather this information up front &amp; store it
4173     // on the YarrOp structure.
4174     Checked&lt;unsigned&gt; m_checkedOffset;
4175 
4176     // This class records state whilst generating the backtracking path of code.
4177     BacktrackingState m_backtrackingState;
4178 
4179     std::unique_ptr&lt;YarrDisassembler&gt; m_disassembler;
4180 };
4181 
4182 static void dumpCompileFailure(JITFailureReason failure)
4183 {
4184     switch (failure) {
4185     case JITFailureReason::DecodeSurrogatePair:
4186         dataLog(&quot;Can&#39;t JIT a pattern decoding surrogate pairs\n&quot;);
4187         break;
4188     case JITFailureReason::BackReference:
4189         dataLog(&quot;Can&#39;t JIT some patterns containing back references\n&quot;);
4190         break;
4191     case JITFailureReason::ForwardReference:
4192         dataLog(&quot;Can&#39;t JIT a pattern containing forward references\n&quot;);
4193         break;
4194     case JITFailureReason::VariableCountedParenthesisWithNonZeroMinimum:
4195         dataLog(&quot;Can&#39;t JIT a pattern containing a variable counted parenthesis with a non-zero minimum\n&quot;);
4196         break;
4197     case JITFailureReason::ParenthesizedSubpattern:
4198         dataLog(&quot;Can&#39;t JIT a pattern containing parenthesized subpatterns\n&quot;);
4199         break;
4200     case JITFailureReason::FixedCountParenthesizedSubpattern:
4201         dataLog(&quot;Can&#39;t JIT a pattern containing fixed count parenthesized subpatterns\n&quot;);
4202         break;
<a name="63" id="anc63"></a>


4203     case JITFailureReason::ExecutableMemoryAllocationFailure:
4204         dataLog(&quot;Can&#39;t JIT because of failure of allocation of executable memory\n&quot;);
4205         break;
4206     }
4207 }
4208 
4209 void jitCompile(YarrPattern&amp; pattern, String&amp; patternString, YarrCharSize charSize, VM* vm, YarrCodeBlock&amp; codeBlock, YarrJITCompileMode mode)
4210 {
4211     if (mode == MatchOnly)
4212         YarrGenerator&lt;MatchOnly&gt;(vm, pattern, patternString, codeBlock, charSize).compile();
4213     else
4214         YarrGenerator&lt;IncludeSubpatterns&gt;(vm, pattern, patternString, codeBlock, charSize).compile();
4215 
4216     if (auto failureReason = codeBlock.failureReason()) {
4217         if (Options::dumpCompiledRegExpPatterns()) {
4218             pattern.dumpPatternString(WTF::dataFile(), patternString);
4219             dataLog(&quot; : &quot;);
4220             dumpCompileFailure(*failureReason);
4221         }
4222     }
4223 }
4224 
4225 }}
4226 
4227 #endif
<a name="64" id="anc64"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="64" type="hidden" />
</body>
</html>