<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.web/src/main/native/Source/WebCore/Modules/webgpu/WHLSL/WHLSLParser.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (C) 2019 Apple Inc. All rights reserved.
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  * 1. Redistributions of source code must retain the above copyright
   8  *    notice, this list of conditions and the following disclaimer.
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
  14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
  15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
  17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
  23  * THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #include &quot;config.h&quot;
  27 #include &quot;WHLSLParser.h&quot;
  28 
  29 #if ENABLE(WEBGPU)
  30 
  31 #include &quot;WHLSLAddressSpace.h&quot;
  32 #include &quot;WHLSLEntryPointType.h&quot;
  33 #include &lt;wtf/dtoa.h&gt;
  34 #include &lt;wtf/text/StringBuilder.h&gt;
  35 #include &lt;wtf/text/StringConcatenate.h&gt;
  36 
  37 namespace WebCore {
  38 
  39 namespace WHLSL {
  40 
  41 // FIXME: Return a better error code from this, and report it to JavaScript.
  42 auto Parser::parse(Program&amp; program, StringView stringView, Mode mode) -&gt; Optional&lt;Error&gt;
  43 {
  44     m_lexer = Lexer(stringView);
  45     m_mode = mode;
  46 
  47     while (!m_lexer.isFullyConsumed()) {
  48         if (tryType(Lexer::Token::Type::Semicolon)) {
  49             m_lexer.consumeToken();
  50             continue;
  51         }
  52 
  53         {
  54             auto typeDefinition = backtrackingScope&lt;Expected&lt;AST::TypeDefinition, Error&gt;&gt;([&amp;]() {
  55                 return parseTypeDefinition();
  56             });
  57             if (typeDefinition) {
  58                 auto success = program.append(WTFMove(*typeDefinition));
  59                 if (!success)
  60                     return WTF::nullopt;
  61                 continue;
  62             }
  63         }
  64 
  65         {
  66             auto structureDefinition = backtrackingScope&lt;Expected&lt;AST::StructureDefinition, Error&gt;&gt;([&amp;]() {
  67                 return parseStructureDefinition();
  68             });
  69             if (structureDefinition) {
  70                 auto success = program.append(WTFMove(*structureDefinition));
  71                 if (!success)
  72                     return WTF::nullopt;
  73                 continue;
  74             }
  75         }
  76 
  77         {
  78             auto enumerationDefinition = backtrackingScope&lt;Expected&lt;AST::EnumerationDefinition, Error&gt;&gt;([&amp;]() {
  79                 return parseEnumerationDefinition();
  80             });
  81             if (enumerationDefinition) {
  82                 auto success = program.append(WTFMove(*enumerationDefinition));
  83                 if (!success)
  84                     return WTF::nullopt;
  85                 continue;
  86             }
  87         }
  88 
  89         Optional&lt;Error&gt; error;
  90         {
  91             auto functionDefinition = backtrackingScope&lt;Expected&lt;AST::FunctionDefinition, Error&gt;&gt;([&amp;]() {
  92                 return parseFunctionDefinition();
  93             });
  94             if (functionDefinition) {
  95                 auto success = program.append(WTFMove(*functionDefinition));
  96                 if (!success)
  97                     return WTF::nullopt;
  98                 continue;
  99             }
 100             error = functionDefinition.error();
 101         }
 102 
 103         if (m_mode == Mode::StandardLibrary) {
 104             auto nativeFunctionDeclaration = backtrackingScope&lt;Expected&lt;AST::NativeFunctionDeclaration, Error&gt;&gt;([&amp;]() {
 105                 return parseNativeFunctionDeclaration();
 106             });
 107             if (nativeFunctionDeclaration) {
 108                 auto success = program.append(WTFMove(*nativeFunctionDeclaration));
 109                 if (!success)
 110                     return WTF::nullopt;
 111                 continue;
 112             }
 113         }
 114 
 115         if (m_mode == Mode::StandardLibrary) {
 116             auto nativeTypeDeclaration = backtrackingScope&lt;Expected&lt;AST::NativeTypeDeclaration, Error&gt;&gt;([&amp;]() {
 117                 return parseNativeTypeDeclaration();
 118             });
 119             if (nativeTypeDeclaration) {
 120                 auto success = program.append(WTFMove(*nativeTypeDeclaration));
 121                 if (!success)
 122                     return WTF::nullopt;
 123                 continue;
 124             }
 125         }
 126 
 127         return WTFMove(*error);
 128     }
 129     return WTF::nullopt;
 130 }
 131 
 132 auto Parser::fail(const String&amp; message) -&gt; Unexpected&lt;Error&gt;
 133 {
 134     if (auto nextToken = peek())
 135         return Unexpected&lt;Error&gt;(Error(m_lexer.errorString(*nextToken, message)));
 136     return Unexpected&lt;Error&gt;(Error(makeString(&quot;Cannot lex: &quot;, message)));
 137 }
 138 
 139 auto Parser::peek() -&gt; Expected&lt;Lexer::Token, Error&gt;
 140 {
 141     if (auto token = m_lexer.consumeToken()) {
 142         m_lexer.unconsumeToken(Lexer::Token(*token));
 143         return *token;
 144     }
 145     return fail(&quot;Cannot consume token&quot;_str);
 146 }
 147 
 148 Optional&lt;Lexer::Token&gt; Parser::tryType(Lexer::Token::Type type)
 149 {
 150     if (auto token = m_lexer.consumeToken()) {
 151         if (token-&gt;type == type)
 152             return token;
 153         m_lexer.unconsumeToken(Lexer::Token(*token));
 154     }
 155     return WTF::nullopt;
 156 }
 157 
 158 Optional&lt;Lexer::Token&gt; Parser::tryTypes(Vector&lt;Lexer::Token::Type&gt; types)
 159 {
 160     if (auto token = m_lexer.consumeToken()) {
 161         if (std::find(types.begin(), types.end(), token-&gt;type) != types.end())
 162             return token;
 163         m_lexer.unconsumeToken(Lexer::Token(*token));
 164     }
 165     return WTF::nullopt;
 166 }
 167 
 168 auto Parser::consumeType(Lexer::Token::Type type) -&gt; Expected&lt;Lexer::Token, Error&gt;
 169 {
 170     if (auto token = m_lexer.consumeToken()) {
 171         if (token-&gt;type == type)
 172             return *token;
 173         return fail(makeString(&quot;Unexpected token (expected &quot;, Lexer::Token::typeName(type), &quot; got &quot;, Lexer::Token::typeName(token-&gt;type), &quot;)&quot;));
 174     }
 175     return fail(makeString(&quot;Cannot consume token (expected &quot;, Lexer::Token::typeName(type), &quot;)&quot;));
 176 }
 177 
 178 auto Parser::consumeTypes(Vector&lt;Lexer::Token::Type&gt; types) -&gt; Expected&lt;Lexer::Token, Error&gt;
 179 {
 180     auto buildExpectedString = [&amp;]() -&gt; String {
 181         StringBuilder builder;
 182         builder.append(&quot;[&quot;);
 183         for (unsigned i = 0; i &lt; types.size(); ++i) {
 184             if (i &gt; 0)
 185                 builder.append(&quot;, &quot;);
 186             builder.append(Lexer::Token::typeName(types[i]));
 187         }
 188         builder.append(&quot;]&quot;);
 189         return builder.toString();
 190     };
 191 
 192     if (auto token = m_lexer.consumeToken()) {
 193         if (std::find(types.begin(), types.end(), token-&gt;type) != types.end())
 194             return *token;
 195         return fail(makeString(&quot;Unexpected token (expected one of &quot;, buildExpectedString(), &quot; got &quot;, Lexer::Token::typeName(token-&gt;type), &quot;)&quot;));
 196     }
 197     return fail(makeString(&quot;Cannot consume token (expected &quot;, buildExpectedString(), &quot;)&quot;));
 198 }
 199 
 200 static int digitValue(UChar character)
 201 {
 202     if (character &gt;= &#39;0&#39; &amp;&amp; character &lt;= &#39;9&#39;)
 203         return character - &#39;0&#39;;
 204     if (character &gt;= &#39;a&#39; &amp;&amp; character &lt;= &#39;f&#39;)
 205         return character - &#39;a&#39; + 10;
 206     return character - &#39;A&#39; + 10;
 207 }
 208 
 209 static Expected&lt;int, Parser::Error&gt; intLiteralToInt(StringView text)
 210 {
 211     bool negate = false;
 212     if (text.startsWith(&quot;-&quot;_str)) {
 213         negate = true;
 214         text = text.substring(1);
 215     }
 216     int base = 10;
 217     if (text.startsWith(&quot;0x&quot;_str)) {
 218         text = text.substring(2);
 219         base = 16;
 220     }
 221 
 222     unsigned result = 0;
 223     for (auto codePoint : text.codePoints()) {
 224         unsigned digit = digitValue(codePoint);
 225         auto previous = result;
 226         result = result * base + digit;
 227         if (result &lt; previous)
 228             return Unexpected&lt;Parser::Error&gt;(Parser::Error(makeString(&quot;int literal &quot;, text, &quot; is out of bounds&quot;)));
 229     }
 230     if (negate) {
 231         static_assert(std::numeric_limits&lt;long long int&gt;::min() &lt; std::numeric_limits&lt;int&gt;::min(), &quot;long long needs to be bigger than an int&quot;);
 232         if (static_cast&lt;long long&gt;(result) &gt; std::abs(static_cast&lt;long long&gt;(std::numeric_limits&lt;int&gt;::min())))
 233             return Unexpected&lt;Parser::Error&gt;(Parser::Error(makeString(&quot;int literal &quot;, text, &quot; is out of bounds&quot;)));
 234         return { static_cast&lt;int&gt;(static_cast&lt;long long&gt;(result) * 1) };
 235     }
 236     if (result &gt; static_cast&lt;unsigned&gt;(std::numeric_limits&lt;int&gt;::max()))
 237         return Unexpected&lt;Parser::Error&gt;(Parser::Error(makeString(&quot;int literal &quot;, text, &quot; is out of bounds&quot;)));
 238     return { static_cast&lt;int&gt;(result) };
 239 }
 240 
 241 static Expected&lt;unsigned, Parser::Error&gt; uintLiteralToUint(StringView text)
 242 {
 243     unsigned base = 10;
 244     if (text.startsWith(&quot;0x&quot;_str)) {
 245         text = text.substring(2);
 246         base = 16;
 247     }
 248     ASSERT(text.endsWith(&quot;u&quot;));
 249     text = text.substring(0, text.length() - 1);
 250     unsigned result = 0;
 251     for (auto codePoint : text.codePoints()) {
 252         unsigned digit = digitValue(codePoint);
 253         auto previous = result;
 254         result = result * base + digit;
 255         if (result &lt; previous)
 256             return Unexpected&lt;Parser::Error&gt;(Parser::Error(makeString(&quot;uint literal &quot;, text, &quot; is out of bounds&quot;)));
 257     }
 258     return { result };
 259 }
 260 
 261 static Expected&lt;float, Parser::Error&gt; floatLiteralToFloat(StringView text)
 262 {
 263     size_t parsedLength;
 264     auto result = parseDouble(text, parsedLength);
 265     if (parsedLength != text.length())
 266         return Unexpected&lt;Parser::Error&gt;(Parser::Error(makeString(&quot;Cannot parse float &quot;, text)));
 267     return static_cast&lt;float&gt;(result);
 268 }
 269 
 270 auto Parser::consumeIntegralLiteral() -&gt; Expected&lt;Variant&lt;int, unsigned&gt;, Error&gt;
 271 {
 272     auto integralLiteralToken = consumeTypes({ Lexer::Token::Type::IntLiteral, Lexer::Token::Type::UintLiteral });
 273     if (!integralLiteralToken)
 274         return Unexpected&lt;Error&gt;(integralLiteralToken.error());
 275 
 276     switch (integralLiteralToken-&gt;type) {
 277     case Lexer::Token::Type::IntLiteral: {
 278         auto result = intLiteralToInt(integralLiteralToken-&gt;stringView);
 279         if (result)
 280             return {{ *result }};
 281         return Unexpected&lt;Error&gt;(result.error());
 282     }
 283     default: {
 284         ASSERT(integralLiteralToken-&gt;type == Lexer::Token::Type::UintLiteral);
 285         auto result = uintLiteralToUint(integralLiteralToken-&gt;stringView);
 286         if (result)
 287             return {{ *result }};
 288         return Unexpected&lt;Error&gt;(result.error());
 289     }
 290     }
 291 }
 292 
 293 auto Parser::consumeNonNegativeIntegralLiteral() -&gt; Expected&lt;unsigned, Error&gt;
 294 {
 295     auto integralLiteral = consumeIntegralLiteral();
 296     if (!integralLiteral)
 297         return Unexpected&lt;Error&gt;(integralLiteral.error());
 298     auto result = WTF::visit(WTF::makeVisitor([](int x) -&gt; Optional&lt;unsigned&gt; {
 299         if (x &lt; 0)
 300             return WTF::nullopt;
 301         return x;
 302     }, [](unsigned x) -&gt; Optional&lt;unsigned&gt; {
 303         return x;
 304     }), *integralLiteral);
 305     if (result)
 306         return *result;
 307     return fail(&quot;int literal is negative&quot;_str);
 308 }
 309 
 310 static Expected&lt;unsigned, Parser::Error&gt; recognizeSimpleUnsignedInteger(StringView stringView)
 311 {
 312     unsigned result = 0;
 313     if (stringView.length() &lt; 1)
 314         return Unexpected&lt;Parser::Error&gt;(Parser::Error(makeString(&quot;Simple unsigned literal &quot;, stringView, &quot; is too short&quot;)));
 315     for (auto codePoint : stringView.codePoints()) {
 316         if (codePoint &lt; &#39;0&#39; || codePoint &gt; &#39;9&#39;)
 317             return Unexpected&lt;Parser::Error&gt;(Parser::Error(makeString(&quot;Simple unsigned literal &quot;, stringView, &quot; isn&#39;t of the form [0-9]+&quot;)));
 318         auto previous = result;
 319         result = result * 10 + (codePoint - &#39;0&#39;);
 320         if (result &lt; previous)
 321             return Unexpected&lt;Parser::Error&gt;(Parser::Error(makeString(&quot;Simple unsigned literal &quot;, stringView, &quot; is out of bounds&quot;)));
 322     }
 323     return result;
 324 }
 325 
 326 auto Parser::parseConstantExpression() -&gt; Expected&lt;AST::ConstantExpression, Error&gt;
 327 {
 328     auto type = consumeTypes({
 329         Lexer::Token::Type::IntLiteral,
 330         Lexer::Token::Type::UintLiteral,
 331         Lexer::Token::Type::FloatLiteral,
 332         Lexer::Token::Type::Null,
 333         Lexer::Token::Type::True,
 334         Lexer::Token::Type::False,
 335         Lexer::Token::Type::Identifier,
 336     });
 337     if (!type)
 338         return Unexpected&lt;Error&gt;(type.error());
 339 
 340     switch (type-&gt;type) {
 341     case Lexer::Token::Type::IntLiteral: {
 342         auto value = intLiteralToInt(type-&gt;stringView);
 343         if (!value)
 344             return Unexpected&lt;Error&gt;(value.error());
 345         return {{ AST::IntegerLiteral(WTFMove(*type), *value) }};
 346     }
 347     case Lexer::Token::Type::UintLiteral: {
 348         auto value = uintLiteralToUint(type-&gt;stringView);
 349         if (!value)
 350             return Unexpected&lt;Error&gt;(value.error());
 351         return {{ AST::UnsignedIntegerLiteral(WTFMove(*type), *value) }};
 352     }
 353     case Lexer::Token::Type::FloatLiteral: {
 354         auto value = floatLiteralToFloat(type-&gt;stringView);
 355         if (!value)
 356             return Unexpected&lt;Error&gt;(value.error());
 357         return {{ AST::FloatLiteral(WTFMove(*type), *value) }};
 358     }
 359     case Lexer::Token::Type::Null:
 360         return { AST::NullLiteral(WTFMove(*type)) };
 361     case Lexer::Token::Type::True:
 362         return { AST::BooleanLiteral(WTFMove(*type), true) };
 363     case Lexer::Token::Type::False:
 364         return { AST::BooleanLiteral(WTFMove(*type), false) };
 365     default: {
 366         ASSERT(type-&gt;type == Lexer::Token::Type::Identifier);
 367         auto origin = consumeType(Lexer::Token::Type::FullStop);
 368         if (!origin)
 369             return Unexpected&lt;Error&gt;(origin.error());
 370         auto next = consumeType(Lexer::Token::Type::Identifier);
 371         if (!next)
 372             return Unexpected&lt;Error&gt;(next.error());
 373         return { AST::EnumerationMemberLiteral(WTFMove(*origin), type-&gt;stringView.toString(), next-&gt;stringView.toString()) };
 374     }
 375     }
 376 }
 377 
 378 auto Parser::parseTypeArgument() -&gt; Expected&lt;AST::TypeArgument, Error&gt;
 379 {
 380     auto constantExpression = backtrackingScope&lt;Expected&lt;AST::ConstantExpression, Error&gt;&gt;([&amp;]() {
 381         return parseConstantExpression();
 382     });
 383     if (constantExpression)
 384         return AST::TypeArgument(WTFMove(*constantExpression));
 385     auto result = consumeType(Lexer::Token::Type::Identifier);
 386     if (!result)
 387         return Unexpected&lt;Error&gt;(result.error());
 388     return AST::TypeArgument(makeUniqueRef&lt;AST::TypeReference&gt;(Lexer::Token(*result), result-&gt;stringView.toString(), AST::TypeArguments()));
 389 }
 390 
 391 auto Parser::parseTypeArguments() -&gt; Expected&lt;AST::TypeArguments, Error&gt;
 392 {
 393     auto typeArguments = backtrackingScope&lt;Optional&lt;AST::TypeArguments&gt;&gt;([&amp;]() -&gt; Optional&lt;AST::TypeArguments&gt; {
 394         auto lessThanSign = consumeType(Lexer::Token::Type::LessThanSign);
 395         if (!lessThanSign)
 396             return WTF::nullopt;
 397         AST::TypeArguments typeArguments;
 398         auto typeArgument = parseTypeArgument();
 399         if (!typeArgument)
 400             return WTF::nullopt;
 401         typeArguments.append(WTFMove(*typeArgument));
 402         while (tryType(Lexer::Token::Type::Comma)) {
 403             auto typeArgument = parseTypeArgument();
 404             if (!typeArgument)
 405                 return WTF::nullopt;
 406             typeArguments.append(WTFMove(*typeArgument));
 407         }
 408         auto greaterThanSign = consumeType(Lexer::Token::Type::GreaterThanSign);
 409         if (!greaterThanSign)
 410             return WTF::nullopt;
 411         return typeArguments;
 412     });
 413     if (typeArguments)
 414         return WTFMove(*typeArguments);
 415 
 416     typeArguments = backtrackingScope&lt;Optional&lt;AST::TypeArguments&gt;&gt;([&amp;]() -&gt; Optional&lt;AST::TypeArguments&gt; {
 417         auto lessThanSign = consumeType(Lexer::Token::Type::LessThanSign);
 418         if (!lessThanSign)
 419             return WTF::nullopt;
 420         auto greaterThanSign = consumeType(Lexer::Token::Type::GreaterThanSign);
 421         if (!greaterThanSign)
 422             return WTF::nullopt;
 423         return {{ }};
 424     });
 425     if (typeArguments)
 426         return WTFMove(*typeArguments);
 427 
 428     return AST::TypeArguments();
 429 }
 430 
 431 auto Parser::parseTypeSuffixAbbreviated() -&gt; Expected&lt;TypeSuffixAbbreviated, Error&gt;
 432 {
 433     auto token = consumeTypes({ Lexer::Token::Type::Star, Lexer::Token::Type::SquareBracketPair, Lexer::Token::Type::LeftSquareBracket });
 434     if (!token)
 435         return Unexpected&lt;Error&gt;(token.error());
 436     if (token-&gt;type == Lexer::Token::Type::LeftSquareBracket) {
 437         auto numElements = consumeNonNegativeIntegralLiteral();
 438         if (!numElements)
 439             return Unexpected&lt;Error&gt;(numElements.error());
 440         auto rightSquareBracket = consumeType(Lexer::Token::Type::RightSquareBracket);
 441         if (!rightSquareBracket)
 442             return Unexpected&lt;Error&gt;(rightSquareBracket.error());
 443         return {{ *token, *numElements }};
 444     }
 445     return {{ *token, WTF::nullopt }};
 446 }
 447 
 448 auto Parser::parseTypeSuffixNonAbbreviated() -&gt; Expected&lt;TypeSuffixNonAbbreviated, Error&gt;
 449 {
 450     auto token = consumeTypes({ Lexer::Token::Type::Star, Lexer::Token::Type::SquareBracketPair, Lexer::Token::Type::LeftSquareBracket });
 451     if (!token)
 452         return Unexpected&lt;Error&gt;(token.error());
 453     if (token-&gt;type == Lexer::Token::Type::LeftSquareBracket) {
 454         auto numElements = consumeNonNegativeIntegralLiteral();
 455         if (!numElements)
 456             return Unexpected&lt;Error&gt;(numElements.error());
 457         auto rightSquareBracket = consumeType(Lexer::Token::Type::RightSquareBracket);
 458         if (!rightSquareBracket)
 459             return Unexpected&lt;Error&gt;(rightSquareBracket.error());
 460         return {{ *token, WTF::nullopt, *numElements }};
 461     }
 462     auto addressSpaceToken = consumeTypes({ Lexer::Token::Type::Constant, Lexer::Token::Type::Device, Lexer::Token::Type::Threadgroup, Lexer::Token::Type::Thread});
 463     if (!addressSpaceToken)
 464         return Unexpected&lt;Error&gt;(addressSpaceToken.error());
 465     AST::AddressSpace addressSpace;
 466     switch (addressSpaceToken-&gt;type) {
 467     case Lexer::Token::Type::Constant:
 468         addressSpace = AST::AddressSpace::Constant;
 469         break;
 470     case Lexer::Token::Type::Device:
 471         addressSpace = AST::AddressSpace::Device;
 472         break;
 473     case Lexer::Token::Type::Threadgroup:
 474         addressSpace = AST::AddressSpace::Threadgroup;
 475         break;
 476     default:
 477         ASSERT(addressSpaceToken-&gt;type == Lexer::Token::Type::Thread);
 478         addressSpace = AST::AddressSpace::Thread;
 479         break;
 480     }
 481     return {{ *token, { addressSpace }, WTF::nullopt }};
 482 }
 483 
 484 auto Parser::parseAddressSpaceType() -&gt; Expected&lt;UniqueRef&lt;AST::UnnamedType&gt;, Error&gt;
 485 {
 486     auto addressSpaceToken = consumeTypes({ Lexer::Token::Type::Constant, Lexer::Token::Type::Device, Lexer::Token::Type::Threadgroup, Lexer::Token::Type::Thread});
 487     if (!addressSpaceToken)
 488         return Unexpected&lt;Error&gt;(addressSpaceToken.error());
 489     AST::AddressSpace addressSpace;
 490     switch (addressSpaceToken-&gt;type) {
 491     case Lexer::Token::Type::Constant:
 492         addressSpace = AST::AddressSpace::Constant;
 493         break;
 494     case Lexer::Token::Type::Device:
 495         addressSpace = AST::AddressSpace::Device;
 496         break;
 497     case Lexer::Token::Type::Threadgroup:
 498         addressSpace = AST::AddressSpace::Threadgroup;
 499         break;
 500     default:
 501         ASSERT(addressSpaceToken-&gt;type == Lexer::Token::Type::Thread);
 502         addressSpace = AST::AddressSpace::Thread;
 503         break;
 504     }
 505     auto name = consumeType(Lexer::Token::Type::Identifier);
 506     if (!name)
 507         return Unexpected&lt;Error&gt;(name.error());
 508     auto typeArguments = parseTypeArguments();
 509     if (!typeArguments)
 510         return Unexpected&lt;Error&gt;(typeArguments.error());
 511 
 512     auto constructTypeFromSuffixAbbreviated = [&amp;](const TypeSuffixAbbreviated&amp; typeSuffixAbbreviated, UniqueRef&lt;AST::UnnamedType&gt;&amp;&amp; previous) -&gt; UniqueRef&lt;AST::UnnamedType&gt; {
 513         switch (typeSuffixAbbreviated.token.type) {
 514         case Lexer::Token::Type::Star:
 515             return { makeUniqueRef&lt;AST::PointerType&gt;(Lexer::Token(typeSuffixAbbreviated.token), addressSpace, WTFMove(previous)) };
 516         case Lexer::Token::Type::SquareBracketPair:
 517             return { makeUniqueRef&lt;AST::ArrayReferenceType&gt;(Lexer::Token(typeSuffixAbbreviated.token), addressSpace, WTFMove(previous)) };
 518         default:
 519             ASSERT(typeSuffixAbbreviated.token.type == Lexer::Token::Type::LeftSquareBracket);
 520             return { makeUniqueRef&lt;AST::ArrayType&gt;(Lexer::Token(typeSuffixAbbreviated.token), WTFMove(previous), *typeSuffixAbbreviated.numElements) };
 521         }
 522     };
 523 
 524     auto firstTypeSuffixAbbreviated = parseTypeSuffixAbbreviated();
 525     if (!firstTypeSuffixAbbreviated)
 526         return Unexpected&lt;Error&gt;(firstTypeSuffixAbbreviated.error());
 527     UniqueRef&lt;AST::UnnamedType&gt; result = makeUniqueRef&lt;AST::TypeReference&gt;(WTFMove(*addressSpaceToken), name-&gt;stringView.toString(), WTFMove(*typeArguments));
 528     auto next = constructTypeFromSuffixAbbreviated(*firstTypeSuffixAbbreviated, WTFMove(result));
 529     result = WTFMove(next);
 530     while (true) {
 531         auto typeSuffixAbbreviated = backtrackingScope&lt;Expected&lt;TypeSuffixAbbreviated, Error&gt;&gt;([&amp;]() {
 532             return parseTypeSuffixAbbreviated();
 533         });
 534         if (!typeSuffixAbbreviated)
 535             break;
 536         // FIXME: The nesting here might be in the wrong order.
 537         next = constructTypeFromSuffixAbbreviated(*typeSuffixAbbreviated, WTFMove(result));
 538         result = WTFMove(next);
 539     }
 540 
 541     return WTFMove(result);
 542 }
 543 
 544 auto Parser::parseNonAddressSpaceType() -&gt; Expected&lt;UniqueRef&lt;AST::UnnamedType&gt;, Error&gt;
 545 {
 546     auto origin = peek();
 547     if (!origin)
 548         return Unexpected&lt;Error&gt;(origin.error());
 549     auto name = consumeType(Lexer::Token::Type::Identifier);
 550     if (!name)
 551         return Unexpected&lt;Error&gt;(name.error());
 552     auto typeArguments = parseTypeArguments();
 553     if (!typeArguments)
 554         return Unexpected&lt;Error&gt;(typeArguments.error());
 555 
 556     auto constructTypeFromSuffixNonAbbreviated = [&amp;](const TypeSuffixNonAbbreviated&amp; typeSuffixNonAbbreviated, UniqueRef&lt;AST::UnnamedType&gt;&amp;&amp; previous) -&gt; UniqueRef&lt;AST::UnnamedType&gt; {
 557         switch (typeSuffixNonAbbreviated.token.type) {
 558         case Lexer::Token::Type::Star:
 559             return { makeUniqueRef&lt;AST::PointerType&gt;(Lexer::Token(typeSuffixNonAbbreviated.token), *typeSuffixNonAbbreviated.addressSpace, WTFMove(previous)) };
 560         case Lexer::Token::Type::SquareBracketPair:
 561             return { makeUniqueRef&lt;AST::ArrayReferenceType&gt;(Lexer::Token(typeSuffixNonAbbreviated.token), *typeSuffixNonAbbreviated.addressSpace, WTFMove(previous)) };
 562         default:
 563             ASSERT(typeSuffixNonAbbreviated.token.type == Lexer::Token::Type::LeftSquareBracket);
 564             return { makeUniqueRef&lt;AST::ArrayType&gt;(Lexer::Token(typeSuffixNonAbbreviated.token), WTFMove(previous), *typeSuffixNonAbbreviated.numElements) };
 565         }
 566     };
 567 
 568     UniqueRef&lt;AST::UnnamedType&gt; result = makeUniqueRef&lt;AST::TypeReference&gt;(WTFMove(*origin), name-&gt;stringView.toString(), WTFMove(*typeArguments));
 569     while (true) {
 570         auto typeSuffixNonAbbreviated = backtrackingScope&lt;Expected&lt;TypeSuffixNonAbbreviated, Error&gt;&gt;([&amp;]() {
 571             return parseTypeSuffixNonAbbreviated();
 572         });
 573         if (!typeSuffixNonAbbreviated)
 574             break;
 575         // FIXME: The nesting here might be in the wrong order.
 576         auto next = constructTypeFromSuffixNonAbbreviated(*typeSuffixNonAbbreviated, WTFMove(result));
 577         result = WTFMove(next);
 578     }
 579 
 580     return WTFMove(result);
 581 }
 582 
 583 auto Parser::parseType() -&gt; Expected&lt;UniqueRef&lt;AST::UnnamedType&gt;, Error&gt;
 584 {
 585     auto type = backtrackingScope&lt;Expected&lt;UniqueRef&lt;AST::UnnamedType&gt;, Error&gt;&gt;([&amp;]() {
 586         return parseAddressSpaceType();
 587     });
 588     if (type)
 589         return type;
 590 
 591     type = backtrackingScope&lt;Expected&lt;UniqueRef&lt;AST::UnnamedType&gt;, Error&gt;&gt;([&amp;]() {
 592         return parseNonAddressSpaceType();
 593     });
 594     if (type)
 595         return type;
 596 
 597     return Unexpected&lt;Error&gt;(type.error());
 598 }
 599 
 600 auto Parser::parseTypeDefinition() -&gt; Expected&lt;AST::TypeDefinition, Error&gt;
 601 {
 602     auto origin = consumeType(Lexer::Token::Type::Typedef);
 603     if (!origin)
 604         return Unexpected&lt;Error&gt;(origin.error());
 605     auto name = consumeType(Lexer::Token::Type::Identifier);
 606     if (!name)
 607         return Unexpected&lt;Error&gt;(name.error());
 608     auto equals = consumeType(Lexer::Token::Type::EqualsSign);
 609     if (!equals)
 610         return Unexpected&lt;Error&gt;(equals.error());
 611     auto type = parseType();
 612     if (!type)
 613         return Unexpected&lt;Error&gt;(type.error());
 614     auto semicolon = consumeType(Lexer::Token::Type::Semicolon);
 615     if (!semicolon)
 616         return Unexpected&lt;Error&gt;(semicolon.error());
 617     return AST::TypeDefinition(WTFMove(*origin), name-&gt;stringView.toString(), WTFMove(*type));
 618 }
 619 
 620 auto Parser::parseBuiltInSemantic() -&gt; Expected&lt;AST::BuiltInSemantic, Error&gt;
 621 {
 622     auto origin = consumeTypes({
 623         Lexer::Token::Type::SVInstanceID,
 624         Lexer::Token::Type::SVVertexID,
 625         Lexer::Token::Type::PSize,
 626         Lexer::Token::Type::SVPosition,
 627         Lexer::Token::Type::SVIsFrontFace,
 628         Lexer::Token::Type::SVSampleIndex,
 629         Lexer::Token::Type::SVInnerCoverage,
 630         Lexer::Token::Type::SVTarget,
 631         Lexer::Token::Type::SVDepth,
 632         Lexer::Token::Type::SVCoverage,
 633         Lexer::Token::Type::SVDispatchThreadID,
 634         Lexer::Token::Type::SVGroupID,
 635         Lexer::Token::Type::SVGroupIndex,
 636         Lexer::Token::Type::SVGroupThreadID});
 637     if (!origin)
 638         return Unexpected&lt;Error&gt;(origin.error());
 639 
 640     switch (origin-&gt;type) {
 641     case Lexer::Token::Type::SVInstanceID:
 642         return AST::BuiltInSemantic(WTFMove(*origin), AST::BuiltInSemantic::Variable::SVInstanceID);
 643     case Lexer::Token::Type::SVVertexID:
 644         return AST::BuiltInSemantic(WTFMove(*origin), AST::BuiltInSemantic::Variable::SVVertexID);
 645     case Lexer::Token::Type::PSize:
 646         return AST::BuiltInSemantic(WTFMove(*origin), AST::BuiltInSemantic::Variable::PSize);
 647     case Lexer::Token::Type::SVPosition:
 648         return AST::BuiltInSemantic(WTFMove(*origin), AST::BuiltInSemantic::Variable::SVPosition);
 649     case Lexer::Token::Type::SVIsFrontFace:
 650         return AST::BuiltInSemantic(WTFMove(*origin), AST::BuiltInSemantic::Variable::SVIsFrontFace);
 651     case Lexer::Token::Type::SVSampleIndex:
 652         return AST::BuiltInSemantic(WTFMove(*origin), AST::BuiltInSemantic::Variable::SVSampleIndex);
 653     case Lexer::Token::Type::SVInnerCoverage:
 654         return AST::BuiltInSemantic(WTFMove(*origin), AST::BuiltInSemantic::Variable::SVInnerCoverage);
 655     case Lexer::Token::Type::SVTarget: {
 656         auto target = consumeNonNegativeIntegralLiteral();
 657         if (!target)
 658             return Unexpected&lt;Error&gt;(target.error());
 659         return AST::BuiltInSemantic(WTFMove(*origin), AST::BuiltInSemantic::Variable::SVTarget, *target);
 660     }
 661     case Lexer::Token::Type::SVDepth:
 662         return AST::BuiltInSemantic(WTFMove(*origin), AST::BuiltInSemantic::Variable::SVDepth);
 663     case Lexer::Token::Type::SVCoverage:
 664         return AST::BuiltInSemantic(WTFMove(*origin), AST::BuiltInSemantic::Variable::SVCoverage);
 665     case Lexer::Token::Type::SVDispatchThreadID:
 666         return AST::BuiltInSemantic(WTFMove(*origin), AST::BuiltInSemantic::Variable::SVDispatchThreadID);
 667     case Lexer::Token::Type::SVGroupID:
 668         return AST::BuiltInSemantic(WTFMove(*origin), AST::BuiltInSemantic::Variable::SVGroupID);
 669     case Lexer::Token::Type::SVGroupIndex:
 670         return AST::BuiltInSemantic(WTFMove(*origin), AST::BuiltInSemantic::Variable::SVGroupIndex);
 671     default:
 672         ASSERT(origin-&gt;type == Lexer::Token::Type::SVGroupThreadID);
 673         return AST::BuiltInSemantic(WTFMove(*origin), AST::BuiltInSemantic::Variable::SVGroupThreadID);
 674     }
 675 }
 676 
 677 auto Parser::parseResourceSemantic() -&gt; Expected&lt;AST::ResourceSemantic, Error&gt;
 678 {
 679     auto origin = consumeType(Lexer::Token::Type::Register);
 680     if (!origin)
 681         return Unexpected&lt;Error&gt;(origin.error());
 682 
 683     auto leftParenthesis = consumeType(Lexer::Token::Type::LeftParenthesis);
 684     if (!leftParenthesis)
 685         return Unexpected&lt;Error&gt;(leftParenthesis.error());
 686 
 687     auto info = consumeType(Lexer::Token::Type::Identifier);
 688     if (!info)
 689         return Unexpected&lt;Error&gt;(info.error());
 690     if (info-&gt;stringView.length() &lt; 2 || (info-&gt;stringView[0] != &#39;u&#39;
 691         &amp;&amp; info-&gt;stringView[0] != &#39;t&#39;
 692         &amp;&amp; info-&gt;stringView[0] != &#39;b&#39;
 693         &amp;&amp; info-&gt;stringView[0] != &#39;s&#39;))
 694         return Unexpected&lt;Error&gt;(Error(makeString(info-&gt;stringView.substring(0, 1), &quot; is not a known resource type (&#39;u&#39;, &#39;t&#39;, &#39;b&#39;, or &#39;s&#39;)&quot;)));
 695 
 696     AST::ResourceSemantic::Mode mode;
 697     switch (info-&gt;stringView[0]) {
 698     case &#39;u&#39;:
 699         mode = AST::ResourceSemantic::Mode::UnorderedAccessView;
 700         break;
 701     case &#39;t&#39;:
 702         mode = AST::ResourceSemantic::Mode::Texture;
 703         break;
 704     case &#39;b&#39;:
 705         mode = AST::ResourceSemantic::Mode::Buffer;
 706         break;
 707     case &#39;s&#39;:
 708         mode = AST::ResourceSemantic::Mode::Sampler;
 709         break;
 710     }
 711 
 712     auto index = recognizeSimpleUnsignedInteger(info-&gt;stringView.substring(1));
 713     if (!index)
 714         return Unexpected&lt;Error&gt;(index.error());
 715 
 716     unsigned space = 0;
 717     if (tryType(Lexer::Token::Type::Comma)) {
 718         auto spaceToken = consumeType(Lexer::Token::Type::Identifier);
 719         if (!spaceToken)
 720             return Unexpected&lt;Error&gt;(spaceToken.error());
 721         auto prefix = &quot;space&quot;_str;
 722         if (!spaceToken-&gt;stringView.startsWith(StringView(prefix)))
 723             return Unexpected&lt;Error&gt;(Error(makeString(&quot;Second argument to resource semantic &quot;, spaceToken-&gt;stringView, &quot; needs be of the form &#39;space0&#39;&quot;)));
 724         if (spaceToken-&gt;stringView.length() &lt;= prefix.length())
 725             return Unexpected&lt;Error&gt;(Error(makeString(&quot;Second argument to resource semantic &quot;, spaceToken-&gt;stringView, &quot; needs be of the form &#39;space0&#39;&quot;)));
 726         auto spaceValue = recognizeSimpleUnsignedInteger(spaceToken-&gt;stringView.substring(prefix.length()));
 727         if (!spaceValue)
 728             return Unexpected&lt;Error&gt;(spaceValue.error());
 729         space = *spaceValue;
 730     }
 731 
 732     auto rightParenthesis = consumeType(Lexer::Token::Type::RightParenthesis);
 733     if (!rightParenthesis)
 734         return Unexpected&lt;Error&gt;(rightParenthesis.error());
 735 
 736     return AST::ResourceSemantic(WTFMove(*origin), mode, *index, space);
 737 }
 738 
 739 auto Parser::parseSpecializationConstantSemantic() -&gt; Expected&lt;AST::SpecializationConstantSemantic, Error&gt;
 740 {
 741     auto origin = consumeType(Lexer::Token::Type::Specialized);
 742     if (!origin)
 743         return Unexpected&lt;Error&gt;(origin.error());
 744     return AST::SpecializationConstantSemantic(WTFMove(*origin));
 745 }
 746 
 747 auto Parser::parseStageInOutSemantic() -&gt; Expected&lt;AST::StageInOutSemantic, Error&gt;
 748 {
 749     auto origin = consumeType(Lexer::Token::Type::Attribute);
 750     if (!origin)
 751         return Unexpected&lt;Error&gt;(origin.error());
 752 
 753     auto leftParenthesis = consumeType(Lexer::Token::Type::LeftParenthesis);
 754     if (!leftParenthesis)
 755         return Unexpected&lt;Error&gt;(leftParenthesis.error());
 756 
 757     auto index = consumeNonNegativeIntegralLiteral();
 758     if (!index)
 759         return Unexpected&lt;Error&gt;(index.error());
 760 
 761     auto rightParenthesis = consumeType(Lexer::Token::Type::RightParenthesis);
 762     if (!rightParenthesis)
 763         return Unexpected&lt;Error&gt;(rightParenthesis.error());
 764 
 765     return AST::StageInOutSemantic(WTFMove(*origin), *index);
 766 }
 767 
 768 auto Parser::parseSemantic() -&gt; Expected&lt;AST::Semantic, Error&gt;
 769 {
 770     auto builtInSemantic = backtrackingScope&lt;Expected&lt;AST::BuiltInSemantic, Error&gt;&gt;([&amp;]() {
 771         return parseBuiltInSemantic();
 772     });
 773     if (builtInSemantic)
 774         return AST::Semantic(WTFMove(*builtInSemantic));
 775 
 776     auto resourceSemantic = backtrackingScope&lt;Expected&lt;AST::ResourceSemantic, Error&gt;&gt;([&amp;]() {
 777         return parseResourceSemantic();
 778     });
 779     if (resourceSemantic)
 780         return AST::Semantic(WTFMove(*resourceSemantic));
 781 
 782     auto specializationConstantSemantic = backtrackingScope&lt;Expected&lt;AST::SpecializationConstantSemantic, Error&gt;&gt;([&amp;]() {
 783         return parseSpecializationConstantSemantic();
 784     });
 785     if (specializationConstantSemantic)
 786         return AST::Semantic(WTFMove(*specializationConstantSemantic));
 787 
 788     auto stageInOutSemantic = backtrackingScope&lt;Expected&lt;AST::StageInOutSemantic, Error&gt;&gt;([&amp;]() {
 789         return parseStageInOutSemantic();
 790     });
 791     if (stageInOutSemantic)
 792         return AST::Semantic(WTFMove(*stageInOutSemantic));
 793 
 794     return Unexpected&lt;Error&gt;(stageInOutSemantic.error());
 795 }
 796 AST::Qualifiers Parser::parseQualifiers()
 797 {
 798     AST::Qualifiers qualifiers;
 799     while (true) {
 800         if (auto next = tryType(Lexer::Token::Type::Qualifier)) {
 801             if (&quot;nointerpolation&quot; == next-&gt;stringView)
 802                 qualifiers.append(AST::Qualifier::Nointerpolation);
 803             else if (&quot;noperspective&quot; == next-&gt;stringView)
 804                 qualifiers.append(AST::Qualifier::Noperspective);
 805             else if (&quot;uniform&quot; == next-&gt;stringView)
 806                 qualifiers.append(AST::Qualifier::Uniform);
 807             else if (&quot;centroid&quot; == next-&gt;stringView)
 808                 qualifiers.append(AST::Qualifier::Centroid);
 809             else {
 810                 ASSERT(&quot;sample&quot; == next-&gt;stringView);
 811                 qualifiers.append(AST::Qualifier::Sample);
 812             }
 813         } else
 814             break;
 815     }
 816     return qualifiers;
 817 }
 818 
 819 auto Parser::parseStructureElement() -&gt; Expected&lt;AST::StructureElement, Error&gt;
 820 {
 821     auto origin = peek();
 822     if (!origin)
 823         return Unexpected&lt;Error&gt;(origin.error());
 824 
 825     AST::Qualifiers qualifiers = parseQualifiers();
 826 
 827     auto type = parseType();
 828     if (!type)
 829         return Unexpected&lt;Error&gt;(type.error());
 830 
 831     auto name = consumeType(Lexer::Token::Type::Identifier);
 832     if (!name)
 833         return Unexpected&lt;Error&gt;(name.error());
 834 
 835     if (tryType(Lexer::Token::Type::Colon)) {
 836         auto semantic = parseSemantic();
 837         if (!semantic)
 838             return Unexpected&lt;Error&gt;(semantic.error());
 839 
 840         auto semicolon = consumeType(Lexer::Token::Type::Semicolon);
 841         if (!semicolon)
 842             return Unexpected&lt;Error&gt;(semicolon.error());
 843 
 844         return AST::StructureElement(WTFMove(*origin), WTFMove(qualifiers), WTFMove(*type), name-&gt;stringView.toString(), WTFMove(*semantic));
 845     }
 846 
 847     auto semicolon = consumeType(Lexer::Token::Type::Semicolon);
 848     if (!semicolon)
 849         return Unexpected&lt;Error&gt;(semicolon.error());
 850 
 851     return AST::StructureElement(WTFMove(*origin), WTFMove(qualifiers), WTFMove(*type), name-&gt;stringView.toString(), WTF::nullopt);
 852 }
 853 
 854 auto Parser::parseStructureDefinition() -&gt; Expected&lt;AST::StructureDefinition, Error&gt;
 855 {
 856     auto origin = consumeType(Lexer::Token::Type::Struct);
 857     if (!origin)
 858         return Unexpected&lt;Error&gt;(origin.error());
 859 
 860     auto name = consumeType(Lexer::Token::Type::Identifier);
 861     if (!name)
 862         return Unexpected&lt;Error&gt;(name.error());
 863 
 864     auto leftCurlyBracket = consumeType(Lexer::Token::Type::LeftCurlyBracket);
 865     if (!leftCurlyBracket)
 866         return Unexpected&lt;Error&gt;(leftCurlyBracket.error());
 867 
 868     AST::StructureElements structureElements;
 869     while (true) {
 870         auto structureElement = backtrackingScope&lt;Expected&lt;AST::StructureElement, Error&gt;&gt;([&amp;]() {
 871             return parseStructureElement();
 872         });
 873         if (structureElement)
 874             structureElements.append(WTFMove(*structureElement));
 875         else
 876             break;
 877     }
 878 
 879     auto rightCurlyBracket = consumeType(Lexer::Token::Type::RightCurlyBracket);
 880     if (!rightCurlyBracket)
 881         return Unexpected&lt;Error&gt;(rightCurlyBracket.error());
 882 
 883     return AST::StructureDefinition(WTFMove(*origin), name-&gt;stringView.toString(), WTFMove(structureElements));
 884 }
 885 
 886 auto Parser::parseEnumerationDefinition() -&gt; Expected&lt;AST::EnumerationDefinition, Error&gt;
 887 {
 888     auto origin = consumeType(Lexer::Token::Type::Enum);
 889     if (!origin)
 890         return Unexpected&lt;Error&gt;(origin.error());
 891 
 892     auto name = consumeType(Lexer::Token::Type::Identifier);
 893     if (!name)
 894         return Unexpected&lt;Error&gt;(name.error());
 895 
 896     auto type = ([&amp;]() -&gt; Expected&lt;UniqueRef&lt;AST::UnnamedType&gt;, Error&gt; {
 897         if (tryType(Lexer::Token::Type::Colon)) {
 898             auto parsedType = parseType();
 899             if (!parsedType)
 900                 return Unexpected&lt;Error&gt;(parsedType.error());
 901             return WTFMove(*parsedType);
 902         }
 903         return { makeUniqueRef&lt;AST::TypeReference&gt;(Lexer::Token(*origin), &quot;int&quot;_str, AST::TypeArguments()) };
 904     })();
 905     if (!type)
 906         return Unexpected&lt;Error&gt;(type.error());
 907 
 908     auto leftCurlyBracket = consumeType(Lexer::Token::Type::LeftCurlyBracket);
 909     if (!leftCurlyBracket)
 910         return Unexpected&lt;Error&gt;(leftCurlyBracket.error());
 911 
 912     auto firstEnumerationMember = parseEnumerationMember();
 913     if (!firstEnumerationMember)
 914         return Unexpected&lt;Error&gt;(firstEnumerationMember.error());
 915 
 916     AST::EnumerationDefinition result(WTFMove(*origin), name-&gt;stringView.toString(), WTFMove(*type));
 917     auto success = result.add(WTFMove(*firstEnumerationMember));
 918     if (!success)
 919         return fail(&quot;Cannot add enumeration member&quot;_str);
 920 
 921     while (tryType(Lexer::Token::Type::Comma)) {
 922         auto member = parseEnumerationMember();
 923         if (!member)
 924             return Unexpected&lt;Error&gt;(member.error());
 925         success = result.add(WTFMove(*member));
 926         if (!success)
 927             return fail(&quot;Cannot add enumeration member&quot;_str);
 928     }
 929 
 930     auto rightCurlyBracket = consumeType(Lexer::Token::Type::RightCurlyBracket);
 931     if (!rightCurlyBracket)
 932         return Unexpected&lt;Error&gt;(rightCurlyBracket.error());
 933 
 934     return WTFMove(result);
 935 }
 936 
 937 auto Parser::parseEnumerationMember() -&gt; Expected&lt;AST::EnumerationMember, Error&gt;
 938 {
 939     auto identifier = consumeType(Lexer::Token::Type::Identifier);
 940     if (!identifier)
 941         return Unexpected&lt;Error&gt;(identifier.error());
 942     auto name = identifier-&gt;stringView.toString();
 943 
 944     if (tryType(Lexer::Token::Type::EqualsSign)) {
 945         auto constantExpression = parseConstantExpression();
 946         if (!constantExpression)
 947             return Unexpected&lt;Error&gt;(constantExpression.error());
 948         return AST::EnumerationMember(Lexer::Token(*identifier), WTFMove(name), WTFMove(*constantExpression));
 949     }
 950     return AST::EnumerationMember(Lexer::Token(*identifier), WTFMove(name));
 951 }
 952 
 953 auto Parser::parseNativeTypeDeclaration() -&gt; Expected&lt;AST::NativeTypeDeclaration, Error&gt;
 954 {
 955     auto origin = consumeType(Lexer::Token::Type::Native);
 956     if (!origin)
 957         return Unexpected&lt;Error&gt;(origin.error());
 958 
 959     auto parsedTypedef = consumeType(Lexer::Token::Type::Typedef);
 960     if (!parsedTypedef)
 961         return Unexpected&lt;Error&gt;(parsedTypedef.error());
 962 
 963     auto name = consumeType(Lexer::Token::Type::Identifier);
 964     if (!name)
 965         return Unexpected&lt;Error&gt;(name.error());
 966 
 967     auto typeArguments = parseTypeArguments();
 968     if (!typeArguments)
 969         return Unexpected&lt;Error&gt;(typeArguments.error());
 970 
 971     auto semicolon = consumeType(Lexer::Token::Type::Semicolon);
 972     if (!semicolon)
 973         return Unexpected&lt;Error&gt;(semicolon.error());
 974 
 975     return AST::NativeTypeDeclaration(WTFMove(*origin), name-&gt;stringView.toString(), WTFMove(*typeArguments));
 976 }
 977 
 978 auto Parser::parseNumThreadsFunctionAttribute() -&gt; Expected&lt;AST::NumThreadsFunctionAttribute, Error&gt;
 979 {
 980     auto origin = consumeType(Lexer::Token::Type::NumThreads);
 981     if (!origin)
 982         return Unexpected&lt;Error&gt;(origin.error());
 983 
 984     auto leftParenthesis = consumeType(Lexer::Token::Type::LeftParenthesis);
 985     if (!leftParenthesis)
 986         return Unexpected&lt;Error&gt;(leftParenthesis.error());
 987 
 988     auto width = consumeNonNegativeIntegralLiteral();
 989     if (!width)
 990         return Unexpected&lt;Error&gt;(width.error());
 991 
 992     auto comma = consumeType(Lexer::Token::Type::Comma);
 993     if (!comma)
 994         return Unexpected&lt;Error&gt;(comma.error());
 995 
 996     auto height = consumeNonNegativeIntegralLiteral();
 997     if (!height)
 998         return Unexpected&lt;Error&gt;(height.error());
 999 
1000     comma = consumeType(Lexer::Token::Type::Comma);
1001     if (!comma)
1002         return Unexpected&lt;Error&gt;(comma.error());
1003 
1004     auto depth = consumeNonNegativeIntegralLiteral();
1005     if (!depth)
1006         return Unexpected&lt;Error&gt;(depth.error());
1007 
1008     auto rightParenthesis = consumeType(Lexer::Token::Type::RightParenthesis);
1009     if (!rightParenthesis)
1010         return Unexpected&lt;Error&gt;(rightParenthesis.error());
1011 
1012     return AST::NumThreadsFunctionAttribute(WTFMove(*origin), *width, *height, *depth);
1013 }
1014 
1015 auto Parser::parseAttributeBlock() -&gt; Expected&lt;AST::AttributeBlock, Error&gt;
1016 {
1017     auto leftSquareBracket = consumeType(Lexer::Token::Type::LeftSquareBracket);
1018     if (!leftSquareBracket)
1019         return Unexpected&lt;Error&gt;(leftSquareBracket.error());
1020 
1021     AST::AttributeBlock result;
1022 
1023     while (true) {
1024         auto numThreadsFunctionAttribute = backtrackingScope&lt;Expected&lt;AST::NumThreadsFunctionAttribute, Error&gt;&gt;([&amp;]() {
1025             return parseNumThreadsFunctionAttribute();
1026         });
1027         if (numThreadsFunctionAttribute) {
1028             result.append(WTFMove(*numThreadsFunctionAttribute));
1029             continue;
1030         }
1031 
1032         break;
1033     }
1034 
1035     auto rightSquareBracket = consumeType(Lexer::Token::Type::RightSquareBracket);
1036     if (!rightSquareBracket)
1037         return Unexpected&lt;Error&gt;(rightSquareBracket.error());
1038 
1039     return WTFMove(result);
1040 }
1041 
1042 auto Parser::parseParameter() -&gt; Expected&lt;AST::VariableDeclaration, Error&gt;
1043 {
1044     auto origin = peek();
1045     if (!origin)
1046         return Unexpected&lt;Error&gt;(origin.error());
1047 
1048     AST::Qualifiers qualifiers = parseQualifiers();
1049 
1050     auto type = parseType();
1051     if (!type)
1052         return Unexpected&lt;Error&gt;(type.error());
1053 
1054     String name;
1055     if (auto token = tryType(Lexer::Token::Type::Identifier))
1056         name = token-&gt;stringView.toString();
1057 
1058     if (tryType(Lexer::Token::Type::Colon)) {
1059         auto semantic = parseSemantic();
1060         if (!semantic)
1061             return Unexpected&lt;Error&gt;(semantic.error());
1062         return AST::VariableDeclaration(WTFMove(*origin), WTFMove(qualifiers), Optional&lt;UniqueRef&lt;AST::UnnamedType&gt;&gt;(WTFMove(*type)), WTFMove(name), WTFMove(*semantic), WTF::nullopt);
1063     }
1064 
1065     return AST::VariableDeclaration(WTFMove(*origin), WTFMove(qualifiers), { WTFMove(*type) }, WTFMove(name), WTF::nullopt, WTF::nullopt);
1066 }
1067 
1068 auto Parser::parseParameters() -&gt; Expected&lt;AST::VariableDeclarations, Error&gt;
1069 {
1070     auto leftParenthesis = consumeType(Lexer::Token::Type::LeftParenthesis);
1071     if (!leftParenthesis)
1072         return Unexpected&lt;Error&gt;(leftParenthesis.error());
1073 
1074     AST::VariableDeclarations parameters;
1075     if (tryType(Lexer::Token::Type::RightParenthesis))
1076         return WTFMove(parameters);
1077 
1078     auto firstParameter = parseParameter();
1079     if (!firstParameter)
1080         return Unexpected&lt;Error&gt;(firstParameter.error());
1081     parameters.append(WTFMove(*firstParameter));
1082 
1083     while (tryType(Lexer::Token::Type::Comma)) {
1084         auto parameter = parseParameter();
1085         if (!parameter)
1086             return Unexpected&lt;Error&gt;(parameter.error());
1087         parameters.append(WTFMove(*parameter));
1088     }
1089 
1090     auto rightParenthesis = consumeType(Lexer::Token::Type::RightParenthesis);
1091     if (!rightParenthesis)
1092         return Unexpected&lt;Error&gt;(rightParenthesis.error());
1093 
1094     return WTFMove(parameters);
1095 }
1096 
1097 auto Parser::parseFunctionDefinition() -&gt; Expected&lt;AST::FunctionDefinition, Error&gt;
1098 {
1099     auto functionDeclaration = parseFunctionDeclaration();
1100     if (!functionDeclaration)
1101         return Unexpected&lt;Error&gt;(functionDeclaration.error());
1102 
1103     auto block = parseBlock();
1104     if (!block)
1105         return Unexpected&lt;Error&gt;(block.error());
1106 
1107     return AST::FunctionDefinition(WTFMove(*functionDeclaration), WTFMove(*block));
1108 }
1109 
1110 auto Parser::parseEntryPointFunctionDeclaration() -&gt; Expected&lt;AST::FunctionDeclaration, Error&gt;
1111 {
1112     auto origin = peek();
1113     if (!origin)
1114         return Unexpected&lt;Error&gt;(origin.error());
1115 
1116     AST::AttributeBlock attributeBlock;
1117     AST::EntryPointType entryPointType;
1118 
1119     auto parsedAttributeBlock = backtrackingScope&lt;Expected&lt;AST::AttributeBlock, Error&gt;&gt;([&amp;]() {
1120         return parseAttributeBlock();
1121     });
1122     if (parsedAttributeBlock) {
1123         auto compute = consumeType(Lexer::Token::Type::Compute);
1124         if (!compute)
1125             return Unexpected&lt;Error&gt;(compute.error());
1126         attributeBlock = WTFMove(*parsedAttributeBlock);
1127         entryPointType = AST::EntryPointType::Compute;
1128     } else {
1129         auto type = consumeTypes({ Lexer::Token::Type::Vertex, Lexer::Token::Type::Fragment });
1130         if (!type)
1131             return Unexpected&lt;Error&gt;(type.error());
1132 
1133         switch (origin-&gt;type) {
1134         case Lexer::Token::Type::Vertex:
1135             entryPointType = AST::EntryPointType::Vertex;
1136             break;
1137         default:
1138             ASSERT(origin-&gt;type == Lexer::Token::Type::Fragment);
1139             entryPointType = AST::EntryPointType::Fragment;
1140             break;
1141         }
1142     }
1143 
1144     auto type = parseType();
1145     if (!type)
1146         return Unexpected&lt;Error&gt;(type.error());
1147 
1148     auto name = consumeType(Lexer::Token::Type::Identifier);
1149     if (!name)
1150         return Unexpected&lt;Error&gt;(name.error());
1151 
1152     auto parameters = parseParameters();
1153     if (!parameters)
1154         return Unexpected&lt;Error&gt;(parameters.error());
1155 
1156     bool isOperator = false;
1157 
1158     if (tryType(Lexer::Token::Type::Colon)) {
1159         auto semantic = parseSemantic();
1160         if (!semantic)
1161             return Unexpected&lt;Error&gt;(semantic.error());
1162         return AST::FunctionDeclaration(WTFMove(*origin), WTFMove(attributeBlock), entryPointType, WTFMove(*type), name-&gt;stringView.toString(), WTFMove(*parameters), WTFMove(*semantic), isOperator);
1163     }
1164 
1165     return AST::FunctionDeclaration(WTFMove(*origin), WTFMove(attributeBlock), entryPointType, WTFMove(*type), name-&gt;stringView.toString(), WTFMove(*parameters), WTF::nullopt, isOperator);
1166 }
1167 
1168 auto Parser::parseRegularFunctionDeclaration() -&gt; Expected&lt;AST::FunctionDeclaration, Error&gt;
1169 {
1170     auto origin = peek();
1171     if (!origin)
1172         return Unexpected&lt;Error&gt;(origin.error());
1173 
1174     auto type = parseType();
1175     if (!type)
1176         return Unexpected&lt;Error&gt;(type.error());
1177 
1178     auto name = consumeTypes({ Lexer::Token::Type::Identifier, Lexer::Token::Type::OperatorName });
1179     if (!name)
1180         return Unexpected&lt;Error&gt;(name.error());
1181     auto isOperator = name-&gt;type == Lexer::Token::Type::OperatorName;
1182 
1183     auto parameters = parseParameters();
1184     if (!parameters)
1185         return Unexpected&lt;Error&gt;(parameters.error());
1186 
1187     if (tryType(Lexer::Token::Type::Colon)) {
1188         auto semantic = parseSemantic();
1189         if (!semantic)
1190             return Unexpected&lt;Error&gt;(semantic.error());
1191         return AST::FunctionDeclaration(WTFMove(*origin), { }, WTF::nullopt, WTFMove(*type), name-&gt;stringView.toString(), WTFMove(*parameters), WTFMove(*semantic), isOperator);
1192     }
1193 
1194     return AST::FunctionDeclaration(WTFMove(*origin), { }, WTF::nullopt, WTFMove(*type), name-&gt;stringView.toString(), WTFMove(*parameters), WTF::nullopt, isOperator);
1195 }
1196 
1197 auto Parser::parseOperatorFunctionDeclaration() -&gt; Expected&lt;AST::FunctionDeclaration, Error&gt;
1198 {
1199     auto origin = consumeType(Lexer::Token::Type::Operator);
1200     if (!origin)
1201         return Unexpected&lt;Error&gt;(origin.error());
1202 
1203     auto type = parseType();
1204     if (!type)
1205         return Unexpected&lt;Error&gt;(type.error());
1206 
1207     auto parameters = parseParameters();
1208     if (!parameters)
1209         return Unexpected&lt;Error&gt;(parameters.error());
1210 
1211     bool isOperator = true;
1212 
1213     if (tryType(Lexer::Token::Type::Colon)) {
1214         auto semantic = parseSemantic();
1215         if (!semantic)
1216             return Unexpected&lt;Error&gt;(semantic.error());
1217         return AST::FunctionDeclaration(WTFMove(*origin), { }, WTF::nullopt, WTFMove(*type), &quot;operator cast&quot;_str, WTFMove(*parameters), WTFMove(*semantic), isOperator);
1218     }
1219 
1220     return AST::FunctionDeclaration(WTFMove(*origin), { }, WTF::nullopt, WTFMove(*type), &quot;operator cast&quot;_str, WTFMove(*parameters), WTF::nullopt, isOperator);
1221 }
1222 
1223 auto Parser::parseFunctionDeclaration() -&gt; Expected&lt;AST::FunctionDeclaration, Error&gt;
1224 {
1225     auto entryPointFunctionDeclaration = backtrackingScope&lt;Expected&lt;AST::FunctionDeclaration, Error&gt;&gt;([&amp;]() {
1226         return parseEntryPointFunctionDeclaration();
1227     });
1228     if (entryPointFunctionDeclaration)
1229         return WTFMove(*entryPointFunctionDeclaration);
1230 
1231     auto regularFunctionDeclaration = backtrackingScope&lt;Expected&lt;AST::FunctionDeclaration, Error&gt;&gt;([&amp;]() {
1232         return parseRegularFunctionDeclaration();
1233     });
1234     if (regularFunctionDeclaration)
1235         return WTFMove(*regularFunctionDeclaration);
1236 
1237     auto operatorFunctionDeclaration = backtrackingScope&lt;Expected&lt;AST::FunctionDeclaration, Error&gt;&gt;([&amp;]() {
1238         return parseOperatorFunctionDeclaration();
1239     });
1240     if (operatorFunctionDeclaration)
1241         return WTFMove(*operatorFunctionDeclaration);
1242 
1243     return Unexpected&lt;Error&gt;(operatorFunctionDeclaration.error());
1244 }
1245 
1246 auto Parser::parseNativeFunctionDeclaration() -&gt; Expected&lt;AST::NativeFunctionDeclaration, Error&gt;
1247 {
1248     Optional&lt;Lexer::Token&gt; origin;
1249 
1250     auto native = consumeType(Lexer::Token::Type::Native);
1251     if (!native)
1252         return Unexpected&lt;Error&gt;(native.error());
1253     if (!origin)
1254         origin = *native;
1255 
1256     auto functionDeclaration = parseFunctionDeclaration();
1257     if (!functionDeclaration)
1258         return Unexpected&lt;Error&gt;(functionDeclaration.error());
1259 
1260     auto semicolon = consumeType(Lexer::Token::Type::Semicolon);
1261     if (!semicolon)
1262         return Unexpected&lt;Error&gt;(semicolon.error());
1263 
1264     return AST::NativeFunctionDeclaration(WTFMove(*functionDeclaration));
1265 }
1266 
1267 auto Parser::parseBlock() -&gt; Expected&lt;AST::Block, Error&gt;
1268 {
1269     auto origin = consumeType(Lexer::Token::Type::LeftCurlyBracket);
1270     if (!origin)
1271         return Unexpected&lt;Error&gt;(origin.error());
1272 
1273     auto result = parseBlockBody(WTFMove(*origin));
1274 
1275     auto rightCurlyBracket = consumeType(Lexer::Token::Type::RightCurlyBracket);
1276     if (!rightCurlyBracket)
1277         return Unexpected&lt;Error&gt;(rightCurlyBracket.error());
1278 
1279     return WTFMove(result);
1280 }
1281 
1282 AST::Block Parser::parseBlockBody(Lexer::Token&amp;&amp; origin)
1283 {
1284     AST::Statements statements;
1285     while (true) {
1286         auto statement = backtrackingScope&lt;Expected&lt;UniqueRef&lt;AST::Statement&gt;, Error&gt;&gt;([&amp;]() {
1287             return parseStatement();
1288         });
1289         if (statement)
1290             statements.append(WTFMove(*statement));
1291         else
1292             break;
1293     }
1294     return AST::Block(WTFMove(origin), WTFMove(statements));
1295 }
1296 
1297 auto Parser::parseIfStatement() -&gt; Expected&lt;AST::IfStatement, Error&gt;
1298 {
1299     auto origin = consumeType(Lexer::Token::Type::If);
1300     if (!origin)
1301         return Unexpected&lt;Error&gt;(origin.error());
1302 
1303     auto leftParenthesis = consumeType(Lexer::Token::Type::LeftParenthesis);
1304     if (!leftParenthesis)
1305         return Unexpected&lt;Error&gt;(leftParenthesis.error());
1306 
1307     auto conditional = parseExpression();
1308     if (!conditional)
1309         return Unexpected&lt;Error&gt;(conditional.error());
1310 
1311     auto rightParenthesis = consumeType(Lexer::Token::Type::RightParenthesis);
1312     if (!rightParenthesis)
1313         return Unexpected&lt;Error&gt;(rightParenthesis.error());
1314 
1315     auto body = parseStatement();
1316     if (!body)
1317         return Unexpected&lt;Error&gt;(body.error());
1318 
1319     Optional&lt;UniqueRef&lt;AST::Statement&gt;&gt; elseBody;
1320     if (tryType(Lexer::Token::Type::Else)) {
1321         auto parsedElseBody = parseStatement();
1322         if (!parsedElseBody)
1323             return Unexpected&lt;Error&gt;(parsedElseBody.error());
1324         elseBody = WTFMove(*parsedElseBody);
1325     }
1326 
1327     Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; castArguments;
1328     castArguments.append(WTFMove(*conditional));
1329     auto boolCast = makeUniqueRef&lt;AST::CallExpression&gt;(Lexer::Token(*origin), &quot;bool&quot;_str, WTFMove(castArguments));
1330     return AST::IfStatement(WTFMove(*origin), WTFMove(boolCast), WTFMove(*body), WTFMove(elseBody));
1331 }
1332 
1333 auto Parser::parseSwitchStatement() -&gt; Expected&lt;AST::SwitchStatement, Error&gt;
1334 {
1335     auto origin = consumeType(Lexer::Token::Type::Switch);
1336     if (!origin)
1337         return Unexpected&lt;Error&gt;(origin.error());
1338 
1339     auto leftParenthesis = consumeType(Lexer::Token::Type::LeftParenthesis);
1340     if (!leftParenthesis)
1341         return Unexpected&lt;Error&gt;(leftParenthesis.error());
1342 
1343     auto value = parseExpression();
1344     if (!value)
1345         return Unexpected&lt;Error&gt;(value.error());
1346 
1347     auto rightParenthesis = consumeType(Lexer::Token::Type::RightParenthesis);
1348     if (!rightParenthesis)
1349         return Unexpected&lt;Error&gt;(rightParenthesis.error());
1350 
1351     auto leftCurlyBracket = consumeType(Lexer::Token::Type::LeftCurlyBracket);
1352     if (!leftCurlyBracket)
1353         return Unexpected&lt;Error&gt;(leftCurlyBracket.error());
1354 
1355     Vector&lt;AST::SwitchCase&gt; switchCases;
1356     while (true) {
1357         auto switchCase = backtrackingScope&lt;Expected&lt;AST::SwitchCase, Error&gt;&gt;([&amp;]() {
1358             return parseSwitchCase();
1359         });
1360         if (switchCase)
1361             switchCases.append(WTFMove(*switchCase));
1362         else
1363             break;
1364     }
1365 
1366     auto rightCurlyBracket = consumeType(Lexer::Token::Type::RightCurlyBracket);
1367     if (!rightCurlyBracket)
1368         return Unexpected&lt;Error&gt;(rightCurlyBracket.error());
1369 
1370     return AST::SwitchStatement(WTFMove(*origin), WTFMove(*value), WTFMove(switchCases));
1371 }
1372 
1373 auto Parser::parseSwitchCase() -&gt; Expected&lt;AST::SwitchCase, Error&gt;
1374 {
1375     auto origin = consumeTypes({ Lexer::Token::Type::Case, Lexer::Token::Type::Default });
1376     if (!origin)
1377         return Unexpected&lt;Error&gt;(origin.error());
1378 
1379     switch (origin-&gt;type) {
1380     case Lexer::Token::Type::Case: {
1381         auto value = parseConstantExpression();
1382         if (!value)
1383             return Unexpected&lt;Error&gt;(value.error());
1384 
1385         auto origin = consumeType(Lexer::Token::Type::Colon);
1386         if (!origin)
1387             return Unexpected&lt;Error&gt;(origin.error());
1388 
1389         auto block = parseBlockBody(Lexer::Token(*origin));
1390 
1391         return AST::SwitchCase(WTFMove(*origin), WTFMove(*value), WTFMove(block));
1392     }
1393     default: {
1394         ASSERT(origin-&gt;type == Lexer::Token::Type::Default);
1395         auto origin = consumeType(Lexer::Token::Type::Colon);
1396         if (!origin)
1397             return Unexpected&lt;Error&gt;(origin.error());
1398 
1399         auto block = parseBlockBody(Lexer::Token(*origin));
1400 
1401         return AST::SwitchCase(WTFMove(*origin), WTF::nullopt, WTFMove(block));
1402     }
1403     }
1404 }
1405 
1406 auto Parser::parseForLoop() -&gt; Expected&lt;AST::ForLoop, Error&gt;
1407 {
1408     auto origin = consumeType(Lexer::Token::Type::For);
1409     if (!origin)
1410         return Unexpected&lt;Error&gt;(origin.error());
1411 
1412     auto parseRemainder = [&amp;](Variant&lt;AST::VariableDeclarationsStatement, UniqueRef&lt;AST::Expression&gt;&gt;&amp;&amp; initialization) -&gt; Expected&lt;AST::ForLoop, Error&gt; {
1413         auto semicolon = consumeType(Lexer::Token::Type::Semicolon);
1414         if (!semicolon)
1415             return Unexpected&lt;Error&gt;(semicolon.error());
1416 
1417         auto condition = backtrackingScope&lt;Optional&lt;UniqueRef&lt;AST::Expression&gt;&gt;&gt;([&amp;]() -&gt; Optional&lt;UniqueRef&lt;AST::Expression&gt;&gt; {
1418             if (auto expression = parseExpression())
1419                 return { WTFMove(*expression) };
1420             return WTF::nullopt;
1421         });
1422 
1423         semicolon = consumeType(Lexer::Token::Type::Semicolon);
1424         if (!semicolon)
1425             return Unexpected&lt;Error&gt;(semicolon.error());
1426 
1427         auto increment = backtrackingScope&lt;Optional&lt;UniqueRef&lt;AST::Expression&gt;&gt;&gt;([&amp;]() -&gt; Optional&lt;UniqueRef&lt;AST::Expression&gt;&gt; {
1428             if (auto expression = parseExpression())
1429                 return { WTFMove(*expression) };
1430             return WTF::nullopt;
1431         });
1432 
1433         auto rightParenthesis = consumeType(Lexer::Token::Type::RightParenthesis);
1434         if (!rightParenthesis)
1435             return Unexpected&lt;Error&gt;(rightParenthesis.error());
1436 
1437         auto body = parseStatement();
1438         if (!body)
1439             return Unexpected&lt;Error&gt;(body.error());
1440 
1441         return AST::ForLoop(WTFMove(*origin), WTFMove(initialization), WTFMove(condition), WTFMove(increment), WTFMove(*body));
1442     };
1443 
1444     auto leftParenthesis = consumeType(Lexer::Token::Type::LeftParenthesis);
1445     if (!leftParenthesis)
1446         return Unexpected&lt;Error&gt;(leftParenthesis.error());
1447 
1448     auto variableDeclarations = backtrackingScope&lt;Expected&lt;AST::VariableDeclarationsStatement, Error&gt;&gt;([&amp;]() {
1449         return parseVariableDeclarations();
1450     });
1451     if (variableDeclarations)
1452         return parseRemainder(WTFMove(*variableDeclarations));
1453 
1454     auto effectfulExpression = parseEffectfulExpression();
1455     if (!effectfulExpression)
1456         return Unexpected&lt;Error&gt;(effectfulExpression.error());
1457 
1458     return parseRemainder(WTFMove(*effectfulExpression));
1459 }
1460 
1461 auto Parser::parseWhileLoop() -&gt; Expected&lt;AST::WhileLoop, Error&gt;
1462 {
1463     auto origin = consumeType(Lexer::Token::Type::While);
1464     if (!origin)
1465         return Unexpected&lt;Error&gt;(origin.error());
1466 
1467     auto leftParenthesis = consumeType(Lexer::Token::Type::LeftParenthesis);
1468     if (!leftParenthesis)
1469         return Unexpected&lt;Error&gt;(leftParenthesis.error());
1470 
1471     auto conditional = parseExpression();
1472     if (!conditional)
1473         return Unexpected&lt;Error&gt;(conditional.error());
1474 
1475     auto rightParenthesis = consumeType(Lexer::Token::Type::RightParenthesis);
1476     if (!rightParenthesis)
1477         return Unexpected&lt;Error&gt;(rightParenthesis.error());
1478 
1479     auto body = parseStatement();
1480     if (!body)
1481         return Unexpected&lt;Error&gt;(body.error());
1482 
1483     return AST::WhileLoop(WTFMove(*origin), WTFMove(*conditional), WTFMove(*body));
1484 }
1485 
1486 auto Parser::parseDoWhileLoop() -&gt; Expected&lt;AST::DoWhileLoop, Error&gt;
1487 {
1488     auto origin = consumeType(Lexer::Token::Type::Do);
1489     if (!origin)
1490         return Unexpected&lt;Error&gt;(origin.error());
1491 
1492     auto body = parseStatement();
1493     if (!body)
1494         return Unexpected&lt;Error&gt;(body.error());
1495 
1496     auto whileKeyword = consumeType(Lexer::Token::Type::While);
1497     if (!whileKeyword)
1498         return Unexpected&lt;Error&gt;(whileKeyword.error());
1499 
1500     auto leftParenthesis = consumeType(Lexer::Token::Type::LeftParenthesis);
1501     if (!leftParenthesis)
1502         return Unexpected&lt;Error&gt;(leftParenthesis.error());
1503 
1504     auto conditional = parseExpression();
1505     if (!conditional)
1506         return Unexpected&lt;Error&gt;(conditional.error());
1507 
1508     auto rightParenthesis = consumeType(Lexer::Token::Type::RightParenthesis);
1509     if (!rightParenthesis)
1510         return Unexpected&lt;Error&gt;(rightParenthesis.error());
1511 
1512     return AST::DoWhileLoop(WTFMove(*origin), WTFMove(*body), WTFMove(*conditional));
1513 }
1514 
1515 auto Parser::parseVariableDeclaration(UniqueRef&lt;AST::UnnamedType&gt;&amp;&amp; type) -&gt; Expected&lt;AST::VariableDeclaration, Error&gt;
1516 {
1517     auto origin = peek();
1518     if (!origin)
1519         return Unexpected&lt;Error&gt;(origin.error());
1520 
1521     auto qualifiers = parseQualifiers();
1522 
1523     auto name = consumeType(Lexer::Token::Type::Identifier);
1524     if (!name)
1525         return Unexpected&lt;Error&gt;(name.error());
1526 
1527     if (tryType(Lexer::Token::Type::Colon)) {
1528         auto semantic = parseSemantic();
1529         if (!semantic)
1530             return Unexpected&lt;Error&gt;(semantic.error());
1531 
1532         if (tryType(Lexer::Token::Type::EqualsSign)) {
1533             auto initializer = parseExpression();
1534             if (!initializer)
1535                 return Unexpected&lt;Error&gt;(initializer.error());
1536             return AST::VariableDeclaration(WTFMove(*origin), WTFMove(qualifiers), { WTFMove(type) }, name-&gt;stringView.toString(), WTFMove(*semantic), WTFMove(*initializer));
1537         }
1538 
1539         return AST::VariableDeclaration(WTFMove(*origin), WTFMove(qualifiers), { WTFMove(type) }, name-&gt;stringView.toString(), WTFMove(*semantic), WTF::nullopt);
1540     }
1541 
1542     if (tryType(Lexer::Token::Type::EqualsSign)) {
1543         auto initializer = parseExpression();
1544         if (!initializer)
1545             return Unexpected&lt;Error&gt;(initializer.error());
1546         return AST::VariableDeclaration(WTFMove(*origin), WTFMove(qualifiers), { WTFMove(type) }, name-&gt;stringView.toString(), WTF::nullopt, WTFMove(*initializer));
1547     }
1548 
1549     return AST::VariableDeclaration(WTFMove(*origin), WTFMove(qualifiers), { WTFMove(type) }, name-&gt;stringView.toString(), WTF::nullopt, WTF::nullopt);
1550 }
1551 
1552 auto Parser::parseVariableDeclarations() -&gt; Expected&lt;AST::VariableDeclarationsStatement, Error&gt;
1553 {
1554     auto origin = peek();
1555     if (!origin)
1556         return Unexpected&lt;Error&gt;(origin.error());
1557 
1558     auto type = parseType();
1559     if (!type)
1560         return Unexpected&lt;Error&gt;(type.error());
1561 
1562     auto firstVariableDeclaration = parseVariableDeclaration((*type)-&gt;clone());
1563     if (!firstVariableDeclaration)
1564         return Unexpected&lt;Error&gt;(firstVariableDeclaration.error());
1565 
1566     Vector&lt;AST::VariableDeclaration&gt; result;
1567     result.append(WTFMove(*firstVariableDeclaration));
1568 
1569     while (tryType(Lexer::Token::Type::Comma)) {
1570         auto variableDeclaration = parseVariableDeclaration((*type)-&gt;clone());
1571         if (!variableDeclaration)
1572             return Unexpected&lt;Error&gt;(variableDeclaration.error());
1573         result.append(WTFMove(*variableDeclaration));
1574     }
1575 
1576     return AST::VariableDeclarationsStatement(WTFMove(*origin), WTFMove(result));
1577 }
1578 
1579 auto Parser::parseStatement() -&gt; Expected&lt;UniqueRef&lt;AST::Statement&gt;, Error&gt;
1580 {
1581     {
1582         auto block = backtrackingScope&lt;Expected&lt;AST::Block, Error&gt;&gt;([&amp;]() {
1583             return parseBlock();
1584         });
1585         if (block)
1586             return { makeUniqueRef&lt;AST::Block&gt;(WTFMove(*block)) };
1587     }
1588 
1589     {
1590         auto ifStatement = backtrackingScope&lt;Expected&lt;AST::IfStatement, Error&gt;&gt;([&amp;]() {
1591             return parseIfStatement();
1592         });
1593         if (ifStatement)
1594             return { makeUniqueRef&lt;AST::IfStatement&gt;(WTFMove(*ifStatement)) };
1595     }
1596 
1597     {
1598         auto switchStatement = backtrackingScope&lt;Expected&lt;AST::SwitchStatement, Error&gt;&gt;([&amp;]() {
1599             return parseSwitchStatement();
1600         });
1601         if (switchStatement)
1602             return { makeUniqueRef&lt;AST::SwitchStatement&gt;(WTFMove(*switchStatement)) };
1603     }
1604 
1605     {
1606         auto forLoop = backtrackingScope&lt;Expected&lt;AST::ForLoop, Error&gt;&gt;([&amp;]() {
1607             return parseForLoop();
1608         });
1609         if (forLoop)
1610             return { makeUniqueRef&lt;AST::ForLoop&gt;(WTFMove(*forLoop)) };
1611     }
1612 
1613     {
1614         auto whileLoop = backtrackingScope&lt;Expected&lt;AST::WhileLoop, Error&gt;&gt;([&amp;]() {
1615             return parseWhileLoop();
1616         });
1617         if (whileLoop)
1618             return { makeUniqueRef&lt;AST::WhileLoop&gt;(WTFMove(*whileLoop)) };
1619     }
1620 
1621     {
1622         auto doWhileLoop = backtrackingScope&lt;Expected&lt;AST::DoWhileLoop, Error&gt;&gt;([&amp;]() -&gt; Expected&lt;AST::DoWhileLoop, Error&gt; {
1623             auto result = parseDoWhileLoop();
1624             if (!result)
1625                 return Unexpected&lt;Error&gt;(result.error());
1626 
1627             auto semicolon = consumeType(Lexer::Token::Type::Semicolon);
1628             if (!semicolon)
1629                 return Unexpected&lt;Error&gt;(semicolon.error());
1630 
1631             return result;
1632         });
1633         if (doWhileLoop)
1634             return { makeUniqueRef&lt;AST::DoWhileLoop&gt;(WTFMove(*doWhileLoop)) };
1635     }
1636 
1637     {
1638         auto breakObject = backtrackingScope&lt;Expected&lt;AST::Break, Error&gt;&gt;([&amp;]() -&gt; Expected&lt;AST::Break, Error&gt; {
1639             auto origin = consumeType(Lexer::Token::Type::Break);
1640             if (!origin)
1641                 return Unexpected&lt;Error&gt;(origin.error());
1642 
1643             auto semicolon = consumeType(Lexer::Token::Type::Semicolon);
1644             if (!semicolon)
1645                 return Unexpected&lt;Error&gt;(semicolon.error());
1646 
1647             return AST::Break(WTFMove(*origin));
1648         });
1649         if (breakObject)
1650             return { makeUniqueRef&lt;AST::Break&gt;(WTFMove(*breakObject)) };
1651     }
1652 
1653     {
1654         auto continueObject = backtrackingScope&lt;Expected&lt;AST::Continue, Error&gt;&gt;([&amp;]() -&gt; Expected&lt;AST::Continue, Error&gt; {
1655             auto origin = consumeType(Lexer::Token::Type::Continue);
1656             if (!origin)
1657                 return Unexpected&lt;Error&gt;(origin.error());
1658 
1659             auto semicolon = consumeType(Lexer::Token::Type::Semicolon);
1660             if (!semicolon)
1661                 return Unexpected&lt;Error&gt;(semicolon.error());
1662 
1663             return AST::Continue(WTFMove(*origin));
1664         });
1665         if (continueObject)
1666             return { makeUniqueRef&lt;AST::Continue&gt;(WTFMove(*continueObject)) };
1667     }
1668 
1669     {
1670         auto fallthroughObject = backtrackingScope&lt;Expected&lt;AST::Fallthrough, Error&gt;&gt;([&amp;]() -&gt; Expected&lt;AST::Fallthrough, Error&gt; {
1671             auto origin = consumeType(Lexer::Token::Type::Fallthrough);
1672             if (!origin)
1673                 return Unexpected&lt;Error&gt;(origin.error());
1674 
1675             auto semicolon = consumeType(Lexer::Token::Type::Semicolon);
1676             if (!semicolon)
1677                 return Unexpected&lt;Error&gt;(semicolon.error());
1678 
1679             return AST::Fallthrough(WTFMove(*origin));
1680         });
1681         if (fallthroughObject)
1682             return { makeUniqueRef&lt;AST::Fallthrough&gt;(WTFMove(*fallthroughObject)) };
1683     }
1684 
1685     {
1686         auto trapObject = backtrackingScope&lt;Expected&lt;AST::Trap, Error&gt;&gt;([&amp;]() -&gt; Expected&lt;AST::Trap, Error&gt; {
1687             auto origin = consumeType(Lexer::Token::Type::Trap);
1688             if (!origin)
1689                 return Unexpected&lt;Error&gt;(origin.error());
1690 
1691             auto semicolon = consumeType(Lexer::Token::Type::Semicolon);
1692             if (!semicolon)
1693                 return Unexpected&lt;Error&gt;(semicolon.error());
1694 
1695             return AST::Trap(WTFMove(*origin));
1696         });
1697         if (trapObject)
1698             return { makeUniqueRef&lt;AST::Trap&gt;(WTFMove(*trapObject)) };
1699     }
1700 
1701     {
1702         auto returnObject = backtrackingScope&lt;Expected&lt;AST::Return, Error&gt;&gt;([&amp;]() -&gt; Expected&lt;AST::Return, Error&gt; {
1703             auto origin = consumeType(Lexer::Token::Type::Return);
1704             if (!origin)
1705                 return Unexpected&lt;Error&gt;(origin.error());
1706 
1707             if (auto semicolon = tryType(Lexer::Token::Type::Semicolon))
1708                 return AST::Return(WTFMove(*origin), WTF::nullopt);
1709 
1710             auto expression = parseExpression();
1711             if (!expression)
1712                 return Unexpected&lt;Error&gt;(expression.error());
1713 
1714             auto semicolon = consumeType(Lexer::Token::Type::Semicolon);
1715             if (!semicolon)
1716                 return Unexpected&lt;Error&gt;(semicolon.error());
1717 
1718             return AST::Return(WTFMove(*origin), { WTFMove(*expression) });
1719         });
1720         if (returnObject)
1721             return { makeUniqueRef&lt;AST::Return&gt;(WTFMove(*returnObject)) };
1722     }
1723 
1724     {
1725         auto variableDeclarations = backtrackingScope&lt;Expected&lt;AST::VariableDeclarationsStatement, Error&gt;&gt;([&amp;]() -&gt; Expected&lt;AST::VariableDeclarationsStatement, Error&gt; {
1726             auto result = parseVariableDeclarations();
1727             if (!result)
1728                 return Unexpected&lt;Error&gt;(result.error());
1729 
1730             auto semicolon = consumeType(Lexer::Token::Type::Semicolon);
1731             if (!semicolon)
1732                 return Unexpected&lt;Error&gt;(semicolon.error());
1733 
1734             return result;
1735         });
1736         if (variableDeclarations)
1737             return { makeUniqueRef&lt;AST::VariableDeclarationsStatement&gt;(WTFMove(*variableDeclarations)) };
1738     }
1739 
1740     auto effectfulExpression = backtrackingScope&lt;Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;&gt;([&amp;]() -&gt; Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt; {
1741         auto result = parseEffectfulExpression();
1742         if (!result)
1743             return Unexpected&lt;Error&gt;(result.error());
1744 
1745         auto semicolon = consumeType(Lexer::Token::Type::Semicolon);
1746         if (!semicolon)
1747             return Unexpected&lt;Error&gt;(semicolon.error());
1748 
1749         return result;
1750     });
1751     if (effectfulExpression)
1752         return { makeUniqueRef&lt;AST::EffectfulExpressionStatement&gt;(WTFMove(*effectfulExpression)) };
1753 
1754     return Unexpected&lt;Error&gt;(effectfulExpression.error());
1755 }
1756 
1757 auto Parser::parseEffectfulExpression() -&gt; Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;
1758 {
1759     auto origin = peek();
1760     if (!origin)
1761         return Unexpected&lt;Error&gt;(origin.error());
1762 
1763     Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; expressions;
1764 
1765     auto first = backtrackingScope&lt;Optional&lt;UniqueRef&lt;AST::Expression&gt;&gt;&gt;([&amp;]() -&gt; Optional&lt;UniqueRef&lt;AST::Expression&gt;&gt; {
1766         auto effectfulExpression = parseEffectfulAssignment();
1767         if (!effectfulExpression)
1768             return WTF::nullopt;
1769         return { WTFMove(*effectfulExpression) };
1770     });
1771     if (!first)
1772         return { makeUniqueRef&lt;AST::CommaExpression&gt;(WTFMove(*origin), WTFMove(expressions)) };
1773 
1774     expressions.append(WTFMove(*first));
1775 
1776     while (tryType(Lexer::Token::Type::Comma)) {
1777         auto expression = parseEffectfulAssignment();
1778         if (!expression)
1779             return Unexpected&lt;Error&gt;(expression.error());
1780         expressions.append(WTFMove(*expression));
1781     }
1782 
1783     if (expressions.size() == 1)
1784         return WTFMove(expressions[0]);
1785     return { makeUniqueRef&lt;AST::CommaExpression&gt;(WTFMove(*origin), WTFMove(expressions)) };
1786 }
1787 
1788 auto Parser::parseEffectfulAssignment() -&gt; Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;
1789 {
1790     auto assignment = backtrackingScope&lt;Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;&gt;([&amp;]() {
1791         return parseAssignment();
1792     });
1793     if (assignment)
1794         return assignment;
1795 
1796     assignment = backtrackingScope&lt;Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;&gt;([&amp;]() {
1797         return parseEffectfulPrefix();
1798     });
1799     if (assignment)
1800         return assignment;
1801 
1802     assignment = backtrackingScope&lt;Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;&gt;([&amp;]() {
1803         return parseCallExpression();
1804     });
1805     if (assignment)
1806         return assignment;
1807 
1808     return Unexpected&lt;Error&gt;(assignment.error());
1809 }
1810 
1811 auto Parser::parseEffectfulPrefix() -&gt; Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;
1812 {
1813     auto prefix = consumeTypes({ Lexer::Token::Type::PlusPlus, Lexer::Token::Type::MinusMinus });
1814     if (!prefix)
1815         return Unexpected&lt;Error&gt;(prefix.error());
1816 
1817     auto previous = parsePossiblePrefix();
1818     if (!previous)
1819         return Unexpected&lt;Error&gt;(previous.error());
1820 
1821     switch (prefix-&gt;type) {
1822     case Lexer::Token::Type::PlusPlus: {
1823         auto result = AST::ReadModifyWriteExpression::create(Lexer::Token(*prefix), WTFMove(*previous));
1824         Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; callArguments;
1825         callArguments.append(result-&gt;oldVariableReference());
1826         result-&gt;setNewValueExpression(makeUniqueRef&lt;AST::CallExpression&gt;(WTFMove(*prefix), &quot;operator++&quot;_str, WTFMove(callArguments)));
1827         result-&gt;setResultExpression(result-&gt;newVariableReference());
1828         return { WTFMove(result) };
1829     }
1830     default: {
1831         ASSERT(prefix-&gt;type == Lexer::Token::Type::MinusMinus);
1832         auto result = AST::ReadModifyWriteExpression::create(Lexer::Token(*prefix), WTFMove(*previous));
1833         Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; callArguments;
1834         callArguments.append(result-&gt;oldVariableReference());
1835         result-&gt;setNewValueExpression(makeUniqueRef&lt;AST::CallExpression&gt;(WTFMove(*prefix), &quot;operator--&quot;_str, WTFMove(callArguments)));
1836         result-&gt;setResultExpression(result-&gt;newVariableReference());
1837         return { WTFMove(result) };
1838     }
1839     }
1840 }
1841 
1842 auto Parser::parseEffectfulSuffix() -&gt; Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;
1843 {
1844     auto effectfulSuffix = backtrackingScope&lt;Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;&gt;([&amp;]() -&gt; Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt; {
1845         auto previous = parsePossibleSuffix();
1846         if (!previous)
1847             return Unexpected&lt;Error&gt;(previous.error());
1848 
1849         auto suffix = consumeTypes({ Lexer::Token::Type::PlusPlus, Lexer::Token::Type::MinusMinus });
1850         if (!suffix)
1851             return Unexpected&lt;Error&gt;(suffix.error());
1852 
1853         switch (suffix-&gt;type) {
1854         case Lexer::Token::Type::PlusPlus: {
1855             auto result = AST::ReadModifyWriteExpression::create(Lexer::Token(*suffix), WTFMove(*previous));
1856             Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; callArguments;
1857             callArguments.append(result-&gt;oldVariableReference());
1858             result-&gt;setNewValueExpression(makeUniqueRef&lt;AST::CallExpression&gt;(WTFMove(*suffix), &quot;operator++&quot;_str, WTFMove(callArguments)));
1859             result-&gt;setResultExpression(result-&gt;oldVariableReference());
1860             return { WTFMove(result) };
1861         }
1862         default: {
1863             ASSERT(suffix-&gt;type == Lexer::Token::Type::MinusMinus);
1864             auto result = AST::ReadModifyWriteExpression::create(Lexer::Token(*suffix), WTFMove(*previous));
1865             Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; callArguments;
1866             callArguments.append(result-&gt;oldVariableReference());
1867             result-&gt;setNewValueExpression(makeUniqueRef&lt;AST::CallExpression&gt;(WTFMove(*suffix), &quot;operator--&quot;_str, WTFMove(callArguments)));
1868             result-&gt;setResultExpression(result-&gt;oldVariableReference());
1869             return { WTFMove(result) };
1870         }
1871         }
1872     });
1873     if (effectfulSuffix)
1874         return effectfulSuffix;
1875 
1876     effectfulSuffix = backtrackingScope&lt;Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;&gt;([&amp;]() {
1877         return parseCallExpression();
1878     });
1879     if (effectfulSuffix)
1880         return effectfulSuffix;
1881 
1882     effectfulSuffix = backtrackingScope&lt;Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;&gt;([&amp;]() -&gt; Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt; {
1883         auto leftParenthesis = consumeType(Lexer::Token::Type::LeftParenthesis);
1884         if (!leftParenthesis)
1885             return Unexpected&lt;Error&gt;(leftParenthesis.error());
1886 
1887         auto expression = parseExpression();
1888         if (!expression)
1889             return Unexpected&lt;Error&gt;(expression.error());
1890 
1891         auto rightParenthesis = consumeType(Lexer::Token::Type::RightParenthesis);
1892         if (!rightParenthesis)
1893             return Unexpected&lt;Error&gt;(rightParenthesis.error());
1894 
1895         return { WTFMove(*expression) };
1896     });
1897     if (effectfulSuffix)
1898         return effectfulSuffix;
1899 
1900     return Unexpected&lt;Error&gt;(effectfulSuffix.error());
1901 }
1902 
1903 auto Parser::parseLimitedSuffixOperator(UniqueRef&lt;AST::Expression&gt;&amp;&amp; previous) -&gt; SuffixExpression
1904 {
1905     auto type = consumeTypes({ Lexer::Token::Type::FullStop, Lexer::Token::Type::Arrow, Lexer::Token::Type::LeftSquareBracket });
1906     if (!type)
1907         return SuffixExpression(WTFMove(previous), false);
1908 
1909     switch (type-&gt;type) {
1910     case Lexer::Token::Type::FullStop: {
1911         auto identifier = consumeType(Lexer::Token::Type::Identifier);
1912         if (!identifier)
1913             return SuffixExpression(WTFMove(previous), false);
1914         return SuffixExpression(makeUniqueRef&lt;AST::DotExpression&gt;(WTFMove(*type), WTFMove(previous), identifier-&gt;stringView.toString()), true);
1915     }
1916     case Lexer::Token::Type::Arrow: {
1917         auto identifier = consumeType(Lexer::Token::Type::Identifier);
1918         if (!identifier)
1919             return SuffixExpression(WTFMove(previous), false);
1920         return SuffixExpression(makeUniqueRef&lt;AST::DotExpression&gt;(Lexer::Token(*type), makeUniqueRef&lt;AST::DereferenceExpression&gt;(WTFMove(*type), WTFMove(previous)), identifier-&gt;stringView.toString()), true);
1921     }
1922     default: {
1923         ASSERT(type-&gt;type == Lexer::Token::Type::LeftSquareBracket);
1924         auto expression = parseExpression();
1925         if (!expression)
1926             return SuffixExpression(WTFMove(previous), false);
1927         if (!consumeType(Lexer::Token::Type::RightSquareBracket))
1928             return SuffixExpression(WTFMove(previous), false);
1929         return SuffixExpression(makeUniqueRef&lt;AST::IndexExpression&gt;(WTFMove(*type), WTFMove(previous), WTFMove(*expression)), true);
1930     }
1931     }
1932 }
1933 
1934 auto Parser::parseSuffixOperator(UniqueRef&lt;AST::Expression&gt;&amp;&amp; previous) -&gt; SuffixExpression
1935 {
1936     auto suffix = consumeTypes({ Lexer::Token::Type::FullStop, Lexer::Token::Type::Arrow, Lexer::Token::Type::LeftSquareBracket, Lexer::Token::Type::PlusPlus, Lexer::Token::Type::MinusMinus });
1937     if (!suffix)
1938         return SuffixExpression(WTFMove(previous), false);
1939 
1940     switch (suffix-&gt;type) {
1941     case Lexer::Token::Type::FullStop: {
1942         auto identifier = consumeType(Lexer::Token::Type::Identifier);
1943         if (!identifier)
1944             return SuffixExpression(WTFMove(previous), false);
1945         return SuffixExpression(makeUniqueRef&lt;AST::DotExpression&gt;(WTFMove(*suffix), WTFMove(previous), identifier-&gt;stringView.toString()), true);
1946     }
1947     case Lexer::Token::Type::Arrow: {
1948         auto identifier = consumeType(Lexer::Token::Type::Identifier);
1949         if (!identifier)
1950             return SuffixExpression(WTFMove(previous), false);
1951         return SuffixExpression(makeUniqueRef&lt;AST::DotExpression&gt;(Lexer::Token(*suffix), makeUniqueRef&lt;AST::DereferenceExpression&gt;(WTFMove(*suffix), WTFMove(previous)), identifier-&gt;stringView.toString()), true);
1952     }
1953     case Lexer::Token::Type::LeftSquareBracket: {
1954         auto expression = parseExpression();
1955         if (!expression)
1956             return SuffixExpression(WTFMove(previous), false);
1957         if (!consumeType(Lexer::Token::Type::RightSquareBracket))
1958             return SuffixExpression(WTFMove(previous), false);
1959         return SuffixExpression(makeUniqueRef&lt;AST::IndexExpression&gt;(WTFMove(*suffix), WTFMove(previous), WTFMove(*expression)), true);
1960     }
1961     case Lexer::Token::Type::PlusPlus: {
1962         auto result = AST::ReadModifyWriteExpression::create(Lexer::Token(*suffix), WTFMove(previous));
1963         Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; callArguments;
1964         callArguments.append(result-&gt;oldVariableReference());
1965         result-&gt;setNewValueExpression(makeUniqueRef&lt;AST::CallExpression&gt;(WTFMove(*suffix), &quot;operator++&quot;_str, WTFMove(callArguments)));
1966         result-&gt;setResultExpression(result-&gt;oldVariableReference());
1967         return SuffixExpression(WTFMove(result), true);
1968     }
1969     default: {
1970         ASSERT(suffix-&gt;type == Lexer::Token::Type::MinusMinus);
1971         auto result = AST::ReadModifyWriteExpression::create(Lexer::Token(*suffix), WTFMove(previous));
1972         Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; callArguments;
1973         callArguments.append(result-&gt;oldVariableReference());
1974         result-&gt;setNewValueExpression(makeUniqueRef&lt;AST::CallExpression&gt;(WTFMove(*suffix), &quot;operator--&quot;_str, WTFMove(callArguments)));
1975         result-&gt;setResultExpression(result-&gt;oldVariableReference());
1976         return SuffixExpression(WTFMove(result), true);
1977     }
1978     }
1979 }
1980 
1981 auto Parser::parseExpression() -&gt; Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;
1982 {
1983     auto origin = peek();
1984     if (!origin)
1985         return Unexpected&lt;Error&gt;(origin.error());
1986 
1987     auto first = parsePossibleTernaryConditional();
1988     if (!first)
1989         return Unexpected&lt;Error&gt;(first.error());
1990 
1991     Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; expressions;
1992     expressions.append(WTFMove(*first));
1993 
1994     while (tryType(Lexer::Token::Type::Comma)) {
1995         auto expression = parsePossibleTernaryConditional();
1996         if (!expression)
1997             return Unexpected&lt;Error&gt;(expression.error());
1998         expressions.append(WTFMove(*expression));
1999     }
2000 
2001     if (expressions.size() == 1)
2002         return WTFMove(expressions[0]);
2003     return { makeUniqueRef&lt;AST::CommaExpression&gt;(WTFMove(*origin), WTFMove(expressions)) };
2004 }
2005 
2006 auto Parser::parseTernaryConditional() -&gt; Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;
2007 {
2008     auto origin = peek();
2009     if (!origin)
2010         return Unexpected&lt;Error&gt;(origin.error());
2011 
2012     auto predicate = parsePossibleLogicalBinaryOperation();
2013     if (!predicate)
2014         return Unexpected&lt;Error&gt;(predicate.error());
2015 
2016     auto questionMark = consumeType(Lexer::Token::Type::QuestionMark);
2017     if (!questionMark)
2018         return Unexpected&lt;Error&gt;(questionMark.error());
2019 
2020     auto bodyExpression = parseExpression();
2021     if (!bodyExpression)
2022         return Unexpected&lt;Error&gt;(bodyExpression.error());
2023 
2024     auto colon = consumeType(Lexer::Token::Type::Colon);
2025     if (!colon)
2026         return Unexpected&lt;Error&gt;(colon.error());
2027 
2028     auto elseExpression = parsePossibleTernaryConditional();
2029     if (!elseExpression)
2030         return Unexpected&lt;Error&gt;(elseExpression.error());
2031 
2032     Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; castArguments;
2033     castArguments.append(WTFMove(*predicate));
2034     auto boolCast = makeUniqueRef&lt;AST::CallExpression&gt;(Lexer::Token(*origin), &quot;bool&quot;_str, WTFMove(castArguments));
2035     return { makeUniqueRef&lt;AST::TernaryExpression&gt;(WTFMove(*origin), WTFMove(boolCast), WTFMove(*bodyExpression), WTFMove(*elseExpression)) };
2036 }
2037 
2038 auto Parser::parseAssignment() -&gt; Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;
2039 {
2040     auto origin = peek();
2041     if (!origin)
2042         return Unexpected&lt;Error&gt;(origin.error());
2043 
2044     auto left = parsePossiblePrefix();
2045     if (!left)
2046         return Unexpected&lt;Error&gt;(left.error());
2047 
2048     auto assignmentOperator = consumeTypes({
2049         Lexer::Token::Type::EqualsSign,
2050         Lexer::Token::Type::PlusEquals,
2051         Lexer::Token::Type::MinusEquals,
2052         Lexer::Token::Type::TimesEquals,
2053         Lexer::Token::Type::DivideEquals,
2054         Lexer::Token::Type::ModEquals,
2055         Lexer::Token::Type::XorEquals,
2056         Lexer::Token::Type::AndEquals,
2057         Lexer::Token::Type::OrEquals,
2058         Lexer::Token::Type::RightShiftEquals,
2059         Lexer::Token::Type::LeftShiftEquals
2060     });
2061     if (!assignmentOperator)
2062         return Unexpected&lt;Error&gt;(assignmentOperator.error());
2063 
2064     auto right = parsePossibleTernaryConditional();
2065     if (!right)
2066         return Unexpected&lt;Error&gt;(right.error());
2067 
2068     if (assignmentOperator-&gt;type == Lexer::Token::Type::EqualsSign)
2069         return { makeUniqueRef&lt;AST::AssignmentExpression&gt;(WTFMove(*origin), WTFMove(*left), WTFMove(*right))};
2070 
2071     String name;
2072     switch (assignmentOperator-&gt;type) {
2073     case Lexer::Token::Type::PlusEquals:
2074         name = &quot;operator+&quot;_str;
2075         break;
2076     case Lexer::Token::Type::MinusEquals:
2077         name = &quot;operator-&quot;_str;
2078         break;
2079     case Lexer::Token::Type::TimesEquals:
2080         name = &quot;operator*&quot;_str;
2081         break;
2082     case Lexer::Token::Type::DivideEquals:
2083         name = &quot;operator/&quot;_str;
2084         break;
2085     case Lexer::Token::Type::ModEquals:
2086         name = &quot;operator%&quot;_str;
2087         break;
2088     case Lexer::Token::Type::XorEquals:
2089         name = &quot;operator^&quot;_str;
2090         break;
2091     case Lexer::Token::Type::AndEquals:
2092         name = &quot;operator&amp;&quot;_str;
2093         break;
2094     case Lexer::Token::Type::OrEquals:
2095         name = &quot;operator|&quot;_str;
2096         break;
2097     case Lexer::Token::Type::RightShiftEquals:
2098         name = &quot;operator&gt;&gt;&quot;_str;
2099         break;
2100     default:
2101         ASSERT(assignmentOperator-&gt;type == Lexer::Token::Type::LeftShiftEquals);
2102         name = &quot;operator&lt;&lt;&quot;_str;
2103         break;
2104     }
2105 
2106     auto result = AST::ReadModifyWriteExpression::create(Lexer::Token(*origin), WTFMove(*left));
2107     Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; callArguments;
2108     callArguments.append(result-&gt;oldVariableReference());
2109     callArguments.append(WTFMove(*right));
2110     result-&gt;setNewValueExpression(makeUniqueRef&lt;AST::CallExpression&gt;(WTFMove(*origin), WTFMove(name), WTFMove(callArguments)));
2111     result-&gt;setResultExpression(result-&gt;newVariableReference());
2112     return { WTFMove(result) };
2113 }
2114 
2115 auto Parser::parsePossibleTernaryConditional() -&gt; Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;
2116 {
2117     auto ternaryExpression = backtrackingScope&lt;Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;&gt;([&amp;]() {
2118         return parseTernaryConditional();
2119     });
2120     if (ternaryExpression)
2121         return ternaryExpression;
2122 
2123     auto assignmentExpression = backtrackingScope&lt;Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;&gt;([&amp;]() {
2124         return parseAssignment();
2125     });
2126     if (assignmentExpression)
2127         return assignmentExpression;
2128 
2129     auto binaryOperation = backtrackingScope&lt;Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;&gt;([&amp;]() {
2130         return parsePossibleLogicalBinaryOperation();
2131     });
2132     if (binaryOperation)
2133         return binaryOperation;
2134 
2135     return Unexpected&lt;Error&gt;(binaryOperation.error());
2136 }
2137 
2138 auto Parser::parsePossibleLogicalBinaryOperation() -&gt; Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;
2139 {
2140     auto parsedPrevious = parsePossibleRelationalBinaryOperation();
2141     if (!parsedPrevious)
2142         return Unexpected&lt;Error&gt;(parsedPrevious.error());
2143     UniqueRef&lt;AST::Expression&gt; previous = WTFMove(*parsedPrevious);
2144 
2145     while (auto logicalBinaryOperation = tryTypes({
2146         Lexer::Token::Type::OrOr,
2147         Lexer::Token::Type::AndAnd,
2148         Lexer::Token::Type::Or,
2149         Lexer::Token::Type::Xor,
2150         Lexer::Token::Type::And
2151         })) {
2152         auto next = parsePossibleRelationalBinaryOperation();
2153         if (!next)
2154             return Unexpected&lt;Error&gt;(next.error());
2155 
2156         switch (logicalBinaryOperation-&gt;type) {
2157         case Lexer::Token::Type::OrOr:
2158             previous = makeUniqueRef&lt;AST::LogicalExpression&gt;(WTFMove(*logicalBinaryOperation), AST::LogicalExpression::Type::Or, WTFMove(previous), WTFMove(*next));
2159             break;
2160         case Lexer::Token::Type::AndAnd:
2161             previous = makeUniqueRef&lt;AST::LogicalExpression&gt;(WTFMove(*logicalBinaryOperation), AST::LogicalExpression::Type::And, WTFMove(previous), WTFMove(*next));
2162             break;
2163         case Lexer::Token::Type::Or: {
2164             Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; callArguments;
2165             callArguments.append(WTFMove(previous));
2166             callArguments.append(WTFMove(*next));
2167             previous = makeUniqueRef&lt;AST::CallExpression&gt;(WTFMove(*logicalBinaryOperation), &quot;operator|&quot;_str, WTFMove(callArguments));
2168             break;
2169         }
2170         case Lexer::Token::Type::Xor: {
2171             Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; callArguments;
2172             callArguments.append(WTFMove(previous));
2173             callArguments.append(WTFMove(*next));
2174             previous = makeUniqueRef&lt;AST::CallExpression&gt;(WTFMove(*logicalBinaryOperation), &quot;operator^&quot;_str, WTFMove(callArguments));
2175             break;
2176         }
2177         default: {
2178             ASSERT(logicalBinaryOperation-&gt;type == Lexer::Token::Type::And);
2179             Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; callArguments;
2180             callArguments.append(WTFMove(previous));
2181             callArguments.append(WTFMove(*next));
2182             previous = makeUniqueRef&lt;AST::CallExpression&gt;(WTFMove(*logicalBinaryOperation), &quot;operator&amp;&quot;_str, WTFMove(callArguments));
2183             break;
2184         }
2185         }
2186     }
2187 
2188     return { WTFMove(previous) };
2189 }
2190 
2191 auto Parser::parsePossibleRelationalBinaryOperation() -&gt; Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;
2192 {
2193     auto parsedPrevious = parsePossibleShift();
2194     if (!parsedPrevious)
2195         return Unexpected&lt;Error&gt;(parsedPrevious.error());
2196     UniqueRef&lt;AST::Expression&gt; previous = WTFMove(*parsedPrevious);
2197 
2198     while (auto relationalBinaryOperation = tryTypes({
2199         Lexer::Token::Type::LessThanSign,
2200         Lexer::Token::Type::GreaterThanSign,
2201         Lexer::Token::Type::LessThanOrEqualTo,
2202         Lexer::Token::Type::GreaterThanOrEqualTo,
2203         Lexer::Token::Type::EqualComparison,
2204         Lexer::Token::Type::NotEqual
2205         })) {
2206         auto next = parsePossibleShift();
2207         if (!next)
2208             return Unexpected&lt;Error&gt;(next.error());
2209 
2210         switch (relationalBinaryOperation-&gt;type) {
2211         case Lexer::Token::Type::LessThanSign: {
2212             Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; callArguments;
2213             callArguments.append(WTFMove(previous));
2214             callArguments.append(WTFMove(*next));
2215             previous = makeUniqueRef&lt;AST::CallExpression&gt;(WTFMove(*relationalBinaryOperation), &quot;operator&lt;&quot;_str, WTFMove(callArguments));
2216             break;
2217         }
2218         case Lexer::Token::Type::GreaterThanSign: {
2219             Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; callArguments;
2220             callArguments.append(WTFMove(previous));
2221             callArguments.append(WTFMove(*next));
2222             previous = makeUniqueRef&lt;AST::CallExpression&gt;(WTFMove(*relationalBinaryOperation), &quot;operator&gt;&quot;_str, WTFMove(callArguments));
2223             break;
2224         }
2225         case Lexer::Token::Type::LessThanOrEqualTo: {
2226             Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; callArguments;
2227             callArguments.append(WTFMove(previous));
2228             callArguments.append(WTFMove(*next));
2229             previous = makeUniqueRef&lt;AST::CallExpression&gt;(WTFMove(*relationalBinaryOperation), &quot;operator&lt;=&quot;_str, WTFMove(callArguments));
2230             break;
2231         }
2232         case Lexer::Token::Type::GreaterThanOrEqualTo: {
2233             Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; callArguments;
2234             callArguments.append(WTFMove(previous));
2235             callArguments.append(WTFMove(*next));
2236             previous = makeUniqueRef&lt;AST::CallExpression&gt;(WTFMove(*relationalBinaryOperation), &quot;operator&gt;=&quot;_str, WTFMove(callArguments));
2237             break;
2238         }
2239         case Lexer::Token::Type::EqualComparison: {
2240             Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; callArguments;
2241             callArguments.append(WTFMove(previous));
2242             callArguments.append(WTFMove(*next));
2243             previous = makeUniqueRef&lt;AST::CallExpression&gt;(WTFMove(*relationalBinaryOperation), &quot;operator==&quot;_str, WTFMove(callArguments));
2244             break;
2245         }
2246         default: {
2247             ASSERT(relationalBinaryOperation-&gt;type == Lexer::Token::Type::NotEqual);
2248             Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; callArguments;
2249             callArguments.append(WTFMove(previous));
2250             callArguments.append(WTFMove(*next));
2251             previous = makeUniqueRef&lt;AST::CallExpression&gt;(Lexer::Token(*relationalBinaryOperation), &quot;operator==&quot;_str, WTFMove(callArguments));
2252             previous = makeUniqueRef&lt;AST::LogicalNotExpression&gt;(WTFMove(*relationalBinaryOperation), WTFMove(previous));
2253             break;
2254         }
2255         }
2256     }
2257 
2258     return WTFMove(previous);
2259 }
2260 
2261 auto Parser::parsePossibleShift() -&gt; Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;
2262 {
2263     auto parsedPrevious = parsePossibleAdd();
2264     if (!parsedPrevious)
2265         return Unexpected&lt;Error&gt;(parsedPrevious.error());
2266     UniqueRef&lt;AST::Expression&gt; previous = WTFMove(*parsedPrevious);
2267 
2268     while (auto shift = tryTypes({
2269         Lexer::Token::Type::LeftShift,
2270         Lexer::Token::Type::RightShift
2271         })) {
2272         auto next = parsePossibleAdd();
2273         if (!next)
2274             return Unexpected&lt;Error&gt;(next.error());
2275 
2276         switch (shift-&gt;type) {
2277         case Lexer::Token::Type::LeftShift: {
2278             Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; callArguments;
2279             callArguments.append(WTFMove(previous));
2280             callArguments.append(WTFMove(*next));
2281             previous = makeUniqueRef&lt;AST::CallExpression&gt;(WTFMove(*shift), &quot;operator&lt;&lt;&quot;_str, WTFMove(callArguments));
2282             break;
2283         }
2284         default: {
2285             ASSERT(shift-&gt;type == Lexer::Token::Type::RightShift);
2286             Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; callArguments;
2287             callArguments.append(WTFMove(previous));
2288             callArguments.append(WTFMove(*next));
2289             previous = makeUniqueRef&lt;AST::CallExpression&gt;(WTFMove(*shift), &quot;operator&gt;&gt;&quot;_str, WTFMove(callArguments));
2290             break;
2291         }
2292         }
2293     }
2294 
2295     return WTFMove(previous);
2296 }
2297 
2298 auto Parser::parsePossibleAdd() -&gt; Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;
2299 {
2300     auto parsedPrevious = parsePossibleMultiply();
2301     if (!parsedPrevious)
2302         return Unexpected&lt;Error&gt;(parsedPrevious.error());
2303     UniqueRef&lt;AST::Expression&gt; previous = WTFMove(*parsedPrevious);
2304 
2305     while (auto add = tryTypes({
2306         Lexer::Token::Type::Plus,
2307         Lexer::Token::Type::Minus
2308         })) {
2309         auto next = parsePossibleMultiply();
2310         if (!next)
2311             return Unexpected&lt;Error&gt;(next.error());
2312 
2313         switch (add-&gt;type) {
2314         case Lexer::Token::Type::Plus: {
2315             Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; callArguments;
2316             callArguments.append(WTFMove(previous));
2317             callArguments.append(WTFMove(*next));
2318             previous = makeUniqueRef&lt;AST::CallExpression&gt;(WTFMove(*add), &quot;operator+&quot;_str, WTFMove(callArguments));
2319             break;
2320         }
2321         default: {
2322             ASSERT(add-&gt;type == Lexer::Token::Type::Minus);
2323             Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; callArguments;
2324             callArguments.append(WTFMove(previous));
2325             callArguments.append(WTFMove(*next));
2326             previous = makeUniqueRef&lt;AST::CallExpression&gt;(WTFMove(*add), &quot;operator-&quot;_str, WTFMove(callArguments));
2327             break;
2328         }
2329         }
2330     }
2331 
2332     return WTFMove(previous);
2333 }
2334 
2335 auto Parser::parsePossibleMultiply() -&gt; Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;
2336 {
2337     auto parsedPrevious = parsePossiblePrefix();
2338     if (!parsedPrevious)
2339         return Unexpected&lt;Error&gt;(parsedPrevious.error());
2340     UniqueRef&lt;AST::Expression&gt; previous = WTFMove(*parsedPrevious);
2341 
2342     while (auto multiply = tryTypes({
2343         Lexer::Token::Type::Star,
2344         Lexer::Token::Type::Divide,
2345         Lexer::Token::Type::Mod
2346         })) {
2347         auto next = parsePossiblePrefix();
2348         if (!next)
2349             return Unexpected&lt;Error&gt;(next.error());
2350 
2351         switch (multiply-&gt;type) {
2352         case Lexer::Token::Type::Star: {
2353             Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; callArguments;
2354             callArguments.append(WTFMove(previous));
2355             callArguments.append(WTFMove(*next));
2356             previous = makeUniqueRef&lt;AST::CallExpression&gt;(WTFMove(*multiply), &quot;operator*&quot;_str, WTFMove(callArguments));
2357             break;
2358         }
2359         case Lexer::Token::Type::Divide: {
2360             Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; callArguments;
2361             callArguments.append(WTFMove(previous));
2362             callArguments.append(WTFMove(*next));
2363             previous = makeUniqueRef&lt;AST::CallExpression&gt;(WTFMove(*multiply), &quot;operator/&quot;_str, WTFMove(callArguments));
2364             break;
2365         }
2366         default: {
2367             ASSERT(multiply-&gt;type == Lexer::Token::Type::Mod);
2368             Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; callArguments;
2369             callArguments.append(WTFMove(previous));
2370             callArguments.append(WTFMove(*next));
2371             previous = makeUniqueRef&lt;AST::CallExpression&gt;(WTFMove(*multiply), &quot;operator%&quot;_str, WTFMove(callArguments));
2372             break;
2373         }
2374         }
2375     }
2376 
2377     return WTFMove(previous);
2378 }
2379 
2380 auto Parser::parsePossiblePrefix() -&gt; Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;
2381 {
2382     if (auto prefix = tryTypes({
2383         Lexer::Token::Type::PlusPlus,
2384         Lexer::Token::Type::MinusMinus,
2385         Lexer::Token::Type::Plus,
2386         Lexer::Token::Type::Minus,
2387         Lexer::Token::Type::Tilde,
2388         Lexer::Token::Type::ExclamationPoint,
2389         Lexer::Token::Type::And,
2390         Lexer::Token::Type::At,
2391         Lexer::Token::Type::Star
2392     })) {
2393         auto next = parsePossiblePrefix();
2394         if (!next)
2395             return Unexpected&lt;Error&gt;(next.error());
2396 
2397         switch (prefix-&gt;type) {
2398         case Lexer::Token::Type::PlusPlus: {
2399             auto result = AST::ReadModifyWriteExpression::create(Lexer::Token(*prefix), WTFMove(*next));
2400             Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; callArguments;
2401             callArguments.append(result-&gt;oldVariableReference());
2402             result-&gt;setNewValueExpression(makeUniqueRef&lt;AST::CallExpression&gt;(Lexer::Token(*prefix), &quot;operator++&quot;_str, WTFMove(callArguments)));
2403             result-&gt;setResultExpression(result-&gt;newVariableReference());
2404             return { WTFMove(result) };
2405         }
2406         case Lexer::Token::Type::MinusMinus: {
2407             auto result = AST::ReadModifyWriteExpression::create(Lexer::Token(*prefix), WTFMove(*next));
2408             Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; callArguments;
2409             callArguments.append(result-&gt;oldVariableReference());
2410             result-&gt;setNewValueExpression(makeUniqueRef&lt;AST::CallExpression&gt;(Lexer::Token(*prefix), &quot;operator--&quot;_str, WTFMove(callArguments)));
2411             result-&gt;setResultExpression(result-&gt;newVariableReference());
2412             return { WTFMove(result) };
2413         }
2414         case Lexer::Token::Type::Plus: {
2415             Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; callArguments;
2416             callArguments.append(WTFMove(*next));
2417             return { makeUniqueRef&lt;AST::CallExpression&gt;(Lexer::Token(*prefix), &quot;operator+&quot;_str, WTFMove(callArguments)) };
2418         }
2419         case Lexer::Token::Type::Minus: {
2420             Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; callArguments;
2421             callArguments.append(WTFMove(*next));
2422             return { makeUniqueRef&lt;AST::CallExpression&gt;(Lexer::Token(*prefix), &quot;operator-&quot;_str, WTFMove(callArguments)) };
2423         }
2424         case Lexer::Token::Type::Tilde: {
2425             Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; callArguments;
2426             callArguments.append(WTFMove(*next));
2427             return { makeUniqueRef&lt;AST::CallExpression&gt;(Lexer::Token(*prefix), &quot;operator~&quot;_str, WTFMove(callArguments)) };
2428         }
2429         case Lexer::Token::Type::ExclamationPoint: {
2430             Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; castArguments;
2431             castArguments.append(WTFMove(*next));
2432             auto boolCast = makeUniqueRef&lt;AST::CallExpression&gt;(Lexer::Token(*prefix), &quot;bool&quot;_str, WTFMove(castArguments));
2433             return { makeUniqueRef&lt;AST::LogicalNotExpression&gt;(Lexer::Token(*prefix), WTFMove(boolCast)) };
2434         }
2435         case Lexer::Token::Type::And:
2436             return { makeUniqueRef&lt;AST::MakePointerExpression&gt;(Lexer::Token(*prefix), WTFMove(*next)) };
2437         case Lexer::Token::Type::At:
2438             return { makeUniqueRef&lt;AST::MakeArrayReferenceExpression&gt;(Lexer::Token(*prefix), WTFMove(*next)) };
2439         default:
2440             ASSERT(prefix-&gt;type == Lexer::Token::Type::Star);
2441             return { makeUniqueRef&lt;AST::DereferenceExpression&gt;(Lexer::Token(*prefix), WTFMove(*next)) };
2442         }
2443     }
2444 
2445     return parsePossibleSuffix();
2446 }
2447 
2448 auto Parser::parsePossibleSuffix() -&gt; Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;
2449 {
2450     auto suffix = backtrackingScope&lt;Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;&gt;([&amp;]() -&gt; Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt; {
2451         auto expression = parseCallExpression();
2452         if (!expression)
2453             return Unexpected&lt;Error&gt;(expression.error());
2454 
2455         while (true) {
2456             auto result = backtrackingScope&lt;SuffixExpression&gt;([&amp;]() -&gt; SuffixExpression {
2457                 return parseLimitedSuffixOperator(WTFMove(*expression));
2458             });
2459             expression = WTFMove(result.result);
2460             if (!result)
2461                 break;
2462         }
2463         return expression;
2464     });
2465     if (suffix)
2466         return suffix;
2467 
2468     suffix = backtrackingScope&lt;Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;&gt;([&amp;]() -&gt; Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt; {
2469         auto expression = parseTerm();
2470         if (!expression)
2471             return Unexpected&lt;Error&gt;(expression.error());
2472 
2473         while (true) {
2474             auto result = backtrackingScope&lt;SuffixExpression&gt;([&amp;]() -&gt; SuffixExpression {
2475                 return parseSuffixOperator(WTFMove(*expression));
2476             });
2477             expression = WTFMove(result.result);
2478             if (!result)
2479                 break;
2480         }
2481         return expression;
2482     });
2483     if (suffix)
2484         return suffix;
2485 
2486     return Unexpected&lt;Error&gt;(suffix.error());
2487 }
2488 
2489 auto Parser::parseCallExpression() -&gt; Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;
2490 {
2491     auto name = consumeType(Lexer::Token::Type::Identifier);
2492     if (!name)
2493         return Unexpected&lt;Error&gt;(name.error());
2494     auto callName = name-&gt;stringView.toString();
2495 
2496     auto leftParenthesis = consumeType(Lexer::Token::Type::LeftParenthesis);
2497     if (!leftParenthesis)
2498         return Unexpected&lt;Error&gt;(leftParenthesis.error());
2499 
2500     Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; arguments;
2501     if (tryType(Lexer::Token::Type::RightParenthesis))
2502         return { makeUniqueRef&lt;AST::CallExpression&gt;(WTFMove(*name), WTFMove(callName), WTFMove(arguments)) };
2503 
2504     auto firstArgument = parsePossibleTernaryConditional();
2505     if (!firstArgument)
2506         return Unexpected&lt;Error&gt;(firstArgument.error());
2507     arguments.append(WTFMove(*firstArgument));
2508     while (tryType(Lexer::Token::Type::Comma)) {
2509         auto argument = parsePossibleTernaryConditional();
2510         if (!argument)
2511             return Unexpected&lt;Error&gt;(argument.error());
2512         arguments.append(WTFMove(*argument));
2513     }
2514 
2515     auto rightParenthesis = consumeType(Lexer::Token::Type::RightParenthesis);
2516     if (!rightParenthesis)
2517         return Unexpected&lt;Error&gt;(rightParenthesis.error());
2518 
2519     return { makeUniqueRef&lt;AST::CallExpression&gt;(WTFMove(*name), WTFMove(callName), WTFMove(arguments)) };
2520 }
2521 
2522 auto Parser::parseTerm() -&gt; Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;
2523 {
2524     auto type = consumeTypes({
2525         Lexer::Token::Type::IntLiteral,
2526         Lexer::Token::Type::UintLiteral,
2527         Lexer::Token::Type::FloatLiteral,
2528         Lexer::Token::Type::Null,
2529         Lexer::Token::Type::True,
2530         Lexer::Token::Type::False,
2531         Lexer::Token::Type::Identifier,
2532         Lexer::Token::Type::LeftParenthesis
2533     });
2534     if (!type)
2535         return Unexpected&lt;Error&gt;(type.error());
2536 
2537     switch (type-&gt;type) {
2538     case Lexer::Token::Type::IntLiteral: {
2539         auto value = intLiteralToInt(type-&gt;stringView);
2540         if (!value)
2541             return Unexpected&lt;Error&gt;(value.error());
2542         return { makeUniqueRef&lt;AST::IntegerLiteral&gt;(WTFMove(*type), *value) };
2543     }
2544     case Lexer::Token::Type::UintLiteral: {
2545         auto value = uintLiteralToUint(type-&gt;stringView);
2546         if (!value)
2547             return Unexpected&lt;Error&gt;(value.error());
2548         return { makeUniqueRef&lt;AST::UnsignedIntegerLiteral&gt;(WTFMove(*type), *value) };
2549     }
2550     case Lexer::Token::Type::FloatLiteral: {
2551         auto value = floatLiteralToFloat(type-&gt;stringView);
2552         if (!value)
2553             return Unexpected&lt;Error&gt;(value.error());
2554         return { makeUniqueRef&lt;AST::FloatLiteral&gt;(WTFMove(*type), *value) };
2555     }
2556     case Lexer::Token::Type::Null:
2557         return { makeUniqueRef&lt;AST::NullLiteral&gt;(WTFMove(*type)) };
2558     case Lexer::Token::Type::True:
2559         return { makeUniqueRef&lt;AST::BooleanLiteral&gt;(WTFMove(*type), true) };
2560     case Lexer::Token::Type::False:
2561         return { makeUniqueRef&lt;AST::BooleanLiteral&gt;(WTFMove(*type), false) };
2562     case Lexer::Token::Type::Identifier: {
2563         auto name = type-&gt;stringView.toString();
2564         return { makeUniqueRef&lt;AST::VariableReference&gt;(WTFMove(*type), WTFMove(name)) };
2565     }
2566     default: {
2567         ASSERT(type-&gt;type == Lexer::Token::Type::LeftParenthesis);
2568         auto expression = parseExpression();
2569         if (!expression)
2570             return Unexpected&lt;Error&gt;(expression.error());
2571 
2572         auto rightParenthesis = consumeType(Lexer::Token::Type::RightParenthesis);
2573         if (!rightParenthesis)
2574             return Unexpected&lt;Error&gt;(rightParenthesis.error());
2575 
2576         return { WTFMove(*expression) };
2577     }
2578     }
2579 }
2580 
2581 } // namespace WHLSL
2582 
2583 } // namespace WebCore
2584 
2585 #endif // ENABLE(WEBGPU)
    </pre>
  </body>
</html>