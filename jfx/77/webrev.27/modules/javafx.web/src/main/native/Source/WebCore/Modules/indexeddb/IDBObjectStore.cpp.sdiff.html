<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/Modules/indexeddb/IDBObjectStore.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="IDBKeyRange.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="IDBObjectStore.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/Modules/indexeddb/IDBObjectStore.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
132         for (auto&amp; name : m_info.indexNames())
133             indexNames-&gt;append(name);
134         indexNames-&gt;sort();
135     }
136 
137     return indexNames;
138 }
139 
140 IDBTransaction&amp; IDBObjectStore::transaction()
141 {
142     ASSERT(&amp;m_transaction.database().originThread() == &amp;Thread::current());
143     return m_transaction;
144 }
145 
146 bool IDBObjectStore::autoIncrement() const
147 {
148     ASSERT(&amp;m_transaction.database().originThread() == &amp;Thread::current());
149     return m_info.autoIncrement();
150 }
151 
<span class="line-modified">152 ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBObjectStore::openCursor(ExecState&amp; execState, RefPtr&lt;IDBKeyRange&gt; range, IDBCursorDirection direction)</span>
153 {
154     LOG(IndexedDB, &quot;IDBObjectStore::openCursor&quot;);
155     ASSERT(&amp;m_transaction.database().originThread() == &amp;Thread::current());
156 
157     if (m_deleted)
158         return Exception { InvalidStateError, &quot;Failed to execute &#39;openCursor&#39; on &#39;IDBObjectStore&#39;: The object store has been deleted.&quot;_s };
159 
160     if (!m_transaction.isActive())
161         return Exception { TransactionInactiveError, &quot;Failed to execute &#39;openCursor&#39; on &#39;IDBObjectStore&#39;: The transaction is inactive or finished.&quot;_s };
162 
<span class="line-modified">163     auto info = IDBCursorInfo::objectStoreCursor(m_transaction, m_info.identifier(), range.get(), direction, IndexedDB::CursorType::KeyAndValue);</span>





164     return m_transaction.requestOpenCursor(execState, *this, info);
165 }
166 







167 ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBObjectStore::openCursor(ExecState&amp; execState, JSValue key, IDBCursorDirection direction)
168 {
<span class="line-modified">169     auto onlyResult = IDBKeyRange::only(execState, key);</span>
<span class="line-modified">170     if (onlyResult.hasException())</span>
<span class="line-modified">171         return Exception { DataError, &quot;Failed to execute &#39;openCursor&#39; on &#39;IDBObjectStore&#39;: The parameter is not a valid key.&quot;_s };</span>

172 
<span class="line-modified">173     return openCursor(execState, onlyResult.releaseReturnValue(), direction);</span>

174 }
175 
<span class="line-modified">176 ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBObjectStore::openKeyCursor(ExecState&amp; execState, RefPtr&lt;IDBKeyRange&gt; range, IDBCursorDirection direction)</span>
177 {
<span class="line-modified">178     LOG(IndexedDB, &quot;IDBObjectStore::openCursor&quot;);</span>
179     ASSERT(&amp;m_transaction.database().originThread() == &amp;Thread::current());
180 
181     if (m_deleted)
182         return Exception { InvalidStateError, &quot;Failed to execute &#39;openKeyCursor&#39; on &#39;IDBObjectStore&#39;: The object store has been deleted.&quot;_s };
183 
184     if (!m_transaction.isActive())
185         return Exception { TransactionInactiveError, &quot;Failed to execute &#39;openKeyCursor&#39; on &#39;IDBObjectStore&#39;: The transaction is inactive or finished.&quot;_s };
186 
<span class="line-modified">187     auto info = IDBCursorInfo::objectStoreCursor(m_transaction, m_info.identifier(), range.get(), direction, IndexedDB::CursorType::KeyOnly);</span>





188     return m_transaction.requestOpenCursor(execState, *this, info);
189 }
190 







191 ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBObjectStore::openKeyCursor(ExecState&amp; execState, JSValue key, IDBCursorDirection direction)
192 {
<span class="line-modified">193     auto onlyResult = IDBKeyRange::only(execState, key);</span>
<span class="line-modified">194     if (onlyResult.hasException())</span>
<span class="line-modified">195         return Exception { DataError, &quot;Failed to execute &#39;openKeyCursor&#39; on &#39;IDBObjectStore&#39;: The parameter is not a valid key or key range.&quot;_s };</span>

196 
<span class="line-modified">197     return openKeyCursor(execState, onlyResult.releaseReturnValue(), direction);</span>

198 }
199 
200 ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBObjectStore::get(ExecState&amp; execState, JSValue key)
201 {
202     LOG(IndexedDB, &quot;IDBObjectStore::get&quot;);
203     ASSERT(&amp;m_transaction.database().originThread() == &amp;Thread::current());
204 
205     if (m_deleted)
206         return Exception { InvalidStateError, &quot;Failed to execute &#39;get&#39; on &#39;IDBObjectStore&#39;: The object store has been deleted.&quot;_s };
207 
208     if (!m_transaction.isActive())
209         return Exception { TransactionInactiveError, &quot;Failed to execute &#39;get&#39; on &#39;IDBObjectStore&#39;: The transaction is inactive or finished.&quot;_s };
210 
211     auto idbKey = scriptValueToIDBKey(execState, key);
212     if (!idbKey-&gt;isValid())
213         return Exception { DataError, &quot;Failed to execute &#39;get&#39; on &#39;IDBObjectStore&#39;: The parameter is not a valid key.&quot;_s };
214 
215     return m_transaction.requestGetRecord(execState, *this, { idbKey.ptr(), IDBGetRecordDataType::KeyAndValue });
216 }
217 
</pre>
<hr />
<pre>
295     VM&amp; vm = state.vm();
296     auto scope = DECLARE_CATCH_SCOPE(vm);
297 
298     LOG(IndexedDB, &quot;IDBObjectStore::putOrAdd&quot;);
299     ASSERT(&amp;m_transaction.database().originThread() == &amp;Thread::current());
300 
301     auto context = scriptExecutionContextFromExecState(&amp;state);
302     if (!context)
303         return Exception { UnknownError, &quot;Unable to store record in object store because it does not have a valid script execution context&quot;_s };
304 
305     if (m_deleted)
306         return Exception { InvalidStateError, &quot;Failed to store record in an IDBObjectStore: The object store has been deleted.&quot;_s };
307 
308     if (!m_transaction.isActive())
309         return Exception { TransactionInactiveError, &quot;Failed to store record in an IDBObjectStore: The transaction is inactive or finished.&quot;_s };
310 
311     if (m_transaction.isReadOnly())
312         return Exception { ReadonlyError, &quot;Failed to store record in an IDBObjectStore: The transaction is read-only.&quot;_s };
313 
314     auto serializedValue = SerializedScriptValue::create(state, value);
<span class="line-modified">315     if (UNLIKELY(scope.exception())) {</span>
<span class="line-removed">316         // Clear the DOM exception from the serializer so we can give a more targeted exception.</span>
<span class="line-removed">317         scope.clearException();</span>
<span class="line-removed">318 </span>
319         return Exception { DataCloneError, &quot;Failed to store record in an IDBObjectStore: An object could not be cloned.&quot;_s };
<span class="line-removed">320     }</span>
321 
322     bool privateBrowsingEnabled = false;
323     if (is&lt;Document&gt;(*context)) {
324         if (auto* page = downcast&lt;Document&gt;(*context).page())
325             privateBrowsingEnabled = page-&gt;sessionID().isEphemeral();
326     }
327 
328     if (serializedValue-&gt;hasBlobURLs() &amp;&amp; privateBrowsingEnabled) {
329         // https://bugs.webkit.org/show_bug.cgi?id=156347 - Support Blobs in private browsing.
330         return Exception { DataCloneError, &quot;Failed to store record in an IDBObjectStore: BlobURLs are not yet supported.&quot;_s };
331     }
332 
333     if (key &amp;&amp; !key-&gt;isValid())
334         return Exception { DataError, &quot;Failed to store record in an IDBObjectStore: The parameter is not a valid key.&quot;_s };
335 
336     bool usesInlineKeys = !!m_info.keyPath();
337     bool usesKeyGenerator = autoIncrement();
338     if (usesInlineKeys &amp;&amp; inlineKeyCheck == InlineKeyCheck::Perform) {
339         if (key)
340             return Exception { DataError, &quot;Failed to store record in an IDBObjectStore: The object store uses in-line keys and the key parameter was provided.&quot;_s };
</pre>
<hr />
<pre>
345 
346         if (!keyPathKey) {
347             if (!usesKeyGenerator)
348                 return Exception { DataError, &quot;Failed to store record in an IDBObjectStore: Evaluating the object store&#39;s key path did not yield a value.&quot;_s };
349             if (!canInjectIDBKeyIntoScriptValue(state, value, m_info.keyPath().value()))
350                 return Exception { DataError };
351         }
352 
353         if (keyPathKey) {
354             ASSERT(!key);
355             key = keyPathKey;
356         }
357     } else if (!usesKeyGenerator &amp;&amp; !key)
358         return Exception { DataError, &quot;Failed to store record in an IDBObjectStore: The object store uses out-of-line keys and has no key generator and the key parameter was not provided.&quot;_s };
359 
360     return m_transaction.requestPutOrAdd(state, *this, WTFMove(key), *serializedValue, overwriteMode);
361 }
362 
363 ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBObjectStore::deleteFunction(ExecState&amp; execState, IDBKeyRange* keyRange)
364 {
<span class="line-modified">365     return doDelete(execState, keyRange);</span>


366 }
367 
<span class="line-modified">368 ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBObjectStore::doDelete(ExecState&amp; execState, IDBKeyRange* keyRange)</span>
369 {
370     LOG(IndexedDB, &quot;IDBObjectStore::deleteFunction&quot;);
371     ASSERT(&amp;m_transaction.database().originThread() == &amp;Thread::current());
372 
373     // The IDB spec for several IDBObjectStore methods states that transaction related exceptions should fire before
374     // the exception for an object store being deleted.
375     // However, a handful of W3C IDB tests expect the deleted exception even though the transaction inactive exception also applies.
376     // Additionally, Chrome and Edge agree with the test, as does Legacy IDB in WebKit.
377     // Until this is sorted out, we&#39;ll agree with the test and the majority share browsers.
378     if (m_deleted)
379         return Exception { InvalidStateError, &quot;Failed to execute &#39;delete&#39; on &#39;IDBObjectStore&#39;: The object store has been deleted.&quot;_s };
380 
381     if (!m_transaction.isActive())
382         return Exception { TransactionInactiveError, &quot;Failed to execute &#39;delete&#39; on &#39;IDBObjectStore&#39;: The transaction is inactive or finished.&quot;_s };
383 
384     if (m_transaction.isReadOnly())
385         return Exception { ReadonlyError, &quot;Failed to execute &#39;delete&#39; on &#39;IDBObjectStore&#39;: The transaction is read-only.&quot;_s };
386 
<span class="line-modified">387     IDBKeyRangeData keyRangeData(keyRange);</span>




388     if (!keyRangeData.isValid())
389         return Exception { DataError, &quot;Failed to execute &#39;delete&#39; on &#39;IDBObjectStore&#39;: The parameter is not a valid key range.&quot;_s };
390 
391     return m_transaction.requestDeleteRecord(execState, *this, keyRangeData);
392 }
393 
394 ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBObjectStore::deleteFunction(ExecState&amp; execState, JSValue key)
395 {
<span class="line-modified">396     Ref&lt;IDBKey&gt; idbKey = scriptValueToIDBKey(execState, key);</span>
<span class="line-modified">397     if (!idbKey-&gt;isValid())</span>
<span class="line-modified">398         return Exception { DataError, &quot;Failed to execute &#39;delete&#39; on &#39;IDBObjectStore&#39;: The parameter is not a valid key.&quot;_s };</span>
<span class="line-modified">399     return doDelete(execState, IDBKeyRange::create(WTFMove(idbKey)).ptr());</span>


400 }
401 
402 ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBObjectStore::clear(ExecState&amp; execState)
403 {
404     LOG(IndexedDB, &quot;IDBObjectStore::clear&quot;);
405     ASSERT(&amp;m_transaction.database().originThread() == &amp;Thread::current());
406 
407     // The IDB spec for several IDBObjectStore methods states that transaction related exceptions should fire before
408     // the exception for an object store being deleted.
409     // However, a handful of W3C IDB tests expect the deleted exception even though the transaction inactive exception also applies.
410     // Additionally, Chrome and Edge agree with the test, as does Legacy IDB in WebKit.
411     // Until this is sorted out, we&#39;ll agree with the test and the majority share browsers.
412     if (m_deleted)
413         return Exception { InvalidStateError, &quot;Failed to execute &#39;clear&#39; on &#39;IDBObjectStore&#39;: The object store has been deleted.&quot;_s };
414 
415     if (!m_transaction.isActive())
416         return Exception { TransactionInactiveError, &quot;Failed to execute &#39;clear&#39; on &#39;IDBObjectStore&#39;: The transaction is inactive or finished.&quot;_s };
417 
418     if (m_transaction.isReadOnly())
419         return Exception { ReadonlyError, &quot;Failed to execute &#39;clear&#39; on &#39;IDBObjectStore&#39;: The transaction is read-only.&quot;_s };
</pre>
<hr />
<pre>
442         return Exception { SyntaxError, &quot;Failed to execute &#39;createIndex&#39; on &#39;IDBObjectStore&#39;: The keyPath argument contains an invalid key path.&quot;_s };
443 
444     if (name.isNull())
445         return Exception { TypeError };
446 
447     if (parameters.multiEntry &amp;&amp; WTF::holds_alternative&lt;Vector&lt;String&gt;&gt;(keyPath))
448         return Exception { InvalidAccessError, &quot;Failed to execute &#39;createIndex&#39; on &#39;IDBObjectStore&#39;: The keyPath argument was an array and the multiEntry option is true.&quot;_s };
449 
450     // Install the new Index into the ObjectStore&#39;s info.
451     IDBIndexInfo info = m_info.createNewIndex(name, WTFMove(keyPath), parameters.unique, parameters.multiEntry);
452     m_transaction.database().didCreateIndexInfo(info);
453 
454     // Create the actual IDBObjectStore from the transaction, which also schedules the operation server side.
455     auto index = m_transaction.createIndex(*this, info);
456 
457     Ref&lt;IDBIndex&gt; referencedIndex { *index };
458 
459     Locker&lt;Lock&gt; locker(m_referencedIndexLock);
460     m_referencedIndexes.set(name, WTFMove(index));
461 
<span class="line-modified">462     return WTFMove(referencedIndex);</span>
463 }
464 
465 ExceptionOr&lt;Ref&lt;IDBIndex&gt;&gt; IDBObjectStore::index(const String&amp; indexName)
466 {
467     LOG(IndexedDB, &quot;IDBObjectStore::index&quot;);
468     ASSERT(&amp;m_transaction.database().originThread() == &amp;Thread::current());
469 
470     if (!scriptExecutionContext())
471         return Exception { InvalidStateError }; // FIXME: Is this code tested? Is iteven reachable?
472 
473     if (m_deleted)
474         return Exception { InvalidStateError, &quot;Failed to execute &#39;index&#39; on &#39;IDBObjectStore&#39;: The object store has been deleted.&quot;_s };
475 
476     if (m_transaction.isFinishedOrFinishing())
477         return Exception { InvalidStateError, &quot;Failed to execute &#39;index&#39; on &#39;IDBObjectStore&#39;: The transaction is finished.&quot;_s };
478 
479     Locker&lt;Lock&gt; locker(m_referencedIndexLock);
480     auto iterator = m_referencedIndexes.find(indexName);
481     if (iterator != m_referencedIndexes.end())
482         return Ref&lt;IDBIndex&gt; { *iterator-&gt;value };
483 
484     auto* info = m_info.infoForExistingIndex(indexName);
485     if (!info)
486         return Exception { NotFoundError, &quot;Failed to execute &#39;index&#39; on &#39;IDBObjectStore&#39;: The specified index was not found.&quot;_s };
487 
<span class="line-modified">488     auto index = std::make_unique&lt;IDBIndex&gt;(*scriptExecutionContext(), *info, *this);</span>
489 
490     Ref&lt;IDBIndex&gt; referencedIndex { *index };
491 
492     m_referencedIndexes.set(indexName, WTFMove(index));
493 
<span class="line-modified">494     return WTFMove(referencedIndex);</span>
495 }
496 
497 ExceptionOr&lt;void&gt; IDBObjectStore::deleteIndex(const String&amp; name)
498 {
499     LOG(IndexedDB, &quot;IDBObjectStore::deleteIndex %s&quot;, name.utf8().data());
500     ASSERT(&amp;m_transaction.database().originThread() == &amp;Thread::current());
501 
502     if (m_deleted)
503         return Exception { InvalidStateError, &quot;Failed to execute &#39;deleteIndex&#39; on &#39;IDBObjectStore&#39;: The object store has been deleted.&quot;_s };
504 
505     if (!m_transaction.isVersionChange())
506         return Exception { InvalidStateError, &quot;Failed to execute &#39;deleteIndex&#39; on &#39;IDBObjectStore&#39;: The database is not running a version change transaction.&quot;_s };
507 
508     if (!m_transaction.isActive())
509         return Exception { TransactionInactiveError,  &quot;Failed to execute &#39;deleteIndex&#39; on &#39;IDBObjectStore&#39;: The transaction is inactive or finished.&quot;_s };
510 
511     if (!m_info.hasIndex(name))
512         return Exception { NotFoundError, &quot;Failed to execute &#39;deleteIndex&#39; on &#39;IDBObjectStore&#39;: The specified index was not found.&quot;_s };
513 
514     auto* info = m_info.infoForExistingIndex(name);
</pre>
<hr />
<pre>
518     m_info.deleteIndex(name);
519 
520     {
521         Locker&lt;Lock&gt; locker(m_referencedIndexLock);
522         if (auto index = m_referencedIndexes.take(name)) {
523             index-&gt;markAsDeleted();
524             auto identifier = index-&gt;info().identifier();
525             m_deletedIndexes.add(identifier, WTFMove(index));
526         }
527     }
528 
529     m_transaction.deleteIndex(m_info.identifier(), name);
530 
531     return { };
532 }
533 
534 ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBObjectStore::count(ExecState&amp; execState, JSValue key)
535 {
536     LOG(IndexedDB, &quot;IDBObjectStore::count&quot;);
537 
<span class="line-modified">538     Ref&lt;IDBKey&gt; idbKey = scriptValueToIDBKey(execState, key);</span>
<span class="line-removed">539     if (!idbKey-&gt;isValid())</span>
<span class="line-removed">540         return Exception { DataError, &quot;Failed to execute &#39;count&#39; on &#39;IDBObjectStore&#39;: The parameter is not a valid key.&quot;_s };</span>
541 
<span class="line-modified">542     return doCount(execState, IDBKeyRangeData(idbKey.ptr()));</span>
543 }
544 
545 ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBObjectStore::count(ExecState&amp; execState, IDBKeyRange* range)
546 {
547     LOG(IndexedDB, &quot;IDBObjectStore::count&quot;);
548 
549     return doCount(execState, range ? IDBKeyRangeData(range) : IDBKeyRangeData::allKeys());
550 }
551 
552 ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBObjectStore::doCount(ExecState&amp; execState, const IDBKeyRangeData&amp; range)
553 {
554     ASSERT(&amp;m_transaction.database().originThread() == &amp;Thread::current());
555 
556     // The IDB spec for several IDBObjectStore methods states that transaction related exceptions should fire before
557     // the exception for an object store being deleted.
558     // However, a handful of W3C IDB tests expect the deleted exception even though the transaction inactive exception also applies.
559     // Additionally, Chrome and Edge agree with the test, as does Legacy IDB in WebKit.
560     // Until this is sorted out, we&#39;ll agree with the test and the majority share browsers.
561     if (m_deleted)
562         return Exception { InvalidStateError, &quot;Failed to execute &#39;count&#39; on &#39;IDBObjectStore&#39;: The object store has been deleted.&quot;_s };
563 
564     if (!m_transaction.isActive())
565         return Exception { TransactionInactiveError, &quot;Failed to execute &#39;count&#39; on &#39;IDBObjectStore&#39;: The transaction is inactive or finished.&quot;_s };
566 
567     if (!range.isValid())
<span class="line-modified">568         return Exception { DataError };</span>
569 
570     return m_transaction.requestCount(execState, *this, range);
571 }
572 
<span class="line-modified">573 ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBObjectStore::getAll(ExecState&amp; execState, RefPtr&lt;IDBKeyRange&gt; range, Optional&lt;uint32_t&gt; count)</span>
574 {
575     LOG(IndexedDB, &quot;IDBObjectStore::getAll&quot;);
576     ASSERT(&amp;m_transaction.database().originThread() == &amp;Thread::current());
577 
578     if (m_deleted)
579         return Exception { InvalidStateError, &quot;Failed to execute &#39;getAll&#39; on &#39;IDBObjectStore&#39;: The object store has been deleted.&quot;_s };
580 
581     if (!m_transaction.isActive())
582         return Exception { TransactionInactiveError, &quot;Failed to execute &#39;getAll&#39; on &#39;IDBObjectStore&#39;: The transaction is inactive or finished.&quot;_s };
583 
<span class="line-modified">584     return m_transaction.requestGetAllObjectStoreRecords(execState, *this, range.get(), IndexedDB::GetAllType::Values, count);</span>












585 }
586 
587 ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBObjectStore::getAll(ExecState&amp; execState, JSValue key, Optional&lt;uint32_t&gt; count)
588 {
<span class="line-modified">589     auto onlyResult = IDBKeyRange::only(execState, key);</span>
<span class="line-modified">590     if (onlyResult.hasException())</span>
<span class="line-modified">591         return Exception { DataError, &quot;Failed to execute &#39;getAll&#39; on &#39;IDBObjectStore&#39;: The parameter is not a valid key.&quot;_s };</span>

592 
<span class="line-modified">593     return getAll(execState, onlyResult.releaseReturnValue(), count);</span>

594 }
595 
<span class="line-modified">596 ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBObjectStore::getAllKeys(ExecState&amp; execState, RefPtr&lt;IDBKeyRange&gt; range, Optional&lt;uint32_t&gt; count)</span>
597 {
598     LOG(IndexedDB, &quot;IDBObjectStore::getAllKeys&quot;);
599     ASSERT(&amp;m_transaction.database().originThread() == &amp;Thread::current());
600 
601     if (m_deleted)
602         return Exception { InvalidStateError, &quot;Failed to execute &#39;getAllKeys&#39; on &#39;IDBObjectStore&#39;: The object store has been deleted.&quot;_s };
603 
604     if (!m_transaction.isActive())
605         return Exception { TransactionInactiveError, &quot;Failed to execute &#39;getAllKeys&#39; on &#39;IDBObjectStore&#39;: The transaction is inactive or finished.&quot;_s };
606 
<span class="line-modified">607     return m_transaction.requestGetAllObjectStoreRecords(execState, *this, range.get(), IndexedDB::GetAllType::Keys, count);</span>












608 }
609 
610 ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBObjectStore::getAllKeys(ExecState&amp; execState, JSValue key, Optional&lt;uint32_t&gt; count)
611 {
<span class="line-modified">612     auto onlyResult = IDBKeyRange::only(execState, key);</span>
<span class="line-modified">613     if (onlyResult.hasException())</span>
<span class="line-modified">614         return Exception { DataError, &quot;Failed to execute &#39;getAllKeys&#39; on &#39;IDBObjectStore&#39;: The parameter is not a valid key.&quot;_s };</span>

615 
<span class="line-modified">616     return getAllKeys(execState, onlyResult.releaseReturnValue(), count);</span>

617 }
618 
619 void IDBObjectStore::markAsDeleted()
620 {
621     ASSERT(&amp;m_transaction.database().originThread() == &amp;Thread::current());
622     m_deleted = true;
623 }
624 
625 void IDBObjectStore::rollbackForVersionChangeAbort()
626 {
627     ASSERT(&amp;m_transaction.database().originThread() == &amp;Thread::current());
628 
629     String currentName = m_info.name();
630     m_info = m_originalInfo;
631 
632     auto&amp; databaseInfo = transaction().database().info();
633     auto* objectStoreInfo = databaseInfo.infoForExistingObjectStore(m_info.identifier());
634     if (!objectStoreInfo) {
635         m_info.rename(currentName);
636         m_deleted = true;
</pre>
</td>
<td>
<hr />
<pre>
132         for (auto&amp; name : m_info.indexNames())
133             indexNames-&gt;append(name);
134         indexNames-&gt;sort();
135     }
136 
137     return indexNames;
138 }
139 
140 IDBTransaction&amp; IDBObjectStore::transaction()
141 {
142     ASSERT(&amp;m_transaction.database().originThread() == &amp;Thread::current());
143     return m_transaction;
144 }
145 
146 bool IDBObjectStore::autoIncrement() const
147 {
148     ASSERT(&amp;m_transaction.database().originThread() == &amp;Thread::current());
149     return m_info.autoIncrement();
150 }
151 
<span class="line-modified">152 ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBObjectStore::doOpenCursor(ExecState&amp; execState, IDBCursorDirection direction, WTF::Function&lt;ExceptionOr&lt;RefPtr&lt;IDBKeyRange&gt;&gt;()&gt;&amp;&amp; function)</span>
153 {
154     LOG(IndexedDB, &quot;IDBObjectStore::openCursor&quot;);
155     ASSERT(&amp;m_transaction.database().originThread() == &amp;Thread::current());
156 
157     if (m_deleted)
158         return Exception { InvalidStateError, &quot;Failed to execute &#39;openCursor&#39; on &#39;IDBObjectStore&#39;: The object store has been deleted.&quot;_s };
159 
160     if (!m_transaction.isActive())
161         return Exception { TransactionInactiveError, &quot;Failed to execute &#39;openCursor&#39; on &#39;IDBObjectStore&#39;: The transaction is inactive or finished.&quot;_s };
162 
<span class="line-modified">163     auto keyRange = function();</span>
<span class="line-added">164     if (keyRange.hasException())</span>
<span class="line-added">165         return keyRange.releaseException();</span>
<span class="line-added">166     auto* keyRangePointer = keyRange.returnValue() ? keyRange.releaseReturnValue().get() : nullptr;</span>
<span class="line-added">167 </span>
<span class="line-added">168     auto info = IDBCursorInfo::objectStoreCursor(m_transaction, m_info.identifier(), keyRangePointer, direction, IndexedDB::CursorType::KeyAndValue);</span>
169     return m_transaction.requestOpenCursor(execState, *this, info);
170 }
171 
<span class="line-added">172 ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBObjectStore::openCursor(ExecState&amp; execState, RefPtr&lt;IDBKeyRange&gt;&amp;&amp; range, IDBCursorDirection direction)</span>
<span class="line-added">173 {</span>
<span class="line-added">174     return doOpenCursor(execState, direction, [range = WTFMove(range)]() {</span>
<span class="line-added">175         return range;</span>
<span class="line-added">176     });</span>
<span class="line-added">177 }</span>
<span class="line-added">178 </span>
179 ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBObjectStore::openCursor(ExecState&amp; execState, JSValue key, IDBCursorDirection direction)
180 {
<span class="line-modified">181     return doOpenCursor(execState, direction, [state=&amp;execState, key]() {</span>
<span class="line-modified">182         auto onlyResult = IDBKeyRange::only(*state, key);</span>
<span class="line-modified">183         if (onlyResult.hasException())</span>
<span class="line-added">184             return ExceptionOr&lt;RefPtr&lt;IDBKeyRange&gt;&gt;{ Exception(DataError, &quot;Failed to execute &#39;openCursor&#39; on &#39;IDBObjectStore&#39;: The parameter is not a valid key.&quot;_s) };</span>
185 
<span class="line-modified">186         return ExceptionOr&lt;RefPtr&lt;IDBKeyRange&gt;&gt; { onlyResult.releaseReturnValue() };</span>
<span class="line-added">187     });</span>
188 }
189 
<span class="line-modified">190 ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBObjectStore::doOpenKeyCursor(ExecState&amp; execState, IDBCursorDirection direction, WTF::Function&lt;ExceptionOr&lt;RefPtr&lt;IDBKeyRange&gt;&gt;()&gt;&amp;&amp; function)</span>
191 {
<span class="line-modified">192     LOG(IndexedDB, &quot;IDBObjectStore::openKeyCursor&quot;);</span>
193     ASSERT(&amp;m_transaction.database().originThread() == &amp;Thread::current());
194 
195     if (m_deleted)
196         return Exception { InvalidStateError, &quot;Failed to execute &#39;openKeyCursor&#39; on &#39;IDBObjectStore&#39;: The object store has been deleted.&quot;_s };
197 
198     if (!m_transaction.isActive())
199         return Exception { TransactionInactiveError, &quot;Failed to execute &#39;openKeyCursor&#39; on &#39;IDBObjectStore&#39;: The transaction is inactive or finished.&quot;_s };
200 
<span class="line-modified">201     auto keyRange = function();</span>
<span class="line-added">202     if (keyRange.hasException())</span>
<span class="line-added">203         return keyRange.releaseException();</span>
<span class="line-added">204 </span>
<span class="line-added">205     auto* keyRangePointer = keyRange.returnValue() ? keyRange.releaseReturnValue().get() : nullptr;</span>
<span class="line-added">206     auto info = IDBCursorInfo::objectStoreCursor(m_transaction, m_info.identifier(), keyRangePointer, direction, IndexedDB::CursorType::KeyOnly);</span>
207     return m_transaction.requestOpenCursor(execState, *this, info);
208 }
209 
<span class="line-added">210 ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBObjectStore::openKeyCursor(ExecState&amp; execState, RefPtr&lt;IDBKeyRange&gt;&amp;&amp; range, IDBCursorDirection direction)</span>
<span class="line-added">211 {</span>
<span class="line-added">212     return doOpenKeyCursor(execState, direction, [range = WTFMove(range)]() {</span>
<span class="line-added">213         return range;</span>
<span class="line-added">214     });</span>
<span class="line-added">215 }</span>
<span class="line-added">216 </span>
217 ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBObjectStore::openKeyCursor(ExecState&amp; execState, JSValue key, IDBCursorDirection direction)
218 {
<span class="line-modified">219     return doOpenCursor(execState, direction, [state=&amp;execState, key]() {</span>
<span class="line-modified">220         auto onlyResult = IDBKeyRange::only(*state, key);</span>
<span class="line-modified">221         if (onlyResult.hasException())</span>
<span class="line-added">222             return ExceptionOr&lt;RefPtr&lt;IDBKeyRange&gt;&gt;{ Exception(DataError, &quot;Failed to execute &#39;openKeyCursor&#39; on &#39;IDBObjectStore&#39;: The parameter is not a valid key.&quot;_s) };</span>
223 
<span class="line-modified">224         return ExceptionOr&lt;RefPtr&lt;IDBKeyRange&gt;&gt; { onlyResult.releaseReturnValue() };</span>
<span class="line-added">225     });</span>
226 }
227 
228 ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBObjectStore::get(ExecState&amp; execState, JSValue key)
229 {
230     LOG(IndexedDB, &quot;IDBObjectStore::get&quot;);
231     ASSERT(&amp;m_transaction.database().originThread() == &amp;Thread::current());
232 
233     if (m_deleted)
234         return Exception { InvalidStateError, &quot;Failed to execute &#39;get&#39; on &#39;IDBObjectStore&#39;: The object store has been deleted.&quot;_s };
235 
236     if (!m_transaction.isActive())
237         return Exception { TransactionInactiveError, &quot;Failed to execute &#39;get&#39; on &#39;IDBObjectStore&#39;: The transaction is inactive or finished.&quot;_s };
238 
239     auto idbKey = scriptValueToIDBKey(execState, key);
240     if (!idbKey-&gt;isValid())
241         return Exception { DataError, &quot;Failed to execute &#39;get&#39; on &#39;IDBObjectStore&#39;: The parameter is not a valid key.&quot;_s };
242 
243     return m_transaction.requestGetRecord(execState, *this, { idbKey.ptr(), IDBGetRecordDataType::KeyAndValue });
244 }
245 
</pre>
<hr />
<pre>
323     VM&amp; vm = state.vm();
324     auto scope = DECLARE_CATCH_SCOPE(vm);
325 
326     LOG(IndexedDB, &quot;IDBObjectStore::putOrAdd&quot;);
327     ASSERT(&amp;m_transaction.database().originThread() == &amp;Thread::current());
328 
329     auto context = scriptExecutionContextFromExecState(&amp;state);
330     if (!context)
331         return Exception { UnknownError, &quot;Unable to store record in object store because it does not have a valid script execution context&quot;_s };
332 
333     if (m_deleted)
334         return Exception { InvalidStateError, &quot;Failed to store record in an IDBObjectStore: The object store has been deleted.&quot;_s };
335 
336     if (!m_transaction.isActive())
337         return Exception { TransactionInactiveError, &quot;Failed to store record in an IDBObjectStore: The transaction is inactive or finished.&quot;_s };
338 
339     if (m_transaction.isReadOnly())
340         return Exception { ReadonlyError, &quot;Failed to store record in an IDBObjectStore: The transaction is read-only.&quot;_s };
341 
342     auto serializedValue = SerializedScriptValue::create(state, value);
<span class="line-modified">343     if (UNLIKELY(scope.exception()))</span>



344         return Exception { DataCloneError, &quot;Failed to store record in an IDBObjectStore: An object could not be cloned.&quot;_s };

345 
346     bool privateBrowsingEnabled = false;
347     if (is&lt;Document&gt;(*context)) {
348         if (auto* page = downcast&lt;Document&gt;(*context).page())
349             privateBrowsingEnabled = page-&gt;sessionID().isEphemeral();
350     }
351 
352     if (serializedValue-&gt;hasBlobURLs() &amp;&amp; privateBrowsingEnabled) {
353         // https://bugs.webkit.org/show_bug.cgi?id=156347 - Support Blobs in private browsing.
354         return Exception { DataCloneError, &quot;Failed to store record in an IDBObjectStore: BlobURLs are not yet supported.&quot;_s };
355     }
356 
357     if (key &amp;&amp; !key-&gt;isValid())
358         return Exception { DataError, &quot;Failed to store record in an IDBObjectStore: The parameter is not a valid key.&quot;_s };
359 
360     bool usesInlineKeys = !!m_info.keyPath();
361     bool usesKeyGenerator = autoIncrement();
362     if (usesInlineKeys &amp;&amp; inlineKeyCheck == InlineKeyCheck::Perform) {
363         if (key)
364             return Exception { DataError, &quot;Failed to store record in an IDBObjectStore: The object store uses in-line keys and the key parameter was provided.&quot;_s };
</pre>
<hr />
<pre>
369 
370         if (!keyPathKey) {
371             if (!usesKeyGenerator)
372                 return Exception { DataError, &quot;Failed to store record in an IDBObjectStore: Evaluating the object store&#39;s key path did not yield a value.&quot;_s };
373             if (!canInjectIDBKeyIntoScriptValue(state, value, m_info.keyPath().value()))
374                 return Exception { DataError };
375         }
376 
377         if (keyPathKey) {
378             ASSERT(!key);
379             key = keyPathKey;
380         }
381     } else if (!usesKeyGenerator &amp;&amp; !key)
382         return Exception { DataError, &quot;Failed to store record in an IDBObjectStore: The object store uses out-of-line keys and has no key generator and the key parameter was not provided.&quot;_s };
383 
384     return m_transaction.requestPutOrAdd(state, *this, WTFMove(key), *serializedValue, overwriteMode);
385 }
386 
387 ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBObjectStore::deleteFunction(ExecState&amp; execState, IDBKeyRange* keyRange)
388 {
<span class="line-modified">389     return doDelete(execState, [keyRange]() {</span>
<span class="line-added">390         return makeRefPtr(keyRange);</span>
<span class="line-added">391     });</span>
392 }
393 
<span class="line-modified">394 ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBObjectStore::doDelete(ExecState&amp; execState, WTF::Function&lt;ExceptionOr&lt;RefPtr&lt;IDBKeyRange&gt;&gt;()&gt;&amp;&amp; function)</span>
395 {
396     LOG(IndexedDB, &quot;IDBObjectStore::deleteFunction&quot;);
397     ASSERT(&amp;m_transaction.database().originThread() == &amp;Thread::current());
398 
399     // The IDB spec for several IDBObjectStore methods states that transaction related exceptions should fire before
400     // the exception for an object store being deleted.
401     // However, a handful of W3C IDB tests expect the deleted exception even though the transaction inactive exception also applies.
402     // Additionally, Chrome and Edge agree with the test, as does Legacy IDB in WebKit.
403     // Until this is sorted out, we&#39;ll agree with the test and the majority share browsers.
404     if (m_deleted)
405         return Exception { InvalidStateError, &quot;Failed to execute &#39;delete&#39; on &#39;IDBObjectStore&#39;: The object store has been deleted.&quot;_s };
406 
407     if (!m_transaction.isActive())
408         return Exception { TransactionInactiveError, &quot;Failed to execute &#39;delete&#39; on &#39;IDBObjectStore&#39;: The transaction is inactive or finished.&quot;_s };
409 
410     if (m_transaction.isReadOnly())
411         return Exception { ReadonlyError, &quot;Failed to execute &#39;delete&#39; on &#39;IDBObjectStore&#39;: The transaction is read-only.&quot;_s };
412 
<span class="line-modified">413     auto keyRange = function();</span>
<span class="line-added">414     if (keyRange.hasException())</span>
<span class="line-added">415         return keyRange.releaseException();</span>
<span class="line-added">416 </span>
<span class="line-added">417     IDBKeyRangeData keyRangeData = keyRange.returnValue() ? keyRange.releaseReturnValue().get() : nullptr;</span>
418     if (!keyRangeData.isValid())
419         return Exception { DataError, &quot;Failed to execute &#39;delete&#39; on &#39;IDBObjectStore&#39;: The parameter is not a valid key range.&quot;_s };
420 
421     return m_transaction.requestDeleteRecord(execState, *this, keyRangeData);
422 }
423 
424 ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBObjectStore::deleteFunction(ExecState&amp; execState, JSValue key)
425 {
<span class="line-modified">426     return doDelete(execState, [state=&amp;execState, key]() {</span>
<span class="line-modified">427         auto idbKey = scriptValueToIDBKey(*state, key);</span>
<span class="line-modified">428         if (!idbKey-&gt;isValid())</span>
<span class="line-modified">429             return ExceptionOr&lt;RefPtr&lt;IDBKeyRange&gt;&gt;{ Exception(DataError, &quot;Failed to execute &#39;delete&#39; on &#39;IDBObjectStore&#39;: The parameter is not a valid key.&quot;_s) };</span>
<span class="line-added">430         return ExceptionOr&lt;RefPtr&lt;IDBKeyRange&gt;&gt; { (IDBKeyRange::create(WTFMove(idbKey))).ptr() };</span>
<span class="line-added">431     });</span>
432 }
433 
434 ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBObjectStore::clear(ExecState&amp; execState)
435 {
436     LOG(IndexedDB, &quot;IDBObjectStore::clear&quot;);
437     ASSERT(&amp;m_transaction.database().originThread() == &amp;Thread::current());
438 
439     // The IDB spec for several IDBObjectStore methods states that transaction related exceptions should fire before
440     // the exception for an object store being deleted.
441     // However, a handful of W3C IDB tests expect the deleted exception even though the transaction inactive exception also applies.
442     // Additionally, Chrome and Edge agree with the test, as does Legacy IDB in WebKit.
443     // Until this is sorted out, we&#39;ll agree with the test and the majority share browsers.
444     if (m_deleted)
445         return Exception { InvalidStateError, &quot;Failed to execute &#39;clear&#39; on &#39;IDBObjectStore&#39;: The object store has been deleted.&quot;_s };
446 
447     if (!m_transaction.isActive())
448         return Exception { TransactionInactiveError, &quot;Failed to execute &#39;clear&#39; on &#39;IDBObjectStore&#39;: The transaction is inactive or finished.&quot;_s };
449 
450     if (m_transaction.isReadOnly())
451         return Exception { ReadonlyError, &quot;Failed to execute &#39;clear&#39; on &#39;IDBObjectStore&#39;: The transaction is read-only.&quot;_s };
</pre>
<hr />
<pre>
474         return Exception { SyntaxError, &quot;Failed to execute &#39;createIndex&#39; on &#39;IDBObjectStore&#39;: The keyPath argument contains an invalid key path.&quot;_s };
475 
476     if (name.isNull())
477         return Exception { TypeError };
478 
479     if (parameters.multiEntry &amp;&amp; WTF::holds_alternative&lt;Vector&lt;String&gt;&gt;(keyPath))
480         return Exception { InvalidAccessError, &quot;Failed to execute &#39;createIndex&#39; on &#39;IDBObjectStore&#39;: The keyPath argument was an array and the multiEntry option is true.&quot;_s };
481 
482     // Install the new Index into the ObjectStore&#39;s info.
483     IDBIndexInfo info = m_info.createNewIndex(name, WTFMove(keyPath), parameters.unique, parameters.multiEntry);
484     m_transaction.database().didCreateIndexInfo(info);
485 
486     // Create the actual IDBObjectStore from the transaction, which also schedules the operation server side.
487     auto index = m_transaction.createIndex(*this, info);
488 
489     Ref&lt;IDBIndex&gt; referencedIndex { *index };
490 
491     Locker&lt;Lock&gt; locker(m_referencedIndexLock);
492     m_referencedIndexes.set(name, WTFMove(index));
493 
<span class="line-modified">494     return referencedIndex;</span>
495 }
496 
497 ExceptionOr&lt;Ref&lt;IDBIndex&gt;&gt; IDBObjectStore::index(const String&amp; indexName)
498 {
499     LOG(IndexedDB, &quot;IDBObjectStore::index&quot;);
500     ASSERT(&amp;m_transaction.database().originThread() == &amp;Thread::current());
501 
502     if (!scriptExecutionContext())
503         return Exception { InvalidStateError }; // FIXME: Is this code tested? Is iteven reachable?
504 
505     if (m_deleted)
506         return Exception { InvalidStateError, &quot;Failed to execute &#39;index&#39; on &#39;IDBObjectStore&#39;: The object store has been deleted.&quot;_s };
507 
508     if (m_transaction.isFinishedOrFinishing())
509         return Exception { InvalidStateError, &quot;Failed to execute &#39;index&#39; on &#39;IDBObjectStore&#39;: The transaction is finished.&quot;_s };
510 
511     Locker&lt;Lock&gt; locker(m_referencedIndexLock);
512     auto iterator = m_referencedIndexes.find(indexName);
513     if (iterator != m_referencedIndexes.end())
514         return Ref&lt;IDBIndex&gt; { *iterator-&gt;value };
515 
516     auto* info = m_info.infoForExistingIndex(indexName);
517     if (!info)
518         return Exception { NotFoundError, &quot;Failed to execute &#39;index&#39; on &#39;IDBObjectStore&#39;: The specified index was not found.&quot;_s };
519 
<span class="line-modified">520     auto index = makeUnique&lt;IDBIndex&gt;(*scriptExecutionContext(), *info, *this);</span>
521 
522     Ref&lt;IDBIndex&gt; referencedIndex { *index };
523 
524     m_referencedIndexes.set(indexName, WTFMove(index));
525 
<span class="line-modified">526     return referencedIndex;</span>
527 }
528 
529 ExceptionOr&lt;void&gt; IDBObjectStore::deleteIndex(const String&amp; name)
530 {
531     LOG(IndexedDB, &quot;IDBObjectStore::deleteIndex %s&quot;, name.utf8().data());
532     ASSERT(&amp;m_transaction.database().originThread() == &amp;Thread::current());
533 
534     if (m_deleted)
535         return Exception { InvalidStateError, &quot;Failed to execute &#39;deleteIndex&#39; on &#39;IDBObjectStore&#39;: The object store has been deleted.&quot;_s };
536 
537     if (!m_transaction.isVersionChange())
538         return Exception { InvalidStateError, &quot;Failed to execute &#39;deleteIndex&#39; on &#39;IDBObjectStore&#39;: The database is not running a version change transaction.&quot;_s };
539 
540     if (!m_transaction.isActive())
541         return Exception { TransactionInactiveError,  &quot;Failed to execute &#39;deleteIndex&#39; on &#39;IDBObjectStore&#39;: The transaction is inactive or finished.&quot;_s };
542 
543     if (!m_info.hasIndex(name))
544         return Exception { NotFoundError, &quot;Failed to execute &#39;deleteIndex&#39; on &#39;IDBObjectStore&#39;: The specified index was not found.&quot;_s };
545 
546     auto* info = m_info.infoForExistingIndex(name);
</pre>
<hr />
<pre>
550     m_info.deleteIndex(name);
551 
552     {
553         Locker&lt;Lock&gt; locker(m_referencedIndexLock);
554         if (auto index = m_referencedIndexes.take(name)) {
555             index-&gt;markAsDeleted();
556             auto identifier = index-&gt;info().identifier();
557             m_deletedIndexes.add(identifier, WTFMove(index));
558         }
559     }
560 
561     m_transaction.deleteIndex(m_info.identifier(), name);
562 
563     return { };
564 }
565 
566 ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBObjectStore::count(ExecState&amp; execState, JSValue key)
567 {
568     LOG(IndexedDB, &quot;IDBObjectStore::count&quot;);
569 
<span class="line-modified">570     auto idbKey = scriptValueToIDBKey(execState, key);</span>


571 
<span class="line-modified">572     return doCount(execState, IDBKeyRangeData(idbKey-&gt;isValid() ? idbKey.ptr() : nullptr));</span>
573 }
574 
575 ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBObjectStore::count(ExecState&amp; execState, IDBKeyRange* range)
576 {
577     LOG(IndexedDB, &quot;IDBObjectStore::count&quot;);
578 
579     return doCount(execState, range ? IDBKeyRangeData(range) : IDBKeyRangeData::allKeys());
580 }
581 
582 ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBObjectStore::doCount(ExecState&amp; execState, const IDBKeyRangeData&amp; range)
583 {
584     ASSERT(&amp;m_transaction.database().originThread() == &amp;Thread::current());
585 
586     // The IDB spec for several IDBObjectStore methods states that transaction related exceptions should fire before
587     // the exception for an object store being deleted.
588     // However, a handful of W3C IDB tests expect the deleted exception even though the transaction inactive exception also applies.
589     // Additionally, Chrome and Edge agree with the test, as does Legacy IDB in WebKit.
590     // Until this is sorted out, we&#39;ll agree with the test and the majority share browsers.
591     if (m_deleted)
592         return Exception { InvalidStateError, &quot;Failed to execute &#39;count&#39; on &#39;IDBObjectStore&#39;: The object store has been deleted.&quot;_s };
593 
594     if (!m_transaction.isActive())
595         return Exception { TransactionInactiveError, &quot;Failed to execute &#39;count&#39; on &#39;IDBObjectStore&#39;: The transaction is inactive or finished.&quot;_s };
596 
597     if (!range.isValid())
<span class="line-modified">598         return Exception { DataError, &quot;Failed to execute &#39;count&#39; on &#39;IDBObjectStore&#39;: The parameter is not a valid key.&quot;_s };</span>
599 
600     return m_transaction.requestCount(execState, *this, range);
601 }
602 
<span class="line-modified">603 ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBObjectStore::doGetAll(ExecState&amp; execState, Optional&lt;uint32_t&gt; count, WTF::Function&lt;ExceptionOr&lt;RefPtr&lt;IDBKeyRange&gt;&gt;()&gt;&amp;&amp; function)</span>
604 {
605     LOG(IndexedDB, &quot;IDBObjectStore::getAll&quot;);
606     ASSERT(&amp;m_transaction.database().originThread() == &amp;Thread::current());
607 
608     if (m_deleted)
609         return Exception { InvalidStateError, &quot;Failed to execute &#39;getAll&#39; on &#39;IDBObjectStore&#39;: The object store has been deleted.&quot;_s };
610 
611     if (!m_transaction.isActive())
612         return Exception { TransactionInactiveError, &quot;Failed to execute &#39;getAll&#39; on &#39;IDBObjectStore&#39;: The transaction is inactive or finished.&quot;_s };
613 
<span class="line-modified">614     auto keyRange = function();</span>
<span class="line-added">615     if (keyRange.hasException())</span>
<span class="line-added">616         return keyRange.releaseException();</span>
<span class="line-added">617 </span>
<span class="line-added">618     auto* keyRangePointer = keyRange.returnValue() ? keyRange.releaseReturnValue().get() : nullptr;</span>
<span class="line-added">619     return m_transaction.requestGetAllObjectStoreRecords(execState, *this, keyRangePointer, IndexedDB::GetAllType::Values, count);</span>
<span class="line-added">620 }</span>
<span class="line-added">621 </span>
<span class="line-added">622 ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBObjectStore::getAll(ExecState&amp; execState, RefPtr&lt;IDBKeyRange&gt;&amp;&amp; range, Optional&lt;uint32_t&gt; count)</span>
<span class="line-added">623 {</span>
<span class="line-added">624     return doGetAll(execState, count, [range = WTFMove(range)]() {</span>
<span class="line-added">625         return range;</span>
<span class="line-added">626     });</span>
627 }
628 
629 ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBObjectStore::getAll(ExecState&amp; execState, JSValue key, Optional&lt;uint32_t&gt; count)
630 {
<span class="line-modified">631     return doGetAll(execState, count, [state=&amp;execState, key]() {</span>
<span class="line-modified">632         auto onlyResult = IDBKeyRange::only(*state, key);</span>
<span class="line-modified">633         if (onlyResult.hasException())</span>
<span class="line-added">634             return ExceptionOr&lt;RefPtr&lt;IDBKeyRange&gt;&gt;{ Exception(DataError, &quot;Failed to execute &#39;getAll&#39; on &#39;IDBObjectStore&#39;: The parameter is not a valid key.&quot;_s) };</span>
635 
<span class="line-modified">636         return ExceptionOr&lt;RefPtr&lt;IDBKeyRange&gt;&gt; { onlyResult.releaseReturnValue() };</span>
<span class="line-added">637     });</span>
638 }
639 
<span class="line-modified">640 ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBObjectStore::doGetAllKeys(ExecState&amp; execState, Optional&lt;uint32_t&gt; count, WTF::Function&lt;ExceptionOr&lt;RefPtr&lt;IDBKeyRange&gt;&gt;()&gt;&amp;&amp; function)</span>
641 {
642     LOG(IndexedDB, &quot;IDBObjectStore::getAllKeys&quot;);
643     ASSERT(&amp;m_transaction.database().originThread() == &amp;Thread::current());
644 
645     if (m_deleted)
646         return Exception { InvalidStateError, &quot;Failed to execute &#39;getAllKeys&#39; on &#39;IDBObjectStore&#39;: The object store has been deleted.&quot;_s };
647 
648     if (!m_transaction.isActive())
649         return Exception { TransactionInactiveError, &quot;Failed to execute &#39;getAllKeys&#39; on &#39;IDBObjectStore&#39;: The transaction is inactive or finished.&quot;_s };
650 
<span class="line-modified">651     auto keyRange = function();</span>
<span class="line-added">652     if (keyRange.hasException())</span>
<span class="line-added">653         return keyRange.releaseException();</span>
<span class="line-added">654 </span>
<span class="line-added">655     auto* keyRangePointer = keyRange.returnValue() ? keyRange.releaseReturnValue().get() : nullptr;</span>
<span class="line-added">656     return m_transaction.requestGetAllObjectStoreRecords(execState, *this, keyRangePointer, IndexedDB::GetAllType::Keys, count);</span>
<span class="line-added">657 }</span>
<span class="line-added">658 </span>
<span class="line-added">659 ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBObjectStore::getAllKeys(ExecState&amp; execState, RefPtr&lt;IDBKeyRange&gt;&amp;&amp; range, Optional&lt;uint32_t&gt; count)</span>
<span class="line-added">660 {</span>
<span class="line-added">661     return doGetAllKeys(execState, count, [range = WTFMove(range)]() {</span>
<span class="line-added">662         return range;</span>
<span class="line-added">663     });</span>
664 }
665 
666 ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBObjectStore::getAllKeys(ExecState&amp; execState, JSValue key, Optional&lt;uint32_t&gt; count)
667 {
<span class="line-modified">668     return doGetAllKeys(execState, count, [state=&amp;execState, key]() {</span>
<span class="line-modified">669         auto onlyResult = IDBKeyRange::only(*state, key);</span>
<span class="line-modified">670         if (onlyResult.hasException())</span>
<span class="line-added">671             return ExceptionOr&lt;RefPtr&lt;IDBKeyRange&gt;&gt;{ Exception(DataError, &quot;Failed to execute &#39;getAllKeys&#39; on &#39;IDBObjectStore&#39;: The parameter is not a valid key.&quot;_s) };</span>
672 
<span class="line-modified">673         return ExceptionOr&lt;RefPtr&lt;IDBKeyRange&gt;&gt; { onlyResult.releaseReturnValue() };</span>
<span class="line-added">674     });</span>
675 }
676 
677 void IDBObjectStore::markAsDeleted()
678 {
679     ASSERT(&amp;m_transaction.database().originThread() == &amp;Thread::current());
680     m_deleted = true;
681 }
682 
683 void IDBObjectStore::rollbackForVersionChangeAbort()
684 {
685     ASSERT(&amp;m_transaction.database().originThread() == &amp;Thread::current());
686 
687     String currentName = m_info.name();
688     m_info = m_originalInfo;
689 
690     auto&amp; databaseInfo = transaction().database().info();
691     auto* objectStoreInfo = databaseInfo.infoForExistingObjectStore(m_info.identifier());
692     if (!objectStoreInfo) {
693         m_info.rename(currentName);
694         m_deleted = true;
</pre>
</td>
</tr>
</table>
<center><a href="IDBKeyRange.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="IDBObjectStore.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>