<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WTF/wtf/dtoa/fixed-dtoa.cc</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 // Copyright 2010 the V8 project authors. All rights reserved.
  2 // Redistribution and use in source and binary forms, with or without
  3 // modification, are permitted provided that the following conditions are
  4 // met:
  5 //
  6 //     * Redistributions of source code must retain the above copyright
  7 //       notice, this list of conditions and the following disclaimer.
  8 //     * Redistributions in binary form must reproduce the above
  9 //       copyright notice, this list of conditions and the following
 10 //       disclaimer in the documentation and/or other materials provided
 11 //       with the distribution.
 12 //     * Neither the name of Google Inc. nor the names of its
 13 //       contributors may be used to endorse or promote products derived
 14 //       from this software without specific prior written permission.
 15 //
 16 // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 17 // &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 18 // LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 19 // A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 20 // OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 21 // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 22 // LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 23 // DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 24 // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 25 // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 26 // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 27 
 28 #include &quot;config.h&quot;
 29 
 30 #include &lt;cmath&gt;
 31 
 32 #include &lt;wtf/dtoa/fixed-dtoa.h&gt;
 33 #include &lt;wtf/dtoa/ieee.h&gt;
 34 
 35 namespace WTF {
 36 namespace double_conversion {
<a name="1" id="anc1"></a><span class="line-modified"> 37 </span>
 38 // Represents a 128bit type. This class should be replaced by a native type on
 39 // platforms that support 128bit integers.
 40 class UInt128 {
<a name="2" id="anc2"></a><span class="line-modified"> 41  public:</span>
<span class="line-modified"> 42   UInt128() : high_bits_(0), low_bits_(0) { }</span>
<span class="line-modified"> 43   UInt128(uint64_t high, uint64_t low) : high_bits_(high), low_bits_(low) { }</span>
<span class="line-modified"> 44 </span>
<span class="line-modified"> 45   void Multiply(uint32_t multiplicand) {</span>
<span class="line-modified"> 46     uint64_t accumulator;</span>
<span class="line-modified"> 47 </span>
<span class="line-modified"> 48     accumulator = (low_bits_ &amp; kMask32) * multiplicand;</span>
<span class="line-modified"> 49     uint32_t part = static_cast&lt;uint32_t&gt;(accumulator &amp; kMask32);</span>
<span class="line-modified"> 50     accumulator &gt;&gt;= 32;</span>
<span class="line-modified"> 51     accumulator = accumulator + (low_bits_ &gt;&gt; 32) * multiplicand;</span>
<span class="line-modified"> 52     low_bits_ = (accumulator &lt;&lt; 32) + part;</span>
<span class="line-modified"> 53     accumulator &gt;&gt;= 32;</span>
<span class="line-modified"> 54     accumulator = accumulator + (high_bits_ &amp; kMask32) * multiplicand;</span>
<span class="line-modified"> 55     part = static_cast&lt;uint32_t&gt;(accumulator &amp; kMask32);</span>
<span class="line-modified"> 56     accumulator &gt;&gt;= 32;</span>
<span class="line-modified"> 57     accumulator = accumulator + (high_bits_ &gt;&gt; 32) * multiplicand;</span>
<span class="line-modified"> 58     high_bits_ = (accumulator &lt;&lt; 32) + part;</span>
<span class="line-modified"> 59     ASSERT((accumulator &gt;&gt; 32) == 0);</span>
<span class="line-modified"> 60   }</span>
<span class="line-modified"> 61 </span>
<span class="line-modified"> 62   void Shift(int shift_amount) {</span>
<span class="line-modified"> 63     ASSERT(-64 &lt;= shift_amount &amp;&amp; shift_amount &lt;= 64);</span>
<span class="line-modified"> 64     if (shift_amount == 0) {</span>
<span class="line-modified"> 65       return;</span>
<span class="line-modified"> 66     } else if (shift_amount == -64) {</span>
<span class="line-modified"> 67       high_bits_ = low_bits_;</span>
<span class="line-modified"> 68       low_bits_ = 0;</span>
<span class="line-modified"> 69     } else if (shift_amount == 64) {</span>
<span class="line-modified"> 70       low_bits_ = high_bits_;</span>
<span class="line-modified"> 71       high_bits_ = 0;</span>
<span class="line-modified"> 72     } else if (shift_amount &lt;= 0) {</span>
<span class="line-modified"> 73       high_bits_ &lt;&lt;= -shift_amount;</span>
<span class="line-modified"> 74       high_bits_ += low_bits_ &gt;&gt; (64 + shift_amount);</span>
<span class="line-modified"> 75       low_bits_ &lt;&lt;= -shift_amount;</span>
<span class="line-modified"> 76     } else {</span>
<span class="line-modified"> 77       low_bits_ &gt;&gt;= shift_amount;</span>
<span class="line-modified"> 78       low_bits_ += high_bits_ &lt;&lt; (64 - shift_amount);</span>
<span class="line-modified"> 79       high_bits_ &gt;&gt;= shift_amount;</span>
<span class="line-modified"> 80     }</span>
<span class="line-modified"> 81   }</span>
<span class="line-modified"> 82 </span>
<span class="line-modified"> 83   // Modifies *this to *this MOD (2^power).</span>
<span class="line-modified"> 84   // Returns *this DIV (2^power).</span>
<span class="line-modified"> 85   int DivModPowerOf2(int power) {</span>
<span class="line-modified"> 86     if (power &gt;= 64) {</span>
<span class="line-modified"> 87       int result = static_cast&lt;int&gt;(high_bits_ &gt;&gt; (power - 64));</span>
<span class="line-modified"> 88       high_bits_ -= static_cast&lt;uint64_t&gt;(result) &lt;&lt; (power - 64);</span>
<span class="line-modified"> 89       return result;</span>
<span class="line-modified"> 90     } else {</span>
<span class="line-modified"> 91       uint64_t part_low = low_bits_ &gt;&gt; power;</span>
<span class="line-modified"> 92       uint64_t part_high = high_bits_ &lt;&lt; (64 - power);</span>
<span class="line-modified"> 93       int result = static_cast&lt;int&gt;(part_low + part_high);</span>
<span class="line-modified"> 94       high_bits_ = 0;</span>
<span class="line-modified"> 95       low_bits_ -= part_low &lt;&lt; power;</span>
<span class="line-modified"> 96       return result;</span>
<span class="line-modified"> 97     }</span>
<span class="line-modified"> 98   }</span>
<span class="line-modified"> 99 </span>
<span class="line-modified">100   bool IsZero() const {</span>
<span class="line-modified">101     return high_bits_ == 0 &amp;&amp; low_bits_ == 0;</span>
<span class="line-modified">102   }</span>
<span class="line-modified">103 </span>
104   int BitAt(int position) const {
<a name="3" id="anc3"></a><span class="line-modified">105     if (position &gt;= 64) {</span>
<span class="line-modified">106       return static_cast&lt;int&gt;(high_bits_ &gt;&gt; (position - 64)) &amp; 1;</span>
<span class="line-modified">107     } else {</span>
<span class="line-modified">108       return static_cast&lt;int&gt;(low_bits_ &gt;&gt; position) &amp; 1;</span>
<span class="line-modified">109     }</span>
<span class="line-modified">110   }</span>
<span class="line-modified">111 </span>
<span class="line-modified">112  private:</span>
<span class="line-modified">113   static const uint64_t kMask32 = 0xFFFFFFFF;</span>
<span class="line-modified">114   // Value == (high_bits_ &lt;&lt; 64) + low_bits_</span>
<span class="line-modified">115   uint64_t high_bits_;</span>
<span class="line-modified">116   uint64_t low_bits_;</span>
117 };
<a name="4" id="anc4"></a><span class="line-modified">118 </span>
<span class="line-modified">119 </span>
120 static const int kDoubleSignificandSize = 53;  // Includes the hidden bit.
<a name="5" id="anc5"></a><span class="line-modified">121 </span>
<span class="line-modified">122 </span>
123 static void FillDigits32FixedLength(uint32_t number, int requested_length,
<a name="6" id="anc6"></a><span class="line-modified">124                                     BufferReference&lt;char&gt; buffer, int* length) {</span>
<span class="line-modified">125   for (int i = requested_length - 1; i &gt;= 0; --i) {</span>
<span class="line-modified">126     buffer[(*length) + i] = &#39;0&#39; + number % 10;</span>
<span class="line-modified">127     number /= 10;</span>
<span class="line-modified">128   }</span>
<span class="line-modified">129   *length += requested_length;</span>
130 }
<a name="7" id="anc7"></a><span class="line-modified">131 </span>
<span class="line-modified">132 </span>
133 static void FillDigits32(uint32_t number, BufferReference&lt;char&gt; buffer, int* length) {
<a name="8" id="anc8"></a><span class="line-modified">134   int number_length = 0;</span>
<span class="line-modified">135   // We fill the digits in reverse order and exchange them afterwards.</span>
<span class="line-modified">136   while (number != 0) {</span>
<span class="line-modified">137     int digit = number % 10;</span>
<span class="line-modified">138     number /= 10;</span>
139     buffer[(*length) + number_length] = static_cast&lt;char&gt;(&#39;0&#39; + digit);
<a name="9" id="anc9"></a><span class="line-modified">140     number_length++;</span>
<span class="line-modified">141   }</span>
<span class="line-modified">142   // Exchange the digits.</span>
<span class="line-modified">143   int i = *length;</span>
<span class="line-modified">144   int j = *length + number_length - 1;</span>
<span class="line-modified">145   while (i &lt; j) {</span>
<span class="line-modified">146     char tmp = buffer[i];</span>
<span class="line-modified">147     buffer[i] = buffer[j];</span>
<span class="line-modified">148     buffer[j] = tmp;</span>
<span class="line-modified">149     i++;</span>
<span class="line-modified">150     j--;</span>
<span class="line-modified">151   }</span>
<span class="line-modified">152   *length += number_length;</span>
153 }
<a name="10" id="anc10"></a><span class="line-modified">154 </span>
<span class="line-modified">155 </span>
156 static void FillDigits64FixedLength(uint64_t number,
<a name="11" id="anc11"></a><span class="line-modified">157                                     BufferReference&lt;char&gt; buffer, int* length) {</span>
<span class="line-modified">158   const uint32_t kTen7 = 10000000;</span>
<span class="line-modified">159   // For efficiency cut the number into 3 uint32_t parts, and print those.</span>
<span class="line-modified">160   uint32_t part2 = static_cast&lt;uint32_t&gt;(number % kTen7);</span>
<span class="line-modified">161   number /= kTen7;</span>
<span class="line-modified">162   uint32_t part1 = static_cast&lt;uint32_t&gt;(number % kTen7);</span>
<span class="line-modified">163   uint32_t part0 = static_cast&lt;uint32_t&gt;(number / kTen7);</span>
<span class="line-modified">164 </span>
<span class="line-modified">165   FillDigits32FixedLength(part0, 3, buffer, length);</span>
<span class="line-modified">166   FillDigits32FixedLength(part1, 7, buffer, length);</span>
<span class="line-modified">167   FillDigits32FixedLength(part2, 7, buffer, length);</span>
168 }
<a name="12" id="anc12"></a><span class="line-modified">169 </span>
<span class="line-modified">170 </span>
171 static void FillDigits64(uint64_t number, BufferReference&lt;char&gt; buffer, int* length) {
<a name="13" id="anc13"></a><span class="line-modified">172   const uint32_t kTen7 = 10000000;</span>
<span class="line-modified">173   // For efficiency cut the number into 3 uint32_t parts, and print those.</span>
<span class="line-modified">174   uint32_t part2 = static_cast&lt;uint32_t&gt;(number % kTen7);</span>
<span class="line-modified">175   number /= kTen7;</span>
<span class="line-modified">176   uint32_t part1 = static_cast&lt;uint32_t&gt;(number % kTen7);</span>
<span class="line-modified">177   uint32_t part0 = static_cast&lt;uint32_t&gt;(number / kTen7);</span>
<span class="line-modified">178 </span>
<span class="line-modified">179   if (part0 != 0) {</span>
<span class="line-modified">180     FillDigits32(part0, buffer, length);</span>
<span class="line-modified">181     FillDigits32FixedLength(part1, 7, buffer, length);</span>
<span class="line-modified">182     FillDigits32FixedLength(part2, 7, buffer, length);</span>
<span class="line-modified">183   } else if (part1 != 0) {</span>
<span class="line-modified">184     FillDigits32(part1, buffer, length);</span>
<span class="line-modified">185     FillDigits32FixedLength(part2, 7, buffer, length);</span>
<span class="line-modified">186   } else {</span>
<span class="line-modified">187     FillDigits32(part2, buffer, length);</span>
<span class="line-modified">188   }</span>
189 }
<a name="14" id="anc14"></a><span class="line-modified">190 </span>
<span class="line-modified">191 </span>
192 static void RoundUp(BufferReference&lt;char&gt; buffer, int* length, int* decimal_point) {
<a name="15" id="anc15"></a><span class="line-modified">193   // An empty buffer represents 0.</span>
<span class="line-modified">194   if (*length == 0) {</span>
<span class="line-modified">195     buffer[0] = &#39;1&#39;;</span>
<span class="line-modified">196     *decimal_point = 1;</span>
<span class="line-modified">197     *length = 1;</span>
<span class="line-modified">198     return;</span>
<span class="line-modified">199   }</span>
<span class="line-modified">200   // Round the last digit until we either have a digit that was not &#39;9&#39; or until</span>
<span class="line-modified">201   // we reached the first digit.</span>
<span class="line-modified">202   buffer[(*length) - 1]++;</span>
<span class="line-modified">203   for (int i = (*length) - 1; i &gt; 0; --i) {</span>
<span class="line-modified">204     if (buffer[i] != &#39;0&#39; + 10) {</span>
<span class="line-modified">205       return;</span>
<span class="line-modified">206     }</span>
<span class="line-modified">207     buffer[i] = &#39;0&#39;;</span>
<span class="line-modified">208     buffer[i - 1]++;</span>
<span class="line-modified">209   }</span>
<span class="line-modified">210   // If the first digit is now &#39;0&#39; + 10, we would need to set it to &#39;0&#39; and add</span>
<span class="line-modified">211   // a &#39;1&#39; in front. However we reach the first digit only if all following</span>
<span class="line-modified">212   // digits had been &#39;9&#39; before rounding up. Now all trailing digits are &#39;0&#39; and</span>
<span class="line-modified">213   // we simply switch the first digit to &#39;1&#39; and update the decimal-point</span>
<span class="line-modified">214   // (indicating that the point is now one digit to the right).</span>
<span class="line-modified">215   if (buffer[0] == &#39;0&#39; + 10) {</span>
<span class="line-modified">216     buffer[0] = &#39;1&#39;;</span>
<span class="line-modified">217     (*decimal_point)++;</span>
<span class="line-modified">218   }</span>
219 }
<a name="16" id="anc16"></a><span class="line-modified">220 </span>
<span class="line-modified">221 </span>
222 // The given fractionals number represents a fixed-point number with binary
223 // point at bit (-exponent).
224 // Preconditions:
225 //   -128 &lt;= exponent &lt;= 0.
226 //   0 &lt;= fractionals * 2^exponent &lt; 1
227 //   The buffer holds the result.
228 // The function will round its result. During the rounding-process digits not
229 // generated by this function might be updated, and the decimal-point variable
230 // might be updated. If this function generates the digits 99 and the buffer
231 // already contained &quot;199&quot; (thus yielding a buffer of &quot;19999&quot;) then a
232 // rounding-up will change the contents of the buffer to &quot;20000&quot;.
233 static void FillFractionals(uint64_t fractionals, int exponent,
<a name="17" id="anc17"></a><span class="line-modified">234                             int fractional_count, BufferReference&lt;char&gt; buffer,</span>
<span class="line-modified">235                             int* length, int* decimal_point) {</span>
<span class="line-modified">236   ASSERT(-128 &lt;= exponent &amp;&amp; exponent &lt;= 0);</span>
<span class="line-modified">237   // &#39;fractionals&#39; is a fixed-point number, with binary point at bit</span>
<span class="line-modified">238   // (-exponent). Inside the function the non-converted remainder of fractionals</span>
<span class="line-modified">239   // is a fixed-point number, with binary point at bit &#39;point&#39;.</span>
<span class="line-modified">240   if (-exponent &lt;= 64) {</span>
<span class="line-modified">241     // One 64 bit number is sufficient.</span>
<span class="line-modified">242     ASSERT(fractionals &gt;&gt; 56 == 0);</span>
<span class="line-modified">243     int point = -exponent;</span>
<span class="line-modified">244     for (int i = 0; i &lt; fractional_count; ++i) {</span>
<span class="line-modified">245       if (fractionals == 0) break;</span>
<span class="line-modified">246       // Instead of multiplying by 10 we multiply by 5 and adjust the point</span>
<span class="line-modified">247       // location. This way the fractionals variable will not overflow.</span>
<span class="line-modified">248       // Invariant at the beginning of the loop: fractionals &lt; 2^point.</span>
<span class="line-modified">249       // Initially we have: point &lt;= 64 and fractionals &lt; 2^56</span>
<span class="line-modified">250       // After each iteration the point is decremented by one.</span>
<span class="line-modified">251       // Note that 5^3 = 125 &lt; 128 = 2^7.</span>
<span class="line-modified">252       // Therefore three iterations of this loop will not overflow fractionals</span>
<span class="line-modified">253       // (even without the subtraction at the end of the loop body). At this</span>
<span class="line-modified">254       // time point will satisfy point &lt;= 61 and therefore fractionals &lt; 2^point</span>
<span class="line-modified">255       // and any further multiplication of fractionals by 5 will not overflow.</span>
<span class="line-modified">256       fractionals *= 5;</span>
<span class="line-modified">257       point--;</span>
<span class="line-modified">258       int digit = static_cast&lt;int&gt;(fractionals &gt;&gt; point);</span>
259       ASSERT(digit &lt;= 9);
260       buffer[*length] = static_cast&lt;char&gt;(&#39;0&#39; + digit);
<a name="18" id="anc18"></a><span class="line-modified">261       (*length)++;</span>
<span class="line-modified">262       fractionals -= static_cast&lt;uint64_t&gt;(digit) &lt;&lt; point;</span>
<span class="line-modified">263     }</span>
<span class="line-modified">264     // If the first bit after the point is set we have to round up.</span>
265     ASSERT(fractionals == 0 || point - 1 &gt;= 0);
266     if ((fractionals != 0) &amp;&amp; ((fractionals &gt;&gt; (point - 1)) &amp; 1) == 1) {
<a name="19" id="anc19"></a><span class="line-modified">267       RoundUp(buffer, length, decimal_point);</span>
<span class="line-modified">268     }</span>
<span class="line-modified">269   } else {  // We need 128 bits.</span>
<span class="line-modified">270     ASSERT(64 &lt; -exponent &amp;&amp; -exponent &lt;= 128);</span>
<span class="line-modified">271     UInt128 fractionals128 = UInt128(fractionals, 0);</span>
<span class="line-modified">272     fractionals128.Shift(-exponent - 64);</span>
<span class="line-modified">273     int point = 128;</span>
<span class="line-modified">274     for (int i = 0; i &lt; fractional_count; ++i) {</span>
<span class="line-modified">275       if (fractionals128.IsZero()) break;</span>
<span class="line-modified">276       // As before: instead of multiplying by 10 we multiply by 5 and adjust the</span>
<span class="line-modified">277       // point location.</span>
<span class="line-modified">278       // This multiplication will not overflow for the same reasons as before.</span>
<span class="line-modified">279       fractionals128.Multiply(5);</span>
<span class="line-modified">280       point--;</span>
<span class="line-modified">281       int digit = fractionals128.DivModPowerOf2(point);</span>
282       ASSERT(digit &lt;= 9);
283       buffer[*length] = static_cast&lt;char&gt;(&#39;0&#39; + digit);
<a name="20" id="anc20"></a><span class="line-modified">284       (*length)++;</span>
<span class="line-modified">285     }</span>
<span class="line-modified">286     if (fractionals128.BitAt(point - 1) == 1) {</span>
<span class="line-modified">287       RoundUp(buffer, length, decimal_point);</span>
<span class="line-modified">288     }</span>
<span class="line-modified">289   }</span>
290 }
<a name="21" id="anc21"></a><span class="line-modified">291 </span>
<span class="line-modified">292 </span>
293 // Removes leading and trailing zeros.
294 // If leading zeros are removed then the decimal point position is adjusted.
295 static void TrimZeros(BufferReference&lt;char&gt; buffer, int* length, int* decimal_point) {
<a name="22" id="anc22"></a><span class="line-modified">296   while (*length &gt; 0 &amp;&amp; buffer[(*length) - 1] == &#39;0&#39;) {</span>
<span class="line-modified">297     (*length)--;</span>
<span class="line-modified">298   }</span>
<span class="line-modified">299   int first_non_zero = 0;</span>
<span class="line-modified">300   while (first_non_zero &lt; *length &amp;&amp; buffer[first_non_zero] == &#39;0&#39;) {</span>
<span class="line-modified">301     first_non_zero++;</span>
<span class="line-modified">302   }</span>
<span class="line-modified">303   if (first_non_zero != 0) {</span>
<span class="line-modified">304     for (int i = first_non_zero; i &lt; *length; ++i) {</span>
<span class="line-modified">305       buffer[i - first_non_zero] = buffer[i];</span>
<span class="line-modified">306     }</span>
<span class="line-modified">307     *length -= first_non_zero;</span>
<span class="line-modified">308     *decimal_point -= first_non_zero;</span>
<span class="line-modified">309   }</span>
310 }
<a name="23" id="anc23"></a><span class="line-modified">311 </span>
<span class="line-modified">312 </span>
313 bool FastFixedDtoa(double v,
<a name="24" id="anc24"></a><span class="line-modified">314                    int fractional_count,</span>
<span class="line-modified">315                    BufferReference&lt;char&gt; buffer,</span>
<span class="line-modified">316                    int* length,</span>
<span class="line-modified">317                    int* decimal_point) {</span>
<span class="line-modified">318   const uint32_t kMaxUInt32 = 0xFFFFFFFF;</span>
<span class="line-modified">319   uint64_t significand = Double(v).Significand();</span>
<span class="line-modified">320   int exponent = Double(v).Exponent();</span>
<span class="line-modified">321   // v = significand * 2^exponent (with significand a 53bit integer).</span>
<span class="line-modified">322   // If the exponent is larger than 20 (i.e. we may have a 73bit number) then we</span>
<span class="line-modified">323   // don&#39;t know how to compute the representation. 2^73 ~= 9.5*10^21.</span>
<span class="line-modified">324   // If necessary this limit could probably be increased, but we don&#39;t need</span>
<span class="line-modified">325   // more.</span>
<span class="line-modified">326   if (exponent &gt; 20) return false;</span>
<span class="line-modified">327   if (fractional_count &gt; 20) return false;</span>
<span class="line-modified">328   *length = 0;</span>
<span class="line-modified">329   // At most kDoubleSignificandSize bits of the significand are non-zero.</span>
<span class="line-modified">330   // Given a 64 bit integer we have 11 0s followed by 53 potentially non-zero</span>
<span class="line-modified">331   // bits:  0..11*..0xxx..53*..xx</span>
<span class="line-modified">332   if (exponent + kDoubleSignificandSize &gt; 64) {</span>
<span class="line-modified">333     // The exponent must be &gt; 11.</span>
<span class="line-modified">334     //</span>
<span class="line-modified">335     // We know that v = significand * 2^exponent.</span>
<span class="line-modified">336     // And the exponent &gt; 11.</span>
<span class="line-modified">337     // We simplify the task by dividing v by 10^17.</span>
<span class="line-modified">338     // The quotient delivers the first digits, and the remainder fits into a 64</span>
<span class="line-modified">339     // bit number.</span>
<span class="line-modified">340     // Dividing by 10^17 is equivalent to dividing by 5^17*2^17.</span>
<span class="line-modified">341     const uint64_t kFive17 = UINT64_2PART_C(0xB1, A2BC2EC5);  // 5^17</span>
<span class="line-modified">342     uint64_t divisor = kFive17;</span>
<span class="line-modified">343     int divisor_power = 17;</span>
<span class="line-modified">344     uint64_t dividend = significand;</span>
<span class="line-modified">345     uint32_t quotient;</span>
<span class="line-modified">346     uint64_t remainder;</span>
<span class="line-modified">347     // Let v = f * 2^e with f == significand and e == exponent.</span>
<span class="line-modified">348     // Then need q (quotient) and r (remainder) as follows:</span>
<span class="line-modified">349     //   v            = q * 10^17       + r</span>
<span class="line-modified">350     //   f * 2^e      = q * 10^17       + r</span>
<span class="line-modified">351     //   f * 2^e      = q * 5^17 * 2^17 + r</span>
<span class="line-modified">352     // If e &gt; 17 then</span>
<span class="line-modified">353     //   f * 2^(e-17) = q * 5^17        + r/2^17</span>
<span class="line-modified">354     // else</span>
<span class="line-modified">355     //   f  = q * 5^17 * 2^(17-e) + r/2^e</span>
<span class="line-modified">356     if (exponent &gt; divisor_power) {</span>
<span class="line-modified">357       // We only allow exponents of up to 20 and therefore (17 - e) &lt;= 3</span>
<span class="line-modified">358       dividend &lt;&lt;= exponent - divisor_power;</span>
<span class="line-modified">359       quotient = static_cast&lt;uint32_t&gt;(dividend / divisor);</span>
<span class="line-modified">360       remainder = (dividend % divisor) &lt;&lt; divisor_power;</span>
<span class="line-modified">361     } else {</span>
<span class="line-modified">362       divisor &lt;&lt;= divisor_power - exponent;</span>
<span class="line-modified">363       quotient = static_cast&lt;uint32_t&gt;(dividend / divisor);</span>
<span class="line-modified">364       remainder = (dividend % divisor) &lt;&lt; exponent;</span>
<span class="line-modified">365     }</span>
<span class="line-modified">366     FillDigits32(quotient, buffer, length);</span>
367     FillDigits64FixedLength(remainder, buffer, length);
<a name="25" id="anc25"></a><span class="line-modified">368     *decimal_point = *length;</span>
<span class="line-modified">369   } else if (exponent &gt;= 0) {</span>
<span class="line-modified">370     // 0 &lt;= exponent &lt;= 11</span>
<span class="line-modified">371     significand &lt;&lt;= exponent;</span>
<span class="line-modified">372     FillDigits64(significand, buffer, length);</span>
<span class="line-modified">373     *decimal_point = *length;</span>
<span class="line-modified">374   } else if (exponent &gt; -kDoubleSignificandSize) {</span>
<span class="line-modified">375     // We have to cut the number.</span>
<span class="line-modified">376     uint64_t integrals = significand &gt;&gt; -exponent;</span>
<span class="line-modified">377     uint64_t fractionals = significand - (integrals &lt;&lt; -exponent);</span>
<span class="line-modified">378     if (integrals &gt; kMaxUInt32) {</span>
<span class="line-modified">379       FillDigits64(integrals, buffer, length);</span>
<span class="line-modified">380     } else {</span>
<span class="line-modified">381       FillDigits32(static_cast&lt;uint32_t&gt;(integrals), buffer, length);</span>
<span class="line-modified">382     }</span>
<span class="line-modified">383     *decimal_point = *length;</span>
<span class="line-modified">384     FillFractionals(fractionals, exponent, fractional_count,</span>
<span class="line-modified">385                     buffer, length, decimal_point);</span>
<span class="line-modified">386   } else if (exponent &lt; -128) {</span>
<span class="line-modified">387     // This configuration (with at most 20 digits) means that all digits must be</span>
<span class="line-modified">388     // 0.</span>
<span class="line-modified">389     ASSERT(fractional_count &lt;= 20);</span>
<span class="line-modified">390     buffer[0] = &#39;\0&#39;;</span>
<span class="line-modified">391     *length = 0;</span>
<span class="line-modified">392     *decimal_point = -fractional_count;</span>
<span class="line-modified">393   } else {</span>
<span class="line-modified">394     *decimal_point = 0;</span>
<span class="line-modified">395     FillFractionals(significand, exponent, fractional_count,</span>
<span class="line-modified">396                     buffer, length, decimal_point);</span>
<span class="line-modified">397   }</span>
<span class="line-modified">398   TrimZeros(buffer, length, decimal_point);</span>
<span class="line-modified">399   buffer[*length] = &#39;\0&#39;;</span>
<span class="line-modified">400   if ((*length) == 0) {</span>
<span class="line-modified">401     // The string is empty and the decimal_point thus has no importance. Mimick</span>
<span class="line-modified">402     // Gay&#39;s dtoa and and set it to -fractional_count.</span>
<span class="line-modified">403     *decimal_point = -fractional_count;</span>
<span class="line-modified">404   }</span>
<span class="line-modified">405   return true;</span>
406 }
<a name="26" id="anc26"></a><span class="line-modified">407 </span>
408 }  // namespace double_conversion
<a name="27" id="anc27"></a><span class="line-modified">409 }  // namespace WTF</span>
<a name="28" id="anc28"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="28" type="hidden" />
</body>
</html>