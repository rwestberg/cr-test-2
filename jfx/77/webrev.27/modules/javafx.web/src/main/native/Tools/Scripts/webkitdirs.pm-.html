<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.web/src/main/native/Tools/Scripts/webkitdirs.pm</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 # Copyright (C) 2005-2007, 2010-2016 Apple Inc. All rights reserved.
   2 # Copyright (C) 2009 Google Inc. All rights reserved.
   3 # Copyright (C) 2011 Research In Motion Limited. All rights reserved.
   4 # Copyright (C) 2013 Nokia Corporation and/or its subsidiary(-ies).
   5 #
   6 # Redistribution and use in source and binary forms, with or without
   7 # modification, are permitted provided that the following conditions
   8 # are met:
   9 #
  10 # 1.  Redistributions of source code must retain the above copyright
  11 #     notice, this list of conditions and the following disclaimer. 
  12 # 2.  Redistributions in binary form must reproduce the above copyright
  13 #     notice, this list of conditions and the following disclaimer in the
  14 #     documentation and/or other materials provided with the distribution. 
  15 # 3.  Neither the name of Apple Inc. (&quot;Apple&quot;) nor the names of
  16 #     its contributors may be used to endorse or promote products derived
  17 #     from this software without specific prior written permission. 
  18 #
  19 # THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS &quot;AS IS&quot; AND ANY
  20 # EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  21 # WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  22 # DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
  23 # DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  24 # (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  25 # LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  26 # ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  27 # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  28 # THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  29 
  30 # Module to share code to get to WebKit directories.
  31 
  32 use strict;
  33 #use version; #the module is not used by the Java port
  34 use warnings;
  35 use Config;
  36 use Cwd qw(realpath);
  37 use Digest::MD5 qw(md5_hex);
  38 use FindBin;
  39 use File::Basename;
  40 use File::Find;
  41 use File::Path qw(make_path mkpath rmtree);
  42 use File::Spec;
  43 use File::Temp qw(tempdir);
  44 use File::stat;
  45 use List::Util;
  46 use POSIX;
  47 use Time::HiRes qw(usleep);
  48 use VCSUtils;
  49 
  50 BEGIN {
  51    use Exporter   ();
  52    our ($VERSION, @ISA, @EXPORT, @EXPORT_OK, %EXPORT_TAGS);
  53    $VERSION     = 1.00;
  54    @ISA         = qw(Exporter);
  55    @EXPORT      = qw(
  56        &amp;XcodeCoverageSupportOptions
  57        &amp;XcodeOptionString
  58        &amp;XcodeOptionStringNoConfig
  59        &amp;XcodeOptions
  60        &amp;XcodeStaticAnalyzerOption
  61        &amp;appDisplayNameFromBundle
  62        &amp;appendToEnvironmentVariableList
  63        &amp;archCommandLineArgumentsForRestrictedEnvironmentVariables
  64        &amp;availableXcodeSDKs
  65        &amp;baseProductDir
  66        &amp;chdirWebKit
  67        &amp;checkFrameworks
  68        &amp;cmakeArgsFromFeatures
  69        &amp;currentSVNRevision
  70        &amp;debugSafari
  71        &amp;executableProductDir
  72        &amp;extractNonHostConfiguration
  73        &amp;findOrCreateSimulatorForIOSDevice
  74        &amp;iosSimulatorDeviceByName
  75        &amp;iosVersion
  76        &amp;nmPath
  77        &amp;passedConfiguration
  78        &amp;prependToEnvironmentVariableList
  79        &amp;printHelpAndExitForRunAndDebugWebKitAppIfNeeded
  80        &amp;productDir
  81        &amp;quitIOSSimulator
  82        &amp;relaunchIOSSimulator
  83        &amp;restartIOSSimulatorDevice
  84        &amp;runIOSWebKitApp
  85        &amp;runMacWebKitApp
  86        &amp;safariPath
  87        &amp;sdkDirectory
  88        &amp;sdkPlatformDirectory
  89        &amp;setConfiguration
  90        &amp;setupMacWebKitEnvironment
  91        &amp;sharedCommandLineOptions
  92        &amp;sharedCommandLineOptionsUsage
  93        &amp;shutDownIOSSimulatorDevice
  94        &amp;willUseIOSDeviceSDK
  95        &amp;willUseIOSSimulatorSDK
  96        DO_NOT_USE_OPEN_COMMAND
  97        SIMULATOR_DEVICE_SUFFIX_FOR_WEBKIT_DEVELOPMENT
  98        USE_OPEN_COMMAND
  99    );
 100    %EXPORT_TAGS = ( );
 101    @EXPORT_OK   = ();
 102 }
 103 
 104 # Ports
 105 use constant {
 106     AppleWin    =&gt; &quot;AppleWin&quot;,
 107     GTK         =&gt; &quot;GTK&quot;,
 108     iOS         =&gt; &quot;iOS&quot;,
 109     tvOS        =&gt; &quot;tvOS&quot;,
 110     watchOS     =&gt; &quot;watchOS&quot;,
 111     Mac         =&gt; &quot;Mac&quot;,
 112     JSCOnly     =&gt; &quot;JSCOnly&quot;,
 113     PlayStation =&gt; &quot;PlayStation&quot;,
 114     WinCairo    =&gt; &quot;WinCairo&quot;,
 115     Java     =&gt; &quot;Java&quot;,
 116     WPE         =&gt; &quot;WPE&quot;,
 117     Unknown     =&gt; &quot;Unknown&quot;
 118 };
 119 
 120 use constant USE_OPEN_COMMAND =&gt; 1; # Used in runMacWebKitApp().
 121 use constant DO_NOT_USE_OPEN_COMMAND =&gt; 2;
 122 use constant SIMULATOR_DEVICE_STATE_SHUTDOWN =&gt; &quot;1&quot;;
 123 use constant SIMULATOR_DEVICE_STATE_BOOTED =&gt; &quot;3&quot;;
 124 use constant SIMULATOR_DEVICE_SUFFIX_FOR_WEBKIT_DEVELOPMENT  =&gt; &quot;For WebKit Development&quot;;
 125 
 126 # See table &quot;Certificate types and names&quot; on &lt;https://developer.apple.com/library/ios/documentation/IDEs/Conceptual/AppDistributionGuide/MaintainingCertificates/MaintainingCertificates.html#//apple_ref/doc/uid/TP40012582-CH31-SW41&gt;.
 127 use constant IOS_DEVELOPMENT_CERTIFICATE_NAME_PREFIX =&gt; &quot;iPhone Developer: &quot;;
 128 
 129 our @EXPORT_OK;
 130 
 131 my $architecture;
 132 my $asanIsEnabled;
 133 my $ltoMode;
 134 my $numberOfCPUs;
 135 my $maxCPULoad;
 136 my $baseProductDir;
 137 my @baseProductDirOption;
 138 my $configuration;
 139 my $xcodeSDK;
 140 my $configurationForVisualStudio;
 141 my $configurationProductDir;
 142 my $sourceDir;
 143 my $currentSVNRevision;
 144 my $didLoadIPhoneSimulatorNotification;
 145 my $nmPath;
 146 my $osXVersion;
 147 my $iosVersion;
 148 my $generateDsym;
 149 my $isCMakeBuild;
 150 my $isGenerateProjectOnly;
 151 my $shouldBuild32Bit;
 152 my $isWin64;
 153 my $isInspectorFrontend;
 154 my $portName;
 155 my $shouldUseGuardMalloc;
 156 my $shouldNotUseNinja;
 157 my $xcodeVersion;
 158 my $isJava;
 159 my $is32bit;
 160 
 161 my $unknownPortProhibited = 0;
 162 
 163 # Variables for Win32 support
 164 my $programFilesPath;
 165 my $vcBuildPath;
 166 my $vsInstallDir;
 167 my $msBuildInstallDir;
 168 my $vsVersion;
 169 my $windowsSourceDir;
 170 my $winVersion;
 171 my $vsWhereFoundInstallation;
 172 
 173 # Defined in VCSUtils.
 174 sub exitStatus($);
 175 
 176 sub findMatchingArguments($$);
 177 sub hasArgument($$);
 178 
 179 sub sdkDirectory($)
 180 {
 181     my ($sdkName) = @_;
 182     chomp(my $sdkDirectory = `xcrun --sdk &#39;$sdkName&#39; --show-sdk-path`);
 183     die &quot;Failed to get SDK path from xcrun: $!&quot; if exitStatus($?);
 184     return $sdkDirectory;
 185 }
 186 
 187 sub sdkPlatformDirectory($)
 188 {
 189     my ($sdkName) = @_;
 190     chomp(my $sdkPlatformDirectory = `xcrun --sdk &#39;$sdkName&#39; --show-sdk-platform-path`);
 191     die &quot;Failed to get SDK platform path from xcrun: $!&quot; if exitStatus($?);
 192     return $sdkPlatformDirectory;
 193 }
 194 
 195 sub determineSourceDir
 196 {
 197     return if $sourceDir;
 198     $sourceDir = $FindBin::Bin;
 199     $sourceDir =~ s|/+$||; # Remove trailing &#39;/&#39; as we would die later
 200 
 201     # walks up path checking each directory to see if it is the main WebKit project dir, 
 202     # defined by containing Sources, WebCore, and JavaScriptCore.
 203     until ((-d File::Spec-&gt;catdir($sourceDir, &quot;Source&quot;) &amp;&amp; -d File::Spec-&gt;catdir($sourceDir, &quot;Source&quot;, &quot;WebCore&quot;) &amp;&amp; -d File::Spec-&gt;catdir($sourceDir, &quot;Source&quot;, &quot;JavaScriptCore&quot;)) || (-d File::Spec-&gt;catdir($sourceDir, &quot;Internal&quot;) &amp;&amp; -d File::Spec-&gt;catdir($sourceDir, &quot;OpenSource&quot;)))
 204     {
 205         if ($sourceDir !~ s|/[^/]+$||) {
 206             die &quot;Could not find top level webkit directory above source directory using FindBin.\n&quot;;
 207         }
 208     }
 209 
 210     $sourceDir = File::Spec-&gt;catdir($sourceDir, &quot;OpenSource&quot;) if -d File::Spec-&gt;catdir($sourceDir, &quot;OpenSource&quot;);
 211 }
 212 
 213 sub currentPerlPath()
 214 {
 215     my $thisPerl = $^X;
 216     if ($^O ne &#39;VMS&#39;) {
 217         $thisPerl .= $Config{_exe} unless $thisPerl =~ m/$Config{_exe}$/i;
 218     }
 219     return $thisPerl;
 220 }
 221 
 222 # used for scripts which are stored in a non-standard location
 223 sub setSourceDir($)
 224 {
 225     ($sourceDir) = @_;
 226 }
 227 
 228 sub determineNinjaVersion
 229 {
 230     chomp(my $ninjaVersion = `ninja --version`);
 231     return $ninjaVersion;
 232 }
 233 
 234 sub determineXcodeVersion
 235 {
 236     return if defined $xcodeVersion;
 237     my $xcodebuildVersionOutput = `xcodebuild -version`;
 238     $xcodeVersion = ($xcodebuildVersionOutput =~ /Xcode ([0-9]+(\.[0-9]+)*)/) ? $1 : &quot;3.0&quot;;
 239 }
 240 
 241 sub readXcodeUserDefault($)
 242 {
 243     my ($key) = @_;
 244 
 245     my $devnull = File::Spec-&gt;devnull();
 246 
 247     my $value = `defaults read com.apple.dt.Xcode ${key} 2&gt; ${devnull}`;
 248     return if $?;
 249 
 250     chomp $value;
 251     return $value;
 252 }
 253 
 254 sub determineBaseProductDir
 255 {
 256     return if defined $baseProductDir;
 257     determineSourceDir();
 258 
 259     my $setSharedPrecompsDir;
 260     my $indexDataStoreDir;
 261     $baseProductDir = $ENV{&quot;WEBKIT_OUTPUTDIR&quot;};
 262 
 263     if (!defined($baseProductDir) and isAppleCocoaWebKit()) {
 264         # Silently remove ~/Library/Preferences/xcodebuild.plist which can
 265         # cause build failure. The presence of
 266         # ~/Library/Preferences/xcodebuild.plist can prevent xcodebuild from
 267         # respecting global settings such as a custom build products directory
 268         # (&lt;rdar://problem/5585899&gt;).
 269         my $personalPlistFile = $ENV{HOME} . &quot;/Library/Preferences/xcodebuild.plist&quot;;
 270         if (-e $personalPlistFile) {
 271             unlink($personalPlistFile) || die &quot;Could not delete $personalPlistFile: $!&quot;;
 272         }
 273 
 274         my $buildLocationStyle = join &#39;&#39;, readXcodeUserDefault(&quot;IDEBuildLocationStyle&quot;);
 275         if ($buildLocationStyle eq &quot;Custom&quot;) {
 276             my $buildLocationType = join &#39;&#39;, readXcodeUserDefault(&quot;IDECustomBuildLocationType&quot;);
 277             # FIXME: Read CustomBuildIntermediatesPath and set OBJROOT accordingly.
 278             if ($buildLocationType eq &quot;Absolute&quot;) {
 279                 $baseProductDir = readXcodeUserDefault(&quot;IDECustomBuildProductsPath&quot;);
 280                 $indexDataStoreDir = readXcodeUserDefault(&quot;IDECustomIndexStorePath&quot;);
 281             }
 282         }
 283 
 284         # DeterminedByTargets corresponds to a setting of &quot;Legacy&quot; in Xcode.
 285         # It is the only build location style for which SHARED_PRECOMPS_DIR is not
 286         # overridden when building from within Xcode.
 287         $setSharedPrecompsDir = 1 if $buildLocationStyle ne &quot;DeterminedByTargets&quot;;
 288 
 289         if (!defined($baseProductDir)) {
 290             $baseProductDir = join &#39;&#39;, readXcodeUserDefault(&quot;IDEApplicationwideBuildSettings&quot;);
 291             $baseProductDir = $1 if $baseProductDir =~ /SYMROOT\s*=\s*\&quot;(.*?)\&quot;;/s;
 292         }
 293 
 294         undef $baseProductDir unless $baseProductDir =~ /^\//;
 295     }
 296 
 297     if (!defined($baseProductDir)) { # Port-specific checks failed, use default
 298         $baseProductDir = File::Spec-&gt;catdir($sourceDir, &quot;WebKitBuild&quot;);
 299     }
 300 
 301     if (isGit() &amp;&amp; isGitBranchBuild()) {
 302         my $branch = gitBranch();
 303         $baseProductDir = &quot;$baseProductDir/$branch&quot;;
 304     }
 305 
 306     if (isAppleCocoaWebKit()) {
 307         $baseProductDir =~ s|^\Q$(SRCROOT)/..\E$|$sourceDir|;
 308         $baseProductDir =~ s|^\Q$(SRCROOT)/../|$sourceDir/|;
 309         $baseProductDir =~ s|^~/|$ENV{HOME}/|;
 310         die &quot;Can&#39;t handle Xcode product directory with a ~ in it.\n&quot; if $baseProductDir =~ /~/;
 311         die &quot;Can&#39;t handle Xcode product directory with a variable in it.\n&quot; if $baseProductDir =~ /\$/;
 312         @baseProductDirOption = (&quot;SYMROOT=$baseProductDir&quot;, &quot;OBJROOT=$baseProductDir&quot;);
 313         push(@baseProductDirOption, &quot;SHARED_PRECOMPS_DIR=${baseProductDir}/PrecompiledHeaders&quot;) if $setSharedPrecompsDir;
 314         push(@baseProductDirOption, &quot;INDEX_ENABLE_DATA_STORE=YES&quot;, &quot;INDEX_DATA_STORE_DIR=${indexDataStoreDir}&quot;) if $indexDataStoreDir;
 315     }
 316 
 317     if (isCygwin()) {
 318         my $dosBuildPath = `cygpath --windows \&quot;$baseProductDir\&quot;`;
 319         chomp $dosBuildPath;
 320         $ENV{&quot;WEBKIT_OUTPUTDIR&quot;} = $dosBuildPath;
 321         my $unixBuildPath = `cygpath --unix \&quot;$baseProductDir\&quot;`;
 322         chomp $unixBuildPath;
 323         $baseProductDir = $dosBuildPath;
 324     }
 325 }
 326 
 327 sub systemVerbose {
 328     print &quot;+ @_\n&quot;;
 329     return system(@_);
 330 }
 331 
 332 sub setBaseProductDir($)
 333 {
 334     ($baseProductDir) = @_;
 335 }
 336 
 337 sub determineConfiguration
 338 {
 339     return if defined $configuration;
 340     determineBaseProductDir();
 341     if (open CONFIGURATION, &quot;$baseProductDir/Configuration&quot;) {
 342         $configuration = &lt;CONFIGURATION&gt;;
 343         close CONFIGURATION;
 344     }
 345     if ($configuration) {
 346         chomp $configuration;
 347         # compatibility for people who have old Configuration files
 348         $configuration = &quot;Release&quot; if $configuration eq &quot;Deployment&quot;;
 349         $configuration = &quot;Debug&quot; if $configuration eq &quot;Development&quot;;
 350     } else {
 351         $configuration = &quot;Release&quot;;
 352     }
 353 }
 354 
 355 sub determineArchitecture
 356 {
 357     return if defined $architecture;
 358     # make sure $architecture is defined in all cases
 359     $architecture = &quot;&quot;;
 360 
 361     determineBaseProductDir();
 362     determineXcodeSDK();
 363 
 364     if (isAppleCocoaWebKit()) {
 365         if (open ARCHITECTURE, &quot;$baseProductDir/Architecture&quot;) {
 366             $architecture = &lt;ARCHITECTURE&gt;;
 367             close ARCHITECTURE;
 368         }
 369         if ($architecture) {
 370             chomp $architecture;
 371         } else {
 372             if (not defined $xcodeSDK or $xcodeSDK =~ /^(\/$|macosx)/) {
 373                 my $supports64Bit = `sysctl -n hw.optional.x86_64`;
 374                 chomp $supports64Bit;
 375                 $architecture = &#39;x86_64&#39; if $supports64Bit;
 376             } elsif ($xcodeSDK =~ /^iphonesimulator/) {
 377                 $architecture = &#39;x86_64&#39;;
 378             } elsif ($xcodeSDK =~ /^iphoneos/) {
 379                 $architecture = &#39;arm64&#39;;
 380             }
 381         }
 382     } elsif (isCMakeBuild()) {
 383         if (isCrossCompilation()) {
 384             my $compiler = &quot;gcc&quot;;
 385             $compiler = $ENV{&#39;CC&#39;} if (defined($ENV{&#39;CC&#39;}));
 386             my @compiler_machine = split(&#39;-&#39;, `$compiler -dumpmachine`);
 387             $architecture = $compiler_machine[0];
 388         } elsif (open my $cmake_sysinfo, &quot;cmake --system-information |&quot;) {
 389             while (&lt;$cmake_sysinfo&gt;) {
 390                 next unless index($_, &#39;CMAKE_SYSTEM_PROCESSOR&#39;) == 0;
 391                 if (/^CMAKE_SYSTEM_PROCESSOR \&quot;([^&quot;]+)\&quot;/) {
 392                     $architecture = $1;
 393                     last;
 394                 }
 395             }
 396             close $cmake_sysinfo;
 397         }
 398     }
 399 
 400     if (!isAnyWindows()) {
 401         if (!$architecture) {
 402             # Fall back to output of `uname -m&#39;, if it is present.
 403             $architecture = `uname -m`;
 404             chomp $architecture;
 405         }
 406     }
 407 
 408     $architecture = &#39;x86_64&#39; if $architecture =~ /amd64/i;
 409     $architecture = &#39;arm64&#39; if $architecture =~ /aarch64/i;
 410 }
 411 
 412 sub determineASanIsEnabled
 413 {
 414     return if defined $asanIsEnabled;
 415     determineBaseProductDir();
 416 
 417     $asanIsEnabled = 0;
 418     my $asanConfigurationValue;
 419 
 420     if (open ASAN, &quot;$baseProductDir/ASan&quot;) {
 421         $asanConfigurationValue = &lt;ASAN&gt;;
 422         close ASAN;
 423         chomp $asanConfigurationValue;
 424         $asanIsEnabled = 1 if $asanConfigurationValue eq &quot;YES&quot;;
 425     }
 426 }
 427 
 428 sub determineLTOMode
 429 {
 430     return if defined $ltoMode;
 431     determineBaseProductDir();
 432 
 433     if (open LTO, &quot;$baseProductDir/LTO&quot;) {
 434         $ltoMode = &lt;LTO&gt;;
 435         close LTO;
 436         chomp $ltoMode;
 437     }
 438 }
 439 
 440 sub determineNumberOfCPUs
 441 {
 442     return if defined $numberOfCPUs;
 443     if (defined($ENV{NUMBER_OF_PROCESSORS})) {
 444         $numberOfCPUs = $ENV{NUMBER_OF_PROCESSORS};
 445     } elsif (isLinux()) {
 446         # First try the nproc utility, if it exists. If we get no
 447         # results fall back to just interpretting /proc directly.
 448         chomp($numberOfCPUs = `nproc --all 2&gt; /dev/null`);
 449         if ($numberOfCPUs eq &quot;&quot;) {
 450             $numberOfCPUs = (grep /processor/, `cat /proc/cpuinfo`);
 451         }
 452     } elsif (isAnyWindows()) {
 453         # Assumes cygwin
 454         $numberOfCPUs = `ls /proc/registry/HKEY_LOCAL_MACHINE/HARDWARE/DESCRIPTION/System/CentralProcessor | wc -w`;
 455     } elsif (isDarwin() || isBSD()) {
 456         chomp($numberOfCPUs = `sysctl -n hw.ncpu`);
 457     } else {
 458         $numberOfCPUs = 1;
 459     }
 460 }
 461 
 462 sub determineMaxCPULoad
 463 {
 464     return if defined $maxCPULoad;
 465     if (defined($ENV{MAX_CPU_LOAD})) {
 466         $maxCPULoad = $ENV{MAX_CPU_LOAD};
 467     }
 468 }
 469 
 470 sub jscPath($)
 471 {
 472     my ($productDir) = @_;
 473     my $jscName = &quot;jsc&quot;;
 474     $jscName .= &quot;_debug&quot;  if configuration() eq &quot;Debug_All&quot;;
 475     $jscName .= &quot;.exe&quot; if (isAnyWindows());
 476     return &quot;$productDir/$jscName&quot; if -e &quot;$productDir/$jscName&quot;;
 477     return &quot;$productDir/JavaScriptCore.framework/Resources/$jscName&quot;;
 478 }
 479 
 480 sub argumentsForConfiguration()
 481 {
 482     determineConfiguration();
 483     determineArchitecture();
 484     determineXcodeSDK();
 485 
 486     my @args = ();
 487     # FIXME: Is it necessary to pass --debug, --release, --32-bit or --64-bit?
 488     # These are determined automatically from stored configuration.
 489     push(@args, &#39;--debug&#39;) if ($configuration =~ &quot;^Debug&quot;);
 490     push(@args, &#39;--release&#39;) if ($configuration =~ &quot;^Release&quot;);
 491     push(@args, &#39;--ios-device&#39;) if (defined $xcodeSDK &amp;&amp; $xcodeSDK =~ /^iphoneos/);
 492     push(@args, &#39;--ios-simulator&#39;) if (defined $xcodeSDK &amp;&amp; $xcodeSDK =~ /^iphonesimulator/);
 493     push(@args, &#39;--32-bit&#39;) if ($architecture eq &quot;x86&quot; and !isWin64());
 494     push(@args, &#39;--64-bit&#39;) if (isWin64());
 495     push(@args, &#39;--gtk&#39;) if isGtk();
 496     push(@args, &#39;--java&#39;) if isJava();
 497     push(@args, &#39;--wpe&#39;) if isWPE();
 498     push(@args, &#39;--jsc-only&#39;) if isJSCOnly();
 499     push(@args, &#39;--wincairo&#39;) if isWinCairo();
 500     push(@args, &#39;--playstation&#39;) if isPlayStation();
 501     return @args;
 502 }
 503 
 504 sub extractNonMacOSHostConfiguration
 505 {
 506     my @args = ();
 507     my @extract = (&#39;--device&#39;, &#39;--gtk&#39;, &#39;--ios&#39;, &#39;--platform&#39;, &#39;--sdk&#39;, &#39;--simulator&#39;, &#39;--wincairo&#39;, &#39;SDKROOT&#39;, &#39;ARCHS&#39;);
 508     foreach (@{$_[0]}) {
 509         my $line = $_;
 510         my $flag = 0;
 511         foreach (@extract) {
 512             if (length($line) &gt;= length($_) &amp;&amp; substr($line, 0, length($_)) eq $_
 513                 &amp;&amp; index($line, &#39;i386&#39;) == -1 &amp;&amp; index($line, &#39;x86_64&#39;) == -1) {
 514                 $flag = 1;
 515             }
 516         }
 517         if (!$flag) {
 518             push @args, $_;
 519         }
 520     }
 521     return @args;
 522 }
 523 
 524 # FIXME: Convert to json &lt;rdar://problem/21594308&gt;
 525 sub parseAvailableXcodeSDKs($)
 526 {
 527     my @outputToParse = @{$_[0]};
 528     my @result = ();
 529     foreach my $line (@outputToParse) {
 530         # Examples:
 531         #    iOS 12.0 -sdk iphoneos12.0
 532         #    Simulator - iOS 12.0 -sdk iphonesimulator12.0
 533         #    macOS 10.14 -sdk macosx10.14
 534         if ($line =~ /-sdk (\D+)([\d\.]+)(\D*)\n/) {
 535             if ($3) {
 536                 push @result, &quot;$1.$3&quot;;
 537             } else {
 538                 push @result, &quot;$1&quot;;
 539             }
 540         }
 541     }
 542     return @result;
 543 }
 544 
 545 sub availableXcodeSDKs
 546 {
 547     my @output = `xcodebuild -showsdks`;
 548     return parseAvailableXcodeSDKs(\@output);
 549 }
 550 
 551 sub determineXcodeSDK
 552 {
 553     return if defined $xcodeSDK;
 554     my $sdk;
 555     
 556     # The user explicitly specified the sdk, don&#39;t assume anything
 557     if (checkForArgumentAndRemoveFromARGVGettingValue(&quot;--sdk&quot;, \$sdk)) {
 558         $xcodeSDK = $sdk;
 559         return;
 560     }
 561     if (checkForArgumentAndRemoveFromARGV(&quot;--device&quot;) || checkForArgumentAndRemoveFromARGV(&quot;--ios-device&quot;)) {
 562         $xcodeSDK ||= &quot;iphoneos&quot;;
 563     }
 564     if (checkForArgumentAndRemoveFromARGV(&quot;--simulator&quot;) || checkForArgumentAndRemoveFromARGV(&quot;--ios-simulator&quot;)) {
 565         $xcodeSDK ||= &#39;iphonesimulator&#39;;
 566     }
 567     if (checkForArgumentAndRemoveFromARGV(&quot;--tvos-device&quot;)) {
 568         $xcodeSDK ||=  &quot;appletvos&quot;;
 569     }
 570     if (checkForArgumentAndRemoveFromARGV(&quot;--tvos-simulator&quot;)) {
 571         $xcodeSDK ||= &quot;appletvsimulator&quot;;
 572     }
 573     if (checkForArgumentAndRemoveFromARGV(&quot;--watchos-device&quot;)) {
 574         $xcodeSDK ||=  &quot;watchos&quot;;
 575     }
 576     if (checkForArgumentAndRemoveFromARGV(&quot;--watchos-simulator&quot;)) {
 577         $xcodeSDK ||= &quot;watchsimulator&quot;;
 578     }
 579     return if !defined $xcodeSDK;
 580     
 581     # Prefer the internal version of an sdk, if it exists.
 582     my @availableSDKs = availableXcodeSDKs();
 583 
 584     foreach my $sdk (@availableSDKs) {
 585         next if $sdk ne &quot;$xcodeSDK.internal&quot;;
 586         $xcodeSDK = $sdk;
 587         last;
 588     }
 589 }
 590 
 591 sub xcodeSDK
 592 {
 593     determineXcodeSDK();
 594     return $xcodeSDK;
 595 }
 596 
 597 sub setXcodeSDK($)
 598 {
 599     ($xcodeSDK) = @_;
 600 }
 601 
 602 
 603 sub xcodeSDKPlatformName()
 604 {
 605     determineXcodeSDK();
 606     return &quot;&quot; if !defined $xcodeSDK;
 607     return &quot;appletvos&quot; if $xcodeSDK =~ /appletvos/i;
 608     return &quot;appletvsimulator&quot; if $xcodeSDK =~ /appletvsimulator/i;
 609     return &quot;iphoneos&quot; if $xcodeSDK =~ /iphoneos/i;
 610     return &quot;iphonesimulator&quot; if $xcodeSDK =~ /iphonesimulator/i;
 611     return &quot;macosx&quot; if $xcodeSDK =~ /macosx/i;
 612     return &quot;watchos&quot; if $xcodeSDK =~ /watchos/i;
 613     return &quot;watchsimulator&quot; if $xcodeSDK =~ /watchsimulator/i;
 614     die &quot;Couldn&#39;t determine platform name from Xcode SDK&quot;;
 615 }
 616 
 617 sub XcodeSDKPath
 618 {
 619     determineXcodeSDK();
 620 
 621     die &quot;Can&#39;t find the SDK path because no Xcode SDK was specified&quot; if not $xcodeSDK;
 622     return sdkDirectory($xcodeSDK);
 623 }
 624 
 625 sub xcodeSDKVersion
 626 {
 627     determineXcodeSDK();
 628 
 629     die &quot;Can&#39;t find the SDK version because no Xcode SDK was specified&quot; if !$xcodeSDK;
 630 
 631     chomp(my $sdkVersion = `xcrun --sdk $xcodeSDK --show-sdk-version`);
 632     die &quot;Failed to get SDK version from xcrun&quot; if exitStatus($?);
 633 
 634     return $sdkVersion;
 635 }
 636 
 637 sub programFilesPath
 638 {
 639     return $programFilesPath if defined $programFilesPath;
 640 
 641     $programFilesPath = $ENV{&#39;PROGRAMFILES(X86)&#39;} || $ENV{&#39;PROGRAMFILES&#39;} || &quot;C:\\Program Files&quot;;
 642 
 643     return $programFilesPath;
 644 }
 645 
 646 sub programFilesPathX86
 647 {
 648     my $programFilesPathX86 = $ENV{&#39;PROGRAMFILES(X86)&#39;} || &quot;C:\\Program Files (x86)&quot;;
 649 
 650     return $programFilesPathX86;
 651 }
 652 
 653 sub requireModulesForVSWhere
 654 {
 655     require Encode;
 656     require Encode::Locale;
 657     require JSON::PP;
 658 }
 659 
 660 sub pickCurrentVisualStudioInstallation
 661 {
 662     return $vsWhereFoundInstallation if defined $vsWhereFoundInstallation;
 663 
 664     requireModulesForVSWhere();
 665     determineSourceDir();
 666 
 667     # Prefer Enterprise, then Professional, then Community, then
 668     # anything else that provides MSBuild.
 669     foreach my $productType ((
 670         &#39;Microsoft.VisualStudio.Product.Enterprise&#39;,
 671         &#39;Microsoft.VisualStudio.Product.Professional&#39;,
 672         &#39;Microsoft.VisualStudio.Product.Community&#39;,
 673         undef
 674     )) {
 675         my $command = &quot;$sourceDir/WebKitLibraries/win/tools/vswhere -nologo -latest -format json -requires Microsoft.Component.MSBuild&quot;;
 676         if (defined $productType) {
 677             $command .= &quot; -products $productType&quot;;
 678         }
 679         my $vsWhereOut = `$command`;
 680         my $installations = [];
 681         eval {
 682             $installations = JSON::PP::decode_json(Encode::encode(&#39;UTF-8&#39; =&gt; Encode::decode(console_in =&gt; $vsWhereOut)));
 683         };
 684         print &quot;Error getting Visual Studio Location: $@\n&quot; if $@;
 685         undef $@;
 686 
 687         if (scalar @$installations) {
 688             my $installation = $installations-&gt;[0];
 689             $vsWhereFoundInstallation = $installation;
 690             return $installation;
 691         }
 692     }
 693     return undef;
 694 }
 695 
 696 sub visualStudioInstallDir
 697 {
 698     return $vsInstallDir if defined $vsInstallDir;
 699 
 700     if ($ENV{&#39;VSINSTALLDIR&#39;}) {
 701         $vsInstallDir = $ENV{&#39;VSINSTALLDIR&#39;};
 702         $vsInstallDir =~ s|[\\/]$||;
 703     } else {
 704         $vsInstallDir = visualStudioInstallDirVSWhere();
 705         if (not -e $vsInstallDir) {
 706             $vsInstallDir = visualStudioInstallDirFallback();
 707         }
 708     }
 709     chomp($vsInstallDir = `cygpath &quot;$vsInstallDir&quot;`) if isCygwin();
 710 
 711     print &quot;Using Visual Studio: $vsInstallDir\n&quot;;
 712     return $vsInstallDir;
 713 }
 714 
 715 sub visualStudioInstallDirVSWhere
 716 {
 717     pickCurrentVisualStudioInstallation();
 718     if (defined($vsWhereFoundInstallation)) {
 719         return $vsWhereFoundInstallation-&gt;{installationPath};
 720     }
 721     return undef;
 722 }
 723 
 724 sub visualStudioInstallDirFallback
 725 {
 726     foreach my $productType ((
 727         &#39;Enterprise&#39;,
 728         &#39;Professional&#39;,
 729         &#39;Community&#39;,
 730     )) {
 731         my $installdir = File::Spec-&gt;catdir(programFilesPathX86(),
 732             &quot;Microsoft Visual Studio&quot;, &quot;2017&quot;, $productType);
 733         my $msbuilddir = File::Spec-&gt;catdir($installdir,
 734             &quot;MSBuild&quot;, &quot;15.0&quot;, &quot;bin&quot;);
 735         if (-e $installdir &amp;&amp; -e $msbuilddir) {
 736             return $installdir;
 737         }
 738     }
 739     return undef;
 740 }
 741 
 742 sub msBuildInstallDir
 743 {
 744     return $msBuildInstallDir if defined $msBuildInstallDir;
 745 
 746     my $installDir = visualStudioInstallDir();
 747     $msBuildInstallDir = File::Spec-&gt;catdir($installDir,
 748         &quot;MSBuild&quot;, &quot;15.0&quot;, &quot;bin&quot;);
 749 
 750     chomp($msBuildInstallDir = `cygpath &quot;$msBuildInstallDir&quot;`) if isCygwin();
 751 
 752     print &quot;Using MSBuild: $msBuildInstallDir\n&quot;;
 753     return $msBuildInstallDir;
 754 }
 755 
 756 sub determineConfigurationForVisualStudio
 757 {
 758     return if defined $configurationForVisualStudio;
 759     determineConfiguration();
 760     # FIXME: We should detect when Debug_All or Production has been chosen.
 761     $configurationForVisualStudio = &quot;/p:Configuration=&quot; . $configuration;
 762 }
 763 
 764 sub usesPerConfigurationBuildDirectory
 765 {
 766     # [Gtk] We don&#39;t have Release/Debug configurations in straight
 767     # autotool builds (non build-webkit). In this case and if
 768     # WEBKIT_OUTPUTDIR exist, use that as our configuration dir. This will
 769     # allows us to run run-webkit-tests without using build-webkit.
 770     return ($ENV{&quot;WEBKIT_OUTPUTDIR&quot;} &amp;&amp; isGtk()) || isAppleWinWebKit() || isJava();
 771 }
 772 
 773 sub determineConfigurationProductDir
 774 {
 775     return if defined $configurationProductDir;
 776     determineBaseProductDir();
 777     determineConfiguration();
 778     if (isAppleWinWebKit() || isWinCairo() || isPlayStation()) {
 779         $configurationProductDir = File::Spec-&gt;catdir($baseProductDir, $configuration);
 780     } else {
 781         if (usesPerConfigurationBuildDirectory()) {
 782             $configurationProductDir = &quot;$baseProductDir&quot;;
 783         } else {
 784             $configurationProductDir = &quot;$baseProductDir/$configuration&quot;;
 785             $configurationProductDir .= &quot;-&quot; . xcodeSDKPlatformName() if isEmbeddedWebKit();
 786         }
 787     }
 788 }
 789 
 790 sub setConfigurationProductDir($)
 791 {
 792     ($configurationProductDir) = @_;
 793 }
 794 
 795 sub determineCurrentSVNRevision
 796 {
 797     # We always update the current SVN revision here, and leave the caching
 798     # to currentSVNRevision(), so that changes to the SVN revision while the
 799     # script is running can be picked up by calling this function again.
 800     determineSourceDir();
 801     $currentSVNRevision = svnRevisionForDirectory($sourceDir);
 802     return $currentSVNRevision;
 803 }
 804 
 805 
 806 sub chdirWebKit
 807 {
 808     determineSourceDir();
 809     chdir $sourceDir or die;
 810 }
 811 
 812 sub baseProductDir
 813 {
 814     determineBaseProductDir();
 815     return $baseProductDir;
 816 }
 817 
 818 sub sourceDir
 819 {
 820     determineSourceDir();
 821     return $sourceDir;
 822 }
 823 
 824 sub productDir
 825 {
 826     determineConfigurationProductDir();
 827     return $configurationProductDir;
 828 }
 829 
 830 sub executableProductDir
 831 {
 832     my $productDirectory = productDir();
 833 
 834     my $binaryDirectory;
 835     if (isAnyWindows()) {
 836         $binaryDirectory = isWin64() ? &quot;bin64&quot; : &quot;bin32&quot;;
 837     } elsif (isGtk() || isJSCOnly() || isWPE()) {
 838         $binaryDirectory = &quot;bin&quot;;
 839     } else {
 840         return $productDirectory;
 841     }
 842 
 843     return File::Spec-&gt;catdir($productDirectory, $binaryDirectory);
 844 }
 845 
 846 sub jscProductDir
 847 {
 848     return executableProductDir();
 849 }
 850 
 851 sub configuration()
 852 {
 853     determineConfiguration();
 854     return $configuration;
 855 }
 856 
 857 sub asanIsEnabled()
 858 {
 859     determineASanIsEnabled();
 860     return $asanIsEnabled;
 861 }
 862 
 863 sub ltoMode()
 864 {
 865     determineLTOMode();
 866     return $ltoMode;
 867 }
 868 
 869 sub configurationForVisualStudio()
 870 {
 871     determineConfigurationForVisualStudio();
 872     return $configurationForVisualStudio;
 873 }
 874 
 875 sub currentSVNRevision
 876 {
 877     determineCurrentSVNRevision() if not defined $currentSVNRevision;
 878     return $currentSVNRevision;
 879 }
 880 
 881 sub generateDsym()
 882 {
 883     determineGenerateDsym();
 884     return $generateDsym;
 885 }
 886 
 887 sub determineGenerateDsym()
 888 {
 889     return if defined($generateDsym);
 890     $generateDsym = checkForArgumentAndRemoveFromARGV(&quot;--dsym&quot;);
 891 }
 892 
 893 sub hasIOSDevelopmentCertificate()
 894 {
 895     return !exitStatus(system(&quot;security find-identity -p codesigning | grep &#39;&quot; . IOS_DEVELOPMENT_CERTIFICATE_NAME_PREFIX . &quot;&#39; &gt; /dev/null 2&gt;&amp;1&quot;));
 896 }
 897 
 898 sub argumentsForXcode()
 899 {
 900     my @args = ();
 901     push @args, &quot;DEBUG_INFORMATION_FORMAT=dwarf-with-dsym&quot; if generateDsym();
 902     return @args;
 903 }
 904 
 905 sub XcodeOptions
 906 {
 907     determineBaseProductDir();
 908     determineConfiguration();
 909     determineArchitecture();
 910     determineASanIsEnabled();
 911     determineLTOMode();
 912     determineXcodeSDK();
 913 
 914     my @options;
 915     push @options, &quot;-UseNewBuildSystem=NO&quot;;
 916     push @options, &quot;-UseSanitizedBuildSystemEnvironment=YES&quot;;
 917     push @options, (&quot;-configuration&quot;, $configuration);
 918     push @options, (&quot;-xcconfig&quot;, sourceDir() . &quot;/Tools/asan/asan.xcconfig&quot;, &quot;ASAN_IGNORE=&quot; . sourceDir() . &quot;/Tools/asan/webkit-asan-ignore.txt&quot;) if $asanIsEnabled;
 919     push @options, &quot;WK_LTO_MODE=$ltoMode&quot; if $ltoMode;
 920     push @options, @baseProductDirOption;
 921     push @options, &quot;ARCHS=$architecture&quot; if $architecture;
 922     push @options, &quot;SDKROOT=$xcodeSDK&quot; if $xcodeSDK;
 923     if (willUseIOSDeviceSDK()) {
 924         push @options, &quot;ENABLE_BITCODE=NO&quot;;
 925         if (hasIOSDevelopmentCertificate()) {
 926             # FIXME: May match more than one installed development certificate.
 927             push @options, &quot;CODE_SIGN_IDENTITY=&quot; . IOS_DEVELOPMENT_CERTIFICATE_NAME_PREFIX;
 928         } else {
 929             push @options, &quot;CODE_SIGN_IDENTITY=&quot;; # No identity
 930             push @options, &quot;CODE_SIGNING_REQUIRED=NO&quot;;
 931         }
 932     }
 933     push @options, argumentsForXcode();
 934     return @options;
 935 }
 936 
 937 sub XcodeOptionString
 938 {
 939     return join &quot; &quot;, XcodeOptions();
 940 }
 941 
 942 sub XcodeOptionStringNoConfig
 943 {
 944     return join &quot; &quot;, @baseProductDirOption;
 945 }
 946 
 947 sub XcodeCoverageSupportOptions()
 948 {
 949     my @coverageSupportOptions = ();
 950     push @coverageSupportOptions, &quot;GCC_GENERATE_TEST_COVERAGE_FILES=YES&quot;;
 951     push @coverageSupportOptions, &quot;GCC_INSTRUMENT_PROGRAM_FLOW_ARCS=YES&quot;;
 952     return @coverageSupportOptions;
 953 }
 954 
 955 sub XcodeStaticAnalyzerOption()
 956 {
 957     return &quot;RUN_CLANG_STATIC_ANALYZER=YES&quot;;
 958 }
 959 
 960 my $passedConfiguration;
 961 my $searchedForPassedConfiguration;
 962 sub determinePassedConfiguration
 963 {
 964     return if $searchedForPassedConfiguration;
 965     $searchedForPassedConfiguration = 1;
 966     $passedConfiguration = undef;
 967 
 968     if (checkForArgumentAndRemoveFromARGV(&quot;--debug&quot;)) {
 969         $passedConfiguration = &quot;Debug&quot;;
 970     } elsif(checkForArgumentAndRemoveFromARGV(&quot;--release&quot;)) {
 971         $passedConfiguration = &quot;Release&quot;;
 972     } elsif (checkForArgumentAndRemoveFromARGV(&quot;--profile&quot;) || checkForArgumentAndRemoveFromARGV(&quot;--profiling&quot;)) {
 973         $passedConfiguration = &quot;Profiling&quot;;
 974     }
 975 }
 976 
 977 sub passedConfiguration
 978 {
 979     determinePassedConfiguration();
 980     return $passedConfiguration;
 981 }
 982 
 983 sub setConfiguration
 984 {
 985     setArchitecture();
 986 
 987     if (my $config = shift @_) {
 988         $configuration = $config;
 989         return;
 990     }
 991 
 992     determinePassedConfiguration();
 993     $configuration = $passedConfiguration if $passedConfiguration;
 994 }
 995 
 996 
 997 my $passedArchitecture;
 998 my $searchedForPassedArchitecture;
 999 sub determinePassedArchitecture
1000 {
1001     return if $searchedForPassedArchitecture;
1002     $searchedForPassedArchitecture = 1;
1003 
1004     $passedArchitecture = undef;
1005     if (shouldBuild32Bit()) {
1006         if (isAppleCocoaWebKit()) {
1007             # PLATFORM_IOS: Don&#39;t run `arch` command inside Simulator environment
1008             local %ENV = %ENV;
1009             delete $ENV{DYLD_ROOT_PATH};
1010             delete $ENV{DYLD_FRAMEWORK_PATH};
1011 
1012             $passedArchitecture = `arch`;
1013             chomp $passedArchitecture;
1014         }
1015     }
1016 }
1017 
1018 sub passedArchitecture
1019 {
1020     determinePassedArchitecture();
1021     return $passedArchitecture;
1022 }
1023 
1024 sub architecture()
1025 {
1026     determineArchitecture();
1027     return $architecture;
1028 }
1029 
1030 sub numberOfCPUs()
1031 {
1032     determineNumberOfCPUs();
1033     return $numberOfCPUs;
1034 }
1035 
1036 sub maxCPULoad()
1037 {
1038     determineMaxCPULoad();
1039     return $maxCPULoad;
1040 }
1041 
1042 sub setArchitecture
1043 {
1044     if (my $arch = shift @_) {
1045         $architecture = $arch;
1046         return;
1047     }
1048 
1049     determinePassedArchitecture();
1050     $architecture = $passedArchitecture if $passedArchitecture;
1051 }
1052 
1053 # Locate Safari.
1054 sub safariPath
1055 {
1056     die &quot;Safari path is only relevant on Apple Mac platform\n&quot; unless isAppleMacWebKit();
1057 
1058     my $safariPath;
1059 
1060     # Use WEBKIT_SAFARI environment variable if present.
1061     my $safariBundle = $ENV{WEBKIT_SAFARI};
1062     if (!$safariBundle) {
1063         determineConfigurationProductDir();
1064         # Use Safari.app in product directory if present (good for Safari development team).
1065         if (-d &quot;$configurationProductDir/Safari.app&quot;) {
1066             $safariBundle = &quot;$configurationProductDir/Safari.app&quot;;
1067         }
1068     }
1069 
1070     if ($safariBundle) {
1071         $safariPath = &quot;$safariBundle/Contents/MacOS/Safari&quot;;
1072     } else {
1073         $safariPath = &quot;/Applications/Safari.app/Contents/MacOS/SafariForWebKitDevelopment&quot;;
1074     }
1075 
1076     die &quot;Can&#39;t find executable at $safariPath.\n&quot; if !-x $safariPath;
1077     return $safariPath;
1078 }
1079 
1080 sub builtDylibPathForName
1081 {
1082     my $libraryName = shift;
1083     determineConfigurationProductDir();
1084 
1085     if (isGtk()) {
1086         my $extension = isDarwin() ? &quot;.dylib&quot; : &quot;.so&quot;;
1087         return &quot;$configurationProductDir/lib/libwebkit2gtk-4.0&quot; . $extension;
1088     }
1089     if (isIOSWebKit()) {
1090         return &quot;$configurationProductDir/$libraryName.framework/$libraryName&quot;;
1091     }
1092     if (isAppleCocoaWebKit()) {
1093         return &quot;$configurationProductDir/$libraryName.framework/Versions/A/$libraryName&quot;;
1094     }
1095     if (isAppleWinWebKit()) {
1096         if ($libraryName eq &quot;JavaScriptCore&quot;) {
1097             return &quot;$baseProductDir/lib/$libraryName.lib&quot;;
1098         } else {
1099             return &quot;$baseProductDir/$libraryName.intermediate/$configuration/$libraryName.intermediate/$libraryName.lib&quot;;
1100         }
1101     }
1102     if (isJava()) {
1103         my $extension = isDarwin() ? &quot;.dylib&quot; : &quot;.so&quot;;
1104         return &quot;$configurationProductDir/lib/libjfxwebkit&quot; . $extension;
1105     }
1106     if (isWPE()) {
1107         return &quot;$configurationProductDir/lib/libWPEWebKit-0.1.so&quot;;
1108     }
1109 
1110     die &quot;Unsupported platform, can&#39;t determine built library locations.\nTry `build-webkit --help` for more information.\n&quot;;
1111 }
1112 
1113 # Check to see that all the frameworks are built.
1114 sub checkFrameworks # FIXME: This is a poor name since only the Mac calls built WebCore a Framework.
1115 {
1116     return if isAnyWindows() || isJava();
1117     my @frameworks = (&quot;JavaScriptCore&quot;, &quot;WebCore&quot;);
1118     push(@frameworks, &quot;WebKit&quot;) if isAppleCocoaWebKit(); # FIXME: This seems wrong, all ports should have a WebKit these days.
1119     for my $framework (@frameworks) {
1120         my $path = builtDylibPathForName($framework);
1121         die &quot;Can&#39;t find built framework at \&quot;$path\&quot;.\n&quot; unless -e $path;
1122     }
1123 }
1124 
1125 sub isInspectorFrontend()
1126 {
1127     determineIsInspectorFrontend();
1128     return $isInspectorFrontend;
1129 }
1130 
1131 sub determineIsInspectorFrontend()
1132 {
1133     return if defined($isInspectorFrontend);
1134     $isInspectorFrontend = checkForArgumentAndRemoveFromARGV(&quot;--inspector-frontend&quot;);
1135 }
1136 
1137 sub commandExists($)
1138 {
1139     my $command = shift;
1140     my $devnull = File::Spec-&gt;devnull();
1141 
1142     if (isAnyWindows()) {
1143         return exitStatus(system(&quot;where /q $command &gt;$devnull 2&gt;&amp;1&quot;)) == 0;
1144     }
1145     return exitStatus(system(&quot;which $command &gt;$devnull 2&gt;&amp;1&quot;)) == 0;
1146 }
1147 
1148 sub checkForArgumentAndRemoveFromARGV($)
1149 {
1150     my $argToCheck = shift;
1151     return checkForArgumentAndRemoveFromArrayRef($argToCheck, \@ARGV);
1152 }
1153 
1154 sub checkForArgumentAndRemoveFromArrayRefGettingValue($$$)
1155 {
1156     my ($argToCheck, $valueRef, $arrayRef) = @_;
1157     my $argumentStartRegEx = qr#^$argToCheck(?:=\S|$)#;
1158     my $i = 0;
1159     for (; $i &lt; @$arrayRef; ++$i) {
1160         last if $arrayRef-&gt;[$i] =~ $argumentStartRegEx;
1161     }
1162     if ($i &gt;= @$arrayRef) {
1163         return $$valueRef = undef;
1164     }
1165     my ($key, $value) = split(&quot;=&quot;, $arrayRef-&gt;[$i]);
1166     splice(@$arrayRef, $i, 1);
1167     if (defined($value)) {
1168         # e.g. --sdk=iphonesimulator
1169         return $$valueRef = $value;
1170     }
1171     return $$valueRef = splice(@$arrayRef, $i, 1); # e.g. --sdk iphonesimulator
1172 }
1173 
1174 sub checkForArgumentAndRemoveFromARGVGettingValue($$)
1175 {
1176     my ($argToCheck, $valueRef) = @_;
1177     return checkForArgumentAndRemoveFromArrayRefGettingValue($argToCheck, $valueRef, \@ARGV);
1178 }
1179 
1180 sub findMatchingArguments($$)
1181 {
1182     my ($argToCheck, $arrayRef) = @_;
1183     my @matchingIndices;
1184     foreach my $index (0 .. $#$arrayRef) {
1185         my $opt = $$arrayRef[$index];
1186         if ($opt =~ /^$argToCheck$/i ) {
1187             push(@matchingIndices, $index);
1188         }
1189     }
1190     return @matchingIndices; 
1191 }
1192 
1193 sub hasArgument($$)
1194 {
1195     my ($argToCheck, $arrayRef) = @_;
1196     my @matchingIndices = findMatchingArguments($argToCheck, $arrayRef);
1197     return scalar @matchingIndices &gt; 0;
1198 }
1199 
1200 sub checkForArgumentAndRemoveFromArrayRef
1201 {
1202     my ($argToCheck, $arrayRef) = @_;
1203     my @indicesToRemove = findMatchingArguments($argToCheck, $arrayRef);
1204     my $removeOffset = 0;
1205     foreach my $index (@indicesToRemove) {
1206         splice(@$arrayRef, $index - $removeOffset++, 1);
1207     }
1208     return scalar @indicesToRemove &gt; 0;
1209 }
1210 
1211 sub prohibitUnknownPort()
1212 {
1213     $unknownPortProhibited = 1;
1214 }
1215 
1216 sub determinePortName()
1217 {
1218     return if defined $portName;
1219 
1220     my %argToPortName = (
1221         gtk =&gt; GTK,
1222         &#39;jsc-only&#39; =&gt; JSCOnly,
1223         playstation =&gt; PlayStation,
1224         wincairo =&gt; WinCairo,
1225         java =&gt; Java,
1226         wpe =&gt; WPE
1227     );
1228 
1229     for my $arg (sort keys %argToPortName) {
1230         if (checkForArgumentAndRemoveFromARGV(&quot;--$arg&quot;)) {
1231             die &quot;Argument &#39;--$arg&#39; conflicts with selected port &#39;$portName&#39;\n&quot;
1232                 if defined $portName;
1233 
1234             $portName = $argToPortName{$arg};
1235         }
1236     }
1237 
1238     return if defined $portName;
1239 
1240     # Port was not selected via command line, use appropriate default value
1241 
1242     if (isAnyWindows()) {
1243         $portName = AppleWin;
1244     } elsif (isDarwin()) {
1245         determineXcodeSDK();
1246         if (willUseIOSDeviceSDK() || willUseIOSSimulatorSDK()) {
1247             $portName = iOS;
1248         } elsif (willUseAppleTVDeviceSDK() || willUseAppleTVSimulatorSDK()) {
1249             $portName = tvOS;
1250         } elsif (willUseWatchDeviceSDK() || willUseWatchSimulatorSDK()) {
1251             $portName = watchOS;
1252         } else {
1253             $portName = Mac;
1254         }
1255     } else {
1256         if ($unknownPortProhibited) {
1257             my $portsChoice = join &quot;\n\t&quot;, qw(
1258                 --gtk
1259                 --jsc-only
1260                 --wpe
1261             );
1262             die &quot;Please specify which WebKit port to build using one of the following options:&quot;
1263                 . &quot;\n\t$portsChoice\n&quot;;
1264         }
1265 
1266         # If script is run without arguments we cannot determine port
1267         # TODO: This state should be outlawed
1268         $portName = Unknown;
1269     }
1270 }
1271 
1272 sub portName()
1273 {
1274     determinePortName();
1275     return $portName;
1276 }
1277 
1278 sub isGtk()
1279 {
1280     return portName() eq GTK;
1281 }
1282 
1283 sub determineIsJava()
1284 {
1285     return if defined($isJava);
1286     $isJava = checkForArgumentAndRemoveFromARGV(&quot;--java&quot;);
1287 }
1288 
1289 sub isJava()
1290 {
1291     return portName() eq Java;
1292 }
1293 
1294 sub isJSCOnly()
1295 {
1296     return portName() eq JSCOnly;
1297 }
1298 
1299 sub isWPE()
1300 {
1301     return portName() eq WPE;
1302 }
1303 
1304 sub isPlayStation()
1305 {
1306     return portName() eq PlayStation;
1307 }
1308 
1309 # Determine if this is debian, ubuntu, linspire, or something similar.
1310 sub isDebianBased()
1311 {
1312     return -e &quot;/etc/debian_version&quot;;
1313 }
1314 
1315 sub isFedoraBased()
1316 {
1317     return -e &quot;/etc/fedora-release&quot;;
1318 }
1319 
1320 sub isWinCairo()
1321 {
1322     return portName() eq WinCairo;
1323 }
1324 
1325 sub shouldBuild32Bit()
1326 {
1327     determineShouldBuild32Bit();
1328     return $shouldBuild32Bit;
1329 }
1330 
1331 sub determineShouldBuild32Bit()
1332 {
1333     return if defined($shouldBuild32Bit);
1334     $shouldBuild32Bit = checkForArgumentAndRemoveFromARGV(&quot;--32-bit&quot;);
1335 }
1336 
1337 sub isWin64()
1338 {
1339     determineIsWin64();
1340     return $isWin64;
1341 }
1342 
1343 sub determineIsWin64()
1344 {
1345     return if defined($isWin64);
1346     $isWin64 = checkForArgumentAndRemoveFromARGV(&quot;--64-bit&quot;) || ((isWinCairo() || isJSCOnly()) &amp;&amp; !shouldBuild32Bit());
1347 }
1348 
1349 sub determineIsWin64FromArchitecture($)
1350 {
1351     my $arch = shift;
1352     $isWin64 = ($arch eq &quot;x86_64&quot;);
1353     return $isWin64;
1354 }
1355 
1356 sub isCygwin()
1357 {
1358     return ($^O eq &quot;cygwin&quot;) || 0;
1359 }
1360 
1361 sub isAnyWindows()
1362 {
1363     return isWindows() || isCygwin();
1364 }
1365 
1366 sub determineWinVersion()
1367 {
1368     return if $winVersion;
1369 
1370     if (!isAnyWindows()) {
1371         $winVersion = -1;
1372         return;
1373     }
1374 
1375     my $versionString = `cmd /c ver`;
1376     $versionString =~ /(\d)\.(\d)\.(\d+)/;
1377 
1378     $winVersion = {
1379         major =&gt; $1,
1380         minor =&gt; $2,
1381         build =&gt; $3,
1382     };
1383 }
1384 
1385 sub winVersion()
1386 {
1387     determineWinVersion();
1388     return $winVersion;
1389 }
1390 
1391 sub isWindows7SP0()
1392 {
1393     return isAnyWindows() &amp;&amp; winVersion()-&gt;{major} == 6 &amp;&amp; winVersion()-&gt;{minor} == 1 &amp;&amp; winVersion()-&gt;{build} == 7600;
1394 }
1395 
1396 sub isWindowsVista()
1397 {
1398     return isAnyWindows() &amp;&amp; winVersion()-&gt;{major} == 6 &amp;&amp; winVersion()-&gt;{minor} == 0;
1399 }
1400 
1401 sub isWindowsXP()
1402 {
1403     return isAnyWindows() &amp;&amp; winVersion()-&gt;{major} == 5 &amp;&amp; winVersion()-&gt;{minor} == 1;
1404 }
1405 
1406 sub isDarwin()
1407 {
1408     return ($^O eq &quot;darwin&quot;) || 0;
1409 }
1410 
1411 sub isWindows()
1412 {
1413     return ($^O eq &quot;MSWin32&quot;) || 0;
1414 }
1415 
1416 sub isLinux()
1417 {
1418     return ($^O eq &quot;linux&quot;) || 0;
1419 }
1420 
1421 sub isBSD()
1422 {
1423     return ($^O eq &quot;freebsd&quot;) || ($^O eq &quot;openbsd&quot;) || ($^O eq &quot;netbsd&quot;) || 0;
1424 }
1425 
1426 sub isX86_64()
1427 {
1428     return (architecture() eq &quot;x86_64&quot;) || 0;
1429 }
1430 
1431 sub isARM64()
1432 {
1433     return (architecture() eq &quot;arm64&quot;) || 0;
1434 }
1435 
1436 sub isCrossCompilation()
1437 {
1438     my $compiler = &quot;&quot;;
1439     $compiler = $ENV{&#39;CC&#39;} if (defined($ENV{&#39;CC&#39;}));
1440     if ($compiler =~ /gcc/) {
1441         my $compilerOptions = `$compiler -v 2&gt;&amp;1`;
1442         my @host = $compilerOptions =~ m/--host=(.*?)\s/;
1443         my @target = $compilerOptions =~ m/--target=(.*?)\s/;
1444         if ($target[0] ne &quot;&quot; &amp;&amp; $host[0] ne &quot;&quot;) {
1445                 return ($host[0] ne $target[0]);
1446         } else {
1447                 # $tempDir gets automatically deleted when goes out of scope
1448                 my $tempDir = File::Temp-&gt;newdir();
1449                 my $testProgramSourcePath = File::Spec-&gt;catfile($tempDir, &quot;testcross.c&quot;);
1450                 my $testProgramBinaryPath = File::Spec-&gt;catfile($tempDir, &quot;testcross&quot;);
1451                 open(my $testProgramSourceHandler, &quot;&gt;&quot;, $testProgramSourcePath);
1452                 print $testProgramSourceHandler &quot;int main() { return 0; }\n&quot;;
1453                 system(&quot;$compiler $testProgramSourcePath -o $testProgramBinaryPath &gt; /dev/null 2&gt;&amp;1&quot;) == 0 or return 0;
1454                 # Crosscompiling if the program fails to run (because it was built for other arch)
1455                 system(&quot;$testProgramBinaryPath &gt; /dev/null 2&gt;&amp;1&quot;) == 0 or return 1;
1456                 return 0;
1457         }
1458     }
1459     return 0;
1460 }
1461 
1462 sub isIOSWebKit()
1463 {
1464     return portName() eq iOS;
1465 }
1466 
1467 sub isTVOSWebKit()
1468 {
1469     return portName() eq tvOS;
1470 }
1471 
1472 sub isWatchOSWebKit()
1473 {
1474     return portName() eq watchOS;
1475 }
1476 
1477 sub isEmbeddedWebKit()
1478 {
1479     return isIOSWebKit() || isTVOSWebKit() || isWatchOSWebKit();
1480 }
1481 
1482 sub isAppleWebKit()
1483 {
1484     return !isJava() &amp;&amp; (isAppleCocoaWebKit() || isAppleWinWebKit());
1485 }
1486 
1487 sub isAppleMacWebKit()
1488 {
1489     return portName() eq Mac;
1490 }
1491 
1492 sub isAppleCocoaWebKit()
1493 {
1494     return isAppleMacWebKit() || isEmbeddedWebKit();
1495 }
1496 
1497 sub isAppleWinWebKit()
1498 {
1499     return portName() eq AppleWin;
1500 }
1501 
1502 sub iOSSimulatorDevicesPath
1503 {
1504     return &quot;$ENV{HOME}/Library/Developer/CoreSimulator/Devices&quot;;
1505 }
1506 
1507 sub iOSSimulatorDevices
1508 {
1509     eval &quot;require Foundation&quot;;
1510     my $devicesPath = iOSSimulatorDevicesPath();
1511     opendir(DEVICES, $devicesPath);
1512     my @udids = grep {
1513         $_ =~ m/^[0-9A-F]{8}-([0-9A-F]{4}-){3}[0-9A-F]{12}$/;
1514     } readdir(DEVICES);
1515     close(DEVICES);
1516 
1517     # FIXME: We should parse the device.plist file ourself and map the dictionary keys in it to known
1518     #        dictionary keys so as to decouple our representation of the plist from the actual structure
1519     #        of the plist, which may change.
1520     my @devices = map {
1521         Foundation::perlRefFromObjectRef(NSDictionary-&gt;dictionaryWithContentsOfFile_(&quot;$devicesPath/$_/device.plist&quot;));
1522     } @udids;
1523 
1524     return @devices;
1525 }
1526 
1527 sub createiOSSimulatorDevice
1528 {
1529     my $name = shift;
1530     my $deviceTypeId = shift;
1531     my $runtimeId = shift;
1532 
1533     my $created = system(&quot;xcrun&quot;, &quot;--sdk&quot;, &quot;iphonesimulator&quot;, &quot;simctl&quot;, &quot;create&quot;, $name, $deviceTypeId, $runtimeId) == 0;
1534     die &quot;Couldn&#39;t create simulator device: $name $deviceTypeId $runtimeId&quot; if not $created;
1535 
1536     system(&quot;xcrun&quot;, &quot;--sdk&quot;, &quot;iphonesimulator&quot;, &quot;simctl&quot;, &quot;list&quot;);
1537 
1538     print &quot;Waiting for device to be created ...\n&quot;;
1539     sleep 5;
1540     for (my $tries = 0; $tries &lt; 5; $tries++){
1541         my @devices = iOSSimulatorDevices();
1542         foreach my $device (@devices) {
1543             return $device if $device-&gt;{name} eq $name and $device-&gt;{deviceType} eq $deviceTypeId and $device-&gt;{runtime} eq $runtimeId;
1544         }
1545         sleep 5;
1546     }
1547     die &quot;Device $name $deviceTypeId $runtimeId wasn&#39;t found in &quot; . iOSSimulatorDevicesPath();
1548 }
1549 
1550 sub willUseIOSDeviceSDK()
1551 {
1552     return xcodeSDKPlatformName() eq &quot;iphoneos&quot;;
1553 }
1554 
1555 sub willUseIOSSimulatorSDK()
1556 {
1557     return xcodeSDKPlatformName() eq &quot;iphonesimulator&quot;;
1558 }
1559 
1560 sub willUseAppleTVDeviceSDK()
1561 {
1562     return xcodeSDKPlatformName() eq &quot;appletvos&quot;;
1563 }
1564 
1565 sub willUseAppleTVSimulatorSDK()
1566 {
1567     return xcodeSDKPlatformName() eq &quot;appletvsimulator&quot;;
1568 }
1569 
1570 sub willUseWatchDeviceSDK()
1571 {
1572     return xcodeSDKPlatformName() eq &quot;watchos&quot;;
1573 }
1574 
1575 sub willUseWatchSimulatorSDK()
1576 {
1577     return xcodeSDKPlatformName() eq &quot;watchsimulator&quot;;
1578 }
1579 
1580 sub determineNmPath()
1581 {
1582     return if $nmPath;
1583 
1584     if (isAppleCocoaWebKit()) {
1585         $nmPath = `xcrun -find nm`;
1586         chomp $nmPath;
1587     }
1588     $nmPath = &quot;nm&quot; if !$nmPath;
1589 }
1590 
1591 sub nmPath()
1592 {
1593     determineNmPath();
1594     return $nmPath;
1595 }
1596 
1597 sub splitVersionString
1598 {
1599     my $versionString = shift;
1600     my @splitVersion = split(/\./, $versionString);
1601     @splitVersion &gt;= 2 or die &quot;Invalid version $versionString&quot;;
1602     $osXVersion = {
1603             &quot;major&quot; =&gt; $splitVersion[0],
1604             &quot;minor&quot; =&gt; $splitVersion[1],
1605             &quot;subminor&quot; =&gt; (defined($splitVersion[2]) ? $splitVersion[2] : 0),
1606     };
1607 }
1608 
1609 sub determineOSXVersion()
1610 {
1611     return if $osXVersion;
1612 
1613     if (!isDarwin()) {
1614         $osXVersion = -1;
1615         return;
1616     }
1617 
1618     my $versionString = `sw_vers -productVersion`;
1619     $osXVersion = splitVersionString($versionString);
1620 }
1621 
1622 sub osXVersion()
1623 {
1624     determineOSXVersion();
1625     return $osXVersion;
1626 }
1627 
1628 sub determineIOSVersion()
1629 {
1630     return if $iosVersion;
1631 
1632     if (!isIOSWebKit()) {
1633         $iosVersion = -1;
1634         return;
1635     }
1636 
1637     my $versionString = xcodeSDKVersion();
1638     $iosVersion = splitVersionString($versionString);
1639 }
1640 
1641 sub iosVersion()
1642 {
1643     determineIOSVersion();
1644     return $iosVersion;
1645 }
1646 
1647 sub isWindowsNT()
1648 {
1649     return $ENV{&#39;OS&#39;} eq &#39;Windows_NT&#39;;
1650 }
1651 
1652 sub appendToEnvironmentVariableList($$)
1653 {
1654     my ($name, $value) = @_;
1655 
1656     if (defined($ENV{$name})) {
1657         $ENV{$name} .= $Config{path_sep} . $value;
1658     } else {
1659         $ENV{$name} = $value;
1660     }
1661 }
1662 
1663 sub prependToEnvironmentVariableList($$)
1664 {
1665     my ($name, $value) = @_;
1666 
1667     if (defined($ENV{$name})) {
1668         $ENV{$name} = $value . $Config{path_sep} . $ENV{$name};
1669     } else {
1670         $ENV{$name} = $value;
1671     }
1672 }
1673 
1674 sub sharedCommandLineOptions()
1675 {
1676     return (
1677         &quot;g|guard-malloc&quot; =&gt; \$shouldUseGuardMalloc,
1678     );
1679 }
1680 
1681 sub sharedCommandLineOptionsUsage
1682 {
1683     my %opts = @_;
1684 
1685     my %switches = (
1686         &#39;-g|--guard-malloc&#39; =&gt; &#39;Use guardmalloc when running executable&#39;,
1687     );
1688 
1689     my $indent = &quot; &quot; x ($opts{indent} || 2);
1690     my $switchWidth = List::Util::max(int($opts{switchWidth}), List::Util::max(map { length($_) } keys %switches) + ($opts{brackets} ? 2 : 0));
1691 
1692     my $result = &quot;Common switches:\n&quot;;
1693 
1694     for my $switch (keys %switches) {
1695         my $switchName = $opts{brackets} ? &quot;[&quot; . $switch . &quot;]&quot; : $switch;
1696         $result .= sprintf(&quot;%s%-&quot; . $switchWidth . &quot;s %s\n&quot;, $indent, $switchName, $switches{$switch});
1697     }
1698 
1699     return $result;
1700 }
1701 
1702 sub setUpGuardMallocIfNeeded
1703 {
1704     if (!isDarwin()) {
1705         return;
1706     }
1707 
1708     if (!defined($shouldUseGuardMalloc)) {
1709         $shouldUseGuardMalloc = checkForArgumentAndRemoveFromARGV(&quot;-g&quot;) || checkForArgumentAndRemoveFromARGV(&quot;--guard-malloc&quot;);
1710     }
1711 
1712     if ($shouldUseGuardMalloc) {
1713         appendToEnvironmentVariableList(&quot;DYLD_INSERT_LIBRARIES&quot;, &quot;/usr/lib/libgmalloc.dylib&quot;);
1714         appendToEnvironmentVariableList(&quot;__XPC_DYLD_INSERT_LIBRARIES&quot;, &quot;/usr/lib/libgmalloc.dylib&quot;);
1715     }
1716 }
1717 
1718 sub relativeScriptsDir()
1719 {
1720     my $scriptDir = File::Spec-&gt;catpath(&quot;&quot;, File::Spec-&gt;abs2rel($FindBin::Bin, getcwd()), &quot;&quot;);
1721     if ($scriptDir eq &quot;&quot;) {
1722         $scriptDir = &quot;.&quot;;
1723     }
1724     return $scriptDir;
1725 }
1726 
1727 sub launcherPath()
1728 {
1729     my $relativeScriptsPath = relativeScriptsDir();
1730     if (isGtk() || isWPE()) {
1731         if (inFlatpakSandbox()) {
1732             return &quot;Tools/Scripts/run-minibrowser&quot;;
1733         }
1734         return &quot;$relativeScriptsPath/run-minibrowser&quot;;
1735     } elsif (isAppleWebKit()) {
1736         return &quot;$relativeScriptsPath/run-safari&quot;;
1737     }
1738 }
1739 
1740 sub launcherName()
1741 {
1742     if (isGtk() || isWPE()) {
1743         return &quot;MiniBrowser&quot;;
1744     } elsif (isAppleMacWebKit()) {
1745         return &quot;Safari&quot;;
1746     } elsif (isAppleWinWebKit()) {
1747         return &quot;MiniBrowser&quot;;
1748     }
1749 }
1750 
1751 sub checkRequiredSystemConfig
1752 {
1753     if (isDarwin()) {
1754         chomp(my $productVersion = `sw_vers -productVersion`);
1755         if (eval &quot;v$productVersion&quot; lt v10.10.5) {
1756             print &quot;*************************************************************\n&quot;;
1757             print &quot;OS X Yosemite v10.10.5 or later is required to build WebKit.\n&quot;;
1758             print &quot;You have &quot; . $productVersion . &quot;, thus the build will most likely fail.\n&quot;;
1759             print &quot;*************************************************************\n&quot;;
1760         }
1761         determineXcodeVersion();
1762         if (eval &quot;v$xcodeVersion&quot; lt v7.0) {
1763             print &quot;*************************************************************\n&quot;;
1764             print &quot;Xcode 7.0 or later is required to build WebKit.\n&quot;;
1765             print &quot;You have an earlier version of Xcode, thus the build will\n&quot;;
1766             print &quot;most likely fail. The latest Xcode is available from the App Store.\n&quot;;
1767             print &quot;*************************************************************\n&quot;;
1768         }
1769     }
1770 }
1771 
1772 sub determineWindowsSourceDir()
1773 {
1774     return if $windowsSourceDir;
1775     $windowsSourceDir = sourceDir();
1776     chomp($windowsSourceDir = `cygpath -w &#39;$windowsSourceDir&#39;`) if isCygwin();
1777 }
1778 
1779 sub windowsSourceDir()
1780 {
1781     determineWindowsSourceDir();
1782     return $windowsSourceDir;
1783 }
1784 
1785 sub windowsSourceSourceDir()
1786 {
1787     return File::Spec-&gt;catdir(windowsSourceDir(), &quot;Source&quot;);
1788 }
1789 
1790 sub windowsLibrariesDir()
1791 {
1792     return File::Spec-&gt;catdir(windowsSourceDir(), &quot;WebKitLibraries&quot;, &quot;win&quot;);
1793 }
1794 
1795 sub windowsOutputDir()
1796 {
1797     return File::Spec-&gt;catdir(windowsSourceDir(), &quot;WebKitBuild&quot;);
1798 }
1799 
1800 sub fontExists($)
1801 {
1802     my $font = shift;
1803     my $cmd = &quot;reg query \&quot;HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Fonts\&quot; /v \&quot;$font\&quot; 2&gt;&amp;1&quot;;
1804     my $val = `$cmd`;
1805     return $? == 0;
1806 }
1807 
1808 sub checkInstalledTools()
1809 {
1810     # environment variables. Avoid until this is corrected.
1811     my $pythonVer = `python --version 2&gt;&amp;1`;
1812     die &quot;You must have Python installed to build WebKit.\n&quot; if ($?);
1813 
1814     # cURL 7.34.0 has a bug that prevents authentication with opensource.apple.com (and other things using SSL3).
1815     my $curlVer = `curl --version 2&gt; NUL`;
1816     if (!$? and $curlVer =~ &quot;(.*curl.*)&quot;) {
1817         $curlVer = $1;
1818         if ($curlVer =~ /libcurl\/7\.34\.0/) {
1819             print &quot;cURL version 7.34.0 has a bug that prevents authentication with SSL v2 or v3.\n&quot;;
1820             print &quot;cURL 7.33.0 is known to work. The cURL projects is preparing an update to\n&quot;;
1821             print &quot;correct this problem.\n\n&quot;;
1822             die &quot;Please install a working cURL and try again.\n&quot;;
1823         }
1824     }
1825 
1826     # MathML requires fonts that may not ship with Windows.
1827     # Warn the user if they are missing.
1828     my @fonts = (&#39;Cambria &amp; Cambria Math (TrueType)&#39;, &#39;LatinModernMath-Regular (TrueType)&#39;, &#39;STIXMath-Regular (TrueType)&#39;);
1829     my @missing = ();
1830     foreach my $font (@fonts) {
1831         push @missing, $font if not fontExists($font);
1832     }
1833 
1834     if (scalar @missing &gt; 0) {
1835         print &quot;*************************************************************\n&quot;;
1836         print &quot;Mathematical fonts, such as Latin Modern Math are needed to\n&quot;;
1837         print &quot;use the MathML feature.  You do not appear to have these fonts\n&quot;;
1838         print &quot;on your system.\n\n&quot;;
1839         print &quot;You can download a suitable set of fonts from the following URL:\n&quot;;
1840         print &quot;https://trac.webkit.org/wiki/MathML/Fonts\n&quot;;
1841         print &quot;*************************************************************\n&quot;;
1842     }
1843 
1844     print &quot;Installed tools are correct for the WebKit build.\n&quot;;
1845 }
1846 
1847 sub setupAppleWinEnv()
1848 {
1849     return unless isAppleWinWebKit();
1850 
1851     checkInstalledTools();
1852 
1853     if (isWindowsNT()) {
1854         my $restartNeeded = 0;
1855         my %variablesToSet = ();
1856 
1857         # FIXME: We should remove this explicit version check for cygwin once we stop supporting Cygwin 1.7.9 or older versions. 
1858         # https://bugs.webkit.org/show_bug.cgi?id=85791
1859         my $uname_version = (POSIX::uname())[2];
1860         $uname_version =~ s/\(.*\)//;  # Remove the trailing cygwin version, if any.
1861         $uname_version =~ s/\-.*$//; # Remove trailing dash-version content, if any
1862         if (version-&gt;parse($uname_version) &lt; version-&gt;parse(&quot;1.7.10&quot;)) {
1863             # Setting the environment variable &#39;CYGWIN&#39; to &#39;tty&#39; makes cygwin enable extra support (i.e., termios)
1864             # for UNIX-like ttys in the Windows console
1865             $variablesToSet{CYGWIN} = &quot;tty&quot; unless $ENV{CYGWIN};
1866         }
1867         
1868         # Those environment variables must be set to be able to build inside Visual Studio.
1869         $variablesToSet{WEBKIT_LIBRARIES} = windowsLibrariesDir() unless $ENV{WEBKIT_LIBRARIES};
1870         $variablesToSet{WEBKIT_OUTPUTDIR} = windowsOutputDir() unless $ENV{WEBKIT_OUTPUTDIR};
1871         $variablesToSet{MSBUILDDISABLENODEREUSE} = &quot;1&quot; unless $ENV{MSBUILDDISABLENODEREUSE};
1872         $variablesToSet{_IsNativeEnvironment} = &quot;true&quot; unless $ENV{_IsNativeEnvironment};
1873         $variablesToSet{PreferredToolArchitecture} = &quot;x64&quot; unless $ENV{PreferredToolArchitecture};
1874 
1875         foreach my $variable (keys %variablesToSet) {
1876             print &quot;Setting the Environment Variable &#39;&quot; . $variable . &quot;&#39; to &#39;&quot; . $variablesToSet{$variable} . &quot;&#39;\n\n&quot;;
1877             my $ret = system &quot;setx&quot;, $variable, $variablesToSet{$variable};
1878             if ($ret != 0) {
1879                 system qw(regtool -s set), &#39;\\HKEY_CURRENT_USER\\Environment\\&#39; . $variable, $variablesToSet{$variable};
1880             }
1881             $restartNeeded ||=  $variable eq &quot;WEBKIT_LIBRARIES&quot; || $variable eq &quot;WEBKIT_OUTPUTDIR&quot;;
1882         }
1883 
1884         if ($restartNeeded) {
1885             print &quot;Please restart your computer before attempting to build inside Visual Studio.\n\n&quot;;
1886         }
1887     } else {
1888         if (!defined $ENV{&#39;WEBKIT_LIBRARIES&#39;} || !$ENV{&#39;WEBKIT_LIBRARIES&#39;}) {
1889             print &quot;Warning: You must set the &#39;WebKit_Libraries&#39; environment variable\n&quot;;
1890             print &quot;         to be able build WebKit from within Visual Studio 2017 and newer.\n&quot;;
1891             print &quot;         Make sure that &#39;WebKit_Libraries&#39; points to the\n&quot;;
1892             print &quot;         &#39;WebKitLibraries/win&#39; directory, not the &#39;WebKitLibraries/&#39; directory.\n\n&quot;;
1893         }
1894         if (!defined $ENV{&#39;WEBKIT_OUTPUTDIR&#39;} || !$ENV{&#39;WEBKIT_OUTPUTDIR&#39;}) {
1895             print &quot;Warning: You must set the &#39;WebKit_OutputDir&#39; environment variable\n&quot;;
1896             print &quot;         to be able build WebKit from within Visual Studio 2017 and newer.\n\n&quot;;
1897         }
1898         if (!defined $ENV{&#39;MSBUILDDISABLENODEREUSE&#39;} || !$ENV{&#39;MSBUILDDISABLENODEREUSE&#39;}) {
1899             print &quot;Warning: You should set the &#39;MSBUILDDISABLENODEREUSE&#39; environment variable to &#39;1&#39;\n&quot;;
1900             print &quot;         to avoid periodic locked log files when building.\n\n&quot;;
1901         }
1902     }
1903     # FIXME (125180): Remove the following temporary 64-bit support once official support is available.
1904     if (isWin64() and !$ENV{&#39;WEBKIT_64_SUPPORT&#39;}) {
1905         print &quot;Warning: You must set the &#39;WEBKIT_64_SUPPORT&#39; environment variable\n&quot;;
1906         print &quot;         to be able run WebKit or JavaScriptCore tests.\n\n&quot;;
1907     }
1908 }
1909 
1910 sub setupCygwinEnv()
1911 {
1912     return if !isAnyWindows();
1913     return if $vcBuildPath;
1914 
1915     my $programFilesPath = programFilesPath();
1916     my $visualStudioPath = File::Spec-&gt;catfile(visualStudioInstallDir(), qw(Common7 IDE devenv.com));
1917 
1918     print &quot;Building results into: &quot;, baseProductDir(), &quot;\n&quot;;
1919     print &quot;WEBKIT_OUTPUTDIR is set to: &quot;, $ENV{&quot;WEBKIT_OUTPUTDIR&quot;}, &quot;\n&quot;;
1920     print &quot;WEBKIT_LIBRARIES is set to: &quot;, $ENV{&quot;WEBKIT_LIBRARIES&quot;}, &quot;\n&quot;;
1921     # FIXME (125180): Remove the following temporary 64-bit support once official support is available.
1922     print &quot;WEBKIT_64_SUPPORT is set to: &quot;, $ENV{&quot;WEBKIT_64_SUPPORT&quot;}, &quot;\n&quot; if isWin64();
1923 
1924     # We will actually use MSBuild to build WebKit, but we need to find the Visual Studio install (above) to make
1925     # sure we use the right options.
1926     $vcBuildPath = File::Spec-&gt;catfile(msBuildInstallDir(), qw(MSBuild.exe));
1927     if (! -e $vcBuildPath) {
1928         print &quot;*************************************************************\n&quot;;
1929         print &quot;Cannot find &#39;$vcBuildPath&#39;\n&quot;;
1930         print &quot;Please make sure execute that the Microsoft .NET Framework SDK\n&quot;;
1931         print &quot;is installed on this machine.\n&quot;;
1932         print &quot;*************************************************************\n&quot;;
1933         die;
1934     }
1935 }
1936 
1937 sub buildXCodeProject($$@)
1938 {
1939     my ($project, $clean, @extraOptions) = @_;
1940 
1941     if ($clean) {
1942         push(@extraOptions, &quot;-alltargets&quot;);
1943         push(@extraOptions, &quot;clean&quot;);
1944     }
1945 
1946     chomp($ENV{DSYMUTIL_NUM_THREADS} = `sysctl -n hw.activecpu`);
1947     return system &quot;xcodebuild&quot;, &quot;-project&quot;, &quot;$project.xcodeproj&quot;, @extraOptions;
1948 }
1949 
1950 sub getMSBuildPlatformArgument()
1951 {
1952     if (isPlayStation()) {
1953         return &quot;&quot;;
1954     } elsif (isWin64()) {
1955         return &quot;/p:Platform=x64&quot;;
1956     } else {
1957         return &quot;/p:Platform=Win32&quot;;
1958     }
1959 }
1960 
1961 sub buildVisualStudioProject
1962 {
1963     my ($project, $clean) = @_;
1964     setupCygwinEnv();
1965 
1966     my $config = configurationForVisualStudio();
1967 
1968     chomp($project = `cygpath -w &quot;$project&quot;`) if isCygwin();
1969 
1970     my $action = &quot;/t:build&quot;;
1971     if ($clean) {
1972         $action = &quot;/t:clean&quot;;
1973     }
1974 
1975     my $platform = getMSBuildPlatformArgument();
1976     my $logPath = File::Spec-&gt;catdir($baseProductDir, $configuration);
1977     make_path($logPath) unless -d $logPath or $logPath eq &quot;.&quot;;
1978 
1979     my $errorLogFile = File::Spec-&gt;catfile($logPath, &quot;webkit_errors.log&quot;);
1980     chomp($errorLogFile = `cygpath -w &quot;$errorLogFile&quot;`) if isCygwin();
1981     my $errorLogging = &quot;/flp:LogFile=&quot; . $errorLogFile . &quot;;ErrorsOnly&quot;;
1982 
1983     my $warningLogFile = File::Spec-&gt;catfile($logPath, &quot;webkit_warnings.log&quot;);
1984     chomp($warningLogFile = `cygpath -w &quot;$warningLogFile&quot;`) if isCygwin();
1985     my $warningLogging = &quot;/flp1:LogFile=&quot; . $warningLogFile . &quot;;WarningsOnly&quot;;
1986 
1987     my $maxCPUCount = &#39;/maxcpucount:&#39; . numberOfCPUs();
1988 
1989     my @command = ($vcBuildPath, &quot;/verbosity:minimal&quot;, $project, $action, $config, $platform, &quot;/fl&quot;, $errorLogging, &quot;/fl1&quot;, $warningLogging, $maxCPUCount);
1990     print join(&quot; &quot;, @command), &quot;\n&quot;;
1991     return system @command;
1992 }
1993 
1994 sub getJhbuildPath()
1995 {
1996     my @jhbuildPath = File::Spec-&gt;splitdir(baseProductDir());
1997     if (isGit() &amp;&amp; isGitBranchBuild() &amp;&amp; gitBranch()) {
1998         pop(@jhbuildPath);
1999     }
2000     if (isGtk()) {
2001         push(@jhbuildPath, &quot;DependenciesGTK&quot;);
2002     } elsif (isJava()) {
2003         push(@jhbuildPath, &quot;DependenciesJava&quot;);
2004     } elsif (isWPE()) {
2005         push(@jhbuildPath, &quot;DependenciesWPE&quot;);
2006     } else {
2007         die &quot;Cannot get JHBuild path for platform that isn&#39;t GTK+ or WPE.\n&quot;;
2008     }
2009     return File::Spec-&gt;catdir(@jhbuildPath);
2010 }
2011 
2012 sub getFlatpakPath()
2013 {
2014     my @flatpakBuildPath = File::Spec-&gt;splitdir(baseProductDir());
2015     if (isGtk()) {
2016         push(@flatpakBuildPath, &quot;GTK&quot;);
2017     } elsif (isWPE()) {
2018         push(@flatpakBuildPath, &quot;WPE&quot;);
2019     } else {
2020         die &quot;Cannot get Flatpak path for platform that isn&#39;t GTK+ or WPE.\n&quot;;
2021     }
2022     my @configuration = configuration();
2023     push(@flatpakBuildPath, &quot;FlatpakTree$configuration&quot;);
2024 
2025     return File::Spec-&gt;catdir(@flatpakBuildPath);
2026 }
2027 
2028 sub isCachedArgumentfileOutOfDate($@)
2029 {
2030     my ($filename, $currentContents) = @_;
2031 
2032     if (! -e $filename) {
2033         return 1;
2034     }
2035 
2036     open(CONTENTS_FILE, $filename);
2037     chomp(my $previousContents = &lt;CONTENTS_FILE&gt; || &quot;&quot;);
2038     close(CONTENTS_FILE);
2039 
2040     if ($previousContents ne $currentContents) {
2041         print &quot;Contents for file $filename have changed.\n&quot;;
2042         print &quot;Previous contents were: $previousContents\n\n&quot;;
2043         print &quot;New contents are: $currentContents\n&quot;;
2044         return 1;
2045     }
2046 
2047     return 0;
2048 }
2049 
2050 sub inFlatpakSandbox()
2051 {
2052     if (-f &quot;/.flatpak-info&quot;) {
2053         return 1;
2054     }
2055 
2056     return 0;
2057 }
2058 
2059 sub runInFlatpak(@)
2060 {
2061     my @arg = @_;
2062     my @command = (File::Spec-&gt;catfile(sourceDir(), &quot;Tools&quot;, &quot;Scripts&quot;, &quot;webkit-flatpak&quot;));
2063     exec @command, argumentsForConfiguration(), &quot;--command&quot;, @_, argumentsForConfiguration(), @ARGV or die;
2064 }
2065 
2066 sub runInFlatpakIfAvailable(@)
2067 {
2068     if (inFlatpakSandbox()) {
2069         return 0;
2070     }
2071 
2072     my @command = (File::Spec-&gt;catfile(sourceDir(), &quot;Tools&quot;, &quot;Scripts&quot;, &quot;webkit-flatpak&quot;));
2073     if (system(@command, &quot;--available&quot;) != 0) {
2074         return 0;
2075     }
2076 
2077     if (! -e getFlatpakPath()) {
2078         return 0;
2079     }
2080 
2081     runInFlatpak(@_)
2082 }
2083 
2084 sub wrapperPrefixIfNeeded()
2085 {
2086     if (isJava()) {
2087         return ();
2088     }
2089 
2090     if (isAnyWindows() || isJSCOnly() || isPlayStation()) {
2091         return ();
2092     }
2093     if (isAppleCocoaWebKit()) {
2094         return (&quot;xcrun&quot;);
2095     }
2096     if (-e getJhbuildPath()) {
2097         my @prefix = (File::Spec-&gt;catfile(sourceDir(), &quot;Tools&quot;, &quot;jhbuild&quot;, &quot;jhbuild-wrapper&quot;));
2098         if (isGtk()) {
2099             push(@prefix, &quot;--gtk&quot;);
2100         } elsif (isWPE()) {
2101             push(@prefix, &quot;--wpe&quot;);
2102         }
2103         push(@prefix, &quot;run&quot;);
2104 
2105         return @prefix;
2106     }
2107 
2108     return ();
2109 }
2110 
2111 sub shouldUseJhbuild()
2112 {
2113     return ((isGtk() or isWPE()) and -e getJhbuildPath());
2114 }
2115 
2116 sub shouldUseFlatpak()
2117 {
2118     return ((isGtk() or isWPE()) and ! inFlatpakSandbox() and -e getFlatpakPath());
2119 }
2120 
2121 sub cmakeCachePath()
2122 {
2123     return File::Spec-&gt;catdir(baseProductDir(), configuration(), &quot;CMakeCache.txt&quot;);
2124 }
2125 
2126 sub cmakeFilesPath()
2127 {
2128     return File::Spec-&gt;catdir(baseProductDir(), configuration(), &quot;CMakeFiles&quot;);
2129 }
2130 
2131 sub shouldRemoveCMakeCache(@)
2132 {
2133     my ($cacheFilePath, @buildArgs) = @_;
2134 
2135     # We check this first, because we always want to create this file for a fresh build.
2136     my $productDir = File::Spec-&gt;catdir(baseProductDir(), configuration());
2137     my $optionsCache = File::Spec-&gt;catdir($productDir, &quot;build-webkit-options.txt&quot;);
2138     my $joinedBuildArgs = join(&quot; &quot;, @buildArgs);
2139     if (isCachedArgumentfileOutOfDate($optionsCache, $joinedBuildArgs)) {
2140         File::Path::mkpath($productDir) unless -d $productDir;
2141         open(CACHED_ARGUMENTS, &quot;&gt;&quot;, $optionsCache);
2142         print CACHED_ARGUMENTS $joinedBuildArgs;
2143         close(CACHED_ARGUMENTS);
2144 
2145         return 1;
2146     }
2147 
2148     my $cmakeCache = cmakeCachePath();
2149     unless (-e $cmakeCache) {
2150         return 0;
2151     }
2152 
2153     my $cacheFileModifiedTime = stat($cmakeCache)-&gt;mtime;
2154     my $platformConfiguration = File::Spec-&gt;catdir(sourceDir(), &quot;Source&quot;, &quot;cmake&quot;, &quot;Options&quot; . cmakeBasedPortName() . &quot;.cmake&quot;);
2155     if ($cacheFileModifiedTime &lt; stat($platformConfiguration)-&gt;mtime) {
2156         return 1;
2157     }
2158 
2159     my $globalConfiguration = File::Spec-&gt;catdir(sourceDir(), &quot;Source&quot;, &quot;cmake&quot;, &quot;OptionsCommon.cmake&quot;);
2160     if ($cacheFileModifiedTime &lt; stat($globalConfiguration)-&gt;mtime) {
2161         return 1;
2162     }
2163 
2164     unless (isJava()) {
2165     # FIXME: This probably does not work as expected, or the next block to
2166     # delete the images subdirectory would not be here. Directory mtime does not
2167     # percolate upwards when files are added or removed from subdirectories.
2168     my $inspectorUserInterfaceDirectory = File::Spec-&gt;catdir(sourceDir(), &quot;Source&quot;, &quot;WebInspectorUI&quot;, &quot;UserInterface&quot;);
2169     if ($cacheFileModifiedTime &lt; stat($inspectorUserInterfaceDirectory)-&gt;mtime) {
2170         return 1;
2171     }
2172 
2173     my $inspectorImageDirectory = File::Spec-&gt;catdir(sourceDir(), &quot;Source&quot;, &quot;WebInspectorUI&quot;, &quot;UserInterface&quot;, &quot;Images&quot;);
2174     if ($cacheFileModifiedTime &lt; stat($inspectorImageDirectory)-&gt;mtime) {
2175         return 1;
2176     }
2177     }
2178 
2179     if(isAnyWindows()) {
2180         my $winConfiguration = File::Spec-&gt;catdir(sourceDir(), &quot;Source&quot;, &quot;cmake&quot;, &quot;OptionsWin.cmake&quot;);
2181         if ($cacheFileModifiedTime &lt; stat($winConfiguration)-&gt;mtime) {
2182             return 1;
2183         }
2184     }
2185 
2186     return 0;
2187 }
2188 
2189 sub removeCMakeCache(@)
2190 {
2191     my (@buildArgs) = @_;
2192     if (shouldRemoveCMakeCache(@buildArgs)) {
2193         my $cmakeCache = cmakeCachePath();
2194         my $cmakeFiles = cmakeFilesPath();
2195         unlink($cmakeCache) if -e $cmakeCache;
2196         rmtree($cmakeFiles) if -d $cmakeFiles;
2197     }
2198 }
2199 
2200 sub canUseNinja(@)
2201 {
2202     if (!defined($shouldNotUseNinja)) {
2203         $shouldNotUseNinja = checkForArgumentAndRemoveFromARGV(&quot;--no-ninja&quot;);
2204     }
2205 
2206     if ($shouldNotUseNinja) {
2207         return 0;
2208     }
2209 
2210     if (isAppleCocoaWebKit()) {
2211         my $devnull = File::Spec-&gt;devnull();
2212         if (exitStatus(system(&quot;xcrun -find ninja &gt;$devnull 2&gt;&amp;1&quot;)) == 0) {
2213             return 1;
2214         }
2215     }
2216 
2217     # Test both ninja and ninja-build. Fedora uses ninja-build and has patched CMake to also call ninja-build.
2218     return commandExists(&quot;ninja&quot;) || commandExists(&quot;ninja-build&quot;);
2219 }
2220 
2221 sub canUseEclipseNinjaGenerator(@)
2222 {
2223     # Check that eclipse and eclipse Ninja generator is installed
2224     my $devnull = File::Spec-&gt;devnull();
2225     return commandExists(&quot;eclipse&quot;) &amp;&amp; exitStatus(system(&quot;cmake -N -G &#39;Eclipse CDT4 - Ninja&#39; &gt;$devnull 2&gt;&amp;1&quot;)) == 0;
2226 }
2227 
2228 sub cmakeGeneratedBuildfile(@)
2229 {
2230     my ($willUseNinja) = @_;
2231     if ($willUseNinja) {
2232         return File::Spec-&gt;catfile(baseProductDir(), configuration(), &quot;build.ninja&quot;)
2233     } elsif (isAnyWindows()) {
2234         return File::Spec-&gt;catfile(baseProductDir(), configuration(), &quot;WebKit.sln&quot;)
2235     } else {
2236         return File::Spec-&gt;catfile(baseProductDir(), configuration(), &quot;Makefile&quot;)
2237     }
2238     return 0;
2239 }
2240 
2241 sub generateBuildSystemFromCMakeProject
2242 {
2243     my ($prefixPath, @cmakeArgs) = @_;
2244     my $config = configuration();
2245     my $port = cmakeBasedPortName();
2246     my $buildPath = File::Spec-&gt;catdir(baseProductDir(), $config);
2247     File::Path::mkpath($buildPath) unless -d $buildPath;
2248     my $originalWorkingDirectory = getcwd();
2249     chdir($buildPath) or die;
2250 
2251     # We try to be smart about when to rerun cmake, so that we can have faster incremental builds.
2252     my $willUseNinja = canUseNinja();
2253     if (-e cmakeCachePath() &amp;&amp; -e cmakeGeneratedBuildfile($willUseNinja)) {
2254         return 0;
2255     }
2256 
2257     my @args;
2258     push @args, &quot;-DPORT=\&quot;$port\&quot;&quot;;
2259     push @args, &quot;-DCMAKE_INSTALL_PREFIX=\&quot;$prefixPath\&quot;&quot; if $prefixPath;
2260     push @args, &quot;-DCMAKE_EXPORT_COMPILE_COMMANDS=ON&quot;;
2261     if ($config =~ /release/i) {
2262         push @args, &quot;-DCMAKE_BUILD_TYPE=Release&quot;;
2263     } elsif ($config =~ /debug/i) {
2264         push @args, &quot;-DCMAKE_BUILD_TYPE=Debug&quot;;
2265     }
2266 
2267     push @args, &quot;-DENABLE_ADDRESS_SANITIZER=ON&quot; if asanIsEnabled();
2268 
2269     push @args, &#39;-DCMAKE_TOOLCHAIN_FILE=Platform/PlayStation&#39; if isPlayStation();
2270 
2271     if ($willUseNinja) {
2272         push @args, &quot;-G&quot;;
2273         if (canUseEclipseNinjaGenerator()) {
2274             push @args, &quot;&#39;Eclipse CDT4 - Ninja&#39;&quot;;
2275         } else {
2276             push @args, &quot;Ninja&quot;;
2277         }
2278         push @args, &quot;-DUSE_THIN_ARCHIVES=OFF&quot; if isPlayStation();
2279     } elsif (isJava() &amp;&amp; isAnyWindows()) {
2280         push @args, &quot;-G&quot;;
2281         if (isWin64()) {
2282             push @args, &#39;&quot;Visual Studio 15 2017 Win64&quot;&#39;;
2283             push @args, &#39;-DCMAKE_GENERATOR_TOOLSET=&quot;host=x64&quot;&#39;;
2284         } else {
2285             push @args, &#39;&quot;Visual Studio 15 2017&quot;&#39;;
2286         }
2287     } elsif (isAnyWindows() &amp;&amp; isWin64()) {
2288         push @args, &#39;-G &quot;Visual Studio 15 2017 Win64&quot;&#39;;
2289         push @args, &#39;-DCMAKE_GENERATOR_TOOLSET=&quot;host=x64&quot;&#39;;
2290     } elsif (isPlayStation()) {
2291         push @args, &#39;-G &quot;Visual Studio 15&quot;&#39;;
2292     }
2293 
2294     # Do not show progress of generating bindings in interactive Ninja build not to leave noisy lines on tty
2295     push @args, &#39;-DSHOW_BINDINGS_GENERATION_PROGRESS=1&#39; unless ($willUseNinja &amp;&amp; -t STDOUT);
2296 
2297     # Some ports have production mode, but build-webkit should always use developer mode.
2298     push @args, &quot;-DDEVELOPER_MODE=ON&quot; if isGtk() || isJSCOnly() || isWPE() || isWinCairo();
2299 
2300     push @args, @cmakeArgs if @cmakeArgs;
2301 
2302     my $cmakeSourceDir = isCygwin() ? windowsSourceDir() : sourceDir();
2303     push @args, &#39;&quot;&#39; . $cmakeSourceDir . &#39;&quot;&#39;;
2304 
2305     # We call system(&quot;cmake @args&quot;) instead of system(&quot;cmake&quot;, @args) so that @args is
2306     # parsed for shell metacharacters.
2307     my $wrapper = join(&quot; &quot;, wrapperPrefixIfNeeded()) . &quot; &quot;;
2308     my $returnCode = systemVerbose($wrapper . &quot;cmake @args&quot;);
2309 
2310     chdir($originalWorkingDirectory);
2311     return $returnCode;
2312 }
2313 
2314 sub buildCMakeGeneratedProject($)
2315 {
2316     my (@makeArgs) = @_;
2317     my $config = configuration();
2318     my $buildPath = File::Spec-&gt;catdir(baseProductDir(), $config);
2319     if (! -d $buildPath) {
2320         die &quot;Must call generateBuildSystemFromCMakeProject() before building CMake project.&quot;;
2321     }
2322 
2323     if ($ENV{VERBOSE} &amp;&amp; canUseNinja()) {
2324         push @makeArgs, &quot;-v&quot;;
2325         push @makeArgs, &quot;-d keeprsp&quot; if (version-&gt;parse(determineNinjaVersion()) &gt;= version-&gt;parse(&quot;1.4.0&quot;));
2326     }
2327 
2328     chomp($buildPath = `cygpath -m &#39;$buildPath&#39;`) if isCygwin();
2329 
2330     my $command = &quot;cmake&quot;;
2331     my @args = (&quot;--build&quot;, $buildPath, &quot;--config&quot;, $config);
2332     push @args, (&quot;--&quot;, @makeArgs) if @makeArgs;
2333 
2334     # GTK and JSCOnly can use a build script to preserve colors and pretty-printing.
2335     if ((isGtk() || isJSCOnly()) &amp;&amp; -e &quot;$buildPath/build.sh&quot;) {
2336         chdir &quot;$buildPath&quot; or die;
2337         $command = &quot;$buildPath/build.sh&quot;;
2338         @args = (@makeArgs);
2339     }
2340 
2341     # We call system(&quot;cmake @args&quot;) instead of system(&quot;cmake&quot;, @args) so that @args is
2342     # parsed for shell metacharacters. In particular, @makeArgs may contain such metacharacters.
2343     my $wrapper = join(&quot; &quot;, wrapperPrefixIfNeeded()) . &quot; &quot;;
2344     return systemVerbose($wrapper . &quot;$command @args&quot;);
2345 }
2346 
2347 sub cleanCMakeGeneratedProject()
2348 {
2349     my $config = configuration();
2350     my $buildPath = File::Spec-&gt;catdir(baseProductDir(), $config);
2351     if (-d $buildPath) {
2352         return systemVerbose(&quot;cmake&quot;, &quot;--build&quot;, $buildPath, &quot;--config&quot;, $config, &quot;--target&quot;, &quot;clean&quot;);
2353     }
2354     return 0;
2355 }
2356 
2357 sub buildCMakeProjectOrExit($$$@)
2358 {
2359     my ($clean, $prefixPath, $makeArgs, @cmakeArgs) = @_;
2360     my $returnCode;
2361 
2362     exit(exitStatus(cleanCMakeGeneratedProject())) if $clean;
2363 
2364     if (isGtk() &amp;&amp; checkForArgumentAndRemoveFromARGV(&quot;--update-gtk&quot;)) {
2365         system(&quot;perl&quot;, &quot;$sourceDir/Tools/Scripts/update-webkitgtk-libs&quot;) == 0 or die $!;
2366     }
2367 
2368     if (isWPE() &amp;&amp; checkForArgumentAndRemoveFromARGV(&quot;--update-wpe&quot;)) {
2369         system(&quot;perl&quot;, &quot;$sourceDir/Tools/Scripts/update-webkitwpe-libs&quot;) == 0 or die $!;
2370     }
2371 
2372     $returnCode = exitStatus(generateBuildSystemFromCMakeProject($prefixPath, @cmakeArgs));
2373     exit($returnCode) if $returnCode;
2374     exit 0 if isGenerateProjectOnly();
2375 
2376     $returnCode = exitStatus(buildCMakeGeneratedProject($makeArgs));
2377     exit($returnCode) if $returnCode;
2378     return 0;
2379 }
2380 
2381 sub cmakeArgsFromFeatures(\@;$)
2382 {
2383     my ($featuresArrayRef, $enableExperimentalFeatures) = @_;
2384 
2385     my @args;
2386     push @args, &quot;-DENABLE_EXPERIMENTAL_FEATURES=ON&quot; if $enableExperimentalFeatures;
2387     foreach (@$featuresArrayRef) {
2388         my $featureName = $_-&gt;{define};
2389         if ($featureName) {
2390             my $featureValue = ${$_-&gt;{value}}; # Undef to let the build system use its default.
2391             if (defined($featureValue)) {
2392                 my $featureEnabled = $featureValue ? &quot;ON&quot; : &quot;OFF&quot;;
2393                 push @args, &quot;-D$featureName=$featureEnabled&quot;;
2394             }
2395         }
2396     }
2397     return @args;
2398 }
2399 
2400 sub cmakeBasedPortName()
2401 {
2402     return ucfirst portName();
2403 }
2404 
2405 sub determineIsCMakeBuild()
2406 {
2407     return if defined($isCMakeBuild);
2408     $isCMakeBuild = checkForArgumentAndRemoveFromARGV(&quot;--cmake&quot;);
2409 }
2410 
2411 sub isCMakeBuild()
2412 {
2413     return 1 unless isAppleCocoaWebKit();
2414     determineIsCMakeBuild();
2415     return $isCMakeBuild;
2416 }
2417 
2418 sub determineIsGenerateProjectOnly()
2419 {
2420     return if defined($isGenerateProjectOnly);
2421     $isGenerateProjectOnly = checkForArgumentAndRemoveFromARGV(&quot;--generate-project-only&quot;);
2422 }
2423 
2424 sub isGenerateProjectOnly()
2425 {
2426     determineIsGenerateProjectOnly();
2427     return $isGenerateProjectOnly;
2428 }
2429 
2430 sub promptUser
2431 {
2432     my ($prompt, $default) = @_;
2433     my $defaultValue = $default ? &quot;[$default]&quot; : &quot;&quot;;
2434     print &quot;$prompt $defaultValue: &quot;;
2435     chomp(my $input = &lt;STDIN&gt;);
2436     return $input ? $input : $default;
2437 }
2438 
2439 sub appleApplicationSupportPath
2440 {
2441     open INSTALL_DIR, &quot;&lt;/proc/registry/HKEY_LOCAL_MACHINE/SOFTWARE/Apple\ Inc./Apple\ Application\ Support/InstallDir&quot;;
2442     my $path = &lt;INSTALL_DIR&gt;;
2443     $path =~ s/[\r\n\x00].*//;
2444     close INSTALL_DIR;
2445 
2446     my $unixPath = `cygpath -u &#39;$path&#39;`;
2447     chomp $unixPath;
2448     return $unixPath;
2449 }
2450 
2451 sub setPathForRunningWebKitApp
2452 {
2453     my ($env) = @_;
2454 
2455     if (isAnyWindows()) {
2456         my $productBinaryDir = executableProductDir();
2457         if (isAppleWinWebKit()) {
2458             $env-&gt;{PATH} = join(&#39;:&#39;, $productBinaryDir, appleApplicationSupportPath(), $env-&gt;{PATH} || &quot;&quot;);
2459         } elsif (isWinCairo()) {
2460             my $winCairoBin = sourceDir() . &quot;/WebKitLibraries/win/&quot; . (isWin64() ? &quot;bin64/&quot; : &quot;bin32/&quot;);
2461             my $gstreamerBin = isWin64() ? $ENV{&quot;GSTREAMER_1_0_ROOT_X86_64&quot;} . &quot;bin&quot; : $ENV{&quot;GSTREAMER_1_0_ROOT_X86&quot;} . &quot;bin&quot;;
2462             $env-&gt;{PATH} = join(&#39;:&#39;, $productBinaryDir, $winCairoBin, $gstreamerBin, $env-&gt;{PATH} || &quot;&quot;);
2463         }
2464     }
2465 }
2466 
2467 sub printHelpAndExitForRunAndDebugWebKitAppIfNeeded
2468 {
2469     return unless checkForArgumentAndRemoveFromARGV(&quot;--help&quot;);
2470 
2471     print STDERR &lt;&lt;EOF;
2472 Usage: @{[basename($0)]} [options] [args ...]
2473   --help                            Show this help message
2474   --no-saved-state                  Launch the application without state restoration
2475 
2476 Options specific to macOS:
2477   -g|--guard-malloc                 Enable Guard Malloc
2478   --lang=LANGUAGE                   Use a specific language instead of system language.
2479                                     This accepts a language name (German) or a language code (de, ar, pt_BR, etc).
2480   --locale=LOCALE                   Use a specific locale instead of the system region.
2481 EOF
2482 
2483     exit(1);
2484 }
2485 
2486 sub argumentsForRunAndDebugMacWebKitApp()
2487 {
2488     my @args = ();
2489     if (checkForArgumentAndRemoveFromARGV(&quot;--no-saved-state&quot;)) {
2490         push @args, (&quot;-ApplePersistenceIgnoreStateQuietly&quot;, &quot;YES&quot;);
2491         # FIXME: Don&#39;t set ApplePersistenceIgnoreState once all supported OS versions respect ApplePersistenceIgnoreStateQuietly (rdar://15032886).
2492         push @args, (&quot;-ApplePersistenceIgnoreState&quot;, &quot;YES&quot;);
2493     }
2494 
2495     my $lang;
2496     if (checkForArgumentAndRemoveFromARGVGettingValue(&quot;--lang&quot;, \$lang)) {
2497         push @args, (&quot;-AppleLanguages&quot;, &quot;(&quot; . $lang . &quot;)&quot;);
2498     }
2499 
2500     my $locale;
2501     if (checkForArgumentAndRemoveFromARGVGettingValue(&quot;--locale&quot;, \$locale)) {
2502         push @args, (&quot;-AppleLocale&quot;, $locale);
2503     }
2504 
2505     unshift @args, @ARGV;
2506 
2507     return @args;
2508 }
2509 
2510 sub setupMacWebKitEnvironment($)
2511 {
2512     my ($dyldFrameworkPath) = @_;
2513 
2514     $dyldFrameworkPath = File::Spec-&gt;rel2abs($dyldFrameworkPath);
2515 
2516     prependToEnvironmentVariableList(&quot;DYLD_FRAMEWORK_PATH&quot;, $dyldFrameworkPath);
2517     prependToEnvironmentVariableList(&quot;__XPC_DYLD_FRAMEWORK_PATH&quot;, $dyldFrameworkPath);
2518     prependToEnvironmentVariableList(&quot;DYLD_LIBRARY_PATH&quot;, $dyldFrameworkPath);
2519     prependToEnvironmentVariableList(&quot;__XPC_DYLD_LIBRARY_PATH&quot;, $dyldFrameworkPath);
2520     $ENV{WEBKIT_UNSET_DYLD_FRAMEWORK_PATH} = &quot;YES&quot;;
2521 
2522     setUpGuardMallocIfNeeded();
2523 }
2524 
2525 sub setupIOSWebKitEnvironment($)
2526 {
2527     my ($dyldFrameworkPath) = @_;
2528     $dyldFrameworkPath = File::Spec-&gt;rel2abs($dyldFrameworkPath);
2529 
2530     prependToEnvironmentVariableList(&quot;DYLD_FRAMEWORK_PATH&quot;, $dyldFrameworkPath);
2531     prependToEnvironmentVariableList(&quot;DYLD_LIBRARY_PATH&quot;, $dyldFrameworkPath);
2532 
2533     setUpGuardMallocIfNeeded();
2534 }
2535 
2536 sub iosSimulatorApplicationsPath()
2537 {
2538     # FIXME: We should ask simctl for this information, instead of guessing from available runtimes.
2539     my $runtimePath = File::Spec-&gt;catdir(sdkPlatformDirectory(&quot;iphoneos&quot;), &quot;Developer&quot;, &quot;Library&quot;, &quot;CoreSimulator&quot;, &quot;Profiles&quot;, &quot;Runtimes&quot;);
2540     opendir(RUNTIMES, $runtimePath);
2541     my @runtimes = grep {/.*\.simruntime/} readdir(RUNTIMES);
2542     close(RUNTIMES);
2543     my $sult = File::Spec-&gt;catdir($runtimePath, @runtimes ? $runtimes[0] : &quot;iOS.simruntime&quot;, &quot;Contents&quot;, &quot;Resources&quot;, &quot;RuntimeRoot&quot;, &quot;Applications&quot;);
2544     return $sult;
2545 }
2546 
2547 sub installedMobileSafariBundle()
2548 {
2549     return File::Spec-&gt;catfile(iosSimulatorApplicationsPath(), &quot;MobileSafari.app&quot;);
2550 }
2551 
2552 sub mobileSafariBundle()
2553 {
2554     determineConfigurationProductDir();
2555 
2556     # Use MobileSafari.app in product directory if present.
2557     if (isIOSWebKit() &amp;&amp; -d &quot;$configurationProductDir/MobileSafari.app&quot;) {
2558         return &quot;$configurationProductDir/MobileSafari.app&quot;;
2559     }
2560     return installedMobileSafariBundle();
2561 }
2562 
2563 sub plistPathFromBundle($)
2564 {
2565     my ($appBundle) = @_;
2566     return &quot;$appBundle/Info.plist&quot; if -f &quot;$appBundle/Info.plist&quot;; # iOS app bundle
2567     return &quot;$appBundle/Contents/Info.plist&quot; if -f &quot;$appBundle/Contents/Info.plist&quot;; # Mac app bundle
2568     return &quot;&quot;;
2569 }
2570 
2571 sub appIdentifierFromBundle($)
2572 {
2573     my ($appBundle) = @_;
2574     my $plistPath = File::Spec-&gt;rel2abs(plistPathFromBundle($appBundle)); # defaults(1) will complain if the specified path is not absolute.
2575     chomp(my $bundleIdentifier = `defaults read &#39;$plistPath&#39; CFBundleIdentifier 2&gt; /dev/null`);
2576     return $bundleIdentifier;
2577 }
2578 
2579 sub appDisplayNameFromBundle($)
2580 {
2581     my ($appBundle) = @_;
2582     my $plistPath = File::Spec-&gt;rel2abs(plistPathFromBundle($appBundle)); # defaults(1) will complain if the specified path is not absolute.
2583     chomp(my $bundleDisplayName = `defaults read &#39;$plistPath&#39; CFBundleDisplayName 2&gt; /dev/null`);
2584     return $bundleDisplayName;
2585 }
2586 
2587 sub waitUntilIOSSimulatorDeviceIsInState($$)
2588 {
2589     my ($deviceUDID, $waitUntilState) = @_;
2590     my $device = iosSimulatorDeviceByUDID($deviceUDID);
2591     # FIXME: We should add a maximum time limit to wait here.
2592     while ($device-&gt;{state} ne $waitUntilState) {
2593         usleep(500 * 1000); # Waiting 500ms between file system polls does not make script run-safari feel sluggish.
2594         $device = iosSimulatorDeviceByUDID($deviceUDID);
2595     }
2596 }
2597 
2598 sub waitUntilProcessNotRunning($)
2599 {
2600     my ($process) = @_;
2601     while (system(&quot;/bin/ps -eo pid,comm | /usr/bin/grep &#39;$process\$&#39;&quot;) == 0) {
2602         usleep(500 * 1000);
2603     }
2604 }
2605 
2606 sub shutDownIOSSimulatorDevice($)
2607 {
2608     my ($simulatorDevice) = @_;
2609     system(&quot;xcrun --sdk iphonesimulator simctl shutdown $simulatorDevice-&gt;{UDID} &gt; /dev/null 2&gt;&amp;1&quot;);
2610 }
2611 
2612 sub restartIOSSimulatorDevice($)
2613 {
2614     my ($simulatorDevice) = @_;
2615     shutDownIOSSimulatorDevice($simulatorDevice);
2616 
2617     exitStatus(system(&quot;xcrun&quot;, &quot;--sdk&quot;, &quot;iphonesimulator&quot;, &quot;simctl&quot;, &quot;boot&quot;, $simulatorDevice-&gt;{UDID})) == 0 or die &quot;Failed to boot simulator device $simulatorDevice-&gt;{UDID}&quot;;
2618 }
2619 
2620 sub relaunchIOSSimulator($)
2621 {
2622     my ($simulatedDevice) = @_;
2623     quitIOSSimulator($simulatedDevice-&gt;{UDID});
2624 
2625     # FIXME: &lt;rdar://problem/20916140&gt; Switch to using CoreSimulator.framework for launching and quitting iOS Simulator
2626     chomp(my $developerDirectory = $ENV{DEVELOPER_DIR} || `xcode-select --print-path`); 
2627     my $iosSimulatorPath = File::Spec-&gt;catfile($developerDirectory, &quot;Applications&quot;, &quot;Simulator.app&quot;); 
2628     system(&quot;open&quot;, &quot;-a&quot;, $iosSimulatorPath, &quot;--args&quot;, &quot;-CurrentDeviceUDID&quot;, $simulatedDevice-&gt;{UDID}) == 0 or die &quot;Failed to open $iosSimulatorPath: $!&quot;; 
2629 
2630     waitUntilIOSSimulatorDeviceIsInState($simulatedDevice-&gt;{UDID}, SIMULATOR_DEVICE_STATE_BOOTED);
2631     waitUntilProcessNotRunning(&quot;com.apple.datamigrator&quot;);
2632 }
2633 
2634 sub quitIOSSimulator(;$)
2635 {
2636     my ($waitForShutdownOfSimulatedDeviceUDID) = @_;
2637     # FIXME: &lt;rdar://problem/20916140&gt; Switch to using CoreSimulator.framework for launching and quitting iOS Simulator
2638     if (exitStatus(system {&quot;osascript&quot;} &quot;osascript&quot;, &quot;-e&quot;, &#39;tell application id &quot;com.apple.iphonesimulator&quot; to quit&#39;)) {
2639         # osascript returns a non-zero exit status if Simulator.app is not registered in LaunchServices.
2640         return;
2641     }
2642 
2643     if (!defined($waitForShutdownOfSimulatedDeviceUDID)) {
2644         return;
2645     }
2646     # FIXME: We assume that $waitForShutdownOfSimulatedDeviceUDID was not booted using the simctl command line tool.
2647     #        Otherwise we will spin indefinitely since quiting the iOS Simulator will not shutdown this device. We
2648     #        should add a maximum time limit to wait for a device to shutdown and either return an error or die()
2649     #        on expiration of the time limit.
2650     waitUntilIOSSimulatorDeviceIsInState($waitForShutdownOfSimulatedDeviceUDID, SIMULATOR_DEVICE_STATE_SHUTDOWN);
2651 }
2652 
2653 sub iosSimulatorDeviceByName($)
2654 {
2655     my ($simulatorName) = @_;
2656     my $simulatorRuntime = iosSimulatorRuntime();
2657     my @devices = iOSSimulatorDevices();
2658     for my $device (@devices) {
2659         if ($device-&gt;{name} eq $simulatorName &amp;&amp; $device-&gt;{runtime} eq $simulatorRuntime) {
2660             return $device;
2661         }
2662     }
2663     return undef;
2664 }
2665 
2666 sub iosSimulatorDeviceByUDID($)
2667 {
2668     my ($simulatedDeviceUDID) = @_;
2669     my $devicePlistPath = File::Spec-&gt;catfile(iOSSimulatorDevicesPath(), $simulatedDeviceUDID, &quot;device.plist&quot;);
2670     if (!-f $devicePlistPath) {
2671         return;
2672     }
2673     # FIXME: We should parse the device.plist file ourself and map the dictionary keys in it to known
2674     #        dictionary keys so as to decouple our representation of the plist from the actual structure
2675     #        of the plist, which may change.
2676     eval &quot;require Foundation&quot;;
2677     return Foundation::perlRefFromObjectRef(NSDictionary-&gt;dictionaryWithContentsOfFile_($devicePlistPath));
2678 }
2679 
2680 sub iosSimulatorRuntime()
2681 {
2682     my $xcodeSDKVersion = xcodeSDKVersion();
2683     $xcodeSDKVersion =~ s/\./-/;
2684     return &quot;com.apple.CoreSimulator.SimRuntime.iOS-$xcodeSDKVersion&quot;;
2685 }
2686 
2687 sub findOrCreateSimulatorForIOSDevice($)
2688 {
2689     my ($simulatorNameSuffix) = @_;
2690     my $simulatorName;
2691     my $simulatorDeviceType;
2692     if (architecture() eq &quot;x86_64&quot;) {
2693         $simulatorName = &quot;iPhone SE &quot; . $simulatorNameSuffix;
2694         $simulatorDeviceType = &quot;com.apple.CoreSimulator.SimDeviceType.iPhone-SE&quot;;
2695     } else {
2696         $simulatorName = &quot;iPhone 5 &quot; . $simulatorNameSuffix;
2697         $simulatorDeviceType = &quot;com.apple.CoreSimulator.SimDeviceType.iPhone-5&quot;;
2698     }
2699     my $simulatedDevice = iosSimulatorDeviceByName($simulatorName);
2700     return $simulatedDevice if $simulatedDevice;
2701     return createiOSSimulatorDevice($simulatorName, $simulatorDeviceType, iosSimulatorRuntime());
2702 }
2703 
2704 sub isIOSSimulatorSystemInstalledApp($)
2705 {
2706     my ($appBundle) = @_;
2707     my $simulatorApplicationsPath = realpath(iosSimulatorApplicationsPath());
2708     return substr(realpath($appBundle), 0, length($simulatorApplicationsPath)) eq $simulatorApplicationsPath;
2709 }
2710 
2711 sub hasUserInstalledAppInSimulatorDevice($$)
2712 {
2713     my ($appIdentifier, $simulatedDeviceUDID) = @_;
2714     my $userInstalledAppPath = File::Spec-&gt;catfile($ENV{HOME}, &quot;Library&quot;, &quot;Developer&quot;, &quot;CoreSimulator&quot;, &quot;Devices&quot;, $simulatedDeviceUDID, &quot;data&quot;, &quot;Containers&quot;, &quot;Bundle&quot;, &quot;Application&quot;);
2715     if (!-d $userInstalledAppPath) {
2716         return 0; # No user installed apps.
2717     }
2718     local @::userInstalledAppBundles;
2719     my $wantedFunction = sub {
2720         my $file = $_;
2721 
2722         # Ignore hidden files and directories.
2723         if ($file =~ /^\../) {
2724             $File::Find::prune = 1;
2725             return;
2726         }
2727 
2728         return if !-d $file || $file !~ /\.app$/;
2729         push @::userInstalledAppBundles, $File::Find::name;
2730         $File::Find::prune = 1; # Do not traverse contents of app bundle.
2731     };
2732     find($wantedFunction, $userInstalledAppPath);
2733     for my $userInstalledAppBundle (@::userInstalledAppBundles) {
2734         if (appIdentifierFromBundle($userInstalledAppBundle) eq $appIdentifier) {
2735             return 1; # Has user installed app.
2736         }
2737     }
2738     return 0; # Does not have user installed app.
2739 }
2740 
2741 sub isSimulatorDeviceBooted($)
2742 {
2743     my ($simulatedDeviceUDID) = @_;
2744     my $device = iosSimulatorDeviceByUDID($simulatedDeviceUDID);
2745     return $device &amp;&amp; $device-&gt;{state} eq SIMULATOR_DEVICE_STATE_BOOTED;
2746 }
2747 
2748 sub runIOSWebKitAppInSimulator($;$)
2749 {
2750     my ($appBundle, $simulatorOptions) = @_;
2751     my $productDir = productDir();
2752     my $appDisplayName = appDisplayNameFromBundle($appBundle);
2753     my $appIdentifier = appIdentifierFromBundle($appBundle);
2754     my $simulatedDevice = findOrCreateSimulatorForIOSDevice(SIMULATOR_DEVICE_SUFFIX_FOR_WEBKIT_DEVELOPMENT);
2755     my $simulatedDeviceUDID = $simulatedDevice-&gt;{UDID};
2756 
2757     my $willUseSystemInstalledApp = isIOSSimulatorSystemInstalledApp($appBundle);
2758     if ($willUseSystemInstalledApp) {
2759         if (hasUserInstalledAppInSimulatorDevice($appIdentifier, $simulatedDeviceUDID)) {
2760             # Restore the system-installed app in the simulator device corresponding to $appBundle as it
2761             # was previously overwritten with a custom built version of the app.
2762             # FIXME: Only restore the system-installed version of the app instead of erasing all contents and settings.
2763             print &quot;Quitting iOS Simulator...\n&quot;;
2764             quitIOSSimulator($simulatedDeviceUDID);
2765             print &quot;Erasing contents and settings for simulator device \&quot;$simulatedDevice-&gt;{name}\&quot;.\n&quot;;
2766             exitStatus(system(&quot;xcrun&quot;, &quot;--sdk&quot;, &quot;iphonesimulator&quot;, &quot;simctl&quot;, &quot;erase&quot;, $simulatedDeviceUDID)) == 0 or die;
2767         }
2768         # FIXME: We assume that if $simulatedDeviceUDID is not booted then iOS Simulator is not open. However
2769         #        $simulatedDeviceUDID may have been booted using the simctl command line tool. If $simulatedDeviceUDID
2770         #        was booted using simctl then we should shutdown the device and launch iOS Simulator to boot it again.
2771         if (!isSimulatorDeviceBooted($simulatedDeviceUDID)) {
2772             print &quot;Launching iOS Simulator...\n&quot;;
2773             relaunchIOSSimulator($simulatedDevice);
2774         }
2775     } else {
2776         # FIXME: We should killall(1) any running instances of $appBundle before installing it to ensure
2777         #        that simctl launch opens the latest installed version of the app. For now we quit and
2778         #        launch the iOS Simulator again to ensure there are no running instances of $appBundle.
2779         print &quot;Quitting and launching iOS Simulator...\n&quot;;
2780         relaunchIOSSimulator($simulatedDevice);
2781 
2782         print &quot;Installing $appBundle.\n&quot;;
2783         # Install custom built app, overwriting an app with the same app identifier if one exists.
2784         exitStatus(system(&quot;xcrun&quot;, &quot;--sdk&quot;, &quot;iphonesimulator&quot;, &quot;simctl&quot;, &quot;install&quot;, $simulatedDeviceUDID, $appBundle)) == 0 or die;
2785 
2786     }
2787 
2788     $simulatorOptions = {} unless $simulatorOptions;
2789 
2790     my %simulatorENV;
2791     %simulatorENV = %{$simulatorOptions-&gt;{applicationEnvironment}} if $simulatorOptions-&gt;{applicationEnvironment};
2792     {
2793         local %ENV; # Shadow global-scope %ENV so that changes to it will not be seen outside of this scope.
2794         setupIOSWebKitEnvironment($productDir);
2795         %simulatorENV = %ENV;
2796     }
2797     my $applicationArguments = \@ARGV;
2798     $applicationArguments = $simulatorOptions-&gt;{applicationArguments} if $simulatorOptions &amp;&amp; $simulatorOptions-&gt;{applicationArguments};
2799 
2800     # Prefix the environment variables with SIMCTL_CHILD_ per `xcrun simctl help launch`.
2801     foreach my $key (keys %simulatorENV) {
2802         $ENV{&quot;SIMCTL_CHILD_$key&quot;} = $simulatorENV{$key};
2803     }
2804 
2805     print &quot;Starting $appDisplayName with DYLD_FRAMEWORK_PATH set to point to built WebKit in $productDir.\n&quot;;
2806     return exitStatus(system(&quot;xcrun&quot;, &quot;--sdk&quot;, &quot;iphonesimulator&quot;, &quot;simctl&quot;, &quot;launch&quot;, $simulatedDeviceUDID, $appIdentifier, @$applicationArguments));
2807 }
2808 
2809 sub runIOSWebKitApp($)
2810 {
2811     my ($appBundle) = @_;
2812     if (willUseIOSDeviceSDK()) {
2813         die &quot;Only running Safari in iOS Simulator is supported now.&quot;;
2814     }
2815     if (willUseIOSSimulatorSDK()) {
2816         return runIOSWebKitAppInSimulator($appBundle);
2817     }
2818     die &quot;Not using an iOS SDK.&quot;
2819 }
2820 
2821 sub archCommandLineArgumentsForRestrictedEnvironmentVariables()
2822 {
2823     my @arguments = ();
2824     foreach my $key (keys(%ENV)) {
2825         if ($key =~ /^DYLD_/) {
2826             push @arguments, &quot;-e&quot;, &quot;$key=$ENV{$key}&quot;;
2827         }
2828     }
2829     return @arguments;
2830 }
2831 
2832 sub runMacWebKitApp($;$)
2833 {
2834     my ($appPath, $useOpenCommand) = @_;
2835     my $productDir = productDir();
2836     print &quot;Starting @{[basename($appPath)]} with DYLD_FRAMEWORK_PATH set to point to built WebKit in $productDir.\n&quot;;
2837 
2838     local %ENV = %ENV;
2839     setupMacWebKitEnvironment($productDir);
2840 
2841     if (defined($useOpenCommand) &amp;&amp; $useOpenCommand == USE_OPEN_COMMAND) {
2842         return system(&quot;open&quot;, &quot;-W&quot;, &quot;-a&quot;, $appPath, &quot;--args&quot;, argumentsForRunAndDebugMacWebKitApp());
2843     }
2844     if (architecture()) {
2845         return system &quot;arch&quot;, &quot;-&quot; . architecture(), archCommandLineArgumentsForRestrictedEnvironmentVariables(), $appPath, argumentsForRunAndDebugMacWebKitApp();
2846     }
2847     return system { $appPath } $appPath, argumentsForRunAndDebugMacWebKitApp();
2848 }
2849 
2850 sub execMacWebKitAppForDebugging($)
2851 {
2852     my ($appPath) = @_;
2853     my $architectureSwitch = &quot;--arch&quot;;
2854     my $argumentsSeparator = &quot;--&quot;;
2855 
2856     my $debuggerPath = `xcrun -find lldb`;
2857     chomp $debuggerPath;
2858     die &quot;Can&#39;t find the lldb executable.\n&quot; unless -x $debuggerPath;
2859 
2860     my $productDir = productDir();
2861     setupMacWebKitEnvironment($productDir);
2862 
2863     my @architectureFlags = ($architectureSwitch, architecture());
2864     print &quot;Starting @{[basename($appPath)]} under lldb with DYLD_FRAMEWORK_PATH set to point to built WebKit in $productDir.\n&quot;;
2865     exec { $debuggerPath } $debuggerPath, @architectureFlags, $argumentsSeparator, $appPath, argumentsForRunAndDebugMacWebKitApp() or die;
2866 }
2867 
2868 sub debugSafari
2869 {
2870     if (isAppleMacWebKit()) {
2871         checkFrameworks();
2872         execMacWebKitAppForDebugging(safariPath());
2873     }
2874 
2875     return 1; # Unsupported platform; can&#39;t debug Safari on this platform.
2876 }
2877 
2878 sub runSafari
2879 {
2880     if (isIOSWebKit()) {
2881         return runIOSWebKitApp(mobileSafariBundle());
2882     }
2883 
2884     if (isAppleMacWebKit()) {
2885         return runMacWebKitApp(safariPath());
2886     }
2887 
2888     if (isAppleWinWebKit()) {
2889         my $result;
2890         my $webKitLauncherPath = File::Spec-&gt;catfile(executableProductDir(), &quot;MiniBrowser.exe&quot;);
2891         return system { $webKitLauncherPath } $webKitLauncherPath, @ARGV;
2892     }
2893 
2894     return 1; # Unsupported platform; can&#39;t run Safari on this platform.
2895 }
2896 
2897 sub runMiniBrowser
2898 {
2899     if (isAppleMacWebKit()) {
2900         return runMacWebKitApp(File::Spec-&gt;catfile(productDir(), &quot;MiniBrowser.app&quot;, &quot;Contents&quot;, &quot;MacOS&quot;, &quot;MiniBrowser&quot;));
2901     }
2902     if (isAppleWinWebKit()) {
2903         my $webKitLauncherPath = File::Spec-&gt;catfile(executableProductDir(), &quot;MiniBrowser.exe&quot;);
2904         return system { $webKitLauncherPath } $webKitLauncherPath, @ARGV;
2905     }
2906     return 1;
2907 }
2908 
2909 sub debugMiniBrowser
2910 {
2911     if (isAppleMacWebKit()) {
2912         execMacWebKitAppForDebugging(File::Spec-&gt;catfile(productDir(), &quot;MiniBrowser.app&quot;, &quot;Contents&quot;, &quot;MacOS&quot;, &quot;MiniBrowser&quot;));
2913     }
2914     
2915     return 1;
2916 }
2917 
2918 sub runWebKitTestRunner
2919 {
2920     if (isAppleMacWebKit()) {
2921         return runMacWebKitApp(File::Spec-&gt;catfile(productDir(), &quot;WebKitTestRunner&quot;));
2922     }
2923 
2924     return 1;
2925 }
2926 
2927 sub debugWebKitTestRunner
2928 {
2929     if (isAppleMacWebKit()) {
2930         execMacWebKitAppForDebugging(File::Spec-&gt;catfile(productDir(), &quot;WebKitTestRunner&quot;));
2931     }
2932 
2933     return 1;
2934 }
2935 
2936 sub readRegistryString
2937 {
2938     my ($valueName) = @_;
2939     chomp(my $string = `regtool --wow32 get &quot;$valueName&quot;`);
2940     return $string;
2941 }
2942 
2943 sub writeRegistryString
2944 {
2945     my ($valueName, $string) = @_;
2946 
2947     my $error = system &quot;regtool&quot;, &quot;--wow32&quot;, &quot;set&quot;, &quot;-s&quot;, $valueName, $string;
2948 
2949     # On Windows Vista/7 with UAC enabled, regtool will fail to modify the registry, but will still
2950     # return a successful exit code. So we double-check here that the value we tried to write to the
2951     # registry was really written.
2952     return !$error &amp;&amp; readRegistryString($valueName) eq $string;
2953 }
2954 
2955 sub formatBuildTime($)
2956 {
2957     my ($buildTime) = @_;
2958 
2959     my $buildHours = int($buildTime / 3600);
2960     my $buildMins = int(($buildTime - $buildHours * 3600) / 60);
2961     my $buildSecs = $buildTime - $buildHours * 3600 - $buildMins * 60;
2962 
2963     if ($buildHours) {
2964         return sprintf(&quot;%dh:%02dm:%02ds&quot;, $buildHours, $buildMins, $buildSecs);
2965     }
2966     return sprintf(&quot;%02dm:%02ds&quot;, $buildMins, $buildSecs);
2967 }
2968 
2969 sub runSvnUpdateAndResolveChangeLogs(@)
2970 {
2971     my @svnOptions = @_;
2972     my $openCommand = &quot;svn update &quot; . join(&quot; &quot;, @svnOptions);
2973     open my $update, &quot;$openCommand |&quot; or die &quot;cannot execute command $openCommand&quot;;
2974     my @conflictedChangeLogs;
2975     while (my $line = &lt;$update&gt;) {
2976         print $line;
2977         $line =~ m/^C\s+(.+?)[\r\n]*$/;
2978         if ($1) {
2979           my $filename = normalizePath($1);
2980           push @conflictedChangeLogs, $filename if basename($filename) eq &quot;ChangeLog&quot;;
2981         }
2982     }
2983     close $update or die;
2984 
2985     if (@conflictedChangeLogs) {
2986         print &quot;Attempting to merge conflicted ChangeLogs.\n&quot;;
2987         my $resolveChangeLogsPath = File::Spec-&gt;catfile(sourceDir(), &quot;Tools&quot;, &quot;Scripts&quot;, &quot;resolve-ChangeLogs&quot;);
2988         (system($resolveChangeLogsPath, &quot;--no-warnings&quot;, @conflictedChangeLogs) == 0)
2989             or die &quot;Could not open resolve-ChangeLogs script: $!.\n&quot;;
2990     }
2991 }
2992 
2993 sub runGitUpdate()
2994 {
2995     # Doing a git fetch first allows setups with svn-remote.svn.fetch = trunk:refs/remotes/origin/master
2996     # to perform the rebase much much faster.
2997     system(&quot;git&quot;, &quot;fetch&quot;);
2998     if (isGitSVNDirectory(&quot;.&quot;)) {
2999         system(&quot;git&quot;, &quot;svn&quot;, &quot;rebase&quot;) == 0 or die;
3000     } else {
3001         # This will die if branch.$BRANCHNAME.merge isn&#39;t set, which is
3002         # almost certainly what we want.
3003         system(&quot;git&quot;, &quot;pull&quot;) == 0 or die;
3004     }
3005 }
3006 
3007 1;
    </pre>
  </body>
</html>