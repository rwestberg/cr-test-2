diff a/modules/javafx.web/src/main/native/Source/WebCore/Modules/webgpu/WHLSL/WHLSLChecker.cpp b/modules/javafx.web/src/main/native/Source/WebCore/Modules/webgpu/WHLSL/WHLSLChecker.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/Modules/webgpu/WHLSL/WHLSLChecker.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/Modules/webgpu/WHLSL/WHLSLChecker.cpp
@@ -34,19 +34,21 @@
 #include "WHLSLCallExpression.h"
 #include "WHLSLCommaExpression.h"
 #include "WHLSLDereferenceExpression.h"
 #include "WHLSLDoWhileLoop.h"
 #include "WHLSLDotExpression.h"
+#include "WHLSLEntryPointType.h"
 #include "WHLSLForLoop.h"
 #include "WHLSLGatherEntryPointItems.h"
 #include "WHLSLIfStatement.h"
 #include "WHLSLIndexExpression.h"
 #include "WHLSLInferTypes.h"
 #include "WHLSLLogicalExpression.h"
 #include "WHLSLLogicalNotExpression.h"
 #include "WHLSLMakeArrayReferenceExpression.h"
 #include "WHLSLMakePointerExpression.h"
+#include "WHLSLNameContext.h"
 #include "WHLSLPointerType.h"
 #include "WHLSLProgram.h"
 #include "WHLSLReadModifyWriteExpression.h"
 #include "WHLSLResolvableType.h"
 #include "WHLSLResolveOverloadImpl.h"
@@ -80,11 +82,11 @@
     void visit(AST::NativeTypeDeclaration& nativeTypeDeclaration) override
     {
         if (!nativeTypeDeclaration.isNumber()
             && !nativeTypeDeclaration.isVector()
             && !nativeTypeDeclaration.isMatrix())
-            setError();
+            setError(Error("Use of native type is not a POD in entrypoint semantic.", nativeTypeDeclaration.codeLocation()));
     }
 
     void visit(AST::StructureDefinition& structureDefinition) override
     {
         Visitor::visit(structureDefinition);
@@ -98,105 +100,253 @@
     void visit(AST::ArrayType& arrayType) override
     {
         Visitor::visit(arrayType);
     }
 
-    void visit(AST::PointerType&) override
+    void visit(AST::PointerType& pointerType) override
     {
-        setError();
+        setError(Error("Illegal use of pointer in entrypoint semantic.", pointerType.codeLocation()));
     }
 
-    void visit(AST::ArrayReferenceType&) override
+    void visit(AST::ArrayReferenceType& arrayReferenceType) override
     {
-        setError();
+        setError(Error("Illegal use of array reference in entrypoint semantic.", arrayReferenceType.codeLocation()));
     }
 
     void visit(AST::TypeReference& typeReference) override
     {
-        ASSERT(typeReference.resolvedType());
-        checkErrorAndVisit(*typeReference.resolvedType());
+        checkErrorAndVisit(typeReference.resolvedType());
     }
 };
 
-static AST::NativeFunctionDeclaration resolveWithOperatorAnderIndexer(AST::CallExpression& callExpression, AST::ArrayReferenceType& firstArgument, const Intrinsics& intrinsics)
+class FunctionKey {
+public:
+    FunctionKey() = default;
+    FunctionKey(WTF::HashTableDeletedValueType)
+    {
+        m_castReturnType = bitwise_cast<AST::NamedType*>(static_cast<uintptr_t>(1));
+    }
+
+    FunctionKey(String name, Vector<std::reference_wrapper<AST::UnnamedType>> types, AST::NamedType* castReturnType = nullptr)
+        : m_name(WTFMove(name))
+        , m_types(WTFMove(types))
+        , m_castReturnType(castReturnType)
+    { }
+
+    bool isEmptyValue() const { return m_name.isNull(); }
+    bool isHashTableDeletedValue() const { return m_castReturnType == bitwise_cast<AST::NamedType*>(static_cast<uintptr_t>(1)); }
+
+    unsigned hash() const
+    {
+        unsigned hash = IntHash<size_t>::hash(m_types.size());
+        hash ^= m_name.hash();
+        for (size_t i = 0; i < m_types.size(); ++i)
+            hash ^= m_types[i].get().hash() + i;
+
+        if (m_castReturnType)
+            hash ^= WTF::PtrHash<AST::Type*>::hash(&m_castReturnType->unifyNode());
+
+        return hash;
+    }
+
+    bool operator==(const FunctionKey& other) const
+    {
+        if (m_types.size() != other.m_types.size())
+            return false;
+
+        if (m_name != other.m_name)
+            return false;
+
+        for (size_t i = 0; i < m_types.size(); ++i) {
+            if (!matches(m_types[i].get(), other.m_types[i].get()))
+                return false;
+        }
+
+        if (static_cast<bool>(m_castReturnType) != static_cast<bool>(other.m_castReturnType))
+            return false;
+
+        if (!m_castReturnType)
+            return true;
+
+        if (&m_castReturnType->unifyNode() == &other.m_castReturnType->unifyNode())
+            return true;
+
+        return false;
+    }
+
+    struct Hash {
+        static unsigned hash(const FunctionKey& key)
+        {
+            return key.hash();
+        }
+
+        static bool equal(const FunctionKey& a, const FunctionKey& b)
+        {
+            return a == b;
+        }
+
+        static const bool safeToCompareToEmptyOrDeleted = false;
+        static const bool emptyValueIsZero = false;
+    };
+
+    struct Traits : public WTF::SimpleClassHashTraits<FunctionKey> {
+        static const bool hasIsEmptyValueFunction = true;
+        static bool isEmptyValue(const FunctionKey& key) { return key.isEmptyValue(); }
+    };
+
+private:
+    String m_name;
+    Vector<std::reference_wrapper<AST::UnnamedType>> m_types;
+    AST::NamedType* m_castReturnType;
+};
+
+class AndOverloadTypeKey {
+public:
+    AndOverloadTypeKey() = default;
+    AndOverloadTypeKey(WTF::HashTableDeletedValueType)
+    {
+        m_type = bitwise_cast<AST::UnnamedType*>(static_cast<uintptr_t>(1));
+    }
+
+    AndOverloadTypeKey(AST::UnnamedType& type, AST::AddressSpace addressSpace)
+        : m_type(&type)
+        , m_addressSpace(addressSpace)
+    { }
+
+    bool isEmptyValue() const { return !m_type; }
+    bool isHashTableDeletedValue() const { return m_type == bitwise_cast<AST::UnnamedType*>(static_cast<uintptr_t>(1)); }
+
+    unsigned hash() const
+    {
+        return IntHash<uint8_t>::hash(static_cast<uint8_t>(m_addressSpace)) ^ m_type->hash();
+    }
+
+    bool operator==(const AndOverloadTypeKey& other) const
+    {
+        return m_addressSpace == other.m_addressSpace
+            && *m_type == *other.m_type;
+    }
+
+    struct Hash {
+        static unsigned hash(const AndOverloadTypeKey& key)
+        {
+            return key.hash();
+        }
+
+        static bool equal(const AndOverloadTypeKey& a, const AndOverloadTypeKey& b)
+        {
+            return a == b;
+        }
+
+        static const bool safeToCompareToEmptyOrDeleted = false;
+    };
+
+    struct Traits : public WTF::SimpleClassHashTraits<AndOverloadTypeKey> {
+        static const bool hasIsEmptyValueFunction = true;
+        static bool isEmptyValue(const AndOverloadTypeKey& key) { return key.isEmptyValue(); }
+    };
+
+private:
+    AST::UnnamedType* m_type { nullptr };
+    AST::AddressSpace m_addressSpace;
+};
+
+static AST::NativeFunctionDeclaration resolveWithOperatorAnderIndexer(CodeLocation location, AST::ArrayReferenceType& firstArgument, const Intrinsics& intrinsics)
 {
     const bool isOperator = true;
-    auto returnType = makeUniqueRef<AST::PointerType>(Lexer::Token(callExpression.origin()), firstArgument.addressSpace(), firstArgument.elementType().clone());
+    auto returnType = AST::PointerType::create(location, firstArgument.addressSpace(), firstArgument.elementType());
     AST::VariableDeclarations parameters;
-    parameters.append(AST::VariableDeclaration(Lexer::Token(callExpression.origin()), AST::Qualifiers(), { firstArgument.clone() }, String(), WTF::nullopt, WTF::nullopt));
-    parameters.append(AST::VariableDeclaration(Lexer::Token(callExpression.origin()), AST::Qualifiers(), { AST::TypeReference::wrap(Lexer::Token(callExpression.origin()), intrinsics.uintType()) }, String(), WTF::nullopt, WTF::nullopt));
-    return AST::NativeFunctionDeclaration(AST::FunctionDeclaration(Lexer::Token(callExpression.origin()), AST::AttributeBlock(), WTF::nullopt, WTFMove(returnType), String("operator&[]", String::ConstructFromLiteral), WTFMove(parameters), WTF::nullopt, isOperator));
+    parameters.append(makeUniqueRef<AST::VariableDeclaration>(location, AST::Qualifiers(), &firstArgument, String(), nullptr, nullptr));
+    parameters.append(makeUniqueRef<AST::VariableDeclaration>(location, AST::Qualifiers(), AST::TypeReference::wrap(location, intrinsics.uintType()), String(), nullptr, nullptr));
+    return AST::NativeFunctionDeclaration(AST::FunctionDeclaration(location, AST::AttributeBlock(), WTF::nullopt, WTFMove(returnType), String("operator&[]", String::ConstructFromLiteral), WTFMove(parameters), nullptr, isOperator, ParsingMode::StandardLibrary));
 }
 
-static AST::NativeFunctionDeclaration resolveWithOperatorLength(AST::CallExpression& callExpression, AST::UnnamedType& firstArgument, const Intrinsics& intrinsics)
+static AST::NativeFunctionDeclaration resolveWithOperatorLength(CodeLocation location, AST::UnnamedType& firstArgument, const Intrinsics& intrinsics)
 {
     const bool isOperator = true;
-    auto returnType = AST::TypeReference::wrap(Lexer::Token(callExpression.origin()), intrinsics.uintType());
+    auto returnType = AST::TypeReference::wrap(location, intrinsics.uintType());
     AST::VariableDeclarations parameters;
-    parameters.append(AST::VariableDeclaration(Lexer::Token(callExpression.origin()), AST::Qualifiers(), { firstArgument.clone() }, String(), WTF::nullopt, WTF::nullopt));
-    return AST::NativeFunctionDeclaration(AST::FunctionDeclaration(Lexer::Token(callExpression.origin()), AST::AttributeBlock(), WTF::nullopt, WTFMove(returnType), String("operator.length", String::ConstructFromLiteral), WTFMove(parameters), WTF::nullopt, isOperator));
+    parameters.append(makeUniqueRef<AST::VariableDeclaration>(location, AST::Qualifiers(), &firstArgument, String(), nullptr, nullptr));
+    return AST::NativeFunctionDeclaration(AST::FunctionDeclaration(location, AST::AttributeBlock(), WTF::nullopt, WTFMove(returnType), String("operator.length", String::ConstructFromLiteral), WTFMove(parameters), nullptr, isOperator, ParsingMode::StandardLibrary));
 }
 
-static AST::NativeFunctionDeclaration resolveWithReferenceComparator(AST::CallExpression& callExpression, ResolvingType& firstArgument, ResolvingType& secondArgument, const Intrinsics& intrinsics)
+static AST::NativeFunctionDeclaration resolveWithReferenceComparator(CodeLocation location, ResolvingType& firstArgument, ResolvingType& secondArgument, const Intrinsics& intrinsics)
 {
     const bool isOperator = true;
-    auto returnType = AST::TypeReference::wrap(Lexer::Token(callExpression.origin()), intrinsics.boolType());
-    auto argumentType = WTF::visit(WTF::makeVisitor([](UniqueRef<AST::UnnamedType>& unnamedType) -> UniqueRef<AST::UnnamedType> {
-        return unnamedType->clone();
-    }, [&](Ref<ResolvableTypeReference>&) -> UniqueRef<AST::UnnamedType> {
-        return WTF::visit(WTF::makeVisitor([](UniqueRef<AST::UnnamedType>& unnamedType) -> UniqueRef<AST::UnnamedType> {
-            return unnamedType->clone();
-        }, [&](Ref<ResolvableTypeReference>&) -> UniqueRef<AST::UnnamedType> {
+    auto returnType = AST::TypeReference::wrap(location, intrinsics.boolType());
+    auto argumentType = firstArgument.visit(WTF::makeVisitor([](Ref<AST::UnnamedType>& unnamedType) -> Ref<AST::UnnamedType> {
+        return unnamedType.copyRef();
+    }, [&](RefPtr<ResolvableTypeReference>&) -> Ref<AST::UnnamedType> {
+        return secondArgument.visit(WTF::makeVisitor([](Ref<AST::UnnamedType>& unnamedType) -> Ref<AST::UnnamedType> {
+            return unnamedType.copyRef();
+        }, [&](RefPtr<ResolvableTypeReference>&) -> Ref<AST::UnnamedType> {
             // We encountered "null == null".
-            // The type isn't observable, so we can pick whatever we want.
-            // FIXME: This can probably be generalized, using the "preferred type" infrastructure used by generic literals
-            return AST::TypeReference::wrap(Lexer::Token(callExpression.origin()), intrinsics.intType());
-        }), secondArgument);
-    }), firstArgument);
+            // FIXME: https://bugs.webkit.org/show_bug.cgi?id=198162 This can probably be generalized, using the "preferred type" infrastructure used by generic literals
+            ASSERT_NOT_REACHED();
+            return AST::TypeReference::wrap(location, intrinsics.intType());
+        }));
+    }));
     AST::VariableDeclarations parameters;
-    parameters.append(AST::VariableDeclaration(Lexer::Token(callExpression.origin()), AST::Qualifiers(), { argumentType->clone() }, String(), WTF::nullopt, WTF::nullopt));
-    parameters.append(AST::VariableDeclaration(Lexer::Token(callExpression.origin()), AST::Qualifiers(), { WTFMove(argumentType) }, String(), WTF::nullopt, WTF::nullopt));
-    return AST::NativeFunctionDeclaration(AST::FunctionDeclaration(Lexer::Token(callExpression.origin()), AST::AttributeBlock(), WTF::nullopt, WTFMove(returnType), String("operator==", String::ConstructFromLiteral), WTFMove(parameters), WTF::nullopt, isOperator));
+    parameters.append(makeUniqueRef<AST::VariableDeclaration>(location, AST::Qualifiers(), argumentType.copyRef(), String(), nullptr, nullptr));
+    parameters.append(makeUniqueRef<AST::VariableDeclaration>(location, AST::Qualifiers(), WTFMove(argumentType), String(), nullptr, nullptr));
+    return AST::NativeFunctionDeclaration(AST::FunctionDeclaration(location, AST::AttributeBlock(), WTF::nullopt, WTFMove(returnType), String("operator==", String::ConstructFromLiteral), WTFMove(parameters), nullptr, isOperator, ParsingMode::StandardLibrary));
 }
 
-static Optional<AST::NativeFunctionDeclaration> resolveByInstantiation(AST::CallExpression& callExpression, const Vector<std::reference_wrapper<ResolvingType>>& types, const Intrinsics& intrinsics)
+enum class Acceptability {
+    Yes,
+    Maybe,
+    No
+};
+
+static Optional<AST::NativeFunctionDeclaration> resolveByInstantiation(const String& name, CodeLocation location, const Vector<std::reference_wrapper<ResolvingType>>& types, const Intrinsics& intrinsics)
 {
-    if (callExpression.name() == "operator&[]" && types.size() == 2) {
-        auto* firstArgumentArrayRef = WTF::visit(WTF::makeVisitor([](UniqueRef<AST::UnnamedType>& unnamedType) -> AST::ArrayReferenceType* {
+    if (name == "operator&[]" && types.size() == 2) {
+        auto* firstArgumentArrayRef = types[0].get().visit(WTF::makeVisitor([](Ref<AST::UnnamedType>& unnamedType) -> AST::ArrayReferenceType* {
             if (is<AST::ArrayReferenceType>(static_cast<AST::UnnamedType&>(unnamedType)))
                 return &downcast<AST::ArrayReferenceType>(static_cast<AST::UnnamedType&>(unnamedType));
             return nullptr;
-        }, [](Ref<ResolvableTypeReference>&) -> AST::ArrayReferenceType* {
+        }, [](RefPtr<ResolvableTypeReference>&) -> AST::ArrayReferenceType* {
             return nullptr;
-        }), types[0].get());
-        bool secondArgumentIsUint = WTF::visit(WTF::makeVisitor([&](UniqueRef<AST::UnnamedType>& unnamedType) -> bool {
+        }));
+        bool secondArgumentIsUint = types[1].get().visit(WTF::makeVisitor([&](Ref<AST::UnnamedType>& unnamedType) -> bool {
             return matches(unnamedType, intrinsics.uintType());
-        }, [&](Ref<ResolvableTypeReference>& resolvableTypeReference) -> bool {
+        }, [&](RefPtr<ResolvableTypeReference>& resolvableTypeReference) -> bool {
             return resolvableTypeReference->resolvableType().canResolve(intrinsics.uintType());
-        }), types[1].get());
+        }));
         if (firstArgumentArrayRef && secondArgumentIsUint)
-            return resolveWithOperatorAnderIndexer(callExpression, *firstArgumentArrayRef, intrinsics);
-    } else if (callExpression.name() == "operator.length" && types.size() == 1) {
-        auto* firstArgumentReference = WTF::visit(WTF::makeVisitor([](UniqueRef<AST::UnnamedType>& unnamedType) -> AST::UnnamedType* {
+            return resolveWithOperatorAnderIndexer(location, *firstArgumentArrayRef, intrinsics);
+    } else if (name == "operator.length" && types.size() == 1) {
+        auto* firstArgumentReference = types[0].get().visit(WTF::makeVisitor([](Ref<AST::UnnamedType>& unnamedType) -> AST::UnnamedType* {
             if (is<AST::ArrayReferenceType>(static_cast<AST::UnnamedType&>(unnamedType)) || is<AST::ArrayType>(static_cast<AST::UnnamedType&>(unnamedType)))
-                return &unnamedType;
+                return unnamedType.ptr();
             return nullptr;
-        }, [](Ref<ResolvableTypeReference>&) -> AST::UnnamedType* {
+        }, [](RefPtr<ResolvableTypeReference>&) -> AST::UnnamedType* {
             return nullptr;
-        }), types[0].get());
+        }));
         if (firstArgumentReference)
-            return resolveWithOperatorLength(callExpression, *firstArgumentReference, intrinsics);
-    } else if (callExpression.name() == "operator==" && types.size() == 2) {
-        auto isAcceptable = [](ResolvingType& resolvingType) -> bool {
-            return WTF::visit(WTF::makeVisitor([](UniqueRef<AST::UnnamedType>& unnamedType) -> bool {
-                return is<AST::ReferenceType>(static_cast<AST::UnnamedType&>(unnamedType));
-            }, [](Ref<ResolvableTypeReference>& resolvableTypeReference) -> bool {
-                return is<AST::NullLiteralType>(resolvableTypeReference->resolvableType());
-            }), resolvingType);
+            return resolveWithOperatorLength(location, *firstArgumentReference, intrinsics);
+    } else if (name == "operator==" && types.size() == 2) {
+        auto acceptability = [](ResolvingType& resolvingType) -> Acceptability {
+            return resolvingType.visit(WTF::makeVisitor([](Ref<AST::UnnamedType>& unnamedType) -> Acceptability {
+                auto& unifyNode = unnamedType->unifyNode();
+                return is<AST::UnnamedType>(unifyNode) && is<AST::ReferenceType>(downcast<AST::UnnamedType>(unifyNode)) ? Acceptability::Yes : Acceptability::No;
+            }, [](RefPtr<ResolvableTypeReference>& resolvableTypeReference) -> Acceptability {
+                return is<AST::NullLiteralType>(resolvableTypeReference->resolvableType()) ? Acceptability::Maybe : Acceptability::No;
+            }));
         };
-        if (isAcceptable(types[0].get()) && isAcceptable(types[1].get()))
-            return resolveWithReferenceComparator(callExpression, types[0].get(), types[1].get(), intrinsics);
+        auto leftAcceptability = acceptability(types[0].get());
+        auto rightAcceptability = acceptability(types[1].get());
+        bool success = false;
+        if (leftAcceptability == Acceptability::Yes && rightAcceptability == Acceptability::Yes) {
+            auto& unnamedType1 = *types[0].get().getUnnamedType();
+            auto& unnamedType2 = *types[1].get().getUnnamedType();
+            success = matches(unnamedType1, unnamedType2);
+        } else if ((leftAcceptability == Acceptability::Maybe && rightAcceptability == Acceptability::Yes)
+            || (leftAcceptability == Acceptability::Yes && rightAcceptability == Acceptability::Maybe))
+            success = true;
+        if (success)
+            return resolveWithReferenceComparator(location, types[0].get(), types[1].get(), intrinsics);
     }
     return WTF::nullopt;
 }
 
 static bool checkSemantics(Vector<EntryPointItem>& inputItems, Vector<EntryPointItem>& outputItems, const Optional<AST::EntryPointType>& entryPointType, const Intrinsics& intrinsics)
@@ -261,11 +411,11 @@
                     podChecker.checkErrorAndVisit(downcast<AST::ArrayReferenceType>(*item.unnamedType).elementType());
                 else if (is<AST::ArrayType>(item.unnamedType))
                     podChecker.checkErrorAndVisit(downcast<AST::ArrayType>(*item.unnamedType).type());
                 else
                     continue;
-                if (podChecker.error())
+                if (podChecker.hasError())
                     return false;
             }
             return true;
         };
         if (!checkPODData(inputItems))
@@ -275,29 +425,29 @@
     }
 
     return true;
 }
 
-static bool checkOperatorOverload(const AST::FunctionDefinition& functionDefinition, const Intrinsics& intrinsics, NameContext& nameContext)
+static bool checkOperatorOverload(const AST::FunctionDefinition& functionDefinition, NameContext& nameContext, AST::NameSpace currentNameSpace)
 {
     enum class CheckKind {
         Index,
         Dot
     };
 
     auto checkGetter = [&](CheckKind kind) -> bool {
         size_t numExpectedParameters = kind == CheckKind::Index ? 2 : 1;
         if (functionDefinition.parameters().size() != numExpectedParameters)
             return false;
-        auto& firstParameterUnifyNode = (*functionDefinition.parameters()[0].type())->unifyNode();
+        auto& firstParameterUnifyNode = functionDefinition.parameters()[0]->type()->unifyNode();
         if (is<AST::UnnamedType>(firstParameterUnifyNode)) {
             auto& unnamedType = downcast<AST::UnnamedType>(firstParameterUnifyNode);
             if (is<AST::PointerType>(unnamedType) || is<AST::ArrayReferenceType>(unnamedType) || is<AST::ArrayType>(unnamedType))
                 return false;
         }
         if (kind == CheckKind::Index) {
-            auto& secondParameterUnifyNode = (*functionDefinition.parameters()[1].type())->unifyNode();
+            auto& secondParameterUnifyNode = functionDefinition.parameters()[1]->type()->unifyNode();
             if (!is<AST::NamedType>(secondParameterUnifyNode))
                 return false;
             auto& namedType = downcast<AST::NamedType>(secondParameterUnifyNode);
             if (!is<AST::NativeTypeDeclaration>(namedType))
                 return false;
@@ -310,42 +460,39 @@
 
     auto checkSetter = [&](CheckKind kind) -> bool {
         size_t numExpectedParameters = kind == CheckKind::Index ? 3 : 2;
         if (functionDefinition.parameters().size() != numExpectedParameters)
             return false;
-        auto& firstArgumentUnifyNode = (*functionDefinition.parameters()[0].type())->unifyNode();
+        auto& firstArgumentUnifyNode = functionDefinition.parameters()[0]->type()->unifyNode();
         if (is<AST::UnnamedType>(firstArgumentUnifyNode)) {
             auto& unnamedType = downcast<AST::UnnamedType>(firstArgumentUnifyNode);
             if (is<AST::PointerType>(unnamedType) || is<AST::ArrayReferenceType>(unnamedType) || is<AST::ArrayType>(unnamedType))
                 return false;
         }
         if (kind == CheckKind::Index) {
-            auto& secondParameterUnifyNode = (*functionDefinition.parameters()[1].type())->unifyNode();
+            auto& secondParameterUnifyNode = functionDefinition.parameters()[1]->type()->unifyNode();
             if (!is<AST::NamedType>(secondParameterUnifyNode))
                 return false;
             auto& namedType = downcast<AST::NamedType>(secondParameterUnifyNode);
             if (!is<AST::NativeTypeDeclaration>(namedType))
                 return false;
             auto& nativeTypeDeclaration = downcast<AST::NativeTypeDeclaration>(namedType);
             if (!nativeTypeDeclaration.isInt())
                 return false;
         }
-        if (!matches(functionDefinition.type(), *functionDefinition.parameters()[0].type()))
+        if (!matches(functionDefinition.type(), *functionDefinition.parameters()[0]->type()))
             return false;
-        auto& valueType = *functionDefinition.parameters()[numExpectedParameters - 1].type();
+        auto& valueType = *functionDefinition.parameters()[numExpectedParameters - 1]->type();
         auto getterName = functionDefinition.name().substring(0, functionDefinition.name().length() - 1);
-        auto* getterFuncs = nameContext.getFunctions(getterName);
-        if (!getterFuncs)
-            return false;
+        auto getterFuncs = nameContext.getFunctions(getterName, currentNameSpace);
         Vector<ResolvingType> argumentTypes;
         Vector<std::reference_wrapper<ResolvingType>> argumentTypeReferences;
         for (size_t i = 0; i < numExpectedParameters - 1; ++i)
-            argumentTypes.append((*functionDefinition.parameters()[0].type())->clone());
+            argumentTypes.append(*functionDefinition.parameters()[i]->type());
         for (auto& argumentType : argumentTypes)
             argumentTypeReferences.append(argumentType);
-        Optional<std::reference_wrapper<AST::NamedType>> castReturnType;
-        auto* overload = resolveFunctionOverloadImpl(*getterFuncs, argumentTypeReferences, castReturnType);
+        auto* overload = resolveFunctionOverload(getterFuncs, argumentTypeReferences, currentNameSpace);
         if (!overload)
             return false;
         auto& resultType = overload->type();
         return matches(resultType, valueType);
     };
@@ -361,11 +508,11 @@
             auto& unnamedType = downcast<AST::UnnamedType>(unifyNode);
             if (!is<AST::PointerType>(unnamedType))
                 return false;
         }
         {
-            auto& unifyNode = (*functionDefinition.parameters()[0].type())->unifyNode();
+            auto& unifyNode = functionDefinition.parameters()[0]->type()->unifyNode();
             if (!is<AST::UnnamedType>(unifyNode))
                 return false;
             auto& unnamedType = downcast<AST::UnnamedType>(unifyNode);
             return is<AST::PointerType>(unnamedType) || is<AST::ArrayReferenceType>(unnamedType);
         }
@@ -375,33 +522,25 @@
         return true;
     if (functionDefinition.isCast())
         return true;
     if (functionDefinition.name() == "operator++" || functionDefinition.name() == "operator--") {
         return functionDefinition.parameters().size() == 1
-            && matches(*functionDefinition.parameters()[0].type(), functionDefinition.type());
+            && matches(*functionDefinition.parameters()[0]->type(), functionDefinition.type());
     }
     if (functionDefinition.name() == "operator+" || functionDefinition.name() == "operator-")
         return functionDefinition.parameters().size() == 1 || functionDefinition.parameters().size() == 2;
     if (functionDefinition.name() == "operator*"
         || functionDefinition.name() == "operator/"
         || functionDefinition.name() == "operator%"
         || functionDefinition.name() == "operator&"
         || functionDefinition.name() == "operator|"
         || functionDefinition.name() == "operator^"
         || functionDefinition.name() == "operator<<"
-        || functionDefinition.name() == "opreator>>")
+        || functionDefinition.name() == "operator>>")
         return functionDefinition.parameters().size() == 2;
     if (functionDefinition.name() == "operator~")
         return functionDefinition.parameters().size() == 1;
-    if (functionDefinition.name() == "operator=="
-        || functionDefinition.name() == "operator<"
-        || functionDefinition.name() == "operator<="
-        || functionDefinition.name() == "operator>"
-        || functionDefinition.name() == "operator>=") {
-        return functionDefinition.parameters().size() == 2
-            && matches(functionDefinition.type(), intrinsics.boolType());
-    }
     if (functionDefinition.name() == "operator[]")
         return checkGetter(CheckKind::Index);
     if (functionDefinition.name() == "operator[]=")
         return checkSetter(CheckKind::Index);
     if (functionDefinition.name() == "operator&[]")
@@ -420,33 +559,51 @@
 public:
     Checker(const Intrinsics& intrinsics, Program& program)
         : m_intrinsics(intrinsics)
         , m_program(program)
     {
+        auto addFunction = [&] (AST::FunctionDeclaration& function) {
+            AST::NamedType* castReturnType = nullptr;
+            if (function.isCast() && is<AST::NamedType>(function.type().unifyNode()))
+                castReturnType = &downcast<AST::NamedType>(function.type().unifyNode());
+
+            Vector<std::reference_wrapper<AST::UnnamedType>> types;
+            types.reserveInitialCapacity(function.parameters().size());
+
+            for (auto& param : function.parameters())
+                types.uncheckedAppend(normalizedTypeForFunctionKey(*param->type()));
+
+            auto addResult = m_functions.add(FunctionKey { function.name(), WTFMove(types), castReturnType }, Vector<std::reference_wrapper<AST::FunctionDeclaration>, 1>());
+            addResult.iterator->value.append(function);
+        };
+
+        for (auto& function : m_program.functionDefinitions())
+            addFunction(function.get());
+        for (auto& function : m_program.nativeFunctionDeclarations())
+            addFunction(function.get());
     }
 
-    ~Checker() = default;
+    virtual ~Checker() = default;
 
     void visit(Program&) override;
 
-    bool assignTypes();
+    Expected<void, Error> assignTypes();
 
 private:
     bool checkShaderType(const AST::FunctionDefinition&);
-    void finishVisitingPropertyAccess(AST::PropertyAccessExpression&, AST::UnnamedType& wrappedBaseType, AST::UnnamedType* extraArgumentType = nullptr);
     bool isBoolType(ResolvingType&);
     struct RecurseInfo {
         ResolvingType& resolvingType;
-        Optional<AST::AddressSpace>& addressSpace;
+        const AST::TypeAnnotation typeAnnotation;
     };
-    Optional<RecurseInfo> recurseAndGetInfo(AST::Expression&, bool requiresLValue = false);
-    Optional<RecurseInfo> getInfo(AST::Expression&, bool requiresLValue = false);
-    Optional<UniqueRef<AST::UnnamedType>> recurseAndWrapBaseType(AST::PropertyAccessExpression&);
+    Optional<RecurseInfo> recurseAndGetInfo(AST::Expression&, bool requiresLeftValue = false);
+    Optional<RecurseInfo> getInfo(AST::Expression&, bool requiresLeftValue = false);
+    RefPtr<AST::UnnamedType> recurseAndWrapBaseType(AST::PropertyAccessExpression&);
     bool recurseAndRequireBoolType(AST::Expression&);
-    void assignType(AST::Expression&, UniqueRef<AST::UnnamedType>&&, Optional<AST::AddressSpace> = WTF::nullopt);
-    void assignType(AST::Expression&, Ref<ResolvableTypeReference>&&, Optional<AST::AddressSpace> = WTF::nullopt);
-    void forwardType(AST::Expression&, ResolvingType&, Optional<AST::AddressSpace> = WTF::nullopt);
+    void assignConcreteType(AST::Expression&, Ref<AST::UnnamedType>, AST::TypeAnnotation);
+    void assignType(AST::Expression&, RefPtr<ResolvableTypeReference>, AST::TypeAnnotation);
+    void forwardType(AST::Expression&, ResolvingType&, AST::TypeAnnotation);
 
     void visit(AST::FunctionDefinition&) override;
     void visit(AST::EnumerationDefinition&) override;
     void visit(AST::TypeReference&) override;
     void visit(AST::VariableDeclaration&) override;
@@ -476,17 +633,54 @@
     void visit(AST::SwitchStatement&) override;
     void visit(AST::CommaExpression&) override;
     void visit(AST::TernaryExpression&) override;
     void visit(AST::CallExpression&) override;
 
-    HashMap<AST::Expression*, ResolvingType> m_typeMap;
-    HashMap<AST::Expression*, Optional<AST::AddressSpace>> m_addressSpaceMap;
-    HashSet<String> m_vertexEntryPoints;
-    HashSet<String> m_fragmentEntryPoints;
-    HashSet<String> m_computeEntryPoints;
+    void finishVisiting(AST::PropertyAccessExpression&, ResolvingType* additionalArgumentType = nullptr);
+
+    AST::FunctionDeclaration* resolveFunction(Vector<std::reference_wrapper<ResolvingType>>& types, const String& name, CodeLocation, AST::NamedType* castReturnType = nullptr);
+
+    RefPtr<AST::UnnamedType> argumentTypeForAndOverload(AST::UnnamedType& baseType, AST::AddressSpace);
+
+    AST::UnnamedType& wrappedFloatType()
+    {
+        if (!m_wrappedFloatType)
+            m_wrappedFloatType = AST::TypeReference::wrap({ }, m_intrinsics.floatType());
+        return *m_wrappedFloatType;
+    }
+
+    AST::UnnamedType& genericPointerType()
+    {
+        if (!m_genericPointerType)
+            m_genericPointerType = AST::PointerType::create({ }, AST::AddressSpace::Thread, AST::TypeReference::wrap({ }, m_intrinsics.floatType()));
+        return *m_genericPointerType;
+    }
+
+    AST::UnnamedType& normalizedTypeForFunctionKey(AST::UnnamedType& type)
+    {
+        auto* unifyNode = &type.unifyNode();
+        if (unifyNode == &m_intrinsics.uintType() || unifyNode == &m_intrinsics.intType())
+            return wrappedFloatType();
+
+        if (is<AST::ReferenceType>(type))
+            return genericPointerType();
+
+        return type;
+    }
+
+    RefPtr<AST::TypeReference> m_wrappedFloatType;
+    RefPtr<AST::UnnamedType> m_genericPointerType;
+    HashMap<AST::Expression*, std::unique_ptr<ResolvingType>> m_typeMap;
+    HashSet<String> m_vertexEntryPoints[AST::nameSpaceCount];
+    HashSet<String> m_fragmentEntryPoints[AST::nameSpaceCount];
+    HashSet<String> m_computeEntryPoints[AST::nameSpaceCount];
     const Intrinsics& m_intrinsics;
     Program& m_program;
+    AST::FunctionDefinition* m_currentFunction { nullptr };
+    HashMap<FunctionKey, Vector<std::reference_wrapper<AST::FunctionDeclaration>, 1>, FunctionKey::Hash, FunctionKey::Traits> m_functions;
+    HashMap<AndOverloadTypeKey, RefPtr<AST::UnnamedType>, AndOverloadTypeKey::Hash, AndOverloadTypeKey::Traits> m_andOverloadTypeMap;
+    AST::NameSpace m_currentNameSpace { AST::NameSpace::StandardLibrary };
 };
 
 void Checker::visit(Program& program)
 {
     // These visiting functions might add new global statements, so don't use foreach syntax.
@@ -503,114 +697,162 @@
         checkErrorAndVisit(program.functionDefinitions()[i]);
     for (size_t i = 0; i < program.nativeFunctionDeclarations().size(); ++i)
         checkErrorAndVisit(program.nativeFunctionDeclarations()[i]);
 }
 
-bool Checker::assignTypes()
+Expected<void, Error> Checker::assignTypes()
 {
     for (auto& keyValuePair : m_typeMap) {
-        auto success = WTF::visit(WTF::makeVisitor([&](UniqueRef<AST::UnnamedType>& unnamedType) -> bool {
-            keyValuePair.key->setType(unnamedType->clone());
+        auto success = keyValuePair.value->visit(WTF::makeVisitor([&](Ref<AST::UnnamedType>& unnamedType) -> bool {
+            keyValuePair.key->setType(unnamedType.copyRef());
             return true;
-        }, [&](Ref<ResolvableTypeReference>& resolvableTypeReference) -> bool {
-            if (!resolvableTypeReference->resolvableType().resolvedType()) {
-                // FIXME: Instead of trying to commit, it might be better to just return an error instead.
+        }, [&](RefPtr<ResolvableTypeReference>& resolvableTypeReference) -> bool {
+            if (!resolvableTypeReference->resolvableType().maybeResolvedType()) {
                 if (!static_cast<bool>(commit(resolvableTypeReference->resolvableType())))
                     return false;
             }
-            keyValuePair.key->setType(resolvableTypeReference->resolvableType().resolvedType()->clone());
+            keyValuePair.key->setType(resolvableTypeReference->resolvableType().resolvedType());
             return true;
-        }), keyValuePair.value);
+        }));
         if (!success)
-            return false;
+            return makeUnexpected(Error("Could not resolve the type of a constant."));
     }
 
-    for (auto& keyValuePair : m_addressSpaceMap)
-        keyValuePair.key->setAddressSpace(keyValuePair.value);
-    return true;
+    return { };
 }
 
 bool Checker::checkShaderType(const AST::FunctionDefinition& functionDefinition)
 {
+    auto index = static_cast<unsigned>(m_currentNameSpace);
     switch (*functionDefinition.entryPointType()) {
     case AST::EntryPointType::Vertex:
-        return !m_vertexEntryPoints.add(functionDefinition.name()).isNewEntry;
+        return static_cast<bool>(m_vertexEntryPoints[index].add(functionDefinition.name()));
     case AST::EntryPointType::Fragment:
-        return !m_fragmentEntryPoints.add(functionDefinition.name()).isNewEntry;
+        return static_cast<bool>(m_fragmentEntryPoints[index].add(functionDefinition.name()));
     case AST::EntryPointType::Compute:
-        return !m_computeEntryPoints.add(functionDefinition.name()).isNewEntry;
+        return static_cast<bool>(m_computeEntryPoints[index].add(functionDefinition.name()));
     }
 }
 
 void Checker::visit(AST::FunctionDefinition& functionDefinition)
 {
+    m_currentNameSpace = functionDefinition.nameSpace();
+    m_currentFunction = &functionDefinition;
     if (functionDefinition.entryPointType()) {
         if (!checkShaderType(functionDefinition)) {
-            setError();
+            setError(Error("Duplicate entrypoint function.", functionDefinition.codeLocation()));
             return;
         }
         auto entryPointItems = gatherEntryPointItems(m_intrinsics, functionDefinition);
         if (!entryPointItems) {
-            setError();
+            setError(entryPointItems.error());
             return;
         }
         if (!checkSemantics(entryPointItems->inputs, entryPointItems->outputs, functionDefinition.entryPointType(), m_intrinsics)) {
-            setError();
+            setError(Error("Bad semantics for entrypoint.", functionDefinition.codeLocation()));
             return;
         }
     }
-    if (!checkOperatorOverload(functionDefinition, m_intrinsics, m_program.nameContext())) {
-        setError();
+    if (!checkOperatorOverload(functionDefinition, m_program.nameContext(), m_currentNameSpace)) {
+        setError(Error("Operator does not match expected signature.", functionDefinition.codeLocation()));
         return;
     }
 
-    checkErrorAndVisit(functionDefinition);
+    Visitor::visit(functionDefinition);
 }
 
-static Optional<UniqueRef<AST::UnnamedType>> matchAndCommit(ResolvingType& left, ResolvingType& right)
+static RefPtr<AST::UnnamedType> matchAndCommit(ResolvingType& left, ResolvingType& right)
 {
-    return WTF::visit(WTF::makeVisitor([&](UniqueRef<AST::UnnamedType>& left) -> Optional<UniqueRef<AST::UnnamedType>> {
-        return WTF::visit(WTF::makeVisitor([&](UniqueRef<AST::UnnamedType>& right) -> Optional<UniqueRef<AST::UnnamedType>> {
+    return left.visit(WTF::makeVisitor([&](Ref<AST::UnnamedType>& left) -> RefPtr<AST::UnnamedType> {
+        return right.visit(WTF::makeVisitor([&](Ref<AST::UnnamedType>& right) -> RefPtr<AST::UnnamedType> {
             if (matches(left, right))
-                return left->clone();
-            return WTF::nullopt;
-        }, [&](Ref<ResolvableTypeReference>& right) -> Optional<UniqueRef<AST::UnnamedType>> {
+                return left.copyRef();
+            return nullptr;
+        }, [&](RefPtr<ResolvableTypeReference>& right) -> RefPtr<AST::UnnamedType> {
             return matchAndCommit(left, right->resolvableType());
-        }), right);
-    }, [&](Ref<ResolvableTypeReference>& left) -> Optional<UniqueRef<AST::UnnamedType>> {
-        return WTF::visit(WTF::makeVisitor([&](UniqueRef<AST::UnnamedType>& right) -> Optional<UniqueRef<AST::UnnamedType>> {
+        }));
+    }, [&](RefPtr<ResolvableTypeReference>& left) -> RefPtr<AST::UnnamedType> {
+        return right.visit(WTF::makeVisitor([&](Ref<AST::UnnamedType>& right) -> RefPtr<AST::UnnamedType> {
             return matchAndCommit(right, left->resolvableType());
-        }, [&](Ref<ResolvableTypeReference>& right) -> Optional<UniqueRef<AST::UnnamedType>> {
+        }, [&](RefPtr<ResolvableTypeReference>& right) -> RefPtr<AST::UnnamedType> {
             return matchAndCommit(left->resolvableType(), right->resolvableType());
-        }), right);
-    }), left);
+        }));
+    }));
 }
 
-static Optional<UniqueRef<AST::UnnamedType>> matchAndCommit(ResolvingType& resolvingType, AST::UnnamedType& unnamedType)
+static RefPtr<AST::UnnamedType> matchAndCommit(ResolvingType& resolvingType, AST::UnnamedType& unnamedType)
 {
-    return WTF::visit(WTF::makeVisitor([&](UniqueRef<AST::UnnamedType>& resolvingType) -> Optional<UniqueRef<AST::UnnamedType>> {
+    return resolvingType.visit(WTF::makeVisitor([&](Ref<AST::UnnamedType>& resolvingType) -> RefPtr<AST::UnnamedType> {
         if (matches(unnamedType, resolvingType))
-            return unnamedType.clone();
-        return WTF::nullopt;
-    }, [&](Ref<ResolvableTypeReference>& resolvingType) -> Optional<UniqueRef<AST::UnnamedType>> {
+            return &unnamedType;
+        return nullptr;
+    }, [&](RefPtr<ResolvableTypeReference>& resolvingType) -> RefPtr<AST::UnnamedType> {
         return matchAndCommit(unnamedType, resolvingType->resolvableType());
-    }), resolvingType);
+    }));
 }
 
-static Optional<UniqueRef<AST::UnnamedType>> matchAndCommit(ResolvingType& resolvingType, AST::NamedType& namedType)
+static RefPtr<AST::UnnamedType> commit(ResolvingType& resolvingType)
 {
-    return WTF::visit(WTF::makeVisitor([&](UniqueRef<AST::UnnamedType>& resolvingType) -> Optional<UniqueRef<AST::UnnamedType>> {
-        if (matches(resolvingType, namedType))
-            return resolvingType->clone();
-        return WTF::nullopt;
-    }, [&](Ref<ResolvableTypeReference>& resolvingType) -> Optional<UniqueRef<AST::UnnamedType>> {
-        return matchAndCommit(namedType, resolvingType->resolvableType());
-    }), resolvingType);
+    return resolvingType.visit(WTF::makeVisitor([&](Ref<AST::UnnamedType>& unnamedType) -> RefPtr<AST::UnnamedType> {
+        return unnamedType.copyRef();
+    }, [&](RefPtr<ResolvableTypeReference>& resolvableTypeReference) -> RefPtr<AST::UnnamedType> {
+        if (!resolvableTypeReference->resolvableType().maybeResolvedType())
+            return commit(resolvableTypeReference->resolvableType());
+        return &resolvableTypeReference->resolvableType().resolvedType();
+    }));
+}
+
+AST::FunctionDeclaration* Checker::resolveFunction(Vector<std::reference_wrapper<ResolvingType>>& types, const String& name, CodeLocation location, AST::NamedType* castReturnType)
+{
+    Vector<std::reference_wrapper<AST::UnnamedType>> unnamedTypes;
+    unnamedTypes.reserveInitialCapacity(types.size());
+
+    for (auto resolvingType : types) {
+        AST::UnnamedType* type = resolvingType.get().visit(WTF::makeVisitor([&](Ref<AST::UnnamedType>& unnamedType) -> AST::UnnamedType* {
+            return unnamedType.ptr();
+        }, [&](RefPtr<ResolvableTypeReference>& resolvableTypeReference) -> AST::UnnamedType* {
+            if (resolvableTypeReference->resolvableType().maybeResolvedType())
+                return &resolvableTypeReference->resolvableType().resolvedType();
+
+            if (resolvableTypeReference->resolvableType().isFloatLiteralType()
+                || resolvableTypeReference->resolvableType().isIntegerLiteralType()
+                || resolvableTypeReference->resolvableType().isUnsignedIntegerLiteralType())
+                return &wrappedFloatType();
+
+            if (resolvableTypeReference->resolvableType().isNullLiteralType())
+                return &genericPointerType();
+
+            return commit(resolvableTypeReference->resolvableType()).get();
+        }));
+
+        if (!type) {
+            setError(Error("Could not resolve the type of a constant."));
+            return nullptr;
+        }
+
+        unnamedTypes.uncheckedAppend(normalizedTypeForFunctionKey(*type));
+    }
+
+    {
+        auto iter = m_functions.find(FunctionKey { name, WTFMove(unnamedTypes), castReturnType });
+        if (iter != m_functions.end()) {
+            if (AST::FunctionDeclaration* function = resolveFunctionOverload(iter->value, types, castReturnType, m_currentNameSpace))
+                return function;
+        }
+    }
+
+    if (auto newFunction = resolveByInstantiation(name, location, types, m_intrinsics)) {
+        m_program.append(WTFMove(*newFunction));
+        return &m_program.nativeFunctionDeclarations().last();
+    }
+
+    return nullptr;
 }
 
 void Checker::visit(AST::EnumerationDefinition& enumerationDefinition)
 {
+    bool isSigned;
     auto* baseType = ([&]() -> AST::NativeTypeDeclaration* {
         checkErrorAndVisit(enumerationDefinition.type());
         auto& baseType = enumerationDefinition.type().unifyNode();
         if (!is<AST::NamedType>(baseType))
             return nullptr;
@@ -618,156 +860,133 @@
         if (!is<AST::NativeTypeDeclaration>(namedType))
             return nullptr;
         auto& nativeTypeDeclaration = downcast<AST::NativeTypeDeclaration>(namedType);
         if (!nativeTypeDeclaration.isInt())
             return nullptr;
+        isSigned = nativeTypeDeclaration.isSigned();
         return &nativeTypeDeclaration;
     })();
     if (!baseType) {
-        setError();
+        setError(Error("Invalid base type for enum.", enumerationDefinition.codeLocation()));
         return;
     }
 
     auto enumerationMembers = enumerationDefinition.enumerationMembers();
 
     for (auto& member : enumerationMembers) {
-        if (!member.get().value())
-            continue;
-
-        bool success = false;
-        member.get().value()->visit(WTF::makeVisitor([&](AST::Expression& value) {
-            auto valueInfo = recurseAndGetInfo(value);
-            if (!valueInfo)
+        int64_t value = member.get().value();
+        if (isSigned) {
+            if (static_cast<int64_t>(static_cast<int32_t>(value)) != value) {
+                setError(Error("Invalid enumeration value.", member.get().codeLocation()));
                 return;
-            success = static_cast<bool>(matchAndCommit(valueInfo->resolvingType, *baseType));
-        }));
-        if (!success) {
-            setError();
-            return;
-        }
-    }
-
-    int64_t nextValue = 0;
-    for (auto& member : enumerationMembers) {
-        if (member.get().value()) {
-            int64_t value;
-            member.get().value()->visit(WTF::makeVisitor([&](AST::IntegerLiteral& integerLiteral) {
-                value = integerLiteral.valueForSelectedType();
-            }, [&](AST::UnsignedIntegerLiteral& unsignedIntegerLiteral) {
-                value = unsignedIntegerLiteral.valueForSelectedType();
-            }, [&](auto&) {
-                ASSERT_NOT_REACHED();
-            }));
-            nextValue = baseType->successor()(value);
+            }
         } else {
-            if (nextValue > std::numeric_limits<int>::max()) {
-                ASSERT(nextValue <= std::numeric_limits<unsigned>::max());
-                member.get().setValue(AST::ConstantExpression(AST::UnsignedIntegerLiteral(Lexer::Token(member.get().origin()), static_cast<unsigned>(nextValue))));
+            if (static_cast<int64_t>(static_cast<uint32_t>(value)) != value) {
+                setError(Error("Invalid enumeration value.", member.get().codeLocation()));
+                return;
             }
-            ASSERT(nextValue >= std::numeric_limits<int>::min());
-            member.get().setValue(AST::ConstantExpression(AST::IntegerLiteral(Lexer::Token(member.get().origin()), static_cast<int>(nextValue))));
-            nextValue = baseType->successor()(nextValue);
         }
     }
 
-    auto getValue = [&](AST::EnumerationMember& member) -> int64_t {
-        int64_t value;
-        ASSERT(member.value());
-        member.value()->visit(WTF::makeVisitor([&](AST::IntegerLiteral& integerLiteral) {
-            value = integerLiteral.value();
-        }, [&](AST::UnsignedIntegerLiteral& unsignedIntegerLiteral) {
-            value = unsignedIntegerLiteral.value();
-        }, [&](auto&) {
-            ASSERT_NOT_REACHED();
-        }));
-        return value;
-    };
-
     for (size_t i = 0; i < enumerationMembers.size(); ++i) {
-        auto value = getValue(enumerationMembers[i].get());
+        auto value = enumerationMembers[i].get().value();
         for (size_t j = i + 1; j < enumerationMembers.size(); ++j) {
-            auto otherValue = getValue(enumerationMembers[j].get());
+            auto otherValue = enumerationMembers[j].get().value();
             if (value == otherValue) {
-                setError();
+                setError(Error("Cannot declare duplicate enumeration values.", enumerationMembers[j].get().codeLocation()));
                 return;
             }
         }
     }
 
     bool foundZero = false;
     for (auto& member : enumerationMembers) {
-        if (!getValue(member.get())) {
+        if (!member.get().value()) {
             foundZero = true;
             break;
         }
     }
     if (!foundZero) {
-        setError();
+        setError(Error("enum definition must contain a zero value.", enumerationDefinition.codeLocation()));
         return;
     }
 }
 
 void Checker::visit(AST::TypeReference& typeReference)
 {
-    ASSERT(typeReference.resolvedType());
+    ASSERT(typeReference.maybeResolvedType());
 
-    checkErrorAndVisit(typeReference);
+    for (auto& typeArgument : typeReference.typeArguments())
+        checkErrorAndVisit(typeArgument);
 }
 
-auto Checker::recurseAndGetInfo(AST::Expression& expression, bool requiresLValue) -> Optional<RecurseInfo>
+auto Checker::recurseAndGetInfo(AST::Expression& expression, bool requiresLeftValue) -> Optional<RecurseInfo>
 {
-    checkErrorAndVisit(expression);
-    if (!error())
+    Visitor::visit(expression);
+    if (hasError())
         return WTF::nullopt;
-    return getInfo(expression, requiresLValue);
+    return getInfo(expression, requiresLeftValue);
 }
 
-auto Checker::getInfo(AST::Expression& expression, bool requiresLValue) -> Optional<RecurseInfo>
+auto Checker::getInfo(AST::Expression& expression, bool requiresLeftValue) -> Optional<RecurseInfo>
 {
     auto typeIterator = m_typeMap.find(&expression);
     ASSERT(typeIterator != m_typeMap.end());
 
-    auto addressSpaceIterator = m_addressSpaceMap.find(&expression);
-    ASSERT(addressSpaceIterator != m_addressSpaceMap.end());
-    if (requiresLValue && !addressSpaceIterator->value) {
-        setError();
+    const auto& typeAnnotation = expression.typeAnnotation();
+    if (requiresLeftValue && typeAnnotation.isRightValue()) {
+        setError(Error("Unexpected rvalue.", expression.codeLocation()));
         return WTF::nullopt;
     }
-    return {{ typeIterator->value, addressSpaceIterator->value }};
+    return {{ *typeIterator->value, typeAnnotation }};
 }
 
 void Checker::visit(AST::VariableDeclaration& variableDeclaration)
 {
     // ReadModifyWriteExpressions are the only place where anonymous variables exist,
     // and that doesn't recurse on the anonymous variables, so we can assume the variable has a type.
     checkErrorAndVisit(*variableDeclaration.type());
+    if (matches(*variableDeclaration.type(), m_intrinsics.voidType())) {
+        setError(Error("Variables can't have void type.", variableDeclaration.codeLocation()));
+        return;
+    }
     if (variableDeclaration.initializer()) {
         auto& lhsType = *variableDeclaration.type();
         auto initializerInfo = recurseAndGetInfo(*variableDeclaration.initializer());
         if (!initializerInfo)
             return;
         if (!matchAndCommit(initializerInfo->resolvingType, lhsType)) {
-            setError();
+            setError(Error("Declared variable type does not match its initializer's type.", variableDeclaration.codeLocation()));
             return;
         }
     }
 }
 
-void Checker::assignType(AST::Expression& expression, UniqueRef<AST::UnnamedType>&& unnamedType, Optional<AST::AddressSpace> addressSpace)
+void Checker::assignConcreteType(AST::Expression& expression, Ref<AST::UnnamedType> unnamedType, AST::TypeAnnotation typeAnnotation = AST::RightValue())
 {
-    auto addResult = m_typeMap.add(&expression, WTFMove(unnamedType));
+    auto addResult = m_typeMap.add(&expression, makeUnique<ResolvingType>(WTFMove(unnamedType)));
     ASSERT_UNUSED(addResult, addResult.isNewEntry);
-    auto addressSpaceAddResult = m_addressSpaceMap.add(&expression, addressSpace);
-    ASSERT_UNUSED(addressSpaceAddResult, addressSpaceAddResult.isNewEntry);
+    expression.setTypeAnnotation(WTFMove(typeAnnotation));
 }
 
-void Checker::assignType(AST::Expression& expression, Ref<ResolvableTypeReference>&& resolvableTypeReference, Optional<AST::AddressSpace> addressSpace)
+void Checker::assignType(AST::Expression& expression, RefPtr<ResolvableTypeReference> resolvableTypeReference, AST::TypeAnnotation typeAnnotation = AST::RightValue())
 {
-    auto addResult = m_typeMap.add(&expression, WTFMove(resolvableTypeReference));
+    auto addResult = m_typeMap.add(&expression, makeUnique<ResolvingType>(WTFMove(resolvableTypeReference)));
     ASSERT_UNUSED(addResult, addResult.isNewEntry);
-    auto addressSpaceAddResult = m_addressSpaceMap.add(&expression, addressSpace);
-    ASSERT_UNUSED(addressSpaceAddResult, addressSpaceAddResult.isNewEntry);
+    expression.setTypeAnnotation(WTFMove(typeAnnotation));
+}
+
+void Checker::forwardType(AST::Expression& expression, ResolvingType& resolvingType, AST::TypeAnnotation typeAnnotation = AST::RightValue())
+{
+    resolvingType.visit(WTF::makeVisitor([&](Ref<AST::UnnamedType>& result) {
+        auto addResult = m_typeMap.add(&expression, makeUnique<ResolvingType>(result.copyRef()));
+        ASSERT_UNUSED(addResult, addResult.isNewEntry);
+    }, [&](RefPtr<ResolvableTypeReference>& result) {
+        auto addResult = m_typeMap.add(&expression, makeUnique<ResolvingType>(result.copyRef()));
+        ASSERT_UNUSED(addResult, addResult.isNewEntry);
+    }));
+    expression.setTypeAnnotation(WTFMove(typeAnnotation));
 }
 
 void Checker::visit(AST::AssignmentExpression& assignmentExpression)
 {
     auto leftInfo = recurseAndGetInfo(assignmentExpression.left(), true);
@@ -778,62 +997,51 @@
     if (!rightInfo)
         return;
 
     auto resultType = matchAndCommit(leftInfo->resolvingType, rightInfo->resolvingType);
     if (!resultType) {
-        setError();
+        setError(Error("Left hand side of assignment does not match the type of the right hand side.", assignmentExpression.codeLocation()));
         return;
     }
 
-    assignType(assignmentExpression, WTFMove(*resultType));
-}
-
-void Checker::forwardType(AST::Expression& expression, ResolvingType& resolvingType, Optional<AST::AddressSpace> addressSpace)
-{
-    WTF::visit(WTF::makeVisitor([&](UniqueRef<AST::UnnamedType>& result) {
-        auto addResult = m_typeMap.add(&expression, result->clone());
-        ASSERT_UNUSED(addResult, addResult.isNewEntry);
-    }, [&](Ref<ResolvableTypeReference>& result) {
-        auto addResult = m_typeMap.add(&expression, result.copyRef());
-        ASSERT_UNUSED(addResult, addResult.isNewEntry);
-    }), resolvingType);
-    auto addressSpaceAddResult = m_addressSpaceMap.add(&expression, addressSpace);
-    ASSERT_UNUSED(addressSpaceAddResult, addressSpaceAddResult.isNewEntry);
+    assignConcreteType(assignmentExpression, *resultType);
 }
 
 void Checker::visit(AST::ReadModifyWriteExpression& readModifyWriteExpression)
 {
-    auto lValueInfo = recurseAndGetInfo(readModifyWriteExpression.lValue(), true);
-    if (!lValueInfo)
+    auto leftValueInfo = recurseAndGetInfo(readModifyWriteExpression.leftValue(), true);
+    if (!leftValueInfo)
         return;
 
-    // FIXME: Figure out what to do with the ReadModifyWriteExpression's AnonymousVariables.
+    readModifyWriteExpression.oldValue().setType(*leftValueInfo->resolvingType.getUnnamedType());
 
-    auto newValueInfo = recurseAndGetInfo(*readModifyWriteExpression.newValueExpression());
+    auto newValueInfo = recurseAndGetInfo(readModifyWriteExpression.newValueExpression());
     if (!newValueInfo)
         return;
 
-    if (!matchAndCommit(lValueInfo->resolvingType, newValueInfo->resolvingType)) {
-        setError();
+    if (RefPtr<AST::UnnamedType> matchedType = matchAndCommit(leftValueInfo->resolvingType, newValueInfo->resolvingType))
+        readModifyWriteExpression.newValue().setType(*matchedType);
+    else {
+        setError(Error("Base of the read-modify-write expression does not match the type of the new value.", readModifyWriteExpression.codeLocation()));
         return;
     }
 
-    auto resultInfo = recurseAndGetInfo(*readModifyWriteExpression.resultExpression());
+    auto resultInfo = recurseAndGetInfo(readModifyWriteExpression.resultExpression());
     if (!resultInfo)
         return;
 
     forwardType(readModifyWriteExpression, resultInfo->resolvingType);
 }
 
 static AST::UnnamedType* getUnnamedType(ResolvingType& resolvingType)
 {
-    return WTF::visit(WTF::makeVisitor([](UniqueRef<AST::UnnamedType>& type) -> AST::UnnamedType* {
-        return &type;
-    }, [](Ref<ResolvableTypeReference>& type) -> AST::UnnamedType* {
+    return resolvingType.visit(WTF::makeVisitor([](Ref<AST::UnnamedType>& type) -> AST::UnnamedType* {
+        return type.ptr();
+    }, [](RefPtr<ResolvableTypeReference>& type) -> AST::UnnamedType* {
         // FIXME: If the type isn't committed, should we just commit() it now?
-        return type->resolvableType().resolvedType();
-    }), resolvingType);
+        return type->resolvableType().maybeResolvedType();
+    }));
 }
 
 void Checker::visit(AST::DereferenceExpression& dereferenceExpression)
 {
     auto pointerInfo = recurseAndGetInfo(dereferenceExpression.pointer());
@@ -852,267 +1060,279 @@
         if (!is<AST::PointerType>(unnamedUnifyType))
             return nullptr;
         return &downcast<AST::PointerType>(unnamedUnifyType);
     })(unnamedType);
     if (!pointerType) {
-        setError();
+        setError(Error("Cannot dereference a non-pointer type.", dereferenceExpression.codeLocation()));
         return;
     }
 
-    assignType(dereferenceExpression, pointerType->clone(), pointerType->addressSpace());
+    assignConcreteType(dereferenceExpression, pointerType->elementType(), AST::LeftValue { pointerType->addressSpace() });
 }
 
 void Checker::visit(AST::MakePointerExpression& makePointerExpression)
 {
-    auto lValueInfo = recurseAndGetInfo(makePointerExpression.lValue(), true);
-    if (!lValueInfo)
+    auto leftValueInfo = recurseAndGetInfo(makePointerExpression.leftValue(), true);
+    if (!leftValueInfo)
         return;
 
-    auto* lValueType = getUnnamedType(lValueInfo->resolvingType);
-    if (!lValueType) {
-        setError();
+    auto leftAddressSpace = leftValueInfo->typeAnnotation.leftAddressSpace();
+    if (!leftAddressSpace) {
+        setError(Error("Cannot take the address of a non lvalue.", makePointerExpression.codeLocation()));
         return;
     }
 
-    assignType(makePointerExpression, makeUniqueRef<AST::PointerType>(Lexer::Token(makePointerExpression.origin()), *lValueInfo->addressSpace, lValueType->clone()));
+    auto* leftValueType = getUnnamedType(leftValueInfo->resolvingType);
+    if (!leftValueType) {
+        setError(Error("Cannot take the address of a value without a type.", makePointerExpression.codeLocation()));
+        return;
+    }
+
+    assignConcreteType(makePointerExpression, AST::PointerType::create(makePointerExpression.codeLocation(), *leftAddressSpace, *leftValueType));
 }
 
 void Checker::visit(AST::MakeArrayReferenceExpression& makeArrayReferenceExpression)
 {
-    auto lValueInfo = recurseAndGetInfo(makeArrayReferenceExpression.lValue());
-    if (!lValueInfo)
+    auto leftValueInfo = recurseAndGetInfo(makeArrayReferenceExpression.leftValue());
+    if (!leftValueInfo)
         return;
 
-    auto* lValueType = getUnnamedType(lValueInfo->resolvingType);
-    if (!lValueType) {
-        setError();
+    auto* leftValueType = getUnnamedType(leftValueInfo->resolvingType);
+    if (!leftValueType) {
+        setError(Error("Cannot make an array reference of a value without a type.", makeArrayReferenceExpression.codeLocation()));
         return;
     }
 
-    auto& unifyNode = lValueType->unifyNode();
+    auto& unifyNode = leftValueType->unifyNode();
     if (is<AST::UnnamedType>(unifyNode)) {
         auto& unnamedType = downcast<AST::UnnamedType>(unifyNode);
         if (is<AST::PointerType>(unnamedType)) {
             auto& pointerType = downcast<AST::PointerType>(unnamedType);
-            // FIXME: Save the fact that we're not targetting the item; we're targetting the item's inner element.
-            assignType(makeArrayReferenceExpression, makeUniqueRef<AST::ArrayReferenceType>(Lexer::Token(makeArrayReferenceExpression.origin()), pointerType.addressSpace(), pointerType.elementType().clone()));
+            // FIXME: https://bugs.webkit.org/show_bug.cgi?id=198163 Save the fact that we're not targetting the item; we're targetting the item's inner element.
+            assignConcreteType(makeArrayReferenceExpression, AST::ArrayReferenceType::create(makeArrayReferenceExpression.codeLocation(), pointerType.addressSpace(), pointerType.elementType()));
             return;
         }
 
-        if (!lValueInfo->addressSpace) {
-            setError();
+        auto leftAddressSpace = leftValueInfo->typeAnnotation.leftAddressSpace();
+        if (!leftAddressSpace) {
+            setError(Error("Cannot make an array reference from a non-left-value.", makeArrayReferenceExpression.codeLocation()));
             return;
         }
 
         if (is<AST::ArrayType>(unnamedType)) {
             auto& arrayType = downcast<AST::ArrayType>(unnamedType);
-            // FIXME: Save the number of elements.
-            assignType(makeArrayReferenceExpression, makeUniqueRef<AST::ArrayReferenceType>(Lexer::Token(makeArrayReferenceExpression.origin()), *lValueInfo->addressSpace, arrayType.type().clone()));
+            // FIXME: https://bugs.webkit.org/show_bug.cgi?id=198163 Save the number of elements.
+            assignConcreteType(makeArrayReferenceExpression, AST::ArrayReferenceType::create(makeArrayReferenceExpression.codeLocation(), *leftAddressSpace, arrayType.type()));
             return;
         }
     }
 
-    if (!lValueInfo->addressSpace) {
-        setError();
+    auto leftAddressSpace = leftValueInfo->typeAnnotation.leftAddressSpace();
+    if (!leftAddressSpace) {
+        setError(Error("Cannot make an array reference from a non-left-value.", makeArrayReferenceExpression.codeLocation()));
         return;
     }
 
-    assignType(makeArrayReferenceExpression, makeUniqueRef<AST::ArrayReferenceType>(Lexer::Token(makeArrayReferenceExpression.origin()), *lValueInfo->addressSpace, lValueType->clone()));
+    assignConcreteType(makeArrayReferenceExpression, AST::ArrayReferenceType::create(makeArrayReferenceExpression.codeLocation(), *leftAddressSpace, *leftValueType));
 }
 
-void Checker::finishVisitingPropertyAccess(AST::PropertyAccessExpression& propertyAccessExpression, AST::UnnamedType& wrappedBaseType, AST::UnnamedType* extraArgumentType)
+RefPtr<AST::UnnamedType> Checker::argumentTypeForAndOverload(AST::UnnamedType& baseType, AST::AddressSpace addressSpace)
 {
-    Optional<std::reference_wrapper<AST::NamedType>> castReturnType;
-    using OverloadResolution = std::tuple<AST::FunctionDeclaration*, AST::UnnamedType*>;
-
-    AST::FunctionDeclaration* getFunction;
-    AST::UnnamedType* getReturnType;
-    std::tie(getFunction, getReturnType) = ([&]() -> OverloadResolution {
-        ResolvingType getArgumentType1(wrappedBaseType.clone());
-        Optional<ResolvingType> getArgumentType2;
-        if (extraArgumentType)
-            getArgumentType2 = ResolvingType(extraArgumentType->clone());
-
-        Vector<std::reference_wrapper<ResolvingType>> getArgumentTypes;
-        getArgumentTypes.append(getArgumentType1);
-        if (getArgumentType2)
-            getArgumentTypes.append(*getArgumentType2);
-
-        auto* getFunction = resolveFunctionOverloadImpl(propertyAccessExpression.possibleGetOverloads(), getArgumentTypes, castReturnType);
-        if (!getFunction)
-            return std::make_pair(nullptr, nullptr);
-        return std::make_pair(getFunction, &getFunction->type());
-    })();
+    AndOverloadTypeKey key { baseType, addressSpace };
+    {
+        auto iter = m_andOverloadTypeMap.find(key);
+        if (iter != m_andOverloadTypeMap.end())
+            return iter->value;
+    }
 
-    AST::FunctionDeclaration* andFunction;
-    AST::UnnamedType* andReturnType;
-    std::tie(andFunction, andReturnType) = ([&]() -> OverloadResolution {
-        auto computeAndArgumentType = [&](AST::UnnamedType& unnamedType) -> Optional<ResolvingType> {
-            if (is<AST::ArrayReferenceType>(unnamedType))
-                return { unnamedType.clone() };
-            if (is<AST::ArrayType>(unnamedType))
-                return { makeUniqueRef<AST::ArrayReferenceType>(Lexer::Token(propertyAccessExpression.origin()), AST::AddressSpace::Thread, downcast<AST::ArrayType>(unnamedType).type().clone()) };
-            if (is<AST::PointerType>(unnamedType))
-                return WTF::nullopt;
-            return { makeUniqueRef<AST::PointerType>(Lexer::Token(propertyAccessExpression.origin()), AST::AddressSpace::Thread, downcast<AST::ArrayType>(unnamedType).type().clone()) };
-        };
-        auto computeAndReturnType = [&](AST::UnnamedType& unnamedType) -> AST::UnnamedType* {
-            if (is<AST::PointerType>(unnamedType))
-                return &downcast<AST::PointerType>(unnamedType).elementType();
+    auto createArgumentType = [&] () -> RefPtr<AST::UnnamedType> {
+        auto& unifyNode = baseType.unifyNode();
+        if (is<AST::NamedType>(unifyNode)) {
+            auto& namedType = downcast<AST::NamedType>(unifyNode);
+            return { AST::PointerType::create(namedType.codeLocation(), addressSpace, AST::TypeReference::wrap(namedType.codeLocation(), namedType)) };
+        }
+
+        auto& unnamedType = downcast<AST::UnnamedType>(unifyNode);
+
+        if (is<AST::ArrayReferenceType>(unnamedType))
+            return &unnamedType;
+
+        if (is<AST::ArrayType>(unnamedType))
+            return { AST::ArrayReferenceType::create(unnamedType.codeLocation(), addressSpace, downcast<AST::ArrayType>(unnamedType).type()) };
+
+        if (is<AST::PointerType>(unnamedType))
             return nullptr;
-        };
 
-        auto andArgumentType1 = computeAndArgumentType(wrappedBaseType);
-        if (!andArgumentType1)
-            return std::make_pair(nullptr, nullptr);
-        Optional<ResolvingType> andArgumentType2;
-        if (extraArgumentType)
-            andArgumentType2 = ResolvingType(extraArgumentType->clone());
-
-        Vector<std::reference_wrapper<ResolvingType>> andArgumentTypes;
-        andArgumentTypes.append(*andArgumentType1);
-        if (andArgumentType2)
-            andArgumentTypes.append(*andArgumentType2);
-
-        auto* andFunction = resolveFunctionOverloadImpl(propertyAccessExpression.possibleAndOverloads(), andArgumentTypes, castReturnType);
-        if (!andFunction)
-            return std::make_pair(nullptr, nullptr);
-        return std::make_pair(andFunction, computeAndReturnType(andFunction->type()));
-    })();
+        return { AST::PointerType::create(unnamedType.codeLocation(), addressSpace, unnamedType) };
+    };
 
-    if (!getReturnType && !andReturnType) {
-        setError();
-        return;
-    }
+    auto result = createArgumentType();
+    m_andOverloadTypeMap.add(key, result);
+    return result;
+}
 
-    if (getReturnType && andReturnType && !matches(*getReturnType, *andReturnType)) {
-        setError();
+void Checker::finishVisiting(AST::PropertyAccessExpression& propertyAccessExpression, ResolvingType* additionalArgumentType)
+{
+    auto baseInfo = recurseAndGetInfo(propertyAccessExpression.base());
+    if (!baseInfo)
+        return;
+    auto baseUnnamedType = commit(baseInfo->resolvingType);
+    if (!baseUnnamedType) {
+        setError(Error("Cannot resolve the type of the base of a property access expression.", propertyAccessExpression.codeLocation()));
         return;
     }
 
-    AST::FunctionDeclaration* setFunction;
-    AST::UnnamedType* setReturnType;
-    std::tie(setFunction, setReturnType) = ([&]() -> OverloadResolution {
-        ResolvingType setArgument1Type(wrappedBaseType.clone());
-        Optional<ResolvingType> setArgumentType2;
-        if (extraArgumentType)
-            setArgumentType2 = ResolvingType(extraArgumentType->clone());
-        ResolvingType setArgument3Type(getReturnType ? getReturnType->clone() : andReturnType->clone());
-
-        Vector<std::reference_wrapper<ResolvingType>> setArgumentTypes;
-        setArgumentTypes.append(setArgument1Type);
-        if (setArgumentType2)
-            setArgumentTypes.append(*setArgumentType2);
-        setArgumentTypes.append(setArgument3Type);
-
-        auto* setFunction = resolveFunctionOverloadImpl(propertyAccessExpression.possibleSetOverloads(), setArgumentTypes, castReturnType);
-        if (!setFunction)
-            return std::make_pair(nullptr, nullptr);
-        return std::make_pair(setFunction, &setFunction->type());
-    })();
-
-    if (setFunction) {
-        if (!matches(setFunction->type(), wrappedBaseType)) {
-            setError();
+    AST::FunctionDeclaration* getterFunction = nullptr;
+    RefPtr<AST::UnnamedType> getterReturnType = nullptr;
+    {
+        Vector<std::reference_wrapper<ResolvingType>> getterArgumentTypes { baseInfo->resolvingType };
+        if (additionalArgumentType)
+            getterArgumentTypes.append(*additionalArgumentType);
+        auto getterName = propertyAccessExpression.getterFunctionName();
+        getterFunction = resolveFunction(getterArgumentTypes, getterName, propertyAccessExpression.codeLocation());
+        if (hasError())
             return;
-        }
+        if (getterFunction)
+            getterReturnType = &getterFunction->type();
     }
 
-    Optional<AST::AddressSpace> addressSpace;
-    if (getReturnType || andReturnType) {
-        // FIXME: The reference compiler has "else if (!node.base.isLValue && !baseType.isArrayRef)",
-        // but I don't understand why it exists. I haven't written it here, and I'll investigate
-        // if we can remove it from the reference compiler.
-        if (is<AST::ReferenceType>(wrappedBaseType))
-            addressSpace = downcast<AST::ReferenceType>(wrappedBaseType).addressSpace();
-        else {
-            auto addressSpaceIterator = m_addressSpaceMap.find(&propertyAccessExpression.base());
-            ASSERT(addressSpaceIterator != m_addressSpaceMap.end());
-            if (addressSpaceIterator->value)
-                addressSpace = *addressSpaceIterator->value;
-            else {
-                setError();
+    AST::FunctionDeclaration* anderFunction = nullptr;
+    RefPtr<AST::UnnamedType> anderReturnType = nullptr;
+    auto leftAddressSpace = baseInfo->typeAnnotation.leftAddressSpace();
+    if (leftAddressSpace) {
+        if (auto argumentTypeForAndOverload = this->argumentTypeForAndOverload(*baseUnnamedType, *leftAddressSpace)) {
+            ResolvingType argumentType = { Ref<AST::UnnamedType>(*argumentTypeForAndOverload) };
+            Vector<std::reference_wrapper<ResolvingType>> anderArgumentTypes { argumentType };
+            if (additionalArgumentType)
+                anderArgumentTypes.append(*additionalArgumentType);
+            auto anderName = propertyAccessExpression.anderFunctionName();
+            anderFunction = resolveFunction(anderArgumentTypes, anderName, propertyAccessExpression.codeLocation());
+            if (hasError())
                 return;
-            }
+            if (anderFunction)
+                anderReturnType = &downcast<AST::PointerType>(anderFunction->type()).elementType(); // FIXME: https://bugs.webkit.org/show_bug.cgi?id=198164 Enforce the return of anders will always be a pointer
         }
     }
 
-    // FIXME: Generate the call expressions
-
-    assignType(propertyAccessExpression, getReturnType ? getReturnType->clone() : andReturnType->clone(), addressSpace);
-}
+    AST::FunctionDeclaration* threadAnderFunction = nullptr;
+    RefPtr<AST::UnnamedType> threadAnderReturnType = nullptr;
+    if (auto argumentTypeForAndOverload = this->argumentTypeForAndOverload(*baseUnnamedType, AST::AddressSpace::Thread)) {
+        ResolvingType argumentType = { Ref<AST::UnnamedType>(AST::PointerType::create(propertyAccessExpression.codeLocation(), AST::AddressSpace::Thread, *baseUnnamedType)) };
+        Vector<std::reference_wrapper<ResolvingType>> threadAnderArgumentTypes { argumentType };
+        if (additionalArgumentType)
+            threadAnderArgumentTypes.append(*additionalArgumentType);
+        auto anderName = propertyAccessExpression.anderFunctionName();
+        threadAnderFunction = resolveFunction(threadAnderArgumentTypes, anderName, propertyAccessExpression.codeLocation());
+        if (hasError())
+            return;
+        if (threadAnderFunction)
+            threadAnderReturnType = &downcast<AST::PointerType>(threadAnderFunction->type()).elementType(); // FIXME: https://bugs.webkit.org/show_bug.cgi?id=198164 Enforce the return of anders will always be a pointer
+    }
 
-Optional<UniqueRef<AST::UnnamedType>> Checker::recurseAndWrapBaseType(AST::PropertyAccessExpression& propertyAccessExpression)
-{
-    auto baseInfo = recurseAndGetInfo(propertyAccessExpression.base());
-    if (!baseInfo)
-        return WTF::nullopt;
+    if (leftAddressSpace && !anderFunction && !getterFunction) {
+        setError(Error("Property access instruction must either have an ander or a getter.", propertyAccessExpression.codeLocation()));
+        return;
+    }
 
-    auto* baseType = getUnnamedType(baseInfo->resolvingType);
-    if (!baseType) {
-        setError();
-        return WTF::nullopt;
+    if (!leftAddressSpace && !threadAnderFunction && !getterFunction) {
+        setError(Error("Property access instruction must either have a thread ander or a getter.", propertyAccessExpression.codeLocation()));
+        return;
     }
-    auto& baseUnifyNode = baseType->unifyNode();
-    if (is<AST::UnnamedType>(baseUnifyNode))
-        return downcast<AST::UnnamedType>(baseUnifyNode).clone();
-    ASSERT(is<AST::NamedType>(baseUnifyNode));
-    return { AST::TypeReference::wrap(Lexer::Token(propertyAccessExpression.origin()), downcast<AST::NamedType>(baseUnifyNode)) };
-}
 
-void Checker::visit(AST::DotExpression& dotExpression)
-{
-    auto baseType = recurseAndWrapBaseType(dotExpression);
-    if (!baseType)
+    if (threadAnderFunction && getterFunction) {
+        setError(Error("Cannot have both a thread ander and a getter.", propertyAccessExpression.codeLocation()));
         return;
+    }
 
-    finishVisitingPropertyAccess(dotExpression, *baseType);
-}
+    if (anderFunction && threadAnderFunction && !matches(*anderReturnType, *threadAnderReturnType)) {
+        setError(Error("Return type of ander must match the return type of the thread ander.", propertyAccessExpression.codeLocation()));
+        return;
+    }
 
-void Checker::visit(AST::IndexExpression& indexExpression)
-{
-    auto baseType = recurseAndWrapBaseType(indexExpression);
-    if (!baseType)
+    if (getterFunction && anderFunction && !matches(*getterReturnType, *anderReturnType)) {
+        setError(Error("Return type of ander must match the return type of the getter.", propertyAccessExpression.codeLocation()));
         return;
+    }
 
-    auto indexInfo = recurseAndGetInfo(indexExpression.indexExpression());
-    if (!indexInfo)
+    if (getterFunction && threadAnderFunction && !matches(*getterReturnType, *threadAnderReturnType)) {
+        setError(Error("Return type of the thread ander must match the return type of the getter.", propertyAccessExpression.codeLocation()));
         return;
-    auto indexExpressionType = getUnnamedType(indexInfo->resolvingType);
-    if (!indexExpressionType) {
-        setError();
+    }
+
+    Ref<AST::UnnamedType> fieldType = getterReturnType ? *getterReturnType : anderReturnType ? *anderReturnType : *threadAnderReturnType;
+
+    AST::FunctionDeclaration* setterFunction = nullptr;
+    AST::UnnamedType* setterReturnType = nullptr;
+    {
+        ResolvingType fieldResolvingType(fieldType.copyRef());
+        Vector<std::reference_wrapper<ResolvingType>> setterArgumentTypes { baseInfo->resolvingType };
+        if (additionalArgumentType)
+            setterArgumentTypes.append(*additionalArgumentType);
+        setterArgumentTypes.append(fieldResolvingType);
+        auto setterName = propertyAccessExpression.setterFunctionName();
+        setterFunction = resolveFunction(setterArgumentTypes, setterName, propertyAccessExpression.codeLocation());
+        if (hasError())
+            return;
+        if (setterFunction)
+            setterReturnType = &setterFunction->type();
+    }
+
+    if (setterFunction && !getterFunction) {
+        setError(Error("Cannot define a setter function without a corresponding getter.", propertyAccessExpression.codeLocation()));
         return;
     }
 
-    finishVisitingPropertyAccess(indexExpression, WTFMove(*baseType), indexExpressionType);
+    propertyAccessExpression.setGetterFunction(getterFunction);
+    propertyAccessExpression.setAnderFunction(anderFunction);
+    propertyAccessExpression.setThreadAnderFunction(threadAnderFunction);
+    propertyAccessExpression.setSetterFunction(setterFunction);
+
+    AST::TypeAnnotation typeAnnotation = AST::RightValue();
+    if (auto leftAddressSpace = baseInfo->typeAnnotation.leftAddressSpace()) {
+        if (anderFunction)
+            typeAnnotation = AST::LeftValue { downcast<AST::ReferenceType>(anderFunction->type()).addressSpace() };
+        else if (setterFunction)
+            typeAnnotation = AST::AbstractLeftValue();
+    } else if (!baseInfo->typeAnnotation.isRightValue() && (setterFunction || threadAnderFunction))
+        typeAnnotation = AST::AbstractLeftValue();
+    assignConcreteType(propertyAccessExpression, WTFMove(fieldType), WTFMove(typeAnnotation));
+}
+
+void Checker::visit(AST::DotExpression& dotExpression)
+{
+    finishVisiting(dotExpression);
+}
+
+void Checker::visit(AST::IndexExpression& indexExpression)
+{
+    auto baseInfo = recurseAndGetInfo(indexExpression.indexExpression());
+    if (!baseInfo)
+        return;
+    finishVisiting(indexExpression, &baseInfo->resolvingType);
 }
 
 void Checker::visit(AST::VariableReference& variableReference)
 {
     ASSERT(variableReference.variable());
     ASSERT(variableReference.variable()->type());
 
-    Optional<AST::AddressSpace> addressSpace;
-    if (!variableReference.variable()->isAnonymous())
-        addressSpace = AST::AddressSpace::Thread;
-    assignType(variableReference, variableReference.variable()->type()->clone(), addressSpace);
+    assignConcreteType(variableReference, *variableReference.variable()->type(), AST::LeftValue { AST::AddressSpace::Thread });
 }
 
 void Checker::visit(AST::Return& returnStatement)
 {
-    ASSERT(returnStatement.function());
     if (returnStatement.value()) {
         auto valueInfo = recurseAndGetInfo(*returnStatement.value());
         if (!valueInfo)
             return;
-        if (!matchAndCommit(valueInfo->resolvingType, returnStatement.function()->type()))
-            setError();
+        if (!matchAndCommit(valueInfo->resolvingType, m_currentFunction->type()))
+            setError(Error("Type of the return value must match the return type of the function.", returnStatement.codeLocation()));
         return;
     }
 
-    if (!matches(returnStatement.function()->type(), m_intrinsics.voidType()))
-        setError();
+    if (!matches(m_currentFunction->type(), m_intrinsics.voidType()))
+        setError(Error("Cannot return a value from a void function.", returnStatement.codeLocation()));
 }
 
 void Checker::visit(AST::PointerType&)
 {
     // Following pointer types can cause infinite loops because of data structures
@@ -1147,55 +1367,55 @@
     assignType(nullLiteral, adoptRef(*new ResolvableTypeReference(nullLiteral.type())));
 }
 
 void Checker::visit(AST::BooleanLiteral& booleanLiteral)
 {
-    assignType(booleanLiteral, AST::TypeReference::wrap(Lexer::Token(booleanLiteral.origin()), m_intrinsics.boolType()));
+    assignConcreteType(booleanLiteral, AST::TypeReference::wrap(booleanLiteral.codeLocation(), m_intrinsics.boolType()));
 }
 
 void Checker::visit(AST::EnumerationMemberLiteral& enumerationMemberLiteral)
 {
     ASSERT(enumerationMemberLiteral.enumerationDefinition());
     auto& enumerationDefinition = *enumerationMemberLiteral.enumerationDefinition();
-    assignType(enumerationMemberLiteral, AST::TypeReference::wrap(Lexer::Token(enumerationMemberLiteral.origin()), enumerationDefinition));
+    assignConcreteType(enumerationMemberLiteral, AST::TypeReference::wrap(enumerationMemberLiteral.codeLocation(), enumerationDefinition));
 }
 
 bool Checker::isBoolType(ResolvingType& resolvingType)
 {
-    return WTF::visit(WTF::makeVisitor([&](UniqueRef<AST::UnnamedType>& left) -> bool {
+    return resolvingType.visit(WTF::makeVisitor([&](Ref<AST::UnnamedType>& left) -> bool {
         return matches(left, m_intrinsics.boolType());
-    }, [&](Ref<ResolvableTypeReference>& left) -> bool {
+    }, [&](RefPtr<ResolvableTypeReference>& left) -> bool {
         return static_cast<bool>(matchAndCommit(m_intrinsics.boolType(), left->resolvableType()));
-    }), resolvingType);
+    }));
 }
 
 bool Checker::recurseAndRequireBoolType(AST::Expression& expression)
 {
     auto expressionInfo = recurseAndGetInfo(expression);
     if (!expressionInfo)
         return false;
     if (!isBoolType(expressionInfo->resolvingType)) {
-        setError();
+        setError(Error("Expected bool type from expression.", expression.codeLocation()));
         return false;
     }
     return true;
 }
 
 void Checker::visit(AST::LogicalNotExpression& logicalNotExpression)
 {
     if (!recurseAndRequireBoolType(logicalNotExpression.operand()))
         return;
-    assignType(logicalNotExpression, AST::TypeReference::wrap(Lexer::Token(logicalNotExpression.origin()), m_intrinsics.boolType()));
+    assignConcreteType(logicalNotExpression, AST::TypeReference::wrap(logicalNotExpression.codeLocation(), m_intrinsics.boolType()));
 }
 
 void Checker::visit(AST::LogicalExpression& logicalExpression)
 {
     if (!recurseAndRequireBoolType(logicalExpression.left()))
         return;
     if (!recurseAndRequireBoolType(logicalExpression.right()))
         return;
-    assignType(logicalExpression, AST::TypeReference::wrap(Lexer::Token(logicalExpression.origin()), m_intrinsics.boolType()));
+    assignConcreteType(logicalExpression, AST::TypeReference::wrap(logicalExpression.codeLocation(), m_intrinsics.boolType()));
 }
 
 void Checker::visit(AST::IfStatement& ifStatement)
 {
     if (!recurseAndRequireBoolType(ifStatement.conditional()))
@@ -1218,16 +1438,12 @@
     recurseAndRequireBoolType(doWhileLoop.conditional());
 }
 
 void Checker::visit(AST::ForLoop& forLoop)
 {
-    WTF::visit(WTF::makeVisitor([&](AST::VariableDeclarationsStatement& variableDeclarationsStatement) {
-        checkErrorAndVisit(variableDeclarationsStatement);
-    }, [&](UniqueRef<AST::Expression>& expression) {
-        checkErrorAndVisit(expression);
-    }), forLoop.initialization());
-    if (error())
+    checkErrorAndVisit(forLoop.initialization());
+    if (hasError())
         return;
     if (forLoop.condition()) {
         if (!recurseAndRequireBoolType(*forLoop.condition()))
             return;
     }
@@ -1253,38 +1469,37 @@
             && !is<AST::EnumerationDefinition>(valueNamedUnifyNode))
             return nullptr;
         return &valueNamedUnifyNode;
     })();
     if (!valueType) {
-        setError();
+        setError(Error("Invalid type for the expression condition of the switch statement.", switchStatement.codeLocation()));
         return;
     }
 
     bool hasDefault = false;
     for (auto& switchCase : switchStatement.switchCases()) {
         checkErrorAndVisit(switchCase.block());
         if (!switchCase.value()) {
             hasDefault = true;
             continue;
         }
-        bool success;
-        switchCase.value()->visit(WTF::makeVisitor([&](AST::IntegerLiteral& integerLiteral) {
-            success = static_cast<bool>(matchAndCommit(*valueType, integerLiteral.type()));
-        }, [&](AST::UnsignedIntegerLiteral& unsignedIntegerLiteral) {
-            success = static_cast<bool>(matchAndCommit(*valueType, unsignedIntegerLiteral.type()));
-        }, [&](AST::FloatLiteral& floatLiteral) {
-            success = static_cast<bool>(matchAndCommit(*valueType, floatLiteral.type()));
-        }, [&](AST::NullLiteral& nullLiteral) {
-            success = static_cast<bool>(matchAndCommit(*valueType, nullLiteral.type()));
-        }, [&](AST::BooleanLiteral&) {
-            success = matches(*valueType, m_intrinsics.boolType());
-        }, [&](AST::EnumerationMemberLiteral& enumerationMemberLiteral) {
+        auto success = switchCase.value()->visit(WTF::makeVisitor([&](AST::IntegerLiteral& integerLiteral) -> bool {
+            return static_cast<bool>(matchAndCommit(*valueType, integerLiteral.type()));
+        }, [&](AST::UnsignedIntegerLiteral& unsignedIntegerLiteral) -> bool {
+            return static_cast<bool>(matchAndCommit(*valueType, unsignedIntegerLiteral.type()));
+        }, [&](AST::FloatLiteral& floatLiteral) -> bool {
+            return static_cast<bool>(matchAndCommit(*valueType, floatLiteral.type()));
+        }, [&](AST::NullLiteral& nullLiteral) -> bool {
+            return static_cast<bool>(matchAndCommit(*valueType, nullLiteral.type()));
+        }, [&](AST::BooleanLiteral&) -> bool {
+            return matches(*valueType, m_intrinsics.boolType());
+        }, [&](AST::EnumerationMemberLiteral& enumerationMemberLiteral) -> bool {
             ASSERT(enumerationMemberLiteral.enumerationDefinition());
-            success = matches(*valueType, *enumerationMemberLiteral.enumerationDefinition());
+            return matches(*valueType, *enumerationMemberLiteral.enumerationDefinition());
         }));
         if (!success) {
-            setError();
+            setError(Error("Invalid type for switch case.", switchCase.codeLocation()));
             return;
         }
     }
 
     for (size_t i = 0; i < switchStatement.switchCases().size(); ++i) {
@@ -1294,54 +1509,60 @@
 
             if (static_cast<bool>(firstCase.value()) != static_cast<bool>(secondCase.value()))
                 continue;
 
             if (!static_cast<bool>(firstCase.value())) {
-                setError();
+                setError(Error("Cannot define multiple default cases in switch statement.", secondCase.codeLocation()));
                 return;
             }
 
-            bool success = true;
-            firstCase.value()->visit(WTF::makeVisitor([&](AST::IntegerLiteral& firstIntegerLiteral) {
-                secondCase.value()->visit(WTF::makeVisitor([&](AST::IntegerLiteral& secondIntegerLiteral) {
-                    success = firstIntegerLiteral.value() != secondIntegerLiteral.value();
-                }, [&](AST::UnsignedIntegerLiteral& secondUnsignedIntegerLiteral) {
-                    success = static_cast<int64_t>(firstIntegerLiteral.value()) != static_cast<int64_t>(secondUnsignedIntegerLiteral.value());
-                }, [](auto&) {
+            auto success = firstCase.value()->visit(WTF::makeVisitor([&](AST::IntegerLiteral& firstIntegerLiteral) -> bool {
+                return secondCase.value()->visit(WTF::makeVisitor([&](AST::IntegerLiteral& secondIntegerLiteral) -> bool {
+                    return firstIntegerLiteral.value() != secondIntegerLiteral.value();
+                }, [&](AST::UnsignedIntegerLiteral& secondUnsignedIntegerLiteral) -> bool {
+                    return static_cast<int64_t>(firstIntegerLiteral.value()) != static_cast<int64_t>(secondUnsignedIntegerLiteral.value());
+                }, [](auto&) -> bool {
+                    return true;
                 }));
-            }, [&](AST::UnsignedIntegerLiteral& firstUnsignedIntegerLiteral) {
-                secondCase.value()->visit(WTF::makeVisitor([&](AST::IntegerLiteral& secondIntegerLiteral) {
-                    success = static_cast<int64_t>(firstUnsignedIntegerLiteral.value()) != static_cast<int64_t>(secondIntegerLiteral.value());
-                }, [&](AST::UnsignedIntegerLiteral& secondUnsignedIntegerLiteral) {
-                    success = firstUnsignedIntegerLiteral.value() != secondUnsignedIntegerLiteral.value();
-                }, [](auto&) {
+            }, [&](AST::UnsignedIntegerLiteral& firstUnsignedIntegerLiteral) -> bool {
+                return secondCase.value()->visit(WTF::makeVisitor([&](AST::IntegerLiteral& secondIntegerLiteral) -> bool {
+                    return static_cast<int64_t>(firstUnsignedIntegerLiteral.value()) != static_cast<int64_t>(secondIntegerLiteral.value());
+                }, [&](AST::UnsignedIntegerLiteral& secondUnsignedIntegerLiteral) -> bool {
+                    return firstUnsignedIntegerLiteral.value() != secondUnsignedIntegerLiteral.value();
+                }, [](auto&) -> bool {
+                    return true;
                 }));
-            }, [&](AST::EnumerationMemberLiteral& firstEnumerationMemberLiteral) {
-                secondCase.value()->visit(WTF::makeVisitor([&](AST::IntegerLiteral&) {
-                }, [&](AST::EnumerationMemberLiteral& secondEnumerationMemberLiteral) {
+            }, [&](AST::EnumerationMemberLiteral& firstEnumerationMemberLiteral) -> bool {
+                return secondCase.value()->visit(WTF::makeVisitor([&](AST::EnumerationMemberLiteral& secondEnumerationMemberLiteral) -> bool {
                     ASSERT(firstEnumerationMemberLiteral.enumerationMember());
                     ASSERT(secondEnumerationMemberLiteral.enumerationMember());
-                    success = firstEnumerationMemberLiteral.enumerationMember() != secondEnumerationMemberLiteral.enumerationMember();
-                }, [](auto&) {
+                    return firstEnumerationMemberLiteral.enumerationMember() != secondEnumerationMemberLiteral.enumerationMember();
+                }, [](auto&) -> bool {
+                    return true;
                 }));
-            }, [](auto&) {
+            }, [](auto&) -> bool {
+                return true;
             }));
+            if (!success) {
+                setError(Error("Cannot define duplicate case statements in a switch.", secondCase.codeLocation()));
+                return;
+            }
         }
     }
 
     if (!hasDefault) {
         if (is<AST::NativeTypeDeclaration>(*valueType)) {
             HashSet<int64_t> values;
             bool zeroValueExists;
             for (auto& switchCase : switchStatement.switchCases()) {
-                int64_t value;
-                switchCase.value()->visit(WTF::makeVisitor([&](AST::IntegerLiteral& integerLiteral) {
-                    value = integerLiteral.valueForSelectedType();
-                }, [&](AST::UnsignedIntegerLiteral& unsignedIntegerLiteral) {
-                    value = unsignedIntegerLiteral.valueForSelectedType();
-                }, [](auto&) {
+                auto value = switchCase.value()->visit(WTF::makeVisitor([&](AST::IntegerLiteral& integerLiteral) -> int64_t {
+                    return integerLiteral.valueForSelectedType();
+                }, [&](AST::UnsignedIntegerLiteral& unsignedIntegerLiteral) -> int64_t {
+                    return unsignedIntegerLiteral.valueForSelectedType();
+                }, [](auto&) -> int64_t {
                     ASSERT_NOT_REACHED();
+                    return 0;
                 }));
                 if (!value)
                     zeroValueExists = true;
                 else
                     values.add(value);
@@ -1360,15 +1581,14 @@
                     return true;
                 }
                 return false;
             });
             if (!success) {
-                setError();
+                setError(Error("Switch cases must be exhaustive or you must define a default case.", switchStatement.codeLocation()));
                 return;
             }
         } else {
-            ASSERT(is<AST::EnumerationDefinition>(*valueType));
             HashSet<AST::EnumerationMember*> values;
             for (auto& switchCase : switchStatement.switchCases()) {
                 switchCase.value()->visit(WTF::makeVisitor([&](AST::EnumerationMemberLiteral& enumerationMemberLiteral) {
                     ASSERT(enumerationMemberLiteral.enumerationMember());
                     values.add(enumerationMemberLiteral.enumerationMember());
@@ -1376,11 +1596,11 @@
                     ASSERT_NOT_REACHED();
                 }));
             }
             for (auto& enumerationMember : downcast<AST::EnumerationDefinition>(*valueType).enumerationMembers()) {
                 if (!values.contains(&enumerationMember.get())) {
-                    setError();
+                    setError(Error("Switch cases over an enum must be exhaustive or you must define a default case.", switchStatement.codeLocation()));
                     return;
                 }
             }
         }
     }
@@ -1388,11 +1608,11 @@
 
 void Checker::visit(AST::CommaExpression& commaExpression)
 {
     ASSERT(commaExpression.list().size() > 0);
     Visitor::visit(commaExpression);
-    if (error())
+    if (hasError())
         return;
     auto lastInfo = getInfo(commaExpression.list().last());
     forwardType(commaExpression, lastInfo->resolvingType);
 }
 
@@ -1405,15 +1625,15 @@
     auto bodyInfo = recurseAndGetInfo(ternaryExpression.bodyExpression());
     auto elseInfo = recurseAndGetInfo(ternaryExpression.elseExpression());
 
     auto resultType = matchAndCommit(bodyInfo->resolvingType, elseInfo->resolvingType);
     if (!resultType) {
-        setError();
+        setError(Error("lhs and rhs of a ternary expression must match.", ternaryExpression.codeLocation()));
         return;
     }
 
-    assignType(ternaryExpression, WTFMove(*resultType));
+    assignConcreteType(ternaryExpression, *resultType);
 }
 
 void Checker::visit(AST::CallExpression& callExpression)
 {
     Vector<std::reference_wrapper<ResolvingType>> types;
@@ -1422,48 +1642,55 @@
         auto argumentInfo = recurseAndGetInfo(argument);
         if (!argumentInfo)
             return;
         types.uncheckedAppend(argumentInfo->resolvingType);
     }
-    if (callExpression.castReturnType()) {
-        checkErrorAndVisit(callExpression.castReturnType()->get());
-        if (error())
-            return;
-    }
+    // Don't recurse on the castReturnType, because it's guaranteed to be a NamedType, which will get visited later.
+    // We don't want to recurse to the same node twice.
+
+    auto* function = resolveFunction(types, callExpression.name(), callExpression.codeLocation());
+    if (hasError())
+        return;
 
-    ASSERT(callExpression.hasOverloads());
-    auto* function = resolveFunctionOverloadImpl(*callExpression.overloads(), types, callExpression.castReturnType());
     if (!function) {
-        if (auto newFunction = resolveByInstantiation(callExpression, types, m_intrinsics)) {
-            m_program.append(WTFMove(*newFunction));
-            function = &m_program.nativeFunctionDeclarations().last();
+        NameContext& nameContext = m_program.nameContext();
+        auto castTypes = nameContext.getTypes(callExpression.name(), m_currentNameSpace);
+        if (castTypes.size() == 1) {
+            AST::NamedType& castType = castTypes[0].get();
+            function = resolveFunction(types, "operator cast"_str, callExpression.codeLocation(), &castType);
+            if (hasError())
+                return;
+            if (function)
+                callExpression.setCastData(castType);
         }
     }
 
     if (!function) {
-        setError();
+        // FIXME: Add better error messages for why we can't resolve to one of the overrides.
+        // https://bugs.webkit.org/show_bug.cgi?id=200133
+        setError(Error("Cannot resolve function call to a concrete callee. Make sure you are using compatible types.", callExpression.codeLocation()));
         return;
     }
 
     for (size_t i = 0; i < function->parameters().size(); ++i) {
-        if (!matchAndCommit(types[i].get(), *function->parameters()[i].type())) {
-            setError();
+        if (!matchAndCommit(types[i].get(), *function->parameters()[i]->type())) {
+            setError(Error(makeString("Invalid type for parameter number ", i + 1, " in function call."), callExpression.codeLocation()));
             return;
         }
     }
 
     callExpression.setFunction(*function);
 
-    assignType(callExpression, function->type().clone());
+    assignConcreteType(callExpression, function->type());
 }
 
-bool check(Program& program)
+Expected<void, Error> check(Program& program)
 {
     Checker checker(program.intrinsics(), program);
     checker.checkErrorAndVisit(program);
-    if (checker.error())
-        return false;
+    if (checker.hasError())
+        return checker.result();
     return checker.assignTypes();
 }
 
 } // namespace WHLSL
 
